{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Check from \"../Core/Check.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nvar textureResolutionScratch = new Cartesian2();\n/**\n * Gets the GLSL functions needed to retrieve clipping planes from a ClippingPlaneCollection's texture.\n *\n * @param {ClippingPlaneCollection} clippingPlaneCollection ClippingPlaneCollection with a defined texture.\n * @param {Context} context The current rendering context.\n * @returns {String} A string containing GLSL functions for retrieving clipping planes.\n * @private\n */\n\nfunction getClippingFunction(clippingPlaneCollection, context) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"clippingPlaneCollection\", clippingPlaneCollection);\n  Check.typeOf.object(\"context\", context); //>>includeEnd('debug');\n\n  var unionClippingRegions = clippingPlaneCollection.unionClippingRegions;\n  var clippingPlanesLength = clippingPlaneCollection.length;\n  var usingFloatTexture = ClippingPlaneCollection.useFloatTexture(context);\n  var textureResolution = ClippingPlaneCollection.getTextureResolution(clippingPlaneCollection, context, textureResolutionScratch);\n  var width = textureResolution.x;\n  var height = textureResolution.y;\n  var functions = usingFloatTexture ? getClippingPlaneFloat(width, height) : getClippingPlaneUint8(width, height);\n  functions += \"\\n\";\n  functions += unionClippingRegions ? clippingFunctionUnion(clippingPlanesLength) : clippingFunctionIntersect(clippingPlanesLength);\n  return functions;\n}\n\nfunction clippingFunctionUnion(clippingPlanesLength) {\n  var functionString = \"float clip(vec4 fragCoord, sampler2D clippingPlanes, mat4 clippingPlanesMatrix)\\n\" + \"{\\n\" + \"    vec4 position = czm_windowToEyeCoordinates(fragCoord);\\n\" + \"    vec3 clipNormal = vec3(0.0);\\n\" + \"    vec3 clipPosition = vec3(0.0);\\n\" + \"    float clipAmount;\\n\" + // For union planes, we want to get the min distance. So we set the initial value to the first plane distance in the loop below.\n  \"    float pixelWidth = czm_metersPerPixel(position);\\n\" + \"    bool breakAndDiscard = false;\\n\" + \"    for (int i = 0; i < \" + clippingPlanesLength + \"; ++i)\\n\" + \"    {\\n\" + \"        vec4 clippingPlane = getClippingPlane(clippingPlanes, i, clippingPlanesMatrix);\\n\" + \"        clipNormal = clippingPlane.xyz;\\n\" + \"        clipPosition = -clippingPlane.w * clipNormal;\\n\" + \"        float amount = dot(clipNormal, (position.xyz - clipPosition)) / pixelWidth;\\n\" + \"        clipAmount = czm_branchFreeTernary(i == 0, amount, min(amount, clipAmount));\\n\" + \"        if (amount <= 0.0)\\n\" + \"        {\\n\" + \"           breakAndDiscard = true;\\n\" + \"           break;\\n\" + // HLSL compiler bug if we discard here: https://bugs.chromium.org/p/angleproject/issues/detail?id=1945#c6\n  \"        }\\n\" + \"    }\\n\" + \"    if (breakAndDiscard) {\\n\" + \"        discard;\\n\" + \"    }\\n\" + \"    return clipAmount;\\n\" + \"}\\n\";\n  return functionString;\n}\n\nfunction clippingFunctionIntersect(clippingPlanesLength) {\n  var functionString = \"float clip(vec4 fragCoord, sampler2D clippingPlanes, mat4 clippingPlanesMatrix)\\n\" + \"{\\n\" + \"    bool clipped = true;\\n\" + \"    vec4 position = czm_windowToEyeCoordinates(fragCoord);\\n\" + \"    vec3 clipNormal = vec3(0.0);\\n\" + \"    vec3 clipPosition = vec3(0.0);\\n\" + \"    float clipAmount = 0.0;\\n\" + \"    float pixelWidth = czm_metersPerPixel(position);\\n\" + \"    for (int i = 0; i < \" + clippingPlanesLength + \"; ++i)\\n\" + \"    {\\n\" + \"        vec4 clippingPlane = getClippingPlane(clippingPlanes, i, clippingPlanesMatrix);\\n\" + \"        clipNormal = clippingPlane.xyz;\\n\" + \"        clipPosition = -clippingPlane.w * clipNormal;\\n\" + \"        float amount = dot(clipNormal, (position.xyz - clipPosition)) / pixelWidth;\\n\" + \"        clipAmount = max(amount, clipAmount);\\n\" + \"        clipped = clipped && (amount <= 0.0);\\n\" + \"    }\\n\" + \"    if (clipped)\\n\" + \"    {\\n\" + \"        discard;\\n\" + \"    }\\n\" + \"    return clipAmount;\\n\" + \"}\\n\";\n  return functionString;\n}\n\nfunction getClippingPlaneFloat(width, height) {\n  var pixelWidth = 1.0 / width;\n  var pixelHeight = 1.0 / height;\n  var pixelWidthString = pixelWidth + \"\";\n\n  if (pixelWidthString.indexOf(\".\") === -1) {\n    pixelWidthString += \".0\";\n  }\n\n  var pixelHeightString = pixelHeight + \"\";\n\n  if (pixelHeightString.indexOf(\".\") === -1) {\n    pixelHeightString += \".0\";\n  }\n\n  var functionString = \"vec4 getClippingPlane(sampler2D packedClippingPlanes, int clippingPlaneNumber, mat4 transform)\\n\" + \"{\\n\" + \"    int pixY = clippingPlaneNumber / \" + width + \";\\n\" + \"    int pixX = clippingPlaneNumber - (pixY * \" + width + \");\\n\" + \"    float u = (float(pixX) + 0.5) * \" + pixelWidthString + \";\\n\" + // sample from center of pixel\n  \"    float v = (float(pixY) + 0.5) * \" + pixelHeightString + \";\\n\" + \"    vec4 plane = texture2D(packedClippingPlanes, vec2(u, v));\\n\" + \"    return czm_transformPlane(plane, transform);\\n\" + \"}\\n\";\n  return functionString;\n}\n\nfunction getClippingPlaneUint8(width, height) {\n  var pixelWidth = 1.0 / width;\n  var pixelHeight = 1.0 / height;\n  var pixelWidthString = pixelWidth + \"\";\n\n  if (pixelWidthString.indexOf(\".\") === -1) {\n    pixelWidthString += \".0\";\n  }\n\n  var pixelHeightString = pixelHeight + \"\";\n\n  if (pixelHeightString.indexOf(\".\") === -1) {\n    pixelHeightString += \".0\";\n  }\n\n  var functionString = \"vec4 getClippingPlane(sampler2D packedClippingPlanes, int clippingPlaneNumber, mat4 transform)\\n\" + \"{\\n\" + \"    int clippingPlaneStartIndex = clippingPlaneNumber * 2;\\n\" + // clipping planes are two pixels each\n  \"    int pixY = clippingPlaneStartIndex / \" + width + \";\\n\" + \"    int pixX = clippingPlaneStartIndex - (pixY * \" + width + \");\\n\" + \"    float u = (float(pixX) + 0.5) * \" + pixelWidthString + \";\\n\" + // sample from center of pixel\n  \"    float v = (float(pixY) + 0.5) * \" + pixelHeightString + \";\\n\" + \"    vec4 oct32 = texture2D(packedClippingPlanes, vec2(u, v)) * 255.0;\\n\" + \"    vec2 oct = vec2(oct32.x * 256.0 + oct32.y, oct32.z * 256.0 + oct32.w);\\n\" + \"    vec4 plane;\\n\" + \"    plane.xyz = czm_octDecode(oct, 65535.0);\\n\" + \"    plane.w = czm_unpackFloat(texture2D(packedClippingPlanes, vec2(u + \" + pixelWidthString + \", v)));\\n\" + \"    return czm_transformPlane(plane, transform);\\n\" + \"}\\n\";\n  return functionString;\n}\n\nexport default getClippingFunction;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Scene/getClippingFunction.js"],"names":["Cartesian2","Check","ClippingPlaneCollection","textureResolutionScratch","getClippingFunction","clippingPlaneCollection","context","typeOf","object","unionClippingRegions","clippingPlanesLength","length","usingFloatTexture","useFloatTexture","textureResolution","getTextureResolution","width","x","height","y","functions","getClippingPlaneFloat","getClippingPlaneUint8","clippingFunctionUnion","clippingFunctionIntersect","functionString","pixelWidth","pixelHeight","pixelWidthString","indexOf","pixelHeightString"],"mappings":"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","sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Check from \"../Core/Check.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\n\nvar textureResolutionScratch = new Cartesian2();\n/**\n * Gets the GLSL functions needed to retrieve clipping planes from a ClippingPlaneCollection's texture.\n *\n * @param {ClippingPlaneCollection} clippingPlaneCollection ClippingPlaneCollection with a defined texture.\n * @param {Context} context The current rendering context.\n * @returns {String} A string containing GLSL functions for retrieving clipping planes.\n * @private\n */\nfunction getClippingFunction(clippingPlaneCollection, context) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"clippingPlaneCollection\", clippingPlaneCollection);\n  Check.typeOf.object(\"context\", context);\n  //>>includeEnd('debug');\n  var unionClippingRegions = clippingPlaneCollection.unionClippingRegions;\n  var clippingPlanesLength = clippingPlaneCollection.length;\n  var usingFloatTexture = ClippingPlaneCollection.useFloatTexture(context);\n  var textureResolution = ClippingPlaneCollection.getTextureResolution(\n    clippingPlaneCollection,\n    context,\n    textureResolutionScratch\n  );\n  var width = textureResolution.x;\n  var height = textureResolution.y;\n\n  var functions = usingFloatTexture\n    ? getClippingPlaneFloat(width, height)\n    : getClippingPlaneUint8(width, height);\n  functions += \"\\n\";\n  functions += unionClippingRegions\n    ? clippingFunctionUnion(clippingPlanesLength)\n    : clippingFunctionIntersect(clippingPlanesLength);\n  return functions;\n}\n\nfunction clippingFunctionUnion(clippingPlanesLength) {\n  var functionString =\n    \"float clip(vec4 fragCoord, sampler2D clippingPlanes, mat4 clippingPlanesMatrix)\\n\" +\n    \"{\\n\" +\n    \"    vec4 position = czm_windowToEyeCoordinates(fragCoord);\\n\" +\n    \"    vec3 clipNormal = vec3(0.0);\\n\" +\n    \"    vec3 clipPosition = vec3(0.0);\\n\" +\n    \"    float clipAmount;\\n\" + // For union planes, we want to get the min distance. So we set the initial value to the first plane distance in the loop below.\n    \"    float pixelWidth = czm_metersPerPixel(position);\\n\" +\n    \"    bool breakAndDiscard = false;\\n\" +\n    \"    for (int i = 0; i < \" +\n    clippingPlanesLength +\n    \"; ++i)\\n\" +\n    \"    {\\n\" +\n    \"        vec4 clippingPlane = getClippingPlane(clippingPlanes, i, clippingPlanesMatrix);\\n\" +\n    \"        clipNormal = clippingPlane.xyz;\\n\" +\n    \"        clipPosition = -clippingPlane.w * clipNormal;\\n\" +\n    \"        float amount = dot(clipNormal, (position.xyz - clipPosition)) / pixelWidth;\\n\" +\n    \"        clipAmount = czm_branchFreeTernary(i == 0, amount, min(amount, clipAmount));\\n\" +\n    \"        if (amount <= 0.0)\\n\" +\n    \"        {\\n\" +\n    \"           breakAndDiscard = true;\\n\" +\n    \"           break;\\n\" + // HLSL compiler bug if we discard here: https://bugs.chromium.org/p/angleproject/issues/detail?id=1945#c6\n    \"        }\\n\" +\n    \"    }\\n\" +\n    \"    if (breakAndDiscard) {\\n\" +\n    \"        discard;\\n\" +\n    \"    }\\n\" +\n    \"    return clipAmount;\\n\" +\n    \"}\\n\";\n  return functionString;\n}\n\nfunction clippingFunctionIntersect(clippingPlanesLength) {\n  var functionString =\n    \"float clip(vec4 fragCoord, sampler2D clippingPlanes, mat4 clippingPlanesMatrix)\\n\" +\n    \"{\\n\" +\n    \"    bool clipped = true;\\n\" +\n    \"    vec4 position = czm_windowToEyeCoordinates(fragCoord);\\n\" +\n    \"    vec3 clipNormal = vec3(0.0);\\n\" +\n    \"    vec3 clipPosition = vec3(0.0);\\n\" +\n    \"    float clipAmount = 0.0;\\n\" +\n    \"    float pixelWidth = czm_metersPerPixel(position);\\n\" +\n    \"    for (int i = 0; i < \" +\n    clippingPlanesLength +\n    \"; ++i)\\n\" +\n    \"    {\\n\" +\n    \"        vec4 clippingPlane = getClippingPlane(clippingPlanes, i, clippingPlanesMatrix);\\n\" +\n    \"        clipNormal = clippingPlane.xyz;\\n\" +\n    \"        clipPosition = -clippingPlane.w * clipNormal;\\n\" +\n    \"        float amount = dot(clipNormal, (position.xyz - clipPosition)) / pixelWidth;\\n\" +\n    \"        clipAmount = max(amount, clipAmount);\\n\" +\n    \"        clipped = clipped && (amount <= 0.0);\\n\" +\n    \"    }\\n\" +\n    \"    if (clipped)\\n\" +\n    \"    {\\n\" +\n    \"        discard;\\n\" +\n    \"    }\\n\" +\n    \"    return clipAmount;\\n\" +\n    \"}\\n\";\n  return functionString;\n}\n\nfunction getClippingPlaneFloat(width, height) {\n  var pixelWidth = 1.0 / width;\n  var pixelHeight = 1.0 / height;\n\n  var pixelWidthString = pixelWidth + \"\";\n  if (pixelWidthString.indexOf(\".\") === -1) {\n    pixelWidthString += \".0\";\n  }\n  var pixelHeightString = pixelHeight + \"\";\n  if (pixelHeightString.indexOf(\".\") === -1) {\n    pixelHeightString += \".0\";\n  }\n\n  var functionString =\n    \"vec4 getClippingPlane(sampler2D packedClippingPlanes, int clippingPlaneNumber, mat4 transform)\\n\" +\n    \"{\\n\" +\n    \"    int pixY = clippingPlaneNumber / \" +\n    width +\n    \";\\n\" +\n    \"    int pixX = clippingPlaneNumber - (pixY * \" +\n    width +\n    \");\\n\" +\n    \"    float u = (float(pixX) + 0.5) * \" +\n    pixelWidthString +\n    \";\\n\" + // sample from center of pixel\n    \"    float v = (float(pixY) + 0.5) * \" +\n    pixelHeightString +\n    \";\\n\" +\n    \"    vec4 plane = texture2D(packedClippingPlanes, vec2(u, v));\\n\" +\n    \"    return czm_transformPlane(plane, transform);\\n\" +\n    \"}\\n\";\n  return functionString;\n}\n\nfunction getClippingPlaneUint8(width, height) {\n  var pixelWidth = 1.0 / width;\n  var pixelHeight = 1.0 / height;\n\n  var pixelWidthString = pixelWidth + \"\";\n  if (pixelWidthString.indexOf(\".\") === -1) {\n    pixelWidthString += \".0\";\n  }\n  var pixelHeightString = pixelHeight + \"\";\n  if (pixelHeightString.indexOf(\".\") === -1) {\n    pixelHeightString += \".0\";\n  }\n\n  var functionString =\n    \"vec4 getClippingPlane(sampler2D packedClippingPlanes, int clippingPlaneNumber, mat4 transform)\\n\" +\n    \"{\\n\" +\n    \"    int clippingPlaneStartIndex = clippingPlaneNumber * 2;\\n\" + // clipping planes are two pixels each\n    \"    int pixY = clippingPlaneStartIndex / \" +\n    width +\n    \";\\n\" +\n    \"    int pixX = clippingPlaneStartIndex - (pixY * \" +\n    width +\n    \");\\n\" +\n    \"    float u = (float(pixX) + 0.5) * \" +\n    pixelWidthString +\n    \";\\n\" + // sample from center of pixel\n    \"    float v = (float(pixY) + 0.5) * \" +\n    pixelHeightString +\n    \";\\n\" +\n    \"    vec4 oct32 = texture2D(packedClippingPlanes, vec2(u, v)) * 255.0;\\n\" +\n    \"    vec2 oct = vec2(oct32.x * 256.0 + oct32.y, oct32.z * 256.0 + oct32.w);\\n\" +\n    \"    vec4 plane;\\n\" +\n    \"    plane.xyz = czm_octDecode(oct, 65535.0);\\n\" +\n    \"    plane.w = czm_unpackFloat(texture2D(packedClippingPlanes, vec2(u + \" +\n    pixelWidthString +\n    \", v)));\\n\" +\n    \"    return czm_transformPlane(plane, transform);\\n\" +\n    \"}\\n\";\n  return functionString;\n}\nexport default getClippingFunction;\n"]},"metadata":{},"sourceType":"module"}