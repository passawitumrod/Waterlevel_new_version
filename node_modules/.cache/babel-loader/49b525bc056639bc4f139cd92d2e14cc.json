{"ast":null,"code":"import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nvar scratchPosition = new Cartesian3();\nvar scratchNormal = new Cartesian3();\nvar scratchTangent = new Cartesian3();\nvar scratchBitangent = new Cartesian3();\nvar scratchNormalST = new Cartesian3();\nvar defaultRadii = new Cartesian3(1.0, 1.0, 1.0);\nvar cos = Math.cos;\nvar sin = Math.sin;\n/**\n * A description of an ellipsoid centered at the origin.\n *\n * @alias EllipsoidGeometry\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Cartesian3} [options.radii=Cartesian3(1.0, 1.0, 1.0)] The radii of the ellipsoid in the x, y, and z directions.\n * @param {Cartesian3} [options.innerRadii=options.radii] The inner radii of the ellipsoid in the x, y, and z directions.\n * @param {Number} [options.minimumClock=0.0] The minimum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {Number} [options.maximumClock=2*PI] The maximum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {Number} [options.minimumCone=0.0] The minimum angle measured from the positive z-axis and toward the negative z-axis.\n * @param {Number} [options.maximumCone=PI] The maximum angle measured from the positive z-axis and toward the negative z-axis.\n * @param {Number} [options.stackPartitions=64] The number of times to partition the ellipsoid into stacks.\n * @param {Number} [options.slicePartitions=64] The number of times to partition the ellipsoid into radial slices.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @exception {DeveloperError} options.slicePartitions cannot be less than three.\n * @exception {DeveloperError} options.stackPartitions cannot be less than three.\n *\n * @see EllipsoidGeometry#createGeometry\n *\n * @example\n * var ellipsoid = new Cesium.EllipsoidGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   radii : new Cesium.Cartesian3(1000000.0, 500000.0, 500000.0)\n * });\n * var geometry = Cesium.EllipsoidGeometry.createGeometry(ellipsoid);\n */\n\nfunction EllipsoidGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var radii = defaultValue(options.radii, defaultRadii);\n  var innerRadii = defaultValue(options.innerRadii, radii);\n  var minimumClock = defaultValue(options.minimumClock, 0.0);\n  var maximumClock = defaultValue(options.maximumClock, CesiumMath.TWO_PI);\n  var minimumCone = defaultValue(options.minimumCone, 0.0);\n  var maximumCone = defaultValue(options.maximumCone, CesiumMath.PI);\n  var stackPartitions = Math.round(defaultValue(options.stackPartitions, 64));\n  var slicePartitions = Math.round(defaultValue(options.slicePartitions, 64));\n  var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT); //>>includeStart('debug', pragmas.debug);\n\n  if (slicePartitions < 3) {\n    throw new DeveloperError(\"options.slicePartitions cannot be less than three.\");\n  }\n\n  if (stackPartitions < 3) {\n    throw new DeveloperError(\"options.stackPartitions cannot be less than three.\");\n  } //>>includeEnd('debug');\n\n\n  this._radii = Cartesian3.clone(radii);\n  this._innerRadii = Cartesian3.clone(innerRadii);\n  this._minimumClock = minimumClock;\n  this._maximumClock = maximumClock;\n  this._minimumCone = minimumCone;\n  this._maximumCone = maximumCone;\n  this._stackPartitions = stackPartitions;\n  this._slicePartitions = slicePartitions;\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createEllipsoidGeometry\";\n}\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\n\n\nEllipsoidGeometry.packedLength = 2 * Cartesian3.packedLength + VertexFormat.packedLength + 7;\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipsoidGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\nEllipsoidGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  } //>>includeEnd('debug');\n\n\n  startingIndex = defaultValue(startingIndex, 0);\n  Cartesian3.pack(value._radii, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n  Cartesian3.pack(value._innerRadii, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n  array[startingIndex++] = value._minimumClock;\n  array[startingIndex++] = value._maximumClock;\n  array[startingIndex++] = value._minimumCone;\n  array[startingIndex++] = value._maximumCone;\n  array[startingIndex++] = value._stackPartitions;\n  array[startingIndex++] = value._slicePartitions;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n  return array;\n};\n\nvar scratchRadii = new Cartesian3();\nvar scratchInnerRadii = new Cartesian3();\nvar scratchVertexFormat = new VertexFormat();\nvar scratchOptions = {\n  radii: scratchRadii,\n  innerRadii: scratchInnerRadii,\n  vertexFormat: scratchVertexFormat,\n  minimumClock: undefined,\n  maximumClock: undefined,\n  minimumCone: undefined,\n  maximumCone: undefined,\n  stackPartitions: undefined,\n  slicePartitions: undefined,\n  offsetAttribute: undefined\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipsoidGeometry} [result] The object into which to store the result.\n * @returns {EllipsoidGeometry} The modified result parameter or a new EllipsoidGeometry instance if one was not provided.\n */\n\nEllipsoidGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  } //>>includeEnd('debug');\n\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var radii = Cartesian3.unpack(array, startingIndex, scratchRadii);\n  startingIndex += Cartesian3.packedLength;\n  var innerRadii = Cartesian3.unpack(array, startingIndex, scratchInnerRadii);\n  startingIndex += Cartesian3.packedLength;\n  var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n  startingIndex += VertexFormat.packedLength;\n  var minimumClock = array[startingIndex++];\n  var maximumClock = array[startingIndex++];\n  var minimumCone = array[startingIndex++];\n  var maximumCone = array[startingIndex++];\n  var stackPartitions = array[startingIndex++];\n  var slicePartitions = array[startingIndex++];\n  var offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.minimumClock = minimumClock;\n    scratchOptions.maximumClock = maximumClock;\n    scratchOptions.minimumCone = minimumCone;\n    scratchOptions.maximumCone = maximumCone;\n    scratchOptions.stackPartitions = stackPartitions;\n    scratchOptions.slicePartitions = slicePartitions;\n    scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new EllipsoidGeometry(scratchOptions);\n  }\n\n  result._radii = Cartesian3.clone(radii, result._radii);\n  result._innerRadii = Cartesian3.clone(innerRadii, result._innerRadii);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._minimumClock = minimumClock;\n  result._maximumClock = maximumClock;\n  result._minimumCone = minimumCone;\n  result._maximumCone = maximumCone;\n  result._stackPartitions = stackPartitions;\n  result._slicePartitions = slicePartitions;\n  result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n  return result;\n};\n/**\n * Computes the geometric representation of an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipsoidGeometry} ellipsoidGeometry A description of the ellipsoid.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\n\n\nEllipsoidGeometry.createGeometry = function (ellipsoidGeometry) {\n  var radii = ellipsoidGeometry._radii;\n\n  if (radii.x <= 0 || radii.y <= 0 || radii.z <= 0) {\n    return;\n  }\n\n  var innerRadii = ellipsoidGeometry._innerRadii;\n\n  if (innerRadii.x <= 0 || innerRadii.y <= 0 || innerRadii.z <= 0) {\n    return;\n  }\n\n  var minimumClock = ellipsoidGeometry._minimumClock;\n  var maximumClock = ellipsoidGeometry._maximumClock;\n  var minimumCone = ellipsoidGeometry._minimumCone;\n  var maximumCone = ellipsoidGeometry._maximumCone;\n  var vertexFormat = ellipsoidGeometry._vertexFormat; // Add an extra slice and stack so that the number of partitions is the\n  // number of surfaces rather than the number of joints\n\n  var slicePartitions = ellipsoidGeometry._slicePartitions + 1;\n  var stackPartitions = ellipsoidGeometry._stackPartitions + 1;\n  slicePartitions = Math.round(slicePartitions * Math.abs(maximumClock - minimumClock) / CesiumMath.TWO_PI);\n  stackPartitions = Math.round(stackPartitions * Math.abs(maximumCone - minimumCone) / CesiumMath.PI);\n\n  if (slicePartitions < 2) {\n    slicePartitions = 2;\n  }\n\n  if (stackPartitions < 2) {\n    stackPartitions = 2;\n  }\n\n  var i;\n  var j;\n  var index = 0; // Create arrays for theta and phi. Duplicate first and last angle to\n  // allow different normals at the intersections.\n\n  var phis = [minimumCone];\n  var thetas = [minimumClock];\n\n  for (i = 0; i < stackPartitions; i++) {\n    phis.push(minimumCone + i * (maximumCone - minimumCone) / (stackPartitions - 1));\n  }\n\n  phis.push(maximumCone);\n\n  for (j = 0; j < slicePartitions; j++) {\n    thetas.push(minimumClock + j * (maximumClock - minimumClock) / (slicePartitions - 1));\n  }\n\n  thetas.push(maximumClock);\n  var numPhis = phis.length;\n  var numThetas = thetas.length; // Allow for extra indices if there is an inner surface and if we need\n  // to close the sides if the clock range is not a full circle\n\n  var extraIndices = 0;\n  var vertexMultiplier = 1.0;\n  var hasInnerSurface = innerRadii.x !== radii.x || innerRadii.y !== radii.y || innerRadii.z !== radii.z;\n  var isTopOpen = false;\n  var isBotOpen = false;\n  var isClockOpen = false;\n\n  if (hasInnerSurface) {\n    vertexMultiplier = 2.0;\n\n    if (minimumCone > 0.0) {\n      isTopOpen = true;\n      extraIndices += slicePartitions - 1;\n    }\n\n    if (maximumCone < Math.PI) {\n      isBotOpen = true;\n      extraIndices += slicePartitions - 1;\n    }\n\n    if ((maximumClock - minimumClock) % CesiumMath.TWO_PI) {\n      isClockOpen = true;\n      extraIndices += (stackPartitions - 1) * 2 + 1;\n    } else {\n      extraIndices += 1;\n    }\n  }\n\n  var vertexCount = numThetas * numPhis * vertexMultiplier;\n  var positions = new Float64Array(vertexCount * 3);\n  var isInner = arrayFill(new Array(vertexCount), false);\n  var negateNormal = arrayFill(new Array(vertexCount), false); // Multiply by 6 because there are two triangles per sector\n\n  var indexCount = slicePartitions * stackPartitions * vertexMultiplier;\n  var numIndices = 6 * (indexCount + extraIndices + 1 - (slicePartitions + stackPartitions) * vertexMultiplier);\n  var indices = IndexDatatype.createTypedArray(indexCount, numIndices);\n  var normals = vertexFormat.normal ? new Float32Array(vertexCount * 3) : undefined;\n  var tangents = vertexFormat.tangent ? new Float32Array(vertexCount * 3) : undefined;\n  var bitangents = vertexFormat.bitangent ? new Float32Array(vertexCount * 3) : undefined;\n  var st = vertexFormat.st ? new Float32Array(vertexCount * 2) : undefined; // Calculate sin/cos phi\n\n  var sinPhi = new Array(numPhis);\n  var cosPhi = new Array(numPhis);\n\n  for (i = 0; i < numPhis; i++) {\n    sinPhi[i] = sin(phis[i]);\n    cosPhi[i] = cos(phis[i]);\n  } // Calculate sin/cos theta\n\n\n  var sinTheta = new Array(numThetas);\n  var cosTheta = new Array(numThetas);\n\n  for (j = 0; j < numThetas; j++) {\n    cosTheta[j] = cos(thetas[j]);\n    sinTheta[j] = sin(thetas[j]);\n  } // Create outer surface\n\n\n  for (i = 0; i < numPhis; i++) {\n    for (j = 0; j < numThetas; j++) {\n      positions[index++] = radii.x * sinPhi[i] * cosTheta[j];\n      positions[index++] = radii.y * sinPhi[i] * sinTheta[j];\n      positions[index++] = radii.z * cosPhi[i];\n    }\n  } // Create inner surface\n\n\n  var vertexIndex = vertexCount / 2.0;\n\n  if (hasInnerSurface) {\n    for (i = 0; i < numPhis; i++) {\n      for (j = 0; j < numThetas; j++) {\n        positions[index++] = innerRadii.x * sinPhi[i] * cosTheta[j];\n        positions[index++] = innerRadii.y * sinPhi[i] * sinTheta[j];\n        positions[index++] = innerRadii.z * cosPhi[i]; // Keep track of which vertices are the inner and which ones\n        // need the normal to be negated\n\n        isInner[vertexIndex] = true;\n\n        if (i > 0 && i !== numPhis - 1 && j !== 0 && j !== numThetas - 1) {\n          negateNormal[vertexIndex] = true;\n        }\n\n        vertexIndex++;\n      }\n    }\n  } // Create indices for outer surface\n\n\n  index = 0;\n  var topOffset;\n  var bottomOffset;\n\n  for (i = 1; i < numPhis - 2; i++) {\n    topOffset = i * numThetas;\n    bottomOffset = (i + 1) * numThetas;\n\n    for (j = 1; j < numThetas - 2; j++) {\n      indices[index++] = bottomOffset + j;\n      indices[index++] = bottomOffset + j + 1;\n      indices[index++] = topOffset + j + 1;\n      indices[index++] = bottomOffset + j;\n      indices[index++] = topOffset + j + 1;\n      indices[index++] = topOffset + j;\n    }\n  } // Create indices for inner surface\n\n\n  if (hasInnerSurface) {\n    var offset = numPhis * numThetas;\n\n    for (i = 1; i < numPhis - 2; i++) {\n      topOffset = offset + i * numThetas;\n      bottomOffset = offset + (i + 1) * numThetas;\n\n      for (j = 1; j < numThetas - 2; j++) {\n        indices[index++] = bottomOffset + j;\n        indices[index++] = topOffset + j;\n        indices[index++] = topOffset + j + 1;\n        indices[index++] = bottomOffset + j;\n        indices[index++] = topOffset + j + 1;\n        indices[index++] = bottomOffset + j + 1;\n      }\n    }\n  }\n\n  var outerOffset;\n  var innerOffset;\n\n  if (hasInnerSurface) {\n    if (isTopOpen) {\n      // Connect the top of the inner surface to the top of the outer surface\n      innerOffset = numPhis * numThetas;\n\n      for (i = 1; i < numThetas - 2; i++) {\n        indices[index++] = i;\n        indices[index++] = i + 1;\n        indices[index++] = innerOffset + i + 1;\n        indices[index++] = i;\n        indices[index++] = innerOffset + i + 1;\n        indices[index++] = innerOffset + i;\n      }\n    }\n\n    if (isBotOpen) {\n      // Connect the bottom of the inner surface to the bottom of the outer surface\n      outerOffset = numPhis * numThetas - numThetas;\n      innerOffset = numPhis * numThetas * vertexMultiplier - numThetas;\n\n      for (i = 1; i < numThetas - 2; i++) {\n        indices[index++] = outerOffset + i + 1;\n        indices[index++] = outerOffset + i;\n        indices[index++] = innerOffset + i;\n        indices[index++] = outerOffset + i + 1;\n        indices[index++] = innerOffset + i;\n        indices[index++] = innerOffset + i + 1;\n      }\n    }\n  } // Connect the edges if clock is not closed\n\n\n  if (isClockOpen) {\n    for (i = 1; i < numPhis - 2; i++) {\n      innerOffset = numThetas * numPhis + numThetas * i;\n      outerOffset = numThetas * i;\n      indices[index++] = innerOffset;\n      indices[index++] = outerOffset + numThetas;\n      indices[index++] = outerOffset;\n      indices[index++] = innerOffset;\n      indices[index++] = innerOffset + numThetas;\n      indices[index++] = outerOffset + numThetas;\n    }\n\n    for (i = 1; i < numPhis - 2; i++) {\n      innerOffset = numThetas * numPhis + numThetas * (i + 1) - 1;\n      outerOffset = numThetas * (i + 1) - 1;\n      indices[index++] = outerOffset + numThetas;\n      indices[index++] = innerOffset;\n      indices[index++] = outerOffset;\n      indices[index++] = outerOffset + numThetas;\n      indices[index++] = innerOffset + numThetas;\n      indices[index++] = innerOffset;\n    }\n  }\n\n  var attributes = new GeometryAttributes();\n\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions\n    });\n  }\n\n  var stIndex = 0;\n  var normalIndex = 0;\n  var tangentIndex = 0;\n  var bitangentIndex = 0;\n  var vertexCountHalf = vertexCount / 2.0;\n  var ellipsoid;\n  var ellipsoidOuter = Ellipsoid.fromCartesian3(radii);\n  var ellipsoidInner = Ellipsoid.fromCartesian3(innerRadii);\n\n  if (vertexFormat.st || vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n    for (i = 0; i < vertexCount; i++) {\n      ellipsoid = isInner[i] ? ellipsoidInner : ellipsoidOuter;\n      var position = Cartesian3.fromArray(positions, i * 3, scratchPosition);\n      var normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\n\n      if (negateNormal[i]) {\n        Cartesian3.negate(normal, normal);\n      }\n\n      if (vertexFormat.st) {\n        var normalST = Cartesian2.negate(normal, scratchNormalST);\n        st[stIndex++] = Math.atan2(normalST.y, normalST.x) / CesiumMath.TWO_PI + 0.5;\n        st[stIndex++] = Math.asin(normal.z) / Math.PI + 0.5;\n      }\n\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = normal.x;\n        normals[normalIndex++] = normal.y;\n        normals[normalIndex++] = normal.z;\n      }\n\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\n        var tangent = scratchTangent; // Use UNIT_X for the poles\n\n        var tangetOffset = 0;\n        var unit;\n\n        if (isInner[i]) {\n          tangetOffset = vertexCountHalf;\n        }\n\n        if (!isTopOpen && i >= tangetOffset && i < tangetOffset + numThetas * 2) {\n          unit = Cartesian3.UNIT_X;\n        } else {\n          unit = Cartesian3.UNIT_Z;\n        }\n\n        Cartesian3.cross(unit, normal, tangent);\n        Cartesian3.normalize(tangent, tangent);\n\n        if (vertexFormat.tangent) {\n          tangents[tangentIndex++] = tangent.x;\n          tangents[tangentIndex++] = tangent.y;\n          tangents[tangentIndex++] = tangent.z;\n        }\n\n        if (vertexFormat.bitangent) {\n          var bitangent = Cartesian3.cross(normal, tangent, scratchBitangent);\n          Cartesian3.normalize(bitangent, bitangent);\n          bitangents[bitangentIndex++] = bitangent.x;\n          bitangents[bitangentIndex++] = bitangent.y;\n          bitangents[bitangentIndex++] = bitangent.z;\n        }\n      }\n    }\n\n    if (vertexFormat.st) {\n      attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: st\n      });\n    }\n\n    if (vertexFormat.normal) {\n      attributes.normal = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: normals\n      });\n    }\n\n    if (vertexFormat.tangent) {\n      attributes.tangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: tangents\n      });\n    }\n\n    if (vertexFormat.bitangent) {\n      attributes.bitangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: bitangents\n      });\n    }\n  }\n\n  if (defined(ellipsoidGeometry._offsetAttribute)) {\n    var length = positions.length;\n    var applyOffset = new Uint8Array(length / 3);\n    var offsetValue = ellipsoidGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n    arrayFill(applyOffset, offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: BoundingSphere.fromEllipsoid(ellipsoidOuter),\n    offsetAttribute: ellipsoidGeometry._offsetAttribute\n  });\n};\n\nvar unitEllipsoidGeometry;\n/**\n * Returns the geometric representation of a unit ellipsoid, including its vertices, indices, and a bounding sphere.\n * @returns {Geometry} The computed vertices and indices.\n *\n * @private\n */\n\nEllipsoidGeometry.getUnitEllipsoid = function () {\n  if (!defined(unitEllipsoidGeometry)) {\n    unitEllipsoidGeometry = EllipsoidGeometry.createGeometry(new EllipsoidGeometry({\n      radii: new Cartesian3(1.0, 1.0, 1.0),\n      vertexFormat: VertexFormat.POSITION_ONLY\n    }));\n  }\n\n  return unitEllipsoidGeometry;\n};\n\nexport default EllipsoidGeometry;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/EllipsoidGeometry.js"],"names":["arrayFill","BoundingSphere","Cartesian2","Cartesian3","ComponentDatatype","defaultValue","defined","DeveloperError","Ellipsoid","Geometry","GeometryAttribute","GeometryAttributes","GeometryOffsetAttribute","IndexDatatype","CesiumMath","PrimitiveType","VertexFormat","scratchPosition","scratchNormal","scratchTangent","scratchBitangent","scratchNormalST","defaultRadii","cos","Math","sin","EllipsoidGeometry","options","EMPTY_OBJECT","radii","innerRadii","minimumClock","maximumClock","TWO_PI","minimumCone","maximumCone","PI","stackPartitions","round","slicePartitions","vertexFormat","DEFAULT","_radii","clone","_innerRadii","_minimumClock","_maximumClock","_minimumCone","_maximumCone","_stackPartitions","_slicePartitions","_vertexFormat","_offsetAttribute","offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","scratchRadii","scratchInnerRadii","scratchVertexFormat","scratchOptions","undefined","unpack","result","createGeometry","ellipsoidGeometry","x","y","z","abs","i","j","index","phis","thetas","push","numPhis","length","numThetas","extraIndices","vertexMultiplier","hasInnerSurface","isTopOpen","isBotOpen","isClockOpen","vertexCount","positions","Float64Array","isInner","Array","negateNormal","indexCount","numIndices","indices","createTypedArray","normals","normal","Float32Array","tangents","tangent","bitangents","bitangent","st","sinPhi","cosPhi","sinTheta","cosTheta","vertexIndex","topOffset","bottomOffset","offset","outerOffset","innerOffset","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","stIndex","normalIndex","tangentIndex","bitangentIndex","vertexCountHalf","ellipsoid","ellipsoidOuter","fromCartesian3","ellipsoidInner","fromArray","geodeticSurfaceNormal","negate","normalST","atan2","asin","tangetOffset","unit","UNIT_X","UNIT_Z","cross","normalize","FLOAT","applyOffset","Uint8Array","offsetValue","NONE","UNSIGNED_BYTE","primitiveType","TRIANGLES","boundingSphere","fromEllipsoid","unitEllipsoidGeometry","getUnitEllipsoid","POSITION_ONLY"],"mappings":"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","sourcesContent":["import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nvar scratchPosition = new Cartesian3();\nvar scratchNormal = new Cartesian3();\nvar scratchTangent = new Cartesian3();\nvar scratchBitangent = new Cartesian3();\nvar scratchNormalST = new Cartesian3();\nvar defaultRadii = new Cartesian3(1.0, 1.0, 1.0);\n\nvar cos = Math.cos;\nvar sin = Math.sin;\n\n/**\n * A description of an ellipsoid centered at the origin.\n *\n * @alias EllipsoidGeometry\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Cartesian3} [options.radii=Cartesian3(1.0, 1.0, 1.0)] The radii of the ellipsoid in the x, y, and z directions.\n * @param {Cartesian3} [options.innerRadii=options.radii] The inner radii of the ellipsoid in the x, y, and z directions.\n * @param {Number} [options.minimumClock=0.0] The minimum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {Number} [options.maximumClock=2*PI] The maximum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {Number} [options.minimumCone=0.0] The minimum angle measured from the positive z-axis and toward the negative z-axis.\n * @param {Number} [options.maximumCone=PI] The maximum angle measured from the positive z-axis and toward the negative z-axis.\n * @param {Number} [options.stackPartitions=64] The number of times to partition the ellipsoid into stacks.\n * @param {Number} [options.slicePartitions=64] The number of times to partition the ellipsoid into radial slices.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @exception {DeveloperError} options.slicePartitions cannot be less than three.\n * @exception {DeveloperError} options.stackPartitions cannot be less than three.\n *\n * @see EllipsoidGeometry#createGeometry\n *\n * @example\n * var ellipsoid = new Cesium.EllipsoidGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   radii : new Cesium.Cartesian3(1000000.0, 500000.0, 500000.0)\n * });\n * var geometry = Cesium.EllipsoidGeometry.createGeometry(ellipsoid);\n */\nfunction EllipsoidGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var radii = defaultValue(options.radii, defaultRadii);\n  var innerRadii = defaultValue(options.innerRadii, radii);\n  var minimumClock = defaultValue(options.minimumClock, 0.0);\n  var maximumClock = defaultValue(options.maximumClock, CesiumMath.TWO_PI);\n  var minimumCone = defaultValue(options.minimumCone, 0.0);\n  var maximumCone = defaultValue(options.maximumCone, CesiumMath.PI);\n  var stackPartitions = Math.round(defaultValue(options.stackPartitions, 64));\n  var slicePartitions = Math.round(defaultValue(options.slicePartitions, 64));\n  var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (slicePartitions < 3) {\n    throw new DeveloperError(\n      \"options.slicePartitions cannot be less than three.\"\n    );\n  }\n  if (stackPartitions < 3) {\n    throw new DeveloperError(\n      \"options.stackPartitions cannot be less than three.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._radii = Cartesian3.clone(radii);\n  this._innerRadii = Cartesian3.clone(innerRadii);\n  this._minimumClock = minimumClock;\n  this._maximumClock = maximumClock;\n  this._minimumCone = minimumCone;\n  this._maximumCone = maximumCone;\n  this._stackPartitions = stackPartitions;\n  this._slicePartitions = slicePartitions;\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createEllipsoidGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nEllipsoidGeometry.packedLength =\n  2 * Cartesian3.packedLength + VertexFormat.packedLength + 7;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipsoidGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nEllipsoidGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value._radii, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n\n  Cartesian3.pack(value._innerRadii, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._minimumClock;\n  array[startingIndex++] = value._maximumClock;\n  array[startingIndex++] = value._minimumCone;\n  array[startingIndex++] = value._maximumCone;\n  array[startingIndex++] = value._stackPartitions;\n  array[startingIndex++] = value._slicePartitions;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nvar scratchRadii = new Cartesian3();\nvar scratchInnerRadii = new Cartesian3();\nvar scratchVertexFormat = new VertexFormat();\nvar scratchOptions = {\n  radii: scratchRadii,\n  innerRadii: scratchInnerRadii,\n  vertexFormat: scratchVertexFormat,\n  minimumClock: undefined,\n  maximumClock: undefined,\n  minimumCone: undefined,\n  maximumCone: undefined,\n  stackPartitions: undefined,\n  slicePartitions: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipsoidGeometry} [result] The object into which to store the result.\n * @returns {EllipsoidGeometry} The modified result parameter or a new EllipsoidGeometry instance if one was not provided.\n */\nEllipsoidGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var radii = Cartesian3.unpack(array, startingIndex, scratchRadii);\n  startingIndex += Cartesian3.packedLength;\n\n  var innerRadii = Cartesian3.unpack(array, startingIndex, scratchInnerRadii);\n  startingIndex += Cartesian3.packedLength;\n\n  var vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  var minimumClock = array[startingIndex++];\n  var maximumClock = array[startingIndex++];\n  var minimumCone = array[startingIndex++];\n  var maximumCone = array[startingIndex++];\n  var stackPartitions = array[startingIndex++];\n  var slicePartitions = array[startingIndex++];\n  var offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.minimumClock = minimumClock;\n    scratchOptions.maximumClock = maximumClock;\n    scratchOptions.minimumCone = minimumCone;\n    scratchOptions.maximumCone = maximumCone;\n    scratchOptions.stackPartitions = stackPartitions;\n    scratchOptions.slicePartitions = slicePartitions;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new EllipsoidGeometry(scratchOptions);\n  }\n\n  result._radii = Cartesian3.clone(radii, result._radii);\n  result._innerRadii = Cartesian3.clone(innerRadii, result._innerRadii);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._minimumClock = minimumClock;\n  result._maximumClock = maximumClock;\n  result._minimumCone = minimumCone;\n  result._maximumCone = maximumCone;\n  result._stackPartitions = stackPartitions;\n  result._slicePartitions = slicePartitions;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipsoidGeometry} ellipsoidGeometry A description of the ellipsoid.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nEllipsoidGeometry.createGeometry = function (ellipsoidGeometry) {\n  var radii = ellipsoidGeometry._radii;\n  if (radii.x <= 0 || radii.y <= 0 || radii.z <= 0) {\n    return;\n  }\n\n  var innerRadii = ellipsoidGeometry._innerRadii;\n  if (innerRadii.x <= 0 || innerRadii.y <= 0 || innerRadii.z <= 0) {\n    return;\n  }\n\n  var minimumClock = ellipsoidGeometry._minimumClock;\n  var maximumClock = ellipsoidGeometry._maximumClock;\n  var minimumCone = ellipsoidGeometry._minimumCone;\n  var maximumCone = ellipsoidGeometry._maximumCone;\n  var vertexFormat = ellipsoidGeometry._vertexFormat;\n\n  // Add an extra slice and stack so that the number of partitions is the\n  // number of surfaces rather than the number of joints\n  var slicePartitions = ellipsoidGeometry._slicePartitions + 1;\n  var stackPartitions = ellipsoidGeometry._stackPartitions + 1;\n\n  slicePartitions = Math.round(\n    (slicePartitions * Math.abs(maximumClock - minimumClock)) /\n      CesiumMath.TWO_PI\n  );\n  stackPartitions = Math.round(\n    (stackPartitions * Math.abs(maximumCone - minimumCone)) / CesiumMath.PI\n  );\n\n  if (slicePartitions < 2) {\n    slicePartitions = 2;\n  }\n  if (stackPartitions < 2) {\n    stackPartitions = 2;\n  }\n\n  var i;\n  var j;\n  var index = 0;\n\n  // Create arrays for theta and phi. Duplicate first and last angle to\n  // allow different normals at the intersections.\n  var phis = [minimumCone];\n  var thetas = [minimumClock];\n  for (i = 0; i < stackPartitions; i++) {\n    phis.push(\n      minimumCone + (i * (maximumCone - minimumCone)) / (stackPartitions - 1)\n    );\n  }\n  phis.push(maximumCone);\n  for (j = 0; j < slicePartitions; j++) {\n    thetas.push(\n      minimumClock + (j * (maximumClock - minimumClock)) / (slicePartitions - 1)\n    );\n  }\n  thetas.push(maximumClock);\n  var numPhis = phis.length;\n  var numThetas = thetas.length;\n\n  // Allow for extra indices if there is an inner surface and if we need\n  // to close the sides if the clock range is not a full circle\n  var extraIndices = 0;\n  var vertexMultiplier = 1.0;\n  var hasInnerSurface =\n    innerRadii.x !== radii.x ||\n    innerRadii.y !== radii.y ||\n    innerRadii.z !== radii.z;\n  var isTopOpen = false;\n  var isBotOpen = false;\n  var isClockOpen = false;\n  if (hasInnerSurface) {\n    vertexMultiplier = 2.0;\n    if (minimumCone > 0.0) {\n      isTopOpen = true;\n      extraIndices += slicePartitions - 1;\n    }\n    if (maximumCone < Math.PI) {\n      isBotOpen = true;\n      extraIndices += slicePartitions - 1;\n    }\n    if ((maximumClock - minimumClock) % CesiumMath.TWO_PI) {\n      isClockOpen = true;\n      extraIndices += (stackPartitions - 1) * 2 + 1;\n    } else {\n      extraIndices += 1;\n    }\n  }\n\n  var vertexCount = numThetas * numPhis * vertexMultiplier;\n  var positions = new Float64Array(vertexCount * 3);\n  var isInner = arrayFill(new Array(vertexCount), false);\n  var negateNormal = arrayFill(new Array(vertexCount), false);\n\n  // Multiply by 6 because there are two triangles per sector\n  var indexCount = slicePartitions * stackPartitions * vertexMultiplier;\n  var numIndices =\n    6 *\n    (indexCount +\n      extraIndices +\n      1 -\n      (slicePartitions + stackPartitions) * vertexMultiplier);\n  var indices = IndexDatatype.createTypedArray(indexCount, numIndices);\n\n  var normals = vertexFormat.normal\n    ? new Float32Array(vertexCount * 3)\n    : undefined;\n  var tangents = vertexFormat.tangent\n    ? new Float32Array(vertexCount * 3)\n    : undefined;\n  var bitangents = vertexFormat.bitangent\n    ? new Float32Array(vertexCount * 3)\n    : undefined;\n  var st = vertexFormat.st ? new Float32Array(vertexCount * 2) : undefined;\n\n  // Calculate sin/cos phi\n  var sinPhi = new Array(numPhis);\n  var cosPhi = new Array(numPhis);\n  for (i = 0; i < numPhis; i++) {\n    sinPhi[i] = sin(phis[i]);\n    cosPhi[i] = cos(phis[i]);\n  }\n\n  // Calculate sin/cos theta\n  var sinTheta = new Array(numThetas);\n  var cosTheta = new Array(numThetas);\n  for (j = 0; j < numThetas; j++) {\n    cosTheta[j] = cos(thetas[j]);\n    sinTheta[j] = sin(thetas[j]);\n  }\n\n  // Create outer surface\n  for (i = 0; i < numPhis; i++) {\n    for (j = 0; j < numThetas; j++) {\n      positions[index++] = radii.x * sinPhi[i] * cosTheta[j];\n      positions[index++] = radii.y * sinPhi[i] * sinTheta[j];\n      positions[index++] = radii.z * cosPhi[i];\n    }\n  }\n\n  // Create inner surface\n  var vertexIndex = vertexCount / 2.0;\n  if (hasInnerSurface) {\n    for (i = 0; i < numPhis; i++) {\n      for (j = 0; j < numThetas; j++) {\n        positions[index++] = innerRadii.x * sinPhi[i] * cosTheta[j];\n        positions[index++] = innerRadii.y * sinPhi[i] * sinTheta[j];\n        positions[index++] = innerRadii.z * cosPhi[i];\n\n        // Keep track of which vertices are the inner and which ones\n        // need the normal to be negated\n        isInner[vertexIndex] = true;\n        if (i > 0 && i !== numPhis - 1 && j !== 0 && j !== numThetas - 1) {\n          negateNormal[vertexIndex] = true;\n        }\n        vertexIndex++;\n      }\n    }\n  }\n\n  // Create indices for outer surface\n  index = 0;\n  var topOffset;\n  var bottomOffset;\n  for (i = 1; i < numPhis - 2; i++) {\n    topOffset = i * numThetas;\n    bottomOffset = (i + 1) * numThetas;\n\n    for (j = 1; j < numThetas - 2; j++) {\n      indices[index++] = bottomOffset + j;\n      indices[index++] = bottomOffset + j + 1;\n      indices[index++] = topOffset + j + 1;\n\n      indices[index++] = bottomOffset + j;\n      indices[index++] = topOffset + j + 1;\n      indices[index++] = topOffset + j;\n    }\n  }\n\n  // Create indices for inner surface\n  if (hasInnerSurface) {\n    var offset = numPhis * numThetas;\n    for (i = 1; i < numPhis - 2; i++) {\n      topOffset = offset + i * numThetas;\n      bottomOffset = offset + (i + 1) * numThetas;\n\n      for (j = 1; j < numThetas - 2; j++) {\n        indices[index++] = bottomOffset + j;\n        indices[index++] = topOffset + j;\n        indices[index++] = topOffset + j + 1;\n\n        indices[index++] = bottomOffset + j;\n        indices[index++] = topOffset + j + 1;\n        indices[index++] = bottomOffset + j + 1;\n      }\n    }\n  }\n\n  var outerOffset;\n  var innerOffset;\n  if (hasInnerSurface) {\n    if (isTopOpen) {\n      // Connect the top of the inner surface to the top of the outer surface\n      innerOffset = numPhis * numThetas;\n      for (i = 1; i < numThetas - 2; i++) {\n        indices[index++] = i;\n        indices[index++] = i + 1;\n        indices[index++] = innerOffset + i + 1;\n\n        indices[index++] = i;\n        indices[index++] = innerOffset + i + 1;\n        indices[index++] = innerOffset + i;\n      }\n    }\n\n    if (isBotOpen) {\n      // Connect the bottom of the inner surface to the bottom of the outer surface\n      outerOffset = numPhis * numThetas - numThetas;\n      innerOffset = numPhis * numThetas * vertexMultiplier - numThetas;\n      for (i = 1; i < numThetas - 2; i++) {\n        indices[index++] = outerOffset + i + 1;\n        indices[index++] = outerOffset + i;\n        indices[index++] = innerOffset + i;\n\n        indices[index++] = outerOffset + i + 1;\n        indices[index++] = innerOffset + i;\n        indices[index++] = innerOffset + i + 1;\n      }\n    }\n  }\n\n  // Connect the edges if clock is not closed\n  if (isClockOpen) {\n    for (i = 1; i < numPhis - 2; i++) {\n      innerOffset = numThetas * numPhis + numThetas * i;\n      outerOffset = numThetas * i;\n      indices[index++] = innerOffset;\n      indices[index++] = outerOffset + numThetas;\n      indices[index++] = outerOffset;\n\n      indices[index++] = innerOffset;\n      indices[index++] = innerOffset + numThetas;\n      indices[index++] = outerOffset + numThetas;\n    }\n\n    for (i = 1; i < numPhis - 2; i++) {\n      innerOffset = numThetas * numPhis + numThetas * (i + 1) - 1;\n      outerOffset = numThetas * (i + 1) - 1;\n      indices[index++] = outerOffset + numThetas;\n      indices[index++] = innerOffset;\n      indices[index++] = outerOffset;\n\n      indices[index++] = outerOffset + numThetas;\n      indices[index++] = innerOffset + numThetas;\n      indices[index++] = innerOffset;\n    }\n  }\n\n  var attributes = new GeometryAttributes();\n\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    });\n  }\n\n  var stIndex = 0;\n  var normalIndex = 0;\n  var tangentIndex = 0;\n  var bitangentIndex = 0;\n  var vertexCountHalf = vertexCount / 2.0;\n\n  var ellipsoid;\n  var ellipsoidOuter = Ellipsoid.fromCartesian3(radii);\n  var ellipsoidInner = Ellipsoid.fromCartesian3(innerRadii);\n\n  if (\n    vertexFormat.st ||\n    vertexFormat.normal ||\n    vertexFormat.tangent ||\n    vertexFormat.bitangent\n  ) {\n    for (i = 0; i < vertexCount; i++) {\n      ellipsoid = isInner[i] ? ellipsoidInner : ellipsoidOuter;\n      var position = Cartesian3.fromArray(positions, i * 3, scratchPosition);\n      var normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\n      if (negateNormal[i]) {\n        Cartesian3.negate(normal, normal);\n      }\n\n      if (vertexFormat.st) {\n        var normalST = Cartesian2.negate(normal, scratchNormalST);\n        st[stIndex++] =\n          Math.atan2(normalST.y, normalST.x) / CesiumMath.TWO_PI + 0.5;\n        st[stIndex++] = Math.asin(normal.z) / Math.PI + 0.5;\n      }\n\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = normal.x;\n        normals[normalIndex++] = normal.y;\n        normals[normalIndex++] = normal.z;\n      }\n\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\n        var tangent = scratchTangent;\n\n        // Use UNIT_X for the poles\n        var tangetOffset = 0;\n        var unit;\n        if (isInner[i]) {\n          tangetOffset = vertexCountHalf;\n        }\n        if (\n          !isTopOpen &&\n          i >= tangetOffset &&\n          i < tangetOffset + numThetas * 2\n        ) {\n          unit = Cartesian3.UNIT_X;\n        } else {\n          unit = Cartesian3.UNIT_Z;\n        }\n        Cartesian3.cross(unit, normal, tangent);\n        Cartesian3.normalize(tangent, tangent);\n\n        if (vertexFormat.tangent) {\n          tangents[tangentIndex++] = tangent.x;\n          tangents[tangentIndex++] = tangent.y;\n          tangents[tangentIndex++] = tangent.z;\n        }\n\n        if (vertexFormat.bitangent) {\n          var bitangent = Cartesian3.cross(normal, tangent, scratchBitangent);\n          Cartesian3.normalize(bitangent, bitangent);\n\n          bitangents[bitangentIndex++] = bitangent.x;\n          bitangents[bitangentIndex++] = bitangent.y;\n          bitangents[bitangentIndex++] = bitangent.z;\n        }\n      }\n    }\n\n    if (vertexFormat.st) {\n      attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: st,\n      });\n    }\n\n    if (vertexFormat.normal) {\n      attributes.normal = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: normals,\n      });\n    }\n\n    if (vertexFormat.tangent) {\n      attributes.tangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: tangents,\n      });\n    }\n\n    if (vertexFormat.bitangent) {\n      attributes.bitangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: bitangents,\n      });\n    }\n  }\n\n  if (defined(ellipsoidGeometry._offsetAttribute)) {\n    var length = positions.length;\n    var applyOffset = new Uint8Array(length / 3);\n    var offsetValue =\n      ellipsoidGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n        ? 0\n        : 1;\n    arrayFill(applyOffset, offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: BoundingSphere.fromEllipsoid(ellipsoidOuter),\n    offsetAttribute: ellipsoidGeometry._offsetAttribute,\n  });\n};\n\nvar unitEllipsoidGeometry;\n\n/**\n * Returns the geometric representation of a unit ellipsoid, including its vertices, indices, and a bounding sphere.\n * @returns {Geometry} The computed vertices and indices.\n *\n * @private\n */\nEllipsoidGeometry.getUnitEllipsoid = function () {\n  if (!defined(unitEllipsoidGeometry)) {\n    unitEllipsoidGeometry = EllipsoidGeometry.createGeometry(\n      new EllipsoidGeometry({\n        radii: new Cartesian3(1.0, 1.0, 1.0),\n        vertexFormat: VertexFormat.POSITION_ONLY,\n      })\n    );\n  }\n  return unitEllipsoidGeometry;\n};\nexport default EllipsoidGeometry;\n"]},"metadata":{},"sourceType":"module"}