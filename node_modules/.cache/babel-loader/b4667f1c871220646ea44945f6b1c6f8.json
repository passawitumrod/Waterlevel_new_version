{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nvar scaleToGeodeticSurfaceIntersection = new Cartesian3();\nvar scaleToGeodeticSurfaceGradient = new Cartesian3();\n/**\n * Scales the provided Cartesian position along the geodetic surface normal\n * so that it is on the surface of this ellipsoid.  If the position is\n * at the center of the ellipsoid, this function returns undefined.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} oneOverRadii One over radii of the ellipsoid.\n * @param {Cartesian3} oneOverRadiiSquared One over radii squared of the ellipsoid.\n * @param {Number} centerToleranceSquared Tolerance for closeness to the center.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\n *\n * @exports scaleToGeodeticSurface\n *\n * @private\n */\n\nfunction scaleToGeodeticSurface(cartesian, oneOverRadii, oneOverRadiiSquared, centerToleranceSquared, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n\n  if (!defined(oneOverRadii)) {\n    throw new DeveloperError(\"oneOverRadii is required.\");\n  }\n\n  if (!defined(oneOverRadiiSquared)) {\n    throw new DeveloperError(\"oneOverRadiiSquared is required.\");\n  }\n\n  if (!defined(centerToleranceSquared)) {\n    throw new DeveloperError(\"centerToleranceSquared is required.\");\n  } //>>includeEnd('debug');\n\n\n  var positionX = cartesian.x;\n  var positionY = cartesian.y;\n  var positionZ = cartesian.z;\n  var oneOverRadiiX = oneOverRadii.x;\n  var oneOverRadiiY = oneOverRadii.y;\n  var oneOverRadiiZ = oneOverRadii.z;\n  var x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;\n  var y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;\n  var z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ; // Compute the squared ellipsoid norm.\n\n  var squaredNorm = x2 + y2 + z2;\n  var ratio = Math.sqrt(1.0 / squaredNorm); // As an initial approximation, assume that the radial intersection is the projection point.\n\n  var intersection = Cartesian3.multiplyByScalar(cartesian, ratio, scaleToGeodeticSurfaceIntersection); // If the position is near the center, the iteration will not converge.\n\n  if (squaredNorm < centerToleranceSquared) {\n    return !isFinite(ratio) ? undefined : Cartesian3.clone(intersection, result);\n  }\n\n  var oneOverRadiiSquaredX = oneOverRadiiSquared.x;\n  var oneOverRadiiSquaredY = oneOverRadiiSquared.y;\n  var oneOverRadiiSquaredZ = oneOverRadiiSquared.z; // Use the gradient at the intersection point in place of the true unit normal.\n  // The difference in magnitude will be absorbed in the multiplier.\n\n  var gradient = scaleToGeodeticSurfaceGradient;\n  gradient.x = intersection.x * oneOverRadiiSquaredX * 2.0;\n  gradient.y = intersection.y * oneOverRadiiSquaredY * 2.0;\n  gradient.z = intersection.z * oneOverRadiiSquaredZ * 2.0; // Compute the initial guess at the normal vector multiplier, lambda.\n\n  var lambda = (1.0 - ratio) * Cartesian3.magnitude(cartesian) / (0.5 * Cartesian3.magnitude(gradient));\n  var correction = 0.0;\n  var func;\n  var denominator;\n  var xMultiplier;\n  var yMultiplier;\n  var zMultiplier;\n  var xMultiplier2;\n  var yMultiplier2;\n  var zMultiplier2;\n  var xMultiplier3;\n  var yMultiplier3;\n  var zMultiplier3;\n\n  do {\n    lambda -= correction;\n    xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);\n    yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);\n    zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);\n    xMultiplier2 = xMultiplier * xMultiplier;\n    yMultiplier2 = yMultiplier * yMultiplier;\n    zMultiplier2 = zMultiplier * zMultiplier;\n    xMultiplier3 = xMultiplier2 * xMultiplier;\n    yMultiplier3 = yMultiplier2 * yMultiplier;\n    zMultiplier3 = zMultiplier2 * zMultiplier;\n    func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0; // \"denominator\" here refers to the use of this expression in the velocity and acceleration\n    // computations in the sections to follow.\n\n    denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX + y2 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;\n    var derivative = -2.0 * denominator;\n    correction = func / derivative;\n  } while (Math.abs(func) > CesiumMath.EPSILON12);\n\n  if (!defined(result)) {\n    return new Cartesian3(positionX * xMultiplier, positionY * yMultiplier, positionZ * zMultiplier);\n  }\n\n  result.x = positionX * xMultiplier;\n  result.y = positionY * yMultiplier;\n  result.z = positionZ * zMultiplier;\n  return result;\n}\n\nexport default scaleToGeodeticSurface;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/scaleToGeodeticSurface.js"],"names":["Cartesian3","defined","DeveloperError","CesiumMath","scaleToGeodeticSurfaceIntersection","scaleToGeodeticSurfaceGradient","scaleToGeodeticSurface","cartesian","oneOverRadii","oneOverRadiiSquared","centerToleranceSquared","result","positionX","x","positionY","y","positionZ","z","oneOverRadiiX","oneOverRadiiY","oneOverRadiiZ","x2","y2","z2","squaredNorm","ratio","Math","sqrt","intersection","multiplyByScalar","isFinite","undefined","clone","oneOverRadiiSquaredX","oneOverRadiiSquaredY","oneOverRadiiSquaredZ","gradient","lambda","magnitude","correction","func","denominator","xMultiplier","yMultiplier","zMultiplier","xMultiplier2","yMultiplier2","zMultiplier2","xMultiplier3","yMultiplier3","zMultiplier3","derivative","abs","EPSILON12"],"mappings":"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","sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\nvar scaleToGeodeticSurfaceIntersection = new Cartesian3();\nvar scaleToGeodeticSurfaceGradient = new Cartesian3();\n\n/**\n * Scales the provided Cartesian position along the geodetic surface normal\n * so that it is on the surface of this ellipsoid.  If the position is\n * at the center of the ellipsoid, this function returns undefined.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} oneOverRadii One over radii of the ellipsoid.\n * @param {Cartesian3} oneOverRadiiSquared One over radii squared of the ellipsoid.\n * @param {Number} centerToleranceSquared Tolerance for closeness to the center.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\n *\n * @exports scaleToGeodeticSurface\n *\n * @private\n */\nfunction scaleToGeodeticSurface(\n  cartesian,\n  oneOverRadii,\n  oneOverRadiiSquared,\n  centerToleranceSquared,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  if (!defined(oneOverRadii)) {\n    throw new DeveloperError(\"oneOverRadii is required.\");\n  }\n  if (!defined(oneOverRadiiSquared)) {\n    throw new DeveloperError(\"oneOverRadiiSquared is required.\");\n  }\n  if (!defined(centerToleranceSquared)) {\n    throw new DeveloperError(\"centerToleranceSquared is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var positionX = cartesian.x;\n  var positionY = cartesian.y;\n  var positionZ = cartesian.z;\n\n  var oneOverRadiiX = oneOverRadii.x;\n  var oneOverRadiiY = oneOverRadii.y;\n  var oneOverRadiiZ = oneOverRadii.z;\n\n  var x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;\n  var y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;\n  var z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;\n\n  // Compute the squared ellipsoid norm.\n  var squaredNorm = x2 + y2 + z2;\n  var ratio = Math.sqrt(1.0 / squaredNorm);\n\n  // As an initial approximation, assume that the radial intersection is the projection point.\n  var intersection = Cartesian3.multiplyByScalar(\n    cartesian,\n    ratio,\n    scaleToGeodeticSurfaceIntersection\n  );\n\n  // If the position is near the center, the iteration will not converge.\n  if (squaredNorm < centerToleranceSquared) {\n    return !isFinite(ratio)\n      ? undefined\n      : Cartesian3.clone(intersection, result);\n  }\n\n  var oneOverRadiiSquaredX = oneOverRadiiSquared.x;\n  var oneOverRadiiSquaredY = oneOverRadiiSquared.y;\n  var oneOverRadiiSquaredZ = oneOverRadiiSquared.z;\n\n  // Use the gradient at the intersection point in place of the true unit normal.\n  // The difference in magnitude will be absorbed in the multiplier.\n  var gradient = scaleToGeodeticSurfaceGradient;\n  gradient.x = intersection.x * oneOverRadiiSquaredX * 2.0;\n  gradient.y = intersection.y * oneOverRadiiSquaredY * 2.0;\n  gradient.z = intersection.z * oneOverRadiiSquaredZ * 2.0;\n\n  // Compute the initial guess at the normal vector multiplier, lambda.\n  var lambda =\n    ((1.0 - ratio) * Cartesian3.magnitude(cartesian)) /\n    (0.5 * Cartesian3.magnitude(gradient));\n  var correction = 0.0;\n\n  var func;\n  var denominator;\n  var xMultiplier;\n  var yMultiplier;\n  var zMultiplier;\n  var xMultiplier2;\n  var yMultiplier2;\n  var zMultiplier2;\n  var xMultiplier3;\n  var yMultiplier3;\n  var zMultiplier3;\n\n  do {\n    lambda -= correction;\n\n    xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);\n    yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);\n    zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);\n\n    xMultiplier2 = xMultiplier * xMultiplier;\n    yMultiplier2 = yMultiplier * yMultiplier;\n    zMultiplier2 = zMultiplier * zMultiplier;\n\n    xMultiplier3 = xMultiplier2 * xMultiplier;\n    yMultiplier3 = yMultiplier2 * yMultiplier;\n    zMultiplier3 = zMultiplier2 * zMultiplier;\n\n    func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\n\n    // \"denominator\" here refers to the use of this expression in the velocity and acceleration\n    // computations in the sections to follow.\n    denominator =\n      x2 * xMultiplier3 * oneOverRadiiSquaredX +\n      y2 * yMultiplier3 * oneOverRadiiSquaredY +\n      z2 * zMultiplier3 * oneOverRadiiSquaredZ;\n\n    var derivative = -2.0 * denominator;\n\n    correction = func / derivative;\n  } while (Math.abs(func) > CesiumMath.EPSILON12);\n\n  if (!defined(result)) {\n    return new Cartesian3(\n      positionX * xMultiplier,\n      positionY * yMultiplier,\n      positionZ * zMultiplier\n    );\n  }\n  result.x = positionX * xMultiplier;\n  result.y = positionY * yMultiplier;\n  result.z = positionZ * zMultiplier;\n  return result;\n}\nexport default scaleToGeodeticSurface;\n"]},"metadata":{},"sourceType":"module"}