{"ast":null,"code":"import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nvar diffScratch = new Cartesian3();\n/**\n * A description of the outline of a cube centered at the origin.\n *\n * @alias BoxOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3} options.minimum The minimum x, y, and z coordinates of the box.\n * @param {Cartesian3} options.maximum The maximum x, y, and z coordinates of the box.\n *\n * @see BoxOutlineGeometry.fromDimensions\n * @see BoxOutlineGeometry.createGeometry\n * @see Packable\n *\n * @example\n * var box = new Cesium.BoxOutlineGeometry({\n *   maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0),\n *   minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0)\n * });\n * var geometry = Cesium.BoxOutlineGeometry.createGeometry(box);\n */\n\nfunction BoxOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var min = options.minimum;\n  var max = options.maximum; //>>includeStart('debug', pragmas.debug);\n\n  Check.typeOf.object(\"min\", min);\n  Check.typeOf.object(\"max\", max);\n\n  if (defined(options.offsetAttribute) && options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n    throw new DeveloperError(\"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\");\n  } //>>includeEnd('debug');\n\n\n  this._min = Cartesian3.clone(min);\n  this._max = Cartesian3.clone(max);\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createBoxOutlineGeometry\";\n}\n/**\n * Creates an outline of a cube centered at the origin given its dimensions.\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3} options.dimensions The width, depth, and height of the box stored in the x, y, and z coordinates of the <code>Cartesian3</code>, respectively.\n * @returns {BoxOutlineGeometry}\n *\n * @exception {DeveloperError} All dimensions components must be greater than or equal to zero.\n *\n *\n * @example\n * var box = Cesium.BoxOutlineGeometry.fromDimensions({\n *   dimensions : new Cesium.Cartesian3(500000.0, 500000.0, 500000.0)\n * });\n * var geometry = Cesium.BoxOutlineGeometry.createGeometry(box);\n *\n * @see BoxOutlineGeometry.createGeometry\n */\n\n\nBoxOutlineGeometry.fromDimensions = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var dimensions = options.dimensions; //>>includeStart('debug', pragmas.debug);\n\n  Check.typeOf.object(\"dimensions\", dimensions);\n  Check.typeOf.number.greaterThanOrEquals(\"dimensions.x\", dimensions.x, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"dimensions.y\", dimensions.y, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"dimensions.z\", dimensions.z, 0); //>>includeEnd('debug');\n\n  var corner = Cartesian3.multiplyByScalar(dimensions, 0.5, new Cartesian3());\n  return new BoxOutlineGeometry({\n    minimum: Cartesian3.negate(corner, new Cartesian3()),\n    maximum: corner,\n    offsetAttribute: options.offsetAttribute\n  });\n};\n/**\n * Creates an outline of a cube from the dimensions of an AxisAlignedBoundingBox.\n *\n * @param {AxisAlignedBoundingBox} boundingBox A description of the AxisAlignedBoundingBox.\n * @returns {BoxOutlineGeometry}\n *\n *\n *\n * @example\n * var aabb = Cesium.AxisAlignedBoundingBox.fromPoints(Cesium.Cartesian3.fromDegreesArray([\n *      -72.0, 40.0,\n *      -70.0, 35.0,\n *      -75.0, 30.0,\n *      -70.0, 30.0,\n *      -68.0, 40.0\n * ]));\n * var box = Cesium.BoxOutlineGeometry.fromAxisAlignedBoundingBox(aabb);\n *\n *  @see BoxOutlineGeometry.createGeometry\n */\n\n\nBoxOutlineGeometry.fromAxisAlignedBoundingBox = function (boundingBox) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"boundindBox\", boundingBox); //>>includeEnd('debug');\n\n  return new BoxOutlineGeometry({\n    minimum: boundingBox.minimum,\n    maximum: boundingBox.maximum\n  });\n};\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\n\n\nBoxOutlineGeometry.packedLength = 2 * Cartesian3.packedLength + 1;\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {BoxOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\nBoxOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  Cartesian3.pack(value._min, array, startingIndex);\n  Cartesian3.pack(value._max, array, startingIndex + Cartesian3.packedLength);\n  array[startingIndex + Cartesian3.packedLength * 2] = defaultValue(value._offsetAttribute, -1);\n  return array;\n};\n\nvar scratchMin = new Cartesian3();\nvar scratchMax = new Cartesian3();\nvar scratchOptions = {\n  minimum: scratchMin,\n  maximum: scratchMax,\n  offsetAttribute: undefined\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {BoxOutlineGeometry} [result] The object into which to store the result.\n * @returns {BoxOutlineGeometry} The modified result parameter or a new BoxOutlineGeometry instance if one was not provided.\n */\n\nBoxOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var min = Cartesian3.unpack(array, startingIndex, scratchMin);\n  var max = Cartesian3.unpack(array, startingIndex + Cartesian3.packedLength, scratchMax);\n  var offsetAttribute = array[startingIndex + Cartesian3.packedLength * 2];\n\n  if (!defined(result)) {\n    scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new BoxOutlineGeometry(scratchOptions);\n  }\n\n  result._min = Cartesian3.clone(min, result._min);\n  result._max = Cartesian3.clone(max, result._max);\n  result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n  return result;\n};\n/**\n * Computes the geometric representation of an outline of a box, including its vertices, indices, and a bounding sphere.\n *\n * @param {BoxOutlineGeometry} boxGeometry A description of the box outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\n\n\nBoxOutlineGeometry.createGeometry = function (boxGeometry) {\n  var min = boxGeometry._min;\n  var max = boxGeometry._max;\n\n  if (Cartesian3.equals(min, max)) {\n    return;\n  }\n\n  var attributes = new GeometryAttributes();\n  var indices = new Uint16Array(12 * 2);\n  var positions = new Float64Array(8 * 3);\n  positions[0] = min.x;\n  positions[1] = min.y;\n  positions[2] = min.z;\n  positions[3] = max.x;\n  positions[4] = min.y;\n  positions[5] = min.z;\n  positions[6] = max.x;\n  positions[7] = max.y;\n  positions[8] = min.z;\n  positions[9] = min.x;\n  positions[10] = max.y;\n  positions[11] = min.z;\n  positions[12] = min.x;\n  positions[13] = min.y;\n  positions[14] = max.z;\n  positions[15] = max.x;\n  positions[16] = min.y;\n  positions[17] = max.z;\n  positions[18] = max.x;\n  positions[19] = max.y;\n  positions[20] = max.z;\n  positions[21] = min.x;\n  positions[22] = max.y;\n  positions[23] = max.z;\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positions\n  }); // top\n\n  indices[0] = 4;\n  indices[1] = 5;\n  indices[2] = 5;\n  indices[3] = 6;\n  indices[4] = 6;\n  indices[5] = 7;\n  indices[6] = 7;\n  indices[7] = 4; // bottom\n\n  indices[8] = 0;\n  indices[9] = 1;\n  indices[10] = 1;\n  indices[11] = 2;\n  indices[12] = 2;\n  indices[13] = 3;\n  indices[14] = 3;\n  indices[15] = 0; // left\n\n  indices[16] = 0;\n  indices[17] = 4;\n  indices[18] = 1;\n  indices[19] = 5; //right\n\n  indices[20] = 2;\n  indices[21] = 6;\n  indices[22] = 3;\n  indices[23] = 7;\n  var diff = Cartesian3.subtract(max, min, diffScratch);\n  var radius = Cartesian3.magnitude(diff) * 0.5;\n\n  if (defined(boxGeometry._offsetAttribute)) {\n    var length = positions.length;\n    var applyOffset = new Uint8Array(length / 3);\n    var offsetValue = boxGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n    arrayFill(applyOffset, offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: new BoundingSphere(Cartesian3.ZERO, radius),\n    offsetAttribute: boxGeometry._offsetAttribute\n  });\n};\n\nexport default BoxOutlineGeometry;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/BoxOutlineGeometry.js"],"names":["arrayFill","BoundingSphere","Cartesian3","Check","ComponentDatatype","defaultValue","defined","DeveloperError","Geometry","GeometryAttribute","GeometryAttributes","GeometryOffsetAttribute","PrimitiveType","diffScratch","BoxOutlineGeometry","options","EMPTY_OBJECT","min","minimum","max","maximum","typeOf","object","offsetAttribute","TOP","_min","clone","_max","_offsetAttribute","_workerName","fromDimensions","dimensions","number","greaterThanOrEquals","x","y","z","corner","multiplyByScalar","negate","fromAxisAlignedBoundingBox","boundingBox","packedLength","pack","value","array","startingIndex","scratchMin","scratchMax","scratchOptions","undefined","unpack","result","createGeometry","boxGeometry","equals","attributes","indices","Uint16Array","positions","Float64Array","position","componentDatatype","DOUBLE","componentsPerAttribute","values","diff","subtract","radius","magnitude","length","applyOffset","Uint8Array","offsetValue","NONE","UNSIGNED_BYTE","primitiveType","LINES","boundingSphere","ZERO"],"mappings":"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","sourcesContent":["import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nvar diffScratch = new Cartesian3();\n\n/**\n * A description of the outline of a cube centered at the origin.\n *\n * @alias BoxOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3} options.minimum The minimum x, y, and z coordinates of the box.\n * @param {Cartesian3} options.maximum The maximum x, y, and z coordinates of the box.\n *\n * @see BoxOutlineGeometry.fromDimensions\n * @see BoxOutlineGeometry.createGeometry\n * @see Packable\n *\n * @example\n * var box = new Cesium.BoxOutlineGeometry({\n *   maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0),\n *   minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0)\n * });\n * var geometry = Cesium.BoxOutlineGeometry.createGeometry(box);\n */\nfunction BoxOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var min = options.minimum;\n  var max = options.maximum;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"min\", min);\n  Check.typeOf.object(\"max\", max);\n  if (\n    defined(options.offsetAttribute) &&\n    options.offsetAttribute === GeometryOffsetAttribute.TOP\n  ) {\n    throw new DeveloperError(\n      \"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._min = Cartesian3.clone(min);\n  this._max = Cartesian3.clone(max);\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createBoxOutlineGeometry\";\n}\n\n/**\n * Creates an outline of a cube centered at the origin given its dimensions.\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3} options.dimensions The width, depth, and height of the box stored in the x, y, and z coordinates of the <code>Cartesian3</code>, respectively.\n * @returns {BoxOutlineGeometry}\n *\n * @exception {DeveloperError} All dimensions components must be greater than or equal to zero.\n *\n *\n * @example\n * var box = Cesium.BoxOutlineGeometry.fromDimensions({\n *   dimensions : new Cesium.Cartesian3(500000.0, 500000.0, 500000.0)\n * });\n * var geometry = Cesium.BoxOutlineGeometry.createGeometry(box);\n *\n * @see BoxOutlineGeometry.createGeometry\n */\nBoxOutlineGeometry.fromDimensions = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var dimensions = options.dimensions;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"dimensions\", dimensions);\n  Check.typeOf.number.greaterThanOrEquals(\"dimensions.x\", dimensions.x, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"dimensions.y\", dimensions.y, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"dimensions.z\", dimensions.z, 0);\n  //>>includeEnd('debug');\n\n  var corner = Cartesian3.multiplyByScalar(dimensions, 0.5, new Cartesian3());\n\n  return new BoxOutlineGeometry({\n    minimum: Cartesian3.negate(corner, new Cartesian3()),\n    maximum: corner,\n    offsetAttribute: options.offsetAttribute,\n  });\n};\n\n/**\n * Creates an outline of a cube from the dimensions of an AxisAlignedBoundingBox.\n *\n * @param {AxisAlignedBoundingBox} boundingBox A description of the AxisAlignedBoundingBox.\n * @returns {BoxOutlineGeometry}\n *\n *\n *\n * @example\n * var aabb = Cesium.AxisAlignedBoundingBox.fromPoints(Cesium.Cartesian3.fromDegreesArray([\n *      -72.0, 40.0,\n *      -70.0, 35.0,\n *      -75.0, 30.0,\n *      -70.0, 30.0,\n *      -68.0, 40.0\n * ]));\n * var box = Cesium.BoxOutlineGeometry.fromAxisAlignedBoundingBox(aabb);\n *\n *  @see BoxOutlineGeometry.createGeometry\n */\nBoxOutlineGeometry.fromAxisAlignedBoundingBox = function (boundingBox) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"boundindBox\", boundingBox);\n  //>>includeEnd('debug');\n\n  return new BoxOutlineGeometry({\n    minimum: boundingBox.minimum,\n    maximum: boundingBox.maximum,\n  });\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nBoxOutlineGeometry.packedLength = 2 * Cartesian3.packedLength + 1;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {BoxOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nBoxOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value._min, array, startingIndex);\n  Cartesian3.pack(value._max, array, startingIndex + Cartesian3.packedLength);\n  array[startingIndex + Cartesian3.packedLength * 2] = defaultValue(\n    value._offsetAttribute,\n    -1\n  );\n\n  return array;\n};\n\nvar scratchMin = new Cartesian3();\nvar scratchMax = new Cartesian3();\nvar scratchOptions = {\n  minimum: scratchMin,\n  maximum: scratchMax,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {BoxOutlineGeometry} [result] The object into which to store the result.\n * @returns {BoxOutlineGeometry} The modified result parameter or a new BoxOutlineGeometry instance if one was not provided.\n */\nBoxOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var min = Cartesian3.unpack(array, startingIndex, scratchMin);\n  var max = Cartesian3.unpack(\n    array,\n    startingIndex + Cartesian3.packedLength,\n    scratchMax\n  );\n  var offsetAttribute = array[startingIndex + Cartesian3.packedLength * 2];\n\n  if (!defined(result)) {\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new BoxOutlineGeometry(scratchOptions);\n  }\n\n  result._min = Cartesian3.clone(min, result._min);\n  result._max = Cartesian3.clone(max, result._max);\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of a box, including its vertices, indices, and a bounding sphere.\n *\n * @param {BoxOutlineGeometry} boxGeometry A description of the box outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nBoxOutlineGeometry.createGeometry = function (boxGeometry) {\n  var min = boxGeometry._min;\n  var max = boxGeometry._max;\n\n  if (Cartesian3.equals(min, max)) {\n    return;\n  }\n\n  var attributes = new GeometryAttributes();\n  var indices = new Uint16Array(12 * 2);\n  var positions = new Float64Array(8 * 3);\n\n  positions[0] = min.x;\n  positions[1] = min.y;\n  positions[2] = min.z;\n  positions[3] = max.x;\n  positions[4] = min.y;\n  positions[5] = min.z;\n  positions[6] = max.x;\n  positions[7] = max.y;\n  positions[8] = min.z;\n  positions[9] = min.x;\n  positions[10] = max.y;\n  positions[11] = min.z;\n\n  positions[12] = min.x;\n  positions[13] = min.y;\n  positions[14] = max.z;\n  positions[15] = max.x;\n  positions[16] = min.y;\n  positions[17] = max.z;\n  positions[18] = max.x;\n  positions[19] = max.y;\n  positions[20] = max.z;\n  positions[21] = min.x;\n  positions[22] = max.y;\n  positions[23] = max.z;\n\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positions,\n  });\n\n  // top\n  indices[0] = 4;\n  indices[1] = 5;\n  indices[2] = 5;\n  indices[3] = 6;\n  indices[4] = 6;\n  indices[5] = 7;\n  indices[6] = 7;\n  indices[7] = 4;\n\n  // bottom\n  indices[8] = 0;\n  indices[9] = 1;\n  indices[10] = 1;\n  indices[11] = 2;\n  indices[12] = 2;\n  indices[13] = 3;\n  indices[14] = 3;\n  indices[15] = 0;\n\n  // left\n  indices[16] = 0;\n  indices[17] = 4;\n  indices[18] = 1;\n  indices[19] = 5;\n\n  //right\n  indices[20] = 2;\n  indices[21] = 6;\n  indices[22] = 3;\n  indices[23] = 7;\n\n  var diff = Cartesian3.subtract(max, min, diffScratch);\n  var radius = Cartesian3.magnitude(diff) * 0.5;\n\n  if (defined(boxGeometry._offsetAttribute)) {\n    var length = positions.length;\n    var applyOffset = new Uint8Array(length / 3);\n    var offsetValue =\n      boxGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n    arrayFill(applyOffset, offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: new BoundingSphere(Cartesian3.ZERO, radius),\n    offsetAttribute: boxGeometry._offsetAttribute,\n  });\n};\nexport default BoxOutlineGeometry;\n"]},"metadata":{},"sourceType":"module"}