{"ast":null,"code":"import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\n/**\n * Represents a {@link Packable} number that always interpolates values\n * towards the shortest angle of rotation. This object is never used directly\n * but is instead passed to the constructor of {@link SampledProperty}\n * in order to represent a two-dimensional angle of rotation.\n *\n * @exports Rotation\n *\n *\n * @example\n * var time1 = Cesium.JulianDate.fromIso8601('2010-05-07T00:00:00');\n * var time2 = Cesium.JulianDate.fromIso8601('2010-05-07T00:01:00');\n * var time3 = Cesium.JulianDate.fromIso8601('2010-05-07T00:02:00');\n *\n * var property = new Cesium.SampledProperty(Cesium.Rotation);\n * property.addSample(time1, 0);\n * property.addSample(time3, Cesium.Math.toRadians(350));\n *\n * //Getting the value at time2 will equal 355 degrees instead\n * //of 175 degrees (which is what you get if you construct\n * //a SampledProperty(Number) instead.  Note, the actual\n * //return value is in radians, not degrees.\n * property.getValue(time2);\n *\n * @see PackableForInterpolation\n */\n\nvar Rotation = {\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  packedLength: 1,\n\n  /**\n   * Stores the provided instance into the provided array.\n   *\n   * @param {Rotation} value The value to pack.\n   * @param {Number[]} array The array to pack into.\n   * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n   *\n   * @returns {Number[]} The array that was packed into\n   */\n  pack: function pack(value, array, startingIndex) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(value)) {\n      throw new DeveloperError(\"value is required\");\n    }\n\n    if (!defined(array)) {\n      throw new DeveloperError(\"array is required\");\n    } //>>includeEnd('debug');\n\n\n    startingIndex = defaultValue(startingIndex, 0);\n    array[startingIndex] = value;\n    return array;\n  },\n\n  /**\n   * Retrieves an instance from a packed array.\n   *\n   * @param {Number[]} array The packed array.\n   * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n   * @param {Rotation} [result] The object into which to store the result.\n   * @returns {Rotation} The modified result parameter or a new Rotation instance if one was not provided.\n   */\n  unpack: function unpack(array, startingIndex, result) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(array)) {\n      throw new DeveloperError(\"array is required\");\n    } //>>includeEnd('debug');\n\n\n    startingIndex = defaultValue(startingIndex, 0);\n    return array[startingIndex];\n  },\n\n  /**\n   * Converts a packed array into a form suitable for interpolation.\n   *\n   * @param {Number[]} packedArray The packed array.\n   * @param {Number} [startingIndex=0] The index of the first element to be converted.\n   * @param {Number} [lastIndex=packedArray.length] The index of the last element to be converted.\n   * @param {Number[]} result The object into which to store the result.\n   */\n  convertPackedArrayForInterpolation: function convertPackedArrayForInterpolation(packedArray, startingIndex, lastIndex, result) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(packedArray)) {\n      throw new DeveloperError(\"packedArray is required\");\n    } //>>includeEnd('debug');\n\n\n    startingIndex = defaultValue(startingIndex, 0);\n    lastIndex = defaultValue(lastIndex, packedArray.length);\n    var previousValue;\n\n    for (var i = 0, len = lastIndex - startingIndex + 1; i < len; i++) {\n      var value = packedArray[startingIndex + i];\n\n      if (i === 0 || Math.abs(previousValue - value) < Math.PI) {\n        result[i] = value;\n      } else {\n        result[i] = value - CesiumMath.TWO_PI;\n      }\n\n      previousValue = value;\n    }\n  },\n\n  /**\n   * Retrieves an instance from a packed array converted with {@link Rotation.convertPackedArrayForInterpolation}.\n   *\n   * @param {Number[]} array The array previously packed for interpolation.\n   * @param {Number[]} sourceArray The original packed array.\n   * @param {Number} [firstIndex=0] The firstIndex used to convert the array.\n   * @param {Number} [lastIndex=packedArray.length] The lastIndex used to convert the array.\n   * @param {Rotation} [result] The object into which to store the result.\n   * @returns {Rotation} The modified result parameter or a new Rotation instance if one was not provided.\n   */\n  unpackInterpolationResult: function unpackInterpolationResult(array, sourceArray, firstIndex, lastIndex, result) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(array)) {\n      throw new DeveloperError(\"array is required\");\n    }\n\n    if (!defined(sourceArray)) {\n      throw new DeveloperError(\"sourceArray is required\");\n    } //>>includeEnd('debug');\n\n\n    result = array[0];\n\n    if (result < 0) {\n      return result + CesiumMath.TWO_PI;\n    }\n\n    return result;\n  }\n};\nexport default Rotation;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/DataSources/Rotation.js"],"names":["defaultValue","defined","DeveloperError","CesiumMath","Rotation","packedLength","pack","value","array","startingIndex","unpack","result","convertPackedArrayForInterpolation","packedArray","lastIndex","length","previousValue","i","len","Math","abs","PI","TWO_PI","unpackInterpolationResult","sourceArray","firstIndex"],"mappings":"AAAA,OAAOA,YAAP,MAAyB,yBAAzB;AACA,OAAOC,OAAP,MAAoB,oBAApB;AACA,OAAOC,cAAP,MAA2B,2BAA3B;AACA,OAAOC,UAAP,MAAuB,iBAAvB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA,IAAIC,QAAQ,GAAG;AACb;;;;AAIAC,EAAAA,YAAY,EAAE,CALD;;AAOb;;;;;;;;;AASAC,EAAAA,IAAI,EAAE,cAAUC,KAAV,EAAiBC,KAAjB,EAAwBC,aAAxB,EAAuC;AAC3C;AACA,QAAI,CAACR,OAAO,CAACM,KAAD,CAAZ,EAAqB;AACnB,YAAM,IAAIL,cAAJ,CAAmB,mBAAnB,CAAN;AACD;;AAED,QAAI,CAACD,OAAO,CAACO,KAAD,CAAZ,EAAqB;AACnB,YAAM,IAAIN,cAAJ,CAAmB,mBAAnB,CAAN;AACD,KAR0C,CAS3C;;;AAEAO,IAAAA,aAAa,GAAGT,YAAY,CAACS,aAAD,EAAgB,CAAhB,CAA5B;AACAD,IAAAA,KAAK,CAACC,aAAD,CAAL,GAAuBF,KAAvB;AAEA,WAAOC,KAAP;AACD,GA/BY;;AAiCb;;;;;;;;AAQAE,EAAAA,MAAM,EAAE,gBAAUF,KAAV,EAAiBC,aAAjB,EAAgCE,MAAhC,EAAwC;AAC9C;AACA,QAAI,CAACV,OAAO,CAACO,KAAD,CAAZ,EAAqB;AACnB,YAAM,IAAIN,cAAJ,CAAmB,mBAAnB,CAAN;AACD,KAJ6C,CAK9C;;;AAEAO,IAAAA,aAAa,GAAGT,YAAY,CAACS,aAAD,EAAgB,CAAhB,CAA5B;AACA,WAAOD,KAAK,CAACC,aAAD,CAAZ;AACD,GAlDY;;AAoDb;;;;;;;;AAQAG,EAAAA,kCAAkC,EAAE,4CAClCC,WADkC,EAElCJ,aAFkC,EAGlCK,SAHkC,EAIlCH,MAJkC,EAKlC;AACA;AACA,QAAI,CAACV,OAAO,CAACY,WAAD,CAAZ,EAA2B;AACzB,YAAM,IAAIX,cAAJ,CAAmB,yBAAnB,CAAN;AACD,KAJD,CAKA;;;AAEAO,IAAAA,aAAa,GAAGT,YAAY,CAACS,aAAD,EAAgB,CAAhB,CAA5B;AACAK,IAAAA,SAAS,GAAGd,YAAY,CAACc,SAAD,EAAYD,WAAW,CAACE,MAAxB,CAAxB;AAEA,QAAIC,aAAJ;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGJ,SAAS,GAAGL,aAAZ,GAA4B,CAAlD,EAAqDQ,CAAC,GAAGC,GAAzD,EAA8DD,CAAC,EAA/D,EAAmE;AACjE,UAAIV,KAAK,GAAGM,WAAW,CAACJ,aAAa,GAAGQ,CAAjB,CAAvB;;AACA,UAAIA,CAAC,KAAK,CAAN,IAAWE,IAAI,CAACC,GAAL,CAASJ,aAAa,GAAGT,KAAzB,IAAkCY,IAAI,CAACE,EAAtD,EAA0D;AACxDV,QAAAA,MAAM,CAACM,CAAD,CAAN,GAAYV,KAAZ;AACD,OAFD,MAEO;AACLI,QAAAA,MAAM,CAACM,CAAD,CAAN,GAAYV,KAAK,GAAGJ,UAAU,CAACmB,MAA/B;AACD;;AACDN,MAAAA,aAAa,GAAGT,KAAhB;AACD;AACF,GArFY;;AAuFb;;;;;;;;;;AAUAgB,EAAAA,yBAAyB,EAAE,mCACzBf,KADyB,EAEzBgB,WAFyB,EAGzBC,UAHyB,EAIzBX,SAJyB,EAKzBH,MALyB,EAMzB;AACA;AACA,QAAI,CAACV,OAAO,CAACO,KAAD,CAAZ,EAAqB;AACnB,YAAM,IAAIN,cAAJ,CAAmB,mBAAnB,CAAN;AACD;;AACD,QAAI,CAACD,OAAO,CAACuB,WAAD,CAAZ,EAA2B;AACzB,YAAM,IAAItB,cAAJ,CAAmB,yBAAnB,CAAN;AACD,KAPD,CAQA;;;AAEAS,IAAAA,MAAM,GAAGH,KAAK,CAAC,CAAD,CAAd;;AACA,QAAIG,MAAM,GAAG,CAAb,EAAgB;AACd,aAAOA,MAAM,GAAGR,UAAU,CAACmB,MAA3B;AACD;;AACD,WAAOX,MAAP;AACD;AAtHY,CAAf;AAwHA,eAAeP,QAAf","sourcesContent":["import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\n\n/**\n * Represents a {@link Packable} number that always interpolates values\n * towards the shortest angle of rotation. This object is never used directly\n * but is instead passed to the constructor of {@link SampledProperty}\n * in order to represent a two-dimensional angle of rotation.\n *\n * @exports Rotation\n *\n *\n * @example\n * var time1 = Cesium.JulianDate.fromIso8601('2010-05-07T00:00:00');\n * var time2 = Cesium.JulianDate.fromIso8601('2010-05-07T00:01:00');\n * var time3 = Cesium.JulianDate.fromIso8601('2010-05-07T00:02:00');\n *\n * var property = new Cesium.SampledProperty(Cesium.Rotation);\n * property.addSample(time1, 0);\n * property.addSample(time3, Cesium.Math.toRadians(350));\n *\n * //Getting the value at time2 will equal 355 degrees instead\n * //of 175 degrees (which is what you get if you construct\n * //a SampledProperty(Number) instead.  Note, the actual\n * //return value is in radians, not degrees.\n * property.getValue(time2);\n *\n * @see PackableForInterpolation\n */\nvar Rotation = {\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  packedLength: 1,\n\n  /**\n   * Stores the provided instance into the provided array.\n   *\n   * @param {Rotation} value The value to pack.\n   * @param {Number[]} array The array to pack into.\n   * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n   *\n   * @returns {Number[]} The array that was packed into\n   */\n  pack: function (value, array, startingIndex) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(value)) {\n      throw new DeveloperError(\"value is required\");\n    }\n\n    if (!defined(array)) {\n      throw new DeveloperError(\"array is required\");\n    }\n    //>>includeEnd('debug');\n\n    startingIndex = defaultValue(startingIndex, 0);\n    array[startingIndex] = value;\n\n    return array;\n  },\n\n  /**\n   * Retrieves an instance from a packed array.\n   *\n   * @param {Number[]} array The packed array.\n   * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n   * @param {Rotation} [result] The object into which to store the result.\n   * @returns {Rotation} The modified result parameter or a new Rotation instance if one was not provided.\n   */\n  unpack: function (array, startingIndex, result) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(array)) {\n      throw new DeveloperError(\"array is required\");\n    }\n    //>>includeEnd('debug');\n\n    startingIndex = defaultValue(startingIndex, 0);\n    return array[startingIndex];\n  },\n\n  /**\n   * Converts a packed array into a form suitable for interpolation.\n   *\n   * @param {Number[]} packedArray The packed array.\n   * @param {Number} [startingIndex=0] The index of the first element to be converted.\n   * @param {Number} [lastIndex=packedArray.length] The index of the last element to be converted.\n   * @param {Number[]} result The object into which to store the result.\n   */\n  convertPackedArrayForInterpolation: function (\n    packedArray,\n    startingIndex,\n    lastIndex,\n    result\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(packedArray)) {\n      throw new DeveloperError(\"packedArray is required\");\n    }\n    //>>includeEnd('debug');\n\n    startingIndex = defaultValue(startingIndex, 0);\n    lastIndex = defaultValue(lastIndex, packedArray.length);\n\n    var previousValue;\n    for (var i = 0, len = lastIndex - startingIndex + 1; i < len; i++) {\n      var value = packedArray[startingIndex + i];\n      if (i === 0 || Math.abs(previousValue - value) < Math.PI) {\n        result[i] = value;\n      } else {\n        result[i] = value - CesiumMath.TWO_PI;\n      }\n      previousValue = value;\n    }\n  },\n\n  /**\n   * Retrieves an instance from a packed array converted with {@link Rotation.convertPackedArrayForInterpolation}.\n   *\n   * @param {Number[]} array The array previously packed for interpolation.\n   * @param {Number[]} sourceArray The original packed array.\n   * @param {Number} [firstIndex=0] The firstIndex used to convert the array.\n   * @param {Number} [lastIndex=packedArray.length] The lastIndex used to convert the array.\n   * @param {Rotation} [result] The object into which to store the result.\n   * @returns {Rotation} The modified result parameter or a new Rotation instance if one was not provided.\n   */\n  unpackInterpolationResult: function (\n    array,\n    sourceArray,\n    firstIndex,\n    lastIndex,\n    result\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(array)) {\n      throw new DeveloperError(\"array is required\");\n    }\n    if (!defined(sourceArray)) {\n      throw new DeveloperError(\"sourceArray is required\");\n    }\n    //>>includeEnd('debug');\n\n    result = array[0];\n    if (result < 0) {\n      return result + CesiumMath.TWO_PI;\n    }\n    return result;\n  },\n};\nexport default Rotation;\n"]},"metadata":{},"sourceType":"module"}