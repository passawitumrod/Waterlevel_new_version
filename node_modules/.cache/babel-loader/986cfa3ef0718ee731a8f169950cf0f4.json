{"ast":null,"code":"import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport createBillboardPointCallback from \"../Scene/createBillboardPointCallback.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport Property from \"./Property.js\";\nvar defaultColor = Color.WHITE;\nvar defaultOutlineColor = Color.BLACK;\nvar defaultOutlineWidth = 0.0;\nvar defaultPixelSize = 1.0;\nvar defaultDisableDepthTestDistance = 0.0;\nvar colorScratch = new Color();\nvar positionScratch = new Cartesian3();\nvar outlineColorScratch = new Color();\nvar scaleByDistanceScratch = new NearFarScalar();\nvar translucencyByDistanceScratch = new NearFarScalar();\nvar distanceDisplayConditionScratch = new DistanceDisplayCondition();\n\nfunction EntityData(entity) {\n  this.entity = entity;\n  this.pointPrimitive = undefined;\n  this.billboard = undefined;\n  this.color = undefined;\n  this.outlineColor = undefined;\n  this.pixelSize = undefined;\n  this.outlineWidth = undefined;\n}\n/**\n * A {@link Visualizer} which maps {@link Entity#point} to a {@link PointPrimitive}.\n * @alias PointVisualizer\n * @constructor\n *\n * @param {EntityCluster} entityCluster The entity cluster to manage the collection of billboards and optionally cluster with other entities.\n * @param {EntityCollection} entityCollection The entityCollection to visualize.\n */\n\n\nfunction PointVisualizer(entityCluster, entityCollection) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entityCluster)) {\n    throw new DeveloperError(\"entityCluster is required.\");\n  }\n\n  if (!defined(entityCollection)) {\n    throw new DeveloperError(\"entityCollection is required.\");\n  } //>>includeEnd('debug');\n\n\n  entityCollection.collectionChanged.addEventListener(PointVisualizer.prototype._onCollectionChanged, this);\n  this._cluster = entityCluster;\n  this._entityCollection = entityCollection;\n  this._items = new AssociativeArray();\n\n  this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n}\n/**\n * Updates the primitives created by this visualizer to match their\n * Entity counterpart at the given time.\n *\n * @param {JulianDate} time The time to update to.\n * @returns {Boolean} This function always returns true.\n */\n\n\nPointVisualizer.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(time)) {\n    throw new DeveloperError(\"time is required.\");\n  } //>>includeEnd('debug');\n\n\n  var items = this._items.values;\n  var cluster = this._cluster;\n\n  for (var i = 0, len = items.length; i < len; i++) {\n    var item = items[i];\n    var entity = item.entity;\n    var pointGraphics = entity._point;\n    var pointPrimitive = item.pointPrimitive;\n    var billboard = item.billboard;\n    var heightReference = Property.getValueOrDefault(pointGraphics._heightReference, time, HeightReference.NONE);\n    var show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(pointGraphics._show, time, true);\n    var position;\n\n    if (show) {\n      position = Property.getValueOrUndefined(entity._position, time, positionScratch);\n      show = defined(position);\n    }\n\n    if (!show) {\n      returnPrimitive(item, entity, cluster);\n      continue;\n    }\n\n    if (!Property.isConstant(entity._position)) {\n      cluster._clusterDirty = true;\n    }\n\n    var needsRedraw = false;\n    var updateClamping = false;\n\n    if (heightReference !== HeightReference.NONE && !defined(billboard)) {\n      if (defined(pointPrimitive)) {\n        returnPrimitive(item, entity, cluster);\n        pointPrimitive = undefined;\n      }\n\n      billboard = cluster.getBillboard(entity);\n      billboard.id = entity;\n      billboard.image = undefined;\n      item.billboard = billboard;\n      needsRedraw = true; // If this new billboard happens to have a position and height reference that match our new values,\n      // billboard._updateClamping will not be called automatically. That's a problem because the clamped\n      // height may be based on different terrain than is now loaded. So we'll manually call\n      // _updateClamping below.\n\n      updateClamping = Cartesian3.equals(billboard.position, position) && billboard.heightReference === heightReference;\n    } else if (heightReference === HeightReference.NONE && !defined(pointPrimitive)) {\n      if (defined(billboard)) {\n        returnPrimitive(item, entity, cluster);\n        billboard = undefined;\n      }\n\n      pointPrimitive = cluster.getPoint(entity);\n      pointPrimitive.id = entity;\n      item.pointPrimitive = pointPrimitive;\n    }\n\n    if (defined(pointPrimitive)) {\n      pointPrimitive.show = true;\n      pointPrimitive.position = position;\n      pointPrimitive.scaleByDistance = Property.getValueOrUndefined(pointGraphics._scaleByDistance, time, scaleByDistanceScratch);\n      pointPrimitive.translucencyByDistance = Property.getValueOrUndefined(pointGraphics._translucencyByDistance, time, translucencyByDistanceScratch);\n      pointPrimitive.color = Property.getValueOrDefault(pointGraphics._color, time, defaultColor, colorScratch);\n      pointPrimitive.outlineColor = Property.getValueOrDefault(pointGraphics._outlineColor, time, defaultOutlineColor, outlineColorScratch);\n      pointPrimitive.outlineWidth = Property.getValueOrDefault(pointGraphics._outlineWidth, time, defaultOutlineWidth);\n      pointPrimitive.pixelSize = Property.getValueOrDefault(pointGraphics._pixelSize, time, defaultPixelSize);\n      pointPrimitive.distanceDisplayCondition = Property.getValueOrUndefined(pointGraphics._distanceDisplayCondition, time, distanceDisplayConditionScratch);\n      pointPrimitive.disableDepthTestDistance = Property.getValueOrDefault(pointGraphics._disableDepthTestDistance, time, defaultDisableDepthTestDistance);\n    } else if (defined(billboard)) {\n      billboard.show = true;\n      billboard.position = position;\n      billboard.scaleByDistance = Property.getValueOrUndefined(pointGraphics._scaleByDistance, time, scaleByDistanceScratch);\n      billboard.translucencyByDistance = Property.getValueOrUndefined(pointGraphics._translucencyByDistance, time, translucencyByDistanceScratch);\n      billboard.distanceDisplayCondition = Property.getValueOrUndefined(pointGraphics._distanceDisplayCondition, time, distanceDisplayConditionScratch);\n      billboard.disableDepthTestDistance = Property.getValueOrDefault(pointGraphics._disableDepthTestDistance, time, defaultDisableDepthTestDistance);\n      billboard.heightReference = heightReference;\n      var newColor = Property.getValueOrDefault(pointGraphics._color, time, defaultColor, colorScratch);\n      var newOutlineColor = Property.getValueOrDefault(pointGraphics._outlineColor, time, defaultOutlineColor, outlineColorScratch);\n      var newOutlineWidth = Math.round(Property.getValueOrDefault(pointGraphics._outlineWidth, time, defaultOutlineWidth));\n      var newPixelSize = Math.max(1, Math.round(Property.getValueOrDefault(pointGraphics._pixelSize, time, defaultPixelSize)));\n\n      if (newOutlineWidth > 0) {\n        billboard.scale = 1.0;\n        needsRedraw = needsRedraw || //\n        newOutlineWidth !== item.outlineWidth || //\n        newPixelSize !== item.pixelSize || //\n        !Color.equals(newColor, item.color) || //\n        !Color.equals(newOutlineColor, item.outlineColor);\n      } else {\n        billboard.scale = newPixelSize / 50.0;\n        newPixelSize = 50.0;\n        needsRedraw = needsRedraw || //\n        newOutlineWidth !== item.outlineWidth || //\n        !Color.equals(newColor, item.color) || //\n        !Color.equals(newOutlineColor, item.outlineColor);\n      }\n\n      if (needsRedraw) {\n        item.color = Color.clone(newColor, item.color);\n        item.outlineColor = Color.clone(newOutlineColor, item.outlineColor);\n        item.pixelSize = newPixelSize;\n        item.outlineWidth = newOutlineWidth;\n        var centerAlpha = newColor.alpha;\n        var cssColor = newColor.toCssColorString();\n        var cssOutlineColor = newOutlineColor.toCssColorString();\n        var textureId = JSON.stringify([cssColor, newPixelSize, cssOutlineColor, newOutlineWidth]);\n        billboard.setImage(textureId, createBillboardPointCallback(centerAlpha, cssColor, cssOutlineColor, newOutlineWidth, newPixelSize));\n      }\n\n      if (updateClamping) {\n        billboard._updateClamping();\n      }\n    }\n  }\n\n  return true;\n};\n/**\n * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n * The bounding sphere is in the fixed frame of the scene's globe.\n *\n * @param {Entity} entity The entity whose bounding sphere to compute.\n * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n *                       BoundingSphereState.PENDING if the result is still being computed, or\n *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n * @private\n */\n\n\nPointVisualizer.prototype.getBoundingSphere = function (entity, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entity)) {\n    throw new DeveloperError(\"entity is required.\");\n  }\n\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  } //>>includeEnd('debug');\n\n\n  var item = this._items.get(entity.id);\n\n  if (!defined(item) || !(defined(item.pointPrimitive) || defined(item.billboard))) {\n    return BoundingSphereState.FAILED;\n  }\n\n  if (defined(item.pointPrimitive)) {\n    result.center = Cartesian3.clone(item.pointPrimitive.position, result.center);\n  } else {\n    var billboard = item.billboard;\n\n    if (!defined(billboard._clampedPosition)) {\n      return BoundingSphereState.PENDING;\n    }\n\n    result.center = Cartesian3.clone(billboard._clampedPosition, result.center);\n  }\n\n  result.radius = 0;\n  return BoundingSphereState.DONE;\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n */\n\n\nPointVisualizer.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Removes and destroys all primitives created by this instance.\n */\n\n\nPointVisualizer.prototype.destroy = function () {\n  this._entityCollection.collectionChanged.removeEventListener(PointVisualizer.prototype._onCollectionChanged, this);\n\n  var entities = this._entityCollection.values;\n\n  for (var i = 0; i < entities.length; i++) {\n    this._cluster.removePoint(entities[i]);\n  }\n\n  return destroyObject(this);\n};\n\nPointVisualizer.prototype._onCollectionChanged = function (entityCollection, added, removed, changed) {\n  var i;\n  var entity;\n  var items = this._items;\n  var cluster = this._cluster;\n\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n\n    if (defined(entity._point) && defined(entity._position)) {\n      items.set(entity.id, new EntityData(entity));\n    }\n  }\n\n  for (i = changed.length - 1; i > -1; i--) {\n    entity = changed[i];\n\n    if (defined(entity._point) && defined(entity._position)) {\n      if (!items.contains(entity.id)) {\n        items.set(entity.id, new EntityData(entity));\n      }\n    } else {\n      returnPrimitive(items.get(entity.id), entity, cluster);\n      items.remove(entity.id);\n    }\n  }\n\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    returnPrimitive(items.get(entity.id), entity, cluster);\n    items.remove(entity.id);\n  }\n};\n\nfunction returnPrimitive(item, entity, cluster) {\n  if (defined(item)) {\n    var pointPrimitive = item.pointPrimitive;\n\n    if (defined(pointPrimitive)) {\n      item.pointPrimitive = undefined;\n      cluster.removePoint(entity);\n      return;\n    }\n\n    var billboard = item.billboard;\n\n    if (defined(billboard)) {\n      item.billboard = undefined;\n      cluster.removeBillboard(entity);\n    }\n  }\n}\n\nexport default PointVisualizer;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/DataSources/PointVisualizer.js"],"names":["AssociativeArray","Cartesian3","Color","defined","destroyObject","DeveloperError","DistanceDisplayCondition","NearFarScalar","createBillboardPointCallback","HeightReference","BoundingSphereState","Property","defaultColor","WHITE","defaultOutlineColor","BLACK","defaultOutlineWidth","defaultPixelSize","defaultDisableDepthTestDistance","colorScratch","positionScratch","outlineColorScratch","scaleByDistanceScratch","translucencyByDistanceScratch","distanceDisplayConditionScratch","EntityData","entity","pointPrimitive","undefined","billboard","color","outlineColor","pixelSize","outlineWidth","PointVisualizer","entityCluster","entityCollection","collectionChanged","addEventListener","prototype","_onCollectionChanged","_cluster","_entityCollection","_items","values","update","time","items","cluster","i","len","length","item","pointGraphics","_point","heightReference","getValueOrDefault","_heightReference","NONE","show","isShowing","isAvailable","_show","position","getValueOrUndefined","_position","returnPrimitive","isConstant","_clusterDirty","needsRedraw","updateClamping","getBillboard","id","image","equals","getPoint","scaleByDistance","_scaleByDistance","translucencyByDistance","_translucencyByDistance","_color","_outlineColor","_outlineWidth","_pixelSize","distanceDisplayCondition","_distanceDisplayCondition","disableDepthTestDistance","_disableDepthTestDistance","newColor","newOutlineColor","newOutlineWidth","Math","round","newPixelSize","max","scale","clone","centerAlpha","alpha","cssColor","toCssColorString","cssOutlineColor","textureId","JSON","stringify","setImage","_updateClamping","getBoundingSphere","result","get","FAILED","center","_clampedPosition","PENDING","radius","DONE","isDestroyed","destroy","removeEventListener","entities","removePoint","added","removed","changed","set","contains","remove","removeBillboard"],"mappings":"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","sourcesContent":["import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport createBillboardPointCallback from \"../Scene/createBillboardPointCallback.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport Property from \"./Property.js\";\n\nvar defaultColor = Color.WHITE;\nvar defaultOutlineColor = Color.BLACK;\nvar defaultOutlineWidth = 0.0;\nvar defaultPixelSize = 1.0;\nvar defaultDisableDepthTestDistance = 0.0;\n\nvar colorScratch = new Color();\nvar positionScratch = new Cartesian3();\nvar outlineColorScratch = new Color();\nvar scaleByDistanceScratch = new NearFarScalar();\nvar translucencyByDistanceScratch = new NearFarScalar();\nvar distanceDisplayConditionScratch = new DistanceDisplayCondition();\n\nfunction EntityData(entity) {\n  this.entity = entity;\n  this.pointPrimitive = undefined;\n  this.billboard = undefined;\n  this.color = undefined;\n  this.outlineColor = undefined;\n  this.pixelSize = undefined;\n  this.outlineWidth = undefined;\n}\n\n/**\n * A {@link Visualizer} which maps {@link Entity#point} to a {@link PointPrimitive}.\n * @alias PointVisualizer\n * @constructor\n *\n * @param {EntityCluster} entityCluster The entity cluster to manage the collection of billboards and optionally cluster with other entities.\n * @param {EntityCollection} entityCollection The entityCollection to visualize.\n */\nfunction PointVisualizer(entityCluster, entityCollection) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entityCluster)) {\n    throw new DeveloperError(\"entityCluster is required.\");\n  }\n  if (!defined(entityCollection)) {\n    throw new DeveloperError(\"entityCollection is required.\");\n  }\n  //>>includeEnd('debug');\n\n  entityCollection.collectionChanged.addEventListener(\n    PointVisualizer.prototype._onCollectionChanged,\n    this\n  );\n\n  this._cluster = entityCluster;\n  this._entityCollection = entityCollection;\n  this._items = new AssociativeArray();\n  this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n}\n\n/**\n * Updates the primitives created by this visualizer to match their\n * Entity counterpart at the given time.\n *\n * @param {JulianDate} time The time to update to.\n * @returns {Boolean} This function always returns true.\n */\nPointVisualizer.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(time)) {\n    throw new DeveloperError(\"time is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var items = this._items.values;\n  var cluster = this._cluster;\n  for (var i = 0, len = items.length; i < len; i++) {\n    var item = items[i];\n    var entity = item.entity;\n    var pointGraphics = entity._point;\n    var pointPrimitive = item.pointPrimitive;\n    var billboard = item.billboard;\n    var heightReference = Property.getValueOrDefault(\n      pointGraphics._heightReference,\n      time,\n      HeightReference.NONE\n    );\n    var show =\n      entity.isShowing &&\n      entity.isAvailable(time) &&\n      Property.getValueOrDefault(pointGraphics._show, time, true);\n    var position;\n    if (show) {\n      position = Property.getValueOrUndefined(\n        entity._position,\n        time,\n        positionScratch\n      );\n      show = defined(position);\n    }\n    if (!show) {\n      returnPrimitive(item, entity, cluster);\n      continue;\n    }\n\n    if (!Property.isConstant(entity._position)) {\n      cluster._clusterDirty = true;\n    }\n\n    var needsRedraw = false;\n    var updateClamping = false;\n    if (heightReference !== HeightReference.NONE && !defined(billboard)) {\n      if (defined(pointPrimitive)) {\n        returnPrimitive(item, entity, cluster);\n        pointPrimitive = undefined;\n      }\n\n      billboard = cluster.getBillboard(entity);\n      billboard.id = entity;\n      billboard.image = undefined;\n      item.billboard = billboard;\n      needsRedraw = true;\n\n      // If this new billboard happens to have a position and height reference that match our new values,\n      // billboard._updateClamping will not be called automatically. That's a problem because the clamped\n      // height may be based on different terrain than is now loaded. So we'll manually call\n      // _updateClamping below.\n      updateClamping =\n        Cartesian3.equals(billboard.position, position) &&\n        billboard.heightReference === heightReference;\n    } else if (\n      heightReference === HeightReference.NONE &&\n      !defined(pointPrimitive)\n    ) {\n      if (defined(billboard)) {\n        returnPrimitive(item, entity, cluster);\n        billboard = undefined;\n      }\n\n      pointPrimitive = cluster.getPoint(entity);\n      pointPrimitive.id = entity;\n      item.pointPrimitive = pointPrimitive;\n    }\n\n    if (defined(pointPrimitive)) {\n      pointPrimitive.show = true;\n      pointPrimitive.position = position;\n      pointPrimitive.scaleByDistance = Property.getValueOrUndefined(\n        pointGraphics._scaleByDistance,\n        time,\n        scaleByDistanceScratch\n      );\n      pointPrimitive.translucencyByDistance = Property.getValueOrUndefined(\n        pointGraphics._translucencyByDistance,\n        time,\n        translucencyByDistanceScratch\n      );\n      pointPrimitive.color = Property.getValueOrDefault(\n        pointGraphics._color,\n        time,\n        defaultColor,\n        colorScratch\n      );\n      pointPrimitive.outlineColor = Property.getValueOrDefault(\n        pointGraphics._outlineColor,\n        time,\n        defaultOutlineColor,\n        outlineColorScratch\n      );\n      pointPrimitive.outlineWidth = Property.getValueOrDefault(\n        pointGraphics._outlineWidth,\n        time,\n        defaultOutlineWidth\n      );\n      pointPrimitive.pixelSize = Property.getValueOrDefault(\n        pointGraphics._pixelSize,\n        time,\n        defaultPixelSize\n      );\n      pointPrimitive.distanceDisplayCondition = Property.getValueOrUndefined(\n        pointGraphics._distanceDisplayCondition,\n        time,\n        distanceDisplayConditionScratch\n      );\n      pointPrimitive.disableDepthTestDistance = Property.getValueOrDefault(\n        pointGraphics._disableDepthTestDistance,\n        time,\n        defaultDisableDepthTestDistance\n      );\n    } else if (defined(billboard)) {\n      billboard.show = true;\n      billboard.position = position;\n      billboard.scaleByDistance = Property.getValueOrUndefined(\n        pointGraphics._scaleByDistance,\n        time,\n        scaleByDistanceScratch\n      );\n      billboard.translucencyByDistance = Property.getValueOrUndefined(\n        pointGraphics._translucencyByDistance,\n        time,\n        translucencyByDistanceScratch\n      );\n      billboard.distanceDisplayCondition = Property.getValueOrUndefined(\n        pointGraphics._distanceDisplayCondition,\n        time,\n        distanceDisplayConditionScratch\n      );\n      billboard.disableDepthTestDistance = Property.getValueOrDefault(\n        pointGraphics._disableDepthTestDistance,\n        time,\n        defaultDisableDepthTestDistance\n      );\n      billboard.heightReference = heightReference;\n\n      var newColor = Property.getValueOrDefault(\n        pointGraphics._color,\n        time,\n        defaultColor,\n        colorScratch\n      );\n      var newOutlineColor = Property.getValueOrDefault(\n        pointGraphics._outlineColor,\n        time,\n        defaultOutlineColor,\n        outlineColorScratch\n      );\n      var newOutlineWidth = Math.round(\n        Property.getValueOrDefault(\n          pointGraphics._outlineWidth,\n          time,\n          defaultOutlineWidth\n        )\n      );\n      var newPixelSize = Math.max(\n        1,\n        Math.round(\n          Property.getValueOrDefault(\n            pointGraphics._pixelSize,\n            time,\n            defaultPixelSize\n          )\n        )\n      );\n\n      if (newOutlineWidth > 0) {\n        billboard.scale = 1.0;\n        needsRedraw =\n          needsRedraw || //\n          newOutlineWidth !== item.outlineWidth || //\n          newPixelSize !== item.pixelSize || //\n          !Color.equals(newColor, item.color) || //\n          !Color.equals(newOutlineColor, item.outlineColor);\n      } else {\n        billboard.scale = newPixelSize / 50.0;\n        newPixelSize = 50.0;\n        needsRedraw =\n          needsRedraw || //\n          newOutlineWidth !== item.outlineWidth || //\n          !Color.equals(newColor, item.color) || //\n          !Color.equals(newOutlineColor, item.outlineColor);\n      }\n\n      if (needsRedraw) {\n        item.color = Color.clone(newColor, item.color);\n        item.outlineColor = Color.clone(newOutlineColor, item.outlineColor);\n        item.pixelSize = newPixelSize;\n        item.outlineWidth = newOutlineWidth;\n\n        var centerAlpha = newColor.alpha;\n        var cssColor = newColor.toCssColorString();\n        var cssOutlineColor = newOutlineColor.toCssColorString();\n        var textureId = JSON.stringify([\n          cssColor,\n          newPixelSize,\n          cssOutlineColor,\n          newOutlineWidth,\n        ]);\n\n        billboard.setImage(\n          textureId,\n          createBillboardPointCallback(\n            centerAlpha,\n            cssColor,\n            cssOutlineColor,\n            newOutlineWidth,\n            newPixelSize\n          )\n        );\n      }\n\n      if (updateClamping) {\n        billboard._updateClamping();\n      }\n    }\n  }\n  return true;\n};\n\n/**\n * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n * The bounding sphere is in the fixed frame of the scene's globe.\n *\n * @param {Entity} entity The entity whose bounding sphere to compute.\n * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n *                       BoundingSphereState.PENDING if the result is still being computed, or\n *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n * @private\n */\nPointVisualizer.prototype.getBoundingSphere = function (entity, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entity)) {\n    throw new DeveloperError(\"entity is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var item = this._items.get(entity.id);\n  if (\n    !defined(item) ||\n    !(defined(item.pointPrimitive) || defined(item.billboard))\n  ) {\n    return BoundingSphereState.FAILED;\n  }\n\n  if (defined(item.pointPrimitive)) {\n    result.center = Cartesian3.clone(\n      item.pointPrimitive.position,\n      result.center\n    );\n  } else {\n    var billboard = item.billboard;\n    if (!defined(billboard._clampedPosition)) {\n      return BoundingSphereState.PENDING;\n    }\n    result.center = Cartesian3.clone(billboard._clampedPosition, result.center);\n  }\n\n  result.radius = 0;\n  return BoundingSphereState.DONE;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n */\nPointVisualizer.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes and destroys all primitives created by this instance.\n */\nPointVisualizer.prototype.destroy = function () {\n  this._entityCollection.collectionChanged.removeEventListener(\n    PointVisualizer.prototype._onCollectionChanged,\n    this\n  );\n  var entities = this._entityCollection.values;\n  for (var i = 0; i < entities.length; i++) {\n    this._cluster.removePoint(entities[i]);\n  }\n  return destroyObject(this);\n};\n\nPointVisualizer.prototype._onCollectionChanged = function (\n  entityCollection,\n  added,\n  removed,\n  changed\n) {\n  var i;\n  var entity;\n  var items = this._items;\n  var cluster = this._cluster;\n\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    if (defined(entity._point) && defined(entity._position)) {\n      items.set(entity.id, new EntityData(entity));\n    }\n  }\n\n  for (i = changed.length - 1; i > -1; i--) {\n    entity = changed[i];\n    if (defined(entity._point) && defined(entity._position)) {\n      if (!items.contains(entity.id)) {\n        items.set(entity.id, new EntityData(entity));\n      }\n    } else {\n      returnPrimitive(items.get(entity.id), entity, cluster);\n      items.remove(entity.id);\n    }\n  }\n\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    returnPrimitive(items.get(entity.id), entity, cluster);\n    items.remove(entity.id);\n  }\n};\n\nfunction returnPrimitive(item, entity, cluster) {\n  if (defined(item)) {\n    var pointPrimitive = item.pointPrimitive;\n    if (defined(pointPrimitive)) {\n      item.pointPrimitive = undefined;\n      cluster.removePoint(entity);\n      return;\n    }\n    var billboard = item.billboard;\n    if (defined(billboard)) {\n      item.billboard = undefined;\n      cluster.removeBillboard(entity);\n    }\n  }\n}\nexport default PointVisualizer;\n"]},"metadata":{},"sourceType":"module"}