{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport GeographicProjection from \"../Core/GeographicProjection.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Request from \"../Core/Request.js\";\nimport RequestState from \"../Core/RequestState.js\";\nimport RequestType from \"../Core/RequestType.js\";\nimport TerrainProvider from \"../Core/TerrainProvider.js\";\nimport TileProviderError from \"../Core/TileProviderError.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ComputeCommand from \"../Renderer/ComputeCommand.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport MipmapHint from \"../Renderer/MipmapHint.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport ReprojectWebMercatorFS from \"../Shaders/ReprojectWebMercatorFS.js\";\nimport ReprojectWebMercatorVS from \"../Shaders/ReprojectWebMercatorVS.js\";\nimport when from \"../ThirdParty/when.js\";\nimport Imagery from \"./Imagery.js\";\nimport ImagerySplitDirection from \"./ImagerySplitDirection.js\";\nimport ImageryState from \"./ImageryState.js\";\nimport TileImagery from \"./TileImagery.js\";\n/**\n * An imagery layer that displays tiled image data from a single imagery provider\n * on a {@link Globe}.\n *\n * @alias ImageryLayer\n * @constructor\n *\n * @param {ImageryProvider} imageryProvider The imagery provider to use.\n * @param {Object} [options] Object with the following properties:\n * @param {Rectangle} [options.rectangle=imageryProvider.rectangle] The rectangle of the layer.  This rectangle\n *        can limit the visible portion of the imagery provider.\n * @param {Number|Function} [options.alpha=1.0] The alpha blending value of this layer, from 0.0 to 1.0.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates of the\n *                          imagery tile for which the alpha is required, and it is expected to return\n *                          the alpha value to use for the tile.\n * @param {Number|Function} [options.brightness=1.0] The brightness of this layer.  1.0 uses the unmodified imagery\n *                          color.  Less than 1.0 makes the imagery darker while greater than 1.0 makes it brighter.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates of the\n *                          imagery tile for which the brightness is required, and it is expected to return\n *                          the brightness value to use for the tile.  The function is executed for every\n *                          frame and for every tile, so it must be fast.\n * @param {Number|Function} [options.contrast=1.0] The contrast of this layer.  1.0 uses the unmodified imagery color.\n *                          Less than 1.0 reduces the contrast while greater than 1.0 increases it.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates of the\n *                          imagery tile for which the contrast is required, and it is expected to return\n *                          the contrast value to use for the tile.  The function is executed for every\n *                          frame and for every tile, so it must be fast.\n * @param {Number|Function} [options.hue=0.0] The hue of this layer.  0.0 uses the unmodified imagery color.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates\n *                          of the imagery tile for which the hue is required, and it is expected to return\n *                          the contrast value to use for the tile.  The function is executed for every\n *                          frame and for every tile, so it must be fast.\n * @param {Number|Function} [options.saturation=1.0] The saturation of this layer.  1.0 uses the unmodified imagery color.\n *                          Less than 1.0 reduces the saturation while greater than 1.0 increases it.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates\n *                          of the imagery tile for which the saturation is required, and it is expected to return\n *                          the contrast value to use for the tile.  The function is executed for every\n *                          frame and for every tile, so it must be fast.\n * @param {Number|Function} [options.gamma=1.0] The gamma correction to apply to this layer.  1.0 uses the unmodified imagery color.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates of the\n *                          imagery tile for which the gamma is required, and it is expected to return\n *                          the gamma value to use for the tile.  The function is executed for every\n *                          frame and for every tile, so it must be fast.\n * @param {ImagerySplitDirection|Function} [options.splitDirection=ImagerySplitDirection.NONE] The {@link ImagerySplitDirection} split to apply to this layer.\n * @param {TextureMinificationFilter} [options.minificationFilter=TextureMinificationFilter.LINEAR] The\n *                                    texture minification filter to apply to this layer. Possible values\n *                                    are <code>TextureMinificationFilter.LINEAR</code> and\n *                                    <code>TextureMinificationFilter.NEAREST</code>.\n * @param {TextureMagnificationFilter} [options.magnificationFilter=TextureMagnificationFilter.LINEAR] The\n *                                     texture minification filter to apply to this layer. Possible values\n *                                     are <code>TextureMagnificationFilter.LINEAR</code> and\n *                                     <code>TextureMagnificationFilter.NEAREST</code>.\n * @param {Boolean} [options.show=true] True if the layer is shown; otherwise, false.\n * @param {Number} [options.maximumAnisotropy=maximum supported] The maximum anisotropy level to use\n *        for texture filtering.  If this parameter is not specified, the maximum anisotropy supported\n *        by the WebGL stack will be used.  Larger values make the imagery look better in horizon\n *        views.\n * @param {Number} [options.minimumTerrainLevel] The minimum terrain level-of-detail at which to show this imagery layer,\n *                 or undefined to show it at all levels.  Level zero is the least-detailed level.\n * @param {Number} [options.maximumTerrainLevel] The maximum terrain level-of-detail at which to show this imagery layer,\n *                 or undefined to show it at all levels.  Level zero is the least-detailed level.\n * @param {Rectangle} [options.cutoutRectangle] Cartographic rectangle for cutting out a portion of this ImageryLayer.\n * @param {Color} [options.colorToAlpha] Color to be used as alpha.\n * @param {Number} [options.colorToAlphaThreshold=0.004] Threshold for color-to-alpha.\n */\n\nfunction ImageryLayer(imageryProvider, options) {\n  this._imageryProvider = imageryProvider;\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  /**\n   * The alpha blending value of this layer, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number}\n   * @default 1.0\n   */\n\n  this.alpha = defaultValue(options.alpha, defaultValue(imageryProvider.defaultAlpha, 1.0));\n  /**\n   * The brightness of this layer.  1.0 uses the unmodified imagery color.  Less than 1.0\n   * makes the imagery darker while greater than 1.0 makes it brighter.\n   *\n   * @type {Number}\n   * @default {@link ImageryLayer.DEFAULT_BRIGHTNESS}\n   */\n\n  this.brightness = defaultValue(options.brightness, defaultValue(imageryProvider.defaultBrightness, ImageryLayer.DEFAULT_BRIGHTNESS));\n  /**\n   * The contrast of this layer.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces\n   * the contrast while greater than 1.0 increases it.\n   *\n   * @type {Number}\n   * @default {@link ImageryLayer.DEFAULT_CONTRAST}\n   */\n\n  this.contrast = defaultValue(options.contrast, defaultValue(imageryProvider.defaultContrast, ImageryLayer.DEFAULT_CONTRAST));\n  /**\n   * The hue of this layer in radians. 0.0 uses the unmodified imagery color.\n   *\n   * @type {Number}\n   * @default {@link ImageryLayer.DEFAULT_HUE}\n   */\n\n  this.hue = defaultValue(options.hue, defaultValue(imageryProvider.defaultHue, ImageryLayer.DEFAULT_HUE));\n  /**\n   * The saturation of this layer. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the\n   * saturation while greater than 1.0 increases it.\n   *\n   * @type {Number}\n   * @default {@link ImageryLayer.DEFAULT_SATURATION}\n   */\n\n  this.saturation = defaultValue(options.saturation, defaultValue(imageryProvider.defaultSaturation, ImageryLayer.DEFAULT_SATURATION));\n  /**\n   * The gamma correction to apply to this layer.  1.0 uses the unmodified imagery color.\n   *\n   * @type {Number}\n   * @default {@link ImageryLayer.DEFAULT_GAMMA}\n   */\n\n  this.gamma = defaultValue(options.gamma, defaultValue(imageryProvider.defaultGamma, ImageryLayer.DEFAULT_GAMMA));\n  /**\n   * The {@link ImagerySplitDirection} to apply to this layer.\n   *\n   * @type {ImagerySplitDirection}\n   * @default {@link ImageryLayer.DEFAULT_SPLIT}\n   */\n\n  this.splitDirection = defaultValue(options.splitDirection, defaultValue(imageryProvider.defaultSplit, ImageryLayer.DEFAULT_SPLIT));\n  /**\n   * The {@link TextureMinificationFilter} to apply to this layer.\n   * Possible values are {@link TextureMinificationFilter.LINEAR} (the default)\n   * and {@link TextureMinificationFilter.NEAREST}.\n   *\n   * To take effect, this property must be set immediately after adding the imagery layer.\n   * Once a texture is loaded it won't be possible to change the texture filter used.\n   *\n   * @type {TextureMinificationFilter}\n   * @default {@link ImageryLayer.DEFAULT_MINIFICATION_FILTER}\n   */\n\n  this.minificationFilter = defaultValue(options.minificationFilter, defaultValue(imageryProvider.defaultMinificationFilter, ImageryLayer.DEFAULT_MINIFICATION_FILTER));\n  /**\n   * The {@link TextureMagnificationFilter} to apply to this layer.\n   * Possible values are {@link TextureMagnificationFilter.LINEAR} (the default)\n   * and {@link TextureMagnificationFilter.NEAREST}.\n   *\n   * To take effect, this property must be set immediately after adding the imagery layer.\n   * Once a texture is loaded it won't be possible to change the texture filter used.\n   *\n   * @type {TextureMagnificationFilter}\n   * @default {@link ImageryLayer.DEFAULT_MAGNIFICATION_FILTER}\n   */\n\n  this.magnificationFilter = defaultValue(options.magnificationFilter, defaultValue(imageryProvider.defaultMagnificationFilter, ImageryLayer.DEFAULT_MAGNIFICATION_FILTER));\n  /**\n   * Determines if this layer is shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.show = defaultValue(options.show, true);\n  this._minimumTerrainLevel = options.minimumTerrainLevel;\n  this._maximumTerrainLevel = options.maximumTerrainLevel;\n  this._rectangle = defaultValue(options.rectangle, Rectangle.MAX_VALUE);\n  this._maximumAnisotropy = options.maximumAnisotropy;\n  this._imageryCache = {};\n  this._skeletonPlaceholder = new TileImagery(Imagery.createPlaceholder(this)); // The value of the show property on the last update.\n\n  this._show = true; // The index of this layer in the ImageryLayerCollection.\n\n  this._layerIndex = -1; // true if this is the base (lowest shown) layer.\n\n  this._isBaseLayer = false;\n  this._requestImageError = undefined;\n  this._reprojectComputeCommands = [];\n  /**\n   * Rectangle cutout in this layer of imagery.\n   *\n   * @type {Rectangle}\n   */\n\n  this.cutoutRectangle = options.cutoutRectangle;\n  /**\n   * Color value that should be set to transparent.\n   *\n   * @type {Color}\n   */\n\n  this.colorToAlpha = options.colorToAlpha;\n  /**\n   * Normalized (0-1) threshold for color-to-alpha.\n   *\n   * @type {Number}\n   */\n\n  this.colorToAlphaThreshold = defaultValue(options.colorToAlphaThreshold, ImageryLayer.DEFAULT_APPLY_COLOR_TO_ALPHA_THRESHOLD);\n}\n\nObject.defineProperties(ImageryLayer.prototype, {\n  /**\n   * Gets the imagery provider for this layer.\n   * @memberof ImageryLayer.prototype\n   * @type {ImageryProvider}\n   * @readonly\n   */\n  imageryProvider: {\n    get: function () {\n      return this._imageryProvider;\n    }\n  },\n\n  /**\n   * Gets the rectangle of this layer.  If this rectangle is smaller than the rectangle of the\n   * {@link ImageryProvider}, only a portion of the imagery provider is shown.\n   * @memberof ImageryLayer.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  rectangle: {\n    get: function () {\n      return this._rectangle;\n    }\n  }\n});\n/**\n * This value is used as the default brightness for the imagery layer if one is not provided during construction\n * or by the imagery provider. This value does not modify the brightness of the imagery.\n * @type {Number}\n * @default 1.0\n */\n\nImageryLayer.DEFAULT_BRIGHTNESS = 1.0;\n/**\n * This value is used as the default contrast for the imagery layer if one is not provided during construction\n * or by the imagery provider. This value does not modify the contrast of the imagery.\n * @type {Number}\n * @default 1.0\n */\n\nImageryLayer.DEFAULT_CONTRAST = 1.0;\n/**\n * This value is used as the default hue for the imagery layer if one is not provided during construction\n * or by the imagery provider. This value does not modify the hue of the imagery.\n * @type {Number}\n * @default 0.0\n */\n\nImageryLayer.DEFAULT_HUE = 0.0;\n/**\n * This value is used as the default saturation for the imagery layer if one is not provided during construction\n * or by the imagery provider. This value does not modify the saturation of the imagery.\n * @type {Number}\n * @default 1.0\n */\n\nImageryLayer.DEFAULT_SATURATION = 1.0;\n/**\n * This value is used as the default gamma for the imagery layer if one is not provided during construction\n * or by the imagery provider. This value does not modify the gamma of the imagery.\n * @type {Number}\n * @default 1.0\n */\n\nImageryLayer.DEFAULT_GAMMA = 1.0;\n/**\n * This value is used as the default split for the imagery layer if one is not provided during construction\n * or by the imagery provider.\n * @type {ImagerySplitDirection}\n * @default ImagerySplitDirection.NONE\n */\n\nImageryLayer.DEFAULT_SPLIT = ImagerySplitDirection.NONE;\n/**\n * This value is used as the default texture minification filter for the imagery layer if one is not provided\n * during construction or by the imagery provider.\n * @type {TextureMinificationFilter}\n * @default TextureMinificationFilter.LINEAR\n */\n\nImageryLayer.DEFAULT_MINIFICATION_FILTER = TextureMinificationFilter.LINEAR;\n/**\n * This value is used as the default texture magnification filter for the imagery layer if one is not provided\n * during construction or by the imagery provider.\n * @type {TextureMagnificationFilter}\n * @default TextureMagnificationFilter.LINEAR\n */\n\nImageryLayer.DEFAULT_MAGNIFICATION_FILTER = TextureMagnificationFilter.LINEAR;\n/**\n * This value is used as the default threshold for color-to-alpha if one is not provided\n * during construction or by the imagery provider.\n * @type {Number}\n * @default 0.004\n */\n\nImageryLayer.DEFAULT_APPLY_COLOR_TO_ALPHA_THRESHOLD = 0.004;\n/**\n * Gets a value indicating whether this layer is the base layer in the\n * {@link ImageryLayerCollection}.  The base layer is the one that underlies all\n * others.  It is special in that it is treated as if it has global rectangle, even if\n * it actually does not, by stretching the texels at the edges over the entire\n * globe.\n *\n * @returns {Boolean} true if this is the base layer; otherwise, false.\n */\n\nImageryLayer.prototype.isBaseLayer = function () {\n  return this._isBaseLayer;\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see ImageryLayer#destroy\n */\n\n\nImageryLayer.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * imageryLayer = imageryLayer && imageryLayer.destroy();\n *\n * @see ImageryLayer#isDestroyed\n */\n\n\nImageryLayer.prototype.destroy = function () {\n  return destroyObject(this);\n};\n\nvar imageryBoundsScratch = new Rectangle();\nvar tileImageryBoundsScratch = new Rectangle();\nvar clippedRectangleScratch = new Rectangle();\nvar terrainRectangleScratch = new Rectangle();\n/**\n * Computes the intersection of this layer's rectangle with the imagery provider's availability rectangle,\n * producing the overall bounds of imagery that can be produced by this layer.\n *\n * @returns {Promise.<Rectangle>} A promise to a rectangle which defines the overall bounds of imagery that can be produced by this layer.\n *\n * @example\n * // Zoom to an imagery layer.\n * imageryLayer.getViewableRectangle().then(function (rectangle) {\n *     return camera.flyTo({\n *         destination: rectangle\n *     });\n * });\n */\n\nImageryLayer.prototype.getViewableRectangle = function () {\n  var imageryProvider = this._imageryProvider;\n  var rectangle = this._rectangle;\n  return imageryProvider.readyPromise.then(function () {\n    return Rectangle.intersection(imageryProvider.rectangle, rectangle);\n  });\n};\n/**\n * Create skeletons for the imagery tiles that partially or completely overlap a given terrain\n * tile.\n *\n * @private\n *\n * @param {Tile} tile The terrain tile.\n * @param {TerrainProvider} terrainProvider The terrain provider associated with the terrain tile.\n * @param {Number} insertionPoint The position to insert new skeletons before in the tile's imagery list.\n * @returns {Boolean} true if this layer overlaps any portion of the terrain tile; otherwise, false.\n */\n\n\nImageryLayer.prototype._createTileImagerySkeletons = function (tile, terrainProvider, insertionPoint) {\n  var surfaceTile = tile.data;\n\n  if (defined(this._minimumTerrainLevel) && tile.level < this._minimumTerrainLevel) {\n    return false;\n  }\n\n  if (defined(this._maximumTerrainLevel) && tile.level > this._maximumTerrainLevel) {\n    return false;\n  }\n\n  var imageryProvider = this._imageryProvider;\n\n  if (!defined(insertionPoint)) {\n    insertionPoint = surfaceTile.imagery.length;\n  }\n\n  if (!imageryProvider.ready) {\n    // The imagery provider is not ready, so we can't create skeletons, yet.\n    // Instead, add a placeholder so that we'll know to create\n    // the skeletons once the provider is ready.\n    this._skeletonPlaceholder.loadingImagery.addReference();\n\n    surfaceTile.imagery.splice(insertionPoint, 0, this._skeletonPlaceholder);\n    return true;\n  } // Use Web Mercator for our texture coordinate computations if this imagery layer uses\n  // that projection and the terrain tile falls entirely inside the valid bounds of the\n  // projection.\n\n\n  var useWebMercatorT = imageryProvider.tilingScheme.projection instanceof WebMercatorProjection && tile.rectangle.north < WebMercatorProjection.MaximumLatitude && tile.rectangle.south > -WebMercatorProjection.MaximumLatitude; // Compute the rectangle of the imagery from this imageryProvider that overlaps\n  // the geometry tile.  The ImageryProvider and ImageryLayer both have the\n  // opportunity to constrain the rectangle.  The imagery TilingScheme's rectangle\n  // always fully contains the ImageryProvider's rectangle.\n\n  var imageryBounds = Rectangle.intersection(imageryProvider.rectangle, this._rectangle, imageryBoundsScratch);\n  var rectangle = Rectangle.intersection(tile.rectangle, imageryBounds, tileImageryBoundsScratch);\n\n  if (!defined(rectangle)) {\n    // There is no overlap between this terrain tile and this imagery\n    // provider.  Unless this is the base layer, no skeletons need to be created.\n    // We stretch texels at the edge of the base layer over the entire globe.\n    if (!this.isBaseLayer()) {\n      return false;\n    }\n\n    var baseImageryRectangle = imageryBounds;\n    var baseTerrainRectangle = tile.rectangle;\n    rectangle = tileImageryBoundsScratch;\n\n    if (baseTerrainRectangle.south >= baseImageryRectangle.north) {\n      rectangle.north = rectangle.south = baseImageryRectangle.north;\n    } else if (baseTerrainRectangle.north <= baseImageryRectangle.south) {\n      rectangle.north = rectangle.south = baseImageryRectangle.south;\n    } else {\n      rectangle.south = Math.max(baseTerrainRectangle.south, baseImageryRectangle.south);\n      rectangle.north = Math.min(baseTerrainRectangle.north, baseImageryRectangle.north);\n    }\n\n    if (baseTerrainRectangle.west >= baseImageryRectangle.east) {\n      rectangle.west = rectangle.east = baseImageryRectangle.east;\n    } else if (baseTerrainRectangle.east <= baseImageryRectangle.west) {\n      rectangle.west = rectangle.east = baseImageryRectangle.west;\n    } else {\n      rectangle.west = Math.max(baseTerrainRectangle.west, baseImageryRectangle.west);\n      rectangle.east = Math.min(baseTerrainRectangle.east, baseImageryRectangle.east);\n    }\n  }\n\n  var latitudeClosestToEquator = 0.0;\n\n  if (rectangle.south > 0.0) {\n    latitudeClosestToEquator = rectangle.south;\n  } else if (rectangle.north < 0.0) {\n    latitudeClosestToEquator = rectangle.north;\n  } // Compute the required level in the imagery tiling scheme.\n  // The errorRatio should really be imagerySSE / terrainSSE rather than this hard-coded value.\n  // But first we need configurable imagery SSE and we need the rendering to be able to handle more\n  // images attached to a terrain tile than there are available texture units.  So that's for the future.\n\n\n  var errorRatio = 1.0;\n  var targetGeometricError = errorRatio * terrainProvider.getLevelMaximumGeometricError(tile.level);\n  var imageryLevel = getLevelWithMaximumTexelSpacing(this, targetGeometricError, latitudeClosestToEquator);\n  imageryLevel = Math.max(0, imageryLevel);\n  var maximumLevel = imageryProvider.maximumLevel;\n\n  if (imageryLevel > maximumLevel) {\n    imageryLevel = maximumLevel;\n  }\n\n  if (defined(imageryProvider.minimumLevel)) {\n    var minimumLevel = imageryProvider.minimumLevel;\n\n    if (imageryLevel < minimumLevel) {\n      imageryLevel = minimumLevel;\n    }\n  }\n\n  var imageryTilingScheme = imageryProvider.tilingScheme;\n  var northwestTileCoordinates = imageryTilingScheme.positionToTileXY(Rectangle.northwest(rectangle), imageryLevel);\n  var southeastTileCoordinates = imageryTilingScheme.positionToTileXY(Rectangle.southeast(rectangle), imageryLevel); // If the southeast corner of the rectangle lies very close to the north or west side\n  // of the southeast tile, we don't actually need the southernmost or easternmost\n  // tiles.\n  // Similarly, if the northwest corner of the rectangle lies very close to the south or east side\n  // of the northwest tile, we don't actually need the northernmost or westernmost tiles.\n  // We define \"very close\" as being within 1/512 of the width of the tile.\n\n  var veryCloseX = tile.rectangle.width / 512.0;\n  var veryCloseY = tile.rectangle.height / 512.0;\n  var northwestTileRectangle = imageryTilingScheme.tileXYToRectangle(northwestTileCoordinates.x, northwestTileCoordinates.y, imageryLevel);\n\n  if (Math.abs(northwestTileRectangle.south - tile.rectangle.north) < veryCloseY && northwestTileCoordinates.y < southeastTileCoordinates.y) {\n    ++northwestTileCoordinates.y;\n  }\n\n  if (Math.abs(northwestTileRectangle.east - tile.rectangle.west) < veryCloseX && northwestTileCoordinates.x < southeastTileCoordinates.x) {\n    ++northwestTileCoordinates.x;\n  }\n\n  var southeastTileRectangle = imageryTilingScheme.tileXYToRectangle(southeastTileCoordinates.x, southeastTileCoordinates.y, imageryLevel);\n\n  if (Math.abs(southeastTileRectangle.north - tile.rectangle.south) < veryCloseY && southeastTileCoordinates.y > northwestTileCoordinates.y) {\n    --southeastTileCoordinates.y;\n  }\n\n  if (Math.abs(southeastTileRectangle.west - tile.rectangle.east) < veryCloseX && southeastTileCoordinates.x > northwestTileCoordinates.x) {\n    --southeastTileCoordinates.x;\n  } // Create TileImagery instances for each imagery tile overlapping this terrain tile.\n  // We need to do all texture coordinate computations in the imagery tile's tiling scheme.\n\n\n  var terrainRectangle = Rectangle.clone(tile.rectangle, terrainRectangleScratch);\n  var imageryRectangle = imageryTilingScheme.tileXYToRectangle(northwestTileCoordinates.x, northwestTileCoordinates.y, imageryLevel);\n  var clippedImageryRectangle = Rectangle.intersection(imageryRectangle, imageryBounds, clippedRectangleScratch);\n  var imageryTileXYToRectangle;\n\n  if (useWebMercatorT) {\n    imageryTilingScheme.rectangleToNativeRectangle(terrainRectangle, terrainRectangle);\n    imageryTilingScheme.rectangleToNativeRectangle(imageryRectangle, imageryRectangle);\n    imageryTilingScheme.rectangleToNativeRectangle(clippedImageryRectangle, clippedImageryRectangle);\n    imageryTilingScheme.rectangleToNativeRectangle(imageryBounds, imageryBounds);\n    imageryTileXYToRectangle = imageryTilingScheme.tileXYToNativeRectangle.bind(imageryTilingScheme);\n    veryCloseX = terrainRectangle.width / 512.0;\n    veryCloseY = terrainRectangle.height / 512.0;\n  } else {\n    imageryTileXYToRectangle = imageryTilingScheme.tileXYToRectangle.bind(imageryTilingScheme);\n  }\n\n  var minU;\n  var maxU = 0.0;\n  var minV = 1.0;\n  var maxV; // If this is the northern-most or western-most tile in the imagery tiling scheme,\n  // it may not start at the northern or western edge of the terrain tile.\n  // Calculate where it does start.\n\n  if (!this.isBaseLayer() && Math.abs(clippedImageryRectangle.west - terrainRectangle.west) >= veryCloseX) {\n    maxU = Math.min(1.0, (clippedImageryRectangle.west - terrainRectangle.west) / terrainRectangle.width);\n  }\n\n  if (!this.isBaseLayer() && Math.abs(clippedImageryRectangle.north - terrainRectangle.north) >= veryCloseY) {\n    minV = Math.max(0.0, (clippedImageryRectangle.north - terrainRectangle.south) / terrainRectangle.height);\n  }\n\n  var initialMinV = minV;\n\n  for (var i = northwestTileCoordinates.x; i <= southeastTileCoordinates.x; i++) {\n    minU = maxU;\n    imageryRectangle = imageryTileXYToRectangle(i, northwestTileCoordinates.y, imageryLevel);\n    clippedImageryRectangle = Rectangle.simpleIntersection(imageryRectangle, imageryBounds, clippedRectangleScratch);\n\n    if (!defined(clippedImageryRectangle)) {\n      continue;\n    }\n\n    maxU = Math.min(1.0, (clippedImageryRectangle.east - terrainRectangle.west) / terrainRectangle.width); // If this is the eastern-most imagery tile mapped to this terrain tile,\n    // and there are more imagery tiles to the east of this one, the maxU\n    // should be 1.0 to make sure rounding errors don't make the last\n    // image fall shy of the edge of the terrain tile.\n\n    if (i === southeastTileCoordinates.x && (this.isBaseLayer() || Math.abs(clippedImageryRectangle.east - terrainRectangle.east) < veryCloseX)) {\n      maxU = 1.0;\n    }\n\n    minV = initialMinV;\n\n    for (var j = northwestTileCoordinates.y; j <= southeastTileCoordinates.y; j++) {\n      maxV = minV;\n      imageryRectangle = imageryTileXYToRectangle(i, j, imageryLevel);\n      clippedImageryRectangle = Rectangle.simpleIntersection(imageryRectangle, imageryBounds, clippedRectangleScratch);\n\n      if (!defined(clippedImageryRectangle)) {\n        continue;\n      }\n\n      minV = Math.max(0.0, (clippedImageryRectangle.south - terrainRectangle.south) / terrainRectangle.height); // If this is the southern-most imagery tile mapped to this terrain tile,\n      // and there are more imagery tiles to the south of this one, the minV\n      // should be 0.0 to make sure rounding errors don't make the last\n      // image fall shy of the edge of the terrain tile.\n\n      if (j === southeastTileCoordinates.y && (this.isBaseLayer() || Math.abs(clippedImageryRectangle.south - terrainRectangle.south) < veryCloseY)) {\n        minV = 0.0;\n      }\n\n      var texCoordsRectangle = new Cartesian4(minU, minV, maxU, maxV);\n      var imagery = this.getImageryFromCache(i, j, imageryLevel);\n      surfaceTile.imagery.splice(insertionPoint, 0, new TileImagery(imagery, texCoordsRectangle, useWebMercatorT));\n      ++insertionPoint;\n    }\n  }\n\n  return true;\n};\n/**\n * Calculate the translation and scale for a particular {@link TileImagery} attached to a\n * particular terrain tile.\n *\n * @private\n *\n * @param {Tile} tile The terrain tile.\n * @param {TileImagery} tileImagery The imagery tile mapping.\n * @returns {Cartesian4} The translation and scale where X and Y are the translation and Z and W\n *          are the scale.\n */\n\n\nImageryLayer.prototype._calculateTextureTranslationAndScale = function (tile, tileImagery) {\n  var imageryRectangle = tileImagery.readyImagery.rectangle;\n  var terrainRectangle = tile.rectangle;\n\n  if (tileImagery.useWebMercatorT) {\n    var tilingScheme = tileImagery.readyImagery.imageryLayer.imageryProvider.tilingScheme;\n    imageryRectangle = tilingScheme.rectangleToNativeRectangle(imageryRectangle, imageryBoundsScratch);\n    terrainRectangle = tilingScheme.rectangleToNativeRectangle(terrainRectangle, terrainRectangleScratch);\n  }\n\n  var terrainWidth = terrainRectangle.width;\n  var terrainHeight = terrainRectangle.height;\n  var scaleX = terrainWidth / imageryRectangle.width;\n  var scaleY = terrainHeight / imageryRectangle.height;\n  return new Cartesian4(scaleX * (terrainRectangle.west - imageryRectangle.west) / terrainWidth, scaleY * (terrainRectangle.south - imageryRectangle.south) / terrainHeight, scaleX, scaleY);\n};\n/**\n * Request a particular piece of imagery from the imagery provider.  This method handles raising an\n * error event if the request fails, and retrying the request if necessary.\n *\n * @private\n *\n * @param {Imagery} imagery The imagery to request.\n */\n\n\nImageryLayer.prototype._requestImagery = function (imagery) {\n  var imageryProvider = this._imageryProvider;\n  var that = this;\n\n  function success(image) {\n    if (!defined(image)) {\n      return failure();\n    }\n\n    imagery.image = image;\n    imagery.state = ImageryState.RECEIVED;\n    imagery.request = undefined;\n    TileProviderError.handleSuccess(that._requestImageError);\n  }\n\n  function failure(e) {\n    if (imagery.request.state === RequestState.CANCELLED) {\n      // Cancelled due to low priority - try again later.\n      imagery.state = ImageryState.UNLOADED;\n      imagery.request = undefined;\n      return;\n    } // Initially assume failure.  handleError may retry, in which case the state will\n    // change to TRANSITIONING.\n\n\n    imagery.state = ImageryState.FAILED;\n    imagery.request = undefined;\n    var message = \"Failed to obtain image tile X: \" + imagery.x + \" Y: \" + imagery.y + \" Level: \" + imagery.level + \".\";\n    that._requestImageError = TileProviderError.handleError(that._requestImageError, imageryProvider, imageryProvider.errorEvent, message, imagery.x, imagery.y, imagery.level, doRequest, e);\n  }\n\n  function doRequest() {\n    var request = new Request({\n      throttle: false,\n      throttleByServer: true,\n      type: RequestType.IMAGERY\n    });\n    imagery.request = request;\n    imagery.state = ImageryState.TRANSITIONING;\n    var imagePromise = imageryProvider.requestImage(imagery.x, imagery.y, imagery.level, request);\n\n    if (!defined(imagePromise)) {\n      // Too many parallel requests, so postpone loading tile.\n      imagery.state = ImageryState.UNLOADED;\n      imagery.request = undefined;\n      return;\n    }\n\n    if (defined(imageryProvider.getTileCredits)) {\n      imagery.credits = imageryProvider.getTileCredits(imagery.x, imagery.y, imagery.level);\n    }\n\n    when(imagePromise, success, failure);\n  }\n\n  doRequest();\n};\n\nImageryLayer.prototype._createTextureWebGL = function (context, imagery) {\n  var sampler = new Sampler({\n    minificationFilter: this.minificationFilter,\n    magnificationFilter: this.magnificationFilter\n  });\n  var image = imagery.image;\n\n  if (defined(image.internalFormat)) {\n    return new Texture({\n      context: context,\n      pixelFormat: image.internalFormat,\n      width: image.width,\n      height: image.height,\n      source: {\n        arrayBufferView: image.bufferView\n      },\n      sampler: sampler\n    });\n  }\n\n  return new Texture({\n    context: context,\n    source: image,\n    pixelFormat: this._imageryProvider.hasAlphaChannel ? PixelFormat.RGBA : PixelFormat.RGB,\n    sampler: sampler\n  });\n};\n/**\n * Create a WebGL texture for a given {@link Imagery} instance.\n *\n * @private\n *\n * @param {Context} context The rendered context to use to create textures.\n * @param {Imagery} imagery The imagery for which to create a texture.\n */\n\n\nImageryLayer.prototype._createTexture = function (context, imagery) {\n  var imageryProvider = this._imageryProvider;\n  var image = imagery.image; // If this imagery provider has a discard policy, use it to check if this\n  // image should be discarded.\n\n  if (defined(imageryProvider.tileDiscardPolicy)) {\n    var discardPolicy = imageryProvider.tileDiscardPolicy;\n\n    if (defined(discardPolicy)) {\n      // If the discard policy is not ready yet, transition back to the\n      // RECEIVED state and we'll try again next time.\n      if (!discardPolicy.isReady()) {\n        imagery.state = ImageryState.RECEIVED;\n        return;\n      } // Mark discarded imagery tiles invalid.  Parent imagery will be used instead.\n\n\n      if (discardPolicy.shouldDiscardImage(image)) {\n        imagery.state = ImageryState.INVALID;\n        return;\n      }\n    }\n  } //>>includeStart('debug', pragmas.debug);\n\n\n  if (this.minificationFilter !== TextureMinificationFilter.NEAREST && this.minificationFilter !== TextureMinificationFilter.LINEAR) {\n    throw new DeveloperError(\"ImageryLayer minification filter must be NEAREST or LINEAR\");\n  } //>>includeEnd('debug');\n  // Imagery does not need to be discarded, so upload it to WebGL.\n\n\n  var texture = this._createTextureWebGL(context, imagery);\n\n  if (imageryProvider.tilingScheme.projection instanceof WebMercatorProjection) {\n    imagery.textureWebMercator = texture;\n  } else {\n    imagery.texture = texture;\n  }\n\n  imagery.image = undefined;\n  imagery.state = ImageryState.TEXTURE_LOADED;\n};\n\nfunction getSamplerKey(minificationFilter, magnificationFilter, maximumAnisotropy) {\n  return minificationFilter + \":\" + magnificationFilter + \":\" + maximumAnisotropy;\n}\n\nImageryLayer.prototype._finalizeReprojectTexture = function (context, texture) {\n  var minificationFilter = this.minificationFilter;\n  var magnificationFilter = this.magnificationFilter;\n  var usesLinearTextureFilter = minificationFilter === TextureMinificationFilter.LINEAR && magnificationFilter === TextureMagnificationFilter.LINEAR; // Use mipmaps if this texture has power-of-two dimensions.\n  // In addition, mipmaps are only generated if the texture filters are both LINEAR.\n\n  if (usesLinearTextureFilter && !PixelFormat.isCompressedFormat(texture.pixelFormat) && CesiumMath.isPowerOfTwo(texture.width) && CesiumMath.isPowerOfTwo(texture.height)) {\n    minificationFilter = TextureMinificationFilter.LINEAR_MIPMAP_LINEAR;\n    var maximumSupportedAnisotropy = ContextLimits.maximumTextureFilterAnisotropy;\n    var maximumAnisotropy = Math.min(maximumSupportedAnisotropy, defaultValue(this._maximumAnisotropy, maximumSupportedAnisotropy));\n    var mipmapSamplerKey = getSamplerKey(minificationFilter, magnificationFilter, maximumAnisotropy);\n    var mipmapSamplers = context.cache.imageryLayerMipmapSamplers;\n\n    if (!defined(mipmapSamplers)) {\n      mipmapSamplers = {};\n      context.cache.imageryLayerMipmapSamplers = mipmapSamplers;\n    }\n\n    var mipmapSampler = mipmapSamplers[mipmapSamplerKey];\n\n    if (!defined(mipmapSampler)) {\n      mipmapSampler = mipmapSamplers[mipmapSamplerKey] = new Sampler({\n        wrapS: TextureWrap.CLAMP_TO_EDGE,\n        wrapT: TextureWrap.CLAMP_TO_EDGE,\n        minificationFilter: minificationFilter,\n        magnificationFilter: magnificationFilter,\n        maximumAnisotropy: maximumAnisotropy\n      });\n    }\n\n    texture.generateMipmap(MipmapHint.NICEST);\n    texture.sampler = mipmapSampler;\n  } else {\n    var nonMipmapSamplerKey = getSamplerKey(minificationFilter, magnificationFilter, 0);\n    var nonMipmapSamplers = context.cache.imageryLayerNonMipmapSamplers;\n\n    if (!defined(nonMipmapSamplers)) {\n      nonMipmapSamplers = {};\n      context.cache.imageryLayerNonMipmapSamplers = nonMipmapSamplers;\n    }\n\n    var nonMipmapSampler = nonMipmapSamplers[nonMipmapSamplerKey];\n\n    if (!defined(nonMipmapSampler)) {\n      nonMipmapSampler = nonMipmapSamplers[nonMipmapSamplerKey] = new Sampler({\n        wrapS: TextureWrap.CLAMP_TO_EDGE,\n        wrapT: TextureWrap.CLAMP_TO_EDGE,\n        minificationFilter: minificationFilter,\n        magnificationFilter: magnificationFilter\n      });\n    }\n\n    texture.sampler = nonMipmapSampler;\n  }\n};\n/**\n * Enqueues a command re-projecting a texture to a {@link GeographicProjection} on the next update, if necessary, and generate\n * mipmaps for the geographic texture.\n *\n * @private\n *\n * @param {FrameState} frameState The frameState.\n * @param {Imagery} imagery The imagery instance to reproject.\n * @param {Boolean} [needGeographicProjection=true] True to reproject to geographic, or false if Web Mercator is fine.\n */\n\n\nImageryLayer.prototype._reprojectTexture = function (frameState, imagery, needGeographicProjection) {\n  var texture = imagery.textureWebMercator || imagery.texture;\n  var rectangle = imagery.rectangle;\n  var context = frameState.context;\n  needGeographicProjection = defaultValue(needGeographicProjection, true); // Reproject this texture if it is not already in a geographic projection and\n  // the pixels are more than 1e-5 radians apart.  The pixel spacing cutoff\n  // avoids precision problems in the reprojection transformation while making\n  // no noticeable difference in the georeferencing of the image.\n\n  if (needGeographicProjection && !(this._imageryProvider.tilingScheme.projection instanceof GeographicProjection) && rectangle.width / texture.width > 1e-5) {\n    var that = this;\n    imagery.addReference();\n    var computeCommand = new ComputeCommand({\n      persists: true,\n      owner: this,\n      // Update render resources right before execution instead of now.\n      // This allows different ImageryLayers to share the same vao and buffers.\n      preExecute: function (command) {\n        reprojectToGeographic(command, context, texture, imagery.rectangle);\n      },\n      postExecute: function (outputTexture) {\n        imagery.texture = outputTexture;\n\n        that._finalizeReprojectTexture(context, outputTexture);\n\n        imagery.state = ImageryState.READY;\n        imagery.releaseReference();\n      }\n    });\n\n    this._reprojectComputeCommands.push(computeCommand);\n  } else {\n    if (needGeographicProjection) {\n      imagery.texture = texture;\n    }\n\n    this._finalizeReprojectTexture(context, texture);\n\n    imagery.state = ImageryState.READY;\n  }\n};\n/**\n * Updates frame state to execute any queued texture re-projections.\n *\n * @private\n *\n * @param {FrameState} frameState The frameState.\n */\n\n\nImageryLayer.prototype.queueReprojectionCommands = function (frameState) {\n  var computeCommands = this._reprojectComputeCommands;\n  var length = computeCommands.length;\n\n  for (var i = 0; i < length; ++i) {\n    frameState.commandList.push(computeCommands[i]);\n  }\n\n  computeCommands.length = 0;\n};\n/**\n * Cancels re-projection commands queued for the next frame.\n *\n * @private\n */\n\n\nImageryLayer.prototype.cancelReprojections = function () {\n  this._reprojectComputeCommands.length = 0;\n};\n\nImageryLayer.prototype.getImageryFromCache = function (x, y, level, imageryRectangle) {\n  var cacheKey = getImageryCacheKey(x, y, level);\n  var imagery = this._imageryCache[cacheKey];\n\n  if (!defined(imagery)) {\n    imagery = new Imagery(this, x, y, level, imageryRectangle);\n    this._imageryCache[cacheKey] = imagery;\n  }\n\n  imagery.addReference();\n  return imagery;\n};\n\nImageryLayer.prototype.removeImageryFromCache = function (imagery) {\n  var cacheKey = getImageryCacheKey(imagery.x, imagery.y, imagery.level);\n  delete this._imageryCache[cacheKey];\n};\n\nfunction getImageryCacheKey(x, y, level) {\n  return JSON.stringify([x, y, level]);\n}\n\nvar uniformMap = {\n  u_textureDimensions: function () {\n    return this.textureDimensions;\n  },\n  u_texture: function () {\n    return this.texture;\n  },\n  textureDimensions: new Cartesian2(),\n  texture: undefined\n};\nvar float32ArrayScratch = FeatureDetection.supportsTypedArrays() ? new Float32Array(2 * 64) : undefined;\n\nfunction reprojectToGeographic(command, context, texture, rectangle) {\n  // This function has gone through a number of iterations, because GPUs are awesome.\n  //\n  // Originally, we had a very simple vertex shader and computed the Web Mercator texture coordinates\n  // per-fragment in the fragment shader.  That worked well, except on mobile devices, because\n  // fragment shaders have limited precision on many mobile devices.  The result was smearing artifacts\n  // at medium zoom levels because different geographic texture coordinates would be reprojected to Web\n  // Mercator as the same value.\n  //\n  // Our solution was to reproject to Web Mercator in the vertex shader instead of the fragment shader.\n  // This required far more vertex data.  With fragment shader reprojection, we only needed a single quad.\n  // But to achieve the same precision with vertex shader reprojection, we needed a vertex for each\n  // output pixel.  So we used a grid of 256x256 vertices, because most of our imagery\n  // tiles are 256x256.  Fortunately the grid could be created and uploaded to the GPU just once and\n  // re-used for all reprojections, so the performance was virtually unchanged from our original fragment\n  // shader approach.  See https://github.com/CesiumGS/cesium/pull/714.\n  //\n  // Over a year later, we noticed (https://github.com/CesiumGS/cesium/issues/2110)\n  // that our reprojection code was creating a rare but severe artifact on some GPUs (Intel HD 4600\n  // for one).  The problem was that the GLSL sin function on these GPUs had a discontinuity at fine scales in\n  // a few places.\n  //\n  // We solved this by implementing a more reliable sin function based on the CORDIC algorithm\n  // (https://github.com/CesiumGS/cesium/pull/2111).  Even though this was a fair\n  // amount of code to be executing per vertex, the performance seemed to be pretty good on most GPUs.\n  // Unfortunately, on some GPUs, the performance was absolutely terrible\n  // (https://github.com/CesiumGS/cesium/issues/2258).\n  //\n  // So that brings us to our current solution, the one you see here.  Effectively, we compute the Web\n  // Mercator texture coordinates on the CPU and store the T coordinate with each vertex (the S coordinate\n  // is the same in Geographic and Web Mercator).  To make this faster, we reduced our reprojection mesh\n  // to be only 2 vertices wide and 64 vertices high.  We should have reduced the width to 2 sooner,\n  // because the extra vertices weren't buying us anything.  The height of 64 means we are technically\n  // doing a slightly less accurate reprojection than we were before, but we can't see the difference\n  // so it's worth the 4x speedup.\n  var reproject = context.cache.imageryLayer_reproject;\n\n  if (!defined(reproject)) {\n    reproject = context.cache.imageryLayer_reproject = {\n      vertexArray: undefined,\n      shaderProgram: undefined,\n      sampler: undefined,\n      destroy: function () {\n        if (defined(this.framebuffer)) {\n          this.framebuffer.destroy();\n        }\n\n        if (defined(this.vertexArray)) {\n          this.vertexArray.destroy();\n        }\n\n        if (defined(this.shaderProgram)) {\n          this.shaderProgram.destroy();\n        }\n      }\n    };\n    var positions = new Float32Array(2 * 64 * 2);\n    var index = 0;\n\n    for (var j = 0; j < 64; ++j) {\n      var y = j / 63.0;\n      positions[index++] = 0.0;\n      positions[index++] = y;\n      positions[index++] = 1.0;\n      positions[index++] = y;\n    }\n\n    var reprojectAttributeIndices = {\n      position: 0,\n      webMercatorT: 1\n    };\n    var indices = TerrainProvider.getRegularGridIndices(2, 64);\n    var indexBuffer = Buffer.createIndexBuffer({\n      context: context,\n      typedArray: indices,\n      usage: BufferUsage.STATIC_DRAW,\n      indexDatatype: IndexDatatype.UNSIGNED_SHORT\n    });\n    reproject.vertexArray = new VertexArray({\n      context: context,\n      attributes: [{\n        index: reprojectAttributeIndices.position,\n        vertexBuffer: Buffer.createVertexBuffer({\n          context: context,\n          typedArray: positions,\n          usage: BufferUsage.STATIC_DRAW\n        }),\n        componentsPerAttribute: 2\n      }, {\n        index: reprojectAttributeIndices.webMercatorT,\n        vertexBuffer: Buffer.createVertexBuffer({\n          context: context,\n          sizeInBytes: 64 * 2 * 4,\n          usage: BufferUsage.STREAM_DRAW\n        }),\n        componentsPerAttribute: 1\n      }],\n      indexBuffer: indexBuffer\n    });\n    var vs = new ShaderSource({\n      sources: [ReprojectWebMercatorVS]\n    });\n    reproject.shaderProgram = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: ReprojectWebMercatorFS,\n      attributeLocations: reprojectAttributeIndices\n    });\n    reproject.sampler = new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: TextureMinificationFilter.LINEAR,\n      magnificationFilter: TextureMagnificationFilter.LINEAR\n    });\n  }\n\n  texture.sampler = reproject.sampler;\n  var width = texture.width;\n  var height = texture.height;\n  uniformMap.textureDimensions.x = width;\n  uniformMap.textureDimensions.y = height;\n  uniformMap.texture = texture;\n  var sinLatitude = Math.sin(rectangle.south);\n  var southMercatorY = 0.5 * Math.log((1 + sinLatitude) / (1 - sinLatitude));\n  sinLatitude = Math.sin(rectangle.north);\n  var northMercatorY = 0.5 * Math.log((1 + sinLatitude) / (1 - sinLatitude));\n  var oneOverMercatorHeight = 1.0 / (northMercatorY - southMercatorY);\n  var outputTexture = new Texture({\n    context: context,\n    width: width,\n    height: height,\n    pixelFormat: texture.pixelFormat,\n    pixelDatatype: texture.pixelDatatype,\n    preMultiplyAlpha: texture.preMultiplyAlpha\n  }); // Allocate memory for the mipmaps.  Failure to do this before rendering\n  // to the texture via the FBO, and calling generateMipmap later,\n  // will result in the texture appearing blank.  I can't pretend to\n  // understand exactly why this is.\n\n  if (CesiumMath.isPowerOfTwo(width) && CesiumMath.isPowerOfTwo(height)) {\n    outputTexture.generateMipmap(MipmapHint.NICEST);\n  }\n\n  var south = rectangle.south;\n  var north = rectangle.north;\n  var webMercatorT = float32ArrayScratch;\n  var outputIndex = 0;\n\n  for (var webMercatorTIndex = 0; webMercatorTIndex < 64; ++webMercatorTIndex) {\n    var fraction = webMercatorTIndex / 63.0;\n    var latitude = CesiumMath.lerp(south, north, fraction);\n    sinLatitude = Math.sin(latitude);\n    var mercatorY = 0.5 * Math.log((1.0 + sinLatitude) / (1.0 - sinLatitude));\n    var mercatorFraction = (mercatorY - southMercatorY) * oneOverMercatorHeight;\n    webMercatorT[outputIndex++] = mercatorFraction;\n    webMercatorT[outputIndex++] = mercatorFraction;\n  }\n\n  reproject.vertexArray.getAttribute(1).vertexBuffer.copyFromArrayView(webMercatorT);\n  command.shaderProgram = reproject.shaderProgram;\n  command.outputTexture = outputTexture;\n  command.uniformMap = uniformMap;\n  command.vertexArray = reproject.vertexArray;\n}\n/**\n * Gets the level with the specified world coordinate spacing between texels, or less.\n *\n * @param {ImageryLayer} layer The imagery layer to use.\n * @param {Number} texelSpacing The texel spacing for which to find a corresponding level.\n * @param {Number} latitudeClosestToEquator The latitude closest to the equator that we're concerned with.\n * @returns {Number} The level with the specified texel spacing or less.\n * @private\n */\n\n\nfunction getLevelWithMaximumTexelSpacing(layer, texelSpacing, latitudeClosestToEquator) {\n  // PERFORMANCE_IDEA: factor out the stuff that doesn't change.\n  var imageryProvider = layer._imageryProvider;\n  var tilingScheme = imageryProvider.tilingScheme;\n  var ellipsoid = tilingScheme.ellipsoid;\n  var latitudeFactor = !(layer._imageryProvider.tilingScheme.projection instanceof GeographicProjection) ? Math.cos(latitudeClosestToEquator) : 1.0;\n  var tilingSchemeRectangle = tilingScheme.rectangle;\n  var levelZeroMaximumTexelSpacing = ellipsoid.maximumRadius * tilingSchemeRectangle.width * latitudeFactor / (imageryProvider.tileWidth * tilingScheme.getNumberOfXTilesAtLevel(0));\n  var twoToTheLevelPower = levelZeroMaximumTexelSpacing / texelSpacing;\n  var level = Math.log(twoToTheLevelPower) / Math.log(2);\n  var rounded = Math.round(level);\n  return rounded | 0;\n}\n\nexport default ImageryLayer;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/ImageryLayer.js"],"names":["Cartesian2","Cartesian4","defaultValue","defined","destroyObject","DeveloperError","FeatureDetection","GeographicProjection","IndexDatatype","CesiumMath","PixelFormat","Rectangle","Request","RequestState","RequestType","TerrainProvider","TileProviderError","WebMercatorProjection","Buffer","BufferUsage","ComputeCommand","ContextLimits","MipmapHint","Sampler","ShaderProgram","ShaderSource","Texture","TextureMagnificationFilter","TextureMinificationFilter","TextureWrap","VertexArray","ReprojectWebMercatorFS","ReprojectWebMercatorVS","when","Imagery","ImagerySplitDirection","ImageryState","TileImagery","ImageryLayer","imageryProvider","options","_imageryProvider","EMPTY_OBJECT","alpha","defaultAlpha","brightness","defaultBrightness","DEFAULT_BRIGHTNESS","contrast","defaultContrast","DEFAULT_CONTRAST","hue","defaultHue","DEFAULT_HUE","saturation","defaultSaturation","DEFAULT_SATURATION","gamma","defaultGamma","DEFAULT_GAMMA","splitDirection","defaultSplit","DEFAULT_SPLIT","minificationFilter","defaultMinificationFilter","DEFAULT_MINIFICATION_FILTER","magnificationFilter","defaultMagnificationFilter","DEFAULT_MAGNIFICATION_FILTER","show","_minimumTerrainLevel","minimumTerrainLevel","_maximumTerrainLevel","maximumTerrainLevel","_rectangle","rectangle","MAX_VALUE","_maximumAnisotropy","maximumAnisotropy","_imageryCache","_skeletonPlaceholder","createPlaceholder","_show","_layerIndex","_isBaseLayer","_requestImageError","undefined","_reprojectComputeCommands","cutoutRectangle","colorToAlpha","colorToAlphaThreshold","DEFAULT_APPLY_COLOR_TO_ALPHA_THRESHOLD","Object","defineProperties","prototype","get","NONE","LINEAR","isBaseLayer","isDestroyed","destroy","imageryBoundsScratch","tileImageryBoundsScratch","clippedRectangleScratch","terrainRectangleScratch","getViewableRectangle","readyPromise","then","intersection","_createTileImagerySkeletons","tile","terrainProvider","insertionPoint","surfaceTile","data","level","imagery","length","ready","loadingImagery","addReference","splice","useWebMercatorT","tilingScheme","projection","north","MaximumLatitude","south","imageryBounds","baseImageryRectangle","baseTerrainRectangle","Math","max","min","west","east","latitudeClosestToEquator","errorRatio","targetGeometricError","getLevelMaximumGeometricError","imageryLevel","getLevelWithMaximumTexelSpacing","maximumLevel","minimumLevel","imageryTilingScheme","northwestTileCoordinates","positionToTileXY","northwest","southeastTileCoordinates","southeast","veryCloseX","width","veryCloseY","height","northwestTileRectangle","tileXYToRectangle","x","y","abs","southeastTileRectangle","terrainRectangle","clone","imageryRectangle","clippedImageryRectangle","imageryTileXYToRectangle","rectangleToNativeRectangle","tileXYToNativeRectangle","bind","minU","maxU","minV","maxV","initialMinV","i","simpleIntersection","j","texCoordsRectangle","getImageryFromCache","_calculateTextureTranslationAndScale","tileImagery","readyImagery","imageryLayer","terrainWidth","terrainHeight","scaleX","scaleY","_requestImagery","that","success","image","failure","state","RECEIVED","request","handleSuccess","e","CANCELLED","UNLOADED","FAILED","message","handleError","errorEvent","doRequest","throttle","throttleByServer","type","IMAGERY","TRANSITIONING","imagePromise","requestImage","getTileCredits","credits","_createTextureWebGL","context","sampler","internalFormat","pixelFormat","source","arrayBufferView","bufferView","hasAlphaChannel","RGBA","RGB","_createTexture","tileDiscardPolicy","discardPolicy","isReady","shouldDiscardImage","INVALID","NEAREST","texture","textureWebMercator","TEXTURE_LOADED","getSamplerKey","_finalizeReprojectTexture","usesLinearTextureFilter","isCompressedFormat","isPowerOfTwo","LINEAR_MIPMAP_LINEAR","maximumSupportedAnisotropy","maximumTextureFilterAnisotropy","mipmapSamplerKey","mipmapSamplers","cache","imageryLayerMipmapSamplers","mipmapSampler","wrapS","CLAMP_TO_EDGE","wrapT","generateMipmap","NICEST","nonMipmapSamplerKey","nonMipmapSamplers","imageryLayerNonMipmapSamplers","nonMipmapSampler","_reprojectTexture","frameState","needGeographicProjection","computeCommand","persists","owner","preExecute","command","reprojectToGeographic","postExecute","outputTexture","READY","releaseReference","push","queueReprojectionCommands","computeCommands","commandList","cancelReprojections","cacheKey","getImageryCacheKey","removeImageryFromCache","JSON","stringify","uniformMap","u_textureDimensions","textureDimensions","u_texture","float32ArrayScratch","supportsTypedArrays","Float32Array","reproject","imageryLayer_reproject","vertexArray","shaderProgram","framebuffer","positions","index","reprojectAttributeIndices","position","webMercatorT","indices","getRegularGridIndices","indexBuffer","createIndexBuffer","typedArray","usage","STATIC_DRAW","indexDatatype","UNSIGNED_SHORT","attributes","vertexBuffer","createVertexBuffer","componentsPerAttribute","sizeInBytes","STREAM_DRAW","vs","sources","fromCache","vertexShaderSource","fragmentShaderSource","attributeLocations","sinLatitude","sin","southMercatorY","log","northMercatorY","oneOverMercatorHeight","pixelDatatype","preMultiplyAlpha","outputIndex","webMercatorTIndex","fraction","latitude","lerp","mercatorY","mercatorFraction","getAttribute","copyFromArrayView","layer","texelSpacing","ellipsoid","latitudeFactor","cos","tilingSchemeRectangle","levelZeroMaximumTexelSpacing","maximumRadius","tileWidth","getNumberOfXTilesAtLevel","twoToTheLevelPower","rounded","round"],"mappings":"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","sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport GeographicProjection from \"../Core/GeographicProjection.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Request from \"../Core/Request.js\";\nimport RequestState from \"../Core/RequestState.js\";\nimport RequestType from \"../Core/RequestType.js\";\nimport TerrainProvider from \"../Core/TerrainProvider.js\";\nimport TileProviderError from \"../Core/TileProviderError.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ComputeCommand from \"../Renderer/ComputeCommand.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport MipmapHint from \"../Renderer/MipmapHint.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport ReprojectWebMercatorFS from \"../Shaders/ReprojectWebMercatorFS.js\";\nimport ReprojectWebMercatorVS from \"../Shaders/ReprojectWebMercatorVS.js\";\nimport when from \"../ThirdParty/when.js\";\nimport Imagery from \"./Imagery.js\";\nimport ImagerySplitDirection from \"./ImagerySplitDirection.js\";\nimport ImageryState from \"./ImageryState.js\";\nimport TileImagery from \"./TileImagery.js\";\n\n/**\n * An imagery layer that displays tiled image data from a single imagery provider\n * on a {@link Globe}.\n *\n * @alias ImageryLayer\n * @constructor\n *\n * @param {ImageryProvider} imageryProvider The imagery provider to use.\n * @param {Object} [options] Object with the following properties:\n * @param {Rectangle} [options.rectangle=imageryProvider.rectangle] The rectangle of the layer.  This rectangle\n *        can limit the visible portion of the imagery provider.\n * @param {Number|Function} [options.alpha=1.0] The alpha blending value of this layer, from 0.0 to 1.0.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates of the\n *                          imagery tile for which the alpha is required, and it is expected to return\n *                          the alpha value to use for the tile.\n * @param {Number|Function} [options.brightness=1.0] The brightness of this layer.  1.0 uses the unmodified imagery\n *                          color.  Less than 1.0 makes the imagery darker while greater than 1.0 makes it brighter.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates of the\n *                          imagery tile for which the brightness is required, and it is expected to return\n *                          the brightness value to use for the tile.  The function is executed for every\n *                          frame and for every tile, so it must be fast.\n * @param {Number|Function} [options.contrast=1.0] The contrast of this layer.  1.0 uses the unmodified imagery color.\n *                          Less than 1.0 reduces the contrast while greater than 1.0 increases it.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates of the\n *                          imagery tile for which the contrast is required, and it is expected to return\n *                          the contrast value to use for the tile.  The function is executed for every\n *                          frame and for every tile, so it must be fast.\n * @param {Number|Function} [options.hue=0.0] The hue of this layer.  0.0 uses the unmodified imagery color.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates\n *                          of the imagery tile for which the hue is required, and it is expected to return\n *                          the contrast value to use for the tile.  The function is executed for every\n *                          frame and for every tile, so it must be fast.\n * @param {Number|Function} [options.saturation=1.0] The saturation of this layer.  1.0 uses the unmodified imagery color.\n *                          Less than 1.0 reduces the saturation while greater than 1.0 increases it.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates\n *                          of the imagery tile for which the saturation is required, and it is expected to return\n *                          the contrast value to use for the tile.  The function is executed for every\n *                          frame and for every tile, so it must be fast.\n * @param {Number|Function} [options.gamma=1.0] The gamma correction to apply to this layer.  1.0 uses the unmodified imagery color.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates of the\n *                          imagery tile for which the gamma is required, and it is expected to return\n *                          the gamma value to use for the tile.  The function is executed for every\n *                          frame and for every tile, so it must be fast.\n * @param {ImagerySplitDirection|Function} [options.splitDirection=ImagerySplitDirection.NONE] The {@link ImagerySplitDirection} split to apply to this layer.\n * @param {TextureMinificationFilter} [options.minificationFilter=TextureMinificationFilter.LINEAR] The\n *                                    texture minification filter to apply to this layer. Possible values\n *                                    are <code>TextureMinificationFilter.LINEAR</code> and\n *                                    <code>TextureMinificationFilter.NEAREST</code>.\n * @param {TextureMagnificationFilter} [options.magnificationFilter=TextureMagnificationFilter.LINEAR] The\n *                                     texture minification filter to apply to this layer. Possible values\n *                                     are <code>TextureMagnificationFilter.LINEAR</code> and\n *                                     <code>TextureMagnificationFilter.NEAREST</code>.\n * @param {Boolean} [options.show=true] True if the layer is shown; otherwise, false.\n * @param {Number} [options.maximumAnisotropy=maximum supported] The maximum anisotropy level to use\n *        for texture filtering.  If this parameter is not specified, the maximum anisotropy supported\n *        by the WebGL stack will be used.  Larger values make the imagery look better in horizon\n *        views.\n * @param {Number} [options.minimumTerrainLevel] The minimum terrain level-of-detail at which to show this imagery layer,\n *                 or undefined to show it at all levels.  Level zero is the least-detailed level.\n * @param {Number} [options.maximumTerrainLevel] The maximum terrain level-of-detail at which to show this imagery layer,\n *                 or undefined to show it at all levels.  Level zero is the least-detailed level.\n * @param {Rectangle} [options.cutoutRectangle] Cartographic rectangle for cutting out a portion of this ImageryLayer.\n * @param {Color} [options.colorToAlpha] Color to be used as alpha.\n * @param {Number} [options.colorToAlphaThreshold=0.004] Threshold for color-to-alpha.\n */\nfunction ImageryLayer(imageryProvider, options) {\n  this._imageryProvider = imageryProvider;\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The alpha blending value of this layer, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number}\n   * @default 1.0\n   */\n  this.alpha = defaultValue(\n    options.alpha,\n    defaultValue(imageryProvider.defaultAlpha, 1.0)\n  );\n\n  /**\n   * The brightness of this layer.  1.0 uses the unmodified imagery color.  Less than 1.0\n   * makes the imagery darker while greater than 1.0 makes it brighter.\n   *\n   * @type {Number}\n   * @default {@link ImageryLayer.DEFAULT_BRIGHTNESS}\n   */\n  this.brightness = defaultValue(\n    options.brightness,\n    defaultValue(\n      imageryProvider.defaultBrightness,\n      ImageryLayer.DEFAULT_BRIGHTNESS\n    )\n  );\n\n  /**\n   * The contrast of this layer.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces\n   * the contrast while greater than 1.0 increases it.\n   *\n   * @type {Number}\n   * @default {@link ImageryLayer.DEFAULT_CONTRAST}\n   */\n  this.contrast = defaultValue(\n    options.contrast,\n    defaultValue(imageryProvider.defaultContrast, ImageryLayer.DEFAULT_CONTRAST)\n  );\n\n  /**\n   * The hue of this layer in radians. 0.0 uses the unmodified imagery color.\n   *\n   * @type {Number}\n   * @default {@link ImageryLayer.DEFAULT_HUE}\n   */\n  this.hue = defaultValue(\n    options.hue,\n    defaultValue(imageryProvider.defaultHue, ImageryLayer.DEFAULT_HUE)\n  );\n\n  /**\n   * The saturation of this layer. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the\n   * saturation while greater than 1.0 increases it.\n   *\n   * @type {Number}\n   * @default {@link ImageryLayer.DEFAULT_SATURATION}\n   */\n  this.saturation = defaultValue(\n    options.saturation,\n    defaultValue(\n      imageryProvider.defaultSaturation,\n      ImageryLayer.DEFAULT_SATURATION\n    )\n  );\n\n  /**\n   * The gamma correction to apply to this layer.  1.0 uses the unmodified imagery color.\n   *\n   * @type {Number}\n   * @default {@link ImageryLayer.DEFAULT_GAMMA}\n   */\n  this.gamma = defaultValue(\n    options.gamma,\n    defaultValue(imageryProvider.defaultGamma, ImageryLayer.DEFAULT_GAMMA)\n  );\n\n  /**\n   * The {@link ImagerySplitDirection} to apply to this layer.\n   *\n   * @type {ImagerySplitDirection}\n   * @default {@link ImageryLayer.DEFAULT_SPLIT}\n   */\n  this.splitDirection = defaultValue(\n    options.splitDirection,\n    defaultValue(imageryProvider.defaultSplit, ImageryLayer.DEFAULT_SPLIT)\n  );\n\n  /**\n   * The {@link TextureMinificationFilter} to apply to this layer.\n   * Possible values are {@link TextureMinificationFilter.LINEAR} (the default)\n   * and {@link TextureMinificationFilter.NEAREST}.\n   *\n   * To take effect, this property must be set immediately after adding the imagery layer.\n   * Once a texture is loaded it won't be possible to change the texture filter used.\n   *\n   * @type {TextureMinificationFilter}\n   * @default {@link ImageryLayer.DEFAULT_MINIFICATION_FILTER}\n   */\n  this.minificationFilter = defaultValue(\n    options.minificationFilter,\n    defaultValue(\n      imageryProvider.defaultMinificationFilter,\n      ImageryLayer.DEFAULT_MINIFICATION_FILTER\n    )\n  );\n\n  /**\n   * The {@link TextureMagnificationFilter} to apply to this layer.\n   * Possible values are {@link TextureMagnificationFilter.LINEAR} (the default)\n   * and {@link TextureMagnificationFilter.NEAREST}.\n   *\n   * To take effect, this property must be set immediately after adding the imagery layer.\n   * Once a texture is loaded it won't be possible to change the texture filter used.\n   *\n   * @type {TextureMagnificationFilter}\n   * @default {@link ImageryLayer.DEFAULT_MAGNIFICATION_FILTER}\n   */\n  this.magnificationFilter = defaultValue(\n    options.magnificationFilter,\n    defaultValue(\n      imageryProvider.defaultMagnificationFilter,\n      ImageryLayer.DEFAULT_MAGNIFICATION_FILTER\n    )\n  );\n\n  /**\n   * Determines if this layer is shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  this._minimumTerrainLevel = options.minimumTerrainLevel;\n  this._maximumTerrainLevel = options.maximumTerrainLevel;\n\n  this._rectangle = defaultValue(options.rectangle, Rectangle.MAX_VALUE);\n  this._maximumAnisotropy = options.maximumAnisotropy;\n\n  this._imageryCache = {};\n\n  this._skeletonPlaceholder = new TileImagery(Imagery.createPlaceholder(this));\n\n  // The value of the show property on the last update.\n  this._show = true;\n\n  // The index of this layer in the ImageryLayerCollection.\n  this._layerIndex = -1;\n\n  // true if this is the base (lowest shown) layer.\n  this._isBaseLayer = false;\n\n  this._requestImageError = undefined;\n\n  this._reprojectComputeCommands = [];\n\n  /**\n   * Rectangle cutout in this layer of imagery.\n   *\n   * @type {Rectangle}\n   */\n  this.cutoutRectangle = options.cutoutRectangle;\n\n  /**\n   * Color value that should be set to transparent.\n   *\n   * @type {Color}\n   */\n  this.colorToAlpha = options.colorToAlpha;\n\n  /**\n   * Normalized (0-1) threshold for color-to-alpha.\n   *\n   * @type {Number}\n   */\n  this.colorToAlphaThreshold = defaultValue(\n    options.colorToAlphaThreshold,\n    ImageryLayer.DEFAULT_APPLY_COLOR_TO_ALPHA_THRESHOLD\n  );\n}\n\nObject.defineProperties(ImageryLayer.prototype, {\n  /**\n   * Gets the imagery provider for this layer.\n   * @memberof ImageryLayer.prototype\n   * @type {ImageryProvider}\n   * @readonly\n   */\n  imageryProvider: {\n    get: function () {\n      return this._imageryProvider;\n    },\n  },\n\n  /**\n   * Gets the rectangle of this layer.  If this rectangle is smaller than the rectangle of the\n   * {@link ImageryProvider}, only a portion of the imagery provider is shown.\n   * @memberof ImageryLayer.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  rectangle: {\n    get: function () {\n      return this._rectangle;\n    },\n  },\n});\n\n/**\n * This value is used as the default brightness for the imagery layer if one is not provided during construction\n * or by the imagery provider. This value does not modify the brightness of the imagery.\n * @type {Number}\n * @default 1.0\n */\nImageryLayer.DEFAULT_BRIGHTNESS = 1.0;\n/**\n * This value is used as the default contrast for the imagery layer if one is not provided during construction\n * or by the imagery provider. This value does not modify the contrast of the imagery.\n * @type {Number}\n * @default 1.0\n */\nImageryLayer.DEFAULT_CONTRAST = 1.0;\n/**\n * This value is used as the default hue for the imagery layer if one is not provided during construction\n * or by the imagery provider. This value does not modify the hue of the imagery.\n * @type {Number}\n * @default 0.0\n */\nImageryLayer.DEFAULT_HUE = 0.0;\n/**\n * This value is used as the default saturation for the imagery layer if one is not provided during construction\n * or by the imagery provider. This value does not modify the saturation of the imagery.\n * @type {Number}\n * @default 1.0\n */\nImageryLayer.DEFAULT_SATURATION = 1.0;\n/**\n * This value is used as the default gamma for the imagery layer if one is not provided during construction\n * or by the imagery provider. This value does not modify the gamma of the imagery.\n * @type {Number}\n * @default 1.0\n */\nImageryLayer.DEFAULT_GAMMA = 1.0;\n\n/**\n * This value is used as the default split for the imagery layer if one is not provided during construction\n * or by the imagery provider.\n * @type {ImagerySplitDirection}\n * @default ImagerySplitDirection.NONE\n */\nImageryLayer.DEFAULT_SPLIT = ImagerySplitDirection.NONE;\n\n/**\n * This value is used as the default texture minification filter for the imagery layer if one is not provided\n * during construction or by the imagery provider.\n * @type {TextureMinificationFilter}\n * @default TextureMinificationFilter.LINEAR\n */\nImageryLayer.DEFAULT_MINIFICATION_FILTER = TextureMinificationFilter.LINEAR;\n\n/**\n * This value is used as the default texture magnification filter for the imagery layer if one is not provided\n * during construction or by the imagery provider.\n * @type {TextureMagnificationFilter}\n * @default TextureMagnificationFilter.LINEAR\n */\nImageryLayer.DEFAULT_MAGNIFICATION_FILTER = TextureMagnificationFilter.LINEAR;\n\n/**\n * This value is used as the default threshold for color-to-alpha if one is not provided\n * during construction or by the imagery provider.\n * @type {Number}\n * @default 0.004\n */\nImageryLayer.DEFAULT_APPLY_COLOR_TO_ALPHA_THRESHOLD = 0.004;\n\n/**\n * Gets a value indicating whether this layer is the base layer in the\n * {@link ImageryLayerCollection}.  The base layer is the one that underlies all\n * others.  It is special in that it is treated as if it has global rectangle, even if\n * it actually does not, by stretching the texels at the edges over the entire\n * globe.\n *\n * @returns {Boolean} true if this is the base layer; otherwise, false.\n */\nImageryLayer.prototype.isBaseLayer = function () {\n  return this._isBaseLayer;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see ImageryLayer#destroy\n */\nImageryLayer.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * imageryLayer = imageryLayer && imageryLayer.destroy();\n *\n * @see ImageryLayer#isDestroyed\n */\nImageryLayer.prototype.destroy = function () {\n  return destroyObject(this);\n};\n\nvar imageryBoundsScratch = new Rectangle();\nvar tileImageryBoundsScratch = new Rectangle();\nvar clippedRectangleScratch = new Rectangle();\nvar terrainRectangleScratch = new Rectangle();\n\n/**\n * Computes the intersection of this layer's rectangle with the imagery provider's availability rectangle,\n * producing the overall bounds of imagery that can be produced by this layer.\n *\n * @returns {Promise.<Rectangle>} A promise to a rectangle which defines the overall bounds of imagery that can be produced by this layer.\n *\n * @example\n * // Zoom to an imagery layer.\n * imageryLayer.getViewableRectangle().then(function (rectangle) {\n *     return camera.flyTo({\n *         destination: rectangle\n *     });\n * });\n */\nImageryLayer.prototype.getViewableRectangle = function () {\n  var imageryProvider = this._imageryProvider;\n  var rectangle = this._rectangle;\n  return imageryProvider.readyPromise.then(function () {\n    return Rectangle.intersection(imageryProvider.rectangle, rectangle);\n  });\n};\n\n/**\n * Create skeletons for the imagery tiles that partially or completely overlap a given terrain\n * tile.\n *\n * @private\n *\n * @param {Tile} tile The terrain tile.\n * @param {TerrainProvider} terrainProvider The terrain provider associated with the terrain tile.\n * @param {Number} insertionPoint The position to insert new skeletons before in the tile's imagery list.\n * @returns {Boolean} true if this layer overlaps any portion of the terrain tile; otherwise, false.\n */\nImageryLayer.prototype._createTileImagerySkeletons = function (\n  tile,\n  terrainProvider,\n  insertionPoint\n) {\n  var surfaceTile = tile.data;\n\n  if (\n    defined(this._minimumTerrainLevel) &&\n    tile.level < this._minimumTerrainLevel\n  ) {\n    return false;\n  }\n  if (\n    defined(this._maximumTerrainLevel) &&\n    tile.level > this._maximumTerrainLevel\n  ) {\n    return false;\n  }\n\n  var imageryProvider = this._imageryProvider;\n\n  if (!defined(insertionPoint)) {\n    insertionPoint = surfaceTile.imagery.length;\n  }\n\n  if (!imageryProvider.ready) {\n    // The imagery provider is not ready, so we can't create skeletons, yet.\n    // Instead, add a placeholder so that we'll know to create\n    // the skeletons once the provider is ready.\n    this._skeletonPlaceholder.loadingImagery.addReference();\n    surfaceTile.imagery.splice(insertionPoint, 0, this._skeletonPlaceholder);\n    return true;\n  }\n\n  // Use Web Mercator for our texture coordinate computations if this imagery layer uses\n  // that projection and the terrain tile falls entirely inside the valid bounds of the\n  // projection.\n  var useWebMercatorT =\n    imageryProvider.tilingScheme.projection instanceof WebMercatorProjection &&\n    tile.rectangle.north < WebMercatorProjection.MaximumLatitude &&\n    tile.rectangle.south > -WebMercatorProjection.MaximumLatitude;\n\n  // Compute the rectangle of the imagery from this imageryProvider that overlaps\n  // the geometry tile.  The ImageryProvider and ImageryLayer both have the\n  // opportunity to constrain the rectangle.  The imagery TilingScheme's rectangle\n  // always fully contains the ImageryProvider's rectangle.\n  var imageryBounds = Rectangle.intersection(\n    imageryProvider.rectangle,\n    this._rectangle,\n    imageryBoundsScratch\n  );\n  var rectangle = Rectangle.intersection(\n    tile.rectangle,\n    imageryBounds,\n    tileImageryBoundsScratch\n  );\n\n  if (!defined(rectangle)) {\n    // There is no overlap between this terrain tile and this imagery\n    // provider.  Unless this is the base layer, no skeletons need to be created.\n    // We stretch texels at the edge of the base layer over the entire globe.\n    if (!this.isBaseLayer()) {\n      return false;\n    }\n\n    var baseImageryRectangle = imageryBounds;\n    var baseTerrainRectangle = tile.rectangle;\n    rectangle = tileImageryBoundsScratch;\n\n    if (baseTerrainRectangle.south >= baseImageryRectangle.north) {\n      rectangle.north = rectangle.south = baseImageryRectangle.north;\n    } else if (baseTerrainRectangle.north <= baseImageryRectangle.south) {\n      rectangle.north = rectangle.south = baseImageryRectangle.south;\n    } else {\n      rectangle.south = Math.max(\n        baseTerrainRectangle.south,\n        baseImageryRectangle.south\n      );\n      rectangle.north = Math.min(\n        baseTerrainRectangle.north,\n        baseImageryRectangle.north\n      );\n    }\n\n    if (baseTerrainRectangle.west >= baseImageryRectangle.east) {\n      rectangle.west = rectangle.east = baseImageryRectangle.east;\n    } else if (baseTerrainRectangle.east <= baseImageryRectangle.west) {\n      rectangle.west = rectangle.east = baseImageryRectangle.west;\n    } else {\n      rectangle.west = Math.max(\n        baseTerrainRectangle.west,\n        baseImageryRectangle.west\n      );\n      rectangle.east = Math.min(\n        baseTerrainRectangle.east,\n        baseImageryRectangle.east\n      );\n    }\n  }\n\n  var latitudeClosestToEquator = 0.0;\n  if (rectangle.south > 0.0) {\n    latitudeClosestToEquator = rectangle.south;\n  } else if (rectangle.north < 0.0) {\n    latitudeClosestToEquator = rectangle.north;\n  }\n\n  // Compute the required level in the imagery tiling scheme.\n  // The errorRatio should really be imagerySSE / terrainSSE rather than this hard-coded value.\n  // But first we need configurable imagery SSE and we need the rendering to be able to handle more\n  // images attached to a terrain tile than there are available texture units.  So that's for the future.\n  var errorRatio = 1.0;\n  var targetGeometricError =\n    errorRatio * terrainProvider.getLevelMaximumGeometricError(tile.level);\n  var imageryLevel = getLevelWithMaximumTexelSpacing(\n    this,\n    targetGeometricError,\n    latitudeClosestToEquator\n  );\n  imageryLevel = Math.max(0, imageryLevel);\n  var maximumLevel = imageryProvider.maximumLevel;\n  if (imageryLevel > maximumLevel) {\n    imageryLevel = maximumLevel;\n  }\n\n  if (defined(imageryProvider.minimumLevel)) {\n    var minimumLevel = imageryProvider.minimumLevel;\n    if (imageryLevel < minimumLevel) {\n      imageryLevel = minimumLevel;\n    }\n  }\n\n  var imageryTilingScheme = imageryProvider.tilingScheme;\n  var northwestTileCoordinates = imageryTilingScheme.positionToTileXY(\n    Rectangle.northwest(rectangle),\n    imageryLevel\n  );\n  var southeastTileCoordinates = imageryTilingScheme.positionToTileXY(\n    Rectangle.southeast(rectangle),\n    imageryLevel\n  );\n\n  // If the southeast corner of the rectangle lies very close to the north or west side\n  // of the southeast tile, we don't actually need the southernmost or easternmost\n  // tiles.\n  // Similarly, if the northwest corner of the rectangle lies very close to the south or east side\n  // of the northwest tile, we don't actually need the northernmost or westernmost tiles.\n\n  // We define \"very close\" as being within 1/512 of the width of the tile.\n  var veryCloseX = tile.rectangle.width / 512.0;\n  var veryCloseY = tile.rectangle.height / 512.0;\n\n  var northwestTileRectangle = imageryTilingScheme.tileXYToRectangle(\n    northwestTileCoordinates.x,\n    northwestTileCoordinates.y,\n    imageryLevel\n  );\n  if (\n    Math.abs(northwestTileRectangle.south - tile.rectangle.north) <\n      veryCloseY &&\n    northwestTileCoordinates.y < southeastTileCoordinates.y\n  ) {\n    ++northwestTileCoordinates.y;\n  }\n  if (\n    Math.abs(northwestTileRectangle.east - tile.rectangle.west) < veryCloseX &&\n    northwestTileCoordinates.x < southeastTileCoordinates.x\n  ) {\n    ++northwestTileCoordinates.x;\n  }\n\n  var southeastTileRectangle = imageryTilingScheme.tileXYToRectangle(\n    southeastTileCoordinates.x,\n    southeastTileCoordinates.y,\n    imageryLevel\n  );\n  if (\n    Math.abs(southeastTileRectangle.north - tile.rectangle.south) <\n      veryCloseY &&\n    southeastTileCoordinates.y > northwestTileCoordinates.y\n  ) {\n    --southeastTileCoordinates.y;\n  }\n  if (\n    Math.abs(southeastTileRectangle.west - tile.rectangle.east) < veryCloseX &&\n    southeastTileCoordinates.x > northwestTileCoordinates.x\n  ) {\n    --southeastTileCoordinates.x;\n  }\n\n  // Create TileImagery instances for each imagery tile overlapping this terrain tile.\n  // We need to do all texture coordinate computations in the imagery tile's tiling scheme.\n\n  var terrainRectangle = Rectangle.clone(\n    tile.rectangle,\n    terrainRectangleScratch\n  );\n  var imageryRectangle = imageryTilingScheme.tileXYToRectangle(\n    northwestTileCoordinates.x,\n    northwestTileCoordinates.y,\n    imageryLevel\n  );\n  var clippedImageryRectangle = Rectangle.intersection(\n    imageryRectangle,\n    imageryBounds,\n    clippedRectangleScratch\n  );\n\n  var imageryTileXYToRectangle;\n  if (useWebMercatorT) {\n    imageryTilingScheme.rectangleToNativeRectangle(\n      terrainRectangle,\n      terrainRectangle\n    );\n    imageryTilingScheme.rectangleToNativeRectangle(\n      imageryRectangle,\n      imageryRectangle\n    );\n    imageryTilingScheme.rectangleToNativeRectangle(\n      clippedImageryRectangle,\n      clippedImageryRectangle\n    );\n    imageryTilingScheme.rectangleToNativeRectangle(\n      imageryBounds,\n      imageryBounds\n    );\n    imageryTileXYToRectangle = imageryTilingScheme.tileXYToNativeRectangle.bind(\n      imageryTilingScheme\n    );\n    veryCloseX = terrainRectangle.width / 512.0;\n    veryCloseY = terrainRectangle.height / 512.0;\n  } else {\n    imageryTileXYToRectangle = imageryTilingScheme.tileXYToRectangle.bind(\n      imageryTilingScheme\n    );\n  }\n\n  var minU;\n  var maxU = 0.0;\n\n  var minV = 1.0;\n  var maxV;\n\n  // If this is the northern-most or western-most tile in the imagery tiling scheme,\n  // it may not start at the northern or western edge of the terrain tile.\n  // Calculate where it does start.\n  if (\n    !this.isBaseLayer() &&\n    Math.abs(clippedImageryRectangle.west - terrainRectangle.west) >= veryCloseX\n  ) {\n    maxU = Math.min(\n      1.0,\n      (clippedImageryRectangle.west - terrainRectangle.west) /\n        terrainRectangle.width\n    );\n  }\n\n  if (\n    !this.isBaseLayer() &&\n    Math.abs(clippedImageryRectangle.north - terrainRectangle.north) >=\n      veryCloseY\n  ) {\n    minV = Math.max(\n      0.0,\n      (clippedImageryRectangle.north - terrainRectangle.south) /\n        terrainRectangle.height\n    );\n  }\n\n  var initialMinV = minV;\n\n  for (\n    var i = northwestTileCoordinates.x;\n    i <= southeastTileCoordinates.x;\n    i++\n  ) {\n    minU = maxU;\n\n    imageryRectangle = imageryTileXYToRectangle(\n      i,\n      northwestTileCoordinates.y,\n      imageryLevel\n    );\n    clippedImageryRectangle = Rectangle.simpleIntersection(\n      imageryRectangle,\n      imageryBounds,\n      clippedRectangleScratch\n    );\n\n    if (!defined(clippedImageryRectangle)) {\n      continue;\n    }\n\n    maxU = Math.min(\n      1.0,\n      (clippedImageryRectangle.east - terrainRectangle.west) /\n        terrainRectangle.width\n    );\n\n    // If this is the eastern-most imagery tile mapped to this terrain tile,\n    // and there are more imagery tiles to the east of this one, the maxU\n    // should be 1.0 to make sure rounding errors don't make the last\n    // image fall shy of the edge of the terrain tile.\n    if (\n      i === southeastTileCoordinates.x &&\n      (this.isBaseLayer() ||\n        Math.abs(clippedImageryRectangle.east - terrainRectangle.east) <\n          veryCloseX)\n    ) {\n      maxU = 1.0;\n    }\n\n    minV = initialMinV;\n\n    for (\n      var j = northwestTileCoordinates.y;\n      j <= southeastTileCoordinates.y;\n      j++\n    ) {\n      maxV = minV;\n\n      imageryRectangle = imageryTileXYToRectangle(i, j, imageryLevel);\n      clippedImageryRectangle = Rectangle.simpleIntersection(\n        imageryRectangle,\n        imageryBounds,\n        clippedRectangleScratch\n      );\n\n      if (!defined(clippedImageryRectangle)) {\n        continue;\n      }\n\n      minV = Math.max(\n        0.0,\n        (clippedImageryRectangle.south - terrainRectangle.south) /\n          terrainRectangle.height\n      );\n\n      // If this is the southern-most imagery tile mapped to this terrain tile,\n      // and there are more imagery tiles to the south of this one, the minV\n      // should be 0.0 to make sure rounding errors don't make the last\n      // image fall shy of the edge of the terrain tile.\n      if (\n        j === southeastTileCoordinates.y &&\n        (this.isBaseLayer() ||\n          Math.abs(clippedImageryRectangle.south - terrainRectangle.south) <\n            veryCloseY)\n      ) {\n        minV = 0.0;\n      }\n\n      var texCoordsRectangle = new Cartesian4(minU, minV, maxU, maxV);\n      var imagery = this.getImageryFromCache(i, j, imageryLevel);\n      surfaceTile.imagery.splice(\n        insertionPoint,\n        0,\n        new TileImagery(imagery, texCoordsRectangle, useWebMercatorT)\n      );\n      ++insertionPoint;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Calculate the translation and scale for a particular {@link TileImagery} attached to a\n * particular terrain tile.\n *\n * @private\n *\n * @param {Tile} tile The terrain tile.\n * @param {TileImagery} tileImagery The imagery tile mapping.\n * @returns {Cartesian4} The translation and scale where X and Y are the translation and Z and W\n *          are the scale.\n */\nImageryLayer.prototype._calculateTextureTranslationAndScale = function (\n  tile,\n  tileImagery\n) {\n  var imageryRectangle = tileImagery.readyImagery.rectangle;\n  var terrainRectangle = tile.rectangle;\n\n  if (tileImagery.useWebMercatorT) {\n    var tilingScheme =\n      tileImagery.readyImagery.imageryLayer.imageryProvider.tilingScheme;\n    imageryRectangle = tilingScheme.rectangleToNativeRectangle(\n      imageryRectangle,\n      imageryBoundsScratch\n    );\n    terrainRectangle = tilingScheme.rectangleToNativeRectangle(\n      terrainRectangle,\n      terrainRectangleScratch\n    );\n  }\n\n  var terrainWidth = terrainRectangle.width;\n  var terrainHeight = terrainRectangle.height;\n\n  var scaleX = terrainWidth / imageryRectangle.width;\n  var scaleY = terrainHeight / imageryRectangle.height;\n  return new Cartesian4(\n    (scaleX * (terrainRectangle.west - imageryRectangle.west)) / terrainWidth,\n    (scaleY * (terrainRectangle.south - imageryRectangle.south)) /\n      terrainHeight,\n    scaleX,\n    scaleY\n  );\n};\n\n/**\n * Request a particular piece of imagery from the imagery provider.  This method handles raising an\n * error event if the request fails, and retrying the request if necessary.\n *\n * @private\n *\n * @param {Imagery} imagery The imagery to request.\n */\nImageryLayer.prototype._requestImagery = function (imagery) {\n  var imageryProvider = this._imageryProvider;\n\n  var that = this;\n\n  function success(image) {\n    if (!defined(image)) {\n      return failure();\n    }\n\n    imagery.image = image;\n    imagery.state = ImageryState.RECEIVED;\n    imagery.request = undefined;\n\n    TileProviderError.handleSuccess(that._requestImageError);\n  }\n\n  function failure(e) {\n    if (imagery.request.state === RequestState.CANCELLED) {\n      // Cancelled due to low priority - try again later.\n      imagery.state = ImageryState.UNLOADED;\n      imagery.request = undefined;\n      return;\n    }\n\n    // Initially assume failure.  handleError may retry, in which case the state will\n    // change to TRANSITIONING.\n    imagery.state = ImageryState.FAILED;\n    imagery.request = undefined;\n\n    var message =\n      \"Failed to obtain image tile X: \" +\n      imagery.x +\n      \" Y: \" +\n      imagery.y +\n      \" Level: \" +\n      imagery.level +\n      \".\";\n    that._requestImageError = TileProviderError.handleError(\n      that._requestImageError,\n      imageryProvider,\n      imageryProvider.errorEvent,\n      message,\n      imagery.x,\n      imagery.y,\n      imagery.level,\n      doRequest,\n      e\n    );\n  }\n\n  function doRequest() {\n    var request = new Request({\n      throttle: false,\n      throttleByServer: true,\n      type: RequestType.IMAGERY,\n    });\n    imagery.request = request;\n    imagery.state = ImageryState.TRANSITIONING;\n    var imagePromise = imageryProvider.requestImage(\n      imagery.x,\n      imagery.y,\n      imagery.level,\n      request\n    );\n\n    if (!defined(imagePromise)) {\n      // Too many parallel requests, so postpone loading tile.\n      imagery.state = ImageryState.UNLOADED;\n      imagery.request = undefined;\n      return;\n    }\n\n    if (defined(imageryProvider.getTileCredits)) {\n      imagery.credits = imageryProvider.getTileCredits(\n        imagery.x,\n        imagery.y,\n        imagery.level\n      );\n    }\n\n    when(imagePromise, success, failure);\n  }\n\n  doRequest();\n};\n\nImageryLayer.prototype._createTextureWebGL = function (context, imagery) {\n  var sampler = new Sampler({\n    minificationFilter: this.minificationFilter,\n    magnificationFilter: this.magnificationFilter,\n  });\n\n  var image = imagery.image;\n\n  if (defined(image.internalFormat)) {\n    return new Texture({\n      context: context,\n      pixelFormat: image.internalFormat,\n      width: image.width,\n      height: image.height,\n      source: {\n        arrayBufferView: image.bufferView,\n      },\n      sampler: sampler,\n    });\n  }\n  return new Texture({\n    context: context,\n    source: image,\n    pixelFormat: this._imageryProvider.hasAlphaChannel\n      ? PixelFormat.RGBA\n      : PixelFormat.RGB,\n    sampler: sampler,\n  });\n};\n\n/**\n * Create a WebGL texture for a given {@link Imagery} instance.\n *\n * @private\n *\n * @param {Context} context The rendered context to use to create textures.\n * @param {Imagery} imagery The imagery for which to create a texture.\n */\nImageryLayer.prototype._createTexture = function (context, imagery) {\n  var imageryProvider = this._imageryProvider;\n  var image = imagery.image;\n\n  // If this imagery provider has a discard policy, use it to check if this\n  // image should be discarded.\n  if (defined(imageryProvider.tileDiscardPolicy)) {\n    var discardPolicy = imageryProvider.tileDiscardPolicy;\n    if (defined(discardPolicy)) {\n      // If the discard policy is not ready yet, transition back to the\n      // RECEIVED state and we'll try again next time.\n      if (!discardPolicy.isReady()) {\n        imagery.state = ImageryState.RECEIVED;\n        return;\n      }\n\n      // Mark discarded imagery tiles invalid.  Parent imagery will be used instead.\n      if (discardPolicy.shouldDiscardImage(image)) {\n        imagery.state = ImageryState.INVALID;\n        return;\n      }\n    }\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    this.minificationFilter !== TextureMinificationFilter.NEAREST &&\n    this.minificationFilter !== TextureMinificationFilter.LINEAR\n  ) {\n    throw new DeveloperError(\n      \"ImageryLayer minification filter must be NEAREST or LINEAR\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  // Imagery does not need to be discarded, so upload it to WebGL.\n  var texture = this._createTextureWebGL(context, imagery);\n\n  if (\n    imageryProvider.tilingScheme.projection instanceof WebMercatorProjection\n  ) {\n    imagery.textureWebMercator = texture;\n  } else {\n    imagery.texture = texture;\n  }\n  imagery.image = undefined;\n  imagery.state = ImageryState.TEXTURE_LOADED;\n};\n\nfunction getSamplerKey(\n  minificationFilter,\n  magnificationFilter,\n  maximumAnisotropy\n) {\n  return (\n    minificationFilter + \":\" + magnificationFilter + \":\" + maximumAnisotropy\n  );\n}\n\nImageryLayer.prototype._finalizeReprojectTexture = function (context, texture) {\n  var minificationFilter = this.minificationFilter;\n  var magnificationFilter = this.magnificationFilter;\n  var usesLinearTextureFilter =\n    minificationFilter === TextureMinificationFilter.LINEAR &&\n    magnificationFilter === TextureMagnificationFilter.LINEAR;\n  // Use mipmaps if this texture has power-of-two dimensions.\n  // In addition, mipmaps are only generated if the texture filters are both LINEAR.\n  if (\n    usesLinearTextureFilter &&\n    !PixelFormat.isCompressedFormat(texture.pixelFormat) &&\n    CesiumMath.isPowerOfTwo(texture.width) &&\n    CesiumMath.isPowerOfTwo(texture.height)\n  ) {\n    minificationFilter = TextureMinificationFilter.LINEAR_MIPMAP_LINEAR;\n    var maximumSupportedAnisotropy =\n      ContextLimits.maximumTextureFilterAnisotropy;\n    var maximumAnisotropy = Math.min(\n      maximumSupportedAnisotropy,\n      defaultValue(this._maximumAnisotropy, maximumSupportedAnisotropy)\n    );\n    var mipmapSamplerKey = getSamplerKey(\n      minificationFilter,\n      magnificationFilter,\n      maximumAnisotropy\n    );\n    var mipmapSamplers = context.cache.imageryLayerMipmapSamplers;\n    if (!defined(mipmapSamplers)) {\n      mipmapSamplers = {};\n      context.cache.imageryLayerMipmapSamplers = mipmapSamplers;\n    }\n    var mipmapSampler = mipmapSamplers[mipmapSamplerKey];\n    if (!defined(mipmapSampler)) {\n      mipmapSampler = mipmapSamplers[mipmapSamplerKey] = new Sampler({\n        wrapS: TextureWrap.CLAMP_TO_EDGE,\n        wrapT: TextureWrap.CLAMP_TO_EDGE,\n        minificationFilter: minificationFilter,\n        magnificationFilter: magnificationFilter,\n        maximumAnisotropy: maximumAnisotropy,\n      });\n    }\n    texture.generateMipmap(MipmapHint.NICEST);\n    texture.sampler = mipmapSampler;\n  } else {\n    var nonMipmapSamplerKey = getSamplerKey(\n      minificationFilter,\n      magnificationFilter,\n      0\n    );\n    var nonMipmapSamplers = context.cache.imageryLayerNonMipmapSamplers;\n    if (!defined(nonMipmapSamplers)) {\n      nonMipmapSamplers = {};\n      context.cache.imageryLayerNonMipmapSamplers = nonMipmapSamplers;\n    }\n    var nonMipmapSampler = nonMipmapSamplers[nonMipmapSamplerKey];\n    if (!defined(nonMipmapSampler)) {\n      nonMipmapSampler = nonMipmapSamplers[nonMipmapSamplerKey] = new Sampler({\n        wrapS: TextureWrap.CLAMP_TO_EDGE,\n        wrapT: TextureWrap.CLAMP_TO_EDGE,\n        minificationFilter: minificationFilter,\n        magnificationFilter: magnificationFilter,\n      });\n    }\n    texture.sampler = nonMipmapSampler;\n  }\n};\n\n/**\n * Enqueues a command re-projecting a texture to a {@link GeographicProjection} on the next update, if necessary, and generate\n * mipmaps for the geographic texture.\n *\n * @private\n *\n * @param {FrameState} frameState The frameState.\n * @param {Imagery} imagery The imagery instance to reproject.\n * @param {Boolean} [needGeographicProjection=true] True to reproject to geographic, or false if Web Mercator is fine.\n */\nImageryLayer.prototype._reprojectTexture = function (\n  frameState,\n  imagery,\n  needGeographicProjection\n) {\n  var texture = imagery.textureWebMercator || imagery.texture;\n  var rectangle = imagery.rectangle;\n  var context = frameState.context;\n\n  needGeographicProjection = defaultValue(needGeographicProjection, true);\n\n  // Reproject this texture if it is not already in a geographic projection and\n  // the pixels are more than 1e-5 radians apart.  The pixel spacing cutoff\n  // avoids precision problems in the reprojection transformation while making\n  // no noticeable difference in the georeferencing of the image.\n  if (\n    needGeographicProjection &&\n    !(\n      this._imageryProvider.tilingScheme.projection instanceof\n      GeographicProjection\n    ) &&\n    rectangle.width / texture.width > 1e-5\n  ) {\n    var that = this;\n    imagery.addReference();\n    var computeCommand = new ComputeCommand({\n      persists: true,\n      owner: this,\n      // Update render resources right before execution instead of now.\n      // This allows different ImageryLayers to share the same vao and buffers.\n      preExecute: function (command) {\n        reprojectToGeographic(command, context, texture, imagery.rectangle);\n      },\n      postExecute: function (outputTexture) {\n        imagery.texture = outputTexture;\n        that._finalizeReprojectTexture(context, outputTexture);\n        imagery.state = ImageryState.READY;\n        imagery.releaseReference();\n      },\n    });\n    this._reprojectComputeCommands.push(computeCommand);\n  } else {\n    if (needGeographicProjection) {\n      imagery.texture = texture;\n    }\n    this._finalizeReprojectTexture(context, texture);\n    imagery.state = ImageryState.READY;\n  }\n};\n\n/**\n * Updates frame state to execute any queued texture re-projections.\n *\n * @private\n *\n * @param {FrameState} frameState The frameState.\n */\nImageryLayer.prototype.queueReprojectionCommands = function (frameState) {\n  var computeCommands = this._reprojectComputeCommands;\n  var length = computeCommands.length;\n  for (var i = 0; i < length; ++i) {\n    frameState.commandList.push(computeCommands[i]);\n  }\n  computeCommands.length = 0;\n};\n\n/**\n * Cancels re-projection commands queued for the next frame.\n *\n * @private\n */\nImageryLayer.prototype.cancelReprojections = function () {\n  this._reprojectComputeCommands.length = 0;\n};\n\nImageryLayer.prototype.getImageryFromCache = function (\n  x,\n  y,\n  level,\n  imageryRectangle\n) {\n  var cacheKey = getImageryCacheKey(x, y, level);\n  var imagery = this._imageryCache[cacheKey];\n\n  if (!defined(imagery)) {\n    imagery = new Imagery(this, x, y, level, imageryRectangle);\n    this._imageryCache[cacheKey] = imagery;\n  }\n\n  imagery.addReference();\n  return imagery;\n};\n\nImageryLayer.prototype.removeImageryFromCache = function (imagery) {\n  var cacheKey = getImageryCacheKey(imagery.x, imagery.y, imagery.level);\n  delete this._imageryCache[cacheKey];\n};\n\nfunction getImageryCacheKey(x, y, level) {\n  return JSON.stringify([x, y, level]);\n}\n\nvar uniformMap = {\n  u_textureDimensions: function () {\n    return this.textureDimensions;\n  },\n  u_texture: function () {\n    return this.texture;\n  },\n\n  textureDimensions: new Cartesian2(),\n  texture: undefined,\n};\n\nvar float32ArrayScratch = FeatureDetection.supportsTypedArrays()\n  ? new Float32Array(2 * 64)\n  : undefined;\n\nfunction reprojectToGeographic(command, context, texture, rectangle) {\n  // This function has gone through a number of iterations, because GPUs are awesome.\n  //\n  // Originally, we had a very simple vertex shader and computed the Web Mercator texture coordinates\n  // per-fragment in the fragment shader.  That worked well, except on mobile devices, because\n  // fragment shaders have limited precision on many mobile devices.  The result was smearing artifacts\n  // at medium zoom levels because different geographic texture coordinates would be reprojected to Web\n  // Mercator as the same value.\n  //\n  // Our solution was to reproject to Web Mercator in the vertex shader instead of the fragment shader.\n  // This required far more vertex data.  With fragment shader reprojection, we only needed a single quad.\n  // But to achieve the same precision with vertex shader reprojection, we needed a vertex for each\n  // output pixel.  So we used a grid of 256x256 vertices, because most of our imagery\n  // tiles are 256x256.  Fortunately the grid could be created and uploaded to the GPU just once and\n  // re-used for all reprojections, so the performance was virtually unchanged from our original fragment\n  // shader approach.  See https://github.com/CesiumGS/cesium/pull/714.\n  //\n  // Over a year later, we noticed (https://github.com/CesiumGS/cesium/issues/2110)\n  // that our reprojection code was creating a rare but severe artifact on some GPUs (Intel HD 4600\n  // for one).  The problem was that the GLSL sin function on these GPUs had a discontinuity at fine scales in\n  // a few places.\n  //\n  // We solved this by implementing a more reliable sin function based on the CORDIC algorithm\n  // (https://github.com/CesiumGS/cesium/pull/2111).  Even though this was a fair\n  // amount of code to be executing per vertex, the performance seemed to be pretty good on most GPUs.\n  // Unfortunately, on some GPUs, the performance was absolutely terrible\n  // (https://github.com/CesiumGS/cesium/issues/2258).\n  //\n  // So that brings us to our current solution, the one you see here.  Effectively, we compute the Web\n  // Mercator texture coordinates on the CPU and store the T coordinate with each vertex (the S coordinate\n  // is the same in Geographic and Web Mercator).  To make this faster, we reduced our reprojection mesh\n  // to be only 2 vertices wide and 64 vertices high.  We should have reduced the width to 2 sooner,\n  // because the extra vertices weren't buying us anything.  The height of 64 means we are technically\n  // doing a slightly less accurate reprojection than we were before, but we can't see the difference\n  // so it's worth the 4x speedup.\n\n  var reproject = context.cache.imageryLayer_reproject;\n\n  if (!defined(reproject)) {\n    reproject = context.cache.imageryLayer_reproject = {\n      vertexArray: undefined,\n      shaderProgram: undefined,\n      sampler: undefined,\n      destroy: function () {\n        if (defined(this.framebuffer)) {\n          this.framebuffer.destroy();\n        }\n        if (defined(this.vertexArray)) {\n          this.vertexArray.destroy();\n        }\n        if (defined(this.shaderProgram)) {\n          this.shaderProgram.destroy();\n        }\n      },\n    };\n\n    var positions = new Float32Array(2 * 64 * 2);\n    var index = 0;\n    for (var j = 0; j < 64; ++j) {\n      var y = j / 63.0;\n      positions[index++] = 0.0;\n      positions[index++] = y;\n      positions[index++] = 1.0;\n      positions[index++] = y;\n    }\n\n    var reprojectAttributeIndices = {\n      position: 0,\n      webMercatorT: 1,\n    };\n\n    var indices = TerrainProvider.getRegularGridIndices(2, 64);\n    var indexBuffer = Buffer.createIndexBuffer({\n      context: context,\n      typedArray: indices,\n      usage: BufferUsage.STATIC_DRAW,\n      indexDatatype: IndexDatatype.UNSIGNED_SHORT,\n    });\n\n    reproject.vertexArray = new VertexArray({\n      context: context,\n      attributes: [\n        {\n          index: reprojectAttributeIndices.position,\n          vertexBuffer: Buffer.createVertexBuffer({\n            context: context,\n            typedArray: positions,\n            usage: BufferUsage.STATIC_DRAW,\n          }),\n          componentsPerAttribute: 2,\n        },\n        {\n          index: reprojectAttributeIndices.webMercatorT,\n          vertexBuffer: Buffer.createVertexBuffer({\n            context: context,\n            sizeInBytes: 64 * 2 * 4,\n            usage: BufferUsage.STREAM_DRAW,\n          }),\n          componentsPerAttribute: 1,\n        },\n      ],\n      indexBuffer: indexBuffer,\n    });\n\n    var vs = new ShaderSource({\n      sources: [ReprojectWebMercatorVS],\n    });\n\n    reproject.shaderProgram = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: ReprojectWebMercatorFS,\n      attributeLocations: reprojectAttributeIndices,\n    });\n\n    reproject.sampler = new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: TextureMinificationFilter.LINEAR,\n      magnificationFilter: TextureMagnificationFilter.LINEAR,\n    });\n  }\n\n  texture.sampler = reproject.sampler;\n\n  var width = texture.width;\n  var height = texture.height;\n\n  uniformMap.textureDimensions.x = width;\n  uniformMap.textureDimensions.y = height;\n  uniformMap.texture = texture;\n\n  var sinLatitude = Math.sin(rectangle.south);\n  var southMercatorY = 0.5 * Math.log((1 + sinLatitude) / (1 - sinLatitude));\n\n  sinLatitude = Math.sin(rectangle.north);\n  var northMercatorY = 0.5 * Math.log((1 + sinLatitude) / (1 - sinLatitude));\n  var oneOverMercatorHeight = 1.0 / (northMercatorY - southMercatorY);\n\n  var outputTexture = new Texture({\n    context: context,\n    width: width,\n    height: height,\n    pixelFormat: texture.pixelFormat,\n    pixelDatatype: texture.pixelDatatype,\n    preMultiplyAlpha: texture.preMultiplyAlpha,\n  });\n\n  // Allocate memory for the mipmaps.  Failure to do this before rendering\n  // to the texture via the FBO, and calling generateMipmap later,\n  // will result in the texture appearing blank.  I can't pretend to\n  // understand exactly why this is.\n  if (CesiumMath.isPowerOfTwo(width) && CesiumMath.isPowerOfTwo(height)) {\n    outputTexture.generateMipmap(MipmapHint.NICEST);\n  }\n\n  var south = rectangle.south;\n  var north = rectangle.north;\n\n  var webMercatorT = float32ArrayScratch;\n\n  var outputIndex = 0;\n  for (var webMercatorTIndex = 0; webMercatorTIndex < 64; ++webMercatorTIndex) {\n    var fraction = webMercatorTIndex / 63.0;\n    var latitude = CesiumMath.lerp(south, north, fraction);\n    sinLatitude = Math.sin(latitude);\n    var mercatorY = 0.5 * Math.log((1.0 + sinLatitude) / (1.0 - sinLatitude));\n    var mercatorFraction = (mercatorY - southMercatorY) * oneOverMercatorHeight;\n    webMercatorT[outputIndex++] = mercatorFraction;\n    webMercatorT[outputIndex++] = mercatorFraction;\n  }\n\n  reproject.vertexArray\n    .getAttribute(1)\n    .vertexBuffer.copyFromArrayView(webMercatorT);\n\n  command.shaderProgram = reproject.shaderProgram;\n  command.outputTexture = outputTexture;\n  command.uniformMap = uniformMap;\n  command.vertexArray = reproject.vertexArray;\n}\n\n/**\n * Gets the level with the specified world coordinate spacing between texels, or less.\n *\n * @param {ImageryLayer} layer The imagery layer to use.\n * @param {Number} texelSpacing The texel spacing for which to find a corresponding level.\n * @param {Number} latitudeClosestToEquator The latitude closest to the equator that we're concerned with.\n * @returns {Number} The level with the specified texel spacing or less.\n * @private\n */\nfunction getLevelWithMaximumTexelSpacing(\n  layer,\n  texelSpacing,\n  latitudeClosestToEquator\n) {\n  // PERFORMANCE_IDEA: factor out the stuff that doesn't change.\n  var imageryProvider = layer._imageryProvider;\n  var tilingScheme = imageryProvider.tilingScheme;\n  var ellipsoid = tilingScheme.ellipsoid;\n  var latitudeFactor = !(\n    layer._imageryProvider.tilingScheme.projection instanceof\n    GeographicProjection\n  )\n    ? Math.cos(latitudeClosestToEquator)\n    : 1.0;\n  var tilingSchemeRectangle = tilingScheme.rectangle;\n  var levelZeroMaximumTexelSpacing =\n    (ellipsoid.maximumRadius * tilingSchemeRectangle.width * latitudeFactor) /\n    (imageryProvider.tileWidth * tilingScheme.getNumberOfXTilesAtLevel(0));\n\n  var twoToTheLevelPower = levelZeroMaximumTexelSpacing / texelSpacing;\n  var level = Math.log(twoToTheLevelPower) / Math.log(2);\n  var rounded = Math.round(level);\n  return rounded | 0;\n}\nexport default ImageryLayer;\n"]},"metadata":{},"sourceType":"module"}