{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport jsep from \"../ThirdParty/jsep.js\";\nimport ExpressionNodeType from \"./ExpressionNodeType.js\";\n/**\n * An expression for a style applied to a {@link Cesium3DTileset}.\n * <p>\n * Evaluates an expression defined using the\n * {@link https://github.com/CesiumGS/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language}.\n * </p>\n * <p>\n * Implements the {@link StyleExpression} interface.\n * </p>\n *\n * @alias Expression\n * @constructor\n *\n * @param {String} [expression] The expression defined using the 3D Tiles Styling language.\n * @param {Object} [defines] Defines in the style.\n *\n * @example\n * var expression = new Cesium.Expression('(regExp(\"^Chest\").test(${County})) && (${YearBuilt} >= 1970)');\n * expression.evaluate(feature); // returns true or false depending on the feature's properties\n *\n * @example\n * var expression = new Cesium.Expression('(${Temperature} > 90) ? color(\"red\") : color(\"white\")');\n * expression.evaluateColor(feature, result); // returns a Cesium.Color object\n */\n\nfunction Expression(expression, defines) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"expression\", expression); //>>includeEnd('debug');\n\n  this._expression = expression;\n  expression = replaceDefines(expression, defines);\n  expression = replaceVariables(removeBackslashes(expression)); // customize jsep operators\n\n  jsep.addBinaryOp(\"=~\", 0);\n  jsep.addBinaryOp(\"!~\", 0);\n  var ast;\n\n  try {\n    ast = jsep(expression);\n  } catch (e) {\n    throw new RuntimeError(e);\n  }\n\n  this._runtimeAst = createRuntimeAst(this, ast);\n}\n\nObject.defineProperties(Expression.prototype, {\n  /**\n   * Gets the expression defined in the 3D Tiles Styling language.\n   *\n   * @memberof Expression.prototype\n   *\n   * @type {String}\n   * @readonly\n   *\n   * @default undefined\n   */\n  expression: {\n    get: function () {\n      return this._expression;\n    }\n  }\n}); // Scratch storage manager while evaluating deep expressions.\n// For example, an expression like dot(vec4(${red}), vec4(${green}) * vec4(${blue}) requires 3 scratch Cartesian4's\n\nvar scratchStorage = {\n  arrayIndex: 0,\n  arrayArray: [[]],\n  cartesian2Index: 0,\n  cartesian3Index: 0,\n  cartesian4Index: 0,\n  cartesian2Array: [new Cartesian2()],\n  cartesian3Array: [new Cartesian3()],\n  cartesian4Array: [new Cartesian4()],\n  reset: function () {\n    this.arrayIndex = 0;\n    this.cartesian2Index = 0;\n    this.cartesian3Index = 0;\n    this.cartesian4Index = 0;\n  },\n  getArray: function () {\n    if (this.arrayIndex >= this.arrayArray.length) {\n      this.arrayArray.push([]);\n    }\n\n    var array = this.arrayArray[this.arrayIndex++];\n    array.length = 0;\n    return array;\n  },\n  getCartesian2: function () {\n    if (this.cartesian2Index >= this.cartesian2Array.length) {\n      this.cartesian2Array.push(new Cartesian2());\n    }\n\n    return this.cartesian2Array[this.cartesian2Index++];\n  },\n  getCartesian3: function () {\n    if (this.cartesian3Index >= this.cartesian3Array.length) {\n      this.cartesian3Array.push(new Cartesian3());\n    }\n\n    return this.cartesian3Array[this.cartesian3Index++];\n  },\n  getCartesian4: function () {\n    if (this.cartesian4Index >= this.cartesian4Array.length) {\n      this.cartesian4Array.push(new Cartesian4());\n    }\n\n    return this.cartesian4Array[this.cartesian4Index++];\n  }\n};\n/**\n * Evaluates the result of an expression, optionally using the provided feature's properties. If the result of\n * the expression in the\n * {@link https://github.com/CesiumGS/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language}\n * is of type <code>Boolean</code>, <code>Number</code>, or <code>String</code>, the corresponding JavaScript\n * primitive type will be returned. If the result is a <code>RegExp</code>, a Javascript <code>RegExp</code>\n * object will be returned. If the result is a <code>Cartesian2</code>, <code>Cartesian3</code>, or <code>Cartesian4</code>,\n * a {@link Cartesian2}, {@link Cartesian3}, or {@link Cartesian4} object will be returned. If the <code>result</code> argument is\n * a {@link Color}, the {@link Cartesian4} value is converted to a {@link Color} and then returned.\n *\n * @param {Cesium3DTileFeature} feature The feature whose properties may be used as variables in the expression.\n * @param {Object} [result] The object onto which to store the result.\n * @returns {Boolean|Number|String|RegExp|Cartesian2|Cartesian3|Cartesian4|Color} The result of evaluating the expression.\n */\n\nExpression.prototype.evaluate = function (feature, result) {\n  scratchStorage.reset();\n\n  var value = this._runtimeAst.evaluate(feature);\n\n  if (result instanceof Color && value instanceof Cartesian4) {\n    return Color.fromCartesian4(value, result);\n  }\n\n  if (value instanceof Cartesian2 || value instanceof Cartesian3 || value instanceof Cartesian4) {\n    return value.clone(result);\n  }\n\n  return value;\n};\n/**\n * Evaluates the result of a Color expression, optionally using the provided feature's properties.\n * <p>\n * This is equivalent to {@link Expression#evaluate} but always returns a {@link Color} object.\n * </p>\n *\n * @param {Cesium3DTileFeature} feature The feature whose properties may be used as variables in the expression.\n * @param {Color} [result] The object in which to store the result\n * @returns {Color} The modified result parameter or a new Color instance if one was not provided.\n */\n\n\nExpression.prototype.evaluateColor = function (feature, result) {\n  scratchStorage.reset();\n\n  var color = this._runtimeAst.evaluate(feature);\n\n  return Color.fromCartesian4(color, result);\n};\n/**\n * Gets the shader function for this expression.\n * Returns undefined if the shader function can't be generated from this expression.\n *\n * @param {String} functionName Name to give to the generated function.\n * @param {String} attributePrefix Prefix that is added to any variable names to access vertex attributes.\n * @param {Object} shaderState Stores information about the generated shader function, including whether it is translucent.\n * @param {String} returnType The return type of the generated function.\n *\n * @returns {String} The shader function.\n *\n * @private\n */\n\n\nExpression.prototype.getShaderFunction = function (functionName, attributePrefix, shaderState, returnType) {\n  var shaderExpression = this.getShaderExpression(attributePrefix, shaderState);\n  shaderExpression = returnType + \" \" + functionName + \"() \\n\" + \"{ \\n\" + \"    return \" + shaderExpression + \"; \\n\" + \"} \\n\";\n  return shaderExpression;\n};\n/**\n * Gets the shader expression for this expression.\n * Returns undefined if the shader expression can't be generated from this expression.\n *\n * @param {String} attributePrefix Prefix that is added to any variable names to access vertex attributes.\n * @param {Object} shaderState Stores information about the generated shader function, including whether it is translucent.\n *\n * @returns {String} The shader expression.\n *\n * @private\n */\n\n\nExpression.prototype.getShaderExpression = function (attributePrefix, shaderState) {\n  return this._runtimeAst.getShaderExpression(attributePrefix, shaderState);\n};\n\nvar unaryOperators = [\"!\", \"-\", \"+\"];\nvar binaryOperators = [\"+\", \"-\", \"*\", \"/\", \"%\", \"===\", \"!==\", \">\", \">=\", \"<\", \"<=\", \"&&\", \"||\", \"!~\", \"=~\"];\nvar variableRegex = /\\${(.*?)}/g; // Matches ${variable_name}\n\nvar backslashRegex = /\\\\/g;\nvar backslashReplacement = \"@#%\";\nvar replacementRegex = /@#%/g;\nvar scratchColor = new Color();\nvar unaryFunctions = {\n  abs: getEvaluateUnaryComponentwise(Math.abs),\n  sqrt: getEvaluateUnaryComponentwise(Math.sqrt),\n  cos: getEvaluateUnaryComponentwise(Math.cos),\n  sin: getEvaluateUnaryComponentwise(Math.sin),\n  tan: getEvaluateUnaryComponentwise(Math.tan),\n  acos: getEvaluateUnaryComponentwise(Math.acos),\n  asin: getEvaluateUnaryComponentwise(Math.asin),\n  atan: getEvaluateUnaryComponentwise(Math.atan),\n  radians: getEvaluateUnaryComponentwise(CesiumMath.toRadians),\n  degrees: getEvaluateUnaryComponentwise(CesiumMath.toDegrees),\n  sign: getEvaluateUnaryComponentwise(CesiumMath.sign),\n  floor: getEvaluateUnaryComponentwise(Math.floor),\n  ceil: getEvaluateUnaryComponentwise(Math.ceil),\n  round: getEvaluateUnaryComponentwise(Math.round),\n  exp: getEvaluateUnaryComponentwise(Math.exp),\n  exp2: getEvaluateUnaryComponentwise(exp2),\n  log: getEvaluateUnaryComponentwise(Math.log),\n  log2: getEvaluateUnaryComponentwise(log2),\n  fract: getEvaluateUnaryComponentwise(fract),\n  length: length,\n  normalize: normalize\n};\nvar binaryFunctions = {\n  atan2: getEvaluateBinaryComponentwise(Math.atan2, false),\n  pow: getEvaluateBinaryComponentwise(Math.pow, false),\n  min: getEvaluateBinaryComponentwise(Math.min, true),\n  max: getEvaluateBinaryComponentwise(Math.max, true),\n  distance: distance,\n  dot: dot,\n  cross: cross\n};\nvar ternaryFunctions = {\n  clamp: getEvaluateTernaryComponentwise(CesiumMath.clamp, true),\n  mix: getEvaluateTernaryComponentwise(CesiumMath.lerp, true)\n};\n\nfunction fract(number) {\n  return number - Math.floor(number);\n}\n\nfunction exp2(exponent) {\n  return Math.pow(2.0, exponent);\n}\n\nfunction log2(number) {\n  return CesiumMath.log2(number);\n}\n\nfunction getEvaluateUnaryComponentwise(operation) {\n  return function (call, left) {\n    if (typeof left === \"number\") {\n      return operation(left);\n    } else if (left instanceof Cartesian2) {\n      return Cartesian2.fromElements(operation(left.x), operation(left.y), scratchStorage.getCartesian2());\n    } else if (left instanceof Cartesian3) {\n      return Cartesian3.fromElements(operation(left.x), operation(left.y), operation(left.z), scratchStorage.getCartesian3());\n    } else if (left instanceof Cartesian4) {\n      return Cartesian4.fromElements(operation(left.x), operation(left.y), operation(left.z), operation(left.w), scratchStorage.getCartesian4());\n    }\n\n    throw new RuntimeError('Function \"' + call + '\" requires a vector or number argument. Argument is ' + left + \".\");\n  };\n}\n\nfunction getEvaluateBinaryComponentwise(operation, allowScalar) {\n  return function (call, left, right) {\n    if (allowScalar && typeof right === \"number\") {\n      if (typeof left === \"number\") {\n        return operation(left, right);\n      } else if (left instanceof Cartesian2) {\n        return Cartesian2.fromElements(operation(left.x, right), operation(left.y, right), scratchStorage.getCartesian2());\n      } else if (left instanceof Cartesian3) {\n        return Cartesian3.fromElements(operation(left.x, right), operation(left.y, right), operation(left.z, right), scratchStorage.getCartesian3());\n      } else if (left instanceof Cartesian4) {\n        return Cartesian4.fromElements(operation(left.x, right), operation(left.y, right), operation(left.z, right), operation(left.w, right), scratchStorage.getCartesian4());\n      }\n    }\n\n    if (typeof left === \"number\" && typeof right === \"number\") {\n      return operation(left, right);\n    } else if (left instanceof Cartesian2 && right instanceof Cartesian2) {\n      return Cartesian2.fromElements(operation(left.x, right.x), operation(left.y, right.y), scratchStorage.getCartesian2());\n    } else if (left instanceof Cartesian3 && right instanceof Cartesian3) {\n      return Cartesian3.fromElements(operation(left.x, right.x), operation(left.y, right.y), operation(left.z, right.z), scratchStorage.getCartesian3());\n    } else if (left instanceof Cartesian4 && right instanceof Cartesian4) {\n      return Cartesian4.fromElements(operation(left.x, right.x), operation(left.y, right.y), operation(left.z, right.z), operation(left.w, right.w), scratchStorage.getCartesian4());\n    }\n\n    throw new RuntimeError('Function \"' + call + '\" requires vector or number arguments of matching types. Arguments are ' + left + \" and \" + right + \".\");\n  };\n}\n\nfunction getEvaluateTernaryComponentwise(operation, allowScalar) {\n  return function (call, left, right, test) {\n    if (allowScalar && typeof test === \"number\") {\n      if (typeof left === \"number\" && typeof right === \"number\") {\n        return operation(left, right, test);\n      } else if (left instanceof Cartesian2 && right instanceof Cartesian2) {\n        return Cartesian2.fromElements(operation(left.x, right.x, test), operation(left.y, right.y, test), scratchStorage.getCartesian2());\n      } else if (left instanceof Cartesian3 && right instanceof Cartesian3) {\n        return Cartesian3.fromElements(operation(left.x, right.x, test), operation(left.y, right.y, test), operation(left.z, right.z, test), scratchStorage.getCartesian3());\n      } else if (left instanceof Cartesian4 && right instanceof Cartesian4) {\n        return Cartesian4.fromElements(operation(left.x, right.x, test), operation(left.y, right.y, test), operation(left.z, right.z, test), operation(left.w, right.w, test), scratchStorage.getCartesian4());\n      }\n    }\n\n    if (typeof left === \"number\" && typeof right === \"number\" && typeof test === \"number\") {\n      return operation(left, right, test);\n    } else if (left instanceof Cartesian2 && right instanceof Cartesian2 && test instanceof Cartesian2) {\n      return Cartesian2.fromElements(operation(left.x, right.x, test.x), operation(left.y, right.y, test.y), scratchStorage.getCartesian2());\n    } else if (left instanceof Cartesian3 && right instanceof Cartesian3 && test instanceof Cartesian3) {\n      return Cartesian3.fromElements(operation(left.x, right.x, test.x), operation(left.y, right.y, test.y), operation(left.z, right.z, test.z), scratchStorage.getCartesian3());\n    } else if (left instanceof Cartesian4 && right instanceof Cartesian4 && test instanceof Cartesian4) {\n      return Cartesian4.fromElements(operation(left.x, right.x, test.x), operation(left.y, right.y, test.y), operation(left.z, right.z, test.z), operation(left.w, right.w, test.w), scratchStorage.getCartesian4());\n    }\n\n    throw new RuntimeError('Function \"' + call + '\" requires vector or number arguments of matching types. Arguments are ' + left + \", \" + right + \", and \" + test + \".\");\n  };\n}\n\nfunction length(call, left) {\n  if (typeof left === \"number\") {\n    return Math.abs(left);\n  } else if (left instanceof Cartesian2) {\n    return Cartesian2.magnitude(left);\n  } else if (left instanceof Cartesian3) {\n    return Cartesian3.magnitude(left);\n  } else if (left instanceof Cartesian4) {\n    return Cartesian4.magnitude(left);\n  }\n\n  throw new RuntimeError('Function \"' + call + '\" requires a vector or number argument. Argument is ' + left + \".\");\n}\n\nfunction normalize(call, left) {\n  if (typeof left === \"number\") {\n    return 1.0;\n  } else if (left instanceof Cartesian2) {\n    return Cartesian2.normalize(left, scratchStorage.getCartesian2());\n  } else if (left instanceof Cartesian3) {\n    return Cartesian3.normalize(left, scratchStorage.getCartesian3());\n  } else if (left instanceof Cartesian4) {\n    return Cartesian4.normalize(left, scratchStorage.getCartesian4());\n  }\n\n  throw new RuntimeError('Function \"' + call + '\" requires a vector or number argument. Argument is ' + left + \".\");\n}\n\nfunction distance(call, left, right) {\n  if (typeof left === \"number\" && typeof right === \"number\") {\n    return Math.abs(left - right);\n  } else if (left instanceof Cartesian2 && right instanceof Cartesian2) {\n    return Cartesian2.distance(left, right);\n  } else if (left instanceof Cartesian3 && right instanceof Cartesian3) {\n    return Cartesian3.distance(left, right);\n  } else if (left instanceof Cartesian4 && right instanceof Cartesian4) {\n    return Cartesian4.distance(left, right);\n  }\n\n  throw new RuntimeError('Function \"' + call + '\" requires vector or number arguments of matching types. Arguments are ' + left + \" and \" + right + \".\");\n}\n\nfunction dot(call, left, right) {\n  if (typeof left === \"number\" && typeof right === \"number\") {\n    return left * right;\n  } else if (left instanceof Cartesian2 && right instanceof Cartesian2) {\n    return Cartesian2.dot(left, right);\n  } else if (left instanceof Cartesian3 && right instanceof Cartesian3) {\n    return Cartesian3.dot(left, right);\n  } else if (left instanceof Cartesian4 && right instanceof Cartesian4) {\n    return Cartesian4.dot(left, right);\n  }\n\n  throw new RuntimeError('Function \"' + call + '\" requires vector or number arguments of matching types. Arguments are ' + left + \" and \" + right + \".\");\n}\n\nfunction cross(call, left, right) {\n  if (left instanceof Cartesian3 && right instanceof Cartesian3) {\n    return Cartesian3.cross(left, right, scratchStorage.getCartesian3());\n  }\n\n  throw new RuntimeError('Function \"' + call + '\" requires vec3 arguments. Arguments are ' + left + \" and \" + right + \".\");\n}\n\nfunction Node(type, value, left, right, test) {\n  this._type = type;\n  this._value = value;\n  this._left = left;\n  this._right = right;\n  this._test = test;\n  this.evaluate = undefined;\n  setEvaluateFunction(this);\n}\n\nfunction replaceDefines(expression, defines) {\n  if (!defined(defines)) {\n    return expression;\n  }\n\n  for (var key in defines) {\n    if (defines.hasOwnProperty(key)) {\n      var definePlaceholder = new RegExp(\"\\\\$\\\\{\" + key + \"\\\\}\", \"g\");\n      var defineReplace = \"(\" + defines[key] + \")\";\n\n      if (defined(defineReplace)) {\n        expression = expression.replace(definePlaceholder, defineReplace);\n      }\n    }\n  }\n\n  return expression;\n}\n\nfunction removeBackslashes(expression) {\n  return expression.replace(backslashRegex, backslashReplacement);\n}\n\nfunction replaceBackslashes(expression) {\n  return expression.replace(replacementRegex, \"\\\\\");\n}\n\nfunction replaceVariables(expression) {\n  var exp = expression;\n  var result = \"\";\n  var i = exp.indexOf(\"${\");\n\n  while (i >= 0) {\n    // Check if string is inside quotes\n    var openSingleQuote = exp.indexOf(\"'\");\n    var openDoubleQuote = exp.indexOf('\"');\n    var closeQuote;\n\n    if (openSingleQuote >= 0 && openSingleQuote < i) {\n      closeQuote = exp.indexOf(\"'\", openSingleQuote + 1);\n      result += exp.substr(0, closeQuote + 1);\n      exp = exp.substr(closeQuote + 1);\n      i = exp.indexOf(\"${\");\n    } else if (openDoubleQuote >= 0 && openDoubleQuote < i) {\n      closeQuote = exp.indexOf('\"', openDoubleQuote + 1);\n      result += exp.substr(0, closeQuote + 1);\n      exp = exp.substr(closeQuote + 1);\n      i = exp.indexOf(\"${\");\n    } else {\n      result += exp.substr(0, i);\n      var j = exp.indexOf(\"}\");\n\n      if (j < 0) {\n        throw new RuntimeError(\"Unmatched {.\");\n      }\n\n      result += \"czm_\" + exp.substr(i + 2, j - (i + 2));\n      exp = exp.substr(j + 1);\n      i = exp.indexOf(\"${\");\n    }\n  }\n\n  result += exp;\n  return result;\n}\n\nfunction parseLiteral(ast) {\n  var type = typeof ast.value;\n\n  if (ast.value === null) {\n    return new Node(ExpressionNodeType.LITERAL_NULL, null);\n  } else if (type === \"boolean\") {\n    return new Node(ExpressionNodeType.LITERAL_BOOLEAN, ast.value);\n  } else if (type === \"number\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, ast.value);\n  } else if (type === \"string\") {\n    if (ast.value.indexOf(\"${\") >= 0) {\n      return new Node(ExpressionNodeType.VARIABLE_IN_STRING, ast.value);\n    }\n\n    return new Node(ExpressionNodeType.LITERAL_STRING, replaceBackslashes(ast.value));\n  }\n}\n\nfunction parseCall(expression, ast) {\n  var args = ast.arguments;\n  var argsLength = args.length;\n  var call;\n  var val, left, right; // Member function calls\n\n  if (ast.callee.type === \"MemberExpression\") {\n    call = ast.callee.property.name;\n    var object = ast.callee.object;\n\n    if (call === \"test\" || call === \"exec\") {\n      // Make sure this is called on a valid type\n      if (object.callee.name !== \"regExp\") {\n        throw new RuntimeError(call + \" is not a function.\");\n      }\n\n      if (argsLength === 0) {\n        if (call === \"test\") {\n          return new Node(ExpressionNodeType.LITERAL_BOOLEAN, false);\n        }\n\n        return new Node(ExpressionNodeType.LITERAL_NULL, null);\n      }\n\n      left = createRuntimeAst(expression, object);\n      right = createRuntimeAst(expression, args[0]);\n      return new Node(ExpressionNodeType.FUNCTION_CALL, call, left, right);\n    } else if (call === \"toString\") {\n      val = createRuntimeAst(expression, object);\n      return new Node(ExpressionNodeType.FUNCTION_CALL, call, val);\n    }\n\n    throw new RuntimeError('Unexpected function call \"' + call + '\".');\n  } // Non-member function calls\n\n\n  call = ast.callee.name;\n\n  if (call === \"color\") {\n    if (argsLength === 0) {\n      return new Node(ExpressionNodeType.LITERAL_COLOR, call);\n    }\n\n    val = createRuntimeAst(expression, args[0]);\n\n    if (defined(args[1])) {\n      var alpha = createRuntimeAst(expression, args[1]);\n      return new Node(ExpressionNodeType.LITERAL_COLOR, call, [val, alpha]);\n    }\n\n    return new Node(ExpressionNodeType.LITERAL_COLOR, call, [val]);\n  } else if (call === \"rgb\" || call === \"hsl\") {\n    if (argsLength < 3) {\n      throw new RuntimeError(call + \" requires three arguments.\");\n    }\n\n    val = [createRuntimeAst(expression, args[0]), createRuntimeAst(expression, args[1]), createRuntimeAst(expression, args[2])];\n    return new Node(ExpressionNodeType.LITERAL_COLOR, call, val);\n  } else if (call === \"rgba\" || call === \"hsla\") {\n    if (argsLength < 4) {\n      throw new RuntimeError(call + \" requires four arguments.\");\n    }\n\n    val = [createRuntimeAst(expression, args[0]), createRuntimeAst(expression, args[1]), createRuntimeAst(expression, args[2]), createRuntimeAst(expression, args[3])];\n    return new Node(ExpressionNodeType.LITERAL_COLOR, call, val);\n  } else if (call === \"vec2\" || call === \"vec3\" || call === \"vec4\") {\n    // Check for invalid constructors at evaluation time\n    val = new Array(argsLength);\n\n    for (var i = 0; i < argsLength; ++i) {\n      val[i] = createRuntimeAst(expression, args[i]);\n    }\n\n    return new Node(ExpressionNodeType.LITERAL_VECTOR, call, val);\n  } else if (call === \"isNaN\" || call === \"isFinite\") {\n    if (argsLength === 0) {\n      if (call === \"isNaN\") {\n        return new Node(ExpressionNodeType.LITERAL_BOOLEAN, true);\n      }\n\n      return new Node(ExpressionNodeType.LITERAL_BOOLEAN, false);\n    }\n\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (call === \"isExactClass\" || call === \"isClass\") {\n    if (argsLength < 1 || argsLength > 1) {\n      throw new RuntimeError(call + \" requires exactly one argument.\");\n    }\n\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (call === \"getExactClassName\") {\n    if (argsLength > 0) {\n      throw new RuntimeError(call + \" does not take any argument.\");\n    }\n\n    return new Node(ExpressionNodeType.UNARY, call);\n  } else if (defined(unaryFunctions[call])) {\n    if (argsLength !== 1) {\n      throw new RuntimeError(call + \" requires exactly one argument.\");\n    }\n\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (defined(binaryFunctions[call])) {\n    if (argsLength !== 2) {\n      throw new RuntimeError(call + \" requires exactly two arguments.\");\n    }\n\n    left = createRuntimeAst(expression, args[0]);\n    right = createRuntimeAst(expression, args[1]);\n    return new Node(ExpressionNodeType.BINARY, call, left, right);\n  } else if (defined(ternaryFunctions[call])) {\n    if (argsLength !== 3) {\n      throw new RuntimeError(call + \" requires exactly three arguments.\");\n    }\n\n    left = createRuntimeAst(expression, args[0]);\n    right = createRuntimeAst(expression, args[1]);\n    var test = createRuntimeAst(expression, args[2]);\n    return new Node(ExpressionNodeType.TERNARY, call, left, right, test);\n  } else if (call === \"Boolean\") {\n    if (argsLength === 0) {\n      return new Node(ExpressionNodeType.LITERAL_BOOLEAN, false);\n    }\n\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (call === \"Number\") {\n    if (argsLength === 0) {\n      return new Node(ExpressionNodeType.LITERAL_NUMBER, 0);\n    }\n\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (call === \"String\") {\n    if (argsLength === 0) {\n      return new Node(ExpressionNodeType.LITERAL_STRING, \"\");\n    }\n\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (call === \"regExp\") {\n    return parseRegex(expression, ast);\n  }\n\n  throw new RuntimeError('Unexpected function call \"' + call + '\".');\n}\n\nfunction parseRegex(expression, ast) {\n  var args = ast.arguments; // no arguments, return default regex\n\n  if (args.length === 0) {\n    return new Node(ExpressionNodeType.LITERAL_REGEX, new RegExp());\n  }\n\n  var pattern = createRuntimeAst(expression, args[0]);\n  var exp; // optional flag argument supplied\n\n  if (args.length > 1) {\n    var flags = createRuntimeAst(expression, args[1]);\n\n    if (isLiteralType(pattern) && isLiteralType(flags)) {\n      try {\n        exp = new RegExp(replaceBackslashes(String(pattern._value)), flags._value);\n      } catch (e) {\n        throw new RuntimeError(e);\n      }\n\n      return new Node(ExpressionNodeType.LITERAL_REGEX, exp);\n    }\n\n    return new Node(ExpressionNodeType.REGEX, pattern, flags);\n  } // only pattern argument supplied\n\n\n  if (isLiteralType(pattern)) {\n    try {\n      exp = new RegExp(replaceBackslashes(String(pattern._value)));\n    } catch (e) {\n      throw new RuntimeError(e);\n    }\n\n    return new Node(ExpressionNodeType.LITERAL_REGEX, exp);\n  }\n\n  return new Node(ExpressionNodeType.REGEX, pattern);\n}\n\nfunction parseKeywordsAndVariables(ast) {\n  if (isVariable(ast.name)) {\n    var name = getPropertyName(ast.name);\n\n    if (name.substr(0, 8) === \"tiles3d_\") {\n      return new Node(ExpressionNodeType.BUILTIN_VARIABLE, name);\n    }\n\n    return new Node(ExpressionNodeType.VARIABLE, name);\n  } else if (ast.name === \"NaN\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, NaN);\n  } else if (ast.name === \"Infinity\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, Infinity);\n  } else if (ast.name === \"undefined\") {\n    return new Node(ExpressionNodeType.LITERAL_UNDEFINED, undefined);\n  }\n\n  throw new RuntimeError(ast.name + \" is not defined.\");\n}\n\nfunction parseMathConstant(ast) {\n  var name = ast.property.name;\n\n  if (name === \"PI\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, Math.PI);\n  } else if (name === \"E\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, Math.E);\n  }\n}\n\nfunction parseNumberConstant(ast) {\n  var name = ast.property.name;\n\n  if (name === \"POSITIVE_INFINITY\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, Number.POSITIVE_INFINITY);\n  }\n}\n\nfunction parseMemberExpression(expression, ast) {\n  if (ast.object.name === \"Math\") {\n    return parseMathConstant(ast);\n  } else if (ast.object.name === \"Number\") {\n    return parseNumberConstant(ast);\n  }\n\n  var val;\n  var obj = createRuntimeAst(expression, ast.object);\n\n  if (ast.computed) {\n    val = createRuntimeAst(expression, ast.property);\n    return new Node(ExpressionNodeType.MEMBER, \"brackets\", obj, val);\n  }\n\n  val = new Node(ExpressionNodeType.LITERAL_STRING, ast.property.name);\n  return new Node(ExpressionNodeType.MEMBER, \"dot\", obj, val);\n}\n\nfunction isLiteralType(node) {\n  return node._type >= ExpressionNodeType.LITERAL_NULL;\n}\n\nfunction isVariable(name) {\n  return name.substr(0, 4) === \"czm_\";\n}\n\nfunction getPropertyName(variable) {\n  return variable.substr(4);\n}\n\nfunction createRuntimeAst(expression, ast) {\n  var node;\n  var op;\n  var left;\n  var right;\n\n  if (ast.type === \"Literal\") {\n    node = parseLiteral(ast);\n  } else if (ast.type === \"CallExpression\") {\n    node = parseCall(expression, ast);\n  } else if (ast.type === \"Identifier\") {\n    node = parseKeywordsAndVariables(ast);\n  } else if (ast.type === \"UnaryExpression\") {\n    op = ast.operator;\n    var child = createRuntimeAst(expression, ast.argument);\n\n    if (unaryOperators.indexOf(op) > -1) {\n      node = new Node(ExpressionNodeType.UNARY, op, child);\n    } else {\n      throw new RuntimeError('Unexpected operator \"' + op + '\".');\n    }\n  } else if (ast.type === \"BinaryExpression\") {\n    op = ast.operator;\n    left = createRuntimeAst(expression, ast.left);\n    right = createRuntimeAst(expression, ast.right);\n\n    if (binaryOperators.indexOf(op) > -1) {\n      node = new Node(ExpressionNodeType.BINARY, op, left, right);\n    } else {\n      throw new RuntimeError('Unexpected operator \"' + op + '\".');\n    }\n  } else if (ast.type === \"LogicalExpression\") {\n    op = ast.operator;\n    left = createRuntimeAst(expression, ast.left);\n    right = createRuntimeAst(expression, ast.right);\n\n    if (binaryOperators.indexOf(op) > -1) {\n      node = new Node(ExpressionNodeType.BINARY, op, left, right);\n    }\n  } else if (ast.type === \"ConditionalExpression\") {\n    var test = createRuntimeAst(expression, ast.test);\n    left = createRuntimeAst(expression, ast.consequent);\n    right = createRuntimeAst(expression, ast.alternate);\n    node = new Node(ExpressionNodeType.CONDITIONAL, \"?\", left, right, test);\n  } else if (ast.type === \"MemberExpression\") {\n    node = parseMemberExpression(expression, ast);\n  } else if (ast.type === \"ArrayExpression\") {\n    var val = [];\n\n    for (var i = 0; i < ast.elements.length; i++) {\n      val[i] = createRuntimeAst(expression, ast.elements[i]);\n    }\n\n    node = new Node(ExpressionNodeType.ARRAY, val);\n  } else if (ast.type === \"Compound\") {\n    // empty expression or multiple expressions\n    throw new RuntimeError(\"Provide exactly one expression.\");\n  } else {\n    throw new RuntimeError(\"Cannot parse expression.\");\n  }\n\n  return node;\n}\n\nfunction setEvaluateFunction(node) {\n  if (node._type === ExpressionNodeType.CONDITIONAL) {\n    node.evaluate = node._evaluateConditional;\n  } else if (node._type === ExpressionNodeType.FUNCTION_CALL) {\n    if (node._value === \"test\") {\n      node.evaluate = node._evaluateRegExpTest;\n    } else if (node._value === \"exec\") {\n      node.evaluate = node._evaluateRegExpExec;\n    } else if (node._value === \"toString\") {\n      node.evaluate = node._evaluateToString;\n    }\n  } else if (node._type === ExpressionNodeType.UNARY) {\n    if (node._value === \"!\") {\n      node.evaluate = node._evaluateNot;\n    } else if (node._value === \"-\") {\n      node.evaluate = node._evaluateNegative;\n    } else if (node._value === \"+\") {\n      node.evaluate = node._evaluatePositive;\n    } else if (node._value === \"isNaN\") {\n      node.evaluate = node._evaluateNaN;\n    } else if (node._value === \"isFinite\") {\n      node.evaluate = node._evaluateIsFinite;\n    } else if (node._value === \"isExactClass\") {\n      node.evaluate = node._evaluateIsExactClass;\n    } else if (node._value === \"isClass\") {\n      node.evaluate = node._evaluateIsClass;\n    } else if (node._value === \"getExactClassName\") {\n      node.evaluate = node._evaluateGetExactClassName;\n    } else if (node._value === \"Boolean\") {\n      node.evaluate = node._evaluateBooleanConversion;\n    } else if (node._value === \"Number\") {\n      node.evaluate = node._evaluateNumberConversion;\n    } else if (node._value === \"String\") {\n      node.evaluate = node._evaluateStringConversion;\n    } else if (defined(unaryFunctions[node._value])) {\n      node.evaluate = getEvaluateUnaryFunction(node._value);\n    }\n  } else if (node._type === ExpressionNodeType.BINARY) {\n    if (node._value === \"+\") {\n      node.evaluate = node._evaluatePlus;\n    } else if (node._value === \"-\") {\n      node.evaluate = node._evaluateMinus;\n    } else if (node._value === \"*\") {\n      node.evaluate = node._evaluateTimes;\n    } else if (node._value === \"/\") {\n      node.evaluate = node._evaluateDivide;\n    } else if (node._value === \"%\") {\n      node.evaluate = node._evaluateMod;\n    } else if (node._value === \"===\") {\n      node.evaluate = node._evaluateEqualsStrict;\n    } else if (node._value === \"!==\") {\n      node.evaluate = node._evaluateNotEqualsStrict;\n    } else if (node._value === \"<\") {\n      node.evaluate = node._evaluateLessThan;\n    } else if (node._value === \"<=\") {\n      node.evaluate = node._evaluateLessThanOrEquals;\n    } else if (node._value === \">\") {\n      node.evaluate = node._evaluateGreaterThan;\n    } else if (node._value === \">=\") {\n      node.evaluate = node._evaluateGreaterThanOrEquals;\n    } else if (node._value === \"&&\") {\n      node.evaluate = node._evaluateAnd;\n    } else if (node._value === \"||\") {\n      node.evaluate = node._evaluateOr;\n    } else if (node._value === \"=~\") {\n      node.evaluate = node._evaluateRegExpMatch;\n    } else if (node._value === \"!~\") {\n      node.evaluate = node._evaluateRegExpNotMatch;\n    } else if (defined(binaryFunctions[node._value])) {\n      node.evaluate = getEvaluateBinaryFunction(node._value);\n    }\n  } else if (node._type === ExpressionNodeType.TERNARY) {\n    node.evaluate = getEvaluateTernaryFunction(node._value);\n  } else if (node._type === ExpressionNodeType.MEMBER) {\n    if (node._value === \"brackets\") {\n      node.evaluate = node._evaluateMemberBrackets;\n    } else {\n      node.evaluate = node._evaluateMemberDot;\n    }\n  } else if (node._type === ExpressionNodeType.ARRAY) {\n    node.evaluate = node._evaluateArray;\n  } else if (node._type === ExpressionNodeType.VARIABLE) {\n    node.evaluate = node._evaluateVariable;\n  } else if (node._type === ExpressionNodeType.VARIABLE_IN_STRING) {\n    node.evaluate = node._evaluateVariableString;\n  } else if (node._type === ExpressionNodeType.LITERAL_COLOR) {\n    node.evaluate = node._evaluateLiteralColor;\n  } else if (node._type === ExpressionNodeType.LITERAL_VECTOR) {\n    node.evaluate = node._evaluateLiteralVector;\n  } else if (node._type === ExpressionNodeType.LITERAL_STRING) {\n    node.evaluate = node._evaluateLiteralString;\n  } else if (node._type === ExpressionNodeType.REGEX) {\n    node.evaluate = node._evaluateRegExp;\n  } else if (node._type === ExpressionNodeType.BUILTIN_VARIABLE) {\n    if (node._value === \"tiles3d_tileset_time\") {\n      node.evaluate = evaluateTilesetTime;\n    }\n  } else {\n    node.evaluate = node._evaluateLiteral;\n  }\n}\n\nfunction evaluateTilesetTime(feature) {\n  if (!defined(feature)) {\n    return 0.0;\n  }\n\n  return feature.content.tileset.timeSinceLoad;\n}\n\nfunction getEvaluateUnaryFunction(call) {\n  var evaluate = unaryFunctions[call];\n  return function (feature) {\n    var left = this._left.evaluate(feature);\n\n    return evaluate(call, left);\n  };\n}\n\nfunction getEvaluateBinaryFunction(call) {\n  var evaluate = binaryFunctions[call];\n  return function (feature) {\n    var left = this._left.evaluate(feature);\n\n    var right = this._right.evaluate(feature);\n\n    return evaluate(call, left, right);\n  };\n}\n\nfunction getEvaluateTernaryFunction(call) {\n  var evaluate = ternaryFunctions[call];\n  return function (feature) {\n    var left = this._left.evaluate(feature);\n\n    var right = this._right.evaluate(feature);\n\n    var test = this._test.evaluate(feature);\n\n    return evaluate(call, left, right, test);\n  };\n}\n\nfunction getFeatureProperty(feature, name) {\n  // Returns undefined if the feature is not defined or the property name is not defined for that feature\n  if (defined(feature)) {\n    return feature.getProperty(name);\n  }\n}\n\nNode.prototype._evaluateLiteral = function () {\n  return this._value;\n};\n\nNode.prototype._evaluateLiteralColor = function (feature) {\n  var color = scratchColor;\n  var args = this._left;\n\n  if (this._value === \"color\") {\n    if (!defined(args)) {\n      Color.fromBytes(255, 255, 255, 255, color);\n    } else if (args.length > 1) {\n      Color.fromCssColorString(args[0].evaluate(feature), color);\n      color.alpha = args[1].evaluate(feature);\n    } else {\n      Color.fromCssColorString(args[0].evaluate(feature), color);\n    }\n  } else if (this._value === \"rgb\") {\n    Color.fromBytes(args[0].evaluate(feature), args[1].evaluate(feature), args[2].evaluate(feature), 255, color);\n  } else if (this._value === \"rgba\") {\n    // convert between css alpha (0 to 1) and cesium alpha (0 to 255)\n    var a = args[3].evaluate(feature) * 255;\n    Color.fromBytes(args[0].evaluate(feature), args[1].evaluate(feature), args[2].evaluate(feature), a, color);\n  } else if (this._value === \"hsl\") {\n    Color.fromHsl(args[0].evaluate(feature), args[1].evaluate(feature), args[2].evaluate(feature), 1.0, color);\n  } else if (this._value === \"hsla\") {\n    Color.fromHsl(args[0].evaluate(feature), args[1].evaluate(feature), args[2].evaluate(feature), args[3].evaluate(feature), color);\n  }\n\n  return Cartesian4.fromColor(color, scratchStorage.getCartesian4());\n};\n\nNode.prototype._evaluateLiteralVector = function (feature) {\n  // Gather the components that make up the vector, which includes components from interior vectors.\n  // For example vec3(1, 2, 3) or vec3(vec2(1, 2), 3) are both valid.\n  //\n  // If the number of components does not equal the vector's size, then a RuntimeError is thrown - with two exceptions:\n  // 1. A vector may be constructed from a larger vector and drop the extra components.\n  // 2. A vector may be constructed from a single component - vec3(1) will become vec3(1, 1, 1).\n  //\n  // Examples of invalid constructors include:\n  // vec4(1, 2)        // not enough components\n  // vec3(vec2(1, 2))  // not enough components\n  // vec3(1, 2, 3, 4)  // too many components\n  // vec2(vec4(1), 1)  // too many components\n  var components = scratchStorage.getArray();\n  var call = this._value;\n  var args = this._left;\n  var argsLength = args.length;\n\n  for (var i = 0; i < argsLength; ++i) {\n    var value = args[i].evaluate(feature);\n\n    if (typeof value === \"number\") {\n      components.push(value);\n    } else if (value instanceof Cartesian2) {\n      components.push(value.x, value.y);\n    } else if (value instanceof Cartesian3) {\n      components.push(value.x, value.y, value.z);\n    } else if (value instanceof Cartesian4) {\n      components.push(value.x, value.y, value.z, value.w);\n    } else {\n      throw new RuntimeError(call + \" argument must be a vector or number. Argument is \" + value + \".\");\n    }\n  }\n\n  var componentsLength = components.length;\n  var vectorLength = parseInt(call.charAt(3));\n\n  if (componentsLength === 0) {\n    throw new RuntimeError(\"Invalid \" + call + \" constructor. No valid arguments.\");\n  } else if (componentsLength < vectorLength && componentsLength > 1) {\n    throw new RuntimeError(\"Invalid \" + call + \" constructor. Not enough arguments.\");\n  } else if (componentsLength > vectorLength && argsLength > 1) {\n    throw new RuntimeError(\"Invalid \" + call + \" constructor. Too many arguments.\");\n  }\n\n  if (componentsLength === 1) {\n    // Add the same component 3 more times\n    var component = components[0];\n    components.push(component, component, component);\n  }\n\n  if (call === \"vec2\") {\n    return Cartesian2.fromArray(components, 0, scratchStorage.getCartesian2());\n  } else if (call === \"vec3\") {\n    return Cartesian3.fromArray(components, 0, scratchStorage.getCartesian3());\n  } else if (call === \"vec4\") {\n    return Cartesian4.fromArray(components, 0, scratchStorage.getCartesian4());\n  }\n};\n\nNode.prototype._evaluateLiteralString = function () {\n  return this._value;\n};\n\nNode.prototype._evaluateVariableString = function (feature) {\n  var result = this._value;\n  var match = variableRegex.exec(result);\n\n  while (match !== null) {\n    var placeholder = match[0];\n    var variableName = match[1];\n    var property = getFeatureProperty(feature, variableName);\n\n    if (!defined(property)) {\n      property = \"\";\n    }\n\n    result = result.replace(placeholder, property);\n    match = variableRegex.exec(result);\n  }\n\n  return result;\n};\n\nNode.prototype._evaluateVariable = function (feature) {\n  // evaluates to undefined if the property name is not defined for that feature\n  return getFeatureProperty(feature, this._value);\n};\n\nfunction checkFeature(ast) {\n  return ast._value === \"feature\";\n} // PERFORMANCE_IDEA: Determine if parent property needs to be computed before runtime\n\n\nNode.prototype._evaluateMemberDot = function (feature) {\n  if (checkFeature(this._left)) {\n    return getFeatureProperty(feature, this._right.evaluate(feature));\n  }\n\n  var property = this._left.evaluate(feature);\n\n  if (!defined(property)) {\n    return undefined;\n  }\n\n  var member = this._right.evaluate(feature);\n\n  if (property instanceof Cartesian2 || property instanceof Cartesian3 || property instanceof Cartesian4) {\n    // Vector components may be accessed with .r, .g, .b, .a and implicitly with .x, .y, .z, .w\n    if (member === \"r\") {\n      return property.x;\n    } else if (member === \"g\") {\n      return property.y;\n    } else if (member === \"b\") {\n      return property.z;\n    } else if (member === \"a\") {\n      return property.w;\n    }\n  }\n\n  return property[member];\n};\n\nNode.prototype._evaluateMemberBrackets = function (feature) {\n  if (checkFeature(this._left)) {\n    return getFeatureProperty(feature, this._right.evaluate(feature));\n  }\n\n  var property = this._left.evaluate(feature);\n\n  if (!defined(property)) {\n    return undefined;\n  }\n\n  var member = this._right.evaluate(feature);\n\n  if (property instanceof Cartesian2 || property instanceof Cartesian3 || property instanceof Cartesian4) {\n    // Vector components may be accessed with [0][1][2][3], ['r']['g']['b']['a'] and implicitly with ['x']['y']['z']['w']\n    // For Cartesian2 and Cartesian3 out-of-range components will just return undefined\n    if (member === 0 || member === \"r\") {\n      return property.x;\n    } else if (member === 1 || member === \"g\") {\n      return property.y;\n    } else if (member === 2 || member === \"b\") {\n      return property.z;\n    } else if (member === 3 || member === \"a\") {\n      return property.w;\n    }\n  }\n\n  return property[member];\n};\n\nNode.prototype._evaluateArray = function (feature) {\n  var array = [];\n\n  for (var i = 0; i < this._value.length; i++) {\n    array[i] = this._value[i].evaluate(feature);\n  }\n\n  return array;\n}; // PERFORMANCE_IDEA: Have \"fast path\" functions that deal only with specific types\n// that we can assign if we know the types before runtime\n\n\nNode.prototype._evaluateNot = function (feature) {\n  var left = this._left.evaluate(feature);\n\n  if (typeof left !== \"boolean\") {\n    throw new RuntimeError('Operator \"!\" requires a boolean argument. Argument is ' + left + \".\");\n  }\n\n  return !left;\n};\n\nNode.prototype._evaluateNegative = function (feature) {\n  var left = this._left.evaluate(feature);\n\n  if (left instanceof Cartesian2) {\n    return Cartesian2.negate(left, scratchStorage.getCartesian2());\n  } else if (left instanceof Cartesian3) {\n    return Cartesian3.negate(left, scratchStorage.getCartesian3());\n  } else if (left instanceof Cartesian4) {\n    return Cartesian4.negate(left, scratchStorage.getCartesian4());\n  } else if (typeof left === \"number\") {\n    return -left;\n  }\n\n  throw new RuntimeError('Operator \"-\" requires a vector or number argument. Argument is ' + left + \".\");\n};\n\nNode.prototype._evaluatePositive = function (feature) {\n  var left = this._left.evaluate(feature);\n\n  if (!(left instanceof Cartesian2 || left instanceof Cartesian3 || left instanceof Cartesian4 || typeof left === \"number\")) {\n    throw new RuntimeError('Operator \"+\" requires a vector or number argument. Argument is ' + left + \".\");\n  }\n\n  return left;\n};\n\nNode.prototype._evaluateLessThan = function (feature) {\n  var left = this._left.evaluate(feature);\n\n  var right = this._right.evaluate(feature);\n\n  if (typeof left !== \"number\" || typeof right !== \"number\") {\n    throw new RuntimeError('Operator \"<\" requires number arguments. Arguments are ' + left + \" and \" + right + \".\");\n  }\n\n  return left < right;\n};\n\nNode.prototype._evaluateLessThanOrEquals = function (feature) {\n  var left = this._left.evaluate(feature);\n\n  var right = this._right.evaluate(feature);\n\n  if (typeof left !== \"number\" || typeof right !== \"number\") {\n    throw new RuntimeError('Operator \"<=\" requires number arguments. Arguments are ' + left + \" and \" + right + \".\");\n  }\n\n  return left <= right;\n};\n\nNode.prototype._evaluateGreaterThan = function (feature) {\n  var left = this._left.evaluate(feature);\n\n  var right = this._right.evaluate(feature);\n\n  if (typeof left !== \"number\" || typeof right !== \"number\") {\n    throw new RuntimeError('Operator \">\" requires number arguments. Arguments are ' + left + \" and \" + right + \".\");\n  }\n\n  return left > right;\n};\n\nNode.prototype._evaluateGreaterThanOrEquals = function (feature) {\n  var left = this._left.evaluate(feature);\n\n  var right = this._right.evaluate(feature);\n\n  if (typeof left !== \"number\" || typeof right !== \"number\") {\n    throw new RuntimeError('Operator \">=\" requires number arguments. Arguments are ' + left + \" and \" + right + \".\");\n  }\n\n  return left >= right;\n};\n\nNode.prototype._evaluateOr = function (feature) {\n  var left = this._left.evaluate(feature);\n\n  if (typeof left !== \"boolean\") {\n    throw new RuntimeError('Operator \"||\" requires boolean arguments. First argument is ' + left + \".\");\n  } // short circuit the expression\n\n\n  if (left) {\n    return true;\n  }\n\n  var right = this._right.evaluate(feature);\n\n  if (typeof right !== \"boolean\") {\n    throw new RuntimeError('Operator \"||\" requires boolean arguments. Second argument is ' + right + \".\");\n  }\n\n  return left || right;\n};\n\nNode.prototype._evaluateAnd = function (feature) {\n  var left = this._left.evaluate(feature);\n\n  if (typeof left !== \"boolean\") {\n    throw new RuntimeError('Operator \"&&\" requires boolean arguments. First argument is ' + left + \".\");\n  } // short circuit the expression\n\n\n  if (!left) {\n    return false;\n  }\n\n  var right = this._right.evaluate(feature);\n\n  if (typeof right !== \"boolean\") {\n    throw new RuntimeError('Operator \"&&\" requires boolean arguments. Second argument is ' + right + \".\");\n  }\n\n  return left && right;\n};\n\nNode.prototype._evaluatePlus = function (feature) {\n  var left = this._left.evaluate(feature);\n\n  var right = this._right.evaluate(feature);\n\n  if (right instanceof Cartesian2 && left instanceof Cartesian2) {\n    return Cartesian2.add(left, right, scratchStorage.getCartesian2());\n  } else if (right instanceof Cartesian3 && left instanceof Cartesian3) {\n    return Cartesian3.add(left, right, scratchStorage.getCartesian3());\n  } else if (right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return Cartesian4.add(left, right, scratchStorage.getCartesian4());\n  } else if (typeof left === \"string\" || typeof right === \"string\") {\n    // If only one argument is a string the other argument calls its toString function.\n    return left + right;\n  } else if (typeof left === \"number\" && typeof right === \"number\") {\n    return left + right;\n  }\n\n  throw new RuntimeError('Operator \"+\" requires vector or number arguments of matching types, or at least one string argument. Arguments are ' + left + \" and \" + right + \".\");\n};\n\nNode.prototype._evaluateMinus = function (feature) {\n  var left = this._left.evaluate(feature);\n\n  var right = this._right.evaluate(feature);\n\n  if (right instanceof Cartesian2 && left instanceof Cartesian2) {\n    return Cartesian2.subtract(left, right, scratchStorage.getCartesian2());\n  } else if (right instanceof Cartesian3 && left instanceof Cartesian3) {\n    return Cartesian3.subtract(left, right, scratchStorage.getCartesian3());\n  } else if (right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return Cartesian4.subtract(left, right, scratchStorage.getCartesian4());\n  } else if (typeof left === \"number\" && typeof right === \"number\") {\n    return left - right;\n  }\n\n  throw new RuntimeError('Operator \"-\" requires vector or number arguments of matching types. Arguments are ' + left + \" and \" + right + \".\");\n};\n\nNode.prototype._evaluateTimes = function (feature) {\n  var left = this._left.evaluate(feature);\n\n  var right = this._right.evaluate(feature);\n\n  if (right instanceof Cartesian2 && left instanceof Cartesian2) {\n    return Cartesian2.multiplyComponents(left, right, scratchStorage.getCartesian2());\n  } else if (right instanceof Cartesian2 && typeof left === \"number\") {\n    return Cartesian2.multiplyByScalar(right, left, scratchStorage.getCartesian2());\n  } else if (left instanceof Cartesian2 && typeof right === \"number\") {\n    return Cartesian2.multiplyByScalar(left, right, scratchStorage.getCartesian2());\n  } else if (right instanceof Cartesian3 && left instanceof Cartesian3) {\n    return Cartesian3.multiplyComponents(left, right, scratchStorage.getCartesian3());\n  } else if (right instanceof Cartesian3 && typeof left === \"number\") {\n    return Cartesian3.multiplyByScalar(right, left, scratchStorage.getCartesian3());\n  } else if (left instanceof Cartesian3 && typeof right === \"number\") {\n    return Cartesian3.multiplyByScalar(left, right, scratchStorage.getCartesian3());\n  } else if (right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return Cartesian4.multiplyComponents(left, right, scratchStorage.getCartesian4());\n  } else if (right instanceof Cartesian4 && typeof left === \"number\") {\n    return Cartesian4.multiplyByScalar(right, left, scratchStorage.getCartesian4());\n  } else if (left instanceof Cartesian4 && typeof right === \"number\") {\n    return Cartesian4.multiplyByScalar(left, right, scratchStorage.getCartesian4());\n  } else if (typeof left === \"number\" && typeof right === \"number\") {\n    return left * right;\n  }\n\n  throw new RuntimeError('Operator \"*\" requires vector or number arguments. If both arguments are vectors they must be matching types. Arguments are ' + left + \" and \" + right + \".\");\n};\n\nNode.prototype._evaluateDivide = function (feature) {\n  var left = this._left.evaluate(feature);\n\n  var right = this._right.evaluate(feature);\n\n  if (right instanceof Cartesian2 && left instanceof Cartesian2) {\n    return Cartesian2.divideComponents(left, right, scratchStorage.getCartesian2());\n  } else if (left instanceof Cartesian2 && typeof right === \"number\") {\n    return Cartesian2.divideByScalar(left, right, scratchStorage.getCartesian2());\n  } else if (right instanceof Cartesian3 && left instanceof Cartesian3) {\n    return Cartesian3.divideComponents(left, right, scratchStorage.getCartesian3());\n  } else if (left instanceof Cartesian3 && typeof right === \"number\") {\n    return Cartesian3.divideByScalar(left, right, scratchStorage.getCartesian3());\n  } else if (right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return Cartesian4.divideComponents(left, right, scratchStorage.getCartesian4());\n  } else if (left instanceof Cartesian4 && typeof right === \"number\") {\n    return Cartesian4.divideByScalar(left, right, scratchStorage.getCartesian4());\n  } else if (typeof left === \"number\" && typeof right === \"number\") {\n    return left / right;\n  }\n\n  throw new RuntimeError('Operator \"/\" requires vector or number arguments of matching types, or a number as the second argument. Arguments are ' + left + \" and \" + right + \".\");\n};\n\nNode.prototype._evaluateMod = function (feature) {\n  var left = this._left.evaluate(feature);\n\n  var right = this._right.evaluate(feature);\n\n  if (right instanceof Cartesian2 && left instanceof Cartesian2) {\n    return Cartesian2.fromElements(left.x % right.x, left.y % right.y, scratchStorage.getCartesian2());\n  } else if (right instanceof Cartesian3 && left instanceof Cartesian3) {\n    return Cartesian3.fromElements(left.x % right.x, left.y % right.y, left.z % right.z, scratchStorage.getCartesian3());\n  } else if (right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return Cartesian4.fromElements(left.x % right.x, left.y % right.y, left.z % right.z, left.w % right.w, scratchStorage.getCartesian4());\n  } else if (typeof left === \"number\" && typeof right === \"number\") {\n    return left % right;\n  }\n\n  throw new RuntimeError('Operator \"%\" requires vector or number arguments of matching types. Arguments are ' + left + \" and \" + right + \".\");\n};\n\nNode.prototype._evaluateEqualsStrict = function (feature) {\n  var left = this._left.evaluate(feature);\n\n  var right = this._right.evaluate(feature);\n\n  if (right instanceof Cartesian2 && left instanceof Cartesian2 || right instanceof Cartesian3 && left instanceof Cartesian3 || right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return left.equals(right);\n  }\n\n  return left === right;\n};\n\nNode.prototype._evaluateNotEqualsStrict = function (feature) {\n  var left = this._left.evaluate(feature);\n\n  var right = this._right.evaluate(feature);\n\n  if (right instanceof Cartesian2 && left instanceof Cartesian2 || right instanceof Cartesian3 && left instanceof Cartesian3 || right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return !left.equals(right);\n  }\n\n  return left !== right;\n};\n\nNode.prototype._evaluateConditional = function (feature) {\n  var test = this._test.evaluate(feature);\n\n  if (typeof test !== \"boolean\") {\n    throw new RuntimeError(\"Conditional argument of conditional expression must be a boolean. Argument is \" + test + \".\");\n  }\n\n  if (test) {\n    return this._left.evaluate(feature);\n  }\n\n  return this._right.evaluate(feature);\n};\n\nNode.prototype._evaluateNaN = function (feature) {\n  return isNaN(this._left.evaluate(feature));\n};\n\nNode.prototype._evaluateIsFinite = function (feature) {\n  return isFinite(this._left.evaluate(feature));\n};\n\nNode.prototype._evaluateIsExactClass = function (feature) {\n  if (defined(feature)) {\n    return feature.isExactClass(this._left.evaluate(feature));\n  }\n\n  return false;\n};\n\nNode.prototype._evaluateIsClass = function (feature) {\n  if (defined(feature)) {\n    return feature.isClass(this._left.evaluate(feature));\n  }\n\n  return false;\n};\n\nNode.prototype._evaluateGetExactClassName = function (feature) {\n  if (defined(feature)) {\n    return feature.getExactClassName();\n  }\n};\n\nNode.prototype._evaluateBooleanConversion = function (feature) {\n  return Boolean(this._left.evaluate(feature));\n};\n\nNode.prototype._evaluateNumberConversion = function (feature) {\n  return Number(this._left.evaluate(feature));\n};\n\nNode.prototype._evaluateStringConversion = function (feature) {\n  return String(this._left.evaluate(feature));\n};\n\nNode.prototype._evaluateRegExp = function (feature) {\n  var pattern = this._value.evaluate(feature);\n\n  var flags = \"\";\n\n  if (defined(this._left)) {\n    flags = this._left.evaluate(feature);\n  }\n\n  var exp;\n\n  try {\n    exp = new RegExp(pattern, flags);\n  } catch (e) {\n    throw new RuntimeError(e);\n  }\n\n  return exp;\n};\n\nNode.prototype._evaluateRegExpTest = function (feature) {\n  var left = this._left.evaluate(feature);\n\n  var right = this._right.evaluate(feature);\n\n  if (!(left instanceof RegExp && typeof right === \"string\")) {\n    throw new RuntimeError(\"RegExp.test requires the first argument to be a RegExp and the second argument to be a string. Arguments are \" + left + \" and \" + right + \".\");\n  }\n\n  return left.test(right);\n};\n\nNode.prototype._evaluateRegExpMatch = function (feature) {\n  var left = this._left.evaluate(feature);\n\n  var right = this._right.evaluate(feature);\n\n  if (left instanceof RegExp && typeof right === \"string\") {\n    return left.test(right);\n  } else if (right instanceof RegExp && typeof left === \"string\") {\n    return right.test(left);\n  }\n\n  throw new RuntimeError('Operator \"=~\" requires one RegExp argument and one string argument. Arguments are ' + left + \" and \" + right + \".\");\n};\n\nNode.prototype._evaluateRegExpNotMatch = function (feature) {\n  var left = this._left.evaluate(feature);\n\n  var right = this._right.evaluate(feature);\n\n  if (left instanceof RegExp && typeof right === \"string\") {\n    return !left.test(right);\n  } else if (right instanceof RegExp && typeof left === \"string\") {\n    return !right.test(left);\n  }\n\n  throw new RuntimeError('Operator \"!~\" requires one RegExp argument and one string argument. Arguments are ' + left + \" and \" + right + \".\");\n};\n\nNode.prototype._evaluateRegExpExec = function (feature) {\n  var left = this._left.evaluate(feature);\n\n  var right = this._right.evaluate(feature);\n\n  if (!(left instanceof RegExp && typeof right === \"string\")) {\n    throw new RuntimeError(\"RegExp.exec requires the first argument to be a RegExp and the second argument to be a string. Arguments are \" + left + \" and \" + right + \".\");\n  }\n\n  var exec = left.exec(right);\n\n  if (!defined(exec)) {\n    return null;\n  }\n\n  return exec[1];\n};\n\nNode.prototype._evaluateToString = function (feature) {\n  var left = this._left.evaluate(feature);\n\n  if (left instanceof RegExp || left instanceof Cartesian2 || left instanceof Cartesian3 || left instanceof Cartesian4) {\n    return String(left);\n  }\n\n  throw new RuntimeError('Unexpected function call \"' + this._value + '\".');\n};\n\nfunction convertHSLToRGB(ast) {\n  // Check if the color contains any nested expressions to see if the color can be converted here.\n  // E.g. \"hsl(0.9, 0.6, 0.7)\" is able to convert directly to rgb, \"hsl(0.9, 0.6, ${Height})\" is not.\n  var channels = ast._left;\n  var length = channels.length;\n\n  for (var i = 0; i < length; ++i) {\n    if (channels[i]._type !== ExpressionNodeType.LITERAL_NUMBER) {\n      return undefined;\n    }\n  }\n\n  var h = channels[0]._value;\n  var s = channels[1]._value;\n  var l = channels[2]._value;\n  var a = length === 4 ? channels[3]._value : 1.0;\n  return Color.fromHsl(h, s, l, a, scratchColor);\n}\n\nfunction convertRGBToColor(ast) {\n  // Check if the color contains any nested expressions to see if the color can be converted here.\n  // E.g. \"rgb(255, 255, 255)\" is able to convert directly to Color, \"rgb(255, 255, ${Height})\" is not.\n  var channels = ast._left;\n  var length = channels.length;\n\n  for (var i = 0; i < length; ++i) {\n    if (channels[i]._type !== ExpressionNodeType.LITERAL_NUMBER) {\n      return undefined;\n    }\n  }\n\n  var color = scratchColor;\n  color.red = channels[0]._value / 255.0;\n  color.green = channels[1]._value / 255.0;\n  color.blue = channels[2]._value / 255.0;\n  color.alpha = length === 4 ? channels[3]._value : 1.0;\n  return color;\n}\n\nfunction numberToString(number) {\n  if (number % 1 === 0) {\n    // Add a .0 to whole numbers\n    return number.toFixed(1);\n  }\n\n  return number.toString();\n}\n\nfunction colorToVec3(color) {\n  var r = numberToString(color.red);\n  var g = numberToString(color.green);\n  var b = numberToString(color.blue);\n  return \"vec3(\" + r + \", \" + g + \", \" + b + \")\";\n}\n\nfunction colorToVec4(color) {\n  var r = numberToString(color.red);\n  var g = numberToString(color.green);\n  var b = numberToString(color.blue);\n  var a = numberToString(color.alpha);\n  return \"vec4(\" + r + \", \" + g + \", \" + b + \", \" + a + \")\";\n}\n\nfunction getExpressionArray(array, attributePrefix, shaderState, parent) {\n  var length = array.length;\n  var expressions = new Array(length);\n\n  for (var i = 0; i < length; ++i) {\n    expressions[i] = array[i].getShaderExpression(attributePrefix, shaderState, parent);\n  }\n\n  return expressions;\n}\n\nvar nullSentinel = \"czm_infinity\"; // null just needs to be some sentinel value that will cause \"[expression] === null\" to be false in nearly all cases. GLSL doesn't have a NaN constant so use czm_infinity.\n\nNode.prototype.getShaderExpression = function (attributePrefix, shaderState, parent) {\n  var color;\n  var left;\n  var right;\n  var test;\n  var type = this._type;\n  var value = this._value;\n\n  if (defined(this._left)) {\n    if (Array.isArray(this._left)) {\n      // Left can be an array if the type is LITERAL_COLOR or LITERAL_VECTOR\n      left = getExpressionArray(this._left, attributePrefix, shaderState, this);\n    } else {\n      left = this._left.getShaderExpression(attributePrefix, shaderState, this);\n    }\n  }\n\n  if (defined(this._right)) {\n    right = this._right.getShaderExpression(attributePrefix, shaderState, this);\n  }\n\n  if (defined(this._test)) {\n    test = this._test.getShaderExpression(attributePrefix, shaderState, this);\n  }\n\n  if (Array.isArray(this._value)) {\n    // For ARRAY type\n    value = getExpressionArray(this._value, attributePrefix, shaderState, this);\n  }\n\n  switch (type) {\n    case ExpressionNodeType.VARIABLE:\n      return attributePrefix + value;\n\n    case ExpressionNodeType.UNARY:\n      // Supported types: +, -, !, Boolean, Number\n      if (value === \"Boolean\") {\n        return \"bool(\" + left + \")\";\n      } else if (value === \"Number\") {\n        return \"float(\" + left + \")\";\n      } else if (value === \"round\") {\n        return \"floor(\" + left + \" + 0.5)\";\n      } else if (defined(unaryFunctions[value])) {\n        return value + \"(\" + left + \")\";\n      } else if (value === \"isNaN\") {\n        // In GLSL 2.0 use isnan instead\n        return \"(\" + left + \" != \" + left + \")\";\n      } else if (value === \"isFinite\") {\n        // In GLSL 2.0 use isinf instead. GLSL doesn't have an infinity constant so use czm_infinity which is an arbitrarily big enough number.\n        return \"(abs(\" + left + \") < czm_infinity)\";\n      } else if (value === \"String\" || value === \"isExactClass\" || value === \"isClass\" || value === \"getExactClassName\") {\n        throw new RuntimeError('Error generating style shader: \"' + value + '\" is not supported.');\n      } else if (defined(unaryFunctions[value])) {\n        return value + \"(\" + left + \")\";\n      }\n\n      return value + left;\n\n    case ExpressionNodeType.BINARY:\n      // Supported types: ||, &&, ===, !==, <, >, <=, >=, +, -, *, /, %\n      if (value === \"%\") {\n        return \"mod(\" + left + \", \" + right + \")\";\n      } else if (value === \"===\") {\n        return \"(\" + left + \" == \" + right + \")\";\n      } else if (value === \"!==\") {\n        return \"(\" + left + \" != \" + right + \")\";\n      } else if (value === \"atan2\") {\n        return \"atan(\" + left + \", \" + right + \")\";\n      } else if (defined(binaryFunctions[value])) {\n        return value + \"(\" + left + \", \" + right + \")\";\n      }\n\n      return \"(\" + left + \" \" + value + \" \" + right + \")\";\n\n    case ExpressionNodeType.TERNARY:\n      if (defined(ternaryFunctions[value])) {\n        return value + \"(\" + left + \", \" + right + \", \" + test + \")\";\n      }\n\n      break;\n\n    case ExpressionNodeType.CONDITIONAL:\n      return \"(\" + test + \" ? \" + left + \" : \" + right + \")\";\n\n    case ExpressionNodeType.MEMBER:\n      // This is intended for accessing the components of vector properties. String members aren't supported.\n      // Check for 0.0 rather than 0 because all numbers are previously converted to decimals.\n      if (right === \"r\" || right === \"x\" || right === \"0.0\") {\n        return left + \"[0]\";\n      } else if (right === \"g\" || right === \"y\" || right === \"1.0\") {\n        return left + \"[1]\";\n      } else if (right === \"b\" || right === \"z\" || right === \"2.0\") {\n        return left + \"[2]\";\n      } else if (right === \"a\" || right === \"w\" || right === \"3.0\") {\n        return left + \"[3]\";\n      }\n\n      return left + \"[int(\" + right + \")]\";\n\n    case ExpressionNodeType.FUNCTION_CALL:\n      throw new RuntimeError('Error generating style shader: \"' + value + '\" is not supported.');\n\n    case ExpressionNodeType.ARRAY:\n      if (value.length === 4) {\n        return \"vec4(\" + value[0] + \", \" + value[1] + \", \" + value[2] + \", \" + value[3] + \")\";\n      } else if (value.length === 3) {\n        return \"vec3(\" + value[0] + \", \" + value[1] + \", \" + value[2] + \")\";\n      } else if (value.length === 2) {\n        return \"vec2(\" + value[0] + \", \" + value[1] + \")\";\n      }\n\n      throw new RuntimeError(\"Error generating style shader: Invalid array length. Array length should be 2, 3, or 4.\");\n\n    case ExpressionNodeType.REGEX:\n      throw new RuntimeError(\"Error generating style shader: Regular expressions are not supported.\");\n\n    case ExpressionNodeType.VARIABLE_IN_STRING:\n      throw new RuntimeError(\"Error generating style shader: Converting a variable to a string is not supported.\");\n\n    case ExpressionNodeType.LITERAL_NULL:\n      return nullSentinel;\n\n    case ExpressionNodeType.LITERAL_BOOLEAN:\n      return value ? \"true\" : \"false\";\n\n    case ExpressionNodeType.LITERAL_NUMBER:\n      return numberToString(value);\n\n    case ExpressionNodeType.LITERAL_STRING:\n      if (defined(parent) && parent._type === ExpressionNodeType.MEMBER) {\n        if (value === \"r\" || value === \"g\" || value === \"b\" || value === \"a\" || value === \"x\" || value === \"y\" || value === \"z\" || value === \"w\") {\n          return value;\n        }\n      } // Check for css color strings\n\n\n      color = Color.fromCssColorString(value, scratchColor);\n\n      if (defined(color)) {\n        return colorToVec3(color);\n      }\n\n      throw new RuntimeError(\"Error generating style shader: String literals are not supported.\");\n\n    case ExpressionNodeType.LITERAL_COLOR:\n      var args = left;\n\n      if (value === \"color\") {\n        if (!defined(args)) {\n          return \"vec4(1.0)\";\n        } else if (args.length > 1) {\n          var rgb = args[0];\n          var alpha = args[1];\n\n          if (alpha !== \"1.0\") {\n            shaderState.translucent = true;\n          }\n\n          return \"vec4(\" + rgb + \", \" + alpha + \")\";\n        }\n\n        return \"vec4(\" + args[0] + \", 1.0)\";\n      } else if (value === \"rgb\") {\n        color = convertRGBToColor(this);\n\n        if (defined(color)) {\n          return colorToVec4(color);\n        }\n\n        return \"vec4(\" + args[0] + \" / 255.0, \" + args[1] + \" / 255.0, \" + args[2] + \" / 255.0, 1.0)\";\n      } else if (value === \"rgba\") {\n        if (args[3] !== \"1.0\") {\n          shaderState.translucent = true;\n        }\n\n        color = convertRGBToColor(this);\n\n        if (defined(color)) {\n          return colorToVec4(color);\n        }\n\n        return \"vec4(\" + args[0] + \" / 255.0, \" + args[1] + \" / 255.0, \" + args[2] + \" / 255.0, \" + args[3] + \")\";\n      } else if (value === \"hsl\") {\n        color = convertHSLToRGB(this);\n\n        if (defined(color)) {\n          return colorToVec4(color);\n        }\n\n        return \"vec4(czm_HSLToRGB(vec3(\" + args[0] + \", \" + args[1] + \", \" + args[2] + \")), 1.0)\";\n      } else if (value === \"hsla\") {\n        color = convertHSLToRGB(this);\n\n        if (defined(color)) {\n          if (color.alpha !== 1.0) {\n            shaderState.translucent = true;\n          }\n\n          return colorToVec4(color);\n        }\n\n        if (args[3] !== \"1.0\") {\n          shaderState.translucent = true;\n        }\n\n        return \"vec4(czm_HSLToRGB(vec3(\" + args[0] + \", \" + args[1] + \", \" + args[2] + \")), \" + args[3] + \")\";\n      }\n\n      break;\n\n    case ExpressionNodeType.LITERAL_VECTOR:\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(left)) {\n        throw new DeveloperError(\"left should always be defined for type ExpressionNodeType.LITERAL_VECTOR\");\n      } //>>includeEnd('debug');\n\n\n      var length = left.length;\n      var vectorExpression = value + \"(\";\n\n      for (var i = 0; i < length; ++i) {\n        vectorExpression += left[i];\n\n        if (i < length - 1) {\n          vectorExpression += \", \";\n        }\n      }\n\n      vectorExpression += \")\";\n      return vectorExpression;\n\n    case ExpressionNodeType.LITERAL_REGEX:\n      throw new RuntimeError(\"Error generating style shader: Regular expressions are not supported.\");\n\n    case ExpressionNodeType.LITERAL_UNDEFINED:\n      return nullSentinel;\n\n    case ExpressionNodeType.BUILTIN_VARIABLE:\n      if (value === \"tiles3d_tileset_time\") {\n        return \"u_time\";\n      }\n\n  }\n};\n\nexport default Expression;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/Expression.js"],"names":["Cartesian2","Cartesian3","Cartesian4","Check","Color","defined","DeveloperError","CesiumMath","RuntimeError","jsep","ExpressionNodeType","Expression","expression","defines","typeOf","string","_expression","replaceDefines","replaceVariables","removeBackslashes","addBinaryOp","ast","e","_runtimeAst","createRuntimeAst","Object","defineProperties","prototype","get","scratchStorage","arrayIndex","arrayArray","cartesian2Index","cartesian3Index","cartesian4Index","cartesian2Array","cartesian3Array","cartesian4Array","reset","getArray","length","push","array","getCartesian2","getCartesian3","getCartesian4","evaluate","feature","result","value","fromCartesian4","clone","evaluateColor","color","getShaderFunction","functionName","attributePrefix","shaderState","returnType","shaderExpression","getShaderExpression","unaryOperators","binaryOperators","variableRegex","backslashRegex","backslashReplacement","replacementRegex","scratchColor","unaryFunctions","abs","getEvaluateUnaryComponentwise","Math","sqrt","cos","sin","tan","acos","asin","atan","radians","toRadians","degrees","toDegrees","sign","floor","ceil","round","exp","exp2","log","log2","fract","normalize","binaryFunctions","atan2","getEvaluateBinaryComponentwise","pow","min","max","distance","dot","cross","ternaryFunctions","clamp","getEvaluateTernaryComponentwise","mix","lerp","number","exponent","operation","call","left","fromElements","x","y","z","w","allowScalar","right","test","magnitude","Node","type","_type","_value","_left","_right","_test","undefined","setEvaluateFunction","key","hasOwnProperty","definePlaceholder","RegExp","defineReplace","replace","replaceBackslashes","i","indexOf","openSingleQuote","openDoubleQuote","closeQuote","substr","j","parseLiteral","LITERAL_NULL","LITERAL_BOOLEAN","LITERAL_NUMBER","VARIABLE_IN_STRING","LITERAL_STRING","parseCall","args","arguments","argsLength","val","callee","property","name","object","FUNCTION_CALL","LITERAL_COLOR","alpha","Array","LITERAL_VECTOR","UNARY","BINARY","TERNARY","parseRegex","LITERAL_REGEX","pattern","flags","isLiteralType","String","REGEX","parseKeywordsAndVariables","isVariable","getPropertyName","BUILTIN_VARIABLE","VARIABLE","NaN","Infinity","LITERAL_UNDEFINED","parseMathConstant","PI","E","parseNumberConstant","Number","POSITIVE_INFINITY","parseMemberExpression","obj","computed","MEMBER","node","variable","op","operator","child","argument","consequent","alternate","CONDITIONAL","elements","ARRAY","_evaluateConditional","_evaluateRegExpTest","_evaluateRegExpExec","_evaluateToString","_evaluateNot","_evaluateNegative","_evaluatePositive","_evaluateNaN","_evaluateIsFinite","_evaluateIsExactClass","_evaluateIsClass","_evaluateGetExactClassName","_evaluateBooleanConversion","_evaluateNumberConversion","_evaluateStringConversion","getEvaluateUnaryFunction","_evaluatePlus","_evaluateMinus","_evaluateTimes","_evaluateDivide","_evaluateMod","_evaluateEqualsStrict","_evaluateNotEqualsStrict","_evaluateLessThan","_evaluateLessThanOrEquals","_evaluateGreaterThan","_evaluateGreaterThanOrEquals","_evaluateAnd","_evaluateOr","_evaluateRegExpMatch","_evaluateRegExpNotMatch","getEvaluateBinaryFunction","getEvaluateTernaryFunction","_evaluateMemberBrackets","_evaluateMemberDot","_evaluateArray","_evaluateVariable","_evaluateVariableString","_evaluateLiteralColor","_evaluateLiteralVector","_evaluateLiteralString","_evaluateRegExp","evaluateTilesetTime","_evaluateLiteral","content","tileset","timeSinceLoad","getFeatureProperty","getProperty","fromBytes","fromCssColorString","a","fromHsl","fromColor","components","componentsLength","vectorLength","parseInt","charAt","component","fromArray","match","exec","placeholder","variableName","checkFeature","member","negate","add","subtract","multiplyComponents","multiplyByScalar","divideComponents","divideByScalar","equals","isNaN","isFinite","isExactClass","isClass","getExactClassName","Boolean","convertHSLToRGB","channels","h","s","l","convertRGBToColor","red","green","blue","numberToString","toFixed","toString","colorToVec3","r","g","b","colorToVec4","getExpressionArray","parent","expressions","nullSentinel","isArray","rgb","translucent","vectorExpression"],"mappings":"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","sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport jsep from \"../ThirdParty/jsep.js\";\nimport ExpressionNodeType from \"./ExpressionNodeType.js\";\n\n/**\n * An expression for a style applied to a {@link Cesium3DTileset}.\n * <p>\n * Evaluates an expression defined using the\n * {@link https://github.com/CesiumGS/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language}.\n * </p>\n * <p>\n * Implements the {@link StyleExpression} interface.\n * </p>\n *\n * @alias Expression\n * @constructor\n *\n * @param {String} [expression] The expression defined using the 3D Tiles Styling language.\n * @param {Object} [defines] Defines in the style.\n *\n * @example\n * var expression = new Cesium.Expression('(regExp(\"^Chest\").test(${County})) && (${YearBuilt} >= 1970)');\n * expression.evaluate(feature); // returns true or false depending on the feature's properties\n *\n * @example\n * var expression = new Cesium.Expression('(${Temperature} > 90) ? color(\"red\") : color(\"white\")');\n * expression.evaluateColor(feature, result); // returns a Cesium.Color object\n */\nfunction Expression(expression, defines) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"expression\", expression);\n  //>>includeEnd('debug');\n\n  this._expression = expression;\n  expression = replaceDefines(expression, defines);\n  expression = replaceVariables(removeBackslashes(expression));\n\n  // customize jsep operators\n  jsep.addBinaryOp(\"=~\", 0);\n  jsep.addBinaryOp(\"!~\", 0);\n\n  var ast;\n  try {\n    ast = jsep(expression);\n  } catch (e) {\n    throw new RuntimeError(e);\n  }\n\n  this._runtimeAst = createRuntimeAst(this, ast);\n}\n\nObject.defineProperties(Expression.prototype, {\n  /**\n   * Gets the expression defined in the 3D Tiles Styling language.\n   *\n   * @memberof Expression.prototype\n   *\n   * @type {String}\n   * @readonly\n   *\n   * @default undefined\n   */\n  expression: {\n    get: function () {\n      return this._expression;\n    },\n  },\n});\n\n// Scratch storage manager while evaluating deep expressions.\n// For example, an expression like dot(vec4(${red}), vec4(${green}) * vec4(${blue}) requires 3 scratch Cartesian4's\nvar scratchStorage = {\n  arrayIndex: 0,\n  arrayArray: [[]],\n  cartesian2Index: 0,\n  cartesian3Index: 0,\n  cartesian4Index: 0,\n  cartesian2Array: [new Cartesian2()],\n  cartesian3Array: [new Cartesian3()],\n  cartesian4Array: [new Cartesian4()],\n  reset: function () {\n    this.arrayIndex = 0;\n    this.cartesian2Index = 0;\n    this.cartesian3Index = 0;\n    this.cartesian4Index = 0;\n  },\n  getArray: function () {\n    if (this.arrayIndex >= this.arrayArray.length) {\n      this.arrayArray.push([]);\n    }\n    var array = this.arrayArray[this.arrayIndex++];\n    array.length = 0;\n    return array;\n  },\n  getCartesian2: function () {\n    if (this.cartesian2Index >= this.cartesian2Array.length) {\n      this.cartesian2Array.push(new Cartesian2());\n    }\n    return this.cartesian2Array[this.cartesian2Index++];\n  },\n  getCartesian3: function () {\n    if (this.cartesian3Index >= this.cartesian3Array.length) {\n      this.cartesian3Array.push(new Cartesian3());\n    }\n    return this.cartesian3Array[this.cartesian3Index++];\n  },\n  getCartesian4: function () {\n    if (this.cartesian4Index >= this.cartesian4Array.length) {\n      this.cartesian4Array.push(new Cartesian4());\n    }\n    return this.cartesian4Array[this.cartesian4Index++];\n  },\n};\n\n/**\n * Evaluates the result of an expression, optionally using the provided feature's properties. If the result of\n * the expression in the\n * {@link https://github.com/CesiumGS/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language}\n * is of type <code>Boolean</code>, <code>Number</code>, or <code>String</code>, the corresponding JavaScript\n * primitive type will be returned. If the result is a <code>RegExp</code>, a Javascript <code>RegExp</code>\n * object will be returned. If the result is a <code>Cartesian2</code>, <code>Cartesian3</code>, or <code>Cartesian4</code>,\n * a {@link Cartesian2}, {@link Cartesian3}, or {@link Cartesian4} object will be returned. If the <code>result</code> argument is\n * a {@link Color}, the {@link Cartesian4} value is converted to a {@link Color} and then returned.\n *\n * @param {Cesium3DTileFeature} feature The feature whose properties may be used as variables in the expression.\n * @param {Object} [result] The object onto which to store the result.\n * @returns {Boolean|Number|String|RegExp|Cartesian2|Cartesian3|Cartesian4|Color} The result of evaluating the expression.\n */\nExpression.prototype.evaluate = function (feature, result) {\n  scratchStorage.reset();\n  var value = this._runtimeAst.evaluate(feature);\n  if (result instanceof Color && value instanceof Cartesian4) {\n    return Color.fromCartesian4(value, result);\n  }\n  if (\n    value instanceof Cartesian2 ||\n    value instanceof Cartesian3 ||\n    value instanceof Cartesian4\n  ) {\n    return value.clone(result);\n  }\n  return value;\n};\n\n/**\n * Evaluates the result of a Color expression, optionally using the provided feature's properties.\n * <p>\n * This is equivalent to {@link Expression#evaluate} but always returns a {@link Color} object.\n * </p>\n *\n * @param {Cesium3DTileFeature} feature The feature whose properties may be used as variables in the expression.\n * @param {Color} [result] The object in which to store the result\n * @returns {Color} The modified result parameter or a new Color instance if one was not provided.\n */\nExpression.prototype.evaluateColor = function (feature, result) {\n  scratchStorage.reset();\n  var color = this._runtimeAst.evaluate(feature);\n  return Color.fromCartesian4(color, result);\n};\n\n/**\n * Gets the shader function for this expression.\n * Returns undefined if the shader function can't be generated from this expression.\n *\n * @param {String} functionName Name to give to the generated function.\n * @param {String} attributePrefix Prefix that is added to any variable names to access vertex attributes.\n * @param {Object} shaderState Stores information about the generated shader function, including whether it is translucent.\n * @param {String} returnType The return type of the generated function.\n *\n * @returns {String} The shader function.\n *\n * @private\n */\nExpression.prototype.getShaderFunction = function (\n  functionName,\n  attributePrefix,\n  shaderState,\n  returnType\n) {\n  var shaderExpression = this.getShaderExpression(attributePrefix, shaderState);\n\n  shaderExpression =\n    returnType +\n    \" \" +\n    functionName +\n    \"() \\n\" +\n    \"{ \\n\" +\n    \"    return \" +\n    shaderExpression +\n    \"; \\n\" +\n    \"} \\n\";\n\n  return shaderExpression;\n};\n\n/**\n * Gets the shader expression for this expression.\n * Returns undefined if the shader expression can't be generated from this expression.\n *\n * @param {String} attributePrefix Prefix that is added to any variable names to access vertex attributes.\n * @param {Object} shaderState Stores information about the generated shader function, including whether it is translucent.\n *\n * @returns {String} The shader expression.\n *\n * @private\n */\nExpression.prototype.getShaderExpression = function (\n  attributePrefix,\n  shaderState\n) {\n  return this._runtimeAst.getShaderExpression(attributePrefix, shaderState);\n};\n\nvar unaryOperators = [\"!\", \"-\", \"+\"];\nvar binaryOperators = [\n  \"+\",\n  \"-\",\n  \"*\",\n  \"/\",\n  \"%\",\n  \"===\",\n  \"!==\",\n  \">\",\n  \">=\",\n  \"<\",\n  \"<=\",\n  \"&&\",\n  \"||\",\n  \"!~\",\n  \"=~\",\n];\n\nvar variableRegex = /\\${(.*?)}/g; // Matches ${variable_name}\nvar backslashRegex = /\\\\/g;\nvar backslashReplacement = \"@#%\";\nvar replacementRegex = /@#%/g;\n\nvar scratchColor = new Color();\n\nvar unaryFunctions = {\n  abs: getEvaluateUnaryComponentwise(Math.abs),\n  sqrt: getEvaluateUnaryComponentwise(Math.sqrt),\n  cos: getEvaluateUnaryComponentwise(Math.cos),\n  sin: getEvaluateUnaryComponentwise(Math.sin),\n  tan: getEvaluateUnaryComponentwise(Math.tan),\n  acos: getEvaluateUnaryComponentwise(Math.acos),\n  asin: getEvaluateUnaryComponentwise(Math.asin),\n  atan: getEvaluateUnaryComponentwise(Math.atan),\n  radians: getEvaluateUnaryComponentwise(CesiumMath.toRadians),\n  degrees: getEvaluateUnaryComponentwise(CesiumMath.toDegrees),\n  sign: getEvaluateUnaryComponentwise(CesiumMath.sign),\n  floor: getEvaluateUnaryComponentwise(Math.floor),\n  ceil: getEvaluateUnaryComponentwise(Math.ceil),\n  round: getEvaluateUnaryComponentwise(Math.round),\n  exp: getEvaluateUnaryComponentwise(Math.exp),\n  exp2: getEvaluateUnaryComponentwise(exp2),\n  log: getEvaluateUnaryComponentwise(Math.log),\n  log2: getEvaluateUnaryComponentwise(log2),\n  fract: getEvaluateUnaryComponentwise(fract),\n  length: length,\n  normalize: normalize,\n};\n\nvar binaryFunctions = {\n  atan2: getEvaluateBinaryComponentwise(Math.atan2, false),\n  pow: getEvaluateBinaryComponentwise(Math.pow, false),\n  min: getEvaluateBinaryComponentwise(Math.min, true),\n  max: getEvaluateBinaryComponentwise(Math.max, true),\n  distance: distance,\n  dot: dot,\n  cross: cross,\n};\n\nvar ternaryFunctions = {\n  clamp: getEvaluateTernaryComponentwise(CesiumMath.clamp, true),\n  mix: getEvaluateTernaryComponentwise(CesiumMath.lerp, true),\n};\n\nfunction fract(number) {\n  return number - Math.floor(number);\n}\n\nfunction exp2(exponent) {\n  return Math.pow(2.0, exponent);\n}\n\nfunction log2(number) {\n  return CesiumMath.log2(number);\n}\n\nfunction getEvaluateUnaryComponentwise(operation) {\n  return function (call, left) {\n    if (typeof left === \"number\") {\n      return operation(left);\n    } else if (left instanceof Cartesian2) {\n      return Cartesian2.fromElements(\n        operation(left.x),\n        operation(left.y),\n        scratchStorage.getCartesian2()\n      );\n    } else if (left instanceof Cartesian3) {\n      return Cartesian3.fromElements(\n        operation(left.x),\n        operation(left.y),\n        operation(left.z),\n        scratchStorage.getCartesian3()\n      );\n    } else if (left instanceof Cartesian4) {\n      return Cartesian4.fromElements(\n        operation(left.x),\n        operation(left.y),\n        operation(left.z),\n        operation(left.w),\n        scratchStorage.getCartesian4()\n      );\n    }\n    throw new RuntimeError(\n      'Function \"' +\n        call +\n        '\" requires a vector or number argument. Argument is ' +\n        left +\n        \".\"\n    );\n  };\n}\n\nfunction getEvaluateBinaryComponentwise(operation, allowScalar) {\n  return function (call, left, right) {\n    if (allowScalar && typeof right === \"number\") {\n      if (typeof left === \"number\") {\n        return operation(left, right);\n      } else if (left instanceof Cartesian2) {\n        return Cartesian2.fromElements(\n          operation(left.x, right),\n          operation(left.y, right),\n          scratchStorage.getCartesian2()\n        );\n      } else if (left instanceof Cartesian3) {\n        return Cartesian3.fromElements(\n          operation(left.x, right),\n          operation(left.y, right),\n          operation(left.z, right),\n          scratchStorage.getCartesian3()\n        );\n      } else if (left instanceof Cartesian4) {\n        return Cartesian4.fromElements(\n          operation(left.x, right),\n          operation(left.y, right),\n          operation(left.z, right),\n          operation(left.w, right),\n          scratchStorage.getCartesian4()\n        );\n      }\n    }\n\n    if (typeof left === \"number\" && typeof right === \"number\") {\n      return operation(left, right);\n    } else if (left instanceof Cartesian2 && right instanceof Cartesian2) {\n      return Cartesian2.fromElements(\n        operation(left.x, right.x),\n        operation(left.y, right.y),\n        scratchStorage.getCartesian2()\n      );\n    } else if (left instanceof Cartesian3 && right instanceof Cartesian3) {\n      return Cartesian3.fromElements(\n        operation(left.x, right.x),\n        operation(left.y, right.y),\n        operation(left.z, right.z),\n        scratchStorage.getCartesian3()\n      );\n    } else if (left instanceof Cartesian4 && right instanceof Cartesian4) {\n      return Cartesian4.fromElements(\n        operation(left.x, right.x),\n        operation(left.y, right.y),\n        operation(left.z, right.z),\n        operation(left.w, right.w),\n        scratchStorage.getCartesian4()\n      );\n    }\n\n    throw new RuntimeError(\n      'Function \"' +\n        call +\n        '\" requires vector or number arguments of matching types. Arguments are ' +\n        left +\n        \" and \" +\n        right +\n        \".\"\n    );\n  };\n}\n\nfunction getEvaluateTernaryComponentwise(operation, allowScalar) {\n  return function (call, left, right, test) {\n    if (allowScalar && typeof test === \"number\") {\n      if (typeof left === \"number\" && typeof right === \"number\") {\n        return operation(left, right, test);\n      } else if (left instanceof Cartesian2 && right instanceof Cartesian2) {\n        return Cartesian2.fromElements(\n          operation(left.x, right.x, test),\n          operation(left.y, right.y, test),\n          scratchStorage.getCartesian2()\n        );\n      } else if (left instanceof Cartesian3 && right instanceof Cartesian3) {\n        return Cartesian3.fromElements(\n          operation(left.x, right.x, test),\n          operation(left.y, right.y, test),\n          operation(left.z, right.z, test),\n          scratchStorage.getCartesian3()\n        );\n      } else if (left instanceof Cartesian4 && right instanceof Cartesian4) {\n        return Cartesian4.fromElements(\n          operation(left.x, right.x, test),\n          operation(left.y, right.y, test),\n          operation(left.z, right.z, test),\n          operation(left.w, right.w, test),\n          scratchStorage.getCartesian4()\n        );\n      }\n    }\n\n    if (\n      typeof left === \"number\" &&\n      typeof right === \"number\" &&\n      typeof test === \"number\"\n    ) {\n      return operation(left, right, test);\n    } else if (\n      left instanceof Cartesian2 &&\n      right instanceof Cartesian2 &&\n      test instanceof Cartesian2\n    ) {\n      return Cartesian2.fromElements(\n        operation(left.x, right.x, test.x),\n        operation(left.y, right.y, test.y),\n        scratchStorage.getCartesian2()\n      );\n    } else if (\n      left instanceof Cartesian3 &&\n      right instanceof Cartesian3 &&\n      test instanceof Cartesian3\n    ) {\n      return Cartesian3.fromElements(\n        operation(left.x, right.x, test.x),\n        operation(left.y, right.y, test.y),\n        operation(left.z, right.z, test.z),\n        scratchStorage.getCartesian3()\n      );\n    } else if (\n      left instanceof Cartesian4 &&\n      right instanceof Cartesian4 &&\n      test instanceof Cartesian4\n    ) {\n      return Cartesian4.fromElements(\n        operation(left.x, right.x, test.x),\n        operation(left.y, right.y, test.y),\n        operation(left.z, right.z, test.z),\n        operation(left.w, right.w, test.w),\n        scratchStorage.getCartesian4()\n      );\n    }\n\n    throw new RuntimeError(\n      'Function \"' +\n        call +\n        '\" requires vector or number arguments of matching types. Arguments are ' +\n        left +\n        \", \" +\n        right +\n        \", and \" +\n        test +\n        \".\"\n    );\n  };\n}\n\nfunction length(call, left) {\n  if (typeof left === \"number\") {\n    return Math.abs(left);\n  } else if (left instanceof Cartesian2) {\n    return Cartesian2.magnitude(left);\n  } else if (left instanceof Cartesian3) {\n    return Cartesian3.magnitude(left);\n  } else if (left instanceof Cartesian4) {\n    return Cartesian4.magnitude(left);\n  }\n\n  throw new RuntimeError(\n    'Function \"' +\n      call +\n      '\" requires a vector or number argument. Argument is ' +\n      left +\n      \".\"\n  );\n}\n\nfunction normalize(call, left) {\n  if (typeof left === \"number\") {\n    return 1.0;\n  } else if (left instanceof Cartesian2) {\n    return Cartesian2.normalize(left, scratchStorage.getCartesian2());\n  } else if (left instanceof Cartesian3) {\n    return Cartesian3.normalize(left, scratchStorage.getCartesian3());\n  } else if (left instanceof Cartesian4) {\n    return Cartesian4.normalize(left, scratchStorage.getCartesian4());\n  }\n\n  throw new RuntimeError(\n    'Function \"' +\n      call +\n      '\" requires a vector or number argument. Argument is ' +\n      left +\n      \".\"\n  );\n}\n\nfunction distance(call, left, right) {\n  if (typeof left === \"number\" && typeof right === \"number\") {\n    return Math.abs(left - right);\n  } else if (left instanceof Cartesian2 && right instanceof Cartesian2) {\n    return Cartesian2.distance(left, right);\n  } else if (left instanceof Cartesian3 && right instanceof Cartesian3) {\n    return Cartesian3.distance(left, right);\n  } else if (left instanceof Cartesian4 && right instanceof Cartesian4) {\n    return Cartesian4.distance(left, right);\n  }\n\n  throw new RuntimeError(\n    'Function \"' +\n      call +\n      '\" requires vector or number arguments of matching types. Arguments are ' +\n      left +\n      \" and \" +\n      right +\n      \".\"\n  );\n}\n\nfunction dot(call, left, right) {\n  if (typeof left === \"number\" && typeof right === \"number\") {\n    return left * right;\n  } else if (left instanceof Cartesian2 && right instanceof Cartesian2) {\n    return Cartesian2.dot(left, right);\n  } else if (left instanceof Cartesian3 && right instanceof Cartesian3) {\n    return Cartesian3.dot(left, right);\n  } else if (left instanceof Cartesian4 && right instanceof Cartesian4) {\n    return Cartesian4.dot(left, right);\n  }\n\n  throw new RuntimeError(\n    'Function \"' +\n      call +\n      '\" requires vector or number arguments of matching types. Arguments are ' +\n      left +\n      \" and \" +\n      right +\n      \".\"\n  );\n}\n\nfunction cross(call, left, right) {\n  if (left instanceof Cartesian3 && right instanceof Cartesian3) {\n    return Cartesian3.cross(left, right, scratchStorage.getCartesian3());\n  }\n\n  throw new RuntimeError(\n    'Function \"' +\n      call +\n      '\" requires vec3 arguments. Arguments are ' +\n      left +\n      \" and \" +\n      right +\n      \".\"\n  );\n}\n\nfunction Node(type, value, left, right, test) {\n  this._type = type;\n  this._value = value;\n  this._left = left;\n  this._right = right;\n  this._test = test;\n  this.evaluate = undefined;\n\n  setEvaluateFunction(this);\n}\n\nfunction replaceDefines(expression, defines) {\n  if (!defined(defines)) {\n    return expression;\n  }\n  for (var key in defines) {\n    if (defines.hasOwnProperty(key)) {\n      var definePlaceholder = new RegExp(\"\\\\$\\\\{\" + key + \"\\\\}\", \"g\");\n      var defineReplace = \"(\" + defines[key] + \")\";\n      if (defined(defineReplace)) {\n        expression = expression.replace(definePlaceholder, defineReplace);\n      }\n    }\n  }\n  return expression;\n}\n\nfunction removeBackslashes(expression) {\n  return expression.replace(backslashRegex, backslashReplacement);\n}\n\nfunction replaceBackslashes(expression) {\n  return expression.replace(replacementRegex, \"\\\\\");\n}\n\nfunction replaceVariables(expression) {\n  var exp = expression;\n  var result = \"\";\n  var i = exp.indexOf(\"${\");\n  while (i >= 0) {\n    // Check if string is inside quotes\n    var openSingleQuote = exp.indexOf(\"'\");\n    var openDoubleQuote = exp.indexOf('\"');\n    var closeQuote;\n    if (openSingleQuote >= 0 && openSingleQuote < i) {\n      closeQuote = exp.indexOf(\"'\", openSingleQuote + 1);\n      result += exp.substr(0, closeQuote + 1);\n      exp = exp.substr(closeQuote + 1);\n      i = exp.indexOf(\"${\");\n    } else if (openDoubleQuote >= 0 && openDoubleQuote < i) {\n      closeQuote = exp.indexOf('\"', openDoubleQuote + 1);\n      result += exp.substr(0, closeQuote + 1);\n      exp = exp.substr(closeQuote + 1);\n      i = exp.indexOf(\"${\");\n    } else {\n      result += exp.substr(0, i);\n      var j = exp.indexOf(\"}\");\n      if (j < 0) {\n        throw new RuntimeError(\"Unmatched {.\");\n      }\n      result += \"czm_\" + exp.substr(i + 2, j - (i + 2));\n      exp = exp.substr(j + 1);\n      i = exp.indexOf(\"${\");\n    }\n  }\n  result += exp;\n  return result;\n}\n\nfunction parseLiteral(ast) {\n  var type = typeof ast.value;\n  if (ast.value === null) {\n    return new Node(ExpressionNodeType.LITERAL_NULL, null);\n  } else if (type === \"boolean\") {\n    return new Node(ExpressionNodeType.LITERAL_BOOLEAN, ast.value);\n  } else if (type === \"number\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, ast.value);\n  } else if (type === \"string\") {\n    if (ast.value.indexOf(\"${\") >= 0) {\n      return new Node(ExpressionNodeType.VARIABLE_IN_STRING, ast.value);\n    }\n    return new Node(\n      ExpressionNodeType.LITERAL_STRING,\n      replaceBackslashes(ast.value)\n    );\n  }\n}\n\nfunction parseCall(expression, ast) {\n  var args = ast.arguments;\n  var argsLength = args.length;\n  var call;\n  var val, left, right;\n\n  // Member function calls\n  if (ast.callee.type === \"MemberExpression\") {\n    call = ast.callee.property.name;\n    var object = ast.callee.object;\n    if (call === \"test\" || call === \"exec\") {\n      // Make sure this is called on a valid type\n      if (object.callee.name !== \"regExp\") {\n        throw new RuntimeError(call + \" is not a function.\");\n      }\n      if (argsLength === 0) {\n        if (call === \"test\") {\n          return new Node(ExpressionNodeType.LITERAL_BOOLEAN, false);\n        }\n        return new Node(ExpressionNodeType.LITERAL_NULL, null);\n      }\n      left = createRuntimeAst(expression, object);\n      right = createRuntimeAst(expression, args[0]);\n      return new Node(ExpressionNodeType.FUNCTION_CALL, call, left, right);\n    } else if (call === \"toString\") {\n      val = createRuntimeAst(expression, object);\n      return new Node(ExpressionNodeType.FUNCTION_CALL, call, val);\n    }\n\n    throw new RuntimeError('Unexpected function call \"' + call + '\".');\n  }\n\n  // Non-member function calls\n  call = ast.callee.name;\n  if (call === \"color\") {\n    if (argsLength === 0) {\n      return new Node(ExpressionNodeType.LITERAL_COLOR, call);\n    }\n    val = createRuntimeAst(expression, args[0]);\n    if (defined(args[1])) {\n      var alpha = createRuntimeAst(expression, args[1]);\n      return new Node(ExpressionNodeType.LITERAL_COLOR, call, [val, alpha]);\n    }\n    return new Node(ExpressionNodeType.LITERAL_COLOR, call, [val]);\n  } else if (call === \"rgb\" || call === \"hsl\") {\n    if (argsLength < 3) {\n      throw new RuntimeError(call + \" requires three arguments.\");\n    }\n    val = [\n      createRuntimeAst(expression, args[0]),\n      createRuntimeAst(expression, args[1]),\n      createRuntimeAst(expression, args[2]),\n    ];\n    return new Node(ExpressionNodeType.LITERAL_COLOR, call, val);\n  } else if (call === \"rgba\" || call === \"hsla\") {\n    if (argsLength < 4) {\n      throw new RuntimeError(call + \" requires four arguments.\");\n    }\n    val = [\n      createRuntimeAst(expression, args[0]),\n      createRuntimeAst(expression, args[1]),\n      createRuntimeAst(expression, args[2]),\n      createRuntimeAst(expression, args[3]),\n    ];\n    return new Node(ExpressionNodeType.LITERAL_COLOR, call, val);\n  } else if (call === \"vec2\" || call === \"vec3\" || call === \"vec4\") {\n    // Check for invalid constructors at evaluation time\n    val = new Array(argsLength);\n    for (var i = 0; i < argsLength; ++i) {\n      val[i] = createRuntimeAst(expression, args[i]);\n    }\n    return new Node(ExpressionNodeType.LITERAL_VECTOR, call, val);\n  } else if (call === \"isNaN\" || call === \"isFinite\") {\n    if (argsLength === 0) {\n      if (call === \"isNaN\") {\n        return new Node(ExpressionNodeType.LITERAL_BOOLEAN, true);\n      }\n      return new Node(ExpressionNodeType.LITERAL_BOOLEAN, false);\n    }\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (call === \"isExactClass\" || call === \"isClass\") {\n    if (argsLength < 1 || argsLength > 1) {\n      throw new RuntimeError(call + \" requires exactly one argument.\");\n    }\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (call === \"getExactClassName\") {\n    if (argsLength > 0) {\n      throw new RuntimeError(call + \" does not take any argument.\");\n    }\n    return new Node(ExpressionNodeType.UNARY, call);\n  } else if (defined(unaryFunctions[call])) {\n    if (argsLength !== 1) {\n      throw new RuntimeError(call + \" requires exactly one argument.\");\n    }\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (defined(binaryFunctions[call])) {\n    if (argsLength !== 2) {\n      throw new RuntimeError(call + \" requires exactly two arguments.\");\n    }\n    left = createRuntimeAst(expression, args[0]);\n    right = createRuntimeAst(expression, args[1]);\n    return new Node(ExpressionNodeType.BINARY, call, left, right);\n  } else if (defined(ternaryFunctions[call])) {\n    if (argsLength !== 3) {\n      throw new RuntimeError(call + \" requires exactly three arguments.\");\n    }\n    left = createRuntimeAst(expression, args[0]);\n    right = createRuntimeAst(expression, args[1]);\n    var test = createRuntimeAst(expression, args[2]);\n    return new Node(ExpressionNodeType.TERNARY, call, left, right, test);\n  } else if (call === \"Boolean\") {\n    if (argsLength === 0) {\n      return new Node(ExpressionNodeType.LITERAL_BOOLEAN, false);\n    }\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (call === \"Number\") {\n    if (argsLength === 0) {\n      return new Node(ExpressionNodeType.LITERAL_NUMBER, 0);\n    }\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (call === \"String\") {\n    if (argsLength === 0) {\n      return new Node(ExpressionNodeType.LITERAL_STRING, \"\");\n    }\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (call === \"regExp\") {\n    return parseRegex(expression, ast);\n  }\n\n  throw new RuntimeError('Unexpected function call \"' + call + '\".');\n}\n\nfunction parseRegex(expression, ast) {\n  var args = ast.arguments;\n  // no arguments, return default regex\n  if (args.length === 0) {\n    return new Node(ExpressionNodeType.LITERAL_REGEX, new RegExp());\n  }\n\n  var pattern = createRuntimeAst(expression, args[0]);\n  var exp;\n\n  // optional flag argument supplied\n  if (args.length > 1) {\n    var flags = createRuntimeAst(expression, args[1]);\n    if (isLiteralType(pattern) && isLiteralType(flags)) {\n      try {\n        exp = new RegExp(\n          replaceBackslashes(String(pattern._value)),\n          flags._value\n        );\n      } catch (e) {\n        throw new RuntimeError(e);\n      }\n      return new Node(ExpressionNodeType.LITERAL_REGEX, exp);\n    }\n    return new Node(ExpressionNodeType.REGEX, pattern, flags);\n  }\n\n  // only pattern argument supplied\n  if (isLiteralType(pattern)) {\n    try {\n      exp = new RegExp(replaceBackslashes(String(pattern._value)));\n    } catch (e) {\n      throw new RuntimeError(e);\n    }\n    return new Node(ExpressionNodeType.LITERAL_REGEX, exp);\n  }\n  return new Node(ExpressionNodeType.REGEX, pattern);\n}\n\nfunction parseKeywordsAndVariables(ast) {\n  if (isVariable(ast.name)) {\n    var name = getPropertyName(ast.name);\n    if (name.substr(0, 8) === \"tiles3d_\") {\n      return new Node(ExpressionNodeType.BUILTIN_VARIABLE, name);\n    }\n    return new Node(ExpressionNodeType.VARIABLE, name);\n  } else if (ast.name === \"NaN\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, NaN);\n  } else if (ast.name === \"Infinity\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, Infinity);\n  } else if (ast.name === \"undefined\") {\n    return new Node(ExpressionNodeType.LITERAL_UNDEFINED, undefined);\n  }\n\n  throw new RuntimeError(ast.name + \" is not defined.\");\n}\n\nfunction parseMathConstant(ast) {\n  var name = ast.property.name;\n  if (name === \"PI\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, Math.PI);\n  } else if (name === \"E\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, Math.E);\n  }\n}\n\nfunction parseNumberConstant(ast) {\n  var name = ast.property.name;\n  if (name === \"POSITIVE_INFINITY\") {\n    return new Node(\n      ExpressionNodeType.LITERAL_NUMBER,\n      Number.POSITIVE_INFINITY\n    );\n  }\n}\n\nfunction parseMemberExpression(expression, ast) {\n  if (ast.object.name === \"Math\") {\n    return parseMathConstant(ast);\n  } else if (ast.object.name === \"Number\") {\n    return parseNumberConstant(ast);\n  }\n\n  var val;\n  var obj = createRuntimeAst(expression, ast.object);\n  if (ast.computed) {\n    val = createRuntimeAst(expression, ast.property);\n    return new Node(ExpressionNodeType.MEMBER, \"brackets\", obj, val);\n  }\n\n  val = new Node(ExpressionNodeType.LITERAL_STRING, ast.property.name);\n  return new Node(ExpressionNodeType.MEMBER, \"dot\", obj, val);\n}\n\nfunction isLiteralType(node) {\n  return node._type >= ExpressionNodeType.LITERAL_NULL;\n}\n\nfunction isVariable(name) {\n  return name.substr(0, 4) === \"czm_\";\n}\n\nfunction getPropertyName(variable) {\n  return variable.substr(4);\n}\n\nfunction createRuntimeAst(expression, ast) {\n  var node;\n  var op;\n  var left;\n  var right;\n\n  if (ast.type === \"Literal\") {\n    node = parseLiteral(ast);\n  } else if (ast.type === \"CallExpression\") {\n    node = parseCall(expression, ast);\n  } else if (ast.type === \"Identifier\") {\n    node = parseKeywordsAndVariables(ast);\n  } else if (ast.type === \"UnaryExpression\") {\n    op = ast.operator;\n    var child = createRuntimeAst(expression, ast.argument);\n    if (unaryOperators.indexOf(op) > -1) {\n      node = new Node(ExpressionNodeType.UNARY, op, child);\n    } else {\n      throw new RuntimeError('Unexpected operator \"' + op + '\".');\n    }\n  } else if (ast.type === \"BinaryExpression\") {\n    op = ast.operator;\n    left = createRuntimeAst(expression, ast.left);\n    right = createRuntimeAst(expression, ast.right);\n    if (binaryOperators.indexOf(op) > -1) {\n      node = new Node(ExpressionNodeType.BINARY, op, left, right);\n    } else {\n      throw new RuntimeError('Unexpected operator \"' + op + '\".');\n    }\n  } else if (ast.type === \"LogicalExpression\") {\n    op = ast.operator;\n    left = createRuntimeAst(expression, ast.left);\n    right = createRuntimeAst(expression, ast.right);\n    if (binaryOperators.indexOf(op) > -1) {\n      node = new Node(ExpressionNodeType.BINARY, op, left, right);\n    }\n  } else if (ast.type === \"ConditionalExpression\") {\n    var test = createRuntimeAst(expression, ast.test);\n    left = createRuntimeAst(expression, ast.consequent);\n    right = createRuntimeAst(expression, ast.alternate);\n    node = new Node(ExpressionNodeType.CONDITIONAL, \"?\", left, right, test);\n  } else if (ast.type === \"MemberExpression\") {\n    node = parseMemberExpression(expression, ast);\n  } else if (ast.type === \"ArrayExpression\") {\n    var val = [];\n    for (var i = 0; i < ast.elements.length; i++) {\n      val[i] = createRuntimeAst(expression, ast.elements[i]);\n    }\n    node = new Node(ExpressionNodeType.ARRAY, val);\n  } else if (ast.type === \"Compound\") {\n    // empty expression or multiple expressions\n    throw new RuntimeError(\"Provide exactly one expression.\");\n  } else {\n    throw new RuntimeError(\"Cannot parse expression.\");\n  }\n\n  return node;\n}\n\nfunction setEvaluateFunction(node) {\n  if (node._type === ExpressionNodeType.CONDITIONAL) {\n    node.evaluate = node._evaluateConditional;\n  } else if (node._type === ExpressionNodeType.FUNCTION_CALL) {\n    if (node._value === \"test\") {\n      node.evaluate = node._evaluateRegExpTest;\n    } else if (node._value === \"exec\") {\n      node.evaluate = node._evaluateRegExpExec;\n    } else if (node._value === \"toString\") {\n      node.evaluate = node._evaluateToString;\n    }\n  } else if (node._type === ExpressionNodeType.UNARY) {\n    if (node._value === \"!\") {\n      node.evaluate = node._evaluateNot;\n    } else if (node._value === \"-\") {\n      node.evaluate = node._evaluateNegative;\n    } else if (node._value === \"+\") {\n      node.evaluate = node._evaluatePositive;\n    } else if (node._value === \"isNaN\") {\n      node.evaluate = node._evaluateNaN;\n    } else if (node._value === \"isFinite\") {\n      node.evaluate = node._evaluateIsFinite;\n    } else if (node._value === \"isExactClass\") {\n      node.evaluate = node._evaluateIsExactClass;\n    } else if (node._value === \"isClass\") {\n      node.evaluate = node._evaluateIsClass;\n    } else if (node._value === \"getExactClassName\") {\n      node.evaluate = node._evaluateGetExactClassName;\n    } else if (node._value === \"Boolean\") {\n      node.evaluate = node._evaluateBooleanConversion;\n    } else if (node._value === \"Number\") {\n      node.evaluate = node._evaluateNumberConversion;\n    } else if (node._value === \"String\") {\n      node.evaluate = node._evaluateStringConversion;\n    } else if (defined(unaryFunctions[node._value])) {\n      node.evaluate = getEvaluateUnaryFunction(node._value);\n    }\n  } else if (node._type === ExpressionNodeType.BINARY) {\n    if (node._value === \"+\") {\n      node.evaluate = node._evaluatePlus;\n    } else if (node._value === \"-\") {\n      node.evaluate = node._evaluateMinus;\n    } else if (node._value === \"*\") {\n      node.evaluate = node._evaluateTimes;\n    } else if (node._value === \"/\") {\n      node.evaluate = node._evaluateDivide;\n    } else if (node._value === \"%\") {\n      node.evaluate = node._evaluateMod;\n    } else if (node._value === \"===\") {\n      node.evaluate = node._evaluateEqualsStrict;\n    } else if (node._value === \"!==\") {\n      node.evaluate = node._evaluateNotEqualsStrict;\n    } else if (node._value === \"<\") {\n      node.evaluate = node._evaluateLessThan;\n    } else if (node._value === \"<=\") {\n      node.evaluate = node._evaluateLessThanOrEquals;\n    } else if (node._value === \">\") {\n      node.evaluate = node._evaluateGreaterThan;\n    } else if (node._value === \">=\") {\n      node.evaluate = node._evaluateGreaterThanOrEquals;\n    } else if (node._value === \"&&\") {\n      node.evaluate = node._evaluateAnd;\n    } else if (node._value === \"||\") {\n      node.evaluate = node._evaluateOr;\n    } else if (node._value === \"=~\") {\n      node.evaluate = node._evaluateRegExpMatch;\n    } else if (node._value === \"!~\") {\n      node.evaluate = node._evaluateRegExpNotMatch;\n    } else if (defined(binaryFunctions[node._value])) {\n      node.evaluate = getEvaluateBinaryFunction(node._value);\n    }\n  } else if (node._type === ExpressionNodeType.TERNARY) {\n    node.evaluate = getEvaluateTernaryFunction(node._value);\n  } else if (node._type === ExpressionNodeType.MEMBER) {\n    if (node._value === \"brackets\") {\n      node.evaluate = node._evaluateMemberBrackets;\n    } else {\n      node.evaluate = node._evaluateMemberDot;\n    }\n  } else if (node._type === ExpressionNodeType.ARRAY) {\n    node.evaluate = node._evaluateArray;\n  } else if (node._type === ExpressionNodeType.VARIABLE) {\n    node.evaluate = node._evaluateVariable;\n  } else if (node._type === ExpressionNodeType.VARIABLE_IN_STRING) {\n    node.evaluate = node._evaluateVariableString;\n  } else if (node._type === ExpressionNodeType.LITERAL_COLOR) {\n    node.evaluate = node._evaluateLiteralColor;\n  } else if (node._type === ExpressionNodeType.LITERAL_VECTOR) {\n    node.evaluate = node._evaluateLiteralVector;\n  } else if (node._type === ExpressionNodeType.LITERAL_STRING) {\n    node.evaluate = node._evaluateLiteralString;\n  } else if (node._type === ExpressionNodeType.REGEX) {\n    node.evaluate = node._evaluateRegExp;\n  } else if (node._type === ExpressionNodeType.BUILTIN_VARIABLE) {\n    if (node._value === \"tiles3d_tileset_time\") {\n      node.evaluate = evaluateTilesetTime;\n    }\n  } else {\n    node.evaluate = node._evaluateLiteral;\n  }\n}\n\nfunction evaluateTilesetTime(feature) {\n  if (!defined(feature)) {\n    return 0.0;\n  }\n  return feature.content.tileset.timeSinceLoad;\n}\n\nfunction getEvaluateUnaryFunction(call) {\n  var evaluate = unaryFunctions[call];\n  return function (feature) {\n    var left = this._left.evaluate(feature);\n    return evaluate(call, left);\n  };\n}\n\nfunction getEvaluateBinaryFunction(call) {\n  var evaluate = binaryFunctions[call];\n  return function (feature) {\n    var left = this._left.evaluate(feature);\n    var right = this._right.evaluate(feature);\n    return evaluate(call, left, right);\n  };\n}\n\nfunction getEvaluateTernaryFunction(call) {\n  var evaluate = ternaryFunctions[call];\n  return function (feature) {\n    var left = this._left.evaluate(feature);\n    var right = this._right.evaluate(feature);\n    var test = this._test.evaluate(feature);\n    return evaluate(call, left, right, test);\n  };\n}\n\nfunction getFeatureProperty(feature, name) {\n  // Returns undefined if the feature is not defined or the property name is not defined for that feature\n  if (defined(feature)) {\n    return feature.getProperty(name);\n  }\n}\n\nNode.prototype._evaluateLiteral = function () {\n  return this._value;\n};\n\nNode.prototype._evaluateLiteralColor = function (feature) {\n  var color = scratchColor;\n  var args = this._left;\n  if (this._value === \"color\") {\n    if (!defined(args)) {\n      Color.fromBytes(255, 255, 255, 255, color);\n    } else if (args.length > 1) {\n      Color.fromCssColorString(args[0].evaluate(feature), color);\n      color.alpha = args[1].evaluate(feature);\n    } else {\n      Color.fromCssColorString(args[0].evaluate(feature), color);\n    }\n  } else if (this._value === \"rgb\") {\n    Color.fromBytes(\n      args[0].evaluate(feature),\n      args[1].evaluate(feature),\n      args[2].evaluate(feature),\n      255,\n      color\n    );\n  } else if (this._value === \"rgba\") {\n    // convert between css alpha (0 to 1) and cesium alpha (0 to 255)\n    var a = args[3].evaluate(feature) * 255;\n    Color.fromBytes(\n      args[0].evaluate(feature),\n      args[1].evaluate(feature),\n      args[2].evaluate(feature),\n      a,\n      color\n    );\n  } else if (this._value === \"hsl\") {\n    Color.fromHsl(\n      args[0].evaluate(feature),\n      args[1].evaluate(feature),\n      args[2].evaluate(feature),\n      1.0,\n      color\n    );\n  } else if (this._value === \"hsla\") {\n    Color.fromHsl(\n      args[0].evaluate(feature),\n      args[1].evaluate(feature),\n      args[2].evaluate(feature),\n      args[3].evaluate(feature),\n      color\n    );\n  }\n  return Cartesian4.fromColor(color, scratchStorage.getCartesian4());\n};\n\nNode.prototype._evaluateLiteralVector = function (feature) {\n  // Gather the components that make up the vector, which includes components from interior vectors.\n  // For example vec3(1, 2, 3) or vec3(vec2(1, 2), 3) are both valid.\n  //\n  // If the number of components does not equal the vector's size, then a RuntimeError is thrown - with two exceptions:\n  // 1. A vector may be constructed from a larger vector and drop the extra components.\n  // 2. A vector may be constructed from a single component - vec3(1) will become vec3(1, 1, 1).\n  //\n  // Examples of invalid constructors include:\n  // vec4(1, 2)        // not enough components\n  // vec3(vec2(1, 2))  // not enough components\n  // vec3(1, 2, 3, 4)  // too many components\n  // vec2(vec4(1), 1)  // too many components\n\n  var components = scratchStorage.getArray();\n  var call = this._value;\n  var args = this._left;\n  var argsLength = args.length;\n  for (var i = 0; i < argsLength; ++i) {\n    var value = args[i].evaluate(feature);\n    if (typeof value === \"number\") {\n      components.push(value);\n    } else if (value instanceof Cartesian2) {\n      components.push(value.x, value.y);\n    } else if (value instanceof Cartesian3) {\n      components.push(value.x, value.y, value.z);\n    } else if (value instanceof Cartesian4) {\n      components.push(value.x, value.y, value.z, value.w);\n    } else {\n      throw new RuntimeError(\n        call +\n          \" argument must be a vector or number. Argument is \" +\n          value +\n          \".\"\n      );\n    }\n  }\n\n  var componentsLength = components.length;\n  var vectorLength = parseInt(call.charAt(3));\n\n  if (componentsLength === 0) {\n    throw new RuntimeError(\n      \"Invalid \" + call + \" constructor. No valid arguments.\"\n    );\n  } else if (componentsLength < vectorLength && componentsLength > 1) {\n    throw new RuntimeError(\n      \"Invalid \" + call + \" constructor. Not enough arguments.\"\n    );\n  } else if (componentsLength > vectorLength && argsLength > 1) {\n    throw new RuntimeError(\n      \"Invalid \" + call + \" constructor. Too many arguments.\"\n    );\n  }\n\n  if (componentsLength === 1) {\n    // Add the same component 3 more times\n    var component = components[0];\n    components.push(component, component, component);\n  }\n\n  if (call === \"vec2\") {\n    return Cartesian2.fromArray(components, 0, scratchStorage.getCartesian2());\n  } else if (call === \"vec3\") {\n    return Cartesian3.fromArray(components, 0, scratchStorage.getCartesian3());\n  } else if (call === \"vec4\") {\n    return Cartesian4.fromArray(components, 0, scratchStorage.getCartesian4());\n  }\n};\n\nNode.prototype._evaluateLiteralString = function () {\n  return this._value;\n};\n\nNode.prototype._evaluateVariableString = function (feature) {\n  var result = this._value;\n  var match = variableRegex.exec(result);\n  while (match !== null) {\n    var placeholder = match[0];\n    var variableName = match[1];\n    var property = getFeatureProperty(feature, variableName);\n    if (!defined(property)) {\n      property = \"\";\n    }\n    result = result.replace(placeholder, property);\n    match = variableRegex.exec(result);\n  }\n  return result;\n};\n\nNode.prototype._evaluateVariable = function (feature) {\n  // evaluates to undefined if the property name is not defined for that feature\n  return getFeatureProperty(feature, this._value);\n};\n\nfunction checkFeature(ast) {\n  return ast._value === \"feature\";\n}\n\n// PERFORMANCE_IDEA: Determine if parent property needs to be computed before runtime\nNode.prototype._evaluateMemberDot = function (feature) {\n  if (checkFeature(this._left)) {\n    return getFeatureProperty(feature, this._right.evaluate(feature));\n  }\n  var property = this._left.evaluate(feature);\n  if (!defined(property)) {\n    return undefined;\n  }\n\n  var member = this._right.evaluate(feature);\n  if (\n    property instanceof Cartesian2 ||\n    property instanceof Cartesian3 ||\n    property instanceof Cartesian4\n  ) {\n    // Vector components may be accessed with .r, .g, .b, .a and implicitly with .x, .y, .z, .w\n    if (member === \"r\") {\n      return property.x;\n    } else if (member === \"g\") {\n      return property.y;\n    } else if (member === \"b\") {\n      return property.z;\n    } else if (member === \"a\") {\n      return property.w;\n    }\n  }\n  return property[member];\n};\n\nNode.prototype._evaluateMemberBrackets = function (feature) {\n  if (checkFeature(this._left)) {\n    return getFeatureProperty(feature, this._right.evaluate(feature));\n  }\n  var property = this._left.evaluate(feature);\n  if (!defined(property)) {\n    return undefined;\n  }\n\n  var member = this._right.evaluate(feature);\n  if (\n    property instanceof Cartesian2 ||\n    property instanceof Cartesian3 ||\n    property instanceof Cartesian4\n  ) {\n    // Vector components may be accessed with [0][1][2][3], ['r']['g']['b']['a'] and implicitly with ['x']['y']['z']['w']\n    // For Cartesian2 and Cartesian3 out-of-range components will just return undefined\n    if (member === 0 || member === \"r\") {\n      return property.x;\n    } else if (member === 1 || member === \"g\") {\n      return property.y;\n    } else if (member === 2 || member === \"b\") {\n      return property.z;\n    } else if (member === 3 || member === \"a\") {\n      return property.w;\n    }\n  }\n  return property[member];\n};\n\nNode.prototype._evaluateArray = function (feature) {\n  var array = [];\n  for (var i = 0; i < this._value.length; i++) {\n    array[i] = this._value[i].evaluate(feature);\n  }\n  return array;\n};\n\n// PERFORMANCE_IDEA: Have \"fast path\" functions that deal only with specific types\n// that we can assign if we know the types before runtime\n\nNode.prototype._evaluateNot = function (feature) {\n  var left = this._left.evaluate(feature);\n  if (typeof left !== \"boolean\") {\n    throw new RuntimeError(\n      'Operator \"!\" requires a boolean argument. Argument is ' + left + \".\"\n    );\n  }\n  return !left;\n};\n\nNode.prototype._evaluateNegative = function (feature) {\n  var left = this._left.evaluate(feature);\n  if (left instanceof Cartesian2) {\n    return Cartesian2.negate(left, scratchStorage.getCartesian2());\n  } else if (left instanceof Cartesian3) {\n    return Cartesian3.negate(left, scratchStorage.getCartesian3());\n  } else if (left instanceof Cartesian4) {\n    return Cartesian4.negate(left, scratchStorage.getCartesian4());\n  } else if (typeof left === \"number\") {\n    return -left;\n  }\n\n  throw new RuntimeError(\n    'Operator \"-\" requires a vector or number argument. Argument is ' +\n      left +\n      \".\"\n  );\n};\n\nNode.prototype._evaluatePositive = function (feature) {\n  var left = this._left.evaluate(feature);\n\n  if (\n    !(\n      left instanceof Cartesian2 ||\n      left instanceof Cartesian3 ||\n      left instanceof Cartesian4 ||\n      typeof left === \"number\"\n    )\n  ) {\n    throw new RuntimeError(\n      'Operator \"+\" requires a vector or number argument. Argument is ' +\n        left +\n        \".\"\n    );\n  }\n\n  return left;\n};\n\nNode.prototype._evaluateLessThan = function (feature) {\n  var left = this._left.evaluate(feature);\n  var right = this._right.evaluate(feature);\n\n  if (typeof left !== \"number\" || typeof right !== \"number\") {\n    throw new RuntimeError(\n      'Operator \"<\" requires number arguments. Arguments are ' +\n        left +\n        \" and \" +\n        right +\n        \".\"\n    );\n  }\n\n  return left < right;\n};\n\nNode.prototype._evaluateLessThanOrEquals = function (feature) {\n  var left = this._left.evaluate(feature);\n  var right = this._right.evaluate(feature);\n\n  if (typeof left !== \"number\" || typeof right !== \"number\") {\n    throw new RuntimeError(\n      'Operator \"<=\" requires number arguments. Arguments are ' +\n        left +\n        \" and \" +\n        right +\n        \".\"\n    );\n  }\n\n  return left <= right;\n};\n\nNode.prototype._evaluateGreaterThan = function (feature) {\n  var left = this._left.evaluate(feature);\n  var right = this._right.evaluate(feature);\n\n  if (typeof left !== \"number\" || typeof right !== \"number\") {\n    throw new RuntimeError(\n      'Operator \">\" requires number arguments. Arguments are ' +\n        left +\n        \" and \" +\n        right +\n        \".\"\n    );\n  }\n\n  return left > right;\n};\n\nNode.prototype._evaluateGreaterThanOrEquals = function (feature) {\n  var left = this._left.evaluate(feature);\n  var right = this._right.evaluate(feature);\n\n  if (typeof left !== \"number\" || typeof right !== \"number\") {\n    throw new RuntimeError(\n      'Operator \">=\" requires number arguments. Arguments are ' +\n        left +\n        \" and \" +\n        right +\n        \".\"\n    );\n  }\n\n  return left >= right;\n};\n\nNode.prototype._evaluateOr = function (feature) {\n  var left = this._left.evaluate(feature);\n  if (typeof left !== \"boolean\") {\n    throw new RuntimeError(\n      'Operator \"||\" requires boolean arguments. First argument is ' +\n        left +\n        \".\"\n    );\n  }\n\n  // short circuit the expression\n  if (left) {\n    return true;\n  }\n\n  var right = this._right.evaluate(feature);\n  if (typeof right !== \"boolean\") {\n    throw new RuntimeError(\n      'Operator \"||\" requires boolean arguments. Second argument is ' +\n        right +\n        \".\"\n    );\n  }\n\n  return left || right;\n};\n\nNode.prototype._evaluateAnd = function (feature) {\n  var left = this._left.evaluate(feature);\n  if (typeof left !== \"boolean\") {\n    throw new RuntimeError(\n      'Operator \"&&\" requires boolean arguments. First argument is ' +\n        left +\n        \".\"\n    );\n  }\n\n  // short circuit the expression\n  if (!left) {\n    return false;\n  }\n\n  var right = this._right.evaluate(feature);\n  if (typeof right !== \"boolean\") {\n    throw new RuntimeError(\n      'Operator \"&&\" requires boolean arguments. Second argument is ' +\n        right +\n        \".\"\n    );\n  }\n\n  return left && right;\n};\n\nNode.prototype._evaluatePlus = function (feature) {\n  var left = this._left.evaluate(feature);\n  var right = this._right.evaluate(feature);\n  if (right instanceof Cartesian2 && left instanceof Cartesian2) {\n    return Cartesian2.add(left, right, scratchStorage.getCartesian2());\n  } else if (right instanceof Cartesian3 && left instanceof Cartesian3) {\n    return Cartesian3.add(left, right, scratchStorage.getCartesian3());\n  } else if (right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return Cartesian4.add(left, right, scratchStorage.getCartesian4());\n  } else if (typeof left === \"string\" || typeof right === \"string\") {\n    // If only one argument is a string the other argument calls its toString function.\n    return left + right;\n  } else if (typeof left === \"number\" && typeof right === \"number\") {\n    return left + right;\n  }\n\n  throw new RuntimeError(\n    'Operator \"+\" requires vector or number arguments of matching types, or at least one string argument. Arguments are ' +\n      left +\n      \" and \" +\n      right +\n      \".\"\n  );\n};\n\nNode.prototype._evaluateMinus = function (feature) {\n  var left = this._left.evaluate(feature);\n  var right = this._right.evaluate(feature);\n  if (right instanceof Cartesian2 && left instanceof Cartesian2) {\n    return Cartesian2.subtract(left, right, scratchStorage.getCartesian2());\n  } else if (right instanceof Cartesian3 && left instanceof Cartesian3) {\n    return Cartesian3.subtract(left, right, scratchStorage.getCartesian3());\n  } else if (right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return Cartesian4.subtract(left, right, scratchStorage.getCartesian4());\n  } else if (typeof left === \"number\" && typeof right === \"number\") {\n    return left - right;\n  }\n\n  throw new RuntimeError(\n    'Operator \"-\" requires vector or number arguments of matching types. Arguments are ' +\n      left +\n      \" and \" +\n      right +\n      \".\"\n  );\n};\n\nNode.prototype._evaluateTimes = function (feature) {\n  var left = this._left.evaluate(feature);\n  var right = this._right.evaluate(feature);\n  if (right instanceof Cartesian2 && left instanceof Cartesian2) {\n    return Cartesian2.multiplyComponents(\n      left,\n      right,\n      scratchStorage.getCartesian2()\n    );\n  } else if (right instanceof Cartesian2 && typeof left === \"number\") {\n    return Cartesian2.multiplyByScalar(\n      right,\n      left,\n      scratchStorage.getCartesian2()\n    );\n  } else if (left instanceof Cartesian2 && typeof right === \"number\") {\n    return Cartesian2.multiplyByScalar(\n      left,\n      right,\n      scratchStorage.getCartesian2()\n    );\n  } else if (right instanceof Cartesian3 && left instanceof Cartesian3) {\n    return Cartesian3.multiplyComponents(\n      left,\n      right,\n      scratchStorage.getCartesian3()\n    );\n  } else if (right instanceof Cartesian3 && typeof left === \"number\") {\n    return Cartesian3.multiplyByScalar(\n      right,\n      left,\n      scratchStorage.getCartesian3()\n    );\n  } else if (left instanceof Cartesian3 && typeof right === \"number\") {\n    return Cartesian3.multiplyByScalar(\n      left,\n      right,\n      scratchStorage.getCartesian3()\n    );\n  } else if (right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return Cartesian4.multiplyComponents(\n      left,\n      right,\n      scratchStorage.getCartesian4()\n    );\n  } else if (right instanceof Cartesian4 && typeof left === \"number\") {\n    return Cartesian4.multiplyByScalar(\n      right,\n      left,\n      scratchStorage.getCartesian4()\n    );\n  } else if (left instanceof Cartesian4 && typeof right === \"number\") {\n    return Cartesian4.multiplyByScalar(\n      left,\n      right,\n      scratchStorage.getCartesian4()\n    );\n  } else if (typeof left === \"number\" && typeof right === \"number\") {\n    return left * right;\n  }\n\n  throw new RuntimeError(\n    'Operator \"*\" requires vector or number arguments. If both arguments are vectors they must be matching types. Arguments are ' +\n      left +\n      \" and \" +\n      right +\n      \".\"\n  );\n};\n\nNode.prototype._evaluateDivide = function (feature) {\n  var left = this._left.evaluate(feature);\n  var right = this._right.evaluate(feature);\n  if (right instanceof Cartesian2 && left instanceof Cartesian2) {\n    return Cartesian2.divideComponents(\n      left,\n      right,\n      scratchStorage.getCartesian2()\n    );\n  } else if (left instanceof Cartesian2 && typeof right === \"number\") {\n    return Cartesian2.divideByScalar(\n      left,\n      right,\n      scratchStorage.getCartesian2()\n    );\n  } else if (right instanceof Cartesian3 && left instanceof Cartesian3) {\n    return Cartesian3.divideComponents(\n      left,\n      right,\n      scratchStorage.getCartesian3()\n    );\n  } else if (left instanceof Cartesian3 && typeof right === \"number\") {\n    return Cartesian3.divideByScalar(\n      left,\n      right,\n      scratchStorage.getCartesian3()\n    );\n  } else if (right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return Cartesian4.divideComponents(\n      left,\n      right,\n      scratchStorage.getCartesian4()\n    );\n  } else if (left instanceof Cartesian4 && typeof right === \"number\") {\n    return Cartesian4.divideByScalar(\n      left,\n      right,\n      scratchStorage.getCartesian4()\n    );\n  } else if (typeof left === \"number\" && typeof right === \"number\") {\n    return left / right;\n  }\n\n  throw new RuntimeError(\n    'Operator \"/\" requires vector or number arguments of matching types, or a number as the second argument. Arguments are ' +\n      left +\n      \" and \" +\n      right +\n      \".\"\n  );\n};\n\nNode.prototype._evaluateMod = function (feature) {\n  var left = this._left.evaluate(feature);\n  var right = this._right.evaluate(feature);\n  if (right instanceof Cartesian2 && left instanceof Cartesian2) {\n    return Cartesian2.fromElements(\n      left.x % right.x,\n      left.y % right.y,\n      scratchStorage.getCartesian2()\n    );\n  } else if (right instanceof Cartesian3 && left instanceof Cartesian3) {\n    return Cartesian3.fromElements(\n      left.x % right.x,\n      left.y % right.y,\n      left.z % right.z,\n      scratchStorage.getCartesian3()\n    );\n  } else if (right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return Cartesian4.fromElements(\n      left.x % right.x,\n      left.y % right.y,\n      left.z % right.z,\n      left.w % right.w,\n      scratchStorage.getCartesian4()\n    );\n  } else if (typeof left === \"number\" && typeof right === \"number\") {\n    return left % right;\n  }\n\n  throw new RuntimeError(\n    'Operator \"%\" requires vector or number arguments of matching types. Arguments are ' +\n      left +\n      \" and \" +\n      right +\n      \".\"\n  );\n};\n\nNode.prototype._evaluateEqualsStrict = function (feature) {\n  var left = this._left.evaluate(feature);\n  var right = this._right.evaluate(feature);\n  if (\n    (right instanceof Cartesian2 && left instanceof Cartesian2) ||\n    (right instanceof Cartesian3 && left instanceof Cartesian3) ||\n    (right instanceof Cartesian4 && left instanceof Cartesian4)\n  ) {\n    return left.equals(right);\n  }\n  return left === right;\n};\n\nNode.prototype._evaluateNotEqualsStrict = function (feature) {\n  var left = this._left.evaluate(feature);\n  var right = this._right.evaluate(feature);\n  if (\n    (right instanceof Cartesian2 && left instanceof Cartesian2) ||\n    (right instanceof Cartesian3 && left instanceof Cartesian3) ||\n    (right instanceof Cartesian4 && left instanceof Cartesian4)\n  ) {\n    return !left.equals(right);\n  }\n  return left !== right;\n};\n\nNode.prototype._evaluateConditional = function (feature) {\n  var test = this._test.evaluate(feature);\n\n  if (typeof test !== \"boolean\") {\n    throw new RuntimeError(\n      \"Conditional argument of conditional expression must be a boolean. Argument is \" +\n        test +\n        \".\"\n    );\n  }\n\n  if (test) {\n    return this._left.evaluate(feature);\n  }\n  return this._right.evaluate(feature);\n};\n\nNode.prototype._evaluateNaN = function (feature) {\n  return isNaN(this._left.evaluate(feature));\n};\n\nNode.prototype._evaluateIsFinite = function (feature) {\n  return isFinite(this._left.evaluate(feature));\n};\n\nNode.prototype._evaluateIsExactClass = function (feature) {\n  if (defined(feature)) {\n    return feature.isExactClass(this._left.evaluate(feature));\n  }\n  return false;\n};\n\nNode.prototype._evaluateIsClass = function (feature) {\n  if (defined(feature)) {\n    return feature.isClass(this._left.evaluate(feature));\n  }\n  return false;\n};\n\nNode.prototype._evaluateGetExactClassName = function (feature) {\n  if (defined(feature)) {\n    return feature.getExactClassName();\n  }\n};\n\nNode.prototype._evaluateBooleanConversion = function (feature) {\n  return Boolean(this._left.evaluate(feature));\n};\n\nNode.prototype._evaluateNumberConversion = function (feature) {\n  return Number(this._left.evaluate(feature));\n};\n\nNode.prototype._evaluateStringConversion = function (feature) {\n  return String(this._left.evaluate(feature));\n};\n\nNode.prototype._evaluateRegExp = function (feature) {\n  var pattern = this._value.evaluate(feature);\n  var flags = \"\";\n\n  if (defined(this._left)) {\n    flags = this._left.evaluate(feature);\n  }\n\n  var exp;\n  try {\n    exp = new RegExp(pattern, flags);\n  } catch (e) {\n    throw new RuntimeError(e);\n  }\n  return exp;\n};\n\nNode.prototype._evaluateRegExpTest = function (feature) {\n  var left = this._left.evaluate(feature);\n  var right = this._right.evaluate(feature);\n\n  if (!(left instanceof RegExp && typeof right === \"string\")) {\n    throw new RuntimeError(\n      \"RegExp.test requires the first argument to be a RegExp and the second argument to be a string. Arguments are \" +\n        left +\n        \" and \" +\n        right +\n        \".\"\n    );\n  }\n\n  return left.test(right);\n};\n\nNode.prototype._evaluateRegExpMatch = function (feature) {\n  var left = this._left.evaluate(feature);\n  var right = this._right.evaluate(feature);\n\n  if (left instanceof RegExp && typeof right === \"string\") {\n    return left.test(right);\n  } else if (right instanceof RegExp && typeof left === \"string\") {\n    return right.test(left);\n  }\n\n  throw new RuntimeError(\n    'Operator \"=~\" requires one RegExp argument and one string argument. Arguments are ' +\n      left +\n      \" and \" +\n      right +\n      \".\"\n  );\n};\n\nNode.prototype._evaluateRegExpNotMatch = function (feature) {\n  var left = this._left.evaluate(feature);\n  var right = this._right.evaluate(feature);\n\n  if (left instanceof RegExp && typeof right === \"string\") {\n    return !left.test(right);\n  } else if (right instanceof RegExp && typeof left === \"string\") {\n    return !right.test(left);\n  }\n\n  throw new RuntimeError(\n    'Operator \"!~\" requires one RegExp argument and one string argument. Arguments are ' +\n      left +\n      \" and \" +\n      right +\n      \".\"\n  );\n};\n\nNode.prototype._evaluateRegExpExec = function (feature) {\n  var left = this._left.evaluate(feature);\n  var right = this._right.evaluate(feature);\n\n  if (!(left instanceof RegExp && typeof right === \"string\")) {\n    throw new RuntimeError(\n      \"RegExp.exec requires the first argument to be a RegExp and the second argument to be a string. Arguments are \" +\n        left +\n        \" and \" +\n        right +\n        \".\"\n    );\n  }\n\n  var exec = left.exec(right);\n  if (!defined(exec)) {\n    return null;\n  }\n  return exec[1];\n};\n\nNode.prototype._evaluateToString = function (feature) {\n  var left = this._left.evaluate(feature);\n  if (\n    left instanceof RegExp ||\n    left instanceof Cartesian2 ||\n    left instanceof Cartesian3 ||\n    left instanceof Cartesian4\n  ) {\n    return String(left);\n  }\n\n  throw new RuntimeError('Unexpected function call \"' + this._value + '\".');\n};\n\nfunction convertHSLToRGB(ast) {\n  // Check if the color contains any nested expressions to see if the color can be converted here.\n  // E.g. \"hsl(0.9, 0.6, 0.7)\" is able to convert directly to rgb, \"hsl(0.9, 0.6, ${Height})\" is not.\n  var channels = ast._left;\n  var length = channels.length;\n  for (var i = 0; i < length; ++i) {\n    if (channels[i]._type !== ExpressionNodeType.LITERAL_NUMBER) {\n      return undefined;\n    }\n  }\n  var h = channels[0]._value;\n  var s = channels[1]._value;\n  var l = channels[2]._value;\n  var a = length === 4 ? channels[3]._value : 1.0;\n  return Color.fromHsl(h, s, l, a, scratchColor);\n}\n\nfunction convertRGBToColor(ast) {\n  // Check if the color contains any nested expressions to see if the color can be converted here.\n  // E.g. \"rgb(255, 255, 255)\" is able to convert directly to Color, \"rgb(255, 255, ${Height})\" is not.\n  var channels = ast._left;\n  var length = channels.length;\n  for (var i = 0; i < length; ++i) {\n    if (channels[i]._type !== ExpressionNodeType.LITERAL_NUMBER) {\n      return undefined;\n    }\n  }\n  var color = scratchColor;\n  color.red = channels[0]._value / 255.0;\n  color.green = channels[1]._value / 255.0;\n  color.blue = channels[2]._value / 255.0;\n  color.alpha = length === 4 ? channels[3]._value : 1.0;\n  return color;\n}\n\nfunction numberToString(number) {\n  if (number % 1 === 0) {\n    // Add a .0 to whole numbers\n    return number.toFixed(1);\n  }\n\n  return number.toString();\n}\n\nfunction colorToVec3(color) {\n  var r = numberToString(color.red);\n  var g = numberToString(color.green);\n  var b = numberToString(color.blue);\n  return \"vec3(\" + r + \", \" + g + \", \" + b + \")\";\n}\n\nfunction colorToVec4(color) {\n  var r = numberToString(color.red);\n  var g = numberToString(color.green);\n  var b = numberToString(color.blue);\n  var a = numberToString(color.alpha);\n  return \"vec4(\" + r + \", \" + g + \", \" + b + \", \" + a + \")\";\n}\n\nfunction getExpressionArray(array, attributePrefix, shaderState, parent) {\n  var length = array.length;\n  var expressions = new Array(length);\n  for (var i = 0; i < length; ++i) {\n    expressions[i] = array[i].getShaderExpression(\n      attributePrefix,\n      shaderState,\n      parent\n    );\n  }\n  return expressions;\n}\n\nvar nullSentinel = \"czm_infinity\"; // null just needs to be some sentinel value that will cause \"[expression] === null\" to be false in nearly all cases. GLSL doesn't have a NaN constant so use czm_infinity.\n\nNode.prototype.getShaderExpression = function (\n  attributePrefix,\n  shaderState,\n  parent\n) {\n  var color;\n  var left;\n  var right;\n  var test;\n\n  var type = this._type;\n  var value = this._value;\n\n  if (defined(this._left)) {\n    if (Array.isArray(this._left)) {\n      // Left can be an array if the type is LITERAL_COLOR or LITERAL_VECTOR\n      left = getExpressionArray(this._left, attributePrefix, shaderState, this);\n    } else {\n      left = this._left.getShaderExpression(attributePrefix, shaderState, this);\n    }\n  }\n\n  if (defined(this._right)) {\n    right = this._right.getShaderExpression(attributePrefix, shaderState, this);\n  }\n\n  if (defined(this._test)) {\n    test = this._test.getShaderExpression(attributePrefix, shaderState, this);\n  }\n\n  if (Array.isArray(this._value)) {\n    // For ARRAY type\n    value = getExpressionArray(this._value, attributePrefix, shaderState, this);\n  }\n\n  switch (type) {\n    case ExpressionNodeType.VARIABLE:\n      return attributePrefix + value;\n    case ExpressionNodeType.UNARY:\n      // Supported types: +, -, !, Boolean, Number\n      if (value === \"Boolean\") {\n        return \"bool(\" + left + \")\";\n      } else if (value === \"Number\") {\n        return \"float(\" + left + \")\";\n      } else if (value === \"round\") {\n        return \"floor(\" + left + \" + 0.5)\";\n      } else if (defined(unaryFunctions[value])) {\n        return value + \"(\" + left + \")\";\n      } else if (value === \"isNaN\") {\n        // In GLSL 2.0 use isnan instead\n        return \"(\" + left + \" != \" + left + \")\";\n      } else if (value === \"isFinite\") {\n        // In GLSL 2.0 use isinf instead. GLSL doesn't have an infinity constant so use czm_infinity which is an arbitrarily big enough number.\n        return \"(abs(\" + left + \") < czm_infinity)\";\n      } else if (\n        value === \"String\" ||\n        value === \"isExactClass\" ||\n        value === \"isClass\" ||\n        value === \"getExactClassName\"\n      ) {\n        throw new RuntimeError(\n          'Error generating style shader: \"' + value + '\" is not supported.'\n        );\n      } else if (defined(unaryFunctions[value])) {\n        return value + \"(\" + left + \")\";\n      }\n      return value + left;\n    case ExpressionNodeType.BINARY:\n      // Supported types: ||, &&, ===, !==, <, >, <=, >=, +, -, *, /, %\n      if (value === \"%\") {\n        return \"mod(\" + left + \", \" + right + \")\";\n      } else if (value === \"===\") {\n        return \"(\" + left + \" == \" + right + \")\";\n      } else if (value === \"!==\") {\n        return \"(\" + left + \" != \" + right + \")\";\n      } else if (value === \"atan2\") {\n        return \"atan(\" + left + \", \" + right + \")\";\n      } else if (defined(binaryFunctions[value])) {\n        return value + \"(\" + left + \", \" + right + \")\";\n      }\n      return \"(\" + left + \" \" + value + \" \" + right + \")\";\n    case ExpressionNodeType.TERNARY:\n      if (defined(ternaryFunctions[value])) {\n        return value + \"(\" + left + \", \" + right + \", \" + test + \")\";\n      }\n      break;\n    case ExpressionNodeType.CONDITIONAL:\n      return \"(\" + test + \" ? \" + left + \" : \" + right + \")\";\n    case ExpressionNodeType.MEMBER:\n      // This is intended for accessing the components of vector properties. String members aren't supported.\n      // Check for 0.0 rather than 0 because all numbers are previously converted to decimals.\n      if (right === \"r\" || right === \"x\" || right === \"0.0\") {\n        return left + \"[0]\";\n      } else if (right === \"g\" || right === \"y\" || right === \"1.0\") {\n        return left + \"[1]\";\n      } else if (right === \"b\" || right === \"z\" || right === \"2.0\") {\n        return left + \"[2]\";\n      } else if (right === \"a\" || right === \"w\" || right === \"3.0\") {\n        return left + \"[3]\";\n      }\n      return left + \"[int(\" + right + \")]\";\n    case ExpressionNodeType.FUNCTION_CALL:\n      throw new RuntimeError(\n        'Error generating style shader: \"' + value + '\" is not supported.'\n      );\n    case ExpressionNodeType.ARRAY:\n      if (value.length === 4) {\n        return (\n          \"vec4(\" +\n          value[0] +\n          \", \" +\n          value[1] +\n          \", \" +\n          value[2] +\n          \", \" +\n          value[3] +\n          \")\"\n        );\n      } else if (value.length === 3) {\n        return \"vec3(\" + value[0] + \", \" + value[1] + \", \" + value[2] + \")\";\n      } else if (value.length === 2) {\n        return \"vec2(\" + value[0] + \", \" + value[1] + \")\";\n      }\n      throw new RuntimeError(\n        \"Error generating style shader: Invalid array length. Array length should be 2, 3, or 4.\"\n      );\n    case ExpressionNodeType.REGEX:\n      throw new RuntimeError(\n        \"Error generating style shader: Regular expressions are not supported.\"\n      );\n    case ExpressionNodeType.VARIABLE_IN_STRING:\n      throw new RuntimeError(\n        \"Error generating style shader: Converting a variable to a string is not supported.\"\n      );\n    case ExpressionNodeType.LITERAL_NULL:\n      return nullSentinel;\n    case ExpressionNodeType.LITERAL_BOOLEAN:\n      return value ? \"true\" : \"false\";\n    case ExpressionNodeType.LITERAL_NUMBER:\n      return numberToString(value);\n    case ExpressionNodeType.LITERAL_STRING:\n      if (defined(parent) && parent._type === ExpressionNodeType.MEMBER) {\n        if (\n          value === \"r\" ||\n          value === \"g\" ||\n          value === \"b\" ||\n          value === \"a\" ||\n          value === \"x\" ||\n          value === \"y\" ||\n          value === \"z\" ||\n          value === \"w\"\n        ) {\n          return value;\n        }\n      }\n      // Check for css color strings\n      color = Color.fromCssColorString(value, scratchColor);\n      if (defined(color)) {\n        return colorToVec3(color);\n      }\n      throw new RuntimeError(\n        \"Error generating style shader: String literals are not supported.\"\n      );\n    case ExpressionNodeType.LITERAL_COLOR:\n      var args = left;\n      if (value === \"color\") {\n        if (!defined(args)) {\n          return \"vec4(1.0)\";\n        } else if (args.length > 1) {\n          var rgb = args[0];\n          var alpha = args[1];\n          if (alpha !== \"1.0\") {\n            shaderState.translucent = true;\n          }\n          return \"vec4(\" + rgb + \", \" + alpha + \")\";\n        }\n        return \"vec4(\" + args[0] + \", 1.0)\";\n      } else if (value === \"rgb\") {\n        color = convertRGBToColor(this);\n        if (defined(color)) {\n          return colorToVec4(color);\n        }\n        return (\n          \"vec4(\" +\n          args[0] +\n          \" / 255.0, \" +\n          args[1] +\n          \" / 255.0, \" +\n          args[2] +\n          \" / 255.0, 1.0)\"\n        );\n      } else if (value === \"rgba\") {\n        if (args[3] !== \"1.0\") {\n          shaderState.translucent = true;\n        }\n        color = convertRGBToColor(this);\n        if (defined(color)) {\n          return colorToVec4(color);\n        }\n        return (\n          \"vec4(\" +\n          args[0] +\n          \" / 255.0, \" +\n          args[1] +\n          \" / 255.0, \" +\n          args[2] +\n          \" / 255.0, \" +\n          args[3] +\n          \")\"\n        );\n      } else if (value === \"hsl\") {\n        color = convertHSLToRGB(this);\n        if (defined(color)) {\n          return colorToVec4(color);\n        }\n        return (\n          \"vec4(czm_HSLToRGB(vec3(\" +\n          args[0] +\n          \", \" +\n          args[1] +\n          \", \" +\n          args[2] +\n          \")), 1.0)\"\n        );\n      } else if (value === \"hsla\") {\n        color = convertHSLToRGB(this);\n        if (defined(color)) {\n          if (color.alpha !== 1.0) {\n            shaderState.translucent = true;\n          }\n          return colorToVec4(color);\n        }\n        if (args[3] !== \"1.0\") {\n          shaderState.translucent = true;\n        }\n        return (\n          \"vec4(czm_HSLToRGB(vec3(\" +\n          args[0] +\n          \", \" +\n          args[1] +\n          \", \" +\n          args[2] +\n          \")), \" +\n          args[3] +\n          \")\"\n        );\n      }\n      break;\n    case ExpressionNodeType.LITERAL_VECTOR:\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(left)) {\n        throw new DeveloperError(\n          \"left should always be defined for type ExpressionNodeType.LITERAL_VECTOR\"\n        );\n      }\n      //>>includeEnd('debug');\n      var length = left.length;\n      var vectorExpression = value + \"(\";\n      for (var i = 0; i < length; ++i) {\n        vectorExpression += left[i];\n        if (i < length - 1) {\n          vectorExpression += \", \";\n        }\n      }\n      vectorExpression += \")\";\n      return vectorExpression;\n    case ExpressionNodeType.LITERAL_REGEX:\n      throw new RuntimeError(\n        \"Error generating style shader: Regular expressions are not supported.\"\n      );\n    case ExpressionNodeType.LITERAL_UNDEFINED:\n      return nullSentinel;\n    case ExpressionNodeType.BUILTIN_VARIABLE:\n      if (value === \"tiles3d_tileset_time\") {\n        return \"u_time\";\n      }\n  }\n};\nexport default Expression;\n"]},"metadata":{},"sourceType":"module"}