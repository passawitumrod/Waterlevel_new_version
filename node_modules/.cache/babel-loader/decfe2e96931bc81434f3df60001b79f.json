{"ast":null,"code":"import when from \"../ThirdParty/when.js\";\nimport binarySearch from \"./binarySearch.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport EarthOrientationParametersSample from \"./EarthOrientationParametersSample.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport LeapSecond from \"./LeapSecond.js\";\nimport Resource from \"./Resource.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nimport TimeConstants from \"./TimeConstants.js\";\nimport TimeStandard from \"./TimeStandard.js\";\n/**\n * Specifies Earth polar motion coordinates and the difference between UT1 and UTC.\n * These Earth Orientation Parameters (EOP) are primarily used in the transformation from\n * the International Celestial Reference Frame (ICRF) to the International Terrestrial\n * Reference Frame (ITRF).\n *\n * @alias EarthOrientationParameters\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Resource|String} [options.url] The URL from which to obtain EOP data.  If neither this\n *                 parameter nor options.data is specified, all EOP values are assumed\n *                 to be 0.0.  If options.data is specified, this parameter is\n *                 ignored.\n * @param {Object} [options.data] The actual EOP data.  If neither this\n *                 parameter nor options.data is specified, all EOP values are assumed\n *                 to be 0.0.\n * @param {Boolean} [options.addNewLeapSeconds=true] True if leap seconds that\n *                  are specified in the EOP data but not in {@link JulianDate.leapSeconds}\n *                  should be added to {@link JulianDate.leapSeconds}.  False if\n *                  new leap seconds should be handled correctly in the context\n *                  of the EOP data but otherwise ignored.\n *\n * @example\n * // An example EOP data file, EOP.json:\n * {\n *   \"columnNames\" : [\"dateIso8601\",\"modifiedJulianDateUtc\",\"xPoleWanderRadians\",\"yPoleWanderRadians\",\"ut1MinusUtcSeconds\",\"lengthOfDayCorrectionSeconds\",\"xCelestialPoleOffsetRadians\",\"yCelestialPoleOffsetRadians\",\"taiMinusUtcSeconds\"],\n *   \"samples\" : [\n *      \"2011-07-01T00:00:00Z\",55743.0,2.117957047295119e-7,2.111518721609984e-6,-0.2908948,-2.956e-4,3.393695767766752e-11,3.3452143996557983e-10,34.0,\n *      \"2011-07-02T00:00:00Z\",55744.0,2.193297093339541e-7,2.115460256837405e-6,-0.29065,-1.824e-4,-8.241832578862112e-11,5.623838700870617e-10,34.0,\n *      \"2011-07-03T00:00:00Z\",55745.0,2.262286080161428e-7,2.1191157519929706e-6,-0.2905572,1.9e-6,-3.490658503988659e-10,6.981317007977318e-10,34.0\n *   ]\n * }\n *\n * @example\n * // Loading the EOP data\n * var eop = new Cesium.EarthOrientationParameters({ url : 'Data/EOP.json' });\n * Cesium.Transforms.earthOrientationParameters = eop;\n *\n * @private\n */\n\nfunction EarthOrientationParameters(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  this._dates = undefined;\n  this._samples = undefined;\n  this._dateColumn = -1;\n  this._xPoleWanderRadiansColumn = -1;\n  this._yPoleWanderRadiansColumn = -1;\n  this._ut1MinusUtcSecondsColumn = -1;\n  this._xCelestialPoleOffsetRadiansColumn = -1;\n  this._yCelestialPoleOffsetRadiansColumn = -1;\n  this._taiMinusUtcSecondsColumn = -1;\n  this._columnCount = 0;\n  this._lastIndex = -1;\n  this._downloadPromise = undefined;\n  this._dataError = undefined;\n  this._addNewLeapSeconds = defaultValue(options.addNewLeapSeconds, true);\n\n  if (defined(options.data)) {\n    // Use supplied EOP data.\n    onDataReady(this, options.data);\n  } else if (defined(options.url)) {\n    var resource = Resource.createIfNeeded(options.url); // Download EOP data.\n\n    var that = this;\n    this._downloadPromise = resource.fetchJson().then(function (eopData) {\n      onDataReady(that, eopData);\n    }).otherwise(function () {\n      that._dataError = \"An error occurred while retrieving the EOP data from the URL \" + resource.url + \".\";\n    });\n  } else {\n    // Use all zeros for EOP data.\n    onDataReady(this, {\n      columnNames: [\"dateIso8601\", \"modifiedJulianDateUtc\", \"xPoleWanderRadians\", \"yPoleWanderRadians\", \"ut1MinusUtcSeconds\", \"lengthOfDayCorrectionSeconds\", \"xCelestialPoleOffsetRadians\", \"yCelestialPoleOffsetRadians\", \"taiMinusUtcSeconds\"],\n      samples: []\n    });\n  }\n}\n/**\n * A default {@link EarthOrientationParameters} instance that returns zero for all EOP values.\n */\n\n\nEarthOrientationParameters.NONE = Object.freeze({\n  getPromiseToLoad: function () {\n    return when.resolve();\n  },\n  compute: function (date, result) {\n    if (!defined(result)) {\n      result = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0);\n    } else {\n      result.xPoleWander = 0.0;\n      result.yPoleWander = 0.0;\n      result.xPoleOffset = 0.0;\n      result.yPoleOffset = 0.0;\n      result.ut1MinusUtc = 0.0;\n    }\n\n    return result;\n  }\n});\n/**\n * Gets a promise that, when resolved, indicates that the EOP data has been loaded and is\n * ready to use.\n *\n * @returns {Promise} The promise.\n */\n\nEarthOrientationParameters.prototype.getPromiseToLoad = function () {\n  return when(this._downloadPromise);\n};\n/**\n * Computes the Earth Orientation Parameters (EOP) for a given date by interpolating.\n * If the EOP data has not yet been download, this method returns undefined.\n *\n * @param {JulianDate} date The date for each to evaluate the EOP.\n * @param {EarthOrientationParametersSample} [result] The instance to which to copy the result.\n *        If this parameter is undefined, a new instance is created and returned.\n * @returns {EarthOrientationParametersSample} The EOP evaluated at the given date, or\n *          undefined if the data necessary to evaluate EOP at the date has not yet been\n *          downloaded.\n *\n * @exception {RuntimeError} The loaded EOP data has an error and cannot be used.\n *\n * @see EarthOrientationParameters#getPromiseToLoad\n */\n\n\nEarthOrientationParameters.prototype.compute = function (date, result) {\n  // We cannot compute until the samples are available.\n  if (!defined(this._samples)) {\n    if (defined(this._dataError)) {\n      throw new RuntimeError(this._dataError);\n    }\n\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0);\n  }\n\n  if (this._samples.length === 0) {\n    result.xPoleWander = 0.0;\n    result.yPoleWander = 0.0;\n    result.xPoleOffset = 0.0;\n    result.yPoleOffset = 0.0;\n    result.ut1MinusUtc = 0.0;\n    return result;\n  }\n\n  var dates = this._dates;\n  var lastIndex = this._lastIndex;\n  var before = 0;\n  var after = 0;\n\n  if (defined(lastIndex)) {\n    var previousIndexDate = dates[lastIndex];\n    var nextIndexDate = dates[lastIndex + 1];\n    var isAfterPrevious = JulianDate.lessThanOrEquals(previousIndexDate, date);\n    var isAfterLastSample = !defined(nextIndexDate);\n    var isBeforeNext = isAfterLastSample || JulianDate.greaterThanOrEquals(nextIndexDate, date);\n\n    if (isAfterPrevious && isBeforeNext) {\n      before = lastIndex;\n\n      if (!isAfterLastSample && nextIndexDate.equals(date)) {\n        ++before;\n      }\n\n      after = before + 1;\n      interpolate(this, dates, this._samples, date, before, after, result);\n      return result;\n    }\n  }\n\n  var index = binarySearch(dates, date, JulianDate.compare, this._dateColumn);\n\n  if (index >= 0) {\n    // If the next entry is the same date, use the later entry.  This way, if two entries\n    // describe the same moment, one before a leap second and the other after, then we will use\n    // the post-leap second data.\n    if (index < dates.length - 1 && dates[index + 1].equals(date)) {\n      ++index;\n    }\n\n    before = index;\n    after = index;\n  } else {\n    after = ~index;\n    before = after - 1; // Use the first entry if the date requested is before the beginning of the data.\n\n    if (before < 0) {\n      before = 0;\n    }\n  }\n\n  this._lastIndex = before;\n  interpolate(this, dates, this._samples, date, before, after, result);\n  return result;\n};\n\nfunction compareLeapSecondDates(leapSecond, dateToFind) {\n  return JulianDate.compare(leapSecond.julianDate, dateToFind);\n}\n\nfunction onDataReady(eop, eopData) {\n  if (!defined(eopData.columnNames)) {\n    eop._dataError = \"Error in loaded EOP data: The columnNames property is required.\";\n    return;\n  }\n\n  if (!defined(eopData.samples)) {\n    eop._dataError = \"Error in loaded EOP data: The samples property is required.\";\n    return;\n  }\n\n  var dateColumn = eopData.columnNames.indexOf(\"modifiedJulianDateUtc\");\n  var xPoleWanderRadiansColumn = eopData.columnNames.indexOf(\"xPoleWanderRadians\");\n  var yPoleWanderRadiansColumn = eopData.columnNames.indexOf(\"yPoleWanderRadians\");\n  var ut1MinusUtcSecondsColumn = eopData.columnNames.indexOf(\"ut1MinusUtcSeconds\");\n  var xCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf(\"xCelestialPoleOffsetRadians\");\n  var yCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf(\"yCelestialPoleOffsetRadians\");\n  var taiMinusUtcSecondsColumn = eopData.columnNames.indexOf(\"taiMinusUtcSeconds\");\n\n  if (dateColumn < 0 || xPoleWanderRadiansColumn < 0 || yPoleWanderRadiansColumn < 0 || ut1MinusUtcSecondsColumn < 0 || xCelestialPoleOffsetRadiansColumn < 0 || yCelestialPoleOffsetRadiansColumn < 0 || taiMinusUtcSecondsColumn < 0) {\n    eop._dataError = \"Error in loaded EOP data: The columnNames property must include modifiedJulianDateUtc, xPoleWanderRadians, yPoleWanderRadians, ut1MinusUtcSeconds, xCelestialPoleOffsetRadians, yCelestialPoleOffsetRadians, and taiMinusUtcSeconds columns\";\n    return;\n  }\n\n  var samples = eop._samples = eopData.samples;\n  var dates = eop._dates = [];\n  eop._dateColumn = dateColumn;\n  eop._xPoleWanderRadiansColumn = xPoleWanderRadiansColumn;\n  eop._yPoleWanderRadiansColumn = yPoleWanderRadiansColumn;\n  eop._ut1MinusUtcSecondsColumn = ut1MinusUtcSecondsColumn;\n  eop._xCelestialPoleOffsetRadiansColumn = xCelestialPoleOffsetRadiansColumn;\n  eop._yCelestialPoleOffsetRadiansColumn = yCelestialPoleOffsetRadiansColumn;\n  eop._taiMinusUtcSecondsColumn = taiMinusUtcSecondsColumn;\n  eop._columnCount = eopData.columnNames.length;\n  eop._lastIndex = undefined;\n  var lastTaiMinusUtc;\n  var addNewLeapSeconds = eop._addNewLeapSeconds; // Convert the ISO8601 dates to JulianDates.\n\n  for (var i = 0, len = samples.length; i < len; i += eop._columnCount) {\n    var mjd = samples[i + dateColumn];\n    var taiMinusUtc = samples[i + taiMinusUtcSecondsColumn];\n    var day = mjd + TimeConstants.MODIFIED_JULIAN_DATE_DIFFERENCE;\n    var date = new JulianDate(day, taiMinusUtc, TimeStandard.TAI);\n    dates.push(date);\n\n    if (addNewLeapSeconds) {\n      if (taiMinusUtc !== lastTaiMinusUtc && defined(lastTaiMinusUtc)) {\n        // We crossed a leap second boundary, so add the leap second\n        // if it does not already exist.\n        var leapSeconds = JulianDate.leapSeconds;\n        var leapSecondIndex = binarySearch(leapSeconds, date, compareLeapSecondDates);\n\n        if (leapSecondIndex < 0) {\n          var leapSecond = new LeapSecond(date, taiMinusUtc);\n          leapSeconds.splice(~leapSecondIndex, 0, leapSecond);\n        }\n      }\n\n      lastTaiMinusUtc = taiMinusUtc;\n    }\n  }\n}\n\nfunction fillResultFromIndex(eop, samples, index, columnCount, result) {\n  var start = index * columnCount;\n  result.xPoleWander = samples[start + eop._xPoleWanderRadiansColumn];\n  result.yPoleWander = samples[start + eop._yPoleWanderRadiansColumn];\n  result.xPoleOffset = samples[start + eop._xCelestialPoleOffsetRadiansColumn];\n  result.yPoleOffset = samples[start + eop._yCelestialPoleOffsetRadiansColumn];\n  result.ut1MinusUtc = samples[start + eop._ut1MinusUtcSecondsColumn];\n}\n\nfunction linearInterp(dx, y1, y2) {\n  return y1 + dx * (y2 - y1);\n}\n\nfunction interpolate(eop, dates, samples, date, before, after, result) {\n  var columnCount = eop._columnCount; // First check the bounds on the EOP data\n  // If we are after the bounds of the data, return zeros.\n  // The 'before' index should never be less than zero.\n\n  if (after > dates.length - 1) {\n    result.xPoleWander = 0;\n    result.yPoleWander = 0;\n    result.xPoleOffset = 0;\n    result.yPoleOffset = 0;\n    result.ut1MinusUtc = 0;\n    return result;\n  }\n\n  var beforeDate = dates[before];\n  var afterDate = dates[after];\n\n  if (beforeDate.equals(afterDate) || date.equals(beforeDate)) {\n    fillResultFromIndex(eop, samples, before, columnCount, result);\n    return result;\n  } else if (date.equals(afterDate)) {\n    fillResultFromIndex(eop, samples, after, columnCount, result);\n    return result;\n  }\n\n  var factor = JulianDate.secondsDifference(date, beforeDate) / JulianDate.secondsDifference(afterDate, beforeDate);\n  var startBefore = before * columnCount;\n  var startAfter = after * columnCount; // Handle UT1 leap second edge case\n\n  var beforeUt1MinusUtc = samples[startBefore + eop._ut1MinusUtcSecondsColumn];\n  var afterUt1MinusUtc = samples[startAfter + eop._ut1MinusUtcSecondsColumn];\n  var offsetDifference = afterUt1MinusUtc - beforeUt1MinusUtc;\n\n  if (offsetDifference > 0.5 || offsetDifference < -0.5) {\n    // The absolute difference between the values is more than 0.5, so we may have\n    // crossed a leap second.  Check if this is the case and, if so, adjust the\n    // afterValue to account for the leap second.  This way, our interpolation will\n    // produce reasonable results.\n    var beforeTaiMinusUtc = samples[startBefore + eop._taiMinusUtcSecondsColumn];\n    var afterTaiMinusUtc = samples[startAfter + eop._taiMinusUtcSecondsColumn];\n\n    if (beforeTaiMinusUtc !== afterTaiMinusUtc) {\n      if (afterDate.equals(date)) {\n        // If we are at the end of the leap second interval, take the second value\n        // Otherwise, the interpolation below will yield the wrong side of the\n        // discontinuity\n        // At the end of the leap second, we need to start accounting for the jump\n        beforeUt1MinusUtc = afterUt1MinusUtc;\n      } else {\n        // Otherwise, remove the leap second so that the interpolation is correct\n        afterUt1MinusUtc -= afterTaiMinusUtc - beforeTaiMinusUtc;\n      }\n    }\n  }\n\n  result.xPoleWander = linearInterp(factor, samples[startBefore + eop._xPoleWanderRadiansColumn], samples[startAfter + eop._xPoleWanderRadiansColumn]);\n  result.yPoleWander = linearInterp(factor, samples[startBefore + eop._yPoleWanderRadiansColumn], samples[startAfter + eop._yPoleWanderRadiansColumn]);\n  result.xPoleOffset = linearInterp(factor, samples[startBefore + eop._xCelestialPoleOffsetRadiansColumn], samples[startAfter + eop._xCelestialPoleOffsetRadiansColumn]);\n  result.yPoleOffset = linearInterp(factor, samples[startBefore + eop._yCelestialPoleOffsetRadiansColumn], samples[startAfter + eop._yCelestialPoleOffsetRadiansColumn]);\n  result.ut1MinusUtc = linearInterp(factor, beforeUt1MinusUtc, afterUt1MinusUtc);\n  return result;\n}\n\nexport default EarthOrientationParameters;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/EarthOrientationParameters.js"],"names":["when","binarySearch","defaultValue","defined","EarthOrientationParametersSample","JulianDate","LeapSecond","Resource","RuntimeError","TimeConstants","TimeStandard","EarthOrientationParameters","options","EMPTY_OBJECT","_dates","undefined","_samples","_dateColumn","_xPoleWanderRadiansColumn","_yPoleWanderRadiansColumn","_ut1MinusUtcSecondsColumn","_xCelestialPoleOffsetRadiansColumn","_yCelestialPoleOffsetRadiansColumn","_taiMinusUtcSecondsColumn","_columnCount","_lastIndex","_downloadPromise","_dataError","_addNewLeapSeconds","addNewLeapSeconds","data","onDataReady","url","resource","createIfNeeded","that","fetchJson","then","eopData","otherwise","columnNames","samples","NONE","Object","freeze","getPromiseToLoad","resolve","compute","date","result","xPoleWander","yPoleWander","xPoleOffset","yPoleOffset","ut1MinusUtc","prototype","length","dates","lastIndex","before","after","previousIndexDate","nextIndexDate","isAfterPrevious","lessThanOrEquals","isAfterLastSample","isBeforeNext","greaterThanOrEquals","equals","interpolate","index","compare","compareLeapSecondDates","leapSecond","dateToFind","julianDate","eop","dateColumn","indexOf","xPoleWanderRadiansColumn","yPoleWanderRadiansColumn","ut1MinusUtcSecondsColumn","xCelestialPoleOffsetRadiansColumn","yCelestialPoleOffsetRadiansColumn","taiMinusUtcSecondsColumn","lastTaiMinusUtc","i","len","mjd","taiMinusUtc","day","MODIFIED_JULIAN_DATE_DIFFERENCE","TAI","push","leapSeconds","leapSecondIndex","splice","fillResultFromIndex","columnCount","start","linearInterp","dx","y1","y2","beforeDate","afterDate","factor","secondsDifference","startBefore","startAfter","beforeUt1MinusUtc","afterUt1MinusUtc","offsetDifference","beforeTaiMinusUtc","afterTaiMinusUtc"],"mappings":"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","sourcesContent":["import when from \"../ThirdParty/when.js\";\nimport binarySearch from \"./binarySearch.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport EarthOrientationParametersSample from \"./EarthOrientationParametersSample.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport LeapSecond from \"./LeapSecond.js\";\nimport Resource from \"./Resource.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nimport TimeConstants from \"./TimeConstants.js\";\nimport TimeStandard from \"./TimeStandard.js\";\n\n/**\n * Specifies Earth polar motion coordinates and the difference between UT1 and UTC.\n * These Earth Orientation Parameters (EOP) are primarily used in the transformation from\n * the International Celestial Reference Frame (ICRF) to the International Terrestrial\n * Reference Frame (ITRF).\n *\n * @alias EarthOrientationParameters\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Resource|String} [options.url] The URL from which to obtain EOP data.  If neither this\n *                 parameter nor options.data is specified, all EOP values are assumed\n *                 to be 0.0.  If options.data is specified, this parameter is\n *                 ignored.\n * @param {Object} [options.data] The actual EOP data.  If neither this\n *                 parameter nor options.data is specified, all EOP values are assumed\n *                 to be 0.0.\n * @param {Boolean} [options.addNewLeapSeconds=true] True if leap seconds that\n *                  are specified in the EOP data but not in {@link JulianDate.leapSeconds}\n *                  should be added to {@link JulianDate.leapSeconds}.  False if\n *                  new leap seconds should be handled correctly in the context\n *                  of the EOP data but otherwise ignored.\n *\n * @example\n * // An example EOP data file, EOP.json:\n * {\n *   \"columnNames\" : [\"dateIso8601\",\"modifiedJulianDateUtc\",\"xPoleWanderRadians\",\"yPoleWanderRadians\",\"ut1MinusUtcSeconds\",\"lengthOfDayCorrectionSeconds\",\"xCelestialPoleOffsetRadians\",\"yCelestialPoleOffsetRadians\",\"taiMinusUtcSeconds\"],\n *   \"samples\" : [\n *      \"2011-07-01T00:00:00Z\",55743.0,2.117957047295119e-7,2.111518721609984e-6,-0.2908948,-2.956e-4,3.393695767766752e-11,3.3452143996557983e-10,34.0,\n *      \"2011-07-02T00:00:00Z\",55744.0,2.193297093339541e-7,2.115460256837405e-6,-0.29065,-1.824e-4,-8.241832578862112e-11,5.623838700870617e-10,34.0,\n *      \"2011-07-03T00:00:00Z\",55745.0,2.262286080161428e-7,2.1191157519929706e-6,-0.2905572,1.9e-6,-3.490658503988659e-10,6.981317007977318e-10,34.0\n *   ]\n * }\n *\n * @example\n * // Loading the EOP data\n * var eop = new Cesium.EarthOrientationParameters({ url : 'Data/EOP.json' });\n * Cesium.Transforms.earthOrientationParameters = eop;\n *\n * @private\n */\nfunction EarthOrientationParameters(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._dates = undefined;\n  this._samples = undefined;\n\n  this._dateColumn = -1;\n  this._xPoleWanderRadiansColumn = -1;\n  this._yPoleWanderRadiansColumn = -1;\n  this._ut1MinusUtcSecondsColumn = -1;\n  this._xCelestialPoleOffsetRadiansColumn = -1;\n  this._yCelestialPoleOffsetRadiansColumn = -1;\n  this._taiMinusUtcSecondsColumn = -1;\n\n  this._columnCount = 0;\n  this._lastIndex = -1;\n\n  this._downloadPromise = undefined;\n  this._dataError = undefined;\n\n  this._addNewLeapSeconds = defaultValue(options.addNewLeapSeconds, true);\n\n  if (defined(options.data)) {\n    // Use supplied EOP data.\n    onDataReady(this, options.data);\n  } else if (defined(options.url)) {\n    var resource = Resource.createIfNeeded(options.url);\n\n    // Download EOP data.\n    var that = this;\n    this._downloadPromise = resource\n      .fetchJson()\n      .then(function (eopData) {\n        onDataReady(that, eopData);\n      })\n      .otherwise(function () {\n        that._dataError =\n          \"An error occurred while retrieving the EOP data from the URL \" +\n          resource.url +\n          \".\";\n      });\n  } else {\n    // Use all zeros for EOP data.\n    onDataReady(this, {\n      columnNames: [\n        \"dateIso8601\",\n        \"modifiedJulianDateUtc\",\n        \"xPoleWanderRadians\",\n        \"yPoleWanderRadians\",\n        \"ut1MinusUtcSeconds\",\n        \"lengthOfDayCorrectionSeconds\",\n        \"xCelestialPoleOffsetRadians\",\n        \"yCelestialPoleOffsetRadians\",\n        \"taiMinusUtcSeconds\",\n      ],\n      samples: [],\n    });\n  }\n}\n\n/**\n * A default {@link EarthOrientationParameters} instance that returns zero for all EOP values.\n */\nEarthOrientationParameters.NONE = Object.freeze({\n  getPromiseToLoad: function () {\n    return when.resolve();\n  },\n  compute: function (date, result) {\n    if (!defined(result)) {\n      result = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0);\n    } else {\n      result.xPoleWander = 0.0;\n      result.yPoleWander = 0.0;\n      result.xPoleOffset = 0.0;\n      result.yPoleOffset = 0.0;\n      result.ut1MinusUtc = 0.0;\n    }\n    return result;\n  },\n});\n\n/**\n * Gets a promise that, when resolved, indicates that the EOP data has been loaded and is\n * ready to use.\n *\n * @returns {Promise} The promise.\n */\nEarthOrientationParameters.prototype.getPromiseToLoad = function () {\n  return when(this._downloadPromise);\n};\n\n/**\n * Computes the Earth Orientation Parameters (EOP) for a given date by interpolating.\n * If the EOP data has not yet been download, this method returns undefined.\n *\n * @param {JulianDate} date The date for each to evaluate the EOP.\n * @param {EarthOrientationParametersSample} [result] The instance to which to copy the result.\n *        If this parameter is undefined, a new instance is created and returned.\n * @returns {EarthOrientationParametersSample} The EOP evaluated at the given date, or\n *          undefined if the data necessary to evaluate EOP at the date has not yet been\n *          downloaded.\n *\n * @exception {RuntimeError} The loaded EOP data has an error and cannot be used.\n *\n * @see EarthOrientationParameters#getPromiseToLoad\n */\nEarthOrientationParameters.prototype.compute = function (date, result) {\n  // We cannot compute until the samples are available.\n  if (!defined(this._samples)) {\n    if (defined(this._dataError)) {\n      throw new RuntimeError(this._dataError);\n    }\n\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0);\n  }\n\n  if (this._samples.length === 0) {\n    result.xPoleWander = 0.0;\n    result.yPoleWander = 0.0;\n    result.xPoleOffset = 0.0;\n    result.yPoleOffset = 0.0;\n    result.ut1MinusUtc = 0.0;\n    return result;\n  }\n\n  var dates = this._dates;\n  var lastIndex = this._lastIndex;\n\n  var before = 0;\n  var after = 0;\n  if (defined(lastIndex)) {\n    var previousIndexDate = dates[lastIndex];\n    var nextIndexDate = dates[lastIndex + 1];\n    var isAfterPrevious = JulianDate.lessThanOrEquals(previousIndexDate, date);\n    var isAfterLastSample = !defined(nextIndexDate);\n    var isBeforeNext =\n      isAfterLastSample || JulianDate.greaterThanOrEquals(nextIndexDate, date);\n\n    if (isAfterPrevious && isBeforeNext) {\n      before = lastIndex;\n\n      if (!isAfterLastSample && nextIndexDate.equals(date)) {\n        ++before;\n      }\n      after = before + 1;\n\n      interpolate(this, dates, this._samples, date, before, after, result);\n      return result;\n    }\n  }\n\n  var index = binarySearch(dates, date, JulianDate.compare, this._dateColumn);\n  if (index >= 0) {\n    // If the next entry is the same date, use the later entry.  This way, if two entries\n    // describe the same moment, one before a leap second and the other after, then we will use\n    // the post-leap second data.\n    if (index < dates.length - 1 && dates[index + 1].equals(date)) {\n      ++index;\n    }\n    before = index;\n    after = index;\n  } else {\n    after = ~index;\n    before = after - 1;\n\n    // Use the first entry if the date requested is before the beginning of the data.\n    if (before < 0) {\n      before = 0;\n    }\n  }\n\n  this._lastIndex = before;\n\n  interpolate(this, dates, this._samples, date, before, after, result);\n  return result;\n};\n\nfunction compareLeapSecondDates(leapSecond, dateToFind) {\n  return JulianDate.compare(leapSecond.julianDate, dateToFind);\n}\n\nfunction onDataReady(eop, eopData) {\n  if (!defined(eopData.columnNames)) {\n    eop._dataError =\n      \"Error in loaded EOP data: The columnNames property is required.\";\n    return;\n  }\n\n  if (!defined(eopData.samples)) {\n    eop._dataError =\n      \"Error in loaded EOP data: The samples property is required.\";\n    return;\n  }\n\n  var dateColumn = eopData.columnNames.indexOf(\"modifiedJulianDateUtc\");\n  var xPoleWanderRadiansColumn = eopData.columnNames.indexOf(\n    \"xPoleWanderRadians\"\n  );\n  var yPoleWanderRadiansColumn = eopData.columnNames.indexOf(\n    \"yPoleWanderRadians\"\n  );\n  var ut1MinusUtcSecondsColumn = eopData.columnNames.indexOf(\n    \"ut1MinusUtcSeconds\"\n  );\n  var xCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf(\n    \"xCelestialPoleOffsetRadians\"\n  );\n  var yCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf(\n    \"yCelestialPoleOffsetRadians\"\n  );\n  var taiMinusUtcSecondsColumn = eopData.columnNames.indexOf(\n    \"taiMinusUtcSeconds\"\n  );\n\n  if (\n    dateColumn < 0 ||\n    xPoleWanderRadiansColumn < 0 ||\n    yPoleWanderRadiansColumn < 0 ||\n    ut1MinusUtcSecondsColumn < 0 ||\n    xCelestialPoleOffsetRadiansColumn < 0 ||\n    yCelestialPoleOffsetRadiansColumn < 0 ||\n    taiMinusUtcSecondsColumn < 0\n  ) {\n    eop._dataError =\n      \"Error in loaded EOP data: The columnNames property must include modifiedJulianDateUtc, xPoleWanderRadians, yPoleWanderRadians, ut1MinusUtcSeconds, xCelestialPoleOffsetRadians, yCelestialPoleOffsetRadians, and taiMinusUtcSeconds columns\";\n    return;\n  }\n\n  var samples = (eop._samples = eopData.samples);\n  var dates = (eop._dates = []);\n\n  eop._dateColumn = dateColumn;\n  eop._xPoleWanderRadiansColumn = xPoleWanderRadiansColumn;\n  eop._yPoleWanderRadiansColumn = yPoleWanderRadiansColumn;\n  eop._ut1MinusUtcSecondsColumn = ut1MinusUtcSecondsColumn;\n  eop._xCelestialPoleOffsetRadiansColumn = xCelestialPoleOffsetRadiansColumn;\n  eop._yCelestialPoleOffsetRadiansColumn = yCelestialPoleOffsetRadiansColumn;\n  eop._taiMinusUtcSecondsColumn = taiMinusUtcSecondsColumn;\n\n  eop._columnCount = eopData.columnNames.length;\n  eop._lastIndex = undefined;\n\n  var lastTaiMinusUtc;\n\n  var addNewLeapSeconds = eop._addNewLeapSeconds;\n\n  // Convert the ISO8601 dates to JulianDates.\n  for (var i = 0, len = samples.length; i < len; i += eop._columnCount) {\n    var mjd = samples[i + dateColumn];\n    var taiMinusUtc = samples[i + taiMinusUtcSecondsColumn];\n    var day = mjd + TimeConstants.MODIFIED_JULIAN_DATE_DIFFERENCE;\n    var date = new JulianDate(day, taiMinusUtc, TimeStandard.TAI);\n    dates.push(date);\n\n    if (addNewLeapSeconds) {\n      if (taiMinusUtc !== lastTaiMinusUtc && defined(lastTaiMinusUtc)) {\n        // We crossed a leap second boundary, so add the leap second\n        // if it does not already exist.\n        var leapSeconds = JulianDate.leapSeconds;\n        var leapSecondIndex = binarySearch(\n          leapSeconds,\n          date,\n          compareLeapSecondDates\n        );\n        if (leapSecondIndex < 0) {\n          var leapSecond = new LeapSecond(date, taiMinusUtc);\n          leapSeconds.splice(~leapSecondIndex, 0, leapSecond);\n        }\n      }\n      lastTaiMinusUtc = taiMinusUtc;\n    }\n  }\n}\n\nfunction fillResultFromIndex(eop, samples, index, columnCount, result) {\n  var start = index * columnCount;\n  result.xPoleWander = samples[start + eop._xPoleWanderRadiansColumn];\n  result.yPoleWander = samples[start + eop._yPoleWanderRadiansColumn];\n  result.xPoleOffset = samples[start + eop._xCelestialPoleOffsetRadiansColumn];\n  result.yPoleOffset = samples[start + eop._yCelestialPoleOffsetRadiansColumn];\n  result.ut1MinusUtc = samples[start + eop._ut1MinusUtcSecondsColumn];\n}\n\nfunction linearInterp(dx, y1, y2) {\n  return y1 + dx * (y2 - y1);\n}\n\nfunction interpolate(eop, dates, samples, date, before, after, result) {\n  var columnCount = eop._columnCount;\n\n  // First check the bounds on the EOP data\n  // If we are after the bounds of the data, return zeros.\n  // The 'before' index should never be less than zero.\n  if (after > dates.length - 1) {\n    result.xPoleWander = 0;\n    result.yPoleWander = 0;\n    result.xPoleOffset = 0;\n    result.yPoleOffset = 0;\n    result.ut1MinusUtc = 0;\n    return result;\n  }\n\n  var beforeDate = dates[before];\n  var afterDate = dates[after];\n  if (beforeDate.equals(afterDate) || date.equals(beforeDate)) {\n    fillResultFromIndex(eop, samples, before, columnCount, result);\n    return result;\n  } else if (date.equals(afterDate)) {\n    fillResultFromIndex(eop, samples, after, columnCount, result);\n    return result;\n  }\n\n  var factor =\n    JulianDate.secondsDifference(date, beforeDate) /\n    JulianDate.secondsDifference(afterDate, beforeDate);\n\n  var startBefore = before * columnCount;\n  var startAfter = after * columnCount;\n\n  // Handle UT1 leap second edge case\n  var beforeUt1MinusUtc = samples[startBefore + eop._ut1MinusUtcSecondsColumn];\n  var afterUt1MinusUtc = samples[startAfter + eop._ut1MinusUtcSecondsColumn];\n\n  var offsetDifference = afterUt1MinusUtc - beforeUt1MinusUtc;\n  if (offsetDifference > 0.5 || offsetDifference < -0.5) {\n    // The absolute difference between the values is more than 0.5, so we may have\n    // crossed a leap second.  Check if this is the case and, if so, adjust the\n    // afterValue to account for the leap second.  This way, our interpolation will\n    // produce reasonable results.\n    var beforeTaiMinusUtc =\n      samples[startBefore + eop._taiMinusUtcSecondsColumn];\n    var afterTaiMinusUtc = samples[startAfter + eop._taiMinusUtcSecondsColumn];\n    if (beforeTaiMinusUtc !== afterTaiMinusUtc) {\n      if (afterDate.equals(date)) {\n        // If we are at the end of the leap second interval, take the second value\n        // Otherwise, the interpolation below will yield the wrong side of the\n        // discontinuity\n        // At the end of the leap second, we need to start accounting for the jump\n        beforeUt1MinusUtc = afterUt1MinusUtc;\n      } else {\n        // Otherwise, remove the leap second so that the interpolation is correct\n        afterUt1MinusUtc -= afterTaiMinusUtc - beforeTaiMinusUtc;\n      }\n    }\n  }\n\n  result.xPoleWander = linearInterp(\n    factor,\n    samples[startBefore + eop._xPoleWanderRadiansColumn],\n    samples[startAfter + eop._xPoleWanderRadiansColumn]\n  );\n  result.yPoleWander = linearInterp(\n    factor,\n    samples[startBefore + eop._yPoleWanderRadiansColumn],\n    samples[startAfter + eop._yPoleWanderRadiansColumn]\n  );\n  result.xPoleOffset = linearInterp(\n    factor,\n    samples[startBefore + eop._xCelestialPoleOffsetRadiansColumn],\n    samples[startAfter + eop._xCelestialPoleOffsetRadiansColumn]\n  );\n  result.yPoleOffset = linearInterp(\n    factor,\n    samples[startBefore + eop._yCelestialPoleOffsetRadiansColumn],\n    samples[startAfter + eop._yCelestialPoleOffsetRadiansColumn]\n  );\n  result.ut1MinusUtc = linearInterp(\n    factor,\n    beforeUt1MinusUtc,\n    afterUt1MinusUtc\n  );\n  return result;\n}\nexport default EarthOrientationParameters;\n"]},"metadata":{},"sourceType":"module"}