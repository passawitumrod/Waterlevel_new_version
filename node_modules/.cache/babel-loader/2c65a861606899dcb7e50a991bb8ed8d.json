{"ast":null,"code":"import ArcType from \"./ArcType.js\";\nimport arrayFill from \"./arrayFill.js\";\nimport BoundingRectangle from \"./BoundingRectangle.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidGeodesic from \"./EllipsoidGeodesic.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolygonGeometryLibrary from \"./PolygonGeometryLibrary.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nimport WindingOrder from \"./WindingOrder.js\";\nvar scratchCarto1 = new Cartographic();\nvar scratchCarto2 = new Cartographic();\n\nfunction adjustPosHeightsForNormal(position, p1, p2, ellipsoid) {\n  var carto1 = ellipsoid.cartesianToCartographic(position, scratchCarto1);\n  var height = carto1.height;\n  var p1Carto = ellipsoid.cartesianToCartographic(p1, scratchCarto2);\n  p1Carto.height = height;\n  ellipsoid.cartographicToCartesian(p1Carto, p1);\n  var p2Carto = ellipsoid.cartesianToCartographic(p2, scratchCarto2);\n  p2Carto.height = height - 100;\n  ellipsoid.cartographicToCartesian(p2Carto, p2);\n}\n\nvar scratchBoundingRectangle = new BoundingRectangle();\nvar scratchPosition = new Cartesian3();\nvar scratchNormal = new Cartesian3();\nvar scratchTangent = new Cartesian3();\nvar scratchBitangent = new Cartesian3();\nvar p1Scratch = new Cartesian3();\nvar p2Scratch = new Cartesian3();\nvar scratchPerPosNormal = new Cartesian3();\nvar scratchPerPosTangent = new Cartesian3();\nvar scratchPerPosBitangent = new Cartesian3();\nvar appendTextureCoordinatesOrigin = new Cartesian2();\nvar appendTextureCoordinatesCartesian2 = new Cartesian2();\nvar appendTextureCoordinatesCartesian3 = new Cartesian3();\nvar appendTextureCoordinatesQuaternion = new Quaternion();\nvar appendTextureCoordinatesMatrix3 = new Matrix3();\nvar tangentMatrixScratch = new Matrix3();\n\nfunction computeAttributes(options) {\n  var vertexFormat = options.vertexFormat;\n  var geometry = options.geometry;\n  var shadowVolume = options.shadowVolume;\n  var flatPositions = geometry.attributes.position.values;\n  var length = flatPositions.length;\n  var wall = options.wall;\n  var top = options.top || wall;\n  var bottom = options.bottom || wall;\n\n  if (vertexFormat.st || vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent || shadowVolume) {\n    // PERFORMANCE_IDEA: Compute before subdivision, then just interpolate during subdivision.\n    // PERFORMANCE_IDEA: Compute with createGeometryFromPositions() for fast path when there's no holes.\n    var boundingRectangle = options.boundingRectangle;\n    var tangentPlane = options.tangentPlane;\n    var ellipsoid = options.ellipsoid;\n    var stRotation = options.stRotation;\n    var perPositionHeight = options.perPositionHeight;\n    var origin = appendTextureCoordinatesOrigin;\n    origin.x = boundingRectangle.x;\n    origin.y = boundingRectangle.y;\n    var textureCoordinates = vertexFormat.st ? new Float32Array(2 * (length / 3)) : undefined;\n    var normals;\n\n    if (vertexFormat.normal) {\n      if (perPositionHeight && top && !wall) {\n        normals = geometry.attributes.normal.values;\n      } else {\n        normals = new Float32Array(length);\n      }\n    }\n\n    var tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;\n    var bitangents = vertexFormat.bitangent ? new Float32Array(length) : undefined;\n    var extrudeNormals = shadowVolume ? new Float32Array(length) : undefined;\n    var textureCoordIndex = 0;\n    var attrIndex = 0;\n    var normal = scratchNormal;\n    var tangent = scratchTangent;\n    var bitangent = scratchBitangent;\n    var recomputeNormal = true;\n    var textureMatrix = appendTextureCoordinatesMatrix3;\n    var tangentRotationMatrix = tangentMatrixScratch;\n\n    if (stRotation !== 0.0) {\n      var rotation = Quaternion.fromAxisAngle(tangentPlane._plane.normal, stRotation, appendTextureCoordinatesQuaternion);\n      textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n      rotation = Quaternion.fromAxisAngle(tangentPlane._plane.normal, -stRotation, appendTextureCoordinatesQuaternion);\n      tangentRotationMatrix = Matrix3.fromQuaternion(rotation, tangentRotationMatrix);\n    } else {\n      textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n      tangentRotationMatrix = Matrix3.clone(Matrix3.IDENTITY, tangentRotationMatrix);\n    }\n\n    var bottomOffset = 0;\n    var bottomOffset2 = 0;\n\n    if (top && bottom) {\n      bottomOffset = length / 2;\n      bottomOffset2 = length / 3;\n      length /= 2;\n    }\n\n    for (var i = 0; i < length; i += 3) {\n      var position = Cartesian3.fromArray(flatPositions, i, appendTextureCoordinatesCartesian3);\n\n      if (vertexFormat.st) {\n        var p = Matrix3.multiplyByVector(textureMatrix, position, scratchPosition);\n        p = ellipsoid.scaleToGeodeticSurface(p, p);\n        var st = tangentPlane.projectPointOntoPlane(p, appendTextureCoordinatesCartesian2);\n        Cartesian2.subtract(st, origin, st);\n        var stx = CesiumMath.clamp(st.x / boundingRectangle.width, 0, 1);\n        var sty = CesiumMath.clamp(st.y / boundingRectangle.height, 0, 1);\n\n        if (bottom) {\n          textureCoordinates[textureCoordIndex + bottomOffset2] = stx;\n          textureCoordinates[textureCoordIndex + 1 + bottomOffset2] = sty;\n        }\n\n        if (top) {\n          textureCoordinates[textureCoordIndex] = stx;\n          textureCoordinates[textureCoordIndex + 1] = sty;\n        }\n\n        textureCoordIndex += 2;\n      }\n\n      if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent || shadowVolume) {\n        var attrIndex1 = attrIndex + 1;\n        var attrIndex2 = attrIndex + 2;\n\n        if (wall) {\n          if (i + 3 < length) {\n            var p1 = Cartesian3.fromArray(flatPositions, i + 3, p1Scratch);\n\n            if (recomputeNormal) {\n              var p2 = Cartesian3.fromArray(flatPositions, i + length, p2Scratch);\n\n              if (perPositionHeight) {\n                adjustPosHeightsForNormal(position, p1, p2, ellipsoid);\n              }\n\n              Cartesian3.subtract(p1, position, p1);\n              Cartesian3.subtract(p2, position, p2);\n              normal = Cartesian3.normalize(Cartesian3.cross(p2, p1, normal), normal);\n              recomputeNormal = false;\n            }\n\n            if (Cartesian3.equalsEpsilon(p1, position, CesiumMath.EPSILON10)) {\n              // if we've reached a corner\n              recomputeNormal = true;\n            }\n          }\n\n          if (vertexFormat.tangent || vertexFormat.bitangent) {\n            bitangent = ellipsoid.geodeticSurfaceNormal(position, bitangent);\n\n            if (vertexFormat.tangent) {\n              tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);\n            }\n          }\n        } else {\n          normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n\n          if (vertexFormat.tangent || vertexFormat.bitangent) {\n            if (perPositionHeight) {\n              scratchPerPosNormal = Cartesian3.fromArray(normals, attrIndex, scratchPerPosNormal);\n              scratchPerPosTangent = Cartesian3.cross(Cartesian3.UNIT_Z, scratchPerPosNormal, scratchPerPosTangent);\n              scratchPerPosTangent = Cartesian3.normalize(Matrix3.multiplyByVector(tangentRotationMatrix, scratchPerPosTangent, scratchPerPosTangent), scratchPerPosTangent);\n\n              if (vertexFormat.bitangent) {\n                scratchPerPosBitangent = Cartesian3.normalize(Cartesian3.cross(scratchPerPosNormal, scratchPerPosTangent, scratchPerPosBitangent), scratchPerPosBitangent);\n              }\n            }\n\n            tangent = Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\n            tangent = Cartesian3.normalize(Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent), tangent);\n\n            if (vertexFormat.bitangent) {\n              bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n            }\n          }\n        }\n\n        if (vertexFormat.normal) {\n          if (options.wall) {\n            normals[attrIndex + bottomOffset] = normal.x;\n            normals[attrIndex1 + bottomOffset] = normal.y;\n            normals[attrIndex2 + bottomOffset] = normal.z;\n          } else if (bottom) {\n            normals[attrIndex + bottomOffset] = -normal.x;\n            normals[attrIndex1 + bottomOffset] = -normal.y;\n            normals[attrIndex2 + bottomOffset] = -normal.z;\n          }\n\n          if (top && !perPositionHeight || wall) {\n            normals[attrIndex] = normal.x;\n            normals[attrIndex1] = normal.y;\n            normals[attrIndex2] = normal.z;\n          }\n        }\n\n        if (shadowVolume) {\n          if (wall) {\n            normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n          }\n\n          extrudeNormals[attrIndex + bottomOffset] = -normal.x;\n          extrudeNormals[attrIndex1 + bottomOffset] = -normal.y;\n          extrudeNormals[attrIndex2 + bottomOffset] = -normal.z;\n        }\n\n        if (vertexFormat.tangent) {\n          if (options.wall) {\n            tangents[attrIndex + bottomOffset] = tangent.x;\n            tangents[attrIndex1 + bottomOffset] = tangent.y;\n            tangents[attrIndex2 + bottomOffset] = tangent.z;\n          } else if (bottom) {\n            tangents[attrIndex + bottomOffset] = -tangent.x;\n            tangents[attrIndex1 + bottomOffset] = -tangent.y;\n            tangents[attrIndex2 + bottomOffset] = -tangent.z;\n          }\n\n          if (top) {\n            if (perPositionHeight) {\n              tangents[attrIndex] = scratchPerPosTangent.x;\n              tangents[attrIndex1] = scratchPerPosTangent.y;\n              tangents[attrIndex2] = scratchPerPosTangent.z;\n            } else {\n              tangents[attrIndex] = tangent.x;\n              tangents[attrIndex1] = tangent.y;\n              tangents[attrIndex2] = tangent.z;\n            }\n          }\n        }\n\n        if (vertexFormat.bitangent) {\n          if (bottom) {\n            bitangents[attrIndex + bottomOffset] = bitangent.x;\n            bitangents[attrIndex1 + bottomOffset] = bitangent.y;\n            bitangents[attrIndex2 + bottomOffset] = bitangent.z;\n          }\n\n          if (top) {\n            if (perPositionHeight) {\n              bitangents[attrIndex] = scratchPerPosBitangent.x;\n              bitangents[attrIndex1] = scratchPerPosBitangent.y;\n              bitangents[attrIndex2] = scratchPerPosBitangent.z;\n            } else {\n              bitangents[attrIndex] = bitangent.x;\n              bitangents[attrIndex1] = bitangent.y;\n              bitangents[attrIndex2] = bitangent.z;\n            }\n          }\n        }\n\n        attrIndex += 3;\n      }\n    }\n\n    if (vertexFormat.st) {\n      geometry.attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: textureCoordinates\n      });\n    }\n\n    if (vertexFormat.normal) {\n      geometry.attributes.normal = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: normals\n      });\n    }\n\n    if (vertexFormat.tangent) {\n      geometry.attributes.tangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: tangents\n      });\n    }\n\n    if (vertexFormat.bitangent) {\n      geometry.attributes.bitangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: bitangents\n      });\n    }\n\n    if (shadowVolume) {\n      geometry.attributes.extrudeDirection = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: extrudeNormals\n      });\n    }\n  }\n\n  if (options.extrude && defined(options.offsetAttribute)) {\n    var size = flatPositions.length / 3;\n    var offsetAttribute = new Uint8Array(size);\n\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      if (top && bottom || wall) {\n        offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n      } else if (top) {\n        offsetAttribute = arrayFill(offsetAttribute, 1);\n      }\n    } else {\n      var offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n    }\n\n    geometry.attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute\n    });\n  }\n\n  return geometry;\n}\n\nvar startCartographicScratch = new Cartographic();\nvar endCartographicScratch = new Cartographic();\nvar idlCross = {\n  westOverIDL: 0.0,\n  eastOverIDL: 0.0\n};\nvar ellipsoidGeodesic = new EllipsoidGeodesic();\n\nfunction computeRectangle(positions, ellipsoid, arcType, granularity, result) {\n  result = defaultValue(result, new Rectangle());\n\n  if (!defined(positions) || positions.length < 3) {\n    result.west = 0.0;\n    result.north = 0.0;\n    result.south = 0.0;\n    result.east = 0.0;\n    return result;\n  }\n\n  if (arcType === ArcType.RHUMB) {\n    return Rectangle.fromCartesianArray(positions, ellipsoid, result);\n  }\n\n  if (!ellipsoidGeodesic.ellipsoid.equals(ellipsoid)) {\n    ellipsoidGeodesic = new EllipsoidGeodesic(undefined, undefined, ellipsoid);\n  }\n\n  result.west = Number.POSITIVE_INFINITY;\n  result.east = Number.NEGATIVE_INFINITY;\n  result.south = Number.POSITIVE_INFINITY;\n  result.north = Number.NEGATIVE_INFINITY;\n  idlCross.westOverIDL = Number.POSITIVE_INFINITY;\n  idlCross.eastOverIDL = Number.NEGATIVE_INFINITY;\n  var inverseChordLength = 1.0 / CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n  var positionsLength = positions.length;\n  var endCartographic = ellipsoid.cartesianToCartographic(positions[0], endCartographicScratch);\n  var startCartographic = startCartographicScratch;\n  var swap;\n\n  for (var i = 1; i < positionsLength; i++) {\n    swap = startCartographic;\n    startCartographic = endCartographic;\n    endCartographic = ellipsoid.cartesianToCartographic(positions[i], swap);\n    ellipsoidGeodesic.setEndPoints(startCartographic, endCartographic);\n    interpolateAndGrowRectangle(ellipsoidGeodesic, inverseChordLength, result, idlCross);\n  }\n\n  swap = startCartographic;\n  startCartographic = endCartographic;\n  endCartographic = ellipsoid.cartesianToCartographic(positions[0], swap);\n  ellipsoidGeodesic.setEndPoints(startCartographic, endCartographic);\n  interpolateAndGrowRectangle(ellipsoidGeodesic, inverseChordLength, result, idlCross);\n\n  if (result.east - result.west > idlCross.eastOverIDL - idlCross.westOverIDL) {\n    result.west = idlCross.westOverIDL;\n    result.east = idlCross.eastOverIDL;\n\n    if (result.east > CesiumMath.PI) {\n      result.east = result.east - CesiumMath.TWO_PI;\n    }\n\n    if (result.west > CesiumMath.PI) {\n      result.west = result.west - CesiumMath.TWO_PI;\n    }\n  }\n\n  return result;\n}\n\nvar interpolatedCartographicScratch = new Cartographic();\n\nfunction interpolateAndGrowRectangle(ellipsoidGeodesic, inverseChordLength, result, idlCross) {\n  var segmentLength = ellipsoidGeodesic.surfaceDistance;\n  var numPoints = Math.ceil(segmentLength * inverseChordLength);\n  var subsegmentDistance = numPoints > 0 ? segmentLength / (numPoints - 1) : Number.POSITIVE_INFINITY;\n  var interpolationDistance = 0.0;\n\n  for (var i = 0; i < numPoints; i++) {\n    var interpolatedCartographic = ellipsoidGeodesic.interpolateUsingSurfaceDistance(interpolationDistance, interpolatedCartographicScratch);\n    interpolationDistance += subsegmentDistance;\n    var longitude = interpolatedCartographic.longitude;\n    var latitude = interpolatedCartographic.latitude;\n    result.west = Math.min(result.west, longitude);\n    result.east = Math.max(result.east, longitude);\n    result.south = Math.min(result.south, latitude);\n    result.north = Math.max(result.north, latitude);\n    var lonAdjusted = longitude >= 0 ? longitude : longitude + CesiumMath.TWO_PI;\n    idlCross.westOverIDL = Math.min(idlCross.westOverIDL, lonAdjusted);\n    idlCross.eastOverIDL = Math.max(idlCross.eastOverIDL, lonAdjusted);\n  }\n}\n\nvar createGeometryFromPositionsExtrudedPositions = [];\n\nfunction createGeometryFromPositionsExtruded(ellipsoid, polygon, granularity, hierarchy, perPositionHeight, closeTop, closeBottom, vertexFormat, arcType) {\n  var geos = {\n    walls: []\n  };\n  var i;\n\n  if (closeTop || closeBottom) {\n    var topGeo = PolygonGeometryLibrary.createGeometryFromPositions(ellipsoid, polygon, granularity, perPositionHeight, vertexFormat, arcType);\n    var edgePoints = topGeo.attributes.position.values;\n    var indices = topGeo.indices;\n    var numPositions;\n    var newIndices;\n\n    if (closeTop && closeBottom) {\n      var topBottomPositions = edgePoints.concat(edgePoints);\n      numPositions = topBottomPositions.length / 3;\n      newIndices = IndexDatatype.createTypedArray(numPositions, indices.length * 2);\n      newIndices.set(indices);\n      var ilength = indices.length;\n      var length = numPositions / 2;\n\n      for (i = 0; i < ilength; i += 3) {\n        var i0 = newIndices[i] + length;\n        var i1 = newIndices[i + 1] + length;\n        var i2 = newIndices[i + 2] + length;\n        newIndices[i + ilength] = i2;\n        newIndices[i + 1 + ilength] = i1;\n        newIndices[i + 2 + ilength] = i0;\n      }\n\n      topGeo.attributes.position.values = topBottomPositions;\n\n      if (perPositionHeight && vertexFormat.normal) {\n        var normals = topGeo.attributes.normal.values;\n        topGeo.attributes.normal.values = new Float32Array(topBottomPositions.length);\n        topGeo.attributes.normal.values.set(normals);\n      }\n\n      topGeo.indices = newIndices;\n    } else if (closeBottom) {\n      numPositions = edgePoints.length / 3;\n      newIndices = IndexDatatype.createTypedArray(numPositions, indices.length);\n\n      for (i = 0; i < indices.length; i += 3) {\n        newIndices[i] = indices[i + 2];\n        newIndices[i + 1] = indices[i + 1];\n        newIndices[i + 2] = indices[i];\n      }\n\n      topGeo.indices = newIndices;\n    }\n\n    geos.topAndBottom = new GeometryInstance({\n      geometry: topGeo\n    });\n  }\n\n  var outerRing = hierarchy.outerRing;\n  var tangentPlane = EllipsoidTangentPlane.fromPoints(outerRing, ellipsoid);\n  var positions2D = tangentPlane.projectPointsOntoPlane(outerRing, createGeometryFromPositionsExtrudedPositions);\n  var windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n\n  if (windingOrder === WindingOrder.CLOCKWISE) {\n    outerRing = outerRing.slice().reverse();\n  }\n\n  var wallGeo = PolygonGeometryLibrary.computeWallGeometry(outerRing, ellipsoid, granularity, perPositionHeight, arcType);\n  geos.walls.push(new GeometryInstance({\n    geometry: wallGeo\n  }));\n  var holes = hierarchy.holes;\n\n  for (i = 0; i < holes.length; i++) {\n    var hole = holes[i];\n    tangentPlane = EllipsoidTangentPlane.fromPoints(hole, ellipsoid);\n    positions2D = tangentPlane.projectPointsOntoPlane(hole, createGeometryFromPositionsExtrudedPositions);\n    windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n\n    if (windingOrder === WindingOrder.COUNTER_CLOCKWISE) {\n      hole = hole.slice().reverse();\n    }\n\n    wallGeo = PolygonGeometryLibrary.computeWallGeometry(hole, ellipsoid, granularity, perPositionHeight, arcType);\n    geos.walls.push(new GeometryInstance({\n      geometry: wallGeo\n    }));\n  }\n\n  return geos;\n}\n/**\n * A description of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias PolygonGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n * @param {Number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\n * @param {Number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\n * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n *\n * @see PolygonGeometry#createGeometry\n * @see PolygonGeometry#fromPositions\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Polygon.html|Cesium Sandcastle Polygon Demo}\n *\n * @example\n * // 1. create a polygon from points\n * var polygon = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   )\n * });\n * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n *\n * // 2. create a nested polygon with holes\n * var polygonWithHole = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -109.0, 30.0,\n *       -95.0, 30.0,\n *       -95.0, 40.0,\n *       -109.0, 40.0\n *     ]),\n *     [new Cesium.PolygonHierarchy(\n *       Cesium.Cartesian3.fromDegreesArray([\n *         -107.0, 31.0,\n *         -107.0, 39.0,\n *         -97.0, 39.0,\n *         -97.0, 31.0\n *       ]),\n *       [new Cesium.PolygonHierarchy(\n *         Cesium.Cartesian3.fromDegreesArray([\n *           -105.0, 33.0,\n *           -99.0, 33.0,\n *           -99.0, 37.0,\n *           -105.0, 37.0\n *         ]),\n *         [new Cesium.PolygonHierarchy(\n *           Cesium.Cartesian3.fromDegreesArray([\n *             -103.0, 34.0,\n *             -101.0, 34.0,\n *             -101.0, 36.0,\n *             -103.0, 36.0\n *           ])\n *         )]\n *       )]\n *     )]\n *   )\n * });\n * var geometry = Cesium.PolygonGeometry.createGeometry(polygonWithHole);\n *\n * // 3. create extruded polygon\n * var extrudedPolygon = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   ),\n *   extrudedHeight: 300000\n * });\n * var geometry = Cesium.PolygonGeometry.createGeometry(extrudedPolygon);\n */\n\n\nfunction PolygonGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.polygonHierarchy\", options.polygonHierarchy);\n\n  if (defined(options.perPositionHeight) && options.perPositionHeight && defined(options.height)) {\n    throw new DeveloperError(\"Cannot use both options.perPositionHeight and options.height\");\n  }\n\n  if (defined(options.arcType) && options.arcType !== ArcType.GEODESIC && options.arcType !== ArcType.RHUMB) {\n    throw new DeveloperError(\"Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.\");\n  } //>>includeEnd('debug');\n\n\n  var polygonHierarchy = options.polygonHierarchy;\n  var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n  var stRotation = defaultValue(options.stRotation, 0.0);\n  var perPositionHeight = defaultValue(options.perPositionHeight, false);\n  var perPositionHeightExtrude = perPositionHeight && defined(options.extrudedHeight);\n  var height = defaultValue(options.height, 0.0);\n  var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  if (!perPositionHeightExtrude) {\n    var h = Math.max(height, extrudedHeight);\n    extrudedHeight = Math.min(height, extrudedHeight);\n    height = h;\n  }\n\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._granularity = granularity;\n  this._stRotation = stRotation;\n  this._height = height;\n  this._extrudedHeight = extrudedHeight;\n  this._closeTop = defaultValue(options.closeTop, true);\n  this._closeBottom = defaultValue(options.closeBottom, true);\n  this._polygonHierarchy = polygonHierarchy;\n  this._perPositionHeight = perPositionHeight;\n  this._perPositionHeightExtrude = perPositionHeightExtrude;\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\n  this._workerName = \"createPolygonGeometry\";\n  this._offsetAttribute = options.offsetAttribute;\n  this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n  this._rectangle = undefined;\n  this._textureCoordinateRotationPoints = undefined;\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n\n  this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + Ellipsoid.packedLength + VertexFormat.packedLength + 12;\n}\n/**\n * A description of a polygon from an array of positions. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n * @param {Number} [options.height=0.0] The height of the polygon.\n * @param {Number} [options.extrudedHeight] The height of the polygon extrusion.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\n * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n * @returns {PolygonGeometry}\n *\n *\n * @example\n * // create a polygon from points\n * var polygon = Cesium.PolygonGeometry.fromPositions({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0,\n *     -75.0, 30.0,\n *     -70.0, 30.0,\n *     -68.0, 40.0\n *   ])\n * });\n * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n *\n * @see PolygonGeometry#createGeometry\n */\n\n\nPolygonGeometry.fromPositions = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);\n\n  Check.defined(\"options.positions\", options.positions); //>>includeEnd('debug');\n\n  var newOptions = {\n    polygonHierarchy: {\n      positions: options.positions\n    },\n    height: options.height,\n    extrudedHeight: options.extrudedHeight,\n    vertexFormat: options.vertexFormat,\n    stRotation: options.stRotation,\n    ellipsoid: options.ellipsoid,\n    granularity: options.granularity,\n    perPositionHeight: options.perPositionHeight,\n    closeTop: options.closeTop,\n    closeBottom: options.closeBottom,\n    offsetAttribute: options.offsetAttribute,\n    arcType: options.arcType\n  };\n  return new PolygonGeometry(newOptions);\n};\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolygonGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\n\nPolygonGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._stRotation;\n  array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\n  array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\n  array[startingIndex++] = value._closeTop ? 1.0 : 0.0;\n  array[startingIndex++] = value._closeBottom ? 1.0 : 0.0;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex++] = defaultValue(value._offsetAttribute, -1);\n  array[startingIndex++] = value._arcType;\n  array[startingIndex] = value.packedLength;\n  return array;\n};\n\nvar scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nvar scratchVertexFormat = new VertexFormat(); //Only used to avoid inability to default construct.\n\nvar dummyOptions = {\n  polygonHierarchy: {}\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolygonGeometry} [result] The object into which to store the result.\n */\n\nPolygonGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);\n  startingIndex = polygonHierarchy.startingIndex;\n  delete polygonHierarchy.startingIndex;\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n  var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n  startingIndex += VertexFormat.packedLength;\n  var height = array[startingIndex++];\n  var extrudedHeight = array[startingIndex++];\n  var granularity = array[startingIndex++];\n  var stRotation = array[startingIndex++];\n  var perPositionHeightExtrude = array[startingIndex++] === 1.0;\n  var perPositionHeight = array[startingIndex++] === 1.0;\n  var closeTop = array[startingIndex++] === 1.0;\n  var closeBottom = array[startingIndex++] === 1.0;\n  var shadowVolume = array[startingIndex++] === 1.0;\n  var offsetAttribute = array[startingIndex++];\n  var arcType = array[startingIndex++];\n  var packedLength = array[startingIndex];\n\n  if (!defined(result)) {\n    result = new PolygonGeometry(dummyOptions);\n  }\n\n  result._polygonHierarchy = polygonHierarchy;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._granularity = granularity;\n  result._stRotation = stRotation;\n  result._perPositionHeightExtrude = perPositionHeightExtrude;\n  result._perPositionHeight = perPositionHeight;\n  result._closeTop = closeTop;\n  result._closeBottom = closeBottom;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n  result._arcType = arcType;\n  result.packedLength = packedLength;\n  return result;\n};\n/**\n * Returns the bounding rectangle given the provided options\n *\n * @param {Object} options Object with the following properties:\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions sampled.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Rectangle} [result] An object in which to store the result.\n *\n * @returns {Rectangle} The result rectangle\n */\n\n\nPolygonGeometry.computeRectangle = function (options, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.polygonHierarchy\", options.polygonHierarchy); //>>includeEnd('debug');\n\n  var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n  var arcType = defaultValue(options.arcType, ArcType.GEODESIC); //>>includeStart('debug', pragmas.debug);\n\n  if (arcType !== ArcType.GEODESIC && arcType !== ArcType.RHUMB) {\n    throw new DeveloperError(\"Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.\");\n  } //>>includeEnd('debug');\n\n\n  var polygonHierarchy = options.polygonHierarchy;\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  return computeRectangle(polygonHierarchy.positions, ellipsoid, arcType, granularity, result);\n};\n/**\n * Computes the geometric representation of a polygon, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolygonGeometry} polygonGeometry A description of the polygon.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\n\n\nPolygonGeometry.createGeometry = function (polygonGeometry) {\n  var vertexFormat = polygonGeometry._vertexFormat;\n  var ellipsoid = polygonGeometry._ellipsoid;\n  var granularity = polygonGeometry._granularity;\n  var stRotation = polygonGeometry._stRotation;\n  var polygonHierarchy = polygonGeometry._polygonHierarchy;\n  var perPositionHeight = polygonGeometry._perPositionHeight;\n  var closeTop = polygonGeometry._closeTop;\n  var closeBottom = polygonGeometry._closeBottom;\n  var arcType = polygonGeometry._arcType;\n  var outerPositions = polygonHierarchy.positions;\n\n  if (outerPositions.length < 3) {\n    return;\n  }\n\n  var tangentPlane = EllipsoidTangentPlane.fromPoints(outerPositions, ellipsoid);\n  var results = PolygonGeometryLibrary.polygonsFromHierarchy(polygonHierarchy, tangentPlane.projectPointsOntoPlane.bind(tangentPlane), !perPositionHeight, ellipsoid);\n  var hierarchy = results.hierarchy;\n  var polygons = results.polygons;\n\n  if (hierarchy.length === 0) {\n    return;\n  }\n\n  outerPositions = hierarchy[0].outerRing;\n  var boundingRectangle = PolygonGeometryLibrary.computeBoundingRectangle(tangentPlane.plane.normal, tangentPlane.projectPointOntoPlane.bind(tangentPlane), outerPositions, stRotation, scratchBoundingRectangle);\n  var geometries = [];\n  var height = polygonGeometry._height;\n  var extrudedHeight = polygonGeometry._extrudedHeight;\n  var extrude = polygonGeometry._perPositionHeightExtrude || !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n  var options = {\n    perPositionHeight: perPositionHeight,\n    vertexFormat: vertexFormat,\n    geometry: undefined,\n    tangentPlane: tangentPlane,\n    boundingRectangle: boundingRectangle,\n    ellipsoid: ellipsoid,\n    stRotation: stRotation,\n    bottom: false,\n    top: true,\n    wall: false,\n    extrude: false,\n    arcType: arcType\n  };\n  var i;\n\n  if (extrude) {\n    options.extrude = true;\n    options.top = closeTop;\n    options.bottom = closeBottom;\n    options.shadowVolume = polygonGeometry._shadowVolume;\n    options.offsetAttribute = polygonGeometry._offsetAttribute;\n\n    for (i = 0; i < polygons.length; i++) {\n      var splitGeometry = createGeometryFromPositionsExtruded(ellipsoid, polygons[i], granularity, hierarchy[i], perPositionHeight, closeTop, closeBottom, vertexFormat, arcType);\n      var topAndBottom;\n\n      if (closeTop && closeBottom) {\n        topAndBottom = splitGeometry.topAndBottom;\n        options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(topAndBottom.geometry, height, extrudedHeight, ellipsoid, perPositionHeight);\n      } else if (closeTop) {\n        topAndBottom = splitGeometry.topAndBottom;\n        topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(topAndBottom.geometry.attributes.position.values, height, ellipsoid, !perPositionHeight);\n        options.geometry = topAndBottom.geometry;\n      } else if (closeBottom) {\n        topAndBottom = splitGeometry.topAndBottom;\n        topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(topAndBottom.geometry.attributes.position.values, extrudedHeight, ellipsoid, true);\n        options.geometry = topAndBottom.geometry;\n      }\n\n      if (closeTop || closeBottom) {\n        options.wall = false;\n        topAndBottom.geometry = computeAttributes(options);\n        geometries.push(topAndBottom);\n      }\n\n      var walls = splitGeometry.walls;\n      options.wall = true;\n\n      for (var k = 0; k < walls.length; k++) {\n        var wall = walls[k];\n        options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(wall.geometry, height, extrudedHeight, ellipsoid, perPositionHeight);\n        wall.geometry = computeAttributes(options);\n        geometries.push(wall);\n      }\n    }\n  } else {\n    for (i = 0; i < polygons.length; i++) {\n      var geometryInstance = new GeometryInstance({\n        geometry: PolygonGeometryLibrary.createGeometryFromPositions(ellipsoid, polygons[i], granularity, perPositionHeight, vertexFormat, arcType)\n      });\n      geometryInstance.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(geometryInstance.geometry.attributes.position.values, height, ellipsoid, !perPositionHeight);\n      options.geometry = geometryInstance.geometry;\n      geometryInstance.geometry = computeAttributes(options);\n\n      if (defined(polygonGeometry._offsetAttribute)) {\n        var length = geometryInstance.geometry.attributes.position.values.length;\n        var applyOffset = new Uint8Array(length / 3);\n        var offsetValue = polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n        arrayFill(applyOffset, offsetValue);\n        geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute({\n          componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n          componentsPerAttribute: 1,\n          values: applyOffset\n        });\n      }\n\n      geometries.push(geometryInstance);\n    }\n  }\n\n  var geometry = GeometryPipeline.combineInstances(geometries)[0];\n  geometry.attributes.position.values = new Float64Array(geometry.attributes.position.values);\n  geometry.indices = IndexDatatype.createTypedArray(geometry.attributes.position.values.length / 3, geometry.indices);\n  var attributes = geometry.attributes;\n  var boundingSphere = BoundingSphere.fromVertices(attributes.position.values);\n\n  if (!vertexFormat.position) {\n    delete attributes.position;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: geometry.indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: boundingSphere,\n    offsetAttribute: polygonGeometry._offsetAttribute\n  });\n};\n/**\n * @private\n */\n\n\nPolygonGeometry.createShadowVolume = function (polygonGeometry, minHeightFunc, maxHeightFunc) {\n  var granularity = polygonGeometry._granularity;\n  var ellipsoid = polygonGeometry._ellipsoid;\n  var minHeight = minHeightFunc(granularity, ellipsoid);\n  var maxHeight = maxHeightFunc(granularity, ellipsoid);\n  return new PolygonGeometry({\n    polygonHierarchy: polygonGeometry._polygonHierarchy,\n    ellipsoid: ellipsoid,\n    stRotation: polygonGeometry._stRotation,\n    granularity: granularity,\n    perPositionHeight: false,\n    extrudedHeight: minHeight,\n    height: maxHeight,\n    vertexFormat: VertexFormat.POSITION_ONLY,\n    shadowVolume: true,\n    arcType: polygonGeometry._arcType\n  });\n};\n\nfunction textureCoordinateRotationPoints(polygonGeometry) {\n  var stRotation = -polygonGeometry._stRotation;\n\n  if (stRotation === 0.0) {\n    return [0, 0, 0, 1, 1, 0];\n  }\n\n  var ellipsoid = polygonGeometry._ellipsoid;\n  var positions = polygonGeometry._polygonHierarchy.positions;\n  var boundingRectangle = polygonGeometry.rectangle;\n  return Geometry._textureCoordinateRotationPoints(positions, stRotation, ellipsoid, boundingRectangle);\n}\n\nObject.defineProperties(PolygonGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function () {\n      if (!defined(this._rectangle)) {\n        var positions = this._polygonHierarchy.positions;\n        this._rectangle = computeRectangle(positions, this._ellipsoid, this._arcType, this._granularity);\n      }\n\n      return this._rectangle;\n    }\n  },\n\n  /**\n   * For remapping texture coordinates when rendering PolygonGeometries as GroundPrimitives.\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function () {\n      if (!defined(this._textureCoordinateRotationPoints)) {\n        this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(this);\n      }\n\n      return this._textureCoordinateRotationPoints;\n    }\n  }\n});\nexport default PolygonGeometry;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/PolygonGeometry.js"],"names":["ArcType","arrayFill","BoundingRectangle","BoundingSphere","Cartesian2","Cartesian3","Cartographic","Check","ComponentDatatype","defaultValue","defined","DeveloperError","Ellipsoid","EllipsoidGeodesic","EllipsoidTangentPlane","Geometry","GeometryAttribute","GeometryInstance","GeometryOffsetAttribute","GeometryPipeline","IndexDatatype","CesiumMath","Matrix3","PolygonGeometryLibrary","PolygonPipeline","Quaternion","Rectangle","VertexFormat","WindingOrder","scratchCarto1","scratchCarto2","adjustPosHeightsForNormal","position","p1","p2","ellipsoid","carto1","cartesianToCartographic","height","p1Carto","cartographicToCartesian","p2Carto","scratchBoundingRectangle","scratchPosition","scratchNormal","scratchTangent","scratchBitangent","p1Scratch","p2Scratch","scratchPerPosNormal","scratchPerPosTangent","scratchPerPosBitangent","appendTextureCoordinatesOrigin","appendTextureCoordinatesCartesian2","appendTextureCoordinatesCartesian3","appendTextureCoordinatesQuaternion","appendTextureCoordinatesMatrix3","tangentMatrixScratch","computeAttributes","options","vertexFormat","geometry","shadowVolume","flatPositions","attributes","values","length","wall","top","bottom","st","normal","tangent","bitangent","boundingRectangle","tangentPlane","stRotation","perPositionHeight","origin","x","y","textureCoordinates","Float32Array","undefined","normals","tangents","bitangents","extrudeNormals","textureCoordIndex","attrIndex","recomputeNormal","textureMatrix","tangentRotationMatrix","rotation","fromAxisAngle","_plane","fromQuaternion","clone","IDENTITY","bottomOffset","bottomOffset2","i","fromArray","p","multiplyByVector","scaleToGeodeticSurface","projectPointOntoPlane","subtract","stx","clamp","width","sty","attrIndex1","attrIndex2","normalize","cross","equalsEpsilon","EPSILON10","geodeticSurfaceNormal","UNIT_Z","z","componentDatatype","FLOAT","componentsPerAttribute","extrudeDirection","extrude","offsetAttribute","size","Uint8Array","TOP","offsetValue","NONE","applyOffset","UNSIGNED_BYTE","startCartographicScratch","endCartographicScratch","idlCross","westOverIDL","eastOverIDL","ellipsoidGeodesic","computeRectangle","positions","arcType","granularity","result","west","north","south","east","RHUMB","fromCartesianArray","equals","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","inverseChordLength","chordLength","maximumRadius","positionsLength","endCartographic","startCartographic","swap","setEndPoints","interpolateAndGrowRectangle","PI","TWO_PI","interpolatedCartographicScratch","segmentLength","surfaceDistance","numPoints","Math","ceil","subsegmentDistance","interpolationDistance","interpolatedCartographic","interpolateUsingSurfaceDistance","longitude","latitude","min","max","lonAdjusted","createGeometryFromPositionsExtrudedPositions","createGeometryFromPositionsExtruded","polygon","hierarchy","closeTop","closeBottom","geos","walls","topGeo","createGeometryFromPositions","edgePoints","indices","numPositions","newIndices","topBottomPositions","concat","createTypedArray","set","ilength","i0","i1","i2","topAndBottom","outerRing","fromPoints","positions2D","projectPointsOntoPlane","windingOrder","computeWindingOrder2D","CLOCKWISE","slice","reverse","wallGeo","computeWallGeometry","push","holes","hole","COUNTER_CLOCKWISE","PolygonGeometry","typeOf","object","polygonHierarchy","GEODESIC","DEFAULT","WGS84","RADIANS_PER_DEGREE","perPositionHeightExtrude","extrudedHeight","h","_vertexFormat","_ellipsoid","_granularity","_stRotation","_height","_extrudedHeight","_closeTop","_closeBottom","_polygonHierarchy","_perPositionHeight","_perPositionHeightExtrude","_shadowVolume","_workerName","_offsetAttribute","_arcType","_rectangle","_textureCoordinateRotationPoints","packedLength","computeHierarchyPackedLength","fromPositions","EMPTY_OBJECT","newOptions","pack","value","array","startingIndex","packPolygonHierarchy","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","dummyOptions","unpack","unpackPolygonHierarchy","createGeometry","polygonGeometry","outerPositions","results","polygonsFromHierarchy","bind","polygons","computeBoundingRectangle","plane","geometries","EPSILON2","splitGeometry","scaleToGeodeticHeightExtruded","scaleToGeodeticHeight","k","geometryInstance","combineInstances","Float64Array","boundingSphere","fromVertices","primitiveType","createShadowVolume","minHeightFunc","maxHeightFunc","minHeight","maxHeight","POSITION_ONLY","textureCoordinateRotationPoints","rectangle","Object","defineProperties","prototype","get"],"mappings":"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","sourcesContent":["import ArcType from \"./ArcType.js\";\nimport arrayFill from \"./arrayFill.js\";\nimport BoundingRectangle from \"./BoundingRectangle.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidGeodesic from \"./EllipsoidGeodesic.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolygonGeometryLibrary from \"./PolygonGeometryLibrary.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nimport WindingOrder from \"./WindingOrder.js\";\n\nvar scratchCarto1 = new Cartographic();\nvar scratchCarto2 = new Cartographic();\nfunction adjustPosHeightsForNormal(position, p1, p2, ellipsoid) {\n  var carto1 = ellipsoid.cartesianToCartographic(position, scratchCarto1);\n  var height = carto1.height;\n  var p1Carto = ellipsoid.cartesianToCartographic(p1, scratchCarto2);\n  p1Carto.height = height;\n  ellipsoid.cartographicToCartesian(p1Carto, p1);\n\n  var p2Carto = ellipsoid.cartesianToCartographic(p2, scratchCarto2);\n  p2Carto.height = height - 100;\n  ellipsoid.cartographicToCartesian(p2Carto, p2);\n}\n\nvar scratchBoundingRectangle = new BoundingRectangle();\nvar scratchPosition = new Cartesian3();\nvar scratchNormal = new Cartesian3();\nvar scratchTangent = new Cartesian3();\nvar scratchBitangent = new Cartesian3();\nvar p1Scratch = new Cartesian3();\nvar p2Scratch = new Cartesian3();\nvar scratchPerPosNormal = new Cartesian3();\nvar scratchPerPosTangent = new Cartesian3();\nvar scratchPerPosBitangent = new Cartesian3();\n\nvar appendTextureCoordinatesOrigin = new Cartesian2();\nvar appendTextureCoordinatesCartesian2 = new Cartesian2();\nvar appendTextureCoordinatesCartesian3 = new Cartesian3();\nvar appendTextureCoordinatesQuaternion = new Quaternion();\nvar appendTextureCoordinatesMatrix3 = new Matrix3();\nvar tangentMatrixScratch = new Matrix3();\n\nfunction computeAttributes(options) {\n  var vertexFormat = options.vertexFormat;\n  var geometry = options.geometry;\n  var shadowVolume = options.shadowVolume;\n  var flatPositions = geometry.attributes.position.values;\n  var length = flatPositions.length;\n  var wall = options.wall;\n  var top = options.top || wall;\n  var bottom = options.bottom || wall;\n  if (\n    vertexFormat.st ||\n    vertexFormat.normal ||\n    vertexFormat.tangent ||\n    vertexFormat.bitangent ||\n    shadowVolume\n  ) {\n    // PERFORMANCE_IDEA: Compute before subdivision, then just interpolate during subdivision.\n    // PERFORMANCE_IDEA: Compute with createGeometryFromPositions() for fast path when there's no holes.\n    var boundingRectangle = options.boundingRectangle;\n    var tangentPlane = options.tangentPlane;\n    var ellipsoid = options.ellipsoid;\n    var stRotation = options.stRotation;\n    var perPositionHeight = options.perPositionHeight;\n\n    var origin = appendTextureCoordinatesOrigin;\n    origin.x = boundingRectangle.x;\n    origin.y = boundingRectangle.y;\n\n    var textureCoordinates = vertexFormat.st\n      ? new Float32Array(2 * (length / 3))\n      : undefined;\n    var normals;\n    if (vertexFormat.normal) {\n      if (perPositionHeight && top && !wall) {\n        normals = geometry.attributes.normal.values;\n      } else {\n        normals = new Float32Array(length);\n      }\n    }\n    var tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;\n    var bitangents = vertexFormat.bitangent\n      ? new Float32Array(length)\n      : undefined;\n    var extrudeNormals = shadowVolume ? new Float32Array(length) : undefined;\n\n    var textureCoordIndex = 0;\n    var attrIndex = 0;\n\n    var normal = scratchNormal;\n    var tangent = scratchTangent;\n    var bitangent = scratchBitangent;\n    var recomputeNormal = true;\n\n    var textureMatrix = appendTextureCoordinatesMatrix3;\n    var tangentRotationMatrix = tangentMatrixScratch;\n    if (stRotation !== 0.0) {\n      var rotation = Quaternion.fromAxisAngle(\n        tangentPlane._plane.normal,\n        stRotation,\n        appendTextureCoordinatesQuaternion\n      );\n      textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n\n      rotation = Quaternion.fromAxisAngle(\n        tangentPlane._plane.normal,\n        -stRotation,\n        appendTextureCoordinatesQuaternion\n      );\n      tangentRotationMatrix = Matrix3.fromQuaternion(\n        rotation,\n        tangentRotationMatrix\n      );\n    } else {\n      textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n      tangentRotationMatrix = Matrix3.clone(\n        Matrix3.IDENTITY,\n        tangentRotationMatrix\n      );\n    }\n\n    var bottomOffset = 0;\n    var bottomOffset2 = 0;\n\n    if (top && bottom) {\n      bottomOffset = length / 2;\n      bottomOffset2 = length / 3;\n\n      length /= 2;\n    }\n\n    for (var i = 0; i < length; i += 3) {\n      var position = Cartesian3.fromArray(\n        flatPositions,\n        i,\n        appendTextureCoordinatesCartesian3\n      );\n\n      if (vertexFormat.st) {\n        var p = Matrix3.multiplyByVector(\n          textureMatrix,\n          position,\n          scratchPosition\n        );\n        p = ellipsoid.scaleToGeodeticSurface(p, p);\n        var st = tangentPlane.projectPointOntoPlane(\n          p,\n          appendTextureCoordinatesCartesian2\n        );\n        Cartesian2.subtract(st, origin, st);\n\n        var stx = CesiumMath.clamp(st.x / boundingRectangle.width, 0, 1);\n        var sty = CesiumMath.clamp(st.y / boundingRectangle.height, 0, 1);\n        if (bottom) {\n          textureCoordinates[textureCoordIndex + bottomOffset2] = stx;\n          textureCoordinates[textureCoordIndex + 1 + bottomOffset2] = sty;\n        }\n        if (top) {\n          textureCoordinates[textureCoordIndex] = stx;\n          textureCoordinates[textureCoordIndex + 1] = sty;\n        }\n\n        textureCoordIndex += 2;\n      }\n\n      if (\n        vertexFormat.normal ||\n        vertexFormat.tangent ||\n        vertexFormat.bitangent ||\n        shadowVolume\n      ) {\n        var attrIndex1 = attrIndex + 1;\n        var attrIndex2 = attrIndex + 2;\n\n        if (wall) {\n          if (i + 3 < length) {\n            var p1 = Cartesian3.fromArray(flatPositions, i + 3, p1Scratch);\n\n            if (recomputeNormal) {\n              var p2 = Cartesian3.fromArray(\n                flatPositions,\n                i + length,\n                p2Scratch\n              );\n              if (perPositionHeight) {\n                adjustPosHeightsForNormal(position, p1, p2, ellipsoid);\n              }\n              Cartesian3.subtract(p1, position, p1);\n              Cartesian3.subtract(p2, position, p2);\n              normal = Cartesian3.normalize(\n                Cartesian3.cross(p2, p1, normal),\n                normal\n              );\n              recomputeNormal = false;\n            }\n\n            if (Cartesian3.equalsEpsilon(p1, position, CesiumMath.EPSILON10)) {\n              // if we've reached a corner\n              recomputeNormal = true;\n            }\n          }\n\n          if (vertexFormat.tangent || vertexFormat.bitangent) {\n            bitangent = ellipsoid.geodeticSurfaceNormal(position, bitangent);\n            if (vertexFormat.tangent) {\n              tangent = Cartesian3.normalize(\n                Cartesian3.cross(bitangent, normal, tangent),\n                tangent\n              );\n            }\n          }\n        } else {\n          normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n          if (vertexFormat.tangent || vertexFormat.bitangent) {\n            if (perPositionHeight) {\n              scratchPerPosNormal = Cartesian3.fromArray(\n                normals,\n                attrIndex,\n                scratchPerPosNormal\n              );\n              scratchPerPosTangent = Cartesian3.cross(\n                Cartesian3.UNIT_Z,\n                scratchPerPosNormal,\n                scratchPerPosTangent\n              );\n              scratchPerPosTangent = Cartesian3.normalize(\n                Matrix3.multiplyByVector(\n                  tangentRotationMatrix,\n                  scratchPerPosTangent,\n                  scratchPerPosTangent\n                ),\n                scratchPerPosTangent\n              );\n              if (vertexFormat.bitangent) {\n                scratchPerPosBitangent = Cartesian3.normalize(\n                  Cartesian3.cross(\n                    scratchPerPosNormal,\n                    scratchPerPosTangent,\n                    scratchPerPosBitangent\n                  ),\n                  scratchPerPosBitangent\n                );\n              }\n            }\n\n            tangent = Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\n            tangent = Cartesian3.normalize(\n              Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent),\n              tangent\n            );\n            if (vertexFormat.bitangent) {\n              bitangent = Cartesian3.normalize(\n                Cartesian3.cross(normal, tangent, bitangent),\n                bitangent\n              );\n            }\n          }\n        }\n\n        if (vertexFormat.normal) {\n          if (options.wall) {\n            normals[attrIndex + bottomOffset] = normal.x;\n            normals[attrIndex1 + bottomOffset] = normal.y;\n            normals[attrIndex2 + bottomOffset] = normal.z;\n          } else if (bottom) {\n            normals[attrIndex + bottomOffset] = -normal.x;\n            normals[attrIndex1 + bottomOffset] = -normal.y;\n            normals[attrIndex2 + bottomOffset] = -normal.z;\n          }\n\n          if ((top && !perPositionHeight) || wall) {\n            normals[attrIndex] = normal.x;\n            normals[attrIndex1] = normal.y;\n            normals[attrIndex2] = normal.z;\n          }\n        }\n\n        if (shadowVolume) {\n          if (wall) {\n            normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n          }\n          extrudeNormals[attrIndex + bottomOffset] = -normal.x;\n          extrudeNormals[attrIndex1 + bottomOffset] = -normal.y;\n          extrudeNormals[attrIndex2 + bottomOffset] = -normal.z;\n        }\n\n        if (vertexFormat.tangent) {\n          if (options.wall) {\n            tangents[attrIndex + bottomOffset] = tangent.x;\n            tangents[attrIndex1 + bottomOffset] = tangent.y;\n            tangents[attrIndex2 + bottomOffset] = tangent.z;\n          } else if (bottom) {\n            tangents[attrIndex + bottomOffset] = -tangent.x;\n            tangents[attrIndex1 + bottomOffset] = -tangent.y;\n            tangents[attrIndex2 + bottomOffset] = -tangent.z;\n          }\n\n          if (top) {\n            if (perPositionHeight) {\n              tangents[attrIndex] = scratchPerPosTangent.x;\n              tangents[attrIndex1] = scratchPerPosTangent.y;\n              tangents[attrIndex2] = scratchPerPosTangent.z;\n            } else {\n              tangents[attrIndex] = tangent.x;\n              tangents[attrIndex1] = tangent.y;\n              tangents[attrIndex2] = tangent.z;\n            }\n          }\n        }\n\n        if (vertexFormat.bitangent) {\n          if (bottom) {\n            bitangents[attrIndex + bottomOffset] = bitangent.x;\n            bitangents[attrIndex1 + bottomOffset] = bitangent.y;\n            bitangents[attrIndex2 + bottomOffset] = bitangent.z;\n          }\n          if (top) {\n            if (perPositionHeight) {\n              bitangents[attrIndex] = scratchPerPosBitangent.x;\n              bitangents[attrIndex1] = scratchPerPosBitangent.y;\n              bitangents[attrIndex2] = scratchPerPosBitangent.z;\n            } else {\n              bitangents[attrIndex] = bitangent.x;\n              bitangents[attrIndex1] = bitangent.y;\n              bitangents[attrIndex2] = bitangent.z;\n            }\n          }\n        }\n        attrIndex += 3;\n      }\n    }\n\n    if (vertexFormat.st) {\n      geometry.attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: textureCoordinates,\n      });\n    }\n\n    if (vertexFormat.normal) {\n      geometry.attributes.normal = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: normals,\n      });\n    }\n\n    if (vertexFormat.tangent) {\n      geometry.attributes.tangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: tangents,\n      });\n    }\n\n    if (vertexFormat.bitangent) {\n      geometry.attributes.bitangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: bitangents,\n      });\n    }\n\n    if (shadowVolume) {\n      geometry.attributes.extrudeDirection = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: extrudeNormals,\n      });\n    }\n  }\n\n  if (options.extrude && defined(options.offsetAttribute)) {\n    var size = flatPositions.length / 3;\n    var offsetAttribute = new Uint8Array(size);\n\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      if ((top && bottom) || wall) {\n        offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n      } else if (top) {\n        offsetAttribute = arrayFill(offsetAttribute, 1);\n      }\n    } else {\n      var offsetValue =\n        options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n    }\n\n    geometry.attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute,\n    });\n  }\n\n  return geometry;\n}\n\nvar startCartographicScratch = new Cartographic();\nvar endCartographicScratch = new Cartographic();\nvar idlCross = {\n  westOverIDL: 0.0,\n  eastOverIDL: 0.0,\n};\nvar ellipsoidGeodesic = new EllipsoidGeodesic();\nfunction computeRectangle(positions, ellipsoid, arcType, granularity, result) {\n  result = defaultValue(result, new Rectangle());\n  if (!defined(positions) || positions.length < 3) {\n    result.west = 0.0;\n    result.north = 0.0;\n    result.south = 0.0;\n    result.east = 0.0;\n    return result;\n  }\n\n  if (arcType === ArcType.RHUMB) {\n    return Rectangle.fromCartesianArray(positions, ellipsoid, result);\n  }\n\n  if (!ellipsoidGeodesic.ellipsoid.equals(ellipsoid)) {\n    ellipsoidGeodesic = new EllipsoidGeodesic(undefined, undefined, ellipsoid);\n  }\n\n  result.west = Number.POSITIVE_INFINITY;\n  result.east = Number.NEGATIVE_INFINITY;\n  result.south = Number.POSITIVE_INFINITY;\n  result.north = Number.NEGATIVE_INFINITY;\n\n  idlCross.westOverIDL = Number.POSITIVE_INFINITY;\n  idlCross.eastOverIDL = Number.NEGATIVE_INFINITY;\n\n  var inverseChordLength =\n    1.0 / CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n  var positionsLength = positions.length;\n  var endCartographic = ellipsoid.cartesianToCartographic(\n    positions[0],\n    endCartographicScratch\n  );\n  var startCartographic = startCartographicScratch;\n  var swap;\n\n  for (var i = 1; i < positionsLength; i++) {\n    swap = startCartographic;\n    startCartographic = endCartographic;\n    endCartographic = ellipsoid.cartesianToCartographic(positions[i], swap);\n    ellipsoidGeodesic.setEndPoints(startCartographic, endCartographic);\n    interpolateAndGrowRectangle(\n      ellipsoidGeodesic,\n      inverseChordLength,\n      result,\n      idlCross\n    );\n  }\n\n  swap = startCartographic;\n  startCartographic = endCartographic;\n  endCartographic = ellipsoid.cartesianToCartographic(positions[0], swap);\n  ellipsoidGeodesic.setEndPoints(startCartographic, endCartographic);\n  interpolateAndGrowRectangle(\n    ellipsoidGeodesic,\n    inverseChordLength,\n    result,\n    idlCross\n  );\n\n  if (result.east - result.west > idlCross.eastOverIDL - idlCross.westOverIDL) {\n    result.west = idlCross.westOverIDL;\n    result.east = idlCross.eastOverIDL;\n\n    if (result.east > CesiumMath.PI) {\n      result.east = result.east - CesiumMath.TWO_PI;\n    }\n    if (result.west > CesiumMath.PI) {\n      result.west = result.west - CesiumMath.TWO_PI;\n    }\n  }\n\n  return result;\n}\n\nvar interpolatedCartographicScratch = new Cartographic();\nfunction interpolateAndGrowRectangle(\n  ellipsoidGeodesic,\n  inverseChordLength,\n  result,\n  idlCross\n) {\n  var segmentLength = ellipsoidGeodesic.surfaceDistance;\n\n  var numPoints = Math.ceil(segmentLength * inverseChordLength);\n  var subsegmentDistance =\n    numPoints > 0 ? segmentLength / (numPoints - 1) : Number.POSITIVE_INFINITY;\n  var interpolationDistance = 0.0;\n\n  for (var i = 0; i < numPoints; i++) {\n    var interpolatedCartographic = ellipsoidGeodesic.interpolateUsingSurfaceDistance(\n      interpolationDistance,\n      interpolatedCartographicScratch\n    );\n    interpolationDistance += subsegmentDistance;\n    var longitude = interpolatedCartographic.longitude;\n    var latitude = interpolatedCartographic.latitude;\n\n    result.west = Math.min(result.west, longitude);\n    result.east = Math.max(result.east, longitude);\n    result.south = Math.min(result.south, latitude);\n    result.north = Math.max(result.north, latitude);\n\n    var lonAdjusted =\n      longitude >= 0 ? longitude : longitude + CesiumMath.TWO_PI;\n    idlCross.westOverIDL = Math.min(idlCross.westOverIDL, lonAdjusted);\n    idlCross.eastOverIDL = Math.max(idlCross.eastOverIDL, lonAdjusted);\n  }\n}\n\nvar createGeometryFromPositionsExtrudedPositions = [];\n\nfunction createGeometryFromPositionsExtruded(\n  ellipsoid,\n  polygon,\n  granularity,\n  hierarchy,\n  perPositionHeight,\n  closeTop,\n  closeBottom,\n  vertexFormat,\n  arcType\n) {\n  var geos = {\n    walls: [],\n  };\n  var i;\n\n  if (closeTop || closeBottom) {\n    var topGeo = PolygonGeometryLibrary.createGeometryFromPositions(\n      ellipsoid,\n      polygon,\n      granularity,\n      perPositionHeight,\n      vertexFormat,\n      arcType\n    );\n\n    var edgePoints = topGeo.attributes.position.values;\n    var indices = topGeo.indices;\n    var numPositions;\n    var newIndices;\n\n    if (closeTop && closeBottom) {\n      var topBottomPositions = edgePoints.concat(edgePoints);\n\n      numPositions = topBottomPositions.length / 3;\n\n      newIndices = IndexDatatype.createTypedArray(\n        numPositions,\n        indices.length * 2\n      );\n      newIndices.set(indices);\n      var ilength = indices.length;\n\n      var length = numPositions / 2;\n\n      for (i = 0; i < ilength; i += 3) {\n        var i0 = newIndices[i] + length;\n        var i1 = newIndices[i + 1] + length;\n        var i2 = newIndices[i + 2] + length;\n\n        newIndices[i + ilength] = i2;\n        newIndices[i + 1 + ilength] = i1;\n        newIndices[i + 2 + ilength] = i0;\n      }\n\n      topGeo.attributes.position.values = topBottomPositions;\n      if (perPositionHeight && vertexFormat.normal) {\n        var normals = topGeo.attributes.normal.values;\n        topGeo.attributes.normal.values = new Float32Array(\n          topBottomPositions.length\n        );\n        topGeo.attributes.normal.values.set(normals);\n      }\n      topGeo.indices = newIndices;\n    } else if (closeBottom) {\n      numPositions = edgePoints.length / 3;\n      newIndices = IndexDatatype.createTypedArray(numPositions, indices.length);\n\n      for (i = 0; i < indices.length; i += 3) {\n        newIndices[i] = indices[i + 2];\n        newIndices[i + 1] = indices[i + 1];\n        newIndices[i + 2] = indices[i];\n      }\n\n      topGeo.indices = newIndices;\n    }\n\n    geos.topAndBottom = new GeometryInstance({\n      geometry: topGeo,\n    });\n  }\n\n  var outerRing = hierarchy.outerRing;\n  var tangentPlane = EllipsoidTangentPlane.fromPoints(outerRing, ellipsoid);\n  var positions2D = tangentPlane.projectPointsOntoPlane(\n    outerRing,\n    createGeometryFromPositionsExtrudedPositions\n  );\n\n  var windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n  if (windingOrder === WindingOrder.CLOCKWISE) {\n    outerRing = outerRing.slice().reverse();\n  }\n\n  var wallGeo = PolygonGeometryLibrary.computeWallGeometry(\n    outerRing,\n    ellipsoid,\n    granularity,\n    perPositionHeight,\n    arcType\n  );\n  geos.walls.push(\n    new GeometryInstance({\n      geometry: wallGeo,\n    })\n  );\n\n  var holes = hierarchy.holes;\n  for (i = 0; i < holes.length; i++) {\n    var hole = holes[i];\n\n    tangentPlane = EllipsoidTangentPlane.fromPoints(hole, ellipsoid);\n    positions2D = tangentPlane.projectPointsOntoPlane(\n      hole,\n      createGeometryFromPositionsExtrudedPositions\n    );\n\n    windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n    if (windingOrder === WindingOrder.COUNTER_CLOCKWISE) {\n      hole = hole.slice().reverse();\n    }\n\n    wallGeo = PolygonGeometryLibrary.computeWallGeometry(\n      hole,\n      ellipsoid,\n      granularity,\n      perPositionHeight,\n      arcType\n    );\n    geos.walls.push(\n      new GeometryInstance({\n        geometry: wallGeo,\n      })\n    );\n  }\n\n  return geos;\n}\n\n/**\n * A description of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias PolygonGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n * @param {Number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\n * @param {Number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\n * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n *\n * @see PolygonGeometry#createGeometry\n * @see PolygonGeometry#fromPositions\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Polygon.html|Cesium Sandcastle Polygon Demo}\n *\n * @example\n * // 1. create a polygon from points\n * var polygon = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   )\n * });\n * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n *\n * // 2. create a nested polygon with holes\n * var polygonWithHole = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -109.0, 30.0,\n *       -95.0, 30.0,\n *       -95.0, 40.0,\n *       -109.0, 40.0\n *     ]),\n *     [new Cesium.PolygonHierarchy(\n *       Cesium.Cartesian3.fromDegreesArray([\n *         -107.0, 31.0,\n *         -107.0, 39.0,\n *         -97.0, 39.0,\n *         -97.0, 31.0\n *       ]),\n *       [new Cesium.PolygonHierarchy(\n *         Cesium.Cartesian3.fromDegreesArray([\n *           -105.0, 33.0,\n *           -99.0, 33.0,\n *           -99.0, 37.0,\n *           -105.0, 37.0\n *         ]),\n *         [new Cesium.PolygonHierarchy(\n *           Cesium.Cartesian3.fromDegreesArray([\n *             -103.0, 34.0,\n *             -101.0, 34.0,\n *             -101.0, 36.0,\n *             -103.0, 36.0\n *           ])\n *         )]\n *       )]\n *     )]\n *   )\n * });\n * var geometry = Cesium.PolygonGeometry.createGeometry(polygonWithHole);\n *\n * // 3. create extruded polygon\n * var extrudedPolygon = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   ),\n *   extrudedHeight: 300000\n * });\n * var geometry = Cesium.PolygonGeometry.createGeometry(extrudedPolygon);\n */\nfunction PolygonGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.polygonHierarchy\", options.polygonHierarchy);\n  if (\n    defined(options.perPositionHeight) &&\n    options.perPositionHeight &&\n    defined(options.height)\n  ) {\n    throw new DeveloperError(\n      \"Cannot use both options.perPositionHeight and options.height\"\n    );\n  }\n  if (\n    defined(options.arcType) &&\n    options.arcType !== ArcType.GEODESIC &&\n    options.arcType !== ArcType.RHUMB\n  ) {\n    throw new DeveloperError(\n      \"Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var polygonHierarchy = options.polygonHierarchy;\n  var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  var stRotation = defaultValue(options.stRotation, 0.0);\n  var perPositionHeight = defaultValue(options.perPositionHeight, false);\n  var perPositionHeightExtrude =\n    perPositionHeight && defined(options.extrudedHeight);\n  var height = defaultValue(options.height, 0.0);\n  var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  if (!perPositionHeightExtrude) {\n    var h = Math.max(height, extrudedHeight);\n    extrudedHeight = Math.min(height, extrudedHeight);\n    height = h;\n  }\n\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._granularity = granularity;\n  this._stRotation = stRotation;\n  this._height = height;\n  this._extrudedHeight = extrudedHeight;\n  this._closeTop = defaultValue(options.closeTop, true);\n  this._closeBottom = defaultValue(options.closeBottom, true);\n  this._polygonHierarchy = polygonHierarchy;\n  this._perPositionHeight = perPositionHeight;\n  this._perPositionHeightExtrude = perPositionHeightExtrude;\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\n  this._workerName = \"createPolygonGeometry\";\n  this._offsetAttribute = options.offsetAttribute;\n  this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n\n  this._rectangle = undefined;\n  this._textureCoordinateRotationPoints = undefined;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  this.packedLength =\n    PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) +\n    Ellipsoid.packedLength +\n    VertexFormat.packedLength +\n    12;\n}\n\n/**\n * A description of a polygon from an array of positions. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n * @param {Number} [options.height=0.0] The height of the polygon.\n * @param {Number} [options.extrudedHeight] The height of the polygon extrusion.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\n * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n * @returns {PolygonGeometry}\n *\n *\n * @example\n * // create a polygon from points\n * var polygon = Cesium.PolygonGeometry.fromPositions({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0,\n *     -75.0, 30.0,\n *     -70.0, 30.0,\n *     -68.0, 40.0\n *   ])\n * });\n * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n *\n * @see PolygonGeometry#createGeometry\n */\nPolygonGeometry.fromPositions = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", options.positions);\n  //>>includeEnd('debug');\n\n  var newOptions = {\n    polygonHierarchy: {\n      positions: options.positions,\n    },\n    height: options.height,\n    extrudedHeight: options.extrudedHeight,\n    vertexFormat: options.vertexFormat,\n    stRotation: options.stRotation,\n    ellipsoid: options.ellipsoid,\n    granularity: options.granularity,\n    perPositionHeight: options.perPositionHeight,\n    closeTop: options.closeTop,\n    closeBottom: options.closeBottom,\n    offsetAttribute: options.offsetAttribute,\n    arcType: options.arcType,\n  };\n  return new PolygonGeometry(newOptions);\n};\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolygonGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nPolygonGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(\n    value._polygonHierarchy,\n    array,\n    startingIndex\n  );\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._stRotation;\n  array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\n  array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\n  array[startingIndex++] = value._closeTop ? 1.0 : 0.0;\n  array[startingIndex++] = value._closeBottom ? 1.0 : 0.0;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex++] = defaultValue(value._offsetAttribute, -1);\n  array[startingIndex++] = value._arcType;\n  array[startingIndex] = value.packedLength;\n\n  return array;\n};\n\nvar scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nvar scratchVertexFormat = new VertexFormat();\n\n//Only used to avoid inability to default construct.\nvar dummyOptions = {\n  polygonHierarchy: {},\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolygonGeometry} [result] The object into which to store the result.\n */\nPolygonGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(\n    array,\n    startingIndex\n  );\n  startingIndex = polygonHierarchy.startingIndex;\n  delete polygonHierarchy.startingIndex;\n\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  var vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  var height = array[startingIndex++];\n  var extrudedHeight = array[startingIndex++];\n  var granularity = array[startingIndex++];\n  var stRotation = array[startingIndex++];\n  var perPositionHeightExtrude = array[startingIndex++] === 1.0;\n  var perPositionHeight = array[startingIndex++] === 1.0;\n  var closeTop = array[startingIndex++] === 1.0;\n  var closeBottom = array[startingIndex++] === 1.0;\n  var shadowVolume = array[startingIndex++] === 1.0;\n  var offsetAttribute = array[startingIndex++];\n  var arcType = array[startingIndex++];\n  var packedLength = array[startingIndex];\n\n  if (!defined(result)) {\n    result = new PolygonGeometry(dummyOptions);\n  }\n\n  result._polygonHierarchy = polygonHierarchy;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._granularity = granularity;\n  result._stRotation = stRotation;\n  result._perPositionHeightExtrude = perPositionHeightExtrude;\n  result._perPositionHeight = perPositionHeight;\n  result._closeTop = closeTop;\n  result._closeBottom = closeBottom;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n  result._arcType = arcType;\n  result.packedLength = packedLength;\n  return result;\n};\n\n/**\n * Returns the bounding rectangle given the provided options\n *\n * @param {Object} options Object with the following properties:\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions sampled.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Rectangle} [result] An object in which to store the result.\n *\n * @returns {Rectangle} The result rectangle\n */\nPolygonGeometry.computeRectangle = function (options, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.polygonHierarchy\", options.polygonHierarchy);\n  //>>includeEnd('debug');\n\n  var granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  var arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n  //>>includeStart('debug', pragmas.debug);\n  if (arcType !== ArcType.GEODESIC && arcType !== ArcType.RHUMB) {\n    throw new DeveloperError(\n      \"Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var polygonHierarchy = options.polygonHierarchy;\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n\n  return computeRectangle(\n    polygonHierarchy.positions,\n    ellipsoid,\n    arcType,\n    granularity,\n    result\n  );\n};\n\n/**\n * Computes the geometric representation of a polygon, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolygonGeometry} polygonGeometry A description of the polygon.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPolygonGeometry.createGeometry = function (polygonGeometry) {\n  var vertexFormat = polygonGeometry._vertexFormat;\n  var ellipsoid = polygonGeometry._ellipsoid;\n  var granularity = polygonGeometry._granularity;\n  var stRotation = polygonGeometry._stRotation;\n  var polygonHierarchy = polygonGeometry._polygonHierarchy;\n  var perPositionHeight = polygonGeometry._perPositionHeight;\n  var closeTop = polygonGeometry._closeTop;\n  var closeBottom = polygonGeometry._closeBottom;\n  var arcType = polygonGeometry._arcType;\n\n  var outerPositions = polygonHierarchy.positions;\n  if (outerPositions.length < 3) {\n    return;\n  }\n\n  var tangentPlane = EllipsoidTangentPlane.fromPoints(\n    outerPositions,\n    ellipsoid\n  );\n\n  var results = PolygonGeometryLibrary.polygonsFromHierarchy(\n    polygonHierarchy,\n    tangentPlane.projectPointsOntoPlane.bind(tangentPlane),\n    !perPositionHeight,\n    ellipsoid\n  );\n\n  var hierarchy = results.hierarchy;\n  var polygons = results.polygons;\n\n  if (hierarchy.length === 0) {\n    return;\n  }\n\n  outerPositions = hierarchy[0].outerRing;\n  var boundingRectangle = PolygonGeometryLibrary.computeBoundingRectangle(\n    tangentPlane.plane.normal,\n    tangentPlane.projectPointOntoPlane.bind(tangentPlane),\n    outerPositions,\n    stRotation,\n    scratchBoundingRectangle\n  );\n\n  var geometries = [];\n\n  var height = polygonGeometry._height;\n  var extrudedHeight = polygonGeometry._extrudedHeight;\n  var extrude =\n    polygonGeometry._perPositionHeightExtrude ||\n    !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n  var options = {\n    perPositionHeight: perPositionHeight,\n    vertexFormat: vertexFormat,\n    geometry: undefined,\n    tangentPlane: tangentPlane,\n    boundingRectangle: boundingRectangle,\n    ellipsoid: ellipsoid,\n    stRotation: stRotation,\n    bottom: false,\n    top: true,\n    wall: false,\n    extrude: false,\n    arcType: arcType,\n  };\n\n  var i;\n\n  if (extrude) {\n    options.extrude = true;\n    options.top = closeTop;\n    options.bottom = closeBottom;\n    options.shadowVolume = polygonGeometry._shadowVolume;\n    options.offsetAttribute = polygonGeometry._offsetAttribute;\n    for (i = 0; i < polygons.length; i++) {\n      var splitGeometry = createGeometryFromPositionsExtruded(\n        ellipsoid,\n        polygons[i],\n        granularity,\n        hierarchy[i],\n        perPositionHeight,\n        closeTop,\n        closeBottom,\n        vertexFormat,\n        arcType\n      );\n\n      var topAndBottom;\n      if (closeTop && closeBottom) {\n        topAndBottom = splitGeometry.topAndBottom;\n        options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(\n          topAndBottom.geometry,\n          height,\n          extrudedHeight,\n          ellipsoid,\n          perPositionHeight\n        );\n      } else if (closeTop) {\n        topAndBottom = splitGeometry.topAndBottom;\n        topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n          topAndBottom.geometry.attributes.position.values,\n          height,\n          ellipsoid,\n          !perPositionHeight\n        );\n        options.geometry = topAndBottom.geometry;\n      } else if (closeBottom) {\n        topAndBottom = splitGeometry.topAndBottom;\n        topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n          topAndBottom.geometry.attributes.position.values,\n          extrudedHeight,\n          ellipsoid,\n          true\n        );\n        options.geometry = topAndBottom.geometry;\n      }\n      if (closeTop || closeBottom) {\n        options.wall = false;\n        topAndBottom.geometry = computeAttributes(options);\n        geometries.push(topAndBottom);\n      }\n\n      var walls = splitGeometry.walls;\n      options.wall = true;\n      for (var k = 0; k < walls.length; k++) {\n        var wall = walls[k];\n        options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(\n          wall.geometry,\n          height,\n          extrudedHeight,\n          ellipsoid,\n          perPositionHeight\n        );\n        wall.geometry = computeAttributes(options);\n        geometries.push(wall);\n      }\n    }\n  } else {\n    for (i = 0; i < polygons.length; i++) {\n      var geometryInstance = new GeometryInstance({\n        geometry: PolygonGeometryLibrary.createGeometryFromPositions(\n          ellipsoid,\n          polygons[i],\n          granularity,\n          perPositionHeight,\n          vertexFormat,\n          arcType\n        ),\n      });\n      geometryInstance.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n        geometryInstance.geometry.attributes.position.values,\n        height,\n        ellipsoid,\n        !perPositionHeight\n      );\n      options.geometry = geometryInstance.geometry;\n      geometryInstance.geometry = computeAttributes(options);\n\n      if (defined(polygonGeometry._offsetAttribute)) {\n        var length =\n          geometryInstance.geometry.attributes.position.values.length;\n        var applyOffset = new Uint8Array(length / 3);\n        var offsetValue =\n          polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n            ? 0\n            : 1;\n        arrayFill(applyOffset, offsetValue);\n        geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute(\n          {\n            componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n            componentsPerAttribute: 1,\n            values: applyOffset,\n          }\n        );\n      }\n\n      geometries.push(geometryInstance);\n    }\n  }\n\n  var geometry = GeometryPipeline.combineInstances(geometries)[0];\n  geometry.attributes.position.values = new Float64Array(\n    geometry.attributes.position.values\n  );\n  geometry.indices = IndexDatatype.createTypedArray(\n    geometry.attributes.position.values.length / 3,\n    geometry.indices\n  );\n\n  var attributes = geometry.attributes;\n  var boundingSphere = BoundingSphere.fromVertices(attributes.position.values);\n\n  if (!vertexFormat.position) {\n    delete attributes.position;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: geometry.indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: boundingSphere,\n    offsetAttribute: polygonGeometry._offsetAttribute,\n  });\n};\n\n/**\n * @private\n */\nPolygonGeometry.createShadowVolume = function (\n  polygonGeometry,\n  minHeightFunc,\n  maxHeightFunc\n) {\n  var granularity = polygonGeometry._granularity;\n  var ellipsoid = polygonGeometry._ellipsoid;\n\n  var minHeight = minHeightFunc(granularity, ellipsoid);\n  var maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n  return new PolygonGeometry({\n    polygonHierarchy: polygonGeometry._polygonHierarchy,\n    ellipsoid: ellipsoid,\n    stRotation: polygonGeometry._stRotation,\n    granularity: granularity,\n    perPositionHeight: false,\n    extrudedHeight: minHeight,\n    height: maxHeight,\n    vertexFormat: VertexFormat.POSITION_ONLY,\n    shadowVolume: true,\n    arcType: polygonGeometry._arcType,\n  });\n};\n\nfunction textureCoordinateRotationPoints(polygonGeometry) {\n  var stRotation = -polygonGeometry._stRotation;\n  if (stRotation === 0.0) {\n    return [0, 0, 0, 1, 1, 0];\n  }\n  var ellipsoid = polygonGeometry._ellipsoid;\n  var positions = polygonGeometry._polygonHierarchy.positions;\n  var boundingRectangle = polygonGeometry.rectangle;\n  return Geometry._textureCoordinateRotationPoints(\n    positions,\n    stRotation,\n    ellipsoid,\n    boundingRectangle\n  );\n}\n\nObject.defineProperties(PolygonGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function () {\n      if (!defined(this._rectangle)) {\n        var positions = this._polygonHierarchy.positions;\n        this._rectangle = computeRectangle(\n          positions,\n          this._ellipsoid,\n          this._arcType,\n          this._granularity\n        );\n      }\n\n      return this._rectangle;\n    },\n  },\n  /**\n   * For remapping texture coordinates when rendering PolygonGeometries as GroundPrimitives.\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function () {\n      if (!defined(this._textureCoordinateRotationPoints)) {\n        this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(\n          this\n        );\n      }\n      return this._textureCoordinateRotationPoints;\n    },\n  },\n});\nexport default PolygonGeometry;\n"]},"metadata":{},"sourceType":"module"}