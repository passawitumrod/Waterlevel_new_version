{"ast":null,"code":"import arraySlice from \"../Core/arraySlice.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport getStringFromTypedArray from \"../Core/getStringFromTypedArray.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport when from \"../ThirdParty/when.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Cesium3DTileBatchTable from \"./Cesium3DTileBatchTable.js\";\nimport Cesium3DTileFeatureTable from \"./Cesium3DTileFeatureTable.js\";\nimport DracoLoader from \"./DracoLoader.js\";\nimport getClipAndStyleCode from \"./getClipAndStyleCode.js\";\nimport getClippingFunction from \"./getClippingFunction.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nvar DecodingState = {\n  NEEDS_DECODE: 0,\n  DECODING: 1,\n  READY: 2,\n  FAILED: 3\n};\n/**\n * Represents the contents of a\n * {@link https://github.com/CesiumGS/3d-tiles/tree/master/specification/TileFormats/PointCloud|Point Cloud}\n * tile. Used internally by {@link PointCloud3DTileContent} and {@link TimeDynamicPointCloud}.\n *\n * @alias PointCloud\n * @constructor\n *\n * @see PointCloud3DTileContent\n * @see TimeDynamicPointCloud\n *\n * @private\n */\n\nfunction PointCloud(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.arrayBuffer\", options.arrayBuffer); //>>includeEnd('debug');\n  // Hold onto the payload until the render resources are created\n\n  this._parsedContent = undefined;\n  this._drawCommand = undefined;\n  this._isTranslucent = false;\n  this._styleTranslucent = false;\n  this._constantColor = Color.clone(Color.DARKGRAY);\n  this._highlightColor = Color.clone(Color.WHITE);\n  this._pointSize = 1.0;\n  this._rtcCenter = undefined;\n  this._quantizedVolumeScale = undefined;\n  this._quantizedVolumeOffset = undefined; // These values are used to regenerate the shader when the style changes\n\n  this._styleableShaderAttributes = undefined;\n  this._isQuantized = false;\n  this._isOctEncoded16P = false;\n  this._isRGB565 = false;\n  this._hasColors = false;\n  this._hasNormals = false;\n  this._hasBatchIds = false; // Draco\n\n  this._decodingState = DecodingState.READY;\n  this._dequantizeInShader = true;\n  this._isQuantizedDraco = false;\n  this._isOctEncodedDraco = false;\n  this._quantizedRange = 0.0;\n  this._octEncodedRange = 0.0; // Use per-point normals to hide back-facing points.\n\n  this.backFaceCulling = false;\n  this._backFaceCulling = false; // Whether to enable normal shading\n\n  this.normalShading = true;\n  this._normalShading = true;\n  this._opaqueRenderState = undefined;\n  this._translucentRenderState = undefined;\n  this._mode = undefined;\n  this._ready = false;\n  this._readyPromise = when.defer();\n  this._pointsLength = 0;\n  this._geometryByteLength = 0;\n  this._vertexShaderLoaded = options.vertexShaderLoaded;\n  this._fragmentShaderLoaded = options.fragmentShaderLoaded;\n  this._uniformMapLoaded = options.uniformMapLoaded;\n  this._batchTableLoaded = options.batchTableLoaded;\n  this._pickIdLoaded = options.pickIdLoaded;\n  this._opaquePass = defaultValue(options.opaquePass, Pass.OPAQUE);\n  this._cull = defaultValue(options.cull, true);\n  this.style = undefined;\n  this._style = undefined;\n  this.styleDirty = false;\n  this.modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this._modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this.time = 0.0; // For styling\n\n  this.shadows = ShadowMode.ENABLED;\n  this._boundingSphere = undefined;\n  this.clippingPlanes = undefined;\n  this.isClipped = false;\n  this.clippingPlanesDirty = false; // If defined, use this matrix to position the clipping planes instead of the modelMatrix.\n  // This is so that when point clouds are part of a tileset they all get clipped relative\n  // to the root tile.\n\n  this.clippingPlanesOriginMatrix = undefined;\n  this.attenuation = false;\n  this._attenuation = false; // Options for geometric error based attenuation\n\n  this.geometricError = 0.0;\n  this.geometricErrorScale = 1.0;\n  this.maximumAttenuation = this._pointSize;\n  initialize(this, options);\n}\n\nObject.defineProperties(PointCloud.prototype, {\n  pointsLength: {\n    get: function get() {\n      return this._pointsLength;\n    }\n  },\n  geometryByteLength: {\n    get: function get() {\n      return this._geometryByteLength;\n    }\n  },\n  ready: {\n    get: function get() {\n      return this._ready;\n    }\n  },\n  readyPromise: {\n    get: function get() {\n      return this._readyPromise.promise;\n    }\n  },\n  color: {\n    get: function get() {\n      return Color.clone(this._highlightColor);\n    },\n    set: function set(value) {\n      this._highlightColor = Color.clone(value, this._highlightColor);\n    }\n  },\n  boundingSphere: {\n    get: function get() {\n      if (defined(this._drawCommand)) {\n        return this._drawCommand.boundingVolume;\n      }\n\n      return undefined;\n    },\n    set: function set(value) {\n      this._boundingSphere = BoundingSphere.clone(value, this._boundingSphere);\n    }\n  }\n});\nvar sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\n\nfunction initialize(pointCloud, options) {\n  var arrayBuffer = options.arrayBuffer;\n  var byteOffset = defaultValue(options.byteOffset, 0);\n  var uint8Array = new Uint8Array(arrayBuffer);\n  var view = new DataView(arrayBuffer);\n  byteOffset += sizeOfUint32; // Skip magic\n\n  var version = view.getUint32(byteOffset, true);\n\n  if (version !== 1) {\n    throw new RuntimeError(\"Only Point Cloud tile version 1 is supported.  Version \" + version + \" is not.\");\n  }\n\n  byteOffset += sizeOfUint32; // Skip byteLength\n\n  byteOffset += sizeOfUint32;\n  var featureTableJsonByteLength = view.getUint32(byteOffset, true);\n\n  if (featureTableJsonByteLength === 0) {\n    throw new RuntimeError(\"Feature table must have a byte length greater than zero\");\n  }\n\n  byteOffset += sizeOfUint32;\n  var featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  var batchTableJsonByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  var batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  var featureTableString = getStringFromTypedArray(uint8Array, byteOffset, featureTableJsonByteLength);\n  var featureTableJson = JSON.parse(featureTableString);\n  byteOffset += featureTableJsonByteLength;\n  var featureTableBinary = new Uint8Array(arrayBuffer, byteOffset, featureTableBinaryByteLength);\n  byteOffset += featureTableBinaryByteLength; // Get the batch table JSON and binary\n\n  var batchTableJson;\n  var batchTableBinary;\n\n  if (batchTableJsonByteLength > 0) {\n    // Has a batch table JSON\n    var batchTableString = getStringFromTypedArray(uint8Array, byteOffset, batchTableJsonByteLength);\n    batchTableJson = JSON.parse(batchTableString);\n    byteOffset += batchTableJsonByteLength;\n\n    if (batchTableBinaryByteLength > 0) {\n      // Has a batch table binary\n      batchTableBinary = new Uint8Array(arrayBuffer, byteOffset, batchTableBinaryByteLength);\n      byteOffset += batchTableBinaryByteLength;\n    }\n  }\n\n  var featureTable = new Cesium3DTileFeatureTable(featureTableJson, featureTableBinary);\n  var pointsLength = featureTable.getGlobalProperty(\"POINTS_LENGTH\");\n  featureTable.featuresLength = pointsLength;\n\n  if (!defined(pointsLength)) {\n    throw new RuntimeError(\"Feature table global property: POINTS_LENGTH must be defined\");\n  }\n\n  var rtcCenter = featureTable.getGlobalProperty(\"RTC_CENTER\", ComponentDatatype.FLOAT, 3);\n\n  if (defined(rtcCenter)) {\n    pointCloud._rtcCenter = Cartesian3.unpack(rtcCenter);\n  }\n\n  var positions;\n  var colors;\n  var normals;\n  var batchIds;\n  var hasPositions = false;\n  var hasColors = false;\n  var hasNormals = false;\n  var hasBatchIds = false;\n  var isQuantized = false;\n  var isTranslucent = false;\n  var isRGB565 = false;\n  var isOctEncoded16P = false;\n  var dracoBuffer;\n  var dracoFeatureTableProperties;\n  var dracoBatchTableProperties;\n  var featureTableDraco = defined(featureTableJson.extensions) ? featureTableJson.extensions[\"3DTILES_draco_point_compression\"] : undefined;\n  var batchTableDraco = defined(batchTableJson) && defined(batchTableJson.extensions) ? batchTableJson.extensions[\"3DTILES_draco_point_compression\"] : undefined;\n\n  if (defined(batchTableDraco)) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n\n  if (defined(featureTableDraco)) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    var dracoByteOffset = featureTableDraco.byteOffset;\n    var dracoByteLength = featureTableDraco.byteLength;\n\n    if (!defined(dracoFeatureTableProperties) || !defined(dracoByteOffset) || !defined(dracoByteLength)) {\n      throw new RuntimeError(\"Draco properties, byteOffset, and byteLength must be defined\");\n    }\n\n    dracoBuffer = arraySlice(featureTableBinary, dracoByteOffset, dracoByteOffset + dracoByteLength);\n    hasPositions = defined(dracoFeatureTableProperties.POSITION);\n    hasColors = defined(dracoFeatureTableProperties.RGB) || defined(dracoFeatureTableProperties.RGBA);\n    hasNormals = defined(dracoFeatureTableProperties.NORMAL);\n    hasBatchIds = defined(dracoFeatureTableProperties.BATCH_ID);\n    isTranslucent = defined(dracoFeatureTableProperties.RGBA);\n    pointCloud._decodingState = DecodingState.NEEDS_DECODE;\n  }\n\n  var draco;\n\n  if (defined(dracoBuffer)) {\n    draco = {\n      buffer: dracoBuffer,\n      featureTableProperties: dracoFeatureTableProperties,\n      batchTableProperties: dracoBatchTableProperties,\n      properties: combine(dracoFeatureTableProperties, dracoBatchTableProperties),\n      dequantizeInShader: pointCloud._dequantizeInShader\n    };\n  }\n\n  if (!hasPositions) {\n    if (defined(featureTableJson.POSITION)) {\n      positions = featureTable.getPropertyArray(\"POSITION\", ComponentDatatype.FLOAT, 3);\n      hasPositions = true;\n    } else if (defined(featureTableJson.POSITION_QUANTIZED)) {\n      positions = featureTable.getPropertyArray(\"POSITION_QUANTIZED\", ComponentDatatype.UNSIGNED_SHORT, 3);\n      isQuantized = true;\n      hasPositions = true;\n      var quantizedVolumeScale = featureTable.getGlobalProperty(\"QUANTIZED_VOLUME_SCALE\", ComponentDatatype.FLOAT, 3);\n\n      if (!defined(quantizedVolumeScale)) {\n        throw new RuntimeError(\"Global property: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.\");\n      }\n\n      pointCloud._quantizedVolumeScale = Cartesian3.unpack(quantizedVolumeScale);\n      pointCloud._quantizedRange = (1 << 16) - 1;\n      var quantizedVolumeOffset = featureTable.getGlobalProperty(\"QUANTIZED_VOLUME_OFFSET\", ComponentDatatype.FLOAT, 3);\n\n      if (!defined(quantizedVolumeOffset)) {\n        throw new RuntimeError(\"Global property: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.\");\n      }\n\n      pointCloud._quantizedVolumeOffset = Cartesian3.unpack(quantizedVolumeOffset);\n    }\n  }\n\n  if (!hasColors) {\n    if (defined(featureTableJson.RGBA)) {\n      colors = featureTable.getPropertyArray(\"RGBA\", ComponentDatatype.UNSIGNED_BYTE, 4);\n      isTranslucent = true;\n      hasColors = true;\n    } else if (defined(featureTableJson.RGB)) {\n      colors = featureTable.getPropertyArray(\"RGB\", ComponentDatatype.UNSIGNED_BYTE, 3);\n      hasColors = true;\n    } else if (defined(featureTableJson.RGB565)) {\n      colors = featureTable.getPropertyArray(\"RGB565\", ComponentDatatype.UNSIGNED_SHORT, 1);\n      isRGB565 = true;\n      hasColors = true;\n    }\n  }\n\n  if (!hasNormals) {\n    if (defined(featureTableJson.NORMAL)) {\n      normals = featureTable.getPropertyArray(\"NORMAL\", ComponentDatatype.FLOAT, 3);\n      hasNormals = true;\n    } else if (defined(featureTableJson.NORMAL_OCT16P)) {\n      normals = featureTable.getPropertyArray(\"NORMAL_OCT16P\", ComponentDatatype.UNSIGNED_BYTE, 2);\n      isOctEncoded16P = true;\n      hasNormals = true;\n    }\n  }\n\n  if (!hasBatchIds) {\n    if (defined(featureTableJson.BATCH_ID)) {\n      batchIds = featureTable.getPropertyArray(\"BATCH_ID\", ComponentDatatype.UNSIGNED_SHORT, 1);\n      hasBatchIds = true;\n    }\n  }\n\n  if (!hasPositions) {\n    throw new RuntimeError(\"Either POSITION or POSITION_QUANTIZED must be defined.\");\n  }\n\n  if (defined(featureTableJson.CONSTANT_RGBA)) {\n    var constantRGBA = featureTable.getGlobalProperty(\"CONSTANT_RGBA\", ComponentDatatype.UNSIGNED_BYTE, 4);\n    pointCloud._constantColor = Color.fromBytes(constantRGBA[0], constantRGBA[1], constantRGBA[2], constantRGBA[3], pointCloud._constantColor);\n  }\n\n  if (hasBatchIds) {\n    var batchLength = featureTable.getGlobalProperty(\"BATCH_LENGTH\");\n\n    if (!defined(batchLength)) {\n      throw new RuntimeError(\"Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.\");\n    }\n\n    if (defined(batchTableBinary)) {\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n    }\n\n    if (defined(pointCloud._batchTableLoaded)) {\n      pointCloud._batchTableLoaded(batchLength, batchTableJson, batchTableBinary);\n    }\n  } // If points are not batched and there are per-point properties, use these properties for styling purposes\n\n\n  var styleableProperties;\n\n  if (!hasBatchIds && defined(batchTableBinary)) {\n    styleableProperties = Cesium3DTileBatchTable.getBinaryProperties(pointsLength, batchTableJson, batchTableBinary);\n  }\n\n  pointCloud._parsedContent = {\n    positions: positions,\n    colors: colors,\n    normals: normals,\n    batchIds: batchIds,\n    styleableProperties: styleableProperties,\n    draco: draco\n  };\n  pointCloud._pointsLength = pointsLength;\n  pointCloud._isQuantized = isQuantized;\n  pointCloud._isOctEncoded16P = isOctEncoded16P;\n  pointCloud._isRGB565 = isRGB565;\n  pointCloud._isTranslucent = isTranslucent;\n  pointCloud._hasColors = hasColors;\n  pointCloud._hasNormals = hasNormals;\n  pointCloud._hasBatchIds = hasBatchIds;\n}\n\nvar scratchMin = new Cartesian3();\nvar scratchMax = new Cartesian3();\nvar scratchPosition = new Cartesian3();\nvar randomValues;\n\nfunction getRandomValues(samplesLength) {\n  // Use same random values across all runs\n  if (!defined(randomValues)) {\n    CesiumMath.setRandomNumberSeed(0);\n    randomValues = new Array(samplesLength);\n\n    for (var i = 0; i < samplesLength; ++i) {\n      randomValues[i] = CesiumMath.nextRandomNumber();\n    }\n  }\n\n  return randomValues;\n}\n\nfunction computeApproximateBoundingSphereFromPositions(positions) {\n  var maximumSamplesLength = 20;\n  var pointsLength = positions.length / 3;\n  var samplesLength = Math.min(pointsLength, maximumSamplesLength);\n  var randomValues = getRandomValues(maximumSamplesLength);\n  var maxValue = Number.MAX_VALUE;\n  var minValue = -Number.MAX_VALUE;\n  var min = Cartesian3.fromElements(maxValue, maxValue, maxValue, scratchMin);\n  var max = Cartesian3.fromElements(minValue, minValue, minValue, scratchMax);\n\n  for (var i = 0; i < samplesLength; ++i) {\n    var index = Math.floor(randomValues[i] * pointsLength);\n    var position = Cartesian3.unpack(positions, index * 3, scratchPosition);\n    Cartesian3.minimumByComponent(min, position, min);\n    Cartesian3.maximumByComponent(max, position, max);\n  }\n\n  var boundingSphere = BoundingSphere.fromCornerPoints(min, max);\n  boundingSphere.radius += CesiumMath.EPSILON2; // To avoid radius of zero\n\n  return boundingSphere;\n}\n\nfunction prepareVertexAttribute(typedArray, name) {\n  // WebGL does not support UNSIGNED_INT, INT, or DOUBLE vertex attributes. Convert these to FLOAT.\n  var componentDatatype = ComponentDatatype.fromTypedArray(typedArray);\n\n  if (componentDatatype === ComponentDatatype.INT || componentDatatype === ComponentDatatype.UNSIGNED_INT || componentDatatype === ComponentDatatype.DOUBLE) {\n    oneTimeWarning(\"Cast pnts property to floats\", 'Point cloud property \"' + name + '\" will be casted to a float array because INT, UNSIGNED_INT, and DOUBLE are not valid WebGL vertex attribute types. Some precision may be lost.');\n    return new Float32Array(typedArray);\n  }\n\n  return typedArray;\n}\n\nvar scratchPointSizeAndTimeAndGeometricErrorAndDepthMultiplier = new Cartesian4();\nvar scratchQuantizedVolumeScaleAndOctEncodedRange = new Cartesian4();\nvar scratchColor = new Color();\nvar positionLocation = 0;\nvar colorLocation = 1;\nvar normalLocation = 2;\nvar batchIdLocation = 3;\nvar numberOfAttributes = 4;\nvar scratchClippingPlaneMatrix = new Matrix4();\n\nfunction createResources(pointCloud, frameState) {\n  var context = frameState.context;\n  var parsedContent = pointCloud._parsedContent;\n  var pointsLength = pointCloud._pointsLength;\n  var positions = parsedContent.positions;\n  var colors = parsedContent.colors;\n  var normals = parsedContent.normals;\n  var batchIds = parsedContent.batchIds;\n  var styleableProperties = parsedContent.styleableProperties;\n  var hasStyleableProperties = defined(styleableProperties);\n  var isQuantized = pointCloud._isQuantized;\n  var isQuantizedDraco = pointCloud._isQuantizedDraco;\n  var isOctEncoded16P = pointCloud._isOctEncoded16P;\n  var isOctEncodedDraco = pointCloud._isOctEncodedDraco;\n  var quantizedRange = pointCloud._quantizedRange;\n  var octEncodedRange = pointCloud._octEncodedRange;\n  var isRGB565 = pointCloud._isRGB565;\n  var isTranslucent = pointCloud._isTranslucent;\n  var hasColors = pointCloud._hasColors;\n  var hasNormals = pointCloud._hasNormals;\n  var hasBatchIds = pointCloud._hasBatchIds;\n  var componentsPerAttribute;\n  var componentDatatype;\n  var styleableVertexAttributes = [];\n  var styleableShaderAttributes = {};\n  pointCloud._styleableShaderAttributes = styleableShaderAttributes;\n\n  if (hasStyleableProperties) {\n    var attributeLocation = numberOfAttributes;\n\n    for (var name in styleableProperties) {\n      if (styleableProperties.hasOwnProperty(name)) {\n        var property = styleableProperties[name];\n        var typedArray = prepareVertexAttribute(property.typedArray, name);\n        componentsPerAttribute = property.componentCount;\n        componentDatatype = ComponentDatatype.fromTypedArray(typedArray);\n        var vertexBuffer = Buffer.createVertexBuffer({\n          context: context,\n          typedArray: typedArray,\n          usage: BufferUsage.STATIC_DRAW\n        });\n        pointCloud._geometryByteLength += vertexBuffer.sizeInBytes;\n        var vertexAttribute = {\n          index: attributeLocation,\n          vertexBuffer: vertexBuffer,\n          componentsPerAttribute: componentsPerAttribute,\n          componentDatatype: componentDatatype,\n          normalize: false,\n          offsetInBytes: 0,\n          strideInBytes: 0\n        };\n        styleableVertexAttributes.push(vertexAttribute);\n        styleableShaderAttributes[name] = {\n          location: attributeLocation,\n          componentCount: componentsPerAttribute\n        };\n        ++attributeLocation;\n      }\n    }\n  }\n\n  var positionsVertexBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: positions,\n    usage: BufferUsage.STATIC_DRAW\n  });\n  pointCloud._geometryByteLength += positionsVertexBuffer.sizeInBytes;\n  var colorsVertexBuffer;\n\n  if (hasColors) {\n    colorsVertexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: colors,\n      usage: BufferUsage.STATIC_DRAW\n    });\n    pointCloud._geometryByteLength += colorsVertexBuffer.sizeInBytes;\n  }\n\n  var normalsVertexBuffer;\n\n  if (hasNormals) {\n    normalsVertexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: normals,\n      usage: BufferUsage.STATIC_DRAW\n    });\n    pointCloud._geometryByteLength += normalsVertexBuffer.sizeInBytes;\n  }\n\n  var batchIdsVertexBuffer;\n\n  if (hasBatchIds) {\n    batchIds = prepareVertexAttribute(batchIds, \"batchIds\");\n    batchIdsVertexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: batchIds,\n      usage: BufferUsage.STATIC_DRAW\n    });\n    pointCloud._geometryByteLength += batchIdsVertexBuffer.sizeInBytes;\n  }\n\n  var attributes = [];\n\n  if (isQuantized) {\n    componentDatatype = ComponentDatatype.UNSIGNED_SHORT;\n  } else if (isQuantizedDraco) {\n    componentDatatype = quantizedRange <= 255 ? ComponentDatatype.UNSIGNED_BYTE : ComponentDatatype.UNSIGNED_SHORT;\n  } else {\n    componentDatatype = ComponentDatatype.FLOAT;\n  }\n\n  attributes.push({\n    index: positionLocation,\n    vertexBuffer: positionsVertexBuffer,\n    componentsPerAttribute: 3,\n    componentDatatype: componentDatatype,\n    normalize: false,\n    offsetInBytes: 0,\n    strideInBytes: 0\n  });\n\n  if (pointCloud._cull) {\n    if (isQuantized || isQuantizedDraco) {\n      pointCloud._boundingSphere = BoundingSphere.fromCornerPoints(Cartesian3.ZERO, pointCloud._quantizedVolumeScale);\n    } else {\n      pointCloud._boundingSphere = computeApproximateBoundingSphereFromPositions(positions);\n    }\n  }\n\n  if (hasColors) {\n    if (isRGB565) {\n      attributes.push({\n        index: colorLocation,\n        vertexBuffer: colorsVertexBuffer,\n        componentsPerAttribute: 1,\n        componentDatatype: ComponentDatatype.UNSIGNED_SHORT,\n        normalize: false,\n        offsetInBytes: 0,\n        strideInBytes: 0\n      });\n    } else {\n      var colorComponentsPerAttribute = isTranslucent ? 4 : 3;\n      attributes.push({\n        index: colorLocation,\n        vertexBuffer: colorsVertexBuffer,\n        componentsPerAttribute: colorComponentsPerAttribute,\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        normalize: true,\n        offsetInBytes: 0,\n        strideInBytes: 0\n      });\n    }\n  }\n\n  if (hasNormals) {\n    if (isOctEncoded16P) {\n      componentsPerAttribute = 2;\n      componentDatatype = ComponentDatatype.UNSIGNED_BYTE;\n    } else if (isOctEncodedDraco) {\n      componentsPerAttribute = 2;\n      componentDatatype = octEncodedRange <= 255 ? ComponentDatatype.UNSIGNED_BYTE : ComponentDatatype.UNSIGNED_SHORT;\n    } else {\n      componentsPerAttribute = 3;\n      componentDatatype = ComponentDatatype.FLOAT;\n    }\n\n    attributes.push({\n      index: normalLocation,\n      vertexBuffer: normalsVertexBuffer,\n      componentsPerAttribute: componentsPerAttribute,\n      componentDatatype: componentDatatype,\n      normalize: false,\n      offsetInBytes: 0,\n      strideInBytes: 0\n    });\n  }\n\n  if (hasBatchIds) {\n    attributes.push({\n      index: batchIdLocation,\n      vertexBuffer: batchIdsVertexBuffer,\n      componentsPerAttribute: 1,\n      componentDatatype: ComponentDatatype.fromTypedArray(batchIds),\n      normalize: false,\n      offsetInBytes: 0,\n      strideInBytes: 0\n    });\n  }\n\n  if (hasStyleableProperties) {\n    attributes = attributes.concat(styleableVertexAttributes);\n  }\n\n  var vertexArray = new VertexArray({\n    context: context,\n    attributes: attributes\n  });\n  var opaqueRenderState = {\n    depthTest: {\n      enabled: true\n    }\n  };\n\n  if (pointCloud._opaquePass === Pass.CESIUM_3D_TILE) {\n    opaqueRenderState.stencilTest = StencilConstants.setCesium3DTileBit();\n    opaqueRenderState.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK;\n  }\n\n  pointCloud._opaqueRenderState = RenderState.fromCache(opaqueRenderState);\n  pointCloud._translucentRenderState = RenderState.fromCache({\n    depthTest: {\n      enabled: true\n    },\n    depthMask: false,\n    blending: BlendingState.ALPHA_BLEND\n  });\n  pointCloud._drawCommand = new DrawCommand({\n    boundingVolume: new BoundingSphere(),\n    cull: pointCloud._cull,\n    modelMatrix: new Matrix4(),\n    primitiveType: PrimitiveType.POINTS,\n    vertexArray: vertexArray,\n    count: pointsLength,\n    shaderProgram: undefined,\n    // Updated in createShaders\n    uniformMap: undefined,\n    // Updated in createShaders\n    renderState: isTranslucent ? pointCloud._translucentRenderState : pointCloud._opaqueRenderState,\n    pass: isTranslucent ? Pass.TRANSLUCENT : pointCloud._opaquePass,\n    owner: pointCloud,\n    castShadows: false,\n    receiveShadows: false,\n    pickId: pointCloud._pickIdLoaded()\n  });\n}\n\nfunction createUniformMap(pointCloud, frameState) {\n  var context = frameState.context;\n  var isQuantized = pointCloud._isQuantized;\n  var isQuantizedDraco = pointCloud._isQuantizedDraco;\n  var isOctEncodedDraco = pointCloud._isOctEncodedDraco;\n  var uniformMap = {\n    u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier: function u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier() {\n      var scratch = scratchPointSizeAndTimeAndGeometricErrorAndDepthMultiplier;\n      scratch.x = pointCloud._attenuation ? pointCloud.maximumAttenuation : pointCloud._pointSize;\n      scratch.x *= frameState.pixelRatio;\n      scratch.y = pointCloud.time;\n\n      if (pointCloud._attenuation) {\n        var frustum = frameState.camera.frustum;\n        var depthMultiplier; // Attenuation is maximumAttenuation in 2D/ortho\n\n        if (frameState.mode === SceneMode.SCENE2D || frustum instanceof OrthographicFrustum) {\n          depthMultiplier = Number.POSITIVE_INFINITY;\n        } else {\n          depthMultiplier = context.drawingBufferHeight / frameState.camera.frustum.sseDenominator;\n        }\n\n        scratch.z = pointCloud.geometricError * pointCloud.geometricErrorScale;\n        scratch.w = depthMultiplier;\n      }\n\n      return scratch;\n    },\n    u_highlightColor: function u_highlightColor() {\n      return pointCloud._highlightColor;\n    },\n    u_constantColor: function u_constantColor() {\n      return pointCloud._constantColor;\n    },\n    u_clippingPlanes: function u_clippingPlanes() {\n      var clippingPlanes = pointCloud.clippingPlanes;\n      var isClipped = pointCloud.isClipped;\n      return isClipped ? clippingPlanes.texture : context.defaultTexture;\n    },\n    u_clippingPlanesEdgeStyle: function u_clippingPlanesEdgeStyle() {\n      var clippingPlanes = pointCloud.clippingPlanes;\n\n      if (!defined(clippingPlanes)) {\n        return Color.TRANSPARENT;\n      }\n\n      var style = Color.clone(clippingPlanes.edgeColor, scratchColor);\n      style.alpha = clippingPlanes.edgeWidth;\n      return style;\n    },\n    u_clippingPlanesMatrix: function u_clippingPlanesMatrix() {\n      var clippingPlanes = pointCloud.clippingPlanes;\n\n      if (!defined(clippingPlanes)) {\n        return Matrix4.IDENTITY;\n      }\n\n      var clippingPlanesOriginMatrix = defaultValue(pointCloud.clippingPlanesOriginMatrix, pointCloud._modelMatrix);\n      Matrix4.multiply(context.uniformState.view3D, clippingPlanesOriginMatrix, scratchClippingPlaneMatrix);\n      return Matrix4.multiply(scratchClippingPlaneMatrix, clippingPlanes.modelMatrix, scratchClippingPlaneMatrix);\n    }\n  };\n\n  if (isQuantized || isQuantizedDraco || isOctEncodedDraco) {\n    uniformMap = combine(uniformMap, {\n      u_quantizedVolumeScaleAndOctEncodedRange: function u_quantizedVolumeScaleAndOctEncodedRange() {\n        var scratch = scratchQuantizedVolumeScaleAndOctEncodedRange;\n\n        if (defined(pointCloud._quantizedVolumeScale)) {\n          var scale = Cartesian3.clone(pointCloud._quantizedVolumeScale, scratch);\n          Cartesian3.divideByScalar(scale, pointCloud._quantizedRange, scratch);\n        }\n\n        scratch.w = pointCloud._octEncodedRange;\n        return scratch;\n      }\n    });\n  }\n\n  if (defined(pointCloud._uniformMapLoaded)) {\n    uniformMap = pointCloud._uniformMapLoaded(uniformMap);\n  }\n\n  pointCloud._drawCommand.uniformMap = uniformMap;\n}\n\nvar defaultProperties = [\"POSITION\", \"COLOR\", \"NORMAL\", \"POSITION_ABSOLUTE\"];\n\nfunction getStyleableProperties(source, properties) {\n  // Get all the properties used by this style\n  var regex = /czm_tiles3d_style_(\\w+)/g;\n  var matches = regex.exec(source);\n\n  while (matches !== null) {\n    var name = matches[1];\n\n    if (properties.indexOf(name) === -1) {\n      properties.push(name);\n    }\n\n    matches = regex.exec(source);\n  }\n}\n\nfunction getVertexAttribute(vertexArray, index) {\n  var numberOfAttributes = vertexArray.numberOfAttributes;\n\n  for (var i = 0; i < numberOfAttributes; ++i) {\n    var attribute = vertexArray.getAttribute(i);\n\n    if (attribute.index === index) {\n      return attribute;\n    }\n  }\n}\n\nfunction modifyStyleFunction(source) {\n  // Replace occurrences of czm_tiles3d_style_DEFAULTPROPERTY\n  var length = defaultProperties.length;\n\n  for (var i = 0; i < length; ++i) {\n    var property = defaultProperties[i];\n    var styleName = \"czm_tiles3d_style_\" + property;\n    var replaceName = property.toLowerCase();\n    source = source.replace(new RegExp(styleName + \"(\\\\W)\", \"g\"), replaceName + \"$1\");\n  } // Edit the function header to accept the point position, color, and normal\n\n\n  return source.replace(\"()\", \"(vec3 position, vec3 position_absolute, vec4 color, vec3 normal)\");\n}\n\nfunction createShaders(pointCloud, frameState, style) {\n  var i;\n  var name;\n  var attribute;\n  var context = frameState.context;\n  var hasStyle = defined(style);\n  var isQuantized = pointCloud._isQuantized;\n  var isQuantizedDraco = pointCloud._isQuantizedDraco;\n  var isOctEncoded16P = pointCloud._isOctEncoded16P;\n  var isOctEncodedDraco = pointCloud._isOctEncodedDraco;\n  var isRGB565 = pointCloud._isRGB565;\n  var isTranslucent = pointCloud._isTranslucent;\n  var hasColors = pointCloud._hasColors;\n  var hasNormals = pointCloud._hasNormals;\n  var hasBatchIds = pointCloud._hasBatchIds;\n  var backFaceCulling = pointCloud._backFaceCulling;\n  var normalShading = pointCloud._normalShading;\n  var vertexArray = pointCloud._drawCommand.vertexArray;\n  var clippingPlanes = pointCloud.clippingPlanes;\n  var attenuation = pointCloud._attenuation;\n  var colorStyleFunction;\n  var showStyleFunction;\n  var pointSizeStyleFunction;\n  var styleTranslucent = isTranslucent;\n\n  if (hasStyle) {\n    var shaderState = {\n      translucent: false\n    };\n    colorStyleFunction = style.getColorShaderFunction(\"getColorFromStyle\", \"czm_tiles3d_style_\", shaderState);\n    showStyleFunction = style.getShowShaderFunction(\"getShowFromStyle\", \"czm_tiles3d_style_\", shaderState);\n    pointSizeStyleFunction = style.getPointSizeShaderFunction(\"getPointSizeFromStyle\", \"czm_tiles3d_style_\", shaderState);\n\n    if (defined(colorStyleFunction) && shaderState.translucent) {\n      styleTranslucent = true;\n    }\n  }\n\n  pointCloud._styleTranslucent = styleTranslucent;\n  var hasColorStyle = defined(colorStyleFunction);\n  var hasShowStyle = defined(showStyleFunction);\n  var hasPointSizeStyle = defined(pointSizeStyleFunction);\n  var hasClippedContent = pointCloud.isClipped; // Get the properties in use by the style\n\n  var styleableProperties = [];\n\n  if (hasColorStyle) {\n    getStyleableProperties(colorStyleFunction, styleableProperties);\n    colorStyleFunction = modifyStyleFunction(colorStyleFunction);\n  }\n\n  if (hasShowStyle) {\n    getStyleableProperties(showStyleFunction, styleableProperties);\n    showStyleFunction = modifyStyleFunction(showStyleFunction);\n  }\n\n  if (hasPointSizeStyle) {\n    getStyleableProperties(pointSizeStyleFunction, styleableProperties);\n    pointSizeStyleFunction = modifyStyleFunction(pointSizeStyleFunction);\n  }\n\n  var usesColorSemantic = styleableProperties.indexOf(\"COLOR\") >= 0;\n  var usesNormalSemantic = styleableProperties.indexOf(\"NORMAL\") >= 0; // Split default properties from user properties\n\n  var userProperties = styleableProperties.filter(function (property) {\n    return defaultProperties.indexOf(property) === -1;\n  });\n\n  if (usesNormalSemantic && !hasNormals) {\n    throw new RuntimeError(\"Style references the NORMAL semantic but the point cloud does not have normals\");\n  } // Disable vertex attributes that aren't used in the style, enable attributes that are\n\n\n  var styleableShaderAttributes = pointCloud._styleableShaderAttributes;\n\n  for (name in styleableShaderAttributes) {\n    if (styleableShaderAttributes.hasOwnProperty(name)) {\n      attribute = styleableShaderAttributes[name];\n      var enabled = userProperties.indexOf(name) >= 0;\n      var vertexAttribute = getVertexAttribute(vertexArray, attribute.location);\n      vertexAttribute.enabled = enabled;\n    }\n  }\n\n  var usesColors = hasColors && (!hasColorStyle || usesColorSemantic);\n\n  if (hasColors) {\n    // Disable the color vertex attribute if the color style does not reference the color semantic\n    var colorVertexAttribute = getVertexAttribute(vertexArray, colorLocation);\n    colorVertexAttribute.enabled = usesColors;\n  }\n\n  var usesNormals = hasNormals && (normalShading || backFaceCulling || usesNormalSemantic);\n\n  if (hasNormals) {\n    // Disable the normal vertex attribute if normals are not used\n    var normalVertexAttribute = getVertexAttribute(vertexArray, normalLocation);\n    normalVertexAttribute.enabled = usesNormals;\n  }\n\n  var attributeLocations = {\n    a_position: positionLocation\n  };\n\n  if (usesColors) {\n    attributeLocations.a_color = colorLocation;\n  }\n\n  if (usesNormals) {\n    attributeLocations.a_normal = normalLocation;\n  }\n\n  if (hasBatchIds) {\n    attributeLocations.a_batchId = batchIdLocation;\n  }\n\n  var attributeDeclarations = \"\";\n  var length = userProperties.length;\n\n  for (i = 0; i < length; ++i) {\n    name = userProperties[i];\n    attribute = styleableShaderAttributes[name];\n\n    if (!defined(attribute)) {\n      throw new RuntimeError('Style references a property \"' + name + '\" that does not exist or is not styleable.');\n    }\n\n    var componentCount = attribute.componentCount;\n    var attributeName = \"czm_tiles3d_style_\" + name;\n    var attributeType;\n\n    if (componentCount === 1) {\n      attributeType = \"float\";\n    } else {\n      attributeType = \"vec\" + componentCount;\n    }\n\n    attributeDeclarations += \"attribute \" + attributeType + \" \" + attributeName + \"; \\n\";\n    attributeLocations[attributeName] = attribute.location;\n  }\n\n  createUniformMap(pointCloud, frameState);\n  var vs = \"attribute vec3 a_position; \\n\" + \"varying vec4 v_color; \\n\" + \"uniform vec4 u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier; \\n\" + \"uniform vec4 u_constantColor; \\n\" + \"uniform vec4 u_highlightColor; \\n\";\n  vs += \"float u_pointSize; \\n\" + \"float u_time; \\n\";\n\n  if (attenuation) {\n    vs += \"float u_geometricError; \\n\" + \"float u_depthMultiplier; \\n\";\n  }\n\n  vs += attributeDeclarations;\n\n  if (usesColors) {\n    if (isTranslucent) {\n      vs += \"attribute vec4 a_color; \\n\";\n    } else if (isRGB565) {\n      vs += \"attribute float a_color; \\n\" + \"const float SHIFT_RIGHT_11 = 1.0 / 2048.0; \\n\" + \"const float SHIFT_RIGHT_5 = 1.0 / 32.0; \\n\" + \"const float SHIFT_LEFT_11 = 2048.0; \\n\" + \"const float SHIFT_LEFT_5 = 32.0; \\n\" + \"const float NORMALIZE_6 = 1.0 / 64.0; \\n\" + \"const float NORMALIZE_5 = 1.0 / 32.0; \\n\";\n    } else {\n      vs += \"attribute vec3 a_color; \\n\";\n    }\n  }\n\n  if (usesNormals) {\n    if (isOctEncoded16P || isOctEncodedDraco) {\n      vs += \"attribute vec2 a_normal; \\n\";\n    } else {\n      vs += \"attribute vec3 a_normal; \\n\";\n    }\n  }\n\n  if (hasBatchIds) {\n    vs += \"attribute float a_batchId; \\n\";\n  }\n\n  if (isQuantized || isQuantizedDraco || isOctEncodedDraco) {\n    vs += \"uniform vec4 u_quantizedVolumeScaleAndOctEncodedRange; \\n\";\n  }\n\n  if (hasColorStyle) {\n    vs += colorStyleFunction;\n  }\n\n  if (hasShowStyle) {\n    vs += showStyleFunction;\n  }\n\n  if (hasPointSizeStyle) {\n    vs += pointSizeStyleFunction;\n  }\n\n  vs += \"void main() \\n\" + \"{ \\n\" + \"    u_pointSize = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.x; \\n\" + \"    u_time = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.y; \\n\";\n\n  if (attenuation) {\n    vs += \"    u_geometricError = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.z; \\n\" + \"    u_depthMultiplier = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.w; \\n\";\n  }\n\n  if (usesColors) {\n    if (isTranslucent) {\n      vs += \"    vec4 color = a_color; \\n\";\n    } else if (isRGB565) {\n      vs += \"    float compressed = a_color; \\n\" + \"    float r = floor(compressed * SHIFT_RIGHT_11); \\n\" + \"    compressed -= r * SHIFT_LEFT_11; \\n\" + \"    float g = floor(compressed * SHIFT_RIGHT_5); \\n\" + \"    compressed -= g * SHIFT_LEFT_5; \\n\" + \"    float b = compressed; \\n\" + \"    vec3 rgb = vec3(r * NORMALIZE_5, g * NORMALIZE_6, b * NORMALIZE_5); \\n\" + \"    vec4 color = vec4(rgb, 1.0); \\n\";\n    } else {\n      vs += \"    vec4 color = vec4(a_color, 1.0); \\n\";\n    }\n  } else {\n    vs += \"    vec4 color = u_constantColor; \\n\";\n  }\n\n  if (isQuantized || isQuantizedDraco) {\n    vs += \"    vec3 position = a_position * u_quantizedVolumeScaleAndOctEncodedRange.xyz; \\n\";\n  } else {\n    vs += \"    vec3 position = a_position; \\n\";\n  }\n\n  vs += \"    vec3 position_absolute = vec3(czm_model * vec4(position, 1.0)); \\n\";\n\n  if (usesNormals) {\n    if (isOctEncoded16P) {\n      vs += \"    vec3 normal = czm_octDecode(a_normal); \\n\";\n    } else if (isOctEncodedDraco) {\n      // Draco oct-encoding decodes to zxy order\n      vs += \"    vec3 normal = czm_octDecode(a_normal, u_quantizedVolumeScaleAndOctEncodedRange.w).zxy; \\n\";\n    } else {\n      vs += \"    vec3 normal = a_normal; \\n\";\n    }\n\n    vs += \"    vec3 normalEC = czm_normal * normal; \\n\";\n  } else {\n    vs += \"    vec3 normal = vec3(1.0); \\n\";\n  }\n\n  if (hasColorStyle) {\n    vs += \"    color = getColorFromStyle(position, position_absolute, color, normal); \\n\";\n  }\n\n  if (hasShowStyle) {\n    vs += \"    float show = float(getShowFromStyle(position, position_absolute, color, normal)); \\n\";\n  }\n\n  if (hasPointSizeStyle) {\n    vs += \"    gl_PointSize = getPointSizeFromStyle(position, position_absolute, color, normal) * czm_pixelRatio; \\n\";\n  } else if (attenuation) {\n    vs += \"    vec4 positionEC = czm_modelView * vec4(position, 1.0); \\n\" + \"    float depth = -positionEC.z; \\n\" + // compute SSE for this point\n    \"    gl_PointSize = min((u_geometricError / depth) * u_depthMultiplier, u_pointSize); \\n\";\n  } else {\n    vs += \"    gl_PointSize = u_pointSize; \\n\";\n  }\n\n  vs += \"    color = color * u_highlightColor; \\n\";\n\n  if (usesNormals && normalShading) {\n    vs += \"    float diffuseStrength = czm_getLambertDiffuse(czm_lightDirectionEC, normalEC); \\n\" + \"    diffuseStrength = max(diffuseStrength, 0.4); \\n\" + // Apply some ambient lighting\n    \"    color.xyz *= diffuseStrength * czm_lightColor; \\n\";\n  }\n\n  vs += \"    v_color = color; \\n\" + \"    gl_Position = czm_modelViewProjection * vec4(position, 1.0); \\n\";\n\n  if (usesNormals && backFaceCulling) {\n    vs += \"    float visible = step(-normalEC.z, 0.0); \\n\" + \"    gl_Position *= visible; \\n\" + \"    gl_PointSize *= visible; \\n\";\n  }\n\n  if (hasShowStyle) {\n    vs += \"    gl_Position.w *= float(show); \\n\" + \"    gl_PointSize *= float(show); \\n\";\n  }\n\n  vs += \"} \\n\";\n  var fs = \"varying vec4 v_color; \\n\";\n\n  if (hasClippedContent) {\n    fs += \"uniform sampler2D u_clippingPlanes; \\n\" + \"uniform mat4 u_clippingPlanesMatrix; \\n\" + \"uniform vec4 u_clippingPlanesEdgeStyle; \\n\";\n    fs += \"\\n\";\n    fs += getClippingFunction(clippingPlanes, context);\n    fs += \"\\n\";\n  }\n\n  fs += \"void main() \\n\" + \"{ \\n\" + \"    gl_FragColor = czm_gammaCorrect(v_color); \\n\";\n\n  if (hasClippedContent) {\n    fs += getClipAndStyleCode(\"u_clippingPlanes\", \"u_clippingPlanesMatrix\", \"u_clippingPlanesEdgeStyle\");\n  }\n\n  fs += \"} \\n\";\n\n  if (defined(pointCloud._vertexShaderLoaded)) {\n    vs = pointCloud._vertexShaderLoaded(vs);\n  }\n\n  if (defined(pointCloud._fragmentShaderLoaded)) {\n    fs = pointCloud._fragmentShaderLoaded(fs);\n  }\n\n  var drawCommand = pointCloud._drawCommand;\n\n  if (defined(drawCommand.shaderProgram)) {\n    // Destroy the old shader\n    drawCommand.shaderProgram.destroy();\n  }\n\n  drawCommand.shaderProgram = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations\n  });\n\n  try {\n    // Check if the shader compiles correctly. If not there is likely a syntax error with the style.\n    drawCommand.shaderProgram._bind();\n  } catch (error) {\n    // Rephrase the error.\n    throw new RuntimeError(\"Error generating style shader: this may be caused by a type mismatch, index out-of-bounds, or other syntax error.\");\n  }\n}\n\nfunction decodeDraco(pointCloud, context) {\n  if (pointCloud._decodingState === DecodingState.READY) {\n    return false;\n  }\n\n  if (pointCloud._decodingState === DecodingState.NEEDS_DECODE) {\n    var parsedContent = pointCloud._parsedContent;\n    var draco = parsedContent.draco;\n    var decodePromise = DracoLoader.decodePointCloud(draco, context);\n\n    if (defined(decodePromise)) {\n      pointCloud._decodingState = DecodingState.DECODING;\n      decodePromise.then(function (result) {\n        pointCloud._decodingState = DecodingState.READY;\n        var decodedPositions = defined(result.POSITION) ? result.POSITION.array : undefined;\n        var decodedRgb = defined(result.RGB) ? result.RGB.array : undefined;\n        var decodedRgba = defined(result.RGBA) ? result.RGBA.array : undefined;\n        var decodedNormals = defined(result.NORMAL) ? result.NORMAL.array : undefined;\n        var decodedBatchIds = defined(result.BATCH_ID) ? result.BATCH_ID.array : undefined;\n        var isQuantizedDraco = defined(decodedPositions) && defined(result.POSITION.data.quantization);\n        var isOctEncodedDraco = defined(decodedNormals) && defined(result.NORMAL.data.quantization);\n\n        if (isQuantizedDraco) {\n          // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n          // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n          var quantization = result.POSITION.data.quantization;\n          var range = quantization.range;\n          pointCloud._quantizedVolumeScale = Cartesian3.fromElements(range, range, range);\n          pointCloud._quantizedVolumeOffset = Cartesian3.unpack(quantization.minValues);\n          pointCloud._quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n          pointCloud._isQuantizedDraco = true;\n        }\n\n        if (isOctEncodedDraco) {\n          pointCloud._octEncodedRange = (1 << result.NORMAL.data.quantization.quantizationBits) - 1.0;\n          pointCloud._isOctEncodedDraco = true;\n        }\n\n        var styleableProperties = parsedContent.styleableProperties;\n        var batchTableProperties = draco.batchTableProperties;\n\n        for (var name in batchTableProperties) {\n          if (batchTableProperties.hasOwnProperty(name)) {\n            var property = result[name];\n\n            if (!defined(styleableProperties)) {\n              styleableProperties = {};\n            }\n\n            styleableProperties[name] = {\n              typedArray: property.array,\n              componentCount: property.data.componentsPerAttribute\n            };\n          }\n        }\n\n        parsedContent.positions = defaultValue(decodedPositions, parsedContent.positions);\n        parsedContent.colors = defaultValue(defaultValue(decodedRgba, decodedRgb), parsedContent.colors);\n        parsedContent.normals = defaultValue(decodedNormals, parsedContent.normals);\n        parsedContent.batchIds = defaultValue(decodedBatchIds, parsedContent.batchIds);\n        parsedContent.styleableProperties = styleableProperties;\n      }).otherwise(function (error) {\n        pointCloud._decodingState = DecodingState.FAILED;\n\n        pointCloud._readyPromise.reject(error);\n      });\n    }\n  }\n\n  return true;\n}\n\nvar scratchComputedTranslation = new Cartesian4();\nvar scratchScale = new Cartesian3();\n\nPointCloud.prototype.update = function (frameState) {\n  var context = frameState.context;\n  var decoding = decodeDraco(this, context);\n\n  if (decoding) {\n    return;\n  }\n\n  var shadersDirty = false;\n  var modelMatrixDirty = !Matrix4.equals(this._modelMatrix, this.modelMatrix);\n\n  if (this._mode !== frameState.mode) {\n    this._mode = frameState.mode;\n    modelMatrixDirty = true;\n  }\n\n  if (!defined(this._drawCommand)) {\n    createResources(this, frameState);\n    modelMatrixDirty = true;\n    shadersDirty = true;\n    this._ready = true;\n\n    this._readyPromise.resolve(this);\n\n    this._parsedContent = undefined; // Unload\n  }\n\n  if (modelMatrixDirty) {\n    Matrix4.clone(this.modelMatrix, this._modelMatrix);\n    var modelMatrix = this._drawCommand.modelMatrix;\n    Matrix4.clone(this._modelMatrix, modelMatrix);\n\n    if (defined(this._rtcCenter)) {\n      Matrix4.multiplyByTranslation(modelMatrix, this._rtcCenter, modelMatrix);\n    }\n\n    if (defined(this._quantizedVolumeOffset)) {\n      Matrix4.multiplyByTranslation(modelMatrix, this._quantizedVolumeOffset, modelMatrix);\n    }\n\n    if (frameState.mode !== SceneMode.SCENE3D) {\n      var projection = frameState.mapProjection;\n      var translation = Matrix4.getColumn(modelMatrix, 3, scratchComputedTranslation);\n\n      if (!Cartesian4.equals(translation, Cartesian4.UNIT_W)) {\n        Transforms.basisTo2D(projection, modelMatrix, modelMatrix);\n      }\n    }\n\n    var boundingSphere = this._drawCommand.boundingVolume;\n    BoundingSphere.clone(this._boundingSphere, boundingSphere);\n\n    if (this._cull) {\n      var center = boundingSphere.center;\n      Matrix4.multiplyByPoint(modelMatrix, center, center);\n      var scale = Matrix4.getScale(modelMatrix, scratchScale);\n      boundingSphere.radius *= Cartesian3.maximumComponent(scale);\n    }\n  }\n\n  if (this.clippingPlanesDirty) {\n    this.clippingPlanesDirty = false;\n    shadersDirty = true;\n  }\n\n  if (this._attenuation !== this.attenuation) {\n    this._attenuation = this.attenuation;\n    shadersDirty = true;\n  }\n\n  if (this.backFaceCulling !== this._backFaceCulling) {\n    this._backFaceCulling = this.backFaceCulling;\n    shadersDirty = true;\n  }\n\n  if (this.normalShading !== this._normalShading) {\n    this._normalShading = this.normalShading;\n    shadersDirty = true;\n  }\n\n  if (this._style !== this.style || this.styleDirty) {\n    this._style = this.style;\n    this.styleDirty = false;\n    shadersDirty = true;\n  }\n\n  if (shadersDirty) {\n    createShaders(this, frameState, this._style);\n  }\n\n  this._drawCommand.castShadows = ShadowMode.castShadows(this.shadows);\n  this._drawCommand.receiveShadows = ShadowMode.receiveShadows(this.shadows); // Update the render state\n\n  var isTranslucent = this._highlightColor.alpha < 1.0 || this._constantColor.alpha < 1.0 || this._styleTranslucent;\n  this._drawCommand.renderState = isTranslucent ? this._translucentRenderState : this._opaqueRenderState;\n  this._drawCommand.pass = isTranslucent ? Pass.TRANSLUCENT : this._opaquePass;\n  var commandList = frameState.commandList;\n  var passes = frameState.passes;\n\n  if (passes.render || passes.pick) {\n    commandList.push(this._drawCommand);\n  }\n};\n\nPointCloud.prototype.isDestroyed = function () {\n  return false;\n};\n\nPointCloud.prototype.destroy = function () {\n  var command = this._drawCommand;\n\n  if (defined(command)) {\n    command.vertexArray = command.vertexArray && command.vertexArray.destroy();\n    command.shaderProgram = command.shaderProgram && command.shaderProgram.destroy();\n  }\n\n  return destroyObject(this);\n};\n\nexport default PointCloud;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/PointCloud.js"],"names":["arraySlice","BoundingSphere","Cartesian3","Cartesian4","Check","Color","combine","ComponentDatatype","defaultValue","defined","destroyObject","getStringFromTypedArray","CesiumMath","Matrix4","oneTimeWarning","OrthographicFrustum","PrimitiveType","RuntimeError","Transforms","Buffer","BufferUsage","DrawCommand","Pass","RenderState","ShaderProgram","VertexArray","when","BlendingState","Cesium3DTileBatchTable","Cesium3DTileFeatureTable","DracoLoader","getClipAndStyleCode","getClippingFunction","SceneMode","ShadowMode","StencilConstants","DecodingState","NEEDS_DECODE","DECODING","READY","FAILED","PointCloud","options","typeOf","object","arrayBuffer","_parsedContent","undefined","_drawCommand","_isTranslucent","_styleTranslucent","_constantColor","clone","DARKGRAY","_highlightColor","WHITE","_pointSize","_rtcCenter","_quantizedVolumeScale","_quantizedVolumeOffset","_styleableShaderAttributes","_isQuantized","_isOctEncoded16P","_isRGB565","_hasColors","_hasNormals","_hasBatchIds","_decodingState","_dequantizeInShader","_isQuantizedDraco","_isOctEncodedDraco","_quantizedRange","_octEncodedRange","backFaceCulling","_backFaceCulling","normalShading","_normalShading","_opaqueRenderState","_translucentRenderState","_mode","_ready","_readyPromise","defer","_pointsLength","_geometryByteLength","_vertexShaderLoaded","vertexShaderLoaded","_fragmentShaderLoaded","fragmentShaderLoaded","_uniformMapLoaded","uniformMapLoaded","_batchTableLoaded","batchTableLoaded","_pickIdLoaded","pickIdLoaded","_opaquePass","opaquePass","OPAQUE","_cull","cull","style","_style","styleDirty","modelMatrix","IDENTITY","_modelMatrix","time","shadows","ENABLED","_boundingSphere","clippingPlanes","isClipped","clippingPlanesDirty","clippingPlanesOriginMatrix","attenuation","_attenuation","geometricError","geometricErrorScale","maximumAttenuation","initialize","Object","defineProperties","prototype","pointsLength","get","geometryByteLength","ready","readyPromise","promise","color","set","value","boundingSphere","boundingVolume","sizeOfUint32","Uint32Array","BYTES_PER_ELEMENT","pointCloud","byteOffset","uint8Array","Uint8Array","view","DataView","version","getUint32","featureTableJsonByteLength","featureTableBinaryByteLength","batchTableJsonByteLength","batchTableBinaryByteLength","featureTableString","featureTableJson","JSON","parse","featureTableBinary","batchTableJson","batchTableBinary","batchTableString","featureTable","getGlobalProperty","featuresLength","rtcCenter","FLOAT","unpack","positions","colors","normals","batchIds","hasPositions","hasColors","hasNormals","hasBatchIds","isQuantized","isTranslucent","isRGB565","isOctEncoded16P","dracoBuffer","dracoFeatureTableProperties","dracoBatchTableProperties","featureTableDraco","extensions","batchTableDraco","properties","dracoByteOffset","dracoByteLength","byteLength","POSITION","RGB","RGBA","NORMAL","BATCH_ID","draco","buffer","featureTableProperties","batchTableProperties","dequantizeInShader","getPropertyArray","POSITION_QUANTIZED","UNSIGNED_SHORT","quantizedVolumeScale","quantizedVolumeOffset","UNSIGNED_BYTE","RGB565","NORMAL_OCT16P","CONSTANT_RGBA","constantRGBA","fromBytes","batchLength","styleableProperties","getBinaryProperties","scratchMin","scratchMax","scratchPosition","randomValues","getRandomValues","samplesLength","setRandomNumberSeed","Array","i","nextRandomNumber","computeApproximateBoundingSphereFromPositions","maximumSamplesLength","length","Math","min","maxValue","Number","MAX_VALUE","minValue","fromElements","max","index","floor","position","minimumByComponent","maximumByComponent","fromCornerPoints","radius","EPSILON2","prepareVertexAttribute","typedArray","name","componentDatatype","fromTypedArray","INT","UNSIGNED_INT","DOUBLE","Float32Array","scratchPointSizeAndTimeAndGeometricErrorAndDepthMultiplier","scratchQuantizedVolumeScaleAndOctEncodedRange","scratchColor","positionLocation","colorLocation","normalLocation","batchIdLocation","numberOfAttributes","scratchClippingPlaneMatrix","createResources","frameState","context","parsedContent","hasStyleableProperties","isQuantizedDraco","isOctEncodedDraco","quantizedRange","octEncodedRange","componentsPerAttribute","styleableVertexAttributes","styleableShaderAttributes","attributeLocation","hasOwnProperty","property","componentCount","vertexBuffer","createVertexBuffer","usage","STATIC_DRAW","sizeInBytes","vertexAttribute","normalize","offsetInBytes","strideInBytes","push","location","positionsVertexBuffer","colorsVertexBuffer","normalsVertexBuffer","batchIdsVertexBuffer","attributes","ZERO","colorComponentsPerAttribute","concat","vertexArray","opaqueRenderState","depthTest","enabled","CESIUM_3D_TILE","stencilTest","setCesium3DTileBit","stencilMask","CESIUM_3D_TILE_MASK","fromCache","depthMask","blending","ALPHA_BLEND","primitiveType","POINTS","count","shaderProgram","uniformMap","renderState","pass","TRANSLUCENT","owner","castShadows","receiveShadows","pickId","createUniformMap","u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier","scratch","x","pixelRatio","y","frustum","camera","depthMultiplier","mode","SCENE2D","POSITIVE_INFINITY","drawingBufferHeight","sseDenominator","z","w","u_highlightColor","u_constantColor","u_clippingPlanes","texture","defaultTexture","u_clippingPlanesEdgeStyle","TRANSPARENT","edgeColor","alpha","edgeWidth","u_clippingPlanesMatrix","multiply","uniformState","view3D","u_quantizedVolumeScaleAndOctEncodedRange","scale","divideByScalar","defaultProperties","getStyleableProperties","source","regex","matches","exec","indexOf","getVertexAttribute","attribute","getAttribute","modifyStyleFunction","styleName","replaceName","toLowerCase","replace","RegExp","createShaders","hasStyle","colorStyleFunction","showStyleFunction","pointSizeStyleFunction","styleTranslucent","shaderState","translucent","getColorShaderFunction","getShowShaderFunction","getPointSizeShaderFunction","hasColorStyle","hasShowStyle","hasPointSizeStyle","hasClippedContent","usesColorSemantic","usesNormalSemantic","userProperties","filter","usesColors","colorVertexAttribute","usesNormals","normalVertexAttribute","attributeLocations","a_position","a_color","a_normal","a_batchId","attributeDeclarations","attributeName","attributeType","vs","fs","drawCommand","destroy","vertexShaderSource","fragmentShaderSource","_bind","error","decodeDraco","decodePromise","decodePointCloud","then","result","decodedPositions","array","decodedRgb","decodedRgba","decodedNormals","decodedBatchIds","data","quantization","range","minValues","quantizationBits","otherwise","reject","scratchComputedTranslation","scratchScale","update","decoding","shadersDirty","modelMatrixDirty","equals","resolve","multiplyByTranslation","SCENE3D","projection","mapProjection","translation","getColumn","UNIT_W","basisTo2D","center","multiplyByPoint","getScale","maximumComponent","commandList","passes","render","pick","isDestroyed","command"],"mappings":"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","sourcesContent":["import arraySlice from \"../Core/arraySlice.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport getStringFromTypedArray from \"../Core/getStringFromTypedArray.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport when from \"../ThirdParty/when.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Cesium3DTileBatchTable from \"./Cesium3DTileBatchTable.js\";\nimport Cesium3DTileFeatureTable from \"./Cesium3DTileFeatureTable.js\";\nimport DracoLoader from \"./DracoLoader.js\";\nimport getClipAndStyleCode from \"./getClipAndStyleCode.js\";\nimport getClippingFunction from \"./getClippingFunction.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\nimport StencilConstants from \"./StencilConstants.js\";\n\nvar DecodingState = {\n  NEEDS_DECODE: 0,\n  DECODING: 1,\n  READY: 2,\n  FAILED: 3,\n};\n\n/**\n * Represents the contents of a\n * {@link https://github.com/CesiumGS/3d-tiles/tree/master/specification/TileFormats/PointCloud|Point Cloud}\n * tile. Used internally by {@link PointCloud3DTileContent} and {@link TimeDynamicPointCloud}.\n *\n * @alias PointCloud\n * @constructor\n *\n * @see PointCloud3DTileContent\n * @see TimeDynamicPointCloud\n *\n * @private\n */\nfunction PointCloud(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.arrayBuffer\", options.arrayBuffer);\n  //>>includeEnd('debug');\n\n  // Hold onto the payload until the render resources are created\n  this._parsedContent = undefined;\n\n  this._drawCommand = undefined;\n  this._isTranslucent = false;\n  this._styleTranslucent = false;\n  this._constantColor = Color.clone(Color.DARKGRAY);\n  this._highlightColor = Color.clone(Color.WHITE);\n  this._pointSize = 1.0;\n\n  this._rtcCenter = undefined;\n  this._quantizedVolumeScale = undefined;\n  this._quantizedVolumeOffset = undefined;\n\n  // These values are used to regenerate the shader when the style changes\n  this._styleableShaderAttributes = undefined;\n  this._isQuantized = false;\n  this._isOctEncoded16P = false;\n  this._isRGB565 = false;\n  this._hasColors = false;\n  this._hasNormals = false;\n  this._hasBatchIds = false;\n\n  // Draco\n  this._decodingState = DecodingState.READY;\n  this._dequantizeInShader = true;\n  this._isQuantizedDraco = false;\n  this._isOctEncodedDraco = false;\n  this._quantizedRange = 0.0;\n  this._octEncodedRange = 0.0;\n\n  // Use per-point normals to hide back-facing points.\n  this.backFaceCulling = false;\n  this._backFaceCulling = false;\n\n  // Whether to enable normal shading\n  this.normalShading = true;\n  this._normalShading = true;\n\n  this._opaqueRenderState = undefined;\n  this._translucentRenderState = undefined;\n\n  this._mode = undefined;\n\n  this._ready = false;\n  this._readyPromise = when.defer();\n  this._pointsLength = 0;\n  this._geometryByteLength = 0;\n\n  this._vertexShaderLoaded = options.vertexShaderLoaded;\n  this._fragmentShaderLoaded = options.fragmentShaderLoaded;\n  this._uniformMapLoaded = options.uniformMapLoaded;\n  this._batchTableLoaded = options.batchTableLoaded;\n  this._pickIdLoaded = options.pickIdLoaded;\n  this._opaquePass = defaultValue(options.opaquePass, Pass.OPAQUE);\n  this._cull = defaultValue(options.cull, true);\n\n  this.style = undefined;\n  this._style = undefined;\n  this.styleDirty = false;\n\n  this.modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this._modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n\n  this.time = 0.0; // For styling\n  this.shadows = ShadowMode.ENABLED;\n  this._boundingSphere = undefined;\n\n  this.clippingPlanes = undefined;\n  this.isClipped = false;\n  this.clippingPlanesDirty = false;\n  // If defined, use this matrix to position the clipping planes instead of the modelMatrix.\n  // This is so that when point clouds are part of a tileset they all get clipped relative\n  // to the root tile.\n  this.clippingPlanesOriginMatrix = undefined;\n\n  this.attenuation = false;\n  this._attenuation = false;\n\n  // Options for geometric error based attenuation\n  this.geometricError = 0.0;\n  this.geometricErrorScale = 1.0;\n  this.maximumAttenuation = this._pointSize;\n\n  initialize(this, options);\n}\n\nObject.defineProperties(PointCloud.prototype, {\n  pointsLength: {\n    get: function () {\n      return this._pointsLength;\n    },\n  },\n\n  geometryByteLength: {\n    get: function () {\n      return this._geometryByteLength;\n    },\n  },\n\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n\n  color: {\n    get: function () {\n      return Color.clone(this._highlightColor);\n    },\n    set: function (value) {\n      this._highlightColor = Color.clone(value, this._highlightColor);\n    },\n  },\n\n  boundingSphere: {\n    get: function () {\n      if (defined(this._drawCommand)) {\n        return this._drawCommand.boundingVolume;\n      }\n      return undefined;\n    },\n    set: function (value) {\n      this._boundingSphere = BoundingSphere.clone(value, this._boundingSphere);\n    },\n  },\n});\n\nvar sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\n\nfunction initialize(pointCloud, options) {\n  var arrayBuffer = options.arrayBuffer;\n  var byteOffset = defaultValue(options.byteOffset, 0);\n\n  var uint8Array = new Uint8Array(arrayBuffer);\n  var view = new DataView(arrayBuffer);\n  byteOffset += sizeOfUint32; // Skip magic\n\n  var version = view.getUint32(byteOffset, true);\n  if (version !== 1) {\n    throw new RuntimeError(\n      \"Only Point Cloud tile version 1 is supported.  Version \" +\n        version +\n        \" is not.\"\n    );\n  }\n  byteOffset += sizeOfUint32;\n\n  // Skip byteLength\n  byteOffset += sizeOfUint32;\n\n  var featureTableJsonByteLength = view.getUint32(byteOffset, true);\n  if (featureTableJsonByteLength === 0) {\n    throw new RuntimeError(\n      \"Feature table must have a byte length greater than zero\"\n    );\n  }\n  byteOffset += sizeOfUint32;\n\n  var featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  var batchTableJsonByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  var batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  var featureTableString = getStringFromTypedArray(\n    uint8Array,\n    byteOffset,\n    featureTableJsonByteLength\n  );\n  var featureTableJson = JSON.parse(featureTableString);\n  byteOffset += featureTableJsonByteLength;\n\n  var featureTableBinary = new Uint8Array(\n    arrayBuffer,\n    byteOffset,\n    featureTableBinaryByteLength\n  );\n  byteOffset += featureTableBinaryByteLength;\n\n  // Get the batch table JSON and binary\n  var batchTableJson;\n  var batchTableBinary;\n  if (batchTableJsonByteLength > 0) {\n    // Has a batch table JSON\n    var batchTableString = getStringFromTypedArray(\n      uint8Array,\n      byteOffset,\n      batchTableJsonByteLength\n    );\n    batchTableJson = JSON.parse(batchTableString);\n    byteOffset += batchTableJsonByteLength;\n\n    if (batchTableBinaryByteLength > 0) {\n      // Has a batch table binary\n      batchTableBinary = new Uint8Array(\n        arrayBuffer,\n        byteOffset,\n        batchTableBinaryByteLength\n      );\n      byteOffset += batchTableBinaryByteLength;\n    }\n  }\n\n  var featureTable = new Cesium3DTileFeatureTable(\n    featureTableJson,\n    featureTableBinary\n  );\n\n  var pointsLength = featureTable.getGlobalProperty(\"POINTS_LENGTH\");\n  featureTable.featuresLength = pointsLength;\n\n  if (!defined(pointsLength)) {\n    throw new RuntimeError(\n      \"Feature table global property: POINTS_LENGTH must be defined\"\n    );\n  }\n\n  var rtcCenter = featureTable.getGlobalProperty(\n    \"RTC_CENTER\",\n    ComponentDatatype.FLOAT,\n    3\n  );\n  if (defined(rtcCenter)) {\n    pointCloud._rtcCenter = Cartesian3.unpack(rtcCenter);\n  }\n\n  var positions;\n  var colors;\n  var normals;\n  var batchIds;\n\n  var hasPositions = false;\n  var hasColors = false;\n  var hasNormals = false;\n  var hasBatchIds = false;\n\n  var isQuantized = false;\n  var isTranslucent = false;\n  var isRGB565 = false;\n  var isOctEncoded16P = false;\n\n  var dracoBuffer;\n  var dracoFeatureTableProperties;\n  var dracoBatchTableProperties;\n\n  var featureTableDraco = defined(featureTableJson.extensions)\n    ? featureTableJson.extensions[\"3DTILES_draco_point_compression\"]\n    : undefined;\n  var batchTableDraco =\n    defined(batchTableJson) && defined(batchTableJson.extensions)\n      ? batchTableJson.extensions[\"3DTILES_draco_point_compression\"]\n      : undefined;\n\n  if (defined(batchTableDraco)) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n\n  if (defined(featureTableDraco)) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    var dracoByteOffset = featureTableDraco.byteOffset;\n    var dracoByteLength = featureTableDraco.byteLength;\n    if (\n      !defined(dracoFeatureTableProperties) ||\n      !defined(dracoByteOffset) ||\n      !defined(dracoByteLength)\n    ) {\n      throw new RuntimeError(\n        \"Draco properties, byteOffset, and byteLength must be defined\"\n      );\n    }\n    dracoBuffer = arraySlice(\n      featureTableBinary,\n      dracoByteOffset,\n      dracoByteOffset + dracoByteLength\n    );\n    hasPositions = defined(dracoFeatureTableProperties.POSITION);\n    hasColors =\n      defined(dracoFeatureTableProperties.RGB) ||\n      defined(dracoFeatureTableProperties.RGBA);\n    hasNormals = defined(dracoFeatureTableProperties.NORMAL);\n    hasBatchIds = defined(dracoFeatureTableProperties.BATCH_ID);\n    isTranslucent = defined(dracoFeatureTableProperties.RGBA);\n    pointCloud._decodingState = DecodingState.NEEDS_DECODE;\n  }\n\n  var draco;\n  if (defined(dracoBuffer)) {\n    draco = {\n      buffer: dracoBuffer,\n      featureTableProperties: dracoFeatureTableProperties,\n      batchTableProperties: dracoBatchTableProperties,\n      properties: combine(\n        dracoFeatureTableProperties,\n        dracoBatchTableProperties\n      ),\n      dequantizeInShader: pointCloud._dequantizeInShader,\n    };\n  }\n\n  if (!hasPositions) {\n    if (defined(featureTableJson.POSITION)) {\n      positions = featureTable.getPropertyArray(\n        \"POSITION\",\n        ComponentDatatype.FLOAT,\n        3\n      );\n      hasPositions = true;\n    } else if (defined(featureTableJson.POSITION_QUANTIZED)) {\n      positions = featureTable.getPropertyArray(\n        \"POSITION_QUANTIZED\",\n        ComponentDatatype.UNSIGNED_SHORT,\n        3\n      );\n      isQuantized = true;\n      hasPositions = true;\n\n      var quantizedVolumeScale = featureTable.getGlobalProperty(\n        \"QUANTIZED_VOLUME_SCALE\",\n        ComponentDatatype.FLOAT,\n        3\n      );\n      if (!defined(quantizedVolumeScale)) {\n        throw new RuntimeError(\n          \"Global property: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.\"\n        );\n      }\n      pointCloud._quantizedVolumeScale = Cartesian3.unpack(\n        quantizedVolumeScale\n      );\n      pointCloud._quantizedRange = (1 << 16) - 1;\n\n      var quantizedVolumeOffset = featureTable.getGlobalProperty(\n        \"QUANTIZED_VOLUME_OFFSET\",\n        ComponentDatatype.FLOAT,\n        3\n      );\n      if (!defined(quantizedVolumeOffset)) {\n        throw new RuntimeError(\n          \"Global property: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.\"\n        );\n      }\n      pointCloud._quantizedVolumeOffset = Cartesian3.unpack(\n        quantizedVolumeOffset\n      );\n    }\n  }\n\n  if (!hasColors) {\n    if (defined(featureTableJson.RGBA)) {\n      colors = featureTable.getPropertyArray(\n        \"RGBA\",\n        ComponentDatatype.UNSIGNED_BYTE,\n        4\n      );\n      isTranslucent = true;\n      hasColors = true;\n    } else if (defined(featureTableJson.RGB)) {\n      colors = featureTable.getPropertyArray(\n        \"RGB\",\n        ComponentDatatype.UNSIGNED_BYTE,\n        3\n      );\n      hasColors = true;\n    } else if (defined(featureTableJson.RGB565)) {\n      colors = featureTable.getPropertyArray(\n        \"RGB565\",\n        ComponentDatatype.UNSIGNED_SHORT,\n        1\n      );\n      isRGB565 = true;\n      hasColors = true;\n    }\n  }\n\n  if (!hasNormals) {\n    if (defined(featureTableJson.NORMAL)) {\n      normals = featureTable.getPropertyArray(\n        \"NORMAL\",\n        ComponentDatatype.FLOAT,\n        3\n      );\n      hasNormals = true;\n    } else if (defined(featureTableJson.NORMAL_OCT16P)) {\n      normals = featureTable.getPropertyArray(\n        \"NORMAL_OCT16P\",\n        ComponentDatatype.UNSIGNED_BYTE,\n        2\n      );\n      isOctEncoded16P = true;\n      hasNormals = true;\n    }\n  }\n\n  if (!hasBatchIds) {\n    if (defined(featureTableJson.BATCH_ID)) {\n      batchIds = featureTable.getPropertyArray(\n        \"BATCH_ID\",\n        ComponentDatatype.UNSIGNED_SHORT,\n        1\n      );\n      hasBatchIds = true;\n    }\n  }\n\n  if (!hasPositions) {\n    throw new RuntimeError(\n      \"Either POSITION or POSITION_QUANTIZED must be defined.\"\n    );\n  }\n\n  if (defined(featureTableJson.CONSTANT_RGBA)) {\n    var constantRGBA = featureTable.getGlobalProperty(\n      \"CONSTANT_RGBA\",\n      ComponentDatatype.UNSIGNED_BYTE,\n      4\n    );\n    pointCloud._constantColor = Color.fromBytes(\n      constantRGBA[0],\n      constantRGBA[1],\n      constantRGBA[2],\n      constantRGBA[3],\n      pointCloud._constantColor\n    );\n  }\n\n  if (hasBatchIds) {\n    var batchLength = featureTable.getGlobalProperty(\"BATCH_LENGTH\");\n    if (!defined(batchLength)) {\n      throw new RuntimeError(\n        \"Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.\"\n      );\n    }\n\n    if (defined(batchTableBinary)) {\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n    }\n\n    if (defined(pointCloud._batchTableLoaded)) {\n      pointCloud._batchTableLoaded(\n        batchLength,\n        batchTableJson,\n        batchTableBinary\n      );\n    }\n  }\n\n  // If points are not batched and there are per-point properties, use these properties for styling purposes\n  var styleableProperties;\n  if (!hasBatchIds && defined(batchTableBinary)) {\n    styleableProperties = Cesium3DTileBatchTable.getBinaryProperties(\n      pointsLength,\n      batchTableJson,\n      batchTableBinary\n    );\n  }\n\n  pointCloud._parsedContent = {\n    positions: positions,\n    colors: colors,\n    normals: normals,\n    batchIds: batchIds,\n    styleableProperties: styleableProperties,\n    draco: draco,\n  };\n  pointCloud._pointsLength = pointsLength;\n  pointCloud._isQuantized = isQuantized;\n  pointCloud._isOctEncoded16P = isOctEncoded16P;\n  pointCloud._isRGB565 = isRGB565;\n  pointCloud._isTranslucent = isTranslucent;\n  pointCloud._hasColors = hasColors;\n  pointCloud._hasNormals = hasNormals;\n  pointCloud._hasBatchIds = hasBatchIds;\n}\n\nvar scratchMin = new Cartesian3();\nvar scratchMax = new Cartesian3();\nvar scratchPosition = new Cartesian3();\nvar randomValues;\n\nfunction getRandomValues(samplesLength) {\n  // Use same random values across all runs\n  if (!defined(randomValues)) {\n    CesiumMath.setRandomNumberSeed(0);\n    randomValues = new Array(samplesLength);\n    for (var i = 0; i < samplesLength; ++i) {\n      randomValues[i] = CesiumMath.nextRandomNumber();\n    }\n  }\n  return randomValues;\n}\n\nfunction computeApproximateBoundingSphereFromPositions(positions) {\n  var maximumSamplesLength = 20;\n  var pointsLength = positions.length / 3;\n  var samplesLength = Math.min(pointsLength, maximumSamplesLength);\n  var randomValues = getRandomValues(maximumSamplesLength);\n  var maxValue = Number.MAX_VALUE;\n  var minValue = -Number.MAX_VALUE;\n  var min = Cartesian3.fromElements(maxValue, maxValue, maxValue, scratchMin);\n  var max = Cartesian3.fromElements(minValue, minValue, minValue, scratchMax);\n  for (var i = 0; i < samplesLength; ++i) {\n    var index = Math.floor(randomValues[i] * pointsLength);\n    var position = Cartesian3.unpack(positions, index * 3, scratchPosition);\n    Cartesian3.minimumByComponent(min, position, min);\n    Cartesian3.maximumByComponent(max, position, max);\n  }\n\n  var boundingSphere = BoundingSphere.fromCornerPoints(min, max);\n  boundingSphere.radius += CesiumMath.EPSILON2; // To avoid radius of zero\n  return boundingSphere;\n}\n\nfunction prepareVertexAttribute(typedArray, name) {\n  // WebGL does not support UNSIGNED_INT, INT, or DOUBLE vertex attributes. Convert these to FLOAT.\n  var componentDatatype = ComponentDatatype.fromTypedArray(typedArray);\n  if (\n    componentDatatype === ComponentDatatype.INT ||\n    componentDatatype === ComponentDatatype.UNSIGNED_INT ||\n    componentDatatype === ComponentDatatype.DOUBLE\n  ) {\n    oneTimeWarning(\n      \"Cast pnts property to floats\",\n      'Point cloud property \"' +\n        name +\n        '\" will be casted to a float array because INT, UNSIGNED_INT, and DOUBLE are not valid WebGL vertex attribute types. Some precision may be lost.'\n    );\n    return new Float32Array(typedArray);\n  }\n  return typedArray;\n}\n\nvar scratchPointSizeAndTimeAndGeometricErrorAndDepthMultiplier = new Cartesian4();\nvar scratchQuantizedVolumeScaleAndOctEncodedRange = new Cartesian4();\nvar scratchColor = new Color();\n\nvar positionLocation = 0;\nvar colorLocation = 1;\nvar normalLocation = 2;\nvar batchIdLocation = 3;\nvar numberOfAttributes = 4;\n\nvar scratchClippingPlaneMatrix = new Matrix4();\n\nfunction createResources(pointCloud, frameState) {\n  var context = frameState.context;\n  var parsedContent = pointCloud._parsedContent;\n  var pointsLength = pointCloud._pointsLength;\n  var positions = parsedContent.positions;\n  var colors = parsedContent.colors;\n  var normals = parsedContent.normals;\n  var batchIds = parsedContent.batchIds;\n  var styleableProperties = parsedContent.styleableProperties;\n  var hasStyleableProperties = defined(styleableProperties);\n  var isQuantized = pointCloud._isQuantized;\n  var isQuantizedDraco = pointCloud._isQuantizedDraco;\n  var isOctEncoded16P = pointCloud._isOctEncoded16P;\n  var isOctEncodedDraco = pointCloud._isOctEncodedDraco;\n  var quantizedRange = pointCloud._quantizedRange;\n  var octEncodedRange = pointCloud._octEncodedRange;\n  var isRGB565 = pointCloud._isRGB565;\n  var isTranslucent = pointCloud._isTranslucent;\n  var hasColors = pointCloud._hasColors;\n  var hasNormals = pointCloud._hasNormals;\n  var hasBatchIds = pointCloud._hasBatchIds;\n\n  var componentsPerAttribute;\n  var componentDatatype;\n\n  var styleableVertexAttributes = [];\n  var styleableShaderAttributes = {};\n  pointCloud._styleableShaderAttributes = styleableShaderAttributes;\n\n  if (hasStyleableProperties) {\n    var attributeLocation = numberOfAttributes;\n\n    for (var name in styleableProperties) {\n      if (styleableProperties.hasOwnProperty(name)) {\n        var property = styleableProperties[name];\n        var typedArray = prepareVertexAttribute(property.typedArray, name);\n        componentsPerAttribute = property.componentCount;\n        componentDatatype = ComponentDatatype.fromTypedArray(typedArray);\n\n        var vertexBuffer = Buffer.createVertexBuffer({\n          context: context,\n          typedArray: typedArray,\n          usage: BufferUsage.STATIC_DRAW,\n        });\n\n        pointCloud._geometryByteLength += vertexBuffer.sizeInBytes;\n\n        var vertexAttribute = {\n          index: attributeLocation,\n          vertexBuffer: vertexBuffer,\n          componentsPerAttribute: componentsPerAttribute,\n          componentDatatype: componentDatatype,\n          normalize: false,\n          offsetInBytes: 0,\n          strideInBytes: 0,\n        };\n\n        styleableVertexAttributes.push(vertexAttribute);\n        styleableShaderAttributes[name] = {\n          location: attributeLocation,\n          componentCount: componentsPerAttribute,\n        };\n        ++attributeLocation;\n      }\n    }\n  }\n\n  var positionsVertexBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: positions,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  pointCloud._geometryByteLength += positionsVertexBuffer.sizeInBytes;\n\n  var colorsVertexBuffer;\n  if (hasColors) {\n    colorsVertexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: colors,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    pointCloud._geometryByteLength += colorsVertexBuffer.sizeInBytes;\n  }\n\n  var normalsVertexBuffer;\n  if (hasNormals) {\n    normalsVertexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: normals,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    pointCloud._geometryByteLength += normalsVertexBuffer.sizeInBytes;\n  }\n\n  var batchIdsVertexBuffer;\n  if (hasBatchIds) {\n    batchIds = prepareVertexAttribute(batchIds, \"batchIds\");\n    batchIdsVertexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: batchIds,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    pointCloud._geometryByteLength += batchIdsVertexBuffer.sizeInBytes;\n  }\n\n  var attributes = [];\n\n  if (isQuantized) {\n    componentDatatype = ComponentDatatype.UNSIGNED_SHORT;\n  } else if (isQuantizedDraco) {\n    componentDatatype =\n      quantizedRange <= 255\n        ? ComponentDatatype.UNSIGNED_BYTE\n        : ComponentDatatype.UNSIGNED_SHORT;\n  } else {\n    componentDatatype = ComponentDatatype.FLOAT;\n  }\n\n  attributes.push({\n    index: positionLocation,\n    vertexBuffer: positionsVertexBuffer,\n    componentsPerAttribute: 3,\n    componentDatatype: componentDatatype,\n    normalize: false,\n    offsetInBytes: 0,\n    strideInBytes: 0,\n  });\n\n  if (pointCloud._cull) {\n    if (isQuantized || isQuantizedDraco) {\n      pointCloud._boundingSphere = BoundingSphere.fromCornerPoints(\n        Cartesian3.ZERO,\n        pointCloud._quantizedVolumeScale\n      );\n    } else {\n      pointCloud._boundingSphere = computeApproximateBoundingSphereFromPositions(\n        positions\n      );\n    }\n  }\n\n  if (hasColors) {\n    if (isRGB565) {\n      attributes.push({\n        index: colorLocation,\n        vertexBuffer: colorsVertexBuffer,\n        componentsPerAttribute: 1,\n        componentDatatype: ComponentDatatype.UNSIGNED_SHORT,\n        normalize: false,\n        offsetInBytes: 0,\n        strideInBytes: 0,\n      });\n    } else {\n      var colorComponentsPerAttribute = isTranslucent ? 4 : 3;\n      attributes.push({\n        index: colorLocation,\n        vertexBuffer: colorsVertexBuffer,\n        componentsPerAttribute: colorComponentsPerAttribute,\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        normalize: true,\n        offsetInBytes: 0,\n        strideInBytes: 0,\n      });\n    }\n  }\n\n  if (hasNormals) {\n    if (isOctEncoded16P) {\n      componentsPerAttribute = 2;\n      componentDatatype = ComponentDatatype.UNSIGNED_BYTE;\n    } else if (isOctEncodedDraco) {\n      componentsPerAttribute = 2;\n      componentDatatype =\n        octEncodedRange <= 255\n          ? ComponentDatatype.UNSIGNED_BYTE\n          : ComponentDatatype.UNSIGNED_SHORT;\n    } else {\n      componentsPerAttribute = 3;\n      componentDatatype = ComponentDatatype.FLOAT;\n    }\n    attributes.push({\n      index: normalLocation,\n      vertexBuffer: normalsVertexBuffer,\n      componentsPerAttribute: componentsPerAttribute,\n      componentDatatype: componentDatatype,\n      normalize: false,\n      offsetInBytes: 0,\n      strideInBytes: 0,\n    });\n  }\n\n  if (hasBatchIds) {\n    attributes.push({\n      index: batchIdLocation,\n      vertexBuffer: batchIdsVertexBuffer,\n      componentsPerAttribute: 1,\n      componentDatatype: ComponentDatatype.fromTypedArray(batchIds),\n      normalize: false,\n      offsetInBytes: 0,\n      strideInBytes: 0,\n    });\n  }\n\n  if (hasStyleableProperties) {\n    attributes = attributes.concat(styleableVertexAttributes);\n  }\n\n  var vertexArray = new VertexArray({\n    context: context,\n    attributes: attributes,\n  });\n\n  var opaqueRenderState = {\n    depthTest: {\n      enabled: true,\n    },\n  };\n\n  if (pointCloud._opaquePass === Pass.CESIUM_3D_TILE) {\n    opaqueRenderState.stencilTest = StencilConstants.setCesium3DTileBit();\n    opaqueRenderState.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK;\n  }\n\n  pointCloud._opaqueRenderState = RenderState.fromCache(opaqueRenderState);\n\n  pointCloud._translucentRenderState = RenderState.fromCache({\n    depthTest: {\n      enabled: true,\n    },\n    depthMask: false,\n    blending: BlendingState.ALPHA_BLEND,\n  });\n\n  pointCloud._drawCommand = new DrawCommand({\n    boundingVolume: new BoundingSphere(),\n    cull: pointCloud._cull,\n    modelMatrix: new Matrix4(),\n    primitiveType: PrimitiveType.POINTS,\n    vertexArray: vertexArray,\n    count: pointsLength,\n    shaderProgram: undefined, // Updated in createShaders\n    uniformMap: undefined, // Updated in createShaders\n    renderState: isTranslucent\n      ? pointCloud._translucentRenderState\n      : pointCloud._opaqueRenderState,\n    pass: isTranslucent ? Pass.TRANSLUCENT : pointCloud._opaquePass,\n    owner: pointCloud,\n    castShadows: false,\n    receiveShadows: false,\n    pickId: pointCloud._pickIdLoaded(),\n  });\n}\n\nfunction createUniformMap(pointCloud, frameState) {\n  var context = frameState.context;\n  var isQuantized = pointCloud._isQuantized;\n  var isQuantizedDraco = pointCloud._isQuantizedDraco;\n  var isOctEncodedDraco = pointCloud._isOctEncodedDraco;\n\n  var uniformMap = {\n    u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier: function () {\n      var scratch = scratchPointSizeAndTimeAndGeometricErrorAndDepthMultiplier;\n      scratch.x = pointCloud._attenuation\n        ? pointCloud.maximumAttenuation\n        : pointCloud._pointSize;\n      scratch.x *= frameState.pixelRatio;\n\n      scratch.y = pointCloud.time;\n\n      if (pointCloud._attenuation) {\n        var frustum = frameState.camera.frustum;\n        var depthMultiplier;\n        // Attenuation is maximumAttenuation in 2D/ortho\n        if (\n          frameState.mode === SceneMode.SCENE2D ||\n          frustum instanceof OrthographicFrustum\n        ) {\n          depthMultiplier = Number.POSITIVE_INFINITY;\n        } else {\n          depthMultiplier =\n            context.drawingBufferHeight /\n            frameState.camera.frustum.sseDenominator;\n        }\n\n        scratch.z = pointCloud.geometricError * pointCloud.geometricErrorScale;\n        scratch.w = depthMultiplier;\n      }\n\n      return scratch;\n    },\n    u_highlightColor: function () {\n      return pointCloud._highlightColor;\n    },\n    u_constantColor: function () {\n      return pointCloud._constantColor;\n    },\n    u_clippingPlanes: function () {\n      var clippingPlanes = pointCloud.clippingPlanes;\n      var isClipped = pointCloud.isClipped;\n      return isClipped ? clippingPlanes.texture : context.defaultTexture;\n    },\n    u_clippingPlanesEdgeStyle: function () {\n      var clippingPlanes = pointCloud.clippingPlanes;\n      if (!defined(clippingPlanes)) {\n        return Color.TRANSPARENT;\n      }\n\n      var style = Color.clone(clippingPlanes.edgeColor, scratchColor);\n      style.alpha = clippingPlanes.edgeWidth;\n      return style;\n    },\n    u_clippingPlanesMatrix: function () {\n      var clippingPlanes = pointCloud.clippingPlanes;\n      if (!defined(clippingPlanes)) {\n        return Matrix4.IDENTITY;\n      }\n\n      var clippingPlanesOriginMatrix = defaultValue(\n        pointCloud.clippingPlanesOriginMatrix,\n        pointCloud._modelMatrix\n      );\n      Matrix4.multiply(\n        context.uniformState.view3D,\n        clippingPlanesOriginMatrix,\n        scratchClippingPlaneMatrix\n      );\n      return Matrix4.multiply(\n        scratchClippingPlaneMatrix,\n        clippingPlanes.modelMatrix,\n        scratchClippingPlaneMatrix\n      );\n    },\n  };\n\n  if (isQuantized || isQuantizedDraco || isOctEncodedDraco) {\n    uniformMap = combine(uniformMap, {\n      u_quantizedVolumeScaleAndOctEncodedRange: function () {\n        var scratch = scratchQuantizedVolumeScaleAndOctEncodedRange;\n        if (defined(pointCloud._quantizedVolumeScale)) {\n          var scale = Cartesian3.clone(\n            pointCloud._quantizedVolumeScale,\n            scratch\n          );\n          Cartesian3.divideByScalar(scale, pointCloud._quantizedRange, scratch);\n        }\n        scratch.w = pointCloud._octEncodedRange;\n        return scratch;\n      },\n    });\n  }\n\n  if (defined(pointCloud._uniformMapLoaded)) {\n    uniformMap = pointCloud._uniformMapLoaded(uniformMap);\n  }\n\n  pointCloud._drawCommand.uniformMap = uniformMap;\n}\n\nvar defaultProperties = [\"POSITION\", \"COLOR\", \"NORMAL\", \"POSITION_ABSOLUTE\"];\n\nfunction getStyleableProperties(source, properties) {\n  // Get all the properties used by this style\n  var regex = /czm_tiles3d_style_(\\w+)/g;\n  var matches = regex.exec(source);\n  while (matches !== null) {\n    var name = matches[1];\n    if (properties.indexOf(name) === -1) {\n      properties.push(name);\n    }\n    matches = regex.exec(source);\n  }\n}\n\nfunction getVertexAttribute(vertexArray, index) {\n  var numberOfAttributes = vertexArray.numberOfAttributes;\n  for (var i = 0; i < numberOfAttributes; ++i) {\n    var attribute = vertexArray.getAttribute(i);\n    if (attribute.index === index) {\n      return attribute;\n    }\n  }\n}\n\nfunction modifyStyleFunction(source) {\n  // Replace occurrences of czm_tiles3d_style_DEFAULTPROPERTY\n  var length = defaultProperties.length;\n  for (var i = 0; i < length; ++i) {\n    var property = defaultProperties[i];\n    var styleName = \"czm_tiles3d_style_\" + property;\n    var replaceName = property.toLowerCase();\n    source = source.replace(\n      new RegExp(styleName + \"(\\\\W)\", \"g\"),\n      replaceName + \"$1\"\n    );\n  }\n\n  // Edit the function header to accept the point position, color, and normal\n  return source.replace(\n    \"()\",\n    \"(vec3 position, vec3 position_absolute, vec4 color, vec3 normal)\"\n  );\n}\n\nfunction createShaders(pointCloud, frameState, style) {\n  var i;\n  var name;\n  var attribute;\n\n  var context = frameState.context;\n  var hasStyle = defined(style);\n  var isQuantized = pointCloud._isQuantized;\n  var isQuantizedDraco = pointCloud._isQuantizedDraco;\n  var isOctEncoded16P = pointCloud._isOctEncoded16P;\n  var isOctEncodedDraco = pointCloud._isOctEncodedDraco;\n  var isRGB565 = pointCloud._isRGB565;\n  var isTranslucent = pointCloud._isTranslucent;\n  var hasColors = pointCloud._hasColors;\n  var hasNormals = pointCloud._hasNormals;\n  var hasBatchIds = pointCloud._hasBatchIds;\n  var backFaceCulling = pointCloud._backFaceCulling;\n  var normalShading = pointCloud._normalShading;\n  var vertexArray = pointCloud._drawCommand.vertexArray;\n  var clippingPlanes = pointCloud.clippingPlanes;\n  var attenuation = pointCloud._attenuation;\n\n  var colorStyleFunction;\n  var showStyleFunction;\n  var pointSizeStyleFunction;\n  var styleTranslucent = isTranslucent;\n\n  if (hasStyle) {\n    var shaderState = {\n      translucent: false,\n    };\n    colorStyleFunction = style.getColorShaderFunction(\n      \"getColorFromStyle\",\n      \"czm_tiles3d_style_\",\n      shaderState\n    );\n    showStyleFunction = style.getShowShaderFunction(\n      \"getShowFromStyle\",\n      \"czm_tiles3d_style_\",\n      shaderState\n    );\n    pointSizeStyleFunction = style.getPointSizeShaderFunction(\n      \"getPointSizeFromStyle\",\n      \"czm_tiles3d_style_\",\n      shaderState\n    );\n    if (defined(colorStyleFunction) && shaderState.translucent) {\n      styleTranslucent = true;\n    }\n  }\n\n  pointCloud._styleTranslucent = styleTranslucent;\n\n  var hasColorStyle = defined(colorStyleFunction);\n  var hasShowStyle = defined(showStyleFunction);\n  var hasPointSizeStyle = defined(pointSizeStyleFunction);\n  var hasClippedContent = pointCloud.isClipped;\n\n  // Get the properties in use by the style\n  var styleableProperties = [];\n\n  if (hasColorStyle) {\n    getStyleableProperties(colorStyleFunction, styleableProperties);\n    colorStyleFunction = modifyStyleFunction(colorStyleFunction);\n  }\n  if (hasShowStyle) {\n    getStyleableProperties(showStyleFunction, styleableProperties);\n    showStyleFunction = modifyStyleFunction(showStyleFunction);\n  }\n  if (hasPointSizeStyle) {\n    getStyleableProperties(pointSizeStyleFunction, styleableProperties);\n    pointSizeStyleFunction = modifyStyleFunction(pointSizeStyleFunction);\n  }\n\n  var usesColorSemantic = styleableProperties.indexOf(\"COLOR\") >= 0;\n  var usesNormalSemantic = styleableProperties.indexOf(\"NORMAL\") >= 0;\n\n  // Split default properties from user properties\n  var userProperties = styleableProperties.filter(function (property) {\n    return defaultProperties.indexOf(property) === -1;\n  });\n\n  if (usesNormalSemantic && !hasNormals) {\n    throw new RuntimeError(\n      \"Style references the NORMAL semantic but the point cloud does not have normals\"\n    );\n  }\n\n  // Disable vertex attributes that aren't used in the style, enable attributes that are\n  var styleableShaderAttributes = pointCloud._styleableShaderAttributes;\n  for (name in styleableShaderAttributes) {\n    if (styleableShaderAttributes.hasOwnProperty(name)) {\n      attribute = styleableShaderAttributes[name];\n      var enabled = userProperties.indexOf(name) >= 0;\n      var vertexAttribute = getVertexAttribute(vertexArray, attribute.location);\n      vertexAttribute.enabled = enabled;\n    }\n  }\n\n  var usesColors = hasColors && (!hasColorStyle || usesColorSemantic);\n  if (hasColors) {\n    // Disable the color vertex attribute if the color style does not reference the color semantic\n    var colorVertexAttribute = getVertexAttribute(vertexArray, colorLocation);\n    colorVertexAttribute.enabled = usesColors;\n  }\n\n  var usesNormals =\n    hasNormals && (normalShading || backFaceCulling || usesNormalSemantic);\n  if (hasNormals) {\n    // Disable the normal vertex attribute if normals are not used\n    var normalVertexAttribute = getVertexAttribute(vertexArray, normalLocation);\n    normalVertexAttribute.enabled = usesNormals;\n  }\n\n  var attributeLocations = {\n    a_position: positionLocation,\n  };\n  if (usesColors) {\n    attributeLocations.a_color = colorLocation;\n  }\n  if (usesNormals) {\n    attributeLocations.a_normal = normalLocation;\n  }\n  if (hasBatchIds) {\n    attributeLocations.a_batchId = batchIdLocation;\n  }\n\n  var attributeDeclarations = \"\";\n\n  var length = userProperties.length;\n  for (i = 0; i < length; ++i) {\n    name = userProperties[i];\n    attribute = styleableShaderAttributes[name];\n    if (!defined(attribute)) {\n      throw new RuntimeError(\n        'Style references a property \"' +\n          name +\n          '\" that does not exist or is not styleable.'\n      );\n    }\n\n    var componentCount = attribute.componentCount;\n    var attributeName = \"czm_tiles3d_style_\" + name;\n    var attributeType;\n    if (componentCount === 1) {\n      attributeType = \"float\";\n    } else {\n      attributeType = \"vec\" + componentCount;\n    }\n\n    attributeDeclarations +=\n      \"attribute \" + attributeType + \" \" + attributeName + \"; \\n\";\n    attributeLocations[attributeName] = attribute.location;\n  }\n\n  createUniformMap(pointCloud, frameState);\n\n  var vs =\n    \"attribute vec3 a_position; \\n\" +\n    \"varying vec4 v_color; \\n\" +\n    \"uniform vec4 u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier; \\n\" +\n    \"uniform vec4 u_constantColor; \\n\" +\n    \"uniform vec4 u_highlightColor; \\n\";\n  vs += \"float u_pointSize; \\n\" + \"float u_time; \\n\";\n\n  if (attenuation) {\n    vs += \"float u_geometricError; \\n\" + \"float u_depthMultiplier; \\n\";\n  }\n\n  vs += attributeDeclarations;\n\n  if (usesColors) {\n    if (isTranslucent) {\n      vs += \"attribute vec4 a_color; \\n\";\n    } else if (isRGB565) {\n      vs +=\n        \"attribute float a_color; \\n\" +\n        \"const float SHIFT_RIGHT_11 = 1.0 / 2048.0; \\n\" +\n        \"const float SHIFT_RIGHT_5 = 1.0 / 32.0; \\n\" +\n        \"const float SHIFT_LEFT_11 = 2048.0; \\n\" +\n        \"const float SHIFT_LEFT_5 = 32.0; \\n\" +\n        \"const float NORMALIZE_6 = 1.0 / 64.0; \\n\" +\n        \"const float NORMALIZE_5 = 1.0 / 32.0; \\n\";\n    } else {\n      vs += \"attribute vec3 a_color; \\n\";\n    }\n  }\n  if (usesNormals) {\n    if (isOctEncoded16P || isOctEncodedDraco) {\n      vs += \"attribute vec2 a_normal; \\n\";\n    } else {\n      vs += \"attribute vec3 a_normal; \\n\";\n    }\n  }\n\n  if (hasBatchIds) {\n    vs += \"attribute float a_batchId; \\n\";\n  }\n\n  if (isQuantized || isQuantizedDraco || isOctEncodedDraco) {\n    vs += \"uniform vec4 u_quantizedVolumeScaleAndOctEncodedRange; \\n\";\n  }\n\n  if (hasColorStyle) {\n    vs += colorStyleFunction;\n  }\n\n  if (hasShowStyle) {\n    vs += showStyleFunction;\n  }\n\n  if (hasPointSizeStyle) {\n    vs += pointSizeStyleFunction;\n  }\n\n  vs +=\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    u_pointSize = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.x; \\n\" +\n    \"    u_time = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.y; \\n\";\n\n  if (attenuation) {\n    vs +=\n      \"    u_geometricError = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.z; \\n\" +\n      \"    u_depthMultiplier = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.w; \\n\";\n  }\n\n  if (usesColors) {\n    if (isTranslucent) {\n      vs += \"    vec4 color = a_color; \\n\";\n    } else if (isRGB565) {\n      vs +=\n        \"    float compressed = a_color; \\n\" +\n        \"    float r = floor(compressed * SHIFT_RIGHT_11); \\n\" +\n        \"    compressed -= r * SHIFT_LEFT_11; \\n\" +\n        \"    float g = floor(compressed * SHIFT_RIGHT_5); \\n\" +\n        \"    compressed -= g * SHIFT_LEFT_5; \\n\" +\n        \"    float b = compressed; \\n\" +\n        \"    vec3 rgb = vec3(r * NORMALIZE_5, g * NORMALIZE_6, b * NORMALIZE_5); \\n\" +\n        \"    vec4 color = vec4(rgb, 1.0); \\n\";\n    } else {\n      vs += \"    vec4 color = vec4(a_color, 1.0); \\n\";\n    }\n  } else {\n    vs += \"    vec4 color = u_constantColor; \\n\";\n  }\n\n  if (isQuantized || isQuantizedDraco) {\n    vs +=\n      \"    vec3 position = a_position * u_quantizedVolumeScaleAndOctEncodedRange.xyz; \\n\";\n  } else {\n    vs += \"    vec3 position = a_position; \\n\";\n  }\n  vs +=\n    \"    vec3 position_absolute = vec3(czm_model * vec4(position, 1.0)); \\n\";\n\n  if (usesNormals) {\n    if (isOctEncoded16P) {\n      vs += \"    vec3 normal = czm_octDecode(a_normal); \\n\";\n    } else if (isOctEncodedDraco) {\n      // Draco oct-encoding decodes to zxy order\n      vs +=\n        \"    vec3 normal = czm_octDecode(a_normal, u_quantizedVolumeScaleAndOctEncodedRange.w).zxy; \\n\";\n    } else {\n      vs += \"    vec3 normal = a_normal; \\n\";\n    }\n    vs += \"    vec3 normalEC = czm_normal * normal; \\n\";\n  } else {\n    vs += \"    vec3 normal = vec3(1.0); \\n\";\n  }\n\n  if (hasColorStyle) {\n    vs +=\n      \"    color = getColorFromStyle(position, position_absolute, color, normal); \\n\";\n  }\n\n  if (hasShowStyle) {\n    vs +=\n      \"    float show = float(getShowFromStyle(position, position_absolute, color, normal)); \\n\";\n  }\n\n  if (hasPointSizeStyle) {\n    vs +=\n      \"    gl_PointSize = getPointSizeFromStyle(position, position_absolute, color, normal) * czm_pixelRatio; \\n\";\n  } else if (attenuation) {\n    vs +=\n      \"    vec4 positionEC = czm_modelView * vec4(position, 1.0); \\n\" +\n      \"    float depth = -positionEC.z; \\n\" +\n      // compute SSE for this point\n      \"    gl_PointSize = min((u_geometricError / depth) * u_depthMultiplier, u_pointSize); \\n\";\n  } else {\n    vs += \"    gl_PointSize = u_pointSize; \\n\";\n  }\n\n  vs += \"    color = color * u_highlightColor; \\n\";\n\n  if (usesNormals && normalShading) {\n    vs +=\n      \"    float diffuseStrength = czm_getLambertDiffuse(czm_lightDirectionEC, normalEC); \\n\" +\n      \"    diffuseStrength = max(diffuseStrength, 0.4); \\n\" + // Apply some ambient lighting\n      \"    color.xyz *= diffuseStrength * czm_lightColor; \\n\";\n  }\n\n  vs +=\n    \"    v_color = color; \\n\" +\n    \"    gl_Position = czm_modelViewProjection * vec4(position, 1.0); \\n\";\n\n  if (usesNormals && backFaceCulling) {\n    vs +=\n      \"    float visible = step(-normalEC.z, 0.0); \\n\" +\n      \"    gl_Position *= visible; \\n\" +\n      \"    gl_PointSize *= visible; \\n\";\n  }\n\n  if (hasShowStyle) {\n    vs +=\n      \"    gl_Position.w *= float(show); \\n\" +\n      \"    gl_PointSize *= float(show); \\n\";\n  }\n\n  vs += \"} \\n\";\n\n  var fs = \"varying vec4 v_color; \\n\";\n\n  if (hasClippedContent) {\n    fs +=\n      \"uniform sampler2D u_clippingPlanes; \\n\" +\n      \"uniform mat4 u_clippingPlanesMatrix; \\n\" +\n      \"uniform vec4 u_clippingPlanesEdgeStyle; \\n\";\n    fs += \"\\n\";\n    fs += getClippingFunction(clippingPlanes, context);\n    fs += \"\\n\";\n  }\n\n  fs +=\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    gl_FragColor = czm_gammaCorrect(v_color); \\n\";\n\n  if (hasClippedContent) {\n    fs += getClipAndStyleCode(\n      \"u_clippingPlanes\",\n      \"u_clippingPlanesMatrix\",\n      \"u_clippingPlanesEdgeStyle\"\n    );\n  }\n\n  fs += \"} \\n\";\n\n  if (defined(pointCloud._vertexShaderLoaded)) {\n    vs = pointCloud._vertexShaderLoaded(vs);\n  }\n\n  if (defined(pointCloud._fragmentShaderLoaded)) {\n    fs = pointCloud._fragmentShaderLoaded(fs);\n  }\n\n  var drawCommand = pointCloud._drawCommand;\n  if (defined(drawCommand.shaderProgram)) {\n    // Destroy the old shader\n    drawCommand.shaderProgram.destroy();\n  }\n  drawCommand.shaderProgram = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n\n  try {\n    // Check if the shader compiles correctly. If not there is likely a syntax error with the style.\n    drawCommand.shaderProgram._bind();\n  } catch (error) {\n    // Rephrase the error.\n    throw new RuntimeError(\n      \"Error generating style shader: this may be caused by a type mismatch, index out-of-bounds, or other syntax error.\"\n    );\n  }\n}\n\nfunction decodeDraco(pointCloud, context) {\n  if (pointCloud._decodingState === DecodingState.READY) {\n    return false;\n  }\n  if (pointCloud._decodingState === DecodingState.NEEDS_DECODE) {\n    var parsedContent = pointCloud._parsedContent;\n    var draco = parsedContent.draco;\n    var decodePromise = DracoLoader.decodePointCloud(draco, context);\n    if (defined(decodePromise)) {\n      pointCloud._decodingState = DecodingState.DECODING;\n      decodePromise\n        .then(function (result) {\n          pointCloud._decodingState = DecodingState.READY;\n          var decodedPositions = defined(result.POSITION)\n            ? result.POSITION.array\n            : undefined;\n          var decodedRgb = defined(result.RGB) ? result.RGB.array : undefined;\n          var decodedRgba = defined(result.RGBA)\n            ? result.RGBA.array\n            : undefined;\n          var decodedNormals = defined(result.NORMAL)\n            ? result.NORMAL.array\n            : undefined;\n          var decodedBatchIds = defined(result.BATCH_ID)\n            ? result.BATCH_ID.array\n            : undefined;\n          var isQuantizedDraco =\n            defined(decodedPositions) &&\n            defined(result.POSITION.data.quantization);\n          var isOctEncodedDraco =\n            defined(decodedNormals) && defined(result.NORMAL.data.quantization);\n          if (isQuantizedDraco) {\n            // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n            // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n            var quantization = result.POSITION.data.quantization;\n            var range = quantization.range;\n            pointCloud._quantizedVolumeScale = Cartesian3.fromElements(\n              range,\n              range,\n              range\n            );\n            pointCloud._quantizedVolumeOffset = Cartesian3.unpack(\n              quantization.minValues\n            );\n            pointCloud._quantizedRange =\n              (1 << quantization.quantizationBits) - 1.0;\n            pointCloud._isQuantizedDraco = true;\n          }\n          if (isOctEncodedDraco) {\n            pointCloud._octEncodedRange =\n              (1 << result.NORMAL.data.quantization.quantizationBits) - 1.0;\n            pointCloud._isOctEncodedDraco = true;\n          }\n          var styleableProperties = parsedContent.styleableProperties;\n          var batchTableProperties = draco.batchTableProperties;\n          for (var name in batchTableProperties) {\n            if (batchTableProperties.hasOwnProperty(name)) {\n              var property = result[name];\n              if (!defined(styleableProperties)) {\n                styleableProperties = {};\n              }\n              styleableProperties[name] = {\n                typedArray: property.array,\n                componentCount: property.data.componentsPerAttribute,\n              };\n            }\n          }\n          parsedContent.positions = defaultValue(\n            decodedPositions,\n            parsedContent.positions\n          );\n          parsedContent.colors = defaultValue(\n            defaultValue(decodedRgba, decodedRgb),\n            parsedContent.colors\n          );\n          parsedContent.normals = defaultValue(\n            decodedNormals,\n            parsedContent.normals\n          );\n          parsedContent.batchIds = defaultValue(\n            decodedBatchIds,\n            parsedContent.batchIds\n          );\n          parsedContent.styleableProperties = styleableProperties;\n        })\n        .otherwise(function (error) {\n          pointCloud._decodingState = DecodingState.FAILED;\n          pointCloud._readyPromise.reject(error);\n        });\n    }\n  }\n  return true;\n}\n\nvar scratchComputedTranslation = new Cartesian4();\nvar scratchScale = new Cartesian3();\n\nPointCloud.prototype.update = function (frameState) {\n  var context = frameState.context;\n  var decoding = decodeDraco(this, context);\n  if (decoding) {\n    return;\n  }\n\n  var shadersDirty = false;\n  var modelMatrixDirty = !Matrix4.equals(this._modelMatrix, this.modelMatrix);\n\n  if (this._mode !== frameState.mode) {\n    this._mode = frameState.mode;\n    modelMatrixDirty = true;\n  }\n\n  if (!defined(this._drawCommand)) {\n    createResources(this, frameState);\n    modelMatrixDirty = true;\n    shadersDirty = true;\n    this._ready = true;\n    this._readyPromise.resolve(this);\n    this._parsedContent = undefined; // Unload\n  }\n\n  if (modelMatrixDirty) {\n    Matrix4.clone(this.modelMatrix, this._modelMatrix);\n    var modelMatrix = this._drawCommand.modelMatrix;\n    Matrix4.clone(this._modelMatrix, modelMatrix);\n\n    if (defined(this._rtcCenter)) {\n      Matrix4.multiplyByTranslation(modelMatrix, this._rtcCenter, modelMatrix);\n    }\n    if (defined(this._quantizedVolumeOffset)) {\n      Matrix4.multiplyByTranslation(\n        modelMatrix,\n        this._quantizedVolumeOffset,\n        modelMatrix\n      );\n    }\n\n    if (frameState.mode !== SceneMode.SCENE3D) {\n      var projection = frameState.mapProjection;\n      var translation = Matrix4.getColumn(\n        modelMatrix,\n        3,\n        scratchComputedTranslation\n      );\n      if (!Cartesian4.equals(translation, Cartesian4.UNIT_W)) {\n        Transforms.basisTo2D(projection, modelMatrix, modelMatrix);\n      }\n    }\n\n    var boundingSphere = this._drawCommand.boundingVolume;\n    BoundingSphere.clone(this._boundingSphere, boundingSphere);\n\n    if (this._cull) {\n      var center = boundingSphere.center;\n      Matrix4.multiplyByPoint(modelMatrix, center, center);\n      var scale = Matrix4.getScale(modelMatrix, scratchScale);\n      boundingSphere.radius *= Cartesian3.maximumComponent(scale);\n    }\n  }\n\n  if (this.clippingPlanesDirty) {\n    this.clippingPlanesDirty = false;\n    shadersDirty = true;\n  }\n\n  if (this._attenuation !== this.attenuation) {\n    this._attenuation = this.attenuation;\n    shadersDirty = true;\n  }\n\n  if (this.backFaceCulling !== this._backFaceCulling) {\n    this._backFaceCulling = this.backFaceCulling;\n    shadersDirty = true;\n  }\n\n  if (this.normalShading !== this._normalShading) {\n    this._normalShading = this.normalShading;\n    shadersDirty = true;\n  }\n\n  if (this._style !== this.style || this.styleDirty) {\n    this._style = this.style;\n    this.styleDirty = false;\n    shadersDirty = true;\n  }\n\n  if (shadersDirty) {\n    createShaders(this, frameState, this._style);\n  }\n\n  this._drawCommand.castShadows = ShadowMode.castShadows(this.shadows);\n  this._drawCommand.receiveShadows = ShadowMode.receiveShadows(this.shadows);\n\n  // Update the render state\n  var isTranslucent =\n    this._highlightColor.alpha < 1.0 ||\n    this._constantColor.alpha < 1.0 ||\n    this._styleTranslucent;\n  this._drawCommand.renderState = isTranslucent\n    ? this._translucentRenderState\n    : this._opaqueRenderState;\n  this._drawCommand.pass = isTranslucent ? Pass.TRANSLUCENT : this._opaquePass;\n\n  var commandList = frameState.commandList;\n\n  var passes = frameState.passes;\n  if (passes.render || passes.pick) {\n    commandList.push(this._drawCommand);\n  }\n};\n\nPointCloud.prototype.isDestroyed = function () {\n  return false;\n};\n\nPointCloud.prototype.destroy = function () {\n  var command = this._drawCommand;\n  if (defined(command)) {\n    command.vertexArray = command.vertexArray && command.vertexArray.destroy();\n    command.shaderProgram =\n      command.shaderProgram && command.shaderProgram.destroy();\n  }\n  return destroyObject(this);\n};\nexport default PointCloud;\n"]},"metadata":{},"sourceType":"module"}