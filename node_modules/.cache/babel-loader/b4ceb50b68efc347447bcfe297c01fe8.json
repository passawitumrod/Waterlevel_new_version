{"ast":null,"code":"import createGuid from \"../Core/createGuid.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Entity from \"./Entity.js\";\nimport EntityCollection from \"./EntityCollection.js\";\nvar entityOptionsScratch = {\n  id: undefined\n};\nvar entityIdScratch = new Array(2);\n\nfunction clean(entity) {\n  var propertyNames = entity.propertyNames;\n  var propertyNamesLength = propertyNames.length;\n\n  for (var i = 0; i < propertyNamesLength; i++) {\n    entity[propertyNames[i]] = undefined;\n  }\n\n  entity._name = undefined;\n  entity._availability = undefined;\n}\n\nfunction subscribeToEntity(that, eventHash, collectionId, entity) {\n  entityIdScratch[0] = collectionId;\n  entityIdScratch[1] = entity.id;\n  eventHash[JSON.stringify(entityIdScratch)] = entity.definitionChanged.addEventListener(CompositeEntityCollection.prototype._onDefinitionChanged, that);\n}\n\nfunction unsubscribeFromEntity(that, eventHash, collectionId, entity) {\n  entityIdScratch[0] = collectionId;\n  entityIdScratch[1] = entity.id;\n  var id = JSON.stringify(entityIdScratch);\n  eventHash[id]();\n  eventHash[id] = undefined;\n}\n\nfunction recomposite(that) {\n  that._shouldRecomposite = true;\n\n  if (that._suspendCount !== 0) {\n    return;\n  }\n\n  var collections = that._collections;\n  var collectionsLength = collections.length;\n  var collectionsCopy = that._collectionsCopy;\n  var collectionsCopyLength = collectionsCopy.length;\n  var i;\n  var entity;\n  var entities;\n  var iEntities;\n  var collection;\n  var composite = that._composite;\n  var newEntities = new EntityCollection(that);\n  var eventHash = that._eventHash;\n  var collectionId;\n\n  for (i = 0; i < collectionsCopyLength; i++) {\n    collection = collectionsCopy[i];\n    collection.collectionChanged.removeEventListener(CompositeEntityCollection.prototype._onCollectionChanged, that);\n    entities = collection.values;\n    collectionId = collection.id;\n\n    for (iEntities = entities.length - 1; iEntities > -1; iEntities--) {\n      entity = entities[iEntities];\n      unsubscribeFromEntity(that, eventHash, collectionId, entity);\n    }\n  }\n\n  for (i = collectionsLength - 1; i >= 0; i--) {\n    collection = collections[i];\n    collection.collectionChanged.addEventListener(CompositeEntityCollection.prototype._onCollectionChanged, that); //Merge all of the existing entities.\n\n    entities = collection.values;\n    collectionId = collection.id;\n\n    for (iEntities = entities.length - 1; iEntities > -1; iEntities--) {\n      entity = entities[iEntities];\n      subscribeToEntity(that, eventHash, collectionId, entity);\n      var compositeEntity = newEntities.getById(entity.id);\n\n      if (!defined(compositeEntity)) {\n        compositeEntity = composite.getById(entity.id);\n\n        if (!defined(compositeEntity)) {\n          entityOptionsScratch.id = entity.id;\n          compositeEntity = new Entity(entityOptionsScratch);\n        } else {\n          clean(compositeEntity);\n        }\n\n        newEntities.add(compositeEntity);\n      }\n\n      compositeEntity.merge(entity);\n    }\n  }\n\n  that._collectionsCopy = collections.slice(0);\n  composite.suspendEvents();\n  composite.removeAll();\n  var newEntitiesArray = newEntities.values;\n\n  for (i = 0; i < newEntitiesArray.length; i++) {\n    composite.add(newEntitiesArray[i]);\n  }\n\n  composite.resumeEvents();\n}\n/**\n * Non-destructively composites multiple {@link EntityCollection} instances into a single collection.\n * If a Entity with the same ID exists in multiple collections, it is non-destructively\n * merged into a single new entity instance.  If an entity has the same property in multiple\n * collections, the property of the Entity in the last collection of the list it\n * belongs to is used.  CompositeEntityCollection can be used almost anywhere that a\n * EntityCollection is used.\n *\n * @alias CompositeEntityCollection\n * @constructor\n *\n * @param {EntityCollection[]} [collections] The initial list of EntityCollection instances to merge.\n * @param {DataSource|CompositeEntityCollection} [owner] The data source (or composite entity collection) which created this collection.\n */\n\n\nfunction CompositeEntityCollection(collections, owner) {\n  this._owner = owner;\n  this._composite = new EntityCollection(this);\n  this._suspendCount = 0;\n  this._collections = defined(collections) ? collections.slice() : [];\n  this._collectionsCopy = [];\n  this._id = createGuid();\n  this._eventHash = {};\n  recomposite(this);\n  this._shouldRecomposite = false;\n}\n\nObject.defineProperties(CompositeEntityCollection.prototype, {\n  /**\n   * Gets the event that is fired when entities are added or removed from the collection.\n   * The generated event is a {@link EntityCollection.collectionChangedEventCallback}.\n   * @memberof CompositeEntityCollection.prototype\n   * @readonly\n   * @type {Event}\n   */\n  collectionChanged: {\n    get: function () {\n      return this._composite._collectionChanged;\n    }\n  },\n\n  /**\n   * Gets a globally unique identifier for this collection.\n   * @memberof CompositeEntityCollection.prototype\n   * @readonly\n   * @type {String}\n   */\n  id: {\n    get: function () {\n      return this._id;\n    }\n  },\n\n  /**\n   * Gets the array of Entity instances in the collection.\n   * This array should not be modified directly.\n   * @memberof CompositeEntityCollection.prototype\n   * @readonly\n   * @type {Entity[]}\n   */\n  values: {\n    get: function () {\n      return this._composite.values;\n    }\n  },\n\n  /**\n   * Gets the owner of this composite entity collection, ie. the data source or composite entity collection which created it.\n   * @memberof CompositeEntityCollection.prototype\n   * @readonly\n   * @type {DataSource|CompositeEntityCollection}\n   */\n  owner: {\n    get: function () {\n      return this._owner;\n    }\n  }\n});\n/**\n * Adds a collection to the composite.\n *\n * @param {EntityCollection} collection the collection to add.\n * @param {Number} [index] the index to add the collection at.  If omitted, the collection will\n *                         added on top of all existing collections.\n *\n * @exception {DeveloperError} index, if supplied, must be greater than or equal to zero and less than or equal to the number of collections.\n */\n\nCompositeEntityCollection.prototype.addCollection = function (collection, index) {\n  var hasIndex = defined(index); //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(collection)) {\n    throw new DeveloperError(\"collection is required.\");\n  }\n\n  if (hasIndex) {\n    if (index < 0) {\n      throw new DeveloperError(\"index must be greater than or equal to zero.\");\n    } else if (index > this._collections.length) {\n      throw new DeveloperError(\"index must be less than or equal to the number of collections.\");\n    }\n  } //>>includeEnd('debug');\n\n\n  if (!hasIndex) {\n    index = this._collections.length;\n\n    this._collections.push(collection);\n  } else {\n    this._collections.splice(index, 0, collection);\n  }\n\n  recomposite(this);\n};\n/**\n * Removes a collection from this composite, if present.\n *\n * @param {EntityCollection} collection The collection to remove.\n * @returns {Boolean} true if the collection was in the composite and was removed,\n *                    false if the collection was not in the composite.\n */\n\n\nCompositeEntityCollection.prototype.removeCollection = function (collection) {\n  var index = this._collections.indexOf(collection);\n\n  if (index !== -1) {\n    this._collections.splice(index, 1);\n\n    recomposite(this);\n    return true;\n  }\n\n  return false;\n};\n/**\n * Removes all collections from this composite.\n */\n\n\nCompositeEntityCollection.prototype.removeAllCollections = function () {\n  this._collections.length = 0;\n  recomposite(this);\n};\n/**\n * Checks to see if the composite contains a given collection.\n *\n * @param {EntityCollection} collection the collection to check for.\n * @returns {Boolean} true if the composite contains the collection, false otherwise.\n */\n\n\nCompositeEntityCollection.prototype.containsCollection = function (collection) {\n  return this._collections.indexOf(collection) !== -1;\n};\n/**\n * Returns true if the provided entity is in this collection, false otherwise.\n *\n * @param {Entity} entity The entity.\n * @returns {Boolean} true if the provided entity is in this collection, false otherwise.\n */\n\n\nCompositeEntityCollection.prototype.contains = function (entity) {\n  return this._composite.contains(entity);\n};\n/**\n * Determines the index of a given collection in the composite.\n *\n * @param {EntityCollection} collection The collection to find the index of.\n * @returns {Number} The index of the collection in the composite, or -1 if the collection does not exist in the composite.\n */\n\n\nCompositeEntityCollection.prototype.indexOfCollection = function (collection) {\n  return this._collections.indexOf(collection);\n};\n/**\n * Gets a collection by index from the composite.\n *\n * @param {Number} index the index to retrieve.\n */\n\n\nCompositeEntityCollection.prototype.getCollection = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\", \"index\");\n  } //>>includeEnd('debug');\n\n\n  return this._collections[index];\n};\n/**\n * Gets the number of collections in this composite.\n */\n\n\nCompositeEntityCollection.prototype.getCollectionsLength = function () {\n  return this._collections.length;\n};\n\nfunction getCollectionIndex(collections, collection) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(collection)) {\n    throw new DeveloperError(\"collection is required.\");\n  } //>>includeEnd('debug');\n\n\n  var index = collections.indexOf(collection); //>>includeStart('debug', pragmas.debug);\n\n  if (index === -1) {\n    throw new DeveloperError(\"collection is not in this composite.\");\n  } //>>includeEnd('debug');\n\n\n  return index;\n}\n\nfunction swapCollections(composite, i, j) {\n  var arr = composite._collections;\n  i = CesiumMath.clamp(i, 0, arr.length - 1);\n  j = CesiumMath.clamp(j, 0, arr.length - 1);\n\n  if (i === j) {\n    return;\n  }\n\n  var temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n  recomposite(composite);\n}\n/**\n * Raises a collection up one position in the composite.\n *\n * @param {EntityCollection} collection the collection to move.\n *\n * @exception {DeveloperError} collection is not in this composite.\n */\n\n\nCompositeEntityCollection.prototype.raiseCollection = function (collection) {\n  var index = getCollectionIndex(this._collections, collection);\n  swapCollections(this, index, index + 1);\n};\n/**\n * Lowers a collection down one position in the composite.\n *\n * @param {EntityCollection} collection the collection to move.\n *\n * @exception {DeveloperError} collection is not in this composite.\n */\n\n\nCompositeEntityCollection.prototype.lowerCollection = function (collection) {\n  var index = getCollectionIndex(this._collections, collection);\n  swapCollections(this, index, index - 1);\n};\n/**\n * Raises a collection to the top of the composite.\n *\n * @param {EntityCollection} collection the collection to move.\n *\n * @exception {DeveloperError} collection is not in this composite.\n */\n\n\nCompositeEntityCollection.prototype.raiseCollectionToTop = function (collection) {\n  var index = getCollectionIndex(this._collections, collection);\n\n  if (index === this._collections.length - 1) {\n    return;\n  }\n\n  this._collections.splice(index, 1);\n\n  this._collections.push(collection);\n\n  recomposite(this);\n};\n/**\n * Lowers a collection to the bottom of the composite.\n *\n * @param {EntityCollection} collection the collection to move.\n *\n * @exception {DeveloperError} collection is not in this composite.\n */\n\n\nCompositeEntityCollection.prototype.lowerCollectionToBottom = function (collection) {\n  var index = getCollectionIndex(this._collections, collection);\n\n  if (index === 0) {\n    return;\n  }\n\n  this._collections.splice(index, 1);\n\n  this._collections.splice(0, 0, collection);\n\n  recomposite(this);\n};\n/**\n * Prevents {@link EntityCollection#collectionChanged} events from being raised\n * until a corresponding call is made to {@link EntityCollection#resumeEvents}, at which\n * point a single event will be raised that covers all suspended operations.\n * This allows for many items to be added and removed efficiently.\n * While events are suspended, recompositing of the collections will\n * also be suspended, as this can be a costly operation.\n * This function can be safely called multiple times as long as there\n * are corresponding calls to {@link EntityCollection#resumeEvents}.\n */\n\n\nCompositeEntityCollection.prototype.suspendEvents = function () {\n  this._suspendCount++;\n\n  this._composite.suspendEvents();\n};\n/**\n * Resumes raising {@link EntityCollection#collectionChanged} events immediately\n * when an item is added or removed.  Any modifications made while while events were suspended\n * will be triggered as a single event when this function is called.  This function also ensures\n * the collection is recomposited if events are also resumed.\n * This function is reference counted and can safely be called multiple times as long as there\n * are corresponding calls to {@link EntityCollection#resumeEvents}.\n *\n * @exception {DeveloperError} resumeEvents can not be called before suspendEvents.\n */\n\n\nCompositeEntityCollection.prototype.resumeEvents = function () {\n  //>>includeStart('debug', pragmas.debug);\n  if (this._suspendCount === 0) {\n    throw new DeveloperError(\"resumeEvents can not be called before suspendEvents.\");\n  } //>>includeEnd('debug');\n\n\n  this._suspendCount--; // recomposite before triggering events (but only if required for performance) that might depend on a composited collection\n\n  if (this._shouldRecomposite && this._suspendCount === 0) {\n    recomposite(this);\n    this._shouldRecomposite = false;\n  }\n\n  this._composite.resumeEvents();\n};\n/**\n * Computes the maximum availability of the entities in the collection.\n * If the collection contains a mix of infinitely available data and non-infinite data,\n * It will return the interval pertaining to the non-infinite data only.  If all\n * data is infinite, an infinite interval will be returned.\n *\n * @returns {TimeInterval} The availability of entities in the collection.\n */\n\n\nCompositeEntityCollection.prototype.computeAvailability = function () {\n  return this._composite.computeAvailability();\n};\n/**\n * Gets an entity with the specified id.\n *\n * @param {String} id The id of the entity to retrieve.\n * @returns {Entity} The entity with the provided id or undefined if the id did not exist in the collection.\n */\n\n\nCompositeEntityCollection.prototype.getById = function (id) {\n  return this._composite.getById(id);\n};\n\nCompositeEntityCollection.prototype._onCollectionChanged = function (collection, added, removed) {\n  var collections = this._collectionsCopy;\n  var collectionsLength = collections.length;\n  var composite = this._composite;\n  composite.suspendEvents();\n  var i;\n  var q;\n  var entity;\n  var compositeEntity;\n  var removedLength = removed.length;\n  var eventHash = this._eventHash;\n  var collectionId = collection.id;\n\n  for (i = 0; i < removedLength; i++) {\n    var removedEntity = removed[i];\n    unsubscribeFromEntity(this, eventHash, collectionId, removedEntity);\n    var removedId = removedEntity.id; //Check if the removed entity exists in any of the remaining collections\n    //If so, we clean and remerge it.\n\n    for (q = collectionsLength - 1; q >= 0; q--) {\n      entity = collections[q].getById(removedId);\n\n      if (defined(entity)) {\n        if (!defined(compositeEntity)) {\n          compositeEntity = composite.getById(removedId);\n          clean(compositeEntity);\n        }\n\n        compositeEntity.merge(entity);\n      }\n    } //We never retrieved the compositeEntity, which means it no longer\n    //exists in any of the collections, remove it from the composite.\n\n\n    if (!defined(compositeEntity)) {\n      composite.removeById(removedId);\n    }\n\n    compositeEntity = undefined;\n  }\n\n  var addedLength = added.length;\n\n  for (i = 0; i < addedLength; i++) {\n    var addedEntity = added[i];\n    subscribeToEntity(this, eventHash, collectionId, addedEntity);\n    var addedId = addedEntity.id; //We know the added entity exists in at least one collection,\n    //but we need to check all collections and re-merge in order\n    //to maintain the priority of properties.\n\n    for (q = collectionsLength - 1; q >= 0; q--) {\n      entity = collections[q].getById(addedId);\n\n      if (defined(entity)) {\n        if (!defined(compositeEntity)) {\n          compositeEntity = composite.getById(addedId);\n\n          if (!defined(compositeEntity)) {\n            entityOptionsScratch.id = addedId;\n            compositeEntity = new Entity(entityOptionsScratch);\n            composite.add(compositeEntity);\n          } else {\n            clean(compositeEntity);\n          }\n        }\n\n        compositeEntity.merge(entity);\n      }\n    }\n\n    compositeEntity = undefined;\n  }\n\n  composite.resumeEvents();\n};\n\nCompositeEntityCollection.prototype._onDefinitionChanged = function (entity, propertyName, newValue, oldValue) {\n  var collections = this._collections;\n  var composite = this._composite;\n  var collectionsLength = collections.length;\n  var id = entity.id;\n  var compositeEntity = composite.getById(id);\n  var compositeProperty = compositeEntity[propertyName];\n  var newProperty = !defined(compositeProperty);\n  var firstTime = true;\n\n  for (var q = collectionsLength - 1; q >= 0; q--) {\n    var innerEntity = collections[q].getById(entity.id);\n\n    if (defined(innerEntity)) {\n      var property = innerEntity[propertyName];\n\n      if (defined(property)) {\n        if (firstTime) {\n          firstTime = false; //We only want to clone if the property is also mergeable.\n          //This ensures that leaf properties are referenced and not copied,\n          //which is the entire point of compositing.\n\n          if (defined(property.merge) && defined(property.clone)) {\n            compositeProperty = property.clone(compositeProperty);\n          } else {\n            compositeProperty = property;\n            break;\n          }\n        }\n\n        compositeProperty.merge(property);\n      }\n    }\n  }\n\n  if (newProperty && compositeEntity.propertyNames.indexOf(propertyName) === -1) {\n    compositeEntity.addProperty(propertyName);\n  }\n\n  compositeEntity[propertyName] = compositeProperty;\n};\n\nexport default CompositeEntityCollection;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/DataSources/CompositeEntityCollection.js"],"names":["createGuid","defined","DeveloperError","CesiumMath","Entity","EntityCollection","entityOptionsScratch","id","undefined","entityIdScratch","Array","clean","entity","propertyNames","propertyNamesLength","length","i","_name","_availability","subscribeToEntity","that","eventHash","collectionId","JSON","stringify","definitionChanged","addEventListener","CompositeEntityCollection","prototype","_onDefinitionChanged","unsubscribeFromEntity","recomposite","_shouldRecomposite","_suspendCount","collections","_collections","collectionsLength","collectionsCopy","_collectionsCopy","collectionsCopyLength","entities","iEntities","collection","composite","_composite","newEntities","_eventHash","collectionChanged","removeEventListener","_onCollectionChanged","values","compositeEntity","getById","add","merge","slice","suspendEvents","removeAll","newEntitiesArray","resumeEvents","owner","_owner","_id","Object","defineProperties","get","_collectionChanged","addCollection","index","hasIndex","push","splice","removeCollection","indexOf","removeAllCollections","containsCollection","contains","indexOfCollection","getCollection","getCollectionsLength","getCollectionIndex","swapCollections","j","arr","clamp","temp","raiseCollection","lowerCollection","raiseCollectionToTop","lowerCollectionToBottom","computeAvailability","added","removed","q","removedLength","removedEntity","removedId","removeById","addedLength","addedEntity","addedId","propertyName","newValue","oldValue","compositeProperty","newProperty","firstTime","innerEntity","property","clone","addProperty"],"mappings":"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","sourcesContent":["import createGuid from \"../Core/createGuid.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Entity from \"./Entity.js\";\nimport EntityCollection from \"./EntityCollection.js\";\n\nvar entityOptionsScratch = {\n  id: undefined,\n};\nvar entityIdScratch = new Array(2);\n\nfunction clean(entity) {\n  var propertyNames = entity.propertyNames;\n  var propertyNamesLength = propertyNames.length;\n  for (var i = 0; i < propertyNamesLength; i++) {\n    entity[propertyNames[i]] = undefined;\n  }\n  entity._name = undefined;\n  entity._availability = undefined;\n}\n\nfunction subscribeToEntity(that, eventHash, collectionId, entity) {\n  entityIdScratch[0] = collectionId;\n  entityIdScratch[1] = entity.id;\n  eventHash[\n    JSON.stringify(entityIdScratch)\n  ] = entity.definitionChanged.addEventListener(\n    CompositeEntityCollection.prototype._onDefinitionChanged,\n    that\n  );\n}\n\nfunction unsubscribeFromEntity(that, eventHash, collectionId, entity) {\n  entityIdScratch[0] = collectionId;\n  entityIdScratch[1] = entity.id;\n  var id = JSON.stringify(entityIdScratch);\n  eventHash[id]();\n  eventHash[id] = undefined;\n}\n\nfunction recomposite(that) {\n  that._shouldRecomposite = true;\n  if (that._suspendCount !== 0) {\n    return;\n  }\n\n  var collections = that._collections;\n  var collectionsLength = collections.length;\n\n  var collectionsCopy = that._collectionsCopy;\n  var collectionsCopyLength = collectionsCopy.length;\n\n  var i;\n  var entity;\n  var entities;\n  var iEntities;\n  var collection;\n  var composite = that._composite;\n  var newEntities = new EntityCollection(that);\n  var eventHash = that._eventHash;\n  var collectionId;\n\n  for (i = 0; i < collectionsCopyLength; i++) {\n    collection = collectionsCopy[i];\n    collection.collectionChanged.removeEventListener(\n      CompositeEntityCollection.prototype._onCollectionChanged,\n      that\n    );\n    entities = collection.values;\n    collectionId = collection.id;\n    for (iEntities = entities.length - 1; iEntities > -1; iEntities--) {\n      entity = entities[iEntities];\n      unsubscribeFromEntity(that, eventHash, collectionId, entity);\n    }\n  }\n\n  for (i = collectionsLength - 1; i >= 0; i--) {\n    collection = collections[i];\n    collection.collectionChanged.addEventListener(\n      CompositeEntityCollection.prototype._onCollectionChanged,\n      that\n    );\n\n    //Merge all of the existing entities.\n    entities = collection.values;\n    collectionId = collection.id;\n    for (iEntities = entities.length - 1; iEntities > -1; iEntities--) {\n      entity = entities[iEntities];\n      subscribeToEntity(that, eventHash, collectionId, entity);\n\n      var compositeEntity = newEntities.getById(entity.id);\n      if (!defined(compositeEntity)) {\n        compositeEntity = composite.getById(entity.id);\n        if (!defined(compositeEntity)) {\n          entityOptionsScratch.id = entity.id;\n          compositeEntity = new Entity(entityOptionsScratch);\n        } else {\n          clean(compositeEntity);\n        }\n        newEntities.add(compositeEntity);\n      }\n      compositeEntity.merge(entity);\n    }\n  }\n  that._collectionsCopy = collections.slice(0);\n\n  composite.suspendEvents();\n  composite.removeAll();\n  var newEntitiesArray = newEntities.values;\n  for (i = 0; i < newEntitiesArray.length; i++) {\n    composite.add(newEntitiesArray[i]);\n  }\n  composite.resumeEvents();\n}\n\n/**\n * Non-destructively composites multiple {@link EntityCollection} instances into a single collection.\n * If a Entity with the same ID exists in multiple collections, it is non-destructively\n * merged into a single new entity instance.  If an entity has the same property in multiple\n * collections, the property of the Entity in the last collection of the list it\n * belongs to is used.  CompositeEntityCollection can be used almost anywhere that a\n * EntityCollection is used.\n *\n * @alias CompositeEntityCollection\n * @constructor\n *\n * @param {EntityCollection[]} [collections] The initial list of EntityCollection instances to merge.\n * @param {DataSource|CompositeEntityCollection} [owner] The data source (or composite entity collection) which created this collection.\n */\nfunction CompositeEntityCollection(collections, owner) {\n  this._owner = owner;\n  this._composite = new EntityCollection(this);\n  this._suspendCount = 0;\n  this._collections = defined(collections) ? collections.slice() : [];\n  this._collectionsCopy = [];\n  this._id = createGuid();\n  this._eventHash = {};\n  recomposite(this);\n  this._shouldRecomposite = false;\n}\n\nObject.defineProperties(CompositeEntityCollection.prototype, {\n  /**\n   * Gets the event that is fired when entities are added or removed from the collection.\n   * The generated event is a {@link EntityCollection.collectionChangedEventCallback}.\n   * @memberof CompositeEntityCollection.prototype\n   * @readonly\n   * @type {Event}\n   */\n  collectionChanged: {\n    get: function () {\n      return this._composite._collectionChanged;\n    },\n  },\n  /**\n   * Gets a globally unique identifier for this collection.\n   * @memberof CompositeEntityCollection.prototype\n   * @readonly\n   * @type {String}\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n  /**\n   * Gets the array of Entity instances in the collection.\n   * This array should not be modified directly.\n   * @memberof CompositeEntityCollection.prototype\n   * @readonly\n   * @type {Entity[]}\n   */\n  values: {\n    get: function () {\n      return this._composite.values;\n    },\n  },\n  /**\n   * Gets the owner of this composite entity collection, ie. the data source or composite entity collection which created it.\n   * @memberof CompositeEntityCollection.prototype\n   * @readonly\n   * @type {DataSource|CompositeEntityCollection}\n   */\n  owner: {\n    get: function () {\n      return this._owner;\n    },\n  },\n});\n\n/**\n * Adds a collection to the composite.\n *\n * @param {EntityCollection} collection the collection to add.\n * @param {Number} [index] the index to add the collection at.  If omitted, the collection will\n *                         added on top of all existing collections.\n *\n * @exception {DeveloperError} index, if supplied, must be greater than or equal to zero and less than or equal to the number of collections.\n */\nCompositeEntityCollection.prototype.addCollection = function (\n  collection,\n  index\n) {\n  var hasIndex = defined(index);\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(collection)) {\n    throw new DeveloperError(\"collection is required.\");\n  }\n  if (hasIndex) {\n    if (index < 0) {\n      throw new DeveloperError(\"index must be greater than or equal to zero.\");\n    } else if (index > this._collections.length) {\n      throw new DeveloperError(\n        \"index must be less than or equal to the number of collections.\"\n      );\n    }\n  }\n  //>>includeEnd('debug');\n\n  if (!hasIndex) {\n    index = this._collections.length;\n    this._collections.push(collection);\n  } else {\n    this._collections.splice(index, 0, collection);\n  }\n\n  recomposite(this);\n};\n\n/**\n * Removes a collection from this composite, if present.\n *\n * @param {EntityCollection} collection The collection to remove.\n * @returns {Boolean} true if the collection was in the composite and was removed,\n *                    false if the collection was not in the composite.\n */\nCompositeEntityCollection.prototype.removeCollection = function (collection) {\n  var index = this._collections.indexOf(collection);\n  if (index !== -1) {\n    this._collections.splice(index, 1);\n    recomposite(this);\n    return true;\n  }\n  return false;\n};\n\n/**\n * Removes all collections from this composite.\n */\nCompositeEntityCollection.prototype.removeAllCollections = function () {\n  this._collections.length = 0;\n  recomposite(this);\n};\n\n/**\n * Checks to see if the composite contains a given collection.\n *\n * @param {EntityCollection} collection the collection to check for.\n * @returns {Boolean} true if the composite contains the collection, false otherwise.\n */\nCompositeEntityCollection.prototype.containsCollection = function (collection) {\n  return this._collections.indexOf(collection) !== -1;\n};\n\n/**\n * Returns true if the provided entity is in this collection, false otherwise.\n *\n * @param {Entity} entity The entity.\n * @returns {Boolean} true if the provided entity is in this collection, false otherwise.\n */\nCompositeEntityCollection.prototype.contains = function (entity) {\n  return this._composite.contains(entity);\n};\n\n/**\n * Determines the index of a given collection in the composite.\n *\n * @param {EntityCollection} collection The collection to find the index of.\n * @returns {Number} The index of the collection in the composite, or -1 if the collection does not exist in the composite.\n */\nCompositeEntityCollection.prototype.indexOfCollection = function (collection) {\n  return this._collections.indexOf(collection);\n};\n\n/**\n * Gets a collection by index from the composite.\n *\n * @param {Number} index the index to retrieve.\n */\nCompositeEntityCollection.prototype.getCollection = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\", \"index\");\n  }\n  //>>includeEnd('debug');\n\n  return this._collections[index];\n};\n\n/**\n * Gets the number of collections in this composite.\n */\nCompositeEntityCollection.prototype.getCollectionsLength = function () {\n  return this._collections.length;\n};\n\nfunction getCollectionIndex(collections, collection) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(collection)) {\n    throw new DeveloperError(\"collection is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var index = collections.indexOf(collection);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (index === -1) {\n    throw new DeveloperError(\"collection is not in this composite.\");\n  }\n  //>>includeEnd('debug');\n\n  return index;\n}\n\nfunction swapCollections(composite, i, j) {\n  var arr = composite._collections;\n  i = CesiumMath.clamp(i, 0, arr.length - 1);\n  j = CesiumMath.clamp(j, 0, arr.length - 1);\n\n  if (i === j) {\n    return;\n  }\n\n  var temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n\n  recomposite(composite);\n}\n\n/**\n * Raises a collection up one position in the composite.\n *\n * @param {EntityCollection} collection the collection to move.\n *\n * @exception {DeveloperError} collection is not in this composite.\n */\nCompositeEntityCollection.prototype.raiseCollection = function (collection) {\n  var index = getCollectionIndex(this._collections, collection);\n  swapCollections(this, index, index + 1);\n};\n\n/**\n * Lowers a collection down one position in the composite.\n *\n * @param {EntityCollection} collection the collection to move.\n *\n * @exception {DeveloperError} collection is not in this composite.\n */\nCompositeEntityCollection.prototype.lowerCollection = function (collection) {\n  var index = getCollectionIndex(this._collections, collection);\n  swapCollections(this, index, index - 1);\n};\n\n/**\n * Raises a collection to the top of the composite.\n *\n * @param {EntityCollection} collection the collection to move.\n *\n * @exception {DeveloperError} collection is not in this composite.\n */\nCompositeEntityCollection.prototype.raiseCollectionToTop = function (\n  collection\n) {\n  var index = getCollectionIndex(this._collections, collection);\n  if (index === this._collections.length - 1) {\n    return;\n  }\n  this._collections.splice(index, 1);\n  this._collections.push(collection);\n\n  recomposite(this);\n};\n\n/**\n * Lowers a collection to the bottom of the composite.\n *\n * @param {EntityCollection} collection the collection to move.\n *\n * @exception {DeveloperError} collection is not in this composite.\n */\nCompositeEntityCollection.prototype.lowerCollectionToBottom = function (\n  collection\n) {\n  var index = getCollectionIndex(this._collections, collection);\n  if (index === 0) {\n    return;\n  }\n  this._collections.splice(index, 1);\n  this._collections.splice(0, 0, collection);\n\n  recomposite(this);\n};\n\n/**\n * Prevents {@link EntityCollection#collectionChanged} events from being raised\n * until a corresponding call is made to {@link EntityCollection#resumeEvents}, at which\n * point a single event will be raised that covers all suspended operations.\n * This allows for many items to be added and removed efficiently.\n * While events are suspended, recompositing of the collections will\n * also be suspended, as this can be a costly operation.\n * This function can be safely called multiple times as long as there\n * are corresponding calls to {@link EntityCollection#resumeEvents}.\n */\nCompositeEntityCollection.prototype.suspendEvents = function () {\n  this._suspendCount++;\n  this._composite.suspendEvents();\n};\n\n/**\n * Resumes raising {@link EntityCollection#collectionChanged} events immediately\n * when an item is added or removed.  Any modifications made while while events were suspended\n * will be triggered as a single event when this function is called.  This function also ensures\n * the collection is recomposited if events are also resumed.\n * This function is reference counted and can safely be called multiple times as long as there\n * are corresponding calls to {@link EntityCollection#resumeEvents}.\n *\n * @exception {DeveloperError} resumeEvents can not be called before suspendEvents.\n */\nCompositeEntityCollection.prototype.resumeEvents = function () {\n  //>>includeStart('debug', pragmas.debug);\n  if (this._suspendCount === 0) {\n    throw new DeveloperError(\n      \"resumeEvents can not be called before suspendEvents.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._suspendCount--;\n  // recomposite before triggering events (but only if required for performance) that might depend on a composited collection\n  if (this._shouldRecomposite && this._suspendCount === 0) {\n    recomposite(this);\n    this._shouldRecomposite = false;\n  }\n\n  this._composite.resumeEvents();\n};\n\n/**\n * Computes the maximum availability of the entities in the collection.\n * If the collection contains a mix of infinitely available data and non-infinite data,\n * It will return the interval pertaining to the non-infinite data only.  If all\n * data is infinite, an infinite interval will be returned.\n *\n * @returns {TimeInterval} The availability of entities in the collection.\n */\nCompositeEntityCollection.prototype.computeAvailability = function () {\n  return this._composite.computeAvailability();\n};\n\n/**\n * Gets an entity with the specified id.\n *\n * @param {String} id The id of the entity to retrieve.\n * @returns {Entity} The entity with the provided id or undefined if the id did not exist in the collection.\n */\nCompositeEntityCollection.prototype.getById = function (id) {\n  return this._composite.getById(id);\n};\n\nCompositeEntityCollection.prototype._onCollectionChanged = function (\n  collection,\n  added,\n  removed\n) {\n  var collections = this._collectionsCopy;\n  var collectionsLength = collections.length;\n  var composite = this._composite;\n  composite.suspendEvents();\n\n  var i;\n  var q;\n  var entity;\n  var compositeEntity;\n  var removedLength = removed.length;\n  var eventHash = this._eventHash;\n  var collectionId = collection.id;\n  for (i = 0; i < removedLength; i++) {\n    var removedEntity = removed[i];\n    unsubscribeFromEntity(this, eventHash, collectionId, removedEntity);\n\n    var removedId = removedEntity.id;\n    //Check if the removed entity exists in any of the remaining collections\n    //If so, we clean and remerge it.\n    for (q = collectionsLength - 1; q >= 0; q--) {\n      entity = collections[q].getById(removedId);\n      if (defined(entity)) {\n        if (!defined(compositeEntity)) {\n          compositeEntity = composite.getById(removedId);\n          clean(compositeEntity);\n        }\n        compositeEntity.merge(entity);\n      }\n    }\n    //We never retrieved the compositeEntity, which means it no longer\n    //exists in any of the collections, remove it from the composite.\n    if (!defined(compositeEntity)) {\n      composite.removeById(removedId);\n    }\n    compositeEntity = undefined;\n  }\n\n  var addedLength = added.length;\n  for (i = 0; i < addedLength; i++) {\n    var addedEntity = added[i];\n    subscribeToEntity(this, eventHash, collectionId, addedEntity);\n\n    var addedId = addedEntity.id;\n    //We know the added entity exists in at least one collection,\n    //but we need to check all collections and re-merge in order\n    //to maintain the priority of properties.\n    for (q = collectionsLength - 1; q >= 0; q--) {\n      entity = collections[q].getById(addedId);\n      if (defined(entity)) {\n        if (!defined(compositeEntity)) {\n          compositeEntity = composite.getById(addedId);\n          if (!defined(compositeEntity)) {\n            entityOptionsScratch.id = addedId;\n            compositeEntity = new Entity(entityOptionsScratch);\n            composite.add(compositeEntity);\n          } else {\n            clean(compositeEntity);\n          }\n        }\n        compositeEntity.merge(entity);\n      }\n    }\n    compositeEntity = undefined;\n  }\n\n  composite.resumeEvents();\n};\n\nCompositeEntityCollection.prototype._onDefinitionChanged = function (\n  entity,\n  propertyName,\n  newValue,\n  oldValue\n) {\n  var collections = this._collections;\n  var composite = this._composite;\n\n  var collectionsLength = collections.length;\n  var id = entity.id;\n  var compositeEntity = composite.getById(id);\n  var compositeProperty = compositeEntity[propertyName];\n  var newProperty = !defined(compositeProperty);\n\n  var firstTime = true;\n  for (var q = collectionsLength - 1; q >= 0; q--) {\n    var innerEntity = collections[q].getById(entity.id);\n    if (defined(innerEntity)) {\n      var property = innerEntity[propertyName];\n      if (defined(property)) {\n        if (firstTime) {\n          firstTime = false;\n          //We only want to clone if the property is also mergeable.\n          //This ensures that leaf properties are referenced and not copied,\n          //which is the entire point of compositing.\n          if (defined(property.merge) && defined(property.clone)) {\n            compositeProperty = property.clone(compositeProperty);\n          } else {\n            compositeProperty = property;\n            break;\n          }\n        }\n        compositeProperty.merge(property);\n      }\n    }\n  }\n\n  if (\n    newProperty &&\n    compositeEntity.propertyNames.indexOf(propertyName) === -1\n  ) {\n    compositeEntity.addProperty(propertyName);\n  }\n\n  compositeEntity[propertyName] = compositeProperty;\n};\nexport default CompositeEntityCollection;\n"]},"metadata":{},"sourceType":"module"}