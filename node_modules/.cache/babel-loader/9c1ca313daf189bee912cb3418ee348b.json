{"ast":null,"code":"import when from \"../ThirdParty/when.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\n/**\n * Geocodes queries containing longitude and latitude coordinates and an optional height.\n * Query format: `longitude latitude (height)` with longitude/latitude in degrees and height in meters.\n *\n * @alias CartographicGeocoderService\n * @constructor\n */\n\nfunction CartographicGeocoderService() {}\n/**\n * @function\n *\n * @param {String} query The query to be sent to the geocoder service\n * @returns {Promise<GeocoderService~Result[]>}\n */\n\n\nCartographicGeocoderService.prototype.geocode = function (query) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"query\", query); //>>includeEnd('debug');\n\n  var splitQuery = query.match(/[^\\s,\\n]+/g);\n\n  if (splitQuery.length === 2 || splitQuery.length === 3) {\n    var longitude = +splitQuery[0];\n    var latitude = +splitQuery[1];\n    var height = splitQuery.length === 3 ? +splitQuery[2] : 300.0;\n\n    if (isNaN(longitude) && isNaN(latitude)) {\n      var coordTest = /^(\\d+.?\\d*)([nsew])/i;\n\n      for (var i = 0; i < splitQuery.length; ++i) {\n        var splitCoord = splitQuery[i].match(coordTest);\n\n        if (coordTest.test(splitQuery[i]) && splitCoord.length === 3) {\n          if (/^[ns]/i.test(splitCoord[2])) {\n            latitude = /^[n]/i.test(splitCoord[2]) ? +splitCoord[1] : -splitCoord[1];\n          } else if (/^[ew]/i.test(splitCoord[2])) {\n            longitude = /^[e]/i.test(splitCoord[2]) ? +splitCoord[1] : -splitCoord[1];\n          }\n        }\n      }\n    }\n\n    if (!isNaN(longitude) && !isNaN(latitude) && !isNaN(height)) {\n      var result = {\n        displayName: query,\n        destination: Cartesian3.fromDegrees(longitude, latitude, height)\n      };\n      return when.resolve([result]);\n    }\n  }\n\n  return when.resolve([]);\n};\n\nexport default CartographicGeocoderService;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/CartographicGeocoderService.js"],"names":["when","Cartesian3","Check","CartographicGeocoderService","prototype","geocode","query","typeOf","string","splitQuery","match","length","longitude","latitude","height","isNaN","coordTest","i","splitCoord","test","result","displayName","destination","fromDegrees","resolve"],"mappings":"AAAA,OAAOA,IAAP,MAAiB,uBAAjB;AACA,OAAOC,UAAP,MAAuB,iBAAvB;AACA,OAAOC,KAAP,MAAkB,YAAlB;AAEA;;;;;;;;AAOA,SAASC,2BAAT,GAAuC,CAAE;AAEzC;;;;;;;;AAMAA,2BAA2B,CAACC,SAA5B,CAAsCC,OAAtC,GAAgD,UAAUC,KAAV,EAAiB;AAC/D;AACAJ,EAAAA,KAAK,CAACK,MAAN,CAAaC,MAAb,CAAoB,OAApB,EAA6BF,KAA7B,EAF+D,CAG/D;;AAEA,MAAIG,UAAU,GAAGH,KAAK,CAACI,KAAN,CAAY,YAAZ,CAAjB;;AACA,MAAID,UAAU,CAACE,MAAX,KAAsB,CAAtB,IAA2BF,UAAU,CAACE,MAAX,KAAsB,CAArD,EAAwD;AACtD,QAAIC,SAAS,GAAG,CAACH,UAAU,CAAC,CAAD,CAA3B;AACA,QAAII,QAAQ,GAAG,CAACJ,UAAU,CAAC,CAAD,CAA1B;AACA,QAAIK,MAAM,GAAGL,UAAU,CAACE,MAAX,KAAsB,CAAtB,GAA0B,CAACF,UAAU,CAAC,CAAD,CAArC,GAA2C,KAAxD;;AAEA,QAAIM,KAAK,CAACH,SAAD,CAAL,IAAoBG,KAAK,CAACF,QAAD,CAA7B,EAAyC;AACvC,UAAIG,SAAS,GAAG,sBAAhB;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,UAAU,CAACE,MAA/B,EAAuC,EAAEM,CAAzC,EAA4C;AAC1C,YAAIC,UAAU,GAAGT,UAAU,CAACQ,CAAD,CAAV,CAAcP,KAAd,CAAoBM,SAApB,CAAjB;;AACA,YAAIA,SAAS,CAACG,IAAV,CAAeV,UAAU,CAACQ,CAAD,CAAzB,KAAiCC,UAAU,CAACP,MAAX,KAAsB,CAA3D,EAA8D;AAC5D,cAAI,SAASQ,IAAT,CAAcD,UAAU,CAAC,CAAD,CAAxB,CAAJ,EAAkC;AAChCL,YAAAA,QAAQ,GAAG,QAAQM,IAAR,CAAaD,UAAU,CAAC,CAAD,CAAvB,IACP,CAACA,UAAU,CAAC,CAAD,CADJ,GAEP,CAACA,UAAU,CAAC,CAAD,CAFf;AAGD,WAJD,MAIO,IAAI,SAASC,IAAT,CAAcD,UAAU,CAAC,CAAD,CAAxB,CAAJ,EAAkC;AACvCN,YAAAA,SAAS,GAAG,QAAQO,IAAR,CAAaD,UAAU,CAAC,CAAD,CAAvB,IACR,CAACA,UAAU,CAAC,CAAD,CADH,GAER,CAACA,UAAU,CAAC,CAAD,CAFf;AAGD;AACF;AACF;AACF;;AAED,QAAI,CAACH,KAAK,CAACH,SAAD,CAAN,IAAqB,CAACG,KAAK,CAACF,QAAD,CAA3B,IAAyC,CAACE,KAAK,CAACD,MAAD,CAAnD,EAA6D;AAC3D,UAAIM,MAAM,GAAG;AACXC,QAAAA,WAAW,EAAEf,KADF;AAEXgB,QAAAA,WAAW,EAAErB,UAAU,CAACsB,WAAX,CAAuBX,SAAvB,EAAkCC,QAAlC,EAA4CC,MAA5C;AAFF,OAAb;AAIA,aAAOd,IAAI,CAACwB,OAAL,CAAa,CAACJ,MAAD,CAAb,CAAP;AACD;AACF;;AACD,SAAOpB,IAAI,CAACwB,OAAL,CAAa,EAAb,CAAP;AACD,CAtCD;;AAuCA,eAAerB,2BAAf","sourcesContent":["import when from \"../ThirdParty/when.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\n\n/**\n * Geocodes queries containing longitude and latitude coordinates and an optional height.\n * Query format: `longitude latitude (height)` with longitude/latitude in degrees and height in meters.\n *\n * @alias CartographicGeocoderService\n * @constructor\n */\nfunction CartographicGeocoderService() {}\n\n/**\n * @function\n *\n * @param {String} query The query to be sent to the geocoder service\n * @returns {Promise<GeocoderService~Result[]>}\n */\nCartographicGeocoderService.prototype.geocode = function (query) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"query\", query);\n  //>>includeEnd('debug');\n\n  var splitQuery = query.match(/[^\\s,\\n]+/g);\n  if (splitQuery.length === 2 || splitQuery.length === 3) {\n    var longitude = +splitQuery[0];\n    var latitude = +splitQuery[1];\n    var height = splitQuery.length === 3 ? +splitQuery[2] : 300.0;\n\n    if (isNaN(longitude) && isNaN(latitude)) {\n      var coordTest = /^(\\d+.?\\d*)([nsew])/i;\n      for (var i = 0; i < splitQuery.length; ++i) {\n        var splitCoord = splitQuery[i].match(coordTest);\n        if (coordTest.test(splitQuery[i]) && splitCoord.length === 3) {\n          if (/^[ns]/i.test(splitCoord[2])) {\n            latitude = /^[n]/i.test(splitCoord[2])\n              ? +splitCoord[1]\n              : -splitCoord[1];\n          } else if (/^[ew]/i.test(splitCoord[2])) {\n            longitude = /^[e]/i.test(splitCoord[2])\n              ? +splitCoord[1]\n              : -splitCoord[1];\n          }\n        }\n      }\n    }\n\n    if (!isNaN(longitude) && !isNaN(latitude) && !isNaN(height)) {\n      var result = {\n        displayName: query,\n        destination: Cartesian3.fromDegrees(longitude, latitude, height),\n      };\n      return when.resolve([result]);\n    }\n  }\n  return when.resolve([]);\n};\nexport default CartographicGeocoderService;\n"]},"metadata":{},"sourceType":"module"}