{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport HermiteSpline from \"./HermiteSpline.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Spline from \"./Spline.js\";\nvar scratchTimeVec = new Cartesian4();\nvar scratchTemp0 = new Cartesian3();\nvar scratchTemp1 = new Cartesian3();\n\nfunction createEvaluateFunction(spline) {\n  var points = spline.points;\n  var times = spline.times;\n\n  if (points.length < 3) {\n    var t0 = times[0];\n    var invSpan = 1.0 / (times[1] - t0);\n    var p0 = points[0];\n    var p1 = points[1];\n    return function (time, result) {\n      if (!defined(result)) {\n        result = new Cartesian3();\n      }\n\n      var u = (time - t0) * invSpan;\n      return Cartesian3.lerp(p0, p1, u, result);\n    };\n  }\n\n  return function (time, result) {\n    if (!defined(result)) {\n      result = new Cartesian3();\n    }\n\n    var i = spline._lastTimeIndex = spline.findTimeInterval(time, spline._lastTimeIndex);\n    var u = (time - times[i]) / (times[i + 1] - times[i]);\n    var timeVec = scratchTimeVec;\n    timeVec.z = u;\n    timeVec.y = u * u;\n    timeVec.x = timeVec.y * u;\n    timeVec.w = 1.0;\n    var p0;\n    var p1;\n    var p2;\n    var p3;\n    var coefs;\n\n    if (i === 0) {\n      p0 = points[0];\n      p1 = points[1];\n      p2 = spline.firstTangent;\n      p3 = Cartesian3.subtract(points[2], p0, scratchTemp0);\n      Cartesian3.multiplyByScalar(p3, 0.5, p3);\n      coefs = Matrix4.multiplyByVector(HermiteSpline.hermiteCoefficientMatrix, timeVec, timeVec);\n    } else if (i === points.length - 2) {\n      p0 = points[i];\n      p1 = points[i + 1];\n      p3 = spline.lastTangent;\n      p2 = Cartesian3.subtract(p1, points[i - 1], scratchTemp0);\n      Cartesian3.multiplyByScalar(p2, 0.5, p2);\n      coefs = Matrix4.multiplyByVector(HermiteSpline.hermiteCoefficientMatrix, timeVec, timeVec);\n    } else {\n      p0 = points[i - 1];\n      p1 = points[i];\n      p2 = points[i + 1];\n      p3 = points[i + 2];\n      coefs = Matrix4.multiplyByVector(CatmullRomSpline.catmullRomCoefficientMatrix, timeVec, timeVec);\n    }\n\n    result = Cartesian3.multiplyByScalar(p0, coefs.x, result);\n    Cartesian3.multiplyByScalar(p1, coefs.y, scratchTemp1);\n    Cartesian3.add(result, scratchTemp1, result);\n    Cartesian3.multiplyByScalar(p2, coefs.z, scratchTemp1);\n    Cartesian3.add(result, scratchTemp1, result);\n    Cartesian3.multiplyByScalar(p3, coefs.w, scratchTemp1);\n    return Cartesian3.add(result, scratchTemp1, result);\n  };\n}\n\nvar firstTangentScratch = new Cartesian3();\nvar lastTangentScratch = new Cartesian3();\n/**\n * A Catmull-Rom spline is a cubic spline where the tangent at control points,\n * except the first and last, are computed using the previous and next control points.\n * Catmull-Rom splines are in the class C<sup>1</sup>.\n *\n * @alias CatmullRomSpline\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {Cartesian3[]} options.points The array of {@link Cartesian3} control points.\n * @param {Cartesian3} [options.firstTangent] The tangent of the curve at the first control point.\n *                     If the tangent is not given, it will be estimated.\n * @param {Cartesian3} [options.lastTangent] The tangent of the curve at the last control point.\n *                     If the tangent is not given, it will be estimated.\n *\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n *\n *\n * @example\n * // spline above the earth from Philadelphia to Los Angeles\n * var spline = new Cesium.CatmullRomSpline({\n *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });\n *\n * var p0 = spline.evaluate(times[i]);         // equal to positions[i]\n * var p1 = spline.evaluate(times[i] + delta); // interpolated value when delta < times[i + 1] - times[i]\n *\n * @see HermiteSpline\n * @see LinearSpline\n * @see QuaternionSpline\n * @see WeightSpline\n */\n\nfunction CatmullRomSpline(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var points = options.points;\n  var times = options.times;\n  var firstTangent = options.firstTangent;\n  var lastTangent = options.lastTangent; //>>includeStart('debug', pragmas.debug);\n\n  Check.defined(\"points\", points);\n  Check.defined(\"times\", times);\n  Check.typeOf.number.greaterThanOrEquals(\"points.length\", points.length, 2);\n  Check.typeOf.number.equals(\"times.length\", \"points.length\", times.length, points.length); //>>includeEnd('debug');\n\n  if (points.length > 2) {\n    if (!defined(firstTangent)) {\n      firstTangent = firstTangentScratch;\n      Cartesian3.multiplyByScalar(points[1], 2.0, firstTangent);\n      Cartesian3.subtract(firstTangent, points[2], firstTangent);\n      Cartesian3.subtract(firstTangent, points[0], firstTangent);\n      Cartesian3.multiplyByScalar(firstTangent, 0.5, firstTangent);\n    }\n\n    if (!defined(lastTangent)) {\n      var n = points.length - 1;\n      lastTangent = lastTangentScratch;\n      Cartesian3.multiplyByScalar(points[n - 1], 2.0, lastTangent);\n      Cartesian3.subtract(points[n], lastTangent, lastTangent);\n      Cartesian3.add(lastTangent, points[n - 2], lastTangent);\n      Cartesian3.multiplyByScalar(lastTangent, 0.5, lastTangent);\n    }\n  }\n\n  this._times = times;\n  this._points = points;\n  this._firstTangent = Cartesian3.clone(firstTangent);\n  this._lastTangent = Cartesian3.clone(lastTangent);\n  this._evaluateFunction = createEvaluateFunction(this);\n  this._lastTimeIndex = 0;\n}\n\nObject.defineProperties(CatmullRomSpline.prototype, {\n  /**\n   * An array of times for the control points.\n   *\n   * @memberof CatmullRomSpline.prototype\n   *\n   * @type {Number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    }\n  },\n\n  /**\n   * An array of {@link Cartesian3} control points.\n   *\n   * @memberof CatmullRomSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  points: {\n    get: function () {\n      return this._points;\n    }\n  },\n\n  /**\n   * The tangent at the first control point.\n   *\n   * @memberof CatmullRomSpline.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  firstTangent: {\n    get: function () {\n      return this._firstTangent;\n    }\n  },\n\n  /**\n   * The tangent at the last control point.\n   *\n   * @memberof CatmullRomSpline.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  lastTangent: {\n    get: function () {\n      return this._lastTangent;\n    }\n  }\n});\n/**\n * @private\n */\n\nCatmullRomSpline.catmullRomCoefficientMatrix = new Matrix4(-0.5, 1.0, -0.5, 0.0, 1.5, -2.5, 0.0, 1.0, -1.5, 2.0, 0.5, 0.0, 0.5, -0.5, 0.0, 0.0);\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {Number} time The time.\n * @returns {Number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\n\nCatmullRomSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, wrapped around to the updated animation.\n */\n\nCatmullRomSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, clamped to the animation period.\n */\n\nCatmullRomSpline.prototype.clampTime = Spline.prototype.clampTime;\n/**\n * Evaluates the curve at a given time.\n *\n * @param {Number} time The time at which to evaluate the curve.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\n\nCatmullRomSpline.prototype.evaluate = function (time, result) {\n  return this._evaluateFunction(time, result);\n};\n\nexport default CatmullRomSpline;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/CatmullRomSpline.js"],"names":["Cartesian3","Cartesian4","Check","defaultValue","defined","HermiteSpline","Matrix4","Spline","scratchTimeVec","scratchTemp0","scratchTemp1","createEvaluateFunction","spline","points","times","length","t0","invSpan","p0","p1","time","result","u","lerp","i","_lastTimeIndex","findTimeInterval","timeVec","z","y","x","w","p2","p3","coefs","firstTangent","subtract","multiplyByScalar","multiplyByVector","hermiteCoefficientMatrix","lastTangent","CatmullRomSpline","catmullRomCoefficientMatrix","add","firstTangentScratch","lastTangentScratch","options","EMPTY_OBJECT","typeOf","number","greaterThanOrEquals","equals","n","_times","_points","_firstTangent","clone","_lastTangent","_evaluateFunction","Object","defineProperties","prototype","get","wrapTime","clampTime","evaluate"],"mappings":"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","sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport HermiteSpline from \"./HermiteSpline.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Spline from \"./Spline.js\";\n\nvar scratchTimeVec = new Cartesian4();\nvar scratchTemp0 = new Cartesian3();\nvar scratchTemp1 = new Cartesian3();\n\nfunction createEvaluateFunction(spline) {\n  var points = spline.points;\n  var times = spline.times;\n\n  if (points.length < 3) {\n    var t0 = times[0];\n    var invSpan = 1.0 / (times[1] - t0);\n\n    var p0 = points[0];\n    var p1 = points[1];\n\n    return function (time, result) {\n      if (!defined(result)) {\n        result = new Cartesian3();\n      }\n      var u = (time - t0) * invSpan;\n      return Cartesian3.lerp(p0, p1, u, result);\n    };\n  }\n\n  return function (time, result) {\n    if (!defined(result)) {\n      result = new Cartesian3();\n    }\n    var i = (spline._lastTimeIndex = spline.findTimeInterval(\n      time,\n      spline._lastTimeIndex\n    ));\n    var u = (time - times[i]) / (times[i + 1] - times[i]);\n\n    var timeVec = scratchTimeVec;\n    timeVec.z = u;\n    timeVec.y = u * u;\n    timeVec.x = timeVec.y * u;\n    timeVec.w = 1.0;\n\n    var p0;\n    var p1;\n    var p2;\n    var p3;\n    var coefs;\n\n    if (i === 0) {\n      p0 = points[0];\n      p1 = points[1];\n      p2 = spline.firstTangent;\n\n      p3 = Cartesian3.subtract(points[2], p0, scratchTemp0);\n      Cartesian3.multiplyByScalar(p3, 0.5, p3);\n\n      coefs = Matrix4.multiplyByVector(\n        HermiteSpline.hermiteCoefficientMatrix,\n        timeVec,\n        timeVec\n      );\n    } else if (i === points.length - 2) {\n      p0 = points[i];\n      p1 = points[i + 1];\n      p3 = spline.lastTangent;\n\n      p2 = Cartesian3.subtract(p1, points[i - 1], scratchTemp0);\n      Cartesian3.multiplyByScalar(p2, 0.5, p2);\n\n      coefs = Matrix4.multiplyByVector(\n        HermiteSpline.hermiteCoefficientMatrix,\n        timeVec,\n        timeVec\n      );\n    } else {\n      p0 = points[i - 1];\n      p1 = points[i];\n      p2 = points[i + 1];\n      p3 = points[i + 2];\n      coefs = Matrix4.multiplyByVector(\n        CatmullRomSpline.catmullRomCoefficientMatrix,\n        timeVec,\n        timeVec\n      );\n    }\n    result = Cartesian3.multiplyByScalar(p0, coefs.x, result);\n    Cartesian3.multiplyByScalar(p1, coefs.y, scratchTemp1);\n    Cartesian3.add(result, scratchTemp1, result);\n    Cartesian3.multiplyByScalar(p2, coefs.z, scratchTemp1);\n    Cartesian3.add(result, scratchTemp1, result);\n    Cartesian3.multiplyByScalar(p3, coefs.w, scratchTemp1);\n    return Cartesian3.add(result, scratchTemp1, result);\n  };\n}\n\nvar firstTangentScratch = new Cartesian3();\nvar lastTangentScratch = new Cartesian3();\n\n/**\n * A Catmull-Rom spline is a cubic spline where the tangent at control points,\n * except the first and last, are computed using the previous and next control points.\n * Catmull-Rom splines are in the class C<sup>1</sup>.\n *\n * @alias CatmullRomSpline\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {Cartesian3[]} options.points The array of {@link Cartesian3} control points.\n * @param {Cartesian3} [options.firstTangent] The tangent of the curve at the first control point.\n *                     If the tangent is not given, it will be estimated.\n * @param {Cartesian3} [options.lastTangent] The tangent of the curve at the last control point.\n *                     If the tangent is not given, it will be estimated.\n *\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n *\n *\n * @example\n * // spline above the earth from Philadelphia to Los Angeles\n * var spline = new Cesium.CatmullRomSpline({\n *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });\n *\n * var p0 = spline.evaluate(times[i]);         // equal to positions[i]\n * var p1 = spline.evaluate(times[i] + delta); // interpolated value when delta < times[i + 1] - times[i]\n *\n * @see HermiteSpline\n * @see LinearSpline\n * @see QuaternionSpline\n * @see WeightSpline\n */\nfunction CatmullRomSpline(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var points = options.points;\n  var times = options.times;\n  var firstTangent = options.firstTangent;\n  var lastTangent = options.lastTangent;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"points\", points);\n  Check.defined(\"times\", times);\n  Check.typeOf.number.greaterThanOrEquals(\"points.length\", points.length, 2);\n  Check.typeOf.number.equals(\n    \"times.length\",\n    \"points.length\",\n    times.length,\n    points.length\n  );\n  //>>includeEnd('debug');\n\n  if (points.length > 2) {\n    if (!defined(firstTangent)) {\n      firstTangent = firstTangentScratch;\n      Cartesian3.multiplyByScalar(points[1], 2.0, firstTangent);\n      Cartesian3.subtract(firstTangent, points[2], firstTangent);\n      Cartesian3.subtract(firstTangent, points[0], firstTangent);\n      Cartesian3.multiplyByScalar(firstTangent, 0.5, firstTangent);\n    }\n\n    if (!defined(lastTangent)) {\n      var n = points.length - 1;\n      lastTangent = lastTangentScratch;\n      Cartesian3.multiplyByScalar(points[n - 1], 2.0, lastTangent);\n      Cartesian3.subtract(points[n], lastTangent, lastTangent);\n      Cartesian3.add(lastTangent, points[n - 2], lastTangent);\n      Cartesian3.multiplyByScalar(lastTangent, 0.5, lastTangent);\n    }\n  }\n\n  this._times = times;\n  this._points = points;\n  this._firstTangent = Cartesian3.clone(firstTangent);\n  this._lastTangent = Cartesian3.clone(lastTangent);\n\n  this._evaluateFunction = createEvaluateFunction(this);\n  this._lastTimeIndex = 0;\n}\n\nObject.defineProperties(CatmullRomSpline.prototype, {\n  /**\n   * An array of times for the control points.\n   *\n   * @memberof CatmullRomSpline.prototype\n   *\n   * @type {Number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    },\n  },\n\n  /**\n   * An array of {@link Cartesian3} control points.\n   *\n   * @memberof CatmullRomSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  points: {\n    get: function () {\n      return this._points;\n    },\n  },\n\n  /**\n   * The tangent at the first control point.\n   *\n   * @memberof CatmullRomSpline.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  firstTangent: {\n    get: function () {\n      return this._firstTangent;\n    },\n  },\n\n  /**\n   * The tangent at the last control point.\n   *\n   * @memberof CatmullRomSpline.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  lastTangent: {\n    get: function () {\n      return this._lastTangent;\n    },\n  },\n});\n\n/**\n * @private\n */\nCatmullRomSpline.catmullRomCoefficientMatrix = new Matrix4(\n  -0.5,\n  1.0,\n  -0.5,\n  0.0,\n  1.5,\n  -2.5,\n  0.0,\n  1.0,\n  -1.5,\n  2.0,\n  0.5,\n  0.0,\n  0.5,\n  -0.5,\n  0.0,\n  0.0\n);\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {Number} time The time.\n * @returns {Number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nCatmullRomSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, wrapped around to the updated animation.\n */\nCatmullRomSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, clamped to the animation period.\n */\nCatmullRomSpline.prototype.clampTime = Spline.prototype.clampTime;\n\n/**\n * Evaluates the curve at a given time.\n *\n * @param {Number} time The time at which to evaluate the curve.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nCatmullRomSpline.prototype.evaluate = function (time, result) {\n  return this._evaluateFunction(time, result);\n};\nexport default CatmullRomSpline;\n"]},"metadata":{},"sourceType":"module"}