{"ast":null,"code":"import defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport destroyObject from \"./destroyObject.js\";\nimport Iso8601 from \"./Iso8601.js\";\nimport JulianDate from \"./JulianDate.js\";\n/**\n * Synchronizes a video element with a simulation clock.\n *\n * @alias VideoSynchronizer\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Clock} [options.clock] The clock instance used to drive the video.\n * @param {HTMLVideoElement} [options.element] The video element to be synchronized.\n * @param {JulianDate} [options.epoch=Iso8601.MINIMUM_VALUE] The simulation time that marks the start of the video.\n * @param {Number} [options.tolerance=1.0] The maximum amount of time, in seconds, that the clock and video can diverge.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Video.html|Video Material Demo}\n */\n\nfunction VideoSynchronizer(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  this._clock = undefined;\n  this._element = undefined;\n  this._clockSubscription = undefined;\n  this._seekFunction = undefined;\n  this._lastPlaybackRate = undefined;\n  this.clock = options.clock;\n  this.element = options.element;\n  /**\n   * Gets or sets the simulation time that marks the start of the video.\n   * @type {JulianDate}\n   * @default Iso8601.MINIMUM_VALUE\n   */\n\n  this.epoch = defaultValue(options.epoch, Iso8601.MINIMUM_VALUE);\n  /**\n   * Gets or sets the amount of time in seconds the video's currentTime\n   * and the clock's currentTime can diverge before a video seek is performed.\n   * Lower values make the synchronization more accurate but video\n   * performance might suffer.  Higher values provide better performance\n   * but at the cost of accuracy.\n   * @type {Number}\n   * @default 1.0\n   */\n\n  this.tolerance = defaultValue(options.tolerance, 1.0);\n  this._seeking = false;\n  this._seekFunction = undefined;\n  this._firstTickAfterSeek = false;\n}\n\nObject.defineProperties(VideoSynchronizer.prototype, {\n  /**\n   * Gets or sets the clock used to drive the video element.\n   *\n   * @memberof VideoSynchronizer.prototype\n   * @type {Clock}\n   */\n  clock: {\n    get: function () {\n      return this._clock;\n    },\n    set: function (value) {\n      var oldValue = this._clock;\n\n      if (oldValue === value) {\n        return;\n      }\n\n      if (defined(oldValue)) {\n        this._clockSubscription();\n\n        this._clockSubscription = undefined;\n      }\n\n      if (defined(value)) {\n        this._clockSubscription = value.onTick.addEventListener(VideoSynchronizer.prototype._onTick, this);\n      }\n\n      this._clock = value;\n    }\n  },\n\n  /**\n   * Gets or sets the video element to synchronize.\n   *\n   * @memberof VideoSynchronizer.prototype\n   * @type {HTMLVideoElement}\n   */\n  element: {\n    get: function () {\n      return this._element;\n    },\n    set: function (value) {\n      var oldValue = this._element;\n\n      if (oldValue === value) {\n        return;\n      }\n\n      if (defined(oldValue)) {\n        oldValue.removeEventListener(\"seeked\", this._seekFunction, false);\n      }\n\n      if (defined(value)) {\n        this._seeking = false;\n        this._seekFunction = createSeekFunction(this);\n        value.addEventListener(\"seeked\", this._seekFunction, false);\n      }\n\n      this._element = value;\n      this._seeking = false;\n      this._firstTickAfterSeek = false;\n    }\n  }\n});\n/**\n * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\n\nVideoSynchronizer.prototype.destroy = function () {\n  this.element = undefined;\n  this.clock = undefined;\n  return destroyObject(this);\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n */\n\n\nVideoSynchronizer.prototype.isDestroyed = function () {\n  return false;\n};\n\nVideoSynchronizer.prototype._trySetPlaybackRate = function (clock) {\n  if (this._lastPlaybackRate === clock.multiplier) {\n    return;\n  }\n\n  var element = this._element;\n\n  try {\n    element.playbackRate = clock.multiplier;\n  } catch (error) {\n    // Seek manually for unsupported playbackRates.\n    element.playbackRate = 0.0;\n  }\n\n  this._lastPlaybackRate = clock.multiplier;\n};\n\nVideoSynchronizer.prototype._onTick = function (clock) {\n  var element = this._element;\n\n  if (!defined(element) || element.readyState < 2) {\n    return;\n  }\n\n  var paused = element.paused;\n  var shouldAnimate = clock.shouldAnimate;\n\n  if (shouldAnimate === paused) {\n    if (shouldAnimate) {\n      element.play();\n    } else {\n      element.pause();\n    }\n  } //We need to avoid constant seeking or the video will\n  //never contain a complete frame for us to render.\n  //So don't do anything if we're seeing or on the first\n  //tick after a seek (the latter of which allows the frame\n  //to actually be rendered.\n\n\n  if (this._seeking || this._firstTickAfterSeek) {\n    this._firstTickAfterSeek = false;\n    return;\n  }\n\n  this._trySetPlaybackRate(clock);\n\n  var clockTime = clock.currentTime;\n  var epoch = defaultValue(this.epoch, Iso8601.MINIMUM_VALUE);\n  var videoTime = JulianDate.secondsDifference(clockTime, epoch);\n  var duration = element.duration;\n  var desiredTime;\n  var currentTime = element.currentTime;\n\n  if (element.loop) {\n    videoTime = videoTime % duration;\n\n    if (videoTime < 0.0) {\n      videoTime = duration - videoTime;\n    }\n\n    desiredTime = videoTime;\n  } else if (videoTime > duration) {\n    desiredTime = duration;\n  } else if (videoTime < 0.0) {\n    desiredTime = 0.0;\n  } else {\n    desiredTime = videoTime;\n  } //If the playing video's time and the scene's clock time\n  //ever drift too far apart, we want to set the video to match\n\n\n  var tolerance = shouldAnimate ? defaultValue(this.tolerance, 1.0) : 0.001;\n\n  if (Math.abs(desiredTime - currentTime) > tolerance) {\n    this._seeking = true;\n    element.currentTime = desiredTime;\n  }\n};\n\nfunction createSeekFunction(that) {\n  return function () {\n    that._seeking = false;\n    that._firstTickAfterSeek = true;\n  };\n}\n\nexport default VideoSynchronizer;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/VideoSynchronizer.js"],"names":["defaultValue","defined","destroyObject","Iso8601","JulianDate","VideoSynchronizer","options","EMPTY_OBJECT","_clock","undefined","_element","_clockSubscription","_seekFunction","_lastPlaybackRate","clock","element","epoch","MINIMUM_VALUE","tolerance","_seeking","_firstTickAfterSeek","Object","defineProperties","prototype","get","set","value","oldValue","onTick","addEventListener","_onTick","removeEventListener","createSeekFunction","destroy","isDestroyed","_trySetPlaybackRate","multiplier","playbackRate","error","readyState","paused","shouldAnimate","play","pause","clockTime","currentTime","videoTime","secondsDifference","duration","desiredTime","loop","Math","abs","that"],"mappings":"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","sourcesContent":["import defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport destroyObject from \"./destroyObject.js\";\nimport Iso8601 from \"./Iso8601.js\";\nimport JulianDate from \"./JulianDate.js\";\n\n/**\n * Synchronizes a video element with a simulation clock.\n *\n * @alias VideoSynchronizer\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Clock} [options.clock] The clock instance used to drive the video.\n * @param {HTMLVideoElement} [options.element] The video element to be synchronized.\n * @param {JulianDate} [options.epoch=Iso8601.MINIMUM_VALUE] The simulation time that marks the start of the video.\n * @param {Number} [options.tolerance=1.0] The maximum amount of time, in seconds, that the clock and video can diverge.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Video.html|Video Material Demo}\n */\nfunction VideoSynchronizer(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._clock = undefined;\n  this._element = undefined;\n  this._clockSubscription = undefined;\n  this._seekFunction = undefined;\n  this._lastPlaybackRate = undefined;\n\n  this.clock = options.clock;\n  this.element = options.element;\n\n  /**\n   * Gets or sets the simulation time that marks the start of the video.\n   * @type {JulianDate}\n   * @default Iso8601.MINIMUM_VALUE\n   */\n  this.epoch = defaultValue(options.epoch, Iso8601.MINIMUM_VALUE);\n\n  /**\n   * Gets or sets the amount of time in seconds the video's currentTime\n   * and the clock's currentTime can diverge before a video seek is performed.\n   * Lower values make the synchronization more accurate but video\n   * performance might suffer.  Higher values provide better performance\n   * but at the cost of accuracy.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.tolerance = defaultValue(options.tolerance, 1.0);\n\n  this._seeking = false;\n  this._seekFunction = undefined;\n  this._firstTickAfterSeek = false;\n}\n\nObject.defineProperties(VideoSynchronizer.prototype, {\n  /**\n   * Gets or sets the clock used to drive the video element.\n   *\n   * @memberof VideoSynchronizer.prototype\n   * @type {Clock}\n   */\n  clock: {\n    get: function () {\n      return this._clock;\n    },\n    set: function (value) {\n      var oldValue = this._clock;\n\n      if (oldValue === value) {\n        return;\n      }\n\n      if (defined(oldValue)) {\n        this._clockSubscription();\n        this._clockSubscription = undefined;\n      }\n\n      if (defined(value)) {\n        this._clockSubscription = value.onTick.addEventListener(\n          VideoSynchronizer.prototype._onTick,\n          this\n        );\n      }\n\n      this._clock = value;\n    },\n  },\n  /**\n   * Gets or sets the video element to synchronize.\n   *\n   * @memberof VideoSynchronizer.prototype\n   * @type {HTMLVideoElement}\n   */\n  element: {\n    get: function () {\n      return this._element;\n    },\n    set: function (value) {\n      var oldValue = this._element;\n\n      if (oldValue === value) {\n        return;\n      }\n\n      if (defined(oldValue)) {\n        oldValue.removeEventListener(\"seeked\", this._seekFunction, false);\n      }\n\n      if (defined(value)) {\n        this._seeking = false;\n        this._seekFunction = createSeekFunction(this);\n        value.addEventListener(\"seeked\", this._seekFunction, false);\n      }\n\n      this._element = value;\n      this._seeking = false;\n      this._firstTickAfterSeek = false;\n    },\n  },\n});\n\n/**\n * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nVideoSynchronizer.prototype.destroy = function () {\n  this.element = undefined;\n  this.clock = undefined;\n  return destroyObject(this);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n */\nVideoSynchronizer.prototype.isDestroyed = function () {\n  return false;\n};\n\nVideoSynchronizer.prototype._trySetPlaybackRate = function (clock) {\n  if (this._lastPlaybackRate === clock.multiplier) {\n    return;\n  }\n\n  var element = this._element;\n  try {\n    element.playbackRate = clock.multiplier;\n  } catch (error) {\n    // Seek manually for unsupported playbackRates.\n    element.playbackRate = 0.0;\n  }\n  this._lastPlaybackRate = clock.multiplier;\n};\n\nVideoSynchronizer.prototype._onTick = function (clock) {\n  var element = this._element;\n  if (!defined(element) || element.readyState < 2) {\n    return;\n  }\n\n  var paused = element.paused;\n  var shouldAnimate = clock.shouldAnimate;\n  if (shouldAnimate === paused) {\n    if (shouldAnimate) {\n      element.play();\n    } else {\n      element.pause();\n    }\n  }\n\n  //We need to avoid constant seeking or the video will\n  //never contain a complete frame for us to render.\n  //So don't do anything if we're seeing or on the first\n  //tick after a seek (the latter of which allows the frame\n  //to actually be rendered.\n  if (this._seeking || this._firstTickAfterSeek) {\n    this._firstTickAfterSeek = false;\n    return;\n  }\n\n  this._trySetPlaybackRate(clock);\n\n  var clockTime = clock.currentTime;\n  var epoch = defaultValue(this.epoch, Iso8601.MINIMUM_VALUE);\n  var videoTime = JulianDate.secondsDifference(clockTime, epoch);\n\n  var duration = element.duration;\n  var desiredTime;\n  var currentTime = element.currentTime;\n  if (element.loop) {\n    videoTime = videoTime % duration;\n    if (videoTime < 0.0) {\n      videoTime = duration - videoTime;\n    }\n    desiredTime = videoTime;\n  } else if (videoTime > duration) {\n    desiredTime = duration;\n  } else if (videoTime < 0.0) {\n    desiredTime = 0.0;\n  } else {\n    desiredTime = videoTime;\n  }\n\n  //If the playing video's time and the scene's clock time\n  //ever drift too far apart, we want to set the video to match\n  var tolerance = shouldAnimate ? defaultValue(this.tolerance, 1.0) : 0.001;\n  if (Math.abs(desiredTime - currentTime) > tolerance) {\n    this._seeking = true;\n    element.currentTime = desiredTime;\n  }\n};\n\nfunction createSeekFunction(that) {\n  return function () {\n    that._seeking = false;\n    that._firstTickAfterSeek = true;\n  };\n}\nexport default VideoSynchronizer;\n"]},"metadata":{},"sourceType":"module"}