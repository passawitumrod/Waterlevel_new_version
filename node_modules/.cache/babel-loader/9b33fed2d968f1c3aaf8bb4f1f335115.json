{"ast":null,"code":"import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport FrustumGeometry from \"./FrustumGeometry.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport OrthographicFrustum from \"./OrthographicFrustum.js\";\nimport PerspectiveFrustum from \"./PerspectiveFrustum.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nvar PERSPECTIVE = 0;\nvar ORTHOGRAPHIC = 1;\n/**\n * A description of the outline of a frustum with the given the origin and orientation.\n *\n * @alias FrustumOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {PerspectiveFrustum|OrthographicFrustum} options.frustum The frustum.\n * @param {Cartesian3} options.origin The origin of the frustum.\n * @param {Quaternion} options.orientation The orientation of the frustum.\n */\n\nfunction FrustumOutlineGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.frustum\", options.frustum);\n  Check.typeOf.object(\"options.origin\", options.origin);\n  Check.typeOf.object(\"options.orientation\", options.orientation); //>>includeEnd('debug');\n\n  var frustum = options.frustum;\n  var orientation = options.orientation;\n  var origin = options.origin; // This is private because it is used by DebugCameraPrimitive to draw a multi-frustum by\n  // creating multiple FrustumOutlineGeometrys. This way the near plane of one frustum doesn't overlap\n  // the far plane of another.\n\n  var drawNearPlane = defaultValue(options._drawNearPlane, true);\n  var frustumType;\n  var frustumPackedLength;\n\n  if (frustum instanceof PerspectiveFrustum) {\n    frustumType = PERSPECTIVE;\n    frustumPackedLength = PerspectiveFrustum.packedLength;\n  } else if (frustum instanceof OrthographicFrustum) {\n    frustumType = ORTHOGRAPHIC;\n    frustumPackedLength = OrthographicFrustum.packedLength;\n  }\n\n  this._frustumType = frustumType;\n  this._frustum = frustum.clone();\n  this._origin = Cartesian3.clone(origin);\n  this._orientation = Quaternion.clone(orientation);\n  this._drawNearPlane = drawNearPlane;\n  this._workerName = \"createFrustumOutlineGeometry\";\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n\n  this.packedLength = 2 + frustumPackedLength + Cartesian3.packedLength + Quaternion.packedLength;\n}\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {FrustumOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\n\nFrustumOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var frustumType = value._frustumType;\n  var frustum = value._frustum;\n  array[startingIndex++] = frustumType;\n\n  if (frustumType === PERSPECTIVE) {\n    PerspectiveFrustum.pack(frustum, array, startingIndex);\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    OrthographicFrustum.pack(frustum, array, startingIndex);\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n\n  Cartesian3.pack(value._origin, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n  Quaternion.pack(value._orientation, array, startingIndex);\n  startingIndex += Quaternion.packedLength;\n  array[startingIndex] = value._drawNearPlane ? 1.0 : 0.0;\n  return array;\n};\n\nvar scratchPackPerspective = new PerspectiveFrustum();\nvar scratchPackOrthographic = new OrthographicFrustum();\nvar scratchPackQuaternion = new Quaternion();\nvar scratchPackorigin = new Cartesian3();\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {FrustumOutlineGeometry} [result] The object into which to store the result.\n */\n\nFrustumOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var frustumType = array[startingIndex++];\n  var frustum;\n\n  if (frustumType === PERSPECTIVE) {\n    frustum = PerspectiveFrustum.unpack(array, startingIndex, scratchPackPerspective);\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    frustum = OrthographicFrustum.unpack(array, startingIndex, scratchPackOrthographic);\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n\n  var origin = Cartesian3.unpack(array, startingIndex, scratchPackorigin);\n  startingIndex += Cartesian3.packedLength;\n  var orientation = Quaternion.unpack(array, startingIndex, scratchPackQuaternion);\n  startingIndex += Quaternion.packedLength;\n  var drawNearPlane = array[startingIndex] === 1.0;\n\n  if (!defined(result)) {\n    return new FrustumOutlineGeometry({\n      frustum: frustum,\n      origin: origin,\n      orientation: orientation,\n      _drawNearPlane: drawNearPlane\n    });\n  }\n\n  var frustumResult = frustumType === result._frustumType ? result._frustum : undefined;\n  result._frustum = frustum.clone(frustumResult);\n  result._frustumType = frustumType;\n  result._origin = Cartesian3.clone(origin, result._origin);\n  result._orientation = Quaternion.clone(orientation, result._orientation);\n  result._drawNearPlane = drawNearPlane;\n  return result;\n};\n/**\n * Computes the geometric representation of a frustum outline, including its vertices, indices, and a bounding sphere.\n *\n * @param {FrustumOutlineGeometry} frustumGeometry A description of the frustum.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\n\n\nFrustumOutlineGeometry.createGeometry = function (frustumGeometry) {\n  var frustumType = frustumGeometry._frustumType;\n  var frustum = frustumGeometry._frustum;\n  var origin = frustumGeometry._origin;\n  var orientation = frustumGeometry._orientation;\n  var drawNearPlane = frustumGeometry._drawNearPlane;\n  var positions = new Float64Array(3 * 4 * 2);\n\n  FrustumGeometry._computeNearFarPlanes(origin, orientation, frustumType, frustum, positions);\n\n  var attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions\n    })\n  });\n  var offset;\n  var index;\n  var numberOfPlanes = drawNearPlane ? 2 : 1;\n  var indices = new Uint16Array(8 * (numberOfPlanes + 1)); // Build the near/far planes\n\n  var i = drawNearPlane ? 0 : 1;\n\n  for (; i < 2; ++i) {\n    offset = drawNearPlane ? i * 8 : 0;\n    index = i * 4;\n    indices[offset] = index;\n    indices[offset + 1] = index + 1;\n    indices[offset + 2] = index + 1;\n    indices[offset + 3] = index + 2;\n    indices[offset + 4] = index + 2;\n    indices[offset + 5] = index + 3;\n    indices[offset + 6] = index + 3;\n    indices[offset + 7] = index;\n  } // Build the sides of the frustums\n\n\n  for (i = 0; i < 2; ++i) {\n    offset = (numberOfPlanes + i) * 8;\n    index = i * 4;\n    indices[offset] = index;\n    indices[offset + 1] = index + 4;\n    indices[offset + 2] = index + 1;\n    indices[offset + 3] = index + 5;\n    indices[offset + 4] = index + 2;\n    indices[offset + 5] = index + 6;\n    indices[offset + 6] = index + 3;\n    indices[offset + 7] = index + 7;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: BoundingSphere.fromVertices(positions)\n  });\n};\n\nexport default FrustumOutlineGeometry;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/FrustumOutlineGeometry.js"],"names":["BoundingSphere","Cartesian3","Check","ComponentDatatype","defaultValue","defined","FrustumGeometry","Geometry","GeometryAttribute","GeometryAttributes","OrthographicFrustum","PerspectiveFrustum","PrimitiveType","Quaternion","PERSPECTIVE","ORTHOGRAPHIC","FrustumOutlineGeometry","options","typeOf","object","frustum","origin","orientation","drawNearPlane","_drawNearPlane","frustumType","frustumPackedLength","packedLength","_frustumType","_frustum","clone","_origin","_orientation","_workerName","pack","value","array","startingIndex","scratchPackPerspective","scratchPackOrthographic","scratchPackQuaternion","scratchPackorigin","unpack","result","frustumResult","undefined","createGeometry","frustumGeometry","positions","Float64Array","_computeNearFarPlanes","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","offset","index","numberOfPlanes","indices","Uint16Array","i","primitiveType","LINES","boundingSphere","fromVertices"],"mappings":"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","sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport FrustumGeometry from \"./FrustumGeometry.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport OrthographicFrustum from \"./OrthographicFrustum.js\";\nimport PerspectiveFrustum from \"./PerspectiveFrustum.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\n\nvar PERSPECTIVE = 0;\nvar ORTHOGRAPHIC = 1;\n\n/**\n * A description of the outline of a frustum with the given the origin and orientation.\n *\n * @alias FrustumOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {PerspectiveFrustum|OrthographicFrustum} options.frustum The frustum.\n * @param {Cartesian3} options.origin The origin of the frustum.\n * @param {Quaternion} options.orientation The orientation of the frustum.\n */\nfunction FrustumOutlineGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.frustum\", options.frustum);\n  Check.typeOf.object(\"options.origin\", options.origin);\n  Check.typeOf.object(\"options.orientation\", options.orientation);\n  //>>includeEnd('debug');\n\n  var frustum = options.frustum;\n  var orientation = options.orientation;\n  var origin = options.origin;\n\n  // This is private because it is used by DebugCameraPrimitive to draw a multi-frustum by\n  // creating multiple FrustumOutlineGeometrys. This way the near plane of one frustum doesn't overlap\n  // the far plane of another.\n  var drawNearPlane = defaultValue(options._drawNearPlane, true);\n\n  var frustumType;\n  var frustumPackedLength;\n  if (frustum instanceof PerspectiveFrustum) {\n    frustumType = PERSPECTIVE;\n    frustumPackedLength = PerspectiveFrustum.packedLength;\n  } else if (frustum instanceof OrthographicFrustum) {\n    frustumType = ORTHOGRAPHIC;\n    frustumPackedLength = OrthographicFrustum.packedLength;\n  }\n\n  this._frustumType = frustumType;\n  this._frustum = frustum.clone();\n  this._origin = Cartesian3.clone(origin);\n  this._orientation = Quaternion.clone(orientation);\n  this._drawNearPlane = drawNearPlane;\n  this._workerName = \"createFrustumOutlineGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  this.packedLength =\n    2 + frustumPackedLength + Cartesian3.packedLength + Quaternion.packedLength;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {FrustumOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nFrustumOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var frustumType = value._frustumType;\n  var frustum = value._frustum;\n\n  array[startingIndex++] = frustumType;\n\n  if (frustumType === PERSPECTIVE) {\n    PerspectiveFrustum.pack(frustum, array, startingIndex);\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    OrthographicFrustum.pack(frustum, array, startingIndex);\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n\n  Cartesian3.pack(value._origin, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n  Quaternion.pack(value._orientation, array, startingIndex);\n  startingIndex += Quaternion.packedLength;\n  array[startingIndex] = value._drawNearPlane ? 1.0 : 0.0;\n\n  return array;\n};\n\nvar scratchPackPerspective = new PerspectiveFrustum();\nvar scratchPackOrthographic = new OrthographicFrustum();\nvar scratchPackQuaternion = new Quaternion();\nvar scratchPackorigin = new Cartesian3();\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {FrustumOutlineGeometry} [result] The object into which to store the result.\n */\nFrustumOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var frustumType = array[startingIndex++];\n\n  var frustum;\n  if (frustumType === PERSPECTIVE) {\n    frustum = PerspectiveFrustum.unpack(\n      array,\n      startingIndex,\n      scratchPackPerspective\n    );\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    frustum = OrthographicFrustum.unpack(\n      array,\n      startingIndex,\n      scratchPackOrthographic\n    );\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n\n  var origin = Cartesian3.unpack(array, startingIndex, scratchPackorigin);\n  startingIndex += Cartesian3.packedLength;\n  var orientation = Quaternion.unpack(\n    array,\n    startingIndex,\n    scratchPackQuaternion\n  );\n  startingIndex += Quaternion.packedLength;\n  var drawNearPlane = array[startingIndex] === 1.0;\n\n  if (!defined(result)) {\n    return new FrustumOutlineGeometry({\n      frustum: frustum,\n      origin: origin,\n      orientation: orientation,\n      _drawNearPlane: drawNearPlane,\n    });\n  }\n\n  var frustumResult =\n    frustumType === result._frustumType ? result._frustum : undefined;\n  result._frustum = frustum.clone(frustumResult);\n\n  result._frustumType = frustumType;\n  result._origin = Cartesian3.clone(origin, result._origin);\n  result._orientation = Quaternion.clone(orientation, result._orientation);\n  result._drawNearPlane = drawNearPlane;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of a frustum outline, including its vertices, indices, and a bounding sphere.\n *\n * @param {FrustumOutlineGeometry} frustumGeometry A description of the frustum.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nFrustumOutlineGeometry.createGeometry = function (frustumGeometry) {\n  var frustumType = frustumGeometry._frustumType;\n  var frustum = frustumGeometry._frustum;\n  var origin = frustumGeometry._origin;\n  var orientation = frustumGeometry._orientation;\n  var drawNearPlane = frustumGeometry._drawNearPlane;\n\n  var positions = new Float64Array(3 * 4 * 2);\n  FrustumGeometry._computeNearFarPlanes(\n    origin,\n    orientation,\n    frustumType,\n    frustum,\n    positions\n  );\n\n  var attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    }),\n  });\n\n  var offset;\n  var index;\n\n  var numberOfPlanes = drawNearPlane ? 2 : 1;\n  var indices = new Uint16Array(8 * (numberOfPlanes + 1));\n\n  // Build the near/far planes\n  var i = drawNearPlane ? 0 : 1;\n  for (; i < 2; ++i) {\n    offset = drawNearPlane ? i * 8 : 0;\n    index = i * 4;\n\n    indices[offset] = index;\n    indices[offset + 1] = index + 1;\n    indices[offset + 2] = index + 1;\n    indices[offset + 3] = index + 2;\n    indices[offset + 4] = index + 2;\n    indices[offset + 5] = index + 3;\n    indices[offset + 6] = index + 3;\n    indices[offset + 7] = index;\n  }\n\n  // Build the sides of the frustums\n  for (i = 0; i < 2; ++i) {\n    offset = (numberOfPlanes + i) * 8;\n    index = i * 4;\n\n    indices[offset] = index;\n    indices[offset + 1] = index + 4;\n    indices[offset + 2] = index + 1;\n    indices[offset + 3] = index + 5;\n    indices[offset + 4] = index + 2;\n    indices[offset + 5] = index + 6;\n    indices[offset + 6] = index + 3;\n    indices[offset + 7] = index + 7;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: BoundingSphere.fromVertices(positions),\n  });\n};\nexport default FrustumOutlineGeometry;\n"]},"metadata":{},"sourceType":"module"}