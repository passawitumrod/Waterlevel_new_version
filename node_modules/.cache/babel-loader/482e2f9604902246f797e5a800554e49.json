{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport ForEach from \"../ThirdParty/GltfPipeline/ForEach.js\";\nimport when from \"../ThirdParty/when.js\";\nimport Model from \"./Model.js\";\nimport ModelInstance from \"./ModelInstance.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\nvar LoadState = {\n  NEEDS_LOAD: 0,\n  LOADING: 1,\n  LOADED: 2,\n  FAILED: 3\n};\n/**\n * A 3D model instance collection. All instances reference the same underlying model, but have unique\n * per-instance properties like model matrix, pick id, etc.\n *\n * Instances are rendered relative-to-center and for best results instances should be positioned close to one another.\n * Otherwise there may be precision issues if, for example, instances are placed on opposite sides of the globe.\n *\n * @alias ModelInstanceCollection\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Object[]} [options.instances] An array of instances, where each instance contains a modelMatrix and optional batchId when options.batchTable is defined.\n * @param {Cesium3DTileBatchTable} [options.batchTable] The batch table of the instanced 3D Tile.\n * @param {Resource|String} [options.url] The url to the .gltf file.\n * @param {Object} [options.requestType] The request type, used for request prioritization\n * @param {Object|ArrayBuffer|Uint8Array} [options.gltf] A glTF JSON object, or a binary glTF buffer.\n * @param {Resource|String} [options.basePath=''] The base path that paths in the glTF JSON are relative to.\n * @param {Boolean} [options.dynamic=false] Hint if instance model matrices will be updated frequently.\n * @param {Boolean} [options.show=true] Determines if the collection will be shown.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each instance is pickable with {@link Scene#pick}.\n * @param {Boolean} [options.asynchronous=true] Determines if model WebGL resource creation will be spread out over several frames or block until completion once all glTF files are loaded.\n * @param {Boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the model is loaded.\n * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the collection casts or receives shadows from light sources.\n * @param {Cartesian2} [options.imageBasedLightingFactor=new Cartesian2(1.0, 1.0)] Scales the diffuse and specular image-based lighting from the earth, sky, atmosphere and star skybox.\n * @param {Cartesian3} [options.lightColor] The light color when shading models. When <code>undefined</code> the scene's light color is used instead.\n * @param {Number} [options.luminanceAtZenith=0.2] The sun's luminance at the zenith in kilo candela per meter squared to use for this model's procedural environment map.\n * @param {Cartesian3[]} [options.sphericalHarmonicCoefficients] The third order spherical harmonic coefficients used for the diffuse color of image-based lighting.\n * @param {String} [options.specularEnvironmentMaps] A URL to a KTX file that contains a cube map of the specular lighting and the convoluted specular mipmaps.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Draws the bounding sphere for the collection.\n * @param {Boolean} [options.debugWireframe=false] For debugging only. Draws the instances in wireframe.\n *\n * @exception {DeveloperError} Must specify either <options.gltf> or <options.url>, but not both.\n * @exception {DeveloperError} Shader program cannot be optimized for instancing. Parameters cannot have any of the following semantics: MODEL, MODELINVERSE, MODELVIEWINVERSE, MODELVIEWPROJECTIONINVERSE, MODELINVERSETRANSPOSE.\n *\n * @private\n */\n\nfunction ModelInstanceCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(options.gltf) && !defined(options.url)) {\n    throw new DeveloperError(\"Either options.gltf or options.url is required.\");\n  }\n\n  if (defined(options.gltf) && defined(options.url)) {\n    throw new DeveloperError(\"Cannot pass in both options.gltf and options.url.\");\n  } //>>includeEnd('debug');\n\n\n  this.show = defaultValue(options.show, true);\n  this._instancingSupported = false;\n  this._dynamic = defaultValue(options.dynamic, false);\n  this._allowPicking = defaultValue(options.allowPicking, true);\n  this._ready = false;\n  this._readyPromise = when.defer();\n  this._state = LoadState.NEEDS_LOAD;\n  this._dirty = false; // Undocumented options\n\n  this._cull = defaultValue(options.cull, true);\n  this._opaquePass = defaultValue(options.opaquePass, Pass.OPAQUE);\n  this._instances = createInstances(this, options.instances); // When the model instance collection is backed by an i3dm tile,\n  // use its batch table resources to modify the shaders, attributes, and uniform maps.\n\n  this._batchTable = options.batchTable;\n  this._model = undefined;\n  this._vertexBufferTypedArray = undefined; // Hold onto the vertex buffer contents when dynamic is true\n\n  this._vertexBuffer = undefined;\n  this._batchIdBuffer = undefined;\n  this._instancedUniformsByProgram = undefined;\n  this._drawCommands = [];\n  this._modelCommands = undefined;\n  this._boundingSphere = createBoundingSphere(this);\n  this._center = Cartesian3.clone(this._boundingSphere.center);\n  this._rtcTransform = new Matrix4();\n  this._rtcModelView = new Matrix4(); // Holds onto uniform\n\n  this._mode = undefined;\n  this.modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this._modelMatrix = Matrix4.clone(this.modelMatrix); // Passed on to Model\n\n  this._url = Resource.createIfNeeded(options.url);\n  this._requestType = options.requestType;\n  this._gltf = options.gltf;\n  this._basePath = Resource.createIfNeeded(options.basePath);\n  this._asynchronous = options.asynchronous;\n  this._incrementallyLoadTextures = options.incrementallyLoadTextures;\n  this._upAxis = options.upAxis; // Undocumented option\n\n  this._forwardAxis = options.forwardAxis; // Undocumented option\n\n  this.shadows = defaultValue(options.shadows, ShadowMode.ENABLED);\n  this._shadows = this.shadows;\n  this._pickIdLoaded = options.pickIdLoaded;\n  this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);\n  this._debugShowBoundingVolume = false;\n  this.debugWireframe = defaultValue(options.debugWireframe, false);\n  this._debugWireframe = false;\n  this._imageBasedLightingFactor = new Cartesian2(1.0, 1.0);\n  Cartesian2.clone(options.imageBasedLightingFactor, this._imageBasedLightingFactor);\n  this.lightColor = options.lightColor;\n  this.luminanceAtZenith = options.luminanceAtZenith;\n  this.sphericalHarmonicCoefficients = options.sphericalHarmonicCoefficients;\n  this.specularEnvironmentMaps = options.specularEnvironmentMaps;\n}\n\nObject.defineProperties(ModelInstanceCollection.prototype, {\n  allowPicking: {\n    get: function () {\n      return this._allowPicking;\n    }\n  },\n  length: {\n    get: function () {\n      return this._instances.length;\n    }\n  },\n  activeAnimations: {\n    get: function () {\n      return this._model.activeAnimations;\n    }\n  },\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    }\n  },\n  imageBasedLightingFactor: {\n    get: function () {\n      return this._imageBasedLightingFactor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.object(\"imageBasedLightingFactor\", value);\n      Check.typeOf.number.greaterThanOrEquals(\"imageBasedLightingFactor.x\", value.x, 0.0);\n      Check.typeOf.number.lessThanOrEquals(\"imageBasedLightingFactor.x\", value.x, 1.0);\n      Check.typeOf.number.greaterThanOrEquals(\"imageBasedLightingFactor.y\", value.y, 0.0);\n      Check.typeOf.number.lessThanOrEquals(\"imageBasedLightingFactor.y\", value.y, 1.0); //>>includeEnd('debug');\n\n      Cartesian2.clone(value, this._imageBasedLightingFactor);\n    }\n  }\n});\n\nfunction createInstances(collection, instancesOptions) {\n  instancesOptions = defaultValue(instancesOptions, []);\n  var length = instancesOptions.length;\n  var instances = new Array(length);\n\n  for (var i = 0; i < length; ++i) {\n    var instanceOptions = instancesOptions[i];\n    var modelMatrix = instanceOptions.modelMatrix;\n    var instanceId = defaultValue(instanceOptions.batchId, i);\n    instances[i] = new ModelInstance(collection, modelMatrix, instanceId);\n  }\n\n  return instances;\n}\n\nfunction createBoundingSphere(collection) {\n  var instancesLength = collection.length;\n  var points = new Array(instancesLength);\n\n  for (var i = 0; i < instancesLength; ++i) {\n    points[i] = Matrix4.getTranslation(collection._instances[i]._modelMatrix, new Cartesian3());\n  }\n\n  return BoundingSphere.fromPoints(points);\n}\n\nvar scratchCartesian = new Cartesian3();\nvar scratchMatrix = new Matrix4();\n\nModelInstanceCollection.prototype.expandBoundingSphere = function (instanceModelMatrix) {\n  var translation = Matrix4.getTranslation(instanceModelMatrix, scratchCartesian);\n  BoundingSphere.expand(this._boundingSphere, translation, this._boundingSphere);\n};\n\nfunction getCheckUniformSemanticFunction(modelSemantics, supportedSemantics, programId, uniformMap) {\n  return function (uniform, uniformName) {\n    var semantic = uniform.semantic;\n\n    if (defined(semantic) && modelSemantics.indexOf(semantic) > -1) {\n      if (supportedSemantics.indexOf(semantic) > -1) {\n        uniformMap[uniformName] = semantic;\n      } else {\n        throw new RuntimeError(\"Shader program cannot be optimized for instancing. \" + 'Uniform \"' + uniformName + '\" in program \"' + programId + '\" uses unsupported semantic \"' + semantic + '\"');\n      }\n    }\n  };\n}\n\nfunction getInstancedUniforms(collection, programId) {\n  if (defined(collection._instancedUniformsByProgram)) {\n    return collection._instancedUniformsByProgram[programId];\n  }\n\n  var instancedUniformsByProgram = {};\n  collection._instancedUniformsByProgram = instancedUniformsByProgram; // When using CESIUM_RTC_MODELVIEW the CESIUM_RTC center is ignored. Instances are always rendered relative-to-center.\n\n  var modelSemantics = [\"MODEL\", \"MODELVIEW\", \"CESIUM_RTC_MODELVIEW\", \"MODELVIEWPROJECTION\", \"MODELINVERSE\", \"MODELVIEWINVERSE\", \"MODELVIEWPROJECTIONINVERSE\", \"MODELINVERSETRANSPOSE\", \"MODELVIEWINVERSETRANSPOSE\"];\n  var supportedSemantics = [\"MODELVIEW\", \"CESIUM_RTC_MODELVIEW\", \"MODELVIEWPROJECTION\", \"MODELVIEWINVERSETRANSPOSE\"];\n  var techniques = collection._model._sourceTechniques;\n\n  for (var techniqueId in techniques) {\n    if (techniques.hasOwnProperty(techniqueId)) {\n      var technique = techniques[techniqueId];\n      var program = technique.program; // Different techniques may share the same program, skip if already processed.\n      // This assumes techniques that share a program do not declare different semantics for the same uniforms.\n\n      if (!defined(instancedUniformsByProgram[program])) {\n        var uniformMap = {};\n        instancedUniformsByProgram[program] = uniformMap;\n        ForEach.techniqueUniform(technique, getCheckUniformSemanticFunction(modelSemantics, supportedSemantics, programId, uniformMap));\n      }\n    }\n  }\n\n  return instancedUniformsByProgram[programId];\n}\n\nfunction getVertexShaderCallback(collection) {\n  return function (vs, programId) {\n    var instancedUniforms = getInstancedUniforms(collection, programId);\n    var usesBatchTable = defined(collection._batchTable);\n    var renamedSource = ShaderSource.replaceMain(vs, \"czm_instancing_main\");\n    var globalVarsHeader = \"\";\n    var globalVarsMain = \"\";\n\n    for (var uniform in instancedUniforms) {\n      if (instancedUniforms.hasOwnProperty(uniform)) {\n        var semantic = instancedUniforms[uniform];\n        var varName;\n\n        if (semantic === \"MODELVIEW\" || semantic === \"CESIUM_RTC_MODELVIEW\") {\n          varName = \"czm_instanced_modelView\";\n        } else if (semantic === \"MODELVIEWPROJECTION\") {\n          varName = \"czm_instanced_modelViewProjection\";\n          globalVarsHeader += \"mat4 czm_instanced_modelViewProjection;\\n\";\n          globalVarsMain += \"czm_instanced_modelViewProjection = czm_projection * czm_instanced_modelView;\\n\";\n        } else if (semantic === \"MODELVIEWINVERSETRANSPOSE\") {\n          varName = \"czm_instanced_modelViewInverseTranspose\";\n          globalVarsHeader += \"mat3 czm_instanced_modelViewInverseTranspose;\\n\";\n          globalVarsMain += \"czm_instanced_modelViewInverseTranspose = mat3(czm_instanced_modelView);\\n\";\n        } // Remove the uniform declaration\n\n\n        var regex = new RegExp(\"uniform.*\" + uniform + \".*\");\n        renamedSource = renamedSource.replace(regex, \"\"); // Replace all occurrences of the uniform with the global variable\n\n        regex = new RegExp(uniform + \"\\\\b\", \"g\");\n        renamedSource = renamedSource.replace(regex, varName);\n      }\n    } // czm_instanced_model is the model matrix of the instance relative to center\n    // czm_instanced_modifiedModelView is the transform from the center to view\n    // czm_instanced_nodeTransform is the local offset of the node within the model\n\n\n    var uniforms = \"uniform mat4 czm_instanced_modifiedModelView;\\n\" + \"uniform mat4 czm_instanced_nodeTransform;\\n\";\n    var batchIdAttribute;\n    var pickAttribute;\n    var pickVarying;\n\n    if (usesBatchTable) {\n      batchIdAttribute = \"attribute float a_batchId;\\n\";\n      pickAttribute = \"\";\n      pickVarying = \"\";\n    } else {\n      batchIdAttribute = \"\";\n      pickAttribute = \"attribute vec4 pickColor;\\n\" + \"varying vec4 v_pickColor;\\n\";\n      pickVarying = \"    v_pickColor = pickColor;\\n\";\n    }\n\n    var instancedSource = uniforms + globalVarsHeader + \"mat4 czm_instanced_modelView;\\n\" + \"attribute vec4 czm_modelMatrixRow0;\\n\" + \"attribute vec4 czm_modelMatrixRow1;\\n\" + \"attribute vec4 czm_modelMatrixRow2;\\n\" + batchIdAttribute + pickAttribute + renamedSource + \"void main()\\n\" + \"{\\n\" + \"    mat4 czm_instanced_model = mat4(czm_modelMatrixRow0.x, czm_modelMatrixRow1.x, czm_modelMatrixRow2.x, 0.0, czm_modelMatrixRow0.y, czm_modelMatrixRow1.y, czm_modelMatrixRow2.y, 0.0, czm_modelMatrixRow0.z, czm_modelMatrixRow1.z, czm_modelMatrixRow2.z, 0.0, czm_modelMatrixRow0.w, czm_modelMatrixRow1.w, czm_modelMatrixRow2.w, 1.0);\\n\" + \"    czm_instanced_modelView = czm_instanced_modifiedModelView * czm_instanced_model * czm_instanced_nodeTransform;\\n\" + globalVarsMain + \"    czm_instancing_main();\\n\" + pickVarying + \"}\\n\";\n\n    if (usesBatchTable) {\n      var gltf = collection._model.gltf;\n      var diffuseAttributeOrUniformName = ModelUtility.getDiffuseAttributeOrUniform(gltf, programId);\n      instancedSource = collection._batchTable.getVertexShaderCallback(true, \"a_batchId\", diffuseAttributeOrUniformName)(instancedSource);\n    }\n\n    return instancedSource;\n  };\n}\n\nfunction getFragmentShaderCallback(collection) {\n  return function (fs, programId) {\n    var batchTable = collection._batchTable;\n\n    if (defined(batchTable)) {\n      var gltf = collection._model.gltf;\n      var diffuseAttributeOrUniformName = ModelUtility.getDiffuseAttributeOrUniform(gltf, programId);\n      fs = batchTable.getFragmentShaderCallback(true, diffuseAttributeOrUniformName)(fs);\n    } else {\n      fs = \"varying vec4 v_pickColor;\\n\" + fs;\n    }\n\n    return fs;\n  };\n}\n\nfunction createModifiedModelView(collection, context) {\n  return function () {\n    return Matrix4.multiply(context.uniformState.view, collection._rtcTransform, collection._rtcModelView);\n  };\n}\n\nfunction createNodeTransformFunction(node) {\n  return function () {\n    return node.computedMatrix;\n  };\n}\n\nfunction getUniformMapCallback(collection, context) {\n  return function (uniformMap, programId, node) {\n    uniformMap = clone(uniformMap);\n    uniformMap.czm_instanced_modifiedModelView = createModifiedModelView(collection, context);\n    uniformMap.czm_instanced_nodeTransform = createNodeTransformFunction(node); // Remove instanced uniforms from the uniform map\n\n    var instancedUniforms = getInstancedUniforms(collection, programId);\n\n    for (var uniform in instancedUniforms) {\n      if (instancedUniforms.hasOwnProperty(uniform)) {\n        delete uniformMap[uniform];\n      }\n    }\n\n    if (defined(collection._batchTable)) {\n      uniformMap = collection._batchTable.getUniformMapCallback()(uniformMap);\n    }\n\n    return uniformMap;\n  };\n}\n\nfunction getVertexShaderNonInstancedCallback(collection) {\n  return function (vs, programId) {\n    if (defined(collection._batchTable)) {\n      var gltf = collection._model.gltf;\n      var diffuseAttributeOrUniformName = ModelUtility.getDiffuseAttributeOrUniform(gltf, programId);\n      vs = collection._batchTable.getVertexShaderCallback(true, \"a_batchId\", diffuseAttributeOrUniformName)(vs); // Treat a_batchId as a uniform rather than a vertex attribute\n\n      vs = \"uniform float a_batchId\\n;\" + vs;\n    }\n\n    return vs;\n  };\n}\n\nfunction getFragmentShaderNonInstancedCallback(collection) {\n  return function (fs, programId) {\n    var batchTable = collection._batchTable;\n\n    if (defined(batchTable)) {\n      var gltf = collection._model.gltf;\n      var diffuseAttributeOrUniformName = ModelUtility.getDiffuseAttributeOrUniform(gltf, programId);\n      fs = batchTable.getFragmentShaderCallback(true, diffuseAttributeOrUniformName)(fs);\n    } else {\n      fs = \"uniform vec4 czm_pickColor;\\n\" + fs;\n    }\n\n    return fs;\n  };\n}\n\nfunction getUniformMapNonInstancedCallback(collection) {\n  return function (uniformMap) {\n    if (defined(collection._batchTable)) {\n      uniformMap = collection._batchTable.getUniformMapCallback()(uniformMap);\n    }\n\n    return uniformMap;\n  };\n}\n\nfunction getVertexBufferTypedArray(collection) {\n  var instances = collection._instances;\n  var instancesLength = collection.length;\n  var collectionCenter = collection._center;\n  var vertexSizeInFloats = 12;\n  var bufferData = collection._vertexBufferTypedArray;\n\n  if (!defined(bufferData)) {\n    bufferData = new Float32Array(instancesLength * vertexSizeInFloats);\n  }\n\n  if (collection._dynamic) {\n    // Hold onto the buffer data so we don't have to allocate new memory every frame.\n    collection._vertexBufferTypedArray = bufferData;\n  }\n\n  for (var i = 0; i < instancesLength; ++i) {\n    var modelMatrix = instances[i]._modelMatrix; // Instance matrix is relative to center\n\n    var instanceMatrix = Matrix4.clone(modelMatrix, scratchMatrix);\n    instanceMatrix[12] -= collectionCenter.x;\n    instanceMatrix[13] -= collectionCenter.y;\n    instanceMatrix[14] -= collectionCenter.z;\n    var offset = i * vertexSizeInFloats; // First three rows of the model matrix\n\n    bufferData[offset + 0] = instanceMatrix[0];\n    bufferData[offset + 1] = instanceMatrix[4];\n    bufferData[offset + 2] = instanceMatrix[8];\n    bufferData[offset + 3] = instanceMatrix[12];\n    bufferData[offset + 4] = instanceMatrix[1];\n    bufferData[offset + 5] = instanceMatrix[5];\n    bufferData[offset + 6] = instanceMatrix[9];\n    bufferData[offset + 7] = instanceMatrix[13];\n    bufferData[offset + 8] = instanceMatrix[2];\n    bufferData[offset + 9] = instanceMatrix[6];\n    bufferData[offset + 10] = instanceMatrix[10];\n    bufferData[offset + 11] = instanceMatrix[14];\n  }\n\n  return bufferData;\n}\n\nfunction createVertexBuffer(collection, context) {\n  var i;\n  var instances = collection._instances;\n  var instancesLength = collection.length;\n  var dynamic = collection._dynamic;\n  var usesBatchTable = defined(collection._batchTable);\n\n  if (usesBatchTable) {\n    var batchIdBufferData = new Uint16Array(instancesLength);\n\n    for (i = 0; i < instancesLength; ++i) {\n      batchIdBufferData[i] = instances[i]._instanceId;\n    }\n\n    collection._batchIdBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: batchIdBufferData,\n      usage: BufferUsage.STATIC_DRAW\n    });\n  }\n\n  if (!usesBatchTable) {\n    var pickIdBuffer = new Uint8Array(instancesLength * 4);\n\n    for (i = 0; i < instancesLength; ++i) {\n      var pickId = collection._pickIds[i];\n      var pickColor = pickId.color;\n      var offset = i * 4;\n      pickIdBuffer[offset] = Color.floatToByte(pickColor.red);\n      pickIdBuffer[offset + 1] = Color.floatToByte(pickColor.green);\n      pickIdBuffer[offset + 2] = Color.floatToByte(pickColor.blue);\n      pickIdBuffer[offset + 3] = Color.floatToByte(pickColor.alpha);\n    }\n\n    collection._pickIdBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: pickIdBuffer,\n      usage: BufferUsage.STATIC_DRAW\n    });\n  }\n\n  var vertexBufferTypedArray = getVertexBufferTypedArray(collection);\n  collection._vertexBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: vertexBufferTypedArray,\n    usage: dynamic ? BufferUsage.STREAM_DRAW : BufferUsage.STATIC_DRAW\n  });\n}\n\nfunction updateVertexBuffer(collection) {\n  var vertexBufferTypedArray = getVertexBufferTypedArray(collection);\n\n  collection._vertexBuffer.copyFromArrayView(vertexBufferTypedArray);\n}\n\nfunction createPickIds(collection, context) {\n  // PERFORMANCE_IDEA: we could skip the pick buffer completely by allocating\n  // a continuous range of pickIds and then converting the base pickId + batchId\n  // to RGBA in the shader.  The only consider is precision issues, which might\n  // not be an issue in WebGL 2.\n  var instances = collection._instances;\n  var instancesLength = instances.length;\n  var pickIds = new Array(instancesLength);\n\n  for (var i = 0; i < instancesLength; ++i) {\n    pickIds[i] = context.createPickId(instances[i]);\n  }\n\n  return pickIds;\n}\n\nfunction createModel(collection, context) {\n  var instancingSupported = collection._instancingSupported;\n  var usesBatchTable = defined(collection._batchTable);\n  var allowPicking = collection._allowPicking;\n  var modelOptions = {\n    url: collection._url,\n    requestType: collection._requestType,\n    gltf: collection._gltf,\n    basePath: collection._basePath,\n    shadows: collection._shadows,\n    cacheKey: undefined,\n    asynchronous: collection._asynchronous,\n    allowPicking: allowPicking,\n    incrementallyLoadTextures: collection._incrementallyLoadTextures,\n    upAxis: collection._upAxis,\n    forwardAxis: collection._forwardAxis,\n    precreatedAttributes: undefined,\n    vertexShaderLoaded: undefined,\n    fragmentShaderLoaded: undefined,\n    uniformMapLoaded: undefined,\n    pickIdLoaded: collection._pickIdLoaded,\n    ignoreCommands: true,\n    opaquePass: collection._opaquePass,\n    imageBasedLightingFactor: collection.imageBasedLightingFactor,\n    lightColor: collection.lightColor,\n    luminanceAtZenith: collection.luminanceAtZenith,\n    sphericalHarmonicCoefficients: collection.sphericalHarmonicCoefficients,\n    specularEnvironmentMaps: collection.specularEnvironmentMaps\n  };\n\n  if (!usesBatchTable) {\n    collection._pickIds = createPickIds(collection, context);\n  }\n\n  if (instancingSupported) {\n    createVertexBuffer(collection, context);\n    var vertexSizeInFloats = 12;\n    var componentSizeInBytes = ComponentDatatype.getSizeInBytes(ComponentDatatype.FLOAT);\n    var instancedAttributes = {\n      czm_modelMatrixRow0: {\n        index: 0,\n        // updated in Model\n        vertexBuffer: collection._vertexBuffer,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        normalize: false,\n        offsetInBytes: 0,\n        strideInBytes: componentSizeInBytes * vertexSizeInFloats,\n        instanceDivisor: 1\n      },\n      czm_modelMatrixRow1: {\n        index: 0,\n        // updated in Model\n        vertexBuffer: collection._vertexBuffer,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        normalize: false,\n        offsetInBytes: componentSizeInBytes * 4,\n        strideInBytes: componentSizeInBytes * vertexSizeInFloats,\n        instanceDivisor: 1\n      },\n      czm_modelMatrixRow2: {\n        index: 0,\n        // updated in Model\n        vertexBuffer: collection._vertexBuffer,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        normalize: false,\n        offsetInBytes: componentSizeInBytes * 8,\n        strideInBytes: componentSizeInBytes * vertexSizeInFloats,\n        instanceDivisor: 1\n      }\n    }; // When using a batch table, add a batch id attribute\n\n    if (usesBatchTable) {\n      instancedAttributes.a_batchId = {\n        index: 0,\n        // updated in Model\n        vertexBuffer: collection._batchIdBuffer,\n        componentsPerAttribute: 1,\n        componentDatatype: ComponentDatatype.UNSIGNED_SHORT,\n        normalize: false,\n        offsetInBytes: 0,\n        strideInBytes: 0,\n        instanceDivisor: 1\n      };\n    }\n\n    if (!usesBatchTable) {\n      instancedAttributes.pickColor = {\n        index: 0,\n        // updated in Model\n        vertexBuffer: collection._pickIdBuffer,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        normalize: true,\n        offsetInBytes: 0,\n        strideInBytes: 0,\n        instanceDivisor: 1\n      };\n    }\n\n    modelOptions.precreatedAttributes = instancedAttributes;\n    modelOptions.vertexShaderLoaded = getVertexShaderCallback(collection);\n    modelOptions.fragmentShaderLoaded = getFragmentShaderCallback(collection);\n    modelOptions.uniformMapLoaded = getUniformMapCallback(collection, context);\n\n    if (defined(collection._url)) {\n      modelOptions.cacheKey = collection._url.getUrlComponent() + \"#instanced\";\n    }\n  } else {\n    modelOptions.vertexShaderLoaded = getVertexShaderNonInstancedCallback(collection);\n    modelOptions.fragmentShaderLoaded = getFragmentShaderNonInstancedCallback(collection);\n    modelOptions.uniformMapLoaded = getUniformMapNonInstancedCallback(collection, context);\n  }\n\n  if (defined(collection._url)) {\n    collection._model = Model.fromGltf(modelOptions);\n  } else {\n    collection._model = new Model(modelOptions);\n  }\n}\n\nfunction updateWireframe(collection) {\n  if (collection._debugWireframe !== collection.debugWireframe) {\n    collection._debugWireframe = collection.debugWireframe; // This assumes the original primitive was TRIANGLES and that the triangles\n    // are connected for the wireframe to look perfect.\n\n    var primitiveType = collection.debugWireframe ? PrimitiveType.LINES : PrimitiveType.TRIANGLES;\n    var commands = collection._drawCommands;\n    var length = commands.length;\n\n    for (var i = 0; i < length; ++i) {\n      commands[i].primitiveType = primitiveType;\n    }\n  }\n}\n\nfunction updateShowBoundingVolume(collection) {\n  if (collection.debugShowBoundingVolume !== collection._debugShowBoundingVolume) {\n    collection._debugShowBoundingVolume = collection.debugShowBoundingVolume;\n    var commands = collection._drawCommands;\n    var length = commands.length;\n\n    for (var i = 0; i < length; ++i) {\n      commands[i].debugShowBoundingVolume = collection.debugShowBoundingVolume;\n    }\n  }\n}\n\nfunction createCommands(collection, drawCommands) {\n  var commandsLength = drawCommands.length;\n  var instancesLength = collection.length;\n  var boundingSphere = collection._boundingSphere;\n  var cull = collection._cull;\n\n  for (var i = 0; i < commandsLength; ++i) {\n    var drawCommand = DrawCommand.shallowClone(drawCommands[i]);\n    drawCommand.instanceCount = instancesLength;\n    drawCommand.boundingVolume = boundingSphere;\n    drawCommand.cull = cull;\n\n    if (defined(collection._batchTable)) {\n      drawCommand.pickId = collection._batchTable.getPickId();\n    } else {\n      drawCommand.pickId = \"v_pickColor\";\n    }\n\n    collection._drawCommands.push(drawCommand);\n  }\n}\n\nfunction createBatchIdFunction(batchId) {\n  return function () {\n    return batchId;\n  };\n}\n\nfunction createPickColorFunction(color) {\n  return function () {\n    return color;\n  };\n}\n\nfunction createCommandsNonInstanced(collection, drawCommands) {\n  // When instancing is disabled, create commands for every instance.\n  var instances = collection._instances;\n  var commandsLength = drawCommands.length;\n  var instancesLength = collection.length;\n  var batchTable = collection._batchTable;\n  var usesBatchTable = defined(batchTable);\n  var cull = collection._cull;\n\n  for (var i = 0; i < commandsLength; ++i) {\n    for (var j = 0; j < instancesLength; ++j) {\n      var drawCommand = DrawCommand.shallowClone(drawCommands[i]);\n      drawCommand.modelMatrix = new Matrix4(); // Updated in updateCommandsNonInstanced\n\n      drawCommand.boundingVolume = new BoundingSphere(); // Updated in updateCommandsNonInstanced\n\n      drawCommand.cull = cull;\n      drawCommand.uniformMap = clone(drawCommand.uniformMap);\n\n      if (usesBatchTable) {\n        drawCommand.uniformMap.a_batchId = createBatchIdFunction(instances[j]._instanceId);\n      } else {\n        var pickId = collection._pickIds[j];\n        drawCommand.uniformMap.czm_pickColor = createPickColorFunction(pickId.color);\n      }\n\n      collection._drawCommands.push(drawCommand);\n    }\n  }\n}\n\nfunction updateCommandsNonInstanced(collection) {\n  var modelCommands = collection._modelCommands;\n  var commandsLength = modelCommands.length;\n  var instancesLength = collection.length;\n  var collectionTransform = collection._rtcTransform;\n  var collectionCenter = collection._center;\n\n  for (var i = 0; i < commandsLength; ++i) {\n    var modelCommand = modelCommands[i];\n\n    for (var j = 0; j < instancesLength; ++j) {\n      var commandIndex = i * instancesLength + j;\n      var drawCommand = collection._drawCommands[commandIndex];\n      var instanceMatrix = Matrix4.clone(collection._instances[j]._modelMatrix, scratchMatrix);\n      instanceMatrix[12] -= collectionCenter.x;\n      instanceMatrix[13] -= collectionCenter.y;\n      instanceMatrix[14] -= collectionCenter.z;\n      instanceMatrix = Matrix4.multiply(collectionTransform, instanceMatrix, scratchMatrix);\n      var nodeMatrix = modelCommand.modelMatrix;\n      var modelMatrix = drawCommand.modelMatrix;\n      Matrix4.multiply(instanceMatrix, nodeMatrix, modelMatrix);\n      var nodeBoundingSphere = modelCommand.boundingVolume;\n      var boundingSphere = drawCommand.boundingVolume;\n      BoundingSphere.transform(nodeBoundingSphere, instanceMatrix, boundingSphere);\n    }\n  }\n}\n\nfunction getModelCommands(model) {\n  var nodeCommands = model._nodeCommands;\n  var length = nodeCommands.length;\n  var drawCommands = [];\n\n  for (var i = 0; i < length; ++i) {\n    var nc = nodeCommands[i];\n\n    if (nc.show) {\n      drawCommands.push(nc.command);\n    }\n  }\n\n  return drawCommands;\n}\n\nfunction commandsDirty(model) {\n  var nodeCommands = model._nodeCommands;\n  var length = nodeCommands.length;\n\n  for (var i = 0; i < length; i++) {\n    var nc = nodeCommands[i];\n\n    if (nc.command.dirty) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction generateModelCommands(modelInstanceCollection, instancingSupported) {\n  modelInstanceCollection._drawCommands = [];\n  var modelCommands = getModelCommands(modelInstanceCollection._model);\n\n  if (instancingSupported) {\n    createCommands(modelInstanceCollection, modelCommands);\n  } else {\n    createCommandsNonInstanced(modelInstanceCollection, modelCommands);\n    updateCommandsNonInstanced(modelInstanceCollection);\n  }\n}\n\nfunction updateShadows(collection) {\n  if (collection.shadows !== collection._shadows) {\n    collection._shadows = collection.shadows;\n    var castShadows = ShadowMode.castShadows(collection.shadows);\n    var receiveShadows = ShadowMode.receiveShadows(collection.shadows);\n    var drawCommands = collection._drawCommands;\n    var length = drawCommands.length;\n\n    for (var i = 0; i < length; ++i) {\n      var drawCommand = drawCommands[i];\n      drawCommand.castShadows = castShadows;\n      drawCommand.receiveShadows = receiveShadows;\n    }\n  }\n}\n\nModelInstanceCollection.prototype.update = function (frameState) {\n  if (frameState.mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  if (!this.show) {\n    return;\n  }\n\n  if (this.length === 0) {\n    return;\n  }\n\n  var context = frameState.context;\n\n  if (this._state === LoadState.NEEDS_LOAD) {\n    this._state = LoadState.LOADING;\n    this._instancingSupported = context.instancedArrays;\n    createModel(this, context);\n    var that = this;\n\n    this._model.readyPromise.otherwise(function (error) {\n      that._state = LoadState.FAILED;\n\n      that._readyPromise.reject(error);\n    });\n  }\n\n  var instancingSupported = this._instancingSupported;\n  var model = this._model;\n  model.imageBasedLightingFactor = this.imageBasedLightingFactor;\n  model.lightColor = this.lightColor;\n  model.luminanceAtZenith = this.luminanceAtZenith;\n  model.sphericalHarmonicCoefficients = this.sphericalHarmonicCoefficients;\n  model.specularEnvironmentMaps = this.specularEnvironmentMaps;\n  model.update(frameState);\n\n  if (model.ready && this._state === LoadState.LOADING) {\n    this._state = LoadState.LOADED;\n    this._ready = true; // Expand bounding volume to fit the radius of the loaded model including the model's offset from the center\n\n    var modelRadius = model.boundingSphere.radius + Cartesian3.magnitude(model.boundingSphere.center);\n    this._boundingSphere.radius += modelRadius;\n    this._modelCommands = getModelCommands(model);\n    generateModelCommands(this, instancingSupported);\n\n    this._readyPromise.resolve(this);\n\n    return;\n  }\n\n  if (this._state !== LoadState.LOADED) {\n    return;\n  }\n\n  var modeChanged = frameState.mode !== this._mode;\n  var modelMatrix = this.modelMatrix;\n  var modelMatrixChanged = !Matrix4.equals(this._modelMatrix, modelMatrix);\n\n  if (modeChanged || modelMatrixChanged) {\n    this._mode = frameState.mode;\n    Matrix4.clone(modelMatrix, this._modelMatrix);\n    var rtcTransform = Matrix4.multiplyByTranslation(this._modelMatrix, this._center, this._rtcTransform);\n\n    if (this._mode !== SceneMode.SCENE3D) {\n      rtcTransform = Transforms.basisTo2D(frameState.mapProjection, rtcTransform, rtcTransform);\n    }\n\n    Matrix4.getTranslation(rtcTransform, this._boundingSphere.center);\n  }\n\n  if (instancingSupported && this._dirty) {\n    // If at least one instance has moved assume the collection is now dynamic\n    this._dynamic = true;\n    this._dirty = false; // PERFORMANCE_IDEA: only update dirty sub-sections instead of the whole collection\n\n    updateVertexBuffer(this);\n  } // If the model was set to rebuild shaders during update, rebuild instanced commands.\n\n\n  if (commandsDirty(model)) {\n    generateModelCommands(this, instancingSupported);\n  } // If any node changes due to an animation, update the commands. This could be inefficient if the model is\n  // composed of many nodes and only one changes, however it is probably fine in the general use case.\n  // Only applies when instancing is disabled. The instanced shader automatically handles node transformations.\n\n\n  if (!instancingSupported && (model.dirty || this._dirty || modeChanged || modelMatrixChanged)) {\n    updateCommandsNonInstanced(this);\n  }\n\n  updateShadows(this);\n  updateWireframe(this);\n  updateShowBoundingVolume(this);\n  var passes = frameState.passes;\n\n  if (!passes.render && !passes.pick) {\n    return;\n  }\n\n  var commandList = frameState.commandList;\n  var commands = this._drawCommands;\n  var commandsLength = commands.length;\n\n  for (var i = 0; i < commandsLength; ++i) {\n    commandList.push(commands[i]);\n  }\n};\n\nModelInstanceCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\nModelInstanceCollection.prototype.destroy = function () {\n  this._model = this._model && this._model.destroy();\n  var pickIds = this._pickIds;\n\n  if (defined(pickIds)) {\n    var length = pickIds.length;\n\n    for (var i = 0; i < length; ++i) {\n      pickIds[i].destroy();\n    }\n  }\n\n  return destroyObject(this);\n};\n\nexport default ModelInstanceCollection;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Scene/ModelInstanceCollection.js"],"names":["BoundingSphere","Cartesian2","Cartesian3","Check","clone","Color","ComponentDatatype","defaultValue","defined","destroyObject","DeveloperError","Matrix4","PrimitiveType","Resource","RuntimeError","Transforms","Buffer","BufferUsage","DrawCommand","Pass","ShaderSource","ForEach","when","Model","ModelInstance","ModelUtility","SceneMode","ShadowMode","LoadState","NEEDS_LOAD","LOADING","LOADED","FAILED","ModelInstanceCollection","options","EMPTY_OBJECT","gltf","url","show","_instancingSupported","_dynamic","dynamic","_allowPicking","allowPicking","_ready","_readyPromise","defer","_state","_dirty","_cull","cull","_opaquePass","opaquePass","OPAQUE","_instances","createInstances","instances","_batchTable","batchTable","_model","undefined","_vertexBufferTypedArray","_vertexBuffer","_batchIdBuffer","_instancedUniformsByProgram","_drawCommands","_modelCommands","_boundingSphere","createBoundingSphere","_center","center","_rtcTransform","_rtcModelView","_mode","modelMatrix","IDENTITY","_modelMatrix","_url","createIfNeeded","_requestType","requestType","_gltf","_basePath","basePath","_asynchronous","asynchronous","_incrementallyLoadTextures","incrementallyLoadTextures","_upAxis","upAxis","_forwardAxis","forwardAxis","shadows","ENABLED","_shadows","_pickIdLoaded","pickIdLoaded","debugShowBoundingVolume","_debugShowBoundingVolume","debugWireframe","_debugWireframe","_imageBasedLightingFactor","imageBasedLightingFactor","lightColor","luminanceAtZenith","sphericalHarmonicCoefficients","specularEnvironmentMaps","Object","defineProperties","prototype","get","length","activeAnimations","ready","readyPromise","promise","set","value","typeOf","object","number","greaterThanOrEquals","x","lessThanOrEquals","y","collection","instancesOptions","Array","i","instanceOptions","instanceId","batchId","instancesLength","points","getTranslation","fromPoints","scratchCartesian","scratchMatrix","expandBoundingSphere","instanceModelMatrix","translation","expand","getCheckUniformSemanticFunction","modelSemantics","supportedSemantics","programId","uniformMap","uniform","uniformName","semantic","indexOf","getInstancedUniforms","instancedUniformsByProgram","techniques","_sourceTechniques","techniqueId","hasOwnProperty","technique","program","techniqueUniform","getVertexShaderCallback","vs","instancedUniforms","usesBatchTable","renamedSource","replaceMain","globalVarsHeader","globalVarsMain","varName","regex","RegExp","replace","uniforms","batchIdAttribute","pickAttribute","pickVarying","instancedSource","diffuseAttributeOrUniformName","getDiffuseAttributeOrUniform","getFragmentShaderCallback","fs","createModifiedModelView","context","multiply","uniformState","view","createNodeTransformFunction","node","computedMatrix","getUniformMapCallback","czm_instanced_modifiedModelView","czm_instanced_nodeTransform","getVertexShaderNonInstancedCallback","getFragmentShaderNonInstancedCallback","getUniformMapNonInstancedCallback","getVertexBufferTypedArray","collectionCenter","vertexSizeInFloats","bufferData","Float32Array","instanceMatrix","z","offset","createVertexBuffer","batchIdBufferData","Uint16Array","_instanceId","typedArray","usage","STATIC_DRAW","pickIdBuffer","Uint8Array","pickId","_pickIds","pickColor","color","floatToByte","red","green","blue","alpha","_pickIdBuffer","vertexBufferTypedArray","STREAM_DRAW","updateVertexBuffer","copyFromArrayView","createPickIds","pickIds","createPickId","createModel","instancingSupported","modelOptions","cacheKey","precreatedAttributes","vertexShaderLoaded","fragmentShaderLoaded","uniformMapLoaded","ignoreCommands","componentSizeInBytes","getSizeInBytes","FLOAT","instancedAttributes","czm_modelMatrixRow0","index","vertexBuffer","componentsPerAttribute","componentDatatype","normalize","offsetInBytes","strideInBytes","instanceDivisor","czm_modelMatrixRow1","czm_modelMatrixRow2","a_batchId","UNSIGNED_SHORT","UNSIGNED_BYTE","getUrlComponent","fromGltf","updateWireframe","primitiveType","LINES","TRIANGLES","commands","updateShowBoundingVolume","createCommands","drawCommands","commandsLength","boundingSphere","drawCommand","shallowClone","instanceCount","boundingVolume","getPickId","push","createBatchIdFunction","createPickColorFunction","createCommandsNonInstanced","j","czm_pickColor","updateCommandsNonInstanced","modelCommands","collectionTransform","modelCommand","commandIndex","nodeMatrix","nodeBoundingSphere","transform","getModelCommands","model","nodeCommands","_nodeCommands","nc","command","commandsDirty","dirty","generateModelCommands","modelInstanceCollection","updateShadows","castShadows","receiveShadows","update","frameState","mode","MORPHING","instancedArrays","that","otherwise","error","reject","modelRadius","radius","magnitude","resolve","modeChanged","modelMatrixChanged","equals","rtcTransform","multiplyByTranslation","SCENE3D","basisTo2D","mapProjection","passes","render","pick","commandList","isDestroyed","destroy"],"mappings":"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","sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport ForEach from \"../ThirdParty/GltfPipeline/ForEach.js\";\nimport when from \"../ThirdParty/when.js\";\nimport Model from \"./Model.js\";\nimport ModelInstance from \"./ModelInstance.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\n\nvar LoadState = {\n  NEEDS_LOAD: 0,\n  LOADING: 1,\n  LOADED: 2,\n  FAILED: 3,\n};\n\n/**\n * A 3D model instance collection. All instances reference the same underlying model, but have unique\n * per-instance properties like model matrix, pick id, etc.\n *\n * Instances are rendered relative-to-center and for best results instances should be positioned close to one another.\n * Otherwise there may be precision issues if, for example, instances are placed on opposite sides of the globe.\n *\n * @alias ModelInstanceCollection\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Object[]} [options.instances] An array of instances, where each instance contains a modelMatrix and optional batchId when options.batchTable is defined.\n * @param {Cesium3DTileBatchTable} [options.batchTable] The batch table of the instanced 3D Tile.\n * @param {Resource|String} [options.url] The url to the .gltf file.\n * @param {Object} [options.requestType] The request type, used for request prioritization\n * @param {Object|ArrayBuffer|Uint8Array} [options.gltf] A glTF JSON object, or a binary glTF buffer.\n * @param {Resource|String} [options.basePath=''] The base path that paths in the glTF JSON are relative to.\n * @param {Boolean} [options.dynamic=false] Hint if instance model matrices will be updated frequently.\n * @param {Boolean} [options.show=true] Determines if the collection will be shown.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each instance is pickable with {@link Scene#pick}.\n * @param {Boolean} [options.asynchronous=true] Determines if model WebGL resource creation will be spread out over several frames or block until completion once all glTF files are loaded.\n * @param {Boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the model is loaded.\n * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the collection casts or receives shadows from light sources.\n * @param {Cartesian2} [options.imageBasedLightingFactor=new Cartesian2(1.0, 1.0)] Scales the diffuse and specular image-based lighting from the earth, sky, atmosphere and star skybox.\n * @param {Cartesian3} [options.lightColor] The light color when shading models. When <code>undefined</code> the scene's light color is used instead.\n * @param {Number} [options.luminanceAtZenith=0.2] The sun's luminance at the zenith in kilo candela per meter squared to use for this model's procedural environment map.\n * @param {Cartesian3[]} [options.sphericalHarmonicCoefficients] The third order spherical harmonic coefficients used for the diffuse color of image-based lighting.\n * @param {String} [options.specularEnvironmentMaps] A URL to a KTX file that contains a cube map of the specular lighting and the convoluted specular mipmaps.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Draws the bounding sphere for the collection.\n * @param {Boolean} [options.debugWireframe=false] For debugging only. Draws the instances in wireframe.\n *\n * @exception {DeveloperError} Must specify either <options.gltf> or <options.url>, but not both.\n * @exception {DeveloperError} Shader program cannot be optimized for instancing. Parameters cannot have any of the following semantics: MODEL, MODELINVERSE, MODELVIEWINVERSE, MODELVIEWPROJECTIONINVERSE, MODELINVERSETRANSPOSE.\n *\n * @private\n */\nfunction ModelInstanceCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.gltf) && !defined(options.url)) {\n    throw new DeveloperError(\"Either options.gltf or options.url is required.\");\n  }\n\n  if (defined(options.gltf) && defined(options.url)) {\n    throw new DeveloperError(\n      \"Cannot pass in both options.gltf and options.url.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this.show = defaultValue(options.show, true);\n\n  this._instancingSupported = false;\n  this._dynamic = defaultValue(options.dynamic, false);\n  this._allowPicking = defaultValue(options.allowPicking, true);\n  this._ready = false;\n  this._readyPromise = when.defer();\n  this._state = LoadState.NEEDS_LOAD;\n  this._dirty = false;\n\n  // Undocumented options\n  this._cull = defaultValue(options.cull, true);\n  this._opaquePass = defaultValue(options.opaquePass, Pass.OPAQUE);\n\n  this._instances = createInstances(this, options.instances);\n\n  // When the model instance collection is backed by an i3dm tile,\n  // use its batch table resources to modify the shaders, attributes, and uniform maps.\n  this._batchTable = options.batchTable;\n\n  this._model = undefined;\n  this._vertexBufferTypedArray = undefined; // Hold onto the vertex buffer contents when dynamic is true\n  this._vertexBuffer = undefined;\n  this._batchIdBuffer = undefined;\n  this._instancedUniformsByProgram = undefined;\n\n  this._drawCommands = [];\n  this._modelCommands = undefined;\n\n  this._boundingSphere = createBoundingSphere(this);\n  this._center = Cartesian3.clone(this._boundingSphere.center);\n  this._rtcTransform = new Matrix4();\n  this._rtcModelView = new Matrix4(); // Holds onto uniform\n\n  this._mode = undefined;\n\n  this.modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this._modelMatrix = Matrix4.clone(this.modelMatrix);\n\n  // Passed on to Model\n  this._url = Resource.createIfNeeded(options.url);\n  this._requestType = options.requestType;\n  this._gltf = options.gltf;\n  this._basePath = Resource.createIfNeeded(options.basePath);\n  this._asynchronous = options.asynchronous;\n  this._incrementallyLoadTextures = options.incrementallyLoadTextures;\n  this._upAxis = options.upAxis; // Undocumented option\n  this._forwardAxis = options.forwardAxis; // Undocumented option\n\n  this.shadows = defaultValue(options.shadows, ShadowMode.ENABLED);\n  this._shadows = this.shadows;\n\n  this._pickIdLoaded = options.pickIdLoaded;\n\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false\n  );\n  this._debugShowBoundingVolume = false;\n\n  this.debugWireframe = defaultValue(options.debugWireframe, false);\n  this._debugWireframe = false;\n\n  this._imageBasedLightingFactor = new Cartesian2(1.0, 1.0);\n  Cartesian2.clone(\n    options.imageBasedLightingFactor,\n    this._imageBasedLightingFactor\n  );\n  this.lightColor = options.lightColor;\n  this.luminanceAtZenith = options.luminanceAtZenith;\n  this.sphericalHarmonicCoefficients = options.sphericalHarmonicCoefficients;\n  this.specularEnvironmentMaps = options.specularEnvironmentMaps;\n}\n\nObject.defineProperties(ModelInstanceCollection.prototype, {\n  allowPicking: {\n    get: function () {\n      return this._allowPicking;\n    },\n  },\n  length: {\n    get: function () {\n      return this._instances.length;\n    },\n  },\n  activeAnimations: {\n    get: function () {\n      return this._model.activeAnimations;\n    },\n  },\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n  imageBasedLightingFactor: {\n    get: function () {\n      return this._imageBasedLightingFactor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.object(\"imageBasedLightingFactor\", value);\n      Check.typeOf.number.greaterThanOrEquals(\n        \"imageBasedLightingFactor.x\",\n        value.x,\n        0.0\n      );\n      Check.typeOf.number.lessThanOrEquals(\n        \"imageBasedLightingFactor.x\",\n        value.x,\n        1.0\n      );\n      Check.typeOf.number.greaterThanOrEquals(\n        \"imageBasedLightingFactor.y\",\n        value.y,\n        0.0\n      );\n      Check.typeOf.number.lessThanOrEquals(\n        \"imageBasedLightingFactor.y\",\n        value.y,\n        1.0\n      );\n      //>>includeEnd('debug');\n      Cartesian2.clone(value, this._imageBasedLightingFactor);\n    },\n  },\n});\n\nfunction createInstances(collection, instancesOptions) {\n  instancesOptions = defaultValue(instancesOptions, []);\n  var length = instancesOptions.length;\n  var instances = new Array(length);\n  for (var i = 0; i < length; ++i) {\n    var instanceOptions = instancesOptions[i];\n    var modelMatrix = instanceOptions.modelMatrix;\n    var instanceId = defaultValue(instanceOptions.batchId, i);\n    instances[i] = new ModelInstance(collection, modelMatrix, instanceId);\n  }\n  return instances;\n}\n\nfunction createBoundingSphere(collection) {\n  var instancesLength = collection.length;\n  var points = new Array(instancesLength);\n  for (var i = 0; i < instancesLength; ++i) {\n    points[i] = Matrix4.getTranslation(\n      collection._instances[i]._modelMatrix,\n      new Cartesian3()\n    );\n  }\n\n  return BoundingSphere.fromPoints(points);\n}\n\nvar scratchCartesian = new Cartesian3();\nvar scratchMatrix = new Matrix4();\n\nModelInstanceCollection.prototype.expandBoundingSphere = function (\n  instanceModelMatrix\n) {\n  var translation = Matrix4.getTranslation(\n    instanceModelMatrix,\n    scratchCartesian\n  );\n  BoundingSphere.expand(\n    this._boundingSphere,\n    translation,\n    this._boundingSphere\n  );\n};\n\nfunction getCheckUniformSemanticFunction(\n  modelSemantics,\n  supportedSemantics,\n  programId,\n  uniformMap\n) {\n  return function (uniform, uniformName) {\n    var semantic = uniform.semantic;\n    if (defined(semantic) && modelSemantics.indexOf(semantic) > -1) {\n      if (supportedSemantics.indexOf(semantic) > -1) {\n        uniformMap[uniformName] = semantic;\n      } else {\n        throw new RuntimeError(\n          \"Shader program cannot be optimized for instancing. \" +\n            'Uniform \"' +\n            uniformName +\n            '\" in program \"' +\n            programId +\n            '\" uses unsupported semantic \"' +\n            semantic +\n            '\"'\n        );\n      }\n    }\n  };\n}\n\nfunction getInstancedUniforms(collection, programId) {\n  if (defined(collection._instancedUniformsByProgram)) {\n    return collection._instancedUniformsByProgram[programId];\n  }\n\n  var instancedUniformsByProgram = {};\n  collection._instancedUniformsByProgram = instancedUniformsByProgram;\n\n  // When using CESIUM_RTC_MODELVIEW the CESIUM_RTC center is ignored. Instances are always rendered relative-to-center.\n  var modelSemantics = [\n    \"MODEL\",\n    \"MODELVIEW\",\n    \"CESIUM_RTC_MODELVIEW\",\n    \"MODELVIEWPROJECTION\",\n    \"MODELINVERSE\",\n    \"MODELVIEWINVERSE\",\n    \"MODELVIEWPROJECTIONINVERSE\",\n    \"MODELINVERSETRANSPOSE\",\n    \"MODELVIEWINVERSETRANSPOSE\",\n  ];\n  var supportedSemantics = [\n    \"MODELVIEW\",\n    \"CESIUM_RTC_MODELVIEW\",\n    \"MODELVIEWPROJECTION\",\n    \"MODELVIEWINVERSETRANSPOSE\",\n  ];\n\n  var techniques = collection._model._sourceTechniques;\n  for (var techniqueId in techniques) {\n    if (techniques.hasOwnProperty(techniqueId)) {\n      var technique = techniques[techniqueId];\n      var program = technique.program;\n\n      // Different techniques may share the same program, skip if already processed.\n      // This assumes techniques that share a program do not declare different semantics for the same uniforms.\n      if (!defined(instancedUniformsByProgram[program])) {\n        var uniformMap = {};\n        instancedUniformsByProgram[program] = uniformMap;\n        ForEach.techniqueUniform(\n          technique,\n          getCheckUniformSemanticFunction(\n            modelSemantics,\n            supportedSemantics,\n            programId,\n            uniformMap\n          )\n        );\n      }\n    }\n  }\n\n  return instancedUniformsByProgram[programId];\n}\n\nfunction getVertexShaderCallback(collection) {\n  return function (vs, programId) {\n    var instancedUniforms = getInstancedUniforms(collection, programId);\n    var usesBatchTable = defined(collection._batchTable);\n\n    var renamedSource = ShaderSource.replaceMain(vs, \"czm_instancing_main\");\n\n    var globalVarsHeader = \"\";\n    var globalVarsMain = \"\";\n    for (var uniform in instancedUniforms) {\n      if (instancedUniforms.hasOwnProperty(uniform)) {\n        var semantic = instancedUniforms[uniform];\n        var varName;\n        if (semantic === \"MODELVIEW\" || semantic === \"CESIUM_RTC_MODELVIEW\") {\n          varName = \"czm_instanced_modelView\";\n        } else if (semantic === \"MODELVIEWPROJECTION\") {\n          varName = \"czm_instanced_modelViewProjection\";\n          globalVarsHeader += \"mat4 czm_instanced_modelViewProjection;\\n\";\n          globalVarsMain +=\n            \"czm_instanced_modelViewProjection = czm_projection * czm_instanced_modelView;\\n\";\n        } else if (semantic === \"MODELVIEWINVERSETRANSPOSE\") {\n          varName = \"czm_instanced_modelViewInverseTranspose\";\n          globalVarsHeader += \"mat3 czm_instanced_modelViewInverseTranspose;\\n\";\n          globalVarsMain +=\n            \"czm_instanced_modelViewInverseTranspose = mat3(czm_instanced_modelView);\\n\";\n        }\n\n        // Remove the uniform declaration\n        var regex = new RegExp(\"uniform.*\" + uniform + \".*\");\n        renamedSource = renamedSource.replace(regex, \"\");\n\n        // Replace all occurrences of the uniform with the global variable\n        regex = new RegExp(uniform + \"\\\\b\", \"g\");\n        renamedSource = renamedSource.replace(regex, varName);\n      }\n    }\n\n    // czm_instanced_model is the model matrix of the instance relative to center\n    // czm_instanced_modifiedModelView is the transform from the center to view\n    // czm_instanced_nodeTransform is the local offset of the node within the model\n    var uniforms =\n      \"uniform mat4 czm_instanced_modifiedModelView;\\n\" +\n      \"uniform mat4 czm_instanced_nodeTransform;\\n\";\n\n    var batchIdAttribute;\n    var pickAttribute;\n    var pickVarying;\n\n    if (usesBatchTable) {\n      batchIdAttribute = \"attribute float a_batchId;\\n\";\n      pickAttribute = \"\";\n      pickVarying = \"\";\n    } else {\n      batchIdAttribute = \"\";\n      pickAttribute =\n        \"attribute vec4 pickColor;\\n\" + \"varying vec4 v_pickColor;\\n\";\n      pickVarying = \"    v_pickColor = pickColor;\\n\";\n    }\n\n    var instancedSource =\n      uniforms +\n      globalVarsHeader +\n      \"mat4 czm_instanced_modelView;\\n\" +\n      \"attribute vec4 czm_modelMatrixRow0;\\n\" +\n      \"attribute vec4 czm_modelMatrixRow1;\\n\" +\n      \"attribute vec4 czm_modelMatrixRow2;\\n\" +\n      batchIdAttribute +\n      pickAttribute +\n      renamedSource +\n      \"void main()\\n\" +\n      \"{\\n\" +\n      \"    mat4 czm_instanced_model = mat4(czm_modelMatrixRow0.x, czm_modelMatrixRow1.x, czm_modelMatrixRow2.x, 0.0, czm_modelMatrixRow0.y, czm_modelMatrixRow1.y, czm_modelMatrixRow2.y, 0.0, czm_modelMatrixRow0.z, czm_modelMatrixRow1.z, czm_modelMatrixRow2.z, 0.0, czm_modelMatrixRow0.w, czm_modelMatrixRow1.w, czm_modelMatrixRow2.w, 1.0);\\n\" +\n      \"    czm_instanced_modelView = czm_instanced_modifiedModelView * czm_instanced_model * czm_instanced_nodeTransform;\\n\" +\n      globalVarsMain +\n      \"    czm_instancing_main();\\n\" +\n      pickVarying +\n      \"}\\n\";\n\n    if (usesBatchTable) {\n      var gltf = collection._model.gltf;\n      var diffuseAttributeOrUniformName = ModelUtility.getDiffuseAttributeOrUniform(\n        gltf,\n        programId\n      );\n      instancedSource = collection._batchTable.getVertexShaderCallback(\n        true,\n        \"a_batchId\",\n        diffuseAttributeOrUniformName\n      )(instancedSource);\n    }\n\n    return instancedSource;\n  };\n}\n\nfunction getFragmentShaderCallback(collection) {\n  return function (fs, programId) {\n    var batchTable = collection._batchTable;\n    if (defined(batchTable)) {\n      var gltf = collection._model.gltf;\n      var diffuseAttributeOrUniformName = ModelUtility.getDiffuseAttributeOrUniform(\n        gltf,\n        programId\n      );\n      fs = batchTable.getFragmentShaderCallback(\n        true,\n        diffuseAttributeOrUniformName\n      )(fs);\n    } else {\n      fs = \"varying vec4 v_pickColor;\\n\" + fs;\n    }\n    return fs;\n  };\n}\n\nfunction createModifiedModelView(collection, context) {\n  return function () {\n    return Matrix4.multiply(\n      context.uniformState.view,\n      collection._rtcTransform,\n      collection._rtcModelView\n    );\n  };\n}\n\nfunction createNodeTransformFunction(node) {\n  return function () {\n    return node.computedMatrix;\n  };\n}\n\nfunction getUniformMapCallback(collection, context) {\n  return function (uniformMap, programId, node) {\n    uniformMap = clone(uniformMap);\n    uniformMap.czm_instanced_modifiedModelView = createModifiedModelView(\n      collection,\n      context\n    );\n    uniformMap.czm_instanced_nodeTransform = createNodeTransformFunction(node);\n\n    // Remove instanced uniforms from the uniform map\n    var instancedUniforms = getInstancedUniforms(collection, programId);\n    for (var uniform in instancedUniforms) {\n      if (instancedUniforms.hasOwnProperty(uniform)) {\n        delete uniformMap[uniform];\n      }\n    }\n\n    if (defined(collection._batchTable)) {\n      uniformMap = collection._batchTable.getUniformMapCallback()(uniformMap);\n    }\n\n    return uniformMap;\n  };\n}\n\nfunction getVertexShaderNonInstancedCallback(collection) {\n  return function (vs, programId) {\n    if (defined(collection._batchTable)) {\n      var gltf = collection._model.gltf;\n      var diffuseAttributeOrUniformName = ModelUtility.getDiffuseAttributeOrUniform(\n        gltf,\n        programId\n      );\n      vs = collection._batchTable.getVertexShaderCallback(\n        true,\n        \"a_batchId\",\n        diffuseAttributeOrUniformName\n      )(vs);\n      // Treat a_batchId as a uniform rather than a vertex attribute\n      vs = \"uniform float a_batchId\\n;\" + vs;\n    }\n    return vs;\n  };\n}\n\nfunction getFragmentShaderNonInstancedCallback(collection) {\n  return function (fs, programId) {\n    var batchTable = collection._batchTable;\n    if (defined(batchTable)) {\n      var gltf = collection._model.gltf;\n      var diffuseAttributeOrUniformName = ModelUtility.getDiffuseAttributeOrUniform(\n        gltf,\n        programId\n      );\n      fs = batchTable.getFragmentShaderCallback(\n        true,\n        diffuseAttributeOrUniformName\n      )(fs);\n    } else {\n      fs = \"uniform vec4 czm_pickColor;\\n\" + fs;\n    }\n    return fs;\n  };\n}\n\nfunction getUniformMapNonInstancedCallback(collection) {\n  return function (uniformMap) {\n    if (defined(collection._batchTable)) {\n      uniformMap = collection._batchTable.getUniformMapCallback()(uniformMap);\n    }\n\n    return uniformMap;\n  };\n}\n\nfunction getVertexBufferTypedArray(collection) {\n  var instances = collection._instances;\n  var instancesLength = collection.length;\n  var collectionCenter = collection._center;\n  var vertexSizeInFloats = 12;\n\n  var bufferData = collection._vertexBufferTypedArray;\n  if (!defined(bufferData)) {\n    bufferData = new Float32Array(instancesLength * vertexSizeInFloats);\n  }\n  if (collection._dynamic) {\n    // Hold onto the buffer data so we don't have to allocate new memory every frame.\n    collection._vertexBufferTypedArray = bufferData;\n  }\n\n  for (var i = 0; i < instancesLength; ++i) {\n    var modelMatrix = instances[i]._modelMatrix;\n\n    // Instance matrix is relative to center\n    var instanceMatrix = Matrix4.clone(modelMatrix, scratchMatrix);\n    instanceMatrix[12] -= collectionCenter.x;\n    instanceMatrix[13] -= collectionCenter.y;\n    instanceMatrix[14] -= collectionCenter.z;\n\n    var offset = i * vertexSizeInFloats;\n\n    // First three rows of the model matrix\n    bufferData[offset + 0] = instanceMatrix[0];\n    bufferData[offset + 1] = instanceMatrix[4];\n    bufferData[offset + 2] = instanceMatrix[8];\n    bufferData[offset + 3] = instanceMatrix[12];\n    bufferData[offset + 4] = instanceMatrix[1];\n    bufferData[offset + 5] = instanceMatrix[5];\n    bufferData[offset + 6] = instanceMatrix[9];\n    bufferData[offset + 7] = instanceMatrix[13];\n    bufferData[offset + 8] = instanceMatrix[2];\n    bufferData[offset + 9] = instanceMatrix[6];\n    bufferData[offset + 10] = instanceMatrix[10];\n    bufferData[offset + 11] = instanceMatrix[14];\n  }\n\n  return bufferData;\n}\n\nfunction createVertexBuffer(collection, context) {\n  var i;\n  var instances = collection._instances;\n  var instancesLength = collection.length;\n  var dynamic = collection._dynamic;\n  var usesBatchTable = defined(collection._batchTable);\n\n  if (usesBatchTable) {\n    var batchIdBufferData = new Uint16Array(instancesLength);\n    for (i = 0; i < instancesLength; ++i) {\n      batchIdBufferData[i] = instances[i]._instanceId;\n    }\n    collection._batchIdBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: batchIdBufferData,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n  }\n\n  if (!usesBatchTable) {\n    var pickIdBuffer = new Uint8Array(instancesLength * 4);\n    for (i = 0; i < instancesLength; ++i) {\n      var pickId = collection._pickIds[i];\n      var pickColor = pickId.color;\n      var offset = i * 4;\n      pickIdBuffer[offset] = Color.floatToByte(pickColor.red);\n      pickIdBuffer[offset + 1] = Color.floatToByte(pickColor.green);\n      pickIdBuffer[offset + 2] = Color.floatToByte(pickColor.blue);\n      pickIdBuffer[offset + 3] = Color.floatToByte(pickColor.alpha);\n    }\n    collection._pickIdBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: pickIdBuffer,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n  }\n\n  var vertexBufferTypedArray = getVertexBufferTypedArray(collection);\n  collection._vertexBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: vertexBufferTypedArray,\n    usage: dynamic ? BufferUsage.STREAM_DRAW : BufferUsage.STATIC_DRAW,\n  });\n}\n\nfunction updateVertexBuffer(collection) {\n  var vertexBufferTypedArray = getVertexBufferTypedArray(collection);\n  collection._vertexBuffer.copyFromArrayView(vertexBufferTypedArray);\n}\n\nfunction createPickIds(collection, context) {\n  // PERFORMANCE_IDEA: we could skip the pick buffer completely by allocating\n  // a continuous range of pickIds and then converting the base pickId + batchId\n  // to RGBA in the shader.  The only consider is precision issues, which might\n  // not be an issue in WebGL 2.\n  var instances = collection._instances;\n  var instancesLength = instances.length;\n  var pickIds = new Array(instancesLength);\n  for (var i = 0; i < instancesLength; ++i) {\n    pickIds[i] = context.createPickId(instances[i]);\n  }\n  return pickIds;\n}\n\nfunction createModel(collection, context) {\n  var instancingSupported = collection._instancingSupported;\n  var usesBatchTable = defined(collection._batchTable);\n  var allowPicking = collection._allowPicking;\n\n  var modelOptions = {\n    url: collection._url,\n    requestType: collection._requestType,\n    gltf: collection._gltf,\n    basePath: collection._basePath,\n    shadows: collection._shadows,\n    cacheKey: undefined,\n    asynchronous: collection._asynchronous,\n    allowPicking: allowPicking,\n    incrementallyLoadTextures: collection._incrementallyLoadTextures,\n    upAxis: collection._upAxis,\n    forwardAxis: collection._forwardAxis,\n    precreatedAttributes: undefined,\n    vertexShaderLoaded: undefined,\n    fragmentShaderLoaded: undefined,\n    uniformMapLoaded: undefined,\n    pickIdLoaded: collection._pickIdLoaded,\n    ignoreCommands: true,\n    opaquePass: collection._opaquePass,\n    imageBasedLightingFactor: collection.imageBasedLightingFactor,\n    lightColor: collection.lightColor,\n    luminanceAtZenith: collection.luminanceAtZenith,\n    sphericalHarmonicCoefficients: collection.sphericalHarmonicCoefficients,\n    specularEnvironmentMaps: collection.specularEnvironmentMaps,\n  };\n\n  if (!usesBatchTable) {\n    collection._pickIds = createPickIds(collection, context);\n  }\n\n  if (instancingSupported) {\n    createVertexBuffer(collection, context);\n\n    var vertexSizeInFloats = 12;\n    var componentSizeInBytes = ComponentDatatype.getSizeInBytes(\n      ComponentDatatype.FLOAT\n    );\n\n    var instancedAttributes = {\n      czm_modelMatrixRow0: {\n        index: 0, // updated in Model\n        vertexBuffer: collection._vertexBuffer,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        normalize: false,\n        offsetInBytes: 0,\n        strideInBytes: componentSizeInBytes * vertexSizeInFloats,\n        instanceDivisor: 1,\n      },\n      czm_modelMatrixRow1: {\n        index: 0, // updated in Model\n        vertexBuffer: collection._vertexBuffer,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        normalize: false,\n        offsetInBytes: componentSizeInBytes * 4,\n        strideInBytes: componentSizeInBytes * vertexSizeInFloats,\n        instanceDivisor: 1,\n      },\n      czm_modelMatrixRow2: {\n        index: 0, // updated in Model\n        vertexBuffer: collection._vertexBuffer,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        normalize: false,\n        offsetInBytes: componentSizeInBytes * 8,\n        strideInBytes: componentSizeInBytes * vertexSizeInFloats,\n        instanceDivisor: 1,\n      },\n    };\n\n    // When using a batch table, add a batch id attribute\n    if (usesBatchTable) {\n      instancedAttributes.a_batchId = {\n        index: 0, // updated in Model\n        vertexBuffer: collection._batchIdBuffer,\n        componentsPerAttribute: 1,\n        componentDatatype: ComponentDatatype.UNSIGNED_SHORT,\n        normalize: false,\n        offsetInBytes: 0,\n        strideInBytes: 0,\n        instanceDivisor: 1,\n      };\n    }\n\n    if (!usesBatchTable) {\n      instancedAttributes.pickColor = {\n        index: 0, // updated in Model\n        vertexBuffer: collection._pickIdBuffer,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        normalize: true,\n        offsetInBytes: 0,\n        strideInBytes: 0,\n        instanceDivisor: 1,\n      };\n    }\n\n    modelOptions.precreatedAttributes = instancedAttributes;\n    modelOptions.vertexShaderLoaded = getVertexShaderCallback(collection);\n    modelOptions.fragmentShaderLoaded = getFragmentShaderCallback(collection);\n    modelOptions.uniformMapLoaded = getUniformMapCallback(collection, context);\n\n    if (defined(collection._url)) {\n      modelOptions.cacheKey = collection._url.getUrlComponent() + \"#instanced\";\n    }\n  } else {\n    modelOptions.vertexShaderLoaded = getVertexShaderNonInstancedCallback(\n      collection\n    );\n    modelOptions.fragmentShaderLoaded = getFragmentShaderNonInstancedCallback(\n      collection\n    );\n    modelOptions.uniformMapLoaded = getUniformMapNonInstancedCallback(\n      collection,\n      context\n    );\n  }\n\n  if (defined(collection._url)) {\n    collection._model = Model.fromGltf(modelOptions);\n  } else {\n    collection._model = new Model(modelOptions);\n  }\n}\n\nfunction updateWireframe(collection) {\n  if (collection._debugWireframe !== collection.debugWireframe) {\n    collection._debugWireframe = collection.debugWireframe;\n\n    // This assumes the original primitive was TRIANGLES and that the triangles\n    // are connected for the wireframe to look perfect.\n    var primitiveType = collection.debugWireframe\n      ? PrimitiveType.LINES\n      : PrimitiveType.TRIANGLES;\n    var commands = collection._drawCommands;\n    var length = commands.length;\n    for (var i = 0; i < length; ++i) {\n      commands[i].primitiveType = primitiveType;\n    }\n  }\n}\nfunction updateShowBoundingVolume(collection) {\n  if (\n    collection.debugShowBoundingVolume !== collection._debugShowBoundingVolume\n  ) {\n    collection._debugShowBoundingVolume = collection.debugShowBoundingVolume;\n\n    var commands = collection._drawCommands;\n    var length = commands.length;\n    for (var i = 0; i < length; ++i) {\n      commands[i].debugShowBoundingVolume = collection.debugShowBoundingVolume;\n    }\n  }\n}\n\nfunction createCommands(collection, drawCommands) {\n  var commandsLength = drawCommands.length;\n  var instancesLength = collection.length;\n  var boundingSphere = collection._boundingSphere;\n  var cull = collection._cull;\n\n  for (var i = 0; i < commandsLength; ++i) {\n    var drawCommand = DrawCommand.shallowClone(drawCommands[i]);\n    drawCommand.instanceCount = instancesLength;\n    drawCommand.boundingVolume = boundingSphere;\n    drawCommand.cull = cull;\n    if (defined(collection._batchTable)) {\n      drawCommand.pickId = collection._batchTable.getPickId();\n    } else {\n      drawCommand.pickId = \"v_pickColor\";\n    }\n    collection._drawCommands.push(drawCommand);\n  }\n}\n\nfunction createBatchIdFunction(batchId) {\n  return function () {\n    return batchId;\n  };\n}\n\nfunction createPickColorFunction(color) {\n  return function () {\n    return color;\n  };\n}\n\nfunction createCommandsNonInstanced(collection, drawCommands) {\n  // When instancing is disabled, create commands for every instance.\n  var instances = collection._instances;\n  var commandsLength = drawCommands.length;\n  var instancesLength = collection.length;\n  var batchTable = collection._batchTable;\n  var usesBatchTable = defined(batchTable);\n  var cull = collection._cull;\n\n  for (var i = 0; i < commandsLength; ++i) {\n    for (var j = 0; j < instancesLength; ++j) {\n      var drawCommand = DrawCommand.shallowClone(drawCommands[i]);\n      drawCommand.modelMatrix = new Matrix4(); // Updated in updateCommandsNonInstanced\n      drawCommand.boundingVolume = new BoundingSphere(); // Updated in updateCommandsNonInstanced\n      drawCommand.cull = cull;\n      drawCommand.uniformMap = clone(drawCommand.uniformMap);\n      if (usesBatchTable) {\n        drawCommand.uniformMap.a_batchId = createBatchIdFunction(\n          instances[j]._instanceId\n        );\n      } else {\n        var pickId = collection._pickIds[j];\n        drawCommand.uniformMap.czm_pickColor = createPickColorFunction(\n          pickId.color\n        );\n      }\n      collection._drawCommands.push(drawCommand);\n    }\n  }\n}\n\nfunction updateCommandsNonInstanced(collection) {\n  var modelCommands = collection._modelCommands;\n  var commandsLength = modelCommands.length;\n  var instancesLength = collection.length;\n  var collectionTransform = collection._rtcTransform;\n  var collectionCenter = collection._center;\n\n  for (var i = 0; i < commandsLength; ++i) {\n    var modelCommand = modelCommands[i];\n    for (var j = 0; j < instancesLength; ++j) {\n      var commandIndex = i * instancesLength + j;\n      var drawCommand = collection._drawCommands[commandIndex];\n      var instanceMatrix = Matrix4.clone(\n        collection._instances[j]._modelMatrix,\n        scratchMatrix\n      );\n      instanceMatrix[12] -= collectionCenter.x;\n      instanceMatrix[13] -= collectionCenter.y;\n      instanceMatrix[14] -= collectionCenter.z;\n      instanceMatrix = Matrix4.multiply(\n        collectionTransform,\n        instanceMatrix,\n        scratchMatrix\n      );\n      var nodeMatrix = modelCommand.modelMatrix;\n      var modelMatrix = drawCommand.modelMatrix;\n      Matrix4.multiply(instanceMatrix, nodeMatrix, modelMatrix);\n\n      var nodeBoundingSphere = modelCommand.boundingVolume;\n      var boundingSphere = drawCommand.boundingVolume;\n      BoundingSphere.transform(\n        nodeBoundingSphere,\n        instanceMatrix,\n        boundingSphere\n      );\n    }\n  }\n}\n\nfunction getModelCommands(model) {\n  var nodeCommands = model._nodeCommands;\n  var length = nodeCommands.length;\n\n  var drawCommands = [];\n\n  for (var i = 0; i < length; ++i) {\n    var nc = nodeCommands[i];\n    if (nc.show) {\n      drawCommands.push(nc.command);\n    }\n  }\n\n  return drawCommands;\n}\n\nfunction commandsDirty(model) {\n  var nodeCommands = model._nodeCommands;\n  var length = nodeCommands.length;\n\n  for (var i = 0; i < length; i++) {\n    var nc = nodeCommands[i];\n    if (nc.command.dirty) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction generateModelCommands(modelInstanceCollection, instancingSupported) {\n  modelInstanceCollection._drawCommands = [];\n\n  var modelCommands = getModelCommands(modelInstanceCollection._model);\n  if (instancingSupported) {\n    createCommands(modelInstanceCollection, modelCommands);\n  } else {\n    createCommandsNonInstanced(modelInstanceCollection, modelCommands);\n    updateCommandsNonInstanced(modelInstanceCollection);\n  }\n}\n\nfunction updateShadows(collection) {\n  if (collection.shadows !== collection._shadows) {\n    collection._shadows = collection.shadows;\n\n    var castShadows = ShadowMode.castShadows(collection.shadows);\n    var receiveShadows = ShadowMode.receiveShadows(collection.shadows);\n\n    var drawCommands = collection._drawCommands;\n    var length = drawCommands.length;\n    for (var i = 0; i < length; ++i) {\n      var drawCommand = drawCommands[i];\n      drawCommand.castShadows = castShadows;\n      drawCommand.receiveShadows = receiveShadows;\n    }\n  }\n}\n\nModelInstanceCollection.prototype.update = function (frameState) {\n  if (frameState.mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  if (!this.show) {\n    return;\n  }\n\n  if (this.length === 0) {\n    return;\n  }\n\n  var context = frameState.context;\n\n  if (this._state === LoadState.NEEDS_LOAD) {\n    this._state = LoadState.LOADING;\n    this._instancingSupported = context.instancedArrays;\n    createModel(this, context);\n    var that = this;\n    this._model.readyPromise.otherwise(function (error) {\n      that._state = LoadState.FAILED;\n      that._readyPromise.reject(error);\n    });\n  }\n\n  var instancingSupported = this._instancingSupported;\n  var model = this._model;\n\n  model.imageBasedLightingFactor = this.imageBasedLightingFactor;\n  model.lightColor = this.lightColor;\n  model.luminanceAtZenith = this.luminanceAtZenith;\n  model.sphericalHarmonicCoefficients = this.sphericalHarmonicCoefficients;\n  model.specularEnvironmentMaps = this.specularEnvironmentMaps;\n\n  model.update(frameState);\n\n  if (model.ready && this._state === LoadState.LOADING) {\n    this._state = LoadState.LOADED;\n    this._ready = true;\n\n    // Expand bounding volume to fit the radius of the loaded model including the model's offset from the center\n    var modelRadius =\n      model.boundingSphere.radius +\n      Cartesian3.magnitude(model.boundingSphere.center);\n    this._boundingSphere.radius += modelRadius;\n    this._modelCommands = getModelCommands(model);\n\n    generateModelCommands(this, instancingSupported);\n\n    this._readyPromise.resolve(this);\n    return;\n  }\n\n  if (this._state !== LoadState.LOADED) {\n    return;\n  }\n\n  var modeChanged = frameState.mode !== this._mode;\n  var modelMatrix = this.modelMatrix;\n  var modelMatrixChanged = !Matrix4.equals(this._modelMatrix, modelMatrix);\n\n  if (modeChanged || modelMatrixChanged) {\n    this._mode = frameState.mode;\n    Matrix4.clone(modelMatrix, this._modelMatrix);\n    var rtcTransform = Matrix4.multiplyByTranslation(\n      this._modelMatrix,\n      this._center,\n      this._rtcTransform\n    );\n    if (this._mode !== SceneMode.SCENE3D) {\n      rtcTransform = Transforms.basisTo2D(\n        frameState.mapProjection,\n        rtcTransform,\n        rtcTransform\n      );\n    }\n    Matrix4.getTranslation(rtcTransform, this._boundingSphere.center);\n  }\n\n  if (instancingSupported && this._dirty) {\n    // If at least one instance has moved assume the collection is now dynamic\n    this._dynamic = true;\n    this._dirty = false;\n\n    // PERFORMANCE_IDEA: only update dirty sub-sections instead of the whole collection\n    updateVertexBuffer(this);\n  }\n\n  // If the model was set to rebuild shaders during update, rebuild instanced commands.\n  if (commandsDirty(model)) {\n    generateModelCommands(this, instancingSupported);\n  }\n\n  // If any node changes due to an animation, update the commands. This could be inefficient if the model is\n  // composed of many nodes and only one changes, however it is probably fine in the general use case.\n  // Only applies when instancing is disabled. The instanced shader automatically handles node transformations.\n  if (\n    !instancingSupported &&\n    (model.dirty || this._dirty || modeChanged || modelMatrixChanged)\n  ) {\n    updateCommandsNonInstanced(this);\n  }\n\n  updateShadows(this);\n  updateWireframe(this);\n  updateShowBoundingVolume(this);\n\n  var passes = frameState.passes;\n  if (!passes.render && !passes.pick) {\n    return;\n  }\n\n  var commandList = frameState.commandList;\n  var commands = this._drawCommands;\n  var commandsLength = commands.length;\n\n  for (var i = 0; i < commandsLength; ++i) {\n    commandList.push(commands[i]);\n  }\n};\n\nModelInstanceCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\nModelInstanceCollection.prototype.destroy = function () {\n  this._model = this._model && this._model.destroy();\n\n  var pickIds = this._pickIds;\n  if (defined(pickIds)) {\n    var length = pickIds.length;\n    for (var i = 0; i < length; ++i) {\n      pickIds[i].destroy();\n    }\n  }\n\n  return destroyObject(this);\n};\nexport default ModelInstanceCollection;\n"]},"metadata":{},"sourceType":"module"}