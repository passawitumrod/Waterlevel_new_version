{"ast":null,"code":"import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Spline from \"./Spline.js\";\n/**\n * A spline that linearly interpolates over an array of weight values used by morph targets.\n *\n * @alias WeightSpline\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {Number[]} options.weights The array of floating-point control weights given. The weights are ordered such\n *                that all weights for the targets are given in chronological order and order in which they appear in\n *                the glTF from which the morph targets come. This means for 2 targets, weights = [w(0,0), w(0,1), w(1,0), w(1,1) ...]\n *                where i and j in w(i,j) are the time indices and target indices, respectively.\n *\n * @exception {DeveloperError} weights.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be a factor of weights.length.\n *\n *\n * @example\n * var times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * var weights = [0.0, 1.0, 0.25, 0.75, 0.5, 0.5, 0.75, 0.25, 1.0, 0.0]; //Two targets\n * var spline = new Cesium.WeightSpline({\n *     times : times,\n *     weights : weights\n * });\n *\n * var p0 = spline.evaluate(times[0]);\n *\n * @see LinearSpline\n * @see HermiteSpline\n * @see CatmullRomSpline\n * @see QuaternionSpline\n */\n\nfunction WeightSpline(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var weights = options.weights;\n  var times = options.times; //>>includeStart('debug', pragmas.debug);\n\n  Check.defined(\"weights\", weights);\n  Check.defined(\"times\", times);\n  Check.typeOf.number.greaterThanOrEquals(\"weights.length\", weights.length, 3);\n\n  if (weights.length % times.length !== 0) {\n    throw new DeveloperError(\"times.length must be a factor of weights.length.\");\n  } //>>includeEnd('debug');\n\n\n  this._times = times;\n  this._weights = weights;\n  this._count = weights.length / times.length;\n  this._lastTimeIndex = 0;\n}\n\nObject.defineProperties(WeightSpline.prototype, {\n  /**\n   * An array of times for the control weights.\n   *\n   * @memberof WeightSpline.prototype\n   *\n   * @type {Number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    }\n  },\n\n  /**\n   * An array of floating-point array control weights.\n   *\n   * @memberof WeightSpline.prototype\n   *\n   * @type {Number[]}\n   * @readonly\n   */\n  weights: {\n    get: function () {\n      return this._weights;\n    }\n  }\n});\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {Number} time The time.\n * @returns {Number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\n\nWeightSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, wrapped around to the updated animation.\n */\n\nWeightSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, clamped to the animation period.\n */\n\nWeightSpline.prototype.clampTime = Spline.prototype.clampTime;\n/**\n * Evaluates the curve at a given time.\n *\n * @param {Number} time The time at which to evaluate the curve.\n * @param {Number[]} [result] The object onto which to store the result.\n * @returns {Number[]} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\n\nWeightSpline.prototype.evaluate = function (time, result) {\n  var weights = this.weights;\n  var times = this.times;\n  var i = this._lastTimeIndex = this.findTimeInterval(time, this._lastTimeIndex);\n  var u = (time - times[i]) / (times[i + 1] - times[i]);\n\n  if (!defined(result)) {\n    result = new Array(this._count);\n  }\n\n  for (var j = 0; j < this._count; j++) {\n    var index = i * this._count + j;\n    result[j] = weights[index] * (1.0 - u) + weights[index + this._count] * u;\n  }\n\n  return result;\n};\n\nexport default WeightSpline;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/WeightSpline.js"],"names":["Check","defaultValue","defined","DeveloperError","Spline","WeightSpline","options","EMPTY_OBJECT","weights","times","typeOf","number","greaterThanOrEquals","length","_times","_weights","_count","_lastTimeIndex","Object","defineProperties","prototype","get","findTimeInterval","wrapTime","clampTime","evaluate","time","result","i","u","Array","j","index"],"mappings":"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","sourcesContent":["import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Spline from \"./Spline.js\";\n\n/**\n * A spline that linearly interpolates over an array of weight values used by morph targets.\n *\n * @alias WeightSpline\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {Number[]} options.weights The array of floating-point control weights given. The weights are ordered such\n *                that all weights for the targets are given in chronological order and order in which they appear in\n *                the glTF from which the morph targets come. This means for 2 targets, weights = [w(0,0), w(0,1), w(1,0), w(1,1) ...]\n *                where i and j in w(i,j) are the time indices and target indices, respectively.\n *\n * @exception {DeveloperError} weights.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be a factor of weights.length.\n *\n *\n * @example\n * var times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * var weights = [0.0, 1.0, 0.25, 0.75, 0.5, 0.5, 0.75, 0.25, 1.0, 0.0]; //Two targets\n * var spline = new Cesium.WeightSpline({\n *     times : times,\n *     weights : weights\n * });\n *\n * var p0 = spline.evaluate(times[0]);\n *\n * @see LinearSpline\n * @see HermiteSpline\n * @see CatmullRomSpline\n * @see QuaternionSpline\n */\nfunction WeightSpline(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var weights = options.weights;\n  var times = options.times;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"weights\", weights);\n  Check.defined(\"times\", times);\n  Check.typeOf.number.greaterThanOrEquals(\"weights.length\", weights.length, 3);\n  if (weights.length % times.length !== 0) {\n    throw new DeveloperError(\n      \"times.length must be a factor of weights.length.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._times = times;\n  this._weights = weights;\n  this._count = weights.length / times.length;\n\n  this._lastTimeIndex = 0;\n}\n\nObject.defineProperties(WeightSpline.prototype, {\n  /**\n   * An array of times for the control weights.\n   *\n   * @memberof WeightSpline.prototype\n   *\n   * @type {Number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    },\n  },\n\n  /**\n   * An array of floating-point array control weights.\n   *\n   * @memberof WeightSpline.prototype\n   *\n   * @type {Number[]}\n   * @readonly\n   */\n  weights: {\n    get: function () {\n      return this._weights;\n    },\n  },\n});\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {Number} time The time.\n * @returns {Number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nWeightSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, wrapped around to the updated animation.\n */\nWeightSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, clamped to the animation period.\n */\nWeightSpline.prototype.clampTime = Spline.prototype.clampTime;\n\n/**\n * Evaluates the curve at a given time.\n *\n * @param {Number} time The time at which to evaluate the curve.\n * @param {Number[]} [result] The object onto which to store the result.\n * @returns {Number[]} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nWeightSpline.prototype.evaluate = function (time, result) {\n  var weights = this.weights;\n  var times = this.times;\n\n  var i = (this._lastTimeIndex = this.findTimeInterval(\n    time,\n    this._lastTimeIndex\n  ));\n  var u = (time - times[i]) / (times[i + 1] - times[i]);\n\n  if (!defined(result)) {\n    result = new Array(this._count);\n  }\n\n  for (var j = 0; j < this._count; j++) {\n    var index = i * this._count + j;\n    result[j] = weights[index] * (1.0 - u) + weights[index + this._count] * u;\n  }\n\n  return result;\n};\nexport default WeightSpline;\n"]},"metadata":{},"sourceType":"module"}