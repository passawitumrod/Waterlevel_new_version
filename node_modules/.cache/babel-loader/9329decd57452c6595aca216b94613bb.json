{"ast":null,"code":"import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport writeTextToCanvas from \"../Core/writeTextToCanvas.js\";\nimport bitmapSDF from \"../ThirdParty/bitmap-sdf.js\";\nimport BillboardCollection from \"./BillboardCollection.js\";\nimport BlendOption from \"./BlendOption.js\";\nimport HeightReference from \"./HeightReference.js\";\nimport HorizontalOrigin from \"./HorizontalOrigin.js\";\nimport Label from \"./Label.js\";\nimport LabelStyle from \"./LabelStyle.js\";\nimport SDFSettings from \"./SDFSettings.js\";\nimport TextureAtlas from \"./TextureAtlas.js\";\nimport VerticalOrigin from \"./VerticalOrigin.js\";\nimport GraphemeSplitter from \"../ThirdParty/graphemesplitter.js\"; // A glyph represents a single character in a particular label.  It may or may\n// not have a billboard, depending on whether the texture info has an index into\n// the the label collection's texture atlas.  Invisible characters have no texture, and\n// no billboard.  However, it always has a valid dimensions object.\n\nfunction Glyph() {\n  this.textureInfo = undefined;\n  this.dimensions = undefined;\n  this.billboard = undefined;\n} // GlyphTextureInfo represents a single character, drawn in a particular style,\n// shared and reference counted across all labels.  It may or may not have an\n// index into the label collection's texture atlas, depending on whether the character\n// has both width and height, but it always has a valid dimensions object.\n\n\nfunction GlyphTextureInfo(labelCollection, index, dimensions) {\n  this.labelCollection = labelCollection;\n  this.index = index;\n  this.dimensions = dimensions;\n} // Traditionally, leading is %20 of the font size.\n\n\nvar defaultLineSpacingPercent = 1.2;\nvar whitePixelCanvasId = \"ID_WHITE_PIXEL\";\nvar whitePixelSize = new Cartesian2(4, 4);\nvar whitePixelBoundingRegion = new BoundingRectangle(1, 1, 1, 1);\n\nfunction addWhitePixelCanvas(textureAtlas, labelCollection) {\n  var canvas = document.createElement(\"canvas\");\n  canvas.width = whitePixelSize.x;\n  canvas.height = whitePixelSize.y;\n  var context2D = canvas.getContext(\"2d\");\n  context2D.fillStyle = \"#fff\";\n  context2D.fillRect(0, 0, canvas.width, canvas.height);\n  textureAtlas.addImage(whitePixelCanvasId, canvas).then(function (index) {\n    labelCollection._whitePixelIndex = index;\n  });\n} // reusable object for calling writeTextToCanvas\n\n\nvar writeTextToCanvasParameters = {};\n\nfunction createGlyphCanvas(character, font, fillColor, outlineColor, outlineWidth, style, verticalOrigin) {\n  writeTextToCanvasParameters.font = font;\n  writeTextToCanvasParameters.fillColor = fillColor;\n  writeTextToCanvasParameters.strokeColor = outlineColor;\n  writeTextToCanvasParameters.strokeWidth = outlineWidth; // Setting the padding to something bigger is necessary to get enough space for the outlining.\n\n  writeTextToCanvasParameters.padding = SDFSettings.PADDING;\n\n  if (verticalOrigin === VerticalOrigin.CENTER) {\n    writeTextToCanvasParameters.textBaseline = \"middle\";\n  } else if (verticalOrigin === VerticalOrigin.TOP) {\n    writeTextToCanvasParameters.textBaseline = \"top\";\n  } else {\n    // VerticalOrigin.BOTTOM and VerticalOrigin.BASELINE\n    writeTextToCanvasParameters.textBaseline = \"bottom\";\n  }\n\n  writeTextToCanvasParameters.fill = style === LabelStyle.FILL || style === LabelStyle.FILL_AND_OUTLINE;\n  writeTextToCanvasParameters.stroke = style === LabelStyle.OUTLINE || style === LabelStyle.FILL_AND_OUTLINE;\n  writeTextToCanvasParameters.backgroundColor = Color.BLACK;\n  return writeTextToCanvas(character, writeTextToCanvasParameters);\n}\n\nfunction unbindGlyph(labelCollection, glyph) {\n  glyph.textureInfo = undefined;\n  glyph.dimensions = undefined;\n  var billboard = glyph.billboard;\n\n  if (defined(billboard)) {\n    billboard.show = false;\n    billboard.image = undefined;\n\n    if (defined(billboard._removeCallbackFunc)) {\n      billboard._removeCallbackFunc();\n\n      billboard._removeCallbackFunc = undefined;\n    }\n\n    labelCollection._spareBillboards.push(billboard);\n\n    glyph.billboard = undefined;\n  }\n}\n\nfunction addGlyphToTextureAtlas(textureAtlas, id, canvas, glyphTextureInfo) {\n  textureAtlas.addImage(id, canvas).then(function (index) {\n    glyphTextureInfo.index = index;\n  });\n}\n\nvar splitter = new GraphemeSplitter();\n\nfunction rebindAllGlyphs(labelCollection, label) {\n  var text = label._renderedText;\n  var graphemes = splitter.splitGraphemes(text);\n  var textLength = graphemes.length;\n  var glyphs = label._glyphs;\n  var glyphsLength = glyphs.length;\n  var glyph;\n  var glyphIndex;\n  var textIndex; // Compute a font size scale relative to the sdf font generated size.\n\n  label._relativeSize = label._fontSize / SDFSettings.FONT_SIZE; // if we have more glyphs than needed, unbind the extras.\n\n  if (textLength < glyphsLength) {\n    for (glyphIndex = textLength; glyphIndex < glyphsLength; ++glyphIndex) {\n      unbindGlyph(labelCollection, glyphs[glyphIndex]);\n    }\n  } // presize glyphs to match the new text length\n\n\n  glyphs.length = textLength;\n  var showBackground = label._showBackground && text.split(\"\\n\").join(\"\").length > 0;\n  var backgroundBillboard = label._backgroundBillboard;\n  var backgroundBillboardCollection = labelCollection._backgroundBillboardCollection;\n\n  if (!showBackground) {\n    if (defined(backgroundBillboard)) {\n      backgroundBillboardCollection.remove(backgroundBillboard);\n      label._backgroundBillboard = backgroundBillboard = undefined;\n    }\n  } else {\n    if (!defined(backgroundBillboard)) {\n      backgroundBillboard = backgroundBillboardCollection.add({\n        collection: labelCollection,\n        image: whitePixelCanvasId,\n        imageSubRegion: whitePixelBoundingRegion\n      });\n      label._backgroundBillboard = backgroundBillboard;\n    }\n\n    backgroundBillboard.color = label._backgroundColor;\n    backgroundBillboard.show = label._show;\n    backgroundBillboard.position = label._position;\n    backgroundBillboard.eyeOffset = label._eyeOffset;\n    backgroundBillboard.pixelOffset = label._pixelOffset;\n    backgroundBillboard.horizontalOrigin = HorizontalOrigin.LEFT;\n    backgroundBillboard.verticalOrigin = label._verticalOrigin;\n    backgroundBillboard.heightReference = label._heightReference;\n    backgroundBillboard.scale = label.totalScale;\n    backgroundBillboard.pickPrimitive = label;\n    backgroundBillboard.id = label._id;\n    backgroundBillboard.translucencyByDistance = label._translucencyByDistance;\n    backgroundBillboard.pixelOffsetScaleByDistance = label._pixelOffsetScaleByDistance;\n    backgroundBillboard.scaleByDistance = label._scaleByDistance;\n    backgroundBillboard.distanceDisplayCondition = label._distanceDisplayCondition;\n    backgroundBillboard.disableDepthTestDistance = label._disableDepthTestDistance;\n  }\n\n  var glyphTextureCache = labelCollection._glyphTextureCache; // walk the text looking for new characters (creating new glyphs for each)\n  // or changed characters (rebinding existing glyphs)\n\n  for (textIndex = 0; textIndex < textLength; ++textIndex) {\n    var character = graphemes[textIndex];\n    var verticalOrigin = label._verticalOrigin;\n    var id = JSON.stringify([character, label._fontFamily, label._fontStyle, label._fontWeight, +verticalOrigin]);\n    var glyphTextureInfo = glyphTextureCache[id];\n\n    if (!defined(glyphTextureInfo)) {\n      var glyphFont = label._fontStyle + \" \" + label._fontWeight + \" \" + SDFSettings.FONT_SIZE + \"px \" + label._fontFamily;\n      var canvas = createGlyphCanvas(character, glyphFont, Color.WHITE, Color.WHITE, 0.0, LabelStyle.FILL, verticalOrigin);\n      glyphTextureInfo = new GlyphTextureInfo(labelCollection, -1, canvas.dimensions);\n      glyphTextureCache[id] = glyphTextureInfo;\n\n      if (canvas.width > 0 && canvas.height > 0) {\n        var sdfValues = bitmapSDF(canvas, {\n          cutoff: SDFSettings.CUTOFF,\n          radius: SDFSettings.RADIUS\n        });\n        var ctx = canvas.getContext(\"2d\");\n        var canvasWidth = canvas.width;\n        var canvasHeight = canvas.height;\n        var imgData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);\n\n        for (var i = 0; i < canvasWidth; i++) {\n          for (var j = 0; j < canvasHeight; j++) {\n            var baseIndex = j * canvasWidth + i;\n            var alpha = sdfValues[baseIndex] * 255;\n            var imageIndex = baseIndex * 4;\n            imgData.data[imageIndex + 0] = alpha;\n            imgData.data[imageIndex + 1] = alpha;\n            imgData.data[imageIndex + 2] = alpha;\n            imgData.data[imageIndex + 3] = alpha;\n          }\n        }\n\n        ctx.putImageData(imgData, 0, 0);\n\n        if (character !== \" \") {\n          addGlyphToTextureAtlas(labelCollection._textureAtlas, id, canvas, glyphTextureInfo);\n        }\n      }\n    }\n\n    glyph = glyphs[textIndex];\n\n    if (defined(glyph)) {\n      // clean up leftover information from the previous glyph\n      if (glyphTextureInfo.index === -1) {\n        // no texture, and therefore no billboard, for this glyph.\n        // so, completely unbind glyph.\n        unbindGlyph(labelCollection, glyph);\n      } else if (defined(glyph.textureInfo)) {\n        // we have a texture and billboard.  If we had one before, release\n        // our reference to that texture info, but reuse the billboard.\n        glyph.textureInfo = undefined;\n      }\n    } else {\n      // create a glyph object\n      glyph = new Glyph();\n      glyphs[textIndex] = glyph;\n    }\n\n    glyph.textureInfo = glyphTextureInfo;\n    glyph.dimensions = glyphTextureInfo.dimensions; // if we have a texture, configure the existing billboard, or obtain one\n\n    if (glyphTextureInfo.index !== -1) {\n      var billboard = glyph.billboard;\n      var spareBillboards = labelCollection._spareBillboards;\n\n      if (!defined(billboard)) {\n        if (spareBillboards.length > 0) {\n          billboard = spareBillboards.pop();\n        } else {\n          billboard = labelCollection._billboardCollection.add({\n            collection: labelCollection\n          });\n          billboard._labelDimensions = new Cartesian2();\n          billboard._labelTranslate = new Cartesian2();\n        }\n\n        glyph.billboard = billboard;\n      }\n\n      billboard.show = label._show;\n      billboard.position = label._position;\n      billboard.eyeOffset = label._eyeOffset;\n      billboard.pixelOffset = label._pixelOffset;\n      billboard.horizontalOrigin = HorizontalOrigin.LEFT;\n      billboard.verticalOrigin = label._verticalOrigin;\n      billboard.heightReference = label._heightReference;\n      billboard.scale = label.totalScale;\n      billboard.pickPrimitive = label;\n      billboard.id = label._id;\n      billboard.image = id;\n      billboard.translucencyByDistance = label._translucencyByDistance;\n      billboard.pixelOffsetScaleByDistance = label._pixelOffsetScaleByDistance;\n      billboard.scaleByDistance = label._scaleByDistance;\n      billboard.distanceDisplayCondition = label._distanceDisplayCondition;\n      billboard.disableDepthTestDistance = label._disableDepthTestDistance;\n      billboard._batchIndex = label._batchIndex;\n      billboard.outlineColor = label.outlineColor;\n\n      if (label.style === LabelStyle.FILL_AND_OUTLINE) {\n        billboard.color = label._fillColor;\n        billboard.outlineWidth = label.outlineWidth;\n      } else if (label.style === LabelStyle.FILL) {\n        billboard.color = label._fillColor;\n        billboard.outlineWidth = 0.0;\n      } else if (label.style === LabelStyle.OUTLINE) {\n        billboard.color = Color.TRANSPARENT;\n        billboard.outlineWidth = label.outlineWidth;\n      }\n    }\n  } // changing glyphs will cause the position of the\n  // glyphs to change, since different characters have different widths\n\n\n  label._repositionAllGlyphs = true;\n}\n\nfunction calculateWidthOffset(lineWidth, horizontalOrigin, backgroundPadding) {\n  if (horizontalOrigin === HorizontalOrigin.CENTER) {\n    return -lineWidth / 2;\n  } else if (horizontalOrigin === HorizontalOrigin.RIGHT) {\n    return -(lineWidth + backgroundPadding.x);\n  }\n\n  return backgroundPadding.x;\n} // reusable Cartesian2 instances\n\n\nvar glyphPixelOffset = new Cartesian2();\nvar scratchBackgroundPadding = new Cartesian2();\n\nfunction repositionAllGlyphs(label) {\n  var glyphs = label._glyphs;\n  var text = label._renderedText;\n  var glyph;\n  var dimensions;\n  var lastLineWidth = 0;\n  var maxLineWidth = 0;\n  var lineWidths = [];\n  var maxGlyphDescent = Number.NEGATIVE_INFINITY;\n  var maxGlyphY = 0;\n  var numberOfLines = 1;\n  var glyphIndex;\n  var glyphLength = glyphs.length;\n  var backgroundBillboard = label._backgroundBillboard;\n  var backgroundPadding = Cartesian2.clone(defined(backgroundBillboard) ? label._backgroundPadding : Cartesian2.ZERO, scratchBackgroundPadding); // We need to scale the background padding, which is specified in pixels by the inverse of the relative size so it is scaled properly.\n\n  backgroundPadding.x /= label._relativeSize;\n  backgroundPadding.y /= label._relativeSize;\n\n  for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {\n    if (text.charAt(glyphIndex) === \"\\n\") {\n      lineWidths.push(lastLineWidth);\n      ++numberOfLines;\n      lastLineWidth = 0;\n    } else {\n      glyph = glyphs[glyphIndex];\n      dimensions = glyph.dimensions;\n      maxGlyphY = Math.max(maxGlyphY, dimensions.height - dimensions.descent);\n      maxGlyphDescent = Math.max(maxGlyphDescent, dimensions.descent); //Computing the line width must also account for the kerning that occurs between letters.\n\n      lastLineWidth += dimensions.width - dimensions.bounds.minx;\n\n      if (glyphIndex < glyphLength - 1) {\n        lastLineWidth += glyphs[glyphIndex + 1].dimensions.bounds.minx;\n      }\n\n      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n    }\n  }\n\n  lineWidths.push(lastLineWidth);\n  var maxLineHeight = maxGlyphY + maxGlyphDescent;\n  var scale = label.totalScale;\n  var horizontalOrigin = label._horizontalOrigin;\n  var verticalOrigin = label._verticalOrigin;\n  var lineIndex = 0;\n  var lineWidth = lineWidths[lineIndex];\n  var widthOffset = calculateWidthOffset(lineWidth, horizontalOrigin, backgroundPadding);\n  var lineSpacing = defaultLineSpacingPercent * maxLineHeight;\n  var otherLinesHeight = lineSpacing * (numberOfLines - 1);\n  var totalLineWidth = maxLineWidth;\n  var totalLineHeight = maxLineHeight + otherLinesHeight;\n\n  if (defined(backgroundBillboard)) {\n    totalLineWidth += backgroundPadding.x * 2;\n    totalLineHeight += backgroundPadding.y * 2;\n    backgroundBillboard._labelHorizontalOrigin = horizontalOrigin;\n  }\n\n  glyphPixelOffset.x = widthOffset * scale;\n  glyphPixelOffset.y = 0;\n  var firstCharOfLine = true;\n  var lineOffsetY = 0;\n\n  for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {\n    if (text.charAt(glyphIndex) === \"\\n\") {\n      ++lineIndex;\n      lineOffsetY += lineSpacing;\n      lineWidth = lineWidths[lineIndex];\n      widthOffset = calculateWidthOffset(lineWidth, horizontalOrigin, backgroundPadding);\n      glyphPixelOffset.x = widthOffset * scale;\n      firstCharOfLine = true;\n    } else {\n      glyph = glyphs[glyphIndex];\n      dimensions = glyph.dimensions;\n\n      if (verticalOrigin === VerticalOrigin.TOP) {\n        glyphPixelOffset.y = dimensions.height - maxGlyphY - backgroundPadding.y;\n        glyphPixelOffset.y += SDFSettings.PADDING;\n      } else if (verticalOrigin === VerticalOrigin.CENTER) {\n        glyphPixelOffset.y = (otherLinesHeight + dimensions.height - maxGlyphY) / 2;\n      } else if (verticalOrigin === VerticalOrigin.BASELINE) {\n        glyphPixelOffset.y = otherLinesHeight;\n        glyphPixelOffset.y -= SDFSettings.PADDING;\n      } else {\n        // VerticalOrigin.BOTTOM\n        glyphPixelOffset.y = otherLinesHeight + maxGlyphDescent + backgroundPadding.y;\n        glyphPixelOffset.y -= SDFSettings.PADDING;\n      }\n\n      glyphPixelOffset.y = (glyphPixelOffset.y - dimensions.descent - lineOffsetY) * scale; // Handle any offsets for the first character of the line since the bounds might not be right on the bottom left pixel.\n\n      if (firstCharOfLine) {\n        glyphPixelOffset.x -= SDFSettings.PADDING * scale;\n        firstCharOfLine = false;\n      }\n\n      if (defined(glyph.billboard)) {\n        glyph.billboard._setTranslate(glyphPixelOffset);\n\n        glyph.billboard._labelDimensions.x = totalLineWidth;\n        glyph.billboard._labelDimensions.y = totalLineHeight;\n        glyph.billboard._labelHorizontalOrigin = horizontalOrigin;\n      } //Compute the next x offset taking into account the kerning performed\n      //on both the current letter as well as the next letter to be drawn\n      //as well as any applied scale.\n\n\n      if (glyphIndex < glyphLength - 1) {\n        var nextGlyph = glyphs[glyphIndex + 1];\n        glyphPixelOffset.x += (dimensions.width - dimensions.bounds.minx + nextGlyph.dimensions.bounds.minx) * scale;\n      }\n    }\n  }\n\n  if (defined(backgroundBillboard) && text.split(\"\\n\").join(\"\").length > 0) {\n    if (horizontalOrigin === HorizontalOrigin.CENTER) {\n      widthOffset = -maxLineWidth / 2 - backgroundPadding.x;\n    } else if (horizontalOrigin === HorizontalOrigin.RIGHT) {\n      widthOffset = -(maxLineWidth + backgroundPadding.x * 2);\n    } else {\n      widthOffset = 0;\n    }\n\n    glyphPixelOffset.x = widthOffset * scale;\n\n    if (verticalOrigin === VerticalOrigin.TOP) {\n      glyphPixelOffset.y = maxLineHeight - maxGlyphY - maxGlyphDescent;\n    } else if (verticalOrigin === VerticalOrigin.CENTER) {\n      glyphPixelOffset.y = (maxLineHeight - maxGlyphY) / 2 - maxGlyphDescent;\n    } else if (verticalOrigin === VerticalOrigin.BASELINE) {\n      glyphPixelOffset.y = -backgroundPadding.y - maxGlyphDescent;\n    } else {\n      // VerticalOrigin.BOTTOM\n      glyphPixelOffset.y = 0;\n    }\n\n    glyphPixelOffset.y = glyphPixelOffset.y * scale;\n    backgroundBillboard.width = totalLineWidth;\n    backgroundBillboard.height = totalLineHeight;\n\n    backgroundBillboard._setTranslate(glyphPixelOffset);\n\n    backgroundBillboard._labelTranslate = Cartesian2.clone(glyphPixelOffset, backgroundBillboard._labelTranslate);\n  }\n\n  if (label.heightReference === HeightReference.CLAMP_TO_GROUND) {\n    for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {\n      glyph = glyphs[glyphIndex];\n      var billboard = glyph.billboard;\n\n      if (defined(billboard)) {\n        billboard._labelTranslate = Cartesian2.clone(glyphPixelOffset, billboard._labelTranslate);\n      }\n    }\n  }\n}\n\nfunction destroyLabel(labelCollection, label) {\n  var glyphs = label._glyphs;\n\n  for (var i = 0, len = glyphs.length; i < len; ++i) {\n    unbindGlyph(labelCollection, glyphs[i]);\n  }\n\n  if (defined(label._backgroundBillboard)) {\n    labelCollection._backgroundBillboardCollection.remove(label._backgroundBillboard);\n\n    label._backgroundBillboard = undefined;\n  }\n\n  label._labelCollection = undefined;\n\n  if (defined(label._removeCallbackFunc)) {\n    label._removeCallbackFunc();\n  }\n\n  destroyObject(label);\n}\n/**\n * A renderable collection of labels.  Labels are viewport-aligned text positioned in the 3D scene.\n * Each label can have a different font, color, scale, etc.\n * <br /><br />\n * <div align='center'>\n * <img src='Images/Label.png' width='400' height='300' /><br />\n * Example labels\n * </div>\n * <br /><br />\n * Labels are added and removed from the collection using {@link LabelCollection#add}\n * and {@link LabelCollection#remove}.\n *\n * @alias LabelCollection\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each label from model to world coordinates.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {Scene} [options.scene] Must be passed in for labels that use the height reference property or will be depth tested against the globe.\n * @param {BlendOption} [options.blendOption=BlendOption.OPAQUE_AND_TRANSLUCENT] The label blending option. The default\n * is used for rendering both opaque and translucent labels. However, if either all of the labels are completely opaque or all are completely translucent,\n * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve performance by up to 2x.\n *\n * @performance For best performance, prefer a few collections, each with many labels, to\n * many collections with only a few labels each.  Avoid having collections where some\n * labels change every frame and others do not; instead, create one or more collections\n * for static labels, and one or more collections for dynamic labels.\n *\n * @see LabelCollection#add\n * @see LabelCollection#remove\n * @see Label\n * @see BillboardCollection\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Labels.html|Cesium Sandcastle Labels Demo}\n *\n * @example\n * // Create a label collection with two labels\n * var labels = scene.primitives.add(new Cesium.LabelCollection());\n * labels.add({\n *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),\n *   text : 'A label'\n * });\n * labels.add({\n *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),\n *   text : 'Another label'\n * });\n */\n\n\nfunction LabelCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  this._scene = options.scene;\n  this._batchTable = options.batchTable;\n  this._textureAtlas = undefined;\n  this._backgroundTextureAtlas = undefined;\n  this._whitePixelIndex = undefined;\n  this._backgroundBillboardCollection = new BillboardCollection({\n    scene: this._scene\n  });\n  this._backgroundBillboardCollection.destroyTextureAtlas = false;\n  this._billboardCollection = new BillboardCollection({\n    scene: this._scene,\n    batchTable: this._batchTable\n  });\n  this._billboardCollection.destroyTextureAtlas = false;\n  this._billboardCollection._sdf = true;\n  this._spareBillboards = [];\n  this._glyphTextureCache = {};\n  this._labels = [];\n  this._labelsToUpdate = [];\n  this._totalGlyphCount = 0;\n  this._highlightColor = Color.clone(Color.WHITE); // Only used by Vector3DTilePoints\n\n  /**\n   * The 4x4 transformation matrix that transforms each label in this collection from model to world coordinates.\n   * When this is the identity matrix, the labels are drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type Matrix4\n   * @default {@link Matrix4.IDENTITY}\n   *\n   * @example\n   * var center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n   * labels.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0),\n   *   text     : 'Center'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0),\n   *   text     : 'East'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0),\n   *   text     : 'North'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0),\n   *   text     : 'Up'\n   * });\n   */\n\n  this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n\n  this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);\n  /**\n   * The label blending option. The default is used for rendering both opaque and translucent labels.\n   * However, if either all of the labels are completely opaque or all are completely translucent,\n   * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve\n   * performance by up to 2x.\n   * @type {BlendOption}\n   * @default BlendOption.OPAQUE_AND_TRANSLUCENT\n   */\n\n  this.blendOption = defaultValue(options.blendOption, BlendOption.OPAQUE_AND_TRANSLUCENT);\n}\n\nObject.defineProperties(LabelCollection.prototype, {\n  /**\n   * Returns the number of labels in this collection.  This is commonly used with\n   * {@link LabelCollection#get} to iterate over all the labels\n   * in the collection.\n   * @memberof LabelCollection.prototype\n   * @type {Number}\n   */\n  length: {\n    get: function () {\n      return this._labels.length;\n    }\n  }\n});\n/**\n * Creates and adds a label with the specified initial properties to the collection.\n * The added label is returned so it can be modified or removed from the collection later.\n *\n * @param {Object} [options] A template describing the label's properties as shown in Example 1.\n * @returns {Label} The label that was added to the collection.\n *\n * @performance Calling <code>add</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten; this operations is <code>O(n)</code> and also incurs\n * CPU to GPU overhead.  For best performance, add as many billboards as possible before\n * calling <code>update</code>.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Example 1:  Add a label, specifying all the default values.\n * var l = labels.add({\n *   show : true,\n *   position : Cesium.Cartesian3.ZERO,\n *   text : '',\n *   font : '30px sans-serif',\n *   fillColor : Cesium.Color.WHITE,\n *   outlineColor : Cesium.Color.BLACK,\n *   outlineWidth : 1.0,\n *   showBackground : false,\n *   backgroundColor : new Cesium.Color(0.165, 0.165, 0.165, 0.8),\n *   backgroundPadding : new Cesium.Cartesian2(7, 5),\n *   style : Cesium.LabelStyle.FILL,\n *   pixelOffset : Cesium.Cartesian2.ZERO,\n *   eyeOffset : Cesium.Cartesian3.ZERO,\n *   horizontalOrigin : Cesium.HorizontalOrigin.LEFT,\n *   verticalOrigin : Cesium.VerticalOrigin.BASELINE,\n *   scale : 1.0,\n *   translucencyByDistance : undefined,\n *   pixelOffsetScaleByDistance : undefined,\n *   heightReference : HeightReference.NONE,\n *   distanceDisplayCondition : undefined\n * });\n *\n * @example\n * // Example 2:  Specify only the label's cartographic position,\n * // text, and font.\n * var l = labels.add({\n *   position : Cesium.Cartesian3.fromRadians(longitude, latitude, height),\n *   text : 'Hello World',\n *   font : '24px Helvetica',\n * });\n *\n * @see LabelCollection#remove\n * @see LabelCollection#removeAll\n */\n\nLabelCollection.prototype.add = function (options) {\n  var label = new Label(options, this);\n\n  this._labels.push(label);\n\n  this._labelsToUpdate.push(label);\n\n  return label;\n};\n/**\n * Removes a label from the collection.  Once removed, a label is no longer usable.\n *\n * @param {Label} label The label to remove.\n * @returns {Boolean} <code>true</code> if the label was removed; <code>false</code> if the label was not found in the collection.\n *\n * @performance Calling <code>remove</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, remove as many labels as possible before calling <code>update</code>.\n * If you intend to temporarily hide a label, it is usually more efficient to call\n * {@link Label#show} instead of removing and re-adding the label.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * var l = labels.add(...);\n * labels.remove(l);  // Returns true\n *\n * @see LabelCollection#add\n * @see LabelCollection#removeAll\n * @see Label#show\n */\n\n\nLabelCollection.prototype.remove = function (label) {\n  if (defined(label) && label._labelCollection === this) {\n    var index = this._labels.indexOf(label);\n\n    if (index !== -1) {\n      this._labels.splice(index, 1);\n\n      destroyLabel(this, label);\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Removes all labels from the collection.\n *\n * @performance <code>O(n)</code>.  It is more efficient to remove all the labels\n * from a collection and then add new ones than to create a new collection entirely.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * labels.add(...);\n * labels.add(...);\n * labels.removeAll();\n *\n * @see LabelCollection#add\n * @see LabelCollection#remove\n */\n\n\nLabelCollection.prototype.removeAll = function () {\n  var labels = this._labels;\n\n  for (var i = 0, len = labels.length; i < len; ++i) {\n    destroyLabel(this, labels[i]);\n  }\n\n  labels.length = 0;\n};\n/**\n * Check whether this collection contains a given label.\n *\n * @param {Label} label The label to check for.\n * @returns {Boolean} true if this collection contains the label, false otherwise.\n *\n * @see LabelCollection#get\n *\n */\n\n\nLabelCollection.prototype.contains = function (label) {\n  return defined(label) && label._labelCollection === this;\n};\n/**\n * Returns the label in the collection at the specified index.  Indices are zero-based\n * and increase as labels are added.  Removing a label shifts all labels after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link LabelCollection#length} to iterate over all the labels\n * in the collection.\n *\n * @param {Number} index The zero-based index of the billboard.\n *\n * @returns {Label} The label at the specified index.\n *\n * @performance Expected constant time.  If labels were removed from the collection and\n * {@link Scene#render} was not called, an implicit <code>O(n)</code>\n * operation is performed.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Toggle the show property of every label in the collection\n * var len = labels.length;\n * for (var i = 0; i < len; ++i) {\n *   var l = billboards.get(i);\n *   l.show = !l.show;\n * }\n *\n * @see LabelCollection#length\n */\n\n\nLabelCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  } //>>includeEnd('debug');\n\n\n  return this._labels[index];\n};\n/**\n * @private\n *\n */\n\n\nLabelCollection.prototype.update = function (frameState) {\n  var billboardCollection = this._billboardCollection;\n  var backgroundBillboardCollection = this._backgroundBillboardCollection;\n  billboardCollection.modelMatrix = this.modelMatrix;\n  billboardCollection.debugShowBoundingVolume = this.debugShowBoundingVolume;\n  backgroundBillboardCollection.modelMatrix = this.modelMatrix;\n  backgroundBillboardCollection.debugShowBoundingVolume = this.debugShowBoundingVolume;\n  var context = frameState.context;\n\n  if (!defined(this._textureAtlas)) {\n    this._textureAtlas = new TextureAtlas({\n      context: context\n    });\n    billboardCollection.textureAtlas = this._textureAtlas;\n  }\n\n  if (!defined(this._backgroundTextureAtlas)) {\n    this._backgroundTextureAtlas = new TextureAtlas({\n      context: context,\n      initialSize: whitePixelSize\n    });\n    backgroundBillboardCollection.textureAtlas = this._backgroundTextureAtlas;\n    addWhitePixelCanvas(this._backgroundTextureAtlas, this);\n  }\n\n  var len = this._labelsToUpdate.length;\n\n  for (var i = 0; i < len; ++i) {\n    var label = this._labelsToUpdate[i];\n\n    if (label.isDestroyed()) {\n      continue;\n    }\n\n    var preUpdateGlyphCount = label._glyphs.length;\n\n    if (label._rebindAllGlyphs) {\n      rebindAllGlyphs(this, label);\n      label._rebindAllGlyphs = false;\n    }\n\n    if (label._repositionAllGlyphs) {\n      repositionAllGlyphs(label);\n      label._repositionAllGlyphs = false;\n    }\n\n    var glyphCountDifference = label._glyphs.length - preUpdateGlyphCount;\n    this._totalGlyphCount += glyphCountDifference;\n  }\n\n  var blendOption = backgroundBillboardCollection.length > 0 ? BlendOption.TRANSLUCENT : this.blendOption;\n  billboardCollection.blendOption = blendOption;\n  backgroundBillboardCollection.blendOption = blendOption;\n  billboardCollection._highlightColor = this._highlightColor;\n  backgroundBillboardCollection._highlightColor = this._highlightColor;\n  this._labelsToUpdate.length = 0;\n  backgroundBillboardCollection.update(frameState);\n  billboardCollection.update(frameState);\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see LabelCollection#destroy\n */\n\n\nLabelCollection.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * labels = labels && labels.destroy();\n *\n * @see LabelCollection#isDestroyed\n */\n\n\nLabelCollection.prototype.destroy = function () {\n  this.removeAll();\n  this._billboardCollection = this._billboardCollection.destroy();\n  this._textureAtlas = this._textureAtlas && this._textureAtlas.destroy();\n  this._backgroundBillboardCollection = this._backgroundBillboardCollection.destroy();\n  this._backgroundTextureAtlas = this._backgroundTextureAtlas && this._backgroundTextureAtlas.destroy();\n  return destroyObject(this);\n};\n\nexport default LabelCollection;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Scene/LabelCollection.js"],"names":["BoundingRectangle","Cartesian2","Color","defaultValue","defined","destroyObject","DeveloperError","Matrix4","writeTextToCanvas","bitmapSDF","BillboardCollection","BlendOption","HeightReference","HorizontalOrigin","Label","LabelStyle","SDFSettings","TextureAtlas","VerticalOrigin","GraphemeSplitter","Glyph","textureInfo","undefined","dimensions","billboard","GlyphTextureInfo","labelCollection","index","defaultLineSpacingPercent","whitePixelCanvasId","whitePixelSize","whitePixelBoundingRegion","addWhitePixelCanvas","textureAtlas","canvas","document","createElement","width","x","height","y","context2D","getContext","fillStyle","fillRect","addImage","then","_whitePixelIndex","writeTextToCanvasParameters","createGlyphCanvas","character","font","fillColor","outlineColor","outlineWidth","style","verticalOrigin","strokeColor","strokeWidth","padding","PADDING","CENTER","textBaseline","TOP","fill","FILL","FILL_AND_OUTLINE","stroke","OUTLINE","backgroundColor","BLACK","unbindGlyph","glyph","show","image","_removeCallbackFunc","_spareBillboards","push","addGlyphToTextureAtlas","id","glyphTextureInfo","splitter","rebindAllGlyphs","label","text","_renderedText","graphemes","splitGraphemes","textLength","length","glyphs","_glyphs","glyphsLength","glyphIndex","textIndex","_relativeSize","_fontSize","FONT_SIZE","showBackground","_showBackground","split","join","backgroundBillboard","_backgroundBillboard","backgroundBillboardCollection","_backgroundBillboardCollection","remove","add","collection","imageSubRegion","color","_backgroundColor","_show","position","_position","eyeOffset","_eyeOffset","pixelOffset","_pixelOffset","horizontalOrigin","LEFT","_verticalOrigin","heightReference","_heightReference","scale","totalScale","pickPrimitive","_id","translucencyByDistance","_translucencyByDistance","pixelOffsetScaleByDistance","_pixelOffsetScaleByDistance","scaleByDistance","_scaleByDistance","distanceDisplayCondition","_distanceDisplayCondition","disableDepthTestDistance","_disableDepthTestDistance","glyphTextureCache","_glyphTextureCache","JSON","stringify","_fontFamily","_fontStyle","_fontWeight","glyphFont","WHITE","sdfValues","cutoff","CUTOFF","radius","RADIUS","ctx","canvasWidth","canvasHeight","imgData","getImageData","i","j","baseIndex","alpha","imageIndex","data","putImageData","_textureAtlas","spareBillboards","pop","_billboardCollection","_labelDimensions","_labelTranslate","_batchIndex","_fillColor","TRANSPARENT","_repositionAllGlyphs","calculateWidthOffset","lineWidth","backgroundPadding","RIGHT","glyphPixelOffset","scratchBackgroundPadding","repositionAllGlyphs","lastLineWidth","maxLineWidth","lineWidths","maxGlyphDescent","Number","NEGATIVE_INFINITY","maxGlyphY","numberOfLines","glyphLength","clone","_backgroundPadding","ZERO","charAt","Math","max","descent","bounds","minx","maxLineHeight","_horizontalOrigin","lineIndex","widthOffset","lineSpacing","otherLinesHeight","totalLineWidth","totalLineHeight","_labelHorizontalOrigin","firstCharOfLine","lineOffsetY","BASELINE","_setTranslate","nextGlyph","CLAMP_TO_GROUND","destroyLabel","len","_labelCollection","LabelCollection","options","EMPTY_OBJECT","_scene","scene","_batchTable","batchTable","_backgroundTextureAtlas","destroyTextureAtlas","_sdf","_labels","_labelsToUpdate","_totalGlyphCount","_highlightColor","modelMatrix","IDENTITY","debugShowBoundingVolume","blendOption","OPAQUE_AND_TRANSLUCENT","Object","defineProperties","prototype","get","indexOf","splice","removeAll","labels","contains","update","frameState","billboardCollection","context","initialSize","isDestroyed","preUpdateGlyphCount","_rebindAllGlyphs","glyphCountDifference","TRANSLUCENT","destroy"],"mappings":"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","sourcesContent":["import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport writeTextToCanvas from \"../Core/writeTextToCanvas.js\";\nimport bitmapSDF from \"../ThirdParty/bitmap-sdf.js\";\nimport BillboardCollection from \"./BillboardCollection.js\";\nimport BlendOption from \"./BlendOption.js\";\nimport HeightReference from \"./HeightReference.js\";\nimport HorizontalOrigin from \"./HorizontalOrigin.js\";\nimport Label from \"./Label.js\";\nimport LabelStyle from \"./LabelStyle.js\";\nimport SDFSettings from \"./SDFSettings.js\";\nimport TextureAtlas from \"./TextureAtlas.js\";\nimport VerticalOrigin from \"./VerticalOrigin.js\";\nimport GraphemeSplitter from \"../ThirdParty/graphemesplitter.js\";\n\n// A glyph represents a single character in a particular label.  It may or may\n// not have a billboard, depending on whether the texture info has an index into\n// the the label collection's texture atlas.  Invisible characters have no texture, and\n// no billboard.  However, it always has a valid dimensions object.\nfunction Glyph() {\n  this.textureInfo = undefined;\n  this.dimensions = undefined;\n  this.billboard = undefined;\n}\n\n// GlyphTextureInfo represents a single character, drawn in a particular style,\n// shared and reference counted across all labels.  It may or may not have an\n// index into the label collection's texture atlas, depending on whether the character\n// has both width and height, but it always has a valid dimensions object.\nfunction GlyphTextureInfo(labelCollection, index, dimensions) {\n  this.labelCollection = labelCollection;\n  this.index = index;\n  this.dimensions = dimensions;\n}\n\n// Traditionally, leading is %20 of the font size.\nvar defaultLineSpacingPercent = 1.2;\n\nvar whitePixelCanvasId = \"ID_WHITE_PIXEL\";\nvar whitePixelSize = new Cartesian2(4, 4);\nvar whitePixelBoundingRegion = new BoundingRectangle(1, 1, 1, 1);\n\nfunction addWhitePixelCanvas(textureAtlas, labelCollection) {\n  var canvas = document.createElement(\"canvas\");\n  canvas.width = whitePixelSize.x;\n  canvas.height = whitePixelSize.y;\n\n  var context2D = canvas.getContext(\"2d\");\n  context2D.fillStyle = \"#fff\";\n  context2D.fillRect(0, 0, canvas.width, canvas.height);\n\n  textureAtlas.addImage(whitePixelCanvasId, canvas).then(function (index) {\n    labelCollection._whitePixelIndex = index;\n  });\n}\n\n// reusable object for calling writeTextToCanvas\nvar writeTextToCanvasParameters = {};\nfunction createGlyphCanvas(\n  character,\n  font,\n  fillColor,\n  outlineColor,\n  outlineWidth,\n  style,\n  verticalOrigin\n) {\n  writeTextToCanvasParameters.font = font;\n  writeTextToCanvasParameters.fillColor = fillColor;\n  writeTextToCanvasParameters.strokeColor = outlineColor;\n  writeTextToCanvasParameters.strokeWidth = outlineWidth;\n  // Setting the padding to something bigger is necessary to get enough space for the outlining.\n  writeTextToCanvasParameters.padding = SDFSettings.PADDING;\n\n  if (verticalOrigin === VerticalOrigin.CENTER) {\n    writeTextToCanvasParameters.textBaseline = \"middle\";\n  } else if (verticalOrigin === VerticalOrigin.TOP) {\n    writeTextToCanvasParameters.textBaseline = \"top\";\n  } else {\n    // VerticalOrigin.BOTTOM and VerticalOrigin.BASELINE\n    writeTextToCanvasParameters.textBaseline = \"bottom\";\n  }\n\n  writeTextToCanvasParameters.fill =\n    style === LabelStyle.FILL || style === LabelStyle.FILL_AND_OUTLINE;\n  writeTextToCanvasParameters.stroke =\n    style === LabelStyle.OUTLINE || style === LabelStyle.FILL_AND_OUTLINE;\n  writeTextToCanvasParameters.backgroundColor = Color.BLACK;\n\n  return writeTextToCanvas(character, writeTextToCanvasParameters);\n}\n\nfunction unbindGlyph(labelCollection, glyph) {\n  glyph.textureInfo = undefined;\n  glyph.dimensions = undefined;\n\n  var billboard = glyph.billboard;\n  if (defined(billboard)) {\n    billboard.show = false;\n    billboard.image = undefined;\n    if (defined(billboard._removeCallbackFunc)) {\n      billboard._removeCallbackFunc();\n      billboard._removeCallbackFunc = undefined;\n    }\n    labelCollection._spareBillboards.push(billboard);\n    glyph.billboard = undefined;\n  }\n}\n\nfunction addGlyphToTextureAtlas(textureAtlas, id, canvas, glyphTextureInfo) {\n  textureAtlas.addImage(id, canvas).then(function (index) {\n    glyphTextureInfo.index = index;\n  });\n}\n\nvar splitter = new GraphemeSplitter();\n\nfunction rebindAllGlyphs(labelCollection, label) {\n  var text = label._renderedText;\n  var graphemes = splitter.splitGraphemes(text);\n  var textLength = graphemes.length;\n  var glyphs = label._glyphs;\n  var glyphsLength = glyphs.length;\n\n  var glyph;\n  var glyphIndex;\n  var textIndex;\n\n  // Compute a font size scale relative to the sdf font generated size.\n  label._relativeSize = label._fontSize / SDFSettings.FONT_SIZE;\n\n  // if we have more glyphs than needed, unbind the extras.\n  if (textLength < glyphsLength) {\n    for (glyphIndex = textLength; glyphIndex < glyphsLength; ++glyphIndex) {\n      unbindGlyph(labelCollection, glyphs[glyphIndex]);\n    }\n  }\n\n  // presize glyphs to match the new text length\n  glyphs.length = textLength;\n\n  var showBackground =\n    label._showBackground && text.split(\"\\n\").join(\"\").length > 0;\n  var backgroundBillboard = label._backgroundBillboard;\n  var backgroundBillboardCollection =\n    labelCollection._backgroundBillboardCollection;\n  if (!showBackground) {\n    if (defined(backgroundBillboard)) {\n      backgroundBillboardCollection.remove(backgroundBillboard);\n      label._backgroundBillboard = backgroundBillboard = undefined;\n    }\n  } else {\n    if (!defined(backgroundBillboard)) {\n      backgroundBillboard = backgroundBillboardCollection.add({\n        collection: labelCollection,\n        image: whitePixelCanvasId,\n        imageSubRegion: whitePixelBoundingRegion,\n      });\n      label._backgroundBillboard = backgroundBillboard;\n    }\n\n    backgroundBillboard.color = label._backgroundColor;\n    backgroundBillboard.show = label._show;\n    backgroundBillboard.position = label._position;\n    backgroundBillboard.eyeOffset = label._eyeOffset;\n    backgroundBillboard.pixelOffset = label._pixelOffset;\n    backgroundBillboard.horizontalOrigin = HorizontalOrigin.LEFT;\n    backgroundBillboard.verticalOrigin = label._verticalOrigin;\n    backgroundBillboard.heightReference = label._heightReference;\n    backgroundBillboard.scale = label.totalScale;\n    backgroundBillboard.pickPrimitive = label;\n    backgroundBillboard.id = label._id;\n    backgroundBillboard.translucencyByDistance = label._translucencyByDistance;\n    backgroundBillboard.pixelOffsetScaleByDistance =\n      label._pixelOffsetScaleByDistance;\n    backgroundBillboard.scaleByDistance = label._scaleByDistance;\n    backgroundBillboard.distanceDisplayCondition =\n      label._distanceDisplayCondition;\n    backgroundBillboard.disableDepthTestDistance =\n      label._disableDepthTestDistance;\n  }\n\n  var glyphTextureCache = labelCollection._glyphTextureCache;\n\n  // walk the text looking for new characters (creating new glyphs for each)\n  // or changed characters (rebinding existing glyphs)\n  for (textIndex = 0; textIndex < textLength; ++textIndex) {\n    var character = graphemes[textIndex];\n    var verticalOrigin = label._verticalOrigin;\n\n    var id = JSON.stringify([\n      character,\n      label._fontFamily,\n      label._fontStyle,\n      label._fontWeight,\n      +verticalOrigin,\n    ]);\n\n    var glyphTextureInfo = glyphTextureCache[id];\n    if (!defined(glyphTextureInfo)) {\n      var glyphFont =\n        label._fontStyle +\n        \" \" +\n        label._fontWeight +\n        \" \" +\n        SDFSettings.FONT_SIZE +\n        \"px \" +\n        label._fontFamily;\n\n      var canvas = createGlyphCanvas(\n        character,\n        glyphFont,\n        Color.WHITE,\n        Color.WHITE,\n        0.0,\n        LabelStyle.FILL,\n        verticalOrigin\n      );\n\n      glyphTextureInfo = new GlyphTextureInfo(\n        labelCollection,\n        -1,\n        canvas.dimensions\n      );\n      glyphTextureCache[id] = glyphTextureInfo;\n\n      if (canvas.width > 0 && canvas.height > 0) {\n        var sdfValues = bitmapSDF(canvas, {\n          cutoff: SDFSettings.CUTOFF,\n          radius: SDFSettings.RADIUS,\n        });\n\n        var ctx = canvas.getContext(\"2d\");\n        var canvasWidth = canvas.width;\n        var canvasHeight = canvas.height;\n        var imgData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);\n        for (var i = 0; i < canvasWidth; i++) {\n          for (var j = 0; j < canvasHeight; j++) {\n            var baseIndex = j * canvasWidth + i;\n            var alpha = sdfValues[baseIndex] * 255;\n            var imageIndex = baseIndex * 4;\n            imgData.data[imageIndex + 0] = alpha;\n            imgData.data[imageIndex + 1] = alpha;\n            imgData.data[imageIndex + 2] = alpha;\n            imgData.data[imageIndex + 3] = alpha;\n          }\n        }\n        ctx.putImageData(imgData, 0, 0);\n        if (character !== \" \") {\n          addGlyphToTextureAtlas(\n            labelCollection._textureAtlas,\n            id,\n            canvas,\n            glyphTextureInfo\n          );\n        }\n      }\n    }\n\n    glyph = glyphs[textIndex];\n\n    if (defined(glyph)) {\n      // clean up leftover information from the previous glyph\n      if (glyphTextureInfo.index === -1) {\n        // no texture, and therefore no billboard, for this glyph.\n        // so, completely unbind glyph.\n        unbindGlyph(labelCollection, glyph);\n      } else if (defined(glyph.textureInfo)) {\n        // we have a texture and billboard.  If we had one before, release\n        // our reference to that texture info, but reuse the billboard.\n        glyph.textureInfo = undefined;\n      }\n    } else {\n      // create a glyph object\n      glyph = new Glyph();\n      glyphs[textIndex] = glyph;\n    }\n\n    glyph.textureInfo = glyphTextureInfo;\n    glyph.dimensions = glyphTextureInfo.dimensions;\n\n    // if we have a texture, configure the existing billboard, or obtain one\n    if (glyphTextureInfo.index !== -1) {\n      var billboard = glyph.billboard;\n      var spareBillboards = labelCollection._spareBillboards;\n      if (!defined(billboard)) {\n        if (spareBillboards.length > 0) {\n          billboard = spareBillboards.pop();\n        } else {\n          billboard = labelCollection._billboardCollection.add({\n            collection: labelCollection,\n          });\n          billboard._labelDimensions = new Cartesian2();\n          billboard._labelTranslate = new Cartesian2();\n        }\n        glyph.billboard = billboard;\n      }\n\n      billboard.show = label._show;\n      billboard.position = label._position;\n      billboard.eyeOffset = label._eyeOffset;\n      billboard.pixelOffset = label._pixelOffset;\n      billboard.horizontalOrigin = HorizontalOrigin.LEFT;\n      billboard.verticalOrigin = label._verticalOrigin;\n      billboard.heightReference = label._heightReference;\n      billboard.scale = label.totalScale;\n      billboard.pickPrimitive = label;\n      billboard.id = label._id;\n      billboard.image = id;\n      billboard.translucencyByDistance = label._translucencyByDistance;\n      billboard.pixelOffsetScaleByDistance = label._pixelOffsetScaleByDistance;\n      billboard.scaleByDistance = label._scaleByDistance;\n      billboard.distanceDisplayCondition = label._distanceDisplayCondition;\n      billboard.disableDepthTestDistance = label._disableDepthTestDistance;\n      billboard._batchIndex = label._batchIndex;\n      billboard.outlineColor = label.outlineColor;\n      if (label.style === LabelStyle.FILL_AND_OUTLINE) {\n        billboard.color = label._fillColor;\n        billboard.outlineWidth = label.outlineWidth;\n      } else if (label.style === LabelStyle.FILL) {\n        billboard.color = label._fillColor;\n        billboard.outlineWidth = 0.0;\n      } else if (label.style === LabelStyle.OUTLINE) {\n        billboard.color = Color.TRANSPARENT;\n        billboard.outlineWidth = label.outlineWidth;\n      }\n    }\n  }\n\n  // changing glyphs will cause the position of the\n  // glyphs to change, since different characters have different widths\n  label._repositionAllGlyphs = true;\n}\n\nfunction calculateWidthOffset(lineWidth, horizontalOrigin, backgroundPadding) {\n  if (horizontalOrigin === HorizontalOrigin.CENTER) {\n    return -lineWidth / 2;\n  } else if (horizontalOrigin === HorizontalOrigin.RIGHT) {\n    return -(lineWidth + backgroundPadding.x);\n  }\n  return backgroundPadding.x;\n}\n\n// reusable Cartesian2 instances\nvar glyphPixelOffset = new Cartesian2();\nvar scratchBackgroundPadding = new Cartesian2();\n\nfunction repositionAllGlyphs(label) {\n  var glyphs = label._glyphs;\n  var text = label._renderedText;\n  var glyph;\n  var dimensions;\n  var lastLineWidth = 0;\n  var maxLineWidth = 0;\n  var lineWidths = [];\n  var maxGlyphDescent = Number.NEGATIVE_INFINITY;\n  var maxGlyphY = 0;\n  var numberOfLines = 1;\n  var glyphIndex;\n  var glyphLength = glyphs.length;\n\n  var backgroundBillboard = label._backgroundBillboard;\n  var backgroundPadding = Cartesian2.clone(\n    defined(backgroundBillboard) ? label._backgroundPadding : Cartesian2.ZERO,\n    scratchBackgroundPadding\n  );\n\n  // We need to scale the background padding, which is specified in pixels by the inverse of the relative size so it is scaled properly.\n  backgroundPadding.x /= label._relativeSize;\n  backgroundPadding.y /= label._relativeSize;\n\n  for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {\n    if (text.charAt(glyphIndex) === \"\\n\") {\n      lineWidths.push(lastLineWidth);\n      ++numberOfLines;\n      lastLineWidth = 0;\n    } else {\n      glyph = glyphs[glyphIndex];\n      dimensions = glyph.dimensions;\n      maxGlyphY = Math.max(maxGlyphY, dimensions.height - dimensions.descent);\n      maxGlyphDescent = Math.max(maxGlyphDescent, dimensions.descent);\n\n      //Computing the line width must also account for the kerning that occurs between letters.\n      lastLineWidth += dimensions.width - dimensions.bounds.minx;\n      if (glyphIndex < glyphLength - 1) {\n        lastLineWidth += glyphs[glyphIndex + 1].dimensions.bounds.minx;\n      }\n      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n    }\n  }\n  lineWidths.push(lastLineWidth);\n  var maxLineHeight = maxGlyphY + maxGlyphDescent;\n\n  var scale = label.totalScale;\n  var horizontalOrigin = label._horizontalOrigin;\n  var verticalOrigin = label._verticalOrigin;\n  var lineIndex = 0;\n  var lineWidth = lineWidths[lineIndex];\n  var widthOffset = calculateWidthOffset(\n    lineWidth,\n    horizontalOrigin,\n    backgroundPadding\n  );\n  var lineSpacing = defaultLineSpacingPercent * maxLineHeight;\n  var otherLinesHeight = lineSpacing * (numberOfLines - 1);\n  var totalLineWidth = maxLineWidth;\n  var totalLineHeight = maxLineHeight + otherLinesHeight;\n\n  if (defined(backgroundBillboard)) {\n    totalLineWidth += backgroundPadding.x * 2;\n    totalLineHeight += backgroundPadding.y * 2;\n    backgroundBillboard._labelHorizontalOrigin = horizontalOrigin;\n  }\n\n  glyphPixelOffset.x = widthOffset * scale;\n  glyphPixelOffset.y = 0;\n\n  var firstCharOfLine = true;\n\n  var lineOffsetY = 0;\n  for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {\n    if (text.charAt(glyphIndex) === \"\\n\") {\n      ++lineIndex;\n      lineOffsetY += lineSpacing;\n      lineWidth = lineWidths[lineIndex];\n      widthOffset = calculateWidthOffset(\n        lineWidth,\n        horizontalOrigin,\n        backgroundPadding\n      );\n      glyphPixelOffset.x = widthOffset * scale;\n      firstCharOfLine = true;\n    } else {\n      glyph = glyphs[glyphIndex];\n      dimensions = glyph.dimensions;\n\n      if (verticalOrigin === VerticalOrigin.TOP) {\n        glyphPixelOffset.y =\n          dimensions.height - maxGlyphY - backgroundPadding.y;\n        glyphPixelOffset.y += SDFSettings.PADDING;\n      } else if (verticalOrigin === VerticalOrigin.CENTER) {\n        glyphPixelOffset.y =\n          (otherLinesHeight + dimensions.height - maxGlyphY) / 2;\n      } else if (verticalOrigin === VerticalOrigin.BASELINE) {\n        glyphPixelOffset.y = otherLinesHeight;\n        glyphPixelOffset.y -= SDFSettings.PADDING;\n      } else {\n        // VerticalOrigin.BOTTOM\n        glyphPixelOffset.y =\n          otherLinesHeight + maxGlyphDescent + backgroundPadding.y;\n        glyphPixelOffset.y -= SDFSettings.PADDING;\n      }\n      glyphPixelOffset.y =\n        (glyphPixelOffset.y - dimensions.descent - lineOffsetY) * scale;\n\n      // Handle any offsets for the first character of the line since the bounds might not be right on the bottom left pixel.\n      if (firstCharOfLine) {\n        glyphPixelOffset.x -= SDFSettings.PADDING * scale;\n        firstCharOfLine = false;\n      }\n\n      if (defined(glyph.billboard)) {\n        glyph.billboard._setTranslate(glyphPixelOffset);\n        glyph.billboard._labelDimensions.x = totalLineWidth;\n        glyph.billboard._labelDimensions.y = totalLineHeight;\n        glyph.billboard._labelHorizontalOrigin = horizontalOrigin;\n      }\n\n      //Compute the next x offset taking into account the kerning performed\n      //on both the current letter as well as the next letter to be drawn\n      //as well as any applied scale.\n      if (glyphIndex < glyphLength - 1) {\n        var nextGlyph = glyphs[glyphIndex + 1];\n        glyphPixelOffset.x +=\n          (dimensions.width -\n            dimensions.bounds.minx +\n            nextGlyph.dimensions.bounds.minx) *\n          scale;\n      }\n    }\n  }\n\n  if (defined(backgroundBillboard) && text.split(\"\\n\").join(\"\").length > 0) {\n    if (horizontalOrigin === HorizontalOrigin.CENTER) {\n      widthOffset = -maxLineWidth / 2 - backgroundPadding.x;\n    } else if (horizontalOrigin === HorizontalOrigin.RIGHT) {\n      widthOffset = -(maxLineWidth + backgroundPadding.x * 2);\n    } else {\n      widthOffset = 0;\n    }\n    glyphPixelOffset.x = widthOffset * scale;\n\n    if (verticalOrigin === VerticalOrigin.TOP) {\n      glyphPixelOffset.y = maxLineHeight - maxGlyphY - maxGlyphDescent;\n    } else if (verticalOrigin === VerticalOrigin.CENTER) {\n      glyphPixelOffset.y = (maxLineHeight - maxGlyphY) / 2 - maxGlyphDescent;\n    } else if (verticalOrigin === VerticalOrigin.BASELINE) {\n      glyphPixelOffset.y = -backgroundPadding.y - maxGlyphDescent;\n    } else {\n      // VerticalOrigin.BOTTOM\n      glyphPixelOffset.y = 0;\n    }\n    glyphPixelOffset.y = glyphPixelOffset.y * scale;\n\n    backgroundBillboard.width = totalLineWidth;\n    backgroundBillboard.height = totalLineHeight;\n    backgroundBillboard._setTranslate(glyphPixelOffset);\n    backgroundBillboard._labelTranslate = Cartesian2.clone(\n      glyphPixelOffset,\n      backgroundBillboard._labelTranslate\n    );\n  }\n\n  if (label.heightReference === HeightReference.CLAMP_TO_GROUND) {\n    for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {\n      glyph = glyphs[glyphIndex];\n      var billboard = glyph.billboard;\n      if (defined(billboard)) {\n        billboard._labelTranslate = Cartesian2.clone(\n          glyphPixelOffset,\n          billboard._labelTranslate\n        );\n      }\n    }\n  }\n}\n\nfunction destroyLabel(labelCollection, label) {\n  var glyphs = label._glyphs;\n  for (var i = 0, len = glyphs.length; i < len; ++i) {\n    unbindGlyph(labelCollection, glyphs[i]);\n  }\n  if (defined(label._backgroundBillboard)) {\n    labelCollection._backgroundBillboardCollection.remove(\n      label._backgroundBillboard\n    );\n    label._backgroundBillboard = undefined;\n  }\n  label._labelCollection = undefined;\n\n  if (defined(label._removeCallbackFunc)) {\n    label._removeCallbackFunc();\n  }\n\n  destroyObject(label);\n}\n\n/**\n * A renderable collection of labels.  Labels are viewport-aligned text positioned in the 3D scene.\n * Each label can have a different font, color, scale, etc.\n * <br /><br />\n * <div align='center'>\n * <img src='Images/Label.png' width='400' height='300' /><br />\n * Example labels\n * </div>\n * <br /><br />\n * Labels are added and removed from the collection using {@link LabelCollection#add}\n * and {@link LabelCollection#remove}.\n *\n * @alias LabelCollection\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each label from model to world coordinates.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {Scene} [options.scene] Must be passed in for labels that use the height reference property or will be depth tested against the globe.\n * @param {BlendOption} [options.blendOption=BlendOption.OPAQUE_AND_TRANSLUCENT] The label blending option. The default\n * is used for rendering both opaque and translucent labels. However, if either all of the labels are completely opaque or all are completely translucent,\n * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve performance by up to 2x.\n *\n * @performance For best performance, prefer a few collections, each with many labels, to\n * many collections with only a few labels each.  Avoid having collections where some\n * labels change every frame and others do not; instead, create one or more collections\n * for static labels, and one or more collections for dynamic labels.\n *\n * @see LabelCollection#add\n * @see LabelCollection#remove\n * @see Label\n * @see BillboardCollection\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Labels.html|Cesium Sandcastle Labels Demo}\n *\n * @example\n * // Create a label collection with two labels\n * var labels = scene.primitives.add(new Cesium.LabelCollection());\n * labels.add({\n *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),\n *   text : 'A label'\n * });\n * labels.add({\n *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),\n *   text : 'Another label'\n * });\n */\nfunction LabelCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._scene = options.scene;\n  this._batchTable = options.batchTable;\n\n  this._textureAtlas = undefined;\n  this._backgroundTextureAtlas = undefined;\n  this._whitePixelIndex = undefined;\n\n  this._backgroundBillboardCollection = new BillboardCollection({\n    scene: this._scene,\n  });\n  this._backgroundBillboardCollection.destroyTextureAtlas = false;\n\n  this._billboardCollection = new BillboardCollection({\n    scene: this._scene,\n    batchTable: this._batchTable,\n  });\n  this._billboardCollection.destroyTextureAtlas = false;\n  this._billboardCollection._sdf = true;\n\n  this._spareBillboards = [];\n  this._glyphTextureCache = {};\n  this._labels = [];\n  this._labelsToUpdate = [];\n  this._totalGlyphCount = 0;\n\n  this._highlightColor = Color.clone(Color.WHITE); // Only used by Vector3DTilePoints\n\n  /**\n   * The 4x4 transformation matrix that transforms each label in this collection from model to world coordinates.\n   * When this is the identity matrix, the labels are drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type Matrix4\n   * @default {@link Matrix4.IDENTITY}\n   *\n   * @example\n   * var center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n   * labels.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0),\n   *   text     : 'Center'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0),\n   *   text     : 'East'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0),\n   *   text     : 'North'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0),\n   *   text     : 'Up'\n   * });\n   */\n  this.modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY)\n  );\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false\n  );\n\n  /**\n   * The label blending option. The default is used for rendering both opaque and translucent labels.\n   * However, if either all of the labels are completely opaque or all are completely translucent,\n   * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve\n   * performance by up to 2x.\n   * @type {BlendOption}\n   * @default BlendOption.OPAQUE_AND_TRANSLUCENT\n   */\n  this.blendOption = defaultValue(\n    options.blendOption,\n    BlendOption.OPAQUE_AND_TRANSLUCENT\n  );\n}\n\nObject.defineProperties(LabelCollection.prototype, {\n  /**\n   * Returns the number of labels in this collection.  This is commonly used with\n   * {@link LabelCollection#get} to iterate over all the labels\n   * in the collection.\n   * @memberof LabelCollection.prototype\n   * @type {Number}\n   */\n  length: {\n    get: function () {\n      return this._labels.length;\n    },\n  },\n});\n\n/**\n * Creates and adds a label with the specified initial properties to the collection.\n * The added label is returned so it can be modified or removed from the collection later.\n *\n * @param {Object} [options] A template describing the label's properties as shown in Example 1.\n * @returns {Label} The label that was added to the collection.\n *\n * @performance Calling <code>add</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten; this operations is <code>O(n)</code> and also incurs\n * CPU to GPU overhead.  For best performance, add as many billboards as possible before\n * calling <code>update</code>.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Example 1:  Add a label, specifying all the default values.\n * var l = labels.add({\n *   show : true,\n *   position : Cesium.Cartesian3.ZERO,\n *   text : '',\n *   font : '30px sans-serif',\n *   fillColor : Cesium.Color.WHITE,\n *   outlineColor : Cesium.Color.BLACK,\n *   outlineWidth : 1.0,\n *   showBackground : false,\n *   backgroundColor : new Cesium.Color(0.165, 0.165, 0.165, 0.8),\n *   backgroundPadding : new Cesium.Cartesian2(7, 5),\n *   style : Cesium.LabelStyle.FILL,\n *   pixelOffset : Cesium.Cartesian2.ZERO,\n *   eyeOffset : Cesium.Cartesian3.ZERO,\n *   horizontalOrigin : Cesium.HorizontalOrigin.LEFT,\n *   verticalOrigin : Cesium.VerticalOrigin.BASELINE,\n *   scale : 1.0,\n *   translucencyByDistance : undefined,\n *   pixelOffsetScaleByDistance : undefined,\n *   heightReference : HeightReference.NONE,\n *   distanceDisplayCondition : undefined\n * });\n *\n * @example\n * // Example 2:  Specify only the label's cartographic position,\n * // text, and font.\n * var l = labels.add({\n *   position : Cesium.Cartesian3.fromRadians(longitude, latitude, height),\n *   text : 'Hello World',\n *   font : '24px Helvetica',\n * });\n *\n * @see LabelCollection#remove\n * @see LabelCollection#removeAll\n */\nLabelCollection.prototype.add = function (options) {\n  var label = new Label(options, this);\n\n  this._labels.push(label);\n  this._labelsToUpdate.push(label);\n\n  return label;\n};\n\n/**\n * Removes a label from the collection.  Once removed, a label is no longer usable.\n *\n * @param {Label} label The label to remove.\n * @returns {Boolean} <code>true</code> if the label was removed; <code>false</code> if the label was not found in the collection.\n *\n * @performance Calling <code>remove</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, remove as many labels as possible before calling <code>update</code>.\n * If you intend to temporarily hide a label, it is usually more efficient to call\n * {@link Label#show} instead of removing and re-adding the label.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * var l = labels.add(...);\n * labels.remove(l);  // Returns true\n *\n * @see LabelCollection#add\n * @see LabelCollection#removeAll\n * @see Label#show\n */\nLabelCollection.prototype.remove = function (label) {\n  if (defined(label) && label._labelCollection === this) {\n    var index = this._labels.indexOf(label);\n    if (index !== -1) {\n      this._labels.splice(index, 1);\n      destroyLabel(this, label);\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Removes all labels from the collection.\n *\n * @performance <code>O(n)</code>.  It is more efficient to remove all the labels\n * from a collection and then add new ones than to create a new collection entirely.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * labels.add(...);\n * labels.add(...);\n * labels.removeAll();\n *\n * @see LabelCollection#add\n * @see LabelCollection#remove\n */\nLabelCollection.prototype.removeAll = function () {\n  var labels = this._labels;\n\n  for (var i = 0, len = labels.length; i < len; ++i) {\n    destroyLabel(this, labels[i]);\n  }\n\n  labels.length = 0;\n};\n\n/**\n * Check whether this collection contains a given label.\n *\n * @param {Label} label The label to check for.\n * @returns {Boolean} true if this collection contains the label, false otherwise.\n *\n * @see LabelCollection#get\n *\n */\nLabelCollection.prototype.contains = function (label) {\n  return defined(label) && label._labelCollection === this;\n};\n\n/**\n * Returns the label in the collection at the specified index.  Indices are zero-based\n * and increase as labels are added.  Removing a label shifts all labels after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link LabelCollection#length} to iterate over all the labels\n * in the collection.\n *\n * @param {Number} index The zero-based index of the billboard.\n *\n * @returns {Label} The label at the specified index.\n *\n * @performance Expected constant time.  If labels were removed from the collection and\n * {@link Scene#render} was not called, an implicit <code>O(n)</code>\n * operation is performed.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Toggle the show property of every label in the collection\n * var len = labels.length;\n * for (var i = 0; i < len; ++i) {\n *   var l = billboards.get(i);\n *   l.show = !l.show;\n * }\n *\n * @see LabelCollection#length\n */\nLabelCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return this._labels[index];\n};\n\n/**\n * @private\n *\n */\nLabelCollection.prototype.update = function (frameState) {\n  var billboardCollection = this._billboardCollection;\n  var backgroundBillboardCollection = this._backgroundBillboardCollection;\n\n  billboardCollection.modelMatrix = this.modelMatrix;\n  billboardCollection.debugShowBoundingVolume = this.debugShowBoundingVolume;\n  backgroundBillboardCollection.modelMatrix = this.modelMatrix;\n  backgroundBillboardCollection.debugShowBoundingVolume = this.debugShowBoundingVolume;\n\n  var context = frameState.context;\n\n  if (!defined(this._textureAtlas)) {\n    this._textureAtlas = new TextureAtlas({\n      context: context,\n    });\n    billboardCollection.textureAtlas = this._textureAtlas;\n  }\n\n  if (!defined(this._backgroundTextureAtlas)) {\n    this._backgroundTextureAtlas = new TextureAtlas({\n      context: context,\n      initialSize: whitePixelSize,\n    });\n    backgroundBillboardCollection.textureAtlas = this._backgroundTextureAtlas;\n    addWhitePixelCanvas(this._backgroundTextureAtlas, this);\n  }\n\n  var len = this._labelsToUpdate.length;\n  for (var i = 0; i < len; ++i) {\n    var label = this._labelsToUpdate[i];\n    if (label.isDestroyed()) {\n      continue;\n    }\n\n    var preUpdateGlyphCount = label._glyphs.length;\n\n    if (label._rebindAllGlyphs) {\n      rebindAllGlyphs(this, label);\n      label._rebindAllGlyphs = false;\n    }\n\n    if (label._repositionAllGlyphs) {\n      repositionAllGlyphs(label);\n      label._repositionAllGlyphs = false;\n    }\n\n    var glyphCountDifference = label._glyphs.length - preUpdateGlyphCount;\n    this._totalGlyphCount += glyphCountDifference;\n  }\n\n  var blendOption =\n    backgroundBillboardCollection.length > 0\n      ? BlendOption.TRANSLUCENT\n      : this.blendOption;\n  billboardCollection.blendOption = blendOption;\n  backgroundBillboardCollection.blendOption = blendOption;\n\n  billboardCollection._highlightColor = this._highlightColor;\n  backgroundBillboardCollection._highlightColor = this._highlightColor;\n\n  this._labelsToUpdate.length = 0;\n  backgroundBillboardCollection.update(frameState);\n  billboardCollection.update(frameState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see LabelCollection#destroy\n */\nLabelCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * labels = labels && labels.destroy();\n *\n * @see LabelCollection#isDestroyed\n */\nLabelCollection.prototype.destroy = function () {\n  this.removeAll();\n  this._billboardCollection = this._billboardCollection.destroy();\n  this._textureAtlas = this._textureAtlas && this._textureAtlas.destroy();\n  this._backgroundBillboardCollection = this._backgroundBillboardCollection.destroy();\n  this._backgroundTextureAtlas =\n    this._backgroundTextureAtlas && this._backgroundTextureAtlas.destroy();\n\n  return destroyObject(this);\n};\nexport default LabelCollection;\n"]},"metadata":{},"sourceType":"module"}