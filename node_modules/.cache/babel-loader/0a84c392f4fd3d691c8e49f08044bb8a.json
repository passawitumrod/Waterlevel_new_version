{"ast":null,"code":"import arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingRectangle from \"./BoundingRectangle.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CoplanarPolygonGeometryLibrary from \"./CoplanarPolygonGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolygonGeometryLibrary from \"./PolygonGeometryLibrary.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nvar scratchPosition = new Cartesian3();\nvar scratchBR = new BoundingRectangle();\nvar stScratch = new Cartesian2();\nvar textureCoordinatesOrigin = new Cartesian2();\nvar scratchNormal = new Cartesian3();\nvar scratchTangent = new Cartesian3();\nvar scratchBitangent = new Cartesian3();\nvar centerScratch = new Cartesian3();\nvar axis1Scratch = new Cartesian3();\nvar axis2Scratch = new Cartesian3();\nvar quaternionScratch = new Quaternion();\nvar textureMatrixScratch = new Matrix3();\nvar tangentRotationScratch = new Matrix3();\nvar surfaceNormalScratch = new Cartesian3();\n\nfunction createGeometryFromPolygon(polygon, vertexFormat, boundingRectangle, stRotation, projectPointTo2D, normal, tangent, bitangent) {\n  var positions = polygon.positions;\n  var indices = PolygonPipeline.triangulate(polygon.positions2D, polygon.holes);\n  /* If polygon is completely unrenderable, just use the first three vertices */\n\n  if (indices.length < 3) {\n    indices = [0, 1, 2];\n  }\n\n  var newIndices = IndexDatatype.createTypedArray(positions.length, indices.length);\n  newIndices.set(indices);\n  var textureMatrix = textureMatrixScratch;\n\n  if (stRotation !== 0.0) {\n    var rotation = Quaternion.fromAxisAngle(normal, stRotation, quaternionScratch);\n    textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n\n    if (vertexFormat.tangent || vertexFormat.bitangent) {\n      rotation = Quaternion.fromAxisAngle(normal, -stRotation, quaternionScratch);\n      var tangentRotation = Matrix3.fromQuaternion(rotation, tangentRotationScratch);\n      tangent = Cartesian3.normalize(Matrix3.multiplyByVector(tangentRotation, tangent, tangent), tangent);\n\n      if (vertexFormat.bitangent) {\n        bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n      }\n    }\n  } else {\n    textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n  }\n\n  var stOrigin = textureCoordinatesOrigin;\n\n  if (vertexFormat.st) {\n    stOrigin.x = boundingRectangle.x;\n    stOrigin.y = boundingRectangle.y;\n  }\n\n  var length = positions.length;\n  var size = length * 3;\n  var flatPositions = new Float64Array(size);\n  var normals = vertexFormat.normal ? new Float32Array(size) : undefined;\n  var tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;\n  var bitangents = vertexFormat.bitangent ? new Float32Array(size) : undefined;\n  var textureCoordinates = vertexFormat.st ? new Float32Array(length * 2) : undefined;\n  var positionIndex = 0;\n  var normalIndex = 0;\n  var bitangentIndex = 0;\n  var tangentIndex = 0;\n  var stIndex = 0;\n\n  for (var i = 0; i < length; i++) {\n    var position = positions[i];\n    flatPositions[positionIndex++] = position.x;\n    flatPositions[positionIndex++] = position.y;\n    flatPositions[positionIndex++] = position.z;\n\n    if (vertexFormat.st) {\n      var p = Matrix3.multiplyByVector(textureMatrix, position, scratchPosition);\n      var st = projectPointTo2D(p, stScratch);\n      Cartesian2.subtract(st, stOrigin, st);\n      var stx = CesiumMath.clamp(st.x / boundingRectangle.width, 0, 1);\n      var sty = CesiumMath.clamp(st.y / boundingRectangle.height, 0, 1);\n      textureCoordinates[stIndex++] = stx;\n      textureCoordinates[stIndex++] = sty;\n    }\n\n    if (vertexFormat.normal) {\n      normals[normalIndex++] = normal.x;\n      normals[normalIndex++] = normal.y;\n      normals[normalIndex++] = normal.z;\n    }\n\n    if (vertexFormat.tangent) {\n      tangents[tangentIndex++] = tangent.x;\n      tangents[tangentIndex++] = tangent.y;\n      tangents[tangentIndex++] = tangent.z;\n    }\n\n    if (vertexFormat.bitangent) {\n      bitangents[bitangentIndex++] = bitangent.x;\n      bitangents[bitangentIndex++] = bitangent.y;\n      bitangents[bitangentIndex++] = bitangent.z;\n    }\n  }\n\n  var attributes = new GeometryAttributes();\n\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: flatPositions\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents\n    });\n  }\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: textureCoordinates\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: newIndices,\n    primitiveType: PrimitiveType.TRIANGLES\n  });\n}\n/**\n * A description of a polygon composed of arbitrary coplanar positions.\n *\n * @alias CoplanarPolygonGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n *\n * @example\n * var polygon = new Cesium.CoplanarPolygonGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n *      -90.0, 30.0, 0.0,\n *      -90.0, 30.0, 1000.0,\n *      -80.0, 30.0, 1000.0,\n *      -80.0, 30.0, 0.0\n *   ])\n * });\n * var geometry = Cesium.CoplanarPolygonGeometry.createGeometry(polygon);\n *\n * @see CoplanarPolygonGeometry.createGeometry\n */\n\n\nfunction CoplanarPolygonGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var polygonHierarchy = options.polygonHierarchy; //>>includeStart('debug', pragmas.debug);\n\n  Check.defined(\"options.polygonHierarchy\", polygonHierarchy); //>>includeEnd('debug');\n\n  var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._polygonHierarchy = polygonHierarchy;\n  this._stRotation = defaultValue(options.stRotation, 0.0);\n  this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n  this._workerName = \"createCoplanarPolygonGeometry\";\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n\n  this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + VertexFormat.packedLength + Ellipsoid.packedLength + 2;\n}\n/**\n * A description of a coplanar polygon from an array of positions.\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @returns {CoplanarPolygonGeometry}\n *\n * @example\n * // create a polygon from points\n * var polygon = Cesium.CoplanarPolygonGeometry.fromPositions({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0,\n *     -75.0, 30.0,\n *     -70.0, 30.0,\n *     -68.0, 40.0\n *   ])\n * });\n * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n *\n * @see PolygonGeometry#createGeometry\n */\n\n\nCoplanarPolygonGeometry.fromPositions = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);\n\n  Check.defined(\"options.positions\", options.positions); //>>includeEnd('debug');\n\n  var newOptions = {\n    polygonHierarchy: {\n      positions: options.positions\n    },\n    vertexFormat: options.vertexFormat,\n    stRotation: options.stRotation,\n    ellipsoid: options.ellipsoid\n  };\n  return new CoplanarPolygonGeometry(newOptions);\n};\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CoplanarPolygonGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\n\nCoplanarPolygonGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n  array[startingIndex++] = value._stRotation;\n  array[startingIndex] = value.packedLength;\n  return array;\n};\n\nvar scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nvar scratchVertexFormat = new VertexFormat();\nvar scratchOptions = {\n  polygonHierarchy: {}\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CoplanarPolygonGeometry} [result] The object into which to store the result.\n * @returns {CoplanarPolygonGeometry} The modified result parameter or a new CoplanarPolygonGeometry instance if one was not provided.\n */\n\nCoplanarPolygonGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);\n  startingIndex = polygonHierarchy.startingIndex;\n  delete polygonHierarchy.startingIndex;\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n  var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n  startingIndex += VertexFormat.packedLength;\n  var stRotation = array[startingIndex++];\n  var packedLength = array[startingIndex];\n\n  if (!defined(result)) {\n    result = new CoplanarPolygonGeometry(scratchOptions);\n  }\n\n  result._polygonHierarchy = polygonHierarchy;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._stRotation = stRotation;\n  result.packedLength = packedLength;\n  return result;\n};\n/**\n * Computes the geometric representation of an arbitrary coplanar polygon, including its vertices, indices, and a bounding sphere.\n *\n * @param {CoplanarPolygonGeometry} polygonGeometry A description of the polygon.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\n\n\nCoplanarPolygonGeometry.createGeometry = function (polygonGeometry) {\n  var vertexFormat = polygonGeometry._vertexFormat;\n  var polygonHierarchy = polygonGeometry._polygonHierarchy;\n  var stRotation = polygonGeometry._stRotation;\n  var outerPositions = polygonHierarchy.positions;\n  outerPositions = arrayRemoveDuplicates(outerPositions, Cartesian3.equalsEpsilon, true);\n\n  if (outerPositions.length < 3) {\n    return;\n  }\n\n  var normal = scratchNormal;\n  var tangent = scratchTangent;\n  var bitangent = scratchBitangent;\n  var axis1 = axis1Scratch;\n  var axis2 = axis2Scratch;\n  var validGeometry = CoplanarPolygonGeometryLibrary.computeProjectTo2DArguments(outerPositions, centerScratch, axis1, axis2);\n\n  if (!validGeometry) {\n    return undefined;\n  }\n\n  normal = Cartesian3.cross(axis1, axis2, normal);\n  normal = Cartesian3.normalize(normal, normal);\n\n  if (!Cartesian3.equalsEpsilon(centerScratch, Cartesian3.ZERO, CesiumMath.EPSILON6)) {\n    var surfaceNormal = polygonGeometry._ellipsoid.geodeticSurfaceNormal(centerScratch, surfaceNormalScratch);\n\n    if (Cartesian3.dot(normal, surfaceNormal) < 0) {\n      normal = Cartesian3.negate(normal, normal);\n      axis1 = Cartesian3.negate(axis1, axis1);\n    }\n  }\n\n  var projectPoints = CoplanarPolygonGeometryLibrary.createProjectPointsTo2DFunction(centerScratch, axis1, axis2);\n  var projectPoint = CoplanarPolygonGeometryLibrary.createProjectPointTo2DFunction(centerScratch, axis1, axis2);\n\n  if (vertexFormat.tangent) {\n    tangent = Cartesian3.clone(axis1, tangent);\n  }\n\n  if (vertexFormat.bitangent) {\n    bitangent = Cartesian3.clone(axis2, bitangent);\n  }\n\n  var results = PolygonGeometryLibrary.polygonsFromHierarchy(polygonHierarchy, projectPoints, false);\n  var hierarchy = results.hierarchy;\n  var polygons = results.polygons;\n\n  if (hierarchy.length === 0) {\n    return;\n  }\n\n  outerPositions = hierarchy[0].outerRing;\n  var boundingSphere = BoundingSphere.fromPoints(outerPositions);\n  var boundingRectangle = PolygonGeometryLibrary.computeBoundingRectangle(normal, projectPoint, outerPositions, stRotation, scratchBR);\n  var geometries = [];\n\n  for (var i = 0; i < polygons.length; i++) {\n    var geometryInstance = new GeometryInstance({\n      geometry: createGeometryFromPolygon(polygons[i], vertexFormat, boundingRectangle, stRotation, projectPoint, normal, tangent, bitangent)\n    });\n    geometries.push(geometryInstance);\n  }\n\n  var geometry = GeometryPipeline.combineInstances(geometries)[0];\n  geometry.attributes.position.values = new Float64Array(geometry.attributes.position.values);\n  geometry.indices = IndexDatatype.createTypedArray(geometry.attributes.position.values.length / 3, geometry.indices);\n  var attributes = geometry.attributes;\n\n  if (!vertexFormat.position) {\n    delete attributes.position;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: geometry.indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: boundingSphere\n  });\n};\n\nexport default CoplanarPolygonGeometry;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/CoplanarPolygonGeometry.js"],"names":["arrayRemoveDuplicates","BoundingRectangle","BoundingSphere","Cartesian2","Cartesian3","Check","ComponentDatatype","CoplanarPolygonGeometryLibrary","defaultValue","defined","Ellipsoid","Geometry","GeometryAttribute","GeometryAttributes","GeometryInstance","GeometryPipeline","IndexDatatype","CesiumMath","Matrix3","PolygonGeometryLibrary","PolygonPipeline","PrimitiveType","Quaternion","VertexFormat","scratchPosition","scratchBR","stScratch","textureCoordinatesOrigin","scratchNormal","scratchTangent","scratchBitangent","centerScratch","axis1Scratch","axis2Scratch","quaternionScratch","textureMatrixScratch","tangentRotationScratch","surfaceNormalScratch","createGeometryFromPolygon","polygon","vertexFormat","boundingRectangle","stRotation","projectPointTo2D","normal","tangent","bitangent","positions","indices","triangulate","positions2D","holes","length","newIndices","createTypedArray","set","textureMatrix","rotation","fromAxisAngle","fromQuaternion","tangentRotation","normalize","multiplyByVector","cross","clone","IDENTITY","stOrigin","st","x","y","size","flatPositions","Float64Array","normals","Float32Array","undefined","tangents","bitangents","textureCoordinates","positionIndex","normalIndex","bitangentIndex","tangentIndex","stIndex","i","position","z","p","subtract","stx","clamp","width","sty","height","attributes","componentDatatype","DOUBLE","componentsPerAttribute","values","FLOAT","primitiveType","TRIANGLES","CoplanarPolygonGeometry","options","EMPTY_OBJECT","polygonHierarchy","DEFAULT","_vertexFormat","_polygonHierarchy","_stRotation","_ellipsoid","ellipsoid","WGS84","_workerName","packedLength","computeHierarchyPackedLength","fromPositions","newOptions","pack","value","array","startingIndex","typeOf","object","packPolygonHierarchy","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","scratchOptions","unpack","result","unpackPolygonHierarchy","createGeometry","polygonGeometry","outerPositions","equalsEpsilon","axis1","axis2","validGeometry","computeProjectTo2DArguments","ZERO","EPSILON6","surfaceNormal","geodeticSurfaceNormal","dot","negate","projectPoints","createProjectPointsTo2DFunction","projectPoint","createProjectPointTo2DFunction","results","polygonsFromHierarchy","hierarchy","polygons","outerRing","boundingSphere","fromPoints","computeBoundingRectangle","geometries","geometryInstance","geometry","push","combineInstances"],"mappings":"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","sourcesContent":["import arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingRectangle from \"./BoundingRectangle.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CoplanarPolygonGeometryLibrary from \"./CoplanarPolygonGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolygonGeometryLibrary from \"./PolygonGeometryLibrary.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nvar scratchPosition = new Cartesian3();\nvar scratchBR = new BoundingRectangle();\nvar stScratch = new Cartesian2();\nvar textureCoordinatesOrigin = new Cartesian2();\nvar scratchNormal = new Cartesian3();\nvar scratchTangent = new Cartesian3();\nvar scratchBitangent = new Cartesian3();\nvar centerScratch = new Cartesian3();\nvar axis1Scratch = new Cartesian3();\nvar axis2Scratch = new Cartesian3();\nvar quaternionScratch = new Quaternion();\nvar textureMatrixScratch = new Matrix3();\nvar tangentRotationScratch = new Matrix3();\nvar surfaceNormalScratch = new Cartesian3();\n\nfunction createGeometryFromPolygon(\n  polygon,\n  vertexFormat,\n  boundingRectangle,\n  stRotation,\n  projectPointTo2D,\n  normal,\n  tangent,\n  bitangent\n) {\n  var positions = polygon.positions;\n  var indices = PolygonPipeline.triangulate(polygon.positions2D, polygon.holes);\n\n  /* If polygon is completely unrenderable, just use the first three vertices */\n  if (indices.length < 3) {\n    indices = [0, 1, 2];\n  }\n\n  var newIndices = IndexDatatype.createTypedArray(\n    positions.length,\n    indices.length\n  );\n  newIndices.set(indices);\n\n  var textureMatrix = textureMatrixScratch;\n  if (stRotation !== 0.0) {\n    var rotation = Quaternion.fromAxisAngle(\n      normal,\n      stRotation,\n      quaternionScratch\n    );\n    textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n\n    if (vertexFormat.tangent || vertexFormat.bitangent) {\n      rotation = Quaternion.fromAxisAngle(\n        normal,\n        -stRotation,\n        quaternionScratch\n      );\n      var tangentRotation = Matrix3.fromQuaternion(\n        rotation,\n        tangentRotationScratch\n      );\n\n      tangent = Cartesian3.normalize(\n        Matrix3.multiplyByVector(tangentRotation, tangent, tangent),\n        tangent\n      );\n      if (vertexFormat.bitangent) {\n        bitangent = Cartesian3.normalize(\n          Cartesian3.cross(normal, tangent, bitangent),\n          bitangent\n        );\n      }\n    }\n  } else {\n    textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n  }\n\n  var stOrigin = textureCoordinatesOrigin;\n  if (vertexFormat.st) {\n    stOrigin.x = boundingRectangle.x;\n    stOrigin.y = boundingRectangle.y;\n  }\n\n  var length = positions.length;\n  var size = length * 3;\n  var flatPositions = new Float64Array(size);\n  var normals = vertexFormat.normal ? new Float32Array(size) : undefined;\n  var tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;\n  var bitangents = vertexFormat.bitangent ? new Float32Array(size) : undefined;\n  var textureCoordinates = vertexFormat.st\n    ? new Float32Array(length * 2)\n    : undefined;\n\n  var positionIndex = 0;\n  var normalIndex = 0;\n  var bitangentIndex = 0;\n  var tangentIndex = 0;\n  var stIndex = 0;\n\n  for (var i = 0; i < length; i++) {\n    var position = positions[i];\n    flatPositions[positionIndex++] = position.x;\n    flatPositions[positionIndex++] = position.y;\n    flatPositions[positionIndex++] = position.z;\n\n    if (vertexFormat.st) {\n      var p = Matrix3.multiplyByVector(\n        textureMatrix,\n        position,\n        scratchPosition\n      );\n      var st = projectPointTo2D(p, stScratch);\n      Cartesian2.subtract(st, stOrigin, st);\n\n      var stx = CesiumMath.clamp(st.x / boundingRectangle.width, 0, 1);\n      var sty = CesiumMath.clamp(st.y / boundingRectangle.height, 0, 1);\n      textureCoordinates[stIndex++] = stx;\n      textureCoordinates[stIndex++] = sty;\n    }\n\n    if (vertexFormat.normal) {\n      normals[normalIndex++] = normal.x;\n      normals[normalIndex++] = normal.y;\n      normals[normalIndex++] = normal.z;\n    }\n\n    if (vertexFormat.tangent) {\n      tangents[tangentIndex++] = tangent.x;\n      tangents[tangentIndex++] = tangent.y;\n      tangents[tangentIndex++] = tangent.z;\n    }\n\n    if (vertexFormat.bitangent) {\n      bitangents[bitangentIndex++] = bitangent.x;\n      bitangents[bitangentIndex++] = bitangent.y;\n      bitangents[bitangentIndex++] = bitangent.z;\n    }\n  }\n\n  var attributes = new GeometryAttributes();\n\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: flatPositions,\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents,\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents,\n    });\n  }\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: textureCoordinates,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: newIndices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  });\n}\n\n/**\n * A description of a polygon composed of arbitrary coplanar positions.\n *\n * @alias CoplanarPolygonGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n *\n * @example\n * var polygon = new Cesium.CoplanarPolygonGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n *      -90.0, 30.0, 0.0,\n *      -90.0, 30.0, 1000.0,\n *      -80.0, 30.0, 1000.0,\n *      -80.0, 30.0, 0.0\n *   ])\n * });\n * var geometry = Cesium.CoplanarPolygonGeometry.createGeometry(polygon);\n *\n * @see CoplanarPolygonGeometry.createGeometry\n */\nfunction CoplanarPolygonGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var polygonHierarchy = options.polygonHierarchy;\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.polygonHierarchy\", polygonHierarchy);\n  //>>includeEnd('debug');\n\n  var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._polygonHierarchy = polygonHierarchy;\n  this._stRotation = defaultValue(options.stRotation, 0.0);\n  this._ellipsoid = Ellipsoid.clone(\n    defaultValue(options.ellipsoid, Ellipsoid.WGS84)\n  );\n  this._workerName = \"createCoplanarPolygonGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  this.packedLength =\n    PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) +\n    VertexFormat.packedLength +\n    Ellipsoid.packedLength +\n    2;\n}\n\n/**\n * A description of a coplanar polygon from an array of positions.\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @returns {CoplanarPolygonGeometry}\n *\n * @example\n * // create a polygon from points\n * var polygon = Cesium.CoplanarPolygonGeometry.fromPositions({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0,\n *     -75.0, 30.0,\n *     -70.0, 30.0,\n *     -68.0, 40.0\n *   ])\n * });\n * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n *\n * @see PolygonGeometry#createGeometry\n */\nCoplanarPolygonGeometry.fromPositions = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", options.positions);\n  //>>includeEnd('debug');\n\n  var newOptions = {\n    polygonHierarchy: {\n      positions: options.positions,\n    },\n    vertexFormat: options.vertexFormat,\n    stRotation: options.stRotation,\n    ellipsoid: options.ellipsoid,\n  };\n  return new CoplanarPolygonGeometry(newOptions);\n};\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CoplanarPolygonGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCoplanarPolygonGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(\n    value._polygonHierarchy,\n    array,\n    startingIndex\n  );\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._stRotation;\n  array[startingIndex] = value.packedLength;\n\n  return array;\n};\n\nvar scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nvar scratchVertexFormat = new VertexFormat();\nvar scratchOptions = {\n  polygonHierarchy: {},\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CoplanarPolygonGeometry} [result] The object into which to store the result.\n * @returns {CoplanarPolygonGeometry} The modified result parameter or a new CoplanarPolygonGeometry instance if one was not provided.\n */\nCoplanarPolygonGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(\n    array,\n    startingIndex\n  );\n  startingIndex = polygonHierarchy.startingIndex;\n  delete polygonHierarchy.startingIndex;\n\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  var vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  var stRotation = array[startingIndex++];\n  var packedLength = array[startingIndex];\n\n  if (!defined(result)) {\n    result = new CoplanarPolygonGeometry(scratchOptions);\n  }\n\n  result._polygonHierarchy = polygonHierarchy;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._stRotation = stRotation;\n  result.packedLength = packedLength;\n  return result;\n};\n\n/**\n * Computes the geometric representation of an arbitrary coplanar polygon, including its vertices, indices, and a bounding sphere.\n *\n * @param {CoplanarPolygonGeometry} polygonGeometry A description of the polygon.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCoplanarPolygonGeometry.createGeometry = function (polygonGeometry) {\n  var vertexFormat = polygonGeometry._vertexFormat;\n  var polygonHierarchy = polygonGeometry._polygonHierarchy;\n  var stRotation = polygonGeometry._stRotation;\n\n  var outerPositions = polygonHierarchy.positions;\n  outerPositions = arrayRemoveDuplicates(\n    outerPositions,\n    Cartesian3.equalsEpsilon,\n    true\n  );\n  if (outerPositions.length < 3) {\n    return;\n  }\n\n  var normal = scratchNormal;\n  var tangent = scratchTangent;\n  var bitangent = scratchBitangent;\n  var axis1 = axis1Scratch;\n  var axis2 = axis2Scratch;\n\n  var validGeometry = CoplanarPolygonGeometryLibrary.computeProjectTo2DArguments(\n    outerPositions,\n    centerScratch,\n    axis1,\n    axis2\n  );\n  if (!validGeometry) {\n    return undefined;\n  }\n\n  normal = Cartesian3.cross(axis1, axis2, normal);\n  normal = Cartesian3.normalize(normal, normal);\n\n  if (\n    !Cartesian3.equalsEpsilon(\n      centerScratch,\n      Cartesian3.ZERO,\n      CesiumMath.EPSILON6\n    )\n  ) {\n    var surfaceNormal = polygonGeometry._ellipsoid.geodeticSurfaceNormal(\n      centerScratch,\n      surfaceNormalScratch\n    );\n    if (Cartesian3.dot(normal, surfaceNormal) < 0) {\n      normal = Cartesian3.negate(normal, normal);\n      axis1 = Cartesian3.negate(axis1, axis1);\n    }\n  }\n\n  var projectPoints = CoplanarPolygonGeometryLibrary.createProjectPointsTo2DFunction(\n    centerScratch,\n    axis1,\n    axis2\n  );\n  var projectPoint = CoplanarPolygonGeometryLibrary.createProjectPointTo2DFunction(\n    centerScratch,\n    axis1,\n    axis2\n  );\n\n  if (vertexFormat.tangent) {\n    tangent = Cartesian3.clone(axis1, tangent);\n  }\n  if (vertexFormat.bitangent) {\n    bitangent = Cartesian3.clone(axis2, bitangent);\n  }\n\n  var results = PolygonGeometryLibrary.polygonsFromHierarchy(\n    polygonHierarchy,\n    projectPoints,\n    false\n  );\n  var hierarchy = results.hierarchy;\n  var polygons = results.polygons;\n\n  if (hierarchy.length === 0) {\n    return;\n  }\n  outerPositions = hierarchy[0].outerRing;\n\n  var boundingSphere = BoundingSphere.fromPoints(outerPositions);\n  var boundingRectangle = PolygonGeometryLibrary.computeBoundingRectangle(\n    normal,\n    projectPoint,\n    outerPositions,\n    stRotation,\n    scratchBR\n  );\n\n  var geometries = [];\n  for (var i = 0; i < polygons.length; i++) {\n    var geometryInstance = new GeometryInstance({\n      geometry: createGeometryFromPolygon(\n        polygons[i],\n        vertexFormat,\n        boundingRectangle,\n        stRotation,\n        projectPoint,\n        normal,\n        tangent,\n        bitangent\n      ),\n    });\n\n    geometries.push(geometryInstance);\n  }\n\n  var geometry = GeometryPipeline.combineInstances(geometries)[0];\n  geometry.attributes.position.values = new Float64Array(\n    geometry.attributes.position.values\n  );\n  geometry.indices = IndexDatatype.createTypedArray(\n    geometry.attributes.position.values.length / 3,\n    geometry.indices\n  );\n\n  var attributes = geometry.attributes;\n  if (!vertexFormat.position) {\n    delete attributes.position;\n  }\n  return new Geometry({\n    attributes: attributes,\n    indices: geometry.indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: boundingSphere,\n  });\n};\nexport default CoplanarPolygonGeometry;\n"]},"metadata":{},"sourceType":"module"}