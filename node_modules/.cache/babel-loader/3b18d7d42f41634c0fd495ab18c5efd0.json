{"ast":null,"code":"import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CylinderGeometryLibrary from \"./CylinderGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nvar radiusScratch = new Cartesian2();\nvar normalScratch = new Cartesian3();\nvar bitangentScratch = new Cartesian3();\nvar tangentScratch = new Cartesian3();\nvar positionScratch = new Cartesian3();\n/**\n * A description of a cylinder.\n *\n * @alias CylinderGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number} options.length The length of the cylinder.\n * @param {Number} options.topRadius The radius of the top of the cylinder.\n * @param {Number} options.bottomRadius The radius of the bottom of the cylinder.\n * @param {Number} [options.slices=128] The number of edges around the perimeter of the cylinder.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @exception {DeveloperError} options.slices must be greater than or equal to 3.\n *\n * @see CylinderGeometry.createGeometry\n *\n * @example\n * // create cylinder geometry\n * var cylinder = new Cesium.CylinderGeometry({\n *     length: 200000,\n *     topRadius: 80000,\n *     bottomRadius: 200000,\n * });\n * var geometry = Cesium.CylinderGeometry.createGeometry(cylinder);\n */\n\nfunction CylinderGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var length = options.length;\n  var topRadius = options.topRadius;\n  var bottomRadius = options.bottomRadius;\n  var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n  var slices = defaultValue(options.slices, 128); //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(length)) {\n    throw new DeveloperError(\"options.length must be defined.\");\n  }\n\n  if (!defined(topRadius)) {\n    throw new DeveloperError(\"options.topRadius must be defined.\");\n  }\n\n  if (!defined(bottomRadius)) {\n    throw new DeveloperError(\"options.bottomRadius must be defined.\");\n  }\n\n  if (slices < 3) {\n    throw new DeveloperError(\"options.slices must be greater than or equal to 3.\");\n  }\n\n  if (defined(options.offsetAttribute) && options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n    throw new DeveloperError(\"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\");\n  } //>>includeEnd('debug');\n\n\n  this._length = length;\n  this._topRadius = topRadius;\n  this._bottomRadius = bottomRadius;\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._slices = slices;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createCylinderGeometry\";\n}\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\n\n\nCylinderGeometry.packedLength = VertexFormat.packedLength + 5;\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CylinderGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\nCylinderGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  } //>>includeEnd('debug');\n\n\n  startingIndex = defaultValue(startingIndex, 0);\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n  array[startingIndex++] = value._length;\n  array[startingIndex++] = value._topRadius;\n  array[startingIndex++] = value._bottomRadius;\n  array[startingIndex++] = value._slices;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n  return array;\n};\n\nvar scratchVertexFormat = new VertexFormat();\nvar scratchOptions = {\n  vertexFormat: scratchVertexFormat,\n  length: undefined,\n  topRadius: undefined,\n  bottomRadius: undefined,\n  slices: undefined,\n  offsetAttribute: undefined\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CylinderGeometry} [result] The object into which to store the result.\n * @returns {CylinderGeometry} The modified result parameter or a new CylinderGeometry instance if one was not provided.\n */\n\nCylinderGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  } //>>includeEnd('debug');\n\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n  startingIndex += VertexFormat.packedLength;\n  var length = array[startingIndex++];\n  var topRadius = array[startingIndex++];\n  var bottomRadius = array[startingIndex++];\n  var slices = array[startingIndex++];\n  var offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.length = length;\n    scratchOptions.topRadius = topRadius;\n    scratchOptions.bottomRadius = bottomRadius;\n    scratchOptions.slices = slices;\n    scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new CylinderGeometry(scratchOptions);\n  }\n\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._length = length;\n  result._topRadius = topRadius;\n  result._bottomRadius = bottomRadius;\n  result._slices = slices;\n  result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n  return result;\n};\n/**\n * Computes the geometric representation of a cylinder, including its vertices, indices, and a bounding sphere.\n *\n * @param {CylinderGeometry} cylinderGeometry A description of the cylinder.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\n\n\nCylinderGeometry.createGeometry = function (cylinderGeometry) {\n  var length = cylinderGeometry._length;\n  var topRadius = cylinderGeometry._topRadius;\n  var bottomRadius = cylinderGeometry._bottomRadius;\n  var vertexFormat = cylinderGeometry._vertexFormat;\n  var slices = cylinderGeometry._slices;\n\n  if (length <= 0 || topRadius < 0 || bottomRadius < 0 || topRadius === 0 && bottomRadius === 0) {\n    return;\n  }\n\n  var twoSlices = slices + slices;\n  var threeSlices = slices + twoSlices;\n  var numVertices = twoSlices + twoSlices;\n  var positions = CylinderGeometryLibrary.computePositions(length, topRadius, bottomRadius, slices, true);\n  var st = vertexFormat.st ? new Float32Array(numVertices * 2) : undefined;\n  var normals = vertexFormat.normal ? new Float32Array(numVertices * 3) : undefined;\n  var tangents = vertexFormat.tangent ? new Float32Array(numVertices * 3) : undefined;\n  var bitangents = vertexFormat.bitangent ? new Float32Array(numVertices * 3) : undefined;\n  var i;\n  var computeNormal = vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent;\n\n  if (computeNormal) {\n    var computeTangent = vertexFormat.tangent || vertexFormat.bitangent;\n    var normalIndex = 0;\n    var tangentIndex = 0;\n    var bitangentIndex = 0;\n    var theta = Math.atan2(bottomRadius - topRadius, length);\n    var normal = normalScratch;\n    normal.z = Math.sin(theta);\n    var normalScale = Math.cos(theta);\n    var tangent = tangentScratch;\n    var bitangent = bitangentScratch;\n\n    for (i = 0; i < slices; i++) {\n      var angle = i / slices * CesiumMath.TWO_PI;\n      var x = normalScale * Math.cos(angle);\n      var y = normalScale * Math.sin(angle);\n\n      if (computeNormal) {\n        normal.x = x;\n        normal.y = y;\n\n        if (computeTangent) {\n          tangent = Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent), tangent);\n        }\n\n        if (vertexFormat.normal) {\n          normals[normalIndex++] = normal.x;\n          normals[normalIndex++] = normal.y;\n          normals[normalIndex++] = normal.z;\n          normals[normalIndex++] = normal.x;\n          normals[normalIndex++] = normal.y;\n          normals[normalIndex++] = normal.z;\n        }\n\n        if (vertexFormat.tangent) {\n          tangents[tangentIndex++] = tangent.x;\n          tangents[tangentIndex++] = tangent.y;\n          tangents[tangentIndex++] = tangent.z;\n          tangents[tangentIndex++] = tangent.x;\n          tangents[tangentIndex++] = tangent.y;\n          tangents[tangentIndex++] = tangent.z;\n        }\n\n        if (vertexFormat.bitangent) {\n          bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n          bitangents[bitangentIndex++] = bitangent.x;\n          bitangents[bitangentIndex++] = bitangent.y;\n          bitangents[bitangentIndex++] = bitangent.z;\n          bitangents[bitangentIndex++] = bitangent.x;\n          bitangents[bitangentIndex++] = bitangent.y;\n          bitangents[bitangentIndex++] = bitangent.z;\n        }\n      }\n    }\n\n    for (i = 0; i < slices; i++) {\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = -1;\n      }\n\n      if (vertexFormat.tangent) {\n        tangents[tangentIndex++] = 1;\n        tangents[tangentIndex++] = 0;\n        tangents[tangentIndex++] = 0;\n      }\n\n      if (vertexFormat.bitangent) {\n        bitangents[bitangentIndex++] = 0;\n        bitangents[bitangentIndex++] = -1;\n        bitangents[bitangentIndex++] = 0;\n      }\n    }\n\n    for (i = 0; i < slices; i++) {\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = 1;\n      }\n\n      if (vertexFormat.tangent) {\n        tangents[tangentIndex++] = 1;\n        tangents[tangentIndex++] = 0;\n        tangents[tangentIndex++] = 0;\n      }\n\n      if (vertexFormat.bitangent) {\n        bitangents[bitangentIndex++] = 0;\n        bitangents[bitangentIndex++] = 1;\n        bitangents[bitangentIndex++] = 0;\n      }\n    }\n  }\n\n  var numIndices = 12 * slices - 12;\n  var indices = IndexDatatype.createTypedArray(numVertices, numIndices);\n  var index = 0;\n  var j = 0;\n\n  for (i = 0; i < slices - 1; i++) {\n    indices[index++] = j;\n    indices[index++] = j + 2;\n    indices[index++] = j + 3;\n    indices[index++] = j;\n    indices[index++] = j + 3;\n    indices[index++] = j + 1;\n    j += 2;\n  }\n\n  indices[index++] = twoSlices - 2;\n  indices[index++] = 0;\n  indices[index++] = 1;\n  indices[index++] = twoSlices - 2;\n  indices[index++] = 1;\n  indices[index++] = twoSlices - 1;\n\n  for (i = 1; i < slices - 1; i++) {\n    indices[index++] = twoSlices + i + 1;\n    indices[index++] = twoSlices + i;\n    indices[index++] = twoSlices;\n  }\n\n  for (i = 1; i < slices - 1; i++) {\n    indices[index++] = threeSlices;\n    indices[index++] = threeSlices + i;\n    indices[index++] = threeSlices + i + 1;\n  }\n\n  var textureCoordIndex = 0;\n\n  if (vertexFormat.st) {\n    var rad = Math.max(topRadius, bottomRadius);\n\n    for (i = 0; i < numVertices; i++) {\n      var position = Cartesian3.fromArray(positions, i * 3, positionScratch);\n      st[textureCoordIndex++] = (position.x + rad) / (2.0 * rad);\n      st[textureCoordIndex++] = (position.y + rad) / (2.0 * rad);\n    }\n  }\n\n  var attributes = new GeometryAttributes();\n\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents\n    });\n  }\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: st\n    });\n  }\n\n  radiusScratch.x = length * 0.5;\n  radiusScratch.y = Math.max(bottomRadius, topRadius);\n  var boundingSphere = new BoundingSphere(Cartesian3.ZERO, Cartesian2.magnitude(radiusScratch));\n\n  if (defined(cylinderGeometry._offsetAttribute)) {\n    length = positions.length;\n    var applyOffset = new Uint8Array(length / 3);\n    var offsetValue = cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n    arrayFill(applyOffset, offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: cylinderGeometry._offsetAttribute\n  });\n};\n\nvar unitCylinderGeometry;\n/**\n * Returns the geometric representation of a unit cylinder, including its vertices, indices, and a bounding sphere.\n * @returns {Geometry} The computed vertices and indices.\n *\n * @private\n */\n\nCylinderGeometry.getUnitCylinder = function () {\n  if (!defined(unitCylinderGeometry)) {\n    unitCylinderGeometry = CylinderGeometry.createGeometry(new CylinderGeometry({\n      topRadius: 1.0,\n      bottomRadius: 1.0,\n      length: 1.0,\n      vertexFormat: VertexFormat.POSITION_ONLY\n    }));\n  }\n\n  return unitCylinderGeometry;\n};\n\nexport default CylinderGeometry;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/CylinderGeometry.js"],"names":["arrayFill","BoundingSphere","Cartesian2","Cartesian3","ComponentDatatype","CylinderGeometryLibrary","defaultValue","defined","DeveloperError","Geometry","GeometryAttribute","GeometryAttributes","GeometryOffsetAttribute","IndexDatatype","CesiumMath","PrimitiveType","VertexFormat","radiusScratch","normalScratch","bitangentScratch","tangentScratch","positionScratch","CylinderGeometry","options","EMPTY_OBJECT","length","topRadius","bottomRadius","vertexFormat","DEFAULT","slices","offsetAttribute","TOP","_length","_topRadius","_bottomRadius","_vertexFormat","clone","_slices","_offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","scratchVertexFormat","scratchOptions","undefined","unpack","result","createGeometry","cylinderGeometry","twoSlices","threeSlices","numVertices","positions","computePositions","st","Float32Array","normals","normal","tangents","tangent","bitangents","bitangent","i","computeNormal","computeTangent","normalIndex","tangentIndex","bitangentIndex","theta","Math","atan2","z","sin","normalScale","cos","angle","TWO_PI","x","y","normalize","cross","UNIT_Z","numIndices","indices","createTypedArray","index","j","textureCoordIndex","rad","max","position","fromArray","attributes","componentDatatype","DOUBLE","componentsPerAttribute","values","FLOAT","boundingSphere","ZERO","magnitude","applyOffset","Uint8Array","offsetValue","NONE","UNSIGNED_BYTE","primitiveType","TRIANGLES","unitCylinderGeometry","getUnitCylinder","POSITION_ONLY"],"mappings":"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","sourcesContent":["import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CylinderGeometryLibrary from \"./CylinderGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nvar radiusScratch = new Cartesian2();\nvar normalScratch = new Cartesian3();\nvar bitangentScratch = new Cartesian3();\nvar tangentScratch = new Cartesian3();\nvar positionScratch = new Cartesian3();\n\n/**\n * A description of a cylinder.\n *\n * @alias CylinderGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number} options.length The length of the cylinder.\n * @param {Number} options.topRadius The radius of the top of the cylinder.\n * @param {Number} options.bottomRadius The radius of the bottom of the cylinder.\n * @param {Number} [options.slices=128] The number of edges around the perimeter of the cylinder.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @exception {DeveloperError} options.slices must be greater than or equal to 3.\n *\n * @see CylinderGeometry.createGeometry\n *\n * @example\n * // create cylinder geometry\n * var cylinder = new Cesium.CylinderGeometry({\n *     length: 200000,\n *     topRadius: 80000,\n *     bottomRadius: 200000,\n * });\n * var geometry = Cesium.CylinderGeometry.createGeometry(cylinder);\n */\nfunction CylinderGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var length = options.length;\n  var topRadius = options.topRadius;\n  var bottomRadius = options.bottomRadius;\n  var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n  var slices = defaultValue(options.slices, 128);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(length)) {\n    throw new DeveloperError(\"options.length must be defined.\");\n  }\n  if (!defined(topRadius)) {\n    throw new DeveloperError(\"options.topRadius must be defined.\");\n  }\n  if (!defined(bottomRadius)) {\n    throw new DeveloperError(\"options.bottomRadius must be defined.\");\n  }\n  if (slices < 3) {\n    throw new DeveloperError(\n      \"options.slices must be greater than or equal to 3.\"\n    );\n  }\n  if (\n    defined(options.offsetAttribute) &&\n    options.offsetAttribute === GeometryOffsetAttribute.TOP\n  ) {\n    throw new DeveloperError(\n      \"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._length = length;\n  this._topRadius = topRadius;\n  this._bottomRadius = bottomRadius;\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._slices = slices;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createCylinderGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nCylinderGeometry.packedLength = VertexFormat.packedLength + 5;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CylinderGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCylinderGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._length;\n  array[startingIndex++] = value._topRadius;\n  array[startingIndex++] = value._bottomRadius;\n  array[startingIndex++] = value._slices;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nvar scratchVertexFormat = new VertexFormat();\nvar scratchOptions = {\n  vertexFormat: scratchVertexFormat,\n  length: undefined,\n  topRadius: undefined,\n  bottomRadius: undefined,\n  slices: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CylinderGeometry} [result] The object into which to store the result.\n * @returns {CylinderGeometry} The modified result parameter or a new CylinderGeometry instance if one was not provided.\n */\nCylinderGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  var length = array[startingIndex++];\n  var topRadius = array[startingIndex++];\n  var bottomRadius = array[startingIndex++];\n  var slices = array[startingIndex++];\n  var offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.length = length;\n    scratchOptions.topRadius = topRadius;\n    scratchOptions.bottomRadius = bottomRadius;\n    scratchOptions.slices = slices;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new CylinderGeometry(scratchOptions);\n  }\n\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._length = length;\n  result._topRadius = topRadius;\n  result._bottomRadius = bottomRadius;\n  result._slices = slices;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of a cylinder, including its vertices, indices, and a bounding sphere.\n *\n * @param {CylinderGeometry} cylinderGeometry A description of the cylinder.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCylinderGeometry.createGeometry = function (cylinderGeometry) {\n  var length = cylinderGeometry._length;\n  var topRadius = cylinderGeometry._topRadius;\n  var bottomRadius = cylinderGeometry._bottomRadius;\n  var vertexFormat = cylinderGeometry._vertexFormat;\n  var slices = cylinderGeometry._slices;\n\n  if (\n    length <= 0 ||\n    topRadius < 0 ||\n    bottomRadius < 0 ||\n    (topRadius === 0 && bottomRadius === 0)\n  ) {\n    return;\n  }\n\n  var twoSlices = slices + slices;\n  var threeSlices = slices + twoSlices;\n  var numVertices = twoSlices + twoSlices;\n\n  var positions = CylinderGeometryLibrary.computePositions(\n    length,\n    topRadius,\n    bottomRadius,\n    slices,\n    true\n  );\n\n  var st = vertexFormat.st ? new Float32Array(numVertices * 2) : undefined;\n  var normals = vertexFormat.normal\n    ? new Float32Array(numVertices * 3)\n    : undefined;\n  var tangents = vertexFormat.tangent\n    ? new Float32Array(numVertices * 3)\n    : undefined;\n  var bitangents = vertexFormat.bitangent\n    ? new Float32Array(numVertices * 3)\n    : undefined;\n\n  var i;\n  var computeNormal =\n    vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent;\n\n  if (computeNormal) {\n    var computeTangent = vertexFormat.tangent || vertexFormat.bitangent;\n\n    var normalIndex = 0;\n    var tangentIndex = 0;\n    var bitangentIndex = 0;\n\n    var theta = Math.atan2(bottomRadius - topRadius, length);\n    var normal = normalScratch;\n    normal.z = Math.sin(theta);\n    var normalScale = Math.cos(theta);\n    var tangent = tangentScratch;\n    var bitangent = bitangentScratch;\n\n    for (i = 0; i < slices; i++) {\n      var angle = (i / slices) * CesiumMath.TWO_PI;\n      var x = normalScale * Math.cos(angle);\n      var y = normalScale * Math.sin(angle);\n      if (computeNormal) {\n        normal.x = x;\n        normal.y = y;\n\n        if (computeTangent) {\n          tangent = Cartesian3.normalize(\n            Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent),\n            tangent\n          );\n        }\n\n        if (vertexFormat.normal) {\n          normals[normalIndex++] = normal.x;\n          normals[normalIndex++] = normal.y;\n          normals[normalIndex++] = normal.z;\n          normals[normalIndex++] = normal.x;\n          normals[normalIndex++] = normal.y;\n          normals[normalIndex++] = normal.z;\n        }\n\n        if (vertexFormat.tangent) {\n          tangents[tangentIndex++] = tangent.x;\n          tangents[tangentIndex++] = tangent.y;\n          tangents[tangentIndex++] = tangent.z;\n          tangents[tangentIndex++] = tangent.x;\n          tangents[tangentIndex++] = tangent.y;\n          tangents[tangentIndex++] = tangent.z;\n        }\n\n        if (vertexFormat.bitangent) {\n          bitangent = Cartesian3.normalize(\n            Cartesian3.cross(normal, tangent, bitangent),\n            bitangent\n          );\n          bitangents[bitangentIndex++] = bitangent.x;\n          bitangents[bitangentIndex++] = bitangent.y;\n          bitangents[bitangentIndex++] = bitangent.z;\n          bitangents[bitangentIndex++] = bitangent.x;\n          bitangents[bitangentIndex++] = bitangent.y;\n          bitangents[bitangentIndex++] = bitangent.z;\n        }\n      }\n    }\n\n    for (i = 0; i < slices; i++) {\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = -1;\n      }\n      if (vertexFormat.tangent) {\n        tangents[tangentIndex++] = 1;\n        tangents[tangentIndex++] = 0;\n        tangents[tangentIndex++] = 0;\n      }\n      if (vertexFormat.bitangent) {\n        bitangents[bitangentIndex++] = 0;\n        bitangents[bitangentIndex++] = -1;\n        bitangents[bitangentIndex++] = 0;\n      }\n    }\n\n    for (i = 0; i < slices; i++) {\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = 1;\n      }\n      if (vertexFormat.tangent) {\n        tangents[tangentIndex++] = 1;\n        tangents[tangentIndex++] = 0;\n        tangents[tangentIndex++] = 0;\n      }\n      if (vertexFormat.bitangent) {\n        bitangents[bitangentIndex++] = 0;\n        bitangents[bitangentIndex++] = 1;\n        bitangents[bitangentIndex++] = 0;\n      }\n    }\n  }\n\n  var numIndices = 12 * slices - 12;\n  var indices = IndexDatatype.createTypedArray(numVertices, numIndices);\n  var index = 0;\n  var j = 0;\n  for (i = 0; i < slices - 1; i++) {\n    indices[index++] = j;\n    indices[index++] = j + 2;\n    indices[index++] = j + 3;\n\n    indices[index++] = j;\n    indices[index++] = j + 3;\n    indices[index++] = j + 1;\n\n    j += 2;\n  }\n\n  indices[index++] = twoSlices - 2;\n  indices[index++] = 0;\n  indices[index++] = 1;\n  indices[index++] = twoSlices - 2;\n  indices[index++] = 1;\n  indices[index++] = twoSlices - 1;\n\n  for (i = 1; i < slices - 1; i++) {\n    indices[index++] = twoSlices + i + 1;\n    indices[index++] = twoSlices + i;\n    indices[index++] = twoSlices;\n  }\n\n  for (i = 1; i < slices - 1; i++) {\n    indices[index++] = threeSlices;\n    indices[index++] = threeSlices + i;\n    indices[index++] = threeSlices + i + 1;\n  }\n\n  var textureCoordIndex = 0;\n  if (vertexFormat.st) {\n    var rad = Math.max(topRadius, bottomRadius);\n    for (i = 0; i < numVertices; i++) {\n      var position = Cartesian3.fromArray(positions, i * 3, positionScratch);\n      st[textureCoordIndex++] = (position.x + rad) / (2.0 * rad);\n      st[textureCoordIndex++] = (position.y + rad) / (2.0 * rad);\n    }\n  }\n\n  var attributes = new GeometryAttributes();\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents,\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents,\n    });\n  }\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: st,\n    });\n  }\n\n  radiusScratch.x = length * 0.5;\n  radiusScratch.y = Math.max(bottomRadius, topRadius);\n\n  var boundingSphere = new BoundingSphere(\n    Cartesian3.ZERO,\n    Cartesian2.magnitude(radiusScratch)\n  );\n\n  if (defined(cylinderGeometry._offsetAttribute)) {\n    length = positions.length;\n    var applyOffset = new Uint8Array(length / 3);\n    var offsetValue =\n      cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n        ? 0\n        : 1;\n    arrayFill(applyOffset, offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: cylinderGeometry._offsetAttribute,\n  });\n};\n\nvar unitCylinderGeometry;\n\n/**\n * Returns the geometric representation of a unit cylinder, including its vertices, indices, and a bounding sphere.\n * @returns {Geometry} The computed vertices and indices.\n *\n * @private\n */\nCylinderGeometry.getUnitCylinder = function () {\n  if (!defined(unitCylinderGeometry)) {\n    unitCylinderGeometry = CylinderGeometry.createGeometry(\n      new CylinderGeometry({\n        topRadius: 1.0,\n        bottomRadius: 1.0,\n        length: 1.0,\n        vertexFormat: VertexFormat.POSITION_ONLY,\n      })\n    );\n  }\n  return unitCylinderGeometry;\n};\nexport default CylinderGeometry;\n"]},"metadata":{},"sourceType":"module"}