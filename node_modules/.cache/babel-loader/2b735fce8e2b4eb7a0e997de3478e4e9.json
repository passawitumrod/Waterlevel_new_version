{"ast":null,"code":"import defined from \"../Core/defined.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\n/**\n * @private\n */\n\nfunction DerivedCommand() {}\n\nvar fragDepthRegex = /\\bgl_FragDepthEXT\\b/;\nvar discardRegex = /\\bdiscard\\b/;\n\nfunction getDepthOnlyShaderProgram(context, shaderProgram) {\n  var shader = context.shaderCache.getDerivedShaderProgram(shaderProgram, \"depthOnly\");\n\n  if (!defined(shader)) {\n    var attributeLocations = shaderProgram._attributeLocations;\n    var fs = shaderProgram.fragmentShaderSource;\n    var i;\n    var writesDepthOrDiscards = false;\n    var sources = fs.sources;\n    var length = sources.length;\n\n    for (i = 0; i < length; ++i) {\n      if (fragDepthRegex.test(sources[i]) || discardRegex.test(sources[i])) {\n        writesDepthOrDiscards = true;\n        break;\n      }\n    }\n\n    var usesLogDepth = false;\n    var defines = fs.defines;\n    length = defines.length;\n\n    for (i = 0; i < length; ++i) {\n      if (defines[i] === \"LOG_DEPTH\") {\n        usesLogDepth = true;\n        break;\n      }\n    }\n\n    var source;\n\n    if (!writesDepthOrDiscards && !usesLogDepth) {\n      source = \"void main() \\n\" + \"{ \\n\" + \"    gl_FragColor = vec4(1.0); \\n\" + \"} \\n\";\n      fs = new ShaderSource({\n        sources: [source]\n      });\n    } else if (!writesDepthOrDiscards && usesLogDepth) {\n      source = \"#ifdef GL_EXT_frag_depth \\n\" + \"#extension GL_EXT_frag_depth : enable \\n\" + \"#endif \\n\\n\" + \"void main() \\n\" + \"{ \\n\" + \"    gl_FragColor = vec4(1.0); \\n\" + \"    czm_writeLogDepth(); \\n\" + \"} \\n\";\n      fs = new ShaderSource({\n        defines: [\"LOG_DEPTH\"],\n        sources: [source]\n      });\n    }\n\n    shader = context.shaderCache.createDerivedShaderProgram(shaderProgram, \"depthOnly\", {\n      vertexShaderSource: shaderProgram.vertexShaderSource,\n      fragmentShaderSource: fs,\n      attributeLocations: attributeLocations\n    });\n  }\n\n  return shader;\n}\n\nfunction getDepthOnlyRenderState(scene, renderState) {\n  var cache = scene._depthOnlyRenderStateCache;\n  var depthOnlyState = cache[renderState.id];\n\n  if (!defined(depthOnlyState)) {\n    var rs = RenderState.getState(renderState);\n    rs.depthMask = true;\n    rs.colorMask = {\n      red: false,\n      green: false,\n      blue: false,\n      alpha: false\n    };\n    depthOnlyState = RenderState.fromCache(rs);\n    cache[renderState.id] = depthOnlyState;\n  }\n\n  return depthOnlyState;\n}\n\nDerivedCommand.createDepthOnlyDerivedCommand = function (scene, command, context, result) {\n  // For a depth only pass, we bind a framebuffer with only a depth attachment (no color attachments),\n  // do not write color, and write depth. If the fragment shader doesn't modify the fragment depth\n  // or discard, the driver can replace the fragment shader with a pass-through shader. We're unsure if this\n  // actually happens so we modify the shader to use a pass-through fragment shader.\n  if (!defined(result)) {\n    result = {};\n  }\n\n  var shader;\n  var renderState;\n\n  if (defined(result.depthOnlyCommand)) {\n    shader = result.depthOnlyCommand.shaderProgram;\n    renderState = result.depthOnlyCommand.renderState;\n  }\n\n  result.depthOnlyCommand = DrawCommand.shallowClone(command, result.depthOnlyCommand);\n\n  if (!defined(shader) || result.shaderProgramId !== command.shaderProgram.id) {\n    result.depthOnlyCommand.shaderProgram = getDepthOnlyShaderProgram(context, command.shaderProgram);\n    result.depthOnlyCommand.renderState = getDepthOnlyRenderState(scene, command.renderState);\n    result.shaderProgramId = command.shaderProgram.id;\n  } else {\n    result.depthOnlyCommand.shaderProgram = shader;\n    result.depthOnlyCommand.renderState = renderState;\n  }\n\n  return result;\n};\n\nvar writeLogDepthRegex = /\\s+czm_writeLogDepth\\(/;\nvar vertexlogDepthRegex = /\\s+czm_vertexLogDepth\\(/;\nvar extensionRegex = /\\s*#extension\\s+GL_EXT_frag_depth\\s*:\\s*enable/;\n\nfunction getLogDepthShaderProgram(context, shaderProgram) {\n  var shader = context.shaderCache.getDerivedShaderProgram(shaderProgram, \"logDepth\");\n\n  if (!defined(shader)) {\n    var attributeLocations = shaderProgram._attributeLocations;\n    var vs = shaderProgram.vertexShaderSource.clone();\n    var fs = shaderProgram.fragmentShaderSource.clone();\n    vs.defines = defined(vs.defines) ? vs.defines.slice(0) : [];\n    vs.defines.push(\"LOG_DEPTH\");\n    fs.defines = defined(fs.defines) ? fs.defines.slice(0) : [];\n    fs.defines.push(\"LOG_DEPTH\");\n    var i;\n    var logMain;\n    var writesLogDepth = false;\n    var sources = vs.sources;\n    var length = sources.length;\n\n    for (i = 0; i < length; ++i) {\n      if (vertexlogDepthRegex.test(sources[i])) {\n        writesLogDepth = true;\n        break;\n      }\n    }\n\n    if (!writesLogDepth) {\n      for (i = 0; i < length; ++i) {\n        sources[i] = ShaderSource.replaceMain(sources[i], \"czm_log_depth_main\");\n      }\n\n      logMain = \"\\n\\n\" + \"void main() \\n\" + \"{ \\n\" + \"    czm_log_depth_main(); \\n\" + \"    czm_vertexLogDepth(); \\n\" + \"} \\n\";\n      sources.push(logMain);\n    }\n\n    var addExtension = true;\n    writesLogDepth = false;\n    sources = fs.sources;\n    length = sources.length;\n\n    for (i = 0; i < length; ++i) {\n      if (writeLogDepthRegex.test(sources[i])) {\n        writesLogDepth = true;\n      }\n\n      if (extensionRegex.test(sources[i])) {\n        addExtension = false;\n      }\n    }\n\n    var logSource = \"\";\n\n    if (addExtension) {\n      logSource += \"#ifdef GL_EXT_frag_depth \\n\" + \"#extension GL_EXT_frag_depth : enable \\n\" + \"#endif \\n\\n\";\n    }\n\n    if (!writesLogDepth) {\n      for (i = 0; i < length; i++) {\n        sources[i] = ShaderSource.replaceMain(sources[i], \"czm_log_depth_main\");\n      }\n\n      logSource += \"\\n\" + \"void main() \\n\" + \"{ \\n\" + \"    czm_log_depth_main(); \\n\" + \"    czm_writeLogDepth(); \\n\" + \"} \\n\";\n    }\n\n    sources.push(logSource);\n    shader = context.shaderCache.createDerivedShaderProgram(shaderProgram, \"logDepth\", {\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n      attributeLocations: attributeLocations\n    });\n  }\n\n  return shader;\n}\n\nDerivedCommand.createLogDepthCommand = function (command, context, result) {\n  if (!defined(result)) {\n    result = {};\n  }\n\n  var shader;\n\n  if (defined(result.command)) {\n    shader = result.command.shaderProgram;\n  }\n\n  result.command = DrawCommand.shallowClone(command, result.command);\n\n  if (!defined(shader) || result.shaderProgramId !== command.shaderProgram.id) {\n    result.command.shaderProgram = getLogDepthShaderProgram(context, command.shaderProgram);\n    result.shaderProgramId = command.shaderProgram.id;\n  } else {\n    result.command.shaderProgram = shader;\n  }\n\n  return result;\n};\n\nfunction getPickShaderProgram(context, shaderProgram, pickId) {\n  var shader = context.shaderCache.getDerivedShaderProgram(shaderProgram, \"pick\");\n\n  if (!defined(shader)) {\n    var attributeLocations = shaderProgram._attributeLocations;\n    var fs = shaderProgram.fragmentShaderSource;\n    var sources = fs.sources;\n    var length = sources.length;\n    var newMain = \"void main() \\n\" + \"{ \\n\" + \"    czm_non_pick_main(); \\n\" + \"    if (gl_FragColor.a == 0.0) { \\n\" + \"        discard; \\n\" + \"    } \\n\" + \"    gl_FragColor = \" + pickId + \"; \\n\" + \"} \\n\";\n    var newSources = new Array(length + 1);\n\n    for (var i = 0; i < length; ++i) {\n      newSources[i] = ShaderSource.replaceMain(sources[i], \"czm_non_pick_main\");\n    }\n\n    newSources[length] = newMain;\n    fs = new ShaderSource({\n      sources: newSources,\n      defines: fs.defines\n    });\n    shader = context.shaderCache.createDerivedShaderProgram(shaderProgram, \"pick\", {\n      vertexShaderSource: shaderProgram.vertexShaderSource,\n      fragmentShaderSource: fs,\n      attributeLocations: attributeLocations\n    });\n  }\n\n  return shader;\n}\n\nfunction getPickRenderState(scene, renderState) {\n  var cache = scene.picking.pickRenderStateCache;\n  var pickState = cache[renderState.id];\n\n  if (!defined(pickState)) {\n    var rs = RenderState.getState(renderState);\n    rs.blending.enabled = false; // Turns on depth writing for opaque and translucent passes\n    // Overlapping translucent geometry on the globe surface may exhibit z-fighting\n    // during the pick pass which may not match the rendered scene. Once\n    // terrain is on by default and ground primitives are used instead\n    // this will become less of a problem.\n\n    rs.depthMask = true;\n    pickState = RenderState.fromCache(rs);\n    cache[renderState.id] = pickState;\n  }\n\n  return pickState;\n}\n\nDerivedCommand.createPickDerivedCommand = function (scene, command, context, result) {\n  if (!defined(result)) {\n    result = {};\n  }\n\n  var shader;\n  var renderState;\n\n  if (defined(result.pickCommand)) {\n    shader = result.pickCommand.shaderProgram;\n    renderState = result.pickCommand.renderState;\n  }\n\n  result.pickCommand = DrawCommand.shallowClone(command, result.pickCommand);\n\n  if (!defined(shader) || result.shaderProgramId !== command.shaderProgram.id) {\n    result.pickCommand.shaderProgram = getPickShaderProgram(context, command.shaderProgram, command.pickId);\n    result.pickCommand.renderState = getPickRenderState(scene, command.renderState);\n    result.shaderProgramId = command.shaderProgram.id;\n  } else {\n    result.pickCommand.shaderProgram = shader;\n    result.pickCommand.renderState = renderState;\n  }\n\n  return result;\n};\n\nfunction getHdrShaderProgram(context, shaderProgram) {\n  var shader = context.shaderCache.getDerivedShaderProgram(shaderProgram, \"HDR\");\n\n  if (!defined(shader)) {\n    var attributeLocations = shaderProgram._attributeLocations;\n    var vs = shaderProgram.vertexShaderSource.clone();\n    var fs = shaderProgram.fragmentShaderSource.clone();\n    vs.defines = defined(vs.defines) ? vs.defines.slice(0) : [];\n    vs.defines.push(\"HDR\");\n    fs.defines = defined(fs.defines) ? fs.defines.slice(0) : [];\n    fs.defines.push(\"HDR\");\n    shader = context.shaderCache.createDerivedShaderProgram(shaderProgram, \"HDR\", {\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n      attributeLocations: attributeLocations\n    });\n  }\n\n  return shader;\n}\n\nDerivedCommand.createHdrCommand = function (command, context, result) {\n  if (!defined(result)) {\n    result = {};\n  }\n\n  var shader;\n\n  if (defined(result.command)) {\n    shader = result.command.shaderProgram;\n  }\n\n  result.command = DrawCommand.shallowClone(command, result.command);\n\n  if (!defined(shader) || result.shaderProgramId !== command.shaderProgram.id) {\n    result.command.shaderProgram = getHdrShaderProgram(context, command.shaderProgram);\n    result.shaderProgramId = command.shaderProgram.id;\n  } else {\n    result.command.shaderProgram = shader;\n  }\n\n  return result;\n};\n\nexport default DerivedCommand;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/DerivedCommand.js"],"names":["defined","DrawCommand","RenderState","ShaderSource","DerivedCommand","fragDepthRegex","discardRegex","getDepthOnlyShaderProgram","context","shaderProgram","shader","shaderCache","getDerivedShaderProgram","attributeLocations","_attributeLocations","fs","fragmentShaderSource","i","writesDepthOrDiscards","sources","length","test","usesLogDepth","defines","source","createDerivedShaderProgram","vertexShaderSource","getDepthOnlyRenderState","scene","renderState","cache","_depthOnlyRenderStateCache","depthOnlyState","id","rs","getState","depthMask","colorMask","red","green","blue","alpha","fromCache","createDepthOnlyDerivedCommand","command","result","depthOnlyCommand","shallowClone","shaderProgramId","writeLogDepthRegex","vertexlogDepthRegex","extensionRegex","getLogDepthShaderProgram","vs","clone","slice","push","logMain","writesLogDepth","replaceMain","addExtension","logSource","createLogDepthCommand","getPickShaderProgram","pickId","newMain","newSources","Array","getPickRenderState","picking","pickRenderStateCache","pickState","blending","enabled","createPickDerivedCommand","pickCommand","getHdrShaderProgram","createHdrCommand"],"mappings":"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","sourcesContent":["import defined from \"../Core/defined.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\n\n/**\n * @private\n */\nfunction DerivedCommand() {}\n\nvar fragDepthRegex = /\\bgl_FragDepthEXT\\b/;\nvar discardRegex = /\\bdiscard\\b/;\n\nfunction getDepthOnlyShaderProgram(context, shaderProgram) {\n  var shader = context.shaderCache.getDerivedShaderProgram(\n    shaderProgram,\n    \"depthOnly\"\n  );\n  if (!defined(shader)) {\n    var attributeLocations = shaderProgram._attributeLocations;\n    var fs = shaderProgram.fragmentShaderSource;\n\n    var i;\n    var writesDepthOrDiscards = false;\n    var sources = fs.sources;\n    var length = sources.length;\n    for (i = 0; i < length; ++i) {\n      if (fragDepthRegex.test(sources[i]) || discardRegex.test(sources[i])) {\n        writesDepthOrDiscards = true;\n        break;\n      }\n    }\n\n    var usesLogDepth = false;\n    var defines = fs.defines;\n    length = defines.length;\n    for (i = 0; i < length; ++i) {\n      if (defines[i] === \"LOG_DEPTH\") {\n        usesLogDepth = true;\n        break;\n      }\n    }\n\n    var source;\n    if (!writesDepthOrDiscards && !usesLogDepth) {\n      source =\n        \"void main() \\n\" + \"{ \\n\" + \"    gl_FragColor = vec4(1.0); \\n\" + \"} \\n\";\n      fs = new ShaderSource({\n        sources: [source],\n      });\n    } else if (!writesDepthOrDiscards && usesLogDepth) {\n      source =\n        \"#ifdef GL_EXT_frag_depth \\n\" +\n        \"#extension GL_EXT_frag_depth : enable \\n\" +\n        \"#endif \\n\\n\" +\n        \"void main() \\n\" +\n        \"{ \\n\" +\n        \"    gl_FragColor = vec4(1.0); \\n\" +\n        \"    czm_writeLogDepth(); \\n\" +\n        \"} \\n\";\n      fs = new ShaderSource({\n        defines: [\"LOG_DEPTH\"],\n        sources: [source],\n      });\n    }\n\n    shader = context.shaderCache.createDerivedShaderProgram(\n      shaderProgram,\n      \"depthOnly\",\n      {\n        vertexShaderSource: shaderProgram.vertexShaderSource,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      }\n    );\n  }\n\n  return shader;\n}\n\nfunction getDepthOnlyRenderState(scene, renderState) {\n  var cache = scene._depthOnlyRenderStateCache;\n  var depthOnlyState = cache[renderState.id];\n  if (!defined(depthOnlyState)) {\n    var rs = RenderState.getState(renderState);\n    rs.depthMask = true;\n    rs.colorMask = {\n      red: false,\n      green: false,\n      blue: false,\n      alpha: false,\n    };\n\n    depthOnlyState = RenderState.fromCache(rs);\n    cache[renderState.id] = depthOnlyState;\n  }\n\n  return depthOnlyState;\n}\n\nDerivedCommand.createDepthOnlyDerivedCommand = function (\n  scene,\n  command,\n  context,\n  result\n) {\n  // For a depth only pass, we bind a framebuffer with only a depth attachment (no color attachments),\n  // do not write color, and write depth. If the fragment shader doesn't modify the fragment depth\n  // or discard, the driver can replace the fragment shader with a pass-through shader. We're unsure if this\n  // actually happens so we modify the shader to use a pass-through fragment shader.\n\n  if (!defined(result)) {\n    result = {};\n  }\n\n  var shader;\n  var renderState;\n  if (defined(result.depthOnlyCommand)) {\n    shader = result.depthOnlyCommand.shaderProgram;\n    renderState = result.depthOnlyCommand.renderState;\n  }\n\n  result.depthOnlyCommand = DrawCommand.shallowClone(\n    command,\n    result.depthOnlyCommand\n  );\n\n  if (!defined(shader) || result.shaderProgramId !== command.shaderProgram.id) {\n    result.depthOnlyCommand.shaderProgram = getDepthOnlyShaderProgram(\n      context,\n      command.shaderProgram\n    );\n    result.depthOnlyCommand.renderState = getDepthOnlyRenderState(\n      scene,\n      command.renderState\n    );\n    result.shaderProgramId = command.shaderProgram.id;\n  } else {\n    result.depthOnlyCommand.shaderProgram = shader;\n    result.depthOnlyCommand.renderState = renderState;\n  }\n\n  return result;\n};\n\nvar writeLogDepthRegex = /\\s+czm_writeLogDepth\\(/;\nvar vertexlogDepthRegex = /\\s+czm_vertexLogDepth\\(/;\nvar extensionRegex = /\\s*#extension\\s+GL_EXT_frag_depth\\s*:\\s*enable/;\n\nfunction getLogDepthShaderProgram(context, shaderProgram) {\n  var shader = context.shaderCache.getDerivedShaderProgram(\n    shaderProgram,\n    \"logDepth\"\n  );\n  if (!defined(shader)) {\n    var attributeLocations = shaderProgram._attributeLocations;\n    var vs = shaderProgram.vertexShaderSource.clone();\n    var fs = shaderProgram.fragmentShaderSource.clone();\n\n    vs.defines = defined(vs.defines) ? vs.defines.slice(0) : [];\n    vs.defines.push(\"LOG_DEPTH\");\n    fs.defines = defined(fs.defines) ? fs.defines.slice(0) : [];\n    fs.defines.push(\"LOG_DEPTH\");\n\n    var i;\n    var logMain;\n    var writesLogDepth = false;\n    var sources = vs.sources;\n    var length = sources.length;\n    for (i = 0; i < length; ++i) {\n      if (vertexlogDepthRegex.test(sources[i])) {\n        writesLogDepth = true;\n        break;\n      }\n    }\n\n    if (!writesLogDepth) {\n      for (i = 0; i < length; ++i) {\n        sources[i] = ShaderSource.replaceMain(sources[i], \"czm_log_depth_main\");\n      }\n\n      logMain =\n        \"\\n\\n\" +\n        \"void main() \\n\" +\n        \"{ \\n\" +\n        \"    czm_log_depth_main(); \\n\" +\n        \"    czm_vertexLogDepth(); \\n\" +\n        \"} \\n\";\n      sources.push(logMain);\n    }\n\n    var addExtension = true;\n    writesLogDepth = false;\n    sources = fs.sources;\n    length = sources.length;\n    for (i = 0; i < length; ++i) {\n      if (writeLogDepthRegex.test(sources[i])) {\n        writesLogDepth = true;\n      }\n      if (extensionRegex.test(sources[i])) {\n        addExtension = false;\n      }\n    }\n\n    var logSource = \"\";\n    if (addExtension) {\n      logSource +=\n        \"#ifdef GL_EXT_frag_depth \\n\" +\n        \"#extension GL_EXT_frag_depth : enable \\n\" +\n        \"#endif \\n\\n\";\n    }\n\n    if (!writesLogDepth) {\n      for (i = 0; i < length; i++) {\n        sources[i] = ShaderSource.replaceMain(sources[i], \"czm_log_depth_main\");\n      }\n\n      logSource +=\n        \"\\n\" +\n        \"void main() \\n\" +\n        \"{ \\n\" +\n        \"    czm_log_depth_main(); \\n\" +\n        \"    czm_writeLogDepth(); \\n\" +\n        \"} \\n\";\n    }\n\n    sources.push(logSource);\n\n    shader = context.shaderCache.createDerivedShaderProgram(\n      shaderProgram,\n      \"logDepth\",\n      {\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      }\n    );\n  }\n\n  return shader;\n}\n\nDerivedCommand.createLogDepthCommand = function (command, context, result) {\n  if (!defined(result)) {\n    result = {};\n  }\n\n  var shader;\n  if (defined(result.command)) {\n    shader = result.command.shaderProgram;\n  }\n\n  result.command = DrawCommand.shallowClone(command, result.command);\n\n  if (!defined(shader) || result.shaderProgramId !== command.shaderProgram.id) {\n    result.command.shaderProgram = getLogDepthShaderProgram(\n      context,\n      command.shaderProgram\n    );\n    result.shaderProgramId = command.shaderProgram.id;\n  } else {\n    result.command.shaderProgram = shader;\n  }\n\n  return result;\n};\n\nfunction getPickShaderProgram(context, shaderProgram, pickId) {\n  var shader = context.shaderCache.getDerivedShaderProgram(\n    shaderProgram,\n    \"pick\"\n  );\n  if (!defined(shader)) {\n    var attributeLocations = shaderProgram._attributeLocations;\n    var fs = shaderProgram.fragmentShaderSource;\n\n    var sources = fs.sources;\n    var length = sources.length;\n\n    var newMain =\n      \"void main() \\n\" +\n      \"{ \\n\" +\n      \"    czm_non_pick_main(); \\n\" +\n      \"    if (gl_FragColor.a == 0.0) { \\n\" +\n      \"        discard; \\n\" +\n      \"    } \\n\" +\n      \"    gl_FragColor = \" +\n      pickId +\n      \"; \\n\" +\n      \"} \\n\";\n    var newSources = new Array(length + 1);\n    for (var i = 0; i < length; ++i) {\n      newSources[i] = ShaderSource.replaceMain(sources[i], \"czm_non_pick_main\");\n    }\n    newSources[length] = newMain;\n    fs = new ShaderSource({\n      sources: newSources,\n      defines: fs.defines,\n    });\n    shader = context.shaderCache.createDerivedShaderProgram(\n      shaderProgram,\n      \"pick\",\n      {\n        vertexShaderSource: shaderProgram.vertexShaderSource,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      }\n    );\n  }\n\n  return shader;\n}\n\nfunction getPickRenderState(scene, renderState) {\n  var cache = scene.picking.pickRenderStateCache;\n  var pickState = cache[renderState.id];\n  if (!defined(pickState)) {\n    var rs = RenderState.getState(renderState);\n    rs.blending.enabled = false;\n\n    // Turns on depth writing for opaque and translucent passes\n    // Overlapping translucent geometry on the globe surface may exhibit z-fighting\n    // during the pick pass which may not match the rendered scene. Once\n    // terrain is on by default and ground primitives are used instead\n    // this will become less of a problem.\n    rs.depthMask = true;\n\n    pickState = RenderState.fromCache(rs);\n    cache[renderState.id] = pickState;\n  }\n\n  return pickState;\n}\n\nDerivedCommand.createPickDerivedCommand = function (\n  scene,\n  command,\n  context,\n  result\n) {\n  if (!defined(result)) {\n    result = {};\n  }\n\n  var shader;\n  var renderState;\n  if (defined(result.pickCommand)) {\n    shader = result.pickCommand.shaderProgram;\n    renderState = result.pickCommand.renderState;\n  }\n\n  result.pickCommand = DrawCommand.shallowClone(command, result.pickCommand);\n\n  if (!defined(shader) || result.shaderProgramId !== command.shaderProgram.id) {\n    result.pickCommand.shaderProgram = getPickShaderProgram(\n      context,\n      command.shaderProgram,\n      command.pickId\n    );\n    result.pickCommand.renderState = getPickRenderState(\n      scene,\n      command.renderState\n    );\n    result.shaderProgramId = command.shaderProgram.id;\n  } else {\n    result.pickCommand.shaderProgram = shader;\n    result.pickCommand.renderState = renderState;\n  }\n\n  return result;\n};\n\nfunction getHdrShaderProgram(context, shaderProgram) {\n  var shader = context.shaderCache.getDerivedShaderProgram(\n    shaderProgram,\n    \"HDR\"\n  );\n  if (!defined(shader)) {\n    var attributeLocations = shaderProgram._attributeLocations;\n    var vs = shaderProgram.vertexShaderSource.clone();\n    var fs = shaderProgram.fragmentShaderSource.clone();\n\n    vs.defines = defined(vs.defines) ? vs.defines.slice(0) : [];\n    vs.defines.push(\"HDR\");\n    fs.defines = defined(fs.defines) ? fs.defines.slice(0) : [];\n    fs.defines.push(\"HDR\");\n\n    shader = context.shaderCache.createDerivedShaderProgram(\n      shaderProgram,\n      \"HDR\",\n      {\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      }\n    );\n  }\n\n  return shader;\n}\n\nDerivedCommand.createHdrCommand = function (command, context, result) {\n  if (!defined(result)) {\n    result = {};\n  }\n\n  var shader;\n  if (defined(result.command)) {\n    shader = result.command.shaderProgram;\n  }\n\n  result.command = DrawCommand.shallowClone(command, result.command);\n\n  if (!defined(shader) || result.shaderProgramId !== command.shaderProgram.id) {\n    result.command.shaderProgram = getHdrShaderProgram(\n      context,\n      command.shaderProgram\n    );\n    result.shaderProgramId = command.shaderProgram.id;\n  } else {\n    result.command.shaderProgram = shader;\n  }\n\n  return result;\n};\nexport default DerivedCommand;\n"]},"metadata":{},"sourceType":"module"}