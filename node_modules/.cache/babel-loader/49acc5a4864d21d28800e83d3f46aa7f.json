{"ast":null,"code":"import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\n/**\n * @private\n */\n\nvar CoplanarPolygonGeometryLibrary = {};\nvar scratchIntersectionPoint = new Cartesian3();\nvar scratchXAxis = new Cartesian3();\nvar scratchYAxis = new Cartesian3();\nvar scratchZAxis = new Cartesian3();\nvar obbScratch = new OrientedBoundingBox();\n\nCoplanarPolygonGeometryLibrary.validOutline = function (positions) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"positions\", positions); //>>includeEnd('debug');\n\n  var orientedBoundingBox = OrientedBoundingBox.fromPoints(positions, obbScratch);\n  var halfAxes = orientedBoundingBox.halfAxes;\n  var xAxis = Matrix3.getColumn(halfAxes, 0, scratchXAxis);\n  var yAxis = Matrix3.getColumn(halfAxes, 1, scratchYAxis);\n  var zAxis = Matrix3.getColumn(halfAxes, 2, scratchZAxis);\n  var xMag = Cartesian3.magnitude(xAxis);\n  var yMag = Cartesian3.magnitude(yAxis);\n  var zMag = Cartesian3.magnitude(zAxis); // If all the points are on a line return undefined because we can't draw a polygon\n\n  return !(xMag === 0 && (yMag === 0 || zMag === 0) || yMag === 0 && zMag === 0);\n}; // call after removeDuplicates\n\n\nCoplanarPolygonGeometryLibrary.computeProjectTo2DArguments = function (positions, centerResult, planeAxis1Result, planeAxis2Result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"positions\", positions);\n  Check.defined(\"centerResult\", centerResult);\n  Check.defined(\"planeAxis1Result\", planeAxis1Result);\n  Check.defined(\"planeAxis2Result\", planeAxis2Result); //>>includeEnd('debug');\n\n  var orientedBoundingBox = OrientedBoundingBox.fromPoints(positions, obbScratch);\n  var halfAxes = orientedBoundingBox.halfAxes;\n  var xAxis = Matrix3.getColumn(halfAxes, 0, scratchXAxis);\n  var yAxis = Matrix3.getColumn(halfAxes, 1, scratchYAxis);\n  var zAxis = Matrix3.getColumn(halfAxes, 2, scratchZAxis);\n  var xMag = Cartesian3.magnitude(xAxis);\n  var yMag = Cartesian3.magnitude(yAxis);\n  var zMag = Cartesian3.magnitude(zAxis);\n  var min = Math.min(xMag, yMag, zMag); // If all the points are on a line return undefined because we can't draw a polygon\n\n  if (xMag === 0 && (yMag === 0 || zMag === 0) || yMag === 0 && zMag === 0) {\n    return false;\n  }\n\n  var planeAxis1;\n  var planeAxis2;\n\n  if (min === yMag || min === zMag) {\n    planeAxis1 = xAxis;\n  }\n\n  if (min === xMag) {\n    planeAxis1 = yAxis;\n  } else if (min === zMag) {\n    planeAxis2 = yAxis;\n  }\n\n  if (min === xMag || min === yMag) {\n    planeAxis2 = zAxis;\n  }\n\n  Cartesian3.normalize(planeAxis1, planeAxis1Result);\n  Cartesian3.normalize(planeAxis2, planeAxis2Result);\n  Cartesian3.clone(orientedBoundingBox.center, centerResult);\n  return true;\n};\n\nfunction projectTo2D(position, center, axis1, axis2, result) {\n  var v = Cartesian3.subtract(position, center, scratchIntersectionPoint);\n  var x = Cartesian3.dot(axis1, v);\n  var y = Cartesian3.dot(axis2, v);\n  return Cartesian2.fromElements(x, y, result);\n}\n\nCoplanarPolygonGeometryLibrary.createProjectPointsTo2DFunction = function (center, axis1, axis2) {\n  return function (positions) {\n    var positionResults = new Array(positions.length);\n\n    for (var i = 0; i < positions.length; i++) {\n      positionResults[i] = projectTo2D(positions[i], center, axis1, axis2);\n    }\n\n    return positionResults;\n  };\n};\n\nCoplanarPolygonGeometryLibrary.createProjectPointTo2DFunction = function (center, axis1, axis2) {\n  return function (position, result) {\n    return projectTo2D(position, center, axis1, axis2, result);\n  };\n};\n\nexport default CoplanarPolygonGeometryLibrary;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/CoplanarPolygonGeometryLibrary.js"],"names":["Cartesian2","Cartesian3","Check","Matrix3","OrientedBoundingBox","CoplanarPolygonGeometryLibrary","scratchIntersectionPoint","scratchXAxis","scratchYAxis","scratchZAxis","obbScratch","validOutline","positions","defined","orientedBoundingBox","fromPoints","halfAxes","xAxis","getColumn","yAxis","zAxis","xMag","magnitude","yMag","zMag","computeProjectTo2DArguments","centerResult","planeAxis1Result","planeAxis2Result","min","Math","planeAxis1","planeAxis2","normalize","clone","center","projectTo2D","position","axis1","axis2","result","v","subtract","x","dot","y","fromElements","createProjectPointsTo2DFunction","positionResults","Array","length","i","createProjectPointTo2DFunction"],"mappings":"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","sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\n\n/**\n * @private\n */\nvar CoplanarPolygonGeometryLibrary = {};\n\nvar scratchIntersectionPoint = new Cartesian3();\nvar scratchXAxis = new Cartesian3();\nvar scratchYAxis = new Cartesian3();\nvar scratchZAxis = new Cartesian3();\nvar obbScratch = new OrientedBoundingBox();\n\nCoplanarPolygonGeometryLibrary.validOutline = function (positions) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"positions\", positions);\n  //>>includeEnd('debug');\n\n  var orientedBoundingBox = OrientedBoundingBox.fromPoints(\n    positions,\n    obbScratch\n  );\n  var halfAxes = orientedBoundingBox.halfAxes;\n  var xAxis = Matrix3.getColumn(halfAxes, 0, scratchXAxis);\n  var yAxis = Matrix3.getColumn(halfAxes, 1, scratchYAxis);\n  var zAxis = Matrix3.getColumn(halfAxes, 2, scratchZAxis);\n\n  var xMag = Cartesian3.magnitude(xAxis);\n  var yMag = Cartesian3.magnitude(yAxis);\n  var zMag = Cartesian3.magnitude(zAxis);\n\n  // If all the points are on a line return undefined because we can't draw a polygon\n  return !(\n    (xMag === 0 && (yMag === 0 || zMag === 0)) ||\n    (yMag === 0 && zMag === 0)\n  );\n};\n\n// call after removeDuplicates\nCoplanarPolygonGeometryLibrary.computeProjectTo2DArguments = function (\n  positions,\n  centerResult,\n  planeAxis1Result,\n  planeAxis2Result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"positions\", positions);\n  Check.defined(\"centerResult\", centerResult);\n  Check.defined(\"planeAxis1Result\", planeAxis1Result);\n  Check.defined(\"planeAxis2Result\", planeAxis2Result);\n  //>>includeEnd('debug');\n\n  var orientedBoundingBox = OrientedBoundingBox.fromPoints(\n    positions,\n    obbScratch\n  );\n  var halfAxes = orientedBoundingBox.halfAxes;\n  var xAxis = Matrix3.getColumn(halfAxes, 0, scratchXAxis);\n  var yAxis = Matrix3.getColumn(halfAxes, 1, scratchYAxis);\n  var zAxis = Matrix3.getColumn(halfAxes, 2, scratchZAxis);\n\n  var xMag = Cartesian3.magnitude(xAxis);\n  var yMag = Cartesian3.magnitude(yAxis);\n  var zMag = Cartesian3.magnitude(zAxis);\n  var min = Math.min(xMag, yMag, zMag);\n\n  // If all the points are on a line return undefined because we can't draw a polygon\n  if (\n    (xMag === 0 && (yMag === 0 || zMag === 0)) ||\n    (yMag === 0 && zMag === 0)\n  ) {\n    return false;\n  }\n\n  var planeAxis1;\n  var planeAxis2;\n\n  if (min === yMag || min === zMag) {\n    planeAxis1 = xAxis;\n  }\n  if (min === xMag) {\n    planeAxis1 = yAxis;\n  } else if (min === zMag) {\n    planeAxis2 = yAxis;\n  }\n  if (min === xMag || min === yMag) {\n    planeAxis2 = zAxis;\n  }\n\n  Cartesian3.normalize(planeAxis1, planeAxis1Result);\n  Cartesian3.normalize(planeAxis2, planeAxis2Result);\n  Cartesian3.clone(orientedBoundingBox.center, centerResult);\n  return true;\n};\n\nfunction projectTo2D(position, center, axis1, axis2, result) {\n  var v = Cartesian3.subtract(position, center, scratchIntersectionPoint);\n  var x = Cartesian3.dot(axis1, v);\n  var y = Cartesian3.dot(axis2, v);\n\n  return Cartesian2.fromElements(x, y, result);\n}\n\nCoplanarPolygonGeometryLibrary.createProjectPointsTo2DFunction = function (\n  center,\n  axis1,\n  axis2\n) {\n  return function (positions) {\n    var positionResults = new Array(positions.length);\n    for (var i = 0; i < positions.length; i++) {\n      positionResults[i] = projectTo2D(positions[i], center, axis1, axis2);\n    }\n\n    return positionResults;\n  };\n};\n\nCoplanarPolygonGeometryLibrary.createProjectPointTo2DFunction = function (\n  center,\n  axis1,\n  axis2\n) {\n  return function (position, result) {\n    return projectTo2D(position, center, axis1, axis2, result);\n  };\n};\nexport default CoplanarPolygonGeometryLibrary;\n"]},"metadata":{},"sourceType":"module"}