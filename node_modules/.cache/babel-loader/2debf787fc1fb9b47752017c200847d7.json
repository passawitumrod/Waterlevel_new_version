{"ast":null,"code":"import when from \"../ThirdParty/when.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Credit from \"./Credit.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Event from \"./Event.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport HeightmapEncoding from \"./HeightmapEncoding.js\";\nimport HeightmapTerrainData from \"./HeightmapTerrainData.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Request from \"./Request.js\";\nimport RequestState from \"./RequestState.js\";\nimport RequestType from \"./RequestType.js\";\nimport Resource from \"./Resource.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nimport TerrainProvider from \"./TerrainProvider.js\";\nimport TileAvailability from \"./TileAvailability.js\";\nimport TileProviderError from \"./TileProviderError.js\";\nimport WebMercatorTilingScheme from \"./WebMercatorTilingScheme.js\";\nvar ALL_CHILDREN = 15;\n/**\n * A {@link TerrainProvider} that produces terrain geometry by tessellating height maps\n * retrieved from Elevation Tiles of an an ArcGIS ImageService.\n *\n * @alias ArcGISTiledElevationTerrainProvider\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource|String|Promise<Resource>|Promise<String>} options.url The URL of the ArcGIS ImageServer service.\n * @param {String} [options.token] The authorization token to use to connect to the service.\n * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If the tilingScheme is specified,\n *                    this parameter is ignored and the tiling scheme's ellipsoid is used instead.\n *                    If neither parameter is specified, the WGS84 ellipsoid is used.\n *\n * @example\n * var terrainProvider = new Cesium.ArcGISTiledElevationTerrainProvider({\n *   url : 'https://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer',\n *   token : 'KED1aF_I4UzXOHy3BnhwyBHU4l5oY6rO6walkmHoYqGp4XyIWUd5YZUC1ZrLAzvV40pR6gBXQayh0eFA8m6vPg..'\n * });\n * viewer.terrainProvider = terrainProvider;\n *\n *  @see TerrainProvider\n */\n\nfunction ArcGISTiledElevationTerrainProvider(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.url)) {\n    throw new DeveloperError(\"options.url is required.\");\n  } //>>includeEnd('debug');\n\n\n  this._resource = undefined;\n  this._credit = undefined;\n  this._tilingScheme = undefined;\n  this._levelZeroMaximumGeometricError = undefined;\n  this._maxLevel = undefined;\n  this._terrainDataStructure = undefined;\n  this._ready = false;\n  this._width = undefined;\n  this._height = undefined;\n  this._encoding = undefined;\n  var token = options.token;\n  this._hasAvailability = false;\n  this._tilesAvailable = undefined;\n  this._tilesAvailablityLoaded = undefined;\n  this._availableCache = {};\n  var that = this;\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  this._readyPromise = when(options.url).then(function (url) {\n    var resource = Resource.createIfNeeded(url);\n    resource.appendForwardSlash();\n\n    if (defined(token)) {\n      resource = resource.getDerivedResource({\n        queryParameters: {\n          token: token\n        }\n      });\n    }\n\n    that._resource = resource;\n    var metadataResource = resource.getDerivedResource({\n      queryParameters: {\n        f: \"pjson\"\n      }\n    });\n    return metadataResource.fetchJson();\n  }).then(function (metadata) {\n    var copyrightText = metadata.copyrightText;\n\n    if (defined(copyrightText)) {\n      that._credit = new Credit(copyrightText);\n    }\n\n    var spatialReference = metadata.spatialReference;\n    var wkid = defaultValue(spatialReference.latestWkid, spatialReference.wkid);\n    var extent = metadata.extent;\n    var tilingSchemeOptions = {\n      ellipsoid: ellipsoid\n    };\n\n    if (wkid === 4326) {\n      tilingSchemeOptions.rectangle = Rectangle.fromDegrees(extent.xmin, extent.ymin, extent.xmax, extent.ymax);\n      that._tilingScheme = new GeographicTilingScheme(tilingSchemeOptions);\n    } else if (wkid === 3857) {\n      tilingSchemeOptions.rectangleSouthwestInMeters = new Cartesian2(extent.xmin, extent.ymin);\n      tilingSchemeOptions.rectangleNortheastInMeters = new Cartesian2(extent.xmax, extent.ymax);\n      that._tilingScheme = new WebMercatorTilingScheme(tilingSchemeOptions);\n    } else {\n      return when.reject(new RuntimeError(\"Invalid spatial reference\"));\n    }\n\n    var tileInfo = metadata.tileInfo;\n\n    if (!defined(tileInfo)) {\n      return when.reject(new RuntimeError(\"tileInfo is required\"));\n    }\n\n    that._width = tileInfo.rows + 1;\n    that._height = tileInfo.cols + 1;\n    that._encoding = tileInfo.format === \"LERC\" ? HeightmapEncoding.LERC : HeightmapEncoding.NONE;\n    that._lodCount = tileInfo.lods.length - 1;\n    var hasAvailability = that._hasAvailability = metadata.capabilities.indexOf(\"Tilemap\") !== -1;\n\n    if (hasAvailability) {\n      that._tilesAvailable = new TileAvailability(that._tilingScheme, that._lodCount);\n\n      that._tilesAvailable.addAvailableTileRange(0, 0, 0, that._tilingScheme.getNumberOfXTilesAtLevel(0), that._tilingScheme.getNumberOfYTilesAtLevel(0));\n\n      that._tilesAvailablityLoaded = new TileAvailability(that._tilingScheme, that._lodCount);\n    }\n\n    that._levelZeroMaximumGeometricError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(that._tilingScheme.ellipsoid, that._width, that._tilingScheme.getNumberOfXTilesAtLevel(0));\n\n    if (metadata.bandCount > 1) {\n      console.log(\"ArcGISTiledElevationTerrainProvider: Terrain data has more than 1 band. Using the first one.\");\n    }\n\n    that._terrainDataStructure = {\n      elementMultiplier: 1.0,\n      lowestEncodedHeight: metadata.minValues[0],\n      highestEncodedHeight: metadata.maxValues[0]\n    };\n    that._ready = true;\n    return true;\n  }).otherwise(function (error) {\n    var message = \"An error occurred while accessing \" + that._resource.url + \".\";\n    TileProviderError.handleError(undefined, that, that._errorEvent, message);\n    return when.reject(error);\n  });\n  this._errorEvent = new Event();\n}\n\nObject.defineProperties(ArcGISTiledElevationTerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    }\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.  This function should not be called before {@link ArcGISTiledElevationTerrainProvider#ready} returns true.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {Credit}\n   */\n  credit: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this.ready) {\n        throw new DeveloperError(\"credit must not be called before ready returns true.\");\n      } //>>includeEnd('debug');\n\n\n      return this._credit;\n    }\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.  This function should\n   * not be called before {@link ArcGISTiledElevationTerrainProvider#ready} returns true.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {GeographicTilingScheme}\n   */\n  tilingScheme: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this.ready) {\n        throw new DeveloperError(\"tilingScheme must not be called before ready returns true.\");\n      } //>>includeEnd('debug');\n\n\n      return this._tilingScheme;\n    }\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {Boolean}\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    }\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.  This function should not be\n   * called before {@link ArcGISTiledElevationTerrainProvider#ready} returns true.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {Boolean}\n   */\n  hasWaterMask: {\n    get: function () {\n      return false;\n    }\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * This function should not be called before {@link ArcGISTiledElevationTerrainProvider#ready} returns true.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {Boolean}\n   */\n  hasVertexNormals: {\n    get: function () {\n      return false;\n    }\n  }\n});\n/**\n * Requests the geometry for a given tile.  This function should not be called before\n * {@link ArcGISTiledElevationTerrainProvider#ready} returns true.  The result includes terrain\n * data and indicates that all child tiles are available.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n */\n\nArcGISTiledElevationTerrainProvider.prototype.requestTileGeometry = function (x, y, level, request) {\n  //>>includeStart('debug', pragmas.debug)\n  if (!this._ready) {\n    throw new DeveloperError(\"requestTileGeometry must not be called before the terrain provider is ready.\");\n  } //>>includeEnd('debug');\n\n\n  var tileResource = this._resource.getDerivedResource({\n    url: \"tile/\" + level + \"/\" + y + \"/\" + x,\n    request: request\n  });\n\n  var hasAvailability = this._hasAvailability;\n  var availabilityPromise = when.resolve(true);\n  var availabilityRequest;\n\n  if (hasAvailability && !defined(isTileAvailable(this, level + 1, x * 2, y * 2))) {\n    // We need to load child availability\n    var availabilityResult = requestAvailability(this, level + 1, x * 2, y * 2);\n    availabilityPromise = availabilityResult.promise;\n    availabilityRequest = availabilityResult.request;\n  }\n\n  var promise = tileResource.fetchArrayBuffer();\n\n  if (!defined(promise) || !defined(availabilityPromise)) {\n    return undefined;\n  }\n\n  var that = this;\n  var tilesAvailable = this._tilesAvailable;\n  return when.join(promise, availabilityPromise).then(function (result) {\n    return new HeightmapTerrainData({\n      buffer: result[0],\n      width: that._width,\n      height: that._height,\n      childTileMask: hasAvailability ? tilesAvailable.computeChildMaskForTile(level, x, y) : ALL_CHILDREN,\n      structure: that._terrainDataStructure,\n      encoding: that._encoding\n    });\n  }).otherwise(function (error) {\n    if (defined(availabilityRequest) && availabilityRequest.state === RequestState.CANCELLED) {\n      request.cancel(); // Don't reject the promise till the request is actually cancelled\n      // Otherwise it will think the request failed, but it didn't.\n\n      return request.deferred.promise.always(function () {\n        request.state = RequestState.CANCELLED;\n        return when.reject(error);\n      });\n    }\n\n    return when.reject(error);\n  });\n};\n\nfunction isTileAvailable(that, level, x, y) {\n  if (!that._hasAvailability) {\n    return undefined;\n  }\n\n  var tilesAvailablityLoaded = that._tilesAvailablityLoaded;\n  var tilesAvailable = that._tilesAvailable;\n\n  if (level > that._lodCount) {\n    return false;\n  } // Check if tiles are known to be available\n\n\n  if (tilesAvailable.isTileAvailable(level, x, y)) {\n    return true;\n  } // or to not be available\n\n\n  if (tilesAvailablityLoaded.isTileAvailable(level, x, y)) {\n    return false;\n  }\n\n  return undefined;\n}\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n *\n * @param {Number} level The tile level for which to get the maximum geometric error.\n * @returns {Number} The maximum geometric error.\n */\n\n\nArcGISTiledElevationTerrainProvider.prototype.getLevelMaximumGeometricError = function (level) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this.ready) {\n    throw new DeveloperError(\"getLevelMaximumGeometricError must not be called before ready returns true.\");\n  } //>>includeEnd('debug');\n\n\n  return this._levelZeroMaximumGeometricError / (1 << level);\n};\n/**\n * Determines whether data for a tile is available to be loaded.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {Boolean} Undefined if not supported, otherwise true or false.\n */\n\n\nArcGISTiledElevationTerrainProvider.prototype.getTileDataAvailable = function (x, y, level) {\n  if (!this._hasAvailability) {\n    return undefined;\n  }\n\n  var result = isTileAvailable(this, level, x, y);\n\n  if (defined(result)) {\n    return result;\n  }\n\n  requestAvailability(this, level, x, y);\n  return undefined;\n};\n/**\n * Makes sure we load availability data for a tile\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {undefined|Promise} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\n */\n\n\nArcGISTiledElevationTerrainProvider.prototype.loadTileDataAvailability = function (x, y, level) {\n  return undefined;\n};\n\nfunction findRange(origin, width, height, data) {\n  var endCol = width - 1;\n  var endRow = height - 1;\n  var value = data[origin.y * width + origin.x];\n  var endingIndices = [];\n  var range = {\n    startX: origin.x,\n    startY: origin.y,\n    endX: 0,\n    endY: 0\n  };\n  var corner = new Cartesian2(origin.x + 1, origin.y + 1);\n  var doneX = false;\n  var doneY = false;\n\n  while (!(doneX && doneY)) {\n    // We want to use the original value when checking Y,\n    //  so get it before it possibly gets incremented\n    var endX = corner.x; // If we no longer move in the Y direction we need to check the corner tile in X pass\n\n    var endY = doneY ? corner.y + 1 : corner.y; // Check X range\n\n    if (!doneX) {\n      for (var y = origin.y; y < endY; ++y) {\n        if (data[y * width + corner.x] !== value) {\n          doneX = true;\n          break;\n        }\n      }\n\n      if (doneX) {\n        endingIndices.push(new Cartesian2(corner.x, origin.y)); // Use the last good column so we can continue with Y\n\n        --corner.x;\n        --endX;\n        range.endX = corner.x;\n      } else if (corner.x === endCol) {\n        range.endX = corner.x;\n        doneX = true;\n      } else {\n        ++corner.x;\n      }\n    } // Check Y range - The corner tile is checked here\n\n\n    if (!doneY) {\n      var col = corner.y * width;\n\n      for (var x = origin.x; x <= endX; ++x) {\n        if (data[col + x] !== value) {\n          doneY = true;\n          break;\n        }\n      }\n\n      if (doneY) {\n        endingIndices.push(new Cartesian2(origin.x, corner.y)); // Use the last good row so we can continue with X\n\n        --corner.y;\n        range.endY = corner.y;\n      } else if (corner.y === endRow) {\n        range.endY = corner.y;\n        doneY = true;\n      } else {\n        ++corner.y;\n      }\n    }\n  }\n\n  return {\n    endingIndices: endingIndices,\n    range: range,\n    value: value\n  };\n}\n\nfunction computeAvailability(x, y, width, height, data) {\n  var ranges = [];\n  var singleValue = data.every(function (val) {\n    return val === data[0];\n  });\n\n  if (singleValue) {\n    if (data[0] === 1) {\n      ranges.push({\n        startX: x,\n        startY: y,\n        endX: x + width - 1,\n        endY: y + height - 1\n      });\n    }\n\n    return ranges;\n  }\n\n  var positions = [new Cartesian2(0, 0)];\n\n  while (positions.length > 0) {\n    var origin = positions.pop();\n    var result = findRange(origin, width, height, data);\n\n    if (result.value === 1) {\n      // Convert range into the array into global tile coordinates\n      var range = result.range;\n      range.startX += x;\n      range.endX += x;\n      range.startY += y;\n      range.endY += y;\n      ranges.push(range);\n    }\n\n    var endingIndices = result.endingIndices;\n\n    if (endingIndices.length > 0) {\n      positions = positions.concat(endingIndices);\n    }\n  }\n\n  return ranges;\n}\n\nfunction requestAvailability(that, level, x, y) {\n  if (!that._hasAvailability) {\n    return {};\n  } // Fetch 128x128 availability list, so we make the minimum amount of requests\n\n\n  var xOffset = Math.floor(x / 128) * 128;\n  var yOffset = Math.floor(y / 128) * 128;\n  var dim = Math.min(1 << level, 128);\n  var url = \"tilemap/\" + level + \"/\" + yOffset + \"/\" + xOffset + \"/\" + dim + \"/\" + dim;\n  var availableCache = that._availableCache;\n\n  if (defined(availableCache[url])) {\n    return availableCache[url];\n  }\n\n  var request = new Request({\n    throttle: true,\n    throttleByServer: true,\n    type: RequestType.TERRAIN\n  });\n\n  var tilemapResource = that._resource.getDerivedResource({\n    url: url,\n    request: request\n  });\n\n  var promise = tilemapResource.fetchJson();\n\n  if (!defined(promise)) {\n    return {};\n  }\n\n  promise = promise.then(function (result) {\n    var available = computeAvailability(xOffset, yOffset, dim, dim, result.data); // Mark whole area as having availability loaded\n\n    that._tilesAvailablityLoaded.addAvailableTileRange(xOffset, yOffset, xOffset + dim, yOffset + dim);\n\n    var tilesAvailable = that._tilesAvailable;\n\n    for (var i = 0; i < available.length; ++i) {\n      var range = available[i];\n      tilesAvailable.addAvailableTileRange(level, range.startX, range.startY, range.endX, range.endY);\n    } // Conveniently return availability of original tile\n\n\n    return isTileAvailable(that, level, x, y);\n  });\n  availableCache[url] = {\n    promise: promise,\n    request: request\n  };\n  promise = promise.always(function (result) {\n    delete availableCache[url];\n    return result;\n  });\n  return {\n    promise: promise,\n    request: request\n  };\n}\n\nexport default ArcGISTiledElevationTerrainProvider;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/ArcGISTiledElevationTerrainProvider.js"],"names":["when","Cartesian2","Credit","defaultValue","defined","DeveloperError","Ellipsoid","Event","GeographicTilingScheme","HeightmapEncoding","HeightmapTerrainData","Rectangle","Request","RequestState","RequestType","Resource","RuntimeError","TerrainProvider","TileAvailability","TileProviderError","WebMercatorTilingScheme","ALL_CHILDREN","ArcGISTiledElevationTerrainProvider","options","url","_resource","undefined","_credit","_tilingScheme","_levelZeroMaximumGeometricError","_maxLevel","_terrainDataStructure","_ready","_width","_height","_encoding","token","_hasAvailability","_tilesAvailable","_tilesAvailablityLoaded","_availableCache","that","ellipsoid","WGS84","_readyPromise","then","resource","createIfNeeded","appendForwardSlash","getDerivedResource","queryParameters","metadataResource","f","fetchJson","metadata","copyrightText","spatialReference","wkid","latestWkid","extent","tilingSchemeOptions","rectangle","fromDegrees","xmin","ymin","xmax","ymax","rectangleSouthwestInMeters","rectangleNortheastInMeters","reject","tileInfo","rows","cols","format","LERC","NONE","_lodCount","lods","length","hasAvailability","capabilities","indexOf","addAvailableTileRange","getNumberOfXTilesAtLevel","getNumberOfYTilesAtLevel","getEstimatedLevelZeroGeometricErrorForAHeightmap","bandCount","console","log","elementMultiplier","lowestEncodedHeight","minValues","highestEncodedHeight","maxValues","otherwise","error","message","handleError","_errorEvent","Object","defineProperties","prototype","errorEvent","get","credit","ready","tilingScheme","readyPromise","hasWaterMask","hasVertexNormals","requestTileGeometry","x","y","level","request","tileResource","availabilityPromise","resolve","availabilityRequest","isTileAvailable","availabilityResult","requestAvailability","promise","fetchArrayBuffer","tilesAvailable","join","result","buffer","width","height","childTileMask","computeChildMaskForTile","structure","encoding","state","CANCELLED","cancel","deferred","always","tilesAvailablityLoaded","getLevelMaximumGeometricError","getTileDataAvailable","loadTileDataAvailability","findRange","origin","data","endCol","endRow","value","endingIndices","range","startX","startY","endX","endY","corner","doneX","doneY","push","col","computeAvailability","ranges","singleValue","every","val","positions","pop","concat","xOffset","Math","floor","yOffset","dim","min","availableCache","throttle","throttleByServer","type","TERRAIN","tilemapResource","available","i"],"mappings":"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","sourcesContent":["import when from \"../ThirdParty/when.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Credit from \"./Credit.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Event from \"./Event.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport HeightmapEncoding from \"./HeightmapEncoding.js\";\nimport HeightmapTerrainData from \"./HeightmapTerrainData.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Request from \"./Request.js\";\nimport RequestState from \"./RequestState.js\";\nimport RequestType from \"./RequestType.js\";\nimport Resource from \"./Resource.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nimport TerrainProvider from \"./TerrainProvider.js\";\nimport TileAvailability from \"./TileAvailability.js\";\nimport TileProviderError from \"./TileProviderError.js\";\nimport WebMercatorTilingScheme from \"./WebMercatorTilingScheme.js\";\n\nvar ALL_CHILDREN = 15;\n\n/**\n * A {@link TerrainProvider} that produces terrain geometry by tessellating height maps\n * retrieved from Elevation Tiles of an an ArcGIS ImageService.\n *\n * @alias ArcGISTiledElevationTerrainProvider\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource|String|Promise<Resource>|Promise<String>} options.url The URL of the ArcGIS ImageServer service.\n * @param {String} [options.token] The authorization token to use to connect to the service.\n * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If the tilingScheme is specified,\n *                    this parameter is ignored and the tiling scheme's ellipsoid is used instead.\n *                    If neither parameter is specified, the WGS84 ellipsoid is used.\n *\n * @example\n * var terrainProvider = new Cesium.ArcGISTiledElevationTerrainProvider({\n *   url : 'https://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer',\n *   token : 'KED1aF_I4UzXOHy3BnhwyBHU4l5oY6rO6walkmHoYqGp4XyIWUd5YZUC1ZrLAzvV40pR6gBXQayh0eFA8m6vPg..'\n * });\n * viewer.terrainProvider = terrainProvider;\n *\n *  @see TerrainProvider\n */\nfunction ArcGISTiledElevationTerrainProvider(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.url)) {\n    throw new DeveloperError(\"options.url is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._resource = undefined;\n  this._credit = undefined;\n  this._tilingScheme = undefined;\n  this._levelZeroMaximumGeometricError = undefined;\n  this._maxLevel = undefined;\n  this._terrainDataStructure = undefined;\n  this._ready = false;\n  this._width = undefined;\n  this._height = undefined;\n  this._encoding = undefined;\n  var token = options.token;\n\n  this._hasAvailability = false;\n  this._tilesAvailable = undefined;\n  this._tilesAvailablityLoaded = undefined;\n  this._availableCache = {};\n\n  var that = this;\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  this._readyPromise = when(options.url)\n    .then(function (url) {\n      var resource = Resource.createIfNeeded(url);\n      resource.appendForwardSlash();\n      if (defined(token)) {\n        resource = resource.getDerivedResource({\n          queryParameters: {\n            token: token,\n          },\n        });\n      }\n      that._resource = resource;\n\n      var metadataResource = resource.getDerivedResource({\n        queryParameters: {\n          f: \"pjson\",\n        },\n      });\n\n      return metadataResource.fetchJson();\n    })\n    .then(function (metadata) {\n      var copyrightText = metadata.copyrightText;\n      if (defined(copyrightText)) {\n        that._credit = new Credit(copyrightText);\n      }\n\n      var spatialReference = metadata.spatialReference;\n      var wkid = defaultValue(\n        spatialReference.latestWkid,\n        spatialReference.wkid\n      );\n      var extent = metadata.extent;\n      var tilingSchemeOptions = {\n        ellipsoid: ellipsoid,\n      };\n      if (wkid === 4326) {\n        tilingSchemeOptions.rectangle = Rectangle.fromDegrees(\n          extent.xmin,\n          extent.ymin,\n          extent.xmax,\n          extent.ymax\n        );\n        that._tilingScheme = new GeographicTilingScheme(tilingSchemeOptions);\n      } else if (wkid === 3857) {\n        tilingSchemeOptions.rectangleSouthwestInMeters = new Cartesian2(\n          extent.xmin,\n          extent.ymin\n        );\n        tilingSchemeOptions.rectangleNortheastInMeters = new Cartesian2(\n          extent.xmax,\n          extent.ymax\n        );\n        that._tilingScheme = new WebMercatorTilingScheme(tilingSchemeOptions);\n      } else {\n        return when.reject(new RuntimeError(\"Invalid spatial reference\"));\n      }\n\n      var tileInfo = metadata.tileInfo;\n      if (!defined(tileInfo)) {\n        return when.reject(new RuntimeError(\"tileInfo is required\"));\n      }\n\n      that._width = tileInfo.rows + 1;\n      that._height = tileInfo.cols + 1;\n      that._encoding =\n        tileInfo.format === \"LERC\"\n          ? HeightmapEncoding.LERC\n          : HeightmapEncoding.NONE;\n      that._lodCount = tileInfo.lods.length - 1;\n\n      var hasAvailability = (that._hasAvailability =\n        metadata.capabilities.indexOf(\"Tilemap\") !== -1);\n      if (hasAvailability) {\n        that._tilesAvailable = new TileAvailability(\n          that._tilingScheme,\n          that._lodCount\n        );\n        that._tilesAvailable.addAvailableTileRange(\n          0,\n          0,\n          0,\n          that._tilingScheme.getNumberOfXTilesAtLevel(0),\n          that._tilingScheme.getNumberOfYTilesAtLevel(0)\n        );\n        that._tilesAvailablityLoaded = new TileAvailability(\n          that._tilingScheme,\n          that._lodCount\n        );\n      }\n\n      that._levelZeroMaximumGeometricError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n        that._tilingScheme.ellipsoid,\n        that._width,\n        that._tilingScheme.getNumberOfXTilesAtLevel(0)\n      );\n\n      if (metadata.bandCount > 1) {\n        console.log(\n          \"ArcGISTiledElevationTerrainProvider: Terrain data has more than 1 band. Using the first one.\"\n        );\n      }\n\n      that._terrainDataStructure = {\n        elementMultiplier: 1.0,\n        lowestEncodedHeight: metadata.minValues[0],\n        highestEncodedHeight: metadata.maxValues[0],\n      };\n\n      that._ready = true;\n\n      return true;\n    })\n    .otherwise(function (error) {\n      var message =\n        \"An error occurred while accessing \" + that._resource.url + \".\";\n      TileProviderError.handleError(undefined, that, that._errorEvent, message);\n      return when.reject(error);\n    });\n\n  this._errorEvent = new Event();\n}\n\nObject.defineProperties(ArcGISTiledElevationTerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.  This function should not be called before {@link ArcGISTiledElevationTerrainProvider#ready} returns true.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {Credit}\n   */\n  credit: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this.ready) {\n        throw new DeveloperError(\n          \"credit must not be called before ready returns true.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._credit;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.  This function should\n   * not be called before {@link ArcGISTiledElevationTerrainProvider#ready} returns true.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {GeographicTilingScheme}\n   */\n  tilingScheme: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this.ready) {\n        throw new DeveloperError(\n          \"tilingScheme must not be called before ready returns true.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {Boolean}\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.  This function should not be\n   * called before {@link ArcGISTiledElevationTerrainProvider#ready} returns true.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {Boolean}\n   */\n  hasWaterMask: {\n    get: function () {\n      return false;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * This function should not be called before {@link ArcGISTiledElevationTerrainProvider#ready} returns true.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {Boolean}\n   */\n  hasVertexNormals: {\n    get: function () {\n      return false;\n    },\n  },\n});\n\n/**\n * Requests the geometry for a given tile.  This function should not be called before\n * {@link ArcGISTiledElevationTerrainProvider#ready} returns true.  The result includes terrain\n * data and indicates that all child tiles are available.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n */\nArcGISTiledElevationTerrainProvider.prototype.requestTileGeometry = function (\n  x,\n  y,\n  level,\n  request\n) {\n  //>>includeStart('debug', pragmas.debug)\n  if (!this._ready) {\n    throw new DeveloperError(\n      \"requestTileGeometry must not be called before the terrain provider is ready.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var tileResource = this._resource.getDerivedResource({\n    url: \"tile/\" + level + \"/\" + y + \"/\" + x,\n    request: request,\n  });\n\n  var hasAvailability = this._hasAvailability;\n  var availabilityPromise = when.resolve(true);\n  var availabilityRequest;\n  if (\n    hasAvailability &&\n    !defined(isTileAvailable(this, level + 1, x * 2, y * 2))\n  ) {\n    // We need to load child availability\n    var availabilityResult = requestAvailability(this, level + 1, x * 2, y * 2);\n\n    availabilityPromise = availabilityResult.promise;\n    availabilityRequest = availabilityResult.request;\n  }\n\n  var promise = tileResource.fetchArrayBuffer();\n  if (!defined(promise) || !defined(availabilityPromise)) {\n    return undefined;\n  }\n\n  var that = this;\n  var tilesAvailable = this._tilesAvailable;\n  return when\n    .join(promise, availabilityPromise)\n    .then(function (result) {\n      return new HeightmapTerrainData({\n        buffer: result[0],\n        width: that._width,\n        height: that._height,\n        childTileMask: hasAvailability\n          ? tilesAvailable.computeChildMaskForTile(level, x, y)\n          : ALL_CHILDREN,\n        structure: that._terrainDataStructure,\n        encoding: that._encoding,\n      });\n    })\n    .otherwise(function (error) {\n      if (\n        defined(availabilityRequest) &&\n        availabilityRequest.state === RequestState.CANCELLED\n      ) {\n        request.cancel();\n\n        // Don't reject the promise till the request is actually cancelled\n        // Otherwise it will think the request failed, but it didn't.\n        return request.deferred.promise.always(function () {\n          request.state = RequestState.CANCELLED;\n          return when.reject(error);\n        });\n      }\n      return when.reject(error);\n    });\n};\n\nfunction isTileAvailable(that, level, x, y) {\n  if (!that._hasAvailability) {\n    return undefined;\n  }\n\n  var tilesAvailablityLoaded = that._tilesAvailablityLoaded;\n  var tilesAvailable = that._tilesAvailable;\n\n  if (level > that._lodCount) {\n    return false;\n  }\n\n  // Check if tiles are known to be available\n  if (tilesAvailable.isTileAvailable(level, x, y)) {\n    return true;\n  }\n\n  // or to not be available\n  if (tilesAvailablityLoaded.isTileAvailable(level, x, y)) {\n    return false;\n  }\n\n  return undefined;\n}\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n *\n * @param {Number} level The tile level for which to get the maximum geometric error.\n * @returns {Number} The maximum geometric error.\n */\nArcGISTiledElevationTerrainProvider.prototype.getLevelMaximumGeometricError = function (\n  level\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this.ready) {\n    throw new DeveloperError(\n      \"getLevelMaximumGeometricError must not be called before ready returns true.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  return this._levelZeroMaximumGeometricError / (1 << level);\n};\n\n/**\n * Determines whether data for a tile is available to be loaded.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {Boolean} Undefined if not supported, otherwise true or false.\n */\nArcGISTiledElevationTerrainProvider.prototype.getTileDataAvailable = function (\n  x,\n  y,\n  level\n) {\n  if (!this._hasAvailability) {\n    return undefined;\n  }\n\n  var result = isTileAvailable(this, level, x, y);\n  if (defined(result)) {\n    return result;\n  }\n\n  requestAvailability(this, level, x, y);\n\n  return undefined;\n};\n\n/**\n * Makes sure we load availability data for a tile\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {undefined|Promise} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\n */\nArcGISTiledElevationTerrainProvider.prototype.loadTileDataAvailability = function (\n  x,\n  y,\n  level\n) {\n  return undefined;\n};\n\nfunction findRange(origin, width, height, data) {\n  var endCol = width - 1;\n  var endRow = height - 1;\n\n  var value = data[origin.y * width + origin.x];\n  var endingIndices = [];\n  var range = {\n    startX: origin.x,\n    startY: origin.y,\n    endX: 0,\n    endY: 0,\n  };\n\n  var corner = new Cartesian2(origin.x + 1, origin.y + 1);\n  var doneX = false;\n  var doneY = false;\n  while (!(doneX && doneY)) {\n    // We want to use the original value when checking Y,\n    //  so get it before it possibly gets incremented\n    var endX = corner.x;\n\n    // If we no longer move in the Y direction we need to check the corner tile in X pass\n    var endY = doneY ? corner.y + 1 : corner.y;\n\n    // Check X range\n    if (!doneX) {\n      for (var y = origin.y; y < endY; ++y) {\n        if (data[y * width + corner.x] !== value) {\n          doneX = true;\n          break;\n        }\n      }\n\n      if (doneX) {\n        endingIndices.push(new Cartesian2(corner.x, origin.y));\n\n        // Use the last good column so we can continue with Y\n        --corner.x;\n        --endX;\n        range.endX = corner.x;\n      } else if (corner.x === endCol) {\n        range.endX = corner.x;\n        doneX = true;\n      } else {\n        ++corner.x;\n      }\n    }\n\n    // Check Y range - The corner tile is checked here\n    if (!doneY) {\n      var col = corner.y * width;\n      for (var x = origin.x; x <= endX; ++x) {\n        if (data[col + x] !== value) {\n          doneY = true;\n          break;\n        }\n      }\n\n      if (doneY) {\n        endingIndices.push(new Cartesian2(origin.x, corner.y));\n\n        // Use the last good row so we can continue with X\n        --corner.y;\n        range.endY = corner.y;\n      } else if (corner.y === endRow) {\n        range.endY = corner.y;\n        doneY = true;\n      } else {\n        ++corner.y;\n      }\n    }\n  }\n\n  return {\n    endingIndices: endingIndices,\n    range: range,\n    value: value,\n  };\n}\n\nfunction computeAvailability(x, y, width, height, data) {\n  var ranges = [];\n\n  var singleValue = data.every(function (val) {\n    return val === data[0];\n  });\n  if (singleValue) {\n    if (data[0] === 1) {\n      ranges.push({\n        startX: x,\n        startY: y,\n        endX: x + width - 1,\n        endY: y + height - 1,\n      });\n    }\n\n    return ranges;\n  }\n\n  var positions = [new Cartesian2(0, 0)];\n  while (positions.length > 0) {\n    var origin = positions.pop();\n    var result = findRange(origin, width, height, data);\n\n    if (result.value === 1) {\n      // Convert range into the array into global tile coordinates\n      var range = result.range;\n      range.startX += x;\n      range.endX += x;\n      range.startY += y;\n      range.endY += y;\n      ranges.push(range);\n    }\n\n    var endingIndices = result.endingIndices;\n    if (endingIndices.length > 0) {\n      positions = positions.concat(endingIndices);\n    }\n  }\n\n  return ranges;\n}\n\nfunction requestAvailability(that, level, x, y) {\n  if (!that._hasAvailability) {\n    return {};\n  }\n\n  // Fetch 128x128 availability list, so we make the minimum amount of requests\n  var xOffset = Math.floor(x / 128) * 128;\n  var yOffset = Math.floor(y / 128) * 128;\n\n  var dim = Math.min(1 << level, 128);\n  var url =\n    \"tilemap/\" + level + \"/\" + yOffset + \"/\" + xOffset + \"/\" + dim + \"/\" + dim;\n\n  var availableCache = that._availableCache;\n  if (defined(availableCache[url])) {\n    return availableCache[url];\n  }\n\n  var request = new Request({\n    throttle: true,\n    throttleByServer: true,\n    type: RequestType.TERRAIN,\n  });\n\n  var tilemapResource = that._resource.getDerivedResource({\n    url: url,\n    request: request,\n  });\n\n  var promise = tilemapResource.fetchJson();\n  if (!defined(promise)) {\n    return {};\n  }\n\n  promise = promise.then(function (result) {\n    var available = computeAvailability(\n      xOffset,\n      yOffset,\n      dim,\n      dim,\n      result.data\n    );\n\n    // Mark whole area as having availability loaded\n    that._tilesAvailablityLoaded.addAvailableTileRange(\n      xOffset,\n      yOffset,\n      xOffset + dim,\n      yOffset + dim\n    );\n\n    var tilesAvailable = that._tilesAvailable;\n    for (var i = 0; i < available.length; ++i) {\n      var range = available[i];\n      tilesAvailable.addAvailableTileRange(\n        level,\n        range.startX,\n        range.startY,\n        range.endX,\n        range.endY\n      );\n    }\n\n    // Conveniently return availability of original tile\n    return isTileAvailable(that, level, x, y);\n  });\n\n  availableCache[url] = {\n    promise: promise,\n    request: request,\n  };\n\n  promise = promise.always(function (result) {\n    delete availableCache[url];\n\n    return result;\n  });\n\n  return {\n    promise: promise,\n    request: request,\n  };\n}\nexport default ArcGISTiledElevationTerrainProvider;\n"]},"metadata":{},"sourceType":"module"}