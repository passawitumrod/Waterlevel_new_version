{"ast":null,"code":"import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport CullingVolume from \"../Core/CullingVolume.js\";\nimport defined from \"../Core/defined.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport Interval from \"../Core/Interval.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport PassState from \"../Renderer/PassState.js\";\nimport Camera from \"./Camera.js\";\nimport FrustumCommands from \"./FrustumCommands.js\";\nimport GlobeDepth from \"./GlobeDepth.js\";\nimport OIT from \"./OIT.js\";\nimport PickDepthFramebuffer from \"./PickDepthFramebuffer.js\";\nimport PickFramebuffer from \"./PickFramebuffer.js\";\nimport SceneFramebuffer from \"./SceneFramebuffer.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMap from \"./ShadowMap.js\";\n/**\n * @private\n */\n\nfunction View(scene, camera, viewport) {\n  var context = scene.context;\n  var frustumCommandsList = []; // Initial guess at frustums.\n\n  var near = camera.frustum.near;\n  var far = camera.frustum.far;\n  var farToNearRatio = scene.logarithmicDepthBuffer ? scene.logarithmicDepthFarToNearRatio : scene.farToNearRatio;\n  var numFrustums = Math.ceil(Math.log(far / near) / Math.log(farToNearRatio));\n  updateFrustums(near, far, farToNearRatio, numFrustums, scene.logarithmicDepthBuffer, frustumCommandsList, false, undefined);\n  var globeDepth;\n\n  if (context.depthTexture) {\n    globeDepth = new GlobeDepth();\n  }\n\n  var oit;\n\n  if (scene._useOIT && context.depthTexture) {\n    oit = new OIT(context);\n  }\n\n  var passState = new PassState(context);\n  passState.viewport = BoundingRectangle.clone(viewport);\n  this.camera = camera;\n  this._cameraClone = Camera.clone(camera);\n  this._cameraStartFired = false;\n  this._cameraMovedTime = undefined;\n  this.viewport = viewport;\n  this.passState = passState;\n  this.pickFramebuffer = new PickFramebuffer(context);\n  this.pickDepthFramebuffer = new PickDepthFramebuffer();\n  this.sceneFramebuffer = new SceneFramebuffer();\n  this.globeDepth = globeDepth;\n  this.oit = oit;\n  this.pickDepths = [];\n  this.debugGlobeDepths = [];\n  this.frustumCommandsList = frustumCommandsList;\n  this.debugFrustumStatistics = undefined;\n  this.updateFrustums = false;\n}\n\nvar scratchPosition0 = new Cartesian3();\nvar scratchPosition1 = new Cartesian3();\n\nfunction maxComponent(a, b) {\n  var x = Math.max(Math.abs(a.x), Math.abs(b.x));\n  var y = Math.max(Math.abs(a.y), Math.abs(b.y));\n  var z = Math.max(Math.abs(a.z), Math.abs(b.z));\n  return Math.max(Math.max(x, y), z);\n}\n\nfunction cameraEqual(camera0, camera1, epsilon) {\n  var scalar = 1 / Math.max(1, maxComponent(camera0.position, camera1.position));\n  Cartesian3.multiplyByScalar(camera0.position, scalar, scratchPosition0);\n  Cartesian3.multiplyByScalar(camera1.position, scalar, scratchPosition1);\n  return Cartesian3.equalsEpsilon(scratchPosition0, scratchPosition1, epsilon) && Cartesian3.equalsEpsilon(camera0.direction, camera1.direction, epsilon) && Cartesian3.equalsEpsilon(camera0.up, camera1.up, epsilon) && Cartesian3.equalsEpsilon(camera0.right, camera1.right, epsilon) && Matrix4.equalsEpsilon(camera0.transform, camera1.transform, epsilon) && camera0.frustum.equalsEpsilon(camera1.frustum, epsilon);\n}\n\nView.prototype.checkForCameraUpdates = function (scene) {\n  var camera = this.camera;\n  var cameraClone = this._cameraClone;\n\n  if (!cameraEqual(camera, cameraClone, CesiumMath.EPSILON15)) {\n    if (!this._cameraStartFired) {\n      camera.moveStart.raiseEvent();\n      this._cameraStartFired = true;\n    }\n\n    this._cameraMovedTime = getTimestamp();\n    Camera.clone(camera, cameraClone);\n    return true;\n  }\n\n  if (this._cameraStartFired && getTimestamp() - this._cameraMovedTime > scene.cameraEventWaitTime) {\n    camera.moveEnd.raiseEvent();\n    this._cameraStartFired = false;\n  }\n\n  return false;\n};\n\nfunction updateFrustums(near, far, farToNearRatio, numFrustums, logDepth, frustumCommandsList, is2D, nearToFarDistance2D) {\n  frustumCommandsList.length = numFrustums;\n\n  for (var m = 0; m < numFrustums; ++m) {\n    var curNear;\n    var curFar;\n\n    if (is2D) {\n      curNear = Math.min(far - nearToFarDistance2D, near + m * nearToFarDistance2D);\n      curFar = Math.min(far, curNear + nearToFarDistance2D);\n    } else {\n      curNear = Math.max(near, Math.pow(farToNearRatio, m) * near);\n      curFar = farToNearRatio * curNear;\n\n      if (!logDepth) {\n        curFar = Math.min(far, curFar);\n      }\n    }\n\n    var frustumCommands = frustumCommandsList[m];\n\n    if (!defined(frustumCommands)) {\n      frustumCommands = frustumCommandsList[m] = new FrustumCommands(curNear, curFar);\n    } else {\n      frustumCommands.near = curNear;\n      frustumCommands.far = curFar;\n    }\n  }\n}\n\nfunction insertIntoBin(scene, view, command, distance) {\n  if (scene.debugShowFrustums) {\n    command.debugOverlappingFrustums = 0;\n  }\n\n  var frustumCommandsList = view.frustumCommandsList;\n  var length = frustumCommandsList.length;\n\n  for (var i = 0; i < length; ++i) {\n    var frustumCommands = frustumCommandsList[i];\n    var curNear = frustumCommands.near;\n    var curFar = frustumCommands.far;\n\n    if (distance.start > curFar) {\n      continue;\n    }\n\n    if (distance.stop < curNear) {\n      break;\n    }\n\n    var pass = command.pass;\n    var index = frustumCommands.indices[pass]++;\n    frustumCommands.commands[pass][index] = command;\n\n    if (scene.debugShowFrustums) {\n      command.debugOverlappingFrustums |= 1 << i;\n    }\n\n    if (command.executeInClosestFrustum) {\n      break;\n    }\n  }\n\n  if (scene.debugShowFrustums) {\n    var cf = view.debugFrustumStatistics.commandsInFrustums;\n    cf[command.debugOverlappingFrustums] = defined(cf[command.debugOverlappingFrustums]) ? cf[command.debugOverlappingFrustums] + 1 : 1;\n    ++view.debugFrustumStatistics.totalCommands;\n  }\n\n  scene.updateDerivedCommands(command);\n}\n\nvar scratchCullingVolume = new CullingVolume();\nvar distances = new Interval();\n\nView.prototype.createPotentiallyVisibleSet = function (scene) {\n  var frameState = scene.frameState;\n  var camera = frameState.camera;\n  var direction = camera.directionWC;\n  var position = camera.positionWC;\n  var computeList = scene._computeCommandList;\n  var overlayList = scene._overlayCommandList;\n  var commandList = frameState.commandList;\n\n  if (scene.debugShowFrustums) {\n    this.debugFrustumStatistics = {\n      totalCommands: 0,\n      commandsInFrustums: {}\n    };\n  }\n\n  var frustumCommandsList = this.frustumCommandsList;\n  var numberOfFrustums = frustumCommandsList.length;\n  var numberOfPasses = Pass.NUMBER_OF_PASSES;\n\n  for (var n = 0; n < numberOfFrustums; ++n) {\n    for (var p = 0; p < numberOfPasses; ++p) {\n      frustumCommandsList[n].indices[p] = 0;\n    }\n  }\n\n  computeList.length = 0;\n  overlayList.length = 0;\n  var near = Number.MAX_VALUE;\n  var far = -Number.MAX_VALUE;\n  var undefBV = false;\n  var shadowsEnabled = frameState.shadowState.shadowsEnabled;\n  var shadowNear = Number.MAX_VALUE;\n  var shadowFar = -Number.MAX_VALUE;\n  var shadowClosestObjectSize = Number.MAX_VALUE;\n  var occluder = frameState.mode === SceneMode.SCENE3D ? frameState.occluder : undefined;\n  var cullingVolume = frameState.cullingVolume; // get user culling volume minus the far plane.\n\n  var planes = scratchCullingVolume.planes;\n\n  for (var k = 0; k < 5; ++k) {\n    planes[k] = cullingVolume.planes[k];\n  }\n\n  cullingVolume = scratchCullingVolume;\n  var length = commandList.length;\n\n  for (var i = 0; i < length; ++i) {\n    var command = commandList[i];\n    var pass = command.pass;\n\n    if (pass === Pass.COMPUTE) {\n      computeList.push(command);\n    } else if (pass === Pass.OVERLAY) {\n      overlayList.push(command);\n    } else {\n      var boundingVolume = command.boundingVolume;\n\n      if (defined(boundingVolume)) {\n        if (!scene.isVisible(command, cullingVolume, occluder)) {\n          continue;\n        }\n\n        distances = boundingVolume.computePlaneDistances(position, direction, distances);\n        near = Math.min(near, distances.start);\n        far = Math.max(far, distances.stop); // Compute a tight near and far plane for commands that receive shadows. This helps compute\n        // good splits for cascaded shadow maps. Ignore commands that exceed the maximum distance.\n        // When moving the camera low LOD globe tiles begin to load, whose bounding volumes\n        // throw off the near/far fitting for the shadow map. Only update for globe tiles that the\n        // camera isn't inside.\n\n        if (shadowsEnabled && command.receiveShadows && distances.start < ShadowMap.MAXIMUM_DISTANCE && !(pass === Pass.GLOBE && distances.start < -100.0 && distances.stop > 100.0)) {\n          // Get the smallest bounding volume the camera is near. This is used to place more shadow detail near the object.\n          var size = distances.stop - distances.start;\n\n          if (pass !== Pass.GLOBE && distances.start < 100.0) {\n            shadowClosestObjectSize = Math.min(shadowClosestObjectSize, size);\n          }\n\n          shadowNear = Math.min(shadowNear, distances.start);\n          shadowFar = Math.max(shadowFar, distances.stop);\n        }\n      } else {\n        // Clear commands don't need a bounding volume - just add the clear to all frustums.\n        // If another command has no bounding volume, though, we need to use the camera's\n        // worst-case near and far planes to avoid clipping something important.\n        distances.start = camera.frustum.near;\n        distances.stop = camera.frustum.far;\n        undefBV = undefBV || !(command instanceof ClearCommand);\n      }\n\n      insertIntoBin(scene, this, command, distances);\n    }\n  }\n\n  if (undefBV) {\n    near = camera.frustum.near;\n    far = camera.frustum.far;\n  } else {\n    // The computed near plane must be between the user defined near and far planes.\n    // The computed far plane must between the user defined far and computed near.\n    // This will handle the case where the computed near plane is further than the user defined far plane.\n    near = Math.min(Math.max(near, camera.frustum.near), camera.frustum.far);\n    far = Math.max(Math.min(far, camera.frustum.far), near);\n\n    if (shadowsEnabled) {\n      shadowNear = Math.min(Math.max(shadowNear, camera.frustum.near), camera.frustum.far);\n      shadowFar = Math.max(Math.min(shadowFar, camera.frustum.far), shadowNear);\n    }\n  } // Use the computed near and far for shadows\n\n\n  if (shadowsEnabled) {\n    frameState.shadowState.nearPlane = shadowNear;\n    frameState.shadowState.farPlane = shadowFar;\n    frameState.shadowState.closestObjectSize = shadowClosestObjectSize;\n  } // Exploit temporal coherence. If the frustums haven't changed much, use the frustums computed\n  // last frame, else compute the new frustums and sort them by frustum again.\n\n\n  var is2D = scene.mode === SceneMode.SCENE2D;\n  var logDepth = frameState.useLogDepth;\n  var farToNearRatio = logDepth ? scene.logarithmicDepthFarToNearRatio : scene.farToNearRatio;\n  var numFrustums;\n\n  if (is2D) {\n    // The multifrustum for 2D is uniformly distributed. To avoid z-fighting in 2D,\n    // the camera is moved to just before the frustum and the frustum depth is scaled\n    // to be in [1.0, nearToFarDistance2D].\n    far = Math.min(far, camera.position.z + scene.nearToFarDistance2D);\n    near = Math.min(near, far);\n    numFrustums = Math.ceil(Math.max(1.0, far - near) / scene.nearToFarDistance2D);\n  } else {\n    // The multifrustum for 3D/CV is non-uniformly distributed.\n    numFrustums = Math.ceil(Math.log(far / near) / Math.log(farToNearRatio));\n  }\n\n  if (this.updateFrustums || near !== Number.MAX_VALUE && (numFrustums !== numberOfFrustums || frustumCommandsList.length !== 0 && (near < frustumCommandsList[0].near || far > frustumCommandsList[numberOfFrustums - 1].far && (logDepth || !CesiumMath.equalsEpsilon(far, frustumCommandsList[numberOfFrustums - 1].far, CesiumMath.EPSILON8))))) {\n    this.updateFrustums = false;\n    updateFrustums(near, far, farToNearRatio, numFrustums, logDepth, frustumCommandsList, is2D, scene.nearToFarDistance2D);\n    this.createPotentiallyVisibleSet(scene);\n  }\n\n  var frustumSplits = frameState.frustumSplits;\n  frustumSplits.length = numFrustums + 1;\n\n  for (var j = 0; j < numFrustums; ++j) {\n    frustumSplits[j] = frustumCommandsList[j].near;\n\n    if (j === numFrustums - 1) {\n      frustumSplits[j + 1] = frustumCommandsList[j].far;\n    }\n  }\n};\n\nView.prototype.destroy = function () {\n  this.pickFramebuffer = this.pickFramebuffer && this.pickFramebuffer.destroy();\n  this.pickDepthFramebuffer = this.pickDepthFramebuffer && this.pickDepthFramebuffer.destroy();\n  this.sceneFramebuffer = this.sceneFramebuffer && this.sceneFramebuffer.destroy();\n  this.globeDepth = this.globeDepth && this.globeDepth.destroy();\n  this.oit = this.oit && this.oit.destroy();\n  var i;\n  var length;\n  var pickDepths = this.pickDepths;\n  var debugGlobeDepths = this.debugGlobeDepths;\n  length = pickDepths.length;\n\n  for (i = 0; i < length; ++i) {\n    pickDepths[i].destroy();\n  }\n\n  length = debugGlobeDepths.length;\n\n  for (i = 0; i < length; ++i) {\n    debugGlobeDepths[i].destroy();\n  }\n};\n\nexport default View;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Scene/View.js"],"names":["BoundingRectangle","Cartesian3","CullingVolume","defined","getTimestamp","Interval","CesiumMath","Matrix4","ClearCommand","Pass","PassState","Camera","FrustumCommands","GlobeDepth","OIT","PickDepthFramebuffer","PickFramebuffer","SceneFramebuffer","SceneMode","ShadowMap","View","scene","camera","viewport","context","frustumCommandsList","near","frustum","far","farToNearRatio","logarithmicDepthBuffer","logarithmicDepthFarToNearRatio","numFrustums","Math","ceil","log","updateFrustums","undefined","globeDepth","depthTexture","oit","_useOIT","passState","clone","_cameraClone","_cameraStartFired","_cameraMovedTime","pickFramebuffer","pickDepthFramebuffer","sceneFramebuffer","pickDepths","debugGlobeDepths","debugFrustumStatistics","scratchPosition0","scratchPosition1","maxComponent","a","b","x","max","abs","y","z","cameraEqual","camera0","camera1","epsilon","scalar","position","multiplyByScalar","equalsEpsilon","direction","up","right","transform","prototype","checkForCameraUpdates","cameraClone","EPSILON15","moveStart","raiseEvent","cameraEventWaitTime","moveEnd","logDepth","is2D","nearToFarDistance2D","length","m","curNear","curFar","min","pow","frustumCommands","insertIntoBin","view","command","distance","debugShowFrustums","debugOverlappingFrustums","i","start","stop","pass","index","indices","commands","executeInClosestFrustum","cf","commandsInFrustums","totalCommands","updateDerivedCommands","scratchCullingVolume","distances","createPotentiallyVisibleSet","frameState","directionWC","positionWC","computeList","_computeCommandList","overlayList","_overlayCommandList","commandList","numberOfFrustums","numberOfPasses","NUMBER_OF_PASSES","n","p","Number","MAX_VALUE","undefBV","shadowsEnabled","shadowState","shadowNear","shadowFar","shadowClosestObjectSize","occluder","mode","SCENE3D","cullingVolume","planes","k","COMPUTE","push","OVERLAY","boundingVolume","isVisible","computePlaneDistances","receiveShadows","MAXIMUM_DISTANCE","GLOBE","size","nearPlane","farPlane","closestObjectSize","SCENE2D","useLogDepth","EPSILON8","frustumSplits","j","destroy"],"mappings":"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","sourcesContent":["import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport CullingVolume from \"../Core/CullingVolume.js\";\nimport defined from \"../Core/defined.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport Interval from \"../Core/Interval.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport PassState from \"../Renderer/PassState.js\";\nimport Camera from \"./Camera.js\";\nimport FrustumCommands from \"./FrustumCommands.js\";\nimport GlobeDepth from \"./GlobeDepth.js\";\nimport OIT from \"./OIT.js\";\nimport PickDepthFramebuffer from \"./PickDepthFramebuffer.js\";\nimport PickFramebuffer from \"./PickFramebuffer.js\";\nimport SceneFramebuffer from \"./SceneFramebuffer.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMap from \"./ShadowMap.js\";\n\n/**\n * @private\n */\nfunction View(scene, camera, viewport) {\n  var context = scene.context;\n\n  var frustumCommandsList = [];\n\n  // Initial guess at frustums.\n  var near = camera.frustum.near;\n  var far = camera.frustum.far;\n  var farToNearRatio = scene.logarithmicDepthBuffer\n    ? scene.logarithmicDepthFarToNearRatio\n    : scene.farToNearRatio;\n\n  var numFrustums = Math.ceil(Math.log(far / near) / Math.log(farToNearRatio));\n  updateFrustums(\n    near,\n    far,\n    farToNearRatio,\n    numFrustums,\n    scene.logarithmicDepthBuffer,\n    frustumCommandsList,\n    false,\n    undefined\n  );\n\n  var globeDepth;\n  if (context.depthTexture) {\n    globeDepth = new GlobeDepth();\n  }\n\n  var oit;\n  if (scene._useOIT && context.depthTexture) {\n    oit = new OIT(context);\n  }\n\n  var passState = new PassState(context);\n  passState.viewport = BoundingRectangle.clone(viewport);\n\n  this.camera = camera;\n  this._cameraClone = Camera.clone(camera);\n  this._cameraStartFired = false;\n  this._cameraMovedTime = undefined;\n\n  this.viewport = viewport;\n  this.passState = passState;\n  this.pickFramebuffer = new PickFramebuffer(context);\n  this.pickDepthFramebuffer = new PickDepthFramebuffer();\n  this.sceneFramebuffer = new SceneFramebuffer();\n  this.globeDepth = globeDepth;\n  this.oit = oit;\n  this.pickDepths = [];\n  this.debugGlobeDepths = [];\n  this.frustumCommandsList = frustumCommandsList;\n  this.debugFrustumStatistics = undefined;\n  this.updateFrustums = false;\n}\n\nvar scratchPosition0 = new Cartesian3();\nvar scratchPosition1 = new Cartesian3();\nfunction maxComponent(a, b) {\n  var x = Math.max(Math.abs(a.x), Math.abs(b.x));\n  var y = Math.max(Math.abs(a.y), Math.abs(b.y));\n  var z = Math.max(Math.abs(a.z), Math.abs(b.z));\n  return Math.max(Math.max(x, y), z);\n}\n\nfunction cameraEqual(camera0, camera1, epsilon) {\n  var scalar =\n    1 / Math.max(1, maxComponent(camera0.position, camera1.position));\n  Cartesian3.multiplyByScalar(camera0.position, scalar, scratchPosition0);\n  Cartesian3.multiplyByScalar(camera1.position, scalar, scratchPosition1);\n  return (\n    Cartesian3.equalsEpsilon(scratchPosition0, scratchPosition1, epsilon) &&\n    Cartesian3.equalsEpsilon(camera0.direction, camera1.direction, epsilon) &&\n    Cartesian3.equalsEpsilon(camera0.up, camera1.up, epsilon) &&\n    Cartesian3.equalsEpsilon(camera0.right, camera1.right, epsilon) &&\n    Matrix4.equalsEpsilon(camera0.transform, camera1.transform, epsilon) &&\n    camera0.frustum.equalsEpsilon(camera1.frustum, epsilon)\n  );\n}\n\nView.prototype.checkForCameraUpdates = function (scene) {\n  var camera = this.camera;\n  var cameraClone = this._cameraClone;\n  if (!cameraEqual(camera, cameraClone, CesiumMath.EPSILON15)) {\n    if (!this._cameraStartFired) {\n      camera.moveStart.raiseEvent();\n      this._cameraStartFired = true;\n    }\n    this._cameraMovedTime = getTimestamp();\n    Camera.clone(camera, cameraClone);\n\n    return true;\n  }\n\n  if (\n    this._cameraStartFired &&\n    getTimestamp() - this._cameraMovedTime > scene.cameraEventWaitTime\n  ) {\n    camera.moveEnd.raiseEvent();\n    this._cameraStartFired = false;\n  }\n\n  return false;\n};\n\nfunction updateFrustums(\n  near,\n  far,\n  farToNearRatio,\n  numFrustums,\n  logDepth,\n  frustumCommandsList,\n  is2D,\n  nearToFarDistance2D\n) {\n  frustumCommandsList.length = numFrustums;\n  for (var m = 0; m < numFrustums; ++m) {\n    var curNear;\n    var curFar;\n\n    if (is2D) {\n      curNear = Math.min(\n        far - nearToFarDistance2D,\n        near + m * nearToFarDistance2D\n      );\n      curFar = Math.min(far, curNear + nearToFarDistance2D);\n    } else {\n      curNear = Math.max(near, Math.pow(farToNearRatio, m) * near);\n      curFar = farToNearRatio * curNear;\n      if (!logDepth) {\n        curFar = Math.min(far, curFar);\n      }\n    }\n\n    var frustumCommands = frustumCommandsList[m];\n    if (!defined(frustumCommands)) {\n      frustumCommands = frustumCommandsList[m] = new FrustumCommands(\n        curNear,\n        curFar\n      );\n    } else {\n      frustumCommands.near = curNear;\n      frustumCommands.far = curFar;\n    }\n  }\n}\n\nfunction insertIntoBin(scene, view, command, distance) {\n  if (scene.debugShowFrustums) {\n    command.debugOverlappingFrustums = 0;\n  }\n\n  var frustumCommandsList = view.frustumCommandsList;\n  var length = frustumCommandsList.length;\n\n  for (var i = 0; i < length; ++i) {\n    var frustumCommands = frustumCommandsList[i];\n    var curNear = frustumCommands.near;\n    var curFar = frustumCommands.far;\n\n    if (distance.start > curFar) {\n      continue;\n    }\n\n    if (distance.stop < curNear) {\n      break;\n    }\n\n    var pass = command.pass;\n    var index = frustumCommands.indices[pass]++;\n    frustumCommands.commands[pass][index] = command;\n\n    if (scene.debugShowFrustums) {\n      command.debugOverlappingFrustums |= 1 << i;\n    }\n\n    if (command.executeInClosestFrustum) {\n      break;\n    }\n  }\n\n  if (scene.debugShowFrustums) {\n    var cf = view.debugFrustumStatistics.commandsInFrustums;\n    cf[command.debugOverlappingFrustums] = defined(\n      cf[command.debugOverlappingFrustums]\n    )\n      ? cf[command.debugOverlappingFrustums] + 1\n      : 1;\n    ++view.debugFrustumStatistics.totalCommands;\n  }\n\n  scene.updateDerivedCommands(command);\n}\n\nvar scratchCullingVolume = new CullingVolume();\nvar distances = new Interval();\n\nView.prototype.createPotentiallyVisibleSet = function (scene) {\n  var frameState = scene.frameState;\n  var camera = frameState.camera;\n  var direction = camera.directionWC;\n  var position = camera.positionWC;\n\n  var computeList = scene._computeCommandList;\n  var overlayList = scene._overlayCommandList;\n  var commandList = frameState.commandList;\n\n  if (scene.debugShowFrustums) {\n    this.debugFrustumStatistics = {\n      totalCommands: 0,\n      commandsInFrustums: {},\n    };\n  }\n\n  var frustumCommandsList = this.frustumCommandsList;\n  var numberOfFrustums = frustumCommandsList.length;\n  var numberOfPasses = Pass.NUMBER_OF_PASSES;\n  for (var n = 0; n < numberOfFrustums; ++n) {\n    for (var p = 0; p < numberOfPasses; ++p) {\n      frustumCommandsList[n].indices[p] = 0;\n    }\n  }\n\n  computeList.length = 0;\n  overlayList.length = 0;\n\n  var near = Number.MAX_VALUE;\n  var far = -Number.MAX_VALUE;\n  var undefBV = false;\n\n  var shadowsEnabled = frameState.shadowState.shadowsEnabled;\n  var shadowNear = Number.MAX_VALUE;\n  var shadowFar = -Number.MAX_VALUE;\n  var shadowClosestObjectSize = Number.MAX_VALUE;\n\n  var occluder =\n    frameState.mode === SceneMode.SCENE3D ? frameState.occluder : undefined;\n  var cullingVolume = frameState.cullingVolume;\n\n  // get user culling volume minus the far plane.\n  var planes = scratchCullingVolume.planes;\n  for (var k = 0; k < 5; ++k) {\n    planes[k] = cullingVolume.planes[k];\n  }\n  cullingVolume = scratchCullingVolume;\n\n  var length = commandList.length;\n  for (var i = 0; i < length; ++i) {\n    var command = commandList[i];\n    var pass = command.pass;\n\n    if (pass === Pass.COMPUTE) {\n      computeList.push(command);\n    } else if (pass === Pass.OVERLAY) {\n      overlayList.push(command);\n    } else {\n      var boundingVolume = command.boundingVolume;\n      if (defined(boundingVolume)) {\n        if (!scene.isVisible(command, cullingVolume, occluder)) {\n          continue;\n        }\n\n        distances = boundingVolume.computePlaneDistances(\n          position,\n          direction,\n          distances\n        );\n        near = Math.min(near, distances.start);\n        far = Math.max(far, distances.stop);\n\n        // Compute a tight near and far plane for commands that receive shadows. This helps compute\n        // good splits for cascaded shadow maps. Ignore commands that exceed the maximum distance.\n        // When moving the camera low LOD globe tiles begin to load, whose bounding volumes\n        // throw off the near/far fitting for the shadow map. Only update for globe tiles that the\n        // camera isn't inside.\n        if (\n          shadowsEnabled &&\n          command.receiveShadows &&\n          distances.start < ShadowMap.MAXIMUM_DISTANCE &&\n          !(\n            pass === Pass.GLOBE &&\n            distances.start < -100.0 &&\n            distances.stop > 100.0\n          )\n        ) {\n          // Get the smallest bounding volume the camera is near. This is used to place more shadow detail near the object.\n          var size = distances.stop - distances.start;\n          if (pass !== Pass.GLOBE && distances.start < 100.0) {\n            shadowClosestObjectSize = Math.min(shadowClosestObjectSize, size);\n          }\n          shadowNear = Math.min(shadowNear, distances.start);\n          shadowFar = Math.max(shadowFar, distances.stop);\n        }\n      } else {\n        // Clear commands don't need a bounding volume - just add the clear to all frustums.\n        // If another command has no bounding volume, though, we need to use the camera's\n        // worst-case near and far planes to avoid clipping something important.\n        distances.start = camera.frustum.near;\n        distances.stop = camera.frustum.far;\n        undefBV = undefBV || !(command instanceof ClearCommand);\n      }\n\n      insertIntoBin(scene, this, command, distances);\n    }\n  }\n\n  if (undefBV) {\n    near = camera.frustum.near;\n    far = camera.frustum.far;\n  } else {\n    // The computed near plane must be between the user defined near and far planes.\n    // The computed far plane must between the user defined far and computed near.\n    // This will handle the case where the computed near plane is further than the user defined far plane.\n    near = Math.min(Math.max(near, camera.frustum.near), camera.frustum.far);\n    far = Math.max(Math.min(far, camera.frustum.far), near);\n\n    if (shadowsEnabled) {\n      shadowNear = Math.min(\n        Math.max(shadowNear, camera.frustum.near),\n        camera.frustum.far\n      );\n      shadowFar = Math.max(Math.min(shadowFar, camera.frustum.far), shadowNear);\n    }\n  }\n\n  // Use the computed near and far for shadows\n  if (shadowsEnabled) {\n    frameState.shadowState.nearPlane = shadowNear;\n    frameState.shadowState.farPlane = shadowFar;\n    frameState.shadowState.closestObjectSize = shadowClosestObjectSize;\n  }\n\n  // Exploit temporal coherence. If the frustums haven't changed much, use the frustums computed\n  // last frame, else compute the new frustums and sort them by frustum again.\n  var is2D = scene.mode === SceneMode.SCENE2D;\n  var logDepth = frameState.useLogDepth;\n  var farToNearRatio = logDepth\n    ? scene.logarithmicDepthFarToNearRatio\n    : scene.farToNearRatio;\n  var numFrustums;\n\n  if (is2D) {\n    // The multifrustum for 2D is uniformly distributed. To avoid z-fighting in 2D,\n    // the camera is moved to just before the frustum and the frustum depth is scaled\n    // to be in [1.0, nearToFarDistance2D].\n    far = Math.min(far, camera.position.z + scene.nearToFarDistance2D);\n    near = Math.min(near, far);\n    numFrustums = Math.ceil(\n      Math.max(1.0, far - near) / scene.nearToFarDistance2D\n    );\n  } else {\n    // The multifrustum for 3D/CV is non-uniformly distributed.\n    numFrustums = Math.ceil(Math.log(far / near) / Math.log(farToNearRatio));\n  }\n\n  if (\n    this.updateFrustums ||\n    (near !== Number.MAX_VALUE &&\n      (numFrustums !== numberOfFrustums ||\n        (frustumCommandsList.length !== 0 &&\n          (near < frustumCommandsList[0].near ||\n            (far > frustumCommandsList[numberOfFrustums - 1].far &&\n              (logDepth ||\n                !CesiumMath.equalsEpsilon(\n                  far,\n                  frustumCommandsList[numberOfFrustums - 1].far,\n                  CesiumMath.EPSILON8\n                )))))))\n  ) {\n    this.updateFrustums = false;\n    updateFrustums(\n      near,\n      far,\n      farToNearRatio,\n      numFrustums,\n      logDepth,\n      frustumCommandsList,\n      is2D,\n      scene.nearToFarDistance2D\n    );\n    this.createPotentiallyVisibleSet(scene);\n  }\n\n  var frustumSplits = frameState.frustumSplits;\n  frustumSplits.length = numFrustums + 1;\n  for (var j = 0; j < numFrustums; ++j) {\n    frustumSplits[j] = frustumCommandsList[j].near;\n    if (j === numFrustums - 1) {\n      frustumSplits[j + 1] = frustumCommandsList[j].far;\n    }\n  }\n};\n\nView.prototype.destroy = function () {\n  this.pickFramebuffer = this.pickFramebuffer && this.pickFramebuffer.destroy();\n  this.pickDepthFramebuffer =\n    this.pickDepthFramebuffer && this.pickDepthFramebuffer.destroy();\n  this.sceneFramebuffer =\n    this.sceneFramebuffer && this.sceneFramebuffer.destroy();\n  this.globeDepth = this.globeDepth && this.globeDepth.destroy();\n  this.oit = this.oit && this.oit.destroy();\n\n  var i;\n  var length;\n\n  var pickDepths = this.pickDepths;\n  var debugGlobeDepths = this.debugGlobeDepths;\n\n  length = pickDepths.length;\n  for (i = 0; i < length; ++i) {\n    pickDepths[i].destroy();\n  }\n\n  length = debugGlobeDepths.length;\n  for (i = 0; i < length; ++i) {\n    debugGlobeDepths[i].destroy();\n  }\n};\nexport default View;\n"]},"metadata":{},"sourceType":"module"}