{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Geometry from \"../Core/Geometry.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Buffer from \"./Buffer.js\";\nimport BufferUsage from \"./BufferUsage.js\";\nimport ContextLimits from \"./ContextLimits.js\";\n\nfunction addAttribute(attributes, attribute, index, context) {\n  var hasVertexBuffer = defined(attribute.vertexBuffer);\n  var hasValue = defined(attribute.value);\n  var componentsPerAttribute = attribute.value ? attribute.value.length : attribute.componentsPerAttribute; //>>includeStart('debug', pragmas.debug);\n\n  if (!hasVertexBuffer && !hasValue) {\n    throw new DeveloperError(\"attribute must have a vertexBuffer or a value.\");\n  }\n\n  if (hasVertexBuffer && hasValue) {\n    throw new DeveloperError(\"attribute cannot have both a vertexBuffer and a value.  It must have either a vertexBuffer property defining per-vertex data or a value property defining data for all vertices.\");\n  }\n\n  if (componentsPerAttribute !== 1 && componentsPerAttribute !== 2 && componentsPerAttribute !== 3 && componentsPerAttribute !== 4) {\n    if (hasValue) {\n      throw new DeveloperError(\"attribute.value.length must be in the range [1, 4].\");\n    }\n\n    throw new DeveloperError(\"attribute.componentsPerAttribute must be in the range [1, 4].\");\n  }\n\n  if (defined(attribute.componentDatatype) && !ComponentDatatype.validate(attribute.componentDatatype)) {\n    throw new DeveloperError(\"attribute must have a valid componentDatatype or not specify it.\");\n  }\n\n  if (defined(attribute.strideInBytes) && attribute.strideInBytes > 255) {\n    // WebGL limit.  Not in GL ES.\n    throw new DeveloperError(\"attribute must have a strideInBytes less than or equal to 255 or not specify it.\");\n  }\n\n  if (defined(attribute.instanceDivisor) && attribute.instanceDivisor > 0 && !context.instancedArrays) {\n    throw new DeveloperError(\"instanced arrays is not supported\");\n  }\n\n  if (defined(attribute.instanceDivisor) && attribute.instanceDivisor < 0) {\n    throw new DeveloperError(\"attribute must have an instanceDivisor greater than or equal to zero\");\n  }\n\n  if (defined(attribute.instanceDivisor) && hasValue) {\n    throw new DeveloperError(\"attribute cannot have have an instanceDivisor if it is not backed by a buffer\");\n  }\n\n  if (defined(attribute.instanceDivisor) && attribute.instanceDivisor > 0 && attribute.index === 0) {\n    throw new DeveloperError(\"attribute zero cannot have an instanceDivisor greater than 0\");\n  } //>>includeEnd('debug');\n  // Shallow copy the attribute; we do not want to copy the vertex buffer.\n\n\n  var attr = {\n    index: defaultValue(attribute.index, index),\n    enabled: defaultValue(attribute.enabled, true),\n    vertexBuffer: attribute.vertexBuffer,\n    value: hasValue ? attribute.value.slice(0) : undefined,\n    componentsPerAttribute: componentsPerAttribute,\n    componentDatatype: defaultValue(attribute.componentDatatype, ComponentDatatype.FLOAT),\n    normalize: defaultValue(attribute.normalize, false),\n    offsetInBytes: defaultValue(attribute.offsetInBytes, 0),\n    strideInBytes: defaultValue(attribute.strideInBytes, 0),\n    instanceDivisor: defaultValue(attribute.instanceDivisor, 0)\n  };\n\n  if (hasVertexBuffer) {\n    // Common case: vertex buffer for per-vertex data\n    attr.vertexAttrib = function (gl) {\n      var index = this.index;\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer._getBuffer());\n      gl.vertexAttribPointer(index, this.componentsPerAttribute, this.componentDatatype, this.normalize, this.strideInBytes, this.offsetInBytes);\n      gl.enableVertexAttribArray(index);\n\n      if (this.instanceDivisor > 0) {\n        context.glVertexAttribDivisor(index, this.instanceDivisor);\n        context._vertexAttribDivisors[index] = this.instanceDivisor;\n        context._previousDrawInstanced = true;\n      }\n    };\n\n    attr.disableVertexAttribArray = function (gl) {\n      gl.disableVertexAttribArray(this.index);\n\n      if (this.instanceDivisor > 0) {\n        context.glVertexAttribDivisor(index, 0);\n      }\n    };\n  } else {\n    // Less common case: value array for the same data for each vertex\n    switch (attr.componentsPerAttribute) {\n      case 1:\n        attr.vertexAttrib = function (gl) {\n          gl.vertexAttrib1fv(this.index, this.value);\n        };\n\n        break;\n\n      case 2:\n        attr.vertexAttrib = function (gl) {\n          gl.vertexAttrib2fv(this.index, this.value);\n        };\n\n        break;\n\n      case 3:\n        attr.vertexAttrib = function (gl) {\n          gl.vertexAttrib3fv(this.index, this.value);\n        };\n\n        break;\n\n      case 4:\n        attr.vertexAttrib = function (gl) {\n          gl.vertexAttrib4fv(this.index, this.value);\n        };\n\n        break;\n    }\n\n    attr.disableVertexAttribArray = function (gl) {};\n  }\n\n  attributes.push(attr);\n}\n\nfunction bind(gl, attributes, indexBuffer) {\n  for (var i = 0; i < attributes.length; ++i) {\n    var attribute = attributes[i];\n\n    if (attribute.enabled) {\n      attribute.vertexAttrib(gl);\n    }\n  }\n\n  if (defined(indexBuffer)) {\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer._getBuffer());\n  }\n}\n/**\n * Creates a vertex array, which defines the attributes making up a vertex, and contains an optional index buffer\n * to select vertices for rendering.  Attributes are defined using object literals as shown in Example 1 below.\n *\n * @param {Object} options Object with the following properties:\n * @param {Context} options.context The context in which the VertexArray gets created.\n * @param {Object[]} options.attributes An array of attributes.\n * @param {IndexBuffer} [options.indexBuffer] An optional index buffer.\n *\n * @returns {VertexArray} The vertex array, ready for use with drawing.\n *\n * @exception {DeveloperError} Attribute must have a <code>vertexBuffer</code>.\n * @exception {DeveloperError} Attribute must have a <code>componentsPerAttribute</code>.\n * @exception {DeveloperError} Attribute must have a valid <code>componentDatatype</code> or not specify it.\n * @exception {DeveloperError} Attribute must have a <code>strideInBytes</code> less than or equal to 255 or not specify it.\n * @exception {DeveloperError} Index n is used by more than one attribute.\n *\n *\n * @example\n * // Example 1. Create a vertex array with vertices made up of three floating point\n * // values, e.g., a position, from a single vertex buffer.  No index buffer is used.\n * var positionBuffer = Buffer.createVertexBuffer({\n *     context : context,\n *     sizeInBytes : 12,\n *     usage : BufferUsage.STATIC_DRAW\n * });\n * var attributes = [\n *     {\n *         index                  : 0,\n *         enabled                : true,\n *         vertexBuffer           : positionBuffer,\n *         componentsPerAttribute : 3,\n *         componentDatatype      : ComponentDatatype.FLOAT,\n *         normalize              : false,\n *         offsetInBytes          : 0,\n *         strideInBytes          : 0 // tightly packed\n *         instanceDivisor        : 0 // not instanced\n *     }\n * ];\n * var va = new VertexArray({\n *     context : context,\n *     attributes : attributes\n * });\n *\n * @example\n * // Example 2. Create a vertex array with vertices from two different vertex buffers.\n * // Each vertex has a three-component position and three-component normal.\n * var positionBuffer = Buffer.createVertexBuffer({\n *     context : context,\n *     sizeInBytes : 12,\n *     usage : BufferUsage.STATIC_DRAW\n * });\n * var normalBuffer = Buffer.createVertexBuffer({\n *     context : context,\n *     sizeInBytes : 12,\n *     usage : BufferUsage.STATIC_DRAW\n * });\n * var attributes = [\n *     {\n *         index                  : 0,\n *         vertexBuffer           : positionBuffer,\n *         componentsPerAttribute : 3,\n *         componentDatatype      : ComponentDatatype.FLOAT\n *     },\n *     {\n *         index                  : 1,\n *         vertexBuffer           : normalBuffer,\n *         componentsPerAttribute : 3,\n *         componentDatatype      : ComponentDatatype.FLOAT\n *     }\n * ];\n * var va = new VertexArray({\n *     context : context,\n *     attributes : attributes\n * });\n *\n * @example\n * // Example 3. Creates the same vertex layout as Example 2 using a single\n * // vertex buffer, instead of two.\n * var buffer = Buffer.createVertexBuffer({\n *     context : context,\n *     sizeInBytes : 24,\n *     usage : BufferUsage.STATIC_DRAW\n * });\n * var attributes = [\n *     {\n *         vertexBuffer           : buffer,\n *         componentsPerAttribute : 3,\n *         componentDatatype      : ComponentDatatype.FLOAT,\n *         offsetInBytes          : 0,\n *         strideInBytes          : 24\n *     },\n *     {\n *         vertexBuffer           : buffer,\n *         componentsPerAttribute : 3,\n *         componentDatatype      : ComponentDatatype.FLOAT,\n *         normalize              : true,\n *         offsetInBytes          : 12,\n *         strideInBytes          : 24\n *     }\n * ];\n * var va = new VertexArray({\n *     context : context,\n *     attributes : attributes\n * });\n *\n * @see Buffer#createVertexBuffer\n * @see Buffer#createIndexBuffer\n * @see Context#draw\n *\n * @private\n */\n\n\nfunction VertexArray(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);\n\n  Check.defined(\"options.context\", options.context);\n  Check.defined(\"options.attributes\", options.attributes); //>>includeEnd('debug');\n\n  var context = options.context;\n  var gl = context._gl;\n  var attributes = options.attributes;\n  var indexBuffer = options.indexBuffer;\n  var i;\n  var vaAttributes = [];\n  var numberOfVertices = 1; // if every attribute is backed by a single value\n\n  var hasInstancedAttributes = false;\n  var hasConstantAttributes = false;\n  var length = attributes.length;\n\n  for (i = 0; i < length; ++i) {\n    addAttribute(vaAttributes, attributes[i], i, context);\n  }\n\n  length = vaAttributes.length;\n\n  for (i = 0; i < length; ++i) {\n    var attribute = vaAttributes[i];\n\n    if (defined(attribute.vertexBuffer) && attribute.instanceDivisor === 0) {\n      // This assumes that each vertex buffer in the vertex array has the same number of vertices.\n      var bytes = attribute.strideInBytes || attribute.componentsPerAttribute * ComponentDatatype.getSizeInBytes(attribute.componentDatatype);\n      numberOfVertices = attribute.vertexBuffer.sizeInBytes / bytes;\n      break;\n    }\n  }\n\n  for (i = 0; i < length; ++i) {\n    if (vaAttributes[i].instanceDivisor > 0) {\n      hasInstancedAttributes = true;\n    }\n\n    if (defined(vaAttributes[i].value)) {\n      hasConstantAttributes = true;\n    }\n  } //>>includeStart('debug', pragmas.debug);\n  // Verify all attribute names are unique\n\n\n  var uniqueIndices = {};\n\n  for (i = 0; i < length; ++i) {\n    var index = vaAttributes[i].index;\n\n    if (uniqueIndices[index]) {\n      throw new DeveloperError(\"Index \" + index + \" is used by more than one attribute.\");\n    }\n\n    uniqueIndices[index] = true;\n  } //>>includeEnd('debug');\n\n\n  var vao; // Setup VAO if supported\n\n  if (context.vertexArrayObject) {\n    vao = context.glCreateVertexArray();\n    context.glBindVertexArray(vao);\n    bind(gl, vaAttributes, indexBuffer);\n    context.glBindVertexArray(null);\n  }\n\n  this._numberOfVertices = numberOfVertices;\n  this._hasInstancedAttributes = hasInstancedAttributes;\n  this._hasConstantAttributes = hasConstantAttributes;\n  this._context = context;\n  this._gl = gl;\n  this._vao = vao;\n  this._attributes = vaAttributes;\n  this._indexBuffer = indexBuffer;\n}\n\nfunction computeNumberOfVertices(attribute) {\n  return attribute.values.length / attribute.componentsPerAttribute;\n}\n\nfunction computeAttributeSizeInBytes(attribute) {\n  return ComponentDatatype.getSizeInBytes(attribute.componentDatatype) * attribute.componentsPerAttribute;\n}\n\nfunction interleaveAttributes(attributes) {\n  var j;\n  var name;\n  var attribute; // Extract attribute names.\n\n  var names = [];\n\n  for (name in attributes) {\n    // Attribute needs to have per-vertex values; not a constant value for all vertices.\n    if (attributes.hasOwnProperty(name) && defined(attributes[name]) && defined(attributes[name].values)) {\n      names.push(name);\n\n      if (attributes[name].componentDatatype === ComponentDatatype.DOUBLE) {\n        attributes[name].componentDatatype = ComponentDatatype.FLOAT;\n        attributes[name].values = ComponentDatatype.createTypedArray(ComponentDatatype.FLOAT, attributes[name].values);\n      }\n    }\n  } // Validation.  Compute number of vertices.\n\n\n  var numberOfVertices;\n  var namesLength = names.length;\n\n  if (namesLength > 0) {\n    numberOfVertices = computeNumberOfVertices(attributes[names[0]]);\n\n    for (j = 1; j < namesLength; ++j) {\n      var currentNumberOfVertices = computeNumberOfVertices(attributes[names[j]]);\n\n      if (currentNumberOfVertices !== numberOfVertices) {\n        throw new RuntimeError(\"Each attribute list must have the same number of vertices.  \" + \"Attribute \" + names[j] + \" has a different number of vertices \" + \"(\" + currentNumberOfVertices.toString() + \")\" + \" than attribute \" + names[0] + \" (\" + numberOfVertices.toString() + \").\");\n      }\n    }\n  } // Sort attributes by the size of their components.  From left to right, a vertex stores floats, shorts, and then bytes.\n\n\n  names.sort(function (left, right) {\n    return ComponentDatatype.getSizeInBytes(attributes[right].componentDatatype) - ComponentDatatype.getSizeInBytes(attributes[left].componentDatatype);\n  }); // Compute sizes and strides.\n\n  var vertexSizeInBytes = 0;\n  var offsetsInBytes = {};\n\n  for (j = 0; j < namesLength; ++j) {\n    name = names[j];\n    attribute = attributes[name];\n    offsetsInBytes[name] = vertexSizeInBytes;\n    vertexSizeInBytes += computeAttributeSizeInBytes(attribute);\n  }\n\n  if (vertexSizeInBytes > 0) {\n    // Pad each vertex to be a multiple of the largest component datatype so each\n    // attribute can be addressed using typed arrays.\n    var maxComponentSizeInBytes = ComponentDatatype.getSizeInBytes(attributes[names[0]].componentDatatype); // Sorted large to small\n\n    var remainder = vertexSizeInBytes % maxComponentSizeInBytes;\n\n    if (remainder !== 0) {\n      vertexSizeInBytes += maxComponentSizeInBytes - remainder;\n    } // Total vertex buffer size in bytes, including per-vertex padding.\n\n\n    var vertexBufferSizeInBytes = numberOfVertices * vertexSizeInBytes; // Create array for interleaved vertices.  Each attribute has a different view (pointer) into the array.\n\n    var buffer = new ArrayBuffer(vertexBufferSizeInBytes);\n    var views = {};\n\n    for (j = 0; j < namesLength; ++j) {\n      name = names[j];\n      var sizeInBytes = ComponentDatatype.getSizeInBytes(attributes[name].componentDatatype);\n      views[name] = {\n        pointer: ComponentDatatype.createTypedArray(attributes[name].componentDatatype, buffer),\n        index: offsetsInBytes[name] / sizeInBytes,\n        // Offset in ComponentType\n        strideInComponentType: vertexSizeInBytes / sizeInBytes\n      };\n    } // Copy attributes into one interleaved array.\n    // PERFORMANCE_IDEA:  Can we optimize these loops?\n\n\n    for (j = 0; j < numberOfVertices; ++j) {\n      for (var n = 0; n < namesLength; ++n) {\n        name = names[n];\n        attribute = attributes[name];\n        var values = attribute.values;\n        var view = views[name];\n        var pointer = view.pointer;\n        var numberOfComponents = attribute.componentsPerAttribute;\n\n        for (var k = 0; k < numberOfComponents; ++k) {\n          pointer[view.index + k] = values[j * numberOfComponents + k];\n        }\n\n        view.index += view.strideInComponentType;\n      }\n    }\n\n    return {\n      buffer: buffer,\n      offsetsInBytes: offsetsInBytes,\n      vertexSizeInBytes: vertexSizeInBytes\n    };\n  } // No attributes to interleave.\n\n\n  return undefined;\n}\n/**\n * Creates a vertex array from a geometry.  A geometry contains vertex attributes and optional index data\n * in system memory, whereas a vertex array contains vertex buffers and an optional index buffer in WebGL\n * memory for use with rendering.\n * <br /><br />\n * The <code>geometry</code> argument should use the standard layout like the geometry returned by {@link BoxGeometry}.\n * <br /><br />\n * <code>options</code> can have four properties:\n * <ul>\n *   <li><code>geometry</code>:  The source geometry containing data used to create the vertex array.</li>\n *   <li><code>attributeLocations</code>:  An object that maps geometry attribute names to vertex shader attribute locations.</li>\n *   <li><code>bufferUsage</code>:  The expected usage pattern of the vertex array's buffers.  On some WebGL implementations, this can significantly affect performance.  See {@link BufferUsage}.  Default: <code>BufferUsage.DYNAMIC_DRAW</code>.</li>\n *   <li><code>interleave</code>:  Determines if all attributes are interleaved in a single vertex buffer or if each attribute is stored in a separate vertex buffer.  Default: <code>false</code>.</li>\n * </ul>\n * <br />\n * If <code>options</code> is not specified or the <code>geometry</code> contains no data, the returned vertex array is empty.\n *\n * @param {Object} options An object defining the geometry, attribute indices, buffer usage, and vertex layout used to create the vertex array.\n *\n * @exception {RuntimeError} Each attribute list must have the same number of vertices.\n * @exception {DeveloperError} The geometry must have zero or one index lists.\n * @exception {DeveloperError} Index n is used by more than one attribute.\n *\n *\n * @example\n * // Example 1. Creates a vertex array for rendering a box.  The default dynamic draw\n * // usage is used for the created vertex and index buffer.  The attributes are not\n * // interleaved by default.\n * var geometry = new BoxGeometry();\n * var va = VertexArray.fromGeometry({\n *     context            : context,\n *     geometry           : geometry,\n *     attributeLocations : GeometryPipeline.createAttributeLocations(geometry),\n * });\n *\n * @example\n * // Example 2. Creates a vertex array with interleaved attributes in a\n * // single vertex buffer.  The vertex and index buffer have static draw usage.\n * var va = VertexArray.fromGeometry({\n *     context            : context,\n *     geometry           : geometry,\n *     attributeLocations : GeometryPipeline.createAttributeLocations(geometry),\n *     bufferUsage        : BufferUsage.STATIC_DRAW,\n *     interleave         : true\n * });\n *\n * @example\n * // Example 3.  When the caller destroys the vertex array, it also destroys the\n * // attached vertex buffer(s) and index buffer.\n * va = va.destroy();\n *\n * @see Buffer#createVertexBuffer\n * @see Buffer#createIndexBuffer\n * @see GeometryPipeline.createAttributeLocations\n * @see ShaderProgram\n */\n\n\nVertexArray.fromGeometry = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);\n\n  Check.defined(\"options.context\", options.context); //>>includeEnd('debug');\n\n  var context = options.context;\n  var geometry = defaultValue(options.geometry, defaultValue.EMPTY_OBJECT);\n  var bufferUsage = defaultValue(options.bufferUsage, BufferUsage.DYNAMIC_DRAW);\n  var attributeLocations = defaultValue(options.attributeLocations, defaultValue.EMPTY_OBJECT);\n  var interleave = defaultValue(options.interleave, false);\n  var createdVAAttributes = options.vertexArrayAttributes;\n  var name;\n  var attribute;\n  var vertexBuffer;\n  var vaAttributes = defined(createdVAAttributes) ? createdVAAttributes : [];\n  var attributes = geometry.attributes;\n\n  if (interleave) {\n    // Use a single vertex buffer with interleaved vertices.\n    var interleavedAttributes = interleaveAttributes(attributes);\n\n    if (defined(interleavedAttributes)) {\n      vertexBuffer = Buffer.createVertexBuffer({\n        context: context,\n        typedArray: interleavedAttributes.buffer,\n        usage: bufferUsage\n      });\n      var offsetsInBytes = interleavedAttributes.offsetsInBytes;\n      var strideInBytes = interleavedAttributes.vertexSizeInBytes;\n\n      for (name in attributes) {\n        if (attributes.hasOwnProperty(name) && defined(attributes[name])) {\n          attribute = attributes[name];\n\n          if (defined(attribute.values)) {\n            // Common case: per-vertex attributes\n            vaAttributes.push({\n              index: attributeLocations[name],\n              vertexBuffer: vertexBuffer,\n              componentDatatype: attribute.componentDatatype,\n              componentsPerAttribute: attribute.componentsPerAttribute,\n              normalize: attribute.normalize,\n              offsetInBytes: offsetsInBytes[name],\n              strideInBytes: strideInBytes\n            });\n          } else {\n            // Constant attribute for all vertices\n            vaAttributes.push({\n              index: attributeLocations[name],\n              value: attribute.value,\n              componentDatatype: attribute.componentDatatype,\n              normalize: attribute.normalize\n            });\n          }\n        }\n      }\n    }\n  } else {\n    // One vertex buffer per attribute.\n    for (name in attributes) {\n      if (attributes.hasOwnProperty(name) && defined(attributes[name])) {\n        attribute = attributes[name];\n        var componentDatatype = attribute.componentDatatype;\n\n        if (componentDatatype === ComponentDatatype.DOUBLE) {\n          componentDatatype = ComponentDatatype.FLOAT;\n        }\n\n        vertexBuffer = undefined;\n\n        if (defined(attribute.values)) {\n          vertexBuffer = Buffer.createVertexBuffer({\n            context: context,\n            typedArray: ComponentDatatype.createTypedArray(componentDatatype, attribute.values),\n            usage: bufferUsage\n          });\n        }\n\n        vaAttributes.push({\n          index: attributeLocations[name],\n          vertexBuffer: vertexBuffer,\n          value: attribute.value,\n          componentDatatype: componentDatatype,\n          componentsPerAttribute: attribute.componentsPerAttribute,\n          normalize: attribute.normalize\n        });\n      }\n    }\n  }\n\n  var indexBuffer;\n  var indices = geometry.indices;\n\n  if (defined(indices)) {\n    if (Geometry.computeNumberOfVertices(geometry) >= CesiumMath.SIXTY_FOUR_KILOBYTES && context.elementIndexUint) {\n      indexBuffer = Buffer.createIndexBuffer({\n        context: context,\n        typedArray: new Uint32Array(indices),\n        usage: bufferUsage,\n        indexDatatype: IndexDatatype.UNSIGNED_INT\n      });\n    } else {\n      indexBuffer = Buffer.createIndexBuffer({\n        context: context,\n        typedArray: new Uint16Array(indices),\n        usage: bufferUsage,\n        indexDatatype: IndexDatatype.UNSIGNED_SHORT\n      });\n    }\n  }\n\n  return new VertexArray({\n    context: context,\n    attributes: vaAttributes,\n    indexBuffer: indexBuffer\n  });\n};\n\nObject.defineProperties(VertexArray.prototype, {\n  numberOfAttributes: {\n    get: function () {\n      return this._attributes.length;\n    }\n  },\n  numberOfVertices: {\n    get: function () {\n      return this._numberOfVertices;\n    }\n  },\n  indexBuffer: {\n    get: function () {\n      return this._indexBuffer;\n    }\n  }\n});\n/**\n * index is the location in the array of attributes, not the index property of an attribute.\n */\n\nVertexArray.prototype.getAttribute = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"index\", index); //>>includeEnd('debug');\n\n  return this._attributes[index];\n}; // Workaround for ANGLE, where the attribute divisor seems to be part of the global state instead\n// of the VAO state. This function is called when the vao is bound, and should be removed\n// once the ANGLE issue is resolved. Setting the divisor should normally happen in vertexAttrib and\n// disableVertexAttribArray.\n\n\nfunction setVertexAttribDivisor(vertexArray) {\n  var context = vertexArray._context;\n  var hasInstancedAttributes = vertexArray._hasInstancedAttributes;\n\n  if (!hasInstancedAttributes && !context._previousDrawInstanced) {\n    return;\n  }\n\n  context._previousDrawInstanced = hasInstancedAttributes;\n  var divisors = context._vertexAttribDivisors;\n  var attributes = vertexArray._attributes;\n  var maxAttributes = ContextLimits.maximumVertexAttributes;\n  var i;\n\n  if (hasInstancedAttributes) {\n    var length = attributes.length;\n\n    for (i = 0; i < length; ++i) {\n      var attribute = attributes[i];\n\n      if (attribute.enabled) {\n        var divisor = attribute.instanceDivisor;\n        var index = attribute.index;\n\n        if (divisor !== divisors[index]) {\n          context.glVertexAttribDivisor(index, divisor);\n          divisors[index] = divisor;\n        }\n      }\n    }\n  } else {\n    for (i = 0; i < maxAttributes; ++i) {\n      if (divisors[i] > 0) {\n        context.glVertexAttribDivisor(i, 0);\n        divisors[i] = 0;\n      }\n    }\n  }\n} // Vertex attributes backed by a constant value go through vertexAttrib[1234]f[v]\n// which is part of context state rather than VAO state.\n\n\nfunction setConstantAttributes(vertexArray, gl) {\n  var attributes = vertexArray._attributes;\n  var length = attributes.length;\n\n  for (var i = 0; i < length; ++i) {\n    var attribute = attributes[i];\n\n    if (attribute.enabled && defined(attribute.value)) {\n      attribute.vertexAttrib(gl);\n    }\n  }\n}\n\nVertexArray.prototype._bind = function () {\n  if (defined(this._vao)) {\n    this._context.glBindVertexArray(this._vao);\n\n    if (this._context.instancedArrays) {\n      setVertexAttribDivisor(this);\n    }\n\n    if (this._hasConstantAttributes) {\n      setConstantAttributes(this, this._gl);\n    }\n  } else {\n    bind(this._gl, this._attributes, this._indexBuffer);\n  }\n};\n\nVertexArray.prototype._unBind = function () {\n  if (defined(this._vao)) {\n    this._context.glBindVertexArray(null);\n  } else {\n    var attributes = this._attributes;\n    var gl = this._gl;\n\n    for (var i = 0; i < attributes.length; ++i) {\n      var attribute = attributes[i];\n\n      if (attribute.enabled) {\n        attribute.disableVertexAttribArray(gl);\n      }\n    }\n\n    if (this._indexBuffer) {\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    }\n  }\n};\n\nVertexArray.prototype.isDestroyed = function () {\n  return false;\n};\n\nVertexArray.prototype.destroy = function () {\n  var attributes = this._attributes;\n\n  for (var i = 0; i < attributes.length; ++i) {\n    var vertexBuffer = attributes[i].vertexBuffer;\n\n    if (defined(vertexBuffer) && !vertexBuffer.isDestroyed() && vertexBuffer.vertexArrayDestroyable) {\n      vertexBuffer.destroy();\n    }\n  }\n\n  var indexBuffer = this._indexBuffer;\n\n  if (defined(indexBuffer) && !indexBuffer.isDestroyed() && indexBuffer.vertexArrayDestroyable) {\n    indexBuffer.destroy();\n  }\n\n  if (defined(this._vao)) {\n    this._context.glDeleteVertexArray(this._vao);\n  }\n\n  return destroyObject(this);\n};\n\nexport default VertexArray;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Renderer/VertexArray.js"],"names":["Check","ComponentDatatype","defaultValue","defined","destroyObject","DeveloperError","Geometry","IndexDatatype","CesiumMath","RuntimeError","Buffer","BufferUsage","ContextLimits","addAttribute","attributes","attribute","index","context","hasVertexBuffer","vertexBuffer","hasValue","value","componentsPerAttribute","length","componentDatatype","validate","strideInBytes","instanceDivisor","instancedArrays","attr","enabled","slice","undefined","FLOAT","normalize","offsetInBytes","vertexAttrib","gl","bindBuffer","ARRAY_BUFFER","_getBuffer","vertexAttribPointer","enableVertexAttribArray","glVertexAttribDivisor","_vertexAttribDivisors","_previousDrawInstanced","disableVertexAttribArray","vertexAttrib1fv","vertexAttrib2fv","vertexAttrib3fv","vertexAttrib4fv","push","bind","indexBuffer","i","ELEMENT_ARRAY_BUFFER","VertexArray","options","EMPTY_OBJECT","_gl","vaAttributes","numberOfVertices","hasInstancedAttributes","hasConstantAttributes","bytes","getSizeInBytes","sizeInBytes","uniqueIndices","vao","vertexArrayObject","glCreateVertexArray","glBindVertexArray","_numberOfVertices","_hasInstancedAttributes","_hasConstantAttributes","_context","_vao","_attributes","_indexBuffer","computeNumberOfVertices","values","computeAttributeSizeInBytes","interleaveAttributes","j","name","names","hasOwnProperty","DOUBLE","createTypedArray","namesLength","currentNumberOfVertices","toString","sort","left","right","vertexSizeInBytes","offsetsInBytes","maxComponentSizeInBytes","remainder","vertexBufferSizeInBytes","buffer","ArrayBuffer","views","pointer","strideInComponentType","n","view","numberOfComponents","k","fromGeometry","geometry","bufferUsage","DYNAMIC_DRAW","attributeLocations","interleave","createdVAAttributes","vertexArrayAttributes","interleavedAttributes","createVertexBuffer","typedArray","usage","indices","SIXTY_FOUR_KILOBYTES","elementIndexUint","createIndexBuffer","Uint32Array","indexDatatype","UNSIGNED_INT","Uint16Array","UNSIGNED_SHORT","Object","defineProperties","prototype","numberOfAttributes","get","getAttribute","setVertexAttribDivisor","vertexArray","divisors","maxAttributes","maximumVertexAttributes","divisor","setConstantAttributes","_bind","_unBind","isDestroyed","destroy","vertexArrayDestroyable","glDeleteVertexArray"],"mappings":"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","sourcesContent":["import Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Geometry from \"../Core/Geometry.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Buffer from \"./Buffer.js\";\nimport BufferUsage from \"./BufferUsage.js\";\nimport ContextLimits from \"./ContextLimits.js\";\n\nfunction addAttribute(attributes, attribute, index, context) {\n  var hasVertexBuffer = defined(attribute.vertexBuffer);\n  var hasValue = defined(attribute.value);\n  var componentsPerAttribute = attribute.value\n    ? attribute.value.length\n    : attribute.componentsPerAttribute;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!hasVertexBuffer && !hasValue) {\n    throw new DeveloperError(\"attribute must have a vertexBuffer or a value.\");\n  }\n  if (hasVertexBuffer && hasValue) {\n    throw new DeveloperError(\n      \"attribute cannot have both a vertexBuffer and a value.  It must have either a vertexBuffer property defining per-vertex data or a value property defining data for all vertices.\"\n    );\n  }\n  if (\n    componentsPerAttribute !== 1 &&\n    componentsPerAttribute !== 2 &&\n    componentsPerAttribute !== 3 &&\n    componentsPerAttribute !== 4\n  ) {\n    if (hasValue) {\n      throw new DeveloperError(\n        \"attribute.value.length must be in the range [1, 4].\"\n      );\n    }\n\n    throw new DeveloperError(\n      \"attribute.componentsPerAttribute must be in the range [1, 4].\"\n    );\n  }\n  if (\n    defined(attribute.componentDatatype) &&\n    !ComponentDatatype.validate(attribute.componentDatatype)\n  ) {\n    throw new DeveloperError(\n      \"attribute must have a valid componentDatatype or not specify it.\"\n    );\n  }\n  if (defined(attribute.strideInBytes) && attribute.strideInBytes > 255) {\n    // WebGL limit.  Not in GL ES.\n    throw new DeveloperError(\n      \"attribute must have a strideInBytes less than or equal to 255 or not specify it.\"\n    );\n  }\n  if (\n    defined(attribute.instanceDivisor) &&\n    attribute.instanceDivisor > 0 &&\n    !context.instancedArrays\n  ) {\n    throw new DeveloperError(\"instanced arrays is not supported\");\n  }\n  if (defined(attribute.instanceDivisor) && attribute.instanceDivisor < 0) {\n    throw new DeveloperError(\n      \"attribute must have an instanceDivisor greater than or equal to zero\"\n    );\n  }\n  if (defined(attribute.instanceDivisor) && hasValue) {\n    throw new DeveloperError(\n      \"attribute cannot have have an instanceDivisor if it is not backed by a buffer\"\n    );\n  }\n  if (\n    defined(attribute.instanceDivisor) &&\n    attribute.instanceDivisor > 0 &&\n    attribute.index === 0\n  ) {\n    throw new DeveloperError(\n      \"attribute zero cannot have an instanceDivisor greater than 0\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  // Shallow copy the attribute; we do not want to copy the vertex buffer.\n  var attr = {\n    index: defaultValue(attribute.index, index),\n    enabled: defaultValue(attribute.enabled, true),\n    vertexBuffer: attribute.vertexBuffer,\n    value: hasValue ? attribute.value.slice(0) : undefined,\n    componentsPerAttribute: componentsPerAttribute,\n    componentDatatype: defaultValue(\n      attribute.componentDatatype,\n      ComponentDatatype.FLOAT\n    ),\n    normalize: defaultValue(attribute.normalize, false),\n    offsetInBytes: defaultValue(attribute.offsetInBytes, 0),\n    strideInBytes: defaultValue(attribute.strideInBytes, 0),\n    instanceDivisor: defaultValue(attribute.instanceDivisor, 0),\n  };\n\n  if (hasVertexBuffer) {\n    // Common case: vertex buffer for per-vertex data\n    attr.vertexAttrib = function (gl) {\n      var index = this.index;\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer._getBuffer());\n      gl.vertexAttribPointer(\n        index,\n        this.componentsPerAttribute,\n        this.componentDatatype,\n        this.normalize,\n        this.strideInBytes,\n        this.offsetInBytes\n      );\n      gl.enableVertexAttribArray(index);\n      if (this.instanceDivisor > 0) {\n        context.glVertexAttribDivisor(index, this.instanceDivisor);\n        context._vertexAttribDivisors[index] = this.instanceDivisor;\n        context._previousDrawInstanced = true;\n      }\n    };\n\n    attr.disableVertexAttribArray = function (gl) {\n      gl.disableVertexAttribArray(this.index);\n      if (this.instanceDivisor > 0) {\n        context.glVertexAttribDivisor(index, 0);\n      }\n    };\n  } else {\n    // Less common case: value array for the same data for each vertex\n    switch (attr.componentsPerAttribute) {\n      case 1:\n        attr.vertexAttrib = function (gl) {\n          gl.vertexAttrib1fv(this.index, this.value);\n        };\n        break;\n      case 2:\n        attr.vertexAttrib = function (gl) {\n          gl.vertexAttrib2fv(this.index, this.value);\n        };\n        break;\n      case 3:\n        attr.vertexAttrib = function (gl) {\n          gl.vertexAttrib3fv(this.index, this.value);\n        };\n        break;\n      case 4:\n        attr.vertexAttrib = function (gl) {\n          gl.vertexAttrib4fv(this.index, this.value);\n        };\n        break;\n    }\n\n    attr.disableVertexAttribArray = function (gl) {};\n  }\n\n  attributes.push(attr);\n}\n\nfunction bind(gl, attributes, indexBuffer) {\n  for (var i = 0; i < attributes.length; ++i) {\n    var attribute = attributes[i];\n    if (attribute.enabled) {\n      attribute.vertexAttrib(gl);\n    }\n  }\n\n  if (defined(indexBuffer)) {\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer._getBuffer());\n  }\n}\n\n/**\n * Creates a vertex array, which defines the attributes making up a vertex, and contains an optional index buffer\n * to select vertices for rendering.  Attributes are defined using object literals as shown in Example 1 below.\n *\n * @param {Object} options Object with the following properties:\n * @param {Context} options.context The context in which the VertexArray gets created.\n * @param {Object[]} options.attributes An array of attributes.\n * @param {IndexBuffer} [options.indexBuffer] An optional index buffer.\n *\n * @returns {VertexArray} The vertex array, ready for use with drawing.\n *\n * @exception {DeveloperError} Attribute must have a <code>vertexBuffer</code>.\n * @exception {DeveloperError} Attribute must have a <code>componentsPerAttribute</code>.\n * @exception {DeveloperError} Attribute must have a valid <code>componentDatatype</code> or not specify it.\n * @exception {DeveloperError} Attribute must have a <code>strideInBytes</code> less than or equal to 255 or not specify it.\n * @exception {DeveloperError} Index n is used by more than one attribute.\n *\n *\n * @example\n * // Example 1. Create a vertex array with vertices made up of three floating point\n * // values, e.g., a position, from a single vertex buffer.  No index buffer is used.\n * var positionBuffer = Buffer.createVertexBuffer({\n *     context : context,\n *     sizeInBytes : 12,\n *     usage : BufferUsage.STATIC_DRAW\n * });\n * var attributes = [\n *     {\n *         index                  : 0,\n *         enabled                : true,\n *         vertexBuffer           : positionBuffer,\n *         componentsPerAttribute : 3,\n *         componentDatatype      : ComponentDatatype.FLOAT,\n *         normalize              : false,\n *         offsetInBytes          : 0,\n *         strideInBytes          : 0 // tightly packed\n *         instanceDivisor        : 0 // not instanced\n *     }\n * ];\n * var va = new VertexArray({\n *     context : context,\n *     attributes : attributes\n * });\n *\n * @example\n * // Example 2. Create a vertex array with vertices from two different vertex buffers.\n * // Each vertex has a three-component position and three-component normal.\n * var positionBuffer = Buffer.createVertexBuffer({\n *     context : context,\n *     sizeInBytes : 12,\n *     usage : BufferUsage.STATIC_DRAW\n * });\n * var normalBuffer = Buffer.createVertexBuffer({\n *     context : context,\n *     sizeInBytes : 12,\n *     usage : BufferUsage.STATIC_DRAW\n * });\n * var attributes = [\n *     {\n *         index                  : 0,\n *         vertexBuffer           : positionBuffer,\n *         componentsPerAttribute : 3,\n *         componentDatatype      : ComponentDatatype.FLOAT\n *     },\n *     {\n *         index                  : 1,\n *         vertexBuffer           : normalBuffer,\n *         componentsPerAttribute : 3,\n *         componentDatatype      : ComponentDatatype.FLOAT\n *     }\n * ];\n * var va = new VertexArray({\n *     context : context,\n *     attributes : attributes\n * });\n *\n * @example\n * // Example 3. Creates the same vertex layout as Example 2 using a single\n * // vertex buffer, instead of two.\n * var buffer = Buffer.createVertexBuffer({\n *     context : context,\n *     sizeInBytes : 24,\n *     usage : BufferUsage.STATIC_DRAW\n * });\n * var attributes = [\n *     {\n *         vertexBuffer           : buffer,\n *         componentsPerAttribute : 3,\n *         componentDatatype      : ComponentDatatype.FLOAT,\n *         offsetInBytes          : 0,\n *         strideInBytes          : 24\n *     },\n *     {\n *         vertexBuffer           : buffer,\n *         componentsPerAttribute : 3,\n *         componentDatatype      : ComponentDatatype.FLOAT,\n *         normalize              : true,\n *         offsetInBytes          : 12,\n *         strideInBytes          : 24\n *     }\n * ];\n * var va = new VertexArray({\n *     context : context,\n *     attributes : attributes\n * });\n *\n * @see Buffer#createVertexBuffer\n * @see Buffer#createIndexBuffer\n * @see Context#draw\n *\n * @private\n */\nfunction VertexArray(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n  Check.defined(\"options.attributes\", options.attributes);\n  //>>includeEnd('debug');\n\n  var context = options.context;\n  var gl = context._gl;\n  var attributes = options.attributes;\n  var indexBuffer = options.indexBuffer;\n\n  var i;\n  var vaAttributes = [];\n  var numberOfVertices = 1; // if every attribute is backed by a single value\n  var hasInstancedAttributes = false;\n  var hasConstantAttributes = false;\n\n  var length = attributes.length;\n  for (i = 0; i < length; ++i) {\n    addAttribute(vaAttributes, attributes[i], i, context);\n  }\n\n  length = vaAttributes.length;\n  for (i = 0; i < length; ++i) {\n    var attribute = vaAttributes[i];\n\n    if (defined(attribute.vertexBuffer) && attribute.instanceDivisor === 0) {\n      // This assumes that each vertex buffer in the vertex array has the same number of vertices.\n      var bytes =\n        attribute.strideInBytes ||\n        attribute.componentsPerAttribute *\n          ComponentDatatype.getSizeInBytes(attribute.componentDatatype);\n      numberOfVertices = attribute.vertexBuffer.sizeInBytes / bytes;\n      break;\n    }\n  }\n\n  for (i = 0; i < length; ++i) {\n    if (vaAttributes[i].instanceDivisor > 0) {\n      hasInstancedAttributes = true;\n    }\n    if (defined(vaAttributes[i].value)) {\n      hasConstantAttributes = true;\n    }\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  // Verify all attribute names are unique\n  var uniqueIndices = {};\n  for (i = 0; i < length; ++i) {\n    var index = vaAttributes[i].index;\n    if (uniqueIndices[index]) {\n      throw new DeveloperError(\n        \"Index \" + index + \" is used by more than one attribute.\"\n      );\n    }\n    uniqueIndices[index] = true;\n  }\n  //>>includeEnd('debug');\n\n  var vao;\n\n  // Setup VAO if supported\n  if (context.vertexArrayObject) {\n    vao = context.glCreateVertexArray();\n    context.glBindVertexArray(vao);\n    bind(gl, vaAttributes, indexBuffer);\n    context.glBindVertexArray(null);\n  }\n\n  this._numberOfVertices = numberOfVertices;\n  this._hasInstancedAttributes = hasInstancedAttributes;\n  this._hasConstantAttributes = hasConstantAttributes;\n  this._context = context;\n  this._gl = gl;\n  this._vao = vao;\n  this._attributes = vaAttributes;\n  this._indexBuffer = indexBuffer;\n}\n\nfunction computeNumberOfVertices(attribute) {\n  return attribute.values.length / attribute.componentsPerAttribute;\n}\n\nfunction computeAttributeSizeInBytes(attribute) {\n  return (\n    ComponentDatatype.getSizeInBytes(attribute.componentDatatype) *\n    attribute.componentsPerAttribute\n  );\n}\n\nfunction interleaveAttributes(attributes) {\n  var j;\n  var name;\n  var attribute;\n\n  // Extract attribute names.\n  var names = [];\n  for (name in attributes) {\n    // Attribute needs to have per-vertex values; not a constant value for all vertices.\n    if (\n      attributes.hasOwnProperty(name) &&\n      defined(attributes[name]) &&\n      defined(attributes[name].values)\n    ) {\n      names.push(name);\n\n      if (attributes[name].componentDatatype === ComponentDatatype.DOUBLE) {\n        attributes[name].componentDatatype = ComponentDatatype.FLOAT;\n        attributes[name].values = ComponentDatatype.createTypedArray(\n          ComponentDatatype.FLOAT,\n          attributes[name].values\n        );\n      }\n    }\n  }\n\n  // Validation.  Compute number of vertices.\n  var numberOfVertices;\n  var namesLength = names.length;\n\n  if (namesLength > 0) {\n    numberOfVertices = computeNumberOfVertices(attributes[names[0]]);\n\n    for (j = 1; j < namesLength; ++j) {\n      var currentNumberOfVertices = computeNumberOfVertices(\n        attributes[names[j]]\n      );\n\n      if (currentNumberOfVertices !== numberOfVertices) {\n        throw new RuntimeError(\n          \"Each attribute list must have the same number of vertices.  \" +\n            \"Attribute \" +\n            names[j] +\n            \" has a different number of vertices \" +\n            \"(\" +\n            currentNumberOfVertices.toString() +\n            \")\" +\n            \" than attribute \" +\n            names[0] +\n            \" (\" +\n            numberOfVertices.toString() +\n            \").\"\n        );\n      }\n    }\n  }\n\n  // Sort attributes by the size of their components.  From left to right, a vertex stores floats, shorts, and then bytes.\n  names.sort(function (left, right) {\n    return (\n      ComponentDatatype.getSizeInBytes(attributes[right].componentDatatype) -\n      ComponentDatatype.getSizeInBytes(attributes[left].componentDatatype)\n    );\n  });\n\n  // Compute sizes and strides.\n  var vertexSizeInBytes = 0;\n  var offsetsInBytes = {};\n\n  for (j = 0; j < namesLength; ++j) {\n    name = names[j];\n    attribute = attributes[name];\n\n    offsetsInBytes[name] = vertexSizeInBytes;\n    vertexSizeInBytes += computeAttributeSizeInBytes(attribute);\n  }\n\n  if (vertexSizeInBytes > 0) {\n    // Pad each vertex to be a multiple of the largest component datatype so each\n    // attribute can be addressed using typed arrays.\n    var maxComponentSizeInBytes = ComponentDatatype.getSizeInBytes(\n      attributes[names[0]].componentDatatype\n    ); // Sorted large to small\n    var remainder = vertexSizeInBytes % maxComponentSizeInBytes;\n    if (remainder !== 0) {\n      vertexSizeInBytes += maxComponentSizeInBytes - remainder;\n    }\n\n    // Total vertex buffer size in bytes, including per-vertex padding.\n    var vertexBufferSizeInBytes = numberOfVertices * vertexSizeInBytes;\n\n    // Create array for interleaved vertices.  Each attribute has a different view (pointer) into the array.\n    var buffer = new ArrayBuffer(vertexBufferSizeInBytes);\n    var views = {};\n\n    for (j = 0; j < namesLength; ++j) {\n      name = names[j];\n      var sizeInBytes = ComponentDatatype.getSizeInBytes(\n        attributes[name].componentDatatype\n      );\n\n      views[name] = {\n        pointer: ComponentDatatype.createTypedArray(\n          attributes[name].componentDatatype,\n          buffer\n        ),\n        index: offsetsInBytes[name] / sizeInBytes, // Offset in ComponentType\n        strideInComponentType: vertexSizeInBytes / sizeInBytes,\n      };\n    }\n\n    // Copy attributes into one interleaved array.\n    // PERFORMANCE_IDEA:  Can we optimize these loops?\n    for (j = 0; j < numberOfVertices; ++j) {\n      for (var n = 0; n < namesLength; ++n) {\n        name = names[n];\n        attribute = attributes[name];\n        var values = attribute.values;\n        var view = views[name];\n        var pointer = view.pointer;\n\n        var numberOfComponents = attribute.componentsPerAttribute;\n        for (var k = 0; k < numberOfComponents; ++k) {\n          pointer[view.index + k] = values[j * numberOfComponents + k];\n        }\n\n        view.index += view.strideInComponentType;\n      }\n    }\n\n    return {\n      buffer: buffer,\n      offsetsInBytes: offsetsInBytes,\n      vertexSizeInBytes: vertexSizeInBytes,\n    };\n  }\n\n  // No attributes to interleave.\n  return undefined;\n}\n\n/**\n * Creates a vertex array from a geometry.  A geometry contains vertex attributes and optional index data\n * in system memory, whereas a vertex array contains vertex buffers and an optional index buffer in WebGL\n * memory for use with rendering.\n * <br /><br />\n * The <code>geometry</code> argument should use the standard layout like the geometry returned by {@link BoxGeometry}.\n * <br /><br />\n * <code>options</code> can have four properties:\n * <ul>\n *   <li><code>geometry</code>:  The source geometry containing data used to create the vertex array.</li>\n *   <li><code>attributeLocations</code>:  An object that maps geometry attribute names to vertex shader attribute locations.</li>\n *   <li><code>bufferUsage</code>:  The expected usage pattern of the vertex array's buffers.  On some WebGL implementations, this can significantly affect performance.  See {@link BufferUsage}.  Default: <code>BufferUsage.DYNAMIC_DRAW</code>.</li>\n *   <li><code>interleave</code>:  Determines if all attributes are interleaved in a single vertex buffer or if each attribute is stored in a separate vertex buffer.  Default: <code>false</code>.</li>\n * </ul>\n * <br />\n * If <code>options</code> is not specified or the <code>geometry</code> contains no data, the returned vertex array is empty.\n *\n * @param {Object} options An object defining the geometry, attribute indices, buffer usage, and vertex layout used to create the vertex array.\n *\n * @exception {RuntimeError} Each attribute list must have the same number of vertices.\n * @exception {DeveloperError} The geometry must have zero or one index lists.\n * @exception {DeveloperError} Index n is used by more than one attribute.\n *\n *\n * @example\n * // Example 1. Creates a vertex array for rendering a box.  The default dynamic draw\n * // usage is used for the created vertex and index buffer.  The attributes are not\n * // interleaved by default.\n * var geometry = new BoxGeometry();\n * var va = VertexArray.fromGeometry({\n *     context            : context,\n *     geometry           : geometry,\n *     attributeLocations : GeometryPipeline.createAttributeLocations(geometry),\n * });\n *\n * @example\n * // Example 2. Creates a vertex array with interleaved attributes in a\n * // single vertex buffer.  The vertex and index buffer have static draw usage.\n * var va = VertexArray.fromGeometry({\n *     context            : context,\n *     geometry           : geometry,\n *     attributeLocations : GeometryPipeline.createAttributeLocations(geometry),\n *     bufferUsage        : BufferUsage.STATIC_DRAW,\n *     interleave         : true\n * });\n *\n * @example\n * // Example 3.  When the caller destroys the vertex array, it also destroys the\n * // attached vertex buffer(s) and index buffer.\n * va = va.destroy();\n *\n * @see Buffer#createVertexBuffer\n * @see Buffer#createIndexBuffer\n * @see GeometryPipeline.createAttributeLocations\n * @see ShaderProgram\n */\nVertexArray.fromGeometry = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n  //>>includeEnd('debug');\n\n  var context = options.context;\n  var geometry = defaultValue(options.geometry, defaultValue.EMPTY_OBJECT);\n\n  var bufferUsage = defaultValue(options.bufferUsage, BufferUsage.DYNAMIC_DRAW);\n\n  var attributeLocations = defaultValue(\n    options.attributeLocations,\n    defaultValue.EMPTY_OBJECT\n  );\n  var interleave = defaultValue(options.interleave, false);\n  var createdVAAttributes = options.vertexArrayAttributes;\n\n  var name;\n  var attribute;\n  var vertexBuffer;\n  var vaAttributes = defined(createdVAAttributes) ? createdVAAttributes : [];\n  var attributes = geometry.attributes;\n\n  if (interleave) {\n    // Use a single vertex buffer with interleaved vertices.\n    var interleavedAttributes = interleaveAttributes(attributes);\n    if (defined(interleavedAttributes)) {\n      vertexBuffer = Buffer.createVertexBuffer({\n        context: context,\n        typedArray: interleavedAttributes.buffer,\n        usage: bufferUsage,\n      });\n      var offsetsInBytes = interleavedAttributes.offsetsInBytes;\n      var strideInBytes = interleavedAttributes.vertexSizeInBytes;\n\n      for (name in attributes) {\n        if (attributes.hasOwnProperty(name) && defined(attributes[name])) {\n          attribute = attributes[name];\n\n          if (defined(attribute.values)) {\n            // Common case: per-vertex attributes\n            vaAttributes.push({\n              index: attributeLocations[name],\n              vertexBuffer: vertexBuffer,\n              componentDatatype: attribute.componentDatatype,\n              componentsPerAttribute: attribute.componentsPerAttribute,\n              normalize: attribute.normalize,\n              offsetInBytes: offsetsInBytes[name],\n              strideInBytes: strideInBytes,\n            });\n          } else {\n            // Constant attribute for all vertices\n            vaAttributes.push({\n              index: attributeLocations[name],\n              value: attribute.value,\n              componentDatatype: attribute.componentDatatype,\n              normalize: attribute.normalize,\n            });\n          }\n        }\n      }\n    }\n  } else {\n    // One vertex buffer per attribute.\n    for (name in attributes) {\n      if (attributes.hasOwnProperty(name) && defined(attributes[name])) {\n        attribute = attributes[name];\n\n        var componentDatatype = attribute.componentDatatype;\n        if (componentDatatype === ComponentDatatype.DOUBLE) {\n          componentDatatype = ComponentDatatype.FLOAT;\n        }\n\n        vertexBuffer = undefined;\n        if (defined(attribute.values)) {\n          vertexBuffer = Buffer.createVertexBuffer({\n            context: context,\n            typedArray: ComponentDatatype.createTypedArray(\n              componentDatatype,\n              attribute.values\n            ),\n            usage: bufferUsage,\n          });\n        }\n\n        vaAttributes.push({\n          index: attributeLocations[name],\n          vertexBuffer: vertexBuffer,\n          value: attribute.value,\n          componentDatatype: componentDatatype,\n          componentsPerAttribute: attribute.componentsPerAttribute,\n          normalize: attribute.normalize,\n        });\n      }\n    }\n  }\n\n  var indexBuffer;\n  var indices = geometry.indices;\n  if (defined(indices)) {\n    if (\n      Geometry.computeNumberOfVertices(geometry) >=\n        CesiumMath.SIXTY_FOUR_KILOBYTES &&\n      context.elementIndexUint\n    ) {\n      indexBuffer = Buffer.createIndexBuffer({\n        context: context,\n        typedArray: new Uint32Array(indices),\n        usage: bufferUsage,\n        indexDatatype: IndexDatatype.UNSIGNED_INT,\n      });\n    } else {\n      indexBuffer = Buffer.createIndexBuffer({\n        context: context,\n        typedArray: new Uint16Array(indices),\n        usage: bufferUsage,\n        indexDatatype: IndexDatatype.UNSIGNED_SHORT,\n      });\n    }\n  }\n\n  return new VertexArray({\n    context: context,\n    attributes: vaAttributes,\n    indexBuffer: indexBuffer,\n  });\n};\n\nObject.defineProperties(VertexArray.prototype, {\n  numberOfAttributes: {\n    get: function () {\n      return this._attributes.length;\n    },\n  },\n  numberOfVertices: {\n    get: function () {\n      return this._numberOfVertices;\n    },\n  },\n  indexBuffer: {\n    get: function () {\n      return this._indexBuffer;\n    },\n  },\n});\n\n/**\n * index is the location in the array of attributes, not the index property of an attribute.\n */\nVertexArray.prototype.getAttribute = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"index\", index);\n  //>>includeEnd('debug');\n\n  return this._attributes[index];\n};\n\n// Workaround for ANGLE, where the attribute divisor seems to be part of the global state instead\n// of the VAO state. This function is called when the vao is bound, and should be removed\n// once the ANGLE issue is resolved. Setting the divisor should normally happen in vertexAttrib and\n// disableVertexAttribArray.\nfunction setVertexAttribDivisor(vertexArray) {\n  var context = vertexArray._context;\n  var hasInstancedAttributes = vertexArray._hasInstancedAttributes;\n  if (!hasInstancedAttributes && !context._previousDrawInstanced) {\n    return;\n  }\n  context._previousDrawInstanced = hasInstancedAttributes;\n\n  var divisors = context._vertexAttribDivisors;\n  var attributes = vertexArray._attributes;\n  var maxAttributes = ContextLimits.maximumVertexAttributes;\n  var i;\n\n  if (hasInstancedAttributes) {\n    var length = attributes.length;\n    for (i = 0; i < length; ++i) {\n      var attribute = attributes[i];\n      if (attribute.enabled) {\n        var divisor = attribute.instanceDivisor;\n        var index = attribute.index;\n        if (divisor !== divisors[index]) {\n          context.glVertexAttribDivisor(index, divisor);\n          divisors[index] = divisor;\n        }\n      }\n    }\n  } else {\n    for (i = 0; i < maxAttributes; ++i) {\n      if (divisors[i] > 0) {\n        context.glVertexAttribDivisor(i, 0);\n        divisors[i] = 0;\n      }\n    }\n  }\n}\n\n// Vertex attributes backed by a constant value go through vertexAttrib[1234]f[v]\n// which is part of context state rather than VAO state.\nfunction setConstantAttributes(vertexArray, gl) {\n  var attributes = vertexArray._attributes;\n  var length = attributes.length;\n  for (var i = 0; i < length; ++i) {\n    var attribute = attributes[i];\n    if (attribute.enabled && defined(attribute.value)) {\n      attribute.vertexAttrib(gl);\n    }\n  }\n}\n\nVertexArray.prototype._bind = function () {\n  if (defined(this._vao)) {\n    this._context.glBindVertexArray(this._vao);\n    if (this._context.instancedArrays) {\n      setVertexAttribDivisor(this);\n    }\n    if (this._hasConstantAttributes) {\n      setConstantAttributes(this, this._gl);\n    }\n  } else {\n    bind(this._gl, this._attributes, this._indexBuffer);\n  }\n};\n\nVertexArray.prototype._unBind = function () {\n  if (defined(this._vao)) {\n    this._context.glBindVertexArray(null);\n  } else {\n    var attributes = this._attributes;\n    var gl = this._gl;\n\n    for (var i = 0; i < attributes.length; ++i) {\n      var attribute = attributes[i];\n      if (attribute.enabled) {\n        attribute.disableVertexAttribArray(gl);\n      }\n    }\n    if (this._indexBuffer) {\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    }\n  }\n};\n\nVertexArray.prototype.isDestroyed = function () {\n  return false;\n};\n\nVertexArray.prototype.destroy = function () {\n  var attributes = this._attributes;\n  for (var i = 0; i < attributes.length; ++i) {\n    var vertexBuffer = attributes[i].vertexBuffer;\n    if (\n      defined(vertexBuffer) &&\n      !vertexBuffer.isDestroyed() &&\n      vertexBuffer.vertexArrayDestroyable\n    ) {\n      vertexBuffer.destroy();\n    }\n  }\n\n  var indexBuffer = this._indexBuffer;\n  if (\n    defined(indexBuffer) &&\n    !indexBuffer.isDestroyed() &&\n    indexBuffer.vertexArrayDestroyable\n  ) {\n    indexBuffer.destroy();\n  }\n\n  if (defined(this._vao)) {\n    this._context.glDeleteVertexArray(this._vao);\n  }\n\n  return destroyObject(this);\n};\nexport default VertexArray;\n"]},"metadata":{},"sourceType":"module"}