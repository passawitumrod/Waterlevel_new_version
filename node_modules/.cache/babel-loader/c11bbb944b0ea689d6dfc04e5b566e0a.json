{"ast":null,"code":"import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport Simon1994PlanetaryPositions from \"../Core/Simon1994PlanetaryPositions.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport SunLight from \"../Scene/SunLight.js\";\n/**\n * @private\n * @constructor\n */\n\nfunction UniformState() {\n  /**\n   * @type {Texture}\n   */\n  this.globeDepthTexture = undefined;\n  /**\n   * @type {Number}\n   */\n\n  this.gamma = undefined;\n  this._viewport = new BoundingRectangle();\n  this._viewportCartesian4 = new Cartesian4();\n  this._viewportDirty = false;\n  this._viewportOrthographicMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this._viewportTransformation = Matrix4.clone(Matrix4.IDENTITY);\n  this._model = Matrix4.clone(Matrix4.IDENTITY);\n  this._view = Matrix4.clone(Matrix4.IDENTITY);\n  this._inverseView = Matrix4.clone(Matrix4.IDENTITY);\n  this._projection = Matrix4.clone(Matrix4.IDENTITY);\n  this._infiniteProjection = Matrix4.clone(Matrix4.IDENTITY);\n  this._entireFrustum = new Cartesian2();\n  this._currentFrustum = new Cartesian2();\n  this._frustumPlanes = new Cartesian4();\n  this._farDepthFromNearPlusOne = undefined;\n  this._log2FarDepthFromNearPlusOne = undefined;\n  this._oneOverLog2FarDepthFromNearPlusOne = undefined;\n  this._frameState = undefined;\n  this._temeToPseudoFixed = Matrix3.clone(Matrix4.IDENTITY); // Derived members\n\n  this._view3DDirty = true;\n  this._view3D = new Matrix4();\n  this._inverseView3DDirty = true;\n  this._inverseView3D = new Matrix4();\n  this._inverseModelDirty = true;\n  this._inverseModel = new Matrix4();\n  this._inverseTransposeModelDirty = true;\n  this._inverseTransposeModel = new Matrix3();\n  this._viewRotation = new Matrix3();\n  this._inverseViewRotation = new Matrix3();\n  this._viewRotation3D = new Matrix3();\n  this._inverseViewRotation3D = new Matrix3();\n  this._inverseProjectionDirty = true;\n  this._inverseProjection = new Matrix4();\n  this._modelViewDirty = true;\n  this._modelView = new Matrix4();\n  this._modelView3DDirty = true;\n  this._modelView3D = new Matrix4();\n  this._modelViewRelativeToEyeDirty = true;\n  this._modelViewRelativeToEye = new Matrix4();\n  this._inverseModelViewDirty = true;\n  this._inverseModelView = new Matrix4();\n  this._inverseModelView3DDirty = true;\n  this._inverseModelView3D = new Matrix4();\n  this._viewProjectionDirty = true;\n  this._viewProjection = new Matrix4();\n  this._inverseViewProjectionDirty = true;\n  this._inverseViewProjection = new Matrix4();\n  this._modelViewProjectionDirty = true;\n  this._modelViewProjection = new Matrix4();\n  this._inverseModelViewProjectionDirty = true;\n  this._inverseModelViewProjection = new Matrix4();\n  this._modelViewProjectionRelativeToEyeDirty = true;\n  this._modelViewProjectionRelativeToEye = new Matrix4();\n  this._modelViewInfiniteProjectionDirty = true;\n  this._modelViewInfiniteProjection = new Matrix4();\n  this._normalDirty = true;\n  this._normal = new Matrix3();\n  this._normal3DDirty = true;\n  this._normal3D = new Matrix3();\n  this._inverseNormalDirty = true;\n  this._inverseNormal = new Matrix3();\n  this._inverseNormal3DDirty = true;\n  this._inverseNormal3D = new Matrix3();\n  this._encodedCameraPositionMCDirty = true;\n  this._encodedCameraPositionMC = new EncodedCartesian3();\n  this._cameraPosition = new Cartesian3();\n  this._sunPositionWC = new Cartesian3();\n  this._sunPositionColumbusView = new Cartesian3();\n  this._sunDirectionWC = new Cartesian3();\n  this._sunDirectionEC = new Cartesian3();\n  this._moonDirectionEC = new Cartesian3();\n  this._lightDirectionWC = new Cartesian3();\n  this._lightDirectionEC = new Cartesian3();\n  this._lightColor = new Cartesian3();\n  this._lightColorHdr = new Cartesian3();\n  this._pass = undefined;\n  this._mode = undefined;\n  this._mapProjection = undefined;\n  this._ellipsoid = undefined;\n  this._cameraDirection = new Cartesian3();\n  this._cameraRight = new Cartesian3();\n  this._cameraUp = new Cartesian3();\n  this._frustum2DWidth = 0.0;\n  this._eyeHeight2D = new Cartesian2();\n  this._pixelRatio = 1.0;\n  this._orthographicIn3D = false;\n  this._backgroundColor = new Color();\n  this._brdfLut = undefined;\n  this._environmentMap = undefined;\n  this._sphericalHarmonicCoefficients = undefined;\n  this._specularEnvironmentMaps = undefined;\n  this._specularEnvironmentMapsDimensions = new Cartesian2();\n  this._specularEnvironmentMapsMaximumLOD = undefined;\n  this._fogDensity = undefined;\n  this._invertClassificationColor = undefined;\n  this._imagerySplitPosition = 0.0;\n  this._pixelSizePerMeter = undefined;\n  this._geometricToleranceOverMeter = undefined;\n  this._minimumDisableDepthTestDistance = undefined;\n}\n\nObject.defineProperties(UniformState.prototype, {\n  /**\n   * @memberof UniformState.prototype\n   * @type {FrameState}\n   * @readonly\n   */\n  frameState: {\n    get: function get() {\n      return this._frameState;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {BoundingRectangle}\n   */\n  viewport: {\n    get: function get() {\n      return this._viewport;\n    },\n    set: function set(viewport) {\n      if (!BoundingRectangle.equals(viewport, this._viewport)) {\n        BoundingRectangle.clone(viewport, this._viewport);\n        var v = this._viewport;\n        var vc = this._viewportCartesian4;\n        vc.x = v.x;\n        vc.y = v.y;\n        vc.z = v.width;\n        vc.w = v.height;\n        this._viewportDirty = true;\n      }\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @private\n   */\n  viewportCartesian4: {\n    get: function get() {\n      return this._viewportCartesian4;\n    }\n  },\n  viewportOrthographic: {\n    get: function get() {\n      cleanViewport(this);\n      return this._viewportOrthographicMatrix;\n    }\n  },\n  viewportTransformation: {\n    get: function get() {\n      cleanViewport(this);\n      return this._viewportTransformation;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  model: {\n    get: function get() {\n      return this._model;\n    },\n    set: function set(matrix) {\n      Matrix4.clone(matrix, this._model);\n      this._modelView3DDirty = true;\n      this._inverseModelView3DDirty = true;\n      this._inverseModelDirty = true;\n      this._inverseTransposeModelDirty = true;\n      this._modelViewDirty = true;\n      this._inverseModelViewDirty = true;\n      this._modelViewRelativeToEyeDirty = true;\n      this._inverseModelViewDirty = true;\n      this._modelViewProjectionDirty = true;\n      this._inverseModelViewProjectionDirty = true;\n      this._modelViewProjectionRelativeToEyeDirty = true;\n      this._modelViewInfiniteProjectionDirty = true;\n      this._normalDirty = true;\n      this._inverseNormalDirty = true;\n      this._normal3DDirty = true;\n      this._inverseNormal3DDirty = true;\n      this._encodedCameraPositionMCDirty = true;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseModel: {\n    get: function get() {\n      if (this._inverseModelDirty) {\n        this._inverseModelDirty = false;\n        Matrix4.inverse(this._model, this._inverseModel);\n      }\n\n      return this._inverseModel;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @private\n   */\n  inverseTransposeModel: {\n    get: function get() {\n      var m = this._inverseTransposeModel;\n\n      if (this._inverseTransposeModelDirty) {\n        this._inverseTransposeModelDirty = false;\n        Matrix4.getMatrix3(this.inverseModel, m);\n        Matrix3.transpose(m, m);\n      }\n\n      return m;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  view: {\n    get: function get() {\n      return this._view;\n    }\n  },\n\n  /**\n   * The 3D view matrix.  In 3D mode, this is identical to {@link UniformState#view},\n   * but in 2D and Columbus View it is a synthetic matrix based on the equivalent position\n   * of the camera in the 3D world.\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  view3D: {\n    get: function get() {\n      updateView3D(this);\n      return this._view3D;\n    }\n  },\n\n  /**\n   * The 3x3 rotation matrix of the current view matrix ({@link UniformState#view}).\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  viewRotation: {\n    get: function get() {\n      updateView3D(this);\n      return this._viewRotation;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  viewRotation3D: {\n    get: function get() {\n      updateView3D(this);\n      return this._viewRotation3D;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseView: {\n    get: function get() {\n      return this._inverseView;\n    }\n  },\n\n  /**\n   * the 4x4 inverse-view matrix that transforms from eye to 3D world coordinates.  In 3D mode, this is\n   * identical to {@link UniformState#inverseView}, but in 2D and Columbus View it is a synthetic matrix\n   * based on the equivalent position of the camera in the 3D world.\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseView3D: {\n    get: function get() {\n      updateInverseView3D(this);\n      return this._inverseView3D;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  inverseViewRotation: {\n    get: function get() {\n      return this._inverseViewRotation;\n    }\n  },\n\n  /**\n   * The 3x3 rotation matrix of the current 3D inverse-view matrix ({@link UniformState#inverseView3D}).\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  inverseViewRotation3D: {\n    get: function get() {\n      updateInverseView3D(this);\n      return this._inverseViewRotation3D;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  projection: {\n    get: function get() {\n      return this._projection;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseProjection: {\n    get: function get() {\n      cleanInverseProjection(this);\n      return this._inverseProjection;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  infiniteProjection: {\n    get: function get() {\n      return this._infiniteProjection;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelView: {\n    get: function get() {\n      cleanModelView(this);\n      return this._modelView;\n    }\n  },\n\n  /**\n   * The 3D model-view matrix.  In 3D mode, this is equivalent to {@link UniformState#modelView}.  In 2D and\n   * Columbus View, however, it is a synthetic matrix based on the equivalent position of the camera in the 3D world.\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelView3D: {\n    get: function get() {\n      cleanModelView3D(this);\n      return this._modelView3D;\n    }\n  },\n\n  /**\n   * Model-view relative to eye matrix.\n   *\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelViewRelativeToEye: {\n    get: function get() {\n      cleanModelViewRelativeToEye(this);\n      return this._modelViewRelativeToEye;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseModelView: {\n    get: function get() {\n      cleanInverseModelView(this);\n      return this._inverseModelView;\n    }\n  },\n\n  /**\n   * The inverse of the 3D model-view matrix.  In 3D mode, this is equivalent to {@link UniformState#inverseModelView}.\n   * In 2D and Columbus View, however, it is a synthetic matrix based on the equivalent position of the camera in the 3D world.\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseModelView3D: {\n    get: function get() {\n      cleanInverseModelView3D(this);\n      return this._inverseModelView3D;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  viewProjection: {\n    get: function get() {\n      cleanViewProjection(this);\n      return this._viewProjection;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseViewProjection: {\n    get: function get() {\n      cleanInverseViewProjection(this);\n      return this._inverseViewProjection;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelViewProjection: {\n    get: function get() {\n      cleanModelViewProjection(this);\n      return this._modelViewProjection;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseModelViewProjection: {\n    get: function get() {\n      cleanInverseModelViewProjection(this);\n      return this._inverseModelViewProjection;\n    }\n  },\n\n  /**\n   * Model-view-projection relative to eye matrix.\n   *\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelViewProjectionRelativeToEye: {\n    get: function get() {\n      cleanModelViewProjectionRelativeToEye(this);\n      return this._modelViewProjectionRelativeToEye;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelViewInfiniteProjection: {\n    get: function get() {\n      cleanModelViewInfiniteProjection(this);\n      return this._modelViewInfiniteProjection;\n    }\n  },\n\n  /**\n   * A 3x3 normal transformation matrix that transforms normal vectors in model coordinates to\n   * eye coordinates.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  normal: {\n    get: function get() {\n      cleanNormal(this);\n      return this._normal;\n    }\n  },\n\n  /**\n   * A 3x3 normal transformation matrix that transforms normal vectors in 3D model\n   * coordinates to eye coordinates.  In 3D mode, this is identical to\n   * {@link UniformState#normal}, but in 2D and Columbus View it represents the normal transformation\n   * matrix as if the camera were at an equivalent location in 3D mode.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  normal3D: {\n    get: function get() {\n      cleanNormal3D(this);\n      return this._normal3D;\n    }\n  },\n\n  /**\n   * An inverse 3x3 normal transformation matrix that transforms normal vectors in model coordinates\n   * to eye coordinates.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  inverseNormal: {\n    get: function get() {\n      cleanInverseNormal(this);\n      return this._inverseNormal;\n    }\n  },\n\n  /**\n   * An inverse 3x3 normal transformation matrix that transforms normal vectors in eye coordinates\n   * to 3D model coordinates.  In 3D mode, this is identical to\n   * {@link UniformState#inverseNormal}, but in 2D and Columbus View it represents the normal transformation\n   * matrix as if the camera were at an equivalent location in 3D mode.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  inverseNormal3D: {\n    get: function get() {\n      cleanInverseNormal3D(this);\n      return this._inverseNormal3D;\n    }\n  },\n\n  /**\n   * The near distance (<code>x</code>) and the far distance (<code>y</code>) of the frustum defined by the camera.\n   * This is the largest possible frustum, not an individual frustum used for multi-frustum rendering.\n   * @memberof UniformState.prototype\n   * @type {Cartesian2}\n   */\n  entireFrustum: {\n    get: function get() {\n      return this._entireFrustum;\n    }\n  },\n\n  /**\n   * The near distance (<code>x</code>) and the far distance (<code>y</code>) of the frustum defined by the camera.\n   * This is the individual frustum used for multi-frustum rendering.\n   * @memberof UniformState.prototype\n   * @type {Cartesian2}\n   */\n  currentFrustum: {\n    get: function get() {\n      return this._currentFrustum;\n    }\n  },\n\n  /**\n   * The distances to the frustum planes. The top, bottom, left and right distances are\n   * the x, y, z, and w components, respectively.\n   * @memberof UniformState.prototype\n   * @type {Cartesian4}\n   */\n  frustumPlanes: {\n    get: function get() {\n      return this._frustumPlanes;\n    }\n  },\n\n  /**\n   * The far plane's distance from the near plane, plus 1.0.\n   *\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  farDepthFromNearPlusOne: {\n    get: function get() {\n      return this._farDepthFromNearPlusOne;\n    }\n  },\n\n  /**\n   * The log2 of {@link UniformState#farDepthFromNearPlusOne}.\n   *\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  log2FarDepthFromNearPlusOne: {\n    get: function get() {\n      return this._log2FarDepthFromNearPlusOne;\n    }\n  },\n\n  /**\n   * 1.0 divided by {@link UniformState#log2FarDepthFromNearPlusOne}.\n   *\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  oneOverLog2FarDepthFromNearPlusOne: {\n    get: function get() {\n      return this._oneOverLog2FarDepthFromNearPlusOne;\n    }\n  },\n\n  /**\n   * The the height (<code>x</code>) and the height squared (<code>y</code>)\n   * in meters of the camera above the 2D world plane. This uniform is only valid\n   * when the {@link SceneMode} equal to <code>SCENE2D</code>.\n   * @memberof UniformState.prototype\n   * @type {Cartesian2}\n   */\n  eyeHeight2D: {\n    get: function get() {\n      return this._eyeHeight2D;\n    }\n  },\n\n  /**\n   * The sun position in 3D world coordinates at the current scene time.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  sunPositionWC: {\n    get: function get() {\n      return this._sunPositionWC;\n    }\n  },\n\n  /**\n   * The sun position in 2D world coordinates at the current scene time.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  sunPositionColumbusView: {\n    get: function get() {\n      return this._sunPositionColumbusView;\n    }\n  },\n\n  /**\n   * A normalized vector to the sun in 3D world coordinates at the current scene time.  Even in 2D or\n   * Columbus View mode, this returns the direction to the sun in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  sunDirectionWC: {\n    get: function get() {\n      return this._sunDirectionWC;\n    }\n  },\n\n  /**\n   * A normalized vector to the sun in eye coordinates at the current scene time.  In 3D mode, this\n   * returns the actual vector from the camera position to the sun position.  In 2D and Columbus View, it returns\n   * the vector from the equivalent 3D camera position to the position of the sun in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  sunDirectionEC: {\n    get: function get() {\n      return this._sunDirectionEC;\n    }\n  },\n\n  /**\n   * A normalized vector to the moon in eye coordinates at the current scene time.  In 3D mode, this\n   * returns the actual vector from the camera position to the moon position.  In 2D and Columbus View, it returns\n   * the vector from the equivalent 3D camera position to the position of the moon in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  moonDirectionEC: {\n    get: function get() {\n      return this._moonDirectionEC;\n    }\n  },\n\n  /**\n   * A normalized vector to the scene's light source in 3D world coordinates.  Even in 2D or\n   * Columbus View mode, this returns the direction to the light in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  lightDirectionWC: {\n    get: function get() {\n      return this._lightDirectionWC;\n    }\n  },\n\n  /**\n   * A normalized vector to the scene's light source in eye coordinates.  In 3D mode, this\n   * returns the actual vector from the camera position to the light.  In 2D and Columbus View, it returns\n   * the vector from the equivalent 3D camera position in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  lightDirectionEC: {\n    get: function get() {\n      return this._lightDirectionEC;\n    }\n  },\n\n  /**\n   * The color of light emitted by the scene's light source. This is equivalent to the light\n   * color multiplied by the light intensity limited to a maximum luminance of 1.0 suitable\n   * for non-HDR lighting.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  lightColor: {\n    get: function get() {\n      return this._lightColor;\n    }\n  },\n\n  /**\n   * The high dynamic range color of light emitted by the scene's light source. This is equivalent to\n   * the light color multiplied by the light intensity suitable for HDR lighting.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  lightColorHdr: {\n    get: function get() {\n      return this._lightColorHdr;\n    }\n  },\n\n  /**\n   * The high bits of the camera position.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  encodedCameraPositionMCHigh: {\n    get: function get() {\n      cleanEncodedCameraPositionMC(this);\n      return this._encodedCameraPositionMC.high;\n    }\n  },\n\n  /**\n   * The low bits of the camera position.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  encodedCameraPositionMCLow: {\n    get: function get() {\n      cleanEncodedCameraPositionMC(this);\n      return this._encodedCameraPositionMC.low;\n    }\n  },\n\n  /**\n   * A 3x3 matrix that transforms from True Equator Mean Equinox (TEME) axes to the\n   * pseudo-fixed axes at the Scene's current time.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  temeToPseudoFixedMatrix: {\n    get: function get() {\n      return this._temeToPseudoFixed;\n    }\n  },\n\n  /**\n   * Gets the scaling factor for transforming from the canvas\n   * pixel space to canvas coordinate space.\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  pixelRatio: {\n    get: function get() {\n      return this._pixelRatio;\n    }\n  },\n\n  /**\n   * A scalar used to mix a color with the fog color based on the distance to the camera.\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  fogDensity: {\n    get: function get() {\n      return this._fogDensity;\n    }\n  },\n\n  /**\n   * A scalar that represents the geometric tolerance per meter\n   * @memberof UniformStat.prototype\n   * @type {Number}\n   */\n  geometricToleranceOverMeter: {\n    get: function get() {\n      return this._geometricToleranceOverMeter;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Pass}\n   */\n  pass: {\n    get: function get() {\n      return this._pass;\n    }\n  },\n\n  /**\n   * The current background color\n   * @memberof UniformState.prototype\n   * @type {Color}\n   */\n  backgroundColor: {\n    get: function get() {\n      return this._backgroundColor;\n    }\n  },\n\n  /**\n   * The look up texture used to find the BRDF for a material\n   * @memberof UniformState.prototype\n   * @type {Texture}\n   */\n  brdfLut: {\n    get: function get() {\n      return this._brdfLut;\n    }\n  },\n\n  /**\n   * The environment map of the scene\n   * @memberof UniformState.prototype\n   * @type {CubeMap}\n   */\n  environmentMap: {\n    get: function get() {\n      return this._environmentMap;\n    }\n  },\n\n  /**\n   * The spherical harmonic coefficients of the scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3[]}\n   */\n  sphericalHarmonicCoefficients: {\n    get: function get() {\n      return this._sphericalHarmonicCoefficients;\n    }\n  },\n\n  /**\n   * The specular environment map atlas of the scene.\n   * @memberof UniformState.prototype\n   * @type {Texture}\n   */\n  specularEnvironmentMaps: {\n    get: function get() {\n      return this._specularEnvironmentMaps;\n    }\n  },\n\n  /**\n   * The dimensions of the specular environment map atlas of the scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian2}\n   */\n  specularEnvironmentMapsDimensions: {\n    get: function get() {\n      return this._specularEnvironmentMapsDimensions;\n    }\n  },\n\n  /**\n   * The maximum level-of-detail of the specular environment map atlas of the scene.\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  specularEnvironmentMapsMaximumLOD: {\n    get: function get() {\n      return this._specularEnvironmentMapsMaximumLOD;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  imagerySplitPosition: {\n    get: function get() {\n      return this._imagerySplitPosition;\n    }\n  },\n\n  /**\n   * The distance from the camera at which to disable the depth test of billboards, labels and points\n   * to, for example, prevent clipping against terrain. When set to zero, the depth test should always\n   * be applied. When less than zero, the depth test should never be applied.\n   *\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  minimumDisableDepthTestDistance: {\n    get: function get() {\n      return this._minimumDisableDepthTestDistance;\n    }\n  },\n\n  /**\n   * The highlight color of unclassified 3D Tiles.\n   *\n   * @memberof UniformState.prototype\n   * @type {Color}\n   */\n  invertClassificationColor: {\n    get: function get() {\n      return this._invertClassificationColor;\n    }\n  },\n\n  /**\n   * Whether or not the current projection is orthographic in 3D.\n   *\n   * @memberOf UniformState.prototype\n   * @type {Boolean}\n   */\n  orthographicIn3D: {\n    get: function get() {\n      return this._orthographicIn3D;\n    }\n  },\n\n  /**\n   * The current ellipsoid.\n   *\n   * @memberOf UniformState.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function get() {\n      return defaultValue(this._ellipsoid, Ellipsoid.WGS84);\n    }\n  }\n});\n\nfunction setView(uniformState, matrix) {\n  Matrix4.clone(matrix, uniformState._view);\n  Matrix4.getMatrix3(matrix, uniformState._viewRotation);\n  uniformState._view3DDirty = true;\n  uniformState._inverseView3DDirty = true;\n  uniformState._modelViewDirty = true;\n  uniformState._modelView3DDirty = true;\n  uniformState._modelViewRelativeToEyeDirty = true;\n  uniformState._inverseModelViewDirty = true;\n  uniformState._inverseModelView3DDirty = true;\n  uniformState._viewProjectionDirty = true;\n  uniformState._inverseViewProjectionDirty = true;\n  uniformState._modelViewProjectionDirty = true;\n  uniformState._modelViewProjectionRelativeToEyeDirty = true;\n  uniformState._modelViewInfiniteProjectionDirty = true;\n  uniformState._normalDirty = true;\n  uniformState._inverseNormalDirty = true;\n  uniformState._normal3DDirty = true;\n  uniformState._inverseNormal3DDirty = true;\n}\n\nfunction setInverseView(uniformState, matrix) {\n  Matrix4.clone(matrix, uniformState._inverseView);\n  Matrix4.getMatrix3(matrix, uniformState._inverseViewRotation);\n}\n\nfunction setProjection(uniformState, matrix) {\n  Matrix4.clone(matrix, uniformState._projection);\n  uniformState._inverseProjectionDirty = true;\n  uniformState._viewProjectionDirty = true;\n  uniformState._inverseViewProjectionDirty = true;\n  uniformState._modelViewProjectionDirty = true;\n  uniformState._modelViewProjectionRelativeToEyeDirty = true;\n}\n\nfunction setInfiniteProjection(uniformState, matrix) {\n  Matrix4.clone(matrix, uniformState._infiniteProjection);\n  uniformState._modelViewInfiniteProjectionDirty = true;\n}\n\nfunction setCamera(uniformState, camera) {\n  Cartesian3.clone(camera.positionWC, uniformState._cameraPosition);\n  Cartesian3.clone(camera.directionWC, uniformState._cameraDirection);\n  Cartesian3.clone(camera.rightWC, uniformState._cameraRight);\n  Cartesian3.clone(camera.upWC, uniformState._cameraUp);\n  uniformState._encodedCameraPositionMCDirty = true;\n}\n\nvar transformMatrix = new Matrix3();\nvar sunCartographicScratch = new Cartographic();\n\nfunction setSunAndMoonDirections(uniformState, frameState) {\n  if (!defined(Transforms.computeIcrfToFixedMatrix(frameState.time, transformMatrix))) {\n    transformMatrix = Transforms.computeTemeToPseudoFixedMatrix(frameState.time, transformMatrix);\n  }\n\n  var position = Simon1994PlanetaryPositions.computeSunPositionInEarthInertialFrame(frameState.time, uniformState._sunPositionWC);\n  Matrix3.multiplyByVector(transformMatrix, position, position);\n  Cartesian3.normalize(position, uniformState._sunDirectionWC);\n  position = Matrix3.multiplyByVector(uniformState.viewRotation3D, position, uniformState._sunDirectionEC);\n  Cartesian3.normalize(position, position);\n  position = Simon1994PlanetaryPositions.computeMoonPositionInEarthInertialFrame(frameState.time, uniformState._moonDirectionEC);\n  Matrix3.multiplyByVector(transformMatrix, position, position);\n  Matrix3.multiplyByVector(uniformState.viewRotation3D, position, position);\n  Cartesian3.normalize(position, position);\n  var projection = frameState.mapProjection;\n  var ellipsoid = projection.ellipsoid;\n  var sunCartographic = ellipsoid.cartesianToCartographic(uniformState._sunPositionWC, sunCartographicScratch);\n  projection.project(sunCartographic, uniformState._sunPositionColumbusView);\n}\n/**\n * Synchronizes the frustum's state with the camera state.  This is called\n * by the {@link Scene} when rendering to ensure that automatic GLSL uniforms\n * are set to the right value.\n *\n * @param {Object} camera The camera to synchronize with.\n */\n\n\nUniformState.prototype.updateCamera = function (camera) {\n  setView(this, camera.viewMatrix);\n  setInverseView(this, camera.inverseViewMatrix);\n  setCamera(this, camera);\n  this._entireFrustum.x = camera.frustum.near;\n  this._entireFrustum.y = camera.frustum.far;\n  this.updateFrustum(camera.frustum);\n  this._orthographicIn3D = this._mode !== SceneMode.SCENE2D && camera.frustum instanceof OrthographicFrustum;\n};\n/**\n * Synchronizes the frustum's state with the uniform state.  This is called\n * by the {@link Scene} when rendering to ensure that automatic GLSL uniforms\n * are set to the right value.\n *\n * @param {Object} frustum The frustum to synchronize with.\n */\n\n\nUniformState.prototype.updateFrustum = function (frustum) {\n  setProjection(this, frustum.projectionMatrix);\n\n  if (defined(frustum.infiniteProjectionMatrix)) {\n    setInfiniteProjection(this, frustum.infiniteProjectionMatrix);\n  }\n\n  this._currentFrustum.x = frustum.near;\n  this._currentFrustum.y = frustum.far;\n  this._farDepthFromNearPlusOne = frustum.far - frustum.near + 1.0;\n  this._log2FarDepthFromNearPlusOne = CesiumMath.log2(this._farDepthFromNearPlusOne);\n  this._oneOverLog2FarDepthFromNearPlusOne = 1.0 / this._log2FarDepthFromNearPlusOne;\n\n  if (defined(frustum._offCenterFrustum)) {\n    frustum = frustum._offCenterFrustum;\n  }\n\n  this._frustumPlanes.x = frustum.top;\n  this._frustumPlanes.y = frustum.bottom;\n  this._frustumPlanes.z = frustum.left;\n  this._frustumPlanes.w = frustum.right;\n};\n\nUniformState.prototype.updatePass = function (pass) {\n  this._pass = pass;\n};\n\nvar EMPTY_ARRAY = [];\nvar defaultLight = new SunLight();\n/**\n * Synchronizes frame state with the uniform state.  This is called\n * by the {@link Scene} when rendering to ensure that automatic GLSL uniforms\n * are set to the right value.\n *\n * @param {FrameState} frameState The frameState to synchronize with.\n */\n\nUniformState.prototype.update = function (frameState) {\n  this._mode = frameState.mode;\n  this._mapProjection = frameState.mapProjection;\n  this._ellipsoid = frameState.mapProjection.ellipsoid;\n  this._pixelRatio = frameState.pixelRatio;\n  var camera = frameState.camera;\n  this.updateCamera(camera);\n\n  if (frameState.mode === SceneMode.SCENE2D) {\n    this._frustum2DWidth = camera.frustum.right - camera.frustum.left;\n    this._eyeHeight2D.x = this._frustum2DWidth * 0.5;\n    this._eyeHeight2D.y = this._eyeHeight2D.x * this._eyeHeight2D.x;\n  } else {\n    this._frustum2DWidth = 0.0;\n    this._eyeHeight2D.x = 0.0;\n    this._eyeHeight2D.y = 0.0;\n  }\n\n  setSunAndMoonDirections(this, frameState);\n  var light = defaultValue(frameState.light, defaultLight);\n\n  if (light instanceof SunLight) {\n    this._lightDirectionWC = Cartesian3.clone(this._sunDirectionWC, this._lightDirectionWC);\n    this._lightDirectionEC = Cartesian3.clone(this._sunDirectionEC, this._lightDirectionEC);\n  } else {\n    this._lightDirectionWC = Cartesian3.normalize(Cartesian3.negate(light.direction, this._lightDirectionWC), this._lightDirectionWC);\n    this._lightDirectionEC = Matrix3.multiplyByVector(this.viewRotation3D, this._lightDirectionWC, this._lightDirectionEC);\n  }\n\n  var lightColor = light.color;\n  var lightColorHdr = Cartesian3.fromElements(lightColor.red, lightColor.green, lightColor.blue, this._lightColorHdr);\n  lightColorHdr = Cartesian3.multiplyByScalar(lightColorHdr, light.intensity, lightColorHdr);\n  var maximumComponent = Cartesian3.maximumComponent(lightColorHdr);\n\n  if (maximumComponent > 1.0) {\n    Cartesian3.divideByScalar(lightColorHdr, maximumComponent, this._lightColor);\n  } else {\n    Cartesian3.clone(lightColorHdr, this._lightColor);\n  }\n\n  var brdfLutGenerator = frameState.brdfLutGenerator;\n  var brdfLut = defined(brdfLutGenerator) ? brdfLutGenerator.colorTexture : undefined;\n  this._brdfLut = brdfLut;\n  this._environmentMap = defaultValue(frameState.environmentMap, frameState.context.defaultCubeMap); // IE 11 doesn't optimize out uniforms that are #ifdef'd out. So undefined values for the spherical harmonic\n  // coefficients and specular environment map atlas dimensions cause a crash.\n\n  this._sphericalHarmonicCoefficients = defaultValue(frameState.sphericalHarmonicCoefficients, EMPTY_ARRAY);\n  this._specularEnvironmentMaps = frameState.specularEnvironmentMaps;\n  this._specularEnvironmentMapsMaximumLOD = frameState.specularEnvironmentMapsMaximumLOD;\n\n  if (defined(this._specularEnvironmentMaps)) {\n    Cartesian2.clone(this._specularEnvironmentMaps.dimensions, this._specularEnvironmentMapsDimensions);\n  }\n\n  this._fogDensity = frameState.fog.density;\n  this._invertClassificationColor = frameState.invertClassificationColor;\n  this._frameState = frameState;\n  this._temeToPseudoFixed = Transforms.computeTemeToPseudoFixedMatrix(frameState.time, this._temeToPseudoFixed); // Convert the relative imagerySplitPosition to absolute pixel coordinates\n\n  this._imagerySplitPosition = frameState.imagerySplitPosition * frameState.context.drawingBufferWidth;\n  var fov = camera.frustum.fov;\n  var viewport = this._viewport;\n  var pixelSizePerMeter;\n\n  if (viewport.height > viewport.width) {\n    pixelSizePerMeter = Math.tan(0.5 * fov) * 2.0 / viewport.height;\n  } else {\n    pixelSizePerMeter = Math.tan(0.5 * fov) * 2.0 / viewport.width;\n  }\n\n  this._geometricToleranceOverMeter = pixelSizePerMeter * frameState.maximumScreenSpaceError;\n  Color.clone(frameState.backgroundColor, this._backgroundColor);\n  this._minimumDisableDepthTestDistance = frameState.minimumDisableDepthTestDistance;\n  this._minimumDisableDepthTestDistance *= this._minimumDisableDepthTestDistance;\n\n  if (this._minimumDisableDepthTestDistance === Number.POSITIVE_INFINITY) {\n    this._minimumDisableDepthTestDistance = -1.0;\n  }\n};\n\nfunction cleanViewport(uniformState) {\n  if (uniformState._viewportDirty) {\n    var v = uniformState._viewport;\n    Matrix4.computeOrthographicOffCenter(v.x, v.x + v.width, v.y, v.y + v.height, 0.0, 1.0, uniformState._viewportOrthographicMatrix);\n    Matrix4.computeViewportTransformation(v, 0.0, 1.0, uniformState._viewportTransformation);\n    uniformState._viewportDirty = false;\n  }\n}\n\nfunction cleanInverseProjection(uniformState) {\n  if (uniformState._inverseProjectionDirty) {\n    uniformState._inverseProjectionDirty = false;\n\n    if (uniformState._mode !== SceneMode.SCENE2D && uniformState._mode !== SceneMode.MORPHING && !uniformState._orthographicIn3D) {\n      Matrix4.inverse(uniformState._projection, uniformState._inverseProjection);\n    } else {\n      Matrix4.clone(Matrix4.ZERO, uniformState._inverseProjection);\n    }\n  }\n} // Derived\n\n\nfunction cleanModelView(uniformState) {\n  if (uniformState._modelViewDirty) {\n    uniformState._modelViewDirty = false;\n    Matrix4.multiplyTransformation(uniformState._view, uniformState._model, uniformState._modelView);\n  }\n}\n\nfunction cleanModelView3D(uniformState) {\n  if (uniformState._modelView3DDirty) {\n    uniformState._modelView3DDirty = false;\n    Matrix4.multiplyTransformation(uniformState.view3D, uniformState._model, uniformState._modelView3D);\n  }\n}\n\nfunction cleanInverseModelView(uniformState) {\n  if (uniformState._inverseModelViewDirty) {\n    uniformState._inverseModelViewDirty = false;\n    Matrix4.inverse(uniformState.modelView, uniformState._inverseModelView);\n  }\n}\n\nfunction cleanInverseModelView3D(uniformState) {\n  if (uniformState._inverseModelView3DDirty) {\n    uniformState._inverseModelView3DDirty = false;\n    Matrix4.inverse(uniformState.modelView3D, uniformState._inverseModelView3D);\n  }\n}\n\nfunction cleanViewProjection(uniformState) {\n  if (uniformState._viewProjectionDirty) {\n    uniformState._viewProjectionDirty = false;\n    Matrix4.multiply(uniformState._projection, uniformState._view, uniformState._viewProjection);\n  }\n}\n\nfunction cleanInverseViewProjection(uniformState) {\n  if (uniformState._inverseViewProjectionDirty) {\n    uniformState._inverseViewProjectionDirty = false;\n    Matrix4.inverse(uniformState.viewProjection, uniformState._inverseViewProjection);\n  }\n}\n\nfunction cleanModelViewProjection(uniformState) {\n  if (uniformState._modelViewProjectionDirty) {\n    uniformState._modelViewProjectionDirty = false;\n    Matrix4.multiply(uniformState._projection, uniformState.modelView, uniformState._modelViewProjection);\n  }\n}\n\nfunction cleanModelViewRelativeToEye(uniformState) {\n  if (uniformState._modelViewRelativeToEyeDirty) {\n    uniformState._modelViewRelativeToEyeDirty = false;\n    var mv = uniformState.modelView;\n    var mvRte = uniformState._modelViewRelativeToEye;\n    mvRte[0] = mv[0];\n    mvRte[1] = mv[1];\n    mvRte[2] = mv[2];\n    mvRte[3] = mv[3];\n    mvRte[4] = mv[4];\n    mvRte[5] = mv[5];\n    mvRte[6] = mv[6];\n    mvRte[7] = mv[7];\n    mvRte[8] = mv[8];\n    mvRte[9] = mv[9];\n    mvRte[10] = mv[10];\n    mvRte[11] = mv[11];\n    mvRte[12] = 0.0;\n    mvRte[13] = 0.0;\n    mvRte[14] = 0.0;\n    mvRte[15] = mv[15];\n  }\n}\n\nfunction cleanInverseModelViewProjection(uniformState) {\n  if (uniformState._inverseModelViewProjectionDirty) {\n    uniformState._inverseModelViewProjectionDirty = false;\n    Matrix4.inverse(uniformState.modelViewProjection, uniformState._inverseModelViewProjection);\n  }\n}\n\nfunction cleanModelViewProjectionRelativeToEye(uniformState) {\n  if (uniformState._modelViewProjectionRelativeToEyeDirty) {\n    uniformState._modelViewProjectionRelativeToEyeDirty = false;\n    Matrix4.multiply(uniformState._projection, uniformState.modelViewRelativeToEye, uniformState._modelViewProjectionRelativeToEye);\n  }\n}\n\nfunction cleanModelViewInfiniteProjection(uniformState) {\n  if (uniformState._modelViewInfiniteProjectionDirty) {\n    uniformState._modelViewInfiniteProjectionDirty = false;\n    Matrix4.multiply(uniformState._infiniteProjection, uniformState.modelView, uniformState._modelViewInfiniteProjection);\n  }\n}\n\nfunction cleanNormal(uniformState) {\n  if (uniformState._normalDirty) {\n    uniformState._normalDirty = false;\n    var m = uniformState._normal;\n    Matrix4.getMatrix3(uniformState.inverseModelView, m);\n    Matrix3.getRotation(m, m);\n    Matrix3.transpose(m, m);\n  }\n}\n\nfunction cleanNormal3D(uniformState) {\n  if (uniformState._normal3DDirty) {\n    uniformState._normal3DDirty = false;\n    var m = uniformState._normal3D;\n    Matrix4.getMatrix3(uniformState.inverseModelView3D, m);\n    Matrix3.getRotation(m, m);\n    Matrix3.transpose(m, m);\n  }\n}\n\nfunction cleanInverseNormal(uniformState) {\n  if (uniformState._inverseNormalDirty) {\n    uniformState._inverseNormalDirty = false;\n    Matrix4.getMatrix3(uniformState.inverseModelView, uniformState._inverseNormal);\n    Matrix3.getRotation(uniformState._inverseNormal, uniformState._inverseNormal);\n  }\n}\n\nfunction cleanInverseNormal3D(uniformState) {\n  if (uniformState._inverseNormal3DDirty) {\n    uniformState._inverseNormal3DDirty = false;\n    Matrix4.getMatrix3(uniformState.inverseModelView3D, uniformState._inverseNormal3D);\n    Matrix3.getRotation(uniformState._inverseNormal3D, uniformState._inverseNormal3D);\n  }\n}\n\nvar cameraPositionMC = new Cartesian3();\n\nfunction cleanEncodedCameraPositionMC(uniformState) {\n  if (uniformState._encodedCameraPositionMCDirty) {\n    uniformState._encodedCameraPositionMCDirty = false;\n    Matrix4.multiplyByPoint(uniformState.inverseModel, uniformState._cameraPosition, cameraPositionMC);\n    EncodedCartesian3.fromCartesian(cameraPositionMC, uniformState._encodedCameraPositionMC);\n  }\n}\n\nvar view2Dto3DPScratch = new Cartesian3();\nvar view2Dto3DRScratch = new Cartesian3();\nvar view2Dto3DUScratch = new Cartesian3();\nvar view2Dto3DDScratch = new Cartesian3();\nvar view2Dto3DCartographicScratch = new Cartographic();\nvar view2Dto3DCartesian3Scratch = new Cartesian3();\nvar view2Dto3DMatrix4Scratch = new Matrix4();\n\nfunction view2Dto3D(position2D, direction2D, right2D, up2D, frustum2DWidth, mode, projection, result) {\n  // The camera position and directions are expressed in the 2D coordinate system where the Y axis is to the East,\n  // the Z axis is to the North, and the X axis is out of the map.  Express them instead in the ENU axes where\n  // X is to the East, Y is to the North, and Z is out of the local horizontal plane.\n  var p = view2Dto3DPScratch;\n  p.x = position2D.y;\n  p.y = position2D.z;\n  p.z = position2D.x;\n  var r = view2Dto3DRScratch;\n  r.x = right2D.y;\n  r.y = right2D.z;\n  r.z = right2D.x;\n  var u = view2Dto3DUScratch;\n  u.x = up2D.y;\n  u.y = up2D.z;\n  u.z = up2D.x;\n  var d = view2Dto3DDScratch;\n  d.x = direction2D.y;\n  d.y = direction2D.z;\n  d.z = direction2D.x; // In 2D, the camera height is always 12.7 million meters.\n  // The apparent height is equal to half the frustum width.\n\n  if (mode === SceneMode.SCENE2D) {\n    p.z = frustum2DWidth * 0.5;\n  } // Compute the equivalent camera position in the real (3D) world.\n  // In 2D and Columbus View, the camera can travel outside the projection, and when it does so\n  // there's not really any corresponding location in the real world.  So clamp the unprojected\n  // longitude and latitude to their valid ranges.\n\n\n  var cartographic = projection.unproject(p, view2Dto3DCartographicScratch);\n  cartographic.longitude = CesiumMath.clamp(cartographic.longitude, -Math.PI, Math.PI);\n  cartographic.latitude = CesiumMath.clamp(cartographic.latitude, -CesiumMath.PI_OVER_TWO, CesiumMath.PI_OVER_TWO);\n  var ellipsoid = projection.ellipsoid;\n  var position3D = ellipsoid.cartographicToCartesian(cartographic, view2Dto3DCartesian3Scratch); // Compute the rotation from the local ENU at the real world camera position to the fixed axes.\n\n  var enuToFixed = Transforms.eastNorthUpToFixedFrame(position3D, ellipsoid, view2Dto3DMatrix4Scratch); // Transform each camera direction to the fixed axes.\n\n  Matrix4.multiplyByPointAsVector(enuToFixed, r, r);\n  Matrix4.multiplyByPointAsVector(enuToFixed, u, u);\n  Matrix4.multiplyByPointAsVector(enuToFixed, d, d); // Compute the view matrix based on the new fixed-frame camera position and directions.\n\n  if (!defined(result)) {\n    result = new Matrix4();\n  }\n\n  result[0] = r.x;\n  result[1] = u.x;\n  result[2] = -d.x;\n  result[3] = 0.0;\n  result[4] = r.y;\n  result[5] = u.y;\n  result[6] = -d.y;\n  result[7] = 0.0;\n  result[8] = r.z;\n  result[9] = u.z;\n  result[10] = -d.z;\n  result[11] = 0.0;\n  result[12] = -Cartesian3.dot(r, position3D);\n  result[13] = -Cartesian3.dot(u, position3D);\n  result[14] = Cartesian3.dot(d, position3D);\n  result[15] = 1.0;\n  return result;\n}\n\nfunction updateView3D(that) {\n  if (that._view3DDirty) {\n    if (that._mode === SceneMode.SCENE3D) {\n      Matrix4.clone(that._view, that._view3D);\n    } else {\n      view2Dto3D(that._cameraPosition, that._cameraDirection, that._cameraRight, that._cameraUp, that._frustum2DWidth, that._mode, that._mapProjection, that._view3D);\n    }\n\n    Matrix4.getMatrix3(that._view3D, that._viewRotation3D);\n    that._view3DDirty = false;\n  }\n}\n\nfunction updateInverseView3D(that) {\n  if (that._inverseView3DDirty) {\n    Matrix4.inverseTransformation(that.view3D, that._inverseView3D);\n    Matrix4.getMatrix3(that._inverseView3D, that._inverseViewRotation3D);\n    that._inverseView3DDirty = false;\n  }\n}\n\nexport default UniformState;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Renderer/UniformState.js"],"names":["BoundingRectangle","Cartesian2","Cartesian3","Cartesian4","Cartographic","Color","defaultValue","defined","Ellipsoid","EncodedCartesian3","CesiumMath","Matrix3","Matrix4","OrthographicFrustum","Simon1994PlanetaryPositions","Transforms","SceneMode","SunLight","UniformState","globeDepthTexture","undefined","gamma","_viewport","_viewportCartesian4","_viewportDirty","_viewportOrthographicMatrix","clone","IDENTITY","_viewportTransformation","_model","_view","_inverseView","_projection","_infiniteProjection","_entireFrustum","_currentFrustum","_frustumPlanes","_farDepthFromNearPlusOne","_log2FarDepthFromNearPlusOne","_oneOverLog2FarDepthFromNearPlusOne","_frameState","_temeToPseudoFixed","_view3DDirty","_view3D","_inverseView3DDirty","_inverseView3D","_inverseModelDirty","_inverseModel","_inverseTransposeModelDirty","_inverseTransposeModel","_viewRotation","_inverseViewRotation","_viewRotation3D","_inverseViewRotation3D","_inverseProjectionDirty","_inverseProjection","_modelViewDirty","_modelView","_modelView3DDirty","_modelView3D","_modelViewRelativeToEyeDirty","_modelViewRelativeToEye","_inverseModelViewDirty","_inverseModelView","_inverseModelView3DDirty","_inverseModelView3D","_viewProjectionDirty","_viewProjection","_inverseViewProjectionDirty","_inverseViewProjection","_modelViewProjectionDirty","_modelViewProjection","_inverseModelViewProjectionDirty","_inverseModelViewProjection","_modelViewProjectionRelativeToEyeDirty","_modelViewProjectionRelativeToEye","_modelViewInfiniteProjectionDirty","_modelViewInfiniteProjection","_normalDirty","_normal","_normal3DDirty","_normal3D","_inverseNormalDirty","_inverseNormal","_inverseNormal3DDirty","_inverseNormal3D","_encodedCameraPositionMCDirty","_encodedCameraPositionMC","_cameraPosition","_sunPositionWC","_sunPositionColumbusView","_sunDirectionWC","_sunDirectionEC","_moonDirectionEC","_lightDirectionWC","_lightDirectionEC","_lightColor","_lightColorHdr","_pass","_mode","_mapProjection","_ellipsoid","_cameraDirection","_cameraRight","_cameraUp","_frustum2DWidth","_eyeHeight2D","_pixelRatio","_orthographicIn3D","_backgroundColor","_brdfLut","_environmentMap","_sphericalHarmonicCoefficients","_specularEnvironmentMaps","_specularEnvironmentMapsDimensions","_specularEnvironmentMapsMaximumLOD","_fogDensity","_invertClassificationColor","_imagerySplitPosition","_pixelSizePerMeter","_geometricToleranceOverMeter","_minimumDisableDepthTestDistance","Object","defineProperties","prototype","frameState","get","viewport","set","equals","v","vc","x","y","z","width","w","height","viewportCartesian4","viewportOrthographic","cleanViewport","viewportTransformation","model","matrix","inverseModel","inverse","inverseTransposeModel","m","getMatrix3","transpose","view","view3D","updateView3D","viewRotation","viewRotation3D","inverseView","inverseView3D","updateInverseView3D","inverseViewRotation","inverseViewRotation3D","projection","inverseProjection","cleanInverseProjection","infiniteProjection","modelView","cleanModelView","modelView3D","cleanModelView3D","modelViewRelativeToEye","cleanModelViewRelativeToEye","inverseModelView","cleanInverseModelView","inverseModelView3D","cleanInverseModelView3D","viewProjection","cleanViewProjection","inverseViewProjection","cleanInverseViewProjection","modelViewProjection","cleanModelViewProjection","inverseModelViewProjection","cleanInverseModelViewProjection","modelViewProjectionRelativeToEye","cleanModelViewProjectionRelativeToEye","modelViewInfiniteProjection","cleanModelViewInfiniteProjection","normal","cleanNormal","normal3D","cleanNormal3D","inverseNormal","cleanInverseNormal","inverseNormal3D","cleanInverseNormal3D","entireFrustum","currentFrustum","frustumPlanes","farDepthFromNearPlusOne","log2FarDepthFromNearPlusOne","oneOverLog2FarDepthFromNearPlusOne","eyeHeight2D","sunPositionWC","sunPositionColumbusView","sunDirectionWC","sunDirectionEC","moonDirectionEC","lightDirectionWC","lightDirectionEC","lightColor","lightColorHdr","encodedCameraPositionMCHigh","cleanEncodedCameraPositionMC","high","encodedCameraPositionMCLow","low","temeToPseudoFixedMatrix","pixelRatio","fogDensity","geometricToleranceOverMeter","pass","backgroundColor","brdfLut","environmentMap","sphericalHarmonicCoefficients","specularEnvironmentMaps","specularEnvironmentMapsDimensions","specularEnvironmentMapsMaximumLOD","imagerySplitPosition","minimumDisableDepthTestDistance","invertClassificationColor","orthographicIn3D","ellipsoid","WGS84","setView","uniformState","setInverseView","setProjection","setInfiniteProjection","setCamera","camera","positionWC","directionWC","rightWC","upWC","transformMatrix","sunCartographicScratch","setSunAndMoonDirections","computeIcrfToFixedMatrix","time","computeTemeToPseudoFixedMatrix","position","computeSunPositionInEarthInertialFrame","multiplyByVector","normalize","computeMoonPositionInEarthInertialFrame","mapProjection","sunCartographic","cartesianToCartographic","project","updateCamera","viewMatrix","inverseViewMatrix","frustum","near","far","updateFrustum","SCENE2D","projectionMatrix","infiniteProjectionMatrix","log2","_offCenterFrustum","top","bottom","left","right","updatePass","EMPTY_ARRAY","defaultLight","update","mode","light","negate","direction","color","fromElements","red","green","blue","multiplyByScalar","intensity","maximumComponent","divideByScalar","brdfLutGenerator","colorTexture","context","defaultCubeMap","dimensions","fog","density","drawingBufferWidth","fov","pixelSizePerMeter","Math","tan","maximumScreenSpaceError","Number","POSITIVE_INFINITY","computeOrthographicOffCenter","computeViewportTransformation","MORPHING","ZERO","multiplyTransformation","multiply","mv","mvRte","getRotation","cameraPositionMC","multiplyByPoint","fromCartesian","view2Dto3DPScratch","view2Dto3DRScratch","view2Dto3DUScratch","view2Dto3DDScratch","view2Dto3DCartographicScratch","view2Dto3DCartesian3Scratch","view2Dto3DMatrix4Scratch","view2Dto3D","position2D","direction2D","right2D","up2D","frustum2DWidth","result","p","r","u","d","cartographic","unproject","longitude","clamp","PI","latitude","PI_OVER_TWO","position3D","cartographicToCartesian","enuToFixed","eastNorthUpToFixedFrame","multiplyByPointAsVector","dot","that","SCENE3D","inverseTransformation"],"mappings":"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","sourcesContent":["import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport Simon1994PlanetaryPositions from \"../Core/Simon1994PlanetaryPositions.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport SunLight from \"../Scene/SunLight.js\";\n\n/**\n * @private\n * @constructor\n */\nfunction UniformState() {\n  /**\n   * @type {Texture}\n   */\n  this.globeDepthTexture = undefined;\n  /**\n   * @type {Number}\n   */\n  this.gamma = undefined;\n\n  this._viewport = new BoundingRectangle();\n  this._viewportCartesian4 = new Cartesian4();\n  this._viewportDirty = false;\n  this._viewportOrthographicMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this._viewportTransformation = Matrix4.clone(Matrix4.IDENTITY);\n\n  this._model = Matrix4.clone(Matrix4.IDENTITY);\n  this._view = Matrix4.clone(Matrix4.IDENTITY);\n  this._inverseView = Matrix4.clone(Matrix4.IDENTITY);\n  this._projection = Matrix4.clone(Matrix4.IDENTITY);\n  this._infiniteProjection = Matrix4.clone(Matrix4.IDENTITY);\n  this._entireFrustum = new Cartesian2();\n  this._currentFrustum = new Cartesian2();\n  this._frustumPlanes = new Cartesian4();\n  this._farDepthFromNearPlusOne = undefined;\n  this._log2FarDepthFromNearPlusOne = undefined;\n  this._oneOverLog2FarDepthFromNearPlusOne = undefined;\n\n  this._frameState = undefined;\n  this._temeToPseudoFixed = Matrix3.clone(Matrix4.IDENTITY);\n\n  // Derived members\n  this._view3DDirty = true;\n  this._view3D = new Matrix4();\n\n  this._inverseView3DDirty = true;\n  this._inverseView3D = new Matrix4();\n\n  this._inverseModelDirty = true;\n  this._inverseModel = new Matrix4();\n\n  this._inverseTransposeModelDirty = true;\n  this._inverseTransposeModel = new Matrix3();\n\n  this._viewRotation = new Matrix3();\n  this._inverseViewRotation = new Matrix3();\n\n  this._viewRotation3D = new Matrix3();\n  this._inverseViewRotation3D = new Matrix3();\n\n  this._inverseProjectionDirty = true;\n  this._inverseProjection = new Matrix4();\n\n  this._modelViewDirty = true;\n  this._modelView = new Matrix4();\n\n  this._modelView3DDirty = true;\n  this._modelView3D = new Matrix4();\n\n  this._modelViewRelativeToEyeDirty = true;\n  this._modelViewRelativeToEye = new Matrix4();\n\n  this._inverseModelViewDirty = true;\n  this._inverseModelView = new Matrix4();\n\n  this._inverseModelView3DDirty = true;\n  this._inverseModelView3D = new Matrix4();\n\n  this._viewProjectionDirty = true;\n  this._viewProjection = new Matrix4();\n\n  this._inverseViewProjectionDirty = true;\n  this._inverseViewProjection = new Matrix4();\n\n  this._modelViewProjectionDirty = true;\n  this._modelViewProjection = new Matrix4();\n\n  this._inverseModelViewProjectionDirty = true;\n  this._inverseModelViewProjection = new Matrix4();\n\n  this._modelViewProjectionRelativeToEyeDirty = true;\n  this._modelViewProjectionRelativeToEye = new Matrix4();\n\n  this._modelViewInfiniteProjectionDirty = true;\n  this._modelViewInfiniteProjection = new Matrix4();\n\n  this._normalDirty = true;\n  this._normal = new Matrix3();\n\n  this._normal3DDirty = true;\n  this._normal3D = new Matrix3();\n\n  this._inverseNormalDirty = true;\n  this._inverseNormal = new Matrix3();\n\n  this._inverseNormal3DDirty = true;\n  this._inverseNormal3D = new Matrix3();\n\n  this._encodedCameraPositionMCDirty = true;\n  this._encodedCameraPositionMC = new EncodedCartesian3();\n  this._cameraPosition = new Cartesian3();\n\n  this._sunPositionWC = new Cartesian3();\n  this._sunPositionColumbusView = new Cartesian3();\n  this._sunDirectionWC = new Cartesian3();\n  this._sunDirectionEC = new Cartesian3();\n  this._moonDirectionEC = new Cartesian3();\n\n  this._lightDirectionWC = new Cartesian3();\n  this._lightDirectionEC = new Cartesian3();\n  this._lightColor = new Cartesian3();\n  this._lightColorHdr = new Cartesian3();\n\n  this._pass = undefined;\n  this._mode = undefined;\n  this._mapProjection = undefined;\n  this._ellipsoid = undefined;\n  this._cameraDirection = new Cartesian3();\n  this._cameraRight = new Cartesian3();\n  this._cameraUp = new Cartesian3();\n  this._frustum2DWidth = 0.0;\n  this._eyeHeight2D = new Cartesian2();\n  this._pixelRatio = 1.0;\n  this._orthographicIn3D = false;\n  this._backgroundColor = new Color();\n\n  this._brdfLut = undefined;\n  this._environmentMap = undefined;\n\n  this._sphericalHarmonicCoefficients = undefined;\n  this._specularEnvironmentMaps = undefined;\n  this._specularEnvironmentMapsDimensions = new Cartesian2();\n  this._specularEnvironmentMapsMaximumLOD = undefined;\n\n  this._fogDensity = undefined;\n\n  this._invertClassificationColor = undefined;\n\n  this._imagerySplitPosition = 0.0;\n  this._pixelSizePerMeter = undefined;\n  this._geometricToleranceOverMeter = undefined;\n\n  this._minimumDisableDepthTestDistance = undefined;\n}\n\nObject.defineProperties(UniformState.prototype, {\n  /**\n   * @memberof UniformState.prototype\n   * @type {FrameState}\n   * @readonly\n   */\n  frameState: {\n    get: function () {\n      return this._frameState;\n    },\n  },\n  /**\n   * @memberof UniformState.prototype\n   * @type {BoundingRectangle}\n   */\n  viewport: {\n    get: function () {\n      return this._viewport;\n    },\n    set: function (viewport) {\n      if (!BoundingRectangle.equals(viewport, this._viewport)) {\n        BoundingRectangle.clone(viewport, this._viewport);\n\n        var v = this._viewport;\n        var vc = this._viewportCartesian4;\n        vc.x = v.x;\n        vc.y = v.y;\n        vc.z = v.width;\n        vc.w = v.height;\n\n        this._viewportDirty = true;\n      }\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @private\n   */\n  viewportCartesian4: {\n    get: function () {\n      return this._viewportCartesian4;\n    },\n  },\n\n  viewportOrthographic: {\n    get: function () {\n      cleanViewport(this);\n      return this._viewportOrthographicMatrix;\n    },\n  },\n\n  viewportTransformation: {\n    get: function () {\n      cleanViewport(this);\n      return this._viewportTransformation;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  model: {\n    get: function () {\n      return this._model;\n    },\n    set: function (matrix) {\n      Matrix4.clone(matrix, this._model);\n\n      this._modelView3DDirty = true;\n      this._inverseModelView3DDirty = true;\n      this._inverseModelDirty = true;\n      this._inverseTransposeModelDirty = true;\n      this._modelViewDirty = true;\n      this._inverseModelViewDirty = true;\n      this._modelViewRelativeToEyeDirty = true;\n      this._inverseModelViewDirty = true;\n      this._modelViewProjectionDirty = true;\n      this._inverseModelViewProjectionDirty = true;\n      this._modelViewProjectionRelativeToEyeDirty = true;\n      this._modelViewInfiniteProjectionDirty = true;\n      this._normalDirty = true;\n      this._inverseNormalDirty = true;\n      this._normal3DDirty = true;\n      this._inverseNormal3DDirty = true;\n      this._encodedCameraPositionMCDirty = true;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseModel: {\n    get: function () {\n      if (this._inverseModelDirty) {\n        this._inverseModelDirty = false;\n\n        Matrix4.inverse(this._model, this._inverseModel);\n      }\n\n      return this._inverseModel;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @private\n   */\n  inverseTransposeModel: {\n    get: function () {\n      var m = this._inverseTransposeModel;\n      if (this._inverseTransposeModelDirty) {\n        this._inverseTransposeModelDirty = false;\n\n        Matrix4.getMatrix3(this.inverseModel, m);\n        Matrix3.transpose(m, m);\n      }\n\n      return m;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  view: {\n    get: function () {\n      return this._view;\n    },\n  },\n\n  /**\n   * The 3D view matrix.  In 3D mode, this is identical to {@link UniformState#view},\n   * but in 2D and Columbus View it is a synthetic matrix based on the equivalent position\n   * of the camera in the 3D world.\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  view3D: {\n    get: function () {\n      updateView3D(this);\n      return this._view3D;\n    },\n  },\n\n  /**\n   * The 3x3 rotation matrix of the current view matrix ({@link UniformState#view}).\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  viewRotation: {\n    get: function () {\n      updateView3D(this);\n      return this._viewRotation;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  viewRotation3D: {\n    get: function () {\n      updateView3D(this);\n      return this._viewRotation3D;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseView: {\n    get: function () {\n      return this._inverseView;\n    },\n  },\n\n  /**\n   * the 4x4 inverse-view matrix that transforms from eye to 3D world coordinates.  In 3D mode, this is\n   * identical to {@link UniformState#inverseView}, but in 2D and Columbus View it is a synthetic matrix\n   * based on the equivalent position of the camera in the 3D world.\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseView3D: {\n    get: function () {\n      updateInverseView3D(this);\n      return this._inverseView3D;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  inverseViewRotation: {\n    get: function () {\n      return this._inverseViewRotation;\n    },\n  },\n\n  /**\n   * The 3x3 rotation matrix of the current 3D inverse-view matrix ({@link UniformState#inverseView3D}).\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  inverseViewRotation3D: {\n    get: function () {\n      updateInverseView3D(this);\n      return this._inverseViewRotation3D;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  projection: {\n    get: function () {\n      return this._projection;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseProjection: {\n    get: function () {\n      cleanInverseProjection(this);\n      return this._inverseProjection;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  infiniteProjection: {\n    get: function () {\n      return this._infiniteProjection;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelView: {\n    get: function () {\n      cleanModelView(this);\n      return this._modelView;\n    },\n  },\n\n  /**\n   * The 3D model-view matrix.  In 3D mode, this is equivalent to {@link UniformState#modelView}.  In 2D and\n   * Columbus View, however, it is a synthetic matrix based on the equivalent position of the camera in the 3D world.\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelView3D: {\n    get: function () {\n      cleanModelView3D(this);\n      return this._modelView3D;\n    },\n  },\n\n  /**\n   * Model-view relative to eye matrix.\n   *\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelViewRelativeToEye: {\n    get: function () {\n      cleanModelViewRelativeToEye(this);\n      return this._modelViewRelativeToEye;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseModelView: {\n    get: function () {\n      cleanInverseModelView(this);\n      return this._inverseModelView;\n    },\n  },\n\n  /**\n   * The inverse of the 3D model-view matrix.  In 3D mode, this is equivalent to {@link UniformState#inverseModelView}.\n   * In 2D and Columbus View, however, it is a synthetic matrix based on the equivalent position of the camera in the 3D world.\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseModelView3D: {\n    get: function () {\n      cleanInverseModelView3D(this);\n      return this._inverseModelView3D;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  viewProjection: {\n    get: function () {\n      cleanViewProjection(this);\n      return this._viewProjection;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseViewProjection: {\n    get: function () {\n      cleanInverseViewProjection(this);\n      return this._inverseViewProjection;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelViewProjection: {\n    get: function () {\n      cleanModelViewProjection(this);\n      return this._modelViewProjection;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseModelViewProjection: {\n    get: function () {\n      cleanInverseModelViewProjection(this);\n      return this._inverseModelViewProjection;\n    },\n  },\n\n  /**\n   * Model-view-projection relative to eye matrix.\n   *\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelViewProjectionRelativeToEye: {\n    get: function () {\n      cleanModelViewProjectionRelativeToEye(this);\n      return this._modelViewProjectionRelativeToEye;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelViewInfiniteProjection: {\n    get: function () {\n      cleanModelViewInfiniteProjection(this);\n      return this._modelViewInfiniteProjection;\n    },\n  },\n\n  /**\n   * A 3x3 normal transformation matrix that transforms normal vectors in model coordinates to\n   * eye coordinates.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  normal: {\n    get: function () {\n      cleanNormal(this);\n      return this._normal;\n    },\n  },\n\n  /**\n   * A 3x3 normal transformation matrix that transforms normal vectors in 3D model\n   * coordinates to eye coordinates.  In 3D mode, this is identical to\n   * {@link UniformState#normal}, but in 2D and Columbus View it represents the normal transformation\n   * matrix as if the camera were at an equivalent location in 3D mode.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  normal3D: {\n    get: function () {\n      cleanNormal3D(this);\n      return this._normal3D;\n    },\n  },\n\n  /**\n   * An inverse 3x3 normal transformation matrix that transforms normal vectors in model coordinates\n   * to eye coordinates.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  inverseNormal: {\n    get: function () {\n      cleanInverseNormal(this);\n      return this._inverseNormal;\n    },\n  },\n\n  /**\n   * An inverse 3x3 normal transformation matrix that transforms normal vectors in eye coordinates\n   * to 3D model coordinates.  In 3D mode, this is identical to\n   * {@link UniformState#inverseNormal}, but in 2D and Columbus View it represents the normal transformation\n   * matrix as if the camera were at an equivalent location in 3D mode.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  inverseNormal3D: {\n    get: function () {\n      cleanInverseNormal3D(this);\n      return this._inverseNormal3D;\n    },\n  },\n\n  /**\n   * The near distance (<code>x</code>) and the far distance (<code>y</code>) of the frustum defined by the camera.\n   * This is the largest possible frustum, not an individual frustum used for multi-frustum rendering.\n   * @memberof UniformState.prototype\n   * @type {Cartesian2}\n   */\n  entireFrustum: {\n    get: function () {\n      return this._entireFrustum;\n    },\n  },\n\n  /**\n   * The near distance (<code>x</code>) and the far distance (<code>y</code>) of the frustum defined by the camera.\n   * This is the individual frustum used for multi-frustum rendering.\n   * @memberof UniformState.prototype\n   * @type {Cartesian2}\n   */\n  currentFrustum: {\n    get: function () {\n      return this._currentFrustum;\n    },\n  },\n\n  /**\n   * The distances to the frustum planes. The top, bottom, left and right distances are\n   * the x, y, z, and w components, respectively.\n   * @memberof UniformState.prototype\n   * @type {Cartesian4}\n   */\n  frustumPlanes: {\n    get: function () {\n      return this._frustumPlanes;\n    },\n  },\n\n  /**\n   * The far plane's distance from the near plane, plus 1.0.\n   *\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  farDepthFromNearPlusOne: {\n    get: function () {\n      return this._farDepthFromNearPlusOne;\n    },\n  },\n\n  /**\n   * The log2 of {@link UniformState#farDepthFromNearPlusOne}.\n   *\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  log2FarDepthFromNearPlusOne: {\n    get: function () {\n      return this._log2FarDepthFromNearPlusOne;\n    },\n  },\n\n  /**\n   * 1.0 divided by {@link UniformState#log2FarDepthFromNearPlusOne}.\n   *\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  oneOverLog2FarDepthFromNearPlusOne: {\n    get: function () {\n      return this._oneOverLog2FarDepthFromNearPlusOne;\n    },\n  },\n\n  /**\n   * The the height (<code>x</code>) and the height squared (<code>y</code>)\n   * in meters of the camera above the 2D world plane. This uniform is only valid\n   * when the {@link SceneMode} equal to <code>SCENE2D</code>.\n   * @memberof UniformState.prototype\n   * @type {Cartesian2}\n   */\n  eyeHeight2D: {\n    get: function () {\n      return this._eyeHeight2D;\n    },\n  },\n\n  /**\n   * The sun position in 3D world coordinates at the current scene time.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  sunPositionWC: {\n    get: function () {\n      return this._sunPositionWC;\n    },\n  },\n\n  /**\n   * The sun position in 2D world coordinates at the current scene time.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  sunPositionColumbusView: {\n    get: function () {\n      return this._sunPositionColumbusView;\n    },\n  },\n\n  /**\n   * A normalized vector to the sun in 3D world coordinates at the current scene time.  Even in 2D or\n   * Columbus View mode, this returns the direction to the sun in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  sunDirectionWC: {\n    get: function () {\n      return this._sunDirectionWC;\n    },\n  },\n\n  /**\n   * A normalized vector to the sun in eye coordinates at the current scene time.  In 3D mode, this\n   * returns the actual vector from the camera position to the sun position.  In 2D and Columbus View, it returns\n   * the vector from the equivalent 3D camera position to the position of the sun in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  sunDirectionEC: {\n    get: function () {\n      return this._sunDirectionEC;\n    },\n  },\n\n  /**\n   * A normalized vector to the moon in eye coordinates at the current scene time.  In 3D mode, this\n   * returns the actual vector from the camera position to the moon position.  In 2D and Columbus View, it returns\n   * the vector from the equivalent 3D camera position to the position of the moon in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  moonDirectionEC: {\n    get: function () {\n      return this._moonDirectionEC;\n    },\n  },\n\n  /**\n   * A normalized vector to the scene's light source in 3D world coordinates.  Even in 2D or\n   * Columbus View mode, this returns the direction to the light in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  lightDirectionWC: {\n    get: function () {\n      return this._lightDirectionWC;\n    },\n  },\n\n  /**\n   * A normalized vector to the scene's light source in eye coordinates.  In 3D mode, this\n   * returns the actual vector from the camera position to the light.  In 2D and Columbus View, it returns\n   * the vector from the equivalent 3D camera position in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  lightDirectionEC: {\n    get: function () {\n      return this._lightDirectionEC;\n    },\n  },\n\n  /**\n   * The color of light emitted by the scene's light source. This is equivalent to the light\n   * color multiplied by the light intensity limited to a maximum luminance of 1.0 suitable\n   * for non-HDR lighting.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  lightColor: {\n    get: function () {\n      return this._lightColor;\n    },\n  },\n\n  /**\n   * The high dynamic range color of light emitted by the scene's light source. This is equivalent to\n   * the light color multiplied by the light intensity suitable for HDR lighting.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  lightColorHdr: {\n    get: function () {\n      return this._lightColorHdr;\n    },\n  },\n\n  /**\n   * The high bits of the camera position.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  encodedCameraPositionMCHigh: {\n    get: function () {\n      cleanEncodedCameraPositionMC(this);\n      return this._encodedCameraPositionMC.high;\n    },\n  },\n\n  /**\n   * The low bits of the camera position.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  encodedCameraPositionMCLow: {\n    get: function () {\n      cleanEncodedCameraPositionMC(this);\n      return this._encodedCameraPositionMC.low;\n    },\n  },\n\n  /**\n   * A 3x3 matrix that transforms from True Equator Mean Equinox (TEME) axes to the\n   * pseudo-fixed axes at the Scene's current time.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  temeToPseudoFixedMatrix: {\n    get: function () {\n      return this._temeToPseudoFixed;\n    },\n  },\n\n  /**\n   * Gets the scaling factor for transforming from the canvas\n   * pixel space to canvas coordinate space.\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  pixelRatio: {\n    get: function () {\n      return this._pixelRatio;\n    },\n  },\n\n  /**\n   * A scalar used to mix a color with the fog color based on the distance to the camera.\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  fogDensity: {\n    get: function () {\n      return this._fogDensity;\n    },\n  },\n\n  /**\n   * A scalar that represents the geometric tolerance per meter\n   * @memberof UniformStat.prototype\n   * @type {Number}\n   */\n  geometricToleranceOverMeter: {\n    get: function () {\n      return this._geometricToleranceOverMeter;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Pass}\n   */\n  pass: {\n    get: function () {\n      return this._pass;\n    },\n  },\n\n  /**\n   * The current background color\n   * @memberof UniformState.prototype\n   * @type {Color}\n   */\n  backgroundColor: {\n    get: function () {\n      return this._backgroundColor;\n    },\n  },\n\n  /**\n   * The look up texture used to find the BRDF for a material\n   * @memberof UniformState.prototype\n   * @type {Texture}\n   */\n  brdfLut: {\n    get: function () {\n      return this._brdfLut;\n    },\n  },\n\n  /**\n   * The environment map of the scene\n   * @memberof UniformState.prototype\n   * @type {CubeMap}\n   */\n  environmentMap: {\n    get: function () {\n      return this._environmentMap;\n    },\n  },\n\n  /**\n   * The spherical harmonic coefficients of the scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3[]}\n   */\n  sphericalHarmonicCoefficients: {\n    get: function () {\n      return this._sphericalHarmonicCoefficients;\n    },\n  },\n\n  /**\n   * The specular environment map atlas of the scene.\n   * @memberof UniformState.prototype\n   * @type {Texture}\n   */\n  specularEnvironmentMaps: {\n    get: function () {\n      return this._specularEnvironmentMaps;\n    },\n  },\n\n  /**\n   * The dimensions of the specular environment map atlas of the scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian2}\n   */\n  specularEnvironmentMapsDimensions: {\n    get: function () {\n      return this._specularEnvironmentMapsDimensions;\n    },\n  },\n\n  /**\n   * The maximum level-of-detail of the specular environment map atlas of the scene.\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  specularEnvironmentMapsMaximumLOD: {\n    get: function () {\n      return this._specularEnvironmentMapsMaximumLOD;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  imagerySplitPosition: {\n    get: function () {\n      return this._imagerySplitPosition;\n    },\n  },\n\n  /**\n   * The distance from the camera at which to disable the depth test of billboards, labels and points\n   * to, for example, prevent clipping against terrain. When set to zero, the depth test should always\n   * be applied. When less than zero, the depth test should never be applied.\n   *\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  minimumDisableDepthTestDistance: {\n    get: function () {\n      return this._minimumDisableDepthTestDistance;\n    },\n  },\n\n  /**\n   * The highlight color of unclassified 3D Tiles.\n   *\n   * @memberof UniformState.prototype\n   * @type {Color}\n   */\n  invertClassificationColor: {\n    get: function () {\n      return this._invertClassificationColor;\n    },\n  },\n\n  /**\n   * Whether or not the current projection is orthographic in 3D.\n   *\n   * @memberOf UniformState.prototype\n   * @type {Boolean}\n   */\n  orthographicIn3D: {\n    get: function () {\n      return this._orthographicIn3D;\n    },\n  },\n\n  /**\n   * The current ellipsoid.\n   *\n   * @memberOf UniformState.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return defaultValue(this._ellipsoid, Ellipsoid.WGS84);\n    },\n  },\n});\n\nfunction setView(uniformState, matrix) {\n  Matrix4.clone(matrix, uniformState._view);\n  Matrix4.getMatrix3(matrix, uniformState._viewRotation);\n\n  uniformState._view3DDirty = true;\n  uniformState._inverseView3DDirty = true;\n  uniformState._modelViewDirty = true;\n  uniformState._modelView3DDirty = true;\n  uniformState._modelViewRelativeToEyeDirty = true;\n  uniformState._inverseModelViewDirty = true;\n  uniformState._inverseModelView3DDirty = true;\n  uniformState._viewProjectionDirty = true;\n  uniformState._inverseViewProjectionDirty = true;\n  uniformState._modelViewProjectionDirty = true;\n  uniformState._modelViewProjectionRelativeToEyeDirty = true;\n  uniformState._modelViewInfiniteProjectionDirty = true;\n  uniformState._normalDirty = true;\n  uniformState._inverseNormalDirty = true;\n  uniformState._normal3DDirty = true;\n  uniformState._inverseNormal3DDirty = true;\n}\n\nfunction setInverseView(uniformState, matrix) {\n  Matrix4.clone(matrix, uniformState._inverseView);\n  Matrix4.getMatrix3(matrix, uniformState._inverseViewRotation);\n}\n\nfunction setProjection(uniformState, matrix) {\n  Matrix4.clone(matrix, uniformState._projection);\n\n  uniformState._inverseProjectionDirty = true;\n  uniformState._viewProjectionDirty = true;\n  uniformState._inverseViewProjectionDirty = true;\n  uniformState._modelViewProjectionDirty = true;\n  uniformState._modelViewProjectionRelativeToEyeDirty = true;\n}\n\nfunction setInfiniteProjection(uniformState, matrix) {\n  Matrix4.clone(matrix, uniformState._infiniteProjection);\n\n  uniformState._modelViewInfiniteProjectionDirty = true;\n}\n\nfunction setCamera(uniformState, camera) {\n  Cartesian3.clone(camera.positionWC, uniformState._cameraPosition);\n  Cartesian3.clone(camera.directionWC, uniformState._cameraDirection);\n  Cartesian3.clone(camera.rightWC, uniformState._cameraRight);\n  Cartesian3.clone(camera.upWC, uniformState._cameraUp);\n  uniformState._encodedCameraPositionMCDirty = true;\n}\n\nvar transformMatrix = new Matrix3();\nvar sunCartographicScratch = new Cartographic();\nfunction setSunAndMoonDirections(uniformState, frameState) {\n  if (\n    !defined(\n      Transforms.computeIcrfToFixedMatrix(frameState.time, transformMatrix)\n    )\n  ) {\n    transformMatrix = Transforms.computeTemeToPseudoFixedMatrix(\n      frameState.time,\n      transformMatrix\n    );\n  }\n\n  var position = Simon1994PlanetaryPositions.computeSunPositionInEarthInertialFrame(\n    frameState.time,\n    uniformState._sunPositionWC\n  );\n  Matrix3.multiplyByVector(transformMatrix, position, position);\n\n  Cartesian3.normalize(position, uniformState._sunDirectionWC);\n\n  position = Matrix3.multiplyByVector(\n    uniformState.viewRotation3D,\n    position,\n    uniformState._sunDirectionEC\n  );\n  Cartesian3.normalize(position, position);\n\n  position = Simon1994PlanetaryPositions.computeMoonPositionInEarthInertialFrame(\n    frameState.time,\n    uniformState._moonDirectionEC\n  );\n  Matrix3.multiplyByVector(transformMatrix, position, position);\n  Matrix3.multiplyByVector(uniformState.viewRotation3D, position, position);\n  Cartesian3.normalize(position, position);\n\n  var projection = frameState.mapProjection;\n  var ellipsoid = projection.ellipsoid;\n  var sunCartographic = ellipsoid.cartesianToCartographic(\n    uniformState._sunPositionWC,\n    sunCartographicScratch\n  );\n  projection.project(sunCartographic, uniformState._sunPositionColumbusView);\n}\n\n/**\n * Synchronizes the frustum's state with the camera state.  This is called\n * by the {@link Scene} when rendering to ensure that automatic GLSL uniforms\n * are set to the right value.\n *\n * @param {Object} camera The camera to synchronize with.\n */\nUniformState.prototype.updateCamera = function (camera) {\n  setView(this, camera.viewMatrix);\n  setInverseView(this, camera.inverseViewMatrix);\n  setCamera(this, camera);\n\n  this._entireFrustum.x = camera.frustum.near;\n  this._entireFrustum.y = camera.frustum.far;\n  this.updateFrustum(camera.frustum);\n\n  this._orthographicIn3D =\n    this._mode !== SceneMode.SCENE2D &&\n    camera.frustum instanceof OrthographicFrustum;\n};\n\n/**\n * Synchronizes the frustum's state with the uniform state.  This is called\n * by the {@link Scene} when rendering to ensure that automatic GLSL uniforms\n * are set to the right value.\n *\n * @param {Object} frustum The frustum to synchronize with.\n */\nUniformState.prototype.updateFrustum = function (frustum) {\n  setProjection(this, frustum.projectionMatrix);\n  if (defined(frustum.infiniteProjectionMatrix)) {\n    setInfiniteProjection(this, frustum.infiniteProjectionMatrix);\n  }\n  this._currentFrustum.x = frustum.near;\n  this._currentFrustum.y = frustum.far;\n\n  this._farDepthFromNearPlusOne = frustum.far - frustum.near + 1.0;\n  this._log2FarDepthFromNearPlusOne = CesiumMath.log2(\n    this._farDepthFromNearPlusOne\n  );\n  this._oneOverLog2FarDepthFromNearPlusOne =\n    1.0 / this._log2FarDepthFromNearPlusOne;\n\n  if (defined(frustum._offCenterFrustum)) {\n    frustum = frustum._offCenterFrustum;\n  }\n\n  this._frustumPlanes.x = frustum.top;\n  this._frustumPlanes.y = frustum.bottom;\n  this._frustumPlanes.z = frustum.left;\n  this._frustumPlanes.w = frustum.right;\n};\n\nUniformState.prototype.updatePass = function (pass) {\n  this._pass = pass;\n};\n\nvar EMPTY_ARRAY = [];\nvar defaultLight = new SunLight();\n\n/**\n * Synchronizes frame state with the uniform state.  This is called\n * by the {@link Scene} when rendering to ensure that automatic GLSL uniforms\n * are set to the right value.\n *\n * @param {FrameState} frameState The frameState to synchronize with.\n */\nUniformState.prototype.update = function (frameState) {\n  this._mode = frameState.mode;\n  this._mapProjection = frameState.mapProjection;\n  this._ellipsoid = frameState.mapProjection.ellipsoid;\n  this._pixelRatio = frameState.pixelRatio;\n\n  var camera = frameState.camera;\n  this.updateCamera(camera);\n\n  if (frameState.mode === SceneMode.SCENE2D) {\n    this._frustum2DWidth = camera.frustum.right - camera.frustum.left;\n    this._eyeHeight2D.x = this._frustum2DWidth * 0.5;\n    this._eyeHeight2D.y = this._eyeHeight2D.x * this._eyeHeight2D.x;\n  } else {\n    this._frustum2DWidth = 0.0;\n    this._eyeHeight2D.x = 0.0;\n    this._eyeHeight2D.y = 0.0;\n  }\n\n  setSunAndMoonDirections(this, frameState);\n\n  var light = defaultValue(frameState.light, defaultLight);\n  if (light instanceof SunLight) {\n    this._lightDirectionWC = Cartesian3.clone(\n      this._sunDirectionWC,\n      this._lightDirectionWC\n    );\n    this._lightDirectionEC = Cartesian3.clone(\n      this._sunDirectionEC,\n      this._lightDirectionEC\n    );\n  } else {\n    this._lightDirectionWC = Cartesian3.normalize(\n      Cartesian3.negate(light.direction, this._lightDirectionWC),\n      this._lightDirectionWC\n    );\n    this._lightDirectionEC = Matrix3.multiplyByVector(\n      this.viewRotation3D,\n      this._lightDirectionWC,\n      this._lightDirectionEC\n    );\n  }\n\n  var lightColor = light.color;\n  var lightColorHdr = Cartesian3.fromElements(\n    lightColor.red,\n    lightColor.green,\n    lightColor.blue,\n    this._lightColorHdr\n  );\n  lightColorHdr = Cartesian3.multiplyByScalar(\n    lightColorHdr,\n    light.intensity,\n    lightColorHdr\n  );\n  var maximumComponent = Cartesian3.maximumComponent(lightColorHdr);\n  if (maximumComponent > 1.0) {\n    Cartesian3.divideByScalar(\n      lightColorHdr,\n      maximumComponent,\n      this._lightColor\n    );\n  } else {\n    Cartesian3.clone(lightColorHdr, this._lightColor);\n  }\n\n  var brdfLutGenerator = frameState.brdfLutGenerator;\n  var brdfLut = defined(brdfLutGenerator)\n    ? brdfLutGenerator.colorTexture\n    : undefined;\n  this._brdfLut = brdfLut;\n\n  this._environmentMap = defaultValue(\n    frameState.environmentMap,\n    frameState.context.defaultCubeMap\n  );\n\n  // IE 11 doesn't optimize out uniforms that are #ifdef'd out. So undefined values for the spherical harmonic\n  // coefficients and specular environment map atlas dimensions cause a crash.\n  this._sphericalHarmonicCoefficients = defaultValue(\n    frameState.sphericalHarmonicCoefficients,\n    EMPTY_ARRAY\n  );\n  this._specularEnvironmentMaps = frameState.specularEnvironmentMaps;\n  this._specularEnvironmentMapsMaximumLOD =\n    frameState.specularEnvironmentMapsMaximumLOD;\n\n  if (defined(this._specularEnvironmentMaps)) {\n    Cartesian2.clone(\n      this._specularEnvironmentMaps.dimensions,\n      this._specularEnvironmentMapsDimensions\n    );\n  }\n\n  this._fogDensity = frameState.fog.density;\n\n  this._invertClassificationColor = frameState.invertClassificationColor;\n\n  this._frameState = frameState;\n  this._temeToPseudoFixed = Transforms.computeTemeToPseudoFixedMatrix(\n    frameState.time,\n    this._temeToPseudoFixed\n  );\n\n  // Convert the relative imagerySplitPosition to absolute pixel coordinates\n  this._imagerySplitPosition =\n    frameState.imagerySplitPosition * frameState.context.drawingBufferWidth;\n  var fov = camera.frustum.fov;\n  var viewport = this._viewport;\n  var pixelSizePerMeter;\n  if (viewport.height > viewport.width) {\n    pixelSizePerMeter = (Math.tan(0.5 * fov) * 2.0) / viewport.height;\n  } else {\n    pixelSizePerMeter = (Math.tan(0.5 * fov) * 2.0) / viewport.width;\n  }\n\n  this._geometricToleranceOverMeter =\n    pixelSizePerMeter * frameState.maximumScreenSpaceError;\n  Color.clone(frameState.backgroundColor, this._backgroundColor);\n\n  this._minimumDisableDepthTestDistance =\n    frameState.minimumDisableDepthTestDistance;\n  this._minimumDisableDepthTestDistance *= this._minimumDisableDepthTestDistance;\n  if (this._minimumDisableDepthTestDistance === Number.POSITIVE_INFINITY) {\n    this._minimumDisableDepthTestDistance = -1.0;\n  }\n};\n\nfunction cleanViewport(uniformState) {\n  if (uniformState._viewportDirty) {\n    var v = uniformState._viewport;\n    Matrix4.computeOrthographicOffCenter(\n      v.x,\n      v.x + v.width,\n      v.y,\n      v.y + v.height,\n      0.0,\n      1.0,\n      uniformState._viewportOrthographicMatrix\n    );\n    Matrix4.computeViewportTransformation(\n      v,\n      0.0,\n      1.0,\n      uniformState._viewportTransformation\n    );\n    uniformState._viewportDirty = false;\n  }\n}\n\nfunction cleanInverseProjection(uniformState) {\n  if (uniformState._inverseProjectionDirty) {\n    uniformState._inverseProjectionDirty = false;\n\n    if (\n      uniformState._mode !== SceneMode.SCENE2D &&\n      uniformState._mode !== SceneMode.MORPHING &&\n      !uniformState._orthographicIn3D\n    ) {\n      Matrix4.inverse(\n        uniformState._projection,\n        uniformState._inverseProjection\n      );\n    } else {\n      Matrix4.clone(Matrix4.ZERO, uniformState._inverseProjection);\n    }\n  }\n}\n\n// Derived\nfunction cleanModelView(uniformState) {\n  if (uniformState._modelViewDirty) {\n    uniformState._modelViewDirty = false;\n\n    Matrix4.multiplyTransformation(\n      uniformState._view,\n      uniformState._model,\n      uniformState._modelView\n    );\n  }\n}\n\nfunction cleanModelView3D(uniformState) {\n  if (uniformState._modelView3DDirty) {\n    uniformState._modelView3DDirty = false;\n\n    Matrix4.multiplyTransformation(\n      uniformState.view3D,\n      uniformState._model,\n      uniformState._modelView3D\n    );\n  }\n}\n\nfunction cleanInverseModelView(uniformState) {\n  if (uniformState._inverseModelViewDirty) {\n    uniformState._inverseModelViewDirty = false;\n\n    Matrix4.inverse(uniformState.modelView, uniformState._inverseModelView);\n  }\n}\n\nfunction cleanInverseModelView3D(uniformState) {\n  if (uniformState._inverseModelView3DDirty) {\n    uniformState._inverseModelView3DDirty = false;\n\n    Matrix4.inverse(uniformState.modelView3D, uniformState._inverseModelView3D);\n  }\n}\n\nfunction cleanViewProjection(uniformState) {\n  if (uniformState._viewProjectionDirty) {\n    uniformState._viewProjectionDirty = false;\n\n    Matrix4.multiply(\n      uniformState._projection,\n      uniformState._view,\n      uniformState._viewProjection\n    );\n  }\n}\n\nfunction cleanInverseViewProjection(uniformState) {\n  if (uniformState._inverseViewProjectionDirty) {\n    uniformState._inverseViewProjectionDirty = false;\n\n    Matrix4.inverse(\n      uniformState.viewProjection,\n      uniformState._inverseViewProjection\n    );\n  }\n}\n\nfunction cleanModelViewProjection(uniformState) {\n  if (uniformState._modelViewProjectionDirty) {\n    uniformState._modelViewProjectionDirty = false;\n\n    Matrix4.multiply(\n      uniformState._projection,\n      uniformState.modelView,\n      uniformState._modelViewProjection\n    );\n  }\n}\n\nfunction cleanModelViewRelativeToEye(uniformState) {\n  if (uniformState._modelViewRelativeToEyeDirty) {\n    uniformState._modelViewRelativeToEyeDirty = false;\n\n    var mv = uniformState.modelView;\n    var mvRte = uniformState._modelViewRelativeToEye;\n    mvRte[0] = mv[0];\n    mvRte[1] = mv[1];\n    mvRte[2] = mv[2];\n    mvRte[3] = mv[3];\n    mvRte[4] = mv[4];\n    mvRte[5] = mv[5];\n    mvRte[6] = mv[6];\n    mvRte[7] = mv[7];\n    mvRte[8] = mv[8];\n    mvRte[9] = mv[9];\n    mvRte[10] = mv[10];\n    mvRte[11] = mv[11];\n    mvRte[12] = 0.0;\n    mvRte[13] = 0.0;\n    mvRte[14] = 0.0;\n    mvRte[15] = mv[15];\n  }\n}\n\nfunction cleanInverseModelViewProjection(uniformState) {\n  if (uniformState._inverseModelViewProjectionDirty) {\n    uniformState._inverseModelViewProjectionDirty = false;\n\n    Matrix4.inverse(\n      uniformState.modelViewProjection,\n      uniformState._inverseModelViewProjection\n    );\n  }\n}\n\nfunction cleanModelViewProjectionRelativeToEye(uniformState) {\n  if (uniformState._modelViewProjectionRelativeToEyeDirty) {\n    uniformState._modelViewProjectionRelativeToEyeDirty = false;\n\n    Matrix4.multiply(\n      uniformState._projection,\n      uniformState.modelViewRelativeToEye,\n      uniformState._modelViewProjectionRelativeToEye\n    );\n  }\n}\n\nfunction cleanModelViewInfiniteProjection(uniformState) {\n  if (uniformState._modelViewInfiniteProjectionDirty) {\n    uniformState._modelViewInfiniteProjectionDirty = false;\n\n    Matrix4.multiply(\n      uniformState._infiniteProjection,\n      uniformState.modelView,\n      uniformState._modelViewInfiniteProjection\n    );\n  }\n}\n\nfunction cleanNormal(uniformState) {\n  if (uniformState._normalDirty) {\n    uniformState._normalDirty = false;\n\n    var m = uniformState._normal;\n    Matrix4.getMatrix3(uniformState.inverseModelView, m);\n    Matrix3.getRotation(m, m);\n    Matrix3.transpose(m, m);\n  }\n}\n\nfunction cleanNormal3D(uniformState) {\n  if (uniformState._normal3DDirty) {\n    uniformState._normal3DDirty = false;\n\n    var m = uniformState._normal3D;\n    Matrix4.getMatrix3(uniformState.inverseModelView3D, m);\n    Matrix3.getRotation(m, m);\n    Matrix3.transpose(m, m);\n  }\n}\n\nfunction cleanInverseNormal(uniformState) {\n  if (uniformState._inverseNormalDirty) {\n    uniformState._inverseNormalDirty = false;\n    Matrix4.getMatrix3(\n      uniformState.inverseModelView,\n      uniformState._inverseNormal\n    );\n    Matrix3.getRotation(\n      uniformState._inverseNormal,\n      uniformState._inverseNormal\n    );\n  }\n}\n\nfunction cleanInverseNormal3D(uniformState) {\n  if (uniformState._inverseNormal3DDirty) {\n    uniformState._inverseNormal3DDirty = false;\n    Matrix4.getMatrix3(\n      uniformState.inverseModelView3D,\n      uniformState._inverseNormal3D\n    );\n    Matrix3.getRotation(\n      uniformState._inverseNormal3D,\n      uniformState._inverseNormal3D\n    );\n  }\n}\n\nvar cameraPositionMC = new Cartesian3();\n\nfunction cleanEncodedCameraPositionMC(uniformState) {\n  if (uniformState._encodedCameraPositionMCDirty) {\n    uniformState._encodedCameraPositionMCDirty = false;\n\n    Matrix4.multiplyByPoint(\n      uniformState.inverseModel,\n      uniformState._cameraPosition,\n      cameraPositionMC\n    );\n    EncodedCartesian3.fromCartesian(\n      cameraPositionMC,\n      uniformState._encodedCameraPositionMC\n    );\n  }\n}\n\nvar view2Dto3DPScratch = new Cartesian3();\nvar view2Dto3DRScratch = new Cartesian3();\nvar view2Dto3DUScratch = new Cartesian3();\nvar view2Dto3DDScratch = new Cartesian3();\nvar view2Dto3DCartographicScratch = new Cartographic();\nvar view2Dto3DCartesian3Scratch = new Cartesian3();\nvar view2Dto3DMatrix4Scratch = new Matrix4();\n\nfunction view2Dto3D(\n  position2D,\n  direction2D,\n  right2D,\n  up2D,\n  frustum2DWidth,\n  mode,\n  projection,\n  result\n) {\n  // The camera position and directions are expressed in the 2D coordinate system where the Y axis is to the East,\n  // the Z axis is to the North, and the X axis is out of the map.  Express them instead in the ENU axes where\n  // X is to the East, Y is to the North, and Z is out of the local horizontal plane.\n  var p = view2Dto3DPScratch;\n  p.x = position2D.y;\n  p.y = position2D.z;\n  p.z = position2D.x;\n\n  var r = view2Dto3DRScratch;\n  r.x = right2D.y;\n  r.y = right2D.z;\n  r.z = right2D.x;\n\n  var u = view2Dto3DUScratch;\n  u.x = up2D.y;\n  u.y = up2D.z;\n  u.z = up2D.x;\n\n  var d = view2Dto3DDScratch;\n  d.x = direction2D.y;\n  d.y = direction2D.z;\n  d.z = direction2D.x;\n\n  // In 2D, the camera height is always 12.7 million meters.\n  // The apparent height is equal to half the frustum width.\n  if (mode === SceneMode.SCENE2D) {\n    p.z = frustum2DWidth * 0.5;\n  }\n\n  // Compute the equivalent camera position in the real (3D) world.\n  // In 2D and Columbus View, the camera can travel outside the projection, and when it does so\n  // there's not really any corresponding location in the real world.  So clamp the unprojected\n  // longitude and latitude to their valid ranges.\n  var cartographic = projection.unproject(p, view2Dto3DCartographicScratch);\n  cartographic.longitude = CesiumMath.clamp(\n    cartographic.longitude,\n    -Math.PI,\n    Math.PI\n  );\n  cartographic.latitude = CesiumMath.clamp(\n    cartographic.latitude,\n    -CesiumMath.PI_OVER_TWO,\n    CesiumMath.PI_OVER_TWO\n  );\n  var ellipsoid = projection.ellipsoid;\n  var position3D = ellipsoid.cartographicToCartesian(\n    cartographic,\n    view2Dto3DCartesian3Scratch\n  );\n\n  // Compute the rotation from the local ENU at the real world camera position to the fixed axes.\n  var enuToFixed = Transforms.eastNorthUpToFixedFrame(\n    position3D,\n    ellipsoid,\n    view2Dto3DMatrix4Scratch\n  );\n\n  // Transform each camera direction to the fixed axes.\n  Matrix4.multiplyByPointAsVector(enuToFixed, r, r);\n  Matrix4.multiplyByPointAsVector(enuToFixed, u, u);\n  Matrix4.multiplyByPointAsVector(enuToFixed, d, d);\n\n  // Compute the view matrix based on the new fixed-frame camera position and directions.\n  if (!defined(result)) {\n    result = new Matrix4();\n  }\n\n  result[0] = r.x;\n  result[1] = u.x;\n  result[2] = -d.x;\n  result[3] = 0.0;\n  result[4] = r.y;\n  result[5] = u.y;\n  result[6] = -d.y;\n  result[7] = 0.0;\n  result[8] = r.z;\n  result[9] = u.z;\n  result[10] = -d.z;\n  result[11] = 0.0;\n  result[12] = -Cartesian3.dot(r, position3D);\n  result[13] = -Cartesian3.dot(u, position3D);\n  result[14] = Cartesian3.dot(d, position3D);\n  result[15] = 1.0;\n\n  return result;\n}\n\nfunction updateView3D(that) {\n  if (that._view3DDirty) {\n    if (that._mode === SceneMode.SCENE3D) {\n      Matrix4.clone(that._view, that._view3D);\n    } else {\n      view2Dto3D(\n        that._cameraPosition,\n        that._cameraDirection,\n        that._cameraRight,\n        that._cameraUp,\n        that._frustum2DWidth,\n        that._mode,\n        that._mapProjection,\n        that._view3D\n      );\n    }\n    Matrix4.getMatrix3(that._view3D, that._viewRotation3D);\n    that._view3DDirty = false;\n  }\n}\n\nfunction updateInverseView3D(that) {\n  if (that._inverseView3DDirty) {\n    Matrix4.inverseTransformation(that.view3D, that._inverseView3D);\n    Matrix4.getMatrix3(that._inverseView3D, that._inverseViewRotation3D);\n    that._inverseView3DDirty = false;\n  }\n}\nexport default UniformState;\n"]},"metadata":{},"sourceType":"module"}