{"ast":null,"code":"import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport defined from \"../Core/defined.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport RectangleCollisionChecker from \"../Core/RectangleCollisionChecker.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport GroundPrimitive from \"../Scene/GroundPrimitive.js\";\nimport ShadowVolumeAppearance from \"../Scene/ShadowVolumeAppearance.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport MaterialProperty from \"./MaterialProperty.js\";\nimport Property from \"./Property.js\";\nvar distanceDisplayConditionScratch = new DistanceDisplayCondition();\nvar defaultDistanceDisplayCondition = new DistanceDisplayCondition(); // Encapsulates a Primitive and all the entities that it represents.\n\nfunction Batch(primitives, classificationType, appearanceType, materialProperty, usingSphericalTextureCoordinates, zIndex) {\n  this.primitives = primitives; // scene level primitive collection\n\n  this.classificationType = classificationType;\n  this.appearanceType = appearanceType;\n  this.materialProperty = materialProperty;\n  this.updaters = new AssociativeArray();\n  this.createPrimitive = true;\n  this.primitive = undefined; // a GroundPrimitive encapsulating all the entities\n\n  this.oldPrimitive = undefined;\n  this.geometry = new AssociativeArray();\n  this.material = undefined;\n  this.updatersWithAttributes = new AssociativeArray();\n  this.attributes = new AssociativeArray();\n  this.invalidated = false;\n  this.removeMaterialSubscription = materialProperty.definitionChanged.addEventListener(Batch.prototype.onMaterialChanged, this);\n  this.subscriptions = new AssociativeArray();\n  this.showsUpdated = new AssociativeArray();\n  this.usingSphericalTextureCoordinates = usingSphericalTextureCoordinates;\n  this.zIndex = zIndex;\n  this.rectangleCollisionCheck = new RectangleCollisionChecker();\n}\n\nBatch.prototype.onMaterialChanged = function () {\n  this.invalidated = true;\n};\n\nBatch.prototype.overlapping = function (rectangle) {\n  return this.rectangleCollisionCheck.collides(rectangle);\n}; // Check if the given updater's material is compatible with this batch\n\n\nBatch.prototype.isMaterial = function (updater) {\n  var material = this.materialProperty;\n  var updaterMaterial = updater.fillMaterialProperty;\n\n  if (updaterMaterial === material || updaterMaterial instanceof ColorMaterialProperty && material instanceof ColorMaterialProperty) {\n    return true;\n  }\n\n  return defined(material) && material.equals(updaterMaterial);\n};\n\nBatch.prototype.add = function (time, updater, geometryInstance) {\n  var id = updater.id;\n  this.updaters.set(id, updater);\n  this.geometry.set(id, geometryInstance);\n  this.rectangleCollisionCheck.insert(id, geometryInstance.geometry.rectangle); // Updaters with dynamic attributes must be tracked separately, may exit the batch\n\n  if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty)) {\n    this.updatersWithAttributes.set(id, updater);\n  } else {\n    var that = this; // Listen for show changes. These will be synchronized in updateShows.\n\n    this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function (entity, propertyName, newValue, oldValue) {\n      if (propertyName === \"isShowing\") {\n        that.showsUpdated.set(updater.id, updater);\n      }\n    }));\n  }\n\n  this.createPrimitive = true;\n};\n\nBatch.prototype.remove = function (updater) {\n  var id = updater.id;\n  var geometryInstance = this.geometry.get(id);\n  this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n\n  if (this.updaters.remove(id)) {\n    this.rectangleCollisionCheck.remove(id, geometryInstance.geometry.rectangle);\n    this.updatersWithAttributes.remove(id);\n    var unsubscribe = this.subscriptions.get(id);\n\n    if (defined(unsubscribe)) {\n      unsubscribe();\n      this.subscriptions.remove(id);\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nBatch.prototype.update = function (time) {\n  var isUpdated = true;\n  var primitive = this.primitive;\n  var primitives = this.primitives;\n  var geometries = this.geometry.values;\n  var i;\n\n  if (this.createPrimitive) {\n    var geometriesLength = geometries.length;\n\n    if (geometriesLength > 0) {\n      if (defined(primitive)) {\n        // Keep a handle to the old primitive so it can be removed when the updated version is ready.\n        if (!defined(this.oldPrimitive)) {\n          this.oldPrimitive = primitive;\n        } else {\n          // For if the new primitive changes again before it is ready.\n          primitives.remove(primitive);\n        }\n      }\n\n      this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n      primitive = new GroundPrimitive({\n        show: false,\n        asynchronous: true,\n        geometryInstances: geometries.slice(),\n        appearance: new this.appearanceType({\n          material: this.material // translucent and closed properties overridden\n\n        }),\n        classificationType: this.classificationType\n      });\n      primitives.add(primitive, this.zIndex);\n      isUpdated = false;\n    } else {\n      if (defined(primitive)) {\n        primitives.remove(primitive);\n        primitive = undefined;\n      }\n\n      var oldPrimitive = this.oldPrimitive;\n\n      if (defined(oldPrimitive)) {\n        primitives.remove(oldPrimitive);\n        this.oldPrimitive = undefined;\n      }\n    }\n\n    this.attributes.removeAll();\n    this.primitive = primitive;\n    this.createPrimitive = false;\n  } else if (defined(primitive) && primitive.ready) {\n    primitive.show = true;\n\n    if (defined(this.oldPrimitive)) {\n      primitives.remove(this.oldPrimitive);\n      this.oldPrimitive = undefined;\n    }\n\n    this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n    this.primitive.appearance.material = this.material;\n    var updatersWithAttributes = this.updatersWithAttributes.values;\n    var length = updatersWithAttributes.length;\n\n    for (i = 0; i < length; i++) {\n      var updater = updatersWithAttributes[i];\n      var entity = updater.entity;\n      var instance = this.geometry.get(updater.id);\n      var attributes = this.attributes.get(instance.id.id);\n\n      if (!defined(attributes)) {\n        attributes = primitive.getGeometryInstanceAttributes(instance.id);\n        this.attributes.set(instance.id.id, attributes);\n      }\n\n      var show = entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n      var currentShow = attributes.show[0] === 1;\n\n      if (show !== currentShow) {\n        attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n      }\n\n      var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n\n      if (!Property.isConstant(distanceDisplayConditionProperty)) {\n        var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n\n        if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n          attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n          attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n        }\n      }\n    }\n\n    this.updateShows(primitive);\n  } else if (defined(primitive) && !primitive.ready) {\n    isUpdated = false;\n  }\n\n  return isUpdated;\n};\n\nBatch.prototype.updateShows = function (primitive) {\n  var showsUpdated = this.showsUpdated.values;\n  var length = showsUpdated.length;\n\n  for (var i = 0; i < length; i++) {\n    var updater = showsUpdated[i];\n    var entity = updater.entity;\n    var instance = this.geometry.get(updater.id);\n    var attributes = this.attributes.get(instance.id.id);\n\n    if (!defined(attributes)) {\n      attributes = primitive.getGeometryInstanceAttributes(instance.id);\n      this.attributes.set(instance.id.id, attributes);\n    }\n\n    var show = entity.isShowing;\n    var currentShow = attributes.show[0] === 1;\n\n    if (show !== currentShow) {\n      attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n      instance.attributes.show.value[0] = attributes.show[0];\n    }\n  }\n\n  this.showsUpdated.removeAll();\n};\n\nBatch.prototype.contains = function (updater) {\n  return this.updaters.contains(updater.id);\n};\n\nBatch.prototype.getBoundingSphere = function (updater, result) {\n  var primitive = this.primitive;\n\n  if (!primitive.ready) {\n    return BoundingSphereState.PENDING;\n  }\n\n  var attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n\n  if (!defined(attributes) || !defined(attributes.boundingSphere) || defined(attributes.show) && attributes.show[0] === 0) {\n    return BoundingSphereState.FAILED;\n  }\n\n  attributes.boundingSphere.clone(result);\n  return BoundingSphereState.DONE;\n};\n\nBatch.prototype.destroy = function () {\n  var primitive = this.primitive;\n  var primitives = this.primitives;\n\n  if (defined(primitive)) {\n    primitives.remove(primitive);\n  }\n\n  var oldPrimitive = this.oldPrimitive;\n\n  if (defined(oldPrimitive)) {\n    primitives.remove(oldPrimitive);\n  }\n\n  this.removeMaterialSubscription();\n};\n/**\n * @private\n */\n\n\nfunction StaticGroundGeometryPerMaterialBatch(primitives, classificationType, appearanceType) {\n  this._items = [];\n  this._primitives = primitives;\n  this._classificationType = classificationType;\n  this._appearanceType = appearanceType;\n}\n\nStaticGroundGeometryPerMaterialBatch.prototype.add = function (time, updater) {\n  var items = this._items;\n  var length = items.length;\n  var geometryInstance = updater.createFillGeometryInstance(time);\n  var usingSphericalTextureCoordinates = ShadowVolumeAppearance.shouldUseSphericalCoordinates(geometryInstance.geometry.rectangle);\n  var zIndex = Property.getValueOrDefault(updater.zIndex, 0); // Check if the Entity represented by the updater can be placed in an existing batch. Requirements:\n  // * compatible material (same material or same color)\n  // * same type of texture coordinates (spherical vs. planar)\n  // * conservatively non-overlapping with any entities in the existing batch\n\n  for (var i = 0; i < length; ++i) {\n    var item = items[i];\n\n    if (item.isMaterial(updater) && item.usingSphericalTextureCoordinates === usingSphericalTextureCoordinates && item.zIndex === zIndex && !item.overlapping(geometryInstance.geometry.rectangle)) {\n      item.add(time, updater, geometryInstance);\n      return;\n    }\n  } // If a compatible batch wasn't found, create a new batch.\n\n\n  var batch = new Batch(this._primitives, this._classificationType, this._appearanceType, updater.fillMaterialProperty, usingSphericalTextureCoordinates, zIndex);\n  batch.add(time, updater, geometryInstance);\n  items.push(batch);\n};\n\nStaticGroundGeometryPerMaterialBatch.prototype.remove = function (updater) {\n  var items = this._items;\n  var length = items.length;\n\n  for (var i = length - 1; i >= 0; i--) {\n    var item = items[i];\n\n    if (item.remove(updater)) {\n      if (item.updaters.length === 0) {\n        items.splice(i, 1);\n        item.destroy();\n      }\n\n      break;\n    }\n  }\n};\n\nStaticGroundGeometryPerMaterialBatch.prototype.update = function (time) {\n  var i;\n  var items = this._items;\n  var length = items.length;\n\n  for (i = length - 1; i >= 0; i--) {\n    var item = items[i];\n\n    if (item.invalidated) {\n      items.splice(i, 1);\n      var updaters = item.updaters.values;\n      var updatersLength = updaters.length;\n\n      for (var h = 0; h < updatersLength; h++) {\n        this.add(time, updaters[h]);\n      }\n\n      item.destroy();\n    }\n  }\n\n  var isUpdated = true;\n\n  for (i = 0; i < items.length; i++) {\n    isUpdated = items[i].update(time) && isUpdated;\n  }\n\n  return isUpdated;\n};\n\nStaticGroundGeometryPerMaterialBatch.prototype.getBoundingSphere = function (updater, result) {\n  var items = this._items;\n  var length = items.length;\n\n  for (var i = 0; i < length; i++) {\n    var item = items[i];\n\n    if (item.contains(updater)) {\n      return item.getBoundingSphere(updater, result);\n    }\n  }\n\n  return BoundingSphereState.FAILED;\n};\n\nStaticGroundGeometryPerMaterialBatch.prototype.removeAllPrimitives = function () {\n  var items = this._items;\n  var length = items.length;\n\n  for (var i = 0; i < length; i++) {\n    items[i].destroy();\n  }\n\n  this._items.length = 0;\n};\n\nexport default StaticGroundGeometryPerMaterialBatch;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/DataSources/StaticGroundGeometryPerMaterialBatch.js"],"names":["AssociativeArray","defined","DistanceDisplayCondition","DistanceDisplayConditionGeometryInstanceAttribute","RectangleCollisionChecker","ShowGeometryInstanceAttribute","GroundPrimitive","ShadowVolumeAppearance","BoundingSphereState","ColorMaterialProperty","MaterialProperty","Property","distanceDisplayConditionScratch","defaultDistanceDisplayCondition","Batch","primitives","classificationType","appearanceType","materialProperty","usingSphericalTextureCoordinates","zIndex","updaters","createPrimitive","primitive","undefined","oldPrimitive","geometry","material","updatersWithAttributes","attributes","invalidated","removeMaterialSubscription","definitionChanged","addEventListener","prototype","onMaterialChanged","subscriptions","showsUpdated","rectangleCollisionCheck","overlapping","rectangle","collides","isMaterial","updater","updaterMaterial","fillMaterialProperty","equals","add","time","geometryInstance","id","set","insert","hasConstantFill","isConstant","distanceDisplayConditionProperty","that","entity","propertyName","newValue","oldValue","remove","get","unsubscribe","update","isUpdated","geometries","values","i","geometriesLength","length","getValue","show","asynchronous","geometryInstances","slice","appearance","removeAll","ready","instance","getGeometryInstanceAttributes","isShowing","isFilled","currentShow","toValue","distanceDisplayCondition","getValueOrDefault","_lastDistanceDisplayCondition","clone","updateShows","value","contains","getBoundingSphere","result","PENDING","boundingSphere","FAILED","DONE","destroy","StaticGroundGeometryPerMaterialBatch","_items","_primitives","_classificationType","_appearanceType","items","createFillGeometryInstance","shouldUseSphericalCoordinates","item","batch","push","splice","updatersLength","h","removeAllPrimitives"],"mappings":"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","sourcesContent":["import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport defined from \"../Core/defined.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport RectangleCollisionChecker from \"../Core/RectangleCollisionChecker.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport GroundPrimitive from \"../Scene/GroundPrimitive.js\";\nimport ShadowVolumeAppearance from \"../Scene/ShadowVolumeAppearance.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport MaterialProperty from \"./MaterialProperty.js\";\nimport Property from \"./Property.js\";\n\nvar distanceDisplayConditionScratch = new DistanceDisplayCondition();\nvar defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n\n// Encapsulates a Primitive and all the entities that it represents.\nfunction Batch(\n  primitives,\n  classificationType,\n  appearanceType,\n  materialProperty,\n  usingSphericalTextureCoordinates,\n  zIndex\n) {\n  this.primitives = primitives; // scene level primitive collection\n  this.classificationType = classificationType;\n  this.appearanceType = appearanceType;\n  this.materialProperty = materialProperty;\n  this.updaters = new AssociativeArray();\n  this.createPrimitive = true;\n  this.primitive = undefined; // a GroundPrimitive encapsulating all the entities\n  this.oldPrimitive = undefined;\n  this.geometry = new AssociativeArray();\n  this.material = undefined;\n  this.updatersWithAttributes = new AssociativeArray();\n  this.attributes = new AssociativeArray();\n  this.invalidated = false;\n  this.removeMaterialSubscription = materialProperty.definitionChanged.addEventListener(\n    Batch.prototype.onMaterialChanged,\n    this\n  );\n  this.subscriptions = new AssociativeArray();\n  this.showsUpdated = new AssociativeArray();\n  this.usingSphericalTextureCoordinates = usingSphericalTextureCoordinates;\n  this.zIndex = zIndex;\n  this.rectangleCollisionCheck = new RectangleCollisionChecker();\n}\n\nBatch.prototype.onMaterialChanged = function () {\n  this.invalidated = true;\n};\n\nBatch.prototype.overlapping = function (rectangle) {\n  return this.rectangleCollisionCheck.collides(rectangle);\n};\n\n// Check if the given updater's material is compatible with this batch\nBatch.prototype.isMaterial = function (updater) {\n  var material = this.materialProperty;\n  var updaterMaterial = updater.fillMaterialProperty;\n\n  if (\n    updaterMaterial === material ||\n    (updaterMaterial instanceof ColorMaterialProperty &&\n      material instanceof ColorMaterialProperty)\n  ) {\n    return true;\n  }\n  return defined(material) && material.equals(updaterMaterial);\n};\n\nBatch.prototype.add = function (time, updater, geometryInstance) {\n  var id = updater.id;\n  this.updaters.set(id, updater);\n  this.geometry.set(id, geometryInstance);\n  this.rectangleCollisionCheck.insert(id, geometryInstance.geometry.rectangle);\n  // Updaters with dynamic attributes must be tracked separately, may exit the batch\n  if (\n    !updater.hasConstantFill ||\n    !updater.fillMaterialProperty.isConstant ||\n    !Property.isConstant(updater.distanceDisplayConditionProperty)\n  ) {\n    this.updatersWithAttributes.set(id, updater);\n  } else {\n    var that = this;\n    // Listen for show changes. These will be synchronized in updateShows.\n    this.subscriptions.set(\n      id,\n      updater.entity.definitionChanged.addEventListener(function (\n        entity,\n        propertyName,\n        newValue,\n        oldValue\n      ) {\n        if (propertyName === \"isShowing\") {\n          that.showsUpdated.set(updater.id, updater);\n        }\n      })\n    );\n  }\n  this.createPrimitive = true;\n};\n\nBatch.prototype.remove = function (updater) {\n  var id = updater.id;\n  var geometryInstance = this.geometry.get(id);\n  this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n  if (this.updaters.remove(id)) {\n    this.rectangleCollisionCheck.remove(\n      id,\n      geometryInstance.geometry.rectangle\n    );\n    this.updatersWithAttributes.remove(id);\n    var unsubscribe = this.subscriptions.get(id);\n    if (defined(unsubscribe)) {\n      unsubscribe();\n      this.subscriptions.remove(id);\n    }\n    return true;\n  }\n  return false;\n};\n\nBatch.prototype.update = function (time) {\n  var isUpdated = true;\n  var primitive = this.primitive;\n  var primitives = this.primitives;\n  var geometries = this.geometry.values;\n  var i;\n\n  if (this.createPrimitive) {\n    var geometriesLength = geometries.length;\n    if (geometriesLength > 0) {\n      if (defined(primitive)) {\n        // Keep a handle to the old primitive so it can be removed when the updated version is ready.\n        if (!defined(this.oldPrimitive)) {\n          this.oldPrimitive = primitive;\n        } else {\n          // For if the new primitive changes again before it is ready.\n          primitives.remove(primitive);\n        }\n      }\n\n      this.material = MaterialProperty.getValue(\n        time,\n        this.materialProperty,\n        this.material\n      );\n\n      primitive = new GroundPrimitive({\n        show: false,\n        asynchronous: true,\n        geometryInstances: geometries.slice(),\n        appearance: new this.appearanceType({\n          material: this.material,\n          // translucent and closed properties overridden\n        }),\n        classificationType: this.classificationType,\n      });\n\n      primitives.add(primitive, this.zIndex);\n      isUpdated = false;\n    } else {\n      if (defined(primitive)) {\n        primitives.remove(primitive);\n        primitive = undefined;\n      }\n      var oldPrimitive = this.oldPrimitive;\n      if (defined(oldPrimitive)) {\n        primitives.remove(oldPrimitive);\n        this.oldPrimitive = undefined;\n      }\n    }\n\n    this.attributes.removeAll();\n    this.primitive = primitive;\n    this.createPrimitive = false;\n  } else if (defined(primitive) && primitive.ready) {\n    primitive.show = true;\n    if (defined(this.oldPrimitive)) {\n      primitives.remove(this.oldPrimitive);\n      this.oldPrimitive = undefined;\n    }\n\n    this.material = MaterialProperty.getValue(\n      time,\n      this.materialProperty,\n      this.material\n    );\n    this.primitive.appearance.material = this.material;\n\n    var updatersWithAttributes = this.updatersWithAttributes.values;\n    var length = updatersWithAttributes.length;\n    for (i = 0; i < length; i++) {\n      var updater = updatersWithAttributes[i];\n      var entity = updater.entity;\n      var instance = this.geometry.get(updater.id);\n\n      var attributes = this.attributes.get(instance.id.id);\n      if (!defined(attributes)) {\n        attributes = primitive.getGeometryInstanceAttributes(instance.id);\n        this.attributes.set(instance.id.id, attributes);\n      }\n\n      var show =\n        entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n      var currentShow = attributes.show[0] === 1;\n      if (show !== currentShow) {\n        attributes.show = ShowGeometryInstanceAttribute.toValue(\n          show,\n          attributes.show\n        );\n      }\n\n      var distanceDisplayConditionProperty =\n        updater.distanceDisplayConditionProperty;\n      if (!Property.isConstant(distanceDisplayConditionProperty)) {\n        var distanceDisplayCondition = Property.getValueOrDefault(\n          distanceDisplayConditionProperty,\n          time,\n          defaultDistanceDisplayCondition,\n          distanceDisplayConditionScratch\n        );\n        if (\n          !DistanceDisplayCondition.equals(\n            distanceDisplayCondition,\n            attributes._lastDistanceDisplayCondition\n          )\n        ) {\n          attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(\n            distanceDisplayCondition,\n            attributes._lastDistanceDisplayCondition\n          );\n          attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(\n            distanceDisplayCondition,\n            attributes.distanceDisplayCondition\n          );\n        }\n      }\n    }\n\n    this.updateShows(primitive);\n  } else if (defined(primitive) && !primitive.ready) {\n    isUpdated = false;\n  }\n  return isUpdated;\n};\n\nBatch.prototype.updateShows = function (primitive) {\n  var showsUpdated = this.showsUpdated.values;\n  var length = showsUpdated.length;\n  for (var i = 0; i < length; i++) {\n    var updater = showsUpdated[i];\n    var entity = updater.entity;\n    var instance = this.geometry.get(updater.id);\n\n    var attributes = this.attributes.get(instance.id.id);\n    if (!defined(attributes)) {\n      attributes = primitive.getGeometryInstanceAttributes(instance.id);\n      this.attributes.set(instance.id.id, attributes);\n    }\n\n    var show = entity.isShowing;\n    var currentShow = attributes.show[0] === 1;\n    if (show !== currentShow) {\n      attributes.show = ShowGeometryInstanceAttribute.toValue(\n        show,\n        attributes.show\n      );\n      instance.attributes.show.value[0] = attributes.show[0];\n    }\n  }\n  this.showsUpdated.removeAll();\n};\n\nBatch.prototype.contains = function (updater) {\n  return this.updaters.contains(updater.id);\n};\n\nBatch.prototype.getBoundingSphere = function (updater, result) {\n  var primitive = this.primitive;\n  if (!primitive.ready) {\n    return BoundingSphereState.PENDING;\n  }\n  var attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n  if (\n    !defined(attributes) ||\n    !defined(attributes.boundingSphere) ||\n    (defined(attributes.show) && attributes.show[0] === 0)\n  ) {\n    return BoundingSphereState.FAILED;\n  }\n  attributes.boundingSphere.clone(result);\n  return BoundingSphereState.DONE;\n};\n\nBatch.prototype.destroy = function () {\n  var primitive = this.primitive;\n  var primitives = this.primitives;\n  if (defined(primitive)) {\n    primitives.remove(primitive);\n  }\n  var oldPrimitive = this.oldPrimitive;\n  if (defined(oldPrimitive)) {\n    primitives.remove(oldPrimitive);\n  }\n  this.removeMaterialSubscription();\n};\n\n/**\n * @private\n */\nfunction StaticGroundGeometryPerMaterialBatch(\n  primitives,\n  classificationType,\n  appearanceType\n) {\n  this._items = [];\n  this._primitives = primitives;\n  this._classificationType = classificationType;\n  this._appearanceType = appearanceType;\n}\n\nStaticGroundGeometryPerMaterialBatch.prototype.add = function (time, updater) {\n  var items = this._items;\n  var length = items.length;\n  var geometryInstance = updater.createFillGeometryInstance(time);\n  var usingSphericalTextureCoordinates = ShadowVolumeAppearance.shouldUseSphericalCoordinates(\n    geometryInstance.geometry.rectangle\n  );\n  var zIndex = Property.getValueOrDefault(updater.zIndex, 0);\n  // Check if the Entity represented by the updater can be placed in an existing batch. Requirements:\n  // * compatible material (same material or same color)\n  // * same type of texture coordinates (spherical vs. planar)\n  // * conservatively non-overlapping with any entities in the existing batch\n  for (var i = 0; i < length; ++i) {\n    var item = items[i];\n    if (\n      item.isMaterial(updater) &&\n      item.usingSphericalTextureCoordinates ===\n        usingSphericalTextureCoordinates &&\n      item.zIndex === zIndex &&\n      !item.overlapping(geometryInstance.geometry.rectangle)\n    ) {\n      item.add(time, updater, geometryInstance);\n      return;\n    }\n  }\n  // If a compatible batch wasn't found, create a new batch.\n  var batch = new Batch(\n    this._primitives,\n    this._classificationType,\n    this._appearanceType,\n    updater.fillMaterialProperty,\n    usingSphericalTextureCoordinates,\n    zIndex\n  );\n  batch.add(time, updater, geometryInstance);\n  items.push(batch);\n};\n\nStaticGroundGeometryPerMaterialBatch.prototype.remove = function (updater) {\n  var items = this._items;\n  var length = items.length;\n  for (var i = length - 1; i >= 0; i--) {\n    var item = items[i];\n    if (item.remove(updater)) {\n      if (item.updaters.length === 0) {\n        items.splice(i, 1);\n        item.destroy();\n      }\n      break;\n    }\n  }\n};\n\nStaticGroundGeometryPerMaterialBatch.prototype.update = function (time) {\n  var i;\n  var items = this._items;\n  var length = items.length;\n\n  for (i = length - 1; i >= 0; i--) {\n    var item = items[i];\n    if (item.invalidated) {\n      items.splice(i, 1);\n      var updaters = item.updaters.values;\n      var updatersLength = updaters.length;\n      for (var h = 0; h < updatersLength; h++) {\n        this.add(time, updaters[h]);\n      }\n      item.destroy();\n    }\n  }\n\n  var isUpdated = true;\n  for (i = 0; i < items.length; i++) {\n    isUpdated = items[i].update(time) && isUpdated;\n  }\n  return isUpdated;\n};\n\nStaticGroundGeometryPerMaterialBatch.prototype.getBoundingSphere = function (\n  updater,\n  result\n) {\n  var items = this._items;\n  var length = items.length;\n  for (var i = 0; i < length; i++) {\n    var item = items[i];\n    if (item.contains(updater)) {\n      return item.getBoundingSphere(updater, result);\n    }\n  }\n  return BoundingSphereState.FAILED;\n};\n\nStaticGroundGeometryPerMaterialBatch.prototype.removeAllPrimitives = function () {\n  var items = this._items;\n  var length = items.length;\n  for (var i = 0; i < length; i++) {\n    items[i].destroy();\n  }\n  this._items.length = 0;\n};\nexport default StaticGroundGeometryPerMaterialBatch;\n"]},"metadata":{},"sourceType":"module"}