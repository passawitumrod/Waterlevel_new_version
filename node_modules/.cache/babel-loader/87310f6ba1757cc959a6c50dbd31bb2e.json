{"ast":null,"code":"import defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nvar factorial = CesiumMath.factorial;\n\nfunction calculateCoefficientTerm(x, zIndices, xTable, derivOrder, termOrder, reservedIndices) {\n  var result = 0;\n  var reserved;\n  var i;\n  var j;\n\n  if (derivOrder > 0) {\n    for (i = 0; i < termOrder; i++) {\n      reserved = false;\n\n      for (j = 0; j < reservedIndices.length && !reserved; j++) {\n        if (i === reservedIndices[j]) {\n          reserved = true;\n        }\n      }\n\n      if (!reserved) {\n        reservedIndices.push(i);\n        result += calculateCoefficientTerm(x, zIndices, xTable, derivOrder - 1, termOrder, reservedIndices);\n        reservedIndices.splice(reservedIndices.length - 1, 1);\n      }\n    }\n\n    return result;\n  }\n\n  result = 1;\n\n  for (i = 0; i < termOrder; i++) {\n    reserved = false;\n\n    for (j = 0; j < reservedIndices.length && !reserved; j++) {\n      if (i === reservedIndices[j]) {\n        reserved = true;\n      }\n    }\n\n    if (!reserved) {\n      result *= x - xTable[zIndices[i]];\n    }\n  }\n\n  return result;\n}\n/**\n * An {@link InterpolationAlgorithm} for performing Hermite interpolation.\n *\n * @exports HermitePolynomialApproximation\n */\n\n\nvar HermitePolynomialApproximation = {\n  type: \"Hermite\"\n};\n/**\n * Given the desired degree, returns the number of data points required for interpolation.\n *\n * @param {Number} degree The desired degree of interpolation.\n * @param {Number} [inputOrder=0]  The order of the inputs (0 means just the data, 1 means the data and its derivative, etc).\n * @returns {Number} The number of required data points needed for the desired degree of interpolation.\n * @exception {DeveloperError} degree must be 0 or greater.\n * @exception {DeveloperError} inputOrder must be 0 or greater.\n */\n\nHermitePolynomialApproximation.getRequiredDataPoints = function (degree, inputOrder) {\n  inputOrder = defaultValue(inputOrder, 0); //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(degree)) {\n    throw new DeveloperError(\"degree is required.\");\n  }\n\n  if (degree < 0) {\n    throw new DeveloperError(\"degree must be 0 or greater.\");\n  }\n\n  if (inputOrder < 0) {\n    throw new DeveloperError(\"inputOrder must be 0 or greater.\");\n  } //>>includeEnd('debug');\n\n\n  return Math.max(Math.floor((degree + 1) / (inputOrder + 1)), 2);\n};\n/**\n * Interpolates values using Hermite Polynomial Approximation.\n *\n * @param {Number} x The independent variable for which the dependent variables will be interpolated.\n * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values\n * in this array must be in increasing order and the same value must not occur twice in the array.\n * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three\n * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.\n * @param {Number} yStride The number of dependent variable values in yTable corresponding to\n * each independent variable value in xTable.\n * @param {Number[]} [result] An existing array into which to store the result.\n * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.\n */\n\n\nHermitePolynomialApproximation.interpolateOrderZero = function (x, xTable, yTable, yStride, result) {\n  if (!defined(result)) {\n    result = new Array(yStride);\n  }\n\n  var i;\n  var j;\n  var d;\n  var s;\n  var len;\n  var index;\n  var length = xTable.length;\n  var coefficients = new Array(yStride);\n\n  for (i = 0; i < yStride; i++) {\n    result[i] = 0;\n    var l = new Array(length);\n    coefficients[i] = l;\n\n    for (j = 0; j < length; j++) {\n      l[j] = [];\n    }\n  }\n\n  var zIndicesLength = length,\n      zIndices = new Array(zIndicesLength);\n\n  for (i = 0; i < zIndicesLength; i++) {\n    zIndices[i] = i;\n  }\n\n  var highestNonZeroCoef = length - 1;\n\n  for (s = 0; s < yStride; s++) {\n    for (j = 0; j < zIndicesLength; j++) {\n      index = zIndices[j] * yStride + s;\n      coefficients[s][0].push(yTable[index]);\n    }\n\n    for (i = 1; i < zIndicesLength; i++) {\n      var nonZeroCoefficients = false;\n\n      for (j = 0; j < zIndicesLength - i; j++) {\n        var zj = xTable[zIndices[j]];\n        var zn = xTable[zIndices[j + i]];\n        var numerator;\n\n        if (zn - zj <= 0) {\n          index = zIndices[j] * yStride + yStride * i + s;\n          numerator = yTable[index];\n          coefficients[s][i].push(numerator / factorial(i));\n        } else {\n          numerator = coefficients[s][i - 1][j + 1] - coefficients[s][i - 1][j];\n          coefficients[s][i].push(numerator / (zn - zj));\n        }\n\n        nonZeroCoefficients = nonZeroCoefficients || numerator !== 0;\n      }\n\n      if (!nonZeroCoefficients) {\n        highestNonZeroCoef = i - 1;\n      }\n    }\n  }\n\n  for (d = 0, len = 0; d <= len; d++) {\n    for (i = d; i <= highestNonZeroCoef; i++) {\n      var tempTerm = calculateCoefficientTerm(x, zIndices, xTable, d, i, []);\n\n      for (s = 0; s < yStride; s++) {\n        var coeff = coefficients[s][i][0];\n        result[s + d * yStride] += coeff * tempTerm;\n      }\n    }\n  }\n\n  return result;\n};\n\nvar arrayScratch = [];\n/**\n * Interpolates values using Hermite Polynomial Approximation.\n *\n * @param {Number} x The independent variable for which the dependent variables will be interpolated.\n * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values\n * in this array must be in increasing order and the same value must not occur twice in the array.\n * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three\n * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.\n * @param {Number} yStride The number of dependent variable values in yTable corresponding to\n * each independent variable value in xTable.\n * @param {Number} inputOrder The number of derivatives supplied for input.\n * @param {Number} outputOrder The number of derivatives desired for output.\n * @param {Number[]} [result] An existing array into which to store the result.\n *\n * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.\n */\n\nHermitePolynomialApproximation.interpolate = function (x, xTable, yTable, yStride, inputOrder, outputOrder, result) {\n  var resultLength = yStride * (outputOrder + 1);\n\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  }\n\n  for (var r = 0; r < resultLength; r++) {\n    result[r] = 0;\n  }\n\n  var length = xTable.length; // The zIndices array holds copies of the addresses of the xTable values\n  // in the range we're looking at. Even though this just holds information already\n  // available in xTable this is a much more convenient format.\n\n  var zIndices = new Array(length * (inputOrder + 1));\n  var i;\n\n  for (i = 0; i < length; i++) {\n    for (var j = 0; j < inputOrder + 1; j++) {\n      zIndices[i * (inputOrder + 1) + j] = i;\n    }\n  }\n\n  var zIndiceslength = zIndices.length;\n  var coefficients = arrayScratch;\n  var highestNonZeroCoef = fillCoefficientList(coefficients, zIndices, xTable, yTable, yStride, inputOrder);\n  var reservedIndices = [];\n  var tmp = zIndiceslength * (zIndiceslength + 1) / 2;\n  var loopStop = Math.min(highestNonZeroCoef, outputOrder);\n\n  for (var d = 0; d <= loopStop; d++) {\n    for (i = d; i <= highestNonZeroCoef; i++) {\n      reservedIndices.length = 0;\n      var tempTerm = calculateCoefficientTerm(x, zIndices, xTable, d, i, reservedIndices);\n      var dimTwo = Math.floor(i * (1 - i) / 2) + zIndiceslength * i;\n\n      for (var s = 0; s < yStride; s++) {\n        var dimOne = Math.floor(s * tmp);\n        var coef = coefficients[dimOne + dimTwo];\n        result[s + d * yStride] += coef * tempTerm;\n      }\n    }\n  }\n\n  return result;\n};\n\nfunction fillCoefficientList(coefficients, zIndices, xTable, yTable, yStride, inputOrder) {\n  var j;\n  var index;\n  var highestNonZero = -1;\n  var zIndiceslength = zIndices.length;\n  var tmp = zIndiceslength * (zIndiceslength + 1) / 2;\n\n  for (var s = 0; s < yStride; s++) {\n    var dimOne = Math.floor(s * tmp);\n\n    for (j = 0; j < zIndiceslength; j++) {\n      index = zIndices[j] * yStride * (inputOrder + 1) + s;\n      coefficients[dimOne + j] = yTable[index];\n    }\n\n    for (var i = 1; i < zIndiceslength; i++) {\n      var coefIndex = 0;\n      var dimTwo = Math.floor(i * (1 - i) / 2) + zIndiceslength * i;\n      var nonZeroCoefficients = false;\n\n      for (j = 0; j < zIndiceslength - i; j++) {\n        var zj = xTable[zIndices[j]];\n        var zn = xTable[zIndices[j + i]];\n        var numerator;\n        var coefficient;\n\n        if (zn - zj <= 0) {\n          index = zIndices[j] * yStride * (inputOrder + 1) + yStride * i + s;\n          numerator = yTable[index];\n          coefficient = numerator / CesiumMath.factorial(i);\n          coefficients[dimOne + dimTwo + coefIndex] = coefficient;\n          coefIndex++;\n        } else {\n          var dimTwoMinusOne = Math.floor((i - 1) * (2 - i) / 2) + zIndiceslength * (i - 1);\n          numerator = coefficients[dimOne + dimTwoMinusOne + j + 1] - coefficients[dimOne + dimTwoMinusOne + j];\n          coefficient = numerator / (zn - zj);\n          coefficients[dimOne + dimTwo + coefIndex] = coefficient;\n          coefIndex++;\n        }\n\n        nonZeroCoefficients = nonZeroCoefficients || numerator !== 0.0;\n      }\n\n      if (nonZeroCoefficients) {\n        highestNonZero = Math.max(highestNonZero, i);\n      }\n    }\n  }\n\n  return highestNonZero;\n}\n\nexport default HermitePolynomialApproximation;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/HermitePolynomialApproximation.js"],"names":["defaultValue","defined","DeveloperError","CesiumMath","factorial","calculateCoefficientTerm","x","zIndices","xTable","derivOrder","termOrder","reservedIndices","result","reserved","i","j","length","push","splice","HermitePolynomialApproximation","type","getRequiredDataPoints","degree","inputOrder","Math","max","floor","interpolateOrderZero","yTable","yStride","Array","d","s","len","index","coefficients","l","zIndicesLength","highestNonZeroCoef","nonZeroCoefficients","zj","zn","numerator","tempTerm","coeff","arrayScratch","interpolate","outputOrder","resultLength","r","zIndiceslength","fillCoefficientList","tmp","loopStop","min","dimTwo","dimOne","coef","highestNonZero","coefIndex","coefficient","dimTwoMinusOne"],"mappings":"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","sourcesContent":["import defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\nvar factorial = CesiumMath.factorial;\n\nfunction calculateCoefficientTerm(\n  x,\n  zIndices,\n  xTable,\n  derivOrder,\n  termOrder,\n  reservedIndices\n) {\n  var result = 0;\n  var reserved;\n  var i;\n  var j;\n\n  if (derivOrder > 0) {\n    for (i = 0; i < termOrder; i++) {\n      reserved = false;\n      for (j = 0; j < reservedIndices.length && !reserved; j++) {\n        if (i === reservedIndices[j]) {\n          reserved = true;\n        }\n      }\n\n      if (!reserved) {\n        reservedIndices.push(i);\n        result += calculateCoefficientTerm(\n          x,\n          zIndices,\n          xTable,\n          derivOrder - 1,\n          termOrder,\n          reservedIndices\n        );\n        reservedIndices.splice(reservedIndices.length - 1, 1);\n      }\n    }\n\n    return result;\n  }\n\n  result = 1;\n  for (i = 0; i < termOrder; i++) {\n    reserved = false;\n    for (j = 0; j < reservedIndices.length && !reserved; j++) {\n      if (i === reservedIndices[j]) {\n        reserved = true;\n      }\n    }\n\n    if (!reserved) {\n      result *= x - xTable[zIndices[i]];\n    }\n  }\n\n  return result;\n}\n\n/**\n * An {@link InterpolationAlgorithm} for performing Hermite interpolation.\n *\n * @exports HermitePolynomialApproximation\n */\nvar HermitePolynomialApproximation = {\n  type: \"Hermite\",\n};\n\n/**\n * Given the desired degree, returns the number of data points required for interpolation.\n *\n * @param {Number} degree The desired degree of interpolation.\n * @param {Number} [inputOrder=0]  The order of the inputs (0 means just the data, 1 means the data and its derivative, etc).\n * @returns {Number} The number of required data points needed for the desired degree of interpolation.\n * @exception {DeveloperError} degree must be 0 or greater.\n * @exception {DeveloperError} inputOrder must be 0 or greater.\n */\nHermitePolynomialApproximation.getRequiredDataPoints = function (\n  degree,\n  inputOrder\n) {\n  inputOrder = defaultValue(inputOrder, 0);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(degree)) {\n    throw new DeveloperError(\"degree is required.\");\n  }\n  if (degree < 0) {\n    throw new DeveloperError(\"degree must be 0 or greater.\");\n  }\n  if (inputOrder < 0) {\n    throw new DeveloperError(\"inputOrder must be 0 or greater.\");\n  }\n  //>>includeEnd('debug');\n\n  return Math.max(Math.floor((degree + 1) / (inputOrder + 1)), 2);\n};\n\n/**\n * Interpolates values using Hermite Polynomial Approximation.\n *\n * @param {Number} x The independent variable for which the dependent variables will be interpolated.\n * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values\n * in this array must be in increasing order and the same value must not occur twice in the array.\n * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three\n * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.\n * @param {Number} yStride The number of dependent variable values in yTable corresponding to\n * each independent variable value in xTable.\n * @param {Number[]} [result] An existing array into which to store the result.\n * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.\n */\nHermitePolynomialApproximation.interpolateOrderZero = function (\n  x,\n  xTable,\n  yTable,\n  yStride,\n  result\n) {\n  if (!defined(result)) {\n    result = new Array(yStride);\n  }\n\n  var i;\n  var j;\n  var d;\n  var s;\n  var len;\n  var index;\n  var length = xTable.length;\n  var coefficients = new Array(yStride);\n\n  for (i = 0; i < yStride; i++) {\n    result[i] = 0;\n\n    var l = new Array(length);\n    coefficients[i] = l;\n    for (j = 0; j < length; j++) {\n      l[j] = [];\n    }\n  }\n\n  var zIndicesLength = length,\n    zIndices = new Array(zIndicesLength);\n\n  for (i = 0; i < zIndicesLength; i++) {\n    zIndices[i] = i;\n  }\n\n  var highestNonZeroCoef = length - 1;\n  for (s = 0; s < yStride; s++) {\n    for (j = 0; j < zIndicesLength; j++) {\n      index = zIndices[j] * yStride + s;\n      coefficients[s][0].push(yTable[index]);\n    }\n\n    for (i = 1; i < zIndicesLength; i++) {\n      var nonZeroCoefficients = false;\n      for (j = 0; j < zIndicesLength - i; j++) {\n        var zj = xTable[zIndices[j]];\n        var zn = xTable[zIndices[j + i]];\n\n        var numerator;\n        if (zn - zj <= 0) {\n          index = zIndices[j] * yStride + yStride * i + s;\n          numerator = yTable[index];\n          coefficients[s][i].push(numerator / factorial(i));\n        } else {\n          numerator = coefficients[s][i - 1][j + 1] - coefficients[s][i - 1][j];\n          coefficients[s][i].push(numerator / (zn - zj));\n        }\n        nonZeroCoefficients = nonZeroCoefficients || numerator !== 0;\n      }\n\n      if (!nonZeroCoefficients) {\n        highestNonZeroCoef = i - 1;\n      }\n    }\n  }\n\n  for (d = 0, len = 0; d <= len; d++) {\n    for (i = d; i <= highestNonZeroCoef; i++) {\n      var tempTerm = calculateCoefficientTerm(x, zIndices, xTable, d, i, []);\n      for (s = 0; s < yStride; s++) {\n        var coeff = coefficients[s][i][0];\n        result[s + d * yStride] += coeff * tempTerm;\n      }\n    }\n  }\n\n  return result;\n};\n\nvar arrayScratch = [];\n\n/**\n * Interpolates values using Hermite Polynomial Approximation.\n *\n * @param {Number} x The independent variable for which the dependent variables will be interpolated.\n * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values\n * in this array must be in increasing order and the same value must not occur twice in the array.\n * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three\n * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.\n * @param {Number} yStride The number of dependent variable values in yTable corresponding to\n * each independent variable value in xTable.\n * @param {Number} inputOrder The number of derivatives supplied for input.\n * @param {Number} outputOrder The number of derivatives desired for output.\n * @param {Number[]} [result] An existing array into which to store the result.\n *\n * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.\n */\nHermitePolynomialApproximation.interpolate = function (\n  x,\n  xTable,\n  yTable,\n  yStride,\n  inputOrder,\n  outputOrder,\n  result\n) {\n  var resultLength = yStride * (outputOrder + 1);\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  }\n  for (var r = 0; r < resultLength; r++) {\n    result[r] = 0;\n  }\n\n  var length = xTable.length;\n  // The zIndices array holds copies of the addresses of the xTable values\n  // in the range we're looking at. Even though this just holds information already\n  // available in xTable this is a much more convenient format.\n  var zIndices = new Array(length * (inputOrder + 1));\n  var i;\n  for (i = 0; i < length; i++) {\n    for (var j = 0; j < inputOrder + 1; j++) {\n      zIndices[i * (inputOrder + 1) + j] = i;\n    }\n  }\n\n  var zIndiceslength = zIndices.length;\n  var coefficients = arrayScratch;\n  var highestNonZeroCoef = fillCoefficientList(\n    coefficients,\n    zIndices,\n    xTable,\n    yTable,\n    yStride,\n    inputOrder\n  );\n  var reservedIndices = [];\n\n  var tmp = (zIndiceslength * (zIndiceslength + 1)) / 2;\n  var loopStop = Math.min(highestNonZeroCoef, outputOrder);\n  for (var d = 0; d <= loopStop; d++) {\n    for (i = d; i <= highestNonZeroCoef; i++) {\n      reservedIndices.length = 0;\n      var tempTerm = calculateCoefficientTerm(\n        x,\n        zIndices,\n        xTable,\n        d,\n        i,\n        reservedIndices\n      );\n      var dimTwo = Math.floor((i * (1 - i)) / 2) + zIndiceslength * i;\n\n      for (var s = 0; s < yStride; s++) {\n        var dimOne = Math.floor(s * tmp);\n        var coef = coefficients[dimOne + dimTwo];\n        result[s + d * yStride] += coef * tempTerm;\n      }\n    }\n  }\n\n  return result;\n};\n\nfunction fillCoefficientList(\n  coefficients,\n  zIndices,\n  xTable,\n  yTable,\n  yStride,\n  inputOrder\n) {\n  var j;\n  var index;\n  var highestNonZero = -1;\n  var zIndiceslength = zIndices.length;\n  var tmp = (zIndiceslength * (zIndiceslength + 1)) / 2;\n\n  for (var s = 0; s < yStride; s++) {\n    var dimOne = Math.floor(s * tmp);\n\n    for (j = 0; j < zIndiceslength; j++) {\n      index = zIndices[j] * yStride * (inputOrder + 1) + s;\n      coefficients[dimOne + j] = yTable[index];\n    }\n\n    for (var i = 1; i < zIndiceslength; i++) {\n      var coefIndex = 0;\n      var dimTwo = Math.floor((i * (1 - i)) / 2) + zIndiceslength * i;\n      var nonZeroCoefficients = false;\n\n      for (j = 0; j < zIndiceslength - i; j++) {\n        var zj = xTable[zIndices[j]];\n        var zn = xTable[zIndices[j + i]];\n\n        var numerator;\n        var coefficient;\n        if (zn - zj <= 0) {\n          index = zIndices[j] * yStride * (inputOrder + 1) + yStride * i + s;\n          numerator = yTable[index];\n          coefficient = numerator / CesiumMath.factorial(i);\n          coefficients[dimOne + dimTwo + coefIndex] = coefficient;\n          coefIndex++;\n        } else {\n          var dimTwoMinusOne =\n            Math.floor(((i - 1) * (2 - i)) / 2) + zIndiceslength * (i - 1);\n          numerator =\n            coefficients[dimOne + dimTwoMinusOne + j + 1] -\n            coefficients[dimOne + dimTwoMinusOne + j];\n          coefficient = numerator / (zn - zj);\n          coefficients[dimOne + dimTwo + coefIndex] = coefficient;\n          coefIndex++;\n        }\n        nonZeroCoefficients = nonZeroCoefficients || numerator !== 0.0;\n      }\n\n      if (nonZeroCoefficients) {\n        highestNonZero = Math.max(highestNonZero, i);\n      }\n    }\n  }\n\n  return highestNonZero;\n}\nexport default HermitePolynomialApproximation;\n"]},"metadata":{},"sourceType":"module"}