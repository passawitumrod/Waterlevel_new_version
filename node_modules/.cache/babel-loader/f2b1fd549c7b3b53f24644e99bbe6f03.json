{"ast":null,"code":"import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport RectangleGeometry from \"../Core/RectangleGeometry.js\";\nimport RectangleOutlineGeometry from \"../Core/RectangleOutlineGeometry.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport DynamicGeometryUpdater from \"./DynamicGeometryUpdater.js\";\nimport GeometryUpdater from \"./GeometryUpdater.js\";\nimport GroundGeometryUpdater from \"./GroundGeometryUpdater.js\";\nimport Property from \"./Property.js\";\nvar scratchColor = new Color();\nvar defaultOffset = Cartesian3.ZERO;\nvar offsetScratch = new Cartesian3();\nvar scratchRectangle = new Rectangle();\nvar scratchCenterRect = new Rectangle();\nvar scratchCarto = new Cartographic();\n\nfunction RectangleGeometryOptions(entity) {\n  this.id = entity;\n  this.vertexFormat = undefined;\n  this.rectangle = undefined;\n  this.height = undefined;\n  this.extrudedHeight = undefined;\n  this.granularity = undefined;\n  this.stRotation = undefined;\n  this.rotation = undefined;\n  this.offsetAttribute = undefined;\n}\n/**\n * A {@link GeometryUpdater} for rectangles.\n * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n * @alias RectangleGeometryUpdater\n * @constructor\n *\n * @param {Entity} entity The entity containing the geometry to be visualized.\n * @param {Scene} scene The scene where visualization is taking place.\n */\n\n\nfunction RectangleGeometryUpdater(entity, scene) {\n  GroundGeometryUpdater.call(this, {\n    entity: entity,\n    scene: scene,\n    geometryOptions: new RectangleGeometryOptions(entity),\n    geometryPropertyName: \"rectangle\",\n    observedPropertyNames: [\"availability\", \"rectangle\"]\n  });\n\n  this._onEntityPropertyChanged(entity, \"rectangle\", entity.rectangle, undefined);\n}\n\nif (defined(Object.create)) {\n  RectangleGeometryUpdater.prototype = Object.create(GroundGeometryUpdater.prototype);\n  RectangleGeometryUpdater.prototype.constructor = RectangleGeometryUpdater;\n}\n/**\n * Creates the geometry instance which represents the fill of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent a filled geometry.\n */\n\n\nRectangleGeometryUpdater.prototype.createFillGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n\n  if (!this._fillEnabled) {\n    throw new DeveloperError(\"This instance does not represent a filled geometry.\");\n  } //>>includeEnd('debug');\n\n\n  var entity = this._entity;\n  var isAvailable = entity.isAvailable(time);\n  var attributes = {\n    show: new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time)),\n    distanceDisplayCondition: DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),\n    offset: undefined,\n    color: undefined\n  };\n\n  if (this._materialProperty instanceof ColorMaterialProperty) {\n    var currentColor;\n\n    if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n      currentColor = this._materialProperty.color.getValue(time, scratchColor);\n    }\n\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n\n    attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n  }\n\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new RectangleGeometry(this._options),\n    attributes: attributes\n  });\n};\n/**\n * Creates the geometry instance which represents the outline of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent an outlined geometry.\n */\n\n\nRectangleGeometryUpdater.prototype.createOutlineGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n\n  if (!this._outlineEnabled) {\n    throw new DeveloperError(\"This instance does not represent an outlined geometry.\");\n  } //>>includeEnd('debug');\n\n\n  var entity = this._entity;\n  var isAvailable = entity.isAvailable(time);\n  var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n\n  var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n  var attributes = {\n    show: new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n    color: ColorGeometryInstanceAttribute.fromColor(outlineColor),\n    distanceDisplayCondition: DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n    offset: undefined\n  };\n\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new RectangleOutlineGeometry(this._options),\n    attributes: attributes\n  });\n};\n\nRectangleGeometryUpdater.prototype._computeCenter = function (time, result) {\n  var rect = Property.getValueOrUndefined(this._entity.rectangle.coordinates, time, scratchCenterRect);\n\n  if (!defined(rect)) {\n    return;\n  }\n\n  var center = Rectangle.center(rect, scratchCarto);\n  return Cartographic.toCartesian(center, Ellipsoid.WGS84, result);\n};\n\nRectangleGeometryUpdater.prototype._isHidden = function (entity, rectangle) {\n  return !defined(rectangle.coordinates) || GeometryUpdater.prototype._isHidden.call(this, entity, rectangle);\n};\n\nRectangleGeometryUpdater.prototype._isDynamic = function (entity, rectangle) {\n  return !rectangle.coordinates.isConstant || //\n  !Property.isConstant(rectangle.height) || //\n  !Property.isConstant(rectangle.extrudedHeight) || //\n  !Property.isConstant(rectangle.granularity) || //\n  !Property.isConstant(rectangle.stRotation) || //\n  !Property.isConstant(rectangle.rotation) || //\n  !Property.isConstant(rectangle.outlineWidth) || //\n  !Property.isConstant(rectangle.zIndex) || //\n  this._onTerrain && !Property.isConstant(this._materialProperty) && !(this._materialProperty instanceof ColorMaterialProperty);\n};\n\nRectangleGeometryUpdater.prototype._setStaticOptions = function (entity, rectangle) {\n  var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;\n  var heightValue = Property.getValueOrUndefined(rectangle.height, Iso8601.MINIMUM_VALUE);\n  var heightReferenceValue = Property.getValueOrDefault(rectangle.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n  var extrudedHeightValue = Property.getValueOrUndefined(rectangle.extrudedHeight, Iso8601.MINIMUM_VALUE);\n  var extrudedHeightReferenceValue = Property.getValueOrDefault(rectangle.extrudedHeightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n\n  if (defined(extrudedHeightValue) && !defined(heightValue)) {\n    heightValue = 0;\n  }\n\n  var options = this._options;\n  options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n  options.rectangle = rectangle.coordinates.getValue(Iso8601.MINIMUM_VALUE, options.rectangle);\n  options.granularity = Property.getValueOrUndefined(rectangle.granularity, Iso8601.MINIMUM_VALUE);\n  options.stRotation = Property.getValueOrUndefined(rectangle.stRotation, Iso8601.MINIMUM_VALUE);\n  options.rotation = Property.getValueOrUndefined(rectangle.rotation, Iso8601.MINIMUM_VALUE);\n  options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n  options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n  extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n\n  if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n    extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(RectangleGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n  }\n\n  options.extrudedHeight = extrudedHeightValue;\n};\n\nRectangleGeometryUpdater.DynamicGeometryUpdater = DynamicRectangleGeometryUpdater;\n/**\n * @private\n */\n\nfunction DynamicRectangleGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n  DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n}\n\nif (defined(Object.create)) {\n  DynamicRectangleGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n  DynamicRectangleGeometryUpdater.prototype.constructor = DynamicRectangleGeometryUpdater;\n}\n\nDynamicRectangleGeometryUpdater.prototype._isHidden = function (entity, rectangle, time) {\n  return !defined(this._options.rectangle) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, rectangle, time);\n};\n\nDynamicRectangleGeometryUpdater.prototype._setOptions = function (entity, rectangle, time) {\n  var options = this._options;\n  var heightValue = Property.getValueOrUndefined(rectangle.height, time);\n  var heightReferenceValue = Property.getValueOrDefault(rectangle.heightReference, time, HeightReference.NONE);\n  var extrudedHeightValue = Property.getValueOrUndefined(rectangle.extrudedHeight, time);\n  var extrudedHeightReferenceValue = Property.getValueOrDefault(rectangle.extrudedHeightReference, time, HeightReference.NONE);\n\n  if (defined(extrudedHeightValue) && !defined(heightValue)) {\n    heightValue = 0;\n  }\n\n  options.rectangle = Property.getValueOrUndefined(rectangle.coordinates, time, options.rectangle);\n  options.granularity = Property.getValueOrUndefined(rectangle.granularity, time);\n  options.stRotation = Property.getValueOrUndefined(rectangle.stRotation, time);\n  options.rotation = Property.getValueOrUndefined(rectangle.rotation, time);\n  options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n  options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n  extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n\n  if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n    extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(RectangleGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n  }\n\n  options.extrudedHeight = extrudedHeightValue;\n};\n\nexport default RectangleGeometryUpdater;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/DataSources/RectangleGeometryUpdater.js"],"names":["ApproximateTerrainHeights","Cartesian3","Cartographic","Check","Color","ColorGeometryInstanceAttribute","defined","DeveloperError","DistanceDisplayConditionGeometryInstanceAttribute","Ellipsoid","GeometryInstance","Iso8601","OffsetGeometryInstanceAttribute","Rectangle","RectangleGeometry","RectangleOutlineGeometry","ShowGeometryInstanceAttribute","HeightReference","MaterialAppearance","PerInstanceColorAppearance","ColorMaterialProperty","DynamicGeometryUpdater","GeometryUpdater","GroundGeometryUpdater","Property","scratchColor","defaultOffset","ZERO","offsetScratch","scratchRectangle","scratchCenterRect","scratchCarto","RectangleGeometryOptions","entity","id","vertexFormat","undefined","rectangle","height","extrudedHeight","granularity","stRotation","rotation","offsetAttribute","RectangleGeometryUpdater","scene","call","geometryOptions","geometryPropertyName","observedPropertyNames","_onEntityPropertyChanged","Object","create","prototype","constructor","createFillGeometryInstance","time","_fillEnabled","_entity","isAvailable","attributes","show","isShowing","_showProperty","getValue","_fillProperty","distanceDisplayCondition","fromDistanceDisplayCondition","_distanceDisplayConditionProperty","offset","color","_materialProperty","currentColor","isConstant","WHITE","fromColor","_options","fromCartesian3","getValueOrDefault","_terrainOffsetProperty","geometry","createOutlineGeometryInstance","_outlineEnabled","outlineColor","_outlineColorProperty","BLACK","_showOutlineProperty","_computeCenter","result","rect","getValueOrUndefined","coordinates","center","toCartesian","WGS84","_isHidden","_isDynamic","outlineWidth","zIndex","_onTerrain","_setStaticOptions","isColorMaterial","heightValue","MINIMUM_VALUE","heightReferenceValue","heightReference","NONE","extrudedHeightValue","extrudedHeightReferenceValue","extrudedHeightReference","options","VERTEX_FORMAT","MaterialSupport","TEXTURED","computeGeometryOffsetAttribute","getGeometryHeight","getGeometryExtrudedHeight","CLAMP_TO_GROUND","getMinimumMaximumHeights","computeRectangle","minimumTerrainHeight","DynamicRectangleGeometryUpdater","geometryUpdater","primitives","groundPrimitives","_setOptions"],"mappings":"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","sourcesContent":["import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport RectangleGeometry from \"../Core/RectangleGeometry.js\";\nimport RectangleOutlineGeometry from \"../Core/RectangleOutlineGeometry.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport DynamicGeometryUpdater from \"./DynamicGeometryUpdater.js\";\nimport GeometryUpdater from \"./GeometryUpdater.js\";\nimport GroundGeometryUpdater from \"./GroundGeometryUpdater.js\";\nimport Property from \"./Property.js\";\n\nvar scratchColor = new Color();\nvar defaultOffset = Cartesian3.ZERO;\nvar offsetScratch = new Cartesian3();\nvar scratchRectangle = new Rectangle();\nvar scratchCenterRect = new Rectangle();\nvar scratchCarto = new Cartographic();\n\nfunction RectangleGeometryOptions(entity) {\n  this.id = entity;\n  this.vertexFormat = undefined;\n  this.rectangle = undefined;\n  this.height = undefined;\n  this.extrudedHeight = undefined;\n  this.granularity = undefined;\n  this.stRotation = undefined;\n  this.rotation = undefined;\n  this.offsetAttribute = undefined;\n}\n\n/**\n * A {@link GeometryUpdater} for rectangles.\n * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n * @alias RectangleGeometryUpdater\n * @constructor\n *\n * @param {Entity} entity The entity containing the geometry to be visualized.\n * @param {Scene} scene The scene where visualization is taking place.\n */\nfunction RectangleGeometryUpdater(entity, scene) {\n  GroundGeometryUpdater.call(this, {\n    entity: entity,\n    scene: scene,\n    geometryOptions: new RectangleGeometryOptions(entity),\n    geometryPropertyName: \"rectangle\",\n    observedPropertyNames: [\"availability\", \"rectangle\"],\n  });\n\n  this._onEntityPropertyChanged(\n    entity,\n    \"rectangle\",\n    entity.rectangle,\n    undefined\n  );\n}\n\nif (defined(Object.create)) {\n  RectangleGeometryUpdater.prototype = Object.create(\n    GroundGeometryUpdater.prototype\n  );\n  RectangleGeometryUpdater.prototype.constructor = RectangleGeometryUpdater;\n}\n\n/**\n * Creates the geometry instance which represents the fill of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent a filled geometry.\n */\nRectangleGeometryUpdater.prototype.createFillGeometryInstance = function (\n  time\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n\n  if (!this._fillEnabled) {\n    throw new DeveloperError(\n      \"This instance does not represent a filled geometry.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var entity = this._entity;\n  var isAvailable = entity.isAvailable(time);\n\n  var attributes = {\n    show: new ShowGeometryInstanceAttribute(\n      isAvailable &&\n        entity.isShowing &&\n        this._showProperty.getValue(time) &&\n        this._fillProperty.getValue(time)\n    ),\n    distanceDisplayCondition: DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(\n      this._distanceDisplayConditionProperty.getValue(time)\n    ),\n    offset: undefined,\n    color: undefined,\n  };\n\n  if (this._materialProperty instanceof ColorMaterialProperty) {\n    var currentColor;\n    if (\n      defined(this._materialProperty.color) &&\n      (this._materialProperty.color.isConstant || isAvailable)\n    ) {\n      currentColor = this._materialProperty.color.getValue(time, scratchColor);\n    }\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n    attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n  }\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(\n      Property.getValueOrDefault(\n        this._terrainOffsetProperty,\n        time,\n        defaultOffset,\n        offsetScratch\n      )\n    );\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new RectangleGeometry(this._options),\n    attributes: attributes,\n  });\n};\n\n/**\n * Creates the geometry instance which represents the outline of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent an outlined geometry.\n */\nRectangleGeometryUpdater.prototype.createOutlineGeometryInstance = function (\n  time\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n\n  if (!this._outlineEnabled) {\n    throw new DeveloperError(\n      \"This instance does not represent an outlined geometry.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var entity = this._entity;\n  var isAvailable = entity.isAvailable(time);\n  var outlineColor = Property.getValueOrDefault(\n    this._outlineColorProperty,\n    time,\n    Color.BLACK,\n    scratchColor\n  );\n  var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(\n    time\n  );\n\n  var attributes = {\n    show: new ShowGeometryInstanceAttribute(\n      isAvailable &&\n        entity.isShowing &&\n        this._showProperty.getValue(time) &&\n        this._showOutlineProperty.getValue(time)\n    ),\n    color: ColorGeometryInstanceAttribute.fromColor(outlineColor),\n    distanceDisplayCondition: DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(\n      distanceDisplayCondition\n    ),\n    offset: undefined,\n  };\n\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(\n      Property.getValueOrDefault(\n        this._terrainOffsetProperty,\n        time,\n        defaultOffset,\n        offsetScratch\n      )\n    );\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new RectangleOutlineGeometry(this._options),\n    attributes: attributes,\n  });\n};\n\nRectangleGeometryUpdater.prototype._computeCenter = function (time, result) {\n  var rect = Property.getValueOrUndefined(\n    this._entity.rectangle.coordinates,\n    time,\n    scratchCenterRect\n  );\n  if (!defined(rect)) {\n    return;\n  }\n  var center = Rectangle.center(rect, scratchCarto);\n  return Cartographic.toCartesian(center, Ellipsoid.WGS84, result);\n};\n\nRectangleGeometryUpdater.prototype._isHidden = function (entity, rectangle) {\n  return (\n    !defined(rectangle.coordinates) ||\n    GeometryUpdater.prototype._isHidden.call(this, entity, rectangle)\n  );\n};\n\nRectangleGeometryUpdater.prototype._isDynamic = function (entity, rectangle) {\n  return (\n    !rectangle.coordinates.isConstant || //\n    !Property.isConstant(rectangle.height) || //\n    !Property.isConstant(rectangle.extrudedHeight) || //\n    !Property.isConstant(rectangle.granularity) || //\n    !Property.isConstant(rectangle.stRotation) || //\n    !Property.isConstant(rectangle.rotation) || //\n    !Property.isConstant(rectangle.outlineWidth) || //\n    !Property.isConstant(rectangle.zIndex) || //\n    (this._onTerrain &&\n      !Property.isConstant(this._materialProperty) &&\n      !(this._materialProperty instanceof ColorMaterialProperty))\n  );\n};\n\nRectangleGeometryUpdater.prototype._setStaticOptions = function (\n  entity,\n  rectangle\n) {\n  var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;\n\n  var heightValue = Property.getValueOrUndefined(\n    rectangle.height,\n    Iso8601.MINIMUM_VALUE\n  );\n  var heightReferenceValue = Property.getValueOrDefault(\n    rectangle.heightReference,\n    Iso8601.MINIMUM_VALUE,\n    HeightReference.NONE\n  );\n  var extrudedHeightValue = Property.getValueOrUndefined(\n    rectangle.extrudedHeight,\n    Iso8601.MINIMUM_VALUE\n  );\n  var extrudedHeightReferenceValue = Property.getValueOrDefault(\n    rectangle.extrudedHeightReference,\n    Iso8601.MINIMUM_VALUE,\n    HeightReference.NONE\n  );\n  if (defined(extrudedHeightValue) && !defined(heightValue)) {\n    heightValue = 0;\n  }\n\n  var options = this._options;\n  options.vertexFormat = isColorMaterial\n    ? PerInstanceColorAppearance.VERTEX_FORMAT\n    : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n  options.rectangle = rectangle.coordinates.getValue(\n    Iso8601.MINIMUM_VALUE,\n    options.rectangle\n  );\n  options.granularity = Property.getValueOrUndefined(\n    rectangle.granularity,\n    Iso8601.MINIMUM_VALUE\n  );\n  options.stRotation = Property.getValueOrUndefined(\n    rectangle.stRotation,\n    Iso8601.MINIMUM_VALUE\n  );\n  options.rotation = Property.getValueOrUndefined(\n    rectangle.rotation,\n    Iso8601.MINIMUM_VALUE\n  );\n  options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(\n    heightValue,\n    heightReferenceValue,\n    extrudedHeightValue,\n    extrudedHeightReferenceValue\n  );\n  options.height = GroundGeometryUpdater.getGeometryHeight(\n    heightValue,\n    heightReferenceValue\n  );\n\n  extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(\n    extrudedHeightValue,\n    extrudedHeightReferenceValue\n  );\n  if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n    extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(\n      RectangleGeometry.computeRectangle(options, scratchRectangle)\n    ).minimumTerrainHeight;\n  }\n\n  options.extrudedHeight = extrudedHeightValue;\n};\n\nRectangleGeometryUpdater.DynamicGeometryUpdater = DynamicRectangleGeometryUpdater;\n\n/**\n * @private\n */\nfunction DynamicRectangleGeometryUpdater(\n  geometryUpdater,\n  primitives,\n  groundPrimitives\n) {\n  DynamicGeometryUpdater.call(\n    this,\n    geometryUpdater,\n    primitives,\n    groundPrimitives\n  );\n}\n\nif (defined(Object.create)) {\n  DynamicRectangleGeometryUpdater.prototype = Object.create(\n    DynamicGeometryUpdater.prototype\n  );\n  DynamicRectangleGeometryUpdater.prototype.constructor = DynamicRectangleGeometryUpdater;\n}\n\nDynamicRectangleGeometryUpdater.prototype._isHidden = function (\n  entity,\n  rectangle,\n  time\n) {\n  return (\n    !defined(this._options.rectangle) ||\n    DynamicGeometryUpdater.prototype._isHidden.call(\n      this,\n      entity,\n      rectangle,\n      time\n    )\n  );\n};\n\nDynamicRectangleGeometryUpdater.prototype._setOptions = function (\n  entity,\n  rectangle,\n  time\n) {\n  var options = this._options;\n  var heightValue = Property.getValueOrUndefined(rectangle.height, time);\n  var heightReferenceValue = Property.getValueOrDefault(\n    rectangle.heightReference,\n    time,\n    HeightReference.NONE\n  );\n  var extrudedHeightValue = Property.getValueOrUndefined(\n    rectangle.extrudedHeight,\n    time\n  );\n  var extrudedHeightReferenceValue = Property.getValueOrDefault(\n    rectangle.extrudedHeightReference,\n    time,\n    HeightReference.NONE\n  );\n  if (defined(extrudedHeightValue) && !defined(heightValue)) {\n    heightValue = 0;\n  }\n\n  options.rectangle = Property.getValueOrUndefined(\n    rectangle.coordinates,\n    time,\n    options.rectangle\n  );\n  options.granularity = Property.getValueOrUndefined(\n    rectangle.granularity,\n    time\n  );\n  options.stRotation = Property.getValueOrUndefined(rectangle.stRotation, time);\n  options.rotation = Property.getValueOrUndefined(rectangle.rotation, time);\n  options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(\n    heightValue,\n    heightReferenceValue,\n    extrudedHeightValue,\n    extrudedHeightReferenceValue\n  );\n  options.height = GroundGeometryUpdater.getGeometryHeight(\n    heightValue,\n    heightReferenceValue\n  );\n\n  extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(\n    extrudedHeightValue,\n    extrudedHeightReferenceValue\n  );\n  if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n    extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(\n      RectangleGeometry.computeRectangle(options, scratchRectangle)\n    ).minimumTerrainHeight;\n  }\n\n  options.extrudedHeight = extrudedHeightValue;\n};\nexport default RectangleGeometryUpdater;\n"]},"metadata":{},"sourceType":"module"}