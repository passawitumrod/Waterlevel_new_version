{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\n/**\n * A plane in Hessian Normal Form defined by\n * <pre>\n * ax + by + cz + d = 0\n * </pre>\n * where (a, b, c) is the plane's <code>normal</code>, d is the signed\n * <code>distance</code> to the plane, and (x, y, z) is any point on\n * the plane.\n *\n * @alias Plane\n * @constructor\n *\n * @param {Cartesian3} normal The plane's normal (normalized).\n * @param {Number} distance The shortest distance from the origin to the plane.  The sign of\n * <code>distance</code> determines which side of the plane the origin\n * is on.  If <code>distance</code> is positive, the origin is in the half-space\n * in the direction of the normal; if negative, the origin is in the half-space\n * opposite to the normal; if zero, the plane passes through the origin.\n *\n * @example\n * // The plane x=0\n * var plane = new Cesium.Plane(Cesium.Cartesian3.UNIT_X, 0.0);\n *\n * @exception {DeveloperError} Normal must be normalized\n */\n\nfunction Plane(normal, distance) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"normal\", normal);\n\n  if (!CesiumMath.equalsEpsilon(Cartesian3.magnitude(normal), 1.0, CesiumMath.EPSILON6)) {\n    throw new DeveloperError(\"normal must be normalized.\");\n  }\n\n  Check.typeOf.number(\"distance\", distance); //>>includeEnd('debug');\n\n  /**\n   * The plane's normal.\n   *\n   * @type {Cartesian3}\n   */\n\n  this.normal = Cartesian3.clone(normal);\n  /**\n   * The shortest distance from the origin to the plane.  The sign of\n   * <code>distance</code> determines which side of the plane the origin\n   * is on.  If <code>distance</code> is positive, the origin is in the half-space\n   * in the direction of the normal; if negative, the origin is in the half-space\n   * opposite to the normal; if zero, the plane passes through the origin.\n   *\n   * @type {Number}\n   */\n\n  this.distance = distance;\n}\n/**\n * Creates a plane from a normal and a point on the plane.\n *\n * @param {Cartesian3} point The point on the plane.\n * @param {Cartesian3} normal The plane's normal (normalized).\n * @param {Plane} [result] The object onto which to store the result.\n * @returns {Plane} A new plane instance or the modified result parameter.\n *\n * @example\n * var point = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);\n * var normal = ellipsoid.geodeticSurfaceNormal(point);\n * var tangentPlane = Cesium.Plane.fromPointNormal(point, normal);\n *\n * @exception {DeveloperError} Normal must be normalized\n */\n\n\nPlane.fromPointNormal = function (point, normal, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"point\", point);\n  Check.typeOf.object(\"normal\", normal);\n\n  if (!CesiumMath.equalsEpsilon(Cartesian3.magnitude(normal), 1.0, CesiumMath.EPSILON6)) {\n    throw new DeveloperError(\"normal must be normalized.\");\n  } //>>includeEnd('debug');\n\n\n  var distance = -Cartesian3.dot(normal, point);\n\n  if (!defined(result)) {\n    return new Plane(normal, distance);\n  }\n\n  Cartesian3.clone(normal, result.normal);\n  result.distance = distance;\n  return result;\n};\n\nvar scratchNormal = new Cartesian3();\n/**\n * Creates a plane from the general equation\n *\n * @param {Cartesian4} coefficients The plane's normal (normalized).\n * @param {Plane} [result] The object onto which to store the result.\n * @returns {Plane} A new plane instance or the modified result parameter.\n *\n * @exception {DeveloperError} Normal must be normalized\n */\n\nPlane.fromCartesian4 = function (coefficients, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"coefficients\", coefficients); //>>includeEnd('debug');\n\n  var normal = Cartesian3.fromCartesian4(coefficients, scratchNormal);\n  var distance = coefficients.w; //>>includeStart('debug', pragmas.debug);\n\n  if (!CesiumMath.equalsEpsilon(Cartesian3.magnitude(normal), 1.0, CesiumMath.EPSILON6)) {\n    throw new DeveloperError(\"normal must be normalized.\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(result)) {\n    return new Plane(normal, distance);\n  }\n\n  Cartesian3.clone(normal, result.normal);\n  result.distance = distance;\n  return result;\n};\n/**\n * Computes the signed shortest distance of a point to a plane.\n * The sign of the distance determines which side of the plane the point\n * is on.  If the distance is positive, the point is in the half-space\n * in the direction of the normal; if negative, the point is in the half-space\n * opposite to the normal; if zero, the plane passes through the point.\n *\n * @param {Plane} plane The plane.\n * @param {Cartesian3} point The point.\n * @returns {Number} The signed shortest distance of the point to the plane.\n */\n\n\nPlane.getPointDistance = function (plane, point) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  Check.typeOf.object(\"point\", point); //>>includeEnd('debug');\n\n  return Cartesian3.dot(plane.normal, point) + plane.distance;\n};\n\nvar scratchCartesian = new Cartesian3();\n/**\n * Projects a point onto the plane.\n * @param {Plane} plane The plane to project the point onto\n * @param {Cartesian3} point The point to project onto the plane\n * @param {Cartesian3} [result] The result point.  If undefined, a new Cartesian3 will be created.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\n\nPlane.projectPointOntoPlane = function (plane, point, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  Check.typeOf.object(\"point\", point); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  } // projectedPoint = point - (normal.point + scale) * normal\n\n\n  var pointDistance = Plane.getPointDistance(plane, point);\n  var scaledNormal = Cartesian3.multiplyByScalar(plane.normal, pointDistance, scratchCartesian);\n  return Cartesian3.subtract(point, scaledNormal, result);\n};\n\nvar scratchPosition = new Cartesian3();\n/**\n * Transforms the plane by the given transformation matrix.\n *\n * @param {Plane} plane The plane.\n * @param {Matrix4} transform The transformation matrix.\n * @param {Plane} [result] The object into which to store the result.\n * @returns {Plane} The plane transformed by the given transformation matrix.\n */\n\nPlane.transform = function (plane, transform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  Check.typeOf.object(\"transform\", transform); //>>includeEnd('debug');\n\n  Matrix4.multiplyByPointAsVector(transform, plane.normal, scratchNormal);\n  Cartesian3.normalize(scratchNormal, scratchNormal);\n  Cartesian3.multiplyByScalar(plane.normal, -plane.distance, scratchPosition);\n  Matrix4.multiplyByPoint(transform, scratchPosition, scratchPosition);\n  return Plane.fromPointNormal(scratchPosition, scratchNormal, result);\n};\n/**\n * Duplicates a Plane instance.\n *\n * @param {Plane} plane The plane to duplicate.\n * @param {Plane} [result] The object onto which to store the result.\n * @returns {Plane} The modified result parameter or a new Plane instance if one was not provided.\n */\n\n\nPlane.clone = function (plane, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Plane(plane.normal, plane.distance);\n  }\n\n  Cartesian3.clone(plane.normal, result.normal);\n  result.distance = plane.distance;\n  return result;\n};\n/**\n * Compares the provided Planes by normal and distance and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Plane} left The first plane.\n * @param {Plane} right The second plane.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\n\n\nPlane.equals = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right); //>>includeEnd('debug');\n\n  return left.distance === right.distance && Cartesian3.equals(left.normal, right.normal);\n};\n/**\n * A constant initialized to the XY plane passing through the origin, with normal in positive Z.\n *\n * @type {Plane}\n * @constant\n */\n\n\nPlane.ORIGIN_XY_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_Z, 0.0));\n/**\n * A constant initialized to the YZ plane passing through the origin, with normal in positive X.\n *\n * @type {Plane}\n * @constant\n */\n\nPlane.ORIGIN_YZ_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_X, 0.0));\n/**\n * A constant initialized to the ZX plane passing through the origin, with normal in positive Y.\n *\n * @type {Plane}\n * @constant\n */\n\nPlane.ORIGIN_ZX_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_Y, 0.0));\nexport default Plane;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/Plane.js"],"names":["Cartesian3","Check","defined","DeveloperError","CesiumMath","Matrix4","Plane","normal","distance","typeOf","object","equalsEpsilon","magnitude","EPSILON6","number","clone","fromPointNormal","point","result","dot","scratchNormal","fromCartesian4","coefficients","w","getPointDistance","plane","scratchCartesian","projectPointOntoPlane","pointDistance","scaledNormal","multiplyByScalar","subtract","scratchPosition","transform","multiplyByPointAsVector","normalize","multiplyByPoint","equals","left","right","ORIGIN_XY_PLANE","Object","freeze","UNIT_Z","ORIGIN_YZ_PLANE","UNIT_X","ORIGIN_ZX_PLANE","UNIT_Y"],"mappings":"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","sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\n\n/**\n * A plane in Hessian Normal Form defined by\n * <pre>\n * ax + by + cz + d = 0\n * </pre>\n * where (a, b, c) is the plane's <code>normal</code>, d is the signed\n * <code>distance</code> to the plane, and (x, y, z) is any point on\n * the plane.\n *\n * @alias Plane\n * @constructor\n *\n * @param {Cartesian3} normal The plane's normal (normalized).\n * @param {Number} distance The shortest distance from the origin to the plane.  The sign of\n * <code>distance</code> determines which side of the plane the origin\n * is on.  If <code>distance</code> is positive, the origin is in the half-space\n * in the direction of the normal; if negative, the origin is in the half-space\n * opposite to the normal; if zero, the plane passes through the origin.\n *\n * @example\n * // The plane x=0\n * var plane = new Cesium.Plane(Cesium.Cartesian3.UNIT_X, 0.0);\n *\n * @exception {DeveloperError} Normal must be normalized\n */\nfunction Plane(normal, distance) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"normal\", normal);\n  if (\n    !CesiumMath.equalsEpsilon(\n      Cartesian3.magnitude(normal),\n      1.0,\n      CesiumMath.EPSILON6\n    )\n  ) {\n    throw new DeveloperError(\"normal must be normalized.\");\n  }\n  Check.typeOf.number(\"distance\", distance);\n  //>>includeEnd('debug');\n\n  /**\n   * The plane's normal.\n   *\n   * @type {Cartesian3}\n   */\n  this.normal = Cartesian3.clone(normal);\n\n  /**\n   * The shortest distance from the origin to the plane.  The sign of\n   * <code>distance</code> determines which side of the plane the origin\n   * is on.  If <code>distance</code> is positive, the origin is in the half-space\n   * in the direction of the normal; if negative, the origin is in the half-space\n   * opposite to the normal; if zero, the plane passes through the origin.\n   *\n   * @type {Number}\n   */\n  this.distance = distance;\n}\n\n/**\n * Creates a plane from a normal and a point on the plane.\n *\n * @param {Cartesian3} point The point on the plane.\n * @param {Cartesian3} normal The plane's normal (normalized).\n * @param {Plane} [result] The object onto which to store the result.\n * @returns {Plane} A new plane instance or the modified result parameter.\n *\n * @example\n * var point = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);\n * var normal = ellipsoid.geodeticSurfaceNormal(point);\n * var tangentPlane = Cesium.Plane.fromPointNormal(point, normal);\n *\n * @exception {DeveloperError} Normal must be normalized\n */\nPlane.fromPointNormal = function (point, normal, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"point\", point);\n  Check.typeOf.object(\"normal\", normal);\n  if (\n    !CesiumMath.equalsEpsilon(\n      Cartesian3.magnitude(normal),\n      1.0,\n      CesiumMath.EPSILON6\n    )\n  ) {\n    throw new DeveloperError(\"normal must be normalized.\");\n  }\n  //>>includeEnd('debug');\n\n  var distance = -Cartesian3.dot(normal, point);\n\n  if (!defined(result)) {\n    return new Plane(normal, distance);\n  }\n\n  Cartesian3.clone(normal, result.normal);\n  result.distance = distance;\n  return result;\n};\n\nvar scratchNormal = new Cartesian3();\n/**\n * Creates a plane from the general equation\n *\n * @param {Cartesian4} coefficients The plane's normal (normalized).\n * @param {Plane} [result] The object onto which to store the result.\n * @returns {Plane} A new plane instance or the modified result parameter.\n *\n * @exception {DeveloperError} Normal must be normalized\n */\nPlane.fromCartesian4 = function (coefficients, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"coefficients\", coefficients);\n  //>>includeEnd('debug');\n\n  var normal = Cartesian3.fromCartesian4(coefficients, scratchNormal);\n  var distance = coefficients.w;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !CesiumMath.equalsEpsilon(\n      Cartesian3.magnitude(normal),\n      1.0,\n      CesiumMath.EPSILON6\n    )\n  ) {\n    throw new DeveloperError(\"normal must be normalized.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Plane(normal, distance);\n  }\n  Cartesian3.clone(normal, result.normal);\n  result.distance = distance;\n  return result;\n};\n\n/**\n * Computes the signed shortest distance of a point to a plane.\n * The sign of the distance determines which side of the plane the point\n * is on.  If the distance is positive, the point is in the half-space\n * in the direction of the normal; if negative, the point is in the half-space\n * opposite to the normal; if zero, the plane passes through the point.\n *\n * @param {Plane} plane The plane.\n * @param {Cartesian3} point The point.\n * @returns {Number} The signed shortest distance of the point to the plane.\n */\nPlane.getPointDistance = function (plane, point) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  Check.typeOf.object(\"point\", point);\n  //>>includeEnd('debug');\n\n  return Cartesian3.dot(plane.normal, point) + plane.distance;\n};\n\nvar scratchCartesian = new Cartesian3();\n/**\n * Projects a point onto the plane.\n * @param {Plane} plane The plane to project the point onto\n * @param {Cartesian3} point The point to project onto the plane\n * @param {Cartesian3} [result] The result point.  If undefined, a new Cartesian3 will be created.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nPlane.projectPointOntoPlane = function (plane, point, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  Check.typeOf.object(\"point\", point);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  // projectedPoint = point - (normal.point + scale) * normal\n  var pointDistance = Plane.getPointDistance(plane, point);\n  var scaledNormal = Cartesian3.multiplyByScalar(\n    plane.normal,\n    pointDistance,\n    scratchCartesian\n  );\n\n  return Cartesian3.subtract(point, scaledNormal, result);\n};\n\nvar scratchPosition = new Cartesian3();\n/**\n * Transforms the plane by the given transformation matrix.\n *\n * @param {Plane} plane The plane.\n * @param {Matrix4} transform The transformation matrix.\n * @param {Plane} [result] The object into which to store the result.\n * @returns {Plane} The plane transformed by the given transformation matrix.\n */\nPlane.transform = function (plane, transform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  Check.typeOf.object(\"transform\", transform);\n  //>>includeEnd('debug');\n\n  Matrix4.multiplyByPointAsVector(transform, plane.normal, scratchNormal);\n  Cartesian3.normalize(scratchNormal, scratchNormal);\n\n  Cartesian3.multiplyByScalar(plane.normal, -plane.distance, scratchPosition);\n  Matrix4.multiplyByPoint(transform, scratchPosition, scratchPosition);\n\n  return Plane.fromPointNormal(scratchPosition, scratchNormal, result);\n};\n\n/**\n * Duplicates a Plane instance.\n *\n * @param {Plane} plane The plane to duplicate.\n * @param {Plane} [result] The object onto which to store the result.\n * @returns {Plane} The modified result parameter or a new Plane instance if one was not provided.\n */\nPlane.clone = function (plane, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Plane(plane.normal, plane.distance);\n  }\n\n  Cartesian3.clone(plane.normal, result.normal);\n  result.distance = plane.distance;\n\n  return result;\n};\n\n/**\n * Compares the provided Planes by normal and distance and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Plane} left The first plane.\n * @param {Plane} right The second plane.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nPlane.equals = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return (\n    left.distance === right.distance &&\n    Cartesian3.equals(left.normal, right.normal)\n  );\n};\n\n/**\n * A constant initialized to the XY plane passing through the origin, with normal in positive Z.\n *\n * @type {Plane}\n * @constant\n */\nPlane.ORIGIN_XY_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_Z, 0.0));\n\n/**\n * A constant initialized to the YZ plane passing through the origin, with normal in positive X.\n *\n * @type {Plane}\n * @constant\n */\nPlane.ORIGIN_YZ_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_X, 0.0));\n\n/**\n * A constant initialized to the ZX plane passing through the origin, with normal in positive Y.\n *\n * @type {Plane}\n * @constant\n */\nPlane.ORIGIN_ZX_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_Y, 0.0));\nexport default Plane;\n"]},"metadata":{},"sourceType":"module"}