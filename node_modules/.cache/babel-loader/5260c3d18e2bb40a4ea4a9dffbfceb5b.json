{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"uniform float u_radiusTS;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nvec2 rotate(vec2 p, vec2 direction)\\n\\\n{\\n\\\n    return vec2(p.x * direction.x - p.y * direction.y, p.x * direction.y + p.y * direction.x);\\n\\\n}\\n\\\n\\n\\\nvec4 addBurst(vec2 position, vec2 direction, float lengthScalar)\\n\\\n{\\n\\\n    vec2 rotatedPosition = rotate(position, direction) * vec2(25.0, 0.75);\\n\\\n    float radius = length(rotatedPosition) * lengthScalar;\\n\\\n    float burst = 1.0 - smoothstep(0.0, 0.55, radius);\\n\\\n    return vec4(burst);\\n\\\n}\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    float lengthScalar = 2.0 / sqrt(2.0);\\n\\\n    vec2 position = v_textureCoordinates - vec2(0.5);\\n\\\n    float radius = length(position) * lengthScalar;\\n\\\n    float surface = step(radius, u_radiusTS);\\n\\\n    vec4 color = vec4(vec2(1.0), surface + 0.2, surface);\\n\\\n\\n\\\n    float glow = 1.0 - smoothstep(0.0, 0.55, radius);\\n\\\n    color.ba += mix(vec2(0.0), vec2(1.0), glow) * 0.75;\\n\\\n\\n\\\n    vec4 burst = vec4(0.0);\\n\\\n\\n\\\n    // The following loop has been manually unrolled for speed, to\\n\\\n    // avoid sin() and cos().\\n\\\n    //\\n\\\n    //for (float i = 0.4; i < 3.2; i += 1.047) {\\n\\\n    //    vec2 direction = vec2(sin(i), cos(i));\\n\\\n    //    burst += 0.4 * addBurst(position, direction, lengthScalar);\\n\\\n    //\\n\\\n    //    direction = vec2(sin(i - 0.08), cos(i - 0.08));\\n\\\n    //    burst += 0.3 * addBurst(position, direction, lengthScalar);\\n\\\n    //}\\n\\\n\\n\\\n    burst += 0.4 * addBurst(position, vec2(0.38942,  0.92106), lengthScalar);  // angle == 0.4\\n\\\n    burst += 0.4 * addBurst(position, vec2(0.99235,  0.12348), lengthScalar);  // angle == 0.4 + 1.047\\n\\\n    burst += 0.4 * addBurst(position, vec2(0.60327, -0.79754), lengthScalar);  // angle == 0.4 + 1.047 * 2.0\\n\\\n\\n\\\n    burst += 0.3 * addBurst(position, vec2(0.31457,  0.94924), lengthScalar);  // angle == 0.4 - 0.08\\n\\\n    burst += 0.3 * addBurst(position, vec2(0.97931,  0.20239), lengthScalar);  // angle == 0.4 + 1.047 - 0.08\\n\\\n    burst += 0.3 * addBurst(position, vec2(0.66507, -0.74678), lengthScalar);  // angle == 0.4 + 1.047 * 2.0 - 0.08\\n\\\n\\n\\\n    // End of manual loop unrolling.\\n\\\n\\n\\\n    color += clamp(burst, vec4(0.0), vec4(1.0)) * 0.15;\\n\\\n\\n\\\n    gl_FragColor = clamp(color, vec4(0.0), vec4(1.0));\\n\\\n}\\n\\\n\";","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Shaders/SunTextureFS.js"],"names":[],"mappings":"AAAA;AACA,eAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAAf","sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"uniform float u_radiusTS;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nvec2 rotate(vec2 p, vec2 direction)\\n\\\n{\\n\\\n    return vec2(p.x * direction.x - p.y * direction.y, p.x * direction.y + p.y * direction.x);\\n\\\n}\\n\\\n\\n\\\nvec4 addBurst(vec2 position, vec2 direction, float lengthScalar)\\n\\\n{\\n\\\n    vec2 rotatedPosition = rotate(position, direction) * vec2(25.0, 0.75);\\n\\\n    float radius = length(rotatedPosition) * lengthScalar;\\n\\\n    float burst = 1.0 - smoothstep(0.0, 0.55, radius);\\n\\\n    return vec4(burst);\\n\\\n}\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    float lengthScalar = 2.0 / sqrt(2.0);\\n\\\n    vec2 position = v_textureCoordinates - vec2(0.5);\\n\\\n    float radius = length(position) * lengthScalar;\\n\\\n    float surface = step(radius, u_radiusTS);\\n\\\n    vec4 color = vec4(vec2(1.0), surface + 0.2, surface);\\n\\\n\\n\\\n    float glow = 1.0 - smoothstep(0.0, 0.55, radius);\\n\\\n    color.ba += mix(vec2(0.0), vec2(1.0), glow) * 0.75;\\n\\\n\\n\\\n    vec4 burst = vec4(0.0);\\n\\\n\\n\\\n    // The following loop has been manually unrolled for speed, to\\n\\\n    // avoid sin() and cos().\\n\\\n    //\\n\\\n    //for (float i = 0.4; i < 3.2; i += 1.047) {\\n\\\n    //    vec2 direction = vec2(sin(i), cos(i));\\n\\\n    //    burst += 0.4 * addBurst(position, direction, lengthScalar);\\n\\\n    //\\n\\\n    //    direction = vec2(sin(i - 0.08), cos(i - 0.08));\\n\\\n    //    burst += 0.3 * addBurst(position, direction, lengthScalar);\\n\\\n    //}\\n\\\n\\n\\\n    burst += 0.4 * addBurst(position, vec2(0.38942,  0.92106), lengthScalar);  // angle == 0.4\\n\\\n    burst += 0.4 * addBurst(position, vec2(0.99235,  0.12348), lengthScalar);  // angle == 0.4 + 1.047\\n\\\n    burst += 0.4 * addBurst(position, vec2(0.60327, -0.79754), lengthScalar);  // angle == 0.4 + 1.047 * 2.0\\n\\\n\\n\\\n    burst += 0.3 * addBurst(position, vec2(0.31457,  0.94924), lengthScalar);  // angle == 0.4 - 0.08\\n\\\n    burst += 0.3 * addBurst(position, vec2(0.97931,  0.20239), lengthScalar);  // angle == 0.4 + 1.047 - 0.08\\n\\\n    burst += 0.3 * addBurst(position, vec2(0.66507, -0.74678), lengthScalar);  // angle == 0.4 + 1.047 * 2.0 - 0.08\\n\\\n\\n\\\n    // End of manual loop unrolling.\\n\\\n\\n\\\n    color += clamp(burst, vec4(0.0), vec4(1.0)) * 0.15;\\n\\\n\\n\\\n    gl_FragColor = clamp(color, vec4(0.0), vec4(1.0));\\n\\\n}\\n\\\n\";\n"]},"metadata":{},"sourceType":"module"}