{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport FeatureDetection from \"./FeatureDetection.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\n/**\n * A set of 4-dimensional coordinates used to represent rotation in 3-dimensional space.\n * @alias Quaternion\n * @constructor\n *\n * @param {Number} [x=0.0] The X component.\n * @param {Number} [y=0.0] The Y component.\n * @param {Number} [z=0.0] The Z component.\n * @param {Number} [w=0.0] The W component.\n *\n * @see PackableForInterpolation\n */\n\nfunction Quaternion(x, y, z, w) {\n  /**\n   * The X component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.x = defaultValue(x, 0.0);\n  /**\n   * The Y component.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.y = defaultValue(y, 0.0);\n  /**\n   * The Z component.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.z = defaultValue(z, 0.0);\n  /**\n   * The W component.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.w = defaultValue(w, 0.0);\n}\n\nvar fromAxisAngleScratch = new Cartesian3();\n/**\n * Computes a quaternion representing a rotation around an axis.\n *\n * @param {Cartesian3} axis The axis of rotation.\n * @param {Number} angle The angle in radians to rotate around the axis.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\n\nQuaternion.fromAxisAngle = function (axis, angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"axis\", axis);\n  Check.typeOf.number(\"angle\", angle); //>>includeEnd('debug');\n\n  var halfAngle = angle / 2.0;\n  var s = Math.sin(halfAngle);\n  fromAxisAngleScratch = Cartesian3.normalize(axis, fromAxisAngleScratch);\n  var x = fromAxisAngleScratch.x * s;\n  var y = fromAxisAngleScratch.y * s;\n  var z = fromAxisAngleScratch.z * s;\n  var w = Math.cos(halfAngle);\n\n  if (!defined(result)) {\n    return new Quaternion(x, y, z, w);\n  }\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\nvar fromRotationMatrixNext = [1, 2, 0];\nvar fromRotationMatrixQuat = new Array(3);\n/**\n * Computes a Quaternion from the provided Matrix3 instance.\n *\n * @param {Matrix3} matrix The rotation matrix.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n *\n * @see Matrix3.fromQuaternion\n */\n\nQuaternion.fromRotationMatrix = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix); //>>includeEnd('debug');\n\n  var root;\n  var x;\n  var y;\n  var z;\n  var w;\n  var m00 = matrix[Matrix3.COLUMN0ROW0];\n  var m11 = matrix[Matrix3.COLUMN1ROW1];\n  var m22 = matrix[Matrix3.COLUMN2ROW2];\n  var trace = m00 + m11 + m22;\n\n  if (trace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    root = Math.sqrt(trace + 1.0); // 2w\n\n    w = 0.5 * root;\n    root = 0.5 / root; // 1/(4w)\n\n    x = (matrix[Matrix3.COLUMN1ROW2] - matrix[Matrix3.COLUMN2ROW1]) * root;\n    y = (matrix[Matrix3.COLUMN2ROW0] - matrix[Matrix3.COLUMN0ROW2]) * root;\n    z = (matrix[Matrix3.COLUMN0ROW1] - matrix[Matrix3.COLUMN1ROW0]) * root;\n  } else {\n    // |w| <= 1/2\n    var next = fromRotationMatrixNext;\n    var i = 0;\n\n    if (m11 > m00) {\n      i = 1;\n    }\n\n    if (m22 > m00 && m22 > m11) {\n      i = 2;\n    }\n\n    var j = next[i];\n    var k = next[j];\n    root = Math.sqrt(matrix[Matrix3.getElementIndex(i, i)] - matrix[Matrix3.getElementIndex(j, j)] - matrix[Matrix3.getElementIndex(k, k)] + 1.0);\n    var quat = fromRotationMatrixQuat;\n    quat[i] = 0.5 * root;\n    root = 0.5 / root;\n    w = (matrix[Matrix3.getElementIndex(k, j)] - matrix[Matrix3.getElementIndex(j, k)]) * root;\n    quat[j] = (matrix[Matrix3.getElementIndex(j, i)] + matrix[Matrix3.getElementIndex(i, j)]) * root;\n    quat[k] = (matrix[Matrix3.getElementIndex(k, i)] + matrix[Matrix3.getElementIndex(i, k)]) * root;\n    x = -quat[0];\n    y = -quat[1];\n    z = -quat[2];\n  }\n\n  if (!defined(result)) {\n    return new Quaternion(x, y, z, w);\n  }\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\nvar scratchHPRQuaternion = new Quaternion();\nvar scratchHeadingQuaternion = new Quaternion();\nvar scratchPitchQuaternion = new Quaternion();\nvar scratchRollQuaternion = new Quaternion();\n/**\n * Computes a rotation from the given heading, pitch and roll angles. Heading is the rotation about the\n * negative z axis. Pitch is the rotation about the negative y axis. Roll is the rotation about\n * the positive x axis.\n *\n * @param {HeadingPitchRoll} headingPitchRoll The rotation expressed as a heading, pitch and roll.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if none was provided.\n */\n\nQuaternion.fromHeadingPitchRoll = function (headingPitchRoll, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"headingPitchRoll\", headingPitchRoll); //>>includeEnd('debug');\n\n  scratchRollQuaternion = Quaternion.fromAxisAngle(Cartesian3.UNIT_X, headingPitchRoll.roll, scratchHPRQuaternion);\n  scratchPitchQuaternion = Quaternion.fromAxisAngle(Cartesian3.UNIT_Y, -headingPitchRoll.pitch, result);\n  result = Quaternion.multiply(scratchPitchQuaternion, scratchRollQuaternion, scratchPitchQuaternion);\n  scratchHeadingQuaternion = Quaternion.fromAxisAngle(Cartesian3.UNIT_Z, -headingPitchRoll.heading, scratchHPRQuaternion);\n  return Quaternion.multiply(scratchHeadingQuaternion, result, result);\n};\n\nvar sampledQuaternionAxis = new Cartesian3();\nvar sampledQuaternionRotation = new Cartesian3();\nvar sampledQuaternionTempQuaternion = new Quaternion();\nvar sampledQuaternionQuaternion0 = new Quaternion();\nvar sampledQuaternionQuaternion0Conjugate = new Quaternion();\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\n\nQuaternion.packedLength = 4;\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Quaternion} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\nQuaternion.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex++] = value.z;\n  array[startingIndex] = value.w;\n  return array;\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Quaternion} [result] The object into which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\n\n\nQuaternion.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Quaternion();\n  }\n\n  result.x = array[startingIndex];\n  result.y = array[startingIndex + 1];\n  result.z = array[startingIndex + 2];\n  result.w = array[startingIndex + 3];\n  return result;\n};\n/**\n * The number of elements used to store the object into an array in its interpolatable form.\n * @type {Number}\n */\n\n\nQuaternion.packedInterpolationLength = 3;\n/**\n * Converts a packed array into a form suitable for interpolation.\n *\n * @param {Number[]} packedArray The packed array.\n * @param {Number} [startingIndex=0] The index of the first element to be converted.\n * @param {Number} [lastIndex=packedArray.length] The index of the last element to be converted.\n * @param {Number[]} result The object into which to store the result.\n */\n\nQuaternion.convertPackedArrayForInterpolation = function (packedArray, startingIndex, lastIndex, result) {\n  Quaternion.unpack(packedArray, lastIndex * 4, sampledQuaternionQuaternion0Conjugate);\n  Quaternion.conjugate(sampledQuaternionQuaternion0Conjugate, sampledQuaternionQuaternion0Conjugate);\n\n  for (var i = 0, len = lastIndex - startingIndex + 1; i < len; i++) {\n    var offset = i * 3;\n    Quaternion.unpack(packedArray, (startingIndex + i) * 4, sampledQuaternionTempQuaternion);\n    Quaternion.multiply(sampledQuaternionTempQuaternion, sampledQuaternionQuaternion0Conjugate, sampledQuaternionTempQuaternion);\n\n    if (sampledQuaternionTempQuaternion.w < 0) {\n      Quaternion.negate(sampledQuaternionTempQuaternion, sampledQuaternionTempQuaternion);\n    }\n\n    Quaternion.computeAxis(sampledQuaternionTempQuaternion, sampledQuaternionAxis);\n    var angle = Quaternion.computeAngle(sampledQuaternionTempQuaternion);\n    result[offset] = sampledQuaternionAxis.x * angle;\n    result[offset + 1] = sampledQuaternionAxis.y * angle;\n    result[offset + 2] = sampledQuaternionAxis.z * angle;\n  }\n};\n/**\n * Retrieves an instance from a packed array converted with {@link convertPackedArrayForInterpolation}.\n *\n * @param {Number[]} array The array previously packed for interpolation.\n * @param {Number[]} sourceArray The original packed array.\n * @param {Number} [firstIndex=0] The firstIndex used to convert the array.\n * @param {Number} [lastIndex=packedArray.length] The lastIndex used to convert the array.\n * @param {Quaternion} [result] The object into which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\n\n\nQuaternion.unpackInterpolationResult = function (array, sourceArray, firstIndex, lastIndex, result) {\n  if (!defined(result)) {\n    result = new Quaternion();\n  }\n\n  Cartesian3.fromArray(array, 0, sampledQuaternionRotation);\n  var magnitude = Cartesian3.magnitude(sampledQuaternionRotation);\n  Quaternion.unpack(sourceArray, lastIndex * 4, sampledQuaternionQuaternion0);\n\n  if (magnitude === 0) {\n    Quaternion.clone(Quaternion.IDENTITY, sampledQuaternionTempQuaternion);\n  } else {\n    Quaternion.fromAxisAngle(sampledQuaternionRotation, magnitude, sampledQuaternionTempQuaternion);\n  }\n\n  return Quaternion.multiply(sampledQuaternionTempQuaternion, sampledQuaternionQuaternion0, result);\n};\n/**\n * Duplicates a Quaternion instance.\n *\n * @param {Quaternion} quaternion The quaternion to duplicate.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided. (Returns undefined if quaternion is undefined)\n */\n\n\nQuaternion.clone = function (quaternion, result) {\n  if (!defined(quaternion)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Quaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n  }\n\n  result.x = quaternion.x;\n  result.y = quaternion.y;\n  result.z = quaternion.z;\n  result.w = quaternion.w;\n  return result;\n};\n/**\n * Computes the conjugate of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to conjugate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\n\n\nQuaternion.conjugate = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = -quaternion.x;\n  result.y = -quaternion.y;\n  result.z = -quaternion.z;\n  result.w = quaternion.w;\n  return result;\n};\n/**\n * Computes magnitude squared for the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to conjugate.\n * @returns {Number} The magnitude squared.\n */\n\n\nQuaternion.magnitudeSquared = function (quaternion) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion); //>>includeEnd('debug');\n\n  return quaternion.x * quaternion.x + quaternion.y * quaternion.y + quaternion.z * quaternion.z + quaternion.w * quaternion.w;\n};\n/**\n * Computes magnitude for the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to conjugate.\n * @returns {Number} The magnitude.\n */\n\n\nQuaternion.magnitude = function (quaternion) {\n  return Math.sqrt(Quaternion.magnitudeSquared(quaternion));\n};\n/**\n * Computes the normalized form of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to normalize.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\n\n\nQuaternion.normalize = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var inverseMagnitude = 1.0 / Quaternion.magnitude(quaternion);\n  var x = quaternion.x * inverseMagnitude;\n  var y = quaternion.y * inverseMagnitude;\n  var z = quaternion.z * inverseMagnitude;\n  var w = quaternion.w * inverseMagnitude;\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n/**\n * Computes the inverse of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to normalize.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\n\n\nQuaternion.inverse = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var magnitudeSquared = Quaternion.magnitudeSquared(quaternion);\n  result = Quaternion.conjugate(quaternion, result);\n  return Quaternion.multiplyByScalar(result, 1.0 / magnitudeSquared, result);\n};\n/**\n * Computes the componentwise sum of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\n\n\nQuaternion.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  result.w = left.w + right.w;\n  return result;\n};\n/**\n * Computes the componentwise difference of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\n\n\nQuaternion.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  result.w = left.w - right.w;\n  return result;\n};\n/**\n * Negates the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to be negated.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\n\n\nQuaternion.negate = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = -quaternion.x;\n  result.y = -quaternion.y;\n  result.z = -quaternion.z;\n  result.w = -quaternion.w;\n  return result;\n};\n/**\n * Computes the dot (scalar) product of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @returns {Number} The dot product.\n */\n\n\nQuaternion.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right); //>>includeEnd('debug');\n\n  return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;\n};\n/**\n * Computes the product of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\n\n\nQuaternion.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var leftX = left.x;\n  var leftY = left.y;\n  var leftZ = left.z;\n  var leftW = left.w;\n  var rightX = right.x;\n  var rightY = right.y;\n  var rightZ = right.z;\n  var rightW = right.w;\n  var x = leftW * rightX + leftX * rightW + leftY * rightZ - leftZ * rightY;\n  var y = leftW * rightY - leftX * rightZ + leftY * rightW + leftZ * rightX;\n  var z = leftW * rightZ + leftX * rightY - leftY * rightX + leftZ * rightW;\n  var w = leftW * rightW - leftX * rightX - leftY * rightY - leftZ * rightZ;\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n/**\n * Multiplies the provided quaternion componentwise by the provided scalar.\n *\n * @param {Quaternion} quaternion The quaternion to be scaled.\n * @param {Number} scalar The scalar to multiply with.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\n\n\nQuaternion.multiplyByScalar = function (quaternion, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = quaternion.x * scalar;\n  result.y = quaternion.y * scalar;\n  result.z = quaternion.z * scalar;\n  result.w = quaternion.w * scalar;\n  return result;\n};\n/**\n * Divides the provided quaternion componentwise by the provided scalar.\n *\n * @param {Quaternion} quaternion The quaternion to be divided.\n * @param {Number} scalar The scalar to divide by.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\n\n\nQuaternion.divideByScalar = function (quaternion, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = quaternion.x / scalar;\n  result.y = quaternion.y / scalar;\n  result.z = quaternion.z / scalar;\n  result.w = quaternion.w / scalar;\n  return result;\n};\n/**\n * Computes the axis of rotation of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to use.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\n\n\nQuaternion.computeAxis = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var w = quaternion.w;\n\n  if (Math.abs(w - 1.0) < CesiumMath.EPSILON6) {\n    result.x = result.y = result.z = 0;\n    return result;\n  }\n\n  var scalar = 1.0 / Math.sqrt(1.0 - w * w);\n  result.x = quaternion.x * scalar;\n  result.y = quaternion.y * scalar;\n  result.z = quaternion.z * scalar;\n  return result;\n};\n/**\n * Computes the angle of rotation of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to use.\n * @returns {Number} The angle of rotation.\n */\n\n\nQuaternion.computeAngle = function (quaternion) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion); //>>includeEnd('debug');\n\n  if (Math.abs(quaternion.w - 1.0) < CesiumMath.EPSILON6) {\n    return 0.0;\n  }\n\n  return 2.0 * Math.acos(quaternion.w);\n};\n\nvar lerpScratch = new Quaternion();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided quaternions.\n *\n * @param {Quaternion} start The value corresponding to t at 0.0.\n * @param {Quaternion} end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\n\nQuaternion.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  lerpScratch = Quaternion.multiplyByScalar(end, t, lerpScratch);\n  result = Quaternion.multiplyByScalar(start, 1.0 - t, result);\n  return Quaternion.add(lerpScratch, result, result);\n};\n\nvar slerpEndNegated = new Quaternion();\nvar slerpScaledP = new Quaternion();\nvar slerpScaledR = new Quaternion();\n/**\n * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.\n *\n * @param {Quaternion} start The value corresponding to t at 0.0.\n * @param {Quaternion} end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n * @see Quaternion#fastSlerp\n */\n\nQuaternion.slerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var dot = Quaternion.dot(start, end); // The angle between start must be acute. Since q and -q represent\n  // the same rotation, negate q to get the acute angle.\n\n  var r = end;\n\n  if (dot < 0.0) {\n    dot = -dot;\n    r = slerpEndNegated = Quaternion.negate(end, slerpEndNegated);\n  } // dot > 0, as the dot product approaches 1, the angle between the\n  // quaternions vanishes. use linear interpolation.\n\n\n  if (1.0 - dot < CesiumMath.EPSILON6) {\n    return Quaternion.lerp(start, r, t, result);\n  }\n\n  var theta = Math.acos(dot);\n  slerpScaledP = Quaternion.multiplyByScalar(start, Math.sin((1 - t) * theta), slerpScaledP);\n  slerpScaledR = Quaternion.multiplyByScalar(r, Math.sin(t * theta), slerpScaledR);\n  result = Quaternion.add(slerpScaledP, slerpScaledR, result);\n  return Quaternion.multiplyByScalar(result, 1.0 / Math.sin(theta), result);\n};\n/**\n * The logarithmic quaternion function.\n *\n * @param {Quaternion} quaternion The unit quaternion.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\n\n\nQuaternion.log = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var theta = CesiumMath.acosClamped(quaternion.w);\n  var thetaOverSinTheta = 0.0;\n\n  if (theta !== 0.0) {\n    thetaOverSinTheta = theta / Math.sin(theta);\n  }\n\n  return Cartesian3.multiplyByScalar(quaternion, thetaOverSinTheta, result);\n};\n/**\n * The exponential quaternion function.\n *\n * @param {Cartesian3} cartesian The cartesian.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\n\n\nQuaternion.exp = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var theta = Cartesian3.magnitude(cartesian);\n  var sinThetaOverTheta = 0.0;\n\n  if (theta !== 0.0) {\n    sinThetaOverTheta = Math.sin(theta) / theta;\n  }\n\n  result.x = cartesian.x * sinThetaOverTheta;\n  result.y = cartesian.y * sinThetaOverTheta;\n  result.z = cartesian.z * sinThetaOverTheta;\n  result.w = Math.cos(theta);\n  return result;\n};\n\nvar squadScratchCartesian0 = new Cartesian3();\nvar squadScratchCartesian1 = new Cartesian3();\nvar squadScratchQuaternion0 = new Quaternion();\nvar squadScratchQuaternion1 = new Quaternion();\n/**\n * Computes an inner quadrangle point.\n * <p>This will compute quaternions that ensure a squad curve is C<sup>1</sup>.</p>\n *\n * @param {Quaternion} q0 The first quaternion.\n * @param {Quaternion} q1 The second quaternion.\n * @param {Quaternion} q2 The third quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n * @see Quaternion#squad\n */\n\nQuaternion.computeInnerQuadrangle = function (q0, q1, q2, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"q0\", q0);\n  Check.typeOf.object(\"q1\", q1);\n  Check.typeOf.object(\"q2\", q2);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var qInv = Quaternion.conjugate(q1, squadScratchQuaternion0);\n  Quaternion.multiply(qInv, q2, squadScratchQuaternion1);\n  var cart0 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian0);\n  Quaternion.multiply(qInv, q0, squadScratchQuaternion1);\n  var cart1 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian1);\n  Cartesian3.add(cart0, cart1, cart0);\n  Cartesian3.multiplyByScalar(cart0, 0.25, cart0);\n  Cartesian3.negate(cart0, cart0);\n  Quaternion.exp(cart0, squadScratchQuaternion0);\n  return Quaternion.multiply(q1, squadScratchQuaternion0, result);\n};\n/**\n * Computes the spherical quadrangle interpolation between quaternions.\n *\n * @param {Quaternion} q0 The first quaternion.\n * @param {Quaternion} q1 The second quaternion.\n * @param {Quaternion} s0 The first inner quadrangle.\n * @param {Quaternion} s1 The second inner quadrangle.\n * @param {Number} t The time in [0,1] used to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n *\n * @example\n * // 1. compute the squad interpolation between two quaternions on a curve\n * var s0 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i - 1], quaternions[i], quaternions[i + 1], new Cesium.Quaternion());\n * var s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i], quaternions[i + 1], quaternions[i + 2], new Cesium.Quaternion());\n * var q = Cesium.Quaternion.squad(quaternions[i], quaternions[i + 1], s0, s1, t, new Cesium.Quaternion());\n *\n * // 2. compute the squad interpolation as above but where the first quaternion is a end point.\n * var s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[0], quaternions[1], quaternions[2], new Cesium.Quaternion());\n * var q = Cesium.Quaternion.squad(quaternions[0], quaternions[1], quaternions[0], s1, t, new Cesium.Quaternion());\n *\n * @see Quaternion#computeInnerQuadrangle\n */\n\n\nQuaternion.squad = function (q0, q1, s0, s1, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"q0\", q0);\n  Check.typeOf.object(\"q1\", q1);\n  Check.typeOf.object(\"s0\", s0);\n  Check.typeOf.object(\"s1\", s1);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var slerp0 = Quaternion.slerp(q0, q1, t, squadScratchQuaternion0);\n  var slerp1 = Quaternion.slerp(s0, s1, t, squadScratchQuaternion1);\n  return Quaternion.slerp(slerp0, slerp1, 2.0 * t * (1.0 - t), result);\n};\n\nvar fastSlerpScratchQuaternion = new Quaternion();\nvar opmu = 1.90110745351730037;\nvar u = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\nvar v = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\nvar bT = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\nvar bD = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\n\nfor (var i = 0; i < 7; ++i) {\n  var s = i + 1.0;\n  var t = 2.0 * s + 1.0;\n  u[i] = 1.0 / (s * t);\n  v[i] = s / t;\n}\n\nu[7] = opmu / (8.0 * 17.0);\nv[7] = opmu * 8.0 / 17.0;\n/**\n * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.\n * This implementation is faster than {@link Quaternion#slerp}, but is only accurate up to 10<sup>-6</sup>.\n *\n * @param {Quaternion} start The value corresponding to t at 0.0.\n * @param {Quaternion} end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n * @see Quaternion#slerp\n */\n\nQuaternion.fastSlerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var x = Quaternion.dot(start, end);\n  var sign;\n\n  if (x >= 0) {\n    sign = 1.0;\n  } else {\n    sign = -1.0;\n    x = -x;\n  }\n\n  var xm1 = x - 1.0;\n  var d = 1.0 - t;\n  var sqrT = t * t;\n  var sqrD = d * d;\n\n  for (var i = 7; i >= 0; --i) {\n    bT[i] = (u[i] * sqrT - v[i]) * xm1;\n    bD[i] = (u[i] * sqrD - v[i]) * xm1;\n  }\n\n  var cT = sign * t * (1.0 + bT[0] * (1.0 + bT[1] * (1.0 + bT[2] * (1.0 + bT[3] * (1.0 + bT[4] * (1.0 + bT[5] * (1.0 + bT[6] * (1.0 + bT[7]))))))));\n  var cD = d * (1.0 + bD[0] * (1.0 + bD[1] * (1.0 + bD[2] * (1.0 + bD[3] * (1.0 + bD[4] * (1.0 + bD[5] * (1.0 + bD[6] * (1.0 + bD[7]))))))));\n  var temp = Quaternion.multiplyByScalar(start, cD, fastSlerpScratchQuaternion);\n  Quaternion.multiplyByScalar(end, cT, result);\n  return Quaternion.add(temp, result, result);\n};\n/**\n * Computes the spherical quadrangle interpolation between quaternions.\n * An implementation that is faster than {@link Quaternion#squad}, but less accurate.\n *\n * @param {Quaternion} q0 The first quaternion.\n * @param {Quaternion} q1 The second quaternion.\n * @param {Quaternion} s0 The first inner quadrangle.\n * @param {Quaternion} s1 The second inner quadrangle.\n * @param {Number} t The time in [0,1] used to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new instance if none was provided.\n *\n * @see Quaternion#squad\n */\n\n\nQuaternion.fastSquad = function (q0, q1, s0, s1, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"q0\", q0);\n  Check.typeOf.object(\"q1\", q1);\n  Check.typeOf.object(\"s0\", s0);\n  Check.typeOf.object(\"s1\", s1);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var slerp0 = Quaternion.fastSlerp(q0, q1, t, squadScratchQuaternion0);\n  var slerp1 = Quaternion.fastSlerp(s0, s1, t, squadScratchQuaternion1);\n  return Quaternion.fastSlerp(slerp0, slerp1, 2.0 * t * (1.0 - t), result);\n};\n/**\n * Compares the provided quaternions componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Quaternion} [left] The first quaternion.\n * @param {Quaternion} [right] The second quaternion.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\n\n\nQuaternion.equals = function (left, right) {\n  return left === right || defined(left) && defined(right) && left.x === right.x && left.y === right.y && left.z === right.z && left.w === right.w;\n};\n/**\n * Compares the provided quaternions componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Quaternion} [left] The first quaternion.\n * @param {Quaternion} [right] The second quaternion.\n * @param {Number} epsilon The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\n\n\nQuaternion.equalsEpsilon = function (left, right, epsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"epsilon\", epsilon); //>>includeEnd('debug');\n\n  return left === right || defined(left) && defined(right) && Math.abs(left.x - right.x) <= epsilon && Math.abs(left.y - right.y) <= epsilon && Math.abs(left.z - right.z) <= epsilon && Math.abs(left.w - right.w) <= epsilon;\n};\n/**\n * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 0.0).\n *\n * @type {Quaternion}\n * @constant\n */\n\n\nQuaternion.ZERO = Object.freeze(new Quaternion(0.0, 0.0, 0.0, 0.0));\n/**\n * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 1.0).\n *\n * @type {Quaternion}\n * @constant\n */\n\nQuaternion.IDENTITY = Object.freeze(new Quaternion(0.0, 0.0, 0.0, 1.0));\n/**\n * Duplicates this Quaternion instance.\n *\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\n\nQuaternion.prototype.clone = function (result) {\n  return Quaternion.clone(this, result);\n};\n/**\n * Compares this and the provided quaternion componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Quaternion} [right] The right hand side quaternion.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\n\n\nQuaternion.prototype.equals = function (right) {\n  return Quaternion.equals(this, right);\n};\n/**\n * Compares this and the provided quaternion componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Quaternion} [right] The right hand side quaternion.\n * @param {Number} epsilon The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\n\n\nQuaternion.prototype.equalsEpsilon = function (right, epsilon) {\n  return Quaternion.equalsEpsilon(this, right, epsilon);\n};\n/**\n * Returns a string representing this quaternion in the format (x, y, z, w).\n *\n * @returns {String} A string representing this Quaternion.\n */\n\n\nQuaternion.prototype.toString = function () {\n  return \"(\" + this.x + \", \" + this.y + \", \" + this.z + \", \" + this.w + \")\";\n};\n\nexport default Quaternion;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/Quaternion.js"],"names":["Cartesian3","Check","defaultValue","defined","FeatureDetection","CesiumMath","Matrix3","Quaternion","x","y","z","w","fromAxisAngleScratch","fromAxisAngle","axis","angle","result","typeOf","object","number","halfAngle","s","Math","sin","normalize","cos","fromRotationMatrixNext","fromRotationMatrixQuat","Array","fromRotationMatrix","matrix","root","m00","COLUMN0ROW0","m11","COLUMN1ROW1","m22","COLUMN2ROW2","trace","sqrt","COLUMN1ROW2","COLUMN2ROW1","COLUMN2ROW0","COLUMN0ROW2","COLUMN0ROW1","COLUMN1ROW0","next","i","j","k","getElementIndex","quat","scratchHPRQuaternion","scratchHeadingQuaternion","scratchPitchQuaternion","scratchRollQuaternion","fromHeadingPitchRoll","headingPitchRoll","UNIT_X","roll","UNIT_Y","pitch","multiply","UNIT_Z","heading","sampledQuaternionAxis","sampledQuaternionRotation","sampledQuaternionTempQuaternion","sampledQuaternionQuaternion0","sampledQuaternionQuaternion0Conjugate","packedLength","pack","value","array","startingIndex","unpack","packedInterpolationLength","convertPackedArrayForInterpolation","packedArray","lastIndex","conjugate","len","offset","negate","computeAxis","computeAngle","unpackInterpolationResult","sourceArray","firstIndex","fromArray","magnitude","clone","IDENTITY","quaternion","undefined","magnitudeSquared","inverseMagnitude","inverse","multiplyByScalar","add","left","right","subtract","dot","leftX","leftY","leftZ","leftW","rightX","rightY","rightZ","rightW","scalar","divideByScalar","abs","EPSILON6","acos","lerpScratch","lerp","start","end","t","slerpEndNegated","slerpScaledP","slerpScaledR","slerp","r","theta","log","acosClamped","thetaOverSinTheta","exp","cartesian","sinThetaOverTheta","squadScratchCartesian0","squadScratchCartesian1","squadScratchQuaternion0","squadScratchQuaternion1","computeInnerQuadrangle","q0","q1","q2","qInv","cart0","cart1","squad","s0","s1","slerp0","slerp1","fastSlerpScratchQuaternion","opmu","u","supportsTypedArrays","Float32Array","v","bT","bD","fastSlerp","sign","xm1","d","sqrT","sqrD","cT","cD","temp","fastSquad","equals","equalsEpsilon","epsilon","ZERO","Object","freeze","prototype","toString"],"mappings":"AAAA,OAAOA,UAAP,MAAuB,iBAAvB;AACA,OAAOC,KAAP,MAAkB,YAAlB;AACA,OAAOC,YAAP,MAAyB,mBAAzB;AACA,OAAOC,OAAP,MAAoB,cAApB;AACA,OAAOC,gBAAP,MAA6B,uBAA7B;AACA,OAAOC,UAAP,MAAuB,WAAvB;AACA,OAAOC,OAAP,MAAoB,cAApB;AAEA;;;;;;;;;;;;;AAYA,SAASC,UAAT,CAAoBC,CAApB,EAAuBC,CAAvB,EAA0BC,CAA1B,EAA6BC,CAA7B,EAAgC;AAC9B;;;;;AAKA,OAAKH,CAAL,GAASN,YAAY,CAACM,CAAD,EAAI,GAAJ,CAArB;AAEA;;;;;;AAKA,OAAKC,CAAL,GAASP,YAAY,CAACO,CAAD,EAAI,GAAJ,CAArB;AAEA;;;;;;AAKA,OAAKC,CAAL,GAASR,YAAY,CAACQ,CAAD,EAAI,GAAJ,CAArB;AAEA;;;;;;AAKA,OAAKC,CAAL,GAAST,YAAY,CAACS,CAAD,EAAI,GAAJ,CAArB;AACD;;AAED,IAAIC,oBAAoB,GAAG,IAAIZ,UAAJ,EAA3B;AAEA;;;;;;;;;AAQAO,UAAU,CAACM,aAAX,GAA2B,UAAUC,IAAV,EAAgBC,KAAhB,EAAuBC,MAAvB,EAA+B;AACxD;AACAf,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,MAApB,EAA4BJ,IAA5B;AACAb,EAAAA,KAAK,CAACgB,MAAN,CAAaE,MAAb,CAAoB,OAApB,EAA6BJ,KAA7B,EAHwD,CAIxD;;AAEA,MAAIK,SAAS,GAAGL,KAAK,GAAG,GAAxB;AACA,MAAIM,CAAC,GAAGC,IAAI,CAACC,GAAL,CAASH,SAAT,CAAR;AACAR,EAAAA,oBAAoB,GAAGZ,UAAU,CAACwB,SAAX,CAAqBV,IAArB,EAA2BF,oBAA3B,CAAvB;AAEA,MAAIJ,CAAC,GAAGI,oBAAoB,CAACJ,CAArB,GAAyBa,CAAjC;AACA,MAAIZ,CAAC,GAAGG,oBAAoB,CAACH,CAArB,GAAyBY,CAAjC;AACA,MAAIX,CAAC,GAAGE,oBAAoB,CAACF,CAArB,GAAyBW,CAAjC;AACA,MAAIV,CAAC,GAAGW,IAAI,CAACG,GAAL,CAASL,SAAT,CAAR;;AACA,MAAI,CAACjB,OAAO,CAACa,MAAD,CAAZ,EAAsB;AACpB,WAAO,IAAIT,UAAJ,CAAeC,CAAf,EAAkBC,CAAlB,EAAqBC,CAArB,EAAwBC,CAAxB,CAAP;AACD;;AACDK,EAAAA,MAAM,CAACR,CAAP,GAAWA,CAAX;AACAQ,EAAAA,MAAM,CAACP,CAAP,GAAWA,CAAX;AACAO,EAAAA,MAAM,CAACN,CAAP,GAAWA,CAAX;AACAM,EAAAA,MAAM,CAACL,CAAP,GAAWA,CAAX;AACA,SAAOK,MAAP;AACD,CAtBD;;AAwBA,IAAIU,sBAAsB,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAA7B;AACA,IAAIC,sBAAsB,GAAG,IAAIC,KAAJ,CAAU,CAAV,CAA7B;AACA;;;;;;;;;;AASArB,UAAU,CAACsB,kBAAX,GAAgC,UAAUC,MAAV,EAAkBd,MAAlB,EAA0B;AACxD;AACAf,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BY,MAA9B,EAFwD,CAGxD;;AAEA,MAAIC,IAAJ;AACA,MAAIvB,CAAJ;AACA,MAAIC,CAAJ;AACA,MAAIC,CAAJ;AACA,MAAIC,CAAJ;AAEA,MAAIqB,GAAG,GAAGF,MAAM,CAACxB,OAAO,CAAC2B,WAAT,CAAhB;AACA,MAAIC,GAAG,GAAGJ,MAAM,CAACxB,OAAO,CAAC6B,WAAT,CAAhB;AACA,MAAIC,GAAG,GAAGN,MAAM,CAACxB,OAAO,CAAC+B,WAAT,CAAhB;AACA,MAAIC,KAAK,GAAGN,GAAG,GAAGE,GAAN,GAAYE,GAAxB;;AAEA,MAAIE,KAAK,GAAG,GAAZ,EAAiB;AACf;AACAP,IAAAA,IAAI,GAAGT,IAAI,CAACiB,IAAL,CAAUD,KAAK,GAAG,GAAlB,CAAP,CAFe,CAEgB;;AAC/B3B,IAAAA,CAAC,GAAG,MAAMoB,IAAV;AACAA,IAAAA,IAAI,GAAG,MAAMA,IAAb,CAJe,CAII;;AAEnBvB,IAAAA,CAAC,GAAG,CAACsB,MAAM,CAACxB,OAAO,CAACkC,WAAT,CAAN,GAA8BV,MAAM,CAACxB,OAAO,CAACmC,WAAT,CAArC,IAA8DV,IAAlE;AACAtB,IAAAA,CAAC,GAAG,CAACqB,MAAM,CAACxB,OAAO,CAACoC,WAAT,CAAN,GAA8BZ,MAAM,CAACxB,OAAO,CAACqC,WAAT,CAArC,IAA8DZ,IAAlE;AACArB,IAAAA,CAAC,GAAG,CAACoB,MAAM,CAACxB,OAAO,CAACsC,WAAT,CAAN,GAA8Bd,MAAM,CAACxB,OAAO,CAACuC,WAAT,CAArC,IAA8Dd,IAAlE;AACD,GATD,MASO;AACL;AACA,QAAIe,IAAI,GAAGpB,sBAAX;AAEA,QAAIqB,CAAC,GAAG,CAAR;;AACA,QAAIb,GAAG,GAAGF,GAAV,EAAe;AACbe,MAAAA,CAAC,GAAG,CAAJ;AACD;;AACD,QAAIX,GAAG,GAAGJ,GAAN,IAAaI,GAAG,GAAGF,GAAvB,EAA4B;AAC1Ba,MAAAA,CAAC,GAAG,CAAJ;AACD;;AACD,QAAIC,CAAC,GAAGF,IAAI,CAACC,CAAD,CAAZ;AACA,QAAIE,CAAC,GAAGH,IAAI,CAACE,CAAD,CAAZ;AAEAjB,IAAAA,IAAI,GAAGT,IAAI,CAACiB,IAAL,CACLT,MAAM,CAACxB,OAAO,CAAC4C,eAAR,CAAwBH,CAAxB,EAA2BA,CAA3B,CAAD,CAAN,GACEjB,MAAM,CAACxB,OAAO,CAAC4C,eAAR,CAAwBF,CAAxB,EAA2BA,CAA3B,CAAD,CADR,GAEElB,MAAM,CAACxB,OAAO,CAAC4C,eAAR,CAAwBD,CAAxB,EAA2BA,CAA3B,CAAD,CAFR,GAGE,GAJG,CAAP;AAOA,QAAIE,IAAI,GAAGxB,sBAAX;AACAwB,IAAAA,IAAI,CAACJ,CAAD,CAAJ,GAAU,MAAMhB,IAAhB;AACAA,IAAAA,IAAI,GAAG,MAAMA,IAAb;AACApB,IAAAA,CAAC,GACC,CAACmB,MAAM,CAACxB,OAAO,CAAC4C,eAAR,CAAwBD,CAAxB,EAA2BD,CAA3B,CAAD,CAAN,GACClB,MAAM,CAACxB,OAAO,CAAC4C,eAAR,CAAwBF,CAAxB,EAA2BC,CAA3B,CAAD,CADR,IAEAlB,IAHF;AAIAoB,IAAAA,IAAI,CAACH,CAAD,CAAJ,GACE,CAAClB,MAAM,CAACxB,OAAO,CAAC4C,eAAR,CAAwBF,CAAxB,EAA2BD,CAA3B,CAAD,CAAN,GACCjB,MAAM,CAACxB,OAAO,CAAC4C,eAAR,CAAwBH,CAAxB,EAA2BC,CAA3B,CAAD,CADR,IAEAjB,IAHF;AAIAoB,IAAAA,IAAI,CAACF,CAAD,CAAJ,GACE,CAACnB,MAAM,CAACxB,OAAO,CAAC4C,eAAR,CAAwBD,CAAxB,EAA2BF,CAA3B,CAAD,CAAN,GACCjB,MAAM,CAACxB,OAAO,CAAC4C,eAAR,CAAwBH,CAAxB,EAA2BE,CAA3B,CAAD,CADR,IAEAlB,IAHF;AAKAvB,IAAAA,CAAC,GAAG,CAAC2C,IAAI,CAAC,CAAD,CAAT;AACA1C,IAAAA,CAAC,GAAG,CAAC0C,IAAI,CAAC,CAAD,CAAT;AACAzC,IAAAA,CAAC,GAAG,CAACyC,IAAI,CAAC,CAAD,CAAT;AACD;;AAED,MAAI,CAAChD,OAAO,CAACa,MAAD,CAAZ,EAAsB;AACpB,WAAO,IAAIT,UAAJ,CAAeC,CAAf,EAAkBC,CAAlB,EAAqBC,CAArB,EAAwBC,CAAxB,CAAP;AACD;;AACDK,EAAAA,MAAM,CAACR,CAAP,GAAWA,CAAX;AACAQ,EAAAA,MAAM,CAACP,CAAP,GAAWA,CAAX;AACAO,EAAAA,MAAM,CAACN,CAAP,GAAWA,CAAX;AACAM,EAAAA,MAAM,CAACL,CAAP,GAAWA,CAAX;AACA,SAAOK,MAAP;AACD,CA3ED;;AA6EA,IAAIoC,oBAAoB,GAAG,IAAI7C,UAAJ,EAA3B;AACA,IAAI8C,wBAAwB,GAAG,IAAI9C,UAAJ,EAA/B;AACA,IAAI+C,sBAAsB,GAAG,IAAI/C,UAAJ,EAA7B;AACA,IAAIgD,qBAAqB,GAAG,IAAIhD,UAAJ,EAA5B;AAEA;;;;;;;;;;AASAA,UAAU,CAACiD,oBAAX,GAAkC,UAAUC,gBAAV,EAA4BzC,MAA5B,EAAoC;AACpE;AACAf,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,kBAApB,EAAwCuC,gBAAxC,EAFoE,CAGpE;;AAEAF,EAAAA,qBAAqB,GAAGhD,UAAU,CAACM,aAAX,CACtBb,UAAU,CAAC0D,MADW,EAEtBD,gBAAgB,CAACE,IAFK,EAGtBP,oBAHsB,CAAxB;AAKAE,EAAAA,sBAAsB,GAAG/C,UAAU,CAACM,aAAX,CACvBb,UAAU,CAAC4D,MADY,EAEvB,CAACH,gBAAgB,CAACI,KAFK,EAGvB7C,MAHuB,CAAzB;AAKAA,EAAAA,MAAM,GAAGT,UAAU,CAACuD,QAAX,CACPR,sBADO,EAEPC,qBAFO,EAGPD,sBAHO,CAAT;AAKAD,EAAAA,wBAAwB,GAAG9C,UAAU,CAACM,aAAX,CACzBb,UAAU,CAAC+D,MADc,EAEzB,CAACN,gBAAgB,CAACO,OAFO,EAGzBZ,oBAHyB,CAA3B;AAKA,SAAO7C,UAAU,CAACuD,QAAX,CAAoBT,wBAApB,EAA8CrC,MAA9C,EAAsDA,MAAtD,CAAP;AACD,CA1BD;;AA4BA,IAAIiD,qBAAqB,GAAG,IAAIjE,UAAJ,EAA5B;AACA,IAAIkE,yBAAyB,GAAG,IAAIlE,UAAJ,EAAhC;AACA,IAAImE,+BAA+B,GAAG,IAAI5D,UAAJ,EAAtC;AACA,IAAI6D,4BAA4B,GAAG,IAAI7D,UAAJ,EAAnC;AACA,IAAI8D,qCAAqC,GAAG,IAAI9D,UAAJ,EAA5C;AAEA;;;;;AAIAA,UAAU,CAAC+D,YAAX,GAA0B,CAA1B;AAEA;;;;;;;;;;AASA/D,UAAU,CAACgE,IAAX,GAAkB,UAAUC,KAAV,EAAiBC,KAAjB,EAAwBC,aAAxB,EAAuC;AACvD;AACAzE,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,OAApB,EAA6BsD,KAA7B;AACAvE,EAAAA,KAAK,CAACE,OAAN,CAAc,OAAd,EAAuBsE,KAAvB,EAHuD,CAIvD;;AAEAC,EAAAA,aAAa,GAAGxE,YAAY,CAACwE,aAAD,EAAgB,CAAhB,CAA5B;AAEAD,EAAAA,KAAK,CAACC,aAAa,EAAd,CAAL,GAAyBF,KAAK,CAAChE,CAA/B;AACAiE,EAAAA,KAAK,CAACC,aAAa,EAAd,CAAL,GAAyBF,KAAK,CAAC/D,CAA/B;AACAgE,EAAAA,KAAK,CAACC,aAAa,EAAd,CAAL,GAAyBF,KAAK,CAAC9D,CAA/B;AACA+D,EAAAA,KAAK,CAACC,aAAD,CAAL,GAAuBF,KAAK,CAAC7D,CAA7B;AAEA,SAAO8D,KAAP;AACD,CAdD;AAgBA;;;;;;;;;;AAQAlE,UAAU,CAACoE,MAAX,GAAoB,UAAUF,KAAV,EAAiBC,aAAjB,EAAgC1D,MAAhC,EAAwC;AAC1D;AACAf,EAAAA,KAAK,CAACE,OAAN,CAAc,OAAd,EAAuBsE,KAAvB,EAF0D,CAG1D;;AAEAC,EAAAA,aAAa,GAAGxE,YAAY,CAACwE,aAAD,EAAgB,CAAhB,CAA5B;;AAEA,MAAI,CAACvE,OAAO,CAACa,MAAD,CAAZ,EAAsB;AACpBA,IAAAA,MAAM,GAAG,IAAIT,UAAJ,EAAT;AACD;;AACDS,EAAAA,MAAM,CAACR,CAAP,GAAWiE,KAAK,CAACC,aAAD,CAAhB;AACA1D,EAAAA,MAAM,CAACP,CAAP,GAAWgE,KAAK,CAACC,aAAa,GAAG,CAAjB,CAAhB;AACA1D,EAAAA,MAAM,CAACN,CAAP,GAAW+D,KAAK,CAACC,aAAa,GAAG,CAAjB,CAAhB;AACA1D,EAAAA,MAAM,CAACL,CAAP,GAAW8D,KAAK,CAACC,aAAa,GAAG,CAAjB,CAAhB;AACA,SAAO1D,MAAP;AACD,CAfD;AAiBA;;;;;;AAIAT,UAAU,CAACqE,yBAAX,GAAuC,CAAvC;AAEA;;;;;;;;;AAQArE,UAAU,CAACsE,kCAAX,GAAgD,UAC9CC,WAD8C,EAE9CJ,aAF8C,EAG9CK,SAH8C,EAI9C/D,MAJ8C,EAK9C;AACAT,EAAAA,UAAU,CAACoE,MAAX,CACEG,WADF,EAEEC,SAAS,GAAG,CAFd,EAGEV,qCAHF;AAKA9D,EAAAA,UAAU,CAACyE,SAAX,CACEX,qCADF,EAEEA,qCAFF;;AAKA,OAAK,IAAItB,CAAC,GAAG,CAAR,EAAWkC,GAAG,GAAGF,SAAS,GAAGL,aAAZ,GAA4B,CAAlD,EAAqD3B,CAAC,GAAGkC,GAAzD,EAA8DlC,CAAC,EAA/D,EAAmE;AACjE,QAAImC,MAAM,GAAGnC,CAAC,GAAG,CAAjB;AACAxC,IAAAA,UAAU,CAACoE,MAAX,CACEG,WADF,EAEE,CAACJ,aAAa,GAAG3B,CAAjB,IAAsB,CAFxB,EAGEoB,+BAHF;AAMA5D,IAAAA,UAAU,CAACuD,QAAX,CACEK,+BADF,EAEEE,qCAFF,EAGEF,+BAHF;;AAMA,QAAIA,+BAA+B,CAACxD,CAAhC,GAAoC,CAAxC,EAA2C;AACzCJ,MAAAA,UAAU,CAAC4E,MAAX,CACEhB,+BADF,EAEEA,+BAFF;AAID;;AAED5D,IAAAA,UAAU,CAAC6E,WAAX,CACEjB,+BADF,EAEEF,qBAFF;AAIA,QAAIlD,KAAK,GAAGR,UAAU,CAAC8E,YAAX,CAAwBlB,+BAAxB,CAAZ;AACAnD,IAAAA,MAAM,CAACkE,MAAD,CAAN,GAAiBjB,qBAAqB,CAACzD,CAAtB,GAA0BO,KAA3C;AACAC,IAAAA,MAAM,CAACkE,MAAM,GAAG,CAAV,CAAN,GAAqBjB,qBAAqB,CAACxD,CAAtB,GAA0BM,KAA/C;AACAC,IAAAA,MAAM,CAACkE,MAAM,GAAG,CAAV,CAAN,GAAqBjB,qBAAqB,CAACvD,CAAtB,GAA0BK,KAA/C;AACD;AACF,CA9CD;AAgDA;;;;;;;;;;;;AAUAR,UAAU,CAAC+E,yBAAX,GAAuC,UACrCb,KADqC,EAErCc,WAFqC,EAGrCC,UAHqC,EAIrCT,SAJqC,EAKrC/D,MALqC,EAMrC;AACA,MAAI,CAACb,OAAO,CAACa,MAAD,CAAZ,EAAsB;AACpBA,IAAAA,MAAM,GAAG,IAAIT,UAAJ,EAAT;AACD;;AACDP,EAAAA,UAAU,CAACyF,SAAX,CAAqBhB,KAArB,EAA4B,CAA5B,EAA+BP,yBAA/B;AACA,MAAIwB,SAAS,GAAG1F,UAAU,CAAC0F,SAAX,CAAqBxB,yBAArB,CAAhB;AAEA3D,EAAAA,UAAU,CAACoE,MAAX,CAAkBY,WAAlB,EAA+BR,SAAS,GAAG,CAA3C,EAA8CX,4BAA9C;;AAEA,MAAIsB,SAAS,KAAK,CAAlB,EAAqB;AACnBnF,IAAAA,UAAU,CAACoF,KAAX,CAAiBpF,UAAU,CAACqF,QAA5B,EAAsCzB,+BAAtC;AACD,GAFD,MAEO;AACL5D,IAAAA,UAAU,CAACM,aAAX,CACEqD,yBADF,EAEEwB,SAFF,EAGEvB,+BAHF;AAKD;;AAED,SAAO5D,UAAU,CAACuD,QAAX,CACLK,+BADK,EAELC,4BAFK,EAGLpD,MAHK,CAAP;AAKD,CA9BD;AAgCA;;;;;;;;;AAOAT,UAAU,CAACoF,KAAX,GAAmB,UAAUE,UAAV,EAAsB7E,MAAtB,EAA8B;AAC/C,MAAI,CAACb,OAAO,CAAC0F,UAAD,CAAZ,EAA0B;AACxB,WAAOC,SAAP;AACD;;AAED,MAAI,CAAC3F,OAAO,CAACa,MAAD,CAAZ,EAAsB;AACpB,WAAO,IAAIT,UAAJ,CACLsF,UAAU,CAACrF,CADN,EAELqF,UAAU,CAACpF,CAFN,EAGLoF,UAAU,CAACnF,CAHN,EAILmF,UAAU,CAAClF,CAJN,CAAP;AAMD;;AAEDK,EAAAA,MAAM,CAACR,CAAP,GAAWqF,UAAU,CAACrF,CAAtB;AACAQ,EAAAA,MAAM,CAACP,CAAP,GAAWoF,UAAU,CAACpF,CAAtB;AACAO,EAAAA,MAAM,CAACN,CAAP,GAAWmF,UAAU,CAACnF,CAAtB;AACAM,EAAAA,MAAM,CAACL,CAAP,GAAWkF,UAAU,CAAClF,CAAtB;AACA,SAAOK,MAAP;AACD,CAnBD;AAqBA;;;;;;;;;AAOAT,UAAU,CAACyE,SAAX,GAAuB,UAAUa,UAAV,EAAsB7E,MAAtB,EAA8B;AACnD;AACAf,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,YAApB,EAAkC2E,UAAlC;AACA5F,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BF,MAA9B,EAHmD,CAInD;;AAEAA,EAAAA,MAAM,CAACR,CAAP,GAAW,CAACqF,UAAU,CAACrF,CAAvB;AACAQ,EAAAA,MAAM,CAACP,CAAP,GAAW,CAACoF,UAAU,CAACpF,CAAvB;AACAO,EAAAA,MAAM,CAACN,CAAP,GAAW,CAACmF,UAAU,CAACnF,CAAvB;AACAM,EAAAA,MAAM,CAACL,CAAP,GAAWkF,UAAU,CAAClF,CAAtB;AACA,SAAOK,MAAP;AACD,CAXD;AAaA;;;;;;;;AAMAT,UAAU,CAACwF,gBAAX,GAA8B,UAAUF,UAAV,EAAsB;AAClD;AACA5F,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,YAApB,EAAkC2E,UAAlC,EAFkD,CAGlD;;AAEA,SACEA,UAAU,CAACrF,CAAX,GAAeqF,UAAU,CAACrF,CAA1B,GACAqF,UAAU,CAACpF,CAAX,GAAeoF,UAAU,CAACpF,CAD1B,GAEAoF,UAAU,CAACnF,CAAX,GAAemF,UAAU,CAACnF,CAF1B,GAGAmF,UAAU,CAAClF,CAAX,GAAekF,UAAU,CAAClF,CAJ5B;AAMD,CAXD;AAaA;;;;;;;;AAMAJ,UAAU,CAACmF,SAAX,GAAuB,UAAUG,UAAV,EAAsB;AAC3C,SAAOvE,IAAI,CAACiB,IAAL,CAAUhC,UAAU,CAACwF,gBAAX,CAA4BF,UAA5B,CAAV,CAAP;AACD,CAFD;AAIA;;;;;;;;;AAOAtF,UAAU,CAACiB,SAAX,GAAuB,UAAUqE,UAAV,EAAsB7E,MAAtB,EAA8B;AACnD;AACAf,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BF,MAA9B,EAFmD,CAGnD;;AAEA,MAAIgF,gBAAgB,GAAG,MAAMzF,UAAU,CAACmF,SAAX,CAAqBG,UAArB,CAA7B;AACA,MAAIrF,CAAC,GAAGqF,UAAU,CAACrF,CAAX,GAAewF,gBAAvB;AACA,MAAIvF,CAAC,GAAGoF,UAAU,CAACpF,CAAX,GAAeuF,gBAAvB;AACA,MAAItF,CAAC,GAAGmF,UAAU,CAACnF,CAAX,GAAesF,gBAAvB;AACA,MAAIrF,CAAC,GAAGkF,UAAU,CAAClF,CAAX,GAAeqF,gBAAvB;AAEAhF,EAAAA,MAAM,CAACR,CAAP,GAAWA,CAAX;AACAQ,EAAAA,MAAM,CAACP,CAAP,GAAWA,CAAX;AACAO,EAAAA,MAAM,CAACN,CAAP,GAAWA,CAAX;AACAM,EAAAA,MAAM,CAACL,CAAP,GAAWA,CAAX;AACA,SAAOK,MAAP;AACD,CAhBD;AAkBA;;;;;;;;;AAOAT,UAAU,CAAC0F,OAAX,GAAqB,UAAUJ,UAAV,EAAsB7E,MAAtB,EAA8B;AACjD;AACAf,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BF,MAA9B,EAFiD,CAGjD;;AAEA,MAAI+E,gBAAgB,GAAGxF,UAAU,CAACwF,gBAAX,CAA4BF,UAA5B,CAAvB;AACA7E,EAAAA,MAAM,GAAGT,UAAU,CAACyE,SAAX,CAAqBa,UAArB,EAAiC7E,MAAjC,CAAT;AACA,SAAOT,UAAU,CAAC2F,gBAAX,CAA4BlF,MAA5B,EAAoC,MAAM+E,gBAA1C,EAA4D/E,MAA5D,CAAP;AACD,CARD;AAUA;;;;;;;;;;AAQAT,UAAU,CAAC4F,GAAX,GAAiB,UAAUC,IAAV,EAAgBC,KAAhB,EAAuBrF,MAAvB,EAA+B;AAC9C;AACAf,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,MAApB,EAA4BkF,IAA5B;AACAnG,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,OAApB,EAA6BmF,KAA7B;AACApG,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BF,MAA9B,EAJ8C,CAK9C;;AAEAA,EAAAA,MAAM,CAACR,CAAP,GAAW4F,IAAI,CAAC5F,CAAL,GAAS6F,KAAK,CAAC7F,CAA1B;AACAQ,EAAAA,MAAM,CAACP,CAAP,GAAW2F,IAAI,CAAC3F,CAAL,GAAS4F,KAAK,CAAC5F,CAA1B;AACAO,EAAAA,MAAM,CAACN,CAAP,GAAW0F,IAAI,CAAC1F,CAAL,GAAS2F,KAAK,CAAC3F,CAA1B;AACAM,EAAAA,MAAM,CAACL,CAAP,GAAWyF,IAAI,CAACzF,CAAL,GAAS0F,KAAK,CAAC1F,CAA1B;AACA,SAAOK,MAAP;AACD,CAZD;AAcA;;;;;;;;;;AAQAT,UAAU,CAAC+F,QAAX,GAAsB,UAAUF,IAAV,EAAgBC,KAAhB,EAAuBrF,MAAvB,EAA+B;AACnD;AACAf,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,MAApB,EAA4BkF,IAA5B;AACAnG,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,OAApB,EAA6BmF,KAA7B;AACApG,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BF,MAA9B,EAJmD,CAKnD;;AAEAA,EAAAA,MAAM,CAACR,CAAP,GAAW4F,IAAI,CAAC5F,CAAL,GAAS6F,KAAK,CAAC7F,CAA1B;AACAQ,EAAAA,MAAM,CAACP,CAAP,GAAW2F,IAAI,CAAC3F,CAAL,GAAS4F,KAAK,CAAC5F,CAA1B;AACAO,EAAAA,MAAM,CAACN,CAAP,GAAW0F,IAAI,CAAC1F,CAAL,GAAS2F,KAAK,CAAC3F,CAA1B;AACAM,EAAAA,MAAM,CAACL,CAAP,GAAWyF,IAAI,CAACzF,CAAL,GAAS0F,KAAK,CAAC1F,CAA1B;AACA,SAAOK,MAAP;AACD,CAZD;AAcA;;;;;;;;;AAOAT,UAAU,CAAC4E,MAAX,GAAoB,UAAUU,UAAV,EAAsB7E,MAAtB,EAA8B;AAChD;AACAf,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,YAApB,EAAkC2E,UAAlC;AACA5F,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BF,MAA9B,EAHgD,CAIhD;;AAEAA,EAAAA,MAAM,CAACR,CAAP,GAAW,CAACqF,UAAU,CAACrF,CAAvB;AACAQ,EAAAA,MAAM,CAACP,CAAP,GAAW,CAACoF,UAAU,CAACpF,CAAvB;AACAO,EAAAA,MAAM,CAACN,CAAP,GAAW,CAACmF,UAAU,CAACnF,CAAvB;AACAM,EAAAA,MAAM,CAACL,CAAP,GAAW,CAACkF,UAAU,CAAClF,CAAvB;AACA,SAAOK,MAAP;AACD,CAXD;AAaA;;;;;;;;;AAOAT,UAAU,CAACgG,GAAX,GAAiB,UAAUH,IAAV,EAAgBC,KAAhB,EAAuB;AACtC;AACApG,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,MAApB,EAA4BkF,IAA5B;AACAnG,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,OAApB,EAA6BmF,KAA7B,EAHsC,CAItC;;AAEA,SACED,IAAI,CAAC5F,CAAL,GAAS6F,KAAK,CAAC7F,CAAf,GAAmB4F,IAAI,CAAC3F,CAAL,GAAS4F,KAAK,CAAC5F,CAAlC,GAAsC2F,IAAI,CAAC1F,CAAL,GAAS2F,KAAK,CAAC3F,CAArD,GAAyD0F,IAAI,CAACzF,CAAL,GAAS0F,KAAK,CAAC1F,CAD1E;AAGD,CATD;AAWA;;;;;;;;;;AAQAJ,UAAU,CAACuD,QAAX,GAAsB,UAAUsC,IAAV,EAAgBC,KAAhB,EAAuBrF,MAAvB,EAA+B;AACnD;AACAf,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,MAApB,EAA4BkF,IAA5B;AACAnG,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,OAApB,EAA6BmF,KAA7B;AACApG,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BF,MAA9B,EAJmD,CAKnD;;AAEA,MAAIwF,KAAK,GAAGJ,IAAI,CAAC5F,CAAjB;AACA,MAAIiG,KAAK,GAAGL,IAAI,CAAC3F,CAAjB;AACA,MAAIiG,KAAK,GAAGN,IAAI,CAAC1F,CAAjB;AACA,MAAIiG,KAAK,GAAGP,IAAI,CAACzF,CAAjB;AAEA,MAAIiG,MAAM,GAAGP,KAAK,CAAC7F,CAAnB;AACA,MAAIqG,MAAM,GAAGR,KAAK,CAAC5F,CAAnB;AACA,MAAIqG,MAAM,GAAGT,KAAK,CAAC3F,CAAnB;AACA,MAAIqG,MAAM,GAAGV,KAAK,CAAC1F,CAAnB;AAEA,MAAIH,CAAC,GAAGmG,KAAK,GAAGC,MAAR,GAAiBJ,KAAK,GAAGO,MAAzB,GAAkCN,KAAK,GAAGK,MAA1C,GAAmDJ,KAAK,GAAGG,MAAnE;AACA,MAAIpG,CAAC,GAAGkG,KAAK,GAAGE,MAAR,GAAiBL,KAAK,GAAGM,MAAzB,GAAkCL,KAAK,GAAGM,MAA1C,GAAmDL,KAAK,GAAGE,MAAnE;AACA,MAAIlG,CAAC,GAAGiG,KAAK,GAAGG,MAAR,GAAiBN,KAAK,GAAGK,MAAzB,GAAkCJ,KAAK,GAAGG,MAA1C,GAAmDF,KAAK,GAAGK,MAAnE;AACA,MAAIpG,CAAC,GAAGgG,KAAK,GAAGI,MAAR,GAAiBP,KAAK,GAAGI,MAAzB,GAAkCH,KAAK,GAAGI,MAA1C,GAAmDH,KAAK,GAAGI,MAAnE;AAEA9F,EAAAA,MAAM,CAACR,CAAP,GAAWA,CAAX;AACAQ,EAAAA,MAAM,CAACP,CAAP,GAAWA,CAAX;AACAO,EAAAA,MAAM,CAACN,CAAP,GAAWA,CAAX;AACAM,EAAAA,MAAM,CAACL,CAAP,GAAWA,CAAX;AACA,SAAOK,MAAP;AACD,CA3BD;AA6BA;;;;;;;;;;AAQAT,UAAU,CAAC2F,gBAAX,GAA8B,UAAUL,UAAV,EAAsBmB,MAAtB,EAA8BhG,MAA9B,EAAsC;AAClE;AACAf,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,YAApB,EAAkC2E,UAAlC;AACA5F,EAAAA,KAAK,CAACgB,MAAN,CAAaE,MAAb,CAAoB,QAApB,EAA8B6F,MAA9B;AACA/G,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BF,MAA9B,EAJkE,CAKlE;;AAEAA,EAAAA,MAAM,CAACR,CAAP,GAAWqF,UAAU,CAACrF,CAAX,GAAewG,MAA1B;AACAhG,EAAAA,MAAM,CAACP,CAAP,GAAWoF,UAAU,CAACpF,CAAX,GAAeuG,MAA1B;AACAhG,EAAAA,MAAM,CAACN,CAAP,GAAWmF,UAAU,CAACnF,CAAX,GAAesG,MAA1B;AACAhG,EAAAA,MAAM,CAACL,CAAP,GAAWkF,UAAU,CAAClF,CAAX,GAAeqG,MAA1B;AACA,SAAOhG,MAAP;AACD,CAZD;AAcA;;;;;;;;;;AAQAT,UAAU,CAAC0G,cAAX,GAA4B,UAAUpB,UAAV,EAAsBmB,MAAtB,EAA8BhG,MAA9B,EAAsC;AAChE;AACAf,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,YAApB,EAAkC2E,UAAlC;AACA5F,EAAAA,KAAK,CAACgB,MAAN,CAAaE,MAAb,CAAoB,QAApB,EAA8B6F,MAA9B;AACA/G,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BF,MAA9B,EAJgE,CAKhE;;AAEAA,EAAAA,MAAM,CAACR,CAAP,GAAWqF,UAAU,CAACrF,CAAX,GAAewG,MAA1B;AACAhG,EAAAA,MAAM,CAACP,CAAP,GAAWoF,UAAU,CAACpF,CAAX,GAAeuG,MAA1B;AACAhG,EAAAA,MAAM,CAACN,CAAP,GAAWmF,UAAU,CAACnF,CAAX,GAAesG,MAA1B;AACAhG,EAAAA,MAAM,CAACL,CAAP,GAAWkF,UAAU,CAAClF,CAAX,GAAeqG,MAA1B;AACA,SAAOhG,MAAP;AACD,CAZD;AAcA;;;;;;;;;AAOAT,UAAU,CAAC6E,WAAX,GAAyB,UAAUS,UAAV,EAAsB7E,MAAtB,EAA8B;AACrD;AACAf,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,YAApB,EAAkC2E,UAAlC;AACA5F,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BF,MAA9B,EAHqD,CAIrD;;AAEA,MAAIL,CAAC,GAAGkF,UAAU,CAAClF,CAAnB;;AACA,MAAIW,IAAI,CAAC4F,GAAL,CAASvG,CAAC,GAAG,GAAb,IAAoBN,UAAU,CAAC8G,QAAnC,EAA6C;AAC3CnG,IAAAA,MAAM,CAACR,CAAP,GAAWQ,MAAM,CAACP,CAAP,GAAWO,MAAM,CAACN,CAAP,GAAW,CAAjC;AACA,WAAOM,MAAP;AACD;;AAED,MAAIgG,MAAM,GAAG,MAAM1F,IAAI,CAACiB,IAAL,CAAU,MAAM5B,CAAC,GAAGA,CAApB,CAAnB;AAEAK,EAAAA,MAAM,CAACR,CAAP,GAAWqF,UAAU,CAACrF,CAAX,GAAewG,MAA1B;AACAhG,EAAAA,MAAM,CAACP,CAAP,GAAWoF,UAAU,CAACpF,CAAX,GAAeuG,MAA1B;AACAhG,EAAAA,MAAM,CAACN,CAAP,GAAWmF,UAAU,CAACnF,CAAX,GAAesG,MAA1B;AACA,SAAOhG,MAAP;AACD,CAlBD;AAoBA;;;;;;;;AAMAT,UAAU,CAAC8E,YAAX,GAA0B,UAAUQ,UAAV,EAAsB;AAC9C;AACA5F,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,YAApB,EAAkC2E,UAAlC,EAF8C,CAG9C;;AAEA,MAAIvE,IAAI,CAAC4F,GAAL,CAASrB,UAAU,CAAClF,CAAX,GAAe,GAAxB,IAA+BN,UAAU,CAAC8G,QAA9C,EAAwD;AACtD,WAAO,GAAP;AACD;;AACD,SAAO,MAAM7F,IAAI,CAAC8F,IAAL,CAAUvB,UAAU,CAAClF,CAArB,CAAb;AACD,CATD;;AAWA,IAAI0G,WAAW,GAAG,IAAI9G,UAAJ,EAAlB;AACA;;;;;;;;;;AASAA,UAAU,CAAC+G,IAAX,GAAkB,UAAUC,KAAV,EAAiBC,GAAjB,EAAsBC,CAAtB,EAAyBzG,MAAzB,EAAiC;AACjD;AACAf,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,OAApB,EAA6BqG,KAA7B;AACAtH,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,KAApB,EAA2BsG,GAA3B;AACAvH,EAAAA,KAAK,CAACgB,MAAN,CAAaE,MAAb,CAAoB,GAApB,EAAyBsG,CAAzB;AACAxH,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BF,MAA9B,EALiD,CAMjD;;AAEAqG,EAAAA,WAAW,GAAG9G,UAAU,CAAC2F,gBAAX,CAA4BsB,GAA5B,EAAiCC,CAAjC,EAAoCJ,WAApC,CAAd;AACArG,EAAAA,MAAM,GAAGT,UAAU,CAAC2F,gBAAX,CAA4BqB,KAA5B,EAAmC,MAAME,CAAzC,EAA4CzG,MAA5C,CAAT;AACA,SAAOT,UAAU,CAAC4F,GAAX,CAAekB,WAAf,EAA4BrG,MAA5B,EAAoCA,MAApC,CAAP;AACD,CAXD;;AAaA,IAAI0G,eAAe,GAAG,IAAInH,UAAJ,EAAtB;AACA,IAAIoH,YAAY,GAAG,IAAIpH,UAAJ,EAAnB;AACA,IAAIqH,YAAY,GAAG,IAAIrH,UAAJ,EAAnB;AACA;;;;;;;;;;;;AAWAA,UAAU,CAACsH,KAAX,GAAmB,UAAUN,KAAV,EAAiBC,GAAjB,EAAsBC,CAAtB,EAAyBzG,MAAzB,EAAiC;AAClD;AACAf,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,OAApB,EAA6BqG,KAA7B;AACAtH,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,KAApB,EAA2BsG,GAA3B;AACAvH,EAAAA,KAAK,CAACgB,MAAN,CAAaE,MAAb,CAAoB,GAApB,EAAyBsG,CAAzB;AACAxH,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BF,MAA9B,EALkD,CAMlD;;AAEA,MAAIuF,GAAG,GAAGhG,UAAU,CAACgG,GAAX,CAAegB,KAAf,EAAsBC,GAAtB,CAAV,CARkD,CAUlD;AACA;;AACA,MAAIM,CAAC,GAAGN,GAAR;;AACA,MAAIjB,GAAG,GAAG,GAAV,EAAe;AACbA,IAAAA,GAAG,GAAG,CAACA,GAAP;AACAuB,IAAAA,CAAC,GAAGJ,eAAe,GAAGnH,UAAU,CAAC4E,MAAX,CAAkBqC,GAAlB,EAAuBE,eAAvB,CAAtB;AACD,GAhBiD,CAkBlD;AACA;;;AACA,MAAI,MAAMnB,GAAN,GAAYlG,UAAU,CAAC8G,QAA3B,EAAqC;AACnC,WAAO5G,UAAU,CAAC+G,IAAX,CAAgBC,KAAhB,EAAuBO,CAAvB,EAA0BL,CAA1B,EAA6BzG,MAA7B,CAAP;AACD;;AAED,MAAI+G,KAAK,GAAGzG,IAAI,CAAC8F,IAAL,CAAUb,GAAV,CAAZ;AACAoB,EAAAA,YAAY,GAAGpH,UAAU,CAAC2F,gBAAX,CACbqB,KADa,EAEbjG,IAAI,CAACC,GAAL,CAAS,CAAC,IAAIkG,CAAL,IAAUM,KAAnB,CAFa,EAGbJ,YAHa,CAAf;AAKAC,EAAAA,YAAY,GAAGrH,UAAU,CAAC2F,gBAAX,CACb4B,CADa,EAEbxG,IAAI,CAACC,GAAL,CAASkG,CAAC,GAAGM,KAAb,CAFa,EAGbH,YAHa,CAAf;AAKA5G,EAAAA,MAAM,GAAGT,UAAU,CAAC4F,GAAX,CAAewB,YAAf,EAA6BC,YAA7B,EAA2C5G,MAA3C,CAAT;AACA,SAAOT,UAAU,CAAC2F,gBAAX,CAA4BlF,MAA5B,EAAoC,MAAMM,IAAI,CAACC,GAAL,CAASwG,KAAT,CAA1C,EAA2D/G,MAA3D,CAAP;AACD,CArCD;AAuCA;;;;;;;;;AAOAT,UAAU,CAACyH,GAAX,GAAiB,UAAUnC,UAAV,EAAsB7E,MAAtB,EAA8B;AAC7C;AACAf,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,YAApB,EAAkC2E,UAAlC;AACA5F,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BF,MAA9B,EAH6C,CAI7C;;AAEA,MAAI+G,KAAK,GAAG1H,UAAU,CAAC4H,WAAX,CAAuBpC,UAAU,CAAClF,CAAlC,CAAZ;AACA,MAAIuH,iBAAiB,GAAG,GAAxB;;AAEA,MAAIH,KAAK,KAAK,GAAd,EAAmB;AACjBG,IAAAA,iBAAiB,GAAGH,KAAK,GAAGzG,IAAI,CAACC,GAAL,CAASwG,KAAT,CAA5B;AACD;;AAED,SAAO/H,UAAU,CAACkG,gBAAX,CAA4BL,UAA5B,EAAwCqC,iBAAxC,EAA2DlH,MAA3D,CAAP;AACD,CAdD;AAgBA;;;;;;;;;AAOAT,UAAU,CAAC4H,GAAX,GAAiB,UAAUC,SAAV,EAAqBpH,MAArB,EAA6B;AAC5C;AACAf,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,WAApB,EAAiCkH,SAAjC;AACAnI,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BF,MAA9B,EAH4C,CAI5C;;AAEA,MAAI+G,KAAK,GAAG/H,UAAU,CAAC0F,SAAX,CAAqB0C,SAArB,CAAZ;AACA,MAAIC,iBAAiB,GAAG,GAAxB;;AAEA,MAAIN,KAAK,KAAK,GAAd,EAAmB;AACjBM,IAAAA,iBAAiB,GAAG/G,IAAI,CAACC,GAAL,CAASwG,KAAT,IAAkBA,KAAtC;AACD;;AAED/G,EAAAA,MAAM,CAACR,CAAP,GAAW4H,SAAS,CAAC5H,CAAV,GAAc6H,iBAAzB;AACArH,EAAAA,MAAM,CAACP,CAAP,GAAW2H,SAAS,CAAC3H,CAAV,GAAc4H,iBAAzB;AACArH,EAAAA,MAAM,CAACN,CAAP,GAAW0H,SAAS,CAAC1H,CAAV,GAAc2H,iBAAzB;AACArH,EAAAA,MAAM,CAACL,CAAP,GAAWW,IAAI,CAACG,GAAL,CAASsG,KAAT,CAAX;AAEA,SAAO/G,MAAP;AACD,CAnBD;;AAqBA,IAAIsH,sBAAsB,GAAG,IAAItI,UAAJ,EAA7B;AACA,IAAIuI,sBAAsB,GAAG,IAAIvI,UAAJ,EAA7B;AACA,IAAIwI,uBAAuB,GAAG,IAAIjI,UAAJ,EAA9B;AACA,IAAIkI,uBAAuB,GAAG,IAAIlI,UAAJ,EAA9B;AAEA;;;;;;;;;;;;;AAYAA,UAAU,CAACmI,sBAAX,GAAoC,UAAUC,EAAV,EAAcC,EAAd,EAAkBC,EAAlB,EAAsB7H,MAAtB,EAA8B;AAChE;AACAf,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,IAApB,EAA0ByH,EAA1B;AACA1I,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,IAApB,EAA0B0H,EAA1B;AACA3I,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,IAApB,EAA0B2H,EAA1B;AACA5I,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BF,MAA9B,EALgE,CAMhE;;AAEA,MAAI8H,IAAI,GAAGvI,UAAU,CAACyE,SAAX,CAAqB4D,EAArB,EAAyBJ,uBAAzB,CAAX;AACAjI,EAAAA,UAAU,CAACuD,QAAX,CAAoBgF,IAApB,EAA0BD,EAA1B,EAA8BJ,uBAA9B;AACA,MAAIM,KAAK,GAAGxI,UAAU,CAACyH,GAAX,CAAeS,uBAAf,EAAwCH,sBAAxC,CAAZ;AAEA/H,EAAAA,UAAU,CAACuD,QAAX,CAAoBgF,IAApB,EAA0BH,EAA1B,EAA8BF,uBAA9B;AACA,MAAIO,KAAK,GAAGzI,UAAU,CAACyH,GAAX,CAAeS,uBAAf,EAAwCF,sBAAxC,CAAZ;AAEAvI,EAAAA,UAAU,CAACmG,GAAX,CAAe4C,KAAf,EAAsBC,KAAtB,EAA6BD,KAA7B;AACA/I,EAAAA,UAAU,CAACkG,gBAAX,CAA4B6C,KAA5B,EAAmC,IAAnC,EAAyCA,KAAzC;AACA/I,EAAAA,UAAU,CAACmF,MAAX,CAAkB4D,KAAlB,EAAyBA,KAAzB;AACAxI,EAAAA,UAAU,CAAC4H,GAAX,CAAeY,KAAf,EAAsBP,uBAAtB;AAEA,SAAOjI,UAAU,CAACuD,QAAX,CAAoB8E,EAApB,EAAwBJ,uBAAxB,EAAiDxH,MAAjD,CAAP;AACD,CArBD;AAuBA;;;;;;;;;;;;;;;;;;;;;;;;;;AAwBAT,UAAU,CAAC0I,KAAX,GAAmB,UAAUN,EAAV,EAAcC,EAAd,EAAkBM,EAAlB,EAAsBC,EAAtB,EAA0B1B,CAA1B,EAA6BzG,MAA7B,EAAqC;AACtD;AACAf,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,IAApB,EAA0ByH,EAA1B;AACA1I,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,IAApB,EAA0B0H,EAA1B;AACA3I,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,IAApB,EAA0BgI,EAA1B;AACAjJ,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,IAApB,EAA0BiI,EAA1B;AACAlJ,EAAAA,KAAK,CAACgB,MAAN,CAAaE,MAAb,CAAoB,GAApB,EAAyBsG,CAAzB;AACAxH,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BF,MAA9B,EAPsD,CAQtD;;AAEA,MAAIoI,MAAM,GAAG7I,UAAU,CAACsH,KAAX,CAAiBc,EAAjB,EAAqBC,EAArB,EAAyBnB,CAAzB,EAA4Be,uBAA5B,CAAb;AACA,MAAIa,MAAM,GAAG9I,UAAU,CAACsH,KAAX,CAAiBqB,EAAjB,EAAqBC,EAArB,EAAyB1B,CAAzB,EAA4BgB,uBAA5B,CAAb;AACA,SAAOlI,UAAU,CAACsH,KAAX,CAAiBuB,MAAjB,EAAyBC,MAAzB,EAAiC,MAAM5B,CAAN,IAAW,MAAMA,CAAjB,CAAjC,EAAsDzG,MAAtD,CAAP;AACD,CAbD;;AAeA,IAAIsI,0BAA0B,GAAG,IAAI/I,UAAJ,EAAjC;AACA,IAAIgJ,IAAI,GAAG,mBAAX;AACA,IAAIC,CAAC,GAAGpJ,gBAAgB,CAACqJ,mBAAjB,KAAyC,IAAIC,YAAJ,CAAiB,CAAjB,CAAzC,GAA+D,EAAvE;AACA,IAAIC,CAAC,GAAGvJ,gBAAgB,CAACqJ,mBAAjB,KAAyC,IAAIC,YAAJ,CAAiB,CAAjB,CAAzC,GAA+D,EAAvE;AACA,IAAIE,EAAE,GAAGxJ,gBAAgB,CAACqJ,mBAAjB,KAAyC,IAAIC,YAAJ,CAAiB,CAAjB,CAAzC,GAA+D,EAAxE;AACA,IAAIG,EAAE,GAAGzJ,gBAAgB,CAACqJ,mBAAjB,KAAyC,IAAIC,YAAJ,CAAiB,CAAjB,CAAzC,GAA+D,EAAxE;;AAEA,KAAK,IAAI3G,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuB,EAAEA,CAAzB,EAA4B;AAC1B,MAAI1B,CAAC,GAAG0B,CAAC,GAAG,GAAZ;AACA,MAAI0E,CAAC,GAAG,MAAMpG,CAAN,GAAU,GAAlB;AACAmI,EAAAA,CAAC,CAACzG,CAAD,CAAD,GAAO,OAAO1B,CAAC,GAAGoG,CAAX,CAAP;AACAkC,EAAAA,CAAC,CAAC5G,CAAD,CAAD,GAAO1B,CAAC,GAAGoG,CAAX;AACD;;AAED+B,CAAC,CAAC,CAAD,CAAD,GAAOD,IAAI,IAAI,MAAM,IAAV,CAAX;AACAI,CAAC,CAAC,CAAD,CAAD,GAAQJ,IAAI,GAAG,GAAR,GAAe,IAAtB;AAEA;;;;;;;;;;;;;AAYAhJ,UAAU,CAACuJ,SAAX,GAAuB,UAAUvC,KAAV,EAAiBC,GAAjB,EAAsBC,CAAtB,EAAyBzG,MAAzB,EAAiC;AACtD;AACAf,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,OAApB,EAA6BqG,KAA7B;AACAtH,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,KAApB,EAA2BsG,GAA3B;AACAvH,EAAAA,KAAK,CAACgB,MAAN,CAAaE,MAAb,CAAoB,GAApB,EAAyBsG,CAAzB;AACAxH,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BF,MAA9B,EALsD,CAMtD;;AAEA,MAAIR,CAAC,GAAGD,UAAU,CAACgG,GAAX,CAAegB,KAAf,EAAsBC,GAAtB,CAAR;AAEA,MAAIuC,IAAJ;;AACA,MAAIvJ,CAAC,IAAI,CAAT,EAAY;AACVuJ,IAAAA,IAAI,GAAG,GAAP;AACD,GAFD,MAEO;AACLA,IAAAA,IAAI,GAAG,CAAC,GAAR;AACAvJ,IAAAA,CAAC,GAAG,CAACA,CAAL;AACD;;AAED,MAAIwJ,GAAG,GAAGxJ,CAAC,GAAG,GAAd;AACA,MAAIyJ,CAAC,GAAG,MAAMxC,CAAd;AACA,MAAIyC,IAAI,GAAGzC,CAAC,GAAGA,CAAf;AACA,MAAI0C,IAAI,GAAGF,CAAC,GAAGA,CAAf;;AAEA,OAAK,IAAIlH,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI,CAArB,EAAwB,EAAEA,CAA1B,EAA6B;AAC3B6G,IAAAA,EAAE,CAAC7G,CAAD,CAAF,GAAQ,CAACyG,CAAC,CAACzG,CAAD,CAAD,GAAOmH,IAAP,GAAcP,CAAC,CAAC5G,CAAD,CAAhB,IAAuBiH,GAA/B;AACAH,IAAAA,EAAE,CAAC9G,CAAD,CAAF,GAAQ,CAACyG,CAAC,CAACzG,CAAD,CAAD,GAAOoH,IAAP,GAAcR,CAAC,CAAC5G,CAAD,CAAhB,IAAuBiH,GAA/B;AACD;;AAED,MAAII,EAAE,GACJL,IAAI,GACJtC,CADA,IAEC,MACCmC,EAAE,CAAC,CAAD,CAAF,IACG,MACCA,EAAE,CAAC,CAAD,CAAF,IACG,MACCA,EAAE,CAAC,CAAD,CAAF,IACG,MACCA,EAAE,CAAC,CAAD,CAAF,IACG,MACCA,EAAE,CAAC,CAAD,CAAF,IACG,MAAMA,EAAE,CAAC,CAAD,CAAF,IAAS,MAAMA,EAAE,CAAC,CAAD,CAAF,IAAS,MAAMA,EAAE,CAAC,CAAD,CAAjB,CAAf,CADT,CAFJ,CAFJ,CAFJ,CAFJ,CAHF,CADF;AAcA,MAAIS,EAAE,GACJJ,CAAC,IACA,MACCJ,EAAE,CAAC,CAAD,CAAF,IACG,MACCA,EAAE,CAAC,CAAD,CAAF,IACG,MACCA,EAAE,CAAC,CAAD,CAAF,IACG,MACCA,EAAE,CAAC,CAAD,CAAF,IACG,MACCA,EAAE,CAAC,CAAD,CAAF,IACG,MAAMA,EAAE,CAAC,CAAD,CAAF,IAAS,MAAMA,EAAE,CAAC,CAAD,CAAF,IAAS,MAAMA,EAAE,CAAC,CAAD,CAAjB,CAAf,CADT,CAFJ,CAFJ,CAFJ,CAFJ,CAFD,CADH;AAcA,MAAIS,IAAI,GAAG/J,UAAU,CAAC2F,gBAAX,CAA4BqB,KAA5B,EAAmC8C,EAAnC,EAAuCf,0BAAvC,CAAX;AACA/I,EAAAA,UAAU,CAAC2F,gBAAX,CAA4BsB,GAA5B,EAAiC4C,EAAjC,EAAqCpJ,MAArC;AACA,SAAOT,UAAU,CAAC4F,GAAX,CAAemE,IAAf,EAAqBtJ,MAArB,EAA6BA,MAA7B,CAAP;AACD,CA3DD;AA6DA;;;;;;;;;;;;;;;;AAcAT,UAAU,CAACgK,SAAX,GAAuB,UAAU5B,EAAV,EAAcC,EAAd,EAAkBM,EAAlB,EAAsBC,EAAtB,EAA0B1B,CAA1B,EAA6BzG,MAA7B,EAAqC;AAC1D;AACAf,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,IAApB,EAA0ByH,EAA1B;AACA1I,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,IAApB,EAA0B0H,EAA1B;AACA3I,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,IAApB,EAA0BgI,EAA1B;AACAjJ,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,IAApB,EAA0BiI,EAA1B;AACAlJ,EAAAA,KAAK,CAACgB,MAAN,CAAaE,MAAb,CAAoB,GAApB,EAAyBsG,CAAzB;AACAxH,EAAAA,KAAK,CAACgB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BF,MAA9B,EAP0D,CAQ1D;;AAEA,MAAIoI,MAAM,GAAG7I,UAAU,CAACuJ,SAAX,CAAqBnB,EAArB,EAAyBC,EAAzB,EAA6BnB,CAA7B,EAAgCe,uBAAhC,CAAb;AACA,MAAIa,MAAM,GAAG9I,UAAU,CAACuJ,SAAX,CAAqBZ,EAArB,EAAyBC,EAAzB,EAA6B1B,CAA7B,EAAgCgB,uBAAhC,CAAb;AACA,SAAOlI,UAAU,CAACuJ,SAAX,CAAqBV,MAArB,EAA6BC,MAA7B,EAAqC,MAAM5B,CAAN,IAAW,MAAMA,CAAjB,CAArC,EAA0DzG,MAA1D,CAAP;AACD,CAbD;AAeA;;;;;;;;;;AAQAT,UAAU,CAACiK,MAAX,GAAoB,UAAUpE,IAAV,EAAgBC,KAAhB,EAAuB;AACzC,SACED,IAAI,KAAKC,KAAT,IACClG,OAAO,CAACiG,IAAD,CAAP,IACCjG,OAAO,CAACkG,KAAD,CADR,IAECD,IAAI,CAAC5F,CAAL,KAAW6F,KAAK,CAAC7F,CAFlB,IAGC4F,IAAI,CAAC3F,CAAL,KAAW4F,KAAK,CAAC5F,CAHlB,IAIC2F,IAAI,CAAC1F,CAAL,KAAW2F,KAAK,CAAC3F,CAJlB,IAKC0F,IAAI,CAACzF,CAAL,KAAW0F,KAAK,CAAC1F,CAPrB;AASD,CAVD;AAYA;;;;;;;;;;;;AAUAJ,UAAU,CAACkK,aAAX,GAA2B,UAAUrE,IAAV,EAAgBC,KAAhB,EAAuBqE,OAAvB,EAAgC;AACzD;AACAzK,EAAAA,KAAK,CAACgB,MAAN,CAAaE,MAAb,CAAoB,SAApB,EAA+BuJ,OAA/B,EAFyD,CAGzD;;AAEA,SACEtE,IAAI,KAAKC,KAAT,IACClG,OAAO,CAACiG,IAAD,CAAP,IACCjG,OAAO,CAACkG,KAAD,CADR,IAEC/E,IAAI,CAAC4F,GAAL,CAASd,IAAI,CAAC5F,CAAL,GAAS6F,KAAK,CAAC7F,CAAxB,KAA8BkK,OAF/B,IAGCpJ,IAAI,CAAC4F,GAAL,CAASd,IAAI,CAAC3F,CAAL,GAAS4F,KAAK,CAAC5F,CAAxB,KAA8BiK,OAH/B,IAICpJ,IAAI,CAAC4F,GAAL,CAASd,IAAI,CAAC1F,CAAL,GAAS2F,KAAK,CAAC3F,CAAxB,KAA8BgK,OAJ/B,IAKCpJ,IAAI,CAAC4F,GAAL,CAASd,IAAI,CAACzF,CAAL,GAAS0F,KAAK,CAAC1F,CAAxB,KAA8B+J,OAPlC;AASD,CAdD;AAgBA;;;;;;;;AAMAnK,UAAU,CAACoK,IAAX,GAAkBC,MAAM,CAACC,MAAP,CAAc,IAAItK,UAAJ,CAAe,GAAf,EAAoB,GAApB,EAAyB,GAAzB,EAA8B,GAA9B,CAAd,CAAlB;AAEA;;;;;;;AAMAA,UAAU,CAACqF,QAAX,GAAsBgF,MAAM,CAACC,MAAP,CAAc,IAAItK,UAAJ,CAAe,GAAf,EAAoB,GAApB,EAAyB,GAAzB,EAA8B,GAA9B,CAAd,CAAtB;AAEA;;;;;;;AAMAA,UAAU,CAACuK,SAAX,CAAqBnF,KAArB,GAA6B,UAAU3E,MAAV,EAAkB;AAC7C,SAAOT,UAAU,CAACoF,KAAX,CAAiB,IAAjB,EAAuB3E,MAAvB,CAAP;AACD,CAFD;AAIA;;;;;;;;;AAOAT,UAAU,CAACuK,SAAX,CAAqBN,MAArB,GAA8B,UAAUnE,KAAV,EAAiB;AAC7C,SAAO9F,UAAU,CAACiK,MAAX,CAAkB,IAAlB,EAAwBnE,KAAxB,CAAP;AACD,CAFD;AAIA;;;;;;;;;;;AASA9F,UAAU,CAACuK,SAAX,CAAqBL,aAArB,GAAqC,UAAUpE,KAAV,EAAiBqE,OAAjB,EAA0B;AAC7D,SAAOnK,UAAU,CAACkK,aAAX,CAAyB,IAAzB,EAA+BpE,KAA/B,EAAsCqE,OAAtC,CAAP;AACD,CAFD;AAIA;;;;;;;AAKAnK,UAAU,CAACuK,SAAX,CAAqBC,QAArB,GAAgC,YAAY;AAC1C,SAAO,MAAM,KAAKvK,CAAX,GAAe,IAAf,GAAsB,KAAKC,CAA3B,GAA+B,IAA/B,GAAsC,KAAKC,CAA3C,GAA+C,IAA/C,GAAsD,KAAKC,CAA3D,GAA+D,GAAtE;AACD,CAFD;;AAGA,eAAeJ,UAAf","sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport FeatureDetection from \"./FeatureDetection.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\n\n/**\n * A set of 4-dimensional coordinates used to represent rotation in 3-dimensional space.\n * @alias Quaternion\n * @constructor\n *\n * @param {Number} [x=0.0] The X component.\n * @param {Number} [y=0.0] The Y component.\n * @param {Number} [z=0.0] The Z component.\n * @param {Number} [w=0.0] The W component.\n *\n * @see PackableForInterpolation\n */\nfunction Quaternion(x, y, z, w) {\n  /**\n   * The X component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.x = defaultValue(x, 0.0);\n\n  /**\n   * The Y component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.y = defaultValue(y, 0.0);\n\n  /**\n   * The Z component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.z = defaultValue(z, 0.0);\n\n  /**\n   * The W component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.w = defaultValue(w, 0.0);\n}\n\nvar fromAxisAngleScratch = new Cartesian3();\n\n/**\n * Computes a quaternion representing a rotation around an axis.\n *\n * @param {Cartesian3} axis The axis of rotation.\n * @param {Number} angle The angle in radians to rotate around the axis.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nQuaternion.fromAxisAngle = function (axis, angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"axis\", axis);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  var halfAngle = angle / 2.0;\n  var s = Math.sin(halfAngle);\n  fromAxisAngleScratch = Cartesian3.normalize(axis, fromAxisAngleScratch);\n\n  var x = fromAxisAngleScratch.x * s;\n  var y = fromAxisAngleScratch.y * s;\n  var z = fromAxisAngleScratch.z * s;\n  var w = Math.cos(halfAngle);\n  if (!defined(result)) {\n    return new Quaternion(x, y, z, w);\n  }\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\nvar fromRotationMatrixNext = [1, 2, 0];\nvar fromRotationMatrixQuat = new Array(3);\n/**\n * Computes a Quaternion from the provided Matrix3 instance.\n *\n * @param {Matrix3} matrix The rotation matrix.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n *\n * @see Matrix3.fromQuaternion\n */\nQuaternion.fromRotationMatrix = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  var root;\n  var x;\n  var y;\n  var z;\n  var w;\n\n  var m00 = matrix[Matrix3.COLUMN0ROW0];\n  var m11 = matrix[Matrix3.COLUMN1ROW1];\n  var m22 = matrix[Matrix3.COLUMN2ROW2];\n  var trace = m00 + m11 + m22;\n\n  if (trace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    root = Math.sqrt(trace + 1.0); // 2w\n    w = 0.5 * root;\n    root = 0.5 / root; // 1/(4w)\n\n    x = (matrix[Matrix3.COLUMN1ROW2] - matrix[Matrix3.COLUMN2ROW1]) * root;\n    y = (matrix[Matrix3.COLUMN2ROW0] - matrix[Matrix3.COLUMN0ROW2]) * root;\n    z = (matrix[Matrix3.COLUMN0ROW1] - matrix[Matrix3.COLUMN1ROW0]) * root;\n  } else {\n    // |w| <= 1/2\n    var next = fromRotationMatrixNext;\n\n    var i = 0;\n    if (m11 > m00) {\n      i = 1;\n    }\n    if (m22 > m00 && m22 > m11) {\n      i = 2;\n    }\n    var j = next[i];\n    var k = next[j];\n\n    root = Math.sqrt(\n      matrix[Matrix3.getElementIndex(i, i)] -\n        matrix[Matrix3.getElementIndex(j, j)] -\n        matrix[Matrix3.getElementIndex(k, k)] +\n        1.0\n    );\n\n    var quat = fromRotationMatrixQuat;\n    quat[i] = 0.5 * root;\n    root = 0.5 / root;\n    w =\n      (matrix[Matrix3.getElementIndex(k, j)] -\n        matrix[Matrix3.getElementIndex(j, k)]) *\n      root;\n    quat[j] =\n      (matrix[Matrix3.getElementIndex(j, i)] +\n        matrix[Matrix3.getElementIndex(i, j)]) *\n      root;\n    quat[k] =\n      (matrix[Matrix3.getElementIndex(k, i)] +\n        matrix[Matrix3.getElementIndex(i, k)]) *\n      root;\n\n    x = -quat[0];\n    y = -quat[1];\n    z = -quat[2];\n  }\n\n  if (!defined(result)) {\n    return new Quaternion(x, y, z, w);\n  }\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\nvar scratchHPRQuaternion = new Quaternion();\nvar scratchHeadingQuaternion = new Quaternion();\nvar scratchPitchQuaternion = new Quaternion();\nvar scratchRollQuaternion = new Quaternion();\n\n/**\n * Computes a rotation from the given heading, pitch and roll angles. Heading is the rotation about the\n * negative z axis. Pitch is the rotation about the negative y axis. Roll is the rotation about\n * the positive x axis.\n *\n * @param {HeadingPitchRoll} headingPitchRoll The rotation expressed as a heading, pitch and roll.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if none was provided.\n */\nQuaternion.fromHeadingPitchRoll = function (headingPitchRoll, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"headingPitchRoll\", headingPitchRoll);\n  //>>includeEnd('debug');\n\n  scratchRollQuaternion = Quaternion.fromAxisAngle(\n    Cartesian3.UNIT_X,\n    headingPitchRoll.roll,\n    scratchHPRQuaternion\n  );\n  scratchPitchQuaternion = Quaternion.fromAxisAngle(\n    Cartesian3.UNIT_Y,\n    -headingPitchRoll.pitch,\n    result\n  );\n  result = Quaternion.multiply(\n    scratchPitchQuaternion,\n    scratchRollQuaternion,\n    scratchPitchQuaternion\n  );\n  scratchHeadingQuaternion = Quaternion.fromAxisAngle(\n    Cartesian3.UNIT_Z,\n    -headingPitchRoll.heading,\n    scratchHPRQuaternion\n  );\n  return Quaternion.multiply(scratchHeadingQuaternion, result, result);\n};\n\nvar sampledQuaternionAxis = new Cartesian3();\nvar sampledQuaternionRotation = new Cartesian3();\nvar sampledQuaternionTempQuaternion = new Quaternion();\nvar sampledQuaternionQuaternion0 = new Quaternion();\nvar sampledQuaternionQuaternion0Conjugate = new Quaternion();\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nQuaternion.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Quaternion} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nQuaternion.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex++] = value.z;\n  array[startingIndex] = value.w;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Quaternion} [result] The object into which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nQuaternion.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Quaternion();\n  }\n  result.x = array[startingIndex];\n  result.y = array[startingIndex + 1];\n  result.z = array[startingIndex + 2];\n  result.w = array[startingIndex + 3];\n  return result;\n};\n\n/**\n * The number of elements used to store the object into an array in its interpolatable form.\n * @type {Number}\n */\nQuaternion.packedInterpolationLength = 3;\n\n/**\n * Converts a packed array into a form suitable for interpolation.\n *\n * @param {Number[]} packedArray The packed array.\n * @param {Number} [startingIndex=0] The index of the first element to be converted.\n * @param {Number} [lastIndex=packedArray.length] The index of the last element to be converted.\n * @param {Number[]} result The object into which to store the result.\n */\nQuaternion.convertPackedArrayForInterpolation = function (\n  packedArray,\n  startingIndex,\n  lastIndex,\n  result\n) {\n  Quaternion.unpack(\n    packedArray,\n    lastIndex * 4,\n    sampledQuaternionQuaternion0Conjugate\n  );\n  Quaternion.conjugate(\n    sampledQuaternionQuaternion0Conjugate,\n    sampledQuaternionQuaternion0Conjugate\n  );\n\n  for (var i = 0, len = lastIndex - startingIndex + 1; i < len; i++) {\n    var offset = i * 3;\n    Quaternion.unpack(\n      packedArray,\n      (startingIndex + i) * 4,\n      sampledQuaternionTempQuaternion\n    );\n\n    Quaternion.multiply(\n      sampledQuaternionTempQuaternion,\n      sampledQuaternionQuaternion0Conjugate,\n      sampledQuaternionTempQuaternion\n    );\n\n    if (sampledQuaternionTempQuaternion.w < 0) {\n      Quaternion.negate(\n        sampledQuaternionTempQuaternion,\n        sampledQuaternionTempQuaternion\n      );\n    }\n\n    Quaternion.computeAxis(\n      sampledQuaternionTempQuaternion,\n      sampledQuaternionAxis\n    );\n    var angle = Quaternion.computeAngle(sampledQuaternionTempQuaternion);\n    result[offset] = sampledQuaternionAxis.x * angle;\n    result[offset + 1] = sampledQuaternionAxis.y * angle;\n    result[offset + 2] = sampledQuaternionAxis.z * angle;\n  }\n};\n\n/**\n * Retrieves an instance from a packed array converted with {@link convertPackedArrayForInterpolation}.\n *\n * @param {Number[]} array The array previously packed for interpolation.\n * @param {Number[]} sourceArray The original packed array.\n * @param {Number} [firstIndex=0] The firstIndex used to convert the array.\n * @param {Number} [lastIndex=packedArray.length] The lastIndex used to convert the array.\n * @param {Quaternion} [result] The object into which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nQuaternion.unpackInterpolationResult = function (\n  array,\n  sourceArray,\n  firstIndex,\n  lastIndex,\n  result\n) {\n  if (!defined(result)) {\n    result = new Quaternion();\n  }\n  Cartesian3.fromArray(array, 0, sampledQuaternionRotation);\n  var magnitude = Cartesian3.magnitude(sampledQuaternionRotation);\n\n  Quaternion.unpack(sourceArray, lastIndex * 4, sampledQuaternionQuaternion0);\n\n  if (magnitude === 0) {\n    Quaternion.clone(Quaternion.IDENTITY, sampledQuaternionTempQuaternion);\n  } else {\n    Quaternion.fromAxisAngle(\n      sampledQuaternionRotation,\n      magnitude,\n      sampledQuaternionTempQuaternion\n    );\n  }\n\n  return Quaternion.multiply(\n    sampledQuaternionTempQuaternion,\n    sampledQuaternionQuaternion0,\n    result\n  );\n};\n\n/**\n * Duplicates a Quaternion instance.\n *\n * @param {Quaternion} quaternion The quaternion to duplicate.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided. (Returns undefined if quaternion is undefined)\n */\nQuaternion.clone = function (quaternion, result) {\n  if (!defined(quaternion)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Quaternion(\n      quaternion.x,\n      quaternion.y,\n      quaternion.z,\n      quaternion.w\n    );\n  }\n\n  result.x = quaternion.x;\n  result.y = quaternion.y;\n  result.z = quaternion.z;\n  result.w = quaternion.w;\n  return result;\n};\n\n/**\n * Computes the conjugate of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to conjugate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.conjugate = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -quaternion.x;\n  result.y = -quaternion.y;\n  result.z = -quaternion.z;\n  result.w = quaternion.w;\n  return result;\n};\n\n/**\n * Computes magnitude squared for the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to conjugate.\n * @returns {Number} The magnitude squared.\n */\nQuaternion.magnitudeSquared = function (quaternion) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  //>>includeEnd('debug');\n\n  return (\n    quaternion.x * quaternion.x +\n    quaternion.y * quaternion.y +\n    quaternion.z * quaternion.z +\n    quaternion.w * quaternion.w\n  );\n};\n\n/**\n * Computes magnitude for the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to conjugate.\n * @returns {Number} The magnitude.\n */\nQuaternion.magnitude = function (quaternion) {\n  return Math.sqrt(Quaternion.magnitudeSquared(quaternion));\n};\n\n/**\n * Computes the normalized form of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to normalize.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.normalize = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var inverseMagnitude = 1.0 / Quaternion.magnitude(quaternion);\n  var x = quaternion.x * inverseMagnitude;\n  var y = quaternion.y * inverseMagnitude;\n  var z = quaternion.z * inverseMagnitude;\n  var w = quaternion.w * inverseMagnitude;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Computes the inverse of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to normalize.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.inverse = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var magnitudeSquared = Quaternion.magnitudeSquared(quaternion);\n  result = Quaternion.conjugate(quaternion, result);\n  return Quaternion.multiplyByScalar(result, 1.0 / magnitudeSquared, result);\n};\n\n/**\n * Computes the componentwise sum of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  result.w = left.w + right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  result.w = left.w - right.w;\n  return result;\n};\n\n/**\n * Negates the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to be negated.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.negate = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -quaternion.x;\n  result.y = -quaternion.y;\n  result.z = -quaternion.z;\n  result.w = -quaternion.w;\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @returns {Number} The dot product.\n */\nQuaternion.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return (\n    left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w\n  );\n};\n\n/**\n * Computes the product of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var leftX = left.x;\n  var leftY = left.y;\n  var leftZ = left.z;\n  var leftW = left.w;\n\n  var rightX = right.x;\n  var rightY = right.y;\n  var rightZ = right.z;\n  var rightW = right.w;\n\n  var x = leftW * rightX + leftX * rightW + leftY * rightZ - leftZ * rightY;\n  var y = leftW * rightY - leftX * rightZ + leftY * rightW + leftZ * rightX;\n  var z = leftW * rightZ + leftX * rightY - leftY * rightX + leftZ * rightW;\n  var w = leftW * rightW - leftX * rightX - leftY * rightY - leftZ * rightZ;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Multiplies the provided quaternion componentwise by the provided scalar.\n *\n * @param {Quaternion} quaternion The quaternion to be scaled.\n * @param {Number} scalar The scalar to multiply with.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.multiplyByScalar = function (quaternion, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = quaternion.x * scalar;\n  result.y = quaternion.y * scalar;\n  result.z = quaternion.z * scalar;\n  result.w = quaternion.w * scalar;\n  return result;\n};\n\n/**\n * Divides the provided quaternion componentwise by the provided scalar.\n *\n * @param {Quaternion} quaternion The quaternion to be divided.\n * @param {Number} scalar The scalar to divide by.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.divideByScalar = function (quaternion, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = quaternion.x / scalar;\n  result.y = quaternion.y / scalar;\n  result.z = quaternion.z / scalar;\n  result.w = quaternion.w / scalar;\n  return result;\n};\n\n/**\n * Computes the axis of rotation of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to use.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nQuaternion.computeAxis = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var w = quaternion.w;\n  if (Math.abs(w - 1.0) < CesiumMath.EPSILON6) {\n    result.x = result.y = result.z = 0;\n    return result;\n  }\n\n  var scalar = 1.0 / Math.sqrt(1.0 - w * w);\n\n  result.x = quaternion.x * scalar;\n  result.y = quaternion.y * scalar;\n  result.z = quaternion.z * scalar;\n  return result;\n};\n\n/**\n * Computes the angle of rotation of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to use.\n * @returns {Number} The angle of rotation.\n */\nQuaternion.computeAngle = function (quaternion) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  //>>includeEnd('debug');\n\n  if (Math.abs(quaternion.w - 1.0) < CesiumMath.EPSILON6) {\n    return 0.0;\n  }\n  return 2.0 * Math.acos(quaternion.w);\n};\n\nvar lerpScratch = new Quaternion();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided quaternions.\n *\n * @param {Quaternion} start The value corresponding to t at 0.0.\n * @param {Quaternion} end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  lerpScratch = Quaternion.multiplyByScalar(end, t, lerpScratch);\n  result = Quaternion.multiplyByScalar(start, 1.0 - t, result);\n  return Quaternion.add(lerpScratch, result, result);\n};\n\nvar slerpEndNegated = new Quaternion();\nvar slerpScaledP = new Quaternion();\nvar slerpScaledR = new Quaternion();\n/**\n * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.\n *\n * @param {Quaternion} start The value corresponding to t at 0.0.\n * @param {Quaternion} end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n * @see Quaternion#fastSlerp\n */\nQuaternion.slerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var dot = Quaternion.dot(start, end);\n\n  // The angle between start must be acute. Since q and -q represent\n  // the same rotation, negate q to get the acute angle.\n  var r = end;\n  if (dot < 0.0) {\n    dot = -dot;\n    r = slerpEndNegated = Quaternion.negate(end, slerpEndNegated);\n  }\n\n  // dot > 0, as the dot product approaches 1, the angle between the\n  // quaternions vanishes. use linear interpolation.\n  if (1.0 - dot < CesiumMath.EPSILON6) {\n    return Quaternion.lerp(start, r, t, result);\n  }\n\n  var theta = Math.acos(dot);\n  slerpScaledP = Quaternion.multiplyByScalar(\n    start,\n    Math.sin((1 - t) * theta),\n    slerpScaledP\n  );\n  slerpScaledR = Quaternion.multiplyByScalar(\n    r,\n    Math.sin(t * theta),\n    slerpScaledR\n  );\n  result = Quaternion.add(slerpScaledP, slerpScaledR, result);\n  return Quaternion.multiplyByScalar(result, 1.0 / Math.sin(theta), result);\n};\n\n/**\n * The logarithmic quaternion function.\n *\n * @param {Quaternion} quaternion The unit quaternion.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nQuaternion.log = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var theta = CesiumMath.acosClamped(quaternion.w);\n  var thetaOverSinTheta = 0.0;\n\n  if (theta !== 0.0) {\n    thetaOverSinTheta = theta / Math.sin(theta);\n  }\n\n  return Cartesian3.multiplyByScalar(quaternion, thetaOverSinTheta, result);\n};\n\n/**\n * The exponential quaternion function.\n *\n * @param {Cartesian3} cartesian The cartesian.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.exp = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var theta = Cartesian3.magnitude(cartesian);\n  var sinThetaOverTheta = 0.0;\n\n  if (theta !== 0.0) {\n    sinThetaOverTheta = Math.sin(theta) / theta;\n  }\n\n  result.x = cartesian.x * sinThetaOverTheta;\n  result.y = cartesian.y * sinThetaOverTheta;\n  result.z = cartesian.z * sinThetaOverTheta;\n  result.w = Math.cos(theta);\n\n  return result;\n};\n\nvar squadScratchCartesian0 = new Cartesian3();\nvar squadScratchCartesian1 = new Cartesian3();\nvar squadScratchQuaternion0 = new Quaternion();\nvar squadScratchQuaternion1 = new Quaternion();\n\n/**\n * Computes an inner quadrangle point.\n * <p>This will compute quaternions that ensure a squad curve is C<sup>1</sup>.</p>\n *\n * @param {Quaternion} q0 The first quaternion.\n * @param {Quaternion} q1 The second quaternion.\n * @param {Quaternion} q2 The third quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n * @see Quaternion#squad\n */\nQuaternion.computeInnerQuadrangle = function (q0, q1, q2, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"q0\", q0);\n  Check.typeOf.object(\"q1\", q1);\n  Check.typeOf.object(\"q2\", q2);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var qInv = Quaternion.conjugate(q1, squadScratchQuaternion0);\n  Quaternion.multiply(qInv, q2, squadScratchQuaternion1);\n  var cart0 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian0);\n\n  Quaternion.multiply(qInv, q0, squadScratchQuaternion1);\n  var cart1 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian1);\n\n  Cartesian3.add(cart0, cart1, cart0);\n  Cartesian3.multiplyByScalar(cart0, 0.25, cart0);\n  Cartesian3.negate(cart0, cart0);\n  Quaternion.exp(cart0, squadScratchQuaternion0);\n\n  return Quaternion.multiply(q1, squadScratchQuaternion0, result);\n};\n\n/**\n * Computes the spherical quadrangle interpolation between quaternions.\n *\n * @param {Quaternion} q0 The first quaternion.\n * @param {Quaternion} q1 The second quaternion.\n * @param {Quaternion} s0 The first inner quadrangle.\n * @param {Quaternion} s1 The second inner quadrangle.\n * @param {Number} t The time in [0,1] used to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n *\n * @example\n * // 1. compute the squad interpolation between two quaternions on a curve\n * var s0 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i - 1], quaternions[i], quaternions[i + 1], new Cesium.Quaternion());\n * var s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i], quaternions[i + 1], quaternions[i + 2], new Cesium.Quaternion());\n * var q = Cesium.Quaternion.squad(quaternions[i], quaternions[i + 1], s0, s1, t, new Cesium.Quaternion());\n *\n * // 2. compute the squad interpolation as above but where the first quaternion is a end point.\n * var s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[0], quaternions[1], quaternions[2], new Cesium.Quaternion());\n * var q = Cesium.Quaternion.squad(quaternions[0], quaternions[1], quaternions[0], s1, t, new Cesium.Quaternion());\n *\n * @see Quaternion#computeInnerQuadrangle\n */\nQuaternion.squad = function (q0, q1, s0, s1, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"q0\", q0);\n  Check.typeOf.object(\"q1\", q1);\n  Check.typeOf.object(\"s0\", s0);\n  Check.typeOf.object(\"s1\", s1);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var slerp0 = Quaternion.slerp(q0, q1, t, squadScratchQuaternion0);\n  var slerp1 = Quaternion.slerp(s0, s1, t, squadScratchQuaternion1);\n  return Quaternion.slerp(slerp0, slerp1, 2.0 * t * (1.0 - t), result);\n};\n\nvar fastSlerpScratchQuaternion = new Quaternion();\nvar opmu = 1.90110745351730037;\nvar u = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\nvar v = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\nvar bT = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\nvar bD = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\n\nfor (var i = 0; i < 7; ++i) {\n  var s = i + 1.0;\n  var t = 2.0 * s + 1.0;\n  u[i] = 1.0 / (s * t);\n  v[i] = s / t;\n}\n\nu[7] = opmu / (8.0 * 17.0);\nv[7] = (opmu * 8.0) / 17.0;\n\n/**\n * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.\n * This implementation is faster than {@link Quaternion#slerp}, but is only accurate up to 10<sup>-6</sup>.\n *\n * @param {Quaternion} start The value corresponding to t at 0.0.\n * @param {Quaternion} end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n * @see Quaternion#slerp\n */\nQuaternion.fastSlerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var x = Quaternion.dot(start, end);\n\n  var sign;\n  if (x >= 0) {\n    sign = 1.0;\n  } else {\n    sign = -1.0;\n    x = -x;\n  }\n\n  var xm1 = x - 1.0;\n  var d = 1.0 - t;\n  var sqrT = t * t;\n  var sqrD = d * d;\n\n  for (var i = 7; i >= 0; --i) {\n    bT[i] = (u[i] * sqrT - v[i]) * xm1;\n    bD[i] = (u[i] * sqrD - v[i]) * xm1;\n  }\n\n  var cT =\n    sign *\n    t *\n    (1.0 +\n      bT[0] *\n        (1.0 +\n          bT[1] *\n            (1.0 +\n              bT[2] *\n                (1.0 +\n                  bT[3] *\n                    (1.0 +\n                      bT[4] *\n                        (1.0 + bT[5] * (1.0 + bT[6] * (1.0 + bT[7]))))))));\n  var cD =\n    d *\n    (1.0 +\n      bD[0] *\n        (1.0 +\n          bD[1] *\n            (1.0 +\n              bD[2] *\n                (1.0 +\n                  bD[3] *\n                    (1.0 +\n                      bD[4] *\n                        (1.0 + bD[5] * (1.0 + bD[6] * (1.0 + bD[7]))))))));\n\n  var temp = Quaternion.multiplyByScalar(start, cD, fastSlerpScratchQuaternion);\n  Quaternion.multiplyByScalar(end, cT, result);\n  return Quaternion.add(temp, result, result);\n};\n\n/**\n * Computes the spherical quadrangle interpolation between quaternions.\n * An implementation that is faster than {@link Quaternion#squad}, but less accurate.\n *\n * @param {Quaternion} q0 The first quaternion.\n * @param {Quaternion} q1 The second quaternion.\n * @param {Quaternion} s0 The first inner quadrangle.\n * @param {Quaternion} s1 The second inner quadrangle.\n * @param {Number} t The time in [0,1] used to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new instance if none was provided.\n *\n * @see Quaternion#squad\n */\nQuaternion.fastSquad = function (q0, q1, s0, s1, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"q0\", q0);\n  Check.typeOf.object(\"q1\", q1);\n  Check.typeOf.object(\"s0\", s0);\n  Check.typeOf.object(\"s1\", s1);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var slerp0 = Quaternion.fastSlerp(q0, q1, t, squadScratchQuaternion0);\n  var slerp1 = Quaternion.fastSlerp(s0, s1, t, squadScratchQuaternion1);\n  return Quaternion.fastSlerp(slerp0, slerp1, 2.0 * t * (1.0 - t), result);\n};\n\n/**\n * Compares the provided quaternions componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Quaternion} [left] The first quaternion.\n * @param {Quaternion} [right] The second quaternion.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nQuaternion.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.x === right.x &&\n      left.y === right.y &&\n      left.z === right.z &&\n      left.w === right.w)\n  );\n};\n\n/**\n * Compares the provided quaternions componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Quaternion} [left] The first quaternion.\n * @param {Quaternion} [right] The second quaternion.\n * @param {Number} epsilon The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nQuaternion.equalsEpsilon = function (left, right, epsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"epsilon\", epsilon);\n  //>>includeEnd('debug');\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(left.x - right.x) <= epsilon &&\n      Math.abs(left.y - right.y) <= epsilon &&\n      Math.abs(left.z - right.z) <= epsilon &&\n      Math.abs(left.w - right.w) <= epsilon)\n  );\n};\n\n/**\n * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 0.0).\n *\n * @type {Quaternion}\n * @constant\n */\nQuaternion.ZERO = Object.freeze(new Quaternion(0.0, 0.0, 0.0, 0.0));\n\n/**\n * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 1.0).\n *\n * @type {Quaternion}\n * @constant\n */\nQuaternion.IDENTITY = Object.freeze(new Quaternion(0.0, 0.0, 0.0, 1.0));\n\n/**\n * Duplicates this Quaternion instance.\n *\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nQuaternion.prototype.clone = function (result) {\n  return Quaternion.clone(this, result);\n};\n\n/**\n * Compares this and the provided quaternion componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Quaternion} [right] The right hand side quaternion.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nQuaternion.prototype.equals = function (right) {\n  return Quaternion.equals(this, right);\n};\n\n/**\n * Compares this and the provided quaternion componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Quaternion} [right] The right hand side quaternion.\n * @param {Number} epsilon The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nQuaternion.prototype.equalsEpsilon = function (right, epsilon) {\n  return Quaternion.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Returns a string representing this quaternion in the format (x, y, z, w).\n *\n * @returns {String} A string representing this Quaternion.\n */\nQuaternion.prototype.toString = function () {\n  return \"(\" + this.x + \", \" + this.y + \", \" + this.z + \", \" + this.w + \")\";\n};\nexport default Quaternion;\n"]},"metadata":{},"sourceType":"module"}