{"ast":null,"code":"import AxisAlignedBoundingBox from \"./AxisAlignedBoundingBox.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidalOccluder from \"./EllipsoidalOccluder.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport Transforms from \"./Transforms.js\";\nimport WebMercatorProjection from \"./WebMercatorProjection.js\";\n/**\n * Contains functions to create a mesh from a heightmap image.\n *\n * @exports HeightmapTessellator\n *\n * @private\n */\n\nvar HeightmapTessellator = {};\n/**\n * The default structure of a heightmap, as given to {@link HeightmapTessellator.computeVertices}.\n *\n * @constant\n */\n\nHeightmapTessellator.DEFAULT_STRUCTURE = Object.freeze({\n  heightScale: 1.0,\n  heightOffset: 0.0,\n  elementsPerHeight: 1,\n  stride: 1,\n  elementMultiplier: 256.0,\n  isBigEndian: false\n});\nvar cartesian3Scratch = new Cartesian3();\nvar matrix4Scratch = new Matrix4();\nvar minimumScratch = new Cartesian3();\nvar maximumScratch = new Cartesian3();\n/**\n * Fills an array of vertices from a heightmap image.\n *\n * @param {Object} options Object with the following properties:\n * @param {TypedArray} options.heightmap The heightmap to tessellate.\n * @param {Number} options.width The width of the heightmap, in height samples.\n * @param {Number} options.height The height of the heightmap, in height samples.\n * @param {Number} options.skirtHeight The height of skirts to drape at the edges of the heightmap.\n * @param {Rectangle} options.nativeRectangle A rectangle in the native coordinates of the heightmap's projection.  For\n *                 a heightmap with a geographic projection, this is degrees.  For the web mercator\n *                 projection, this is meters.\n * @param {Number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {Rectangle} [options.rectangle] The rectangle covered by the heightmap, in geodetic coordinates with north, south, east and\n *                 west properties in radians.  Either rectangle or nativeRectangle must be provided.  If both\n *                 are provided, they're assumed to be consistent.\n * @param {Boolean} [options.isGeographic=true] True if the heightmap uses a {@link GeographicProjection}, or false if it uses\n *                  a {@link WebMercatorProjection}.\n * @param {Cartesian3} [options.relativeToCenter=Cartesian3.ZERO] The positions will be computed as <code>Cartesian3.subtract(worldPosition, relativeToCenter)</code>.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to which the heightmap applies.\n * @param {Object} [options.structure] An object describing the structure of the height data.\n * @param {Number} [options.structure.heightScale=1.0] The factor by which to multiply height samples in order to obtain\n *                 the height above the heightOffset, in meters.  The heightOffset is added to the resulting\n *                 height after multiplying by the scale.\n * @param {Number} [options.structure.heightOffset=0.0] The offset to add to the scaled height to obtain the final\n *                 height in meters.  The offset is added after the height sample is multiplied by the\n *                 heightScale.\n * @param {Number} [options.structure.elementsPerHeight=1] The number of elements in the buffer that make up a single height\n *                 sample.  This is usually 1, indicating that each element is a separate height sample.  If\n *                 it is greater than 1, that number of elements together form the height sample, which is\n *                 computed according to the structure.elementMultiplier and structure.isBigEndian properties.\n * @param {Number} [options.structure.stride=1] The number of elements to skip to get from the first element of\n *                 one height to the first element of the next height.\n * @param {Number} [options.structure.elementMultiplier=256.0] The multiplier used to compute the height value when the\n *                 stride property is greater than 1.  For example, if the stride is 4 and the strideMultiplier\n *                 is 256, the height is computed as follows:\n *                 `height = buffer[index] + buffer[index + 1] * 256 + buffer[index + 2] * 256 * 256 + buffer[index + 3] * 256 * 256 * 256`\n *                 This is assuming that the isBigEndian property is false.  If it is true, the order of the\n *                 elements is reversed.\n * @param {Number} [options.structure.lowestEncodedHeight] The lowest value that can be stored in the height buffer.  Any heights that are lower\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be 0 because a `Uint16Array` cannot store negative numbers.  If this parameter is\n *                 not specified, no minimum value is enforced.\n * @param {Number} [options.structure.highestEncodedHeight] The highest value that can be stored in the height buffer.  Any heights that are higher\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be `256 * 256 - 1` or 65535 because a `Uint16Array` cannot store numbers larger\n *                 than 65535.  If this parameter is not specified, no maximum value is enforced.\n * @param {Boolean} [options.structure.isBigEndian=false] Indicates endianness of the elements in the buffer when the\n *                  stride property is greater than 1.  If this property is false, the first element is the\n *                  low-order element.  If it is true, the first element is the high-order element.\n *\n * @example\n * var width = 5;\n * var height = 5;\n * var statistics = Cesium.HeightmapTessellator.computeVertices({\n *     heightmap : [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0],\n *     width : width,\n *     height : height,\n *     skirtHeight : 0.0,\n *     nativeRectangle : {\n *         west : 10.0,\n *         east : 20.0,\n *         south : 30.0,\n *         north : 40.0\n *     }\n * });\n *\n * var encoding = statistics.encoding;\n * var position = encoding.decodePosition(statistics.vertices, index * encoding.getStride());\n */\n\nHeightmapTessellator.computeVertices = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.heightmap)) {\n    throw new DeveloperError(\"options.heightmap is required.\");\n  }\n\n  if (!defined(options.width) || !defined(options.height)) {\n    throw new DeveloperError(\"options.width and options.height are required.\");\n  }\n\n  if (!defined(options.nativeRectangle)) {\n    throw new DeveloperError(\"options.nativeRectangle is required.\");\n  }\n\n  if (!defined(options.skirtHeight)) {\n    throw new DeveloperError(\"options.skirtHeight is required.\");\n  } //>>includeEnd('debug');\n  // This function tends to be a performance hotspot for terrain rendering,\n  // so it employs a lot of inlining and unrolling as an optimization.\n  // In particular, the functionality of Ellipsoid.cartographicToCartesian\n  // is inlined.\n\n\n  var cos = Math.cos;\n  var sin = Math.sin;\n  var sqrt = Math.sqrt;\n  var atan = Math.atan;\n  var exp = Math.exp;\n  var piOverTwo = CesiumMath.PI_OVER_TWO;\n  var toRadians = CesiumMath.toRadians;\n  var heightmap = options.heightmap;\n  var width = options.width;\n  var height = options.height;\n  var skirtHeight = options.skirtHeight;\n  var isGeographic = defaultValue(options.isGeographic, true);\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var oneOverGlobeSemimajorAxis = 1.0 / ellipsoid.maximumRadius;\n  var nativeRectangle = options.nativeRectangle;\n  var geographicWest;\n  var geographicSouth;\n  var geographicEast;\n  var geographicNorth;\n  var rectangle = options.rectangle;\n\n  if (!defined(rectangle)) {\n    if (isGeographic) {\n      geographicWest = toRadians(nativeRectangle.west);\n      geographicSouth = toRadians(nativeRectangle.south);\n      geographicEast = toRadians(nativeRectangle.east);\n      geographicNorth = toRadians(nativeRectangle.north);\n    } else {\n      geographicWest = nativeRectangle.west * oneOverGlobeSemimajorAxis;\n      geographicSouth = piOverTwo - 2.0 * atan(exp(-nativeRectangle.south * oneOverGlobeSemimajorAxis));\n      geographicEast = nativeRectangle.east * oneOverGlobeSemimajorAxis;\n      geographicNorth = piOverTwo - 2.0 * atan(exp(-nativeRectangle.north * oneOverGlobeSemimajorAxis));\n    }\n  } else {\n    geographicWest = rectangle.west;\n    geographicSouth = rectangle.south;\n    geographicEast = rectangle.east;\n    geographicNorth = rectangle.north;\n  }\n\n  var relativeToCenter = options.relativeToCenter;\n  var hasRelativeToCenter = defined(relativeToCenter);\n  relativeToCenter = hasRelativeToCenter ? relativeToCenter : Cartesian3.ZERO;\n  var exaggeration = defaultValue(options.exaggeration, 1.0);\n  var includeWebMercatorT = defaultValue(options.includeWebMercatorT, false);\n  var structure = defaultValue(options.structure, HeightmapTessellator.DEFAULT_STRUCTURE);\n  var heightScale = defaultValue(structure.heightScale, HeightmapTessellator.DEFAULT_STRUCTURE.heightScale);\n  var heightOffset = defaultValue(structure.heightOffset, HeightmapTessellator.DEFAULT_STRUCTURE.heightOffset);\n  var elementsPerHeight = defaultValue(structure.elementsPerHeight, HeightmapTessellator.DEFAULT_STRUCTURE.elementsPerHeight);\n  var stride = defaultValue(structure.stride, HeightmapTessellator.DEFAULT_STRUCTURE.stride);\n  var elementMultiplier = defaultValue(structure.elementMultiplier, HeightmapTessellator.DEFAULT_STRUCTURE.elementMultiplier);\n  var isBigEndian = defaultValue(structure.isBigEndian, HeightmapTessellator.DEFAULT_STRUCTURE.isBigEndian);\n  var rectangleWidth = Rectangle.computeWidth(nativeRectangle);\n  var rectangleHeight = Rectangle.computeHeight(nativeRectangle);\n  var granularityX = rectangleWidth / (width - 1);\n  var granularityY = rectangleHeight / (height - 1);\n\n  if (!isGeographic) {\n    rectangleWidth *= oneOverGlobeSemimajorAxis;\n    rectangleHeight *= oneOverGlobeSemimajorAxis;\n  }\n\n  var radiiSquared = ellipsoid.radiiSquared;\n  var radiiSquaredX = radiiSquared.x;\n  var radiiSquaredY = radiiSquared.y;\n  var radiiSquaredZ = radiiSquared.z;\n  var minimumHeight = 65536.0;\n  var maximumHeight = -65536.0;\n  var fromENU = Transforms.eastNorthUpToFixedFrame(relativeToCenter, ellipsoid);\n  var toENU = Matrix4.inverseTransformation(fromENU, matrix4Scratch);\n  var southMercatorY;\n  var oneOverMercatorHeight;\n\n  if (includeWebMercatorT) {\n    southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(geographicSouth);\n    oneOverMercatorHeight = 1.0 / (WebMercatorProjection.geodeticLatitudeToMercatorAngle(geographicNorth) - southMercatorY);\n  }\n\n  var minimum = minimumScratch;\n  minimum.x = Number.POSITIVE_INFINITY;\n  minimum.y = Number.POSITIVE_INFINITY;\n  minimum.z = Number.POSITIVE_INFINITY;\n  var maximum = maximumScratch;\n  maximum.x = Number.NEGATIVE_INFINITY;\n  maximum.y = Number.NEGATIVE_INFINITY;\n  maximum.z = Number.NEGATIVE_INFINITY;\n  var hMin = Number.POSITIVE_INFINITY;\n  var gridVertexCount = width * height;\n  var edgeVertexCount = skirtHeight > 0.0 ? width * 2 + height * 2 : 0;\n  var vertexCount = gridVertexCount + edgeVertexCount;\n  var positions = new Array(vertexCount);\n  var heights = new Array(vertexCount);\n  var uvs = new Array(vertexCount);\n  var webMercatorTs = includeWebMercatorT ? new Array(vertexCount) : [];\n  var startRow = 0;\n  var endRow = height;\n  var startCol = 0;\n  var endCol = width;\n\n  if (skirtHeight > 0.0) {\n    --startRow;\n    ++endRow;\n    --startCol;\n    ++endCol;\n  }\n\n  var skirtOffsetPercentage = 0.00001;\n\n  for (var rowIndex = startRow; rowIndex < endRow; ++rowIndex) {\n    var row = rowIndex;\n\n    if (row < 0) {\n      row = 0;\n    }\n\n    if (row >= height) {\n      row = height - 1;\n    }\n\n    var latitude = nativeRectangle.north - granularityY * row;\n\n    if (!isGeographic) {\n      latitude = piOverTwo - 2.0 * atan(exp(-latitude * oneOverGlobeSemimajorAxis));\n    } else {\n      latitude = toRadians(latitude);\n    }\n\n    var v = (latitude - geographicSouth) / (geographicNorth - geographicSouth);\n    v = CesiumMath.clamp(v, 0.0, 1.0);\n    var isNorthEdge = rowIndex === startRow;\n    var isSouthEdge = rowIndex === endRow - 1;\n\n    if (skirtHeight > 0.0) {\n      if (isNorthEdge) {\n        latitude += skirtOffsetPercentage * rectangleHeight;\n      } else if (isSouthEdge) {\n        latitude -= skirtOffsetPercentage * rectangleHeight;\n      }\n    }\n\n    var cosLatitude = cos(latitude);\n    var nZ = sin(latitude);\n    var kZ = radiiSquaredZ * nZ;\n    var webMercatorT;\n\n    if (includeWebMercatorT) {\n      webMercatorT = (WebMercatorProjection.geodeticLatitudeToMercatorAngle(latitude) - southMercatorY) * oneOverMercatorHeight;\n    }\n\n    for (var colIndex = startCol; colIndex < endCol; ++colIndex) {\n      var col = colIndex;\n\n      if (col < 0) {\n        col = 0;\n      }\n\n      if (col >= width) {\n        col = width - 1;\n      }\n\n      var terrainOffset = row * (width * stride) + col * stride;\n      var heightSample;\n\n      if (elementsPerHeight === 1) {\n        heightSample = heightmap[terrainOffset];\n      } else {\n        heightSample = 0;\n        var elementOffset;\n\n        if (isBigEndian) {\n          for (elementOffset = 0; elementOffset < elementsPerHeight; ++elementOffset) {\n            heightSample = heightSample * elementMultiplier + heightmap[terrainOffset + elementOffset];\n          }\n        } else {\n          for (elementOffset = elementsPerHeight - 1; elementOffset >= 0; --elementOffset) {\n            heightSample = heightSample * elementMultiplier + heightmap[terrainOffset + elementOffset];\n          }\n        }\n      }\n\n      heightSample = (heightSample * heightScale + heightOffset) * exaggeration;\n      maximumHeight = Math.max(maximumHeight, heightSample);\n      minimumHeight = Math.min(minimumHeight, heightSample);\n      var longitude = nativeRectangle.west + granularityX * col;\n\n      if (!isGeographic) {\n        longitude = longitude * oneOverGlobeSemimajorAxis;\n      } else {\n        longitude = toRadians(longitude);\n      }\n\n      var u = (longitude - geographicWest) / (geographicEast - geographicWest);\n      u = CesiumMath.clamp(u, 0.0, 1.0);\n      var index = row * width + col;\n\n      if (skirtHeight > 0.0) {\n        var isWestEdge = colIndex === startCol;\n        var isEastEdge = colIndex === endCol - 1;\n        var isEdge = isNorthEdge || isSouthEdge || isWestEdge || isEastEdge;\n        var isCorner = (isNorthEdge || isSouthEdge) && (isWestEdge || isEastEdge);\n\n        if (isCorner) {\n          // Don't generate skirts on the corners.\n          continue;\n        } else if (isEdge) {\n          heightSample -= skirtHeight;\n\n          if (isWestEdge) {\n            // The outer loop iterates north to south but the indices are ordered south to north, hence the index flip below\n            index = gridVertexCount + (height - row - 1);\n            longitude -= skirtOffsetPercentage * rectangleWidth;\n          } else if (isSouthEdge) {\n            // Add after west indices. South indices are ordered east to west.\n            index = gridVertexCount + height + (width - col - 1);\n          } else if (isEastEdge) {\n            // Add after west and south indices. East indices are ordered north to south. The index is flipped like above.\n            index = gridVertexCount + height + width + row;\n            longitude += skirtOffsetPercentage * rectangleWidth;\n          } else if (isNorthEdge) {\n            // Add after west, south, and east indices. North indices are ordered west to east.\n            index = gridVertexCount + height + width + height + col;\n          }\n        }\n      }\n\n      var nX = cosLatitude * cos(longitude);\n      var nY = cosLatitude * sin(longitude);\n      var kX = radiiSquaredX * nX;\n      var kY = radiiSquaredY * nY;\n      var gamma = sqrt(kX * nX + kY * nY + kZ * nZ);\n      var oneOverGamma = 1.0 / gamma;\n      var rSurfaceX = kX * oneOverGamma;\n      var rSurfaceY = kY * oneOverGamma;\n      var rSurfaceZ = kZ * oneOverGamma;\n      var position = new Cartesian3();\n      position.x = rSurfaceX + nX * heightSample;\n      position.y = rSurfaceY + nY * heightSample;\n      position.z = rSurfaceZ + nZ * heightSample;\n      positions[index] = position;\n      heights[index] = heightSample;\n      uvs[index] = new Cartesian2(u, v);\n\n      if (includeWebMercatorT) {\n        webMercatorTs[index] = webMercatorT;\n      }\n\n      Matrix4.multiplyByPoint(toENU, position, cartesian3Scratch);\n      Cartesian3.minimumByComponent(cartesian3Scratch, minimum, minimum);\n      Cartesian3.maximumByComponent(cartesian3Scratch, maximum, maximum);\n      hMin = Math.min(hMin, heightSample);\n    }\n  }\n\n  var boundingSphere3D = BoundingSphere.fromPoints(positions);\n  var orientedBoundingBox;\n\n  if (defined(rectangle)) {\n    orientedBoundingBox = OrientedBoundingBox.fromRectangle(rectangle, minimumHeight, maximumHeight, ellipsoid);\n  }\n\n  var occludeePointInScaledSpace;\n\n  if (hasRelativeToCenter) {\n    var occluder = new EllipsoidalOccluder(ellipsoid);\n    occludeePointInScaledSpace = occluder.computeHorizonCullingPointPossiblyUnderEllipsoid(relativeToCenter, positions, minimumHeight);\n  }\n\n  var aaBox = new AxisAlignedBoundingBox(minimum, maximum, relativeToCenter);\n  var encoding = new TerrainEncoding(aaBox, hMin, maximumHeight, fromENU, false, includeWebMercatorT);\n  var vertices = new Float32Array(vertexCount * encoding.getStride());\n  var bufferIndex = 0;\n\n  for (var j = 0; j < vertexCount; ++j) {\n    bufferIndex = encoding.encode(vertices, bufferIndex, positions[j], uvs[j], heights[j], undefined, webMercatorTs[j]);\n  }\n\n  return {\n    vertices: vertices,\n    maximumHeight: maximumHeight,\n    minimumHeight: minimumHeight,\n    encoding: encoding,\n    boundingSphere3D: boundingSphere3D,\n    orientedBoundingBox: orientedBoundingBox,\n    occludeePointInScaledSpace: occludeePointInScaledSpace\n  };\n};\n\nexport default HeightmapTessellator;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/HeightmapTessellator.js"],"names":["AxisAlignedBoundingBox","BoundingSphere","Cartesian2","Cartesian3","defaultValue","defined","DeveloperError","Ellipsoid","EllipsoidalOccluder","CesiumMath","Matrix4","OrientedBoundingBox","Rectangle","TerrainEncoding","Transforms","WebMercatorProjection","HeightmapTessellator","DEFAULT_STRUCTURE","Object","freeze","heightScale","heightOffset","elementsPerHeight","stride","elementMultiplier","isBigEndian","cartesian3Scratch","matrix4Scratch","minimumScratch","maximumScratch","computeVertices","options","heightmap","width","height","nativeRectangle","skirtHeight","cos","Math","sin","sqrt","atan","exp","piOverTwo","PI_OVER_TWO","toRadians","isGeographic","ellipsoid","WGS84","oneOverGlobeSemimajorAxis","maximumRadius","geographicWest","geographicSouth","geographicEast","geographicNorth","rectangle","west","south","east","north","relativeToCenter","hasRelativeToCenter","ZERO","exaggeration","includeWebMercatorT","structure","rectangleWidth","computeWidth","rectangleHeight","computeHeight","granularityX","granularityY","radiiSquared","radiiSquaredX","x","radiiSquaredY","y","radiiSquaredZ","z","minimumHeight","maximumHeight","fromENU","eastNorthUpToFixedFrame","toENU","inverseTransformation","southMercatorY","oneOverMercatorHeight","geodeticLatitudeToMercatorAngle","minimum","Number","POSITIVE_INFINITY","maximum","NEGATIVE_INFINITY","hMin","gridVertexCount","edgeVertexCount","vertexCount","positions","Array","heights","uvs","webMercatorTs","startRow","endRow","startCol","endCol","skirtOffsetPercentage","rowIndex","row","latitude","v","clamp","isNorthEdge","isSouthEdge","cosLatitude","nZ","kZ","webMercatorT","colIndex","col","terrainOffset","heightSample","elementOffset","max","min","longitude","u","index","isWestEdge","isEastEdge","isEdge","isCorner","nX","nY","kX","kY","gamma","oneOverGamma","rSurfaceX","rSurfaceY","rSurfaceZ","position","multiplyByPoint","minimumByComponent","maximumByComponent","boundingSphere3D","fromPoints","orientedBoundingBox","fromRectangle","occludeePointInScaledSpace","occluder","computeHorizonCullingPointPossiblyUnderEllipsoid","aaBox","encoding","vertices","Float32Array","getStride","bufferIndex","j","encode","undefined"],"mappings":"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","sourcesContent":["import AxisAlignedBoundingBox from \"./AxisAlignedBoundingBox.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidalOccluder from \"./EllipsoidalOccluder.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport Transforms from \"./Transforms.js\";\nimport WebMercatorProjection from \"./WebMercatorProjection.js\";\n\n/**\n * Contains functions to create a mesh from a heightmap image.\n *\n * @exports HeightmapTessellator\n *\n * @private\n */\nvar HeightmapTessellator = {};\n\n/**\n * The default structure of a heightmap, as given to {@link HeightmapTessellator.computeVertices}.\n *\n * @constant\n */\nHeightmapTessellator.DEFAULT_STRUCTURE = Object.freeze({\n  heightScale: 1.0,\n  heightOffset: 0.0,\n  elementsPerHeight: 1,\n  stride: 1,\n  elementMultiplier: 256.0,\n  isBigEndian: false,\n});\n\nvar cartesian3Scratch = new Cartesian3();\nvar matrix4Scratch = new Matrix4();\nvar minimumScratch = new Cartesian3();\nvar maximumScratch = new Cartesian3();\n\n/**\n * Fills an array of vertices from a heightmap image.\n *\n * @param {Object} options Object with the following properties:\n * @param {TypedArray} options.heightmap The heightmap to tessellate.\n * @param {Number} options.width The width of the heightmap, in height samples.\n * @param {Number} options.height The height of the heightmap, in height samples.\n * @param {Number} options.skirtHeight The height of skirts to drape at the edges of the heightmap.\n * @param {Rectangle} options.nativeRectangle A rectangle in the native coordinates of the heightmap's projection.  For\n *                 a heightmap with a geographic projection, this is degrees.  For the web mercator\n *                 projection, this is meters.\n * @param {Number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {Rectangle} [options.rectangle] The rectangle covered by the heightmap, in geodetic coordinates with north, south, east and\n *                 west properties in radians.  Either rectangle or nativeRectangle must be provided.  If both\n *                 are provided, they're assumed to be consistent.\n * @param {Boolean} [options.isGeographic=true] True if the heightmap uses a {@link GeographicProjection}, or false if it uses\n *                  a {@link WebMercatorProjection}.\n * @param {Cartesian3} [options.relativeToCenter=Cartesian3.ZERO] The positions will be computed as <code>Cartesian3.subtract(worldPosition, relativeToCenter)</code>.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to which the heightmap applies.\n * @param {Object} [options.structure] An object describing the structure of the height data.\n * @param {Number} [options.structure.heightScale=1.0] The factor by which to multiply height samples in order to obtain\n *                 the height above the heightOffset, in meters.  The heightOffset is added to the resulting\n *                 height after multiplying by the scale.\n * @param {Number} [options.structure.heightOffset=0.0] The offset to add to the scaled height to obtain the final\n *                 height in meters.  The offset is added after the height sample is multiplied by the\n *                 heightScale.\n * @param {Number} [options.structure.elementsPerHeight=1] The number of elements in the buffer that make up a single height\n *                 sample.  This is usually 1, indicating that each element is a separate height sample.  If\n *                 it is greater than 1, that number of elements together form the height sample, which is\n *                 computed according to the structure.elementMultiplier and structure.isBigEndian properties.\n * @param {Number} [options.structure.stride=1] The number of elements to skip to get from the first element of\n *                 one height to the first element of the next height.\n * @param {Number} [options.structure.elementMultiplier=256.0] The multiplier used to compute the height value when the\n *                 stride property is greater than 1.  For example, if the stride is 4 and the strideMultiplier\n *                 is 256, the height is computed as follows:\n *                 `height = buffer[index] + buffer[index + 1] * 256 + buffer[index + 2] * 256 * 256 + buffer[index + 3] * 256 * 256 * 256`\n *                 This is assuming that the isBigEndian property is false.  If it is true, the order of the\n *                 elements is reversed.\n * @param {Number} [options.structure.lowestEncodedHeight] The lowest value that can be stored in the height buffer.  Any heights that are lower\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be 0 because a `Uint16Array` cannot store negative numbers.  If this parameter is\n *                 not specified, no minimum value is enforced.\n * @param {Number} [options.structure.highestEncodedHeight] The highest value that can be stored in the height buffer.  Any heights that are higher\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be `256 * 256 - 1` or 65535 because a `Uint16Array` cannot store numbers larger\n *                 than 65535.  If this parameter is not specified, no maximum value is enforced.\n * @param {Boolean} [options.structure.isBigEndian=false] Indicates endianness of the elements in the buffer when the\n *                  stride property is greater than 1.  If this property is false, the first element is the\n *                  low-order element.  If it is true, the first element is the high-order element.\n *\n * @example\n * var width = 5;\n * var height = 5;\n * var statistics = Cesium.HeightmapTessellator.computeVertices({\n *     heightmap : [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0],\n *     width : width,\n *     height : height,\n *     skirtHeight : 0.0,\n *     nativeRectangle : {\n *         west : 10.0,\n *         east : 20.0,\n *         south : 30.0,\n *         north : 40.0\n *     }\n * });\n *\n * var encoding = statistics.encoding;\n * var position = encoding.decodePosition(statistics.vertices, index * encoding.getStride());\n */\nHeightmapTessellator.computeVertices = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.heightmap)) {\n    throw new DeveloperError(\"options.heightmap is required.\");\n  }\n  if (!defined(options.width) || !defined(options.height)) {\n    throw new DeveloperError(\"options.width and options.height are required.\");\n  }\n  if (!defined(options.nativeRectangle)) {\n    throw new DeveloperError(\"options.nativeRectangle is required.\");\n  }\n  if (!defined(options.skirtHeight)) {\n    throw new DeveloperError(\"options.skirtHeight is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // This function tends to be a performance hotspot for terrain rendering,\n  // so it employs a lot of inlining and unrolling as an optimization.\n  // In particular, the functionality of Ellipsoid.cartographicToCartesian\n  // is inlined.\n\n  var cos = Math.cos;\n  var sin = Math.sin;\n  var sqrt = Math.sqrt;\n  var atan = Math.atan;\n  var exp = Math.exp;\n  var piOverTwo = CesiumMath.PI_OVER_TWO;\n  var toRadians = CesiumMath.toRadians;\n\n  var heightmap = options.heightmap;\n  var width = options.width;\n  var height = options.height;\n  var skirtHeight = options.skirtHeight;\n\n  var isGeographic = defaultValue(options.isGeographic, true);\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n\n  var oneOverGlobeSemimajorAxis = 1.0 / ellipsoid.maximumRadius;\n\n  var nativeRectangle = options.nativeRectangle;\n\n  var geographicWest;\n  var geographicSouth;\n  var geographicEast;\n  var geographicNorth;\n\n  var rectangle = options.rectangle;\n  if (!defined(rectangle)) {\n    if (isGeographic) {\n      geographicWest = toRadians(nativeRectangle.west);\n      geographicSouth = toRadians(nativeRectangle.south);\n      geographicEast = toRadians(nativeRectangle.east);\n      geographicNorth = toRadians(nativeRectangle.north);\n    } else {\n      geographicWest = nativeRectangle.west * oneOverGlobeSemimajorAxis;\n      geographicSouth =\n        piOverTwo -\n        2.0 * atan(exp(-nativeRectangle.south * oneOverGlobeSemimajorAxis));\n      geographicEast = nativeRectangle.east * oneOverGlobeSemimajorAxis;\n      geographicNorth =\n        piOverTwo -\n        2.0 * atan(exp(-nativeRectangle.north * oneOverGlobeSemimajorAxis));\n    }\n  } else {\n    geographicWest = rectangle.west;\n    geographicSouth = rectangle.south;\n    geographicEast = rectangle.east;\n    geographicNorth = rectangle.north;\n  }\n\n  var relativeToCenter = options.relativeToCenter;\n  var hasRelativeToCenter = defined(relativeToCenter);\n  relativeToCenter = hasRelativeToCenter ? relativeToCenter : Cartesian3.ZERO;\n  var exaggeration = defaultValue(options.exaggeration, 1.0);\n  var includeWebMercatorT = defaultValue(options.includeWebMercatorT, false);\n\n  var structure = defaultValue(\n    options.structure,\n    HeightmapTessellator.DEFAULT_STRUCTURE\n  );\n  var heightScale = defaultValue(\n    structure.heightScale,\n    HeightmapTessellator.DEFAULT_STRUCTURE.heightScale\n  );\n  var heightOffset = defaultValue(\n    structure.heightOffset,\n    HeightmapTessellator.DEFAULT_STRUCTURE.heightOffset\n  );\n  var elementsPerHeight = defaultValue(\n    structure.elementsPerHeight,\n    HeightmapTessellator.DEFAULT_STRUCTURE.elementsPerHeight\n  );\n  var stride = defaultValue(\n    structure.stride,\n    HeightmapTessellator.DEFAULT_STRUCTURE.stride\n  );\n  var elementMultiplier = defaultValue(\n    structure.elementMultiplier,\n    HeightmapTessellator.DEFAULT_STRUCTURE.elementMultiplier\n  );\n  var isBigEndian = defaultValue(\n    structure.isBigEndian,\n    HeightmapTessellator.DEFAULT_STRUCTURE.isBigEndian\n  );\n\n  var rectangleWidth = Rectangle.computeWidth(nativeRectangle);\n  var rectangleHeight = Rectangle.computeHeight(nativeRectangle);\n\n  var granularityX = rectangleWidth / (width - 1);\n  var granularityY = rectangleHeight / (height - 1);\n\n  if (!isGeographic) {\n    rectangleWidth *= oneOverGlobeSemimajorAxis;\n    rectangleHeight *= oneOverGlobeSemimajorAxis;\n  }\n\n  var radiiSquared = ellipsoid.radiiSquared;\n  var radiiSquaredX = radiiSquared.x;\n  var radiiSquaredY = radiiSquared.y;\n  var radiiSquaredZ = radiiSquared.z;\n\n  var minimumHeight = 65536.0;\n  var maximumHeight = -65536.0;\n\n  var fromENU = Transforms.eastNorthUpToFixedFrame(relativeToCenter, ellipsoid);\n  var toENU = Matrix4.inverseTransformation(fromENU, matrix4Scratch);\n\n  var southMercatorY;\n  var oneOverMercatorHeight;\n  if (includeWebMercatorT) {\n    southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(\n      geographicSouth\n    );\n    oneOverMercatorHeight =\n      1.0 /\n      (WebMercatorProjection.geodeticLatitudeToMercatorAngle(geographicNorth) -\n        southMercatorY);\n  }\n\n  var minimum = minimumScratch;\n  minimum.x = Number.POSITIVE_INFINITY;\n  minimum.y = Number.POSITIVE_INFINITY;\n  minimum.z = Number.POSITIVE_INFINITY;\n\n  var maximum = maximumScratch;\n  maximum.x = Number.NEGATIVE_INFINITY;\n  maximum.y = Number.NEGATIVE_INFINITY;\n  maximum.z = Number.NEGATIVE_INFINITY;\n\n  var hMin = Number.POSITIVE_INFINITY;\n\n  var gridVertexCount = width * height;\n  var edgeVertexCount = skirtHeight > 0.0 ? width * 2 + height * 2 : 0;\n  var vertexCount = gridVertexCount + edgeVertexCount;\n\n  var positions = new Array(vertexCount);\n  var heights = new Array(vertexCount);\n  var uvs = new Array(vertexCount);\n  var webMercatorTs = includeWebMercatorT ? new Array(vertexCount) : [];\n\n  var startRow = 0;\n  var endRow = height;\n  var startCol = 0;\n  var endCol = width;\n\n  if (skirtHeight > 0.0) {\n    --startRow;\n    ++endRow;\n    --startCol;\n    ++endCol;\n  }\n\n  var skirtOffsetPercentage = 0.00001;\n\n  for (var rowIndex = startRow; rowIndex < endRow; ++rowIndex) {\n    var row = rowIndex;\n    if (row < 0) {\n      row = 0;\n    }\n    if (row >= height) {\n      row = height - 1;\n    }\n\n    var latitude = nativeRectangle.north - granularityY * row;\n\n    if (!isGeographic) {\n      latitude =\n        piOverTwo - 2.0 * atan(exp(-latitude * oneOverGlobeSemimajorAxis));\n    } else {\n      latitude = toRadians(latitude);\n    }\n\n    var v = (latitude - geographicSouth) / (geographicNorth - geographicSouth);\n    v = CesiumMath.clamp(v, 0.0, 1.0);\n\n    var isNorthEdge = rowIndex === startRow;\n    var isSouthEdge = rowIndex === endRow - 1;\n    if (skirtHeight > 0.0) {\n      if (isNorthEdge) {\n        latitude += skirtOffsetPercentage * rectangleHeight;\n      } else if (isSouthEdge) {\n        latitude -= skirtOffsetPercentage * rectangleHeight;\n      }\n    }\n\n    var cosLatitude = cos(latitude);\n    var nZ = sin(latitude);\n    var kZ = radiiSquaredZ * nZ;\n\n    var webMercatorT;\n    if (includeWebMercatorT) {\n      webMercatorT =\n        (WebMercatorProjection.geodeticLatitudeToMercatorAngle(latitude) -\n          southMercatorY) *\n        oneOverMercatorHeight;\n    }\n\n    for (var colIndex = startCol; colIndex < endCol; ++colIndex) {\n      var col = colIndex;\n      if (col < 0) {\n        col = 0;\n      }\n      if (col >= width) {\n        col = width - 1;\n      }\n\n      var terrainOffset = row * (width * stride) + col * stride;\n\n      var heightSample;\n      if (elementsPerHeight === 1) {\n        heightSample = heightmap[terrainOffset];\n      } else {\n        heightSample = 0;\n\n        var elementOffset;\n        if (isBigEndian) {\n          for (\n            elementOffset = 0;\n            elementOffset < elementsPerHeight;\n            ++elementOffset\n          ) {\n            heightSample =\n              heightSample * elementMultiplier +\n              heightmap[terrainOffset + elementOffset];\n          }\n        } else {\n          for (\n            elementOffset = elementsPerHeight - 1;\n            elementOffset >= 0;\n            --elementOffset\n          ) {\n            heightSample =\n              heightSample * elementMultiplier +\n              heightmap[terrainOffset + elementOffset];\n          }\n        }\n      }\n\n      heightSample = (heightSample * heightScale + heightOffset) * exaggeration;\n\n      maximumHeight = Math.max(maximumHeight, heightSample);\n      minimumHeight = Math.min(minimumHeight, heightSample);\n\n      var longitude = nativeRectangle.west + granularityX * col;\n\n      if (!isGeographic) {\n        longitude = longitude * oneOverGlobeSemimajorAxis;\n      } else {\n        longitude = toRadians(longitude);\n      }\n\n      var u = (longitude - geographicWest) / (geographicEast - geographicWest);\n      u = CesiumMath.clamp(u, 0.0, 1.0);\n\n      var index = row * width + col;\n\n      if (skirtHeight > 0.0) {\n        var isWestEdge = colIndex === startCol;\n        var isEastEdge = colIndex === endCol - 1;\n        var isEdge = isNorthEdge || isSouthEdge || isWestEdge || isEastEdge;\n        var isCorner =\n          (isNorthEdge || isSouthEdge) && (isWestEdge || isEastEdge);\n        if (isCorner) {\n          // Don't generate skirts on the corners.\n          continue;\n        } else if (isEdge) {\n          heightSample -= skirtHeight;\n\n          if (isWestEdge) {\n            // The outer loop iterates north to south but the indices are ordered south to north, hence the index flip below\n            index = gridVertexCount + (height - row - 1);\n            longitude -= skirtOffsetPercentage * rectangleWidth;\n          } else if (isSouthEdge) {\n            // Add after west indices. South indices are ordered east to west.\n            index = gridVertexCount + height + (width - col - 1);\n          } else if (isEastEdge) {\n            // Add after west and south indices. East indices are ordered north to south. The index is flipped like above.\n            index = gridVertexCount + height + width + row;\n            longitude += skirtOffsetPercentage * rectangleWidth;\n          } else if (isNorthEdge) {\n            // Add after west, south, and east indices. North indices are ordered west to east.\n            index = gridVertexCount + height + width + height + col;\n          }\n        }\n      }\n\n      var nX = cosLatitude * cos(longitude);\n      var nY = cosLatitude * sin(longitude);\n\n      var kX = radiiSquaredX * nX;\n      var kY = radiiSquaredY * nY;\n\n      var gamma = sqrt(kX * nX + kY * nY + kZ * nZ);\n      var oneOverGamma = 1.0 / gamma;\n\n      var rSurfaceX = kX * oneOverGamma;\n      var rSurfaceY = kY * oneOverGamma;\n      var rSurfaceZ = kZ * oneOverGamma;\n\n      var position = new Cartesian3();\n      position.x = rSurfaceX + nX * heightSample;\n      position.y = rSurfaceY + nY * heightSample;\n      position.z = rSurfaceZ + nZ * heightSample;\n\n      positions[index] = position;\n      heights[index] = heightSample;\n      uvs[index] = new Cartesian2(u, v);\n\n      if (includeWebMercatorT) {\n        webMercatorTs[index] = webMercatorT;\n      }\n\n      Matrix4.multiplyByPoint(toENU, position, cartesian3Scratch);\n\n      Cartesian3.minimumByComponent(cartesian3Scratch, minimum, minimum);\n      Cartesian3.maximumByComponent(cartesian3Scratch, maximum, maximum);\n      hMin = Math.min(hMin, heightSample);\n    }\n  }\n\n  var boundingSphere3D = BoundingSphere.fromPoints(positions);\n  var orientedBoundingBox;\n  if (defined(rectangle)) {\n    orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n      rectangle,\n      minimumHeight,\n      maximumHeight,\n      ellipsoid\n    );\n  }\n\n  var occludeePointInScaledSpace;\n  if (hasRelativeToCenter) {\n    var occluder = new EllipsoidalOccluder(ellipsoid);\n    occludeePointInScaledSpace = occluder.computeHorizonCullingPointPossiblyUnderEllipsoid(\n      relativeToCenter,\n      positions,\n      minimumHeight\n    );\n  }\n\n  var aaBox = new AxisAlignedBoundingBox(minimum, maximum, relativeToCenter);\n  var encoding = new TerrainEncoding(\n    aaBox,\n    hMin,\n    maximumHeight,\n    fromENU,\n    false,\n    includeWebMercatorT\n  );\n  var vertices = new Float32Array(vertexCount * encoding.getStride());\n\n  var bufferIndex = 0;\n  for (var j = 0; j < vertexCount; ++j) {\n    bufferIndex = encoding.encode(\n      vertices,\n      bufferIndex,\n      positions[j],\n      uvs[j],\n      heights[j],\n      undefined,\n      webMercatorTs[j]\n    );\n  }\n\n  return {\n    vertices: vertices,\n    maximumHeight: maximumHeight,\n    minimumHeight: minimumHeight,\n    encoding: encoding,\n    boundingSphere3D: boundingSphere3D,\n    orientedBoundingBox: orientedBoundingBox,\n    occludeePointInScaledSpace: occludeePointInScaledSpace,\n  };\n};\nexport default HeightmapTessellator;\n"]},"metadata":{},"sourceType":"module"}