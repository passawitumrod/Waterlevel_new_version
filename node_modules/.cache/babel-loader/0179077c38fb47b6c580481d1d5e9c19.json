{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport BoxOutlineGeometry from \"../Core/BoxOutlineGeometry.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nvar scratchU = new Cartesian3();\nvar scratchV = new Cartesian3();\nvar scratchW = new Cartesian3();\nvar scratchCartesian = new Cartesian3();\n\nfunction computeMissingVector(a, b, result) {\n  result = Cartesian3.cross(a, b, result);\n  var magnitude = Cartesian3.magnitude(result);\n  return Cartesian3.multiplyByScalar(result, CesiumMath.EPSILON7 / magnitude, result);\n}\n\nfunction findOrthogonalVector(a, result) {\n  var temp = Cartesian3.normalize(a, scratchCartesian);\n  var b = Cartesian3.equalsEpsilon(temp, Cartesian3.UNIT_X, CesiumMath.EPSILON6) ? Cartesian3.UNIT_Y : Cartesian3.UNIT_X;\n  return computeMissingVector(a, b, result);\n}\n\nfunction checkHalfAxes(halfAxes) {\n  var u = Matrix3.getColumn(halfAxes, 0, scratchU);\n  var v = Matrix3.getColumn(halfAxes, 1, scratchV);\n  var w = Matrix3.getColumn(halfAxes, 2, scratchW);\n  var uZero = Cartesian3.equals(u, Cartesian3.ZERO);\n  var vZero = Cartesian3.equals(v, Cartesian3.ZERO);\n  var wZero = Cartesian3.equals(w, Cartesian3.ZERO);\n\n  if (!uZero && !vZero && !wZero) {\n    return halfAxes;\n  }\n\n  if (uZero && vZero && wZero) {\n    halfAxes[0] = CesiumMath.EPSILON7;\n    halfAxes[4] = CesiumMath.EPSILON7;\n    halfAxes[8] = CesiumMath.EPSILON7;\n    return halfAxes;\n  }\n\n  if (uZero && !vZero && !wZero) {\n    u = computeMissingVector(v, w, u);\n  } else if (!uZero && vZero && !wZero) {\n    v = computeMissingVector(u, w, v);\n  } else if (!uZero && !vZero && wZero) {\n    w = computeMissingVector(v, u, w);\n  } else if (!uZero) {\n    v = findOrthogonalVector(u, v);\n    w = computeMissingVector(v, u, w);\n  } else if (!vZero) {\n    u = findOrthogonalVector(v, u);\n    w = computeMissingVector(v, u, w);\n  } else if (!wZero) {\n    u = findOrthogonalVector(w, u);\n    v = computeMissingVector(w, u, v);\n  }\n\n  Matrix3.setColumn(halfAxes, 0, u, halfAxes);\n  Matrix3.setColumn(halfAxes, 1, v, halfAxes);\n  Matrix3.setColumn(halfAxes, 2, w, halfAxes);\n  return halfAxes;\n}\n/**\n * A tile bounding volume specified as an oriented bounding box.\n * @alias TileOrientedBoundingBox\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the box.\n * @param {Matrix3} [halfAxes=Matrix3.ZERO] The three orthogonal half-axes of the bounding box.\n *                                          Equivalently, the transformation matrix, to rotate and scale a 2x2x2\n *                                          cube centered at the origin.\n *\n * @private\n */\n\n\nfunction TileOrientedBoundingBox(center, halfAxes) {\n  halfAxes = checkHalfAxes(halfAxes);\n  this._orientedBoundingBox = new OrientedBoundingBox(center, halfAxes);\n  this._boundingSphere = BoundingSphere.fromOrientedBoundingBox(this._orientedBoundingBox);\n}\n\nObject.defineProperties(TileOrientedBoundingBox.prototype, {\n  /**\n   * The underlying bounding volume.\n   *\n   * @memberof TileOrientedBoundingBox.prototype\n   *\n   * @type {Object}\n   * @readonly\n   */\n  boundingVolume: {\n    get: function get() {\n      return this._orientedBoundingBox;\n    }\n  },\n\n  /**\n   * The underlying bounding sphere.\n   *\n   * @memberof TileOrientedBoundingBox.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function get() {\n      return this._boundingSphere;\n    }\n  }\n});\n/**\n * Computes the distance between this bounding box and the camera attached to frameState.\n *\n * @param {FrameState} frameState The frameState to which the camera is attached.\n * @returns {Number} The distance between the camera and the bounding box in meters. Returns 0 if the camera is inside the bounding volume.\n */\n\nTileOrientedBoundingBox.prototype.distanceToCamera = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"frameState\", frameState); //>>includeEnd('debug');\n\n  return Math.sqrt(this._orientedBoundingBox.distanceSquaredTo(frameState.camera.positionWC));\n};\n/**\n * Determines which side of a plane this box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\n\n\nTileOrientedBoundingBox.prototype.intersectPlane = function (plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"plane\", plane); //>>includeEnd('debug');\n\n  return this._orientedBoundingBox.intersectPlane(plane);\n};\n/**\n * Update the bounding box after the tile is transformed.\n *\n * @param {Cartesian3} center The center of the box.\n * @param {Matrix3} halfAxes The three orthogonal half-axes of the bounding box.\n *                           Equivalently, the transformation matrix, to rotate and scale a 2x2x2\n *                           cube centered at the origin.\n */\n\n\nTileOrientedBoundingBox.prototype.update = function (center, halfAxes) {\n  Cartesian3.clone(center, this._orientedBoundingBox.center);\n  halfAxes = checkHalfAxes(halfAxes);\n  Matrix3.clone(halfAxes, this._orientedBoundingBox.halfAxes);\n  BoundingSphere.fromOrientedBoundingBox(this._orientedBoundingBox, this._boundingSphere);\n};\n/**\n * Creates a debug primitive that shows the outline of the box.\n *\n * @param {Color} color The desired color of the primitive's mesh\n * @return {Primitive}\n */\n\n\nTileOrientedBoundingBox.prototype.createDebugVolume = function (color) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"color\", color); //>>includeEnd('debug');\n\n  var geometry = new BoxOutlineGeometry({\n    // Make a 2x2x2 cube\n    minimum: new Cartesian3(-1.0, -1.0, -1.0),\n    maximum: new Cartesian3(1.0, 1.0, 1.0)\n  });\n  var modelMatrix = Matrix4.fromRotationTranslation(this.boundingVolume.halfAxes, this.boundingVolume.center);\n  var instance = new GeometryInstance({\n    geometry: geometry,\n    id: \"outline\",\n    modelMatrix: modelMatrix,\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color)\n    }\n  });\n  return new Primitive({\n    geometryInstances: instance,\n    appearance: new PerInstanceColorAppearance({\n      translucent: false,\n      flat: true\n    }),\n    asynchronous: false\n  });\n};\n\nexport default TileOrientedBoundingBox;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/TileOrientedBoundingBox.js"],"names":["BoundingSphere","BoxOutlineGeometry","Cartesian3","Check","ColorGeometryInstanceAttribute","GeometryInstance","Matrix3","Matrix4","CesiumMath","OrientedBoundingBox","PerInstanceColorAppearance","Primitive","scratchU","scratchV","scratchW","scratchCartesian","computeMissingVector","a","b","result","cross","magnitude","multiplyByScalar","EPSILON7","findOrthogonalVector","temp","normalize","equalsEpsilon","UNIT_X","EPSILON6","UNIT_Y","checkHalfAxes","halfAxes","u","getColumn","v","w","uZero","equals","ZERO","vZero","wZero","setColumn","TileOrientedBoundingBox","center","_orientedBoundingBox","_boundingSphere","fromOrientedBoundingBox","Object","defineProperties","prototype","boundingVolume","get","boundingSphere","distanceToCamera","frameState","defined","Math","sqrt","distanceSquaredTo","camera","positionWC","intersectPlane","plane","update","clone","createDebugVolume","color","geometry","minimum","maximum","modelMatrix","fromRotationTranslation","instance","id","attributes","fromColor","geometryInstances","appearance","translucent","flat","asynchronous"],"mappings":"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","sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport BoxOutlineGeometry from \"../Core/BoxOutlineGeometry.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\n\nvar scratchU = new Cartesian3();\nvar scratchV = new Cartesian3();\nvar scratchW = new Cartesian3();\nvar scratchCartesian = new Cartesian3();\n\nfunction computeMissingVector(a, b, result) {\n  result = Cartesian3.cross(a, b, result);\n  var magnitude = Cartesian3.magnitude(result);\n  return Cartesian3.multiplyByScalar(\n    result,\n    CesiumMath.EPSILON7 / magnitude,\n    result\n  );\n}\n\nfunction findOrthogonalVector(a, result) {\n  var temp = Cartesian3.normalize(a, scratchCartesian);\n  var b = Cartesian3.equalsEpsilon(temp, Cartesian3.UNIT_X, CesiumMath.EPSILON6)\n    ? Cartesian3.UNIT_Y\n    : Cartesian3.UNIT_X;\n  return computeMissingVector(a, b, result);\n}\n\nfunction checkHalfAxes(halfAxes) {\n  var u = Matrix3.getColumn(halfAxes, 0, scratchU);\n  var v = Matrix3.getColumn(halfAxes, 1, scratchV);\n  var w = Matrix3.getColumn(halfAxes, 2, scratchW);\n\n  var uZero = Cartesian3.equals(u, Cartesian3.ZERO);\n  var vZero = Cartesian3.equals(v, Cartesian3.ZERO);\n  var wZero = Cartesian3.equals(w, Cartesian3.ZERO);\n\n  if (!uZero && !vZero && !wZero) {\n    return halfAxes;\n  }\n  if (uZero && vZero && wZero) {\n    halfAxes[0] = CesiumMath.EPSILON7;\n    halfAxes[4] = CesiumMath.EPSILON7;\n    halfAxes[8] = CesiumMath.EPSILON7;\n    return halfAxes;\n  }\n  if (uZero && !vZero && !wZero) {\n    u = computeMissingVector(v, w, u);\n  } else if (!uZero && vZero && !wZero) {\n    v = computeMissingVector(u, w, v);\n  } else if (!uZero && !vZero && wZero) {\n    w = computeMissingVector(v, u, w);\n  } else if (!uZero) {\n    v = findOrthogonalVector(u, v);\n    w = computeMissingVector(v, u, w);\n  } else if (!vZero) {\n    u = findOrthogonalVector(v, u);\n    w = computeMissingVector(v, u, w);\n  } else if (!wZero) {\n    u = findOrthogonalVector(w, u);\n    v = computeMissingVector(w, u, v);\n  }\n\n  Matrix3.setColumn(halfAxes, 0, u, halfAxes);\n  Matrix3.setColumn(halfAxes, 1, v, halfAxes);\n  Matrix3.setColumn(halfAxes, 2, w, halfAxes);\n\n  return halfAxes;\n}\n\n/**\n * A tile bounding volume specified as an oriented bounding box.\n * @alias TileOrientedBoundingBox\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the box.\n * @param {Matrix3} [halfAxes=Matrix3.ZERO] The three orthogonal half-axes of the bounding box.\n *                                          Equivalently, the transformation matrix, to rotate and scale a 2x2x2\n *                                          cube centered at the origin.\n *\n * @private\n */\nfunction TileOrientedBoundingBox(center, halfAxes) {\n  halfAxes = checkHalfAxes(halfAxes);\n  this._orientedBoundingBox = new OrientedBoundingBox(center, halfAxes);\n  this._boundingSphere = BoundingSphere.fromOrientedBoundingBox(\n    this._orientedBoundingBox\n  );\n}\n\nObject.defineProperties(TileOrientedBoundingBox.prototype, {\n  /**\n   * The underlying bounding volume.\n   *\n   * @memberof TileOrientedBoundingBox.prototype\n   *\n   * @type {Object}\n   * @readonly\n   */\n  boundingVolume: {\n    get: function () {\n      return this._orientedBoundingBox;\n    },\n  },\n  /**\n   * The underlying bounding sphere.\n   *\n   * @memberof TileOrientedBoundingBox.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    },\n  },\n});\n\n/**\n * Computes the distance between this bounding box and the camera attached to frameState.\n *\n * @param {FrameState} frameState The frameState to which the camera is attached.\n * @returns {Number} The distance between the camera and the bounding box in meters. Returns 0 if the camera is inside the bounding volume.\n */\nTileOrientedBoundingBox.prototype.distanceToCamera = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"frameState\", frameState);\n  //>>includeEnd('debug');\n  return Math.sqrt(\n    this._orientedBoundingBox.distanceSquaredTo(frameState.camera.positionWC)\n  );\n};\n\n/**\n * Determines which side of a plane this box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nTileOrientedBoundingBox.prototype.intersectPlane = function (plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"plane\", plane);\n  //>>includeEnd('debug');\n  return this._orientedBoundingBox.intersectPlane(plane);\n};\n\n/**\n * Update the bounding box after the tile is transformed.\n *\n * @param {Cartesian3} center The center of the box.\n * @param {Matrix3} halfAxes The three orthogonal half-axes of the bounding box.\n *                           Equivalently, the transformation matrix, to rotate and scale a 2x2x2\n *                           cube centered at the origin.\n */\nTileOrientedBoundingBox.prototype.update = function (center, halfAxes) {\n  Cartesian3.clone(center, this._orientedBoundingBox.center);\n  halfAxes = checkHalfAxes(halfAxes);\n  Matrix3.clone(halfAxes, this._orientedBoundingBox.halfAxes);\n  BoundingSphere.fromOrientedBoundingBox(\n    this._orientedBoundingBox,\n    this._boundingSphere\n  );\n};\n\n/**\n * Creates a debug primitive that shows the outline of the box.\n *\n * @param {Color} color The desired color of the primitive's mesh\n * @return {Primitive}\n */\nTileOrientedBoundingBox.prototype.createDebugVolume = function (color) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"color\", color);\n  //>>includeEnd('debug');\n\n  var geometry = new BoxOutlineGeometry({\n    // Make a 2x2x2 cube\n    minimum: new Cartesian3(-1.0, -1.0, -1.0),\n    maximum: new Cartesian3(1.0, 1.0, 1.0),\n  });\n  var modelMatrix = Matrix4.fromRotationTranslation(\n    this.boundingVolume.halfAxes,\n    this.boundingVolume.center\n  );\n  var instance = new GeometryInstance({\n    geometry: geometry,\n    id: \"outline\",\n    modelMatrix: modelMatrix,\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color),\n    },\n  });\n\n  return new Primitive({\n    geometryInstances: instance,\n    appearance: new PerInstanceColorAppearance({\n      translucent: false,\n      flat: true,\n    }),\n    asynchronous: false,\n  });\n};\nexport default TileOrientedBoundingBox;\n"]},"metadata":{},"sourceType":"module"}