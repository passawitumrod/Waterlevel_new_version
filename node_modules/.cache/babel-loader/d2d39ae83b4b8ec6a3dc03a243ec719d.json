{"ast":null,"code":"import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n/**\n * A 3D Cartesian point.\n * @alias Cartesian3\n * @constructor\n *\n * @param {Number} [x=0.0] The X component.\n * @param {Number} [y=0.0] The Y component.\n * @param {Number} [z=0.0] The Z component.\n *\n * @see Cartesian2\n * @see Cartesian4\n * @see Packable\n */\n\nfunction Cartesian3(x, y, z) {\n  /**\n   * The X component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.x = defaultValue(x, 0.0);\n  /**\n   * The Y component.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.y = defaultValue(y, 0.0);\n  /**\n   * The Z component.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.z = defaultValue(z, 0.0);\n}\n/**\n * Converts the provided Spherical into Cartesian3 coordinates.\n *\n * @param {Spherical} spherical The Spherical to be converted to Cartesian3.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\n\n\nCartesian3.fromSpherical = function (spherical, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"spherical\", spherical); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  var clock = spherical.clock;\n  var cone = spherical.cone;\n  var magnitude = defaultValue(spherical.magnitude, 1.0);\n  var radial = magnitude * Math.sin(cone);\n  result.x = radial * Math.cos(clock);\n  result.y = radial * Math.sin(clock);\n  result.z = magnitude * Math.cos(cone);\n  return result;\n};\n/**\n * Creates a Cartesian3 instance from x, y and z coordinates.\n *\n * @param {Number} x The x coordinate.\n * @param {Number} y The y coordinate.\n * @param {Number} z The z coordinate.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\n\n\nCartesian3.fromElements = function (x, y, z, result) {\n  if (!defined(result)) {\n    return new Cartesian3(x, y, z);\n  }\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n/**\n * Duplicates a Cartesian3 instance.\n *\n * @param {Cartesian3} cartesian The Cartesian to duplicate.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\n\n\nCartesian3.clone = function (cartesian, result) {\n  if (!defined(cartesian)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Cartesian3(cartesian.x, cartesian.y, cartesian.z);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  result.z = cartesian.z;\n  return result;\n};\n/**\n * Creates a Cartesian3 instance from an existing Cartesian4.  This simply takes the\n * x, y, and z properties of the Cartesian4 and drops w.\n * @function\n *\n * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian3 instance from.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\n\n\nCartesian3.fromCartesian4 = Cartesian3.clone;\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\n\nCartesian3.packedLength = 3;\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian3} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\nCartesian3.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex] = value.z;\n  return array;\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian3} [result] The object into which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\n\n\nCartesian3.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex++];\n  result.z = array[startingIndex];\n  return result;\n};\n/**\n * Flattens an array of Cartesian3s into an array of components.\n *\n * @param {Cartesian3[]} array The array of cartesians to pack.\n * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 3 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 3) elements.\n * @returns {Number[]} The packed array.\n */\n\n\nCartesian3.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  var length = array.length;\n  var resultLength = length * 3;\n\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    throw new DeveloperError(\"If result is a typed array, it must have exactly array.length * 3 elements\");\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    Cartesian3.pack(array[i], result, i * 3);\n  }\n\n  return result;\n};\n/**\n * Unpacks an array of cartesian components into an array of Cartesian3s.\n *\n * @param {Number[]} array The array of components to unpack.\n * @param {Cartesian3[]} [result] The array onto which to store the result.\n * @returns {Cartesian3[]} The unpacked array.\n */\n\n\nCartesian3.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 3);\n\n  if (array.length % 3 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 3.\");\n  } //>>includeEnd('debug');\n\n\n  var length = array.length;\n\n  if (!defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (var i = 0; i < length; i += 3) {\n    var index = i / 3;\n    result[index] = Cartesian3.unpack(array, i, result[index]);\n  }\n\n  return result;\n};\n/**\n * Creates a Cartesian3 from three consecutive elements in an array.\n * @function\n *\n * @param {Number[]} array The array whose three consecutive elements correspond to the x, y, and z components, respectively.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian3 with (1.0, 2.0, 3.0)\n * var v = [1.0, 2.0, 3.0];\n * var p = Cesium.Cartesian3.fromArray(v);\n *\n * // Create a Cartesian3 with (1.0, 2.0, 3.0) using an offset into an array\n * var v2 = [0.0, 0.0, 1.0, 2.0, 3.0];\n * var p2 = Cesium.Cartesian3.fromArray(v2, 2);\n */\n\n\nCartesian3.fromArray = Cartesian3.unpack;\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The cartesian to use.\n * @returns {Number} The value of the maximum component.\n */\n\nCartesian3.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian); //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y, cartesian.z);\n};\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The cartesian to use.\n * @returns {Number} The value of the minimum component.\n */\n\n\nCartesian3.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian); //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y, cartesian.z);\n};\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian3} first A cartesian to compare.\n * @param {Cartesian3} second A cartesian to compare.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} A cartesian with the minimum components.\n */\n\n\nCartesian3.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n  result.z = Math.min(first.z, second.z);\n  return result;\n};\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian3} first A cartesian to compare.\n * @param {Cartesian3} second A cartesian to compare.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} A cartesian with the maximum components.\n */\n\n\nCartesian3.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  result.z = Math.max(first.z, second.z);\n  return result;\n};\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian3} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {Number} The squared magnitude.\n */\n\n\nCartesian3.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian); //>>includeEnd('debug');\n\n  return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z;\n};\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian3} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {Number} The magnitude.\n */\n\n\nCartesian3.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian3.magnitudeSquared(cartesian));\n};\n\nvar distanceScratch = new Cartesian3();\n/**\n * Computes the distance between two points.\n *\n * @param {Cartesian3} left The first point to compute the distance from.\n * @param {Cartesian3} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * var d = Cesium.Cartesian3.distance(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(2.0, 0.0, 0.0));\n */\n\nCartesian3.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right); //>>includeEnd('debug');\n\n  Cartesian3.subtract(left, right, distanceScratch);\n  return Cartesian3.magnitude(distanceScratch);\n};\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian3#distance}.\n *\n * @param {Cartesian3} left The first point to compute the distance from.\n * @param {Cartesian3} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * var d = Cesium.Cartesian3.distanceSquared(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(3.0, 0.0, 0.0));\n */\n\n\nCartesian3.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right); //>>includeEnd('debug');\n\n  Cartesian3.subtract(left, right, distanceScratch);\n  return Cartesian3.magnitudeSquared(distanceScratch);\n};\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian to be normalized.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\n\n\nCartesian3.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var magnitude = Cartesian3.magnitude(cartesian);\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n  result.z = cartesian.z / magnitude; //>>includeStart('debug', pragmas.debug);\n\n  if (isNaN(result.x) || isNaN(result.y) || isNaN(result.z)) {\n    throw new DeveloperError(\"normalized result is not a number\");\n  } //>>includeEnd('debug');\n\n\n  return result;\n};\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @returns {Number} The dot product.\n */\n\n\nCartesian3.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right); //>>includeEnd('debug');\n\n  return left.x * right.x + left.y * right.y + left.z * right.z;\n};\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\n\n\nCartesian3.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  result.z = left.z * right.z;\n  return result;\n};\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\n\n\nCartesian3.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  result.z = left.z / right.z;\n  return result;\n};\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\n\n\nCartesian3.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  return result;\n};\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\n\n\nCartesian3.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  return result;\n};\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian3} cartesian The Cartesian to be scaled.\n * @param {Number} scalar The scalar to multiply with.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\n\n\nCartesian3.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  result.z = cartesian.z * scalar;\n  return result;\n};\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian3} cartesian The Cartesian to be divided.\n * @param {Number} scalar The scalar to divide by.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\n\n\nCartesian3.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  result.z = cartesian.z / scalar;\n  return result;\n};\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian to be negated.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\n\n\nCartesian3.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  result.z = -cartesian.z;\n  return result;\n};\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\n\n\nCartesian3.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  result.z = Math.abs(cartesian.z);\n  return result;\n};\n\nvar lerpScratch = new Cartesian3();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian3} start The value corresponding to t at 0.0.\n * @param {Cartesian3} end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\n\nCartesian3.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  Cartesian3.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian3.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian3.add(lerpScratch, result, result);\n};\n\nvar angleBetweenScratch = new Cartesian3();\nvar angleBetweenScratch2 = new Cartesian3();\n/**\n * Returns the angle, in radians, between the provided Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @returns {Number} The angle between the Cartesians.\n */\n\nCartesian3.angleBetween = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right); //>>includeEnd('debug');\n\n  Cartesian3.normalize(left, angleBetweenScratch);\n  Cartesian3.normalize(right, angleBetweenScratch2);\n  var cosine = Cartesian3.dot(angleBetweenScratch, angleBetweenScratch2);\n  var sine = Cartesian3.magnitude(Cartesian3.cross(angleBetweenScratch, angleBetweenScratch2, angleBetweenScratch));\n  return Math.atan2(sine, cosine);\n};\n\nvar mostOrthogonalAxisScratch = new Cartesian3();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The most orthogonal axis.\n */\n\nCartesian3.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var f = Cartesian3.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian3.abs(f, f);\n\n  if (f.x <= f.y) {\n    if (f.x <= f.z) {\n      result = Cartesian3.clone(Cartesian3.UNIT_X, result);\n    } else {\n      result = Cartesian3.clone(Cartesian3.UNIT_Z, result);\n    }\n  } else if (f.y <= f.z) {\n    result = Cartesian3.clone(Cartesian3.UNIT_Y, result);\n  } else {\n    result = Cartesian3.clone(Cartesian3.UNIT_Z, result);\n  }\n\n  return result;\n};\n/**\n * Projects vector a onto vector b\n * @param {Cartesian3} a The vector that needs projecting\n * @param {Cartesian3} b The vector to project onto\n * @param {Cartesian3} result The result cartesian\n * @returns {Cartesian3} The modified result parameter\n */\n\n\nCartesian3.projectVector = function (a, b, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"a\", a);\n  Check.defined(\"b\", b);\n  Check.defined(\"result\", result); //>>includeEnd('debug');\n\n  var scalar = Cartesian3.dot(a, b) / Cartesian3.dot(b, b);\n  return Cartesian3.multiplyByScalar(b, scalar, result);\n};\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian3} [left] The first Cartesian.\n * @param {Cartesian3} [right] The second Cartesian.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\n\n\nCartesian3.equals = function (left, right) {\n  return left === right || defined(left) && defined(right) && left.x === right.x && left.y === right.y && left.z === right.z;\n};\n/**\n * @private\n */\n\n\nCartesian3.equalsArray = function (cartesian, array, offset) {\n  return cartesian.x === array[offset] && cartesian.y === array[offset + 1] && cartesian.z === array[offset + 2];\n};\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian3} [left] The first Cartesian.\n * @param {Cartesian3} [right] The second Cartesian.\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\n\n\nCartesian3.equalsEpsilon = function (left, right, relativeEpsilon, absoluteEpsilon) {\n  return left === right || defined(left) && defined(right) && CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.z, right.z, relativeEpsilon, absoluteEpsilon);\n};\n/**\n * Computes the cross (outer) product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The cross product.\n */\n\n\nCartesian3.cross = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var leftX = left.x;\n  var leftY = left.y;\n  var leftZ = left.z;\n  var rightX = right.x;\n  var rightY = right.y;\n  var rightZ = right.z;\n  var x = leftY * rightZ - leftZ * rightY;\n  var y = leftZ * rightX - leftX * rightZ;\n  var z = leftX * rightY - leftY * rightX;\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n/**\n * Computes the midpoint between the right and left Cartesian.\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The midpoint.\n */\n\n\nCartesian3.midpoint = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = (left.x + right.x) * 0.5;\n  result.y = (left.y + right.y) * 0.5;\n  result.z = (left.z + right.z) * 0.5;\n  return result;\n};\n/**\n * Returns a Cartesian3 position from longitude and latitude values given in degrees.\n *\n * @param {Number} longitude The longitude, in degrees\n * @param {Number} latitude The latitude, in degrees\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n *\n * @example\n * var position = Cesium.Cartesian3.fromDegrees(-115.0, 37.0);\n */\n\n\nCartesian3.fromDegrees = function (longitude, latitude, height, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"longitude\", longitude);\n  Check.typeOf.number(\"latitude\", latitude); //>>includeEnd('debug');\n\n  longitude = CesiumMath.toRadians(longitude);\n  latitude = CesiumMath.toRadians(latitude);\n  return Cartesian3.fromRadians(longitude, latitude, height, ellipsoid, result);\n};\n\nvar scratchN = new Cartesian3();\nvar scratchK = new Cartesian3();\nvar wgs84RadiiSquared = new Cartesian3(6378137.0 * 6378137.0, 6378137.0 * 6378137.0, 6356752.3142451793 * 6356752.3142451793);\n/**\n * Returns a Cartesian3 position from longitude and latitude values given in radians.\n *\n * @param {Number} longitude The longitude, in radians\n * @param {Number} latitude The latitude, in radians\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n *\n * @example\n * var position = Cesium.Cartesian3.fromRadians(-2.007, 0.645);\n */\n\nCartesian3.fromRadians = function (longitude, latitude, height, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"longitude\", longitude);\n  Check.typeOf.number(\"latitude\", latitude); //>>includeEnd('debug');\n\n  height = defaultValue(height, 0.0);\n  var radiiSquared = defined(ellipsoid) ? ellipsoid.radiiSquared : wgs84RadiiSquared;\n  var cosLatitude = Math.cos(latitude);\n  scratchN.x = cosLatitude * Math.cos(longitude);\n  scratchN.y = cosLatitude * Math.sin(longitude);\n  scratchN.z = Math.sin(latitude);\n  scratchN = Cartesian3.normalize(scratchN, scratchN);\n  Cartesian3.multiplyComponents(radiiSquared, scratchN, scratchK);\n  var gamma = Math.sqrt(Cartesian3.dot(scratchN, scratchK));\n  scratchK = Cartesian3.divideByScalar(scratchK, gamma, scratchK);\n  scratchN = Cartesian3.multiplyByScalar(scratchN, height, scratchN);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  return Cartesian3.add(scratchK, scratchN, result);\n};\n/**\n * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in degrees.\n *\n * @param {Number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the coordinates lie.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromDegreesArray([-115.0, 37.0, -107.0, 33.0]);\n */\n\n\nCartesian3.fromDegreesArray = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n\n  if (coordinates.length < 2 || coordinates.length % 2 !== 0) {\n    throw new DeveloperError(\"the number of coordinates must be a multiple of 2 and at least 2\");\n  } //>>includeEnd('debug');\n\n\n  var length = coordinates.length;\n\n  if (!defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (var i = 0; i < length; i += 2) {\n    var longitude = coordinates[i];\n    var latitude = coordinates[i + 1];\n    var index = i / 2;\n    result[index] = Cartesian3.fromDegrees(longitude, latitude, 0, ellipsoid, result[index]);\n  }\n\n  return result;\n};\n/**\n * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in radians.\n *\n * @param {Number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the coordinates lie.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromRadiansArray([-2.007, 0.645, -1.867, .575]);\n */\n\n\nCartesian3.fromRadiansArray = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n\n  if (coordinates.length < 2 || coordinates.length % 2 !== 0) {\n    throw new DeveloperError(\"the number of coordinates must be a multiple of 2 and at least 2\");\n  } //>>includeEnd('debug');\n\n\n  var length = coordinates.length;\n\n  if (!defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (var i = 0; i < length; i += 2) {\n    var longitude = coordinates[i];\n    var latitude = coordinates[i + 1];\n    var index = i / 2;\n    result[index] = Cartesian3.fromRadians(longitude, latitude, 0, ellipsoid, result[index]);\n  }\n\n  return result;\n};\n/**\n * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in degrees.\n *\n * @param {Number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromDegreesArrayHeights([-115.0, 37.0, 100000.0, -107.0, 33.0, 150000.0]);\n */\n\n\nCartesian3.fromDegreesArrayHeights = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n\n  if (coordinates.length < 3 || coordinates.length % 3 !== 0) {\n    throw new DeveloperError(\"the number of coordinates must be a multiple of 3 and at least 3\");\n  } //>>includeEnd('debug');\n\n\n  var length = coordinates.length;\n\n  if (!defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (var i = 0; i < length; i += 3) {\n    var longitude = coordinates[i];\n    var latitude = coordinates[i + 1];\n    var height = coordinates[i + 2];\n    var index = i / 3;\n    result[index] = Cartesian3.fromDegrees(longitude, latitude, height, ellipsoid, result[index]);\n  }\n\n  return result;\n};\n/**\n * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in radians.\n *\n * @param {Number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromRadiansArrayHeights([-2.007, 0.645, 100000.0, -1.867, .575, 150000.0]);\n */\n\n\nCartesian3.fromRadiansArrayHeights = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n\n  if (coordinates.length < 3 || coordinates.length % 3 !== 0) {\n    throw new DeveloperError(\"the number of coordinates must be a multiple of 3 and at least 3\");\n  } //>>includeEnd('debug');\n\n\n  var length = coordinates.length;\n\n  if (!defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (var i = 0; i < length; i += 3) {\n    var longitude = coordinates[i];\n    var latitude = coordinates[i + 1];\n    var height = coordinates[i + 2];\n    var index = i / 3;\n    result[index] = Cartesian3.fromRadians(longitude, latitude, height, ellipsoid, result[index]);\n  }\n\n  return result;\n};\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 0.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\n\n\nCartesian3.ZERO = Object.freeze(new Cartesian3(0.0, 0.0, 0.0));\n/**\n * An immutable Cartesian3 instance initialized to (1.0, 0.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\n\nCartesian3.UNIT_X = Object.freeze(new Cartesian3(1.0, 0.0, 0.0));\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 1.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\n\nCartesian3.UNIT_Y = Object.freeze(new Cartesian3(0.0, 1.0, 0.0));\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 0.0, 1.0).\n *\n * @type {Cartesian3}\n * @constant\n */\n\nCartesian3.UNIT_Z = Object.freeze(new Cartesian3(0.0, 0.0, 1.0));\n/**\n * Duplicates this Cartesian3 instance.\n *\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\n\nCartesian3.prototype.clone = function (result) {\n  return Cartesian3.clone(this, result);\n};\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian3} [right] The right hand side Cartesian.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\n\n\nCartesian3.prototype.equals = function (right) {\n  return Cartesian3.equals(this, right);\n};\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian3} [right] The right hand side Cartesian.\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\n\n\nCartesian3.prototype.equalsEpsilon = function (right, relativeEpsilon, absoluteEpsilon) {\n  return Cartesian3.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);\n};\n/**\n * Creates a string representing this Cartesian in the format '(x, y, z)'.\n *\n * @returns {String} A string representing this Cartesian in the format '(x, y, z)'.\n */\n\n\nCartesian3.prototype.toString = function () {\n  return \"(\" + this.x + \", \" + this.y + \", \" + this.z + \")\";\n};\n\nexport default Cartesian3;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/Cartesian3.js"],"names":["Check","defaultValue","defined","DeveloperError","CesiumMath","Cartesian3","x","y","z","fromSpherical","spherical","result","typeOf","object","clock","cone","magnitude","radial","Math","sin","cos","fromElements","clone","cartesian","undefined","fromCartesian4","packedLength","pack","value","array","startingIndex","unpack","packArray","length","resultLength","Array","isArray","i","unpackArray","number","greaterThanOrEquals","index","fromArray","maximumComponent","max","minimumComponent","min","minimumByComponent","first","second","maximumByComponent","magnitudeSquared","sqrt","distanceScratch","distance","left","right","subtract","distanceSquared","normalize","isNaN","dot","multiplyComponents","divideComponents","add","multiplyByScalar","scalar","divideByScalar","negate","abs","lerpScratch","lerp","start","end","t","angleBetweenScratch","angleBetweenScratch2","angleBetween","cosine","sine","cross","atan2","mostOrthogonalAxisScratch","mostOrthogonalAxis","f","UNIT_X","UNIT_Z","UNIT_Y","projectVector","a","b","equals","equalsArray","offset","equalsEpsilon","relativeEpsilon","absoluteEpsilon","leftX","leftY","leftZ","rightX","rightY","rightZ","midpoint","fromDegrees","longitude","latitude","height","ellipsoid","toRadians","fromRadians","scratchN","scratchK","wgs84RadiiSquared","radiiSquared","cosLatitude","gamma","fromDegreesArray","coordinates","fromRadiansArray","fromDegreesArrayHeights","fromRadiansArrayHeights","ZERO","Object","freeze","prototype","toString"],"mappings":"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","sourcesContent":["import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A 3D Cartesian point.\n * @alias Cartesian3\n * @constructor\n *\n * @param {Number} [x=0.0] The X component.\n * @param {Number} [y=0.0] The Y component.\n * @param {Number} [z=0.0] The Z component.\n *\n * @see Cartesian2\n * @see Cartesian4\n * @see Packable\n */\nfunction Cartesian3(x, y, z) {\n  /**\n   * The X component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.x = defaultValue(x, 0.0);\n\n  /**\n   * The Y component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.y = defaultValue(y, 0.0);\n\n  /**\n   * The Z component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.z = defaultValue(z, 0.0);\n}\n\n/**\n * Converts the provided Spherical into Cartesian3 coordinates.\n *\n * @param {Spherical} spherical The Spherical to be converted to Cartesian3.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromSpherical = function (spherical, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"spherical\", spherical);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  var clock = spherical.clock;\n  var cone = spherical.cone;\n  var magnitude = defaultValue(spherical.magnitude, 1.0);\n  var radial = magnitude * Math.sin(cone);\n  result.x = radial * Math.cos(clock);\n  result.y = radial * Math.sin(clock);\n  result.z = magnitude * Math.cos(cone);\n  return result;\n};\n\n/**\n * Creates a Cartesian3 instance from x, y and z coordinates.\n *\n * @param {Number} x The x coordinate.\n * @param {Number} y The y coordinate.\n * @param {Number} z The z coordinate.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromElements = function (x, y, z, result) {\n  if (!defined(result)) {\n    return new Cartesian3(x, y, z);\n  }\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Duplicates a Cartesian3 instance.\n *\n * @param {Cartesian3} cartesian The Cartesian to duplicate.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\nCartesian3.clone = function (cartesian, result) {\n  if (!defined(cartesian)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Cartesian3(cartesian.x, cartesian.y, cartesian.z);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  result.z = cartesian.z;\n  return result;\n};\n\n/**\n * Creates a Cartesian3 instance from an existing Cartesian4.  This simply takes the\n * x, y, and z properties of the Cartesian4 and drops w.\n * @function\n *\n * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian3 instance from.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromCartesian4 = Cartesian3.clone;\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nCartesian3.packedLength = 3;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian3} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCartesian3.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex] = value.z;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian3} [result] The object into which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex++];\n  result.z = array[startingIndex];\n  return result;\n};\n\n/**\n * Flattens an array of Cartesian3s into an array of components.\n *\n * @param {Cartesian3[]} array The array of cartesians to pack.\n * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 3 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 3) elements.\n * @returns {Number[]} The packed array.\n */\nCartesian3.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  var length = array.length;\n  var resultLength = length * 3;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    throw new DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 3 elements\"\n    );\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    Cartesian3.pack(array[i], result, i * 3);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of cartesian components into an array of Cartesian3s.\n *\n * @param {Number[]} array The array of components to unpack.\n * @param {Cartesian3[]} [result] The array onto which to store the result.\n * @returns {Cartesian3[]} The unpacked array.\n */\nCartesian3.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 3);\n  if (array.length % 3 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 3.\");\n  }\n  //>>includeEnd('debug');\n\n  var length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (var i = 0; i < length; i += 3) {\n    var index = i / 3;\n    result[index] = Cartesian3.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Creates a Cartesian3 from three consecutive elements in an array.\n * @function\n *\n * @param {Number[]} array The array whose three consecutive elements correspond to the x, y, and z components, respectively.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian3 with (1.0, 2.0, 3.0)\n * var v = [1.0, 2.0, 3.0];\n * var p = Cesium.Cartesian3.fromArray(v);\n *\n * // Create a Cartesian3 with (1.0, 2.0, 3.0) using an offset into an array\n * var v2 = [0.0, 0.0, 1.0, 2.0, 3.0];\n * var p2 = Cesium.Cartesian3.fromArray(v2, 2);\n */\nCartesian3.fromArray = Cartesian3.unpack;\n\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The cartesian to use.\n * @returns {Number} The value of the maximum component.\n */\nCartesian3.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y, cartesian.z);\n};\n\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The cartesian to use.\n * @returns {Number} The value of the minimum component.\n */\nCartesian3.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y, cartesian.z);\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian3} first A cartesian to compare.\n * @param {Cartesian3} second A cartesian to compare.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} A cartesian with the minimum components.\n */\nCartesian3.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n  result.z = Math.min(first.z, second.z);\n\n  return result;\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian3} first A cartesian to compare.\n * @param {Cartesian3} second A cartesian to compare.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} A cartesian with the maximum components.\n */\nCartesian3.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  result.z = Math.max(first.z, second.z);\n  return result;\n};\n\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian3} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {Number} The squared magnitude.\n */\nCartesian3.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return (\n    cartesian.x * cartesian.x +\n    cartesian.y * cartesian.y +\n    cartesian.z * cartesian.z\n  );\n};\n\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian3} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {Number} The magnitude.\n */\nCartesian3.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian3.magnitudeSquared(cartesian));\n};\n\nvar distanceScratch = new Cartesian3();\n\n/**\n * Computes the distance between two points.\n *\n * @param {Cartesian3} left The first point to compute the distance from.\n * @param {Cartesian3} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * var d = Cesium.Cartesian3.distance(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(2.0, 0.0, 0.0));\n */\nCartesian3.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian3.subtract(left, right, distanceScratch);\n  return Cartesian3.magnitude(distanceScratch);\n};\n\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian3#distance}.\n *\n * @param {Cartesian3} left The first point to compute the distance from.\n * @param {Cartesian3} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * var d = Cesium.Cartesian3.distanceSquared(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(3.0, 0.0, 0.0));\n */\nCartesian3.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian3.subtract(left, right, distanceScratch);\n  return Cartesian3.magnitudeSquared(distanceScratch);\n};\n\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian to be normalized.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var magnitude = Cartesian3.magnitude(cartesian);\n\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n  result.z = cartesian.z / magnitude;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (isNaN(result.x) || isNaN(result.y) || isNaN(result.z)) {\n    throw new DeveloperError(\"normalized result is not a number\");\n  }\n  //>>includeEnd('debug');\n\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @returns {Number} The dot product.\n */\nCartesian3.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.x * right.x + left.y * right.y + left.z * right.z;\n};\n\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  result.z = left.z * right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  result.z = left.z / right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  return result;\n};\n\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian3} cartesian The Cartesian to be scaled.\n * @param {Number} scalar The scalar to multiply with.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  result.z = cartesian.z * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian3} cartesian The Cartesian to be divided.\n * @param {Number} scalar The scalar to divide by.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  result.z = cartesian.z / scalar;\n  return result;\n};\n\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian to be negated.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  result.z = -cartesian.z;\n  return result;\n};\n\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  result.z = Math.abs(cartesian.z);\n  return result;\n};\n\nvar lerpScratch = new Cartesian3();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian3} start The value corresponding to t at 0.0.\n * @param {Cartesian3} end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  Cartesian3.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian3.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian3.add(lerpScratch, result, result);\n};\n\nvar angleBetweenScratch = new Cartesian3();\nvar angleBetweenScratch2 = new Cartesian3();\n/**\n * Returns the angle, in radians, between the provided Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @returns {Number} The angle between the Cartesians.\n */\nCartesian3.angleBetween = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian3.normalize(left, angleBetweenScratch);\n  Cartesian3.normalize(right, angleBetweenScratch2);\n  var cosine = Cartesian3.dot(angleBetweenScratch, angleBetweenScratch2);\n  var sine = Cartesian3.magnitude(\n    Cartesian3.cross(\n      angleBetweenScratch,\n      angleBetweenScratch2,\n      angleBetweenScratch\n    )\n  );\n  return Math.atan2(sine, cosine);\n};\n\nvar mostOrthogonalAxisScratch = new Cartesian3();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The most orthogonal axis.\n */\nCartesian3.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var f = Cartesian3.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian3.abs(f, f);\n\n  if (f.x <= f.y) {\n    if (f.x <= f.z) {\n      result = Cartesian3.clone(Cartesian3.UNIT_X, result);\n    } else {\n      result = Cartesian3.clone(Cartesian3.UNIT_Z, result);\n    }\n  } else if (f.y <= f.z) {\n    result = Cartesian3.clone(Cartesian3.UNIT_Y, result);\n  } else {\n    result = Cartesian3.clone(Cartesian3.UNIT_Z, result);\n  }\n\n  return result;\n};\n\n/**\n * Projects vector a onto vector b\n * @param {Cartesian3} a The vector that needs projecting\n * @param {Cartesian3} b The vector to project onto\n * @param {Cartesian3} result The result cartesian\n * @returns {Cartesian3} The modified result parameter\n */\nCartesian3.projectVector = function (a, b, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"a\", a);\n  Check.defined(\"b\", b);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  var scalar = Cartesian3.dot(a, b) / Cartesian3.dot(b, b);\n  return Cartesian3.multiplyByScalar(b, scalar, result);\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian3} [left] The first Cartesian.\n * @param {Cartesian3} [right] The second Cartesian.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartesian3.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.x === right.x &&\n      left.y === right.y &&\n      left.z === right.z)\n  );\n};\n\n/**\n * @private\n */\nCartesian3.equalsArray = function (cartesian, array, offset) {\n  return (\n    cartesian.x === array[offset] &&\n    cartesian.y === array[offset + 1] &&\n    cartesian.z === array[offset + 2]\n  );\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian3} [left] The first Cartesian.\n * @param {Cartesian3} [right] The second Cartesian.\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian3.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      CesiumMath.equalsEpsilon(\n        left.x,\n        right.x,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.y,\n        right.y,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.z,\n        right.z,\n        relativeEpsilon,\n        absoluteEpsilon\n      ))\n  );\n};\n\n/**\n * Computes the cross (outer) product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The cross product.\n */\nCartesian3.cross = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var leftX = left.x;\n  var leftY = left.y;\n  var leftZ = left.z;\n  var rightX = right.x;\n  var rightY = right.y;\n  var rightZ = right.z;\n\n  var x = leftY * rightZ - leftZ * rightY;\n  var y = leftZ * rightX - leftX * rightZ;\n  var z = leftX * rightY - leftY * rightX;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes the midpoint between the right and left Cartesian.\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The midpoint.\n */\nCartesian3.midpoint = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = (left.x + right.x) * 0.5;\n  result.y = (left.y + right.y) * 0.5;\n  result.z = (left.z + right.z) * 0.5;\n\n  return result;\n};\n\n/**\n * Returns a Cartesian3 position from longitude and latitude values given in degrees.\n *\n * @param {Number} longitude The longitude, in degrees\n * @param {Number} latitude The latitude, in degrees\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n *\n * @example\n * var position = Cesium.Cartesian3.fromDegrees(-115.0, 37.0);\n */\nCartesian3.fromDegrees = function (\n  longitude,\n  latitude,\n  height,\n  ellipsoid,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"longitude\", longitude);\n  Check.typeOf.number(\"latitude\", latitude);\n  //>>includeEnd('debug');\n\n  longitude = CesiumMath.toRadians(longitude);\n  latitude = CesiumMath.toRadians(latitude);\n  return Cartesian3.fromRadians(longitude, latitude, height, ellipsoid, result);\n};\n\nvar scratchN = new Cartesian3();\nvar scratchK = new Cartesian3();\nvar wgs84RadiiSquared = new Cartesian3(\n  6378137.0 * 6378137.0,\n  6378137.0 * 6378137.0,\n  6356752.3142451793 * 6356752.3142451793\n);\n\n/**\n * Returns a Cartesian3 position from longitude and latitude values given in radians.\n *\n * @param {Number} longitude The longitude, in radians\n * @param {Number} latitude The latitude, in radians\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n *\n * @example\n * var position = Cesium.Cartesian3.fromRadians(-2.007, 0.645);\n */\nCartesian3.fromRadians = function (\n  longitude,\n  latitude,\n  height,\n  ellipsoid,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"longitude\", longitude);\n  Check.typeOf.number(\"latitude\", latitude);\n  //>>includeEnd('debug');\n\n  height = defaultValue(height, 0.0);\n  var radiiSquared = defined(ellipsoid)\n    ? ellipsoid.radiiSquared\n    : wgs84RadiiSquared;\n\n  var cosLatitude = Math.cos(latitude);\n  scratchN.x = cosLatitude * Math.cos(longitude);\n  scratchN.y = cosLatitude * Math.sin(longitude);\n  scratchN.z = Math.sin(latitude);\n  scratchN = Cartesian3.normalize(scratchN, scratchN);\n\n  Cartesian3.multiplyComponents(radiiSquared, scratchN, scratchK);\n  var gamma = Math.sqrt(Cartesian3.dot(scratchN, scratchK));\n  scratchK = Cartesian3.divideByScalar(scratchK, gamma, scratchK);\n  scratchN = Cartesian3.multiplyByScalar(scratchN, height, scratchN);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  return Cartesian3.add(scratchK, scratchN, result);\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in degrees.\n *\n * @param {Number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the coordinates lie.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromDegreesArray([-115.0, 37.0, -107.0, 33.0]);\n */\nCartesian3.fromDegreesArray = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 2 || coordinates.length % 2 !== 0) {\n    throw new DeveloperError(\n      \"the number of coordinates must be a multiple of 2 and at least 2\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (var i = 0; i < length; i += 2) {\n    var longitude = coordinates[i];\n    var latitude = coordinates[i + 1];\n    var index = i / 2;\n    result[index] = Cartesian3.fromDegrees(\n      longitude,\n      latitude,\n      0,\n      ellipsoid,\n      result[index]\n    );\n  }\n\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in radians.\n *\n * @param {Number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the coordinates lie.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromRadiansArray([-2.007, 0.645, -1.867, .575]);\n */\nCartesian3.fromRadiansArray = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 2 || coordinates.length % 2 !== 0) {\n    throw new DeveloperError(\n      \"the number of coordinates must be a multiple of 2 and at least 2\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (var i = 0; i < length; i += 2) {\n    var longitude = coordinates[i];\n    var latitude = coordinates[i + 1];\n    var index = i / 2;\n    result[index] = Cartesian3.fromRadians(\n      longitude,\n      latitude,\n      0,\n      ellipsoid,\n      result[index]\n    );\n  }\n\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in degrees.\n *\n * @param {Number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromDegreesArrayHeights([-115.0, 37.0, 100000.0, -107.0, 33.0, 150000.0]);\n */\nCartesian3.fromDegreesArrayHeights = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 3 || coordinates.length % 3 !== 0) {\n    throw new DeveloperError(\n      \"the number of coordinates must be a multiple of 3 and at least 3\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (var i = 0; i < length; i += 3) {\n    var longitude = coordinates[i];\n    var latitude = coordinates[i + 1];\n    var height = coordinates[i + 2];\n    var index = i / 3;\n    result[index] = Cartesian3.fromDegrees(\n      longitude,\n      latitude,\n      height,\n      ellipsoid,\n      result[index]\n    );\n  }\n\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in radians.\n *\n * @param {Number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromRadiansArrayHeights([-2.007, 0.645, 100000.0, -1.867, .575, 150000.0]);\n */\nCartesian3.fromRadiansArrayHeights = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 3 || coordinates.length % 3 !== 0) {\n    throw new DeveloperError(\n      \"the number of coordinates must be a multiple of 3 and at least 3\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (var i = 0; i < length; i += 3) {\n    var longitude = coordinates[i];\n    var latitude = coordinates[i + 1];\n    var height = coordinates[i + 2];\n    var index = i / 3;\n    result[index] = Cartesian3.fromRadians(\n      longitude,\n      latitude,\n      height,\n      ellipsoid,\n      result[index]\n    );\n  }\n\n  return result;\n};\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 0.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.ZERO = Object.freeze(new Cartesian3(0.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (1.0, 0.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_X = Object.freeze(new Cartesian3(1.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 1.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_Y = Object.freeze(new Cartesian3(0.0, 1.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 0.0, 1.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_Z = Object.freeze(new Cartesian3(0.0, 0.0, 1.0));\n\n/**\n * Duplicates this Cartesian3 instance.\n *\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.prototype.clone = function (result) {\n  return Cartesian3.clone(this, result);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian3} [right] The right hand side Cartesian.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nCartesian3.prototype.equals = function (right) {\n  return Cartesian3.equals(this, right);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian3} [right] The right hand side Cartesian.\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian3.prototype.equalsEpsilon = function (\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return Cartesian3.equalsEpsilon(\n    this,\n    right,\n    relativeEpsilon,\n    absoluteEpsilon\n  );\n};\n\n/**\n * Creates a string representing this Cartesian in the format '(x, y, z)'.\n *\n * @returns {String} A string representing this Cartesian in the format '(x, y, z)'.\n */\nCartesian3.prototype.toString = function () {\n  return \"(\" + this.x + \", \" + this.y + \", \" + this.z + \")\";\n};\nexport default Cartesian3;\n"]},"metadata":{},"sourceType":"module"}