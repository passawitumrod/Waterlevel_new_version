{"ast":null,"code":"import arraySlice from \"../Core/arraySlice.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport ForEach from \"../ThirdParty/GltfPipeline/ForEach.js\";\nimport when from \"../ThirdParty/when.js\";\n/**\n * @private\n */\n\nfunction DracoLoader() {} // Maximum concurrency to use when decoding draco models\n\n\nDracoLoader._maxDecodingConcurrency = Math.max(FeatureDetection.hardwareConcurrency - 1, 1); // Exposed for testing purposes\n\nDracoLoader._decoderTaskProcessor = undefined;\nDracoLoader._taskProcessorReady = false;\n\nDracoLoader._getDecoderTaskProcessor = function () {\n  if (!defined(DracoLoader._decoderTaskProcessor)) {\n    var processor = new TaskProcessor(\"decodeDraco\", DracoLoader._maxDecodingConcurrency);\n    processor.initWebAssemblyModule({\n      modulePath: \"ThirdParty/Workers/draco_wasm_wrapper.js\",\n      wasmBinaryFile: \"ThirdParty/draco_decoder.wasm\",\n      fallbackModulePath: \"ThirdParty/Workers/draco_decoder.js\"\n    }).then(function () {\n      DracoLoader._taskProcessorReady = true;\n    });\n    DracoLoader._decoderTaskProcessor = processor;\n  }\n\n  return DracoLoader._decoderTaskProcessor;\n};\n/**\n * Returns true if the model uses or requires KHR_draco_mesh_compression.\n *\n * @private\n */\n\n\nDracoLoader.hasExtension = function (model) {\n  return defined(model.extensionsRequired.KHR_draco_mesh_compression) || defined(model.extensionsUsed.KHR_draco_mesh_compression);\n};\n\nfunction addBufferToLoadResources(loadResources, typedArray) {\n  // Create a new id to differentiate from original glTF bufferViews\n  var bufferViewId = \"runtime.\" + Object.keys(loadResources.createdBufferViews).length;\n  var loadResourceBuffers = loadResources.buffers;\n  var id = Object.keys(loadResourceBuffers).length;\n  loadResourceBuffers[id] = typedArray;\n  loadResources.createdBufferViews[bufferViewId] = {\n    buffer: id,\n    byteOffset: 0,\n    byteLength: typedArray.byteLength\n  };\n  return bufferViewId;\n}\n\nfunction addNewVertexBuffer(typedArray, model, context) {\n  var loadResources = model._loadResources;\n  var id = addBufferToLoadResources(loadResources, typedArray);\n  loadResources.vertexBuffersToCreate.enqueue(id);\n  return id;\n}\n\nfunction addNewIndexBuffer(indexArray, model, context) {\n  var typedArray = indexArray.typedArray;\n  var loadResources = model._loadResources;\n  var id = addBufferToLoadResources(loadResources, typedArray);\n  loadResources.indexBuffersToCreate.enqueue({\n    id: id,\n    componentType: ComponentDatatype.fromTypedArray(typedArray)\n  });\n  return {\n    bufferViewId: id,\n    numberOfIndices: indexArray.numberOfIndices\n  };\n}\n\nfunction scheduleDecodingTask(decoderTaskProcessor, model, loadResources, context) {\n  if (!DracoLoader._taskProcessorReady) {\n    // The task processor is not ready to schedule tasks\n    return;\n  }\n\n  var taskData = loadResources.primitivesToDecode.peek();\n\n  if (!defined(taskData)) {\n    // All primitives are processing\n    return;\n  }\n\n  var promise = decoderTaskProcessor.scheduleTask(taskData, [taskData.array.buffer]);\n\n  if (!defined(promise)) {\n    // Cannot schedule another task this frame\n    return;\n  }\n\n  loadResources.activeDecodingTasks++;\n  loadResources.primitivesToDecode.dequeue();\n  return promise.then(function (result) {\n    loadResources.activeDecodingTasks--;\n    var decodedIndexBuffer = addNewIndexBuffer(result.indexArray, model, context);\n    var attributes = {};\n    var decodedAttributeData = result.attributeData;\n\n    for (var attributeName in decodedAttributeData) {\n      if (decodedAttributeData.hasOwnProperty(attributeName)) {\n        var attribute = decodedAttributeData[attributeName];\n        var vertexArray = attribute.array;\n        var vertexBufferView = addNewVertexBuffer(vertexArray, model, context);\n        var data = attribute.data;\n        data.bufferView = vertexBufferView;\n        attributes[attributeName] = data;\n      }\n    }\n\n    model._decodedData[taskData.mesh + \".primitive.\" + taskData.primitive] = {\n      bufferView: decodedIndexBuffer.bufferViewId,\n      numberOfIndices: decodedIndexBuffer.numberOfIndices,\n      attributes: attributes\n    };\n  });\n}\n\nDracoLoader._decodedModelResourceCache = undefined;\n/**\n * Parses draco extension on model primitives and\n * adds the decoding data to the model's load resources.\n *\n * @private\n */\n\nDracoLoader.parse = function (model, context) {\n  if (!DracoLoader.hasExtension(model)) {\n    return;\n  }\n\n  var loadResources = model._loadResources;\n  var cacheKey = model.cacheKey;\n\n  if (defined(cacheKey)) {\n    if (!defined(DracoLoader._decodedModelResourceCache)) {\n      if (!defined(context.cache.modelDecodingCache)) {\n        context.cache.modelDecodingCache = {};\n      }\n\n      DracoLoader._decodedModelResourceCache = context.cache.modelDecodingCache;\n    } // Decoded data for model will be loaded from cache\n\n\n    var cachedData = DracoLoader._decodedModelResourceCache[cacheKey];\n\n    if (defined(cachedData)) {\n      cachedData.count++;\n      loadResources.pendingDecodingCache = true;\n      return;\n    }\n  }\n\n  var dequantizeInShader = model._dequantizeInShader;\n  var gltf = model.gltf;\n  ForEach.mesh(gltf, function (mesh, meshId) {\n    ForEach.meshPrimitive(mesh, function (primitive, primitiveId) {\n      if (!defined(primitive.extensions)) {\n        return;\n      }\n\n      var compressionData = primitive.extensions.KHR_draco_mesh_compression;\n\n      if (!defined(compressionData)) {\n        return;\n      }\n\n      var bufferView = gltf.bufferViews[compressionData.bufferView];\n      var typedArray = arraySlice(gltf.buffers[bufferView.buffer].extras._pipeline.source, bufferView.byteOffset, bufferView.byteOffset + bufferView.byteLength);\n      loadResources.primitivesToDecode.enqueue({\n        mesh: meshId,\n        primitive: primitiveId,\n        array: typedArray,\n        bufferView: bufferView,\n        compressedAttributes: compressionData.attributes,\n        dequantizeInShader: dequantizeInShader\n      });\n    });\n  });\n};\n/**\n * Schedules decoding tasks available this frame.\n * @private\n */\n\n\nDracoLoader.decodeModel = function (model, context) {\n  if (!DracoLoader.hasExtension(model)) {\n    return when.resolve();\n  }\n\n  var loadResources = model._loadResources;\n  var cacheKey = model.cacheKey;\n\n  if (defined(cacheKey) && defined(DracoLoader._decodedModelResourceCache)) {\n    var cachedData = DracoLoader._decodedModelResourceCache[cacheKey]; // Load decoded data for model when cache is ready\n\n    if (defined(cachedData) && loadResources.pendingDecodingCache) {\n      return when(cachedData.ready, function () {\n        model._decodedData = cachedData.data;\n        loadResources.pendingDecodingCache = false;\n      });\n    } // Decoded data for model should be cached when ready\n\n\n    DracoLoader._decodedModelResourceCache[cacheKey] = {\n      ready: false,\n      count: 1,\n      data: undefined\n    };\n  }\n\n  if (loadResources.primitivesToDecode.length === 0) {\n    // No more tasks to schedule\n    return when.resolve();\n  }\n\n  var decoderTaskProcessor = DracoLoader._getDecoderTaskProcessor();\n\n  var decodingPromises = [];\n  var promise = scheduleDecodingTask(decoderTaskProcessor, model, loadResources, context);\n\n  while (defined(promise)) {\n    decodingPromises.push(promise);\n    promise = scheduleDecodingTask(decoderTaskProcessor, model, loadResources, context);\n  }\n\n  return when.all(decodingPromises);\n};\n/**\n * Decodes a compressed point cloud. Returns undefined if the task cannot be scheduled.\n * @private\n */\n\n\nDracoLoader.decodePointCloud = function (parameters) {\n  var decoderTaskProcessor = DracoLoader._getDecoderTaskProcessor();\n\n  if (!DracoLoader._taskProcessorReady) {\n    // The task processor is not ready to schedule tasks\n    return;\n  }\n\n  return decoderTaskProcessor.scheduleTask(parameters, [parameters.buffer.buffer]);\n};\n/**\n * Caches a models decoded data so it doesn't need to decode more than once.\n * @private\n */\n\n\nDracoLoader.cacheDataForModel = function (model) {\n  var cacheKey = model.cacheKey;\n\n  if (defined(cacheKey) && defined(DracoLoader._decodedModelResourceCache)) {\n    var cachedData = DracoLoader._decodedModelResourceCache[cacheKey];\n\n    if (defined(cachedData)) {\n      cachedData.ready = true;\n      cachedData.data = model._decodedData;\n    }\n  }\n};\n/**\n * Destroys the cached data that this model references if it is no longer in use.\n * @private\n */\n\n\nDracoLoader.destroyCachedDataForModel = function (model) {\n  var cacheKey = model.cacheKey;\n\n  if (defined(cacheKey) && defined(DracoLoader._decodedModelResourceCache)) {\n    var cachedData = DracoLoader._decodedModelResourceCache[cacheKey];\n\n    if (defined(cachedData) && --cachedData.count === 0) {\n      delete DracoLoader._decodedModelResourceCache[cacheKey];\n    }\n  }\n};\n\nexport default DracoLoader;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/DracoLoader.js"],"names":["arraySlice","ComponentDatatype","defined","FeatureDetection","TaskProcessor","ForEach","when","DracoLoader","_maxDecodingConcurrency","Math","max","hardwareConcurrency","_decoderTaskProcessor","undefined","_taskProcessorReady","_getDecoderTaskProcessor","processor","initWebAssemblyModule","modulePath","wasmBinaryFile","fallbackModulePath","then","hasExtension","model","extensionsRequired","KHR_draco_mesh_compression","extensionsUsed","addBufferToLoadResources","loadResources","typedArray","bufferViewId","Object","keys","createdBufferViews","length","loadResourceBuffers","buffers","id","buffer","byteOffset","byteLength","addNewVertexBuffer","context","_loadResources","vertexBuffersToCreate","enqueue","addNewIndexBuffer","indexArray","indexBuffersToCreate","componentType","fromTypedArray","numberOfIndices","scheduleDecodingTask","decoderTaskProcessor","taskData","primitivesToDecode","peek","promise","scheduleTask","array","activeDecodingTasks","dequeue","result","decodedIndexBuffer","attributes","decodedAttributeData","attributeData","attributeName","hasOwnProperty","attribute","vertexArray","vertexBufferView","data","bufferView","_decodedData","mesh","primitive","_decodedModelResourceCache","parse","cacheKey","cache","modelDecodingCache","cachedData","count","pendingDecodingCache","dequantizeInShader","_dequantizeInShader","gltf","meshId","meshPrimitive","primitiveId","extensions","compressionData","bufferViews","extras","_pipeline","source","compressedAttributes","decodeModel","resolve","ready","decodingPromises","push","all","decodePointCloud","parameters","cacheDataForModel","destroyCachedDataForModel"],"mappings":"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","sourcesContent":["import arraySlice from \"../Core/arraySlice.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport ForEach from \"../ThirdParty/GltfPipeline/ForEach.js\";\nimport when from \"../ThirdParty/when.js\";\n\n/**\n * @private\n */\nfunction DracoLoader() {}\n\n// Maximum concurrency to use when decoding draco models\nDracoLoader._maxDecodingConcurrency = Math.max(\n  FeatureDetection.hardwareConcurrency - 1,\n  1\n);\n\n// Exposed for testing purposes\nDracoLoader._decoderTaskProcessor = undefined;\nDracoLoader._taskProcessorReady = false;\nDracoLoader._getDecoderTaskProcessor = function () {\n  if (!defined(DracoLoader._decoderTaskProcessor)) {\n    var processor = new TaskProcessor(\n      \"decodeDraco\",\n      DracoLoader._maxDecodingConcurrency\n    );\n    processor\n      .initWebAssemblyModule({\n        modulePath: \"ThirdParty/Workers/draco_wasm_wrapper.js\",\n        wasmBinaryFile: \"ThirdParty/draco_decoder.wasm\",\n        fallbackModulePath: \"ThirdParty/Workers/draco_decoder.js\",\n      })\n      .then(function () {\n        DracoLoader._taskProcessorReady = true;\n      });\n    DracoLoader._decoderTaskProcessor = processor;\n  }\n\n  return DracoLoader._decoderTaskProcessor;\n};\n\n/**\n * Returns true if the model uses or requires KHR_draco_mesh_compression.\n *\n * @private\n */\nDracoLoader.hasExtension = function (model) {\n  return (\n    defined(model.extensionsRequired.KHR_draco_mesh_compression) ||\n    defined(model.extensionsUsed.KHR_draco_mesh_compression)\n  );\n};\n\nfunction addBufferToLoadResources(loadResources, typedArray) {\n  // Create a new id to differentiate from original glTF bufferViews\n  var bufferViewId =\n    \"runtime.\" + Object.keys(loadResources.createdBufferViews).length;\n\n  var loadResourceBuffers = loadResources.buffers;\n  var id = Object.keys(loadResourceBuffers).length;\n  loadResourceBuffers[id] = typedArray;\n  loadResources.createdBufferViews[bufferViewId] = {\n    buffer: id,\n    byteOffset: 0,\n    byteLength: typedArray.byteLength,\n  };\n\n  return bufferViewId;\n}\n\nfunction addNewVertexBuffer(typedArray, model, context) {\n  var loadResources = model._loadResources;\n  var id = addBufferToLoadResources(loadResources, typedArray);\n  loadResources.vertexBuffersToCreate.enqueue(id);\n  return id;\n}\n\nfunction addNewIndexBuffer(indexArray, model, context) {\n  var typedArray = indexArray.typedArray;\n  var loadResources = model._loadResources;\n  var id = addBufferToLoadResources(loadResources, typedArray);\n  loadResources.indexBuffersToCreate.enqueue({\n    id: id,\n    componentType: ComponentDatatype.fromTypedArray(typedArray),\n  });\n\n  return {\n    bufferViewId: id,\n    numberOfIndices: indexArray.numberOfIndices,\n  };\n}\n\nfunction scheduleDecodingTask(\n  decoderTaskProcessor,\n  model,\n  loadResources,\n  context\n) {\n  if (!DracoLoader._taskProcessorReady) {\n    // The task processor is not ready to schedule tasks\n    return;\n  }\n\n  var taskData = loadResources.primitivesToDecode.peek();\n  if (!defined(taskData)) {\n    // All primitives are processing\n    return;\n  }\n\n  var promise = decoderTaskProcessor.scheduleTask(taskData, [\n    taskData.array.buffer,\n  ]);\n  if (!defined(promise)) {\n    // Cannot schedule another task this frame\n    return;\n  }\n\n  loadResources.activeDecodingTasks++;\n  loadResources.primitivesToDecode.dequeue();\n  return promise.then(function (result) {\n    loadResources.activeDecodingTasks--;\n\n    var decodedIndexBuffer = addNewIndexBuffer(\n      result.indexArray,\n      model,\n      context\n    );\n\n    var attributes = {};\n    var decodedAttributeData = result.attributeData;\n    for (var attributeName in decodedAttributeData) {\n      if (decodedAttributeData.hasOwnProperty(attributeName)) {\n        var attribute = decodedAttributeData[attributeName];\n        var vertexArray = attribute.array;\n        var vertexBufferView = addNewVertexBuffer(vertexArray, model, context);\n\n        var data = attribute.data;\n        data.bufferView = vertexBufferView;\n\n        attributes[attributeName] = data;\n      }\n    }\n\n    model._decodedData[taskData.mesh + \".primitive.\" + taskData.primitive] = {\n      bufferView: decodedIndexBuffer.bufferViewId,\n      numberOfIndices: decodedIndexBuffer.numberOfIndices,\n      attributes: attributes,\n    };\n  });\n}\n\nDracoLoader._decodedModelResourceCache = undefined;\n\n/**\n * Parses draco extension on model primitives and\n * adds the decoding data to the model's load resources.\n *\n * @private\n */\nDracoLoader.parse = function (model, context) {\n  if (!DracoLoader.hasExtension(model)) {\n    return;\n  }\n\n  var loadResources = model._loadResources;\n  var cacheKey = model.cacheKey;\n  if (defined(cacheKey)) {\n    if (!defined(DracoLoader._decodedModelResourceCache)) {\n      if (!defined(context.cache.modelDecodingCache)) {\n        context.cache.modelDecodingCache = {};\n      }\n\n      DracoLoader._decodedModelResourceCache = context.cache.modelDecodingCache;\n    }\n\n    // Decoded data for model will be loaded from cache\n    var cachedData = DracoLoader._decodedModelResourceCache[cacheKey];\n    if (defined(cachedData)) {\n      cachedData.count++;\n      loadResources.pendingDecodingCache = true;\n      return;\n    }\n  }\n\n  var dequantizeInShader = model._dequantizeInShader;\n  var gltf = model.gltf;\n  ForEach.mesh(gltf, function (mesh, meshId) {\n    ForEach.meshPrimitive(mesh, function (primitive, primitiveId) {\n      if (!defined(primitive.extensions)) {\n        return;\n      }\n\n      var compressionData = primitive.extensions.KHR_draco_mesh_compression;\n      if (!defined(compressionData)) {\n        return;\n      }\n\n      var bufferView = gltf.bufferViews[compressionData.bufferView];\n      var typedArray = arraySlice(\n        gltf.buffers[bufferView.buffer].extras._pipeline.source,\n        bufferView.byteOffset,\n        bufferView.byteOffset + bufferView.byteLength\n      );\n      loadResources.primitivesToDecode.enqueue({\n        mesh: meshId,\n        primitive: primitiveId,\n        array: typedArray,\n        bufferView: bufferView,\n        compressedAttributes: compressionData.attributes,\n        dequantizeInShader: dequantizeInShader,\n      });\n    });\n  });\n};\n\n/**\n * Schedules decoding tasks available this frame.\n * @private\n */\nDracoLoader.decodeModel = function (model, context) {\n  if (!DracoLoader.hasExtension(model)) {\n    return when.resolve();\n  }\n\n  var loadResources = model._loadResources;\n  var cacheKey = model.cacheKey;\n  if (defined(cacheKey) && defined(DracoLoader._decodedModelResourceCache)) {\n    var cachedData = DracoLoader._decodedModelResourceCache[cacheKey];\n    // Load decoded data for model when cache is ready\n    if (defined(cachedData) && loadResources.pendingDecodingCache) {\n      return when(cachedData.ready, function () {\n        model._decodedData = cachedData.data;\n        loadResources.pendingDecodingCache = false;\n      });\n    }\n\n    // Decoded data for model should be cached when ready\n    DracoLoader._decodedModelResourceCache[cacheKey] = {\n      ready: false,\n      count: 1,\n      data: undefined,\n    };\n  }\n\n  if (loadResources.primitivesToDecode.length === 0) {\n    // No more tasks to schedule\n    return when.resolve();\n  }\n\n  var decoderTaskProcessor = DracoLoader._getDecoderTaskProcessor();\n  var decodingPromises = [];\n\n  var promise = scheduleDecodingTask(\n    decoderTaskProcessor,\n    model,\n    loadResources,\n    context\n  );\n  while (defined(promise)) {\n    decodingPromises.push(promise);\n    promise = scheduleDecodingTask(\n      decoderTaskProcessor,\n      model,\n      loadResources,\n      context\n    );\n  }\n\n  return when.all(decodingPromises);\n};\n\n/**\n * Decodes a compressed point cloud. Returns undefined if the task cannot be scheduled.\n * @private\n */\nDracoLoader.decodePointCloud = function (parameters) {\n  var decoderTaskProcessor = DracoLoader._getDecoderTaskProcessor();\n  if (!DracoLoader._taskProcessorReady) {\n    // The task processor is not ready to schedule tasks\n    return;\n  }\n  return decoderTaskProcessor.scheduleTask(parameters, [\n    parameters.buffer.buffer,\n  ]);\n};\n\n/**\n * Caches a models decoded data so it doesn't need to decode more than once.\n * @private\n */\nDracoLoader.cacheDataForModel = function (model) {\n  var cacheKey = model.cacheKey;\n  if (defined(cacheKey) && defined(DracoLoader._decodedModelResourceCache)) {\n    var cachedData = DracoLoader._decodedModelResourceCache[cacheKey];\n    if (defined(cachedData)) {\n      cachedData.ready = true;\n      cachedData.data = model._decodedData;\n    }\n  }\n};\n\n/**\n * Destroys the cached data that this model references if it is no longer in use.\n * @private\n */\nDracoLoader.destroyCachedDataForModel = function (model) {\n  var cacheKey = model.cacheKey;\n  if (defined(cacheKey) && defined(DracoLoader._decodedModelResourceCache)) {\n    var cachedData = DracoLoader._decodedModelResourceCache[cacheKey];\n    if (defined(cachedData) && --cachedData.count === 0) {\n      delete DracoLoader._decodedModelResourceCache[cacheKey];\n    }\n  }\n};\nexport default DracoLoader;\n"]},"metadata":{},"sourceType":"module"}