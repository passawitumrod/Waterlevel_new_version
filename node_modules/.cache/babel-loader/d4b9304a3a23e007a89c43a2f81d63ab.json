{"ast":null,"code":"import CartographicGeocoderService from \"../../Core/CartographicGeocoderService.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport Event from \"../../Core/Event.js\";\nimport GeocodeType from \"../../Core/GeocodeType.js\";\nimport IonGeocoderService from \"../../Core/IonGeocoderService.js\";\nimport CesiumMath from \"../../Core/Math.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Rectangle from \"../../Core/Rectangle.js\";\nimport sampleTerrainMostDetailed from \"../../Core/sampleTerrainMostDetailed.js\";\nimport computeFlyToLocationForRectangle from \"../../Scene/computeFlyToLocationForRectangle.js\";\nimport knockout from \"../../ThirdParty/knockout.js\";\nimport when from \"../../ThirdParty/when.js\";\nimport createCommand from \"../createCommand.js\";\nimport getElement from \"../getElement.js\"; // The height we use if geocoding to a specific point instead of an rectangle.\n\nvar DEFAULT_HEIGHT = 1000;\n/**\n * The view model for the {@link Geocoder} widget.\n * @alias GeocoderViewModel\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Scene} options.scene The Scene instance to use.\n * @param {GeocoderService[]} [options.geocoderServices] Geocoder services to use for geocoding queries.\n *        If more than one are supplied, suggestions will be gathered for the geocoders that support it,\n *        and if no suggestion is selected the result from the first geocoder service wil be used.\n * @param {Number} [options.flightDuration] The duration of the camera flight to an entered location, in seconds.\n * @param {Geocoder~DestinationFoundFunction} [options.destinationFound=GeocoderViewModel.flyToDestination] A callback function that is called after a successful geocode.  If not supplied, the default behavior is to fly the camera to the result destination.\n */\n\nfunction GeocoderViewModel(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.scene)) {\n    throw new DeveloperError(\"options.scene is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (defined(options.geocoderServices)) {\n    this._geocoderServices = options.geocoderServices;\n  } else {\n    this._geocoderServices = [new CartographicGeocoderService(), new IonGeocoderService({\n      scene: options.scene\n    })];\n  }\n\n  this._viewContainer = options.container;\n  this._scene = options.scene;\n  this._flightDuration = options.flightDuration;\n  this._searchText = \"\";\n  this._isSearchInProgress = false;\n  this._geocodePromise = undefined;\n  this._complete = new Event();\n  this._suggestions = [];\n  this._selectedSuggestion = undefined;\n  this._showSuggestions = true;\n  this._handleArrowDown = handleArrowDown;\n  this._handleArrowUp = handleArrowUp;\n  var that = this;\n  this._suggestionsVisible = knockout.pureComputed(function () {\n    var suggestions = knockout.getObservable(that, \"_suggestions\");\n    var suggestionsNotEmpty = suggestions().length > 0;\n    var showSuggestions = knockout.getObservable(that, \"_showSuggestions\")();\n    return suggestionsNotEmpty && showSuggestions;\n  });\n  this._searchCommand = createCommand(function (geocodeType) {\n    geocodeType = defaultValue(geocodeType, GeocodeType.SEARCH);\n    that._focusTextbox = false;\n\n    if (defined(that._selectedSuggestion)) {\n      that.activateSuggestion(that._selectedSuggestion);\n      return false;\n    }\n\n    that.hideSuggestions();\n\n    if (that.isSearchInProgress) {\n      cancelGeocode(that);\n    } else {\n      geocode(that, that._geocoderServices, geocodeType);\n    }\n  });\n\n  this.deselectSuggestion = function () {\n    that._selectedSuggestion = undefined;\n  };\n\n  this.handleKeyDown = function (data, event) {\n    var downKey = event.key === \"ArrowDown\" || event.key === \"Down\" || event.keyCode === 40;\n    var upKey = event.key === \"ArrowUp\" || event.key === \"Up\" || event.keyCode === 38;\n\n    if (downKey || upKey) {\n      event.preventDefault();\n    }\n\n    return true;\n  };\n\n  this.handleKeyUp = function (data, event) {\n    var downKey = event.key === \"ArrowDown\" || event.key === \"Down\" || event.keyCode === 40;\n    var upKey = event.key === \"ArrowUp\" || event.key === \"Up\" || event.keyCode === 38;\n    var enterKey = event.key === \"Enter\" || event.keyCode === 13;\n\n    if (upKey) {\n      handleArrowUp(that);\n    } else if (downKey) {\n      handleArrowDown(that);\n    } else if (enterKey) {\n      that._searchCommand();\n    }\n\n    return true;\n  };\n\n  this.activateSuggestion = function (data) {\n    that.hideSuggestions();\n    that._searchText = data.displayName;\n    var destination = data.destination;\n    clearSuggestions(that);\n    that.destinationFound(that, destination);\n  };\n\n  this.hideSuggestions = function () {\n    that._showSuggestions = false;\n    that._selectedSuggestion = undefined;\n  };\n\n  this.showSuggestions = function () {\n    that._showSuggestions = true;\n  };\n\n  this.handleMouseover = function (data, event) {\n    if (data !== that._selectedSuggestion) {\n      that._selectedSuggestion = data;\n    }\n  };\n  /**\n   * Gets or sets a value indicating if this instance should always show its text input field.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n\n\n  this.keepExpanded = false;\n  /**\n   * True if the geocoder should query as the user types to autocomplete\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.autoComplete = defaultValue(options.autocomplete, true);\n  /**\n   * Gets and sets the command called when a geocode destination is found\n   * @type {Geocoder~DestinationFoundFunction}\n   */\n\n  this.destinationFound = defaultValue(options.destinationFound, GeocoderViewModel.flyToDestination);\n  this._focusTextbox = false;\n  knockout.track(this, [\"_searchText\", \"_isSearchInProgress\", \"keepExpanded\", \"_suggestions\", \"_selectedSuggestion\", \"_showSuggestions\", \"_focusTextbox\"]);\n  var searchTextObservable = knockout.getObservable(this, \"_searchText\");\n  searchTextObservable.extend({\n    rateLimit: {\n      timeout: 500\n    }\n  });\n  this._suggestionSubscription = searchTextObservable.subscribe(function () {\n    GeocoderViewModel._updateSearchSuggestions(that);\n  });\n  /**\n   * Gets a value indicating whether a search is currently in progress.  This property is observable.\n   *\n   * @type {Boolean}\n   */\n\n  this.isSearchInProgress = undefined;\n  knockout.defineProperty(this, \"isSearchInProgress\", {\n    get: function () {\n      return this._isSearchInProgress;\n    }\n  });\n  /**\n   * Gets or sets the text to search for.  The text can be an address, or longitude, latitude,\n   * and optional height, where longitude and latitude are in degrees and height is in meters.\n   *\n   * @type {String}\n   */\n\n  this.searchText = undefined;\n  knockout.defineProperty(this, \"searchText\", {\n    get: function () {\n      if (this.isSearchInProgress) {\n        return \"Searching...\";\n      }\n\n      return this._searchText;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (typeof value !== \"string\") {\n        throw new DeveloperError(\"value must be a valid string.\");\n      } //>>includeEnd('debug');\n\n\n      this._searchText = value;\n    }\n  });\n  /**\n   * Gets or sets the the duration of the camera flight in seconds.\n   * A value of zero causes the camera to instantly switch to the geocoding location.\n   * The duration will be computed based on the distance when undefined.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n\n  this.flightDuration = undefined;\n  knockout.defineProperty(this, \"flightDuration\", {\n    get: function () {\n      return this._flightDuration;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value < 0) {\n        throw new DeveloperError(\"value must be positive.\");\n      } //>>includeEnd('debug');\n\n\n      this._flightDuration = value;\n    }\n  });\n}\n\nObject.defineProperties(GeocoderViewModel.prototype, {\n  /**\n   * Gets the event triggered on flight completion.\n   * @memberof GeocoderViewModel.prototype\n   *\n   * @type {Event}\n   */\n  complete: {\n    get: function () {\n      return this._complete;\n    }\n  },\n\n  /**\n   * Gets the scene to control.\n   * @memberof GeocoderViewModel.prototype\n   *\n   * @type {Scene}\n   */\n  scene: {\n    get: function () {\n      return this._scene;\n    }\n  },\n\n  /**\n   * Gets the Command that is executed when the button is clicked.\n   * @memberof GeocoderViewModel.prototype\n   *\n   * @type {Command}\n   */\n  search: {\n    get: function () {\n      return this._searchCommand;\n    }\n  },\n\n  /**\n   * Gets the currently selected geocoder search suggestion\n   * @memberof GeocoderViewModel.prototype\n   *\n   * @type {Object}\n   */\n  selectedSuggestion: {\n    get: function () {\n      return this._selectedSuggestion;\n    }\n  },\n\n  /**\n   * Gets the list of geocoder search suggestions\n   * @memberof GeocoderViewModel.prototype\n   *\n   * @type {Object[]}\n   */\n  suggestions: {\n    get: function () {\n      return this._suggestions;\n    }\n  }\n});\n/**\n * Destroys the widget.  Should be called if permanently\n * removing the widget from layout.\n */\n\nGeocoderViewModel.prototype.destroy = function () {\n  this._suggestionSubscription.dispose();\n};\n\nfunction handleArrowUp(viewModel) {\n  if (viewModel._suggestions.length === 0) {\n    return;\n  }\n\n  var next;\n\n  var currentIndex = viewModel._suggestions.indexOf(viewModel._selectedSuggestion);\n\n  if (currentIndex === -1 || currentIndex === 0) {\n    viewModel._selectedSuggestion = undefined;\n    return;\n  }\n\n  next = currentIndex - 1;\n  viewModel._selectedSuggestion = viewModel._suggestions[next];\n\n  GeocoderViewModel._adjustSuggestionsScroll(viewModel, next);\n}\n\nfunction handleArrowDown(viewModel) {\n  if (viewModel._suggestions.length === 0) {\n    return;\n  }\n\n  var numberOfSuggestions = viewModel._suggestions.length;\n\n  var currentIndex = viewModel._suggestions.indexOf(viewModel._selectedSuggestion);\n\n  var next = (currentIndex + 1) % numberOfSuggestions;\n  viewModel._selectedSuggestion = viewModel._suggestions[next];\n\n  GeocoderViewModel._adjustSuggestionsScroll(viewModel, next);\n}\n\nfunction computeFlyToLocationForCartographic(cartographic, terrainProvider) {\n  var availability = defined(terrainProvider) ? terrainProvider.availability : undefined;\n\n  if (!defined(availability)) {\n    cartographic.height += DEFAULT_HEIGHT;\n    return when.resolve(cartographic);\n  }\n\n  return sampleTerrainMostDetailed(terrainProvider, [cartographic]).then(function (positionOnTerrain) {\n    cartographic = positionOnTerrain[0];\n    cartographic.height += DEFAULT_HEIGHT;\n    return cartographic;\n  });\n}\n\nfunction flyToDestination(viewModel, destination) {\n  var scene = viewModel._scene;\n  var mapProjection = scene.mapProjection;\n  var ellipsoid = mapProjection.ellipsoid;\n  var camera = scene.camera;\n  var terrainProvider = scene.terrainProvider;\n  var finalDestination = destination;\n  var promise;\n\n  if (destination instanceof Rectangle) {\n    // Some geocoders return a Rectangle of zero width/height, treat it like a point instead.\n    if (CesiumMath.equalsEpsilon(destination.south, destination.north, CesiumMath.EPSILON7) && CesiumMath.equalsEpsilon(destination.east, destination.west, CesiumMath.EPSILON7)) {\n      // destination is now a Cartographic\n      destination = Rectangle.center(destination);\n    } else {\n      promise = computeFlyToLocationForRectangle(destination, scene);\n    }\n  } else {\n    // destination is a Cartesian3\n    destination = ellipsoid.cartesianToCartographic(destination);\n  }\n\n  if (!defined(promise)) {\n    promise = computeFlyToLocationForCartographic(destination, terrainProvider);\n  }\n\n  promise.then(function (result) {\n    finalDestination = ellipsoid.cartographicToCartesian(result);\n  }).always(function () {\n    // Whether terrain querying succeeded or not, fly to the destination.\n    camera.flyTo({\n      destination: finalDestination,\n      complete: function () {\n        viewModel._complete.raiseEvent();\n      },\n      duration: viewModel._flightDuration,\n      endTransform: Matrix4.IDENTITY\n    });\n  });\n}\n\nfunction chainPromise(promise, geocoderService, query, geocodeType) {\n  return promise.then(function (result) {\n    if (defined(result) && result.state === \"fulfilled\" && result.value.length > 0) {\n      return result;\n    }\n\n    var nextPromise = geocoderService.geocode(query, geocodeType).then(function (result) {\n      return {\n        state: \"fulfilled\",\n        value: result\n      };\n    }).otherwise(function (err) {\n      return {\n        state: \"rejected\",\n        reason: err\n      };\n    });\n    return nextPromise;\n  });\n}\n\nfunction geocode(viewModel, geocoderServices, geocodeType) {\n  var query = viewModel._searchText;\n\n  if (hasOnlyWhitespace(query)) {\n    viewModel.showSuggestions();\n    return;\n  }\n\n  viewModel._isSearchInProgress = true;\n  var promise = when.resolve();\n\n  for (var i = 0; i < geocoderServices.length; i++) {\n    promise = chainPromise(promise, geocoderServices[i], query, geocodeType);\n  }\n\n  viewModel._geocodePromise = promise;\n  promise.then(function (result) {\n    if (promise.cancel) {\n      return;\n    }\n\n    viewModel._isSearchInProgress = false;\n    var geocoderResults = result.value;\n\n    if (result.state === \"fulfilled\" && defined(geocoderResults) && geocoderResults.length > 0) {\n      viewModel._searchText = geocoderResults[0].displayName;\n      viewModel.destinationFound(viewModel, geocoderResults[0].destination);\n      return;\n    }\n\n    viewModel._searchText = query + \" (not found)\";\n  });\n}\n\nfunction adjustSuggestionsScroll(viewModel, focusedItemIndex) {\n  var container = getElement(viewModel._viewContainer);\n  var searchResults = container.getElementsByClassName(\"search-results\")[0];\n  var listItems = container.getElementsByTagName(\"li\");\n  var element = listItems[focusedItemIndex];\n\n  if (focusedItemIndex === 0) {\n    searchResults.scrollTop = 0;\n    return;\n  }\n\n  var offsetTop = element.offsetTop;\n\n  if (offsetTop + element.clientHeight > searchResults.clientHeight) {\n    searchResults.scrollTop = offsetTop + element.clientHeight;\n  } else if (offsetTop < searchResults.scrollTop) {\n    searchResults.scrollTop = offsetTop;\n  }\n}\n\nfunction cancelGeocode(viewModel) {\n  viewModel._isSearchInProgress = false;\n\n  if (defined(viewModel._geocodePromise)) {\n    viewModel._geocodePromise.cancel = true;\n    viewModel._geocodePromise = undefined;\n  }\n}\n\nfunction hasOnlyWhitespace(string) {\n  return /^\\s*$/.test(string);\n}\n\nfunction clearSuggestions(viewModel) {\n  knockout.getObservable(viewModel, \"_suggestions\").removeAll();\n}\n\nfunction updateSearchSuggestions(viewModel) {\n  if (!viewModel.autoComplete) {\n    return;\n  }\n\n  var query = viewModel._searchText;\n  clearSuggestions(viewModel);\n\n  if (hasOnlyWhitespace(query)) {\n    return;\n  }\n\n  var promise = when.resolve([]);\n\n  viewModel._geocoderServices.forEach(function (service) {\n    promise = promise.then(function (results) {\n      if (results.length >= 5) {\n        return results;\n      }\n\n      return service.geocode(query, GeocodeType.AUTOCOMPLETE).then(function (newResults) {\n        results = results.concat(newResults);\n        return results;\n      });\n    });\n  });\n\n  promise.then(function (results) {\n    var suggestions = viewModel._suggestions;\n\n    for (var i = 0; i < results.length; i++) {\n      suggestions.push(results[i]);\n    }\n  });\n}\n/**\n * A function to fly to the destination found by a successful geocode.\n * @type {Geocoder~DestinationFoundFunction}\n */\n\n\nGeocoderViewModel.flyToDestination = flyToDestination; //exposed for testing\n\nGeocoderViewModel._updateSearchSuggestions = updateSearchSuggestions;\nGeocoderViewModel._adjustSuggestionsScroll = adjustSuggestionsScroll;\nexport default GeocoderViewModel;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Widgets/Geocoder/GeocoderViewModel.js"],"names":["CartographicGeocoderService","defaultValue","defined","DeveloperError","Event","GeocodeType","IonGeocoderService","CesiumMath","Matrix4","Rectangle","sampleTerrainMostDetailed","computeFlyToLocationForRectangle","knockout","when","createCommand","getElement","DEFAULT_HEIGHT","GeocoderViewModel","options","scene","geocoderServices","_geocoderServices","_viewContainer","container","_scene","_flightDuration","flightDuration","_searchText","_isSearchInProgress","_geocodePromise","undefined","_complete","_suggestions","_selectedSuggestion","_showSuggestions","_handleArrowDown","handleArrowDown","_handleArrowUp","handleArrowUp","that","_suggestionsVisible","pureComputed","suggestions","getObservable","suggestionsNotEmpty","length","showSuggestions","_searchCommand","geocodeType","SEARCH","_focusTextbox","activateSuggestion","hideSuggestions","isSearchInProgress","cancelGeocode","geocode","deselectSuggestion","handleKeyDown","data","event","downKey","key","keyCode","upKey","preventDefault","handleKeyUp","enterKey","displayName","destination","clearSuggestions","destinationFound","handleMouseover","keepExpanded","autoComplete","autocomplete","flyToDestination","track","searchTextObservable","extend","rateLimit","timeout","_suggestionSubscription","subscribe","_updateSearchSuggestions","defineProperty","get","searchText","set","value","Object","defineProperties","prototype","complete","search","selectedSuggestion","destroy","dispose","viewModel","next","currentIndex","indexOf","_adjustSuggestionsScroll","numberOfSuggestions","computeFlyToLocationForCartographic","cartographic","terrainProvider","availability","height","resolve","then","positionOnTerrain","mapProjection","ellipsoid","camera","finalDestination","promise","equalsEpsilon","south","north","EPSILON7","east","west","center","cartesianToCartographic","result","cartographicToCartesian","always","flyTo","raiseEvent","duration","endTransform","IDENTITY","chainPromise","geocoderService","query","state","nextPromise","otherwise","err","reason","hasOnlyWhitespace","i","cancel","geocoderResults","adjustSuggestionsScroll","focusedItemIndex","searchResults","getElementsByClassName","listItems","getElementsByTagName","element","scrollTop","offsetTop","clientHeight","string","test","removeAll","updateSearchSuggestions","forEach","service","results","AUTOCOMPLETE","newResults","concat","push"],"mappings":"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","sourcesContent":["import CartographicGeocoderService from \"../../Core/CartographicGeocoderService.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport Event from \"../../Core/Event.js\";\nimport GeocodeType from \"../../Core/GeocodeType.js\";\nimport IonGeocoderService from \"../../Core/IonGeocoderService.js\";\nimport CesiumMath from \"../../Core/Math.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Rectangle from \"../../Core/Rectangle.js\";\nimport sampleTerrainMostDetailed from \"../../Core/sampleTerrainMostDetailed.js\";\nimport computeFlyToLocationForRectangle from \"../../Scene/computeFlyToLocationForRectangle.js\";\nimport knockout from \"../../ThirdParty/knockout.js\";\nimport when from \"../../ThirdParty/when.js\";\nimport createCommand from \"../createCommand.js\";\nimport getElement from \"../getElement.js\";\n\n// The height we use if geocoding to a specific point instead of an rectangle.\nvar DEFAULT_HEIGHT = 1000;\n\n/**\n * The view model for the {@link Geocoder} widget.\n * @alias GeocoderViewModel\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Scene} options.scene The Scene instance to use.\n * @param {GeocoderService[]} [options.geocoderServices] Geocoder services to use for geocoding queries.\n *        If more than one are supplied, suggestions will be gathered for the geocoders that support it,\n *        and if no suggestion is selected the result from the first geocoder service wil be used.\n * @param {Number} [options.flightDuration] The duration of the camera flight to an entered location, in seconds.\n * @param {Geocoder~DestinationFoundFunction} [options.destinationFound=GeocoderViewModel.flyToDestination] A callback function that is called after a successful geocode.  If not supplied, the default behavior is to fly the camera to the result destination.\n */\nfunction GeocoderViewModel(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.scene)) {\n    throw new DeveloperError(\"options.scene is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (defined(options.geocoderServices)) {\n    this._geocoderServices = options.geocoderServices;\n  } else {\n    this._geocoderServices = [\n      new CartographicGeocoderService(),\n      new IonGeocoderService({ scene: options.scene }),\n    ];\n  }\n\n  this._viewContainer = options.container;\n  this._scene = options.scene;\n  this._flightDuration = options.flightDuration;\n  this._searchText = \"\";\n  this._isSearchInProgress = false;\n  this._geocodePromise = undefined;\n  this._complete = new Event();\n  this._suggestions = [];\n  this._selectedSuggestion = undefined;\n  this._showSuggestions = true;\n\n  this._handleArrowDown = handleArrowDown;\n  this._handleArrowUp = handleArrowUp;\n\n  var that = this;\n\n  this._suggestionsVisible = knockout.pureComputed(function () {\n    var suggestions = knockout.getObservable(that, \"_suggestions\");\n    var suggestionsNotEmpty = suggestions().length > 0;\n    var showSuggestions = knockout.getObservable(that, \"_showSuggestions\")();\n    return suggestionsNotEmpty && showSuggestions;\n  });\n\n  this._searchCommand = createCommand(function (geocodeType) {\n    geocodeType = defaultValue(geocodeType, GeocodeType.SEARCH);\n    that._focusTextbox = false;\n    if (defined(that._selectedSuggestion)) {\n      that.activateSuggestion(that._selectedSuggestion);\n      return false;\n    }\n    that.hideSuggestions();\n    if (that.isSearchInProgress) {\n      cancelGeocode(that);\n    } else {\n      geocode(that, that._geocoderServices, geocodeType);\n    }\n  });\n\n  this.deselectSuggestion = function () {\n    that._selectedSuggestion = undefined;\n  };\n\n  this.handleKeyDown = function (data, event) {\n    var downKey =\n      event.key === \"ArrowDown\" || event.key === \"Down\" || event.keyCode === 40;\n    var upKey =\n      event.key === \"ArrowUp\" || event.key === \"Up\" || event.keyCode === 38;\n    if (downKey || upKey) {\n      event.preventDefault();\n    }\n\n    return true;\n  };\n\n  this.handleKeyUp = function (data, event) {\n    var downKey =\n      event.key === \"ArrowDown\" || event.key === \"Down\" || event.keyCode === 40;\n    var upKey =\n      event.key === \"ArrowUp\" || event.key === \"Up\" || event.keyCode === 38;\n    var enterKey = event.key === \"Enter\" || event.keyCode === 13;\n    if (upKey) {\n      handleArrowUp(that);\n    } else if (downKey) {\n      handleArrowDown(that);\n    } else if (enterKey) {\n      that._searchCommand();\n    }\n    return true;\n  };\n\n  this.activateSuggestion = function (data) {\n    that.hideSuggestions();\n    that._searchText = data.displayName;\n    var destination = data.destination;\n    clearSuggestions(that);\n    that.destinationFound(that, destination);\n  };\n\n  this.hideSuggestions = function () {\n    that._showSuggestions = false;\n    that._selectedSuggestion = undefined;\n  };\n\n  this.showSuggestions = function () {\n    that._showSuggestions = true;\n  };\n\n  this.handleMouseover = function (data, event) {\n    if (data !== that._selectedSuggestion) {\n      that._selectedSuggestion = data;\n    }\n  };\n\n  /**\n   * Gets or sets a value indicating if this instance should always show its text input field.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  this.keepExpanded = false;\n\n  /**\n   * True if the geocoder should query as the user types to autocomplete\n   * @type {Boolean}\n   * @default true\n   */\n  this.autoComplete = defaultValue(options.autocomplete, true);\n\n  /**\n   * Gets and sets the command called when a geocode destination is found\n   * @type {Geocoder~DestinationFoundFunction}\n   */\n  this.destinationFound = defaultValue(\n    options.destinationFound,\n    GeocoderViewModel.flyToDestination\n  );\n\n  this._focusTextbox = false;\n\n  knockout.track(this, [\n    \"_searchText\",\n    \"_isSearchInProgress\",\n    \"keepExpanded\",\n    \"_suggestions\",\n    \"_selectedSuggestion\",\n    \"_showSuggestions\",\n    \"_focusTextbox\",\n  ]);\n\n  var searchTextObservable = knockout.getObservable(this, \"_searchText\");\n  searchTextObservable.extend({ rateLimit: { timeout: 500 } });\n  this._suggestionSubscription = searchTextObservable.subscribe(function () {\n    GeocoderViewModel._updateSearchSuggestions(that);\n  });\n  /**\n   * Gets a value indicating whether a search is currently in progress.  This property is observable.\n   *\n   * @type {Boolean}\n   */\n  this.isSearchInProgress = undefined;\n  knockout.defineProperty(this, \"isSearchInProgress\", {\n    get: function () {\n      return this._isSearchInProgress;\n    },\n  });\n\n  /**\n   * Gets or sets the text to search for.  The text can be an address, or longitude, latitude,\n   * and optional height, where longitude and latitude are in degrees and height is in meters.\n   *\n   * @type {String}\n   */\n  this.searchText = undefined;\n  knockout.defineProperty(this, \"searchText\", {\n    get: function () {\n      if (this.isSearchInProgress) {\n        return \"Searching...\";\n      }\n\n      return this._searchText;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (typeof value !== \"string\") {\n        throw new DeveloperError(\"value must be a valid string.\");\n      }\n      //>>includeEnd('debug');\n      this._searchText = value;\n    },\n  });\n\n  /**\n   * Gets or sets the the duration of the camera flight in seconds.\n   * A value of zero causes the camera to instantly switch to the geocoding location.\n   * The duration will be computed based on the distance when undefined.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.flightDuration = undefined;\n  knockout.defineProperty(this, \"flightDuration\", {\n    get: function () {\n      return this._flightDuration;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value < 0) {\n        throw new DeveloperError(\"value must be positive.\");\n      }\n      //>>includeEnd('debug');\n\n      this._flightDuration = value;\n    },\n  });\n}\n\nObject.defineProperties(GeocoderViewModel.prototype, {\n  /**\n   * Gets the event triggered on flight completion.\n   * @memberof GeocoderViewModel.prototype\n   *\n   * @type {Event}\n   */\n  complete: {\n    get: function () {\n      return this._complete;\n    },\n  },\n\n  /**\n   * Gets the scene to control.\n   * @memberof GeocoderViewModel.prototype\n   *\n   * @type {Scene}\n   */\n  scene: {\n    get: function () {\n      return this._scene;\n    },\n  },\n\n  /**\n   * Gets the Command that is executed when the button is clicked.\n   * @memberof GeocoderViewModel.prototype\n   *\n   * @type {Command}\n   */\n  search: {\n    get: function () {\n      return this._searchCommand;\n    },\n  },\n\n  /**\n   * Gets the currently selected geocoder search suggestion\n   * @memberof GeocoderViewModel.prototype\n   *\n   * @type {Object}\n   */\n  selectedSuggestion: {\n    get: function () {\n      return this._selectedSuggestion;\n    },\n  },\n\n  /**\n   * Gets the list of geocoder search suggestions\n   * @memberof GeocoderViewModel.prototype\n   *\n   * @type {Object[]}\n   */\n  suggestions: {\n    get: function () {\n      return this._suggestions;\n    },\n  },\n});\n\n/**\n * Destroys the widget.  Should be called if permanently\n * removing the widget from layout.\n */\nGeocoderViewModel.prototype.destroy = function () {\n  this._suggestionSubscription.dispose();\n};\n\nfunction handleArrowUp(viewModel) {\n  if (viewModel._suggestions.length === 0) {\n    return;\n  }\n  var next;\n  var currentIndex = viewModel._suggestions.indexOf(\n    viewModel._selectedSuggestion\n  );\n  if (currentIndex === -1 || currentIndex === 0) {\n    viewModel._selectedSuggestion = undefined;\n    return;\n  }\n  next = currentIndex - 1;\n  viewModel._selectedSuggestion = viewModel._suggestions[next];\n  GeocoderViewModel._adjustSuggestionsScroll(viewModel, next);\n}\n\nfunction handleArrowDown(viewModel) {\n  if (viewModel._suggestions.length === 0) {\n    return;\n  }\n  var numberOfSuggestions = viewModel._suggestions.length;\n  var currentIndex = viewModel._suggestions.indexOf(\n    viewModel._selectedSuggestion\n  );\n  var next = (currentIndex + 1) % numberOfSuggestions;\n  viewModel._selectedSuggestion = viewModel._suggestions[next];\n\n  GeocoderViewModel._adjustSuggestionsScroll(viewModel, next);\n}\n\nfunction computeFlyToLocationForCartographic(cartographic, terrainProvider) {\n  var availability = defined(terrainProvider)\n    ? terrainProvider.availability\n    : undefined;\n\n  if (!defined(availability)) {\n    cartographic.height += DEFAULT_HEIGHT;\n    return when.resolve(cartographic);\n  }\n\n  return sampleTerrainMostDetailed(terrainProvider, [cartographic]).then(\n    function (positionOnTerrain) {\n      cartographic = positionOnTerrain[0];\n      cartographic.height += DEFAULT_HEIGHT;\n      return cartographic;\n    }\n  );\n}\n\nfunction flyToDestination(viewModel, destination) {\n  var scene = viewModel._scene;\n  var mapProjection = scene.mapProjection;\n  var ellipsoid = mapProjection.ellipsoid;\n\n  var camera = scene.camera;\n  var terrainProvider = scene.terrainProvider;\n  var finalDestination = destination;\n\n  var promise;\n  if (destination instanceof Rectangle) {\n    // Some geocoders return a Rectangle of zero width/height, treat it like a point instead.\n    if (\n      CesiumMath.equalsEpsilon(\n        destination.south,\n        destination.north,\n        CesiumMath.EPSILON7\n      ) &&\n      CesiumMath.equalsEpsilon(\n        destination.east,\n        destination.west,\n        CesiumMath.EPSILON7\n      )\n    ) {\n      // destination is now a Cartographic\n      destination = Rectangle.center(destination);\n    } else {\n      promise = computeFlyToLocationForRectangle(destination, scene);\n    }\n  } else {\n    // destination is a Cartesian3\n    destination = ellipsoid.cartesianToCartographic(destination);\n  }\n\n  if (!defined(promise)) {\n    promise = computeFlyToLocationForCartographic(destination, terrainProvider);\n  }\n\n  promise\n    .then(function (result) {\n      finalDestination = ellipsoid.cartographicToCartesian(result);\n    })\n    .always(function () {\n      // Whether terrain querying succeeded or not, fly to the destination.\n      camera.flyTo({\n        destination: finalDestination,\n        complete: function () {\n          viewModel._complete.raiseEvent();\n        },\n        duration: viewModel._flightDuration,\n        endTransform: Matrix4.IDENTITY,\n      });\n    });\n}\n\nfunction chainPromise(promise, geocoderService, query, geocodeType) {\n  return promise.then(function (result) {\n    if (\n      defined(result) &&\n      result.state === \"fulfilled\" &&\n      result.value.length > 0\n    ) {\n      return result;\n    }\n    var nextPromise = geocoderService\n      .geocode(query, geocodeType)\n      .then(function (result) {\n        return { state: \"fulfilled\", value: result };\n      })\n      .otherwise(function (err) {\n        return { state: \"rejected\", reason: err };\n      });\n\n    return nextPromise;\n  });\n}\n\nfunction geocode(viewModel, geocoderServices, geocodeType) {\n  var query = viewModel._searchText;\n\n  if (hasOnlyWhitespace(query)) {\n    viewModel.showSuggestions();\n    return;\n  }\n\n  viewModel._isSearchInProgress = true;\n\n  var promise = when.resolve();\n  for (var i = 0; i < geocoderServices.length; i++) {\n    promise = chainPromise(promise, geocoderServices[i], query, geocodeType);\n  }\n\n  viewModel._geocodePromise = promise;\n  promise.then(function (result) {\n    if (promise.cancel) {\n      return;\n    }\n    viewModel._isSearchInProgress = false;\n\n    var geocoderResults = result.value;\n    if (\n      result.state === \"fulfilled\" &&\n      defined(geocoderResults) &&\n      geocoderResults.length > 0\n    ) {\n      viewModel._searchText = geocoderResults[0].displayName;\n      viewModel.destinationFound(viewModel, geocoderResults[0].destination);\n      return;\n    }\n    viewModel._searchText = query + \" (not found)\";\n  });\n}\n\nfunction adjustSuggestionsScroll(viewModel, focusedItemIndex) {\n  var container = getElement(viewModel._viewContainer);\n  var searchResults = container.getElementsByClassName(\"search-results\")[0];\n  var listItems = container.getElementsByTagName(\"li\");\n  var element = listItems[focusedItemIndex];\n\n  if (focusedItemIndex === 0) {\n    searchResults.scrollTop = 0;\n    return;\n  }\n\n  var offsetTop = element.offsetTop;\n  if (offsetTop + element.clientHeight > searchResults.clientHeight) {\n    searchResults.scrollTop = offsetTop + element.clientHeight;\n  } else if (offsetTop < searchResults.scrollTop) {\n    searchResults.scrollTop = offsetTop;\n  }\n}\n\nfunction cancelGeocode(viewModel) {\n  viewModel._isSearchInProgress = false;\n  if (defined(viewModel._geocodePromise)) {\n    viewModel._geocodePromise.cancel = true;\n    viewModel._geocodePromise = undefined;\n  }\n}\n\nfunction hasOnlyWhitespace(string) {\n  return /^\\s*$/.test(string);\n}\n\nfunction clearSuggestions(viewModel) {\n  knockout.getObservable(viewModel, \"_suggestions\").removeAll();\n}\n\nfunction updateSearchSuggestions(viewModel) {\n  if (!viewModel.autoComplete) {\n    return;\n  }\n\n  var query = viewModel._searchText;\n\n  clearSuggestions(viewModel);\n  if (hasOnlyWhitespace(query)) {\n    return;\n  }\n\n  var promise = when.resolve([]);\n  viewModel._geocoderServices.forEach(function (service) {\n    promise = promise.then(function (results) {\n      if (results.length >= 5) {\n        return results;\n      }\n      return service\n        .geocode(query, GeocodeType.AUTOCOMPLETE)\n        .then(function (newResults) {\n          results = results.concat(newResults);\n          return results;\n        });\n    });\n  });\n  promise.then(function (results) {\n    var suggestions = viewModel._suggestions;\n    for (var i = 0; i < results.length; i++) {\n      suggestions.push(results[i]);\n    }\n  });\n}\n\n/**\n * A function to fly to the destination found by a successful geocode.\n * @type {Geocoder~DestinationFoundFunction}\n */\nGeocoderViewModel.flyToDestination = flyToDestination;\n\n//exposed for testing\nGeocoderViewModel._updateSearchSuggestions = updateSearchSuggestions;\nGeocoderViewModel._adjustSuggestionsScroll = adjustSuggestionsScroll;\nexport default GeocoderViewModel;\n"]},"metadata":{},"sourceType":"module"}