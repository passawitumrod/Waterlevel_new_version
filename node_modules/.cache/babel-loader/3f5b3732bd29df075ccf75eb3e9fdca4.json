{"ast":null,"code":"import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport modernizeShader from \"../Renderer/modernizeShader.js\";\nimport CzmBuiltins from \"../Shaders/Builtin/CzmBuiltins.js\";\nimport AutomaticUniforms from \"./AutomaticUniforms.js\";\n\nfunction removeComments(source) {\n  // remove inline comments\n  source = source.replace(/\\/\\/.*/g, \"\"); // remove multiline comment block\n\n  return source.replace(/\\/\\*\\*[\\s\\S]*?\\*\\//gm, function (match) {\n    // preserve the number of lines in the comment block so the line numbers will be correct when debugging shaders\n    var numberOfLines = match.match(/\\n/gm).length;\n    var replacement = \"\";\n\n    for (var lineNumber = 0; lineNumber < numberOfLines; ++lineNumber) {\n      replacement += \"\\n\";\n    }\n\n    return replacement;\n  });\n}\n\nfunction getDependencyNode(name, glslSource, nodes) {\n  var dependencyNode; // check if already loaded\n\n  for (var i = 0; i < nodes.length; ++i) {\n    if (nodes[i].name === name) {\n      dependencyNode = nodes[i];\n    }\n  }\n\n  if (!defined(dependencyNode)) {\n    // strip doc comments so we don't accidentally try to determine a dependency for something found\n    // in a comment\n    glslSource = removeComments(glslSource); // create new node\n\n    dependencyNode = {\n      name: name,\n      glslSource: glslSource,\n      dependsOn: [],\n      requiredBy: [],\n      evaluated: false\n    };\n    nodes.push(dependencyNode);\n  }\n\n  return dependencyNode;\n}\n\nfunction generateDependencies(currentNode, dependencyNodes) {\n  if (currentNode.evaluated) {\n    return;\n  }\n\n  currentNode.evaluated = true; // identify all dependencies that are referenced from this glsl source code\n\n  var czmMatches = currentNode.glslSource.match(/\\bczm_[a-zA-Z0-9_]*/g);\n\n  if (defined(czmMatches) && czmMatches !== null) {\n    // remove duplicates\n    czmMatches = czmMatches.filter(function (elem, pos) {\n      return czmMatches.indexOf(elem) === pos;\n    });\n    czmMatches.forEach(function (element) {\n      if (element !== currentNode.name && ShaderSource._czmBuiltinsAndUniforms.hasOwnProperty(element)) {\n        var referencedNode = getDependencyNode(element, ShaderSource._czmBuiltinsAndUniforms[element], dependencyNodes);\n        currentNode.dependsOn.push(referencedNode);\n        referencedNode.requiredBy.push(currentNode); // recursive call to find any dependencies of the new node\n\n        generateDependencies(referencedNode, dependencyNodes);\n      }\n    });\n  }\n}\n\nfunction sortDependencies(dependencyNodes) {\n  var nodesWithoutIncomingEdges = [];\n  var allNodes = [];\n\n  while (dependencyNodes.length > 0) {\n    var node = dependencyNodes.pop();\n    allNodes.push(node);\n\n    if (node.requiredBy.length === 0) {\n      nodesWithoutIncomingEdges.push(node);\n    }\n  }\n\n  while (nodesWithoutIncomingEdges.length > 0) {\n    var currentNode = nodesWithoutIncomingEdges.shift();\n    dependencyNodes.push(currentNode);\n\n    for (var i = 0; i < currentNode.dependsOn.length; ++i) {\n      // remove the edge from the graph\n      var referencedNode = currentNode.dependsOn[i];\n      var index = referencedNode.requiredBy.indexOf(currentNode);\n      referencedNode.requiredBy.splice(index, 1); // if referenced node has no more incoming edges, add to list\n\n      if (referencedNode.requiredBy.length === 0) {\n        nodesWithoutIncomingEdges.push(referencedNode);\n      }\n    }\n  } // if there are any nodes left with incoming edges, then there was a circular dependency somewhere in the graph\n\n\n  var badNodes = [];\n\n  for (var j = 0; j < allNodes.length; ++j) {\n    if (allNodes[j].requiredBy.length !== 0) {\n      badNodes.push(allNodes[j]);\n    }\n  } //>>includeStart('debug', pragmas.debug);\n\n\n  if (badNodes.length !== 0) {\n    var message = \"A circular dependency was found in the following built-in functions/structs/constants: \\n\";\n\n    for (var k = 0; k < badNodes.length; ++k) {\n      message = message + badNodes[k].name + \"\\n\";\n    }\n\n    throw new DeveloperError(message);\n  } //>>includeEnd('debug');\n\n}\n\nfunction getBuiltinsAndAutomaticUniforms(shaderSource) {\n  // generate a dependency graph for builtin functions\n  var dependencyNodes = [];\n  var root = getDependencyNode(\"main\", shaderSource, dependencyNodes);\n  generateDependencies(root, dependencyNodes);\n  sortDependencies(dependencyNodes); // Concatenate the source code for the function dependencies.\n  // Iterate in reverse so that dependent items are declared before they are used.\n\n  var builtinsSource = \"\";\n\n  for (var i = dependencyNodes.length - 1; i >= 0; --i) {\n    builtinsSource = builtinsSource + dependencyNodes[i].glslSource + \"\\n\";\n  }\n\n  return builtinsSource.replace(root.glslSource, \"\");\n}\n\nfunction combineShader(shaderSource, isFragmentShader, context) {\n  var i;\n  var length; // Combine shader sources, generally for pseudo-polymorphism, e.g., czm_getMaterial.\n\n  var combinedSources = \"\";\n  var sources = shaderSource.sources;\n\n  if (defined(sources)) {\n    for (i = 0, length = sources.length; i < length; ++i) {\n      // #line needs to be on its own line.\n      combinedSources += \"\\n#line 0\\n\" + sources[i];\n    }\n  }\n\n  combinedSources = removeComments(combinedSources); // Extract existing shader version from sources\n\n  var version;\n  combinedSources = combinedSources.replace(/#version\\s+(.*?)\\n/gm, function (match, group1) {\n    //>>includeStart('debug', pragmas.debug);\n    if (defined(version) && version !== group1) {\n      throw new DeveloperError(\"inconsistent versions found: \" + version + \" and \" + group1);\n    } //>>includeEnd('debug');\n    // Extract #version to put at the top\n\n\n    version = group1; // Replace original #version directive with a new line so the line numbers\n    // are not off by one.  There can be only one #version directive\n    // and it must appear at the top of the source, only preceded by\n    // whitespace and comments.\n\n    return \"\\n\";\n  }); // Extract shader extensions from sources\n\n  var extensions = [];\n  combinedSources = combinedSources.replace(/#extension.*\\n/gm, function (match) {\n    // Extract extension to put at the top\n    extensions.push(match); // Replace original #extension directive with a new line so the line numbers\n    // are not off by one.\n\n    return \"\\n\";\n  }); // Remove precision qualifier\n\n  combinedSources = combinedSources.replace(/precision\\s(lowp|mediump|highp)\\s(float|int);/, \"\"); // Replace main() for picked if desired.\n\n  var pickColorQualifier = shaderSource.pickColorQualifier;\n\n  if (defined(pickColorQualifier)) {\n    combinedSources = ShaderSource.createPickFragmentShaderSource(combinedSources, pickColorQualifier);\n  } // combine into single string\n\n\n  var result = \"\"; // #version must be first\n  // defaults to #version 100 if not specified\n\n  if (defined(version)) {\n    result = \"#version \" + version + \"\\n\";\n  }\n\n  var extensionsLength = extensions.length;\n\n  for (i = 0; i < extensionsLength; i++) {\n    result += extensions[i];\n  }\n\n  if (isFragmentShader) {\n    result += \"\\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\n\\\n    precision highp float;\\n\\\n#else\\n\\\n    precision mediump float;\\n\\\n#endif\\n\\n\";\n  } // Prepend #defines for uber-shaders\n\n\n  var defines = shaderSource.defines;\n\n  if (defined(defines)) {\n    for (i = 0, length = defines.length; i < length; ++i) {\n      var define = defines[i];\n\n      if (define.length !== 0) {\n        result += \"#define \" + define + \"\\n\";\n      }\n    }\n  } // GLSLModernizer inserts its own layout qualifiers\n  // at this position in the source\n\n\n  if (context.webgl2) {\n    result += \"#define OUTPUT_DECLARATION\\n\\n\";\n  } // Define a constant for the OES_texture_float_linear extension since WebGL does not.\n\n\n  if (context.textureFloatLinear) {\n    result += \"#define OES_texture_float_linear\\n\\n\";\n  } // append built-ins\n\n\n  if (shaderSource.includeBuiltIns) {\n    result += getBuiltinsAndAutomaticUniforms(combinedSources);\n  } // reset line number\n\n\n  result += \"\\n#line 0\\n\"; // append actual source\n\n  result += combinedSources; // modernize the source\n\n  if (context.webgl2) {\n    result = modernizeShader(result, isFragmentShader, true);\n  }\n\n  return result;\n}\n/**\n * An object containing various inputs that will be combined to form a final GLSL shader string.\n *\n * @param {Object} [options] Object with the following properties:\n * @param {String[]} [options.sources] An array of strings to combine containing GLSL code for the shader.\n * @param {String[]} [options.defines] An array of strings containing GLSL identifiers to <code>#define</code>.\n * @param {String} [options.pickColorQualifier] The GLSL qualifier, <code>uniform</code> or <code>varying</code>, for the input <code>czm_pickColor</code>.  When defined, a pick fragment shader is generated.\n * @param {Boolean} [options.includeBuiltIns=true] If true, referenced built-in functions will be included with the combined shader.  Set to false if this shader will become a source in another shader, to avoid duplicating functions.\n *\n * @exception {DeveloperError} options.pickColorQualifier must be 'uniform' or 'varying'.\n *\n * @example\n * // 1. Prepend #defines to a shader\n * var source = new Cesium.ShaderSource({\n *   defines : ['WHITE'],\n *   sources : ['void main() { \\n#ifdef WHITE\\n gl_FragColor = vec4(1.0); \\n#else\\n gl_FragColor = vec4(0.0); \\n#endif\\n }']\n * });\n *\n * // 2. Modify a fragment shader for picking\n * var source = new Cesium.ShaderSource({\n *   sources : ['void main() { gl_FragColor = vec4(1.0); }'],\n *   pickColorQualifier : 'uniform'\n * });\n *\n * @private\n */\n\n\nfunction ShaderSource(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var pickColorQualifier = options.pickColorQualifier; //>>includeStart('debug', pragmas.debug);\n\n  if (defined(pickColorQualifier) && pickColorQualifier !== \"uniform\" && pickColorQualifier !== \"varying\") {\n    throw new DeveloperError(\"options.pickColorQualifier must be 'uniform' or 'varying'.\");\n  } //>>includeEnd('debug');\n\n\n  this.defines = defined(options.defines) ? options.defines.slice(0) : [];\n  this.sources = defined(options.sources) ? options.sources.slice(0) : [];\n  this.pickColorQualifier = pickColorQualifier;\n  this.includeBuiltIns = defaultValue(options.includeBuiltIns, true);\n}\n\nShaderSource.prototype.clone = function () {\n  return new ShaderSource({\n    sources: this.sources,\n    defines: this.defines,\n    pickColorQualifier: this.pickColorQualifier,\n    includeBuiltIns: this.includeBuiltIns\n  });\n};\n\nShaderSource.replaceMain = function (source, renamedMain) {\n  renamedMain = \"void \" + renamedMain + \"()\";\n  return source.replace(/void\\s+main\\s*\\(\\s*(?:void)?\\s*\\)/g, renamedMain);\n};\n/**\n * Create a single string containing the full, combined vertex shader with all dependencies and defines.\n *\n * @param {Context} context The current rendering context\n *\n * @returns {String} The combined shader string.\n */\n\n\nShaderSource.prototype.createCombinedVertexShader = function (context) {\n  return combineShader(this, false, context);\n};\n/**\n * Create a single string containing the full, combined fragment shader with all dependencies and defines.\n *\n * @param {Context} context The current rendering context\n *\n * @returns {String} The combined shader string.\n */\n\n\nShaderSource.prototype.createCombinedFragmentShader = function (context) {\n  return combineShader(this, true, context);\n};\n/**\n * For ShaderProgram testing\n * @private\n */\n\n\nShaderSource._czmBuiltinsAndUniforms = {}; // combine automatic uniforms and Cesium built-ins\n\nfor (var builtinName in CzmBuiltins) {\n  if (CzmBuiltins.hasOwnProperty(builtinName)) {\n    ShaderSource._czmBuiltinsAndUniforms[builtinName] = CzmBuiltins[builtinName];\n  }\n}\n\nfor (var uniformName in AutomaticUniforms) {\n  if (AutomaticUniforms.hasOwnProperty(uniformName)) {\n    var uniform = AutomaticUniforms[uniformName];\n\n    if (typeof uniform.getDeclaration === \"function\") {\n      ShaderSource._czmBuiltinsAndUniforms[uniformName] = uniform.getDeclaration(uniformName);\n    }\n  }\n}\n\nShaderSource.createPickVertexShaderSource = function (vertexShaderSource) {\n  var renamedVS = ShaderSource.replaceMain(vertexShaderSource, \"czm_old_main\");\n  var pickMain = \"attribute vec4 pickColor; \\n\" + \"varying vec4 czm_pickColor; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    czm_old_main(); \\n\" + \"    czm_pickColor = pickColor; \\n\" + \"}\";\n  return renamedVS + \"\\n\" + pickMain;\n};\n\nShaderSource.createPickFragmentShaderSource = function (fragmentShaderSource, pickColorQualifier) {\n  var renamedFS = ShaderSource.replaceMain(fragmentShaderSource, \"czm_old_main\");\n  var pickMain = pickColorQualifier + \" vec4 czm_pickColor; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    czm_old_main(); \\n\" + \"    if (gl_FragColor.a == 0.0) { \\n\" + \"       discard; \\n\" + \"    } \\n\" + \"    gl_FragColor = czm_pickColor; \\n\" + \"}\";\n  return renamedFS + \"\\n\" + pickMain;\n};\n\nShaderSource.findVarying = function (shaderSource, names) {\n  var sources = shaderSource.sources;\n  var namesLength = names.length;\n\n  for (var i = 0; i < namesLength; ++i) {\n    var name = names[i];\n    var sourcesLength = sources.length;\n\n    for (var j = 0; j < sourcesLength; ++j) {\n      if (sources[j].indexOf(name) !== -1) {\n        return name;\n      }\n    }\n  }\n\n  return undefined;\n};\n\nvar normalVaryingNames = [\"v_normalEC\", \"v_normal\"];\n\nShaderSource.findNormalVarying = function (shaderSource) {\n  return ShaderSource.findVarying(shaderSource, normalVaryingNames);\n};\n\nvar positionVaryingNames = [\"v_positionEC\"];\n\nShaderSource.findPositionVarying = function (shaderSource) {\n  return ShaderSource.findVarying(shaderSource, positionVaryingNames);\n};\n\nexport default ShaderSource;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Renderer/ShaderSource.js"],"names":["defaultValue","defined","DeveloperError","modernizeShader","CzmBuiltins","AutomaticUniforms","removeComments","source","replace","match","numberOfLines","length","replacement","lineNumber","getDependencyNode","name","glslSource","nodes","dependencyNode","i","dependsOn","requiredBy","evaluated","push","generateDependencies","currentNode","dependencyNodes","czmMatches","filter","elem","pos","indexOf","forEach","element","ShaderSource","_czmBuiltinsAndUniforms","hasOwnProperty","referencedNode","sortDependencies","nodesWithoutIncomingEdges","allNodes","node","pop","shift","index","splice","badNodes","j","message","k","getBuiltinsAndAutomaticUniforms","shaderSource","root","builtinsSource","combineShader","isFragmentShader","context","combinedSources","sources","version","group1","extensions","pickColorQualifier","createPickFragmentShaderSource","result","extensionsLength","defines","define","webgl2","textureFloatLinear","includeBuiltIns","options","EMPTY_OBJECT","slice","prototype","clone","replaceMain","renamedMain","createCombinedVertexShader","createCombinedFragmentShader","builtinName","uniformName","uniform","getDeclaration","createPickVertexShaderSource","vertexShaderSource","renamedVS","pickMain","fragmentShaderSource","renamedFS","findVarying","names","namesLength","sourcesLength","undefined","normalVaryingNames","findNormalVarying","positionVaryingNames","findPositionVarying"],"mappings":"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","sourcesContent":["import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport modernizeShader from \"../Renderer/modernizeShader.js\";\nimport CzmBuiltins from \"../Shaders/Builtin/CzmBuiltins.js\";\nimport AutomaticUniforms from \"./AutomaticUniforms.js\";\n\nfunction removeComments(source) {\n  // remove inline comments\n  source = source.replace(/\\/\\/.*/g, \"\");\n  // remove multiline comment block\n  return source.replace(/\\/\\*\\*[\\s\\S]*?\\*\\//gm, function (match) {\n    // preserve the number of lines in the comment block so the line numbers will be correct when debugging shaders\n    var numberOfLines = match.match(/\\n/gm).length;\n    var replacement = \"\";\n    for (var lineNumber = 0; lineNumber < numberOfLines; ++lineNumber) {\n      replacement += \"\\n\";\n    }\n    return replacement;\n  });\n}\n\nfunction getDependencyNode(name, glslSource, nodes) {\n  var dependencyNode;\n\n  // check if already loaded\n  for (var i = 0; i < nodes.length; ++i) {\n    if (nodes[i].name === name) {\n      dependencyNode = nodes[i];\n    }\n  }\n\n  if (!defined(dependencyNode)) {\n    // strip doc comments so we don't accidentally try to determine a dependency for something found\n    // in a comment\n    glslSource = removeComments(glslSource);\n\n    // create new node\n    dependencyNode = {\n      name: name,\n      glslSource: glslSource,\n      dependsOn: [],\n      requiredBy: [],\n      evaluated: false,\n    };\n    nodes.push(dependencyNode);\n  }\n\n  return dependencyNode;\n}\n\nfunction generateDependencies(currentNode, dependencyNodes) {\n  if (currentNode.evaluated) {\n    return;\n  }\n\n  currentNode.evaluated = true;\n\n  // identify all dependencies that are referenced from this glsl source code\n  var czmMatches = currentNode.glslSource.match(/\\bczm_[a-zA-Z0-9_]*/g);\n  if (defined(czmMatches) && czmMatches !== null) {\n    // remove duplicates\n    czmMatches = czmMatches.filter(function (elem, pos) {\n      return czmMatches.indexOf(elem) === pos;\n    });\n\n    czmMatches.forEach(function (element) {\n      if (\n        element !== currentNode.name &&\n        ShaderSource._czmBuiltinsAndUniforms.hasOwnProperty(element)\n      ) {\n        var referencedNode = getDependencyNode(\n          element,\n          ShaderSource._czmBuiltinsAndUniforms[element],\n          dependencyNodes\n        );\n        currentNode.dependsOn.push(referencedNode);\n        referencedNode.requiredBy.push(currentNode);\n\n        // recursive call to find any dependencies of the new node\n        generateDependencies(referencedNode, dependencyNodes);\n      }\n    });\n  }\n}\n\nfunction sortDependencies(dependencyNodes) {\n  var nodesWithoutIncomingEdges = [];\n  var allNodes = [];\n\n  while (dependencyNodes.length > 0) {\n    var node = dependencyNodes.pop();\n    allNodes.push(node);\n\n    if (node.requiredBy.length === 0) {\n      nodesWithoutIncomingEdges.push(node);\n    }\n  }\n\n  while (nodesWithoutIncomingEdges.length > 0) {\n    var currentNode = nodesWithoutIncomingEdges.shift();\n\n    dependencyNodes.push(currentNode);\n\n    for (var i = 0; i < currentNode.dependsOn.length; ++i) {\n      // remove the edge from the graph\n      var referencedNode = currentNode.dependsOn[i];\n      var index = referencedNode.requiredBy.indexOf(currentNode);\n      referencedNode.requiredBy.splice(index, 1);\n\n      // if referenced node has no more incoming edges, add to list\n      if (referencedNode.requiredBy.length === 0) {\n        nodesWithoutIncomingEdges.push(referencedNode);\n      }\n    }\n  }\n\n  // if there are any nodes left with incoming edges, then there was a circular dependency somewhere in the graph\n  var badNodes = [];\n  for (var j = 0; j < allNodes.length; ++j) {\n    if (allNodes[j].requiredBy.length !== 0) {\n      badNodes.push(allNodes[j]);\n    }\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (badNodes.length !== 0) {\n    var message =\n      \"A circular dependency was found in the following built-in functions/structs/constants: \\n\";\n    for (var k = 0; k < badNodes.length; ++k) {\n      message = message + badNodes[k].name + \"\\n\";\n    }\n    throw new DeveloperError(message);\n  }\n  //>>includeEnd('debug');\n}\n\nfunction getBuiltinsAndAutomaticUniforms(shaderSource) {\n  // generate a dependency graph for builtin functions\n  var dependencyNodes = [];\n  var root = getDependencyNode(\"main\", shaderSource, dependencyNodes);\n  generateDependencies(root, dependencyNodes);\n  sortDependencies(dependencyNodes);\n\n  // Concatenate the source code for the function dependencies.\n  // Iterate in reverse so that dependent items are declared before they are used.\n  var builtinsSource = \"\";\n  for (var i = dependencyNodes.length - 1; i >= 0; --i) {\n    builtinsSource = builtinsSource + dependencyNodes[i].glslSource + \"\\n\";\n  }\n\n  return builtinsSource.replace(root.glslSource, \"\");\n}\n\nfunction combineShader(shaderSource, isFragmentShader, context) {\n  var i;\n  var length;\n\n  // Combine shader sources, generally for pseudo-polymorphism, e.g., czm_getMaterial.\n  var combinedSources = \"\";\n  var sources = shaderSource.sources;\n  if (defined(sources)) {\n    for (i = 0, length = sources.length; i < length; ++i) {\n      // #line needs to be on its own line.\n      combinedSources += \"\\n#line 0\\n\" + sources[i];\n    }\n  }\n\n  combinedSources = removeComments(combinedSources);\n\n  // Extract existing shader version from sources\n  var version;\n  combinedSources = combinedSources.replace(/#version\\s+(.*?)\\n/gm, function (\n    match,\n    group1\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    if (defined(version) && version !== group1) {\n      throw new DeveloperError(\n        \"inconsistent versions found: \" + version + \" and \" + group1\n      );\n    }\n    //>>includeEnd('debug');\n\n    // Extract #version to put at the top\n    version = group1;\n\n    // Replace original #version directive with a new line so the line numbers\n    // are not off by one.  There can be only one #version directive\n    // and it must appear at the top of the source, only preceded by\n    // whitespace and comments.\n    return \"\\n\";\n  });\n\n  // Extract shader extensions from sources\n  var extensions = [];\n  combinedSources = combinedSources.replace(/#extension.*\\n/gm, function (\n    match\n  ) {\n    // Extract extension to put at the top\n    extensions.push(match);\n\n    // Replace original #extension directive with a new line so the line numbers\n    // are not off by one.\n    return \"\\n\";\n  });\n\n  // Remove precision qualifier\n  combinedSources = combinedSources.replace(\n    /precision\\s(lowp|mediump|highp)\\s(float|int);/,\n    \"\"\n  );\n\n  // Replace main() for picked if desired.\n  var pickColorQualifier = shaderSource.pickColorQualifier;\n  if (defined(pickColorQualifier)) {\n    combinedSources = ShaderSource.createPickFragmentShaderSource(\n      combinedSources,\n      pickColorQualifier\n    );\n  }\n\n  // combine into single string\n  var result = \"\";\n\n  // #version must be first\n  // defaults to #version 100 if not specified\n  if (defined(version)) {\n    result = \"#version \" + version + \"\\n\";\n  }\n\n  var extensionsLength = extensions.length;\n  for (i = 0; i < extensionsLength; i++) {\n    result += extensions[i];\n  }\n\n  if (isFragmentShader) {\n    result +=\n      \"\\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\n\\\n    precision highp float;\\n\\\n#else\\n\\\n    precision mediump float;\\n\\\n#endif\\n\\n\";\n  }\n\n  // Prepend #defines for uber-shaders\n  var defines = shaderSource.defines;\n  if (defined(defines)) {\n    for (i = 0, length = defines.length; i < length; ++i) {\n      var define = defines[i];\n      if (define.length !== 0) {\n        result += \"#define \" + define + \"\\n\";\n      }\n    }\n  }\n\n  // GLSLModernizer inserts its own layout qualifiers\n  // at this position in the source\n  if (context.webgl2) {\n    result += \"#define OUTPUT_DECLARATION\\n\\n\";\n  }\n\n  // Define a constant for the OES_texture_float_linear extension since WebGL does not.\n  if (context.textureFloatLinear) {\n    result += \"#define OES_texture_float_linear\\n\\n\";\n  }\n\n  // append built-ins\n  if (shaderSource.includeBuiltIns) {\n    result += getBuiltinsAndAutomaticUniforms(combinedSources);\n  }\n\n  // reset line number\n  result += \"\\n#line 0\\n\";\n\n  // append actual source\n  result += combinedSources;\n\n  // modernize the source\n  if (context.webgl2) {\n    result = modernizeShader(result, isFragmentShader, true);\n  }\n\n  return result;\n}\n\n/**\n * An object containing various inputs that will be combined to form a final GLSL shader string.\n *\n * @param {Object} [options] Object with the following properties:\n * @param {String[]} [options.sources] An array of strings to combine containing GLSL code for the shader.\n * @param {String[]} [options.defines] An array of strings containing GLSL identifiers to <code>#define</code>.\n * @param {String} [options.pickColorQualifier] The GLSL qualifier, <code>uniform</code> or <code>varying</code>, for the input <code>czm_pickColor</code>.  When defined, a pick fragment shader is generated.\n * @param {Boolean} [options.includeBuiltIns=true] If true, referenced built-in functions will be included with the combined shader.  Set to false if this shader will become a source in another shader, to avoid duplicating functions.\n *\n * @exception {DeveloperError} options.pickColorQualifier must be 'uniform' or 'varying'.\n *\n * @example\n * // 1. Prepend #defines to a shader\n * var source = new Cesium.ShaderSource({\n *   defines : ['WHITE'],\n *   sources : ['void main() { \\n#ifdef WHITE\\n gl_FragColor = vec4(1.0); \\n#else\\n gl_FragColor = vec4(0.0); \\n#endif\\n }']\n * });\n *\n * // 2. Modify a fragment shader for picking\n * var source = new Cesium.ShaderSource({\n *   sources : ['void main() { gl_FragColor = vec4(1.0); }'],\n *   pickColorQualifier : 'uniform'\n * });\n *\n * @private\n */\nfunction ShaderSource(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var pickColorQualifier = options.pickColorQualifier;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    defined(pickColorQualifier) &&\n    pickColorQualifier !== \"uniform\" &&\n    pickColorQualifier !== \"varying\"\n  ) {\n    throw new DeveloperError(\n      \"options.pickColorQualifier must be 'uniform' or 'varying'.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this.defines = defined(options.defines) ? options.defines.slice(0) : [];\n  this.sources = defined(options.sources) ? options.sources.slice(0) : [];\n  this.pickColorQualifier = pickColorQualifier;\n  this.includeBuiltIns = defaultValue(options.includeBuiltIns, true);\n}\n\nShaderSource.prototype.clone = function () {\n  return new ShaderSource({\n    sources: this.sources,\n    defines: this.defines,\n    pickColorQualifier: this.pickColorQualifier,\n    includeBuiltIns: this.includeBuiltIns,\n  });\n};\n\nShaderSource.replaceMain = function (source, renamedMain) {\n  renamedMain = \"void \" + renamedMain + \"()\";\n  return source.replace(/void\\s+main\\s*\\(\\s*(?:void)?\\s*\\)/g, renamedMain);\n};\n\n/**\n * Create a single string containing the full, combined vertex shader with all dependencies and defines.\n *\n * @param {Context} context The current rendering context\n *\n * @returns {String} The combined shader string.\n */\nShaderSource.prototype.createCombinedVertexShader = function (context) {\n  return combineShader(this, false, context);\n};\n\n/**\n * Create a single string containing the full, combined fragment shader with all dependencies and defines.\n *\n * @param {Context} context The current rendering context\n *\n * @returns {String} The combined shader string.\n */\nShaderSource.prototype.createCombinedFragmentShader = function (context) {\n  return combineShader(this, true, context);\n};\n\n/**\n * For ShaderProgram testing\n * @private\n */\nShaderSource._czmBuiltinsAndUniforms = {};\n\n// combine automatic uniforms and Cesium built-ins\nfor (var builtinName in CzmBuiltins) {\n  if (CzmBuiltins.hasOwnProperty(builtinName)) {\n    ShaderSource._czmBuiltinsAndUniforms[builtinName] =\n      CzmBuiltins[builtinName];\n  }\n}\nfor (var uniformName in AutomaticUniforms) {\n  if (AutomaticUniforms.hasOwnProperty(uniformName)) {\n    var uniform = AutomaticUniforms[uniformName];\n    if (typeof uniform.getDeclaration === \"function\") {\n      ShaderSource._czmBuiltinsAndUniforms[\n        uniformName\n      ] = uniform.getDeclaration(uniformName);\n    }\n  }\n}\n\nShaderSource.createPickVertexShaderSource = function (vertexShaderSource) {\n  var renamedVS = ShaderSource.replaceMain(vertexShaderSource, \"czm_old_main\");\n  var pickMain =\n    \"attribute vec4 pickColor; \\n\" +\n    \"varying vec4 czm_pickColor; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    czm_old_main(); \\n\" +\n    \"    czm_pickColor = pickColor; \\n\" +\n    \"}\";\n\n  return renamedVS + \"\\n\" + pickMain;\n};\n\nShaderSource.createPickFragmentShaderSource = function (\n  fragmentShaderSource,\n  pickColorQualifier\n) {\n  var renamedFS = ShaderSource.replaceMain(\n    fragmentShaderSource,\n    \"czm_old_main\"\n  );\n  var pickMain =\n    pickColorQualifier +\n    \" vec4 czm_pickColor; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    czm_old_main(); \\n\" +\n    \"    if (gl_FragColor.a == 0.0) { \\n\" +\n    \"       discard; \\n\" +\n    \"    } \\n\" +\n    \"    gl_FragColor = czm_pickColor; \\n\" +\n    \"}\";\n\n  return renamedFS + \"\\n\" + pickMain;\n};\n\nShaderSource.findVarying = function (shaderSource, names) {\n  var sources = shaderSource.sources;\n\n  var namesLength = names.length;\n  for (var i = 0; i < namesLength; ++i) {\n    var name = names[i];\n\n    var sourcesLength = sources.length;\n    for (var j = 0; j < sourcesLength; ++j) {\n      if (sources[j].indexOf(name) !== -1) {\n        return name;\n      }\n    }\n  }\n\n  return undefined;\n};\n\nvar normalVaryingNames = [\"v_normalEC\", \"v_normal\"];\n\nShaderSource.findNormalVarying = function (shaderSource) {\n  return ShaderSource.findVarying(shaderSource, normalVaryingNames);\n};\n\nvar positionVaryingNames = [\"v_positionEC\"];\n\nShaderSource.findPositionVarying = function (shaderSource) {\n  return ShaderSource.findVarying(shaderSource, positionVaryingNames);\n};\nexport default ShaderSource;\n"]},"metadata":{},"sourceType":"module"}