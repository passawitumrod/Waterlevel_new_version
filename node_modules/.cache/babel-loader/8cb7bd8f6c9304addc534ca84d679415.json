{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Buffer from \"./Buffer.js\";\nimport BufferUsage from \"./BufferUsage.js\";\nimport VertexArray from \"./VertexArray.js\";\n/**\n * @private\n */\n\nfunction VertexArrayFacade(context, attributes, sizeInVertices, instanced) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"context\", context);\n\n  if (!attributes || attributes.length === 0) {\n    throw new DeveloperError(\"At least one attribute is required.\");\n  } //>>includeEnd('debug');\n\n\n  var attrs = VertexArrayFacade._verifyAttributes(attributes);\n\n  sizeInVertices = defaultValue(sizeInVertices, 0);\n  var precreatedAttributes = [];\n  var attributesByUsage = {};\n  var attributesForUsage;\n  var usage; // Bucket the attributes by usage.\n\n  var length = attrs.length;\n\n  for (var i = 0; i < length; ++i) {\n    var attribute = attrs[i]; // If the attribute already has a vertex buffer, we do not need\n    // to manage a vertex buffer or typed array for it.\n\n    if (attribute.vertexBuffer) {\n      precreatedAttributes.push(attribute);\n      continue;\n    }\n\n    usage = attribute.usage;\n    attributesForUsage = attributesByUsage[usage];\n\n    if (!defined(attributesForUsage)) {\n      attributesForUsage = attributesByUsage[usage] = [];\n    }\n\n    attributesForUsage.push(attribute);\n  } // A function to sort attributes by the size of their components.  From left to right, a vertex\n  // stores floats, shorts, and then bytes.\n\n\n  function compare(left, right) {\n    return ComponentDatatype.getSizeInBytes(right.componentDatatype) - ComponentDatatype.getSizeInBytes(left.componentDatatype);\n  }\n\n  this._allBuffers = [];\n\n  for (usage in attributesByUsage) {\n    if (attributesByUsage.hasOwnProperty(usage)) {\n      attributesForUsage = attributesByUsage[usage];\n      attributesForUsage.sort(compare);\n\n      var vertexSizeInBytes = VertexArrayFacade._vertexSizeInBytes(attributesForUsage);\n\n      var bufferUsage = attributesForUsage[0].usage;\n      var buffer = {\n        vertexSizeInBytes: vertexSizeInBytes,\n        vertexBuffer: undefined,\n        usage: bufferUsage,\n        needsCommit: false,\n        arrayBuffer: undefined,\n        arrayViews: VertexArrayFacade._createArrayViews(attributesForUsage, vertexSizeInBytes)\n      };\n\n      this._allBuffers.push(buffer);\n    }\n  }\n\n  this._size = 0;\n  this._instanced = defaultValue(instanced, false);\n  this._precreated = precreatedAttributes;\n  this._context = context;\n  this.writers = undefined;\n  this.va = undefined;\n  this.resize(sizeInVertices);\n}\n\nVertexArrayFacade._verifyAttributes = function (attributes) {\n  var attrs = [];\n\n  for (var i = 0; i < attributes.length; ++i) {\n    var attribute = attributes[i];\n    var attr = {\n      index: defaultValue(attribute.index, i),\n      enabled: defaultValue(attribute.enabled, true),\n      componentsPerAttribute: attribute.componentsPerAttribute,\n      componentDatatype: defaultValue(attribute.componentDatatype, ComponentDatatype.FLOAT),\n      normalize: defaultValue(attribute.normalize, false),\n      // There will be either a vertexBuffer or an [optional] usage.\n      vertexBuffer: attribute.vertexBuffer,\n      usage: defaultValue(attribute.usage, BufferUsage.STATIC_DRAW)\n    };\n    attrs.push(attr); //>>includeStart('debug', pragmas.debug);\n\n    if (attr.componentsPerAttribute !== 1 && attr.componentsPerAttribute !== 2 && attr.componentsPerAttribute !== 3 && attr.componentsPerAttribute !== 4) {\n      throw new DeveloperError(\"attribute.componentsPerAttribute must be in the range [1, 4].\");\n    }\n\n    var datatype = attr.componentDatatype;\n\n    if (!ComponentDatatype.validate(datatype)) {\n      throw new DeveloperError(\"Attribute must have a valid componentDatatype or not specify it.\");\n    }\n\n    if (!BufferUsage.validate(attr.usage)) {\n      throw new DeveloperError(\"Attribute must have a valid usage or not specify it.\");\n    } //>>includeEnd('debug');\n\n  } // Verify all attribute names are unique.\n\n\n  var uniqueIndices = new Array(attrs.length);\n\n  for (var j = 0; j < attrs.length; ++j) {\n    var currentAttr = attrs[j];\n    var index = currentAttr.index; //>>includeStart('debug', pragmas.debug);\n\n    if (uniqueIndices[index]) {\n      throw new DeveloperError(\"Index \" + index + \" is used by more than one attribute.\");\n    } //>>includeEnd('debug');\n\n\n    uniqueIndices[index] = true;\n  }\n\n  return attrs;\n};\n\nVertexArrayFacade._vertexSizeInBytes = function (attributes) {\n  var sizeInBytes = 0;\n  var length = attributes.length;\n\n  for (var i = 0; i < length; ++i) {\n    var attribute = attributes[i];\n    sizeInBytes += attribute.componentsPerAttribute * ComponentDatatype.getSizeInBytes(attribute.componentDatatype);\n  }\n\n  var maxComponentSizeInBytes = length > 0 ? ComponentDatatype.getSizeInBytes(attributes[0].componentDatatype) : 0; // Sorted by size\n\n  var remainder = maxComponentSizeInBytes > 0 ? sizeInBytes % maxComponentSizeInBytes : 0;\n  var padding = remainder === 0 ? 0 : maxComponentSizeInBytes - remainder;\n  sizeInBytes += padding;\n  return sizeInBytes;\n};\n\nVertexArrayFacade._createArrayViews = function (attributes, vertexSizeInBytes) {\n  var views = [];\n  var offsetInBytes = 0;\n  var length = attributes.length;\n\n  for (var i = 0; i < length; ++i) {\n    var attribute = attributes[i];\n    var componentDatatype = attribute.componentDatatype;\n    views.push({\n      index: attribute.index,\n      enabled: attribute.enabled,\n      componentsPerAttribute: attribute.componentsPerAttribute,\n      componentDatatype: componentDatatype,\n      normalize: attribute.normalize,\n      offsetInBytes: offsetInBytes,\n      vertexSizeInComponentType: vertexSizeInBytes / ComponentDatatype.getSizeInBytes(componentDatatype),\n      view: undefined\n    });\n    offsetInBytes += attribute.componentsPerAttribute * ComponentDatatype.getSizeInBytes(componentDatatype);\n  }\n\n  return views;\n};\n/**\n * Invalidates writers.  Can't render again until commit is called.\n */\n\n\nVertexArrayFacade.prototype.resize = function (sizeInVertices) {\n  this._size = sizeInVertices;\n  var allBuffers = this._allBuffers;\n  this.writers = [];\n\n  for (var i = 0, len = allBuffers.length; i < len; ++i) {\n    var buffer = allBuffers[i];\n\n    VertexArrayFacade._resize(buffer, this._size); // Reserving invalidates the writers, so if client's cache them, they need to invalidate their cache.\n\n\n    VertexArrayFacade._appendWriters(this.writers, buffer);\n  } // VAs are recreated next time commit is called.\n\n\n  destroyVA(this);\n};\n\nVertexArrayFacade._resize = function (buffer, size) {\n  if (buffer.vertexSizeInBytes > 0) {\n    // Create larger array buffer\n    var arrayBuffer = new ArrayBuffer(size * buffer.vertexSizeInBytes); // Copy contents from previous array buffer\n\n    if (defined(buffer.arrayBuffer)) {\n      var destView = new Uint8Array(arrayBuffer);\n      var sourceView = new Uint8Array(buffer.arrayBuffer);\n      var sourceLength = sourceView.length;\n\n      for (var j = 0; j < sourceLength; ++j) {\n        destView[j] = sourceView[j];\n      }\n    } // Create typed views into the new array buffer\n\n\n    var views = buffer.arrayViews;\n    var length = views.length;\n\n    for (var i = 0; i < length; ++i) {\n      var view = views[i];\n      view.view = ComponentDatatype.createArrayBufferView(view.componentDatatype, arrayBuffer, view.offsetInBytes);\n    }\n\n    buffer.arrayBuffer = arrayBuffer;\n  }\n};\n\nvar createWriters = [// 1 component per attribute\nfunction (buffer, view, vertexSizeInComponentType) {\n  return function (index, attribute) {\n    view[index * vertexSizeInComponentType] = attribute;\n    buffer.needsCommit = true;\n  };\n}, // 2 component per attribute\nfunction (buffer, view, vertexSizeInComponentType) {\n  return function (index, component0, component1) {\n    var i = index * vertexSizeInComponentType;\n    view[i] = component0;\n    view[i + 1] = component1;\n    buffer.needsCommit = true;\n  };\n}, // 3 component per attribute\nfunction (buffer, view, vertexSizeInComponentType) {\n  return function (index, component0, component1, component2) {\n    var i = index * vertexSizeInComponentType;\n    view[i] = component0;\n    view[i + 1] = component1;\n    view[i + 2] = component2;\n    buffer.needsCommit = true;\n  };\n}, // 4 component per attribute\nfunction (buffer, view, vertexSizeInComponentType) {\n  return function (index, component0, component1, component2, component3) {\n    var i = index * vertexSizeInComponentType;\n    view[i] = component0;\n    view[i + 1] = component1;\n    view[i + 2] = component2;\n    view[i + 3] = component3;\n    buffer.needsCommit = true;\n  };\n}];\n\nVertexArrayFacade._appendWriters = function (writers, buffer) {\n  var arrayViews = buffer.arrayViews;\n  var length = arrayViews.length;\n\n  for (var i = 0; i < length; ++i) {\n    var arrayView = arrayViews[i];\n    writers[arrayView.index] = createWriters[arrayView.componentsPerAttribute - 1](buffer, arrayView.view, arrayView.vertexSizeInComponentType);\n  }\n};\n\nVertexArrayFacade.prototype.commit = function (indexBuffer) {\n  var recreateVA = false;\n  var allBuffers = this._allBuffers;\n  var buffer;\n  var i;\n  var length;\n\n  for (i = 0, length = allBuffers.length; i < length; ++i) {\n    buffer = allBuffers[i];\n    recreateVA = commit(this, buffer) || recreateVA;\n  } ///////////////////////////////////////////////////////////////////////\n\n\n  if (recreateVA || !defined(this.va)) {\n    destroyVA(this);\n    var va = this.va = [];\n    var chunkSize = CesiumMath.SIXTY_FOUR_KILOBYTES - 4; // The 65535 index is reserved for primitive restart. Reserve the last 4 indices so that billboard quads are not broken up.\n\n    var numberOfVertexArrays = defined(indexBuffer) && !this._instanced ? Math.ceil(this._size / chunkSize) : 1;\n\n    for (var k = 0; k < numberOfVertexArrays; ++k) {\n      var attributes = [];\n\n      for (i = 0, length = allBuffers.length; i < length; ++i) {\n        buffer = allBuffers[i];\n        var offset = k * (buffer.vertexSizeInBytes * chunkSize);\n\n        VertexArrayFacade._appendAttributes(attributes, buffer, offset, this._instanced);\n      }\n\n      attributes = attributes.concat(this._precreated);\n      va.push({\n        va: new VertexArray({\n          context: this._context,\n          attributes: attributes,\n          indexBuffer: indexBuffer\n        }),\n        indicesCount: 1.5 * (k !== numberOfVertexArrays - 1 ? chunkSize : this._size % chunkSize) // TODO: not hardcode 1.5, this assumes 6 indices per 4 vertices (as for Billboard quads).\n\n      });\n    }\n  }\n};\n\nfunction commit(vertexArrayFacade, buffer) {\n  if (buffer.needsCommit && buffer.vertexSizeInBytes > 0) {\n    buffer.needsCommit = false;\n    var vertexBuffer = buffer.vertexBuffer;\n    var vertexBufferSizeInBytes = vertexArrayFacade._size * buffer.vertexSizeInBytes;\n    var vertexBufferDefined = defined(vertexBuffer);\n\n    if (!vertexBufferDefined || vertexBuffer.sizeInBytes < vertexBufferSizeInBytes) {\n      if (vertexBufferDefined) {\n        vertexBuffer.destroy();\n      }\n\n      buffer.vertexBuffer = Buffer.createVertexBuffer({\n        context: vertexArrayFacade._context,\n        typedArray: buffer.arrayBuffer,\n        usage: buffer.usage\n      });\n      buffer.vertexBuffer.vertexArrayDestroyable = false;\n      return true; // Created new vertex buffer\n    }\n\n    buffer.vertexBuffer.copyFromArrayView(buffer.arrayBuffer);\n  }\n\n  return false; // Did not create new vertex buffer\n}\n\nVertexArrayFacade._appendAttributes = function (attributes, buffer, vertexBufferOffset, instanced) {\n  var arrayViews = buffer.arrayViews;\n  var length = arrayViews.length;\n\n  for (var i = 0; i < length; ++i) {\n    var view = arrayViews[i];\n    attributes.push({\n      index: view.index,\n      enabled: view.enabled,\n      componentsPerAttribute: view.componentsPerAttribute,\n      componentDatatype: view.componentDatatype,\n      normalize: view.normalize,\n      vertexBuffer: buffer.vertexBuffer,\n      offsetInBytes: vertexBufferOffset + view.offsetInBytes,\n      strideInBytes: buffer.vertexSizeInBytes,\n      instanceDivisor: instanced ? 1 : 0\n    });\n  }\n};\n\nVertexArrayFacade.prototype.subCommit = function (offsetInVertices, lengthInVertices) {\n  //>>includeStart('debug', pragmas.debug);\n  if (offsetInVertices < 0 || offsetInVertices >= this._size) {\n    throw new DeveloperError(\"offsetInVertices must be greater than or equal to zero and less than the vertex array size.\");\n  }\n\n  if (offsetInVertices + lengthInVertices > this._size) {\n    throw new DeveloperError(\"offsetInVertices + lengthInVertices cannot exceed the vertex array size.\");\n  } //>>includeEnd('debug');\n\n\n  var allBuffers = this._allBuffers;\n\n  for (var i = 0, len = allBuffers.length; i < len; ++i) {\n    subCommit(allBuffers[i], offsetInVertices, lengthInVertices);\n  }\n};\n\nfunction subCommit(buffer, offsetInVertices, lengthInVertices) {\n  if (buffer.needsCommit && buffer.vertexSizeInBytes > 0) {\n    var byteOffset = buffer.vertexSizeInBytes * offsetInVertices;\n    var byteLength = buffer.vertexSizeInBytes * lengthInVertices; // PERFORMANCE_IDEA: If we want to get really crazy, we could consider updating\n    // individual attributes instead of the entire (sub-)vertex.\n    //\n    // PERFORMANCE_IDEA: Does creating the typed view add too much GC overhead?\n\n    buffer.vertexBuffer.copyFromArrayView(new Uint8Array(buffer.arrayBuffer, byteOffset, byteLength), byteOffset);\n  }\n}\n\nVertexArrayFacade.prototype.endSubCommits = function () {\n  var allBuffers = this._allBuffers;\n\n  for (var i = 0, len = allBuffers.length; i < len; ++i) {\n    allBuffers[i].needsCommit = false;\n  }\n};\n\nfunction destroyVA(vertexArrayFacade) {\n  var va = vertexArrayFacade.va;\n\n  if (!defined(va)) {\n    return;\n  }\n\n  var length = va.length;\n\n  for (var i = 0; i < length; ++i) {\n    va[i].va.destroy();\n  }\n\n  vertexArrayFacade.va = undefined;\n}\n\nVertexArrayFacade.prototype.isDestroyed = function () {\n  return false;\n};\n\nVertexArrayFacade.prototype.destroy = function () {\n  var allBuffers = this._allBuffers;\n\n  for (var i = 0, len = allBuffers.length; i < len; ++i) {\n    var buffer = allBuffers[i];\n    buffer.vertexBuffer = buffer.vertexBuffer && buffer.vertexBuffer.destroy();\n  }\n\n  destroyVA(this);\n  return destroyObject(this);\n};\n\nexport default VertexArrayFacade;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Renderer/VertexArrayFacade.js"],"names":["Check","ComponentDatatype","defaultValue","defined","destroyObject","DeveloperError","CesiumMath","Buffer","BufferUsage","VertexArray","VertexArrayFacade","context","attributes","sizeInVertices","instanced","length","attrs","_verifyAttributes","precreatedAttributes","attributesByUsage","attributesForUsage","usage","i","attribute","vertexBuffer","push","compare","left","right","getSizeInBytes","componentDatatype","_allBuffers","hasOwnProperty","sort","vertexSizeInBytes","_vertexSizeInBytes","bufferUsage","buffer","undefined","needsCommit","arrayBuffer","arrayViews","_createArrayViews","_size","_instanced","_precreated","_context","writers","va","resize","attr","index","enabled","componentsPerAttribute","FLOAT","normalize","STATIC_DRAW","datatype","validate","uniqueIndices","Array","j","currentAttr","sizeInBytes","maxComponentSizeInBytes","remainder","padding","views","offsetInBytes","vertexSizeInComponentType","view","prototype","allBuffers","len","_resize","_appendWriters","destroyVA","size","ArrayBuffer","destView","Uint8Array","sourceView","sourceLength","createArrayBufferView","createWriters","component0","component1","component2","component3","arrayView","commit","indexBuffer","recreateVA","chunkSize","SIXTY_FOUR_KILOBYTES","numberOfVertexArrays","Math","ceil","k","offset","_appendAttributes","concat","indicesCount","vertexArrayFacade","vertexBufferSizeInBytes","vertexBufferDefined","destroy","createVertexBuffer","typedArray","vertexArrayDestroyable","copyFromArrayView","vertexBufferOffset","strideInBytes","instanceDivisor","subCommit","offsetInVertices","lengthInVertices","byteOffset","byteLength","endSubCommits","isDestroyed"],"mappings":"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","sourcesContent":["import Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Buffer from \"./Buffer.js\";\nimport BufferUsage from \"./BufferUsage.js\";\nimport VertexArray from \"./VertexArray.js\";\n\n/**\n * @private\n */\nfunction VertexArrayFacade(context, attributes, sizeInVertices, instanced) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"context\", context);\n  if (!attributes || attributes.length === 0) {\n    throw new DeveloperError(\"At least one attribute is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var attrs = VertexArrayFacade._verifyAttributes(attributes);\n  sizeInVertices = defaultValue(sizeInVertices, 0);\n  var precreatedAttributes = [];\n  var attributesByUsage = {};\n  var attributesForUsage;\n  var usage;\n\n  // Bucket the attributes by usage.\n  var length = attrs.length;\n  for (var i = 0; i < length; ++i) {\n    var attribute = attrs[i];\n\n    // If the attribute already has a vertex buffer, we do not need\n    // to manage a vertex buffer or typed array for it.\n    if (attribute.vertexBuffer) {\n      precreatedAttributes.push(attribute);\n      continue;\n    }\n\n    usage = attribute.usage;\n    attributesForUsage = attributesByUsage[usage];\n    if (!defined(attributesForUsage)) {\n      attributesForUsage = attributesByUsage[usage] = [];\n    }\n\n    attributesForUsage.push(attribute);\n  }\n\n  // A function to sort attributes by the size of their components.  From left to right, a vertex\n  // stores floats, shorts, and then bytes.\n  function compare(left, right) {\n    return (\n      ComponentDatatype.getSizeInBytes(right.componentDatatype) -\n      ComponentDatatype.getSizeInBytes(left.componentDatatype)\n    );\n  }\n\n  this._allBuffers = [];\n\n  for (usage in attributesByUsage) {\n    if (attributesByUsage.hasOwnProperty(usage)) {\n      attributesForUsage = attributesByUsage[usage];\n\n      attributesForUsage.sort(compare);\n      var vertexSizeInBytes = VertexArrayFacade._vertexSizeInBytes(\n        attributesForUsage\n      );\n\n      var bufferUsage = attributesForUsage[0].usage;\n\n      var buffer = {\n        vertexSizeInBytes: vertexSizeInBytes,\n        vertexBuffer: undefined,\n        usage: bufferUsage,\n        needsCommit: false,\n        arrayBuffer: undefined,\n        arrayViews: VertexArrayFacade._createArrayViews(\n          attributesForUsage,\n          vertexSizeInBytes\n        ),\n      };\n\n      this._allBuffers.push(buffer);\n    }\n  }\n\n  this._size = 0;\n  this._instanced = defaultValue(instanced, false);\n\n  this._precreated = precreatedAttributes;\n  this._context = context;\n\n  this.writers = undefined;\n  this.va = undefined;\n\n  this.resize(sizeInVertices);\n}\nVertexArrayFacade._verifyAttributes = function (attributes) {\n  var attrs = [];\n\n  for (var i = 0; i < attributes.length; ++i) {\n    var attribute = attributes[i];\n\n    var attr = {\n      index: defaultValue(attribute.index, i),\n      enabled: defaultValue(attribute.enabled, true),\n      componentsPerAttribute: attribute.componentsPerAttribute,\n      componentDatatype: defaultValue(\n        attribute.componentDatatype,\n        ComponentDatatype.FLOAT\n      ),\n      normalize: defaultValue(attribute.normalize, false),\n\n      // There will be either a vertexBuffer or an [optional] usage.\n      vertexBuffer: attribute.vertexBuffer,\n      usage: defaultValue(attribute.usage, BufferUsage.STATIC_DRAW),\n    };\n    attrs.push(attr);\n\n    //>>includeStart('debug', pragmas.debug);\n    if (\n      attr.componentsPerAttribute !== 1 &&\n      attr.componentsPerAttribute !== 2 &&\n      attr.componentsPerAttribute !== 3 &&\n      attr.componentsPerAttribute !== 4\n    ) {\n      throw new DeveloperError(\n        \"attribute.componentsPerAttribute must be in the range [1, 4].\"\n      );\n    }\n\n    var datatype = attr.componentDatatype;\n    if (!ComponentDatatype.validate(datatype)) {\n      throw new DeveloperError(\n        \"Attribute must have a valid componentDatatype or not specify it.\"\n      );\n    }\n\n    if (!BufferUsage.validate(attr.usage)) {\n      throw new DeveloperError(\n        \"Attribute must have a valid usage or not specify it.\"\n      );\n    }\n    //>>includeEnd('debug');\n  }\n\n  // Verify all attribute names are unique.\n  var uniqueIndices = new Array(attrs.length);\n  for (var j = 0; j < attrs.length; ++j) {\n    var currentAttr = attrs[j];\n    var index = currentAttr.index;\n    //>>includeStart('debug', pragmas.debug);\n    if (uniqueIndices[index]) {\n      throw new DeveloperError(\n        \"Index \" + index + \" is used by more than one attribute.\"\n      );\n    }\n    //>>includeEnd('debug');\n    uniqueIndices[index] = true;\n  }\n\n  return attrs;\n};\n\nVertexArrayFacade._vertexSizeInBytes = function (attributes) {\n  var sizeInBytes = 0;\n\n  var length = attributes.length;\n  for (var i = 0; i < length; ++i) {\n    var attribute = attributes[i];\n    sizeInBytes +=\n      attribute.componentsPerAttribute *\n      ComponentDatatype.getSizeInBytes(attribute.componentDatatype);\n  }\n\n  var maxComponentSizeInBytes =\n    length > 0\n      ? ComponentDatatype.getSizeInBytes(attributes[0].componentDatatype)\n      : 0; // Sorted by size\n  var remainder =\n    maxComponentSizeInBytes > 0 ? sizeInBytes % maxComponentSizeInBytes : 0;\n  var padding = remainder === 0 ? 0 : maxComponentSizeInBytes - remainder;\n  sizeInBytes += padding;\n\n  return sizeInBytes;\n};\n\nVertexArrayFacade._createArrayViews = function (attributes, vertexSizeInBytes) {\n  var views = [];\n  var offsetInBytes = 0;\n\n  var length = attributes.length;\n  for (var i = 0; i < length; ++i) {\n    var attribute = attributes[i];\n    var componentDatatype = attribute.componentDatatype;\n\n    views.push({\n      index: attribute.index,\n      enabled: attribute.enabled,\n      componentsPerAttribute: attribute.componentsPerAttribute,\n      componentDatatype: componentDatatype,\n      normalize: attribute.normalize,\n\n      offsetInBytes: offsetInBytes,\n      vertexSizeInComponentType:\n        vertexSizeInBytes / ComponentDatatype.getSizeInBytes(componentDatatype),\n\n      view: undefined,\n    });\n\n    offsetInBytes +=\n      attribute.componentsPerAttribute *\n      ComponentDatatype.getSizeInBytes(componentDatatype);\n  }\n\n  return views;\n};\n\n/**\n * Invalidates writers.  Can't render again until commit is called.\n */\nVertexArrayFacade.prototype.resize = function (sizeInVertices) {\n  this._size = sizeInVertices;\n\n  var allBuffers = this._allBuffers;\n  this.writers = [];\n\n  for (var i = 0, len = allBuffers.length; i < len; ++i) {\n    var buffer = allBuffers[i];\n\n    VertexArrayFacade._resize(buffer, this._size);\n\n    // Reserving invalidates the writers, so if client's cache them, they need to invalidate their cache.\n    VertexArrayFacade._appendWriters(this.writers, buffer);\n  }\n\n  // VAs are recreated next time commit is called.\n  destroyVA(this);\n};\n\nVertexArrayFacade._resize = function (buffer, size) {\n  if (buffer.vertexSizeInBytes > 0) {\n    // Create larger array buffer\n    var arrayBuffer = new ArrayBuffer(size * buffer.vertexSizeInBytes);\n\n    // Copy contents from previous array buffer\n    if (defined(buffer.arrayBuffer)) {\n      var destView = new Uint8Array(arrayBuffer);\n      var sourceView = new Uint8Array(buffer.arrayBuffer);\n      var sourceLength = sourceView.length;\n      for (var j = 0; j < sourceLength; ++j) {\n        destView[j] = sourceView[j];\n      }\n    }\n\n    // Create typed views into the new array buffer\n    var views = buffer.arrayViews;\n    var length = views.length;\n    for (var i = 0; i < length; ++i) {\n      var view = views[i];\n      view.view = ComponentDatatype.createArrayBufferView(\n        view.componentDatatype,\n        arrayBuffer,\n        view.offsetInBytes\n      );\n    }\n\n    buffer.arrayBuffer = arrayBuffer;\n  }\n};\n\nvar createWriters = [\n  // 1 component per attribute\n  function (buffer, view, vertexSizeInComponentType) {\n    return function (index, attribute) {\n      view[index * vertexSizeInComponentType] = attribute;\n      buffer.needsCommit = true;\n    };\n  },\n\n  // 2 component per attribute\n  function (buffer, view, vertexSizeInComponentType) {\n    return function (index, component0, component1) {\n      var i = index * vertexSizeInComponentType;\n      view[i] = component0;\n      view[i + 1] = component1;\n      buffer.needsCommit = true;\n    };\n  },\n\n  // 3 component per attribute\n  function (buffer, view, vertexSizeInComponentType) {\n    return function (index, component0, component1, component2) {\n      var i = index * vertexSizeInComponentType;\n      view[i] = component0;\n      view[i + 1] = component1;\n      view[i + 2] = component2;\n      buffer.needsCommit = true;\n    };\n  },\n\n  // 4 component per attribute\n  function (buffer, view, vertexSizeInComponentType) {\n    return function (index, component0, component1, component2, component3) {\n      var i = index * vertexSizeInComponentType;\n      view[i] = component0;\n      view[i + 1] = component1;\n      view[i + 2] = component2;\n      view[i + 3] = component3;\n      buffer.needsCommit = true;\n    };\n  },\n];\n\nVertexArrayFacade._appendWriters = function (writers, buffer) {\n  var arrayViews = buffer.arrayViews;\n  var length = arrayViews.length;\n  for (var i = 0; i < length; ++i) {\n    var arrayView = arrayViews[i];\n    writers[arrayView.index] = createWriters[\n      arrayView.componentsPerAttribute - 1\n    ](buffer, arrayView.view, arrayView.vertexSizeInComponentType);\n  }\n};\n\nVertexArrayFacade.prototype.commit = function (indexBuffer) {\n  var recreateVA = false;\n\n  var allBuffers = this._allBuffers;\n  var buffer;\n  var i;\n  var length;\n\n  for (i = 0, length = allBuffers.length; i < length; ++i) {\n    buffer = allBuffers[i];\n    recreateVA = commit(this, buffer) || recreateVA;\n  }\n\n  ///////////////////////////////////////////////////////////////////////\n\n  if (recreateVA || !defined(this.va)) {\n    destroyVA(this);\n    var va = (this.va = []);\n\n    var chunkSize = CesiumMath.SIXTY_FOUR_KILOBYTES - 4; // The 65535 index is reserved for primitive restart. Reserve the last 4 indices so that billboard quads are not broken up.\n    var numberOfVertexArrays =\n      defined(indexBuffer) && !this._instanced\n        ? Math.ceil(this._size / chunkSize)\n        : 1;\n    for (var k = 0; k < numberOfVertexArrays; ++k) {\n      var attributes = [];\n      for (i = 0, length = allBuffers.length; i < length; ++i) {\n        buffer = allBuffers[i];\n        var offset = k * (buffer.vertexSizeInBytes * chunkSize);\n        VertexArrayFacade._appendAttributes(\n          attributes,\n          buffer,\n          offset,\n          this._instanced\n        );\n      }\n\n      attributes = attributes.concat(this._precreated);\n\n      va.push({\n        va: new VertexArray({\n          context: this._context,\n          attributes: attributes,\n          indexBuffer: indexBuffer,\n        }),\n        indicesCount:\n          1.5 *\n          (k !== numberOfVertexArrays - 1 ? chunkSize : this._size % chunkSize),\n        // TODO: not hardcode 1.5, this assumes 6 indices per 4 vertices (as for Billboard quads).\n      });\n    }\n  }\n};\n\nfunction commit(vertexArrayFacade, buffer) {\n  if (buffer.needsCommit && buffer.vertexSizeInBytes > 0) {\n    buffer.needsCommit = false;\n\n    var vertexBuffer = buffer.vertexBuffer;\n    var vertexBufferSizeInBytes =\n      vertexArrayFacade._size * buffer.vertexSizeInBytes;\n    var vertexBufferDefined = defined(vertexBuffer);\n    if (\n      !vertexBufferDefined ||\n      vertexBuffer.sizeInBytes < vertexBufferSizeInBytes\n    ) {\n      if (vertexBufferDefined) {\n        vertexBuffer.destroy();\n      }\n      buffer.vertexBuffer = Buffer.createVertexBuffer({\n        context: vertexArrayFacade._context,\n        typedArray: buffer.arrayBuffer,\n        usage: buffer.usage,\n      });\n      buffer.vertexBuffer.vertexArrayDestroyable = false;\n\n      return true; // Created new vertex buffer\n    }\n\n    buffer.vertexBuffer.copyFromArrayView(buffer.arrayBuffer);\n  }\n\n  return false; // Did not create new vertex buffer\n}\n\nVertexArrayFacade._appendAttributes = function (\n  attributes,\n  buffer,\n  vertexBufferOffset,\n  instanced\n) {\n  var arrayViews = buffer.arrayViews;\n  var length = arrayViews.length;\n  for (var i = 0; i < length; ++i) {\n    var view = arrayViews[i];\n\n    attributes.push({\n      index: view.index,\n      enabled: view.enabled,\n      componentsPerAttribute: view.componentsPerAttribute,\n      componentDatatype: view.componentDatatype,\n      normalize: view.normalize,\n      vertexBuffer: buffer.vertexBuffer,\n      offsetInBytes: vertexBufferOffset + view.offsetInBytes,\n      strideInBytes: buffer.vertexSizeInBytes,\n      instanceDivisor: instanced ? 1 : 0,\n    });\n  }\n};\n\nVertexArrayFacade.prototype.subCommit = function (\n  offsetInVertices,\n  lengthInVertices\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (offsetInVertices < 0 || offsetInVertices >= this._size) {\n    throw new DeveloperError(\n      \"offsetInVertices must be greater than or equal to zero and less than the vertex array size.\"\n    );\n  }\n  if (offsetInVertices + lengthInVertices > this._size) {\n    throw new DeveloperError(\n      \"offsetInVertices + lengthInVertices cannot exceed the vertex array size.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var allBuffers = this._allBuffers;\n  for (var i = 0, len = allBuffers.length; i < len; ++i) {\n    subCommit(allBuffers[i], offsetInVertices, lengthInVertices);\n  }\n};\n\nfunction subCommit(buffer, offsetInVertices, lengthInVertices) {\n  if (buffer.needsCommit && buffer.vertexSizeInBytes > 0) {\n    var byteOffset = buffer.vertexSizeInBytes * offsetInVertices;\n    var byteLength = buffer.vertexSizeInBytes * lengthInVertices;\n\n    // PERFORMANCE_IDEA: If we want to get really crazy, we could consider updating\n    // individual attributes instead of the entire (sub-)vertex.\n    //\n    // PERFORMANCE_IDEA: Does creating the typed view add too much GC overhead?\n    buffer.vertexBuffer.copyFromArrayView(\n      new Uint8Array(buffer.arrayBuffer, byteOffset, byteLength),\n      byteOffset\n    );\n  }\n}\n\nVertexArrayFacade.prototype.endSubCommits = function () {\n  var allBuffers = this._allBuffers;\n\n  for (var i = 0, len = allBuffers.length; i < len; ++i) {\n    allBuffers[i].needsCommit = false;\n  }\n};\n\nfunction destroyVA(vertexArrayFacade) {\n  var va = vertexArrayFacade.va;\n  if (!defined(va)) {\n    return;\n  }\n\n  var length = va.length;\n  for (var i = 0; i < length; ++i) {\n    va[i].va.destroy();\n  }\n\n  vertexArrayFacade.va = undefined;\n}\n\nVertexArrayFacade.prototype.isDestroyed = function () {\n  return false;\n};\n\nVertexArrayFacade.prototype.destroy = function () {\n  var allBuffers = this._allBuffers;\n  for (var i = 0, len = allBuffers.length; i < len; ++i) {\n    var buffer = allBuffers[i];\n    buffer.vertexBuffer = buffer.vertexBuffer && buffer.vertexBuffer.destroy();\n  }\n\n  destroyVA(this);\n\n  return destroyObject(this);\n};\nexport default VertexArrayFacade;\n"]},"metadata":{},"sourceType":"module"}