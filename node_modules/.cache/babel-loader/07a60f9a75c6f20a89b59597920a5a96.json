{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport HeadingPitchRoll from \"../Core/HeadingPitchRoll.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport KeyboardEventModifier from \"../Core/KeyboardEventModifier.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport Plane from \"../Core/Plane.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport CameraEventAggregator from \"./CameraEventAggregator.js\";\nimport CameraEventType from \"./CameraEventType.js\";\nimport MapMode2D from \"./MapMode2D.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport SceneTransforms from \"./SceneTransforms.js\";\nimport TweenCollection from \"./TweenCollection.js\";\n/**\n * Modifies the camera position and orientation based on mouse input to a canvas.\n * @alias ScreenSpaceCameraController\n * @constructor\n *\n * @param {Scene} scene The scene.\n */\n\nfunction ScreenSpaceCameraController(scene) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  } //>>includeEnd('debug');\n\n  /**\n   * If true, inputs are allowed conditionally with the flags enableTranslate, enableZoom,\n   * enableRotate, enableTilt, and enableLook.  If false, all inputs are disabled.\n   *\n   * NOTE: This setting is for temporary use cases, such as camera flights and\n   * drag-selection of regions (see Picking demo).  It is typically set to false at the\n   * start of such events, and set true on completion.  To keep inputs disabled\n   * past the end of camera flights, you must use the other booleans (enableTranslate,\n   * enableZoom, enableRotate, enableTilt, and enableLook).\n   * @type {Boolean}\n   * @default true\n   */\n\n\n  this.enableInputs = true;\n  /**\n   * If true, allows the user to pan around the map.  If false, the camera stays locked at the current position.\n   * This flag only applies in 2D and Columbus view modes.\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.enableTranslate = true;\n  /**\n   * If true, allows the user to zoom in and out.  If false, the camera is locked to the current distance from the ellipsoid.\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.enableZoom = true;\n  /**\n   * If true, allows the user to rotate the world which translates the user's position.\n   * This flag only applies in 2D and 3D.\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.enableRotate = true;\n  /**\n   * If true, allows the user to tilt the camera.  If false, the camera is locked to the current heading.\n   * This flag only applies in 3D and Columbus view.\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.enableTilt = true;\n  /**\n   * If true, allows the user to use free-look. If false, the camera view direction can only be changed through translating\n   * or rotating. This flag only applies in 3D and Columbus view modes.\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.enableLook = true;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to spin because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {Number}\n   * @default 0.9\n   */\n\n  this.inertiaSpin = 0.9;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to translate because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {Number}\n   * @default 0.9\n   */\n\n  this.inertiaTranslate = 0.9;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to zoom because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {Number}\n   * @default 0.8\n   */\n\n  this.inertiaZoom = 0.8;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to limit the range\n   * of various user inputs to a percentage of the window width/height per animation frame.\n   * This helps keep the camera under control in low-frame-rate situations.\n   * @type {Number}\n   * @default 0.1\n   */\n\n  this.maximumMovementRatio = 0.1;\n  /**\n   * Sets the duration, in seconds, of the bounce back animations in 2D and Columbus view.\n   * @type {Number}\n   * @default 3.0\n   */\n\n  this.bounceAnimationTime = 3.0;\n  /**\n   * The minimum magnitude, in meters, of the camera position when zooming. Defaults to 1.0.\n   * @type {Number}\n   * @default 1.0\n   */\n\n  this.minimumZoomDistance = 1.0;\n  /**\n   * The maximum magnitude, in meters, of the camera position when zooming. Defaults to positive infinity.\n   * @type {Number}\n   * @default {@link Number.POSITIVE_INFINITY}\n   */\n\n  this.maximumZoomDistance = Number.POSITIVE_INFINITY;\n  /**\n   * The input that allows the user to pan around the map. This only applies in 2D and Columbus view modes.\n   * <p>\n   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default {@link CameraEventType.LEFT_DRAG}\n   */\n\n  this.translateEventTypes = CameraEventType.LEFT_DRAG;\n  /**\n   * The input that allows the user to zoom in/out.\n   * <p>\n   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default [{@link CameraEventType.RIGHT_DRAG}, {@link CameraEventType.WHEEL}, {@link CameraEventType.PINCH}]\n   */\n\n  this.zoomEventTypes = [CameraEventType.RIGHT_DRAG, CameraEventType.WHEEL, CameraEventType.PINCH];\n  /**\n   * The input that allows the user to rotate around the globe or another object. This only applies in 3D and Columbus view modes.\n   * <p>\n   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default {@link CameraEventType.LEFT_DRAG}\n   */\n\n  this.rotateEventTypes = CameraEventType.LEFT_DRAG;\n  /**\n   * The input that allows the user to tilt in 3D and Columbus view or twist in 2D.\n   * <p>\n   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default [{@link CameraEventType.MIDDLE_DRAG}, {@link CameraEventType.PINCH}, {\n   *     eventType : {@link CameraEventType.LEFT_DRAG},\n   *     modifier : {@link KeyboardEventModifier.CTRL}\n   * }, {\n   *     eventType : {@link CameraEventType.RIGHT_DRAG},\n   *     modifier : {@link KeyboardEventModifier.CTRL}\n   * }]\n   */\n\n  this.tiltEventTypes = [CameraEventType.MIDDLE_DRAG, CameraEventType.PINCH, {\n    eventType: CameraEventType.LEFT_DRAG,\n    modifier: KeyboardEventModifier.CTRL\n  }, {\n    eventType: CameraEventType.RIGHT_DRAG,\n    modifier: KeyboardEventModifier.CTRL\n  }];\n  /**\n   * The input that allows the user to change the direction the camera is viewing. This only applies in 3D and Columbus view modes.\n   * <p>\n   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default { eventType : {@link CameraEventType.LEFT_DRAG}, modifier : {@link KeyboardEventModifier.SHIFT} }\n   */\n\n  this.lookEventTypes = {\n    eventType: CameraEventType.LEFT_DRAG,\n    modifier: KeyboardEventModifier.SHIFT\n  };\n  /**\n   * The minimum height the camera must be before picking the terrain instead of the ellipsoid.\n   * @type {Number}\n   * @default 150000.0\n   */\n\n  this.minimumPickingTerrainHeight = 150000.0;\n  this._minimumPickingTerrainHeight = this.minimumPickingTerrainHeight;\n  /**\n   * The minimum height the camera must be before testing for collision with terrain.\n   * @type {Number}\n   * @default 15000.0\n   */\n\n  this.minimumCollisionTerrainHeight = 15000.0;\n  this._minimumCollisionTerrainHeight = this.minimumCollisionTerrainHeight;\n  /**\n   * The minimum height the camera must be before switching from rotating a track ball to\n   * free look when clicks originate on the sky on in space.\n   * @type {Number}\n   * @default 7500000.0\n   */\n\n  this.minimumTrackBallHeight = 7500000.0;\n  this._minimumTrackBallHeight = this.minimumTrackBallHeight;\n  /**\n   * Enables or disables camera collision detection with terrain.\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.enableCollisionDetection = true;\n  this._scene = scene;\n  this._globe = undefined;\n  this._ellipsoid = undefined;\n  this._aggregator = new CameraEventAggregator(scene.canvas);\n  this._lastInertiaSpinMovement = undefined;\n  this._lastInertiaZoomMovement = undefined;\n  this._lastInertiaTranslateMovement = undefined;\n  this._lastInertiaTiltMovement = undefined;\n  this._tweens = new TweenCollection();\n  this._tween = undefined;\n  this._horizontalRotationAxis = undefined;\n  this._tiltCenterMousePosition = new Cartesian2(-1.0, -1.0);\n  this._tiltCenter = new Cartesian3();\n  this._rotateMousePosition = new Cartesian2(-1.0, -1.0);\n  this._rotateStartPosition = new Cartesian3();\n  this._strafeStartPosition = new Cartesian3();\n  this._zoomMouseStart = new Cartesian2(-1.0, -1.0);\n  this._zoomWorldPosition = new Cartesian3();\n  this._useZoomWorldPosition = false;\n  this._tiltCVOffMap = false;\n  this._looking = false;\n  this._rotating = false;\n  this._strafing = false;\n  this._zoomingOnVector = false;\n  this._rotatingZoom = false;\n  this._adjustedHeightForTerrain = false;\n  var projection = scene.mapProjection;\n  this._maxCoord = projection.project(new Cartographic(Math.PI, CesiumMath.PI_OVER_TWO)); // Constants, Make any of these public?\n\n  this._zoomFactor = 5.0;\n  this._rotateFactor = undefined;\n  this._rotateRateRangeAdjustment = undefined;\n  this._maximumRotateRate = 1.77;\n  this._minimumRotateRate = 1.0 / 5000.0;\n  this._minimumZoomRate = 20.0;\n  this._maximumZoomRate = 5906376272000.0; // distance from the Sun to Pluto in meters.\n}\n\nfunction decay(time, coefficient) {\n  if (time < 0) {\n    return 0.0;\n  }\n\n  var tau = (1.0 - coefficient) * 25.0;\n  return Math.exp(-tau * time);\n}\n\nfunction sameMousePosition(movement) {\n  return Cartesian2.equalsEpsilon(movement.startPosition, movement.endPosition, CesiumMath.EPSILON14);\n} // If the time between mouse down and mouse up is not between\n// these thresholds, the camera will not move with inertia.\n// This value is probably dependent on the browser and/or the\n// hardware. Should be investigated further.\n\n\nvar inertiaMaxClickTimeThreshold = 0.4;\n\nfunction maintainInertia(aggregator, type, modifier, decayCoef, action, object, lastMovementName) {\n  var movementState = object[lastMovementName];\n\n  if (!defined(movementState)) {\n    movementState = object[lastMovementName] = {\n      startPosition: new Cartesian2(),\n      endPosition: new Cartesian2(),\n      motion: new Cartesian2(),\n      active: false\n    };\n  }\n\n  var ts = aggregator.getButtonPressTime(type, modifier);\n  var tr = aggregator.getButtonReleaseTime(type, modifier);\n  var threshold = ts && tr && (tr.getTime() - ts.getTime()) / 1000.0;\n  var now = new Date();\n  var fromNow = tr && (now.getTime() - tr.getTime()) / 1000.0;\n\n  if (ts && tr && threshold < inertiaMaxClickTimeThreshold) {\n    var d = decay(fromNow, decayCoef);\n\n    if (!movementState.active) {\n      var lastMovement = aggregator.getLastMovement(type, modifier);\n\n      if (!defined(lastMovement) || sameMousePosition(lastMovement)) {\n        return;\n      }\n\n      movementState.motion.x = (lastMovement.endPosition.x - lastMovement.startPosition.x) * 0.5;\n      movementState.motion.y = (lastMovement.endPosition.y - lastMovement.startPosition.y) * 0.5;\n      movementState.startPosition = Cartesian2.clone(lastMovement.startPosition, movementState.startPosition);\n      movementState.endPosition = Cartesian2.multiplyByScalar(movementState.motion, d, movementState.endPosition);\n      movementState.endPosition = Cartesian2.add(movementState.startPosition, movementState.endPosition, movementState.endPosition);\n      movementState.active = true;\n    } else {\n      movementState.startPosition = Cartesian2.clone(movementState.endPosition, movementState.startPosition);\n      movementState.endPosition = Cartesian2.multiplyByScalar(movementState.motion, d, movementState.endPosition);\n      movementState.endPosition = Cartesian2.add(movementState.startPosition, movementState.endPosition, movementState.endPosition);\n      movementState.motion = Cartesian2.clone(Cartesian2.ZERO, movementState.motion);\n    } // If value from the decreasing exponential function is close to zero,\n    // the end coordinates may be NaN.\n\n\n    if (isNaN(movementState.endPosition.x) || isNaN(movementState.endPosition.y) || Cartesian2.distance(movementState.startPosition, movementState.endPosition) < 0.5) {\n      movementState.active = false;\n      return;\n    }\n\n    if (!aggregator.isButtonDown(type, modifier)) {\n      var startPosition = aggregator.getStartMousePosition(type, modifier);\n      action(object, startPosition, movementState);\n    }\n  } else {\n    movementState.active = false;\n  }\n}\n\nvar scratchEventTypeArray = [];\n\nfunction reactToInput(controller, enabled, eventTypes, action, inertiaConstant, inertiaStateName) {\n  if (!defined(eventTypes)) {\n    return;\n  }\n\n  var aggregator = controller._aggregator;\n\n  if (!Array.isArray(eventTypes)) {\n    scratchEventTypeArray[0] = eventTypes;\n    eventTypes = scratchEventTypeArray;\n  }\n\n  var length = eventTypes.length;\n\n  for (var i = 0; i < length; ++i) {\n    var eventType = eventTypes[i];\n    var type = defined(eventType.eventType) ? eventType.eventType : eventType;\n    var modifier = eventType.modifier;\n    var movement = aggregator.isMoving(type, modifier) && aggregator.getMovement(type, modifier);\n    var startPosition = aggregator.getStartMousePosition(type, modifier);\n\n    if (controller.enableInputs && enabled) {\n      if (movement) {\n        action(controller, startPosition, movement);\n      } else if (inertiaConstant < 1.0) {\n        maintainInertia(aggregator, type, modifier, inertiaConstant, action, controller, inertiaStateName);\n      }\n    }\n  }\n}\n\nvar scratchZoomPickRay = new Ray();\nvar scratchPickCartesian = new Cartesian3();\nvar scratchZoomOffset = new Cartesian2();\nvar scratchZoomDirection = new Cartesian3();\nvar scratchCenterPixel = new Cartesian2();\nvar scratchCenterPosition = new Cartesian3();\nvar scratchPositionNormal = new Cartesian3();\nvar scratchPickNormal = new Cartesian3();\nvar scratchZoomAxis = new Cartesian3();\nvar scratchCameraPositionNormal = new Cartesian3(); // Scratch variables used in zooming algorithm\n\nvar scratchTargetNormal = new Cartesian3();\nvar scratchCameraPosition = new Cartesian3();\nvar scratchCameraUpNormal = new Cartesian3();\nvar scratchCameraRightNormal = new Cartesian3();\nvar scratchForwardNormal = new Cartesian3();\nvar scratchPositionToTarget = new Cartesian3();\nvar scratchPositionToTargetNormal = new Cartesian3();\nvar scratchPan = new Cartesian3();\nvar scratchCenterMovement = new Cartesian3();\nvar scratchCenter = new Cartesian3();\nvar scratchCartesian = new Cartesian3();\nvar scratchCartesianTwo = new Cartesian3();\nvar scratchCartesianThree = new Cartesian3();\nvar scratchZoomViewOptions = {\n  orientation: new HeadingPitchRoll()\n};\n\nfunction handleZoom(object, startPosition, movement, zoomFactor, distanceMeasure, unitPositionDotDirection) {\n  var percentage = 1.0;\n\n  if (defined(unitPositionDotDirection)) {\n    percentage = CesiumMath.clamp(Math.abs(unitPositionDotDirection), 0.25, 1.0);\n  } // distanceMeasure should be the height above the ellipsoid.\n  // The zoomRate slows as it approaches the surface and stops minimumZoomDistance above it.\n\n\n  var minHeight = object.minimumZoomDistance * percentage;\n  var maxHeight = object.maximumZoomDistance;\n  var minDistance = distanceMeasure - minHeight;\n  var zoomRate = zoomFactor * minDistance;\n  zoomRate = CesiumMath.clamp(zoomRate, object._minimumZoomRate, object._maximumZoomRate);\n  var diff = movement.endPosition.y - movement.startPosition.y;\n  var rangeWindowRatio = diff / object._scene.canvas.clientHeight;\n  rangeWindowRatio = Math.min(rangeWindowRatio, object.maximumMovementRatio);\n  var distance = zoomRate * rangeWindowRatio;\n\n  if (distance > 0.0 && Math.abs(distanceMeasure - minHeight) < 1.0) {\n    return;\n  }\n\n  if (distance < 0.0 && Math.abs(distanceMeasure - maxHeight) < 1.0) {\n    return;\n  }\n\n  if (distanceMeasure - distance < minHeight) {\n    distance = distanceMeasure - minHeight - 1.0;\n  } else if (distanceMeasure - distance > maxHeight) {\n    distance = distanceMeasure - maxHeight;\n  }\n\n  var scene = object._scene;\n  var camera = scene.camera;\n  var mode = scene.mode;\n  var orientation = scratchZoomViewOptions.orientation;\n  orientation.heading = camera.heading;\n  orientation.pitch = camera.pitch;\n  orientation.roll = camera.roll;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    if (Math.abs(distance) > 0.0) {\n      camera.zoomIn(distance);\n\n      camera._adjustOrthographicFrustum();\n    }\n\n    return;\n  }\n\n  var sameStartPosition = Cartesian2.equals(startPosition, object._zoomMouseStart);\n  var zoomingOnVector = object._zoomingOnVector;\n  var rotatingZoom = object._rotatingZoom;\n  var pickedPosition;\n\n  if (!sameStartPosition) {\n    object._zoomMouseStart = Cartesian2.clone(startPosition, object._zoomMouseStart);\n\n    if (defined(object._globe)) {\n      if (mode === SceneMode.SCENE2D) {\n        pickedPosition = camera.getPickRay(startPosition, scratchZoomPickRay).origin;\n        pickedPosition = Cartesian3.fromElements(pickedPosition.y, pickedPosition.z, pickedPosition.x);\n      } else {\n        pickedPosition = pickGlobe(object, startPosition, scratchPickCartesian);\n      }\n    }\n\n    if (defined(pickedPosition)) {\n      object._useZoomWorldPosition = true;\n      object._zoomWorldPosition = Cartesian3.clone(pickedPosition, object._zoomWorldPosition);\n    } else {\n      object._useZoomWorldPosition = false;\n    }\n\n    zoomingOnVector = object._zoomingOnVector = false;\n    rotatingZoom = object._rotatingZoom = false;\n  }\n\n  if (!object._useZoomWorldPosition) {\n    camera.zoomIn(distance);\n    return;\n  }\n\n  var zoomOnVector = mode === SceneMode.COLUMBUS_VIEW;\n\n  if (camera.positionCartographic.height < 2000000) {\n    rotatingZoom = true;\n  }\n\n  if (!sameStartPosition || rotatingZoom) {\n    if (mode === SceneMode.SCENE2D) {\n      var worldPosition = object._zoomWorldPosition;\n      var endPosition = camera.position;\n\n      if (!Cartesian3.equals(worldPosition, endPosition) && camera.positionCartographic.height < object._maxCoord.x * 2.0) {\n        var savedX = camera.position.x;\n        var direction = Cartesian3.subtract(worldPosition, endPosition, scratchZoomDirection);\n        Cartesian3.normalize(direction, direction);\n        var d = Cartesian3.distance(worldPosition, endPosition) * distance / (camera.getMagnitude() * 0.5);\n        camera.move(direction, d * 0.5);\n\n        if (camera.position.x < 0.0 && savedX > 0.0 || camera.position.x > 0.0 && savedX < 0.0) {\n          pickedPosition = camera.getPickRay(startPosition, scratchZoomPickRay).origin;\n          pickedPosition = Cartesian3.fromElements(pickedPosition.y, pickedPosition.z, pickedPosition.x);\n          object._zoomWorldPosition = Cartesian3.clone(pickedPosition, object._zoomWorldPosition);\n        }\n      }\n    } else if (mode === SceneMode.SCENE3D) {\n      var cameraPositionNormal = Cartesian3.normalize(camera.position, scratchCameraPositionNormal);\n\n      if (camera.positionCartographic.height < 3000.0 && Math.abs(Cartesian3.dot(camera.direction, cameraPositionNormal)) < 0.6) {\n        zoomOnVector = true;\n      } else {\n        var canvas = scene.canvas;\n        var centerPixel = scratchCenterPixel;\n        centerPixel.x = canvas.clientWidth / 2;\n        centerPixel.y = canvas.clientHeight / 2;\n        var centerPosition = pickGlobe(object, centerPixel, scratchCenterPosition); // If centerPosition is not defined, it means the globe does not cover the center position of screen\n\n        if (defined(centerPosition) && camera.positionCartographic.height < 1000000) {\n          var cameraPosition = scratchCameraPosition;\n          Cartesian3.clone(camera.position, cameraPosition);\n          var target = object._zoomWorldPosition;\n          var targetNormal = scratchTargetNormal;\n          targetNormal = Cartesian3.normalize(target, targetNormal);\n\n          if (Cartesian3.dot(targetNormal, cameraPositionNormal) < 0.0) {\n            return;\n          }\n\n          var center = scratchCenter;\n          var forward = scratchForwardNormal;\n          Cartesian3.clone(camera.direction, forward);\n          Cartesian3.add(cameraPosition, Cartesian3.multiplyByScalar(forward, 1000, scratchCartesian), center);\n          var positionToTarget = scratchPositionToTarget;\n          var positionToTargetNormal = scratchPositionToTargetNormal;\n          Cartesian3.subtract(target, cameraPosition, positionToTarget);\n          Cartesian3.normalize(positionToTarget, positionToTargetNormal);\n          var alphaDot = Cartesian3.dot(cameraPositionNormal, positionToTargetNormal);\n\n          if (alphaDot >= 0.0) {\n            // We zoomed past the target, and this zoom is not valid anymore.\n            // This line causes the next zoom movement to pick a new starting point.\n            object._zoomMouseStart.x = -1;\n            return;\n          }\n\n          var alpha = Math.acos(-alphaDot);\n          var cameraDistance = Cartesian3.magnitude(cameraPosition);\n          var targetDistance = Cartesian3.magnitude(target);\n          var remainingDistance = cameraDistance - distance;\n          var positionToTargetDistance = Cartesian3.magnitude(positionToTarget);\n          var gamma = Math.asin(CesiumMath.clamp(positionToTargetDistance / targetDistance * Math.sin(alpha), -1.0, 1.0));\n          var delta = Math.asin(CesiumMath.clamp(remainingDistance / targetDistance * Math.sin(alpha), -1.0, 1.0));\n          var beta = gamma - delta + alpha;\n          var up = scratchCameraUpNormal;\n          Cartesian3.normalize(cameraPosition, up);\n          var right = scratchCameraRightNormal;\n          right = Cartesian3.cross(positionToTargetNormal, up, right);\n          right = Cartesian3.normalize(right, right);\n          Cartesian3.normalize(Cartesian3.cross(up, right, scratchCartesian), forward); // Calculate new position to move to\n\n          Cartesian3.multiplyByScalar(Cartesian3.normalize(center, scratchCartesian), Cartesian3.magnitude(center) - distance, center);\n          Cartesian3.normalize(cameraPosition, cameraPosition);\n          Cartesian3.multiplyByScalar(cameraPosition, remainingDistance, cameraPosition); // Pan\n\n          var pMid = scratchPan;\n          Cartesian3.multiplyByScalar(Cartesian3.add(Cartesian3.multiplyByScalar(up, Math.cos(beta) - 1, scratchCartesianTwo), Cartesian3.multiplyByScalar(forward, Math.sin(beta), scratchCartesianThree), scratchCartesian), remainingDistance, pMid);\n          Cartesian3.add(cameraPosition, pMid, cameraPosition);\n          Cartesian3.normalize(center, up);\n          Cartesian3.normalize(Cartesian3.cross(up, right, scratchCartesian), forward);\n          var cMid = scratchCenterMovement;\n          Cartesian3.multiplyByScalar(Cartesian3.add(Cartesian3.multiplyByScalar(up, Math.cos(beta) - 1, scratchCartesianTwo), Cartesian3.multiplyByScalar(forward, Math.sin(beta), scratchCartesianThree), scratchCartesian), Cartesian3.magnitude(center), cMid);\n          Cartesian3.add(center, cMid, center); // Update camera\n          // Set new position\n\n          Cartesian3.clone(cameraPosition, camera.position); // Set new direction\n\n          Cartesian3.normalize(Cartesian3.subtract(center, cameraPosition, scratchCartesian), camera.direction);\n          Cartesian3.clone(camera.direction, camera.direction); // Set new right & up vectors\n\n          Cartesian3.cross(camera.direction, camera.up, camera.right);\n          Cartesian3.cross(camera.right, camera.direction, camera.up);\n          camera.setView(scratchZoomViewOptions);\n          return;\n        }\n\n        if (defined(centerPosition)) {\n          var positionNormal = Cartesian3.normalize(centerPosition, scratchPositionNormal);\n          var pickedNormal = Cartesian3.normalize(object._zoomWorldPosition, scratchPickNormal);\n          var dotProduct = Cartesian3.dot(pickedNormal, positionNormal);\n\n          if (dotProduct > 0.0 && dotProduct < 1.0) {\n            var angle = CesiumMath.acosClamped(dotProduct);\n            var axis = Cartesian3.cross(pickedNormal, positionNormal, scratchZoomAxis);\n            var denom = Math.abs(angle) > CesiumMath.toRadians(20.0) ? camera.positionCartographic.height * 0.75 : camera.positionCartographic.height - distance;\n            var scalar = distance / denom;\n            camera.rotate(axis, angle * scalar);\n          }\n        } else {\n          zoomOnVector = true;\n        }\n      }\n    }\n\n    object._rotatingZoom = !zoomOnVector;\n  }\n\n  if (!sameStartPosition && zoomOnVector || zoomingOnVector) {\n    var ray;\n    var zoomMouseStart = SceneTransforms.wgs84ToWindowCoordinates(scene, object._zoomWorldPosition, scratchZoomOffset);\n\n    if (mode !== SceneMode.COLUMBUS_VIEW && Cartesian2.equals(startPosition, object._zoomMouseStart) && defined(zoomMouseStart)) {\n      ray = camera.getPickRay(zoomMouseStart, scratchZoomPickRay);\n    } else {\n      ray = camera.getPickRay(startPosition, scratchZoomPickRay);\n    }\n\n    var rayDirection = ray.direction;\n\n    if (mode === SceneMode.COLUMBUS_VIEW || mode === SceneMode.SCENE2D) {\n      Cartesian3.fromElements(rayDirection.y, rayDirection.z, rayDirection.x, rayDirection);\n    }\n\n    camera.move(rayDirection, distance);\n    object._zoomingOnVector = true;\n  } else {\n    camera.zoomIn(distance);\n  }\n\n  camera.setView(scratchZoomViewOptions);\n}\n\nvar translate2DStart = new Ray();\nvar translate2DEnd = new Ray();\nvar scratchTranslateP0 = new Cartesian3();\n\nfunction translate2D(controller, startPosition, movement) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var start = camera.getPickRay(movement.startPosition, translate2DStart).origin;\n  var end = camera.getPickRay(movement.endPosition, translate2DEnd).origin;\n  start = Cartesian3.fromElements(start.y, start.z, start.x, start);\n  end = Cartesian3.fromElements(end.y, end.z, end.x, end);\n  var direction = Cartesian3.subtract(start, end, scratchTranslateP0);\n  var distance = Cartesian3.magnitude(direction);\n\n  if (distance > 0.0) {\n    Cartesian3.normalize(direction, direction);\n    camera.move(direction, distance);\n  }\n}\n\nfunction zoom2D(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n\n  var scene = controller._scene;\n  var camera = scene.camera;\n  handleZoom(controller, startPosition, movement, controller._zoomFactor, camera.getMagnitude());\n}\n\nvar twist2DStart = new Cartesian2();\nvar twist2DEnd = new Cartesian2();\n\nfunction twist2D(controller, startPosition, movement) {\n  if (defined(movement.angleAndHeight)) {\n    singleAxisTwist2D(controller, startPosition, movement.angleAndHeight);\n    return;\n  }\n\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var canvas = scene.canvas;\n  var width = canvas.clientWidth;\n  var height = canvas.clientHeight;\n  var start = twist2DStart;\n  start.x = 2.0 / width * movement.startPosition.x - 1.0;\n  start.y = 2.0 / height * (height - movement.startPosition.y) - 1.0;\n  start = Cartesian2.normalize(start, start);\n  var end = twist2DEnd;\n  end.x = 2.0 / width * movement.endPosition.x - 1.0;\n  end.y = 2.0 / height * (height - movement.endPosition.y) - 1.0;\n  end = Cartesian2.normalize(end, end);\n  var startTheta = CesiumMath.acosClamped(start.x);\n\n  if (start.y < 0) {\n    startTheta = CesiumMath.TWO_PI - startTheta;\n  }\n\n  var endTheta = CesiumMath.acosClamped(end.x);\n\n  if (end.y < 0) {\n    endTheta = CesiumMath.TWO_PI - endTheta;\n  }\n\n  var theta = endTheta - startTheta;\n  camera.twistRight(theta);\n}\n\nfunction singleAxisTwist2D(controller, startPosition, movement) {\n  var rotateRate = controller._rotateFactor * controller._rotateRateRangeAdjustment;\n\n  if (rotateRate > controller._maximumRotateRate) {\n    rotateRate = controller._maximumRotateRate;\n  }\n\n  if (rotateRate < controller._minimumRotateRate) {\n    rotateRate = controller._minimumRotateRate;\n  }\n\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var canvas = scene.canvas;\n  var phiWindowRatio = (movement.endPosition.x - movement.startPosition.x) / canvas.clientWidth;\n  phiWindowRatio = Math.min(phiWindowRatio, controller.maximumMovementRatio);\n  var deltaPhi = rotateRate * phiWindowRatio * Math.PI * 4.0;\n  camera.twistRight(deltaPhi);\n}\n\nfunction update2D(controller) {\n  var rotatable2D = controller._scene.mapMode2D === MapMode2D.ROTATE;\n\n  if (!Matrix4.equals(Matrix4.IDENTITY, controller._scene.camera.transform)) {\n    reactToInput(controller, controller.enableZoom, controller.zoomEventTypes, zoom2D, controller.inertiaZoom, \"_lastInertiaZoomMovement\");\n\n    if (rotatable2D) {\n      reactToInput(controller, controller.enableRotate, controller.translateEventTypes, twist2D, controller.inertiaSpin, \"_lastInertiaSpinMovement\");\n    }\n  } else {\n    reactToInput(controller, controller.enableTranslate, controller.translateEventTypes, translate2D, controller.inertiaTranslate, \"_lastInertiaTranslateMovement\");\n    reactToInput(controller, controller.enableZoom, controller.zoomEventTypes, zoom2D, controller.inertiaZoom, \"_lastInertiaZoomMovement\");\n\n    if (rotatable2D) {\n      reactToInput(controller, controller.enableRotate, controller.tiltEventTypes, twist2D, controller.inertiaSpin, \"_lastInertiaTiltMovement\");\n    }\n  }\n}\n\nvar pickGlobeScratchRay = new Ray();\nvar scratchDepthIntersection = new Cartesian3();\nvar scratchRayIntersection = new Cartesian3();\n\nfunction pickGlobe(controller, mousePosition, result) {\n  var scene = controller._scene;\n  var globe = controller._globe;\n  var camera = scene.camera;\n\n  if (!defined(globe)) {\n    return undefined;\n  }\n\n  var depthIntersection;\n\n  if (scene.pickPositionSupported) {\n    depthIntersection = scene.pickPositionWorldCoordinates(mousePosition, scratchDepthIntersection);\n  }\n\n  var ray = camera.getPickRay(mousePosition, pickGlobeScratchRay);\n  var rayIntersection = globe.pickWorldCoordinates(ray, scene, scratchRayIntersection);\n  var pickDistance = defined(depthIntersection) ? Cartesian3.distance(depthIntersection, camera.positionWC) : Number.POSITIVE_INFINITY;\n  var rayDistance = defined(rayIntersection) ? Cartesian3.distance(rayIntersection, camera.positionWC) : Number.POSITIVE_INFINITY;\n\n  if (pickDistance < rayDistance) {\n    return Cartesian3.clone(depthIntersection, result);\n  }\n\n  return Cartesian3.clone(rayIntersection, result);\n}\n\nvar translateCVStartRay = new Ray();\nvar translateCVEndRay = new Ray();\nvar translateCVStartPos = new Cartesian3();\nvar translateCVEndPos = new Cartesian3();\nvar translatCVDifference = new Cartesian3();\nvar translateCVOrigin = new Cartesian3();\nvar translateCVPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nvar translateCVStartMouse = new Cartesian2();\nvar translateCVEndMouse = new Cartesian2();\n\nfunction translateCV(controller, startPosition, movement) {\n  if (!Cartesian3.equals(startPosition, controller._translateMousePosition)) {\n    controller._looking = false;\n  }\n\n  if (!Cartesian3.equals(startPosition, controller._strafeMousePosition)) {\n    controller._strafing = false;\n  }\n\n  if (controller._looking) {\n    look3D(controller, startPosition, movement);\n    return;\n  }\n\n  if (controller._strafing) {\n    strafe(controller, startPosition, movement);\n    return;\n  }\n\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var startMouse = Cartesian2.clone(movement.startPosition, translateCVStartMouse);\n  var endMouse = Cartesian2.clone(movement.endPosition, translateCVEndMouse);\n  var startRay = camera.getPickRay(startMouse, translateCVStartRay);\n  var origin = Cartesian3.clone(Cartesian3.ZERO, translateCVOrigin);\n  var normal = Cartesian3.UNIT_X;\n  var globePos;\n\n  if (camera.position.z < controller._minimumPickingTerrainHeight) {\n    globePos = pickGlobe(controller, startMouse, translateCVStartPos);\n\n    if (defined(globePos)) {\n      origin.x = globePos.x;\n    }\n  }\n\n  if (origin.x > camera.position.z && defined(globePos)) {\n    Cartesian3.clone(globePos, controller._strafeStartPosition);\n    controller._strafing = true;\n    strafe(controller, startPosition, movement);\n    controller._strafeMousePosition = Cartesian2.clone(startPosition, controller._strafeMousePosition);\n    return;\n  }\n\n  var plane = Plane.fromPointNormal(origin, normal, translateCVPlane);\n  startRay = camera.getPickRay(startMouse, translateCVStartRay);\n  var startPlanePos = IntersectionTests.rayPlane(startRay, plane, translateCVStartPos);\n  var endRay = camera.getPickRay(endMouse, translateCVEndRay);\n  var endPlanePos = IntersectionTests.rayPlane(endRay, plane, translateCVEndPos);\n\n  if (!defined(startPlanePos) || !defined(endPlanePos)) {\n    controller._looking = true;\n    look3D(controller, startPosition, movement);\n    Cartesian2.clone(startPosition, controller._translateMousePosition);\n    return;\n  }\n\n  var diff = Cartesian3.subtract(startPlanePos, endPlanePos, translatCVDifference);\n  var temp = diff.x;\n  diff.x = diff.y;\n  diff.y = diff.z;\n  diff.z = temp;\n  var mag = Cartesian3.magnitude(diff);\n\n  if (mag > CesiumMath.EPSILON6) {\n    Cartesian3.normalize(diff, diff);\n    camera.move(diff, mag);\n  }\n}\n\nvar rotateCVWindowPos = new Cartesian2();\nvar rotateCVWindowRay = new Ray();\nvar rotateCVCenter = new Cartesian3();\nvar rotateCVVerticalCenter = new Cartesian3();\nvar rotateCVTransform = new Matrix4();\nvar rotateCVVerticalTransform = new Matrix4();\nvar rotateCVOrigin = new Cartesian3();\nvar rotateCVPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nvar rotateCVCartesian3 = new Cartesian3();\nvar rotateCVCart = new Cartographic();\nvar rotateCVOldTransform = new Matrix4();\nvar rotateCVQuaternion = new Quaternion();\nvar rotateCVMatrix = new Matrix3();\nvar tilt3DCartesian3 = new Cartesian3();\n\nfunction rotateCV(controller, startPosition, movement) {\n  if (defined(movement.angleAndHeight)) {\n    movement = movement.angleAndHeight;\n  }\n\n  if (!Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    controller._tiltCVOffMap = false;\n    controller._looking = false;\n  }\n\n  if (controller._looking) {\n    look3D(controller, startPosition, movement);\n    return;\n  }\n\n  var scene = controller._scene;\n  var camera = scene.camera;\n\n  if (controller._tiltCVOffMap || !controller.onMap() || camera.position.z > controller._minimumPickingTerrainHeight) {\n    controller._tiltCVOffMap = true;\n    rotateCVOnPlane(controller, startPosition, movement);\n  } else {\n    rotateCVOnTerrain(controller, startPosition, movement);\n  }\n}\n\nfunction rotateCVOnPlane(controller, startPosition, movement) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var canvas = scene.canvas;\n  var windowPosition = rotateCVWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = canvas.clientHeight / 2;\n  var ray = camera.getPickRay(windowPosition, rotateCVWindowRay);\n  var normal = Cartesian3.UNIT_X;\n  var position = ray.origin;\n  var direction = ray.direction;\n  var scalar;\n  var normalDotDirection = Cartesian3.dot(normal, direction);\n\n  if (Math.abs(normalDotDirection) > CesiumMath.EPSILON6) {\n    scalar = -Cartesian3.dot(normal, position) / normalDotDirection;\n  }\n\n  if (!defined(scalar) || scalar <= 0.0) {\n    controller._looking = true;\n    look3D(controller, startPosition, movement);\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    return;\n  }\n\n  var center = Cartesian3.multiplyByScalar(direction, scalar, rotateCVCenter);\n  Cartesian3.add(position, center, center);\n  var projection = scene.mapProjection;\n  var ellipsoid = projection.ellipsoid;\n  Cartesian3.fromElements(center.y, center.z, center.x, center);\n  var cart = projection.unproject(center, rotateCVCart);\n  ellipsoid.cartographicToCartesian(cart, center);\n  var transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, rotateCVTransform);\n  var oldGlobe = controller._globe;\n  var oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n  var oldTransform = Matrix4.clone(camera.transform, rotateCVOldTransform);\n\n  camera._setTransform(transform);\n\n  rotate3D(controller, startPosition, movement, Cartesian3.UNIT_Z);\n\n  camera._setTransform(oldTransform);\n\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n  var radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n}\n\nfunction rotateCVOnTerrain(controller, startPosition, movement) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var center;\n  var ray;\n  var normal = Cartesian3.UNIT_X;\n\n  if (Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    center = Cartesian3.clone(controller._tiltCenter, rotateCVCenter);\n  } else {\n    if (camera.position.z < controller._minimumPickingTerrainHeight) {\n      center = pickGlobe(controller, startPosition, rotateCVCenter);\n    }\n\n    if (!defined(center)) {\n      ray = camera.getPickRay(startPosition, rotateCVWindowRay);\n      var position = ray.origin;\n      var direction = ray.direction;\n      var scalar;\n      var normalDotDirection = Cartesian3.dot(normal, direction);\n\n      if (Math.abs(normalDotDirection) > CesiumMath.EPSILON6) {\n        scalar = -Cartesian3.dot(normal, position) / normalDotDirection;\n      }\n\n      if (!defined(scalar) || scalar <= 0.0) {\n        controller._looking = true;\n        look3D(controller, startPosition, movement);\n        Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n        return;\n      }\n\n      center = Cartesian3.multiplyByScalar(direction, scalar, rotateCVCenter);\n      Cartesian3.add(position, center, center);\n    }\n\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    Cartesian3.clone(center, controller._tiltCenter);\n  }\n\n  var canvas = scene.canvas;\n  var windowPosition = rotateCVWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = controller._tiltCenterMousePosition.y;\n  ray = camera.getPickRay(windowPosition, rotateCVWindowRay);\n  var origin = Cartesian3.clone(Cartesian3.ZERO, rotateCVOrigin);\n  origin.x = center.x;\n  var plane = Plane.fromPointNormal(origin, normal, rotateCVPlane);\n  var verticalCenter = IntersectionTests.rayPlane(ray, plane, rotateCVVerticalCenter);\n  var projection = camera._projection;\n  var ellipsoid = projection.ellipsoid;\n  Cartesian3.fromElements(center.y, center.z, center.x, center);\n  var cart = projection.unproject(center, rotateCVCart);\n  ellipsoid.cartographicToCartesian(cart, center);\n  var transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, rotateCVTransform);\n  var verticalTransform;\n\n  if (defined(verticalCenter)) {\n    Cartesian3.fromElements(verticalCenter.y, verticalCenter.z, verticalCenter.x, verticalCenter);\n    cart = projection.unproject(verticalCenter, rotateCVCart);\n    ellipsoid.cartographicToCartesian(cart, verticalCenter);\n    verticalTransform = Transforms.eastNorthUpToFixedFrame(verticalCenter, ellipsoid, rotateCVVerticalTransform);\n  } else {\n    verticalTransform = transform;\n  }\n\n  var oldGlobe = controller._globe;\n  var oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n  var constrainedAxis = Cartesian3.UNIT_Z;\n  var oldTransform = Matrix4.clone(camera.transform, rotateCVOldTransform);\n\n  camera._setTransform(transform);\n\n  var tangent = Cartesian3.cross(Cartesian3.UNIT_Z, Cartesian3.normalize(camera.position, rotateCVCartesian3), rotateCVCartesian3);\n  var dot = Cartesian3.dot(camera.right, tangent);\n  rotate3D(controller, startPosition, movement, constrainedAxis, false, true);\n\n  camera._setTransform(verticalTransform);\n\n  if (dot < 0.0) {\n    if (movement.startPosition.y > movement.endPosition.y) {\n      constrainedAxis = undefined;\n    }\n\n    var oldConstrainedAxis = camera.constrainedAxis;\n    camera.constrainedAxis = undefined;\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n    camera.constrainedAxis = oldConstrainedAxis;\n  } else {\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n  }\n\n  if (defined(camera.constrainedAxis)) {\n    var right = Cartesian3.cross(camera.direction, camera.constrainedAxis, tilt3DCartesian3);\n\n    if (!Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)) {\n      if (Cartesian3.dot(right, camera.right) < 0.0) {\n        Cartesian3.negate(right, right);\n      }\n\n      Cartesian3.cross(right, camera.direction, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.normalize(camera.up, camera.up);\n      Cartesian3.normalize(camera.right, camera.right);\n    }\n  }\n\n  camera._setTransform(oldTransform);\n\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n  var radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n  var originalPosition = Cartesian3.clone(camera.positionWC, rotateCVCartesian3);\n\n  if (controller.enableCollisionDetection) {\n    adjustHeightForTerrain(controller);\n  }\n\n  if (!Cartesian3.equals(camera.positionWC, originalPosition)) {\n    camera._setTransform(verticalTransform);\n\n    camera.worldToCameraCoordinatesPoint(originalPosition, originalPosition);\n    var magSqrd = Cartesian3.magnitudeSquared(originalPosition);\n\n    if (Cartesian3.magnitudeSquared(camera.position) > magSqrd) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.multiplyByScalar(camera.position, Math.sqrt(magSqrd), camera.position);\n    }\n\n    var angle = Cartesian3.angleBetween(originalPosition, camera.position);\n    var axis = Cartesian3.cross(originalPosition, camera.position, originalPosition);\n    Cartesian3.normalize(axis, axis);\n    var quaternion = Quaternion.fromAxisAngle(axis, angle, rotateCVQuaternion);\n    var rotation = Matrix3.fromQuaternion(quaternion, rotateCVMatrix);\n    Matrix3.multiplyByVector(rotation, camera.direction, camera.direction);\n    Matrix3.multiplyByVector(rotation, camera.up, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.cross(camera.right, camera.direction, camera.up);\n\n    camera._setTransform(oldTransform);\n  }\n}\n\nvar zoomCVWindowPos = new Cartesian2();\nvar zoomCVWindowRay = new Ray();\nvar zoomCVIntersection = new Cartesian3();\n\nfunction zoomCV(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var canvas = scene.canvas;\n  var windowPosition = zoomCVWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = canvas.clientHeight / 2;\n  var ray = camera.getPickRay(windowPosition, zoomCVWindowRay);\n  var intersection;\n\n  if (camera.position.z < controller._minimumPickingTerrainHeight) {\n    intersection = pickGlobe(controller, windowPosition, zoomCVIntersection);\n  }\n\n  var distance;\n\n  if (defined(intersection)) {\n    distance = Cartesian3.distance(ray.origin, intersection);\n  } else {\n    var normal = Cartesian3.UNIT_X;\n    var position = ray.origin;\n    var direction = ray.direction;\n    distance = -Cartesian3.dot(normal, position) / Cartesian3.dot(normal, direction);\n  }\n\n  handleZoom(controller, startPosition, movement, controller._zoomFactor, distance);\n}\n\nfunction updateCV(controller) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n\n  if (!Matrix4.equals(Matrix4.IDENTITY, camera.transform)) {\n    reactToInput(controller, controller.enableRotate, controller.rotateEventTypes, rotate3D, controller.inertiaSpin, \"_lastInertiaSpinMovement\");\n    reactToInput(controller, controller.enableZoom, controller.zoomEventTypes, zoom3D, controller.inertiaZoom, \"_lastInertiaZoomMovement\");\n  } else {\n    var tweens = controller._tweens;\n\n    if (controller._aggregator.anyButtonDown) {\n      tweens.removeAll();\n    }\n\n    reactToInput(controller, controller.enableTilt, controller.tiltEventTypes, rotateCV, controller.inertiaSpin, \"_lastInertiaTiltMovement\");\n    reactToInput(controller, controller.enableTranslate, controller.translateEventTypes, translateCV, controller.inertiaTranslate, \"_lastInertiaTranslateMovement\");\n    reactToInput(controller, controller.enableZoom, controller.zoomEventTypes, zoomCV, controller.inertiaZoom, \"_lastInertiaZoomMovement\");\n    reactToInput(controller, controller.enableLook, controller.lookEventTypes, look3D);\n\n    if (!controller._aggregator.anyButtonDown && (!defined(controller._lastInertiaZoomMovement) || !controller._lastInertiaZoomMovement.active) && (!defined(controller._lastInertiaTranslateMovement) || !controller._lastInertiaTranslateMovement.active) && !tweens.contains(controller._tween)) {\n      var tween = camera.createCorrectPositionTween(controller.bounceAnimationTime);\n\n      if (defined(tween)) {\n        controller._tween = tweens.add(tween);\n      }\n    }\n\n    tweens.update();\n  }\n}\n\nvar scratchStrafeRay = new Ray();\nvar scratchStrafePlane = new Plane(Cartesian3.UNIT_X, 0.0);\nvar scratchStrafeIntersection = new Cartesian3();\nvar scratchStrafeDirection = new Cartesian3();\nvar scratchMousePos = new Cartesian3();\n\nfunction strafe(controller, startPosition, movement) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var mouseStartPosition = pickGlobe(controller, movement.startPosition, scratchMousePos);\n\n  if (!defined(mouseStartPosition)) {\n    return;\n  }\n\n  var mousePosition = movement.endPosition;\n  var ray = camera.getPickRay(mousePosition, scratchStrafeRay);\n  var direction = Cartesian3.clone(camera.direction, scratchStrafeDirection);\n\n  if (scene.mode === SceneMode.COLUMBUS_VIEW) {\n    Cartesian3.fromElements(direction.z, direction.x, direction.y, direction);\n  }\n\n  var plane = Plane.fromPointNormal(mouseStartPosition, direction, scratchStrafePlane);\n  var intersection = IntersectionTests.rayPlane(ray, plane, scratchStrafeIntersection);\n\n  if (!defined(intersection)) {\n    return;\n  }\n\n  direction = Cartesian3.subtract(mouseStartPosition, intersection, direction);\n\n  if (scene.mode === SceneMode.COLUMBUS_VIEW) {\n    Cartesian3.fromElements(direction.y, direction.z, direction.x, direction);\n  }\n\n  Cartesian3.add(camera.position, direction, camera.position);\n}\n\nvar spin3DPick = new Cartesian3();\nvar scratchCartographic = new Cartographic();\nvar scratchRadii = new Cartesian3();\nvar scratchEllipsoid = new Ellipsoid();\nvar scratchLookUp = new Cartesian3();\n\nfunction spin3D(controller, startPosition, movement) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    rotate3D(controller, startPosition, movement);\n    return;\n  }\n\n  var magnitude;\n  var radii;\n  var ellipsoid;\n\n  var up = controller._ellipsoid.geodeticSurfaceNormal(camera.position, scratchLookUp);\n\n  var height = controller._ellipsoid.cartesianToCartographic(camera.positionWC, scratchCartographic).height;\n\n  var globe = controller._globe;\n  var mousePos;\n  var tangentPick = false;\n\n  if (defined(globe) && height < controller._minimumPickingTerrainHeight) {\n    mousePos = pickGlobe(controller, movement.startPosition, scratchMousePos);\n\n    if (defined(mousePos)) {\n      var ray = camera.getPickRay(movement.startPosition, pickGlobeScratchRay);\n\n      var normal = controller._ellipsoid.geodeticSurfaceNormal(mousePos);\n\n      tangentPick = Math.abs(Cartesian3.dot(ray.direction, normal)) < 0.05;\n\n      if (tangentPick && !controller._looking) {\n        controller._rotating = false;\n        controller._strafing = true;\n      }\n    }\n  }\n\n  if (Cartesian2.equals(startPosition, controller._rotateMousePosition)) {\n    if (controller._looking) {\n      look3D(controller, startPosition, movement, up);\n    } else if (controller._rotating) {\n      rotate3D(controller, startPosition, movement);\n    } else if (controller._strafing) {\n      Cartesian3.clone(mousePos, controller._strafeStartPosition);\n      strafe(controller, startPosition, movement);\n    } else {\n      magnitude = Cartesian3.magnitude(controller._rotateStartPosition);\n      radii = scratchRadii;\n      radii.x = radii.y = radii.z = magnitude;\n      ellipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n      pan3D(controller, startPosition, movement, ellipsoid);\n    }\n\n    return;\n  }\n\n  controller._looking = false;\n  controller._rotating = false;\n  controller._strafing = false;\n\n  if (defined(globe) && height < controller._minimumPickingTerrainHeight) {\n    if (defined(mousePos)) {\n      if (Cartesian3.magnitude(camera.position) < Cartesian3.magnitude(mousePos)) {\n        Cartesian3.clone(mousePos, controller._strafeStartPosition);\n        controller._strafing = true;\n        strafe(controller, startPosition, movement);\n      } else {\n        magnitude = Cartesian3.magnitude(mousePos);\n        radii = scratchRadii;\n        radii.x = radii.y = radii.z = magnitude;\n        ellipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n        pan3D(controller, startPosition, movement, ellipsoid);\n        Cartesian3.clone(mousePos, controller._rotateStartPosition);\n      }\n    } else {\n      controller._looking = true;\n      look3D(controller, startPosition, movement, up);\n    }\n  } else if (defined(camera.pickEllipsoid(movement.startPosition, controller._ellipsoid, spin3DPick))) {\n    pan3D(controller, startPosition, movement, controller._ellipsoid);\n    Cartesian3.clone(spin3DPick, controller._rotateStartPosition);\n  } else if (height > controller._minimumTrackBallHeight) {\n    controller._rotating = true;\n    rotate3D(controller, startPosition, movement);\n  } else {\n    controller._looking = true;\n    look3D(controller, startPosition, movement, up);\n  }\n\n  Cartesian2.clone(startPosition, controller._rotateMousePosition);\n}\n\nfunction rotate3D(controller, startPosition, movement, constrainedAxis, rotateOnlyVertical, rotateOnlyHorizontal) {\n  rotateOnlyVertical = defaultValue(rotateOnlyVertical, false);\n  rotateOnlyHorizontal = defaultValue(rotateOnlyHorizontal, false);\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var canvas = scene.canvas;\n  var oldAxis = camera.constrainedAxis;\n\n  if (defined(constrainedAxis)) {\n    camera.constrainedAxis = constrainedAxis;\n  }\n\n  var rho = Cartesian3.magnitude(camera.position);\n  var rotateRate = controller._rotateFactor * (rho - controller._rotateRateRangeAdjustment);\n\n  if (rotateRate > controller._maximumRotateRate) {\n    rotateRate = controller._maximumRotateRate;\n  }\n\n  if (rotateRate < controller._minimumRotateRate) {\n    rotateRate = controller._minimumRotateRate;\n  }\n\n  var phiWindowRatio = (movement.startPosition.x - movement.endPosition.x) / canvas.clientWidth;\n  var thetaWindowRatio = (movement.startPosition.y - movement.endPosition.y) / canvas.clientHeight;\n  phiWindowRatio = Math.min(phiWindowRatio, controller.maximumMovementRatio);\n  thetaWindowRatio = Math.min(thetaWindowRatio, controller.maximumMovementRatio);\n  var deltaPhi = rotateRate * phiWindowRatio * Math.PI * 2.0;\n  var deltaTheta = rotateRate * thetaWindowRatio * Math.PI;\n\n  if (!rotateOnlyVertical) {\n    camera.rotateRight(deltaPhi);\n  }\n\n  if (!rotateOnlyHorizontal) {\n    camera.rotateUp(deltaTheta);\n  }\n\n  camera.constrainedAxis = oldAxis;\n}\n\nvar pan3DP0 = Cartesian4.clone(Cartesian4.UNIT_W);\nvar pan3DP1 = Cartesian4.clone(Cartesian4.UNIT_W);\nvar pan3DTemp0 = new Cartesian3();\nvar pan3DTemp1 = new Cartesian3();\nvar pan3DTemp2 = new Cartesian3();\nvar pan3DTemp3 = new Cartesian3();\nvar pan3DStartMousePosition = new Cartesian2();\nvar pan3DEndMousePosition = new Cartesian2();\n\nfunction pan3D(controller, startPosition, movement, ellipsoid) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var startMousePosition = Cartesian2.clone(movement.startPosition, pan3DStartMousePosition);\n  var endMousePosition = Cartesian2.clone(movement.endPosition, pan3DEndMousePosition);\n  var p0 = camera.pickEllipsoid(startMousePosition, ellipsoid, pan3DP0);\n  var p1 = camera.pickEllipsoid(endMousePosition, ellipsoid, pan3DP1);\n\n  if (!defined(p0) || !defined(p1)) {\n    controller._rotating = true;\n    rotate3D(controller, startPosition, movement);\n    return;\n  }\n\n  p0 = camera.worldToCameraCoordinates(p0, p0);\n  p1 = camera.worldToCameraCoordinates(p1, p1);\n\n  if (!defined(camera.constrainedAxis)) {\n    Cartesian3.normalize(p0, p0);\n    Cartesian3.normalize(p1, p1);\n    var dot = Cartesian3.dot(p0, p1);\n    var axis = Cartesian3.cross(p0, p1, pan3DTemp0);\n\n    if (dot < 1.0 && !Cartesian3.equalsEpsilon(axis, Cartesian3.ZERO, CesiumMath.EPSILON14)) {\n      // dot is in [0, 1]\n      var angle = Math.acos(dot);\n      camera.rotate(axis, angle);\n    }\n  } else {\n    var basis0 = camera.constrainedAxis;\n    var basis1 = Cartesian3.mostOrthogonalAxis(basis0, pan3DTemp0);\n    Cartesian3.cross(basis1, basis0, basis1);\n    Cartesian3.normalize(basis1, basis1);\n    var basis2 = Cartesian3.cross(basis0, basis1, pan3DTemp1);\n    var startRho = Cartesian3.magnitude(p0);\n    var startDot = Cartesian3.dot(basis0, p0);\n    var startTheta = Math.acos(startDot / startRho);\n    var startRej = Cartesian3.multiplyByScalar(basis0, startDot, pan3DTemp2);\n    Cartesian3.subtract(p0, startRej, startRej);\n    Cartesian3.normalize(startRej, startRej);\n    var endRho = Cartesian3.magnitude(p1);\n    var endDot = Cartesian3.dot(basis0, p1);\n    var endTheta = Math.acos(endDot / endRho);\n    var endRej = Cartesian3.multiplyByScalar(basis0, endDot, pan3DTemp3);\n    Cartesian3.subtract(p1, endRej, endRej);\n    Cartesian3.normalize(endRej, endRej);\n    var startPhi = Math.acos(Cartesian3.dot(startRej, basis1));\n\n    if (Cartesian3.dot(startRej, basis2) < 0) {\n      startPhi = CesiumMath.TWO_PI - startPhi;\n    }\n\n    var endPhi = Math.acos(Cartesian3.dot(endRej, basis1));\n\n    if (Cartesian3.dot(endRej, basis2) < 0) {\n      endPhi = CesiumMath.TWO_PI - endPhi;\n    }\n\n    var deltaPhi = startPhi - endPhi;\n    var east;\n\n    if (Cartesian3.equalsEpsilon(basis0, camera.position, CesiumMath.EPSILON2)) {\n      east = camera.right;\n    } else {\n      east = Cartesian3.cross(basis0, camera.position, pan3DTemp0);\n    }\n\n    var planeNormal = Cartesian3.cross(basis0, east, pan3DTemp0);\n    var side0 = Cartesian3.dot(planeNormal, Cartesian3.subtract(p0, basis0, pan3DTemp1));\n    var side1 = Cartesian3.dot(planeNormal, Cartesian3.subtract(p1, basis0, pan3DTemp1));\n    var deltaTheta;\n\n    if (side0 > 0 && side1 > 0) {\n      deltaTheta = endTheta - startTheta;\n    } else if (side0 > 0 && side1 <= 0) {\n      if (Cartesian3.dot(camera.position, basis0) > 0) {\n        deltaTheta = -startTheta - endTheta;\n      } else {\n        deltaTheta = startTheta + endTheta;\n      }\n    } else {\n      deltaTheta = startTheta - endTheta;\n    }\n\n    camera.rotateRight(deltaPhi);\n    camera.rotateUp(deltaTheta);\n  }\n}\n\nvar zoom3DUnitPosition = new Cartesian3();\nvar zoom3DCartographic = new Cartographic();\n\nfunction zoom3D(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n\n  var ellipsoid = controller._ellipsoid;\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var canvas = scene.canvas;\n  var windowPosition = zoomCVWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = canvas.clientHeight / 2;\n  var ray = camera.getPickRay(windowPosition, zoomCVWindowRay);\n  var intersection;\n  var height = ellipsoid.cartesianToCartographic(camera.position, zoom3DCartographic).height;\n\n  if (height < controller._minimumPickingTerrainHeight) {\n    intersection = pickGlobe(controller, windowPosition, zoomCVIntersection);\n  }\n\n  var distance;\n\n  if (defined(intersection)) {\n    distance = Cartesian3.distance(ray.origin, intersection);\n  } else {\n    distance = height;\n  }\n\n  var unitPosition = Cartesian3.normalize(camera.position, zoom3DUnitPosition);\n  handleZoom(controller, startPosition, movement, controller._zoomFactor, distance, Cartesian3.dot(unitPosition, camera.direction));\n}\n\nvar tilt3DWindowPos = new Cartesian2();\nvar tilt3DRay = new Ray();\nvar tilt3DCenter = new Cartesian3();\nvar tilt3DVerticalCenter = new Cartesian3();\nvar tilt3DTransform = new Matrix4();\nvar tilt3DVerticalTransform = new Matrix4();\nvar tilt3DOldTransform = new Matrix4();\nvar tilt3DQuaternion = new Quaternion();\nvar tilt3DMatrix = new Matrix3();\nvar tilt3DCart = new Cartographic();\nvar tilt3DLookUp = new Cartesian3();\n\nfunction tilt3D(controller, startPosition, movement) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    return;\n  }\n\n  if (defined(movement.angleAndHeight)) {\n    movement = movement.angleAndHeight;\n  }\n\n  if (!Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    controller._tiltOnEllipsoid = false;\n    controller._looking = false;\n  }\n\n  if (controller._looking) {\n    var up = controller._ellipsoid.geodeticSurfaceNormal(camera.position, tilt3DLookUp);\n\n    look3D(controller, startPosition, movement, up);\n    return;\n  }\n\n  var ellipsoid = controller._ellipsoid;\n  var cartographic = ellipsoid.cartesianToCartographic(camera.position, tilt3DCart);\n\n  if (controller._tiltOnEllipsoid || cartographic.height > controller._minimumCollisionTerrainHeight) {\n    controller._tiltOnEllipsoid = true;\n    tilt3DOnEllipsoid(controller, startPosition, movement);\n  } else {\n    tilt3DOnTerrain(controller, startPosition, movement);\n  }\n}\n\nvar tilt3DOnEllipsoidCartographic = new Cartographic();\n\nfunction tilt3DOnEllipsoid(controller, startPosition, movement) {\n  var ellipsoid = controller._ellipsoid;\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var minHeight = controller.minimumZoomDistance * 0.25;\n  var height = ellipsoid.cartesianToCartographic(camera.positionWC, tilt3DOnEllipsoidCartographic).height;\n\n  if (height - minHeight - 1.0 < CesiumMath.EPSILON3 && movement.endPosition.y - movement.startPosition.y < 0) {\n    return;\n  }\n\n  var canvas = scene.canvas;\n  var windowPosition = tilt3DWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = canvas.clientHeight / 2;\n  var ray = camera.getPickRay(windowPosition, tilt3DRay);\n  var center;\n  var intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n\n  if (defined(intersection)) {\n    center = Ray.getPoint(ray, intersection.start, tilt3DCenter);\n  } else if (height > controller._minimumTrackBallHeight) {\n    var grazingAltitudeLocation = IntersectionTests.grazingAltitudeLocation(ray, ellipsoid);\n\n    if (!defined(grazingAltitudeLocation)) {\n      return;\n    }\n\n    var grazingAltitudeCart = ellipsoid.cartesianToCartographic(grazingAltitudeLocation, tilt3DCart);\n    grazingAltitudeCart.height = 0.0;\n    center = ellipsoid.cartographicToCartesian(grazingAltitudeCart, tilt3DCenter);\n  } else {\n    controller._looking = true;\n\n    var up = controller._ellipsoid.geodeticSurfaceNormal(camera.position, tilt3DLookUp);\n\n    look3D(controller, startPosition, movement, up);\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    return;\n  }\n\n  var transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, tilt3DTransform);\n  var oldGlobe = controller._globe;\n  var oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n  var oldTransform = Matrix4.clone(camera.transform, tilt3DOldTransform);\n\n  camera._setTransform(transform);\n\n  rotate3D(controller, startPosition, movement, Cartesian3.UNIT_Z);\n\n  camera._setTransform(oldTransform);\n\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n  var radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n}\n\nfunction tilt3DOnTerrain(controller, startPosition, movement) {\n  var ellipsoid = controller._ellipsoid;\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var center;\n  var ray;\n  var intersection;\n\n  if (Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    center = Cartesian3.clone(controller._tiltCenter, tilt3DCenter);\n  } else {\n    center = pickGlobe(controller, startPosition, tilt3DCenter);\n\n    if (!defined(center)) {\n      ray = camera.getPickRay(startPosition, tilt3DRay);\n      intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n\n      if (!defined(intersection)) {\n        var cartographic = ellipsoid.cartesianToCartographic(camera.position, tilt3DCart);\n\n        if (cartographic.height <= controller._minimumTrackBallHeight) {\n          controller._looking = true;\n\n          var up = controller._ellipsoid.geodeticSurfaceNormal(camera.position, tilt3DLookUp);\n\n          look3D(controller, startPosition, movement, up);\n          Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n        }\n\n        return;\n      }\n\n      center = Ray.getPoint(ray, intersection.start, tilt3DCenter);\n    }\n\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    Cartesian3.clone(center, controller._tiltCenter);\n  }\n\n  var canvas = scene.canvas;\n  var windowPosition = tilt3DWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = controller._tiltCenterMousePosition.y;\n  ray = camera.getPickRay(windowPosition, tilt3DRay);\n  var mag = Cartesian3.magnitude(center);\n  var radii = Cartesian3.fromElements(mag, mag, mag, scratchRadii);\n  var newEllipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n  intersection = IntersectionTests.rayEllipsoid(ray, newEllipsoid);\n\n  if (!defined(intersection)) {\n    return;\n  }\n\n  var t = Cartesian3.magnitude(ray.origin) > mag ? intersection.start : intersection.stop;\n  var verticalCenter = Ray.getPoint(ray, t, tilt3DVerticalCenter);\n  var transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, tilt3DTransform);\n  var verticalTransform = Transforms.eastNorthUpToFixedFrame(verticalCenter, newEllipsoid, tilt3DVerticalTransform);\n  var oldGlobe = controller._globe;\n  var oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n  var constrainedAxis = Cartesian3.UNIT_Z;\n  var oldTransform = Matrix4.clone(camera.transform, tilt3DOldTransform);\n\n  camera._setTransform(transform);\n\n  var tangent = Cartesian3.cross(verticalCenter, camera.positionWC, tilt3DCartesian3);\n  var dot = Cartesian3.dot(camera.rightWC, tangent);\n  rotate3D(controller, startPosition, movement, constrainedAxis, false, true);\n\n  camera._setTransform(verticalTransform);\n\n  if (dot < 0.0) {\n    if (movement.startPosition.y > movement.endPosition.y) {\n      constrainedAxis = undefined;\n    }\n\n    var oldConstrainedAxis = camera.constrainedAxis;\n    camera.constrainedAxis = undefined;\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n    camera.constrainedAxis = oldConstrainedAxis;\n  } else {\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n  }\n\n  if (defined(camera.constrainedAxis)) {\n    var right = Cartesian3.cross(camera.direction, camera.constrainedAxis, tilt3DCartesian3);\n\n    if (!Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)) {\n      if (Cartesian3.dot(right, camera.right) < 0.0) {\n        Cartesian3.negate(right, right);\n      }\n\n      Cartesian3.cross(right, camera.direction, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.normalize(camera.up, camera.up);\n      Cartesian3.normalize(camera.right, camera.right);\n    }\n  }\n\n  camera._setTransform(oldTransform);\n\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n  var radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n  var originalPosition = Cartesian3.clone(camera.positionWC, tilt3DCartesian3);\n\n  if (controller.enableCollisionDetection) {\n    adjustHeightForTerrain(controller);\n  }\n\n  if (!Cartesian3.equals(camera.positionWC, originalPosition)) {\n    camera._setTransform(verticalTransform);\n\n    camera.worldToCameraCoordinatesPoint(originalPosition, originalPosition);\n    var magSqrd = Cartesian3.magnitudeSquared(originalPosition);\n\n    if (Cartesian3.magnitudeSquared(camera.position) > magSqrd) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.multiplyByScalar(camera.position, Math.sqrt(magSqrd), camera.position);\n    }\n\n    var angle = Cartesian3.angleBetween(originalPosition, camera.position);\n    var axis = Cartesian3.cross(originalPosition, camera.position, originalPosition);\n    Cartesian3.normalize(axis, axis);\n    var quaternion = Quaternion.fromAxisAngle(axis, angle, tilt3DQuaternion);\n    var rotation = Matrix3.fromQuaternion(quaternion, tilt3DMatrix);\n    Matrix3.multiplyByVector(rotation, camera.direction, camera.direction);\n    Matrix3.multiplyByVector(rotation, camera.up, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.cross(camera.right, camera.direction, camera.up);\n\n    camera._setTransform(oldTransform);\n  }\n}\n\nvar look3DStartPos = new Cartesian2();\nvar look3DEndPos = new Cartesian2();\nvar look3DStartRay = new Ray();\nvar look3DEndRay = new Ray();\nvar look3DNegativeRot = new Cartesian3();\nvar look3DTan = new Cartesian3();\n\nfunction look3D(controller, startPosition, movement, rotationAxis) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var startPos = look3DStartPos;\n  startPos.x = movement.startPosition.x;\n  startPos.y = 0.0;\n  var endPos = look3DEndPos;\n  endPos.x = movement.endPosition.x;\n  endPos.y = 0.0;\n  var startRay = camera.getPickRay(startPos, look3DStartRay);\n  var endRay = camera.getPickRay(endPos, look3DEndRay);\n  var angle = 0.0;\n  var start;\n  var end;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    start = startRay.origin;\n    end = endRay.origin;\n    Cartesian3.add(camera.direction, start, start);\n    Cartesian3.add(camera.direction, end, end);\n    Cartesian3.subtract(start, camera.position, start);\n    Cartesian3.subtract(end, camera.position, end);\n    Cartesian3.normalize(start, start);\n    Cartesian3.normalize(end, end);\n  } else {\n    start = startRay.direction;\n    end = endRay.direction;\n  }\n\n  var dot = Cartesian3.dot(start, end);\n\n  if (dot < 1.0) {\n    // dot is in [0, 1]\n    angle = Math.acos(dot);\n  }\n\n  angle = movement.startPosition.x > movement.endPosition.x ? -angle : angle;\n  var horizontalRotationAxis = controller._horizontalRotationAxis;\n\n  if (defined(rotationAxis)) {\n    camera.look(rotationAxis, -angle);\n  } else if (defined(horizontalRotationAxis)) {\n    camera.look(horizontalRotationAxis, -angle);\n  } else {\n    camera.lookLeft(angle);\n  }\n\n  startPos.x = 0.0;\n  startPos.y = movement.startPosition.y;\n  endPos.x = 0.0;\n  endPos.y = movement.endPosition.y;\n  startRay = camera.getPickRay(startPos, look3DStartRay);\n  endRay = camera.getPickRay(endPos, look3DEndRay);\n  angle = 0.0;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    start = startRay.origin;\n    end = endRay.origin;\n    Cartesian3.add(camera.direction, start, start);\n    Cartesian3.add(camera.direction, end, end);\n    Cartesian3.subtract(start, camera.position, start);\n    Cartesian3.subtract(end, camera.position, end);\n    Cartesian3.normalize(start, start);\n    Cartesian3.normalize(end, end);\n  } else {\n    start = startRay.direction;\n    end = endRay.direction;\n  }\n\n  dot = Cartesian3.dot(start, end);\n\n  if (dot < 1.0) {\n    // dot is in [0, 1]\n    angle = Math.acos(dot);\n  }\n\n  angle = movement.startPosition.y > movement.endPosition.y ? -angle : angle;\n  rotationAxis = defaultValue(rotationAxis, horizontalRotationAxis);\n\n  if (defined(rotationAxis)) {\n    var direction = camera.direction;\n    var negativeRotationAxis = Cartesian3.negate(rotationAxis, look3DNegativeRot);\n    var northParallel = Cartesian3.equalsEpsilon(direction, rotationAxis, CesiumMath.EPSILON2);\n    var southParallel = Cartesian3.equalsEpsilon(direction, negativeRotationAxis, CesiumMath.EPSILON2);\n\n    if (!northParallel && !southParallel) {\n      dot = Cartesian3.dot(direction, rotationAxis);\n      var angleToAxis = CesiumMath.acosClamped(dot);\n\n      if (angle > 0 && angle > angleToAxis) {\n        angle = angleToAxis - CesiumMath.EPSILON4;\n      }\n\n      dot = Cartesian3.dot(direction, negativeRotationAxis);\n      angleToAxis = CesiumMath.acosClamped(dot);\n\n      if (angle < 0 && -angle > angleToAxis) {\n        angle = -angleToAxis + CesiumMath.EPSILON4;\n      }\n\n      var tangent = Cartesian3.cross(rotationAxis, direction, look3DTan);\n      camera.look(tangent, angle);\n    } else if (northParallel && angle < 0 || southParallel && angle > 0) {\n      camera.look(camera.right, -angle);\n    }\n  } else {\n    camera.lookUp(angle);\n  }\n}\n\nfunction update3D(controller) {\n  reactToInput(controller, controller.enableRotate, controller.rotateEventTypes, spin3D, controller.inertiaSpin, \"_lastInertiaSpinMovement\");\n  reactToInput(controller, controller.enableZoom, controller.zoomEventTypes, zoom3D, controller.inertiaZoom, \"_lastInertiaZoomMovement\");\n  reactToInput(controller, controller.enableTilt, controller.tiltEventTypes, tilt3D, controller.inertiaSpin, \"_lastInertiaTiltMovement\");\n  reactToInput(controller, controller.enableLook, controller.lookEventTypes, look3D);\n}\n\nvar scratchAdjustHeightTransform = new Matrix4();\nvar scratchAdjustHeightCartographic = new Cartographic();\n\nfunction adjustHeightForTerrain(controller) {\n  controller._adjustedHeightForTerrain = true;\n  var scene = controller._scene;\n  var mode = scene.mode;\n  var globe = scene.globe;\n\n  if (!defined(globe) || mode === SceneMode.SCENE2D || mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  var camera = scene.camera;\n  var ellipsoid = globe.ellipsoid;\n  var projection = scene.mapProjection;\n  var transform;\n  var mag;\n\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    transform = Matrix4.clone(camera.transform, scratchAdjustHeightTransform);\n    mag = Cartesian3.magnitude(camera.position);\n\n    camera._setTransform(Matrix4.IDENTITY);\n  }\n\n  var cartographic = scratchAdjustHeightCartographic;\n\n  if (mode === SceneMode.SCENE3D) {\n    ellipsoid.cartesianToCartographic(camera.position, cartographic);\n  } else {\n    projection.unproject(camera.position, cartographic);\n  }\n\n  var heightUpdated = false;\n\n  if (cartographic.height < controller._minimumCollisionTerrainHeight) {\n    var height = globe.getHeight(cartographic);\n\n    if (defined(height)) {\n      height += controller.minimumZoomDistance;\n\n      if (cartographic.height < height) {\n        cartographic.height = height;\n\n        if (mode === SceneMode.SCENE3D) {\n          ellipsoid.cartographicToCartesian(cartographic, camera.position);\n        } else {\n          projection.project(cartographic, camera.position);\n        }\n\n        heightUpdated = true;\n      }\n    }\n  }\n\n  if (defined(transform)) {\n    camera._setTransform(transform);\n\n    if (heightUpdated) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.negate(camera.position, camera.direction);\n      Cartesian3.multiplyByScalar(camera.position, Math.max(mag, controller.minimumZoomDistance), camera.position);\n      Cartesian3.normalize(camera.direction, camera.direction);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.cross(camera.right, camera.direction, camera.up);\n    }\n  }\n}\n/**\n * @private\n */\n\n\nScreenSpaceCameraController.prototype.onMap = function () {\n  var scene = this._scene;\n  var mode = scene.mode;\n  var camera = scene.camera;\n\n  if (mode === SceneMode.COLUMBUS_VIEW) {\n    return Math.abs(camera.position.x) - this._maxCoord.x < 0 && Math.abs(camera.position.y) - this._maxCoord.y < 0;\n  }\n\n  return true;\n};\n\nvar scratchPreviousPosition = new Cartesian3();\nvar scratchPreviousDirection = new Cartesian3();\n/**\n * @private\n */\n\nScreenSpaceCameraController.prototype.update = function () {\n  var camera = this._scene.camera;\n\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    this._globe = undefined;\n    this._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  } else {\n    this._globe = this._scene.globe;\n    this._ellipsoid = defined(this._globe) ? this._globe.ellipsoid : this._scene.mapProjection.ellipsoid;\n  }\n\n  this._minimumCollisionTerrainHeight = this.minimumCollisionTerrainHeight * this._scene.terrainExaggeration;\n  this._minimumPickingTerrainHeight = this.minimumPickingTerrainHeight * this._scene.terrainExaggeration;\n  this._minimumTrackBallHeight = this.minimumTrackBallHeight * this._scene.terrainExaggeration;\n  var radius = this._ellipsoid.maximumRadius;\n  this._rotateFactor = 1.0 / radius;\n  this._rotateRateRangeAdjustment = radius;\n  this._adjustedHeightForTerrain = false;\n  var previousPosition = Cartesian3.clone(camera.positionWC, scratchPreviousPosition);\n  var previousDirection = Cartesian3.clone(camera.directionWC, scratchPreviousDirection);\n  var scene = this._scene;\n  var mode = scene.mode;\n\n  if (mode === SceneMode.SCENE2D) {\n    update2D(this);\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    this._horizontalRotationAxis = Cartesian3.UNIT_Z;\n    updateCV(this);\n  } else if (mode === SceneMode.SCENE3D) {\n    this._horizontalRotationAxis = undefined;\n    update3D(this);\n  }\n\n  if (this.enableCollisionDetection && !this._adjustedHeightForTerrain) {\n    // Adjust the camera height if the camera moved at all (user input or intertia) and an action didn't already adjust the camera height\n    var cameraChanged = !Cartesian3.equals(previousPosition, camera.positionWC) || !Cartesian3.equals(previousDirection, camera.directionWC);\n\n    if (cameraChanged) {\n      adjustHeightForTerrain(this);\n    }\n  }\n\n  this._aggregator.reset();\n};\n/**\n * @private\n */\n\n\nScreenSpaceCameraController.prototype.adjustedHeightForTerrain = function () {\n  return this._adjustedHeightForTerrain;\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ScreenSpaceCameraController#destroy\n */\n\n\nScreenSpaceCameraController.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Removes mouse listeners held by this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * controller = controller && controller.destroy();\n *\n * @see ScreenSpaceCameraController#isDestroyed\n */\n\n\nScreenSpaceCameraController.prototype.destroy = function () {\n  this._tweens.removeAll();\n\n  this._aggregator = this._aggregator && this._aggregator.destroy();\n  return destroyObject(this);\n};\n\nexport default ScreenSpaceCameraController;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Scene/ScreenSpaceCameraController.js"],"names":["Cartesian2","Cartesian3","Cartesian4","Cartographic","defaultValue","defined","destroyObject","DeveloperError","Ellipsoid","HeadingPitchRoll","IntersectionTests","KeyboardEventModifier","CesiumMath","Matrix3","Matrix4","OrthographicFrustum","Plane","Quaternion","Ray","Transforms","CameraEventAggregator","CameraEventType","MapMode2D","SceneMode","SceneTransforms","TweenCollection","ScreenSpaceCameraController","scene","enableInputs","enableTranslate","enableZoom","enableRotate","enableTilt","enableLook","inertiaSpin","inertiaTranslate","inertiaZoom","maximumMovementRatio","bounceAnimationTime","minimumZoomDistance","maximumZoomDistance","Number","POSITIVE_INFINITY","translateEventTypes","LEFT_DRAG","zoomEventTypes","RIGHT_DRAG","WHEEL","PINCH","rotateEventTypes","tiltEventTypes","MIDDLE_DRAG","eventType","modifier","CTRL","lookEventTypes","SHIFT","minimumPickingTerrainHeight","_minimumPickingTerrainHeight","minimumCollisionTerrainHeight","_minimumCollisionTerrainHeight","minimumTrackBallHeight","_minimumTrackBallHeight","enableCollisionDetection","_scene","_globe","undefined","_ellipsoid","_aggregator","canvas","_lastInertiaSpinMovement","_lastInertiaZoomMovement","_lastInertiaTranslateMovement","_lastInertiaTiltMovement","_tweens","_tween","_horizontalRotationAxis","_tiltCenterMousePosition","_tiltCenter","_rotateMousePosition","_rotateStartPosition","_strafeStartPosition","_zoomMouseStart","_zoomWorldPosition","_useZoomWorldPosition","_tiltCVOffMap","_looking","_rotating","_strafing","_zoomingOnVector","_rotatingZoom","_adjustedHeightForTerrain","projection","mapProjection","_maxCoord","project","Math","PI","PI_OVER_TWO","_zoomFactor","_rotateFactor","_rotateRateRangeAdjustment","_maximumRotateRate","_minimumRotateRate","_minimumZoomRate","_maximumZoomRate","decay","time","coefficient","tau","exp","sameMousePosition","movement","equalsEpsilon","startPosition","endPosition","EPSILON14","inertiaMaxClickTimeThreshold","maintainInertia","aggregator","type","decayCoef","action","object","lastMovementName","movementState","motion","active","ts","getButtonPressTime","tr","getButtonReleaseTime","threshold","getTime","now","Date","fromNow","d","lastMovement","getLastMovement","x","y","clone","multiplyByScalar","add","ZERO","isNaN","distance","isButtonDown","getStartMousePosition","scratchEventTypeArray","reactToInput","controller","enabled","eventTypes","inertiaConstant","inertiaStateName","Array","isArray","length","i","isMoving","getMovement","scratchZoomPickRay","scratchPickCartesian","scratchZoomOffset","scratchZoomDirection","scratchCenterPixel","scratchCenterPosition","scratchPositionNormal","scratchPickNormal","scratchZoomAxis","scratchCameraPositionNormal","scratchTargetNormal","scratchCameraPosition","scratchCameraUpNormal","scratchCameraRightNormal","scratchForwardNormal","scratchPositionToTarget","scratchPositionToTargetNormal","scratchPan","scratchCenterMovement","scratchCenter","scratchCartesian","scratchCartesianTwo","scratchCartesianThree","scratchZoomViewOptions","orientation","handleZoom","zoomFactor","distanceMeasure","unitPositionDotDirection","percentage","clamp","abs","minHeight","maxHeight","minDistance","zoomRate","diff","rangeWindowRatio","clientHeight","min","camera","mode","heading","pitch","roll","frustum","zoomIn","_adjustOrthographicFrustum","sameStartPosition","equals","zoomingOnVector","rotatingZoom","pickedPosition","SCENE2D","getPickRay","origin","fromElements","z","pickGlobe","zoomOnVector","COLUMBUS_VIEW","positionCartographic","height","worldPosition","position","savedX","direction","subtract","normalize","getMagnitude","move","SCENE3D","cameraPositionNormal","dot","centerPixel","clientWidth","centerPosition","cameraPosition","target","targetNormal","center","forward","positionToTarget","positionToTargetNormal","alphaDot","alpha","acos","cameraDistance","magnitude","targetDistance","remainingDistance","positionToTargetDistance","gamma","asin","sin","delta","beta","up","right","cross","pMid","cos","cMid","setView","positionNormal","pickedNormal","dotProduct","angle","acosClamped","axis","denom","toRadians","scalar","rotate","ray","zoomMouseStart","wgs84ToWindowCoordinates","rayDirection","translate2DStart","translate2DEnd","scratchTranslateP0","translate2D","start","end","zoom2D","twist2DStart","twist2DEnd","twist2D","angleAndHeight","singleAxisTwist2D","width","startTheta","TWO_PI","endTheta","theta","twistRight","rotateRate","phiWindowRatio","deltaPhi","update2D","rotatable2D","mapMode2D","ROTATE","IDENTITY","transform","pickGlobeScratchRay","scratchDepthIntersection","scratchRayIntersection","mousePosition","result","globe","depthIntersection","pickPositionSupported","pickPositionWorldCoordinates","rayIntersection","pickWorldCoordinates","pickDistance","positionWC","rayDistance","translateCVStartRay","translateCVEndRay","translateCVStartPos","translateCVEndPos","translatCVDifference","translateCVOrigin","translateCVPlane","UNIT_X","translateCVStartMouse","translateCVEndMouse","translateCV","_translateMousePosition","_strafeMousePosition","look3D","strafe","startMouse","endMouse","startRay","normal","globePos","plane","fromPointNormal","startPlanePos","rayPlane","endRay","endPlanePos","temp","mag","EPSILON6","rotateCVWindowPos","rotateCVWindowRay","rotateCVCenter","rotateCVVerticalCenter","rotateCVTransform","rotateCVVerticalTransform","rotateCVOrigin","rotateCVPlane","rotateCVCartesian3","rotateCVCart","rotateCVOldTransform","rotateCVQuaternion","rotateCVMatrix","tilt3DCartesian3","rotateCV","onMap","rotateCVOnPlane","rotateCVOnTerrain","windowPosition","normalDotDirection","ellipsoid","cart","unproject","cartographicToCartesian","eastNorthUpToFixedFrame","oldGlobe","oldEllipsoid","UNIT_SPHERE","oldTransform","_setTransform","rotate3D","UNIT_Z","radius","maximumRadius","verticalCenter","_projection","verticalTransform","constrainedAxis","tangent","oldConstrainedAxis","negate","originalPosition","adjustHeightForTerrain","worldToCameraCoordinatesPoint","magSqrd","magnitudeSquared","sqrt","angleBetween","quaternion","fromAxisAngle","rotation","fromQuaternion","multiplyByVector","zoomCVWindowPos","zoomCVWindowRay","zoomCVIntersection","zoomCV","intersection","updateCV","zoom3D","tweens","anyButtonDown","removeAll","contains","tween","createCorrectPositionTween","update","scratchStrafeRay","scratchStrafePlane","scratchStrafeIntersection","scratchStrafeDirection","scratchMousePos","mouseStartPosition","spin3DPick","scratchCartographic","scratchRadii","scratchEllipsoid","scratchLookUp","spin3D","radii","geodeticSurfaceNormal","cartesianToCartographic","mousePos","tangentPick","fromCartesian3","pan3D","pickEllipsoid","rotateOnlyVertical","rotateOnlyHorizontal","oldAxis","rho","thetaWindowRatio","deltaTheta","rotateRight","rotateUp","pan3DP0","UNIT_W","pan3DP1","pan3DTemp0","pan3DTemp1","pan3DTemp2","pan3DTemp3","pan3DStartMousePosition","pan3DEndMousePosition","startMousePosition","endMousePosition","p0","p1","worldToCameraCoordinates","basis0","basis1","mostOrthogonalAxis","basis2","startRho","startDot","startRej","endRho","endDot","endRej","startPhi","endPhi","east","EPSILON2","planeNormal","side0","side1","zoom3DUnitPosition","zoom3DCartographic","unitPosition","tilt3DWindowPos","tilt3DRay","tilt3DCenter","tilt3DVerticalCenter","tilt3DTransform","tilt3DVerticalTransform","tilt3DOldTransform","tilt3DQuaternion","tilt3DMatrix","tilt3DCart","tilt3DLookUp","tilt3D","_tiltOnEllipsoid","cartographic","tilt3DOnEllipsoid","tilt3DOnTerrain","tilt3DOnEllipsoidCartographic","EPSILON3","rayEllipsoid","getPoint","grazingAltitudeLocation","grazingAltitudeCart","newEllipsoid","t","stop","rightWC","look3DStartPos","look3DEndPos","look3DStartRay","look3DEndRay","look3DNegativeRot","look3DTan","rotationAxis","startPos","endPos","horizontalRotationAxis","look","lookLeft","negativeRotationAxis","northParallel","southParallel","angleToAxis","EPSILON4","lookUp","update3D","scratchAdjustHeightTransform","scratchAdjustHeightCartographic","MORPHING","heightUpdated","getHeight","max","prototype","scratchPreviousPosition","scratchPreviousDirection","terrainExaggeration","previousPosition","previousDirection","directionWC","cameraChanged","reset","adjustedHeightForTerrain","isDestroyed","destroy"],"mappings":"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","sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport HeadingPitchRoll from \"../Core/HeadingPitchRoll.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport KeyboardEventModifier from \"../Core/KeyboardEventModifier.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport Plane from \"../Core/Plane.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport CameraEventAggregator from \"./CameraEventAggregator.js\";\nimport CameraEventType from \"./CameraEventType.js\";\nimport MapMode2D from \"./MapMode2D.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport SceneTransforms from \"./SceneTransforms.js\";\nimport TweenCollection from \"./TweenCollection.js\";\n\n/**\n * Modifies the camera position and orientation based on mouse input to a canvas.\n * @alias ScreenSpaceCameraController\n * @constructor\n *\n * @param {Scene} scene The scene.\n */\nfunction ScreenSpaceCameraController(scene) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * If true, inputs are allowed conditionally with the flags enableTranslate, enableZoom,\n   * enableRotate, enableTilt, and enableLook.  If false, all inputs are disabled.\n   *\n   * NOTE: This setting is for temporary use cases, such as camera flights and\n   * drag-selection of regions (see Picking demo).  It is typically set to false at the\n   * start of such events, and set true on completion.  To keep inputs disabled\n   * past the end of camera flights, you must use the other booleans (enableTranslate,\n   * enableZoom, enableRotate, enableTilt, and enableLook).\n   * @type {Boolean}\n   * @default true\n   */\n  this.enableInputs = true;\n  /**\n   * If true, allows the user to pan around the map.  If false, the camera stays locked at the current position.\n   * This flag only applies in 2D and Columbus view modes.\n   * @type {Boolean}\n   * @default true\n   */\n  this.enableTranslate = true;\n  /**\n   * If true, allows the user to zoom in and out.  If false, the camera is locked to the current distance from the ellipsoid.\n   * @type {Boolean}\n   * @default true\n   */\n  this.enableZoom = true;\n  /**\n   * If true, allows the user to rotate the world which translates the user's position.\n   * This flag only applies in 2D and 3D.\n   * @type {Boolean}\n   * @default true\n   */\n  this.enableRotate = true;\n  /**\n   * If true, allows the user to tilt the camera.  If false, the camera is locked to the current heading.\n   * This flag only applies in 3D and Columbus view.\n   * @type {Boolean}\n   * @default true\n   */\n  this.enableTilt = true;\n  /**\n   * If true, allows the user to use free-look. If false, the camera view direction can only be changed through translating\n   * or rotating. This flag only applies in 3D and Columbus view modes.\n   * @type {Boolean}\n   * @default true\n   */\n  this.enableLook = true;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to spin because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {Number}\n   * @default 0.9\n   */\n  this.inertiaSpin = 0.9;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to translate because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {Number}\n   * @default 0.9\n   */\n  this.inertiaTranslate = 0.9;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to zoom because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {Number}\n   * @default 0.8\n   */\n  this.inertiaZoom = 0.8;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to limit the range\n   * of various user inputs to a percentage of the window width/height per animation frame.\n   * This helps keep the camera under control in low-frame-rate situations.\n   * @type {Number}\n   * @default 0.1\n   */\n  this.maximumMovementRatio = 0.1;\n  /**\n   * Sets the duration, in seconds, of the bounce back animations in 2D and Columbus view.\n   * @type {Number}\n   * @default 3.0\n   */\n  this.bounceAnimationTime = 3.0;\n  /**\n   * The minimum magnitude, in meters, of the camera position when zooming. Defaults to 1.0.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.minimumZoomDistance = 1.0;\n  /**\n   * The maximum magnitude, in meters, of the camera position when zooming. Defaults to positive infinity.\n   * @type {Number}\n   * @default {@link Number.POSITIVE_INFINITY}\n   */\n  this.maximumZoomDistance = Number.POSITIVE_INFINITY;\n  /**\n   * The input that allows the user to pan around the map. This only applies in 2D and Columbus view modes.\n   * <p>\n   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default {@link CameraEventType.LEFT_DRAG}\n   */\n  this.translateEventTypes = CameraEventType.LEFT_DRAG;\n  /**\n   * The input that allows the user to zoom in/out.\n   * <p>\n   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default [{@link CameraEventType.RIGHT_DRAG}, {@link CameraEventType.WHEEL}, {@link CameraEventType.PINCH}]\n   */\n  this.zoomEventTypes = [\n    CameraEventType.RIGHT_DRAG,\n    CameraEventType.WHEEL,\n    CameraEventType.PINCH,\n  ];\n  /**\n   * The input that allows the user to rotate around the globe or another object. This only applies in 3D and Columbus view modes.\n   * <p>\n   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default {@link CameraEventType.LEFT_DRAG}\n   */\n  this.rotateEventTypes = CameraEventType.LEFT_DRAG;\n  /**\n   * The input that allows the user to tilt in 3D and Columbus view or twist in 2D.\n   * <p>\n   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default [{@link CameraEventType.MIDDLE_DRAG}, {@link CameraEventType.PINCH}, {\n   *     eventType : {@link CameraEventType.LEFT_DRAG},\n   *     modifier : {@link KeyboardEventModifier.CTRL}\n   * }, {\n   *     eventType : {@link CameraEventType.RIGHT_DRAG},\n   *     modifier : {@link KeyboardEventModifier.CTRL}\n   * }]\n   */\n  this.tiltEventTypes = [\n    CameraEventType.MIDDLE_DRAG,\n    CameraEventType.PINCH,\n    {\n      eventType: CameraEventType.LEFT_DRAG,\n      modifier: KeyboardEventModifier.CTRL,\n    },\n    {\n      eventType: CameraEventType.RIGHT_DRAG,\n      modifier: KeyboardEventModifier.CTRL,\n    },\n  ];\n  /**\n   * The input that allows the user to change the direction the camera is viewing. This only applies in 3D and Columbus view modes.\n   * <p>\n   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default { eventType : {@link CameraEventType.LEFT_DRAG}, modifier : {@link KeyboardEventModifier.SHIFT} }\n   */\n  this.lookEventTypes = {\n    eventType: CameraEventType.LEFT_DRAG,\n    modifier: KeyboardEventModifier.SHIFT,\n  };\n  /**\n   * The minimum height the camera must be before picking the terrain instead of the ellipsoid.\n   * @type {Number}\n   * @default 150000.0\n   */\n  this.minimumPickingTerrainHeight = 150000.0;\n  this._minimumPickingTerrainHeight = this.minimumPickingTerrainHeight;\n  /**\n   * The minimum height the camera must be before testing for collision with terrain.\n   * @type {Number}\n   * @default 15000.0\n   */\n  this.minimumCollisionTerrainHeight = 15000.0;\n  this._minimumCollisionTerrainHeight = this.minimumCollisionTerrainHeight;\n  /**\n   * The minimum height the camera must be before switching from rotating a track ball to\n   * free look when clicks originate on the sky on in space.\n   * @type {Number}\n   * @default 7500000.0\n   */\n  this.minimumTrackBallHeight = 7500000.0;\n  this._minimumTrackBallHeight = this.minimumTrackBallHeight;\n  /**\n   * Enables or disables camera collision detection with terrain.\n   * @type {Boolean}\n   * @default true\n   */\n  this.enableCollisionDetection = true;\n\n  this._scene = scene;\n  this._globe = undefined;\n  this._ellipsoid = undefined;\n\n  this._aggregator = new CameraEventAggregator(scene.canvas);\n\n  this._lastInertiaSpinMovement = undefined;\n  this._lastInertiaZoomMovement = undefined;\n  this._lastInertiaTranslateMovement = undefined;\n  this._lastInertiaTiltMovement = undefined;\n\n  this._tweens = new TweenCollection();\n  this._tween = undefined;\n\n  this._horizontalRotationAxis = undefined;\n\n  this._tiltCenterMousePosition = new Cartesian2(-1.0, -1.0);\n  this._tiltCenter = new Cartesian3();\n  this._rotateMousePosition = new Cartesian2(-1.0, -1.0);\n  this._rotateStartPosition = new Cartesian3();\n  this._strafeStartPosition = new Cartesian3();\n  this._zoomMouseStart = new Cartesian2(-1.0, -1.0);\n  this._zoomWorldPosition = new Cartesian3();\n  this._useZoomWorldPosition = false;\n  this._tiltCVOffMap = false;\n  this._looking = false;\n  this._rotating = false;\n  this._strafing = false;\n  this._zoomingOnVector = false;\n  this._rotatingZoom = false;\n  this._adjustedHeightForTerrain = false;\n\n  var projection = scene.mapProjection;\n  this._maxCoord = projection.project(\n    new Cartographic(Math.PI, CesiumMath.PI_OVER_TWO)\n  );\n\n  // Constants, Make any of these public?\n  this._zoomFactor = 5.0;\n  this._rotateFactor = undefined;\n  this._rotateRateRangeAdjustment = undefined;\n  this._maximumRotateRate = 1.77;\n  this._minimumRotateRate = 1.0 / 5000.0;\n  this._minimumZoomRate = 20.0;\n  this._maximumZoomRate = 5906376272000.0; // distance from the Sun to Pluto in meters.\n}\n\nfunction decay(time, coefficient) {\n  if (time < 0) {\n    return 0.0;\n  }\n\n  var tau = (1.0 - coefficient) * 25.0;\n  return Math.exp(-tau * time);\n}\n\nfunction sameMousePosition(movement) {\n  return Cartesian2.equalsEpsilon(\n    movement.startPosition,\n    movement.endPosition,\n    CesiumMath.EPSILON14\n  );\n}\n\n// If the time between mouse down and mouse up is not between\n// these thresholds, the camera will not move with inertia.\n// This value is probably dependent on the browser and/or the\n// hardware. Should be investigated further.\nvar inertiaMaxClickTimeThreshold = 0.4;\n\nfunction maintainInertia(\n  aggregator,\n  type,\n  modifier,\n  decayCoef,\n  action,\n  object,\n  lastMovementName\n) {\n  var movementState = object[lastMovementName];\n  if (!defined(movementState)) {\n    movementState = object[lastMovementName] = {\n      startPosition: new Cartesian2(),\n      endPosition: new Cartesian2(),\n      motion: new Cartesian2(),\n      active: false,\n    };\n  }\n\n  var ts = aggregator.getButtonPressTime(type, modifier);\n  var tr = aggregator.getButtonReleaseTime(type, modifier);\n\n  var threshold = ts && tr && (tr.getTime() - ts.getTime()) / 1000.0;\n  var now = new Date();\n  var fromNow = tr && (now.getTime() - tr.getTime()) / 1000.0;\n\n  if (ts && tr && threshold < inertiaMaxClickTimeThreshold) {\n    var d = decay(fromNow, decayCoef);\n\n    if (!movementState.active) {\n      var lastMovement = aggregator.getLastMovement(type, modifier);\n      if (!defined(lastMovement) || sameMousePosition(lastMovement)) {\n        return;\n      }\n\n      movementState.motion.x =\n        (lastMovement.endPosition.x - lastMovement.startPosition.x) * 0.5;\n      movementState.motion.y =\n        (lastMovement.endPosition.y - lastMovement.startPosition.y) * 0.5;\n\n      movementState.startPosition = Cartesian2.clone(\n        lastMovement.startPosition,\n        movementState.startPosition\n      );\n\n      movementState.endPosition = Cartesian2.multiplyByScalar(\n        movementState.motion,\n        d,\n        movementState.endPosition\n      );\n      movementState.endPosition = Cartesian2.add(\n        movementState.startPosition,\n        movementState.endPosition,\n        movementState.endPosition\n      );\n\n      movementState.active = true;\n    } else {\n      movementState.startPosition = Cartesian2.clone(\n        movementState.endPosition,\n        movementState.startPosition\n      );\n\n      movementState.endPosition = Cartesian2.multiplyByScalar(\n        movementState.motion,\n        d,\n        movementState.endPosition\n      );\n      movementState.endPosition = Cartesian2.add(\n        movementState.startPosition,\n        movementState.endPosition,\n        movementState.endPosition\n      );\n\n      movementState.motion = Cartesian2.clone(\n        Cartesian2.ZERO,\n        movementState.motion\n      );\n    }\n\n    // If value from the decreasing exponential function is close to zero,\n    // the end coordinates may be NaN.\n    if (\n      isNaN(movementState.endPosition.x) ||\n      isNaN(movementState.endPosition.y) ||\n      Cartesian2.distance(\n        movementState.startPosition,\n        movementState.endPosition\n      ) < 0.5\n    ) {\n      movementState.active = false;\n      return;\n    }\n\n    if (!aggregator.isButtonDown(type, modifier)) {\n      var startPosition = aggregator.getStartMousePosition(type, modifier);\n      action(object, startPosition, movementState);\n    }\n  } else {\n    movementState.active = false;\n  }\n}\n\nvar scratchEventTypeArray = [];\n\nfunction reactToInput(\n  controller,\n  enabled,\n  eventTypes,\n  action,\n  inertiaConstant,\n  inertiaStateName\n) {\n  if (!defined(eventTypes)) {\n    return;\n  }\n\n  var aggregator = controller._aggregator;\n\n  if (!Array.isArray(eventTypes)) {\n    scratchEventTypeArray[0] = eventTypes;\n    eventTypes = scratchEventTypeArray;\n  }\n\n  var length = eventTypes.length;\n  for (var i = 0; i < length; ++i) {\n    var eventType = eventTypes[i];\n    var type = defined(eventType.eventType) ? eventType.eventType : eventType;\n    var modifier = eventType.modifier;\n\n    var movement =\n      aggregator.isMoving(type, modifier) &&\n      aggregator.getMovement(type, modifier);\n    var startPosition = aggregator.getStartMousePosition(type, modifier);\n\n    if (controller.enableInputs && enabled) {\n      if (movement) {\n        action(controller, startPosition, movement);\n      } else if (inertiaConstant < 1.0) {\n        maintainInertia(\n          aggregator,\n          type,\n          modifier,\n          inertiaConstant,\n          action,\n          controller,\n          inertiaStateName\n        );\n      }\n    }\n  }\n}\n\nvar scratchZoomPickRay = new Ray();\nvar scratchPickCartesian = new Cartesian3();\nvar scratchZoomOffset = new Cartesian2();\nvar scratchZoomDirection = new Cartesian3();\nvar scratchCenterPixel = new Cartesian2();\nvar scratchCenterPosition = new Cartesian3();\nvar scratchPositionNormal = new Cartesian3();\nvar scratchPickNormal = new Cartesian3();\nvar scratchZoomAxis = new Cartesian3();\nvar scratchCameraPositionNormal = new Cartesian3();\n\n// Scratch variables used in zooming algorithm\nvar scratchTargetNormal = new Cartesian3();\nvar scratchCameraPosition = new Cartesian3();\nvar scratchCameraUpNormal = new Cartesian3();\nvar scratchCameraRightNormal = new Cartesian3();\nvar scratchForwardNormal = new Cartesian3();\nvar scratchPositionToTarget = new Cartesian3();\nvar scratchPositionToTargetNormal = new Cartesian3();\nvar scratchPan = new Cartesian3();\nvar scratchCenterMovement = new Cartesian3();\nvar scratchCenter = new Cartesian3();\nvar scratchCartesian = new Cartesian3();\nvar scratchCartesianTwo = new Cartesian3();\nvar scratchCartesianThree = new Cartesian3();\nvar scratchZoomViewOptions = {\n  orientation: new HeadingPitchRoll(),\n};\n\nfunction handleZoom(\n  object,\n  startPosition,\n  movement,\n  zoomFactor,\n  distanceMeasure,\n  unitPositionDotDirection\n) {\n  var percentage = 1.0;\n  if (defined(unitPositionDotDirection)) {\n    percentage = CesiumMath.clamp(\n      Math.abs(unitPositionDotDirection),\n      0.25,\n      1.0\n    );\n  }\n\n  // distanceMeasure should be the height above the ellipsoid.\n  // The zoomRate slows as it approaches the surface and stops minimumZoomDistance above it.\n  var minHeight = object.minimumZoomDistance * percentage;\n  var maxHeight = object.maximumZoomDistance;\n\n  var minDistance = distanceMeasure - minHeight;\n  var zoomRate = zoomFactor * minDistance;\n  zoomRate = CesiumMath.clamp(\n    zoomRate,\n    object._minimumZoomRate,\n    object._maximumZoomRate\n  );\n\n  var diff = movement.endPosition.y - movement.startPosition.y;\n  var rangeWindowRatio = diff / object._scene.canvas.clientHeight;\n  rangeWindowRatio = Math.min(rangeWindowRatio, object.maximumMovementRatio);\n  var distance = zoomRate * rangeWindowRatio;\n\n  if (distance > 0.0 && Math.abs(distanceMeasure - minHeight) < 1.0) {\n    return;\n  }\n\n  if (distance < 0.0 && Math.abs(distanceMeasure - maxHeight) < 1.0) {\n    return;\n  }\n\n  if (distanceMeasure - distance < minHeight) {\n    distance = distanceMeasure - minHeight - 1.0;\n  } else if (distanceMeasure - distance > maxHeight) {\n    distance = distanceMeasure - maxHeight;\n  }\n\n  var scene = object._scene;\n  var camera = scene.camera;\n  var mode = scene.mode;\n\n  var orientation = scratchZoomViewOptions.orientation;\n  orientation.heading = camera.heading;\n  orientation.pitch = camera.pitch;\n  orientation.roll = camera.roll;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    if (Math.abs(distance) > 0.0) {\n      camera.zoomIn(distance);\n      camera._adjustOrthographicFrustum();\n    }\n    return;\n  }\n\n  var sameStartPosition = Cartesian2.equals(\n    startPosition,\n    object._zoomMouseStart\n  );\n  var zoomingOnVector = object._zoomingOnVector;\n  var rotatingZoom = object._rotatingZoom;\n  var pickedPosition;\n\n  if (!sameStartPosition) {\n    object._zoomMouseStart = Cartesian2.clone(\n      startPosition,\n      object._zoomMouseStart\n    );\n\n    if (defined(object._globe)) {\n      if (mode === SceneMode.SCENE2D) {\n        pickedPosition = camera.getPickRay(startPosition, scratchZoomPickRay)\n          .origin;\n        pickedPosition = Cartesian3.fromElements(\n          pickedPosition.y,\n          pickedPosition.z,\n          pickedPosition.x\n        );\n      } else {\n        pickedPosition = pickGlobe(object, startPosition, scratchPickCartesian);\n      }\n    }\n    if (defined(pickedPosition)) {\n      object._useZoomWorldPosition = true;\n      object._zoomWorldPosition = Cartesian3.clone(\n        pickedPosition,\n        object._zoomWorldPosition\n      );\n    } else {\n      object._useZoomWorldPosition = false;\n    }\n\n    zoomingOnVector = object._zoomingOnVector = false;\n    rotatingZoom = object._rotatingZoom = false;\n  }\n\n  if (!object._useZoomWorldPosition) {\n    camera.zoomIn(distance);\n    return;\n  }\n\n  var zoomOnVector = mode === SceneMode.COLUMBUS_VIEW;\n\n  if (camera.positionCartographic.height < 2000000) {\n    rotatingZoom = true;\n  }\n\n  if (!sameStartPosition || rotatingZoom) {\n    if (mode === SceneMode.SCENE2D) {\n      var worldPosition = object._zoomWorldPosition;\n      var endPosition = camera.position;\n\n      if (\n        !Cartesian3.equals(worldPosition, endPosition) &&\n        camera.positionCartographic.height < object._maxCoord.x * 2.0\n      ) {\n        var savedX = camera.position.x;\n\n        var direction = Cartesian3.subtract(\n          worldPosition,\n          endPosition,\n          scratchZoomDirection\n        );\n        Cartesian3.normalize(direction, direction);\n\n        var d =\n          (Cartesian3.distance(worldPosition, endPosition) * distance) /\n          (camera.getMagnitude() * 0.5);\n        camera.move(direction, d * 0.5);\n\n        if (\n          (camera.position.x < 0.0 && savedX > 0.0) ||\n          (camera.position.x > 0.0 && savedX < 0.0)\n        ) {\n          pickedPosition = camera.getPickRay(startPosition, scratchZoomPickRay)\n            .origin;\n          pickedPosition = Cartesian3.fromElements(\n            pickedPosition.y,\n            pickedPosition.z,\n            pickedPosition.x\n          );\n          object._zoomWorldPosition = Cartesian3.clone(\n            pickedPosition,\n            object._zoomWorldPosition\n          );\n        }\n      }\n    } else if (mode === SceneMode.SCENE3D) {\n      var cameraPositionNormal = Cartesian3.normalize(\n        camera.position,\n        scratchCameraPositionNormal\n      );\n      if (\n        camera.positionCartographic.height < 3000.0 &&\n        Math.abs(Cartesian3.dot(camera.direction, cameraPositionNormal)) < 0.6\n      ) {\n        zoomOnVector = true;\n      } else {\n        var canvas = scene.canvas;\n\n        var centerPixel = scratchCenterPixel;\n        centerPixel.x = canvas.clientWidth / 2;\n        centerPixel.y = canvas.clientHeight / 2;\n        var centerPosition = pickGlobe(\n          object,\n          centerPixel,\n          scratchCenterPosition\n        );\n        // If centerPosition is not defined, it means the globe does not cover the center position of screen\n\n        if (\n          defined(centerPosition) &&\n          camera.positionCartographic.height < 1000000\n        ) {\n          var cameraPosition = scratchCameraPosition;\n          Cartesian3.clone(camera.position, cameraPosition);\n          var target = object._zoomWorldPosition;\n\n          var targetNormal = scratchTargetNormal;\n\n          targetNormal = Cartesian3.normalize(target, targetNormal);\n\n          if (Cartesian3.dot(targetNormal, cameraPositionNormal) < 0.0) {\n            return;\n          }\n\n          var center = scratchCenter;\n          var forward = scratchForwardNormal;\n          Cartesian3.clone(camera.direction, forward);\n          Cartesian3.add(\n            cameraPosition,\n            Cartesian3.multiplyByScalar(forward, 1000, scratchCartesian),\n            center\n          );\n\n          var positionToTarget = scratchPositionToTarget;\n          var positionToTargetNormal = scratchPositionToTargetNormal;\n          Cartesian3.subtract(target, cameraPosition, positionToTarget);\n\n          Cartesian3.normalize(positionToTarget, positionToTargetNormal);\n\n          var alphaDot = Cartesian3.dot(\n            cameraPositionNormal,\n            positionToTargetNormal\n          );\n          if (alphaDot >= 0.0) {\n            // We zoomed past the target, and this zoom is not valid anymore.\n            // This line causes the next zoom movement to pick a new starting point.\n            object._zoomMouseStart.x = -1;\n            return;\n          }\n          var alpha = Math.acos(-alphaDot);\n          var cameraDistance = Cartesian3.magnitude(cameraPosition);\n          var targetDistance = Cartesian3.magnitude(target);\n          var remainingDistance = cameraDistance - distance;\n          var positionToTargetDistance = Cartesian3.magnitude(positionToTarget);\n\n          var gamma = Math.asin(\n            CesiumMath.clamp(\n              (positionToTargetDistance / targetDistance) * Math.sin(alpha),\n              -1.0,\n              1.0\n            )\n          );\n          var delta = Math.asin(\n            CesiumMath.clamp(\n              (remainingDistance / targetDistance) * Math.sin(alpha),\n              -1.0,\n              1.0\n            )\n          );\n          var beta = gamma - delta + alpha;\n\n          var up = scratchCameraUpNormal;\n          Cartesian3.normalize(cameraPosition, up);\n          var right = scratchCameraRightNormal;\n          right = Cartesian3.cross(positionToTargetNormal, up, right);\n          right = Cartesian3.normalize(right, right);\n\n          Cartesian3.normalize(\n            Cartesian3.cross(up, right, scratchCartesian),\n            forward\n          );\n\n          // Calculate new position to move to\n          Cartesian3.multiplyByScalar(\n            Cartesian3.normalize(center, scratchCartesian),\n            Cartesian3.magnitude(center) - distance,\n            center\n          );\n          Cartesian3.normalize(cameraPosition, cameraPosition);\n          Cartesian3.multiplyByScalar(\n            cameraPosition,\n            remainingDistance,\n            cameraPosition\n          );\n\n          // Pan\n          var pMid = scratchPan;\n          Cartesian3.multiplyByScalar(\n            Cartesian3.add(\n              Cartesian3.multiplyByScalar(\n                up,\n                Math.cos(beta) - 1,\n                scratchCartesianTwo\n              ),\n              Cartesian3.multiplyByScalar(\n                forward,\n                Math.sin(beta),\n                scratchCartesianThree\n              ),\n              scratchCartesian\n            ),\n            remainingDistance,\n            pMid\n          );\n          Cartesian3.add(cameraPosition, pMid, cameraPosition);\n\n          Cartesian3.normalize(center, up);\n          Cartesian3.normalize(\n            Cartesian3.cross(up, right, scratchCartesian),\n            forward\n          );\n\n          var cMid = scratchCenterMovement;\n          Cartesian3.multiplyByScalar(\n            Cartesian3.add(\n              Cartesian3.multiplyByScalar(\n                up,\n                Math.cos(beta) - 1,\n                scratchCartesianTwo\n              ),\n              Cartesian3.multiplyByScalar(\n                forward,\n                Math.sin(beta),\n                scratchCartesianThree\n              ),\n              scratchCartesian\n            ),\n            Cartesian3.magnitude(center),\n            cMid\n          );\n          Cartesian3.add(center, cMid, center);\n\n          // Update camera\n\n          // Set new position\n          Cartesian3.clone(cameraPosition, camera.position);\n\n          // Set new direction\n          Cartesian3.normalize(\n            Cartesian3.subtract(center, cameraPosition, scratchCartesian),\n            camera.direction\n          );\n          Cartesian3.clone(camera.direction, camera.direction);\n\n          // Set new right & up vectors\n          Cartesian3.cross(camera.direction, camera.up, camera.right);\n          Cartesian3.cross(camera.right, camera.direction, camera.up);\n\n          camera.setView(scratchZoomViewOptions);\n          return;\n        }\n\n        if (defined(centerPosition)) {\n          var positionNormal = Cartesian3.normalize(\n            centerPosition,\n            scratchPositionNormal\n          );\n          var pickedNormal = Cartesian3.normalize(\n            object._zoomWorldPosition,\n            scratchPickNormal\n          );\n          var dotProduct = Cartesian3.dot(pickedNormal, positionNormal);\n\n          if (dotProduct > 0.0 && dotProduct < 1.0) {\n            var angle = CesiumMath.acosClamped(dotProduct);\n            var axis = Cartesian3.cross(\n              pickedNormal,\n              positionNormal,\n              scratchZoomAxis\n            );\n\n            var denom =\n              Math.abs(angle) > CesiumMath.toRadians(20.0)\n                ? camera.positionCartographic.height * 0.75\n                : camera.positionCartographic.height - distance;\n            var scalar = distance / denom;\n            camera.rotate(axis, angle * scalar);\n          }\n        } else {\n          zoomOnVector = true;\n        }\n      }\n    }\n\n    object._rotatingZoom = !zoomOnVector;\n  }\n\n  if ((!sameStartPosition && zoomOnVector) || zoomingOnVector) {\n    var ray;\n    var zoomMouseStart = SceneTransforms.wgs84ToWindowCoordinates(\n      scene,\n      object._zoomWorldPosition,\n      scratchZoomOffset\n    );\n    if (\n      mode !== SceneMode.COLUMBUS_VIEW &&\n      Cartesian2.equals(startPosition, object._zoomMouseStart) &&\n      defined(zoomMouseStart)\n    ) {\n      ray = camera.getPickRay(zoomMouseStart, scratchZoomPickRay);\n    } else {\n      ray = camera.getPickRay(startPosition, scratchZoomPickRay);\n    }\n\n    var rayDirection = ray.direction;\n    if (mode === SceneMode.COLUMBUS_VIEW || mode === SceneMode.SCENE2D) {\n      Cartesian3.fromElements(\n        rayDirection.y,\n        rayDirection.z,\n        rayDirection.x,\n        rayDirection\n      );\n    }\n\n    camera.move(rayDirection, distance);\n\n    object._zoomingOnVector = true;\n  } else {\n    camera.zoomIn(distance);\n  }\n\n  camera.setView(scratchZoomViewOptions);\n}\n\nvar translate2DStart = new Ray();\nvar translate2DEnd = new Ray();\nvar scratchTranslateP0 = new Cartesian3();\n\nfunction translate2D(controller, startPosition, movement) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var start = camera.getPickRay(movement.startPosition, translate2DStart)\n    .origin;\n  var end = camera.getPickRay(movement.endPosition, translate2DEnd).origin;\n\n  start = Cartesian3.fromElements(start.y, start.z, start.x, start);\n  end = Cartesian3.fromElements(end.y, end.z, end.x, end);\n\n  var direction = Cartesian3.subtract(start, end, scratchTranslateP0);\n  var distance = Cartesian3.magnitude(direction);\n\n  if (distance > 0.0) {\n    Cartesian3.normalize(direction, direction);\n    camera.move(direction, distance);\n  }\n}\n\nfunction zoom2D(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n\n  var scene = controller._scene;\n  var camera = scene.camera;\n\n  handleZoom(\n    controller,\n    startPosition,\n    movement,\n    controller._zoomFactor,\n    camera.getMagnitude()\n  );\n}\n\nvar twist2DStart = new Cartesian2();\nvar twist2DEnd = new Cartesian2();\n\nfunction twist2D(controller, startPosition, movement) {\n  if (defined(movement.angleAndHeight)) {\n    singleAxisTwist2D(controller, startPosition, movement.angleAndHeight);\n    return;\n  }\n\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var canvas = scene.canvas;\n  var width = canvas.clientWidth;\n  var height = canvas.clientHeight;\n\n  var start = twist2DStart;\n  start.x = (2.0 / width) * movement.startPosition.x - 1.0;\n  start.y = (2.0 / height) * (height - movement.startPosition.y) - 1.0;\n  start = Cartesian2.normalize(start, start);\n\n  var end = twist2DEnd;\n  end.x = (2.0 / width) * movement.endPosition.x - 1.0;\n  end.y = (2.0 / height) * (height - movement.endPosition.y) - 1.0;\n  end = Cartesian2.normalize(end, end);\n\n  var startTheta = CesiumMath.acosClamped(start.x);\n  if (start.y < 0) {\n    startTheta = CesiumMath.TWO_PI - startTheta;\n  }\n  var endTheta = CesiumMath.acosClamped(end.x);\n  if (end.y < 0) {\n    endTheta = CesiumMath.TWO_PI - endTheta;\n  }\n  var theta = endTheta - startTheta;\n\n  camera.twistRight(theta);\n}\n\nfunction singleAxisTwist2D(controller, startPosition, movement) {\n  var rotateRate =\n    controller._rotateFactor * controller._rotateRateRangeAdjustment;\n\n  if (rotateRate > controller._maximumRotateRate) {\n    rotateRate = controller._maximumRotateRate;\n  }\n\n  if (rotateRate < controller._minimumRotateRate) {\n    rotateRate = controller._minimumRotateRate;\n  }\n\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var canvas = scene.canvas;\n\n  var phiWindowRatio =\n    (movement.endPosition.x - movement.startPosition.x) / canvas.clientWidth;\n  phiWindowRatio = Math.min(phiWindowRatio, controller.maximumMovementRatio);\n\n  var deltaPhi = rotateRate * phiWindowRatio * Math.PI * 4.0;\n\n  camera.twistRight(deltaPhi);\n}\n\nfunction update2D(controller) {\n  var rotatable2D = controller._scene.mapMode2D === MapMode2D.ROTATE;\n  if (!Matrix4.equals(Matrix4.IDENTITY, controller._scene.camera.transform)) {\n    reactToInput(\n      controller,\n      controller.enableZoom,\n      controller.zoomEventTypes,\n      zoom2D,\n      controller.inertiaZoom,\n      \"_lastInertiaZoomMovement\"\n    );\n    if (rotatable2D) {\n      reactToInput(\n        controller,\n        controller.enableRotate,\n        controller.translateEventTypes,\n        twist2D,\n        controller.inertiaSpin,\n        \"_lastInertiaSpinMovement\"\n      );\n    }\n  } else {\n    reactToInput(\n      controller,\n      controller.enableTranslate,\n      controller.translateEventTypes,\n      translate2D,\n      controller.inertiaTranslate,\n      \"_lastInertiaTranslateMovement\"\n    );\n    reactToInput(\n      controller,\n      controller.enableZoom,\n      controller.zoomEventTypes,\n      zoom2D,\n      controller.inertiaZoom,\n      \"_lastInertiaZoomMovement\"\n    );\n    if (rotatable2D) {\n      reactToInput(\n        controller,\n        controller.enableRotate,\n        controller.tiltEventTypes,\n        twist2D,\n        controller.inertiaSpin,\n        \"_lastInertiaTiltMovement\"\n      );\n    }\n  }\n}\n\nvar pickGlobeScratchRay = new Ray();\nvar scratchDepthIntersection = new Cartesian3();\nvar scratchRayIntersection = new Cartesian3();\n\nfunction pickGlobe(controller, mousePosition, result) {\n  var scene = controller._scene;\n  var globe = controller._globe;\n  var camera = scene.camera;\n\n  if (!defined(globe)) {\n    return undefined;\n  }\n\n  var depthIntersection;\n  if (scene.pickPositionSupported) {\n    depthIntersection = scene.pickPositionWorldCoordinates(\n      mousePosition,\n      scratchDepthIntersection\n    );\n  }\n\n  var ray = camera.getPickRay(mousePosition, pickGlobeScratchRay);\n  var rayIntersection = globe.pickWorldCoordinates(\n    ray,\n    scene,\n    scratchRayIntersection\n  );\n\n  var pickDistance = defined(depthIntersection)\n    ? Cartesian3.distance(depthIntersection, camera.positionWC)\n    : Number.POSITIVE_INFINITY;\n  var rayDistance = defined(rayIntersection)\n    ? Cartesian3.distance(rayIntersection, camera.positionWC)\n    : Number.POSITIVE_INFINITY;\n\n  if (pickDistance < rayDistance) {\n    return Cartesian3.clone(depthIntersection, result);\n  }\n\n  return Cartesian3.clone(rayIntersection, result);\n}\n\nvar translateCVStartRay = new Ray();\nvar translateCVEndRay = new Ray();\nvar translateCVStartPos = new Cartesian3();\nvar translateCVEndPos = new Cartesian3();\nvar translatCVDifference = new Cartesian3();\nvar translateCVOrigin = new Cartesian3();\nvar translateCVPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nvar translateCVStartMouse = new Cartesian2();\nvar translateCVEndMouse = new Cartesian2();\n\nfunction translateCV(controller, startPosition, movement) {\n  if (!Cartesian3.equals(startPosition, controller._translateMousePosition)) {\n    controller._looking = false;\n  }\n\n  if (!Cartesian3.equals(startPosition, controller._strafeMousePosition)) {\n    controller._strafing = false;\n  }\n\n  if (controller._looking) {\n    look3D(controller, startPosition, movement);\n    return;\n  }\n\n  if (controller._strafing) {\n    strafe(controller, startPosition, movement);\n    return;\n  }\n\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var startMouse = Cartesian2.clone(\n    movement.startPosition,\n    translateCVStartMouse\n  );\n  var endMouse = Cartesian2.clone(movement.endPosition, translateCVEndMouse);\n  var startRay = camera.getPickRay(startMouse, translateCVStartRay);\n\n  var origin = Cartesian3.clone(Cartesian3.ZERO, translateCVOrigin);\n  var normal = Cartesian3.UNIT_X;\n\n  var globePos;\n  if (camera.position.z < controller._minimumPickingTerrainHeight) {\n    globePos = pickGlobe(controller, startMouse, translateCVStartPos);\n    if (defined(globePos)) {\n      origin.x = globePos.x;\n    }\n  }\n\n  if (origin.x > camera.position.z && defined(globePos)) {\n    Cartesian3.clone(globePos, controller._strafeStartPosition);\n    controller._strafing = true;\n    strafe(controller, startPosition, movement);\n    controller._strafeMousePosition = Cartesian2.clone(\n      startPosition,\n      controller._strafeMousePosition\n    );\n    return;\n  }\n\n  var plane = Plane.fromPointNormal(origin, normal, translateCVPlane);\n\n  startRay = camera.getPickRay(startMouse, translateCVStartRay);\n  var startPlanePos = IntersectionTests.rayPlane(\n    startRay,\n    plane,\n    translateCVStartPos\n  );\n\n  var endRay = camera.getPickRay(endMouse, translateCVEndRay);\n  var endPlanePos = IntersectionTests.rayPlane(\n    endRay,\n    plane,\n    translateCVEndPos\n  );\n\n  if (!defined(startPlanePos) || !defined(endPlanePos)) {\n    controller._looking = true;\n    look3D(controller, startPosition, movement);\n    Cartesian2.clone(startPosition, controller._translateMousePosition);\n    return;\n  }\n\n  var diff = Cartesian3.subtract(\n    startPlanePos,\n    endPlanePos,\n    translatCVDifference\n  );\n  var temp = diff.x;\n  diff.x = diff.y;\n  diff.y = diff.z;\n  diff.z = temp;\n  var mag = Cartesian3.magnitude(diff);\n  if (mag > CesiumMath.EPSILON6) {\n    Cartesian3.normalize(diff, diff);\n    camera.move(diff, mag);\n  }\n}\n\nvar rotateCVWindowPos = new Cartesian2();\nvar rotateCVWindowRay = new Ray();\nvar rotateCVCenter = new Cartesian3();\nvar rotateCVVerticalCenter = new Cartesian3();\nvar rotateCVTransform = new Matrix4();\nvar rotateCVVerticalTransform = new Matrix4();\nvar rotateCVOrigin = new Cartesian3();\nvar rotateCVPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nvar rotateCVCartesian3 = new Cartesian3();\nvar rotateCVCart = new Cartographic();\nvar rotateCVOldTransform = new Matrix4();\nvar rotateCVQuaternion = new Quaternion();\nvar rotateCVMatrix = new Matrix3();\nvar tilt3DCartesian3 = new Cartesian3();\n\nfunction rotateCV(controller, startPosition, movement) {\n  if (defined(movement.angleAndHeight)) {\n    movement = movement.angleAndHeight;\n  }\n\n  if (!Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    controller._tiltCVOffMap = false;\n    controller._looking = false;\n  }\n\n  if (controller._looking) {\n    look3D(controller, startPosition, movement);\n    return;\n  }\n\n  var scene = controller._scene;\n  var camera = scene.camera;\n\n  if (\n    controller._tiltCVOffMap ||\n    !controller.onMap() ||\n    camera.position.z > controller._minimumPickingTerrainHeight\n  ) {\n    controller._tiltCVOffMap = true;\n    rotateCVOnPlane(controller, startPosition, movement);\n  } else {\n    rotateCVOnTerrain(controller, startPosition, movement);\n  }\n}\n\nfunction rotateCVOnPlane(controller, startPosition, movement) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var canvas = scene.canvas;\n\n  var windowPosition = rotateCVWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = canvas.clientHeight / 2;\n  var ray = camera.getPickRay(windowPosition, rotateCVWindowRay);\n  var normal = Cartesian3.UNIT_X;\n\n  var position = ray.origin;\n  var direction = ray.direction;\n  var scalar;\n  var normalDotDirection = Cartesian3.dot(normal, direction);\n  if (Math.abs(normalDotDirection) > CesiumMath.EPSILON6) {\n    scalar = -Cartesian3.dot(normal, position) / normalDotDirection;\n  }\n\n  if (!defined(scalar) || scalar <= 0.0) {\n    controller._looking = true;\n    look3D(controller, startPosition, movement);\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    return;\n  }\n\n  var center = Cartesian3.multiplyByScalar(direction, scalar, rotateCVCenter);\n  Cartesian3.add(position, center, center);\n\n  var projection = scene.mapProjection;\n  var ellipsoid = projection.ellipsoid;\n\n  Cartesian3.fromElements(center.y, center.z, center.x, center);\n  var cart = projection.unproject(center, rotateCVCart);\n  ellipsoid.cartographicToCartesian(cart, center);\n\n  var transform = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    rotateCVTransform\n  );\n\n  var oldGlobe = controller._globe;\n  var oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n\n  var oldTransform = Matrix4.clone(camera.transform, rotateCVOldTransform);\n  camera._setTransform(transform);\n\n  rotate3D(controller, startPosition, movement, Cartesian3.UNIT_Z);\n\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n\n  var radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n}\n\nfunction rotateCVOnTerrain(controller, startPosition, movement) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n\n  var center;\n  var ray;\n  var normal = Cartesian3.UNIT_X;\n\n  if (Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    center = Cartesian3.clone(controller._tiltCenter, rotateCVCenter);\n  } else {\n    if (camera.position.z < controller._minimumPickingTerrainHeight) {\n      center = pickGlobe(controller, startPosition, rotateCVCenter);\n    }\n\n    if (!defined(center)) {\n      ray = camera.getPickRay(startPosition, rotateCVWindowRay);\n      var position = ray.origin;\n      var direction = ray.direction;\n\n      var scalar;\n      var normalDotDirection = Cartesian3.dot(normal, direction);\n      if (Math.abs(normalDotDirection) > CesiumMath.EPSILON6) {\n        scalar = -Cartesian3.dot(normal, position) / normalDotDirection;\n      }\n\n      if (!defined(scalar) || scalar <= 0.0) {\n        controller._looking = true;\n        look3D(controller, startPosition, movement);\n        Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n        return;\n      }\n\n      center = Cartesian3.multiplyByScalar(direction, scalar, rotateCVCenter);\n      Cartesian3.add(position, center, center);\n    }\n\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    Cartesian3.clone(center, controller._tiltCenter);\n  }\n\n  var canvas = scene.canvas;\n\n  var windowPosition = rotateCVWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = controller._tiltCenterMousePosition.y;\n  ray = camera.getPickRay(windowPosition, rotateCVWindowRay);\n\n  var origin = Cartesian3.clone(Cartesian3.ZERO, rotateCVOrigin);\n  origin.x = center.x;\n\n  var plane = Plane.fromPointNormal(origin, normal, rotateCVPlane);\n  var verticalCenter = IntersectionTests.rayPlane(\n    ray,\n    plane,\n    rotateCVVerticalCenter\n  );\n\n  var projection = camera._projection;\n  var ellipsoid = projection.ellipsoid;\n\n  Cartesian3.fromElements(center.y, center.z, center.x, center);\n  var cart = projection.unproject(center, rotateCVCart);\n  ellipsoid.cartographicToCartesian(cart, center);\n\n  var transform = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    rotateCVTransform\n  );\n\n  var verticalTransform;\n  if (defined(verticalCenter)) {\n    Cartesian3.fromElements(\n      verticalCenter.y,\n      verticalCenter.z,\n      verticalCenter.x,\n      verticalCenter\n    );\n    cart = projection.unproject(verticalCenter, rotateCVCart);\n    ellipsoid.cartographicToCartesian(cart, verticalCenter);\n\n    verticalTransform = Transforms.eastNorthUpToFixedFrame(\n      verticalCenter,\n      ellipsoid,\n      rotateCVVerticalTransform\n    );\n  } else {\n    verticalTransform = transform;\n  }\n\n  var oldGlobe = controller._globe;\n  var oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n\n  var constrainedAxis = Cartesian3.UNIT_Z;\n\n  var oldTransform = Matrix4.clone(camera.transform, rotateCVOldTransform);\n  camera._setTransform(transform);\n\n  var tangent = Cartesian3.cross(\n    Cartesian3.UNIT_Z,\n    Cartesian3.normalize(camera.position, rotateCVCartesian3),\n    rotateCVCartesian3\n  );\n  var dot = Cartesian3.dot(camera.right, tangent);\n\n  rotate3D(controller, startPosition, movement, constrainedAxis, false, true);\n\n  camera._setTransform(verticalTransform);\n  if (dot < 0.0) {\n    if (movement.startPosition.y > movement.endPosition.y) {\n      constrainedAxis = undefined;\n    }\n\n    var oldConstrainedAxis = camera.constrainedAxis;\n    camera.constrainedAxis = undefined;\n\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n\n    camera.constrainedAxis = oldConstrainedAxis;\n  } else {\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n  }\n\n  if (defined(camera.constrainedAxis)) {\n    var right = Cartesian3.cross(\n      camera.direction,\n      camera.constrainedAxis,\n      tilt3DCartesian3\n    );\n    if (\n      !Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)\n    ) {\n      if (Cartesian3.dot(right, camera.right) < 0.0) {\n        Cartesian3.negate(right, right);\n      }\n\n      Cartesian3.cross(right, camera.direction, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n      Cartesian3.normalize(camera.up, camera.up);\n      Cartesian3.normalize(camera.right, camera.right);\n    }\n  }\n\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n\n  var radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n\n  var originalPosition = Cartesian3.clone(\n    camera.positionWC,\n    rotateCVCartesian3\n  );\n\n  if (controller.enableCollisionDetection) {\n    adjustHeightForTerrain(controller);\n  }\n\n  if (!Cartesian3.equals(camera.positionWC, originalPosition)) {\n    camera._setTransform(verticalTransform);\n    camera.worldToCameraCoordinatesPoint(originalPosition, originalPosition);\n\n    var magSqrd = Cartesian3.magnitudeSquared(originalPosition);\n    if (Cartesian3.magnitudeSquared(camera.position) > magSqrd) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.multiplyByScalar(\n        camera.position,\n        Math.sqrt(magSqrd),\n        camera.position\n      );\n    }\n\n    var angle = Cartesian3.angleBetween(originalPosition, camera.position);\n    var axis = Cartesian3.cross(\n      originalPosition,\n      camera.position,\n      originalPosition\n    );\n    Cartesian3.normalize(axis, axis);\n\n    var quaternion = Quaternion.fromAxisAngle(axis, angle, rotateCVQuaternion);\n    var rotation = Matrix3.fromQuaternion(quaternion, rotateCVMatrix);\n    Matrix3.multiplyByVector(rotation, camera.direction, camera.direction);\n    Matrix3.multiplyByVector(rotation, camera.up, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.cross(camera.right, camera.direction, camera.up);\n\n    camera._setTransform(oldTransform);\n  }\n}\n\nvar zoomCVWindowPos = new Cartesian2();\nvar zoomCVWindowRay = new Ray();\nvar zoomCVIntersection = new Cartesian3();\n\nfunction zoomCV(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var canvas = scene.canvas;\n\n  var windowPosition = zoomCVWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = canvas.clientHeight / 2;\n  var ray = camera.getPickRay(windowPosition, zoomCVWindowRay);\n\n  var intersection;\n  if (camera.position.z < controller._minimumPickingTerrainHeight) {\n    intersection = pickGlobe(controller, windowPosition, zoomCVIntersection);\n  }\n\n  var distance;\n  if (defined(intersection)) {\n    distance = Cartesian3.distance(ray.origin, intersection);\n  } else {\n    var normal = Cartesian3.UNIT_X;\n    var position = ray.origin;\n    var direction = ray.direction;\n    distance =\n      -Cartesian3.dot(normal, position) / Cartesian3.dot(normal, direction);\n  }\n\n  handleZoom(\n    controller,\n    startPosition,\n    movement,\n    controller._zoomFactor,\n    distance\n  );\n}\n\nfunction updateCV(controller) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n\n  if (!Matrix4.equals(Matrix4.IDENTITY, camera.transform)) {\n    reactToInput(\n      controller,\n      controller.enableRotate,\n      controller.rotateEventTypes,\n      rotate3D,\n      controller.inertiaSpin,\n      \"_lastInertiaSpinMovement\"\n    );\n    reactToInput(\n      controller,\n      controller.enableZoom,\n      controller.zoomEventTypes,\n      zoom3D,\n      controller.inertiaZoom,\n      \"_lastInertiaZoomMovement\"\n    );\n  } else {\n    var tweens = controller._tweens;\n\n    if (controller._aggregator.anyButtonDown) {\n      tweens.removeAll();\n    }\n\n    reactToInput(\n      controller,\n      controller.enableTilt,\n      controller.tiltEventTypes,\n      rotateCV,\n      controller.inertiaSpin,\n      \"_lastInertiaTiltMovement\"\n    );\n    reactToInput(\n      controller,\n      controller.enableTranslate,\n      controller.translateEventTypes,\n      translateCV,\n      controller.inertiaTranslate,\n      \"_lastInertiaTranslateMovement\"\n    );\n    reactToInput(\n      controller,\n      controller.enableZoom,\n      controller.zoomEventTypes,\n      zoomCV,\n      controller.inertiaZoom,\n      \"_lastInertiaZoomMovement\"\n    );\n    reactToInput(\n      controller,\n      controller.enableLook,\n      controller.lookEventTypes,\n      look3D\n    );\n\n    if (\n      !controller._aggregator.anyButtonDown &&\n      (!defined(controller._lastInertiaZoomMovement) ||\n        !controller._lastInertiaZoomMovement.active) &&\n      (!defined(controller._lastInertiaTranslateMovement) ||\n        !controller._lastInertiaTranslateMovement.active) &&\n      !tweens.contains(controller._tween)\n    ) {\n      var tween = camera.createCorrectPositionTween(\n        controller.bounceAnimationTime\n      );\n      if (defined(tween)) {\n        controller._tween = tweens.add(tween);\n      }\n    }\n\n    tweens.update();\n  }\n}\n\nvar scratchStrafeRay = new Ray();\nvar scratchStrafePlane = new Plane(Cartesian3.UNIT_X, 0.0);\nvar scratchStrafeIntersection = new Cartesian3();\nvar scratchStrafeDirection = new Cartesian3();\nvar scratchMousePos = new Cartesian3();\n\nfunction strafe(controller, startPosition, movement) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n\n  var mouseStartPosition = pickGlobe(\n    controller,\n    movement.startPosition,\n    scratchMousePos\n  );\n  if (!defined(mouseStartPosition)) {\n    return;\n  }\n\n  var mousePosition = movement.endPosition;\n  var ray = camera.getPickRay(mousePosition, scratchStrafeRay);\n\n  var direction = Cartesian3.clone(camera.direction, scratchStrafeDirection);\n  if (scene.mode === SceneMode.COLUMBUS_VIEW) {\n    Cartesian3.fromElements(direction.z, direction.x, direction.y, direction);\n  }\n\n  var plane = Plane.fromPointNormal(\n    mouseStartPosition,\n    direction,\n    scratchStrafePlane\n  );\n  var intersection = IntersectionTests.rayPlane(\n    ray,\n    plane,\n    scratchStrafeIntersection\n  );\n  if (!defined(intersection)) {\n    return;\n  }\n\n  direction = Cartesian3.subtract(mouseStartPosition, intersection, direction);\n  if (scene.mode === SceneMode.COLUMBUS_VIEW) {\n    Cartesian3.fromElements(direction.y, direction.z, direction.x, direction);\n  }\n\n  Cartesian3.add(camera.position, direction, camera.position);\n}\n\nvar spin3DPick = new Cartesian3();\nvar scratchCartographic = new Cartographic();\nvar scratchRadii = new Cartesian3();\nvar scratchEllipsoid = new Ellipsoid();\nvar scratchLookUp = new Cartesian3();\n\nfunction spin3D(controller, startPosition, movement) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    rotate3D(controller, startPosition, movement);\n    return;\n  }\n\n  var magnitude;\n  var radii;\n  var ellipsoid;\n\n  var up = controller._ellipsoid.geodeticSurfaceNormal(\n    camera.position,\n    scratchLookUp\n  );\n\n  var height = controller._ellipsoid.cartesianToCartographic(\n    camera.positionWC,\n    scratchCartographic\n  ).height;\n  var globe = controller._globe;\n\n  var mousePos;\n  var tangentPick = false;\n  if (defined(globe) && height < controller._minimumPickingTerrainHeight) {\n    mousePos = pickGlobe(controller, movement.startPosition, scratchMousePos);\n    if (defined(mousePos)) {\n      var ray = camera.getPickRay(movement.startPosition, pickGlobeScratchRay);\n      var normal = controller._ellipsoid.geodeticSurfaceNormal(mousePos);\n      tangentPick = Math.abs(Cartesian3.dot(ray.direction, normal)) < 0.05;\n\n      if (tangentPick && !controller._looking) {\n        controller._rotating = false;\n        controller._strafing = true;\n      }\n    }\n  }\n\n  if (Cartesian2.equals(startPosition, controller._rotateMousePosition)) {\n    if (controller._looking) {\n      look3D(controller, startPosition, movement, up);\n    } else if (controller._rotating) {\n      rotate3D(controller, startPosition, movement);\n    } else if (controller._strafing) {\n      Cartesian3.clone(mousePos, controller._strafeStartPosition);\n      strafe(controller, startPosition, movement);\n    } else {\n      magnitude = Cartesian3.magnitude(controller._rotateStartPosition);\n      radii = scratchRadii;\n      radii.x = radii.y = radii.z = magnitude;\n      ellipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n      pan3D(controller, startPosition, movement, ellipsoid);\n    }\n    return;\n  }\n  controller._looking = false;\n  controller._rotating = false;\n  controller._strafing = false;\n\n  if (defined(globe) && height < controller._minimumPickingTerrainHeight) {\n    if (defined(mousePos)) {\n      if (\n        Cartesian3.magnitude(camera.position) < Cartesian3.magnitude(mousePos)\n      ) {\n        Cartesian3.clone(mousePos, controller._strafeStartPosition);\n\n        controller._strafing = true;\n        strafe(controller, startPosition, movement);\n      } else {\n        magnitude = Cartesian3.magnitude(mousePos);\n        radii = scratchRadii;\n        radii.x = radii.y = radii.z = magnitude;\n        ellipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n        pan3D(controller, startPosition, movement, ellipsoid);\n\n        Cartesian3.clone(mousePos, controller._rotateStartPosition);\n      }\n    } else {\n      controller._looking = true;\n      look3D(controller, startPosition, movement, up);\n    }\n  } else if (\n    defined(\n      camera.pickEllipsoid(\n        movement.startPosition,\n        controller._ellipsoid,\n        spin3DPick\n      )\n    )\n  ) {\n    pan3D(controller, startPosition, movement, controller._ellipsoid);\n    Cartesian3.clone(spin3DPick, controller._rotateStartPosition);\n  } else if (height > controller._minimumTrackBallHeight) {\n    controller._rotating = true;\n    rotate3D(controller, startPosition, movement);\n  } else {\n    controller._looking = true;\n    look3D(controller, startPosition, movement, up);\n  }\n\n  Cartesian2.clone(startPosition, controller._rotateMousePosition);\n}\n\nfunction rotate3D(\n  controller,\n  startPosition,\n  movement,\n  constrainedAxis,\n  rotateOnlyVertical,\n  rotateOnlyHorizontal\n) {\n  rotateOnlyVertical = defaultValue(rotateOnlyVertical, false);\n  rotateOnlyHorizontal = defaultValue(rotateOnlyHorizontal, false);\n\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var canvas = scene.canvas;\n\n  var oldAxis = camera.constrainedAxis;\n  if (defined(constrainedAxis)) {\n    camera.constrainedAxis = constrainedAxis;\n  }\n\n  var rho = Cartesian3.magnitude(camera.position);\n  var rotateRate =\n    controller._rotateFactor * (rho - controller._rotateRateRangeAdjustment);\n\n  if (rotateRate > controller._maximumRotateRate) {\n    rotateRate = controller._maximumRotateRate;\n  }\n\n  if (rotateRate < controller._minimumRotateRate) {\n    rotateRate = controller._minimumRotateRate;\n  }\n\n  var phiWindowRatio =\n    (movement.startPosition.x - movement.endPosition.x) / canvas.clientWidth;\n  var thetaWindowRatio =\n    (movement.startPosition.y - movement.endPosition.y) / canvas.clientHeight;\n  phiWindowRatio = Math.min(phiWindowRatio, controller.maximumMovementRatio);\n  thetaWindowRatio = Math.min(\n    thetaWindowRatio,\n    controller.maximumMovementRatio\n  );\n\n  var deltaPhi = rotateRate * phiWindowRatio * Math.PI * 2.0;\n  var deltaTheta = rotateRate * thetaWindowRatio * Math.PI;\n\n  if (!rotateOnlyVertical) {\n    camera.rotateRight(deltaPhi);\n  }\n\n  if (!rotateOnlyHorizontal) {\n    camera.rotateUp(deltaTheta);\n  }\n\n  camera.constrainedAxis = oldAxis;\n}\n\nvar pan3DP0 = Cartesian4.clone(Cartesian4.UNIT_W);\nvar pan3DP1 = Cartesian4.clone(Cartesian4.UNIT_W);\nvar pan3DTemp0 = new Cartesian3();\nvar pan3DTemp1 = new Cartesian3();\nvar pan3DTemp2 = new Cartesian3();\nvar pan3DTemp3 = new Cartesian3();\nvar pan3DStartMousePosition = new Cartesian2();\nvar pan3DEndMousePosition = new Cartesian2();\n\nfunction pan3D(controller, startPosition, movement, ellipsoid) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n\n  var startMousePosition = Cartesian2.clone(\n    movement.startPosition,\n    pan3DStartMousePosition\n  );\n  var endMousePosition = Cartesian2.clone(\n    movement.endPosition,\n    pan3DEndMousePosition\n  );\n\n  var p0 = camera.pickEllipsoid(startMousePosition, ellipsoid, pan3DP0);\n  var p1 = camera.pickEllipsoid(endMousePosition, ellipsoid, pan3DP1);\n\n  if (!defined(p0) || !defined(p1)) {\n    controller._rotating = true;\n    rotate3D(controller, startPosition, movement);\n    return;\n  }\n\n  p0 = camera.worldToCameraCoordinates(p0, p0);\n  p1 = camera.worldToCameraCoordinates(p1, p1);\n\n  if (!defined(camera.constrainedAxis)) {\n    Cartesian3.normalize(p0, p0);\n    Cartesian3.normalize(p1, p1);\n    var dot = Cartesian3.dot(p0, p1);\n    var axis = Cartesian3.cross(p0, p1, pan3DTemp0);\n\n    if (\n      dot < 1.0 &&\n      !Cartesian3.equalsEpsilon(axis, Cartesian3.ZERO, CesiumMath.EPSILON14)\n    ) {\n      // dot is in [0, 1]\n      var angle = Math.acos(dot);\n      camera.rotate(axis, angle);\n    }\n  } else {\n    var basis0 = camera.constrainedAxis;\n    var basis1 = Cartesian3.mostOrthogonalAxis(basis0, pan3DTemp0);\n    Cartesian3.cross(basis1, basis0, basis1);\n    Cartesian3.normalize(basis1, basis1);\n    var basis2 = Cartesian3.cross(basis0, basis1, pan3DTemp1);\n\n    var startRho = Cartesian3.magnitude(p0);\n    var startDot = Cartesian3.dot(basis0, p0);\n    var startTheta = Math.acos(startDot / startRho);\n    var startRej = Cartesian3.multiplyByScalar(basis0, startDot, pan3DTemp2);\n    Cartesian3.subtract(p0, startRej, startRej);\n    Cartesian3.normalize(startRej, startRej);\n\n    var endRho = Cartesian3.magnitude(p1);\n    var endDot = Cartesian3.dot(basis0, p1);\n    var endTheta = Math.acos(endDot / endRho);\n    var endRej = Cartesian3.multiplyByScalar(basis0, endDot, pan3DTemp3);\n    Cartesian3.subtract(p1, endRej, endRej);\n    Cartesian3.normalize(endRej, endRej);\n\n    var startPhi = Math.acos(Cartesian3.dot(startRej, basis1));\n    if (Cartesian3.dot(startRej, basis2) < 0) {\n      startPhi = CesiumMath.TWO_PI - startPhi;\n    }\n\n    var endPhi = Math.acos(Cartesian3.dot(endRej, basis1));\n    if (Cartesian3.dot(endRej, basis2) < 0) {\n      endPhi = CesiumMath.TWO_PI - endPhi;\n    }\n\n    var deltaPhi = startPhi - endPhi;\n\n    var east;\n    if (\n      Cartesian3.equalsEpsilon(basis0, camera.position, CesiumMath.EPSILON2)\n    ) {\n      east = camera.right;\n    } else {\n      east = Cartesian3.cross(basis0, camera.position, pan3DTemp0);\n    }\n\n    var planeNormal = Cartesian3.cross(basis0, east, pan3DTemp0);\n    var side0 = Cartesian3.dot(\n      planeNormal,\n      Cartesian3.subtract(p0, basis0, pan3DTemp1)\n    );\n    var side1 = Cartesian3.dot(\n      planeNormal,\n      Cartesian3.subtract(p1, basis0, pan3DTemp1)\n    );\n\n    var deltaTheta;\n    if (side0 > 0 && side1 > 0) {\n      deltaTheta = endTheta - startTheta;\n    } else if (side0 > 0 && side1 <= 0) {\n      if (Cartesian3.dot(camera.position, basis0) > 0) {\n        deltaTheta = -startTheta - endTheta;\n      } else {\n        deltaTheta = startTheta + endTheta;\n      }\n    } else {\n      deltaTheta = startTheta - endTheta;\n    }\n\n    camera.rotateRight(deltaPhi);\n    camera.rotateUp(deltaTheta);\n  }\n}\n\nvar zoom3DUnitPosition = new Cartesian3();\nvar zoom3DCartographic = new Cartographic();\n\nfunction zoom3D(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n\n  var ellipsoid = controller._ellipsoid;\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var canvas = scene.canvas;\n\n  var windowPosition = zoomCVWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = canvas.clientHeight / 2;\n  var ray = camera.getPickRay(windowPosition, zoomCVWindowRay);\n\n  var intersection;\n  var height = ellipsoid.cartesianToCartographic(\n    camera.position,\n    zoom3DCartographic\n  ).height;\n  if (height < controller._minimumPickingTerrainHeight) {\n    intersection = pickGlobe(controller, windowPosition, zoomCVIntersection);\n  }\n\n  var distance;\n  if (defined(intersection)) {\n    distance = Cartesian3.distance(ray.origin, intersection);\n  } else {\n    distance = height;\n  }\n\n  var unitPosition = Cartesian3.normalize(camera.position, zoom3DUnitPosition);\n  handleZoom(\n    controller,\n    startPosition,\n    movement,\n    controller._zoomFactor,\n    distance,\n    Cartesian3.dot(unitPosition, camera.direction)\n  );\n}\n\nvar tilt3DWindowPos = new Cartesian2();\nvar tilt3DRay = new Ray();\nvar tilt3DCenter = new Cartesian3();\nvar tilt3DVerticalCenter = new Cartesian3();\nvar tilt3DTransform = new Matrix4();\nvar tilt3DVerticalTransform = new Matrix4();\nvar tilt3DOldTransform = new Matrix4();\nvar tilt3DQuaternion = new Quaternion();\nvar tilt3DMatrix = new Matrix3();\nvar tilt3DCart = new Cartographic();\nvar tilt3DLookUp = new Cartesian3();\n\nfunction tilt3D(controller, startPosition, movement) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    return;\n  }\n\n  if (defined(movement.angleAndHeight)) {\n    movement = movement.angleAndHeight;\n  }\n\n  if (!Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    controller._tiltOnEllipsoid = false;\n    controller._looking = false;\n  }\n\n  if (controller._looking) {\n    var up = controller._ellipsoid.geodeticSurfaceNormal(\n      camera.position,\n      tilt3DLookUp\n    );\n    look3D(controller, startPosition, movement, up);\n    return;\n  }\n\n  var ellipsoid = controller._ellipsoid;\n  var cartographic = ellipsoid.cartesianToCartographic(\n    camera.position,\n    tilt3DCart\n  );\n\n  if (\n    controller._tiltOnEllipsoid ||\n    cartographic.height > controller._minimumCollisionTerrainHeight\n  ) {\n    controller._tiltOnEllipsoid = true;\n    tilt3DOnEllipsoid(controller, startPosition, movement);\n  } else {\n    tilt3DOnTerrain(controller, startPosition, movement);\n  }\n}\n\nvar tilt3DOnEllipsoidCartographic = new Cartographic();\n\nfunction tilt3DOnEllipsoid(controller, startPosition, movement) {\n  var ellipsoid = controller._ellipsoid;\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var minHeight = controller.minimumZoomDistance * 0.25;\n  var height = ellipsoid.cartesianToCartographic(\n    camera.positionWC,\n    tilt3DOnEllipsoidCartographic\n  ).height;\n  if (\n    height - minHeight - 1.0 < CesiumMath.EPSILON3 &&\n    movement.endPosition.y - movement.startPosition.y < 0\n  ) {\n    return;\n  }\n\n  var canvas = scene.canvas;\n\n  var windowPosition = tilt3DWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = canvas.clientHeight / 2;\n  var ray = camera.getPickRay(windowPosition, tilt3DRay);\n\n  var center;\n  var intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n  if (defined(intersection)) {\n    center = Ray.getPoint(ray, intersection.start, tilt3DCenter);\n  } else if (height > controller._minimumTrackBallHeight) {\n    var grazingAltitudeLocation = IntersectionTests.grazingAltitudeLocation(\n      ray,\n      ellipsoid\n    );\n    if (!defined(grazingAltitudeLocation)) {\n      return;\n    }\n    var grazingAltitudeCart = ellipsoid.cartesianToCartographic(\n      grazingAltitudeLocation,\n      tilt3DCart\n    );\n    grazingAltitudeCart.height = 0.0;\n    center = ellipsoid.cartographicToCartesian(\n      grazingAltitudeCart,\n      tilt3DCenter\n    );\n  } else {\n    controller._looking = true;\n    var up = controller._ellipsoid.geodeticSurfaceNormal(\n      camera.position,\n      tilt3DLookUp\n    );\n    look3D(controller, startPosition, movement, up);\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    return;\n  }\n\n  var transform = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    tilt3DTransform\n  );\n\n  var oldGlobe = controller._globe;\n  var oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n\n  var oldTransform = Matrix4.clone(camera.transform, tilt3DOldTransform);\n  camera._setTransform(transform);\n\n  rotate3D(controller, startPosition, movement, Cartesian3.UNIT_Z);\n\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n\n  var radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n}\n\nfunction tilt3DOnTerrain(controller, startPosition, movement) {\n  var ellipsoid = controller._ellipsoid;\n  var scene = controller._scene;\n  var camera = scene.camera;\n\n  var center;\n  var ray;\n  var intersection;\n\n  if (Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    center = Cartesian3.clone(controller._tiltCenter, tilt3DCenter);\n  } else {\n    center = pickGlobe(controller, startPosition, tilt3DCenter);\n\n    if (!defined(center)) {\n      ray = camera.getPickRay(startPosition, tilt3DRay);\n      intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n      if (!defined(intersection)) {\n        var cartographic = ellipsoid.cartesianToCartographic(\n          camera.position,\n          tilt3DCart\n        );\n        if (cartographic.height <= controller._minimumTrackBallHeight) {\n          controller._looking = true;\n          var up = controller._ellipsoid.geodeticSurfaceNormal(\n            camera.position,\n            tilt3DLookUp\n          );\n          look3D(controller, startPosition, movement, up);\n          Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n        }\n        return;\n      }\n      center = Ray.getPoint(ray, intersection.start, tilt3DCenter);\n    }\n\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    Cartesian3.clone(center, controller._tiltCenter);\n  }\n\n  var canvas = scene.canvas;\n\n  var windowPosition = tilt3DWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = controller._tiltCenterMousePosition.y;\n  ray = camera.getPickRay(windowPosition, tilt3DRay);\n\n  var mag = Cartesian3.magnitude(center);\n  var radii = Cartesian3.fromElements(mag, mag, mag, scratchRadii);\n  var newEllipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n\n  intersection = IntersectionTests.rayEllipsoid(ray, newEllipsoid);\n  if (!defined(intersection)) {\n    return;\n  }\n\n  var t =\n    Cartesian3.magnitude(ray.origin) > mag\n      ? intersection.start\n      : intersection.stop;\n  var verticalCenter = Ray.getPoint(ray, t, tilt3DVerticalCenter);\n\n  var transform = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    tilt3DTransform\n  );\n  var verticalTransform = Transforms.eastNorthUpToFixedFrame(\n    verticalCenter,\n    newEllipsoid,\n    tilt3DVerticalTransform\n  );\n\n  var oldGlobe = controller._globe;\n  var oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n\n  var constrainedAxis = Cartesian3.UNIT_Z;\n\n  var oldTransform = Matrix4.clone(camera.transform, tilt3DOldTransform);\n  camera._setTransform(transform);\n\n  var tangent = Cartesian3.cross(\n    verticalCenter,\n    camera.positionWC,\n    tilt3DCartesian3\n  );\n  var dot = Cartesian3.dot(camera.rightWC, tangent);\n\n  rotate3D(controller, startPosition, movement, constrainedAxis, false, true);\n\n  camera._setTransform(verticalTransform);\n\n  if (dot < 0.0) {\n    if (movement.startPosition.y > movement.endPosition.y) {\n      constrainedAxis = undefined;\n    }\n\n    var oldConstrainedAxis = camera.constrainedAxis;\n    camera.constrainedAxis = undefined;\n\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n\n    camera.constrainedAxis = oldConstrainedAxis;\n  } else {\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n  }\n\n  if (defined(camera.constrainedAxis)) {\n    var right = Cartesian3.cross(\n      camera.direction,\n      camera.constrainedAxis,\n      tilt3DCartesian3\n    );\n    if (\n      !Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)\n    ) {\n      if (Cartesian3.dot(right, camera.right) < 0.0) {\n        Cartesian3.negate(right, right);\n      }\n\n      Cartesian3.cross(right, camera.direction, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n      Cartesian3.normalize(camera.up, camera.up);\n      Cartesian3.normalize(camera.right, camera.right);\n    }\n  }\n\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n\n  var radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n\n  var originalPosition = Cartesian3.clone(camera.positionWC, tilt3DCartesian3);\n\n  if (controller.enableCollisionDetection) {\n    adjustHeightForTerrain(controller);\n  }\n\n  if (!Cartesian3.equals(camera.positionWC, originalPosition)) {\n    camera._setTransform(verticalTransform);\n    camera.worldToCameraCoordinatesPoint(originalPosition, originalPosition);\n\n    var magSqrd = Cartesian3.magnitudeSquared(originalPosition);\n    if (Cartesian3.magnitudeSquared(camera.position) > magSqrd) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.multiplyByScalar(\n        camera.position,\n        Math.sqrt(magSqrd),\n        camera.position\n      );\n    }\n\n    var angle = Cartesian3.angleBetween(originalPosition, camera.position);\n    var axis = Cartesian3.cross(\n      originalPosition,\n      camera.position,\n      originalPosition\n    );\n    Cartesian3.normalize(axis, axis);\n\n    var quaternion = Quaternion.fromAxisAngle(axis, angle, tilt3DQuaternion);\n    var rotation = Matrix3.fromQuaternion(quaternion, tilt3DMatrix);\n    Matrix3.multiplyByVector(rotation, camera.direction, camera.direction);\n    Matrix3.multiplyByVector(rotation, camera.up, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.cross(camera.right, camera.direction, camera.up);\n\n    camera._setTransform(oldTransform);\n  }\n}\n\nvar look3DStartPos = new Cartesian2();\nvar look3DEndPos = new Cartesian2();\nvar look3DStartRay = new Ray();\nvar look3DEndRay = new Ray();\nvar look3DNegativeRot = new Cartesian3();\nvar look3DTan = new Cartesian3();\n\nfunction look3D(controller, startPosition, movement, rotationAxis) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n\n  var startPos = look3DStartPos;\n  startPos.x = movement.startPosition.x;\n  startPos.y = 0.0;\n  var endPos = look3DEndPos;\n  endPos.x = movement.endPosition.x;\n  endPos.y = 0.0;\n\n  var startRay = camera.getPickRay(startPos, look3DStartRay);\n  var endRay = camera.getPickRay(endPos, look3DEndRay);\n  var angle = 0.0;\n  var start;\n  var end;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    start = startRay.origin;\n    end = endRay.origin;\n\n    Cartesian3.add(camera.direction, start, start);\n    Cartesian3.add(camera.direction, end, end);\n\n    Cartesian3.subtract(start, camera.position, start);\n    Cartesian3.subtract(end, camera.position, end);\n\n    Cartesian3.normalize(start, start);\n    Cartesian3.normalize(end, end);\n  } else {\n    start = startRay.direction;\n    end = endRay.direction;\n  }\n\n  var dot = Cartesian3.dot(start, end);\n  if (dot < 1.0) {\n    // dot is in [0, 1]\n    angle = Math.acos(dot);\n  }\n\n  angle = movement.startPosition.x > movement.endPosition.x ? -angle : angle;\n\n  var horizontalRotationAxis = controller._horizontalRotationAxis;\n  if (defined(rotationAxis)) {\n    camera.look(rotationAxis, -angle);\n  } else if (defined(horizontalRotationAxis)) {\n    camera.look(horizontalRotationAxis, -angle);\n  } else {\n    camera.lookLeft(angle);\n  }\n\n  startPos.x = 0.0;\n  startPos.y = movement.startPosition.y;\n  endPos.x = 0.0;\n  endPos.y = movement.endPosition.y;\n\n  startRay = camera.getPickRay(startPos, look3DStartRay);\n  endRay = camera.getPickRay(endPos, look3DEndRay);\n  angle = 0.0;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    start = startRay.origin;\n    end = endRay.origin;\n\n    Cartesian3.add(camera.direction, start, start);\n    Cartesian3.add(camera.direction, end, end);\n\n    Cartesian3.subtract(start, camera.position, start);\n    Cartesian3.subtract(end, camera.position, end);\n\n    Cartesian3.normalize(start, start);\n    Cartesian3.normalize(end, end);\n  } else {\n    start = startRay.direction;\n    end = endRay.direction;\n  }\n\n  dot = Cartesian3.dot(start, end);\n  if (dot < 1.0) {\n    // dot is in [0, 1]\n    angle = Math.acos(dot);\n  }\n  angle = movement.startPosition.y > movement.endPosition.y ? -angle : angle;\n\n  rotationAxis = defaultValue(rotationAxis, horizontalRotationAxis);\n  if (defined(rotationAxis)) {\n    var direction = camera.direction;\n    var negativeRotationAxis = Cartesian3.negate(\n      rotationAxis,\n      look3DNegativeRot\n    );\n    var northParallel = Cartesian3.equalsEpsilon(\n      direction,\n      rotationAxis,\n      CesiumMath.EPSILON2\n    );\n    var southParallel = Cartesian3.equalsEpsilon(\n      direction,\n      negativeRotationAxis,\n      CesiumMath.EPSILON2\n    );\n    if (!northParallel && !southParallel) {\n      dot = Cartesian3.dot(direction, rotationAxis);\n      var angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle > 0 && angle > angleToAxis) {\n        angle = angleToAxis - CesiumMath.EPSILON4;\n      }\n\n      dot = Cartesian3.dot(direction, negativeRotationAxis);\n      angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle < 0 && -angle > angleToAxis) {\n        angle = -angleToAxis + CesiumMath.EPSILON4;\n      }\n\n      var tangent = Cartesian3.cross(rotationAxis, direction, look3DTan);\n      camera.look(tangent, angle);\n    } else if ((northParallel && angle < 0) || (southParallel && angle > 0)) {\n      camera.look(camera.right, -angle);\n    }\n  } else {\n    camera.lookUp(angle);\n  }\n}\n\nfunction update3D(controller) {\n  reactToInput(\n    controller,\n    controller.enableRotate,\n    controller.rotateEventTypes,\n    spin3D,\n    controller.inertiaSpin,\n    \"_lastInertiaSpinMovement\"\n  );\n  reactToInput(\n    controller,\n    controller.enableZoom,\n    controller.zoomEventTypes,\n    zoom3D,\n    controller.inertiaZoom,\n    \"_lastInertiaZoomMovement\"\n  );\n  reactToInput(\n    controller,\n    controller.enableTilt,\n    controller.tiltEventTypes,\n    tilt3D,\n    controller.inertiaSpin,\n    \"_lastInertiaTiltMovement\"\n  );\n  reactToInput(\n    controller,\n    controller.enableLook,\n    controller.lookEventTypes,\n    look3D\n  );\n}\n\nvar scratchAdjustHeightTransform = new Matrix4();\nvar scratchAdjustHeightCartographic = new Cartographic();\n\nfunction adjustHeightForTerrain(controller) {\n  controller._adjustedHeightForTerrain = true;\n\n  var scene = controller._scene;\n  var mode = scene.mode;\n  var globe = scene.globe;\n\n  if (\n    !defined(globe) ||\n    mode === SceneMode.SCENE2D ||\n    mode === SceneMode.MORPHING\n  ) {\n    return;\n  }\n\n  var camera = scene.camera;\n  var ellipsoid = globe.ellipsoid;\n  var projection = scene.mapProjection;\n\n  var transform;\n  var mag;\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    transform = Matrix4.clone(camera.transform, scratchAdjustHeightTransform);\n    mag = Cartesian3.magnitude(camera.position);\n    camera._setTransform(Matrix4.IDENTITY);\n  }\n\n  var cartographic = scratchAdjustHeightCartographic;\n  if (mode === SceneMode.SCENE3D) {\n    ellipsoid.cartesianToCartographic(camera.position, cartographic);\n  } else {\n    projection.unproject(camera.position, cartographic);\n  }\n\n  var heightUpdated = false;\n  if (cartographic.height < controller._minimumCollisionTerrainHeight) {\n    var height = globe.getHeight(cartographic);\n    if (defined(height)) {\n      height += controller.minimumZoomDistance;\n      if (cartographic.height < height) {\n        cartographic.height = height;\n        if (mode === SceneMode.SCENE3D) {\n          ellipsoid.cartographicToCartesian(cartographic, camera.position);\n        } else {\n          projection.project(cartographic, camera.position);\n        }\n        heightUpdated = true;\n      }\n    }\n  }\n\n  if (defined(transform)) {\n    camera._setTransform(transform);\n    if (heightUpdated) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.negate(camera.position, camera.direction);\n      Cartesian3.multiplyByScalar(\n        camera.position,\n        Math.max(mag, controller.minimumZoomDistance),\n        camera.position\n      );\n      Cartesian3.normalize(camera.direction, camera.direction);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.cross(camera.right, camera.direction, camera.up);\n    }\n  }\n}\n\n/**\n * @private\n */\nScreenSpaceCameraController.prototype.onMap = function () {\n  var scene = this._scene;\n  var mode = scene.mode;\n  var camera = scene.camera;\n\n  if (mode === SceneMode.COLUMBUS_VIEW) {\n    return (\n      Math.abs(camera.position.x) - this._maxCoord.x < 0 &&\n      Math.abs(camera.position.y) - this._maxCoord.y < 0\n    );\n  }\n\n  return true;\n};\n\nvar scratchPreviousPosition = new Cartesian3();\nvar scratchPreviousDirection = new Cartesian3();\n\n/**\n * @private\n */\nScreenSpaceCameraController.prototype.update = function () {\n  var camera = this._scene.camera;\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    this._globe = undefined;\n    this._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  } else {\n    this._globe = this._scene.globe;\n    this._ellipsoid = defined(this._globe)\n      ? this._globe.ellipsoid\n      : this._scene.mapProjection.ellipsoid;\n  }\n\n  this._minimumCollisionTerrainHeight =\n    this.minimumCollisionTerrainHeight * this._scene.terrainExaggeration;\n  this._minimumPickingTerrainHeight =\n    this.minimumPickingTerrainHeight * this._scene.terrainExaggeration;\n  this._minimumTrackBallHeight =\n    this.minimumTrackBallHeight * this._scene.terrainExaggeration;\n\n  var radius = this._ellipsoid.maximumRadius;\n  this._rotateFactor = 1.0 / radius;\n  this._rotateRateRangeAdjustment = radius;\n\n  this._adjustedHeightForTerrain = false;\n  var previousPosition = Cartesian3.clone(\n    camera.positionWC,\n    scratchPreviousPosition\n  );\n  var previousDirection = Cartesian3.clone(\n    camera.directionWC,\n    scratchPreviousDirection\n  );\n\n  var scene = this._scene;\n  var mode = scene.mode;\n  if (mode === SceneMode.SCENE2D) {\n    update2D(this);\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    this._horizontalRotationAxis = Cartesian3.UNIT_Z;\n    updateCV(this);\n  } else if (mode === SceneMode.SCENE3D) {\n    this._horizontalRotationAxis = undefined;\n    update3D(this);\n  }\n\n  if (this.enableCollisionDetection && !this._adjustedHeightForTerrain) {\n    // Adjust the camera height if the camera moved at all (user input or intertia) and an action didn't already adjust the camera height\n    var cameraChanged =\n      !Cartesian3.equals(previousPosition, camera.positionWC) ||\n      !Cartesian3.equals(previousDirection, camera.directionWC);\n    if (cameraChanged) {\n      adjustHeightForTerrain(this);\n    }\n  }\n\n  this._aggregator.reset();\n};\n\n/**\n * @private\n */\nScreenSpaceCameraController.prototype.adjustedHeightForTerrain = function () {\n  return this._adjustedHeightForTerrain;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ScreenSpaceCameraController#destroy\n */\nScreenSpaceCameraController.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes mouse listeners held by this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * controller = controller && controller.destroy();\n *\n * @see ScreenSpaceCameraController#isDestroyed\n */\nScreenSpaceCameraController.prototype.destroy = function () {\n  this._tweens.removeAll();\n  this._aggregator = this._aggregator && this._aggregator.destroy();\n  return destroyObject(this);\n};\nexport default ScreenSpaceCameraController;\n"]},"metadata":{},"sourceType":"module"}