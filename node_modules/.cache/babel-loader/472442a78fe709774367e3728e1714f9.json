{"ast":null,"code":"import Cartesian2 from \"./Cartesian2.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Intersect from \"./Intersect.js\";\nimport Rectangle from \"./Rectangle.js\";\n/**\n * A bounding rectangle given by a corner, width and height.\n * @alias BoundingRectangle\n * @constructor\n *\n * @param {Number} [x=0.0] The x coordinate of the rectangle.\n * @param {Number} [y=0.0] The y coordinate of the rectangle.\n * @param {Number} [width=0.0] The width of the rectangle.\n * @param {Number} [height=0.0] The height of the rectangle.\n *\n * @see BoundingSphere\n * @see Packable\n */\n\nfunction BoundingRectangle(x, y, width, height) {\n  /**\n   * The x coordinate of the rectangle.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.x = defaultValue(x, 0.0);\n  /**\n   * The y coordinate of the rectangle.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.y = defaultValue(y, 0.0);\n  /**\n   * The width of the rectangle.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.width = defaultValue(width, 0.0);\n  /**\n   * The height of the rectangle.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.height = defaultValue(height, 0.0);\n}\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\n\n\nBoundingRectangle.packedLength = 4;\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {BoundingRectangle} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\nBoundingRectangle.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex++] = value.width;\n  array[startingIndex] = value.height;\n  return array;\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {BoundingRectangle} [result] The object into which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\n\n\nBoundingRectangle.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex++];\n  result.width = array[startingIndex++];\n  result.height = array[startingIndex];\n  return result;\n};\n/**\n * Computes a bounding rectangle enclosing the list of 2D points.\n * The rectangle is oriented with the corner at the bottom left.\n *\n * @param {Cartesian2[]} positions List of points that the bounding rectangle will enclose.  Each point must have <code>x</code> and <code>y</code> properties.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\n\n\nBoundingRectangle.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.x = 0;\n    result.y = 0;\n    result.width = 0;\n    result.height = 0;\n    return result;\n  }\n\n  var length = positions.length;\n  var minimumX = positions[0].x;\n  var minimumY = positions[0].y;\n  var maximumX = positions[0].x;\n  var maximumY = positions[0].y;\n\n  for (var i = 1; i < length; i++) {\n    var p = positions[i];\n    var x = p.x;\n    var y = p.y;\n    minimumX = Math.min(x, minimumX);\n    maximumX = Math.max(x, maximumX);\n    minimumY = Math.min(y, minimumY);\n    maximumY = Math.max(y, maximumY);\n  }\n\n  result.x = minimumX;\n  result.y = minimumY;\n  result.width = maximumX - minimumX;\n  result.height = maximumY - minimumY;\n  return result;\n};\n\nvar defaultProjection = new GeographicProjection();\nvar fromRectangleLowerLeft = new Cartographic();\nvar fromRectangleUpperRight = new Cartographic();\n/**\n * Computes a bounding rectangle from a rectangle.\n *\n * @param {Rectangle} rectangle The valid rectangle used to create a bounding rectangle.\n * @param {Object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\n\nBoundingRectangle.fromRectangle = function (rectangle, projection, result) {\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n\n  if (!defined(rectangle)) {\n    result.x = 0;\n    result.y = 0;\n    result.width = 0;\n    result.height = 0;\n    return result;\n  }\n\n  projection = defaultValue(projection, defaultProjection);\n  var lowerLeft = projection.project(Rectangle.southwest(rectangle, fromRectangleLowerLeft));\n  var upperRight = projection.project(Rectangle.northeast(rectangle, fromRectangleUpperRight));\n  Cartesian2.subtract(upperRight, lowerLeft, upperRight);\n  result.x = lowerLeft.x;\n  result.y = lowerLeft.y;\n  result.width = upperRight.x;\n  result.height = upperRight.y;\n  return result;\n};\n/**\n * Duplicates a BoundingRectangle instance.\n *\n * @param {BoundingRectangle} rectangle The bounding rectangle to duplicate.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided. (Returns undefined if rectangle is undefined)\n */\n\n\nBoundingRectangle.clone = function (rectangle, result) {\n  if (!defined(rectangle)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new BoundingRectangle(rectangle.x, rectangle.y, rectangle.width, rectangle.height);\n  }\n\n  result.x = rectangle.x;\n  result.y = rectangle.y;\n  result.width = rectangle.width;\n  result.height = rectangle.height;\n  return result;\n};\n/**\n * Computes a bounding rectangle that is the union of the left and right bounding rectangles.\n *\n * @param {BoundingRectangle} left A rectangle to enclose in bounding rectangle.\n * @param {BoundingRectangle} right A rectangle to enclose in a bounding rectangle.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\n\n\nBoundingRectangle.union = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n\n  var lowerLeftX = Math.min(left.x, right.x);\n  var lowerLeftY = Math.min(left.y, right.y);\n  var upperRightX = Math.max(left.x + left.width, right.x + right.width);\n  var upperRightY = Math.max(left.y + left.height, right.y + right.height);\n  result.x = lowerLeftX;\n  result.y = lowerLeftY;\n  result.width = upperRightX - lowerLeftX;\n  result.height = upperRightY - lowerLeftY;\n  return result;\n};\n/**\n * Computes a bounding rectangle by enlarging the provided rectangle until it contains the provided point.\n *\n * @param {BoundingRectangle} rectangle A rectangle to expand.\n * @param {Cartesian2} point A point to enclose in a bounding rectangle.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\n\n\nBoundingRectangle.expand = function (rectangle, point, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"point\", point); //>>includeEnd('debug');\n\n  result = BoundingRectangle.clone(rectangle, result);\n  var width = point.x - result.x;\n  var height = point.y - result.y;\n\n  if (width > result.width) {\n    result.width = width;\n  } else if (width < 0) {\n    result.width -= width;\n    result.x = point.x;\n  }\n\n  if (height > result.height) {\n    result.height = height;\n  } else if (height < 0) {\n    result.height -= height;\n    result.y = point.y;\n  }\n\n  return result;\n};\n/**\n * Determines if two rectangles intersect.\n *\n * @param {BoundingRectangle} left A rectangle to check for intersection.\n * @param {BoundingRectangle} right The other rectangle to check for intersection.\n * @returns {Intersect} <code>Intersect.INTESECTING</code> if the rectangles intersect, <code>Intersect.OUTSIDE</code> otherwise.\n */\n\n\nBoundingRectangle.intersect = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right); //>>includeEnd('debug');\n\n  var leftX = left.x;\n  var leftY = left.y;\n  var rightX = right.x;\n  var rightY = right.y;\n\n  if (!(leftX > rightX + right.width || leftX + left.width < rightX || leftY + left.height < rightY || leftY > rightY + right.height)) {\n    return Intersect.INTERSECTING;\n  }\n\n  return Intersect.OUTSIDE;\n};\n/**\n * Compares the provided BoundingRectangles componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {BoundingRectangle} [left] The first BoundingRectangle.\n * @param {BoundingRectangle} [right] The second BoundingRectangle.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\n\n\nBoundingRectangle.equals = function (left, right) {\n  return left === right || defined(left) && defined(right) && left.x === right.x && left.y === right.y && left.width === right.width && left.height === right.height;\n};\n/**\n * Duplicates this BoundingRectangle instance.\n *\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\n\n\nBoundingRectangle.prototype.clone = function (result) {\n  return BoundingRectangle.clone(this, result);\n};\n/**\n * Determines if this rectangle intersects with another.\n *\n * @param {BoundingRectangle} right A rectangle to check for intersection.\n * @returns {Intersect} <code>Intersect.INTESECTING</code> if the rectangles intersect, <code>Intersect.OUTSIDE</code> otherwise.\n */\n\n\nBoundingRectangle.prototype.intersect = function (right) {\n  return BoundingRectangle.intersect(this, right);\n};\n/**\n * Compares this BoundingRectangle against the provided BoundingRectangle componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {BoundingRectangle} [right] The right hand side BoundingRectangle.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\n\n\nBoundingRectangle.prototype.equals = function (right) {\n  return BoundingRectangle.equals(this, right);\n};\n\nexport default BoundingRectangle;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/BoundingRectangle.js"],"names":["Cartesian2","Cartographic","Check","defaultValue","defined","GeographicProjection","Intersect","Rectangle","BoundingRectangle","x","y","width","height","packedLength","pack","value","array","startingIndex","typeOf","object","unpack","result","fromPoints","positions","length","minimumX","minimumY","maximumX","maximumY","i","p","Math","min","max","defaultProjection","fromRectangleLowerLeft","fromRectangleUpperRight","fromRectangle","rectangle","projection","lowerLeft","project","southwest","upperRight","northeast","subtract","clone","undefined","union","left","right","lowerLeftX","lowerLeftY","upperRightX","upperRightY","expand","point","intersect","leftX","leftY","rightX","rightY","INTERSECTING","OUTSIDE","equals","prototype"],"mappings":"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","sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Intersect from \"./Intersect.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * A bounding rectangle given by a corner, width and height.\n * @alias BoundingRectangle\n * @constructor\n *\n * @param {Number} [x=0.0] The x coordinate of the rectangle.\n * @param {Number} [y=0.0] The y coordinate of the rectangle.\n * @param {Number} [width=0.0] The width of the rectangle.\n * @param {Number} [height=0.0] The height of the rectangle.\n *\n * @see BoundingSphere\n * @see Packable\n */\nfunction BoundingRectangle(x, y, width, height) {\n  /**\n   * The x coordinate of the rectangle.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.x = defaultValue(x, 0.0);\n\n  /**\n   * The y coordinate of the rectangle.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.y = defaultValue(y, 0.0);\n\n  /**\n   * The width of the rectangle.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.width = defaultValue(width, 0.0);\n\n  /**\n   * The height of the rectangle.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.height = defaultValue(height, 0.0);\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nBoundingRectangle.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {BoundingRectangle} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nBoundingRectangle.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex++] = value.width;\n  array[startingIndex] = value.height;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {BoundingRectangle} [result] The object into which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\nBoundingRectangle.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex++];\n  result.width = array[startingIndex++];\n  result.height = array[startingIndex];\n  return result;\n};\n\n/**\n * Computes a bounding rectangle enclosing the list of 2D points.\n * The rectangle is oriented with the corner at the bottom left.\n *\n * @param {Cartesian2[]} positions List of points that the bounding rectangle will enclose.  Each point must have <code>x</code> and <code>y</code> properties.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\nBoundingRectangle.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.x = 0;\n    result.y = 0;\n    result.width = 0;\n    result.height = 0;\n    return result;\n  }\n\n  var length = positions.length;\n\n  var minimumX = positions[0].x;\n  var minimumY = positions[0].y;\n\n  var maximumX = positions[0].x;\n  var maximumY = positions[0].y;\n\n  for (var i = 1; i < length; i++) {\n    var p = positions[i];\n    var x = p.x;\n    var y = p.y;\n\n    minimumX = Math.min(x, minimumX);\n    maximumX = Math.max(x, maximumX);\n    minimumY = Math.min(y, minimumY);\n    maximumY = Math.max(y, maximumY);\n  }\n\n  result.x = minimumX;\n  result.y = minimumY;\n  result.width = maximumX - minimumX;\n  result.height = maximumY - minimumY;\n  return result;\n};\n\nvar defaultProjection = new GeographicProjection();\nvar fromRectangleLowerLeft = new Cartographic();\nvar fromRectangleUpperRight = new Cartographic();\n/**\n * Computes a bounding rectangle from a rectangle.\n *\n * @param {Rectangle} rectangle The valid rectangle used to create a bounding rectangle.\n * @param {Object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\nBoundingRectangle.fromRectangle = function (rectangle, projection, result) {\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n\n  if (!defined(rectangle)) {\n    result.x = 0;\n    result.y = 0;\n    result.width = 0;\n    result.height = 0;\n    return result;\n  }\n\n  projection = defaultValue(projection, defaultProjection);\n\n  var lowerLeft = projection.project(\n    Rectangle.southwest(rectangle, fromRectangleLowerLeft)\n  );\n  var upperRight = projection.project(\n    Rectangle.northeast(rectangle, fromRectangleUpperRight)\n  );\n\n  Cartesian2.subtract(upperRight, lowerLeft, upperRight);\n\n  result.x = lowerLeft.x;\n  result.y = lowerLeft.y;\n  result.width = upperRight.x;\n  result.height = upperRight.y;\n  return result;\n};\n\n/**\n * Duplicates a BoundingRectangle instance.\n *\n * @param {BoundingRectangle} rectangle The bounding rectangle to duplicate.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided. (Returns undefined if rectangle is undefined)\n */\nBoundingRectangle.clone = function (rectangle, result) {\n  if (!defined(rectangle)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new BoundingRectangle(\n      rectangle.x,\n      rectangle.y,\n      rectangle.width,\n      rectangle.height\n    );\n  }\n\n  result.x = rectangle.x;\n  result.y = rectangle.y;\n  result.width = rectangle.width;\n  result.height = rectangle.height;\n  return result;\n};\n\n/**\n * Computes a bounding rectangle that is the union of the left and right bounding rectangles.\n *\n * @param {BoundingRectangle} left A rectangle to enclose in bounding rectangle.\n * @param {BoundingRectangle} right A rectangle to enclose in a bounding rectangle.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\nBoundingRectangle.union = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n\n  var lowerLeftX = Math.min(left.x, right.x);\n  var lowerLeftY = Math.min(left.y, right.y);\n  var upperRightX = Math.max(left.x + left.width, right.x + right.width);\n  var upperRightY = Math.max(left.y + left.height, right.y + right.height);\n\n  result.x = lowerLeftX;\n  result.y = lowerLeftY;\n  result.width = upperRightX - lowerLeftX;\n  result.height = upperRightY - lowerLeftY;\n  return result;\n};\n\n/**\n * Computes a bounding rectangle by enlarging the provided rectangle until it contains the provided point.\n *\n * @param {BoundingRectangle} rectangle A rectangle to expand.\n * @param {Cartesian2} point A point to enclose in a bounding rectangle.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\nBoundingRectangle.expand = function (rectangle, point, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"point\", point);\n  //>>includeEnd('debug');\n\n  result = BoundingRectangle.clone(rectangle, result);\n\n  var width = point.x - result.x;\n  var height = point.y - result.y;\n\n  if (width > result.width) {\n    result.width = width;\n  } else if (width < 0) {\n    result.width -= width;\n    result.x = point.x;\n  }\n\n  if (height > result.height) {\n    result.height = height;\n  } else if (height < 0) {\n    result.height -= height;\n    result.y = point.y;\n  }\n\n  return result;\n};\n\n/**\n * Determines if two rectangles intersect.\n *\n * @param {BoundingRectangle} left A rectangle to check for intersection.\n * @param {BoundingRectangle} right The other rectangle to check for intersection.\n * @returns {Intersect} <code>Intersect.INTESECTING</code> if the rectangles intersect, <code>Intersect.OUTSIDE</code> otherwise.\n */\nBoundingRectangle.intersect = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  var leftX = left.x;\n  var leftY = left.y;\n  var rightX = right.x;\n  var rightY = right.y;\n  if (\n    !(\n      leftX > rightX + right.width ||\n      leftX + left.width < rightX ||\n      leftY + left.height < rightY ||\n      leftY > rightY + right.height\n    )\n  ) {\n    return Intersect.INTERSECTING;\n  }\n\n  return Intersect.OUTSIDE;\n};\n\n/**\n * Compares the provided BoundingRectangles componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {BoundingRectangle} [left] The first BoundingRectangle.\n * @param {BoundingRectangle} [right] The second BoundingRectangle.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nBoundingRectangle.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.x === right.x &&\n      left.y === right.y &&\n      left.width === right.width &&\n      left.height === right.height)\n  );\n};\n\n/**\n * Duplicates this BoundingRectangle instance.\n *\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\nBoundingRectangle.prototype.clone = function (result) {\n  return BoundingRectangle.clone(this, result);\n};\n\n/**\n * Determines if this rectangle intersects with another.\n *\n * @param {BoundingRectangle} right A rectangle to check for intersection.\n * @returns {Intersect} <code>Intersect.INTESECTING</code> if the rectangles intersect, <code>Intersect.OUTSIDE</code> otherwise.\n */\nBoundingRectangle.prototype.intersect = function (right) {\n  return BoundingRectangle.intersect(this, right);\n};\n\n/**\n * Compares this BoundingRectangle against the provided BoundingRectangle componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {BoundingRectangle} [right] The right hand side BoundingRectangle.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nBoundingRectangle.prototype.equals = function (right) {\n  return BoundingRectangle.equals(this, right);\n};\nexport default BoundingRectangle;\n"]},"metadata":{},"sourceType":"module"}