{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport scaleToGeodeticSurface from \"./scaleToGeodeticSurface.js\";\n\nfunction initialize(ellipsoid, x, y, z) {\n  x = defaultValue(x, 0.0);\n  y = defaultValue(y, 0.0);\n  z = defaultValue(z, 0.0); //>>includeStart('debug', pragmas.debug);\n\n  Check.typeOf.number.greaterThanOrEquals(\"x\", x, 0.0);\n  Check.typeOf.number.greaterThanOrEquals(\"y\", y, 0.0);\n  Check.typeOf.number.greaterThanOrEquals(\"z\", z, 0.0); //>>includeEnd('debug');\n\n  ellipsoid._radii = new Cartesian3(x, y, z);\n  ellipsoid._radiiSquared = new Cartesian3(x * x, y * y, z * z);\n  ellipsoid._radiiToTheFourth = new Cartesian3(x * x * x * x, y * y * y * y, z * z * z * z);\n  ellipsoid._oneOverRadii = new Cartesian3(x === 0.0 ? 0.0 : 1.0 / x, y === 0.0 ? 0.0 : 1.0 / y, z === 0.0 ? 0.0 : 1.0 / z);\n  ellipsoid._oneOverRadiiSquared = new Cartesian3(x === 0.0 ? 0.0 : 1.0 / (x * x), y === 0.0 ? 0.0 : 1.0 / (y * y), z === 0.0 ? 0.0 : 1.0 / (z * z));\n  ellipsoid._minimumRadius = Math.min(x, y, z);\n  ellipsoid._maximumRadius = Math.max(x, y, z);\n  ellipsoid._centerToleranceSquared = CesiumMath.EPSILON1;\n\n  if (ellipsoid._radiiSquared.z !== 0) {\n    ellipsoid._squaredXOverSquaredZ = ellipsoid._radiiSquared.x / ellipsoid._radiiSquared.z;\n  }\n}\n/**\n * A quadratic surface defined in Cartesian coordinates by the equation\n * <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used\n * by Cesium to represent the shape of planetary bodies.\n *\n * Rather than constructing this object directly, one of the provided\n * constants is normally used.\n * @alias Ellipsoid\n * @constructor\n *\n * @param {Number} [x=0] The radius in the x direction.\n * @param {Number} [y=0] The radius in the y direction.\n * @param {Number} [z=0] The radius in the z direction.\n *\n * @exception {DeveloperError} All radii components must be greater than or equal to zero.\n *\n * @see Ellipsoid.fromCartesian3\n * @see Ellipsoid.WGS84\n * @see Ellipsoid.UNIT_SPHERE\n */\n\n\nfunction Ellipsoid(x, y, z) {\n  this._radii = undefined;\n  this._radiiSquared = undefined;\n  this._radiiToTheFourth = undefined;\n  this._oneOverRadii = undefined;\n  this._oneOverRadiiSquared = undefined;\n  this._minimumRadius = undefined;\n  this._maximumRadius = undefined;\n  this._centerToleranceSquared = undefined;\n  this._squaredXOverSquaredZ = undefined;\n  initialize(this, x, y, z);\n}\n\nObject.defineProperties(Ellipsoid.prototype, {\n  /**\n   * Gets the radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radii: {\n    get: function () {\n      return this._radii;\n    }\n  },\n\n  /**\n   * Gets the squared radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radiiSquared: {\n    get: function () {\n      return this._radiiSquared;\n    }\n  },\n\n  /**\n   * Gets the radii of the ellipsoid raise to the fourth power.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radiiToTheFourth: {\n    get: function () {\n      return this._radiiToTheFourth;\n    }\n  },\n\n  /**\n   * Gets one over the radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  oneOverRadii: {\n    get: function () {\n      return this._oneOverRadii;\n    }\n  },\n\n  /**\n   * Gets one over the squared radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  oneOverRadiiSquared: {\n    get: function () {\n      return this._oneOverRadiiSquared;\n    }\n  },\n\n  /**\n   * Gets the minimum radius of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Number}\n   * @readonly\n   */\n  minimumRadius: {\n    get: function () {\n      return this._minimumRadius;\n    }\n  },\n\n  /**\n   * Gets the maximum radius of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Number}\n   * @readonly\n   */\n  maximumRadius: {\n    get: function () {\n      return this._maximumRadius;\n    }\n  }\n});\n/**\n * Duplicates an Ellipsoid instance.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to duplicate.\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} The cloned Ellipsoid. (Returns undefined if ellipsoid is undefined)\n */\n\nEllipsoid.clone = function (ellipsoid, result) {\n  if (!defined(ellipsoid)) {\n    return undefined;\n  }\n\n  var radii = ellipsoid._radii;\n\n  if (!defined(result)) {\n    return new Ellipsoid(radii.x, radii.y, radii.z);\n  }\n\n  Cartesian3.clone(radii, result._radii);\n  Cartesian3.clone(ellipsoid._radiiSquared, result._radiiSquared);\n  Cartesian3.clone(ellipsoid._radiiToTheFourth, result._radiiToTheFourth);\n  Cartesian3.clone(ellipsoid._oneOverRadii, result._oneOverRadii);\n  Cartesian3.clone(ellipsoid._oneOverRadiiSquared, result._oneOverRadiiSquared);\n  result._minimumRadius = ellipsoid._minimumRadius;\n  result._maximumRadius = ellipsoid._maximumRadius;\n  result._centerToleranceSquared = ellipsoid._centerToleranceSquared;\n  return result;\n};\n/**\n * Computes an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.\n *\n * @param {Cartesian3} [cartesian=Cartesian3.ZERO] The ellipsoid's radius in the x, y, and z directions.\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} A new Ellipsoid instance.\n *\n * @exception {DeveloperError} All radii components must be greater than or equal to zero.\n *\n * @see Ellipsoid.WGS84\n * @see Ellipsoid.UNIT_SPHERE\n */\n\n\nEllipsoid.fromCartesian3 = function (cartesian, result) {\n  if (!defined(result)) {\n    result = new Ellipsoid();\n  }\n\n  if (!defined(cartesian)) {\n    return result;\n  }\n\n  initialize(result, cartesian.x, cartesian.y, cartesian.z);\n  return result;\n};\n/**\n * An Ellipsoid instance initialized to the WGS84 standard.\n *\n * @type {Ellipsoid}\n * @constant\n */\n\n\nEllipsoid.WGS84 = Object.freeze(new Ellipsoid(6378137.0, 6378137.0, 6356752.3142451793));\n/**\n * An Ellipsoid instance initialized to radii of (1.0, 1.0, 1.0).\n *\n * @type {Ellipsoid}\n * @constant\n */\n\nEllipsoid.UNIT_SPHERE = Object.freeze(new Ellipsoid(1.0, 1.0, 1.0));\n/**\n * An Ellipsoid instance initialized to a sphere with the lunar radius.\n *\n * @type {Ellipsoid}\n * @constant\n */\n\nEllipsoid.MOON = Object.freeze(new Ellipsoid(CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS));\n/**\n * Duplicates an Ellipsoid instance.\n *\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} The cloned Ellipsoid.\n */\n\nEllipsoid.prototype.clone = function (result) {\n  return Ellipsoid.clone(this, result);\n};\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\n\n\nEllipsoid.packedLength = Cartesian3.packedLength;\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Ellipsoid} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\nEllipsoid.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  Cartesian3.pack(value._radii, array, startingIndex);\n  return array;\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Ellipsoid} [result] The object into which to store the result.\n * @returns {Ellipsoid} The modified result parameter or a new Ellipsoid instance if one was not provided.\n */\n\n\nEllipsoid.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var radii = Cartesian3.unpack(array, startingIndex);\n  return Ellipsoid.fromCartesian3(radii, result);\n};\n/**\n * Computes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position.\n * @function\n *\n * @param {Cartesian3} cartesian The Cartesian for which to to determine the geocentric normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\n\n\nEllipsoid.prototype.geocentricSurfaceNormal = Cartesian3.normalize;\n/**\n * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n *\n * @param {Cartographic} cartographic The cartographic position for which to to determine the geodetic normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\n\nEllipsoid.prototype.geodeticSurfaceNormalCartographic = function (cartographic, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartographic\", cartographic); //>>includeEnd('debug');\n\n  var longitude = cartographic.longitude;\n  var latitude = cartographic.latitude;\n  var cosLatitude = Math.cos(latitude);\n  var x = cosLatitude * Math.cos(longitude);\n  var y = cosLatitude * Math.sin(longitude);\n  var z = Math.sin(latitude);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return Cartesian3.normalize(result, result);\n};\n/**\n * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n *\n * @param {Cartesian3} cartesian The Cartesian position for which to to determine the surface normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\n\n\nEllipsoid.prototype.geodeticSurfaceNormal = function (cartesian, result) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  result = Cartesian3.multiplyComponents(cartesian, this._oneOverRadiiSquared, result);\n  return Cartesian3.normalize(result, result);\n};\n\nvar cartographicToCartesianNormal = new Cartesian3();\nvar cartographicToCartesianK = new Cartesian3();\n/**\n * Converts the provided cartographic to Cartesian representation.\n *\n * @param {Cartographic} cartographic The cartographic position.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n *\n * @example\n * //Create a Cartographic and determine it's Cartesian representation on a WGS84 ellipsoid.\n * var position = new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 5000);\n * var cartesianPosition = Cesium.Ellipsoid.WGS84.cartographicToCartesian(position);\n */\n\nEllipsoid.prototype.cartographicToCartesian = function (cartographic, result) {\n  //`cartographic is required` is thrown from geodeticSurfaceNormalCartographic.\n  var n = cartographicToCartesianNormal;\n  var k = cartographicToCartesianK;\n  this.geodeticSurfaceNormalCartographic(cartographic, n);\n  Cartesian3.multiplyComponents(this._radiiSquared, n, k);\n  var gamma = Math.sqrt(Cartesian3.dot(n, k));\n  Cartesian3.divideByScalar(k, gamma, k);\n  Cartesian3.multiplyByScalar(n, cartographic.height, n);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  return Cartesian3.add(k, n, result);\n};\n/**\n * Converts the provided array of cartographics to an array of Cartesians.\n *\n * @param {Cartographic[]} cartographics An array of cartographic positions.\n * @param {Cartesian3[]} [result] The object onto which to store the result.\n * @returns {Cartesian3[]} The modified result parameter or a new Array instance if none was provided.\n *\n * @example\n * //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.\n * var positions = [new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 0),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.321), Cesium.Math.toRadians(78.123), 100),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.645), Cesium.Math.toRadians(78.456), 250)];\n * var cartesianPositions = Cesium.Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);\n */\n\n\nEllipsoid.prototype.cartographicArrayToCartesianArray = function (cartographics, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartographics\", cartographics); //>>includeEnd('debug')\n\n  var length = cartographics.length;\n\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n\n  for (var i = 0; i < length; i++) {\n    result[i] = this.cartographicToCartesian(cartographics[i], result[i]);\n  }\n\n  return result;\n};\n\nvar cartesianToCartographicN = new Cartesian3();\nvar cartesianToCartographicP = new Cartesian3();\nvar cartesianToCartographicH = new Cartesian3();\n/**\n * Converts the provided cartesian to cartographic representation.\n * The cartesian is undefined at the center of the ellipsoid.\n *\n * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\n *\n * @example\n * //Create a Cartesian and determine it's Cartographic representation on a WGS84 ellipsoid.\n * var position = new Cesium.Cartesian3(17832.12, 83234.52, 952313.73);\n * var cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);\n */\n\nEllipsoid.prototype.cartesianToCartographic = function (cartesian, result) {\n  //`cartesian is required.` is thrown from scaleToGeodeticSurface\n  var p = this.scaleToGeodeticSurface(cartesian, cartesianToCartographicP);\n\n  if (!defined(p)) {\n    return undefined;\n  }\n\n  var n = this.geodeticSurfaceNormal(p, cartesianToCartographicN);\n  var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);\n  var longitude = Math.atan2(n.y, n.x);\n  var latitude = Math.asin(n.z);\n  var height = CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n/**\n * Converts the provided array of cartesians to an array of cartographics.\n *\n * @param {Cartesian3[]} cartesians An array of Cartesian positions.\n * @param {Cartographic[]} [result] The object onto which to store the result.\n * @returns {Cartographic[]} The modified result parameter or a new Array instance if none was provided.\n *\n * @example\n * //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.\n * var positions = [new Cesium.Cartesian3(17832.12, 83234.52, 952313.73),\n *                  new Cesium.Cartesian3(17832.13, 83234.53, 952313.73),\n *                  new Cesium.Cartesian3(17832.14, 83234.54, 952313.73)]\n * var cartographicPositions = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);\n */\n\n\nEllipsoid.prototype.cartesianArrayToCartographicArray = function (cartesians, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians); //>>includeEnd('debug');\n\n  var length = cartesians.length;\n\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    result[i] = this.cartesianToCartographic(cartesians[i], result[i]);\n  }\n\n  return result;\n};\n/**\n * Scales the provided Cartesian position along the geodetic surface normal\n * so that it is on the surface of this ellipsoid.  If the position is\n * at the center of the ellipsoid, this function returns undefined.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\n */\n\n\nEllipsoid.prototype.scaleToGeodeticSurface = function (cartesian, result) {\n  return scaleToGeodeticSurface(cartesian, this._oneOverRadii, this._oneOverRadiiSquared, this._centerToleranceSquared, result);\n};\n/**\n * Scales the provided Cartesian position along the geocentric surface normal\n * so that it is on the surface of this ellipsoid.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\n\n\nEllipsoid.prototype.scaleToGeocentricSurface = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  var positionX = cartesian.x;\n  var positionY = cartesian.y;\n  var positionZ = cartesian.z;\n  var oneOverRadiiSquared = this._oneOverRadiiSquared;\n  var beta = 1.0 / Math.sqrt(positionX * positionX * oneOverRadiiSquared.x + positionY * positionY * oneOverRadiiSquared.y + positionZ * positionZ * oneOverRadiiSquared.z);\n  return Cartesian3.multiplyByScalar(cartesian, beta, result);\n};\n/**\n * Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\n * its components by the result of {@link Ellipsoid#oneOverRadii}.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3} The position expressed in the scaled space.  The returned instance is the\n *          one passed as the result parameter if it is not undefined, or a new instance of it is.\n */\n\n\nEllipsoid.prototype.transformPositionToScaledSpace = function (position, result) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  return Cartesian3.multiplyComponents(position, this._oneOverRadii, result);\n};\n/**\n * Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\n * its components by the result of {@link Ellipsoid#radii}.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3} The position expressed in the unscaled space.  The returned instance is the\n *          one passed as the result parameter if it is not undefined, or a new instance of it is.\n */\n\n\nEllipsoid.prototype.transformPositionFromScaledSpace = function (position, result) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  return Cartesian3.multiplyComponents(position, this._radii, result);\n};\n/**\n * Compares this Ellipsoid against the provided Ellipsoid componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Ellipsoid} [right] The other Ellipsoid.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\n\n\nEllipsoid.prototype.equals = function (right) {\n  return this === right || defined(right) && Cartesian3.equals(this._radii, right._radii);\n};\n/**\n * Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n *\n * @returns {String} A string representing this ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n */\n\n\nEllipsoid.prototype.toString = function () {\n  return this._radii.toString();\n};\n/**\n * Computes a point which is the intersection of the surface normal with the z-axis.\n *\n * @param {Cartesian3} position the position. must be on the surface of the ellipsoid.\n * @param {Number} [buffer = 0.0] A buffer to subtract from the ellipsoid size when checking if the point is inside the ellipsoid.\n *                                In earth case, with common earth datums, there is no need for this buffer since the intersection point is always (relatively) very close to the center.\n *                                In WGS84 datum, intersection point is at max z = +-42841.31151331382 (0.673% of z-axis).\n *                                Intersection point could be outside the ellipsoid if the ratio of MajorAxis / AxisOfRotation is bigger than the square root of 2\n * @param {Cartesian3} [result] The cartesian to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3 | undefined} the intersection point if it's inside the ellipsoid, undefined otherwise\n *\n * @exception {DeveloperError} position is required.\n * @exception {DeveloperError} Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y).\n * @exception {DeveloperError} Ellipsoid.radii.z must be greater than 0.\n */\n\n\nEllipsoid.prototype.getSurfaceNormalIntersectionWithZAxis = function (position, buffer, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"position\", position);\n\n  if (!CesiumMath.equalsEpsilon(this._radii.x, this._radii.y, CesiumMath.EPSILON15)) {\n    throw new DeveloperError(\"Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\");\n  }\n\n  Check.typeOf.number.greaterThan(\"Ellipsoid.radii.z\", this._radii.z, 0); //>>includeEnd('debug');\n\n  buffer = defaultValue(buffer, 0.0);\n  var squaredXOverSquaredZ = this._squaredXOverSquaredZ;\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  result.x = 0.0;\n  result.y = 0.0;\n  result.z = position.z * (1 - squaredXOverSquaredZ);\n\n  if (Math.abs(result.z) >= this._radii.z - buffer) {\n    return undefined;\n  }\n\n  return result;\n};\n\nexport default Ellipsoid;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/Ellipsoid.js"],"names":["Cartesian3","Cartographic","Check","defaultValue","defined","DeveloperError","CesiumMath","scaleToGeodeticSurface","initialize","ellipsoid","x","y","z","typeOf","number","greaterThanOrEquals","_radii","_radiiSquared","_radiiToTheFourth","_oneOverRadii","_oneOverRadiiSquared","_minimumRadius","Math","min","_maximumRadius","max","_centerToleranceSquared","EPSILON1","_squaredXOverSquaredZ","Ellipsoid","undefined","Object","defineProperties","prototype","radii","get","radiiSquared","radiiToTheFourth","oneOverRadii","oneOverRadiiSquared","minimumRadius","maximumRadius","clone","result","fromCartesian3","cartesian","WGS84","freeze","UNIT_SPHERE","MOON","LUNAR_RADIUS","packedLength","pack","value","array","startingIndex","object","unpack","geocentricSurfaceNormal","normalize","geodeticSurfaceNormalCartographic","cartographic","longitude","latitude","cosLatitude","cos","sin","geodeticSurfaceNormal","multiplyComponents","cartographicToCartesianNormal","cartographicToCartesianK","cartographicToCartesian","n","k","gamma","sqrt","dot","divideByScalar","multiplyByScalar","height","add","cartographicArrayToCartesianArray","cartographics","length","Array","i","cartesianToCartographicN","cartesianToCartographicP","cartesianToCartographicH","cartesianToCartographic","p","h","subtract","atan2","asin","sign","magnitude","cartesianArrayToCartographicArray","cartesians","scaleToGeocentricSurface","positionX","positionY","positionZ","beta","transformPositionToScaledSpace","position","transformPositionFromScaledSpace","equals","right","toString","getSurfaceNormalIntersectionWithZAxis","buffer","equalsEpsilon","EPSILON15","greaterThan","squaredXOverSquaredZ","abs"],"mappings":"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","sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport scaleToGeodeticSurface from \"./scaleToGeodeticSurface.js\";\n\nfunction initialize(ellipsoid, x, y, z) {\n  x = defaultValue(x, 0.0);\n  y = defaultValue(y, 0.0);\n  z = defaultValue(z, 0.0);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"x\", x, 0.0);\n  Check.typeOf.number.greaterThanOrEquals(\"y\", y, 0.0);\n  Check.typeOf.number.greaterThanOrEquals(\"z\", z, 0.0);\n  //>>includeEnd('debug');\n\n  ellipsoid._radii = new Cartesian3(x, y, z);\n\n  ellipsoid._radiiSquared = new Cartesian3(x * x, y * y, z * z);\n\n  ellipsoid._radiiToTheFourth = new Cartesian3(\n    x * x * x * x,\n    y * y * y * y,\n    z * z * z * z\n  );\n\n  ellipsoid._oneOverRadii = new Cartesian3(\n    x === 0.0 ? 0.0 : 1.0 / x,\n    y === 0.0 ? 0.0 : 1.0 / y,\n    z === 0.0 ? 0.0 : 1.0 / z\n  );\n\n  ellipsoid._oneOverRadiiSquared = new Cartesian3(\n    x === 0.0 ? 0.0 : 1.0 / (x * x),\n    y === 0.0 ? 0.0 : 1.0 / (y * y),\n    z === 0.0 ? 0.0 : 1.0 / (z * z)\n  );\n\n  ellipsoid._minimumRadius = Math.min(x, y, z);\n\n  ellipsoid._maximumRadius = Math.max(x, y, z);\n\n  ellipsoid._centerToleranceSquared = CesiumMath.EPSILON1;\n\n  if (ellipsoid._radiiSquared.z !== 0) {\n    ellipsoid._squaredXOverSquaredZ =\n      ellipsoid._radiiSquared.x / ellipsoid._radiiSquared.z;\n  }\n}\n\n/**\n * A quadratic surface defined in Cartesian coordinates by the equation\n * <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used\n * by Cesium to represent the shape of planetary bodies.\n *\n * Rather than constructing this object directly, one of the provided\n * constants is normally used.\n * @alias Ellipsoid\n * @constructor\n *\n * @param {Number} [x=0] The radius in the x direction.\n * @param {Number} [y=0] The radius in the y direction.\n * @param {Number} [z=0] The radius in the z direction.\n *\n * @exception {DeveloperError} All radii components must be greater than or equal to zero.\n *\n * @see Ellipsoid.fromCartesian3\n * @see Ellipsoid.WGS84\n * @see Ellipsoid.UNIT_SPHERE\n */\nfunction Ellipsoid(x, y, z) {\n  this._radii = undefined;\n  this._radiiSquared = undefined;\n  this._radiiToTheFourth = undefined;\n  this._oneOverRadii = undefined;\n  this._oneOverRadiiSquared = undefined;\n  this._minimumRadius = undefined;\n  this._maximumRadius = undefined;\n  this._centerToleranceSquared = undefined;\n  this._squaredXOverSquaredZ = undefined;\n\n  initialize(this, x, y, z);\n}\n\nObject.defineProperties(Ellipsoid.prototype, {\n  /**\n   * Gets the radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radii: {\n    get: function () {\n      return this._radii;\n    },\n  },\n  /**\n   * Gets the squared radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radiiSquared: {\n    get: function () {\n      return this._radiiSquared;\n    },\n  },\n  /**\n   * Gets the radii of the ellipsoid raise to the fourth power.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radiiToTheFourth: {\n    get: function () {\n      return this._radiiToTheFourth;\n    },\n  },\n  /**\n   * Gets one over the radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  oneOverRadii: {\n    get: function () {\n      return this._oneOverRadii;\n    },\n  },\n  /**\n   * Gets one over the squared radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  oneOverRadiiSquared: {\n    get: function () {\n      return this._oneOverRadiiSquared;\n    },\n  },\n  /**\n   * Gets the minimum radius of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Number}\n   * @readonly\n   */\n  minimumRadius: {\n    get: function () {\n      return this._minimumRadius;\n    },\n  },\n  /**\n   * Gets the maximum radius of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Number}\n   * @readonly\n   */\n  maximumRadius: {\n    get: function () {\n      return this._maximumRadius;\n    },\n  },\n});\n\n/**\n * Duplicates an Ellipsoid instance.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to duplicate.\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} The cloned Ellipsoid. (Returns undefined if ellipsoid is undefined)\n */\nEllipsoid.clone = function (ellipsoid, result) {\n  if (!defined(ellipsoid)) {\n    return undefined;\n  }\n  var radii = ellipsoid._radii;\n\n  if (!defined(result)) {\n    return new Ellipsoid(radii.x, radii.y, radii.z);\n  }\n\n  Cartesian3.clone(radii, result._radii);\n  Cartesian3.clone(ellipsoid._radiiSquared, result._radiiSquared);\n  Cartesian3.clone(ellipsoid._radiiToTheFourth, result._radiiToTheFourth);\n  Cartesian3.clone(ellipsoid._oneOverRadii, result._oneOverRadii);\n  Cartesian3.clone(ellipsoid._oneOverRadiiSquared, result._oneOverRadiiSquared);\n  result._minimumRadius = ellipsoid._minimumRadius;\n  result._maximumRadius = ellipsoid._maximumRadius;\n  result._centerToleranceSquared = ellipsoid._centerToleranceSquared;\n\n  return result;\n};\n\n/**\n * Computes an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.\n *\n * @param {Cartesian3} [cartesian=Cartesian3.ZERO] The ellipsoid's radius in the x, y, and z directions.\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} A new Ellipsoid instance.\n *\n * @exception {DeveloperError} All radii components must be greater than or equal to zero.\n *\n * @see Ellipsoid.WGS84\n * @see Ellipsoid.UNIT_SPHERE\n */\nEllipsoid.fromCartesian3 = function (cartesian, result) {\n  if (!defined(result)) {\n    result = new Ellipsoid();\n  }\n\n  if (!defined(cartesian)) {\n    return result;\n  }\n\n  initialize(result, cartesian.x, cartesian.y, cartesian.z);\n  return result;\n};\n\n/**\n * An Ellipsoid instance initialized to the WGS84 standard.\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.WGS84 = Object.freeze(\n  new Ellipsoid(6378137.0, 6378137.0, 6356752.3142451793)\n);\n\n/**\n * An Ellipsoid instance initialized to radii of (1.0, 1.0, 1.0).\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.UNIT_SPHERE = Object.freeze(new Ellipsoid(1.0, 1.0, 1.0));\n\n/**\n * An Ellipsoid instance initialized to a sphere with the lunar radius.\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.MOON = Object.freeze(\n  new Ellipsoid(\n    CesiumMath.LUNAR_RADIUS,\n    CesiumMath.LUNAR_RADIUS,\n    CesiumMath.LUNAR_RADIUS\n  )\n);\n\n/**\n * Duplicates an Ellipsoid instance.\n *\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} The cloned Ellipsoid.\n */\nEllipsoid.prototype.clone = function (result) {\n  return Ellipsoid.clone(this, result);\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nEllipsoid.packedLength = Cartesian3.packedLength;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Ellipsoid} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nEllipsoid.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value._radii, array, startingIndex);\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Ellipsoid} [result] The object into which to store the result.\n * @returns {Ellipsoid} The modified result parameter or a new Ellipsoid instance if one was not provided.\n */\nEllipsoid.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var radii = Cartesian3.unpack(array, startingIndex);\n  return Ellipsoid.fromCartesian3(radii, result);\n};\n\n/**\n * Computes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position.\n * @function\n *\n * @param {Cartesian3} cartesian The Cartesian for which to to determine the geocentric normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.geocentricSurfaceNormal = Cartesian3.normalize;\n\n/**\n * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n *\n * @param {Cartographic} cartographic The cartographic position for which to to determine the geodetic normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.geodeticSurfaceNormalCartographic = function (\n  cartographic,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  var longitude = cartographic.longitude;\n  var latitude = cartographic.latitude;\n  var cosLatitude = Math.cos(latitude);\n\n  var x = cosLatitude * Math.cos(longitude);\n  var y = cosLatitude * Math.sin(longitude);\n  var z = Math.sin(latitude);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return Cartesian3.normalize(result, result);\n};\n\n/**\n * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n *\n * @param {Cartesian3} cartesian The Cartesian position for which to to determine the surface normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.geodeticSurfaceNormal = function (cartesian, result) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  result = Cartesian3.multiplyComponents(\n    cartesian,\n    this._oneOverRadiiSquared,\n    result\n  );\n  return Cartesian3.normalize(result, result);\n};\n\nvar cartographicToCartesianNormal = new Cartesian3();\nvar cartographicToCartesianK = new Cartesian3();\n\n/**\n * Converts the provided cartographic to Cartesian representation.\n *\n * @param {Cartographic} cartographic The cartographic position.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n *\n * @example\n * //Create a Cartographic and determine it's Cartesian representation on a WGS84 ellipsoid.\n * var position = new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 5000);\n * var cartesianPosition = Cesium.Ellipsoid.WGS84.cartographicToCartesian(position);\n */\nEllipsoid.prototype.cartographicToCartesian = function (cartographic, result) {\n  //`cartographic is required` is thrown from geodeticSurfaceNormalCartographic.\n  var n = cartographicToCartesianNormal;\n  var k = cartographicToCartesianK;\n  this.geodeticSurfaceNormalCartographic(cartographic, n);\n  Cartesian3.multiplyComponents(this._radiiSquared, n, k);\n  var gamma = Math.sqrt(Cartesian3.dot(n, k));\n  Cartesian3.divideByScalar(k, gamma, k);\n  Cartesian3.multiplyByScalar(n, cartographic.height, n);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  return Cartesian3.add(k, n, result);\n};\n\n/**\n * Converts the provided array of cartographics to an array of Cartesians.\n *\n * @param {Cartographic[]} cartographics An array of cartographic positions.\n * @param {Cartesian3[]} [result] The object onto which to store the result.\n * @returns {Cartesian3[]} The modified result parameter or a new Array instance if none was provided.\n *\n * @example\n * //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.\n * var positions = [new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 0),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.321), Cesium.Math.toRadians(78.123), 100),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.645), Cesium.Math.toRadians(78.456), 250)];\n * var cartesianPositions = Cesium.Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);\n */\nEllipsoid.prototype.cartographicArrayToCartesianArray = function (\n  cartographics,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartographics\", cartographics);\n  //>>includeEnd('debug')\n\n  var length = cartographics.length;\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n  for (var i = 0; i < length; i++) {\n    result[i] = this.cartographicToCartesian(cartographics[i], result[i]);\n  }\n  return result;\n};\n\nvar cartesianToCartographicN = new Cartesian3();\nvar cartesianToCartographicP = new Cartesian3();\nvar cartesianToCartographicH = new Cartesian3();\n\n/**\n * Converts the provided cartesian to cartographic representation.\n * The cartesian is undefined at the center of the ellipsoid.\n *\n * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\n *\n * @example\n * //Create a Cartesian and determine it's Cartographic representation on a WGS84 ellipsoid.\n * var position = new Cesium.Cartesian3(17832.12, 83234.52, 952313.73);\n * var cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);\n */\nEllipsoid.prototype.cartesianToCartographic = function (cartesian, result) {\n  //`cartesian is required.` is thrown from scaleToGeodeticSurface\n  var p = this.scaleToGeodeticSurface(cartesian, cartesianToCartographicP);\n\n  if (!defined(p)) {\n    return undefined;\n  }\n\n  var n = this.geodeticSurfaceNormal(p, cartesianToCartographicN);\n  var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);\n\n  var longitude = Math.atan2(n.y, n.x);\n  var latitude = Math.asin(n.z);\n  var height =\n    CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n\n/**\n * Converts the provided array of cartesians to an array of cartographics.\n *\n * @param {Cartesian3[]} cartesians An array of Cartesian positions.\n * @param {Cartographic[]} [result] The object onto which to store the result.\n * @returns {Cartographic[]} The modified result parameter or a new Array instance if none was provided.\n *\n * @example\n * //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.\n * var positions = [new Cesium.Cartesian3(17832.12, 83234.52, 952313.73),\n *                  new Cesium.Cartesian3(17832.13, 83234.53, 952313.73),\n *                  new Cesium.Cartesian3(17832.14, 83234.54, 952313.73)]\n * var cartographicPositions = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);\n */\nEllipsoid.prototype.cartesianArrayToCartographicArray = function (\n  cartesians,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  var length = cartesians.length;\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n  for (var i = 0; i < length; ++i) {\n    result[i] = this.cartesianToCartographic(cartesians[i], result[i]);\n  }\n  return result;\n};\n\n/**\n * Scales the provided Cartesian position along the geodetic surface normal\n * so that it is on the surface of this ellipsoid.  If the position is\n * at the center of the ellipsoid, this function returns undefined.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\n */\nEllipsoid.prototype.scaleToGeodeticSurface = function (cartesian, result) {\n  return scaleToGeodeticSurface(\n    cartesian,\n    this._oneOverRadii,\n    this._oneOverRadiiSquared,\n    this._centerToleranceSquared,\n    result\n  );\n};\n\n/**\n * Scales the provided Cartesian position along the geocentric surface normal\n * so that it is on the surface of this ellipsoid.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.scaleToGeocentricSurface = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  var positionX = cartesian.x;\n  var positionY = cartesian.y;\n  var positionZ = cartesian.z;\n  var oneOverRadiiSquared = this._oneOverRadiiSquared;\n\n  var beta =\n    1.0 /\n    Math.sqrt(\n      positionX * positionX * oneOverRadiiSquared.x +\n        positionY * positionY * oneOverRadiiSquared.y +\n        positionZ * positionZ * oneOverRadiiSquared.z\n    );\n\n  return Cartesian3.multiplyByScalar(cartesian, beta, result);\n};\n\n/**\n * Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\n * its components by the result of {@link Ellipsoid#oneOverRadii}.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3} The position expressed in the scaled space.  The returned instance is the\n *          one passed as the result parameter if it is not undefined, or a new instance of it is.\n */\nEllipsoid.prototype.transformPositionToScaledSpace = function (\n  position,\n  result\n) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  return Cartesian3.multiplyComponents(position, this._oneOverRadii, result);\n};\n\n/**\n * Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\n * its components by the result of {@link Ellipsoid#radii}.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3} The position expressed in the unscaled space.  The returned instance is the\n *          one passed as the result parameter if it is not undefined, or a new instance of it is.\n */\nEllipsoid.prototype.transformPositionFromScaledSpace = function (\n  position,\n  result\n) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  return Cartesian3.multiplyComponents(position, this._radii, result);\n};\n\n/**\n * Compares this Ellipsoid against the provided Ellipsoid componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Ellipsoid} [right] The other Ellipsoid.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nEllipsoid.prototype.equals = function (right) {\n  return (\n    this === right ||\n    (defined(right) && Cartesian3.equals(this._radii, right._radii))\n  );\n};\n\n/**\n * Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n *\n * @returns {String} A string representing this ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n */\nEllipsoid.prototype.toString = function () {\n  return this._radii.toString();\n};\n\n/**\n * Computes a point which is the intersection of the surface normal with the z-axis.\n *\n * @param {Cartesian3} position the position. must be on the surface of the ellipsoid.\n * @param {Number} [buffer = 0.0] A buffer to subtract from the ellipsoid size when checking if the point is inside the ellipsoid.\n *                                In earth case, with common earth datums, there is no need for this buffer since the intersection point is always (relatively) very close to the center.\n *                                In WGS84 datum, intersection point is at max z = +-42841.31151331382 (0.673% of z-axis).\n *                                Intersection point could be outside the ellipsoid if the ratio of MajorAxis / AxisOfRotation is bigger than the square root of 2\n * @param {Cartesian3} [result] The cartesian to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3 | undefined} the intersection point if it's inside the ellipsoid, undefined otherwise\n *\n * @exception {DeveloperError} position is required.\n * @exception {DeveloperError} Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y).\n * @exception {DeveloperError} Ellipsoid.radii.z must be greater than 0.\n */\nEllipsoid.prototype.getSurfaceNormalIntersectionWithZAxis = function (\n  position,\n  buffer,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"position\", position);\n\n  if (\n    !CesiumMath.equalsEpsilon(\n      this._radii.x,\n      this._radii.y,\n      CesiumMath.EPSILON15\n    )\n  ) {\n    throw new DeveloperError(\n      \"Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\"\n    );\n  }\n\n  Check.typeOf.number.greaterThan(\"Ellipsoid.radii.z\", this._radii.z, 0);\n  //>>includeEnd('debug');\n\n  buffer = defaultValue(buffer, 0.0);\n\n  var squaredXOverSquaredZ = this._squaredXOverSquaredZ;\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  result.x = 0.0;\n  result.y = 0.0;\n  result.z = position.z * (1 - squaredXOverSquaredZ);\n\n  if (Math.abs(result.z) >= this._radii.z - buffer) {\n    return undefined;\n  }\n\n  return result;\n};\nexport default Ellipsoid;\n"]},"metadata":{},"sourceType":"module"}