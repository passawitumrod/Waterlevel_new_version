{"ast":null,"code":"import earcut from \"../ThirdParty/earcut-2.2.1.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport WindingOrder from \"./WindingOrder.js\";\nvar scaleToGeodeticHeightN = new Cartesian3();\nvar scaleToGeodeticHeightP = new Cartesian3();\n/**\n * @private\n */\n\nvar PolygonPipeline = {};\n/**\n * @exception {DeveloperError} At least three positions are required.\n */\n\nPolygonPipeline.computeArea2D = function (positions) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"positions\", positions);\n  Check.typeOf.number.greaterThanOrEquals(\"positions.length\", positions.length, 3); //>>includeEnd('debug');\n\n  var length = positions.length;\n  var area = 0.0;\n\n  for (var i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {\n    var v0 = positions[i0];\n    var v1 = positions[i1];\n    area += v0.x * v1.y - v1.x * v0.y;\n  }\n\n  return area * 0.5;\n};\n/**\n * @returns {WindingOrder} The winding order.\n *\n * @exception {DeveloperError} At least three positions are required.\n */\n\n\nPolygonPipeline.computeWindingOrder2D = function (positions) {\n  var area = PolygonPipeline.computeArea2D(positions);\n  return area > 0.0 ? WindingOrder.COUNTER_CLOCKWISE : WindingOrder.CLOCKWISE;\n};\n/**\n * Triangulate a polygon.\n *\n * @param {Cartesian2[]} positions Cartesian2 array containing the vertices of the polygon\n * @param {Number[]} [holes] An array of the staring indices of the holes.\n * @returns {Number[]} Index array representing triangles that fill the polygon\n */\n\n\nPolygonPipeline.triangulate = function (positions, holes) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"positions\", positions); //>>includeEnd('debug');\n\n  var flattenedPositions = Cartesian2.packArray(positions);\n  return earcut(flattenedPositions, holes, 2);\n};\n\nvar subdivisionV0Scratch = new Cartesian3();\nvar subdivisionV1Scratch = new Cartesian3();\nvar subdivisionV2Scratch = new Cartesian3();\nvar subdivisionS0Scratch = new Cartesian3();\nvar subdivisionS1Scratch = new Cartesian3();\nvar subdivisionS2Scratch = new Cartesian3();\nvar subdivisionMidScratch = new Cartesian3();\n/**\n * Subdivides positions and raises points to the surface of the ellipsoid.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid the polygon in on.\n * @param {Cartesian3[]} positions An array of {@link Cartesian3} positions of the polygon.\n * @param {Number[]} indices An array of indices that determines the triangles in the polygon.\n * @param {Number} [granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n *\n * @exception {DeveloperError} At least three indices are required.\n * @exception {DeveloperError} The number of indices must be divisable by three.\n * @exception {DeveloperError} Granularity must be greater than zero.\n */\n\nPolygonPipeline.computeSubdivision = function (ellipsoid, positions, indices, granularity) {\n  granularity = defaultValue(granularity, CesiumMath.RADIANS_PER_DEGREE); //>>includeStart('debug', pragmas.debug);\n\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  Check.defined(\"positions\", positions);\n  Check.defined(\"indices\", indices);\n  Check.typeOf.number.greaterThanOrEquals(\"indices.length\", indices.length, 3);\n  Check.typeOf.number.equals(\"indices.length % 3\", \"0\", indices.length % 3, 0);\n  Check.typeOf.number.greaterThan(\"granularity\", granularity, 0.0); //>>includeEnd('debug');\n  // triangles that need (or might need) to be subdivided.\n\n  var triangles = indices.slice(0); // New positions due to edge splits are appended to the positions list.\n\n  var i;\n  var length = positions.length;\n  var subdividedPositions = new Array(length * 3);\n  var q = 0;\n\n  for (i = 0; i < length; i++) {\n    var item = positions[i];\n    subdividedPositions[q++] = item.x;\n    subdividedPositions[q++] = item.y;\n    subdividedPositions[q++] = item.z;\n  }\n\n  var subdividedIndices = []; // Used to make sure shared edges are not split more than once.\n\n  var edges = {};\n  var radius = ellipsoid.maximumRadius;\n  var minDistance = CesiumMath.chordLength(granularity, radius);\n  var minDistanceSqrd = minDistance * minDistance;\n\n  while (triangles.length > 0) {\n    var i2 = triangles.pop();\n    var i1 = triangles.pop();\n    var i0 = triangles.pop();\n    var v0 = Cartesian3.fromArray(subdividedPositions, i0 * 3, subdivisionV0Scratch);\n    var v1 = Cartesian3.fromArray(subdividedPositions, i1 * 3, subdivisionV1Scratch);\n    var v2 = Cartesian3.fromArray(subdividedPositions, i2 * 3, subdivisionV2Scratch);\n    var s0 = Cartesian3.multiplyByScalar(Cartesian3.normalize(v0, subdivisionS0Scratch), radius, subdivisionS0Scratch);\n    var s1 = Cartesian3.multiplyByScalar(Cartesian3.normalize(v1, subdivisionS1Scratch), radius, subdivisionS1Scratch);\n    var s2 = Cartesian3.multiplyByScalar(Cartesian3.normalize(v2, subdivisionS2Scratch), radius, subdivisionS2Scratch);\n    var g0 = Cartesian3.magnitudeSquared(Cartesian3.subtract(s0, s1, subdivisionMidScratch));\n    var g1 = Cartesian3.magnitudeSquared(Cartesian3.subtract(s1, s2, subdivisionMidScratch));\n    var g2 = Cartesian3.magnitudeSquared(Cartesian3.subtract(s2, s0, subdivisionMidScratch));\n    var max = Math.max(g0, g1, g2);\n    var edge;\n    var mid; // if the max length squared of a triangle edge is greater than the chord length of squared\n    // of the granularity, subdivide the triangle\n\n    if (max > minDistanceSqrd) {\n      if (g0 === max) {\n        edge = Math.min(i0, i1) + \" \" + Math.max(i0, i1);\n        i = edges[edge];\n\n        if (!defined(i)) {\n          mid = Cartesian3.add(v0, v1, subdivisionMidScratch);\n          Cartesian3.multiplyByScalar(mid, 0.5, mid);\n          subdividedPositions.push(mid.x, mid.y, mid.z);\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n        }\n\n        triangles.push(i0, i, i2);\n        triangles.push(i, i1, i2);\n      } else if (g1 === max) {\n        edge = Math.min(i1, i2) + \" \" + Math.max(i1, i2);\n        i = edges[edge];\n\n        if (!defined(i)) {\n          mid = Cartesian3.add(v1, v2, subdivisionMidScratch);\n          Cartesian3.multiplyByScalar(mid, 0.5, mid);\n          subdividedPositions.push(mid.x, mid.y, mid.z);\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n        }\n\n        triangles.push(i1, i, i0);\n        triangles.push(i, i2, i0);\n      } else if (g2 === max) {\n        edge = Math.min(i2, i0) + \" \" + Math.max(i2, i0);\n        i = edges[edge];\n\n        if (!defined(i)) {\n          mid = Cartesian3.add(v2, v0, subdivisionMidScratch);\n          Cartesian3.multiplyByScalar(mid, 0.5, mid);\n          subdividedPositions.push(mid.x, mid.y, mid.z);\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n        }\n\n        triangles.push(i2, i, i1);\n        triangles.push(i, i0, i1);\n      }\n    } else {\n      subdividedIndices.push(i0);\n      subdividedIndices.push(i1);\n      subdividedIndices.push(i2);\n    }\n  }\n\n  return new Geometry({\n    attributes: {\n      position: new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: subdividedPositions\n      })\n    },\n    indices: subdividedIndices,\n    primitiveType: PrimitiveType.TRIANGLES\n  });\n};\n\nvar subdivisionC0Scratch = new Cartographic();\nvar subdivisionC1Scratch = new Cartographic();\nvar subdivisionC2Scratch = new Cartographic();\nvar subdivisionCartographicScratch = new Cartographic();\n/**\n * Subdivides positions on rhumb lines and raises points to the surface of the ellipsoid.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid the polygon in on.\n * @param {Cartesian3[]} positions An array of {@link Cartesian3} positions of the polygon.\n * @param {Number[]} indices An array of indices that determines the triangles in the polygon.\n * @param {Number} [granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n *\n * @exception {DeveloperError} At least three indices are required.\n * @exception {DeveloperError} The number of indices must be divisable by three.\n * @exception {DeveloperError} Granularity must be greater than zero.\n */\n\nPolygonPipeline.computeRhumbLineSubdivision = function (ellipsoid, positions, indices, granularity) {\n  granularity = defaultValue(granularity, CesiumMath.RADIANS_PER_DEGREE); //>>includeStart('debug', pragmas.debug);\n\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  Check.defined(\"positions\", positions);\n  Check.defined(\"indices\", indices);\n  Check.typeOf.number.greaterThanOrEquals(\"indices.length\", indices.length, 3);\n  Check.typeOf.number.equals(\"indices.length % 3\", \"0\", indices.length % 3, 0);\n  Check.typeOf.number.greaterThan(\"granularity\", granularity, 0.0); //>>includeEnd('debug');\n  // triangles that need (or might need) to be subdivided.\n\n  var triangles = indices.slice(0); // New positions due to edge splits are appended to the positions list.\n\n  var i;\n  var length = positions.length;\n  var subdividedPositions = new Array(length * 3);\n  var q = 0;\n\n  for (i = 0; i < length; i++) {\n    var item = positions[i];\n    subdividedPositions[q++] = item.x;\n    subdividedPositions[q++] = item.y;\n    subdividedPositions[q++] = item.z;\n  }\n\n  var subdividedIndices = []; // Used to make sure shared edges are not split more than once.\n\n  var edges = {};\n  var radius = ellipsoid.maximumRadius;\n  var minDistance = CesiumMath.chordLength(granularity, radius);\n  var rhumb0 = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  var rhumb1 = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  var rhumb2 = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n\n  while (triangles.length > 0) {\n    var i2 = triangles.pop();\n    var i1 = triangles.pop();\n    var i0 = triangles.pop();\n    var v0 = Cartesian3.fromArray(subdividedPositions, i0 * 3, subdivisionV0Scratch);\n    var v1 = Cartesian3.fromArray(subdividedPositions, i1 * 3, subdivisionV1Scratch);\n    var v2 = Cartesian3.fromArray(subdividedPositions, i2 * 3, subdivisionV2Scratch);\n    var c0 = ellipsoid.cartesianToCartographic(v0, subdivisionC0Scratch);\n    var c1 = ellipsoid.cartesianToCartographic(v1, subdivisionC1Scratch);\n    var c2 = ellipsoid.cartesianToCartographic(v2, subdivisionC2Scratch);\n    rhumb0.setEndPoints(c0, c1);\n    var g0 = rhumb0.surfaceDistance;\n    rhumb1.setEndPoints(c1, c2);\n    var g1 = rhumb1.surfaceDistance;\n    rhumb2.setEndPoints(c2, c0);\n    var g2 = rhumb2.surfaceDistance;\n    var max = Math.max(g0, g1, g2);\n    var edge;\n    var mid;\n    var midHeight;\n    var midCartesian3; // if the max length squared of a triangle edge is greater than granularity, subdivide the triangle\n\n    if (max > minDistance) {\n      if (g0 === max) {\n        edge = Math.min(i0, i1) + \" \" + Math.max(i0, i1);\n        i = edges[edge];\n\n        if (!defined(i)) {\n          mid = rhumb0.interpolateUsingFraction(0.5, subdivisionCartographicScratch);\n          midHeight = (c0.height + c1.height) * 0.5;\n          midCartesian3 = Cartesian3.fromRadians(mid.longitude, mid.latitude, midHeight, ellipsoid, subdivisionMidScratch);\n          subdividedPositions.push(midCartesian3.x, midCartesian3.y, midCartesian3.z);\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n        }\n\n        triangles.push(i0, i, i2);\n        triangles.push(i, i1, i2);\n      } else if (g1 === max) {\n        edge = Math.min(i1, i2) + \" \" + Math.max(i1, i2);\n        i = edges[edge];\n\n        if (!defined(i)) {\n          mid = rhumb1.interpolateUsingFraction(0.5, subdivisionCartographicScratch);\n          midHeight = (c1.height + c2.height) * 0.5;\n          midCartesian3 = Cartesian3.fromRadians(mid.longitude, mid.latitude, midHeight, ellipsoid, subdivisionMidScratch);\n          subdividedPositions.push(midCartesian3.x, midCartesian3.y, midCartesian3.z);\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n        }\n\n        triangles.push(i1, i, i0);\n        triangles.push(i, i2, i0);\n      } else if (g2 === max) {\n        edge = Math.min(i2, i0) + \" \" + Math.max(i2, i0);\n        i = edges[edge];\n\n        if (!defined(i)) {\n          mid = rhumb2.interpolateUsingFraction(0.5, subdivisionCartographicScratch);\n          midHeight = (c2.height + c0.height) * 0.5;\n          midCartesian3 = Cartesian3.fromRadians(mid.longitude, mid.latitude, midHeight, ellipsoid, subdivisionMidScratch);\n          subdividedPositions.push(midCartesian3.x, midCartesian3.y, midCartesian3.z);\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n        }\n\n        triangles.push(i2, i, i1);\n        triangles.push(i, i0, i1);\n      }\n    } else {\n      subdividedIndices.push(i0);\n      subdividedIndices.push(i1);\n      subdividedIndices.push(i2);\n    }\n  }\n\n  return new Geometry({\n    attributes: {\n      position: new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: subdividedPositions\n      })\n    },\n    indices: subdividedIndices,\n    primitiveType: PrimitiveType.TRIANGLES\n  });\n};\n/**\n * Scales each position of a geometry's position attribute to a height, in place.\n *\n * @param {Number[]} positions The array of numbers representing the positions to be scaled\n * @param {Number} [height=0.0] The desired height to add to the positions\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n * @param {Boolean} [scaleToSurface=true] <code>true</code> if the positions need to be scaled to the surface before the height is added.\n * @returns {Number[]} The input array of positions, scaled to height\n */\n\n\nPolygonPipeline.scaleToGeodeticHeight = function (positions, height, ellipsoid, scaleToSurface) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  var n = scaleToGeodeticHeightN;\n  var p = scaleToGeodeticHeightP;\n  height = defaultValue(height, 0.0);\n  scaleToSurface = defaultValue(scaleToSurface, true);\n\n  if (defined(positions)) {\n    var length = positions.length;\n\n    for (var i = 0; i < length; i += 3) {\n      Cartesian3.fromArray(positions, i, p);\n\n      if (scaleToSurface) {\n        p = ellipsoid.scaleToGeodeticSurface(p, p);\n      }\n\n      if (height !== 0) {\n        n = ellipsoid.geodeticSurfaceNormal(p, n);\n        Cartesian3.multiplyByScalar(n, height, n);\n        Cartesian3.add(p, n, p);\n      }\n\n      positions[i] = p.x;\n      positions[i + 1] = p.y;\n      positions[i + 2] = p.z;\n    }\n  }\n\n  return positions;\n};\n\nexport default PolygonPipeline;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/PolygonPipeline.js"],"names":["earcut","Cartesian2","Cartesian3","Cartographic","Check","ComponentDatatype","defaultValue","defined","Ellipsoid","EllipsoidRhumbLine","Geometry","GeometryAttribute","CesiumMath","PrimitiveType","WindingOrder","scaleToGeodeticHeightN","scaleToGeodeticHeightP","PolygonPipeline","computeArea2D","positions","typeOf","number","greaterThanOrEquals","length","area","i0","i1","v0","v1","x","y","computeWindingOrder2D","COUNTER_CLOCKWISE","CLOCKWISE","triangulate","holes","flattenedPositions","packArray","subdivisionV0Scratch","subdivisionV1Scratch","subdivisionV2Scratch","subdivisionS0Scratch","subdivisionS1Scratch","subdivisionS2Scratch","subdivisionMidScratch","computeSubdivision","ellipsoid","indices","granularity","RADIANS_PER_DEGREE","object","equals","greaterThan","triangles","slice","i","subdividedPositions","Array","q","item","z","subdividedIndices","edges","radius","maximumRadius","minDistance","chordLength","minDistanceSqrd","i2","pop","fromArray","v2","s0","multiplyByScalar","normalize","s1","s2","g0","magnitudeSquared","subtract","g1","g2","max","Math","edge","mid","min","add","push","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","primitiveType","TRIANGLES","subdivisionC0Scratch","subdivisionC1Scratch","subdivisionC2Scratch","subdivisionCartographicScratch","computeRhumbLineSubdivision","rhumb0","undefined","rhumb1","rhumb2","c0","cartesianToCartographic","c1","c2","setEndPoints","surfaceDistance","midHeight","midCartesian3","interpolateUsingFraction","height","fromRadians","longitude","latitude","scaleToGeodeticHeight","scaleToSurface","WGS84","n","p","scaleToGeodeticSurface","geodeticSurfaceNormal"],"mappings":"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","sourcesContent":["import earcut from \"../ThirdParty/earcut-2.2.1.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport WindingOrder from \"./WindingOrder.js\";\n\nvar scaleToGeodeticHeightN = new Cartesian3();\nvar scaleToGeodeticHeightP = new Cartesian3();\n\n/**\n * @private\n */\nvar PolygonPipeline = {};\n\n/**\n * @exception {DeveloperError} At least three positions are required.\n */\nPolygonPipeline.computeArea2D = function (positions) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"positions\", positions);\n  Check.typeOf.number.greaterThanOrEquals(\n    \"positions.length\",\n    positions.length,\n    3\n  );\n  //>>includeEnd('debug');\n\n  var length = positions.length;\n  var area = 0.0;\n\n  for (var i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {\n    var v0 = positions[i0];\n    var v1 = positions[i1];\n\n    area += v0.x * v1.y - v1.x * v0.y;\n  }\n\n  return area * 0.5;\n};\n\n/**\n * @returns {WindingOrder} The winding order.\n *\n * @exception {DeveloperError} At least three positions are required.\n */\nPolygonPipeline.computeWindingOrder2D = function (positions) {\n  var area = PolygonPipeline.computeArea2D(positions);\n  return area > 0.0 ? WindingOrder.COUNTER_CLOCKWISE : WindingOrder.CLOCKWISE;\n};\n\n/**\n * Triangulate a polygon.\n *\n * @param {Cartesian2[]} positions Cartesian2 array containing the vertices of the polygon\n * @param {Number[]} [holes] An array of the staring indices of the holes.\n * @returns {Number[]} Index array representing triangles that fill the polygon\n */\nPolygonPipeline.triangulate = function (positions, holes) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"positions\", positions);\n  //>>includeEnd('debug');\n\n  var flattenedPositions = Cartesian2.packArray(positions);\n  return earcut(flattenedPositions, holes, 2);\n};\n\nvar subdivisionV0Scratch = new Cartesian3();\nvar subdivisionV1Scratch = new Cartesian3();\nvar subdivisionV2Scratch = new Cartesian3();\nvar subdivisionS0Scratch = new Cartesian3();\nvar subdivisionS1Scratch = new Cartesian3();\nvar subdivisionS2Scratch = new Cartesian3();\nvar subdivisionMidScratch = new Cartesian3();\n\n/**\n * Subdivides positions and raises points to the surface of the ellipsoid.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid the polygon in on.\n * @param {Cartesian3[]} positions An array of {@link Cartesian3} positions of the polygon.\n * @param {Number[]} indices An array of indices that determines the triangles in the polygon.\n * @param {Number} [granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n *\n * @exception {DeveloperError} At least three indices are required.\n * @exception {DeveloperError} The number of indices must be divisable by three.\n * @exception {DeveloperError} Granularity must be greater than zero.\n */\nPolygonPipeline.computeSubdivision = function (\n  ellipsoid,\n  positions,\n  indices,\n  granularity\n) {\n  granularity = defaultValue(granularity, CesiumMath.RADIANS_PER_DEGREE);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  Check.defined(\"positions\", positions);\n  Check.defined(\"indices\", indices);\n  Check.typeOf.number.greaterThanOrEquals(\"indices.length\", indices.length, 3);\n  Check.typeOf.number.equals(\"indices.length % 3\", \"0\", indices.length % 3, 0);\n  Check.typeOf.number.greaterThan(\"granularity\", granularity, 0.0);\n  //>>includeEnd('debug');\n\n  // triangles that need (or might need) to be subdivided.\n  var triangles = indices.slice(0);\n\n  // New positions due to edge splits are appended to the positions list.\n  var i;\n  var length = positions.length;\n  var subdividedPositions = new Array(length * 3);\n  var q = 0;\n  for (i = 0; i < length; i++) {\n    var item = positions[i];\n    subdividedPositions[q++] = item.x;\n    subdividedPositions[q++] = item.y;\n    subdividedPositions[q++] = item.z;\n  }\n\n  var subdividedIndices = [];\n\n  // Used to make sure shared edges are not split more than once.\n  var edges = {};\n\n  var radius = ellipsoid.maximumRadius;\n  var minDistance = CesiumMath.chordLength(granularity, radius);\n  var minDistanceSqrd = minDistance * minDistance;\n\n  while (triangles.length > 0) {\n    var i2 = triangles.pop();\n    var i1 = triangles.pop();\n    var i0 = triangles.pop();\n\n    var v0 = Cartesian3.fromArray(\n      subdividedPositions,\n      i0 * 3,\n      subdivisionV0Scratch\n    );\n    var v1 = Cartesian3.fromArray(\n      subdividedPositions,\n      i1 * 3,\n      subdivisionV1Scratch\n    );\n    var v2 = Cartesian3.fromArray(\n      subdividedPositions,\n      i2 * 3,\n      subdivisionV2Scratch\n    );\n\n    var s0 = Cartesian3.multiplyByScalar(\n      Cartesian3.normalize(v0, subdivisionS0Scratch),\n      radius,\n      subdivisionS0Scratch\n    );\n    var s1 = Cartesian3.multiplyByScalar(\n      Cartesian3.normalize(v1, subdivisionS1Scratch),\n      radius,\n      subdivisionS1Scratch\n    );\n    var s2 = Cartesian3.multiplyByScalar(\n      Cartesian3.normalize(v2, subdivisionS2Scratch),\n      radius,\n      subdivisionS2Scratch\n    );\n\n    var g0 = Cartesian3.magnitudeSquared(\n      Cartesian3.subtract(s0, s1, subdivisionMidScratch)\n    );\n    var g1 = Cartesian3.magnitudeSquared(\n      Cartesian3.subtract(s1, s2, subdivisionMidScratch)\n    );\n    var g2 = Cartesian3.magnitudeSquared(\n      Cartesian3.subtract(s2, s0, subdivisionMidScratch)\n    );\n\n    var max = Math.max(g0, g1, g2);\n    var edge;\n    var mid;\n\n    // if the max length squared of a triangle edge is greater than the chord length of squared\n    // of the granularity, subdivide the triangle\n    if (max > minDistanceSqrd) {\n      if (g0 === max) {\n        edge = Math.min(i0, i1) + \" \" + Math.max(i0, i1);\n\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = Cartesian3.add(v0, v1, subdivisionMidScratch);\n          Cartesian3.multiplyByScalar(mid, 0.5, mid);\n          subdividedPositions.push(mid.x, mid.y, mid.z);\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n        }\n\n        triangles.push(i0, i, i2);\n        triangles.push(i, i1, i2);\n      } else if (g1 === max) {\n        edge = Math.min(i1, i2) + \" \" + Math.max(i1, i2);\n\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = Cartesian3.add(v1, v2, subdivisionMidScratch);\n          Cartesian3.multiplyByScalar(mid, 0.5, mid);\n          subdividedPositions.push(mid.x, mid.y, mid.z);\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n        }\n\n        triangles.push(i1, i, i0);\n        triangles.push(i, i2, i0);\n      } else if (g2 === max) {\n        edge = Math.min(i2, i0) + \" \" + Math.max(i2, i0);\n\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = Cartesian3.add(v2, v0, subdivisionMidScratch);\n          Cartesian3.multiplyByScalar(mid, 0.5, mid);\n          subdividedPositions.push(mid.x, mid.y, mid.z);\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n        }\n\n        triangles.push(i2, i, i1);\n        triangles.push(i, i0, i1);\n      }\n    } else {\n      subdividedIndices.push(i0);\n      subdividedIndices.push(i1);\n      subdividedIndices.push(i2);\n    }\n  }\n\n  return new Geometry({\n    attributes: {\n      position: new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: subdividedPositions,\n      }),\n    },\n    indices: subdividedIndices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  });\n};\n\nvar subdivisionC0Scratch = new Cartographic();\nvar subdivisionC1Scratch = new Cartographic();\nvar subdivisionC2Scratch = new Cartographic();\nvar subdivisionCartographicScratch = new Cartographic();\n\n/**\n * Subdivides positions on rhumb lines and raises points to the surface of the ellipsoid.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid the polygon in on.\n * @param {Cartesian3[]} positions An array of {@link Cartesian3} positions of the polygon.\n * @param {Number[]} indices An array of indices that determines the triangles in the polygon.\n * @param {Number} [granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n *\n * @exception {DeveloperError} At least three indices are required.\n * @exception {DeveloperError} The number of indices must be divisable by three.\n * @exception {DeveloperError} Granularity must be greater than zero.\n */\nPolygonPipeline.computeRhumbLineSubdivision = function (\n  ellipsoid,\n  positions,\n  indices,\n  granularity\n) {\n  granularity = defaultValue(granularity, CesiumMath.RADIANS_PER_DEGREE);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  Check.defined(\"positions\", positions);\n  Check.defined(\"indices\", indices);\n  Check.typeOf.number.greaterThanOrEquals(\"indices.length\", indices.length, 3);\n  Check.typeOf.number.equals(\"indices.length % 3\", \"0\", indices.length % 3, 0);\n  Check.typeOf.number.greaterThan(\"granularity\", granularity, 0.0);\n  //>>includeEnd('debug');\n\n  // triangles that need (or might need) to be subdivided.\n  var triangles = indices.slice(0);\n\n  // New positions due to edge splits are appended to the positions list.\n  var i;\n  var length = positions.length;\n  var subdividedPositions = new Array(length * 3);\n  var q = 0;\n  for (i = 0; i < length; i++) {\n    var item = positions[i];\n    subdividedPositions[q++] = item.x;\n    subdividedPositions[q++] = item.y;\n    subdividedPositions[q++] = item.z;\n  }\n\n  var subdividedIndices = [];\n\n  // Used to make sure shared edges are not split more than once.\n  var edges = {};\n\n  var radius = ellipsoid.maximumRadius;\n  var minDistance = CesiumMath.chordLength(granularity, radius);\n\n  var rhumb0 = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  var rhumb1 = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  var rhumb2 = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n\n  while (triangles.length > 0) {\n    var i2 = triangles.pop();\n    var i1 = triangles.pop();\n    var i0 = triangles.pop();\n\n    var v0 = Cartesian3.fromArray(\n      subdividedPositions,\n      i0 * 3,\n      subdivisionV0Scratch\n    );\n    var v1 = Cartesian3.fromArray(\n      subdividedPositions,\n      i1 * 3,\n      subdivisionV1Scratch\n    );\n    var v2 = Cartesian3.fromArray(\n      subdividedPositions,\n      i2 * 3,\n      subdivisionV2Scratch\n    );\n\n    var c0 = ellipsoid.cartesianToCartographic(v0, subdivisionC0Scratch);\n    var c1 = ellipsoid.cartesianToCartographic(v1, subdivisionC1Scratch);\n    var c2 = ellipsoid.cartesianToCartographic(v2, subdivisionC2Scratch);\n\n    rhumb0.setEndPoints(c0, c1);\n    var g0 = rhumb0.surfaceDistance;\n    rhumb1.setEndPoints(c1, c2);\n    var g1 = rhumb1.surfaceDistance;\n    rhumb2.setEndPoints(c2, c0);\n    var g2 = rhumb2.surfaceDistance;\n\n    var max = Math.max(g0, g1, g2);\n    var edge;\n    var mid;\n    var midHeight;\n    var midCartesian3;\n\n    // if the max length squared of a triangle edge is greater than granularity, subdivide the triangle\n    if (max > minDistance) {\n      if (g0 === max) {\n        edge = Math.min(i0, i1) + \" \" + Math.max(i0, i1);\n\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = rhumb0.interpolateUsingFraction(\n            0.5,\n            subdivisionCartographicScratch\n          );\n          midHeight = (c0.height + c1.height) * 0.5;\n          midCartesian3 = Cartesian3.fromRadians(\n            mid.longitude,\n            mid.latitude,\n            midHeight,\n            ellipsoid,\n            subdivisionMidScratch\n          );\n          subdividedPositions.push(\n            midCartesian3.x,\n            midCartesian3.y,\n            midCartesian3.z\n          );\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n        }\n\n        triangles.push(i0, i, i2);\n        triangles.push(i, i1, i2);\n      } else if (g1 === max) {\n        edge = Math.min(i1, i2) + \" \" + Math.max(i1, i2);\n\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = rhumb1.interpolateUsingFraction(\n            0.5,\n            subdivisionCartographicScratch\n          );\n          midHeight = (c1.height + c2.height) * 0.5;\n          midCartesian3 = Cartesian3.fromRadians(\n            mid.longitude,\n            mid.latitude,\n            midHeight,\n            ellipsoid,\n            subdivisionMidScratch\n          );\n          subdividedPositions.push(\n            midCartesian3.x,\n            midCartesian3.y,\n            midCartesian3.z\n          );\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n        }\n\n        triangles.push(i1, i, i0);\n        triangles.push(i, i2, i0);\n      } else if (g2 === max) {\n        edge = Math.min(i2, i0) + \" \" + Math.max(i2, i0);\n\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = rhumb2.interpolateUsingFraction(\n            0.5,\n            subdivisionCartographicScratch\n          );\n          midHeight = (c2.height + c0.height) * 0.5;\n          midCartesian3 = Cartesian3.fromRadians(\n            mid.longitude,\n            mid.latitude,\n            midHeight,\n            ellipsoid,\n            subdivisionMidScratch\n          );\n          subdividedPositions.push(\n            midCartesian3.x,\n            midCartesian3.y,\n            midCartesian3.z\n          );\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n        }\n\n        triangles.push(i2, i, i1);\n        triangles.push(i, i0, i1);\n      }\n    } else {\n      subdividedIndices.push(i0);\n      subdividedIndices.push(i1);\n      subdividedIndices.push(i2);\n    }\n  }\n\n  return new Geometry({\n    attributes: {\n      position: new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: subdividedPositions,\n      }),\n    },\n    indices: subdividedIndices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  });\n};\n\n/**\n * Scales each position of a geometry's position attribute to a height, in place.\n *\n * @param {Number[]} positions The array of numbers representing the positions to be scaled\n * @param {Number} [height=0.0] The desired height to add to the positions\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n * @param {Boolean} [scaleToSurface=true] <code>true</code> if the positions need to be scaled to the surface before the height is added.\n * @returns {Number[]} The input array of positions, scaled to height\n */\nPolygonPipeline.scaleToGeodeticHeight = function (\n  positions,\n  height,\n  ellipsoid,\n  scaleToSurface\n) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  var n = scaleToGeodeticHeightN;\n  var p = scaleToGeodeticHeightP;\n\n  height = defaultValue(height, 0.0);\n  scaleToSurface = defaultValue(scaleToSurface, true);\n\n  if (defined(positions)) {\n    var length = positions.length;\n\n    for (var i = 0; i < length; i += 3) {\n      Cartesian3.fromArray(positions, i, p);\n\n      if (scaleToSurface) {\n        p = ellipsoid.scaleToGeodeticSurface(p, p);\n      }\n\n      if (height !== 0) {\n        n = ellipsoid.geodeticSurfaceNormal(p, n);\n\n        Cartesian3.multiplyByScalar(n, height, n);\n        Cartesian3.add(p, n, p);\n      }\n\n      positions[i] = p.x;\n      positions[i + 1] = p.y;\n      positions[i + 2] = p.z;\n    }\n  }\n\n  return positions;\n};\nexport default PolygonPipeline;\n"]},"metadata":{},"sourceType":"module"}