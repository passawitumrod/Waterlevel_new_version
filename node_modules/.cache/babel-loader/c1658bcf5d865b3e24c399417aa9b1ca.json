{"ast":null,"code":"import arraySlice from \"../Core/arraySlice.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport when from \"../ThirdParty/when.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport Vector3DTileBatch from \"./Vector3DTileBatch.js\";\nimport Vector3DTilePrimitive from \"./Vector3DTilePrimitive.js\";\n/**\n * Creates a batch of pre-triangulated polygons draped on terrain and/or 3D Tiles.\n *\n * @alias Vector3DTilePolygons\n * @constructor\n *\n * @param {Object} options An object with following properties:\n * @param {Float32Array|Uint16Array} options.positions The positions of the polygons. The positions must be contiguous\n * so that the positions for polygon n are in [c, c + counts[n]] where c = sum{counts[0], counts[n - 1]} and they are the outer ring of\n * the polygon in counter-clockwise order.\n * @param {Uint32Array} options.counts The number of positions in the each polygon.\n * @param {Uint32Array} options.indices The indices of the triangulated polygons. The indices must be contiguous so that\n * the indices for polygon n are in [i, i + indexCounts[n]] where i = sum{indexCounts[0], indexCounts[n - 1]}.\n * @param {Uint32Array} options.indexCounts The number of indices for each polygon.\n * @param {Number} options.minimumHeight The minimum height of the terrain covered by the tile.\n * @param {Number} options.maximumHeight The maximum height of the terrain covered by the tile.\n * @param {Float32Array} [options.polygonMinimumHeights] An array containing the minimum heights for each polygon.\n * @param {Float32Array} [options.polygonMaximumHeights] An array containing the maximum heights for each polygon.\n * @param {Rectangle} options.rectangle The rectangle containing the tile.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid.\n * @param {Cartesian3} [options.center=Cartesian3.ZERO] The RTC center.\n * @param {Cesium3DTileBatchTable} options.batchTable The batch table for the tile containing the batched polygons.\n * @param {Uint16Array} options.batchIds The batch ids for each polygon.\n * @param {BoundingSphere} options.boundingVolume The bounding volume for the entire batch of polygons.\n *\n * @private\n */\n\nfunction Vector3DTilePolygons(options) {\n  // All of the private properties will be released except _readyPromise\n  // and _primitive after the Vector3DTilePrimitive is created.\n  this._batchTable = options.batchTable;\n  this._batchIds = options.batchIds;\n  this._positions = options.positions;\n  this._counts = options.counts;\n  this._indices = options.indices;\n  this._indexCounts = options.indexCounts;\n  this._indexOffsets = undefined;\n  this._batchTableColors = undefined;\n  this._packedBuffer = undefined;\n  this._batchedPositions = undefined;\n  this._transferrableBatchIds = undefined;\n  this._vertexBatchIds = undefined;\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  this._minimumHeight = options.minimumHeight;\n  this._maximumHeight = options.maximumHeight;\n  this._polygonMinimumHeights = options.polygonMinimumHeights;\n  this._polygonMaximumHeights = options.polygonMaximumHeights;\n  this._center = defaultValue(options.center, Cartesian3.ZERO);\n  this._rectangle = options.rectangle;\n  this._center = undefined;\n  this._boundingVolume = options.boundingVolume;\n  this._boundingVolumes = undefined;\n  this._batchedIndices = undefined;\n  this._ready = false;\n  this._readyPromise = when.defer();\n  this._verticesPromise = undefined;\n  this._primitive = undefined;\n  /**\n   * Draws the wireframe of the classification meshes.\n   * @type {Boolean}\n   * @default false\n   */\n\n  this.debugWireframe = false;\n  /**\n   * Forces a re-batch instead of waiting after a number of frames have been rendered. For testing only.\n   * @type {Boolean}\n   * @default false\n   */\n\n  this.forceRebatch = false;\n  /**\n   * What this tile will classify.\n   * @type {ClassificationType}\n   * @default ClassificationType.BOTH\n   */\n\n  this.classificationType = ClassificationType.BOTH;\n}\n\nObject.defineProperties(Vector3DTilePolygons.prototype, {\n  /**\n   * Gets the number of triangles.\n   *\n   * @memberof Vector3DTilePolygons.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  trianglesLength: {\n    get: function get() {\n      if (defined(this._primitive)) {\n        return this._primitive.trianglesLength;\n      }\n\n      return 0;\n    }\n  },\n\n  /**\n   * Gets the geometry memory in bytes.\n   *\n   * @memberof Vector3DTilePolygons.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  geometryByteLength: {\n    get: function get() {\n      if (defined(this._primitive)) {\n        return this._primitive.geometryByteLength;\n      }\n\n      return 0;\n    }\n  },\n\n  /**\n   * Gets a promise that resolves when the primitive is ready to render.\n   * @memberof Vector3DTilePolygons.prototype\n   * @type {Promise}\n   * @readonly\n   */\n  readyPromise: {\n    get: function get() {\n      return this._readyPromise.promise;\n    }\n  }\n});\n\nfunction packBuffer(polygons) {\n  var packedBuffer = new Float64Array(3 + Cartesian3.packedLength + Ellipsoid.packedLength + Rectangle.packedLength);\n  var offset = 0;\n  packedBuffer[offset++] = polygons._indices.BYTES_PER_ELEMENT;\n  packedBuffer[offset++] = polygons._minimumHeight;\n  packedBuffer[offset++] = polygons._maximumHeight;\n  Cartesian3.pack(polygons._center, packedBuffer, offset);\n  offset += Cartesian3.packedLength;\n  Ellipsoid.pack(polygons._ellipsoid, packedBuffer, offset);\n  offset += Ellipsoid.packedLength;\n  Rectangle.pack(polygons._rectangle, packedBuffer, offset);\n  return packedBuffer;\n}\n\nfunction unpackBuffer(polygons, packedBuffer) {\n  var offset = 1;\n  var numBVS = packedBuffer[offset++];\n  var bvs = polygons._boundingVolumes = new Array(numBVS);\n\n  for (var i = 0; i < numBVS; ++i) {\n    bvs[i] = OrientedBoundingBox.unpack(packedBuffer, offset);\n    offset += OrientedBoundingBox.packedLength;\n  }\n\n  var numBatchedIndices = packedBuffer[offset++];\n  var bis = polygons._batchedIndices = new Array(numBatchedIndices);\n\n  for (var j = 0; j < numBatchedIndices; ++j) {\n    var color = Color.unpack(packedBuffer, offset);\n    offset += Color.packedLength;\n    var indexOffset = packedBuffer[offset++];\n    var count = packedBuffer[offset++];\n    var length = packedBuffer[offset++];\n    var batchIds = new Array(length);\n\n    for (var k = 0; k < length; ++k) {\n      batchIds[k] = packedBuffer[offset++];\n    }\n\n    bis[j] = new Vector3DTileBatch({\n      color: color,\n      offset: indexOffset,\n      count: count,\n      batchIds: batchIds\n    });\n  }\n}\n\nvar createVerticesTaskProcessor = new TaskProcessor(\"createVectorTilePolygons\");\nvar scratchColor = new Color();\n\nfunction createPrimitive(polygons) {\n  if (defined(polygons._primitive)) {\n    return;\n  }\n\n  if (!defined(polygons._verticesPromise)) {\n    var positions = polygons._positions;\n    var counts = polygons._counts;\n    var indexCounts = polygons._indexCounts;\n    var indices = polygons._indices;\n    var batchIds = polygons._transferrableBatchIds;\n    var batchTableColors = polygons._batchTableColors;\n    var packedBuffer = polygons._packedBuffer;\n\n    if (!defined(batchTableColors)) {\n      // Copy because they may be the views on the same buffer.\n      positions = polygons._positions = arraySlice(polygons._positions);\n      counts = polygons._counts = arraySlice(polygons._counts);\n      indexCounts = polygons._indexCounts = arraySlice(polygons._indexCounts);\n      indices = polygons._indices = arraySlice(polygons._indices);\n      polygons._center = polygons._ellipsoid.cartographicToCartesian(Rectangle.center(polygons._rectangle));\n      batchIds = polygons._transferrableBatchIds = new Uint32Array(polygons._batchIds);\n      batchTableColors = polygons._batchTableColors = new Uint32Array(batchIds.length);\n      var batchTable = polygons._batchTable;\n      var length = batchTableColors.length;\n\n      for (var i = 0; i < length; ++i) {\n        var color = batchTable.getColor(i, scratchColor);\n        batchTableColors[i] = color.toRgba();\n      }\n\n      packedBuffer = polygons._packedBuffer = packBuffer(polygons);\n    }\n\n    var transferrableObjects = [positions.buffer, counts.buffer, indexCounts.buffer, indices.buffer, batchIds.buffer, batchTableColors.buffer, packedBuffer.buffer];\n    var parameters = {\n      packedBuffer: packedBuffer.buffer,\n      positions: positions.buffer,\n      counts: counts.buffer,\n      indexCounts: indexCounts.buffer,\n      indices: indices.buffer,\n      batchIds: batchIds.buffer,\n      batchTableColors: batchTableColors.buffer\n    };\n    var minimumHeights = polygons._polygonMinimumHeights;\n    var maximumHeights = polygons._polygonMaximumHeights;\n\n    if (defined(minimumHeights) && defined(maximumHeights)) {\n      minimumHeights = arraySlice(minimumHeights);\n      maximumHeights = arraySlice(maximumHeights);\n      transferrableObjects.push(minimumHeights.buffer, maximumHeights.buffer);\n      parameters.minimumHeights = minimumHeights;\n      parameters.maximumHeights = maximumHeights;\n    }\n\n    var verticesPromise = polygons._verticesPromise = createVerticesTaskProcessor.scheduleTask(parameters, transferrableObjects);\n\n    if (!defined(verticesPromise)) {\n      // Postponed\n      return;\n    }\n\n    when(verticesPromise, function (result) {\n      polygons._positions = undefined;\n      polygons._counts = undefined;\n      polygons._polygonMinimumHeights = undefined;\n      polygons._polygonMaximumHeights = undefined;\n      var packedBuffer = new Float64Array(result.packedBuffer);\n      var indexDatatype = packedBuffer[0];\n      unpackBuffer(polygons, packedBuffer);\n      polygons._indices = IndexDatatype.getSizeInBytes(indexDatatype) === 2 ? new Uint16Array(result.indices) : new Uint32Array(result.indices);\n      polygons._indexOffsets = new Uint32Array(result.indexOffsets);\n      polygons._indexCounts = new Uint32Array(result.indexCounts); // will be released\n\n      polygons._batchedPositions = new Float32Array(result.positions);\n      polygons._vertexBatchIds = new Uint16Array(result.batchIds);\n      polygons._ready = true;\n    });\n  }\n\n  if (polygons._ready && !defined(polygons._primitive)) {\n    polygons._primitive = new Vector3DTilePrimitive({\n      batchTable: polygons._batchTable,\n      positions: polygons._batchedPositions,\n      batchIds: polygons._batchIds,\n      vertexBatchIds: polygons._vertexBatchIds,\n      indices: polygons._indices,\n      indexOffsets: polygons._indexOffsets,\n      indexCounts: polygons._indexCounts,\n      batchedIndices: polygons._batchedIndices,\n      boundingVolume: polygons._boundingVolume,\n      boundingVolumes: polygons._boundingVolumes,\n      center: polygons._center\n    });\n    polygons._batchTable = undefined;\n    polygons._batchIds = undefined;\n    polygons._positions = undefined;\n    polygons._counts = undefined;\n    polygons._indices = undefined;\n    polygons._indexCounts = undefined;\n    polygons._indexOffsets = undefined;\n    polygons._batchTableColors = undefined;\n    polygons._packedBuffer = undefined;\n    polygons._batchedPositions = undefined;\n    polygons._transferrableBatchIds = undefined;\n    polygons._vertexBatchIds = undefined;\n    polygons._ellipsoid = undefined;\n    polygons._minimumHeight = undefined;\n    polygons._maximumHeight = undefined;\n    polygons._polygonMinimumHeights = undefined;\n    polygons._polygonMaximumHeights = undefined;\n    polygons._center = undefined;\n    polygons._rectangle = undefined;\n    polygons._boundingVolume = undefined;\n    polygons._boundingVolumes = undefined;\n    polygons._batchedIndices = undefined;\n    polygons._verticesPromise = undefined;\n\n    polygons._readyPromise.resolve();\n  }\n}\n/**\n * Creates features for each polygon and places it at the batch id index of features.\n *\n * @param {Vector3DTileContent} content The vector tile content.\n * @param {Cesium3DTileFeature[]} features An array of features where the polygon features will be placed.\n */\n\n\nVector3DTilePolygons.prototype.createFeatures = function (content, features) {\n  this._primitive.createFeatures(content, features);\n};\n/**\n * Colors the entire tile when enabled is true. The resulting color will be (polygon batch table color * color).\n *\n * @param {Boolean} enabled Whether to enable debug coloring.\n * @param {Color} color The debug color.\n */\n\n\nVector3DTilePolygons.prototype.applyDebugSettings = function (enabled, color) {\n  this._primitive.applyDebugSettings(enabled, color);\n};\n/**\n * Apply a style to the content.\n *\n * @param {Cesium3DTileStyle} style The style.\n * @param {Cesium3DTileFeature[]} features The array of features.\n */\n\n\nVector3DTilePolygons.prototype.applyStyle = function (style, features) {\n  this._primitive.applyStyle(style, features);\n};\n/**\n * Call when updating the color of a polygon with batchId changes color. The polygons will need to be re-batched\n * on the next update.\n *\n * @param {Number} batchId The batch id of the polygon whose color has changed.\n * @param {Color} color The new polygon color.\n */\n\n\nVector3DTilePolygons.prototype.updateCommands = function (batchId, color) {\n  this._primitive.updateCommands(batchId, color);\n};\n/**\n * Updates the batches and queues the commands for rendering.\n *\n * @param {FrameState} frameState The current frame state.\n */\n\n\nVector3DTilePolygons.prototype.update = function (frameState) {\n  createPrimitive(this);\n\n  if (!this._ready) {\n    return;\n  }\n\n  this._primitive.debugWireframe = this.debugWireframe;\n  this._primitive.forceRebatch = this.forceRebatch;\n  this._primitive.classificationType = this.classificationType;\n\n  this._primitive.update(frameState);\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\n\n\nVector3DTilePolygons.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\n\n\nVector3DTilePolygons.prototype.destroy = function () {\n  this._primitive = this._primitive && this._primitive.destroy();\n  return destroyObject(this);\n};\n\nexport default Vector3DTilePolygons;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/Vector3DTilePolygons.js"],"names":["arraySlice","Cartesian3","Color","defaultValue","defined","destroyObject","Ellipsoid","IndexDatatype","OrientedBoundingBox","Rectangle","TaskProcessor","when","ClassificationType","Vector3DTileBatch","Vector3DTilePrimitive","Vector3DTilePolygons","options","_batchTable","batchTable","_batchIds","batchIds","_positions","positions","_counts","counts","_indices","indices","_indexCounts","indexCounts","_indexOffsets","undefined","_batchTableColors","_packedBuffer","_batchedPositions","_transferrableBatchIds","_vertexBatchIds","_ellipsoid","ellipsoid","WGS84","_minimumHeight","minimumHeight","_maximumHeight","maximumHeight","_polygonMinimumHeights","polygonMinimumHeights","_polygonMaximumHeights","polygonMaximumHeights","_center","center","ZERO","_rectangle","rectangle","_boundingVolume","boundingVolume","_boundingVolumes","_batchedIndices","_ready","_readyPromise","defer","_verticesPromise","_primitive","debugWireframe","forceRebatch","classificationType","BOTH","Object","defineProperties","prototype","trianglesLength","get","geometryByteLength","readyPromise","promise","packBuffer","polygons","packedBuffer","Float64Array","packedLength","offset","BYTES_PER_ELEMENT","pack","unpackBuffer","numBVS","bvs","Array","i","unpack","numBatchedIndices","bis","j","color","indexOffset","count","length","k","createVerticesTaskProcessor","scratchColor","createPrimitive","batchTableColors","cartographicToCartesian","Uint32Array","getColor","toRgba","transferrableObjects","buffer","parameters","minimumHeights","maximumHeights","push","verticesPromise","scheduleTask","result","indexDatatype","getSizeInBytes","Uint16Array","indexOffsets","Float32Array","vertexBatchIds","batchedIndices","boundingVolumes","resolve","createFeatures","content","features","applyDebugSettings","enabled","applyStyle","style","updateCommands","batchId","update","frameState","isDestroyed","destroy"],"mappings":"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","sourcesContent":["import arraySlice from \"../Core/arraySlice.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport when from \"../ThirdParty/when.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport Vector3DTileBatch from \"./Vector3DTileBatch.js\";\nimport Vector3DTilePrimitive from \"./Vector3DTilePrimitive.js\";\n\n/**\n * Creates a batch of pre-triangulated polygons draped on terrain and/or 3D Tiles.\n *\n * @alias Vector3DTilePolygons\n * @constructor\n *\n * @param {Object} options An object with following properties:\n * @param {Float32Array|Uint16Array} options.positions The positions of the polygons. The positions must be contiguous\n * so that the positions for polygon n are in [c, c + counts[n]] where c = sum{counts[0], counts[n - 1]} and they are the outer ring of\n * the polygon in counter-clockwise order.\n * @param {Uint32Array} options.counts The number of positions in the each polygon.\n * @param {Uint32Array} options.indices The indices of the triangulated polygons. The indices must be contiguous so that\n * the indices for polygon n are in [i, i + indexCounts[n]] where i = sum{indexCounts[0], indexCounts[n - 1]}.\n * @param {Uint32Array} options.indexCounts The number of indices for each polygon.\n * @param {Number} options.minimumHeight The minimum height of the terrain covered by the tile.\n * @param {Number} options.maximumHeight The maximum height of the terrain covered by the tile.\n * @param {Float32Array} [options.polygonMinimumHeights] An array containing the minimum heights for each polygon.\n * @param {Float32Array} [options.polygonMaximumHeights] An array containing the maximum heights for each polygon.\n * @param {Rectangle} options.rectangle The rectangle containing the tile.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid.\n * @param {Cartesian3} [options.center=Cartesian3.ZERO] The RTC center.\n * @param {Cesium3DTileBatchTable} options.batchTable The batch table for the tile containing the batched polygons.\n * @param {Uint16Array} options.batchIds The batch ids for each polygon.\n * @param {BoundingSphere} options.boundingVolume The bounding volume for the entire batch of polygons.\n *\n * @private\n */\nfunction Vector3DTilePolygons(options) {\n  // All of the private properties will be released except _readyPromise\n  // and _primitive after the Vector3DTilePrimitive is created.\n  this._batchTable = options.batchTable;\n\n  this._batchIds = options.batchIds;\n  this._positions = options.positions;\n  this._counts = options.counts;\n\n  this._indices = options.indices;\n  this._indexCounts = options.indexCounts;\n  this._indexOffsets = undefined;\n\n  this._batchTableColors = undefined;\n  this._packedBuffer = undefined;\n\n  this._batchedPositions = undefined;\n  this._transferrableBatchIds = undefined;\n  this._vertexBatchIds = undefined;\n\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  this._minimumHeight = options.minimumHeight;\n  this._maximumHeight = options.maximumHeight;\n  this._polygonMinimumHeights = options.polygonMinimumHeights;\n  this._polygonMaximumHeights = options.polygonMaximumHeights;\n  this._center = defaultValue(options.center, Cartesian3.ZERO);\n  this._rectangle = options.rectangle;\n\n  this._center = undefined;\n\n  this._boundingVolume = options.boundingVolume;\n  this._boundingVolumes = undefined;\n\n  this._batchedIndices = undefined;\n\n  this._ready = false;\n  this._readyPromise = when.defer();\n\n  this._verticesPromise = undefined;\n\n  this._primitive = undefined;\n\n  /**\n   * Draws the wireframe of the classification meshes.\n   * @type {Boolean}\n   * @default false\n   */\n  this.debugWireframe = false;\n\n  /**\n   * Forces a re-batch instead of waiting after a number of frames have been rendered. For testing only.\n   * @type {Boolean}\n   * @default false\n   */\n  this.forceRebatch = false;\n\n  /**\n   * What this tile will classify.\n   * @type {ClassificationType}\n   * @default ClassificationType.BOTH\n   */\n  this.classificationType = ClassificationType.BOTH;\n}\n\nObject.defineProperties(Vector3DTilePolygons.prototype, {\n  /**\n   * Gets the number of triangles.\n   *\n   * @memberof Vector3DTilePolygons.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  trianglesLength: {\n    get: function () {\n      if (defined(this._primitive)) {\n        return this._primitive.trianglesLength;\n      }\n      return 0;\n    },\n  },\n\n  /**\n   * Gets the geometry memory in bytes.\n   *\n   * @memberof Vector3DTilePolygons.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  geometryByteLength: {\n    get: function () {\n      if (defined(this._primitive)) {\n        return this._primitive.geometryByteLength;\n      }\n      return 0;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves when the primitive is ready to render.\n   * @memberof Vector3DTilePolygons.prototype\n   * @type {Promise}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n});\n\nfunction packBuffer(polygons) {\n  var packedBuffer = new Float64Array(\n    3 +\n      Cartesian3.packedLength +\n      Ellipsoid.packedLength +\n      Rectangle.packedLength\n  );\n\n  var offset = 0;\n  packedBuffer[offset++] = polygons._indices.BYTES_PER_ELEMENT;\n\n  packedBuffer[offset++] = polygons._minimumHeight;\n  packedBuffer[offset++] = polygons._maximumHeight;\n\n  Cartesian3.pack(polygons._center, packedBuffer, offset);\n  offset += Cartesian3.packedLength;\n\n  Ellipsoid.pack(polygons._ellipsoid, packedBuffer, offset);\n  offset += Ellipsoid.packedLength;\n\n  Rectangle.pack(polygons._rectangle, packedBuffer, offset);\n\n  return packedBuffer;\n}\n\nfunction unpackBuffer(polygons, packedBuffer) {\n  var offset = 1;\n\n  var numBVS = packedBuffer[offset++];\n  var bvs = (polygons._boundingVolumes = new Array(numBVS));\n\n  for (var i = 0; i < numBVS; ++i) {\n    bvs[i] = OrientedBoundingBox.unpack(packedBuffer, offset);\n    offset += OrientedBoundingBox.packedLength;\n  }\n\n  var numBatchedIndices = packedBuffer[offset++];\n  var bis = (polygons._batchedIndices = new Array(numBatchedIndices));\n\n  for (var j = 0; j < numBatchedIndices; ++j) {\n    var color = Color.unpack(packedBuffer, offset);\n    offset += Color.packedLength;\n\n    var indexOffset = packedBuffer[offset++];\n    var count = packedBuffer[offset++];\n\n    var length = packedBuffer[offset++];\n    var batchIds = new Array(length);\n\n    for (var k = 0; k < length; ++k) {\n      batchIds[k] = packedBuffer[offset++];\n    }\n\n    bis[j] = new Vector3DTileBatch({\n      color: color,\n      offset: indexOffset,\n      count: count,\n      batchIds: batchIds,\n    });\n  }\n}\n\nvar createVerticesTaskProcessor = new TaskProcessor(\"createVectorTilePolygons\");\nvar scratchColor = new Color();\n\nfunction createPrimitive(polygons) {\n  if (defined(polygons._primitive)) {\n    return;\n  }\n\n  if (!defined(polygons._verticesPromise)) {\n    var positions = polygons._positions;\n    var counts = polygons._counts;\n    var indexCounts = polygons._indexCounts;\n    var indices = polygons._indices;\n\n    var batchIds = polygons._transferrableBatchIds;\n    var batchTableColors = polygons._batchTableColors;\n\n    var packedBuffer = polygons._packedBuffer;\n\n    if (!defined(batchTableColors)) {\n      // Copy because they may be the views on the same buffer.\n      positions = polygons._positions = arraySlice(polygons._positions);\n      counts = polygons._counts = arraySlice(polygons._counts);\n      indexCounts = polygons._indexCounts = arraySlice(polygons._indexCounts);\n      indices = polygons._indices = arraySlice(polygons._indices);\n\n      polygons._center = polygons._ellipsoid.cartographicToCartesian(\n        Rectangle.center(polygons._rectangle)\n      );\n\n      batchIds = polygons._transferrableBatchIds = new Uint32Array(\n        polygons._batchIds\n      );\n      batchTableColors = polygons._batchTableColors = new Uint32Array(\n        batchIds.length\n      );\n      var batchTable = polygons._batchTable;\n\n      var length = batchTableColors.length;\n      for (var i = 0; i < length; ++i) {\n        var color = batchTable.getColor(i, scratchColor);\n        batchTableColors[i] = color.toRgba();\n      }\n\n      packedBuffer = polygons._packedBuffer = packBuffer(polygons);\n    }\n\n    var transferrableObjects = [\n      positions.buffer,\n      counts.buffer,\n      indexCounts.buffer,\n      indices.buffer,\n      batchIds.buffer,\n      batchTableColors.buffer,\n      packedBuffer.buffer,\n    ];\n    var parameters = {\n      packedBuffer: packedBuffer.buffer,\n      positions: positions.buffer,\n      counts: counts.buffer,\n      indexCounts: indexCounts.buffer,\n      indices: indices.buffer,\n      batchIds: batchIds.buffer,\n      batchTableColors: batchTableColors.buffer,\n    };\n\n    var minimumHeights = polygons._polygonMinimumHeights;\n    var maximumHeights = polygons._polygonMaximumHeights;\n    if (defined(minimumHeights) && defined(maximumHeights)) {\n      minimumHeights = arraySlice(minimumHeights);\n      maximumHeights = arraySlice(maximumHeights);\n\n      transferrableObjects.push(minimumHeights.buffer, maximumHeights.buffer);\n      parameters.minimumHeights = minimumHeights;\n      parameters.maximumHeights = maximumHeights;\n    }\n\n    var verticesPromise = (polygons._verticesPromise = createVerticesTaskProcessor.scheduleTask(\n      parameters,\n      transferrableObjects\n    ));\n    if (!defined(verticesPromise)) {\n      // Postponed\n      return;\n    }\n\n    when(verticesPromise, function (result) {\n      polygons._positions = undefined;\n      polygons._counts = undefined;\n      polygons._polygonMinimumHeights = undefined;\n      polygons._polygonMaximumHeights = undefined;\n\n      var packedBuffer = new Float64Array(result.packedBuffer);\n      var indexDatatype = packedBuffer[0];\n      unpackBuffer(polygons, packedBuffer);\n\n      polygons._indices =\n        IndexDatatype.getSizeInBytes(indexDatatype) === 2\n          ? new Uint16Array(result.indices)\n          : new Uint32Array(result.indices);\n      polygons._indexOffsets = new Uint32Array(result.indexOffsets);\n      polygons._indexCounts = new Uint32Array(result.indexCounts);\n\n      // will be released\n      polygons._batchedPositions = new Float32Array(result.positions);\n      polygons._vertexBatchIds = new Uint16Array(result.batchIds);\n\n      polygons._ready = true;\n    });\n  }\n\n  if (polygons._ready && !defined(polygons._primitive)) {\n    polygons._primitive = new Vector3DTilePrimitive({\n      batchTable: polygons._batchTable,\n      positions: polygons._batchedPositions,\n      batchIds: polygons._batchIds,\n      vertexBatchIds: polygons._vertexBatchIds,\n      indices: polygons._indices,\n      indexOffsets: polygons._indexOffsets,\n      indexCounts: polygons._indexCounts,\n      batchedIndices: polygons._batchedIndices,\n      boundingVolume: polygons._boundingVolume,\n      boundingVolumes: polygons._boundingVolumes,\n      center: polygons._center,\n    });\n\n    polygons._batchTable = undefined;\n    polygons._batchIds = undefined;\n    polygons._positions = undefined;\n    polygons._counts = undefined;\n    polygons._indices = undefined;\n    polygons._indexCounts = undefined;\n    polygons._indexOffsets = undefined;\n    polygons._batchTableColors = undefined;\n    polygons._packedBuffer = undefined;\n    polygons._batchedPositions = undefined;\n    polygons._transferrableBatchIds = undefined;\n    polygons._vertexBatchIds = undefined;\n    polygons._ellipsoid = undefined;\n    polygons._minimumHeight = undefined;\n    polygons._maximumHeight = undefined;\n    polygons._polygonMinimumHeights = undefined;\n    polygons._polygonMaximumHeights = undefined;\n    polygons._center = undefined;\n    polygons._rectangle = undefined;\n    polygons._boundingVolume = undefined;\n    polygons._boundingVolumes = undefined;\n    polygons._batchedIndices = undefined;\n    polygons._verticesPromise = undefined;\n\n    polygons._readyPromise.resolve();\n  }\n}\n\n/**\n * Creates features for each polygon and places it at the batch id index of features.\n *\n * @param {Vector3DTileContent} content The vector tile content.\n * @param {Cesium3DTileFeature[]} features An array of features where the polygon features will be placed.\n */\nVector3DTilePolygons.prototype.createFeatures = function (content, features) {\n  this._primitive.createFeatures(content, features);\n};\n\n/**\n * Colors the entire tile when enabled is true. The resulting color will be (polygon batch table color * color).\n *\n * @param {Boolean} enabled Whether to enable debug coloring.\n * @param {Color} color The debug color.\n */\nVector3DTilePolygons.prototype.applyDebugSettings = function (enabled, color) {\n  this._primitive.applyDebugSettings(enabled, color);\n};\n\n/**\n * Apply a style to the content.\n *\n * @param {Cesium3DTileStyle} style The style.\n * @param {Cesium3DTileFeature[]} features The array of features.\n */\nVector3DTilePolygons.prototype.applyStyle = function (style, features) {\n  this._primitive.applyStyle(style, features);\n};\n\n/**\n * Call when updating the color of a polygon with batchId changes color. The polygons will need to be re-batched\n * on the next update.\n *\n * @param {Number} batchId The batch id of the polygon whose color has changed.\n * @param {Color} color The new polygon color.\n */\nVector3DTilePolygons.prototype.updateCommands = function (batchId, color) {\n  this._primitive.updateCommands(batchId, color);\n};\n\n/**\n * Updates the batches and queues the commands for rendering.\n *\n * @param {FrameState} frameState The current frame state.\n */\nVector3DTilePolygons.prototype.update = function (frameState) {\n  createPrimitive(this);\n\n  if (!this._ready) {\n    return;\n  }\n\n  this._primitive.debugWireframe = this.debugWireframe;\n  this._primitive.forceRebatch = this.forceRebatch;\n  this._primitive.classificationType = this.classificationType;\n  this._primitive.update(frameState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\nVector3DTilePolygons.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nVector3DTilePolygons.prototype.destroy = function () {\n  this._primitive = this._primitive && this._primitive.destroy();\n  return destroyObject(this);\n};\nexport default Vector3DTilePolygons;\n"]},"metadata":{},"sourceType":"module"}