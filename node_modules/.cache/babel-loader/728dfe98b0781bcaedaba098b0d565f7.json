{"ast":null,"code":"import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport webGLConstantToGlslType from \"../Core/webGLConstantToGlslType.js\";\nimport addToArray from \"../ThirdParty/GltfPipeline/addToArray.js\";\nimport ForEach from \"../ThirdParty/GltfPipeline/ForEach.js\";\nimport hasExtension from \"../ThirdParty/GltfPipeline/hasExtension.js\";\nimport numberOfComponentsForType from \"../ThirdParty/GltfPipeline/numberOfComponentsForType.js\";\nimport ModelUtility from \"./ModelUtility.js\";\n/**\n * @private\n */\n\nfunction processPbrMaterials(gltf, options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); // No need to create new techniques if they already exist,\n  // the shader should handle these values\n\n  if (hasExtension(gltf, \"KHR_techniques_webgl\")) {\n    return gltf;\n  } // All materials in glTF are PBR by default,\n  // so we should apply PBR unless no materials are found.\n\n\n  if (!defined(gltf.materials) || gltf.materials.length === 0) {\n    return gltf;\n  }\n\n  if (!defined(gltf.extensions)) {\n    gltf.extensions = {};\n  }\n\n  if (!defined(gltf.extensionsUsed)) {\n    gltf.extensionsUsed = [];\n  }\n\n  if (!defined(gltf.extensionsRequired)) {\n    gltf.extensionsRequired = [];\n  }\n\n  gltf.extensions.KHR_techniques_webgl = {\n    programs: [],\n    shaders: [],\n    techniques: []\n  };\n  gltf.extensionsUsed.push(\"KHR_techniques_webgl\");\n  gltf.extensionsRequired.push(\"KHR_techniques_webgl\");\n  var primitiveByMaterial = ModelUtility.splitIncompatibleMaterials(gltf);\n  ForEach.material(gltf, function (material, materialIndex) {\n    var generatedMaterialValues = {};\n    var technique = generateTechnique(gltf, material, materialIndex, generatedMaterialValues, primitiveByMaterial, options);\n\n    if (!defined(material.extensions)) {\n      material.extensions = {};\n    }\n\n    material.extensions.KHR_techniques_webgl = {\n      values: generatedMaterialValues,\n      technique: technique\n    };\n  }); // If any primitives have semantics that aren't declared in the generated\n  // shaders, we want to preserve them.\n\n  ModelUtility.ensureSemanticExistence(gltf);\n  return gltf;\n}\n\nfunction isSpecularGlossinessMaterial(material) {\n  return defined(material.extensions) && defined(material.extensions.KHR_materials_pbrSpecularGlossiness);\n}\n\nfunction addTextureCoordinates(gltf, textureName, generatedMaterialValues, defaultTexCoord, result) {\n  var texCoord;\n\n  if (defined(generatedMaterialValues[textureName + \"Offset\"])) {\n    texCoord = textureName + \"Coord\";\n    result.fragmentShaderMain += \"    vec2 \" + texCoord + \" = computeTexCoord(\" + defaultTexCoord + \", \" + textureName + \"Offset, \" + textureName + \"Rotation, \" + textureName + \"Scale);\\n\";\n  } else {\n    texCoord = defaultTexCoord;\n  }\n\n  return texCoord;\n}\n\nvar DEFAULT_TEXTURE_OFFSET = [0.0, 0.0];\nvar DEFAULT_TEXTURE_ROTATION = [0.0];\nvar DEFAULT_TEXTURE_SCALE = [1.0, 1.0];\n\nfunction handleKHRTextureTransform(parameterName, value, generatedMaterialValues) {\n  if (parameterName.indexOf(\"Texture\") === -1 || !defined(value.extensions) || !defined(value.extensions.KHR_texture_transform)) {\n    return;\n  }\n\n  var uniformName = \"u_\" + parameterName;\n  var extension = value.extensions.KHR_texture_transform;\n  generatedMaterialValues[uniformName + \"Offset\"] = defaultValue(extension.offset, DEFAULT_TEXTURE_OFFSET);\n  generatedMaterialValues[uniformName + \"Rotation\"] = defaultValue(extension.rotation, DEFAULT_TEXTURE_ROTATION);\n  generatedMaterialValues[uniformName + \"Scale\"] = defaultValue(extension.scale, DEFAULT_TEXTURE_SCALE);\n\n  if (defined(value.texCoord) && defined(extension.texCoord)) {\n    generatedMaterialValues[uniformName].texCoord = extension.texCoord;\n  }\n}\n\nfunction generateTechnique(gltf, material, materialIndex, generatedMaterialValues, primitiveByMaterial, options) {\n  var addBatchIdToGeneratedShaders = defaultValue(options.addBatchIdToGeneratedShaders, false);\n  var techniquesWebgl = gltf.extensions.KHR_techniques_webgl;\n  var techniques = techniquesWebgl.techniques;\n  var shaders = techniquesWebgl.shaders;\n  var programs = techniquesWebgl.programs;\n  var useSpecGloss = isSpecularGlossinessMaterial(material);\n  var uniformName;\n  var parameterName;\n  var value;\n  var pbrMetallicRoughness = material.pbrMetallicRoughness;\n\n  if (defined(pbrMetallicRoughness) && !useSpecGloss) {\n    for (parameterName in pbrMetallicRoughness) {\n      if (pbrMetallicRoughness.hasOwnProperty(parameterName)) {\n        value = pbrMetallicRoughness[parameterName];\n        uniformName = \"u_\" + parameterName;\n        generatedMaterialValues[uniformName] = value;\n        handleKHRTextureTransform(parameterName, value, generatedMaterialValues);\n      }\n    }\n  }\n\n  if (useSpecGloss) {\n    var pbrSpecularGlossiness = material.extensions.KHR_materials_pbrSpecularGlossiness;\n\n    for (parameterName in pbrSpecularGlossiness) {\n      if (pbrSpecularGlossiness.hasOwnProperty(parameterName)) {\n        value = pbrSpecularGlossiness[parameterName];\n        uniformName = \"u_\" + parameterName;\n        generatedMaterialValues[uniformName] = value;\n        handleKHRTextureTransform(parameterName, value, generatedMaterialValues);\n      }\n    }\n  }\n\n  for (var additional in material) {\n    if (material.hasOwnProperty(additional) && (additional.indexOf(\"Texture\") >= 0 || additional.indexOf(\"Factor\") >= 0)) {\n      value = material[additional];\n      uniformName = \"u_\" + additional;\n      generatedMaterialValues[uniformName] = value;\n      handleKHRTextureTransform(additional, value, generatedMaterialValues);\n    }\n  }\n\n  var vertexShader = \"precision highp float;\\n\";\n  var fragmentShader = \"precision highp float;\\n\";\n  var skin;\n\n  if (defined(gltf.skins)) {\n    skin = gltf.skins[0];\n  }\n\n  var joints = defined(skin) ? skin.joints : [];\n  var jointCount = joints.length;\n  var primitiveInfo = primitiveByMaterial[materialIndex];\n  var skinningInfo;\n  var hasSkinning = false;\n  var hasVertexColors = false;\n  var hasMorphTargets = false;\n  var hasNormals = false;\n  var hasTangents = false;\n  var hasTexCoords = false;\n  var hasOutline = false;\n  var isUnlit = false;\n\n  if (defined(primitiveInfo)) {\n    skinningInfo = primitiveInfo.skinning;\n    hasSkinning = skinningInfo.skinned && joints.length > 0;\n    hasVertexColors = primitiveInfo.hasVertexColors;\n    hasMorphTargets = primitiveInfo.hasMorphTargets;\n    hasNormals = primitiveInfo.hasNormals;\n    hasTangents = primitiveInfo.hasTangents;\n    hasTexCoords = primitiveInfo.hasTexCoords;\n    hasOutline = primitiveInfo.hasOutline;\n  }\n\n  var morphTargets;\n\n  if (hasMorphTargets) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        if (primitive.material === materialIndex) {\n          var targets = primitive.targets;\n\n          if (defined(targets)) {\n            morphTargets = targets;\n          }\n        }\n      });\n    });\n  } // Add techniques\n\n\n  var techniqueUniforms = {\n    // Add matrices\n    u_modelViewMatrix: {\n      semantic: hasExtension(gltf, \"CESIUM_RTC\") ? \"CESIUM_RTC_MODELVIEW\" : \"MODELVIEW\",\n      type: WebGLConstants.FLOAT_MAT4\n    },\n    u_projectionMatrix: {\n      semantic: \"PROJECTION\",\n      type: WebGLConstants.FLOAT_MAT4\n    }\n  };\n\n  if (defined(material.extensions) && defined(material.extensions.KHR_materials_unlit)) {\n    isUnlit = true;\n    hasNormals = false;\n    hasTangents = false;\n  }\n\n  if (hasNormals) {\n    techniqueUniforms.u_normalMatrix = {\n      semantic: \"MODELVIEWINVERSETRANSPOSE\",\n      type: WebGLConstants.FLOAT_MAT3\n    };\n  }\n\n  if (hasSkinning) {\n    techniqueUniforms.u_jointMatrix = {\n      count: jointCount,\n      semantic: \"JOINTMATRIX\",\n      type: WebGLConstants.FLOAT_MAT4\n    };\n  }\n\n  if (hasMorphTargets) {\n    techniqueUniforms.u_morphWeights = {\n      count: morphTargets.length,\n      semantic: \"MORPHWEIGHTS\",\n      type: WebGLConstants.FLOAT\n    };\n  }\n\n  var alphaMode = material.alphaMode;\n\n  if (defined(alphaMode) && alphaMode === \"MASK\") {\n    techniqueUniforms.u_alphaCutoff = {\n      semantic: \"ALPHACUTOFF\",\n      type: WebGLConstants.FLOAT\n    };\n  } // Add material values\n\n\n  for (uniformName in generatedMaterialValues) {\n    if (generatedMaterialValues.hasOwnProperty(uniformName)) {\n      techniqueUniforms[uniformName] = {\n        type: getPBRValueType(uniformName)\n      };\n    }\n  }\n\n  var baseColorUniform = defaultValue(techniqueUniforms.u_baseColorTexture, techniqueUniforms.u_baseColorFactor);\n\n  if (defined(baseColorUniform)) {\n    baseColorUniform.semantic = \"_3DTILESDIFFUSE\";\n  } // Add uniforms to shaders\n\n\n  for (uniformName in techniqueUniforms) {\n    if (techniqueUniforms.hasOwnProperty(uniformName)) {\n      var uniform = techniqueUniforms[uniformName];\n      var arraySize = defined(uniform.count) ? \"[\" + uniform.count + \"]\" : \"\";\n\n      if (uniform.type !== WebGLConstants.FLOAT_MAT3 && uniform.type !== WebGLConstants.FLOAT_MAT4 && uniformName !== \"u_morphWeights\" || uniform.useInFragment) {\n        fragmentShader += \"uniform \" + webGLConstantToGlslType(uniform.type) + \" \" + uniformName + arraySize + \";\\n\";\n        delete uniform.useInFragment;\n      } else {\n        vertexShader += \"uniform \" + webGLConstantToGlslType(uniform.type) + \" \" + uniformName + arraySize + \";\\n\";\n      }\n    }\n  }\n\n  if (hasOutline) {\n    fragmentShader += \"uniform sampler2D u_outlineTexture;\\n\";\n  } // Add attributes with semantics\n\n\n  var vertexShaderMain = \"\";\n\n  if (hasSkinning) {\n    var i, j;\n    var numberOfComponents = numberOfComponentsForType(skinningInfo.type);\n    var matrix = false;\n\n    if (skinningInfo.type.indexOf(\"MAT\") === 0) {\n      matrix = true;\n      numberOfComponents = Math.sqrt(numberOfComponents);\n    }\n\n    if (!matrix) {\n      for (i = 0; i < numberOfComponents; i++) {\n        if (i === 0) {\n          vertexShaderMain += \"    mat4 skinMatrix = \";\n        } else {\n          vertexShaderMain += \"    skinMatrix += \";\n        }\n\n        vertexShaderMain += \"a_weight[\" + i + \"] * u_jointMatrix[int(a_joint[\" + i + \"])];\\n\";\n      }\n    } else {\n      for (i = 0; i < numberOfComponents; i++) {\n        for (j = 0; j < numberOfComponents; j++) {\n          if (i === 0 && j === 0) {\n            vertexShaderMain += \"    mat4 skinMatrix = \";\n          } else {\n            vertexShaderMain += \"    skinMatrix += \";\n          }\n\n          vertexShaderMain += \"a_weight[\" + i + \"][\" + j + \"] * u_jointMatrix[int(a_joint[\" + i + \"][\" + j + \"])];\\n\";\n        }\n      }\n    }\n  } // Add position always\n\n\n  var techniqueAttributes = {\n    a_position: {\n      semantic: \"POSITION\"\n    }\n  };\n\n  if (hasOutline) {\n    techniqueAttributes.a_outlineCoordinates = {\n      semantic: \"_OUTLINE_COORDINATES\"\n    };\n  }\n\n  vertexShader += \"attribute vec3 a_position;\\n\";\n\n  if (hasNormals) {\n    vertexShader += \"varying vec3 v_positionEC;\\n\";\n  }\n\n  if (hasOutline) {\n    vertexShader += \"attribute vec3 a_outlineCoordinates;\\n\";\n    vertexShader += \"varying vec3 v_outlineCoordinates;\\n\";\n  } // Morph Target Weighting\n\n\n  vertexShaderMain += \"    vec3 weightedPosition = a_position;\\n\";\n\n  if (hasNormals) {\n    vertexShaderMain += \"    vec3 weightedNormal = a_normal;\\n\";\n  }\n\n  if (hasTangents) {\n    vertexShaderMain += \"    vec4 weightedTangent = a_tangent;\\n\";\n  }\n\n  if (hasMorphTargets) {\n    for (var k = 0; k < morphTargets.length; k++) {\n      var targetAttributes = morphTargets[k];\n\n      for (var targetAttribute in targetAttributes) {\n        if (targetAttributes.hasOwnProperty(targetAttribute) && targetAttribute !== \"extras\") {\n          var attributeName = \"a_\" + targetAttribute + \"_\" + k;\n          techniqueAttributes[attributeName] = {\n            semantic: targetAttribute + \"_\" + k\n          };\n          vertexShader += \"attribute vec3 \" + attributeName + \";\\n\";\n\n          if (targetAttribute === \"POSITION\") {\n            vertexShaderMain += \"    weightedPosition += u_morphWeights[\" + k + \"] * \" + attributeName + \";\\n\";\n          } else if (targetAttribute === \"NORMAL\") {\n            vertexShaderMain += \"    weightedNormal += u_morphWeights[\" + k + \"] * \" + attributeName + \";\\n\";\n          } else if (hasTangents && targetAttribute === \"TANGENT\") {\n            vertexShaderMain += \"    weightedTangent.xyz += u_morphWeights[\" + k + \"] * \" + attributeName + \";\\n\";\n          }\n        }\n      }\n    }\n  } // Final position computation\n\n\n  if (hasSkinning) {\n    vertexShaderMain += \"    vec4 position = skinMatrix * vec4(weightedPosition, 1.0);\\n\";\n  } else {\n    vertexShaderMain += \"    vec4 position = vec4(weightedPosition, 1.0);\\n\";\n  }\n\n  vertexShaderMain += \"    position = u_modelViewMatrix * position;\\n\";\n\n  if (hasNormals) {\n    vertexShaderMain += \"    v_positionEC = position.xyz;\\n\";\n  }\n\n  vertexShaderMain += \"    gl_Position = u_projectionMatrix * position;\\n\";\n\n  if (hasOutline) {\n    vertexShaderMain += \"    v_outlineCoordinates = a_outlineCoordinates;\\n\";\n  } // Final normal computation\n\n\n  if (hasNormals) {\n    techniqueAttributes.a_normal = {\n      semantic: \"NORMAL\"\n    };\n    vertexShader += \"attribute vec3 a_normal;\\n\";\n    vertexShader += \"varying vec3 v_normal;\\n\";\n\n    if (hasSkinning) {\n      vertexShaderMain += \"    v_normal = u_normalMatrix * mat3(skinMatrix) * weightedNormal;\\n\";\n    } else {\n      vertexShaderMain += \"    v_normal = u_normalMatrix * weightedNormal;\\n\";\n    }\n\n    fragmentShader += \"varying vec3 v_normal;\\n\";\n    fragmentShader += \"varying vec3 v_positionEC;\\n\";\n  } // Read tangents if available\n\n\n  if (hasTangents) {\n    techniqueAttributes.a_tangent = {\n      semantic: \"TANGENT\"\n    };\n    vertexShader += \"attribute vec4 a_tangent;\\n\";\n    vertexShader += \"varying vec4 v_tangent;\\n\";\n    vertexShaderMain += \"    v_tangent.xyz = u_normalMatrix * weightedTangent.xyz;\\n\";\n    vertexShaderMain += \"    v_tangent.w = weightedTangent.w;\\n\";\n    fragmentShader += \"varying vec4 v_tangent;\\n\";\n  }\n\n  if (hasOutline) {\n    fragmentShader += \"varying vec3 v_outlineCoordinates;\\n\";\n  }\n\n  var fragmentShaderMain = \"\"; // Add texture coordinates if the material uses them\n\n  var v_texCoord;\n  var normalTexCoord;\n  var baseColorTexCoord;\n  var specularGlossinessTexCoord;\n  var diffuseTexCoord;\n  var metallicRoughnessTexCoord;\n  var occlusionTexCoord;\n  var emissiveTexCoord;\n\n  if (hasTexCoords) {\n    techniqueAttributes.a_texcoord_0 = {\n      semantic: \"TEXCOORD_0\"\n    };\n    v_texCoord = \"v_texcoord_0\";\n    vertexShader += \"attribute vec2 a_texcoord_0;\\n\";\n    vertexShader += \"varying vec2 \" + v_texCoord + \";\\n\";\n    vertexShaderMain += \"    \" + v_texCoord + \" = a_texcoord_0;\\n\";\n    fragmentShader += \"varying vec2 \" + v_texCoord + \";\\n\";\n    var result = {\n      fragmentShaderMain: fragmentShaderMain\n    };\n    normalTexCoord = addTextureCoordinates(gltf, \"u_normalTexture\", generatedMaterialValues, v_texCoord, result);\n    baseColorTexCoord = addTextureCoordinates(gltf, \"u_baseColorTexture\", generatedMaterialValues, v_texCoord, result);\n    specularGlossinessTexCoord = addTextureCoordinates(gltf, \"u_specularGlossinessTexture\", generatedMaterialValues, v_texCoord, result);\n    diffuseTexCoord = addTextureCoordinates(gltf, \"u_diffuseTexture\", generatedMaterialValues, v_texCoord, result);\n    metallicRoughnessTexCoord = addTextureCoordinates(gltf, \"u_metallicRoughnessTexture\", generatedMaterialValues, v_texCoord, result);\n    occlusionTexCoord = addTextureCoordinates(gltf, \"u_occlusionTexture\", generatedMaterialValues, v_texCoord, result);\n    emissiveTexCoord = addTextureCoordinates(gltf, \"u_emmissiveTexture\", generatedMaterialValues, v_texCoord, result);\n    fragmentShaderMain = result.fragmentShaderMain;\n  } // Add skinning information if available\n\n\n  if (hasSkinning) {\n    var attributeType = ModelUtility.getShaderVariable(skinningInfo.type);\n    techniqueAttributes.a_joint = {\n      semantic: \"JOINTS_0\"\n    };\n    techniqueAttributes.a_weight = {\n      semantic: \"WEIGHTS_0\"\n    };\n    vertexShader += \"attribute \" + attributeType + \" a_joint;\\n\";\n    vertexShader += \"attribute \" + attributeType + \" a_weight;\\n\";\n  }\n\n  if (hasVertexColors) {\n    techniqueAttributes.a_vertexColor = {\n      semantic: \"COLOR_0\"\n    };\n    vertexShader += \"attribute vec4 a_vertexColor;\\n\";\n    vertexShader += \"varying vec4 v_vertexColor;\\n\";\n    vertexShaderMain += \"  v_vertexColor = a_vertexColor;\\n\";\n    fragmentShader += \"varying vec4 v_vertexColor;\\n\";\n  }\n\n  if (addBatchIdToGeneratedShaders) {\n    techniqueAttributes.a_batchId = {\n      semantic: \"_BATCHID\"\n    };\n    vertexShader += \"attribute float a_batchId;\\n\";\n  }\n\n  vertexShader += \"void main(void) \\n{\\n\";\n  vertexShader += vertexShaderMain;\n  vertexShader += \"}\\n\"; // Fragment shader lighting\n\n  if (hasNormals) {\n    fragmentShader += \"const float M_PI = 3.141592653589793;\\n\";\n    fragmentShader += \"vec3 lambertianDiffuse(vec3 diffuseColor) \\n\" + \"{\\n\" + \"    return diffuseColor / M_PI;\\n\" + \"}\\n\\n\";\n    fragmentShader += \"vec3 fresnelSchlick2(vec3 f0, vec3 f90, float VdotH) \\n\" + \"{\\n\" + \"    return f0 + (f90 - f0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);\\n\" + \"}\\n\\n\";\n    fragmentShader += \"vec3 fresnelSchlick(float metalness, float VdotH) \\n\" + \"{\\n\" + \"    return metalness + (vec3(1.0) - metalness) * pow(1.0 - VdotH, 5.0);\\n\" + \"}\\n\\n\";\n    fragmentShader += \"float smithVisibilityG1(float NdotV, float roughness) \\n\" + \"{\\n\" + \"    float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;\\n\" + \"    return NdotV / (NdotV * (1.0 - k) + k);\\n\" + \"}\\n\\n\";\n    fragmentShader += \"float smithVisibilityGGX(float roughness, float NdotL, float NdotV) \\n\" + \"{\\n\" + \"    return smithVisibilityG1(NdotL, roughness) * smithVisibilityG1(NdotV, roughness);\\n\" + \"}\\n\\n\";\n    fragmentShader += \"float GGX(float roughness, float NdotH) \\n\" + \"{\\n\" + \"    float roughnessSquared = roughness * roughness;\\n\" + \"    float f = (NdotH * roughnessSquared - NdotH) * NdotH + 1.0;\\n\" + \"    return roughnessSquared / (M_PI * f * f);\\n\" + \"}\\n\\n\";\n  }\n\n  fragmentShader += \"vec3 SRGBtoLINEAR3(vec3 srgbIn) \\n\" + \"{\\n\" + \"    return pow(srgbIn, vec3(2.2));\\n\" + \"}\\n\\n\";\n  fragmentShader += \"vec4 SRGBtoLINEAR4(vec4 srgbIn) \\n\" + \"{\\n\" + \"    vec3 linearOut = pow(srgbIn.rgb, vec3(2.2));\\n\" + \"    return vec4(linearOut, srgbIn.a);\\n\" + \"}\\n\\n\";\n  fragmentShader += \"vec3 applyTonemapping(vec3 linearIn) \\n\" + \"{\\n\" + \"#ifndef HDR \\n\" + \"    return czm_acesTonemapping(linearIn);\\n\" + \"#else \\n\" + \"    return linearIn;\\n\" + \"#endif \\n\" + \"}\\n\\n\";\n  fragmentShader += \"vec3 LINEARtoSRGB(vec3 linearIn) \\n\" + \"{\\n\" + \"#ifndef HDR \\n\" + \"    return pow(linearIn, vec3(1.0/2.2));\\n\" + \"#else \\n\" + \"    return linearIn;\\n\" + \"#endif \\n\" + \"}\\n\\n\";\n  fragmentShader += \"vec2 computeTexCoord(vec2 texCoords, vec2 offset, float rotation, vec2 scale) \\n\" + \"{\\n\" + \"    rotation = -rotation; \\n\" + \"    mat3 transform = mat3(\\n\" + \"        cos(rotation) * scale.x, sin(rotation) * scale.x, 0.0, \\n\" + \"       -sin(rotation) * scale.y, cos(rotation) * scale.y, 0.0, \\n\" + \"        offset.x, offset.y, 1.0); \\n\" + \"    vec2 transformedTexCoords = (transform * vec3(fract(texCoords), 1.0)).xy; \\n\" + \"    return transformedTexCoords; \\n\" + \"}\\n\\n\";\n  fragmentShader += \"#ifdef USE_IBL_LIGHTING \\n\";\n  fragmentShader += \"uniform vec2 gltf_iblFactor; \\n\";\n  fragmentShader += \"#endif \\n\";\n  fragmentShader += \"#ifdef USE_CUSTOM_LIGHT_COLOR \\n\";\n  fragmentShader += \"uniform vec3 gltf_lightColor; \\n\";\n  fragmentShader += \"#endif \\n\";\n  fragmentShader += \"void main(void) \\n{\\n\";\n  fragmentShader += fragmentShaderMain; // Add normal mapping to fragment shader\n\n  if (hasNormals) {\n    fragmentShader += \"    vec3 ng = normalize(v_normal);\\n\";\n    fragmentShader += \"    vec3 positionWC = vec3(czm_inverseView * vec4(v_positionEC, 1.0));\\n\";\n\n    if (defined(generatedMaterialValues.u_normalTexture)) {\n      if (hasTangents) {\n        // Read tangents from varying\n        fragmentShader += \"    vec3 t = normalize(v_tangent.xyz);\\n\";\n        fragmentShader += \"    vec3 b = normalize(cross(ng, t) * v_tangent.w);\\n\";\n        fragmentShader += \"    mat3 tbn = mat3(t, b, ng);\\n\";\n        fragmentShader += \"    vec3 n = texture2D(u_normalTexture, \" + normalTexCoord + \").rgb;\\n\";\n        fragmentShader += \"    n = normalize(tbn * (2.0 * n - 1.0));\\n\";\n      } else {\n        // Add standard derivatives extension\n        fragmentShader = \"#ifdef GL_OES_standard_derivatives\\n\" + \"#extension GL_OES_standard_derivatives : enable\\n\" + \"#endif\\n\" + fragmentShader; // Compute tangents\n\n        fragmentShader += \"#ifdef GL_OES_standard_derivatives\\n\";\n        fragmentShader += \"    vec3 pos_dx = dFdx(v_positionEC);\\n\";\n        fragmentShader += \"    vec3 pos_dy = dFdy(v_positionEC);\\n\";\n        fragmentShader += \"    vec3 tex_dx = dFdx(vec3(\" + normalTexCoord + \",0.0));\\n\";\n        fragmentShader += \"    vec3 tex_dy = dFdy(vec3(\" + normalTexCoord + \",0.0));\\n\";\n        fragmentShader += \"    vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\\n\";\n        fragmentShader += \"    t = normalize(t - ng * dot(ng, t));\\n\";\n        fragmentShader += \"    vec3 b = normalize(cross(ng, t));\\n\";\n        fragmentShader += \"    mat3 tbn = mat3(t, b, ng);\\n\";\n        fragmentShader += \"    vec3 n = texture2D(u_normalTexture, \" + normalTexCoord + \").rgb;\\n\";\n        fragmentShader += \"    n = normalize(tbn * (2.0 * n - 1.0));\\n\";\n        fragmentShader += \"#else\\n\";\n        fragmentShader += \"    vec3 n = ng;\\n\";\n        fragmentShader += \"#endif\\n\";\n      }\n    } else {\n      fragmentShader += \"    vec3 n = ng;\\n\";\n    }\n\n    if (material.doubleSided) {\n      // !gl_FrontFacing doesn't work as expected on Mac/Intel so use the more verbose form instead. See https://github.com/CesiumGS/cesium/pull/8494.\n      fragmentShader += \"    if (gl_FrontFacing == false)\\n\";\n      fragmentShader += \"    {\\n\";\n      fragmentShader += \"        n = -n;\\n\";\n      fragmentShader += \"    }\\n\";\n    }\n  } // Add base color to fragment shader\n\n\n  if (defined(generatedMaterialValues.u_baseColorTexture)) {\n    fragmentShader += \"    vec4 baseColorWithAlpha = SRGBtoLINEAR4(texture2D(u_baseColorTexture, \" + baseColorTexCoord + \"));\\n\";\n\n    if (defined(generatedMaterialValues.u_baseColorFactor)) {\n      fragmentShader += \"    baseColorWithAlpha *= u_baseColorFactor;\\n\";\n    }\n  } else if (defined(generatedMaterialValues.u_baseColorFactor)) {\n    fragmentShader += \"    vec4 baseColorWithAlpha = u_baseColorFactor;\\n\";\n  } else {\n    fragmentShader += \"    vec4 baseColorWithAlpha = vec4(1.0);\\n\";\n  }\n\n  if (hasVertexColors) {\n    fragmentShader += \"    baseColorWithAlpha *= v_vertexColor;\\n\";\n  }\n\n  fragmentShader += \"    vec3 baseColor = baseColorWithAlpha.rgb;\\n\";\n\n  if (hasNormals) {\n    if (useSpecGloss) {\n      if (defined(generatedMaterialValues.u_specularGlossinessTexture)) {\n        fragmentShader += \"    vec4 specularGlossiness = SRGBtoLINEAR4(texture2D(u_specularGlossinessTexture, \" + specularGlossinessTexCoord + \"));\\n\";\n        fragmentShader += \"    vec3 specular = specularGlossiness.rgb;\\n\";\n        fragmentShader += \"    float glossiness = specularGlossiness.a;\\n\";\n\n        if (defined(generatedMaterialValues.u_specularFactor)) {\n          fragmentShader += \"    specular *= u_specularFactor;\\n\";\n        }\n\n        if (defined(generatedMaterialValues.u_glossinessFactor)) {\n          fragmentShader += \"    glossiness *= u_glossinessFactor;\\n\";\n        }\n      } else {\n        if (defined(generatedMaterialValues.u_specularFactor)) {\n          fragmentShader += \"    vec3 specular = clamp(u_specularFactor, vec3(0.0), vec3(1.0));\\n\";\n        } else {\n          fragmentShader += \"    vec3 specular = vec3(1.0);\\n\";\n        }\n\n        if (defined(generatedMaterialValues.u_glossinessFactor)) {\n          fragmentShader += \"    float glossiness = clamp(u_glossinessFactor, 0.0, 1.0);\\n\";\n        } else {\n          fragmentShader += \"    float glossiness = 1.0;\\n\";\n        }\n      }\n\n      if (defined(generatedMaterialValues.u_diffuseTexture)) {\n        fragmentShader += \"    vec4 diffuse = SRGBtoLINEAR4(texture2D(u_diffuseTexture, \" + diffuseTexCoord + \"));\\n\";\n\n        if (defined(generatedMaterialValues.u_diffuseFactor)) {\n          fragmentShader += \"    diffuse *= u_diffuseFactor;\\n\";\n        }\n      } else if (defined(generatedMaterialValues.u_diffuseFactor)) {\n        fragmentShader += \"    vec4 diffuse = clamp(u_diffuseFactor, vec4(0.0), vec4(1.0));\\n\";\n      } else {\n        fragmentShader += \"    vec4 diffuse = vec4(1.0);\\n\";\n      }\n    } else if (defined(generatedMaterialValues.u_metallicRoughnessTexture)) {\n      fragmentShader += \"    vec3 metallicRoughness = texture2D(u_metallicRoughnessTexture, \" + metallicRoughnessTexCoord + \").rgb;\\n\";\n      fragmentShader += \"    float metalness = clamp(metallicRoughness.b, 0.0, 1.0);\\n\";\n      fragmentShader += \"    float roughness = clamp(metallicRoughness.g, 0.04, 1.0);\\n\";\n\n      if (defined(generatedMaterialValues.u_metallicFactor)) {\n        fragmentShader += \"    metalness *= u_metallicFactor;\\n\";\n      }\n\n      if (defined(generatedMaterialValues.u_roughnessFactor)) {\n        fragmentShader += \"    roughness *= u_roughnessFactor;\\n\";\n      }\n    } else {\n      if (defined(generatedMaterialValues.u_metallicFactor)) {\n        fragmentShader += \"    float metalness = clamp(u_metallicFactor, 0.0, 1.0);\\n\";\n      } else {\n        fragmentShader += \"    float metalness = 1.0;\\n\";\n      }\n\n      if (defined(generatedMaterialValues.u_roughnessFactor)) {\n        fragmentShader += \"    float roughness = clamp(u_roughnessFactor, 0.04, 1.0);\\n\";\n      } else {\n        fragmentShader += \"    float roughness = 1.0;\\n\";\n      }\n    }\n\n    fragmentShader += \"    vec3 v = -normalize(v_positionEC);\\n\"; // Generate fragment shader's lighting block\n\n    fragmentShader += \"#ifndef USE_CUSTOM_LIGHT_COLOR \\n\";\n    fragmentShader += \"    vec3 lightColorHdr = czm_lightColorHdr;\\n\";\n    fragmentShader += \"#else \\n\";\n    fragmentShader += \"    vec3 lightColorHdr = gltf_lightColor;\\n\";\n    fragmentShader += \"#endif \\n\";\n    fragmentShader += \"    vec3 l = normalize(czm_lightDirectionEC);\\n\";\n    fragmentShader += \"    vec3 h = normalize(v + l);\\n\";\n    fragmentShader += \"    float NdotL = clamp(dot(n, l), 0.001, 1.0);\\n\";\n    fragmentShader += \"    float NdotV = abs(dot(n, v)) + 0.001;\\n\";\n    fragmentShader += \"    float NdotH = clamp(dot(n, h), 0.0, 1.0);\\n\";\n    fragmentShader += \"    float LdotH = clamp(dot(l, h), 0.0, 1.0);\\n\";\n    fragmentShader += \"    float VdotH = clamp(dot(v, h), 0.0, 1.0);\\n\";\n    fragmentShader += \"    vec3 f0 = vec3(0.04);\\n\"; // Whether the material uses metallic-roughness or specular-glossiness changes how the BRDF inputs are computed.\n    // It does not change the implementation of the BRDF itself.\n\n    if (useSpecGloss) {\n      fragmentShader += \"    float roughness = 1.0 - glossiness;\\n\";\n      fragmentShader += \"    vec3 diffuseColor = diffuse.rgb * (1.0 - max(max(specular.r, specular.g), specular.b));\\n\";\n      fragmentShader += \"    vec3 specularColor = specular;\\n\";\n    } else {\n      fragmentShader += \"    vec3 diffuseColor = baseColor * (1.0 - metalness) * (1.0 - f0);\\n\";\n      fragmentShader += \"    vec3 specularColor = mix(f0, baseColor, metalness);\\n\";\n    }\n\n    fragmentShader += \"    float alpha = roughness * roughness;\\n\";\n    fragmentShader += \"    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\\n\";\n    fragmentShader += \"    vec3 r90 = vec3(clamp(reflectance * 25.0, 0.0, 1.0));\\n\";\n    fragmentShader += \"    vec3 r0 = specularColor.rgb;\\n\";\n    fragmentShader += \"    vec3 F = fresnelSchlick2(r0, r90, VdotH);\\n\";\n    fragmentShader += \"    float G = smithVisibilityGGX(alpha, NdotL, NdotV);\\n\";\n    fragmentShader += \"    float D = GGX(alpha, NdotH);\\n\";\n    fragmentShader += \"    vec3 diffuseContribution = (1.0 - F) * lambertianDiffuse(diffuseColor);\\n\";\n    fragmentShader += \"    vec3 specularContribution = F * G * D / (4.0 * NdotL * NdotV);\\n\";\n    fragmentShader += \"    vec3 color = NdotL * lightColorHdr * (diffuseContribution + specularContribution);\\n\"; // Use the procedural IBL if there are no environment maps\n\n    fragmentShader += \"#if defined(USE_IBL_LIGHTING) && !defined(DIFFUSE_IBL) && !defined(SPECULAR_IBL) \\n\";\n    fragmentShader += \"    vec3 r = normalize(czm_inverseViewRotation * normalize(reflect(v, n)));\\n\"; // Figure out if the reflection vector hits the ellipsoid\n\n    fragmentShader += \"    float vertexRadius = length(positionWC);\\n\";\n    fragmentShader += \"    float horizonDotNadir = 1.0 - min(1.0, czm_ellipsoidRadii.x / vertexRadius);\\n\";\n    fragmentShader += \"    float reflectionDotNadir = dot(r, normalize(positionWC));\\n\"; // Flipping the X vector is a cheap way to get the inverse of czm_temeToPseudoFixed, since that's a rotation about Z.\n\n    fragmentShader += \"    r.x = -r.x;\\n\";\n    fragmentShader += \"    r = -normalize(czm_temeToPseudoFixed * r);\\n\";\n    fragmentShader += \"    r.x = -r.x;\\n\";\n    fragmentShader += \"    float inverseRoughness = 1.04 - roughness;\\n\";\n    fragmentShader += \"    inverseRoughness *= inverseRoughness;\\n\";\n    fragmentShader += \"    vec3 sceneSkyBox = textureCube(czm_environmentMap, r).rgb * inverseRoughness;\\n\";\n    fragmentShader += \"    float atmosphereHeight = 0.05;\\n\";\n    fragmentShader += \"    float blendRegionSize = 0.1 * ((1.0 - inverseRoughness) * 8.0 + 1.1 - horizonDotNadir);\\n\";\n    fragmentShader += \"    float blendRegionOffset = roughness * -1.0;\\n\";\n    fragmentShader += \"    float farAboveHorizon = clamp(horizonDotNadir - blendRegionSize * 0.5 + blendRegionOffset, 1.0e-10 - blendRegionSize, 0.99999);\\n\";\n    fragmentShader += \"    float aroundHorizon = clamp(horizonDotNadir + blendRegionSize * 0.5, 1.0e-10 - blendRegionSize, 0.99999);\\n\";\n    fragmentShader += \"    float farBelowHorizon = clamp(horizonDotNadir + blendRegionSize * 1.5, 1.0e-10 - blendRegionSize, 0.99999);\\n\";\n    fragmentShader += \"    float smoothstepHeight = smoothstep(0.0, atmosphereHeight, horizonDotNadir);\\n\";\n    fragmentShader += \"    vec3 belowHorizonColor = mix(vec3(0.1, 0.15, 0.25), vec3(0.4, 0.7, 0.9), smoothstepHeight);\\n\";\n    fragmentShader += \"    vec3 nadirColor = belowHorizonColor * 0.5;\\n\";\n    fragmentShader += \"    vec3 aboveHorizonColor = mix(vec3(0.9, 1.0, 1.2), belowHorizonColor, roughness * 0.5);\\n\";\n    fragmentShader += \"    vec3 blueSkyColor = mix(vec3(0.18, 0.26, 0.48), aboveHorizonColor, reflectionDotNadir * inverseRoughness * 0.5 + 0.75);\\n\";\n    fragmentShader += \"    vec3 zenithColor = mix(blueSkyColor, sceneSkyBox, smoothstepHeight);\\n\";\n    fragmentShader += \"    vec3 blueSkyDiffuseColor = vec3(0.7, 0.85, 0.9);\\n\";\n    fragmentShader += \"    float diffuseIrradianceFromEarth = (1.0 - horizonDotNadir) * (reflectionDotNadir * 0.25 + 0.75) * smoothstepHeight;\\n\";\n    fragmentShader += \"    float diffuseIrradianceFromSky = (1.0 - smoothstepHeight) * (1.0 - (reflectionDotNadir * 0.25 + 0.25));\\n\";\n    fragmentShader += \"    vec3 diffuseIrradiance = blueSkyDiffuseColor * clamp(diffuseIrradianceFromEarth + diffuseIrradianceFromSky, 0.0, 1.0);\\n\";\n    fragmentShader += \"    float notDistantRough = (1.0 - horizonDotNadir * roughness * 0.8);\\n\";\n    fragmentShader += \"    vec3 specularIrradiance = mix(zenithColor, aboveHorizonColor, smoothstep(farAboveHorizon, aroundHorizon, reflectionDotNadir) * notDistantRough);\\n\";\n    fragmentShader += \"    specularIrradiance = mix(specularIrradiance, belowHorizonColor, smoothstep(aroundHorizon, farBelowHorizon, reflectionDotNadir) * inverseRoughness);\\n\";\n    fragmentShader += \"    specularIrradiance = mix(specularIrradiance, nadirColor, smoothstep(farBelowHorizon, 1.0, reflectionDotNadir) * inverseRoughness);\\n\"; // Luminance model from page 40 of http://silviojemma.com/public/papers/lighting/spherical-harmonic-lighting.pdf\n\n    fragmentShader += \"#ifdef USE_SUN_LUMINANCE \\n\"; // Angle between sun and zenith\n\n    fragmentShader += \"    float LdotZenith = clamp(dot(normalize(czm_inverseViewRotation * l), normalize(positionWC * -1.0)), 0.001, 1.0);\\n\";\n    fragmentShader += \"    float S = acos(LdotZenith);\\n\"; // Angle between zenith and current pixel\n\n    fragmentShader += \"    float NdotZenith = clamp(dot(normalize(czm_inverseViewRotation * n), normalize(positionWC * -1.0)), 0.001, 1.0);\\n\"; // Angle between sun and current pixel\n\n    fragmentShader += \"    float gamma = acos(NdotL);\\n\";\n    fragmentShader += \"    float numerator = ((0.91 + 10.0 * exp(-3.0 * gamma) + 0.45 * pow(NdotL, 2.0)) * (1.0 - exp(-0.32 / NdotZenith)));\\n\";\n    fragmentShader += \"    float denominator = (0.91 + 10.0 * exp(-3.0 * S) + 0.45 * pow(LdotZenith,2.0)) * (1.0 - exp(-0.32));\\n\";\n    fragmentShader += \"    float luminance = gltf_luminanceAtZenith * (numerator / denominator);\\n\";\n    fragmentShader += \"#endif \\n\";\n    fragmentShader += \"    vec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, roughness)).rg;\\n\";\n    fragmentShader += \"    vec3 IBLColor = (diffuseIrradiance * diffuseColor * gltf_iblFactor.x) + (specularIrradiance * SRGBtoLINEAR3(specularColor * brdfLut.x + brdfLut.y) * gltf_iblFactor.y);\\n\";\n    fragmentShader += \"    float maximumComponent = max(max(lightColorHdr.x, lightColorHdr.y), lightColorHdr.z);\\n\";\n    fragmentShader += \"    vec3 lightColor = lightColorHdr / max(maximumComponent, 1.0);\\n\";\n    fragmentShader += \"    IBLColor *= lightColor;\\n\";\n    fragmentShader += \"#ifdef USE_SUN_LUMINANCE \\n\";\n    fragmentShader += \"    color += IBLColor * luminance;\\n\";\n    fragmentShader += \"#else \\n\";\n    fragmentShader += \"    color += IBLColor; \\n\";\n    fragmentShader += \"#endif \\n\"; // Environment maps were provided, use them for IBL\n\n    fragmentShader += \"#elif defined(DIFFUSE_IBL) || defined(SPECULAR_IBL) \\n\";\n    fragmentShader += \"    mat3 fixedToENU = mat3(gltf_clippingPlanesMatrix[0][0], gltf_clippingPlanesMatrix[1][0], gltf_clippingPlanesMatrix[2][0], \\n\";\n    fragmentShader += \"                           gltf_clippingPlanesMatrix[0][1], gltf_clippingPlanesMatrix[1][1], gltf_clippingPlanesMatrix[2][1], \\n\";\n    fragmentShader += \"                           gltf_clippingPlanesMatrix[0][2], gltf_clippingPlanesMatrix[1][2], gltf_clippingPlanesMatrix[2][2]); \\n\";\n    fragmentShader += \"    const mat3 yUpToZUp = mat3(-1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0); \\n\";\n    fragmentShader += \"    vec3 cubeDir = normalize(yUpToZUp * fixedToENU * normalize(reflect(-v, n))); \\n\";\n    fragmentShader += \"#ifdef DIFFUSE_IBL \\n\";\n    fragmentShader += \"#ifdef CUSTOM_SPHERICAL_HARMONICS \\n\";\n    fragmentShader += \"    vec3 diffuseIrradiance = czm_sphericalHarmonics(cubeDir, gltf_sphericalHarmonicCoefficients); \\n\";\n    fragmentShader += \"#else \\n\";\n    fragmentShader += \"    vec3 diffuseIrradiance = czm_sphericalHarmonics(cubeDir, czm_sphericalHarmonicCoefficients); \\n\";\n    fragmentShader += \"#endif \\n\";\n    fragmentShader += \"#else \\n\";\n    fragmentShader += \"    vec3 diffuseIrradiance = vec3(0.0); \\n\";\n    fragmentShader += \"#endif \\n\";\n    fragmentShader += \"#ifdef SPECULAR_IBL \\n\";\n    fragmentShader += \"    vec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, roughness)).rg;\\n\";\n    fragmentShader += \"#ifdef CUSTOM_SPECULAR_IBL \\n\";\n    fragmentShader += \"    vec3 specularIBL = czm_sampleOctahedralProjection(gltf_specularMap, gltf_specularMapSize, cubeDir,  roughness * gltf_maxSpecularLOD, gltf_maxSpecularLOD);\\n\";\n    fragmentShader += \"#else \\n\";\n    fragmentShader += \"    vec3 specularIBL = czm_sampleOctahedralProjection(czm_specularEnvironmentMaps, czm_specularEnvironmentMapSize, cubeDir,  roughness * czm_specularEnvironmentMapsMaximumLOD, czm_specularEnvironmentMapsMaximumLOD);\\n\";\n    fragmentShader += \"#endif \\n\";\n    fragmentShader += \"    specularIBL *= F * brdfLut.x + brdfLut.y;\\n\";\n    fragmentShader += \"#else \\n\";\n    fragmentShader += \"    vec3 specularIBL = vec3(0.0); \\n\";\n    fragmentShader += \"#endif \\n\";\n    fragmentShader += \"    color += diffuseIrradiance * diffuseColor + specularColor * specularIBL;\\n\";\n    fragmentShader += \"#endif \\n\";\n  } else {\n    fragmentShader += \"    vec3 color = baseColor;\\n\";\n  } // Ignore occlusion and emissive when unlit\n\n\n  if (!isUnlit) {\n    if (defined(generatedMaterialValues.u_occlusionTexture)) {\n      fragmentShader += \"    color *= texture2D(u_occlusionTexture, \" + occlusionTexCoord + \").r;\\n\";\n    }\n\n    if (defined(generatedMaterialValues.u_emissiveTexture)) {\n      fragmentShader += \"    vec3 emissive = SRGBtoLINEAR3(texture2D(u_emissiveTexture, \" + emissiveTexCoord + \").rgb);\\n\";\n\n      if (defined(generatedMaterialValues.u_emissiveFactor)) {\n        fragmentShader += \"    emissive *= u_emissiveFactor;\\n\";\n      }\n\n      fragmentShader += \"    color += emissive;\\n\";\n    } else if (defined(generatedMaterialValues.u_emissiveFactor)) {\n      fragmentShader += \"    color += u_emissiveFactor;\\n\";\n    }\n  }\n\n  if (!isUnlit) {\n    fragmentShader += \"    color = applyTonemapping(color);\\n\";\n  }\n\n  fragmentShader += \"    color = LINEARtoSRGB(color);\\n\";\n\n  if (hasOutline) {\n    fragmentShader += \"    float outlineness = max(\\n\";\n    fragmentShader += \"        texture2D(u_outlineTexture, vec2(v_outlineCoordinates.x, 0.5)).r,\\n\";\n    fragmentShader += \"        max(\\n\";\n    fragmentShader += \"          texture2D(u_outlineTexture, vec2(v_outlineCoordinates.y, 0.5)).r,\\n\";\n    fragmentShader += \"          texture2D(u_outlineTexture, vec2(v_outlineCoordinates.z, 0.5)).r));\\n\";\n    fragmentShader += \"    color = mix(color, vec3(0.0, 0.0, 0.0), outlineness);\\n\";\n  }\n\n  if (defined(alphaMode)) {\n    if (alphaMode === \"MASK\") {\n      fragmentShader += \"    if (baseColorWithAlpha.a < u_alphaCutoff) {\\n\";\n      fragmentShader += \"        discard;\\n\";\n      fragmentShader += \"    }\\n\";\n      fragmentShader += \"    gl_FragColor = vec4(color, 1.0);\\n\";\n    } else if (alphaMode === \"BLEND\") {\n      fragmentShader += \"    gl_FragColor = vec4(color, baseColorWithAlpha.a);\\n\";\n    } else {\n      fragmentShader += \"    gl_FragColor = vec4(color, 1.0);\\n\";\n    }\n  } else {\n    fragmentShader += \"    gl_FragColor = vec4(color, 1.0);\\n\";\n  }\n\n  fragmentShader += \"}\\n\"; // Add shaders\n\n  var vertexShaderId = addToArray(shaders, {\n    type: WebGLConstants.VERTEX_SHADER,\n    extras: {\n      _pipeline: {\n        source: vertexShader,\n        extension: \".glsl\"\n      }\n    }\n  });\n  var fragmentShaderId = addToArray(shaders, {\n    type: WebGLConstants.FRAGMENT_SHADER,\n    extras: {\n      _pipeline: {\n        source: fragmentShader,\n        extension: \".glsl\"\n      }\n    }\n  }); // Add program\n\n  var programId = addToArray(programs, {\n    fragmentShader: fragmentShaderId,\n    vertexShader: vertexShaderId\n  });\n  var techniqueId = addToArray(techniques, {\n    attributes: techniqueAttributes,\n    program: programId,\n    uniforms: techniqueUniforms\n  });\n  return techniqueId;\n}\n\nfunction getPBRValueType(paramName) {\n  if (paramName.indexOf(\"Offset\") !== -1) {\n    return WebGLConstants.FLOAT_VEC2;\n  } else if (paramName.indexOf(\"Rotation\") !== -1) {\n    return WebGLConstants.FLOAT;\n  } else if (paramName.indexOf(\"Scale\") !== -1) {\n    return WebGLConstants.FLOAT_VEC2;\n  } else if (paramName.indexOf(\"Texture\") !== -1) {\n    return WebGLConstants.SAMPLER_2D;\n  }\n\n  switch (paramName) {\n    case \"u_baseColorFactor\":\n      return WebGLConstants.FLOAT_VEC4;\n\n    case \"u_metallicFactor\":\n      return WebGLConstants.FLOAT;\n\n    case \"u_roughnessFactor\":\n      return WebGLConstants.FLOAT;\n\n    case \"u_emissiveFactor\":\n      return WebGLConstants.FLOAT_VEC3;\n    // Specular Glossiness Types\n\n    case \"u_diffuseFactor\":\n      return WebGLConstants.FLOAT_VEC4;\n\n    case \"u_specularFactor\":\n      return WebGLConstants.FLOAT_VEC3;\n\n    case \"u_glossinessFactor\":\n      return WebGLConstants.FLOAT;\n  }\n}\n\nexport default processPbrMaterials;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/processPbrMaterials.js"],"names":["defaultValue","defined","WebGLConstants","webGLConstantToGlslType","addToArray","ForEach","hasExtension","numberOfComponentsForType","ModelUtility","processPbrMaterials","gltf","options","EMPTY_OBJECT","materials","length","extensions","extensionsUsed","extensionsRequired","KHR_techniques_webgl","programs","shaders","techniques","push","primitiveByMaterial","splitIncompatibleMaterials","material","materialIndex","generatedMaterialValues","technique","generateTechnique","values","ensureSemanticExistence","isSpecularGlossinessMaterial","KHR_materials_pbrSpecularGlossiness","addTextureCoordinates","textureName","defaultTexCoord","result","texCoord","fragmentShaderMain","DEFAULT_TEXTURE_OFFSET","DEFAULT_TEXTURE_ROTATION","DEFAULT_TEXTURE_SCALE","handleKHRTextureTransform","parameterName","value","indexOf","KHR_texture_transform","uniformName","extension","offset","rotation","scale","addBatchIdToGeneratedShaders","techniquesWebgl","useSpecGloss","pbrMetallicRoughness","hasOwnProperty","pbrSpecularGlossiness","additional","vertexShader","fragmentShader","skin","skins","joints","jointCount","primitiveInfo","skinningInfo","hasSkinning","hasVertexColors","hasMorphTargets","hasNormals","hasTangents","hasTexCoords","hasOutline","isUnlit","skinning","skinned","morphTargets","mesh","meshPrimitive","primitive","targets","techniqueUniforms","u_modelViewMatrix","semantic","type","FLOAT_MAT4","u_projectionMatrix","KHR_materials_unlit","u_normalMatrix","FLOAT_MAT3","u_jointMatrix","count","u_morphWeights","FLOAT","alphaMode","u_alphaCutoff","getPBRValueType","baseColorUniform","u_baseColorTexture","u_baseColorFactor","uniform","arraySize","useInFragment","vertexShaderMain","i","j","numberOfComponents","matrix","Math","sqrt","techniqueAttributes","a_position","a_outlineCoordinates","k","targetAttributes","targetAttribute","attributeName","a_normal","a_tangent","v_texCoord","normalTexCoord","baseColorTexCoord","specularGlossinessTexCoord","diffuseTexCoord","metallicRoughnessTexCoord","occlusionTexCoord","emissiveTexCoord","a_texcoord_0","attributeType","getShaderVariable","a_joint","a_weight","a_vertexColor","a_batchId","u_normalTexture","doubleSided","u_specularGlossinessTexture","u_specularFactor","u_glossinessFactor","u_diffuseTexture","u_diffuseFactor","u_metallicRoughnessTexture","u_metallicFactor","u_roughnessFactor","u_occlusionTexture","u_emissiveTexture","u_emissiveFactor","vertexShaderId","VERTEX_SHADER","extras","_pipeline","source","fragmentShaderId","FRAGMENT_SHADER","programId","techniqueId","attributes","program","uniforms","paramName","FLOAT_VEC2","SAMPLER_2D","FLOAT_VEC4","FLOAT_VEC3"],"mappings":"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","sourcesContent":["import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport webGLConstantToGlslType from \"../Core/webGLConstantToGlslType.js\";\nimport addToArray from \"../ThirdParty/GltfPipeline/addToArray.js\";\nimport ForEach from \"../ThirdParty/GltfPipeline/ForEach.js\";\nimport hasExtension from \"../ThirdParty/GltfPipeline/hasExtension.js\";\nimport numberOfComponentsForType from \"../ThirdParty/GltfPipeline/numberOfComponentsForType.js\";\nimport ModelUtility from \"./ModelUtility.js\";\n\n/**\n * @private\n */\nfunction processPbrMaterials(gltf, options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  // No need to create new techniques if they already exist,\n  // the shader should handle these values\n  if (hasExtension(gltf, \"KHR_techniques_webgl\")) {\n    return gltf;\n  }\n\n  // All materials in glTF are PBR by default,\n  // so we should apply PBR unless no materials are found.\n  if (!defined(gltf.materials) || gltf.materials.length === 0) {\n    return gltf;\n  }\n\n  if (!defined(gltf.extensions)) {\n    gltf.extensions = {};\n  }\n\n  if (!defined(gltf.extensionsUsed)) {\n    gltf.extensionsUsed = [];\n  }\n\n  if (!defined(gltf.extensionsRequired)) {\n    gltf.extensionsRequired = [];\n  }\n\n  gltf.extensions.KHR_techniques_webgl = {\n    programs: [],\n    shaders: [],\n    techniques: [],\n  };\n\n  gltf.extensionsUsed.push(\"KHR_techniques_webgl\");\n  gltf.extensionsRequired.push(\"KHR_techniques_webgl\");\n\n  var primitiveByMaterial = ModelUtility.splitIncompatibleMaterials(gltf);\n\n  ForEach.material(gltf, function (material, materialIndex) {\n    var generatedMaterialValues = {};\n    var technique = generateTechnique(\n      gltf,\n      material,\n      materialIndex,\n      generatedMaterialValues,\n      primitiveByMaterial,\n      options\n    );\n\n    if (!defined(material.extensions)) {\n      material.extensions = {};\n    }\n\n    material.extensions.KHR_techniques_webgl = {\n      values: generatedMaterialValues,\n      technique: technique,\n    };\n  });\n\n  // If any primitives have semantics that aren't declared in the generated\n  // shaders, we want to preserve them.\n  ModelUtility.ensureSemanticExistence(gltf);\n\n  return gltf;\n}\n\nfunction isSpecularGlossinessMaterial(material) {\n  return (\n    defined(material.extensions) &&\n    defined(material.extensions.KHR_materials_pbrSpecularGlossiness)\n  );\n}\n\nfunction addTextureCoordinates(\n  gltf,\n  textureName,\n  generatedMaterialValues,\n  defaultTexCoord,\n  result\n) {\n  var texCoord;\n  if (defined(generatedMaterialValues[textureName + \"Offset\"])) {\n    texCoord = textureName + \"Coord\";\n    result.fragmentShaderMain +=\n      \"    vec2 \" +\n      texCoord +\n      \" = computeTexCoord(\" +\n      defaultTexCoord +\n      \", \" +\n      textureName +\n      \"Offset, \" +\n      textureName +\n      \"Rotation, \" +\n      textureName +\n      \"Scale);\\n\";\n  } else {\n    texCoord = defaultTexCoord;\n  }\n  return texCoord;\n}\n\nvar DEFAULT_TEXTURE_OFFSET = [0.0, 0.0];\nvar DEFAULT_TEXTURE_ROTATION = [0.0];\nvar DEFAULT_TEXTURE_SCALE = [1.0, 1.0];\n\nfunction handleKHRTextureTransform(\n  parameterName,\n  value,\n  generatedMaterialValues\n) {\n  if (\n    parameterName.indexOf(\"Texture\") === -1 ||\n    !defined(value.extensions) ||\n    !defined(value.extensions.KHR_texture_transform)\n  ) {\n    return;\n  }\n\n  var uniformName = \"u_\" + parameterName;\n  var extension = value.extensions.KHR_texture_transform;\n  generatedMaterialValues[uniformName + \"Offset\"] = defaultValue(\n    extension.offset,\n    DEFAULT_TEXTURE_OFFSET\n  );\n  generatedMaterialValues[uniformName + \"Rotation\"] = defaultValue(\n    extension.rotation,\n    DEFAULT_TEXTURE_ROTATION\n  );\n  generatedMaterialValues[uniformName + \"Scale\"] = defaultValue(\n    extension.scale,\n    DEFAULT_TEXTURE_SCALE\n  );\n\n  if (defined(value.texCoord) && defined(extension.texCoord)) {\n    generatedMaterialValues[uniformName].texCoord = extension.texCoord;\n  }\n}\n\nfunction generateTechnique(\n  gltf,\n  material,\n  materialIndex,\n  generatedMaterialValues,\n  primitiveByMaterial,\n  options\n) {\n  var addBatchIdToGeneratedShaders = defaultValue(\n    options.addBatchIdToGeneratedShaders,\n    false\n  );\n\n  var techniquesWebgl = gltf.extensions.KHR_techniques_webgl;\n  var techniques = techniquesWebgl.techniques;\n  var shaders = techniquesWebgl.shaders;\n  var programs = techniquesWebgl.programs;\n\n  var useSpecGloss = isSpecularGlossinessMaterial(material);\n\n  var uniformName;\n  var parameterName;\n  var value;\n  var pbrMetallicRoughness = material.pbrMetallicRoughness;\n  if (defined(pbrMetallicRoughness) && !useSpecGloss) {\n    for (parameterName in pbrMetallicRoughness) {\n      if (pbrMetallicRoughness.hasOwnProperty(parameterName)) {\n        value = pbrMetallicRoughness[parameterName];\n        uniformName = \"u_\" + parameterName;\n        generatedMaterialValues[uniformName] = value;\n        handleKHRTextureTransform(\n          parameterName,\n          value,\n          generatedMaterialValues\n        );\n      }\n    }\n  }\n\n  if (useSpecGloss) {\n    var pbrSpecularGlossiness =\n      material.extensions.KHR_materials_pbrSpecularGlossiness;\n    for (parameterName in pbrSpecularGlossiness) {\n      if (pbrSpecularGlossiness.hasOwnProperty(parameterName)) {\n        value = pbrSpecularGlossiness[parameterName];\n        uniformName = \"u_\" + parameterName;\n        generatedMaterialValues[uniformName] = value;\n        handleKHRTextureTransform(\n          parameterName,\n          value,\n          generatedMaterialValues\n        );\n      }\n    }\n  }\n\n  for (var additional in material) {\n    if (\n      material.hasOwnProperty(additional) &&\n      (additional.indexOf(\"Texture\") >= 0 || additional.indexOf(\"Factor\") >= 0)\n    ) {\n      value = material[additional];\n      uniformName = \"u_\" + additional;\n      generatedMaterialValues[uniformName] = value;\n      handleKHRTextureTransform(additional, value, generatedMaterialValues);\n    }\n  }\n\n  var vertexShader = \"precision highp float;\\n\";\n  var fragmentShader = \"precision highp float;\\n\";\n\n  var skin;\n  if (defined(gltf.skins)) {\n    skin = gltf.skins[0];\n  }\n  var joints = defined(skin) ? skin.joints : [];\n  var jointCount = joints.length;\n\n  var primitiveInfo = primitiveByMaterial[materialIndex];\n\n  var skinningInfo;\n  var hasSkinning = false;\n  var hasVertexColors = false;\n  var hasMorphTargets = false;\n  var hasNormals = false;\n  var hasTangents = false;\n  var hasTexCoords = false;\n  var hasOutline = false;\n  var isUnlit = false;\n\n  if (defined(primitiveInfo)) {\n    skinningInfo = primitiveInfo.skinning;\n    hasSkinning = skinningInfo.skinned && joints.length > 0;\n    hasVertexColors = primitiveInfo.hasVertexColors;\n    hasMorphTargets = primitiveInfo.hasMorphTargets;\n    hasNormals = primitiveInfo.hasNormals;\n    hasTangents = primitiveInfo.hasTangents;\n    hasTexCoords = primitiveInfo.hasTexCoords;\n    hasOutline = primitiveInfo.hasOutline;\n  }\n\n  var morphTargets;\n  if (hasMorphTargets) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        if (primitive.material === materialIndex) {\n          var targets = primitive.targets;\n          if (defined(targets)) {\n            morphTargets = targets;\n          }\n        }\n      });\n    });\n  }\n\n  // Add techniques\n  var techniqueUniforms = {\n    // Add matrices\n    u_modelViewMatrix: {\n      semantic: hasExtension(gltf, \"CESIUM_RTC\")\n        ? \"CESIUM_RTC_MODELVIEW\"\n        : \"MODELVIEW\",\n      type: WebGLConstants.FLOAT_MAT4,\n    },\n    u_projectionMatrix: {\n      semantic: \"PROJECTION\",\n      type: WebGLConstants.FLOAT_MAT4,\n    },\n  };\n\n  if (\n    defined(material.extensions) &&\n    defined(material.extensions.KHR_materials_unlit)\n  ) {\n    isUnlit = true;\n    hasNormals = false;\n    hasTangents = false;\n  }\n\n  if (hasNormals) {\n    techniqueUniforms.u_normalMatrix = {\n      semantic: \"MODELVIEWINVERSETRANSPOSE\",\n      type: WebGLConstants.FLOAT_MAT3,\n    };\n  }\n\n  if (hasSkinning) {\n    techniqueUniforms.u_jointMatrix = {\n      count: jointCount,\n      semantic: \"JOINTMATRIX\",\n      type: WebGLConstants.FLOAT_MAT4,\n    };\n  }\n\n  if (hasMorphTargets) {\n    techniqueUniforms.u_morphWeights = {\n      count: morphTargets.length,\n      semantic: \"MORPHWEIGHTS\",\n      type: WebGLConstants.FLOAT,\n    };\n  }\n\n  var alphaMode = material.alphaMode;\n  if (defined(alphaMode) && alphaMode === \"MASK\") {\n    techniqueUniforms.u_alphaCutoff = {\n      semantic: \"ALPHACUTOFF\",\n      type: WebGLConstants.FLOAT,\n    };\n  }\n\n  // Add material values\n  for (uniformName in generatedMaterialValues) {\n    if (generatedMaterialValues.hasOwnProperty(uniformName)) {\n      techniqueUniforms[uniformName] = {\n        type: getPBRValueType(uniformName),\n      };\n    }\n  }\n\n  var baseColorUniform = defaultValue(\n    techniqueUniforms.u_baseColorTexture,\n    techniqueUniforms.u_baseColorFactor\n  );\n  if (defined(baseColorUniform)) {\n    baseColorUniform.semantic = \"_3DTILESDIFFUSE\";\n  }\n\n  // Add uniforms to shaders\n  for (uniformName in techniqueUniforms) {\n    if (techniqueUniforms.hasOwnProperty(uniformName)) {\n      var uniform = techniqueUniforms[uniformName];\n      var arraySize = defined(uniform.count) ? \"[\" + uniform.count + \"]\" : \"\";\n      if (\n        (uniform.type !== WebGLConstants.FLOAT_MAT3 &&\n          uniform.type !== WebGLConstants.FLOAT_MAT4 &&\n          uniformName !== \"u_morphWeights\") ||\n        uniform.useInFragment\n      ) {\n        fragmentShader +=\n          \"uniform \" +\n          webGLConstantToGlslType(uniform.type) +\n          \" \" +\n          uniformName +\n          arraySize +\n          \";\\n\";\n        delete uniform.useInFragment;\n      } else {\n        vertexShader +=\n          \"uniform \" +\n          webGLConstantToGlslType(uniform.type) +\n          \" \" +\n          uniformName +\n          arraySize +\n          \";\\n\";\n      }\n    }\n  }\n\n  if (hasOutline) {\n    fragmentShader += \"uniform sampler2D u_outlineTexture;\\n\";\n  }\n\n  // Add attributes with semantics\n  var vertexShaderMain = \"\";\n  if (hasSkinning) {\n    var i, j;\n    var numberOfComponents = numberOfComponentsForType(skinningInfo.type);\n    var matrix = false;\n    if (skinningInfo.type.indexOf(\"MAT\") === 0) {\n      matrix = true;\n      numberOfComponents = Math.sqrt(numberOfComponents);\n    }\n    if (!matrix) {\n      for (i = 0; i < numberOfComponents; i++) {\n        if (i === 0) {\n          vertexShaderMain += \"    mat4 skinMatrix = \";\n        } else {\n          vertexShaderMain += \"    skinMatrix += \";\n        }\n        vertexShaderMain +=\n          \"a_weight[\" + i + \"] * u_jointMatrix[int(a_joint[\" + i + \"])];\\n\";\n      }\n    } else {\n      for (i = 0; i < numberOfComponents; i++) {\n        for (j = 0; j < numberOfComponents; j++) {\n          if (i === 0 && j === 0) {\n            vertexShaderMain += \"    mat4 skinMatrix = \";\n          } else {\n            vertexShaderMain += \"    skinMatrix += \";\n          }\n          vertexShaderMain +=\n            \"a_weight[\" +\n            i +\n            \"][\" +\n            j +\n            \"] * u_jointMatrix[int(a_joint[\" +\n            i +\n            \"][\" +\n            j +\n            \"])];\\n\";\n        }\n      }\n    }\n  }\n\n  // Add position always\n  var techniqueAttributes = {\n    a_position: {\n      semantic: \"POSITION\",\n    },\n  };\n\n  if (hasOutline) {\n    techniqueAttributes.a_outlineCoordinates = {\n      semantic: \"_OUTLINE_COORDINATES\",\n    };\n  }\n\n  vertexShader += \"attribute vec3 a_position;\\n\";\n  if (hasNormals) {\n    vertexShader += \"varying vec3 v_positionEC;\\n\";\n  }\n  if (hasOutline) {\n    vertexShader += \"attribute vec3 a_outlineCoordinates;\\n\";\n    vertexShader += \"varying vec3 v_outlineCoordinates;\\n\";\n  }\n\n  // Morph Target Weighting\n  vertexShaderMain += \"    vec3 weightedPosition = a_position;\\n\";\n  if (hasNormals) {\n    vertexShaderMain += \"    vec3 weightedNormal = a_normal;\\n\";\n  }\n  if (hasTangents) {\n    vertexShaderMain += \"    vec4 weightedTangent = a_tangent;\\n\";\n  }\n  if (hasMorphTargets) {\n    for (var k = 0; k < morphTargets.length; k++) {\n      var targetAttributes = morphTargets[k];\n      for (var targetAttribute in targetAttributes) {\n        if (\n          targetAttributes.hasOwnProperty(targetAttribute) &&\n          targetAttribute !== \"extras\"\n        ) {\n          var attributeName = \"a_\" + targetAttribute + \"_\" + k;\n          techniqueAttributes[attributeName] = {\n            semantic: targetAttribute + \"_\" + k,\n          };\n          vertexShader += \"attribute vec3 \" + attributeName + \";\\n\";\n          if (targetAttribute === \"POSITION\") {\n            vertexShaderMain +=\n              \"    weightedPosition += u_morphWeights[\" +\n              k +\n              \"] * \" +\n              attributeName +\n              \";\\n\";\n          } else if (targetAttribute === \"NORMAL\") {\n            vertexShaderMain +=\n              \"    weightedNormal += u_morphWeights[\" +\n              k +\n              \"] * \" +\n              attributeName +\n              \";\\n\";\n          } else if (hasTangents && targetAttribute === \"TANGENT\") {\n            vertexShaderMain +=\n              \"    weightedTangent.xyz += u_morphWeights[\" +\n              k +\n              \"] * \" +\n              attributeName +\n              \";\\n\";\n          }\n        }\n      }\n    }\n  }\n\n  // Final position computation\n  if (hasSkinning) {\n    vertexShaderMain +=\n      \"    vec4 position = skinMatrix * vec4(weightedPosition, 1.0);\\n\";\n  } else {\n    vertexShaderMain += \"    vec4 position = vec4(weightedPosition, 1.0);\\n\";\n  }\n  vertexShaderMain += \"    position = u_modelViewMatrix * position;\\n\";\n  if (hasNormals) {\n    vertexShaderMain += \"    v_positionEC = position.xyz;\\n\";\n  }\n  vertexShaderMain += \"    gl_Position = u_projectionMatrix * position;\\n\";\n\n  if (hasOutline) {\n    vertexShaderMain += \"    v_outlineCoordinates = a_outlineCoordinates;\\n\";\n  }\n\n  // Final normal computation\n  if (hasNormals) {\n    techniqueAttributes.a_normal = {\n      semantic: \"NORMAL\",\n    };\n    vertexShader += \"attribute vec3 a_normal;\\n\";\n    vertexShader += \"varying vec3 v_normal;\\n\";\n    if (hasSkinning) {\n      vertexShaderMain +=\n        \"    v_normal = u_normalMatrix * mat3(skinMatrix) * weightedNormal;\\n\";\n    } else {\n      vertexShaderMain += \"    v_normal = u_normalMatrix * weightedNormal;\\n\";\n    }\n\n    fragmentShader += \"varying vec3 v_normal;\\n\";\n    fragmentShader += \"varying vec3 v_positionEC;\\n\";\n  }\n\n  // Read tangents if available\n  if (hasTangents) {\n    techniqueAttributes.a_tangent = {\n      semantic: \"TANGENT\",\n    };\n    vertexShader += \"attribute vec4 a_tangent;\\n\";\n    vertexShader += \"varying vec4 v_tangent;\\n\";\n    vertexShaderMain +=\n      \"    v_tangent.xyz = u_normalMatrix * weightedTangent.xyz;\\n\";\n    vertexShaderMain += \"    v_tangent.w = weightedTangent.w;\\n\";\n\n    fragmentShader += \"varying vec4 v_tangent;\\n\";\n  }\n\n  if (hasOutline) {\n    fragmentShader += \"varying vec3 v_outlineCoordinates;\\n\";\n  }\n\n  var fragmentShaderMain = \"\";\n\n  // Add texture coordinates if the material uses them\n  var v_texCoord;\n  var normalTexCoord;\n  var baseColorTexCoord;\n  var specularGlossinessTexCoord;\n  var diffuseTexCoord;\n  var metallicRoughnessTexCoord;\n  var occlusionTexCoord;\n  var emissiveTexCoord;\n\n  if (hasTexCoords) {\n    techniqueAttributes.a_texcoord_0 = {\n      semantic: \"TEXCOORD_0\",\n    };\n\n    v_texCoord = \"v_texcoord_0\";\n    vertexShader += \"attribute vec2 a_texcoord_0;\\n\";\n    vertexShader += \"varying vec2 \" + v_texCoord + \";\\n\";\n    vertexShaderMain += \"    \" + v_texCoord + \" = a_texcoord_0;\\n\";\n\n    fragmentShader += \"varying vec2 \" + v_texCoord + \";\\n\";\n\n    var result = {\n      fragmentShaderMain: fragmentShaderMain,\n    };\n    normalTexCoord = addTextureCoordinates(\n      gltf,\n      \"u_normalTexture\",\n      generatedMaterialValues,\n      v_texCoord,\n      result\n    );\n    baseColorTexCoord = addTextureCoordinates(\n      gltf,\n      \"u_baseColorTexture\",\n      generatedMaterialValues,\n      v_texCoord,\n      result\n    );\n    specularGlossinessTexCoord = addTextureCoordinates(\n      gltf,\n      \"u_specularGlossinessTexture\",\n      generatedMaterialValues,\n      v_texCoord,\n      result\n    );\n    diffuseTexCoord = addTextureCoordinates(\n      gltf,\n      \"u_diffuseTexture\",\n      generatedMaterialValues,\n      v_texCoord,\n      result\n    );\n    metallicRoughnessTexCoord = addTextureCoordinates(\n      gltf,\n      \"u_metallicRoughnessTexture\",\n      generatedMaterialValues,\n      v_texCoord,\n      result\n    );\n    occlusionTexCoord = addTextureCoordinates(\n      gltf,\n      \"u_occlusionTexture\",\n      generatedMaterialValues,\n      v_texCoord,\n      result\n    );\n    emissiveTexCoord = addTextureCoordinates(\n      gltf,\n      \"u_emmissiveTexture\",\n      generatedMaterialValues,\n      v_texCoord,\n      result\n    );\n\n    fragmentShaderMain = result.fragmentShaderMain;\n  }\n\n  // Add skinning information if available\n  if (hasSkinning) {\n    var attributeType = ModelUtility.getShaderVariable(skinningInfo.type);\n    techniqueAttributes.a_joint = {\n      semantic: \"JOINTS_0\",\n    };\n    techniqueAttributes.a_weight = {\n      semantic: \"WEIGHTS_0\",\n    };\n\n    vertexShader += \"attribute \" + attributeType + \" a_joint;\\n\";\n    vertexShader += \"attribute \" + attributeType + \" a_weight;\\n\";\n  }\n\n  if (hasVertexColors) {\n    techniqueAttributes.a_vertexColor = {\n      semantic: \"COLOR_0\",\n    };\n    vertexShader += \"attribute vec4 a_vertexColor;\\n\";\n    vertexShader += \"varying vec4 v_vertexColor;\\n\";\n    vertexShaderMain += \"  v_vertexColor = a_vertexColor;\\n\";\n    fragmentShader += \"varying vec4 v_vertexColor;\\n\";\n  }\n\n  if (addBatchIdToGeneratedShaders) {\n    techniqueAttributes.a_batchId = {\n      semantic: \"_BATCHID\",\n    };\n    vertexShader += \"attribute float a_batchId;\\n\";\n  }\n\n  vertexShader += \"void main(void) \\n{\\n\";\n  vertexShader += vertexShaderMain;\n  vertexShader += \"}\\n\";\n\n  // Fragment shader lighting\n  if (hasNormals) {\n    fragmentShader += \"const float M_PI = 3.141592653589793;\\n\";\n\n    fragmentShader +=\n      \"vec3 lambertianDiffuse(vec3 diffuseColor) \\n\" +\n      \"{\\n\" +\n      \"    return diffuseColor / M_PI;\\n\" +\n      \"}\\n\\n\";\n\n    fragmentShader +=\n      \"vec3 fresnelSchlick2(vec3 f0, vec3 f90, float VdotH) \\n\" +\n      \"{\\n\" +\n      \"    return f0 + (f90 - f0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);\\n\" +\n      \"}\\n\\n\";\n\n    fragmentShader +=\n      \"vec3 fresnelSchlick(float metalness, float VdotH) \\n\" +\n      \"{\\n\" +\n      \"    return metalness + (vec3(1.0) - metalness) * pow(1.0 - VdotH, 5.0);\\n\" +\n      \"}\\n\\n\";\n\n    fragmentShader +=\n      \"float smithVisibilityG1(float NdotV, float roughness) \\n\" +\n      \"{\\n\" +\n      \"    float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;\\n\" +\n      \"    return NdotV / (NdotV * (1.0 - k) + k);\\n\" +\n      \"}\\n\\n\";\n\n    fragmentShader +=\n      \"float smithVisibilityGGX(float roughness, float NdotL, float NdotV) \\n\" +\n      \"{\\n\" +\n      \"    return smithVisibilityG1(NdotL, roughness) * smithVisibilityG1(NdotV, roughness);\\n\" +\n      \"}\\n\\n\";\n\n    fragmentShader +=\n      \"float GGX(float roughness, float NdotH) \\n\" +\n      \"{\\n\" +\n      \"    float roughnessSquared = roughness * roughness;\\n\" +\n      \"    float f = (NdotH * roughnessSquared - NdotH) * NdotH + 1.0;\\n\" +\n      \"    return roughnessSquared / (M_PI * f * f);\\n\" +\n      \"}\\n\\n\";\n  }\n\n  fragmentShader +=\n    \"vec3 SRGBtoLINEAR3(vec3 srgbIn) \\n\" +\n    \"{\\n\" +\n    \"    return pow(srgbIn, vec3(2.2));\\n\" +\n    \"}\\n\\n\";\n\n  fragmentShader +=\n    \"vec4 SRGBtoLINEAR4(vec4 srgbIn) \\n\" +\n    \"{\\n\" +\n    \"    vec3 linearOut = pow(srgbIn.rgb, vec3(2.2));\\n\" +\n    \"    return vec4(linearOut, srgbIn.a);\\n\" +\n    \"}\\n\\n\";\n\n  fragmentShader +=\n    \"vec3 applyTonemapping(vec3 linearIn) \\n\" +\n    \"{\\n\" +\n    \"#ifndef HDR \\n\" +\n    \"    return czm_acesTonemapping(linearIn);\\n\" +\n    \"#else \\n\" +\n    \"    return linearIn;\\n\" +\n    \"#endif \\n\" +\n    \"}\\n\\n\";\n\n  fragmentShader +=\n    \"vec3 LINEARtoSRGB(vec3 linearIn) \\n\" +\n    \"{\\n\" +\n    \"#ifndef HDR \\n\" +\n    \"    return pow(linearIn, vec3(1.0/2.2));\\n\" +\n    \"#else \\n\" +\n    \"    return linearIn;\\n\" +\n    \"#endif \\n\" +\n    \"}\\n\\n\";\n\n  fragmentShader +=\n    \"vec2 computeTexCoord(vec2 texCoords, vec2 offset, float rotation, vec2 scale) \\n\" +\n    \"{\\n\" +\n    \"    rotation = -rotation; \\n\" +\n    \"    mat3 transform = mat3(\\n\" +\n    \"        cos(rotation) * scale.x, sin(rotation) * scale.x, 0.0, \\n\" +\n    \"       -sin(rotation) * scale.y, cos(rotation) * scale.y, 0.0, \\n\" +\n    \"        offset.x, offset.y, 1.0); \\n\" +\n    \"    vec2 transformedTexCoords = (transform * vec3(fract(texCoords), 1.0)).xy; \\n\" +\n    \"    return transformedTexCoords; \\n\" +\n    \"}\\n\\n\";\n\n  fragmentShader += \"#ifdef USE_IBL_LIGHTING \\n\";\n  fragmentShader += \"uniform vec2 gltf_iblFactor; \\n\";\n  fragmentShader += \"#endif \\n\";\n  fragmentShader += \"#ifdef USE_CUSTOM_LIGHT_COLOR \\n\";\n  fragmentShader += \"uniform vec3 gltf_lightColor; \\n\";\n  fragmentShader += \"#endif \\n\";\n\n  fragmentShader += \"void main(void) \\n{\\n\";\n  fragmentShader += fragmentShaderMain;\n\n  // Add normal mapping to fragment shader\n  if (hasNormals) {\n    fragmentShader += \"    vec3 ng = normalize(v_normal);\\n\";\n    fragmentShader +=\n      \"    vec3 positionWC = vec3(czm_inverseView * vec4(v_positionEC, 1.0));\\n\";\n    if (defined(generatedMaterialValues.u_normalTexture)) {\n      if (hasTangents) {\n        // Read tangents from varying\n        fragmentShader += \"    vec3 t = normalize(v_tangent.xyz);\\n\";\n        fragmentShader +=\n          \"    vec3 b = normalize(cross(ng, t) * v_tangent.w);\\n\";\n        fragmentShader += \"    mat3 tbn = mat3(t, b, ng);\\n\";\n        fragmentShader +=\n          \"    vec3 n = texture2D(u_normalTexture, \" +\n          normalTexCoord +\n          \").rgb;\\n\";\n        fragmentShader += \"    n = normalize(tbn * (2.0 * n - 1.0));\\n\";\n      } else {\n        // Add standard derivatives extension\n        fragmentShader =\n          \"#ifdef GL_OES_standard_derivatives\\n\" +\n          \"#extension GL_OES_standard_derivatives : enable\\n\" +\n          \"#endif\\n\" +\n          fragmentShader;\n        // Compute tangents\n        fragmentShader += \"#ifdef GL_OES_standard_derivatives\\n\";\n        fragmentShader += \"    vec3 pos_dx = dFdx(v_positionEC);\\n\";\n        fragmentShader += \"    vec3 pos_dy = dFdy(v_positionEC);\\n\";\n        fragmentShader +=\n          \"    vec3 tex_dx = dFdx(vec3(\" + normalTexCoord + \",0.0));\\n\";\n        fragmentShader +=\n          \"    vec3 tex_dy = dFdy(vec3(\" + normalTexCoord + \",0.0));\\n\";\n        fragmentShader +=\n          \"    vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\\n\";\n        fragmentShader += \"    t = normalize(t - ng * dot(ng, t));\\n\";\n        fragmentShader += \"    vec3 b = normalize(cross(ng, t));\\n\";\n        fragmentShader += \"    mat3 tbn = mat3(t, b, ng);\\n\";\n        fragmentShader +=\n          \"    vec3 n = texture2D(u_normalTexture, \" +\n          normalTexCoord +\n          \").rgb;\\n\";\n        fragmentShader += \"    n = normalize(tbn * (2.0 * n - 1.0));\\n\";\n        fragmentShader += \"#else\\n\";\n        fragmentShader += \"    vec3 n = ng;\\n\";\n        fragmentShader += \"#endif\\n\";\n      }\n    } else {\n      fragmentShader += \"    vec3 n = ng;\\n\";\n    }\n    if (material.doubleSided) {\n      // !gl_FrontFacing doesn't work as expected on Mac/Intel so use the more verbose form instead. See https://github.com/CesiumGS/cesium/pull/8494.\n      fragmentShader += \"    if (gl_FrontFacing == false)\\n\";\n      fragmentShader += \"    {\\n\";\n      fragmentShader += \"        n = -n;\\n\";\n      fragmentShader += \"    }\\n\";\n    }\n  }\n\n  // Add base color to fragment shader\n  if (defined(generatedMaterialValues.u_baseColorTexture)) {\n    fragmentShader +=\n      \"    vec4 baseColorWithAlpha = SRGBtoLINEAR4(texture2D(u_baseColorTexture, \" +\n      baseColorTexCoord +\n      \"));\\n\";\n    if (defined(generatedMaterialValues.u_baseColorFactor)) {\n      fragmentShader += \"    baseColorWithAlpha *= u_baseColorFactor;\\n\";\n    }\n  } else if (defined(generatedMaterialValues.u_baseColorFactor)) {\n    fragmentShader += \"    vec4 baseColorWithAlpha = u_baseColorFactor;\\n\";\n  } else {\n    fragmentShader += \"    vec4 baseColorWithAlpha = vec4(1.0);\\n\";\n  }\n\n  if (hasVertexColors) {\n    fragmentShader += \"    baseColorWithAlpha *= v_vertexColor;\\n\";\n  }\n\n  fragmentShader += \"    vec3 baseColor = baseColorWithAlpha.rgb;\\n\";\n\n  if (hasNormals) {\n    if (useSpecGloss) {\n      if (defined(generatedMaterialValues.u_specularGlossinessTexture)) {\n        fragmentShader +=\n          \"    vec4 specularGlossiness = SRGBtoLINEAR4(texture2D(u_specularGlossinessTexture, \" +\n          specularGlossinessTexCoord +\n          \"));\\n\";\n        fragmentShader += \"    vec3 specular = specularGlossiness.rgb;\\n\";\n        fragmentShader += \"    float glossiness = specularGlossiness.a;\\n\";\n        if (defined(generatedMaterialValues.u_specularFactor)) {\n          fragmentShader += \"    specular *= u_specularFactor;\\n\";\n        }\n        if (defined(generatedMaterialValues.u_glossinessFactor)) {\n          fragmentShader += \"    glossiness *= u_glossinessFactor;\\n\";\n        }\n      } else {\n        if (defined(generatedMaterialValues.u_specularFactor)) {\n          fragmentShader +=\n            \"    vec3 specular = clamp(u_specularFactor, vec3(0.0), vec3(1.0));\\n\";\n        } else {\n          fragmentShader += \"    vec3 specular = vec3(1.0);\\n\";\n        }\n        if (defined(generatedMaterialValues.u_glossinessFactor)) {\n          fragmentShader +=\n            \"    float glossiness = clamp(u_glossinessFactor, 0.0, 1.0);\\n\";\n        } else {\n          fragmentShader += \"    float glossiness = 1.0;\\n\";\n        }\n      }\n      if (defined(generatedMaterialValues.u_diffuseTexture)) {\n        fragmentShader +=\n          \"    vec4 diffuse = SRGBtoLINEAR4(texture2D(u_diffuseTexture, \" +\n          diffuseTexCoord +\n          \"));\\n\";\n        if (defined(generatedMaterialValues.u_diffuseFactor)) {\n          fragmentShader += \"    diffuse *= u_diffuseFactor;\\n\";\n        }\n      } else if (defined(generatedMaterialValues.u_diffuseFactor)) {\n        fragmentShader +=\n          \"    vec4 diffuse = clamp(u_diffuseFactor, vec4(0.0), vec4(1.0));\\n\";\n      } else {\n        fragmentShader += \"    vec4 diffuse = vec4(1.0);\\n\";\n      }\n    } else if (defined(generatedMaterialValues.u_metallicRoughnessTexture)) {\n      fragmentShader +=\n        \"    vec3 metallicRoughness = texture2D(u_metallicRoughnessTexture, \" +\n        metallicRoughnessTexCoord +\n        \").rgb;\\n\";\n      fragmentShader +=\n        \"    float metalness = clamp(metallicRoughness.b, 0.0, 1.0);\\n\";\n      fragmentShader +=\n        \"    float roughness = clamp(metallicRoughness.g, 0.04, 1.0);\\n\";\n      if (defined(generatedMaterialValues.u_metallicFactor)) {\n        fragmentShader += \"    metalness *= u_metallicFactor;\\n\";\n      }\n      if (defined(generatedMaterialValues.u_roughnessFactor)) {\n        fragmentShader += \"    roughness *= u_roughnessFactor;\\n\";\n      }\n    } else {\n      if (defined(generatedMaterialValues.u_metallicFactor)) {\n        fragmentShader +=\n          \"    float metalness = clamp(u_metallicFactor, 0.0, 1.0);\\n\";\n      } else {\n        fragmentShader += \"    float metalness = 1.0;\\n\";\n      }\n      if (defined(generatedMaterialValues.u_roughnessFactor)) {\n        fragmentShader +=\n          \"    float roughness = clamp(u_roughnessFactor, 0.04, 1.0);\\n\";\n      } else {\n        fragmentShader += \"    float roughness = 1.0;\\n\";\n      }\n    }\n\n    fragmentShader += \"    vec3 v = -normalize(v_positionEC);\\n\";\n\n    // Generate fragment shader's lighting block\n    fragmentShader += \"#ifndef USE_CUSTOM_LIGHT_COLOR \\n\";\n    fragmentShader += \"    vec3 lightColorHdr = czm_lightColorHdr;\\n\";\n    fragmentShader += \"#else \\n\";\n    fragmentShader += \"    vec3 lightColorHdr = gltf_lightColor;\\n\";\n    fragmentShader += \"#endif \\n\";\n    fragmentShader += \"    vec3 l = normalize(czm_lightDirectionEC);\\n\";\n    fragmentShader += \"    vec3 h = normalize(v + l);\\n\";\n    fragmentShader += \"    float NdotL = clamp(dot(n, l), 0.001, 1.0);\\n\";\n    fragmentShader += \"    float NdotV = abs(dot(n, v)) + 0.001;\\n\";\n    fragmentShader += \"    float NdotH = clamp(dot(n, h), 0.0, 1.0);\\n\";\n    fragmentShader += \"    float LdotH = clamp(dot(l, h), 0.0, 1.0);\\n\";\n    fragmentShader += \"    float VdotH = clamp(dot(v, h), 0.0, 1.0);\\n\";\n    fragmentShader += \"    vec3 f0 = vec3(0.04);\\n\";\n    // Whether the material uses metallic-roughness or specular-glossiness changes how the BRDF inputs are computed.\n    // It does not change the implementation of the BRDF itself.\n    if (useSpecGloss) {\n      fragmentShader += \"    float roughness = 1.0 - glossiness;\\n\";\n      fragmentShader +=\n        \"    vec3 diffuseColor = diffuse.rgb * (1.0 - max(max(specular.r, specular.g), specular.b));\\n\";\n      fragmentShader += \"    vec3 specularColor = specular;\\n\";\n    } else {\n      fragmentShader +=\n        \"    vec3 diffuseColor = baseColor * (1.0 - metalness) * (1.0 - f0);\\n\";\n      fragmentShader +=\n        \"    vec3 specularColor = mix(f0, baseColor, metalness);\\n\";\n    }\n\n    fragmentShader += \"    float alpha = roughness * roughness;\\n\";\n    fragmentShader +=\n      \"    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\\n\";\n    fragmentShader +=\n      \"    vec3 r90 = vec3(clamp(reflectance * 25.0, 0.0, 1.0));\\n\";\n    fragmentShader += \"    vec3 r0 = specularColor.rgb;\\n\";\n\n    fragmentShader += \"    vec3 F = fresnelSchlick2(r0, r90, VdotH);\\n\";\n    fragmentShader +=\n      \"    float G = smithVisibilityGGX(alpha, NdotL, NdotV);\\n\";\n    fragmentShader += \"    float D = GGX(alpha, NdotH);\\n\";\n\n    fragmentShader +=\n      \"    vec3 diffuseContribution = (1.0 - F) * lambertianDiffuse(diffuseColor);\\n\";\n    fragmentShader +=\n      \"    vec3 specularContribution = F * G * D / (4.0 * NdotL * NdotV);\\n\";\n    fragmentShader +=\n      \"    vec3 color = NdotL * lightColorHdr * (diffuseContribution + specularContribution);\\n\";\n\n    // Use the procedural IBL if there are no environment maps\n    fragmentShader +=\n      \"#if defined(USE_IBL_LIGHTING) && !defined(DIFFUSE_IBL) && !defined(SPECULAR_IBL) \\n\";\n\n    fragmentShader +=\n      \"    vec3 r = normalize(czm_inverseViewRotation * normalize(reflect(v, n)));\\n\";\n    // Figure out if the reflection vector hits the ellipsoid\n    fragmentShader += \"    float vertexRadius = length(positionWC);\\n\";\n    fragmentShader +=\n      \"    float horizonDotNadir = 1.0 - min(1.0, czm_ellipsoidRadii.x / vertexRadius);\\n\";\n    fragmentShader +=\n      \"    float reflectionDotNadir = dot(r, normalize(positionWC));\\n\";\n    // Flipping the X vector is a cheap way to get the inverse of czm_temeToPseudoFixed, since that's a rotation about Z.\n    fragmentShader += \"    r.x = -r.x;\\n\";\n    fragmentShader += \"    r = -normalize(czm_temeToPseudoFixed * r);\\n\";\n    fragmentShader += \"    r.x = -r.x;\\n\";\n\n    fragmentShader += \"    float inverseRoughness = 1.04 - roughness;\\n\";\n    fragmentShader += \"    inverseRoughness *= inverseRoughness;\\n\";\n    fragmentShader +=\n      \"    vec3 sceneSkyBox = textureCube(czm_environmentMap, r).rgb * inverseRoughness;\\n\";\n\n    fragmentShader += \"    float atmosphereHeight = 0.05;\\n\";\n    fragmentShader +=\n      \"    float blendRegionSize = 0.1 * ((1.0 - inverseRoughness) * 8.0 + 1.1 - horizonDotNadir);\\n\";\n    fragmentShader += \"    float blendRegionOffset = roughness * -1.0;\\n\";\n    fragmentShader +=\n      \"    float farAboveHorizon = clamp(horizonDotNadir - blendRegionSize * 0.5 + blendRegionOffset, 1.0e-10 - blendRegionSize, 0.99999);\\n\";\n    fragmentShader +=\n      \"    float aroundHorizon = clamp(horizonDotNadir + blendRegionSize * 0.5, 1.0e-10 - blendRegionSize, 0.99999);\\n\";\n    fragmentShader +=\n      \"    float farBelowHorizon = clamp(horizonDotNadir + blendRegionSize * 1.5, 1.0e-10 - blendRegionSize, 0.99999);\\n\";\n    fragmentShader +=\n      \"    float smoothstepHeight = smoothstep(0.0, atmosphereHeight, horizonDotNadir);\\n\";\n\n    fragmentShader +=\n      \"    vec3 belowHorizonColor = mix(vec3(0.1, 0.15, 0.25), vec3(0.4, 0.7, 0.9), smoothstepHeight);\\n\";\n    fragmentShader += \"    vec3 nadirColor = belowHorizonColor * 0.5;\\n\";\n    fragmentShader +=\n      \"    vec3 aboveHorizonColor = mix(vec3(0.9, 1.0, 1.2), belowHorizonColor, roughness * 0.5);\\n\";\n    fragmentShader +=\n      \"    vec3 blueSkyColor = mix(vec3(0.18, 0.26, 0.48), aboveHorizonColor, reflectionDotNadir * inverseRoughness * 0.5 + 0.75);\\n\";\n    fragmentShader +=\n      \"    vec3 zenithColor = mix(blueSkyColor, sceneSkyBox, smoothstepHeight);\\n\";\n\n    fragmentShader += \"    vec3 blueSkyDiffuseColor = vec3(0.7, 0.85, 0.9);\\n\";\n    fragmentShader +=\n      \"    float diffuseIrradianceFromEarth = (1.0 - horizonDotNadir) * (reflectionDotNadir * 0.25 + 0.75) * smoothstepHeight;\\n\";\n    fragmentShader +=\n      \"    float diffuseIrradianceFromSky = (1.0 - smoothstepHeight) * (1.0 - (reflectionDotNadir * 0.25 + 0.25));\\n\";\n    fragmentShader +=\n      \"    vec3 diffuseIrradiance = blueSkyDiffuseColor * clamp(diffuseIrradianceFromEarth + diffuseIrradianceFromSky, 0.0, 1.0);\\n\";\n\n    fragmentShader +=\n      \"    float notDistantRough = (1.0 - horizonDotNadir * roughness * 0.8);\\n\";\n    fragmentShader +=\n      \"    vec3 specularIrradiance = mix(zenithColor, aboveHorizonColor, smoothstep(farAboveHorizon, aroundHorizon, reflectionDotNadir) * notDistantRough);\\n\";\n    fragmentShader +=\n      \"    specularIrradiance = mix(specularIrradiance, belowHorizonColor, smoothstep(aroundHorizon, farBelowHorizon, reflectionDotNadir) * inverseRoughness);\\n\";\n    fragmentShader +=\n      \"    specularIrradiance = mix(specularIrradiance, nadirColor, smoothstep(farBelowHorizon, 1.0, reflectionDotNadir) * inverseRoughness);\\n\";\n\n    // Luminance model from page 40 of http://silviojemma.com/public/papers/lighting/spherical-harmonic-lighting.pdf\n    fragmentShader += \"#ifdef USE_SUN_LUMINANCE \\n\";\n    // Angle between sun and zenith\n    fragmentShader +=\n      \"    float LdotZenith = clamp(dot(normalize(czm_inverseViewRotation * l), normalize(positionWC * -1.0)), 0.001, 1.0);\\n\";\n    fragmentShader += \"    float S = acos(LdotZenith);\\n\";\n    // Angle between zenith and current pixel\n    fragmentShader +=\n      \"    float NdotZenith = clamp(dot(normalize(czm_inverseViewRotation * n), normalize(positionWC * -1.0)), 0.001, 1.0);\\n\";\n    // Angle between sun and current pixel\n    fragmentShader += \"    float gamma = acos(NdotL);\\n\";\n    fragmentShader +=\n      \"    float numerator = ((0.91 + 10.0 * exp(-3.0 * gamma) + 0.45 * pow(NdotL, 2.0)) * (1.0 - exp(-0.32 / NdotZenith)));\\n\";\n    fragmentShader +=\n      \"    float denominator = (0.91 + 10.0 * exp(-3.0 * S) + 0.45 * pow(LdotZenith,2.0)) * (1.0 - exp(-0.32));\\n\";\n    fragmentShader +=\n      \"    float luminance = gltf_luminanceAtZenith * (numerator / denominator);\\n\";\n    fragmentShader += \"#endif \\n\";\n\n    fragmentShader +=\n      \"    vec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, roughness)).rg;\\n\";\n    fragmentShader +=\n      \"    vec3 IBLColor = (diffuseIrradiance * diffuseColor * gltf_iblFactor.x) + (specularIrradiance * SRGBtoLINEAR3(specularColor * brdfLut.x + brdfLut.y) * gltf_iblFactor.y);\\n\";\n\n    fragmentShader +=\n      \"    float maximumComponent = max(max(lightColorHdr.x, lightColorHdr.y), lightColorHdr.z);\\n\";\n    fragmentShader +=\n      \"    vec3 lightColor = lightColorHdr / max(maximumComponent, 1.0);\\n\";\n    fragmentShader += \"    IBLColor *= lightColor;\\n\";\n\n    fragmentShader += \"#ifdef USE_SUN_LUMINANCE \\n\";\n    fragmentShader += \"    color += IBLColor * luminance;\\n\";\n    fragmentShader += \"#else \\n\";\n    fragmentShader += \"    color += IBLColor; \\n\";\n    fragmentShader += \"#endif \\n\";\n\n    // Environment maps were provided, use them for IBL\n    fragmentShader += \"#elif defined(DIFFUSE_IBL) || defined(SPECULAR_IBL) \\n\";\n\n    fragmentShader +=\n      \"    mat3 fixedToENU = mat3(gltf_clippingPlanesMatrix[0][0], gltf_clippingPlanesMatrix[1][0], gltf_clippingPlanesMatrix[2][0], \\n\";\n    fragmentShader +=\n      \"                           gltf_clippingPlanesMatrix[0][1], gltf_clippingPlanesMatrix[1][1], gltf_clippingPlanesMatrix[2][1], \\n\";\n    fragmentShader +=\n      \"                           gltf_clippingPlanesMatrix[0][2], gltf_clippingPlanesMatrix[1][2], gltf_clippingPlanesMatrix[2][2]); \\n\";\n    fragmentShader +=\n      \"    const mat3 yUpToZUp = mat3(-1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0); \\n\";\n    fragmentShader +=\n      \"    vec3 cubeDir = normalize(yUpToZUp * fixedToENU * normalize(reflect(-v, n))); \\n\";\n\n    fragmentShader += \"#ifdef DIFFUSE_IBL \\n\";\n    fragmentShader += \"#ifdef CUSTOM_SPHERICAL_HARMONICS \\n\";\n    fragmentShader +=\n      \"    vec3 diffuseIrradiance = czm_sphericalHarmonics(cubeDir, gltf_sphericalHarmonicCoefficients); \\n\";\n    fragmentShader += \"#else \\n\";\n    fragmentShader +=\n      \"    vec3 diffuseIrradiance = czm_sphericalHarmonics(cubeDir, czm_sphericalHarmonicCoefficients); \\n\";\n    fragmentShader += \"#endif \\n\";\n    fragmentShader += \"#else \\n\";\n    fragmentShader += \"    vec3 diffuseIrradiance = vec3(0.0); \\n\";\n    fragmentShader += \"#endif \\n\";\n\n    fragmentShader += \"#ifdef SPECULAR_IBL \\n\";\n    fragmentShader +=\n      \"    vec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, roughness)).rg;\\n\";\n    fragmentShader += \"#ifdef CUSTOM_SPECULAR_IBL \\n\";\n    fragmentShader +=\n      \"    vec3 specularIBL = czm_sampleOctahedralProjection(gltf_specularMap, gltf_specularMapSize, cubeDir,  roughness * gltf_maxSpecularLOD, gltf_maxSpecularLOD);\\n\";\n    fragmentShader += \"#else \\n\";\n    fragmentShader +=\n      \"    vec3 specularIBL = czm_sampleOctahedralProjection(czm_specularEnvironmentMaps, czm_specularEnvironmentMapSize, cubeDir,  roughness * czm_specularEnvironmentMapsMaximumLOD, czm_specularEnvironmentMapsMaximumLOD);\\n\";\n    fragmentShader += \"#endif \\n\";\n    fragmentShader += \"    specularIBL *= F * brdfLut.x + brdfLut.y;\\n\";\n    fragmentShader += \"#else \\n\";\n    fragmentShader += \"    vec3 specularIBL = vec3(0.0); \\n\";\n    fragmentShader += \"#endif \\n\";\n\n    fragmentShader +=\n      \"    color += diffuseIrradiance * diffuseColor + specularColor * specularIBL;\\n\";\n\n    fragmentShader += \"#endif \\n\";\n  } else {\n    fragmentShader += \"    vec3 color = baseColor;\\n\";\n  }\n\n  // Ignore occlusion and emissive when unlit\n  if (!isUnlit) {\n    if (defined(generatedMaterialValues.u_occlusionTexture)) {\n      fragmentShader +=\n        \"    color *= texture2D(u_occlusionTexture, \" +\n        occlusionTexCoord +\n        \").r;\\n\";\n    }\n    if (defined(generatedMaterialValues.u_emissiveTexture)) {\n      fragmentShader +=\n        \"    vec3 emissive = SRGBtoLINEAR3(texture2D(u_emissiveTexture, \" +\n        emissiveTexCoord +\n        \").rgb);\\n\";\n      if (defined(generatedMaterialValues.u_emissiveFactor)) {\n        fragmentShader += \"    emissive *= u_emissiveFactor;\\n\";\n      }\n      fragmentShader += \"    color += emissive;\\n\";\n    } else if (defined(generatedMaterialValues.u_emissiveFactor)) {\n      fragmentShader += \"    color += u_emissiveFactor;\\n\";\n    }\n  }\n\n  if (!isUnlit) {\n    fragmentShader += \"    color = applyTonemapping(color);\\n\";\n  }\n\n  fragmentShader += \"    color = LINEARtoSRGB(color);\\n\";\n\n  if (hasOutline) {\n    fragmentShader += \"    float outlineness = max(\\n\";\n    fragmentShader +=\n      \"        texture2D(u_outlineTexture, vec2(v_outlineCoordinates.x, 0.5)).r,\\n\";\n    fragmentShader += \"        max(\\n\";\n    fragmentShader +=\n      \"          texture2D(u_outlineTexture, vec2(v_outlineCoordinates.y, 0.5)).r,\\n\";\n    fragmentShader +=\n      \"          texture2D(u_outlineTexture, vec2(v_outlineCoordinates.z, 0.5)).r));\\n\";\n    fragmentShader +=\n      \"    color = mix(color, vec3(0.0, 0.0, 0.0), outlineness);\\n\";\n  }\n\n  if (defined(alphaMode)) {\n    if (alphaMode === \"MASK\") {\n      fragmentShader += \"    if (baseColorWithAlpha.a < u_alphaCutoff) {\\n\";\n      fragmentShader += \"        discard;\\n\";\n      fragmentShader += \"    }\\n\";\n      fragmentShader += \"    gl_FragColor = vec4(color, 1.0);\\n\";\n    } else if (alphaMode === \"BLEND\") {\n      fragmentShader +=\n        \"    gl_FragColor = vec4(color, baseColorWithAlpha.a);\\n\";\n    } else {\n      fragmentShader += \"    gl_FragColor = vec4(color, 1.0);\\n\";\n    }\n  } else {\n    fragmentShader += \"    gl_FragColor = vec4(color, 1.0);\\n\";\n  }\n\n  fragmentShader += \"}\\n\";\n\n  // Add shaders\n  var vertexShaderId = addToArray(shaders, {\n    type: WebGLConstants.VERTEX_SHADER,\n    extras: {\n      _pipeline: {\n        source: vertexShader,\n        extension: \".glsl\",\n      },\n    },\n  });\n\n  var fragmentShaderId = addToArray(shaders, {\n    type: WebGLConstants.FRAGMENT_SHADER,\n    extras: {\n      _pipeline: {\n        source: fragmentShader,\n        extension: \".glsl\",\n      },\n    },\n  });\n\n  // Add program\n  var programId = addToArray(programs, {\n    fragmentShader: fragmentShaderId,\n    vertexShader: vertexShaderId,\n  });\n\n  var techniqueId = addToArray(techniques, {\n    attributes: techniqueAttributes,\n    program: programId,\n    uniforms: techniqueUniforms,\n  });\n\n  return techniqueId;\n}\n\nfunction getPBRValueType(paramName) {\n  if (paramName.indexOf(\"Offset\") !== -1) {\n    return WebGLConstants.FLOAT_VEC2;\n  } else if (paramName.indexOf(\"Rotation\") !== -1) {\n    return WebGLConstants.FLOAT;\n  } else if (paramName.indexOf(\"Scale\") !== -1) {\n    return WebGLConstants.FLOAT_VEC2;\n  } else if (paramName.indexOf(\"Texture\") !== -1) {\n    return WebGLConstants.SAMPLER_2D;\n  }\n\n  switch (paramName) {\n    case \"u_baseColorFactor\":\n      return WebGLConstants.FLOAT_VEC4;\n    case \"u_metallicFactor\":\n      return WebGLConstants.FLOAT;\n    case \"u_roughnessFactor\":\n      return WebGLConstants.FLOAT;\n    case \"u_emissiveFactor\":\n      return WebGLConstants.FLOAT_VEC3;\n    // Specular Glossiness Types\n    case \"u_diffuseFactor\":\n      return WebGLConstants.FLOAT_VEC4;\n    case \"u_specularFactor\":\n      return WebGLConstants.FLOAT_VEC3;\n    case \"u_glossinessFactor\":\n      return WebGLConstants.FLOAT;\n  }\n}\nexport default processPbrMaterials;\n"]},"metadata":{},"sourceType":"module"}