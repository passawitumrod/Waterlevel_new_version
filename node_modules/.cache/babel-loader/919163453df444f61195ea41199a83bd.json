{"ast":null,"code":"import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport OrthographicFrustum from \"./OrthographicFrustum.js\";\nimport PerspectiveFrustum from \"./PerspectiveFrustum.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nvar PERSPECTIVE = 0;\nvar ORTHOGRAPHIC = 1;\n/**\n * Describes a frustum at the given the origin and orientation.\n *\n * @alias FrustumGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {PerspectiveFrustum|OrthographicFrustum} options.frustum The frustum.\n * @param {Cartesian3} options.origin The origin of the frustum.\n * @param {Quaternion} options.orientation The orientation of the frustum.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n */\n\nfunction FrustumGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.frustum\", options.frustum);\n  Check.typeOf.object(\"options.origin\", options.origin);\n  Check.typeOf.object(\"options.orientation\", options.orientation); //>>includeEnd('debug');\n\n  var frustum = options.frustum;\n  var orientation = options.orientation;\n  var origin = options.origin;\n  var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT); // This is private because it is used by DebugCameraPrimitive to draw a multi-frustum by\n  // creating multiple FrustumGeometrys. This way the near plane of one frustum doesn't overlap\n  // the far plane of another.\n\n  var drawNearPlane = defaultValue(options._drawNearPlane, true);\n  var frustumType;\n  var frustumPackedLength;\n\n  if (frustum instanceof PerspectiveFrustum) {\n    frustumType = PERSPECTIVE;\n    frustumPackedLength = PerspectiveFrustum.packedLength;\n  } else if (frustum instanceof OrthographicFrustum) {\n    frustumType = ORTHOGRAPHIC;\n    frustumPackedLength = OrthographicFrustum.packedLength;\n  }\n\n  this._frustumType = frustumType;\n  this._frustum = frustum.clone();\n  this._origin = Cartesian3.clone(origin);\n  this._orientation = Quaternion.clone(orientation);\n  this._drawNearPlane = drawNearPlane;\n  this._vertexFormat = vertexFormat;\n  this._workerName = \"createFrustumGeometry\";\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n\n  this.packedLength = 2 + frustumPackedLength + Cartesian3.packedLength + Quaternion.packedLength + VertexFormat.packedLength;\n}\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {FrustumGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\n\nFrustumGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var frustumType = value._frustumType;\n  var frustum = value._frustum;\n  array[startingIndex++] = frustumType;\n\n  if (frustumType === PERSPECTIVE) {\n    PerspectiveFrustum.pack(frustum, array, startingIndex);\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    OrthographicFrustum.pack(frustum, array, startingIndex);\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n\n  Cartesian3.pack(value._origin, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n  Quaternion.pack(value._orientation, array, startingIndex);\n  startingIndex += Quaternion.packedLength;\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n  array[startingIndex] = value._drawNearPlane ? 1.0 : 0.0;\n  return array;\n};\n\nvar scratchPackPerspective = new PerspectiveFrustum();\nvar scratchPackOrthographic = new OrthographicFrustum();\nvar scratchPackQuaternion = new Quaternion();\nvar scratchPackorigin = new Cartesian3();\nvar scratchVertexFormat = new VertexFormat();\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {FrustumGeometry} [result] The object into which to store the result.\n */\n\nFrustumGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var frustumType = array[startingIndex++];\n  var frustum;\n\n  if (frustumType === PERSPECTIVE) {\n    frustum = PerspectiveFrustum.unpack(array, startingIndex, scratchPackPerspective);\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    frustum = OrthographicFrustum.unpack(array, startingIndex, scratchPackOrthographic);\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n\n  var origin = Cartesian3.unpack(array, startingIndex, scratchPackorigin);\n  startingIndex += Cartesian3.packedLength;\n  var orientation = Quaternion.unpack(array, startingIndex, scratchPackQuaternion);\n  startingIndex += Quaternion.packedLength;\n  var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n  startingIndex += VertexFormat.packedLength;\n  var drawNearPlane = array[startingIndex] === 1.0;\n\n  if (!defined(result)) {\n    return new FrustumGeometry({\n      frustum: frustum,\n      origin: origin,\n      orientation: orientation,\n      vertexFormat: vertexFormat,\n      _drawNearPlane: drawNearPlane\n    });\n  }\n\n  var frustumResult = frustumType === result._frustumType ? result._frustum : undefined;\n  result._frustum = frustum.clone(frustumResult);\n  result._frustumType = frustumType;\n  result._origin = Cartesian3.clone(origin, result._origin);\n  result._orientation = Quaternion.clone(orientation, result._orientation);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._drawNearPlane = drawNearPlane;\n  return result;\n};\n\nfunction getAttributes(offset, normals, tangents, bitangents, st, normal, tangent, bitangent) {\n  var stOffset = offset / 3 * 2;\n\n  for (var i = 0; i < 4; ++i) {\n    if (defined(normals)) {\n      normals[offset] = normal.x;\n      normals[offset + 1] = normal.y;\n      normals[offset + 2] = normal.z;\n    }\n\n    if (defined(tangents)) {\n      tangents[offset] = tangent.x;\n      tangents[offset + 1] = tangent.y;\n      tangents[offset + 2] = tangent.z;\n    }\n\n    if (defined(bitangents)) {\n      bitangents[offset] = bitangent.x;\n      bitangents[offset + 1] = bitangent.y;\n      bitangents[offset + 2] = bitangent.z;\n    }\n\n    offset += 3;\n  }\n\n  st[stOffset] = 0.0;\n  st[stOffset + 1] = 0.0;\n  st[stOffset + 2] = 1.0;\n  st[stOffset + 3] = 0.0;\n  st[stOffset + 4] = 1.0;\n  st[stOffset + 5] = 1.0;\n  st[stOffset + 6] = 0.0;\n  st[stOffset + 7] = 1.0;\n}\n\nvar scratchRotationMatrix = new Matrix3();\nvar scratchViewMatrix = new Matrix4();\nvar scratchInverseMatrix = new Matrix4();\nvar scratchXDirection = new Cartesian3();\nvar scratchYDirection = new Cartesian3();\nvar scratchZDirection = new Cartesian3();\nvar scratchNegativeX = new Cartesian3();\nvar scratchNegativeY = new Cartesian3();\nvar scratchNegativeZ = new Cartesian3();\nvar frustumSplits = new Array(3);\nvar frustumCornersNDC = new Array(4);\nfrustumCornersNDC[0] = new Cartesian4(-1.0, -1.0, 1.0, 1.0);\nfrustumCornersNDC[1] = new Cartesian4(1.0, -1.0, 1.0, 1.0);\nfrustumCornersNDC[2] = new Cartesian4(1.0, 1.0, 1.0, 1.0);\nfrustumCornersNDC[3] = new Cartesian4(-1.0, 1.0, 1.0, 1.0);\nvar scratchFrustumCorners = new Array(4);\n\nfor (var i = 0; i < 4; ++i) {\n  scratchFrustumCorners[i] = new Cartesian4();\n}\n\nFrustumGeometry._computeNearFarPlanes = function (origin, orientation, frustumType, frustum, positions, xDirection, yDirection, zDirection) {\n  var rotationMatrix = Matrix3.fromQuaternion(orientation, scratchRotationMatrix);\n  var x = defaultValue(xDirection, scratchXDirection);\n  var y = defaultValue(yDirection, scratchYDirection);\n  var z = defaultValue(zDirection, scratchZDirection);\n  x = Matrix3.getColumn(rotationMatrix, 0, x);\n  y = Matrix3.getColumn(rotationMatrix, 1, y);\n  z = Matrix3.getColumn(rotationMatrix, 2, z);\n  Cartesian3.normalize(x, x);\n  Cartesian3.normalize(y, y);\n  Cartesian3.normalize(z, z);\n  Cartesian3.negate(x, x);\n  var view = Matrix4.computeView(origin, z, y, x, scratchViewMatrix);\n  var inverseView;\n  var inverseViewProjection;\n\n  if (frustumType === PERSPECTIVE) {\n    var projection = frustum.projectionMatrix;\n    var viewProjection = Matrix4.multiply(projection, view, scratchInverseMatrix);\n    inverseViewProjection = Matrix4.inverse(viewProjection, scratchInverseMatrix);\n  } else {\n    inverseView = Matrix4.inverseTransformation(view, scratchInverseMatrix);\n  }\n\n  if (defined(inverseViewProjection)) {\n    frustumSplits[0] = frustum.near;\n    frustumSplits[1] = frustum.far;\n  } else {\n    frustumSplits[0] = 0.0;\n    frustumSplits[1] = frustum.near;\n    frustumSplits[2] = frustum.far;\n  }\n\n  for (var i = 0; i < 2; ++i) {\n    for (var j = 0; j < 4; ++j) {\n      var corner = Cartesian4.clone(frustumCornersNDC[j], scratchFrustumCorners[j]);\n\n      if (!defined(inverseViewProjection)) {\n        if (defined(frustum._offCenterFrustum)) {\n          frustum = frustum._offCenterFrustum;\n        }\n\n        var near = frustumSplits[i];\n        var far = frustumSplits[i + 1];\n        corner.x = (corner.x * (frustum.right - frustum.left) + frustum.left + frustum.right) * 0.5;\n        corner.y = (corner.y * (frustum.top - frustum.bottom) + frustum.bottom + frustum.top) * 0.5;\n        corner.z = (corner.z * (near - far) - near - far) * 0.5;\n        corner.w = 1.0;\n        Matrix4.multiplyByVector(inverseView, corner, corner);\n      } else {\n        corner = Matrix4.multiplyByVector(inverseViewProjection, corner, corner); // Reverse perspective divide\n\n        var w = 1.0 / corner.w;\n        Cartesian3.multiplyByScalar(corner, w, corner);\n        Cartesian3.subtract(corner, origin, corner);\n        Cartesian3.normalize(corner, corner);\n        var fac = Cartesian3.dot(z, corner);\n        Cartesian3.multiplyByScalar(corner, frustumSplits[i] / fac, corner);\n        Cartesian3.add(corner, origin, corner);\n      }\n\n      positions[12 * i + j * 3] = corner.x;\n      positions[12 * i + j * 3 + 1] = corner.y;\n      positions[12 * i + j * 3 + 2] = corner.z;\n    }\n  }\n};\n/**\n * Computes the geometric representation of a frustum, including its vertices, indices, and a bounding sphere.\n *\n * @param {FrustumGeometry} frustumGeometry A description of the frustum.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\n\n\nFrustumGeometry.createGeometry = function (frustumGeometry) {\n  var frustumType = frustumGeometry._frustumType;\n  var frustum = frustumGeometry._frustum;\n  var origin = frustumGeometry._origin;\n  var orientation = frustumGeometry._orientation;\n  var drawNearPlane = frustumGeometry._drawNearPlane;\n  var vertexFormat = frustumGeometry._vertexFormat;\n  var numberOfPlanes = drawNearPlane ? 6 : 5;\n  var positions = new Float64Array(3 * 4 * 6);\n\n  FrustumGeometry._computeNearFarPlanes(origin, orientation, frustumType, frustum, positions); // -x plane\n\n\n  var offset = 3 * 4 * 2;\n  positions[offset] = positions[3 * 4];\n  positions[offset + 1] = positions[3 * 4 + 1];\n  positions[offset + 2] = positions[3 * 4 + 2];\n  positions[offset + 3] = positions[0];\n  positions[offset + 4] = positions[1];\n  positions[offset + 5] = positions[2];\n  positions[offset + 6] = positions[3 * 3];\n  positions[offset + 7] = positions[3 * 3 + 1];\n  positions[offset + 8] = positions[3 * 3 + 2];\n  positions[offset + 9] = positions[3 * 7];\n  positions[offset + 10] = positions[3 * 7 + 1];\n  positions[offset + 11] = positions[3 * 7 + 2]; // -y plane\n\n  offset += 3 * 4;\n  positions[offset] = positions[3 * 5];\n  positions[offset + 1] = positions[3 * 5 + 1];\n  positions[offset + 2] = positions[3 * 5 + 2];\n  positions[offset + 3] = positions[3];\n  positions[offset + 4] = positions[3 + 1];\n  positions[offset + 5] = positions[3 + 2];\n  positions[offset + 6] = positions[0];\n  positions[offset + 7] = positions[1];\n  positions[offset + 8] = positions[2];\n  positions[offset + 9] = positions[3 * 4];\n  positions[offset + 10] = positions[3 * 4 + 1];\n  positions[offset + 11] = positions[3 * 4 + 2]; // +x plane\n\n  offset += 3 * 4;\n  positions[offset] = positions[3];\n  positions[offset + 1] = positions[3 + 1];\n  positions[offset + 2] = positions[3 + 2];\n  positions[offset + 3] = positions[3 * 5];\n  positions[offset + 4] = positions[3 * 5 + 1];\n  positions[offset + 5] = positions[3 * 5 + 2];\n  positions[offset + 6] = positions[3 * 6];\n  positions[offset + 7] = positions[3 * 6 + 1];\n  positions[offset + 8] = positions[3 * 6 + 2];\n  positions[offset + 9] = positions[3 * 2];\n  positions[offset + 10] = positions[3 * 2 + 1];\n  positions[offset + 11] = positions[3 * 2 + 2]; // +y plane\n\n  offset += 3 * 4;\n  positions[offset] = positions[3 * 2];\n  positions[offset + 1] = positions[3 * 2 + 1];\n  positions[offset + 2] = positions[3 * 2 + 2];\n  positions[offset + 3] = positions[3 * 6];\n  positions[offset + 4] = positions[3 * 6 + 1];\n  positions[offset + 5] = positions[3 * 6 + 2];\n  positions[offset + 6] = positions[3 * 7];\n  positions[offset + 7] = positions[3 * 7 + 1];\n  positions[offset + 8] = positions[3 * 7 + 2];\n  positions[offset + 9] = positions[3 * 3];\n  positions[offset + 10] = positions[3 * 3 + 1];\n  positions[offset + 11] = positions[3 * 3 + 2];\n\n  if (!drawNearPlane) {\n    positions = positions.subarray(3 * 4);\n  }\n\n  var attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions\n    })\n  });\n\n  if (defined(vertexFormat.normal) || defined(vertexFormat.tangent) || defined(vertexFormat.bitangent) || defined(vertexFormat.st)) {\n    var normals = defined(vertexFormat.normal) ? new Float32Array(3 * 4 * numberOfPlanes) : undefined;\n    var tangents = defined(vertexFormat.tangent) ? new Float32Array(3 * 4 * numberOfPlanes) : undefined;\n    var bitangents = defined(vertexFormat.bitangent) ? new Float32Array(3 * 4 * numberOfPlanes) : undefined;\n    var st = defined(vertexFormat.st) ? new Float32Array(2 * 4 * numberOfPlanes) : undefined;\n    var x = scratchXDirection;\n    var y = scratchYDirection;\n    var z = scratchZDirection;\n    var negativeX = Cartesian3.negate(x, scratchNegativeX);\n    var negativeY = Cartesian3.negate(y, scratchNegativeY);\n    var negativeZ = Cartesian3.negate(z, scratchNegativeZ);\n    offset = 0;\n\n    if (drawNearPlane) {\n      getAttributes(offset, normals, tangents, bitangents, st, negativeZ, x, y); // near\n\n      offset += 3 * 4;\n    }\n\n    getAttributes(offset, normals, tangents, bitangents, st, z, negativeX, y); // far\n\n    offset += 3 * 4;\n    getAttributes(offset, normals, tangents, bitangents, st, negativeX, negativeZ, y); // -x\n\n    offset += 3 * 4;\n    getAttributes(offset, normals, tangents, bitangents, st, negativeY, negativeZ, negativeX); // -y\n\n    offset += 3 * 4;\n    getAttributes(offset, normals, tangents, bitangents, st, x, z, y); // +x\n\n    offset += 3 * 4;\n    getAttributes(offset, normals, tangents, bitangents, st, y, z, negativeX); // +y\n\n    if (defined(normals)) {\n      attributes.normal = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: normals\n      });\n    }\n\n    if (defined(tangents)) {\n      attributes.tangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: tangents\n      });\n    }\n\n    if (defined(bitangents)) {\n      attributes.bitangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: bitangents\n      });\n    }\n\n    if (defined(st)) {\n      attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: st\n      });\n    }\n  }\n\n  var indices = new Uint16Array(6 * numberOfPlanes);\n\n  for (var i = 0; i < numberOfPlanes; ++i) {\n    var indexOffset = i * 6;\n    var index = i * 4;\n    indices[indexOffset] = index;\n    indices[indexOffset + 1] = index + 1;\n    indices[indexOffset + 2] = index + 2;\n    indices[indexOffset + 3] = index;\n    indices[indexOffset + 4] = index + 2;\n    indices[indexOffset + 5] = index + 3;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: BoundingSphere.fromVertices(positions)\n  });\n};\n\nexport default FrustumGeometry;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/FrustumGeometry.js"],"names":["BoundingSphere","Cartesian3","Cartesian4","Check","ComponentDatatype","defaultValue","defined","Geometry","GeometryAttribute","GeometryAttributes","Matrix3","Matrix4","OrthographicFrustum","PerspectiveFrustum","PrimitiveType","Quaternion","VertexFormat","PERSPECTIVE","ORTHOGRAPHIC","FrustumGeometry","options","typeOf","object","frustum","origin","orientation","vertexFormat","DEFAULT","drawNearPlane","_drawNearPlane","frustumType","frustumPackedLength","packedLength","_frustumType","_frustum","clone","_origin","_orientation","_vertexFormat","_workerName","pack","value","array","startingIndex","scratchPackPerspective","scratchPackOrthographic","scratchPackQuaternion","scratchPackorigin","scratchVertexFormat","unpack","result","frustumResult","undefined","getAttributes","offset","normals","tangents","bitangents","st","normal","tangent","bitangent","stOffset","i","x","y","z","scratchRotationMatrix","scratchViewMatrix","scratchInverseMatrix","scratchXDirection","scratchYDirection","scratchZDirection","scratchNegativeX","scratchNegativeY","scratchNegativeZ","frustumSplits","Array","frustumCornersNDC","scratchFrustumCorners","_computeNearFarPlanes","positions","xDirection","yDirection","zDirection","rotationMatrix","fromQuaternion","getColumn","normalize","negate","view","computeView","inverseView","inverseViewProjection","projection","projectionMatrix","viewProjection","multiply","inverse","inverseTransformation","near","far","j","corner","_offCenterFrustum","right","left","top","bottom","w","multiplyByVector","multiplyByScalar","subtract","fac","dot","add","createGeometry","frustumGeometry","numberOfPlanes","Float64Array","subarray","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","Float32Array","negativeX","negativeY","negativeZ","FLOAT","indices","Uint16Array","indexOffset","index","primitiveType","TRIANGLES","boundingSphere","fromVertices"],"mappings":"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","sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport OrthographicFrustum from \"./OrthographicFrustum.js\";\nimport PerspectiveFrustum from \"./PerspectiveFrustum.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nvar PERSPECTIVE = 0;\nvar ORTHOGRAPHIC = 1;\n\n/**\n * Describes a frustum at the given the origin and orientation.\n *\n * @alias FrustumGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {PerspectiveFrustum|OrthographicFrustum} options.frustum The frustum.\n * @param {Cartesian3} options.origin The origin of the frustum.\n * @param {Quaternion} options.orientation The orientation of the frustum.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n */\nfunction FrustumGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.frustum\", options.frustum);\n  Check.typeOf.object(\"options.origin\", options.origin);\n  Check.typeOf.object(\"options.orientation\", options.orientation);\n  //>>includeEnd('debug');\n\n  var frustum = options.frustum;\n  var orientation = options.orientation;\n  var origin = options.origin;\n  var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n\n  // This is private because it is used by DebugCameraPrimitive to draw a multi-frustum by\n  // creating multiple FrustumGeometrys. This way the near plane of one frustum doesn't overlap\n  // the far plane of another.\n  var drawNearPlane = defaultValue(options._drawNearPlane, true);\n\n  var frustumType;\n  var frustumPackedLength;\n  if (frustum instanceof PerspectiveFrustum) {\n    frustumType = PERSPECTIVE;\n    frustumPackedLength = PerspectiveFrustum.packedLength;\n  } else if (frustum instanceof OrthographicFrustum) {\n    frustumType = ORTHOGRAPHIC;\n    frustumPackedLength = OrthographicFrustum.packedLength;\n  }\n\n  this._frustumType = frustumType;\n  this._frustum = frustum.clone();\n  this._origin = Cartesian3.clone(origin);\n  this._orientation = Quaternion.clone(orientation);\n  this._drawNearPlane = drawNearPlane;\n  this._vertexFormat = vertexFormat;\n  this._workerName = \"createFrustumGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  this.packedLength =\n    2 +\n    frustumPackedLength +\n    Cartesian3.packedLength +\n    Quaternion.packedLength +\n    VertexFormat.packedLength;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {FrustumGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nFrustumGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var frustumType = value._frustumType;\n  var frustum = value._frustum;\n\n  array[startingIndex++] = frustumType;\n\n  if (frustumType === PERSPECTIVE) {\n    PerspectiveFrustum.pack(frustum, array, startingIndex);\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    OrthographicFrustum.pack(frustum, array, startingIndex);\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n\n  Cartesian3.pack(value._origin, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n  Quaternion.pack(value._orientation, array, startingIndex);\n  startingIndex += Quaternion.packedLength;\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n  array[startingIndex] = value._drawNearPlane ? 1.0 : 0.0;\n\n  return array;\n};\n\nvar scratchPackPerspective = new PerspectiveFrustum();\nvar scratchPackOrthographic = new OrthographicFrustum();\nvar scratchPackQuaternion = new Quaternion();\nvar scratchPackorigin = new Cartesian3();\nvar scratchVertexFormat = new VertexFormat();\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {FrustumGeometry} [result] The object into which to store the result.\n */\nFrustumGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var frustumType = array[startingIndex++];\n\n  var frustum;\n  if (frustumType === PERSPECTIVE) {\n    frustum = PerspectiveFrustum.unpack(\n      array,\n      startingIndex,\n      scratchPackPerspective\n    );\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    frustum = OrthographicFrustum.unpack(\n      array,\n      startingIndex,\n      scratchPackOrthographic\n    );\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n\n  var origin = Cartesian3.unpack(array, startingIndex, scratchPackorigin);\n  startingIndex += Cartesian3.packedLength;\n  var orientation = Quaternion.unpack(\n    array,\n    startingIndex,\n    scratchPackQuaternion\n  );\n  startingIndex += Quaternion.packedLength;\n  var vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += VertexFormat.packedLength;\n  var drawNearPlane = array[startingIndex] === 1.0;\n\n  if (!defined(result)) {\n    return new FrustumGeometry({\n      frustum: frustum,\n      origin: origin,\n      orientation: orientation,\n      vertexFormat: vertexFormat,\n      _drawNearPlane: drawNearPlane,\n    });\n  }\n\n  var frustumResult =\n    frustumType === result._frustumType ? result._frustum : undefined;\n  result._frustum = frustum.clone(frustumResult);\n\n  result._frustumType = frustumType;\n  result._origin = Cartesian3.clone(origin, result._origin);\n  result._orientation = Quaternion.clone(orientation, result._orientation);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._drawNearPlane = drawNearPlane;\n\n  return result;\n};\n\nfunction getAttributes(\n  offset,\n  normals,\n  tangents,\n  bitangents,\n  st,\n  normal,\n  tangent,\n  bitangent\n) {\n  var stOffset = (offset / 3) * 2;\n\n  for (var i = 0; i < 4; ++i) {\n    if (defined(normals)) {\n      normals[offset] = normal.x;\n      normals[offset + 1] = normal.y;\n      normals[offset + 2] = normal.z;\n    }\n    if (defined(tangents)) {\n      tangents[offset] = tangent.x;\n      tangents[offset + 1] = tangent.y;\n      tangents[offset + 2] = tangent.z;\n    }\n    if (defined(bitangents)) {\n      bitangents[offset] = bitangent.x;\n      bitangents[offset + 1] = bitangent.y;\n      bitangents[offset + 2] = bitangent.z;\n    }\n    offset += 3;\n  }\n\n  st[stOffset] = 0.0;\n  st[stOffset + 1] = 0.0;\n  st[stOffset + 2] = 1.0;\n  st[stOffset + 3] = 0.0;\n  st[stOffset + 4] = 1.0;\n  st[stOffset + 5] = 1.0;\n  st[stOffset + 6] = 0.0;\n  st[stOffset + 7] = 1.0;\n}\n\nvar scratchRotationMatrix = new Matrix3();\nvar scratchViewMatrix = new Matrix4();\nvar scratchInverseMatrix = new Matrix4();\n\nvar scratchXDirection = new Cartesian3();\nvar scratchYDirection = new Cartesian3();\nvar scratchZDirection = new Cartesian3();\nvar scratchNegativeX = new Cartesian3();\nvar scratchNegativeY = new Cartesian3();\nvar scratchNegativeZ = new Cartesian3();\n\nvar frustumSplits = new Array(3);\n\nvar frustumCornersNDC = new Array(4);\nfrustumCornersNDC[0] = new Cartesian4(-1.0, -1.0, 1.0, 1.0);\nfrustumCornersNDC[1] = new Cartesian4(1.0, -1.0, 1.0, 1.0);\nfrustumCornersNDC[2] = new Cartesian4(1.0, 1.0, 1.0, 1.0);\nfrustumCornersNDC[3] = new Cartesian4(-1.0, 1.0, 1.0, 1.0);\n\nvar scratchFrustumCorners = new Array(4);\nfor (var i = 0; i < 4; ++i) {\n  scratchFrustumCorners[i] = new Cartesian4();\n}\n\nFrustumGeometry._computeNearFarPlanes = function (\n  origin,\n  orientation,\n  frustumType,\n  frustum,\n  positions,\n  xDirection,\n  yDirection,\n  zDirection\n) {\n  var rotationMatrix = Matrix3.fromQuaternion(\n    orientation,\n    scratchRotationMatrix\n  );\n  var x = defaultValue(xDirection, scratchXDirection);\n  var y = defaultValue(yDirection, scratchYDirection);\n  var z = defaultValue(zDirection, scratchZDirection);\n\n  x = Matrix3.getColumn(rotationMatrix, 0, x);\n  y = Matrix3.getColumn(rotationMatrix, 1, y);\n  z = Matrix3.getColumn(rotationMatrix, 2, z);\n\n  Cartesian3.normalize(x, x);\n  Cartesian3.normalize(y, y);\n  Cartesian3.normalize(z, z);\n\n  Cartesian3.negate(x, x);\n\n  var view = Matrix4.computeView(origin, z, y, x, scratchViewMatrix);\n\n  var inverseView;\n  var inverseViewProjection;\n  if (frustumType === PERSPECTIVE) {\n    var projection = frustum.projectionMatrix;\n    var viewProjection = Matrix4.multiply(\n      projection,\n      view,\n      scratchInverseMatrix\n    );\n    inverseViewProjection = Matrix4.inverse(\n      viewProjection,\n      scratchInverseMatrix\n    );\n  } else {\n    inverseView = Matrix4.inverseTransformation(view, scratchInverseMatrix);\n  }\n\n  if (defined(inverseViewProjection)) {\n    frustumSplits[0] = frustum.near;\n    frustumSplits[1] = frustum.far;\n  } else {\n    frustumSplits[0] = 0.0;\n    frustumSplits[1] = frustum.near;\n    frustumSplits[2] = frustum.far;\n  }\n\n  for (var i = 0; i < 2; ++i) {\n    for (var j = 0; j < 4; ++j) {\n      var corner = Cartesian4.clone(\n        frustumCornersNDC[j],\n        scratchFrustumCorners[j]\n      );\n\n      if (!defined(inverseViewProjection)) {\n        if (defined(frustum._offCenterFrustum)) {\n          frustum = frustum._offCenterFrustum;\n        }\n\n        var near = frustumSplits[i];\n        var far = frustumSplits[i + 1];\n\n        corner.x =\n          (corner.x * (frustum.right - frustum.left) +\n            frustum.left +\n            frustum.right) *\n          0.5;\n        corner.y =\n          (corner.y * (frustum.top - frustum.bottom) +\n            frustum.bottom +\n            frustum.top) *\n          0.5;\n        corner.z = (corner.z * (near - far) - near - far) * 0.5;\n        corner.w = 1.0;\n\n        Matrix4.multiplyByVector(inverseView, corner, corner);\n      } else {\n        corner = Matrix4.multiplyByVector(\n          inverseViewProjection,\n          corner,\n          corner\n        );\n\n        // Reverse perspective divide\n        var w = 1.0 / corner.w;\n        Cartesian3.multiplyByScalar(corner, w, corner);\n\n        Cartesian3.subtract(corner, origin, corner);\n        Cartesian3.normalize(corner, corner);\n\n        var fac = Cartesian3.dot(z, corner);\n        Cartesian3.multiplyByScalar(corner, frustumSplits[i] / fac, corner);\n        Cartesian3.add(corner, origin, corner);\n      }\n\n      positions[12 * i + j * 3] = corner.x;\n      positions[12 * i + j * 3 + 1] = corner.y;\n      positions[12 * i + j * 3 + 2] = corner.z;\n    }\n  }\n};\n\n/**\n * Computes the geometric representation of a frustum, including its vertices, indices, and a bounding sphere.\n *\n * @param {FrustumGeometry} frustumGeometry A description of the frustum.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nFrustumGeometry.createGeometry = function (frustumGeometry) {\n  var frustumType = frustumGeometry._frustumType;\n  var frustum = frustumGeometry._frustum;\n  var origin = frustumGeometry._origin;\n  var orientation = frustumGeometry._orientation;\n  var drawNearPlane = frustumGeometry._drawNearPlane;\n  var vertexFormat = frustumGeometry._vertexFormat;\n\n  var numberOfPlanes = drawNearPlane ? 6 : 5;\n  var positions = new Float64Array(3 * 4 * 6);\n  FrustumGeometry._computeNearFarPlanes(\n    origin,\n    orientation,\n    frustumType,\n    frustum,\n    positions\n  );\n\n  // -x plane\n  var offset = 3 * 4 * 2;\n  positions[offset] = positions[3 * 4];\n  positions[offset + 1] = positions[3 * 4 + 1];\n  positions[offset + 2] = positions[3 * 4 + 2];\n  positions[offset + 3] = positions[0];\n  positions[offset + 4] = positions[1];\n  positions[offset + 5] = positions[2];\n  positions[offset + 6] = positions[3 * 3];\n  positions[offset + 7] = positions[3 * 3 + 1];\n  positions[offset + 8] = positions[3 * 3 + 2];\n  positions[offset + 9] = positions[3 * 7];\n  positions[offset + 10] = positions[3 * 7 + 1];\n  positions[offset + 11] = positions[3 * 7 + 2];\n\n  // -y plane\n  offset += 3 * 4;\n  positions[offset] = positions[3 * 5];\n  positions[offset + 1] = positions[3 * 5 + 1];\n  positions[offset + 2] = positions[3 * 5 + 2];\n  positions[offset + 3] = positions[3];\n  positions[offset + 4] = positions[3 + 1];\n  positions[offset + 5] = positions[3 + 2];\n  positions[offset + 6] = positions[0];\n  positions[offset + 7] = positions[1];\n  positions[offset + 8] = positions[2];\n  positions[offset + 9] = positions[3 * 4];\n  positions[offset + 10] = positions[3 * 4 + 1];\n  positions[offset + 11] = positions[3 * 4 + 2];\n\n  // +x plane\n  offset += 3 * 4;\n  positions[offset] = positions[3];\n  positions[offset + 1] = positions[3 + 1];\n  positions[offset + 2] = positions[3 + 2];\n  positions[offset + 3] = positions[3 * 5];\n  positions[offset + 4] = positions[3 * 5 + 1];\n  positions[offset + 5] = positions[3 * 5 + 2];\n  positions[offset + 6] = positions[3 * 6];\n  positions[offset + 7] = positions[3 * 6 + 1];\n  positions[offset + 8] = positions[3 * 6 + 2];\n  positions[offset + 9] = positions[3 * 2];\n  positions[offset + 10] = positions[3 * 2 + 1];\n  positions[offset + 11] = positions[3 * 2 + 2];\n\n  // +y plane\n  offset += 3 * 4;\n  positions[offset] = positions[3 * 2];\n  positions[offset + 1] = positions[3 * 2 + 1];\n  positions[offset + 2] = positions[3 * 2 + 2];\n  positions[offset + 3] = positions[3 * 6];\n  positions[offset + 4] = positions[3 * 6 + 1];\n  positions[offset + 5] = positions[3 * 6 + 2];\n  positions[offset + 6] = positions[3 * 7];\n  positions[offset + 7] = positions[3 * 7 + 1];\n  positions[offset + 8] = positions[3 * 7 + 2];\n  positions[offset + 9] = positions[3 * 3];\n  positions[offset + 10] = positions[3 * 3 + 1];\n  positions[offset + 11] = positions[3 * 3 + 2];\n\n  if (!drawNearPlane) {\n    positions = positions.subarray(3 * 4);\n  }\n\n  var attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    }),\n  });\n\n  if (\n    defined(vertexFormat.normal) ||\n    defined(vertexFormat.tangent) ||\n    defined(vertexFormat.bitangent) ||\n    defined(vertexFormat.st)\n  ) {\n    var normals = defined(vertexFormat.normal)\n      ? new Float32Array(3 * 4 * numberOfPlanes)\n      : undefined;\n    var tangents = defined(vertexFormat.tangent)\n      ? new Float32Array(3 * 4 * numberOfPlanes)\n      : undefined;\n    var bitangents = defined(vertexFormat.bitangent)\n      ? new Float32Array(3 * 4 * numberOfPlanes)\n      : undefined;\n    var st = defined(vertexFormat.st)\n      ? new Float32Array(2 * 4 * numberOfPlanes)\n      : undefined;\n\n    var x = scratchXDirection;\n    var y = scratchYDirection;\n    var z = scratchZDirection;\n\n    var negativeX = Cartesian3.negate(x, scratchNegativeX);\n    var negativeY = Cartesian3.negate(y, scratchNegativeY);\n    var negativeZ = Cartesian3.negate(z, scratchNegativeZ);\n\n    offset = 0;\n    if (drawNearPlane) {\n      getAttributes(offset, normals, tangents, bitangents, st, negativeZ, x, y); // near\n      offset += 3 * 4;\n    }\n    getAttributes(offset, normals, tangents, bitangents, st, z, negativeX, y); // far\n    offset += 3 * 4;\n    getAttributes(\n      offset,\n      normals,\n      tangents,\n      bitangents,\n      st,\n      negativeX,\n      negativeZ,\n      y\n    ); // -x\n    offset += 3 * 4;\n    getAttributes(\n      offset,\n      normals,\n      tangents,\n      bitangents,\n      st,\n      negativeY,\n      negativeZ,\n      negativeX\n    ); // -y\n    offset += 3 * 4;\n    getAttributes(offset, normals, tangents, bitangents, st, x, z, y); // +x\n    offset += 3 * 4;\n    getAttributes(offset, normals, tangents, bitangents, st, y, z, negativeX); // +y\n\n    if (defined(normals)) {\n      attributes.normal = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: normals,\n      });\n    }\n    if (defined(tangents)) {\n      attributes.tangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: tangents,\n      });\n    }\n    if (defined(bitangents)) {\n      attributes.bitangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: bitangents,\n      });\n    }\n    if (defined(st)) {\n      attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: st,\n      });\n    }\n  }\n\n  var indices = new Uint16Array(6 * numberOfPlanes);\n  for (var i = 0; i < numberOfPlanes; ++i) {\n    var indexOffset = i * 6;\n    var index = i * 4;\n\n    indices[indexOffset] = index;\n    indices[indexOffset + 1] = index + 1;\n    indices[indexOffset + 2] = index + 2;\n    indices[indexOffset + 3] = index;\n    indices[indexOffset + 4] = index + 2;\n    indices[indexOffset + 5] = index + 3;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: BoundingSphere.fromVertices(positions),\n  });\n};\nexport default FrustumGeometry;\n"]},"metadata":{},"sourceType":"module"}