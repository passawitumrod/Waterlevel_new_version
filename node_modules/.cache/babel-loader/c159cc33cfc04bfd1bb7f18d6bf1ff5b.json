{"ast":null,"code":"import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport EllipseGeometryLibrary from \"./EllipseGeometryLibrary.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nvar scratchCartesian1 = new Cartesian3();\nvar boundingSphereCenter = new Cartesian3();\n\nfunction computeEllipse(options) {\n  var center = options.center;\n  boundingSphereCenter = Cartesian3.multiplyByScalar(options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter), options.height, boundingSphereCenter);\n  boundingSphereCenter = Cartesian3.add(center, boundingSphereCenter, boundingSphereCenter);\n  var boundingSphere = new BoundingSphere(boundingSphereCenter, options.semiMajorAxis);\n  var positions = EllipseGeometryLibrary.computeEllipsePositions(options, false, true).outerPositions;\n  var attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: EllipseGeometryLibrary.raisePositionsToHeight(positions, options, false)\n    })\n  });\n  var length = positions.length / 3;\n  var indices = IndexDatatype.createTypedArray(length, length * 2);\n  var index = 0;\n\n  for (var i = 0; i < length; ++i) {\n    indices[index++] = i;\n    indices[index++] = (i + 1) % length;\n  }\n\n  return {\n    boundingSphere: boundingSphere,\n    attributes: attributes,\n    indices: indices\n  };\n}\n\nvar topBoundingSphere = new BoundingSphere();\nvar bottomBoundingSphere = new BoundingSphere();\n\nfunction computeExtrudedEllipse(options) {\n  var center = options.center;\n  var ellipsoid = options.ellipsoid;\n  var semiMajorAxis = options.semiMajorAxis;\n  var scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1), options.height, scratchCartesian1);\n  topBoundingSphere.center = Cartesian3.add(center, scaledNormal, topBoundingSphere.center);\n  topBoundingSphere.radius = semiMajorAxis;\n  scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scaledNormal), options.extrudedHeight, scaledNormal);\n  bottomBoundingSphere.center = Cartesian3.add(center, scaledNormal, bottomBoundingSphere.center);\n  bottomBoundingSphere.radius = semiMajorAxis;\n  var positions = EllipseGeometryLibrary.computeEllipsePositions(options, false, true).outerPositions;\n  var attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: EllipseGeometryLibrary.raisePositionsToHeight(positions, options, true)\n    })\n  });\n  positions = attributes.position.values;\n  var boundingSphere = BoundingSphere.union(topBoundingSphere, bottomBoundingSphere);\n  var length = positions.length / 3;\n\n  if (defined(options.offsetAttribute)) {\n    var applyOffset = new Uint8Array(length);\n\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      applyOffset = arrayFill(applyOffset, 1, 0, length / 2);\n    } else {\n      var offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      applyOffset = arrayFill(applyOffset, offsetValue);\n    }\n\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset\n    });\n  }\n\n  var numberOfVerticalLines = defaultValue(options.numberOfVerticalLines, 16);\n  numberOfVerticalLines = CesiumMath.clamp(numberOfVerticalLines, 0, length / 2);\n  var indices = IndexDatatype.createTypedArray(length, length * 2 + numberOfVerticalLines * 2);\n  length /= 2;\n  var index = 0;\n  var i;\n\n  for (i = 0; i < length; ++i) {\n    indices[index++] = i;\n    indices[index++] = (i + 1) % length;\n    indices[index++] = i + length;\n    indices[index++] = (i + 1) % length + length;\n  }\n\n  var numSide;\n\n  if (numberOfVerticalLines > 0) {\n    var numSideLines = Math.min(numberOfVerticalLines, length);\n    numSide = Math.round(length / numSideLines);\n    var maxI = Math.min(numSide * numberOfVerticalLines, length);\n\n    for (i = 0; i < maxI; i += numSide) {\n      indices[index++] = i;\n      indices[index++] = i + length;\n    }\n  }\n\n  return {\n    boundingSphere: boundingSphere,\n    attributes: attributes,\n    indices: indices\n  };\n}\n/**\n * A description of the outline of an ellipse on an ellipsoid.\n *\n * @alias EllipseOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.\n * @param {Number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.\n * @param {Number} [options.extrudedHeight] The distance in meters between the ellipse's extruded face and the ellipsoid surface.\n * @param {Number} [options.rotation=0.0] The angle from north (counter-clockwise) in radians.\n * @param {Number} [options.granularity=0.02] The angular distance between points on the ellipse in radians.\n * @param {Number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surface of an extruded ellipse.\n *\n * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.\n * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.\n * @exception {DeveloperError} granularity must be greater than zero.\n *\n * @see EllipseOutlineGeometry.createGeometry\n *\n * @example\n * var ellipse = new Cesium.EllipseOutlineGeometry({\n *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n *   semiMajorAxis : 500000.0,\n *   semiMinorAxis : 300000.0,\n *   rotation : Cesium.Math.toRadians(60.0)\n * });\n * var geometry = Cesium.EllipseOutlineGeometry.createGeometry(ellipse);\n */\n\n\nfunction EllipseOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var center = options.center;\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var semiMajorAxis = options.semiMajorAxis;\n  var semiMinorAxis = options.semiMinorAxis;\n  var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE); //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(center)) {\n    throw new DeveloperError(\"center is required.\");\n  }\n\n  if (!defined(semiMajorAxis)) {\n    throw new DeveloperError(\"semiMajorAxis is required.\");\n  }\n\n  if (!defined(semiMinorAxis)) {\n    throw new DeveloperError(\"semiMinorAxis is required.\");\n  }\n\n  if (semiMajorAxis < semiMinorAxis) {\n    throw new DeveloperError(\"semiMajorAxis must be greater than or equal to the semiMinorAxis.\");\n  }\n\n  if (granularity <= 0.0) {\n    throw new DeveloperError(\"granularity must be greater than zero.\");\n  } //>>includeEnd('debug');\n\n\n  var height = defaultValue(options.height, 0.0);\n  var extrudedHeight = defaultValue(options.extrudedHeight, height);\n  this._center = Cartesian3.clone(center);\n  this._semiMajorAxis = semiMajorAxis;\n  this._semiMinorAxis = semiMinorAxis;\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._rotation = defaultValue(options.rotation, 0.0);\n  this._height = Math.max(extrudedHeight, height);\n  this._granularity = granularity;\n  this._extrudedHeight = Math.min(extrudedHeight, height);\n  this._numberOfVerticalLines = Math.max(defaultValue(options.numberOfVerticalLines, 16), 0);\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createEllipseOutlineGeometry\";\n}\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\n\n\nEllipseOutlineGeometry.packedLength = Cartesian3.packedLength + Ellipsoid.packedLength + 8;\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipseOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\nEllipseOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  } //>>includeEnd('debug');\n\n\n  startingIndex = defaultValue(startingIndex, 0);\n  Cartesian3.pack(value._center, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n  array[startingIndex++] = value._semiMajorAxis;\n  array[startingIndex++] = value._semiMinorAxis;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._numberOfVerticalLines;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n  return array;\n};\n\nvar scratchCenter = new Cartesian3();\nvar scratchEllipsoid = new Ellipsoid();\nvar scratchOptions = {\n  center: scratchCenter,\n  ellipsoid: scratchEllipsoid,\n  semiMajorAxis: undefined,\n  semiMinorAxis: undefined,\n  rotation: undefined,\n  height: undefined,\n  granularity: undefined,\n  extrudedHeight: undefined,\n  numberOfVerticalLines: undefined,\n  offsetAttribute: undefined\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipseOutlineGeometry} [result] The object into which to store the result.\n * @returns {EllipseOutlineGeometry} The modified result parameter or a new EllipseOutlineGeometry instance if one was not provided.\n */\n\nEllipseOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  } //>>includeEnd('debug');\n\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var center = Cartesian3.unpack(array, startingIndex, scratchCenter);\n  startingIndex += Cartesian3.packedLength;\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n  var semiMajorAxis = array[startingIndex++];\n  var semiMinorAxis = array[startingIndex++];\n  var rotation = array[startingIndex++];\n  var height = array[startingIndex++];\n  var granularity = array[startingIndex++];\n  var extrudedHeight = array[startingIndex++];\n  var numberOfVerticalLines = array[startingIndex++];\n  var offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.granularity = granularity;\n    scratchOptions.rotation = rotation;\n    scratchOptions.semiMajorAxis = semiMajorAxis;\n    scratchOptions.semiMinorAxis = semiMinorAxis;\n    scratchOptions.numberOfVerticalLines = numberOfVerticalLines;\n    scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new EllipseOutlineGeometry(scratchOptions);\n  }\n\n  result._center = Cartesian3.clone(center, result._center);\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._semiMajorAxis = semiMajorAxis;\n  result._semiMinorAxis = semiMinorAxis;\n  result._rotation = rotation;\n  result._height = height;\n  result._granularity = granularity;\n  result._extrudedHeight = extrudedHeight;\n  result._numberOfVerticalLines = numberOfVerticalLines;\n  result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n  return result;\n};\n/**\n * Computes the geometric representation of an outline of an ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipseOutlineGeometry} ellipseGeometry A description of the ellipse.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\n\n\nEllipseOutlineGeometry.createGeometry = function (ellipseGeometry) {\n  if (ellipseGeometry._semiMajorAxis <= 0.0 || ellipseGeometry._semiMinorAxis <= 0.0) {\n    return;\n  }\n\n  var height = ellipseGeometry._height;\n  var extrudedHeight = ellipseGeometry._extrudedHeight;\n  var extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n  ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(ellipseGeometry._center, ellipseGeometry._center);\n  var options = {\n    center: ellipseGeometry._center,\n    semiMajorAxis: ellipseGeometry._semiMajorAxis,\n    semiMinorAxis: ellipseGeometry._semiMinorAxis,\n    ellipsoid: ellipseGeometry._ellipsoid,\n    rotation: ellipseGeometry._rotation,\n    height: height,\n    granularity: ellipseGeometry._granularity,\n    numberOfVerticalLines: ellipseGeometry._numberOfVerticalLines\n  };\n  var geometry;\n\n  if (extrude) {\n    options.extrudedHeight = extrudedHeight;\n    options.offsetAttribute = ellipseGeometry._offsetAttribute;\n    geometry = computeExtrudedEllipse(options);\n  } else {\n    geometry = computeEllipse(options);\n\n    if (defined(ellipseGeometry._offsetAttribute)) {\n      var length = geometry.attributes.position.values.length;\n      var applyOffset = new Uint8Array(length / 3);\n      var offsetValue = ellipseGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      arrayFill(applyOffset, offsetValue);\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset\n      });\n    }\n  }\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: geometry.boundingSphere,\n    offsetAttribute: ellipseGeometry._offsetAttribute\n  });\n};\n\nexport default EllipseOutlineGeometry;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/EllipseOutlineGeometry.js"],"names":["arrayFill","BoundingSphere","Cartesian3","ComponentDatatype","defaultValue","defined","DeveloperError","EllipseGeometryLibrary","Ellipsoid","Geometry","GeometryAttribute","GeometryAttributes","GeometryOffsetAttribute","IndexDatatype","CesiumMath","PrimitiveType","scratchCartesian1","boundingSphereCenter","computeEllipse","options","center","multiplyByScalar","ellipsoid","geodeticSurfaceNormal","height","add","boundingSphere","semiMajorAxis","positions","computeEllipsePositions","outerPositions","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","raisePositionsToHeight","length","indices","createTypedArray","index","i","topBoundingSphere","bottomBoundingSphere","computeExtrudedEllipse","scaledNormal","radius","extrudedHeight","union","offsetAttribute","applyOffset","Uint8Array","TOP","offsetValue","NONE","UNSIGNED_BYTE","numberOfVerticalLines","clamp","numSide","numSideLines","Math","min","round","maxI","EllipseOutlineGeometry","EMPTY_OBJECT","WGS84","semiMinorAxis","granularity","RADIANS_PER_DEGREE","_center","clone","_semiMajorAxis","_semiMinorAxis","_ellipsoid","_rotation","rotation","_height","max","_granularity","_extrudedHeight","_numberOfVerticalLines","_offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","scratchCenter","scratchEllipsoid","scratchOptions","undefined","unpack","result","createGeometry","ellipseGeometry","extrude","equalsEpsilon","EPSILON2","scaleToGeodeticSurface","geometry","primitiveType","LINES"],"mappings":"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","sourcesContent":["import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport EllipseGeometryLibrary from \"./EllipseGeometryLibrary.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nvar scratchCartesian1 = new Cartesian3();\nvar boundingSphereCenter = new Cartesian3();\n\nfunction computeEllipse(options) {\n  var center = options.center;\n  boundingSphereCenter = Cartesian3.multiplyByScalar(\n    options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter),\n    options.height,\n    boundingSphereCenter\n  );\n  boundingSphereCenter = Cartesian3.add(\n    center,\n    boundingSphereCenter,\n    boundingSphereCenter\n  );\n  var boundingSphere = new BoundingSphere(\n    boundingSphereCenter,\n    options.semiMajorAxis\n  );\n  var positions = EllipseGeometryLibrary.computeEllipsePositions(\n    options,\n    false,\n    true\n  ).outerPositions;\n\n  var attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: EllipseGeometryLibrary.raisePositionsToHeight(\n        positions,\n        options,\n        false\n      ),\n    }),\n  });\n\n  var length = positions.length / 3;\n  var indices = IndexDatatype.createTypedArray(length, length * 2);\n  var index = 0;\n  for (var i = 0; i < length; ++i) {\n    indices[index++] = i;\n    indices[index++] = (i + 1) % length;\n  }\n\n  return {\n    boundingSphere: boundingSphere,\n    attributes: attributes,\n    indices: indices,\n  };\n}\n\nvar topBoundingSphere = new BoundingSphere();\nvar bottomBoundingSphere = new BoundingSphere();\nfunction computeExtrudedEllipse(options) {\n  var center = options.center;\n  var ellipsoid = options.ellipsoid;\n  var semiMajorAxis = options.semiMajorAxis;\n  var scaledNormal = Cartesian3.multiplyByScalar(\n    ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1),\n    options.height,\n    scratchCartesian1\n  );\n  topBoundingSphere.center = Cartesian3.add(\n    center,\n    scaledNormal,\n    topBoundingSphere.center\n  );\n  topBoundingSphere.radius = semiMajorAxis;\n\n  scaledNormal = Cartesian3.multiplyByScalar(\n    ellipsoid.geodeticSurfaceNormal(center, scaledNormal),\n    options.extrudedHeight,\n    scaledNormal\n  );\n  bottomBoundingSphere.center = Cartesian3.add(\n    center,\n    scaledNormal,\n    bottomBoundingSphere.center\n  );\n  bottomBoundingSphere.radius = semiMajorAxis;\n\n  var positions = EllipseGeometryLibrary.computeEllipsePositions(\n    options,\n    false,\n    true\n  ).outerPositions;\n  var attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: EllipseGeometryLibrary.raisePositionsToHeight(\n        positions,\n        options,\n        true\n      ),\n    }),\n  });\n\n  positions = attributes.position.values;\n  var boundingSphere = BoundingSphere.union(\n    topBoundingSphere,\n    bottomBoundingSphere\n  );\n  var length = positions.length / 3;\n\n  if (defined(options.offsetAttribute)) {\n    var applyOffset = new Uint8Array(length);\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      applyOffset = arrayFill(applyOffset, 1, 0, length / 2);\n    } else {\n      var offsetValue =\n        options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      applyOffset = arrayFill(applyOffset, offsetValue);\n    }\n\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  var numberOfVerticalLines = defaultValue(options.numberOfVerticalLines, 16);\n  numberOfVerticalLines = CesiumMath.clamp(\n    numberOfVerticalLines,\n    0,\n    length / 2\n  );\n\n  var indices = IndexDatatype.createTypedArray(\n    length,\n    length * 2 + numberOfVerticalLines * 2\n  );\n\n  length /= 2;\n  var index = 0;\n  var i;\n  for (i = 0; i < length; ++i) {\n    indices[index++] = i;\n    indices[index++] = (i + 1) % length;\n    indices[index++] = i + length;\n    indices[index++] = ((i + 1) % length) + length;\n  }\n\n  var numSide;\n  if (numberOfVerticalLines > 0) {\n    var numSideLines = Math.min(numberOfVerticalLines, length);\n    numSide = Math.round(length / numSideLines);\n\n    var maxI = Math.min(numSide * numberOfVerticalLines, length);\n    for (i = 0; i < maxI; i += numSide) {\n      indices[index++] = i;\n      indices[index++] = i + length;\n    }\n  }\n\n  return {\n    boundingSphere: boundingSphere,\n    attributes: attributes,\n    indices: indices,\n  };\n}\n\n/**\n * A description of the outline of an ellipse on an ellipsoid.\n *\n * @alias EllipseOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.\n * @param {Number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.\n * @param {Number} [options.extrudedHeight] The distance in meters between the ellipse's extruded face and the ellipsoid surface.\n * @param {Number} [options.rotation=0.0] The angle from north (counter-clockwise) in radians.\n * @param {Number} [options.granularity=0.02] The angular distance between points on the ellipse in radians.\n * @param {Number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surface of an extruded ellipse.\n *\n * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.\n * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.\n * @exception {DeveloperError} granularity must be greater than zero.\n *\n * @see EllipseOutlineGeometry.createGeometry\n *\n * @example\n * var ellipse = new Cesium.EllipseOutlineGeometry({\n *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n *   semiMajorAxis : 500000.0,\n *   semiMinorAxis : 300000.0,\n *   rotation : Cesium.Math.toRadians(60.0)\n * });\n * var geometry = Cesium.EllipseOutlineGeometry.createGeometry(ellipse);\n */\nfunction EllipseOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var center = options.center;\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var semiMajorAxis = options.semiMajorAxis;\n  var semiMinorAxis = options.semiMinorAxis;\n  var granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(center)) {\n    throw new DeveloperError(\"center is required.\");\n  }\n  if (!defined(semiMajorAxis)) {\n    throw new DeveloperError(\"semiMajorAxis is required.\");\n  }\n  if (!defined(semiMinorAxis)) {\n    throw new DeveloperError(\"semiMinorAxis is required.\");\n  }\n  if (semiMajorAxis < semiMinorAxis) {\n    throw new DeveloperError(\n      \"semiMajorAxis must be greater than or equal to the semiMinorAxis.\"\n    );\n  }\n  if (granularity <= 0.0) {\n    throw new DeveloperError(\"granularity must be greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  var height = defaultValue(options.height, 0.0);\n  var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  this._center = Cartesian3.clone(center);\n  this._semiMajorAxis = semiMajorAxis;\n  this._semiMinorAxis = semiMinorAxis;\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._rotation = defaultValue(options.rotation, 0.0);\n  this._height = Math.max(extrudedHeight, height);\n  this._granularity = granularity;\n  this._extrudedHeight = Math.min(extrudedHeight, height);\n  this._numberOfVerticalLines = Math.max(\n    defaultValue(options.numberOfVerticalLines, 16),\n    0\n  );\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createEllipseOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nEllipseOutlineGeometry.packedLength =\n  Cartesian3.packedLength + Ellipsoid.packedLength + 8;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipseOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nEllipseOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value._center, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  array[startingIndex++] = value._semiMajorAxis;\n  array[startingIndex++] = value._semiMinorAxis;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._numberOfVerticalLines;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nvar scratchCenter = new Cartesian3();\nvar scratchEllipsoid = new Ellipsoid();\nvar scratchOptions = {\n  center: scratchCenter,\n  ellipsoid: scratchEllipsoid,\n  semiMajorAxis: undefined,\n  semiMinorAxis: undefined,\n  rotation: undefined,\n  height: undefined,\n  granularity: undefined,\n  extrudedHeight: undefined,\n  numberOfVerticalLines: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipseOutlineGeometry} [result] The object into which to store the result.\n * @returns {EllipseOutlineGeometry} The modified result parameter or a new EllipseOutlineGeometry instance if one was not provided.\n */\nEllipseOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var center = Cartesian3.unpack(array, startingIndex, scratchCenter);\n  startingIndex += Cartesian3.packedLength;\n\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  var semiMajorAxis = array[startingIndex++];\n  var semiMinorAxis = array[startingIndex++];\n  var rotation = array[startingIndex++];\n  var height = array[startingIndex++];\n  var granularity = array[startingIndex++];\n  var extrudedHeight = array[startingIndex++];\n  var numberOfVerticalLines = array[startingIndex++];\n  var offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.granularity = granularity;\n    scratchOptions.rotation = rotation;\n    scratchOptions.semiMajorAxis = semiMajorAxis;\n    scratchOptions.semiMinorAxis = semiMinorAxis;\n    scratchOptions.numberOfVerticalLines = numberOfVerticalLines;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n\n    return new EllipseOutlineGeometry(scratchOptions);\n  }\n\n  result._center = Cartesian3.clone(center, result._center);\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._semiMajorAxis = semiMajorAxis;\n  result._semiMinorAxis = semiMinorAxis;\n  result._rotation = rotation;\n  result._height = height;\n  result._granularity = granularity;\n  result._extrudedHeight = extrudedHeight;\n  result._numberOfVerticalLines = numberOfVerticalLines;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of an ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipseOutlineGeometry} ellipseGeometry A description of the ellipse.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nEllipseOutlineGeometry.createGeometry = function (ellipseGeometry) {\n  if (\n    ellipseGeometry._semiMajorAxis <= 0.0 ||\n    ellipseGeometry._semiMinorAxis <= 0.0\n  ) {\n    return;\n  }\n\n  var height = ellipseGeometry._height;\n  var extrudedHeight = ellipseGeometry._extrudedHeight;\n  var extrude = !CesiumMath.equalsEpsilon(\n    height,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2\n  );\n\n  ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(\n    ellipseGeometry._center,\n    ellipseGeometry._center\n  );\n  var options = {\n    center: ellipseGeometry._center,\n    semiMajorAxis: ellipseGeometry._semiMajorAxis,\n    semiMinorAxis: ellipseGeometry._semiMinorAxis,\n    ellipsoid: ellipseGeometry._ellipsoid,\n    rotation: ellipseGeometry._rotation,\n    height: height,\n    granularity: ellipseGeometry._granularity,\n    numberOfVerticalLines: ellipseGeometry._numberOfVerticalLines,\n  };\n  var geometry;\n  if (extrude) {\n    options.extrudedHeight = extrudedHeight;\n    options.offsetAttribute = ellipseGeometry._offsetAttribute;\n    geometry = computeExtrudedEllipse(options);\n  } else {\n    geometry = computeEllipse(options);\n\n    if (defined(ellipseGeometry._offsetAttribute)) {\n      var length = geometry.attributes.position.values.length;\n      var applyOffset = new Uint8Array(length / 3);\n      var offsetValue =\n        ellipseGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      arrayFill(applyOffset, offsetValue);\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n  }\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: geometry.boundingSphere,\n    offsetAttribute: ellipseGeometry._offsetAttribute,\n  });\n};\nexport default EllipseOutlineGeometry;\n"]},"metadata":{},"sourceType":"module"}