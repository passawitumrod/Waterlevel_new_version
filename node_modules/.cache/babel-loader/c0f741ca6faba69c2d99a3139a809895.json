{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport loadKTX from \"../Core/loadKTX.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ComputeCommand from \"../Renderer/ComputeCommand.js\";\nimport CubeMap from \"../Renderer/CubeMap.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport OctahedralProjectionAtlasFS from \"../Shaders/OctahedralProjectionAtlasFS.js\";\nimport OctahedralProjectionFS from \"../Shaders/OctahedralProjectionFS.js\";\nimport OctahedralProjectionVS from \"../Shaders/OctahedralProjectionVS.js\";\nimport when from \"../ThirdParty/when.js\";\n/**\n * Packs all mip levels of a cube map into a 2D texture atlas.\n *\n * Octahedral projection is a way of putting the cube maps onto a 2D texture\n * with minimal distortion and easy look up.\n * See Chapter 16 of WebGL Insights \"HDR Image-Based Lighting on the Web\" by Jeff Russell\n * and \"Octahedron Environment Maps\" for reference.\n *\n * @private\n */\n\nfunction OctahedralProjectedCubeMap(url) {\n  this._url = url;\n  this._cubeMapBuffers = undefined;\n  this._cubeMaps = undefined;\n  this._texture = undefined;\n  this._mipTextures = undefined;\n  this._va = undefined;\n  this._sp = undefined;\n  this._maximumMipmapLevel = undefined;\n  this._loading = false;\n  this._ready = false;\n  this._readyPromise = when.defer();\n}\n\nObject.defineProperties(OctahedralProjectedCubeMap.prototype, {\n  /**\n   * The url to the KTX file containing the specular environment map and convoluted mipmaps.\n   * @memberof OctahedralProjectedCubeMap.prototype\n   * @type {String}\n   * @readonly\n   */\n  url: {\n    get: function () {\n      return this._url;\n    }\n  },\n\n  /**\n   * A texture containing all the packed convolutions.\n   * @memberof OctahedralProjectedCubeMap.prototype\n   * @type {Texture}\n   * @readonly\n   */\n  texture: {\n    get: function () {\n      return this._texture;\n    }\n  },\n\n  /**\n   * The maximum number of mip levels.\n   * @memberOf OctahedralProjectedCubeMap.prototype\n   * @type {Number}\n   * @readonly\n   */\n  maximumMipmapLevel: {\n    get: function () {\n      return this._maximumMipmapLevel;\n    }\n  },\n\n  /**\n   * Determines if the texture atlas is complete and ready to use.\n   * @memberof OctahedralProjectedCubeMap.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n\n  /**\n   * Gets a promise that resolves when the texture atlas is ready to use.\n   * @memberof OctahedralProjectedCubeMap.prototype\n   * @type {Promise}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    }\n  }\n});\n\nOctahedralProjectedCubeMap.isSupported = function (context) {\n  return context.colorBufferHalfFloat && context.halfFloatingPointTexture || context.floatingPointTexture && context.colorBufferFloat;\n}; // These vertices are based on figure 1 from \"Octahedron Environment Maps\".\n\n\nvar v1 = new Cartesian3(1.0, 0.0, 0.0);\nvar v2 = new Cartesian3(0.0, 0.0, 1.0);\nvar v3 = new Cartesian3(-1.0, 0.0, 0.0);\nvar v4 = new Cartesian3(0.0, 0.0, -1.0);\nvar v5 = new Cartesian3(0.0, 1.0, 0.0);\nvar v6 = new Cartesian3(0.0, -1.0, 0.0); // top left, left, top, center, right, top right, bottom, bottom left, bottom right\n\nvar cubeMapCoordinates = [v5, v3, v2, v6, v1, v5, v4, v5, v5];\nvar length = cubeMapCoordinates.length;\nvar flatCubeMapCoordinates = new Float32Array(length * 3);\nvar offset = 0;\n\nfor (var i = 0; i < length; ++i, offset += 3) {\n  Cartesian3.pack(cubeMapCoordinates[i], flatCubeMapCoordinates, offset);\n}\n\nvar flatPositions = new Float32Array([-1.0, 1.0, // top left\n-1.0, 0.0, // left\n0.0, 1.0, // top\n0.0, 0.0, // center\n1.0, 0.0, // right\n1.0, 1.0, // top right\n0.0, -1.0, // bottom\n-1.0, -1.0, // bottom left\n1.0, -1.0 // bottom right\n]);\nvar indices = new Uint16Array([0, 1, 2, // top left, left, top,\n2, 3, 1, // top, center, left,\n7, 6, 1, // bottom left, bottom, left,\n3, 6, 1, // center, bottom, left,\n2, 5, 4, // top, top right, right,\n3, 4, 2, // center, right, top,\n4, 8, 6, // right, bottom right, bottom,\n3, 4, 6 //center, right, bottom\n]);\n\nfunction createVertexArray(context) {\n  var positionBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: flatPositions,\n    usage: BufferUsage.STATIC_DRAW\n  });\n  var cubeMapCoordinatesBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: flatCubeMapCoordinates,\n    usage: BufferUsage.STATIC_DRAW\n  });\n  var indexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: indices,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: IndexDatatype.UNSIGNED_SHORT\n  });\n  var attributes = [{\n    index: 0,\n    vertexBuffer: positionBuffer,\n    componentsPerAttribute: 2,\n    componentDatatype: ComponentDatatype.FLOAT\n  }, {\n    index: 1,\n    vertexBuffer: cubeMapCoordinatesBuffer,\n    componentsPerAttribute: 3,\n    componentDatatype: ComponentDatatype.FLOAT\n  }];\n  return new VertexArray({\n    context: context,\n    attributes: attributes,\n    indexBuffer: indexBuffer\n  });\n}\n\nfunction createUniformTexture(texture) {\n  return function () {\n    return texture;\n  };\n}\n\nfunction cleanupResources(map) {\n  map._va = map._va && map._va.destroy();\n  map._sp = map._sp && map._sp.destroy();\n  var i;\n  var length;\n  var cubeMaps = map._cubeMaps;\n\n  if (defined(cubeMaps)) {\n    length = cubeMaps.length;\n\n    for (i = 0; i < length; ++i) {\n      cubeMaps[i].destroy();\n    }\n  }\n\n  var mipTextures = map._mipTextures;\n\n  if (defined(mipTextures)) {\n    length = mipTextures.length;\n\n    for (i = 0; i < length; ++i) {\n      mipTextures[i].destroy();\n    }\n  }\n\n  map._va = undefined;\n  map._sp = undefined;\n  map._cubeMaps = undefined;\n  map._cubeMapBuffers = undefined;\n  map._mipTextures = undefined;\n}\n/**\n * Creates compute commands to generate octahedral projections of each cube map\n * and then renders them to an atlas.\n * <p>\n * Only needs to be called twice. The first call queues the compute commands to generate the atlas.\n * The second call cleans up unused resources. Every call afterwards is a no-op.\n * </p>\n *\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\n\n\nOctahedralProjectedCubeMap.prototype.update = function (frameState) {\n  var context = frameState.context;\n\n  if (!OctahedralProjectedCubeMap.isSupported(context)) {\n    return;\n  }\n\n  if (defined(this._texture) && defined(this._va)) {\n    cleanupResources(this);\n  }\n\n  if (defined(this._texture)) {\n    return;\n  }\n\n  if (!defined(this._texture) && !this._loading) {\n    var cachedTexture = context.textureCache.getTexture(this._url);\n\n    if (defined(cachedTexture)) {\n      cleanupResources(this);\n      this._texture = cachedTexture;\n      this._maximumMipmapLevel = this._texture.maximumMipmapLevel;\n      this._ready = true;\n\n      this._readyPromise.resolve();\n\n      return;\n    }\n  }\n\n  var cubeMapBuffers = this._cubeMapBuffers;\n\n  if (!defined(cubeMapBuffers) && !this._loading) {\n    var that = this;\n    loadKTX(this._url).then(function (buffers) {\n      that._cubeMapBuffers = buffers;\n      that._loading = false;\n    }).otherwise(this._readyPromise.reject);\n    this._loading = true;\n  }\n\n  if (!defined(this._cubeMapBuffers)) {\n    return;\n  }\n\n  this._va = createVertexArray(context);\n  this._sp = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: OctahedralProjectionVS,\n    fragmentShaderSource: OctahedralProjectionFS,\n    attributeLocations: {\n      position: 0,\n      cubeMapCoordinates: 1\n    }\n  }); // We only need up to 6 mip levels to avoid artifacts.\n\n  var length = Math.min(cubeMapBuffers.length, 6);\n  this._maximumMipmapLevel = length - 1;\n  var cubeMaps = this._cubeMaps = new Array(length);\n  var mipTextures = this._mipTextures = new Array(length);\n  var originalSize = cubeMapBuffers[0].positiveX.width * 2.0;\n  var uniformMap = {\n    originalSize: function () {\n      return originalSize;\n    }\n  };\n  var pixelDatatype = context.halfFloatingPointTexture ? PixelDatatype.HALF_FLOAT : PixelDatatype.FLOAT;\n  var pixelFormat = PixelFormat.RGBA; // First we project each cubemap onto a flat octahedron, and write that to a texture.\n\n  for (var i = 0; i < length; ++i) {\n    // Swap +Y/-Y faces since the octahedral projection expects this order.\n    var positiveY = cubeMapBuffers[i].positiveY;\n    cubeMapBuffers[i].positiveY = cubeMapBuffers[i].negativeY;\n    cubeMapBuffers[i].negativeY = positiveY;\n    var cubeMap = cubeMaps[i] = new CubeMap({\n      context: context,\n      source: cubeMapBuffers[i]\n    });\n    var size = cubeMaps[i].width * 2;\n    var mipTexture = mipTextures[i] = new Texture({\n      context: context,\n      width: size,\n      height: size,\n      pixelDatatype: pixelDatatype,\n      pixelFormat: pixelFormat\n    });\n    var command = new ComputeCommand({\n      vertexArray: this._va,\n      shaderProgram: this._sp,\n      uniformMap: {\n        cubeMap: createUniformTexture(cubeMap)\n      },\n      outputTexture: mipTexture,\n      persists: true,\n      owner: this\n    });\n    frameState.commandList.push(command);\n    uniformMap[\"texture\" + i] = createUniformTexture(mipTexture);\n  }\n\n  this._texture = new Texture({\n    context: context,\n    width: originalSize * 1.5 + 2.0,\n    // We add a 1 pixel border to avoid linear sampling artifacts.\n    height: originalSize,\n    pixelDatatype: pixelDatatype,\n    pixelFormat: pixelFormat\n  });\n  this._texture.maximumMipmapLevel = this._maximumMipmapLevel;\n  context.textureCache.addTexture(this._url, this._texture);\n  var atlasCommand = new ComputeCommand({\n    fragmentShaderSource: OctahedralProjectionAtlasFS,\n    uniformMap: uniformMap,\n    outputTexture: this._texture,\n    persists: false,\n    owner: this\n  });\n  frameState.commandList.push(atlasCommand);\n  this._ready = true;\n\n  this._readyPromise.resolve();\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see OctahedralProjectedCubeMap#destroy\n */\n\n\nOctahedralProjectedCubeMap.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see OctahedralProjectedCubeMap#isDestroyed\n */\n\n\nOctahedralProjectedCubeMap.prototype.destroy = function () {\n  cleanupResources(this);\n  this._texture = this._texture && this._texture.destroy();\n  return destroyObject(this);\n};\n\nexport default OctahedralProjectedCubeMap;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/OctahedralProjectedCubeMap.js"],"names":["Cartesian3","ComponentDatatype","defined","destroyObject","IndexDatatype","loadKTX","PixelFormat","Buffer","BufferUsage","ComputeCommand","CubeMap","PixelDatatype","ShaderProgram","Texture","VertexArray","OctahedralProjectionAtlasFS","OctahedralProjectionFS","OctahedralProjectionVS","when","OctahedralProjectedCubeMap","url","_url","_cubeMapBuffers","undefined","_cubeMaps","_texture","_mipTextures","_va","_sp","_maximumMipmapLevel","_loading","_ready","_readyPromise","defer","Object","defineProperties","prototype","get","texture","maximumMipmapLevel","ready","readyPromise","promise","isSupported","context","colorBufferHalfFloat","halfFloatingPointTexture","floatingPointTexture","colorBufferFloat","v1","v2","v3","v4","v5","v6","cubeMapCoordinates","length","flatCubeMapCoordinates","Float32Array","offset","i","pack","flatPositions","indices","Uint16Array","createVertexArray","positionBuffer","createVertexBuffer","typedArray","usage","STATIC_DRAW","cubeMapCoordinatesBuffer","indexBuffer","createIndexBuffer","indexDatatype","UNSIGNED_SHORT","attributes","index","vertexBuffer","componentsPerAttribute","componentDatatype","FLOAT","createUniformTexture","cleanupResources","map","destroy","cubeMaps","mipTextures","update","frameState","cachedTexture","textureCache","getTexture","resolve","cubeMapBuffers","that","then","buffers","otherwise","reject","fromCache","vertexShaderSource","fragmentShaderSource","attributeLocations","position","Math","min","Array","originalSize","positiveX","width","uniformMap","pixelDatatype","HALF_FLOAT","pixelFormat","RGBA","positiveY","negativeY","cubeMap","source","size","mipTexture","height","command","vertexArray","shaderProgram","outputTexture","persists","owner","commandList","push","addTexture","atlasCommand","isDestroyed"],"mappings":"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","sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport loadKTX from \"../Core/loadKTX.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ComputeCommand from \"../Renderer/ComputeCommand.js\";\nimport CubeMap from \"../Renderer/CubeMap.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport OctahedralProjectionAtlasFS from \"../Shaders/OctahedralProjectionAtlasFS.js\";\nimport OctahedralProjectionFS from \"../Shaders/OctahedralProjectionFS.js\";\nimport OctahedralProjectionVS from \"../Shaders/OctahedralProjectionVS.js\";\nimport when from \"../ThirdParty/when.js\";\n\n/**\n * Packs all mip levels of a cube map into a 2D texture atlas.\n *\n * Octahedral projection is a way of putting the cube maps onto a 2D texture\n * with minimal distortion and easy look up.\n * See Chapter 16 of WebGL Insights \"HDR Image-Based Lighting on the Web\" by Jeff Russell\n * and \"Octahedron Environment Maps\" for reference.\n *\n * @private\n */\nfunction OctahedralProjectedCubeMap(url) {\n  this._url = url;\n\n  this._cubeMapBuffers = undefined;\n  this._cubeMaps = undefined;\n  this._texture = undefined;\n  this._mipTextures = undefined;\n  this._va = undefined;\n  this._sp = undefined;\n\n  this._maximumMipmapLevel = undefined;\n\n  this._loading = false;\n  this._ready = false;\n  this._readyPromise = when.defer();\n}\n\nObject.defineProperties(OctahedralProjectedCubeMap.prototype, {\n  /**\n   * The url to the KTX file containing the specular environment map and convoluted mipmaps.\n   * @memberof OctahedralProjectedCubeMap.prototype\n   * @type {String}\n   * @readonly\n   */\n  url: {\n    get: function () {\n      return this._url;\n    },\n  },\n  /**\n   * A texture containing all the packed convolutions.\n   * @memberof OctahedralProjectedCubeMap.prototype\n   * @type {Texture}\n   * @readonly\n   */\n  texture: {\n    get: function () {\n      return this._texture;\n    },\n  },\n  /**\n   * The maximum number of mip levels.\n   * @memberOf OctahedralProjectedCubeMap.prototype\n   * @type {Number}\n   * @readonly\n   */\n  maximumMipmapLevel: {\n    get: function () {\n      return this._maximumMipmapLevel;\n    },\n  },\n  /**\n   * Determines if the texture atlas is complete and ready to use.\n   * @memberof OctahedralProjectedCubeMap.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n  /**\n   * Gets a promise that resolves when the texture atlas is ready to use.\n   * @memberof OctahedralProjectedCubeMap.prototype\n   * @type {Promise}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n});\n\nOctahedralProjectedCubeMap.isSupported = function (context) {\n  return (\n    (context.colorBufferHalfFloat && context.halfFloatingPointTexture) ||\n    (context.floatingPointTexture && context.colorBufferFloat)\n  );\n};\n\n// These vertices are based on figure 1 from \"Octahedron Environment Maps\".\nvar v1 = new Cartesian3(1.0, 0.0, 0.0);\nvar v2 = new Cartesian3(0.0, 0.0, 1.0);\nvar v3 = new Cartesian3(-1.0, 0.0, 0.0);\nvar v4 = new Cartesian3(0.0, 0.0, -1.0);\nvar v5 = new Cartesian3(0.0, 1.0, 0.0);\nvar v6 = new Cartesian3(0.0, -1.0, 0.0);\n\n// top left, left, top, center, right, top right, bottom, bottom left, bottom right\nvar cubeMapCoordinates = [v5, v3, v2, v6, v1, v5, v4, v5, v5];\nvar length = cubeMapCoordinates.length;\nvar flatCubeMapCoordinates = new Float32Array(length * 3);\n\nvar offset = 0;\nfor (var i = 0; i < length; ++i, offset += 3) {\n  Cartesian3.pack(cubeMapCoordinates[i], flatCubeMapCoordinates, offset);\n}\n\nvar flatPositions = new Float32Array([\n  -1.0,\n  1.0, // top left\n  -1.0,\n  0.0, // left\n  0.0,\n  1.0, // top\n  0.0,\n  0.0, // center\n  1.0,\n  0.0, // right\n  1.0,\n  1.0, // top right\n  0.0,\n  -1.0, // bottom\n  -1.0,\n  -1.0, // bottom left\n  1.0,\n  -1.0, // bottom right\n]);\nvar indices = new Uint16Array([\n  0,\n  1,\n  2, // top left, left, top,\n  2,\n  3,\n  1, // top, center, left,\n  7,\n  6,\n  1, // bottom left, bottom, left,\n  3,\n  6,\n  1, // center, bottom, left,\n  2,\n  5,\n  4, // top, top right, right,\n  3,\n  4,\n  2, // center, right, top,\n  4,\n  8,\n  6, // right, bottom right, bottom,\n  3,\n  4,\n  6, //center, right, bottom\n]);\n\nfunction createVertexArray(context) {\n  var positionBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: flatPositions,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  var cubeMapCoordinatesBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: flatCubeMapCoordinates,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  var indexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: indices,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: IndexDatatype.UNSIGNED_SHORT,\n  });\n\n  var attributes = [\n    {\n      index: 0,\n      vertexBuffer: positionBuffer,\n      componentsPerAttribute: 2,\n      componentDatatype: ComponentDatatype.FLOAT,\n    },\n    {\n      index: 1,\n      vertexBuffer: cubeMapCoordinatesBuffer,\n      componentsPerAttribute: 3,\n      componentDatatype: ComponentDatatype.FLOAT,\n    },\n  ];\n  return new VertexArray({\n    context: context,\n    attributes: attributes,\n    indexBuffer: indexBuffer,\n  });\n}\n\nfunction createUniformTexture(texture) {\n  return function () {\n    return texture;\n  };\n}\n\nfunction cleanupResources(map) {\n  map._va = map._va && map._va.destroy();\n  map._sp = map._sp && map._sp.destroy();\n\n  var i;\n  var length;\n\n  var cubeMaps = map._cubeMaps;\n  if (defined(cubeMaps)) {\n    length = cubeMaps.length;\n    for (i = 0; i < length; ++i) {\n      cubeMaps[i].destroy();\n    }\n  }\n  var mipTextures = map._mipTextures;\n  if (defined(mipTextures)) {\n    length = mipTextures.length;\n    for (i = 0; i < length; ++i) {\n      mipTextures[i].destroy();\n    }\n  }\n\n  map._va = undefined;\n  map._sp = undefined;\n  map._cubeMaps = undefined;\n  map._cubeMapBuffers = undefined;\n  map._mipTextures = undefined;\n}\n\n/**\n * Creates compute commands to generate octahedral projections of each cube map\n * and then renders them to an atlas.\n * <p>\n * Only needs to be called twice. The first call queues the compute commands to generate the atlas.\n * The second call cleans up unused resources. Every call afterwards is a no-op.\n * </p>\n *\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nOctahedralProjectedCubeMap.prototype.update = function (frameState) {\n  var context = frameState.context;\n\n  if (!OctahedralProjectedCubeMap.isSupported(context)) {\n    return;\n  }\n\n  if (defined(this._texture) && defined(this._va)) {\n    cleanupResources(this);\n  }\n  if (defined(this._texture)) {\n    return;\n  }\n\n  if (!defined(this._texture) && !this._loading) {\n    var cachedTexture = context.textureCache.getTexture(this._url);\n    if (defined(cachedTexture)) {\n      cleanupResources(this);\n      this._texture = cachedTexture;\n      this._maximumMipmapLevel = this._texture.maximumMipmapLevel;\n      this._ready = true;\n      this._readyPromise.resolve();\n      return;\n    }\n  }\n\n  var cubeMapBuffers = this._cubeMapBuffers;\n  if (!defined(cubeMapBuffers) && !this._loading) {\n    var that = this;\n    loadKTX(this._url)\n      .then(function (buffers) {\n        that._cubeMapBuffers = buffers;\n        that._loading = false;\n      })\n      .otherwise(this._readyPromise.reject);\n    this._loading = true;\n  }\n  if (!defined(this._cubeMapBuffers)) {\n    return;\n  }\n\n  this._va = createVertexArray(context);\n  this._sp = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: OctahedralProjectionVS,\n    fragmentShaderSource: OctahedralProjectionFS,\n    attributeLocations: {\n      position: 0,\n      cubeMapCoordinates: 1,\n    },\n  });\n\n  // We only need up to 6 mip levels to avoid artifacts.\n  var length = Math.min(cubeMapBuffers.length, 6);\n  this._maximumMipmapLevel = length - 1;\n  var cubeMaps = (this._cubeMaps = new Array(length));\n  var mipTextures = (this._mipTextures = new Array(length));\n  var originalSize = cubeMapBuffers[0].positiveX.width * 2.0;\n  var uniformMap = {\n    originalSize: function () {\n      return originalSize;\n    },\n  };\n\n  var pixelDatatype = context.halfFloatingPointTexture\n    ? PixelDatatype.HALF_FLOAT\n    : PixelDatatype.FLOAT;\n  var pixelFormat = PixelFormat.RGBA;\n\n  // First we project each cubemap onto a flat octahedron, and write that to a texture.\n  for (var i = 0; i < length; ++i) {\n    // Swap +Y/-Y faces since the octahedral projection expects this order.\n    var positiveY = cubeMapBuffers[i].positiveY;\n    cubeMapBuffers[i].positiveY = cubeMapBuffers[i].negativeY;\n    cubeMapBuffers[i].negativeY = positiveY;\n\n    var cubeMap = (cubeMaps[i] = new CubeMap({\n      context: context,\n      source: cubeMapBuffers[i],\n    }));\n    var size = cubeMaps[i].width * 2;\n\n    var mipTexture = (mipTextures[i] = new Texture({\n      context: context,\n      width: size,\n      height: size,\n      pixelDatatype: pixelDatatype,\n      pixelFormat: pixelFormat,\n    }));\n\n    var command = new ComputeCommand({\n      vertexArray: this._va,\n      shaderProgram: this._sp,\n      uniformMap: {\n        cubeMap: createUniformTexture(cubeMap),\n      },\n      outputTexture: mipTexture,\n      persists: true,\n      owner: this,\n    });\n    frameState.commandList.push(command);\n\n    uniformMap[\"texture\" + i] = createUniformTexture(mipTexture);\n  }\n\n  this._texture = new Texture({\n    context: context,\n    width: originalSize * 1.5 + 2.0, // We add a 1 pixel border to avoid linear sampling artifacts.\n    height: originalSize,\n    pixelDatatype: pixelDatatype,\n    pixelFormat: pixelFormat,\n  });\n\n  this._texture.maximumMipmapLevel = this._maximumMipmapLevel;\n  context.textureCache.addTexture(this._url, this._texture);\n\n  var atlasCommand = new ComputeCommand({\n    fragmentShaderSource: OctahedralProjectionAtlasFS,\n    uniformMap: uniformMap,\n    outputTexture: this._texture,\n    persists: false,\n    owner: this,\n  });\n  frameState.commandList.push(atlasCommand);\n\n  this._ready = true;\n  this._readyPromise.resolve();\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see OctahedralProjectedCubeMap#destroy\n */\nOctahedralProjectedCubeMap.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see OctahedralProjectedCubeMap#isDestroyed\n */\nOctahedralProjectedCubeMap.prototype.destroy = function () {\n  cleanupResources(this);\n  this._texture = this._texture && this._texture.destroy();\n  return destroyObject(this);\n};\nexport default OctahedralProjectedCubeMap;\n"]},"metadata":{},"sourceType":"module"}