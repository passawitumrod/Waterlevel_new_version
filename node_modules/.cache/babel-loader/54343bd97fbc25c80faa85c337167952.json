{"ast":null,"code":"import ApproximateTerrainHeights from \"./ApproximateTerrainHeights.js\";\nimport ArcType from \"./ArcType.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidGeodesic from \"./EllipsoidGeodesic.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport EncodedCartesian3 from \"./EncodedCartesian3.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Plane from \"./Plane.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport WebMercatorProjection from \"./WebMercatorProjection.js\";\nvar PROJECTIONS = [GeographicProjection, WebMercatorProjection];\nvar PROJECTION_COUNT = PROJECTIONS.length;\nvar MITER_BREAK_SMALL = Math.cos(CesiumMath.toRadians(30.0));\nvar MITER_BREAK_LARGE = Math.cos(CesiumMath.toRadians(150.0)); // Initial heights for constructing the wall.\n// Keeping WALL_INITIAL_MIN_HEIGHT near the ellipsoid surface helps\n// prevent precision problems with planes in the shader.\n// Putting the start point of a plane at ApproximateTerrainHeights._defaultMinTerrainHeight,\n// which is a highly conservative bound, usually puts the plane origin several thousands\n// of meters away from the actual terrain, causing floating point problems when checking\n// fragments on terrain against the plane.\n// Ellipsoid height is generally much closer.\n// The initial max height is arbitrary.\n// Both heights are corrected using ApproximateTerrainHeights for computing the actual volume geometry.\n\nvar WALL_INITIAL_MIN_HEIGHT = 0.0;\nvar WALL_INITIAL_MAX_HEIGHT = 1000.0;\n/**\n * A description of a polyline on terrain or 3D Tiles. Only to be used with {@link GroundPolylinePrimitive}.\n *\n * @alias GroundPolylineGeometry\n * @constructor\n *\n * @param {Object} options Options with the following properties:\n * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the polyline's points. Heights above the ellipsoid will be ignored.\n * @param {Number} [options.width=1.0] The screen space width in pixels.\n * @param {Number} [options.granularity=9999.0] The distance interval in meters used for interpolating options.points. Defaults to 9999.0 meters. Zero indicates no interpolation.\n * @param {Boolean} [options.loop=false] Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n *\n * @exception {DeveloperError} At least two positions are required.\n *\n * @see GroundPolylinePrimitive\n *\n * @example\n * var positions = Cesium.Cartesian3.fromDegreesArray([\n *   -112.1340164450331, 36.05494287836128,\n *   -112.08821010582645, 36.097804071380715,\n *   -112.13296079730024, 36.168769146801104\n * ]);\n *\n * var geometry = new Cesium.GroundPolylineGeometry({\n *   positions : positions\n * });\n */\n\nfunction GroundPolylineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var positions = options.positions; //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(positions) || positions.length < 2) {\n    throw new DeveloperError(\"At least two positions are required.\");\n  }\n\n  if (defined(options.arcType) && options.arcType !== ArcType.GEODESIC && options.arcType !== ArcType.RHUMB) {\n    throw new DeveloperError(\"Valid options for arcType are ArcType.GEODESIC and ArcType.RHUMB.\");\n  } //>>includeEnd('debug');\n\n  /**\n   * The screen space width in pixels.\n   * @type {Number}\n   */\n\n\n  this.width = defaultValue(options.width, 1.0); // Doesn't get packed, not necessary for computing geometry.\n\n  this._positions = positions;\n  /**\n   * The distance interval used for interpolating options.points. Zero indicates no interpolation.\n   * Default of 9999.0 allows centimeter accuracy with 32 bit floating point.\n   * @type {Boolean}\n   * @default 9999.0\n   */\n\n  this.granularity = defaultValue(options.granularity, 9999.0);\n  /**\n   * Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\n   * If the geometry has two positions this parameter will be ignored.\n   * @type {Boolean}\n   * @default false\n   */\n\n  this.loop = defaultValue(options.loop, false);\n  /**\n   * The type of path the polyline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n   * @type {ArcType}\n   * @default ArcType.GEODESIC\n   */\n\n  this.arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n  this._ellipsoid = Ellipsoid.WGS84; // MapProjections can't be packed, so store the index to a known MapProjection.\n\n  this._projectionIndex = 0;\n  this._workerName = \"createGroundPolylineGeometry\"; // Used by GroundPolylinePrimitive to signal worker that scenemode is 3D only.\n\n  this._scene3DOnly = false;\n}\n\nObject.defineProperties(GroundPolylineGeometry.prototype, {\n  /**\n   * The number of elements used to pack the object into an array.\n   * @memberof GroundPolylineGeometry.prototype\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  packedLength: {\n    get: function () {\n      return 1.0 + this._positions.length * 3 + 1.0 + 1.0 + 1.0 + Ellipsoid.packedLength + 1.0 + 1.0;\n    }\n  }\n});\n/**\n * Set the GroundPolylineGeometry's projection and ellipsoid.\n * Used by GroundPolylinePrimitive to signal scene information to the geometry for generating 2D attributes.\n *\n * @param {GroundPolylineGeometry} groundPolylineGeometry GroundPolylinGeometry describing a polyline on terrain or 3D Tiles.\n * @param {Projection} mapProjection A MapProjection used for projecting cartographic coordinates to 2D.\n * @private\n */\n\nGroundPolylineGeometry.setProjectionAndEllipsoid = function (groundPolylineGeometry, mapProjection) {\n  var projectionIndex = 0;\n\n  for (var i = 0; i < PROJECTION_COUNT; i++) {\n    if (mapProjection instanceof PROJECTIONS[i]) {\n      projectionIndex = i;\n      break;\n    }\n  }\n\n  groundPolylineGeometry._projectionIndex = projectionIndex;\n  groundPolylineGeometry._ellipsoid = mapProjection.ellipsoid;\n};\n\nvar cart3Scratch1 = new Cartesian3();\nvar cart3Scratch2 = new Cartesian3();\nvar cart3Scratch3 = new Cartesian3();\n\nfunction computeRightNormal(start, end, maxHeight, ellipsoid, result) {\n  var startBottom = getPosition(ellipsoid, start, 0.0, cart3Scratch1);\n  var startTop = getPosition(ellipsoid, start, maxHeight, cart3Scratch2);\n  var endBottom = getPosition(ellipsoid, end, 0.0, cart3Scratch3);\n  var up = direction(startTop, startBottom, cart3Scratch2);\n  var forward = direction(endBottom, startBottom, cart3Scratch3);\n  Cartesian3.cross(forward, up, result);\n  return Cartesian3.normalize(result, result);\n}\n\nvar interpolatedCartographicScratch = new Cartographic();\nvar interpolatedBottomScratch = new Cartesian3();\nvar interpolatedTopScratch = new Cartesian3();\nvar interpolatedNormalScratch = new Cartesian3();\n\nfunction interpolateSegment(start, end, minHeight, maxHeight, granularity, arcType, ellipsoid, normalsArray, bottomPositionsArray, topPositionsArray, cartographicsArray) {\n  if (granularity === 0.0) {\n    return;\n  }\n\n  var ellipsoidLine;\n\n  if (arcType === ArcType.GEODESIC) {\n    ellipsoidLine = new EllipsoidGeodesic(start, end, ellipsoid);\n  } else if (arcType === ArcType.RHUMB) {\n    ellipsoidLine = new EllipsoidRhumbLine(start, end, ellipsoid);\n  }\n\n  var surfaceDistance = ellipsoidLine.surfaceDistance;\n\n  if (surfaceDistance < granularity) {\n    return;\n  } // Compute rightwards normal applicable at all interpolated points\n\n\n  var interpolatedNormal = computeRightNormal(start, end, maxHeight, ellipsoid, interpolatedNormalScratch);\n  var segments = Math.ceil(surfaceDistance / granularity);\n  var interpointDistance = surfaceDistance / segments;\n  var distanceFromStart = interpointDistance;\n  var pointsToAdd = segments - 1;\n  var packIndex = normalsArray.length;\n\n  for (var i = 0; i < pointsToAdd; i++) {\n    var interpolatedCartographic = ellipsoidLine.interpolateUsingSurfaceDistance(distanceFromStart, interpolatedCartographicScratch);\n    var interpolatedBottom = getPosition(ellipsoid, interpolatedCartographic, minHeight, interpolatedBottomScratch);\n    var interpolatedTop = getPosition(ellipsoid, interpolatedCartographic, maxHeight, interpolatedTopScratch);\n    Cartesian3.pack(interpolatedNormal, normalsArray, packIndex);\n    Cartesian3.pack(interpolatedBottom, bottomPositionsArray, packIndex);\n    Cartesian3.pack(interpolatedTop, topPositionsArray, packIndex);\n    cartographicsArray.push(interpolatedCartographic.latitude);\n    cartographicsArray.push(interpolatedCartographic.longitude);\n    packIndex += 3;\n    distanceFromStart += interpointDistance;\n  }\n}\n\nvar heightlessCartographicScratch = new Cartographic();\n\nfunction getPosition(ellipsoid, cartographic, height, result) {\n  Cartographic.clone(cartographic, heightlessCartographicScratch);\n  heightlessCartographicScratch.height = height;\n  return Cartographic.toCartesian(heightlessCartographicScratch, ellipsoid, result);\n}\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolygonGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\n\nGroundPolylineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  var index = defaultValue(startingIndex, 0);\n  var positions = value._positions;\n  var positionsLength = positions.length;\n  array[index++] = positionsLength;\n\n  for (var i = 0; i < positionsLength; ++i) {\n    var cartesian = positions[i];\n    Cartesian3.pack(cartesian, array, index);\n    index += 3;\n  }\n\n  array[index++] = value.granularity;\n  array[index++] = value.loop ? 1.0 : 0.0;\n  array[index++] = value.arcType;\n  Ellipsoid.pack(value._ellipsoid, array, index);\n  index += Ellipsoid.packedLength;\n  array[index++] = value._projectionIndex;\n  array[index++] = value._scene3DOnly ? 1.0 : 0.0;\n  return array;\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolygonGeometry} [result] The object into which to store the result.\n */\n\n\nGroundPolylineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  var index = defaultValue(startingIndex, 0);\n  var positionsLength = array[index++];\n  var positions = new Array(positionsLength);\n\n  for (var i = 0; i < positionsLength; i++) {\n    positions[i] = Cartesian3.unpack(array, index);\n    index += 3;\n  }\n\n  var granularity = array[index++];\n  var loop = array[index++] === 1.0;\n  var arcType = array[index++];\n  var ellipsoid = Ellipsoid.unpack(array, index);\n  index += Ellipsoid.packedLength;\n  var projectionIndex = array[index++];\n  var scene3DOnly = array[index++] === 1.0;\n\n  if (!defined(result)) {\n    result = new GroundPolylineGeometry({\n      positions: positions\n    });\n  }\n\n  result._positions = positions;\n  result.granularity = granularity;\n  result.loop = loop;\n  result.arcType = arcType;\n  result._ellipsoid = ellipsoid;\n  result._projectionIndex = projectionIndex;\n  result._scene3DOnly = scene3DOnly;\n  return result;\n};\n\nfunction direction(target, origin, result) {\n  Cartesian3.subtract(target, origin, result);\n  Cartesian3.normalize(result, result);\n  return result;\n}\n\nfunction tangentDirection(target, origin, up, result) {\n  result = direction(target, origin, result); // orthogonalize\n\n  result = Cartesian3.cross(result, up, result);\n  result = Cartesian3.normalize(result, result);\n  result = Cartesian3.cross(up, result, result);\n  return result;\n}\n\nvar toPreviousScratch = new Cartesian3();\nvar toNextScratch = new Cartesian3();\nvar forwardScratch = new Cartesian3();\nvar vertexUpScratch = new Cartesian3();\nvar cosine90 = 0.0;\nvar cosine180 = -1.0;\n\nfunction computeVertexMiterNormal(previousBottom, vertexBottom, vertexTop, nextBottom, result) {\n  var up = direction(vertexTop, vertexBottom, vertexUpScratch); // Compute vectors pointing towards neighboring points but tangent to this point on the ellipsoid\n\n  var toPrevious = tangentDirection(previousBottom, vertexBottom, up, toPreviousScratch);\n  var toNext = tangentDirection(nextBottom, vertexBottom, up, toNextScratch); // Check if tangents are almost opposite - if so, no need to miter.\n\n  if (CesiumMath.equalsEpsilon(Cartesian3.dot(toPrevious, toNext), cosine180, CesiumMath.EPSILON5)) {\n    result = Cartesian3.cross(up, toPrevious, result);\n    result = Cartesian3.normalize(result, result);\n    return result;\n  } // Average directions to previous and to next in the plane of Up\n\n\n  result = Cartesian3.add(toNext, toPrevious, result);\n  result = Cartesian3.normalize(result, result); // Flip the normal if it isn't pointing roughly bound right (aka if forward is pointing more \"backwards\")\n\n  var forward = Cartesian3.cross(up, result, forwardScratch);\n\n  if (Cartesian3.dot(toNext, forward) < cosine90) {\n    result = Cartesian3.negate(result, result);\n  }\n\n  return result;\n}\n\nvar XZ_PLANE = Plane.fromPointNormal(Cartesian3.ZERO, Cartesian3.UNIT_Y);\nvar previousBottomScratch = new Cartesian3();\nvar vertexBottomScratch = new Cartesian3();\nvar vertexTopScratch = new Cartesian3();\nvar nextBottomScratch = new Cartesian3();\nvar vertexNormalScratch = new Cartesian3();\nvar intersectionScratch = new Cartesian3();\nvar cartographicScratch0 = new Cartographic();\nvar cartographicScratch1 = new Cartographic();\nvar cartographicIntersectionScratch = new Cartographic();\n/**\n * Computes shadow volumes for the ground polyline, consisting of its vertices, indices, and a bounding sphere.\n * Vertices are \"fat,\" packing all the data needed in each volume to describe a line on terrain or 3D Tiles.\n * Should not be called independent of {@link GroundPolylinePrimitive}.\n *\n * @param {GroundPolylineGeometry} groundPolylineGeometry\n * @private\n */\n\nGroundPolylineGeometry.createGeometry = function (groundPolylineGeometry) {\n  var compute2dAttributes = !groundPolylineGeometry._scene3DOnly;\n  var loop = groundPolylineGeometry.loop;\n  var ellipsoid = groundPolylineGeometry._ellipsoid;\n  var granularity = groundPolylineGeometry.granularity;\n  var arcType = groundPolylineGeometry.arcType;\n  var projection = new PROJECTIONS[groundPolylineGeometry._projectionIndex](ellipsoid);\n  var minHeight = WALL_INITIAL_MIN_HEIGHT;\n  var maxHeight = WALL_INITIAL_MAX_HEIGHT;\n  var index;\n  var i;\n  var positions = groundPolylineGeometry._positions;\n  var positionsLength = positions.length;\n\n  if (positionsLength === 2) {\n    loop = false;\n  } // Split positions across the IDL and the Prime Meridian as well.\n  // Split across prime meridian because very large geometries crossing the Prime Meridian but not the IDL\n  // may get split by the plane of IDL + Prime Meridian.\n\n\n  var p0;\n  var p1;\n  var c0;\n  var c1;\n  var rhumbLine = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  var intersection;\n  var intersectionCartographic;\n  var intersectionLongitude;\n  var splitPositions = [positions[0]];\n\n  for (i = 0; i < positionsLength - 1; i++) {\n    p0 = positions[i];\n    p1 = positions[i + 1];\n    intersection = IntersectionTests.lineSegmentPlane(p0, p1, XZ_PLANE, intersectionScratch);\n\n    if (defined(intersection) && !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) && !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)) {\n      if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\n        splitPositions.push(Cartesian3.clone(intersection));\n      } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\n        intersectionLongitude = ellipsoid.cartesianToCartographic(intersection, cartographicScratch0).longitude;\n        c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\n        c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\n        rhumbLine.setEndPoints(c0, c1);\n        intersectionCartographic = rhumbLine.findIntersectionWithLongitude(intersectionLongitude, cartographicIntersectionScratch);\n        intersection = ellipsoid.cartographicToCartesian(intersectionCartographic, intersectionScratch);\n\n        if (defined(intersection) && !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) && !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)) {\n          splitPositions.push(Cartesian3.clone(intersection));\n        }\n      }\n    }\n\n    splitPositions.push(p1);\n  }\n\n  if (loop) {\n    p0 = positions[positionsLength - 1];\n    p1 = positions[0];\n    intersection = IntersectionTests.lineSegmentPlane(p0, p1, XZ_PLANE, intersectionScratch);\n\n    if (defined(intersection) && !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) && !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)) {\n      if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\n        splitPositions.push(Cartesian3.clone(intersection));\n      } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\n        intersectionLongitude = ellipsoid.cartesianToCartographic(intersection, cartographicScratch0).longitude;\n        c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\n        c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\n        rhumbLine.setEndPoints(c0, c1);\n        intersectionCartographic = rhumbLine.findIntersectionWithLongitude(intersectionLongitude, cartographicIntersectionScratch);\n        intersection = ellipsoid.cartographicToCartesian(intersectionCartographic, intersectionScratch);\n\n        if (defined(intersection) && !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) && !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)) {\n          splitPositions.push(Cartesian3.clone(intersection));\n        }\n      }\n    }\n  }\n\n  var cartographicsLength = splitPositions.length;\n  var cartographics = new Array(cartographicsLength);\n\n  for (i = 0; i < cartographicsLength; i++) {\n    var cartographic = Cartographic.fromCartesian(splitPositions[i], ellipsoid);\n    cartographic.height = 0.0;\n    cartographics[i] = cartographic;\n  }\n\n  cartographics = arrayRemoveDuplicates(cartographics, Cartographic.equalsEpsilon);\n  cartographicsLength = cartographics.length;\n\n  if (cartographicsLength < 2) {\n    return undefined;\n  }\n  /**** Build heap-side arrays for positions, interpolated cartographics, and normals from which to compute vertices ****/\n  // We build a \"wall\" and then decompose it into separately connected component \"volumes\" because we need a lot\n  // of information about the wall. Also, this simplifies interpolation.\n  // Convention: \"next\" and \"end\" are locally forward to each segment of the wall,\n  // and we are computing normals pointing towards the local right side of the vertices in each segment.\n\n\n  var cartographicsArray = [];\n  var normalsArray = [];\n  var bottomPositionsArray = [];\n  var topPositionsArray = [];\n  var previousBottom = previousBottomScratch;\n  var vertexBottom = vertexBottomScratch;\n  var vertexTop = vertexTopScratch;\n  var nextBottom = nextBottomScratch;\n  var vertexNormal = vertexNormalScratch; // First point - either loop or attach a \"perpendicular\" normal\n\n  var startCartographic = cartographics[0];\n  var nextCartographic = cartographics[1];\n  var prestartCartographic = cartographics[cartographicsLength - 1];\n  previousBottom = getPosition(ellipsoid, prestartCartographic, minHeight, previousBottom);\n  nextBottom = getPosition(ellipsoid, nextCartographic, minHeight, nextBottom);\n  vertexBottom = getPosition(ellipsoid, startCartographic, minHeight, vertexBottom);\n  vertexTop = getPosition(ellipsoid, startCartographic, maxHeight, vertexTop);\n\n  if (loop) {\n    vertexNormal = computeVertexMiterNormal(previousBottom, vertexBottom, vertexTop, nextBottom, vertexNormal);\n  } else {\n    vertexNormal = computeRightNormal(startCartographic, nextCartographic, maxHeight, ellipsoid, vertexNormal);\n  }\n\n  Cartesian3.pack(vertexNormal, normalsArray, 0);\n  Cartesian3.pack(vertexBottom, bottomPositionsArray, 0);\n  Cartesian3.pack(vertexTop, topPositionsArray, 0);\n  cartographicsArray.push(startCartographic.latitude);\n  cartographicsArray.push(startCartographic.longitude);\n  interpolateSegment(startCartographic, nextCartographic, minHeight, maxHeight, granularity, arcType, ellipsoid, normalsArray, bottomPositionsArray, topPositionsArray, cartographicsArray); // All inbetween points\n\n  for (i = 1; i < cartographicsLength - 1; ++i) {\n    previousBottom = Cartesian3.clone(vertexBottom, previousBottom);\n    vertexBottom = Cartesian3.clone(nextBottom, vertexBottom);\n    var vertexCartographic = cartographics[i];\n    getPosition(ellipsoid, vertexCartographic, maxHeight, vertexTop);\n    getPosition(ellipsoid, cartographics[i + 1], minHeight, nextBottom);\n    computeVertexMiterNormal(previousBottom, vertexBottom, vertexTop, nextBottom, vertexNormal);\n    index = normalsArray.length;\n    Cartesian3.pack(vertexNormal, normalsArray, index);\n    Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\n    Cartesian3.pack(vertexTop, topPositionsArray, index);\n    cartographicsArray.push(vertexCartographic.latitude);\n    cartographicsArray.push(vertexCartographic.longitude);\n    interpolateSegment(cartographics[i], cartographics[i + 1], minHeight, maxHeight, granularity, arcType, ellipsoid, normalsArray, bottomPositionsArray, topPositionsArray, cartographicsArray);\n  } // Last point - either loop or attach a normal \"perpendicular\" to the wall.\n\n\n  var endCartographic = cartographics[cartographicsLength - 1];\n  var preEndCartographic = cartographics[cartographicsLength - 2];\n  vertexBottom = getPosition(ellipsoid, endCartographic, minHeight, vertexBottom);\n  vertexTop = getPosition(ellipsoid, endCartographic, maxHeight, vertexTop);\n\n  if (loop) {\n    var postEndCartographic = cartographics[0];\n    previousBottom = getPosition(ellipsoid, preEndCartographic, minHeight, previousBottom);\n    nextBottom = getPosition(ellipsoid, postEndCartographic, minHeight, nextBottom);\n    vertexNormal = computeVertexMiterNormal(previousBottom, vertexBottom, vertexTop, nextBottom, vertexNormal);\n  } else {\n    vertexNormal = computeRightNormal(preEndCartographic, endCartographic, maxHeight, ellipsoid, vertexNormal);\n  }\n\n  index = normalsArray.length;\n  Cartesian3.pack(vertexNormal, normalsArray, index);\n  Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\n  Cartesian3.pack(vertexTop, topPositionsArray, index);\n  cartographicsArray.push(endCartographic.latitude);\n  cartographicsArray.push(endCartographic.longitude);\n\n  if (loop) {\n    interpolateSegment(endCartographic, startCartographic, minHeight, maxHeight, granularity, arcType, ellipsoid, normalsArray, bottomPositionsArray, topPositionsArray, cartographicsArray);\n    index = normalsArray.length;\n\n    for (i = 0; i < 3; ++i) {\n      normalsArray[index + i] = normalsArray[i];\n      bottomPositionsArray[index + i] = bottomPositionsArray[i];\n      topPositionsArray[index + i] = topPositionsArray[i];\n    }\n\n    cartographicsArray.push(startCartographic.latitude);\n    cartographicsArray.push(startCartographic.longitude);\n  }\n\n  return generateGeometryAttributes(loop, projection, bottomPositionsArray, topPositionsArray, normalsArray, cartographicsArray, compute2dAttributes);\n}; // If the end normal angle is too steep compared to the direction of the line segment,\n// \"break\" the miter by rotating the normal 90 degrees around the \"up\" direction at the point\n// For ultra precision we would want to project into a plane, but in practice this is sufficient.\n\n\nvar lineDirectionScratch = new Cartesian3();\nvar matrix3Scratch = new Matrix3();\nvar quaternionScratch = new Quaternion();\n\nfunction breakMiter(endGeometryNormal, startBottom, endBottom, endTop) {\n  var lineDirection = direction(endBottom, startBottom, lineDirectionScratch);\n  var dot = Cartesian3.dot(lineDirection, endGeometryNormal);\n\n  if (dot > MITER_BREAK_SMALL || dot < MITER_BREAK_LARGE) {\n    var vertexUp = direction(endTop, endBottom, vertexUpScratch);\n    var angle = dot < MITER_BREAK_LARGE ? CesiumMath.PI_OVER_TWO : -CesiumMath.PI_OVER_TWO;\n    var quaternion = Quaternion.fromAxisAngle(vertexUp, angle, quaternionScratch);\n    var rotationMatrix = Matrix3.fromQuaternion(quaternion, matrix3Scratch);\n    Matrix3.multiplyByVector(rotationMatrix, endGeometryNormal, endGeometryNormal);\n    return true;\n  }\n\n  return false;\n}\n\nvar endPosCartographicScratch = new Cartographic();\nvar normalStartpointScratch = new Cartesian3();\nvar normalEndpointScratch = new Cartesian3();\n\nfunction projectNormal(projection, cartographic, normal, projectedPosition, result) {\n  var position = Cartographic.toCartesian(cartographic, projection._ellipsoid, normalStartpointScratch);\n  var normalEndpoint = Cartesian3.add(position, normal, normalEndpointScratch);\n  var flipNormal = false;\n  var ellipsoid = projection._ellipsoid;\n  var normalEndpointCartographic = ellipsoid.cartesianToCartographic(normalEndpoint, endPosCartographicScratch); // If normal crosses the IDL, go the other way and flip the result.\n  // In practice this almost never happens because the cartographic start\n  // and end points of each segment are \"nudged\" to be on the same side\n  // of the IDL and slightly away from the IDL.\n\n  if (Math.abs(cartographic.longitude - normalEndpointCartographic.longitude) > CesiumMath.PI_OVER_TWO) {\n    flipNormal = true;\n    normalEndpoint = Cartesian3.subtract(position, normal, normalEndpointScratch);\n    normalEndpointCartographic = ellipsoid.cartesianToCartographic(normalEndpoint, endPosCartographicScratch);\n  }\n\n  normalEndpointCartographic.height = 0.0;\n  var normalEndpointProjected = projection.project(normalEndpointCartographic, result);\n  result = Cartesian3.subtract(normalEndpointProjected, projectedPosition, result);\n  result.z = 0.0;\n  result = Cartesian3.normalize(result, result);\n\n  if (flipNormal) {\n    Cartesian3.negate(result, result);\n  }\n\n  return result;\n}\n\nvar adjustHeightNormalScratch = new Cartesian3();\nvar adjustHeightOffsetScratch = new Cartesian3();\n\nfunction adjustHeights(bottom, top, minHeight, maxHeight, adjustHeightBottom, adjustHeightTop) {\n  // bottom and top should be at WALL_INITIAL_MIN_HEIGHT and WALL_INITIAL_MAX_HEIGHT, respectively\n  var adjustHeightNormal = Cartesian3.subtract(top, bottom, adjustHeightNormalScratch);\n  Cartesian3.normalize(adjustHeightNormal, adjustHeightNormal);\n  var distanceForBottom = minHeight - WALL_INITIAL_MIN_HEIGHT;\n  var adjustHeightOffset = Cartesian3.multiplyByScalar(adjustHeightNormal, distanceForBottom, adjustHeightOffsetScratch);\n  Cartesian3.add(bottom, adjustHeightOffset, adjustHeightBottom);\n  var distanceForTop = maxHeight - WALL_INITIAL_MAX_HEIGHT;\n  adjustHeightOffset = Cartesian3.multiplyByScalar(adjustHeightNormal, distanceForTop, adjustHeightOffsetScratch);\n  Cartesian3.add(top, adjustHeightOffset, adjustHeightTop);\n}\n\nvar nudgeDirectionScratch = new Cartesian3();\n\nfunction nudgeXZ(start, end) {\n  var startToXZdistance = Plane.getPointDistance(XZ_PLANE, start);\n  var endToXZdistance = Plane.getPointDistance(XZ_PLANE, end);\n  var offset = nudgeDirectionScratch; // Larger epsilon than what's used in GeometryPipeline, a centimeter in world space\n\n  if (CesiumMath.equalsEpsilon(startToXZdistance, 0.0, CesiumMath.EPSILON2)) {\n    offset = direction(end, start, offset);\n    Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\n    Cartesian3.add(start, offset, start);\n  } else if (CesiumMath.equalsEpsilon(endToXZdistance, 0.0, CesiumMath.EPSILON2)) {\n    offset = direction(start, end, offset);\n    Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\n    Cartesian3.add(end, offset, end);\n  }\n} // \"Nudge\" cartographic coordinates so start and end are on the same side of the IDL.\n// Nudge amounts are tiny, basically just an IDL flip.\n// Only used for 2D/CV.\n\n\nfunction nudgeCartographic(start, end) {\n  var absStartLon = Math.abs(start.longitude);\n  var absEndLon = Math.abs(end.longitude);\n\n  if (CesiumMath.equalsEpsilon(absStartLon, CesiumMath.PI, CesiumMath.EPSILON11)) {\n    var endSign = CesiumMath.sign(end.longitude);\n    start.longitude = endSign * (absStartLon - CesiumMath.EPSILON11);\n    return 1;\n  } else if (CesiumMath.equalsEpsilon(absEndLon, CesiumMath.PI, CesiumMath.EPSILON11)) {\n    var startSign = CesiumMath.sign(start.longitude);\n    end.longitude = startSign * (absEndLon - CesiumMath.EPSILON11);\n    return 2;\n  }\n\n  return 0;\n}\n\nvar startCartographicScratch = new Cartographic();\nvar endCartographicScratch = new Cartographic();\nvar segmentStartTopScratch = new Cartesian3();\nvar segmentEndTopScratch = new Cartesian3();\nvar segmentStartBottomScratch = new Cartesian3();\nvar segmentEndBottomScratch = new Cartesian3();\nvar segmentStartNormalScratch = new Cartesian3();\nvar segmentEndNormalScratch = new Cartesian3();\nvar getHeightCartographics = [startCartographicScratch, endCartographicScratch];\nvar getHeightRectangleScratch = new Rectangle();\nvar adjustHeightStartTopScratch = new Cartesian3();\nvar adjustHeightEndTopScratch = new Cartesian3();\nvar adjustHeightStartBottomScratch = new Cartesian3();\nvar adjustHeightEndBottomScratch = new Cartesian3();\nvar segmentStart2DScratch = new Cartesian3();\nvar segmentEnd2DScratch = new Cartesian3();\nvar segmentStartNormal2DScratch = new Cartesian3();\nvar segmentEndNormal2DScratch = new Cartesian3();\nvar offsetScratch = new Cartesian3();\nvar startUpScratch = new Cartesian3();\nvar endUpScratch = new Cartesian3();\nvar rightScratch = new Cartesian3();\nvar startPlaneNormalScratch = new Cartesian3();\nvar endPlaneNormalScratch = new Cartesian3();\nvar encodeScratch = new EncodedCartesian3();\nvar encodeScratch2D = new EncodedCartesian3();\nvar forwardOffset2DScratch = new Cartesian3();\nvar right2DScratch = new Cartesian3();\nvar normalNudgeScratch = new Cartesian3();\nvar scratchBoundingSpheres = [new BoundingSphere(), new BoundingSphere()]; // Winding order is reversed so each segment's volume is inside-out\n\nvar REFERENCE_INDICES = [0, 2, 1, 0, 3, 2, // right\n0, 7, 3, 0, 4, 7, // start\n0, 5, 4, 0, 1, 5, // bottom\n5, 7, 4, 5, 6, 7, // left\n5, 2, 6, 5, 1, 2, // end\n3, 6, 2, 3, 7, 6 // top\n];\nvar REFERENCE_INDICES_LENGTH = REFERENCE_INDICES.length; // Decompose the \"wall\" into a series of shadow volumes.\n// Each shadow volume's vertices encode a description of the line it contains,\n// including mitering planes at the end points, a plane along the line itself,\n// and attributes for computing length-wise texture coordinates.\n\nfunction generateGeometryAttributes(loop, projection, bottomPositionsArray, topPositionsArray, normalsArray, cartographicsArray, compute2dAttributes) {\n  var i;\n  var index;\n  var ellipsoid = projection._ellipsoid; // Each segment will have 8 vertices\n\n  var segmentCount = bottomPositionsArray.length / 3 - 1;\n  var vertexCount = segmentCount * 8;\n  var arraySizeVec4 = vertexCount * 4;\n  var indexCount = segmentCount * 36;\n  var indices = vertexCount > 65535 ? new Uint32Array(indexCount) : new Uint16Array(indexCount);\n  var positionsArray = new Float64Array(vertexCount * 3);\n  var startHiAndForwardOffsetX = new Float32Array(arraySizeVec4);\n  var startLoAndForwardOffsetY = new Float32Array(arraySizeVec4);\n  var startNormalAndForwardOffsetZ = new Float32Array(arraySizeVec4);\n  var endNormalAndTextureCoordinateNormalizationX = new Float32Array(arraySizeVec4);\n  var rightNormalAndTextureCoordinateNormalizationY = new Float32Array(arraySizeVec4);\n  var startHiLo2D;\n  var offsetAndRight2D;\n  var startEndNormals2D;\n  var texcoordNormalization2D;\n\n  if (compute2dAttributes) {\n    startHiLo2D = new Float32Array(arraySizeVec4);\n    offsetAndRight2D = new Float32Array(arraySizeVec4);\n    startEndNormals2D = new Float32Array(arraySizeVec4);\n    texcoordNormalization2D = new Float32Array(vertexCount * 2);\n  }\n  /*** Compute total lengths for texture coordinate normalization ***/\n  // 2D\n\n\n  var cartographicsLength = cartographicsArray.length / 2;\n  var length2D = 0.0;\n  var startCartographic = startCartographicScratch;\n  startCartographic.height = 0.0;\n  var endCartographic = endCartographicScratch;\n  endCartographic.height = 0.0;\n  var segmentStartCartesian = segmentStartTopScratch;\n  var segmentEndCartesian = segmentEndTopScratch;\n\n  if (compute2dAttributes) {\n    index = 0;\n\n    for (i = 1; i < cartographicsLength; i++) {\n      // Don't clone anything from previous segment b/c possible IDL touch\n      startCartographic.latitude = cartographicsArray[index];\n      startCartographic.longitude = cartographicsArray[index + 1];\n      endCartographic.latitude = cartographicsArray[index + 2];\n      endCartographic.longitude = cartographicsArray[index + 3];\n      segmentStartCartesian = projection.project(startCartographic, segmentStartCartesian);\n      segmentEndCartesian = projection.project(endCartographic, segmentEndCartesian);\n      length2D += Cartesian3.distance(segmentStartCartesian, segmentEndCartesian);\n      index += 2;\n    }\n  } // 3D\n\n\n  var positionsLength = topPositionsArray.length / 3;\n  segmentEndCartesian = Cartesian3.unpack(topPositionsArray, 0, segmentEndCartesian);\n  var length3D = 0.0;\n  index = 3;\n\n  for (i = 1; i < positionsLength; i++) {\n    segmentStartCartesian = Cartesian3.clone(segmentEndCartesian, segmentStartCartesian);\n    segmentEndCartesian = Cartesian3.unpack(topPositionsArray, index, segmentEndCartesian);\n    length3D += Cartesian3.distance(segmentStartCartesian, segmentEndCartesian);\n    index += 3;\n  }\n  /*** Generate segments ***/\n\n\n  var j;\n  index = 3;\n  var cartographicsIndex = 0;\n  var vec2sWriteIndex = 0;\n  var vec3sWriteIndex = 0;\n  var vec4sWriteIndex = 0;\n  var miterBroken = false;\n  var endBottom = Cartesian3.unpack(bottomPositionsArray, 0, segmentEndBottomScratch);\n  var endTop = Cartesian3.unpack(topPositionsArray, 0, segmentEndTopScratch);\n  var endGeometryNormal = Cartesian3.unpack(normalsArray, 0, segmentEndNormalScratch);\n\n  if (loop) {\n    var preEndBottom = Cartesian3.unpack(bottomPositionsArray, bottomPositionsArray.length - 6, segmentStartBottomScratch);\n\n    if (breakMiter(endGeometryNormal, preEndBottom, endBottom, endTop)) {\n      // Miter broken as if for the last point in the loop, needs to be inverted for first point (clone of endBottom)\n      endGeometryNormal = Cartesian3.negate(endGeometryNormal, endGeometryNormal);\n    }\n  }\n\n  var lengthSoFar3D = 0.0;\n  var lengthSoFar2D = 0.0; // For translating bounding volume\n\n  var sumHeights = 0.0;\n\n  for (i = 0; i < segmentCount; i++) {\n    var startBottom = Cartesian3.clone(endBottom, segmentStartBottomScratch);\n    var startTop = Cartesian3.clone(endTop, segmentStartTopScratch);\n    var startGeometryNormal = Cartesian3.clone(endGeometryNormal, segmentStartNormalScratch);\n\n    if (miterBroken) {\n      startGeometryNormal = Cartesian3.negate(startGeometryNormal, startGeometryNormal);\n    }\n\n    endBottom = Cartesian3.unpack(bottomPositionsArray, index, segmentEndBottomScratch);\n    endTop = Cartesian3.unpack(topPositionsArray, index, segmentEndTopScratch);\n    endGeometryNormal = Cartesian3.unpack(normalsArray, index, segmentEndNormalScratch);\n    miterBroken = breakMiter(endGeometryNormal, startBottom, endBottom, endTop); // 2D - don't clone anything from previous segment b/c possible IDL touch\n\n    startCartographic.latitude = cartographicsArray[cartographicsIndex];\n    startCartographic.longitude = cartographicsArray[cartographicsIndex + 1];\n    endCartographic.latitude = cartographicsArray[cartographicsIndex + 2];\n    endCartographic.longitude = cartographicsArray[cartographicsIndex + 3];\n    var start2D;\n    var end2D;\n    var startGeometryNormal2D;\n    var endGeometryNormal2D;\n\n    if (compute2dAttributes) {\n      var nudgeResult = nudgeCartographic(startCartographic, endCartographic);\n      start2D = projection.project(startCartographic, segmentStart2DScratch);\n      end2D = projection.project(endCartographic, segmentEnd2DScratch);\n      var direction2D = direction(end2D, start2D, forwardOffset2DScratch);\n      direction2D.y = Math.abs(direction2D.y);\n      startGeometryNormal2D = segmentStartNormal2DScratch;\n      endGeometryNormal2D = segmentEndNormal2DScratch;\n\n      if (nudgeResult === 0 || Cartesian3.dot(direction2D, Cartesian3.UNIT_Y) > MITER_BREAK_SMALL) {\n        // No nudge - project the original normal\n        // Or, if the line's angle relative to the IDL is very acute,\n        // in which case snapping will produce oddly shaped volumes.\n        startGeometryNormal2D = projectNormal(projection, startCartographic, startGeometryNormal, start2D, segmentStartNormal2DScratch);\n        endGeometryNormal2D = projectNormal(projection, endCartographic, endGeometryNormal, end2D, segmentEndNormal2DScratch);\n      } else if (nudgeResult === 1) {\n        // Start is close to IDL - snap start normal to align with IDL\n        endGeometryNormal2D = projectNormal(projection, endCartographic, endGeometryNormal, end2D, segmentEndNormal2DScratch);\n        startGeometryNormal2D.x = 0.0; // If start longitude is negative and end longitude is less negative, relative right is unit -Y\n        // If start longitude is positive and end longitude is less positive, relative right is unit +Y\n\n        startGeometryNormal2D.y = CesiumMath.sign(startCartographic.longitude - Math.abs(endCartographic.longitude));\n        startGeometryNormal2D.z = 0.0;\n      } else {\n        // End is close to IDL - snap end normal to align with IDL\n        startGeometryNormal2D = projectNormal(projection, startCartographic, startGeometryNormal, start2D, segmentStartNormal2DScratch);\n        endGeometryNormal2D.x = 0.0; // If end longitude is negative and start longitude is less negative, relative right is unit Y\n        // If end longitude is positive and start longitude is less positive, relative right is unit -Y\n\n        endGeometryNormal2D.y = CesiumMath.sign(startCartographic.longitude - endCartographic.longitude);\n        endGeometryNormal2D.z = 0.0;\n      }\n    }\n    /****************************************\n     * Geometry descriptors of a \"line on terrain,\"\n     * as opposed to the \"shadow volume used to draw\n     * the line on terrain\":\n     * - position of start + offset to end\n     * - start, end, and right-facing planes\n     * - encoded texture coordinate offsets\n     ****************************************/\n\n    /** 3D **/\n\n\n    var segmentLength3D = Cartesian3.distance(startTop, endTop);\n    var encodedStart = EncodedCartesian3.fromCartesian(startBottom, encodeScratch);\n    var forwardOffset = Cartesian3.subtract(endBottom, startBottom, offsetScratch);\n    var forward = Cartesian3.normalize(forwardOffset, rightScratch);\n    var startUp = Cartesian3.subtract(startTop, startBottom, startUpScratch);\n    startUp = Cartesian3.normalize(startUp, startUp);\n    var rightNormal = Cartesian3.cross(forward, startUp, rightScratch);\n    rightNormal = Cartesian3.normalize(rightNormal, rightNormal);\n    var startPlaneNormal = Cartesian3.cross(startUp, startGeometryNormal, startPlaneNormalScratch);\n    startPlaneNormal = Cartesian3.normalize(startPlaneNormal, startPlaneNormal);\n    var endUp = Cartesian3.subtract(endTop, endBottom, endUpScratch);\n    endUp = Cartesian3.normalize(endUp, endUp);\n    var endPlaneNormal = Cartesian3.cross(endGeometryNormal, endUp, endPlaneNormalScratch);\n    endPlaneNormal = Cartesian3.normalize(endPlaneNormal, endPlaneNormal);\n    var texcoordNormalization3DX = segmentLength3D / length3D;\n    var texcoordNormalization3DY = lengthSoFar3D / length3D;\n    /** 2D **/\n\n    var segmentLength2D = 0.0;\n    var encodedStart2D;\n    var forwardOffset2D;\n    var right2D;\n    var texcoordNormalization2DX = 0.0;\n    var texcoordNormalization2DY = 0.0;\n\n    if (compute2dAttributes) {\n      segmentLength2D = Cartesian3.distance(start2D, end2D);\n      encodedStart2D = EncodedCartesian3.fromCartesian(start2D, encodeScratch2D);\n      forwardOffset2D = Cartesian3.subtract(end2D, start2D, forwardOffset2DScratch); // Right direction is just forward direction rotated by -90 degrees around Z\n      // Similarly with plane normals\n\n      right2D = Cartesian3.normalize(forwardOffset2D, right2DScratch);\n      var swap = right2D.x;\n      right2D.x = right2D.y;\n      right2D.y = -swap;\n      texcoordNormalization2DX = segmentLength2D / length2D;\n      texcoordNormalization2DY = lengthSoFar2D / length2D;\n    }\n    /** Pack **/\n\n\n    for (j = 0; j < 8; j++) {\n      var vec4Index = vec4sWriteIndex + j * 4;\n      var vec2Index = vec2sWriteIndex + j * 2;\n      var wIndex = vec4Index + 3; // Encode sidedness of vertex relative to right plane in texture coordinate normalization X,\n      // whether vertex is top or bottom of volume in sign/magnitude of normalization Y.\n\n      var rightPlaneSide = j < 4 ? 1.0 : -1.0;\n      var topBottomSide = j === 2 || j === 3 || j === 6 || j === 7 ? 1.0 : -1.0; // 3D\n\n      Cartesian3.pack(encodedStart.high, startHiAndForwardOffsetX, vec4Index);\n      startHiAndForwardOffsetX[wIndex] = forwardOffset.x;\n      Cartesian3.pack(encodedStart.low, startLoAndForwardOffsetY, vec4Index);\n      startLoAndForwardOffsetY[wIndex] = forwardOffset.y;\n      Cartesian3.pack(startPlaneNormal, startNormalAndForwardOffsetZ, vec4Index);\n      startNormalAndForwardOffsetZ[wIndex] = forwardOffset.z;\n      Cartesian3.pack(endPlaneNormal, endNormalAndTextureCoordinateNormalizationX, vec4Index);\n      endNormalAndTextureCoordinateNormalizationX[wIndex] = texcoordNormalization3DX * rightPlaneSide;\n      Cartesian3.pack(rightNormal, rightNormalAndTextureCoordinateNormalizationY, vec4Index);\n      var texcoordNormalization = texcoordNormalization3DY * topBottomSide;\n\n      if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\n        texcoordNormalization = 9.0; // some value greater than 1.0\n      }\n\n      rightNormalAndTextureCoordinateNormalizationY[wIndex] = texcoordNormalization; // 2D\n\n      if (compute2dAttributes) {\n        startHiLo2D[vec4Index] = encodedStart2D.high.x;\n        startHiLo2D[vec4Index + 1] = encodedStart2D.high.y;\n        startHiLo2D[vec4Index + 2] = encodedStart2D.low.x;\n        startHiLo2D[vec4Index + 3] = encodedStart2D.low.y;\n        startEndNormals2D[vec4Index] = -startGeometryNormal2D.y;\n        startEndNormals2D[vec4Index + 1] = startGeometryNormal2D.x;\n        startEndNormals2D[vec4Index + 2] = endGeometryNormal2D.y;\n        startEndNormals2D[vec4Index + 3] = -endGeometryNormal2D.x;\n        offsetAndRight2D[vec4Index] = forwardOffset2D.x;\n        offsetAndRight2D[vec4Index + 1] = forwardOffset2D.y;\n        offsetAndRight2D[vec4Index + 2] = right2D.x;\n        offsetAndRight2D[vec4Index + 3] = right2D.y;\n        texcoordNormalization2D[vec2Index] = texcoordNormalization2DX * rightPlaneSide;\n        texcoordNormalization = texcoordNormalization2DY * topBottomSide;\n\n        if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\n          texcoordNormalization = 9.0; // some value greater than 1.0\n        }\n\n        texcoordNormalization2D[vec2Index + 1] = texcoordNormalization;\n      }\n    } // Adjust height of volume in 3D\n\n\n    var adjustHeightStartBottom = adjustHeightStartBottomScratch;\n    var adjustHeightEndBottom = adjustHeightEndBottomScratch;\n    var adjustHeightStartTop = adjustHeightStartTopScratch;\n    var adjustHeightEndTop = adjustHeightEndTopScratch;\n    var getHeightsRectangle = Rectangle.fromCartographicArray(getHeightCartographics, getHeightRectangleScratch);\n    var minMaxHeights = ApproximateTerrainHeights.getMinimumMaximumHeights(getHeightsRectangle, ellipsoid);\n    var minHeight = minMaxHeights.minimumTerrainHeight;\n    var maxHeight = minMaxHeights.maximumTerrainHeight;\n    sumHeights += minHeight;\n    sumHeights += maxHeight;\n    adjustHeights(startBottom, startTop, minHeight, maxHeight, adjustHeightStartBottom, adjustHeightStartTop);\n    adjustHeights(endBottom, endTop, minHeight, maxHeight, adjustHeightEndBottom, adjustHeightEndTop); // Nudge the positions away from the \"polyline\" a little bit to prevent errors in GeometryPipeline\n\n    var normalNudge = Cartesian3.multiplyByScalar(rightNormal, CesiumMath.EPSILON5, normalNudgeScratch);\n    Cartesian3.add(adjustHeightStartBottom, normalNudge, adjustHeightStartBottom);\n    Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\n    Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\n    Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop); // If the segment is very close to the XZ plane, nudge the vertices slightly to avoid touching it.\n\n    nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\n    nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\n    Cartesian3.pack(adjustHeightStartBottom, positionsArray, vec3sWriteIndex);\n    Cartesian3.pack(adjustHeightEndBottom, positionsArray, vec3sWriteIndex + 3);\n    Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 6);\n    Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 9);\n    normalNudge = Cartesian3.multiplyByScalar(rightNormal, -2.0 * CesiumMath.EPSILON5, normalNudgeScratch);\n    Cartesian3.add(adjustHeightStartBottom, normalNudge, adjustHeightStartBottom);\n    Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\n    Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\n    Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\n    nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\n    nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\n    Cartesian3.pack(adjustHeightStartBottom, positionsArray, vec3sWriteIndex + 12);\n    Cartesian3.pack(adjustHeightEndBottom, positionsArray, vec3sWriteIndex + 15);\n    Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 18);\n    Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 21);\n    cartographicsIndex += 2;\n    index += 3;\n    vec2sWriteIndex += 16;\n    vec3sWriteIndex += 24;\n    vec4sWriteIndex += 32;\n    lengthSoFar3D += segmentLength3D;\n    lengthSoFar2D += segmentLength2D;\n  }\n\n  index = 0;\n  var indexOffset = 0;\n\n  for (i = 0; i < segmentCount; i++) {\n    for (j = 0; j < REFERENCE_INDICES_LENGTH; j++) {\n      indices[index + j] = REFERENCE_INDICES[j] + indexOffset;\n    }\n\n    indexOffset += 8;\n    index += REFERENCE_INDICES_LENGTH;\n  }\n\n  var boundingSpheres = scratchBoundingSpheres;\n  BoundingSphere.fromVertices(bottomPositionsArray, Cartesian3.ZERO, 3, boundingSpheres[0]);\n  BoundingSphere.fromVertices(topPositionsArray, Cartesian3.ZERO, 3, boundingSpheres[1]);\n  var boundingSphere = BoundingSphere.fromBoundingSpheres(boundingSpheres); // Adjust bounding sphere height and radius to cover more of the volume\n\n  boundingSphere.radius += sumHeights / (segmentCount * 2.0);\n  var attributes = {\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      normalize: false,\n      values: positionsArray\n    }),\n    startHiAndForwardOffsetX: getVec4GeometryAttribute(startHiAndForwardOffsetX),\n    startLoAndForwardOffsetY: getVec4GeometryAttribute(startLoAndForwardOffsetY),\n    startNormalAndForwardOffsetZ: getVec4GeometryAttribute(startNormalAndForwardOffsetZ),\n    endNormalAndTextureCoordinateNormalizationX: getVec4GeometryAttribute(endNormalAndTextureCoordinateNormalizationX),\n    rightNormalAndTextureCoordinateNormalizationY: getVec4GeometryAttribute(rightNormalAndTextureCoordinateNormalizationY)\n  };\n\n  if (compute2dAttributes) {\n    attributes.startHiLo2D = getVec4GeometryAttribute(startHiLo2D);\n    attributes.offsetAndRight2D = getVec4GeometryAttribute(offsetAndRight2D);\n    attributes.startEndNormals2D = getVec4GeometryAttribute(startEndNormals2D);\n    attributes.texcoordNormalization2D = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      normalize: false,\n      values: texcoordNormalization2D\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    boundingSphere: boundingSphere\n  });\n}\n\nfunction getVec4GeometryAttribute(typedArray) {\n  return new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    values: typedArray\n  });\n}\n/**\n * Approximates an ellipsoid-tangent vector in 2D by projecting the end point into 2D.\n * Exposed for testing.\n *\n * @param {MapProjection} projection Map Projection for projecting coordinates to 2D.\n * @param {Cartographic} cartographic The cartographic origin point of the normal.\n *   Used to check if the normal crosses the IDL during projection.\n * @param {Cartesian3} normal The normal in 3D.\n * @param {Cartesian3} projectedPosition The projected origin point of the normal in 2D.\n * @param {Cartesian3} result Result parameter on which to store the projected normal.\n * @private\n */\n\n\nGroundPolylineGeometry._projectNormal = projectNormal;\nexport default GroundPolylineGeometry;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/GroundPolylineGeometry.js"],"names":["ApproximateTerrainHeights","ArcType","arrayRemoveDuplicates","BoundingSphere","Cartesian3","Cartographic","Check","ComponentDatatype","defaultValue","defined","DeveloperError","Ellipsoid","EllipsoidGeodesic","EllipsoidRhumbLine","EncodedCartesian3","GeographicProjection","Geometry","GeometryAttribute","IntersectionTests","CesiumMath","Matrix3","Plane","Quaternion","Rectangle","WebMercatorProjection","PROJECTIONS","PROJECTION_COUNT","length","MITER_BREAK_SMALL","Math","cos","toRadians","MITER_BREAK_LARGE","WALL_INITIAL_MIN_HEIGHT","WALL_INITIAL_MAX_HEIGHT","GroundPolylineGeometry","options","EMPTY_OBJECT","positions","arcType","GEODESIC","RHUMB","width","_positions","granularity","loop","_ellipsoid","WGS84","_projectionIndex","_workerName","_scene3DOnly","Object","defineProperties","prototype","packedLength","get","setProjectionAndEllipsoid","groundPolylineGeometry","mapProjection","projectionIndex","i","ellipsoid","cart3Scratch1","cart3Scratch2","cart3Scratch3","computeRightNormal","start","end","maxHeight","result","startBottom","getPosition","startTop","endBottom","up","direction","forward","cross","normalize","interpolatedCartographicScratch","interpolatedBottomScratch","interpolatedTopScratch","interpolatedNormalScratch","interpolateSegment","minHeight","normalsArray","bottomPositionsArray","topPositionsArray","cartographicsArray","ellipsoidLine","surfaceDistance","interpolatedNormal","segments","ceil","interpointDistance","distanceFromStart","pointsToAdd","packIndex","interpolatedCartographic","interpolateUsingSurfaceDistance","interpolatedBottom","interpolatedTop","pack","push","latitude","longitude","heightlessCartographicScratch","cartographic","height","clone","toCartesian","value","array","startingIndex","typeOf","object","index","positionsLength","cartesian","unpack","Array","scene3DOnly","target","origin","subtract","tangentDirection","toPreviousScratch","toNextScratch","forwardScratch","vertexUpScratch","cosine90","cosine180","computeVertexMiterNormal","previousBottom","vertexBottom","vertexTop","nextBottom","toPrevious","toNext","equalsEpsilon","dot","EPSILON5","add","negate","XZ_PLANE","fromPointNormal","ZERO","UNIT_Y","previousBottomScratch","vertexBottomScratch","vertexTopScratch","nextBottomScratch","vertexNormalScratch","intersectionScratch","cartographicScratch0","cartographicScratch1","cartographicIntersectionScratch","createGeometry","compute2dAttributes","projection","p0","p1","c0","c1","rhumbLine","undefined","intersection","intersectionCartographic","intersectionLongitude","splitPositions","lineSegmentPlane","EPSILON7","cartesianToCartographic","setEndPoints","findIntersectionWithLongitude","cartographicToCartesian","cartographicsLength","cartographics","fromCartesian","vertexNormal","startCartographic","nextCartographic","prestartCartographic","vertexCartographic","endCartographic","preEndCartographic","postEndCartographic","generateGeometryAttributes","lineDirectionScratch","matrix3Scratch","quaternionScratch","breakMiter","endGeometryNormal","endTop","lineDirection","vertexUp","angle","PI_OVER_TWO","quaternion","fromAxisAngle","rotationMatrix","fromQuaternion","multiplyByVector","endPosCartographicScratch","normalStartpointScratch","normalEndpointScratch","projectNormal","normal","projectedPosition","position","normalEndpoint","flipNormal","normalEndpointCartographic","abs","normalEndpointProjected","project","z","adjustHeightNormalScratch","adjustHeightOffsetScratch","adjustHeights","bottom","top","adjustHeightBottom","adjustHeightTop","adjustHeightNormal","distanceForBottom","adjustHeightOffset","multiplyByScalar","distanceForTop","nudgeDirectionScratch","nudgeXZ","startToXZdistance","getPointDistance","endToXZdistance","offset","EPSILON2","nudgeCartographic","absStartLon","absEndLon","PI","EPSILON11","endSign","sign","startSign","startCartographicScratch","endCartographicScratch","segmentStartTopScratch","segmentEndTopScratch","segmentStartBottomScratch","segmentEndBottomScratch","segmentStartNormalScratch","segmentEndNormalScratch","getHeightCartographics","getHeightRectangleScratch","adjustHeightStartTopScratch","adjustHeightEndTopScratch","adjustHeightStartBottomScratch","adjustHeightEndBottomScratch","segmentStart2DScratch","segmentEnd2DScratch","segmentStartNormal2DScratch","segmentEndNormal2DScratch","offsetScratch","startUpScratch","endUpScratch","rightScratch","startPlaneNormalScratch","endPlaneNormalScratch","encodeScratch","encodeScratch2D","forwardOffset2DScratch","right2DScratch","normalNudgeScratch","scratchBoundingSpheres","REFERENCE_INDICES","REFERENCE_INDICES_LENGTH","segmentCount","vertexCount","arraySizeVec4","indexCount","indices","Uint32Array","Uint16Array","positionsArray","Float64Array","startHiAndForwardOffsetX","Float32Array","startLoAndForwardOffsetY","startNormalAndForwardOffsetZ","endNormalAndTextureCoordinateNormalizationX","rightNormalAndTextureCoordinateNormalizationY","startHiLo2D","offsetAndRight2D","startEndNormals2D","texcoordNormalization2D","length2D","segmentStartCartesian","segmentEndCartesian","distance","length3D","j","cartographicsIndex","vec2sWriteIndex","vec3sWriteIndex","vec4sWriteIndex","miterBroken","preEndBottom","lengthSoFar3D","lengthSoFar2D","sumHeights","startGeometryNormal","start2D","end2D","startGeometryNormal2D","endGeometryNormal2D","nudgeResult","direction2D","y","x","segmentLength3D","encodedStart","forwardOffset","startUp","rightNormal","startPlaneNormal","endUp","endPlaneNormal","texcoordNormalization3DX","texcoordNormalization3DY","segmentLength2D","encodedStart2D","forwardOffset2D","right2D","texcoordNormalization2DX","texcoordNormalization2DY","swap","vec4Index","vec2Index","wIndex","rightPlaneSide","topBottomSide","high","low","texcoordNormalization","adjustHeightStartBottom","adjustHeightEndBottom","adjustHeightStartTop","adjustHeightEndTop","getHeightsRectangle","fromCartographicArray","minMaxHeights","getMinimumMaximumHeights","minimumTerrainHeight","maximumTerrainHeight","normalNudge","indexOffset","boundingSpheres","fromVertices","boundingSphere","fromBoundingSpheres","radius","attributes","componentDatatype","DOUBLE","componentsPerAttribute","values","getVec4GeometryAttribute","FLOAT","typedArray","_projectNormal"],"mappings":"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","sourcesContent":["import ApproximateTerrainHeights from \"./ApproximateTerrainHeights.js\";\nimport ArcType from \"./ArcType.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidGeodesic from \"./EllipsoidGeodesic.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport EncodedCartesian3 from \"./EncodedCartesian3.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Plane from \"./Plane.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport WebMercatorProjection from \"./WebMercatorProjection.js\";\n\nvar PROJECTIONS = [GeographicProjection, WebMercatorProjection];\nvar PROJECTION_COUNT = PROJECTIONS.length;\n\nvar MITER_BREAK_SMALL = Math.cos(CesiumMath.toRadians(30.0));\nvar MITER_BREAK_LARGE = Math.cos(CesiumMath.toRadians(150.0));\n\n// Initial heights for constructing the wall.\n// Keeping WALL_INITIAL_MIN_HEIGHT near the ellipsoid surface helps\n// prevent precision problems with planes in the shader.\n// Putting the start point of a plane at ApproximateTerrainHeights._defaultMinTerrainHeight,\n// which is a highly conservative bound, usually puts the plane origin several thousands\n// of meters away from the actual terrain, causing floating point problems when checking\n// fragments on terrain against the plane.\n// Ellipsoid height is generally much closer.\n// The initial max height is arbitrary.\n// Both heights are corrected using ApproximateTerrainHeights for computing the actual volume geometry.\nvar WALL_INITIAL_MIN_HEIGHT = 0.0;\nvar WALL_INITIAL_MAX_HEIGHT = 1000.0;\n\n/**\n * A description of a polyline on terrain or 3D Tiles. Only to be used with {@link GroundPolylinePrimitive}.\n *\n * @alias GroundPolylineGeometry\n * @constructor\n *\n * @param {Object} options Options with the following properties:\n * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the polyline's points. Heights above the ellipsoid will be ignored.\n * @param {Number} [options.width=1.0] The screen space width in pixels.\n * @param {Number} [options.granularity=9999.0] The distance interval in meters used for interpolating options.points. Defaults to 9999.0 meters. Zero indicates no interpolation.\n * @param {Boolean} [options.loop=false] Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n *\n * @exception {DeveloperError} At least two positions are required.\n *\n * @see GroundPolylinePrimitive\n *\n * @example\n * var positions = Cesium.Cartesian3.fromDegreesArray([\n *   -112.1340164450331, 36.05494287836128,\n *   -112.08821010582645, 36.097804071380715,\n *   -112.13296079730024, 36.168769146801104\n * ]);\n *\n * var geometry = new Cesium.GroundPolylineGeometry({\n *   positions : positions\n * });\n */\nfunction GroundPolylineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var positions = options.positions;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions) || positions.length < 2) {\n    throw new DeveloperError(\"At least two positions are required.\");\n  }\n  if (\n    defined(options.arcType) &&\n    options.arcType !== ArcType.GEODESIC &&\n    options.arcType !== ArcType.RHUMB\n  ) {\n    throw new DeveloperError(\n      \"Valid options for arcType are ArcType.GEODESIC and ArcType.RHUMB.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * The screen space width in pixels.\n   * @type {Number}\n   */\n  this.width = defaultValue(options.width, 1.0); // Doesn't get packed, not necessary for computing geometry.\n\n  this._positions = positions;\n\n  /**\n   * The distance interval used for interpolating options.points. Zero indicates no interpolation.\n   * Default of 9999.0 allows centimeter accuracy with 32 bit floating point.\n   * @type {Boolean}\n   * @default 9999.0\n   */\n  this.granularity = defaultValue(options.granularity, 9999.0);\n\n  /**\n   * Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\n   * If the geometry has two positions this parameter will be ignored.\n   * @type {Boolean}\n   * @default false\n   */\n  this.loop = defaultValue(options.loop, false);\n\n  /**\n   * The type of path the polyline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n   * @type {ArcType}\n   * @default ArcType.GEODESIC\n   */\n  this.arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n\n  this._ellipsoid = Ellipsoid.WGS84;\n\n  // MapProjections can't be packed, so store the index to a known MapProjection.\n  this._projectionIndex = 0;\n  this._workerName = \"createGroundPolylineGeometry\";\n\n  // Used by GroundPolylinePrimitive to signal worker that scenemode is 3D only.\n  this._scene3DOnly = false;\n}\n\nObject.defineProperties(GroundPolylineGeometry.prototype, {\n  /**\n   * The number of elements used to pack the object into an array.\n   * @memberof GroundPolylineGeometry.prototype\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  packedLength: {\n    get: function () {\n      return (\n        1.0 +\n        this._positions.length * 3 +\n        1.0 +\n        1.0 +\n        1.0 +\n        Ellipsoid.packedLength +\n        1.0 +\n        1.0\n      );\n    },\n  },\n});\n\n/**\n * Set the GroundPolylineGeometry's projection and ellipsoid.\n * Used by GroundPolylinePrimitive to signal scene information to the geometry for generating 2D attributes.\n *\n * @param {GroundPolylineGeometry} groundPolylineGeometry GroundPolylinGeometry describing a polyline on terrain or 3D Tiles.\n * @param {Projection} mapProjection A MapProjection used for projecting cartographic coordinates to 2D.\n * @private\n */\nGroundPolylineGeometry.setProjectionAndEllipsoid = function (\n  groundPolylineGeometry,\n  mapProjection\n) {\n  var projectionIndex = 0;\n  for (var i = 0; i < PROJECTION_COUNT; i++) {\n    if (mapProjection instanceof PROJECTIONS[i]) {\n      projectionIndex = i;\n      break;\n    }\n  }\n\n  groundPolylineGeometry._projectionIndex = projectionIndex;\n  groundPolylineGeometry._ellipsoid = mapProjection.ellipsoid;\n};\n\nvar cart3Scratch1 = new Cartesian3();\nvar cart3Scratch2 = new Cartesian3();\nvar cart3Scratch3 = new Cartesian3();\nfunction computeRightNormal(start, end, maxHeight, ellipsoid, result) {\n  var startBottom = getPosition(ellipsoid, start, 0.0, cart3Scratch1);\n  var startTop = getPosition(ellipsoid, start, maxHeight, cart3Scratch2);\n  var endBottom = getPosition(ellipsoid, end, 0.0, cart3Scratch3);\n\n  var up = direction(startTop, startBottom, cart3Scratch2);\n  var forward = direction(endBottom, startBottom, cart3Scratch3);\n\n  Cartesian3.cross(forward, up, result);\n  return Cartesian3.normalize(result, result);\n}\n\nvar interpolatedCartographicScratch = new Cartographic();\nvar interpolatedBottomScratch = new Cartesian3();\nvar interpolatedTopScratch = new Cartesian3();\nvar interpolatedNormalScratch = new Cartesian3();\nfunction interpolateSegment(\n  start,\n  end,\n  minHeight,\n  maxHeight,\n  granularity,\n  arcType,\n  ellipsoid,\n  normalsArray,\n  bottomPositionsArray,\n  topPositionsArray,\n  cartographicsArray\n) {\n  if (granularity === 0.0) {\n    return;\n  }\n\n  var ellipsoidLine;\n  if (arcType === ArcType.GEODESIC) {\n    ellipsoidLine = new EllipsoidGeodesic(start, end, ellipsoid);\n  } else if (arcType === ArcType.RHUMB) {\n    ellipsoidLine = new EllipsoidRhumbLine(start, end, ellipsoid);\n  }\n\n  var surfaceDistance = ellipsoidLine.surfaceDistance;\n  if (surfaceDistance < granularity) {\n    return;\n  }\n\n  // Compute rightwards normal applicable at all interpolated points\n  var interpolatedNormal = computeRightNormal(\n    start,\n    end,\n    maxHeight,\n    ellipsoid,\n    interpolatedNormalScratch\n  );\n\n  var segments = Math.ceil(surfaceDistance / granularity);\n  var interpointDistance = surfaceDistance / segments;\n  var distanceFromStart = interpointDistance;\n  var pointsToAdd = segments - 1;\n  var packIndex = normalsArray.length;\n  for (var i = 0; i < pointsToAdd; i++) {\n    var interpolatedCartographic = ellipsoidLine.interpolateUsingSurfaceDistance(\n      distanceFromStart,\n      interpolatedCartographicScratch\n    );\n    var interpolatedBottom = getPosition(\n      ellipsoid,\n      interpolatedCartographic,\n      minHeight,\n      interpolatedBottomScratch\n    );\n    var interpolatedTop = getPosition(\n      ellipsoid,\n      interpolatedCartographic,\n      maxHeight,\n      interpolatedTopScratch\n    );\n\n    Cartesian3.pack(interpolatedNormal, normalsArray, packIndex);\n    Cartesian3.pack(interpolatedBottom, bottomPositionsArray, packIndex);\n    Cartesian3.pack(interpolatedTop, topPositionsArray, packIndex);\n    cartographicsArray.push(interpolatedCartographic.latitude);\n    cartographicsArray.push(interpolatedCartographic.longitude);\n\n    packIndex += 3;\n    distanceFromStart += interpointDistance;\n  }\n}\n\nvar heightlessCartographicScratch = new Cartographic();\nfunction getPosition(ellipsoid, cartographic, height, result) {\n  Cartographic.clone(cartographic, heightlessCartographicScratch);\n  heightlessCartographicScratch.height = height;\n  return Cartographic.toCartesian(\n    heightlessCartographicScratch,\n    ellipsoid,\n    result\n  );\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolygonGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nGroundPolylineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  var index = defaultValue(startingIndex, 0);\n\n  var positions = value._positions;\n  var positionsLength = positions.length;\n\n  array[index++] = positionsLength;\n\n  for (var i = 0; i < positionsLength; ++i) {\n    var cartesian = positions[i];\n    Cartesian3.pack(cartesian, array, index);\n    index += 3;\n  }\n\n  array[index++] = value.granularity;\n  array[index++] = value.loop ? 1.0 : 0.0;\n  array[index++] = value.arcType;\n\n  Ellipsoid.pack(value._ellipsoid, array, index);\n  index += Ellipsoid.packedLength;\n\n  array[index++] = value._projectionIndex;\n  array[index++] = value._scene3DOnly ? 1.0 : 0.0;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolygonGeometry} [result] The object into which to store the result.\n */\nGroundPolylineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  var index = defaultValue(startingIndex, 0);\n  var positionsLength = array[index++];\n  var positions = new Array(positionsLength);\n\n  for (var i = 0; i < positionsLength; i++) {\n    positions[i] = Cartesian3.unpack(array, index);\n    index += 3;\n  }\n\n  var granularity = array[index++];\n  var loop = array[index++] === 1.0;\n  var arcType = array[index++];\n\n  var ellipsoid = Ellipsoid.unpack(array, index);\n  index += Ellipsoid.packedLength;\n\n  var projectionIndex = array[index++];\n  var scene3DOnly = array[index++] === 1.0;\n\n  if (!defined(result)) {\n    result = new GroundPolylineGeometry({\n      positions: positions,\n    });\n  }\n\n  result._positions = positions;\n  result.granularity = granularity;\n  result.loop = loop;\n  result.arcType = arcType;\n  result._ellipsoid = ellipsoid;\n  result._projectionIndex = projectionIndex;\n  result._scene3DOnly = scene3DOnly;\n\n  return result;\n};\n\nfunction direction(target, origin, result) {\n  Cartesian3.subtract(target, origin, result);\n  Cartesian3.normalize(result, result);\n  return result;\n}\n\nfunction tangentDirection(target, origin, up, result) {\n  result = direction(target, origin, result);\n\n  // orthogonalize\n  result = Cartesian3.cross(result, up, result);\n  result = Cartesian3.normalize(result, result);\n  result = Cartesian3.cross(up, result, result);\n  return result;\n}\n\nvar toPreviousScratch = new Cartesian3();\nvar toNextScratch = new Cartesian3();\nvar forwardScratch = new Cartesian3();\nvar vertexUpScratch = new Cartesian3();\nvar cosine90 = 0.0;\nvar cosine180 = -1.0;\nfunction computeVertexMiterNormal(\n  previousBottom,\n  vertexBottom,\n  vertexTop,\n  nextBottom,\n  result\n) {\n  var up = direction(vertexTop, vertexBottom, vertexUpScratch);\n\n  // Compute vectors pointing towards neighboring points but tangent to this point on the ellipsoid\n  var toPrevious = tangentDirection(\n    previousBottom,\n    vertexBottom,\n    up,\n    toPreviousScratch\n  );\n  var toNext = tangentDirection(nextBottom, vertexBottom, up, toNextScratch);\n\n  // Check if tangents are almost opposite - if so, no need to miter.\n  if (\n    CesiumMath.equalsEpsilon(\n      Cartesian3.dot(toPrevious, toNext),\n      cosine180,\n      CesiumMath.EPSILON5\n    )\n  ) {\n    result = Cartesian3.cross(up, toPrevious, result);\n    result = Cartesian3.normalize(result, result);\n    return result;\n  }\n\n  // Average directions to previous and to next in the plane of Up\n  result = Cartesian3.add(toNext, toPrevious, result);\n  result = Cartesian3.normalize(result, result);\n\n  // Flip the normal if it isn't pointing roughly bound right (aka if forward is pointing more \"backwards\")\n  var forward = Cartesian3.cross(up, result, forwardScratch);\n  if (Cartesian3.dot(toNext, forward) < cosine90) {\n    result = Cartesian3.negate(result, result);\n  }\n\n  return result;\n}\n\nvar XZ_PLANE = Plane.fromPointNormal(Cartesian3.ZERO, Cartesian3.UNIT_Y);\n\nvar previousBottomScratch = new Cartesian3();\nvar vertexBottomScratch = new Cartesian3();\nvar vertexTopScratch = new Cartesian3();\nvar nextBottomScratch = new Cartesian3();\nvar vertexNormalScratch = new Cartesian3();\nvar intersectionScratch = new Cartesian3();\nvar cartographicScratch0 = new Cartographic();\nvar cartographicScratch1 = new Cartographic();\nvar cartographicIntersectionScratch = new Cartographic();\n/**\n * Computes shadow volumes for the ground polyline, consisting of its vertices, indices, and a bounding sphere.\n * Vertices are \"fat,\" packing all the data needed in each volume to describe a line on terrain or 3D Tiles.\n * Should not be called independent of {@link GroundPolylinePrimitive}.\n *\n * @param {GroundPolylineGeometry} groundPolylineGeometry\n * @private\n */\nGroundPolylineGeometry.createGeometry = function (groundPolylineGeometry) {\n  var compute2dAttributes = !groundPolylineGeometry._scene3DOnly;\n  var loop = groundPolylineGeometry.loop;\n  var ellipsoid = groundPolylineGeometry._ellipsoid;\n  var granularity = groundPolylineGeometry.granularity;\n  var arcType = groundPolylineGeometry.arcType;\n  var projection = new PROJECTIONS[groundPolylineGeometry._projectionIndex](\n    ellipsoid\n  );\n\n  var minHeight = WALL_INITIAL_MIN_HEIGHT;\n  var maxHeight = WALL_INITIAL_MAX_HEIGHT;\n\n  var index;\n  var i;\n\n  var positions = groundPolylineGeometry._positions;\n  var positionsLength = positions.length;\n\n  if (positionsLength === 2) {\n    loop = false;\n  }\n\n  // Split positions across the IDL and the Prime Meridian as well.\n  // Split across prime meridian because very large geometries crossing the Prime Meridian but not the IDL\n  // may get split by the plane of IDL + Prime Meridian.\n  var p0;\n  var p1;\n  var c0;\n  var c1;\n  var rhumbLine = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  var intersection;\n  var intersectionCartographic;\n  var intersectionLongitude;\n  var splitPositions = [positions[0]];\n  for (i = 0; i < positionsLength - 1; i++) {\n    p0 = positions[i];\n    p1 = positions[i + 1];\n    intersection = IntersectionTests.lineSegmentPlane(\n      p0,\n      p1,\n      XZ_PLANE,\n      intersectionScratch\n    );\n    if (\n      defined(intersection) &&\n      !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n      !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\n    ) {\n      if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\n        splitPositions.push(Cartesian3.clone(intersection));\n      } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\n        intersectionLongitude = ellipsoid.cartesianToCartographic(\n          intersection,\n          cartographicScratch0\n        ).longitude;\n        c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\n        c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\n        rhumbLine.setEndPoints(c0, c1);\n        intersectionCartographic = rhumbLine.findIntersectionWithLongitude(\n          intersectionLongitude,\n          cartographicIntersectionScratch\n        );\n        intersection = ellipsoid.cartographicToCartesian(\n          intersectionCartographic,\n          intersectionScratch\n        );\n        if (\n          defined(intersection) &&\n          !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n          !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\n        ) {\n          splitPositions.push(Cartesian3.clone(intersection));\n        }\n      }\n    }\n    splitPositions.push(p1);\n  }\n\n  if (loop) {\n    p0 = positions[positionsLength - 1];\n    p1 = positions[0];\n    intersection = IntersectionTests.lineSegmentPlane(\n      p0,\n      p1,\n      XZ_PLANE,\n      intersectionScratch\n    );\n    if (\n      defined(intersection) &&\n      !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n      !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\n    ) {\n      if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\n        splitPositions.push(Cartesian3.clone(intersection));\n      } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\n        intersectionLongitude = ellipsoid.cartesianToCartographic(\n          intersection,\n          cartographicScratch0\n        ).longitude;\n        c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\n        c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\n        rhumbLine.setEndPoints(c0, c1);\n        intersectionCartographic = rhumbLine.findIntersectionWithLongitude(\n          intersectionLongitude,\n          cartographicIntersectionScratch\n        );\n        intersection = ellipsoid.cartographicToCartesian(\n          intersectionCartographic,\n          intersectionScratch\n        );\n        if (\n          defined(intersection) &&\n          !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n          !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\n        ) {\n          splitPositions.push(Cartesian3.clone(intersection));\n        }\n      }\n    }\n  }\n  var cartographicsLength = splitPositions.length;\n\n  var cartographics = new Array(cartographicsLength);\n  for (i = 0; i < cartographicsLength; i++) {\n    var cartographic = Cartographic.fromCartesian(splitPositions[i], ellipsoid);\n    cartographic.height = 0.0;\n    cartographics[i] = cartographic;\n  }\n\n  cartographics = arrayRemoveDuplicates(\n    cartographics,\n    Cartographic.equalsEpsilon\n  );\n  cartographicsLength = cartographics.length;\n\n  if (cartographicsLength < 2) {\n    return undefined;\n  }\n\n  /**** Build heap-side arrays for positions, interpolated cartographics, and normals from which to compute vertices ****/\n  // We build a \"wall\" and then decompose it into separately connected component \"volumes\" because we need a lot\n  // of information about the wall. Also, this simplifies interpolation.\n  // Convention: \"next\" and \"end\" are locally forward to each segment of the wall,\n  // and we are computing normals pointing towards the local right side of the vertices in each segment.\n  var cartographicsArray = [];\n  var normalsArray = [];\n  var bottomPositionsArray = [];\n  var topPositionsArray = [];\n\n  var previousBottom = previousBottomScratch;\n  var vertexBottom = vertexBottomScratch;\n  var vertexTop = vertexTopScratch;\n  var nextBottom = nextBottomScratch;\n  var vertexNormal = vertexNormalScratch;\n\n  // First point - either loop or attach a \"perpendicular\" normal\n  var startCartographic = cartographics[0];\n  var nextCartographic = cartographics[1];\n\n  var prestartCartographic = cartographics[cartographicsLength - 1];\n  previousBottom = getPosition(\n    ellipsoid,\n    prestartCartographic,\n    minHeight,\n    previousBottom\n  );\n  nextBottom = getPosition(ellipsoid, nextCartographic, minHeight, nextBottom);\n  vertexBottom = getPosition(\n    ellipsoid,\n    startCartographic,\n    minHeight,\n    vertexBottom\n  );\n  vertexTop = getPosition(ellipsoid, startCartographic, maxHeight, vertexTop);\n\n  if (loop) {\n    vertexNormal = computeVertexMiterNormal(\n      previousBottom,\n      vertexBottom,\n      vertexTop,\n      nextBottom,\n      vertexNormal\n    );\n  } else {\n    vertexNormal = computeRightNormal(\n      startCartographic,\n      nextCartographic,\n      maxHeight,\n      ellipsoid,\n      vertexNormal\n    );\n  }\n\n  Cartesian3.pack(vertexNormal, normalsArray, 0);\n  Cartesian3.pack(vertexBottom, bottomPositionsArray, 0);\n  Cartesian3.pack(vertexTop, topPositionsArray, 0);\n  cartographicsArray.push(startCartographic.latitude);\n  cartographicsArray.push(startCartographic.longitude);\n\n  interpolateSegment(\n    startCartographic,\n    nextCartographic,\n    minHeight,\n    maxHeight,\n    granularity,\n    arcType,\n    ellipsoid,\n    normalsArray,\n    bottomPositionsArray,\n    topPositionsArray,\n    cartographicsArray\n  );\n\n  // All inbetween points\n  for (i = 1; i < cartographicsLength - 1; ++i) {\n    previousBottom = Cartesian3.clone(vertexBottom, previousBottom);\n    vertexBottom = Cartesian3.clone(nextBottom, vertexBottom);\n    var vertexCartographic = cartographics[i];\n    getPosition(ellipsoid, vertexCartographic, maxHeight, vertexTop);\n    getPosition(ellipsoid, cartographics[i + 1], minHeight, nextBottom);\n\n    computeVertexMiterNormal(\n      previousBottom,\n      vertexBottom,\n      vertexTop,\n      nextBottom,\n      vertexNormal\n    );\n\n    index = normalsArray.length;\n    Cartesian3.pack(vertexNormal, normalsArray, index);\n    Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\n    Cartesian3.pack(vertexTop, topPositionsArray, index);\n    cartographicsArray.push(vertexCartographic.latitude);\n    cartographicsArray.push(vertexCartographic.longitude);\n\n    interpolateSegment(\n      cartographics[i],\n      cartographics[i + 1],\n      minHeight,\n      maxHeight,\n      granularity,\n      arcType,\n      ellipsoid,\n      normalsArray,\n      bottomPositionsArray,\n      topPositionsArray,\n      cartographicsArray\n    );\n  }\n\n  // Last point - either loop or attach a normal \"perpendicular\" to the wall.\n  var endCartographic = cartographics[cartographicsLength - 1];\n  var preEndCartographic = cartographics[cartographicsLength - 2];\n\n  vertexBottom = getPosition(\n    ellipsoid,\n    endCartographic,\n    minHeight,\n    vertexBottom\n  );\n  vertexTop = getPosition(ellipsoid, endCartographic, maxHeight, vertexTop);\n\n  if (loop) {\n    var postEndCartographic = cartographics[0];\n    previousBottom = getPosition(\n      ellipsoid,\n      preEndCartographic,\n      minHeight,\n      previousBottom\n    );\n    nextBottom = getPosition(\n      ellipsoid,\n      postEndCartographic,\n      minHeight,\n      nextBottom\n    );\n\n    vertexNormal = computeVertexMiterNormal(\n      previousBottom,\n      vertexBottom,\n      vertexTop,\n      nextBottom,\n      vertexNormal\n    );\n  } else {\n    vertexNormal = computeRightNormal(\n      preEndCartographic,\n      endCartographic,\n      maxHeight,\n      ellipsoid,\n      vertexNormal\n    );\n  }\n\n  index = normalsArray.length;\n  Cartesian3.pack(vertexNormal, normalsArray, index);\n  Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\n  Cartesian3.pack(vertexTop, topPositionsArray, index);\n  cartographicsArray.push(endCartographic.latitude);\n  cartographicsArray.push(endCartographic.longitude);\n\n  if (loop) {\n    interpolateSegment(\n      endCartographic,\n      startCartographic,\n      minHeight,\n      maxHeight,\n      granularity,\n      arcType,\n      ellipsoid,\n      normalsArray,\n      bottomPositionsArray,\n      topPositionsArray,\n      cartographicsArray\n    );\n    index = normalsArray.length;\n    for (i = 0; i < 3; ++i) {\n      normalsArray[index + i] = normalsArray[i];\n      bottomPositionsArray[index + i] = bottomPositionsArray[i];\n      topPositionsArray[index + i] = topPositionsArray[i];\n    }\n    cartographicsArray.push(startCartographic.latitude);\n    cartographicsArray.push(startCartographic.longitude);\n  }\n\n  return generateGeometryAttributes(\n    loop,\n    projection,\n    bottomPositionsArray,\n    topPositionsArray,\n    normalsArray,\n    cartographicsArray,\n    compute2dAttributes\n  );\n};\n\n// If the end normal angle is too steep compared to the direction of the line segment,\n// \"break\" the miter by rotating the normal 90 degrees around the \"up\" direction at the point\n// For ultra precision we would want to project into a plane, but in practice this is sufficient.\nvar lineDirectionScratch = new Cartesian3();\nvar matrix3Scratch = new Matrix3();\nvar quaternionScratch = new Quaternion();\nfunction breakMiter(endGeometryNormal, startBottom, endBottom, endTop) {\n  var lineDirection = direction(endBottom, startBottom, lineDirectionScratch);\n\n  var dot = Cartesian3.dot(lineDirection, endGeometryNormal);\n  if (dot > MITER_BREAK_SMALL || dot < MITER_BREAK_LARGE) {\n    var vertexUp = direction(endTop, endBottom, vertexUpScratch);\n    var angle =\n      dot < MITER_BREAK_LARGE\n        ? CesiumMath.PI_OVER_TWO\n        : -CesiumMath.PI_OVER_TWO;\n    var quaternion = Quaternion.fromAxisAngle(\n      vertexUp,\n      angle,\n      quaternionScratch\n    );\n    var rotationMatrix = Matrix3.fromQuaternion(quaternion, matrix3Scratch);\n    Matrix3.multiplyByVector(\n      rotationMatrix,\n      endGeometryNormal,\n      endGeometryNormal\n    );\n    return true;\n  }\n  return false;\n}\n\nvar endPosCartographicScratch = new Cartographic();\nvar normalStartpointScratch = new Cartesian3();\nvar normalEndpointScratch = new Cartesian3();\nfunction projectNormal(\n  projection,\n  cartographic,\n  normal,\n  projectedPosition,\n  result\n) {\n  var position = Cartographic.toCartesian(\n    cartographic,\n    projection._ellipsoid,\n    normalStartpointScratch\n  );\n  var normalEndpoint = Cartesian3.add(position, normal, normalEndpointScratch);\n  var flipNormal = false;\n\n  var ellipsoid = projection._ellipsoid;\n  var normalEndpointCartographic = ellipsoid.cartesianToCartographic(\n    normalEndpoint,\n    endPosCartographicScratch\n  );\n  // If normal crosses the IDL, go the other way and flip the result.\n  // In practice this almost never happens because the cartographic start\n  // and end points of each segment are \"nudged\" to be on the same side\n  // of the IDL and slightly away from the IDL.\n  if (\n    Math.abs(cartographic.longitude - normalEndpointCartographic.longitude) >\n    CesiumMath.PI_OVER_TWO\n  ) {\n    flipNormal = true;\n    normalEndpoint = Cartesian3.subtract(\n      position,\n      normal,\n      normalEndpointScratch\n    );\n    normalEndpointCartographic = ellipsoid.cartesianToCartographic(\n      normalEndpoint,\n      endPosCartographicScratch\n    );\n  }\n\n  normalEndpointCartographic.height = 0.0;\n  var normalEndpointProjected = projection.project(\n    normalEndpointCartographic,\n    result\n  );\n  result = Cartesian3.subtract(\n    normalEndpointProjected,\n    projectedPosition,\n    result\n  );\n  result.z = 0.0;\n  result = Cartesian3.normalize(result, result);\n  if (flipNormal) {\n    Cartesian3.negate(result, result);\n  }\n  return result;\n}\n\nvar adjustHeightNormalScratch = new Cartesian3();\nvar adjustHeightOffsetScratch = new Cartesian3();\nfunction adjustHeights(\n  bottom,\n  top,\n  minHeight,\n  maxHeight,\n  adjustHeightBottom,\n  adjustHeightTop\n) {\n  // bottom and top should be at WALL_INITIAL_MIN_HEIGHT and WALL_INITIAL_MAX_HEIGHT, respectively\n  var adjustHeightNormal = Cartesian3.subtract(\n    top,\n    bottom,\n    adjustHeightNormalScratch\n  );\n  Cartesian3.normalize(adjustHeightNormal, adjustHeightNormal);\n\n  var distanceForBottom = minHeight - WALL_INITIAL_MIN_HEIGHT;\n  var adjustHeightOffset = Cartesian3.multiplyByScalar(\n    adjustHeightNormal,\n    distanceForBottom,\n    adjustHeightOffsetScratch\n  );\n  Cartesian3.add(bottom, adjustHeightOffset, adjustHeightBottom);\n\n  var distanceForTop = maxHeight - WALL_INITIAL_MAX_HEIGHT;\n  adjustHeightOffset = Cartesian3.multiplyByScalar(\n    adjustHeightNormal,\n    distanceForTop,\n    adjustHeightOffsetScratch\n  );\n  Cartesian3.add(top, adjustHeightOffset, adjustHeightTop);\n}\n\nvar nudgeDirectionScratch = new Cartesian3();\nfunction nudgeXZ(start, end) {\n  var startToXZdistance = Plane.getPointDistance(XZ_PLANE, start);\n  var endToXZdistance = Plane.getPointDistance(XZ_PLANE, end);\n  var offset = nudgeDirectionScratch;\n  // Larger epsilon than what's used in GeometryPipeline, a centimeter in world space\n  if (CesiumMath.equalsEpsilon(startToXZdistance, 0.0, CesiumMath.EPSILON2)) {\n    offset = direction(end, start, offset);\n    Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\n    Cartesian3.add(start, offset, start);\n  } else if (\n    CesiumMath.equalsEpsilon(endToXZdistance, 0.0, CesiumMath.EPSILON2)\n  ) {\n    offset = direction(start, end, offset);\n    Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\n    Cartesian3.add(end, offset, end);\n  }\n}\n\n// \"Nudge\" cartographic coordinates so start and end are on the same side of the IDL.\n// Nudge amounts are tiny, basically just an IDL flip.\n// Only used for 2D/CV.\nfunction nudgeCartographic(start, end) {\n  var absStartLon = Math.abs(start.longitude);\n  var absEndLon = Math.abs(end.longitude);\n  if (\n    CesiumMath.equalsEpsilon(absStartLon, CesiumMath.PI, CesiumMath.EPSILON11)\n  ) {\n    var endSign = CesiumMath.sign(end.longitude);\n    start.longitude = endSign * (absStartLon - CesiumMath.EPSILON11);\n    return 1;\n  } else if (\n    CesiumMath.equalsEpsilon(absEndLon, CesiumMath.PI, CesiumMath.EPSILON11)\n  ) {\n    var startSign = CesiumMath.sign(start.longitude);\n    end.longitude = startSign * (absEndLon - CesiumMath.EPSILON11);\n    return 2;\n  }\n  return 0;\n}\n\nvar startCartographicScratch = new Cartographic();\nvar endCartographicScratch = new Cartographic();\n\nvar segmentStartTopScratch = new Cartesian3();\nvar segmentEndTopScratch = new Cartesian3();\nvar segmentStartBottomScratch = new Cartesian3();\nvar segmentEndBottomScratch = new Cartesian3();\nvar segmentStartNormalScratch = new Cartesian3();\nvar segmentEndNormalScratch = new Cartesian3();\n\nvar getHeightCartographics = [startCartographicScratch, endCartographicScratch];\nvar getHeightRectangleScratch = new Rectangle();\n\nvar adjustHeightStartTopScratch = new Cartesian3();\nvar adjustHeightEndTopScratch = new Cartesian3();\nvar adjustHeightStartBottomScratch = new Cartesian3();\nvar adjustHeightEndBottomScratch = new Cartesian3();\n\nvar segmentStart2DScratch = new Cartesian3();\nvar segmentEnd2DScratch = new Cartesian3();\nvar segmentStartNormal2DScratch = new Cartesian3();\nvar segmentEndNormal2DScratch = new Cartesian3();\n\nvar offsetScratch = new Cartesian3();\nvar startUpScratch = new Cartesian3();\nvar endUpScratch = new Cartesian3();\nvar rightScratch = new Cartesian3();\nvar startPlaneNormalScratch = new Cartesian3();\nvar endPlaneNormalScratch = new Cartesian3();\nvar encodeScratch = new EncodedCartesian3();\n\nvar encodeScratch2D = new EncodedCartesian3();\nvar forwardOffset2DScratch = new Cartesian3();\nvar right2DScratch = new Cartesian3();\n\nvar normalNudgeScratch = new Cartesian3();\n\nvar scratchBoundingSpheres = [new BoundingSphere(), new BoundingSphere()];\n\n// Winding order is reversed so each segment's volume is inside-out\nvar REFERENCE_INDICES = [\n  0,\n  2,\n  1,\n  0,\n  3,\n  2, // right\n  0,\n  7,\n  3,\n  0,\n  4,\n  7, // start\n  0,\n  5,\n  4,\n  0,\n  1,\n  5, // bottom\n  5,\n  7,\n  4,\n  5,\n  6,\n  7, // left\n  5,\n  2,\n  6,\n  5,\n  1,\n  2, // end\n  3,\n  6,\n  2,\n  3,\n  7,\n  6, // top\n];\nvar REFERENCE_INDICES_LENGTH = REFERENCE_INDICES.length;\n\n// Decompose the \"wall\" into a series of shadow volumes.\n// Each shadow volume's vertices encode a description of the line it contains,\n// including mitering planes at the end points, a plane along the line itself,\n// and attributes for computing length-wise texture coordinates.\nfunction generateGeometryAttributes(\n  loop,\n  projection,\n  bottomPositionsArray,\n  topPositionsArray,\n  normalsArray,\n  cartographicsArray,\n  compute2dAttributes\n) {\n  var i;\n  var index;\n  var ellipsoid = projection._ellipsoid;\n\n  // Each segment will have 8 vertices\n  var segmentCount = bottomPositionsArray.length / 3 - 1;\n  var vertexCount = segmentCount * 8;\n  var arraySizeVec4 = vertexCount * 4;\n  var indexCount = segmentCount * 36;\n\n  var indices =\n    vertexCount > 65535\n      ? new Uint32Array(indexCount)\n      : new Uint16Array(indexCount);\n  var positionsArray = new Float64Array(vertexCount * 3);\n\n  var startHiAndForwardOffsetX = new Float32Array(arraySizeVec4);\n  var startLoAndForwardOffsetY = new Float32Array(arraySizeVec4);\n  var startNormalAndForwardOffsetZ = new Float32Array(arraySizeVec4);\n  var endNormalAndTextureCoordinateNormalizationX = new Float32Array(\n    arraySizeVec4\n  );\n  var rightNormalAndTextureCoordinateNormalizationY = new Float32Array(\n    arraySizeVec4\n  );\n\n  var startHiLo2D;\n  var offsetAndRight2D;\n  var startEndNormals2D;\n  var texcoordNormalization2D;\n\n  if (compute2dAttributes) {\n    startHiLo2D = new Float32Array(arraySizeVec4);\n    offsetAndRight2D = new Float32Array(arraySizeVec4);\n    startEndNormals2D = new Float32Array(arraySizeVec4);\n    texcoordNormalization2D = new Float32Array(vertexCount * 2);\n  }\n\n  /*** Compute total lengths for texture coordinate normalization ***/\n  // 2D\n  var cartographicsLength = cartographicsArray.length / 2;\n  var length2D = 0.0;\n\n  var startCartographic = startCartographicScratch;\n  startCartographic.height = 0.0;\n  var endCartographic = endCartographicScratch;\n  endCartographic.height = 0.0;\n\n  var segmentStartCartesian = segmentStartTopScratch;\n  var segmentEndCartesian = segmentEndTopScratch;\n\n  if (compute2dAttributes) {\n    index = 0;\n    for (i = 1; i < cartographicsLength; i++) {\n      // Don't clone anything from previous segment b/c possible IDL touch\n      startCartographic.latitude = cartographicsArray[index];\n      startCartographic.longitude = cartographicsArray[index + 1];\n      endCartographic.latitude = cartographicsArray[index + 2];\n      endCartographic.longitude = cartographicsArray[index + 3];\n\n      segmentStartCartesian = projection.project(\n        startCartographic,\n        segmentStartCartesian\n      );\n      segmentEndCartesian = projection.project(\n        endCartographic,\n        segmentEndCartesian\n      );\n      length2D += Cartesian3.distance(\n        segmentStartCartesian,\n        segmentEndCartesian\n      );\n      index += 2;\n    }\n  }\n\n  // 3D\n  var positionsLength = topPositionsArray.length / 3;\n  segmentEndCartesian = Cartesian3.unpack(\n    topPositionsArray,\n    0,\n    segmentEndCartesian\n  );\n  var length3D = 0.0;\n\n  index = 3;\n  for (i = 1; i < positionsLength; i++) {\n    segmentStartCartesian = Cartesian3.clone(\n      segmentEndCartesian,\n      segmentStartCartesian\n    );\n    segmentEndCartesian = Cartesian3.unpack(\n      topPositionsArray,\n      index,\n      segmentEndCartesian\n    );\n    length3D += Cartesian3.distance(segmentStartCartesian, segmentEndCartesian);\n    index += 3;\n  }\n\n  /*** Generate segments ***/\n  var j;\n  index = 3;\n  var cartographicsIndex = 0;\n  var vec2sWriteIndex = 0;\n  var vec3sWriteIndex = 0;\n  var vec4sWriteIndex = 0;\n  var miterBroken = false;\n\n  var endBottom = Cartesian3.unpack(\n    bottomPositionsArray,\n    0,\n    segmentEndBottomScratch\n  );\n  var endTop = Cartesian3.unpack(topPositionsArray, 0, segmentEndTopScratch);\n  var endGeometryNormal = Cartesian3.unpack(\n    normalsArray,\n    0,\n    segmentEndNormalScratch\n  );\n\n  if (loop) {\n    var preEndBottom = Cartesian3.unpack(\n      bottomPositionsArray,\n      bottomPositionsArray.length - 6,\n      segmentStartBottomScratch\n    );\n    if (breakMiter(endGeometryNormal, preEndBottom, endBottom, endTop)) {\n      // Miter broken as if for the last point in the loop, needs to be inverted for first point (clone of endBottom)\n      endGeometryNormal = Cartesian3.negate(\n        endGeometryNormal,\n        endGeometryNormal\n      );\n    }\n  }\n\n  var lengthSoFar3D = 0.0;\n  var lengthSoFar2D = 0.0;\n\n  // For translating bounding volume\n  var sumHeights = 0.0;\n\n  for (i = 0; i < segmentCount; i++) {\n    var startBottom = Cartesian3.clone(endBottom, segmentStartBottomScratch);\n    var startTop = Cartesian3.clone(endTop, segmentStartTopScratch);\n    var startGeometryNormal = Cartesian3.clone(\n      endGeometryNormal,\n      segmentStartNormalScratch\n    );\n\n    if (miterBroken) {\n      startGeometryNormal = Cartesian3.negate(\n        startGeometryNormal,\n        startGeometryNormal\n      );\n    }\n\n    endBottom = Cartesian3.unpack(\n      bottomPositionsArray,\n      index,\n      segmentEndBottomScratch\n    );\n    endTop = Cartesian3.unpack(topPositionsArray, index, segmentEndTopScratch);\n    endGeometryNormal = Cartesian3.unpack(\n      normalsArray,\n      index,\n      segmentEndNormalScratch\n    );\n\n    miterBroken = breakMiter(endGeometryNormal, startBottom, endBottom, endTop);\n\n    // 2D - don't clone anything from previous segment b/c possible IDL touch\n    startCartographic.latitude = cartographicsArray[cartographicsIndex];\n    startCartographic.longitude = cartographicsArray[cartographicsIndex + 1];\n    endCartographic.latitude = cartographicsArray[cartographicsIndex + 2];\n    endCartographic.longitude = cartographicsArray[cartographicsIndex + 3];\n    var start2D;\n    var end2D;\n    var startGeometryNormal2D;\n    var endGeometryNormal2D;\n\n    if (compute2dAttributes) {\n      var nudgeResult = nudgeCartographic(startCartographic, endCartographic);\n      start2D = projection.project(startCartographic, segmentStart2DScratch);\n      end2D = projection.project(endCartographic, segmentEnd2DScratch);\n      var direction2D = direction(end2D, start2D, forwardOffset2DScratch);\n      direction2D.y = Math.abs(direction2D.y);\n\n      startGeometryNormal2D = segmentStartNormal2DScratch;\n      endGeometryNormal2D = segmentEndNormal2DScratch;\n      if (\n        nudgeResult === 0 ||\n        Cartesian3.dot(direction2D, Cartesian3.UNIT_Y) > MITER_BREAK_SMALL\n      ) {\n        // No nudge - project the original normal\n        // Or, if the line's angle relative to the IDL is very acute,\n        // in which case snapping will produce oddly shaped volumes.\n        startGeometryNormal2D = projectNormal(\n          projection,\n          startCartographic,\n          startGeometryNormal,\n          start2D,\n          segmentStartNormal2DScratch\n        );\n        endGeometryNormal2D = projectNormal(\n          projection,\n          endCartographic,\n          endGeometryNormal,\n          end2D,\n          segmentEndNormal2DScratch\n        );\n      } else if (nudgeResult === 1) {\n        // Start is close to IDL - snap start normal to align with IDL\n        endGeometryNormal2D = projectNormal(\n          projection,\n          endCartographic,\n          endGeometryNormal,\n          end2D,\n          segmentEndNormal2DScratch\n        );\n        startGeometryNormal2D.x = 0.0;\n        // If start longitude is negative and end longitude is less negative, relative right is unit -Y\n        // If start longitude is positive and end longitude is less positive, relative right is unit +Y\n        startGeometryNormal2D.y = CesiumMath.sign(\n          startCartographic.longitude - Math.abs(endCartographic.longitude)\n        );\n        startGeometryNormal2D.z = 0.0;\n      } else {\n        // End is close to IDL - snap end normal to align with IDL\n        startGeometryNormal2D = projectNormal(\n          projection,\n          startCartographic,\n          startGeometryNormal,\n          start2D,\n          segmentStartNormal2DScratch\n        );\n        endGeometryNormal2D.x = 0.0;\n        // If end longitude is negative and start longitude is less negative, relative right is unit Y\n        // If end longitude is positive and start longitude is less positive, relative right is unit -Y\n        endGeometryNormal2D.y = CesiumMath.sign(\n          startCartographic.longitude - endCartographic.longitude\n        );\n        endGeometryNormal2D.z = 0.0;\n      }\n    }\n\n    /****************************************\n     * Geometry descriptors of a \"line on terrain,\"\n     * as opposed to the \"shadow volume used to draw\n     * the line on terrain\":\n     * - position of start + offset to end\n     * - start, end, and right-facing planes\n     * - encoded texture coordinate offsets\n     ****************************************/\n\n    /** 3D **/\n    var segmentLength3D = Cartesian3.distance(startTop, endTop);\n\n    var encodedStart = EncodedCartesian3.fromCartesian(\n      startBottom,\n      encodeScratch\n    );\n    var forwardOffset = Cartesian3.subtract(\n      endBottom,\n      startBottom,\n      offsetScratch\n    );\n    var forward = Cartesian3.normalize(forwardOffset, rightScratch);\n\n    var startUp = Cartesian3.subtract(startTop, startBottom, startUpScratch);\n    startUp = Cartesian3.normalize(startUp, startUp);\n    var rightNormal = Cartesian3.cross(forward, startUp, rightScratch);\n    rightNormal = Cartesian3.normalize(rightNormal, rightNormal);\n\n    var startPlaneNormal = Cartesian3.cross(\n      startUp,\n      startGeometryNormal,\n      startPlaneNormalScratch\n    );\n    startPlaneNormal = Cartesian3.normalize(startPlaneNormal, startPlaneNormal);\n\n    var endUp = Cartesian3.subtract(endTop, endBottom, endUpScratch);\n    endUp = Cartesian3.normalize(endUp, endUp);\n    var endPlaneNormal = Cartesian3.cross(\n      endGeometryNormal,\n      endUp,\n      endPlaneNormalScratch\n    );\n    endPlaneNormal = Cartesian3.normalize(endPlaneNormal, endPlaneNormal);\n\n    var texcoordNormalization3DX = segmentLength3D / length3D;\n    var texcoordNormalization3DY = lengthSoFar3D / length3D;\n\n    /** 2D **/\n    var segmentLength2D = 0.0;\n    var encodedStart2D;\n    var forwardOffset2D;\n    var right2D;\n    var texcoordNormalization2DX = 0.0;\n    var texcoordNormalization2DY = 0.0;\n    if (compute2dAttributes) {\n      segmentLength2D = Cartesian3.distance(start2D, end2D);\n\n      encodedStart2D = EncodedCartesian3.fromCartesian(\n        start2D,\n        encodeScratch2D\n      );\n      forwardOffset2D = Cartesian3.subtract(\n        end2D,\n        start2D,\n        forwardOffset2DScratch\n      );\n\n      // Right direction is just forward direction rotated by -90 degrees around Z\n      // Similarly with plane normals\n      right2D = Cartesian3.normalize(forwardOffset2D, right2DScratch);\n      var swap = right2D.x;\n      right2D.x = right2D.y;\n      right2D.y = -swap;\n\n      texcoordNormalization2DX = segmentLength2D / length2D;\n      texcoordNormalization2DY = lengthSoFar2D / length2D;\n    }\n    /** Pack **/\n    for (j = 0; j < 8; j++) {\n      var vec4Index = vec4sWriteIndex + j * 4;\n      var vec2Index = vec2sWriteIndex + j * 2;\n      var wIndex = vec4Index + 3;\n\n      // Encode sidedness of vertex relative to right plane in texture coordinate normalization X,\n      // whether vertex is top or bottom of volume in sign/magnitude of normalization Y.\n      var rightPlaneSide = j < 4 ? 1.0 : -1.0;\n      var topBottomSide = j === 2 || j === 3 || j === 6 || j === 7 ? 1.0 : -1.0;\n\n      // 3D\n      Cartesian3.pack(encodedStart.high, startHiAndForwardOffsetX, vec4Index);\n      startHiAndForwardOffsetX[wIndex] = forwardOffset.x;\n\n      Cartesian3.pack(encodedStart.low, startLoAndForwardOffsetY, vec4Index);\n      startLoAndForwardOffsetY[wIndex] = forwardOffset.y;\n\n      Cartesian3.pack(\n        startPlaneNormal,\n        startNormalAndForwardOffsetZ,\n        vec4Index\n      );\n      startNormalAndForwardOffsetZ[wIndex] = forwardOffset.z;\n\n      Cartesian3.pack(\n        endPlaneNormal,\n        endNormalAndTextureCoordinateNormalizationX,\n        vec4Index\n      );\n      endNormalAndTextureCoordinateNormalizationX[wIndex] =\n        texcoordNormalization3DX * rightPlaneSide;\n\n      Cartesian3.pack(\n        rightNormal,\n        rightNormalAndTextureCoordinateNormalizationY,\n        vec4Index\n      );\n\n      var texcoordNormalization = texcoordNormalization3DY * topBottomSide;\n      if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\n        texcoordNormalization = 9.0; // some value greater than 1.0\n      }\n      rightNormalAndTextureCoordinateNormalizationY[\n        wIndex\n      ] = texcoordNormalization;\n\n      // 2D\n      if (compute2dAttributes) {\n        startHiLo2D[vec4Index] = encodedStart2D.high.x;\n        startHiLo2D[vec4Index + 1] = encodedStart2D.high.y;\n        startHiLo2D[vec4Index + 2] = encodedStart2D.low.x;\n        startHiLo2D[vec4Index + 3] = encodedStart2D.low.y;\n\n        startEndNormals2D[vec4Index] = -startGeometryNormal2D.y;\n        startEndNormals2D[vec4Index + 1] = startGeometryNormal2D.x;\n        startEndNormals2D[vec4Index + 2] = endGeometryNormal2D.y;\n        startEndNormals2D[vec4Index + 3] = -endGeometryNormal2D.x;\n\n        offsetAndRight2D[vec4Index] = forwardOffset2D.x;\n        offsetAndRight2D[vec4Index + 1] = forwardOffset2D.y;\n        offsetAndRight2D[vec4Index + 2] = right2D.x;\n        offsetAndRight2D[vec4Index + 3] = right2D.y;\n\n        texcoordNormalization2D[vec2Index] =\n          texcoordNormalization2DX * rightPlaneSide;\n\n        texcoordNormalization = texcoordNormalization2DY * topBottomSide;\n        if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\n          texcoordNormalization = 9.0; // some value greater than 1.0\n        }\n        texcoordNormalization2D[vec2Index + 1] = texcoordNormalization;\n      }\n    }\n\n    // Adjust height of volume in 3D\n    var adjustHeightStartBottom = adjustHeightStartBottomScratch;\n    var adjustHeightEndBottom = adjustHeightEndBottomScratch;\n    var adjustHeightStartTop = adjustHeightStartTopScratch;\n    var adjustHeightEndTop = adjustHeightEndTopScratch;\n\n    var getHeightsRectangle = Rectangle.fromCartographicArray(\n      getHeightCartographics,\n      getHeightRectangleScratch\n    );\n    var minMaxHeights = ApproximateTerrainHeights.getMinimumMaximumHeights(\n      getHeightsRectangle,\n      ellipsoid\n    );\n    var minHeight = minMaxHeights.minimumTerrainHeight;\n    var maxHeight = minMaxHeights.maximumTerrainHeight;\n\n    sumHeights += minHeight;\n    sumHeights += maxHeight;\n\n    adjustHeights(\n      startBottom,\n      startTop,\n      minHeight,\n      maxHeight,\n      adjustHeightStartBottom,\n      adjustHeightStartTop\n    );\n    adjustHeights(\n      endBottom,\n      endTop,\n      minHeight,\n      maxHeight,\n      adjustHeightEndBottom,\n      adjustHeightEndTop\n    );\n\n    // Nudge the positions away from the \"polyline\" a little bit to prevent errors in GeometryPipeline\n    var normalNudge = Cartesian3.multiplyByScalar(\n      rightNormal,\n      CesiumMath.EPSILON5,\n      normalNudgeScratch\n    );\n    Cartesian3.add(\n      adjustHeightStartBottom,\n      normalNudge,\n      adjustHeightStartBottom\n    );\n    Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\n    Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\n    Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\n\n    // If the segment is very close to the XZ plane, nudge the vertices slightly to avoid touching it.\n    nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\n    nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\n\n    Cartesian3.pack(adjustHeightStartBottom, positionsArray, vec3sWriteIndex);\n    Cartesian3.pack(adjustHeightEndBottom, positionsArray, vec3sWriteIndex + 3);\n    Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 6);\n    Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 9);\n\n    normalNudge = Cartesian3.multiplyByScalar(\n      rightNormal,\n      -2.0 * CesiumMath.EPSILON5,\n      normalNudgeScratch\n    );\n    Cartesian3.add(\n      adjustHeightStartBottom,\n      normalNudge,\n      adjustHeightStartBottom\n    );\n    Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\n    Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\n    Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\n\n    nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\n    nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\n\n    Cartesian3.pack(\n      adjustHeightStartBottom,\n      positionsArray,\n      vec3sWriteIndex + 12\n    );\n    Cartesian3.pack(\n      adjustHeightEndBottom,\n      positionsArray,\n      vec3sWriteIndex + 15\n    );\n    Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 18);\n    Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 21);\n\n    cartographicsIndex += 2;\n    index += 3;\n\n    vec2sWriteIndex += 16;\n    vec3sWriteIndex += 24;\n    vec4sWriteIndex += 32;\n\n    lengthSoFar3D += segmentLength3D;\n    lengthSoFar2D += segmentLength2D;\n  }\n\n  index = 0;\n  var indexOffset = 0;\n  for (i = 0; i < segmentCount; i++) {\n    for (j = 0; j < REFERENCE_INDICES_LENGTH; j++) {\n      indices[index + j] = REFERENCE_INDICES[j] + indexOffset;\n    }\n    indexOffset += 8;\n    index += REFERENCE_INDICES_LENGTH;\n  }\n\n  var boundingSpheres = scratchBoundingSpheres;\n  BoundingSphere.fromVertices(\n    bottomPositionsArray,\n    Cartesian3.ZERO,\n    3,\n    boundingSpheres[0]\n  );\n  BoundingSphere.fromVertices(\n    topPositionsArray,\n    Cartesian3.ZERO,\n    3,\n    boundingSpheres[1]\n  );\n  var boundingSphere = BoundingSphere.fromBoundingSpheres(boundingSpheres);\n\n  // Adjust bounding sphere height and radius to cover more of the volume\n  boundingSphere.radius += sumHeights / (segmentCount * 2.0);\n\n  var attributes = {\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      normalize: false,\n      values: positionsArray,\n    }),\n    startHiAndForwardOffsetX: getVec4GeometryAttribute(\n      startHiAndForwardOffsetX\n    ),\n    startLoAndForwardOffsetY: getVec4GeometryAttribute(\n      startLoAndForwardOffsetY\n    ),\n    startNormalAndForwardOffsetZ: getVec4GeometryAttribute(\n      startNormalAndForwardOffsetZ\n    ),\n    endNormalAndTextureCoordinateNormalizationX: getVec4GeometryAttribute(\n      endNormalAndTextureCoordinateNormalizationX\n    ),\n    rightNormalAndTextureCoordinateNormalizationY: getVec4GeometryAttribute(\n      rightNormalAndTextureCoordinateNormalizationY\n    ),\n  };\n\n  if (compute2dAttributes) {\n    attributes.startHiLo2D = getVec4GeometryAttribute(startHiLo2D);\n    attributes.offsetAndRight2D = getVec4GeometryAttribute(offsetAndRight2D);\n    attributes.startEndNormals2D = getVec4GeometryAttribute(startEndNormals2D);\n    attributes.texcoordNormalization2D = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      normalize: false,\n      values: texcoordNormalization2D,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    boundingSphere: boundingSphere,\n  });\n}\n\nfunction getVec4GeometryAttribute(typedArray) {\n  return new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    values: typedArray,\n  });\n}\n\n/**\n * Approximates an ellipsoid-tangent vector in 2D by projecting the end point into 2D.\n * Exposed for testing.\n *\n * @param {MapProjection} projection Map Projection for projecting coordinates to 2D.\n * @param {Cartographic} cartographic The cartographic origin point of the normal.\n *   Used to check if the normal crosses the IDL during projection.\n * @param {Cartesian3} normal The normal in 3D.\n * @param {Cartesian3} projectedPosition The projected origin point of the normal in 2D.\n * @param {Cartesian3} result Result parameter on which to store the projected normal.\n * @private\n */\nGroundPolylineGeometry._projectNormal = projectNormal;\nexport default GroundPolylineGeometry;\n"]},"metadata":{},"sourceType":"module"}