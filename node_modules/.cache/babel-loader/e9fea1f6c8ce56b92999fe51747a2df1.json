{"ast":null,"code":"import ForEach from './ForEach.js';\nimport hasExtension from './hasExtension.js';\nimport defaultValue from '../../Core/defaultValue.js';\nimport defined from '../../Core/defined.js';\nvar allElementTypes = ['mesh', 'node', 'material', 'accessor', 'bufferView', 'buffer'];\n/**\n * Removes unused elements from gltf.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @param {String[]} [elementTypes=['mesh', 'node', 'material', 'accessor', 'bufferView', 'buffer']] Element types to be removed. Needs to be a subset of ['mesh', 'node', 'material', 'accessor', 'bufferView', 'buffer'], other items will be ignored.\n *\n * @private\n */\n\nfunction removeUnusedElements(gltf, elementTypes) {\n  elementTypes = defaultValue(elementTypes, allElementTypes);\n  allElementTypes.forEach(function (type) {\n    if (elementTypes.indexOf(type) > -1) {\n      removeUnusedElementsByType(gltf, type);\n    }\n  });\n  return gltf;\n}\n\nvar TypeToGltfElementName = {\n  accessor: 'accessors',\n  buffer: 'buffers',\n  bufferView: 'bufferViews',\n  node: 'nodes',\n  material: 'materials',\n  mesh: 'meshes'\n};\n\nfunction removeUnusedElementsByType(gltf, type) {\n  var name = TypeToGltfElementName[type];\n  var arrayOfObjects = gltf[name];\n\n  if (defined(arrayOfObjects)) {\n    var removed = 0;\n    var usedIds = getListOfElementsIdsInUse[type](gltf);\n    var length = arrayOfObjects.length;\n\n    for (var i = 0; i < length; ++i) {\n      if (!usedIds[i]) {\n        Remove[type](gltf, i - removed);\n        removed++;\n      }\n    }\n  }\n}\n/**\n * Contains functions for removing elements from a glTF hierarchy.\n * Since top-level glTF elements are arrays, when something is removed, referring\n * indices need to be updated.\n * @constructor\n *\n * @private\n */\n\n\nfunction Remove() {}\n\nRemove.accessor = function (gltf, accessorId) {\n  var accessors = gltf.accessors;\n  accessors.splice(accessorId, 1);\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      // Update accessor ids for the primitives.\n      ForEach.meshPrimitiveAttribute(primitive, function (attributeAccessorId, semantic) {\n        if (attributeAccessorId > accessorId) {\n          primitive.attributes[semantic]--;\n        }\n      }); // Update accessor ids for the targets.\n\n      ForEach.meshPrimitiveTarget(primitive, function (target) {\n        ForEach.meshPrimitiveTargetAttribute(target, function (attributeAccessorId, semantic) {\n          if (attributeAccessorId > accessorId) {\n            target[semantic]--;\n          }\n        });\n      });\n      var indices = primitive.indices;\n\n      if (defined(indices) && indices > accessorId) {\n        primitive.indices--;\n      }\n    });\n  });\n  ForEach.skin(gltf, function (skin) {\n    if (defined(skin.inverseBindMatrices) && skin.inverseBindMatrices > accessorId) {\n      skin.inverseBindMatrices--;\n    }\n  });\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationSampler(animation, function (sampler) {\n      if (defined(sampler.input) && sampler.input > accessorId) {\n        sampler.input--;\n      }\n\n      if (defined(sampler.output) && sampler.output > accessorId) {\n        sampler.output--;\n      }\n    });\n  });\n};\n\nRemove.buffer = function (gltf, bufferId) {\n  var buffers = gltf.buffers;\n  buffers.splice(bufferId, 1);\n  ForEach.bufferView(gltf, function (bufferView) {\n    if (defined(bufferView.buffer) && bufferView.buffer > bufferId) {\n      bufferView.buffer--;\n    }\n  });\n};\n\nRemove.bufferView = function (gltf, bufferViewId) {\n  var bufferViews = gltf.bufferViews;\n  bufferViews.splice(bufferViewId, 1);\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.bufferView) && accessor.bufferView > bufferViewId) {\n      accessor.bufferView--;\n    }\n  });\n  ForEach.shader(gltf, function (shader) {\n    if (defined(shader.bufferView) && shader.bufferView > bufferViewId) {\n      shader.bufferView--;\n    }\n  });\n  ForEach.image(gltf, function (image) {\n    if (defined(image.bufferView) && image.bufferView > bufferViewId) {\n      image.bufferView--;\n    }\n\n    ForEach.compressedImage(image, function (compressedImage) {\n      var compressedImageBufferView = compressedImage.bufferView;\n\n      if (defined(compressedImageBufferView) && compressedImageBufferView > bufferViewId) {\n        compressedImage.bufferView--;\n      }\n    });\n  });\n\n  if (hasExtension(gltf, 'KHR_draco_mesh_compression')) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        if (defined(primitive.extensions) && defined(primitive.extensions.KHR_draco_mesh_compression)) {\n          if (primitive.extensions.KHR_draco_mesh_compression.bufferView > bufferViewId) {\n            primitive.extensions.KHR_draco_mesh_compression.bufferView--;\n          }\n        }\n      });\n    });\n  }\n};\n\nRemove.mesh = function (gltf, meshId) {\n  var meshes = gltf.meshes;\n  meshes.splice(meshId, 1);\n  ForEach.node(gltf, function (node) {\n    if (defined(node.mesh)) {\n      if (node.mesh > meshId) {\n        node.mesh--;\n      } else if (node.mesh === meshId) {\n        // Remove reference to deleted mesh\n        delete node.mesh;\n      }\n    }\n  });\n};\n\nRemove.node = function (gltf, nodeId) {\n  var nodes = gltf.nodes;\n  nodes.splice(nodeId, 1); // Shift all node references\n\n  ForEach.skin(gltf, function (skin) {\n    if (defined(skin.skeleton) && skin.skeleton > nodeId) {\n      skin.skeleton--;\n    }\n\n    skin.joints = skin.joints.map(function (x) {\n      return x > nodeId ? x - 1 : x;\n    });\n  });\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationChannel(animation, function (channel) {\n      if (defined(channel.target) && defined(channel.target.node) && channel.target.node > nodeId) {\n        channel.target.node--;\n      }\n    });\n  });\n  ForEach.technique(gltf, function (technique) {\n    ForEach.techniqueUniform(technique, function (uniform) {\n      if (defined(uniform.node) && uniform.node > nodeId) {\n        uniform.node--;\n      }\n    });\n  });\n  ForEach.node(gltf, function (node) {\n    if (!defined(node.children)) {\n      return;\n    }\n\n    node.children = node.children.filter(function (x) {\n      return x !== nodeId; // Remove\n    }).map(function (x) {\n      return x > nodeId ? x - 1 : x; // Shift indices\n    });\n  });\n  ForEach.scene(gltf, function (scene) {\n    scene.nodes = scene.nodes.filter(function (x) {\n      return x !== nodeId; // Remove\n    }).map(function (x) {\n      return x > nodeId ? x - 1 : x; // Shift indices\n    });\n  });\n};\n\nRemove.material = function (gltf, materialId) {\n  var materials = gltf.materials;\n  materials.splice(materialId, 1); // Shift other material ids\n\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      if (defined(primitive.material) && primitive.material > materialId) {\n        primitive.material--;\n      }\n    });\n  });\n};\n/**\n * Contains functions for getting a list of element ids in use by the glTF asset.\n * @constructor\n *\n * @private\n */\n\n\nfunction getListOfElementsIdsInUse() {}\n\ngetListOfElementsIdsInUse.accessor = function (gltf) {\n  // Calculate accessor's that are currently in use.\n  var usedAccessorIds = {};\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      ForEach.meshPrimitiveAttribute(primitive, function (accessorId) {\n        usedAccessorIds[accessorId] = true;\n      });\n      ForEach.meshPrimitiveTarget(primitive, function (target) {\n        ForEach.meshPrimitiveTargetAttribute(target, function (accessorId) {\n          usedAccessorIds[accessorId] = true;\n        });\n      });\n      var indices = primitive.indices;\n\n      if (defined(indices)) {\n        usedAccessorIds[indices] = true;\n      }\n    });\n  });\n  ForEach.skin(gltf, function (skin) {\n    if (defined(skin.inverseBindMatrices)) {\n      usedAccessorIds[skin.inverseBindMatrices] = true;\n    }\n  });\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationSampler(animation, function (sampler) {\n      if (defined(sampler.input)) {\n        usedAccessorIds[sampler.input] = true;\n      }\n\n      if (defined(sampler.output)) {\n        usedAccessorIds[sampler.output] = true;\n      }\n    });\n  });\n  return usedAccessorIds;\n};\n\ngetListOfElementsIdsInUse.buffer = function (gltf) {\n  // Calculate buffer's that are currently in use.\n  var usedBufferIds = {};\n  ForEach.bufferView(gltf, function (bufferView) {\n    if (defined(bufferView.buffer)) {\n      usedBufferIds[bufferView.buffer] = true;\n    }\n  });\n  return usedBufferIds;\n};\n\ngetListOfElementsIdsInUse.bufferView = function (gltf) {\n  // Calculate bufferView's that are currently in use.\n  var usedBufferViewIds = {};\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.bufferView)) {\n      usedBufferViewIds[accessor.bufferView] = true;\n    }\n  });\n  ForEach.shader(gltf, function (shader) {\n    if (defined(shader.bufferView)) {\n      usedBufferViewIds[shader.bufferView] = true;\n    }\n  });\n  ForEach.image(gltf, function (image) {\n    if (defined(image.bufferView)) {\n      usedBufferViewIds[image.bufferView] = true;\n    }\n\n    ForEach.compressedImage(image, function (compressedImage) {\n      if (defined(compressedImage.bufferView)) {\n        usedBufferViewIds[compressedImage.bufferView] = true;\n      }\n    });\n  });\n\n  if (hasExtension(gltf, 'KHR_draco_mesh_compression')) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        if (defined(primitive.extensions) && defined(primitive.extensions.KHR_draco_mesh_compression)) {\n          usedBufferViewIds[primitive.extensions.KHR_draco_mesh_compression.bufferView] = true;\n        }\n      });\n    });\n  }\n\n  return usedBufferViewIds;\n};\n\ngetListOfElementsIdsInUse.mesh = function (gltf) {\n  var usedMeshIds = {};\n  ForEach.node(gltf, function (node) {\n    if (defined(node.mesh && defined(gltf.meshes))) {\n      var mesh = gltf.meshes[node.mesh];\n\n      if (defined(mesh) && defined(mesh.primitives) && mesh.primitives.length > 0) {\n        usedMeshIds[node.mesh] = true;\n      }\n    }\n  });\n  return usedMeshIds;\n}; // Check if node is empty. It is considered empty if neither referencing\n// mesh, camera, extensions and has no children\n\n\nfunction nodeIsEmpty(gltf, node) {\n  if (defined(node.mesh) || defined(node.camera) || defined(node.skin) || defined(node.weights) || defined(node.extras) || defined(node.extensions) && node.extensions.length !== 0) {\n    return false;\n  } // Empty if no children or children are all empty nodes\n\n\n  return !defined(node.children) || node.children.filter(function (n) {\n    return !nodeIsEmpty(gltf, gltf.nodes[n]);\n  }).length === 0;\n}\n\ngetListOfElementsIdsInUse.node = function (gltf) {\n  var usedNodeIds = {};\n  ForEach.node(gltf, function (node, nodeId) {\n    if (!nodeIsEmpty(gltf, node)) {\n      usedNodeIds[nodeId] = true;\n    }\n  });\n  ForEach.skin(gltf, function (skin) {\n    if (defined(skin.skeleton)) {\n      usedNodeIds[skin.skeleton] = true;\n    }\n\n    ForEach.skinJoint(skin, function (joint) {\n      usedNodeIds[joint] = true;\n    });\n  });\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationChannel(animation, function (channel) {\n      if (defined(channel.target) && defined(channel.target.node)) {\n        usedNodeIds[channel.target.node] = true;\n      }\n    });\n  });\n  ForEach.technique(gltf, function (technique) {\n    ForEach.techniqueUniform(technique, function (uniform) {\n      if (defined(uniform.node)) {\n        usedNodeIds[uniform.node] = true;\n      }\n    });\n  });\n  return usedNodeIds;\n};\n\ngetListOfElementsIdsInUse.material = function (gltf) {\n  var usedMaterialIds = {};\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      if (defined(primitive.material)) {\n        usedMaterialIds[primitive.material] = true;\n      }\n    });\n  });\n  return usedMaterialIds;\n};\n\nexport default removeUnusedElements;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/ThirdParty/GltfPipeline/removeUnusedElements.js"],"names":["ForEach","hasExtension","defaultValue","defined","allElementTypes","removeUnusedElements","gltf","elementTypes","forEach","type","indexOf","removeUnusedElementsByType","TypeToGltfElementName","accessor","buffer","bufferView","node","material","mesh","name","arrayOfObjects","removed","usedIds","getListOfElementsIdsInUse","length","i","Remove","accessorId","accessors","splice","meshPrimitive","primitive","meshPrimitiveAttribute","attributeAccessorId","semantic","attributes","meshPrimitiveTarget","target","meshPrimitiveTargetAttribute","indices","skin","inverseBindMatrices","animation","animationSampler","sampler","input","output","bufferId","buffers","bufferViewId","bufferViews","shader","image","compressedImage","compressedImageBufferView","extensions","KHR_draco_mesh_compression","meshId","meshes","nodeId","nodes","skeleton","joints","map","x","animationChannel","channel","technique","techniqueUniform","uniform","children","filter","scene","materialId","materials","usedAccessorIds","usedBufferIds","usedBufferViewIds","usedMeshIds","primitives","nodeIsEmpty","camera","weights","extras","n","usedNodeIds","skinJoint","joint","usedMaterialIds"],"mappings":"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","sourcesContent":["import ForEach from './ForEach.js'\nimport hasExtension from './hasExtension.js'\nimport defaultValue from '../../Core/defaultValue.js'\nimport defined from '../../Core/defined.js'\n\n    var allElementTypes = ['mesh', 'node', 'material', 'accessor', 'bufferView', 'buffer'];\n\n    /**\n     * Removes unused elements from gltf.\n     *\n     * @param {Object} gltf A javascript object containing a glTF asset.\n     * @param {String[]} [elementTypes=['mesh', 'node', 'material', 'accessor', 'bufferView', 'buffer']] Element types to be removed. Needs to be a subset of ['mesh', 'node', 'material', 'accessor', 'bufferView', 'buffer'], other items will be ignored.\n     *\n     * @private\n     */\n    function removeUnusedElements(gltf, elementTypes) {\n        elementTypes = defaultValue(elementTypes, allElementTypes);\n        allElementTypes.forEach(function(type) {\n            if (elementTypes.indexOf(type) > -1) {\n                removeUnusedElementsByType(gltf, type);\n            }\n        });\n        return gltf;\n    }\n\n    var TypeToGltfElementName = {\n        accessor: 'accessors',\n        buffer: 'buffers',\n        bufferView: 'bufferViews',\n        node: 'nodes',\n        material: 'materials',\n        mesh: 'meshes'\n    };\n\n    function removeUnusedElementsByType(gltf, type) {\n        var name = TypeToGltfElementName[type];\n        var arrayOfObjects = gltf[name];\n\n        if (defined(arrayOfObjects)) {\n            var removed = 0;\n            var usedIds = getListOfElementsIdsInUse[type](gltf);\n            var length = arrayOfObjects.length;\n\n            for (var i = 0; i < length; ++i) {\n                if (!usedIds[i]) {\n                    Remove[type](gltf, i - removed);\n                    removed++;\n                }\n            }\n        }\n    }\n\n    /**\n     * Contains functions for removing elements from a glTF hierarchy.\n     * Since top-level glTF elements are arrays, when something is removed, referring\n     * indices need to be updated.\n     * @constructor\n     *\n     * @private\n     */\n    function Remove() {}\n\n    Remove.accessor = function(gltf, accessorId) {\n        var accessors = gltf.accessors;\n\n        accessors.splice(accessorId, 1);\n\n        ForEach.mesh(gltf, function(mesh) {\n            ForEach.meshPrimitive(mesh, function(primitive) {\n                // Update accessor ids for the primitives.\n                ForEach.meshPrimitiveAttribute(primitive, function(attributeAccessorId, semantic) {\n                    if (attributeAccessorId > accessorId) {\n                        primitive.attributes[semantic]--;\n                    }\n                });\n\n                // Update accessor ids for the targets.\n                ForEach.meshPrimitiveTarget(primitive, function(target) {\n                    ForEach.meshPrimitiveTargetAttribute(target, function(attributeAccessorId, semantic) {\n                        if (attributeAccessorId > accessorId) {\n                            target[semantic]--;\n                        }\n                    });\n                });\n                var indices = primitive.indices;\n                if (defined(indices) && indices > accessorId) {\n                    primitive.indices--;\n                }\n            });\n        });\n\n        ForEach.skin(gltf, function(skin) {\n            if (defined(skin.inverseBindMatrices) && skin.inverseBindMatrices > accessorId) {\n                skin.inverseBindMatrices--;\n            }\n        });\n\n        ForEach.animation(gltf, function(animation) {\n            ForEach.animationSampler(animation, function(sampler) {\n                if (defined(sampler.input) && sampler.input > accessorId) {\n                    sampler.input--;\n                }\n                if (defined(sampler.output) && sampler.output > accessorId) {\n                    sampler.output--;\n                }\n            });\n        });\n    };\n\n    Remove.buffer = function(gltf, bufferId) {\n        var buffers = gltf.buffers;\n\n        buffers.splice(bufferId, 1);\n\n        ForEach.bufferView(gltf, function(bufferView) {\n            if (defined(bufferView.buffer) && bufferView.buffer > bufferId) {\n                bufferView.buffer--;\n            }\n        });\n    };\n\n    Remove.bufferView = function(gltf, bufferViewId) {\n        var bufferViews = gltf.bufferViews;\n\n        bufferViews.splice(bufferViewId, 1);\n\n        ForEach.accessor(gltf, function(accessor) {\n            if (defined(accessor.bufferView) && accessor.bufferView > bufferViewId) {\n                accessor.bufferView--;\n            }\n        });\n\n        ForEach.shader(gltf, function(shader) {\n            if (defined(shader.bufferView) && shader.bufferView > bufferViewId) {\n                shader.bufferView--;\n            }\n        });\n\n        ForEach.image(gltf, function(image) {\n            if (defined(image.bufferView) && image.bufferView > bufferViewId) {\n                image.bufferView--;\n            }\n            ForEach.compressedImage(image, function(compressedImage) {\n                var compressedImageBufferView = compressedImage.bufferView;\n                if (defined(compressedImageBufferView) && compressedImageBufferView > bufferViewId) {\n                    compressedImage.bufferView--;\n                }\n            });\n        });\n\n        if (hasExtension(gltf, 'KHR_draco_mesh_compression')) {\n            ForEach.mesh(gltf, function(mesh) {\n                ForEach.meshPrimitive(mesh, function(primitive) {\n                    if (defined(primitive.extensions) &&\n                        defined(primitive.extensions.KHR_draco_mesh_compression)) {\n                        if (primitive.extensions.KHR_draco_mesh_compression.bufferView > bufferViewId) {\n                            primitive.extensions.KHR_draco_mesh_compression.bufferView--;\n                        }\n                    }\n                });\n            });\n        }\n    };\n\n    Remove.mesh = function(gltf, meshId) {\n        var meshes = gltf.meshes;\n        meshes.splice(meshId, 1);\n\n        ForEach.node(gltf, function(node) {\n            if (defined(node.mesh)) {\n                if (node.mesh > meshId) {\n                    node.mesh--;\n                } else if (node.mesh === meshId) {\n                    // Remove reference to deleted mesh\n                    delete node.mesh;\n                }\n            }\n        });\n    };\n\n    Remove.node = function(gltf, nodeId) {\n        var nodes = gltf.nodes;\n        nodes.splice(nodeId, 1);\n\n        // Shift all node references\n        ForEach.skin(gltf, function(skin) {\n            if (defined(skin.skeleton) && skin.skeleton > nodeId) {\n                skin.skeleton--;\n            }\n\n            skin.joints = skin.joints.map(function(x) {\n                return x > nodeId ? x - 1 : x;\n            });\n        });\n        ForEach.animation(gltf, function(animation) {\n            ForEach.animationChannel(animation, function(channel) {\n                if (defined(channel.target) && defined(channel.target.node) && (channel.target.node > nodeId)) {\n                    channel.target.node--;\n                }\n            });\n        });\n        ForEach.technique(gltf, function(technique) {\n            ForEach.techniqueUniform(technique, function(uniform) {\n                if (defined(uniform.node) && uniform.node > nodeId) {\n                    uniform.node--;\n                }\n            });\n        });\n        ForEach.node(gltf, function(node) {\n            if (!defined(node.children)) {\n                return;\n            }\n\n            node.children = node.children\n                .filter(function(x) {\n                    return x !== nodeId; // Remove\n                })\n                .map(function(x) {\n                    return x > nodeId ? x - 1 : x; // Shift indices\n                });\n        });\n        ForEach.scene(gltf, function(scene) {\n            scene.nodes = scene.nodes\n                .filter(function(x) {\n                    return x !== nodeId; // Remove\n                })\n                .map(function(x) {\n                    return x > nodeId ? x - 1 : x; // Shift indices\n                });\n        });\n    };\n\n    Remove.material = function(gltf, materialId) {\n        var materials = gltf.materials;\n        materials.splice(materialId, 1);\n\n        // Shift other material ids\n        ForEach.mesh(gltf, function(mesh) {\n            ForEach.meshPrimitive(mesh, function(primitive) {\n                if (defined(primitive.material) && primitive.material > materialId) {\n                    primitive.material--;\n                }\n            });\n        });\n    };\n\n    /**\n     * Contains functions for getting a list of element ids in use by the glTF asset.\n     * @constructor\n     *\n     * @private\n     */\n    function getListOfElementsIdsInUse() {}\n\n    getListOfElementsIdsInUse.accessor = function(gltf) {\n        // Calculate accessor's that are currently in use.\n        var usedAccessorIds = {};\n\n        ForEach.mesh(gltf, function(mesh) {\n            ForEach.meshPrimitive(mesh, function(primitive) {\n                ForEach.meshPrimitiveAttribute(primitive, function(accessorId) {\n                    usedAccessorIds[accessorId] = true;\n                });\n                ForEach.meshPrimitiveTarget(primitive, function(target) {\n                    ForEach.meshPrimitiveTargetAttribute(target, function(accessorId) {\n                        usedAccessorIds[accessorId] = true;\n                    });\n                });\n                var indices = primitive.indices;\n                if (defined(indices)) {\n                    usedAccessorIds[indices] = true;\n                }\n            });\n        });\n\n        ForEach.skin(gltf, function(skin) {\n            if (defined(skin.inverseBindMatrices)) {\n                usedAccessorIds[skin.inverseBindMatrices] = true;\n            }\n        });\n\n        ForEach.animation(gltf, function(animation) {\n            ForEach.animationSampler(animation, function(sampler) {\n                if (defined(sampler.input)) {\n                    usedAccessorIds[sampler.input] = true;\n                }\n                if (defined(sampler.output)) {\n                    usedAccessorIds[sampler.output] = true;\n                }\n            });\n        });\n\n        return usedAccessorIds;\n    };\n\n    getListOfElementsIdsInUse.buffer = function(gltf) {\n        // Calculate buffer's that are currently in use.\n        var usedBufferIds = {};\n\n        ForEach.bufferView(gltf, function(bufferView) {\n            if (defined(bufferView.buffer)) {\n                usedBufferIds[bufferView.buffer] = true;\n            }\n        });\n\n        return usedBufferIds;\n    };\n\n    getListOfElementsIdsInUse.bufferView = function(gltf) {\n        // Calculate bufferView's that are currently in use.\n        var usedBufferViewIds = {};\n\n        ForEach.accessor(gltf, function(accessor) {\n            if (defined(accessor.bufferView)) {\n                usedBufferViewIds[accessor.bufferView] = true;\n            }\n        });\n\n        ForEach.shader(gltf, function(shader) {\n            if (defined(shader.bufferView)) {\n                usedBufferViewIds[shader.bufferView] = true;\n            }\n        });\n\n        ForEach.image(gltf, function(image) {\n            if (defined(image.bufferView)) {\n                usedBufferViewIds[image.bufferView] = true;\n            }\n            ForEach.compressedImage(image, function(compressedImage) {\n                if (defined(compressedImage.bufferView)) {\n                    usedBufferViewIds[compressedImage.bufferView] = true;\n                }\n            });\n        });\n\n        if (hasExtension(gltf, 'KHR_draco_mesh_compression')) {\n            ForEach.mesh(gltf, function(mesh) {\n                ForEach.meshPrimitive(mesh, function(primitive) {\n                    if (defined(primitive.extensions) &&\n                        defined(primitive.extensions.KHR_draco_mesh_compression)) {\n                        usedBufferViewIds[primitive.extensions.KHR_draco_mesh_compression.bufferView] = true;\n                    }\n                });\n            });\n        }\n\n        return usedBufferViewIds;\n    };\n\n    getListOfElementsIdsInUse.mesh = function(gltf) {\n        var usedMeshIds = {};\n        ForEach.node(gltf, function(node) {\n            if (defined(node.mesh && defined(gltf.meshes))) {\n                var mesh = gltf.meshes[node.mesh];\n                if (defined(mesh) && defined(mesh.primitives) && (mesh.primitives.length > 0)) {\n                    usedMeshIds[node.mesh] = true;\n                }\n            }\n        });\n\n        return usedMeshIds;\n    };\n\n    // Check if node is empty. It is considered empty if neither referencing\n    // mesh, camera, extensions and has no children\n    function nodeIsEmpty(gltf, node) {\n        if (defined(node.mesh) || defined(node.camera) || defined(node.skin)\n            || defined(node.weights) || defined(node.extras)\n            || (defined(node.extensions) && node.extensions.length !== 0)) {\n            return false;\n        }\n\n        // Empty if no children or children are all empty nodes\n        return !defined(node.children)\n            || node.children.filter(function(n) {\n                return !nodeIsEmpty(gltf, gltf.nodes[n]);\n            }).length === 0;\n    }\n\n    getListOfElementsIdsInUse.node = function(gltf) {\n        var usedNodeIds = {};\n        ForEach.node(gltf, function(node, nodeId) {\n            if (!nodeIsEmpty(gltf, node)) {\n                usedNodeIds[nodeId] = true;\n            }\n        });\n        ForEach.skin(gltf, function(skin) {\n            if (defined(skin.skeleton)) {\n                usedNodeIds[skin.skeleton] = true;\n            }\n\n            ForEach.skinJoint(skin, function(joint) {\n                usedNodeIds[joint] = true;\n            });\n        });\n        ForEach.animation(gltf, function(animation) {\n            ForEach.animationChannel(animation, function(channel) {\n                if (defined(channel.target) && defined(channel.target.node)) {\n                    usedNodeIds[channel.target.node] = true;\n                }\n            });\n        });\n        ForEach.technique(gltf, function(technique) {\n            ForEach.techniqueUniform(technique, function(uniform) {\n                if (defined(uniform.node)) {\n                    usedNodeIds[uniform.node] = true;\n                }\n            });\n        });\n\n        return usedNodeIds;\n    };\n\n    getListOfElementsIdsInUse.material = function(gltf) {\n        var usedMaterialIds = {};\n\n        ForEach.mesh(gltf, function(mesh) {\n            ForEach.meshPrimitive(mesh, function(primitive) {\n                if (defined(primitive.material)) {\n                    usedMaterialIds[primitive.material] = true;\n                }\n            });\n        });\n\n        return usedMaterialIds;\n    };\n\n    export default removeUnusedElements;\n"]},"metadata":{},"sourceType":"module"}