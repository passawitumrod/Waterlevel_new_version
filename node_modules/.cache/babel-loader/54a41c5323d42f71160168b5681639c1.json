{"ast":null,"code":"import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport ReferenceFrame from \"../Core/ReferenceFrame.js\";\nimport TimeInterval from \"../Core/TimeInterval.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport PolylineCollection from \"../Scene/PolylineCollection.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport CompositePositionProperty from \"./CompositePositionProperty.js\";\nimport ConstantPositionProperty from \"./ConstantPositionProperty.js\";\nimport MaterialProperty from \"./MaterialProperty.js\";\nimport Property from \"./Property.js\";\nimport ReferenceProperty from \"./ReferenceProperty.js\";\nimport SampledPositionProperty from \"./SampledPositionProperty.js\";\nimport ScaledPositionProperty from \"./ScaledPositionProperty.js\";\nimport TimeIntervalCollectionPositionProperty from \"./TimeIntervalCollectionPositionProperty.js\";\nvar defaultResolution = 60.0;\nvar defaultWidth = 1.0;\nvar scratchTimeInterval = new TimeInterval();\nvar subSampleCompositePropertyScratch = new TimeInterval();\nvar subSampleIntervalPropertyScratch = new TimeInterval();\n\nfunction EntityData(entity) {\n  this.entity = entity;\n  this.polyline = undefined;\n  this.index = undefined;\n  this.updater = undefined;\n}\n\nfunction subSampleSampledProperty(property, start, stop, times, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n  var r = startingIndex; //Always step exactly on start (but only use it if it exists.)\n\n  var tmp;\n  tmp = property.getValueInReferenceFrame(start, referenceFrame, result[r]);\n\n  if (defined(tmp)) {\n    result[r++] = tmp;\n  }\n\n  var steppedOnNow = !defined(updateTime) || JulianDate.lessThanOrEquals(updateTime, start) || JulianDate.greaterThanOrEquals(updateTime, stop); //Iterate over all interval times and add the ones that fall in our\n  //time range.  Note that times can contain data outside of\n  //the intervals range.  This is by design for use with interpolation.\n\n  var t = 0;\n  var len = times.length;\n  var current = times[t];\n  var loopStop = stop;\n  var sampling = false;\n  var sampleStepsToTake;\n  var sampleStepsTaken;\n  var sampleStepSize;\n\n  while (t < len) {\n    if (!steppedOnNow && JulianDate.greaterThanOrEquals(current, updateTime)) {\n      tmp = property.getValueInReferenceFrame(updateTime, referenceFrame, result[r]);\n\n      if (defined(tmp)) {\n        result[r++] = tmp;\n      }\n\n      steppedOnNow = true;\n    }\n\n    if (JulianDate.greaterThan(current, start) && JulianDate.lessThan(current, loopStop) && !current.equals(updateTime)) {\n      tmp = property.getValueInReferenceFrame(current, referenceFrame, result[r]);\n\n      if (defined(tmp)) {\n        result[r++] = tmp;\n      }\n    }\n\n    if (t < len - 1) {\n      if (maximumStep > 0 && !sampling) {\n        var next = times[t + 1];\n        var secondsUntilNext = JulianDate.secondsDifference(next, current);\n        sampling = secondsUntilNext > maximumStep;\n\n        if (sampling) {\n          sampleStepsToTake = Math.ceil(secondsUntilNext / maximumStep);\n          sampleStepsTaken = 0;\n          sampleStepSize = secondsUntilNext / Math.max(sampleStepsToTake, 2);\n          sampleStepsToTake = Math.max(sampleStepsToTake - 1, 1);\n        }\n      }\n\n      if (sampling && sampleStepsTaken < sampleStepsToTake) {\n        current = JulianDate.addSeconds(current, sampleStepSize, new JulianDate());\n        sampleStepsTaken++;\n        continue;\n      }\n    }\n\n    sampling = false;\n    t++;\n    current = times[t];\n  } //Always step exactly on stop (but only use it if it exists.)\n\n\n  tmp = property.getValueInReferenceFrame(stop, referenceFrame, result[r]);\n\n  if (defined(tmp)) {\n    result[r++] = tmp;\n  }\n\n  return r;\n}\n\nfunction subSampleGenericProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n  var tmp;\n  var i = 0;\n  var index = startingIndex;\n  var time = start;\n  var stepSize = Math.max(maximumStep, 60);\n  var steppedOnNow = !defined(updateTime) || JulianDate.lessThanOrEquals(updateTime, start) || JulianDate.greaterThanOrEquals(updateTime, stop);\n\n  while (JulianDate.lessThan(time, stop)) {\n    if (!steppedOnNow && JulianDate.greaterThanOrEquals(time, updateTime)) {\n      steppedOnNow = true;\n      tmp = property.getValueInReferenceFrame(updateTime, referenceFrame, result[index]);\n\n      if (defined(tmp)) {\n        result[index] = tmp;\n        index++;\n      }\n    }\n\n    tmp = property.getValueInReferenceFrame(time, referenceFrame, result[index]);\n\n    if (defined(tmp)) {\n      result[index] = tmp;\n      index++;\n    }\n\n    i++;\n    time = JulianDate.addSeconds(start, stepSize * i, new JulianDate());\n  } //Always sample stop.\n\n\n  tmp = property.getValueInReferenceFrame(stop, referenceFrame, result[index]);\n\n  if (defined(tmp)) {\n    result[index] = tmp;\n    index++;\n  }\n\n  return index;\n}\n\nfunction subSampleIntervalProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n  subSampleIntervalPropertyScratch.start = start;\n  subSampleIntervalPropertyScratch.stop = stop;\n  var index = startingIndex;\n  var intervals = property.intervals;\n\n  for (var i = 0; i < intervals.length; i++) {\n    var interval = intervals.get(i);\n\n    if (!TimeInterval.intersect(interval, subSampleIntervalPropertyScratch, scratchTimeInterval).isEmpty) {\n      var time = interval.start;\n\n      if (!interval.isStartIncluded) {\n        if (interval.isStopIncluded) {\n          time = interval.stop;\n        } else {\n          time = JulianDate.addSeconds(interval.start, JulianDate.secondsDifference(interval.stop, interval.start) / 2, new JulianDate());\n        }\n      }\n\n      var tmp = property.getValueInReferenceFrame(time, referenceFrame, result[index]);\n\n      if (defined(tmp)) {\n        result[index] = tmp;\n        index++;\n      }\n    }\n  }\n\n  return index;\n}\n\nfunction subSampleConstantProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n  var tmp = property.getValueInReferenceFrame(start, referenceFrame, result[startingIndex]);\n\n  if (defined(tmp)) {\n    result[startingIndex++] = tmp;\n  }\n\n  return startingIndex;\n}\n\nfunction subSampleCompositeProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n  subSampleCompositePropertyScratch.start = start;\n  subSampleCompositePropertyScratch.stop = stop;\n  var index = startingIndex;\n  var intervals = property.intervals;\n\n  for (var i = 0; i < intervals.length; i++) {\n    var interval = intervals.get(i);\n\n    if (!TimeInterval.intersect(interval, subSampleCompositePropertyScratch, scratchTimeInterval).isEmpty) {\n      var intervalStart = interval.start;\n      var intervalStop = interval.stop;\n      var sampleStart = start;\n\n      if (JulianDate.greaterThan(intervalStart, sampleStart)) {\n        sampleStart = intervalStart;\n      }\n\n      var sampleStop = stop;\n\n      if (JulianDate.lessThan(intervalStop, sampleStop)) {\n        sampleStop = intervalStop;\n      }\n\n      index = reallySubSample(interval.data, sampleStart, sampleStop, updateTime, referenceFrame, maximumStep, index, result);\n    }\n  }\n\n  return index;\n}\n\nfunction reallySubSample(property, start, stop, updateTime, referenceFrame, maximumStep, index, result) {\n  //Unwrap any references until we have the actual property.\n  while (property instanceof ReferenceProperty) {\n    property = property.resolvedProperty;\n  }\n\n  if (property instanceof SampledPositionProperty) {\n    var times = property._property._times;\n    index = subSampleSampledProperty(property, start, stop, times, updateTime, referenceFrame, maximumStep, index, result);\n  } else if (property instanceof CompositePositionProperty) {\n    index = subSampleCompositeProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);\n  } else if (property instanceof TimeIntervalCollectionPositionProperty) {\n    index = subSampleIntervalProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);\n  } else if (property instanceof ConstantPositionProperty || property instanceof ScaledPositionProperty && Property.isConstant(property)) {\n    index = subSampleConstantProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);\n  } else {\n    //Fallback to generic sampling.\n    index = subSampleGenericProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);\n  }\n\n  return index;\n}\n\nfunction subSample(property, start, stop, updateTime, referenceFrame, maximumStep, result) {\n  if (!defined(result)) {\n    result = [];\n  }\n\n  var length = reallySubSample(property, start, stop, updateTime, referenceFrame, maximumStep, 0, result);\n  result.length = length;\n  return result;\n}\n\nvar toFixedScratch = new Matrix3();\n\nfunction PolylineUpdater(scene, referenceFrame) {\n  this._unusedIndexes = [];\n  this._polylineCollection = new PolylineCollection();\n  this._scene = scene;\n  this._referenceFrame = referenceFrame;\n  scene.primitives.add(this._polylineCollection);\n}\n\nPolylineUpdater.prototype.update = function (time) {\n  if (this._referenceFrame === ReferenceFrame.INERTIAL) {\n    var toFixed = Transforms.computeIcrfToFixedMatrix(time, toFixedScratch);\n\n    if (!defined(toFixed)) {\n      toFixed = Transforms.computeTemeToPseudoFixedMatrix(time, toFixedScratch);\n    }\n\n    Matrix4.fromRotationTranslation(toFixed, Cartesian3.ZERO, this._polylineCollection.modelMatrix);\n  }\n};\n\nPolylineUpdater.prototype.updateObject = function (time, item) {\n  var entity = item.entity;\n  var pathGraphics = entity._path;\n  var positionProperty = entity._position;\n  var sampleStart;\n  var sampleStop;\n  var showProperty = pathGraphics._show;\n  var polyline = item.polyline;\n  var show = entity.isShowing && (!defined(showProperty) || showProperty.getValue(time)); //While we want to show the path, there may not actually be anything to show\n  //depending on lead/trail settings.  Compute the interval of the path to\n  //show and check against actual availability.\n\n  if (show) {\n    var leadTime = Property.getValueOrUndefined(pathGraphics._leadTime, time);\n    var trailTime = Property.getValueOrUndefined(pathGraphics._trailTime, time);\n    var availability = entity._availability;\n    var hasAvailability = defined(availability);\n    var hasLeadTime = defined(leadTime);\n    var hasTrailTime = defined(trailTime); //Objects need to have either defined availability or both a lead and trail time in order to\n    //draw a path (since we can't draw \"infinite\" paths.\n\n    show = hasAvailability || hasLeadTime && hasTrailTime; //The final step is to compute the actual start/stop times of the path to show.\n    //If current time is outside of the availability interval, there's a chance that\n    //we won't have to draw anything anyway.\n\n    if (show) {\n      if (hasTrailTime) {\n        sampleStart = JulianDate.addSeconds(time, -trailTime, new JulianDate());\n      }\n\n      if (hasLeadTime) {\n        sampleStop = JulianDate.addSeconds(time, leadTime, new JulianDate());\n      }\n\n      if (hasAvailability) {\n        var start = availability.start;\n        var stop = availability.stop;\n\n        if (!hasTrailTime || JulianDate.greaterThan(start, sampleStart)) {\n          sampleStart = start;\n        }\n\n        if (!hasLeadTime || JulianDate.lessThan(stop, sampleStop)) {\n          sampleStop = stop;\n        }\n      }\n\n      show = JulianDate.lessThan(sampleStart, sampleStop);\n    }\n  }\n\n  if (!show) {\n    //don't bother creating or updating anything else\n    if (defined(polyline)) {\n      this._unusedIndexes.push(item.index);\n\n      item.polyline = undefined;\n      polyline.show = false;\n      item.index = undefined;\n    }\n\n    return;\n  }\n\n  if (!defined(polyline)) {\n    var unusedIndexes = this._unusedIndexes;\n    var length = unusedIndexes.length;\n\n    if (length > 0) {\n      var index = unusedIndexes.pop();\n      polyline = this._polylineCollection.get(index);\n      item.index = index;\n    } else {\n      item.index = this._polylineCollection.length;\n      polyline = this._polylineCollection.add();\n    }\n\n    polyline.id = entity;\n    item.polyline = polyline;\n  }\n\n  var resolution = Property.getValueOrDefault(pathGraphics._resolution, time, defaultResolution);\n  polyline.show = true;\n  polyline.positions = subSample(positionProperty, sampleStart, sampleStop, time, this._referenceFrame, resolution, polyline.positions.slice());\n  polyline.material = MaterialProperty.getValue(time, pathGraphics._material, polyline.material);\n  polyline.width = Property.getValueOrDefault(pathGraphics._width, time, defaultWidth);\n  polyline.distanceDisplayCondition = Property.getValueOrUndefined(pathGraphics._distanceDisplayCondition, time, polyline.distanceDisplayCondition);\n};\n\nPolylineUpdater.prototype.removeObject = function (item) {\n  var polyline = item.polyline;\n\n  if (defined(polyline)) {\n    this._unusedIndexes.push(item.index);\n\n    item.polyline = undefined;\n    polyline.show = false;\n    polyline.id = undefined;\n    item.index = undefined;\n  }\n};\n\nPolylineUpdater.prototype.destroy = function () {\n  this._scene.primitives.remove(this._polylineCollection);\n\n  return destroyObject(this);\n};\n/**\n * A {@link Visualizer} which maps {@link Entity#path} to a {@link Polyline}.\n * @alias PathVisualizer\n * @constructor\n *\n * @param {Scene} scene The scene the primitives will be rendered in.\n * @param {EntityCollection} entityCollection The entityCollection to visualize.\n */\n\n\nfunction PathVisualizer(scene, entityCollection) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n\n  if (!defined(entityCollection)) {\n    throw new DeveloperError(\"entityCollection is required.\");\n  } //>>includeEnd('debug');\n\n\n  entityCollection.collectionChanged.addEventListener(PathVisualizer.prototype._onCollectionChanged, this);\n  this._scene = scene;\n  this._updaters = {};\n  this._entityCollection = entityCollection;\n  this._items = new AssociativeArray();\n\n  this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n}\n/**\n * Updates all of the primitives created by this visualizer to match their\n * Entity counterpart at the given time.\n *\n * @param {JulianDate} time The time to update to.\n * @returns {Boolean} This function always returns true.\n */\n\n\nPathVisualizer.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(time)) {\n    throw new DeveloperError(\"time is required.\");\n  } //>>includeEnd('debug');\n\n\n  var updaters = this._updaters;\n\n  for (var key in updaters) {\n    if (updaters.hasOwnProperty(key)) {\n      updaters[key].update(time);\n    }\n  }\n\n  var items = this._items.values;\n\n  if (items.length === 0 && defined(this._updaters) && Object.keys(this._updaters).length > 0) {\n    for (var u in updaters) {\n      if (updaters.hasOwnProperty(u)) {\n        updaters[u].destroy();\n      }\n    }\n\n    this._updaters = {};\n  }\n\n  for (var i = 0, len = items.length; i < len; i++) {\n    var item = items[i];\n    var entity = item.entity;\n    var positionProperty = entity._position;\n    var lastUpdater = item.updater;\n    var frameToVisualize = ReferenceFrame.FIXED;\n\n    if (this._scene.mode === SceneMode.SCENE3D) {\n      frameToVisualize = positionProperty.referenceFrame;\n    }\n\n    var currentUpdater = this._updaters[frameToVisualize];\n\n    if (lastUpdater === currentUpdater && defined(currentUpdater)) {\n      currentUpdater.updateObject(time, item);\n      continue;\n    }\n\n    if (defined(lastUpdater)) {\n      lastUpdater.removeObject(item);\n    }\n\n    if (!defined(currentUpdater)) {\n      currentUpdater = new PolylineUpdater(this._scene, frameToVisualize);\n      currentUpdater.update(time);\n      this._updaters[frameToVisualize] = currentUpdater;\n    }\n\n    item.updater = currentUpdater;\n\n    if (defined(currentUpdater)) {\n      currentUpdater.updateObject(time, item);\n    }\n  }\n\n  return true;\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n */\n\n\nPathVisualizer.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Removes and destroys all primitives created by this instance.\n */\n\n\nPathVisualizer.prototype.destroy = function () {\n  this._entityCollection.collectionChanged.removeEventListener(PathVisualizer.prototype._onCollectionChanged, this);\n\n  var updaters = this._updaters;\n\n  for (var key in updaters) {\n    if (updaters.hasOwnProperty(key)) {\n      updaters[key].destroy();\n    }\n  }\n\n  return destroyObject(this);\n};\n\nPathVisualizer.prototype._onCollectionChanged = function (entityCollection, added, removed, changed) {\n  var i;\n  var entity;\n  var item;\n  var items = this._items;\n\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n\n    if (defined(entity._path) && defined(entity._position)) {\n      items.set(entity.id, new EntityData(entity));\n    }\n  }\n\n  for (i = changed.length - 1; i > -1; i--) {\n    entity = changed[i];\n\n    if (defined(entity._path) && defined(entity._position)) {\n      if (!items.contains(entity.id)) {\n        items.set(entity.id, new EntityData(entity));\n      }\n    } else {\n      item = items.get(entity.id);\n\n      if (defined(item)) {\n        if (defined(item.updater)) {\n          item.updater.removeObject(item);\n        }\n\n        items.remove(entity.id);\n      }\n    }\n  }\n\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    item = items.get(entity.id);\n\n    if (defined(item)) {\n      if (defined(item.updater)) {\n        item.updater.removeObject(item);\n      }\n\n      items.remove(entity.id);\n    }\n  }\n}; //for testing\n\n\nPathVisualizer._subSample = subSample;\nexport default PathVisualizer;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/DataSources/PathVisualizer.js"],"names":["AssociativeArray","Cartesian3","defined","destroyObject","DeveloperError","JulianDate","Matrix3","Matrix4","ReferenceFrame","TimeInterval","Transforms","PolylineCollection","SceneMode","CompositePositionProperty","ConstantPositionProperty","MaterialProperty","Property","ReferenceProperty","SampledPositionProperty","ScaledPositionProperty","TimeIntervalCollectionPositionProperty","defaultResolution","defaultWidth","scratchTimeInterval","subSampleCompositePropertyScratch","subSampleIntervalPropertyScratch","EntityData","entity","polyline","undefined","index","updater","subSampleSampledProperty","property","start","stop","times","updateTime","referenceFrame","maximumStep","startingIndex","result","r","tmp","getValueInReferenceFrame","steppedOnNow","lessThanOrEquals","greaterThanOrEquals","t","len","length","current","loopStop","sampling","sampleStepsToTake","sampleStepsTaken","sampleStepSize","greaterThan","lessThan","equals","next","secondsUntilNext","secondsDifference","Math","ceil","max","addSeconds","subSampleGenericProperty","i","time","stepSize","subSampleIntervalProperty","intervals","interval","get","intersect","isEmpty","isStartIncluded","isStopIncluded","subSampleConstantProperty","subSampleCompositeProperty","intervalStart","intervalStop","sampleStart","sampleStop","reallySubSample","data","resolvedProperty","_property","_times","isConstant","subSample","toFixedScratch","PolylineUpdater","scene","_unusedIndexes","_polylineCollection","_scene","_referenceFrame","primitives","add","prototype","update","INERTIAL","toFixed","computeIcrfToFixedMatrix","computeTemeToPseudoFixedMatrix","fromRotationTranslation","ZERO","modelMatrix","updateObject","item","pathGraphics","_path","positionProperty","_position","showProperty","_show","show","isShowing","getValue","leadTime","getValueOrUndefined","_leadTime","trailTime","_trailTime","availability","_availability","hasAvailability","hasLeadTime","hasTrailTime","push","unusedIndexes","pop","id","resolution","getValueOrDefault","_resolution","positions","slice","material","_material","width","_width","distanceDisplayCondition","_distanceDisplayCondition","removeObject","destroy","remove","PathVisualizer","entityCollection","collectionChanged","addEventListener","_onCollectionChanged","_updaters","_entityCollection","_items","values","updaters","key","hasOwnProperty","items","Object","keys","u","lastUpdater","frameToVisualize","FIXED","mode","SCENE3D","currentUpdater","isDestroyed","removeEventListener","added","removed","changed","set","contains","_subSample"],"mappings":"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","sourcesContent":["import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport ReferenceFrame from \"../Core/ReferenceFrame.js\";\nimport TimeInterval from \"../Core/TimeInterval.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport PolylineCollection from \"../Scene/PolylineCollection.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport CompositePositionProperty from \"./CompositePositionProperty.js\";\nimport ConstantPositionProperty from \"./ConstantPositionProperty.js\";\nimport MaterialProperty from \"./MaterialProperty.js\";\nimport Property from \"./Property.js\";\nimport ReferenceProperty from \"./ReferenceProperty.js\";\nimport SampledPositionProperty from \"./SampledPositionProperty.js\";\nimport ScaledPositionProperty from \"./ScaledPositionProperty.js\";\nimport TimeIntervalCollectionPositionProperty from \"./TimeIntervalCollectionPositionProperty.js\";\n\nvar defaultResolution = 60.0;\nvar defaultWidth = 1.0;\n\nvar scratchTimeInterval = new TimeInterval();\nvar subSampleCompositePropertyScratch = new TimeInterval();\nvar subSampleIntervalPropertyScratch = new TimeInterval();\n\nfunction EntityData(entity) {\n  this.entity = entity;\n  this.polyline = undefined;\n  this.index = undefined;\n  this.updater = undefined;\n}\n\nfunction subSampleSampledProperty(\n  property,\n  start,\n  stop,\n  times,\n  updateTime,\n  referenceFrame,\n  maximumStep,\n  startingIndex,\n  result\n) {\n  var r = startingIndex;\n  //Always step exactly on start (but only use it if it exists.)\n  var tmp;\n  tmp = property.getValueInReferenceFrame(start, referenceFrame, result[r]);\n  if (defined(tmp)) {\n    result[r++] = tmp;\n  }\n\n  var steppedOnNow =\n    !defined(updateTime) ||\n    JulianDate.lessThanOrEquals(updateTime, start) ||\n    JulianDate.greaterThanOrEquals(updateTime, stop);\n\n  //Iterate over all interval times and add the ones that fall in our\n  //time range.  Note that times can contain data outside of\n  //the intervals range.  This is by design for use with interpolation.\n  var t = 0;\n  var len = times.length;\n  var current = times[t];\n  var loopStop = stop;\n  var sampling = false;\n  var sampleStepsToTake;\n  var sampleStepsTaken;\n  var sampleStepSize;\n\n  while (t < len) {\n    if (!steppedOnNow && JulianDate.greaterThanOrEquals(current, updateTime)) {\n      tmp = property.getValueInReferenceFrame(\n        updateTime,\n        referenceFrame,\n        result[r]\n      );\n      if (defined(tmp)) {\n        result[r++] = tmp;\n      }\n      steppedOnNow = true;\n    }\n    if (\n      JulianDate.greaterThan(current, start) &&\n      JulianDate.lessThan(current, loopStop) &&\n      !current.equals(updateTime)\n    ) {\n      tmp = property.getValueInReferenceFrame(\n        current,\n        referenceFrame,\n        result[r]\n      );\n      if (defined(tmp)) {\n        result[r++] = tmp;\n      }\n    }\n\n    if (t < len - 1) {\n      if (maximumStep > 0 && !sampling) {\n        var next = times[t + 1];\n        var secondsUntilNext = JulianDate.secondsDifference(next, current);\n        sampling = secondsUntilNext > maximumStep;\n\n        if (sampling) {\n          sampleStepsToTake = Math.ceil(secondsUntilNext / maximumStep);\n          sampleStepsTaken = 0;\n          sampleStepSize = secondsUntilNext / Math.max(sampleStepsToTake, 2);\n          sampleStepsToTake = Math.max(sampleStepsToTake - 1, 1);\n        }\n      }\n\n      if (sampling && sampleStepsTaken < sampleStepsToTake) {\n        current = JulianDate.addSeconds(\n          current,\n          sampleStepSize,\n          new JulianDate()\n        );\n        sampleStepsTaken++;\n        continue;\n      }\n    }\n    sampling = false;\n    t++;\n    current = times[t];\n  }\n\n  //Always step exactly on stop (but only use it if it exists.)\n  tmp = property.getValueInReferenceFrame(stop, referenceFrame, result[r]);\n  if (defined(tmp)) {\n    result[r++] = tmp;\n  }\n\n  return r;\n}\n\nfunction subSampleGenericProperty(\n  property,\n  start,\n  stop,\n  updateTime,\n  referenceFrame,\n  maximumStep,\n  startingIndex,\n  result\n) {\n  var tmp;\n  var i = 0;\n  var index = startingIndex;\n  var time = start;\n  var stepSize = Math.max(maximumStep, 60);\n  var steppedOnNow =\n    !defined(updateTime) ||\n    JulianDate.lessThanOrEquals(updateTime, start) ||\n    JulianDate.greaterThanOrEquals(updateTime, stop);\n  while (JulianDate.lessThan(time, stop)) {\n    if (!steppedOnNow && JulianDate.greaterThanOrEquals(time, updateTime)) {\n      steppedOnNow = true;\n      tmp = property.getValueInReferenceFrame(\n        updateTime,\n        referenceFrame,\n        result[index]\n      );\n      if (defined(tmp)) {\n        result[index] = tmp;\n        index++;\n      }\n    }\n    tmp = property.getValueInReferenceFrame(\n      time,\n      referenceFrame,\n      result[index]\n    );\n    if (defined(tmp)) {\n      result[index] = tmp;\n      index++;\n    }\n    i++;\n    time = JulianDate.addSeconds(start, stepSize * i, new JulianDate());\n  }\n  //Always sample stop.\n  tmp = property.getValueInReferenceFrame(stop, referenceFrame, result[index]);\n  if (defined(tmp)) {\n    result[index] = tmp;\n    index++;\n  }\n  return index;\n}\n\nfunction subSampleIntervalProperty(\n  property,\n  start,\n  stop,\n  updateTime,\n  referenceFrame,\n  maximumStep,\n  startingIndex,\n  result\n) {\n  subSampleIntervalPropertyScratch.start = start;\n  subSampleIntervalPropertyScratch.stop = stop;\n\n  var index = startingIndex;\n  var intervals = property.intervals;\n  for (var i = 0; i < intervals.length; i++) {\n    var interval = intervals.get(i);\n    if (\n      !TimeInterval.intersect(\n        interval,\n        subSampleIntervalPropertyScratch,\n        scratchTimeInterval\n      ).isEmpty\n    ) {\n      var time = interval.start;\n      if (!interval.isStartIncluded) {\n        if (interval.isStopIncluded) {\n          time = interval.stop;\n        } else {\n          time = JulianDate.addSeconds(\n            interval.start,\n            JulianDate.secondsDifference(interval.stop, interval.start) / 2,\n            new JulianDate()\n          );\n        }\n      }\n      var tmp = property.getValueInReferenceFrame(\n        time,\n        referenceFrame,\n        result[index]\n      );\n      if (defined(tmp)) {\n        result[index] = tmp;\n        index++;\n      }\n    }\n  }\n  return index;\n}\n\nfunction subSampleConstantProperty(\n  property,\n  start,\n  stop,\n  updateTime,\n  referenceFrame,\n  maximumStep,\n  startingIndex,\n  result\n) {\n  var tmp = property.getValueInReferenceFrame(\n    start,\n    referenceFrame,\n    result[startingIndex]\n  );\n  if (defined(tmp)) {\n    result[startingIndex++] = tmp;\n  }\n  return startingIndex;\n}\n\nfunction subSampleCompositeProperty(\n  property,\n  start,\n  stop,\n  updateTime,\n  referenceFrame,\n  maximumStep,\n  startingIndex,\n  result\n) {\n  subSampleCompositePropertyScratch.start = start;\n  subSampleCompositePropertyScratch.stop = stop;\n\n  var index = startingIndex;\n  var intervals = property.intervals;\n  for (var i = 0; i < intervals.length; i++) {\n    var interval = intervals.get(i);\n    if (\n      !TimeInterval.intersect(\n        interval,\n        subSampleCompositePropertyScratch,\n        scratchTimeInterval\n      ).isEmpty\n    ) {\n      var intervalStart = interval.start;\n      var intervalStop = interval.stop;\n\n      var sampleStart = start;\n      if (JulianDate.greaterThan(intervalStart, sampleStart)) {\n        sampleStart = intervalStart;\n      }\n\n      var sampleStop = stop;\n      if (JulianDate.lessThan(intervalStop, sampleStop)) {\n        sampleStop = intervalStop;\n      }\n\n      index = reallySubSample(\n        interval.data,\n        sampleStart,\n        sampleStop,\n        updateTime,\n        referenceFrame,\n        maximumStep,\n        index,\n        result\n      );\n    }\n  }\n  return index;\n}\n\nfunction reallySubSample(\n  property,\n  start,\n  stop,\n  updateTime,\n  referenceFrame,\n  maximumStep,\n  index,\n  result\n) {\n  //Unwrap any references until we have the actual property.\n  while (property instanceof ReferenceProperty) {\n    property = property.resolvedProperty;\n  }\n\n  if (property instanceof SampledPositionProperty) {\n    var times = property._property._times;\n    index = subSampleSampledProperty(\n      property,\n      start,\n      stop,\n      times,\n      updateTime,\n      referenceFrame,\n      maximumStep,\n      index,\n      result\n    );\n  } else if (property instanceof CompositePositionProperty) {\n    index = subSampleCompositeProperty(\n      property,\n      start,\n      stop,\n      updateTime,\n      referenceFrame,\n      maximumStep,\n      index,\n      result\n    );\n  } else if (property instanceof TimeIntervalCollectionPositionProperty) {\n    index = subSampleIntervalProperty(\n      property,\n      start,\n      stop,\n      updateTime,\n      referenceFrame,\n      maximumStep,\n      index,\n      result\n    );\n  } else if (\n    property instanceof ConstantPositionProperty ||\n    (property instanceof ScaledPositionProperty &&\n      Property.isConstant(property))\n  ) {\n    index = subSampleConstantProperty(\n      property,\n      start,\n      stop,\n      updateTime,\n      referenceFrame,\n      maximumStep,\n      index,\n      result\n    );\n  } else {\n    //Fallback to generic sampling.\n    index = subSampleGenericProperty(\n      property,\n      start,\n      stop,\n      updateTime,\n      referenceFrame,\n      maximumStep,\n      index,\n      result\n    );\n  }\n  return index;\n}\n\nfunction subSample(\n  property,\n  start,\n  stop,\n  updateTime,\n  referenceFrame,\n  maximumStep,\n  result\n) {\n  if (!defined(result)) {\n    result = [];\n  }\n\n  var length = reallySubSample(\n    property,\n    start,\n    stop,\n    updateTime,\n    referenceFrame,\n    maximumStep,\n    0,\n    result\n  );\n  result.length = length;\n  return result;\n}\n\nvar toFixedScratch = new Matrix3();\nfunction PolylineUpdater(scene, referenceFrame) {\n  this._unusedIndexes = [];\n  this._polylineCollection = new PolylineCollection();\n  this._scene = scene;\n  this._referenceFrame = referenceFrame;\n  scene.primitives.add(this._polylineCollection);\n}\n\nPolylineUpdater.prototype.update = function (time) {\n  if (this._referenceFrame === ReferenceFrame.INERTIAL) {\n    var toFixed = Transforms.computeIcrfToFixedMatrix(time, toFixedScratch);\n    if (!defined(toFixed)) {\n      toFixed = Transforms.computeTemeToPseudoFixedMatrix(time, toFixedScratch);\n    }\n    Matrix4.fromRotationTranslation(\n      toFixed,\n      Cartesian3.ZERO,\n      this._polylineCollection.modelMatrix\n    );\n  }\n};\n\nPolylineUpdater.prototype.updateObject = function (time, item) {\n  var entity = item.entity;\n  var pathGraphics = entity._path;\n  var positionProperty = entity._position;\n\n  var sampleStart;\n  var sampleStop;\n  var showProperty = pathGraphics._show;\n  var polyline = item.polyline;\n  var show =\n    entity.isShowing && (!defined(showProperty) || showProperty.getValue(time));\n\n  //While we want to show the path, there may not actually be anything to show\n  //depending on lead/trail settings.  Compute the interval of the path to\n  //show and check against actual availability.\n  if (show) {\n    var leadTime = Property.getValueOrUndefined(pathGraphics._leadTime, time);\n    var trailTime = Property.getValueOrUndefined(pathGraphics._trailTime, time);\n    var availability = entity._availability;\n    var hasAvailability = defined(availability);\n    var hasLeadTime = defined(leadTime);\n    var hasTrailTime = defined(trailTime);\n\n    //Objects need to have either defined availability or both a lead and trail time in order to\n    //draw a path (since we can't draw \"infinite\" paths.\n    show = hasAvailability || (hasLeadTime && hasTrailTime);\n\n    //The final step is to compute the actual start/stop times of the path to show.\n    //If current time is outside of the availability interval, there's a chance that\n    //we won't have to draw anything anyway.\n    if (show) {\n      if (hasTrailTime) {\n        sampleStart = JulianDate.addSeconds(time, -trailTime, new JulianDate());\n      }\n      if (hasLeadTime) {\n        sampleStop = JulianDate.addSeconds(time, leadTime, new JulianDate());\n      }\n\n      if (hasAvailability) {\n        var start = availability.start;\n        var stop = availability.stop;\n\n        if (!hasTrailTime || JulianDate.greaterThan(start, sampleStart)) {\n          sampleStart = start;\n        }\n\n        if (!hasLeadTime || JulianDate.lessThan(stop, sampleStop)) {\n          sampleStop = stop;\n        }\n      }\n      show = JulianDate.lessThan(sampleStart, sampleStop);\n    }\n  }\n\n  if (!show) {\n    //don't bother creating or updating anything else\n    if (defined(polyline)) {\n      this._unusedIndexes.push(item.index);\n      item.polyline = undefined;\n      polyline.show = false;\n      item.index = undefined;\n    }\n    return;\n  }\n\n  if (!defined(polyline)) {\n    var unusedIndexes = this._unusedIndexes;\n    var length = unusedIndexes.length;\n    if (length > 0) {\n      var index = unusedIndexes.pop();\n      polyline = this._polylineCollection.get(index);\n      item.index = index;\n    } else {\n      item.index = this._polylineCollection.length;\n      polyline = this._polylineCollection.add();\n    }\n    polyline.id = entity;\n    item.polyline = polyline;\n  }\n\n  var resolution = Property.getValueOrDefault(\n    pathGraphics._resolution,\n    time,\n    defaultResolution\n  );\n\n  polyline.show = true;\n  polyline.positions = subSample(\n    positionProperty,\n    sampleStart,\n    sampleStop,\n    time,\n    this._referenceFrame,\n    resolution,\n    polyline.positions.slice()\n  );\n  polyline.material = MaterialProperty.getValue(\n    time,\n    pathGraphics._material,\n    polyline.material\n  );\n  polyline.width = Property.getValueOrDefault(\n    pathGraphics._width,\n    time,\n    defaultWidth\n  );\n  polyline.distanceDisplayCondition = Property.getValueOrUndefined(\n    pathGraphics._distanceDisplayCondition,\n    time,\n    polyline.distanceDisplayCondition\n  );\n};\n\nPolylineUpdater.prototype.removeObject = function (item) {\n  var polyline = item.polyline;\n  if (defined(polyline)) {\n    this._unusedIndexes.push(item.index);\n    item.polyline = undefined;\n    polyline.show = false;\n    polyline.id = undefined;\n    item.index = undefined;\n  }\n};\n\nPolylineUpdater.prototype.destroy = function () {\n  this._scene.primitives.remove(this._polylineCollection);\n  return destroyObject(this);\n};\n\n/**\n * A {@link Visualizer} which maps {@link Entity#path} to a {@link Polyline}.\n * @alias PathVisualizer\n * @constructor\n *\n * @param {Scene} scene The scene the primitives will be rendered in.\n * @param {EntityCollection} entityCollection The entityCollection to visualize.\n */\nfunction PathVisualizer(scene, entityCollection) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  if (!defined(entityCollection)) {\n    throw new DeveloperError(\"entityCollection is required.\");\n  }\n  //>>includeEnd('debug');\n\n  entityCollection.collectionChanged.addEventListener(\n    PathVisualizer.prototype._onCollectionChanged,\n    this\n  );\n\n  this._scene = scene;\n  this._updaters = {};\n  this._entityCollection = entityCollection;\n  this._items = new AssociativeArray();\n\n  this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n}\n\n/**\n * Updates all of the primitives created by this visualizer to match their\n * Entity counterpart at the given time.\n *\n * @param {JulianDate} time The time to update to.\n * @returns {Boolean} This function always returns true.\n */\nPathVisualizer.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(time)) {\n    throw new DeveloperError(\"time is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var updaters = this._updaters;\n  for (var key in updaters) {\n    if (updaters.hasOwnProperty(key)) {\n      updaters[key].update(time);\n    }\n  }\n\n  var items = this._items.values;\n  if (\n    items.length === 0 &&\n    defined(this._updaters) &&\n    Object.keys(this._updaters).length > 0\n  ) {\n    for (var u in updaters) {\n      if (updaters.hasOwnProperty(u)) {\n        updaters[u].destroy();\n      }\n    }\n    this._updaters = {};\n  }\n\n  for (var i = 0, len = items.length; i < len; i++) {\n    var item = items[i];\n    var entity = item.entity;\n    var positionProperty = entity._position;\n\n    var lastUpdater = item.updater;\n\n    var frameToVisualize = ReferenceFrame.FIXED;\n    if (this._scene.mode === SceneMode.SCENE3D) {\n      frameToVisualize = positionProperty.referenceFrame;\n    }\n\n    var currentUpdater = this._updaters[frameToVisualize];\n\n    if (lastUpdater === currentUpdater && defined(currentUpdater)) {\n      currentUpdater.updateObject(time, item);\n      continue;\n    }\n\n    if (defined(lastUpdater)) {\n      lastUpdater.removeObject(item);\n    }\n\n    if (!defined(currentUpdater)) {\n      currentUpdater = new PolylineUpdater(this._scene, frameToVisualize);\n      currentUpdater.update(time);\n      this._updaters[frameToVisualize] = currentUpdater;\n    }\n\n    item.updater = currentUpdater;\n    if (defined(currentUpdater)) {\n      currentUpdater.updateObject(time, item);\n    }\n  }\n  return true;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n */\nPathVisualizer.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes and destroys all primitives created by this instance.\n */\nPathVisualizer.prototype.destroy = function () {\n  this._entityCollection.collectionChanged.removeEventListener(\n    PathVisualizer.prototype._onCollectionChanged,\n    this\n  );\n\n  var updaters = this._updaters;\n  for (var key in updaters) {\n    if (updaters.hasOwnProperty(key)) {\n      updaters[key].destroy();\n    }\n  }\n\n  return destroyObject(this);\n};\n\nPathVisualizer.prototype._onCollectionChanged = function (\n  entityCollection,\n  added,\n  removed,\n  changed\n) {\n  var i;\n  var entity;\n  var item;\n  var items = this._items;\n\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    if (defined(entity._path) && defined(entity._position)) {\n      items.set(entity.id, new EntityData(entity));\n    }\n  }\n\n  for (i = changed.length - 1; i > -1; i--) {\n    entity = changed[i];\n    if (defined(entity._path) && defined(entity._position)) {\n      if (!items.contains(entity.id)) {\n        items.set(entity.id, new EntityData(entity));\n      }\n    } else {\n      item = items.get(entity.id);\n      if (defined(item)) {\n        if (defined(item.updater)) {\n          item.updater.removeObject(item);\n        }\n        items.remove(entity.id);\n      }\n    }\n  }\n\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    item = items.get(entity.id);\n    if (defined(item)) {\n      if (defined(item.updater)) {\n        item.updater.removeObject(item);\n      }\n      items.remove(entity.id);\n    }\n  }\n};\n\n//for testing\nPathVisualizer._subSample = subSample;\nexport default PathVisualizer;\n"]},"metadata":{},"sourceType":"module"}