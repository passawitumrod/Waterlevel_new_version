{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport IonResource from \"../Core/IonResource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport when from \"../ThirdParty/when.js\";\nimport ArcGisMapServerImageryProvider from \"./ArcGisMapServerImageryProvider.js\";\nimport BingMapsImageryProvider from \"./BingMapsImageryProvider.js\";\nimport TileMapServiceImageryProvider from \"./TileMapServiceImageryProvider.js\";\nimport GoogleEarthEnterpriseMapsProvider from \"./GoogleEarthEnterpriseMapsProvider.js\";\nimport MapboxImageryProvider from \"./MapboxImageryProvider.js\";\nimport SingleTileImageryProvider from \"./SingleTileImageryProvider.js\";\nimport UrlTemplateImageryProvider from \"./UrlTemplateImageryProvider.js\";\nimport WebMapServiceImageryProvider from \"./WebMapServiceImageryProvider.js\";\nimport WebMapTileServiceImageryProvider from \"./WebMapTileServiceImageryProvider.js\";\n\nfunction createFactory(Type) {\n  return function (options) {\n    return new Type(options);\n  };\n} // These values are the list of supported external imagery\n// assets in the Cesium ion beta. They are subject to change.\n\n\nvar ImageryProviderMapping = {\n  ARCGIS_MAPSERVER: createFactory(ArcGisMapServerImageryProvider),\n  BING: createFactory(BingMapsImageryProvider),\n  GOOGLE_EARTH: createFactory(GoogleEarthEnterpriseMapsProvider),\n  MAPBOX: createFactory(MapboxImageryProvider),\n  SINGLE_TILE: createFactory(SingleTileImageryProvider),\n  TMS: createFactory(TileMapServiceImageryProvider),\n  URL_TEMPLATE: createFactory(UrlTemplateImageryProvider),\n  WMS: createFactory(WebMapServiceImageryProvider),\n  WMTS: createFactory(WebMapTileServiceImageryProvider)\n};\n/**\n * Provides tiled imagery using the Cesium ion REST API.\n *\n * @alias IonImageryProvider\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number} options.assetId An ion imagery asset ID;\n * @param {String} [options.accessToken=Ion.defaultAccessToken] The access token to use.\n * @param {String|Resource} [options.server=Ion.defaultServer] The resource to the Cesium ion API server.\n *\n * @example\n * viewer.imageryLayers.addImageryProvider(new Cesium.IonImageryProvider({ assetId : 23489024 }));\n */\n\nfunction IonImageryProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var assetId = options.assetId; //>>includeStart('debug', pragmas.debug);\n\n  Check.typeOf.number(\"options.assetId\", assetId); //>>includeEnd('debug');\n\n  /**\n   * The default alpha blending value of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number}\n   * @default undefined\n   */\n\n  this.defaultAlpha = undefined;\n  /**\n   * The default brightness of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0\n   * makes the imagery darker while greater than 1.0 makes it brighter.\n   *\n   * @type {Number}\n   * @default undefined\n   */\n\n  this.defaultBrightness = undefined;\n  /**\n   * The default contrast of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces\n   * the contrast while greater than 1.0 increases it.\n   *\n   * @type {Number}\n   * @default undefined\n   */\n\n  this.defaultContrast = undefined;\n  /**\n   * The default hue of this provider in radians. 0.0 uses the unmodified imagery color.\n   *\n   * @type {Number}\n   * @default undefined\n   */\n\n  this.defaultHue = undefined;\n  /**\n   * The default saturation of this provider. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the\n   * saturation while greater than 1.0 increases it.\n   *\n   * @type {Number}\n   * @default undefined\n   */\n\n  this.defaultSaturation = undefined;\n  /**\n   * The default gamma correction to apply to this provider.  1.0 uses the unmodified imagery color.\n   *\n   * @type {Number}\n   * @default undefined\n   */\n\n  this.defaultGamma = undefined;\n  /**\n   * The default texture minification filter to apply to this provider.\n   *\n   * @type {TextureMinificationFilter}\n   * @default undefined\n   */\n\n  this.defaultMinificationFilter = undefined;\n  /**\n   * The default texture magnification filter to apply to this provider.\n   *\n   * @type {TextureMagnificationFilter}\n   * @default undefined\n   */\n\n  this.defaultMagnificationFilter = undefined;\n  this._ready = false;\n  this._tileCredits = undefined;\n  this._errorEvent = new Event();\n  var that = this;\n\n  var endpointResource = IonResource._createEndpointResource(assetId, options); // A simple cache to avoid making repeated requests to ion for endpoints we've\n  // already retrieved. This exists mainly to support Bing caching to reduce\n  // world imagery sessions, but provides a small boost of performance in general\n  // if constantly reloading assets\n\n\n  var cacheKey = options.assetId.toString() + options.accessToken + options.server;\n  var promise = IonImageryProvider._endpointCache[cacheKey];\n\n  if (!defined(promise)) {\n    promise = endpointResource.fetchJson();\n    IonImageryProvider._endpointCache[cacheKey] = promise;\n  }\n\n  this._readyPromise = promise.then(function (endpoint) {\n    if (endpoint.type !== \"IMAGERY\") {\n      return when.reject(new RuntimeError(\"Cesium ion asset \" + assetId + \" is not an imagery asset.\"));\n    }\n\n    var imageryProvider;\n    var externalType = endpoint.externalType;\n\n    if (!defined(externalType)) {\n      imageryProvider = new TileMapServiceImageryProvider({\n        url: new IonResource(endpoint, endpointResource)\n      });\n    } else {\n      var factory = ImageryProviderMapping[externalType];\n\n      if (!defined(factory)) {\n        return when.reject(new RuntimeError(\"Unrecognized Cesium ion imagery type: \" + externalType));\n      }\n\n      imageryProvider = factory(endpoint.options);\n    }\n\n    that._tileCredits = IonResource.getCreditsFromEndpoint(endpoint, endpointResource);\n    imageryProvider.errorEvent.addEventListener(function (tileProviderError) {\n      //Propagate the errorEvent but set the provider to this instance instead\n      //of the inner instance.\n      tileProviderError.provider = that;\n\n      that._errorEvent.raiseEvent(tileProviderError);\n    });\n    that._imageryProvider = imageryProvider;\n    return imageryProvider.readyPromise.then(function () {\n      that._ready = true;\n      return true;\n    });\n  });\n}\n\nObject.defineProperties(IonImageryProvider.prototype, {\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof IonImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof IonImageryProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    }\n  },\n\n  /**\n   * Gets the rectangle, in radians, of the imagery provided by the instance.  This function should\n   * not be called before {@link IonImageryProvider#ready} returns true.\n   * @memberof IonImageryProvider.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  rectangle: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\"tileHeight must not be called before the imagery provider is ready.\");\n      } //>>includeEnd('debug');\n\n\n      return this._imageryProvider.rectangle;\n    }\n  },\n\n  /**\n   * Gets the width of each tile, in pixels.  This function should\n   * not be called before {@link IonImageryProvider#ready} returns true.\n   * @memberof IonImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileWidth: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\"tileWidth must not be called before the imagery provider is ready.\");\n      } //>>includeEnd('debug');\n\n\n      return this._imageryProvider.tileWidth;\n    }\n  },\n\n  /**\n   * Gets the height of each tile, in pixels.  This function should\n   * not be called before {@link IonImageryProvider#ready} returns true.\n   * @memberof IonImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileHeight: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\"tileHeight must not be called before the imagery provider is ready.\");\n      } //>>includeEnd('debug');\n\n\n      return this._imageryProvider.tileHeight;\n    }\n  },\n\n  /**\n   * Gets the maximum level-of-detail that can be requested.  This function should\n   * not be called before {@link IonImageryProvider#ready} returns true.\n   * @memberof IonImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  maximumLevel: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\"maximumLevel must not be called before the imagery provider is ready.\");\n      } //>>includeEnd('debug');\n\n\n      return this._imageryProvider.maximumLevel;\n    }\n  },\n\n  /**\n   * Gets the minimum level-of-detail that can be requested.  This function should\n   * not be called before {@link IonImageryProvider#ready} returns true. Generally,\n   * a minimum level should only be used when the rectangle of the imagery is small\n   * enough that the number of tiles at the minimum level is small.  An imagery\n   * provider with more than a few tiles at the minimum level will lead to\n   * rendering problems.\n   * @memberof IonImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  minimumLevel: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\"minimumLevel must not be called before the imagery provider is ready.\");\n      } //>>includeEnd('debug');\n\n\n      return this._imageryProvider.minimumLevel;\n    }\n  },\n\n  /**\n   * Gets the tiling scheme used by the provider.  This function should\n   * not be called before {@link IonImageryProvider#ready} returns true.\n   * @memberof IonImageryProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\"tilingScheme must not be called before the imagery provider is ready.\");\n      } //>>includeEnd('debug');\n\n\n      return this._imageryProvider.tilingScheme;\n    }\n  },\n\n  /**\n   * Gets the tile discard policy.  If not undefined, the discard policy is responsible\n   * for filtering out \"missing\" tiles via its shouldDiscardImage function.  If this function\n   * returns undefined, no tiles are filtered.  This function should\n   * not be called before {@link IonImageryProvider#ready} returns true.\n   * @memberof IonImageryProvider.prototype\n   * @type {TileDiscardPolicy}\n   * @readonly\n   */\n  tileDiscardPolicy: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\"tileDiscardPolicy must not be called before the imagery provider is ready.\");\n      } //>>includeEnd('debug');\n\n\n      return this._imageryProvider.tileDiscardPolicy;\n    }\n  },\n\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof IonImageryProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    }\n  },\n\n  /**\n   * Gets the credit to display when this imagery provider is active.  Typically this is used to credit\n   * the source of the imagery. This function should\n   * not be called before {@link IonImageryProvider#ready} returns true.\n   * @memberof IonImageryProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\"credit must not be called before the imagery provider is ready.\");\n      } //>>includeEnd('debug');\n\n\n      return this._imageryProvider.credit;\n    }\n  },\n\n  /**\n   * Gets a value indicating whether or not the images provided by this imagery provider\n   * include an alpha channel.  If this property is false, an alpha channel, if present, will\n   * be ignored.  If this property is true, any images without an alpha channel will be treated\n   * as if their alpha is 1.0 everywhere.  When this property is false, memory usage\n   * and texture upload time are reduced.\n   * @memberof IonImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasAlphaChannel: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\"hasAlphaChannel must not be called before the imagery provider is ready.\");\n      } //>>includeEnd('debug');\n\n\n      return this._imageryProvider.hasAlphaChannel;\n    }\n  }\n});\n/**\n * Gets the credits to be displayed when a given tile is displayed.\n * @function\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level;\n * @returns {Credit[]} The credits to be displayed when the tile is displayed.\n *\n * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.\n */\n\nIonImageryProvider.prototype.getTileCredits = function (x, y, level) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._ready) {\n    throw new DeveloperError(\"getTileCredits must not be called before the imagery provider is ready.\");\n  } //>>includeEnd('debug');\n\n\n  var innerCredits = this._imageryProvider.getTileCredits(x, y, level);\n\n  if (!defined(innerCredits)) {\n    return this._tileCredits;\n  }\n\n  return this._tileCredits.concat(innerCredits);\n};\n/**\n * Requests the image for a given tile.  This function should\n * not be called before {@link IonImageryProvider#ready} returns true.\n * @function\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<Image|Canvas>|undefined} A promise for the image that will resolve when the image is available, or\n *          undefined if there are too many active requests to the server, and the request\n *          should be retried later.  The resolved image may be either an\n *          Image or a Canvas DOM object.\n *\n * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.\n */\n\n\nIonImageryProvider.prototype.requestImage = function (x, y, level, request) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._ready) {\n    throw new DeveloperError(\"requestImage must not be called before the imagery provider is ready.\");\n  } //>>includeEnd('debug');\n\n\n  return this._imageryProvider.requestImage(x, y, level, request);\n};\n/**\n * Asynchronously determines what features, if any, are located at a given longitude and latitude within\n * a tile.  This function should not be called before {@link IonImageryProvider#ready} returns true.\n * This function is optional, so it may not exist on all ImageryProviders.\n *\n * @function\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Number} longitude The longitude at which to pick features.\n * @param {Number} latitude  The latitude at which to pick features.\n * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve when the asynchronous\n *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}\n *                   instances.  The array may be empty if no features are found at the given location.\n *                   It may also be undefined if picking is not supported.\n *\n * @exception {DeveloperError} <code>pickFeatures</code> must not be called before the imagery provider is ready.\n */\n\n\nIonImageryProvider.prototype.pickFeatures = function (x, y, level, longitude, latitude) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._ready) {\n    throw new DeveloperError(\"pickFeatures must not be called before the imagery provider is ready.\");\n  } //>>includeEnd('debug');\n\n\n  return this._imageryProvider.pickFeatures(x, y, level, longitude, latitude);\n}; //exposed for testing\n\n\nIonImageryProvider._endpointCache = {};\nexport default IonImageryProvider;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Scene/IonImageryProvider.js"],"names":["Check","defaultValue","defined","DeveloperError","Event","IonResource","RuntimeError","when","ArcGisMapServerImageryProvider","BingMapsImageryProvider","TileMapServiceImageryProvider","GoogleEarthEnterpriseMapsProvider","MapboxImageryProvider","SingleTileImageryProvider","UrlTemplateImageryProvider","WebMapServiceImageryProvider","WebMapTileServiceImageryProvider","createFactory","Type","options","ImageryProviderMapping","ARCGIS_MAPSERVER","BING","GOOGLE_EARTH","MAPBOX","SINGLE_TILE","TMS","URL_TEMPLATE","WMS","WMTS","IonImageryProvider","EMPTY_OBJECT","assetId","typeOf","number","defaultAlpha","undefined","defaultBrightness","defaultContrast","defaultHue","defaultSaturation","defaultGamma","defaultMinificationFilter","defaultMagnificationFilter","_ready","_tileCredits","_errorEvent","that","endpointResource","_createEndpointResource","cacheKey","toString","accessToken","server","promise","_endpointCache","fetchJson","_readyPromise","then","endpoint","type","reject","imageryProvider","externalType","url","factory","getCreditsFromEndpoint","errorEvent","addEventListener","tileProviderError","provider","raiseEvent","_imageryProvider","readyPromise","Object","defineProperties","prototype","ready","get","rectangle","tileWidth","tileHeight","maximumLevel","minimumLevel","tilingScheme","tileDiscardPolicy","credit","hasAlphaChannel","getTileCredits","x","y","level","innerCredits","concat","requestImage","request","pickFeatures","longitude","latitude"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,kBAAlB;AACA,OAAOC,YAAP,MAAyB,yBAAzB;AACA,OAAOC,OAAP,MAAoB,oBAApB;AACA,OAAOC,cAAP,MAA2B,2BAA3B;AACA,OAAOC,KAAP,MAAkB,kBAAlB;AACA,OAAOC,WAAP,MAAwB,wBAAxB;AACA,OAAOC,YAAP,MAAyB,yBAAzB;AACA,OAAOC,IAAP,MAAiB,uBAAjB;AACA,OAAOC,8BAAP,MAA2C,qCAA3C;AACA,OAAOC,uBAAP,MAAoC,8BAApC;AACA,OAAOC,6BAAP,MAA0C,oCAA1C;AACA,OAAOC,iCAAP,MAA8C,wCAA9C;AACA,OAAOC,qBAAP,MAAkC,4BAAlC;AACA,OAAOC,yBAAP,MAAsC,gCAAtC;AACA,OAAOC,0BAAP,MAAuC,iCAAvC;AACA,OAAOC,4BAAP,MAAyC,mCAAzC;AACA,OAAOC,gCAAP,MAA6C,uCAA7C;;AAEA,SAASC,aAAT,CAAuBC,IAAvB,EAA6B;AAC3B,SAAO,UAAUC,OAAV,EAAmB;AACxB,WAAO,IAAID,IAAJ,CAASC,OAAT,CAAP;AACD,GAFD;AAGD,C,CAED;AACA;;;AACA,IAAIC,sBAAsB,GAAG;AAC3BC,EAAAA,gBAAgB,EAAEJ,aAAa,CAACT,8BAAD,CADJ;AAE3Bc,EAAAA,IAAI,EAAEL,aAAa,CAACR,uBAAD,CAFQ;AAG3Bc,EAAAA,YAAY,EAAEN,aAAa,CAACN,iCAAD,CAHA;AAI3Ba,EAAAA,MAAM,EAAEP,aAAa,CAACL,qBAAD,CAJM;AAK3Ba,EAAAA,WAAW,EAAER,aAAa,CAACJ,yBAAD,CALC;AAM3Ba,EAAAA,GAAG,EAAET,aAAa,CAACP,6BAAD,CANS;AAO3BiB,EAAAA,YAAY,EAAEV,aAAa,CAACH,0BAAD,CAPA;AAQ3Bc,EAAAA,GAAG,EAAEX,aAAa,CAACF,4BAAD,CARS;AAS3Bc,EAAAA,IAAI,EAAEZ,aAAa,CAACD,gCAAD;AATQ,CAA7B;AAYA;;;;;;;;;;;;;;;AAcA,SAASc,kBAAT,CAA4BX,OAA5B,EAAqC;AACnCA,EAAAA,OAAO,GAAGlB,YAAY,CAACkB,OAAD,EAAUlB,YAAY,CAAC8B,YAAvB,CAAtB;AAEA,MAAIC,OAAO,GAAGb,OAAO,CAACa,OAAtB,CAHmC,CAInC;;AACAhC,EAAAA,KAAK,CAACiC,MAAN,CAAaC,MAAb,CAAoB,iBAApB,EAAuCF,OAAvC,EALmC,CAMnC;;AAEA;;;;;;;;AAOA,OAAKG,YAAL,GAAoBC,SAApB;AAEA;;;;;;;;AAOA,OAAKC,iBAAL,GAAyBD,SAAzB;AAEA;;;;;;;;AAOA,OAAKE,eAAL,GAAuBF,SAAvB;AAEA;;;;;;;AAMA,OAAKG,UAAL,GAAkBH,SAAlB;AAEA;;;;;;;;AAOA,OAAKI,iBAAL,GAAyBJ,SAAzB;AAEA;;;;;;;AAMA,OAAKK,YAAL,GAAoBL,SAApB;AAEA;;;;;;;AAMA,OAAKM,yBAAL,GAAiCN,SAAjC;AAEA;;;;;;;AAMA,OAAKO,0BAAL,GAAkCP,SAAlC;AAEA,OAAKQ,MAAL,GAAc,KAAd;AACA,OAAKC,YAAL,GAAoBT,SAApB;AACA,OAAKU,WAAL,GAAmB,IAAI1C,KAAJ,EAAnB;AAEA,MAAI2C,IAAI,GAAG,IAAX;;AACA,MAAIC,gBAAgB,GAAG3C,WAAW,CAAC4C,uBAAZ,CAAoCjB,OAApC,EAA6Cb,OAA7C,CAAvB,CAjFmC,CAmFnC;AACA;AACA;AACA;;;AACA,MAAI+B,QAAQ,GACV/B,OAAO,CAACa,OAAR,CAAgBmB,QAAhB,KAA6BhC,OAAO,CAACiC,WAArC,GAAmDjC,OAAO,CAACkC,MAD7D;AAEA,MAAIC,OAAO,GAAGxB,kBAAkB,CAACyB,cAAnB,CAAkCL,QAAlC,CAAd;;AACA,MAAI,CAAChD,OAAO,CAACoD,OAAD,CAAZ,EAAuB;AACrBA,IAAAA,OAAO,GAAGN,gBAAgB,CAACQ,SAAjB,EAAV;AACA1B,IAAAA,kBAAkB,CAACyB,cAAnB,CAAkCL,QAAlC,IAA8CI,OAA9C;AACD;;AAED,OAAKG,aAAL,GAAqBH,OAAO,CAACI,IAAR,CAAa,UAAUC,QAAV,EAAoB;AACpD,QAAIA,QAAQ,CAACC,IAAT,KAAkB,SAAtB,EAAiC;AAC/B,aAAOrD,IAAI,CAACsD,MAAL,CACL,IAAIvD,YAAJ,CACE,sBAAsB0B,OAAtB,GAAgC,2BADlC,CADK,CAAP;AAKD;;AAED,QAAI8B,eAAJ;AACA,QAAIC,YAAY,GAAGJ,QAAQ,CAACI,YAA5B;;AACA,QAAI,CAAC7D,OAAO,CAAC6D,YAAD,CAAZ,EAA4B;AAC1BD,MAAAA,eAAe,GAAG,IAAIpD,6BAAJ,CAAkC;AAClDsD,QAAAA,GAAG,EAAE,IAAI3D,WAAJ,CAAgBsD,QAAhB,EAA0BX,gBAA1B;AAD6C,OAAlC,CAAlB;AAGD,KAJD,MAIO;AACL,UAAIiB,OAAO,GAAG7C,sBAAsB,CAAC2C,YAAD,CAApC;;AAEA,UAAI,CAAC7D,OAAO,CAAC+D,OAAD,CAAZ,EAAuB;AACrB,eAAO1D,IAAI,CAACsD,MAAL,CACL,IAAIvD,YAAJ,CACE,2CAA2CyD,YAD7C,CADK,CAAP;AAKD;;AACDD,MAAAA,eAAe,GAAGG,OAAO,CAACN,QAAQ,CAACxC,OAAV,CAAzB;AACD;;AAED4B,IAAAA,IAAI,CAACF,YAAL,GAAoBxC,WAAW,CAAC6D,sBAAZ,CAClBP,QADkB,EAElBX,gBAFkB,CAApB;AAKAc,IAAAA,eAAe,CAACK,UAAhB,CAA2BC,gBAA3B,CAA4C,UAAUC,iBAAV,EAA6B;AACvE;AACA;AACAA,MAAAA,iBAAiB,CAACC,QAAlB,GAA6BvB,IAA7B;;AACAA,MAAAA,IAAI,CAACD,WAAL,CAAiByB,UAAjB,CAA4BF,iBAA5B;AACD,KALD;AAOAtB,IAAAA,IAAI,CAACyB,gBAAL,GAAwBV,eAAxB;AACA,WAAOA,eAAe,CAACW,YAAhB,CAA6Bf,IAA7B,CAAkC,YAAY;AACnDX,MAAAA,IAAI,CAACH,MAAL,GAAc,IAAd;AACA,aAAO,IAAP;AACD,KAHM,CAAP;AAID,GA7CoB,CAArB;AA8CD;;AAED8B,MAAM,CAACC,gBAAP,CAAwB7C,kBAAkB,CAAC8C,SAA3C,EAAsD;AACpD;;;;;;AAMAC,EAAAA,KAAK,EAAE;AACLC,IAAAA,GAAG,EAAE,YAAY;AACf,aAAO,KAAKlC,MAAZ;AACD;AAHI,GAP6C;;AAapD;;;;;;AAMA6B,EAAAA,YAAY,EAAE;AACZK,IAAAA,GAAG,EAAE,YAAY;AACf,aAAO,KAAKrB,aAAZ;AACD;AAHW,GAnBsC;;AAyBpD;;;;;;;AAOAsB,EAAAA,SAAS,EAAE;AACTD,IAAAA,GAAG,EAAE,YAAY;AACf;AACA,UAAI,CAAC,KAAKlC,MAAV,EAAkB;AAChB,cAAM,IAAIzC,cAAJ,CACJ,qEADI,CAAN;AAGD,OANc,CAOf;;;AACA,aAAO,KAAKqE,gBAAL,CAAsBO,SAA7B;AACD;AAVQ,GAhCyC;;AA6CpD;;;;;;;AAOAC,EAAAA,SAAS,EAAE;AACTF,IAAAA,GAAG,EAAE,YAAY;AACf;AACA,UAAI,CAAC,KAAKlC,MAAV,EAAkB;AAChB,cAAM,IAAIzC,cAAJ,CACJ,oEADI,CAAN;AAGD,OANc,CAOf;;;AACA,aAAO,KAAKqE,gBAAL,CAAsBQ,SAA7B;AACD;AAVQ,GApDyC;;AAiEpD;;;;;;;AAOAC,EAAAA,UAAU,EAAE;AACVH,IAAAA,GAAG,EAAE,YAAY;AACf;AACA,UAAI,CAAC,KAAKlC,MAAV,EAAkB;AAChB,cAAM,IAAIzC,cAAJ,CACJ,qEADI,CAAN;AAGD,OANc,CAOf;;;AACA,aAAO,KAAKqE,gBAAL,CAAsBS,UAA7B;AACD;AAVS,GAxEwC;;AAqFpD;;;;;;;AAOAC,EAAAA,YAAY,EAAE;AACZJ,IAAAA,GAAG,EAAE,YAAY;AACf;AACA,UAAI,CAAC,KAAKlC,MAAV,EAAkB;AAChB,cAAM,IAAIzC,cAAJ,CACJ,uEADI,CAAN;AAGD,OANc,CAOf;;;AACA,aAAO,KAAKqE,gBAAL,CAAsBU,YAA7B;AACD;AAVW,GA5FsC;;AAyGpD;;;;;;;;;;;AAWAC,EAAAA,YAAY,EAAE;AACZL,IAAAA,GAAG,EAAE,YAAY;AACf;AACA,UAAI,CAAC,KAAKlC,MAAV,EAAkB;AAChB,cAAM,IAAIzC,cAAJ,CACJ,uEADI,CAAN;AAGD,OANc,CAOf;;;AACA,aAAO,KAAKqE,gBAAL,CAAsBW,YAA7B;AACD;AAVW,GApHsC;;AAiIpD;;;;;;;AAOAC,EAAAA,YAAY,EAAE;AACZN,IAAAA,GAAG,EAAE,YAAY;AACf;AACA,UAAI,CAAC,KAAKlC,MAAV,EAAkB;AAChB,cAAM,IAAIzC,cAAJ,CACJ,uEADI,CAAN;AAGD,OANc,CAOf;;;AACA,aAAO,KAAKqE,gBAAL,CAAsBY,YAA7B;AACD;AAVW,GAxIsC;;AAqJpD;;;;;;;;;AASAC,EAAAA,iBAAiB,EAAE;AACjBP,IAAAA,GAAG,EAAE,YAAY;AACf;AACA,UAAI,CAAC,KAAKlC,MAAV,EAAkB;AAChB,cAAM,IAAIzC,cAAJ,CACJ,4EADI,CAAN;AAGD,OANc,CAOf;;;AACA,aAAO,KAAKqE,gBAAL,CAAsBa,iBAA7B;AACD;AAVgB,GA9JiC;;AA2KpD;;;;;;;;AAQAlB,EAAAA,UAAU,EAAE;AACVW,IAAAA,GAAG,EAAE,YAAY;AACf,aAAO,KAAKhC,WAAZ;AACD;AAHS,GAnLwC;;AAyLpD;;;;;;;;AAQAwC,EAAAA,MAAM,EAAE;AACNR,IAAAA,GAAG,EAAE,YAAY;AACf;AACA,UAAI,CAAC,KAAKlC,MAAV,EAAkB;AAChB,cAAM,IAAIzC,cAAJ,CACJ,iEADI,CAAN;AAGD,OANc,CAOf;;;AACA,aAAO,KAAKqE,gBAAL,CAAsBc,MAA7B;AACD;AAVK,GAjM4C;;AA8MpD;;;;;;;;;;AAUAC,EAAAA,eAAe,EAAE;AACfT,IAAAA,GAAG,EAAE,YAAY;AACf;AACA,UAAI,CAAC,KAAKlC,MAAV,EAAkB;AAChB,cAAM,IAAIzC,cAAJ,CACJ,0EADI,CAAN;AAGD,OANc,CAOf;;;AACA,aAAO,KAAKqE,gBAAL,CAAsBe,eAA7B;AACD;AAVc;AAxNmC,CAAtD;AAsOA;;;;;;;;;;;;AAWAzD,kBAAkB,CAAC8C,SAAnB,CAA6BY,cAA7B,GAA8C,UAAUC,CAAV,EAAaC,CAAb,EAAgBC,KAAhB,EAAuB;AACnE;AACA,MAAI,CAAC,KAAK/C,MAAV,EAAkB;AAChB,UAAM,IAAIzC,cAAJ,CACJ,yEADI,CAAN;AAGD,GANkE,CAOnE;;;AAEA,MAAIyF,YAAY,GAAG,KAAKpB,gBAAL,CAAsBgB,cAAtB,CAAqCC,CAArC,EAAwCC,CAAxC,EAA2CC,KAA3C,CAAnB;;AACA,MAAI,CAACzF,OAAO,CAAC0F,YAAD,CAAZ,EAA4B;AAC1B,WAAO,KAAK/C,YAAZ;AACD;;AAED,SAAO,KAAKA,YAAL,CAAkBgD,MAAlB,CAAyBD,YAAzB,CAAP;AACD,CAfD;AAiBA;;;;;;;;;;;;;;;;;;AAgBA9D,kBAAkB,CAAC8C,SAAnB,CAA6BkB,YAA7B,GAA4C,UAAUL,CAAV,EAAaC,CAAb,EAAgBC,KAAhB,EAAuBI,OAAvB,EAAgC;AAC1E;AACA,MAAI,CAAC,KAAKnD,MAAV,EAAkB;AAChB,UAAM,IAAIzC,cAAJ,CACJ,uEADI,CAAN;AAGD,GANyE,CAO1E;;;AACA,SAAO,KAAKqE,gBAAL,CAAsBsB,YAAtB,CAAmCL,CAAnC,EAAsCC,CAAtC,EAAyCC,KAAzC,EAAgDI,OAAhD,CAAP;AACD,CATD;AAWA;;;;;;;;;;;;;;;;;;;;;AAmBAjE,kBAAkB,CAAC8C,SAAnB,CAA6BoB,YAA7B,GAA4C,UAC1CP,CAD0C,EAE1CC,CAF0C,EAG1CC,KAH0C,EAI1CM,SAJ0C,EAK1CC,QAL0C,EAM1C;AACA;AACA,MAAI,CAAC,KAAKtD,MAAV,EAAkB;AAChB,UAAM,IAAIzC,cAAJ,CACJ,uEADI,CAAN;AAGD,GAND,CAOA;;;AACA,SAAO,KAAKqE,gBAAL,CAAsBwB,YAAtB,CAAmCP,CAAnC,EAAsCC,CAAtC,EAAyCC,KAAzC,EAAgDM,SAAhD,EAA2DC,QAA3D,CAAP;AACD,CAfD,C,CAiBA;;;AACApE,kBAAkB,CAACyB,cAAnB,GAAoC,EAApC;AACA,eAAezB,kBAAf","sourcesContent":["import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport IonResource from \"../Core/IonResource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport when from \"../ThirdParty/when.js\";\nimport ArcGisMapServerImageryProvider from \"./ArcGisMapServerImageryProvider.js\";\nimport BingMapsImageryProvider from \"./BingMapsImageryProvider.js\";\nimport TileMapServiceImageryProvider from \"./TileMapServiceImageryProvider.js\";\nimport GoogleEarthEnterpriseMapsProvider from \"./GoogleEarthEnterpriseMapsProvider.js\";\nimport MapboxImageryProvider from \"./MapboxImageryProvider.js\";\nimport SingleTileImageryProvider from \"./SingleTileImageryProvider.js\";\nimport UrlTemplateImageryProvider from \"./UrlTemplateImageryProvider.js\";\nimport WebMapServiceImageryProvider from \"./WebMapServiceImageryProvider.js\";\nimport WebMapTileServiceImageryProvider from \"./WebMapTileServiceImageryProvider.js\";\n\nfunction createFactory(Type) {\n  return function (options) {\n    return new Type(options);\n  };\n}\n\n// These values are the list of supported external imagery\n// assets in the Cesium ion beta. They are subject to change.\nvar ImageryProviderMapping = {\n  ARCGIS_MAPSERVER: createFactory(ArcGisMapServerImageryProvider),\n  BING: createFactory(BingMapsImageryProvider),\n  GOOGLE_EARTH: createFactory(GoogleEarthEnterpriseMapsProvider),\n  MAPBOX: createFactory(MapboxImageryProvider),\n  SINGLE_TILE: createFactory(SingleTileImageryProvider),\n  TMS: createFactory(TileMapServiceImageryProvider),\n  URL_TEMPLATE: createFactory(UrlTemplateImageryProvider),\n  WMS: createFactory(WebMapServiceImageryProvider),\n  WMTS: createFactory(WebMapTileServiceImageryProvider),\n};\n\n/**\n * Provides tiled imagery using the Cesium ion REST API.\n *\n * @alias IonImageryProvider\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number} options.assetId An ion imagery asset ID;\n * @param {String} [options.accessToken=Ion.defaultAccessToken] The access token to use.\n * @param {String|Resource} [options.server=Ion.defaultServer] The resource to the Cesium ion API server.\n *\n * @example\n * viewer.imageryLayers.addImageryProvider(new Cesium.IonImageryProvider({ assetId : 23489024 }));\n */\nfunction IonImageryProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var assetId = options.assetId;\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"options.assetId\", assetId);\n  //>>includeEnd('debug');\n\n  /**\n   * The default alpha blending value of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number}\n   * @default undefined\n   */\n  this.defaultAlpha = undefined;\n\n  /**\n   * The default brightness of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0\n   * makes the imagery darker while greater than 1.0 makes it brighter.\n   *\n   * @type {Number}\n   * @default undefined\n   */\n  this.defaultBrightness = undefined;\n\n  /**\n   * The default contrast of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces\n   * the contrast while greater than 1.0 increases it.\n   *\n   * @type {Number}\n   * @default undefined\n   */\n  this.defaultContrast = undefined;\n\n  /**\n   * The default hue of this provider in radians. 0.0 uses the unmodified imagery color.\n   *\n   * @type {Number}\n   * @default undefined\n   */\n  this.defaultHue = undefined;\n\n  /**\n   * The default saturation of this provider. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the\n   * saturation while greater than 1.0 increases it.\n   *\n   * @type {Number}\n   * @default undefined\n   */\n  this.defaultSaturation = undefined;\n\n  /**\n   * The default gamma correction to apply to this provider.  1.0 uses the unmodified imagery color.\n   *\n   * @type {Number}\n   * @default undefined\n   */\n  this.defaultGamma = undefined;\n\n  /**\n   * The default texture minification filter to apply to this provider.\n   *\n   * @type {TextureMinificationFilter}\n   * @default undefined\n   */\n  this.defaultMinificationFilter = undefined;\n\n  /**\n   * The default texture magnification filter to apply to this provider.\n   *\n   * @type {TextureMagnificationFilter}\n   * @default undefined\n   */\n  this.defaultMagnificationFilter = undefined;\n\n  this._ready = false;\n  this._tileCredits = undefined;\n  this._errorEvent = new Event();\n\n  var that = this;\n  var endpointResource = IonResource._createEndpointResource(assetId, options);\n\n  // A simple cache to avoid making repeated requests to ion for endpoints we've\n  // already retrieved. This exists mainly to support Bing caching to reduce\n  // world imagery sessions, but provides a small boost of performance in general\n  // if constantly reloading assets\n  var cacheKey =\n    options.assetId.toString() + options.accessToken + options.server;\n  var promise = IonImageryProvider._endpointCache[cacheKey];\n  if (!defined(promise)) {\n    promise = endpointResource.fetchJson();\n    IonImageryProvider._endpointCache[cacheKey] = promise;\n  }\n\n  this._readyPromise = promise.then(function (endpoint) {\n    if (endpoint.type !== \"IMAGERY\") {\n      return when.reject(\n        new RuntimeError(\n          \"Cesium ion asset \" + assetId + \" is not an imagery asset.\"\n        )\n      );\n    }\n\n    var imageryProvider;\n    var externalType = endpoint.externalType;\n    if (!defined(externalType)) {\n      imageryProvider = new TileMapServiceImageryProvider({\n        url: new IonResource(endpoint, endpointResource),\n      });\n    } else {\n      var factory = ImageryProviderMapping[externalType];\n\n      if (!defined(factory)) {\n        return when.reject(\n          new RuntimeError(\n            \"Unrecognized Cesium ion imagery type: \" + externalType\n          )\n        );\n      }\n      imageryProvider = factory(endpoint.options);\n    }\n\n    that._tileCredits = IonResource.getCreditsFromEndpoint(\n      endpoint,\n      endpointResource\n    );\n\n    imageryProvider.errorEvent.addEventListener(function (tileProviderError) {\n      //Propagate the errorEvent but set the provider to this instance instead\n      //of the inner instance.\n      tileProviderError.provider = that;\n      that._errorEvent.raiseEvent(tileProviderError);\n    });\n\n    that._imageryProvider = imageryProvider;\n    return imageryProvider.readyPromise.then(function () {\n      that._ready = true;\n      return true;\n    });\n  });\n}\n\nObject.defineProperties(IonImageryProvider.prototype, {\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof IonImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof IonImageryProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n\n  /**\n   * Gets the rectangle, in radians, of the imagery provided by the instance.  This function should\n   * not be called before {@link IonImageryProvider#ready} returns true.\n   * @memberof IonImageryProvider.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  rectangle: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tileHeight must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._imageryProvider.rectangle;\n    },\n  },\n\n  /**\n   * Gets the width of each tile, in pixels.  This function should\n   * not be called before {@link IonImageryProvider#ready} returns true.\n   * @memberof IonImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileWidth: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tileWidth must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._imageryProvider.tileWidth;\n    },\n  },\n\n  /**\n   * Gets the height of each tile, in pixels.  This function should\n   * not be called before {@link IonImageryProvider#ready} returns true.\n   * @memberof IonImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileHeight: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tileHeight must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._imageryProvider.tileHeight;\n    },\n  },\n\n  /**\n   * Gets the maximum level-of-detail that can be requested.  This function should\n   * not be called before {@link IonImageryProvider#ready} returns true.\n   * @memberof IonImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  maximumLevel: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"maximumLevel must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._imageryProvider.maximumLevel;\n    },\n  },\n\n  /**\n   * Gets the minimum level-of-detail that can be requested.  This function should\n   * not be called before {@link IonImageryProvider#ready} returns true. Generally,\n   * a minimum level should only be used when the rectangle of the imagery is small\n   * enough that the number of tiles at the minimum level is small.  An imagery\n   * provider with more than a few tiles at the minimum level will lead to\n   * rendering problems.\n   * @memberof IonImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  minimumLevel: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"minimumLevel must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._imageryProvider.minimumLevel;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by the provider.  This function should\n   * not be called before {@link IonImageryProvider#ready} returns true.\n   * @memberof IonImageryProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tilingScheme must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._imageryProvider.tilingScheme;\n    },\n  },\n\n  /**\n   * Gets the tile discard policy.  If not undefined, the discard policy is responsible\n   * for filtering out \"missing\" tiles via its shouldDiscardImage function.  If this function\n   * returns undefined, no tiles are filtered.  This function should\n   * not be called before {@link IonImageryProvider#ready} returns true.\n   * @memberof IonImageryProvider.prototype\n   * @type {TileDiscardPolicy}\n   * @readonly\n   */\n  tileDiscardPolicy: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tileDiscardPolicy must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._imageryProvider.tileDiscardPolicy;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof IonImageryProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this imagery provider is active.  Typically this is used to credit\n   * the source of the imagery. This function should\n   * not be called before {@link IonImageryProvider#ready} returns true.\n   * @memberof IonImageryProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"credit must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._imageryProvider.credit;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the images provided by this imagery provider\n   * include an alpha channel.  If this property is false, an alpha channel, if present, will\n   * be ignored.  If this property is true, any images without an alpha channel will be treated\n   * as if their alpha is 1.0 everywhere.  When this property is false, memory usage\n   * and texture upload time are reduced.\n   * @memberof IonImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasAlphaChannel: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"hasAlphaChannel must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._imageryProvider.hasAlphaChannel;\n    },\n  },\n});\n\n/**\n * Gets the credits to be displayed when a given tile is displayed.\n * @function\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level;\n * @returns {Credit[]} The credits to be displayed when the tile is displayed.\n *\n * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.\n */\nIonImageryProvider.prototype.getTileCredits = function (x, y, level) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._ready) {\n    throw new DeveloperError(\n      \"getTileCredits must not be called before the imagery provider is ready.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var innerCredits = this._imageryProvider.getTileCredits(x, y, level);\n  if (!defined(innerCredits)) {\n    return this._tileCredits;\n  }\n\n  return this._tileCredits.concat(innerCredits);\n};\n\n/**\n * Requests the image for a given tile.  This function should\n * not be called before {@link IonImageryProvider#ready} returns true.\n * @function\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<Image|Canvas>|undefined} A promise for the image that will resolve when the image is available, or\n *          undefined if there are too many active requests to the server, and the request\n *          should be retried later.  The resolved image may be either an\n *          Image or a Canvas DOM object.\n *\n * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.\n */\nIonImageryProvider.prototype.requestImage = function (x, y, level, request) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._ready) {\n    throw new DeveloperError(\n      \"requestImage must not be called before the imagery provider is ready.\"\n    );\n  }\n  //>>includeEnd('debug');\n  return this._imageryProvider.requestImage(x, y, level, request);\n};\n\n/**\n * Asynchronously determines what features, if any, are located at a given longitude and latitude within\n * a tile.  This function should not be called before {@link IonImageryProvider#ready} returns true.\n * This function is optional, so it may not exist on all ImageryProviders.\n *\n * @function\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Number} longitude The longitude at which to pick features.\n * @param {Number} latitude  The latitude at which to pick features.\n * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve when the asynchronous\n *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}\n *                   instances.  The array may be empty if no features are found at the given location.\n *                   It may also be undefined if picking is not supported.\n *\n * @exception {DeveloperError} <code>pickFeatures</code> must not be called before the imagery provider is ready.\n */\nIonImageryProvider.prototype.pickFeatures = function (\n  x,\n  y,\n  level,\n  longitude,\n  latitude\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._ready) {\n    throw new DeveloperError(\n      \"pickFeatures must not be called before the imagery provider is ready.\"\n    );\n  }\n  //>>includeEnd('debug');\n  return this._imageryProvider.pickFeatures(x, y, level, longitude, latitude);\n};\n\n//exposed for testing\nIonImageryProvider._endpointCache = {};\nexport default IonImageryProvider;\n"]},"metadata":{},"sourceType":"module"}