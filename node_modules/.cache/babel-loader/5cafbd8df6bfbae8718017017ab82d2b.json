{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport GeometryInstanceAttribute from \"../Core/GeometryInstanceAttribute.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport ShadowVolumeAppearanceFS from \"../Shaders/ShadowVolumeAppearanceFS.js\";\n/**\n * Creates shaders for a ClassificationPrimitive to use a given Appearance, as well as for picking.\n *\n * @param {Boolean} extentsCulling Discard fragments outside the instance's texture coordinate extents.\n * @param {Boolean} planarExtents If true, texture coordinates will be computed using planes instead of spherical coordinates.\n * @param {Appearance} appearance An Appearance to be used with a ClassificationPrimitive via GroundPrimitive.\n * @private\n */\n\nfunction ShadowVolumeAppearance(extentsCulling, planarExtents, appearance) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bool(\"extentsCulling\", extentsCulling);\n  Check.typeOf.bool(\"planarExtents\", planarExtents);\n  Check.typeOf.object(\"appearance\", appearance); //>>includeEnd('debug');\n\n  this._projectionExtentDefines = {\n    eastMostYhighDefine: \"\",\n    eastMostYlowDefine: \"\",\n    westMostYhighDefine: \"\",\n    westMostYlowDefine: \"\"\n  }; // Compute shader dependencies\n\n  var colorShaderDependencies = new ShaderDependencies();\n  colorShaderDependencies.requiresTextureCoordinates = extentsCulling;\n  colorShaderDependencies.requiresEC = !appearance.flat;\n  var pickShaderDependencies = new ShaderDependencies();\n  pickShaderDependencies.requiresTextureCoordinates = extentsCulling;\n\n  if (appearance instanceof PerInstanceColorAppearance) {\n    // PerInstanceColorAppearance doesn't have material.shaderSource, instead it has its own vertex and fragment shaders\n    colorShaderDependencies.requiresNormalEC = !appearance.flat;\n  } else {\n    // Scan material source for what hookups are needed. Assume czm_materialInput materialInput.\n    var materialShaderSource = appearance.material.shaderSource + \"\\n\" + appearance.fragmentShaderSource;\n    colorShaderDependencies.normalEC = materialShaderSource.indexOf(\"materialInput.normalEC\") !== -1 || materialShaderSource.indexOf(\"czm_getDefaultMaterial\") !== -1;\n    colorShaderDependencies.positionToEyeEC = materialShaderSource.indexOf(\"materialInput.positionToEyeEC\") !== -1;\n    colorShaderDependencies.tangentToEyeMatrix = materialShaderSource.indexOf(\"materialInput.tangentToEyeMatrix\") !== -1;\n    colorShaderDependencies.st = materialShaderSource.indexOf(\"materialInput.st\") !== -1;\n  }\n\n  this._colorShaderDependencies = colorShaderDependencies;\n  this._pickShaderDependencies = pickShaderDependencies;\n  this._appearance = appearance;\n  this._extentsCulling = extentsCulling;\n  this._planarExtents = planarExtents;\n}\n/**\n * Create the fragment shader for a ClassificationPrimitive's color pass when rendering for color.\n *\n * @param {Boolean} columbusView2D Whether the shader will be used for Columbus View or 2D.\n * @returns {ShaderSource} Shader source for the fragment shader.\n */\n\n\nShadowVolumeAppearance.prototype.createFragmentShader = function (columbusView2D) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bool(\"columbusView2D\", columbusView2D); //>>includeEnd('debug');\n\n  var appearance = this._appearance;\n  var dependencies = this._colorShaderDependencies;\n  var defines = [];\n\n  if (!columbusView2D && !this._planarExtents) {\n    defines.push(\"SPHERICAL\");\n  }\n\n  if (dependencies.requiresEC) {\n    defines.push(\"REQUIRES_EC\");\n  }\n\n  if (dependencies.requiresWC) {\n    defines.push(\"REQUIRES_WC\");\n  }\n\n  if (dependencies.requiresTextureCoordinates) {\n    defines.push(\"TEXTURE_COORDINATES\");\n  }\n\n  if (this._extentsCulling) {\n    defines.push(\"CULL_FRAGMENTS\");\n  }\n\n  if (dependencies.requiresNormalEC) {\n    defines.push(\"NORMAL_EC\");\n  }\n\n  if (appearance instanceof PerInstanceColorAppearance) {\n    defines.push(\"PER_INSTANCE_COLOR\");\n  } // Material inputs. Use of parameters in the material is different\n  // from requirement of the parameters in the overall shader, for example,\n  // texture coordinates may be used for fragment culling but not for the material itself.\n\n\n  if (dependencies.normalEC) {\n    defines.push(\"USES_NORMAL_EC\");\n  }\n\n  if (dependencies.positionToEyeEC) {\n    defines.push(\"USES_POSITION_TO_EYE_EC\");\n  }\n\n  if (dependencies.tangentToEyeMatrix) {\n    defines.push(\"USES_TANGENT_TO_EYE\");\n  }\n\n  if (dependencies.st) {\n    defines.push(\"USES_ST\");\n  }\n\n  if (appearance.flat) {\n    defines.push(\"FLAT\");\n  }\n\n  var materialSource = \"\";\n\n  if (!(appearance instanceof PerInstanceColorAppearance)) {\n    materialSource = appearance.material.shaderSource;\n  }\n\n  return new ShaderSource({\n    defines: defines,\n    sources: [materialSource, ShadowVolumeAppearanceFS]\n  });\n};\n\nShadowVolumeAppearance.prototype.createPickFragmentShader = function (columbusView2D) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bool(\"columbusView2D\", columbusView2D); //>>includeEnd('debug');\n\n  var dependencies = this._pickShaderDependencies;\n  var defines = [\"PICK\"];\n\n  if (!columbusView2D && !this._planarExtents) {\n    defines.push(\"SPHERICAL\");\n  }\n\n  if (dependencies.requiresEC) {\n    defines.push(\"REQUIRES_EC\");\n  }\n\n  if (dependencies.requiresWC) {\n    defines.push(\"REQUIRES_WC\");\n  }\n\n  if (dependencies.requiresTextureCoordinates) {\n    defines.push(\"TEXTURE_COORDINATES\");\n  }\n\n  if (this._extentsCulling) {\n    defines.push(\"CULL_FRAGMENTS\");\n  }\n\n  return new ShaderSource({\n    defines: defines,\n    sources: [ShadowVolumeAppearanceFS],\n    pickColorQualifier: \"varying\"\n  });\n};\n/**\n * Create the vertex shader for a ClassificationPrimitive's color pass on the final of 3 shadow volume passes\n *\n * @param {String[]} defines External defines to pass to the vertex shader.\n * @param {String} vertexShaderSource ShadowVolumeAppearanceVS with any required modifications for computing position.\n * @param {Boolean} columbusView2D Whether the shader will be used for Columbus View or 2D.\n * @param {MapProjection} mapProjection Current scene's map projection.\n * @returns {String} Shader source for the vertex shader.\n */\n\n\nShadowVolumeAppearance.prototype.createVertexShader = function (defines, vertexShaderSource, columbusView2D, mapProjection) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"defines\", defines);\n  Check.typeOf.string(\"vertexShaderSource\", vertexShaderSource);\n  Check.typeOf.bool(\"columbusView2D\", columbusView2D);\n  Check.defined(\"mapProjection\", mapProjection); //>>includeEnd('debug');\n\n  return createShadowVolumeAppearanceVS(this._colorShaderDependencies, this._planarExtents, columbusView2D, defines, vertexShaderSource, this._appearance, mapProjection, this._projectionExtentDefines);\n};\n/**\n * Create the vertex shader for a ClassificationPrimitive's pick pass on the final of 3 shadow volume passes\n *\n * @param {String[]} defines External defines to pass to the vertex shader.\n * @param {String} vertexShaderSource ShadowVolumeAppearanceVS with any required modifications for computing position and picking.\n * @param {Boolean} columbusView2D Whether the shader will be used for Columbus View or 2D.\n * @param {MapProjection} mapProjection Current scene's map projection.\n * @returns {String} Shader source for the vertex shader.\n */\n\n\nShadowVolumeAppearance.prototype.createPickVertexShader = function (defines, vertexShaderSource, columbusView2D, mapProjection) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"defines\", defines);\n  Check.typeOf.string(\"vertexShaderSource\", vertexShaderSource);\n  Check.typeOf.bool(\"columbusView2D\", columbusView2D);\n  Check.defined(\"mapProjection\", mapProjection); //>>includeEnd('debug');\n\n  return createShadowVolumeAppearanceVS(this._pickShaderDependencies, this._planarExtents, columbusView2D, defines, vertexShaderSource, undefined, mapProjection, this._projectionExtentDefines);\n};\n\nvar longitudeExtentsCartesianScratch = new Cartesian3();\nvar longitudeExtentsCartographicScratch = new Cartographic();\nvar longitudeExtentsEncodeScratch = {\n  high: 0.0,\n  low: 0.0\n};\n\nfunction createShadowVolumeAppearanceVS(shaderDependencies, planarExtents, columbusView2D, defines, vertexShaderSource, appearance, mapProjection, projectionExtentDefines) {\n  var allDefines = defines.slice();\n\n  if (projectionExtentDefines.eastMostYhighDefine === \"\") {\n    var eastMostCartographic = longitudeExtentsCartographicScratch;\n    eastMostCartographic.longitude = CesiumMath.PI;\n    eastMostCartographic.latitude = 0.0;\n    eastMostCartographic.height = 0.0;\n    var eastMostCartesian = mapProjection.project(eastMostCartographic, longitudeExtentsCartesianScratch);\n    var encoded = EncodedCartesian3.encode(eastMostCartesian.x, longitudeExtentsEncodeScratch);\n    projectionExtentDefines.eastMostYhighDefine = \"EAST_MOST_X_HIGH \" + encoded.high.toFixed((encoded.high + \"\").length + 1);\n    projectionExtentDefines.eastMostYlowDefine = \"EAST_MOST_X_LOW \" + encoded.low.toFixed((encoded.low + \"\").length + 1);\n    var westMostCartographic = longitudeExtentsCartographicScratch;\n    westMostCartographic.longitude = -CesiumMath.PI;\n    westMostCartographic.latitude = 0.0;\n    westMostCartographic.height = 0.0;\n    var westMostCartesian = mapProjection.project(westMostCartographic, longitudeExtentsCartesianScratch);\n    encoded = EncodedCartesian3.encode(westMostCartesian.x, longitudeExtentsEncodeScratch);\n    projectionExtentDefines.westMostYhighDefine = \"WEST_MOST_X_HIGH \" + encoded.high.toFixed((encoded.high + \"\").length + 1);\n    projectionExtentDefines.westMostYlowDefine = \"WEST_MOST_X_LOW \" + encoded.low.toFixed((encoded.low + \"\").length + 1);\n  }\n\n  if (columbusView2D) {\n    allDefines.push(projectionExtentDefines.eastMostYhighDefine);\n    allDefines.push(projectionExtentDefines.eastMostYlowDefine);\n    allDefines.push(projectionExtentDefines.westMostYhighDefine);\n    allDefines.push(projectionExtentDefines.westMostYlowDefine);\n  }\n\n  if (defined(appearance) && appearance instanceof PerInstanceColorAppearance) {\n    allDefines.push(\"PER_INSTANCE_COLOR\");\n  }\n\n  if (shaderDependencies.requiresTextureCoordinates) {\n    allDefines.push(\"TEXTURE_COORDINATES\");\n\n    if (!(planarExtents || columbusView2D)) {\n      allDefines.push(\"SPHERICAL\");\n    }\n\n    if (columbusView2D) {\n      allDefines.push(\"COLUMBUS_VIEW_2D\");\n    }\n  }\n\n  return new ShaderSource({\n    defines: allDefines,\n    sources: [vertexShaderSource]\n  });\n}\n/**\n * Tracks shader dependencies.\n * @private\n */\n\n\nfunction ShaderDependencies() {\n  this._requiresEC = false;\n  this._requiresWC = false; // depends on eye coordinates, needed for material and for phong\n\n  this._requiresNormalEC = false; // depends on eye coordinates, needed for material\n\n  this._requiresTextureCoordinates = false; // depends on world coordinates, needed for material and for culling\n\n  this._usesNormalEC = false;\n  this._usesPositionToEyeEC = false;\n  this._usesTangentToEyeMat = false;\n  this._usesSt = false;\n}\n\nObject.defineProperties(ShaderDependencies.prototype, {\n  // Set when assessing final shading (flat vs. phong) and culling using computed texture coordinates\n  requiresEC: {\n    get: function get() {\n      return this._requiresEC;\n    },\n    set: function set(value) {\n      this._requiresEC = value || this._requiresEC;\n    }\n  },\n  requiresWC: {\n    get: function get() {\n      return this._requiresWC;\n    },\n    set: function set(value) {\n      this._requiresWC = value || this._requiresWC;\n      this.requiresEC = this._requiresWC;\n    }\n  },\n  requiresNormalEC: {\n    get: function get() {\n      return this._requiresNormalEC;\n    },\n    set: function set(value) {\n      this._requiresNormalEC = value || this._requiresNormalEC;\n      this.requiresEC = this._requiresNormalEC;\n    }\n  },\n  requiresTextureCoordinates: {\n    get: function get() {\n      return this._requiresTextureCoordinates;\n    },\n    set: function set(value) {\n      this._requiresTextureCoordinates = value || this._requiresTextureCoordinates;\n      this.requiresWC = this._requiresTextureCoordinates;\n    }\n  },\n  // Get/Set when assessing material hookups\n  normalEC: {\n    set: function set(value) {\n      this.requiresNormalEC = value;\n      this._usesNormalEC = value;\n    },\n    get: function get() {\n      return this._usesNormalEC;\n    }\n  },\n  tangentToEyeMatrix: {\n    set: function set(value) {\n      this.requiresWC = value;\n      this.requiresNormalEC = value;\n      this._usesTangentToEyeMat = value;\n    },\n    get: function get() {\n      return this._usesTangentToEyeMat;\n    }\n  },\n  positionToEyeEC: {\n    set: function set(value) {\n      this.requiresEC = value;\n      this._usesPositionToEyeEC = value;\n    },\n    get: function get() {\n      return this._usesPositionToEyeEC;\n    }\n  },\n  st: {\n    set: function set(value) {\n      this.requiresTextureCoordinates = value;\n      this._usesSt = value;\n    },\n    get: function get() {\n      return this._usesSt;\n    }\n  }\n});\n\nfunction pointLineDistance(point1, point2, point) {\n  return Math.abs((point2.y - point1.y) * point.x - (point2.x - point1.x) * point.y + point2.x * point1.y - point2.y * point1.x) / Cartesian2.distance(point2, point1);\n}\n\nvar points2DScratch = [new Cartesian2(), new Cartesian2(), new Cartesian2(), new Cartesian2()]; // textureCoordinateRotationPoints form 2 lines in the computed UV space that remap to desired texture coordinates.\n// This allows simulation of baked texture coordinates for EllipseGeometry, RectangleGeometry, and PolygonGeometry.\n\nfunction addTextureCoordinateRotationAttributes(attributes, textureCoordinateRotationPoints) {\n  var points2D = points2DScratch;\n  var minXYCorner = Cartesian2.unpack(textureCoordinateRotationPoints, 0, points2D[0]);\n  var maxYCorner = Cartesian2.unpack(textureCoordinateRotationPoints, 2, points2D[1]);\n  var maxXCorner = Cartesian2.unpack(textureCoordinateRotationPoints, 4, points2D[2]);\n  attributes.uMaxVmax = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    value: [maxYCorner.x, maxYCorner.y, maxXCorner.x, maxXCorner.y]\n  });\n  var inverseExtentX = 1.0 / pointLineDistance(minXYCorner, maxYCorner, maxXCorner);\n  var inverseExtentY = 1.0 / pointLineDistance(minXYCorner, maxXCorner, maxYCorner);\n  attributes.uvMinAndExtents = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    value: [minXYCorner.x, minXYCorner.y, inverseExtentX, inverseExtentY]\n  });\n}\n\nvar cartographicScratch = new Cartographic();\nvar cornerScratch = new Cartesian3();\nvar northWestScratch = new Cartesian3();\nvar southEastScratch = new Cartesian3();\nvar highLowScratch = {\n  high: 0.0,\n  low: 0.0\n};\n\nfunction add2DTextureCoordinateAttributes(rectangle, projection, attributes) {\n  // Compute corner positions in double precision\n  var carto = cartographicScratch;\n  carto.height = 0.0;\n  carto.longitude = rectangle.west;\n  carto.latitude = rectangle.south;\n  var southWestCorner = projection.project(carto, cornerScratch);\n  carto.latitude = rectangle.north;\n  var northWest = projection.project(carto, northWestScratch);\n  carto.longitude = rectangle.east;\n  carto.latitude = rectangle.south;\n  var southEast = projection.project(carto, southEastScratch); // Since these positions are all in the 2D plane, there's a lot of zeros\n  // and a lot of repetition. So we only need to encode 4 values.\n  // Encode:\n  // x: x value for southWestCorner\n  // y: y value for southWestCorner\n  // z: y value for northWest\n  // w: x value for southEast\n\n  var valuesHigh = [0, 0, 0, 0];\n  var valuesLow = [0, 0, 0, 0];\n  var encoded = EncodedCartesian3.encode(southWestCorner.x, highLowScratch);\n  valuesHigh[0] = encoded.high;\n  valuesLow[0] = encoded.low;\n  encoded = EncodedCartesian3.encode(southWestCorner.y, highLowScratch);\n  valuesHigh[1] = encoded.high;\n  valuesLow[1] = encoded.low;\n  encoded = EncodedCartesian3.encode(northWest.y, highLowScratch);\n  valuesHigh[2] = encoded.high;\n  valuesLow[2] = encoded.low;\n  encoded = EncodedCartesian3.encode(southEast.x, highLowScratch);\n  valuesHigh[3] = encoded.high;\n  valuesLow[3] = encoded.low;\n  attributes.planes2D_HIGH = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    value: valuesHigh\n  });\n  attributes.planes2D_LOW = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    value: valuesLow\n  });\n}\n\nvar enuMatrixScratch = new Matrix4();\nvar inverseEnuScratch = new Matrix4();\nvar rectanglePointCartesianScratch = new Cartesian3();\nvar rectangleCenterScratch = new Cartographic();\nvar pointsCartographicScratch = [new Cartographic(), new Cartographic(), new Cartographic(), new Cartographic(), new Cartographic(), new Cartographic(), new Cartographic(), new Cartographic()];\n/**\n * When computing planes to bound the rectangle,\n * need to factor in \"bulge\" and other distortion.\n * Flatten the ellipsoid-centered corners and edge-centers of the rectangle\n * into the plane of the local ENU system, compute bounds in 2D, and\n * project back to ellipsoid-centered.\n *\n * @private\n */\n\nfunction computeRectangleBounds(rectangle, ellipsoid, height, southWestCornerResult, eastVectorResult, northVectorResult) {\n  // Compute center of rectangle\n  var centerCartographic = Rectangle.center(rectangle, rectangleCenterScratch);\n  centerCartographic.height = height;\n  var centerCartesian = Cartographic.toCartesian(centerCartographic, ellipsoid, rectanglePointCartesianScratch);\n  var enuMatrix = Transforms.eastNorthUpToFixedFrame(centerCartesian, ellipsoid, enuMatrixScratch);\n  var inverseEnu = Matrix4.inverse(enuMatrix, inverseEnuScratch);\n  var west = rectangle.west;\n  var east = rectangle.east;\n  var north = rectangle.north;\n  var south = rectangle.south;\n  var cartographics = pointsCartographicScratch;\n  cartographics[0].latitude = south;\n  cartographics[0].longitude = west;\n  cartographics[1].latitude = north;\n  cartographics[1].longitude = west;\n  cartographics[2].latitude = north;\n  cartographics[2].longitude = east;\n  cartographics[3].latitude = south;\n  cartographics[3].longitude = east;\n  var longitudeCenter = (west + east) * 0.5;\n  var latitudeCenter = (north + south) * 0.5;\n  cartographics[4].latitude = south;\n  cartographics[4].longitude = longitudeCenter;\n  cartographics[5].latitude = north;\n  cartographics[5].longitude = longitudeCenter;\n  cartographics[6].latitude = latitudeCenter;\n  cartographics[6].longitude = west;\n  cartographics[7].latitude = latitudeCenter;\n  cartographics[7].longitude = east;\n  var minX = Number.POSITIVE_INFINITY;\n  var maxX = Number.NEGATIVE_INFINITY;\n  var minY = Number.POSITIVE_INFINITY;\n  var maxY = Number.NEGATIVE_INFINITY;\n\n  for (var i = 0; i < 8; i++) {\n    cartographics[i].height = height;\n    var pointCartesian = Cartographic.toCartesian(cartographics[i], ellipsoid, rectanglePointCartesianScratch);\n    Matrix4.multiplyByPoint(inverseEnu, pointCartesian, pointCartesian);\n    pointCartesian.z = 0.0; // flatten into XY plane of ENU coordinate system\n\n    minX = Math.min(minX, pointCartesian.x);\n    maxX = Math.max(maxX, pointCartesian.x);\n    minY = Math.min(minY, pointCartesian.y);\n    maxY = Math.max(maxY, pointCartesian.y);\n  }\n\n  var southWestCorner = southWestCornerResult;\n  southWestCorner.x = minX;\n  southWestCorner.y = minY;\n  southWestCorner.z = 0.0;\n  Matrix4.multiplyByPoint(enuMatrix, southWestCorner, southWestCorner);\n  var southEastCorner = eastVectorResult;\n  southEastCorner.x = maxX;\n  southEastCorner.y = minY;\n  southEastCorner.z = 0.0;\n  Matrix4.multiplyByPoint(enuMatrix, southEastCorner, southEastCorner); // make eastward vector\n\n  Cartesian3.subtract(southEastCorner, southWestCorner, eastVectorResult);\n  var northWestCorner = northVectorResult;\n  northWestCorner.x = minX;\n  northWestCorner.y = maxY;\n  northWestCorner.z = 0.0;\n  Matrix4.multiplyByPoint(enuMatrix, northWestCorner, northWestCorner); // make eastward vector\n\n  Cartesian3.subtract(northWestCorner, southWestCorner, northVectorResult);\n}\n\nvar eastwardScratch = new Cartesian3();\nvar northwardScratch = new Cartesian3();\nvar encodeScratch = new EncodedCartesian3();\n/**\n * Gets an attributes object containing:\n * - 3 high-precision points as 6 GeometryInstanceAttributes. These points are used to compute eye-space planes.\n * - 1 texture coordinate rotation GeometryInstanceAttributes\n * - 2 GeometryInstanceAttributes used to compute high-precision points in 2D and Columbus View.\n *   These points are used to compute eye-space planes like above.\n *\n * Used to compute texture coordinates for small-area ClassificationPrimitives with materials or multiple non-overlapping instances.\n *\n * @see ShadowVolumeAppearance\n * @private\n *\n * @param {Rectangle} boundingRectangle Rectangle object that the points will approximately bound\n * @param {Number[]} textureCoordinateRotationPoints Points in the computed texture coordinate system for remapping texture coordinates\n * @param {Ellipsoid} ellipsoid Ellipsoid for converting Rectangle points to world coordinates\n * @param {MapProjection} projection The MapProjection used for 2D and Columbus View.\n * @param {Number} [height=0] The maximum height for the shadow volume.\n * @returns {Object} An attributes dictionary containing planar texture coordinate attributes.\n */\n\nShadowVolumeAppearance.getPlanarTextureCoordinateAttributes = function (boundingRectangle, textureCoordinateRotationPoints, ellipsoid, projection, height) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"boundingRectangle\", boundingRectangle);\n  Check.defined(\"textureCoordinateRotationPoints\", textureCoordinateRotationPoints);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  Check.typeOf.object(\"projection\", projection); //>>includeEnd('debug');\n\n  var corner = cornerScratch;\n  var eastward = eastwardScratch;\n  var northward = northwardScratch;\n  computeRectangleBounds(boundingRectangle, ellipsoid, defaultValue(height, 0.0), corner, eastward, northward);\n  var attributes = {};\n  addTextureCoordinateRotationAttributes(attributes, textureCoordinateRotationPoints);\n  var encoded = EncodedCartesian3.fromCartesian(corner, encodeScratch);\n  attributes.southWest_HIGH = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    normalize: false,\n    value: Cartesian3.pack(encoded.high, [0, 0, 0])\n  });\n  attributes.southWest_LOW = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    normalize: false,\n    value: Cartesian3.pack(encoded.low, [0, 0, 0])\n  });\n  attributes.eastward = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    normalize: false,\n    value: Cartesian3.pack(eastward, [0, 0, 0])\n  });\n  attributes.northward = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    normalize: false,\n    value: Cartesian3.pack(northward, [0, 0, 0])\n  });\n  add2DTextureCoordinateAttributes(boundingRectangle, projection, attributes);\n  return attributes;\n};\n\nvar spherePointScratch = new Cartesian3();\n\nfunction latLongToSpherical(latitude, longitude, ellipsoid, result) {\n  var cartographic = cartographicScratch;\n  cartographic.latitude = latitude;\n  cartographic.longitude = longitude;\n  cartographic.height = 0.0;\n  var spherePoint = Cartographic.toCartesian(cartographic, ellipsoid, spherePointScratch); // Project into plane with vertical for latitude\n\n  var magXY = Math.sqrt(spherePoint.x * spherePoint.x + spherePoint.y * spherePoint.y); // Use fastApproximateAtan2 for alignment with shader\n\n  var sphereLatitude = CesiumMath.fastApproximateAtan2(magXY, spherePoint.z);\n  var sphereLongitude = CesiumMath.fastApproximateAtan2(spherePoint.x, spherePoint.y);\n  result.x = sphereLatitude;\n  result.y = sphereLongitude;\n  return result;\n}\n\nvar sphericalScratch = new Cartesian2();\n/**\n * Gets an attributes object containing:\n * - the southwest corner of a rectangular area in spherical coordinates, as well as the inverse of the latitude/longitude range.\n *   These are computed using the same atan2 approximation used in the shader.\n * - 1 texture coordinate rotation GeometryInstanceAttributes\n * - 2 GeometryInstanceAttributes used to compute high-precision points in 2D and Columbus View.\n *   These points are used to compute eye-space planes like above.\n *\n * Used when computing texture coordinates for large-area ClassificationPrimitives with materials or\n * multiple non-overlapping instances.\n * @see ShadowVolumeAppearance\n * @private\n *\n * @param {Rectangle} boundingRectangle Rectangle object that the spherical extents will approximately bound\n * @param {Number[]} textureCoordinateRotationPoints Points in the computed texture coordinate system for remapping texture coordinates\n * @param {Ellipsoid} ellipsoid Ellipsoid for converting Rectangle points to world coordinates\n * @param {MapProjection} projection The MapProjection used for 2D and Columbus View.\n * @returns {Object} An attributes dictionary containing spherical texture coordinate attributes.\n */\n\nShadowVolumeAppearance.getSphericalExtentGeometryInstanceAttributes = function (boundingRectangle, textureCoordinateRotationPoints, ellipsoid, projection) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"boundingRectangle\", boundingRectangle);\n  Check.defined(\"textureCoordinateRotationPoints\", textureCoordinateRotationPoints);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  Check.typeOf.object(\"projection\", projection); //>>includeEnd('debug');\n  // rectangle cartographic coords !== spherical because it's on an ellipsoid\n\n  var southWestExtents = latLongToSpherical(boundingRectangle.south, boundingRectangle.west, ellipsoid, sphericalScratch);\n  var south = southWestExtents.x;\n  var west = southWestExtents.y;\n  var northEastExtents = latLongToSpherical(boundingRectangle.north, boundingRectangle.east, ellipsoid, sphericalScratch);\n  var north = northEastExtents.x;\n  var east = northEastExtents.y; // If the bounding rectangle crosses the IDL, rotate the spherical extents so the cross no longer happens.\n  // This rotation must happen in the shader too.\n\n  var rotationRadians = 0.0;\n\n  if (west > east) {\n    rotationRadians = CesiumMath.PI - west;\n    west = -CesiumMath.PI;\n    east += rotationRadians;\n  } // Slightly pad extents to avoid floating point error when fragment culling at edges.\n\n\n  south -= CesiumMath.EPSILON5;\n  west -= CesiumMath.EPSILON5;\n  north += CesiumMath.EPSILON5;\n  east += CesiumMath.EPSILON5;\n  var longitudeRangeInverse = 1.0 / (east - west);\n  var latitudeRangeInverse = 1.0 / (north - south);\n  var attributes = {\n    sphericalExtents: new GeometryInstanceAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 4,\n      normalize: false,\n      value: [south, west, latitudeRangeInverse, longitudeRangeInverse]\n    }),\n    longitudeRotation: new GeometryInstanceAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 1,\n      normalize: false,\n      value: [rotationRadians]\n    })\n  };\n  addTextureCoordinateRotationAttributes(attributes, textureCoordinateRotationPoints);\n  add2DTextureCoordinateAttributes(boundingRectangle, projection, attributes);\n  return attributes;\n};\n\nShadowVolumeAppearance.hasAttributesForTextureCoordinatePlanes = function (attributes) {\n  return defined(attributes.southWest_HIGH) && defined(attributes.southWest_LOW) && defined(attributes.northward) && defined(attributes.eastward) && defined(attributes.planes2D_HIGH) && defined(attributes.planes2D_LOW) && defined(attributes.uMaxVmax) && defined(attributes.uvMinAndExtents);\n};\n\nShadowVolumeAppearance.hasAttributesForSphericalExtents = function (attributes) {\n  return defined(attributes.sphericalExtents) && defined(attributes.longitudeRotation) && defined(attributes.planes2D_HIGH) && defined(attributes.planes2D_LOW) && defined(attributes.uMaxVmax) && defined(attributes.uvMinAndExtents);\n};\n\nfunction shouldUseSpherical(rectangle) {\n  return Math.max(rectangle.width, rectangle.height) > ShadowVolumeAppearance.MAX_WIDTH_FOR_PLANAR_EXTENTS;\n}\n/**\n * Computes whether the given rectangle is wide enough that texture coordinates\n * over its area should be computed using spherical extents instead of distance to planes.\n *\n * @param {Rectangle} rectangle A rectangle\n * @private\n */\n\n\nShadowVolumeAppearance.shouldUseSphericalCoordinates = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle); //>>includeEnd('debug');\n\n  return shouldUseSpherical(rectangle);\n};\n/**\n * Texture coordinates for ground primitives are computed either using spherical coordinates for large areas or\n * using distance from planes for small areas.\n *\n * @type {Number}\n * @constant\n * @private\n */\n\n\nShadowVolumeAppearance.MAX_WIDTH_FOR_PLANAR_EXTENTS = CesiumMath.toRadians(1.0);\nexport default ShadowVolumeAppearance;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/ShadowVolumeAppearance.js"],"names":["Cartesian2","Cartesian3","Cartographic","Check","ComponentDatatype","defaultValue","defined","EncodedCartesian3","GeometryInstanceAttribute","CesiumMath","Matrix4","Rectangle","Transforms","ShaderSource","PerInstanceColorAppearance","ShadowVolumeAppearanceFS","ShadowVolumeAppearance","extentsCulling","planarExtents","appearance","typeOf","bool","object","_projectionExtentDefines","eastMostYhighDefine","eastMostYlowDefine","westMostYhighDefine","westMostYlowDefine","colorShaderDependencies","ShaderDependencies","requiresTextureCoordinates","requiresEC","flat","pickShaderDependencies","requiresNormalEC","materialShaderSource","material","shaderSource","fragmentShaderSource","normalEC","indexOf","positionToEyeEC","tangentToEyeMatrix","st","_colorShaderDependencies","_pickShaderDependencies","_appearance","_extentsCulling","_planarExtents","prototype","createFragmentShader","columbusView2D","dependencies","defines","push","requiresWC","materialSource","sources","createPickFragmentShader","pickColorQualifier","createVertexShader","vertexShaderSource","mapProjection","string","createShadowVolumeAppearanceVS","createPickVertexShader","undefined","longitudeExtentsCartesianScratch","longitudeExtentsCartographicScratch","longitudeExtentsEncodeScratch","high","low","shaderDependencies","projectionExtentDefines","allDefines","slice","eastMostCartographic","longitude","PI","latitude","height","eastMostCartesian","project","encoded","encode","x","toFixed","length","westMostCartographic","westMostCartesian","_requiresEC","_requiresWC","_requiresNormalEC","_requiresTextureCoordinates","_usesNormalEC","_usesPositionToEyeEC","_usesTangentToEyeMat","_usesSt","Object","defineProperties","get","set","value","pointLineDistance","point1","point2","point","Math","abs","y","distance","points2DScratch","addTextureCoordinateRotationAttributes","attributes","textureCoordinateRotationPoints","points2D","minXYCorner","unpack","maxYCorner","maxXCorner","uMaxVmax","componentDatatype","FLOAT","componentsPerAttribute","normalize","inverseExtentX","inverseExtentY","uvMinAndExtents","cartographicScratch","cornerScratch","northWestScratch","southEastScratch","highLowScratch","add2DTextureCoordinateAttributes","rectangle","projection","carto","west","south","southWestCorner","north","northWest","east","southEast","valuesHigh","valuesLow","planes2D_HIGH","planes2D_LOW","enuMatrixScratch","inverseEnuScratch","rectanglePointCartesianScratch","rectangleCenterScratch","pointsCartographicScratch","computeRectangleBounds","ellipsoid","southWestCornerResult","eastVectorResult","northVectorResult","centerCartographic","center","centerCartesian","toCartesian","enuMatrix","eastNorthUpToFixedFrame","inverseEnu","inverse","cartographics","longitudeCenter","latitudeCenter","minX","Number","POSITIVE_INFINITY","maxX","NEGATIVE_INFINITY","minY","maxY","i","pointCartesian","multiplyByPoint","z","min","max","southEastCorner","subtract","northWestCorner","eastwardScratch","northwardScratch","encodeScratch","getPlanarTextureCoordinateAttributes","boundingRectangle","corner","eastward","northward","fromCartesian","southWest_HIGH","pack","southWest_LOW","spherePointScratch","latLongToSpherical","result","cartographic","spherePoint","magXY","sqrt","sphereLatitude","fastApproximateAtan2","sphereLongitude","sphericalScratch","getSphericalExtentGeometryInstanceAttributes","southWestExtents","northEastExtents","rotationRadians","EPSILON5","longitudeRangeInverse","latitudeRangeInverse","sphericalExtents","longitudeRotation","hasAttributesForTextureCoordinatePlanes","hasAttributesForSphericalExtents","shouldUseSpherical","width","MAX_WIDTH_FOR_PLANAR_EXTENTS","shouldUseSphericalCoordinates","toRadians"],"mappings":"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","sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport GeometryInstanceAttribute from \"../Core/GeometryInstanceAttribute.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport ShadowVolumeAppearanceFS from \"../Shaders/ShadowVolumeAppearanceFS.js\";\n\n/**\n * Creates shaders for a ClassificationPrimitive to use a given Appearance, as well as for picking.\n *\n * @param {Boolean} extentsCulling Discard fragments outside the instance's texture coordinate extents.\n * @param {Boolean} planarExtents If true, texture coordinates will be computed using planes instead of spherical coordinates.\n * @param {Appearance} appearance An Appearance to be used with a ClassificationPrimitive via GroundPrimitive.\n * @private\n */\nfunction ShadowVolumeAppearance(extentsCulling, planarExtents, appearance) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bool(\"extentsCulling\", extentsCulling);\n  Check.typeOf.bool(\"planarExtents\", planarExtents);\n  Check.typeOf.object(\"appearance\", appearance);\n  //>>includeEnd('debug');\n\n  this._projectionExtentDefines = {\n    eastMostYhighDefine: \"\",\n    eastMostYlowDefine: \"\",\n    westMostYhighDefine: \"\",\n    westMostYlowDefine: \"\",\n  };\n\n  // Compute shader dependencies\n  var colorShaderDependencies = new ShaderDependencies();\n  colorShaderDependencies.requiresTextureCoordinates = extentsCulling;\n  colorShaderDependencies.requiresEC = !appearance.flat;\n\n  var pickShaderDependencies = new ShaderDependencies();\n  pickShaderDependencies.requiresTextureCoordinates = extentsCulling;\n\n  if (appearance instanceof PerInstanceColorAppearance) {\n    // PerInstanceColorAppearance doesn't have material.shaderSource, instead it has its own vertex and fragment shaders\n    colorShaderDependencies.requiresNormalEC = !appearance.flat;\n  } else {\n    // Scan material source for what hookups are needed. Assume czm_materialInput materialInput.\n    var materialShaderSource =\n      appearance.material.shaderSource + \"\\n\" + appearance.fragmentShaderSource;\n\n    colorShaderDependencies.normalEC =\n      materialShaderSource.indexOf(\"materialInput.normalEC\") !== -1 ||\n      materialShaderSource.indexOf(\"czm_getDefaultMaterial\") !== -1;\n    colorShaderDependencies.positionToEyeEC =\n      materialShaderSource.indexOf(\"materialInput.positionToEyeEC\") !== -1;\n    colorShaderDependencies.tangentToEyeMatrix =\n      materialShaderSource.indexOf(\"materialInput.tangentToEyeMatrix\") !== -1;\n    colorShaderDependencies.st =\n      materialShaderSource.indexOf(\"materialInput.st\") !== -1;\n  }\n\n  this._colorShaderDependencies = colorShaderDependencies;\n  this._pickShaderDependencies = pickShaderDependencies;\n  this._appearance = appearance;\n  this._extentsCulling = extentsCulling;\n  this._planarExtents = planarExtents;\n}\n\n/**\n * Create the fragment shader for a ClassificationPrimitive's color pass when rendering for color.\n *\n * @param {Boolean} columbusView2D Whether the shader will be used for Columbus View or 2D.\n * @returns {ShaderSource} Shader source for the fragment shader.\n */\nShadowVolumeAppearance.prototype.createFragmentShader = function (\n  columbusView2D\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bool(\"columbusView2D\", columbusView2D);\n  //>>includeEnd('debug');\n\n  var appearance = this._appearance;\n  var dependencies = this._colorShaderDependencies;\n\n  var defines = [];\n  if (!columbusView2D && !this._planarExtents) {\n    defines.push(\"SPHERICAL\");\n  }\n  if (dependencies.requiresEC) {\n    defines.push(\"REQUIRES_EC\");\n  }\n  if (dependencies.requiresWC) {\n    defines.push(\"REQUIRES_WC\");\n  }\n  if (dependencies.requiresTextureCoordinates) {\n    defines.push(\"TEXTURE_COORDINATES\");\n  }\n  if (this._extentsCulling) {\n    defines.push(\"CULL_FRAGMENTS\");\n  }\n  if (dependencies.requiresNormalEC) {\n    defines.push(\"NORMAL_EC\");\n  }\n  if (appearance instanceof PerInstanceColorAppearance) {\n    defines.push(\"PER_INSTANCE_COLOR\");\n  }\n\n  // Material inputs. Use of parameters in the material is different\n  // from requirement of the parameters in the overall shader, for example,\n  // texture coordinates may be used for fragment culling but not for the material itself.\n  if (dependencies.normalEC) {\n    defines.push(\"USES_NORMAL_EC\");\n  }\n  if (dependencies.positionToEyeEC) {\n    defines.push(\"USES_POSITION_TO_EYE_EC\");\n  }\n  if (dependencies.tangentToEyeMatrix) {\n    defines.push(\"USES_TANGENT_TO_EYE\");\n  }\n  if (dependencies.st) {\n    defines.push(\"USES_ST\");\n  }\n\n  if (appearance.flat) {\n    defines.push(\"FLAT\");\n  }\n\n  var materialSource = \"\";\n  if (!(appearance instanceof PerInstanceColorAppearance)) {\n    materialSource = appearance.material.shaderSource;\n  }\n\n  return new ShaderSource({\n    defines: defines,\n    sources: [materialSource, ShadowVolumeAppearanceFS],\n  });\n};\n\nShadowVolumeAppearance.prototype.createPickFragmentShader = function (\n  columbusView2D\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bool(\"columbusView2D\", columbusView2D);\n  //>>includeEnd('debug');\n\n  var dependencies = this._pickShaderDependencies;\n\n  var defines = [\"PICK\"];\n  if (!columbusView2D && !this._planarExtents) {\n    defines.push(\"SPHERICAL\");\n  }\n  if (dependencies.requiresEC) {\n    defines.push(\"REQUIRES_EC\");\n  }\n  if (dependencies.requiresWC) {\n    defines.push(\"REQUIRES_WC\");\n  }\n  if (dependencies.requiresTextureCoordinates) {\n    defines.push(\"TEXTURE_COORDINATES\");\n  }\n  if (this._extentsCulling) {\n    defines.push(\"CULL_FRAGMENTS\");\n  }\n  return new ShaderSource({\n    defines: defines,\n    sources: [ShadowVolumeAppearanceFS],\n    pickColorQualifier: \"varying\",\n  });\n};\n\n/**\n * Create the vertex shader for a ClassificationPrimitive's color pass on the final of 3 shadow volume passes\n *\n * @param {String[]} defines External defines to pass to the vertex shader.\n * @param {String} vertexShaderSource ShadowVolumeAppearanceVS with any required modifications for computing position.\n * @param {Boolean} columbusView2D Whether the shader will be used for Columbus View or 2D.\n * @param {MapProjection} mapProjection Current scene's map projection.\n * @returns {String} Shader source for the vertex shader.\n */\nShadowVolumeAppearance.prototype.createVertexShader = function (\n  defines,\n  vertexShaderSource,\n  columbusView2D,\n  mapProjection\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"defines\", defines);\n  Check.typeOf.string(\"vertexShaderSource\", vertexShaderSource);\n  Check.typeOf.bool(\"columbusView2D\", columbusView2D);\n  Check.defined(\"mapProjection\", mapProjection);\n  //>>includeEnd('debug');\n  return createShadowVolumeAppearanceVS(\n    this._colorShaderDependencies,\n    this._planarExtents,\n    columbusView2D,\n    defines,\n    vertexShaderSource,\n    this._appearance,\n    mapProjection,\n    this._projectionExtentDefines\n  );\n};\n\n/**\n * Create the vertex shader for a ClassificationPrimitive's pick pass on the final of 3 shadow volume passes\n *\n * @param {String[]} defines External defines to pass to the vertex shader.\n * @param {String} vertexShaderSource ShadowVolumeAppearanceVS with any required modifications for computing position and picking.\n * @param {Boolean} columbusView2D Whether the shader will be used for Columbus View or 2D.\n * @param {MapProjection} mapProjection Current scene's map projection.\n * @returns {String} Shader source for the vertex shader.\n */\nShadowVolumeAppearance.prototype.createPickVertexShader = function (\n  defines,\n  vertexShaderSource,\n  columbusView2D,\n  mapProjection\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"defines\", defines);\n  Check.typeOf.string(\"vertexShaderSource\", vertexShaderSource);\n  Check.typeOf.bool(\"columbusView2D\", columbusView2D);\n  Check.defined(\"mapProjection\", mapProjection);\n  //>>includeEnd('debug');\n  return createShadowVolumeAppearanceVS(\n    this._pickShaderDependencies,\n    this._planarExtents,\n    columbusView2D,\n    defines,\n    vertexShaderSource,\n    undefined,\n    mapProjection,\n    this._projectionExtentDefines\n  );\n};\n\nvar longitudeExtentsCartesianScratch = new Cartesian3();\nvar longitudeExtentsCartographicScratch = new Cartographic();\nvar longitudeExtentsEncodeScratch = {\n  high: 0.0,\n  low: 0.0,\n};\nfunction createShadowVolumeAppearanceVS(\n  shaderDependencies,\n  planarExtents,\n  columbusView2D,\n  defines,\n  vertexShaderSource,\n  appearance,\n  mapProjection,\n  projectionExtentDefines\n) {\n  var allDefines = defines.slice();\n\n  if (projectionExtentDefines.eastMostYhighDefine === \"\") {\n    var eastMostCartographic = longitudeExtentsCartographicScratch;\n    eastMostCartographic.longitude = CesiumMath.PI;\n    eastMostCartographic.latitude = 0.0;\n    eastMostCartographic.height = 0.0;\n    var eastMostCartesian = mapProjection.project(\n      eastMostCartographic,\n      longitudeExtentsCartesianScratch\n    );\n    var encoded = EncodedCartesian3.encode(\n      eastMostCartesian.x,\n      longitudeExtentsEncodeScratch\n    );\n    projectionExtentDefines.eastMostYhighDefine =\n      \"EAST_MOST_X_HIGH \" +\n      encoded.high.toFixed((encoded.high + \"\").length + 1);\n    projectionExtentDefines.eastMostYlowDefine =\n      \"EAST_MOST_X_LOW \" + encoded.low.toFixed((encoded.low + \"\").length + 1);\n\n    var westMostCartographic = longitudeExtentsCartographicScratch;\n    westMostCartographic.longitude = -CesiumMath.PI;\n    westMostCartographic.latitude = 0.0;\n    westMostCartographic.height = 0.0;\n    var westMostCartesian = mapProjection.project(\n      westMostCartographic,\n      longitudeExtentsCartesianScratch\n    );\n    encoded = EncodedCartesian3.encode(\n      westMostCartesian.x,\n      longitudeExtentsEncodeScratch\n    );\n    projectionExtentDefines.westMostYhighDefine =\n      \"WEST_MOST_X_HIGH \" +\n      encoded.high.toFixed((encoded.high + \"\").length + 1);\n    projectionExtentDefines.westMostYlowDefine =\n      \"WEST_MOST_X_LOW \" + encoded.low.toFixed((encoded.low + \"\").length + 1);\n  }\n\n  if (columbusView2D) {\n    allDefines.push(projectionExtentDefines.eastMostYhighDefine);\n    allDefines.push(projectionExtentDefines.eastMostYlowDefine);\n    allDefines.push(projectionExtentDefines.westMostYhighDefine);\n    allDefines.push(projectionExtentDefines.westMostYlowDefine);\n  }\n\n  if (defined(appearance) && appearance instanceof PerInstanceColorAppearance) {\n    allDefines.push(\"PER_INSTANCE_COLOR\");\n  }\n  if (shaderDependencies.requiresTextureCoordinates) {\n    allDefines.push(\"TEXTURE_COORDINATES\");\n    if (!(planarExtents || columbusView2D)) {\n      allDefines.push(\"SPHERICAL\");\n    }\n    if (columbusView2D) {\n      allDefines.push(\"COLUMBUS_VIEW_2D\");\n    }\n  }\n\n  return new ShaderSource({\n    defines: allDefines,\n    sources: [vertexShaderSource],\n  });\n}\n\n/**\n * Tracks shader dependencies.\n * @private\n */\nfunction ShaderDependencies() {\n  this._requiresEC = false;\n  this._requiresWC = false; // depends on eye coordinates, needed for material and for phong\n  this._requiresNormalEC = false; // depends on eye coordinates, needed for material\n  this._requiresTextureCoordinates = false; // depends on world coordinates, needed for material and for culling\n\n  this._usesNormalEC = false;\n  this._usesPositionToEyeEC = false;\n  this._usesTangentToEyeMat = false;\n  this._usesSt = false;\n}\n\nObject.defineProperties(ShaderDependencies.prototype, {\n  // Set when assessing final shading (flat vs. phong) and culling using computed texture coordinates\n  requiresEC: {\n    get: function () {\n      return this._requiresEC;\n    },\n    set: function (value) {\n      this._requiresEC = value || this._requiresEC;\n    },\n  },\n  requiresWC: {\n    get: function () {\n      return this._requiresWC;\n    },\n    set: function (value) {\n      this._requiresWC = value || this._requiresWC;\n      this.requiresEC = this._requiresWC;\n    },\n  },\n  requiresNormalEC: {\n    get: function () {\n      return this._requiresNormalEC;\n    },\n    set: function (value) {\n      this._requiresNormalEC = value || this._requiresNormalEC;\n      this.requiresEC = this._requiresNormalEC;\n    },\n  },\n  requiresTextureCoordinates: {\n    get: function () {\n      return this._requiresTextureCoordinates;\n    },\n    set: function (value) {\n      this._requiresTextureCoordinates =\n        value || this._requiresTextureCoordinates;\n      this.requiresWC = this._requiresTextureCoordinates;\n    },\n  },\n  // Get/Set when assessing material hookups\n  normalEC: {\n    set: function (value) {\n      this.requiresNormalEC = value;\n      this._usesNormalEC = value;\n    },\n    get: function () {\n      return this._usesNormalEC;\n    },\n  },\n  tangentToEyeMatrix: {\n    set: function (value) {\n      this.requiresWC = value;\n      this.requiresNormalEC = value;\n      this._usesTangentToEyeMat = value;\n    },\n    get: function () {\n      return this._usesTangentToEyeMat;\n    },\n  },\n  positionToEyeEC: {\n    set: function (value) {\n      this.requiresEC = value;\n      this._usesPositionToEyeEC = value;\n    },\n    get: function () {\n      return this._usesPositionToEyeEC;\n    },\n  },\n  st: {\n    set: function (value) {\n      this.requiresTextureCoordinates = value;\n      this._usesSt = value;\n    },\n    get: function () {\n      return this._usesSt;\n    },\n  },\n});\n\nfunction pointLineDistance(point1, point2, point) {\n  return (\n    Math.abs(\n      (point2.y - point1.y) * point.x -\n        (point2.x - point1.x) * point.y +\n        point2.x * point1.y -\n        point2.y * point1.x\n    ) / Cartesian2.distance(point2, point1)\n  );\n}\n\nvar points2DScratch = [\n  new Cartesian2(),\n  new Cartesian2(),\n  new Cartesian2(),\n  new Cartesian2(),\n];\n\n// textureCoordinateRotationPoints form 2 lines in the computed UV space that remap to desired texture coordinates.\n// This allows simulation of baked texture coordinates for EllipseGeometry, RectangleGeometry, and PolygonGeometry.\nfunction addTextureCoordinateRotationAttributes(\n  attributes,\n  textureCoordinateRotationPoints\n) {\n  var points2D = points2DScratch;\n\n  var minXYCorner = Cartesian2.unpack(\n    textureCoordinateRotationPoints,\n    0,\n    points2D[0]\n  );\n  var maxYCorner = Cartesian2.unpack(\n    textureCoordinateRotationPoints,\n    2,\n    points2D[1]\n  );\n  var maxXCorner = Cartesian2.unpack(\n    textureCoordinateRotationPoints,\n    4,\n    points2D[2]\n  );\n\n  attributes.uMaxVmax = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    value: [maxYCorner.x, maxYCorner.y, maxXCorner.x, maxXCorner.y],\n  });\n\n  var inverseExtentX =\n    1.0 / pointLineDistance(minXYCorner, maxYCorner, maxXCorner);\n  var inverseExtentY =\n    1.0 / pointLineDistance(minXYCorner, maxXCorner, maxYCorner);\n\n  attributes.uvMinAndExtents = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    value: [minXYCorner.x, minXYCorner.y, inverseExtentX, inverseExtentY],\n  });\n}\n\nvar cartographicScratch = new Cartographic();\nvar cornerScratch = new Cartesian3();\nvar northWestScratch = new Cartesian3();\nvar southEastScratch = new Cartesian3();\nvar highLowScratch = { high: 0.0, low: 0.0 };\nfunction add2DTextureCoordinateAttributes(rectangle, projection, attributes) {\n  // Compute corner positions in double precision\n  var carto = cartographicScratch;\n  carto.height = 0.0;\n\n  carto.longitude = rectangle.west;\n  carto.latitude = rectangle.south;\n\n  var southWestCorner = projection.project(carto, cornerScratch);\n\n  carto.latitude = rectangle.north;\n  var northWest = projection.project(carto, northWestScratch);\n\n  carto.longitude = rectangle.east;\n  carto.latitude = rectangle.south;\n  var southEast = projection.project(carto, southEastScratch);\n\n  // Since these positions are all in the 2D plane, there's a lot of zeros\n  // and a lot of repetition. So we only need to encode 4 values.\n  // Encode:\n  // x: x value for southWestCorner\n  // y: y value for southWestCorner\n  // z: y value for northWest\n  // w: x value for southEast\n\n  var valuesHigh = [0, 0, 0, 0];\n  var valuesLow = [0, 0, 0, 0];\n  var encoded = EncodedCartesian3.encode(southWestCorner.x, highLowScratch);\n  valuesHigh[0] = encoded.high;\n  valuesLow[0] = encoded.low;\n\n  encoded = EncodedCartesian3.encode(southWestCorner.y, highLowScratch);\n  valuesHigh[1] = encoded.high;\n  valuesLow[1] = encoded.low;\n\n  encoded = EncodedCartesian3.encode(northWest.y, highLowScratch);\n  valuesHigh[2] = encoded.high;\n  valuesLow[2] = encoded.low;\n\n  encoded = EncodedCartesian3.encode(southEast.x, highLowScratch);\n  valuesHigh[3] = encoded.high;\n  valuesLow[3] = encoded.low;\n\n  attributes.planes2D_HIGH = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    value: valuesHigh,\n  });\n\n  attributes.planes2D_LOW = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    value: valuesLow,\n  });\n}\n\nvar enuMatrixScratch = new Matrix4();\nvar inverseEnuScratch = new Matrix4();\nvar rectanglePointCartesianScratch = new Cartesian3();\nvar rectangleCenterScratch = new Cartographic();\nvar pointsCartographicScratch = [\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n];\n/**\n * When computing planes to bound the rectangle,\n * need to factor in \"bulge\" and other distortion.\n * Flatten the ellipsoid-centered corners and edge-centers of the rectangle\n * into the plane of the local ENU system, compute bounds in 2D, and\n * project back to ellipsoid-centered.\n *\n * @private\n */\nfunction computeRectangleBounds(\n  rectangle,\n  ellipsoid,\n  height,\n  southWestCornerResult,\n  eastVectorResult,\n  northVectorResult\n) {\n  // Compute center of rectangle\n  var centerCartographic = Rectangle.center(rectangle, rectangleCenterScratch);\n  centerCartographic.height = height;\n  var centerCartesian = Cartographic.toCartesian(\n    centerCartographic,\n    ellipsoid,\n    rectanglePointCartesianScratch\n  );\n  var enuMatrix = Transforms.eastNorthUpToFixedFrame(\n    centerCartesian,\n    ellipsoid,\n    enuMatrixScratch\n  );\n  var inverseEnu = Matrix4.inverse(enuMatrix, inverseEnuScratch);\n\n  var west = rectangle.west;\n  var east = rectangle.east;\n  var north = rectangle.north;\n  var south = rectangle.south;\n\n  var cartographics = pointsCartographicScratch;\n  cartographics[0].latitude = south;\n  cartographics[0].longitude = west;\n  cartographics[1].latitude = north;\n  cartographics[1].longitude = west;\n  cartographics[2].latitude = north;\n  cartographics[2].longitude = east;\n  cartographics[3].latitude = south;\n  cartographics[3].longitude = east;\n\n  var longitudeCenter = (west + east) * 0.5;\n  var latitudeCenter = (north + south) * 0.5;\n\n  cartographics[4].latitude = south;\n  cartographics[4].longitude = longitudeCenter;\n  cartographics[5].latitude = north;\n  cartographics[5].longitude = longitudeCenter;\n  cartographics[6].latitude = latitudeCenter;\n  cartographics[6].longitude = west;\n  cartographics[7].latitude = latitudeCenter;\n  cartographics[7].longitude = east;\n\n  var minX = Number.POSITIVE_INFINITY;\n  var maxX = Number.NEGATIVE_INFINITY;\n  var minY = Number.POSITIVE_INFINITY;\n  var maxY = Number.NEGATIVE_INFINITY;\n  for (var i = 0; i < 8; i++) {\n    cartographics[i].height = height;\n    var pointCartesian = Cartographic.toCartesian(\n      cartographics[i],\n      ellipsoid,\n      rectanglePointCartesianScratch\n    );\n    Matrix4.multiplyByPoint(inverseEnu, pointCartesian, pointCartesian);\n    pointCartesian.z = 0.0; // flatten into XY plane of ENU coordinate system\n    minX = Math.min(minX, pointCartesian.x);\n    maxX = Math.max(maxX, pointCartesian.x);\n    minY = Math.min(minY, pointCartesian.y);\n    maxY = Math.max(maxY, pointCartesian.y);\n  }\n\n  var southWestCorner = southWestCornerResult;\n  southWestCorner.x = minX;\n  southWestCorner.y = minY;\n  southWestCorner.z = 0.0;\n  Matrix4.multiplyByPoint(enuMatrix, southWestCorner, southWestCorner);\n\n  var southEastCorner = eastVectorResult;\n  southEastCorner.x = maxX;\n  southEastCorner.y = minY;\n  southEastCorner.z = 0.0;\n  Matrix4.multiplyByPoint(enuMatrix, southEastCorner, southEastCorner);\n  // make eastward vector\n  Cartesian3.subtract(southEastCorner, southWestCorner, eastVectorResult);\n\n  var northWestCorner = northVectorResult;\n  northWestCorner.x = minX;\n  northWestCorner.y = maxY;\n  northWestCorner.z = 0.0;\n  Matrix4.multiplyByPoint(enuMatrix, northWestCorner, northWestCorner);\n  // make eastward vector\n  Cartesian3.subtract(northWestCorner, southWestCorner, northVectorResult);\n}\n\nvar eastwardScratch = new Cartesian3();\nvar northwardScratch = new Cartesian3();\nvar encodeScratch = new EncodedCartesian3();\n/**\n * Gets an attributes object containing:\n * - 3 high-precision points as 6 GeometryInstanceAttributes. These points are used to compute eye-space planes.\n * - 1 texture coordinate rotation GeometryInstanceAttributes\n * - 2 GeometryInstanceAttributes used to compute high-precision points in 2D and Columbus View.\n *   These points are used to compute eye-space planes like above.\n *\n * Used to compute texture coordinates for small-area ClassificationPrimitives with materials or multiple non-overlapping instances.\n *\n * @see ShadowVolumeAppearance\n * @private\n *\n * @param {Rectangle} boundingRectangle Rectangle object that the points will approximately bound\n * @param {Number[]} textureCoordinateRotationPoints Points in the computed texture coordinate system for remapping texture coordinates\n * @param {Ellipsoid} ellipsoid Ellipsoid for converting Rectangle points to world coordinates\n * @param {MapProjection} projection The MapProjection used for 2D and Columbus View.\n * @param {Number} [height=0] The maximum height for the shadow volume.\n * @returns {Object} An attributes dictionary containing planar texture coordinate attributes.\n */\nShadowVolumeAppearance.getPlanarTextureCoordinateAttributes = function (\n  boundingRectangle,\n  textureCoordinateRotationPoints,\n  ellipsoid,\n  projection,\n  height\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"boundingRectangle\", boundingRectangle);\n  Check.defined(\n    \"textureCoordinateRotationPoints\",\n    textureCoordinateRotationPoints\n  );\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  Check.typeOf.object(\"projection\", projection);\n  //>>includeEnd('debug');\n\n  var corner = cornerScratch;\n  var eastward = eastwardScratch;\n  var northward = northwardScratch;\n  computeRectangleBounds(\n    boundingRectangle,\n    ellipsoid,\n    defaultValue(height, 0.0),\n    corner,\n    eastward,\n    northward\n  );\n\n  var attributes = {};\n  addTextureCoordinateRotationAttributes(\n    attributes,\n    textureCoordinateRotationPoints\n  );\n\n  var encoded = EncodedCartesian3.fromCartesian(corner, encodeScratch);\n\n  attributes.southWest_HIGH = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    normalize: false,\n    value: Cartesian3.pack(encoded.high, [0, 0, 0]),\n  });\n  attributes.southWest_LOW = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    normalize: false,\n    value: Cartesian3.pack(encoded.low, [0, 0, 0]),\n  });\n  attributes.eastward = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    normalize: false,\n    value: Cartesian3.pack(eastward, [0, 0, 0]),\n  });\n  attributes.northward = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    normalize: false,\n    value: Cartesian3.pack(northward, [0, 0, 0]),\n  });\n\n  add2DTextureCoordinateAttributes(boundingRectangle, projection, attributes);\n  return attributes;\n};\n\nvar spherePointScratch = new Cartesian3();\nfunction latLongToSpherical(latitude, longitude, ellipsoid, result) {\n  var cartographic = cartographicScratch;\n  cartographic.latitude = latitude;\n  cartographic.longitude = longitude;\n  cartographic.height = 0.0;\n\n  var spherePoint = Cartographic.toCartesian(\n    cartographic,\n    ellipsoid,\n    spherePointScratch\n  );\n\n  // Project into plane with vertical for latitude\n  var magXY = Math.sqrt(\n    spherePoint.x * spherePoint.x + spherePoint.y * spherePoint.y\n  );\n\n  // Use fastApproximateAtan2 for alignment with shader\n  var sphereLatitude = CesiumMath.fastApproximateAtan2(magXY, spherePoint.z);\n  var sphereLongitude = CesiumMath.fastApproximateAtan2(\n    spherePoint.x,\n    spherePoint.y\n  );\n\n  result.x = sphereLatitude;\n  result.y = sphereLongitude;\n\n  return result;\n}\n\nvar sphericalScratch = new Cartesian2();\n/**\n * Gets an attributes object containing:\n * - the southwest corner of a rectangular area in spherical coordinates, as well as the inverse of the latitude/longitude range.\n *   These are computed using the same atan2 approximation used in the shader.\n * - 1 texture coordinate rotation GeometryInstanceAttributes\n * - 2 GeometryInstanceAttributes used to compute high-precision points in 2D and Columbus View.\n *   These points are used to compute eye-space planes like above.\n *\n * Used when computing texture coordinates for large-area ClassificationPrimitives with materials or\n * multiple non-overlapping instances.\n * @see ShadowVolumeAppearance\n * @private\n *\n * @param {Rectangle} boundingRectangle Rectangle object that the spherical extents will approximately bound\n * @param {Number[]} textureCoordinateRotationPoints Points in the computed texture coordinate system for remapping texture coordinates\n * @param {Ellipsoid} ellipsoid Ellipsoid for converting Rectangle points to world coordinates\n * @param {MapProjection} projection The MapProjection used for 2D and Columbus View.\n * @returns {Object} An attributes dictionary containing spherical texture coordinate attributes.\n */\nShadowVolumeAppearance.getSphericalExtentGeometryInstanceAttributes = function (\n  boundingRectangle,\n  textureCoordinateRotationPoints,\n  ellipsoid,\n  projection\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"boundingRectangle\", boundingRectangle);\n  Check.defined(\n    \"textureCoordinateRotationPoints\",\n    textureCoordinateRotationPoints\n  );\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  Check.typeOf.object(\"projection\", projection);\n  //>>includeEnd('debug');\n\n  // rectangle cartographic coords !== spherical because it's on an ellipsoid\n  var southWestExtents = latLongToSpherical(\n    boundingRectangle.south,\n    boundingRectangle.west,\n    ellipsoid,\n    sphericalScratch\n  );\n\n  var south = southWestExtents.x;\n  var west = southWestExtents.y;\n\n  var northEastExtents = latLongToSpherical(\n    boundingRectangle.north,\n    boundingRectangle.east,\n    ellipsoid,\n    sphericalScratch\n  );\n  var north = northEastExtents.x;\n  var east = northEastExtents.y;\n\n  // If the bounding rectangle crosses the IDL, rotate the spherical extents so the cross no longer happens.\n  // This rotation must happen in the shader too.\n  var rotationRadians = 0.0;\n  if (west > east) {\n    rotationRadians = CesiumMath.PI - west;\n    west = -CesiumMath.PI;\n    east += rotationRadians;\n  }\n\n  // Slightly pad extents to avoid floating point error when fragment culling at edges.\n  south -= CesiumMath.EPSILON5;\n  west -= CesiumMath.EPSILON5;\n  north += CesiumMath.EPSILON5;\n  east += CesiumMath.EPSILON5;\n\n  var longitudeRangeInverse = 1.0 / (east - west);\n  var latitudeRangeInverse = 1.0 / (north - south);\n\n  var attributes = {\n    sphericalExtents: new GeometryInstanceAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 4,\n      normalize: false,\n      value: [south, west, latitudeRangeInverse, longitudeRangeInverse],\n    }),\n    longitudeRotation: new GeometryInstanceAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 1,\n      normalize: false,\n      value: [rotationRadians],\n    }),\n  };\n\n  addTextureCoordinateRotationAttributes(\n    attributes,\n    textureCoordinateRotationPoints\n  );\n  add2DTextureCoordinateAttributes(boundingRectangle, projection, attributes);\n  return attributes;\n};\n\nShadowVolumeAppearance.hasAttributesForTextureCoordinatePlanes = function (\n  attributes\n) {\n  return (\n    defined(attributes.southWest_HIGH) &&\n    defined(attributes.southWest_LOW) &&\n    defined(attributes.northward) &&\n    defined(attributes.eastward) &&\n    defined(attributes.planes2D_HIGH) &&\n    defined(attributes.planes2D_LOW) &&\n    defined(attributes.uMaxVmax) &&\n    defined(attributes.uvMinAndExtents)\n  );\n};\n\nShadowVolumeAppearance.hasAttributesForSphericalExtents = function (\n  attributes\n) {\n  return (\n    defined(attributes.sphericalExtents) &&\n    defined(attributes.longitudeRotation) &&\n    defined(attributes.planes2D_HIGH) &&\n    defined(attributes.planes2D_LOW) &&\n    defined(attributes.uMaxVmax) &&\n    defined(attributes.uvMinAndExtents)\n  );\n};\n\nfunction shouldUseSpherical(rectangle) {\n  return (\n    Math.max(rectangle.width, rectangle.height) >\n    ShadowVolumeAppearance.MAX_WIDTH_FOR_PLANAR_EXTENTS\n  );\n}\n\n/**\n * Computes whether the given rectangle is wide enough that texture coordinates\n * over its area should be computed using spherical extents instead of distance to planes.\n *\n * @param {Rectangle} rectangle A rectangle\n * @private\n */\nShadowVolumeAppearance.shouldUseSphericalCoordinates = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  return shouldUseSpherical(rectangle);\n};\n\n/**\n * Texture coordinates for ground primitives are computed either using spherical coordinates for large areas or\n * using distance from planes for small areas.\n *\n * @type {Number}\n * @constant\n * @private\n */\nShadowVolumeAppearance.MAX_WIDTH_FOR_PLANAR_EXTENTS = CesiumMath.toRadians(1.0);\nexport default ShadowVolumeAppearance;\n"]},"metadata":{},"sourceType":"module"}