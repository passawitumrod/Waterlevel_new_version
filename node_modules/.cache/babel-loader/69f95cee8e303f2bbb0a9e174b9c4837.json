{"ast":null,"code":"import ArcType from \"./ArcType.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Color from \"./Color.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryType from \"./GeometryType.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nvar scratchInterpolateColorsArray = [];\n\nfunction interpolateColors(p0, p1, color0, color1, numPoints) {\n  var colors = scratchInterpolateColorsArray;\n  colors.length = numPoints;\n  var i;\n  var r0 = color0.red;\n  var g0 = color0.green;\n  var b0 = color0.blue;\n  var a0 = color0.alpha;\n  var r1 = color1.red;\n  var g1 = color1.green;\n  var b1 = color1.blue;\n  var a1 = color1.alpha;\n\n  if (Color.equals(color0, color1)) {\n    for (i = 0; i < numPoints; i++) {\n      colors[i] = Color.clone(color0);\n    }\n\n    return colors;\n  }\n\n  var redPerVertex = (r1 - r0) / numPoints;\n  var greenPerVertex = (g1 - g0) / numPoints;\n  var bluePerVertex = (b1 - b0) / numPoints;\n  var alphaPerVertex = (a1 - a0) / numPoints;\n\n  for (i = 0; i < numPoints; i++) {\n    colors[i] = new Color(r0 + i * redPerVertex, g0 + i * greenPerVertex, b0 + i * bluePerVertex, a0 + i * alphaPerVertex);\n  }\n\n  return colors;\n}\n/**\n * A description of a polyline modeled as a line strip; the first two positions define a line segment,\n * and each additional position defines a line segment from the previous position. The polyline is capable of\n * displaying with a material.\n *\n * @alias PolylineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the positions in the polyline as a line strip.\n * @param {Number} [options.width=1.0] The width in pixels.\n * @param {Color[]} [options.colors] An Array of {@link Color} defining the per vertex or per segment colors.\n * @param {Boolean} [options.colorsPerVertex=false] A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude if options.arcType is not ArcType.NONE. Determines the number of positions in the buffer.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n *\n * @exception {DeveloperError} At least two positions are required.\n * @exception {DeveloperError} width must be greater than or equal to one.\n * @exception {DeveloperError} colors has an invalid length.\n *\n * @see PolylineGeometry#createGeometry\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Polyline.html|Cesium Sandcastle Polyline Demo}\n *\n * @example\n * // A polyline with two connected line segments\n * var polyline = new Cesium.PolylineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     0.0, 0.0,\n *     5.0, 0.0,\n *     5.0, 5.0\n *   ]),\n *   width : 10.0\n * });\n * var geometry = Cesium.PolylineGeometry.createGeometry(polyline);\n */\n\n\nfunction PolylineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var positions = options.positions;\n  var colors = options.colors;\n  var width = defaultValue(options.width, 1.0);\n  var colorsPerVertex = defaultValue(options.colorsPerVertex, false); //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(positions) || positions.length < 2) {\n    throw new DeveloperError(\"At least two positions are required.\");\n  }\n\n  if (typeof width !== \"number\") {\n    throw new DeveloperError(\"width must be a number\");\n  }\n\n  if (defined(colors) && (colorsPerVertex && colors.length < positions.length || !colorsPerVertex && colors.length < positions.length - 1)) {\n    throw new DeveloperError(\"colors has an invalid length.\");\n  } //>>includeEnd('debug');\n\n\n  this._positions = positions;\n  this._colors = colors;\n  this._width = width;\n  this._colorsPerVertex = colorsPerVertex;\n  this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));\n  this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n  this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n  this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n  this._workerName = \"createPolylineGeometry\";\n  var numComponents = 1 + positions.length * Cartesian3.packedLength;\n  numComponents += defined(colors) ? 1 + colors.length * Color.packedLength : 1;\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n\n  this.packedLength = numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 4;\n}\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolylineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\n\nPolylineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  } //>>includeEnd('debug');\n\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var i;\n  var positions = value._positions;\n  var length = positions.length;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  var colors = value._colors;\n  length = defined(colors) ? colors.length : 0.0;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n    Color.pack(colors[i], array, startingIndex);\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n  array[startingIndex++] = value._width;\n  array[startingIndex++] = value._colorsPerVertex ? 1.0 : 0.0;\n  array[startingIndex++] = value._arcType;\n  array[startingIndex] = value._granularity;\n  return array;\n};\n\nvar scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nvar scratchVertexFormat = new VertexFormat();\nvar scratchOptions = {\n  positions: undefined,\n  colors: undefined,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  width: undefined,\n  colorsPerVertex: undefined,\n  arcType: undefined,\n  granularity: undefined\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolylineGeometry} [result] The object into which to store the result.\n * @returns {PolylineGeometry} The modified result parameter or a new PolylineGeometry instance if one was not provided.\n */\n\nPolylineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  } //>>includeEnd('debug');\n\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var i;\n  var length = array[startingIndex++];\n  var positions = new Array(length);\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  length = array[startingIndex++];\n  var colors = length > 0 ? new Array(length) : undefined;\n\n  for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n    colors[i] = Color.unpack(array, startingIndex);\n  }\n\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n  var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n  startingIndex += VertexFormat.packedLength;\n  var width = array[startingIndex++];\n  var colorsPerVertex = array[startingIndex++] === 1.0;\n  var arcType = array[startingIndex++];\n  var granularity = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.positions = positions;\n    scratchOptions.colors = colors;\n    scratchOptions.width = width;\n    scratchOptions.colorsPerVertex = colorsPerVertex;\n    scratchOptions.arcType = arcType;\n    scratchOptions.granularity = granularity;\n    return new PolylineGeometry(scratchOptions);\n  }\n\n  result._positions = positions;\n  result._colors = colors;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._width = width;\n  result._colorsPerVertex = colorsPerVertex;\n  result._arcType = arcType;\n  result._granularity = granularity;\n  return result;\n};\n\nvar scratchCartesian3 = new Cartesian3();\nvar scratchPosition = new Cartesian3();\nvar scratchPrevPosition = new Cartesian3();\nvar scratchNextPosition = new Cartesian3();\n/**\n * Computes the geometric representation of a polyline, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolylineGeometry} polylineGeometry A description of the polyline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\n\nPolylineGeometry.createGeometry = function (polylineGeometry) {\n  var width = polylineGeometry._width;\n  var vertexFormat = polylineGeometry._vertexFormat;\n  var colors = polylineGeometry._colors;\n  var colorsPerVertex = polylineGeometry._colorsPerVertex;\n  var arcType = polylineGeometry._arcType;\n  var granularity = polylineGeometry._granularity;\n  var ellipsoid = polylineGeometry._ellipsoid;\n  var i;\n  var j;\n  var k;\n  var positions = arrayRemoveDuplicates(polylineGeometry._positions, Cartesian3.equalsEpsilon);\n  var positionsLength = positions.length; // A width of a pixel or less is not a valid geometry, but in order to support external data\n  // that may have errors we treat this as an empty geometry.\n\n  if (positionsLength < 2 || width <= 0.0) {\n    return undefined;\n  }\n\n  if (arcType === ArcType.GEODESIC || arcType === ArcType.RHUMB) {\n    var subdivisionSize;\n    var numberOfPointsFunction;\n\n    if (arcType === ArcType.GEODESIC) {\n      subdivisionSize = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n      numberOfPointsFunction = PolylinePipeline.numberOfPoints;\n    } else {\n      subdivisionSize = granularity;\n      numberOfPointsFunction = PolylinePipeline.numberOfPointsRhumbLine;\n    }\n\n    var heights = PolylinePipeline.extractHeights(positions, ellipsoid);\n\n    if (defined(colors)) {\n      var colorLength = 1;\n\n      for (i = 0; i < positionsLength - 1; ++i) {\n        colorLength += numberOfPointsFunction(positions[i], positions[i + 1], subdivisionSize);\n      }\n\n      var newColors = new Array(colorLength);\n      var newColorIndex = 0;\n\n      for (i = 0; i < positionsLength - 1; ++i) {\n        var p0 = positions[i];\n        var p1 = positions[i + 1];\n        var c0 = colors[i];\n        var numColors = numberOfPointsFunction(p0, p1, subdivisionSize);\n\n        if (colorsPerVertex && i < colorLength) {\n          var c1 = colors[i + 1];\n          var interpolatedColors = interpolateColors(p0, p1, c0, c1, numColors);\n          var interpolatedColorsLength = interpolatedColors.length;\n\n          for (j = 0; j < interpolatedColorsLength; ++j) {\n            newColors[newColorIndex++] = interpolatedColors[j];\n          }\n        } else {\n          for (j = 0; j < numColors; ++j) {\n            newColors[newColorIndex++] = Color.clone(c0);\n          }\n        }\n      }\n\n      newColors[newColorIndex] = Color.clone(colors[colors.length - 1]);\n      colors = newColors;\n      scratchInterpolateColorsArray.length = 0;\n    }\n\n    if (arcType === ArcType.GEODESIC) {\n      positions = PolylinePipeline.generateCartesianArc({\n        positions: positions,\n        minDistance: subdivisionSize,\n        ellipsoid: ellipsoid,\n        height: heights\n      });\n    } else {\n      positions = PolylinePipeline.generateCartesianRhumbArc({\n        positions: positions,\n        granularity: subdivisionSize,\n        ellipsoid: ellipsoid,\n        height: heights\n      });\n    }\n  }\n\n  positionsLength = positions.length;\n  var size = positionsLength * 4.0 - 4.0;\n  var finalPositions = new Float64Array(size * 3);\n  var prevPositions = new Float64Array(size * 3);\n  var nextPositions = new Float64Array(size * 3);\n  var expandAndWidth = new Float32Array(size * 2);\n  var st = vertexFormat.st ? new Float32Array(size * 2) : undefined;\n  var finalColors = defined(colors) ? new Uint8Array(size * 4) : undefined;\n  var positionIndex = 0;\n  var expandAndWidthIndex = 0;\n  var stIndex = 0;\n  var colorIndex = 0;\n  var position;\n\n  for (j = 0; j < positionsLength; ++j) {\n    if (j === 0) {\n      position = scratchCartesian3;\n      Cartesian3.subtract(positions[0], positions[1], position);\n      Cartesian3.add(positions[0], position, position);\n    } else {\n      position = positions[j - 1];\n    }\n\n    Cartesian3.clone(position, scratchPrevPosition);\n    Cartesian3.clone(positions[j], scratchPosition);\n\n    if (j === positionsLength - 1) {\n      position = scratchCartesian3;\n      Cartesian3.subtract(positions[positionsLength - 1], positions[positionsLength - 2], position);\n      Cartesian3.add(positions[positionsLength - 1], position, position);\n    } else {\n      position = positions[j + 1];\n    }\n\n    Cartesian3.clone(position, scratchNextPosition);\n    var color0, color1;\n\n    if (defined(finalColors)) {\n      if (j !== 0 && !colorsPerVertex) {\n        color0 = colors[j - 1];\n      } else {\n        color0 = colors[j];\n      }\n\n      if (j !== positionsLength - 1) {\n        color1 = colors[j];\n      }\n    }\n\n    var startK = j === 0 ? 2 : 0;\n    var endK = j === positionsLength - 1 ? 2 : 4;\n\n    for (k = startK; k < endK; ++k) {\n      Cartesian3.pack(scratchPosition, finalPositions, positionIndex);\n      Cartesian3.pack(scratchPrevPosition, prevPositions, positionIndex);\n      Cartesian3.pack(scratchNextPosition, nextPositions, positionIndex);\n      positionIndex += 3;\n      var direction = k - 2 < 0 ? -1.0 : 1.0;\n      expandAndWidth[expandAndWidthIndex++] = 2 * (k % 2) - 1; // expand direction\n\n      expandAndWidth[expandAndWidthIndex++] = direction * width;\n\n      if (vertexFormat.st) {\n        st[stIndex++] = j / (positionsLength - 1);\n        st[stIndex++] = Math.max(expandAndWidth[expandAndWidthIndex - 2], 0.0);\n      }\n\n      if (defined(finalColors)) {\n        var color = k < 2 ? color0 : color1;\n        finalColors[colorIndex++] = Color.floatToByte(color.red);\n        finalColors[colorIndex++] = Color.floatToByte(color.green);\n        finalColors[colorIndex++] = Color.floatToByte(color.blue);\n        finalColors[colorIndex++] = Color.floatToByte(color.alpha);\n      }\n    }\n  }\n\n  var attributes = new GeometryAttributes();\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: finalPositions\n  });\n  attributes.prevPosition = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: prevPositions\n  });\n  attributes.nextPosition = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: nextPositions\n  });\n  attributes.expandAndWidth = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 2,\n    values: expandAndWidth\n  });\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: st\n    });\n  }\n\n  if (defined(finalColors)) {\n    attributes.color = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 4,\n      values: finalColors,\n      normalize: true\n    });\n  }\n\n  var indices = IndexDatatype.createTypedArray(size, positionsLength * 6 - 6);\n  var index = 0;\n  var indicesIndex = 0;\n  var length = positionsLength - 1.0;\n\n  for (j = 0; j < length; ++j) {\n    indices[indicesIndex++] = index;\n    indices[indicesIndex++] = index + 2;\n    indices[indicesIndex++] = index + 1;\n    indices[indicesIndex++] = index + 1;\n    indices[indicesIndex++] = index + 2;\n    indices[indicesIndex++] = index + 3;\n    index += 4;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: BoundingSphere.fromPoints(positions),\n    geometryType: GeometryType.POLYLINES\n  });\n};\n\nexport default PolylineGeometry;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/PolylineGeometry.js"],"names":["ArcType","arrayRemoveDuplicates","BoundingSphere","Cartesian3","Color","ComponentDatatype","defaultValue","defined","DeveloperError","Ellipsoid","Geometry","GeometryAttribute","GeometryAttributes","GeometryType","IndexDatatype","CesiumMath","PolylinePipeline","PrimitiveType","VertexFormat","scratchInterpolateColorsArray","interpolateColors","p0","p1","color0","color1","numPoints","colors","length","i","r0","red","g0","green","b0","blue","a0","alpha","r1","g1","b1","a1","equals","clone","redPerVertex","greenPerVertex","bluePerVertex","alphaPerVertex","PolylineGeometry","options","EMPTY_OBJECT","positions","width","colorsPerVertex","_positions","_colors","_width","_colorsPerVertex","_vertexFormat","vertexFormat","DEFAULT","_arcType","arcType","GEODESIC","_granularity","granularity","RADIANS_PER_DEGREE","_ellipsoid","ellipsoid","WGS84","_workerName","numComponents","packedLength","pack","value","array","startingIndex","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","scratchOptions","undefined","unpack","result","Array","scratchCartesian3","scratchPosition","scratchPrevPosition","scratchNextPosition","createGeometry","polylineGeometry","j","k","equalsEpsilon","positionsLength","RHUMB","subdivisionSize","numberOfPointsFunction","chordLength","maximumRadius","numberOfPoints","numberOfPointsRhumbLine","heights","extractHeights","colorLength","newColors","newColorIndex","c0","numColors","c1","interpolatedColors","interpolatedColorsLength","generateCartesianArc","minDistance","height","generateCartesianRhumbArc","size","finalPositions","Float64Array","prevPositions","nextPositions","expandAndWidth","Float32Array","st","finalColors","Uint8Array","positionIndex","expandAndWidthIndex","stIndex","colorIndex","position","subtract","add","startK","endK","direction","Math","max","color","floatToByte","attributes","componentDatatype","DOUBLE","componentsPerAttribute","values","prevPosition","nextPosition","FLOAT","UNSIGNED_BYTE","normalize","indices","createTypedArray","index","indicesIndex","primitiveType","TRIANGLES","boundingSphere","fromPoints","geometryType","POLYLINES"],"mappings":"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","sourcesContent":["import ArcType from \"./ArcType.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Color from \"./Color.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryType from \"./GeometryType.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nvar scratchInterpolateColorsArray = [];\n\nfunction interpolateColors(p0, p1, color0, color1, numPoints) {\n  var colors = scratchInterpolateColorsArray;\n  colors.length = numPoints;\n  var i;\n\n  var r0 = color0.red;\n  var g0 = color0.green;\n  var b0 = color0.blue;\n  var a0 = color0.alpha;\n\n  var r1 = color1.red;\n  var g1 = color1.green;\n  var b1 = color1.blue;\n  var a1 = color1.alpha;\n\n  if (Color.equals(color0, color1)) {\n    for (i = 0; i < numPoints; i++) {\n      colors[i] = Color.clone(color0);\n    }\n    return colors;\n  }\n\n  var redPerVertex = (r1 - r0) / numPoints;\n  var greenPerVertex = (g1 - g0) / numPoints;\n  var bluePerVertex = (b1 - b0) / numPoints;\n  var alphaPerVertex = (a1 - a0) / numPoints;\n\n  for (i = 0; i < numPoints; i++) {\n    colors[i] = new Color(\n      r0 + i * redPerVertex,\n      g0 + i * greenPerVertex,\n      b0 + i * bluePerVertex,\n      a0 + i * alphaPerVertex\n    );\n  }\n\n  return colors;\n}\n\n/**\n * A description of a polyline modeled as a line strip; the first two positions define a line segment,\n * and each additional position defines a line segment from the previous position. The polyline is capable of\n * displaying with a material.\n *\n * @alias PolylineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the positions in the polyline as a line strip.\n * @param {Number} [options.width=1.0] The width in pixels.\n * @param {Color[]} [options.colors] An Array of {@link Color} defining the per vertex or per segment colors.\n * @param {Boolean} [options.colorsPerVertex=false] A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude if options.arcType is not ArcType.NONE. Determines the number of positions in the buffer.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n *\n * @exception {DeveloperError} At least two positions are required.\n * @exception {DeveloperError} width must be greater than or equal to one.\n * @exception {DeveloperError} colors has an invalid length.\n *\n * @see PolylineGeometry#createGeometry\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Polyline.html|Cesium Sandcastle Polyline Demo}\n *\n * @example\n * // A polyline with two connected line segments\n * var polyline = new Cesium.PolylineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     0.0, 0.0,\n *     5.0, 0.0,\n *     5.0, 5.0\n *   ]),\n *   width : 10.0\n * });\n * var geometry = Cesium.PolylineGeometry.createGeometry(polyline);\n */\nfunction PolylineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var positions = options.positions;\n  var colors = options.colors;\n  var width = defaultValue(options.width, 1.0);\n  var colorsPerVertex = defaultValue(options.colorsPerVertex, false);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions) || positions.length < 2) {\n    throw new DeveloperError(\"At least two positions are required.\");\n  }\n  if (typeof width !== \"number\") {\n    throw new DeveloperError(\"width must be a number\");\n  }\n  if (\n    defined(colors) &&\n    ((colorsPerVertex && colors.length < positions.length) ||\n      (!colorsPerVertex && colors.length < positions.length - 1))\n  ) {\n    throw new DeveloperError(\"colors has an invalid length.\");\n  }\n  //>>includeEnd('debug');\n\n  this._positions = positions;\n  this._colors = colors;\n  this._width = width;\n  this._colorsPerVertex = colorsPerVertex;\n  this._vertexFormat = VertexFormat.clone(\n    defaultValue(options.vertexFormat, VertexFormat.DEFAULT)\n  );\n\n  this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n  this._granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  this._ellipsoid = Ellipsoid.clone(\n    defaultValue(options.ellipsoid, Ellipsoid.WGS84)\n  );\n  this._workerName = \"createPolylineGeometry\";\n\n  var numComponents = 1 + positions.length * Cartesian3.packedLength;\n  numComponents += defined(colors) ? 1 + colors.length * Color.packedLength : 1;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  this.packedLength =\n    numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 4;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolylineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nPolylineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var i;\n\n  var positions = value._positions;\n  var length = positions.length;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  var colors = value._colors;\n  length = defined(colors) ? colors.length : 0.0;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n    Color.pack(colors[i], array, startingIndex);\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._width;\n  array[startingIndex++] = value._colorsPerVertex ? 1.0 : 0.0;\n  array[startingIndex++] = value._arcType;\n  array[startingIndex] = value._granularity;\n\n  return array;\n};\n\nvar scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nvar scratchVertexFormat = new VertexFormat();\nvar scratchOptions = {\n  positions: undefined,\n  colors: undefined,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  width: undefined,\n  colorsPerVertex: undefined,\n  arcType: undefined,\n  granularity: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolylineGeometry} [result] The object into which to store the result.\n * @returns {PolylineGeometry} The modified result parameter or a new PolylineGeometry instance if one was not provided.\n */\nPolylineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var i;\n\n  var length = array[startingIndex++];\n  var positions = new Array(length);\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  length = array[startingIndex++];\n  var colors = length > 0 ? new Array(length) : undefined;\n\n  for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n    colors[i] = Color.unpack(array, startingIndex);\n  }\n\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  var vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  var width = array[startingIndex++];\n  var colorsPerVertex = array[startingIndex++] === 1.0;\n  var arcType = array[startingIndex++];\n  var granularity = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.positions = positions;\n    scratchOptions.colors = colors;\n    scratchOptions.width = width;\n    scratchOptions.colorsPerVertex = colorsPerVertex;\n    scratchOptions.arcType = arcType;\n    scratchOptions.granularity = granularity;\n    return new PolylineGeometry(scratchOptions);\n  }\n\n  result._positions = positions;\n  result._colors = colors;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._width = width;\n  result._colorsPerVertex = colorsPerVertex;\n  result._arcType = arcType;\n  result._granularity = granularity;\n\n  return result;\n};\n\nvar scratchCartesian3 = new Cartesian3();\nvar scratchPosition = new Cartesian3();\nvar scratchPrevPosition = new Cartesian3();\nvar scratchNextPosition = new Cartesian3();\n\n/**\n * Computes the geometric representation of a polyline, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolylineGeometry} polylineGeometry A description of the polyline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPolylineGeometry.createGeometry = function (polylineGeometry) {\n  var width = polylineGeometry._width;\n  var vertexFormat = polylineGeometry._vertexFormat;\n  var colors = polylineGeometry._colors;\n  var colorsPerVertex = polylineGeometry._colorsPerVertex;\n  var arcType = polylineGeometry._arcType;\n  var granularity = polylineGeometry._granularity;\n  var ellipsoid = polylineGeometry._ellipsoid;\n\n  var i;\n  var j;\n  var k;\n\n  var positions = arrayRemoveDuplicates(\n    polylineGeometry._positions,\n    Cartesian3.equalsEpsilon\n  );\n  var positionsLength = positions.length;\n\n  // A width of a pixel or less is not a valid geometry, but in order to support external data\n  // that may have errors we treat this as an empty geometry.\n  if (positionsLength < 2 || width <= 0.0) {\n    return undefined;\n  }\n\n  if (arcType === ArcType.GEODESIC || arcType === ArcType.RHUMB) {\n    var subdivisionSize;\n    var numberOfPointsFunction;\n    if (arcType === ArcType.GEODESIC) {\n      subdivisionSize = CesiumMath.chordLength(\n        granularity,\n        ellipsoid.maximumRadius\n      );\n      numberOfPointsFunction = PolylinePipeline.numberOfPoints;\n    } else {\n      subdivisionSize = granularity;\n      numberOfPointsFunction = PolylinePipeline.numberOfPointsRhumbLine;\n    }\n\n    var heights = PolylinePipeline.extractHeights(positions, ellipsoid);\n\n    if (defined(colors)) {\n      var colorLength = 1;\n      for (i = 0; i < positionsLength - 1; ++i) {\n        colorLength += numberOfPointsFunction(\n          positions[i],\n          positions[i + 1],\n          subdivisionSize\n        );\n      }\n\n      var newColors = new Array(colorLength);\n      var newColorIndex = 0;\n\n      for (i = 0; i < positionsLength - 1; ++i) {\n        var p0 = positions[i];\n        var p1 = positions[i + 1];\n        var c0 = colors[i];\n\n        var numColors = numberOfPointsFunction(p0, p1, subdivisionSize);\n        if (colorsPerVertex && i < colorLength) {\n          var c1 = colors[i + 1];\n          var interpolatedColors = interpolateColors(p0, p1, c0, c1, numColors);\n          var interpolatedColorsLength = interpolatedColors.length;\n          for (j = 0; j < interpolatedColorsLength; ++j) {\n            newColors[newColorIndex++] = interpolatedColors[j];\n          }\n        } else {\n          for (j = 0; j < numColors; ++j) {\n            newColors[newColorIndex++] = Color.clone(c0);\n          }\n        }\n      }\n\n      newColors[newColorIndex] = Color.clone(colors[colors.length - 1]);\n      colors = newColors;\n\n      scratchInterpolateColorsArray.length = 0;\n    }\n\n    if (arcType === ArcType.GEODESIC) {\n      positions = PolylinePipeline.generateCartesianArc({\n        positions: positions,\n        minDistance: subdivisionSize,\n        ellipsoid: ellipsoid,\n        height: heights,\n      });\n    } else {\n      positions = PolylinePipeline.generateCartesianRhumbArc({\n        positions: positions,\n        granularity: subdivisionSize,\n        ellipsoid: ellipsoid,\n        height: heights,\n      });\n    }\n  }\n\n  positionsLength = positions.length;\n  var size = positionsLength * 4.0 - 4.0;\n\n  var finalPositions = new Float64Array(size * 3);\n  var prevPositions = new Float64Array(size * 3);\n  var nextPositions = new Float64Array(size * 3);\n  var expandAndWidth = new Float32Array(size * 2);\n  var st = vertexFormat.st ? new Float32Array(size * 2) : undefined;\n  var finalColors = defined(colors) ? new Uint8Array(size * 4) : undefined;\n\n  var positionIndex = 0;\n  var expandAndWidthIndex = 0;\n  var stIndex = 0;\n  var colorIndex = 0;\n  var position;\n\n  for (j = 0; j < positionsLength; ++j) {\n    if (j === 0) {\n      position = scratchCartesian3;\n      Cartesian3.subtract(positions[0], positions[1], position);\n      Cartesian3.add(positions[0], position, position);\n    } else {\n      position = positions[j - 1];\n    }\n\n    Cartesian3.clone(position, scratchPrevPosition);\n    Cartesian3.clone(positions[j], scratchPosition);\n\n    if (j === positionsLength - 1) {\n      position = scratchCartesian3;\n      Cartesian3.subtract(\n        positions[positionsLength - 1],\n        positions[positionsLength - 2],\n        position\n      );\n      Cartesian3.add(positions[positionsLength - 1], position, position);\n    } else {\n      position = positions[j + 1];\n    }\n\n    Cartesian3.clone(position, scratchNextPosition);\n\n    var color0, color1;\n    if (defined(finalColors)) {\n      if (j !== 0 && !colorsPerVertex) {\n        color0 = colors[j - 1];\n      } else {\n        color0 = colors[j];\n      }\n\n      if (j !== positionsLength - 1) {\n        color1 = colors[j];\n      }\n    }\n\n    var startK = j === 0 ? 2 : 0;\n    var endK = j === positionsLength - 1 ? 2 : 4;\n\n    for (k = startK; k < endK; ++k) {\n      Cartesian3.pack(scratchPosition, finalPositions, positionIndex);\n      Cartesian3.pack(scratchPrevPosition, prevPositions, positionIndex);\n      Cartesian3.pack(scratchNextPosition, nextPositions, positionIndex);\n      positionIndex += 3;\n\n      var direction = k - 2 < 0 ? -1.0 : 1.0;\n      expandAndWidth[expandAndWidthIndex++] = 2 * (k % 2) - 1; // expand direction\n      expandAndWidth[expandAndWidthIndex++] = direction * width;\n\n      if (vertexFormat.st) {\n        st[stIndex++] = j / (positionsLength - 1);\n        st[stIndex++] = Math.max(expandAndWidth[expandAndWidthIndex - 2], 0.0);\n      }\n\n      if (defined(finalColors)) {\n        var color = k < 2 ? color0 : color1;\n\n        finalColors[colorIndex++] = Color.floatToByte(color.red);\n        finalColors[colorIndex++] = Color.floatToByte(color.green);\n        finalColors[colorIndex++] = Color.floatToByte(color.blue);\n        finalColors[colorIndex++] = Color.floatToByte(color.alpha);\n      }\n    }\n  }\n\n  var attributes = new GeometryAttributes();\n\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: finalPositions,\n  });\n\n  attributes.prevPosition = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: prevPositions,\n  });\n\n  attributes.nextPosition = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: nextPositions,\n  });\n\n  attributes.expandAndWidth = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 2,\n    values: expandAndWidth,\n  });\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: st,\n    });\n  }\n\n  if (defined(finalColors)) {\n    attributes.color = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 4,\n      values: finalColors,\n      normalize: true,\n    });\n  }\n\n  var indices = IndexDatatype.createTypedArray(size, positionsLength * 6 - 6);\n  var index = 0;\n  var indicesIndex = 0;\n  var length = positionsLength - 1.0;\n  for (j = 0; j < length; ++j) {\n    indices[indicesIndex++] = index;\n    indices[indicesIndex++] = index + 2;\n    indices[indicesIndex++] = index + 1;\n\n    indices[indicesIndex++] = index + 1;\n    indices[indicesIndex++] = index + 2;\n    indices[indicesIndex++] = index + 3;\n\n    index += 4;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: BoundingSphere.fromPoints(positions),\n    geometryType: GeometryType.POLYLINES,\n  });\n};\nexport default PolylineGeometry;\n"]},"metadata":{},"sourceType":"module"}