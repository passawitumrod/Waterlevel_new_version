{"ast":null,"code":"import when from \"../ThirdParty/when.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport Intersections2D from \"./Intersections2D.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport TerrainMesh from \"./TerrainMesh.js\";\n/**\n * Terrain data for a single tile where the terrain data is represented as a quantized mesh.  A quantized\n * mesh consists of three vertex attributes, longitude, latitude, and height.  All attributes are expressed\n * as 16-bit values in the range 0 to 32767.  Longitude and latitude are zero at the southwest corner\n * of the tile and 32767 at the northeast corner.  Height is zero at the minimum height in the tile\n * and 32767 at the maximum height in the tile.\n *\n * @alias QuantizedMeshTerrainData\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Uint16Array} options.quantizedVertices The buffer containing the quantized mesh.\n * @param {Uint16Array|Uint32Array} options.indices The indices specifying how the quantized vertices are linked\n *                      together into triangles.  Each three indices specifies one triangle.\n * @param {Number} options.minimumHeight The minimum terrain height within the tile, in meters above the ellipsoid.\n * @param {Number} options.maximumHeight The maximum terrain height within the tile, in meters above the ellipsoid.\n * @param {BoundingSphere} options.boundingSphere A sphere bounding all of the vertices in the mesh.\n * @param {OrientedBoundingBox} [options.orientedBoundingBox] An OrientedBoundingBox bounding all of the vertices in the mesh.\n * @param {Cartesian3} options.horizonOcclusionPoint The horizon occlusion point of the mesh.  If this point\n *                      is below the horizon, the entire tile is assumed to be below the horizon as well.\n *                      The point is expressed in ellipsoid-scaled coordinates.\n * @param {Number[]} options.westIndices The indices of the vertices on the western edge of the tile.\n * @param {Number[]} options.southIndices The indices of the vertices on the southern edge of the tile.\n * @param {Number[]} options.eastIndices The indices of the vertices on the eastern edge of the tile.\n * @param {Number[]} options.northIndices The indices of the vertices on the northern edge of the tile.\n * @param {Number} options.westSkirtHeight The height of the skirt to add on the western edge of the tile.\n * @param {Number} options.southSkirtHeight The height of the skirt to add on the southern edge of the tile.\n * @param {Number} options.eastSkirtHeight The height of the skirt to add on the eastern edge of the tile.\n * @param {Number} options.northSkirtHeight The height of the skirt to add on the northern edge of the tile.\n * @param {Number} [options.childTileMask=15] A bit mask indicating which of this tile's four children exist.\n *                 If a child's bit is set, geometry will be requested for that tile as well when it\n *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is\n *                 instead upsampled from the parent.  The bit values are as follows:\n *                 <table>\n *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *                  <tr><td>2</td><td>4</td><td>Northwest</td></tr>\n *                  <tr><td>3</td><td>8</td><td>Northeast</td></tr>\n *                 </table>\n * @param {Boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;\n *                  otherwise, false.\n * @param {Uint8Array} [options.encodedNormals] The buffer containing per vertex normals, encoded using 'oct' encoding\n * @param {Uint8Array} [options.waterMask] The buffer containing the watermask.\n * @param {Credit[]} [options.credits] Array of credits for this tile.\n *\n *\n * @example\n * var data = new Cesium.QuantizedMeshTerrainData({\n *     minimumHeight : -100,\n *     maximumHeight : 2101,\n *     quantizedVertices : new Uint16Array([// order is SW NW SE NE\n *                                          // longitude\n *                                          0, 0, 32767, 32767,\n *                                          // latitude\n *                                          0, 32767, 0, 32767,\n *                                          // heights\n *                                          16384, 0, 32767, 16384]),\n *     indices : new Uint16Array([0, 3, 1,\n *                                0, 2, 3]),\n *     boundingSphere : new Cesium.BoundingSphere(new Cesium.Cartesian3(1.0, 2.0, 3.0), 10000),\n *     orientedBoundingBox : new Cesium.OrientedBoundingBox(new Cesium.Cartesian3(1.0, 2.0, 3.0), Cesium.Matrix3.fromRotationX(Cesium.Math.PI, new Cesium.Matrix3())),\n *     horizonOcclusionPoint : new Cesium.Cartesian3(3.0, 2.0, 1.0),\n *     westIndices : [0, 1],\n *     southIndices : [0, 1],\n *     eastIndices : [2, 3],\n *     northIndices : [1, 3],\n *     westSkirtHeight : 1.0,\n *     southSkirtHeight : 1.0,\n *     eastSkirtHeight : 1.0,\n *     northSkirtHeight : 1.0\n * });\n *\n * @see TerrainData\n * @see HeightmapTerrainData\n * @see GoogleEarthEnterpriseTerrainData\n */\n\nfunction QuantizedMeshTerrainData(options) {\n  //>>includeStart('debug', pragmas.debug)\n  if (!defined(options) || !defined(options.quantizedVertices)) {\n    throw new DeveloperError(\"options.quantizedVertices is required.\");\n  }\n\n  if (!defined(options.indices)) {\n    throw new DeveloperError(\"options.indices is required.\");\n  }\n\n  if (!defined(options.minimumHeight)) {\n    throw new DeveloperError(\"options.minimumHeight is required.\");\n  }\n\n  if (!defined(options.maximumHeight)) {\n    throw new DeveloperError(\"options.maximumHeight is required.\");\n  }\n\n  if (!defined(options.maximumHeight)) {\n    throw new DeveloperError(\"options.maximumHeight is required.\");\n  }\n\n  if (!defined(options.boundingSphere)) {\n    throw new DeveloperError(\"options.boundingSphere is required.\");\n  }\n\n  if (!defined(options.horizonOcclusionPoint)) {\n    throw new DeveloperError(\"options.horizonOcclusionPoint is required.\");\n  }\n\n  if (!defined(options.westIndices)) {\n    throw new DeveloperError(\"options.westIndices is required.\");\n  }\n\n  if (!defined(options.southIndices)) {\n    throw new DeveloperError(\"options.southIndices is required.\");\n  }\n\n  if (!defined(options.eastIndices)) {\n    throw new DeveloperError(\"options.eastIndices is required.\");\n  }\n\n  if (!defined(options.northIndices)) {\n    throw new DeveloperError(\"options.northIndices is required.\");\n  }\n\n  if (!defined(options.westSkirtHeight)) {\n    throw new DeveloperError(\"options.westSkirtHeight is required.\");\n  }\n\n  if (!defined(options.southSkirtHeight)) {\n    throw new DeveloperError(\"options.southSkirtHeight is required.\");\n  }\n\n  if (!defined(options.eastSkirtHeight)) {\n    throw new DeveloperError(\"options.eastSkirtHeight is required.\");\n  }\n\n  if (!defined(options.northSkirtHeight)) {\n    throw new DeveloperError(\"options.northSkirtHeight is required.\");\n  } //>>includeEnd('debug');\n\n\n  this._quantizedVertices = options.quantizedVertices;\n  this._encodedNormals = options.encodedNormals;\n  this._indices = options.indices;\n  this._minimumHeight = options.minimumHeight;\n  this._maximumHeight = options.maximumHeight;\n  this._boundingSphere = options.boundingSphere;\n  this._orientedBoundingBox = options.orientedBoundingBox;\n  this._horizonOcclusionPoint = options.horizonOcclusionPoint;\n  this._credits = options.credits;\n  var vertexCount = this._quantizedVertices.length / 3;\n\n  var uValues = this._uValues = this._quantizedVertices.subarray(0, vertexCount);\n\n  var vValues = this._vValues = this._quantizedVertices.subarray(vertexCount, 2 * vertexCount);\n\n  this._heightValues = this._quantizedVertices.subarray(2 * vertexCount, 3 * vertexCount); // We don't assume that we can count on the edge vertices being sorted by u or v.\n\n  function sortByV(a, b) {\n    return vValues[a] - vValues[b];\n  }\n\n  function sortByU(a, b) {\n    return uValues[a] - uValues[b];\n  }\n\n  this._westIndices = sortIndicesIfNecessary(options.westIndices, sortByV, vertexCount);\n  this._southIndices = sortIndicesIfNecessary(options.southIndices, sortByU, vertexCount);\n  this._eastIndices = sortIndicesIfNecessary(options.eastIndices, sortByV, vertexCount);\n  this._northIndices = sortIndicesIfNecessary(options.northIndices, sortByU, vertexCount);\n  this._westSkirtHeight = options.westSkirtHeight;\n  this._southSkirtHeight = options.southSkirtHeight;\n  this._eastSkirtHeight = options.eastSkirtHeight;\n  this._northSkirtHeight = options.northSkirtHeight;\n  this._childTileMask = defaultValue(options.childTileMask, 15);\n  this._createdByUpsampling = defaultValue(options.createdByUpsampling, false);\n  this._waterMask = options.waterMask;\n  this._mesh = undefined;\n}\n\nObject.defineProperties(QuantizedMeshTerrainData.prototype, {\n  /**\n   * An array of credits for this tile.\n   * @memberof QuantizedMeshTerrainData.prototype\n   * @type {Credit[]}\n   */\n  credits: {\n    get: function () {\n      return this._credits;\n    }\n  },\n\n  /**\n   * The water mask included in this terrain data, if any.  A water mask is a rectangular\n   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n   * @memberof QuantizedMeshTerrainData.prototype\n   * @type {Uint8Array|Image|Canvas}\n   */\n  waterMask: {\n    get: function () {\n      return this._waterMask;\n    }\n  },\n  childTileMask: {\n    get: function () {\n      return this._childTileMask;\n    }\n  },\n  canUpsample: {\n    get: function () {\n      return defined(this._mesh);\n    }\n  }\n});\nvar arrayScratch = [];\n\nfunction sortIndicesIfNecessary(indices, sortFunction, vertexCount) {\n  arrayScratch.length = indices.length;\n  var needsSort = false;\n\n  for (var i = 0, len = indices.length; i < len; ++i) {\n    arrayScratch[i] = indices[i];\n    needsSort = needsSort || i > 0 && sortFunction(indices[i - 1], indices[i]) > 0;\n  }\n\n  if (needsSort) {\n    arrayScratch.sort(sortFunction);\n    return IndexDatatype.createTypedArray(vertexCount, arrayScratch);\n  }\n\n  return indices;\n}\n\nvar createMeshTaskProcessor = new TaskProcessor(\"createVerticesFromQuantizedTerrainMesh\");\n/**\n * Creates a {@link TerrainMesh} from this terrain data.\n *\n * @private\n *\n * @param {TilingScheme} tilingScheme The tiling scheme to which this tile belongs.\n * @param {Number} x The X coordinate of the tile for which to create the terrain data.\n * @param {Number} y The Y coordinate of the tile for which to create the terrain data.\n * @param {Number} level The level of the tile for which to create the terrain data.\n * @param {Number} [exaggeration=1.0] The scale used to exaggerate the terrain.\n * @returns {Promise.<TerrainMesh>|undefined} A promise for the terrain mesh, or undefined if too many\n *          asynchronous mesh creations are already in progress and the operation should\n *          be retried later.\n */\n\nQuantizedMeshTerrainData.prototype.createMesh = function (tilingScheme, x, y, level, exaggeration) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(tilingScheme)) {\n    throw new DeveloperError(\"tilingScheme is required.\");\n  }\n\n  if (!defined(x)) {\n    throw new DeveloperError(\"x is required.\");\n  }\n\n  if (!defined(y)) {\n    throw new DeveloperError(\"y is required.\");\n  }\n\n  if (!defined(level)) {\n    throw new DeveloperError(\"level is required.\");\n  } //>>includeEnd('debug');\n\n\n  var ellipsoid = tilingScheme.ellipsoid;\n  var rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n  exaggeration = defaultValue(exaggeration, 1.0);\n  var verticesPromise = createMeshTaskProcessor.scheduleTask({\n    minimumHeight: this._minimumHeight,\n    maximumHeight: this._maximumHeight,\n    quantizedVertices: this._quantizedVertices,\n    octEncodedNormals: this._encodedNormals,\n    includeWebMercatorT: true,\n    indices: this._indices,\n    westIndices: this._westIndices,\n    southIndices: this._southIndices,\n    eastIndices: this._eastIndices,\n    northIndices: this._northIndices,\n    westSkirtHeight: this._westSkirtHeight,\n    southSkirtHeight: this._southSkirtHeight,\n    eastSkirtHeight: this._eastSkirtHeight,\n    northSkirtHeight: this._northSkirtHeight,\n    rectangle: rectangle,\n    relativeToCenter: this._boundingSphere.center,\n    ellipsoid: ellipsoid,\n    exaggeration: exaggeration\n  });\n\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  var that = this;\n  return when(verticesPromise, function (result) {\n    var vertexCountWithoutSkirts = that._quantizedVertices.length / 3;\n    var vertexCount = vertexCountWithoutSkirts + that._westIndices.length + that._southIndices.length + that._eastIndices.length + that._northIndices.length;\n    var indicesTypedArray = IndexDatatype.createTypedArray(vertexCount, result.indices);\n    var vertices = new Float32Array(result.vertices);\n    var rtc = result.center;\n    var minimumHeight = result.minimumHeight;\n    var maximumHeight = result.maximumHeight;\n    var boundingSphere = defaultValue(BoundingSphere.clone(result.boundingSphere), that._boundingSphere);\n    var obb = defaultValue(OrientedBoundingBox.clone(result.orientedBoundingBox), that._orientedBoundingBox);\n    var occludeePointInScaledSpace = defaultValue(Cartesian3.clone(result.occludeePointInScaledSpace), that._horizonOcclusionPoint);\n    var stride = result.vertexStride;\n    var terrainEncoding = TerrainEncoding.clone(result.encoding); // Clone complex result objects because the transfer from the web worker\n    // has stripped them down to JSON-style objects.\n\n    that._mesh = new TerrainMesh(rtc, vertices, indicesTypedArray, result.indexCountWithoutSkirts, vertexCountWithoutSkirts, minimumHeight, maximumHeight, boundingSphere, occludeePointInScaledSpace, stride, obb, terrainEncoding, exaggeration, result.westIndicesSouthToNorth, result.southIndicesEastToWest, result.eastIndicesNorthToSouth, result.northIndicesWestToEast); // Free memory received from server after mesh is created.\n\n    that._quantizedVertices = undefined;\n    that._encodedNormals = undefined;\n    that._indices = undefined;\n    that._uValues = undefined;\n    that._vValues = undefined;\n    that._heightValues = undefined;\n    that._westIndices = undefined;\n    that._southIndices = undefined;\n    that._eastIndices = undefined;\n    that._northIndices = undefined;\n    return that._mesh;\n  });\n};\n\nvar upsampleTaskProcessor = new TaskProcessor(\"upsampleQuantizedTerrainMesh\");\n/**\n * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the\n * vertices in this instance, interpolated if necessary.\n *\n * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.\n * @param {Number} thisX The X coordinate of this tile in the tiling scheme.\n * @param {Number} thisY The Y coordinate of this tile in the tiling scheme.\n * @param {Number} thisLevel The level of this tile in the tiling scheme.\n * @param {Number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.\n * @returns {Promise.<QuantizedMeshTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,\n *          or undefined if too many asynchronous upsample operations are in progress and the request has been\n *          deferred.\n */\n\nQuantizedMeshTerrainData.prototype.upsample = function (tilingScheme, thisX, thisY, thisLevel, descendantX, descendantY, descendantLevel) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(tilingScheme)) {\n    throw new DeveloperError(\"tilingScheme is required.\");\n  }\n\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n\n  if (!defined(thisLevel)) {\n    throw new DeveloperError(\"thisLevel is required.\");\n  }\n\n  if (!defined(descendantX)) {\n    throw new DeveloperError(\"descendantX is required.\");\n  }\n\n  if (!defined(descendantY)) {\n    throw new DeveloperError(\"descendantY is required.\");\n  }\n\n  if (!defined(descendantLevel)) {\n    throw new DeveloperError(\"descendantLevel is required.\");\n  }\n\n  var levelDifference = descendantLevel - thisLevel;\n\n  if (levelDifference > 1) {\n    throw new DeveloperError(\"Upsampling through more than one level at a time is not currently supported.\");\n  } //>>includeEnd('debug');\n\n\n  var mesh = this._mesh;\n\n  if (!defined(this._mesh)) {\n    return undefined;\n  }\n\n  var isEastChild = thisX * 2 !== descendantX;\n  var isNorthChild = thisY * 2 === descendantY;\n  var ellipsoid = tilingScheme.ellipsoid;\n  var childRectangle = tilingScheme.tileXYToRectangle(descendantX, descendantY, descendantLevel);\n  var upsamplePromise = upsampleTaskProcessor.scheduleTask({\n    vertices: mesh.vertices,\n    vertexCountWithoutSkirts: mesh.vertexCountWithoutSkirts,\n    indices: mesh.indices,\n    indexCountWithoutSkirts: mesh.indexCountWithoutSkirts,\n    encoding: mesh.encoding,\n    minimumHeight: this._minimumHeight,\n    maximumHeight: this._maximumHeight,\n    isEastChild: isEastChild,\n    isNorthChild: isNorthChild,\n    childRectangle: childRectangle,\n    ellipsoid: ellipsoid,\n    exaggeration: mesh.exaggeration\n  });\n\n  if (!defined(upsamplePromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  var shortestSkirt = Math.min(this._westSkirtHeight, this._eastSkirtHeight);\n  shortestSkirt = Math.min(shortestSkirt, this._southSkirtHeight);\n  shortestSkirt = Math.min(shortestSkirt, this._northSkirtHeight);\n  var westSkirtHeight = isEastChild ? shortestSkirt * 0.5 : this._westSkirtHeight;\n  var southSkirtHeight = isNorthChild ? shortestSkirt * 0.5 : this._southSkirtHeight;\n  var eastSkirtHeight = isEastChild ? this._eastSkirtHeight : shortestSkirt * 0.5;\n  var northSkirtHeight = isNorthChild ? this._northSkirtHeight : shortestSkirt * 0.5;\n  var credits = this._credits;\n  return when(upsamplePromise).then(function (result) {\n    var quantizedVertices = new Uint16Array(result.vertices);\n    var indicesTypedArray = IndexDatatype.createTypedArray(quantizedVertices.length / 3, result.indices);\n    var encodedNormals;\n\n    if (defined(result.encodedNormals)) {\n      encodedNormals = new Uint8Array(result.encodedNormals);\n    }\n\n    return new QuantizedMeshTerrainData({\n      quantizedVertices: quantizedVertices,\n      indices: indicesTypedArray,\n      encodedNormals: encodedNormals,\n      minimumHeight: result.minimumHeight,\n      maximumHeight: result.maximumHeight,\n      boundingSphere: BoundingSphere.clone(result.boundingSphere),\n      orientedBoundingBox: OrientedBoundingBox.clone(result.orientedBoundingBox),\n      horizonOcclusionPoint: Cartesian3.clone(result.horizonOcclusionPoint),\n      westIndices: result.westIndices,\n      southIndices: result.southIndices,\n      eastIndices: result.eastIndices,\n      northIndices: result.northIndices,\n      westSkirtHeight: westSkirtHeight,\n      southSkirtHeight: southSkirtHeight,\n      eastSkirtHeight: eastSkirtHeight,\n      northSkirtHeight: northSkirtHeight,\n      childTileMask: 0,\n      credits: credits,\n      createdByUpsampling: true\n    });\n  });\n};\n\nvar maxShort = 32767;\nvar barycentricCoordinateScratch = new Cartesian3();\n/**\n * Computes the terrain height at a specified longitude and latitude.\n *\n * @param {Rectangle} rectangle The rectangle covered by this terrain data.\n * @param {Number} longitude The longitude in radians.\n * @param {Number} latitude The latitude in radians.\n * @returns {Number} The terrain height at the specified position.  The position is clamped to\n *          the rectangle, so expect incorrect results for positions far outside the rectangle.\n */\n\nQuantizedMeshTerrainData.prototype.interpolateHeight = function (rectangle, longitude, latitude) {\n  var u = CesiumMath.clamp((longitude - rectangle.west) / rectangle.width, 0.0, 1.0);\n  u *= maxShort;\n  var v = CesiumMath.clamp((latitude - rectangle.south) / rectangle.height, 0.0, 1.0);\n  v *= maxShort;\n\n  if (!defined(this._mesh)) {\n    return interpolateHeight(this, u, v);\n  }\n\n  return interpolateMeshHeight(this, u, v);\n};\n\nfunction pointInBoundingBox(u, v, u0, v0, u1, v1, u2, v2) {\n  var minU = Math.min(u0, u1, u2);\n  var maxU = Math.max(u0, u1, u2);\n  var minV = Math.min(v0, v1, v2);\n  var maxV = Math.max(v0, v1, v2);\n  return u >= minU && u <= maxU && v >= minV && v <= maxV;\n}\n\nvar texCoordScratch0 = new Cartesian2();\nvar texCoordScratch1 = new Cartesian2();\nvar texCoordScratch2 = new Cartesian2();\n\nfunction interpolateMeshHeight(terrainData, u, v) {\n  var mesh = terrainData._mesh;\n  var vertices = mesh.vertices;\n  var encoding = mesh.encoding;\n  var indices = mesh.indices;\n\n  for (var i = 0, len = indices.length; i < len; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n    var uv0 = encoding.decodeTextureCoordinates(vertices, i0, texCoordScratch0);\n    var uv1 = encoding.decodeTextureCoordinates(vertices, i1, texCoordScratch1);\n    var uv2 = encoding.decodeTextureCoordinates(vertices, i2, texCoordScratch2);\n\n    if (pointInBoundingBox(u, v, uv0.x, uv0.y, uv1.x, uv1.y, uv2.x, uv2.y)) {\n      var barycentric = Intersections2D.computeBarycentricCoordinates(u, v, uv0.x, uv0.y, uv1.x, uv1.y, uv2.x, uv2.y, barycentricCoordinateScratch);\n\n      if (barycentric.x >= -1e-15 && barycentric.y >= -1e-15 && barycentric.z >= -1e-15) {\n        var h0 = encoding.decodeHeight(vertices, i0);\n        var h1 = encoding.decodeHeight(vertices, i1);\n        var h2 = encoding.decodeHeight(vertices, i2);\n        return barycentric.x * h0 + barycentric.y * h1 + barycentric.z * h2;\n      }\n    }\n  } // Position does not lie in any triangle in this mesh.\n\n\n  return undefined;\n}\n\nfunction interpolateHeight(terrainData, u, v) {\n  var uBuffer = terrainData._uValues;\n  var vBuffer = terrainData._vValues;\n  var heightBuffer = terrainData._heightValues;\n  var indices = terrainData._indices;\n\n  for (var i = 0, len = indices.length; i < len; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n    var u0 = uBuffer[i0];\n    var u1 = uBuffer[i1];\n    var u2 = uBuffer[i2];\n    var v0 = vBuffer[i0];\n    var v1 = vBuffer[i1];\n    var v2 = vBuffer[i2];\n\n    if (pointInBoundingBox(u, v, u0, v0, u1, v1, u2, v2)) {\n      var barycentric = Intersections2D.computeBarycentricCoordinates(u, v, u0, v0, u1, v1, u2, v2, barycentricCoordinateScratch);\n\n      if (barycentric.x >= -1e-15 && barycentric.y >= -1e-15 && barycentric.z >= -1e-15) {\n        var quantizedHeight = barycentric.x * heightBuffer[i0] + barycentric.y * heightBuffer[i1] + barycentric.z * heightBuffer[i2];\n        return CesiumMath.lerp(terrainData._minimumHeight, terrainData._maximumHeight, quantizedHeight / maxShort);\n      }\n    }\n  } // Position does not lie in any triangle in this mesh.\n\n\n  return undefined;\n}\n/**\n * Determines if a given child tile is available, based on the\n * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed\n * to be one of the four children of this tile.  If non-child tile coordinates are\n * given, the availability of the southeast child tile is returned.\n *\n * @param {Number} thisX The tile X coordinate of this (the parent) tile.\n * @param {Number} thisY The tile Y coordinate of this (the parent) tile.\n * @param {Number} childX The tile X coordinate of the child tile to check for availability.\n * @param {Number} childY The tile Y coordinate of the child tile to check for availability.\n * @returns {Boolean} True if the child tile is available; otherwise, false.\n */\n\n\nQuantizedMeshTerrainData.prototype.isChildAvailable = function (thisX, thisY, childX, childY) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n\n  if (!defined(childX)) {\n    throw new DeveloperError(\"childX is required.\");\n  }\n\n  if (!defined(childY)) {\n    throw new DeveloperError(\"childY is required.\");\n  } //>>includeEnd('debug');\n\n\n  var bitNumber = 2; // northwest child\n\n  if (childX !== thisX * 2) {\n    ++bitNumber; // east child\n  }\n\n  if (childY !== thisY * 2) {\n    bitNumber -= 2; // south child\n  }\n\n  return (this._childTileMask & 1 << bitNumber) !== 0;\n};\n/**\n * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution\n * terrain data.  If this value is false, the data was obtained from some other source, such\n * as by downloading it from a remote server.  This method should return true for instances\n * returned from a call to {@link HeightmapTerrainData#upsample}.\n *\n * @returns {Boolean} True if this instance was created by upsampling; otherwise, false.\n */\n\n\nQuantizedMeshTerrainData.prototype.wasCreatedByUpsampling = function () {\n  return this._createdByUpsampling;\n};\n\nexport default QuantizedMeshTerrainData;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/QuantizedMeshTerrainData.js"],"names":["when","BoundingSphere","Cartesian2","Cartesian3","defaultValue","defined","DeveloperError","IndexDatatype","Intersections2D","CesiumMath","OrientedBoundingBox","TaskProcessor","TerrainEncoding","TerrainMesh","QuantizedMeshTerrainData","options","quantizedVertices","indices","minimumHeight","maximumHeight","boundingSphere","horizonOcclusionPoint","westIndices","southIndices","eastIndices","northIndices","westSkirtHeight","southSkirtHeight","eastSkirtHeight","northSkirtHeight","_quantizedVertices","_encodedNormals","encodedNormals","_indices","_minimumHeight","_maximumHeight","_boundingSphere","_orientedBoundingBox","orientedBoundingBox","_horizonOcclusionPoint","_credits","credits","vertexCount","length","uValues","_uValues","subarray","vValues","_vValues","_heightValues","sortByV","a","b","sortByU","_westIndices","sortIndicesIfNecessary","_southIndices","_eastIndices","_northIndices","_westSkirtHeight","_southSkirtHeight","_eastSkirtHeight","_northSkirtHeight","_childTileMask","childTileMask","_createdByUpsampling","createdByUpsampling","_waterMask","waterMask","_mesh","undefined","Object","defineProperties","prototype","get","canUpsample","arrayScratch","sortFunction","needsSort","i","len","sort","createTypedArray","createMeshTaskProcessor","createMesh","tilingScheme","x","y","level","exaggeration","ellipsoid","rectangle","tileXYToRectangle","verticesPromise","scheduleTask","octEncodedNormals","includeWebMercatorT","relativeToCenter","center","that","result","vertexCountWithoutSkirts","indicesTypedArray","vertices","Float32Array","rtc","clone","obb","occludeePointInScaledSpace","stride","vertexStride","terrainEncoding","encoding","indexCountWithoutSkirts","westIndicesSouthToNorth","southIndicesEastToWest","eastIndicesNorthToSouth","northIndicesWestToEast","upsampleTaskProcessor","upsample","thisX","thisY","thisLevel","descendantX","descendantY","descendantLevel","levelDifference","mesh","isEastChild","isNorthChild","childRectangle","upsamplePromise","shortestSkirt","Math","min","then","Uint16Array","Uint8Array","maxShort","barycentricCoordinateScratch","interpolateHeight","longitude","latitude","u","clamp","west","width","v","south","height","interpolateMeshHeight","pointInBoundingBox","u0","v0","u1","v1","u2","v2","minU","maxU","max","minV","maxV","texCoordScratch0","texCoordScratch1","texCoordScratch2","terrainData","i0","i1","i2","uv0","decodeTextureCoordinates","uv1","uv2","barycentric","computeBarycentricCoordinates","z","h0","decodeHeight","h1","h2","uBuffer","vBuffer","heightBuffer","quantizedHeight","lerp","isChildAvailable","childX","childY","bitNumber","wasCreatedByUpsampling"],"mappings":"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","sourcesContent":["import when from \"../ThirdParty/when.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport Intersections2D from \"./Intersections2D.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport TerrainMesh from \"./TerrainMesh.js\";\n\n/**\n * Terrain data for a single tile where the terrain data is represented as a quantized mesh.  A quantized\n * mesh consists of three vertex attributes, longitude, latitude, and height.  All attributes are expressed\n * as 16-bit values in the range 0 to 32767.  Longitude and latitude are zero at the southwest corner\n * of the tile and 32767 at the northeast corner.  Height is zero at the minimum height in the tile\n * and 32767 at the maximum height in the tile.\n *\n * @alias QuantizedMeshTerrainData\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Uint16Array} options.quantizedVertices The buffer containing the quantized mesh.\n * @param {Uint16Array|Uint32Array} options.indices The indices specifying how the quantized vertices are linked\n *                      together into triangles.  Each three indices specifies one triangle.\n * @param {Number} options.minimumHeight The minimum terrain height within the tile, in meters above the ellipsoid.\n * @param {Number} options.maximumHeight The maximum terrain height within the tile, in meters above the ellipsoid.\n * @param {BoundingSphere} options.boundingSphere A sphere bounding all of the vertices in the mesh.\n * @param {OrientedBoundingBox} [options.orientedBoundingBox] An OrientedBoundingBox bounding all of the vertices in the mesh.\n * @param {Cartesian3} options.horizonOcclusionPoint The horizon occlusion point of the mesh.  If this point\n *                      is below the horizon, the entire tile is assumed to be below the horizon as well.\n *                      The point is expressed in ellipsoid-scaled coordinates.\n * @param {Number[]} options.westIndices The indices of the vertices on the western edge of the tile.\n * @param {Number[]} options.southIndices The indices of the vertices on the southern edge of the tile.\n * @param {Number[]} options.eastIndices The indices of the vertices on the eastern edge of the tile.\n * @param {Number[]} options.northIndices The indices of the vertices on the northern edge of the tile.\n * @param {Number} options.westSkirtHeight The height of the skirt to add on the western edge of the tile.\n * @param {Number} options.southSkirtHeight The height of the skirt to add on the southern edge of the tile.\n * @param {Number} options.eastSkirtHeight The height of the skirt to add on the eastern edge of the tile.\n * @param {Number} options.northSkirtHeight The height of the skirt to add on the northern edge of the tile.\n * @param {Number} [options.childTileMask=15] A bit mask indicating which of this tile's four children exist.\n *                 If a child's bit is set, geometry will be requested for that tile as well when it\n *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is\n *                 instead upsampled from the parent.  The bit values are as follows:\n *                 <table>\n *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *                  <tr><td>2</td><td>4</td><td>Northwest</td></tr>\n *                  <tr><td>3</td><td>8</td><td>Northeast</td></tr>\n *                 </table>\n * @param {Boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;\n *                  otherwise, false.\n * @param {Uint8Array} [options.encodedNormals] The buffer containing per vertex normals, encoded using 'oct' encoding\n * @param {Uint8Array} [options.waterMask] The buffer containing the watermask.\n * @param {Credit[]} [options.credits] Array of credits for this tile.\n *\n *\n * @example\n * var data = new Cesium.QuantizedMeshTerrainData({\n *     minimumHeight : -100,\n *     maximumHeight : 2101,\n *     quantizedVertices : new Uint16Array([// order is SW NW SE NE\n *                                          // longitude\n *                                          0, 0, 32767, 32767,\n *                                          // latitude\n *                                          0, 32767, 0, 32767,\n *                                          // heights\n *                                          16384, 0, 32767, 16384]),\n *     indices : new Uint16Array([0, 3, 1,\n *                                0, 2, 3]),\n *     boundingSphere : new Cesium.BoundingSphere(new Cesium.Cartesian3(1.0, 2.0, 3.0), 10000),\n *     orientedBoundingBox : new Cesium.OrientedBoundingBox(new Cesium.Cartesian3(1.0, 2.0, 3.0), Cesium.Matrix3.fromRotationX(Cesium.Math.PI, new Cesium.Matrix3())),\n *     horizonOcclusionPoint : new Cesium.Cartesian3(3.0, 2.0, 1.0),\n *     westIndices : [0, 1],\n *     southIndices : [0, 1],\n *     eastIndices : [2, 3],\n *     northIndices : [1, 3],\n *     westSkirtHeight : 1.0,\n *     southSkirtHeight : 1.0,\n *     eastSkirtHeight : 1.0,\n *     northSkirtHeight : 1.0\n * });\n *\n * @see TerrainData\n * @see HeightmapTerrainData\n * @see GoogleEarthEnterpriseTerrainData\n */\nfunction QuantizedMeshTerrainData(options) {\n  //>>includeStart('debug', pragmas.debug)\n  if (!defined(options) || !defined(options.quantizedVertices)) {\n    throw new DeveloperError(\"options.quantizedVertices is required.\");\n  }\n  if (!defined(options.indices)) {\n    throw new DeveloperError(\"options.indices is required.\");\n  }\n  if (!defined(options.minimumHeight)) {\n    throw new DeveloperError(\"options.minimumHeight is required.\");\n  }\n  if (!defined(options.maximumHeight)) {\n    throw new DeveloperError(\"options.maximumHeight is required.\");\n  }\n  if (!defined(options.maximumHeight)) {\n    throw new DeveloperError(\"options.maximumHeight is required.\");\n  }\n  if (!defined(options.boundingSphere)) {\n    throw new DeveloperError(\"options.boundingSphere is required.\");\n  }\n  if (!defined(options.horizonOcclusionPoint)) {\n    throw new DeveloperError(\"options.horizonOcclusionPoint is required.\");\n  }\n  if (!defined(options.westIndices)) {\n    throw new DeveloperError(\"options.westIndices is required.\");\n  }\n  if (!defined(options.southIndices)) {\n    throw new DeveloperError(\"options.southIndices is required.\");\n  }\n  if (!defined(options.eastIndices)) {\n    throw new DeveloperError(\"options.eastIndices is required.\");\n  }\n  if (!defined(options.northIndices)) {\n    throw new DeveloperError(\"options.northIndices is required.\");\n  }\n  if (!defined(options.westSkirtHeight)) {\n    throw new DeveloperError(\"options.westSkirtHeight is required.\");\n  }\n  if (!defined(options.southSkirtHeight)) {\n    throw new DeveloperError(\"options.southSkirtHeight is required.\");\n  }\n  if (!defined(options.eastSkirtHeight)) {\n    throw new DeveloperError(\"options.eastSkirtHeight is required.\");\n  }\n  if (!defined(options.northSkirtHeight)) {\n    throw new DeveloperError(\"options.northSkirtHeight is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._quantizedVertices = options.quantizedVertices;\n  this._encodedNormals = options.encodedNormals;\n  this._indices = options.indices;\n  this._minimumHeight = options.minimumHeight;\n  this._maximumHeight = options.maximumHeight;\n  this._boundingSphere = options.boundingSphere;\n  this._orientedBoundingBox = options.orientedBoundingBox;\n  this._horizonOcclusionPoint = options.horizonOcclusionPoint;\n  this._credits = options.credits;\n\n  var vertexCount = this._quantizedVertices.length / 3;\n  var uValues = (this._uValues = this._quantizedVertices.subarray(\n    0,\n    vertexCount\n  ));\n  var vValues = (this._vValues = this._quantizedVertices.subarray(\n    vertexCount,\n    2 * vertexCount\n  ));\n  this._heightValues = this._quantizedVertices.subarray(\n    2 * vertexCount,\n    3 * vertexCount\n  );\n\n  // We don't assume that we can count on the edge vertices being sorted by u or v.\n  function sortByV(a, b) {\n    return vValues[a] - vValues[b];\n  }\n\n  function sortByU(a, b) {\n    return uValues[a] - uValues[b];\n  }\n\n  this._westIndices = sortIndicesIfNecessary(\n    options.westIndices,\n    sortByV,\n    vertexCount\n  );\n  this._southIndices = sortIndicesIfNecessary(\n    options.southIndices,\n    sortByU,\n    vertexCount\n  );\n  this._eastIndices = sortIndicesIfNecessary(\n    options.eastIndices,\n    sortByV,\n    vertexCount\n  );\n  this._northIndices = sortIndicesIfNecessary(\n    options.northIndices,\n    sortByU,\n    vertexCount\n  );\n\n  this._westSkirtHeight = options.westSkirtHeight;\n  this._southSkirtHeight = options.southSkirtHeight;\n  this._eastSkirtHeight = options.eastSkirtHeight;\n  this._northSkirtHeight = options.northSkirtHeight;\n\n  this._childTileMask = defaultValue(options.childTileMask, 15);\n\n  this._createdByUpsampling = defaultValue(options.createdByUpsampling, false);\n  this._waterMask = options.waterMask;\n\n  this._mesh = undefined;\n}\n\nObject.defineProperties(QuantizedMeshTerrainData.prototype, {\n  /**\n   * An array of credits for this tile.\n   * @memberof QuantizedMeshTerrainData.prototype\n   * @type {Credit[]}\n   */\n  credits: {\n    get: function () {\n      return this._credits;\n    },\n  },\n  /**\n   * The water mask included in this terrain data, if any.  A water mask is a rectangular\n   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n   * @memberof QuantizedMeshTerrainData.prototype\n   * @type {Uint8Array|Image|Canvas}\n   */\n  waterMask: {\n    get: function () {\n      return this._waterMask;\n    },\n  },\n\n  childTileMask: {\n    get: function () {\n      return this._childTileMask;\n    },\n  },\n\n  canUpsample: {\n    get: function () {\n      return defined(this._mesh);\n    },\n  },\n});\n\nvar arrayScratch = [];\n\nfunction sortIndicesIfNecessary(indices, sortFunction, vertexCount) {\n  arrayScratch.length = indices.length;\n\n  var needsSort = false;\n  for (var i = 0, len = indices.length; i < len; ++i) {\n    arrayScratch[i] = indices[i];\n    needsSort =\n      needsSort || (i > 0 && sortFunction(indices[i - 1], indices[i]) > 0);\n  }\n\n  if (needsSort) {\n    arrayScratch.sort(sortFunction);\n    return IndexDatatype.createTypedArray(vertexCount, arrayScratch);\n  }\n  return indices;\n}\n\nvar createMeshTaskProcessor = new TaskProcessor(\n  \"createVerticesFromQuantizedTerrainMesh\"\n);\n\n/**\n * Creates a {@link TerrainMesh} from this terrain data.\n *\n * @private\n *\n * @param {TilingScheme} tilingScheme The tiling scheme to which this tile belongs.\n * @param {Number} x The X coordinate of the tile for which to create the terrain data.\n * @param {Number} y The Y coordinate of the tile for which to create the terrain data.\n * @param {Number} level The level of the tile for which to create the terrain data.\n * @param {Number} [exaggeration=1.0] The scale used to exaggerate the terrain.\n * @returns {Promise.<TerrainMesh>|undefined} A promise for the terrain mesh, or undefined if too many\n *          asynchronous mesh creations are already in progress and the operation should\n *          be retried later.\n */\nQuantizedMeshTerrainData.prototype.createMesh = function (\n  tilingScheme,\n  x,\n  y,\n  level,\n  exaggeration\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(tilingScheme)) {\n    throw new DeveloperError(\"tilingScheme is required.\");\n  }\n  if (!defined(x)) {\n    throw new DeveloperError(\"x is required.\");\n  }\n  if (!defined(y)) {\n    throw new DeveloperError(\"y is required.\");\n  }\n  if (!defined(level)) {\n    throw new DeveloperError(\"level is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var ellipsoid = tilingScheme.ellipsoid;\n  var rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n  exaggeration = defaultValue(exaggeration, 1.0);\n\n  var verticesPromise = createMeshTaskProcessor.scheduleTask({\n    minimumHeight: this._minimumHeight,\n    maximumHeight: this._maximumHeight,\n    quantizedVertices: this._quantizedVertices,\n    octEncodedNormals: this._encodedNormals,\n    includeWebMercatorT: true,\n    indices: this._indices,\n    westIndices: this._westIndices,\n    southIndices: this._southIndices,\n    eastIndices: this._eastIndices,\n    northIndices: this._northIndices,\n    westSkirtHeight: this._westSkirtHeight,\n    southSkirtHeight: this._southSkirtHeight,\n    eastSkirtHeight: this._eastSkirtHeight,\n    northSkirtHeight: this._northSkirtHeight,\n    rectangle: rectangle,\n    relativeToCenter: this._boundingSphere.center,\n    ellipsoid: ellipsoid,\n    exaggeration: exaggeration,\n  });\n\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  var that = this;\n  return when(verticesPromise, function (result) {\n    var vertexCountWithoutSkirts = that._quantizedVertices.length / 3;\n    var vertexCount =\n      vertexCountWithoutSkirts +\n      that._westIndices.length +\n      that._southIndices.length +\n      that._eastIndices.length +\n      that._northIndices.length;\n    var indicesTypedArray = IndexDatatype.createTypedArray(\n      vertexCount,\n      result.indices\n    );\n\n    var vertices = new Float32Array(result.vertices);\n    var rtc = result.center;\n    var minimumHeight = result.minimumHeight;\n    var maximumHeight = result.maximumHeight;\n    var boundingSphere = defaultValue(\n      BoundingSphere.clone(result.boundingSphere),\n      that._boundingSphere\n    );\n    var obb = defaultValue(\n      OrientedBoundingBox.clone(result.orientedBoundingBox),\n      that._orientedBoundingBox\n    );\n    var occludeePointInScaledSpace = defaultValue(\n      Cartesian3.clone(result.occludeePointInScaledSpace),\n      that._horizonOcclusionPoint\n    );\n    var stride = result.vertexStride;\n    var terrainEncoding = TerrainEncoding.clone(result.encoding);\n\n    // Clone complex result objects because the transfer from the web worker\n    // has stripped them down to JSON-style objects.\n    that._mesh = new TerrainMesh(\n      rtc,\n      vertices,\n      indicesTypedArray,\n      result.indexCountWithoutSkirts,\n      vertexCountWithoutSkirts,\n      minimumHeight,\n      maximumHeight,\n      boundingSphere,\n      occludeePointInScaledSpace,\n      stride,\n      obb,\n      terrainEncoding,\n      exaggeration,\n      result.westIndicesSouthToNorth,\n      result.southIndicesEastToWest,\n      result.eastIndicesNorthToSouth,\n      result.northIndicesWestToEast\n    );\n\n    // Free memory received from server after mesh is created.\n    that._quantizedVertices = undefined;\n    that._encodedNormals = undefined;\n    that._indices = undefined;\n\n    that._uValues = undefined;\n    that._vValues = undefined;\n    that._heightValues = undefined;\n\n    that._westIndices = undefined;\n    that._southIndices = undefined;\n    that._eastIndices = undefined;\n    that._northIndices = undefined;\n\n    return that._mesh;\n  });\n};\n\nvar upsampleTaskProcessor = new TaskProcessor(\"upsampleQuantizedTerrainMesh\");\n\n/**\n * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the\n * vertices in this instance, interpolated if necessary.\n *\n * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.\n * @param {Number} thisX The X coordinate of this tile in the tiling scheme.\n * @param {Number} thisY The Y coordinate of this tile in the tiling scheme.\n * @param {Number} thisLevel The level of this tile in the tiling scheme.\n * @param {Number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.\n * @returns {Promise.<QuantizedMeshTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,\n *          or undefined if too many asynchronous upsample operations are in progress and the request has been\n *          deferred.\n */\nQuantizedMeshTerrainData.prototype.upsample = function (\n  tilingScheme,\n  thisX,\n  thisY,\n  thisLevel,\n  descendantX,\n  descendantY,\n  descendantLevel\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(tilingScheme)) {\n    throw new DeveloperError(\"tilingScheme is required.\");\n  }\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n  if (!defined(thisLevel)) {\n    throw new DeveloperError(\"thisLevel is required.\");\n  }\n  if (!defined(descendantX)) {\n    throw new DeveloperError(\"descendantX is required.\");\n  }\n  if (!defined(descendantY)) {\n    throw new DeveloperError(\"descendantY is required.\");\n  }\n  if (!defined(descendantLevel)) {\n    throw new DeveloperError(\"descendantLevel is required.\");\n  }\n  var levelDifference = descendantLevel - thisLevel;\n  if (levelDifference > 1) {\n    throw new DeveloperError(\n      \"Upsampling through more than one level at a time is not currently supported.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var mesh = this._mesh;\n  if (!defined(this._mesh)) {\n    return undefined;\n  }\n\n  var isEastChild = thisX * 2 !== descendantX;\n  var isNorthChild = thisY * 2 === descendantY;\n\n  var ellipsoid = tilingScheme.ellipsoid;\n  var childRectangle = tilingScheme.tileXYToRectangle(\n    descendantX,\n    descendantY,\n    descendantLevel\n  );\n\n  var upsamplePromise = upsampleTaskProcessor.scheduleTask({\n    vertices: mesh.vertices,\n    vertexCountWithoutSkirts: mesh.vertexCountWithoutSkirts,\n    indices: mesh.indices,\n    indexCountWithoutSkirts: mesh.indexCountWithoutSkirts,\n    encoding: mesh.encoding,\n    minimumHeight: this._minimumHeight,\n    maximumHeight: this._maximumHeight,\n    isEastChild: isEastChild,\n    isNorthChild: isNorthChild,\n    childRectangle: childRectangle,\n    ellipsoid: ellipsoid,\n    exaggeration: mesh.exaggeration,\n  });\n\n  if (!defined(upsamplePromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  var shortestSkirt = Math.min(this._westSkirtHeight, this._eastSkirtHeight);\n  shortestSkirt = Math.min(shortestSkirt, this._southSkirtHeight);\n  shortestSkirt = Math.min(shortestSkirt, this._northSkirtHeight);\n\n  var westSkirtHeight = isEastChild\n    ? shortestSkirt * 0.5\n    : this._westSkirtHeight;\n  var southSkirtHeight = isNorthChild\n    ? shortestSkirt * 0.5\n    : this._southSkirtHeight;\n  var eastSkirtHeight = isEastChild\n    ? this._eastSkirtHeight\n    : shortestSkirt * 0.5;\n  var northSkirtHeight = isNorthChild\n    ? this._northSkirtHeight\n    : shortestSkirt * 0.5;\n  var credits = this._credits;\n\n  return when(upsamplePromise).then(function (result) {\n    var quantizedVertices = new Uint16Array(result.vertices);\n    var indicesTypedArray = IndexDatatype.createTypedArray(\n      quantizedVertices.length / 3,\n      result.indices\n    );\n    var encodedNormals;\n    if (defined(result.encodedNormals)) {\n      encodedNormals = new Uint8Array(result.encodedNormals);\n    }\n\n    return new QuantizedMeshTerrainData({\n      quantizedVertices: quantizedVertices,\n      indices: indicesTypedArray,\n      encodedNormals: encodedNormals,\n      minimumHeight: result.minimumHeight,\n      maximumHeight: result.maximumHeight,\n      boundingSphere: BoundingSphere.clone(result.boundingSphere),\n      orientedBoundingBox: OrientedBoundingBox.clone(\n        result.orientedBoundingBox\n      ),\n      horizonOcclusionPoint: Cartesian3.clone(result.horizonOcclusionPoint),\n      westIndices: result.westIndices,\n      southIndices: result.southIndices,\n      eastIndices: result.eastIndices,\n      northIndices: result.northIndices,\n      westSkirtHeight: westSkirtHeight,\n      southSkirtHeight: southSkirtHeight,\n      eastSkirtHeight: eastSkirtHeight,\n      northSkirtHeight: northSkirtHeight,\n      childTileMask: 0,\n      credits: credits,\n      createdByUpsampling: true,\n    });\n  });\n};\n\nvar maxShort = 32767;\nvar barycentricCoordinateScratch = new Cartesian3();\n\n/**\n * Computes the terrain height at a specified longitude and latitude.\n *\n * @param {Rectangle} rectangle The rectangle covered by this terrain data.\n * @param {Number} longitude The longitude in radians.\n * @param {Number} latitude The latitude in radians.\n * @returns {Number} The terrain height at the specified position.  The position is clamped to\n *          the rectangle, so expect incorrect results for positions far outside the rectangle.\n */\nQuantizedMeshTerrainData.prototype.interpolateHeight = function (\n  rectangle,\n  longitude,\n  latitude\n) {\n  var u = CesiumMath.clamp(\n    (longitude - rectangle.west) / rectangle.width,\n    0.0,\n    1.0\n  );\n  u *= maxShort;\n  var v = CesiumMath.clamp(\n    (latitude - rectangle.south) / rectangle.height,\n    0.0,\n    1.0\n  );\n  v *= maxShort;\n\n  if (!defined(this._mesh)) {\n    return interpolateHeight(this, u, v);\n  }\n\n  return interpolateMeshHeight(this, u, v);\n};\n\nfunction pointInBoundingBox(u, v, u0, v0, u1, v1, u2, v2) {\n  var minU = Math.min(u0, u1, u2);\n  var maxU = Math.max(u0, u1, u2);\n  var minV = Math.min(v0, v1, v2);\n  var maxV = Math.max(v0, v1, v2);\n  return u >= minU && u <= maxU && v >= minV && v <= maxV;\n}\n\nvar texCoordScratch0 = new Cartesian2();\nvar texCoordScratch1 = new Cartesian2();\nvar texCoordScratch2 = new Cartesian2();\n\nfunction interpolateMeshHeight(terrainData, u, v) {\n  var mesh = terrainData._mesh;\n  var vertices = mesh.vertices;\n  var encoding = mesh.encoding;\n  var indices = mesh.indices;\n\n  for (var i = 0, len = indices.length; i < len; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n\n    var uv0 = encoding.decodeTextureCoordinates(vertices, i0, texCoordScratch0);\n    var uv1 = encoding.decodeTextureCoordinates(vertices, i1, texCoordScratch1);\n    var uv2 = encoding.decodeTextureCoordinates(vertices, i2, texCoordScratch2);\n\n    if (pointInBoundingBox(u, v, uv0.x, uv0.y, uv1.x, uv1.y, uv2.x, uv2.y)) {\n      var barycentric = Intersections2D.computeBarycentricCoordinates(\n        u,\n        v,\n        uv0.x,\n        uv0.y,\n        uv1.x,\n        uv1.y,\n        uv2.x,\n        uv2.y,\n        barycentricCoordinateScratch\n      );\n      if (\n        barycentric.x >= -1e-15 &&\n        barycentric.y >= -1e-15 &&\n        barycentric.z >= -1e-15\n      ) {\n        var h0 = encoding.decodeHeight(vertices, i0);\n        var h1 = encoding.decodeHeight(vertices, i1);\n        var h2 = encoding.decodeHeight(vertices, i2);\n        return barycentric.x * h0 + barycentric.y * h1 + barycentric.z * h2;\n      }\n    }\n  }\n\n  // Position does not lie in any triangle in this mesh.\n  return undefined;\n}\n\nfunction interpolateHeight(terrainData, u, v) {\n  var uBuffer = terrainData._uValues;\n  var vBuffer = terrainData._vValues;\n  var heightBuffer = terrainData._heightValues;\n\n  var indices = terrainData._indices;\n  for (var i = 0, len = indices.length; i < len; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n\n    var u0 = uBuffer[i0];\n    var u1 = uBuffer[i1];\n    var u2 = uBuffer[i2];\n\n    var v0 = vBuffer[i0];\n    var v1 = vBuffer[i1];\n    var v2 = vBuffer[i2];\n\n    if (pointInBoundingBox(u, v, u0, v0, u1, v1, u2, v2)) {\n      var barycentric = Intersections2D.computeBarycentricCoordinates(\n        u,\n        v,\n        u0,\n        v0,\n        u1,\n        v1,\n        u2,\n        v2,\n        barycentricCoordinateScratch\n      );\n      if (\n        barycentric.x >= -1e-15 &&\n        barycentric.y >= -1e-15 &&\n        barycentric.z >= -1e-15\n      ) {\n        var quantizedHeight =\n          barycentric.x * heightBuffer[i0] +\n          barycentric.y * heightBuffer[i1] +\n          barycentric.z * heightBuffer[i2];\n        return CesiumMath.lerp(\n          terrainData._minimumHeight,\n          terrainData._maximumHeight,\n          quantizedHeight / maxShort\n        );\n      }\n    }\n  }\n\n  // Position does not lie in any triangle in this mesh.\n  return undefined;\n}\n\n/**\n * Determines if a given child tile is available, based on the\n * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed\n * to be one of the four children of this tile.  If non-child tile coordinates are\n * given, the availability of the southeast child tile is returned.\n *\n * @param {Number} thisX The tile X coordinate of this (the parent) tile.\n * @param {Number} thisY The tile Y coordinate of this (the parent) tile.\n * @param {Number} childX The tile X coordinate of the child tile to check for availability.\n * @param {Number} childY The tile Y coordinate of the child tile to check for availability.\n * @returns {Boolean} True if the child tile is available; otherwise, false.\n */\nQuantizedMeshTerrainData.prototype.isChildAvailable = function (\n  thisX,\n  thisY,\n  childX,\n  childY\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n  if (!defined(childX)) {\n    throw new DeveloperError(\"childX is required.\");\n  }\n  if (!defined(childY)) {\n    throw new DeveloperError(\"childY is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var bitNumber = 2; // northwest child\n  if (childX !== thisX * 2) {\n    ++bitNumber; // east child\n  }\n  if (childY !== thisY * 2) {\n    bitNumber -= 2; // south child\n  }\n\n  return (this._childTileMask & (1 << bitNumber)) !== 0;\n};\n\n/**\n * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution\n * terrain data.  If this value is false, the data was obtained from some other source, such\n * as by downloading it from a remote server.  This method should return true for instances\n * returned from a call to {@link HeightmapTerrainData#upsample}.\n *\n * @returns {Boolean} True if this instance was created by upsampling; otherwise, false.\n */\nQuantizedMeshTerrainData.prototype.wasCreatedByUpsampling = function () {\n  return this._createdByUpsampling;\n};\nexport default QuantizedMeshTerrainData;\n"]},"metadata":{},"sourceType":"module"}