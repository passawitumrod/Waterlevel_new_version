{"ast":null,"code":"/**\n  @license\n  when.js - https://github.com/cujojs/when\n\n  MIT License (c) copyright B Cavalier & J Hann\n\n * A lightweight CommonJS Promises/A and when() implementation\n * when is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @version 1.7.1\n */\nvar reduceArray, slice, undef; //\n// Public API\n//\n\nwhen.defer = defer; // Create a deferred\n\nwhen.resolve = resolve; // Create a resolved promise\n\nwhen.reject = reject; // Create a rejected promise\n\nwhen.join = join; // Join 2 or more promises\n\nwhen.all = all; // Resolve a list of promises\n\nwhen.map = map; // Array.map() for promises\n\nwhen.reduce = reduce; // Array.reduce() for promises\n\nwhen.any = any; // One-winner race\n\nwhen.some = some; // Multi-winner race\n\nwhen.chain = chain; // Make a promise trigger another resolver\n\nwhen.isPromise = isPromise; // Determine if a thing is a promise\n\n/**\n * Register an observer for a promise or immediate value.\n *\n * @param {*} promiseOrValue\n * @param {function?} [onFulfilled] callback to be called when promiseOrValue is\n *   successfully fulfilled.  If promiseOrValue is an immediate value, callback\n *   will be invoked immediately.\n * @param {function?} [onRejected] callback to be called when promiseOrValue is\n *   rejected.\n * @param {function?} [onProgress] callback to be called when progress updates\n *   are issued for promiseOrValue.\n * @returns {Promise} a new {@link Promise} that will complete with the return\n *   value of callback or errback or the completion value of promiseOrValue if\n *   callback and/or errback is not supplied.\n */\n\nfunction when(promiseOrValue, onFulfilled, onRejected, onProgress) {\n  // Get a trusted promise for the input promiseOrValue, and then\n  // register promise handlers\n  return resolve(promiseOrValue).then(onFulfilled, onRejected, onProgress);\n}\n/**\n * Returns promiseOrValue if promiseOrValue is a {@link Promise}, a new Promise if\n * promiseOrValue is a foreign promise, or a new, already-fulfilled {@link Promise}\n * whose value is promiseOrValue if promiseOrValue is an immediate value.\n *\n * @param {*} promiseOrValue\n * @returns Guaranteed to return a trusted Promise.  If promiseOrValue is a when.js {@link Promise}\n *   returns promiseOrValue, otherwise, returns a new, already-resolved, when.js {@link Promise}\n *   whose resolution value is:\n *   * the resolution value of promiseOrValue if it's a foreign promise, or\n *   * promiseOrValue if it's a value\n */\n\n\nfunction resolve(promiseOrValue) {\n  var promise, deferred;\n\n  if (promiseOrValue instanceof Promise) {\n    // It's a when.js promise, so we trust it\n    promise = promiseOrValue;\n  } else {\n    // It's not a when.js promise. See if it's a foreign promise or a value.\n    if (isPromise(promiseOrValue)) {\n      // It's a thenable, but we don't know where it came from, so don't trust\n      // its implementation entirely.  Introduce a trusted middleman when.js promise\n      deferred = defer(); // IMPORTANT: This is the only place when.js should ever call .then() on an\n      // untrusted promise. Don't expose the return value to the untrusted promise\n\n      promiseOrValue.then(function (value) {\n        deferred.resolve(value);\n      }, function (reason) {\n        deferred.reject(reason);\n      }, function (update) {\n        deferred.progress(update);\n      });\n      promise = deferred.promise;\n    } else {\n      // It's a value, not a promise.  Create a resolved promise for it.\n      promise = fulfilled(promiseOrValue);\n    }\n  }\n\n  return promise;\n}\n/**\n * Returns a rejected promise for the supplied promiseOrValue.  The returned\n * promise will be rejected with:\n * - promiseOrValue, if it is a value, or\n * - if promiseOrValue is a promise\n *   - promiseOrValue's value after it is fulfilled\n *   - promiseOrValue's reason after it is rejected\n * @param {*} promiseOrValue the rejected value of the returned {@link Promise}\n * @returns {Promise} rejected {@link Promise}\n */\n\n\nfunction reject(promiseOrValue) {\n  return when(promiseOrValue, rejected);\n}\n/**\n * Trusted Promise constructor.  A Promise created from this constructor is\n * a trusted when.js promise.  Any other duck-typed promise is considered\n * untrusted.\n * @constructor\n * @name Promise\n */\n\n\nfunction Promise(then) {\n  this.then = then;\n}\n\nPromise.prototype = {\n  /**\n   * Register a callback that will be called when a promise is\n   * fulfilled or rejected.  Optionally also register a progress handler.\n   * Shortcut for .then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress)\n   * @param {function?} [onFulfilledOrRejected]\n   * @param {function?} [onProgress]\n   * @returns {Promise}\n   */\n  always: function (onFulfilledOrRejected, onProgress) {\n    return this.then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress);\n  },\n\n  /**\n   * Register a rejection handler.  Shortcut for .then(undefined, onRejected)\n   * @param {function?} onRejected\n   * @returns {Promise}\n   */\n  otherwise: function (onRejected) {\n    return this.then(undef, onRejected);\n  },\n\n  /**\n   * Shortcut for .then(function() { return value; })\n   * @param  {*} value\n   * @returns {Promise} a promise that:\n   *  - is fulfilled if value is not a promise, or\n   *  - if value is a promise, will fulfill with its value, or reject\n   *    with its reason.\n   */\n  yield: function (value) {\n    return this.then(function () {\n      return value;\n    });\n  },\n\n  /**\n   * Assumes that this promise will fulfill with an array, and arranges\n   * for the onFulfilled to be called with the array as its argument list\n   * i.e. onFulfilled.spread(undefined, array).\n   * @param {function} onFulfilled function to receive spread arguments\n   * @returns {Promise}\n   */\n  spread: function (onFulfilled) {\n    return this.then(function (array) {\n      // array may contain promises, so resolve its contents.\n      return all(array, function (array) {\n        return onFulfilled.apply(undef, array);\n      });\n    });\n  }\n};\n/**\n * Create an already-resolved promise for the supplied value\n * @private\n *\n * @param {*} value\n * @returns {Promise} fulfilled promise\n */\n\nfunction fulfilled(value) {\n  var p = new Promise(function (onFulfilled) {\n    // TODO: Promises/A+ check typeof onFulfilled\n    try {\n      return resolve(onFulfilled ? onFulfilled(value) : value);\n    } catch (e) {\n      return rejected(e);\n    }\n  });\n  return p;\n}\n/**\n * Create an already-rejected {@link Promise} with the supplied\n * rejection reason.\n * @private\n *\n * @param {*} reason\n * @returns {Promise} rejected promise\n */\n\n\nfunction rejected(reason) {\n  var p = new Promise(function (_, onRejected) {\n    // TODO: Promises/A+ check typeof onRejected\n    try {\n      return onRejected ? resolve(onRejected(reason)) : rejected(reason);\n    } catch (e) {\n      return rejected(e);\n    }\n  });\n  return p;\n}\n/**\n * Creates a new, Deferred with fully isolated resolver and promise parts,\n * either or both of which may be given out safely to consumers.\n * The Deferred itself has the full API: resolve, reject, progress, and\n * then. The resolver has resolve, reject, and progress.  The promise\n * only has then.\n *\n * @returns {Deferred}\n */\n\n\nfunction defer() {\n  var deferred, promise, handlers, progressHandlers, _then, _progress, _resolve;\n  /**\n   * The promise for the new deferred\n   * @type {Promise}\n   */\n\n\n  promise = new Promise(then);\n  /**\n   * The full Deferred object, with {@link Promise} and {@link Resolver} parts\n   * @class Deferred\n   * @name Deferred\n   */\n\n  deferred = {\n    then: then,\n    // DEPRECATED: use deferred.promise.then\n    resolve: promiseResolve,\n    reject: promiseReject,\n    // TODO: Consider renaming progress() to notify()\n    progress: promiseProgress,\n    promise: promise,\n    resolver: {\n      resolve: promiseResolve,\n      reject: promiseReject,\n      progress: promiseProgress\n    }\n  };\n  handlers = [];\n  progressHandlers = [];\n  /**\n   * Pre-resolution then() that adds the supplied callback, errback, and progback\n   * functions to the registered listeners\n   * @private\n   *\n   * @param {function?} [onFulfilled] resolution handler\n   * @param {function?} [onRejected] rejection handler\n   * @param {function?} [onProgress] progress handler\n   */\n\n  _then = function (onFulfilled, onRejected, onProgress) {\n    // TODO: Promises/A+ check typeof onFulfilled, onRejected, onProgress\n    var deferred, progressHandler;\n    deferred = defer();\n    progressHandler = typeof onProgress === 'function' ? function (update) {\n      try {\n        // Allow progress handler to transform progress event\n        deferred.progress(onProgress(update));\n      } catch (e) {\n        // Use caught value as progress\n        deferred.progress(e);\n      }\n    } : function (update) {\n      deferred.progress(update);\n    };\n    handlers.push(function (promise) {\n      promise.then(onFulfilled, onRejected).then(deferred.resolve, deferred.reject, progressHandler);\n    });\n    progressHandlers.push(progressHandler);\n    return deferred.promise;\n  };\n  /**\n   * Issue a progress event, notifying all progress listeners\n   * @private\n   * @param {*} update progress event payload to pass to all listeners\n   */\n\n\n  _progress = function (update) {\n    processQueue(progressHandlers, update);\n    return update;\n  };\n  /**\n   * Transition from pre-resolution state to post-resolution state, notifying\n   * all listeners of the resolution or rejection\n   * @private\n   * @param {*} value the value of this deferred\n   */\n\n\n  _resolve = function (value) {\n    value = resolve(value); // Replace _then with one that directly notifies with the result.\n\n    _then = value.then; // Replace _resolve so that this Deferred can only be resolved once\n\n    _resolve = resolve; // Make _progress a noop, to disallow progress for the resolved promise.\n\n    _progress = noop; // Notify handlers\n\n    processQueue(handlers, value); // Free progressHandlers array since we'll never issue progress events\n\n    progressHandlers = handlers = undef;\n    return value;\n  };\n\n  return deferred;\n  /**\n   * Wrapper to allow _then to be replaced safely\n   * @param {function?} [onFulfilled] resolution handler\n   * @param {function?} [onRejected] rejection handler\n   * @param {function?} [onProgress] progress handler\n   * @returns {Promise} new promise\n   */\n\n  function then(onFulfilled, onRejected, onProgress) {\n    // TODO: Promises/A+ check typeof onFulfilled, onRejected, onProgress\n    return _then(onFulfilled, onRejected, onProgress);\n  }\n  /**\n   * Wrapper to allow _resolve to be replaced\n   */\n\n\n  function promiseResolve(val) {\n    return _resolve(val);\n  }\n  /**\n   * Wrapper to allow _reject to be replaced\n   */\n\n\n  function promiseReject(err) {\n    return _resolve(rejected(err));\n  }\n  /**\n   * Wrapper to allow _progress to be replaced\n   */\n\n\n  function promiseProgress(update) {\n    return _progress(update);\n  }\n}\n/**\n * Determines if promiseOrValue is a promise or not.  Uses the feature\n * test from http://wiki.commonjs.org/wiki/Promises/A to determine if\n * promiseOrValue is a promise.\n *\n * @param {*} promiseOrValue anything\n * @returns {boolean} true if promiseOrValue is a {@link Promise}\n */\n\n\nfunction isPromise(promiseOrValue) {\n  return promiseOrValue && typeof promiseOrValue.then === 'function';\n}\n/**\n * Initiates a competitive race, returning a promise that will resolve when\n * howMany of the supplied promisesOrValues have resolved, or will reject when\n * it becomes impossible for howMany to resolve, for example, when\n * (promisesOrValues.length - howMany) + 1 input promises reject.\n *\n * @param {Array} promisesOrValues array of anything, may contain a mix\n *      of promises and values\n * @param howMany {number} number of promisesOrValues to resolve\n * @param {function?} [onFulfilled] resolution handler\n * @param {function?} [onRejected] rejection handler\n * @param {function?} [onProgress] progress handler\n * @returns {Promise} promise that will resolve to an array of howMany values that\n * resolved first, or will reject with an array of (promisesOrValues.length - howMany) + 1\n * rejection reasons.\n */\n\n\nfunction some(promisesOrValues, howMany, onFulfilled, onRejected, onProgress) {\n  checkCallbacks(2, arguments);\n  return when(promisesOrValues, function (promisesOrValues) {\n    var toResolve, toReject, values, reasons, deferred, fulfillOne, rejectOne, progress, len, i;\n    len = promisesOrValues.length >>> 0;\n    toResolve = Math.max(0, Math.min(howMany, len));\n    values = [];\n    toReject = len - toResolve + 1;\n    reasons = [];\n    deferred = defer(); // No items in the input, resolve immediately\n\n    if (!toResolve) {\n      deferred.resolve(values);\n    } else {\n      progress = deferred.progress;\n\n      rejectOne = function (reason) {\n        reasons.push(reason);\n\n        if (! --toReject) {\n          fulfillOne = rejectOne = noop;\n          deferred.reject(reasons);\n        }\n      };\n\n      fulfillOne = function (val) {\n        // This orders the values based on promise resolution order\n        // Another strategy would be to use the original position of\n        // the corresponding promise.\n        values.push(val);\n\n        if (! --toResolve) {\n          fulfillOne = rejectOne = noop;\n          deferred.resolve(values);\n        }\n      };\n\n      for (i = 0; i < len; ++i) {\n        if (i in promisesOrValues) {\n          when(promisesOrValues[i], fulfiller, rejecter, progress);\n        }\n      }\n    }\n\n    return deferred.then(onFulfilled, onRejected, onProgress);\n\n    function rejecter(reason) {\n      rejectOne(reason);\n    }\n\n    function fulfiller(val) {\n      fulfillOne(val);\n    }\n  });\n}\n/**\n * Initiates a competitive race, returning a promise that will resolve when\n * any one of the supplied promisesOrValues has resolved or will reject when\n * *all* promisesOrValues have rejected.\n *\n * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n *      of {@link Promise}s and values\n * @param {function?} [onFulfilled] resolution handler\n * @param {function?} [onRejected] rejection handler\n * @param {function?} [onProgress] progress handler\n * @returns {Promise} promise that will resolve to the value that resolved first, or\n * will reject with an array of all rejected inputs.\n */\n\n\nfunction any(promisesOrValues, onFulfilled, onRejected, onProgress) {\n  function unwrapSingleResult(val) {\n    return onFulfilled ? onFulfilled(val[0]) : val[0];\n  }\n\n  return some(promisesOrValues, 1, unwrapSingleResult, onRejected, onProgress);\n}\n/**\n * Return a promise that will resolve only once all the supplied promisesOrValues\n * have resolved. The resolution value of the returned promise will be an array\n * containing the resolution values of each of the promisesOrValues.\n * @memberOf when\n *\n * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n *      of {@link Promise}s and values\n * @param {function?} [onFulfilled] resolution handler\n * @param {function?} [onRejected] rejection handler\n * @param {function?} [onProgress] progress handler\n * @returns {Promise}\n */\n\n\nfunction all(promisesOrValues, onFulfilled, onRejected, onProgress) {\n  checkCallbacks(1, arguments);\n  return map(promisesOrValues, identity).then(onFulfilled, onRejected, onProgress);\n}\n/**\n * Joins multiple promises into a single returned promise.\n * @returns {Promise} a promise that will fulfill when *all* the input promises\n * have fulfilled, or will reject when *any one* of the input promises rejects.\n */\n\n\nfunction join()\n/* ...promises */\n{\n  return map(arguments, identity);\n}\n/**\n * Traditional map function, similar to `Array.prototype.map()`, but allows\n * input to contain {@link Promise}s and/or values, and mapFunc may return\n * either a value or a {@link Promise}\n *\n * @param {Array|Promise} promise array of anything, may contain a mix\n *      of {@link Promise}s and values\n * @param {function} mapFunc mapping function mapFunc(value) which may return\n *      either a {@link Promise} or value\n * @returns {Promise} a {@link Promise} that will resolve to an array containing\n *      the mapped output values.\n */\n\n\nfunction map(promise, mapFunc) {\n  return when(promise, function (array) {\n    var results, len, toResolve, resolve, i, d; // Since we know the resulting length, we can preallocate the results\n    // array to avoid array expansions.\n\n    toResolve = len = array.length >>> 0;\n    results = [];\n    d = defer();\n\n    if (!toResolve) {\n      d.resolve(results);\n    } else {\n      resolve = function resolveOne(item, i) {\n        when(item, mapFunc).then(function (mapped) {\n          results[i] = mapped;\n\n          if (! --toResolve) {\n            d.resolve(results);\n          }\n        }, d.reject);\n      }; // Since mapFunc may be async, get all invocations of it into flight\n\n\n      for (i = 0; i < len; i++) {\n        if (i in array) {\n          resolve(array[i], i);\n        } else {\n          --toResolve;\n        }\n      }\n    }\n\n    return d.promise;\n  });\n}\n/**\n * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n * input may contain promises and/or values, and reduceFunc\n * may return either a value or a promise, *and* initialValue may\n * be a promise for the starting value.\n *\n * @param {Array|Promise} promise array or promise for an array of anything,\n *      may contain a mix of promises and values.\n * @param {function} reduceFunc reduce function reduce(currentValue, nextValue, index, total),\n *      where total is the total number of items being reduced, and will be the same\n *      in each call to reduceFunc.\n * @returns {Promise} that will resolve to the final reduced value\n */\n\n\nfunction reduce(promise, reduceFunc\n/*, initialValue */\n) {\n  var args = slice.call(arguments, 1);\n  return when(promise, function (array) {\n    var total;\n    total = array.length; // Wrap the supplied reduceFunc with one that handles promises and then\n    // delegates to the supplied.\n\n    args[0] = function (current, val, i) {\n      return when(current, function (c) {\n        return when(val, function (value) {\n          return reduceFunc(c, value, i, total);\n        });\n      });\n    };\n\n    return reduceArray.apply(array, args);\n  });\n}\n/**\n * Ensure that resolution of promiseOrValue will trigger resolver with the\n * value or reason of promiseOrValue, or instead with resolveValue if it is provided.\n *\n * @param promiseOrValue\n * @param {Object} resolver\n * @param {function} resolver.resolve\n * @param {function} resolver.reject\n * @param {*} [resolveValue]\n * @returns {Promise}\n */\n\n\nfunction chain(promiseOrValue, resolver, resolveValue) {\n  var useResolveValue = arguments.length > 2;\n  return when(promiseOrValue, function (val) {\n    val = useResolveValue ? resolveValue : val;\n    resolver.resolve(val);\n    return val;\n  }, function (reason) {\n    resolver.reject(reason);\n    return rejected(reason);\n  }, resolver.progress);\n} //\n// Utility functions\n//\n\n/**\n * Apply all functions in queue to value\n * @param {Array} queue array of functions to execute\n * @param {*} value argument passed to each function\n */\n\n\nfunction processQueue(queue, value) {\n  var handler,\n      i = 0;\n\n  while (handler = queue[i++]) {\n    handler(value);\n  }\n}\n/**\n * Helper that checks arrayOfCallbacks to ensure that each element is either\n * a function, or null or undefined.\n * @private\n * @param {number} start index at which to start checking items in arrayOfCallbacks\n * @param {Array} arrayOfCallbacks array to check\n * @throws {Error} if any element of arrayOfCallbacks is something other than\n * a functions, null, or undefined.\n */\n\n\nfunction checkCallbacks(start, arrayOfCallbacks) {\n  // TODO: Promises/A+ update type checking and docs\n  var arg,\n      i = arrayOfCallbacks.length;\n\n  while (i > start) {\n    arg = arrayOfCallbacks[--i];\n\n    if (arg != null && typeof arg != 'function') {\n      throw new Error('arg ' + i + ' must be a function');\n    }\n  }\n}\n/**\n * No-Op function used in method replacement\n * @private\n */\n\n\nfunction noop() {}\n\nslice = [].slice; // ES5 reduce implementation if native not available\n// See: http://es5.github.com/#x15.4.4.21 as there are many\n// specifics and edge cases.\n\nreduceArray = [].reduce || function (reduceFunc\n/*, initialValue */\n) {\n  /*jshint maxcomplexity: 7*/\n  // ES5 dictates that reduce.length === 1\n  // This implementation deviates from ES5 spec in the following ways:\n  // 1. It does not check if reduceFunc is a Callable\n  var arr, args, reduced, len, i;\n  i = 0; // This generates a jshint warning, despite being valid\n  // \"Missing 'new' prefix when invoking a constructor.\"\n  // See https://github.com/jshint/jshint/issues/392\n\n  arr = Object(this);\n  len = arr.length >>> 0;\n  args = arguments; // If no initialValue, use first item of array (we know length !== 0 here)\n  // and adjust i to start at second item\n\n  if (args.length <= 1) {\n    // Skip to the first real element in the array\n    for (;;) {\n      if (i in arr) {\n        reduced = arr[i++];\n        break;\n      } // If we reached the end of the array without finding any real\n      // elements, it's a TypeError\n\n\n      if (++i >= len) {\n        throw new TypeError();\n      }\n    }\n  } else {\n    // If initialValue provided, use it\n    reduced = args[1];\n  } // Do the actual reduce\n\n\n  for (; i < len; ++i) {\n    // Skip holes\n    if (i in arr) {\n      reduced = reduceFunc(reduced, arr[i], i, arr);\n    }\n  }\n\n  return reduced;\n};\n\nfunction identity(x) {\n  return x;\n}\n\nexport default when;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/ThirdParty/when.js"],"names":["reduceArray","slice","undef","when","defer","resolve","reject","join","all","map","reduce","any","some","chain","isPromise","promiseOrValue","onFulfilled","onRejected","onProgress","then","promise","deferred","Promise","value","reason","update","progress","fulfilled","rejected","prototype","always","onFulfilledOrRejected","otherwise","yield","spread","array","apply","p","e","_","handlers","progressHandlers","_then","_progress","_resolve","promiseResolve","promiseReject","promiseProgress","resolver","progressHandler","push","processQueue","noop","val","err","promisesOrValues","howMany","checkCallbacks","arguments","toResolve","toReject","values","reasons","fulfillOne","rejectOne","len","i","length","Math","max","min","fulfiller","rejecter","unwrapSingleResult","identity","mapFunc","results","d","resolveOne","item","mapped","reduceFunc","args","call","total","current","c","resolveValue","useResolveValue","queue","handler","start","arrayOfCallbacks","arg","Error","arr","reduced","Object","TypeError","x"],"mappings":"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","sourcesContent":["/**\n  @license\n  when.js - https://github.com/cujojs/when\n\n  MIT License (c) copyright B Cavalier & J Hann\n\n * A lightweight CommonJS Promises/A and when() implementation\n * when is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @version 1.7.1\n */\n\n\tvar reduceArray, slice, undef;\n\n\t//\n\t// Public API\n\t//\n\n\twhen.defer     = defer;     // Create a deferred\n\twhen.resolve   = resolve;   // Create a resolved promise\n\twhen.reject    = reject;    // Create a rejected promise\n\n\twhen.join      = join;      // Join 2 or more promises\n\n\twhen.all       = all;       // Resolve a list of promises\n\twhen.map       = map;       // Array.map() for promises\n\twhen.reduce    = reduce;    // Array.reduce() for promises\n\n\twhen.any       = any;       // One-winner race\n\twhen.some      = some;      // Multi-winner race\n\n\twhen.chain     = chain;     // Make a promise trigger another resolver\n\n\twhen.isPromise = isPromise; // Determine if a thing is a promise\n\n\t/**\n\t * Register an observer for a promise or immediate value.\n\t *\n\t * @param {*} promiseOrValue\n\t * @param {function?} [onFulfilled] callback to be called when promiseOrValue is\n\t *   successfully fulfilled.  If promiseOrValue is an immediate value, callback\n\t *   will be invoked immediately.\n\t * @param {function?} [onRejected] callback to be called when promiseOrValue is\n\t *   rejected.\n\t * @param {function?} [onProgress] callback to be called when progress updates\n\t *   are issued for promiseOrValue.\n\t * @returns {Promise} a new {@link Promise} that will complete with the return\n\t *   value of callback or errback or the completion value of promiseOrValue if\n\t *   callback and/or errback is not supplied.\n\t */\n\tfunction when(promiseOrValue, onFulfilled, onRejected, onProgress) {\n\t\t// Get a trusted promise for the input promiseOrValue, and then\n\t\t// register promise handlers\n\t\treturn resolve(promiseOrValue).then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Returns promiseOrValue if promiseOrValue is a {@link Promise}, a new Promise if\n\t * promiseOrValue is a foreign promise, or a new, already-fulfilled {@link Promise}\n\t * whose value is promiseOrValue if promiseOrValue is an immediate value.\n\t *\n\t * @param {*} promiseOrValue\n\t * @returns Guaranteed to return a trusted Promise.  If promiseOrValue is a when.js {@link Promise}\n\t *   returns promiseOrValue, otherwise, returns a new, already-resolved, when.js {@link Promise}\n\t *   whose resolution value is:\n\t *   * the resolution value of promiseOrValue if it's a foreign promise, or\n\t *   * promiseOrValue if it's a value\n\t */\n\tfunction resolve(promiseOrValue) {\n\t\tvar promise, deferred;\n\n\t\tif(promiseOrValue instanceof Promise) {\n\t\t\t// It's a when.js promise, so we trust it\n\t\t\tpromise = promiseOrValue;\n\n\t\t} else {\n\t\t\t// It's not a when.js promise. See if it's a foreign promise or a value.\n\t\t\tif(isPromise(promiseOrValue)) {\n\t\t\t\t// It's a thenable, but we don't know where it came from, so don't trust\n\t\t\t\t// its implementation entirely.  Introduce a trusted middleman when.js promise\n\t\t\t\tdeferred = defer();\n\n\t\t\t\t// IMPORTANT: This is the only place when.js should ever call .then() on an\n\t\t\t\t// untrusted promise. Don't expose the return value to the untrusted promise\n\t\t\t\tpromiseOrValue.then(\n\t\t\t\t\tfunction(value)  { deferred.resolve(value); },\n\t\t\t\t\tfunction(reason) { deferred.reject(reason); },\n\t\t\t\t\tfunction(update) { deferred.progress(update); }\n\t\t\t\t);\n\n\t\t\t\tpromise = deferred.promise;\n\n\t\t\t} else {\n\t\t\t\t// It's a value, not a promise.  Create a resolved promise for it.\n\t\t\t\tpromise = fulfilled(promiseOrValue);\n\t\t\t}\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\t/**\n\t * Returns a rejected promise for the supplied promiseOrValue.  The returned\n\t * promise will be rejected with:\n\t * - promiseOrValue, if it is a value, or\n\t * - if promiseOrValue is a promise\n\t *   - promiseOrValue's value after it is fulfilled\n\t *   - promiseOrValue's reason after it is rejected\n\t * @param {*} promiseOrValue the rejected value of the returned {@link Promise}\n\t * @returns {Promise} rejected {@link Promise}\n\t */\n\tfunction reject(promiseOrValue) {\n\t\treturn when(promiseOrValue, rejected);\n\t}\n\n\t/**\n\t * Trusted Promise constructor.  A Promise created from this constructor is\n\t * a trusted when.js promise.  Any other duck-typed promise is considered\n\t * untrusted.\n\t * @constructor\n\t * @name Promise\n\t */\n\tfunction Promise(then) {\n\t\tthis.then = then;\n\t}\n\n\tPromise.prototype = {\n\t\t/**\n\t\t * Register a callback that will be called when a promise is\n\t\t * fulfilled or rejected.  Optionally also register a progress handler.\n\t\t * Shortcut for .then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress)\n\t\t * @param {function?} [onFulfilledOrRejected]\n\t\t * @param {function?} [onProgress]\n\t\t * @returns {Promise}\n\t\t */\n\t\talways: function(onFulfilledOrRejected, onProgress) {\n\t\t\treturn this.then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress);\n\t\t},\n\n\t\t/**\n\t\t * Register a rejection handler.  Shortcut for .then(undefined, onRejected)\n\t\t * @param {function?} onRejected\n\t\t * @returns {Promise}\n\t\t */\n\t\totherwise: function(onRejected) {\n\t\t\treturn this.then(undef, onRejected);\n\t\t},\n\n\t\t/**\n\t\t * Shortcut for .then(function() { return value; })\n\t\t * @param  {*} value\n\t\t * @returns {Promise} a promise that:\n\t\t *  - is fulfilled if value is not a promise, or\n\t\t *  - if value is a promise, will fulfill with its value, or reject\n\t\t *    with its reason.\n\t\t */\n\t\tyield: function(value) {\n\t\t\treturn this.then(function() {\n\t\t\t\treturn value;\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Assumes that this promise will fulfill with an array, and arranges\n\t\t * for the onFulfilled to be called with the array as its argument list\n\t\t * i.e. onFulfilled.spread(undefined, array).\n\t\t * @param {function} onFulfilled function to receive spread arguments\n\t\t * @returns {Promise}\n\t\t */\n\t\tspread: function(onFulfilled) {\n\t\t\treturn this.then(function(array) {\n\t\t\t\t// array may contain promises, so resolve its contents.\n\t\t\t\treturn all(array, function(array) {\n\t\t\t\t\treturn onFulfilled.apply(undef, array);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n\t * Create an already-resolved promise for the supplied value\n\t * @private\n\t *\n\t * @param {*} value\n\t * @returns {Promise} fulfilled promise\n\t */\n\tfunction fulfilled(value) {\n\t\tvar p = new Promise(function(onFulfilled) {\n\t\t\t// TODO: Promises/A+ check typeof onFulfilled\n\t\t\ttry {\n\t\t\t\treturn resolve(onFulfilled ? onFulfilled(value) : value);\n\t\t\t} catch(e) {\n\t\t\t\treturn rejected(e);\n\t\t\t}\n\t\t});\n\n\t\treturn p;\n\t}\n\n\t/**\n\t * Create an already-rejected {@link Promise} with the supplied\n\t * rejection reason.\n\t * @private\n\t *\n\t * @param {*} reason\n\t * @returns {Promise} rejected promise\n\t */\n\tfunction rejected(reason) {\n\t\tvar p = new Promise(function(_, onRejected) {\n\t\t\t// TODO: Promises/A+ check typeof onRejected\n\t\t\ttry {\n\t\t\t\treturn onRejected ? resolve(onRejected(reason)) : rejected(reason);\n\t\t\t} catch(e) {\n\t\t\t\treturn rejected(e);\n\t\t\t}\n\t\t});\n\n\t\treturn p;\n\t}\n\n\t/**\n\t * Creates a new, Deferred with fully isolated resolver and promise parts,\n\t * either or both of which may be given out safely to consumers.\n\t * The Deferred itself has the full API: resolve, reject, progress, and\n\t * then. The resolver has resolve, reject, and progress.  The promise\n\t * only has then.\n\t *\n\t * @returns {Deferred}\n\t */\n\tfunction defer() {\n\t\tvar deferred, promise, handlers, progressHandlers,\n\t\t\t_then, _progress, _resolve;\n\n\t\t/**\n\t\t * The promise for the new deferred\n\t\t * @type {Promise}\n\t\t */\n\t\tpromise = new Promise(then);\n\n\t\t/**\n\t\t * The full Deferred object, with {@link Promise} and {@link Resolver} parts\n\t\t * @class Deferred\n\t\t * @name Deferred\n\t\t */\n\t\tdeferred = {\n\t\t\tthen:     then, // DEPRECATED: use deferred.promise.then\n\t\t\tresolve:  promiseResolve,\n\t\t\treject:   promiseReject,\n\t\t\t// TODO: Consider renaming progress() to notify()\n\t\t\tprogress: promiseProgress,\n\n\t\t\tpromise:  promise,\n\n\t\t\tresolver: {\n\t\t\t\tresolve:  promiseResolve,\n\t\t\t\treject:   promiseReject,\n\t\t\t\tprogress: promiseProgress\n\t\t\t}\n\t\t};\n\n\t\thandlers = [];\n\t\tprogressHandlers = [];\n\n\t\t/**\n\t\t * Pre-resolution then() that adds the supplied callback, errback, and progback\n\t\t * functions to the registered listeners\n\t\t * @private\n\t\t *\n\t\t * @param {function?} [onFulfilled] resolution handler\n\t\t * @param {function?} [onRejected] rejection handler\n\t\t * @param {function?} [onProgress] progress handler\n\t\t */\n\t\t_then = function(onFulfilled, onRejected, onProgress) {\n\t\t\t// TODO: Promises/A+ check typeof onFulfilled, onRejected, onProgress\n\t\t\tvar deferred, progressHandler;\n\n\t\t\tdeferred = defer();\n\n\t\t\tprogressHandler = typeof onProgress === 'function'\n\t\t\t\t? function(update) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Allow progress handler to transform progress event\n\t\t\t\t\t\tdeferred.progress(onProgress(update));\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t// Use caught value as progress\n\t\t\t\t\t\tdeferred.progress(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t: function(update) { deferred.progress(update); };\n\n\t\t\thandlers.push(function(promise) {\n\t\t\t\tpromise.then(onFulfilled, onRejected)\n\t\t\t\t\t.then(deferred.resolve, deferred.reject, progressHandler);\n\t\t\t});\n\n\t\t\tprogressHandlers.push(progressHandler);\n\n\t\t\treturn deferred.promise;\n\t\t};\n\n\t\t/**\n\t\t * Issue a progress event, notifying all progress listeners\n\t\t * @private\n\t\t * @param {*} update progress event payload to pass to all listeners\n\t\t */\n\t\t_progress = function(update) {\n\t\t\tprocessQueue(progressHandlers, update);\n\t\t\treturn update;\n\t\t};\n\n\t\t/**\n\t\t * Transition from pre-resolution state to post-resolution state, notifying\n\t\t * all listeners of the resolution or rejection\n\t\t * @private\n\t\t * @param {*} value the value of this deferred\n\t\t */\n\t\t_resolve = function(value) {\n\t\t\tvalue = resolve(value);\n\n\t\t\t// Replace _then with one that directly notifies with the result.\n\t\t\t_then = value.then;\n\t\t\t// Replace _resolve so that this Deferred can only be resolved once\n\t\t\t_resolve = resolve;\n\t\t\t// Make _progress a noop, to disallow progress for the resolved promise.\n\t\t\t_progress = noop;\n\n\t\t\t// Notify handlers\n\t\t\tprocessQueue(handlers, value);\n\n\t\t\t// Free progressHandlers array since we'll never issue progress events\n\t\t\tprogressHandlers = handlers = undef;\n\n\t\t\treturn value;\n\t\t};\n\n\t\treturn deferred;\n\n\t\t/**\n\t\t * Wrapper to allow _then to be replaced safely\n\t\t * @param {function?} [onFulfilled] resolution handler\n\t\t * @param {function?} [onRejected] rejection handler\n\t\t * @param {function?} [onProgress] progress handler\n\t\t * @returns {Promise} new promise\n\t\t */\n\t\tfunction then(onFulfilled, onRejected, onProgress) {\n\t\t\t// TODO: Promises/A+ check typeof onFulfilled, onRejected, onProgress\n\t\t\treturn _then(onFulfilled, onRejected, onProgress);\n\t\t}\n\n\t\t/**\n\t\t * Wrapper to allow _resolve to be replaced\n\t\t */\n\t\tfunction promiseResolve(val) {\n\t\t\treturn _resolve(val);\n\t\t}\n\n\t\t/**\n\t\t * Wrapper to allow _reject to be replaced\n\t\t */\n\t\tfunction promiseReject(err) {\n\t\t\treturn _resolve(rejected(err));\n\t\t}\n\n\t\t/**\n\t\t * Wrapper to allow _progress to be replaced\n\t\t */\n\t\tfunction promiseProgress(update) {\n\t\t\treturn _progress(update);\n\t\t}\n\t}\n\n\t/**\n\t * Determines if promiseOrValue is a promise or not.  Uses the feature\n\t * test from http://wiki.commonjs.org/wiki/Promises/A to determine if\n\t * promiseOrValue is a promise.\n\t *\n\t * @param {*} promiseOrValue anything\n\t * @returns {boolean} true if promiseOrValue is a {@link Promise}\n\t */\n\tfunction isPromise(promiseOrValue) {\n\t\treturn promiseOrValue && typeof promiseOrValue.then === 'function';\n\t}\n\n\t/**\n\t * Initiates a competitive race, returning a promise that will resolve when\n\t * howMany of the supplied promisesOrValues have resolved, or will reject when\n\t * it becomes impossible for howMany to resolve, for example, when\n\t * (promisesOrValues.length - howMany) + 1 input promises reject.\n\t *\n\t * @param {Array} promisesOrValues array of anything, may contain a mix\n\t *      of promises and values\n\t * @param howMany {number} number of promisesOrValues to resolve\n\t * @param {function?} [onFulfilled] resolution handler\n\t * @param {function?} [onRejected] rejection handler\n\t * @param {function?} [onProgress] progress handler\n\t * @returns {Promise} promise that will resolve to an array of howMany values that\n\t * resolved first, or will reject with an array of (promisesOrValues.length - howMany) + 1\n\t * rejection reasons.\n\t */\n\tfunction some(promisesOrValues, howMany, onFulfilled, onRejected, onProgress) {\n\n\t\tcheckCallbacks(2, arguments);\n\n\t\treturn when(promisesOrValues, function(promisesOrValues) {\n\n\t\t\tvar toResolve, toReject, values, reasons, deferred, fulfillOne, rejectOne, progress, len, i;\n\n\t\t\tlen = promisesOrValues.length >>> 0;\n\n\t\t\ttoResolve = Math.max(0, Math.min(howMany, len));\n\t\t\tvalues = [];\n\n\t\t\ttoReject = (len - toResolve) + 1;\n\t\t\treasons = [];\n\n\t\t\tdeferred = defer();\n\n\t\t\t// No items in the input, resolve immediately\n\t\t\tif (!toResolve) {\n\t\t\t\tdeferred.resolve(values);\n\n\t\t\t} else {\n\t\t\t\tprogress = deferred.progress;\n\n\t\t\t\trejectOne = function(reason) {\n\t\t\t\t\treasons.push(reason);\n\t\t\t\t\tif(!--toReject) {\n\t\t\t\t\t\tfulfillOne = rejectOne = noop;\n\t\t\t\t\t\tdeferred.reject(reasons);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tfulfillOne = function(val) {\n\t\t\t\t\t// This orders the values based on promise resolution order\n\t\t\t\t\t// Another strategy would be to use the original position of\n\t\t\t\t\t// the corresponding promise.\n\t\t\t\t\tvalues.push(val);\n\n\t\t\t\t\tif (!--toResolve) {\n\t\t\t\t\t\tfulfillOne = rejectOne = noop;\n\t\t\t\t\t\tdeferred.resolve(values);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tfor(i = 0; i < len; ++i) {\n\t\t\t\t\tif(i in promisesOrValues) {\n\t\t\t\t\t\twhen(promisesOrValues[i], fulfiller, rejecter, progress);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn deferred.then(onFulfilled, onRejected, onProgress);\n\n\t\t\tfunction rejecter(reason) {\n\t\t\t\trejectOne(reason);\n\t\t\t}\n\n\t\t\tfunction fulfiller(val) {\n\t\t\t\tfulfillOne(val);\n\t\t\t}\n\n\t\t});\n\t}\n\n\t/**\n\t * Initiates a competitive race, returning a promise that will resolve when\n\t * any one of the supplied promisesOrValues has resolved or will reject when\n\t * *all* promisesOrValues have rejected.\n\t *\n\t * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function?} [onFulfilled] resolution handler\n\t * @param {function?} [onRejected] rejection handler\n\t * @param {function?} [onProgress] progress handler\n\t * @returns {Promise} promise that will resolve to the value that resolved first, or\n\t * will reject with an array of all rejected inputs.\n\t */\n\tfunction any(promisesOrValues, onFulfilled, onRejected, onProgress) {\n\n\t\tfunction unwrapSingleResult(val) {\n\t\t\treturn onFulfilled ? onFulfilled(val[0]) : val[0];\n\t\t}\n\n\t\treturn some(promisesOrValues, 1, unwrapSingleResult, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Return a promise that will resolve only once all the supplied promisesOrValues\n\t * have resolved. The resolution value of the returned promise will be an array\n\t * containing the resolution values of each of the promisesOrValues.\n\t * @memberOf when\n\t *\n\t * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function?} [onFulfilled] resolution handler\n\t * @param {function?} [onRejected] rejection handler\n\t * @param {function?} [onProgress] progress handler\n\t * @returns {Promise}\n\t */\n\tfunction all(promisesOrValues, onFulfilled, onRejected, onProgress) {\n\t\tcheckCallbacks(1, arguments);\n\t\treturn map(promisesOrValues, identity).then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Joins multiple promises into a single returned promise.\n\t * @returns {Promise} a promise that will fulfill when *all* the input promises\n\t * have fulfilled, or will reject when *any one* of the input promises rejects.\n\t */\n\tfunction join(/* ...promises */) {\n\t\treturn map(arguments, identity);\n\t}\n\n\t/**\n\t * Traditional map function, similar to `Array.prototype.map()`, but allows\n\t * input to contain {@link Promise}s and/or values, and mapFunc may return\n\t * either a value or a {@link Promise}\n\t *\n\t * @param {Array|Promise} promise array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function} mapFunc mapping function mapFunc(value) which may return\n\t *      either a {@link Promise} or value\n\t * @returns {Promise} a {@link Promise} that will resolve to an array containing\n\t *      the mapped output values.\n\t */\n\tfunction map(promise, mapFunc) {\n\t\treturn when(promise, function(array) {\n\t\t\tvar results, len, toResolve, resolve, i, d;\n\n\t\t\t// Since we know the resulting length, we can preallocate the results\n\t\t\t// array to avoid array expansions.\n\t\t\ttoResolve = len = array.length >>> 0;\n\t\t\tresults = [];\n\t\t\td = defer();\n\n\t\t\tif(!toResolve) {\n\t\t\t\td.resolve(results);\n\t\t\t} else {\n\n\t\t\t\tresolve = function resolveOne(item, i) {\n\t\t\t\t\twhen(item, mapFunc).then(function(mapped) {\n\t\t\t\t\t\tresults[i] = mapped;\n\n\t\t\t\t\t\tif(!--toResolve) {\n\t\t\t\t\t\t\td.resolve(results);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, d.reject);\n\t\t\t\t};\n\n\t\t\t\t// Since mapFunc may be async, get all invocations of it into flight\n\t\t\t\tfor(i = 0; i < len; i++) {\n\t\t\t\t\tif(i in array) {\n\t\t\t\t\t\tresolve(array[i], i);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t--toResolve;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn d.promise;\n\n\t\t});\n\t}\n\n\t/**\n\t * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n\t * input may contain promises and/or values, and reduceFunc\n\t * may return either a value or a promise, *and* initialValue may\n\t * be a promise for the starting value.\n\t *\n\t * @param {Array|Promise} promise array or promise for an array of anything,\n\t *      may contain a mix of promises and values.\n\t * @param {function} reduceFunc reduce function reduce(currentValue, nextValue, index, total),\n\t *      where total is the total number of items being reduced, and will be the same\n\t *      in each call to reduceFunc.\n\t * @returns {Promise} that will resolve to the final reduced value\n\t */\n\tfunction reduce(promise, reduceFunc /*, initialValue */) {\n\t\tvar args = slice.call(arguments, 1);\n\n\t\treturn when(promise, function(array) {\n\t\t\tvar total;\n\n\t\t\ttotal = array.length;\n\n\t\t\t// Wrap the supplied reduceFunc with one that handles promises and then\n\t\t\t// delegates to the supplied.\n\t\t\targs[0] = function (current, val, i) {\n\t\t\t\treturn when(current, function (c) {\n\t\t\t\t\treturn when(val, function (value) {\n\t\t\t\t\t\treturn reduceFunc(c, value, i, total);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\n\t\t\treturn reduceArray.apply(array, args);\n\t\t});\n\t}\n\n\t/**\n\t * Ensure that resolution of promiseOrValue will trigger resolver with the\n\t * value or reason of promiseOrValue, or instead with resolveValue if it is provided.\n\t *\n\t * @param promiseOrValue\n\t * @param {Object} resolver\n\t * @param {function} resolver.resolve\n\t * @param {function} resolver.reject\n\t * @param {*} [resolveValue]\n\t * @returns {Promise}\n\t */\n\tfunction chain(promiseOrValue, resolver, resolveValue) {\n\t\tvar useResolveValue = arguments.length > 2;\n\n\t\treturn when(promiseOrValue,\n\t\t\tfunction(val) {\n\t\t\t\tval = useResolveValue ? resolveValue : val;\n\t\t\t\tresolver.resolve(val);\n\t\t\t\treturn val;\n\t\t\t},\n\t\t\tfunction(reason) {\n\t\t\t\tresolver.reject(reason);\n\t\t\t\treturn rejected(reason);\n\t\t\t},\n\t\t\tresolver.progress\n\t\t);\n\t}\n\n\t//\n\t// Utility functions\n\t//\n\n\t/**\n\t * Apply all functions in queue to value\n\t * @param {Array} queue array of functions to execute\n\t * @param {*} value argument passed to each function\n\t */\n\tfunction processQueue(queue, value) {\n\t\tvar handler, i = 0;\n\n\t\twhile (handler = queue[i++]) {\n\t\t\thandler(value);\n\t\t}\n\t}\n\n\t/**\n\t * Helper that checks arrayOfCallbacks to ensure that each element is either\n\t * a function, or null or undefined.\n\t * @private\n\t * @param {number} start index at which to start checking items in arrayOfCallbacks\n\t * @param {Array} arrayOfCallbacks array to check\n\t * @throws {Error} if any element of arrayOfCallbacks is something other than\n\t * a functions, null, or undefined.\n\t */\n\tfunction checkCallbacks(start, arrayOfCallbacks) {\n\t\t// TODO: Promises/A+ update type checking and docs\n\t\tvar arg, i = arrayOfCallbacks.length;\n\n\t\twhile(i > start) {\n\t\t\targ = arrayOfCallbacks[--i];\n\n\t\t\tif (arg != null && typeof arg != 'function') {\n\t\t\t\tthrow new Error('arg '+i+' must be a function');\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * No-Op function used in method replacement\n\t * @private\n\t */\n\tfunction noop() {}\n\n\tslice = [].slice;\n\n\t// ES5 reduce implementation if native not available\n\t// See: http://es5.github.com/#x15.4.4.21 as there are many\n\t// specifics and edge cases.\n\treduceArray = [].reduce ||\n\t\tfunction(reduceFunc /*, initialValue */) {\n\t\t\t/*jshint maxcomplexity: 7*/\n\n\t\t\t// ES5 dictates that reduce.length === 1\n\n\t\t\t// This implementation deviates from ES5 spec in the following ways:\n\t\t\t// 1. It does not check if reduceFunc is a Callable\n\n\t\t\tvar arr, args, reduced, len, i;\n\n\t\t\ti = 0;\n\t\t\t// This generates a jshint warning, despite being valid\n\t\t\t// \"Missing 'new' prefix when invoking a constructor.\"\n\t\t\t// See https://github.com/jshint/jshint/issues/392\n\t\t\tarr = Object(this);\n\t\t\tlen = arr.length >>> 0;\n\t\t\targs = arguments;\n\n\t\t\t// If no initialValue, use first item of array (we know length !== 0 here)\n\t\t\t// and adjust i to start at second item\n\t\t\tif(args.length <= 1) {\n\t\t\t\t// Skip to the first real element in the array\n\t\t\t\tfor(;;) {\n\t\t\t\t\tif(i in arr) {\n\t\t\t\t\t\treduced = arr[i++];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If we reached the end of the array without finding any real\n\t\t\t\t\t// elements, it's a TypeError\n\t\t\t\t\tif(++i >= len) {\n\t\t\t\t\t\tthrow new TypeError();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If initialValue provided, use it\n\t\t\t\treduced = args[1];\n\t\t\t}\n\n\t\t\t// Do the actual reduce\n\t\t\tfor(;i < len; ++i) {\n\t\t\t\t// Skip holes\n\t\t\t\tif(i in arr) {\n\t\t\t\t\treduced = reduceFunc(reduced, arr[i], i, arr);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn reduced;\n\t\t};\n\n\tfunction identity(x) {\n\t\treturn x;\n\t}\n\nexport default when;\n"]},"metadata":{},"sourceType":"module"}