{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \" /**\\n\\\n  * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component Cartesian vector.\\n\\\n  * The 'oct' encoding is described in \\\"A Survey of Efficient Representations of Independent Unit Vectors\\\",\\n\\\n  * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/\\n\\\n  *\\n\\\n  * @name czm_octDecode\\n\\\n  * @param {vec2} encoded The oct-encoded, unit-length vector\\n\\\n  * @param {float} range The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\\n\\\n  * @returns {vec3} The decoded and normalized vector\\n\\\n  */\\n\\\n  vec3 czm_octDecode(vec2 encoded, float range)\\n\\\n  {\\n\\\n      if (encoded.x == 0.0 && encoded.y == 0.0) {\\n\\\n          return vec3(0.0, 0.0, 0.0);\\n\\\n      }\\n\\\n\\n\\\n     encoded = encoded / range * 2.0 - 1.0;\\n\\\n     vec3 v = vec3(encoded.x, encoded.y, 1.0 - abs(encoded.x) - abs(encoded.y));\\n\\\n     if (v.z < 0.0)\\n\\\n     {\\n\\\n         v.xy = (1.0 - abs(v.yx)) * czm_signNotZero(v.xy);\\n\\\n     }\\n\\\n\\n\\\n     return normalize(v);\\n\\\n  }\\n\\\n\\n\\\n/**\\n\\\n * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component Cartesian vector.\\n\\\n * The 'oct' encoding is described in \\\"A Survey of Efficient Representations of Independent Unit Vectors\\\",\\n\\\n * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/\\n\\\n *\\n\\\n * @name czm_octDecode\\n\\\n * @param {vec2} encoded The oct-encoded, unit-length vector\\n\\\n * @returns {vec3} The decoded and normalized vector\\n\\\n */\\n\\\n vec3 czm_octDecode(vec2 encoded)\\n\\\n {\\n\\\n    return czm_octDecode(encoded, 255.0);\\n\\\n }\\n\\\n\\n\\\n /**\\n\\\n * Decodes a unit-length vector in 'oct' encoding packed into a floating-point number to a normalized 3-component Cartesian vector.\\n\\\n * The 'oct' encoding is described in \\\"A Survey of Efficient Representations of Independent Unit Vectors\\\",\\n\\\n * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/\\n\\\n *\\n\\\n * @name czm_octDecode\\n\\\n * @param {float} encoded The oct-encoded, unit-length vector\\n\\\n * @returns {vec3} The decoded and normalized vector\\n\\\n */\\n\\\n vec3 czm_octDecode(float encoded)\\n\\\n {\\n\\\n    float temp = encoded / 256.0;\\n\\\n    float x = floor(temp);\\n\\\n    float y = (temp - x) * 256.0;\\n\\\n    return czm_octDecode(vec2(x, y));\\n\\\n }\\n\\\n\\n\\\n/**\\n\\\n * Decodes three unit-length vectors in 'oct' encoding packed into two floating-point numbers to normalized 3-component Cartesian vectors.\\n\\\n * The 'oct' encoding is described in \\\"A Survey of Efficient Representations of Independent Unit Vectors\\\",\\n\\\n * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/\\n\\\n *\\n\\\n * @name czm_octDecode\\n\\\n * @param {vec2} encoded The packed oct-encoded, unit-length vectors.\\n\\\n * @param {vec3} vector1 One decoded and normalized vector.\\n\\\n * @param {vec3} vector2 One decoded and normalized vector.\\n\\\n * @param {vec3} vector3 One decoded and normalized vector.\\n\\\n */\\n\\\n  void czm_octDecode(vec2 encoded, out vec3 vector1, out vec3 vector2, out vec3 vector3)\\n\\\n {\\n\\\n    float temp = encoded.x / 65536.0;\\n\\\n    float x = floor(temp);\\n\\\n    float encodedFloat1 = (temp - x) * 65536.0;\\n\\\n\\n\\\n    temp = encoded.y / 65536.0;\\n\\\n    float y = floor(temp);\\n\\\n    float encodedFloat2 = (temp - y) * 65536.0;\\n\\\n\\n\\\n    vector1 = czm_octDecode(encodedFloat1);\\n\\\n    vector2 = czm_octDecode(encodedFloat2);\\n\\\n    vector3 = czm_octDecode(vec2(x, y));\\n\\\n }\\n\\\n\\n\\\n\";","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Shaders/Builtin/Functions/octDecode.js"],"names":[],"mappings":"AAAA;AACA,eAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAAf","sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \" /**\\n\\\n  * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component Cartesian vector.\\n\\\n  * The 'oct' encoding is described in \\\"A Survey of Efficient Representations of Independent Unit Vectors\\\",\\n\\\n  * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/\\n\\\n  *\\n\\\n  * @name czm_octDecode\\n\\\n  * @param {vec2} encoded The oct-encoded, unit-length vector\\n\\\n  * @param {float} range The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\\n\\\n  * @returns {vec3} The decoded and normalized vector\\n\\\n  */\\n\\\n  vec3 czm_octDecode(vec2 encoded, float range)\\n\\\n  {\\n\\\n      if (encoded.x == 0.0 && encoded.y == 0.0) {\\n\\\n          return vec3(0.0, 0.0, 0.0);\\n\\\n      }\\n\\\n\\n\\\n     encoded = encoded / range * 2.0 - 1.0;\\n\\\n     vec3 v = vec3(encoded.x, encoded.y, 1.0 - abs(encoded.x) - abs(encoded.y));\\n\\\n     if (v.z < 0.0)\\n\\\n     {\\n\\\n         v.xy = (1.0 - abs(v.yx)) * czm_signNotZero(v.xy);\\n\\\n     }\\n\\\n\\n\\\n     return normalize(v);\\n\\\n  }\\n\\\n\\n\\\n/**\\n\\\n * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component Cartesian vector.\\n\\\n * The 'oct' encoding is described in \\\"A Survey of Efficient Representations of Independent Unit Vectors\\\",\\n\\\n * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/\\n\\\n *\\n\\\n * @name czm_octDecode\\n\\\n * @param {vec2} encoded The oct-encoded, unit-length vector\\n\\\n * @returns {vec3} The decoded and normalized vector\\n\\\n */\\n\\\n vec3 czm_octDecode(vec2 encoded)\\n\\\n {\\n\\\n    return czm_octDecode(encoded, 255.0);\\n\\\n }\\n\\\n\\n\\\n /**\\n\\\n * Decodes a unit-length vector in 'oct' encoding packed into a floating-point number to a normalized 3-component Cartesian vector.\\n\\\n * The 'oct' encoding is described in \\\"A Survey of Efficient Representations of Independent Unit Vectors\\\",\\n\\\n * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/\\n\\\n *\\n\\\n * @name czm_octDecode\\n\\\n * @param {float} encoded The oct-encoded, unit-length vector\\n\\\n * @returns {vec3} The decoded and normalized vector\\n\\\n */\\n\\\n vec3 czm_octDecode(float encoded)\\n\\\n {\\n\\\n    float temp = encoded / 256.0;\\n\\\n    float x = floor(temp);\\n\\\n    float y = (temp - x) * 256.0;\\n\\\n    return czm_octDecode(vec2(x, y));\\n\\\n }\\n\\\n\\n\\\n/**\\n\\\n * Decodes three unit-length vectors in 'oct' encoding packed into two floating-point numbers to normalized 3-component Cartesian vectors.\\n\\\n * The 'oct' encoding is described in \\\"A Survey of Efficient Representations of Independent Unit Vectors\\\",\\n\\\n * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/\\n\\\n *\\n\\\n * @name czm_octDecode\\n\\\n * @param {vec2} encoded The packed oct-encoded, unit-length vectors.\\n\\\n * @param {vec3} vector1 One decoded and normalized vector.\\n\\\n * @param {vec3} vector2 One decoded and normalized vector.\\n\\\n * @param {vec3} vector3 One decoded and normalized vector.\\n\\\n */\\n\\\n  void czm_octDecode(vec2 encoded, out vec3 vector1, out vec3 vector2, out vec3 vector3)\\n\\\n {\\n\\\n    float temp = encoded.x / 65536.0;\\n\\\n    float x = floor(temp);\\n\\\n    float encodedFloat1 = (temp - x) * 65536.0;\\n\\\n\\n\\\n    temp = encoded.y / 65536.0;\\n\\\n    float y = floor(temp);\\n\\\n    float encodedFloat2 = (temp - y) * 65536.0;\\n\\\n\\n\\\n    vector1 = czm_octDecode(encodedFloat1);\\n\\\n    vector2 = czm_octDecode(encodedFloat2);\\n\\\n    vector3 = czm_octDecode(vec2(x, y));\\n\\\n }\\n\\\n\\n\\\n\";\n"]},"metadata":{},"sourceType":"module"}