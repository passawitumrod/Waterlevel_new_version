{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport LinearSpline from \"../Core/LinearSpline.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport QuaternionSpline from \"../Core/QuaternionSpline.js\";\nimport Spline from \"../Core/Spline.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport WeightSpline from \"../Core/WeightSpline.js\";\nimport getAccessorByteStride from \"../ThirdParty/GltfPipeline/getAccessorByteStride.js\";\nimport numberOfComponentsForType from \"../ThirdParty/GltfPipeline/numberOfComponentsForType.js\";\nimport AttributeType from \"./AttributeType.js\";\n/**\n * @private\n */\n\nfunction ModelAnimationCache() {}\n\nvar dataUriRegex = /^data\\:/i;\n\nfunction getAccessorKey(model, accessor) {\n  var gltf = model.gltf;\n  var buffers = gltf.buffers;\n  var bufferViews = gltf.bufferViews;\n  var bufferView = bufferViews[accessor.bufferView];\n  var buffer = buffers[bufferView.buffer];\n  var byteOffset = bufferView.byteOffset + accessor.byteOffset;\n  var byteLength = accessor.count * numberOfComponentsForType(accessor.type);\n  var uriKey = dataUriRegex.test(buffer.uri) ? \"\" : buffer.uri;\n  return model.cacheKey + \"//\" + uriKey + \"/\" + byteOffset + \"/\" + byteLength;\n}\n\nvar cachedAnimationParameters = {};\n\nModelAnimationCache.getAnimationParameterValues = function (model, accessor) {\n  var key = getAccessorKey(model, accessor);\n  var values = cachedAnimationParameters[key];\n\n  if (!defined(values)) {\n    // Cache miss\n    var gltf = model.gltf;\n    var buffers = gltf.buffers;\n    var bufferViews = gltf.bufferViews;\n    var bufferView = bufferViews[accessor.bufferView];\n    var bufferId = bufferView.buffer;\n    var buffer = buffers[bufferId];\n    var source = buffer.extras._pipeline.source;\n    var componentType = accessor.componentType;\n    var type = accessor.type;\n    var numberOfComponents = numberOfComponentsForType(type);\n    var count = accessor.count;\n    var byteStride = getAccessorByteStride(gltf, accessor);\n    values = new Array(count);\n    var accessorByteOffset = defaultValue(accessor.byteOffset, 0);\n    var byteOffset = bufferView.byteOffset + accessorByteOffset;\n\n    for (var i = 0; i < count; i++) {\n      var typedArrayView = ComponentDatatype.createArrayBufferView(componentType, source.buffer, source.byteOffset + byteOffset, numberOfComponents);\n\n      if (type === \"SCALAR\") {\n        values[i] = typedArrayView[0];\n      } else if (type === \"VEC3\") {\n        values[i] = Cartesian3.fromArray(typedArrayView);\n      } else if (type === \"VEC4\") {\n        values[i] = Quaternion.unpack(typedArrayView);\n      }\n\n      byteOffset += byteStride;\n    } // GLTF_SPEC: Support more parameter types when glTF supports targeting materials. https://github.com/KhronosGroup/glTF/issues/142\n\n\n    if (defined(model.cacheKey)) {\n      // Only cache when we can create a unique id\n      cachedAnimationParameters[key] = values;\n    }\n  }\n\n  return values;\n};\n\nvar cachedAnimationSplines = {};\n\nfunction getAnimationSplineKey(model, animationName, samplerName) {\n  return model.cacheKey + \"//\" + animationName + \"/\" + samplerName;\n}\n\nfunction ConstantSpline(value) {\n  this._value = value;\n}\n\nConstantSpline.prototype.evaluate = function (time, result) {\n  return this._value;\n};\n\nConstantSpline.prototype.wrapTime = function (time) {\n  return 0.0;\n};\n\nConstantSpline.prototype.clampTime = function (time) {\n  return 0.0;\n};\n\nfunction SteppedSpline(backingSpline) {\n  this._spline = backingSpline;\n  this._lastTimeIndex = 0;\n}\n\nSteppedSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n\nSteppedSpline.prototype.evaluate = function (time, result) {\n  var i = this._lastTimeIndex = this.findTimeInterval(time, this._lastTimeIndex);\n  var times = this._spline.times;\n  var steppedTime = time >= times[i + 1] ? times[i + 1] : times[i];\n  return this._spline.evaluate(steppedTime, result);\n};\n\nObject.defineProperties(SteppedSpline.prototype, {\n  times: {\n    get: function () {\n      return this._spline.times;\n    }\n  }\n});\n\nSteppedSpline.prototype.wrapTime = function (time) {\n  return this._spline.wrapTime(time);\n};\n\nSteppedSpline.prototype.clampTime = function (time) {\n  return this._spline.clampTime(time);\n};\n\nModelAnimationCache.getAnimationSpline = function (model, animationName, animation, samplerName, sampler, input, path, output) {\n  var key = getAnimationSplineKey(model, animationName, samplerName);\n  var spline = cachedAnimationSplines[key];\n\n  if (!defined(spline)) {\n    var times = input;\n    var controlPoints = output;\n\n    if (times.length === 1 && controlPoints.length === 1) {\n      spline = new ConstantSpline(controlPoints[0]);\n    } else if (sampler.interpolation === \"LINEAR\" || sampler.interpolation === \"STEP\") {\n      if (path === \"translation\" || path === \"scale\") {\n        spline = new LinearSpline({\n          times: times,\n          points: controlPoints\n        });\n      } else if (path === \"rotation\") {\n        spline = new QuaternionSpline({\n          times: times,\n          points: controlPoints\n        });\n      } else if (path === \"weights\") {\n        spline = new WeightSpline({\n          times: times,\n          weights: controlPoints\n        });\n      }\n\n      if (defined(spline) && sampler.interpolation === \"STEP\") {\n        spline = new SteppedSpline(spline);\n      }\n    }\n\n    if (defined(model.cacheKey)) {\n      // Only cache when we can create a unique id\n      cachedAnimationSplines[key] = spline;\n    }\n  }\n\n  return spline;\n};\n\nvar cachedSkinInverseBindMatrices = {};\n\nModelAnimationCache.getSkinInverseBindMatrices = function (model, accessor) {\n  var key = getAccessorKey(model, accessor);\n  var matrices = cachedSkinInverseBindMatrices[key];\n\n  if (!defined(matrices)) {\n    // Cache miss\n    var gltf = model.gltf;\n    var buffers = gltf.buffers;\n    var bufferViews = gltf.bufferViews;\n    var bufferViewId = accessor.bufferView;\n    var bufferView = bufferViews[bufferViewId];\n    var bufferId = bufferView.buffer;\n    var buffer = buffers[bufferId];\n    var source = buffer.extras._pipeline.source;\n    var componentType = accessor.componentType;\n    var type = accessor.type;\n    var count = accessor.count;\n    var byteStride = getAccessorByteStride(gltf, accessor);\n    var byteOffset = bufferView.byteOffset + accessor.byteOffset;\n    var numberOfComponents = numberOfComponentsForType(type);\n    matrices = new Array(count);\n\n    if (componentType === WebGLConstants.FLOAT && type === AttributeType.MAT4) {\n      for (var i = 0; i < count; ++i) {\n        var typedArrayView = ComponentDatatype.createArrayBufferView(componentType, source.buffer, source.byteOffset + byteOffset, numberOfComponents);\n        matrices[i] = Matrix4.fromArray(typedArrayView);\n        byteOffset += byteStride;\n      }\n    }\n\n    cachedSkinInverseBindMatrices[key] = matrices;\n  }\n\n  return matrices;\n};\n\nexport default ModelAnimationCache;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/ModelAnimationCache.js"],"names":["Cartesian3","ComponentDatatype","defaultValue","defined","LinearSpline","Matrix4","Quaternion","QuaternionSpline","Spline","WebGLConstants","WeightSpline","getAccessorByteStride","numberOfComponentsForType","AttributeType","ModelAnimationCache","dataUriRegex","getAccessorKey","model","accessor","gltf","buffers","bufferViews","bufferView","buffer","byteOffset","byteLength","count","type","uriKey","test","uri","cacheKey","cachedAnimationParameters","getAnimationParameterValues","key","values","bufferId","source","extras","_pipeline","componentType","numberOfComponents","byteStride","Array","accessorByteOffset","i","typedArrayView","createArrayBufferView","fromArray","unpack","cachedAnimationSplines","getAnimationSplineKey","animationName","samplerName","ConstantSpline","value","_value","prototype","evaluate","time","result","wrapTime","clampTime","SteppedSpline","backingSpline","_spline","_lastTimeIndex","findTimeInterval","times","steppedTime","Object","defineProperties","get","getAnimationSpline","animation","sampler","input","path","output","spline","controlPoints","length","interpolation","points","weights","cachedSkinInverseBindMatrices","getSkinInverseBindMatrices","matrices","bufferViewId","FLOAT","MAT4"],"mappings":"AAAA,OAAOA,UAAP,MAAuB,uBAAvB;AACA,OAAOC,iBAAP,MAA8B,8BAA9B;AACA,OAAOC,YAAP,MAAyB,yBAAzB;AACA,OAAOC,OAAP,MAAoB,oBAApB;AACA,OAAOC,YAAP,MAAyB,yBAAzB;AACA,OAAOC,OAAP,MAAoB,oBAApB;AACA,OAAOC,UAAP,MAAuB,uBAAvB;AACA,OAAOC,gBAAP,MAA6B,6BAA7B;AACA,OAAOC,MAAP,MAAmB,mBAAnB;AACA,OAAOC,cAAP,MAA2B,2BAA3B;AACA,OAAOC,YAAP,MAAyB,yBAAzB;AACA,OAAOC,qBAAP,MAAkC,qDAAlC;AACA,OAAOC,yBAAP,MAAsC,yDAAtC;AACA,OAAOC,aAAP,MAA0B,oBAA1B;AAEA;;;;AAGA,SAASC,mBAAT,GAA+B,CAAE;;AAEjC,IAAIC,YAAY,GAAG,UAAnB;;AAEA,SAASC,cAAT,CAAwBC,KAAxB,EAA+BC,QAA/B,EAAyC;AACvC,MAAIC,IAAI,GAAGF,KAAK,CAACE,IAAjB;AACA,MAAIC,OAAO,GAAGD,IAAI,CAACC,OAAnB;AACA,MAAIC,WAAW,GAAGF,IAAI,CAACE,WAAvB;AAEA,MAAIC,UAAU,GAAGD,WAAW,CAACH,QAAQ,CAACI,UAAV,CAA5B;AACA,MAAIC,MAAM,GAAGH,OAAO,CAACE,UAAU,CAACC,MAAZ,CAApB;AAEA,MAAIC,UAAU,GAAGF,UAAU,CAACE,UAAX,GAAwBN,QAAQ,CAACM,UAAlD;AACA,MAAIC,UAAU,GAAGP,QAAQ,CAACQ,KAAT,GAAiBd,yBAAyB,CAACM,QAAQ,CAACS,IAAV,CAA3D;AAEA,MAAIC,MAAM,GAAGb,YAAY,CAACc,IAAb,CAAkBN,MAAM,CAACO,GAAzB,IAAgC,EAAhC,GAAqCP,MAAM,CAACO,GAAzD;AACA,SAAOb,KAAK,CAACc,QAAN,GAAiB,IAAjB,GAAwBH,MAAxB,GAAiC,GAAjC,GAAuCJ,UAAvC,GAAoD,GAApD,GAA0DC,UAAjE;AACD;;AAED,IAAIO,yBAAyB,GAAG,EAAhC;;AAEAlB,mBAAmB,CAACmB,2BAApB,GAAkD,UAAUhB,KAAV,EAAiBC,QAAjB,EAA2B;AAC3E,MAAIgB,GAAG,GAAGlB,cAAc,CAACC,KAAD,EAAQC,QAAR,CAAxB;AACA,MAAIiB,MAAM,GAAGH,yBAAyB,CAACE,GAAD,CAAtC;;AAEA,MAAI,CAAC/B,OAAO,CAACgC,MAAD,CAAZ,EAAsB;AACpB;AACA,QAAIhB,IAAI,GAAGF,KAAK,CAACE,IAAjB;AAEA,QAAIC,OAAO,GAAGD,IAAI,CAACC,OAAnB;AACA,QAAIC,WAAW,GAAGF,IAAI,CAACE,WAAvB;AAEA,QAAIC,UAAU,GAAGD,WAAW,CAACH,QAAQ,CAACI,UAAV,CAA5B;AACA,QAAIc,QAAQ,GAAGd,UAAU,CAACC,MAA1B;AACA,QAAIA,MAAM,GAAGH,OAAO,CAACgB,QAAD,CAApB;AACA,QAAIC,MAAM,GAAGd,MAAM,CAACe,MAAP,CAAcC,SAAd,CAAwBF,MAArC;AAEA,QAAIG,aAAa,GAAGtB,QAAQ,CAACsB,aAA7B;AACA,QAAIb,IAAI,GAAGT,QAAQ,CAACS,IAApB;AACA,QAAIc,kBAAkB,GAAG7B,yBAAyB,CAACe,IAAD,CAAlD;AACA,QAAID,KAAK,GAAGR,QAAQ,CAACQ,KAArB;AACA,QAAIgB,UAAU,GAAG/B,qBAAqB,CAACQ,IAAD,EAAOD,QAAP,CAAtC;AAEAiB,IAAAA,MAAM,GAAG,IAAIQ,KAAJ,CAAUjB,KAAV,CAAT;AACA,QAAIkB,kBAAkB,GAAG1C,YAAY,CAACgB,QAAQ,CAACM,UAAV,EAAsB,CAAtB,CAArC;AACA,QAAIA,UAAU,GAAGF,UAAU,CAACE,UAAX,GAAwBoB,kBAAzC;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnB,KAApB,EAA2BmB,CAAC,EAA5B,EAAgC;AAC9B,UAAIC,cAAc,GAAG7C,iBAAiB,CAAC8C,qBAAlB,CACnBP,aADmB,EAEnBH,MAAM,CAACd,MAFY,EAGnBc,MAAM,CAACb,UAAP,GAAoBA,UAHD,EAInBiB,kBAJmB,CAArB;;AAMA,UAAId,IAAI,KAAK,QAAb,EAAuB;AACrBQ,QAAAA,MAAM,CAACU,CAAD,CAAN,GAAYC,cAAc,CAAC,CAAD,CAA1B;AACD,OAFD,MAEO,IAAInB,IAAI,KAAK,MAAb,EAAqB;AAC1BQ,QAAAA,MAAM,CAACU,CAAD,CAAN,GAAY7C,UAAU,CAACgD,SAAX,CAAqBF,cAArB,CAAZ;AACD,OAFM,MAEA,IAAInB,IAAI,KAAK,MAAb,EAAqB;AAC1BQ,QAAAA,MAAM,CAACU,CAAD,CAAN,GAAYvC,UAAU,CAAC2C,MAAX,CAAkBH,cAAlB,CAAZ;AACD;;AACDtB,MAAAA,UAAU,IAAIkB,UAAd;AACD,KApCmB,CAqCpB;;;AAEA,QAAIvC,OAAO,CAACc,KAAK,CAACc,QAAP,CAAX,EAA6B;AAC3B;AACAC,MAAAA,yBAAyB,CAACE,GAAD,CAAzB,GAAiCC,MAAjC;AACD;AACF;;AAED,SAAOA,MAAP;AACD,CAlDD;;AAoDA,IAAIe,sBAAsB,GAAG,EAA7B;;AAEA,SAASC,qBAAT,CAA+BlC,KAA/B,EAAsCmC,aAAtC,EAAqDC,WAArD,EAAkE;AAChE,SAAOpC,KAAK,CAACc,QAAN,GAAiB,IAAjB,GAAwBqB,aAAxB,GAAwC,GAAxC,GAA8CC,WAArD;AACD;;AAED,SAASC,cAAT,CAAwBC,KAAxB,EAA+B;AAC7B,OAAKC,MAAL,GAAcD,KAAd;AACD;;AACDD,cAAc,CAACG,SAAf,CAAyBC,QAAzB,GAAoC,UAAUC,IAAV,EAAgBC,MAAhB,EAAwB;AAC1D,SAAO,KAAKJ,MAAZ;AACD,CAFD;;AAGAF,cAAc,CAACG,SAAf,CAAyBI,QAAzB,GAAoC,UAAUF,IAAV,EAAgB;AAClD,SAAO,GAAP;AACD,CAFD;;AAGAL,cAAc,CAACG,SAAf,CAAyBK,SAAzB,GAAqC,UAAUH,IAAV,EAAgB;AACnD,SAAO,GAAP;AACD,CAFD;;AAIA,SAASI,aAAT,CAAuBC,aAAvB,EAAsC;AACpC,OAAKC,OAAL,GAAeD,aAAf;AACA,OAAKE,cAAL,GAAsB,CAAtB;AACD;;AACDH,aAAa,CAACN,SAAd,CAAwBU,gBAAxB,GAA2C3D,MAAM,CAACiD,SAAP,CAAiBU,gBAA5D;;AACAJ,aAAa,CAACN,SAAd,CAAwBC,QAAxB,GAAmC,UAAUC,IAAV,EAAgBC,MAAhB,EAAwB;AACzD,MAAIf,CAAC,GAAI,KAAKqB,cAAL,GAAsB,KAAKC,gBAAL,CAC7BR,IAD6B,EAE7B,KAAKO,cAFwB,CAA/B;AAIA,MAAIE,KAAK,GAAG,KAAKH,OAAL,CAAaG,KAAzB;AACA,MAAIC,WAAW,GAAGV,IAAI,IAAIS,KAAK,CAACvB,CAAC,GAAG,CAAL,CAAb,GAAuBuB,KAAK,CAACvB,CAAC,GAAG,CAAL,CAA5B,GAAsCuB,KAAK,CAACvB,CAAD,CAA7D;AACA,SAAO,KAAKoB,OAAL,CAAaP,QAAb,CAAsBW,WAAtB,EAAmCT,MAAnC,CAAP;AACD,CARD;;AASAU,MAAM,CAACC,gBAAP,CAAwBR,aAAa,CAACN,SAAtC,EAAiD;AAC/CW,EAAAA,KAAK,EAAE;AACLI,IAAAA,GAAG,EAAE,YAAY;AACf,aAAO,KAAKP,OAAL,CAAaG,KAApB;AACD;AAHI;AADwC,CAAjD;;AAOAL,aAAa,CAACN,SAAd,CAAwBI,QAAxB,GAAmC,UAAUF,IAAV,EAAgB;AACjD,SAAO,KAAKM,OAAL,CAAaJ,QAAb,CAAsBF,IAAtB,CAAP;AACD,CAFD;;AAGAI,aAAa,CAACN,SAAd,CAAwBK,SAAxB,GAAoC,UAAUH,IAAV,EAAgB;AAClD,SAAO,KAAKM,OAAL,CAAaH,SAAb,CAAuBH,IAAvB,CAAP;AACD,CAFD;;AAIA7C,mBAAmB,CAAC2D,kBAApB,GAAyC,UACvCxD,KADuC,EAEvCmC,aAFuC,EAGvCsB,SAHuC,EAIvCrB,WAJuC,EAKvCsB,OALuC,EAMvCC,KANuC,EAOvCC,IAPuC,EAQvCC,MARuC,EASvC;AACA,MAAI5C,GAAG,GAAGiB,qBAAqB,CAAClC,KAAD,EAAQmC,aAAR,EAAuBC,WAAvB,CAA/B;AACA,MAAI0B,MAAM,GAAG7B,sBAAsB,CAAChB,GAAD,CAAnC;;AAEA,MAAI,CAAC/B,OAAO,CAAC4E,MAAD,CAAZ,EAAsB;AACpB,QAAIX,KAAK,GAAGQ,KAAZ;AACA,QAAII,aAAa,GAAGF,MAApB;;AAEA,QAAIV,KAAK,CAACa,MAAN,KAAiB,CAAjB,IAAsBD,aAAa,CAACC,MAAd,KAAyB,CAAnD,EAAsD;AACpDF,MAAAA,MAAM,GAAG,IAAIzB,cAAJ,CAAmB0B,aAAa,CAAC,CAAD,CAAhC,CAAT;AACD,KAFD,MAEO,IACLL,OAAO,CAACO,aAAR,KAA0B,QAA1B,IACAP,OAAO,CAACO,aAAR,KAA0B,MAFrB,EAGL;AACA,UAAIL,IAAI,KAAK,aAAT,IAA0BA,IAAI,KAAK,OAAvC,EAAgD;AAC9CE,QAAAA,MAAM,GAAG,IAAI3E,YAAJ,CAAiB;AACxBgE,UAAAA,KAAK,EAAEA,KADiB;AAExBe,UAAAA,MAAM,EAAEH;AAFgB,SAAjB,CAAT;AAID,OALD,MAKO,IAAIH,IAAI,KAAK,UAAb,EAAyB;AAC9BE,QAAAA,MAAM,GAAG,IAAIxE,gBAAJ,CAAqB;AAC5B6D,UAAAA,KAAK,EAAEA,KADqB;AAE5Be,UAAAA,MAAM,EAAEH;AAFoB,SAArB,CAAT;AAID,OALM,MAKA,IAAIH,IAAI,KAAK,SAAb,EAAwB;AAC7BE,QAAAA,MAAM,GAAG,IAAIrE,YAAJ,CAAiB;AACxB0D,UAAAA,KAAK,EAAEA,KADiB;AAExBgB,UAAAA,OAAO,EAAEJ;AAFe,SAAjB,CAAT;AAID;;AAED,UAAI7E,OAAO,CAAC4E,MAAD,CAAP,IAAmBJ,OAAO,CAACO,aAAR,KAA0B,MAAjD,EAAyD;AACvDH,QAAAA,MAAM,GAAG,IAAIhB,aAAJ,CAAkBgB,MAAlB,CAAT;AACD;AACF;;AAED,QAAI5E,OAAO,CAACc,KAAK,CAACc,QAAP,CAAX,EAA6B;AAC3B;AACAmB,MAAAA,sBAAsB,CAAChB,GAAD,CAAtB,GAA8B6C,MAA9B;AACD;AACF;;AAED,SAAOA,MAAP;AACD,CApDD;;AAsDA,IAAIM,6BAA6B,GAAG,EAApC;;AAEAvE,mBAAmB,CAACwE,0BAApB,GAAiD,UAAUrE,KAAV,EAAiBC,QAAjB,EAA2B;AAC1E,MAAIgB,GAAG,GAAGlB,cAAc,CAACC,KAAD,EAAQC,QAAR,CAAxB;AACA,MAAIqE,QAAQ,GAAGF,6BAA6B,CAACnD,GAAD,CAA5C;;AAEA,MAAI,CAAC/B,OAAO,CAACoF,QAAD,CAAZ,EAAwB;AACtB;AACA,QAAIpE,IAAI,GAAGF,KAAK,CAACE,IAAjB;AACA,QAAIC,OAAO,GAAGD,IAAI,CAACC,OAAnB;AACA,QAAIC,WAAW,GAAGF,IAAI,CAACE,WAAvB;AAEA,QAAImE,YAAY,GAAGtE,QAAQ,CAACI,UAA5B;AACA,QAAIA,UAAU,GAAGD,WAAW,CAACmE,YAAD,CAA5B;AACA,QAAIpD,QAAQ,GAAGd,UAAU,CAACC,MAA1B;AACA,QAAIA,MAAM,GAAGH,OAAO,CAACgB,QAAD,CAApB;AACA,QAAIC,MAAM,GAAGd,MAAM,CAACe,MAAP,CAAcC,SAAd,CAAwBF,MAArC;AAEA,QAAIG,aAAa,GAAGtB,QAAQ,CAACsB,aAA7B;AACA,QAAIb,IAAI,GAAGT,QAAQ,CAACS,IAApB;AACA,QAAID,KAAK,GAAGR,QAAQ,CAACQ,KAArB;AACA,QAAIgB,UAAU,GAAG/B,qBAAqB,CAACQ,IAAD,EAAOD,QAAP,CAAtC;AACA,QAAIM,UAAU,GAAGF,UAAU,CAACE,UAAX,GAAwBN,QAAQ,CAACM,UAAlD;AACA,QAAIiB,kBAAkB,GAAG7B,yBAAyB,CAACe,IAAD,CAAlD;AAEA4D,IAAAA,QAAQ,GAAG,IAAI5C,KAAJ,CAAUjB,KAAV,CAAX;;AAEA,QAAIc,aAAa,KAAK/B,cAAc,CAACgF,KAAjC,IAA0C9D,IAAI,KAAKd,aAAa,CAAC6E,IAArE,EAA2E;AACzE,WAAK,IAAI7C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnB,KAApB,EAA2B,EAAEmB,CAA7B,EAAgC;AAC9B,YAAIC,cAAc,GAAG7C,iBAAiB,CAAC8C,qBAAlB,CACnBP,aADmB,EAEnBH,MAAM,CAACd,MAFY,EAGnBc,MAAM,CAACb,UAAP,GAAoBA,UAHD,EAInBiB,kBAJmB,CAArB;AAMA8C,QAAAA,QAAQ,CAAC1C,CAAD,CAAR,GAAcxC,OAAO,CAAC2C,SAAR,CAAkBF,cAAlB,CAAd;AACAtB,QAAAA,UAAU,IAAIkB,UAAd;AACD;AACF;;AAED2C,IAAAA,6BAA6B,CAACnD,GAAD,CAA7B,GAAqCqD,QAArC;AACD;;AAED,SAAOA,QAAP;AACD,CA1CD;;AA2CA,eAAezE,mBAAf","sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport LinearSpline from \"../Core/LinearSpline.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport QuaternionSpline from \"../Core/QuaternionSpline.js\";\nimport Spline from \"../Core/Spline.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport WeightSpline from \"../Core/WeightSpline.js\";\nimport getAccessorByteStride from \"../ThirdParty/GltfPipeline/getAccessorByteStride.js\";\nimport numberOfComponentsForType from \"../ThirdParty/GltfPipeline/numberOfComponentsForType.js\";\nimport AttributeType from \"./AttributeType.js\";\n\n/**\n * @private\n */\nfunction ModelAnimationCache() {}\n\nvar dataUriRegex = /^data\\:/i;\n\nfunction getAccessorKey(model, accessor) {\n  var gltf = model.gltf;\n  var buffers = gltf.buffers;\n  var bufferViews = gltf.bufferViews;\n\n  var bufferView = bufferViews[accessor.bufferView];\n  var buffer = buffers[bufferView.buffer];\n\n  var byteOffset = bufferView.byteOffset + accessor.byteOffset;\n  var byteLength = accessor.count * numberOfComponentsForType(accessor.type);\n\n  var uriKey = dataUriRegex.test(buffer.uri) ? \"\" : buffer.uri;\n  return model.cacheKey + \"//\" + uriKey + \"/\" + byteOffset + \"/\" + byteLength;\n}\n\nvar cachedAnimationParameters = {};\n\nModelAnimationCache.getAnimationParameterValues = function (model, accessor) {\n  var key = getAccessorKey(model, accessor);\n  var values = cachedAnimationParameters[key];\n\n  if (!defined(values)) {\n    // Cache miss\n    var gltf = model.gltf;\n\n    var buffers = gltf.buffers;\n    var bufferViews = gltf.bufferViews;\n\n    var bufferView = bufferViews[accessor.bufferView];\n    var bufferId = bufferView.buffer;\n    var buffer = buffers[bufferId];\n    var source = buffer.extras._pipeline.source;\n\n    var componentType = accessor.componentType;\n    var type = accessor.type;\n    var numberOfComponents = numberOfComponentsForType(type);\n    var count = accessor.count;\n    var byteStride = getAccessorByteStride(gltf, accessor);\n\n    values = new Array(count);\n    var accessorByteOffset = defaultValue(accessor.byteOffset, 0);\n    var byteOffset = bufferView.byteOffset + accessorByteOffset;\n    for (var i = 0; i < count; i++) {\n      var typedArrayView = ComponentDatatype.createArrayBufferView(\n        componentType,\n        source.buffer,\n        source.byteOffset + byteOffset,\n        numberOfComponents\n      );\n      if (type === \"SCALAR\") {\n        values[i] = typedArrayView[0];\n      } else if (type === \"VEC3\") {\n        values[i] = Cartesian3.fromArray(typedArrayView);\n      } else if (type === \"VEC4\") {\n        values[i] = Quaternion.unpack(typedArrayView);\n      }\n      byteOffset += byteStride;\n    }\n    // GLTF_SPEC: Support more parameter types when glTF supports targeting materials. https://github.com/KhronosGroup/glTF/issues/142\n\n    if (defined(model.cacheKey)) {\n      // Only cache when we can create a unique id\n      cachedAnimationParameters[key] = values;\n    }\n  }\n\n  return values;\n};\n\nvar cachedAnimationSplines = {};\n\nfunction getAnimationSplineKey(model, animationName, samplerName) {\n  return model.cacheKey + \"//\" + animationName + \"/\" + samplerName;\n}\n\nfunction ConstantSpline(value) {\n  this._value = value;\n}\nConstantSpline.prototype.evaluate = function (time, result) {\n  return this._value;\n};\nConstantSpline.prototype.wrapTime = function (time) {\n  return 0.0;\n};\nConstantSpline.prototype.clampTime = function (time) {\n  return 0.0;\n};\n\nfunction SteppedSpline(backingSpline) {\n  this._spline = backingSpline;\n  this._lastTimeIndex = 0;\n}\nSteppedSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\nSteppedSpline.prototype.evaluate = function (time, result) {\n  var i = (this._lastTimeIndex = this.findTimeInterval(\n    time,\n    this._lastTimeIndex\n  ));\n  var times = this._spline.times;\n  var steppedTime = time >= times[i + 1] ? times[i + 1] : times[i];\n  return this._spline.evaluate(steppedTime, result);\n};\nObject.defineProperties(SteppedSpline.prototype, {\n  times: {\n    get: function () {\n      return this._spline.times;\n    },\n  },\n});\nSteppedSpline.prototype.wrapTime = function (time) {\n  return this._spline.wrapTime(time);\n};\nSteppedSpline.prototype.clampTime = function (time) {\n  return this._spline.clampTime(time);\n};\n\nModelAnimationCache.getAnimationSpline = function (\n  model,\n  animationName,\n  animation,\n  samplerName,\n  sampler,\n  input,\n  path,\n  output\n) {\n  var key = getAnimationSplineKey(model, animationName, samplerName);\n  var spline = cachedAnimationSplines[key];\n\n  if (!defined(spline)) {\n    var times = input;\n    var controlPoints = output;\n\n    if (times.length === 1 && controlPoints.length === 1) {\n      spline = new ConstantSpline(controlPoints[0]);\n    } else if (\n      sampler.interpolation === \"LINEAR\" ||\n      sampler.interpolation === \"STEP\"\n    ) {\n      if (path === \"translation\" || path === \"scale\") {\n        spline = new LinearSpline({\n          times: times,\n          points: controlPoints,\n        });\n      } else if (path === \"rotation\") {\n        spline = new QuaternionSpline({\n          times: times,\n          points: controlPoints,\n        });\n      } else if (path === \"weights\") {\n        spline = new WeightSpline({\n          times: times,\n          weights: controlPoints,\n        });\n      }\n\n      if (defined(spline) && sampler.interpolation === \"STEP\") {\n        spline = new SteppedSpline(spline);\n      }\n    }\n\n    if (defined(model.cacheKey)) {\n      // Only cache when we can create a unique id\n      cachedAnimationSplines[key] = spline;\n    }\n  }\n\n  return spline;\n};\n\nvar cachedSkinInverseBindMatrices = {};\n\nModelAnimationCache.getSkinInverseBindMatrices = function (model, accessor) {\n  var key = getAccessorKey(model, accessor);\n  var matrices = cachedSkinInverseBindMatrices[key];\n\n  if (!defined(matrices)) {\n    // Cache miss\n    var gltf = model.gltf;\n    var buffers = gltf.buffers;\n    var bufferViews = gltf.bufferViews;\n\n    var bufferViewId = accessor.bufferView;\n    var bufferView = bufferViews[bufferViewId];\n    var bufferId = bufferView.buffer;\n    var buffer = buffers[bufferId];\n    var source = buffer.extras._pipeline.source;\n\n    var componentType = accessor.componentType;\n    var type = accessor.type;\n    var count = accessor.count;\n    var byteStride = getAccessorByteStride(gltf, accessor);\n    var byteOffset = bufferView.byteOffset + accessor.byteOffset;\n    var numberOfComponents = numberOfComponentsForType(type);\n\n    matrices = new Array(count);\n\n    if (componentType === WebGLConstants.FLOAT && type === AttributeType.MAT4) {\n      for (var i = 0; i < count; ++i) {\n        var typedArrayView = ComponentDatatype.createArrayBufferView(\n          componentType,\n          source.buffer,\n          source.byteOffset + byteOffset,\n          numberOfComponents\n        );\n        matrices[i] = Matrix4.fromArray(typedArrayView);\n        byteOffset += byteStride;\n      }\n    }\n\n    cachedSkinInverseBindMatrices[key] = matrices;\n  }\n\n  return matrices;\n};\nexport default ModelAnimationCache;\n"]},"metadata":{},"sourceType":"module"}