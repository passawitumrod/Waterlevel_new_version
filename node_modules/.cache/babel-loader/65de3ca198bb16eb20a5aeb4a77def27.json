{"ast":null,"code":"import arrayFill from \"./arrayFill.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CornerType from \"./CornerType.js\";\nimport CorridorGeometryLibrary from \"./CorridorGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nvar cartesian1 = new Cartesian3();\nvar cartesian2 = new Cartesian3();\nvar cartesian3 = new Cartesian3();\n\nfunction scaleToSurface(positions, ellipsoid) {\n  for (var i = 0; i < positions.length; i++) {\n    positions[i] = ellipsoid.scaleToGeodeticSurface(positions[i], positions[i]);\n  }\n\n  return positions;\n}\n\nfunction combine(computedPositions, cornerType) {\n  var wallIndices = [];\n  var positions = computedPositions.positions;\n  var corners = computedPositions.corners;\n  var endPositions = computedPositions.endPositions;\n  var attributes = new GeometryAttributes();\n  var corner;\n  var leftCount = 0;\n  var rightCount = 0;\n  var i;\n  var indicesLength = 0;\n  var length;\n\n  for (i = 0; i < positions.length; i += 2) {\n    length = positions[i].length - 3;\n    leftCount += length; //subtracting 3 to account for duplicate points at corners\n\n    indicesLength += length / 3 * 4;\n    rightCount += positions[i + 1].length - 3;\n  }\n\n  leftCount += 3; //add back count for end positions\n\n  rightCount += 3;\n\n  for (i = 0; i < corners.length; i++) {\n    corner = corners[i];\n    var leftSide = corners[i].leftPositions;\n\n    if (defined(leftSide)) {\n      length = leftSide.length;\n      leftCount += length;\n      indicesLength += length / 3 * 2;\n    } else {\n      length = corners[i].rightPositions.length;\n      rightCount += length;\n      indicesLength += length / 3 * 2;\n    }\n  }\n\n  var addEndPositions = defined(endPositions);\n  var endPositionLength;\n\n  if (addEndPositions) {\n    endPositionLength = endPositions[0].length - 3;\n    leftCount += endPositionLength;\n    rightCount += endPositionLength;\n    endPositionLength /= 3;\n    indicesLength += endPositionLength * 4;\n  }\n\n  var size = leftCount + rightCount;\n  var finalPositions = new Float64Array(size);\n  var front = 0;\n  var back = size - 1;\n  var UL, LL, UR, LR;\n  var rightPos, leftPos;\n  var halfLength = endPositionLength / 2;\n  var indices = IndexDatatype.createTypedArray(size / 3, indicesLength + 4);\n  var index = 0;\n  indices[index++] = front / 3;\n  indices[index++] = (back - 2) / 3;\n\n  if (addEndPositions) {\n    // add rounded end\n    wallIndices.push(front / 3);\n    leftPos = cartesian1;\n    rightPos = cartesian2;\n    var firstEndPositions = endPositions[0];\n\n    for (i = 0; i < halfLength; i++) {\n      leftPos = Cartesian3.fromArray(firstEndPositions, (halfLength - 1 - i) * 3, leftPos);\n      rightPos = Cartesian3.fromArray(firstEndPositions, (halfLength + i) * 3, rightPos);\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n      CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);\n      LL = front / 3;\n      LR = LL + 1;\n      UL = (back - 2) / 3;\n      UR = UL - 1;\n      indices[index++] = UL;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n      front += 3;\n      back -= 3;\n    }\n  }\n\n  var posIndex = 0;\n  var rightEdge = positions[posIndex++]; //add first two edges\n\n  var leftEdge = positions[posIndex++];\n  finalPositions.set(rightEdge, front);\n  finalPositions.set(leftEdge, back - leftEdge.length + 1);\n  length = leftEdge.length - 3;\n  wallIndices.push(front / 3, (back - 2) / 3);\n\n  for (i = 0; i < length; i += 3) {\n    LL = front / 3;\n    LR = LL + 1;\n    UL = (back - 2) / 3;\n    UR = UL - 1;\n    indices[index++] = UL;\n    indices[index++] = UR;\n    indices[index++] = LL;\n    indices[index++] = LR;\n    front += 3;\n    back -= 3;\n  }\n\n  for (i = 0; i < corners.length; i++) {\n    var j;\n    corner = corners[i];\n    var l = corner.leftPositions;\n    var r = corner.rightPositions;\n    var start;\n    var outsidePoint = cartesian3;\n\n    if (defined(l)) {\n      back -= 3;\n      start = UR;\n      wallIndices.push(LR);\n\n      for (j = 0; j < l.length / 3; j++) {\n        outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);\n        indices[index++] = start - j - 1;\n        indices[index++] = start - j;\n        CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, undefined, back);\n        back -= 3;\n      }\n\n      wallIndices.push(start - Math.floor(l.length / 6));\n\n      if (cornerType === CornerType.BEVELED) {\n        wallIndices.push((back - 2) / 3 + 1);\n      }\n\n      front += 3;\n    } else {\n      front += 3;\n      start = LR;\n      wallIndices.push(UR);\n\n      for (j = 0; j < r.length / 3; j++) {\n        outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);\n        indices[index++] = start + j;\n        indices[index++] = start + j + 1;\n        CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, front);\n        front += 3;\n      }\n\n      wallIndices.push(start + Math.floor(r.length / 6));\n\n      if (cornerType === CornerType.BEVELED) {\n        wallIndices.push(front / 3 - 1);\n      }\n\n      back -= 3;\n    }\n\n    rightEdge = positions[posIndex++];\n    leftEdge = positions[posIndex++];\n    rightEdge.splice(0, 3); //remove duplicate points added by corner\n\n    leftEdge.splice(leftEdge.length - 3, 3);\n    finalPositions.set(rightEdge, front);\n    finalPositions.set(leftEdge, back - leftEdge.length + 1);\n    length = leftEdge.length - 3;\n\n    for (j = 0; j < leftEdge.length; j += 3) {\n      LR = front / 3;\n      LL = LR - 1;\n      UR = (back - 2) / 3;\n      UL = UR + 1;\n      indices[index++] = UL;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n      front += 3;\n      back -= 3;\n    }\n\n    front -= 3;\n    back += 3;\n    wallIndices.push(front / 3, (back - 2) / 3);\n  }\n\n  if (addEndPositions) {\n    // add rounded end\n    front += 3;\n    back -= 3;\n    leftPos = cartesian1;\n    rightPos = cartesian2;\n    var lastEndPositions = endPositions[1];\n\n    for (i = 0; i < halfLength; i++) {\n      leftPos = Cartesian3.fromArray(lastEndPositions, (endPositionLength - i - 1) * 3, leftPos);\n      rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);\n      CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n      LR = front / 3;\n      LL = LR - 1;\n      UR = (back - 2) / 3;\n      UL = UR + 1;\n      indices[index++] = UL;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n      front += 3;\n      back -= 3;\n    }\n\n    wallIndices.push(front / 3);\n  } else {\n    wallIndices.push(front / 3, (back - 2) / 3);\n  }\n\n  indices[index++] = front / 3;\n  indices[index++] = (back - 2) / 3;\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: finalPositions\n  });\n  return {\n    attributes: attributes,\n    indices: indices,\n    wallIndices: wallIndices\n  };\n}\n\nfunction computePositionsExtruded(params) {\n  var ellipsoid = params.ellipsoid;\n  var computedPositions = CorridorGeometryLibrary.computePositions(params);\n  var attr = combine(computedPositions, params.cornerType);\n  var wallIndices = attr.wallIndices;\n  var height = params.height;\n  var extrudedHeight = params.extrudedHeight;\n  var attributes = attr.attributes;\n  var indices = attr.indices;\n  var positions = attributes.position.values;\n  var length = positions.length;\n  var extrudedPositions = new Float64Array(length);\n  extrudedPositions.set(positions);\n  var newPositions = new Float64Array(length * 2);\n  positions = PolygonPipeline.scaleToGeodeticHeight(positions, height, ellipsoid);\n  extrudedPositions = PolygonPipeline.scaleToGeodeticHeight(extrudedPositions, extrudedHeight, ellipsoid);\n  newPositions.set(positions);\n  newPositions.set(extrudedPositions, length);\n  attributes.position.values = newPositions;\n  length /= 3;\n\n  if (defined(params.offsetAttribute)) {\n    var applyOffset = new Uint8Array(length * 2);\n\n    if (params.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      applyOffset = arrayFill(applyOffset, 1, 0, length);\n    } else {\n      var applyOffsetValue = params.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      applyOffset = arrayFill(applyOffset, applyOffsetValue);\n    }\n\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset\n    });\n  }\n\n  var i;\n  var iLength = indices.length;\n  var newIndices = IndexDatatype.createTypedArray(newPositions.length / 3, (iLength + wallIndices.length) * 2);\n  newIndices.set(indices);\n  var index = iLength;\n\n  for (i = 0; i < iLength; i += 2) {\n    // bottom indices\n    var v0 = indices[i];\n    var v1 = indices[i + 1];\n    newIndices[index++] = v0 + length;\n    newIndices[index++] = v1 + length;\n  }\n\n  var UL, LL;\n\n  for (i = 0; i < wallIndices.length; i++) {\n    //wall indices\n    UL = wallIndices[i];\n    LL = UL + length;\n    newIndices[index++] = UL;\n    newIndices[index++] = LL;\n  }\n\n  return {\n    attributes: attributes,\n    indices: newIndices\n  };\n}\n/**\n * A description of a corridor outline.\n *\n * @alias CorridorOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor outline.\n * @param {Number} options.width The distance between the edges of the corridor outline.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Number} [options.height=0] The distance in meters between the positions and the ellipsoid surface.\n * @param {Number} [options.extrudedHeight] The distance in meters between the extruded face and the ellipsoid surface.\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n *\n * @see CorridorOutlineGeometry.createGeometry\n *\n * @example\n * var corridor = new Cesium.CorridorOutlineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\n *   width : 100000\n * });\n */\n\n\nfunction CorridorOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var positions = options.positions;\n  var width = options.width; //>>includeStart('debug', pragmas.debug);\n\n  Check.typeOf.object(\"options.positions\", positions);\n  Check.typeOf.number(\"options.width\", width); //>>includeEnd('debug');\n\n  var height = defaultValue(options.height, 0.0);\n  var extrudedHeight = defaultValue(options.extrudedHeight, height);\n  this._positions = positions;\n  this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n  this._width = width;\n  this._height = Math.max(height, extrudedHeight);\n  this._extrudedHeight = Math.min(height, extrudedHeight);\n  this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n  this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createCorridorOutlineGeometry\";\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n\n  this.packedLength = 1 + positions.length * Cartesian3.packedLength + Ellipsoid.packedLength + 6;\n}\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CorridorOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\n\nCorridorOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.typeOf.object(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var positions = value._positions;\n  var length = positions.length;\n  array[startingIndex++] = length;\n\n  for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n  array[startingIndex++] = value._width;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._cornerType;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n  return array;\n};\n\nvar scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nvar scratchOptions = {\n  positions: undefined,\n  ellipsoid: scratchEllipsoid,\n  width: undefined,\n  height: undefined,\n  extrudedHeight: undefined,\n  cornerType: undefined,\n  granularity: undefined,\n  offsetAttribute: undefined\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CorridorOutlineGeometry} [result] The object into which to store the result.\n * @returns {CorridorOutlineGeometry} The modified result parameter or a new CorridorOutlineGeometry instance if one was not provided.\n */\n\nCorridorOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var length = array[startingIndex++];\n  var positions = new Array(length);\n\n  for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n  var width = array[startingIndex++];\n  var height = array[startingIndex++];\n  var extrudedHeight = array[startingIndex++];\n  var cornerType = array[startingIndex++];\n  var granularity = array[startingIndex++];\n  var offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.positions = positions;\n    scratchOptions.width = width;\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.cornerType = cornerType;\n    scratchOptions.granularity = granularity;\n    scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new CorridorOutlineGeometry(scratchOptions);\n  }\n\n  result._positions = positions;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._width = width;\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._cornerType = cornerType;\n  result._granularity = granularity;\n  result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n  return result;\n};\n/**\n * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.\n *\n * @param {CorridorOutlineGeometry} corridorOutlineGeometry A description of the corridor.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\n\n\nCorridorOutlineGeometry.createGeometry = function (corridorOutlineGeometry) {\n  var positions = corridorOutlineGeometry._positions;\n  var width = corridorOutlineGeometry._width;\n  var ellipsoid = corridorOutlineGeometry._ellipsoid;\n  positions = scaleToSurface(positions, ellipsoid);\n  var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n\n  if (cleanPositions.length < 2 || width <= 0) {\n    return;\n  }\n\n  var height = corridorOutlineGeometry._height;\n  var extrudedHeight = corridorOutlineGeometry._extrudedHeight;\n  var extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n  var params = {\n    ellipsoid: ellipsoid,\n    positions: cleanPositions,\n    width: width,\n    cornerType: corridorOutlineGeometry._cornerType,\n    granularity: corridorOutlineGeometry._granularity,\n    saveAttributes: false\n  };\n  var attr;\n\n  if (extrude) {\n    params.height = height;\n    params.extrudedHeight = extrudedHeight;\n    params.offsetAttribute = corridorOutlineGeometry._offsetAttribute;\n    attr = computePositionsExtruded(params);\n  } else {\n    var computedPositions = CorridorGeometryLibrary.computePositions(params);\n    attr = combine(computedPositions, params.cornerType);\n    attr.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(attr.attributes.position.values, height, ellipsoid);\n\n    if (defined(corridorOutlineGeometry._offsetAttribute)) {\n      var length = attr.attributes.position.values.length;\n      var applyOffset = new Uint8Array(length / 3);\n      var offsetValue = corridorOutlineGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      arrayFill(applyOffset, offsetValue);\n      attr.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset\n      });\n    }\n  }\n\n  var attributes = attr.attributes;\n  var boundingSphere = BoundingSphere.fromVertices(attributes.position.values, undefined, 3);\n  return new Geometry({\n    attributes: attributes,\n    indices: attr.indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: corridorOutlineGeometry._offsetAttribute\n  });\n};\n\nexport default CorridorOutlineGeometry;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/CorridorOutlineGeometry.js"],"names":["arrayFill","arrayRemoveDuplicates","BoundingSphere","Cartesian3","Check","ComponentDatatype","CornerType","CorridorGeometryLibrary","defaultValue","defined","Ellipsoid","Geometry","GeometryAttribute","GeometryAttributes","GeometryOffsetAttribute","IndexDatatype","CesiumMath","PolygonPipeline","PrimitiveType","cartesian1","cartesian2","cartesian3","scaleToSurface","positions","ellipsoid","i","length","scaleToGeodeticSurface","combine","computedPositions","cornerType","wallIndices","corners","endPositions","attributes","corner","leftCount","rightCount","indicesLength","leftSide","leftPositions","rightPositions","addEndPositions","endPositionLength","size","finalPositions","Float64Array","front","back","UL","LL","UR","LR","rightPos","leftPos","halfLength","indices","createTypedArray","index","push","firstEndPositions","fromArray","addAttribute","undefined","posIndex","rightEdge","leftEdge","set","j","l","r","start","outsidePoint","Math","floor","BEVELED","splice","lastEndPositions","position","componentDatatype","DOUBLE","componentsPerAttribute","values","computePositionsExtruded","params","computePositions","attr","height","extrudedHeight","extrudedPositions","newPositions","scaleToGeodeticHeight","offsetAttribute","applyOffset","Uint8Array","TOP","applyOffsetValue","NONE","UNSIGNED_BYTE","iLength","newIndices","v0","v1","CorridorOutlineGeometry","options","EMPTY_OBJECT","width","typeOf","object","number","_positions","_ellipsoid","clone","WGS84","_width","_height","max","_extrudedHeight","min","_cornerType","ROUNDED","_granularity","granularity","RADIANS_PER_DEGREE","_offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","scratchEllipsoid","UNIT_SPHERE","scratchOptions","unpack","result","Array","createGeometry","corridorOutlineGeometry","cleanPositions","equalsEpsilon","extrude","EPSILON2","saveAttributes","offsetValue","boundingSphere","fromVertices","primitiveType","LINES"],"mappings":"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","sourcesContent":["import arrayFill from \"./arrayFill.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CornerType from \"./CornerType.js\";\nimport CorridorGeometryLibrary from \"./CorridorGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nvar cartesian1 = new Cartesian3();\nvar cartesian2 = new Cartesian3();\nvar cartesian3 = new Cartesian3();\n\nfunction scaleToSurface(positions, ellipsoid) {\n  for (var i = 0; i < positions.length; i++) {\n    positions[i] = ellipsoid.scaleToGeodeticSurface(positions[i], positions[i]);\n  }\n  return positions;\n}\n\nfunction combine(computedPositions, cornerType) {\n  var wallIndices = [];\n  var positions = computedPositions.positions;\n  var corners = computedPositions.corners;\n  var endPositions = computedPositions.endPositions;\n  var attributes = new GeometryAttributes();\n  var corner;\n  var leftCount = 0;\n  var rightCount = 0;\n  var i;\n  var indicesLength = 0;\n  var length;\n  for (i = 0; i < positions.length; i += 2) {\n    length = positions[i].length - 3;\n    leftCount += length; //subtracting 3 to account for duplicate points at corners\n    indicesLength += (length / 3) * 4;\n    rightCount += positions[i + 1].length - 3;\n  }\n  leftCount += 3; //add back count for end positions\n  rightCount += 3;\n  for (i = 0; i < corners.length; i++) {\n    corner = corners[i];\n    var leftSide = corners[i].leftPositions;\n    if (defined(leftSide)) {\n      length = leftSide.length;\n      leftCount += length;\n      indicesLength += (length / 3) * 2;\n    } else {\n      length = corners[i].rightPositions.length;\n      rightCount += length;\n      indicesLength += (length / 3) * 2;\n    }\n  }\n\n  var addEndPositions = defined(endPositions);\n  var endPositionLength;\n  if (addEndPositions) {\n    endPositionLength = endPositions[0].length - 3;\n    leftCount += endPositionLength;\n    rightCount += endPositionLength;\n    endPositionLength /= 3;\n    indicesLength += endPositionLength * 4;\n  }\n  var size = leftCount + rightCount;\n  var finalPositions = new Float64Array(size);\n  var front = 0;\n  var back = size - 1;\n  var UL, LL, UR, LR;\n  var rightPos, leftPos;\n  var halfLength = endPositionLength / 2;\n\n  var indices = IndexDatatype.createTypedArray(size / 3, indicesLength + 4);\n  var index = 0;\n\n  indices[index++] = front / 3;\n  indices[index++] = (back - 2) / 3;\n  if (addEndPositions) {\n    // add rounded end\n    wallIndices.push(front / 3);\n    leftPos = cartesian1;\n    rightPos = cartesian2;\n    var firstEndPositions = endPositions[0];\n    for (i = 0; i < halfLength; i++) {\n      leftPos = Cartesian3.fromArray(\n        firstEndPositions,\n        (halfLength - 1 - i) * 3,\n        leftPos\n      );\n      rightPos = Cartesian3.fromArray(\n        firstEndPositions,\n        (halfLength + i) * 3,\n        rightPos\n      );\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n      CorridorGeometryLibrary.addAttribute(\n        finalPositions,\n        leftPos,\n        undefined,\n        back\n      );\n\n      LL = front / 3;\n      LR = LL + 1;\n      UL = (back - 2) / 3;\n      UR = UL - 1;\n      indices[index++] = UL;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n\n      front += 3;\n      back -= 3;\n    }\n  }\n\n  var posIndex = 0;\n  var rightEdge = positions[posIndex++]; //add first two edges\n  var leftEdge = positions[posIndex++];\n  finalPositions.set(rightEdge, front);\n  finalPositions.set(leftEdge, back - leftEdge.length + 1);\n\n  length = leftEdge.length - 3;\n  wallIndices.push(front / 3, (back - 2) / 3);\n  for (i = 0; i < length; i += 3) {\n    LL = front / 3;\n    LR = LL + 1;\n    UL = (back - 2) / 3;\n    UR = UL - 1;\n    indices[index++] = UL;\n    indices[index++] = UR;\n    indices[index++] = LL;\n    indices[index++] = LR;\n\n    front += 3;\n    back -= 3;\n  }\n\n  for (i = 0; i < corners.length; i++) {\n    var j;\n    corner = corners[i];\n    var l = corner.leftPositions;\n    var r = corner.rightPositions;\n    var start;\n    var outsidePoint = cartesian3;\n    if (defined(l)) {\n      back -= 3;\n      start = UR;\n      wallIndices.push(LR);\n      for (j = 0; j < l.length / 3; j++) {\n        outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);\n        indices[index++] = start - j - 1;\n        indices[index++] = start - j;\n        CorridorGeometryLibrary.addAttribute(\n          finalPositions,\n          outsidePoint,\n          undefined,\n          back\n        );\n        back -= 3;\n      }\n      wallIndices.push(start - Math.floor(l.length / 6));\n      if (cornerType === CornerType.BEVELED) {\n        wallIndices.push((back - 2) / 3 + 1);\n      }\n      front += 3;\n    } else {\n      front += 3;\n      start = LR;\n      wallIndices.push(UR);\n      for (j = 0; j < r.length / 3; j++) {\n        outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);\n        indices[index++] = start + j;\n        indices[index++] = start + j + 1;\n        CorridorGeometryLibrary.addAttribute(\n          finalPositions,\n          outsidePoint,\n          front\n        );\n        front += 3;\n      }\n      wallIndices.push(start + Math.floor(r.length / 6));\n      if (cornerType === CornerType.BEVELED) {\n        wallIndices.push(front / 3 - 1);\n      }\n      back -= 3;\n    }\n    rightEdge = positions[posIndex++];\n    leftEdge = positions[posIndex++];\n    rightEdge.splice(0, 3); //remove duplicate points added by corner\n    leftEdge.splice(leftEdge.length - 3, 3);\n    finalPositions.set(rightEdge, front);\n    finalPositions.set(leftEdge, back - leftEdge.length + 1);\n    length = leftEdge.length - 3;\n\n    for (j = 0; j < leftEdge.length; j += 3) {\n      LR = front / 3;\n      LL = LR - 1;\n      UR = (back - 2) / 3;\n      UL = UR + 1;\n      indices[index++] = UL;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n      front += 3;\n      back -= 3;\n    }\n    front -= 3;\n    back += 3;\n    wallIndices.push(front / 3, (back - 2) / 3);\n  }\n\n  if (addEndPositions) {\n    // add rounded end\n    front += 3;\n    back -= 3;\n    leftPos = cartesian1;\n    rightPos = cartesian2;\n    var lastEndPositions = endPositions[1];\n    for (i = 0; i < halfLength; i++) {\n      leftPos = Cartesian3.fromArray(\n        lastEndPositions,\n        (endPositionLength - i - 1) * 3,\n        leftPos\n      );\n      rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);\n      CorridorGeometryLibrary.addAttribute(\n        finalPositions,\n        leftPos,\n        undefined,\n        back\n      );\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n\n      LR = front / 3;\n      LL = LR - 1;\n      UR = (back - 2) / 3;\n      UL = UR + 1;\n      indices[index++] = UL;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n\n      front += 3;\n      back -= 3;\n    }\n\n    wallIndices.push(front / 3);\n  } else {\n    wallIndices.push(front / 3, (back - 2) / 3);\n  }\n  indices[index++] = front / 3;\n  indices[index++] = (back - 2) / 3;\n\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: finalPositions,\n  });\n\n  return {\n    attributes: attributes,\n    indices: indices,\n    wallIndices: wallIndices,\n  };\n}\n\nfunction computePositionsExtruded(params) {\n  var ellipsoid = params.ellipsoid;\n  var computedPositions = CorridorGeometryLibrary.computePositions(params);\n  var attr = combine(computedPositions, params.cornerType);\n  var wallIndices = attr.wallIndices;\n  var height = params.height;\n  var extrudedHeight = params.extrudedHeight;\n  var attributes = attr.attributes;\n  var indices = attr.indices;\n  var positions = attributes.position.values;\n  var length = positions.length;\n  var extrudedPositions = new Float64Array(length);\n  extrudedPositions.set(positions);\n  var newPositions = new Float64Array(length * 2);\n\n  positions = PolygonPipeline.scaleToGeodeticHeight(\n    positions,\n    height,\n    ellipsoid\n  );\n  extrudedPositions = PolygonPipeline.scaleToGeodeticHeight(\n    extrudedPositions,\n    extrudedHeight,\n    ellipsoid\n  );\n  newPositions.set(positions);\n  newPositions.set(extrudedPositions, length);\n  attributes.position.values = newPositions;\n\n  length /= 3;\n  if (defined(params.offsetAttribute)) {\n    var applyOffset = new Uint8Array(length * 2);\n    if (params.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      applyOffset = arrayFill(applyOffset, 1, 0, length);\n    } else {\n      var applyOffsetValue =\n        params.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      applyOffset = arrayFill(applyOffset, applyOffsetValue);\n    }\n\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  var i;\n  var iLength = indices.length;\n  var newIndices = IndexDatatype.createTypedArray(\n    newPositions.length / 3,\n    (iLength + wallIndices.length) * 2\n  );\n  newIndices.set(indices);\n  var index = iLength;\n  for (i = 0; i < iLength; i += 2) {\n    // bottom indices\n    var v0 = indices[i];\n    var v1 = indices[i + 1];\n    newIndices[index++] = v0 + length;\n    newIndices[index++] = v1 + length;\n  }\n\n  var UL, LL;\n  for (i = 0; i < wallIndices.length; i++) {\n    //wall indices\n    UL = wallIndices[i];\n    LL = UL + length;\n    newIndices[index++] = UL;\n    newIndices[index++] = LL;\n  }\n\n  return {\n    attributes: attributes,\n    indices: newIndices,\n  };\n}\n\n/**\n * A description of a corridor outline.\n *\n * @alias CorridorOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor outline.\n * @param {Number} options.width The distance between the edges of the corridor outline.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Number} [options.height=0] The distance in meters between the positions and the ellipsoid surface.\n * @param {Number} [options.extrudedHeight] The distance in meters between the extruded face and the ellipsoid surface.\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n *\n * @see CorridorOutlineGeometry.createGeometry\n *\n * @example\n * var corridor = new Cesium.CorridorOutlineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\n *   width : 100000\n * });\n */\nfunction CorridorOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var positions = options.positions;\n  var width = options.width;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.positions\", positions);\n  Check.typeOf.number(\"options.width\", width);\n  //>>includeEnd('debug');\n\n  var height = defaultValue(options.height, 0.0);\n  var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  this._positions = positions;\n  this._ellipsoid = Ellipsoid.clone(\n    defaultValue(options.ellipsoid, Ellipsoid.WGS84)\n  );\n  this._width = width;\n  this._height = Math.max(height, extrudedHeight);\n  this._extrudedHeight = Math.min(height, extrudedHeight);\n  this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n  this._granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createCorridorOutlineGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  this.packedLength =\n    1 + positions.length * Cartesian3.packedLength + Ellipsoid.packedLength + 6;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CorridorOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCorridorOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.typeOf.object(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var positions = value._positions;\n  var length = positions.length;\n  array[startingIndex++] = length;\n\n  for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  array[startingIndex++] = value._width;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._cornerType;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nvar scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nvar scratchOptions = {\n  positions: undefined,\n  ellipsoid: scratchEllipsoid,\n  width: undefined,\n  height: undefined,\n  extrudedHeight: undefined,\n  cornerType: undefined,\n  granularity: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CorridorOutlineGeometry} [result] The object into which to store the result.\n * @returns {CorridorOutlineGeometry} The modified result parameter or a new CorridorOutlineGeometry instance if one was not provided.\n */\nCorridorOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var length = array[startingIndex++];\n  var positions = new Array(length);\n\n  for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  var width = array[startingIndex++];\n  var height = array[startingIndex++];\n  var extrudedHeight = array[startingIndex++];\n  var cornerType = array[startingIndex++];\n  var granularity = array[startingIndex++];\n  var offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.positions = positions;\n    scratchOptions.width = width;\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.cornerType = cornerType;\n    scratchOptions.granularity = granularity;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new CorridorOutlineGeometry(scratchOptions);\n  }\n\n  result._positions = positions;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._width = width;\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._cornerType = cornerType;\n  result._granularity = granularity;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.\n *\n * @param {CorridorOutlineGeometry} corridorOutlineGeometry A description of the corridor.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCorridorOutlineGeometry.createGeometry = function (corridorOutlineGeometry) {\n  var positions = corridorOutlineGeometry._positions;\n  var width = corridorOutlineGeometry._width;\n  var ellipsoid = corridorOutlineGeometry._ellipsoid;\n\n  positions = scaleToSurface(positions, ellipsoid);\n  var cleanPositions = arrayRemoveDuplicates(\n    positions,\n    Cartesian3.equalsEpsilon\n  );\n\n  if (cleanPositions.length < 2 || width <= 0) {\n    return;\n  }\n\n  var height = corridorOutlineGeometry._height;\n  var extrudedHeight = corridorOutlineGeometry._extrudedHeight;\n  var extrude = !CesiumMath.equalsEpsilon(\n    height,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2\n  );\n\n  var params = {\n    ellipsoid: ellipsoid,\n    positions: cleanPositions,\n    width: width,\n    cornerType: corridorOutlineGeometry._cornerType,\n    granularity: corridorOutlineGeometry._granularity,\n    saveAttributes: false,\n  };\n  var attr;\n  if (extrude) {\n    params.height = height;\n    params.extrudedHeight = extrudedHeight;\n    params.offsetAttribute = corridorOutlineGeometry._offsetAttribute;\n    attr = computePositionsExtruded(params);\n  } else {\n    var computedPositions = CorridorGeometryLibrary.computePositions(params);\n    attr = combine(computedPositions, params.cornerType);\n    attr.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n      attr.attributes.position.values,\n      height,\n      ellipsoid\n    );\n\n    if (defined(corridorOutlineGeometry._offsetAttribute)) {\n      var length = attr.attributes.position.values.length;\n      var applyOffset = new Uint8Array(length / 3);\n      var offsetValue =\n        corridorOutlineGeometry._offsetAttribute ===\n        GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      arrayFill(applyOffset, offsetValue);\n      attr.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n  }\n  var attributes = attr.attributes;\n  var boundingSphere = BoundingSphere.fromVertices(\n    attributes.position.values,\n    undefined,\n    3\n  );\n\n  return new Geometry({\n    attributes: attributes,\n    indices: attr.indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: corridorOutlineGeometry._offsetAttribute,\n  });\n};\nexport default CorridorOutlineGeometry;\n"]},"metadata":{},"sourceType":"module"}