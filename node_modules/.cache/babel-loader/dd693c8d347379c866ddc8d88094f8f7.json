{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"#ifdef LOG_DEPTH\\n\\\nvarying float v_depthFromNearPlusOne;\\n\\\n\\n\\\n#ifdef POLYGON_OFFSET\\n\\\nuniform vec2 u_polygonOffset;\\n\\\n#endif\\n\\\n\\n\\\n#endif\\n\\\n\\n\\\n/**\\n\\\n * Writes the fragment depth to the logarithmic depth buffer.\\n\\\n * <p>\\n\\\n * Use this when the vertex shader does not call {@link czm_vertexlogDepth}, for example, when\\n\\\n * ray-casting geometry using a full screen quad.\\n\\\n * </p>\\n\\\n * @name czm_writeLogDepth\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {float} depth The depth coordinate, where 1.0 is on the near plane and\\n\\\n *                      depth increases in eye-space units from there\\n\\\n *\\n\\\n * @example\\n\\\n * czm_writeLogDepth((czm_projection * v_positionEyeCoordinates).w + 1.0);\\n\\\n */\\n\\\nvoid czm_writeLogDepth(float depth)\\n\\\n{\\n\\\n#if defined(GL_EXT_frag_depth) && defined(LOG_DEPTH)\\n\\\n    // Discard the vertex if it's not between the near and far planes.\\n\\\n    // We allow a bit of epsilon on the near plane comparison because a 1.0\\n\\\n    // from the vertex shader (indicating the vertex should be _on_ the near\\n\\\n    // plane) will not necessarily come here as exactly 1.0.\\n\\\n    if (depth <= 0.9999999 || depth > czm_farDepthFromNearPlusOne) {\\n\\\n        discard;\\n\\\n    }\\n\\\n\\n\\\n#ifdef POLYGON_OFFSET\\n\\\n    // Polygon offset: m * factor + r * units\\n\\\n    float factor = u_polygonOffset[0];\\n\\\n    float units = u_polygonOffset[1];\\n\\\n\\n\\\n    // If we can't compute derivatives, just leave out the factor I guess?\\n\\\n#ifdef GL_OES_standard_derivatives\\n\\\n    // m = sqrt(dZdX^2 + dZdY^2);\\n\\\n    float x = dFdx(depth);\\n\\\n    float y = dFdy(depth);\\n\\\n    float m = sqrt(x * x + y * y);\\n\\\n\\n\\\n    // Apply the factor before computing the log depth.\\n\\\n    depth += m * factor;\\n\\\n#endif\\n\\\n\\n\\\n#endif\\n\\\n\\n\\\n    gl_FragDepthEXT = log2(depth) * czm_oneOverLog2FarDepthFromNearPlusOne;\\n\\\n\\n\\\n#ifdef POLYGON_OFFSET\\n\\\n    // Apply the units after the log depth.\\n\\\n    gl_FragDepthEXT += czm_epsilon7 * units;\\n\\\n#endif\\n\\\n\\n\\\n#endif\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Writes the fragment depth to the logarithmic depth buffer.\\n\\\n * <p>\\n\\\n * Use this when the vertex shader calls {@link czm_vertexlogDepth}.\\n\\\n * </p>\\n\\\n *\\n\\\n * @name czm_writeLogDepth\\n\\\n * @glslFunction\\n\\\n */\\n\\\nvoid czm_writeLogDepth() {\\n\\\n#ifdef LOG_DEPTH\\n\\\n    czm_writeLogDepth(v_depthFromNearPlusOne);\\n\\\n#endif\\n\\\n}\\n\\\n\";","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Shaders/Builtin/Functions/writeLogDepth.js"],"names":[],"mappings":"AAAA;AACA,eAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAAf","sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"#ifdef LOG_DEPTH\\n\\\nvarying float v_depthFromNearPlusOne;\\n\\\n\\n\\\n#ifdef POLYGON_OFFSET\\n\\\nuniform vec2 u_polygonOffset;\\n\\\n#endif\\n\\\n\\n\\\n#endif\\n\\\n\\n\\\n/**\\n\\\n * Writes the fragment depth to the logarithmic depth buffer.\\n\\\n * <p>\\n\\\n * Use this when the vertex shader does not call {@link czm_vertexlogDepth}, for example, when\\n\\\n * ray-casting geometry using a full screen quad.\\n\\\n * </p>\\n\\\n * @name czm_writeLogDepth\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {float} depth The depth coordinate, where 1.0 is on the near plane and\\n\\\n *                      depth increases in eye-space units from there\\n\\\n *\\n\\\n * @example\\n\\\n * czm_writeLogDepth((czm_projection * v_positionEyeCoordinates).w + 1.0);\\n\\\n */\\n\\\nvoid czm_writeLogDepth(float depth)\\n\\\n{\\n\\\n#if defined(GL_EXT_frag_depth) && defined(LOG_DEPTH)\\n\\\n    // Discard the vertex if it's not between the near and far planes.\\n\\\n    // We allow a bit of epsilon on the near plane comparison because a 1.0\\n\\\n    // from the vertex shader (indicating the vertex should be _on_ the near\\n\\\n    // plane) will not necessarily come here as exactly 1.0.\\n\\\n    if (depth <= 0.9999999 || depth > czm_farDepthFromNearPlusOne) {\\n\\\n        discard;\\n\\\n    }\\n\\\n\\n\\\n#ifdef POLYGON_OFFSET\\n\\\n    // Polygon offset: m * factor + r * units\\n\\\n    float factor = u_polygonOffset[0];\\n\\\n    float units = u_polygonOffset[1];\\n\\\n\\n\\\n    // If we can't compute derivatives, just leave out the factor I guess?\\n\\\n#ifdef GL_OES_standard_derivatives\\n\\\n    // m = sqrt(dZdX^2 + dZdY^2);\\n\\\n    float x = dFdx(depth);\\n\\\n    float y = dFdy(depth);\\n\\\n    float m = sqrt(x * x + y * y);\\n\\\n\\n\\\n    // Apply the factor before computing the log depth.\\n\\\n    depth += m * factor;\\n\\\n#endif\\n\\\n\\n\\\n#endif\\n\\\n\\n\\\n    gl_FragDepthEXT = log2(depth) * czm_oneOverLog2FarDepthFromNearPlusOne;\\n\\\n\\n\\\n#ifdef POLYGON_OFFSET\\n\\\n    // Apply the units after the log depth.\\n\\\n    gl_FragDepthEXT += czm_epsilon7 * units;\\n\\\n#endif\\n\\\n\\n\\\n#endif\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Writes the fragment depth to the logarithmic depth buffer.\\n\\\n * <p>\\n\\\n * Use this when the vertex shader calls {@link czm_vertexlogDepth}.\\n\\\n * </p>\\n\\\n *\\n\\\n * @name czm_writeLogDepth\\n\\\n * @glslFunction\\n\\\n */\\n\\\nvoid czm_writeLogDepth() {\\n\\\n#ifdef LOG_DEPTH\\n\\\n    czm_writeLogDepth(v_depthFromNearPlusOne);\\n\\\n#endif\\n\\\n}\\n\\\n\";\n"]},"metadata":{},"sourceType":"module"}