{"ast":null,"code":"import arrayFill from \"../Core/arrayFill.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport deprecationWarning from \"../Core/deprecationWarning.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport AttributeType from \"./AttributeType.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Cesium3DTileColorBlendMode from \"./Cesium3DTileColorBlendMode.js\";\nimport CullFace from \"./CullFace.js\";\nimport getBinaryAccessor from \"./getBinaryAccessor.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\nvar DEFAULT_COLOR_VALUE = Color.WHITE;\nvar DEFAULT_SHOW_VALUE = true;\n/**\n * @private\n * @constructor\n */\n\nfunction Cesium3DTileBatchTable(content, featuresLength, batchTableJson, batchTableBinary, colorChangedCallback) {\n  /**\n   * @readonly\n   */\n  this.featuresLength = featuresLength;\n  this._translucentFeaturesLength = 0; // Number of features in the tile that are translucent\n\n  var extensions;\n\n  if (defined(batchTableJson)) {\n    extensions = batchTableJson.extensions;\n  }\n\n  this._extensions = defaultValue(extensions, {});\n  var properties = initializeProperties(batchTableJson);\n  this._properties = properties;\n  this._batchTableHierarchy = initializeHierarchy(this, batchTableJson, batchTableBinary);\n  this._batchTableBinaryProperties = getBinaryProperties(featuresLength, properties, batchTableBinary); // PERFORMANCE_IDEA: These parallel arrays probably generate cache misses in get/set color/show\n  // and use A LOT of memory.  How can we use less memory?\n\n  this._showAlphaProperties = undefined; // [Show (0 or 255), Alpha (0 to 255)] property for each feature\n\n  this._batchValues = undefined; // Per-feature RGBA (A is based on the color's alpha and feature's show property)\n\n  this._batchValuesDirty = false;\n  this._batchTexture = undefined;\n  this._defaultTexture = undefined;\n  this._pickTexture = undefined;\n  this._pickIds = [];\n  this._content = content;\n  this._colorChangedCallback = colorChangedCallback; // Dimensions for batch and pick textures\n\n  var textureDimensions;\n  var textureStep;\n\n  if (featuresLength > 0) {\n    // PERFORMANCE_IDEA: this can waste memory in the last row in the uncommon case\n    // when more than one row is needed (e.g., > 16K features in one tile)\n    var width = Math.min(featuresLength, ContextLimits.maximumTextureSize);\n    var height = Math.ceil(featuresLength / ContextLimits.maximumTextureSize);\n    var stepX = 1.0 / width;\n    var centerX = stepX * 0.5;\n    var stepY = 1.0 / height;\n    var centerY = stepY * 0.5;\n    textureDimensions = new Cartesian2(width, height);\n    textureStep = new Cartesian4(stepX, centerX, stepY, centerY);\n  }\n\n  this._textureDimensions = textureDimensions;\n  this._textureStep = textureStep;\n} // This can be overridden for testing purposes\n\n\nCesium3DTileBatchTable._deprecationWarning = deprecationWarning;\nObject.defineProperties(Cesium3DTileBatchTable.prototype, {\n  memorySizeInBytes: {\n    get: function get() {\n      var memory = 0;\n\n      if (defined(this._pickTexture)) {\n        memory += this._pickTexture.sizeInBytes;\n      }\n\n      if (defined(this._batchTexture)) {\n        memory += this._batchTexture.sizeInBytes;\n      }\n\n      return memory;\n    }\n  }\n});\n\nfunction initializeProperties(jsonHeader) {\n  var properties = {};\n\n  if (!defined(jsonHeader)) {\n    return properties;\n  }\n\n  for (var propertyName in jsonHeader) {\n    if (jsonHeader.hasOwnProperty(propertyName) && propertyName !== \"HIERARCHY\" && // Deprecated HIERARCHY property\n    propertyName !== \"extensions\" && propertyName !== \"extras\") {\n      properties[propertyName] = clone(jsonHeader[propertyName], true);\n    }\n  }\n\n  return properties;\n}\n\nfunction initializeHierarchy(batchTable, jsonHeader, binaryBody) {\n  if (!defined(jsonHeader)) {\n    return;\n  }\n\n  var hierarchy = batchTable._extensions[\"3DTILES_batch_table_hierarchy\"];\n  var legacyHierarchy = jsonHeader.HIERARCHY;\n\n  if (defined(legacyHierarchy)) {\n    Cesium3DTileBatchTable._deprecationWarning(\"batchTableHierarchyExtension\", \"The batch table HIERARCHY property has been moved to an extension. Use extensions.3DTILES_batch_table_hierarchy instead.\");\n\n    batchTable._extensions[\"3DTILES_batch_table_hierarchy\"] = legacyHierarchy;\n    hierarchy = legacyHierarchy;\n  }\n\n  if (!defined(hierarchy)) {\n    return;\n  }\n\n  return initializeHierarchyValues(hierarchy, binaryBody);\n}\n\nfunction initializeHierarchyValues(hierarchyJson, binaryBody) {\n  var i;\n  var classId;\n  var binaryAccessor;\n  var instancesLength = hierarchyJson.instancesLength;\n  var classes = hierarchyJson.classes;\n  var classIds = hierarchyJson.classIds;\n  var parentCounts = hierarchyJson.parentCounts;\n  var parentIds = hierarchyJson.parentIds;\n  var parentIdsLength = instancesLength;\n\n  if (defined(classIds.byteOffset)) {\n    classIds.componentType = defaultValue(classIds.componentType, ComponentDatatype.UNSIGNED_SHORT);\n    classIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(classIds);\n    classIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + classIds.byteOffset, instancesLength);\n  }\n\n  var parentIndexes;\n\n  if (defined(parentCounts)) {\n    if (defined(parentCounts.byteOffset)) {\n      parentCounts.componentType = defaultValue(parentCounts.componentType, ComponentDatatype.UNSIGNED_SHORT);\n      parentCounts.type = AttributeType.SCALAR;\n      binaryAccessor = getBinaryAccessor(parentCounts);\n      parentCounts = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentCounts.byteOffset, instancesLength);\n    }\n\n    parentIndexes = new Uint16Array(instancesLength);\n    parentIdsLength = 0;\n\n    for (i = 0; i < instancesLength; ++i) {\n      parentIndexes[i] = parentIdsLength;\n      parentIdsLength += parentCounts[i];\n    }\n  }\n\n  if (defined(parentIds) && defined(parentIds.byteOffset)) {\n    parentIds.componentType = defaultValue(parentIds.componentType, ComponentDatatype.UNSIGNED_SHORT);\n    parentIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(parentIds);\n    parentIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentIds.byteOffset, parentIdsLength);\n  }\n\n  var classesLength = classes.length;\n\n  for (i = 0; i < classesLength; ++i) {\n    var classInstancesLength = classes[i].length;\n    var properties = classes[i].instances;\n    var binaryProperties = getBinaryProperties(classInstancesLength, properties, binaryBody);\n    classes[i].instances = combine(binaryProperties, properties);\n  }\n\n  var classCounts = arrayFill(new Array(classesLength), 0);\n  var classIndexes = new Uint16Array(instancesLength);\n\n  for (i = 0; i < instancesLength; ++i) {\n    classId = classIds[i];\n    classIndexes[i] = classCounts[classId];\n    ++classCounts[classId];\n  }\n\n  var hierarchy = {\n    classes: classes,\n    classIds: classIds,\n    classIndexes: classIndexes,\n    parentCounts: parentCounts,\n    parentIndexes: parentIndexes,\n    parentIds: parentIds\n  }; //>>includeStart('debug', pragmas.debug);\n\n  validateHierarchy(hierarchy); //>>includeEnd('debug');\n\n  return hierarchy;\n} //>>includeStart('debug', pragmas.debug);\n\n\nvar scratchValidateStack = [];\n\nfunction validateHierarchy(hierarchy) {\n  var stack = scratchValidateStack;\n  stack.length = 0;\n  var classIds = hierarchy.classIds;\n  var instancesLength = classIds.length;\n\n  for (var i = 0; i < instancesLength; ++i) {\n    validateInstance(hierarchy, i, stack);\n  }\n}\n\nfunction validateInstance(hierarchy, instanceIndex, stack) {\n  var parentCounts = hierarchy.parentCounts;\n  var parentIds = hierarchy.parentIds;\n  var parentIndexes = hierarchy.parentIndexes;\n  var classIds = hierarchy.classIds;\n  var instancesLength = classIds.length;\n\n  if (!defined(parentIds)) {\n    // No need to validate if there are no parents\n    return;\n  }\n\n  if (instanceIndex >= instancesLength) {\n    throw new DeveloperError(\"Parent index \" + instanceIndex + \" exceeds the total number of instances: \" + instancesLength);\n  }\n\n  if (stack.indexOf(instanceIndex) > -1) {\n    throw new DeveloperError(\"Circular dependency detected in the batch table hierarchy.\");\n  }\n\n  stack.push(instanceIndex);\n  var parentCount = defined(parentCounts) ? parentCounts[instanceIndex] : 1;\n  var parentIndex = defined(parentCounts) ? parentIndexes[instanceIndex] : instanceIndex;\n\n  for (var i = 0; i < parentCount; ++i) {\n    var parentId = parentIds[parentIndex + i]; // Stop the traversal when the instance has no parent (its parentId equals itself), else continue the traversal.\n\n    if (parentId !== instanceIndex) {\n      validateInstance(hierarchy, parentId, stack);\n    }\n  }\n\n  stack.pop(instanceIndex);\n} //>>includeEnd('debug');\n\n\nfunction getBinaryProperties(featuresLength, properties, binaryBody) {\n  var binaryProperties;\n\n  for (var name in properties) {\n    if (properties.hasOwnProperty(name)) {\n      var property = properties[name];\n      var byteOffset = property.byteOffset;\n\n      if (defined(byteOffset)) {\n        // This is a binary property\n        var componentType = property.componentType;\n        var type = property.type;\n\n        if (!defined(componentType)) {\n          throw new RuntimeError(\"componentType is required.\");\n        }\n\n        if (!defined(type)) {\n          throw new RuntimeError(\"type is required.\");\n        }\n\n        if (!defined(binaryBody)) {\n          throw new RuntimeError(\"Property \" + name + \" requires a batch table binary.\");\n        }\n\n        var binaryAccessor = getBinaryAccessor(property);\n        var componentCount = binaryAccessor.componentsPerAttribute;\n        var classType = binaryAccessor.classType;\n        var typedArray = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + byteOffset, featuresLength);\n\n        if (!defined(binaryProperties)) {\n          binaryProperties = {};\n        } // Store any information needed to access the binary data, including the typed array,\n        // componentCount (e.g. a VEC4 would be 4), and the type used to pack and unpack (e.g. Cartesian4).\n\n\n        binaryProperties[name] = {\n          typedArray: typedArray,\n          componentCount: componentCount,\n          type: classType\n        };\n      }\n    }\n  }\n\n  return binaryProperties;\n}\n\nCesium3DTileBatchTable.getBinaryProperties = function (featuresLength, batchTableJson, batchTableBinary) {\n  return getBinaryProperties(featuresLength, batchTableJson, batchTableBinary);\n};\n\nfunction getByteLength(batchTable) {\n  var dimensions = batchTable._textureDimensions;\n  return dimensions.x * dimensions.y * 4;\n}\n\nfunction getBatchValues(batchTable) {\n  if (!defined(batchTable._batchValues)) {\n    // Default batch texture to RGBA = 255: white highlight (RGB) and show/alpha = true/255 (A).\n    var byteLength = getByteLength(batchTable);\n    var bytes = new Uint8Array(byteLength);\n    arrayFill(bytes, 255);\n    batchTable._batchValues = bytes;\n  }\n\n  return batchTable._batchValues;\n}\n\nfunction getShowAlphaProperties(batchTable) {\n  if (!defined(batchTable._showAlphaProperties)) {\n    var byteLength = 2 * batchTable.featuresLength;\n    var bytes = new Uint8Array(byteLength); // [Show = true, Alpha = 255]\n\n    arrayFill(bytes, 255);\n    batchTable._showAlphaProperties = bytes;\n  }\n\n  return batchTable._showAlphaProperties;\n}\n\nfunction checkBatchId(batchId, featuresLength) {\n  if (!defined(batchId) || batchId < 0 || batchId > featuresLength) {\n    throw new DeveloperError(\"batchId is required and between zero and featuresLength - 1 (\" + featuresLength - +\").\");\n  }\n}\n\nCesium3DTileBatchTable.prototype.setShow = function (batchId, show) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  Check.typeOf.bool(\"show\", show); //>>includeEnd('debug');\n\n  if (show && !defined(this._showAlphaProperties)) {\n    // Avoid allocating since the default is show = true\n    return;\n  }\n\n  var showAlphaProperties = getShowAlphaProperties(this);\n  var propertyOffset = batchId * 2;\n  var newShow = show ? 255 : 0;\n\n  if (showAlphaProperties[propertyOffset] !== newShow) {\n    showAlphaProperties[propertyOffset] = newShow;\n    var batchValues = getBatchValues(this); // Compute alpha used in the shader based on show and color.alpha properties\n\n    var offset = batchId * 4 + 3;\n    batchValues[offset] = show ? showAlphaProperties[propertyOffset + 1] : 0;\n    this._batchValuesDirty = true;\n  }\n};\n\nCesium3DTileBatchTable.prototype.setAllShow = function (show) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bool(\"show\", show); //>>includeEnd('debug');\n\n  var featuresLength = this.featuresLength;\n\n  for (var i = 0; i < featuresLength; ++i) {\n    this.setShow(i, show);\n  }\n};\n\nCesium3DTileBatchTable.prototype.getShow = function (batchId) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength); //>>includeEnd('debug');\n\n  if (!defined(this._showAlphaProperties)) {\n    // Avoid allocating since the default is show = true\n    return true;\n  }\n\n  var offset = batchId * 2;\n  return this._showAlphaProperties[offset] === 255;\n};\n\nvar scratchColorBytes = new Array(4);\n\nCesium3DTileBatchTable.prototype.setColor = function (batchId, color) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  Check.typeOf.object(\"color\", color); //>>includeEnd('debug');\n\n  if (Color.equals(color, DEFAULT_COLOR_VALUE) && !defined(this._batchValues)) {\n    // Avoid allocating since the default is white\n    return;\n  }\n\n  var newColor = color.toBytes(scratchColorBytes);\n  var newAlpha = newColor[3];\n  var batchValues = getBatchValues(this);\n  var offset = batchId * 4;\n  var showAlphaProperties = getShowAlphaProperties(this);\n  var propertyOffset = batchId * 2;\n\n  if (batchValues[offset] !== newColor[0] || batchValues[offset + 1] !== newColor[1] || batchValues[offset + 2] !== newColor[2] || showAlphaProperties[propertyOffset + 1] !== newAlpha) {\n    batchValues[offset] = newColor[0];\n    batchValues[offset + 1] = newColor[1];\n    batchValues[offset + 2] = newColor[2];\n    var wasTranslucent = showAlphaProperties[propertyOffset + 1] !== 255; // Compute alpha used in the shader based on show and color.alpha properties\n\n    var show = showAlphaProperties[propertyOffset] !== 0;\n    batchValues[offset + 3] = show ? newAlpha : 0;\n    showAlphaProperties[propertyOffset + 1] = newAlpha; // Track number of translucent features so we know if this tile needs\n    // opaque commands, translucent commands, or both for rendering.\n\n    var isTranslucent = newAlpha !== 255;\n\n    if (isTranslucent && !wasTranslucent) {\n      ++this._translucentFeaturesLength;\n    } else if (!isTranslucent && wasTranslucent) {\n      --this._translucentFeaturesLength;\n    }\n\n    this._batchValuesDirty = true;\n\n    if (defined(this._colorChangedCallback)) {\n      this._colorChangedCallback(batchId, color);\n    }\n  }\n};\n\nCesium3DTileBatchTable.prototype.setAllColor = function (color) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"color\", color); //>>includeEnd('debug');\n\n  var featuresLength = this.featuresLength;\n\n  for (var i = 0; i < featuresLength; ++i) {\n    this.setColor(i, color);\n  }\n};\n\nCesium3DTileBatchTable.prototype.getColor = function (batchId, result) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  if (!defined(this._batchValues)) {\n    return Color.clone(DEFAULT_COLOR_VALUE, result);\n  }\n\n  var batchValues = this._batchValues;\n  var offset = batchId * 4;\n  var showAlphaProperties = this._showAlphaProperties;\n  var propertyOffset = batchId * 2;\n  return Color.fromBytes(batchValues[offset], batchValues[offset + 1], batchValues[offset + 2], showAlphaProperties[propertyOffset + 1], result);\n};\n\nCesium3DTileBatchTable.prototype.getPickColor = function (batchId) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength); //>>includeEnd('debug');\n\n  return this._pickIds[batchId];\n};\n\nvar scratchColor = new Color();\n\nCesium3DTileBatchTable.prototype.applyStyle = function (style) {\n  if (!defined(style)) {\n    this.setAllColor(DEFAULT_COLOR_VALUE);\n    this.setAllShow(DEFAULT_SHOW_VALUE);\n    return;\n  }\n\n  var content = this._content;\n  var length = this.featuresLength;\n\n  for (var i = 0; i < length; ++i) {\n    var feature = content.getFeature(i);\n    var color = defined(style.color) ? style.color.evaluateColor(feature, scratchColor) : DEFAULT_COLOR_VALUE;\n    var show = defined(style.show) ? style.show.evaluate(feature) : DEFAULT_SHOW_VALUE;\n    this.setColor(i, color);\n    this.setShow(i, show);\n  }\n};\n\nfunction getBinaryProperty(binaryProperty, index) {\n  var typedArray = binaryProperty.typedArray;\n  var componentCount = binaryProperty.componentCount;\n\n  if (componentCount === 1) {\n    return typedArray[index];\n  }\n\n  return binaryProperty.type.unpack(typedArray, index * componentCount);\n}\n\nfunction setBinaryProperty(binaryProperty, index, value) {\n  var typedArray = binaryProperty.typedArray;\n  var componentCount = binaryProperty.componentCount;\n\n  if (componentCount === 1) {\n    typedArray[index] = value;\n  } else {\n    binaryProperty.type.pack(value, typedArray, index * componentCount);\n  }\n} // The size of this array equals the maximum instance count among all loaded tiles, which has the potential to be large.\n\n\nvar scratchVisited = [];\nvar scratchStack = [];\nvar marker = 0;\n\nfunction traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback) {\n  var classIds = hierarchy.classIds;\n  var parentCounts = hierarchy.parentCounts;\n  var parentIds = hierarchy.parentIds;\n  var parentIndexes = hierarchy.parentIndexes;\n  var instancesLength = classIds.length; // Ignore instances that have already been visited. This occurs in diamond inheritance situations.\n  // Use a marker value to indicate that an instance has been visited, which increments with each run.\n  // This is more efficient than clearing the visited array every time.\n\n  var visited = scratchVisited;\n  visited.length = Math.max(visited.length, instancesLength);\n  var visitedMarker = ++marker;\n  var stack = scratchStack;\n  stack.length = 0;\n  stack.push(instanceIndex);\n\n  while (stack.length > 0) {\n    instanceIndex = stack.pop();\n\n    if (visited[instanceIndex] === visitedMarker) {\n      // This instance has already been visited, stop traversal\n      continue;\n    }\n\n    visited[instanceIndex] = visitedMarker;\n    var result = endConditionCallback(hierarchy, instanceIndex);\n\n    if (defined(result)) {\n      // The end condition was met, stop the traversal and return the result\n      return result;\n    }\n\n    var parentCount = parentCounts[instanceIndex];\n    var parentIndex = parentIndexes[instanceIndex];\n\n    for (var i = 0; i < parentCount; ++i) {\n      var parentId = parentIds[parentIndex + i]; // Stop the traversal when the instance has no parent (its parentId equals itself)\n      // else add the parent to the stack to continue the traversal.\n\n      if (parentId !== instanceIndex) {\n        stack.push(parentId);\n      }\n    }\n  }\n}\n\nfunction traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback) {\n  var hasParent = true;\n\n  while (hasParent) {\n    var result = endConditionCallback(hierarchy, instanceIndex);\n\n    if (defined(result)) {\n      // The end condition was met, stop the traversal and return the result\n      return result;\n    }\n\n    var parentId = hierarchy.parentIds[instanceIndex];\n    hasParent = parentId !== instanceIndex;\n    instanceIndex = parentId;\n  }\n}\n\nfunction traverseHierarchy(hierarchy, instanceIndex, endConditionCallback) {\n  // Traverse over the hierarchy and process each instance with the endConditionCallback.\n  // When the endConditionCallback returns a value, the traversal stops and that value is returned.\n  var parentCounts = hierarchy.parentCounts;\n  var parentIds = hierarchy.parentIds;\n\n  if (!defined(parentIds)) {\n    return endConditionCallback(hierarchy, instanceIndex);\n  } else if (defined(parentCounts)) {\n    return traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback);\n  }\n\n  return traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback);\n}\n\nfunction hasPropertyInHierarchy(batchTable, batchId, name) {\n  var hierarchy = batchTable._batchTableHierarchy;\n  var result = traverseHierarchy(hierarchy, batchId, function (hierarchy, instanceIndex) {\n    var classId = hierarchy.classIds[instanceIndex];\n    var instances = hierarchy.classes[classId].instances;\n\n    if (defined(instances[name])) {\n      return true;\n    }\n  });\n  return defined(result);\n}\n\nfunction getPropertyNamesInHierarchy(batchTable, batchId, results) {\n  var hierarchy = batchTable._batchTableHierarchy;\n  traverseHierarchy(hierarchy, batchId, function (hierarchy, instanceIndex) {\n    var classId = hierarchy.classIds[instanceIndex];\n    var instances = hierarchy.classes[classId].instances;\n\n    for (var name in instances) {\n      if (instances.hasOwnProperty(name)) {\n        if (results.indexOf(name) === -1) {\n          results.push(name);\n        }\n      }\n    }\n  });\n}\n\nfunction getHierarchyProperty(batchTable, batchId, name) {\n  var hierarchy = batchTable._batchTableHierarchy;\n  return traverseHierarchy(hierarchy, batchId, function (hierarchy, instanceIndex) {\n    var classId = hierarchy.classIds[instanceIndex];\n    var instanceClass = hierarchy.classes[classId];\n    var indexInClass = hierarchy.classIndexes[instanceIndex];\n    var propertyValues = instanceClass.instances[name];\n\n    if (defined(propertyValues)) {\n      if (defined(propertyValues.typedArray)) {\n        return getBinaryProperty(propertyValues, indexInClass);\n      }\n\n      return clone(propertyValues[indexInClass], true);\n    }\n  });\n}\n\nfunction setHierarchyProperty(batchTable, batchId, name, value) {\n  var hierarchy = batchTable._batchTableHierarchy;\n  var result = traverseHierarchy(hierarchy, batchId, function (hierarchy, instanceIndex) {\n    var classId = hierarchy.classIds[instanceIndex];\n    var instanceClass = hierarchy.classes[classId];\n    var indexInClass = hierarchy.classIndexes[instanceIndex];\n    var propertyValues = instanceClass.instances[name];\n\n    if (defined(propertyValues)) {\n      //>>includeStart('debug', pragmas.debug);\n      if (instanceIndex !== batchId) {\n        throw new DeveloperError('Inherited property \"' + name + '\" is read-only.');\n      } //>>includeEnd('debug');\n\n\n      if (defined(propertyValues.typedArray)) {\n        setBinaryProperty(propertyValues, indexInClass, value);\n      } else {\n        propertyValues[indexInClass] = clone(value, true);\n      }\n\n      return true;\n    }\n  });\n  return defined(result);\n}\n\nCesium3DTileBatchTable.prototype.isClass = function (batchId, className) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  Check.typeOf.string(\"className\", className); //>>includeEnd('debug');\n  // PERFORMANCE_IDEA : cache results in the ancestor classes to speed up this check if this area becomes a hotspot\n\n  var hierarchy = this._batchTableHierarchy;\n\n  if (!defined(hierarchy)) {\n    return false;\n  } // PERFORMANCE_IDEA : treat class names as integers for faster comparisons\n\n\n  var result = traverseHierarchy(hierarchy, batchId, function (hierarchy, instanceIndex) {\n    var classId = hierarchy.classIds[instanceIndex];\n    var instanceClass = hierarchy.classes[classId];\n\n    if (instanceClass.name === className) {\n      return true;\n    }\n  });\n  return defined(result);\n};\n\nCesium3DTileBatchTable.prototype.isExactClass = function (batchId, className) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"className\", className); //>>includeEnd('debug');\n\n  return this.getExactClassName(batchId) === className;\n};\n\nCesium3DTileBatchTable.prototype.getExactClassName = function (batchId) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength); //>>includeEnd('debug');\n\n  var hierarchy = this._batchTableHierarchy;\n\n  if (!defined(hierarchy)) {\n    return undefined;\n  }\n\n  var classId = hierarchy.classIds[batchId];\n  var instanceClass = hierarchy.classes[classId];\n  return instanceClass.name;\n};\n\nCesium3DTileBatchTable.prototype.hasProperty = function (batchId, name) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  Check.typeOf.string(\"name\", name); //>>includeEnd('debug');\n\n  return defined(this._properties[name]) || defined(this._batchTableHierarchy) && hasPropertyInHierarchy(this, batchId, name);\n};\n\nCesium3DTileBatchTable.prototype.getPropertyNames = function (batchId, results) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength); //>>includeEnd('debug');\n\n  results = defined(results) ? results : [];\n  results.length = 0;\n  var propertyNames = Object.keys(this._properties);\n  results.push.apply(results, propertyNames);\n\n  if (defined(this._batchTableHierarchy)) {\n    getPropertyNamesInHierarchy(this, batchId, results);\n  }\n\n  return results;\n};\n\nCesium3DTileBatchTable.prototype.getProperty = function (batchId, name) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  Check.typeOf.string(\"name\", name); //>>includeEnd('debug');\n\n  if (defined(this._batchTableBinaryProperties)) {\n    var binaryProperty = this._batchTableBinaryProperties[name];\n\n    if (defined(binaryProperty)) {\n      return getBinaryProperty(binaryProperty, batchId);\n    }\n  }\n\n  var propertyValues = this._properties[name];\n\n  if (defined(propertyValues)) {\n    return clone(propertyValues[batchId], true);\n  }\n\n  if (defined(this._batchTableHierarchy)) {\n    var hierarchyProperty = getHierarchyProperty(this, batchId, name);\n\n    if (defined(hierarchyProperty)) {\n      return hierarchyProperty;\n    }\n  }\n\n  return undefined;\n};\n\nCesium3DTileBatchTable.prototype.setProperty = function (batchId, name, value) {\n  var featuresLength = this.featuresLength; //>>includeStart('debug', pragmas.debug);\n\n  checkBatchId(batchId, featuresLength);\n  Check.typeOf.string(\"name\", name); //>>includeEnd('debug');\n\n  if (defined(this._batchTableBinaryProperties)) {\n    var binaryProperty = this._batchTableBinaryProperties[name];\n\n    if (defined(binaryProperty)) {\n      setBinaryProperty(binaryProperty, batchId, value);\n      return;\n    }\n  }\n\n  if (defined(this._batchTableHierarchy)) {\n    if (setHierarchyProperty(this, batchId, name, value)) {\n      return;\n    }\n  }\n\n  var propertyValues = this._properties[name];\n\n  if (!defined(propertyValues)) {\n    // Property does not exist. Create it.\n    this._properties[name] = new Array(featuresLength);\n    propertyValues = this._properties[name];\n  }\n\n  propertyValues[batchId] = clone(value, true);\n};\n\nfunction getGlslComputeSt(batchTable) {\n  // GLSL batchId is zero-based: [0, featuresLength - 1]\n  if (batchTable._textureDimensions.y === 1) {\n    return \"uniform vec4 tile_textureStep; \\n\" + \"vec2 computeSt(float batchId) \\n\" + \"{ \\n\" + \"    float stepX = tile_textureStep.x; \\n\" + \"    float centerX = tile_textureStep.y; \\n\" + \"    return vec2(centerX + (batchId * stepX), 0.5); \\n\" + \"} \\n\";\n  }\n\n  return \"uniform vec4 tile_textureStep; \\n\" + \"uniform vec2 tile_textureDimensions; \\n\" + \"vec2 computeSt(float batchId) \\n\" + \"{ \\n\" + \"    float stepX = tile_textureStep.x; \\n\" + \"    float centerX = tile_textureStep.y; \\n\" + \"    float stepY = tile_textureStep.z; \\n\" + \"    float centerY = tile_textureStep.w; \\n\" + \"    float xId = mod(batchId, tile_textureDimensions.x); \\n\" + \"    float yId = floor(batchId / tile_textureDimensions.x); \\n\" + \"    return vec2(centerX + (xId * stepX), centerY + (yId * stepY)); \\n\" + \"} \\n\";\n}\n\nCesium3DTileBatchTable.prototype.getVertexShaderCallback = function (handleTranslucent, batchIdAttributeName, diffuseAttributeOrUniformName) {\n  if (this.featuresLength === 0) {\n    return;\n  }\n\n  var that = this;\n  return function (source) {\n    // If the color blend mode is HIGHLIGHT, the highlight color will always be applied in the fragment shader.\n    // No need to apply the highlight color in the vertex shader as well.\n    var renamedSource = modifyDiffuse(source, diffuseAttributeOrUniformName, false);\n    var newMain;\n\n    if (ContextLimits.maximumVertexTextureImageUnits > 0) {\n      // When VTF is supported, perform per-feature show/hide in the vertex shader\n      newMain = \"\";\n\n      if (handleTranslucent) {\n        newMain += \"uniform bool tile_translucentCommand; \\n\";\n      }\n\n      newMain += \"uniform sampler2D tile_batchTexture; \\n\" + \"varying vec4 tile_featureColor; \\n\" + \"varying vec2 tile_featureSt; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    vec2 st = computeSt(\" + batchIdAttributeName + \"); \\n\" + \"    vec4 featureProperties = texture2D(tile_batchTexture, st); \\n\" + \"    tile_color(featureProperties); \\n\" + \"    float show = ceil(featureProperties.a); \\n\" + // 0 - false, non-zeo - true\n      \"    gl_Position *= show; \\n\"; // Per-feature show/hide\n\n      if (handleTranslucent) {\n        newMain += \"    bool isStyleTranslucent = (featureProperties.a != 1.0); \\n\" + \"    if (czm_pass == czm_passTranslucent) \\n\" + \"    { \\n\" + \"        if (!isStyleTranslucent && !tile_translucentCommand) \\n\" + // Do not render opaque features in the translucent pass\n        \"        { \\n\" + \"            gl_Position *= 0.0; \\n\" + \"        } \\n\" + \"    } \\n\" + \"    else \\n\" + \"    { \\n\" + \"        if (isStyleTranslucent) \\n\" + // Do not render translucent features in the opaque pass\n        \"        { \\n\" + \"            gl_Position *= 0.0; \\n\" + \"        } \\n\" + \"    } \\n\";\n      }\n\n      newMain += \"    tile_featureColor = featureProperties; \\n\" + \"    tile_featureSt = st; \\n\" + \"}\";\n    } else {\n      // When VTF is not supported, color blend mode MIX will look incorrect due to the feature's color not being available in the vertex shader\n      newMain = \"varying vec2 tile_featureSt; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    tile_color(vec4(1.0)); \\n\" + \"    tile_featureSt = computeSt(\" + batchIdAttributeName + \"); \\n\" + \"}\";\n    }\n\n    return renamedSource + \"\\n\" + getGlslComputeSt(that) + newMain;\n  };\n};\n\nfunction getDefaultShader(source, applyHighlight) {\n  source = ShaderSource.replaceMain(source, \"tile_main\");\n\n  if (!applyHighlight) {\n    return source + \"void tile_color(vec4 tile_featureColor) \\n\" + \"{ \\n\" + \"    tile_main(); \\n\" + \"} \\n\";\n  } // The color blend mode is intended for the RGB channels so alpha is always just multiplied.\n  // gl_FragColor is multiplied by the tile color only when tile_colorBlend is 0.0 (highlight)\n\n\n  return source + \"uniform float tile_colorBlend; \\n\" + \"void tile_color(vec4 tile_featureColor) \\n\" + \"{ \\n\" + \"    tile_main(); \\n\" + \"    tile_featureColor = czm_gammaCorrect(tile_featureColor); \\n\" + \"    gl_FragColor.a *= tile_featureColor.a; \\n\" + \"    float highlight = ceil(tile_colorBlend); \\n\" + \"    gl_FragColor.rgb *= mix(tile_featureColor.rgb, vec3(1.0), highlight); \\n\" + \"} \\n\";\n}\n\nfunction replaceDiffuseTextureCalls(source, diffuseAttributeOrUniformName) {\n  var functionCall = \"texture2D(\" + diffuseAttributeOrUniformName;\n  var fromIndex = 0;\n  var startIndex = source.indexOf(functionCall, fromIndex);\n  var endIndex;\n\n  while (startIndex > -1) {\n    var nestedLevel = 0;\n\n    for (var i = startIndex; i < source.length; ++i) {\n      var character = source.charAt(i);\n\n      if (character === \"(\") {\n        ++nestedLevel;\n      } else if (character === \")\") {\n        --nestedLevel;\n\n        if (nestedLevel === 0) {\n          endIndex = i + 1;\n          break;\n        }\n      }\n    }\n\n    var extractedFunction = source.slice(startIndex, endIndex);\n    var replacedFunction = \"tile_diffuse_final(\" + extractedFunction + \", tile_diffuse)\";\n    source = source.slice(0, startIndex) + replacedFunction + source.slice(endIndex);\n    fromIndex = startIndex + replacedFunction.length;\n    startIndex = source.indexOf(functionCall, fromIndex);\n  }\n\n  return source;\n}\n\nfunction modifyDiffuse(source, diffuseAttributeOrUniformName, applyHighlight) {\n  // If the glTF does not specify the _3DTILESDIFFUSE semantic, return the default shader.\n  // Otherwise if _3DTILESDIFFUSE is defined prefer the shader below that can switch the color mode at runtime.\n  if (!defined(diffuseAttributeOrUniformName)) {\n    return getDefaultShader(source, applyHighlight);\n  } // Find the diffuse uniform. Examples matches:\n  //   uniform vec3 u_diffuseColor;\n  //   uniform sampler2D diffuseTexture;\n\n\n  var regex = new RegExp(\"(uniform|attribute|in)\\\\s+(vec[34]|sampler2D)\\\\s+\" + diffuseAttributeOrUniformName + \";\");\n  var uniformMatch = source.match(regex);\n\n  if (!defined(uniformMatch)) {\n    // Could not find uniform declaration of type vec3, vec4, or sampler2D\n    return getDefaultShader(source, applyHighlight);\n  }\n\n  var declaration = uniformMatch[0];\n  var type = uniformMatch[2];\n  source = ShaderSource.replaceMain(source, \"tile_main\");\n  source = source.replace(declaration, \"\"); // Remove uniform declaration for now so the replace below doesn't affect it\n  // If the tile color is white, use the source color. This implies the feature has not been styled.\n  // Highlight: tile_colorBlend is 0.0 and the source color is used\n  // Replace: tile_colorBlend is 1.0 and the tile color is used\n  // Mix: tile_colorBlend is between 0.0 and 1.0, causing the source color and tile color to mix\n\n  var finalDiffuseFunction = \"bool isWhite(vec3 color) \\n\" + \"{ \\n\" + \"    return all(greaterThan(color, vec3(1.0 - czm_epsilon3))); \\n\" + \"} \\n\" + \"vec4 tile_diffuse_final(vec4 sourceDiffuse, vec4 tileDiffuse) \\n\" + \"{ \\n\" + \"    vec4 blendDiffuse = mix(sourceDiffuse, tileDiffuse, tile_colorBlend); \\n\" + \"    vec4 diffuse = isWhite(tileDiffuse.rgb) ? sourceDiffuse : blendDiffuse; \\n\" + \"    return vec4(diffuse.rgb, sourceDiffuse.a); \\n\" + \"} \\n\"; // The color blend mode is intended for the RGB channels so alpha is always just multiplied.\n  // gl_FragColor is multiplied by the tile color only when tile_colorBlend is 0.0 (highlight)\n\n  var highlight = \"    tile_featureColor = czm_gammaCorrect(tile_featureColor); \\n\" + \"    gl_FragColor.a *= tile_featureColor.a; \\n\" + \"    float highlight = ceil(tile_colorBlend); \\n\" + \"    gl_FragColor.rgb *= mix(tile_featureColor.rgb, vec3(1.0), highlight); \\n\";\n  var setColor;\n\n  if (type === \"vec3\" || type === \"vec4\") {\n    var sourceDiffuse = type === \"vec3\" ? \"vec4(\" + diffuseAttributeOrUniformName + \", 1.0)\" : diffuseAttributeOrUniformName;\n    var replaceDiffuse = type === \"vec3\" ? \"tile_diffuse.xyz\" : \"tile_diffuse\";\n    regex = new RegExp(diffuseAttributeOrUniformName, \"g\");\n    source = source.replace(regex, replaceDiffuse);\n    setColor = \"    vec4 source = \" + sourceDiffuse + \"; \\n\" + \"    tile_diffuse = tile_diffuse_final(source, tile_featureColor); \\n\" + \"    tile_main(); \\n\";\n  } else if (type === \"sampler2D\") {\n    // Handles any number of nested parentheses\n    // E.g. texture2D(u_diffuse, uv)\n    // E.g. texture2D(u_diffuse, computeUV(index))\n    source = replaceDiffuseTextureCalls(source, diffuseAttributeOrUniformName);\n    setColor = \"    tile_diffuse = tile_featureColor; \\n\" + \"    tile_main(); \\n\";\n  }\n\n  source = \"uniform float tile_colorBlend; \\n\" + \"vec4 tile_diffuse = vec4(1.0); \\n\" + finalDiffuseFunction + declaration + \"\\n\" + source + \"\\n\" + \"void tile_color(vec4 tile_featureColor) \\n\" + \"{ \\n\" + setColor;\n\n  if (applyHighlight) {\n    source += highlight;\n  }\n\n  source += \"} \\n\";\n  return source;\n}\n\nCesium3DTileBatchTable.prototype.getFragmentShaderCallback = function (handleTranslucent, diffuseAttributeOrUniformName) {\n  if (this.featuresLength === 0) {\n    return;\n  }\n\n  return function (source) {\n    source = modifyDiffuse(source, diffuseAttributeOrUniformName, true);\n\n    if (ContextLimits.maximumVertexTextureImageUnits > 0) {\n      // When VTF is supported, per-feature show/hide already happened in the fragment shader\n      source += \"uniform sampler2D tile_pickTexture; \\n\" + \"varying vec2 tile_featureSt; \\n\" + \"varying vec4 tile_featureColor; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    tile_color(tile_featureColor); \\n\" + \"}\";\n    } else {\n      if (handleTranslucent) {\n        source += \"uniform bool tile_translucentCommand; \\n\";\n      }\n\n      source += \"uniform sampler2D tile_pickTexture; \\n\" + \"uniform sampler2D tile_batchTexture; \\n\" + \"varying vec2 tile_featureSt; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    vec4 featureProperties = texture2D(tile_batchTexture, tile_featureSt); \\n\" + \"    if (featureProperties.a == 0.0) { \\n\" + // show: alpha == 0 - false, non-zeo - true\n      \"        discard; \\n\" + \"    } \\n\";\n\n      if (handleTranslucent) {\n        source += \"    bool isStyleTranslucent = (featureProperties.a != 1.0); \\n\" + \"    if (czm_pass == czm_passTranslucent) \\n\" + \"    { \\n\" + \"        if (!isStyleTranslucent && !tile_translucentCommand) \\n\" + // Do not render opaque features in the translucent pass\n        \"        { \\n\" + \"            discard; \\n\" + \"        } \\n\" + \"    } \\n\" + \"    else \\n\" + \"    { \\n\" + \"        if (isStyleTranslucent) \\n\" + // Do not render translucent features in the opaque pass\n        \"        { \\n\" + \"            discard; \\n\" + \"        } \\n\" + \"    } \\n\";\n      }\n\n      source += \"    tile_color(featureProperties); \\n\" + \"} \\n\";\n    }\n\n    return source;\n  };\n};\n\nCesium3DTileBatchTable.prototype.getClassificationFragmentShaderCallback = function () {\n  if (this.featuresLength === 0) {\n    return;\n  }\n\n  return function (source) {\n    source = ShaderSource.replaceMain(source, \"tile_main\");\n\n    if (ContextLimits.maximumVertexTextureImageUnits > 0) {\n      // When VTF is supported, per-feature show/hide already happened in the fragment shader\n      source += \"uniform sampler2D tile_pickTexture;\\n\" + \"varying vec2 tile_featureSt; \\n\" + \"varying vec4 tile_featureColor; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    tile_main(); \\n\" + \"    gl_FragColor = tile_featureColor; \\n\" + \"}\";\n    } else {\n      source += \"uniform sampler2D tile_batchTexture; \\n\" + \"uniform sampler2D tile_pickTexture;\\n\" + \"varying vec2 tile_featureSt; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    tile_main(); \\n\" + \"    vec4 featureProperties = texture2D(tile_batchTexture, tile_featureSt); \\n\" + \"    if (featureProperties.a == 0.0) { \\n\" + // show: alpha == 0 - false, non-zeo - true\n      \"        discard; \\n\" + \"    } \\n\" + \"    gl_FragColor = featureProperties; \\n\" + \"} \\n\";\n    }\n\n    return source;\n  };\n};\n\nfunction getColorBlend(batchTable) {\n  var tileset = batchTable._content.tileset;\n  var colorBlendMode = tileset.colorBlendMode;\n  var colorBlendAmount = tileset.colorBlendAmount;\n\n  if (colorBlendMode === Cesium3DTileColorBlendMode.HIGHLIGHT) {\n    return 0.0;\n  }\n\n  if (colorBlendMode === Cesium3DTileColorBlendMode.REPLACE) {\n    return 1.0;\n  }\n\n  if (colorBlendMode === Cesium3DTileColorBlendMode.MIX) {\n    // The value 0.0 is reserved for highlight, so clamp to just above 0.0.\n    return CesiumMath.clamp(colorBlendAmount, CesiumMath.EPSILON4, 1.0);\n  } //>>includeStart('debug', pragmas.debug);\n\n\n  throw new DeveloperError('Invalid color blend mode \"' + colorBlendMode + '\".'); //>>includeEnd('debug');\n}\n\nCesium3DTileBatchTable.prototype.getUniformMapCallback = function () {\n  if (this.featuresLength === 0) {\n    return;\n  }\n\n  var that = this;\n  return function (uniformMap) {\n    var batchUniformMap = {\n      tile_batchTexture: function tile_batchTexture() {\n        // PERFORMANCE_IDEA: we could also use a custom shader that avoids the texture read.\n        return defaultValue(that._batchTexture, that._defaultTexture);\n      },\n      tile_textureDimensions: function tile_textureDimensions() {\n        return that._textureDimensions;\n      },\n      tile_textureStep: function tile_textureStep() {\n        return that._textureStep;\n      },\n      tile_colorBlend: function tile_colorBlend() {\n        return getColorBlend(that);\n      },\n      tile_pickTexture: function tile_pickTexture() {\n        return that._pickTexture;\n      }\n    };\n    return combine(uniformMap, batchUniformMap);\n  };\n};\n\nCesium3DTileBatchTable.prototype.getPickId = function () {\n  return \"texture2D(tile_pickTexture, tile_featureSt)\";\n}; ///////////////////////////////////////////////////////////////////////////\n\n\nvar StyleCommandsNeeded = {\n  ALL_OPAQUE: 0,\n  ALL_TRANSLUCENT: 1,\n  OPAQUE_AND_TRANSLUCENT: 2\n};\n\nCesium3DTileBatchTable.prototype.addDerivedCommands = function (frameState, commandStart) {\n  var commandList = frameState.commandList;\n  var commandEnd = commandList.length;\n  var tile = this._content._tile;\n  var finalResolution = tile._finalResolution;\n  var tileset = tile.tileset;\n  var bivariateVisibilityTest = tileset._skipLevelOfDetail && tileset._hasMixedContent && frameState.context.stencilBuffer;\n  var styleCommandsNeeded = getStyleCommandsNeeded(this);\n\n  for (var i = commandStart; i < commandEnd; ++i) {\n    var command = commandList[i];\n    var derivedCommands = command.derivedCommands.tileset;\n\n    if (!defined(derivedCommands) || command.dirty) {\n      derivedCommands = {};\n      command.derivedCommands.tileset = derivedCommands;\n      derivedCommands.originalCommand = deriveCommand(command);\n      command.dirty = false;\n    }\n\n    var originalCommand = derivedCommands.originalCommand;\n\n    if (styleCommandsNeeded !== StyleCommandsNeeded.ALL_OPAQUE && command.pass !== Pass.TRANSLUCENT) {\n      if (!defined(derivedCommands.translucent)) {\n        derivedCommands.translucent = deriveTranslucentCommand(originalCommand);\n      }\n    }\n\n    if (styleCommandsNeeded !== StyleCommandsNeeded.ALL_TRANSLUCENT && command.pass !== Pass.TRANSLUCENT) {\n      if (!defined(derivedCommands.opaque)) {\n        derivedCommands.opaque = deriveOpaqueCommand(originalCommand);\n      }\n\n      if (bivariateVisibilityTest) {\n        if (!finalResolution) {\n          if (!defined(derivedCommands.zback)) {\n            derivedCommands.zback = deriveZBackfaceCommand(frameState.context, originalCommand);\n          }\n\n          tileset._backfaceCommands.push(derivedCommands.zback);\n        }\n\n        if (!defined(derivedCommands.stencil) || tile._selectionDepth !== getLastSelectionDepth(derivedCommands.stencil)) {\n          if (command.renderState.depthMask) {\n            derivedCommands.stencil = deriveStencilCommand(originalCommand, tile._selectionDepth);\n          } else {\n            // Ignore if tile does not write depth\n            derivedCommands.stencil = derivedCommands.opaque;\n          }\n        }\n      }\n    }\n\n    var opaqueCommand = bivariateVisibilityTest ? derivedCommands.stencil : derivedCommands.opaque;\n    var translucentCommand = derivedCommands.translucent; // If the command was originally opaque:\n    //    * If the styling applied to the tile is all opaque, use the opaque command\n    //      (with one additional uniform needed for the shader).\n    //    * If the styling is all translucent, use new (cached) derived commands (front\n    //      and back faces) with a translucent render state.\n    //    * If the styling causes both opaque and translucent features in this tile,\n    //      then use both sets of commands.\n\n    if (command.pass !== Pass.TRANSLUCENT) {\n      if (styleCommandsNeeded === StyleCommandsNeeded.ALL_OPAQUE) {\n        commandList[i] = opaqueCommand;\n      }\n\n      if (styleCommandsNeeded === StyleCommandsNeeded.ALL_TRANSLUCENT) {\n        commandList[i] = translucentCommand;\n      }\n\n      if (styleCommandsNeeded === StyleCommandsNeeded.OPAQUE_AND_TRANSLUCENT) {\n        // PERFORMANCE_IDEA: if the tile has multiple commands, we do not know what features are in what\n        // commands so this case may be overkill.\n        commandList[i] = opaqueCommand;\n        commandList.push(translucentCommand);\n      }\n    } else {\n      // Command was originally translucent so no need to derive new commands;\n      // as of now, a style can't change an originally translucent feature to\n      // opaque since the style's alpha is modulated, not a replacement.  When\n      // this changes, we need to derive new opaque commands here.\n      commandList[i] = originalCommand;\n    }\n  }\n};\n\nfunction getStyleCommandsNeeded(batchTable) {\n  var translucentFeaturesLength = batchTable._translucentFeaturesLength;\n\n  if (translucentFeaturesLength === 0) {\n    return StyleCommandsNeeded.ALL_OPAQUE;\n  } else if (translucentFeaturesLength === batchTable.featuresLength) {\n    return StyleCommandsNeeded.ALL_TRANSLUCENT;\n  }\n\n  return StyleCommandsNeeded.OPAQUE_AND_TRANSLUCENT;\n}\n\nfunction deriveCommand(command) {\n  var derivedCommand = DrawCommand.shallowClone(command); // Add a uniform to indicate if the original command was translucent so\n  // the shader knows not to cull vertices that were originally transparent\n  // even though their style is opaque.\n\n  var translucentCommand = derivedCommand.pass === Pass.TRANSLUCENT;\n  derivedCommand.uniformMap = defined(derivedCommand.uniformMap) ? derivedCommand.uniformMap : {};\n\n  derivedCommand.uniformMap.tile_translucentCommand = function () {\n    return translucentCommand;\n  };\n\n  return derivedCommand;\n}\n\nfunction deriveTranslucentCommand(command) {\n  var derivedCommand = DrawCommand.shallowClone(command);\n  derivedCommand.pass = Pass.TRANSLUCENT;\n  derivedCommand.renderState = getTranslucentRenderState(command.renderState);\n  return derivedCommand;\n}\n\nfunction deriveOpaqueCommand(command) {\n  var derivedCommand = DrawCommand.shallowClone(command);\n  derivedCommand.renderState = getOpaqueRenderState(command.renderState);\n  return derivedCommand;\n}\n\nfunction getLogDepthPolygonOffsetFragmentShaderProgram(context, shaderProgram) {\n  var shader = context.shaderCache.getDerivedShaderProgram(shaderProgram, \"zBackfaceLogDepth\");\n\n  if (!defined(shader)) {\n    var fs = shaderProgram.fragmentShaderSource.clone();\n    fs.defines = defined(fs.defines) ? fs.defines.slice(0) : [];\n    fs.defines.push(\"POLYGON_OFFSET\");\n    fs.sources.unshift(\"#ifdef GL_OES_standard_derivatives\\n#extension GL_OES_standard_derivatives : enable\\n#endif\\n\");\n    shader = context.shaderCache.createDerivedShaderProgram(shaderProgram, \"zBackfaceLogDepth\", {\n      vertexShaderSource: shaderProgram.vertexShaderSource,\n      fragmentShaderSource: fs,\n      attributeLocations: shaderProgram._attributeLocations\n    });\n  }\n\n  return shader;\n}\n\nfunction deriveZBackfaceCommand(context, command) {\n  // Write just backface depth of unresolved tiles so resolved stenciled tiles do not appear in front\n  var derivedCommand = DrawCommand.shallowClone(command);\n  var rs = clone(derivedCommand.renderState, true);\n  rs.cull.enabled = true;\n  rs.cull.face = CullFace.FRONT; // Back faces do not need to write color.\n\n  rs.colorMask = {\n    red: false,\n    green: false,\n    blue: false,\n    alpha: false\n  }; // Push back face depth away from the camera so it is less likely that back faces and front faces of the same tile\n  // intersect and overlap. This helps avoid flickering for very thin double-sided walls.\n\n  rs.polygonOffset = {\n    enabled: true,\n    factor: 5.0,\n    units: 5.0\n  }; // Set the 3D Tiles bit\n\n  rs.stencilTest = StencilConstants.setCesium3DTileBit();\n  rs.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK;\n  derivedCommand.renderState = RenderState.fromCache(rs);\n  derivedCommand.castShadows = false;\n  derivedCommand.receiveShadows = false;\n  derivedCommand.uniformMap = clone(command.uniformMap);\n  var polygonOffset = new Cartesian2(5.0, 5.0);\n\n  derivedCommand.uniformMap.u_polygonOffset = function () {\n    return polygonOffset;\n  }; // Make the log depth depth fragment write account for the polygon offset, too.\n  // Otherwise, the back face commands will cause the higher resolution\n  // tiles to disappear.\n\n\n  derivedCommand.shaderProgram = getLogDepthPolygonOffsetFragmentShaderProgram(context, command.shaderProgram);\n  return derivedCommand;\n}\n\nfunction deriveStencilCommand(command, reference) {\n  // Tiles only draw if their selection depth is >= the tile drawn already. They write their\n  // selection depth to the stencil buffer to prevent ancestor tiles from drawing on top\n  var derivedCommand = DrawCommand.shallowClone(command);\n  var rs = clone(derivedCommand.renderState, true); // Stencil test is masked to the most significant 3 bits so the reference is shifted. Writes 0 for the terrain bit\n\n  rs.stencilTest.enabled = true;\n  rs.stencilTest.mask = StencilConstants.SKIP_LOD_MASK;\n  rs.stencilTest.reference = StencilConstants.CESIUM_3D_TILE_MASK | reference << StencilConstants.SKIP_LOD_BIT_SHIFT;\n  rs.stencilTest.frontFunction = StencilFunction.GREATER_OR_EQUAL;\n  rs.stencilTest.frontOperation.zPass = StencilOperation.REPLACE;\n  rs.stencilTest.backFunction = StencilFunction.GREATER_OR_EQUAL;\n  rs.stencilTest.backOperation.zPass = StencilOperation.REPLACE;\n  rs.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK | StencilConstants.SKIP_LOD_MASK;\n  derivedCommand.renderState = RenderState.fromCache(rs);\n  return derivedCommand;\n}\n\nfunction getLastSelectionDepth(stencilCommand) {\n  // Isolate the selection depth from the stencil reference.\n  var reference = stencilCommand.renderState.stencilTest.reference;\n  return (reference & StencilConstants.SKIP_LOD_MASK) >>> StencilConstants.SKIP_LOD_BIT_SHIFT;\n}\n\nfunction getTranslucentRenderState(renderState) {\n  var rs = clone(renderState, true);\n  rs.cull.enabled = false;\n  rs.depthTest.enabled = true;\n  rs.depthMask = false;\n  rs.blending = BlendingState.ALPHA_BLEND;\n  return RenderState.fromCache(rs);\n}\n\nfunction getOpaqueRenderState(renderState) {\n  var rs = clone(renderState, true);\n  rs.stencilTest = StencilConstants.setCesium3DTileBit();\n  rs.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK;\n  return RenderState.fromCache(rs);\n} ///////////////////////////////////////////////////////////////////////////\n\n\nfunction createTexture(batchTable, context, bytes) {\n  var dimensions = batchTable._textureDimensions;\n  return new Texture({\n    context: context,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n    source: {\n      width: dimensions.x,\n      height: dimensions.y,\n      arrayBufferView: bytes\n    },\n    flipY: false,\n    sampler: Sampler.NEAREST\n  });\n}\n\nfunction createPickTexture(batchTable, context) {\n  var featuresLength = batchTable.featuresLength;\n\n  if (!defined(batchTable._pickTexture) && featuresLength > 0) {\n    var pickIds = batchTable._pickIds;\n    var byteLength = getByteLength(batchTable);\n    var bytes = new Uint8Array(byteLength);\n    var content = batchTable._content; // PERFORMANCE_IDEA: we could skip the pick texture completely by allocating\n    // a continuous range of pickIds and then converting the base pickId + batchId\n    // to RGBA in the shader.  The only consider is precision issues, which might\n    // not be an issue in WebGL 2.\n\n    for (var i = 0; i < featuresLength; ++i) {\n      var pickId = context.createPickId(content.getFeature(i));\n      pickIds.push(pickId);\n      var pickColor = pickId.color;\n      var offset = i * 4;\n      bytes[offset] = Color.floatToByte(pickColor.red);\n      bytes[offset + 1] = Color.floatToByte(pickColor.green);\n      bytes[offset + 2] = Color.floatToByte(pickColor.blue);\n      bytes[offset + 3] = Color.floatToByte(pickColor.alpha);\n    }\n\n    batchTable._pickTexture = createTexture(batchTable, context, bytes);\n    content.tileset._statistics.batchTableByteLength += batchTable._pickTexture.sizeInBytes;\n  }\n}\n\nfunction updateBatchTexture(batchTable) {\n  var dimensions = batchTable._textureDimensions; // PERFORMANCE_IDEA: Instead of rewriting the entire texture, use fine-grained\n  // texture updates when less than, for example, 10%, of the values changed.  Or\n  // even just optimize the common case when one feature show/color changed.\n\n  batchTable._batchTexture.copyFrom({\n    width: dimensions.x,\n    height: dimensions.y,\n    arrayBufferView: batchTable._batchValues\n  });\n}\n\nCesium3DTileBatchTable.prototype.update = function (tileset, frameState) {\n  var context = frameState.context;\n  this._defaultTexture = context.defaultTexture;\n  var passes = frameState.passes;\n\n  if (passes.pick || passes.postProcess) {\n    createPickTexture(this, context);\n  }\n\n  if (this._batchValuesDirty) {\n    this._batchValuesDirty = false; // Create batch texture on-demand\n\n    if (!defined(this._batchTexture)) {\n      this._batchTexture = createTexture(this, context, this._batchValues);\n      tileset._statistics.batchTableByteLength += this._batchTexture.sizeInBytes;\n    }\n\n    updateBatchTexture(this); // Apply per-feature show/color updates\n  }\n};\n\nCesium3DTileBatchTable.prototype.isDestroyed = function () {\n  return false;\n};\n\nCesium3DTileBatchTable.prototype.destroy = function () {\n  this._batchTexture = this._batchTexture && this._batchTexture.destroy();\n  this._pickTexture = this._pickTexture && this._pickTexture.destroy();\n  var pickIds = this._pickIds;\n  var length = pickIds.length;\n\n  for (var i = 0; i < length; ++i) {\n    pickIds[i].destroy();\n  }\n\n  return destroyObject(this);\n};\n\nexport default Cesium3DTileBatchTable;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/Cesium3DTileBatchTable.js"],"names":["arrayFill","Cartesian2","Cartesian4","Check","clone","Color","combine","ComponentDatatype","defaultValue","defined","deprecationWarning","destroyObject","DeveloperError","CesiumMath","PixelFormat","RuntimeError","ContextLimits","DrawCommand","Pass","PixelDatatype","RenderState","Sampler","ShaderSource","Texture","AttributeType","BlendingState","Cesium3DTileColorBlendMode","CullFace","getBinaryAccessor","StencilConstants","StencilFunction","StencilOperation","DEFAULT_COLOR_VALUE","WHITE","DEFAULT_SHOW_VALUE","Cesium3DTileBatchTable","content","featuresLength","batchTableJson","batchTableBinary","colorChangedCallback","_translucentFeaturesLength","extensions","_extensions","properties","initializeProperties","_properties","_batchTableHierarchy","initializeHierarchy","_batchTableBinaryProperties","getBinaryProperties","_showAlphaProperties","undefined","_batchValues","_batchValuesDirty","_batchTexture","_defaultTexture","_pickTexture","_pickIds","_content","_colorChangedCallback","textureDimensions","textureStep","width","Math","min","maximumTextureSize","height","ceil","stepX","centerX","stepY","centerY","_textureDimensions","_textureStep","_deprecationWarning","Object","defineProperties","prototype","memorySizeInBytes","get","memory","sizeInBytes","jsonHeader","propertyName","hasOwnProperty","batchTable","binaryBody","hierarchy","legacyHierarchy","HIERARCHY","initializeHierarchyValues","hierarchyJson","i","classId","binaryAccessor","instancesLength","classes","classIds","parentCounts","parentIds","parentIdsLength","byteOffset","componentType","UNSIGNED_SHORT","type","SCALAR","createArrayBufferView","buffer","parentIndexes","Uint16Array","classesLength","length","classInstancesLength","instances","binaryProperties","classCounts","Array","classIndexes","validateHierarchy","scratchValidateStack","stack","validateInstance","instanceIndex","indexOf","push","parentCount","parentIndex","parentId","pop","name","property","componentCount","componentsPerAttribute","classType","typedArray","getByteLength","dimensions","x","y","getBatchValues","byteLength","bytes","Uint8Array","getShowAlphaProperties","checkBatchId","batchId","setShow","show","typeOf","bool","showAlphaProperties","propertyOffset","newShow","batchValues","offset","setAllShow","getShow","scratchColorBytes","setColor","color","object","equals","newColor","toBytes","newAlpha","wasTranslucent","isTranslucent","setAllColor","getColor","result","fromBytes","getPickColor","scratchColor","applyStyle","style","feature","getFeature","evaluateColor","evaluate","getBinaryProperty","binaryProperty","index","unpack","setBinaryProperty","value","pack","scratchVisited","scratchStack","marker","traverseHierarchyMultipleParents","endConditionCallback","visited","max","visitedMarker","traverseHierarchySingleParent","hasParent","traverseHierarchy","hasPropertyInHierarchy","getPropertyNamesInHierarchy","results","getHierarchyProperty","instanceClass","indexInClass","propertyValues","setHierarchyProperty","isClass","className","string","isExactClass","getExactClassName","hasProperty","getPropertyNames","propertyNames","keys","apply","getProperty","hierarchyProperty","setProperty","getGlslComputeSt","getVertexShaderCallback","handleTranslucent","batchIdAttributeName","diffuseAttributeOrUniformName","that","source","renamedSource","modifyDiffuse","newMain","maximumVertexTextureImageUnits","getDefaultShader","applyHighlight","replaceMain","replaceDiffuseTextureCalls","functionCall","fromIndex","startIndex","endIndex","nestedLevel","character","charAt","extractedFunction","slice","replacedFunction","regex","RegExp","uniformMatch","match","declaration","replace","finalDiffuseFunction","highlight","sourceDiffuse","replaceDiffuse","getFragmentShaderCallback","getClassificationFragmentShaderCallback","getColorBlend","tileset","colorBlendMode","colorBlendAmount","HIGHLIGHT","REPLACE","MIX","clamp","EPSILON4","getUniformMapCallback","uniformMap","batchUniformMap","tile_batchTexture","tile_textureDimensions","tile_textureStep","tile_colorBlend","tile_pickTexture","getPickId","StyleCommandsNeeded","ALL_OPAQUE","ALL_TRANSLUCENT","OPAQUE_AND_TRANSLUCENT","addDerivedCommands","frameState","commandStart","commandList","commandEnd","tile","_tile","finalResolution","_finalResolution","bivariateVisibilityTest","_skipLevelOfDetail","_hasMixedContent","context","stencilBuffer","styleCommandsNeeded","getStyleCommandsNeeded","command","derivedCommands","dirty","originalCommand","deriveCommand","pass","TRANSLUCENT","translucent","deriveTranslucentCommand","opaque","deriveOpaqueCommand","zback","deriveZBackfaceCommand","_backfaceCommands","stencil","_selectionDepth","getLastSelectionDepth","renderState","depthMask","deriveStencilCommand","opaqueCommand","translucentCommand","translucentFeaturesLength","derivedCommand","shallowClone","tile_translucentCommand","getTranslucentRenderState","getOpaqueRenderState","getLogDepthPolygonOffsetFragmentShaderProgram","shaderProgram","shader","shaderCache","getDerivedShaderProgram","fs","fragmentShaderSource","defines","sources","unshift","createDerivedShaderProgram","vertexShaderSource","attributeLocations","_attributeLocations","rs","cull","enabled","face","FRONT","colorMask","red","green","blue","alpha","polygonOffset","factor","units","stencilTest","setCesium3DTileBit","stencilMask","CESIUM_3D_TILE_MASK","fromCache","castShadows","receiveShadows","u_polygonOffset","reference","mask","SKIP_LOD_MASK","SKIP_LOD_BIT_SHIFT","frontFunction","GREATER_OR_EQUAL","frontOperation","zPass","backFunction","backOperation","stencilCommand","depthTest","blending","ALPHA_BLEND","createTexture","pixelFormat","RGBA","pixelDatatype","UNSIGNED_BYTE","arrayBufferView","flipY","sampler","NEAREST","createPickTexture","pickIds","pickId","createPickId","pickColor","floatToByte","_statistics","batchTableByteLength","updateBatchTexture","copyFrom","update","defaultTexture","passes","pick","postProcess","isDestroyed","destroy"],"mappings":"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","sourcesContent":["import arrayFill from \"../Core/arrayFill.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport deprecationWarning from \"../Core/deprecationWarning.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport AttributeType from \"./AttributeType.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Cesium3DTileColorBlendMode from \"./Cesium3DTileColorBlendMode.js\";\nimport CullFace from \"./CullFace.js\";\nimport getBinaryAccessor from \"./getBinaryAccessor.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\n\nvar DEFAULT_COLOR_VALUE = Color.WHITE;\nvar DEFAULT_SHOW_VALUE = true;\n\n/**\n * @private\n * @constructor\n */\nfunction Cesium3DTileBatchTable(\n  content,\n  featuresLength,\n  batchTableJson,\n  batchTableBinary,\n  colorChangedCallback\n) {\n  /**\n   * @readonly\n   */\n  this.featuresLength = featuresLength;\n\n  this._translucentFeaturesLength = 0; // Number of features in the tile that are translucent\n\n  var extensions;\n  if (defined(batchTableJson)) {\n    extensions = batchTableJson.extensions;\n  }\n  this._extensions = defaultValue(extensions, {});\n\n  var properties = initializeProperties(batchTableJson);\n  this._properties = properties;\n\n  this._batchTableHierarchy = initializeHierarchy(\n    this,\n    batchTableJson,\n    batchTableBinary\n  );\n  this._batchTableBinaryProperties = getBinaryProperties(\n    featuresLength,\n    properties,\n    batchTableBinary\n  );\n\n  // PERFORMANCE_IDEA: These parallel arrays probably generate cache misses in get/set color/show\n  // and use A LOT of memory.  How can we use less memory?\n  this._showAlphaProperties = undefined; // [Show (0 or 255), Alpha (0 to 255)] property for each feature\n  this._batchValues = undefined; // Per-feature RGBA (A is based on the color's alpha and feature's show property)\n\n  this._batchValuesDirty = false;\n  this._batchTexture = undefined;\n  this._defaultTexture = undefined;\n\n  this._pickTexture = undefined;\n  this._pickIds = [];\n\n  this._content = content;\n\n  this._colorChangedCallback = colorChangedCallback;\n\n  // Dimensions for batch and pick textures\n  var textureDimensions;\n  var textureStep;\n\n  if (featuresLength > 0) {\n    // PERFORMANCE_IDEA: this can waste memory in the last row in the uncommon case\n    // when more than one row is needed (e.g., > 16K features in one tile)\n    var width = Math.min(featuresLength, ContextLimits.maximumTextureSize);\n    var height = Math.ceil(featuresLength / ContextLimits.maximumTextureSize);\n    var stepX = 1.0 / width;\n    var centerX = stepX * 0.5;\n    var stepY = 1.0 / height;\n    var centerY = stepY * 0.5;\n\n    textureDimensions = new Cartesian2(width, height);\n    textureStep = new Cartesian4(stepX, centerX, stepY, centerY);\n  }\n\n  this._textureDimensions = textureDimensions;\n  this._textureStep = textureStep;\n}\n\n// This can be overridden for testing purposes\nCesium3DTileBatchTable._deprecationWarning = deprecationWarning;\n\nObject.defineProperties(Cesium3DTileBatchTable.prototype, {\n  memorySizeInBytes: {\n    get: function () {\n      var memory = 0;\n      if (defined(this._pickTexture)) {\n        memory += this._pickTexture.sizeInBytes;\n      }\n      if (defined(this._batchTexture)) {\n        memory += this._batchTexture.sizeInBytes;\n      }\n      return memory;\n    },\n  },\n});\n\nfunction initializeProperties(jsonHeader) {\n  var properties = {};\n\n  if (!defined(jsonHeader)) {\n    return properties;\n  }\n\n  for (var propertyName in jsonHeader) {\n    if (\n      jsonHeader.hasOwnProperty(propertyName) &&\n      propertyName !== \"HIERARCHY\" && // Deprecated HIERARCHY property\n      propertyName !== \"extensions\" &&\n      propertyName !== \"extras\"\n    ) {\n      properties[propertyName] = clone(jsonHeader[propertyName], true);\n    }\n  }\n\n  return properties;\n}\n\nfunction initializeHierarchy(batchTable, jsonHeader, binaryBody) {\n  if (!defined(jsonHeader)) {\n    return;\n  }\n\n  var hierarchy = batchTable._extensions[\"3DTILES_batch_table_hierarchy\"];\n\n  var legacyHierarchy = jsonHeader.HIERARCHY;\n  if (defined(legacyHierarchy)) {\n    Cesium3DTileBatchTable._deprecationWarning(\n      \"batchTableHierarchyExtension\",\n      \"The batch table HIERARCHY property has been moved to an extension. Use extensions.3DTILES_batch_table_hierarchy instead.\"\n    );\n    batchTable._extensions[\"3DTILES_batch_table_hierarchy\"] = legacyHierarchy;\n    hierarchy = legacyHierarchy;\n  }\n\n  if (!defined(hierarchy)) {\n    return;\n  }\n\n  return initializeHierarchyValues(hierarchy, binaryBody);\n}\n\nfunction initializeHierarchyValues(hierarchyJson, binaryBody) {\n  var i;\n  var classId;\n  var binaryAccessor;\n\n  var instancesLength = hierarchyJson.instancesLength;\n  var classes = hierarchyJson.classes;\n  var classIds = hierarchyJson.classIds;\n  var parentCounts = hierarchyJson.parentCounts;\n  var parentIds = hierarchyJson.parentIds;\n  var parentIdsLength = instancesLength;\n\n  if (defined(classIds.byteOffset)) {\n    classIds.componentType = defaultValue(\n      classIds.componentType,\n      ComponentDatatype.UNSIGNED_SHORT\n    );\n    classIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(classIds);\n    classIds = binaryAccessor.createArrayBufferView(\n      binaryBody.buffer,\n      binaryBody.byteOffset + classIds.byteOffset,\n      instancesLength\n    );\n  }\n\n  var parentIndexes;\n  if (defined(parentCounts)) {\n    if (defined(parentCounts.byteOffset)) {\n      parentCounts.componentType = defaultValue(\n        parentCounts.componentType,\n        ComponentDatatype.UNSIGNED_SHORT\n      );\n      parentCounts.type = AttributeType.SCALAR;\n      binaryAccessor = getBinaryAccessor(parentCounts);\n      parentCounts = binaryAccessor.createArrayBufferView(\n        binaryBody.buffer,\n        binaryBody.byteOffset + parentCounts.byteOffset,\n        instancesLength\n      );\n    }\n    parentIndexes = new Uint16Array(instancesLength);\n    parentIdsLength = 0;\n    for (i = 0; i < instancesLength; ++i) {\n      parentIndexes[i] = parentIdsLength;\n      parentIdsLength += parentCounts[i];\n    }\n  }\n\n  if (defined(parentIds) && defined(parentIds.byteOffset)) {\n    parentIds.componentType = defaultValue(\n      parentIds.componentType,\n      ComponentDatatype.UNSIGNED_SHORT\n    );\n    parentIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(parentIds);\n    parentIds = binaryAccessor.createArrayBufferView(\n      binaryBody.buffer,\n      binaryBody.byteOffset + parentIds.byteOffset,\n      parentIdsLength\n    );\n  }\n\n  var classesLength = classes.length;\n  for (i = 0; i < classesLength; ++i) {\n    var classInstancesLength = classes[i].length;\n    var properties = classes[i].instances;\n    var binaryProperties = getBinaryProperties(\n      classInstancesLength,\n      properties,\n      binaryBody\n    );\n    classes[i].instances = combine(binaryProperties, properties);\n  }\n\n  var classCounts = arrayFill(new Array(classesLength), 0);\n  var classIndexes = new Uint16Array(instancesLength);\n  for (i = 0; i < instancesLength; ++i) {\n    classId = classIds[i];\n    classIndexes[i] = classCounts[classId];\n    ++classCounts[classId];\n  }\n\n  var hierarchy = {\n    classes: classes,\n    classIds: classIds,\n    classIndexes: classIndexes,\n    parentCounts: parentCounts,\n    parentIndexes: parentIndexes,\n    parentIds: parentIds,\n  };\n\n  //>>includeStart('debug', pragmas.debug);\n  validateHierarchy(hierarchy);\n  //>>includeEnd('debug');\n\n  return hierarchy;\n}\n\n//>>includeStart('debug', pragmas.debug);\nvar scratchValidateStack = [];\nfunction validateHierarchy(hierarchy) {\n  var stack = scratchValidateStack;\n  stack.length = 0;\n\n  var classIds = hierarchy.classIds;\n  var instancesLength = classIds.length;\n\n  for (var i = 0; i < instancesLength; ++i) {\n    validateInstance(hierarchy, i, stack);\n  }\n}\n\nfunction validateInstance(hierarchy, instanceIndex, stack) {\n  var parentCounts = hierarchy.parentCounts;\n  var parentIds = hierarchy.parentIds;\n  var parentIndexes = hierarchy.parentIndexes;\n  var classIds = hierarchy.classIds;\n  var instancesLength = classIds.length;\n\n  if (!defined(parentIds)) {\n    // No need to validate if there are no parents\n    return;\n  }\n\n  if (instanceIndex >= instancesLength) {\n    throw new DeveloperError(\n      \"Parent index \" +\n        instanceIndex +\n        \" exceeds the total number of instances: \" +\n        instancesLength\n    );\n  }\n  if (stack.indexOf(instanceIndex) > -1) {\n    throw new DeveloperError(\n      \"Circular dependency detected in the batch table hierarchy.\"\n    );\n  }\n\n  stack.push(instanceIndex);\n  var parentCount = defined(parentCounts) ? parentCounts[instanceIndex] : 1;\n  var parentIndex = defined(parentCounts)\n    ? parentIndexes[instanceIndex]\n    : instanceIndex;\n  for (var i = 0; i < parentCount; ++i) {\n    var parentId = parentIds[parentIndex + i];\n    // Stop the traversal when the instance has no parent (its parentId equals itself), else continue the traversal.\n    if (parentId !== instanceIndex) {\n      validateInstance(hierarchy, parentId, stack);\n    }\n  }\n  stack.pop(instanceIndex);\n}\n//>>includeEnd('debug');\n\nfunction getBinaryProperties(featuresLength, properties, binaryBody) {\n  var binaryProperties;\n  for (var name in properties) {\n    if (properties.hasOwnProperty(name)) {\n      var property = properties[name];\n      var byteOffset = property.byteOffset;\n      if (defined(byteOffset)) {\n        // This is a binary property\n        var componentType = property.componentType;\n        var type = property.type;\n        if (!defined(componentType)) {\n          throw new RuntimeError(\"componentType is required.\");\n        }\n        if (!defined(type)) {\n          throw new RuntimeError(\"type is required.\");\n        }\n        if (!defined(binaryBody)) {\n          throw new RuntimeError(\n            \"Property \" + name + \" requires a batch table binary.\"\n          );\n        }\n\n        var binaryAccessor = getBinaryAccessor(property);\n        var componentCount = binaryAccessor.componentsPerAttribute;\n        var classType = binaryAccessor.classType;\n        var typedArray = binaryAccessor.createArrayBufferView(\n          binaryBody.buffer,\n          binaryBody.byteOffset + byteOffset,\n          featuresLength\n        );\n\n        if (!defined(binaryProperties)) {\n          binaryProperties = {};\n        }\n\n        // Store any information needed to access the binary data, including the typed array,\n        // componentCount (e.g. a VEC4 would be 4), and the type used to pack and unpack (e.g. Cartesian4).\n        binaryProperties[name] = {\n          typedArray: typedArray,\n          componentCount: componentCount,\n          type: classType,\n        };\n      }\n    }\n  }\n  return binaryProperties;\n}\n\nCesium3DTileBatchTable.getBinaryProperties = function (\n  featuresLength,\n  batchTableJson,\n  batchTableBinary\n) {\n  return getBinaryProperties(featuresLength, batchTableJson, batchTableBinary);\n};\n\nfunction getByteLength(batchTable) {\n  var dimensions = batchTable._textureDimensions;\n  return dimensions.x * dimensions.y * 4;\n}\n\nfunction getBatchValues(batchTable) {\n  if (!defined(batchTable._batchValues)) {\n    // Default batch texture to RGBA = 255: white highlight (RGB) and show/alpha = true/255 (A).\n    var byteLength = getByteLength(batchTable);\n    var bytes = new Uint8Array(byteLength);\n    arrayFill(bytes, 255);\n    batchTable._batchValues = bytes;\n  }\n\n  return batchTable._batchValues;\n}\n\nfunction getShowAlphaProperties(batchTable) {\n  if (!defined(batchTable._showAlphaProperties)) {\n    var byteLength = 2 * batchTable.featuresLength;\n    var bytes = new Uint8Array(byteLength);\n    // [Show = true, Alpha = 255]\n    arrayFill(bytes, 255);\n    batchTable._showAlphaProperties = bytes;\n  }\n  return batchTable._showAlphaProperties;\n}\n\nfunction checkBatchId(batchId, featuresLength) {\n  if (!defined(batchId) || batchId < 0 || batchId > featuresLength) {\n    throw new DeveloperError(\n      \"batchId is required and between zero and featuresLength - 1 (\" +\n        featuresLength -\n        +\").\"\n    );\n  }\n}\n\nCesium3DTileBatchTable.prototype.setShow = function (batchId, show) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  Check.typeOf.bool(\"show\", show);\n  //>>includeEnd('debug');\n\n  if (show && !defined(this._showAlphaProperties)) {\n    // Avoid allocating since the default is show = true\n    return;\n  }\n\n  var showAlphaProperties = getShowAlphaProperties(this);\n  var propertyOffset = batchId * 2;\n\n  var newShow = show ? 255 : 0;\n  if (showAlphaProperties[propertyOffset] !== newShow) {\n    showAlphaProperties[propertyOffset] = newShow;\n\n    var batchValues = getBatchValues(this);\n\n    // Compute alpha used in the shader based on show and color.alpha properties\n    var offset = batchId * 4 + 3;\n    batchValues[offset] = show ? showAlphaProperties[propertyOffset + 1] : 0;\n\n    this._batchValuesDirty = true;\n  }\n};\n\nCesium3DTileBatchTable.prototype.setAllShow = function (show) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bool(\"show\", show);\n  //>>includeEnd('debug');\n\n  var featuresLength = this.featuresLength;\n  for (var i = 0; i < featuresLength; ++i) {\n    this.setShow(i, show);\n  }\n};\n\nCesium3DTileBatchTable.prototype.getShow = function (batchId) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  //>>includeEnd('debug');\n\n  if (!defined(this._showAlphaProperties)) {\n    // Avoid allocating since the default is show = true\n    return true;\n  }\n\n  var offset = batchId * 2;\n  return this._showAlphaProperties[offset] === 255;\n};\n\nvar scratchColorBytes = new Array(4);\n\nCesium3DTileBatchTable.prototype.setColor = function (batchId, color) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  Check.typeOf.object(\"color\", color);\n  //>>includeEnd('debug');\n\n  if (Color.equals(color, DEFAULT_COLOR_VALUE) && !defined(this._batchValues)) {\n    // Avoid allocating since the default is white\n    return;\n  }\n\n  var newColor = color.toBytes(scratchColorBytes);\n  var newAlpha = newColor[3];\n\n  var batchValues = getBatchValues(this);\n  var offset = batchId * 4;\n\n  var showAlphaProperties = getShowAlphaProperties(this);\n  var propertyOffset = batchId * 2;\n\n  if (\n    batchValues[offset] !== newColor[0] ||\n    batchValues[offset + 1] !== newColor[1] ||\n    batchValues[offset + 2] !== newColor[2] ||\n    showAlphaProperties[propertyOffset + 1] !== newAlpha\n  ) {\n    batchValues[offset] = newColor[0];\n    batchValues[offset + 1] = newColor[1];\n    batchValues[offset + 2] = newColor[2];\n\n    var wasTranslucent = showAlphaProperties[propertyOffset + 1] !== 255;\n\n    // Compute alpha used in the shader based on show and color.alpha properties\n    var show = showAlphaProperties[propertyOffset] !== 0;\n    batchValues[offset + 3] = show ? newAlpha : 0;\n    showAlphaProperties[propertyOffset + 1] = newAlpha;\n\n    // Track number of translucent features so we know if this tile needs\n    // opaque commands, translucent commands, or both for rendering.\n    var isTranslucent = newAlpha !== 255;\n    if (isTranslucent && !wasTranslucent) {\n      ++this._translucentFeaturesLength;\n    } else if (!isTranslucent && wasTranslucent) {\n      --this._translucentFeaturesLength;\n    }\n\n    this._batchValuesDirty = true;\n\n    if (defined(this._colorChangedCallback)) {\n      this._colorChangedCallback(batchId, color);\n    }\n  }\n};\n\nCesium3DTileBatchTable.prototype.setAllColor = function (color) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"color\", color);\n  //>>includeEnd('debug');\n\n  var featuresLength = this.featuresLength;\n  for (var i = 0; i < featuresLength; ++i) {\n    this.setColor(i, color);\n  }\n};\n\nCesium3DTileBatchTable.prototype.getColor = function (batchId, result) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  if (!defined(this._batchValues)) {\n    return Color.clone(DEFAULT_COLOR_VALUE, result);\n  }\n\n  var batchValues = this._batchValues;\n  var offset = batchId * 4;\n\n  var showAlphaProperties = this._showAlphaProperties;\n  var propertyOffset = batchId * 2;\n\n  return Color.fromBytes(\n    batchValues[offset],\n    batchValues[offset + 1],\n    batchValues[offset + 2],\n    showAlphaProperties[propertyOffset + 1],\n    result\n  );\n};\n\nCesium3DTileBatchTable.prototype.getPickColor = function (batchId) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  //>>includeEnd('debug');\n  return this._pickIds[batchId];\n};\n\nvar scratchColor = new Color();\n\nCesium3DTileBatchTable.prototype.applyStyle = function (style) {\n  if (!defined(style)) {\n    this.setAllColor(DEFAULT_COLOR_VALUE);\n    this.setAllShow(DEFAULT_SHOW_VALUE);\n    return;\n  }\n\n  var content = this._content;\n  var length = this.featuresLength;\n  for (var i = 0; i < length; ++i) {\n    var feature = content.getFeature(i);\n    var color = defined(style.color)\n      ? style.color.evaluateColor(feature, scratchColor)\n      : DEFAULT_COLOR_VALUE;\n    var show = defined(style.show)\n      ? style.show.evaluate(feature)\n      : DEFAULT_SHOW_VALUE;\n    this.setColor(i, color);\n    this.setShow(i, show);\n  }\n};\n\nfunction getBinaryProperty(binaryProperty, index) {\n  var typedArray = binaryProperty.typedArray;\n  var componentCount = binaryProperty.componentCount;\n  if (componentCount === 1) {\n    return typedArray[index];\n  }\n  return binaryProperty.type.unpack(typedArray, index * componentCount);\n}\n\nfunction setBinaryProperty(binaryProperty, index, value) {\n  var typedArray = binaryProperty.typedArray;\n  var componentCount = binaryProperty.componentCount;\n  if (componentCount === 1) {\n    typedArray[index] = value;\n  } else {\n    binaryProperty.type.pack(value, typedArray, index * componentCount);\n  }\n}\n\n// The size of this array equals the maximum instance count among all loaded tiles, which has the potential to be large.\nvar scratchVisited = [];\nvar scratchStack = [];\nvar marker = 0;\nfunction traverseHierarchyMultipleParents(\n  hierarchy,\n  instanceIndex,\n  endConditionCallback\n) {\n  var classIds = hierarchy.classIds;\n  var parentCounts = hierarchy.parentCounts;\n  var parentIds = hierarchy.parentIds;\n  var parentIndexes = hierarchy.parentIndexes;\n  var instancesLength = classIds.length;\n\n  // Ignore instances that have already been visited. This occurs in diamond inheritance situations.\n  // Use a marker value to indicate that an instance has been visited, which increments with each run.\n  // This is more efficient than clearing the visited array every time.\n  var visited = scratchVisited;\n  visited.length = Math.max(visited.length, instancesLength);\n  var visitedMarker = ++marker;\n\n  var stack = scratchStack;\n  stack.length = 0;\n  stack.push(instanceIndex);\n\n  while (stack.length > 0) {\n    instanceIndex = stack.pop();\n    if (visited[instanceIndex] === visitedMarker) {\n      // This instance has already been visited, stop traversal\n      continue;\n    }\n    visited[instanceIndex] = visitedMarker;\n    var result = endConditionCallback(hierarchy, instanceIndex);\n    if (defined(result)) {\n      // The end condition was met, stop the traversal and return the result\n      return result;\n    }\n    var parentCount = parentCounts[instanceIndex];\n    var parentIndex = parentIndexes[instanceIndex];\n    for (var i = 0; i < parentCount; ++i) {\n      var parentId = parentIds[parentIndex + i];\n      // Stop the traversal when the instance has no parent (its parentId equals itself)\n      // else add the parent to the stack to continue the traversal.\n      if (parentId !== instanceIndex) {\n        stack.push(parentId);\n      }\n    }\n  }\n}\n\nfunction traverseHierarchySingleParent(\n  hierarchy,\n  instanceIndex,\n  endConditionCallback\n) {\n  var hasParent = true;\n  while (hasParent) {\n    var result = endConditionCallback(hierarchy, instanceIndex);\n    if (defined(result)) {\n      // The end condition was met, stop the traversal and return the result\n      return result;\n    }\n    var parentId = hierarchy.parentIds[instanceIndex];\n    hasParent = parentId !== instanceIndex;\n    instanceIndex = parentId;\n  }\n}\n\nfunction traverseHierarchy(hierarchy, instanceIndex, endConditionCallback) {\n  // Traverse over the hierarchy and process each instance with the endConditionCallback.\n  // When the endConditionCallback returns a value, the traversal stops and that value is returned.\n  var parentCounts = hierarchy.parentCounts;\n  var parentIds = hierarchy.parentIds;\n  if (!defined(parentIds)) {\n    return endConditionCallback(hierarchy, instanceIndex);\n  } else if (defined(parentCounts)) {\n    return traverseHierarchyMultipleParents(\n      hierarchy,\n      instanceIndex,\n      endConditionCallback\n    );\n  }\n  return traverseHierarchySingleParent(\n    hierarchy,\n    instanceIndex,\n    endConditionCallback\n  );\n}\n\nfunction hasPropertyInHierarchy(batchTable, batchId, name) {\n  var hierarchy = batchTable._batchTableHierarchy;\n  var result = traverseHierarchy(hierarchy, batchId, function (\n    hierarchy,\n    instanceIndex\n  ) {\n    var classId = hierarchy.classIds[instanceIndex];\n    var instances = hierarchy.classes[classId].instances;\n    if (defined(instances[name])) {\n      return true;\n    }\n  });\n  return defined(result);\n}\n\nfunction getPropertyNamesInHierarchy(batchTable, batchId, results) {\n  var hierarchy = batchTable._batchTableHierarchy;\n  traverseHierarchy(hierarchy, batchId, function (hierarchy, instanceIndex) {\n    var classId = hierarchy.classIds[instanceIndex];\n    var instances = hierarchy.classes[classId].instances;\n    for (var name in instances) {\n      if (instances.hasOwnProperty(name)) {\n        if (results.indexOf(name) === -1) {\n          results.push(name);\n        }\n      }\n    }\n  });\n}\n\nfunction getHierarchyProperty(batchTable, batchId, name) {\n  var hierarchy = batchTable._batchTableHierarchy;\n  return traverseHierarchy(hierarchy, batchId, function (\n    hierarchy,\n    instanceIndex\n  ) {\n    var classId = hierarchy.classIds[instanceIndex];\n    var instanceClass = hierarchy.classes[classId];\n    var indexInClass = hierarchy.classIndexes[instanceIndex];\n    var propertyValues = instanceClass.instances[name];\n    if (defined(propertyValues)) {\n      if (defined(propertyValues.typedArray)) {\n        return getBinaryProperty(propertyValues, indexInClass);\n      }\n      return clone(propertyValues[indexInClass], true);\n    }\n  });\n}\n\nfunction setHierarchyProperty(batchTable, batchId, name, value) {\n  var hierarchy = batchTable._batchTableHierarchy;\n  var result = traverseHierarchy(hierarchy, batchId, function (\n    hierarchy,\n    instanceIndex\n  ) {\n    var classId = hierarchy.classIds[instanceIndex];\n    var instanceClass = hierarchy.classes[classId];\n    var indexInClass = hierarchy.classIndexes[instanceIndex];\n    var propertyValues = instanceClass.instances[name];\n    if (defined(propertyValues)) {\n      //>>includeStart('debug', pragmas.debug);\n      if (instanceIndex !== batchId) {\n        throw new DeveloperError(\n          'Inherited property \"' + name + '\" is read-only.'\n        );\n      }\n      //>>includeEnd('debug');\n      if (defined(propertyValues.typedArray)) {\n        setBinaryProperty(propertyValues, indexInClass, value);\n      } else {\n        propertyValues[indexInClass] = clone(value, true);\n      }\n      return true;\n    }\n  });\n  return defined(result);\n}\n\nCesium3DTileBatchTable.prototype.isClass = function (batchId, className) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  Check.typeOf.string(\"className\", className);\n  //>>includeEnd('debug');\n\n  // PERFORMANCE_IDEA : cache results in the ancestor classes to speed up this check if this area becomes a hotspot\n  var hierarchy = this._batchTableHierarchy;\n  if (!defined(hierarchy)) {\n    return false;\n  }\n\n  // PERFORMANCE_IDEA : treat class names as integers for faster comparisons\n  var result = traverseHierarchy(hierarchy, batchId, function (\n    hierarchy,\n    instanceIndex\n  ) {\n    var classId = hierarchy.classIds[instanceIndex];\n    var instanceClass = hierarchy.classes[classId];\n    if (instanceClass.name === className) {\n      return true;\n    }\n  });\n  return defined(result);\n};\n\nCesium3DTileBatchTable.prototype.isExactClass = function (batchId, className) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"className\", className);\n  //>>includeEnd('debug');\n\n  return this.getExactClassName(batchId) === className;\n};\n\nCesium3DTileBatchTable.prototype.getExactClassName = function (batchId) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  //>>includeEnd('debug');\n\n  var hierarchy = this._batchTableHierarchy;\n  if (!defined(hierarchy)) {\n    return undefined;\n  }\n  var classId = hierarchy.classIds[batchId];\n  var instanceClass = hierarchy.classes[classId];\n  return instanceClass.name;\n};\n\nCesium3DTileBatchTable.prototype.hasProperty = function (batchId, name) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  Check.typeOf.string(\"name\", name);\n  //>>includeEnd('debug');\n\n  return (\n    defined(this._properties[name]) ||\n    (defined(this._batchTableHierarchy) &&\n      hasPropertyInHierarchy(this, batchId, name))\n  );\n};\n\nCesium3DTileBatchTable.prototype.getPropertyNames = function (\n  batchId,\n  results\n) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  //>>includeEnd('debug');\n\n  results = defined(results) ? results : [];\n  results.length = 0;\n\n  var propertyNames = Object.keys(this._properties);\n  results.push.apply(results, propertyNames);\n\n  if (defined(this._batchTableHierarchy)) {\n    getPropertyNamesInHierarchy(this, batchId, results);\n  }\n\n  return results;\n};\n\nCesium3DTileBatchTable.prototype.getProperty = function (batchId, name) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  Check.typeOf.string(\"name\", name);\n  //>>includeEnd('debug');\n\n  if (defined(this._batchTableBinaryProperties)) {\n    var binaryProperty = this._batchTableBinaryProperties[name];\n    if (defined(binaryProperty)) {\n      return getBinaryProperty(binaryProperty, batchId);\n    }\n  }\n\n  var propertyValues = this._properties[name];\n  if (defined(propertyValues)) {\n    return clone(propertyValues[batchId], true);\n  }\n\n  if (defined(this._batchTableHierarchy)) {\n    var hierarchyProperty = getHierarchyProperty(this, batchId, name);\n    if (defined(hierarchyProperty)) {\n      return hierarchyProperty;\n    }\n  }\n\n  return undefined;\n};\n\nCesium3DTileBatchTable.prototype.setProperty = function (batchId, name, value) {\n  var featuresLength = this.featuresLength;\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, featuresLength);\n  Check.typeOf.string(\"name\", name);\n  //>>includeEnd('debug');\n\n  if (defined(this._batchTableBinaryProperties)) {\n    var binaryProperty = this._batchTableBinaryProperties[name];\n    if (defined(binaryProperty)) {\n      setBinaryProperty(binaryProperty, batchId, value);\n      return;\n    }\n  }\n\n  if (defined(this._batchTableHierarchy)) {\n    if (setHierarchyProperty(this, batchId, name, value)) {\n      return;\n    }\n  }\n\n  var propertyValues = this._properties[name];\n  if (!defined(propertyValues)) {\n    // Property does not exist. Create it.\n    this._properties[name] = new Array(featuresLength);\n    propertyValues = this._properties[name];\n  }\n\n  propertyValues[batchId] = clone(value, true);\n};\n\nfunction getGlslComputeSt(batchTable) {\n  // GLSL batchId is zero-based: [0, featuresLength - 1]\n  if (batchTable._textureDimensions.y === 1) {\n    return (\n      \"uniform vec4 tile_textureStep; \\n\" +\n      \"vec2 computeSt(float batchId) \\n\" +\n      \"{ \\n\" +\n      \"    float stepX = tile_textureStep.x; \\n\" +\n      \"    float centerX = tile_textureStep.y; \\n\" +\n      \"    return vec2(centerX + (batchId * stepX), 0.5); \\n\" +\n      \"} \\n\"\n    );\n  }\n\n  return (\n    \"uniform vec4 tile_textureStep; \\n\" +\n    \"uniform vec2 tile_textureDimensions; \\n\" +\n    \"vec2 computeSt(float batchId) \\n\" +\n    \"{ \\n\" +\n    \"    float stepX = tile_textureStep.x; \\n\" +\n    \"    float centerX = tile_textureStep.y; \\n\" +\n    \"    float stepY = tile_textureStep.z; \\n\" +\n    \"    float centerY = tile_textureStep.w; \\n\" +\n    \"    float xId = mod(batchId, tile_textureDimensions.x); \\n\" +\n    \"    float yId = floor(batchId / tile_textureDimensions.x); \\n\" +\n    \"    return vec2(centerX + (xId * stepX), centerY + (yId * stepY)); \\n\" +\n    \"} \\n\"\n  );\n}\n\nCesium3DTileBatchTable.prototype.getVertexShaderCallback = function (\n  handleTranslucent,\n  batchIdAttributeName,\n  diffuseAttributeOrUniformName\n) {\n  if (this.featuresLength === 0) {\n    return;\n  }\n\n  var that = this;\n  return function (source) {\n    // If the color blend mode is HIGHLIGHT, the highlight color will always be applied in the fragment shader.\n    // No need to apply the highlight color in the vertex shader as well.\n    var renamedSource = modifyDiffuse(\n      source,\n      diffuseAttributeOrUniformName,\n      false\n    );\n    var newMain;\n\n    if (ContextLimits.maximumVertexTextureImageUnits > 0) {\n      // When VTF is supported, perform per-feature show/hide in the vertex shader\n      newMain = \"\";\n      if (handleTranslucent) {\n        newMain += \"uniform bool tile_translucentCommand; \\n\";\n      }\n      newMain +=\n        \"uniform sampler2D tile_batchTexture; \\n\" +\n        \"varying vec4 tile_featureColor; \\n\" +\n        \"varying vec2 tile_featureSt; \\n\" +\n        \"void main() \\n\" +\n        \"{ \\n\" +\n        \"    vec2 st = computeSt(\" +\n        batchIdAttributeName +\n        \"); \\n\" +\n        \"    vec4 featureProperties = texture2D(tile_batchTexture, st); \\n\" +\n        \"    tile_color(featureProperties); \\n\" +\n        \"    float show = ceil(featureProperties.a); \\n\" + // 0 - false, non-zeo - true\n        \"    gl_Position *= show; \\n\"; // Per-feature show/hide\n      if (handleTranslucent) {\n        newMain +=\n          \"    bool isStyleTranslucent = (featureProperties.a != 1.0); \\n\" +\n          \"    if (czm_pass == czm_passTranslucent) \\n\" +\n          \"    { \\n\" +\n          \"        if (!isStyleTranslucent && !tile_translucentCommand) \\n\" + // Do not render opaque features in the translucent pass\n          \"        { \\n\" +\n          \"            gl_Position *= 0.0; \\n\" +\n          \"        } \\n\" +\n          \"    } \\n\" +\n          \"    else \\n\" +\n          \"    { \\n\" +\n          \"        if (isStyleTranslucent) \\n\" + // Do not render translucent features in the opaque pass\n          \"        { \\n\" +\n          \"            gl_Position *= 0.0; \\n\" +\n          \"        } \\n\" +\n          \"    } \\n\";\n      }\n      newMain +=\n        \"    tile_featureColor = featureProperties; \\n\" +\n        \"    tile_featureSt = st; \\n\" +\n        \"}\";\n    } else {\n      // When VTF is not supported, color blend mode MIX will look incorrect due to the feature's color not being available in the vertex shader\n      newMain =\n        \"varying vec2 tile_featureSt; \\n\" +\n        \"void main() \\n\" +\n        \"{ \\n\" +\n        \"    tile_color(vec4(1.0)); \\n\" +\n        \"    tile_featureSt = computeSt(\" +\n        batchIdAttributeName +\n        \"); \\n\" +\n        \"}\";\n    }\n\n    return renamedSource + \"\\n\" + getGlslComputeSt(that) + newMain;\n  };\n};\n\nfunction getDefaultShader(source, applyHighlight) {\n  source = ShaderSource.replaceMain(source, \"tile_main\");\n\n  if (!applyHighlight) {\n    return (\n      source +\n      \"void tile_color(vec4 tile_featureColor) \\n\" +\n      \"{ \\n\" +\n      \"    tile_main(); \\n\" +\n      \"} \\n\"\n    );\n  }\n\n  // The color blend mode is intended for the RGB channels so alpha is always just multiplied.\n  // gl_FragColor is multiplied by the tile color only when tile_colorBlend is 0.0 (highlight)\n  return (\n    source +\n    \"uniform float tile_colorBlend; \\n\" +\n    \"void tile_color(vec4 tile_featureColor) \\n\" +\n    \"{ \\n\" +\n    \"    tile_main(); \\n\" +\n    \"    tile_featureColor = czm_gammaCorrect(tile_featureColor); \\n\" +\n    \"    gl_FragColor.a *= tile_featureColor.a; \\n\" +\n    \"    float highlight = ceil(tile_colorBlend); \\n\" +\n    \"    gl_FragColor.rgb *= mix(tile_featureColor.rgb, vec3(1.0), highlight); \\n\" +\n    \"} \\n\"\n  );\n}\n\nfunction replaceDiffuseTextureCalls(source, diffuseAttributeOrUniformName) {\n  var functionCall = \"texture2D(\" + diffuseAttributeOrUniformName;\n\n  var fromIndex = 0;\n  var startIndex = source.indexOf(functionCall, fromIndex);\n  var endIndex;\n\n  while (startIndex > -1) {\n    var nestedLevel = 0;\n    for (var i = startIndex; i < source.length; ++i) {\n      var character = source.charAt(i);\n      if (character === \"(\") {\n        ++nestedLevel;\n      } else if (character === \")\") {\n        --nestedLevel;\n        if (nestedLevel === 0) {\n          endIndex = i + 1;\n          break;\n        }\n      }\n    }\n    var extractedFunction = source.slice(startIndex, endIndex);\n    var replacedFunction =\n      \"tile_diffuse_final(\" + extractedFunction + \", tile_diffuse)\";\n\n    source =\n      source.slice(0, startIndex) + replacedFunction + source.slice(endIndex);\n    fromIndex = startIndex + replacedFunction.length;\n    startIndex = source.indexOf(functionCall, fromIndex);\n  }\n\n  return source;\n}\n\nfunction modifyDiffuse(source, diffuseAttributeOrUniformName, applyHighlight) {\n  // If the glTF does not specify the _3DTILESDIFFUSE semantic, return the default shader.\n  // Otherwise if _3DTILESDIFFUSE is defined prefer the shader below that can switch the color mode at runtime.\n  if (!defined(diffuseAttributeOrUniformName)) {\n    return getDefaultShader(source, applyHighlight);\n  }\n\n  // Find the diffuse uniform. Examples matches:\n  //   uniform vec3 u_diffuseColor;\n  //   uniform sampler2D diffuseTexture;\n  var regex = new RegExp(\n    \"(uniform|attribute|in)\\\\s+(vec[34]|sampler2D)\\\\s+\" +\n      diffuseAttributeOrUniformName +\n      \";\"\n  );\n  var uniformMatch = source.match(regex);\n\n  if (!defined(uniformMatch)) {\n    // Could not find uniform declaration of type vec3, vec4, or sampler2D\n    return getDefaultShader(source, applyHighlight);\n  }\n\n  var declaration = uniformMatch[0];\n  var type = uniformMatch[2];\n\n  source = ShaderSource.replaceMain(source, \"tile_main\");\n  source = source.replace(declaration, \"\"); // Remove uniform declaration for now so the replace below doesn't affect it\n\n  // If the tile color is white, use the source color. This implies the feature has not been styled.\n  // Highlight: tile_colorBlend is 0.0 and the source color is used\n  // Replace: tile_colorBlend is 1.0 and the tile color is used\n  // Mix: tile_colorBlend is between 0.0 and 1.0, causing the source color and tile color to mix\n  var finalDiffuseFunction =\n    \"bool isWhite(vec3 color) \\n\" +\n    \"{ \\n\" +\n    \"    return all(greaterThan(color, vec3(1.0 - czm_epsilon3))); \\n\" +\n    \"} \\n\" +\n    \"vec4 tile_diffuse_final(vec4 sourceDiffuse, vec4 tileDiffuse) \\n\" +\n    \"{ \\n\" +\n    \"    vec4 blendDiffuse = mix(sourceDiffuse, tileDiffuse, tile_colorBlend); \\n\" +\n    \"    vec4 diffuse = isWhite(tileDiffuse.rgb) ? sourceDiffuse : blendDiffuse; \\n\" +\n    \"    return vec4(diffuse.rgb, sourceDiffuse.a); \\n\" +\n    \"} \\n\";\n\n  // The color blend mode is intended for the RGB channels so alpha is always just multiplied.\n  // gl_FragColor is multiplied by the tile color only when tile_colorBlend is 0.0 (highlight)\n  var highlight =\n    \"    tile_featureColor = czm_gammaCorrect(tile_featureColor); \\n\" +\n    \"    gl_FragColor.a *= tile_featureColor.a; \\n\" +\n    \"    float highlight = ceil(tile_colorBlend); \\n\" +\n    \"    gl_FragColor.rgb *= mix(tile_featureColor.rgb, vec3(1.0), highlight); \\n\";\n\n  var setColor;\n  if (type === \"vec3\" || type === \"vec4\") {\n    var sourceDiffuse =\n      type === \"vec3\"\n        ? \"vec4(\" + diffuseAttributeOrUniformName + \", 1.0)\"\n        : diffuseAttributeOrUniformName;\n    var replaceDiffuse = type === \"vec3\" ? \"tile_diffuse.xyz\" : \"tile_diffuse\";\n    regex = new RegExp(diffuseAttributeOrUniformName, \"g\");\n    source = source.replace(regex, replaceDiffuse);\n    setColor =\n      \"    vec4 source = \" +\n      sourceDiffuse +\n      \"; \\n\" +\n      \"    tile_diffuse = tile_diffuse_final(source, tile_featureColor); \\n\" +\n      \"    tile_main(); \\n\";\n  } else if (type === \"sampler2D\") {\n    // Handles any number of nested parentheses\n    // E.g. texture2D(u_diffuse, uv)\n    // E.g. texture2D(u_diffuse, computeUV(index))\n    source = replaceDiffuseTextureCalls(source, diffuseAttributeOrUniformName);\n    setColor =\n      \"    tile_diffuse = tile_featureColor; \\n\" + \"    tile_main(); \\n\";\n  }\n\n  source =\n    \"uniform float tile_colorBlend; \\n\" +\n    \"vec4 tile_diffuse = vec4(1.0); \\n\" +\n    finalDiffuseFunction +\n    declaration +\n    \"\\n\" +\n    source +\n    \"\\n\" +\n    \"void tile_color(vec4 tile_featureColor) \\n\" +\n    \"{ \\n\" +\n    setColor;\n\n  if (applyHighlight) {\n    source += highlight;\n  }\n\n  source += \"} \\n\";\n  return source;\n}\n\nCesium3DTileBatchTable.prototype.getFragmentShaderCallback = function (\n  handleTranslucent,\n  diffuseAttributeOrUniformName\n) {\n  if (this.featuresLength === 0) {\n    return;\n  }\n  return function (source) {\n    source = modifyDiffuse(source, diffuseAttributeOrUniformName, true);\n    if (ContextLimits.maximumVertexTextureImageUnits > 0) {\n      // When VTF is supported, per-feature show/hide already happened in the fragment shader\n      source +=\n        \"uniform sampler2D tile_pickTexture; \\n\" +\n        \"varying vec2 tile_featureSt; \\n\" +\n        \"varying vec4 tile_featureColor; \\n\" +\n        \"void main() \\n\" +\n        \"{ \\n\" +\n        \"    tile_color(tile_featureColor); \\n\" +\n        \"}\";\n    } else {\n      if (handleTranslucent) {\n        source += \"uniform bool tile_translucentCommand; \\n\";\n      }\n      source +=\n        \"uniform sampler2D tile_pickTexture; \\n\" +\n        \"uniform sampler2D tile_batchTexture; \\n\" +\n        \"varying vec2 tile_featureSt; \\n\" +\n        \"void main() \\n\" +\n        \"{ \\n\" +\n        \"    vec4 featureProperties = texture2D(tile_batchTexture, tile_featureSt); \\n\" +\n        \"    if (featureProperties.a == 0.0) { \\n\" + // show: alpha == 0 - false, non-zeo - true\n        \"        discard; \\n\" +\n        \"    } \\n\";\n\n      if (handleTranslucent) {\n        source +=\n          \"    bool isStyleTranslucent = (featureProperties.a != 1.0); \\n\" +\n          \"    if (czm_pass == czm_passTranslucent) \\n\" +\n          \"    { \\n\" +\n          \"        if (!isStyleTranslucent && !tile_translucentCommand) \\n\" + // Do not render opaque features in the translucent pass\n          \"        { \\n\" +\n          \"            discard; \\n\" +\n          \"        } \\n\" +\n          \"    } \\n\" +\n          \"    else \\n\" +\n          \"    { \\n\" +\n          \"        if (isStyleTranslucent) \\n\" + // Do not render translucent features in the opaque pass\n          \"        { \\n\" +\n          \"            discard; \\n\" +\n          \"        } \\n\" +\n          \"    } \\n\";\n      }\n\n      source += \"    tile_color(featureProperties); \\n\" + \"} \\n\";\n    }\n    return source;\n  };\n};\n\nCesium3DTileBatchTable.prototype.getClassificationFragmentShaderCallback = function () {\n  if (this.featuresLength === 0) {\n    return;\n  }\n  return function (source) {\n    source = ShaderSource.replaceMain(source, \"tile_main\");\n    if (ContextLimits.maximumVertexTextureImageUnits > 0) {\n      // When VTF is supported, per-feature show/hide already happened in the fragment shader\n      source +=\n        \"uniform sampler2D tile_pickTexture;\\n\" +\n        \"varying vec2 tile_featureSt; \\n\" +\n        \"varying vec4 tile_featureColor; \\n\" +\n        \"void main() \\n\" +\n        \"{ \\n\" +\n        \"    tile_main(); \\n\" +\n        \"    gl_FragColor = tile_featureColor; \\n\" +\n        \"}\";\n    } else {\n      source +=\n        \"uniform sampler2D tile_batchTexture; \\n\" +\n        \"uniform sampler2D tile_pickTexture;\\n\" +\n        \"varying vec2 tile_featureSt; \\n\" +\n        \"void main() \\n\" +\n        \"{ \\n\" +\n        \"    tile_main(); \\n\" +\n        \"    vec4 featureProperties = texture2D(tile_batchTexture, tile_featureSt); \\n\" +\n        \"    if (featureProperties.a == 0.0) { \\n\" + // show: alpha == 0 - false, non-zeo - true\n        \"        discard; \\n\" +\n        \"    } \\n\" +\n        \"    gl_FragColor = featureProperties; \\n\" +\n        \"} \\n\";\n    }\n    return source;\n  };\n};\n\nfunction getColorBlend(batchTable) {\n  var tileset = batchTable._content.tileset;\n  var colorBlendMode = tileset.colorBlendMode;\n  var colorBlendAmount = tileset.colorBlendAmount;\n  if (colorBlendMode === Cesium3DTileColorBlendMode.HIGHLIGHT) {\n    return 0.0;\n  }\n  if (colorBlendMode === Cesium3DTileColorBlendMode.REPLACE) {\n    return 1.0;\n  }\n  if (colorBlendMode === Cesium3DTileColorBlendMode.MIX) {\n    // The value 0.0 is reserved for highlight, so clamp to just above 0.0.\n    return CesiumMath.clamp(colorBlendAmount, CesiumMath.EPSILON4, 1.0);\n  }\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(\n    'Invalid color blend mode \"' + colorBlendMode + '\".'\n  );\n  //>>includeEnd('debug');\n}\n\nCesium3DTileBatchTable.prototype.getUniformMapCallback = function () {\n  if (this.featuresLength === 0) {\n    return;\n  }\n\n  var that = this;\n  return function (uniformMap) {\n    var batchUniformMap = {\n      tile_batchTexture: function () {\n        // PERFORMANCE_IDEA: we could also use a custom shader that avoids the texture read.\n        return defaultValue(that._batchTexture, that._defaultTexture);\n      },\n      tile_textureDimensions: function () {\n        return that._textureDimensions;\n      },\n      tile_textureStep: function () {\n        return that._textureStep;\n      },\n      tile_colorBlend: function () {\n        return getColorBlend(that);\n      },\n      tile_pickTexture: function () {\n        return that._pickTexture;\n      },\n    };\n\n    return combine(uniformMap, batchUniformMap);\n  };\n};\n\nCesium3DTileBatchTable.prototype.getPickId = function () {\n  return \"texture2D(tile_pickTexture, tile_featureSt)\";\n};\n\n///////////////////////////////////////////////////////////////////////////\n\nvar StyleCommandsNeeded = {\n  ALL_OPAQUE: 0,\n  ALL_TRANSLUCENT: 1,\n  OPAQUE_AND_TRANSLUCENT: 2,\n};\n\nCesium3DTileBatchTable.prototype.addDerivedCommands = function (\n  frameState,\n  commandStart\n) {\n  var commandList = frameState.commandList;\n  var commandEnd = commandList.length;\n  var tile = this._content._tile;\n  var finalResolution = tile._finalResolution;\n  var tileset = tile.tileset;\n  var bivariateVisibilityTest =\n    tileset._skipLevelOfDetail &&\n    tileset._hasMixedContent &&\n    frameState.context.stencilBuffer;\n  var styleCommandsNeeded = getStyleCommandsNeeded(this);\n\n  for (var i = commandStart; i < commandEnd; ++i) {\n    var command = commandList[i];\n    var derivedCommands = command.derivedCommands.tileset;\n    if (!defined(derivedCommands) || command.dirty) {\n      derivedCommands = {};\n      command.derivedCommands.tileset = derivedCommands;\n      derivedCommands.originalCommand = deriveCommand(command);\n      command.dirty = false;\n    }\n    var originalCommand = derivedCommands.originalCommand;\n\n    if (\n      styleCommandsNeeded !== StyleCommandsNeeded.ALL_OPAQUE &&\n      command.pass !== Pass.TRANSLUCENT\n    ) {\n      if (!defined(derivedCommands.translucent)) {\n        derivedCommands.translucent = deriveTranslucentCommand(originalCommand);\n      }\n    }\n\n    if (\n      styleCommandsNeeded !== StyleCommandsNeeded.ALL_TRANSLUCENT &&\n      command.pass !== Pass.TRANSLUCENT\n    ) {\n      if (!defined(derivedCommands.opaque)) {\n        derivedCommands.opaque = deriveOpaqueCommand(originalCommand);\n      }\n\n      if (bivariateVisibilityTest) {\n        if (!finalResolution) {\n          if (!defined(derivedCommands.zback)) {\n            derivedCommands.zback = deriveZBackfaceCommand(\n              frameState.context,\n              originalCommand\n            );\n          }\n          tileset._backfaceCommands.push(derivedCommands.zback);\n        }\n        if (\n          !defined(derivedCommands.stencil) ||\n          tile._selectionDepth !==\n            getLastSelectionDepth(derivedCommands.stencil)\n        ) {\n          if (command.renderState.depthMask) {\n            derivedCommands.stencil = deriveStencilCommand(\n              originalCommand,\n              tile._selectionDepth\n            );\n          } else {\n            // Ignore if tile does not write depth\n            derivedCommands.stencil = derivedCommands.opaque;\n          }\n        }\n      }\n    }\n\n    var opaqueCommand = bivariateVisibilityTest\n      ? derivedCommands.stencil\n      : derivedCommands.opaque;\n    var translucentCommand = derivedCommands.translucent;\n\n    // If the command was originally opaque:\n    //    * If the styling applied to the tile is all opaque, use the opaque command\n    //      (with one additional uniform needed for the shader).\n    //    * If the styling is all translucent, use new (cached) derived commands (front\n    //      and back faces) with a translucent render state.\n    //    * If the styling causes both opaque and translucent features in this tile,\n    //      then use both sets of commands.\n    if (command.pass !== Pass.TRANSLUCENT) {\n      if (styleCommandsNeeded === StyleCommandsNeeded.ALL_OPAQUE) {\n        commandList[i] = opaqueCommand;\n      }\n      if (styleCommandsNeeded === StyleCommandsNeeded.ALL_TRANSLUCENT) {\n        commandList[i] = translucentCommand;\n      }\n      if (styleCommandsNeeded === StyleCommandsNeeded.OPAQUE_AND_TRANSLUCENT) {\n        // PERFORMANCE_IDEA: if the tile has multiple commands, we do not know what features are in what\n        // commands so this case may be overkill.\n        commandList[i] = opaqueCommand;\n        commandList.push(translucentCommand);\n      }\n    } else {\n      // Command was originally translucent so no need to derive new commands;\n      // as of now, a style can't change an originally translucent feature to\n      // opaque since the style's alpha is modulated, not a replacement.  When\n      // this changes, we need to derive new opaque commands here.\n      commandList[i] = originalCommand;\n    }\n  }\n};\n\nfunction getStyleCommandsNeeded(batchTable) {\n  var translucentFeaturesLength = batchTable._translucentFeaturesLength;\n\n  if (translucentFeaturesLength === 0) {\n    return StyleCommandsNeeded.ALL_OPAQUE;\n  } else if (translucentFeaturesLength === batchTable.featuresLength) {\n    return StyleCommandsNeeded.ALL_TRANSLUCENT;\n  }\n\n  return StyleCommandsNeeded.OPAQUE_AND_TRANSLUCENT;\n}\n\nfunction deriveCommand(command) {\n  var derivedCommand = DrawCommand.shallowClone(command);\n\n  // Add a uniform to indicate if the original command was translucent so\n  // the shader knows not to cull vertices that were originally transparent\n  // even though their style is opaque.\n  var translucentCommand = derivedCommand.pass === Pass.TRANSLUCENT;\n\n  derivedCommand.uniformMap = defined(derivedCommand.uniformMap)\n    ? derivedCommand.uniformMap\n    : {};\n  derivedCommand.uniformMap.tile_translucentCommand = function () {\n    return translucentCommand;\n  };\n\n  return derivedCommand;\n}\n\nfunction deriveTranslucentCommand(command) {\n  var derivedCommand = DrawCommand.shallowClone(command);\n  derivedCommand.pass = Pass.TRANSLUCENT;\n  derivedCommand.renderState = getTranslucentRenderState(command.renderState);\n  return derivedCommand;\n}\n\nfunction deriveOpaqueCommand(command) {\n  var derivedCommand = DrawCommand.shallowClone(command);\n  derivedCommand.renderState = getOpaqueRenderState(command.renderState);\n  return derivedCommand;\n}\n\nfunction getLogDepthPolygonOffsetFragmentShaderProgram(context, shaderProgram) {\n  var shader = context.shaderCache.getDerivedShaderProgram(\n    shaderProgram,\n    \"zBackfaceLogDepth\"\n  );\n  if (!defined(shader)) {\n    var fs = shaderProgram.fragmentShaderSource.clone();\n    fs.defines = defined(fs.defines) ? fs.defines.slice(0) : [];\n    fs.defines.push(\"POLYGON_OFFSET\");\n\n    fs.sources.unshift(\n      \"#ifdef GL_OES_standard_derivatives\\n#extension GL_OES_standard_derivatives : enable\\n#endif\\n\"\n    );\n    shader = context.shaderCache.createDerivedShaderProgram(\n      shaderProgram,\n      \"zBackfaceLogDepth\",\n      {\n        vertexShaderSource: shaderProgram.vertexShaderSource,\n        fragmentShaderSource: fs,\n        attributeLocations: shaderProgram._attributeLocations,\n      }\n    );\n  }\n\n  return shader;\n}\n\nfunction deriveZBackfaceCommand(context, command) {\n  // Write just backface depth of unresolved tiles so resolved stenciled tiles do not appear in front\n  var derivedCommand = DrawCommand.shallowClone(command);\n  var rs = clone(derivedCommand.renderState, true);\n  rs.cull.enabled = true;\n  rs.cull.face = CullFace.FRONT;\n  // Back faces do not need to write color.\n  rs.colorMask = {\n    red: false,\n    green: false,\n    blue: false,\n    alpha: false,\n  };\n  // Push back face depth away from the camera so it is less likely that back faces and front faces of the same tile\n  // intersect and overlap. This helps avoid flickering for very thin double-sided walls.\n  rs.polygonOffset = {\n    enabled: true,\n    factor: 5.0,\n    units: 5.0,\n  };\n  // Set the 3D Tiles bit\n  rs.stencilTest = StencilConstants.setCesium3DTileBit();\n  rs.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK;\n\n  derivedCommand.renderState = RenderState.fromCache(rs);\n  derivedCommand.castShadows = false;\n  derivedCommand.receiveShadows = false;\n  derivedCommand.uniformMap = clone(command.uniformMap);\n\n  var polygonOffset = new Cartesian2(5.0, 5.0);\n  derivedCommand.uniformMap.u_polygonOffset = function () {\n    return polygonOffset;\n  };\n\n  // Make the log depth depth fragment write account for the polygon offset, too.\n  // Otherwise, the back face commands will cause the higher resolution\n  // tiles to disappear.\n  derivedCommand.shaderProgram = getLogDepthPolygonOffsetFragmentShaderProgram(\n    context,\n    command.shaderProgram\n  );\n  return derivedCommand;\n}\n\nfunction deriveStencilCommand(command, reference) {\n  // Tiles only draw if their selection depth is >= the tile drawn already. They write their\n  // selection depth to the stencil buffer to prevent ancestor tiles from drawing on top\n  var derivedCommand = DrawCommand.shallowClone(command);\n  var rs = clone(derivedCommand.renderState, true);\n  // Stencil test is masked to the most significant 3 bits so the reference is shifted. Writes 0 for the terrain bit\n  rs.stencilTest.enabled = true;\n  rs.stencilTest.mask = StencilConstants.SKIP_LOD_MASK;\n  rs.stencilTest.reference =\n    StencilConstants.CESIUM_3D_TILE_MASK |\n    (reference << StencilConstants.SKIP_LOD_BIT_SHIFT);\n  rs.stencilTest.frontFunction = StencilFunction.GREATER_OR_EQUAL;\n  rs.stencilTest.frontOperation.zPass = StencilOperation.REPLACE;\n  rs.stencilTest.backFunction = StencilFunction.GREATER_OR_EQUAL;\n  rs.stencilTest.backOperation.zPass = StencilOperation.REPLACE;\n  rs.stencilMask =\n    StencilConstants.CESIUM_3D_TILE_MASK | StencilConstants.SKIP_LOD_MASK;\n  derivedCommand.renderState = RenderState.fromCache(rs);\n  return derivedCommand;\n}\n\nfunction getLastSelectionDepth(stencilCommand) {\n  // Isolate the selection depth from the stencil reference.\n  var reference = stencilCommand.renderState.stencilTest.reference;\n  return (\n    (reference & StencilConstants.SKIP_LOD_MASK) >>>\n    StencilConstants.SKIP_LOD_BIT_SHIFT\n  );\n}\n\nfunction getTranslucentRenderState(renderState) {\n  var rs = clone(renderState, true);\n  rs.cull.enabled = false;\n  rs.depthTest.enabled = true;\n  rs.depthMask = false;\n  rs.blending = BlendingState.ALPHA_BLEND;\n\n  return RenderState.fromCache(rs);\n}\n\nfunction getOpaqueRenderState(renderState) {\n  var rs = clone(renderState, true);\n  rs.stencilTest = StencilConstants.setCesium3DTileBit();\n  rs.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK;\n\n  return RenderState.fromCache(rs);\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction createTexture(batchTable, context, bytes) {\n  var dimensions = batchTable._textureDimensions;\n  return new Texture({\n    context: context,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n    source: {\n      width: dimensions.x,\n      height: dimensions.y,\n      arrayBufferView: bytes,\n    },\n    flipY: false,\n    sampler: Sampler.NEAREST,\n  });\n}\n\nfunction createPickTexture(batchTable, context) {\n  var featuresLength = batchTable.featuresLength;\n  if (!defined(batchTable._pickTexture) && featuresLength > 0) {\n    var pickIds = batchTable._pickIds;\n    var byteLength = getByteLength(batchTable);\n    var bytes = new Uint8Array(byteLength);\n    var content = batchTable._content;\n\n    // PERFORMANCE_IDEA: we could skip the pick texture completely by allocating\n    // a continuous range of pickIds and then converting the base pickId + batchId\n    // to RGBA in the shader.  The only consider is precision issues, which might\n    // not be an issue in WebGL 2.\n    for (var i = 0; i < featuresLength; ++i) {\n      var pickId = context.createPickId(content.getFeature(i));\n      pickIds.push(pickId);\n\n      var pickColor = pickId.color;\n      var offset = i * 4;\n      bytes[offset] = Color.floatToByte(pickColor.red);\n      bytes[offset + 1] = Color.floatToByte(pickColor.green);\n      bytes[offset + 2] = Color.floatToByte(pickColor.blue);\n      bytes[offset + 3] = Color.floatToByte(pickColor.alpha);\n    }\n\n    batchTable._pickTexture = createTexture(batchTable, context, bytes);\n    content.tileset._statistics.batchTableByteLength +=\n      batchTable._pickTexture.sizeInBytes;\n  }\n}\n\nfunction updateBatchTexture(batchTable) {\n  var dimensions = batchTable._textureDimensions;\n  // PERFORMANCE_IDEA: Instead of rewriting the entire texture, use fine-grained\n  // texture updates when less than, for example, 10%, of the values changed.  Or\n  // even just optimize the common case when one feature show/color changed.\n  batchTable._batchTexture.copyFrom({\n    width: dimensions.x,\n    height: dimensions.y,\n    arrayBufferView: batchTable._batchValues,\n  });\n}\n\nCesium3DTileBatchTable.prototype.update = function (tileset, frameState) {\n  var context = frameState.context;\n  this._defaultTexture = context.defaultTexture;\n\n  var passes = frameState.passes;\n  if (passes.pick || passes.postProcess) {\n    createPickTexture(this, context);\n  }\n\n  if (this._batchValuesDirty) {\n    this._batchValuesDirty = false;\n\n    // Create batch texture on-demand\n    if (!defined(this._batchTexture)) {\n      this._batchTexture = createTexture(this, context, this._batchValues);\n      tileset._statistics.batchTableByteLength += this._batchTexture.sizeInBytes;\n    }\n\n    updateBatchTexture(this); // Apply per-feature show/color updates\n  }\n};\n\nCesium3DTileBatchTable.prototype.isDestroyed = function () {\n  return false;\n};\n\nCesium3DTileBatchTable.prototype.destroy = function () {\n  this._batchTexture = this._batchTexture && this._batchTexture.destroy();\n  this._pickTexture = this._pickTexture && this._pickTexture.destroy();\n\n  var pickIds = this._pickIds;\n  var length = pickIds.length;\n  for (var i = 0; i < length; ++i) {\n    pickIds[i].destroy();\n  }\n\n  return destroyObject(this);\n};\nexport default Cesium3DTileBatchTable;\n"]},"metadata":{},"sourceType":"module"}