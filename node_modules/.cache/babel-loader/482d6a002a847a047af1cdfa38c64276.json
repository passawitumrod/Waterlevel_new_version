{"ast":null,"code":"import defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport RuntimeError from \"./RuntimeError.js\";\n/**\n * @private\n */\n\nfunction getStringFromTypedArray(uint8Array, byteOffset, byteLength) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(uint8Array)) {\n    throw new DeveloperError(\"uint8Array is required.\");\n  }\n\n  if (byteOffset < 0) {\n    throw new DeveloperError(\"byteOffset cannot be negative.\");\n  }\n\n  if (byteLength < 0) {\n    throw new DeveloperError(\"byteLength cannot be negative.\");\n  }\n\n  if (byteOffset + byteLength > uint8Array.byteLength) {\n    throw new DeveloperError(\"sub-region exceeds array bounds.\");\n  } //>>includeEnd('debug');\n\n\n  byteOffset = defaultValue(byteOffset, 0);\n  byteLength = defaultValue(byteLength, uint8Array.byteLength - byteOffset);\n  uint8Array = uint8Array.subarray(byteOffset, byteOffset + byteLength);\n  return getStringFromTypedArray.decode(uint8Array);\n} // Exposed functions for testing\n\n\ngetStringFromTypedArray.decodeWithTextDecoder = function (view) {\n  var decoder = new TextDecoder(\"utf-8\");\n  return decoder.decode(view);\n};\n\ngetStringFromTypedArray.decodeWithFromCharCode = function (view) {\n  var result = \"\";\n  var codePoints = utf8Handler(view);\n  var length = codePoints.length;\n\n  for (var i = 0; i < length; ++i) {\n    var cp = codePoints[i];\n\n    if (cp <= 0xffff) {\n      result += String.fromCharCode(cp);\n    } else {\n      cp -= 0x10000;\n      result += String.fromCharCode((cp >> 10) + 0xd800, (cp & 0x3ff) + 0xdc00);\n    }\n  }\n\n  return result;\n};\n\nfunction inRange(a, min, max) {\n  return min <= a && a <= max;\n} // This code is inspired by public domain code found here: https://github.com/inexorabletash/text-encoding\n\n\nfunction utf8Handler(utfBytes) {\n  var codePoint = 0;\n  var bytesSeen = 0;\n  var bytesNeeded = 0;\n  var lowerBoundary = 0x80;\n  var upperBoundary = 0xbf;\n  var codePoints = [];\n  var length = utfBytes.length;\n\n  for (var i = 0; i < length; ++i) {\n    var currentByte = utfBytes[i]; // If bytesNeeded = 0, then we are starting a new character\n\n    if (bytesNeeded === 0) {\n      // 1 Byte Ascii character\n      if (inRange(currentByte, 0x00, 0x7f)) {\n        // Return a code point whose value is byte.\n        codePoints.push(currentByte);\n        continue;\n      } // 2 Byte character\n\n\n      if (inRange(currentByte, 0xc2, 0xdf)) {\n        bytesNeeded = 1;\n        codePoint = currentByte & 0x1f;\n        continue;\n      } // 3 Byte character\n\n\n      if (inRange(currentByte, 0xe0, 0xef)) {\n        // If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n        if (currentByte === 0xe0) {\n          lowerBoundary = 0xa0;\n        } // If byte is 0xED, set utf-8 upper boundary to 0x9F.\n\n\n        if (currentByte === 0xed) {\n          upperBoundary = 0x9f;\n        }\n\n        bytesNeeded = 2;\n        codePoint = currentByte & 0xf;\n        continue;\n      } // 4 Byte character\n\n\n      if (inRange(currentByte, 0xf0, 0xf4)) {\n        // If byte is 0xF0, set utf-8 lower boundary to 0x90.\n        if (currentByte === 0xf0) {\n          lowerBoundary = 0x90;\n        } // If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n\n\n        if (currentByte === 0xf4) {\n          upperBoundary = 0x8f;\n        }\n\n        bytesNeeded = 3;\n        codePoint = currentByte & 0x7;\n        continue;\n      }\n\n      throw new RuntimeError(\"String decoding failed.\");\n    } // Out of range, so ignore the first part(s) of the character and continue with this byte on its own\n\n\n    if (!inRange(currentByte, lowerBoundary, upperBoundary)) {\n      codePoint = bytesNeeded = bytesSeen = 0;\n      lowerBoundary = 0x80;\n      upperBoundary = 0xbf;\n      --i;\n      continue;\n    } // Set appropriate boundaries, since we've now checked byte 2 of a potential longer character\n\n\n    lowerBoundary = 0x80;\n    upperBoundary = 0xbf; // Add byte to code point\n\n    codePoint = codePoint << 6 | currentByte & 0x3f; // We have the correct number of bytes, so push and reset for next character\n\n    ++bytesSeen;\n\n    if (bytesSeen === bytesNeeded) {\n      codePoints.push(codePoint);\n      codePoint = bytesNeeded = bytesSeen = 0;\n    }\n  }\n\n  return codePoints;\n}\n\nif (typeof TextDecoder !== \"undefined\") {\n  getStringFromTypedArray.decode = getStringFromTypedArray.decodeWithTextDecoder;\n} else {\n  getStringFromTypedArray.decode = getStringFromTypedArray.decodeWithFromCharCode;\n}\n\nexport default getStringFromTypedArray;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/getStringFromTypedArray.js"],"names":["defaultValue","defined","DeveloperError","RuntimeError","getStringFromTypedArray","uint8Array","byteOffset","byteLength","subarray","decode","decodeWithTextDecoder","view","decoder","TextDecoder","decodeWithFromCharCode","result","codePoints","utf8Handler","length","i","cp","String","fromCharCode","inRange","a","min","max","utfBytes","codePoint","bytesSeen","bytesNeeded","lowerBoundary","upperBoundary","currentByte","push"],"mappings":"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","sourcesContent":["import defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport RuntimeError from \"./RuntimeError.js\";\n\n/**\n * @private\n */\nfunction getStringFromTypedArray(uint8Array, byteOffset, byteLength) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(uint8Array)) {\n    throw new DeveloperError(\"uint8Array is required.\");\n  }\n  if (byteOffset < 0) {\n    throw new DeveloperError(\"byteOffset cannot be negative.\");\n  }\n  if (byteLength < 0) {\n    throw new DeveloperError(\"byteLength cannot be negative.\");\n  }\n  if (byteOffset + byteLength > uint8Array.byteLength) {\n    throw new DeveloperError(\"sub-region exceeds array bounds.\");\n  }\n  //>>includeEnd('debug');\n\n  byteOffset = defaultValue(byteOffset, 0);\n  byteLength = defaultValue(byteLength, uint8Array.byteLength - byteOffset);\n\n  uint8Array = uint8Array.subarray(byteOffset, byteOffset + byteLength);\n\n  return getStringFromTypedArray.decode(uint8Array);\n}\n\n// Exposed functions for testing\ngetStringFromTypedArray.decodeWithTextDecoder = function (view) {\n  var decoder = new TextDecoder(\"utf-8\");\n  return decoder.decode(view);\n};\n\ngetStringFromTypedArray.decodeWithFromCharCode = function (view) {\n  var result = \"\";\n  var codePoints = utf8Handler(view);\n  var length = codePoints.length;\n  for (var i = 0; i < length; ++i) {\n    var cp = codePoints[i];\n    if (cp <= 0xffff) {\n      result += String.fromCharCode(cp);\n    } else {\n      cp -= 0x10000;\n      result += String.fromCharCode((cp >> 10) + 0xd800, (cp & 0x3ff) + 0xdc00);\n    }\n  }\n  return result;\n};\n\nfunction inRange(a, min, max) {\n  return min <= a && a <= max;\n}\n\n// This code is inspired by public domain code found here: https://github.com/inexorabletash/text-encoding\nfunction utf8Handler(utfBytes) {\n  var codePoint = 0;\n  var bytesSeen = 0;\n  var bytesNeeded = 0;\n  var lowerBoundary = 0x80;\n  var upperBoundary = 0xbf;\n\n  var codePoints = [];\n  var length = utfBytes.length;\n  for (var i = 0; i < length; ++i) {\n    var currentByte = utfBytes[i];\n\n    // If bytesNeeded = 0, then we are starting a new character\n    if (bytesNeeded === 0) {\n      // 1 Byte Ascii character\n      if (inRange(currentByte, 0x00, 0x7f)) {\n        // Return a code point whose value is byte.\n        codePoints.push(currentByte);\n        continue;\n      }\n\n      // 2 Byte character\n      if (inRange(currentByte, 0xc2, 0xdf)) {\n        bytesNeeded = 1;\n        codePoint = currentByte & 0x1f;\n        continue;\n      }\n\n      // 3 Byte character\n      if (inRange(currentByte, 0xe0, 0xef)) {\n        // If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n        if (currentByte === 0xe0) {\n          lowerBoundary = 0xa0;\n        }\n        // If byte is 0xED, set utf-8 upper boundary to 0x9F.\n        if (currentByte === 0xed) {\n          upperBoundary = 0x9f;\n        }\n\n        bytesNeeded = 2;\n        codePoint = currentByte & 0xf;\n        continue;\n      }\n\n      // 4 Byte character\n      if (inRange(currentByte, 0xf0, 0xf4)) {\n        // If byte is 0xF0, set utf-8 lower boundary to 0x90.\n        if (currentByte === 0xf0) {\n          lowerBoundary = 0x90;\n        }\n        // If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n        if (currentByte === 0xf4) {\n          upperBoundary = 0x8f;\n        }\n\n        bytesNeeded = 3;\n        codePoint = currentByte & 0x7;\n        continue;\n      }\n\n      throw new RuntimeError(\"String decoding failed.\");\n    }\n\n    // Out of range, so ignore the first part(s) of the character and continue with this byte on its own\n    if (!inRange(currentByte, lowerBoundary, upperBoundary)) {\n      codePoint = bytesNeeded = bytesSeen = 0;\n      lowerBoundary = 0x80;\n      upperBoundary = 0xbf;\n      --i;\n      continue;\n    }\n\n    // Set appropriate boundaries, since we've now checked byte 2 of a potential longer character\n    lowerBoundary = 0x80;\n    upperBoundary = 0xbf;\n\n    // Add byte to code point\n    codePoint = (codePoint << 6) | (currentByte & 0x3f);\n\n    // We have the correct number of bytes, so push and reset for next character\n    ++bytesSeen;\n    if (bytesSeen === bytesNeeded) {\n      codePoints.push(codePoint);\n      codePoint = bytesNeeded = bytesSeen = 0;\n    }\n  }\n\n  return codePoints;\n}\n\nif (typeof TextDecoder !== \"undefined\") {\n  getStringFromTypedArray.decode =\n    getStringFromTypedArray.decodeWithTextDecoder;\n} else {\n  getStringFromTypedArray.decode =\n    getStringFromTypedArray.decodeWithFromCharCode;\n}\nexport default getStringFromTypedArray;\n"]},"metadata":{},"sourceType":"module"}