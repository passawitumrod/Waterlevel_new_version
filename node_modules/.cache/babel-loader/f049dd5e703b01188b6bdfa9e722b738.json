{"ast":null,"code":"/**\n * @license\n * Knockout ES5 plugin - https://github.com/SteveSanderson/knockout-es5\n * Copyright (c) Steve Sanderson\n * MIT license\n */\nvar OBSERVABLES_PROPERTY = '__knockoutObservables';\nvar SUBSCRIBABLE_PROPERTY = '__knockoutSubscribable'; // Model tracking\n// --------------\n//\n// This is the central feature of Knockout-ES5. We augment model objects by converting properties\n// into ES5 getter/setter pairs that read/write an underlying Knockout observable. This means you can\n// use plain JavaScript syntax to read/write the property while still getting the full benefits of\n// Knockout's automatic dependency detection and notification triggering.\n//\n// For comparison, here's Knockout ES3-compatible syntax:\n//\n//     var firstNameLength = myModel.user().firstName().length; // Read\n//     myModel.user().firstName('Bert'); // Write\n//\n// ... versus Knockout-ES5 syntax:\n//\n//     var firstNameLength = myModel.user.firstName.length; // Read\n//     myModel.user.firstName = 'Bert'; // Write\n// `ko.track(model)` converts each property on the given model object into a getter/setter pair that\n// wraps a Knockout observable. Optionally specify an array of property names to wrap; otherwise we\n// wrap all properties. If any of the properties are already observables, we replace them with\n// ES5 getter/setter pairs that wrap your original observable instances. In the case of readonly\n// ko.computed properties, we simply do not define a setter (so attempted writes will be ignored,\n// which is how ES5 readonly properties normally behave).\n//\n// By design, this does *not* recursively walk child object properties, because making literally\n// everything everywhere independently observable is usually unhelpful. When you do want to track\n// child object properties independently, define your own class for those child objects and put\n// a separate ko.track call into its constructor --- this gives you far more control.\n\nfunction track(obj, propertyNames) {\n  if (!obj\n  /*|| typeof obj !== 'object'*/\n  ) {\n      throw new Error('When calling ko.track, you must pass an object as the first parameter.');\n    }\n\n  var ko = this,\n      allObservablesForObject = getAllObservablesForObject(obj, true);\n  propertyNames = propertyNames || Object.getOwnPropertyNames(obj);\n  propertyNames.forEach(function (propertyName) {\n    // Skip storage properties\n    if (propertyName === OBSERVABLES_PROPERTY || propertyName === SUBSCRIBABLE_PROPERTY) {\n      return;\n    } // Skip properties that are already tracked\n\n\n    if (propertyName in allObservablesForObject) {\n      return;\n    }\n\n    var origValue = obj[propertyName],\n        isArray = origValue instanceof Array,\n        observable = ko.isObservable(origValue) ? origValue : isArray ? ko.observableArray(origValue) : ko.observable(origValue);\n    Object.defineProperty(obj, propertyName, {\n      configurable: true,\n      enumerable: true,\n      get: observable,\n      set: ko.isWriteableObservable(observable) ? observable : undefined\n    });\n    allObservablesForObject[propertyName] = observable;\n\n    if (isArray) {\n      notifyWhenPresentOrFutureArrayValuesMutate(ko, observable);\n    }\n  });\n  return obj;\n} // Gets or creates the hidden internal key-value collection of observables corresponding to\n// properties on the model object.\n\n\nfunction getAllObservablesForObject(obj, createIfNotDefined) {\n  var result = obj[OBSERVABLES_PROPERTY];\n\n  if (!result && createIfNotDefined) {\n    result = {};\n    Object.defineProperty(obj, OBSERVABLES_PROPERTY, {\n      value: result\n    });\n  }\n\n  return result;\n} // Computed properties\n// -------------------\n//\n// The preceding code is already sufficient to upgrade ko.computed model properties to ES5\n// getter/setter pairs (or in the case of readonly ko.computed properties, just a getter).\n// These then behave like a regular property with a getter function, except they are smarter:\n// your evaluator is only invoked when one of its dependencies changes. The result is cached\n// and used for all evaluations until the next time a dependency changes).\n//\n// However, instead of forcing developers to declare a ko.computed property explicitly, it's\n// nice to offer a utility function that declares a computed getter directly.\n// Implements `ko.defineProperty`\n\n\nfunction defineComputedProperty(obj, propertyName, evaluatorOrOptions) {\n  var ko = this,\n      computedOptions = {\n    owner: obj,\n    deferEvaluation: true\n  };\n\n  if (typeof evaluatorOrOptions === 'function') {\n    computedOptions.read = evaluatorOrOptions;\n  } else {\n    if ('value' in evaluatorOrOptions) {\n      throw new Error('For ko.defineProperty, you must not specify a \"value\" for the property. You must provide a \"get\" function.');\n    }\n\n    if (typeof evaluatorOrOptions.get !== 'function') {\n      throw new Error('For ko.defineProperty, the third parameter must be either an evaluator function, or an options object containing a function called \"get\".');\n    }\n\n    computedOptions.read = evaluatorOrOptions.get;\n    computedOptions.write = evaluatorOrOptions.set;\n  }\n\n  obj[propertyName] = ko.computed(computedOptions);\n  track.call(ko, obj, [propertyName]);\n  return obj;\n} // Array handling\n// --------------\n//\n// Arrays are special, because unlike other property types, they have standard mutator functions\n// (`push`/`pop`/`splice`/etc.) and it's desirable to trigger a change notification whenever one of\n// those mutator functions is invoked.\n//\n// Traditionally, Knockout handles this by putting special versions of `push`/`pop`/etc. on observable\n// arrays that mutate the underlying array and then trigger a notification. That approach doesn't\n// work for Knockout-ES5 because properties now return the underlying arrays, so the mutator runs\n// in the context of the underlying array, not any particular observable:\n//\n//     // Operates on the underlying array value\n//     myModel.someCollection.push('New value');\n//\n// To solve this, Knockout-ES5 detects array values, and modifies them as follows:\n//  1. Associates a hidden subscribable with each array instance that it encounters\n//  2. Intercepts standard mutators (`push`/`pop`/etc.) and makes them trigger the subscribable\n// Then, for model properties whose values are arrays, the property's underlying observable\n// subscribes to the array subscribable, so it can trigger a change notification after mutation.\n// Given an observable that underlies a model property, watch for any array value that might\n// be assigned as the property value, and hook into its change events\n\n\nfunction notifyWhenPresentOrFutureArrayValuesMutate(ko, observable) {\n  var watchingArraySubscription = null;\n  ko.computed(function () {\n    // Unsubscribe to any earlier array instance\n    if (watchingArraySubscription) {\n      watchingArraySubscription.dispose();\n      watchingArraySubscription = null;\n    } // Subscribe to the new array instance\n\n\n    var newArrayInstance = observable();\n\n    if (newArrayInstance instanceof Array) {\n      watchingArraySubscription = startWatchingArrayInstance(ko, observable, newArrayInstance);\n    }\n  });\n} // Listens for array mutations, and when they happen, cause the observable to fire notifications.\n// This is used to make model properties of type array fire notifications when the array changes.\n// Returns a subscribable that can later be disposed.\n\n\nfunction startWatchingArrayInstance(ko, observable, arrayInstance) {\n  var subscribable = getSubscribableForArray(ko, arrayInstance);\n  return subscribable.subscribe(observable);\n} // Gets or creates a subscribable that fires after each array mutation\n\n\nfunction getSubscribableForArray(ko, arrayInstance) {\n  var subscribable = arrayInstance[SUBSCRIBABLE_PROPERTY];\n\n  if (!subscribable) {\n    subscribable = new ko.subscribable();\n    Object.defineProperty(arrayInstance, SUBSCRIBABLE_PROPERTY, {\n      value: subscribable\n    });\n    var notificationPauseSignal = {};\n    wrapStandardArrayMutators(arrayInstance, subscribable, notificationPauseSignal);\n    addKnockoutArrayMutators(ko, arrayInstance, subscribable, notificationPauseSignal);\n  }\n\n  return subscribable;\n} // After each array mutation, fires a notification on the given subscribable\n\n\nfunction wrapStandardArrayMutators(arrayInstance, subscribable, notificationPauseSignal) {\n  ['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'].forEach(function (fnName) {\n    var origMutator = arrayInstance[fnName];\n\n    arrayInstance[fnName] = function () {\n      var result = origMutator.apply(this, arguments);\n\n      if (notificationPauseSignal.pause !== true) {\n        subscribable.notifySubscribers(this);\n      }\n\n      return result;\n    };\n  });\n} // Adds Knockout's additional array mutation functions to the array\n\n\nfunction addKnockoutArrayMutators(ko, arrayInstance, subscribable, notificationPauseSignal) {\n  ['remove', 'removeAll', 'destroy', 'destroyAll', 'replace'].forEach(function (fnName) {\n    // Make it a non-enumerable property for consistency with standard Array functions\n    Object.defineProperty(arrayInstance, fnName, {\n      enumerable: false,\n      value: function () {\n        var result; // These additional array mutators are built using the underlying push/pop/etc.\n        // mutators, which are wrapped to trigger notifications. But we don't want to\n        // trigger multiple notifications, so pause the push/pop/etc. wrappers and\n        // delivery only one notification at the end of the process.\n\n        notificationPauseSignal.pause = true;\n\n        try {\n          // Creates a temporary observableArray that can perform the operation.\n          result = ko.observableArray.fn[fnName].apply(ko.observableArray(arrayInstance), arguments);\n        } finally {\n          notificationPauseSignal.pause = false;\n        }\n\n        subscribable.notifySubscribers(arrayInstance);\n        return result;\n      }\n    });\n  });\n} // Static utility functions\n// ------------------------\n//\n// Since Knockout-ES5 sets up properties that return values, not observables, you can't\n// trivially subscribe to the underlying observables (e.g., `someProperty.subscribe(...)`),\n// or tell them that object values have mutated, etc. To handle this, we set up some\n// extra utility functions that can return or work with the underlying observables.\n// Returns the underlying observable associated with a model property (or `null` if the\n// model or property doesn't exist, or isn't associated with an observable). This means\n// you can subscribe to the property, e.g.:\n//\n//     ko.getObservable(model, 'propertyName')\n//       .subscribe(function(newValue) { ... });\n\n\nfunction getObservable(obj, propertyName) {\n  if (!obj\n  /*|| typeof obj !== 'object'*/\n  ) {\n      return null;\n    }\n\n  var allObservablesForObject = getAllObservablesForObject(obj, false);\n  return allObservablesForObject && allObservablesForObject[propertyName] || null;\n} // Causes a property's associated observable to fire a change notification. Useful when\n// the property value is a complex object and you've modified a child property.\n\n\nfunction valueHasMutated(obj, propertyName) {\n  var observable = getObservable(obj, propertyName);\n\n  if (observable) {\n    observable.valueHasMutated();\n  }\n} // Extends a Knockout instance with Knockout-ES5 functionality\n\n\nfunction attachToKo(ko) {\n  ko.track = track;\n  ko.getObservable = getObservable;\n  ko.valueHasMutated = valueHasMutated;\n  ko.defineProperty = defineComputedProperty;\n}\n\nexport default {\n  attachToKo: attachToKo\n};","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/ThirdParty/knockout-es5.js"],"names":["OBSERVABLES_PROPERTY","SUBSCRIBABLE_PROPERTY","track","obj","propertyNames","Error","ko","allObservablesForObject","getAllObservablesForObject","Object","getOwnPropertyNames","forEach","propertyName","origValue","isArray","Array","observable","isObservable","observableArray","defineProperty","configurable","enumerable","get","set","isWriteableObservable","undefined","notifyWhenPresentOrFutureArrayValuesMutate","createIfNotDefined","result","value","defineComputedProperty","evaluatorOrOptions","computedOptions","owner","deferEvaluation","read","write","computed","call","watchingArraySubscription","dispose","newArrayInstance","startWatchingArrayInstance","arrayInstance","subscribable","getSubscribableForArray","subscribe","notificationPauseSignal","wrapStandardArrayMutators","addKnockoutArrayMutators","fnName","origMutator","apply","arguments","pause","notifySubscribers","fn","getObservable","valueHasMutated","attachToKo"],"mappings":"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","sourcesContent":["/**\n * @license\n * Knockout ES5 plugin - https://github.com/SteveSanderson/knockout-es5\n * Copyright (c) Steve Sanderson\n * MIT license\n */\n\n    var OBSERVABLES_PROPERTY = '__knockoutObservables';\n    var SUBSCRIBABLE_PROPERTY = '__knockoutSubscribable';\n\n    // Model tracking\n    // --------------\n    //\n    // This is the central feature of Knockout-ES5. We augment model objects by converting properties\n    // into ES5 getter/setter pairs that read/write an underlying Knockout observable. This means you can\n    // use plain JavaScript syntax to read/write the property while still getting the full benefits of\n    // Knockout's automatic dependency detection and notification triggering.\n    //\n    // For comparison, here's Knockout ES3-compatible syntax:\n    //\n    //     var firstNameLength = myModel.user().firstName().length; // Read\n    //     myModel.user().firstName('Bert'); // Write\n    //\n    // ... versus Knockout-ES5 syntax:\n    //\n    //     var firstNameLength = myModel.user.firstName.length; // Read\n    //     myModel.user.firstName = 'Bert'; // Write\n\n    // `ko.track(model)` converts each property on the given model object into a getter/setter pair that\n    // wraps a Knockout observable. Optionally specify an array of property names to wrap; otherwise we\n    // wrap all properties. If any of the properties are already observables, we replace them with\n    // ES5 getter/setter pairs that wrap your original observable instances. In the case of readonly\n    // ko.computed properties, we simply do not define a setter (so attempted writes will be ignored,\n    // which is how ES5 readonly properties normally behave).\n    //\n    // By design, this does *not* recursively walk child object properties, because making literally\n    // everything everywhere independently observable is usually unhelpful. When you do want to track\n    // child object properties independently, define your own class for those child objects and put\n    // a separate ko.track call into its constructor --- this gives you far more control.\n    function track(obj, propertyNames) {\n        if (!obj /*|| typeof obj !== 'object'*/) {\n            throw new Error('When calling ko.track, you must pass an object as the first parameter.');\n        }\n\n        var ko = this,\n            allObservablesForObject = getAllObservablesForObject(obj, true);\n        propertyNames = propertyNames || Object.getOwnPropertyNames(obj);\n\n        propertyNames.forEach(function(propertyName) {\n            // Skip storage properties\n            if (propertyName === OBSERVABLES_PROPERTY || propertyName === SUBSCRIBABLE_PROPERTY) {\n                return;\n            }\n            // Skip properties that are already tracked\n            if (propertyName in allObservablesForObject) {\n                return;\n            }\n\n            var origValue = obj[propertyName],\n                isArray = origValue instanceof Array,\n                observable = ko.isObservable(origValue) ? origValue\n                                              : isArray ? ko.observableArray(origValue)\n                                                        : ko.observable(origValue);\n\n            Object.defineProperty(obj, propertyName, {\n                configurable: true,\n                enumerable: true,\n                get: observable,\n                set: ko.isWriteableObservable(observable) ? observable : undefined\n            });\n\n            allObservablesForObject[propertyName] = observable;\n\n            if (isArray) {\n                notifyWhenPresentOrFutureArrayValuesMutate(ko, observable);\n            }\n        });\n\n        return obj;\n    }\n\n    // Gets or creates the hidden internal key-value collection of observables corresponding to\n    // properties on the model object.\n    function getAllObservablesForObject(obj, createIfNotDefined) {\n        var result = obj[OBSERVABLES_PROPERTY];\n        if (!result && createIfNotDefined) {\n            result = {};\n            Object.defineProperty(obj, OBSERVABLES_PROPERTY, {\n                value : result\n            });\n        }\n        return result;\n    }\n\n    // Computed properties\n    // -------------------\n    //\n    // The preceding code is already sufficient to upgrade ko.computed model properties to ES5\n    // getter/setter pairs (or in the case of readonly ko.computed properties, just a getter).\n    // These then behave like a regular property with a getter function, except they are smarter:\n    // your evaluator is only invoked when one of its dependencies changes. The result is cached\n    // and used for all evaluations until the next time a dependency changes).\n    //\n    // However, instead of forcing developers to declare a ko.computed property explicitly, it's\n    // nice to offer a utility function that declares a computed getter directly.\n\n    // Implements `ko.defineProperty`\n    function defineComputedProperty(obj, propertyName, evaluatorOrOptions) {\n        var ko = this,\n            computedOptions = { owner: obj, deferEvaluation: true };\n\n        if (typeof evaluatorOrOptions === 'function') {\n            computedOptions.read = evaluatorOrOptions;\n        } else {\n            if ('value' in evaluatorOrOptions) {\n                throw new Error('For ko.defineProperty, you must not specify a \"value\" for the property. You must provide a \"get\" function.');\n            }\n\n            if (typeof evaluatorOrOptions.get !== 'function') {\n                throw new Error('For ko.defineProperty, the third parameter must be either an evaluator function, or an options object containing a function called \"get\".');\n            }\n\n            computedOptions.read = evaluatorOrOptions.get;\n            computedOptions.write = evaluatorOrOptions.set;\n        }\n\n        obj[propertyName] = ko.computed(computedOptions);\n        track.call(ko, obj, [propertyName]);\n        return obj;\n    }\n\n    // Array handling\n    // --------------\n    //\n    // Arrays are special, because unlike other property types, they have standard mutator functions\n    // (`push`/`pop`/`splice`/etc.) and it's desirable to trigger a change notification whenever one of\n    // those mutator functions is invoked.\n    //\n    // Traditionally, Knockout handles this by putting special versions of `push`/`pop`/etc. on observable\n    // arrays that mutate the underlying array and then trigger a notification. That approach doesn't\n    // work for Knockout-ES5 because properties now return the underlying arrays, so the mutator runs\n    // in the context of the underlying array, not any particular observable:\n    //\n    //     // Operates on the underlying array value\n    //     myModel.someCollection.push('New value');\n    //\n    // To solve this, Knockout-ES5 detects array values, and modifies them as follows:\n    //  1. Associates a hidden subscribable with each array instance that it encounters\n    //  2. Intercepts standard mutators (`push`/`pop`/etc.) and makes them trigger the subscribable\n    // Then, for model properties whose values are arrays, the property's underlying observable\n    // subscribes to the array subscribable, so it can trigger a change notification after mutation.\n\n    // Given an observable that underlies a model property, watch for any array value that might\n    // be assigned as the property value, and hook into its change events\n    function notifyWhenPresentOrFutureArrayValuesMutate(ko, observable) {\n        var watchingArraySubscription = null;\n        ko.computed(function () {\n            // Unsubscribe to any earlier array instance\n            if (watchingArraySubscription) {\n                watchingArraySubscription.dispose();\n                watchingArraySubscription = null;\n            }\n\n            // Subscribe to the new array instance\n            var newArrayInstance = observable();\n            if (newArrayInstance instanceof Array) {\n                watchingArraySubscription = startWatchingArrayInstance(ko, observable, newArrayInstance);\n            }\n        });\n    }\n\n    // Listens for array mutations, and when they happen, cause the observable to fire notifications.\n    // This is used to make model properties of type array fire notifications when the array changes.\n    // Returns a subscribable that can later be disposed.\n    function startWatchingArrayInstance(ko, observable, arrayInstance) {\n        var subscribable = getSubscribableForArray(ko, arrayInstance);\n        return subscribable.subscribe(observable);\n    }\n\n    // Gets or creates a subscribable that fires after each array mutation\n    function getSubscribableForArray(ko, arrayInstance) {\n        var subscribable = arrayInstance[SUBSCRIBABLE_PROPERTY];\n        if (!subscribable) {\n            subscribable = new ko.subscribable();\n            Object.defineProperty(arrayInstance, SUBSCRIBABLE_PROPERTY, {\n                value : subscribable\n            });\n\n            var notificationPauseSignal = {};\n            wrapStandardArrayMutators(arrayInstance, subscribable, notificationPauseSignal);\n            addKnockoutArrayMutators(ko, arrayInstance, subscribable, notificationPauseSignal);\n        }\n\n        return subscribable;\n    }\n\n    // After each array mutation, fires a notification on the given subscribable\n    function wrapStandardArrayMutators(arrayInstance, subscribable, notificationPauseSignal) {\n        ['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'].forEach(function(fnName) {\n            var origMutator = arrayInstance[fnName];\n            arrayInstance[fnName] = function() {\n                var result = origMutator.apply(this, arguments);\n                if (notificationPauseSignal.pause !== true) {\n                    subscribable.notifySubscribers(this);\n                }\n                return result;\n            };\n        });\n    }\n\n    // Adds Knockout's additional array mutation functions to the array\n    function addKnockoutArrayMutators(ko, arrayInstance, subscribable, notificationPauseSignal) {\n        ['remove', 'removeAll', 'destroy', 'destroyAll', 'replace'].forEach(function(fnName) {\n            // Make it a non-enumerable property for consistency with standard Array functions\n            Object.defineProperty(arrayInstance, fnName, {\n                enumerable: false,\n                value: function() {\n                    var result;\n\n                    // These additional array mutators are built using the underlying push/pop/etc.\n                    // mutators, which are wrapped to trigger notifications. But we don't want to\n                    // trigger multiple notifications, so pause the push/pop/etc. wrappers and\n                    // delivery only one notification at the end of the process.\n                    notificationPauseSignal.pause = true;\n                    try {\n                        // Creates a temporary observableArray that can perform the operation.\n                        result = ko.observableArray.fn[fnName].apply(ko.observableArray(arrayInstance), arguments);\n                    }\n                    finally {\n                        notificationPauseSignal.pause = false;\n                    }\n                    subscribable.notifySubscribers(arrayInstance);\n                    return result;\n                }\n            });\n        });\n    }\n\n    // Static utility functions\n    // ------------------------\n    //\n    // Since Knockout-ES5 sets up properties that return values, not observables, you can't\n    // trivially subscribe to the underlying observables (e.g., `someProperty.subscribe(...)`),\n    // or tell them that object values have mutated, etc. To handle this, we set up some\n    // extra utility functions that can return or work with the underlying observables.\n\n    // Returns the underlying observable associated with a model property (or `null` if the\n    // model or property doesn't exist, or isn't associated with an observable). This means\n    // you can subscribe to the property, e.g.:\n    //\n    //     ko.getObservable(model, 'propertyName')\n    //       .subscribe(function(newValue) { ... });\n    function getObservable(obj, propertyName) {\n        if (!obj /*|| typeof obj !== 'object'*/) {\n            return null;\n        }\n\n        var allObservablesForObject = getAllObservablesForObject(obj, false);\n        return (allObservablesForObject && allObservablesForObject[propertyName]) || null;\n    }\n\n    // Causes a property's associated observable to fire a change notification. Useful when\n    // the property value is a complex object and you've modified a child property.\n    function valueHasMutated(obj, propertyName) {\n        var observable = getObservable(obj, propertyName);\n\n        if (observable) {\n            observable.valueHasMutated();\n        }\n    }\n\n    // Extends a Knockout instance with Knockout-ES5 functionality\n    function attachToKo(ko) {\n        ko.track = track;\n        ko.getObservable = getObservable;\n        ko.valueHasMutated = valueHasMutated;\n        ko.defineProperty = defineComputedProperty;\n    }\n\n    export default {\n        attachToKo : attachToKo\n    };\n"]},"metadata":{},"sourceType":"module"}