{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport Property from \"./Property.js\";\n/**\n * A {@link Property} which evaluates to a {@link Cartesian3} vector\n * based on the velocity of the provided {@link PositionProperty}.\n *\n * @alias VelocityVectorProperty\n * @constructor\n *\n * @param {Property} [position] The position property used to compute the velocity.\n * @param {Boolean} [normalize=true] Whether to normalize the computed velocity vector.\n *\n * @example\n * //Create an entity with a billboard rotated to match its velocity.\n * var position = new Cesium.SampledProperty();\n * position.addSamples(...);\n * var entity = viewer.entities.add({\n *   position : position,\n *   billboard : {\n *     image : 'image.png',\n *     alignedAxis : new Cesium.VelocityVectorProperty(position, true) // alignedAxis must be a unit vector\n *   }\n * }));\n */\n\nfunction VelocityVectorProperty(position, normalize) {\n  this._position = undefined;\n  this._subscription = undefined;\n  this._definitionChanged = new Event();\n  this._normalize = defaultValue(normalize, true);\n  this.position = position;\n}\n\nObject.defineProperties(VelocityVectorProperty.prototype, {\n  /**\n   * Gets a value indicating if this property is constant.\n   * @memberof VelocityVectorProperty.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  isConstant: {\n    get: function get() {\n      return Property.isConstant(this._position);\n    }\n  },\n\n  /**\n   * Gets the event that is raised whenever the definition of this property changes.\n   * @memberof VelocityVectorProperty.prototype\n   *\n   * @type {Event}\n   * @readonly\n   */\n  definitionChanged: {\n    get: function get() {\n      return this._definitionChanged;\n    }\n  },\n\n  /**\n   * Gets or sets the position property used to compute the velocity vector.\n   * @memberof VelocityVectorProperty.prototype\n   *\n   * @type {Property}\n   */\n  position: {\n    get: function get() {\n      return this._position;\n    },\n    set: function set(value) {\n      var oldValue = this._position;\n\n      if (oldValue !== value) {\n        if (defined(oldValue)) {\n          this._subscription();\n        }\n\n        this._position = value;\n\n        if (defined(value)) {\n          this._subscription = value._definitionChanged.addEventListener(function () {\n            this._definitionChanged.raiseEvent(this);\n          }, this);\n        }\n\n        this._definitionChanged.raiseEvent(this);\n      }\n    }\n  },\n\n  /**\n   * Gets or sets whether the vector produced by this property\n   * will be normalized or not.\n   * @memberof VelocityVectorProperty.prototype\n   *\n   * @type {Boolean}\n   */\n  normalize: {\n    get: function get() {\n      return this._normalize;\n    },\n    set: function set(value) {\n      if (this._normalize === value) {\n        return;\n      }\n\n      this._normalize = value;\n\n      this._definitionChanged.raiseEvent(this);\n    }\n  }\n});\nvar position1Scratch = new Cartesian3();\nvar position2Scratch = new Cartesian3();\nvar timeScratch = new JulianDate();\nvar step = 1.0 / 60.0;\n/**\n * Gets the value of the property at the provided time.\n *\n * @param {JulianDate} [time] The time for which to retrieve the value.\n * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.\n * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.\n */\n\nVelocityVectorProperty.prototype.getValue = function (time, result) {\n  return this._getValue(time, result);\n};\n/**\n * @private\n */\n\n\nVelocityVectorProperty.prototype._getValue = function (time, velocityResult, positionResult) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(time)) {\n    throw new DeveloperError(\"time is required\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(velocityResult)) {\n    velocityResult = new Cartesian3();\n  }\n\n  var property = this._position;\n\n  if (Property.isConstant(property)) {\n    return this._normalize ? undefined : Cartesian3.clone(Cartesian3.ZERO, velocityResult);\n  }\n\n  var position1 = property.getValue(time, position1Scratch);\n  var position2 = property.getValue(JulianDate.addSeconds(time, step, timeScratch), position2Scratch); //If we don't have a position for now, return undefined.\n\n  if (!defined(position1)) {\n    return undefined;\n  } //If we don't have a position for now + step, see if we have a position for now - step.\n\n\n  if (!defined(position2)) {\n    position2 = position1;\n    position1 = property.getValue(JulianDate.addSeconds(time, -step, timeScratch), position2Scratch);\n\n    if (!defined(position1)) {\n      return undefined;\n    }\n  }\n\n  if (Cartesian3.equals(position1, position2)) {\n    return this._normalize ? undefined : Cartesian3.clone(Cartesian3.ZERO, velocityResult);\n  }\n\n  if (defined(positionResult)) {\n    position1.clone(positionResult);\n  }\n\n  var velocity = Cartesian3.subtract(position2, position1, velocityResult);\n\n  if (this._normalize) {\n    return Cartesian3.normalize(velocity, velocityResult);\n  }\n\n  return Cartesian3.divideByScalar(velocity, step, velocityResult);\n};\n/**\n * Compares this property to the provided property and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Property} [other] The other property.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\n\n\nVelocityVectorProperty.prototype.equals = function (other) {\n  return this === other || //\n  other instanceof VelocityVectorProperty && Property.equals(this._position, other._position);\n};\n\nexport default VelocityVectorProperty;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/DataSources/VelocityVectorProperty.js"],"names":["Cartesian3","defaultValue","defined","DeveloperError","Event","JulianDate","Property","VelocityVectorProperty","position","normalize","_position","undefined","_subscription","_definitionChanged","_normalize","Object","defineProperties","prototype","isConstant","get","definitionChanged","set","value","oldValue","addEventListener","raiseEvent","position1Scratch","position2Scratch","timeScratch","step","getValue","time","result","_getValue","velocityResult","positionResult","property","clone","ZERO","position1","position2","addSeconds","equals","velocity","subtract","divideByScalar","other"],"mappings":"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","sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport Property from \"./Property.js\";\n\n/**\n * A {@link Property} which evaluates to a {@link Cartesian3} vector\n * based on the velocity of the provided {@link PositionProperty}.\n *\n * @alias VelocityVectorProperty\n * @constructor\n *\n * @param {Property} [position] The position property used to compute the velocity.\n * @param {Boolean} [normalize=true] Whether to normalize the computed velocity vector.\n *\n * @example\n * //Create an entity with a billboard rotated to match its velocity.\n * var position = new Cesium.SampledProperty();\n * position.addSamples(...);\n * var entity = viewer.entities.add({\n *   position : position,\n *   billboard : {\n *     image : 'image.png',\n *     alignedAxis : new Cesium.VelocityVectorProperty(position, true) // alignedAxis must be a unit vector\n *   }\n * }));\n */\nfunction VelocityVectorProperty(position, normalize) {\n  this._position = undefined;\n  this._subscription = undefined;\n  this._definitionChanged = new Event();\n  this._normalize = defaultValue(normalize, true);\n\n  this.position = position;\n}\n\nObject.defineProperties(VelocityVectorProperty.prototype, {\n  /**\n   * Gets a value indicating if this property is constant.\n   * @memberof VelocityVectorProperty.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  isConstant: {\n    get: function () {\n      return Property.isConstant(this._position);\n    },\n  },\n  /**\n   * Gets the event that is raised whenever the definition of this property changes.\n   * @memberof VelocityVectorProperty.prototype\n   *\n   * @type {Event}\n   * @readonly\n   */\n  definitionChanged: {\n    get: function () {\n      return this._definitionChanged;\n    },\n  },\n  /**\n   * Gets or sets the position property used to compute the velocity vector.\n   * @memberof VelocityVectorProperty.prototype\n   *\n   * @type {Property}\n   */\n  position: {\n    get: function () {\n      return this._position;\n    },\n    set: function (value) {\n      var oldValue = this._position;\n      if (oldValue !== value) {\n        if (defined(oldValue)) {\n          this._subscription();\n        }\n\n        this._position = value;\n\n        if (defined(value)) {\n          this._subscription = value._definitionChanged.addEventListener(\n            function () {\n              this._definitionChanged.raiseEvent(this);\n            },\n            this\n          );\n        }\n\n        this._definitionChanged.raiseEvent(this);\n      }\n    },\n  },\n  /**\n   * Gets or sets whether the vector produced by this property\n   * will be normalized or not.\n   * @memberof VelocityVectorProperty.prototype\n   *\n   * @type {Boolean}\n   */\n  normalize: {\n    get: function () {\n      return this._normalize;\n    },\n    set: function (value) {\n      if (this._normalize === value) {\n        return;\n      }\n\n      this._normalize = value;\n      this._definitionChanged.raiseEvent(this);\n    },\n  },\n});\n\nvar position1Scratch = new Cartesian3();\nvar position2Scratch = new Cartesian3();\nvar timeScratch = new JulianDate();\nvar step = 1.0 / 60.0;\n\n/**\n * Gets the value of the property at the provided time.\n *\n * @param {JulianDate} [time] The time for which to retrieve the value.\n * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.\n * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.\n */\nVelocityVectorProperty.prototype.getValue = function (time, result) {\n  return this._getValue(time, result);\n};\n\n/**\n * @private\n */\nVelocityVectorProperty.prototype._getValue = function (\n  time,\n  velocityResult,\n  positionResult\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(time)) {\n    throw new DeveloperError(\"time is required\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(velocityResult)) {\n    velocityResult = new Cartesian3();\n  }\n\n  var property = this._position;\n  if (Property.isConstant(property)) {\n    return this._normalize\n      ? undefined\n      : Cartesian3.clone(Cartesian3.ZERO, velocityResult);\n  }\n\n  var position1 = property.getValue(time, position1Scratch);\n  var position2 = property.getValue(\n    JulianDate.addSeconds(time, step, timeScratch),\n    position2Scratch\n  );\n\n  //If we don't have a position for now, return undefined.\n  if (!defined(position1)) {\n    return undefined;\n  }\n\n  //If we don't have a position for now + step, see if we have a position for now - step.\n  if (!defined(position2)) {\n    position2 = position1;\n    position1 = property.getValue(\n      JulianDate.addSeconds(time, -step, timeScratch),\n      position2Scratch\n    );\n\n    if (!defined(position1)) {\n      return undefined;\n    }\n  }\n\n  if (Cartesian3.equals(position1, position2)) {\n    return this._normalize\n      ? undefined\n      : Cartesian3.clone(Cartesian3.ZERO, velocityResult);\n  }\n\n  if (defined(positionResult)) {\n    position1.clone(positionResult);\n  }\n\n  var velocity = Cartesian3.subtract(position2, position1, velocityResult);\n  if (this._normalize) {\n    return Cartesian3.normalize(velocity, velocityResult);\n  }\n\n  return Cartesian3.divideByScalar(velocity, step, velocityResult);\n};\n\n/**\n * Compares this property to the provided property and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Property} [other] The other property.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nVelocityVectorProperty.prototype.equals = function (other) {\n  return (\n    this === other || //\n    (other instanceof VelocityVectorProperty &&\n      Property.equals(this._position, other._position))\n  );\n};\nexport default VelocityVectorProperty;\n"]},"metadata":{},"sourceType":"module"}