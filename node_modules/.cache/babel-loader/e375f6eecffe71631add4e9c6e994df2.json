{"ast":null,"code":"import defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n/**\n * Encapsulates an algorithm to optimize triangles for the post\n * vertex-shader cache.  This is based on the 2007 SIGGRAPH paper\n * 'Fast Triangle Reordering for Vertex Locality and Reduced Overdraw.'\n * The runtime is linear but several passes are made.\n *\n * @exports Tipsify\n *\n * @see <a href='http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf'>\n * Fast Triangle Reordering for Vertex Locality and Reduced Overdraw</a>\n * by Sander, Nehab, and Barczak\n *\n * @private\n */\n\nvar Tipsify = {};\n/**\n * Calculates the average cache miss ratio (ACMR) for a given set of indices.\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.indices Lists triads of numbers corresponding to the indices of the vertices\n *                        in the vertex buffer that define the geometry's triangles.\n * @param {Number} [options.maximumIndex] The maximum value of the elements in <code>args.indices</code>.\n *                                     If not supplied, this value will be computed.\n * @param {Number} [options.cacheSize=24] The number of vertices that can be stored in the cache at any one time.\n * @returns {Number} The average cache miss ratio (ACMR).\n *\n * @exception {DeveloperError} indices length must be a multiple of three.\n * @exception {DeveloperError} cacheSize must be greater than two.\n *\n * @example\n * var indices = [0, 1, 2, 3, 4, 5];\n * var maxIndex = 5;\n * var cacheSize = 3;\n * var acmr = Cesium.Tipsify.calculateACMR({indices : indices, maxIndex : maxIndex, cacheSize : cacheSize});\n */\n\nTipsify.calculateACMR = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var indices = options.indices;\n  var maximumIndex = options.maximumIndex;\n  var cacheSize = defaultValue(options.cacheSize, 24); //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(indices)) {\n    throw new DeveloperError(\"indices is required.\");\n  } //>>includeEnd('debug');\n\n\n  var numIndices = indices.length; //>>includeStart('debug', pragmas.debug);\n\n  if (numIndices < 3 || numIndices % 3 !== 0) {\n    throw new DeveloperError(\"indices length must be a multiple of three.\");\n  }\n\n  if (maximumIndex <= 0) {\n    throw new DeveloperError(\"maximumIndex must be greater than zero.\");\n  }\n\n  if (cacheSize < 3) {\n    throw new DeveloperError(\"cacheSize must be greater than two.\");\n  } //>>includeEnd('debug');\n  // Compute the maximumIndex if not given\n\n\n  if (!defined(maximumIndex)) {\n    maximumIndex = 0;\n    var currentIndex = 0;\n    var intoIndices = indices[currentIndex];\n\n    while (currentIndex < numIndices) {\n      if (intoIndices > maximumIndex) {\n        maximumIndex = intoIndices;\n      }\n\n      ++currentIndex;\n      intoIndices = indices[currentIndex];\n    }\n  } // Vertex time stamps\n\n\n  var vertexTimeStamps = [];\n\n  for (var i = 0; i < maximumIndex + 1; i++) {\n    vertexTimeStamps[i] = 0;\n  } // Cache processing\n\n\n  var s = cacheSize + 1;\n\n  for (var j = 0; j < numIndices; ++j) {\n    if (s - vertexTimeStamps[indices[j]] > cacheSize) {\n      vertexTimeStamps[indices[j]] = s;\n      ++s;\n    }\n  }\n\n  return (s - cacheSize + 1) / (numIndices / 3);\n};\n/**\n * Optimizes triangles for the post-vertex shader cache.\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.indices Lists triads of numbers corresponding to the indices of the vertices\n *                        in the vertex buffer that define the geometry's triangles.\n * @param {Number} [options.maximumIndex] The maximum value of the elements in <code>args.indices</code>.\n *                                     If not supplied, this value will be computed.\n * @param {Number} [options.cacheSize=24] The number of vertices that can be stored in the cache at any one time.\n * @returns {Number[]} A list of the input indices in an optimized order.\n *\n * @exception {DeveloperError} indices length must be a multiple of three.\n * @exception {DeveloperError} cacheSize must be greater than two.\n *\n * @example\n * var indices = [0, 1, 2, 3, 4, 5];\n * var maxIndex = 5;\n * var cacheSize = 3;\n * var reorderedIndices = Cesium.Tipsify.tipsify({indices : indices, maxIndex : maxIndex, cacheSize : cacheSize});\n */\n\n\nTipsify.tipsify = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var indices = options.indices;\n  var maximumIndex = options.maximumIndex;\n  var cacheSize = defaultValue(options.cacheSize, 24);\n  var cursor;\n\n  function skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne) {\n    while (deadEnd.length >= 1) {\n      // while the stack is not empty\n      var d = deadEnd[deadEnd.length - 1]; // top of the stack\n\n      deadEnd.splice(deadEnd.length - 1, 1); // pop the stack\n\n      if (vertices[d].numLiveTriangles > 0) {\n        return d;\n      }\n    }\n\n    while (cursor < maximumIndexPlusOne) {\n      if (vertices[cursor].numLiveTriangles > 0) {\n        ++cursor;\n        return cursor - 1;\n      }\n\n      ++cursor;\n    }\n\n    return -1;\n  }\n\n  function getNextVertex(indices, cacheSize, oneRing, vertices, s, deadEnd, maximumIndexPlusOne) {\n    var n = -1;\n    var p;\n    var m = -1;\n    var itOneRing = 0;\n\n    while (itOneRing < oneRing.length) {\n      var index = oneRing[itOneRing];\n\n      if (vertices[index].numLiveTriangles) {\n        p = 0;\n\n        if (s - vertices[index].timeStamp + 2 * vertices[index].numLiveTriangles <= cacheSize) {\n          p = s - vertices[index].timeStamp;\n        }\n\n        if (p > m || m === -1) {\n          m = p;\n          n = index;\n        }\n      }\n\n      ++itOneRing;\n    }\n\n    if (n === -1) {\n      return skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne);\n    }\n\n    return n;\n  } //>>includeStart('debug', pragmas.debug);\n\n\n  if (!defined(indices)) {\n    throw new DeveloperError(\"indices is required.\");\n  } //>>includeEnd('debug');\n\n\n  var numIndices = indices.length; //>>includeStart('debug', pragmas.debug);\n\n  if (numIndices < 3 || numIndices % 3 !== 0) {\n    throw new DeveloperError(\"indices length must be a multiple of three.\");\n  }\n\n  if (maximumIndex <= 0) {\n    throw new DeveloperError(\"maximumIndex must be greater than zero.\");\n  }\n\n  if (cacheSize < 3) {\n    throw new DeveloperError(\"cacheSize must be greater than two.\");\n  } //>>includeEnd('debug');\n  // Determine maximum index\n\n\n  var maximumIndexPlusOne = 0;\n  var currentIndex = 0;\n  var intoIndices = indices[currentIndex];\n  var endIndex = numIndices;\n\n  if (defined(maximumIndex)) {\n    maximumIndexPlusOne = maximumIndex + 1;\n  } else {\n    while (currentIndex < endIndex) {\n      if (intoIndices > maximumIndexPlusOne) {\n        maximumIndexPlusOne = intoIndices;\n      }\n\n      ++currentIndex;\n      intoIndices = indices[currentIndex];\n    }\n\n    if (maximumIndexPlusOne === -1) {\n      return 0;\n    }\n\n    ++maximumIndexPlusOne;\n  } // Vertices\n\n\n  var vertices = [];\n  var i;\n\n  for (i = 0; i < maximumIndexPlusOne; i++) {\n    vertices[i] = {\n      numLiveTriangles: 0,\n      timeStamp: 0,\n      vertexTriangles: []\n    };\n  }\n\n  currentIndex = 0;\n  var triangle = 0;\n\n  while (currentIndex < endIndex) {\n    vertices[indices[currentIndex]].vertexTriangles.push(triangle);\n    ++vertices[indices[currentIndex]].numLiveTriangles;\n    vertices[indices[currentIndex + 1]].vertexTriangles.push(triangle);\n    ++vertices[indices[currentIndex + 1]].numLiveTriangles;\n    vertices[indices[currentIndex + 2]].vertexTriangles.push(triangle);\n    ++vertices[indices[currentIndex + 2]].numLiveTriangles;\n    ++triangle;\n    currentIndex += 3;\n  } // Starting index\n\n\n  var f = 0; // Time Stamp\n\n  var s = cacheSize + 1;\n  cursor = 1; // Process\n\n  var oneRing = [];\n  var deadEnd = []; //Stack\n\n  var vertex;\n  var intoVertices;\n  var currentOutputIndex = 0;\n  var outputIndices = [];\n  var numTriangles = numIndices / 3;\n  var triangleEmitted = [];\n\n  for (i = 0; i < numTriangles; i++) {\n    triangleEmitted[i] = false;\n  }\n\n  var index;\n  var limit;\n\n  while (f !== -1) {\n    oneRing = [];\n    intoVertices = vertices[f];\n    limit = intoVertices.vertexTriangles.length;\n\n    for (var k = 0; k < limit; ++k) {\n      triangle = intoVertices.vertexTriangles[k];\n\n      if (!triangleEmitted[triangle]) {\n        triangleEmitted[triangle] = true;\n        currentIndex = triangle + triangle + triangle;\n\n        for (var j = 0; j < 3; ++j) {\n          // Set this index as a possible next index\n          index = indices[currentIndex];\n          oneRing.push(index);\n          deadEnd.push(index); // Output index\n\n          outputIndices[currentOutputIndex] = index;\n          ++currentOutputIndex; // Cache processing\n\n          vertex = vertices[index];\n          --vertex.numLiveTriangles;\n\n          if (s - vertex.timeStamp > cacheSize) {\n            vertex.timeStamp = s;\n            ++s;\n          }\n\n          ++currentIndex;\n        }\n      }\n    }\n\n    f = getNextVertex(indices, cacheSize, oneRing, vertices, s, deadEnd, maximumIndexPlusOne);\n  }\n\n  return outputIndices;\n};\n\nexport default Tipsify;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/Tipsify.js"],"names":["defaultValue","defined","DeveloperError","Tipsify","calculateACMR","options","EMPTY_OBJECT","indices","maximumIndex","cacheSize","numIndices","length","currentIndex","intoIndices","vertexTimeStamps","i","s","j","tipsify","cursor","skipDeadEnd","vertices","deadEnd","maximumIndexPlusOne","d","splice","numLiveTriangles","getNextVertex","oneRing","n","p","m","itOneRing","index","timeStamp","endIndex","vertexTriangles","triangle","push","f","vertex","intoVertices","currentOutputIndex","outputIndices","numTriangles","triangleEmitted","limit","k"],"mappings":"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","sourcesContent":["import defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Encapsulates an algorithm to optimize triangles for the post\n * vertex-shader cache.  This is based on the 2007 SIGGRAPH paper\n * 'Fast Triangle Reordering for Vertex Locality and Reduced Overdraw.'\n * The runtime is linear but several passes are made.\n *\n * @exports Tipsify\n *\n * @see <a href='http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf'>\n * Fast Triangle Reordering for Vertex Locality and Reduced Overdraw</a>\n * by Sander, Nehab, and Barczak\n *\n * @private\n */\nvar Tipsify = {};\n\n/**\n * Calculates the average cache miss ratio (ACMR) for a given set of indices.\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.indices Lists triads of numbers corresponding to the indices of the vertices\n *                        in the vertex buffer that define the geometry's triangles.\n * @param {Number} [options.maximumIndex] The maximum value of the elements in <code>args.indices</code>.\n *                                     If not supplied, this value will be computed.\n * @param {Number} [options.cacheSize=24] The number of vertices that can be stored in the cache at any one time.\n * @returns {Number} The average cache miss ratio (ACMR).\n *\n * @exception {DeveloperError} indices length must be a multiple of three.\n * @exception {DeveloperError} cacheSize must be greater than two.\n *\n * @example\n * var indices = [0, 1, 2, 3, 4, 5];\n * var maxIndex = 5;\n * var cacheSize = 3;\n * var acmr = Cesium.Tipsify.calculateACMR({indices : indices, maxIndex : maxIndex, cacheSize : cacheSize});\n */\nTipsify.calculateACMR = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var indices = options.indices;\n  var maximumIndex = options.maximumIndex;\n  var cacheSize = defaultValue(options.cacheSize, 24);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(indices)) {\n    throw new DeveloperError(\"indices is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var numIndices = indices.length;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numIndices < 3 || numIndices % 3 !== 0) {\n    throw new DeveloperError(\"indices length must be a multiple of three.\");\n  }\n  if (maximumIndex <= 0) {\n    throw new DeveloperError(\"maximumIndex must be greater than zero.\");\n  }\n  if (cacheSize < 3) {\n    throw new DeveloperError(\"cacheSize must be greater than two.\");\n  }\n  //>>includeEnd('debug');\n\n  // Compute the maximumIndex if not given\n  if (!defined(maximumIndex)) {\n    maximumIndex = 0;\n    var currentIndex = 0;\n    var intoIndices = indices[currentIndex];\n    while (currentIndex < numIndices) {\n      if (intoIndices > maximumIndex) {\n        maximumIndex = intoIndices;\n      }\n      ++currentIndex;\n      intoIndices = indices[currentIndex];\n    }\n  }\n\n  // Vertex time stamps\n  var vertexTimeStamps = [];\n  for (var i = 0; i < maximumIndex + 1; i++) {\n    vertexTimeStamps[i] = 0;\n  }\n\n  // Cache processing\n  var s = cacheSize + 1;\n  for (var j = 0; j < numIndices; ++j) {\n    if (s - vertexTimeStamps[indices[j]] > cacheSize) {\n      vertexTimeStamps[indices[j]] = s;\n      ++s;\n    }\n  }\n\n  return (s - cacheSize + 1) / (numIndices / 3);\n};\n\n/**\n * Optimizes triangles for the post-vertex shader cache.\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.indices Lists triads of numbers corresponding to the indices of the vertices\n *                        in the vertex buffer that define the geometry's triangles.\n * @param {Number} [options.maximumIndex] The maximum value of the elements in <code>args.indices</code>.\n *                                     If not supplied, this value will be computed.\n * @param {Number} [options.cacheSize=24] The number of vertices that can be stored in the cache at any one time.\n * @returns {Number[]} A list of the input indices in an optimized order.\n *\n * @exception {DeveloperError} indices length must be a multiple of three.\n * @exception {DeveloperError} cacheSize must be greater than two.\n *\n * @example\n * var indices = [0, 1, 2, 3, 4, 5];\n * var maxIndex = 5;\n * var cacheSize = 3;\n * var reorderedIndices = Cesium.Tipsify.tipsify({indices : indices, maxIndex : maxIndex, cacheSize : cacheSize});\n */\nTipsify.tipsify = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var indices = options.indices;\n  var maximumIndex = options.maximumIndex;\n  var cacheSize = defaultValue(options.cacheSize, 24);\n\n  var cursor;\n\n  function skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne) {\n    while (deadEnd.length >= 1) {\n      // while the stack is not empty\n      var d = deadEnd[deadEnd.length - 1]; // top of the stack\n      deadEnd.splice(deadEnd.length - 1, 1); // pop the stack\n\n      if (vertices[d].numLiveTriangles > 0) {\n        return d;\n      }\n    }\n\n    while (cursor < maximumIndexPlusOne) {\n      if (vertices[cursor].numLiveTriangles > 0) {\n        ++cursor;\n        return cursor - 1;\n      }\n      ++cursor;\n    }\n    return -1;\n  }\n\n  function getNextVertex(\n    indices,\n    cacheSize,\n    oneRing,\n    vertices,\n    s,\n    deadEnd,\n    maximumIndexPlusOne\n  ) {\n    var n = -1;\n    var p;\n    var m = -1;\n    var itOneRing = 0;\n    while (itOneRing < oneRing.length) {\n      var index = oneRing[itOneRing];\n      if (vertices[index].numLiveTriangles) {\n        p = 0;\n        if (\n          s -\n            vertices[index].timeStamp +\n            2 * vertices[index].numLiveTriangles <=\n          cacheSize\n        ) {\n          p = s - vertices[index].timeStamp;\n        }\n        if (p > m || m === -1) {\n          m = p;\n          n = index;\n        }\n      }\n      ++itOneRing;\n    }\n    if (n === -1) {\n      return skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne);\n    }\n    return n;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(indices)) {\n    throw new DeveloperError(\"indices is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var numIndices = indices.length;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numIndices < 3 || numIndices % 3 !== 0) {\n    throw new DeveloperError(\"indices length must be a multiple of three.\");\n  }\n  if (maximumIndex <= 0) {\n    throw new DeveloperError(\"maximumIndex must be greater than zero.\");\n  }\n  if (cacheSize < 3) {\n    throw new DeveloperError(\"cacheSize must be greater than two.\");\n  }\n  //>>includeEnd('debug');\n\n  // Determine maximum index\n  var maximumIndexPlusOne = 0;\n  var currentIndex = 0;\n  var intoIndices = indices[currentIndex];\n  var endIndex = numIndices;\n  if (defined(maximumIndex)) {\n    maximumIndexPlusOne = maximumIndex + 1;\n  } else {\n    while (currentIndex < endIndex) {\n      if (intoIndices > maximumIndexPlusOne) {\n        maximumIndexPlusOne = intoIndices;\n      }\n      ++currentIndex;\n      intoIndices = indices[currentIndex];\n    }\n    if (maximumIndexPlusOne === -1) {\n      return 0;\n    }\n    ++maximumIndexPlusOne;\n  }\n\n  // Vertices\n  var vertices = [];\n  var i;\n  for (i = 0; i < maximumIndexPlusOne; i++) {\n    vertices[i] = {\n      numLiveTriangles: 0,\n      timeStamp: 0,\n      vertexTriangles: [],\n    };\n  }\n  currentIndex = 0;\n  var triangle = 0;\n  while (currentIndex < endIndex) {\n    vertices[indices[currentIndex]].vertexTriangles.push(triangle);\n    ++vertices[indices[currentIndex]].numLiveTriangles;\n    vertices[indices[currentIndex + 1]].vertexTriangles.push(triangle);\n    ++vertices[indices[currentIndex + 1]].numLiveTriangles;\n    vertices[indices[currentIndex + 2]].vertexTriangles.push(triangle);\n    ++vertices[indices[currentIndex + 2]].numLiveTriangles;\n    ++triangle;\n    currentIndex += 3;\n  }\n\n  // Starting index\n  var f = 0;\n\n  // Time Stamp\n  var s = cacheSize + 1;\n  cursor = 1;\n\n  // Process\n  var oneRing = [];\n  var deadEnd = []; //Stack\n  var vertex;\n  var intoVertices;\n  var currentOutputIndex = 0;\n  var outputIndices = [];\n  var numTriangles = numIndices / 3;\n  var triangleEmitted = [];\n  for (i = 0; i < numTriangles; i++) {\n    triangleEmitted[i] = false;\n  }\n  var index;\n  var limit;\n  while (f !== -1) {\n    oneRing = [];\n    intoVertices = vertices[f];\n    limit = intoVertices.vertexTriangles.length;\n    for (var k = 0; k < limit; ++k) {\n      triangle = intoVertices.vertexTriangles[k];\n      if (!triangleEmitted[triangle]) {\n        triangleEmitted[triangle] = true;\n        currentIndex = triangle + triangle + triangle;\n        for (var j = 0; j < 3; ++j) {\n          // Set this index as a possible next index\n          index = indices[currentIndex];\n          oneRing.push(index);\n          deadEnd.push(index);\n\n          // Output index\n          outputIndices[currentOutputIndex] = index;\n          ++currentOutputIndex;\n\n          // Cache processing\n          vertex = vertices[index];\n          --vertex.numLiveTriangles;\n          if (s - vertex.timeStamp > cacheSize) {\n            vertex.timeStamp = s;\n            ++s;\n          }\n          ++currentIndex;\n        }\n      }\n    }\n    f = getNextVertex(\n      indices,\n      cacheSize,\n      oneRing,\n      vertices,\n      s,\n      deadEnd,\n      maximumIndexPlusOne\n    );\n  }\n\n  return outputIndices;\n};\nexport default Tipsify;\n"]},"metadata":{},"sourceType":"module"}