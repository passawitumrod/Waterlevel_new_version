{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport ShadowVolumeFS from \"../Shaders/ShadowVolumeFS.js\";\nimport VectorTileVS from \"../Shaders/VectorTileVS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Cesium3DTileFeature from \"./Cesium3DTileFeature.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport Expression from \"./Expression.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\nimport Vector3DTileBatch from \"./Vector3DTileBatch.js\";\n/**\n * Creates a batch of classification meshes.\n *\n * @alias Vector3DTilePrimitive\n * @constructor\n *\n * @param {Object} options An object with following properties:\n * @param {Float32Array} options.positions The positions of the meshes.\n * @param {Uint16Array|Uint32Array} options.indices The indices of the triangulated meshes. The indices must be contiguous so that\n * the indices for mesh n are in [i, i + indexCounts[n]] where i = sum{indexCounts[0], indexCounts[n - 1]}.\n * @param {Uint32Array} options.indexCounts The number of indices for each mesh.\n * @param {Uint32Array} options.indexOffsets The offset into the index buffer for each mesh.\n * @param {Vector3DTileBatch[]} options.batchedIndices The index offset and count for each batch with the same color.\n * @param {Cartesian3} [options.center=Cartesian3.ZERO] The RTC center.\n * @param {Cesium3DTileBatchTable} options.batchTable The batch table for the tile containing the batched meshes.\n * @param {Uint16Array} options.batchIds The batch ids for each mesh.\n * @param {Uint16Array} options.vertexBatchIds The batch id for each vertex.\n * @param {BoundingSphere} options.boundingVolume The bounding volume for the entire batch of meshes.\n * @param {BoundingSphere[]} options.boundingVolumes The bounding volume for each mesh.\n * @param {ClassificationType} [options.classificationType] What this tile will classify.\n *\n * @private\n */\n\nfunction Vector3DTilePrimitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  this._batchTable = options.batchTable;\n  this._batchIds = options.batchIds; // These arrays are released after VAO creation.\n\n  this._positions = options.positions;\n  this._vertexBatchIds = options.vertexBatchIds; // These arrays are kept for re-batching indices based on colors.\n  // If WebGL 2 is supported, indices will be released and re-batching uses buffer-to-buffer copies.\n\n  this._indices = options.indices;\n  this._indexCounts = options.indexCounts;\n  this._indexOffsets = options.indexOffsets;\n  this._batchedIndices = options.batchedIndices;\n  this._boundingVolume = options.boundingVolume;\n  this._boundingVolumes = options.boundingVolumes;\n  this._center = defaultValue(options.center, Cartesian3.ZERO);\n  this._va = undefined;\n  this._sp = undefined;\n  this._spStencil = undefined;\n  this._spPick = undefined;\n  this._uniformMap = undefined; // Only used with WebGL 2 to ping-pong ibos after copy.\n\n  this._vaSwap = undefined;\n  this._rsStencilPreloadPass = undefined;\n  this._rsStencilPreloadPass3DTiles = undefined;\n  this._rsStencilDepthPass = undefined;\n  this._rsStencilDepthPass3DTiles = undefined;\n  this._rsColorPass = undefined;\n  this._rsPickPass = undefined;\n  this._rsWireframe = undefined;\n  this._commands = [];\n  this._commandsIgnoreShow = [];\n  this._pickCommands = [];\n  this._constantColor = Color.clone(Color.WHITE);\n  this._highlightColor = this._constantColor;\n  this._batchDirty = true;\n  this._pickCommandsDirty = true;\n  this._framesSinceLastRebatch = 0;\n  this._updatingAllCommands = false;\n  this._trianglesLength = this._indices.length / 3;\n  this._geometryByteLength = this._indices.byteLength + this._positions.byteLength + this._vertexBatchIds.byteLength;\n  /**\n   * Draw the wireframe of the classification meshes.\n   * @type {Boolean}\n   * @default false\n   */\n\n  this.debugWireframe = false;\n  this._debugWireframe = this.debugWireframe;\n  this._wireframeDirty = false;\n  /**\n   * Forces a re-batch instead of waiting after a number of frames have been rendered. For testing only.\n   * @type {Boolean}\n   * @default false\n   */\n\n  this.forceRebatch = false;\n  /**\n   * What this tile will classify.\n   * @type {ClassificationType}\n   * @default ClassificationType.BOTH\n   */\n\n  this.classificationType = defaultValue(options.classificationType, ClassificationType.BOTH); // Hidden options\n\n  this._vertexShaderSource = options._vertexShaderSource;\n  this._fragmentShaderSource = options._fragmentShaderSource;\n  this._attributeLocations = options._attributeLocations;\n  this._uniformMap = options._uniformMap;\n  this._pickId = options._pickId;\n  this._modelMatrix = options._modelMatrix;\n  this._boundingSphere = options._boundingSphere;\n  this._batchIdLookUp = {};\n  var length = this._batchIds.length;\n\n  for (var i = 0; i < length; ++i) {\n    var batchId = this._batchIds[i];\n    this._batchIdLookUp[batchId] = i;\n  }\n}\n\nObject.defineProperties(Vector3DTilePrimitive.prototype, {\n  /**\n   * Gets the number of triangles.\n   *\n   * @memberof Vector3DTilePrimitive.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  trianglesLength: {\n    get: function () {\n      return this._trianglesLength;\n    }\n  },\n\n  /**\n   * Gets the geometry memory in bytes.\n   *\n   * @memberof Vector3DTilePrimitive.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  geometryByteLength: {\n    get: function () {\n      return this._geometryByteLength;\n    }\n  }\n});\nvar defaultAttributeLocations = {\n  position: 0,\n  a_batchId: 1\n};\n\nfunction createVertexArray(primitive, context) {\n  if (defined(primitive._va)) {\n    return;\n  }\n\n  var positionBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: primitive._positions,\n    usage: BufferUsage.STATIC_DRAW\n  });\n  var idBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: primitive._vertexBatchIds,\n    usage: BufferUsage.STATIC_DRAW\n  });\n  var indexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: primitive._indices,\n    usage: BufferUsage.DYNAMIC_DRAW,\n    indexDatatype: primitive._indices.BYTES_PER_ELEMENT === 2 ? IndexDatatype.UNSIGNED_SHORT : IndexDatatype.UNSIGNED_INT\n  });\n  var vertexAttributes = [{\n    index: 0,\n    vertexBuffer: positionBuffer,\n    componentDatatype: ComponentDatatype.fromTypedArray(primitive._positions),\n    componentsPerAttribute: 3\n  }, {\n    index: 1,\n    vertexBuffer: idBuffer,\n    componentDatatype: ComponentDatatype.fromTypedArray(primitive._vertexBatchIds),\n    componentsPerAttribute: 1\n  }];\n  primitive._va = new VertexArray({\n    context: context,\n    attributes: vertexAttributes,\n    indexBuffer: indexBuffer\n  });\n\n  if (context.webgl2) {\n    primitive._vaSwap = new VertexArray({\n      context: context,\n      attributes: vertexAttributes,\n      indexBuffer: Buffer.createIndexBuffer({\n        context: context,\n        sizeInBytes: indexBuffer.sizeInBytes,\n        usage: BufferUsage.DYNAMIC_DRAW,\n        indexDatatype: indexBuffer.indexDatatype\n      })\n    });\n  }\n\n  primitive._batchedPositions = undefined;\n  primitive._transferrableBatchIds = undefined;\n  primitive._vertexBatchIds = undefined;\n  primitive._verticesPromise = undefined;\n}\n\nfunction createShaders(primitive, context) {\n  if (defined(primitive._sp)) {\n    return;\n  }\n\n  var batchTable = primitive._batchTable;\n  var attributeLocations = defaultValue(primitive._attributeLocations, defaultAttributeLocations);\n  var pickId = primitive._pickId;\n  var vertexShaderSource = primitive._vertexShaderSource;\n  var fragmentShaderSource = primitive._fragmentShaderSource;\n\n  if (defined(vertexShaderSource)) {\n    primitive._sp = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vertexShaderSource,\n      fragmentShaderSource: fragmentShaderSource,\n      attributeLocations: attributeLocations\n    });\n    primitive._spStencil = primitive._sp;\n    fragmentShaderSource = ShaderSource.replaceMain(fragmentShaderSource, \"czm_non_pick_main\");\n    fragmentShaderSource = fragmentShaderSource + \"void main() \\n\" + \"{ \\n\" + \"    czm_non_pick_main(); \\n\" + \"    gl_FragColor = \" + pickId + \"; \\n\" + \"} \\n\";\n    primitive._spPick = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vertexShaderSource,\n      fragmentShaderSource: fragmentShaderSource,\n      attributeLocations: attributeLocations\n    });\n    return;\n  }\n\n  var vsSource = batchTable.getVertexShaderCallback(false, \"a_batchId\", undefined)(VectorTileVS);\n  var fsSource = batchTable.getFragmentShaderCallback()(ShadowVolumeFS, false, undefined);\n  pickId = batchTable.getPickId();\n  var vs = new ShaderSource({\n    sources: [vsSource]\n  });\n  var fs = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [fsSource]\n  });\n  primitive._sp = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations\n  });\n  vs = new ShaderSource({\n    sources: [VectorTileVS]\n  });\n  fs = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [ShadowVolumeFS]\n  });\n  primitive._spStencil = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations\n  });\n  fsSource = ShaderSource.replaceMain(fsSource, \"czm_non_pick_main\");\n  fsSource = fsSource + \"\\n\" + \"void main() \\n\" + \"{ \\n\" + \"    czm_non_pick_main(); \\n\" + \"    gl_FragColor = \" + pickId + \"; \\n\" + \"} \\n\";\n  var pickVS = new ShaderSource({\n    sources: [vsSource]\n  });\n  var pickFS = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [fsSource]\n  });\n  primitive._spPick = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: pickVS,\n    fragmentShaderSource: pickFS,\n    attributeLocations: attributeLocations\n  });\n}\n\nfunction getStencilPreloadRenderState(mask3DTiles) {\n  var stencilFunction = mask3DTiles ? StencilFunction.EQUAL : StencilFunction.ALWAYS;\n  return {\n    colorMask: {\n      red: false,\n      green: false,\n      blue: false,\n      alpha: false\n    },\n    stencilTest: {\n      enabled: true,\n      frontFunction: stencilFunction,\n      frontOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.DECREMENT_WRAP,\n        zPass: StencilOperation.DECREMENT_WRAP\n      },\n      backFunction: stencilFunction,\n      backOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.INCREMENT_WRAP,\n        zPass: StencilOperation.INCREMENT_WRAP\n      },\n      reference: StencilConstants.CESIUM_3D_TILE_MASK,\n      mask: StencilConstants.CESIUM_3D_TILE_MASK\n    },\n    stencilMask: StencilConstants.CLASSIFICATION_MASK,\n    depthTest: {\n      enabled: false\n    },\n    depthMask: false\n  };\n}\n\nfunction getStencilDepthRenderState(mask3DTiles) {\n  var stencilFunction = mask3DTiles ? StencilFunction.EQUAL : StencilFunction.ALWAYS;\n  return {\n    colorMask: {\n      red: false,\n      green: false,\n      blue: false,\n      alpha: false\n    },\n    stencilTest: {\n      enabled: true,\n      frontFunction: stencilFunction,\n      frontOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.INCREMENT_WRAP\n      },\n      backFunction: stencilFunction,\n      backOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.DECREMENT_WRAP\n      },\n      reference: StencilConstants.CESIUM_3D_TILE_MASK,\n      mask: StencilConstants.CESIUM_3D_TILE_MASK\n    },\n    stencilMask: StencilConstants.CLASSIFICATION_MASK,\n    depthTest: {\n      enabled: true,\n      func: DepthFunction.LESS_OR_EQUAL\n    },\n    depthMask: false\n  };\n}\n\nvar colorRenderState = {\n  stencilTest: {\n    enabled: true,\n    frontFunction: StencilFunction.NOT_EQUAL,\n    frontOperation: {\n      fail: StencilOperation.KEEP,\n      zFail: StencilOperation.KEEP,\n      zPass: StencilOperation.DECREMENT_WRAP\n    },\n    backFunction: StencilFunction.NOT_EQUAL,\n    backOperation: {\n      fail: StencilOperation.KEEP,\n      zFail: StencilOperation.KEEP,\n      zPass: StencilOperation.DECREMENT_WRAP\n    },\n    reference: 0,\n    mask: StencilConstants.CLASSIFICATION_MASK\n  },\n  stencilMask: StencilConstants.CLASSIFICATION_MASK,\n  depthTest: {\n    enabled: false\n  },\n  depthMask: false,\n  blending: BlendingState.ALPHA_BLEND\n};\nvar pickRenderState = {\n  stencilTest: {\n    enabled: true,\n    frontFunction: StencilFunction.NOT_EQUAL,\n    frontOperation: {\n      fail: StencilOperation.KEEP,\n      zFail: StencilOperation.KEEP,\n      zPass: StencilOperation.DECREMENT_WRAP\n    },\n    backFunction: StencilFunction.NOT_EQUAL,\n    backOperation: {\n      fail: StencilOperation.KEEP,\n      zFail: StencilOperation.KEEP,\n      zPass: StencilOperation.DECREMENT_WRAP\n    },\n    reference: 0,\n    mask: StencilConstants.CLASSIFICATION_MASK\n  },\n  stencilMask: StencilConstants.CLASSIFICATION_MASK,\n  depthTest: {\n    enabled: false\n  },\n  depthMask: false\n};\n\nfunction createRenderStates(primitive) {\n  if (defined(primitive._rsStencilPreloadPass)) {\n    return;\n  }\n\n  primitive._rsStencilPreloadPass = RenderState.fromCache(getStencilPreloadRenderState(false));\n  primitive._rsStencilPreloadPass3DTiles = RenderState.fromCache(getStencilPreloadRenderState(true));\n  primitive._rsStencilDepthPass = RenderState.fromCache(getStencilDepthRenderState(false));\n  primitive._rsStencilDepthPass3DTiles = RenderState.fromCache(getStencilDepthRenderState(true));\n  primitive._rsColorPass = RenderState.fromCache(colorRenderState);\n  primitive._rsPickPass = RenderState.fromCache(pickRenderState);\n}\n\nvar modifiedModelViewScratch = new Matrix4();\nvar rtcScratch = new Cartesian3();\n\nfunction createUniformMap(primitive, context) {\n  if (defined(primitive._uniformMap)) {\n    return;\n  }\n\n  var uniformMap = {\n    u_modifiedModelViewProjection: function () {\n      var viewMatrix = context.uniformState.view;\n      var projectionMatrix = context.uniformState.projection;\n      Matrix4.clone(viewMatrix, modifiedModelViewScratch);\n      Matrix4.multiplyByPoint(modifiedModelViewScratch, primitive._center, rtcScratch);\n      Matrix4.setTranslation(modifiedModelViewScratch, rtcScratch, modifiedModelViewScratch);\n      Matrix4.multiply(projectionMatrix, modifiedModelViewScratch, modifiedModelViewScratch);\n      return modifiedModelViewScratch;\n    },\n    u_highlightColor: function () {\n      return primitive._highlightColor;\n    }\n  };\n  primitive._uniformMap = primitive._batchTable.getUniformMapCallback()(uniformMap);\n}\n\nfunction copyIndicesCPU(indices, newIndices, currentOffset, offsets, counts, batchIds, batchIdLookUp) {\n  var sizeInBytes = indices.constructor.BYTES_PER_ELEMENT;\n  var batchedIdsLength = batchIds.length;\n\n  for (var j = 0; j < batchedIdsLength; ++j) {\n    var batchedId = batchIds[j];\n    var index = batchIdLookUp[batchedId];\n    var offset = offsets[index];\n    var count = counts[index];\n    var subarray = new indices.constructor(indices.buffer, sizeInBytes * offset, count);\n    newIndices.set(subarray, currentOffset);\n    offsets[index] = currentOffset;\n    currentOffset += count;\n  }\n\n  return currentOffset;\n}\n\nfunction rebatchCPU(primitive, batchedIndices) {\n  var indices = primitive._indices;\n  var indexOffsets = primitive._indexOffsets;\n  var indexCounts = primitive._indexCounts;\n  var batchIdLookUp = primitive._batchIdLookUp;\n  var newIndices = new indices.constructor(indices.length);\n  var current = batchedIndices.pop();\n  var newBatchedIndices = [current];\n  var currentOffset = copyIndicesCPU(indices, newIndices, 0, indexOffsets, indexCounts, current.batchIds, batchIdLookUp);\n  current.offset = 0;\n  current.count = currentOffset;\n\n  while (batchedIndices.length > 0) {\n    var next = batchedIndices.pop();\n\n    if (Color.equals(next.color, current.color)) {\n      currentOffset = copyIndicesCPU(indices, newIndices, currentOffset, indexOffsets, indexCounts, next.batchIds, batchIdLookUp);\n      current.batchIds = current.batchIds.concat(next.batchIds);\n      current.count = currentOffset - current.offset;\n    } else {\n      var offset = currentOffset;\n      currentOffset = copyIndicesCPU(indices, newIndices, currentOffset, indexOffsets, indexCounts, next.batchIds, batchIdLookUp);\n      next.offset = offset;\n      next.count = currentOffset - offset;\n      newBatchedIndices.push(next);\n      current = next;\n    }\n  }\n\n  primitive._va.indexBuffer.copyFromArrayView(newIndices);\n\n  primitive._indices = newIndices;\n  primitive._batchedIndices = newBatchedIndices;\n}\n\nfunction copyIndicesGPU(readBuffer, writeBuffer, currentOffset, offsets, counts, batchIds, batchIdLookUp) {\n  var sizeInBytes = readBuffer.bytesPerIndex;\n  var batchedIdsLength = batchIds.length;\n\n  for (var j = 0; j < batchedIdsLength; ++j) {\n    var batchedId = batchIds[j];\n    var index = batchIdLookUp[batchedId];\n    var offset = offsets[index];\n    var count = counts[index];\n    writeBuffer.copyFromBuffer(readBuffer, offset * sizeInBytes, currentOffset * sizeInBytes, count * sizeInBytes);\n    offsets[index] = currentOffset;\n    currentOffset += count;\n  }\n\n  return currentOffset;\n}\n\nfunction rebatchGPU(primitive, batchedIndices) {\n  var indexOffsets = primitive._indexOffsets;\n  var indexCounts = primitive._indexCounts;\n  var batchIdLookUp = primitive._batchIdLookUp;\n  var current = batchedIndices.pop();\n  var newBatchedIndices = [current];\n  var readBuffer = primitive._va.indexBuffer;\n  var writeBuffer = primitive._vaSwap.indexBuffer;\n  var currentOffset = copyIndicesGPU(readBuffer, writeBuffer, 0, indexOffsets, indexCounts, current.batchIds, batchIdLookUp);\n  current.offset = 0;\n  current.count = currentOffset;\n\n  while (batchedIndices.length > 0) {\n    var next = batchedIndices.pop();\n\n    if (Color.equals(next.color, current.color)) {\n      currentOffset = copyIndicesGPU(readBuffer, writeBuffer, currentOffset, indexOffsets, indexCounts, next.batchIds, batchIdLookUp);\n      current.batchIds = current.batchIds.concat(next.batchIds);\n      current.count = currentOffset - current.offset;\n    } else {\n      var offset = currentOffset;\n      currentOffset = copyIndicesGPU(readBuffer, writeBuffer, currentOffset, indexOffsets, indexCounts, next.batchIds, batchIdLookUp);\n      next.offset = offset;\n      next.count = currentOffset - offset;\n      newBatchedIndices.push(next);\n      current = next;\n    }\n  }\n\n  var temp = primitive._va;\n  primitive._va = primitive._vaSwap;\n  primitive._vaSwap = temp;\n  primitive._batchedIndices = newBatchedIndices;\n}\n\nfunction compareColors(a, b) {\n  return b.color.toRgba() - a.color.toRgba();\n} // PERFORMANCE_IDEA: For WebGL 2, we can use copyBufferSubData for buffer-to-buffer copies.\n// PERFORMANCE_IDEA: Not supported, but we could use glMultiDrawElements here.\n\n\nfunction rebatchCommands(primitive, context) {\n  if (!primitive._batchDirty) {\n    return false;\n  }\n\n  var batchedIndices = primitive._batchedIndices;\n  var length = batchedIndices.length;\n  var needToRebatch = false;\n  var colorCounts = {};\n\n  for (var i = 0; i < length; ++i) {\n    var color = batchedIndices[i].color;\n    var rgba = color.toRgba();\n\n    if (defined(colorCounts[rgba])) {\n      needToRebatch = true;\n      break;\n    } else {\n      colorCounts[rgba] = true;\n    }\n  }\n\n  if (!needToRebatch) {\n    primitive._batchDirty = false;\n    return false;\n  }\n\n  if (needToRebatch && !primitive.forceRebatch && primitive._framesSinceLastRebatch < 120) {\n    ++primitive._framesSinceLastRebatch;\n    return;\n  }\n\n  batchedIndices.sort(compareColors);\n\n  if (context.webgl2) {\n    rebatchGPU(primitive, batchedIndices);\n  } else {\n    rebatchCPU(primitive, batchedIndices);\n  }\n\n  primitive._framesSinceLastRebatch = 0;\n  primitive._batchDirty = false;\n  primitive._pickCommandsDirty = true;\n  primitive._wireframeDirty = true;\n  return true;\n}\n\nfunction createColorCommands(primitive, context) {\n  var needsRebatch = rebatchCommands(primitive, context);\n  var commands = primitive._commands;\n  var batchedIndices = primitive._batchedIndices;\n  var length = batchedIndices.length;\n  var commandsLength = length * 3;\n\n  if (defined(commands) && !needsRebatch && commands.length === commandsLength) {\n    return;\n  }\n\n  commands.length = commandsLength;\n  var vertexArray = primitive._va;\n  var sp = primitive._sp;\n  var modelMatrix = defaultValue(primitive._modelMatrix, Matrix4.IDENTITY);\n  var uniformMap = primitive._uniformMap;\n  var bv = primitive._boundingVolume;\n\n  for (var j = 0; j < length; ++j) {\n    var offset = batchedIndices[j].offset;\n    var count = batchedIndices[j].count;\n    var stencilPreloadCommand = commands[j * 3];\n\n    if (!defined(stencilPreloadCommand)) {\n      stencilPreloadCommand = commands[j * 3] = new DrawCommand({\n        owner: primitive\n      });\n    }\n\n    stencilPreloadCommand.vertexArray = vertexArray;\n    stencilPreloadCommand.modelMatrix = modelMatrix;\n    stencilPreloadCommand.offset = offset;\n    stencilPreloadCommand.count = count;\n    stencilPreloadCommand.renderState = primitive._rsStencilPreloadPass;\n    stencilPreloadCommand.shaderProgram = sp;\n    stencilPreloadCommand.uniformMap = uniformMap;\n    stencilPreloadCommand.boundingVolume = bv;\n    stencilPreloadCommand.cull = false;\n    stencilPreloadCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n    var stencilPreloadDerivedCommand = DrawCommand.shallowClone(stencilPreloadCommand, stencilPreloadCommand.derivedCommands.tileset);\n    stencilPreloadDerivedCommand.renderState = primitive._rsStencilPreloadPass3DTiles;\n    stencilPreloadDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    stencilPreloadCommand.derivedCommands.tileset = stencilPreloadDerivedCommand;\n    var stencilDepthCommand = commands[j * 3 + 1];\n\n    if (!defined(stencilDepthCommand)) {\n      stencilDepthCommand = commands[j * 3 + 1] = new DrawCommand({\n        owner: primitive\n      });\n    }\n\n    stencilDepthCommand.vertexArray = vertexArray;\n    stencilDepthCommand.modelMatrix = modelMatrix;\n    stencilDepthCommand.offset = offset;\n    stencilDepthCommand.count = count;\n    stencilDepthCommand.renderState = primitive._rsStencilDepthPass;\n    stencilDepthCommand.shaderProgram = sp;\n    stencilDepthCommand.uniformMap = uniformMap;\n    stencilDepthCommand.boundingVolume = bv;\n    stencilDepthCommand.cull = false;\n    stencilDepthCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n    var stencilDepthDerivedCommand = DrawCommand.shallowClone(stencilDepthCommand, stencilDepthCommand.derivedCommands.tileset);\n    stencilDepthDerivedCommand.renderState = primitive._rsStencilDepthPass3DTiles;\n    stencilDepthDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    stencilDepthCommand.derivedCommands.tileset = stencilDepthDerivedCommand;\n    var colorCommand = commands[j * 3 + 2];\n\n    if (!defined(colorCommand)) {\n      colorCommand = commands[j * 3 + 2] = new DrawCommand({\n        owner: primitive\n      });\n    }\n\n    colorCommand.vertexArray = vertexArray;\n    colorCommand.modelMatrix = modelMatrix;\n    colorCommand.offset = offset;\n    colorCommand.count = count;\n    colorCommand.renderState = primitive._rsColorPass;\n    colorCommand.shaderProgram = sp;\n    colorCommand.uniformMap = uniformMap;\n    colorCommand.boundingVolume = bv;\n    colorCommand.cull = false;\n    colorCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n    var colorDerivedCommand = DrawCommand.shallowClone(colorCommand, colorCommand.derivedCommands.tileset);\n    colorDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    colorCommand.derivedCommands.tileset = colorDerivedCommand;\n  }\n\n  primitive._commandsDirty = true;\n}\n\nfunction createColorCommandsIgnoreShow(primitive, frameState) {\n  if (primitive.classificationType === ClassificationType.TERRAIN || !frameState.invertClassification || defined(primitive._commandsIgnoreShow) && !primitive._commandsDirty) {\n    return;\n  }\n\n  var commands = primitive._commands;\n  var commandsIgnoreShow = primitive._commandsIgnoreShow;\n  var spStencil = primitive._spStencil;\n  var commandsLength = commands.length;\n  var length = commandsIgnoreShow.length = commandsLength / 3 * 2;\n  var commandIndex = 0;\n\n  for (var j = 0; j < length; j += 2) {\n    var commandIgnoreShow = commandsIgnoreShow[j] = DrawCommand.shallowClone(commands[commandIndex], commandsIgnoreShow[j]);\n    commandIgnoreShow.shaderProgram = spStencil;\n    commandIgnoreShow.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW;\n    commandIgnoreShow = commandsIgnoreShow[j + 1] = DrawCommand.shallowClone(commands[commandIndex + 1], commandsIgnoreShow[j + 1]);\n    commandIgnoreShow.shaderProgram = spStencil;\n    commandIgnoreShow.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW;\n    commandIndex += 3;\n  }\n\n  primitive._commandsDirty = false;\n}\n\nfunction createPickCommands(primitive) {\n  if (!primitive._pickCommandsDirty) {\n    return;\n  }\n\n  var length = primitive._indexOffsets.length;\n  var pickCommands = primitive._pickCommands;\n  pickCommands.length = length * 3;\n  var vertexArray = primitive._va;\n  var spStencil = primitive._spStencil;\n  var spPick = primitive._spPick;\n  var modelMatrix = defaultValue(primitive._modelMatrix, Matrix4.IDENTITY);\n  var uniformMap = primitive._uniformMap;\n\n  for (var j = 0; j < length; ++j) {\n    var offset = primitive._indexOffsets[j];\n    var count = primitive._indexCounts[j];\n    var bv = defined(primitive._boundingVolumes) ? primitive._boundingVolumes[j] : primitive.boundingVolume;\n    var stencilPreloadCommand = pickCommands[j * 3];\n\n    if (!defined(stencilPreloadCommand)) {\n      stencilPreloadCommand = pickCommands[j * 3] = new DrawCommand({\n        owner: primitive,\n        pickOnly: true\n      });\n    }\n\n    stencilPreloadCommand.vertexArray = vertexArray;\n    stencilPreloadCommand.modelMatrix = modelMatrix;\n    stencilPreloadCommand.offset = offset;\n    stencilPreloadCommand.count = count;\n    stencilPreloadCommand.renderState = primitive._rsStencilPreloadPass;\n    stencilPreloadCommand.shaderProgram = spStencil;\n    stencilPreloadCommand.uniformMap = uniformMap;\n    stencilPreloadCommand.boundingVolume = bv;\n    stencilPreloadCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n    var stencilPreloadDerivedCommand = DrawCommand.shallowClone(stencilPreloadCommand, stencilPreloadCommand.derivedCommands.tileset);\n    stencilPreloadDerivedCommand.renderState = primitive._rsStencilPreloadPass3DTiles;\n    stencilPreloadDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    stencilPreloadCommand.derivedCommands.tileset = stencilPreloadDerivedCommand;\n    var stencilDepthCommand = pickCommands[j * 3 + 1];\n\n    if (!defined(stencilDepthCommand)) {\n      stencilDepthCommand = pickCommands[j * 3 + 1] = new DrawCommand({\n        owner: primitive,\n        pickOnly: true\n      });\n    }\n\n    stencilDepthCommand.vertexArray = vertexArray;\n    stencilDepthCommand.modelMatrix = modelMatrix;\n    stencilDepthCommand.offset = offset;\n    stencilDepthCommand.count = count;\n    stencilDepthCommand.renderState = primitive._rsStencilDepthPass;\n    stencilDepthCommand.shaderProgram = spStencil;\n    stencilDepthCommand.uniformMap = uniformMap;\n    stencilDepthCommand.boundingVolume = bv;\n    stencilDepthCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n    var stencilDepthDerivedCommand = DrawCommand.shallowClone(stencilDepthCommand, stencilDepthCommand.derivedCommands.tileset);\n    stencilDepthDerivedCommand.renderState = primitive._rsStencilDepthPass3DTiles;\n    stencilDepthDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    stencilDepthCommand.derivedCommands.tileset = stencilDepthDerivedCommand;\n    var colorCommand = pickCommands[j * 3 + 2];\n\n    if (!defined(colorCommand)) {\n      colorCommand = pickCommands[j * 3 + 2] = new DrawCommand({\n        owner: primitive,\n        pickOnly: true\n      });\n    }\n\n    colorCommand.vertexArray = vertexArray;\n    colorCommand.modelMatrix = modelMatrix;\n    colorCommand.offset = offset;\n    colorCommand.count = count;\n    colorCommand.renderState = primitive._rsPickPass;\n    colorCommand.shaderProgram = spPick;\n    colorCommand.uniformMap = uniformMap;\n    colorCommand.boundingVolume = bv;\n    colorCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n    var colorDerivedCommand = DrawCommand.shallowClone(colorCommand, colorCommand.derivedCommands.tileset);\n    colorDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    colorCommand.derivedCommands.tileset = colorDerivedCommand;\n  }\n\n  primitive._pickCommandsDirty = false;\n}\n/**\n * Creates features for each mesh and places it at the batch id index of features.\n *\n * @param {Vector3DTileContent} content The vector tile content.\n * @param {Cesium3DTileFeature[]} features An array of features where the polygon features will be placed.\n */\n\n\nVector3DTilePrimitive.prototype.createFeatures = function (content, features) {\n  var batchIds = this._batchIds;\n  var length = batchIds.length;\n\n  for (var i = 0; i < length; ++i) {\n    var batchId = batchIds[i];\n    features[batchId] = new Cesium3DTileFeature(content, batchId);\n  }\n};\n/**\n * Colors the entire tile when enabled is true. The resulting color will be (mesh batch table color * color).\n *\n * @param {Boolean} enabled Whether to enable debug coloring.\n * @param {Color} color The debug color.\n */\n\n\nVector3DTilePrimitive.prototype.applyDebugSettings = function (enabled, color) {\n  this._highlightColor = enabled ? color : this._constantColor;\n};\n\nfunction clearStyle(polygons, features) {\n  polygons._updatingAllCommands = true;\n  var batchIds = polygons._batchIds;\n  var length = batchIds.length;\n  var i;\n\n  for (i = 0; i < length; ++i) {\n    var batchId = batchIds[i];\n    var feature = features[batchId];\n    feature.show = true;\n    feature.color = Color.WHITE;\n  }\n\n  var batchedIndices = polygons._batchedIndices;\n  length = batchedIndices.length;\n\n  for (i = 0; i < length; ++i) {\n    batchedIndices[i].color = Color.clone(Color.WHITE);\n  }\n\n  polygons._updatingAllCommands = false;\n  polygons._batchDirty = true;\n}\n\nvar scratchColor = new Color();\nvar DEFAULT_COLOR_VALUE = Color.WHITE;\nvar DEFAULT_SHOW_VALUE = true;\nvar complexExpressionReg = /\\$/;\n/**\n * Apply a style to the content.\n *\n * @param {Cesium3DTileStyle} style The style.\n * @param {Cesium3DTileFeature[]} features The array of features.\n */\n\nVector3DTilePrimitive.prototype.applyStyle = function (style, features) {\n  if (!defined(style)) {\n    clearStyle(this, features);\n    return;\n  }\n\n  var colorExpression = style.color;\n  var isSimpleStyle = colorExpression instanceof Expression && !complexExpressionReg.test(colorExpression.expression);\n  this._updatingAllCommands = isSimpleStyle;\n  var batchIds = this._batchIds;\n  var length = batchIds.length;\n  var i;\n\n  for (i = 0; i < length; ++i) {\n    var batchId = batchIds[i];\n    var feature = features[batchId];\n    feature.color = defined(style.color) ? style.color.evaluateColor(feature, scratchColor) : DEFAULT_COLOR_VALUE;\n    feature.show = defined(style.show) ? style.show.evaluate(feature) : DEFAULT_SHOW_VALUE;\n  }\n\n  if (isSimpleStyle) {\n    var batchedIndices = this._batchedIndices;\n    length = batchedIndices.length;\n\n    for (i = 0; i < length; ++i) {\n      batchedIndices[i].color = Color.clone(Color.WHITE);\n    }\n\n    this._updatingAllCommands = false;\n    this._batchDirty = true;\n  }\n};\n/**\n * Call when updating the color of a mesh with batchId changes color. The meshes will need to be re-batched\n * on the next update.\n *\n * @param {Number} batchId The batch id of the meshes whose color has changed.\n * @param {Color} color The new polygon color.\n */\n\n\nVector3DTilePrimitive.prototype.updateCommands = function (batchId, color) {\n  if (this._updatingAllCommands) {\n    return;\n  }\n\n  var batchIdLookUp = this._batchIdLookUp;\n  var index = batchIdLookUp[batchId];\n\n  if (!defined(index)) {\n    return;\n  }\n\n  var indexOffsets = this._indexOffsets;\n  var indexCounts = this._indexCounts;\n  var offset = indexOffsets[index];\n  var count = indexCounts[index];\n  var batchedIndices = this._batchedIndices;\n  var length = batchedIndices.length;\n  var i;\n\n  for (i = 0; i < length; ++i) {\n    var batchedOffset = batchedIndices[i].offset;\n    var batchedCount = batchedIndices[i].count;\n\n    if (offset >= batchedOffset && offset < batchedOffset + batchedCount) {\n      break;\n    }\n  }\n\n  batchedIndices.push(new Vector3DTileBatch({\n    color: Color.clone(color),\n    offset: offset,\n    count: count,\n    batchIds: [batchId]\n  }));\n  var startIds = [];\n  var endIds = [];\n  var batchIds = batchedIndices[i].batchIds;\n  var batchIdsLength = batchIds.length;\n\n  for (var j = 0; j < batchIdsLength; ++j) {\n    var id = batchIds[j];\n\n    if (id === batchId) {\n      continue;\n    }\n\n    var offsetIndex = batchIdLookUp[id];\n\n    if (indexOffsets[offsetIndex] < offset) {\n      startIds.push(id);\n    } else {\n      endIds.push(id);\n    }\n  }\n\n  if (endIds.length !== 0) {\n    batchedIndices.push(new Vector3DTileBatch({\n      color: Color.clone(batchedIndices[i].color),\n      offset: offset + count,\n      count: batchedIndices[i].offset + batchedIndices[i].count - (offset + count),\n      batchIds: endIds\n    }));\n  }\n\n  if (startIds.length !== 0) {\n    batchedIndices[i].count = offset - batchedIndices[i].offset;\n    batchedIndices[i].batchIds = startIds;\n  } else {\n    batchedIndices.splice(i, 1);\n  }\n\n  this._batchDirty = true;\n};\n\nfunction queueCommands(primitive, frameState, commands, commandsIgnoreShow) {\n  var classificationType = primitive.classificationType;\n  var queueTerrainCommands = classificationType !== ClassificationType.CESIUM_3D_TILE;\n  var queue3DTilesCommands = classificationType !== ClassificationType.TERRAIN;\n  var commandList = frameState.commandList;\n  var commandLength = commands.length;\n  var command;\n  var i;\n\n  for (i = 0; i < commandLength; ++i) {\n    if (queueTerrainCommands) {\n      command = commands[i];\n      command.pass = Pass.TERRAIN_CLASSIFICATION;\n      commandList.push(command);\n    }\n\n    if (queue3DTilesCommands) {\n      command = commands[i].derivedCommands.tileset;\n      command.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n      commandList.push(command);\n    }\n  }\n\n  if (!frameState.invertClassification || !defined(commandsIgnoreShow)) {\n    return;\n  }\n\n  commandLength = commandsIgnoreShow.length;\n\n  for (i = 0; i < commandLength; ++i) {\n    commandList.push(commandsIgnoreShow[i]);\n  }\n}\n\nfunction queueWireframeCommands(frameState, commands) {\n  var commandList = frameState.commandList;\n  var commandLength = commands.length;\n\n  for (var i = 0; i < commandLength; i += 3) {\n    var command = commands[i + 2];\n    command.pass = Pass.OPAQUE;\n    commandList.push(command);\n  }\n}\n\nfunction updateWireframe(primitive) {\n  var earlyExit = primitive.debugWireframe === primitive._debugWireframe;\n  earlyExit = earlyExit && !(primitive.debugWireframe && primitive._wireframeDirty);\n\n  if (earlyExit) {\n    return;\n  }\n\n  if (!defined(primitive._rsWireframe)) {\n    primitive._rsWireframe = RenderState.fromCache({});\n  }\n\n  var rs;\n  var type;\n\n  if (primitive.debugWireframe) {\n    rs = primitive._rsWireframe;\n    type = PrimitiveType.LINES;\n  } else {\n    rs = primitive._rsColorPass;\n    type = PrimitiveType.TRIANGLES;\n  }\n\n  var commands = primitive._commands;\n  var commandLength = commands.length;\n\n  for (var i = 0; i < commandLength; i += 3) {\n    var command = commands[i + 2];\n    command.renderState = rs;\n    command.primitiveType = type;\n  }\n\n  primitive._debugWireframe = primitive.debugWireframe;\n  primitive._wireframeDirty = false;\n}\n/**\n * Updates the batches and queues the commands for rendering.\n *\n * @param {FrameState} frameState The current frame state.\n */\n\n\nVector3DTilePrimitive.prototype.update = function (frameState) {\n  var context = frameState.context;\n  createVertexArray(this, context);\n  createShaders(this, context);\n  createRenderStates(this);\n  createUniformMap(this, context);\n  var passes = frameState.passes;\n\n  if (passes.render) {\n    createColorCommands(this, context);\n    createColorCommandsIgnoreShow(this, frameState);\n    updateWireframe(this);\n\n    if (this._debugWireframe) {\n      queueWireframeCommands(frameState, this._commands);\n    } else {\n      queueCommands(this, frameState, this._commands, this._commandsIgnoreShow);\n    }\n  }\n\n  if (passes.pick) {\n    createPickCommands(this);\n    queueCommands(this, frameState, this._pickCommands);\n  }\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\n\n\nVector3DTilePrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\n\n\nVector3DTilePrimitive.prototype.destroy = function () {\n  this._va = this._va && this._va.destroy();\n  this._sp = this._sp && this._sp.destroy();\n  this._spPick = this._spPick && this._spPick.destroy();\n  this._vaSwap = this._vaSwap && this._vaSwap.destroy();\n  return destroyObject(this);\n};\n\nexport default Vector3DTilePrimitive;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/Vector3DTilePrimitive.js"],"names":["Cartesian3","Color","ComponentDatatype","defaultValue","defined","destroyObject","IndexDatatype","Matrix4","PrimitiveType","Buffer","BufferUsage","DrawCommand","Pass","RenderState","ShaderProgram","ShaderSource","VertexArray","ShadowVolumeFS","VectorTileVS","BlendingState","Cesium3DTileFeature","ClassificationType","DepthFunction","Expression","StencilConstants","StencilFunction","StencilOperation","Vector3DTileBatch","Vector3DTilePrimitive","options","EMPTY_OBJECT","_batchTable","batchTable","_batchIds","batchIds","_positions","positions","_vertexBatchIds","vertexBatchIds","_indices","indices","_indexCounts","indexCounts","_indexOffsets","indexOffsets","_batchedIndices","batchedIndices","_boundingVolume","boundingVolume","_boundingVolumes","boundingVolumes","_center","center","ZERO","_va","undefined","_sp","_spStencil","_spPick","_uniformMap","_vaSwap","_rsStencilPreloadPass","_rsStencilPreloadPass3DTiles","_rsStencilDepthPass","_rsStencilDepthPass3DTiles","_rsColorPass","_rsPickPass","_rsWireframe","_commands","_commandsIgnoreShow","_pickCommands","_constantColor","clone","WHITE","_highlightColor","_batchDirty","_pickCommandsDirty","_framesSinceLastRebatch","_updatingAllCommands","_trianglesLength","length","_geometryByteLength","byteLength","debugWireframe","_debugWireframe","_wireframeDirty","forceRebatch","classificationType","BOTH","_vertexShaderSource","_fragmentShaderSource","_attributeLocations","_pickId","_modelMatrix","_boundingSphere","_batchIdLookUp","i","batchId","Object","defineProperties","prototype","trianglesLength","get","geometryByteLength","defaultAttributeLocations","position","a_batchId","createVertexArray","primitive","context","positionBuffer","createVertexBuffer","typedArray","usage","STATIC_DRAW","idBuffer","indexBuffer","createIndexBuffer","DYNAMIC_DRAW","indexDatatype","BYTES_PER_ELEMENT","UNSIGNED_SHORT","UNSIGNED_INT","vertexAttributes","index","vertexBuffer","componentDatatype","fromTypedArray","componentsPerAttribute","attributes","webgl2","sizeInBytes","_batchedPositions","_transferrableBatchIds","_verticesPromise","createShaders","attributeLocations","pickId","vertexShaderSource","fragmentShaderSource","fromCache","replaceMain","vsSource","getVertexShaderCallback","fsSource","getFragmentShaderCallback","getPickId","vs","sources","fs","defines","pickVS","pickFS","getStencilPreloadRenderState","mask3DTiles","stencilFunction","EQUAL","ALWAYS","colorMask","red","green","blue","alpha","stencilTest","enabled","frontFunction","frontOperation","fail","KEEP","zFail","DECREMENT_WRAP","zPass","backFunction","backOperation","INCREMENT_WRAP","reference","CESIUM_3D_TILE_MASK","mask","stencilMask","CLASSIFICATION_MASK","depthTest","depthMask","getStencilDepthRenderState","func","LESS_OR_EQUAL","colorRenderState","NOT_EQUAL","blending","ALPHA_BLEND","pickRenderState","createRenderStates","modifiedModelViewScratch","rtcScratch","createUniformMap","uniformMap","u_modifiedModelViewProjection","viewMatrix","uniformState","view","projectionMatrix","projection","multiplyByPoint","setTranslation","multiply","u_highlightColor","getUniformMapCallback","copyIndicesCPU","newIndices","currentOffset","offsets","counts","batchIdLookUp","constructor","batchedIdsLength","j","batchedId","offset","count","subarray","buffer","set","rebatchCPU","current","pop","newBatchedIndices","next","equals","color","concat","push","copyFromArrayView","copyIndicesGPU","readBuffer","writeBuffer","bytesPerIndex","copyFromBuffer","rebatchGPU","temp","compareColors","a","b","toRgba","rebatchCommands","needToRebatch","colorCounts","rgba","sort","createColorCommands","needsRebatch","commands","commandsLength","vertexArray","sp","modelMatrix","IDENTITY","bv","stencilPreloadCommand","owner","renderState","shaderProgram","cull","pass","TERRAIN_CLASSIFICATION","stencilPreloadDerivedCommand","shallowClone","derivedCommands","tileset","CESIUM_3D_TILE_CLASSIFICATION","stencilDepthCommand","stencilDepthDerivedCommand","colorCommand","colorDerivedCommand","_commandsDirty","createColorCommandsIgnoreShow","frameState","TERRAIN","invertClassification","commandsIgnoreShow","spStencil","commandIndex","commandIgnoreShow","CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW","createPickCommands","pickCommands","spPick","pickOnly","createFeatures","content","features","applyDebugSettings","clearStyle","polygons","feature","show","scratchColor","DEFAULT_COLOR_VALUE","DEFAULT_SHOW_VALUE","complexExpressionReg","applyStyle","style","colorExpression","isSimpleStyle","test","expression","evaluateColor","evaluate","updateCommands","batchedOffset","batchedCount","startIds","endIds","batchIdsLength","id","offsetIndex","splice","queueCommands","queueTerrainCommands","CESIUM_3D_TILE","queue3DTilesCommands","commandList","commandLength","command","queueWireframeCommands","OPAQUE","updateWireframe","earlyExit","rs","type","LINES","TRIANGLES","primitiveType","update","passes","render","pick","isDestroyed","destroy"],"mappings":"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","sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport ShadowVolumeFS from \"../Shaders/ShadowVolumeFS.js\";\nimport VectorTileVS from \"../Shaders/VectorTileVS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Cesium3DTileFeature from \"./Cesium3DTileFeature.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport Expression from \"./Expression.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\nimport Vector3DTileBatch from \"./Vector3DTileBatch.js\";\n\n/**\n * Creates a batch of classification meshes.\n *\n * @alias Vector3DTilePrimitive\n * @constructor\n *\n * @param {Object} options An object with following properties:\n * @param {Float32Array} options.positions The positions of the meshes.\n * @param {Uint16Array|Uint32Array} options.indices The indices of the triangulated meshes. The indices must be contiguous so that\n * the indices for mesh n are in [i, i + indexCounts[n]] where i = sum{indexCounts[0], indexCounts[n - 1]}.\n * @param {Uint32Array} options.indexCounts The number of indices for each mesh.\n * @param {Uint32Array} options.indexOffsets The offset into the index buffer for each mesh.\n * @param {Vector3DTileBatch[]} options.batchedIndices The index offset and count for each batch with the same color.\n * @param {Cartesian3} [options.center=Cartesian3.ZERO] The RTC center.\n * @param {Cesium3DTileBatchTable} options.batchTable The batch table for the tile containing the batched meshes.\n * @param {Uint16Array} options.batchIds The batch ids for each mesh.\n * @param {Uint16Array} options.vertexBatchIds The batch id for each vertex.\n * @param {BoundingSphere} options.boundingVolume The bounding volume for the entire batch of meshes.\n * @param {BoundingSphere[]} options.boundingVolumes The bounding volume for each mesh.\n * @param {ClassificationType} [options.classificationType] What this tile will classify.\n *\n * @private\n */\nfunction Vector3DTilePrimitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._batchTable = options.batchTable;\n  this._batchIds = options.batchIds;\n\n  // These arrays are released after VAO creation.\n  this._positions = options.positions;\n  this._vertexBatchIds = options.vertexBatchIds;\n\n  // These arrays are kept for re-batching indices based on colors.\n  // If WebGL 2 is supported, indices will be released and re-batching uses buffer-to-buffer copies.\n  this._indices = options.indices;\n  this._indexCounts = options.indexCounts;\n  this._indexOffsets = options.indexOffsets;\n  this._batchedIndices = options.batchedIndices;\n\n  this._boundingVolume = options.boundingVolume;\n  this._boundingVolumes = options.boundingVolumes;\n\n  this._center = defaultValue(options.center, Cartesian3.ZERO);\n\n  this._va = undefined;\n  this._sp = undefined;\n  this._spStencil = undefined;\n  this._spPick = undefined;\n  this._uniformMap = undefined;\n\n  // Only used with WebGL 2 to ping-pong ibos after copy.\n  this._vaSwap = undefined;\n\n  this._rsStencilPreloadPass = undefined;\n  this._rsStencilPreloadPass3DTiles = undefined;\n  this._rsStencilDepthPass = undefined;\n  this._rsStencilDepthPass3DTiles = undefined;\n  this._rsColorPass = undefined;\n  this._rsPickPass = undefined;\n  this._rsWireframe = undefined;\n\n  this._commands = [];\n  this._commandsIgnoreShow = [];\n  this._pickCommands = [];\n\n  this._constantColor = Color.clone(Color.WHITE);\n  this._highlightColor = this._constantColor;\n\n  this._batchDirty = true;\n  this._pickCommandsDirty = true;\n  this._framesSinceLastRebatch = 0;\n\n  this._updatingAllCommands = false;\n\n  this._trianglesLength = this._indices.length / 3;\n  this._geometryByteLength =\n    this._indices.byteLength +\n    this._positions.byteLength +\n    this._vertexBatchIds.byteLength;\n\n  /**\n   * Draw the wireframe of the classification meshes.\n   * @type {Boolean}\n   * @default false\n   */\n  this.debugWireframe = false;\n  this._debugWireframe = this.debugWireframe;\n  this._wireframeDirty = false;\n\n  /**\n   * Forces a re-batch instead of waiting after a number of frames have been rendered. For testing only.\n   * @type {Boolean}\n   * @default false\n   */\n  this.forceRebatch = false;\n\n  /**\n   * What this tile will classify.\n   * @type {ClassificationType}\n   * @default ClassificationType.BOTH\n   */\n  this.classificationType = defaultValue(\n    options.classificationType,\n    ClassificationType.BOTH\n  );\n\n  // Hidden options\n  this._vertexShaderSource = options._vertexShaderSource;\n  this._fragmentShaderSource = options._fragmentShaderSource;\n  this._attributeLocations = options._attributeLocations;\n  this._uniformMap = options._uniformMap;\n  this._pickId = options._pickId;\n  this._modelMatrix = options._modelMatrix;\n  this._boundingSphere = options._boundingSphere;\n\n  this._batchIdLookUp = {};\n\n  var length = this._batchIds.length;\n  for (var i = 0; i < length; ++i) {\n    var batchId = this._batchIds[i];\n    this._batchIdLookUp[batchId] = i;\n  }\n}\n\nObject.defineProperties(Vector3DTilePrimitive.prototype, {\n  /**\n   * Gets the number of triangles.\n   *\n   * @memberof Vector3DTilePrimitive.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  trianglesLength: {\n    get: function () {\n      return this._trianglesLength;\n    },\n  },\n\n  /**\n   * Gets the geometry memory in bytes.\n   *\n   * @memberof Vector3DTilePrimitive.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  geometryByteLength: {\n    get: function () {\n      return this._geometryByteLength;\n    },\n  },\n});\n\nvar defaultAttributeLocations = {\n  position: 0,\n  a_batchId: 1,\n};\n\nfunction createVertexArray(primitive, context) {\n  if (defined(primitive._va)) {\n    return;\n  }\n\n  var positionBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: primitive._positions,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  var idBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: primitive._vertexBatchIds,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  var indexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: primitive._indices,\n    usage: BufferUsage.DYNAMIC_DRAW,\n    indexDatatype:\n      primitive._indices.BYTES_PER_ELEMENT === 2\n        ? IndexDatatype.UNSIGNED_SHORT\n        : IndexDatatype.UNSIGNED_INT,\n  });\n\n  var vertexAttributes = [\n    {\n      index: 0,\n      vertexBuffer: positionBuffer,\n      componentDatatype: ComponentDatatype.fromTypedArray(primitive._positions),\n      componentsPerAttribute: 3,\n    },\n    {\n      index: 1,\n      vertexBuffer: idBuffer,\n      componentDatatype: ComponentDatatype.fromTypedArray(\n        primitive._vertexBatchIds\n      ),\n      componentsPerAttribute: 1,\n    },\n  ];\n\n  primitive._va = new VertexArray({\n    context: context,\n    attributes: vertexAttributes,\n    indexBuffer: indexBuffer,\n  });\n\n  if (context.webgl2) {\n    primitive._vaSwap = new VertexArray({\n      context: context,\n      attributes: vertexAttributes,\n      indexBuffer: Buffer.createIndexBuffer({\n        context: context,\n        sizeInBytes: indexBuffer.sizeInBytes,\n        usage: BufferUsage.DYNAMIC_DRAW,\n        indexDatatype: indexBuffer.indexDatatype,\n      }),\n    });\n  }\n\n  primitive._batchedPositions = undefined;\n  primitive._transferrableBatchIds = undefined;\n  primitive._vertexBatchIds = undefined;\n  primitive._verticesPromise = undefined;\n}\n\nfunction createShaders(primitive, context) {\n  if (defined(primitive._sp)) {\n    return;\n  }\n\n  var batchTable = primitive._batchTable;\n  var attributeLocations = defaultValue(\n    primitive._attributeLocations,\n    defaultAttributeLocations\n  );\n\n  var pickId = primitive._pickId;\n  var vertexShaderSource = primitive._vertexShaderSource;\n  var fragmentShaderSource = primitive._fragmentShaderSource;\n  if (defined(vertexShaderSource)) {\n    primitive._sp = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vertexShaderSource,\n      fragmentShaderSource: fragmentShaderSource,\n      attributeLocations: attributeLocations,\n    });\n    primitive._spStencil = primitive._sp;\n\n    fragmentShaderSource = ShaderSource.replaceMain(\n      fragmentShaderSource,\n      \"czm_non_pick_main\"\n    );\n    fragmentShaderSource =\n      fragmentShaderSource +\n      \"void main() \\n\" +\n      \"{ \\n\" +\n      \"    czm_non_pick_main(); \\n\" +\n      \"    gl_FragColor = \" +\n      pickId +\n      \"; \\n\" +\n      \"} \\n\";\n    primitive._spPick = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vertexShaderSource,\n      fragmentShaderSource: fragmentShaderSource,\n      attributeLocations: attributeLocations,\n    });\n    return;\n  }\n\n  var vsSource = batchTable.getVertexShaderCallback(\n    false,\n    \"a_batchId\",\n    undefined\n  )(VectorTileVS);\n  var fsSource = batchTable.getFragmentShaderCallback()(\n    ShadowVolumeFS,\n    false,\n    undefined\n  );\n\n  pickId = batchTable.getPickId();\n\n  var vs = new ShaderSource({\n    sources: [vsSource],\n  });\n  var fs = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [fsSource],\n  });\n\n  primitive._sp = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n\n  vs = new ShaderSource({\n    sources: [VectorTileVS],\n  });\n  fs = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [ShadowVolumeFS],\n  });\n\n  primitive._spStencil = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n\n  fsSource = ShaderSource.replaceMain(fsSource, \"czm_non_pick_main\");\n  fsSource =\n    fsSource +\n    \"\\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    czm_non_pick_main(); \\n\" +\n    \"    gl_FragColor = \" +\n    pickId +\n    \"; \\n\" +\n    \"} \\n\";\n\n  var pickVS = new ShaderSource({\n    sources: [vsSource],\n  });\n  var pickFS = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [fsSource],\n  });\n  primitive._spPick = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: pickVS,\n    fragmentShaderSource: pickFS,\n    attributeLocations: attributeLocations,\n  });\n}\n\nfunction getStencilPreloadRenderState(mask3DTiles) {\n  var stencilFunction = mask3DTiles\n    ? StencilFunction.EQUAL\n    : StencilFunction.ALWAYS;\n  return {\n    colorMask: {\n      red: false,\n      green: false,\n      blue: false,\n      alpha: false,\n    },\n    stencilTest: {\n      enabled: true,\n      frontFunction: stencilFunction,\n      frontOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.DECREMENT_WRAP,\n        zPass: StencilOperation.DECREMENT_WRAP,\n      },\n      backFunction: stencilFunction,\n      backOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.INCREMENT_WRAP,\n        zPass: StencilOperation.INCREMENT_WRAP,\n      },\n      reference: StencilConstants.CESIUM_3D_TILE_MASK,\n      mask: StencilConstants.CESIUM_3D_TILE_MASK,\n    },\n    stencilMask: StencilConstants.CLASSIFICATION_MASK,\n    depthTest: {\n      enabled: false,\n    },\n    depthMask: false,\n  };\n}\n\nfunction getStencilDepthRenderState(mask3DTiles) {\n  var stencilFunction = mask3DTiles\n    ? StencilFunction.EQUAL\n    : StencilFunction.ALWAYS;\n  return {\n    colorMask: {\n      red: false,\n      green: false,\n      blue: false,\n      alpha: false,\n    },\n    stencilTest: {\n      enabled: true,\n      frontFunction: stencilFunction,\n      frontOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.INCREMENT_WRAP,\n      },\n      backFunction: stencilFunction,\n      backOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.DECREMENT_WRAP,\n      },\n      reference: StencilConstants.CESIUM_3D_TILE_MASK,\n      mask: StencilConstants.CESIUM_3D_TILE_MASK,\n    },\n    stencilMask: StencilConstants.CLASSIFICATION_MASK,\n    depthTest: {\n      enabled: true,\n      func: DepthFunction.LESS_OR_EQUAL,\n    },\n    depthMask: false,\n  };\n}\n\nvar colorRenderState = {\n  stencilTest: {\n    enabled: true,\n    frontFunction: StencilFunction.NOT_EQUAL,\n    frontOperation: {\n      fail: StencilOperation.KEEP,\n      zFail: StencilOperation.KEEP,\n      zPass: StencilOperation.DECREMENT_WRAP,\n    },\n    backFunction: StencilFunction.NOT_EQUAL,\n    backOperation: {\n      fail: StencilOperation.KEEP,\n      zFail: StencilOperation.KEEP,\n      zPass: StencilOperation.DECREMENT_WRAP,\n    },\n    reference: 0,\n    mask: StencilConstants.CLASSIFICATION_MASK,\n  },\n  stencilMask: StencilConstants.CLASSIFICATION_MASK,\n  depthTest: {\n    enabled: false,\n  },\n  depthMask: false,\n  blending: BlendingState.ALPHA_BLEND,\n};\n\nvar pickRenderState = {\n  stencilTest: {\n    enabled: true,\n    frontFunction: StencilFunction.NOT_EQUAL,\n    frontOperation: {\n      fail: StencilOperation.KEEP,\n      zFail: StencilOperation.KEEP,\n      zPass: StencilOperation.DECREMENT_WRAP,\n    },\n    backFunction: StencilFunction.NOT_EQUAL,\n    backOperation: {\n      fail: StencilOperation.KEEP,\n      zFail: StencilOperation.KEEP,\n      zPass: StencilOperation.DECREMENT_WRAP,\n    },\n    reference: 0,\n    mask: StencilConstants.CLASSIFICATION_MASK,\n  },\n  stencilMask: StencilConstants.CLASSIFICATION_MASK,\n  depthTest: {\n    enabled: false,\n  },\n  depthMask: false,\n};\n\nfunction createRenderStates(primitive) {\n  if (defined(primitive._rsStencilPreloadPass)) {\n    return;\n  }\n\n  primitive._rsStencilPreloadPass = RenderState.fromCache(\n    getStencilPreloadRenderState(false)\n  );\n  primitive._rsStencilPreloadPass3DTiles = RenderState.fromCache(\n    getStencilPreloadRenderState(true)\n  );\n  primitive._rsStencilDepthPass = RenderState.fromCache(\n    getStencilDepthRenderState(false)\n  );\n  primitive._rsStencilDepthPass3DTiles = RenderState.fromCache(\n    getStencilDepthRenderState(true)\n  );\n  primitive._rsColorPass = RenderState.fromCache(colorRenderState);\n  primitive._rsPickPass = RenderState.fromCache(pickRenderState);\n}\n\nvar modifiedModelViewScratch = new Matrix4();\nvar rtcScratch = new Cartesian3();\n\nfunction createUniformMap(primitive, context) {\n  if (defined(primitive._uniformMap)) {\n    return;\n  }\n\n  var uniformMap = {\n    u_modifiedModelViewProjection: function () {\n      var viewMatrix = context.uniformState.view;\n      var projectionMatrix = context.uniformState.projection;\n      Matrix4.clone(viewMatrix, modifiedModelViewScratch);\n      Matrix4.multiplyByPoint(\n        modifiedModelViewScratch,\n        primitive._center,\n        rtcScratch\n      );\n      Matrix4.setTranslation(\n        modifiedModelViewScratch,\n        rtcScratch,\n        modifiedModelViewScratch\n      );\n      Matrix4.multiply(\n        projectionMatrix,\n        modifiedModelViewScratch,\n        modifiedModelViewScratch\n      );\n      return modifiedModelViewScratch;\n    },\n    u_highlightColor: function () {\n      return primitive._highlightColor;\n    },\n  };\n\n  primitive._uniformMap = primitive._batchTable.getUniformMapCallback()(\n    uniformMap\n  );\n}\n\nfunction copyIndicesCPU(\n  indices,\n  newIndices,\n  currentOffset,\n  offsets,\n  counts,\n  batchIds,\n  batchIdLookUp\n) {\n  var sizeInBytes = indices.constructor.BYTES_PER_ELEMENT;\n\n  var batchedIdsLength = batchIds.length;\n  for (var j = 0; j < batchedIdsLength; ++j) {\n    var batchedId = batchIds[j];\n    var index = batchIdLookUp[batchedId];\n    var offset = offsets[index];\n    var count = counts[index];\n\n    var subarray = new indices.constructor(\n      indices.buffer,\n      sizeInBytes * offset,\n      count\n    );\n    newIndices.set(subarray, currentOffset);\n\n    offsets[index] = currentOffset;\n    currentOffset += count;\n  }\n\n  return currentOffset;\n}\n\nfunction rebatchCPU(primitive, batchedIndices) {\n  var indices = primitive._indices;\n  var indexOffsets = primitive._indexOffsets;\n  var indexCounts = primitive._indexCounts;\n  var batchIdLookUp = primitive._batchIdLookUp;\n\n  var newIndices = new indices.constructor(indices.length);\n\n  var current = batchedIndices.pop();\n  var newBatchedIndices = [current];\n\n  var currentOffset = copyIndicesCPU(\n    indices,\n    newIndices,\n    0,\n    indexOffsets,\n    indexCounts,\n    current.batchIds,\n    batchIdLookUp\n  );\n\n  current.offset = 0;\n  current.count = currentOffset;\n\n  while (batchedIndices.length > 0) {\n    var next = batchedIndices.pop();\n    if (Color.equals(next.color, current.color)) {\n      currentOffset = copyIndicesCPU(\n        indices,\n        newIndices,\n        currentOffset,\n        indexOffsets,\n        indexCounts,\n        next.batchIds,\n        batchIdLookUp\n      );\n      current.batchIds = current.batchIds.concat(next.batchIds);\n      current.count = currentOffset - current.offset;\n    } else {\n      var offset = currentOffset;\n      currentOffset = copyIndicesCPU(\n        indices,\n        newIndices,\n        currentOffset,\n        indexOffsets,\n        indexCounts,\n        next.batchIds,\n        batchIdLookUp\n      );\n\n      next.offset = offset;\n      next.count = currentOffset - offset;\n      newBatchedIndices.push(next);\n      current = next;\n    }\n  }\n\n  primitive._va.indexBuffer.copyFromArrayView(newIndices);\n\n  primitive._indices = newIndices;\n  primitive._batchedIndices = newBatchedIndices;\n}\n\nfunction copyIndicesGPU(\n  readBuffer,\n  writeBuffer,\n  currentOffset,\n  offsets,\n  counts,\n  batchIds,\n  batchIdLookUp\n) {\n  var sizeInBytes = readBuffer.bytesPerIndex;\n\n  var batchedIdsLength = batchIds.length;\n  for (var j = 0; j < batchedIdsLength; ++j) {\n    var batchedId = batchIds[j];\n    var index = batchIdLookUp[batchedId];\n    var offset = offsets[index];\n    var count = counts[index];\n\n    writeBuffer.copyFromBuffer(\n      readBuffer,\n      offset * sizeInBytes,\n      currentOffset * sizeInBytes,\n      count * sizeInBytes\n    );\n\n    offsets[index] = currentOffset;\n    currentOffset += count;\n  }\n\n  return currentOffset;\n}\n\nfunction rebatchGPU(primitive, batchedIndices) {\n  var indexOffsets = primitive._indexOffsets;\n  var indexCounts = primitive._indexCounts;\n  var batchIdLookUp = primitive._batchIdLookUp;\n\n  var current = batchedIndices.pop();\n  var newBatchedIndices = [current];\n\n  var readBuffer = primitive._va.indexBuffer;\n  var writeBuffer = primitive._vaSwap.indexBuffer;\n\n  var currentOffset = copyIndicesGPU(\n    readBuffer,\n    writeBuffer,\n    0,\n    indexOffsets,\n    indexCounts,\n    current.batchIds,\n    batchIdLookUp\n  );\n\n  current.offset = 0;\n  current.count = currentOffset;\n\n  while (batchedIndices.length > 0) {\n    var next = batchedIndices.pop();\n    if (Color.equals(next.color, current.color)) {\n      currentOffset = copyIndicesGPU(\n        readBuffer,\n        writeBuffer,\n        currentOffset,\n        indexOffsets,\n        indexCounts,\n        next.batchIds,\n        batchIdLookUp\n      );\n      current.batchIds = current.batchIds.concat(next.batchIds);\n      current.count = currentOffset - current.offset;\n    } else {\n      var offset = currentOffset;\n      currentOffset = copyIndicesGPU(\n        readBuffer,\n        writeBuffer,\n        currentOffset,\n        indexOffsets,\n        indexCounts,\n        next.batchIds,\n        batchIdLookUp\n      );\n      next.offset = offset;\n      next.count = currentOffset - offset;\n      newBatchedIndices.push(next);\n      current = next;\n    }\n  }\n\n  var temp = primitive._va;\n  primitive._va = primitive._vaSwap;\n  primitive._vaSwap = temp;\n\n  primitive._batchedIndices = newBatchedIndices;\n}\n\nfunction compareColors(a, b) {\n  return b.color.toRgba() - a.color.toRgba();\n}\n\n// PERFORMANCE_IDEA: For WebGL 2, we can use copyBufferSubData for buffer-to-buffer copies.\n// PERFORMANCE_IDEA: Not supported, but we could use glMultiDrawElements here.\nfunction rebatchCommands(primitive, context) {\n  if (!primitive._batchDirty) {\n    return false;\n  }\n\n  var batchedIndices = primitive._batchedIndices;\n  var length = batchedIndices.length;\n\n  var needToRebatch = false;\n  var colorCounts = {};\n\n  for (var i = 0; i < length; ++i) {\n    var color = batchedIndices[i].color;\n    var rgba = color.toRgba();\n    if (defined(colorCounts[rgba])) {\n      needToRebatch = true;\n      break;\n    } else {\n      colorCounts[rgba] = true;\n    }\n  }\n\n  if (!needToRebatch) {\n    primitive._batchDirty = false;\n    return false;\n  }\n\n  if (\n    needToRebatch &&\n    !primitive.forceRebatch &&\n    primitive._framesSinceLastRebatch < 120\n  ) {\n    ++primitive._framesSinceLastRebatch;\n    return;\n  }\n\n  batchedIndices.sort(compareColors);\n\n  if (context.webgl2) {\n    rebatchGPU(primitive, batchedIndices);\n  } else {\n    rebatchCPU(primitive, batchedIndices);\n  }\n\n  primitive._framesSinceLastRebatch = 0;\n  primitive._batchDirty = false;\n  primitive._pickCommandsDirty = true;\n  primitive._wireframeDirty = true;\n  return true;\n}\n\nfunction createColorCommands(primitive, context) {\n  var needsRebatch = rebatchCommands(primitive, context);\n\n  var commands = primitive._commands;\n  var batchedIndices = primitive._batchedIndices;\n  var length = batchedIndices.length;\n  var commandsLength = length * 3;\n\n  if (\n    defined(commands) &&\n    !needsRebatch &&\n    commands.length === commandsLength\n  ) {\n    return;\n  }\n\n  commands.length = commandsLength;\n\n  var vertexArray = primitive._va;\n  var sp = primitive._sp;\n  var modelMatrix = defaultValue(primitive._modelMatrix, Matrix4.IDENTITY);\n  var uniformMap = primitive._uniformMap;\n  var bv = primitive._boundingVolume;\n\n  for (var j = 0; j < length; ++j) {\n    var offset = batchedIndices[j].offset;\n    var count = batchedIndices[j].count;\n\n    var stencilPreloadCommand = commands[j * 3];\n    if (!defined(stencilPreloadCommand)) {\n      stencilPreloadCommand = commands[j * 3] = new DrawCommand({\n        owner: primitive,\n      });\n    }\n\n    stencilPreloadCommand.vertexArray = vertexArray;\n    stencilPreloadCommand.modelMatrix = modelMatrix;\n    stencilPreloadCommand.offset = offset;\n    stencilPreloadCommand.count = count;\n    stencilPreloadCommand.renderState = primitive._rsStencilPreloadPass;\n    stencilPreloadCommand.shaderProgram = sp;\n    stencilPreloadCommand.uniformMap = uniformMap;\n    stencilPreloadCommand.boundingVolume = bv;\n    stencilPreloadCommand.cull = false;\n    stencilPreloadCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n\n    var stencilPreloadDerivedCommand = DrawCommand.shallowClone(\n      stencilPreloadCommand,\n      stencilPreloadCommand.derivedCommands.tileset\n    );\n    stencilPreloadDerivedCommand.renderState =\n      primitive._rsStencilPreloadPass3DTiles;\n    stencilPreloadDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    stencilPreloadCommand.derivedCommands.tileset = stencilPreloadDerivedCommand;\n\n    var stencilDepthCommand = commands[j * 3 + 1];\n    if (!defined(stencilDepthCommand)) {\n      stencilDepthCommand = commands[j * 3 + 1] = new DrawCommand({\n        owner: primitive,\n      });\n    }\n\n    stencilDepthCommand.vertexArray = vertexArray;\n    stencilDepthCommand.modelMatrix = modelMatrix;\n    stencilDepthCommand.offset = offset;\n    stencilDepthCommand.count = count;\n    stencilDepthCommand.renderState = primitive._rsStencilDepthPass;\n    stencilDepthCommand.shaderProgram = sp;\n    stencilDepthCommand.uniformMap = uniformMap;\n    stencilDepthCommand.boundingVolume = bv;\n    stencilDepthCommand.cull = false;\n    stencilDepthCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n\n    var stencilDepthDerivedCommand = DrawCommand.shallowClone(\n      stencilDepthCommand,\n      stencilDepthCommand.derivedCommands.tileset\n    );\n    stencilDepthDerivedCommand.renderState =\n      primitive._rsStencilDepthPass3DTiles;\n    stencilDepthDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    stencilDepthCommand.derivedCommands.tileset = stencilDepthDerivedCommand;\n\n    var colorCommand = commands[j * 3 + 2];\n    if (!defined(colorCommand)) {\n      colorCommand = commands[j * 3 + 2] = new DrawCommand({\n        owner: primitive,\n      });\n    }\n\n    colorCommand.vertexArray = vertexArray;\n    colorCommand.modelMatrix = modelMatrix;\n    colorCommand.offset = offset;\n    colorCommand.count = count;\n    colorCommand.renderState = primitive._rsColorPass;\n    colorCommand.shaderProgram = sp;\n    colorCommand.uniformMap = uniformMap;\n    colorCommand.boundingVolume = bv;\n    colorCommand.cull = false;\n    colorCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n\n    var colorDerivedCommand = DrawCommand.shallowClone(\n      colorCommand,\n      colorCommand.derivedCommands.tileset\n    );\n    colorDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    colorCommand.derivedCommands.tileset = colorDerivedCommand;\n  }\n\n  primitive._commandsDirty = true;\n}\n\nfunction createColorCommandsIgnoreShow(primitive, frameState) {\n  if (\n    primitive.classificationType === ClassificationType.TERRAIN ||\n    !frameState.invertClassification ||\n    (defined(primitive._commandsIgnoreShow) && !primitive._commandsDirty)\n  ) {\n    return;\n  }\n\n  var commands = primitive._commands;\n  var commandsIgnoreShow = primitive._commandsIgnoreShow;\n  var spStencil = primitive._spStencil;\n\n  var commandsLength = commands.length;\n  var length = (commandsIgnoreShow.length = (commandsLength / 3) * 2);\n\n  var commandIndex = 0;\n  for (var j = 0; j < length; j += 2) {\n    var commandIgnoreShow = (commandsIgnoreShow[j] = DrawCommand.shallowClone(\n      commands[commandIndex],\n      commandsIgnoreShow[j]\n    ));\n    commandIgnoreShow.shaderProgram = spStencil;\n    commandIgnoreShow.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW;\n\n    commandIgnoreShow = commandsIgnoreShow[j + 1] = DrawCommand.shallowClone(\n      commands[commandIndex + 1],\n      commandsIgnoreShow[j + 1]\n    );\n    commandIgnoreShow.shaderProgram = spStencil;\n    commandIgnoreShow.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW;\n\n    commandIndex += 3;\n  }\n\n  primitive._commandsDirty = false;\n}\n\nfunction createPickCommands(primitive) {\n  if (!primitive._pickCommandsDirty) {\n    return;\n  }\n\n  var length = primitive._indexOffsets.length;\n  var pickCommands = primitive._pickCommands;\n  pickCommands.length = length * 3;\n\n  var vertexArray = primitive._va;\n  var spStencil = primitive._spStencil;\n  var spPick = primitive._spPick;\n  var modelMatrix = defaultValue(primitive._modelMatrix, Matrix4.IDENTITY);\n  var uniformMap = primitive._uniformMap;\n\n  for (var j = 0; j < length; ++j) {\n    var offset = primitive._indexOffsets[j];\n    var count = primitive._indexCounts[j];\n    var bv = defined(primitive._boundingVolumes)\n      ? primitive._boundingVolumes[j]\n      : primitive.boundingVolume;\n\n    var stencilPreloadCommand = pickCommands[j * 3];\n    if (!defined(stencilPreloadCommand)) {\n      stencilPreloadCommand = pickCommands[j * 3] = new DrawCommand({\n        owner: primitive,\n        pickOnly: true,\n      });\n    }\n\n    stencilPreloadCommand.vertexArray = vertexArray;\n    stencilPreloadCommand.modelMatrix = modelMatrix;\n    stencilPreloadCommand.offset = offset;\n    stencilPreloadCommand.count = count;\n    stencilPreloadCommand.renderState = primitive._rsStencilPreloadPass;\n    stencilPreloadCommand.shaderProgram = spStencil;\n    stencilPreloadCommand.uniformMap = uniformMap;\n    stencilPreloadCommand.boundingVolume = bv;\n    stencilPreloadCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n\n    var stencilPreloadDerivedCommand = DrawCommand.shallowClone(\n      stencilPreloadCommand,\n      stencilPreloadCommand.derivedCommands.tileset\n    );\n    stencilPreloadDerivedCommand.renderState =\n      primitive._rsStencilPreloadPass3DTiles;\n    stencilPreloadDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    stencilPreloadCommand.derivedCommands.tileset = stencilPreloadDerivedCommand;\n\n    var stencilDepthCommand = pickCommands[j * 3 + 1];\n    if (!defined(stencilDepthCommand)) {\n      stencilDepthCommand = pickCommands[j * 3 + 1] = new DrawCommand({\n        owner: primitive,\n        pickOnly: true,\n      });\n    }\n\n    stencilDepthCommand.vertexArray = vertexArray;\n    stencilDepthCommand.modelMatrix = modelMatrix;\n    stencilDepthCommand.offset = offset;\n    stencilDepthCommand.count = count;\n    stencilDepthCommand.renderState = primitive._rsStencilDepthPass;\n    stencilDepthCommand.shaderProgram = spStencil;\n    stencilDepthCommand.uniformMap = uniformMap;\n    stencilDepthCommand.boundingVolume = bv;\n    stencilDepthCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n\n    var stencilDepthDerivedCommand = DrawCommand.shallowClone(\n      stencilDepthCommand,\n      stencilDepthCommand.derivedCommands.tileset\n    );\n    stencilDepthDerivedCommand.renderState =\n      primitive._rsStencilDepthPass3DTiles;\n    stencilDepthDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    stencilDepthCommand.derivedCommands.tileset = stencilDepthDerivedCommand;\n\n    var colorCommand = pickCommands[j * 3 + 2];\n    if (!defined(colorCommand)) {\n      colorCommand = pickCommands[j * 3 + 2] = new DrawCommand({\n        owner: primitive,\n        pickOnly: true,\n      });\n    }\n\n    colorCommand.vertexArray = vertexArray;\n    colorCommand.modelMatrix = modelMatrix;\n    colorCommand.offset = offset;\n    colorCommand.count = count;\n    colorCommand.renderState = primitive._rsPickPass;\n    colorCommand.shaderProgram = spPick;\n    colorCommand.uniformMap = uniformMap;\n    colorCommand.boundingVolume = bv;\n    colorCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n\n    var colorDerivedCommand = DrawCommand.shallowClone(\n      colorCommand,\n      colorCommand.derivedCommands.tileset\n    );\n    colorDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    colorCommand.derivedCommands.tileset = colorDerivedCommand;\n  }\n\n  primitive._pickCommandsDirty = false;\n}\n\n/**\n * Creates features for each mesh and places it at the batch id index of features.\n *\n * @param {Vector3DTileContent} content The vector tile content.\n * @param {Cesium3DTileFeature[]} features An array of features where the polygon features will be placed.\n */\nVector3DTilePrimitive.prototype.createFeatures = function (content, features) {\n  var batchIds = this._batchIds;\n  var length = batchIds.length;\n  for (var i = 0; i < length; ++i) {\n    var batchId = batchIds[i];\n    features[batchId] = new Cesium3DTileFeature(content, batchId);\n  }\n};\n\n/**\n * Colors the entire tile when enabled is true. The resulting color will be (mesh batch table color * color).\n *\n * @param {Boolean} enabled Whether to enable debug coloring.\n * @param {Color} color The debug color.\n */\nVector3DTilePrimitive.prototype.applyDebugSettings = function (enabled, color) {\n  this._highlightColor = enabled ? color : this._constantColor;\n};\n\nfunction clearStyle(polygons, features) {\n  polygons._updatingAllCommands = true;\n\n  var batchIds = polygons._batchIds;\n  var length = batchIds.length;\n  var i;\n\n  for (i = 0; i < length; ++i) {\n    var batchId = batchIds[i];\n    var feature = features[batchId];\n\n    feature.show = true;\n    feature.color = Color.WHITE;\n  }\n\n  var batchedIndices = polygons._batchedIndices;\n  length = batchedIndices.length;\n\n  for (i = 0; i < length; ++i) {\n    batchedIndices[i].color = Color.clone(Color.WHITE);\n  }\n\n  polygons._updatingAllCommands = false;\n  polygons._batchDirty = true;\n}\n\nvar scratchColor = new Color();\n\nvar DEFAULT_COLOR_VALUE = Color.WHITE;\nvar DEFAULT_SHOW_VALUE = true;\n\nvar complexExpressionReg = /\\$/;\n\n/**\n * Apply a style to the content.\n *\n * @param {Cesium3DTileStyle} style The style.\n * @param {Cesium3DTileFeature[]} features The array of features.\n */\nVector3DTilePrimitive.prototype.applyStyle = function (style, features) {\n  if (!defined(style)) {\n    clearStyle(this, features);\n    return;\n  }\n\n  var colorExpression = style.color;\n  var isSimpleStyle =\n    colorExpression instanceof Expression &&\n    !complexExpressionReg.test(colorExpression.expression);\n  this._updatingAllCommands = isSimpleStyle;\n\n  var batchIds = this._batchIds;\n  var length = batchIds.length;\n  var i;\n\n  for (i = 0; i < length; ++i) {\n    var batchId = batchIds[i];\n    var feature = features[batchId];\n\n    feature.color = defined(style.color)\n      ? style.color.evaluateColor(feature, scratchColor)\n      : DEFAULT_COLOR_VALUE;\n    feature.show = defined(style.show)\n      ? style.show.evaluate(feature)\n      : DEFAULT_SHOW_VALUE;\n  }\n\n  if (isSimpleStyle) {\n    var batchedIndices = this._batchedIndices;\n    length = batchedIndices.length;\n\n    for (i = 0; i < length; ++i) {\n      batchedIndices[i].color = Color.clone(Color.WHITE);\n    }\n\n    this._updatingAllCommands = false;\n    this._batchDirty = true;\n  }\n};\n\n/**\n * Call when updating the color of a mesh with batchId changes color. The meshes will need to be re-batched\n * on the next update.\n *\n * @param {Number} batchId The batch id of the meshes whose color has changed.\n * @param {Color} color The new polygon color.\n */\nVector3DTilePrimitive.prototype.updateCommands = function (batchId, color) {\n  if (this._updatingAllCommands) {\n    return;\n  }\n\n  var batchIdLookUp = this._batchIdLookUp;\n  var index = batchIdLookUp[batchId];\n  if (!defined(index)) {\n    return;\n  }\n\n  var indexOffsets = this._indexOffsets;\n  var indexCounts = this._indexCounts;\n\n  var offset = indexOffsets[index];\n  var count = indexCounts[index];\n\n  var batchedIndices = this._batchedIndices;\n  var length = batchedIndices.length;\n\n  var i;\n  for (i = 0; i < length; ++i) {\n    var batchedOffset = batchedIndices[i].offset;\n    var batchedCount = batchedIndices[i].count;\n\n    if (offset >= batchedOffset && offset < batchedOffset + batchedCount) {\n      break;\n    }\n  }\n\n  batchedIndices.push(\n    new Vector3DTileBatch({\n      color: Color.clone(color),\n      offset: offset,\n      count: count,\n      batchIds: [batchId],\n    })\n  );\n\n  var startIds = [];\n  var endIds = [];\n\n  var batchIds = batchedIndices[i].batchIds;\n  var batchIdsLength = batchIds.length;\n\n  for (var j = 0; j < batchIdsLength; ++j) {\n    var id = batchIds[j];\n    if (id === batchId) {\n      continue;\n    }\n\n    var offsetIndex = batchIdLookUp[id];\n    if (indexOffsets[offsetIndex] < offset) {\n      startIds.push(id);\n    } else {\n      endIds.push(id);\n    }\n  }\n\n  if (endIds.length !== 0) {\n    batchedIndices.push(\n      new Vector3DTileBatch({\n        color: Color.clone(batchedIndices[i].color),\n        offset: offset + count,\n        count:\n          batchedIndices[i].offset + batchedIndices[i].count - (offset + count),\n        batchIds: endIds,\n      })\n    );\n  }\n\n  if (startIds.length !== 0) {\n    batchedIndices[i].count = offset - batchedIndices[i].offset;\n    batchedIndices[i].batchIds = startIds;\n  } else {\n    batchedIndices.splice(i, 1);\n  }\n\n  this._batchDirty = true;\n};\n\nfunction queueCommands(primitive, frameState, commands, commandsIgnoreShow) {\n  var classificationType = primitive.classificationType;\n  var queueTerrainCommands =\n    classificationType !== ClassificationType.CESIUM_3D_TILE;\n  var queue3DTilesCommands = classificationType !== ClassificationType.TERRAIN;\n\n  var commandList = frameState.commandList;\n  var commandLength = commands.length;\n  var command;\n  var i;\n  for (i = 0; i < commandLength; ++i) {\n    if (queueTerrainCommands) {\n      command = commands[i];\n      command.pass = Pass.TERRAIN_CLASSIFICATION;\n      commandList.push(command);\n    }\n    if (queue3DTilesCommands) {\n      command = commands[i].derivedCommands.tileset;\n      command.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n      commandList.push(command);\n    }\n  }\n\n  if (!frameState.invertClassification || !defined(commandsIgnoreShow)) {\n    return;\n  }\n\n  commandLength = commandsIgnoreShow.length;\n  for (i = 0; i < commandLength; ++i) {\n    commandList.push(commandsIgnoreShow[i]);\n  }\n}\n\nfunction queueWireframeCommands(frameState, commands) {\n  var commandList = frameState.commandList;\n  var commandLength = commands.length;\n  for (var i = 0; i < commandLength; i += 3) {\n    var command = commands[i + 2];\n    command.pass = Pass.OPAQUE;\n    commandList.push(command);\n  }\n}\n\nfunction updateWireframe(primitive) {\n  var earlyExit = primitive.debugWireframe === primitive._debugWireframe;\n  earlyExit =\n    earlyExit && !(primitive.debugWireframe && primitive._wireframeDirty);\n  if (earlyExit) {\n    return;\n  }\n\n  if (!defined(primitive._rsWireframe)) {\n    primitive._rsWireframe = RenderState.fromCache({});\n  }\n\n  var rs;\n  var type;\n\n  if (primitive.debugWireframe) {\n    rs = primitive._rsWireframe;\n    type = PrimitiveType.LINES;\n  } else {\n    rs = primitive._rsColorPass;\n    type = PrimitiveType.TRIANGLES;\n  }\n\n  var commands = primitive._commands;\n  var commandLength = commands.length;\n  for (var i = 0; i < commandLength; i += 3) {\n    var command = commands[i + 2];\n    command.renderState = rs;\n    command.primitiveType = type;\n  }\n\n  primitive._debugWireframe = primitive.debugWireframe;\n  primitive._wireframeDirty = false;\n}\n\n/**\n * Updates the batches and queues the commands for rendering.\n *\n * @param {FrameState} frameState The current frame state.\n */\nVector3DTilePrimitive.prototype.update = function (frameState) {\n  var context = frameState.context;\n\n  createVertexArray(this, context);\n  createShaders(this, context);\n  createRenderStates(this);\n  createUniformMap(this, context);\n\n  var passes = frameState.passes;\n  if (passes.render) {\n    createColorCommands(this, context);\n    createColorCommandsIgnoreShow(this, frameState);\n    updateWireframe(this);\n\n    if (this._debugWireframe) {\n      queueWireframeCommands(frameState, this._commands);\n    } else {\n      queueCommands(this, frameState, this._commands, this._commandsIgnoreShow);\n    }\n  }\n\n  if (passes.pick) {\n    createPickCommands(this);\n    queueCommands(this, frameState, this._pickCommands);\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\nVector3DTilePrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nVector3DTilePrimitive.prototype.destroy = function () {\n  this._va = this._va && this._va.destroy();\n  this._sp = this._sp && this._sp.destroy();\n  this._spPick = this._spPick && this._spPick.destroy();\n  this._vaSwap = this._vaSwap && this._vaSwap.destroy();\n  return destroyObject(this);\n};\nexport default Vector3DTilePrimitive;\n"]},"metadata":{},"sourceType":"module"}