{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Spline from \"./Spline.js\";\n/**\n * A spline that uses piecewise linear interpolation to create a curve.\n *\n * @alias LinearSpline\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {Cartesian3[]} options.points The array of {@link Cartesian3} control points.\n *\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n *\n *\n * @example\n * var times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * var spline = new Cesium.LinearSpline({\n *     times : times,\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });\n *\n * var p0 = spline.evaluate(times[0]);\n *\n * @see HermiteSpline\n * @see CatmullRomSpline\n * @see QuaternionSpline\n * @see WeightSpline\n */\n\nfunction LinearSpline(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var points = options.points;\n  var times = options.times; //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(points) || !defined(times)) {\n    throw new DeveloperError(\"points and times are required.\");\n  }\n\n  if (points.length < 2) {\n    throw new DeveloperError(\"points.length must be greater than or equal to 2.\");\n  }\n\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  } //>>includeEnd('debug');\n\n\n  this._times = times;\n  this._points = points;\n  this._lastTimeIndex = 0;\n}\n\nObject.defineProperties(LinearSpline.prototype, {\n  /**\n   * An array of times for the control points.\n   *\n   * @memberof LinearSpline.prototype\n   *\n   * @type {Number[]}\n   * @readonly\n   */\n  times: {\n    get: function get() {\n      return this._times;\n    }\n  },\n\n  /**\n   * An array of {@link Cartesian3} control points.\n   *\n   * @memberof LinearSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  points: {\n    get: function get() {\n      return this._points;\n    }\n  }\n});\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {Number} time The time.\n * @returns {Number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\n\nLinearSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, wrapped around to the updated animation.\n */\n\nLinearSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, clamped to the animation period.\n */\n\nLinearSpline.prototype.clampTime = Spline.prototype.clampTime;\n/**\n * Evaluates the curve at a given time.\n *\n * @param {Number} time The time at which to evaluate the curve.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\n\nLinearSpline.prototype.evaluate = function (time, result) {\n  var points = this.points;\n  var times = this.times;\n  var i = this._lastTimeIndex = this.findTimeInterval(time, this._lastTimeIndex);\n  var u = (time - times[i]) / (times[i + 1] - times[i]);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  return Cartesian3.lerp(points[i], points[i + 1], u, result);\n};\n\nexport default LinearSpline;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/LinearSpline.js"],"names":["Cartesian3","defaultValue","defined","DeveloperError","Spline","LinearSpline","options","EMPTY_OBJECT","points","times","length","_times","_points","_lastTimeIndex","Object","defineProperties","prototype","get","findTimeInterval","wrapTime","clampTime","evaluate","time","result","i","u","lerp"],"mappings":"AAAA,OAAOA,UAAP,MAAuB,iBAAvB;AACA,OAAOC,YAAP,MAAyB,mBAAzB;AACA,OAAOC,OAAP,MAAoB,cAApB;AACA,OAAOC,cAAP,MAA2B,qBAA3B;AACA,OAAOC,MAAP,MAAmB,aAAnB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA,SAASC,YAAT,CAAsBC,OAAtB,EAA+B;AAC7BA,EAAAA,OAAO,GAAGL,YAAY,CAACK,OAAD,EAAUL,YAAY,CAACM,YAAvB,CAAtB;AAEA,MAAIC,MAAM,GAAGF,OAAO,CAACE,MAArB;AACA,MAAIC,KAAK,GAAGH,OAAO,CAACG,KAApB,CAJ6B,CAM7B;;AACA,MAAI,CAACP,OAAO,CAACM,MAAD,CAAR,IAAoB,CAACN,OAAO,CAACO,KAAD,CAAhC,EAAyC;AACvC,UAAM,IAAIN,cAAJ,CAAmB,gCAAnB,CAAN;AACD;;AACD,MAAIK,MAAM,CAACE,MAAP,GAAgB,CAApB,EAAuB;AACrB,UAAM,IAAIP,cAAJ,CACJ,mDADI,CAAN;AAGD;;AACD,MAAIM,KAAK,CAACC,MAAN,KAAiBF,MAAM,CAACE,MAA5B,EAAoC;AAClC,UAAM,IAAIP,cAAJ,CAAmB,8CAAnB,CAAN;AACD,GAjB4B,CAkB7B;;;AAEA,OAAKQ,MAAL,GAAcF,KAAd;AACA,OAAKG,OAAL,GAAeJ,MAAf;AAEA,OAAKK,cAAL,GAAsB,CAAtB;AACD;;AAEDC,MAAM,CAACC,gBAAP,CAAwBV,YAAY,CAACW,SAArC,EAAgD;AAC9C;;;;;;;;AAQAP,EAAAA,KAAK,EAAE;AACLQ,IAAAA,GAAG,EAAE,eAAY;AACf,aAAO,KAAKN,MAAZ;AACD;AAHI,GATuC;;AAe9C;;;;;;;;AAQAH,EAAAA,MAAM,EAAE;AACNS,IAAAA,GAAG,EAAE,eAAY;AACf,aAAO,KAAKL,OAAZ;AACD;AAHK;AAvBsC,CAAhD;AA8BA;;;;;;;;;;;;;AAYAP,YAAY,CAACW,SAAb,CAAuBE,gBAAvB,GAA0Cd,MAAM,CAACY,SAAP,CAAiBE,gBAA3D;AAEA;;;;;;;;AAOAb,YAAY,CAACW,SAAb,CAAuBG,QAAvB,GAAkCf,MAAM,CAACY,SAAP,CAAiBG,QAAnD;AAEA;;;;;;;;AAOAd,YAAY,CAACW,SAAb,CAAuBI,SAAvB,GAAmChB,MAAM,CAACY,SAAP,CAAiBI,SAApD;AAEA;;;;;;;;;;;;AAWAf,YAAY,CAACW,SAAb,CAAuBK,QAAvB,GAAkC,UAAUC,IAAV,EAAgBC,MAAhB,EAAwB;AACxD,MAAIf,MAAM,GAAG,KAAKA,MAAlB;AACA,MAAIC,KAAK,GAAG,KAAKA,KAAjB;AAEA,MAAIe,CAAC,GAAI,KAAKX,cAAL,GAAsB,KAAKK,gBAAL,CAC7BI,IAD6B,EAE7B,KAAKT,cAFwB,CAA/B;AAIA,MAAIY,CAAC,GAAG,CAACH,IAAI,GAAGb,KAAK,CAACe,CAAD,CAAb,KAAqBf,KAAK,CAACe,CAAC,GAAG,CAAL,CAAL,GAAef,KAAK,CAACe,CAAD,CAAzC,CAAR;;AAEA,MAAI,CAACtB,OAAO,CAACqB,MAAD,CAAZ,EAAsB;AACpBA,IAAAA,MAAM,GAAG,IAAIvB,UAAJ,EAAT;AACD;;AAED,SAAOA,UAAU,CAAC0B,IAAX,CAAgBlB,MAAM,CAACgB,CAAD,CAAtB,EAA2BhB,MAAM,CAACgB,CAAC,GAAG,CAAL,CAAjC,EAA0CC,CAA1C,EAA6CF,MAA7C,CAAP;AACD,CAfD;;AAgBA,eAAelB,YAAf","sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Spline from \"./Spline.js\";\n\n/**\n * A spline that uses piecewise linear interpolation to create a curve.\n *\n * @alias LinearSpline\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {Cartesian3[]} options.points The array of {@link Cartesian3} control points.\n *\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n *\n *\n * @example\n * var times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * var spline = new Cesium.LinearSpline({\n *     times : times,\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });\n *\n * var p0 = spline.evaluate(times[0]);\n *\n * @see HermiteSpline\n * @see CatmullRomSpline\n * @see QuaternionSpline\n * @see WeightSpline\n */\nfunction LinearSpline(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var points = options.points;\n  var times = options.times;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(points) || !defined(times)) {\n    throw new DeveloperError(\"points and times are required.\");\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\n      \"points.length must be greater than or equal to 2.\"\n    );\n  }\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n  //>>includeEnd('debug');\n\n  this._times = times;\n  this._points = points;\n\n  this._lastTimeIndex = 0;\n}\n\nObject.defineProperties(LinearSpline.prototype, {\n  /**\n   * An array of times for the control points.\n   *\n   * @memberof LinearSpline.prototype\n   *\n   * @type {Number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    },\n  },\n\n  /**\n   * An array of {@link Cartesian3} control points.\n   *\n   * @memberof LinearSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  points: {\n    get: function () {\n      return this._points;\n    },\n  },\n});\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {Number} time The time.\n * @returns {Number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nLinearSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, wrapped around to the updated animation.\n */\nLinearSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, clamped to the animation period.\n */\nLinearSpline.prototype.clampTime = Spline.prototype.clampTime;\n\n/**\n * Evaluates the curve at a given time.\n *\n * @param {Number} time The time at which to evaluate the curve.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nLinearSpline.prototype.evaluate = function (time, result) {\n  var points = this.points;\n  var times = this.times;\n\n  var i = (this._lastTimeIndex = this.findTimeInterval(\n    time,\n    this._lastTimeIndex\n  ));\n  var u = (time - times[i]) / (times[i + 1] - times[i]);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  return Cartesian3.lerp(points[i], points[i + 1], u, result);\n};\nexport default LinearSpline;\n"]},"metadata":{},"sourceType":"module"}