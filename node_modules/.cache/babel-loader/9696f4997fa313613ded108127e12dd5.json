{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport KeyboardEventModifier from \"../Core/KeyboardEventModifier.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport ScreenSpaceEventHandler from \"../Core/ScreenSpaceEventHandler.js\";\nimport ScreenSpaceEventType from \"../Core/ScreenSpaceEventType.js\";\nimport CameraEventType from \"./CameraEventType.js\";\n\nfunction getKey(type, modifier) {\n  var key = type;\n\n  if (defined(modifier)) {\n    key += \"+\" + modifier;\n  }\n\n  return key;\n}\n\nfunction clonePinchMovement(pinchMovement, result) {\n  Cartesian2.clone(pinchMovement.distance.startPosition, result.distance.startPosition);\n  Cartesian2.clone(pinchMovement.distance.endPosition, result.distance.endPosition);\n  Cartesian2.clone(pinchMovement.angleAndHeight.startPosition, result.angleAndHeight.startPosition);\n  Cartesian2.clone(pinchMovement.angleAndHeight.endPosition, result.angleAndHeight.endPosition);\n}\n\nfunction listenToPinch(aggregator, modifier, canvas) {\n  var key = getKey(CameraEventType.PINCH, modifier);\n  var update = aggregator._update;\n  var isDown = aggregator._isDown;\n  var eventStartPosition = aggregator._eventStartPosition;\n  var pressTime = aggregator._pressTime;\n  var releaseTime = aggregator._releaseTime;\n  update[key] = true;\n  isDown[key] = false;\n  eventStartPosition[key] = new Cartesian2();\n  var movement = aggregator._movement[key];\n\n  if (!defined(movement)) {\n    movement = aggregator._movement[key] = {};\n  }\n\n  movement.distance = {\n    startPosition: new Cartesian2(),\n    endPosition: new Cartesian2()\n  };\n  movement.angleAndHeight = {\n    startPosition: new Cartesian2(),\n    endPosition: new Cartesian2()\n  };\n  movement.prevAngle = 0.0;\n\n  aggregator._eventHandler.setInputAction(function (event) {\n    aggregator._buttonsDown++;\n    isDown[key] = true;\n    pressTime[key] = new Date(); // Compute center position and store as start point.\n\n    Cartesian2.lerp(event.position1, event.position2, 0.5, eventStartPosition[key]);\n  }, ScreenSpaceEventType.PINCH_START, modifier);\n\n  aggregator._eventHandler.setInputAction(function () {\n    aggregator._buttonsDown = Math.max(aggregator._buttonsDown - 1, 0);\n    isDown[key] = false;\n    releaseTime[key] = new Date();\n  }, ScreenSpaceEventType.PINCH_END, modifier);\n\n  aggregator._eventHandler.setInputAction(function (mouseMovement) {\n    if (isDown[key]) {\n      // Aggregate several input events into a single animation frame.\n      if (!update[key]) {\n        Cartesian2.clone(mouseMovement.distance.endPosition, movement.distance.endPosition);\n        Cartesian2.clone(mouseMovement.angleAndHeight.endPosition, movement.angleAndHeight.endPosition);\n      } else {\n        clonePinchMovement(mouseMovement, movement);\n        update[key] = false;\n        movement.prevAngle = movement.angleAndHeight.startPosition.x;\n      } // Make sure our aggregation of angles does not \"flip\" over 360 degrees.\n\n\n      var angle = movement.angleAndHeight.endPosition.x;\n      var prevAngle = movement.prevAngle;\n      var TwoPI = Math.PI * 2;\n\n      while (angle >= prevAngle + Math.PI) {\n        angle -= TwoPI;\n      }\n\n      while (angle < prevAngle - Math.PI) {\n        angle += TwoPI;\n      }\n\n      movement.angleAndHeight.endPosition.x = -angle * canvas.clientWidth / 12;\n      movement.angleAndHeight.startPosition.x = -prevAngle * canvas.clientWidth / 12;\n    }\n  }, ScreenSpaceEventType.PINCH_MOVE, modifier);\n}\n\nfunction listenToWheel(aggregator, modifier) {\n  var key = getKey(CameraEventType.WHEEL, modifier);\n  var update = aggregator._update;\n  update[key] = true;\n  var movement = aggregator._movement[key];\n\n  if (!defined(movement)) {\n    movement = aggregator._movement[key] = {};\n  }\n\n  movement.startPosition = new Cartesian2();\n  movement.endPosition = new Cartesian2();\n\n  aggregator._eventHandler.setInputAction(function (delta) {\n    // TODO: magic numbers\n    var arcLength = 15.0 * CesiumMath.toRadians(delta);\n\n    if (!update[key]) {\n      movement.endPosition.y = movement.endPosition.y + arcLength;\n    } else {\n      Cartesian2.clone(Cartesian2.ZERO, movement.startPosition);\n      movement.endPosition.x = 0.0;\n      movement.endPosition.y = arcLength;\n      update[key] = false;\n    }\n  }, ScreenSpaceEventType.WHEEL, modifier);\n}\n\nfunction listenMouseButtonDownUp(aggregator, modifier, type) {\n  var key = getKey(type, modifier);\n  var isDown = aggregator._isDown;\n  var eventStartPosition = aggregator._eventStartPosition;\n  var pressTime = aggregator._pressTime;\n  var releaseTime = aggregator._releaseTime;\n  isDown[key] = false;\n  eventStartPosition[key] = new Cartesian2();\n  var lastMovement = aggregator._lastMovement[key];\n\n  if (!defined(lastMovement)) {\n    lastMovement = aggregator._lastMovement[key] = {\n      startPosition: new Cartesian2(),\n      endPosition: new Cartesian2(),\n      valid: false\n    };\n  }\n\n  var down;\n  var up;\n\n  if (type === CameraEventType.LEFT_DRAG) {\n    down = ScreenSpaceEventType.LEFT_DOWN;\n    up = ScreenSpaceEventType.LEFT_UP;\n  } else if (type === CameraEventType.RIGHT_DRAG) {\n    down = ScreenSpaceEventType.RIGHT_DOWN;\n    up = ScreenSpaceEventType.RIGHT_UP;\n  } else if (type === CameraEventType.MIDDLE_DRAG) {\n    down = ScreenSpaceEventType.MIDDLE_DOWN;\n    up = ScreenSpaceEventType.MIDDLE_UP;\n  }\n\n  aggregator._eventHandler.setInputAction(function (event) {\n    aggregator._buttonsDown++;\n    lastMovement.valid = false;\n    isDown[key] = true;\n    pressTime[key] = new Date();\n    Cartesian2.clone(event.position, eventStartPosition[key]);\n  }, down, modifier);\n\n  aggregator._eventHandler.setInputAction(function () {\n    aggregator._buttonsDown = Math.max(aggregator._buttonsDown - 1, 0);\n    isDown[key] = false;\n    releaseTime[key] = new Date();\n  }, up, modifier);\n}\n\nfunction cloneMouseMovement(mouseMovement, result) {\n  Cartesian2.clone(mouseMovement.startPosition, result.startPosition);\n  Cartesian2.clone(mouseMovement.endPosition, result.endPosition);\n}\n\nfunction listenMouseMove(aggregator, modifier) {\n  var update = aggregator._update;\n  var movement = aggregator._movement;\n  var lastMovement = aggregator._lastMovement;\n  var isDown = aggregator._isDown;\n\n  for (var typeName in CameraEventType) {\n    if (CameraEventType.hasOwnProperty(typeName)) {\n      var type = CameraEventType[typeName];\n\n      if (defined(type)) {\n        var key = getKey(type, modifier);\n        update[key] = true;\n\n        if (!defined(aggregator._lastMovement[key])) {\n          aggregator._lastMovement[key] = {\n            startPosition: new Cartesian2(),\n            endPosition: new Cartesian2(),\n            valid: false\n          };\n        }\n\n        if (!defined(aggregator._movement[key])) {\n          aggregator._movement[key] = {\n            startPosition: new Cartesian2(),\n            endPosition: new Cartesian2()\n          };\n        }\n      }\n    }\n  }\n\n  aggregator._eventHandler.setInputAction(function (mouseMovement) {\n    for (var typeName in CameraEventType) {\n      if (CameraEventType.hasOwnProperty(typeName)) {\n        var type = CameraEventType[typeName];\n\n        if (defined(type)) {\n          var key = getKey(type, modifier);\n\n          if (isDown[key]) {\n            if (!update[key]) {\n              Cartesian2.clone(mouseMovement.endPosition, movement[key].endPosition);\n            } else {\n              cloneMouseMovement(movement[key], lastMovement[key]);\n              lastMovement[key].valid = true;\n              cloneMouseMovement(mouseMovement, movement[key]);\n              update[key] = false;\n            }\n          }\n        }\n      }\n    }\n\n    Cartesian2.clone(mouseMovement.endPosition, aggregator._currentMousePosition);\n  }, ScreenSpaceEventType.MOUSE_MOVE, modifier);\n}\n/**\n * Aggregates input events. For example, suppose the following inputs are received between frames:\n * left mouse button down, mouse move, mouse move, left mouse button up. These events will be aggregated into\n * one event with a start and end position of the mouse.\n *\n * @alias CameraEventAggregator\n * @constructor\n *\n * @param {Canvas} [canvas=document] The element to handle events for.\n *\n * @see ScreenSpaceEventHandler\n */\n\n\nfunction CameraEventAggregator(canvas) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(canvas)) {\n    throw new DeveloperError(\"canvas is required.\");\n  } //>>includeEnd('debug');\n\n\n  this._eventHandler = new ScreenSpaceEventHandler(canvas);\n  this._update = {};\n  this._movement = {};\n  this._lastMovement = {};\n  this._isDown = {};\n  this._eventStartPosition = {};\n  this._pressTime = {};\n  this._releaseTime = {};\n  this._buttonsDown = 0;\n  this._currentMousePosition = new Cartesian2();\n  listenToWheel(this, undefined);\n  listenToPinch(this, undefined, canvas);\n  listenMouseButtonDownUp(this, undefined, CameraEventType.LEFT_DRAG);\n  listenMouseButtonDownUp(this, undefined, CameraEventType.RIGHT_DRAG);\n  listenMouseButtonDownUp(this, undefined, CameraEventType.MIDDLE_DRAG);\n  listenMouseMove(this, undefined);\n\n  for (var modifierName in KeyboardEventModifier) {\n    if (KeyboardEventModifier.hasOwnProperty(modifierName)) {\n      var modifier = KeyboardEventModifier[modifierName];\n\n      if (defined(modifier)) {\n        listenToWheel(this, modifier);\n        listenToPinch(this, modifier, canvas);\n        listenMouseButtonDownUp(this, modifier, CameraEventType.LEFT_DRAG);\n        listenMouseButtonDownUp(this, modifier, CameraEventType.RIGHT_DRAG);\n        listenMouseButtonDownUp(this, modifier, CameraEventType.MIDDLE_DRAG);\n        listenMouseMove(this, modifier);\n      }\n    }\n  }\n}\n\nObject.defineProperties(CameraEventAggregator.prototype, {\n  /**\n   * Gets the current mouse position.\n   * @memberof CameraEventAggregator.prototype\n   * @type {Cartesian2}\n   */\n  currentMousePosition: {\n    get: function () {\n      return this._currentMousePosition;\n    }\n  },\n\n  /**\n   * Gets whether any mouse button is down, a touch has started, or the wheel has been moved.\n   * @memberof CameraEventAggregator.prototype\n   * @type {Boolean}\n   */\n  anyButtonDown: {\n    get: function () {\n      var wheelMoved = !this._update[getKey(CameraEventType.WHEEL)] || !this._update[getKey(CameraEventType.WHEEL, KeyboardEventModifier.SHIFT)] || !this._update[getKey(CameraEventType.WHEEL, KeyboardEventModifier.CTRL)] || !this._update[getKey(CameraEventType.WHEEL, KeyboardEventModifier.ALT)];\n      return this._buttonsDown > 0 || wheelMoved;\n    }\n  }\n});\n/**\n * Gets if a mouse button down or touch has started and has been moved.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Boolean} Returns <code>true</code> if a mouse button down or touch has started and has been moved; otherwise, <code>false</code>\n */\n\nCameraEventAggregator.prototype.isMoving = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  } //>>includeEnd('debug');\n\n\n  var key = getKey(type, modifier);\n  return !this._update[key];\n};\n/**\n * Gets the aggregated start and end position of the current event.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Object} An object with two {@link Cartesian2} properties: <code>startPosition</code> and <code>endPosition</code>.\n */\n\n\nCameraEventAggregator.prototype.getMovement = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  } //>>includeEnd('debug');\n\n\n  var key = getKey(type, modifier);\n  var movement = this._movement[key];\n  return movement;\n};\n/**\n * Gets the start and end position of the last move event (not the aggregated event).\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Object|undefined} An object with two {@link Cartesian2} properties: <code>startPosition</code> and <code>endPosition</code> or <code>undefined</code>.\n */\n\n\nCameraEventAggregator.prototype.getLastMovement = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  } //>>includeEnd('debug');\n\n\n  var key = getKey(type, modifier);\n  var lastMovement = this._lastMovement[key];\n\n  if (lastMovement.valid) {\n    return lastMovement;\n  }\n\n  return undefined;\n};\n/**\n * Gets whether the mouse button is down or a touch has started.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Boolean} Whether the mouse button is down or a touch has started.\n */\n\n\nCameraEventAggregator.prototype.isButtonDown = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  } //>>includeEnd('debug');\n\n\n  var key = getKey(type, modifier);\n  return this._isDown[key];\n};\n/**\n * Gets the mouse position that started the aggregation.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Cartesian2} The mouse position.\n */\n\n\nCameraEventAggregator.prototype.getStartMousePosition = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (type === CameraEventType.WHEEL) {\n    return this._currentMousePosition;\n  }\n\n  var key = getKey(type, modifier);\n  return this._eventStartPosition[key];\n};\n/**\n * Gets the time the button was pressed or the touch was started.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Date} The time the button was pressed or the touch was started.\n */\n\n\nCameraEventAggregator.prototype.getButtonPressTime = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  } //>>includeEnd('debug');\n\n\n  var key = getKey(type, modifier);\n  return this._pressTime[key];\n};\n/**\n * Gets the time the button was released or the touch was ended.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Date} The time the button was released or the touch was ended.\n */\n\n\nCameraEventAggregator.prototype.getButtonReleaseTime = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  } //>>includeEnd('debug');\n\n\n  var key = getKey(type, modifier);\n  return this._releaseTime[key];\n};\n/**\n * Signals that all of the events have been handled and the aggregator should be reset to handle new events.\n */\n\n\nCameraEventAggregator.prototype.reset = function () {\n  for (var name in this._update) {\n    if (this._update.hasOwnProperty(name)) {\n      this._update[name] = true;\n    }\n  }\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see CameraEventAggregator#destroy\n */\n\n\nCameraEventAggregator.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Removes mouse listeners held by this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * handler = handler && handler.destroy();\n *\n * @see CameraEventAggregator#isDestroyed\n */\n\n\nCameraEventAggregator.prototype.destroy = function () {\n  this._eventHandler = this._eventHandler && this._eventHandler.destroy();\n  return destroyObject(this);\n};\n\nexport default CameraEventAggregator;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Scene/CameraEventAggregator.js"],"names":["Cartesian2","defined","destroyObject","DeveloperError","KeyboardEventModifier","CesiumMath","ScreenSpaceEventHandler","ScreenSpaceEventType","CameraEventType","getKey","type","modifier","key","clonePinchMovement","pinchMovement","result","clone","distance","startPosition","endPosition","angleAndHeight","listenToPinch","aggregator","canvas","PINCH","update","_update","isDown","_isDown","eventStartPosition","_eventStartPosition","pressTime","_pressTime","releaseTime","_releaseTime","movement","_movement","prevAngle","_eventHandler","setInputAction","event","_buttonsDown","Date","lerp","position1","position2","PINCH_START","Math","max","PINCH_END","mouseMovement","x","angle","TwoPI","PI","clientWidth","PINCH_MOVE","listenToWheel","WHEEL","delta","arcLength","toRadians","y","ZERO","listenMouseButtonDownUp","lastMovement","_lastMovement","valid","down","up","LEFT_DRAG","LEFT_DOWN","LEFT_UP","RIGHT_DRAG","RIGHT_DOWN","RIGHT_UP","MIDDLE_DRAG","MIDDLE_DOWN","MIDDLE_UP","position","cloneMouseMovement","listenMouseMove","typeName","hasOwnProperty","_currentMousePosition","MOUSE_MOVE","CameraEventAggregator","undefined","modifierName","Object","defineProperties","prototype","currentMousePosition","get","anyButtonDown","wheelMoved","SHIFT","CTRL","ALT","isMoving","getMovement","getLastMovement","isButtonDown","getStartMousePosition","getButtonPressTime","getButtonReleaseTime","reset","name","isDestroyed","destroy"],"mappings":"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","sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport KeyboardEventModifier from \"../Core/KeyboardEventModifier.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport ScreenSpaceEventHandler from \"../Core/ScreenSpaceEventHandler.js\";\nimport ScreenSpaceEventType from \"../Core/ScreenSpaceEventType.js\";\nimport CameraEventType from \"./CameraEventType.js\";\n\nfunction getKey(type, modifier) {\n  var key = type;\n  if (defined(modifier)) {\n    key += \"+\" + modifier;\n  }\n  return key;\n}\n\nfunction clonePinchMovement(pinchMovement, result) {\n  Cartesian2.clone(\n    pinchMovement.distance.startPosition,\n    result.distance.startPosition\n  );\n  Cartesian2.clone(\n    pinchMovement.distance.endPosition,\n    result.distance.endPosition\n  );\n\n  Cartesian2.clone(\n    pinchMovement.angleAndHeight.startPosition,\n    result.angleAndHeight.startPosition\n  );\n  Cartesian2.clone(\n    pinchMovement.angleAndHeight.endPosition,\n    result.angleAndHeight.endPosition\n  );\n}\n\nfunction listenToPinch(aggregator, modifier, canvas) {\n  var key = getKey(CameraEventType.PINCH, modifier);\n\n  var update = aggregator._update;\n  var isDown = aggregator._isDown;\n  var eventStartPosition = aggregator._eventStartPosition;\n  var pressTime = aggregator._pressTime;\n  var releaseTime = aggregator._releaseTime;\n\n  update[key] = true;\n  isDown[key] = false;\n  eventStartPosition[key] = new Cartesian2();\n\n  var movement = aggregator._movement[key];\n  if (!defined(movement)) {\n    movement = aggregator._movement[key] = {};\n  }\n\n  movement.distance = {\n    startPosition: new Cartesian2(),\n    endPosition: new Cartesian2(),\n  };\n  movement.angleAndHeight = {\n    startPosition: new Cartesian2(),\n    endPosition: new Cartesian2(),\n  };\n  movement.prevAngle = 0.0;\n\n  aggregator._eventHandler.setInputAction(\n    function (event) {\n      aggregator._buttonsDown++;\n      isDown[key] = true;\n      pressTime[key] = new Date();\n      // Compute center position and store as start point.\n      Cartesian2.lerp(\n        event.position1,\n        event.position2,\n        0.5,\n        eventStartPosition[key]\n      );\n    },\n    ScreenSpaceEventType.PINCH_START,\n    modifier\n  );\n\n  aggregator._eventHandler.setInputAction(\n    function () {\n      aggregator._buttonsDown = Math.max(aggregator._buttonsDown - 1, 0);\n      isDown[key] = false;\n      releaseTime[key] = new Date();\n    },\n    ScreenSpaceEventType.PINCH_END,\n    modifier\n  );\n\n  aggregator._eventHandler.setInputAction(\n    function (mouseMovement) {\n      if (isDown[key]) {\n        // Aggregate several input events into a single animation frame.\n        if (!update[key]) {\n          Cartesian2.clone(\n            mouseMovement.distance.endPosition,\n            movement.distance.endPosition\n          );\n          Cartesian2.clone(\n            mouseMovement.angleAndHeight.endPosition,\n            movement.angleAndHeight.endPosition\n          );\n        } else {\n          clonePinchMovement(mouseMovement, movement);\n          update[key] = false;\n          movement.prevAngle = movement.angleAndHeight.startPosition.x;\n        }\n        // Make sure our aggregation of angles does not \"flip\" over 360 degrees.\n        var angle = movement.angleAndHeight.endPosition.x;\n        var prevAngle = movement.prevAngle;\n        var TwoPI = Math.PI * 2;\n        while (angle >= prevAngle + Math.PI) {\n          angle -= TwoPI;\n        }\n        while (angle < prevAngle - Math.PI) {\n          angle += TwoPI;\n        }\n        movement.angleAndHeight.endPosition.x =\n          (-angle * canvas.clientWidth) / 12;\n        movement.angleAndHeight.startPosition.x =\n          (-prevAngle * canvas.clientWidth) / 12;\n      }\n    },\n    ScreenSpaceEventType.PINCH_MOVE,\n    modifier\n  );\n}\n\nfunction listenToWheel(aggregator, modifier) {\n  var key = getKey(CameraEventType.WHEEL, modifier);\n\n  var update = aggregator._update;\n  update[key] = true;\n\n  var movement = aggregator._movement[key];\n  if (!defined(movement)) {\n    movement = aggregator._movement[key] = {};\n  }\n\n  movement.startPosition = new Cartesian2();\n  movement.endPosition = new Cartesian2();\n\n  aggregator._eventHandler.setInputAction(\n    function (delta) {\n      // TODO: magic numbers\n      var arcLength = 15.0 * CesiumMath.toRadians(delta);\n      if (!update[key]) {\n        movement.endPosition.y = movement.endPosition.y + arcLength;\n      } else {\n        Cartesian2.clone(Cartesian2.ZERO, movement.startPosition);\n        movement.endPosition.x = 0.0;\n        movement.endPosition.y = arcLength;\n        update[key] = false;\n      }\n    },\n    ScreenSpaceEventType.WHEEL,\n    modifier\n  );\n}\n\nfunction listenMouseButtonDownUp(aggregator, modifier, type) {\n  var key = getKey(type, modifier);\n\n  var isDown = aggregator._isDown;\n  var eventStartPosition = aggregator._eventStartPosition;\n  var pressTime = aggregator._pressTime;\n  var releaseTime = aggregator._releaseTime;\n\n  isDown[key] = false;\n  eventStartPosition[key] = new Cartesian2();\n\n  var lastMovement = aggregator._lastMovement[key];\n  if (!defined(lastMovement)) {\n    lastMovement = aggregator._lastMovement[key] = {\n      startPosition: new Cartesian2(),\n      endPosition: new Cartesian2(),\n      valid: false,\n    };\n  }\n\n  var down;\n  var up;\n  if (type === CameraEventType.LEFT_DRAG) {\n    down = ScreenSpaceEventType.LEFT_DOWN;\n    up = ScreenSpaceEventType.LEFT_UP;\n  } else if (type === CameraEventType.RIGHT_DRAG) {\n    down = ScreenSpaceEventType.RIGHT_DOWN;\n    up = ScreenSpaceEventType.RIGHT_UP;\n  } else if (type === CameraEventType.MIDDLE_DRAG) {\n    down = ScreenSpaceEventType.MIDDLE_DOWN;\n    up = ScreenSpaceEventType.MIDDLE_UP;\n  }\n\n  aggregator._eventHandler.setInputAction(\n    function (event) {\n      aggregator._buttonsDown++;\n      lastMovement.valid = false;\n      isDown[key] = true;\n      pressTime[key] = new Date();\n      Cartesian2.clone(event.position, eventStartPosition[key]);\n    },\n    down,\n    modifier\n  );\n\n  aggregator._eventHandler.setInputAction(\n    function () {\n      aggregator._buttonsDown = Math.max(aggregator._buttonsDown - 1, 0);\n      isDown[key] = false;\n      releaseTime[key] = new Date();\n    },\n    up,\n    modifier\n  );\n}\n\nfunction cloneMouseMovement(mouseMovement, result) {\n  Cartesian2.clone(mouseMovement.startPosition, result.startPosition);\n  Cartesian2.clone(mouseMovement.endPosition, result.endPosition);\n}\n\nfunction listenMouseMove(aggregator, modifier) {\n  var update = aggregator._update;\n  var movement = aggregator._movement;\n  var lastMovement = aggregator._lastMovement;\n  var isDown = aggregator._isDown;\n\n  for (var typeName in CameraEventType) {\n    if (CameraEventType.hasOwnProperty(typeName)) {\n      var type = CameraEventType[typeName];\n      if (defined(type)) {\n        var key = getKey(type, modifier);\n        update[key] = true;\n\n        if (!defined(aggregator._lastMovement[key])) {\n          aggregator._lastMovement[key] = {\n            startPosition: new Cartesian2(),\n            endPosition: new Cartesian2(),\n            valid: false,\n          };\n        }\n\n        if (!defined(aggregator._movement[key])) {\n          aggregator._movement[key] = {\n            startPosition: new Cartesian2(),\n            endPosition: new Cartesian2(),\n          };\n        }\n      }\n    }\n  }\n\n  aggregator._eventHandler.setInputAction(\n    function (mouseMovement) {\n      for (var typeName in CameraEventType) {\n        if (CameraEventType.hasOwnProperty(typeName)) {\n          var type = CameraEventType[typeName];\n          if (defined(type)) {\n            var key = getKey(type, modifier);\n            if (isDown[key]) {\n              if (!update[key]) {\n                Cartesian2.clone(\n                  mouseMovement.endPosition,\n                  movement[key].endPosition\n                );\n              } else {\n                cloneMouseMovement(movement[key], lastMovement[key]);\n                lastMovement[key].valid = true;\n                cloneMouseMovement(mouseMovement, movement[key]);\n                update[key] = false;\n              }\n            }\n          }\n        }\n      }\n\n      Cartesian2.clone(\n        mouseMovement.endPosition,\n        aggregator._currentMousePosition\n      );\n    },\n    ScreenSpaceEventType.MOUSE_MOVE,\n    modifier\n  );\n}\n\n/**\n * Aggregates input events. For example, suppose the following inputs are received between frames:\n * left mouse button down, mouse move, mouse move, left mouse button up. These events will be aggregated into\n * one event with a start and end position of the mouse.\n *\n * @alias CameraEventAggregator\n * @constructor\n *\n * @param {Canvas} [canvas=document] The element to handle events for.\n *\n * @see ScreenSpaceEventHandler\n */\nfunction CameraEventAggregator(canvas) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(canvas)) {\n    throw new DeveloperError(\"canvas is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._eventHandler = new ScreenSpaceEventHandler(canvas);\n\n  this._update = {};\n  this._movement = {};\n  this._lastMovement = {};\n  this._isDown = {};\n  this._eventStartPosition = {};\n  this._pressTime = {};\n  this._releaseTime = {};\n\n  this._buttonsDown = 0;\n\n  this._currentMousePosition = new Cartesian2();\n\n  listenToWheel(this, undefined);\n  listenToPinch(this, undefined, canvas);\n  listenMouseButtonDownUp(this, undefined, CameraEventType.LEFT_DRAG);\n  listenMouseButtonDownUp(this, undefined, CameraEventType.RIGHT_DRAG);\n  listenMouseButtonDownUp(this, undefined, CameraEventType.MIDDLE_DRAG);\n  listenMouseMove(this, undefined);\n\n  for (var modifierName in KeyboardEventModifier) {\n    if (KeyboardEventModifier.hasOwnProperty(modifierName)) {\n      var modifier = KeyboardEventModifier[modifierName];\n      if (defined(modifier)) {\n        listenToWheel(this, modifier);\n        listenToPinch(this, modifier, canvas);\n        listenMouseButtonDownUp(this, modifier, CameraEventType.LEFT_DRAG);\n        listenMouseButtonDownUp(this, modifier, CameraEventType.RIGHT_DRAG);\n        listenMouseButtonDownUp(this, modifier, CameraEventType.MIDDLE_DRAG);\n        listenMouseMove(this, modifier);\n      }\n    }\n  }\n}\n\nObject.defineProperties(CameraEventAggregator.prototype, {\n  /**\n   * Gets the current mouse position.\n   * @memberof CameraEventAggregator.prototype\n   * @type {Cartesian2}\n   */\n  currentMousePosition: {\n    get: function () {\n      return this._currentMousePosition;\n    },\n  },\n\n  /**\n   * Gets whether any mouse button is down, a touch has started, or the wheel has been moved.\n   * @memberof CameraEventAggregator.prototype\n   * @type {Boolean}\n   */\n  anyButtonDown: {\n    get: function () {\n      var wheelMoved =\n        !this._update[getKey(CameraEventType.WHEEL)] ||\n        !this._update[\n          getKey(CameraEventType.WHEEL, KeyboardEventModifier.SHIFT)\n        ] ||\n        !this._update[\n          getKey(CameraEventType.WHEEL, KeyboardEventModifier.CTRL)\n        ] ||\n        !this._update[getKey(CameraEventType.WHEEL, KeyboardEventModifier.ALT)];\n      return this._buttonsDown > 0 || wheelMoved;\n    },\n  },\n});\n\n/**\n * Gets if a mouse button down or touch has started and has been moved.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Boolean} Returns <code>true</code> if a mouse button down or touch has started and has been moved; otherwise, <code>false</code>\n */\nCameraEventAggregator.prototype.isMoving = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var key = getKey(type, modifier);\n  return !this._update[key];\n};\n\n/**\n * Gets the aggregated start and end position of the current event.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Object} An object with two {@link Cartesian2} properties: <code>startPosition</code> and <code>endPosition</code>.\n */\nCameraEventAggregator.prototype.getMovement = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var key = getKey(type, modifier);\n  var movement = this._movement[key];\n  return movement;\n};\n\n/**\n * Gets the start and end position of the last move event (not the aggregated event).\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Object|undefined} An object with two {@link Cartesian2} properties: <code>startPosition</code> and <code>endPosition</code> or <code>undefined</code>.\n */\nCameraEventAggregator.prototype.getLastMovement = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var key = getKey(type, modifier);\n  var lastMovement = this._lastMovement[key];\n  if (lastMovement.valid) {\n    return lastMovement;\n  }\n\n  return undefined;\n};\n\n/**\n * Gets whether the mouse button is down or a touch has started.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Boolean} Whether the mouse button is down or a touch has started.\n */\nCameraEventAggregator.prototype.isButtonDown = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var key = getKey(type, modifier);\n  return this._isDown[key];\n};\n\n/**\n * Gets the mouse position that started the aggregation.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Cartesian2} The mouse position.\n */\nCameraEventAggregator.prototype.getStartMousePosition = function (\n  type,\n  modifier\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (type === CameraEventType.WHEEL) {\n    return this._currentMousePosition;\n  }\n\n  var key = getKey(type, modifier);\n  return this._eventStartPosition[key];\n};\n\n/**\n * Gets the time the button was pressed or the touch was started.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Date} The time the button was pressed or the touch was started.\n */\nCameraEventAggregator.prototype.getButtonPressTime = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var key = getKey(type, modifier);\n  return this._pressTime[key];\n};\n\n/**\n * Gets the time the button was released or the touch was ended.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Date} The time the button was released or the touch was ended.\n */\nCameraEventAggregator.prototype.getButtonReleaseTime = function (\n  type,\n  modifier\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var key = getKey(type, modifier);\n  return this._releaseTime[key];\n};\n\n/**\n * Signals that all of the events have been handled and the aggregator should be reset to handle new events.\n */\nCameraEventAggregator.prototype.reset = function () {\n  for (var name in this._update) {\n    if (this._update.hasOwnProperty(name)) {\n      this._update[name] = true;\n    }\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see CameraEventAggregator#destroy\n */\nCameraEventAggregator.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes mouse listeners held by this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * handler = handler && handler.destroy();\n *\n * @see CameraEventAggregator#isDestroyed\n */\nCameraEventAggregator.prototype.destroy = function () {\n  this._eventHandler = this._eventHandler && this._eventHandler.destroy();\n  return destroyObject(this);\n};\nexport default CameraEventAggregator;\n"]},"metadata":{},"sourceType":"module"}