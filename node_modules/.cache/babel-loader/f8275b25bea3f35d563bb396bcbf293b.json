{"ast":null,"code":"import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport ClassificationType from \"../Scene/ClassificationType.js\";\nimport PolylineColorAppearance from \"../Scene/PolylineColorAppearance.js\";\nimport PolylineMaterialAppearance from \"../Scene/PolylineMaterialAppearance.js\";\nimport ShadowMode from \"../Scene/ShadowMode.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport DynamicGeometryBatch from \"./DynamicGeometryBatch.js\";\nimport PolylineGeometryUpdater from \"./PolylineGeometryUpdater.js\";\nimport StaticGeometryColorBatch from \"./StaticGeometryColorBatch.js\";\nimport StaticGeometryPerMaterialBatch from \"./StaticGeometryPerMaterialBatch.js\";\nimport StaticGroundPolylinePerMaterialBatch from \"./StaticGroundPolylinePerMaterialBatch.js\";\nvar emptyArray = [];\n\nfunction removeUpdater(that, updater) {\n  //We don't keep track of which batch an updater is in, so just remove it from all of them.\n  var batches = that._batches;\n  var length = batches.length;\n\n  for (var i = 0; i < length; i++) {\n    batches[i].remove(updater);\n  }\n}\n\nfunction insertUpdaterIntoBatch(that, time, updater) {\n  if (updater.isDynamic) {\n    that._dynamicBatch.add(time, updater);\n\n    return;\n  }\n\n  if (updater.clampToGround && updater.fillEnabled) {\n    // Also checks for support\n    var classificationType = updater.classificationTypeProperty.getValue(time);\n\n    that._groundBatches[classificationType].add(time, updater);\n\n    return;\n  }\n\n  var shadows;\n\n  if (updater.fillEnabled) {\n    shadows = updater.shadowsProperty.getValue(time);\n  }\n\n  var multiplier = 0;\n\n  if (defined(updater.depthFailMaterialProperty)) {\n    multiplier = updater.depthFailMaterialProperty instanceof ColorMaterialProperty ? 1 : 2;\n  }\n\n  var index;\n\n  if (defined(shadows)) {\n    index = shadows + multiplier * ShadowMode.NUMBER_OF_SHADOW_MODES;\n  }\n\n  if (updater.fillEnabled) {\n    if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n      that._colorBatches[index].add(time, updater);\n    } else {\n      that._materialBatches[index].add(time, updater);\n    }\n  }\n}\n/**\n * A visualizer for polylines represented by {@link Primitive} instances.\n * @alias PolylineVisualizer\n * @constructor\n *\n * @param {Scene} scene The scene the primitives will be rendered in.\n * @param {EntityCollection} entityCollection The entityCollection to visualize.\n * @param {PrimitiveCollection} [primitives=scene.primitives] A collection to add primitives related to the entities\n * @param {PrimitiveCollection} [groundPrimitives=scene.groundPrimitives] A collection to add ground primitives related to the entities\n */\n\n\nfunction PolylineVisualizer(scene, entityCollection, primitives, groundPrimitives) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"scene\", scene);\n  Check.defined(\"entityCollection\", entityCollection); //>>includeEnd('debug');\n\n  groundPrimitives = defaultValue(groundPrimitives, scene.groundPrimitives);\n  primitives = defaultValue(primitives, scene.primitives);\n  this._scene = scene;\n  this._primitives = primitives;\n  this._entityCollection = undefined;\n  this._addedObjects = new AssociativeArray();\n  this._removedObjects = new AssociativeArray();\n  this._changedObjects = new AssociativeArray();\n  var i;\n  var numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;\n  this._colorBatches = new Array(numberOfShadowModes * 3);\n  this._materialBatches = new Array(numberOfShadowModes * 3);\n\n  for (i = 0; i < numberOfShadowModes; ++i) {\n    this._colorBatches[i] = new StaticGeometryColorBatch(primitives, PolylineColorAppearance, undefined, false, i); // no depth fail appearance\n\n    this._materialBatches[i] = new StaticGeometryPerMaterialBatch(primitives, PolylineMaterialAppearance, undefined, false, i);\n    this._colorBatches[i + numberOfShadowModes] = new StaticGeometryColorBatch(primitives, PolylineColorAppearance, PolylineColorAppearance, false, i); //depth fail appearance variations\n\n    this._materialBatches[i + numberOfShadowModes] = new StaticGeometryPerMaterialBatch(primitives, PolylineMaterialAppearance, PolylineColorAppearance, false, i);\n    this._colorBatches[i + numberOfShadowModes * 2] = new StaticGeometryColorBatch(primitives, PolylineColorAppearance, PolylineMaterialAppearance, false, i);\n    this._materialBatches[i + numberOfShadowModes * 2] = new StaticGeometryPerMaterialBatch(primitives, PolylineMaterialAppearance, PolylineMaterialAppearance, false, i);\n  }\n\n  this._dynamicBatch = new DynamicGeometryBatch(primitives, groundPrimitives);\n  var numberOfClassificationTypes = ClassificationType.NUMBER_OF_CLASSIFICATION_TYPES;\n  this._groundBatches = new Array(numberOfClassificationTypes);\n\n  for (i = 0; i < numberOfClassificationTypes; ++i) {\n    this._groundBatches[i] = new StaticGroundPolylinePerMaterialBatch(groundPrimitives, i);\n  }\n\n  this._batches = this._colorBatches.concat(this._materialBatches, this._dynamicBatch, this._groundBatches);\n  this._subscriptions = new AssociativeArray();\n  this._updaters = new AssociativeArray();\n  this._entityCollection = entityCollection;\n  entityCollection.collectionChanged.addEventListener(PolylineVisualizer.prototype._onCollectionChanged, this);\n\n  this._onCollectionChanged(entityCollection, entityCollection.values, emptyArray);\n}\n/**\n * Updates all of the primitives created by this visualizer to match their\n * Entity counterpart at the given time.\n *\n * @param {JulianDate} time The time to update to.\n * @returns {Boolean} True if the visualizer successfully updated to the provided time,\n * false if the visualizer is waiting for asynchronous primitives to be created.\n */\n\n\nPolylineVisualizer.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time); //>>includeEnd('debug');\n\n  var addedObjects = this._addedObjects;\n  var added = addedObjects.values;\n  var removedObjects = this._removedObjects;\n  var removed = removedObjects.values;\n  var changedObjects = this._changedObjects;\n  var changed = changedObjects.values;\n  var i;\n  var entity;\n  var id;\n  var updater;\n\n  for (i = changed.length - 1; i > -1; i--) {\n    entity = changed[i];\n    id = entity.id;\n    updater = this._updaters.get(id); //If in a single update, an entity gets removed and a new instance\n    //re-added with the same id, the updater no longer tracks the\n    //correct entity, we need to both remove the old one and\n    //add the new one, which is done by pushing the entity\n    //onto the removed/added lists.\n\n    if (updater.entity === entity) {\n      removeUpdater(this, updater);\n      insertUpdaterIntoBatch(this, time, updater);\n    } else {\n      removed.push(entity);\n      added.push(entity);\n    }\n  }\n\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    id = entity.id;\n    updater = this._updaters.get(id);\n    removeUpdater(this, updater);\n    updater.destroy();\n\n    this._updaters.remove(id);\n\n    this._subscriptions.get(id)();\n\n    this._subscriptions.remove(id);\n  }\n\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    id = entity.id;\n    updater = new PolylineGeometryUpdater(entity, this._scene);\n\n    this._updaters.set(id, updater);\n\n    insertUpdaterIntoBatch(this, time, updater);\n\n    this._subscriptions.set(id, updater.geometryChanged.addEventListener(PolylineVisualizer._onGeometryChanged, this));\n  }\n\n  addedObjects.removeAll();\n  removedObjects.removeAll();\n  changedObjects.removeAll();\n  var isUpdated = true;\n  var batches = this._batches;\n  var length = batches.length;\n\n  for (i = 0; i < length; i++) {\n    isUpdated = batches[i].update(time) && isUpdated;\n  }\n\n  return isUpdated;\n};\n\nvar getBoundingSphereArrayScratch = [];\nvar getBoundingSphereBoundingSphereScratch = new BoundingSphere();\n/**\n * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n * The bounding sphere is in the fixed frame of the scene's globe.\n *\n * @param {Entity} entity The entity whose bounding sphere to compute.\n * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n *                       BoundingSphereState.PENDING if the result is still being computed, or\n *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n * @private\n */\n\nPolylineVisualizer.prototype.getBoundingSphere = function (entity, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"entity\", entity);\n  Check.defined(\"result\", result); //>>includeEnd('debug');\n\n  var boundingSpheres = getBoundingSphereArrayScratch;\n  var tmp = getBoundingSphereBoundingSphereScratch;\n  var count = 0;\n  var state = BoundingSphereState.DONE;\n  var batches = this._batches;\n  var batchesLength = batches.length;\n\n  var updater = this._updaters.get(entity.id);\n\n  for (var i = 0; i < batchesLength; i++) {\n    state = batches[i].getBoundingSphere(updater, tmp);\n\n    if (state === BoundingSphereState.PENDING) {\n      return BoundingSphereState.PENDING;\n    } else if (state === BoundingSphereState.DONE) {\n      boundingSpheres[count] = BoundingSphere.clone(tmp, boundingSpheres[count]);\n      count++;\n    }\n  }\n\n  if (count === 0) {\n    return BoundingSphereState.FAILED;\n  }\n\n  boundingSpheres.length = count;\n  BoundingSphere.fromBoundingSpheres(boundingSpheres, result);\n  return BoundingSphereState.DONE;\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n */\n\n\nPolylineVisualizer.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Removes and destroys all primitives created by this instance.\n */\n\n\nPolylineVisualizer.prototype.destroy = function () {\n  this._entityCollection.collectionChanged.removeEventListener(PolylineVisualizer.prototype._onCollectionChanged, this);\n\n  this._addedObjects.removeAll();\n\n  this._removedObjects.removeAll();\n\n  var i;\n  var batches = this._batches;\n  var length = batches.length;\n\n  for (i = 0; i < length; i++) {\n    batches[i].removeAllPrimitives();\n  }\n\n  var subscriptions = this._subscriptions.values;\n  length = subscriptions.length;\n\n  for (i = 0; i < length; i++) {\n    subscriptions[i]();\n  }\n\n  this._subscriptions.removeAll();\n\n  return destroyObject(this);\n};\n/**\n * @private\n */\n\n\nPolylineVisualizer._onGeometryChanged = function (updater) {\n  var removedObjects = this._removedObjects;\n  var changedObjects = this._changedObjects;\n  var entity = updater.entity;\n  var id = entity.id;\n\n  if (!defined(removedObjects.get(id)) && !defined(changedObjects.get(id))) {\n    changedObjects.set(id, entity);\n  }\n};\n/**\n * @private\n */\n\n\nPolylineVisualizer.prototype._onCollectionChanged = function (entityCollection, added, removed) {\n  var addedObjects = this._addedObjects;\n  var removedObjects = this._removedObjects;\n  var changedObjects = this._changedObjects;\n  var i;\n  var id;\n  var entity;\n\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    id = entity.id;\n\n    if (!addedObjects.remove(id)) {\n      removedObjects.set(id, entity);\n      changedObjects.remove(id);\n    }\n  }\n\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    id = entity.id;\n\n    if (removedObjects.remove(id)) {\n      changedObjects.set(id, entity);\n    } else {\n      addedObjects.set(id, entity);\n    }\n  }\n};\n\nexport default PolylineVisualizer;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/DataSources/PolylineVisualizer.js"],"names":["AssociativeArray","BoundingSphere","Check","defaultValue","defined","destroyObject","ClassificationType","PolylineColorAppearance","PolylineMaterialAppearance","ShadowMode","BoundingSphereState","ColorMaterialProperty","DynamicGeometryBatch","PolylineGeometryUpdater","StaticGeometryColorBatch","StaticGeometryPerMaterialBatch","StaticGroundPolylinePerMaterialBatch","emptyArray","removeUpdater","that","updater","batches","_batches","length","i","remove","insertUpdaterIntoBatch","time","isDynamic","_dynamicBatch","add","clampToGround","fillEnabled","classificationType","classificationTypeProperty","getValue","_groundBatches","shadows","shadowsProperty","multiplier","depthFailMaterialProperty","index","NUMBER_OF_SHADOW_MODES","fillMaterialProperty","_colorBatches","_materialBatches","PolylineVisualizer","scene","entityCollection","primitives","groundPrimitives","_scene","_primitives","_entityCollection","undefined","_addedObjects","_removedObjects","_changedObjects","numberOfShadowModes","Array","numberOfClassificationTypes","NUMBER_OF_CLASSIFICATION_TYPES","concat","_subscriptions","_updaters","collectionChanged","addEventListener","prototype","_onCollectionChanged","values","update","addedObjects","added","removedObjects","removed","changedObjects","changed","entity","id","get","push","destroy","set","geometryChanged","_onGeometryChanged","removeAll","isUpdated","getBoundingSphereArrayScratch","getBoundingSphereBoundingSphereScratch","getBoundingSphere","result","boundingSpheres","tmp","count","state","DONE","batchesLength","PENDING","clone","FAILED","fromBoundingSpheres","isDestroyed","removeEventListener","removeAllPrimitives","subscriptions"],"mappings":"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","sourcesContent":["import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport ClassificationType from \"../Scene/ClassificationType.js\";\nimport PolylineColorAppearance from \"../Scene/PolylineColorAppearance.js\";\nimport PolylineMaterialAppearance from \"../Scene/PolylineMaterialAppearance.js\";\nimport ShadowMode from \"../Scene/ShadowMode.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport DynamicGeometryBatch from \"./DynamicGeometryBatch.js\";\nimport PolylineGeometryUpdater from \"./PolylineGeometryUpdater.js\";\nimport StaticGeometryColorBatch from \"./StaticGeometryColorBatch.js\";\nimport StaticGeometryPerMaterialBatch from \"./StaticGeometryPerMaterialBatch.js\";\nimport StaticGroundPolylinePerMaterialBatch from \"./StaticGroundPolylinePerMaterialBatch.js\";\n\nvar emptyArray = [];\n\nfunction removeUpdater(that, updater) {\n  //We don't keep track of which batch an updater is in, so just remove it from all of them.\n  var batches = that._batches;\n  var length = batches.length;\n  for (var i = 0; i < length; i++) {\n    batches[i].remove(updater);\n  }\n}\n\nfunction insertUpdaterIntoBatch(that, time, updater) {\n  if (updater.isDynamic) {\n    that._dynamicBatch.add(time, updater);\n    return;\n  }\n\n  if (updater.clampToGround && updater.fillEnabled) {\n    // Also checks for support\n    var classificationType = updater.classificationTypeProperty.getValue(time);\n    that._groundBatches[classificationType].add(time, updater);\n    return;\n  }\n\n  var shadows;\n  if (updater.fillEnabled) {\n    shadows = updater.shadowsProperty.getValue(time);\n  }\n\n  var multiplier = 0;\n  if (defined(updater.depthFailMaterialProperty)) {\n    multiplier =\n      updater.depthFailMaterialProperty instanceof ColorMaterialProperty\n        ? 1\n        : 2;\n  }\n\n  var index;\n  if (defined(shadows)) {\n    index = shadows + multiplier * ShadowMode.NUMBER_OF_SHADOW_MODES;\n  }\n\n  if (updater.fillEnabled) {\n    if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n      that._colorBatches[index].add(time, updater);\n    } else {\n      that._materialBatches[index].add(time, updater);\n    }\n  }\n}\n\n/**\n * A visualizer for polylines represented by {@link Primitive} instances.\n * @alias PolylineVisualizer\n * @constructor\n *\n * @param {Scene} scene The scene the primitives will be rendered in.\n * @param {EntityCollection} entityCollection The entityCollection to visualize.\n * @param {PrimitiveCollection} [primitives=scene.primitives] A collection to add primitives related to the entities\n * @param {PrimitiveCollection} [groundPrimitives=scene.groundPrimitives] A collection to add ground primitives related to the entities\n */\nfunction PolylineVisualizer(\n  scene,\n  entityCollection,\n  primitives,\n  groundPrimitives\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"scene\", scene);\n  Check.defined(\"entityCollection\", entityCollection);\n  //>>includeEnd('debug');\n\n  groundPrimitives = defaultValue(groundPrimitives, scene.groundPrimitives);\n  primitives = defaultValue(primitives, scene.primitives);\n\n  this._scene = scene;\n  this._primitives = primitives;\n  this._entityCollection = undefined;\n  this._addedObjects = new AssociativeArray();\n  this._removedObjects = new AssociativeArray();\n  this._changedObjects = new AssociativeArray();\n\n  var i;\n  var numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;\n  this._colorBatches = new Array(numberOfShadowModes * 3);\n  this._materialBatches = new Array(numberOfShadowModes * 3);\n\n  for (i = 0; i < numberOfShadowModes; ++i) {\n    this._colorBatches[i] = new StaticGeometryColorBatch(\n      primitives,\n      PolylineColorAppearance,\n      undefined,\n      false,\n      i\n    ); // no depth fail appearance\n    this._materialBatches[i] = new StaticGeometryPerMaterialBatch(\n      primitives,\n      PolylineMaterialAppearance,\n      undefined,\n      false,\n      i\n    );\n\n    this._colorBatches[i + numberOfShadowModes] = new StaticGeometryColorBatch(\n      primitives,\n      PolylineColorAppearance,\n      PolylineColorAppearance,\n      false,\n      i\n    ); //depth fail appearance variations\n    this._materialBatches[\n      i + numberOfShadowModes\n    ] = new StaticGeometryPerMaterialBatch(\n      primitives,\n      PolylineMaterialAppearance,\n      PolylineColorAppearance,\n      false,\n      i\n    );\n\n    this._colorBatches[\n      i + numberOfShadowModes * 2\n    ] = new StaticGeometryColorBatch(\n      primitives,\n      PolylineColorAppearance,\n      PolylineMaterialAppearance,\n      false,\n      i\n    );\n    this._materialBatches[\n      i + numberOfShadowModes * 2\n    ] = new StaticGeometryPerMaterialBatch(\n      primitives,\n      PolylineMaterialAppearance,\n      PolylineMaterialAppearance,\n      false,\n      i\n    );\n  }\n\n  this._dynamicBatch = new DynamicGeometryBatch(primitives, groundPrimitives);\n\n  var numberOfClassificationTypes =\n    ClassificationType.NUMBER_OF_CLASSIFICATION_TYPES;\n  this._groundBatches = new Array(numberOfClassificationTypes);\n\n  for (i = 0; i < numberOfClassificationTypes; ++i) {\n    this._groundBatches[i] = new StaticGroundPolylinePerMaterialBatch(\n      groundPrimitives,\n      i\n    );\n  }\n\n  this._batches = this._colorBatches.concat(\n    this._materialBatches,\n    this._dynamicBatch,\n    this._groundBatches\n  );\n\n  this._subscriptions = new AssociativeArray();\n  this._updaters = new AssociativeArray();\n\n  this._entityCollection = entityCollection;\n  entityCollection.collectionChanged.addEventListener(\n    PolylineVisualizer.prototype._onCollectionChanged,\n    this\n  );\n  this._onCollectionChanged(\n    entityCollection,\n    entityCollection.values,\n    emptyArray\n  );\n}\n\n/**\n * Updates all of the primitives created by this visualizer to match their\n * Entity counterpart at the given time.\n *\n * @param {JulianDate} time The time to update to.\n * @returns {Boolean} True if the visualizer successfully updated to the provided time,\n * false if the visualizer is waiting for asynchronous primitives to be created.\n */\nPolylineVisualizer.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  //>>includeEnd('debug');\n\n  var addedObjects = this._addedObjects;\n  var added = addedObjects.values;\n  var removedObjects = this._removedObjects;\n  var removed = removedObjects.values;\n  var changedObjects = this._changedObjects;\n  var changed = changedObjects.values;\n\n  var i;\n  var entity;\n  var id;\n  var updater;\n\n  for (i = changed.length - 1; i > -1; i--) {\n    entity = changed[i];\n    id = entity.id;\n    updater = this._updaters.get(id);\n\n    //If in a single update, an entity gets removed and a new instance\n    //re-added with the same id, the updater no longer tracks the\n    //correct entity, we need to both remove the old one and\n    //add the new one, which is done by pushing the entity\n    //onto the removed/added lists.\n    if (updater.entity === entity) {\n      removeUpdater(this, updater);\n      insertUpdaterIntoBatch(this, time, updater);\n    } else {\n      removed.push(entity);\n      added.push(entity);\n    }\n  }\n\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    id = entity.id;\n    updater = this._updaters.get(id);\n    removeUpdater(this, updater);\n    updater.destroy();\n    this._updaters.remove(id);\n    this._subscriptions.get(id)();\n    this._subscriptions.remove(id);\n  }\n\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    id = entity.id;\n    updater = new PolylineGeometryUpdater(entity, this._scene);\n    this._updaters.set(id, updater);\n    insertUpdaterIntoBatch(this, time, updater);\n    this._subscriptions.set(\n      id,\n      updater.geometryChanged.addEventListener(\n        PolylineVisualizer._onGeometryChanged,\n        this\n      )\n    );\n  }\n\n  addedObjects.removeAll();\n  removedObjects.removeAll();\n  changedObjects.removeAll();\n\n  var isUpdated = true;\n  var batches = this._batches;\n  var length = batches.length;\n  for (i = 0; i < length; i++) {\n    isUpdated = batches[i].update(time) && isUpdated;\n  }\n\n  return isUpdated;\n};\n\nvar getBoundingSphereArrayScratch = [];\nvar getBoundingSphereBoundingSphereScratch = new BoundingSphere();\n\n/**\n * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n * The bounding sphere is in the fixed frame of the scene's globe.\n *\n * @param {Entity} entity The entity whose bounding sphere to compute.\n * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n *                       BoundingSphereState.PENDING if the result is still being computed, or\n *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n * @private\n */\nPolylineVisualizer.prototype.getBoundingSphere = function (entity, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"entity\", entity);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  var boundingSpheres = getBoundingSphereArrayScratch;\n  var tmp = getBoundingSphereBoundingSphereScratch;\n\n  var count = 0;\n  var state = BoundingSphereState.DONE;\n  var batches = this._batches;\n  var batchesLength = batches.length;\n  var updater = this._updaters.get(entity.id);\n  for (var i = 0; i < batchesLength; i++) {\n    state = batches[i].getBoundingSphere(updater, tmp);\n    if (state === BoundingSphereState.PENDING) {\n      return BoundingSphereState.PENDING;\n    } else if (state === BoundingSphereState.DONE) {\n      boundingSpheres[count] = BoundingSphere.clone(\n        tmp,\n        boundingSpheres[count]\n      );\n      count++;\n    }\n  }\n\n  if (count === 0) {\n    return BoundingSphereState.FAILED;\n  }\n\n  boundingSpheres.length = count;\n  BoundingSphere.fromBoundingSpheres(boundingSpheres, result);\n  return BoundingSphereState.DONE;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n */\nPolylineVisualizer.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes and destroys all primitives created by this instance.\n */\nPolylineVisualizer.prototype.destroy = function () {\n  this._entityCollection.collectionChanged.removeEventListener(\n    PolylineVisualizer.prototype._onCollectionChanged,\n    this\n  );\n  this._addedObjects.removeAll();\n  this._removedObjects.removeAll();\n\n  var i;\n  var batches = this._batches;\n  var length = batches.length;\n  for (i = 0; i < length; i++) {\n    batches[i].removeAllPrimitives();\n  }\n\n  var subscriptions = this._subscriptions.values;\n  length = subscriptions.length;\n  for (i = 0; i < length; i++) {\n    subscriptions[i]();\n  }\n  this._subscriptions.removeAll();\n  return destroyObject(this);\n};\n\n/**\n * @private\n */\nPolylineVisualizer._onGeometryChanged = function (updater) {\n  var removedObjects = this._removedObjects;\n  var changedObjects = this._changedObjects;\n\n  var entity = updater.entity;\n  var id = entity.id;\n\n  if (!defined(removedObjects.get(id)) && !defined(changedObjects.get(id))) {\n    changedObjects.set(id, entity);\n  }\n};\n\n/**\n * @private\n */\nPolylineVisualizer.prototype._onCollectionChanged = function (\n  entityCollection,\n  added,\n  removed\n) {\n  var addedObjects = this._addedObjects;\n  var removedObjects = this._removedObjects;\n  var changedObjects = this._changedObjects;\n\n  var i;\n  var id;\n  var entity;\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    id = entity.id;\n    if (!addedObjects.remove(id)) {\n      removedObjects.set(id, entity);\n      changedObjects.remove(id);\n    }\n  }\n\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    id = entity.id;\n    if (removedObjects.remove(id)) {\n      changedObjects.set(id, entity);\n    } else {\n      addedObjects.set(id, entity);\n    }\n  }\n};\nexport default PolylineVisualizer;\n"]},"metadata":{},"sourceType":"module"}