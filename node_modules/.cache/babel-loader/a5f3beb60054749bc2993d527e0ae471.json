{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport Geometry from \"../Core/Geometry.js\";\nimport GeometryAttribute from \"../Core/GeometryAttribute.js\";\nimport GeometryAttributes from \"../Core/GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"../Core/GeometryOffsetAttribute.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Plane from \"../Core/Plane.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport subdivideArray from \"../Core/subdivideArray.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport when from \"../ThirdParty/when.js\";\nimport BatchTable from \"./BatchTable.js\";\nimport CullFace from \"./CullFace.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport PrimitivePipeline from \"./PrimitivePipeline.js\";\nimport PrimitiveState from \"./PrimitiveState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\n/**\n * A primitive represents geometry in the {@link Scene}.  The geometry can be from a single {@link GeometryInstance}\n * as shown in example 1 below, or from an array of instances, even if the geometry is from different\n * geometry types, e.g., an {@link RectangleGeometry} and an {@link EllipsoidGeometry} as shown in Code Example 2.\n * <p>\n * A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including\n * {@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,\n * and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix\n * and match most of them and add a new geometry or appearance independently of each other.\n * </p>\n * <p>\n * Combining multiple instances into one primitive is called batching, and significantly improves performance for static data.\n * Instances can be individually picked; {@link Scene#pick} returns their {@link GeometryInstance#id}.  Using\n * per-instance appearances like {@link PerInstanceColorAppearance}, each instance can also have a unique color.\n * </p>\n * <p>\n * {@link Geometry} can either be created and batched on a web worker or the main thread. The first two examples\n * show geometry that will be created on a web worker by using the descriptions of the geometry. The third example\n * shows how to create the geometry on the main thread by explicitly calling the <code>createGeometry</code> method.\n * </p>\n *\n * @alias Primitive\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {GeometryInstance[]|GeometryInstance} [options.geometryInstances] The geometry instances - or a single geometry instance - to render.\n * @param {Appearance} [options.appearance] The appearance used to render the primitive.\n * @param {Appearance} [options.depthFailAppearance] The appearance used to shade this primitive when it fails the depth test.\n * @param {Boolean} [options.show=true] Determines if this primitive will be shown.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates.\n * @param {Boolean} [options.vertexCacheOptimize=false] When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n * @param {Boolean} [options.interleave=false] When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.\n * @param {Boolean} [options.compressVertices=true] When <code>true</code>, the geometry vertices are compressed, which will save memory.\n * @param {Boolean} [options.releaseGeometryInstances=true] When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n * @param {Boolean} [options.cull=true] When <code>true</code>, the renderer frustum culls and horizon culls the primitive's commands based on their bounding volume.  Set this to <code>false</code> for a small performance gain if you are manually culling the primitive.\n * @param {Boolean} [options.asynchronous=true] Determines if the primitive will be created asynchronously or block until ready.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {ShadowMode} [options.shadows=ShadowMode.DISABLED] Determines whether this primitive casts or receives shadows from light sources.\n *\n * @example\n * // 1. Draw a translucent ellipse on the surface with a checkerboard pattern\n * var instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.EllipseGeometry({\n *       center : Cesium.Cartesian3.fromDegrees(-100.0, 20.0),\n *       semiMinorAxis : 500000.0,\n *       semiMajorAxis : 1000000.0,\n *       rotation : Cesium.Math.PI_OVER_FOUR,\n *       vertexFormat : Cesium.VertexFormat.POSITION_AND_ST\n *   }),\n *   id : 'object returned when this instance is picked and to get/set per-instance attributes'\n * });\n * scene.primitives.add(new Cesium.Primitive({\n *   geometryInstances : instance,\n *   appearance : new Cesium.EllipsoidSurfaceAppearance({\n *     material : Cesium.Material.fromType('Checkerboard')\n *   })\n * }));\n *\n * @example\n * // 2. Draw different instances each with a unique color\n * var rectangleInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0),\n *     vertexFormat : Cesium.PerInstanceColorAppearance.VERTEX_FORMAT\n *   }),\n *   id : 'rectangle',\n *   attributes : {\n *     color : new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5)\n *   }\n * });\n * var ellipsoidInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.EllipsoidGeometry({\n *     radii : new Cesium.Cartesian3(500000.0, 500000.0, 1000000.0),\n *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL\n *   }),\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(-95.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 500000.0), new Cesium.Matrix4()),\n *   id : 'ellipsoid',\n *   attributes : {\n *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)\n *   }\n * });\n * scene.primitives.add(new Cesium.Primitive({\n *   geometryInstances : [rectangleInstance, ellipsoidInstance],\n *   appearance : new Cesium.PerInstanceColorAppearance()\n * }));\n *\n * @example\n * // 3. Create the geometry on the main thread.\n * scene.primitives.add(new Cesium.Primitive({\n *   geometryInstances : new Cesium.GeometryInstance({\n *       geometry : Cesium.EllipsoidGeometry.createGeometry(new Cesium.EllipsoidGeometry({\n *         radii : new Cesium.Cartesian3(500000.0, 500000.0, 1000000.0),\n *         vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL\n *       })),\n *       modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *         Cesium.Cartesian3.fromDegrees(-95.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 500000.0), new Cesium.Matrix4()),\n *       id : 'ellipsoid',\n *       attributes : {\n *         color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)\n *       }\n *   }),\n *   appearance : new Cesium.PerInstanceColorAppearance()\n * }));\n *\n * @see GeometryInstance\n * @see Appearance\n * @see ClassificationPrimitive\n * @see GroundPrimitive\n */\n\nfunction Primitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  /**\n   * The geometry instances rendered with this primitive.  This may\n   * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>\n   * is <code>true</code> when the primitive is constructed.\n   * <p>\n   * Changing this property after the primitive is rendered has no effect.\n   * </p>\n   *\n   * @readonly\n   * @type GeometryInstance[]|GeometryInstance\n   *\n   * @default undefined\n   */\n\n  this.geometryInstances = options.geometryInstances;\n  /**\n   * The {@link Appearance} used to shade this primitive. Each geometry\n   * instance is shaded with the same appearance.  Some appearances, like\n   * {@link PerInstanceColorAppearance} allow giving each instance unique\n   * properties.\n   *\n   * @type Appearance\n   *\n   * @default undefined\n   */\n\n  this.appearance = options.appearance;\n  this._appearance = undefined;\n  this._material = undefined;\n  /**\n   * The {@link Appearance} used to shade this primitive when it fails the depth test. Each geometry\n   * instance is shaded with the same appearance.  Some appearances, like\n   * {@link PerInstanceColorAppearance} allow giving each instance unique\n   * properties.\n   *\n   * <p>\n   * When using an appearance that requires a color attribute, like PerInstanceColorAppearance,\n   * add a depthFailColor per-instance attribute instead.\n   * </p>\n   *\n   * <p>\n   * Requires the EXT_frag_depth WebGL extension to render properly. If the extension is not supported,\n   * there may be artifacts.\n   * </p>\n   * @type Appearance\n   *\n   * @default undefined\n   */\n\n  this.depthFailAppearance = options.depthFailAppearance;\n  this._depthFailAppearance = undefined;\n  this._depthFailMaterial = undefined;\n  /**\n   * The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates.\n   * When this is the identity matrix, the primitive is drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * <p>\n   * This property is only supported in 3D mode.\n   * </p>\n   *\n   * @type Matrix4\n   *\n   * @default Matrix4.IDENTITY\n   *\n   * @example\n   * var origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n   * p.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);\n   */\n\n  this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));\n  this._modelMatrix = new Matrix4();\n  /**\n   * Determines if the primitive will be shown.  This affects all geometry\n   * instances in the primitive.\n   *\n   * @type Boolean\n   *\n   * @default true\n   */\n\n  this.show = defaultValue(options.show, true);\n  this._vertexCacheOptimize = defaultValue(options.vertexCacheOptimize, false);\n  this._interleave = defaultValue(options.interleave, false);\n  this._releaseGeometryInstances = defaultValue(options.releaseGeometryInstances, true);\n  this._allowPicking = defaultValue(options.allowPicking, true);\n  this._asynchronous = defaultValue(options.asynchronous, true);\n  this._compressVertices = defaultValue(options.compressVertices, true);\n  /**\n   * When <code>true</code>, the renderer frustum culls and horizon culls the primitive's commands\n   * based on their bounding volume.  Set this to <code>false</code> for a small performance gain\n   * if you are manually culling the primitive.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n\n  this.cull = defaultValue(options.cull, true);\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n\n  this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);\n  /**\n   * @private\n   */\n\n  this.rtcCenter = options.rtcCenter; //>>includeStart('debug', pragmas.debug);\n\n  if (defined(this.rtcCenter) && (!defined(this.geometryInstances) || Array.isArray(this.geometryInstances) && this.geometryInstances.length !== 1)) {\n    throw new DeveloperError(\"Relative-to-center rendering only supports one geometry instance.\");\n  } //>>includeEnd('debug');\n\n  /**\n   * Determines whether this primitive casts or receives shadows from light sources.\n   *\n   * @type {ShadowMode}\n   *\n   * @default ShadowMode.DISABLED\n   */\n\n\n  this.shadows = defaultValue(options.shadows, ShadowMode.DISABLED);\n  this._translucent = undefined;\n  this._state = PrimitiveState.READY;\n  this._geometries = [];\n  this._error = undefined;\n  this._numberOfInstances = 0;\n  this._boundingSpheres = [];\n  this._boundingSphereWC = [];\n  this._boundingSphereCV = [];\n  this._boundingSphere2D = [];\n  this._boundingSphereMorph = [];\n  this._perInstanceAttributeCache = [];\n  this._instanceIds = [];\n  this._lastPerInstanceAttributeIndex = 0;\n  this._va = [];\n  this._attributeLocations = undefined;\n  this._primitiveType = undefined;\n  this._frontFaceRS = undefined;\n  this._backFaceRS = undefined;\n  this._sp = undefined;\n  this._depthFailAppearance = undefined;\n  this._spDepthFail = undefined;\n  this._frontFaceDepthFailRS = undefined;\n  this._backFaceDepthFailRS = undefined;\n  this._pickIds = [];\n  this._colorCommands = [];\n  this._pickCommands = [];\n  this._createBoundingVolumeFunction = options._createBoundingVolumeFunction;\n  this._createRenderStatesFunction = options._createRenderStatesFunction;\n  this._createShaderProgramFunction = options._createShaderProgramFunction;\n  this._createCommandsFunction = options._createCommandsFunction;\n  this._updateAndQueueCommandsFunction = options._updateAndQueueCommandsFunction;\n  this._createPickOffsets = options._createPickOffsets;\n  this._pickOffsets = undefined;\n  this._createGeometryResults = undefined;\n  this._ready = false;\n  this._readyPromise = when.defer();\n  this._batchTable = undefined;\n  this._batchTableAttributeIndices = undefined;\n  this._offsetInstanceExtend = undefined;\n  this._batchTableOffsetAttribute2DIndex = undefined;\n  this._batchTableOffsetsUpdated = false;\n  this._instanceBoundingSpheres = undefined;\n  this._instanceBoundingSpheresCV = undefined;\n  this._tempBoundingSpheres = undefined;\n  this._recomputeBoundingSpheres = false;\n  this._batchTableBoundingSpheresUpdated = false;\n  this._batchTableBoundingSphereAttributeIndices = undefined;\n}\n\nObject.defineProperties(Primitive.prototype, {\n  /**\n   * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  vertexCacheOptimize: {\n    get: function () {\n      return this._vertexCacheOptimize;\n    }\n  },\n\n  /**\n   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  interleave: {\n    get: function () {\n      return this._interleave;\n    }\n  },\n\n  /**\n   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  releaseGeometryInstances: {\n    get: function () {\n      return this._releaseGeometryInstances;\n    }\n  },\n\n  /**\n   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.         *\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._allowPicking;\n    }\n  },\n\n  /**\n   * Determines if the geometry instances will be created and batched on a web worker.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._asynchronous;\n    }\n  },\n\n  /**\n   * When <code>true</code>, geometry vertices are compressed, which will save memory.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  compressVertices: {\n    get: function () {\n      return this._compressVertices;\n    }\n  },\n\n  /**\n   * Determines if the primitive is complete and ready to render.  If this property is\n   * true, the primitive will be rendered the next time that {@link Primitive#update}\n   * is called.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n\n  /**\n   * Gets a promise that resolves when the primitive is ready to render.\n   * @memberof Primitive.prototype\n   * @type {Promise.<Primitive>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    }\n  }\n});\n\nfunction getCommonPerInstanceAttributeNames(instances) {\n  var length = instances.length;\n  var attributesInAllInstances = [];\n  var attributes0 = instances[0].attributes;\n  var name;\n\n  for (name in attributes0) {\n    if (attributes0.hasOwnProperty(name) && defined(attributes0[name])) {\n      var attribute = attributes0[name];\n      var inAllInstances = true; // Does this same attribute exist in all instances?\n\n      for (var i = 1; i < length; ++i) {\n        var otherAttribute = instances[i].attributes[name];\n\n        if (!defined(otherAttribute) || attribute.componentDatatype !== otherAttribute.componentDatatype || attribute.componentsPerAttribute !== otherAttribute.componentsPerAttribute || attribute.normalize !== otherAttribute.normalize) {\n          inAllInstances = false;\n          break;\n        }\n      }\n\n      if (inAllInstances) {\n        attributesInAllInstances.push(name);\n      }\n    }\n  }\n\n  return attributesInAllInstances;\n}\n\nvar scratchGetAttributeCartesian2 = new Cartesian2();\nvar scratchGetAttributeCartesian3 = new Cartesian3();\nvar scratchGetAttributeCartesian4 = new Cartesian4();\n\nfunction getAttributeValue(value) {\n  var componentsPerAttribute = value.length;\n\n  if (componentsPerAttribute === 1) {\n    return value[0];\n  } else if (componentsPerAttribute === 2) {\n    return Cartesian2.unpack(value, 0, scratchGetAttributeCartesian2);\n  } else if (componentsPerAttribute === 3) {\n    return Cartesian3.unpack(value, 0, scratchGetAttributeCartesian3);\n  } else if (componentsPerAttribute === 4) {\n    return Cartesian4.unpack(value, 0, scratchGetAttributeCartesian4);\n  }\n}\n\nfunction createBatchTable(primitive, context) {\n  var geometryInstances = primitive.geometryInstances;\n  var instances = Array.isArray(geometryInstances) ? geometryInstances : [geometryInstances];\n  var numberOfInstances = instances.length;\n\n  if (numberOfInstances === 0) {\n    return;\n  }\n\n  var names = getCommonPerInstanceAttributeNames(instances);\n  var length = names.length;\n  var attributes = [];\n  var attributeIndices = {};\n  var boundingSphereAttributeIndices = {};\n  var offset2DIndex;\n  var firstInstance = instances[0];\n  var instanceAttributes = firstInstance.attributes;\n  var i;\n  var name;\n  var attribute;\n\n  for (i = 0; i < length; ++i) {\n    name = names[i];\n    attribute = instanceAttributes[name];\n    attributeIndices[name] = i;\n    attributes.push({\n      functionName: \"czm_batchTable_\" + name,\n      componentDatatype: attribute.componentDatatype,\n      componentsPerAttribute: attribute.componentsPerAttribute,\n      normalize: attribute.normalize\n    });\n  }\n\n  if (names.indexOf(\"distanceDisplayCondition\") !== -1) {\n    attributes.push({\n      functionName: \"czm_batchTable_boundingSphereCenter3DHigh\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3\n    }, {\n      functionName: \"czm_batchTable_boundingSphereCenter3DLow\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3\n    }, {\n      functionName: \"czm_batchTable_boundingSphereCenter2DHigh\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3\n    }, {\n      functionName: \"czm_batchTable_boundingSphereCenter2DLow\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3\n    }, {\n      functionName: \"czm_batchTable_boundingSphereRadius\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 1\n    });\n    boundingSphereAttributeIndices.center3DHigh = attributes.length - 5;\n    boundingSphereAttributeIndices.center3DLow = attributes.length - 4;\n    boundingSphereAttributeIndices.center2DHigh = attributes.length - 3;\n    boundingSphereAttributeIndices.center2DLow = attributes.length - 2;\n    boundingSphereAttributeIndices.radius = attributes.length - 1;\n  }\n\n  if (names.indexOf(\"offset\") !== -1) {\n    attributes.push({\n      functionName: \"czm_batchTable_offset2D\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3\n    });\n    offset2DIndex = attributes.length - 1;\n  }\n\n  attributes.push({\n    functionName: \"czm_batchTable_pickColor\",\n    componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n    componentsPerAttribute: 4,\n    normalize: true\n  });\n  var attributesLength = attributes.length;\n  var batchTable = new BatchTable(context, attributes, numberOfInstances);\n\n  for (i = 0; i < numberOfInstances; ++i) {\n    var instance = instances[i];\n    instanceAttributes = instance.attributes;\n\n    for (var j = 0; j < length; ++j) {\n      name = names[j];\n      attribute = instanceAttributes[name];\n      var value = getAttributeValue(attribute.value);\n      var attributeIndex = attributeIndices[name];\n      batchTable.setBatchedAttribute(i, attributeIndex, value);\n    }\n\n    var pickObject = {\n      primitive: defaultValue(instance.pickPrimitive, primitive)\n    };\n\n    if (defined(instance.id)) {\n      pickObject.id = instance.id;\n    }\n\n    var pickId = context.createPickId(pickObject);\n\n    primitive._pickIds.push(pickId);\n\n    var pickColor = pickId.color;\n    var color = scratchGetAttributeCartesian4;\n    color.x = Color.floatToByte(pickColor.red);\n    color.y = Color.floatToByte(pickColor.green);\n    color.z = Color.floatToByte(pickColor.blue);\n    color.w = Color.floatToByte(pickColor.alpha);\n    batchTable.setBatchedAttribute(i, attributesLength - 1, color);\n  }\n\n  primitive._batchTable = batchTable;\n  primitive._batchTableAttributeIndices = attributeIndices;\n  primitive._batchTableBoundingSphereAttributeIndices = boundingSphereAttributeIndices;\n  primitive._batchTableOffsetAttribute2DIndex = offset2DIndex;\n}\n\nfunction cloneAttribute(attribute) {\n  var clonedValues;\n\n  if (Array.isArray(attribute.values)) {\n    clonedValues = attribute.values.slice(0);\n  } else {\n    clonedValues = new attribute.values.constructor(attribute.values);\n  }\n\n  return new GeometryAttribute({\n    componentDatatype: attribute.componentDatatype,\n    componentsPerAttribute: attribute.componentsPerAttribute,\n    normalize: attribute.normalize,\n    values: clonedValues\n  });\n}\n\nfunction cloneGeometry(geometry) {\n  var attributes = geometry.attributes;\n  var newAttributes = new GeometryAttributes();\n\n  for (var property in attributes) {\n    if (attributes.hasOwnProperty(property) && defined(attributes[property])) {\n      newAttributes[property] = cloneAttribute(attributes[property]);\n    }\n  }\n\n  var indices;\n\n  if (defined(geometry.indices)) {\n    var sourceValues = geometry.indices;\n\n    if (Array.isArray(sourceValues)) {\n      indices = sourceValues.slice(0);\n    } else {\n      indices = new sourceValues.constructor(sourceValues);\n    }\n  }\n\n  return new Geometry({\n    attributes: newAttributes,\n    indices: indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: BoundingSphere.clone(geometry.boundingSphere)\n  });\n}\n\nfunction cloneInstance(instance, geometry) {\n  return {\n    geometry: geometry,\n    attributes: instance.attributes,\n    modelMatrix: Matrix4.clone(instance.modelMatrix),\n    pickPrimitive: instance.pickPrimitive,\n    id: instance.id\n  };\n}\n\nvar positionRegex = /attribute\\s+vec(?:3|4)\\s+(.*)3DHigh;/g;\n\nPrimitive._modifyShaderPosition = function (primitive, vertexShaderSource, scene3DOnly) {\n  var match;\n  var forwardDecl = \"\";\n  var attributes = \"\";\n  var computeFunctions = \"\";\n\n  while ((match = positionRegex.exec(vertexShaderSource)) !== null) {\n    var name = match[1];\n    var functionName = \"vec4 czm_compute\" + name[0].toUpperCase() + name.substr(1) + \"()\"; // Don't forward-declare czm_computePosition because computePosition.glsl already does.\n\n    if (functionName !== \"vec4 czm_computePosition()\") {\n      forwardDecl += functionName + \";\\n\";\n    }\n\n    if (!defined(primitive.rtcCenter)) {\n      // Use GPU RTE\n      if (!scene3DOnly) {\n        attributes += \"attribute vec3 \" + name + \"2DHigh;\\n\" + \"attribute vec3 \" + name + \"2DLow;\\n\";\n        computeFunctions += functionName + \"\\n\" + \"{\\n\" + \"    vec4 p;\\n\" + \"    if (czm_morphTime == 1.0)\\n\" + \"    {\\n\" + \"        p = czm_translateRelativeToEye(\" + name + \"3DHigh, \" + name + \"3DLow);\\n\" + \"    }\\n\" + \"    else if (czm_morphTime == 0.0)\\n\" + \"    {\\n\" + \"        p = czm_translateRelativeToEye(\" + name + \"2DHigh.zxy, \" + name + \"2DLow.zxy);\\n\" + \"    }\\n\" + \"    else\\n\" + \"    {\\n\" + \"        p = czm_columbusViewMorph(\\n\" + \"                czm_translateRelativeToEye(\" + name + \"2DHigh.zxy, \" + name + \"2DLow.zxy),\\n\" + \"                czm_translateRelativeToEye(\" + name + \"3DHigh, \" + name + \"3DLow),\\n\" + \"                czm_morphTime);\\n\" + \"    }\\n\" + \"    return p;\\n\" + \"}\\n\\n\";\n      } else {\n        computeFunctions += functionName + \"\\n\" + \"{\\n\" + \"    return czm_translateRelativeToEye(\" + name + \"3DHigh, \" + name + \"3DLow);\\n\" + \"}\\n\\n\";\n      }\n    } else {\n      // Use RTC\n      vertexShaderSource = vertexShaderSource.replace(/attribute\\s+vec(?:3|4)\\s+position3DHigh;/g, \"\");\n      vertexShaderSource = vertexShaderSource.replace(/attribute\\s+vec(?:3|4)\\s+position3DLow;/g, \"\");\n      forwardDecl += \"uniform mat4 u_modifiedModelView;\\n\";\n      attributes += \"attribute vec4 position;\\n\";\n      computeFunctions += functionName + \"\\n\" + \"{\\n\" + \"    return u_modifiedModelView * position;\\n\" + \"}\\n\\n\";\n      vertexShaderSource = vertexShaderSource.replace(/czm_modelViewRelativeToEye\\s+\\*\\s+/g, \"\");\n      vertexShaderSource = vertexShaderSource.replace(/czm_modelViewProjectionRelativeToEye/g, \"czm_projection\");\n    }\n  }\n\n  return [forwardDecl, attributes, vertexShaderSource, computeFunctions].join(\"\\n\");\n};\n\nPrimitive._appendShowToShader = function (primitive, vertexShaderSource) {\n  if (!defined(primitive._batchTableAttributeIndices.show)) {\n    return vertexShaderSource;\n  }\n\n  var renamedVS = ShaderSource.replaceMain(vertexShaderSource, \"czm_non_show_main\");\n  var showMain = \"void main() \\n\" + \"{ \\n\" + \"    czm_non_show_main(); \\n\" + \"    gl_Position *= czm_batchTable_show(batchId); \\n\" + \"}\";\n  return renamedVS + \"\\n\" + showMain;\n};\n\nPrimitive._updateColorAttribute = function (primitive, vertexShaderSource, isDepthFail) {\n  // some appearances have a color attribute for per vertex color.\n  // only remove if color is a per instance attribute.\n  if (!defined(primitive._batchTableAttributeIndices.color) && !defined(primitive._batchTableAttributeIndices.depthFailColor)) {\n    return vertexShaderSource;\n  }\n\n  if (vertexShaderSource.search(/attribute\\s+vec4\\s+color;/g) === -1) {\n    return vertexShaderSource;\n  } //>>includeStart('debug', pragmas.debug);\n\n\n  if (isDepthFail && !defined(primitive._batchTableAttributeIndices.depthFailColor)) {\n    throw new DeveloperError(\"A depthFailColor per-instance attribute is required when using a depth fail appearance that uses a color attribute.\");\n  } //>>includeEnd('debug');\n\n\n  var modifiedVS = vertexShaderSource;\n  modifiedVS = modifiedVS.replace(/attribute\\s+vec4\\s+color;/g, \"\");\n\n  if (!isDepthFail) {\n    modifiedVS = modifiedVS.replace(/(\\b)color(\\b)/g, \"$1czm_batchTable_color(batchId)$2\");\n  } else {\n    modifiedVS = modifiedVS.replace(/(\\b)color(\\b)/g, \"$1czm_batchTable_depthFailColor(batchId)$2\");\n  }\n\n  return modifiedVS;\n};\n\nfunction appendPickToVertexShader(source) {\n  var renamedVS = ShaderSource.replaceMain(source, \"czm_non_pick_main\");\n  var pickMain = \"varying vec4 v_pickColor; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    czm_non_pick_main(); \\n\" + \"    v_pickColor = czm_batchTable_pickColor(batchId); \\n\" + \"}\";\n  return renamedVS + \"\\n\" + pickMain;\n}\n\nfunction appendPickToFragmentShader(source) {\n  return \"varying vec4 v_pickColor;\\n\" + source;\n}\n\nPrimitive._updatePickColorAttribute = function (source) {\n  var vsPick = source.replace(/attribute\\s+vec4\\s+pickColor;/g, \"\");\n  vsPick = vsPick.replace(/(\\b)pickColor(\\b)/g, \"$1czm_batchTable_pickColor(batchId)$2\");\n  return vsPick;\n};\n\nPrimitive._appendOffsetToShader = function (primitive, vertexShaderSource) {\n  if (!defined(primitive._batchTableAttributeIndices.offset)) {\n    return vertexShaderSource;\n  }\n\n  var attr = \"attribute float batchId;\\n\";\n  attr += \"attribute float applyOffset;\";\n  var modifiedShader = vertexShaderSource.replace(/attribute\\s+float\\s+batchId;/g, attr);\n  var str = \"vec4 $1 = czm_computePosition();\\n\";\n  str += \"    if (czm_sceneMode == czm_sceneMode3D)\\n\";\n  str += \"    {\\n\";\n  str += \"        $1 = $1 + vec4(czm_batchTable_offset(batchId) * applyOffset, 0.0);\";\n  str += \"    }\\n\";\n  str += \"    else\\n\";\n  str += \"    {\\n\";\n  str += \"        $1 = $1 + vec4(czm_batchTable_offset2D(batchId) * applyOffset, 0.0);\";\n  str += \"    }\\n\";\n  modifiedShader = modifiedShader.replace(/vec4\\s+([A-Za-z0-9_]+)\\s+=\\s+czm_computePosition\\(\\);/g, str);\n  return modifiedShader;\n};\n\nPrimitive._appendDistanceDisplayConditionToShader = function (primitive, vertexShaderSource, scene3DOnly) {\n  if (!defined(primitive._batchTableAttributeIndices.distanceDisplayCondition)) {\n    return vertexShaderSource;\n  }\n\n  var renamedVS = ShaderSource.replaceMain(vertexShaderSource, \"czm_non_distanceDisplayCondition_main\");\n  var distanceDisplayConditionMain = \"void main() \\n\" + \"{ \\n\" + \"    czm_non_distanceDisplayCondition_main(); \\n\" + \"    vec2 distanceDisplayCondition = czm_batchTable_distanceDisplayCondition(batchId);\\n\" + \"    vec3 boundingSphereCenter3DHigh = czm_batchTable_boundingSphereCenter3DHigh(batchId);\\n\" + \"    vec3 boundingSphereCenter3DLow = czm_batchTable_boundingSphereCenter3DLow(batchId);\\n\" + \"    float boundingSphereRadius = czm_batchTable_boundingSphereRadius(batchId);\\n\";\n\n  if (!scene3DOnly) {\n    distanceDisplayConditionMain += \"    vec3 boundingSphereCenter2DHigh = czm_batchTable_boundingSphereCenter2DHigh(batchId);\\n\" + \"    vec3 boundingSphereCenter2DLow = czm_batchTable_boundingSphereCenter2DLow(batchId);\\n\" + \"    vec4 centerRTE;\\n\" + \"    if (czm_morphTime == 1.0)\\n\" + \"    {\\n\" + \"        centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);\\n\" + \"    }\\n\" + \"    else if (czm_morphTime == 0.0)\\n\" + \"    {\\n\" + \"        centerRTE = czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy);\\n\" + \"    }\\n\" + \"    else\\n\" + \"    {\\n\" + \"        centerRTE = czm_columbusViewMorph(\\n\" + \"                czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy),\\n\" + \"                czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow),\\n\" + \"                czm_morphTime);\\n\" + \"    }\\n\";\n  } else {\n    distanceDisplayConditionMain += \"    vec4 centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);\\n\";\n  }\n\n  distanceDisplayConditionMain += \"    float radiusSq = boundingSphereRadius * boundingSphereRadius; \\n\" + \"    float distanceSq; \\n\" + \"    if (czm_sceneMode == czm_sceneMode2D) \\n\" + \"    { \\n\" + \"        distanceSq = czm_eyeHeight2D.y - radiusSq; \\n\" + \"    } \\n\" + \"    else \\n\" + \"    { \\n\" + \"        distanceSq = dot(centerRTE.xyz, centerRTE.xyz) - radiusSq; \\n\" + \"    } \\n\" + \"    distanceSq = max(distanceSq, 0.0); \\n\" + \"    float nearSq = distanceDisplayCondition.x * distanceDisplayCondition.x; \\n\" + \"    float farSq = distanceDisplayCondition.y * distanceDisplayCondition.y; \\n\" + \"    float show = (distanceSq >= nearSq && distanceSq <= farSq) ? 1.0 : 0.0; \\n\" + \"    gl_Position *= show; \\n\" + \"}\";\n  return renamedVS + \"\\n\" + distanceDisplayConditionMain;\n};\n\nfunction modifyForEncodedNormals(primitive, vertexShaderSource) {\n  if (!primitive.compressVertices) {\n    return vertexShaderSource;\n  }\n\n  var containsNormal = vertexShaderSource.search(/attribute\\s+vec3\\s+normal;/g) !== -1;\n  var containsSt = vertexShaderSource.search(/attribute\\s+vec2\\s+st;/g) !== -1;\n\n  if (!containsNormal && !containsSt) {\n    return vertexShaderSource;\n  }\n\n  var containsTangent = vertexShaderSource.search(/attribute\\s+vec3\\s+tangent;/g) !== -1;\n  var containsBitangent = vertexShaderSource.search(/attribute\\s+vec3\\s+bitangent;/g) !== -1;\n  var numComponents = containsSt && containsNormal ? 2.0 : 1.0;\n  numComponents += containsTangent || containsBitangent ? 1 : 0;\n  var type = numComponents > 1 ? \"vec\" + numComponents : \"float\";\n  var attributeName = \"compressedAttributes\";\n  var attributeDecl = \"attribute \" + type + \" \" + attributeName + \";\";\n  var globalDecl = \"\";\n  var decode = \"\";\n\n  if (containsSt) {\n    globalDecl += \"vec2 st;\\n\";\n    var stComponent = numComponents > 1 ? attributeName + \".x\" : attributeName;\n    decode += \"    st = czm_decompressTextureCoordinates(\" + stComponent + \");\\n\";\n  }\n\n  if (containsNormal && containsTangent && containsBitangent) {\n    globalDecl += \"vec3 normal;\\n\" + \"vec3 tangent;\\n\" + \"vec3 bitangent;\\n\";\n    decode += \"    czm_octDecode(\" + attributeName + \".\" + (containsSt ? \"yz\" : \"xy\") + \", normal, tangent, bitangent);\\n\";\n  } else {\n    if (containsNormal) {\n      globalDecl += \"vec3 normal;\\n\";\n      decode += \"    normal = czm_octDecode(\" + attributeName + (numComponents > 1 ? \".\" + (containsSt ? \"y\" : \"x\") : \"\") + \");\\n\";\n    }\n\n    if (containsTangent) {\n      globalDecl += \"vec3 tangent;\\n\";\n      decode += \"    tangent = czm_octDecode(\" + attributeName + \".\" + (containsSt && containsNormal ? \"z\" : \"y\") + \");\\n\";\n    }\n\n    if (containsBitangent) {\n      globalDecl += \"vec3 bitangent;\\n\";\n      decode += \"    bitangent = czm_octDecode(\" + attributeName + \".\" + (containsSt && containsNormal ? \"z\" : \"y\") + \");\\n\";\n    }\n  }\n\n  var modifiedVS = vertexShaderSource;\n  modifiedVS = modifiedVS.replace(/attribute\\s+vec3\\s+normal;/g, \"\");\n  modifiedVS = modifiedVS.replace(/attribute\\s+vec2\\s+st;/g, \"\");\n  modifiedVS = modifiedVS.replace(/attribute\\s+vec3\\s+tangent;/g, \"\");\n  modifiedVS = modifiedVS.replace(/attribute\\s+vec3\\s+bitangent;/g, \"\");\n  modifiedVS = ShaderSource.replaceMain(modifiedVS, \"czm_non_compressed_main\");\n  var compressedMain = \"void main() \\n\" + \"{ \\n\" + decode + \"    czm_non_compressed_main(); \\n\" + \"}\";\n  return [attributeDecl, globalDecl, modifiedVS, compressedMain].join(\"\\n\");\n}\n\nfunction depthClampVS(vertexShaderSource) {\n  var modifiedVS = ShaderSource.replaceMain(vertexShaderSource, \"czm_non_depth_clamp_main\"); // The varying should be surround by #ifdef GL_EXT_frag_depth as an optimization.\n  // It is not to workaround an issue with Edge:\n  //     https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12120362/\n\n  modifiedVS += \"varying float v_WindowZ;\\n\" + \"void main() {\\n\" + \"    czm_non_depth_clamp_main();\\n\" + \"    vec4 position = gl_Position;\\n\" + \"    v_WindowZ = (0.5 * (position.z / position.w) + 0.5) * position.w;\\n\" + \"    position.z = min(position.z, position.w);\\n\" + \"    gl_Position = position;\\n\" + \"}\\n\";\n  return modifiedVS;\n}\n\nfunction depthClampFS(fragmentShaderSource) {\n  var modifiedFS = ShaderSource.replaceMain(fragmentShaderSource, \"czm_non_depth_clamp_main\");\n  modifiedFS += \"varying float v_WindowZ;\\n\" + \"void main() {\\n\" + \"    czm_non_depth_clamp_main();\\n\" + \"#if defined(GL_EXT_frag_depth)\\n\" + \"    #if defined(LOG_DEPTH)\\n\" + \"        czm_writeLogDepth();\\n\" + \"    #else\\n\" + \"        gl_FragDepthEXT = min(v_WindowZ * gl_FragCoord.w, 1.0);\\n\" + \"    #endif\\n\" + \"#endif\\n\" + \"}\\n\";\n  modifiedFS = \"#ifdef GL_EXT_frag_depth\\n\" + \"#extension GL_EXT_frag_depth : enable\\n\" + \"#endif\\n\" + modifiedFS;\n  return modifiedFS;\n}\n\nfunction validateShaderMatching(shaderProgram, attributeLocations) {\n  // For a VAO and shader program to be compatible, the VAO must have\n  // all active attribute in the shader program.  The VAO may have\n  // extra attributes with the only concern being a potential\n  // performance hit due to extra memory bandwidth and cache pollution.\n  // The shader source could have extra attributes that are not used,\n  // but there is no guarantee they will be optimized out.\n  //\n  // Here, we validate that the VAO has all attributes required\n  // to match the shader program.\n  var shaderAttributes = shaderProgram.vertexAttributes; //>>includeStart('debug', pragmas.debug);\n\n  for (var name in shaderAttributes) {\n    if (shaderAttributes.hasOwnProperty(name)) {\n      if (!defined(attributeLocations[name])) {\n        throw new DeveloperError(\"Appearance/Geometry mismatch.  The appearance requires vertex shader attribute input '\" + name + \"', which was not computed as part of the Geometry.  Use the appearance's vertexFormat property when constructing the geometry.\");\n      }\n    }\n  } //>>includeEnd('debug');\n\n}\n\nfunction getUniformFunction(uniforms, name) {\n  return function () {\n    return uniforms[name];\n  };\n}\n\nvar numberOfCreationWorkers = Math.max(FeatureDetection.hardwareConcurrency - 1, 1);\nvar createGeometryTaskProcessors;\nvar combineGeometryTaskProcessor = new TaskProcessor(\"combineGeometry\", Number.POSITIVE_INFINITY);\n\nfunction loadAsynchronous(primitive, frameState) {\n  var instances;\n  var geometry;\n  var i;\n  var j;\n  var instanceIds = primitive._instanceIds;\n\n  if (primitive._state === PrimitiveState.READY) {\n    instances = Array.isArray(primitive.geometryInstances) ? primitive.geometryInstances : [primitive.geometryInstances];\n    var length = primitive._numberOfInstances = instances.length;\n    var promises = [];\n    var subTasks = [];\n\n    for (i = 0; i < length; ++i) {\n      geometry = instances[i].geometry;\n      instanceIds.push(instances[i].id); //>>includeStart('debug', pragmas.debug);\n\n      if (!defined(geometry._workerName)) {\n        throw new DeveloperError(\"_workerName must be defined for asynchronous geometry.\");\n      } //>>includeEnd('debug');\n\n\n      subTasks.push({\n        moduleName: geometry._workerName,\n        geometry: geometry\n      });\n    }\n\n    if (!defined(createGeometryTaskProcessors)) {\n      createGeometryTaskProcessors = new Array(numberOfCreationWorkers);\n\n      for (i = 0; i < numberOfCreationWorkers; i++) {\n        createGeometryTaskProcessors[i] = new TaskProcessor(\"createGeometry\", Number.POSITIVE_INFINITY);\n      }\n    }\n\n    var subTask;\n    subTasks = subdivideArray(subTasks, numberOfCreationWorkers);\n\n    for (i = 0; i < subTasks.length; i++) {\n      var packedLength = 0;\n      var workerSubTasks = subTasks[i];\n      var workerSubTasksLength = workerSubTasks.length;\n\n      for (j = 0; j < workerSubTasksLength; ++j) {\n        subTask = workerSubTasks[j];\n        geometry = subTask.geometry;\n\n        if (defined(geometry.constructor.pack)) {\n          subTask.offset = packedLength;\n          packedLength += defaultValue(geometry.constructor.packedLength, geometry.packedLength);\n        }\n      }\n\n      var subTaskTransferableObjects;\n\n      if (packedLength > 0) {\n        var array = new Float64Array(packedLength);\n        subTaskTransferableObjects = [array.buffer];\n\n        for (j = 0; j < workerSubTasksLength; ++j) {\n          subTask = workerSubTasks[j];\n          geometry = subTask.geometry;\n\n          if (defined(geometry.constructor.pack)) {\n            geometry.constructor.pack(geometry, array, subTask.offset);\n            subTask.geometry = array;\n          }\n        }\n      }\n\n      promises.push(createGeometryTaskProcessors[i].scheduleTask({\n        subTasks: subTasks[i]\n      }, subTaskTransferableObjects));\n    }\n\n    primitive._state = PrimitiveState.CREATING;\n    when.all(promises, function (results) {\n      primitive._createGeometryResults = results;\n      primitive._state = PrimitiveState.CREATED;\n    }).otherwise(function (error) {\n      setReady(primitive, frameState, PrimitiveState.FAILED, error);\n    });\n  } else if (primitive._state === PrimitiveState.CREATED) {\n    var transferableObjects = [];\n    instances = Array.isArray(primitive.geometryInstances) ? primitive.geometryInstances : [primitive.geometryInstances];\n    var scene3DOnly = frameState.scene3DOnly;\n    var projection = frameState.mapProjection;\n    var promise = combineGeometryTaskProcessor.scheduleTask(PrimitivePipeline.packCombineGeometryParameters({\n      createGeometryResults: primitive._createGeometryResults,\n      instances: instances,\n      ellipsoid: projection.ellipsoid,\n      projection: projection,\n      elementIndexUintSupported: frameState.context.elementIndexUint,\n      scene3DOnly: scene3DOnly,\n      vertexCacheOptimize: primitive.vertexCacheOptimize,\n      compressVertices: primitive.compressVertices,\n      modelMatrix: primitive.modelMatrix,\n      createPickOffsets: primitive._createPickOffsets\n    }, transferableObjects), transferableObjects);\n    primitive._createGeometryResults = undefined;\n    primitive._state = PrimitiveState.COMBINING;\n    when(promise, function (packedResult) {\n      var result = PrimitivePipeline.unpackCombineGeometryResults(packedResult);\n      primitive._geometries = result.geometries;\n      primitive._attributeLocations = result.attributeLocations;\n      primitive.modelMatrix = Matrix4.clone(result.modelMatrix, primitive.modelMatrix);\n      primitive._pickOffsets = result.pickOffsets;\n      primitive._offsetInstanceExtend = result.offsetInstanceExtend;\n      primitive._instanceBoundingSpheres = result.boundingSpheres;\n      primitive._instanceBoundingSpheresCV = result.boundingSpheresCV;\n\n      if (defined(primitive._geometries) && primitive._geometries.length > 0) {\n        primitive._recomputeBoundingSpheres = true;\n        primitive._state = PrimitiveState.COMBINED;\n      } else {\n        setReady(primitive, frameState, PrimitiveState.FAILED, undefined);\n      }\n    }).otherwise(function (error) {\n      setReady(primitive, frameState, PrimitiveState.FAILED, error);\n    });\n  }\n}\n\nfunction loadSynchronous(primitive, frameState) {\n  var instances = Array.isArray(primitive.geometryInstances) ? primitive.geometryInstances : [primitive.geometryInstances];\n  var length = primitive._numberOfInstances = instances.length;\n  var clonedInstances = new Array(length);\n  var instanceIds = primitive._instanceIds;\n  var instance;\n  var i;\n  var geometryIndex = 0;\n\n  for (i = 0; i < length; i++) {\n    instance = instances[i];\n    var geometry = instance.geometry;\n    var createdGeometry;\n\n    if (defined(geometry.attributes) && defined(geometry.primitiveType)) {\n      createdGeometry = cloneGeometry(geometry);\n    } else {\n      createdGeometry = geometry.constructor.createGeometry(geometry);\n    }\n\n    clonedInstances[geometryIndex++] = cloneInstance(instance, createdGeometry);\n    instanceIds.push(instance.id);\n  }\n\n  clonedInstances.length = geometryIndex;\n  var scene3DOnly = frameState.scene3DOnly;\n  var projection = frameState.mapProjection;\n  var result = PrimitivePipeline.combineGeometry({\n    instances: clonedInstances,\n    ellipsoid: projection.ellipsoid,\n    projection: projection,\n    elementIndexUintSupported: frameState.context.elementIndexUint,\n    scene3DOnly: scene3DOnly,\n    vertexCacheOptimize: primitive.vertexCacheOptimize,\n    compressVertices: primitive.compressVertices,\n    modelMatrix: primitive.modelMatrix,\n    createPickOffsets: primitive._createPickOffsets\n  });\n  primitive._geometries = result.geometries;\n  primitive._attributeLocations = result.attributeLocations;\n  primitive.modelMatrix = Matrix4.clone(result.modelMatrix, primitive.modelMatrix);\n  primitive._pickOffsets = result.pickOffsets;\n  primitive._offsetInstanceExtend = result.offsetInstanceExtend;\n  primitive._instanceBoundingSpheres = result.boundingSpheres;\n  primitive._instanceBoundingSpheresCV = result.boundingSpheresCV;\n\n  if (defined(primitive._geometries) && primitive._geometries.length > 0) {\n    primitive._recomputeBoundingSpheres = true;\n    primitive._state = PrimitiveState.COMBINED;\n  } else {\n    setReady(primitive, frameState, PrimitiveState.FAILED, undefined);\n  }\n}\n\nfunction recomputeBoundingSpheres(primitive, frameState) {\n  var offsetIndex = primitive._batchTableAttributeIndices.offset;\n\n  if (!primitive._recomputeBoundingSpheres || !defined(offsetIndex)) {\n    primitive._recomputeBoundingSpheres = false;\n    return;\n  }\n\n  var i;\n  var offsetInstanceExtend = primitive._offsetInstanceExtend;\n  var boundingSpheres = primitive._instanceBoundingSpheres;\n  var length = boundingSpheres.length;\n  var newBoundingSpheres = primitive._tempBoundingSpheres;\n\n  if (!defined(newBoundingSpheres)) {\n    newBoundingSpheres = new Array(length);\n\n    for (i = 0; i < length; i++) {\n      newBoundingSpheres[i] = new BoundingSphere();\n    }\n\n    primitive._tempBoundingSpheres = newBoundingSpheres;\n  }\n\n  for (i = 0; i < length; ++i) {\n    var newBS = newBoundingSpheres[i];\n\n    var offset = primitive._batchTable.getBatchedAttribute(i, offsetIndex, new Cartesian3());\n\n    newBS = boundingSpheres[i].clone(newBS);\n    transformBoundingSphere(newBS, offset, offsetInstanceExtend[i]);\n  }\n\n  var combinedBS = [];\n  var combinedWestBS = [];\n  var combinedEastBS = [];\n\n  for (i = 0; i < length; ++i) {\n    var bs = newBoundingSpheres[i];\n    var minX = bs.center.x - bs.radius;\n\n    if (minX > 0 || BoundingSphere.intersectPlane(bs, Plane.ORIGIN_ZX_PLANE) !== Intersect.INTERSECTING) {\n      combinedBS.push(bs);\n    } else {\n      combinedWestBS.push(bs);\n      combinedEastBS.push(bs);\n    }\n  }\n\n  var resultBS1 = combinedBS[0];\n  var resultBS2 = combinedEastBS[0];\n  var resultBS3 = combinedWestBS[0];\n\n  for (i = 1; i < combinedBS.length; i++) {\n    resultBS1 = BoundingSphere.union(resultBS1, combinedBS[i]);\n  }\n\n  for (i = 1; i < combinedEastBS.length; i++) {\n    resultBS2 = BoundingSphere.union(resultBS2, combinedEastBS[i]);\n  }\n\n  for (i = 1; i < combinedWestBS.length; i++) {\n    resultBS3 = BoundingSphere.union(resultBS3, combinedWestBS[i]);\n  }\n\n  var result = [];\n\n  if (defined(resultBS1)) {\n    result.push(resultBS1);\n  }\n\n  if (defined(resultBS2)) {\n    result.push(resultBS2);\n  }\n\n  if (defined(resultBS3)) {\n    result.push(resultBS3);\n  }\n\n  for (i = 0; i < result.length; i++) {\n    var boundingSphere = result[i].clone(primitive._boundingSpheres[i]);\n    primitive._boundingSpheres[i] = boundingSphere;\n    primitive._boundingSphereCV[i] = BoundingSphere.projectTo2D(boundingSphere, frameState.mapProjection, primitive._boundingSphereCV[i]);\n  }\n\n  Primitive._updateBoundingVolumes(primitive, frameState, primitive.modelMatrix, true);\n\n  primitive._recomputeBoundingSpheres = false;\n}\n\nvar scratchBoundingSphereCenterEncoded = new EncodedCartesian3();\nvar scratchBoundingSphereCartographic = new Cartographic();\nvar scratchBoundingSphereCenter2D = new Cartesian3();\nvar scratchBoundingSphere = new BoundingSphere();\n\nfunction updateBatchTableBoundingSpheres(primitive, frameState) {\n  var hasDistanceDisplayCondition = defined(primitive._batchTableAttributeIndices.distanceDisplayCondition);\n\n  if (!hasDistanceDisplayCondition || primitive._batchTableBoundingSpheresUpdated) {\n    return;\n  }\n\n  var indices = primitive._batchTableBoundingSphereAttributeIndices;\n  var center3DHighIndex = indices.center3DHigh;\n  var center3DLowIndex = indices.center3DLow;\n  var center2DHighIndex = indices.center2DHigh;\n  var center2DLowIndex = indices.center2DLow;\n  var radiusIndex = indices.radius;\n  var projection = frameState.mapProjection;\n  var ellipsoid = projection.ellipsoid;\n  var batchTable = primitive._batchTable;\n  var boundingSpheres = primitive._instanceBoundingSpheres;\n  var length = boundingSpheres.length;\n\n  for (var i = 0; i < length; ++i) {\n    var boundingSphere = boundingSpheres[i];\n\n    if (!defined(boundingSphere)) {\n      continue;\n    }\n\n    var modelMatrix = primitive.modelMatrix;\n\n    if (defined(modelMatrix)) {\n      boundingSphere = BoundingSphere.transform(boundingSphere, modelMatrix, scratchBoundingSphere);\n    }\n\n    var center = boundingSphere.center;\n    var radius = boundingSphere.radius;\n    var encodedCenter = EncodedCartesian3.fromCartesian(center, scratchBoundingSphereCenterEncoded);\n    batchTable.setBatchedAttribute(i, center3DHighIndex, encodedCenter.high);\n    batchTable.setBatchedAttribute(i, center3DLowIndex, encodedCenter.low);\n\n    if (!frameState.scene3DOnly) {\n      var cartographic = ellipsoid.cartesianToCartographic(center, scratchBoundingSphereCartographic);\n      var center2D = projection.project(cartographic, scratchBoundingSphereCenter2D);\n      encodedCenter = EncodedCartesian3.fromCartesian(center2D, scratchBoundingSphereCenterEncoded);\n      batchTable.setBatchedAttribute(i, center2DHighIndex, encodedCenter.high);\n      batchTable.setBatchedAttribute(i, center2DLowIndex, encodedCenter.low);\n    }\n\n    batchTable.setBatchedAttribute(i, radiusIndex, radius);\n  }\n\n  primitive._batchTableBoundingSpheresUpdated = true;\n}\n\nvar offsetScratchCartesian = new Cartesian3();\nvar offsetCenterScratch = new Cartesian3();\n\nfunction updateBatchTableOffsets(primitive, frameState) {\n  var hasOffset = defined(primitive._batchTableAttributeIndices.offset);\n\n  if (!hasOffset || primitive._batchTableOffsetsUpdated || frameState.scene3DOnly) {\n    return;\n  }\n\n  var index2D = primitive._batchTableOffsetAttribute2DIndex;\n  var projection = frameState.mapProjection;\n  var ellipsoid = projection.ellipsoid;\n  var batchTable = primitive._batchTable;\n  var boundingSpheres = primitive._instanceBoundingSpheres;\n  var length = boundingSpheres.length;\n\n  for (var i = 0; i < length; ++i) {\n    var boundingSphere = boundingSpheres[i];\n\n    if (!defined(boundingSphere)) {\n      continue;\n    }\n\n    var offset = batchTable.getBatchedAttribute(i, primitive._batchTableAttributeIndices.offset);\n\n    if (Cartesian3.equals(offset, Cartesian3.ZERO)) {\n      batchTable.setBatchedAttribute(i, index2D, Cartesian3.ZERO);\n      continue;\n    }\n\n    var modelMatrix = primitive.modelMatrix;\n\n    if (defined(modelMatrix)) {\n      boundingSphere = BoundingSphere.transform(boundingSphere, modelMatrix, scratchBoundingSphere);\n    }\n\n    var center = boundingSphere.center;\n    center = ellipsoid.scaleToGeodeticSurface(center, offsetCenterScratch);\n    var cartographic = ellipsoid.cartesianToCartographic(center, scratchBoundingSphereCartographic);\n    var center2D = projection.project(cartographic, scratchBoundingSphereCenter2D);\n    var newPoint = Cartesian3.add(offset, center, offsetScratchCartesian);\n    cartographic = ellipsoid.cartesianToCartographic(newPoint, cartographic);\n    var newPointProjected = projection.project(cartographic, offsetScratchCartesian);\n    var newVector = Cartesian3.subtract(newPointProjected, center2D, offsetScratchCartesian);\n    var x = newVector.x;\n    newVector.x = newVector.z;\n    newVector.z = newVector.y;\n    newVector.y = x;\n    batchTable.setBatchedAttribute(i, index2D, newVector);\n  }\n\n  primitive._batchTableOffsetsUpdated = true;\n}\n\nfunction createVertexArray(primitive, frameState) {\n  var attributeLocations = primitive._attributeLocations;\n  var geometries = primitive._geometries;\n  var scene3DOnly = frameState.scene3DOnly;\n  var context = frameState.context;\n  var va = [];\n  var length = geometries.length;\n\n  for (var i = 0; i < length; ++i) {\n    var geometry = geometries[i];\n    va.push(VertexArray.fromGeometry({\n      context: context,\n      geometry: geometry,\n      attributeLocations: attributeLocations,\n      bufferUsage: BufferUsage.STATIC_DRAW,\n      interleave: primitive._interleave\n    }));\n\n    if (defined(primitive._createBoundingVolumeFunction)) {\n      primitive._createBoundingVolumeFunction(frameState, geometry);\n    } else {\n      primitive._boundingSpheres.push(BoundingSphere.clone(geometry.boundingSphere));\n\n      primitive._boundingSphereWC.push(new BoundingSphere());\n\n      if (!scene3DOnly) {\n        var center = geometry.boundingSphereCV.center;\n        var x = center.x;\n        var y = center.y;\n        var z = center.z;\n        center.x = z;\n        center.y = x;\n        center.z = y;\n\n        primitive._boundingSphereCV.push(BoundingSphere.clone(geometry.boundingSphereCV));\n\n        primitive._boundingSphere2D.push(new BoundingSphere());\n\n        primitive._boundingSphereMorph.push(new BoundingSphere());\n      }\n    }\n  }\n\n  primitive._va = va;\n  primitive._primitiveType = geometries[0].primitiveType;\n\n  if (primitive.releaseGeometryInstances) {\n    primitive.geometryInstances = undefined;\n  }\n\n  primitive._geometries = undefined;\n  setReady(primitive, frameState, PrimitiveState.COMPLETE, undefined);\n}\n\nfunction createRenderStates(primitive, context, appearance, twoPasses) {\n  var renderState = appearance.getRenderState();\n  var rs;\n\n  if (twoPasses) {\n    rs = clone(renderState, false);\n    rs.cull = {\n      enabled: true,\n      face: CullFace.BACK\n    };\n    primitive._frontFaceRS = RenderState.fromCache(rs);\n    rs.cull.face = CullFace.FRONT;\n    primitive._backFaceRS = RenderState.fromCache(rs);\n  } else {\n    primitive._frontFaceRS = RenderState.fromCache(renderState);\n    primitive._backFaceRS = primitive._frontFaceRS;\n  }\n\n  rs = clone(renderState, false);\n\n  if (defined(primitive._depthFailAppearance)) {\n    rs.depthTest.enabled = false;\n  }\n\n  if (defined(primitive._depthFailAppearance)) {\n    renderState = primitive._depthFailAppearance.getRenderState();\n    rs = clone(renderState, false);\n    rs.depthTest.func = DepthFunction.GREATER;\n\n    if (twoPasses) {\n      rs.cull = {\n        enabled: true,\n        face: CullFace.BACK\n      };\n      primitive._frontFaceDepthFailRS = RenderState.fromCache(rs);\n      rs.cull.face = CullFace.FRONT;\n      primitive._backFaceDepthFailRS = RenderState.fromCache(rs);\n    } else {\n      primitive._frontFaceDepthFailRS = RenderState.fromCache(rs);\n      primitive._backFaceDepthFailRS = primitive._frontFaceRS;\n    }\n  }\n}\n\nfunction createShaderProgram(primitive, frameState, appearance) {\n  var context = frameState.context;\n  var attributeLocations = primitive._attributeLocations;\n\n  var vs = primitive._batchTable.getVertexShaderCallback()(appearance.vertexShaderSource);\n\n  vs = Primitive._appendOffsetToShader(primitive, vs);\n  vs = Primitive._appendShowToShader(primitive, vs);\n  vs = Primitive._appendDistanceDisplayConditionToShader(primitive, vs, frameState.scene3DOnly);\n  vs = appendPickToVertexShader(vs);\n  vs = Primitive._updateColorAttribute(primitive, vs, false);\n  vs = modifyForEncodedNormals(primitive, vs);\n  vs = Primitive._modifyShaderPosition(primitive, vs, frameState.scene3DOnly);\n  var fs = appearance.getFragmentShaderSource();\n  fs = appendPickToFragmentShader(fs);\n  primitive._sp = ShaderProgram.replaceCache({\n    context: context,\n    shaderProgram: primitive._sp,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations\n  });\n  validateShaderMatching(primitive._sp, attributeLocations);\n\n  if (defined(primitive._depthFailAppearance)) {\n    vs = primitive._batchTable.getVertexShaderCallback()(primitive._depthFailAppearance.vertexShaderSource);\n    vs = Primitive._appendShowToShader(primitive, vs);\n    vs = Primitive._appendDistanceDisplayConditionToShader(primitive, vs, frameState.scene3DOnly);\n    vs = appendPickToVertexShader(vs);\n    vs = Primitive._updateColorAttribute(primitive, vs, true);\n    vs = modifyForEncodedNormals(primitive, vs);\n    vs = Primitive._modifyShaderPosition(primitive, vs, frameState.scene3DOnly);\n    vs = depthClampVS(vs);\n    fs = primitive._depthFailAppearance.getFragmentShaderSource();\n    fs = appendPickToFragmentShader(fs);\n    fs = depthClampFS(fs);\n    primitive._spDepthFail = ShaderProgram.replaceCache({\n      context: context,\n      shaderProgram: primitive._spDepthFail,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n      attributeLocations: attributeLocations\n    });\n    validateShaderMatching(primitive._spDepthFail, attributeLocations);\n  }\n}\n\nvar modifiedModelViewScratch = new Matrix4();\nvar rtcScratch = new Cartesian3();\n\nfunction getUniforms(primitive, appearance, material, frameState) {\n  // Create uniform map by combining uniforms from the appearance and material if either have uniforms.\n  var materialUniformMap = defined(material) ? material._uniforms : undefined;\n  var appearanceUniformMap = {};\n  var appearanceUniforms = appearance.uniforms;\n\n  if (defined(appearanceUniforms)) {\n    // Convert to uniform map of functions for the renderer\n    for (var name in appearanceUniforms) {\n      if (appearanceUniforms.hasOwnProperty(name)) {\n        //>>includeStart('debug', pragmas.debug);\n        if (defined(materialUniformMap) && defined(materialUniformMap[name])) {\n          // Later, we could rename uniforms behind-the-scenes if needed.\n          throw new DeveloperError(\"Appearance and material have a uniform with the same name: \" + name);\n        } //>>includeEnd('debug');\n\n\n        appearanceUniformMap[name] = getUniformFunction(appearanceUniforms, name);\n      }\n    }\n  }\n\n  var uniforms = combine(appearanceUniformMap, materialUniformMap);\n  uniforms = primitive._batchTable.getUniformMapCallback()(uniforms);\n\n  if (defined(primitive.rtcCenter)) {\n    uniforms.u_modifiedModelView = function () {\n      var viewMatrix = frameState.context.uniformState.view;\n      Matrix4.multiply(viewMatrix, primitive._modelMatrix, modifiedModelViewScratch);\n      Matrix4.multiplyByPoint(modifiedModelViewScratch, primitive.rtcCenter, rtcScratch);\n      Matrix4.setTranslation(modifiedModelViewScratch, rtcScratch, modifiedModelViewScratch);\n      return modifiedModelViewScratch;\n    };\n  }\n\n  return uniforms;\n}\n\nfunction createCommands(primitive, appearance, material, translucent, twoPasses, colorCommands, pickCommands, frameState) {\n  var uniforms = getUniforms(primitive, appearance, material, frameState);\n  var depthFailUniforms;\n\n  if (defined(primitive._depthFailAppearance)) {\n    depthFailUniforms = getUniforms(primitive, primitive._depthFailAppearance, primitive._depthFailAppearance.material, frameState);\n  }\n\n  var pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;\n  var multiplier = twoPasses ? 2 : 1;\n  multiplier *= defined(primitive._depthFailAppearance) ? 2 : 1;\n  colorCommands.length = primitive._va.length * multiplier;\n  var length = colorCommands.length;\n  var vaIndex = 0;\n\n  for (var i = 0; i < length; ++i) {\n    var colorCommand;\n\n    if (twoPasses) {\n      colorCommand = colorCommands[i];\n\n      if (!defined(colorCommand)) {\n        colorCommand = colorCommands[i] = new DrawCommand({\n          owner: primitive,\n          primitiveType: primitive._primitiveType\n        });\n      }\n\n      colorCommand.vertexArray = primitive._va[vaIndex];\n      colorCommand.renderState = primitive._backFaceRS;\n      colorCommand.shaderProgram = primitive._sp;\n      colorCommand.uniformMap = uniforms;\n      colorCommand.pass = pass;\n      ++i;\n    }\n\n    colorCommand = colorCommands[i];\n\n    if (!defined(colorCommand)) {\n      colorCommand = colorCommands[i] = new DrawCommand({\n        owner: primitive,\n        primitiveType: primitive._primitiveType\n      });\n    }\n\n    colorCommand.vertexArray = primitive._va[vaIndex];\n    colorCommand.renderState = primitive._frontFaceRS;\n    colorCommand.shaderProgram = primitive._sp;\n    colorCommand.uniformMap = uniforms;\n    colorCommand.pass = pass;\n\n    if (defined(primitive._depthFailAppearance)) {\n      if (twoPasses) {\n        ++i;\n        colorCommand = colorCommands[i];\n\n        if (!defined(colorCommand)) {\n          colorCommand = colorCommands[i] = new DrawCommand({\n            owner: primitive,\n            primitiveType: primitive._primitiveType\n          });\n        }\n\n        colorCommand.vertexArray = primitive._va[vaIndex];\n        colorCommand.renderState = primitive._backFaceDepthFailRS;\n        colorCommand.shaderProgram = primitive._spDepthFail;\n        colorCommand.uniformMap = depthFailUniforms;\n        colorCommand.pass = pass;\n      }\n\n      ++i;\n      colorCommand = colorCommands[i];\n\n      if (!defined(colorCommand)) {\n        colorCommand = colorCommands[i] = new DrawCommand({\n          owner: primitive,\n          primitiveType: primitive._primitiveType\n        });\n      }\n\n      colorCommand.vertexArray = primitive._va[vaIndex];\n      colorCommand.renderState = primitive._frontFaceDepthFailRS;\n      colorCommand.shaderProgram = primitive._spDepthFail;\n      colorCommand.uniformMap = depthFailUniforms;\n      colorCommand.pass = pass;\n    }\n\n    ++vaIndex;\n  }\n}\n\nPrimitive._updateBoundingVolumes = function (primitive, frameState, modelMatrix, forceUpdate) {\n  var i;\n  var length;\n  var boundingSphere;\n\n  if (forceUpdate || !Matrix4.equals(modelMatrix, primitive._modelMatrix)) {\n    Matrix4.clone(modelMatrix, primitive._modelMatrix);\n    length = primitive._boundingSpheres.length;\n\n    for (i = 0; i < length; ++i) {\n      boundingSphere = primitive._boundingSpheres[i];\n\n      if (defined(boundingSphere)) {\n        primitive._boundingSphereWC[i] = BoundingSphere.transform(boundingSphere, modelMatrix, primitive._boundingSphereWC[i]);\n\n        if (!frameState.scene3DOnly) {\n          primitive._boundingSphere2D[i] = BoundingSphere.clone(primitive._boundingSphereCV[i], primitive._boundingSphere2D[i]);\n          primitive._boundingSphere2D[i].center.x = 0.0;\n          primitive._boundingSphereMorph[i] = BoundingSphere.union(primitive._boundingSphereWC[i], primitive._boundingSphereCV[i]);\n        }\n      }\n    }\n  } // Update bounding volumes for primitives that are sized in pixels.\n  // The pixel size in meters varies based on the distance from the camera.\n\n\n  var pixelSize = primitive.appearance.pixelSize;\n\n  if (defined(pixelSize)) {\n    length = primitive._boundingSpheres.length;\n\n    for (i = 0; i < length; ++i) {\n      boundingSphere = primitive._boundingSpheres[i];\n      var boundingSphereWC = primitive._boundingSphereWC[i];\n      var pixelSizeInMeters = frameState.camera.getPixelSize(boundingSphere, frameState.context.drawingBufferWidth, frameState.context.drawingBufferHeight);\n      var sizeInMeters = pixelSizeInMeters * pixelSize;\n      boundingSphereWC.radius = boundingSphere.radius + sizeInMeters;\n    }\n  }\n};\n\nfunction updateAndQueueCommands(primitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {\n  //>>includeStart('debug', pragmas.debug);\n  if (frameState.mode !== SceneMode.SCENE3D && !Matrix4.equals(modelMatrix, Matrix4.IDENTITY)) {\n    throw new DeveloperError(\"Primitive.modelMatrix is only supported in 3D mode.\");\n  } //>>includeEnd('debug');\n\n\n  Primitive._updateBoundingVolumes(primitive, frameState, modelMatrix);\n\n  var boundingSpheres;\n\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingSpheres = primitive._boundingSphereWC;\n  } else if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n    boundingSpheres = primitive._boundingSphereCV;\n  } else if (frameState.mode === SceneMode.SCENE2D && defined(primitive._boundingSphere2D)) {\n    boundingSpheres = primitive._boundingSphere2D;\n  } else if (defined(primitive._boundingSphereMorph)) {\n    boundingSpheres = primitive._boundingSphereMorph;\n  }\n\n  var commandList = frameState.commandList;\n  var passes = frameState.passes;\n\n  if (passes.render || passes.pick) {\n    var allowPicking = primitive.allowPicking;\n    var castShadows = ShadowMode.castShadows(primitive.shadows);\n    var receiveShadows = ShadowMode.receiveShadows(primitive.shadows);\n    var colorLength = colorCommands.length;\n    var factor = twoPasses ? 2 : 1;\n    factor *= defined(primitive._depthFailAppearance) ? 2 : 1;\n\n    for (var j = 0; j < colorLength; ++j) {\n      var sphereIndex = Math.floor(j / factor);\n      var colorCommand = colorCommands[j];\n      colorCommand.modelMatrix = modelMatrix;\n      colorCommand.boundingVolume = boundingSpheres[sphereIndex];\n      colorCommand.cull = cull;\n      colorCommand.debugShowBoundingVolume = debugShowBoundingVolume;\n      colorCommand.castShadows = castShadows;\n      colorCommand.receiveShadows = receiveShadows;\n\n      if (allowPicking) {\n        colorCommand.pickId = \"v_pickColor\";\n      } else {\n        colorCommand.pickId = undefined;\n      }\n\n      commandList.push(colorCommand);\n    }\n  }\n}\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} All instance geometries must have the same primitiveType.\n * @exception {DeveloperError} Appearance and material have a uniform with the same name.\n * @exception {DeveloperError} Primitive.modelMatrix is only supported in 3D mode.\n * @exception {RuntimeError} Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.\n */\n\n\nPrimitive.prototype.update = function (frameState) {\n  if (!defined(this.geometryInstances) && this._va.length === 0 || defined(this.geometryInstances) && Array.isArray(this.geometryInstances) && this.geometryInstances.length === 0 || !defined(this.appearance) || frameState.mode !== SceneMode.SCENE3D && frameState.scene3DOnly || !frameState.passes.render && !frameState.passes.pick) {\n    return;\n  }\n\n  if (defined(this._error)) {\n    throw this._error;\n  } //>>includeStart('debug', pragmas.debug);\n\n\n  if (defined(this.rtcCenter) && !frameState.scene3DOnly) {\n    throw new DeveloperError(\"RTC rendering is only available for 3D only scenes.\");\n  } //>>includeEnd('debug');\n\n\n  if (this._state === PrimitiveState.FAILED) {\n    return;\n  }\n\n  var context = frameState.context;\n\n  if (!defined(this._batchTable)) {\n    createBatchTable(this, context);\n  }\n\n  if (this._batchTable.attributes.length > 0) {\n    if (ContextLimits.maximumVertexTextureImageUnits === 0) {\n      throw new RuntimeError(\"Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.\");\n    }\n\n    this._batchTable.update(frameState);\n  }\n\n  if (this._state !== PrimitiveState.COMPLETE && this._state !== PrimitiveState.COMBINED) {\n    if (this.asynchronous) {\n      loadAsynchronous(this, frameState);\n    } else {\n      loadSynchronous(this, frameState);\n    }\n  }\n\n  if (this._state === PrimitiveState.COMBINED) {\n    updateBatchTableBoundingSpheres(this, frameState);\n    updateBatchTableOffsets(this, frameState);\n    createVertexArray(this, frameState);\n  }\n\n  if (!this.show || this._state !== PrimitiveState.COMPLETE) {\n    return;\n  }\n\n  if (!this._batchTableOffsetsUpdated) {\n    updateBatchTableOffsets(this, frameState);\n  }\n\n  if (this._recomputeBoundingSpheres) {\n    recomputeBoundingSpheres(this, frameState);\n  } // Create or recreate render state and shader program if appearance/material changed\n\n\n  var appearance = this.appearance;\n  var material = appearance.material;\n  var createRS = false;\n  var createSP = false;\n\n  if (this._appearance !== appearance) {\n    this._appearance = appearance;\n    this._material = material;\n    createRS = true;\n    createSP = true;\n  } else if (this._material !== material) {\n    this._material = material;\n    createSP = true;\n  }\n\n  var depthFailAppearance = this.depthFailAppearance;\n  var depthFailMaterial = defined(depthFailAppearance) ? depthFailAppearance.material : undefined;\n\n  if (this._depthFailAppearance !== depthFailAppearance) {\n    this._depthFailAppearance = depthFailAppearance;\n    this._depthFailMaterial = depthFailMaterial;\n    createRS = true;\n    createSP = true;\n  } else if (this._depthFailMaterial !== depthFailMaterial) {\n    this._depthFailMaterial = depthFailMaterial;\n    createSP = true;\n  }\n\n  var translucent = this._appearance.isTranslucent();\n\n  if (this._translucent !== translucent) {\n    this._translucent = translucent;\n    createRS = true;\n  }\n\n  if (defined(this._material)) {\n    this._material.update(context);\n  }\n\n  var twoPasses = appearance.closed && translucent;\n\n  if (createRS) {\n    var rsFunc = defaultValue(this._createRenderStatesFunction, createRenderStates);\n    rsFunc(this, context, appearance, twoPasses);\n  }\n\n  if (createSP) {\n    var spFunc = defaultValue(this._createShaderProgramFunction, createShaderProgram);\n    spFunc(this, frameState, appearance);\n  }\n\n  if (createRS || createSP) {\n    var commandFunc = defaultValue(this._createCommandsFunction, createCommands);\n    commandFunc(this, appearance, material, translucent, twoPasses, this._colorCommands, this._pickCommands, frameState);\n  }\n\n  var updateAndQueueCommandsFunc = defaultValue(this._updateAndQueueCommandsFunction, updateAndQueueCommands);\n  updateAndQueueCommandsFunc(this, frameState, this._colorCommands, this._pickCommands, this.modelMatrix, this.cull, this.debugShowBoundingVolume, twoPasses);\n};\n\nvar offsetBoundingSphereScratch1 = new BoundingSphere();\nvar offsetBoundingSphereScratch2 = new BoundingSphere();\n\nfunction transformBoundingSphere(boundingSphere, offset, offsetAttribute) {\n  if (offsetAttribute === GeometryOffsetAttribute.TOP) {\n    var origBS = BoundingSphere.clone(boundingSphere, offsetBoundingSphereScratch1);\n    var offsetBS = BoundingSphere.clone(boundingSphere, offsetBoundingSphereScratch2);\n    offsetBS.center = Cartesian3.add(offsetBS.center, offset, offsetBS.center);\n    boundingSphere = BoundingSphere.union(origBS, offsetBS, boundingSphere);\n  } else if (offsetAttribute === GeometryOffsetAttribute.ALL) {\n    boundingSphere.center = Cartesian3.add(boundingSphere.center, offset, boundingSphere.center);\n  }\n\n  return boundingSphere;\n}\n\nfunction createGetFunction(batchTable, instanceIndex, attributeIndex) {\n  return function () {\n    var attributeValue = batchTable.getBatchedAttribute(instanceIndex, attributeIndex);\n    var attribute = batchTable.attributes[attributeIndex];\n    var componentsPerAttribute = attribute.componentsPerAttribute;\n    var value = ComponentDatatype.createTypedArray(attribute.componentDatatype, componentsPerAttribute);\n\n    if (defined(attributeValue.constructor.pack)) {\n      attributeValue.constructor.pack(attributeValue, value, 0);\n    } else {\n      value[0] = attributeValue;\n    }\n\n    return value;\n  };\n}\n\nfunction createSetFunction(batchTable, instanceIndex, attributeIndex, primitive, name) {\n  return function (value) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(value) || !defined(value.length) || value.length < 1 || value.length > 4) {\n      throw new DeveloperError(\"value must be and array with length between 1 and 4.\");\n    } //>>includeEnd('debug');\n\n\n    var attributeValue = getAttributeValue(value);\n    batchTable.setBatchedAttribute(instanceIndex, attributeIndex, attributeValue);\n\n    if (name === \"offset\") {\n      primitive._recomputeBoundingSpheres = true;\n      primitive._batchTableOffsetsUpdated = false;\n    }\n  };\n}\n\nvar offsetScratch = new Cartesian3();\n\nfunction createBoundingSphereProperties(primitive, properties, index) {\n  properties.boundingSphere = {\n    get: function () {\n      var boundingSphere = primitive._instanceBoundingSpheres[index];\n\n      if (defined(boundingSphere)) {\n        boundingSphere = boundingSphere.clone();\n        var modelMatrix = primitive.modelMatrix;\n        var offset = properties.offset;\n\n        if (defined(offset)) {\n          transformBoundingSphere(boundingSphere, Cartesian3.fromArray(offset.get(), 0, offsetScratch), primitive._offsetInstanceExtend[index]);\n        }\n\n        if (defined(modelMatrix)) {\n          boundingSphere = BoundingSphere.transform(boundingSphere, modelMatrix);\n        }\n      }\n\n      return boundingSphere;\n    }\n  };\n  properties.boundingSphereCV = {\n    get: function () {\n      return primitive._instanceBoundingSpheresCV[index];\n    }\n  };\n}\n\nfunction createPickIdProperty(primitive, properties, index) {\n  properties.pickId = {\n    get: function () {\n      return primitive._pickIds[index];\n    }\n  };\n}\n/**\n * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.\n *\n * @param {*} id The id of the {@link GeometryInstance}.\n * @returns {Object} The typed array in the attribute's format or undefined if the is no instance with id.\n *\n * @exception {DeveloperError} must call update before calling getGeometryInstanceAttributes.\n *\n * @example\n * var attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);\n * attributes.distanceDisplayCondition = Cesium.DistanceDisplayConditionGeometryInstanceAttribute.toValue(100.0, 10000.0);\n * attributes.offset = Cesium.OffsetGeometryInstanceAttribute.toValue(Cartesian3.IDENTITY);\n */\n\n\nPrimitive.prototype.getGeometryInstanceAttributes = function (id) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required\");\n  }\n\n  if (!defined(this._batchTable)) {\n    throw new DeveloperError(\"must call update before calling getGeometryInstanceAttributes\");\n  } //>>includeEnd('debug');\n\n\n  var index = -1;\n  var lastIndex = this._lastPerInstanceAttributeIndex;\n  var ids = this._instanceIds;\n  var length = ids.length;\n\n  for (var i = 0; i < length; ++i) {\n    var curIndex = (lastIndex + i) % length;\n\n    if (id === ids[curIndex]) {\n      index = curIndex;\n      break;\n    }\n  }\n\n  if (index === -1) {\n    return undefined;\n  }\n\n  var attributes = this._perInstanceAttributeCache[index];\n\n  if (defined(attributes)) {\n    return attributes;\n  }\n\n  var batchTable = this._batchTable;\n  var perInstanceAttributeIndices = this._batchTableAttributeIndices;\n  attributes = {};\n  var properties = {};\n\n  for (var name in perInstanceAttributeIndices) {\n    if (perInstanceAttributeIndices.hasOwnProperty(name)) {\n      var attributeIndex = perInstanceAttributeIndices[name];\n      properties[name] = {\n        get: createGetFunction(batchTable, index, attributeIndex),\n        set: createSetFunction(batchTable, index, attributeIndex, this, name)\n      };\n    }\n  }\n\n  createBoundingSphereProperties(this, properties, index);\n  createPickIdProperty(this, properties, index);\n  Object.defineProperties(attributes, properties);\n  this._lastPerInstanceAttributeIndex = index;\n  this._perInstanceAttributeCache[index] = attributes;\n  return attributes;\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see Primitive#destroy\n */\n\n\nPrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * e = e && e.destroy();\n *\n * @see Primitive#isDestroyed\n */\n\n\nPrimitive.prototype.destroy = function () {\n  var length;\n  var i;\n  this._sp = this._sp && this._sp.destroy();\n  this._spDepthFail = this._spDepthFail && this._spDepthFail.destroy();\n  var va = this._va;\n  length = va.length;\n\n  for (i = 0; i < length; ++i) {\n    va[i].destroy();\n  }\n\n  this._va = undefined;\n  var pickIds = this._pickIds;\n  length = pickIds.length;\n\n  for (i = 0; i < length; ++i) {\n    pickIds[i].destroy();\n  }\n\n  this._pickIds = undefined;\n  this._batchTable = this._batchTable && this._batchTable.destroy(); //These objects may be fairly large and reference other large objects (like Entities)\n  //We explicitly set them to undefined here so that the memory can be freed\n  //even if a reference to the destroyed Primitive has been kept around.\n\n  this._instanceIds = undefined;\n  this._perInstanceAttributeCache = undefined;\n  this._attributeLocations = undefined;\n  return destroyObject(this);\n};\n\nfunction setReady(primitive, frameState, state, error) {\n  primitive._error = error;\n  primitive._state = state;\n  frameState.afterRender.push(function () {\n    primitive._ready = primitive._state === PrimitiveState.COMPLETE || primitive._state === PrimitiveState.FAILED;\n\n    if (!defined(error)) {\n      primitive._readyPromise.resolve(primitive);\n    } else {\n      primitive._readyPromise.reject(error);\n    }\n  });\n}\n\nexport default Primitive;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Scene/Primitive.js"],"names":["BoundingSphere","Cartesian2","Cartesian3","Cartesian4","Cartographic","clone","Color","combine","ComponentDatatype","defaultValue","defined","destroyObject","DeveloperError","EncodedCartesian3","FeatureDetection","Geometry","GeometryAttribute","GeometryAttributes","GeometryOffsetAttribute","Intersect","Matrix4","Plane","RuntimeError","subdivideArray","TaskProcessor","BufferUsage","ContextLimits","DrawCommand","Pass","RenderState","ShaderProgram","ShaderSource","VertexArray","when","BatchTable","CullFace","DepthFunction","PrimitivePipeline","PrimitiveState","SceneMode","ShadowMode","Primitive","options","EMPTY_OBJECT","geometryInstances","appearance","_appearance","undefined","_material","depthFailAppearance","_depthFailAppearance","_depthFailMaterial","modelMatrix","IDENTITY","_modelMatrix","show","_vertexCacheOptimize","vertexCacheOptimize","_interleave","interleave","_releaseGeometryInstances","releaseGeometryInstances","_allowPicking","allowPicking","_asynchronous","asynchronous","_compressVertices","compressVertices","cull","debugShowBoundingVolume","rtcCenter","Array","isArray","length","shadows","DISABLED","_translucent","_state","READY","_geometries","_error","_numberOfInstances","_boundingSpheres","_boundingSphereWC","_boundingSphereCV","_boundingSphere2D","_boundingSphereMorph","_perInstanceAttributeCache","_instanceIds","_lastPerInstanceAttributeIndex","_va","_attributeLocations","_primitiveType","_frontFaceRS","_backFaceRS","_sp","_spDepthFail","_frontFaceDepthFailRS","_backFaceDepthFailRS","_pickIds","_colorCommands","_pickCommands","_createBoundingVolumeFunction","_createRenderStatesFunction","_createShaderProgramFunction","_createCommandsFunction","_updateAndQueueCommandsFunction","_createPickOffsets","_pickOffsets","_createGeometryResults","_ready","_readyPromise","defer","_batchTable","_batchTableAttributeIndices","_offsetInstanceExtend","_batchTableOffsetAttribute2DIndex","_batchTableOffsetsUpdated","_instanceBoundingSpheres","_instanceBoundingSpheresCV","_tempBoundingSpheres","_recomputeBoundingSpheres","_batchTableBoundingSpheresUpdated","_batchTableBoundingSphereAttributeIndices","Object","defineProperties","prototype","get","ready","readyPromise","promise","getCommonPerInstanceAttributeNames","instances","attributesInAllInstances","attributes0","attributes","name","hasOwnProperty","attribute","inAllInstances","i","otherAttribute","componentDatatype","componentsPerAttribute","normalize","push","scratchGetAttributeCartesian2","scratchGetAttributeCartesian3","scratchGetAttributeCartesian4","getAttributeValue","value","unpack","createBatchTable","primitive","context","numberOfInstances","names","attributeIndices","boundingSphereAttributeIndices","offset2DIndex","firstInstance","instanceAttributes","functionName","indexOf","FLOAT","center3DHigh","center3DLow","center2DHigh","center2DLow","radius","UNSIGNED_BYTE","attributesLength","batchTable","instance","j","attributeIndex","setBatchedAttribute","pickObject","pickPrimitive","id","pickId","createPickId","pickColor","color","x","floatToByte","red","y","green","z","blue","w","alpha","cloneAttribute","clonedValues","values","slice","constructor","cloneGeometry","geometry","newAttributes","property","indices","sourceValues","primitiveType","boundingSphere","cloneInstance","positionRegex","_modifyShaderPosition","vertexShaderSource","scene3DOnly","match","forwardDecl","computeFunctions","exec","toUpperCase","substr","replace","join","_appendShowToShader","renamedVS","replaceMain","showMain","_updateColorAttribute","isDepthFail","depthFailColor","search","modifiedVS","appendPickToVertexShader","source","pickMain","appendPickToFragmentShader","_updatePickColorAttribute","vsPick","_appendOffsetToShader","offset","attr","modifiedShader","str","_appendDistanceDisplayConditionToShader","distanceDisplayCondition","distanceDisplayConditionMain","modifyForEncodedNormals","containsNormal","containsSt","containsTangent","containsBitangent","numComponents","type","attributeName","attributeDecl","globalDecl","decode","stComponent","compressedMain","depthClampVS","depthClampFS","fragmentShaderSource","modifiedFS","validateShaderMatching","shaderProgram","attributeLocations","shaderAttributes","vertexAttributes","getUniformFunction","uniforms","numberOfCreationWorkers","Math","max","hardwareConcurrency","createGeometryTaskProcessors","combineGeometryTaskProcessor","Number","POSITIVE_INFINITY","loadAsynchronous","frameState","instanceIds","promises","subTasks","_workerName","moduleName","subTask","packedLength","workerSubTasks","workerSubTasksLength","pack","subTaskTransferableObjects","array","Float64Array","buffer","scheduleTask","CREATING","all","results","CREATED","otherwise","error","setReady","FAILED","transferableObjects","projection","mapProjection","packCombineGeometryParameters","createGeometryResults","ellipsoid","elementIndexUintSupported","elementIndexUint","createPickOffsets","COMBINING","packedResult","result","unpackCombineGeometryResults","geometries","pickOffsets","offsetInstanceExtend","boundingSpheres","boundingSpheresCV","COMBINED","loadSynchronous","clonedInstances","geometryIndex","createdGeometry","createGeometry","combineGeometry","recomputeBoundingSpheres","offsetIndex","newBoundingSpheres","newBS","getBatchedAttribute","transformBoundingSphere","combinedBS","combinedWestBS","combinedEastBS","bs","minX","center","intersectPlane","ORIGIN_ZX_PLANE","INTERSECTING","resultBS1","resultBS2","resultBS3","union","projectTo2D","_updateBoundingVolumes","scratchBoundingSphereCenterEncoded","scratchBoundingSphereCartographic","scratchBoundingSphereCenter2D","scratchBoundingSphere","updateBatchTableBoundingSpheres","hasDistanceDisplayCondition","center3DHighIndex","center3DLowIndex","center2DHighIndex","center2DLowIndex","radiusIndex","transform","encodedCenter","fromCartesian","high","low","cartographic","cartesianToCartographic","center2D","project","offsetScratchCartesian","offsetCenterScratch","updateBatchTableOffsets","hasOffset","index2D","equals","ZERO","scaleToGeodeticSurface","newPoint","add","newPointProjected","newVector","subtract","createVertexArray","va","fromGeometry","bufferUsage","STATIC_DRAW","boundingSphereCV","COMPLETE","createRenderStates","twoPasses","renderState","getRenderState","rs","enabled","face","BACK","fromCache","FRONT","depthTest","func","GREATER","createShaderProgram","vs","getVertexShaderCallback","fs","getFragmentShaderSource","replaceCache","modifiedModelViewScratch","rtcScratch","getUniforms","material","materialUniformMap","_uniforms","appearanceUniformMap","appearanceUniforms","getUniformMapCallback","u_modifiedModelView","viewMatrix","uniformState","view","multiply","multiplyByPoint","setTranslation","createCommands","translucent","colorCommands","pickCommands","depthFailUniforms","pass","TRANSLUCENT","OPAQUE","multiplier","vaIndex","colorCommand","owner","vertexArray","uniformMap","forceUpdate","pixelSize","boundingSphereWC","pixelSizeInMeters","camera","getPixelSize","drawingBufferWidth","drawingBufferHeight","sizeInMeters","updateAndQueueCommands","mode","SCENE3D","COLUMBUS_VIEW","SCENE2D","commandList","passes","render","pick","castShadows","receiveShadows","colorLength","factor","sphereIndex","floor","boundingVolume","update","maximumVertexTextureImageUnits","createRS","createSP","depthFailMaterial","isTranslucent","closed","rsFunc","spFunc","commandFunc","updateAndQueueCommandsFunc","offsetBoundingSphereScratch1","offsetBoundingSphereScratch2","offsetAttribute","TOP","origBS","offsetBS","ALL","createGetFunction","instanceIndex","attributeValue","createTypedArray","createSetFunction","offsetScratch","createBoundingSphereProperties","properties","index","fromArray","createPickIdProperty","getGeometryInstanceAttributes","lastIndex","ids","curIndex","perInstanceAttributeIndices","set","isDestroyed","destroy","pickIds","state","afterRender","resolve","reject"],"mappings":"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","sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport Geometry from \"../Core/Geometry.js\";\nimport GeometryAttribute from \"../Core/GeometryAttribute.js\";\nimport GeometryAttributes from \"../Core/GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"../Core/GeometryOffsetAttribute.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Plane from \"../Core/Plane.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport subdivideArray from \"../Core/subdivideArray.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport when from \"../ThirdParty/when.js\";\nimport BatchTable from \"./BatchTable.js\";\nimport CullFace from \"./CullFace.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport PrimitivePipeline from \"./PrimitivePipeline.js\";\nimport PrimitiveState from \"./PrimitiveState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\n\n/**\n * A primitive represents geometry in the {@link Scene}.  The geometry can be from a single {@link GeometryInstance}\n * as shown in example 1 below, or from an array of instances, even if the geometry is from different\n * geometry types, e.g., an {@link RectangleGeometry} and an {@link EllipsoidGeometry} as shown in Code Example 2.\n * <p>\n * A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including\n * {@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,\n * and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix\n * and match most of them and add a new geometry or appearance independently of each other.\n * </p>\n * <p>\n * Combining multiple instances into one primitive is called batching, and significantly improves performance for static data.\n * Instances can be individually picked; {@link Scene#pick} returns their {@link GeometryInstance#id}.  Using\n * per-instance appearances like {@link PerInstanceColorAppearance}, each instance can also have a unique color.\n * </p>\n * <p>\n * {@link Geometry} can either be created and batched on a web worker or the main thread. The first two examples\n * show geometry that will be created on a web worker by using the descriptions of the geometry. The third example\n * shows how to create the geometry on the main thread by explicitly calling the <code>createGeometry</code> method.\n * </p>\n *\n * @alias Primitive\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {GeometryInstance[]|GeometryInstance} [options.geometryInstances] The geometry instances - or a single geometry instance - to render.\n * @param {Appearance} [options.appearance] The appearance used to render the primitive.\n * @param {Appearance} [options.depthFailAppearance] The appearance used to shade this primitive when it fails the depth test.\n * @param {Boolean} [options.show=true] Determines if this primitive will be shown.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates.\n * @param {Boolean} [options.vertexCacheOptimize=false] When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n * @param {Boolean} [options.interleave=false] When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.\n * @param {Boolean} [options.compressVertices=true] When <code>true</code>, the geometry vertices are compressed, which will save memory.\n * @param {Boolean} [options.releaseGeometryInstances=true] When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n * @param {Boolean} [options.cull=true] When <code>true</code>, the renderer frustum culls and horizon culls the primitive's commands based on their bounding volume.  Set this to <code>false</code> for a small performance gain if you are manually culling the primitive.\n * @param {Boolean} [options.asynchronous=true] Determines if the primitive will be created asynchronously or block until ready.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {ShadowMode} [options.shadows=ShadowMode.DISABLED] Determines whether this primitive casts or receives shadows from light sources.\n *\n * @example\n * // 1. Draw a translucent ellipse on the surface with a checkerboard pattern\n * var instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.EllipseGeometry({\n *       center : Cesium.Cartesian3.fromDegrees(-100.0, 20.0),\n *       semiMinorAxis : 500000.0,\n *       semiMajorAxis : 1000000.0,\n *       rotation : Cesium.Math.PI_OVER_FOUR,\n *       vertexFormat : Cesium.VertexFormat.POSITION_AND_ST\n *   }),\n *   id : 'object returned when this instance is picked and to get/set per-instance attributes'\n * });\n * scene.primitives.add(new Cesium.Primitive({\n *   geometryInstances : instance,\n *   appearance : new Cesium.EllipsoidSurfaceAppearance({\n *     material : Cesium.Material.fromType('Checkerboard')\n *   })\n * }));\n *\n * @example\n * // 2. Draw different instances each with a unique color\n * var rectangleInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0),\n *     vertexFormat : Cesium.PerInstanceColorAppearance.VERTEX_FORMAT\n *   }),\n *   id : 'rectangle',\n *   attributes : {\n *     color : new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5)\n *   }\n * });\n * var ellipsoidInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.EllipsoidGeometry({\n *     radii : new Cesium.Cartesian3(500000.0, 500000.0, 1000000.0),\n *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL\n *   }),\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(-95.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 500000.0), new Cesium.Matrix4()),\n *   id : 'ellipsoid',\n *   attributes : {\n *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)\n *   }\n * });\n * scene.primitives.add(new Cesium.Primitive({\n *   geometryInstances : [rectangleInstance, ellipsoidInstance],\n *   appearance : new Cesium.PerInstanceColorAppearance()\n * }));\n *\n * @example\n * // 3. Create the geometry on the main thread.\n * scene.primitives.add(new Cesium.Primitive({\n *   geometryInstances : new Cesium.GeometryInstance({\n *       geometry : Cesium.EllipsoidGeometry.createGeometry(new Cesium.EllipsoidGeometry({\n *         radii : new Cesium.Cartesian3(500000.0, 500000.0, 1000000.0),\n *         vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL\n *       })),\n *       modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *         Cesium.Cartesian3.fromDegrees(-95.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 500000.0), new Cesium.Matrix4()),\n *       id : 'ellipsoid',\n *       attributes : {\n *         color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)\n *       }\n *   }),\n *   appearance : new Cesium.PerInstanceColorAppearance()\n * }));\n *\n * @see GeometryInstance\n * @see Appearance\n * @see ClassificationPrimitive\n * @see GroundPrimitive\n */\nfunction Primitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The geometry instances rendered with this primitive.  This may\n   * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>\n   * is <code>true</code> when the primitive is constructed.\n   * <p>\n   * Changing this property after the primitive is rendered has no effect.\n   * </p>\n   *\n   * @readonly\n   * @type GeometryInstance[]|GeometryInstance\n   *\n   * @default undefined\n   */\n  this.geometryInstances = options.geometryInstances;\n\n  /**\n   * The {@link Appearance} used to shade this primitive. Each geometry\n   * instance is shaded with the same appearance.  Some appearances, like\n   * {@link PerInstanceColorAppearance} allow giving each instance unique\n   * properties.\n   *\n   * @type Appearance\n   *\n   * @default undefined\n   */\n  this.appearance = options.appearance;\n  this._appearance = undefined;\n  this._material = undefined;\n\n  /**\n   * The {@link Appearance} used to shade this primitive when it fails the depth test. Each geometry\n   * instance is shaded with the same appearance.  Some appearances, like\n   * {@link PerInstanceColorAppearance} allow giving each instance unique\n   * properties.\n   *\n   * <p>\n   * When using an appearance that requires a color attribute, like PerInstanceColorAppearance,\n   * add a depthFailColor per-instance attribute instead.\n   * </p>\n   *\n   * <p>\n   * Requires the EXT_frag_depth WebGL extension to render properly. If the extension is not supported,\n   * there may be artifacts.\n   * </p>\n   * @type Appearance\n   *\n   * @default undefined\n   */\n  this.depthFailAppearance = options.depthFailAppearance;\n  this._depthFailAppearance = undefined;\n  this._depthFailMaterial = undefined;\n\n  /**\n   * The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates.\n   * When this is the identity matrix, the primitive is drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * <p>\n   * This property is only supported in 3D mode.\n   * </p>\n   *\n   * @type Matrix4\n   *\n   * @default Matrix4.IDENTITY\n   *\n   * @example\n   * var origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n   * p.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);\n   */\n  this.modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY)\n  );\n  this._modelMatrix = new Matrix4();\n\n  /**\n   * Determines if the primitive will be shown.  This affects all geometry\n   * instances in the primitive.\n   *\n   * @type Boolean\n   *\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  this._vertexCacheOptimize = defaultValue(options.vertexCacheOptimize, false);\n  this._interleave = defaultValue(options.interleave, false);\n  this._releaseGeometryInstances = defaultValue(\n    options.releaseGeometryInstances,\n    true\n  );\n  this._allowPicking = defaultValue(options.allowPicking, true);\n  this._asynchronous = defaultValue(options.asynchronous, true);\n  this._compressVertices = defaultValue(options.compressVertices, true);\n\n  /**\n   * When <code>true</code>, the renderer frustum culls and horizon culls the primitive's commands\n   * based on their bounding volume.  Set this to <code>false</code> for a small performance gain\n   * if you are manually culling the primitive.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  this.cull = defaultValue(options.cull, true);\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false\n  );\n\n  /**\n   * @private\n   */\n  this.rtcCenter = options.rtcCenter;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    defined(this.rtcCenter) &&\n    (!defined(this.geometryInstances) ||\n      (Array.isArray(this.geometryInstances) &&\n        this.geometryInstances.length !== 1))\n  ) {\n    throw new DeveloperError(\n      \"Relative-to-center rendering only supports one geometry instance.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * Determines whether this primitive casts or receives shadows from light sources.\n   *\n   * @type {ShadowMode}\n   *\n   * @default ShadowMode.DISABLED\n   */\n  this.shadows = defaultValue(options.shadows, ShadowMode.DISABLED);\n\n  this._translucent = undefined;\n\n  this._state = PrimitiveState.READY;\n  this._geometries = [];\n  this._error = undefined;\n  this._numberOfInstances = 0;\n\n  this._boundingSpheres = [];\n  this._boundingSphereWC = [];\n  this._boundingSphereCV = [];\n  this._boundingSphere2D = [];\n  this._boundingSphereMorph = [];\n  this._perInstanceAttributeCache = [];\n  this._instanceIds = [];\n  this._lastPerInstanceAttributeIndex = 0;\n\n  this._va = [];\n  this._attributeLocations = undefined;\n  this._primitiveType = undefined;\n\n  this._frontFaceRS = undefined;\n  this._backFaceRS = undefined;\n  this._sp = undefined;\n\n  this._depthFailAppearance = undefined;\n  this._spDepthFail = undefined;\n  this._frontFaceDepthFailRS = undefined;\n  this._backFaceDepthFailRS = undefined;\n\n  this._pickIds = [];\n\n  this._colorCommands = [];\n  this._pickCommands = [];\n\n  this._createBoundingVolumeFunction = options._createBoundingVolumeFunction;\n  this._createRenderStatesFunction = options._createRenderStatesFunction;\n  this._createShaderProgramFunction = options._createShaderProgramFunction;\n  this._createCommandsFunction = options._createCommandsFunction;\n  this._updateAndQueueCommandsFunction =\n    options._updateAndQueueCommandsFunction;\n\n  this._createPickOffsets = options._createPickOffsets;\n  this._pickOffsets = undefined;\n\n  this._createGeometryResults = undefined;\n  this._ready = false;\n  this._readyPromise = when.defer();\n\n  this._batchTable = undefined;\n  this._batchTableAttributeIndices = undefined;\n  this._offsetInstanceExtend = undefined;\n  this._batchTableOffsetAttribute2DIndex = undefined;\n  this._batchTableOffsetsUpdated = false;\n  this._instanceBoundingSpheres = undefined;\n  this._instanceBoundingSpheresCV = undefined;\n  this._tempBoundingSpheres = undefined;\n  this._recomputeBoundingSpheres = false;\n  this._batchTableBoundingSpheresUpdated = false;\n  this._batchTableBoundingSphereAttributeIndices = undefined;\n}\n\nObject.defineProperties(Primitive.prototype, {\n  /**\n   * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  vertexCacheOptimize: {\n    get: function () {\n      return this._vertexCacheOptimize;\n    },\n  },\n\n  /**\n   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  interleave: {\n    get: function () {\n      return this._interleave;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  releaseGeometryInstances: {\n    get: function () {\n      return this._releaseGeometryInstances;\n    },\n  },\n\n  /**\n   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.         *\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._allowPicking;\n    },\n  },\n\n  /**\n   * Determines if the geometry instances will be created and batched on a web worker.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._asynchronous;\n    },\n  },\n\n  /**\n   * When <code>true</code>, geometry vertices are compressed, which will save memory.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  compressVertices: {\n    get: function () {\n      return this._compressVertices;\n    },\n  },\n\n  /**\n   * Determines if the primitive is complete and ready to render.  If this property is\n   * true, the primitive will be rendered the next time that {@link Primitive#update}\n   * is called.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves when the primitive is ready to render.\n   * @memberof Primitive.prototype\n   * @type {Promise.<Primitive>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n});\n\nfunction getCommonPerInstanceAttributeNames(instances) {\n  var length = instances.length;\n\n  var attributesInAllInstances = [];\n  var attributes0 = instances[0].attributes;\n  var name;\n\n  for (name in attributes0) {\n    if (attributes0.hasOwnProperty(name) && defined(attributes0[name])) {\n      var attribute = attributes0[name];\n      var inAllInstances = true;\n\n      // Does this same attribute exist in all instances?\n      for (var i = 1; i < length; ++i) {\n        var otherAttribute = instances[i].attributes[name];\n\n        if (\n          !defined(otherAttribute) ||\n          attribute.componentDatatype !== otherAttribute.componentDatatype ||\n          attribute.componentsPerAttribute !==\n            otherAttribute.componentsPerAttribute ||\n          attribute.normalize !== otherAttribute.normalize\n        ) {\n          inAllInstances = false;\n          break;\n        }\n      }\n\n      if (inAllInstances) {\n        attributesInAllInstances.push(name);\n      }\n    }\n  }\n\n  return attributesInAllInstances;\n}\n\nvar scratchGetAttributeCartesian2 = new Cartesian2();\nvar scratchGetAttributeCartesian3 = new Cartesian3();\nvar scratchGetAttributeCartesian4 = new Cartesian4();\n\nfunction getAttributeValue(value) {\n  var componentsPerAttribute = value.length;\n  if (componentsPerAttribute === 1) {\n    return value[0];\n  } else if (componentsPerAttribute === 2) {\n    return Cartesian2.unpack(value, 0, scratchGetAttributeCartesian2);\n  } else if (componentsPerAttribute === 3) {\n    return Cartesian3.unpack(value, 0, scratchGetAttributeCartesian3);\n  } else if (componentsPerAttribute === 4) {\n    return Cartesian4.unpack(value, 0, scratchGetAttributeCartesian4);\n  }\n}\n\nfunction createBatchTable(primitive, context) {\n  var geometryInstances = primitive.geometryInstances;\n  var instances = Array.isArray(geometryInstances)\n    ? geometryInstances\n    : [geometryInstances];\n  var numberOfInstances = instances.length;\n  if (numberOfInstances === 0) {\n    return;\n  }\n\n  var names = getCommonPerInstanceAttributeNames(instances);\n  var length = names.length;\n\n  var attributes = [];\n  var attributeIndices = {};\n  var boundingSphereAttributeIndices = {};\n  var offset2DIndex;\n\n  var firstInstance = instances[0];\n  var instanceAttributes = firstInstance.attributes;\n\n  var i;\n  var name;\n  var attribute;\n\n  for (i = 0; i < length; ++i) {\n    name = names[i];\n    attribute = instanceAttributes[name];\n\n    attributeIndices[name] = i;\n    attributes.push({\n      functionName: \"czm_batchTable_\" + name,\n      componentDatatype: attribute.componentDatatype,\n      componentsPerAttribute: attribute.componentsPerAttribute,\n      normalize: attribute.normalize,\n    });\n  }\n\n  if (names.indexOf(\"distanceDisplayCondition\") !== -1) {\n    attributes.push(\n      {\n        functionName: \"czm_batchTable_boundingSphereCenter3DHigh\",\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        functionName: \"czm_batchTable_boundingSphereCenter3DLow\",\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        functionName: \"czm_batchTable_boundingSphereCenter2DHigh\",\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        functionName: \"czm_batchTable_boundingSphereCenter2DLow\",\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        functionName: \"czm_batchTable_boundingSphereRadius\",\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 1,\n      }\n    );\n    boundingSphereAttributeIndices.center3DHigh = attributes.length - 5;\n    boundingSphereAttributeIndices.center3DLow = attributes.length - 4;\n    boundingSphereAttributeIndices.center2DHigh = attributes.length - 3;\n    boundingSphereAttributeIndices.center2DLow = attributes.length - 2;\n    boundingSphereAttributeIndices.radius = attributes.length - 1;\n  }\n\n  if (names.indexOf(\"offset\") !== -1) {\n    attributes.push({\n      functionName: \"czm_batchTable_offset2D\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n    });\n    offset2DIndex = attributes.length - 1;\n  }\n\n  attributes.push({\n    functionName: \"czm_batchTable_pickColor\",\n    componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n    componentsPerAttribute: 4,\n    normalize: true,\n  });\n\n  var attributesLength = attributes.length;\n  var batchTable = new BatchTable(context, attributes, numberOfInstances);\n\n  for (i = 0; i < numberOfInstances; ++i) {\n    var instance = instances[i];\n    instanceAttributes = instance.attributes;\n\n    for (var j = 0; j < length; ++j) {\n      name = names[j];\n      attribute = instanceAttributes[name];\n      var value = getAttributeValue(attribute.value);\n      var attributeIndex = attributeIndices[name];\n      batchTable.setBatchedAttribute(i, attributeIndex, value);\n    }\n\n    var pickObject = {\n      primitive: defaultValue(instance.pickPrimitive, primitive),\n    };\n\n    if (defined(instance.id)) {\n      pickObject.id = instance.id;\n    }\n\n    var pickId = context.createPickId(pickObject);\n    primitive._pickIds.push(pickId);\n\n    var pickColor = pickId.color;\n    var color = scratchGetAttributeCartesian4;\n    color.x = Color.floatToByte(pickColor.red);\n    color.y = Color.floatToByte(pickColor.green);\n    color.z = Color.floatToByte(pickColor.blue);\n    color.w = Color.floatToByte(pickColor.alpha);\n\n    batchTable.setBatchedAttribute(i, attributesLength - 1, color);\n  }\n\n  primitive._batchTable = batchTable;\n  primitive._batchTableAttributeIndices = attributeIndices;\n  primitive._batchTableBoundingSphereAttributeIndices = boundingSphereAttributeIndices;\n  primitive._batchTableOffsetAttribute2DIndex = offset2DIndex;\n}\n\nfunction cloneAttribute(attribute) {\n  var clonedValues;\n  if (Array.isArray(attribute.values)) {\n    clonedValues = attribute.values.slice(0);\n  } else {\n    clonedValues = new attribute.values.constructor(attribute.values);\n  }\n  return new GeometryAttribute({\n    componentDatatype: attribute.componentDatatype,\n    componentsPerAttribute: attribute.componentsPerAttribute,\n    normalize: attribute.normalize,\n    values: clonedValues,\n  });\n}\n\nfunction cloneGeometry(geometry) {\n  var attributes = geometry.attributes;\n  var newAttributes = new GeometryAttributes();\n  for (var property in attributes) {\n    if (attributes.hasOwnProperty(property) && defined(attributes[property])) {\n      newAttributes[property] = cloneAttribute(attributes[property]);\n    }\n  }\n\n  var indices;\n  if (defined(geometry.indices)) {\n    var sourceValues = geometry.indices;\n    if (Array.isArray(sourceValues)) {\n      indices = sourceValues.slice(0);\n    } else {\n      indices = new sourceValues.constructor(sourceValues);\n    }\n  }\n\n  return new Geometry({\n    attributes: newAttributes,\n    indices: indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: BoundingSphere.clone(geometry.boundingSphere),\n  });\n}\n\nfunction cloneInstance(instance, geometry) {\n  return {\n    geometry: geometry,\n    attributes: instance.attributes,\n    modelMatrix: Matrix4.clone(instance.modelMatrix),\n    pickPrimitive: instance.pickPrimitive,\n    id: instance.id,\n  };\n}\n\nvar positionRegex = /attribute\\s+vec(?:3|4)\\s+(.*)3DHigh;/g;\n\nPrimitive._modifyShaderPosition = function (\n  primitive,\n  vertexShaderSource,\n  scene3DOnly\n) {\n  var match;\n\n  var forwardDecl = \"\";\n  var attributes = \"\";\n  var computeFunctions = \"\";\n\n  while ((match = positionRegex.exec(vertexShaderSource)) !== null) {\n    var name = match[1];\n\n    var functionName =\n      \"vec4 czm_compute\" + name[0].toUpperCase() + name.substr(1) + \"()\";\n\n    // Don't forward-declare czm_computePosition because computePosition.glsl already does.\n    if (functionName !== \"vec4 czm_computePosition()\") {\n      forwardDecl += functionName + \";\\n\";\n    }\n\n    if (!defined(primitive.rtcCenter)) {\n      // Use GPU RTE\n      if (!scene3DOnly) {\n        attributes +=\n          \"attribute vec3 \" +\n          name +\n          \"2DHigh;\\n\" +\n          \"attribute vec3 \" +\n          name +\n          \"2DLow;\\n\";\n\n        computeFunctions +=\n          functionName +\n          \"\\n\" +\n          \"{\\n\" +\n          \"    vec4 p;\\n\" +\n          \"    if (czm_morphTime == 1.0)\\n\" +\n          \"    {\\n\" +\n          \"        p = czm_translateRelativeToEye(\" +\n          name +\n          \"3DHigh, \" +\n          name +\n          \"3DLow);\\n\" +\n          \"    }\\n\" +\n          \"    else if (czm_morphTime == 0.0)\\n\" +\n          \"    {\\n\" +\n          \"        p = czm_translateRelativeToEye(\" +\n          name +\n          \"2DHigh.zxy, \" +\n          name +\n          \"2DLow.zxy);\\n\" +\n          \"    }\\n\" +\n          \"    else\\n\" +\n          \"    {\\n\" +\n          \"        p = czm_columbusViewMorph(\\n\" +\n          \"                czm_translateRelativeToEye(\" +\n          name +\n          \"2DHigh.zxy, \" +\n          name +\n          \"2DLow.zxy),\\n\" +\n          \"                czm_translateRelativeToEye(\" +\n          name +\n          \"3DHigh, \" +\n          name +\n          \"3DLow),\\n\" +\n          \"                czm_morphTime);\\n\" +\n          \"    }\\n\" +\n          \"    return p;\\n\" +\n          \"}\\n\\n\";\n      } else {\n        computeFunctions +=\n          functionName +\n          \"\\n\" +\n          \"{\\n\" +\n          \"    return czm_translateRelativeToEye(\" +\n          name +\n          \"3DHigh, \" +\n          name +\n          \"3DLow);\\n\" +\n          \"}\\n\\n\";\n      }\n    } else {\n      // Use RTC\n      vertexShaderSource = vertexShaderSource.replace(\n        /attribute\\s+vec(?:3|4)\\s+position3DHigh;/g,\n        \"\"\n      );\n      vertexShaderSource = vertexShaderSource.replace(\n        /attribute\\s+vec(?:3|4)\\s+position3DLow;/g,\n        \"\"\n      );\n\n      forwardDecl += \"uniform mat4 u_modifiedModelView;\\n\";\n      attributes += \"attribute vec4 position;\\n\";\n\n      computeFunctions +=\n        functionName +\n        \"\\n\" +\n        \"{\\n\" +\n        \"    return u_modifiedModelView * position;\\n\" +\n        \"}\\n\\n\";\n\n      vertexShaderSource = vertexShaderSource.replace(\n        /czm_modelViewRelativeToEye\\s+\\*\\s+/g,\n        \"\"\n      );\n      vertexShaderSource = vertexShaderSource.replace(\n        /czm_modelViewProjectionRelativeToEye/g,\n        \"czm_projection\"\n      );\n    }\n  }\n\n  return [forwardDecl, attributes, vertexShaderSource, computeFunctions].join(\n    \"\\n\"\n  );\n};\n\nPrimitive._appendShowToShader = function (primitive, vertexShaderSource) {\n  if (!defined(primitive._batchTableAttributeIndices.show)) {\n    return vertexShaderSource;\n  }\n\n  var renamedVS = ShaderSource.replaceMain(\n    vertexShaderSource,\n    \"czm_non_show_main\"\n  );\n  var showMain =\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    czm_non_show_main(); \\n\" +\n    \"    gl_Position *= czm_batchTable_show(batchId); \\n\" +\n    \"}\";\n\n  return renamedVS + \"\\n\" + showMain;\n};\n\nPrimitive._updateColorAttribute = function (\n  primitive,\n  vertexShaderSource,\n  isDepthFail\n) {\n  // some appearances have a color attribute for per vertex color.\n  // only remove if color is a per instance attribute.\n  if (\n    !defined(primitive._batchTableAttributeIndices.color) &&\n    !defined(primitive._batchTableAttributeIndices.depthFailColor)\n  ) {\n    return vertexShaderSource;\n  }\n\n  if (vertexShaderSource.search(/attribute\\s+vec4\\s+color;/g) === -1) {\n    return vertexShaderSource;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    isDepthFail &&\n    !defined(primitive._batchTableAttributeIndices.depthFailColor)\n  ) {\n    throw new DeveloperError(\n      \"A depthFailColor per-instance attribute is required when using a depth fail appearance that uses a color attribute.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var modifiedVS = vertexShaderSource;\n  modifiedVS = modifiedVS.replace(/attribute\\s+vec4\\s+color;/g, \"\");\n  if (!isDepthFail) {\n    modifiedVS = modifiedVS.replace(\n      /(\\b)color(\\b)/g,\n      \"$1czm_batchTable_color(batchId)$2\"\n    );\n  } else {\n    modifiedVS = modifiedVS.replace(\n      /(\\b)color(\\b)/g,\n      \"$1czm_batchTable_depthFailColor(batchId)$2\"\n    );\n  }\n  return modifiedVS;\n};\n\nfunction appendPickToVertexShader(source) {\n  var renamedVS = ShaderSource.replaceMain(source, \"czm_non_pick_main\");\n  var pickMain =\n    \"varying vec4 v_pickColor; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    czm_non_pick_main(); \\n\" +\n    \"    v_pickColor = czm_batchTable_pickColor(batchId); \\n\" +\n    \"}\";\n\n  return renamedVS + \"\\n\" + pickMain;\n}\n\nfunction appendPickToFragmentShader(source) {\n  return \"varying vec4 v_pickColor;\\n\" + source;\n}\n\nPrimitive._updatePickColorAttribute = function (source) {\n  var vsPick = source.replace(/attribute\\s+vec4\\s+pickColor;/g, \"\");\n  vsPick = vsPick.replace(\n    /(\\b)pickColor(\\b)/g,\n    \"$1czm_batchTable_pickColor(batchId)$2\"\n  );\n  return vsPick;\n};\n\nPrimitive._appendOffsetToShader = function (primitive, vertexShaderSource) {\n  if (!defined(primitive._batchTableAttributeIndices.offset)) {\n    return vertexShaderSource;\n  }\n\n  var attr = \"attribute float batchId;\\n\";\n  attr += \"attribute float applyOffset;\";\n  var modifiedShader = vertexShaderSource.replace(\n    /attribute\\s+float\\s+batchId;/g,\n    attr\n  );\n\n  var str = \"vec4 $1 = czm_computePosition();\\n\";\n  str += \"    if (czm_sceneMode == czm_sceneMode3D)\\n\";\n  str += \"    {\\n\";\n  str +=\n    \"        $1 = $1 + vec4(czm_batchTable_offset(batchId) * applyOffset, 0.0);\";\n  str += \"    }\\n\";\n  str += \"    else\\n\";\n  str += \"    {\\n\";\n  str +=\n    \"        $1 = $1 + vec4(czm_batchTable_offset2D(batchId) * applyOffset, 0.0);\";\n  str += \"    }\\n\";\n  modifiedShader = modifiedShader.replace(\n    /vec4\\s+([A-Za-z0-9_]+)\\s+=\\s+czm_computePosition\\(\\);/g,\n    str\n  );\n  return modifiedShader;\n};\n\nPrimitive._appendDistanceDisplayConditionToShader = function (\n  primitive,\n  vertexShaderSource,\n  scene3DOnly\n) {\n  if (\n    !defined(primitive._batchTableAttributeIndices.distanceDisplayCondition)\n  ) {\n    return vertexShaderSource;\n  }\n\n  var renamedVS = ShaderSource.replaceMain(\n    vertexShaderSource,\n    \"czm_non_distanceDisplayCondition_main\"\n  );\n  var distanceDisplayConditionMain =\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    czm_non_distanceDisplayCondition_main(); \\n\" +\n    \"    vec2 distanceDisplayCondition = czm_batchTable_distanceDisplayCondition(batchId);\\n\" +\n    \"    vec3 boundingSphereCenter3DHigh = czm_batchTable_boundingSphereCenter3DHigh(batchId);\\n\" +\n    \"    vec3 boundingSphereCenter3DLow = czm_batchTable_boundingSphereCenter3DLow(batchId);\\n\" +\n    \"    float boundingSphereRadius = czm_batchTable_boundingSphereRadius(batchId);\\n\";\n\n  if (!scene3DOnly) {\n    distanceDisplayConditionMain +=\n      \"    vec3 boundingSphereCenter2DHigh = czm_batchTable_boundingSphereCenter2DHigh(batchId);\\n\" +\n      \"    vec3 boundingSphereCenter2DLow = czm_batchTable_boundingSphereCenter2DLow(batchId);\\n\" +\n      \"    vec4 centerRTE;\\n\" +\n      \"    if (czm_morphTime == 1.0)\\n\" +\n      \"    {\\n\" +\n      \"        centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);\\n\" +\n      \"    }\\n\" +\n      \"    else if (czm_morphTime == 0.0)\\n\" +\n      \"    {\\n\" +\n      \"        centerRTE = czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy);\\n\" +\n      \"    }\\n\" +\n      \"    else\\n\" +\n      \"    {\\n\" +\n      \"        centerRTE = czm_columbusViewMorph(\\n\" +\n      \"                czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy),\\n\" +\n      \"                czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow),\\n\" +\n      \"                czm_morphTime);\\n\" +\n      \"    }\\n\";\n  } else {\n    distanceDisplayConditionMain +=\n      \"    vec4 centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);\\n\";\n  }\n\n  distanceDisplayConditionMain +=\n    \"    float radiusSq = boundingSphereRadius * boundingSphereRadius; \\n\" +\n    \"    float distanceSq; \\n\" +\n    \"    if (czm_sceneMode == czm_sceneMode2D) \\n\" +\n    \"    { \\n\" +\n    \"        distanceSq = czm_eyeHeight2D.y - radiusSq; \\n\" +\n    \"    } \\n\" +\n    \"    else \\n\" +\n    \"    { \\n\" +\n    \"        distanceSq = dot(centerRTE.xyz, centerRTE.xyz) - radiusSq; \\n\" +\n    \"    } \\n\" +\n    \"    distanceSq = max(distanceSq, 0.0); \\n\" +\n    \"    float nearSq = distanceDisplayCondition.x * distanceDisplayCondition.x; \\n\" +\n    \"    float farSq = distanceDisplayCondition.y * distanceDisplayCondition.y; \\n\" +\n    \"    float show = (distanceSq >= nearSq && distanceSq <= farSq) ? 1.0 : 0.0; \\n\" +\n    \"    gl_Position *= show; \\n\" +\n    \"}\";\n  return renamedVS + \"\\n\" + distanceDisplayConditionMain;\n};\n\nfunction modifyForEncodedNormals(primitive, vertexShaderSource) {\n  if (!primitive.compressVertices) {\n    return vertexShaderSource;\n  }\n\n  var containsNormal =\n    vertexShaderSource.search(/attribute\\s+vec3\\s+normal;/g) !== -1;\n  var containsSt = vertexShaderSource.search(/attribute\\s+vec2\\s+st;/g) !== -1;\n  if (!containsNormal && !containsSt) {\n    return vertexShaderSource;\n  }\n\n  var containsTangent =\n    vertexShaderSource.search(/attribute\\s+vec3\\s+tangent;/g) !== -1;\n  var containsBitangent =\n    vertexShaderSource.search(/attribute\\s+vec3\\s+bitangent;/g) !== -1;\n\n  var numComponents = containsSt && containsNormal ? 2.0 : 1.0;\n  numComponents += containsTangent || containsBitangent ? 1 : 0;\n\n  var type = numComponents > 1 ? \"vec\" + numComponents : \"float\";\n\n  var attributeName = \"compressedAttributes\";\n  var attributeDecl = \"attribute \" + type + \" \" + attributeName + \";\";\n\n  var globalDecl = \"\";\n  var decode = \"\";\n\n  if (containsSt) {\n    globalDecl += \"vec2 st;\\n\";\n    var stComponent = numComponents > 1 ? attributeName + \".x\" : attributeName;\n    decode +=\n      \"    st = czm_decompressTextureCoordinates(\" + stComponent + \");\\n\";\n  }\n\n  if (containsNormal && containsTangent && containsBitangent) {\n    globalDecl += \"vec3 normal;\\n\" + \"vec3 tangent;\\n\" + \"vec3 bitangent;\\n\";\n    decode +=\n      \"    czm_octDecode(\" +\n      attributeName +\n      \".\" +\n      (containsSt ? \"yz\" : \"xy\") +\n      \", normal, tangent, bitangent);\\n\";\n  } else {\n    if (containsNormal) {\n      globalDecl += \"vec3 normal;\\n\";\n      decode +=\n        \"    normal = czm_octDecode(\" +\n        attributeName +\n        (numComponents > 1 ? \".\" + (containsSt ? \"y\" : \"x\") : \"\") +\n        \");\\n\";\n    }\n\n    if (containsTangent) {\n      globalDecl += \"vec3 tangent;\\n\";\n      decode +=\n        \"    tangent = czm_octDecode(\" +\n        attributeName +\n        \".\" +\n        (containsSt && containsNormal ? \"z\" : \"y\") +\n        \");\\n\";\n    }\n\n    if (containsBitangent) {\n      globalDecl += \"vec3 bitangent;\\n\";\n      decode +=\n        \"    bitangent = czm_octDecode(\" +\n        attributeName +\n        \".\" +\n        (containsSt && containsNormal ? \"z\" : \"y\") +\n        \");\\n\";\n    }\n  }\n\n  var modifiedVS = vertexShaderSource;\n  modifiedVS = modifiedVS.replace(/attribute\\s+vec3\\s+normal;/g, \"\");\n  modifiedVS = modifiedVS.replace(/attribute\\s+vec2\\s+st;/g, \"\");\n  modifiedVS = modifiedVS.replace(/attribute\\s+vec3\\s+tangent;/g, \"\");\n  modifiedVS = modifiedVS.replace(/attribute\\s+vec3\\s+bitangent;/g, \"\");\n  modifiedVS = ShaderSource.replaceMain(modifiedVS, \"czm_non_compressed_main\");\n  var compressedMain =\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    decode +\n    \"    czm_non_compressed_main(); \\n\" +\n    \"}\";\n\n  return [attributeDecl, globalDecl, modifiedVS, compressedMain].join(\"\\n\");\n}\n\nfunction depthClampVS(vertexShaderSource) {\n  var modifiedVS = ShaderSource.replaceMain(\n    vertexShaderSource,\n    \"czm_non_depth_clamp_main\"\n  );\n  // The varying should be surround by #ifdef GL_EXT_frag_depth as an optimization.\n  // It is not to workaround an issue with Edge:\n  //     https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12120362/\n  modifiedVS +=\n    \"varying float v_WindowZ;\\n\" +\n    \"void main() {\\n\" +\n    \"    czm_non_depth_clamp_main();\\n\" +\n    \"    vec4 position = gl_Position;\\n\" +\n    \"    v_WindowZ = (0.5 * (position.z / position.w) + 0.5) * position.w;\\n\" +\n    \"    position.z = min(position.z, position.w);\\n\" +\n    \"    gl_Position = position;\\n\" +\n    \"}\\n\";\n  return modifiedVS;\n}\n\nfunction depthClampFS(fragmentShaderSource) {\n  var modifiedFS = ShaderSource.replaceMain(\n    fragmentShaderSource,\n    \"czm_non_depth_clamp_main\"\n  );\n  modifiedFS +=\n    \"varying float v_WindowZ;\\n\" +\n    \"void main() {\\n\" +\n    \"    czm_non_depth_clamp_main();\\n\" +\n    \"#if defined(GL_EXT_frag_depth)\\n\" +\n    \"    #if defined(LOG_DEPTH)\\n\" +\n    \"        czm_writeLogDepth();\\n\" +\n    \"    #else\\n\" +\n    \"        gl_FragDepthEXT = min(v_WindowZ * gl_FragCoord.w, 1.0);\\n\" +\n    \"    #endif\\n\" +\n    \"#endif\\n\" +\n    \"}\\n\";\n  modifiedFS =\n    \"#ifdef GL_EXT_frag_depth\\n\" +\n    \"#extension GL_EXT_frag_depth : enable\\n\" +\n    \"#endif\\n\" +\n    modifiedFS;\n  return modifiedFS;\n}\n\nfunction validateShaderMatching(shaderProgram, attributeLocations) {\n  // For a VAO and shader program to be compatible, the VAO must have\n  // all active attribute in the shader program.  The VAO may have\n  // extra attributes with the only concern being a potential\n  // performance hit due to extra memory bandwidth and cache pollution.\n  // The shader source could have extra attributes that are not used,\n  // but there is no guarantee they will be optimized out.\n  //\n  // Here, we validate that the VAO has all attributes required\n  // to match the shader program.\n  var shaderAttributes = shaderProgram.vertexAttributes;\n\n  //>>includeStart('debug', pragmas.debug);\n  for (var name in shaderAttributes) {\n    if (shaderAttributes.hasOwnProperty(name)) {\n      if (!defined(attributeLocations[name])) {\n        throw new DeveloperError(\n          \"Appearance/Geometry mismatch.  The appearance requires vertex shader attribute input '\" +\n            name +\n            \"', which was not computed as part of the Geometry.  Use the appearance's vertexFormat property when constructing the geometry.\"\n        );\n      }\n    }\n  }\n  //>>includeEnd('debug');\n}\n\nfunction getUniformFunction(uniforms, name) {\n  return function () {\n    return uniforms[name];\n  };\n}\n\nvar numberOfCreationWorkers = Math.max(\n  FeatureDetection.hardwareConcurrency - 1,\n  1\n);\nvar createGeometryTaskProcessors;\nvar combineGeometryTaskProcessor = new TaskProcessor(\n  \"combineGeometry\",\n  Number.POSITIVE_INFINITY\n);\n\nfunction loadAsynchronous(primitive, frameState) {\n  var instances;\n  var geometry;\n  var i;\n  var j;\n\n  var instanceIds = primitive._instanceIds;\n\n  if (primitive._state === PrimitiveState.READY) {\n    instances = Array.isArray(primitive.geometryInstances)\n      ? primitive.geometryInstances\n      : [primitive.geometryInstances];\n    var length = (primitive._numberOfInstances = instances.length);\n\n    var promises = [];\n    var subTasks = [];\n    for (i = 0; i < length; ++i) {\n      geometry = instances[i].geometry;\n      instanceIds.push(instances[i].id);\n\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(geometry._workerName)) {\n        throw new DeveloperError(\n          \"_workerName must be defined for asynchronous geometry.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      subTasks.push({\n        moduleName: geometry._workerName,\n        geometry: geometry,\n      });\n    }\n\n    if (!defined(createGeometryTaskProcessors)) {\n      createGeometryTaskProcessors = new Array(numberOfCreationWorkers);\n      for (i = 0; i < numberOfCreationWorkers; i++) {\n        createGeometryTaskProcessors[i] = new TaskProcessor(\n          \"createGeometry\",\n          Number.POSITIVE_INFINITY\n        );\n      }\n    }\n\n    var subTask;\n    subTasks = subdivideArray(subTasks, numberOfCreationWorkers);\n\n    for (i = 0; i < subTasks.length; i++) {\n      var packedLength = 0;\n      var workerSubTasks = subTasks[i];\n      var workerSubTasksLength = workerSubTasks.length;\n      for (j = 0; j < workerSubTasksLength; ++j) {\n        subTask = workerSubTasks[j];\n        geometry = subTask.geometry;\n        if (defined(geometry.constructor.pack)) {\n          subTask.offset = packedLength;\n          packedLength += defaultValue(\n            geometry.constructor.packedLength,\n            geometry.packedLength\n          );\n        }\n      }\n\n      var subTaskTransferableObjects;\n\n      if (packedLength > 0) {\n        var array = new Float64Array(packedLength);\n        subTaskTransferableObjects = [array.buffer];\n\n        for (j = 0; j < workerSubTasksLength; ++j) {\n          subTask = workerSubTasks[j];\n          geometry = subTask.geometry;\n          if (defined(geometry.constructor.pack)) {\n            geometry.constructor.pack(geometry, array, subTask.offset);\n            subTask.geometry = array;\n          }\n        }\n      }\n\n      promises.push(\n        createGeometryTaskProcessors[i].scheduleTask(\n          {\n            subTasks: subTasks[i],\n          },\n          subTaskTransferableObjects\n        )\n      );\n    }\n\n    primitive._state = PrimitiveState.CREATING;\n\n    when\n      .all(promises, function (results) {\n        primitive._createGeometryResults = results;\n        primitive._state = PrimitiveState.CREATED;\n      })\n      .otherwise(function (error) {\n        setReady(primitive, frameState, PrimitiveState.FAILED, error);\n      });\n  } else if (primitive._state === PrimitiveState.CREATED) {\n    var transferableObjects = [];\n    instances = Array.isArray(primitive.geometryInstances)\n      ? primitive.geometryInstances\n      : [primitive.geometryInstances];\n\n    var scene3DOnly = frameState.scene3DOnly;\n    var projection = frameState.mapProjection;\n\n    var promise = combineGeometryTaskProcessor.scheduleTask(\n      PrimitivePipeline.packCombineGeometryParameters(\n        {\n          createGeometryResults: primitive._createGeometryResults,\n          instances: instances,\n          ellipsoid: projection.ellipsoid,\n          projection: projection,\n          elementIndexUintSupported: frameState.context.elementIndexUint,\n          scene3DOnly: scene3DOnly,\n          vertexCacheOptimize: primitive.vertexCacheOptimize,\n          compressVertices: primitive.compressVertices,\n          modelMatrix: primitive.modelMatrix,\n          createPickOffsets: primitive._createPickOffsets,\n        },\n        transferableObjects\n      ),\n      transferableObjects\n    );\n\n    primitive._createGeometryResults = undefined;\n    primitive._state = PrimitiveState.COMBINING;\n\n    when(promise, function (packedResult) {\n      var result = PrimitivePipeline.unpackCombineGeometryResults(packedResult);\n      primitive._geometries = result.geometries;\n      primitive._attributeLocations = result.attributeLocations;\n      primitive.modelMatrix = Matrix4.clone(\n        result.modelMatrix,\n        primitive.modelMatrix\n      );\n      primitive._pickOffsets = result.pickOffsets;\n      primitive._offsetInstanceExtend = result.offsetInstanceExtend;\n      primitive._instanceBoundingSpheres = result.boundingSpheres;\n      primitive._instanceBoundingSpheresCV = result.boundingSpheresCV;\n\n      if (defined(primitive._geometries) && primitive._geometries.length > 0) {\n        primitive._recomputeBoundingSpheres = true;\n        primitive._state = PrimitiveState.COMBINED;\n      } else {\n        setReady(primitive, frameState, PrimitiveState.FAILED, undefined);\n      }\n    }).otherwise(function (error) {\n      setReady(primitive, frameState, PrimitiveState.FAILED, error);\n    });\n  }\n}\n\nfunction loadSynchronous(primitive, frameState) {\n  var instances = Array.isArray(primitive.geometryInstances)\n    ? primitive.geometryInstances\n    : [primitive.geometryInstances];\n  var length = (primitive._numberOfInstances = instances.length);\n  var clonedInstances = new Array(length);\n  var instanceIds = primitive._instanceIds;\n\n  var instance;\n  var i;\n\n  var geometryIndex = 0;\n  for (i = 0; i < length; i++) {\n    instance = instances[i];\n    var geometry = instance.geometry;\n\n    var createdGeometry;\n    if (defined(geometry.attributes) && defined(geometry.primitiveType)) {\n      createdGeometry = cloneGeometry(geometry);\n    } else {\n      createdGeometry = geometry.constructor.createGeometry(geometry);\n    }\n\n    clonedInstances[geometryIndex++] = cloneInstance(instance, createdGeometry);\n    instanceIds.push(instance.id);\n  }\n\n  clonedInstances.length = geometryIndex;\n\n  var scene3DOnly = frameState.scene3DOnly;\n  var projection = frameState.mapProjection;\n\n  var result = PrimitivePipeline.combineGeometry({\n    instances: clonedInstances,\n    ellipsoid: projection.ellipsoid,\n    projection: projection,\n    elementIndexUintSupported: frameState.context.elementIndexUint,\n    scene3DOnly: scene3DOnly,\n    vertexCacheOptimize: primitive.vertexCacheOptimize,\n    compressVertices: primitive.compressVertices,\n    modelMatrix: primitive.modelMatrix,\n    createPickOffsets: primitive._createPickOffsets,\n  });\n\n  primitive._geometries = result.geometries;\n  primitive._attributeLocations = result.attributeLocations;\n  primitive.modelMatrix = Matrix4.clone(\n    result.modelMatrix,\n    primitive.modelMatrix\n  );\n  primitive._pickOffsets = result.pickOffsets;\n  primitive._offsetInstanceExtend = result.offsetInstanceExtend;\n  primitive._instanceBoundingSpheres = result.boundingSpheres;\n  primitive._instanceBoundingSpheresCV = result.boundingSpheresCV;\n\n  if (defined(primitive._geometries) && primitive._geometries.length > 0) {\n    primitive._recomputeBoundingSpheres = true;\n    primitive._state = PrimitiveState.COMBINED;\n  } else {\n    setReady(primitive, frameState, PrimitiveState.FAILED, undefined);\n  }\n}\n\nfunction recomputeBoundingSpheres(primitive, frameState) {\n  var offsetIndex = primitive._batchTableAttributeIndices.offset;\n  if (!primitive._recomputeBoundingSpheres || !defined(offsetIndex)) {\n    primitive._recomputeBoundingSpheres = false;\n    return;\n  }\n\n  var i;\n  var offsetInstanceExtend = primitive._offsetInstanceExtend;\n  var boundingSpheres = primitive._instanceBoundingSpheres;\n  var length = boundingSpheres.length;\n  var newBoundingSpheres = primitive._tempBoundingSpheres;\n  if (!defined(newBoundingSpheres)) {\n    newBoundingSpheres = new Array(length);\n    for (i = 0; i < length; i++) {\n      newBoundingSpheres[i] = new BoundingSphere();\n    }\n    primitive._tempBoundingSpheres = newBoundingSpheres;\n  }\n  for (i = 0; i < length; ++i) {\n    var newBS = newBoundingSpheres[i];\n    var offset = primitive._batchTable.getBatchedAttribute(\n      i,\n      offsetIndex,\n      new Cartesian3()\n    );\n    newBS = boundingSpheres[i].clone(newBS);\n    transformBoundingSphere(newBS, offset, offsetInstanceExtend[i]);\n  }\n  var combinedBS = [];\n  var combinedWestBS = [];\n  var combinedEastBS = [];\n\n  for (i = 0; i < length; ++i) {\n    var bs = newBoundingSpheres[i];\n\n    var minX = bs.center.x - bs.radius;\n    if (\n      minX > 0 ||\n      BoundingSphere.intersectPlane(bs, Plane.ORIGIN_ZX_PLANE) !==\n        Intersect.INTERSECTING\n    ) {\n      combinedBS.push(bs);\n    } else {\n      combinedWestBS.push(bs);\n      combinedEastBS.push(bs);\n    }\n  }\n\n  var resultBS1 = combinedBS[0];\n  var resultBS2 = combinedEastBS[0];\n  var resultBS3 = combinedWestBS[0];\n\n  for (i = 1; i < combinedBS.length; i++) {\n    resultBS1 = BoundingSphere.union(resultBS1, combinedBS[i]);\n  }\n  for (i = 1; i < combinedEastBS.length; i++) {\n    resultBS2 = BoundingSphere.union(resultBS2, combinedEastBS[i]);\n  }\n  for (i = 1; i < combinedWestBS.length; i++) {\n    resultBS3 = BoundingSphere.union(resultBS3, combinedWestBS[i]);\n  }\n  var result = [];\n  if (defined(resultBS1)) {\n    result.push(resultBS1);\n  }\n  if (defined(resultBS2)) {\n    result.push(resultBS2);\n  }\n  if (defined(resultBS3)) {\n    result.push(resultBS3);\n  }\n\n  for (i = 0; i < result.length; i++) {\n    var boundingSphere = result[i].clone(primitive._boundingSpheres[i]);\n    primitive._boundingSpheres[i] = boundingSphere;\n    primitive._boundingSphereCV[i] = BoundingSphere.projectTo2D(\n      boundingSphere,\n      frameState.mapProjection,\n      primitive._boundingSphereCV[i]\n    );\n  }\n\n  Primitive._updateBoundingVolumes(\n    primitive,\n    frameState,\n    primitive.modelMatrix,\n    true\n  );\n  primitive._recomputeBoundingSpheres = false;\n}\n\nvar scratchBoundingSphereCenterEncoded = new EncodedCartesian3();\nvar scratchBoundingSphereCartographic = new Cartographic();\nvar scratchBoundingSphereCenter2D = new Cartesian3();\nvar scratchBoundingSphere = new BoundingSphere();\n\nfunction updateBatchTableBoundingSpheres(primitive, frameState) {\n  var hasDistanceDisplayCondition = defined(\n    primitive._batchTableAttributeIndices.distanceDisplayCondition\n  );\n  if (\n    !hasDistanceDisplayCondition ||\n    primitive._batchTableBoundingSpheresUpdated\n  ) {\n    return;\n  }\n\n  var indices = primitive._batchTableBoundingSphereAttributeIndices;\n  var center3DHighIndex = indices.center3DHigh;\n  var center3DLowIndex = indices.center3DLow;\n  var center2DHighIndex = indices.center2DHigh;\n  var center2DLowIndex = indices.center2DLow;\n  var radiusIndex = indices.radius;\n\n  var projection = frameState.mapProjection;\n  var ellipsoid = projection.ellipsoid;\n\n  var batchTable = primitive._batchTable;\n  var boundingSpheres = primitive._instanceBoundingSpheres;\n  var length = boundingSpheres.length;\n\n  for (var i = 0; i < length; ++i) {\n    var boundingSphere = boundingSpheres[i];\n    if (!defined(boundingSphere)) {\n      continue;\n    }\n\n    var modelMatrix = primitive.modelMatrix;\n    if (defined(modelMatrix)) {\n      boundingSphere = BoundingSphere.transform(\n        boundingSphere,\n        modelMatrix,\n        scratchBoundingSphere\n      );\n    }\n\n    var center = boundingSphere.center;\n    var radius = boundingSphere.radius;\n\n    var encodedCenter = EncodedCartesian3.fromCartesian(\n      center,\n      scratchBoundingSphereCenterEncoded\n    );\n    batchTable.setBatchedAttribute(i, center3DHighIndex, encodedCenter.high);\n    batchTable.setBatchedAttribute(i, center3DLowIndex, encodedCenter.low);\n\n    if (!frameState.scene3DOnly) {\n      var cartographic = ellipsoid.cartesianToCartographic(\n        center,\n        scratchBoundingSphereCartographic\n      );\n      var center2D = projection.project(\n        cartographic,\n        scratchBoundingSphereCenter2D\n      );\n      encodedCenter = EncodedCartesian3.fromCartesian(\n        center2D,\n        scratchBoundingSphereCenterEncoded\n      );\n      batchTable.setBatchedAttribute(i, center2DHighIndex, encodedCenter.high);\n      batchTable.setBatchedAttribute(i, center2DLowIndex, encodedCenter.low);\n    }\n\n    batchTable.setBatchedAttribute(i, radiusIndex, radius);\n  }\n\n  primitive._batchTableBoundingSpheresUpdated = true;\n}\n\nvar offsetScratchCartesian = new Cartesian3();\nvar offsetCenterScratch = new Cartesian3();\nfunction updateBatchTableOffsets(primitive, frameState) {\n  var hasOffset = defined(primitive._batchTableAttributeIndices.offset);\n  if (\n    !hasOffset ||\n    primitive._batchTableOffsetsUpdated ||\n    frameState.scene3DOnly\n  ) {\n    return;\n  }\n\n  var index2D = primitive._batchTableOffsetAttribute2DIndex;\n\n  var projection = frameState.mapProjection;\n  var ellipsoid = projection.ellipsoid;\n\n  var batchTable = primitive._batchTable;\n  var boundingSpheres = primitive._instanceBoundingSpheres;\n  var length = boundingSpheres.length;\n\n  for (var i = 0; i < length; ++i) {\n    var boundingSphere = boundingSpheres[i];\n    if (!defined(boundingSphere)) {\n      continue;\n    }\n    var offset = batchTable.getBatchedAttribute(\n      i,\n      primitive._batchTableAttributeIndices.offset\n    );\n    if (Cartesian3.equals(offset, Cartesian3.ZERO)) {\n      batchTable.setBatchedAttribute(i, index2D, Cartesian3.ZERO);\n      continue;\n    }\n\n    var modelMatrix = primitive.modelMatrix;\n    if (defined(modelMatrix)) {\n      boundingSphere = BoundingSphere.transform(\n        boundingSphere,\n        modelMatrix,\n        scratchBoundingSphere\n      );\n    }\n\n    var center = boundingSphere.center;\n    center = ellipsoid.scaleToGeodeticSurface(center, offsetCenterScratch);\n    var cartographic = ellipsoid.cartesianToCartographic(\n      center,\n      scratchBoundingSphereCartographic\n    );\n    var center2D = projection.project(\n      cartographic,\n      scratchBoundingSphereCenter2D\n    );\n\n    var newPoint = Cartesian3.add(offset, center, offsetScratchCartesian);\n    cartographic = ellipsoid.cartesianToCartographic(newPoint, cartographic);\n\n    var newPointProjected = projection.project(\n      cartographic,\n      offsetScratchCartesian\n    );\n\n    var newVector = Cartesian3.subtract(\n      newPointProjected,\n      center2D,\n      offsetScratchCartesian\n    );\n\n    var x = newVector.x;\n    newVector.x = newVector.z;\n    newVector.z = newVector.y;\n    newVector.y = x;\n\n    batchTable.setBatchedAttribute(i, index2D, newVector);\n  }\n\n  primitive._batchTableOffsetsUpdated = true;\n}\n\nfunction createVertexArray(primitive, frameState) {\n  var attributeLocations = primitive._attributeLocations;\n  var geometries = primitive._geometries;\n  var scene3DOnly = frameState.scene3DOnly;\n  var context = frameState.context;\n\n  var va = [];\n  var length = geometries.length;\n  for (var i = 0; i < length; ++i) {\n    var geometry = geometries[i];\n\n    va.push(\n      VertexArray.fromGeometry({\n        context: context,\n        geometry: geometry,\n        attributeLocations: attributeLocations,\n        bufferUsage: BufferUsage.STATIC_DRAW,\n        interleave: primitive._interleave,\n      })\n    );\n\n    if (defined(primitive._createBoundingVolumeFunction)) {\n      primitive._createBoundingVolumeFunction(frameState, geometry);\n    } else {\n      primitive._boundingSpheres.push(\n        BoundingSphere.clone(geometry.boundingSphere)\n      );\n      primitive._boundingSphereWC.push(new BoundingSphere());\n\n      if (!scene3DOnly) {\n        var center = geometry.boundingSphereCV.center;\n        var x = center.x;\n        var y = center.y;\n        var z = center.z;\n        center.x = z;\n        center.y = x;\n        center.z = y;\n\n        primitive._boundingSphereCV.push(\n          BoundingSphere.clone(geometry.boundingSphereCV)\n        );\n        primitive._boundingSphere2D.push(new BoundingSphere());\n        primitive._boundingSphereMorph.push(new BoundingSphere());\n      }\n    }\n  }\n\n  primitive._va = va;\n  primitive._primitiveType = geometries[0].primitiveType;\n\n  if (primitive.releaseGeometryInstances) {\n    primitive.geometryInstances = undefined;\n  }\n\n  primitive._geometries = undefined;\n  setReady(primitive, frameState, PrimitiveState.COMPLETE, undefined);\n}\n\nfunction createRenderStates(primitive, context, appearance, twoPasses) {\n  var renderState = appearance.getRenderState();\n  var rs;\n\n  if (twoPasses) {\n    rs = clone(renderState, false);\n    rs.cull = {\n      enabled: true,\n      face: CullFace.BACK,\n    };\n    primitive._frontFaceRS = RenderState.fromCache(rs);\n\n    rs.cull.face = CullFace.FRONT;\n    primitive._backFaceRS = RenderState.fromCache(rs);\n  } else {\n    primitive._frontFaceRS = RenderState.fromCache(renderState);\n    primitive._backFaceRS = primitive._frontFaceRS;\n  }\n\n  rs = clone(renderState, false);\n  if (defined(primitive._depthFailAppearance)) {\n    rs.depthTest.enabled = false;\n  }\n\n  if (defined(primitive._depthFailAppearance)) {\n    renderState = primitive._depthFailAppearance.getRenderState();\n    rs = clone(renderState, false);\n    rs.depthTest.func = DepthFunction.GREATER;\n    if (twoPasses) {\n      rs.cull = {\n        enabled: true,\n        face: CullFace.BACK,\n      };\n      primitive._frontFaceDepthFailRS = RenderState.fromCache(rs);\n\n      rs.cull.face = CullFace.FRONT;\n      primitive._backFaceDepthFailRS = RenderState.fromCache(rs);\n    } else {\n      primitive._frontFaceDepthFailRS = RenderState.fromCache(rs);\n      primitive._backFaceDepthFailRS = primitive._frontFaceRS;\n    }\n  }\n}\n\nfunction createShaderProgram(primitive, frameState, appearance) {\n  var context = frameState.context;\n\n  var attributeLocations = primitive._attributeLocations;\n\n  var vs = primitive._batchTable.getVertexShaderCallback()(\n    appearance.vertexShaderSource\n  );\n  vs = Primitive._appendOffsetToShader(primitive, vs);\n  vs = Primitive._appendShowToShader(primitive, vs);\n  vs = Primitive._appendDistanceDisplayConditionToShader(\n    primitive,\n    vs,\n    frameState.scene3DOnly\n  );\n  vs = appendPickToVertexShader(vs);\n  vs = Primitive._updateColorAttribute(primitive, vs, false);\n  vs = modifyForEncodedNormals(primitive, vs);\n  vs = Primitive._modifyShaderPosition(primitive, vs, frameState.scene3DOnly);\n  var fs = appearance.getFragmentShaderSource();\n  fs = appendPickToFragmentShader(fs);\n\n  primitive._sp = ShaderProgram.replaceCache({\n    context: context,\n    shaderProgram: primitive._sp,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n  validateShaderMatching(primitive._sp, attributeLocations);\n\n  if (defined(primitive._depthFailAppearance)) {\n    vs = primitive._batchTable.getVertexShaderCallback()(\n      primitive._depthFailAppearance.vertexShaderSource\n    );\n    vs = Primitive._appendShowToShader(primitive, vs);\n    vs = Primitive._appendDistanceDisplayConditionToShader(\n      primitive,\n      vs,\n      frameState.scene3DOnly\n    );\n    vs = appendPickToVertexShader(vs);\n    vs = Primitive._updateColorAttribute(primitive, vs, true);\n    vs = modifyForEncodedNormals(primitive, vs);\n    vs = Primitive._modifyShaderPosition(primitive, vs, frameState.scene3DOnly);\n    vs = depthClampVS(vs);\n\n    fs = primitive._depthFailAppearance.getFragmentShaderSource();\n    fs = appendPickToFragmentShader(fs);\n    fs = depthClampFS(fs);\n\n    primitive._spDepthFail = ShaderProgram.replaceCache({\n      context: context,\n      shaderProgram: primitive._spDepthFail,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n      attributeLocations: attributeLocations,\n    });\n    validateShaderMatching(primitive._spDepthFail, attributeLocations);\n  }\n}\n\nvar modifiedModelViewScratch = new Matrix4();\nvar rtcScratch = new Cartesian3();\n\nfunction getUniforms(primitive, appearance, material, frameState) {\n  // Create uniform map by combining uniforms from the appearance and material if either have uniforms.\n  var materialUniformMap = defined(material) ? material._uniforms : undefined;\n  var appearanceUniformMap = {};\n  var appearanceUniforms = appearance.uniforms;\n  if (defined(appearanceUniforms)) {\n    // Convert to uniform map of functions for the renderer\n    for (var name in appearanceUniforms) {\n      if (appearanceUniforms.hasOwnProperty(name)) {\n        //>>includeStart('debug', pragmas.debug);\n        if (defined(materialUniformMap) && defined(materialUniformMap[name])) {\n          // Later, we could rename uniforms behind-the-scenes if needed.\n          throw new DeveloperError(\n            \"Appearance and material have a uniform with the same name: \" + name\n          );\n        }\n        //>>includeEnd('debug');\n\n        appearanceUniformMap[name] = getUniformFunction(\n          appearanceUniforms,\n          name\n        );\n      }\n    }\n  }\n  var uniforms = combine(appearanceUniformMap, materialUniformMap);\n  uniforms = primitive._batchTable.getUniformMapCallback()(uniforms);\n\n  if (defined(primitive.rtcCenter)) {\n    uniforms.u_modifiedModelView = function () {\n      var viewMatrix = frameState.context.uniformState.view;\n      Matrix4.multiply(\n        viewMatrix,\n        primitive._modelMatrix,\n        modifiedModelViewScratch\n      );\n      Matrix4.multiplyByPoint(\n        modifiedModelViewScratch,\n        primitive.rtcCenter,\n        rtcScratch\n      );\n      Matrix4.setTranslation(\n        modifiedModelViewScratch,\n        rtcScratch,\n        modifiedModelViewScratch\n      );\n      return modifiedModelViewScratch;\n    };\n  }\n\n  return uniforms;\n}\n\nfunction createCommands(\n  primitive,\n  appearance,\n  material,\n  translucent,\n  twoPasses,\n  colorCommands,\n  pickCommands,\n  frameState\n) {\n  var uniforms = getUniforms(primitive, appearance, material, frameState);\n\n  var depthFailUniforms;\n  if (defined(primitive._depthFailAppearance)) {\n    depthFailUniforms = getUniforms(\n      primitive,\n      primitive._depthFailAppearance,\n      primitive._depthFailAppearance.material,\n      frameState\n    );\n  }\n\n  var pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;\n\n  var multiplier = twoPasses ? 2 : 1;\n  multiplier *= defined(primitive._depthFailAppearance) ? 2 : 1;\n  colorCommands.length = primitive._va.length * multiplier;\n\n  var length = colorCommands.length;\n  var vaIndex = 0;\n  for (var i = 0; i < length; ++i) {\n    var colorCommand;\n\n    if (twoPasses) {\n      colorCommand = colorCommands[i];\n      if (!defined(colorCommand)) {\n        colorCommand = colorCommands[i] = new DrawCommand({\n          owner: primitive,\n          primitiveType: primitive._primitiveType,\n        });\n      }\n      colorCommand.vertexArray = primitive._va[vaIndex];\n      colorCommand.renderState = primitive._backFaceRS;\n      colorCommand.shaderProgram = primitive._sp;\n      colorCommand.uniformMap = uniforms;\n      colorCommand.pass = pass;\n\n      ++i;\n    }\n\n    colorCommand = colorCommands[i];\n    if (!defined(colorCommand)) {\n      colorCommand = colorCommands[i] = new DrawCommand({\n        owner: primitive,\n        primitiveType: primitive._primitiveType,\n      });\n    }\n    colorCommand.vertexArray = primitive._va[vaIndex];\n    colorCommand.renderState = primitive._frontFaceRS;\n    colorCommand.shaderProgram = primitive._sp;\n    colorCommand.uniformMap = uniforms;\n    colorCommand.pass = pass;\n\n    if (defined(primitive._depthFailAppearance)) {\n      if (twoPasses) {\n        ++i;\n\n        colorCommand = colorCommands[i];\n        if (!defined(colorCommand)) {\n          colorCommand = colorCommands[i] = new DrawCommand({\n            owner: primitive,\n            primitiveType: primitive._primitiveType,\n          });\n        }\n        colorCommand.vertexArray = primitive._va[vaIndex];\n        colorCommand.renderState = primitive._backFaceDepthFailRS;\n        colorCommand.shaderProgram = primitive._spDepthFail;\n        colorCommand.uniformMap = depthFailUniforms;\n        colorCommand.pass = pass;\n      }\n\n      ++i;\n\n      colorCommand = colorCommands[i];\n      if (!defined(colorCommand)) {\n        colorCommand = colorCommands[i] = new DrawCommand({\n          owner: primitive,\n          primitiveType: primitive._primitiveType,\n        });\n      }\n      colorCommand.vertexArray = primitive._va[vaIndex];\n      colorCommand.renderState = primitive._frontFaceDepthFailRS;\n      colorCommand.shaderProgram = primitive._spDepthFail;\n      colorCommand.uniformMap = depthFailUniforms;\n      colorCommand.pass = pass;\n    }\n\n    ++vaIndex;\n  }\n}\n\nPrimitive._updateBoundingVolumes = function (\n  primitive,\n  frameState,\n  modelMatrix,\n  forceUpdate\n) {\n  var i;\n  var length;\n  var boundingSphere;\n\n  if (forceUpdate || !Matrix4.equals(modelMatrix, primitive._modelMatrix)) {\n    Matrix4.clone(modelMatrix, primitive._modelMatrix);\n    length = primitive._boundingSpheres.length;\n    for (i = 0; i < length; ++i) {\n      boundingSphere = primitive._boundingSpheres[i];\n      if (defined(boundingSphere)) {\n        primitive._boundingSphereWC[i] = BoundingSphere.transform(\n          boundingSphere,\n          modelMatrix,\n          primitive._boundingSphereWC[i]\n        );\n        if (!frameState.scene3DOnly) {\n          primitive._boundingSphere2D[i] = BoundingSphere.clone(\n            primitive._boundingSphereCV[i],\n            primitive._boundingSphere2D[i]\n          );\n          primitive._boundingSphere2D[i].center.x = 0.0;\n          primitive._boundingSphereMorph[i] = BoundingSphere.union(\n            primitive._boundingSphereWC[i],\n            primitive._boundingSphereCV[i]\n          );\n        }\n      }\n    }\n  }\n\n  // Update bounding volumes for primitives that are sized in pixels.\n  // The pixel size in meters varies based on the distance from the camera.\n  var pixelSize = primitive.appearance.pixelSize;\n  if (defined(pixelSize)) {\n    length = primitive._boundingSpheres.length;\n    for (i = 0; i < length; ++i) {\n      boundingSphere = primitive._boundingSpheres[i];\n      var boundingSphereWC = primitive._boundingSphereWC[i];\n      var pixelSizeInMeters = frameState.camera.getPixelSize(\n        boundingSphere,\n        frameState.context.drawingBufferWidth,\n        frameState.context.drawingBufferHeight\n      );\n      var sizeInMeters = pixelSizeInMeters * pixelSize;\n      boundingSphereWC.radius = boundingSphere.radius + sizeInMeters;\n    }\n  }\n};\n\nfunction updateAndQueueCommands(\n  primitive,\n  frameState,\n  colorCommands,\n  pickCommands,\n  modelMatrix,\n  cull,\n  debugShowBoundingVolume,\n  twoPasses\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    frameState.mode !== SceneMode.SCENE3D &&\n    !Matrix4.equals(modelMatrix, Matrix4.IDENTITY)\n  ) {\n    throw new DeveloperError(\n      \"Primitive.modelMatrix is only supported in 3D mode.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  Primitive._updateBoundingVolumes(primitive, frameState, modelMatrix);\n\n  var boundingSpheres;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingSpheres = primitive._boundingSphereWC;\n  } else if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n    boundingSpheres = primitive._boundingSphereCV;\n  } else if (\n    frameState.mode === SceneMode.SCENE2D &&\n    defined(primitive._boundingSphere2D)\n  ) {\n    boundingSpheres = primitive._boundingSphere2D;\n  } else if (defined(primitive._boundingSphereMorph)) {\n    boundingSpheres = primitive._boundingSphereMorph;\n  }\n\n  var commandList = frameState.commandList;\n  var passes = frameState.passes;\n  if (passes.render || passes.pick) {\n    var allowPicking = primitive.allowPicking;\n    var castShadows = ShadowMode.castShadows(primitive.shadows);\n    var receiveShadows = ShadowMode.receiveShadows(primitive.shadows);\n    var colorLength = colorCommands.length;\n\n    var factor = twoPasses ? 2 : 1;\n    factor *= defined(primitive._depthFailAppearance) ? 2 : 1;\n\n    for (var j = 0; j < colorLength; ++j) {\n      var sphereIndex = Math.floor(j / factor);\n      var colorCommand = colorCommands[j];\n      colorCommand.modelMatrix = modelMatrix;\n      colorCommand.boundingVolume = boundingSpheres[sphereIndex];\n      colorCommand.cull = cull;\n      colorCommand.debugShowBoundingVolume = debugShowBoundingVolume;\n      colorCommand.castShadows = castShadows;\n      colorCommand.receiveShadows = receiveShadows;\n\n      if (allowPicking) {\n        colorCommand.pickId = \"v_pickColor\";\n      } else {\n        colorCommand.pickId = undefined;\n      }\n\n      commandList.push(colorCommand);\n    }\n  }\n}\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} All instance geometries must have the same primitiveType.\n * @exception {DeveloperError} Appearance and material have a uniform with the same name.\n * @exception {DeveloperError} Primitive.modelMatrix is only supported in 3D mode.\n * @exception {RuntimeError} Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.\n */\nPrimitive.prototype.update = function (frameState) {\n  if (\n    (!defined(this.geometryInstances) && this._va.length === 0) ||\n    (defined(this.geometryInstances) &&\n      Array.isArray(this.geometryInstances) &&\n      this.geometryInstances.length === 0) ||\n    !defined(this.appearance) ||\n    (frameState.mode !== SceneMode.SCENE3D && frameState.scene3DOnly) ||\n    (!frameState.passes.render && !frameState.passes.pick)\n  ) {\n    return;\n  }\n\n  if (defined(this._error)) {\n    throw this._error;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (defined(this.rtcCenter) && !frameState.scene3DOnly) {\n    throw new DeveloperError(\n      \"RTC rendering is only available for 3D only scenes.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (this._state === PrimitiveState.FAILED) {\n    return;\n  }\n\n  var context = frameState.context;\n  if (!defined(this._batchTable)) {\n    createBatchTable(this, context);\n  }\n  if (this._batchTable.attributes.length > 0) {\n    if (ContextLimits.maximumVertexTextureImageUnits === 0) {\n      throw new RuntimeError(\n        \"Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.\"\n      );\n    }\n    this._batchTable.update(frameState);\n  }\n\n  if (\n    this._state !== PrimitiveState.COMPLETE &&\n    this._state !== PrimitiveState.COMBINED\n  ) {\n    if (this.asynchronous) {\n      loadAsynchronous(this, frameState);\n    } else {\n      loadSynchronous(this, frameState);\n    }\n  }\n\n  if (this._state === PrimitiveState.COMBINED) {\n    updateBatchTableBoundingSpheres(this, frameState);\n    updateBatchTableOffsets(this, frameState);\n    createVertexArray(this, frameState);\n  }\n\n  if (!this.show || this._state !== PrimitiveState.COMPLETE) {\n    return;\n  }\n\n  if (!this._batchTableOffsetsUpdated) {\n    updateBatchTableOffsets(this, frameState);\n  }\n  if (this._recomputeBoundingSpheres) {\n    recomputeBoundingSpheres(this, frameState);\n  }\n\n  // Create or recreate render state and shader program if appearance/material changed\n  var appearance = this.appearance;\n  var material = appearance.material;\n  var createRS = false;\n  var createSP = false;\n\n  if (this._appearance !== appearance) {\n    this._appearance = appearance;\n    this._material = material;\n    createRS = true;\n    createSP = true;\n  } else if (this._material !== material) {\n    this._material = material;\n    createSP = true;\n  }\n\n  var depthFailAppearance = this.depthFailAppearance;\n  var depthFailMaterial = defined(depthFailAppearance)\n    ? depthFailAppearance.material\n    : undefined;\n\n  if (this._depthFailAppearance !== depthFailAppearance) {\n    this._depthFailAppearance = depthFailAppearance;\n    this._depthFailMaterial = depthFailMaterial;\n    createRS = true;\n    createSP = true;\n  } else if (this._depthFailMaterial !== depthFailMaterial) {\n    this._depthFailMaterial = depthFailMaterial;\n    createSP = true;\n  }\n\n  var translucent = this._appearance.isTranslucent();\n  if (this._translucent !== translucent) {\n    this._translucent = translucent;\n    createRS = true;\n  }\n\n  if (defined(this._material)) {\n    this._material.update(context);\n  }\n\n  var twoPasses = appearance.closed && translucent;\n\n  if (createRS) {\n    var rsFunc = defaultValue(\n      this._createRenderStatesFunction,\n      createRenderStates\n    );\n    rsFunc(this, context, appearance, twoPasses);\n  }\n\n  if (createSP) {\n    var spFunc = defaultValue(\n      this._createShaderProgramFunction,\n      createShaderProgram\n    );\n    spFunc(this, frameState, appearance);\n  }\n\n  if (createRS || createSP) {\n    var commandFunc = defaultValue(\n      this._createCommandsFunction,\n      createCommands\n    );\n    commandFunc(\n      this,\n      appearance,\n      material,\n      translucent,\n      twoPasses,\n      this._colorCommands,\n      this._pickCommands,\n      frameState\n    );\n  }\n\n  var updateAndQueueCommandsFunc = defaultValue(\n    this._updateAndQueueCommandsFunction,\n    updateAndQueueCommands\n  );\n  updateAndQueueCommandsFunc(\n    this,\n    frameState,\n    this._colorCommands,\n    this._pickCommands,\n    this.modelMatrix,\n    this.cull,\n    this.debugShowBoundingVolume,\n    twoPasses\n  );\n};\n\nvar offsetBoundingSphereScratch1 = new BoundingSphere();\nvar offsetBoundingSphereScratch2 = new BoundingSphere();\nfunction transformBoundingSphere(boundingSphere, offset, offsetAttribute) {\n  if (offsetAttribute === GeometryOffsetAttribute.TOP) {\n    var origBS = BoundingSphere.clone(\n      boundingSphere,\n      offsetBoundingSphereScratch1\n    );\n    var offsetBS = BoundingSphere.clone(\n      boundingSphere,\n      offsetBoundingSphereScratch2\n    );\n    offsetBS.center = Cartesian3.add(offsetBS.center, offset, offsetBS.center);\n    boundingSphere = BoundingSphere.union(origBS, offsetBS, boundingSphere);\n  } else if (offsetAttribute === GeometryOffsetAttribute.ALL) {\n    boundingSphere.center = Cartesian3.add(\n      boundingSphere.center,\n      offset,\n      boundingSphere.center\n    );\n  }\n\n  return boundingSphere;\n}\n\nfunction createGetFunction(batchTable, instanceIndex, attributeIndex) {\n  return function () {\n    var attributeValue = batchTable.getBatchedAttribute(\n      instanceIndex,\n      attributeIndex\n    );\n    var attribute = batchTable.attributes[attributeIndex];\n    var componentsPerAttribute = attribute.componentsPerAttribute;\n    var value = ComponentDatatype.createTypedArray(\n      attribute.componentDatatype,\n      componentsPerAttribute\n    );\n    if (defined(attributeValue.constructor.pack)) {\n      attributeValue.constructor.pack(attributeValue, value, 0);\n    } else {\n      value[0] = attributeValue;\n    }\n    return value;\n  };\n}\n\nfunction createSetFunction(\n  batchTable,\n  instanceIndex,\n  attributeIndex,\n  primitive,\n  name\n) {\n  return function (value) {\n    //>>includeStart('debug', pragmas.debug);\n    if (\n      !defined(value) ||\n      !defined(value.length) ||\n      value.length < 1 ||\n      value.length > 4\n    ) {\n      throw new DeveloperError(\n        \"value must be and array with length between 1 and 4.\"\n      );\n    }\n    //>>includeEnd('debug');\n    var attributeValue = getAttributeValue(value);\n    batchTable.setBatchedAttribute(\n      instanceIndex,\n      attributeIndex,\n      attributeValue\n    );\n    if (name === \"offset\") {\n      primitive._recomputeBoundingSpheres = true;\n      primitive._batchTableOffsetsUpdated = false;\n    }\n  };\n}\n\nvar offsetScratch = new Cartesian3();\n\nfunction createBoundingSphereProperties(primitive, properties, index) {\n  properties.boundingSphere = {\n    get: function () {\n      var boundingSphere = primitive._instanceBoundingSpheres[index];\n      if (defined(boundingSphere)) {\n        boundingSphere = boundingSphere.clone();\n        var modelMatrix = primitive.modelMatrix;\n        var offset = properties.offset;\n        if (defined(offset)) {\n          transformBoundingSphere(\n            boundingSphere,\n            Cartesian3.fromArray(offset.get(), 0, offsetScratch),\n            primitive._offsetInstanceExtend[index]\n          );\n        }\n        if (defined(modelMatrix)) {\n          boundingSphere = BoundingSphere.transform(\n            boundingSphere,\n            modelMatrix\n          );\n        }\n      }\n\n      return boundingSphere;\n    },\n  };\n  properties.boundingSphereCV = {\n    get: function () {\n      return primitive._instanceBoundingSpheresCV[index];\n    },\n  };\n}\n\nfunction createPickIdProperty(primitive, properties, index) {\n  properties.pickId = {\n    get: function () {\n      return primitive._pickIds[index];\n    },\n  };\n}\n\n/**\n * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.\n *\n * @param {*} id The id of the {@link GeometryInstance}.\n * @returns {Object} The typed array in the attribute's format or undefined if the is no instance with id.\n *\n * @exception {DeveloperError} must call update before calling getGeometryInstanceAttributes.\n *\n * @example\n * var attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);\n * attributes.distanceDisplayCondition = Cesium.DistanceDisplayConditionGeometryInstanceAttribute.toValue(100.0, 10000.0);\n * attributes.offset = Cesium.OffsetGeometryInstanceAttribute.toValue(Cartesian3.IDENTITY);\n */\nPrimitive.prototype.getGeometryInstanceAttributes = function (id) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required\");\n  }\n  if (!defined(this._batchTable)) {\n    throw new DeveloperError(\n      \"must call update before calling getGeometryInstanceAttributes\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var index = -1;\n  var lastIndex = this._lastPerInstanceAttributeIndex;\n  var ids = this._instanceIds;\n  var length = ids.length;\n  for (var i = 0; i < length; ++i) {\n    var curIndex = (lastIndex + i) % length;\n    if (id === ids[curIndex]) {\n      index = curIndex;\n      break;\n    }\n  }\n\n  if (index === -1) {\n    return undefined;\n  }\n\n  var attributes = this._perInstanceAttributeCache[index];\n  if (defined(attributes)) {\n    return attributes;\n  }\n\n  var batchTable = this._batchTable;\n  var perInstanceAttributeIndices = this._batchTableAttributeIndices;\n  attributes = {};\n  var properties = {};\n\n  for (var name in perInstanceAttributeIndices) {\n    if (perInstanceAttributeIndices.hasOwnProperty(name)) {\n      var attributeIndex = perInstanceAttributeIndices[name];\n      properties[name] = {\n        get: createGetFunction(batchTable, index, attributeIndex),\n        set: createSetFunction(batchTable, index, attributeIndex, this, name),\n      };\n    }\n  }\n\n  createBoundingSphereProperties(this, properties, index);\n  createPickIdProperty(this, properties, index);\n  Object.defineProperties(attributes, properties);\n\n  this._lastPerInstanceAttributeIndex = index;\n  this._perInstanceAttributeCache[index] = attributes;\n  return attributes;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see Primitive#destroy\n */\nPrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * e = e && e.destroy();\n *\n * @see Primitive#isDestroyed\n */\nPrimitive.prototype.destroy = function () {\n  var length;\n  var i;\n\n  this._sp = this._sp && this._sp.destroy();\n  this._spDepthFail = this._spDepthFail && this._spDepthFail.destroy();\n\n  var va = this._va;\n  length = va.length;\n  for (i = 0; i < length; ++i) {\n    va[i].destroy();\n  }\n  this._va = undefined;\n\n  var pickIds = this._pickIds;\n  length = pickIds.length;\n  for (i = 0; i < length; ++i) {\n    pickIds[i].destroy();\n  }\n  this._pickIds = undefined;\n\n  this._batchTable = this._batchTable && this._batchTable.destroy();\n\n  //These objects may be fairly large and reference other large objects (like Entities)\n  //We explicitly set them to undefined here so that the memory can be freed\n  //even if a reference to the destroyed Primitive has been kept around.\n  this._instanceIds = undefined;\n  this._perInstanceAttributeCache = undefined;\n  this._attributeLocations = undefined;\n\n  return destroyObject(this);\n};\n\nfunction setReady(primitive, frameState, state, error) {\n  primitive._error = error;\n  primitive._state = state;\n  frameState.afterRender.push(function () {\n    primitive._ready =\n      primitive._state === PrimitiveState.COMPLETE ||\n      primitive._state === PrimitiveState.FAILED;\n    if (!defined(error)) {\n      primitive._readyPromise.resolve(primitive);\n    } else {\n      primitive._readyPromise.reject(error);\n    }\n  });\n}\nexport default Primitive;\n"]},"metadata":{},"sourceType":"module"}