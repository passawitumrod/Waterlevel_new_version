{"ast":null,"code":"import ArcType from \"../Core/ArcType.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport Event from \"../Core/Event.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GroundPolylineGeometry from \"../Core/GroundPolylineGeometry.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nimport PolylineGeometry from \"../Core/PolylineGeometry.js\";\nimport PolylinePipeline from \"../Core/PolylinePipeline.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport Entity from \"../DataSources/Entity.js\";\nimport ClassificationType from \"../Scene/ClassificationType.js\";\nimport GroundPolylinePrimitive from \"../Scene/GroundPolylinePrimitive.js\";\nimport PolylineCollection from \"../Scene/PolylineCollection.js\";\nimport PolylineColorAppearance from \"../Scene/PolylineColorAppearance.js\";\nimport PolylineMaterialAppearance from \"../Scene/PolylineMaterialAppearance.js\";\nimport ShadowMode from \"../Scene/ShadowMode.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport ConstantProperty from \"./ConstantProperty.js\";\nimport MaterialProperty from \"./MaterialProperty.js\";\nimport Property from \"./Property.js\";\nvar defaultZIndex = new ConstantProperty(0); //We use this object to create one polyline collection per-scene.\n\nvar polylineCollections = {};\nvar scratchColor = new Color();\nvar defaultMaterial = new ColorMaterialProperty(Color.WHITE);\nvar defaultShow = new ConstantProperty(true);\nvar defaultShadows = new ConstantProperty(ShadowMode.DISABLED);\nvar defaultDistanceDisplayCondition = new ConstantProperty(new DistanceDisplayCondition());\nvar defaultClassificationType = new ConstantProperty(ClassificationType.BOTH);\n\nfunction GeometryOptions() {\n  this.vertexFormat = undefined;\n  this.positions = undefined;\n  this.width = undefined;\n  this.arcType = undefined;\n  this.granularity = undefined;\n}\n\nfunction GroundGeometryOptions() {\n  this.positions = undefined;\n  this.width = undefined;\n  this.arcType = undefined;\n  this.granularity = undefined;\n}\n/**\n * A {@link GeometryUpdater} for polylines.\n * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n * @alias PolylineGeometryUpdater\n * @constructor\n *\n * @param {Entity} entity The entity containing the geometry to be visualized.\n * @param {Scene} scene The scene where visualization is taking place.\n */\n\n\nfunction PolylineGeometryUpdater(entity, scene) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entity)) {\n    throw new DeveloperError(\"entity is required\");\n  }\n\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required\");\n  } //>>includeEnd('debug');\n\n\n  this._entity = entity;\n  this._scene = scene;\n  this._entitySubscription = entity.definitionChanged.addEventListener(PolylineGeometryUpdater.prototype._onEntityPropertyChanged, this);\n  this._fillEnabled = false;\n  this._dynamic = false;\n  this._geometryChanged = new Event();\n  this._showProperty = undefined;\n  this._materialProperty = undefined;\n  this._shadowsProperty = undefined;\n  this._distanceDisplayConditionProperty = undefined;\n  this._classificationTypeProperty = undefined;\n  this._depthFailMaterialProperty = undefined;\n  this._geometryOptions = new GeometryOptions();\n  this._groundGeometryOptions = new GroundGeometryOptions();\n  this._id = \"polyline-\" + entity.id;\n  this._clampToGround = false;\n  this._supportsPolylinesOnTerrain = Entity.supportsPolylinesOnTerrain(scene);\n  this._zIndex = 0;\n\n  this._onEntityPropertyChanged(entity, \"polyline\", entity.polyline, undefined);\n}\n\nObject.defineProperties(PolylineGeometryUpdater.prototype, {\n  /**\n   * Gets the unique ID associated with this updater\n   * @memberof PolylineGeometryUpdater.prototype\n   * @type {String}\n   * @readonly\n   */\n  id: {\n    get: function () {\n      return this._id;\n    }\n  },\n\n  /**\n   * Gets the entity associated with this geometry.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Entity}\n   * @readonly\n   */\n  entity: {\n    get: function () {\n      return this._entity;\n    }\n  },\n\n  /**\n   * Gets a value indicating if the geometry has a fill component.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  fillEnabled: {\n    get: function () {\n      return this._fillEnabled;\n    }\n  },\n\n  /**\n   * Gets a value indicating if fill visibility varies with simulation time.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  hasConstantFill: {\n    get: function () {\n      return !this._fillEnabled || !defined(this._entity.availability) && Property.isConstant(this._showProperty);\n    }\n  },\n\n  /**\n   * Gets the material property used to fill the geometry.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {MaterialProperty}\n   * @readonly\n   */\n  fillMaterialProperty: {\n    get: function () {\n      return this._materialProperty;\n    }\n  },\n\n  /**\n   * Gets the material property used to fill the geometry when it fails the depth test.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {MaterialProperty}\n   * @readonly\n   */\n  depthFailMaterialProperty: {\n    get: function () {\n      return this._depthFailMaterialProperty;\n    }\n  },\n\n  /**\n   * Gets a value indicating if the geometry has an outline component.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  outlineEnabled: {\n    value: false\n  },\n\n  /**\n   * Gets a value indicating if outline visibility varies with simulation time.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  hasConstantOutline: {\n    value: true\n  },\n\n  /**\n   * Gets the {@link Color} property for the geometry outline.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Property}\n   * @readonly\n   */\n  outlineColorProperty: {\n    value: undefined\n  },\n\n  /**\n   * Gets the property specifying whether the geometry\n   * casts or receives shadows from light sources.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Property}\n   * @readonly\n   */\n  shadowsProperty: {\n    get: function () {\n      return this._shadowsProperty;\n    }\n  },\n\n  /**\n   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Property}\n   * @readonly\n   */\n  distanceDisplayConditionProperty: {\n    get: function () {\n      return this._distanceDisplayConditionProperty;\n    }\n  },\n\n  /**\n   * Gets or sets the {@link ClassificationType} Property specifying if this geometry will classify terrain, 3D Tiles, or both when on the ground.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Property}\n   * @readonly\n   */\n  classificationTypeProperty: {\n    get: function () {\n      return this._classificationTypeProperty;\n    }\n  },\n\n  /**\n   * Gets a value indicating if the geometry is time-varying.\n   * If true, all visualization is delegated to the {@link DynamicGeometryUpdater}\n   * returned by GeometryUpdater#createDynamicUpdater.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  isDynamic: {\n    get: function () {\n      return this._dynamic;\n    }\n  },\n\n  /**\n   * Gets a value indicating if the geometry is closed.\n   * This property is only valid for static geometry.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  isClosed: {\n    value: false\n  },\n\n  /**\n   * Gets an event that is raised whenever the public properties\n   * of this updater change.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  geometryChanged: {\n    get: function () {\n      return this._geometryChanged;\n    }\n  },\n\n  /**\n   * Gets a value indicating if the path of the line.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {ArcType}\n   * @readonly\n   */\n  arcType: {\n    get: function () {\n      return this._arcType;\n    }\n  },\n\n  /**\n   * Gets a value indicating if the geometry is clamped to the ground.\n   * Returns false if polylines on terrain is not supported.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  clampToGround: {\n    get: function () {\n      return this._clampToGround && this._supportsPolylinesOnTerrain;\n    }\n  },\n\n  /**\n   * Gets the zindex\n   * @type {Number}\n   * @memberof PolylineGeometryUpdater.prototype\n   * @readonly\n   */\n  zIndex: {\n    get: function () {\n      return this._zIndex;\n    }\n  }\n});\n/**\n * Checks if the geometry is outlined at the provided time.\n *\n * @param {JulianDate} time The time for which to retrieve visibility.\n * @returns {Boolean} true if geometry is outlined at the provided time, false otherwise.\n */\n\nPolylineGeometryUpdater.prototype.isOutlineVisible = function (time) {\n  return false;\n};\n/**\n * Checks if the geometry is filled at the provided time.\n *\n * @param {JulianDate} time The time for which to retrieve visibility.\n * @returns {Boolean} true if geometry is filled at the provided time, false otherwise.\n */\n\n\nPolylineGeometryUpdater.prototype.isFilled = function (time) {\n  var entity = this._entity;\n\n  var visible = this._fillEnabled && entity.isAvailable(time) && this._showProperty.getValue(time);\n\n  return defaultValue(visible, false);\n};\n/**\n * Creates the geometry instance which represents the fill of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent a filled geometry.\n */\n\n\nPolylineGeometryUpdater.prototype.createFillGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(time)) {\n    throw new DeveloperError(\"time is required.\");\n  }\n\n  if (!this._fillEnabled) {\n    throw new DeveloperError(\"This instance does not represent a filled geometry.\");\n  } //>>includeEnd('debug');\n\n\n  var entity = this._entity;\n  var isAvailable = entity.isAvailable(time);\n  var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time));\n\n  var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n  var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n  var attributes = {\n    show: show,\n    distanceDisplayCondition: distanceDisplayConditionAttribute\n  };\n  var currentColor;\n\n  if (this._materialProperty instanceof ColorMaterialProperty) {\n    if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n      currentColor = this._materialProperty.color.getValue(time, scratchColor);\n    }\n\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n\n    attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n  }\n\n  if (this.clampToGround) {\n    return new GeometryInstance({\n      id: entity,\n      geometry: new GroundPolylineGeometry(this._groundGeometryOptions),\n      attributes: attributes\n    });\n  }\n\n  if (defined(this._depthFailMaterialProperty) && this._depthFailMaterialProperty instanceof ColorMaterialProperty) {\n    if (defined(this._depthFailMaterialProperty.color) && (this._depthFailMaterialProperty.color.isConstant || isAvailable)) {\n      currentColor = this._depthFailMaterialProperty.color.getValue(time, scratchColor);\n    }\n\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n\n    attributes.depthFailColor = ColorGeometryInstanceAttribute.fromColor(currentColor);\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new PolylineGeometry(this._geometryOptions),\n    attributes: attributes\n  });\n};\n/**\n * Creates the geometry instance which represents the outline of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent an outlined geometry.\n */\n\n\nPolylineGeometryUpdater.prototype.createOutlineGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(\"This instance does not represent an outlined geometry.\"); //>>includeEnd('debug');\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n */\n\n\nPolylineGeometryUpdater.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\n\n\nPolylineGeometryUpdater.prototype.destroy = function () {\n  this._entitySubscription();\n\n  destroyObject(this);\n};\n\nPolylineGeometryUpdater.prototype._onEntityPropertyChanged = function (entity, propertyName, newValue, oldValue) {\n  if (!(propertyName === \"availability\" || propertyName === \"polyline\")) {\n    return;\n  }\n\n  var polyline = this._entity.polyline;\n\n  if (!defined(polyline)) {\n    if (this._fillEnabled) {\n      this._fillEnabled = false;\n\n      this._geometryChanged.raiseEvent(this);\n    }\n\n    return;\n  }\n\n  var positionsProperty = polyline.positions;\n  var show = polyline.show;\n\n  if (defined(show) && show.isConstant && !show.getValue(Iso8601.MINIMUM_VALUE) || //\n  !defined(positionsProperty)) {\n    if (this._fillEnabled) {\n      this._fillEnabled = false;\n\n      this._geometryChanged.raiseEvent(this);\n    }\n\n    return;\n  }\n\n  var zIndex = polyline.zIndex;\n  var material = defaultValue(polyline.material, defaultMaterial);\n  var isColorMaterial = material instanceof ColorMaterialProperty;\n  this._materialProperty = material;\n  this._depthFailMaterialProperty = polyline.depthFailMaterial;\n  this._showProperty = defaultValue(show, defaultShow);\n  this._shadowsProperty = defaultValue(polyline.shadows, defaultShadows);\n  this._distanceDisplayConditionProperty = defaultValue(polyline.distanceDisplayCondition, defaultDistanceDisplayCondition);\n  this._classificationTypeProperty = defaultValue(polyline.classificationType, defaultClassificationType);\n  this._fillEnabled = true;\n  this._zIndex = defaultValue(zIndex, defaultZIndex);\n  var width = polyline.width;\n  var arcType = polyline.arcType;\n  var clampToGround = polyline.clampToGround;\n  var granularity = polyline.granularity;\n\n  if (!positionsProperty.isConstant || !Property.isConstant(width) || !Property.isConstant(arcType) || !Property.isConstant(granularity) || !Property.isConstant(clampToGround) || !Property.isConstant(zIndex)) {\n    if (!this._dynamic) {\n      this._dynamic = true;\n\n      this._geometryChanged.raiseEvent(this);\n    }\n  } else {\n    var geometryOptions = this._geometryOptions;\n    var positions = positionsProperty.getValue(Iso8601.MINIMUM_VALUE, geometryOptions.positions); //Because of the way we currently handle reference properties,\n    //we can't automatically assume the positions are always valid.\n\n    if (!defined(positions) || positions.length < 2) {\n      if (this._fillEnabled) {\n        this._fillEnabled = false;\n\n        this._geometryChanged.raiseEvent(this);\n      }\n\n      return;\n    }\n\n    var vertexFormat;\n\n    if (isColorMaterial && (!defined(this._depthFailMaterialProperty) || this._depthFailMaterialProperty instanceof ColorMaterialProperty)) {\n      vertexFormat = PolylineColorAppearance.VERTEX_FORMAT;\n    } else {\n      vertexFormat = PolylineMaterialAppearance.VERTEX_FORMAT;\n    }\n\n    geometryOptions.vertexFormat = vertexFormat;\n    geometryOptions.positions = positions;\n    geometryOptions.width = defined(width) ? width.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n    geometryOptions.arcType = defined(arcType) ? arcType.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n    geometryOptions.granularity = defined(granularity) ? granularity.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n    var groundGeometryOptions = this._groundGeometryOptions;\n    groundGeometryOptions.positions = positions;\n    groundGeometryOptions.width = geometryOptions.width;\n    groundGeometryOptions.arcType = geometryOptions.arcType;\n    groundGeometryOptions.granularity = geometryOptions.granularity;\n    this._clampToGround = defined(clampToGround) ? clampToGround.getValue(Iso8601.MINIMUM_VALUE) : false;\n\n    if (!this._clampToGround && defined(zIndex)) {\n      oneTimeWarning(\"Entity polylines must have clampToGround: true when using zIndex.  zIndex will be ignored.\");\n    }\n\n    this._dynamic = false;\n\n    this._geometryChanged.raiseEvent(this);\n  }\n};\n/**\n * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.\n *\n * @param {PrimitiveCollection} primitives The primitive collection to use.\n * @param {PrimitiveCollection|OrderedGroundPrimitiveCollection} groundPrimitives The primitive collection to use for ordered ground primitives.\n * @returns {DynamicGeometryUpdater} The dynamic updater used to update the geometry each frame.\n *\n * @exception {DeveloperError} This instance does not represent dynamic geometry.\n */\n\n\nPolylineGeometryUpdater.prototype.createDynamicUpdater = function (primitives, groundPrimitives) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"primitives\", primitives);\n  Check.defined(\"groundPrimitives\", groundPrimitives);\n\n  if (!this._dynamic) {\n    throw new DeveloperError(\"This instance does not represent dynamic geometry.\");\n  } //>>includeEnd('debug');\n\n\n  return new DynamicGeometryUpdater(primitives, groundPrimitives, this);\n};\n/**\n * @private\n */\n\n\nvar generateCartesianArcOptions = {\n  positions: undefined,\n  granularity: undefined,\n  height: undefined,\n  ellipsoid: undefined\n};\n\nfunction DynamicGeometryUpdater(primitives, groundPrimitives, geometryUpdater) {\n  this._line = undefined;\n  this._primitives = primitives;\n  this._groundPrimitives = groundPrimitives;\n  this._groundPolylinePrimitive = undefined;\n  this._material = undefined;\n  this._geometryUpdater = geometryUpdater;\n  this._positions = [];\n}\n\nfunction getLine(dynamicGeometryUpdater) {\n  if (defined(dynamicGeometryUpdater._line)) {\n    return dynamicGeometryUpdater._line;\n  }\n\n  var sceneId = dynamicGeometryUpdater._geometryUpdater._scene.id;\n  var polylineCollection = polylineCollections[sceneId];\n  var primitives = dynamicGeometryUpdater._primitives;\n\n  if (!defined(polylineCollection) || polylineCollection.isDestroyed()) {\n    polylineCollection = new PolylineCollection();\n    polylineCollections[sceneId] = polylineCollection;\n    primitives.add(polylineCollection);\n  } else if (!primitives.contains(polylineCollection)) {\n    primitives.add(polylineCollection);\n  }\n\n  var line = polylineCollection.add();\n  line.id = dynamicGeometryUpdater._geometryUpdater._entity;\n  dynamicGeometryUpdater._line = line;\n  return line;\n}\n\nDynamicGeometryUpdater.prototype.update = function (time) {\n  var geometryUpdater = this._geometryUpdater;\n  var entity = geometryUpdater._entity;\n  var polyline = entity.polyline;\n  var positionsProperty = polyline.positions;\n  var positions = Property.getValueOrUndefined(positionsProperty, time, this._positions); // Synchronize with geometryUpdater for GroundPolylinePrimitive\n\n  geometryUpdater._clampToGround = Property.getValueOrDefault(polyline._clampToGround, time, false);\n  geometryUpdater._groundGeometryOptions.positions = positions;\n  geometryUpdater._groundGeometryOptions.width = Property.getValueOrDefault(polyline._width, time, 1);\n  geometryUpdater._groundGeometryOptions.arcType = Property.getValueOrDefault(polyline._arcType, time, ArcType.GEODESIC);\n  geometryUpdater._groundGeometryOptions.granularity = Property.getValueOrDefault(polyline._granularity, time, 9999);\n  var groundPrimitives = this._groundPrimitives;\n\n  if (defined(this._groundPolylinePrimitive)) {\n    groundPrimitives.remove(this._groundPolylinePrimitive); // destroys by default\n\n    this._groundPolylinePrimitive = undefined;\n  }\n\n  if (geometryUpdater.clampToGround) {\n    if (!entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(polyline._show, time, true)) {\n      return;\n    }\n\n    if (!defined(positions) || positions.length < 2) {\n      return;\n    }\n\n    var fillMaterialProperty = geometryUpdater.fillMaterialProperty;\n    var appearance;\n\n    if (fillMaterialProperty instanceof ColorMaterialProperty) {\n      appearance = new PolylineColorAppearance();\n    } else {\n      var material = MaterialProperty.getValue(time, fillMaterialProperty, this._material);\n      appearance = new PolylineMaterialAppearance({\n        material: material,\n        translucent: material.isTranslucent()\n      });\n      this._material = material;\n    }\n\n    this._groundPolylinePrimitive = groundPrimitives.add(new GroundPolylinePrimitive({\n      geometryInstances: geometryUpdater.createFillGeometryInstance(time),\n      appearance: appearance,\n      classificationType: geometryUpdater.classificationTypeProperty.getValue(time),\n      asynchronous: false\n    }), Property.getValueOrUndefined(geometryUpdater.zIndex, time)); // Hide the polyline in the collection, if any\n\n    if (defined(this._line)) {\n      this._line.show = false;\n    }\n\n    return;\n  }\n\n  var line = getLine(this);\n\n  if (!entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(polyline._show, time, true)) {\n    line.show = false;\n    return;\n  }\n\n  if (!defined(positions) || positions.length < 2) {\n    line.show = false;\n    return;\n  }\n\n  var arcType = ArcType.GEODESIC;\n  arcType = Property.getValueOrDefault(polyline._arcType, time, arcType);\n  var globe = geometryUpdater._scene.globe;\n\n  if (arcType !== ArcType.NONE && defined(globe)) {\n    generateCartesianArcOptions.ellipsoid = globe.ellipsoid;\n    generateCartesianArcOptions.positions = positions;\n    generateCartesianArcOptions.granularity = Property.getValueOrUndefined(polyline._granularity, time);\n    generateCartesianArcOptions.height = PolylinePipeline.extractHeights(positions, globe.ellipsoid);\n\n    if (arcType === ArcType.GEODESIC) {\n      positions = PolylinePipeline.generateCartesianArc(generateCartesianArcOptions);\n    } else {\n      positions = PolylinePipeline.generateCartesianRhumbArc(generateCartesianArcOptions);\n    }\n  }\n\n  line.show = true;\n  line.positions = positions.slice();\n  line.material = MaterialProperty.getValue(time, geometryUpdater.fillMaterialProperty, line.material);\n  line.width = Property.getValueOrDefault(polyline._width, time, 1);\n  line.distanceDisplayCondition = Property.getValueOrUndefined(polyline._distanceDisplayCondition, time, line.distanceDisplayCondition);\n};\n\nDynamicGeometryUpdater.prototype.getBoundingSphere = function (result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"result\", result); //>>includeEnd('debug');\n\n  if (!this._geometryUpdater.clampToGround) {\n    var line = getLine(this);\n\n    if (line.show && line.positions.length > 0) {\n      BoundingSphere.fromPoints(line.positions, result);\n      return BoundingSphereState.DONE;\n    }\n  } else {\n    var groundPolylinePrimitive = this._groundPolylinePrimitive;\n\n    if (defined(groundPolylinePrimitive) && groundPolylinePrimitive.show && groundPolylinePrimitive.ready) {\n      var attributes = groundPolylinePrimitive.getGeometryInstanceAttributes(this._geometryUpdater._entity);\n\n      if (defined(attributes) && defined(attributes.boundingSphere)) {\n        BoundingSphere.clone(attributes.boundingSphere, result);\n        return BoundingSphereState.DONE;\n      }\n    }\n\n    if (defined(groundPolylinePrimitive) && !groundPolylinePrimitive.ready) {\n      return BoundingSphereState.PENDING;\n    }\n\n    return BoundingSphereState.DONE;\n  }\n\n  return BoundingSphereState.FAILED;\n};\n\nDynamicGeometryUpdater.prototype.isDestroyed = function () {\n  return false;\n};\n\nDynamicGeometryUpdater.prototype.destroy = function () {\n  var geometryUpdater = this._geometryUpdater;\n  var sceneId = geometryUpdater._scene.id;\n  var polylineCollection = polylineCollections[sceneId];\n\n  if (defined(polylineCollection)) {\n    polylineCollection.remove(this._line);\n\n    if (polylineCollection.length === 0) {\n      this._primitives.removeAndDestroy(polylineCollection);\n\n      delete polylineCollections[sceneId];\n    }\n  }\n\n  if (defined(this._groundPolylinePrimitive)) {\n    this._groundPrimitives.remove(this._groundPolylinePrimitive);\n  }\n\n  destroyObject(this);\n};\n\nexport default PolylineGeometryUpdater;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/DataSources/PolylineGeometryUpdater.js"],"names":["ArcType","BoundingSphere","Check","Color","ColorGeometryInstanceAttribute","defaultValue","defined","destroyObject","DeveloperError","DistanceDisplayCondition","DistanceDisplayConditionGeometryInstanceAttribute","Event","GeometryInstance","GroundPolylineGeometry","Iso8601","oneTimeWarning","PolylineGeometry","PolylinePipeline","ShowGeometryInstanceAttribute","Entity","ClassificationType","GroundPolylinePrimitive","PolylineCollection","PolylineColorAppearance","PolylineMaterialAppearance","ShadowMode","BoundingSphereState","ColorMaterialProperty","ConstantProperty","MaterialProperty","Property","defaultZIndex","polylineCollections","scratchColor","defaultMaterial","WHITE","defaultShow","defaultShadows","DISABLED","defaultDistanceDisplayCondition","defaultClassificationType","BOTH","GeometryOptions","vertexFormat","undefined","positions","width","arcType","granularity","GroundGeometryOptions","PolylineGeometryUpdater","entity","scene","_entity","_scene","_entitySubscription","definitionChanged","addEventListener","prototype","_onEntityPropertyChanged","_fillEnabled","_dynamic","_geometryChanged","_showProperty","_materialProperty","_shadowsProperty","_distanceDisplayConditionProperty","_classificationTypeProperty","_depthFailMaterialProperty","_geometryOptions","_groundGeometryOptions","_id","id","_clampToGround","_supportsPolylinesOnTerrain","supportsPolylinesOnTerrain","_zIndex","polyline","Object","defineProperties","get","fillEnabled","hasConstantFill","availability","isConstant","fillMaterialProperty","depthFailMaterialProperty","outlineEnabled","value","hasConstantOutline","outlineColorProperty","shadowsProperty","distanceDisplayConditionProperty","classificationTypeProperty","isDynamic","isClosed","geometryChanged","_arcType","clampToGround","zIndex","isOutlineVisible","time","isFilled","visible","isAvailable","getValue","createFillGeometryInstance","show","isShowing","distanceDisplayCondition","distanceDisplayConditionAttribute","fromDistanceDisplayCondition","attributes","currentColor","color","fromColor","geometry","depthFailColor","createOutlineGeometryInstance","isDestroyed","destroy","propertyName","newValue","oldValue","raiseEvent","positionsProperty","MINIMUM_VALUE","material","isColorMaterial","depthFailMaterial","shadows","classificationType","geometryOptions","length","VERTEX_FORMAT","groundGeometryOptions","createDynamicUpdater","primitives","groundPrimitives","DynamicGeometryUpdater","generateCartesianArcOptions","height","ellipsoid","geometryUpdater","_line","_primitives","_groundPrimitives","_groundPolylinePrimitive","_material","_geometryUpdater","_positions","getLine","dynamicGeometryUpdater","sceneId","polylineCollection","add","contains","line","update","getValueOrUndefined","getValueOrDefault","_width","GEODESIC","_granularity","remove","_show","appearance","translucent","isTranslucent","geometryInstances","asynchronous","globe","NONE","extractHeights","generateCartesianArc","generateCartesianRhumbArc","slice","_distanceDisplayCondition","getBoundingSphere","result","fromPoints","DONE","groundPolylinePrimitive","ready","getGeometryInstanceAttributes","boundingSphere","clone","PENDING","FAILED","removeAndDestroy"],"mappings":"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","sourcesContent":["import ArcType from \"../Core/ArcType.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport Event from \"../Core/Event.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GroundPolylineGeometry from \"../Core/GroundPolylineGeometry.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nimport PolylineGeometry from \"../Core/PolylineGeometry.js\";\nimport PolylinePipeline from \"../Core/PolylinePipeline.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport Entity from \"../DataSources/Entity.js\";\nimport ClassificationType from \"../Scene/ClassificationType.js\";\nimport GroundPolylinePrimitive from \"../Scene/GroundPolylinePrimitive.js\";\nimport PolylineCollection from \"../Scene/PolylineCollection.js\";\nimport PolylineColorAppearance from \"../Scene/PolylineColorAppearance.js\";\nimport PolylineMaterialAppearance from \"../Scene/PolylineMaterialAppearance.js\";\nimport ShadowMode from \"../Scene/ShadowMode.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport ConstantProperty from \"./ConstantProperty.js\";\nimport MaterialProperty from \"./MaterialProperty.js\";\nimport Property from \"./Property.js\";\n\nvar defaultZIndex = new ConstantProperty(0);\n\n//We use this object to create one polyline collection per-scene.\nvar polylineCollections = {};\n\nvar scratchColor = new Color();\nvar defaultMaterial = new ColorMaterialProperty(Color.WHITE);\nvar defaultShow = new ConstantProperty(true);\nvar defaultShadows = new ConstantProperty(ShadowMode.DISABLED);\nvar defaultDistanceDisplayCondition = new ConstantProperty(\n  new DistanceDisplayCondition()\n);\nvar defaultClassificationType = new ConstantProperty(ClassificationType.BOTH);\n\nfunction GeometryOptions() {\n  this.vertexFormat = undefined;\n  this.positions = undefined;\n  this.width = undefined;\n  this.arcType = undefined;\n  this.granularity = undefined;\n}\n\nfunction GroundGeometryOptions() {\n  this.positions = undefined;\n  this.width = undefined;\n  this.arcType = undefined;\n  this.granularity = undefined;\n}\n\n/**\n * A {@link GeometryUpdater} for polylines.\n * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n * @alias PolylineGeometryUpdater\n * @constructor\n *\n * @param {Entity} entity The entity containing the geometry to be visualized.\n * @param {Scene} scene The scene where visualization is taking place.\n */\nfunction PolylineGeometryUpdater(entity, scene) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entity)) {\n    throw new DeveloperError(\"entity is required\");\n  }\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required\");\n  }\n  //>>includeEnd('debug');\n\n  this._entity = entity;\n  this._scene = scene;\n  this._entitySubscription = entity.definitionChanged.addEventListener(\n    PolylineGeometryUpdater.prototype._onEntityPropertyChanged,\n    this\n  );\n  this._fillEnabled = false;\n  this._dynamic = false;\n  this._geometryChanged = new Event();\n  this._showProperty = undefined;\n  this._materialProperty = undefined;\n  this._shadowsProperty = undefined;\n  this._distanceDisplayConditionProperty = undefined;\n  this._classificationTypeProperty = undefined;\n  this._depthFailMaterialProperty = undefined;\n  this._geometryOptions = new GeometryOptions();\n  this._groundGeometryOptions = new GroundGeometryOptions();\n  this._id = \"polyline-\" + entity.id;\n  this._clampToGround = false;\n  this._supportsPolylinesOnTerrain = Entity.supportsPolylinesOnTerrain(scene);\n\n  this._zIndex = 0;\n\n  this._onEntityPropertyChanged(entity, \"polyline\", entity.polyline, undefined);\n}\n\nObject.defineProperties(PolylineGeometryUpdater.prototype, {\n  /**\n   * Gets the unique ID associated with this updater\n   * @memberof PolylineGeometryUpdater.prototype\n   * @type {String}\n   * @readonly\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n  /**\n   * Gets the entity associated with this geometry.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Entity}\n   * @readonly\n   */\n  entity: {\n    get: function () {\n      return this._entity;\n    },\n  },\n  /**\n   * Gets a value indicating if the geometry has a fill component.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  fillEnabled: {\n    get: function () {\n      return this._fillEnabled;\n    },\n  },\n  /**\n   * Gets a value indicating if fill visibility varies with simulation time.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  hasConstantFill: {\n    get: function () {\n      return (\n        !this._fillEnabled ||\n        (!defined(this._entity.availability) &&\n          Property.isConstant(this._showProperty))\n      );\n    },\n  },\n  /**\n   * Gets the material property used to fill the geometry.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {MaterialProperty}\n   * @readonly\n   */\n  fillMaterialProperty: {\n    get: function () {\n      return this._materialProperty;\n    },\n  },\n  /**\n   * Gets the material property used to fill the geometry when it fails the depth test.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {MaterialProperty}\n   * @readonly\n   */\n  depthFailMaterialProperty: {\n    get: function () {\n      return this._depthFailMaterialProperty;\n    },\n  },\n  /**\n   * Gets a value indicating if the geometry has an outline component.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  outlineEnabled: {\n    value: false,\n  },\n  /**\n   * Gets a value indicating if outline visibility varies with simulation time.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  hasConstantOutline: {\n    value: true,\n  },\n  /**\n   * Gets the {@link Color} property for the geometry outline.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Property}\n   * @readonly\n   */\n  outlineColorProperty: {\n    value: undefined,\n  },\n  /**\n   * Gets the property specifying whether the geometry\n   * casts or receives shadows from light sources.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Property}\n   * @readonly\n   */\n  shadowsProperty: {\n    get: function () {\n      return this._shadowsProperty;\n    },\n  },\n  /**\n   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Property}\n   * @readonly\n   */\n  distanceDisplayConditionProperty: {\n    get: function () {\n      return this._distanceDisplayConditionProperty;\n    },\n  },\n  /**\n   * Gets or sets the {@link ClassificationType} Property specifying if this geometry will classify terrain, 3D Tiles, or both when on the ground.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Property}\n   * @readonly\n   */\n  classificationTypeProperty: {\n    get: function () {\n      return this._classificationTypeProperty;\n    },\n  },\n  /**\n   * Gets a value indicating if the geometry is time-varying.\n   * If true, all visualization is delegated to the {@link DynamicGeometryUpdater}\n   * returned by GeometryUpdater#createDynamicUpdater.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  isDynamic: {\n    get: function () {\n      return this._dynamic;\n    },\n  },\n  /**\n   * Gets a value indicating if the geometry is closed.\n   * This property is only valid for static geometry.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  isClosed: {\n    value: false,\n  },\n  /**\n   * Gets an event that is raised whenever the public properties\n   * of this updater change.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  geometryChanged: {\n    get: function () {\n      return this._geometryChanged;\n    },\n  },\n\n  /**\n   * Gets a value indicating if the path of the line.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {ArcType}\n   * @readonly\n   */\n  arcType: {\n    get: function () {\n      return this._arcType;\n    },\n  },\n\n  /**\n   * Gets a value indicating if the geometry is clamped to the ground.\n   * Returns false if polylines on terrain is not supported.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  clampToGround: {\n    get: function () {\n      return this._clampToGround && this._supportsPolylinesOnTerrain;\n    },\n  },\n\n  /**\n   * Gets the zindex\n   * @type {Number}\n   * @memberof PolylineGeometryUpdater.prototype\n   * @readonly\n   */\n  zIndex: {\n    get: function () {\n      return this._zIndex;\n    },\n  },\n});\n\n/**\n * Checks if the geometry is outlined at the provided time.\n *\n * @param {JulianDate} time The time for which to retrieve visibility.\n * @returns {Boolean} true if geometry is outlined at the provided time, false otherwise.\n */\nPolylineGeometryUpdater.prototype.isOutlineVisible = function (time) {\n  return false;\n};\n\n/**\n * Checks if the geometry is filled at the provided time.\n *\n * @param {JulianDate} time The time for which to retrieve visibility.\n * @returns {Boolean} true if geometry is filled at the provided time, false otherwise.\n */\nPolylineGeometryUpdater.prototype.isFilled = function (time) {\n  var entity = this._entity;\n  var visible =\n    this._fillEnabled &&\n    entity.isAvailable(time) &&\n    this._showProperty.getValue(time);\n  return defaultValue(visible, false);\n};\n\n/**\n * Creates the geometry instance which represents the fill of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent a filled geometry.\n */\nPolylineGeometryUpdater.prototype.createFillGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(time)) {\n    throw new DeveloperError(\"time is required.\");\n  }\n\n  if (!this._fillEnabled) {\n    throw new DeveloperError(\n      \"This instance does not represent a filled geometry.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var entity = this._entity;\n  var isAvailable = entity.isAvailable(time);\n  var show = new ShowGeometryInstanceAttribute(\n    isAvailable && entity.isShowing && this._showProperty.getValue(time)\n  );\n  var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(\n    time\n  );\n  var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(\n    distanceDisplayCondition\n  );\n\n  var attributes = {\n    show: show,\n    distanceDisplayCondition: distanceDisplayConditionAttribute,\n  };\n\n  var currentColor;\n  if (this._materialProperty instanceof ColorMaterialProperty) {\n    if (\n      defined(this._materialProperty.color) &&\n      (this._materialProperty.color.isConstant || isAvailable)\n    ) {\n      currentColor = this._materialProperty.color.getValue(time, scratchColor);\n    }\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n    attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n  }\n\n  if (this.clampToGround) {\n    return new GeometryInstance({\n      id: entity,\n      geometry: new GroundPolylineGeometry(this._groundGeometryOptions),\n      attributes: attributes,\n    });\n  }\n\n  if (\n    defined(this._depthFailMaterialProperty) &&\n    this._depthFailMaterialProperty instanceof ColorMaterialProperty\n  ) {\n    if (\n      defined(this._depthFailMaterialProperty.color) &&\n      (this._depthFailMaterialProperty.color.isConstant || isAvailable)\n    ) {\n      currentColor = this._depthFailMaterialProperty.color.getValue(\n        time,\n        scratchColor\n      );\n    }\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n    attributes.depthFailColor = ColorGeometryInstanceAttribute.fromColor(\n      currentColor\n    );\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new PolylineGeometry(this._geometryOptions),\n    attributes: attributes,\n  });\n};\n\n/**\n * Creates the geometry instance which represents the outline of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent an outlined geometry.\n */\nPolylineGeometryUpdater.prototype.createOutlineGeometryInstance = function (\n  time\n) {\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(\n    \"This instance does not represent an outlined geometry.\"\n  );\n  //>>includeEnd('debug');\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n */\nPolylineGeometryUpdater.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nPolylineGeometryUpdater.prototype.destroy = function () {\n  this._entitySubscription();\n  destroyObject(this);\n};\n\nPolylineGeometryUpdater.prototype._onEntityPropertyChanged = function (\n  entity,\n  propertyName,\n  newValue,\n  oldValue\n) {\n  if (!(propertyName === \"availability\" || propertyName === \"polyline\")) {\n    return;\n  }\n\n  var polyline = this._entity.polyline;\n\n  if (!defined(polyline)) {\n    if (this._fillEnabled) {\n      this._fillEnabled = false;\n      this._geometryChanged.raiseEvent(this);\n    }\n    return;\n  }\n\n  var positionsProperty = polyline.positions;\n\n  var show = polyline.show;\n  if (\n    (defined(show) &&\n      show.isConstant &&\n      !show.getValue(Iso8601.MINIMUM_VALUE)) || //\n    !defined(positionsProperty)\n  ) {\n    if (this._fillEnabled) {\n      this._fillEnabled = false;\n      this._geometryChanged.raiseEvent(this);\n    }\n    return;\n  }\n\n  var zIndex = polyline.zIndex;\n  var material = defaultValue(polyline.material, defaultMaterial);\n  var isColorMaterial = material instanceof ColorMaterialProperty;\n  this._materialProperty = material;\n  this._depthFailMaterialProperty = polyline.depthFailMaterial;\n  this._showProperty = defaultValue(show, defaultShow);\n  this._shadowsProperty = defaultValue(polyline.shadows, defaultShadows);\n  this._distanceDisplayConditionProperty = defaultValue(\n    polyline.distanceDisplayCondition,\n    defaultDistanceDisplayCondition\n  );\n  this._classificationTypeProperty = defaultValue(\n    polyline.classificationType,\n    defaultClassificationType\n  );\n  this._fillEnabled = true;\n  this._zIndex = defaultValue(zIndex, defaultZIndex);\n\n  var width = polyline.width;\n  var arcType = polyline.arcType;\n  var clampToGround = polyline.clampToGround;\n  var granularity = polyline.granularity;\n\n  if (\n    !positionsProperty.isConstant ||\n    !Property.isConstant(width) ||\n    !Property.isConstant(arcType) ||\n    !Property.isConstant(granularity) ||\n    !Property.isConstant(clampToGround) ||\n    !Property.isConstant(zIndex)\n  ) {\n    if (!this._dynamic) {\n      this._dynamic = true;\n      this._geometryChanged.raiseEvent(this);\n    }\n  } else {\n    var geometryOptions = this._geometryOptions;\n    var positions = positionsProperty.getValue(\n      Iso8601.MINIMUM_VALUE,\n      geometryOptions.positions\n    );\n\n    //Because of the way we currently handle reference properties,\n    //we can't automatically assume the positions are always valid.\n    if (!defined(positions) || positions.length < 2) {\n      if (this._fillEnabled) {\n        this._fillEnabled = false;\n        this._geometryChanged.raiseEvent(this);\n      }\n      return;\n    }\n\n    var vertexFormat;\n    if (\n      isColorMaterial &&\n      (!defined(this._depthFailMaterialProperty) ||\n        this._depthFailMaterialProperty instanceof ColorMaterialProperty)\n    ) {\n      vertexFormat = PolylineColorAppearance.VERTEX_FORMAT;\n    } else {\n      vertexFormat = PolylineMaterialAppearance.VERTEX_FORMAT;\n    }\n\n    geometryOptions.vertexFormat = vertexFormat;\n    geometryOptions.positions = positions;\n    geometryOptions.width = defined(width)\n      ? width.getValue(Iso8601.MINIMUM_VALUE)\n      : undefined;\n    geometryOptions.arcType = defined(arcType)\n      ? arcType.getValue(Iso8601.MINIMUM_VALUE)\n      : undefined;\n    geometryOptions.granularity = defined(granularity)\n      ? granularity.getValue(Iso8601.MINIMUM_VALUE)\n      : undefined;\n\n    var groundGeometryOptions = this._groundGeometryOptions;\n    groundGeometryOptions.positions = positions;\n    groundGeometryOptions.width = geometryOptions.width;\n    groundGeometryOptions.arcType = geometryOptions.arcType;\n    groundGeometryOptions.granularity = geometryOptions.granularity;\n\n    this._clampToGround = defined(clampToGround)\n      ? clampToGround.getValue(Iso8601.MINIMUM_VALUE)\n      : false;\n\n    if (!this._clampToGround && defined(zIndex)) {\n      oneTimeWarning(\n        \"Entity polylines must have clampToGround: true when using zIndex.  zIndex will be ignored.\"\n      );\n    }\n\n    this._dynamic = false;\n    this._geometryChanged.raiseEvent(this);\n  }\n};\n\n/**\n * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.\n *\n * @param {PrimitiveCollection} primitives The primitive collection to use.\n * @param {PrimitiveCollection|OrderedGroundPrimitiveCollection} groundPrimitives The primitive collection to use for ordered ground primitives.\n * @returns {DynamicGeometryUpdater} The dynamic updater used to update the geometry each frame.\n *\n * @exception {DeveloperError} This instance does not represent dynamic geometry.\n */\nPolylineGeometryUpdater.prototype.createDynamicUpdater = function (\n  primitives,\n  groundPrimitives\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"primitives\", primitives);\n  Check.defined(\"groundPrimitives\", groundPrimitives);\n\n  if (!this._dynamic) {\n    throw new DeveloperError(\n      \"This instance does not represent dynamic geometry.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  return new DynamicGeometryUpdater(primitives, groundPrimitives, this);\n};\n\n/**\n * @private\n */\nvar generateCartesianArcOptions = {\n  positions: undefined,\n  granularity: undefined,\n  height: undefined,\n  ellipsoid: undefined,\n};\n\nfunction DynamicGeometryUpdater(primitives, groundPrimitives, geometryUpdater) {\n  this._line = undefined;\n  this._primitives = primitives;\n  this._groundPrimitives = groundPrimitives;\n  this._groundPolylinePrimitive = undefined;\n  this._material = undefined;\n  this._geometryUpdater = geometryUpdater;\n  this._positions = [];\n}\n\nfunction getLine(dynamicGeometryUpdater) {\n  if (defined(dynamicGeometryUpdater._line)) {\n    return dynamicGeometryUpdater._line;\n  }\n\n  var sceneId = dynamicGeometryUpdater._geometryUpdater._scene.id;\n  var polylineCollection = polylineCollections[sceneId];\n  var primitives = dynamicGeometryUpdater._primitives;\n  if (!defined(polylineCollection) || polylineCollection.isDestroyed()) {\n    polylineCollection = new PolylineCollection();\n    polylineCollections[sceneId] = polylineCollection;\n    primitives.add(polylineCollection);\n  } else if (!primitives.contains(polylineCollection)) {\n    primitives.add(polylineCollection);\n  }\n\n  var line = polylineCollection.add();\n  line.id = dynamicGeometryUpdater._geometryUpdater._entity;\n  dynamicGeometryUpdater._line = line;\n  return line;\n}\n\nDynamicGeometryUpdater.prototype.update = function (time) {\n  var geometryUpdater = this._geometryUpdater;\n  var entity = geometryUpdater._entity;\n  var polyline = entity.polyline;\n\n  var positionsProperty = polyline.positions;\n  var positions = Property.getValueOrUndefined(\n    positionsProperty,\n    time,\n    this._positions\n  );\n\n  // Synchronize with geometryUpdater for GroundPolylinePrimitive\n  geometryUpdater._clampToGround = Property.getValueOrDefault(\n    polyline._clampToGround,\n    time,\n    false\n  );\n  geometryUpdater._groundGeometryOptions.positions = positions;\n  geometryUpdater._groundGeometryOptions.width = Property.getValueOrDefault(\n    polyline._width,\n    time,\n    1\n  );\n  geometryUpdater._groundGeometryOptions.arcType = Property.getValueOrDefault(\n    polyline._arcType,\n    time,\n    ArcType.GEODESIC\n  );\n  geometryUpdater._groundGeometryOptions.granularity = Property.getValueOrDefault(\n    polyline._granularity,\n    time,\n    9999\n  );\n\n  var groundPrimitives = this._groundPrimitives;\n\n  if (defined(this._groundPolylinePrimitive)) {\n    groundPrimitives.remove(this._groundPolylinePrimitive); // destroys by default\n    this._groundPolylinePrimitive = undefined;\n  }\n\n  if (geometryUpdater.clampToGround) {\n    if (\n      !entity.isShowing ||\n      !entity.isAvailable(time) ||\n      !Property.getValueOrDefault(polyline._show, time, true)\n    ) {\n      return;\n    }\n\n    if (!defined(positions) || positions.length < 2) {\n      return;\n    }\n\n    var fillMaterialProperty = geometryUpdater.fillMaterialProperty;\n    var appearance;\n    if (fillMaterialProperty instanceof ColorMaterialProperty) {\n      appearance = new PolylineColorAppearance();\n    } else {\n      var material = MaterialProperty.getValue(\n        time,\n        fillMaterialProperty,\n        this._material\n      );\n      appearance = new PolylineMaterialAppearance({\n        material: material,\n        translucent: material.isTranslucent(),\n      });\n      this._material = material;\n    }\n\n    this._groundPolylinePrimitive = groundPrimitives.add(\n      new GroundPolylinePrimitive({\n        geometryInstances: geometryUpdater.createFillGeometryInstance(time),\n        appearance: appearance,\n        classificationType: geometryUpdater.classificationTypeProperty.getValue(\n          time\n        ),\n        asynchronous: false,\n      }),\n      Property.getValueOrUndefined(geometryUpdater.zIndex, time)\n    );\n\n    // Hide the polyline in the collection, if any\n    if (defined(this._line)) {\n      this._line.show = false;\n    }\n    return;\n  }\n\n  var line = getLine(this);\n\n  if (\n    !entity.isShowing ||\n    !entity.isAvailable(time) ||\n    !Property.getValueOrDefault(polyline._show, time, true)\n  ) {\n    line.show = false;\n    return;\n  }\n\n  if (!defined(positions) || positions.length < 2) {\n    line.show = false;\n    return;\n  }\n\n  var arcType = ArcType.GEODESIC;\n  arcType = Property.getValueOrDefault(polyline._arcType, time, arcType);\n\n  var globe = geometryUpdater._scene.globe;\n  if (arcType !== ArcType.NONE && defined(globe)) {\n    generateCartesianArcOptions.ellipsoid = globe.ellipsoid;\n    generateCartesianArcOptions.positions = positions;\n    generateCartesianArcOptions.granularity = Property.getValueOrUndefined(\n      polyline._granularity,\n      time\n    );\n    generateCartesianArcOptions.height = PolylinePipeline.extractHeights(\n      positions,\n      globe.ellipsoid\n    );\n    if (arcType === ArcType.GEODESIC) {\n      positions = PolylinePipeline.generateCartesianArc(\n        generateCartesianArcOptions\n      );\n    } else {\n      positions = PolylinePipeline.generateCartesianRhumbArc(\n        generateCartesianArcOptions\n      );\n    }\n  }\n\n  line.show = true;\n  line.positions = positions.slice();\n  line.material = MaterialProperty.getValue(\n    time,\n    geometryUpdater.fillMaterialProperty,\n    line.material\n  );\n  line.width = Property.getValueOrDefault(polyline._width, time, 1);\n  line.distanceDisplayCondition = Property.getValueOrUndefined(\n    polyline._distanceDisplayCondition,\n    time,\n    line.distanceDisplayCondition\n  );\n};\n\nDynamicGeometryUpdater.prototype.getBoundingSphere = function (result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  if (!this._geometryUpdater.clampToGround) {\n    var line = getLine(this);\n    if (line.show && line.positions.length > 0) {\n      BoundingSphere.fromPoints(line.positions, result);\n      return BoundingSphereState.DONE;\n    }\n  } else {\n    var groundPolylinePrimitive = this._groundPolylinePrimitive;\n    if (\n      defined(groundPolylinePrimitive) &&\n      groundPolylinePrimitive.show &&\n      groundPolylinePrimitive.ready\n    ) {\n      var attributes = groundPolylinePrimitive.getGeometryInstanceAttributes(\n        this._geometryUpdater._entity\n      );\n      if (defined(attributes) && defined(attributes.boundingSphere)) {\n        BoundingSphere.clone(attributes.boundingSphere, result);\n        return BoundingSphereState.DONE;\n      }\n    }\n\n    if (defined(groundPolylinePrimitive) && !groundPolylinePrimitive.ready) {\n      return BoundingSphereState.PENDING;\n    }\n\n    return BoundingSphereState.DONE;\n  }\n\n  return BoundingSphereState.FAILED;\n};\n\nDynamicGeometryUpdater.prototype.isDestroyed = function () {\n  return false;\n};\n\nDynamicGeometryUpdater.prototype.destroy = function () {\n  var geometryUpdater = this._geometryUpdater;\n  var sceneId = geometryUpdater._scene.id;\n  var polylineCollection = polylineCollections[sceneId];\n  if (defined(polylineCollection)) {\n    polylineCollection.remove(this._line);\n    if (polylineCollection.length === 0) {\n      this._primitives.removeAndDestroy(polylineCollection);\n      delete polylineCollections[sceneId];\n    }\n  }\n  if (defined(this._groundPolylinePrimitive)) {\n    this._groundPrimitives.remove(this._groundPolylinePrimitive);\n  }\n  destroyObject(this);\n};\nexport default PolylineGeometryUpdater;\n"]},"metadata":{},"sourceType":"module"}