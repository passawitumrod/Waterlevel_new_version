{"ast":null,"code":"import clone from \"../Core/clone.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport CullFace from \"./CullFace.js\";\n/**\n * An appearance defines the full GLSL vertex and fragment shaders and the\n * render state used to draw a {@link Primitive}.  All appearances implement\n * this base <code>Appearance</code> interface.\n *\n * @alias Appearance\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Boolean} [options.translucent=true] When <code>true</code>, the geometry is expected to appear translucent so {@link Appearance#renderState} has alpha blending enabled.\n * @param {Boolean} [options.closed=false] When <code>true</code>, the geometry is expected to be closed so {@link Appearance#renderState} has backface culling enabled.\n * @param {Material} [options.material=Material.ColorType] The material used to determine the fragment color.\n * @param {String} [options.vertexShaderSource] Optional GLSL vertex shader source to override the default vertex shader.\n * @param {String} [options.fragmentShaderSource] Optional GLSL fragment shader source to override the default fragment shader.\n * @param {RenderState} [options.renderState] Optional render state to override the default render state.\n *\n * @see MaterialAppearance\n * @see EllipsoidSurfaceAppearance\n * @see PerInstanceColorAppearance\n * @see DebugAppearance\n * @see PolylineColorAppearance\n * @see PolylineMaterialAppearance\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Geometry%20and%20Appearances.html|Geometry and Appearances Demo}\n */\n\nfunction Appearance(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  /**\n   * The material used to determine the fragment color.  Unlike other {@link Appearance}\n   * properties, this is not read-only, so an appearance's material can change on the fly.\n   *\n   * @type Material\n   *\n   * @see {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}\n   */\n\n  this.material = options.material;\n  /**\n   * When <code>true</code>, the geometry is expected to appear translucent.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n\n  this.translucent = defaultValue(options.translucent, true);\n  this._vertexShaderSource = options.vertexShaderSource;\n  this._fragmentShaderSource = options.fragmentShaderSource;\n  this._renderState = options.renderState;\n  this._closed = defaultValue(options.closed, false);\n}\n\nObject.defineProperties(Appearance.prototype, {\n  /**\n   * The GLSL source code for the vertex shader.\n   *\n   * @memberof Appearance.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  vertexShaderSource: {\n    get: function () {\n      return this._vertexShaderSource;\n    }\n  },\n\n  /**\n   * The GLSL source code for the fragment shader.  The full fragment shader\n   * source is built procedurally taking into account the {@link Appearance#material}.\n   * Use {@link Appearance#getFragmentShaderSource} to get the full source.\n   *\n   * @memberof Appearance.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  fragmentShaderSource: {\n    get: function () {\n      return this._fragmentShaderSource;\n    }\n  },\n\n  /**\n   * The WebGL fixed-function state to use when rendering the geometry.\n   *\n   * @memberof Appearance.prototype\n   *\n   * @type {Object}\n   * @readonly\n   */\n  renderState: {\n    get: function () {\n      return this._renderState;\n    }\n  },\n\n  /**\n   * When <code>true</code>, the geometry is expected to be closed.\n   *\n   * @memberof Appearance.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  closed: {\n    get: function () {\n      return this._closed;\n    }\n  }\n});\n/**\n * Procedurally creates the full GLSL fragment shader source for this appearance\n * taking into account {@link Appearance#fragmentShaderSource} and {@link Appearance#material}.\n *\n * @returns {String} The full GLSL fragment shader source.\n */\n\nAppearance.prototype.getFragmentShaderSource = function () {\n  var parts = [];\n\n  if (this.flat) {\n    parts.push(\"#define FLAT\");\n  }\n\n  if (this.faceForward) {\n    parts.push(\"#define FACE_FORWARD\");\n  }\n\n  if (defined(this.material)) {\n    parts.push(this.material.shaderSource);\n  }\n\n  parts.push(this.fragmentShaderSource);\n  return parts.join(\"\\n\");\n};\n/**\n * Determines if the geometry is translucent based on {@link Appearance#translucent} and {@link Material#isTranslucent}.\n *\n * @returns {Boolean} <code>true</code> if the appearance is translucent.\n */\n\n\nAppearance.prototype.isTranslucent = function () {\n  return defined(this.material) && this.material.isTranslucent() || !defined(this.material) && this.translucent;\n};\n/**\n * Creates a render state.  This is not the final render state instance; instead,\n * it can contain a subset of render state properties identical to the render state\n * created in the context.\n *\n * @returns {Object} The render state.\n */\n\n\nAppearance.prototype.getRenderState = function () {\n  var translucent = this.isTranslucent();\n  var rs = clone(this.renderState, false);\n\n  if (translucent) {\n    rs.depthMask = false;\n    rs.blending = BlendingState.ALPHA_BLEND;\n  } else {\n    rs.depthMask = true;\n  }\n\n  return rs;\n};\n/**\n * @private\n */\n\n\nAppearance.getDefaultRenderState = function (translucent, closed, existing) {\n  var rs = {\n    depthTest: {\n      enabled: true\n    }\n  };\n\n  if (translucent) {\n    rs.depthMask = false;\n    rs.blending = BlendingState.ALPHA_BLEND;\n  }\n\n  if (closed) {\n    rs.cull = {\n      enabled: true,\n      face: CullFace.BACK\n    };\n  }\n\n  if (defined(existing)) {\n    rs = combine(existing, rs, true);\n  }\n\n  return rs;\n};\n\nexport default Appearance;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/Appearance.js"],"names":["clone","combine","defaultValue","defined","BlendingState","CullFace","Appearance","options","EMPTY_OBJECT","material","translucent","_vertexShaderSource","vertexShaderSource","_fragmentShaderSource","fragmentShaderSource","_renderState","renderState","_closed","closed","Object","defineProperties","prototype","get","getFragmentShaderSource","parts","flat","push","faceForward","shaderSource","join","isTranslucent","getRenderState","rs","depthMask","blending","ALPHA_BLEND","getDefaultRenderState","existing","depthTest","enabled","cull","face","BACK"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,kBAAlB;AACA,OAAOC,OAAP,MAAoB,oBAApB;AACA,OAAOC,YAAP,MAAyB,yBAAzB;AACA,OAAOC,OAAP,MAAoB,oBAApB;AACA,OAAOC,aAAP,MAA0B,oBAA1B;AACA,OAAOC,QAAP,MAAqB,eAArB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,SAASC,UAAT,CAAoBC,OAApB,EAA6B;AAC3BA,EAAAA,OAAO,GAAGL,YAAY,CAACK,OAAD,EAAUL,YAAY,CAACM,YAAvB,CAAtB;AAEA;;;;;;;;;AAQA,OAAKC,QAAL,GAAgBF,OAAO,CAACE,QAAxB;AAEA;;;;;;;;AAOA,OAAKC,WAAL,GAAmBR,YAAY,CAACK,OAAO,CAACG,WAAT,EAAsB,IAAtB,CAA/B;AAEA,OAAKC,mBAAL,GAA2BJ,OAAO,CAACK,kBAAnC;AACA,OAAKC,qBAAL,GAA6BN,OAAO,CAACO,oBAArC;AACA,OAAKC,YAAL,GAAoBR,OAAO,CAACS,WAA5B;AACA,OAAKC,OAAL,GAAef,YAAY,CAACK,OAAO,CAACW,MAAT,EAAiB,KAAjB,CAA3B;AACD;;AAEDC,MAAM,CAACC,gBAAP,CAAwBd,UAAU,CAACe,SAAnC,EAA8C;AAC5C;;;;;;;;AAQAT,EAAAA,kBAAkB,EAAE;AAClBU,IAAAA,GAAG,EAAE,YAAY;AACf,aAAO,KAAKX,mBAAZ;AACD;AAHiB,GATwB;;AAe5C;;;;;;;;;;AAUAG,EAAAA,oBAAoB,EAAE;AACpBQ,IAAAA,GAAG,EAAE,YAAY;AACf,aAAO,KAAKT,qBAAZ;AACD;AAHmB,GAzBsB;;AA+B5C;;;;;;;;AAQAG,EAAAA,WAAW,EAAE;AACXM,IAAAA,GAAG,EAAE,YAAY;AACf,aAAO,KAAKP,YAAZ;AACD;AAHU,GAvC+B;;AA6C5C;;;;;;;;;;AAUAG,EAAAA,MAAM,EAAE;AACNI,IAAAA,GAAG,EAAE,YAAY;AACf,aAAO,KAAKL,OAAZ;AACD;AAHK;AAvDoC,CAA9C;AA8DA;;;;;;;AAMAX,UAAU,CAACe,SAAX,CAAqBE,uBAArB,GAA+C,YAAY;AACzD,MAAIC,KAAK,GAAG,EAAZ;;AACA,MAAI,KAAKC,IAAT,EAAe;AACbD,IAAAA,KAAK,CAACE,IAAN,CAAW,cAAX;AACD;;AACD,MAAI,KAAKC,WAAT,EAAsB;AACpBH,IAAAA,KAAK,CAACE,IAAN,CAAW,sBAAX;AACD;;AACD,MAAIvB,OAAO,CAAC,KAAKM,QAAN,CAAX,EAA4B;AAC1Be,IAAAA,KAAK,CAACE,IAAN,CAAW,KAAKjB,QAAL,CAAcmB,YAAzB;AACD;;AACDJ,EAAAA,KAAK,CAACE,IAAN,CAAW,KAAKZ,oBAAhB;AAEA,SAAOU,KAAK,CAACK,IAAN,CAAW,IAAX,CAAP;AACD,CAdD;AAgBA;;;;;;;AAKAvB,UAAU,CAACe,SAAX,CAAqBS,aAArB,GAAqC,YAAY;AAC/C,SACG3B,OAAO,CAAC,KAAKM,QAAN,CAAP,IAA0B,KAAKA,QAAL,CAAcqB,aAAd,EAA3B,IACC,CAAC3B,OAAO,CAAC,KAAKM,QAAN,CAAR,IAA2B,KAAKC,WAFnC;AAID,CALD;AAOA;;;;;;;;;AAOAJ,UAAU,CAACe,SAAX,CAAqBU,cAArB,GAAsC,YAAY;AAChD,MAAIrB,WAAW,GAAG,KAAKoB,aAAL,EAAlB;AACA,MAAIE,EAAE,GAAGhC,KAAK,CAAC,KAAKgB,WAAN,EAAmB,KAAnB,CAAd;;AACA,MAAIN,WAAJ,EAAiB;AACfsB,IAAAA,EAAE,CAACC,SAAH,GAAe,KAAf;AACAD,IAAAA,EAAE,CAACE,QAAH,GAAc9B,aAAa,CAAC+B,WAA5B;AACD,GAHD,MAGO;AACLH,IAAAA,EAAE,CAACC,SAAH,GAAe,IAAf;AACD;;AACD,SAAOD,EAAP;AACD,CAVD;AAYA;;;;;AAGA1B,UAAU,CAAC8B,qBAAX,GAAmC,UAAU1B,WAAV,EAAuBQ,MAAvB,EAA+BmB,QAA/B,EAAyC;AAC1E,MAAIL,EAAE,GAAG;AACPM,IAAAA,SAAS,EAAE;AACTC,MAAAA,OAAO,EAAE;AADA;AADJ,GAAT;;AAMA,MAAI7B,WAAJ,EAAiB;AACfsB,IAAAA,EAAE,CAACC,SAAH,GAAe,KAAf;AACAD,IAAAA,EAAE,CAACE,QAAH,GAAc9B,aAAa,CAAC+B,WAA5B;AACD;;AAED,MAAIjB,MAAJ,EAAY;AACVc,IAAAA,EAAE,CAACQ,IAAH,GAAU;AACRD,MAAAA,OAAO,EAAE,IADD;AAERE,MAAAA,IAAI,EAAEpC,QAAQ,CAACqC;AAFP,KAAV;AAID;;AAED,MAAIvC,OAAO,CAACkC,QAAD,CAAX,EAAuB;AACrBL,IAAAA,EAAE,GAAG/B,OAAO,CAACoC,QAAD,EAAWL,EAAX,EAAe,IAAf,CAAZ;AACD;;AAED,SAAOA,EAAP;AACD,CAxBD;;AAyBA,eAAe1B,UAAf","sourcesContent":["import clone from \"../Core/clone.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport CullFace from \"./CullFace.js\";\n\n/**\n * An appearance defines the full GLSL vertex and fragment shaders and the\n * render state used to draw a {@link Primitive}.  All appearances implement\n * this base <code>Appearance</code> interface.\n *\n * @alias Appearance\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Boolean} [options.translucent=true] When <code>true</code>, the geometry is expected to appear translucent so {@link Appearance#renderState} has alpha blending enabled.\n * @param {Boolean} [options.closed=false] When <code>true</code>, the geometry is expected to be closed so {@link Appearance#renderState} has backface culling enabled.\n * @param {Material} [options.material=Material.ColorType] The material used to determine the fragment color.\n * @param {String} [options.vertexShaderSource] Optional GLSL vertex shader source to override the default vertex shader.\n * @param {String} [options.fragmentShaderSource] Optional GLSL fragment shader source to override the default fragment shader.\n * @param {RenderState} [options.renderState] Optional render state to override the default render state.\n *\n * @see MaterialAppearance\n * @see EllipsoidSurfaceAppearance\n * @see PerInstanceColorAppearance\n * @see DebugAppearance\n * @see PolylineColorAppearance\n * @see PolylineMaterialAppearance\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Geometry%20and%20Appearances.html|Geometry and Appearances Demo}\n */\nfunction Appearance(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The material used to determine the fragment color.  Unlike other {@link Appearance}\n   * properties, this is not read-only, so an appearance's material can change on the fly.\n   *\n   * @type Material\n   *\n   * @see {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}\n   */\n  this.material = options.material;\n\n  /**\n   * When <code>true</code>, the geometry is expected to appear translucent.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  this.translucent = defaultValue(options.translucent, true);\n\n  this._vertexShaderSource = options.vertexShaderSource;\n  this._fragmentShaderSource = options.fragmentShaderSource;\n  this._renderState = options.renderState;\n  this._closed = defaultValue(options.closed, false);\n}\n\nObject.defineProperties(Appearance.prototype, {\n  /**\n   * The GLSL source code for the vertex shader.\n   *\n   * @memberof Appearance.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  vertexShaderSource: {\n    get: function () {\n      return this._vertexShaderSource;\n    },\n  },\n\n  /**\n   * The GLSL source code for the fragment shader.  The full fragment shader\n   * source is built procedurally taking into account the {@link Appearance#material}.\n   * Use {@link Appearance#getFragmentShaderSource} to get the full source.\n   *\n   * @memberof Appearance.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  fragmentShaderSource: {\n    get: function () {\n      return this._fragmentShaderSource;\n    },\n  },\n\n  /**\n   * The WebGL fixed-function state to use when rendering the geometry.\n   *\n   * @memberof Appearance.prototype\n   *\n   * @type {Object}\n   * @readonly\n   */\n  renderState: {\n    get: function () {\n      return this._renderState;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the geometry is expected to be closed.\n   *\n   * @memberof Appearance.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  closed: {\n    get: function () {\n      return this._closed;\n    },\n  },\n});\n\n/**\n * Procedurally creates the full GLSL fragment shader source for this appearance\n * taking into account {@link Appearance#fragmentShaderSource} and {@link Appearance#material}.\n *\n * @returns {String} The full GLSL fragment shader source.\n */\nAppearance.prototype.getFragmentShaderSource = function () {\n  var parts = [];\n  if (this.flat) {\n    parts.push(\"#define FLAT\");\n  }\n  if (this.faceForward) {\n    parts.push(\"#define FACE_FORWARD\");\n  }\n  if (defined(this.material)) {\n    parts.push(this.material.shaderSource);\n  }\n  parts.push(this.fragmentShaderSource);\n\n  return parts.join(\"\\n\");\n};\n\n/**\n * Determines if the geometry is translucent based on {@link Appearance#translucent} and {@link Material#isTranslucent}.\n *\n * @returns {Boolean} <code>true</code> if the appearance is translucent.\n */\nAppearance.prototype.isTranslucent = function () {\n  return (\n    (defined(this.material) && this.material.isTranslucent()) ||\n    (!defined(this.material) && this.translucent)\n  );\n};\n\n/**\n * Creates a render state.  This is not the final render state instance; instead,\n * it can contain a subset of render state properties identical to the render state\n * created in the context.\n *\n * @returns {Object} The render state.\n */\nAppearance.prototype.getRenderState = function () {\n  var translucent = this.isTranslucent();\n  var rs = clone(this.renderState, false);\n  if (translucent) {\n    rs.depthMask = false;\n    rs.blending = BlendingState.ALPHA_BLEND;\n  } else {\n    rs.depthMask = true;\n  }\n  return rs;\n};\n\n/**\n * @private\n */\nAppearance.getDefaultRenderState = function (translucent, closed, existing) {\n  var rs = {\n    depthTest: {\n      enabled: true,\n    },\n  };\n\n  if (translucent) {\n    rs.depthMask = false;\n    rs.blending = BlendingState.ALPHA_BLEND;\n  }\n\n  if (closed) {\n    rs.cull = {\n      enabled: true,\n      face: CullFace.BACK,\n    };\n  }\n\n  if (defined(existing)) {\n    rs = combine(existing, rs, true);\n  }\n\n  return rs;\n};\nexport default Appearance;\n"]},"metadata":{},"sourceType":"module"}