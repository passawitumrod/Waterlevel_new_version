{"ast":null,"code":"import Credit from \"../Core/Credit.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport GeographicTilingScheme from \"../Core/GeographicTilingScheme.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TileProviderError from \"../Core/TileProviderError.js\";\nimport when from \"../ThirdParty/when.js\";\nimport ImageryProvider from \"./ImageryProvider.js\";\n/**\n * Provides a single, top-level imagery tile.  The single image is assumed to use a\n * {@link GeographicTilingScheme}.\n *\n * @alias SingleTileImageryProvider\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource|String} options.url The url for the tile.\n * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the image.\n * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.\n * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If not specified, the WGS84 ellipsoid is used.\n *\n * @see ArcGisMapServerImageryProvider\n * @see BingMapsImageryProvider\n * @see GoogleEarthEnterpriseMapsProvider\n * @see OpenStreetMapImageryProvider\n * @see TileMapServiceImageryProvider\n * @see WebMapServiceImageryProvider\n * @see WebMapTileServiceImageryProvider\n * @see UrlTemplateImageryProvider\n */\n\nfunction SingleTileImageryProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(options.url)) {\n    throw new DeveloperError(\"options.url is required.\");\n  } //>>includeEnd('debug');\n\n\n  var resource = Resource.createIfNeeded(options.url);\n  var rectangle = defaultValue(options.rectangle, Rectangle.MAX_VALUE);\n  var tilingScheme = new GeographicTilingScheme({\n    rectangle: rectangle,\n    numberOfLevelZeroTilesX: 1,\n    numberOfLevelZeroTilesY: 1,\n    ellipsoid: options.ellipsoid\n  });\n  this._tilingScheme = tilingScheme;\n  this._resource = resource;\n  this._image = undefined;\n  this._texture = undefined;\n  this._tileWidth = 0;\n  this._tileHeight = 0;\n  this._errorEvent = new Event();\n  this._ready = false;\n  this._readyPromise = when.defer();\n  var credit = options.credit;\n\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n\n  this._credit = credit;\n  var that = this;\n  var error;\n\n  function success(image) {\n    that._image = image;\n    that._tileWidth = image.width;\n    that._tileHeight = image.height;\n    that._ready = true;\n\n    that._readyPromise.resolve(true);\n\n    TileProviderError.handleSuccess(that._errorEvent);\n  }\n\n  function failure(e) {\n    var message = \"Failed to load image \" + resource.url + \".\";\n    error = TileProviderError.handleError(error, that, that._errorEvent, message, 0, 0, 0, doRequest, e);\n\n    that._readyPromise.reject(new RuntimeError(message));\n  }\n\n  function doRequest() {\n    ImageryProvider.loadImage(null, resource).then(success).otherwise(failure);\n  }\n\n  doRequest();\n}\n\nObject.defineProperties(SingleTileImageryProvider.prototype, {\n  /**\n   * Gets the URL of the single, top-level imagery tile.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {String}\n   * @readonly\n   */\n  url: {\n    get: function get() {\n      return this._resource.url;\n    }\n  },\n\n  /**\n   * Gets the proxy used by this provider.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Proxy}\n   * @readonly\n   */\n  proxy: {\n    get: function get() {\n      return this._resource.proxy;\n    }\n  },\n\n  /**\n   * Gets the width of each tile, in pixels. This function should\n   * not be called before {@link SingleTileImageryProvider#ready} returns true.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileWidth: {\n    get: function get() {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\"tileWidth must not be called before the imagery provider is ready.\");\n      } //>>includeEnd('debug');\n\n\n      return this._tileWidth;\n    }\n  },\n\n  /**\n   * Gets the height of each tile, in pixels.  This function should\n   * not be called before {@link SingleTileImageryProvider#ready} returns true.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileHeight: {\n    get: function get() {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\"tileHeight must not be called before the imagery provider is ready.\");\n      } //>>includeEnd('debug');\n\n\n      return this._tileHeight;\n    }\n  },\n\n  /**\n   * Gets the maximum level-of-detail that can be requested.  This function should\n   * not be called before {@link SingleTileImageryProvider#ready} returns true.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  maximumLevel: {\n    get: function get() {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\"maximumLevel must not be called before the imagery provider is ready.\");\n      } //>>includeEnd('debug');\n\n\n      return 0;\n    }\n  },\n\n  /**\n   * Gets the minimum level-of-detail that can be requested.  This function should\n   * not be called before {@link SingleTileImageryProvider#ready} returns true.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  minimumLevel: {\n    get: function get() {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\"minimumLevel must not be called before the imagery provider is ready.\");\n      } //>>includeEnd('debug');\n\n\n      return 0;\n    }\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.  This function should\n   * not be called before {@link SingleTileImageryProvider#ready} returns true.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function get() {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\"tilingScheme must not be called before the imagery provider is ready.\");\n      } //>>includeEnd('debug');\n\n\n      return this._tilingScheme;\n    }\n  },\n\n  /**\n   * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should\n   * not be called before {@link SingleTileImageryProvider#ready} returns true.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  rectangle: {\n    get: function get() {\n      return this._tilingScheme.rectangle;\n    }\n  },\n\n  /**\n   * Gets the tile discard policy.  If not undefined, the discard policy is responsible\n   * for filtering out \"missing\" tiles via its shouldDiscardImage function.  If this function\n   * returns undefined, no tiles are filtered.  This function should\n   * not be called before {@link SingleTileImageryProvider#ready} returns true.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {TileDiscardPolicy}\n   * @readonly\n   */\n  tileDiscardPolicy: {\n    get: function get() {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\"tileDiscardPolicy must not be called before the imagery provider is ready.\");\n      } //>>includeEnd('debug');\n\n\n      return undefined;\n    }\n  },\n\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function get() {\n      return this._errorEvent;\n    }\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function get() {\n      return this._ready;\n    }\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function get() {\n      return this._readyPromise.promise;\n    }\n  },\n\n  /**\n   * Gets the credit to display when this imagery provider is active.  Typically this is used to credit\n   * the source of the imagery.  This function should not be called before {@link SingleTileImageryProvider#ready} returns true.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function get() {\n      return this._credit;\n    }\n  },\n\n  /**\n   * Gets a value indicating whether or not the images provided by this imagery provider\n   * include an alpha channel.  If this property is false, an alpha channel, if present, will\n   * be ignored.  If this property is true, any images without an alpha channel will be treated\n   * as if their alpha is 1.0 everywhere.  When this property is false, memory usage\n   * and texture upload time are reduced.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasAlphaChannel: {\n    get: function get() {\n      return true;\n    }\n  }\n});\n/**\n * Gets the credits to be displayed when a given tile is displayed.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level;\n * @returns {Credit[]} The credits to be displayed when the tile is displayed.\n *\n * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.\n */\n\nSingleTileImageryProvider.prototype.getTileCredits = function (x, y, level) {\n  return undefined;\n};\n/**\n * Requests the image for a given tile.  This function should\n * not be called before {@link SingleTileImageryProvider#ready} returns true.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<Image|Canvas>|undefined} A promise for the image that will resolve when the image is available, or\n *          undefined if there are too many active requests to the server, and the request\n *          should be retried later.  The resolved image may be either an\n *          Image or a Canvas DOM object.\n *\n * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.\n */\n\n\nSingleTileImageryProvider.prototype.requestImage = function (x, y, level, request) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._ready) {\n    throw new DeveloperError(\"requestImage must not be called before the imagery provider is ready.\");\n  } //>>includeEnd('debug');\n\n\n  return this._image;\n};\n/**\n * Picking features is not currently supported by this imagery provider, so this function simply returns\n * undefined.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Number} longitude The longitude at which to pick features.\n * @param {Number} latitude  The latitude at which to pick features.\n * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve when the asynchronous\n *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}\n *                   instances.  The array may be empty if no features are found at the given location.\n *                   It may also be undefined if picking is not supported.\n */\n\n\nSingleTileImageryProvider.prototype.pickFeatures = function (x, y, level, longitude, latitude) {\n  return undefined;\n};\n\nexport default SingleTileImageryProvider;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/SingleTileImageryProvider.js"],"names":["Credit","defaultValue","defined","DeveloperError","Event","GeographicTilingScheme","Rectangle","Resource","RuntimeError","TileProviderError","when","ImageryProvider","SingleTileImageryProvider","options","EMPTY_OBJECT","url","resource","createIfNeeded","rectangle","MAX_VALUE","tilingScheme","numberOfLevelZeroTilesX","numberOfLevelZeroTilesY","ellipsoid","_tilingScheme","_resource","_image","undefined","_texture","_tileWidth","_tileHeight","_errorEvent","_ready","_readyPromise","defer","credit","_credit","that","error","success","image","width","height","resolve","handleSuccess","failure","e","message","handleError","doRequest","reject","loadImage","then","otherwise","Object","defineProperties","prototype","get","proxy","tileWidth","tileHeight","maximumLevel","minimumLevel","tileDiscardPolicy","errorEvent","ready","readyPromise","promise","hasAlphaChannel","getTileCredits","x","y","level","requestImage","request","pickFeatures","longitude","latitude"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,mBAAnB;AACA,OAAOC,YAAP,MAAyB,yBAAzB;AACA,OAAOC,OAAP,MAAoB,oBAApB;AACA,OAAOC,cAAP,MAA2B,2BAA3B;AACA,OAAOC,KAAP,MAAkB,kBAAlB;AACA,OAAOC,sBAAP,MAAmC,mCAAnC;AACA,OAAOC,SAAP,MAAsB,sBAAtB;AACA,OAAOC,QAAP,MAAqB,qBAArB;AACA,OAAOC,YAAP,MAAyB,yBAAzB;AACA,OAAOC,iBAAP,MAA8B,8BAA9B;AACA,OAAOC,IAAP,MAAiB,uBAAjB;AACA,OAAOC,eAAP,MAA4B,sBAA5B;AAEA;;;;;;;;;;;;;;;;;;;;;;;AAsBA,SAASC,yBAAT,CAAmCC,OAAnC,EAA4C;AAC1CA,EAAAA,OAAO,GAAGZ,YAAY,CAACY,OAAD,EAAUZ,YAAY,CAACa,YAAvB,CAAtB,CAD0C,CAE1C;;AACA,MAAI,CAACZ,OAAO,CAACW,OAAO,CAACE,GAAT,CAAZ,EAA2B;AACzB,UAAM,IAAIZ,cAAJ,CAAmB,0BAAnB,CAAN;AACD,GALyC,CAM1C;;;AAEA,MAAIa,QAAQ,GAAGT,QAAQ,CAACU,cAAT,CAAwBJ,OAAO,CAACE,GAAhC,CAAf;AAEA,MAAIG,SAAS,GAAGjB,YAAY,CAACY,OAAO,CAACK,SAAT,EAAoBZ,SAAS,CAACa,SAA9B,CAA5B;AACA,MAAIC,YAAY,GAAG,IAAIf,sBAAJ,CAA2B;AAC5Ca,IAAAA,SAAS,EAAEA,SADiC;AAE5CG,IAAAA,uBAAuB,EAAE,CAFmB;AAG5CC,IAAAA,uBAAuB,EAAE,CAHmB;AAI5CC,IAAAA,SAAS,EAAEV,OAAO,CAACU;AAJyB,GAA3B,CAAnB;AAMA,OAAKC,aAAL,GAAqBJ,YAArB;AACA,OAAKK,SAAL,GAAiBT,QAAjB;AACA,OAAKU,MAAL,GAAcC,SAAd;AACA,OAAKC,QAAL,GAAgBD,SAAhB;AACA,OAAKE,UAAL,GAAkB,CAAlB;AACA,OAAKC,WAAL,GAAmB,CAAnB;AAEA,OAAKC,WAAL,GAAmB,IAAI3B,KAAJ,EAAnB;AAEA,OAAK4B,MAAL,GAAc,KAAd;AACA,OAAKC,aAAL,GAAqBvB,IAAI,CAACwB,KAAL,EAArB;AAEA,MAAIC,MAAM,GAAGtB,OAAO,CAACsB,MAArB;;AACA,MAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC;AAC9BA,IAAAA,MAAM,GAAG,IAAInC,MAAJ,CAAWmC,MAAX,CAAT;AACD;;AACD,OAAKC,OAAL,GAAeD,MAAf;AAEA,MAAIE,IAAI,GAAG,IAAX;AACA,MAAIC,KAAJ;;AAEA,WAASC,OAAT,CAAiBC,KAAjB,EAAwB;AACtBH,IAAAA,IAAI,CAACX,MAAL,GAAcc,KAAd;AACAH,IAAAA,IAAI,CAACR,UAAL,GAAkBW,KAAK,CAACC,KAAxB;AACAJ,IAAAA,IAAI,CAACP,WAAL,GAAmBU,KAAK,CAACE,MAAzB;AACAL,IAAAA,IAAI,CAACL,MAAL,GAAc,IAAd;;AACAK,IAAAA,IAAI,CAACJ,aAAL,CAAmBU,OAAnB,CAA2B,IAA3B;;AACAlC,IAAAA,iBAAiB,CAACmC,aAAlB,CAAgCP,IAAI,CAACN,WAArC;AACD;;AAED,WAASc,OAAT,CAAiBC,CAAjB,EAAoB;AAClB,QAAIC,OAAO,GAAG,0BAA0B/B,QAAQ,CAACD,GAAnC,GAAyC,GAAvD;AACAuB,IAAAA,KAAK,GAAG7B,iBAAiB,CAACuC,WAAlB,CACNV,KADM,EAEND,IAFM,EAGNA,IAAI,CAACN,WAHC,EAINgB,OAJM,EAKN,CALM,EAMN,CANM,EAON,CAPM,EAQNE,SARM,EASNH,CATM,CAAR;;AAWAT,IAAAA,IAAI,CAACJ,aAAL,CAAmBiB,MAAnB,CAA0B,IAAI1C,YAAJ,CAAiBuC,OAAjB,CAA1B;AACD;;AAED,WAASE,SAAT,GAAqB;AACnBtC,IAAAA,eAAe,CAACwC,SAAhB,CAA0B,IAA1B,EAAgCnC,QAAhC,EAA0CoC,IAA1C,CAA+Cb,OAA/C,EAAwDc,SAAxD,CAAkER,OAAlE;AACD;;AAEDI,EAAAA,SAAS;AACV;;AAEDK,MAAM,CAACC,gBAAP,CAAwB3C,yBAAyB,CAAC4C,SAAlD,EAA6D;AAC3D;;;;;;AAMAzC,EAAAA,GAAG,EAAE;AACH0C,IAAAA,GAAG,EAAE,eAAY;AACf,aAAO,KAAKhC,SAAL,CAAeV,GAAtB;AACD;AAHE,GAPsD;;AAa3D;;;;;;AAMA2C,EAAAA,KAAK,EAAE;AACLD,IAAAA,GAAG,EAAE,eAAY;AACf,aAAO,KAAKhC,SAAL,CAAeiC,KAAtB;AACD;AAHI,GAnBoD;;AAyB3D;;;;;;;AAOAC,EAAAA,SAAS,EAAE;AACTF,IAAAA,GAAG,EAAE,eAAY;AACf;AACA,UAAI,CAAC,KAAKzB,MAAV,EAAkB;AAChB,cAAM,IAAI7B,cAAJ,CACJ,oEADI,CAAN;AAGD,OANc,CAOf;;;AAEA,aAAO,KAAK0B,UAAZ;AACD;AAXQ,GAhCgD;;AA8C3D;;;;;;;AAOA+B,EAAAA,UAAU,EAAE;AACVH,IAAAA,GAAG,EAAE,eAAY;AACf;AACA,UAAI,CAAC,KAAKzB,MAAV,EAAkB;AAChB,cAAM,IAAI7B,cAAJ,CACJ,qEADI,CAAN;AAGD,OANc,CAOf;;;AAEA,aAAO,KAAK2B,WAAZ;AACD;AAXS,GArD+C;;AAmE3D;;;;;;;AAOA+B,EAAAA,YAAY,EAAE;AACZJ,IAAAA,GAAG,EAAE,eAAY;AACf;AACA,UAAI,CAAC,KAAKzB,MAAV,EAAkB;AAChB,cAAM,IAAI7B,cAAJ,CACJ,uEADI,CAAN;AAGD,OANc,CAOf;;;AAEA,aAAO,CAAP;AACD;AAXW,GA1E6C;;AAwF3D;;;;;;;AAOA2D,EAAAA,YAAY,EAAE;AACZL,IAAAA,GAAG,EAAE,eAAY;AACf;AACA,UAAI,CAAC,KAAKzB,MAAV,EAAkB;AAChB,cAAM,IAAI7B,cAAJ,CACJ,uEADI,CAAN;AAGD,OANc,CAOf;;;AAEA,aAAO,CAAP;AACD;AAXW,GA/F6C;;AA6G3D;;;;;;;AAOAiB,EAAAA,YAAY,EAAE;AACZqC,IAAAA,GAAG,EAAE,eAAY;AACf;AACA,UAAI,CAAC,KAAKzB,MAAV,EAAkB;AAChB,cAAM,IAAI7B,cAAJ,CACJ,uEADI,CAAN;AAGD,OANc,CAOf;;;AAEA,aAAO,KAAKqB,aAAZ;AACD;AAXW,GApH6C;;AAkI3D;;;;;;;AAOAN,EAAAA,SAAS,EAAE;AACTuC,IAAAA,GAAG,EAAE,eAAY;AACf,aAAO,KAAKjC,aAAL,CAAmBN,SAA1B;AACD;AAHQ,GAzIgD;;AA+I3D;;;;;;;;;AASA6C,EAAAA,iBAAiB,EAAE;AACjBN,IAAAA,GAAG,EAAE,eAAY;AACf;AACA,UAAI,CAAC,KAAKzB,MAAV,EAAkB;AAChB,cAAM,IAAI7B,cAAJ,CACJ,4EADI,CAAN;AAGD,OANc,CAOf;;;AAEA,aAAOwB,SAAP;AACD;AAXgB,GAxJwC;;AAsK3D;;;;;;;;AAQAqC,EAAAA,UAAU,EAAE;AACVP,IAAAA,GAAG,EAAE,eAAY;AACf,aAAO,KAAK1B,WAAZ;AACD;AAHS,GA9K+C;;AAoL3D;;;;;;AAMAkC,EAAAA,KAAK,EAAE;AACLR,IAAAA,GAAG,EAAE,eAAY;AACf,aAAO,KAAKzB,MAAZ;AACD;AAHI,GA1LoD;;AAgM3D;;;;;;AAMAkC,EAAAA,YAAY,EAAE;AACZT,IAAAA,GAAG,EAAE,eAAY;AACf,aAAO,KAAKxB,aAAL,CAAmBkC,OAA1B;AACD;AAHW,GAtM6C;;AA4M3D;;;;;;;AAOAhC,EAAAA,MAAM,EAAE;AACNsB,IAAAA,GAAG,EAAE,eAAY;AACf,aAAO,KAAKrB,OAAZ;AACD;AAHK,GAnNmD;;AAyN3D;;;;;;;;;;AAUAgC,EAAAA,eAAe,EAAE;AACfX,IAAAA,GAAG,EAAE,eAAY;AACf,aAAO,IAAP;AACD;AAHc;AAnO0C,CAA7D;AA0OA;;;;;;;;;;;AAUA7C,yBAAyB,CAAC4C,SAA1B,CAAoCa,cAApC,GAAqD,UAAUC,CAAV,EAAaC,CAAb,EAAgBC,KAAhB,EAAuB;AAC1E,SAAO7C,SAAP;AACD,CAFD;AAIA;;;;;;;;;;;;;;;;;AAeAf,yBAAyB,CAAC4C,SAA1B,CAAoCiB,YAApC,GAAmD,UACjDH,CADiD,EAEjDC,CAFiD,EAGjDC,KAHiD,EAIjDE,OAJiD,EAKjD;AACA;AACA,MAAI,CAAC,KAAK1C,MAAV,EAAkB;AAChB,UAAM,IAAI7B,cAAJ,CACJ,uEADI,CAAN;AAGD,GAND,CAOA;;;AAEA,SAAO,KAAKuB,MAAZ;AACD,CAfD;AAiBA;;;;;;;;;;;;;;;;AAcAd,yBAAyB,CAAC4C,SAA1B,CAAoCmB,YAApC,GAAmD,UACjDL,CADiD,EAEjDC,CAFiD,EAGjDC,KAHiD,EAIjDI,SAJiD,EAKjDC,QALiD,EAMjD;AACA,SAAOlD,SAAP;AACD,CARD;;AASA,eAAef,yBAAf","sourcesContent":["import Credit from \"../Core/Credit.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport GeographicTilingScheme from \"../Core/GeographicTilingScheme.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TileProviderError from \"../Core/TileProviderError.js\";\nimport when from \"../ThirdParty/when.js\";\nimport ImageryProvider from \"./ImageryProvider.js\";\n\n/**\n * Provides a single, top-level imagery tile.  The single image is assumed to use a\n * {@link GeographicTilingScheme}.\n *\n * @alias SingleTileImageryProvider\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource|String} options.url The url for the tile.\n * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the image.\n * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.\n * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If not specified, the WGS84 ellipsoid is used.\n *\n * @see ArcGisMapServerImageryProvider\n * @see BingMapsImageryProvider\n * @see GoogleEarthEnterpriseMapsProvider\n * @see OpenStreetMapImageryProvider\n * @see TileMapServiceImageryProvider\n * @see WebMapServiceImageryProvider\n * @see WebMapTileServiceImageryProvider\n * @see UrlTemplateImageryProvider\n */\nfunction SingleTileImageryProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.url)) {\n    throw new DeveloperError(\"options.url is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var resource = Resource.createIfNeeded(options.url);\n\n  var rectangle = defaultValue(options.rectangle, Rectangle.MAX_VALUE);\n  var tilingScheme = new GeographicTilingScheme({\n    rectangle: rectangle,\n    numberOfLevelZeroTilesX: 1,\n    numberOfLevelZeroTilesY: 1,\n    ellipsoid: options.ellipsoid,\n  });\n  this._tilingScheme = tilingScheme;\n  this._resource = resource;\n  this._image = undefined;\n  this._texture = undefined;\n  this._tileWidth = 0;\n  this._tileHeight = 0;\n\n  this._errorEvent = new Event();\n\n  this._ready = false;\n  this._readyPromise = when.defer();\n\n  var credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  this._credit = credit;\n\n  var that = this;\n  var error;\n\n  function success(image) {\n    that._image = image;\n    that._tileWidth = image.width;\n    that._tileHeight = image.height;\n    that._ready = true;\n    that._readyPromise.resolve(true);\n    TileProviderError.handleSuccess(that._errorEvent);\n  }\n\n  function failure(e) {\n    var message = \"Failed to load image \" + resource.url + \".\";\n    error = TileProviderError.handleError(\n      error,\n      that,\n      that._errorEvent,\n      message,\n      0,\n      0,\n      0,\n      doRequest,\n      e\n    );\n    that._readyPromise.reject(new RuntimeError(message));\n  }\n\n  function doRequest() {\n    ImageryProvider.loadImage(null, resource).then(success).otherwise(failure);\n  }\n\n  doRequest();\n}\n\nObject.defineProperties(SingleTileImageryProvider.prototype, {\n  /**\n   * Gets the URL of the single, top-level imagery tile.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {String}\n   * @readonly\n   */\n  url: {\n    get: function () {\n      return this._resource.url;\n    },\n  },\n\n  /**\n   * Gets the proxy used by this provider.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Proxy}\n   * @readonly\n   */\n  proxy: {\n    get: function () {\n      return this._resource.proxy;\n    },\n  },\n\n  /**\n   * Gets the width of each tile, in pixels. This function should\n   * not be called before {@link SingleTileImageryProvider#ready} returns true.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileWidth: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tileWidth must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tileWidth;\n    },\n  },\n\n  /**\n   * Gets the height of each tile, in pixels.  This function should\n   * not be called before {@link SingleTileImageryProvider#ready} returns true.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileHeight: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tileHeight must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tileHeight;\n    },\n  },\n\n  /**\n   * Gets the maximum level-of-detail that can be requested.  This function should\n   * not be called before {@link SingleTileImageryProvider#ready} returns true.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  maximumLevel: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"maximumLevel must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return 0;\n    },\n  },\n\n  /**\n   * Gets the minimum level-of-detail that can be requested.  This function should\n   * not be called before {@link SingleTileImageryProvider#ready} returns true.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  minimumLevel: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"minimumLevel must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return 0;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.  This function should\n   * not be called before {@link SingleTileImageryProvider#ready} returns true.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tilingScheme must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should\n   * not be called before {@link SingleTileImageryProvider#ready} returns true.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  rectangle: {\n    get: function () {\n      return this._tilingScheme.rectangle;\n    },\n  },\n\n  /**\n   * Gets the tile discard policy.  If not undefined, the discard policy is responsible\n   * for filtering out \"missing\" tiles via its shouldDiscardImage function.  If this function\n   * returns undefined, no tiles are filtered.  This function should\n   * not be called before {@link SingleTileImageryProvider#ready} returns true.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {TileDiscardPolicy}\n   * @readonly\n   */\n  tileDiscardPolicy: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tileDiscardPolicy must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this imagery provider is active.  Typically this is used to credit\n   * the source of the imagery.  This function should not be called before {@link SingleTileImageryProvider#ready} returns true.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the images provided by this imagery provider\n   * include an alpha channel.  If this property is false, an alpha channel, if present, will\n   * be ignored.  If this property is true, any images without an alpha channel will be treated\n   * as if their alpha is 1.0 everywhere.  When this property is false, memory usage\n   * and texture upload time are reduced.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasAlphaChannel: {\n    get: function () {\n      return true;\n    },\n  },\n});\n\n/**\n * Gets the credits to be displayed when a given tile is displayed.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level;\n * @returns {Credit[]} The credits to be displayed when the tile is displayed.\n *\n * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.\n */\nSingleTileImageryProvider.prototype.getTileCredits = function (x, y, level) {\n  return undefined;\n};\n\n/**\n * Requests the image for a given tile.  This function should\n * not be called before {@link SingleTileImageryProvider#ready} returns true.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<Image|Canvas>|undefined} A promise for the image that will resolve when the image is available, or\n *          undefined if there are too many active requests to the server, and the request\n *          should be retried later.  The resolved image may be either an\n *          Image or a Canvas DOM object.\n *\n * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.\n */\nSingleTileImageryProvider.prototype.requestImage = function (\n  x,\n  y,\n  level,\n  request\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._ready) {\n    throw new DeveloperError(\n      \"requestImage must not be called before the imagery provider is ready.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  return this._image;\n};\n\n/**\n * Picking features is not currently supported by this imagery provider, so this function simply returns\n * undefined.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Number} longitude The longitude at which to pick features.\n * @param {Number} latitude  The latitude at which to pick features.\n * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve when the asynchronous\n *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}\n *                   instances.  The array may be empty if no features are found at the given location.\n *                   It may also be undefined if picking is not supported.\n */\nSingleTileImageryProvider.prototype.pickFeatures = function (\n  x,\n  y,\n  level,\n  longitude,\n  latitude\n) {\n  return undefined;\n};\nexport default SingleTileImageryProvider;\n"]},"metadata":{},"sourceType":"module"}