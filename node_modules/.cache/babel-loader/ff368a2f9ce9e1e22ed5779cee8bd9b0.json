{"ast":null,"code":"import defaultValue from \"../Core/defaultValue.js\";\nimport PointCloudEyeDomeLighting from \"./PointCloudEyeDomeLighting.js\";\n/**\n * Options for performing point attenuation based on geometric error when rendering\n * point clouds using 3D Tiles.\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Boolean} [options.attenuation=false] Perform point attenuation based on geometric error.\n * @param {Number} [options.geometricErrorScale=1.0] Scale to be applied to each tile's geometric error.\n * @param {Number} [options.maximumAttenuation] Maximum attenuation in pixels. Defaults to the Cesium3DTileset's maximumScreenSpaceError.\n * @param {Number} [options.baseResolution] Average base resolution for the dataset in meters. Substitute for Geometric Error when not available.\n * @param {Boolean} [options.eyeDomeLighting=true] When true, use eye dome lighting when drawing with point attenuation.\n * @param {Number} [options.eyeDomeLightingStrength=1.0] Increasing this value increases contrast on slopes and edges.\n * @param {Number} [options.eyeDomeLightingRadius=1.0] Increase the thickness of contours from eye dome lighting.\n * @param {Boolean} [options.backFaceCulling=false] Determines whether back-facing points are hidden. This option works only if data has normals included.\n * @param {Boolean} [options.normalShading=true] Determines whether a point cloud that contains normals is shaded by the scene's light source.\n *\n * @alias PointCloudShading\n * @constructor\n */\n\nfunction PointCloudShading(options) {\n  var pointCloudShading = defaultValue(options, {});\n  /**\n   * Perform point attenuation based on geometric error.\n   * @type {Boolean}\n   * @default false\n   */\n\n  this.attenuation = defaultValue(pointCloudShading.attenuation, false);\n  /**\n   * Scale to be applied to the geometric error before computing attenuation.\n   * @type {Number}\n   * @default 1.0\n   */\n\n  this.geometricErrorScale = defaultValue(pointCloudShading.geometricErrorScale, 1.0);\n  /**\n   * Maximum point attenuation in pixels. If undefined, the Cesium3DTileset's maximumScreenSpaceError will be used.\n   * @type {Number}\n   */\n\n  this.maximumAttenuation = pointCloudShading.maximumAttenuation;\n  /**\n   * Average base resolution for the dataset in meters.\n   * Used in place of geometric error when geometric error is 0.\n   * If undefined, an approximation will be computed for each tile that has geometric error of 0.\n   * @type {Number}\n   */\n\n  this.baseResolution = pointCloudShading.baseResolution;\n  /**\n   * Use eye dome lighting when drawing with point attenuation\n   * Requires support for EXT_frag_depth, OES_texture_float, and WEBGL_draw_buffers extensions in WebGL 1.0,\n   * otherwise eye dome lighting is ignored.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.eyeDomeLighting = defaultValue(pointCloudShading.eyeDomeLighting, true);\n  /**\n   * Eye dome lighting strength (apparent contrast)\n   * @type {Number}\n   * @default 1.0\n   */\n\n  this.eyeDomeLightingStrength = defaultValue(pointCloudShading.eyeDomeLightingStrength, 1.0);\n  /**\n   * Thickness of contours from eye dome lighting\n   * @type {Number}\n   * @default 1.0\n   */\n\n  this.eyeDomeLightingRadius = defaultValue(pointCloudShading.eyeDomeLightingRadius, 1.0);\n  /**\n   * Determines whether back-facing points are hidden.\n   * This option works only if data has normals included.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n\n  this.backFaceCulling = defaultValue(pointCloudShading.backFaceCulling, false);\n  /**\n   * Determines whether a point cloud that contains normals is shaded by the scene's light source.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.normalShading = defaultValue(pointCloudShading.normalShading, true);\n}\n/**\n * Determines if point cloud shading is supported.\n *\n * @param {Scene} scene The scene.\n * @returns {Boolean} <code>true</code> if point cloud shading is supported; otherwise, returns <code>false</code>\n */\n\n\nPointCloudShading.isSupported = function (scene) {\n  return PointCloudEyeDomeLighting.isSupported(scene.context);\n};\n\nexport default PointCloudShading;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/PointCloudShading.js"],"names":["defaultValue","PointCloudEyeDomeLighting","PointCloudShading","options","pointCloudShading","attenuation","geometricErrorScale","maximumAttenuation","baseResolution","eyeDomeLighting","eyeDomeLightingStrength","eyeDomeLightingRadius","backFaceCulling","normalShading","isSupported","scene","context"],"mappings":"AAAA,OAAOA,YAAP,MAAyB,yBAAzB;AACA,OAAOC,yBAAP,MAAsC,gCAAtC;AAEA;;;;;;;;;;;;;;;;;;;AAkBA,SAASC,iBAAT,CAA2BC,OAA3B,EAAoC;AAClC,MAAIC,iBAAiB,GAAGJ,YAAY,CAACG,OAAD,EAAU,EAAV,CAApC;AAEA;;;;;;AAKA,OAAKE,WAAL,GAAmBL,YAAY,CAACI,iBAAiB,CAACC,WAAnB,EAAgC,KAAhC,CAA/B;AAEA;;;;;;AAKA,OAAKC,mBAAL,GAA2BN,YAAY,CACrCI,iBAAiB,CAACE,mBADmB,EAErC,GAFqC,CAAvC;AAKA;;;;;AAIA,OAAKC,kBAAL,GAA0BH,iBAAiB,CAACG,kBAA5C;AAEA;;;;;;;AAMA,OAAKC,cAAL,GAAsBJ,iBAAiB,CAACI,cAAxC;AAEA;;;;;;;;;AAQA,OAAKC,eAAL,GAAuBT,YAAY,CAACI,iBAAiB,CAACK,eAAnB,EAAoC,IAApC,CAAnC;AAEA;;;;;;AAKA,OAAKC,uBAAL,GAA+BV,YAAY,CACzCI,iBAAiB,CAACM,uBADuB,EAEzC,GAFyC,CAA3C;AAKA;;;;;;AAKA,OAAKC,qBAAL,GAA6BX,YAAY,CACvCI,iBAAiB,CAACO,qBADqB,EAEvC,GAFuC,CAAzC;AAKA;;;;;;;;AAOA,OAAKC,eAAL,GAAuBZ,YAAY,CAACI,iBAAiB,CAACQ,eAAnB,EAAoC,KAApC,CAAnC;AAEA;;;;;;;AAMA,OAAKC,aAAL,GAAqBb,YAAY,CAACI,iBAAiB,CAACS,aAAnB,EAAkC,IAAlC,CAAjC;AACD;AAED;;;;;;;;AAMAX,iBAAiB,CAACY,WAAlB,GAAgC,UAAUC,KAAV,EAAiB;AAC/C,SAAOd,yBAAyB,CAACa,WAA1B,CAAsCC,KAAK,CAACC,OAA5C,CAAP;AACD,CAFD;;AAGA,eAAed,iBAAf","sourcesContent":["import defaultValue from \"../Core/defaultValue.js\";\nimport PointCloudEyeDomeLighting from \"./PointCloudEyeDomeLighting.js\";\n\n/**\n * Options for performing point attenuation based on geometric error when rendering\n * point clouds using 3D Tiles.\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Boolean} [options.attenuation=false] Perform point attenuation based on geometric error.\n * @param {Number} [options.geometricErrorScale=1.0] Scale to be applied to each tile's geometric error.\n * @param {Number} [options.maximumAttenuation] Maximum attenuation in pixels. Defaults to the Cesium3DTileset's maximumScreenSpaceError.\n * @param {Number} [options.baseResolution] Average base resolution for the dataset in meters. Substitute for Geometric Error when not available.\n * @param {Boolean} [options.eyeDomeLighting=true] When true, use eye dome lighting when drawing with point attenuation.\n * @param {Number} [options.eyeDomeLightingStrength=1.0] Increasing this value increases contrast on slopes and edges.\n * @param {Number} [options.eyeDomeLightingRadius=1.0] Increase the thickness of contours from eye dome lighting.\n * @param {Boolean} [options.backFaceCulling=false] Determines whether back-facing points are hidden. This option works only if data has normals included.\n * @param {Boolean} [options.normalShading=true] Determines whether a point cloud that contains normals is shaded by the scene's light source.\n *\n * @alias PointCloudShading\n * @constructor\n */\nfunction PointCloudShading(options) {\n  var pointCloudShading = defaultValue(options, {});\n\n  /**\n   * Perform point attenuation based on geometric error.\n   * @type {Boolean}\n   * @default false\n   */\n  this.attenuation = defaultValue(pointCloudShading.attenuation, false);\n\n  /**\n   * Scale to be applied to the geometric error before computing attenuation.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.geometricErrorScale = defaultValue(\n    pointCloudShading.geometricErrorScale,\n    1.0\n  );\n\n  /**\n   * Maximum point attenuation in pixels. If undefined, the Cesium3DTileset's maximumScreenSpaceError will be used.\n   * @type {Number}\n   */\n  this.maximumAttenuation = pointCloudShading.maximumAttenuation;\n\n  /**\n   * Average base resolution for the dataset in meters.\n   * Used in place of geometric error when geometric error is 0.\n   * If undefined, an approximation will be computed for each tile that has geometric error of 0.\n   * @type {Number}\n   */\n  this.baseResolution = pointCloudShading.baseResolution;\n\n  /**\n   * Use eye dome lighting when drawing with point attenuation\n   * Requires support for EXT_frag_depth, OES_texture_float, and WEBGL_draw_buffers extensions in WebGL 1.0,\n   * otherwise eye dome lighting is ignored.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.eyeDomeLighting = defaultValue(pointCloudShading.eyeDomeLighting, true);\n\n  /**\n   * Eye dome lighting strength (apparent contrast)\n   * @type {Number}\n   * @default 1.0\n   */\n  this.eyeDomeLightingStrength = defaultValue(\n    pointCloudShading.eyeDomeLightingStrength,\n    1.0\n  );\n\n  /**\n   * Thickness of contours from eye dome lighting\n   * @type {Number}\n   * @default 1.0\n   */\n  this.eyeDomeLightingRadius = defaultValue(\n    pointCloudShading.eyeDomeLightingRadius,\n    1.0\n  );\n\n  /**\n   * Determines whether back-facing points are hidden.\n   * This option works only if data has normals included.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  this.backFaceCulling = defaultValue(pointCloudShading.backFaceCulling, false);\n\n  /**\n   * Determines whether a point cloud that contains normals is shaded by the scene's light source.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.normalShading = defaultValue(pointCloudShading.normalShading, true);\n}\n\n/**\n * Determines if point cloud shading is supported.\n *\n * @param {Scene} scene The scene.\n * @returns {Boolean} <code>true</code> if point cloud shading is supported; otherwise, returns <code>false</code>\n */\nPointCloudShading.isSupported = function (scene) {\n  return PointCloudEyeDomeLighting.isSupported(scene.context);\n};\nexport default PointCloudShading;\n"]},"metadata":{},"sourceType":"module"}