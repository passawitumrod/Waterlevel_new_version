{"ast":null,"code":"import Color from \"../../Core/Color.js\";\nimport defined from \"../../Core/defined.js\";\nimport JulianDate from \"../../Core/JulianDate.js\";\n/**\n * @private\n */\n\nfunction TimelineTrack(interval, pixelHeight, color, backgroundColor) {\n  this.interval = interval;\n  this.height = pixelHeight;\n  this.color = color || new Color(0.5, 0.5, 0.5, 1.0);\n  this.backgroundColor = backgroundColor || new Color(0.0, 0.0, 0.0, 0.0);\n}\n\nTimelineTrack.prototype.render = function (context, renderState) {\n  var startInterval = this.interval.start;\n  var stopInterval = this.interval.stop;\n  var spanStart = renderState.startJulian;\n  var spanStop = JulianDate.addSeconds(renderState.startJulian, renderState.duration, new JulianDate());\n\n  if (JulianDate.lessThan(startInterval, spanStart) && JulianDate.greaterThan(stopInterval, spanStop)) {\n    //The track takes up the entire visible span.\n    context.fillStyle = this.color.toCssColorString();\n    context.fillRect(0, renderState.y, renderState.timeBarWidth, this.height);\n  } else if (JulianDate.lessThanOrEquals(startInterval, spanStop) && JulianDate.greaterThanOrEquals(stopInterval, spanStart)) {\n    //The track only takes up some of the visible span, compute that span.\n    var x;\n    var start, stop;\n\n    for (x = 0; x < renderState.timeBarWidth; ++x) {\n      var currentTime = JulianDate.addSeconds(renderState.startJulian, x / renderState.timeBarWidth * renderState.duration, new JulianDate());\n\n      if (!defined(start) && JulianDate.greaterThanOrEquals(currentTime, startInterval)) {\n        start = x;\n      } else if (!defined(stop) && JulianDate.greaterThanOrEquals(currentTime, stopInterval)) {\n        stop = x;\n      }\n    }\n\n    context.fillStyle = this.backgroundColor.toCssColorString();\n    context.fillRect(0, renderState.y, renderState.timeBarWidth, this.height);\n\n    if (defined(start)) {\n      if (!defined(stop)) {\n        stop = renderState.timeBarWidth;\n      }\n\n      context.fillStyle = this.color.toCssColorString();\n      context.fillRect(start, renderState.y, Math.max(stop - start, 1), this.height);\n    }\n  }\n};\n\nexport default TimelineTrack;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Widgets/Timeline/TimelineTrack.js"],"names":["Color","defined","JulianDate","TimelineTrack","interval","pixelHeight","color","backgroundColor","height","prototype","render","context","renderState","startInterval","start","stopInterval","stop","spanStart","startJulian","spanStop","addSeconds","duration","lessThan","greaterThan","fillStyle","toCssColorString","fillRect","y","timeBarWidth","lessThanOrEquals","greaterThanOrEquals","x","currentTime","Math","max"],"mappings":"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","sourcesContent":["import Color from \"../../Core/Color.js\";\nimport defined from \"../../Core/defined.js\";\nimport JulianDate from \"../../Core/JulianDate.js\";\n\n/**\n * @private\n */\nfunction TimelineTrack(interval, pixelHeight, color, backgroundColor) {\n  this.interval = interval;\n  this.height = pixelHeight;\n  this.color = color || new Color(0.5, 0.5, 0.5, 1.0);\n  this.backgroundColor = backgroundColor || new Color(0.0, 0.0, 0.0, 0.0);\n}\n\nTimelineTrack.prototype.render = function (context, renderState) {\n  var startInterval = this.interval.start;\n  var stopInterval = this.interval.stop;\n\n  var spanStart = renderState.startJulian;\n  var spanStop = JulianDate.addSeconds(\n    renderState.startJulian,\n    renderState.duration,\n    new JulianDate()\n  );\n\n  if (\n    JulianDate.lessThan(startInterval, spanStart) &&\n    JulianDate.greaterThan(stopInterval, spanStop)\n  ) {\n    //The track takes up the entire visible span.\n    context.fillStyle = this.color.toCssColorString();\n    context.fillRect(0, renderState.y, renderState.timeBarWidth, this.height);\n  } else if (\n    JulianDate.lessThanOrEquals(startInterval, spanStop) &&\n    JulianDate.greaterThanOrEquals(stopInterval, spanStart)\n  ) {\n    //The track only takes up some of the visible span, compute that span.\n    var x;\n    var start, stop;\n    for (x = 0; x < renderState.timeBarWidth; ++x) {\n      var currentTime = JulianDate.addSeconds(\n        renderState.startJulian,\n        (x / renderState.timeBarWidth) * renderState.duration,\n        new JulianDate()\n      );\n      if (\n        !defined(start) &&\n        JulianDate.greaterThanOrEquals(currentTime, startInterval)\n      ) {\n        start = x;\n      } else if (\n        !defined(stop) &&\n        JulianDate.greaterThanOrEquals(currentTime, stopInterval)\n      ) {\n        stop = x;\n      }\n    }\n\n    context.fillStyle = this.backgroundColor.toCssColorString();\n    context.fillRect(0, renderState.y, renderState.timeBarWidth, this.height);\n\n    if (defined(start)) {\n      if (!defined(stop)) {\n        stop = renderState.timeBarWidth;\n      }\n      context.fillStyle = this.color.toCssColorString();\n      context.fillRect(\n        start,\n        renderState.y,\n        Math.max(stop - start, 1),\n        this.height\n      );\n    }\n  }\n};\nexport default TimelineTrack;\n"]},"metadata":{},"sourceType":"module"}