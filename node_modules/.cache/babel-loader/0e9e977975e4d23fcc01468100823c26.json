{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport GeographicProjection from \"../Core/GeographicProjection.js\";\nimport Geometry from \"../Core/Geometry.js\";\nimport GeometryAttribute from \"../Core/GeometryAttribute.js\";\nimport GeometryAttributes from \"../Core/GeometryAttributes.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\n\nfunction transformToWorldCoordinates(instances, primitiveModelMatrix, scene3DOnly) {\n  var toWorld = !scene3DOnly;\n  var length = instances.length;\n  var i;\n\n  if (!toWorld && length > 1) {\n    var modelMatrix = instances[0].modelMatrix;\n\n    for (i = 1; i < length; ++i) {\n      if (!Matrix4.equals(modelMatrix, instances[i].modelMatrix)) {\n        toWorld = true;\n        break;\n      }\n    }\n  }\n\n  if (toWorld) {\n    for (i = 0; i < length; ++i) {\n      if (defined(instances[i].geometry)) {\n        GeometryPipeline.transformToWorldCoordinates(instances[i]);\n      }\n    }\n  } else {\n    // Leave geometry in local coordinate system; auto update model-matrix.\n    Matrix4.multiplyTransformation(primitiveModelMatrix, instances[0].modelMatrix, primitiveModelMatrix);\n  }\n}\n\nfunction addGeometryBatchId(geometry, batchId) {\n  var attributes = geometry.attributes;\n  var positionAttr = attributes.position;\n  var numberOfComponents = positionAttr.values.length / positionAttr.componentsPerAttribute;\n  attributes.batchId = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 1,\n    values: new Float32Array(numberOfComponents)\n  });\n  var values = attributes.batchId.values;\n\n  for (var j = 0; j < numberOfComponents; ++j) {\n    values[j] = batchId;\n  }\n}\n\nfunction addBatchIds(instances) {\n  var length = instances.length;\n\n  for (var i = 0; i < length; ++i) {\n    var instance = instances[i];\n\n    if (defined(instance.geometry)) {\n      addGeometryBatchId(instance.geometry, i);\n    } else if (defined(instance.westHemisphereGeometry) && defined(instance.eastHemisphereGeometry)) {\n      addGeometryBatchId(instance.westHemisphereGeometry, i);\n      addGeometryBatchId(instance.eastHemisphereGeometry, i);\n    }\n  }\n}\n\nfunction geometryPipeline(parameters) {\n  var instances = parameters.instances;\n  var projection = parameters.projection;\n  var uintIndexSupport = parameters.elementIndexUintSupported;\n  var scene3DOnly = parameters.scene3DOnly;\n  var vertexCacheOptimize = parameters.vertexCacheOptimize;\n  var compressVertices = parameters.compressVertices;\n  var modelMatrix = parameters.modelMatrix;\n  var i;\n  var geometry;\n  var primitiveType;\n  var length = instances.length;\n\n  for (i = 0; i < length; ++i) {\n    if (defined(instances[i].geometry)) {\n      primitiveType = instances[i].geometry.primitiveType;\n      break;\n    }\n  } //>>includeStart('debug', pragmas.debug);\n\n\n  for (i = 1; i < length; ++i) {\n    if (defined(instances[i].geometry) && instances[i].geometry.primitiveType !== primitiveType) {\n      throw new DeveloperError(\"All instance geometries must have the same primitiveType.\");\n    }\n  } //>>includeEnd('debug');\n  // Unify to world coordinates before combining.\n\n\n  transformToWorldCoordinates(instances, modelMatrix, scene3DOnly); // Clip to IDL\n\n  if (!scene3DOnly) {\n    for (i = 0; i < length; ++i) {\n      if (defined(instances[i].geometry)) {\n        GeometryPipeline.splitLongitude(instances[i]);\n      }\n    }\n  }\n\n  addBatchIds(instances); // Optimize for vertex shader caches\n\n  if (vertexCacheOptimize) {\n    for (i = 0; i < length; ++i) {\n      var instance = instances[i];\n\n      if (defined(instance.geometry)) {\n        GeometryPipeline.reorderForPostVertexCache(instance.geometry);\n        GeometryPipeline.reorderForPreVertexCache(instance.geometry);\n      } else if (defined(instance.westHemisphereGeometry) && defined(instance.eastHemisphereGeometry)) {\n        GeometryPipeline.reorderForPostVertexCache(instance.westHemisphereGeometry);\n        GeometryPipeline.reorderForPreVertexCache(instance.westHemisphereGeometry);\n        GeometryPipeline.reorderForPostVertexCache(instance.eastHemisphereGeometry);\n        GeometryPipeline.reorderForPreVertexCache(instance.eastHemisphereGeometry);\n      }\n    }\n  } // Combine into single geometry for better rendering performance.\n\n\n  var geometries = GeometryPipeline.combineInstances(instances);\n  length = geometries.length;\n\n  for (i = 0; i < length; ++i) {\n    geometry = geometries[i]; // Split positions for GPU RTE\n\n    var attributes = geometry.attributes;\n    var name;\n\n    if (!scene3DOnly) {\n      for (name in attributes) {\n        if (attributes.hasOwnProperty(name) && attributes[name].componentDatatype === ComponentDatatype.DOUBLE) {\n          var name3D = name + \"3D\";\n          var name2D = name + \"2D\"; // Compute 2D positions\n\n          GeometryPipeline.projectTo2D(geometry, name, name3D, name2D, projection);\n\n          if (defined(geometry.boundingSphere) && name === \"position\") {\n            geometry.boundingSphereCV = BoundingSphere.fromVertices(geometry.attributes.position2D.values);\n          }\n\n          GeometryPipeline.encodeAttribute(geometry, name3D, name3D + \"High\", name3D + \"Low\");\n          GeometryPipeline.encodeAttribute(geometry, name2D, name2D + \"High\", name2D + \"Low\");\n        }\n      }\n    } else {\n      for (name in attributes) {\n        if (attributes.hasOwnProperty(name) && attributes[name].componentDatatype === ComponentDatatype.DOUBLE) {\n          GeometryPipeline.encodeAttribute(geometry, name, name + \"3DHigh\", name + \"3DLow\");\n        }\n      }\n    } // oct encode and pack normals, compress texture coordinates\n\n\n    if (compressVertices) {\n      GeometryPipeline.compressVertices(geometry);\n    }\n  }\n\n  if (!uintIndexSupport) {\n    // Break into multiple geometries to fit within unsigned short indices if needed\n    var splitGeometries = [];\n    length = geometries.length;\n\n    for (i = 0; i < length; ++i) {\n      geometry = geometries[i];\n      splitGeometries = splitGeometries.concat(GeometryPipeline.fitToUnsignedShortIndices(geometry));\n    }\n\n    geometries = splitGeometries;\n  }\n\n  return geometries;\n}\n\nfunction createPickOffsets(instances, geometryName, geometries, pickOffsets) {\n  var offset;\n  var indexCount;\n  var geometryIndex;\n  var offsetIndex = pickOffsets.length - 1;\n\n  if (offsetIndex >= 0) {\n    var pickOffset = pickOffsets[offsetIndex];\n    offset = pickOffset.offset + pickOffset.count;\n    geometryIndex = pickOffset.index;\n    indexCount = geometries[geometryIndex].indices.length;\n  } else {\n    offset = 0;\n    geometryIndex = 0;\n    indexCount = geometries[geometryIndex].indices.length;\n  }\n\n  var length = instances.length;\n\n  for (var i = 0; i < length; ++i) {\n    var instance = instances[i];\n    var geometry = instance[geometryName];\n\n    if (!defined(geometry)) {\n      continue;\n    }\n\n    var count = geometry.indices.length;\n\n    if (offset + count > indexCount) {\n      offset = 0;\n      indexCount = geometries[++geometryIndex].indices.length;\n    }\n\n    pickOffsets.push({\n      index: geometryIndex,\n      offset: offset,\n      count: count\n    });\n    offset += count;\n  }\n}\n\nfunction createInstancePickOffsets(instances, geometries) {\n  var pickOffsets = [];\n  createPickOffsets(instances, \"geometry\", geometries, pickOffsets);\n  createPickOffsets(instances, \"westHemisphereGeometry\", geometries, pickOffsets);\n  createPickOffsets(instances, \"eastHemisphereGeometry\", geometries, pickOffsets);\n  return pickOffsets;\n}\n/**\n * @private\n */\n\n\nvar PrimitivePipeline = {};\n/**\n * @private\n */\n\nPrimitivePipeline.combineGeometry = function (parameters) {\n  var geometries;\n  var attributeLocations;\n  var instances = parameters.instances;\n  var length = instances.length;\n  var pickOffsets;\n  var offsetInstanceExtend;\n  var hasOffset = false;\n\n  if (length > 0) {\n    geometries = geometryPipeline(parameters);\n\n    if (geometries.length > 0) {\n      attributeLocations = GeometryPipeline.createAttributeLocations(geometries[0]);\n\n      if (parameters.createPickOffsets) {\n        pickOffsets = createInstancePickOffsets(instances, geometries);\n      }\n    }\n\n    if (defined(instances[0].attributes) && defined(instances[0].attributes.offset)) {\n      offsetInstanceExtend = new Array(length);\n      hasOffset = true;\n    }\n  }\n\n  var boundingSpheres = new Array(length);\n  var boundingSpheresCV = new Array(length);\n\n  for (var i = 0; i < length; ++i) {\n    var instance = instances[i];\n    var geometry = instance.geometry;\n\n    if (defined(geometry)) {\n      boundingSpheres[i] = geometry.boundingSphere;\n      boundingSpheresCV[i] = geometry.boundingSphereCV;\n\n      if (hasOffset) {\n        offsetInstanceExtend[i] = instance.geometry.offsetAttribute;\n      }\n    }\n\n    var eastHemisphereGeometry = instance.eastHemisphereGeometry;\n    var westHemisphereGeometry = instance.westHemisphereGeometry;\n\n    if (defined(eastHemisphereGeometry) && defined(westHemisphereGeometry)) {\n      if (defined(eastHemisphereGeometry.boundingSphere) && defined(westHemisphereGeometry.boundingSphere)) {\n        boundingSpheres[i] = BoundingSphere.union(eastHemisphereGeometry.boundingSphere, westHemisphereGeometry.boundingSphere);\n      }\n\n      if (defined(eastHemisphereGeometry.boundingSphereCV) && defined(westHemisphereGeometry.boundingSphereCV)) {\n        boundingSpheresCV[i] = BoundingSphere.union(eastHemisphereGeometry.boundingSphereCV, westHemisphereGeometry.boundingSphereCV);\n      }\n    }\n  }\n\n  return {\n    geometries: geometries,\n    modelMatrix: parameters.modelMatrix,\n    attributeLocations: attributeLocations,\n    pickOffsets: pickOffsets,\n    offsetInstanceExtend: offsetInstanceExtend,\n    boundingSpheres: boundingSpheres,\n    boundingSpheresCV: boundingSpheresCV\n  };\n};\n\nfunction transferGeometry(geometry, transferableObjects) {\n  var attributes = geometry.attributes;\n\n  for (var name in attributes) {\n    if (attributes.hasOwnProperty(name)) {\n      var attribute = attributes[name];\n\n      if (defined(attribute) && defined(attribute.values)) {\n        transferableObjects.push(attribute.values.buffer);\n      }\n    }\n  }\n\n  if (defined(geometry.indices)) {\n    transferableObjects.push(geometry.indices.buffer);\n  }\n}\n\nfunction transferGeometries(geometries, transferableObjects) {\n  var length = geometries.length;\n\n  for (var i = 0; i < length; ++i) {\n    transferGeometry(geometries[i], transferableObjects);\n  }\n} // This function was created by simplifying packCreateGeometryResults into a count-only operation.\n\n\nfunction countCreateGeometryResults(items) {\n  var count = 1;\n  var length = items.length;\n\n  for (var i = 0; i < length; i++) {\n    var geometry = items[i];\n    ++count;\n\n    if (!defined(geometry)) {\n      continue;\n    }\n\n    var attributes = geometry.attributes;\n    count += 7 + 2 * BoundingSphere.packedLength + (defined(geometry.indices) ? geometry.indices.length : 0);\n\n    for (var property in attributes) {\n      if (attributes.hasOwnProperty(property) && defined(attributes[property])) {\n        var attribute = attributes[property];\n        count += 5 + attribute.values.length;\n      }\n    }\n  }\n\n  return count;\n}\n/**\n * @private\n */\n\n\nPrimitivePipeline.packCreateGeometryResults = function (items, transferableObjects) {\n  var packedData = new Float64Array(countCreateGeometryResults(items));\n  var stringTable = [];\n  var stringHash = {};\n  var length = items.length;\n  var count = 0;\n  packedData[count++] = length;\n\n  for (var i = 0; i < length; i++) {\n    var geometry = items[i];\n    var validGeometry = defined(geometry);\n    packedData[count++] = validGeometry ? 1.0 : 0.0;\n\n    if (!validGeometry) {\n      continue;\n    }\n\n    packedData[count++] = geometry.primitiveType;\n    packedData[count++] = geometry.geometryType;\n    packedData[count++] = defaultValue(geometry.offsetAttribute, -1);\n    var validBoundingSphere = defined(geometry.boundingSphere) ? 1.0 : 0.0;\n    packedData[count++] = validBoundingSphere;\n\n    if (validBoundingSphere) {\n      BoundingSphere.pack(geometry.boundingSphere, packedData, count);\n    }\n\n    count += BoundingSphere.packedLength;\n    var validBoundingSphereCV = defined(geometry.boundingSphereCV) ? 1.0 : 0.0;\n    packedData[count++] = validBoundingSphereCV;\n\n    if (validBoundingSphereCV) {\n      BoundingSphere.pack(geometry.boundingSphereCV, packedData, count);\n    }\n\n    count += BoundingSphere.packedLength;\n    var attributes = geometry.attributes;\n    var attributesToWrite = [];\n\n    for (var property in attributes) {\n      if (attributes.hasOwnProperty(property) && defined(attributes[property])) {\n        attributesToWrite.push(property);\n\n        if (!defined(stringHash[property])) {\n          stringHash[property] = stringTable.length;\n          stringTable.push(property);\n        }\n      }\n    }\n\n    packedData[count++] = attributesToWrite.length;\n\n    for (var q = 0; q < attributesToWrite.length; q++) {\n      var name = attributesToWrite[q];\n      var attribute = attributes[name];\n      packedData[count++] = stringHash[name];\n      packedData[count++] = attribute.componentDatatype;\n      packedData[count++] = attribute.componentsPerAttribute;\n      packedData[count++] = attribute.normalize ? 1 : 0;\n      packedData[count++] = attribute.values.length;\n      packedData.set(attribute.values, count);\n      count += attribute.values.length;\n    }\n\n    var indicesLength = defined(geometry.indices) ? geometry.indices.length : 0;\n    packedData[count++] = indicesLength;\n\n    if (indicesLength > 0) {\n      packedData.set(geometry.indices, count);\n      count += indicesLength;\n    }\n  }\n\n  transferableObjects.push(packedData.buffer);\n  return {\n    stringTable: stringTable,\n    packedData: packedData\n  };\n};\n/**\n * @private\n */\n\n\nPrimitivePipeline.unpackCreateGeometryResults = function (createGeometryResult) {\n  var stringTable = createGeometryResult.stringTable;\n  var packedGeometry = createGeometryResult.packedData;\n  var i;\n  var result = new Array(packedGeometry[0]);\n  var resultIndex = 0;\n  var packedGeometryIndex = 1;\n\n  while (packedGeometryIndex < packedGeometry.length) {\n    var valid = packedGeometry[packedGeometryIndex++] === 1.0;\n\n    if (!valid) {\n      result[resultIndex++] = undefined;\n      continue;\n    }\n\n    var primitiveType = packedGeometry[packedGeometryIndex++];\n    var geometryType = packedGeometry[packedGeometryIndex++];\n    var offsetAttribute = packedGeometry[packedGeometryIndex++];\n\n    if (offsetAttribute === -1) {\n      offsetAttribute = undefined;\n    }\n\n    var boundingSphere;\n    var boundingSphereCV;\n    var validBoundingSphere = packedGeometry[packedGeometryIndex++] === 1.0;\n\n    if (validBoundingSphere) {\n      boundingSphere = BoundingSphere.unpack(packedGeometry, packedGeometryIndex);\n    }\n\n    packedGeometryIndex += BoundingSphere.packedLength;\n    var validBoundingSphereCV = packedGeometry[packedGeometryIndex++] === 1.0;\n\n    if (validBoundingSphereCV) {\n      boundingSphereCV = BoundingSphere.unpack(packedGeometry, packedGeometryIndex);\n    }\n\n    packedGeometryIndex += BoundingSphere.packedLength;\n    var length;\n    var values;\n    var componentsPerAttribute;\n    var attributes = new GeometryAttributes();\n    var numAttributes = packedGeometry[packedGeometryIndex++];\n\n    for (i = 0; i < numAttributes; i++) {\n      var name = stringTable[packedGeometry[packedGeometryIndex++]];\n      var componentDatatype = packedGeometry[packedGeometryIndex++];\n      componentsPerAttribute = packedGeometry[packedGeometryIndex++];\n      var normalize = packedGeometry[packedGeometryIndex++] !== 0;\n      length = packedGeometry[packedGeometryIndex++];\n      values = ComponentDatatype.createTypedArray(componentDatatype, length);\n\n      for (var valuesIndex = 0; valuesIndex < length; valuesIndex++) {\n        values[valuesIndex] = packedGeometry[packedGeometryIndex++];\n      }\n\n      attributes[name] = new GeometryAttribute({\n        componentDatatype: componentDatatype,\n        componentsPerAttribute: componentsPerAttribute,\n        normalize: normalize,\n        values: values\n      });\n    }\n\n    var indices;\n    length = packedGeometry[packedGeometryIndex++];\n\n    if (length > 0) {\n      var numberOfVertices = values.length / componentsPerAttribute;\n      indices = IndexDatatype.createTypedArray(numberOfVertices, length);\n\n      for (i = 0; i < length; i++) {\n        indices[i] = packedGeometry[packedGeometryIndex++];\n      }\n    }\n\n    result[resultIndex++] = new Geometry({\n      primitiveType: primitiveType,\n      geometryType: geometryType,\n      boundingSphere: boundingSphere,\n      boundingSphereCV: boundingSphereCV,\n      indices: indices,\n      attributes: attributes,\n      offsetAttribute: offsetAttribute\n    });\n  }\n\n  return result;\n};\n\nfunction packInstancesForCombine(instances, transferableObjects) {\n  var length = instances.length;\n  var packedData = new Float64Array(1 + length * 19);\n  var count = 0;\n  packedData[count++] = length;\n\n  for (var i = 0; i < length; i++) {\n    var instance = instances[i];\n    Matrix4.pack(instance.modelMatrix, packedData, count);\n    count += Matrix4.packedLength;\n\n    if (defined(instance.attributes) && defined(instance.attributes.offset)) {\n      var values = instance.attributes.offset.value;\n      packedData[count] = values[0];\n      packedData[count + 1] = values[1];\n      packedData[count + 2] = values[2];\n    }\n\n    count += 3;\n  }\n\n  transferableObjects.push(packedData.buffer);\n  return packedData;\n}\n\nfunction unpackInstancesForCombine(data) {\n  var packedInstances = data;\n  var result = new Array(packedInstances[0]);\n  var count = 0;\n  var i = 1;\n\n  while (i < packedInstances.length) {\n    var modelMatrix = Matrix4.unpack(packedInstances, i);\n    var attributes;\n    i += Matrix4.packedLength;\n\n    if (defined(packedInstances[i])) {\n      attributes = {\n        offset: new OffsetGeometryInstanceAttribute(packedInstances[i], packedInstances[i + 1], packedInstances[i + 2])\n      };\n    }\n\n    i += 3;\n    result[count++] = {\n      modelMatrix: modelMatrix,\n      attributes: attributes\n    };\n  }\n\n  return result;\n}\n/**\n * @private\n */\n\n\nPrimitivePipeline.packCombineGeometryParameters = function (parameters, transferableObjects) {\n  var createGeometryResults = parameters.createGeometryResults;\n  var length = createGeometryResults.length;\n\n  for (var i = 0; i < length; i++) {\n    transferableObjects.push(createGeometryResults[i].packedData.buffer);\n  }\n\n  return {\n    createGeometryResults: parameters.createGeometryResults,\n    packedInstances: packInstancesForCombine(parameters.instances, transferableObjects),\n    ellipsoid: parameters.ellipsoid,\n    isGeographic: parameters.projection instanceof GeographicProjection,\n    elementIndexUintSupported: parameters.elementIndexUintSupported,\n    scene3DOnly: parameters.scene3DOnly,\n    vertexCacheOptimize: parameters.vertexCacheOptimize,\n    compressVertices: parameters.compressVertices,\n    modelMatrix: parameters.modelMatrix,\n    createPickOffsets: parameters.createPickOffsets\n  };\n};\n/**\n * @private\n */\n\n\nPrimitivePipeline.unpackCombineGeometryParameters = function (packedParameters) {\n  var instances = unpackInstancesForCombine(packedParameters.packedInstances);\n  var createGeometryResults = packedParameters.createGeometryResults;\n  var length = createGeometryResults.length;\n  var instanceIndex = 0;\n\n  for (var resultIndex = 0; resultIndex < length; resultIndex++) {\n    var geometries = PrimitivePipeline.unpackCreateGeometryResults(createGeometryResults[resultIndex]);\n    var geometriesLength = geometries.length;\n\n    for (var geometryIndex = 0; geometryIndex < geometriesLength; geometryIndex++) {\n      var geometry = geometries[geometryIndex];\n      var instance = instances[instanceIndex];\n      instance.geometry = geometry;\n      ++instanceIndex;\n    }\n  }\n\n  var ellipsoid = Ellipsoid.clone(packedParameters.ellipsoid);\n  var projection = packedParameters.isGeographic ? new GeographicProjection(ellipsoid) : new WebMercatorProjection(ellipsoid);\n  return {\n    instances: instances,\n    ellipsoid: ellipsoid,\n    projection: projection,\n    elementIndexUintSupported: packedParameters.elementIndexUintSupported,\n    scene3DOnly: packedParameters.scene3DOnly,\n    vertexCacheOptimize: packedParameters.vertexCacheOptimize,\n    compressVertices: packedParameters.compressVertices,\n    modelMatrix: Matrix4.clone(packedParameters.modelMatrix),\n    createPickOffsets: packedParameters.createPickOffsets\n  };\n};\n\nfunction packBoundingSpheres(boundingSpheres) {\n  var length = boundingSpheres.length;\n  var bufferLength = 1 + (BoundingSphere.packedLength + 1) * length;\n  var buffer = new Float32Array(bufferLength);\n  var bufferIndex = 0;\n  buffer[bufferIndex++] = length;\n\n  for (var i = 0; i < length; ++i) {\n    var bs = boundingSpheres[i];\n\n    if (!defined(bs)) {\n      buffer[bufferIndex++] = 0.0;\n    } else {\n      buffer[bufferIndex++] = 1.0;\n      BoundingSphere.pack(boundingSpheres[i], buffer, bufferIndex);\n    }\n\n    bufferIndex += BoundingSphere.packedLength;\n  }\n\n  return buffer;\n}\n\nfunction unpackBoundingSpheres(buffer) {\n  var result = new Array(buffer[0]);\n  var count = 0;\n  var i = 1;\n\n  while (i < buffer.length) {\n    if (buffer[i++] === 1.0) {\n      result[count] = BoundingSphere.unpack(buffer, i);\n    }\n\n    ++count;\n    i += BoundingSphere.packedLength;\n  }\n\n  return result;\n}\n/**\n * @private\n */\n\n\nPrimitivePipeline.packCombineGeometryResults = function (results, transferableObjects) {\n  if (defined(results.geometries)) {\n    transferGeometries(results.geometries, transferableObjects);\n  }\n\n  var packedBoundingSpheres = packBoundingSpheres(results.boundingSpheres);\n  var packedBoundingSpheresCV = packBoundingSpheres(results.boundingSpheresCV);\n  transferableObjects.push(packedBoundingSpheres.buffer, packedBoundingSpheresCV.buffer);\n  return {\n    geometries: results.geometries,\n    attributeLocations: results.attributeLocations,\n    modelMatrix: results.modelMatrix,\n    pickOffsets: results.pickOffsets,\n    offsetInstanceExtend: results.offsetInstanceExtend,\n    boundingSpheres: packedBoundingSpheres,\n    boundingSpheresCV: packedBoundingSpheresCV\n  };\n};\n/**\n * @private\n */\n\n\nPrimitivePipeline.unpackCombineGeometryResults = function (packedResult) {\n  return {\n    geometries: packedResult.geometries,\n    attributeLocations: packedResult.attributeLocations,\n    modelMatrix: packedResult.modelMatrix,\n    pickOffsets: packedResult.pickOffsets,\n    offsetInstanceExtend: packedResult.offsetInstanceExtend,\n    boundingSpheres: unpackBoundingSpheres(packedResult.boundingSpheres),\n    boundingSpheresCV: unpackBoundingSpheres(packedResult.boundingSpheresCV)\n  };\n};\n\nexport default PrimitivePipeline;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/PrimitivePipeline.js"],"names":["BoundingSphere","ComponentDatatype","defaultValue","defined","DeveloperError","Ellipsoid","GeographicProjection","Geometry","GeometryAttribute","GeometryAttributes","GeometryPipeline","IndexDatatype","Matrix4","OffsetGeometryInstanceAttribute","WebMercatorProjection","transformToWorldCoordinates","instances","primitiveModelMatrix","scene3DOnly","toWorld","length","i","modelMatrix","equals","geometry","multiplyTransformation","addGeometryBatchId","batchId","attributes","positionAttr","position","numberOfComponents","values","componentsPerAttribute","componentDatatype","FLOAT","Float32Array","j","addBatchIds","instance","westHemisphereGeometry","eastHemisphereGeometry","geometryPipeline","parameters","projection","uintIndexSupport","elementIndexUintSupported","vertexCacheOptimize","compressVertices","primitiveType","splitLongitude","reorderForPostVertexCache","reorderForPreVertexCache","geometries","combineInstances","name","hasOwnProperty","DOUBLE","name3D","name2D","projectTo2D","boundingSphere","boundingSphereCV","fromVertices","position2D","encodeAttribute","splitGeometries","concat","fitToUnsignedShortIndices","createPickOffsets","geometryName","pickOffsets","offset","indexCount","geometryIndex","offsetIndex","pickOffset","count","index","indices","push","createInstancePickOffsets","PrimitivePipeline","combineGeometry","attributeLocations","offsetInstanceExtend","hasOffset","createAttributeLocations","Array","boundingSpheres","boundingSpheresCV","offsetAttribute","union","transferGeometry","transferableObjects","attribute","buffer","transferGeometries","countCreateGeometryResults","items","packedLength","property","packCreateGeometryResults","packedData","Float64Array","stringTable","stringHash","validGeometry","geometryType","validBoundingSphere","pack","validBoundingSphereCV","attributesToWrite","q","normalize","set","indicesLength","unpackCreateGeometryResults","createGeometryResult","packedGeometry","result","resultIndex","packedGeometryIndex","valid","undefined","unpack","numAttributes","createTypedArray","valuesIndex","numberOfVertices","packInstancesForCombine","value","unpackInstancesForCombine","data","packedInstances","packCombineGeometryParameters","createGeometryResults","ellipsoid","isGeographic","unpackCombineGeometryParameters","packedParameters","instanceIndex","geometriesLength","clone","packBoundingSpheres","bufferLength","bufferIndex","bs","unpackBoundingSpheres","packCombineGeometryResults","results","packedBoundingSpheres","packedBoundingSpheresCV","unpackCombineGeometryResults","packedResult"],"mappings":"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","sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport GeographicProjection from \"../Core/GeographicProjection.js\";\nimport Geometry from \"../Core/Geometry.js\";\nimport GeometryAttribute from \"../Core/GeometryAttribute.js\";\nimport GeometryAttributes from \"../Core/GeometryAttributes.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\n\nfunction transformToWorldCoordinates(\n  instances,\n  primitiveModelMatrix,\n  scene3DOnly\n) {\n  var toWorld = !scene3DOnly;\n  var length = instances.length;\n  var i;\n\n  if (!toWorld && length > 1) {\n    var modelMatrix = instances[0].modelMatrix;\n\n    for (i = 1; i < length; ++i) {\n      if (!Matrix4.equals(modelMatrix, instances[i].modelMatrix)) {\n        toWorld = true;\n        break;\n      }\n    }\n  }\n\n  if (toWorld) {\n    for (i = 0; i < length; ++i) {\n      if (defined(instances[i].geometry)) {\n        GeometryPipeline.transformToWorldCoordinates(instances[i]);\n      }\n    }\n  } else {\n    // Leave geometry in local coordinate system; auto update model-matrix.\n    Matrix4.multiplyTransformation(\n      primitiveModelMatrix,\n      instances[0].modelMatrix,\n      primitiveModelMatrix\n    );\n  }\n}\n\nfunction addGeometryBatchId(geometry, batchId) {\n  var attributes = geometry.attributes;\n  var positionAttr = attributes.position;\n  var numberOfComponents =\n    positionAttr.values.length / positionAttr.componentsPerAttribute;\n\n  attributes.batchId = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 1,\n    values: new Float32Array(numberOfComponents),\n  });\n\n  var values = attributes.batchId.values;\n  for (var j = 0; j < numberOfComponents; ++j) {\n    values[j] = batchId;\n  }\n}\n\nfunction addBatchIds(instances) {\n  var length = instances.length;\n\n  for (var i = 0; i < length; ++i) {\n    var instance = instances[i];\n    if (defined(instance.geometry)) {\n      addGeometryBatchId(instance.geometry, i);\n    } else if (\n      defined(instance.westHemisphereGeometry) &&\n      defined(instance.eastHemisphereGeometry)\n    ) {\n      addGeometryBatchId(instance.westHemisphereGeometry, i);\n      addGeometryBatchId(instance.eastHemisphereGeometry, i);\n    }\n  }\n}\n\nfunction geometryPipeline(parameters) {\n  var instances = parameters.instances;\n  var projection = parameters.projection;\n  var uintIndexSupport = parameters.elementIndexUintSupported;\n  var scene3DOnly = parameters.scene3DOnly;\n  var vertexCacheOptimize = parameters.vertexCacheOptimize;\n  var compressVertices = parameters.compressVertices;\n  var modelMatrix = parameters.modelMatrix;\n\n  var i;\n  var geometry;\n  var primitiveType;\n  var length = instances.length;\n\n  for (i = 0; i < length; ++i) {\n    if (defined(instances[i].geometry)) {\n      primitiveType = instances[i].geometry.primitiveType;\n      break;\n    }\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  for (i = 1; i < length; ++i) {\n    if (\n      defined(instances[i].geometry) &&\n      instances[i].geometry.primitiveType !== primitiveType\n    ) {\n      throw new DeveloperError(\n        \"All instance geometries must have the same primitiveType.\"\n      );\n    }\n  }\n  //>>includeEnd('debug');\n\n  // Unify to world coordinates before combining.\n  transformToWorldCoordinates(instances, modelMatrix, scene3DOnly);\n\n  // Clip to IDL\n  if (!scene3DOnly) {\n    for (i = 0; i < length; ++i) {\n      if (defined(instances[i].geometry)) {\n        GeometryPipeline.splitLongitude(instances[i]);\n      }\n    }\n  }\n\n  addBatchIds(instances);\n\n  // Optimize for vertex shader caches\n  if (vertexCacheOptimize) {\n    for (i = 0; i < length; ++i) {\n      var instance = instances[i];\n      if (defined(instance.geometry)) {\n        GeometryPipeline.reorderForPostVertexCache(instance.geometry);\n        GeometryPipeline.reorderForPreVertexCache(instance.geometry);\n      } else if (\n        defined(instance.westHemisphereGeometry) &&\n        defined(instance.eastHemisphereGeometry)\n      ) {\n        GeometryPipeline.reorderForPostVertexCache(\n          instance.westHemisphereGeometry\n        );\n        GeometryPipeline.reorderForPreVertexCache(\n          instance.westHemisphereGeometry\n        );\n\n        GeometryPipeline.reorderForPostVertexCache(\n          instance.eastHemisphereGeometry\n        );\n        GeometryPipeline.reorderForPreVertexCache(\n          instance.eastHemisphereGeometry\n        );\n      }\n    }\n  }\n\n  // Combine into single geometry for better rendering performance.\n  var geometries = GeometryPipeline.combineInstances(instances);\n\n  length = geometries.length;\n  for (i = 0; i < length; ++i) {\n    geometry = geometries[i];\n\n    // Split positions for GPU RTE\n    var attributes = geometry.attributes;\n    var name;\n    if (!scene3DOnly) {\n      for (name in attributes) {\n        if (\n          attributes.hasOwnProperty(name) &&\n          attributes[name].componentDatatype === ComponentDatatype.DOUBLE\n        ) {\n          var name3D = name + \"3D\";\n          var name2D = name + \"2D\";\n\n          // Compute 2D positions\n          GeometryPipeline.projectTo2D(\n            geometry,\n            name,\n            name3D,\n            name2D,\n            projection\n          );\n          if (defined(geometry.boundingSphere) && name === \"position\") {\n            geometry.boundingSphereCV = BoundingSphere.fromVertices(\n              geometry.attributes.position2D.values\n            );\n          }\n\n          GeometryPipeline.encodeAttribute(\n            geometry,\n            name3D,\n            name3D + \"High\",\n            name3D + \"Low\"\n          );\n          GeometryPipeline.encodeAttribute(\n            geometry,\n            name2D,\n            name2D + \"High\",\n            name2D + \"Low\"\n          );\n        }\n      }\n    } else {\n      for (name in attributes) {\n        if (\n          attributes.hasOwnProperty(name) &&\n          attributes[name].componentDatatype === ComponentDatatype.DOUBLE\n        ) {\n          GeometryPipeline.encodeAttribute(\n            geometry,\n            name,\n            name + \"3DHigh\",\n            name + \"3DLow\"\n          );\n        }\n      }\n    }\n\n    // oct encode and pack normals, compress texture coordinates\n    if (compressVertices) {\n      GeometryPipeline.compressVertices(geometry);\n    }\n  }\n\n  if (!uintIndexSupport) {\n    // Break into multiple geometries to fit within unsigned short indices if needed\n    var splitGeometries = [];\n    length = geometries.length;\n    for (i = 0; i < length; ++i) {\n      geometry = geometries[i];\n      splitGeometries = splitGeometries.concat(\n        GeometryPipeline.fitToUnsignedShortIndices(geometry)\n      );\n    }\n\n    geometries = splitGeometries;\n  }\n\n  return geometries;\n}\n\nfunction createPickOffsets(instances, geometryName, geometries, pickOffsets) {\n  var offset;\n  var indexCount;\n  var geometryIndex;\n\n  var offsetIndex = pickOffsets.length - 1;\n  if (offsetIndex >= 0) {\n    var pickOffset = pickOffsets[offsetIndex];\n    offset = pickOffset.offset + pickOffset.count;\n    geometryIndex = pickOffset.index;\n    indexCount = geometries[geometryIndex].indices.length;\n  } else {\n    offset = 0;\n    geometryIndex = 0;\n    indexCount = geometries[geometryIndex].indices.length;\n  }\n\n  var length = instances.length;\n  for (var i = 0; i < length; ++i) {\n    var instance = instances[i];\n    var geometry = instance[geometryName];\n    if (!defined(geometry)) {\n      continue;\n    }\n\n    var count = geometry.indices.length;\n\n    if (offset + count > indexCount) {\n      offset = 0;\n      indexCount = geometries[++geometryIndex].indices.length;\n    }\n\n    pickOffsets.push({\n      index: geometryIndex,\n      offset: offset,\n      count: count,\n    });\n    offset += count;\n  }\n}\n\nfunction createInstancePickOffsets(instances, geometries) {\n  var pickOffsets = [];\n  createPickOffsets(instances, \"geometry\", geometries, pickOffsets);\n  createPickOffsets(\n    instances,\n    \"westHemisphereGeometry\",\n    geometries,\n    pickOffsets\n  );\n  createPickOffsets(\n    instances,\n    \"eastHemisphereGeometry\",\n    geometries,\n    pickOffsets\n  );\n  return pickOffsets;\n}\n\n/**\n * @private\n */\nvar PrimitivePipeline = {};\n\n/**\n * @private\n */\nPrimitivePipeline.combineGeometry = function (parameters) {\n  var geometries;\n  var attributeLocations;\n  var instances = parameters.instances;\n  var length = instances.length;\n  var pickOffsets;\n\n  var offsetInstanceExtend;\n  var hasOffset = false;\n  if (length > 0) {\n    geometries = geometryPipeline(parameters);\n    if (geometries.length > 0) {\n      attributeLocations = GeometryPipeline.createAttributeLocations(\n        geometries[0]\n      );\n      if (parameters.createPickOffsets) {\n        pickOffsets = createInstancePickOffsets(instances, geometries);\n      }\n    }\n    if (\n      defined(instances[0].attributes) &&\n      defined(instances[0].attributes.offset)\n    ) {\n      offsetInstanceExtend = new Array(length);\n      hasOffset = true;\n    }\n  }\n\n  var boundingSpheres = new Array(length);\n  var boundingSpheresCV = new Array(length);\n  for (var i = 0; i < length; ++i) {\n    var instance = instances[i];\n    var geometry = instance.geometry;\n    if (defined(geometry)) {\n      boundingSpheres[i] = geometry.boundingSphere;\n      boundingSpheresCV[i] = geometry.boundingSphereCV;\n      if (hasOffset) {\n        offsetInstanceExtend[i] = instance.geometry.offsetAttribute;\n      }\n    }\n\n    var eastHemisphereGeometry = instance.eastHemisphereGeometry;\n    var westHemisphereGeometry = instance.westHemisphereGeometry;\n    if (defined(eastHemisphereGeometry) && defined(westHemisphereGeometry)) {\n      if (\n        defined(eastHemisphereGeometry.boundingSphere) &&\n        defined(westHemisphereGeometry.boundingSphere)\n      ) {\n        boundingSpheres[i] = BoundingSphere.union(\n          eastHemisphereGeometry.boundingSphere,\n          westHemisphereGeometry.boundingSphere\n        );\n      }\n      if (\n        defined(eastHemisphereGeometry.boundingSphereCV) &&\n        defined(westHemisphereGeometry.boundingSphereCV)\n      ) {\n        boundingSpheresCV[i] = BoundingSphere.union(\n          eastHemisphereGeometry.boundingSphereCV,\n          westHemisphereGeometry.boundingSphereCV\n        );\n      }\n    }\n  }\n\n  return {\n    geometries: geometries,\n    modelMatrix: parameters.modelMatrix,\n    attributeLocations: attributeLocations,\n    pickOffsets: pickOffsets,\n    offsetInstanceExtend: offsetInstanceExtend,\n    boundingSpheres: boundingSpheres,\n    boundingSpheresCV: boundingSpheresCV,\n  };\n};\n\nfunction transferGeometry(geometry, transferableObjects) {\n  var attributes = geometry.attributes;\n  for (var name in attributes) {\n    if (attributes.hasOwnProperty(name)) {\n      var attribute = attributes[name];\n\n      if (defined(attribute) && defined(attribute.values)) {\n        transferableObjects.push(attribute.values.buffer);\n      }\n    }\n  }\n\n  if (defined(geometry.indices)) {\n    transferableObjects.push(geometry.indices.buffer);\n  }\n}\n\nfunction transferGeometries(geometries, transferableObjects) {\n  var length = geometries.length;\n  for (var i = 0; i < length; ++i) {\n    transferGeometry(geometries[i], transferableObjects);\n  }\n}\n\n// This function was created by simplifying packCreateGeometryResults into a count-only operation.\nfunction countCreateGeometryResults(items) {\n  var count = 1;\n  var length = items.length;\n  for (var i = 0; i < length; i++) {\n    var geometry = items[i];\n    ++count;\n\n    if (!defined(geometry)) {\n      continue;\n    }\n\n    var attributes = geometry.attributes;\n\n    count +=\n      7 +\n      2 * BoundingSphere.packedLength +\n      (defined(geometry.indices) ? geometry.indices.length : 0);\n\n    for (var property in attributes) {\n      if (\n        attributes.hasOwnProperty(property) &&\n        defined(attributes[property])\n      ) {\n        var attribute = attributes[property];\n        count += 5 + attribute.values.length;\n      }\n    }\n  }\n\n  return count;\n}\n\n/**\n * @private\n */\nPrimitivePipeline.packCreateGeometryResults = function (\n  items,\n  transferableObjects\n) {\n  var packedData = new Float64Array(countCreateGeometryResults(items));\n  var stringTable = [];\n  var stringHash = {};\n\n  var length = items.length;\n  var count = 0;\n  packedData[count++] = length;\n  for (var i = 0; i < length; i++) {\n    var geometry = items[i];\n\n    var validGeometry = defined(geometry);\n    packedData[count++] = validGeometry ? 1.0 : 0.0;\n\n    if (!validGeometry) {\n      continue;\n    }\n\n    packedData[count++] = geometry.primitiveType;\n    packedData[count++] = geometry.geometryType;\n    packedData[count++] = defaultValue(geometry.offsetAttribute, -1);\n\n    var validBoundingSphere = defined(geometry.boundingSphere) ? 1.0 : 0.0;\n    packedData[count++] = validBoundingSphere;\n    if (validBoundingSphere) {\n      BoundingSphere.pack(geometry.boundingSphere, packedData, count);\n    }\n\n    count += BoundingSphere.packedLength;\n\n    var validBoundingSphereCV = defined(geometry.boundingSphereCV) ? 1.0 : 0.0;\n    packedData[count++] = validBoundingSphereCV;\n    if (validBoundingSphereCV) {\n      BoundingSphere.pack(geometry.boundingSphereCV, packedData, count);\n    }\n\n    count += BoundingSphere.packedLength;\n\n    var attributes = geometry.attributes;\n    var attributesToWrite = [];\n    for (var property in attributes) {\n      if (\n        attributes.hasOwnProperty(property) &&\n        defined(attributes[property])\n      ) {\n        attributesToWrite.push(property);\n        if (!defined(stringHash[property])) {\n          stringHash[property] = stringTable.length;\n          stringTable.push(property);\n        }\n      }\n    }\n\n    packedData[count++] = attributesToWrite.length;\n    for (var q = 0; q < attributesToWrite.length; q++) {\n      var name = attributesToWrite[q];\n      var attribute = attributes[name];\n      packedData[count++] = stringHash[name];\n      packedData[count++] = attribute.componentDatatype;\n      packedData[count++] = attribute.componentsPerAttribute;\n      packedData[count++] = attribute.normalize ? 1 : 0;\n      packedData[count++] = attribute.values.length;\n      packedData.set(attribute.values, count);\n      count += attribute.values.length;\n    }\n\n    var indicesLength = defined(geometry.indices) ? geometry.indices.length : 0;\n    packedData[count++] = indicesLength;\n\n    if (indicesLength > 0) {\n      packedData.set(geometry.indices, count);\n      count += indicesLength;\n    }\n  }\n\n  transferableObjects.push(packedData.buffer);\n\n  return {\n    stringTable: stringTable,\n    packedData: packedData,\n  };\n};\n\n/**\n * @private\n */\nPrimitivePipeline.unpackCreateGeometryResults = function (\n  createGeometryResult\n) {\n  var stringTable = createGeometryResult.stringTable;\n  var packedGeometry = createGeometryResult.packedData;\n\n  var i;\n  var result = new Array(packedGeometry[0]);\n  var resultIndex = 0;\n\n  var packedGeometryIndex = 1;\n  while (packedGeometryIndex < packedGeometry.length) {\n    var valid = packedGeometry[packedGeometryIndex++] === 1.0;\n    if (!valid) {\n      result[resultIndex++] = undefined;\n      continue;\n    }\n\n    var primitiveType = packedGeometry[packedGeometryIndex++];\n    var geometryType = packedGeometry[packedGeometryIndex++];\n    var offsetAttribute = packedGeometry[packedGeometryIndex++];\n    if (offsetAttribute === -1) {\n      offsetAttribute = undefined;\n    }\n\n    var boundingSphere;\n    var boundingSphereCV;\n\n    var validBoundingSphere = packedGeometry[packedGeometryIndex++] === 1.0;\n    if (validBoundingSphere) {\n      boundingSphere = BoundingSphere.unpack(\n        packedGeometry,\n        packedGeometryIndex\n      );\n    }\n\n    packedGeometryIndex += BoundingSphere.packedLength;\n\n    var validBoundingSphereCV = packedGeometry[packedGeometryIndex++] === 1.0;\n    if (validBoundingSphereCV) {\n      boundingSphereCV = BoundingSphere.unpack(\n        packedGeometry,\n        packedGeometryIndex\n      );\n    }\n\n    packedGeometryIndex += BoundingSphere.packedLength;\n\n    var length;\n    var values;\n    var componentsPerAttribute;\n    var attributes = new GeometryAttributes();\n    var numAttributes = packedGeometry[packedGeometryIndex++];\n    for (i = 0; i < numAttributes; i++) {\n      var name = stringTable[packedGeometry[packedGeometryIndex++]];\n      var componentDatatype = packedGeometry[packedGeometryIndex++];\n      componentsPerAttribute = packedGeometry[packedGeometryIndex++];\n      var normalize = packedGeometry[packedGeometryIndex++] !== 0;\n\n      length = packedGeometry[packedGeometryIndex++];\n      values = ComponentDatatype.createTypedArray(componentDatatype, length);\n      for (var valuesIndex = 0; valuesIndex < length; valuesIndex++) {\n        values[valuesIndex] = packedGeometry[packedGeometryIndex++];\n      }\n\n      attributes[name] = new GeometryAttribute({\n        componentDatatype: componentDatatype,\n        componentsPerAttribute: componentsPerAttribute,\n        normalize: normalize,\n        values: values,\n      });\n    }\n\n    var indices;\n    length = packedGeometry[packedGeometryIndex++];\n\n    if (length > 0) {\n      var numberOfVertices = values.length / componentsPerAttribute;\n      indices = IndexDatatype.createTypedArray(numberOfVertices, length);\n      for (i = 0; i < length; i++) {\n        indices[i] = packedGeometry[packedGeometryIndex++];\n      }\n    }\n\n    result[resultIndex++] = new Geometry({\n      primitiveType: primitiveType,\n      geometryType: geometryType,\n      boundingSphere: boundingSphere,\n      boundingSphereCV: boundingSphereCV,\n      indices: indices,\n      attributes: attributes,\n      offsetAttribute: offsetAttribute,\n    });\n  }\n\n  return result;\n};\n\nfunction packInstancesForCombine(instances, transferableObjects) {\n  var length = instances.length;\n  var packedData = new Float64Array(1 + length * 19);\n  var count = 0;\n  packedData[count++] = length;\n  for (var i = 0; i < length; i++) {\n    var instance = instances[i];\n    Matrix4.pack(instance.modelMatrix, packedData, count);\n    count += Matrix4.packedLength;\n    if (defined(instance.attributes) && defined(instance.attributes.offset)) {\n      var values = instance.attributes.offset.value;\n      packedData[count] = values[0];\n      packedData[count + 1] = values[1];\n      packedData[count + 2] = values[2];\n    }\n    count += 3;\n  }\n  transferableObjects.push(packedData.buffer);\n\n  return packedData;\n}\n\nfunction unpackInstancesForCombine(data) {\n  var packedInstances = data;\n  var result = new Array(packedInstances[0]);\n  var count = 0;\n\n  var i = 1;\n  while (i < packedInstances.length) {\n    var modelMatrix = Matrix4.unpack(packedInstances, i);\n    var attributes;\n    i += Matrix4.packedLength;\n    if (defined(packedInstances[i])) {\n      attributes = {\n        offset: new OffsetGeometryInstanceAttribute(\n          packedInstances[i],\n          packedInstances[i + 1],\n          packedInstances[i + 2]\n        ),\n      };\n    }\n    i += 3;\n\n    result[count++] = {\n      modelMatrix: modelMatrix,\n      attributes: attributes,\n    };\n  }\n\n  return result;\n}\n\n/**\n * @private\n */\nPrimitivePipeline.packCombineGeometryParameters = function (\n  parameters,\n  transferableObjects\n) {\n  var createGeometryResults = parameters.createGeometryResults;\n  var length = createGeometryResults.length;\n\n  for (var i = 0; i < length; i++) {\n    transferableObjects.push(createGeometryResults[i].packedData.buffer);\n  }\n\n  return {\n    createGeometryResults: parameters.createGeometryResults,\n    packedInstances: packInstancesForCombine(\n      parameters.instances,\n      transferableObjects\n    ),\n    ellipsoid: parameters.ellipsoid,\n    isGeographic: parameters.projection instanceof GeographicProjection,\n    elementIndexUintSupported: parameters.elementIndexUintSupported,\n    scene3DOnly: parameters.scene3DOnly,\n    vertexCacheOptimize: parameters.vertexCacheOptimize,\n    compressVertices: parameters.compressVertices,\n    modelMatrix: parameters.modelMatrix,\n    createPickOffsets: parameters.createPickOffsets,\n  };\n};\n\n/**\n * @private\n */\nPrimitivePipeline.unpackCombineGeometryParameters = function (\n  packedParameters\n) {\n  var instances = unpackInstancesForCombine(packedParameters.packedInstances);\n  var createGeometryResults = packedParameters.createGeometryResults;\n  var length = createGeometryResults.length;\n  var instanceIndex = 0;\n\n  for (var resultIndex = 0; resultIndex < length; resultIndex++) {\n    var geometries = PrimitivePipeline.unpackCreateGeometryResults(\n      createGeometryResults[resultIndex]\n    );\n    var geometriesLength = geometries.length;\n    for (\n      var geometryIndex = 0;\n      geometryIndex < geometriesLength;\n      geometryIndex++\n    ) {\n      var geometry = geometries[geometryIndex];\n      var instance = instances[instanceIndex];\n      instance.geometry = geometry;\n      ++instanceIndex;\n    }\n  }\n\n  var ellipsoid = Ellipsoid.clone(packedParameters.ellipsoid);\n  var projection = packedParameters.isGeographic\n    ? new GeographicProjection(ellipsoid)\n    : new WebMercatorProjection(ellipsoid);\n\n  return {\n    instances: instances,\n    ellipsoid: ellipsoid,\n    projection: projection,\n    elementIndexUintSupported: packedParameters.elementIndexUintSupported,\n    scene3DOnly: packedParameters.scene3DOnly,\n    vertexCacheOptimize: packedParameters.vertexCacheOptimize,\n    compressVertices: packedParameters.compressVertices,\n    modelMatrix: Matrix4.clone(packedParameters.modelMatrix),\n    createPickOffsets: packedParameters.createPickOffsets,\n  };\n};\n\nfunction packBoundingSpheres(boundingSpheres) {\n  var length = boundingSpheres.length;\n  var bufferLength = 1 + (BoundingSphere.packedLength + 1) * length;\n  var buffer = new Float32Array(bufferLength);\n\n  var bufferIndex = 0;\n  buffer[bufferIndex++] = length;\n\n  for (var i = 0; i < length; ++i) {\n    var bs = boundingSpheres[i];\n    if (!defined(bs)) {\n      buffer[bufferIndex++] = 0.0;\n    } else {\n      buffer[bufferIndex++] = 1.0;\n      BoundingSphere.pack(boundingSpheres[i], buffer, bufferIndex);\n    }\n    bufferIndex += BoundingSphere.packedLength;\n  }\n\n  return buffer;\n}\n\nfunction unpackBoundingSpheres(buffer) {\n  var result = new Array(buffer[0]);\n  var count = 0;\n\n  var i = 1;\n  while (i < buffer.length) {\n    if (buffer[i++] === 1.0) {\n      result[count] = BoundingSphere.unpack(buffer, i);\n    }\n    ++count;\n    i += BoundingSphere.packedLength;\n  }\n\n  return result;\n}\n\n/**\n * @private\n */\nPrimitivePipeline.packCombineGeometryResults = function (\n  results,\n  transferableObjects\n) {\n  if (defined(results.geometries)) {\n    transferGeometries(results.geometries, transferableObjects);\n  }\n\n  var packedBoundingSpheres = packBoundingSpheres(results.boundingSpheres);\n  var packedBoundingSpheresCV = packBoundingSpheres(results.boundingSpheresCV);\n  transferableObjects.push(\n    packedBoundingSpheres.buffer,\n    packedBoundingSpheresCV.buffer\n  );\n\n  return {\n    geometries: results.geometries,\n    attributeLocations: results.attributeLocations,\n    modelMatrix: results.modelMatrix,\n    pickOffsets: results.pickOffsets,\n    offsetInstanceExtend: results.offsetInstanceExtend,\n    boundingSpheres: packedBoundingSpheres,\n    boundingSpheresCV: packedBoundingSpheresCV,\n  };\n};\n\n/**\n * @private\n */\nPrimitivePipeline.unpackCombineGeometryResults = function (packedResult) {\n  return {\n    geometries: packedResult.geometries,\n    attributeLocations: packedResult.attributeLocations,\n    modelMatrix: packedResult.modelMatrix,\n    pickOffsets: packedResult.pickOffsets,\n    offsetInstanceExtend: packedResult.offsetInstanceExtend,\n    boundingSpheres: unpackBoundingSpheres(packedResult.boundingSpheres),\n    boundingSpheresCV: unpackBoundingSpheres(packedResult.boundingSpheresCV),\n  };\n};\nexport default PrimitivePipeline;\n"]},"metadata":{},"sourceType":"module"}