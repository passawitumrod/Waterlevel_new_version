{"ast":null,"code":"function quickselect(arr, k, left, right, compare) {\n  quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n  while (right > left) {\n    if (right - left > 600) {\n      var n = right - left + 1;\n      var m = k - left + 1;\n      var z = Math.log(n);\n      var s = 0.5 * Math.exp(2 * z / 3);\n      var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n      var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n      var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n      quickselectStep(arr, k, newLeft, newRight, compare);\n    }\n\n    var t = arr[k];\n    var i = left;\n    var j = right;\n    swap(arr, left, k);\n\n    if (compare(arr[right], t) > 0) {\n      swap(arr, left, right);\n    }\n\n    while (i < j) {\n      swap(arr, i, j);\n      i++;\n      j--;\n\n      while (compare(arr[i], t) < 0) {\n        i++;\n      }\n\n      while (compare(arr[j], t) > 0) {\n        j--;\n      }\n    }\n\n    if (compare(arr[left], t) === 0) {\n      swap(arr, left, j);\n    } else {\n      j++;\n      swap(arr, j, right);\n    }\n\n    if (j <= k) {\n      left = j + 1;\n    }\n\n    if (k <= j) {\n      right = j - 1;\n    }\n  }\n}\n\nfunction swap(arr, i, j) {\n  var tmp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n  return a < b ? -1 : a > b ? 1 : 0;\n}\n\nfunction RBush(maxEntries) {\n  if (maxEntries === void 0) maxEntries = 9; // max entries in a node is 9 by default; min node fill is 40% for best performance\n\n  this._maxEntries = Math.max(4, maxEntries);\n  this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n  this.clear();\n}\n\n;\n\nRBush.prototype.all = function all() {\n  return this._all(this.data, []);\n};\n\nRBush.prototype.search = function search(bbox) {\n  var node = this.data;\n  var result = [];\n\n  if (!intersects(bbox, node)) {\n    return result;\n  }\n\n  var toBBox = this.toBBox;\n  var nodesToSearch = [];\n\n  while (node) {\n    for (var i = 0; i < node.children.length; i++) {\n      var child = node.children[i];\n      var childBBox = node.leaf ? toBBox(child) : child;\n\n      if (intersects(bbox, childBBox)) {\n        if (node.leaf) {\n          result.push(child);\n        } else if (contains(bbox, childBBox)) {\n          this._all(child, result);\n        } else {\n          nodesToSearch.push(child);\n        }\n      }\n    }\n\n    node = nodesToSearch.pop();\n  }\n\n  return result;\n};\n\nRBush.prototype.collides = function collides(bbox) {\n  var node = this.data;\n\n  if (!intersects(bbox, node)) {\n    return false;\n  }\n\n  var nodesToSearch = [];\n\n  while (node) {\n    for (var i = 0; i < node.children.length; i++) {\n      var child = node.children[i];\n      var childBBox = node.leaf ? this.toBBox(child) : child;\n\n      if (intersects(bbox, childBBox)) {\n        if (node.leaf || contains(bbox, childBBox)) {\n          return true;\n        }\n\n        nodesToSearch.push(child);\n      }\n    }\n\n    node = nodesToSearch.pop();\n  }\n\n  return false;\n};\n\nRBush.prototype.load = function load(data) {\n  if (!(data && data.length)) {\n    return this;\n  }\n\n  if (data.length < this._minEntries) {\n    for (var i = 0; i < data.length; i++) {\n      this.insert(data[i]);\n    }\n\n    return this;\n  } // recursively build the tree with the given data from scratch using OMT algorithm\n\n\n  var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n  if (!this.data.children.length) {\n    // save as is if tree is empty\n    this.data = node;\n  } else if (this.data.height === node.height) {\n    // split root if trees have the same height\n    this._splitRoot(this.data, node);\n  } else {\n    if (this.data.height < node.height) {\n      // swap trees if inserted one is bigger\n      var tmpNode = this.data;\n      this.data = node;\n      node = tmpNode;\n    } // insert the small tree into the large tree at appropriate level\n\n\n    this._insert(node, this.data.height - node.height - 1, true);\n  }\n\n  return this;\n};\n\nRBush.prototype.insert = function insert(item) {\n  if (item) {\n    this._insert(item, this.data.height - 1);\n  }\n\n  return this;\n};\n\nRBush.prototype.clear = function clear() {\n  this.data = createNode([]);\n  return this;\n};\n\nRBush.prototype.remove = function remove(item, equalsFn) {\n  if (!item) {\n    return this;\n  }\n\n  var node = this.data;\n  var bbox = this.toBBox(item);\n  var path = [];\n  var indexes = [];\n  var i, parent, goingUp; // depth-first iterative tree traversal\n\n  while (node || path.length) {\n    if (!node) {\n      // go up\n      node = path.pop();\n      parent = path[path.length - 1];\n      i = indexes.pop();\n      goingUp = true;\n    }\n\n    if (node.leaf) {\n      // check current node\n      var index = findItem(item, node.children, equalsFn);\n\n      if (index !== -1) {\n        // item found, remove the item and condense tree upwards\n        node.children.splice(index, 1);\n        path.push(node);\n\n        this._condense(path);\n\n        return this;\n      }\n    }\n\n    if (!goingUp && !node.leaf && contains(node, bbox)) {\n      // go down\n      path.push(node);\n      indexes.push(i);\n      i = 0;\n      parent = node;\n      node = node.children[0];\n    } else if (parent) {\n      // go right\n      i++;\n      node = parent.children[i];\n      goingUp = false;\n    } else {\n      node = null;\n    } // nothing found\n\n  }\n\n  return this;\n};\n\nRBush.prototype.toBBox = function toBBox(item) {\n  return item;\n};\n\nRBush.prototype.compareMinX = function compareMinX(a, b) {\n  return a.minX - b.minX;\n};\n\nRBush.prototype.compareMinY = function compareMinY(a, b) {\n  return a.minY - b.minY;\n};\n\nRBush.prototype.toJSON = function toJSON() {\n  return this.data;\n};\n\nRBush.prototype.fromJSON = function fromJSON(data) {\n  this.data = data;\n  return this;\n};\n\nRBush.prototype._all = function _all(node, result) {\n  var nodesToSearch = [];\n\n  while (node) {\n    if (node.leaf) {\n      result.push.apply(result, node.children);\n    } else {\n      nodesToSearch.push.apply(nodesToSearch, node.children);\n    }\n\n    node = nodesToSearch.pop();\n  }\n\n  return result;\n};\n\nRBush.prototype._build = function _build(items, left, right, height) {\n  var N = right - left + 1;\n  var M = this._maxEntries;\n  var node;\n\n  if (N <= M) {\n    // reached leaf level; return leaf\n    node = createNode(items.slice(left, right + 1));\n    calcBBox(node, this.toBBox);\n    return node;\n  }\n\n  if (!height) {\n    // target height of the bulk-loaded tree\n    height = Math.ceil(Math.log(N) / Math.log(M)); // target number of root entries to maximize storage utilization\n\n    M = Math.ceil(N / Math.pow(M, height - 1));\n  }\n\n  node = createNode([]);\n  node.leaf = false;\n  node.height = height; // split the items into M mostly square tiles\n\n  var N2 = Math.ceil(N / M);\n  var N1 = N2 * Math.ceil(Math.sqrt(M));\n  multiSelect(items, left, right, N1, this.compareMinX);\n\n  for (var i = left; i <= right; i += N1) {\n    var right2 = Math.min(i + N1 - 1, right);\n    multiSelect(items, i, right2, N2, this.compareMinY);\n\n    for (var j = i; j <= right2; j += N2) {\n      var right3 = Math.min(j + N2 - 1, right2); // pack each entry recursively\n\n      node.children.push(this._build(items, j, right3, height - 1));\n    }\n  }\n\n  calcBBox(node, this.toBBox);\n  return node;\n};\n\nRBush.prototype._chooseSubtree = function _chooseSubtree(bbox, node, level, path) {\n  while (true) {\n    path.push(node);\n\n    if (node.leaf || path.length - 1 === level) {\n      break;\n    }\n\n    var minArea = Infinity;\n    var minEnlargement = Infinity;\n    var targetNode = void 0;\n\n    for (var i = 0; i < node.children.length; i++) {\n      var child = node.children[i];\n      var area = bboxArea(child);\n      var enlargement = enlargedArea(bbox, child) - area; // choose entry with the least area enlargement\n\n      if (enlargement < minEnlargement) {\n        minEnlargement = enlargement;\n        minArea = area < minArea ? area : minArea;\n        targetNode = child;\n      } else if (enlargement === minEnlargement) {\n        // otherwise choose one with the smallest area\n        if (area < minArea) {\n          minArea = area;\n          targetNode = child;\n        }\n      }\n    }\n\n    node = targetNode || node.children[0];\n  }\n\n  return node;\n};\n\nRBush.prototype._insert = function _insert(item, level, isNode) {\n  var bbox = isNode ? item : this.toBBox(item);\n  var insertPath = []; // find the best node for accommodating the item, saving all nodes along the path too\n\n  var node = this._chooseSubtree(bbox, this.data, level, insertPath); // put the item into the node\n\n\n  node.children.push(item);\n  extend(node, bbox); // split on node overflow; propagate upwards if necessary\n\n  while (level >= 0) {\n    if (insertPath[level].children.length > this._maxEntries) {\n      this._split(insertPath, level);\n\n      level--;\n    } else {\n      break;\n    }\n  } // adjust bboxes along the insertion path\n\n\n  this._adjustParentBBoxes(bbox, insertPath, level);\n}; // split overflowed node into two\n\n\nRBush.prototype._split = function _split(insertPath, level) {\n  var node = insertPath[level];\n  var M = node.children.length;\n  var m = this._minEntries;\n\n  this._chooseSplitAxis(node, m, M);\n\n  var splitIndex = this._chooseSplitIndex(node, m, M);\n\n  var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n  newNode.height = node.height;\n  newNode.leaf = node.leaf;\n  calcBBox(node, this.toBBox);\n  calcBBox(newNode, this.toBBox);\n\n  if (level) {\n    insertPath[level - 1].children.push(newNode);\n  } else {\n    this._splitRoot(node, newNode);\n  }\n};\n\nRBush.prototype._splitRoot = function _splitRoot(node, newNode) {\n  // split root node\n  this.data = createNode([node, newNode]);\n  this.data.height = node.height + 1;\n  this.data.leaf = false;\n  calcBBox(this.data, this.toBBox);\n};\n\nRBush.prototype._chooseSplitIndex = function _chooseSplitIndex(node, m, M) {\n  var index;\n  var minOverlap = Infinity;\n  var minArea = Infinity;\n\n  for (var i = m; i <= M - m; i++) {\n    var bbox1 = distBBox(node, 0, i, this.toBBox);\n    var bbox2 = distBBox(node, i, M, this.toBBox);\n    var overlap = intersectionArea(bbox1, bbox2);\n    var area = bboxArea(bbox1) + bboxArea(bbox2); // choose distribution with minimum overlap\n\n    if (overlap < minOverlap) {\n      minOverlap = overlap;\n      index = i;\n      minArea = area < minArea ? area : minArea;\n    } else if (overlap === minOverlap) {\n      // otherwise choose distribution with minimum area\n      if (area < minArea) {\n        minArea = area;\n        index = i;\n      }\n    }\n  }\n\n  return index || M - m;\n}; // sorts node children by the best axis for split\n\n\nRBush.prototype._chooseSplitAxis = function _chooseSplitAxis(node, m, M) {\n  var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n  var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n\n  var xMargin = this._allDistMargin(node, m, M, compareMinX);\n\n  var yMargin = this._allDistMargin(node, m, M, compareMinY); // if total distributions margin value is minimal for x, sort by minX,\n  // otherwise it's already sorted by minY\n\n\n  if (xMargin < yMargin) {\n    node.children.sort(compareMinX);\n  }\n}; // total margin of all possible split distributions where each node is at least m full\n\n\nRBush.prototype._allDistMargin = function _allDistMargin(node, m, M, compare) {\n  node.children.sort(compare);\n  var toBBox = this.toBBox;\n  var leftBBox = distBBox(node, 0, m, toBBox);\n  var rightBBox = distBBox(node, M - m, M, toBBox);\n  var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n  for (var i = m; i < M - m; i++) {\n    var child = node.children[i];\n    extend(leftBBox, node.leaf ? toBBox(child) : child);\n    margin += bboxMargin(leftBBox);\n  }\n\n  for (var i$1 = M - m - 1; i$1 >= m; i$1--) {\n    var child$1 = node.children[i$1];\n    extend(rightBBox, node.leaf ? toBBox(child$1) : child$1);\n    margin += bboxMargin(rightBBox);\n  }\n\n  return margin;\n};\n\nRBush.prototype._adjustParentBBoxes = function _adjustParentBBoxes(bbox, path, level) {\n  // adjust bboxes along the given tree path\n  for (var i = level; i >= 0; i--) {\n    extend(path[i], bbox);\n  }\n};\n\nRBush.prototype._condense = function _condense(path) {\n  // go through the path, removing empty nodes and updating bboxes\n  for (var i = path.length - 1, siblings = void 0; i >= 0; i--) {\n    if (path[i].children.length === 0) {\n      if (i > 0) {\n        siblings = path[i - 1].children;\n        siblings.splice(siblings.indexOf(path[i]), 1);\n      } else {\n        this.clear();\n      }\n    } else {\n      calcBBox(path[i], this.toBBox);\n    }\n  }\n};\n\nfunction findItem(item, items, equalsFn) {\n  if (!equalsFn) {\n    return items.indexOf(item);\n  }\n\n  for (var i = 0; i < items.length; i++) {\n    if (equalsFn(item, items[i])) {\n      return i;\n    }\n  }\n\n  return -1;\n} // calculate node's bbox from bboxes of its children\n\n\nfunction calcBBox(node, toBBox) {\n  distBBox(node, 0, node.children.length, toBBox, node);\n} // min bounding rectangle of node children from k to p-1\n\n\nfunction distBBox(node, k, p, toBBox, destNode) {\n  if (!destNode) {\n    destNode = createNode(null);\n  }\n\n  destNode.minX = Infinity;\n  destNode.minY = Infinity;\n  destNode.maxX = -Infinity;\n  destNode.maxY = -Infinity;\n\n  for (var i = k; i < p; i++) {\n    var child = node.children[i];\n    extend(destNode, node.leaf ? toBBox(child) : child);\n  }\n\n  return destNode;\n}\n\nfunction extend(a, b) {\n  a.minX = Math.min(a.minX, b.minX);\n  a.minY = Math.min(a.minY, b.minY);\n  a.maxX = Math.max(a.maxX, b.maxX);\n  a.maxY = Math.max(a.maxY, b.maxY);\n  return a;\n}\n\nfunction compareNodeMinX(a, b) {\n  return a.minX - b.minX;\n}\n\nfunction compareNodeMinY(a, b) {\n  return a.minY - b.minY;\n}\n\nfunction bboxArea(a) {\n  return (a.maxX - a.minX) * (a.maxY - a.minY);\n}\n\nfunction bboxMargin(a) {\n  return a.maxX - a.minX + (a.maxY - a.minY);\n}\n\nfunction enlargedArea(a, b) {\n  return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n  var minX = Math.max(a.minX, b.minX);\n  var minY = Math.max(a.minY, b.minY);\n  var maxX = Math.min(a.maxX, b.maxX);\n  var maxY = Math.min(a.maxY, b.maxY);\n  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n  return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n  return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n  return {\n    children: children,\n    height: 1,\n    leaf: true,\n    minX: Infinity,\n    minY: Infinity,\n    maxX: -Infinity,\n    maxY: -Infinity\n  };\n} // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\n\nfunction multiSelect(arr, left, right, n, compare) {\n  var stack = [left, right];\n\n  while (stack.length) {\n    right = stack.pop();\n    left = stack.pop();\n\n    if (right - left <= n) {\n      continue;\n    }\n\n    var mid = left + Math.ceil((right - left) / n / 2) * n;\n    quickselect(arr, mid, left, right, compare);\n    stack.push(left, mid, mid, right);\n  }\n}\n\nexport default RBush;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/ThirdParty/rbush.js"],"names":["quickselect","arr","k","left","right","compare","quickselectStep","length","defaultCompare","n","m","z","Math","log","s","exp","sd","sqrt","newLeft","max","floor","newRight","min","t","i","j","swap","tmp","a","b","RBush","maxEntries","_maxEntries","_minEntries","ceil","clear","prototype","all","_all","data","search","bbox","node","result","intersects","toBBox","nodesToSearch","children","child","childBBox","leaf","push","contains","pop","collides","load","insert","_build","slice","height","_splitRoot","tmpNode","_insert","item","createNode","remove","equalsFn","path","indexes","parent","goingUp","index","findItem","splice","_condense","compareMinX","minX","compareMinY","minY","toJSON","fromJSON","apply","items","N","M","calcBBox","pow","N2","N1","multiSelect","right2","right3","_chooseSubtree","level","minArea","Infinity","minEnlargement","targetNode","area","bboxArea","enlargement","enlargedArea","isNode","insertPath","extend","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","minOverlap","bbox1","distBBox","bbox2","overlap","intersectionArea","compareNodeMinX","compareNodeMinY","xMargin","_allDistMargin","yMargin","sort","leftBBox","rightBBox","margin","bboxMargin","i$1","child$1","siblings","indexOf","p","destNode","maxX","maxY","stack","mid"],"mappings":"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","sourcesContent":["function quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) { swap(arr, left, right); }\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) { i++; }\n            while (compare(arr[j], t) > 0) { j--; }\n        }\n\n        if (compare(arr[left], t) === 0) { swap(arr, left, j); }\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) { left = j + 1; }\n        if (k <= j) { right = j - 1; }\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nfunction RBush(maxEntries) {\n    if ( maxEntries === void 0 ) maxEntries = 9;\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n    this.clear();\n};\n\nRBush.prototype.all = function all () {\n    return this._all(this.data, []);\n};\n\nRBush.prototype.search = function search (bbox) {\n    var node = this.data;\n    var result = [];\n\n    if (!intersects(bbox, node)) { return result; }\n\n    var toBBox = this.toBBox;\n    var nodesToSearch = [];\n\n    while (node) {\n        for (var i = 0; i < node.children.length; i++) {\n            var child = node.children[i];\n            var childBBox = node.leaf ? toBBox(child) : child;\n\n            if (intersects(bbox, childBBox)) {\n                if (node.leaf) { result.push(child); }\n                else if (contains(bbox, childBBox)) { this._all(child, result); }\n                else { nodesToSearch.push(child); }\n            }\n        }\n        node = nodesToSearch.pop();\n    }\n\n    return result;\n};\n\nRBush.prototype.collides = function collides (bbox) {\n    var node = this.data;\n\n    if (!intersects(bbox, node)) { return false; }\n\n    var nodesToSearch = [];\n    while (node) {\n        for (var i = 0; i < node.children.length; i++) {\n            var child = node.children[i];\n            var childBBox = node.leaf ? this.toBBox(child) : child;\n\n            if (intersects(bbox, childBBox)) {\n                if (node.leaf || contains(bbox, childBBox)) { return true; }\n                nodesToSearch.push(child);\n            }\n        }\n        node = nodesToSearch.pop();\n    }\n\n    return false;\n};\n\nRBush.prototype.load = function load (data) {\n    if (!(data && data.length)) { return this; }\n\n    if (data.length < this._minEntries) {\n        for (var i = 0; i < data.length; i++) {\n            this.insert(data[i]);\n        }\n        return this;\n    }\n\n    // recursively build the tree with the given data from scratch using OMT algorithm\n    var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n    if (!this.data.children.length) {\n        // save as is if tree is empty\n        this.data = node;\n\n    } else if (this.data.height === node.height) {\n        // split root if trees have the same height\n        this._splitRoot(this.data, node);\n\n    } else {\n        if (this.data.height < node.height) {\n            // swap trees if inserted one is bigger\n            var tmpNode = this.data;\n            this.data = node;\n            node = tmpNode;\n        }\n\n        // insert the small tree into the large tree at appropriate level\n        this._insert(node, this.data.height - node.height - 1, true);\n    }\n\n    return this;\n};\n\nRBush.prototype.insert = function insert (item) {\n    if (item) { this._insert(item, this.data.height - 1); }\n    return this;\n};\n\nRBush.prototype.clear = function clear () {\n    this.data = createNode([]);\n    return this;\n};\n\nRBush.prototype.remove = function remove (item, equalsFn) {\n    if (!item) { return this; }\n\n    var node = this.data;\n    var bbox = this.toBBox(item);\n    var path = [];\n    var indexes = [];\n    var i, parent, goingUp;\n\n    // depth-first iterative tree traversal\n    while (node || path.length) {\n\n        if (!node) { // go up\n            node = path.pop();\n            parent = path[path.length - 1];\n            i = indexes.pop();\n            goingUp = true;\n        }\n\n        if (node.leaf) { // check current node\n            var index = findItem(item, node.children, equalsFn);\n\n            if (index !== -1) {\n                // item found, remove the item and condense tree upwards\n                node.children.splice(index, 1);\n                path.push(node);\n                this._condense(path);\n                return this;\n            }\n        }\n\n        if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n            path.push(node);\n            indexes.push(i);\n            i = 0;\n            parent = node;\n            node = node.children[0];\n\n        } else if (parent) { // go right\n            i++;\n            node = parent.children[i];\n            goingUp = false;\n\n        } else { node = null; } // nothing found\n    }\n\n    return this;\n};\n\nRBush.prototype.toBBox = function toBBox (item) { return item; };\n\nRBush.prototype.compareMinX = function compareMinX (a, b) { return a.minX - b.minX; };\nRBush.prototype.compareMinY = function compareMinY (a, b) { return a.minY - b.minY; };\n\nRBush.prototype.toJSON = function toJSON () { return this.data; };\n\nRBush.prototype.fromJSON = function fromJSON (data) {\n    this.data = data;\n    return this;\n};\n\nRBush.prototype._all = function _all (node, result) {\n    var nodesToSearch = [];\n    while (node) {\n        if (node.leaf) { result.push.apply(result, node.children); }\n        else { nodesToSearch.push.apply(nodesToSearch, node.children); }\n\n        node = nodesToSearch.pop();\n    }\n    return result;\n};\n\nRBush.prototype._build = function _build (items, left, right, height) {\n\n    var N = right - left + 1;\n    var M = this._maxEntries;\n    var node;\n\n    if (N <= M) {\n        // reached leaf level; return leaf\n        node = createNode(items.slice(left, right + 1));\n        calcBBox(node, this.toBBox);\n        return node;\n    }\n\n    if (!height) {\n        // target height of the bulk-loaded tree\n        height = Math.ceil(Math.log(N) / Math.log(M));\n\n        // target number of root entries to maximize storage utilization\n        M = Math.ceil(N / Math.pow(M, height - 1));\n    }\n\n    node = createNode([]);\n    node.leaf = false;\n    node.height = height;\n\n    // split the items into M mostly square tiles\n\n    var N2 = Math.ceil(N / M);\n    var N1 = N2 * Math.ceil(Math.sqrt(M));\n\n    multiSelect(items, left, right, N1, this.compareMinX);\n\n    for (var i = left; i <= right; i += N1) {\n\n        var right2 = Math.min(i + N1 - 1, right);\n\n        multiSelect(items, i, right2, N2, this.compareMinY);\n\n        for (var j = i; j <= right2; j += N2) {\n\n            var right3 = Math.min(j + N2 - 1, right2);\n\n            // pack each entry recursively\n            node.children.push(this._build(items, j, right3, height - 1));\n        }\n    }\n\n    calcBBox(node, this.toBBox);\n\n    return node;\n};\n\nRBush.prototype._chooseSubtree = function _chooseSubtree (bbox, node, level, path) {\n    while (true) {\n        path.push(node);\n\n        if (node.leaf || path.length - 1 === level) { break; }\n\n        var minArea = Infinity;\n        var minEnlargement = Infinity;\n        var targetNode = (void 0);\n\n        for (var i = 0; i < node.children.length; i++) {\n            var child = node.children[i];\n            var area = bboxArea(child);\n            var enlargement = enlargedArea(bbox, child) - area;\n\n            // choose entry with the least area enlargement\n            if (enlargement < minEnlargement) {\n                minEnlargement = enlargement;\n                minArea = area < minArea ? area : minArea;\n                targetNode = child;\n\n            } else if (enlargement === minEnlargement) {\n                // otherwise choose one with the smallest area\n                if (area < minArea) {\n                    minArea = area;\n                    targetNode = child;\n                }\n            }\n        }\n\n        node = targetNode || node.children[0];\n    }\n\n    return node;\n};\n\nRBush.prototype._insert = function _insert (item, level, isNode) {\n    var bbox = isNode ? item : this.toBBox(item);\n    var insertPath = [];\n\n    // find the best node for accommodating the item, saving all nodes along the path too\n    var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n    // put the item into the node\n    node.children.push(item);\n    extend(node, bbox);\n\n    // split on node overflow; propagate upwards if necessary\n    while (level >= 0) {\n        if (insertPath[level].children.length > this._maxEntries) {\n            this._split(insertPath, level);\n            level--;\n        } else { break; }\n    }\n\n    // adjust bboxes along the insertion path\n    this._adjustParentBBoxes(bbox, insertPath, level);\n};\n\n// split overflowed node into two\nRBush.prototype._split = function _split (insertPath, level) {\n    var node = insertPath[level];\n    var M = node.children.length;\n    var m = this._minEntries;\n\n    this._chooseSplitAxis(node, m, M);\n\n    var splitIndex = this._chooseSplitIndex(node, m, M);\n\n    var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n    newNode.height = node.height;\n    newNode.leaf = node.leaf;\n\n    calcBBox(node, this.toBBox);\n    calcBBox(newNode, this.toBBox);\n\n    if (level) { insertPath[level - 1].children.push(newNode); }\n    else { this._splitRoot(node, newNode); }\n};\n\nRBush.prototype._splitRoot = function _splitRoot (node, newNode) {\n    // split root node\n    this.data = createNode([node, newNode]);\n    this.data.height = node.height + 1;\n    this.data.leaf = false;\n    calcBBox(this.data, this.toBBox);\n};\n\nRBush.prototype._chooseSplitIndex = function _chooseSplitIndex (node, m, M) {\n    var index;\n    var minOverlap = Infinity;\n    var minArea = Infinity;\n\n    for (var i = m; i <= M - m; i++) {\n        var bbox1 = distBBox(node, 0, i, this.toBBox);\n        var bbox2 = distBBox(node, i, M, this.toBBox);\n\n        var overlap = intersectionArea(bbox1, bbox2);\n        var area = bboxArea(bbox1) + bboxArea(bbox2);\n\n        // choose distribution with minimum overlap\n        if (overlap < minOverlap) {\n            minOverlap = overlap;\n            index = i;\n\n            minArea = area < minArea ? area : minArea;\n\n        } else if (overlap === minOverlap) {\n            // otherwise choose distribution with minimum area\n            if (area < minArea) {\n                minArea = area;\n                index = i;\n            }\n        }\n    }\n\n    return index || M - m;\n};\n\n// sorts node children by the best axis for split\nRBush.prototype._chooseSplitAxis = function _chooseSplitAxis (node, m, M) {\n    var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n    var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n    var xMargin = this._allDistMargin(node, m, M, compareMinX);\n    var yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n    // if total distributions margin value is minimal for x, sort by minX,\n    // otherwise it's already sorted by minY\n    if (xMargin < yMargin) { node.children.sort(compareMinX); }\n};\n\n// total margin of all possible split distributions where each node is at least m full\nRBush.prototype._allDistMargin = function _allDistMargin (node, m, M, compare) {\n    node.children.sort(compare);\n\n    var toBBox = this.toBBox;\n    var leftBBox = distBBox(node, 0, m, toBBox);\n    var rightBBox = distBBox(node, M - m, M, toBBox);\n    var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n    for (var i = m; i < M - m; i++) {\n        var child = node.children[i];\n        extend(leftBBox, node.leaf ? toBBox(child) : child);\n        margin += bboxMargin(leftBBox);\n    }\n\n    for (var i$1 = M - m - 1; i$1 >= m; i$1--) {\n        var child$1 = node.children[i$1];\n        extend(rightBBox, node.leaf ? toBBox(child$1) : child$1);\n        margin += bboxMargin(rightBBox);\n    }\n\n    return margin;\n};\n\nRBush.prototype._adjustParentBBoxes = function _adjustParentBBoxes (bbox, path, level) {\n    // adjust bboxes along the given tree path\n    for (var i = level; i >= 0; i--) {\n        extend(path[i], bbox);\n    }\n};\n\nRBush.prototype._condense = function _condense (path) {\n    // go through the path, removing empty nodes and updating bboxes\n    for (var i = path.length - 1, siblings = (void 0); i >= 0; i--) {\n        if (path[i].children.length === 0) {\n            if (i > 0) {\n                siblings = path[i - 1].children;\n                siblings.splice(siblings.indexOf(path[i]), 1);\n\n            } else { this.clear(); }\n\n        } else { calcBBox(path[i], this.toBBox); }\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) { return items.indexOf(item); }\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) { return i; }\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) { destNode = createNode(null); }\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k; i < p; i++) {\n        var child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX);\n    var minY = Math.max(a.minY, b.minY);\n    var maxX = Math.min(a.maxX, b.maxX);\n    var maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right];\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) { continue; }\n\n        var mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n\nexport default RBush;\n"]},"metadata":{},"sourceType":"module"}