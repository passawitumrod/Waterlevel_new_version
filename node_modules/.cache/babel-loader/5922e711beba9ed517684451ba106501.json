{"ast":null,"code":"import ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport ShadowVolumeAppearanceVS from \"../Shaders/ShadowVolumeAppearanceVS.js\";\nimport ShadowVolumeFS from \"../Shaders/ShadowVolumeFS.js\";\nimport when from \"../ThirdParty/when.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowVolumeAppearance from \"./ShadowVolumeAppearance.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\n/**\n * A classification primitive represents a volume enclosing geometry in the {@link Scene} to be highlighted.\n * <p>\n * A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including\n * {@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,\n * and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix\n * and match most of them and add a new geometry or appearance independently of each other.\n * Only {@link PerInstanceColorAppearance} with the same color across all instances is supported at this time when using\n * ClassificationPrimitive directly.\n * For full {@link Appearance} support when classifying terrain or 3D Tiles use {@link GroundPrimitive} instead.\n * </p>\n * <p>\n * For correct rendering, this feature requires the EXT_frag_depth WebGL extension. For hardware that do not support this extension, there\n * will be rendering artifacts for some viewing angles.\n * </p>\n * <p>\n * Valid geometries are {@link BoxGeometry}, {@link CylinderGeometry}, {@link EllipsoidGeometry}, {@link PolylineVolumeGeometry}, and {@link SphereGeometry}.\n * </p>\n * <p>\n * Geometries that follow the surface of the ellipsoid, such as {@link CircleGeometry}, {@link CorridorGeometry}, {@link EllipseGeometry}, {@link PolygonGeometry}, and {@link RectangleGeometry},\n * are also valid if they are extruded volumes; otherwise, they will not be rendered.\n * </p>\n *\n * @alias ClassificationPrimitive\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Array|GeometryInstance} [options.geometryInstances] The geometry instances to render. This can either be a single instance or an array of length one.\n * @param {Appearance} [options.appearance] The appearance used to render the primitive. Defaults to PerInstanceColorAppearance when GeometryInstances have a color attribute.\n * @param {Boolean} [options.show=true] Determines if this primitive will be shown.\n * @param {Boolean} [options.vertexCacheOptimize=false] When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n * @param {Boolean} [options.interleave=false] When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.\n * @param {Boolean} [options.compressVertices=true] When <code>true</code>, the geometry vertices are compressed, which will save memory.\n * @param {Boolean} [options.releaseGeometryInstances=true] When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n * @param {Boolean} [options.asynchronous=true] Determines if the primitive will be created asynchronously or block until ready. If false initializeTerrainHeights() must be called first.\n * @param {ClassificationType} [options.classificationType=ClassificationType.BOTH] Determines whether terrain, 3D Tiles or both will be classified.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {Boolean} [options.debugShowShadowVolume=false] For debugging only. Determines if the shadow volume for each geometry in the primitive is drawn. Must be <code>true</code> on\n *                  creation for the volumes to be created before the geometry is released or options.releaseGeometryInstance must be <code>false</code>.\n *\n * @see Primitive\n * @see GroundPrimitive\n * @see GeometryInstance\n * @see Appearance\n */\n\nfunction ClassificationPrimitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var geometryInstances = options.geometryInstances;\n  /**\n   * The geometry instance rendered with this primitive.  This may\n   * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>\n   * is <code>true</code> when the primitive is constructed.\n   * <p>\n   * Changing this property after the primitive is rendered has no effect.\n   * </p>\n   * <p>\n   * Because of the rendering technique used, all geometry instances must be the same color.\n   * If there is an instance with a differing color, a <code>DeveloperError</code> will be thrown\n   * on the first attempt to render.\n   * </p>\n   *\n   * @readonly\n   * @type {Array|GeometryInstance}\n   *\n   * @default undefined\n   */\n\n  this.geometryInstances = geometryInstances;\n  /**\n   * Determines if the primitive will be shown.  This affects all geometry\n   * instances in the primitive.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n\n  this.show = defaultValue(options.show, true);\n  /**\n   * Determines whether terrain, 3D Tiles or both will be classified.\n   *\n   * @type {ClassificationType}\n   *\n   * @default ClassificationType.BOTH\n   */\n\n  this.classificationType = defaultValue(options.classificationType, ClassificationType.BOTH);\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n\n  this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the shadow volume for each geometry in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n\n  this.debugShowShadowVolume = defaultValue(options.debugShowShadowVolume, false);\n  this._debugShowShadowVolume = false; // These are used by GroundPrimitive to augment the shader and uniform map.\n\n  this._extruded = defaultValue(options._extruded, false);\n  this._uniformMap = options._uniformMap;\n  this._sp = undefined;\n  this._spStencil = undefined;\n  this._spPick = undefined;\n  this._spColor = undefined;\n  this._spPick2D = undefined; // only derived if necessary\n\n  this._spColor2D = undefined; // only derived if necessary\n\n  this._rsStencilPreloadPass = undefined;\n  this._rsStencilPreloadPass3DTiles = undefined;\n  this._rsStencilDepthPass = undefined;\n  this._rsStencilDepthPass3DTiles = undefined;\n  this._rsColorPass = undefined;\n  this._rsPickPass = undefined;\n  this._commandsIgnoreShow = [];\n  this._ready = false;\n  this._readyPromise = when.defer();\n  this._primitive = undefined;\n  this._pickPrimitive = options._pickPrimitive; // Set in update\n\n  this._hasSphericalExtentsAttribute = false;\n  this._hasPlanarExtentsAttributes = false;\n  this._hasPerColorAttribute = false;\n  this.appearance = options.appearance;\n  this._createBoundingVolumeFunction = options._createBoundingVolumeFunction;\n  this._updateAndQueueCommandsFunction = options._updateAndQueueCommandsFunction;\n  this._usePickOffsets = false;\n  this._primitiveOptions = {\n    geometryInstances: undefined,\n    appearance: undefined,\n    vertexCacheOptimize: defaultValue(options.vertexCacheOptimize, false),\n    interleave: defaultValue(options.interleave, false),\n    releaseGeometryInstances: defaultValue(options.releaseGeometryInstances, true),\n    allowPicking: defaultValue(options.allowPicking, true),\n    asynchronous: defaultValue(options.asynchronous, true),\n    compressVertices: defaultValue(options.compressVertices, true),\n    _createBoundingVolumeFunction: undefined,\n    _createRenderStatesFunction: undefined,\n    _createShaderProgramFunction: undefined,\n    _createCommandsFunction: undefined,\n    _updateAndQueueCommandsFunction: undefined,\n    _createPickOffsets: true\n  };\n}\n\nObject.defineProperties(ClassificationPrimitive.prototype, {\n  /**\n   * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  vertexCacheOptimize: {\n    get: function () {\n      return this._primitiveOptions.vertexCacheOptimize;\n    }\n  },\n\n  /**\n   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  interleave: {\n    get: function () {\n      return this._primitiveOptions.interleave;\n    }\n  },\n\n  /**\n   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  releaseGeometryInstances: {\n    get: function () {\n      return this._primitiveOptions.releaseGeometryInstances;\n    }\n  },\n\n  /**\n   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._primitiveOptions.allowPicking;\n    }\n  },\n\n  /**\n   * Determines if the geometry instances will be created and batched on a web worker.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._primitiveOptions.asynchronous;\n    }\n  },\n\n  /**\n   * When <code>true</code>, geometry vertices are compressed, which will save memory.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  compressVertices: {\n    get: function () {\n      return this._primitiveOptions.compressVertices;\n    }\n  },\n\n  /**\n   * Determines if the primitive is complete and ready to render.  If this property is\n   * true, the primitive will be rendered the next time that {@link ClassificationPrimitive#update}\n   * is called.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n\n  /**\n   * Gets a promise that resolves when the primitive is ready to render.\n   * @memberof ClassificationPrimitive.prototype\n   * @type {Promise.<ClassificationPrimitive>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    }\n  },\n\n  /**\n   * Returns true if the ClassificationPrimitive needs a separate shader and commands for 2D.\n   * This is because texture coordinates on ClassificationPrimitives are computed differently,\n   * and are used for culling when multiple GeometryInstances are batched in one ClassificationPrimitive.\n   * @memberof ClassificationPrimitive.prototype\n   * @type {Boolean}\n   * @readonly\n   * @private\n   */\n  _needs2DShader: {\n    get: function () {\n      return this._hasPlanarExtentsAttributes || this._hasSphericalExtentsAttribute;\n    }\n  }\n});\n/**\n * Determines if ClassificationPrimitive rendering is supported.\n *\n * @param {Scene} scene The scene.\n * @returns {Boolean} <code>true</code> if ClassificationPrimitives are supported; otherwise, returns <code>false</code>\n */\n\nClassificationPrimitive.isSupported = function (scene) {\n  return scene.context.stencilBuffer;\n};\n\nfunction getStencilPreloadRenderState(enableStencil, mask3DTiles) {\n  var stencilFunction = mask3DTiles ? StencilFunction.EQUAL : StencilFunction.ALWAYS;\n  return {\n    colorMask: {\n      red: false,\n      green: false,\n      blue: false,\n      alpha: false\n    },\n    stencilTest: {\n      enabled: enableStencil,\n      frontFunction: stencilFunction,\n      frontOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.DECREMENT_WRAP,\n        zPass: StencilOperation.DECREMENT_WRAP\n      },\n      backFunction: stencilFunction,\n      backOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.INCREMENT_WRAP,\n        zPass: StencilOperation.INCREMENT_WRAP\n      },\n      reference: StencilConstants.CESIUM_3D_TILE_MASK,\n      mask: StencilConstants.CESIUM_3D_TILE_MASK\n    },\n    stencilMask: StencilConstants.CLASSIFICATION_MASK,\n    depthTest: {\n      enabled: false\n    },\n    depthMask: false\n  };\n}\n\nfunction getStencilDepthRenderState(enableStencil, mask3DTiles) {\n  var stencilFunction = mask3DTiles ? StencilFunction.EQUAL : StencilFunction.ALWAYS;\n  return {\n    colorMask: {\n      red: false,\n      green: false,\n      blue: false,\n      alpha: false\n    },\n    stencilTest: {\n      enabled: enableStencil,\n      frontFunction: stencilFunction,\n      frontOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.INCREMENT_WRAP\n      },\n      backFunction: stencilFunction,\n      backOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.DECREMENT_WRAP\n      },\n      reference: StencilConstants.CESIUM_3D_TILE_MASK,\n      mask: StencilConstants.CESIUM_3D_TILE_MASK\n    },\n    stencilMask: StencilConstants.CLASSIFICATION_MASK,\n    depthTest: {\n      enabled: true,\n      func: DepthFunction.LESS_OR_EQUAL\n    },\n    depthMask: false\n  };\n}\n\nfunction getColorRenderState(enableStencil) {\n  return {\n    stencilTest: {\n      enabled: enableStencil,\n      frontFunction: StencilFunction.NOT_EQUAL,\n      frontOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.DECREMENT_WRAP\n      },\n      backFunction: StencilFunction.NOT_EQUAL,\n      backOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.DECREMENT_WRAP\n      },\n      reference: 0,\n      mask: StencilConstants.CLASSIFICATION_MASK\n    },\n    stencilMask: StencilConstants.CLASSIFICATION_MASK,\n    depthTest: {\n      enabled: false\n    },\n    depthMask: false,\n    blending: BlendingState.ALPHA_BLEND\n  };\n}\n\nvar pickRenderState = {\n  stencilTest: {\n    enabled: true,\n    frontFunction: StencilFunction.NOT_EQUAL,\n    frontOperation: {\n      fail: StencilOperation.KEEP,\n      zFail: StencilOperation.KEEP,\n      zPass: StencilOperation.DECREMENT_WRAP\n    },\n    backFunction: StencilFunction.NOT_EQUAL,\n    backOperation: {\n      fail: StencilOperation.KEEP,\n      zFail: StencilOperation.KEEP,\n      zPass: StencilOperation.DECREMENT_WRAP\n    },\n    reference: 0,\n    mask: StencilConstants.CLASSIFICATION_MASK\n  },\n  stencilMask: StencilConstants.CLASSIFICATION_MASK,\n  depthTest: {\n    enabled: false\n  },\n  depthMask: false\n};\n\nfunction createRenderStates(classificationPrimitive, context, appearance, twoPasses) {\n  if (defined(classificationPrimitive._rsStencilPreloadPass)) {\n    return;\n  }\n\n  var stencilEnabled = !classificationPrimitive.debugShowShadowVolume;\n  classificationPrimitive._rsStencilPreloadPass = RenderState.fromCache(getStencilPreloadRenderState(stencilEnabled, false));\n  classificationPrimitive._rsStencilPreloadPass3DTiles = RenderState.fromCache(getStencilPreloadRenderState(stencilEnabled, true));\n  classificationPrimitive._rsStencilDepthPass = RenderState.fromCache(getStencilDepthRenderState(stencilEnabled, false));\n  classificationPrimitive._rsStencilDepthPass3DTiles = RenderState.fromCache(getStencilDepthRenderState(stencilEnabled, true));\n  classificationPrimitive._rsColorPass = RenderState.fromCache(getColorRenderState(stencilEnabled, false));\n  classificationPrimitive._rsPickPass = RenderState.fromCache(pickRenderState);\n}\n\nfunction modifyForEncodedNormals(primitive, vertexShaderSource) {\n  if (!primitive.compressVertices) {\n    return vertexShaderSource;\n  }\n\n  if (vertexShaderSource.search(/attribute\\s+vec3\\s+extrudeDirection;/g) !== -1) {\n    var attributeName = \"compressedAttributes\"; //only shadow volumes use extrudeDirection, and shadow volumes use vertexFormat: POSITION_ONLY so we don't need to check other attributes\n\n    var attributeDecl = \"attribute vec2 \" + attributeName + \";\";\n    var globalDecl = \"vec3 extrudeDirection;\\n\";\n    var decode = \"    extrudeDirection = czm_octDecode(\" + attributeName + \", 65535.0);\\n\";\n    var modifiedVS = vertexShaderSource;\n    modifiedVS = modifiedVS.replace(/attribute\\s+vec3\\s+extrudeDirection;/g, \"\");\n    modifiedVS = ShaderSource.replaceMain(modifiedVS, \"czm_non_compressed_main\");\n    var compressedMain = \"void main() \\n\" + \"{ \\n\" + decode + \"    czm_non_compressed_main(); \\n\" + \"}\";\n    return [attributeDecl, globalDecl, modifiedVS, compressedMain].join(\"\\n\");\n  }\n}\n\nfunction createShaderProgram(classificationPrimitive, frameState) {\n  var context = frameState.context;\n  var primitive = classificationPrimitive._primitive;\n  var vs = ShadowVolumeAppearanceVS;\n  vs = classificationPrimitive._primitive._batchTable.getVertexShaderCallback()(vs);\n  vs = Primitive._appendDistanceDisplayConditionToShader(primitive, vs);\n  vs = Primitive._modifyShaderPosition(classificationPrimitive, vs, frameState.scene3DOnly);\n  vs = Primitive._updateColorAttribute(primitive, vs);\n  var planarExtents = classificationPrimitive._hasPlanarExtentsAttributes;\n  var cullFragmentsUsingExtents = planarExtents || classificationPrimitive._hasSphericalExtentsAttribute;\n\n  if (classificationPrimitive._extruded) {\n    vs = modifyForEncodedNormals(primitive, vs);\n  }\n\n  var extrudedDefine = classificationPrimitive._extruded ? \"EXTRUDED_GEOMETRY\" : \"\";\n  var vsSource = new ShaderSource({\n    defines: [extrudedDefine],\n    sources: [vs]\n  });\n  var fsSource = new ShaderSource({\n    sources: [ShadowVolumeFS]\n  });\n  var attributeLocations = classificationPrimitive._primitive._attributeLocations;\n  var shadowVolumeAppearance = new ShadowVolumeAppearance(cullFragmentsUsingExtents, planarExtents, classificationPrimitive.appearance);\n  classificationPrimitive._spStencil = ShaderProgram.replaceCache({\n    context: context,\n    shaderProgram: classificationPrimitive._spStencil,\n    vertexShaderSource: vsSource,\n    fragmentShaderSource: fsSource,\n    attributeLocations: attributeLocations\n  });\n\n  if (classificationPrimitive._primitive.allowPicking) {\n    var vsPick = ShaderSource.createPickVertexShaderSource(vs);\n    vsPick = Primitive._appendShowToShader(primitive, vsPick);\n    vsPick = Primitive._updatePickColorAttribute(vsPick);\n    var pickFS3D = shadowVolumeAppearance.createPickFragmentShader(false);\n    var pickVS3D = shadowVolumeAppearance.createPickVertexShader([extrudedDefine], vsPick, false, frameState.mapProjection);\n    classificationPrimitive._spPick = ShaderProgram.replaceCache({\n      context: context,\n      shaderProgram: classificationPrimitive._spPick,\n      vertexShaderSource: pickVS3D,\n      fragmentShaderSource: pickFS3D,\n      attributeLocations: attributeLocations\n    }); // Derive a 2D pick shader if the primitive uses texture coordinate-based fragment culling,\n    // since texture coordinates are computed differently in 2D.\n\n    if (cullFragmentsUsingExtents) {\n      var pickProgram2D = context.shaderCache.getDerivedShaderProgram(classificationPrimitive._spPick, \"2dPick\");\n\n      if (!defined(pickProgram2D)) {\n        var pickFS2D = shadowVolumeAppearance.createPickFragmentShader(true);\n        var pickVS2D = shadowVolumeAppearance.createPickVertexShader([extrudedDefine], vsPick, true, frameState.mapProjection);\n        pickProgram2D = context.shaderCache.createDerivedShaderProgram(classificationPrimitive._spPick, \"2dPick\", {\n          vertexShaderSource: pickVS2D,\n          fragmentShaderSource: pickFS2D,\n          attributeLocations: attributeLocations\n        });\n      }\n\n      classificationPrimitive._spPick2D = pickProgram2D;\n    }\n  } else {\n    classificationPrimitive._spPick = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vsSource,\n      fragmentShaderSource: fsSource,\n      attributeLocations: attributeLocations\n    });\n  }\n\n  vs = Primitive._appendShowToShader(primitive, vs);\n  vsSource = new ShaderSource({\n    defines: [extrudedDefine],\n    sources: [vs]\n  });\n  classificationPrimitive._sp = ShaderProgram.replaceCache({\n    context: context,\n    shaderProgram: classificationPrimitive._sp,\n    vertexShaderSource: vsSource,\n    fragmentShaderSource: fsSource,\n    attributeLocations: attributeLocations\n  }); // Create a fragment shader that computes only required material hookups using screen space techniques\n\n  var fsColorSource = shadowVolumeAppearance.createFragmentShader(false);\n  var vsColorSource = shadowVolumeAppearance.createVertexShader([extrudedDefine], vs, false, frameState.mapProjection);\n  classificationPrimitive._spColor = ShaderProgram.replaceCache({\n    context: context,\n    shaderProgram: classificationPrimitive._spColor,\n    vertexShaderSource: vsColorSource,\n    fragmentShaderSource: fsColorSource,\n    attributeLocations: attributeLocations\n  }); // Derive a 2D shader if the primitive uses texture coordinate-based fragment culling,\n  // since texture coordinates are computed differently in 2D.\n  // Any material that uses texture coordinates will also equip texture coordinate-based fragment culling.\n\n  if (cullFragmentsUsingExtents) {\n    var colorProgram2D = context.shaderCache.getDerivedShaderProgram(classificationPrimitive._spColor, \"2dColor\");\n\n    if (!defined(colorProgram2D)) {\n      var fsColorSource2D = shadowVolumeAppearance.createFragmentShader(true);\n      var vsColorSource2D = shadowVolumeAppearance.createVertexShader([extrudedDefine], vs, true, frameState.mapProjection);\n      colorProgram2D = context.shaderCache.createDerivedShaderProgram(classificationPrimitive._spColor, \"2dColor\", {\n        vertexShaderSource: vsColorSource2D,\n        fragmentShaderSource: fsColorSource2D,\n        attributeLocations: attributeLocations\n      });\n    }\n\n    classificationPrimitive._spColor2D = colorProgram2D;\n  }\n}\n\nfunction createColorCommands(classificationPrimitive, colorCommands) {\n  var primitive = classificationPrimitive._primitive;\n  var length = primitive._va.length * 3; // each geometry (pack of vertex attributes) needs 3 commands: front/back stencils and fill\n\n  colorCommands.length = length;\n  var i;\n  var command;\n  var derivedCommand;\n  var vaIndex = 0;\n\n  var uniformMap = primitive._batchTable.getUniformMapCallback()(classificationPrimitive._uniformMap);\n\n  var needs2DShader = classificationPrimitive._needs2DShader;\n\n  for (i = 0; i < length; i += 3) {\n    var vertexArray = primitive._va[vaIndex++]; // Stencil preload command\n\n    command = colorCommands[i];\n\n    if (!defined(command)) {\n      command = colorCommands[i] = new DrawCommand({\n        owner: classificationPrimitive,\n        primitiveType: primitive._primitiveType\n      });\n    }\n\n    command.vertexArray = vertexArray;\n    command.renderState = classificationPrimitive._rsStencilPreloadPass;\n    command.shaderProgram = classificationPrimitive._sp;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.TERRAIN_CLASSIFICATION;\n    derivedCommand = DrawCommand.shallowClone(command, command.derivedCommands.tileset);\n    derivedCommand.renderState = classificationPrimitive._rsStencilPreloadPass3DTiles;\n    derivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedCommand; // Stencil depth command\n\n    command = colorCommands[i + 1];\n\n    if (!defined(command)) {\n      command = colorCommands[i + 1] = new DrawCommand({\n        owner: classificationPrimitive,\n        primitiveType: primitive._primitiveType\n      });\n    }\n\n    command.vertexArray = vertexArray;\n    command.renderState = classificationPrimitive._rsStencilDepthPass;\n    command.shaderProgram = classificationPrimitive._sp;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.TERRAIN_CLASSIFICATION;\n    derivedCommand = DrawCommand.shallowClone(command, command.derivedCommands.tileset);\n    derivedCommand.renderState = classificationPrimitive._rsStencilDepthPass3DTiles;\n    derivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedCommand; // Color command\n\n    command = colorCommands[i + 2];\n\n    if (!defined(command)) {\n      command = colorCommands[i + 2] = new DrawCommand({\n        owner: classificationPrimitive,\n        primitiveType: primitive._primitiveType\n      });\n    }\n\n    command.vertexArray = vertexArray;\n    command.renderState = classificationPrimitive._rsColorPass;\n    command.shaderProgram = classificationPrimitive._spColor;\n    command.pass = Pass.TERRAIN_CLASSIFICATION;\n    var appearance = classificationPrimitive.appearance;\n    var material = appearance.material;\n\n    if (defined(material)) {\n      uniformMap = combine(uniformMap, material._uniforms);\n    }\n\n    command.uniformMap = uniformMap;\n    derivedCommand = DrawCommand.shallowClone(command, command.derivedCommands.tileset);\n    derivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedCommand; // Derive for 2D if texture coordinates are ever computed\n\n    if (needs2DShader) {\n      // First derive from the terrain command\n      var derived2DCommand = DrawCommand.shallowClone(command, command.derivedCommands.appearance2D);\n      derived2DCommand.shaderProgram = classificationPrimitive._spColor2D;\n      command.derivedCommands.appearance2D = derived2DCommand; // Then derive from the 3D Tiles command\n\n      derived2DCommand = DrawCommand.shallowClone(derivedCommand, derivedCommand.derivedCommands.appearance2D);\n      derived2DCommand.shaderProgram = classificationPrimitive._spColor2D;\n      derivedCommand.derivedCommands.appearance2D = derived2DCommand;\n    }\n  }\n\n  var commandsIgnoreShow = classificationPrimitive._commandsIgnoreShow;\n  var spStencil = classificationPrimitive._spStencil;\n  var commandIndex = 0;\n  length = commandsIgnoreShow.length = length / 3 * 2;\n\n  for (var j = 0; j < length; j += 2) {\n    var commandIgnoreShow = commandsIgnoreShow[j] = DrawCommand.shallowClone(colorCommands[commandIndex], commandsIgnoreShow[j]);\n    commandIgnoreShow.shaderProgram = spStencil;\n    commandIgnoreShow.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW;\n    commandIgnoreShow = commandsIgnoreShow[j + 1] = DrawCommand.shallowClone(colorCommands[commandIndex + 1], commandsIgnoreShow[j + 1]);\n    commandIgnoreShow.shaderProgram = spStencil;\n    commandIgnoreShow.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW;\n    commandIndex += 3;\n  }\n}\n\nfunction createPickCommands(classificationPrimitive, pickCommands) {\n  var usePickOffsets = classificationPrimitive._usePickOffsets;\n  var primitive = classificationPrimitive._primitive;\n  var length = primitive._va.length * 3; // each geometry (pack of vertex attributes) needs 3 commands: front/back stencils and fill\n  // Fallback for batching same-color geometry instances\n\n  var pickOffsets;\n  var pickIndex = 0;\n  var pickOffset;\n\n  if (usePickOffsets) {\n    pickOffsets = primitive._pickOffsets;\n    length = pickOffsets.length * 3;\n  }\n\n  pickCommands.length = length;\n  var j;\n  var command;\n  var derivedCommand;\n  var vaIndex = 0;\n\n  var uniformMap = primitive._batchTable.getUniformMapCallback()(classificationPrimitive._uniformMap);\n\n  var needs2DShader = classificationPrimitive._needs2DShader;\n\n  for (j = 0; j < length; j += 3) {\n    var vertexArray = primitive._va[vaIndex++];\n\n    if (usePickOffsets) {\n      pickOffset = pickOffsets[pickIndex++];\n      vertexArray = primitive._va[pickOffset.index];\n    } // Stencil preload command\n\n\n    command = pickCommands[j];\n\n    if (!defined(command)) {\n      command = pickCommands[j] = new DrawCommand({\n        owner: classificationPrimitive,\n        primitiveType: primitive._primitiveType,\n        pickOnly: true\n      });\n    }\n\n    command.vertexArray = vertexArray;\n    command.renderState = classificationPrimitive._rsStencilPreloadPass;\n    command.shaderProgram = classificationPrimitive._sp;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.TERRAIN_CLASSIFICATION;\n\n    if (usePickOffsets) {\n      command.offset = pickOffset.offset;\n      command.count = pickOffset.count;\n    } // Derive for 3D Tiles classification\n\n\n    derivedCommand = DrawCommand.shallowClone(command, command.derivedCommands.tileset);\n    derivedCommand.renderState = classificationPrimitive._rsStencilPreloadPass3DTiles;\n    derivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedCommand; // Stencil depth command\n\n    command = pickCommands[j + 1];\n\n    if (!defined(command)) {\n      command = pickCommands[j + 1] = new DrawCommand({\n        owner: classificationPrimitive,\n        primitiveType: primitive._primitiveType,\n        pickOnly: true\n      });\n    }\n\n    command.vertexArray = vertexArray;\n    command.renderState = classificationPrimitive._rsStencilDepthPass;\n    command.shaderProgram = classificationPrimitive._sp;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.TERRAIN_CLASSIFICATION;\n\n    if (usePickOffsets) {\n      command.offset = pickOffset.offset;\n      command.count = pickOffset.count;\n    } // Derive for 3D Tiles classification\n\n\n    derivedCommand = DrawCommand.shallowClone(command, command.derivedCommands.tileset);\n    derivedCommand.renderState = classificationPrimitive._rsStencilDepthPass3DTiles;\n    derivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedCommand; // Pick color command\n\n    command = pickCommands[j + 2];\n\n    if (!defined(command)) {\n      command = pickCommands[j + 2] = new DrawCommand({\n        owner: classificationPrimitive,\n        primitiveType: primitive._primitiveType,\n        pickOnly: true\n      });\n    }\n\n    command.vertexArray = vertexArray;\n    command.renderState = classificationPrimitive._rsPickPass;\n    command.shaderProgram = classificationPrimitive._spPick;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.TERRAIN_CLASSIFICATION;\n\n    if (usePickOffsets) {\n      command.offset = pickOffset.offset;\n      command.count = pickOffset.count;\n    }\n\n    derivedCommand = DrawCommand.shallowClone(command, command.derivedCommands.tileset);\n    derivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedCommand; // Derive for 2D if texture coordinates are ever computed\n\n    if (needs2DShader) {\n      // First derive from the terrain command\n      var derived2DCommand = DrawCommand.shallowClone(command, command.derivedCommands.pick2D);\n      derived2DCommand.shaderProgram = classificationPrimitive._spPick2D;\n      command.derivedCommands.pick2D = derived2DCommand; // Then derive from the 3D Tiles command\n\n      derived2DCommand = DrawCommand.shallowClone(derivedCommand, derivedCommand.derivedCommands.pick2D);\n      derived2DCommand.shaderProgram = classificationPrimitive._spPick2D;\n      derivedCommand.derivedCommands.pick2D = derived2DCommand;\n    }\n  }\n}\n\nfunction createCommands(classificationPrimitive, appearance, material, translucent, twoPasses, colorCommands, pickCommands) {\n  createColorCommands(classificationPrimitive, colorCommands);\n  createPickCommands(classificationPrimitive, pickCommands);\n}\n\nfunction boundingVolumeIndex(commandIndex, length) {\n  return Math.floor(commandIndex % length / 3);\n}\n\nfunction updateAndQueueRenderCommand(command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume) {\n  command.modelMatrix = modelMatrix;\n  command.boundingVolume = boundingVolume;\n  command.cull = cull;\n  command.debugShowBoundingVolume = debugShowBoundingVolume;\n  frameState.commandList.push(command);\n}\n\nfunction updateAndQueuePickCommand(command, frameState, modelMatrix, cull, boundingVolume) {\n  command.modelMatrix = modelMatrix;\n  command.boundingVolume = boundingVolume;\n  command.cull = cull;\n  frameState.commandList.push(command);\n}\n\nfunction updateAndQueueCommands(classificationPrimitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {\n  var primitive = classificationPrimitive._primitive;\n\n  Primitive._updateBoundingVolumes(primitive, frameState, modelMatrix);\n\n  var boundingVolumes;\n\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingVolumes = primitive._boundingSphereWC;\n  } else if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n    boundingVolumes = primitive._boundingSphereCV;\n  } else if (frameState.mode === SceneMode.SCENE2D && defined(primitive._boundingSphere2D)) {\n    boundingVolumes = primitive._boundingSphere2D;\n  } else if (defined(primitive._boundingSphereMorph)) {\n    boundingVolumes = primitive._boundingSphereMorph;\n  }\n\n  var classificationType = classificationPrimitive.classificationType;\n  var queueTerrainCommands = classificationType !== ClassificationType.CESIUM_3D_TILE;\n  var queue3DTilesCommands = classificationType !== ClassificationType.TERRAIN;\n  var passes = frameState.passes;\n  var i;\n  var boundingVolume;\n  var command;\n\n  if (passes.render) {\n    var colorLength = colorCommands.length;\n\n    for (i = 0; i < colorLength; ++i) {\n      boundingVolume = boundingVolumes[boundingVolumeIndex(i, colorLength)];\n\n      if (queueTerrainCommands) {\n        command = colorCommands[i];\n        updateAndQueueRenderCommand(command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume);\n      }\n\n      if (queue3DTilesCommands) {\n        command = colorCommands[i].derivedCommands.tileset;\n        updateAndQueueRenderCommand(command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume);\n      }\n    }\n\n    if (frameState.invertClassification) {\n      var ignoreShowCommands = classificationPrimitive._commandsIgnoreShow;\n      var ignoreShowCommandsLength = ignoreShowCommands.length;\n\n      for (i = 0; i < ignoreShowCommandsLength; ++i) {\n        boundingVolume = boundingVolumes[Math.floor(i / 2)];\n        command = ignoreShowCommands[i];\n        updateAndQueueRenderCommand(command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume);\n      }\n    }\n  }\n\n  if (passes.pick) {\n    var pickLength = pickCommands.length;\n    var pickOffsets = primitive._pickOffsets;\n\n    for (i = 0; i < pickLength; ++i) {\n      var pickOffset = pickOffsets[boundingVolumeIndex(i, pickLength)];\n      boundingVolume = boundingVolumes[pickOffset.index];\n\n      if (queueTerrainCommands) {\n        command = pickCommands[i];\n        updateAndQueuePickCommand(command, frameState, modelMatrix, cull, boundingVolume);\n      }\n\n      if (queue3DTilesCommands) {\n        command = pickCommands[i].derivedCommands.tileset;\n        updateAndQueuePickCommand(command, frameState, modelMatrix, cull, boundingVolume);\n      }\n    }\n  }\n}\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} All instance geometries must have the same primitiveType.\n * @exception {DeveloperError} Appearance and material have a uniform with the same name.\n * @exception {DeveloperError} Not all of the geometry instances have the same color attribute.\n */\n\n\nClassificationPrimitive.prototype.update = function (frameState) {\n  if (!defined(this._primitive) && !defined(this.geometryInstances)) {\n    return;\n  }\n\n  var appearance = this.appearance;\n\n  if (defined(appearance) && defined(appearance.material)) {\n    appearance.material.update(frameState.context);\n  }\n\n  var that = this;\n  var primitiveOptions = this._primitiveOptions;\n\n  if (!defined(this._primitive)) {\n    var instances = Array.isArray(this.geometryInstances) ? this.geometryInstances : [this.geometryInstances];\n    var length = instances.length;\n    var i;\n    var instance;\n    var attributes;\n    var hasPerColorAttribute = false;\n    var allColorsSame = true;\n    var firstColor;\n    var hasSphericalExtentsAttribute = false;\n    var hasPlanarExtentsAttributes = false;\n\n    if (length > 0) {\n      attributes = instances[0].attributes; // Not expecting these to be set by users, should only be set via GroundPrimitive.\n      // So don't check for mismatch.\n\n      hasSphericalExtentsAttribute = ShadowVolumeAppearance.hasAttributesForSphericalExtents(attributes);\n      hasPlanarExtentsAttributes = ShadowVolumeAppearance.hasAttributesForTextureCoordinatePlanes(attributes);\n      firstColor = attributes.color;\n    }\n\n    for (i = 0; i < length; i++) {\n      instance = instances[i];\n      var color = instance.attributes.color;\n\n      if (defined(color)) {\n        hasPerColorAttribute = true;\n      } //>>includeStart('debug', pragmas.debug);\n      else if (hasPerColorAttribute) {\n          throw new DeveloperError(\"All GeometryInstances must have color attributes to use per-instance color.\");\n        } //>>includeEnd('debug');\n\n\n      allColorsSame = allColorsSame && defined(color) && ColorGeometryInstanceAttribute.equals(firstColor, color);\n    } // If no attributes exist for computing spherical extents or fragment culling,\n    // throw if the colors aren't all the same.\n\n\n    if (!allColorsSame && !hasSphericalExtentsAttribute && !hasPlanarExtentsAttributes) {\n      throw new DeveloperError(\"All GeometryInstances must have the same color attribute except via GroundPrimitives\");\n    } // default to a color appearance\n\n\n    if (hasPerColorAttribute && !defined(appearance)) {\n      appearance = new PerInstanceColorAppearance({\n        flat: true\n      });\n      this.appearance = appearance;\n    } //>>includeStart('debug', pragmas.debug);\n\n\n    if (!hasPerColorAttribute && appearance instanceof PerInstanceColorAppearance) {\n      throw new DeveloperError(\"PerInstanceColorAppearance requires color GeometryInstanceAttributes on all GeometryInstances\");\n    }\n\n    if (defined(appearance.material) && !hasSphericalExtentsAttribute && !hasPlanarExtentsAttributes) {\n      throw new DeveloperError(\"Materials on ClassificationPrimitives are not supported except via GroundPrimitives\");\n    } //>>includeEnd('debug');\n\n\n    this._usePickOffsets = !hasSphericalExtentsAttribute && !hasPlanarExtentsAttributes;\n    this._hasSphericalExtentsAttribute = hasSphericalExtentsAttribute;\n    this._hasPlanarExtentsAttributes = hasPlanarExtentsAttributes;\n    this._hasPerColorAttribute = hasPerColorAttribute;\n    var geometryInstances = new Array(length);\n\n    for (i = 0; i < length; ++i) {\n      instance = instances[i];\n      geometryInstances[i] = new GeometryInstance({\n        geometry: instance.geometry,\n        attributes: instance.attributes,\n        modelMatrix: instance.modelMatrix,\n        id: instance.id,\n        pickPrimitive: defaultValue(this._pickPrimitive, that)\n      });\n    }\n\n    primitiveOptions.appearance = appearance;\n    primitiveOptions.geometryInstances = geometryInstances;\n\n    if (defined(this._createBoundingVolumeFunction)) {\n      primitiveOptions._createBoundingVolumeFunction = function (frameState, geometry) {\n        that._createBoundingVolumeFunction(frameState, geometry);\n      };\n    }\n\n    primitiveOptions._createRenderStatesFunction = function (primitive, context, appearance, twoPasses) {\n      createRenderStates(that, context);\n    };\n\n    primitiveOptions._createShaderProgramFunction = function (primitive, frameState, appearance) {\n      createShaderProgram(that, frameState);\n    };\n\n    primitiveOptions._createCommandsFunction = function (primitive, appearance, material, translucent, twoPasses, colorCommands, pickCommands) {\n      createCommands(that, undefined, undefined, true, false, colorCommands, pickCommands);\n    };\n\n    if (defined(this._updateAndQueueCommandsFunction)) {\n      primitiveOptions._updateAndQueueCommandsFunction = function (primitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {\n        that._updateAndQueueCommandsFunction(primitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses);\n      };\n    } else {\n      primitiveOptions._updateAndQueueCommandsFunction = function (primitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {\n        updateAndQueueCommands(that, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses);\n      };\n    }\n\n    this._primitive = new Primitive(primitiveOptions);\n\n    this._primitive.readyPromise.then(function (primitive) {\n      that._ready = true;\n\n      if (that.releaseGeometryInstances) {\n        that.geometryInstances = undefined;\n      }\n\n      var error = primitive._error;\n\n      if (!defined(error)) {\n        that._readyPromise.resolve(that);\n      } else {\n        that._readyPromise.reject(error);\n      }\n    });\n  }\n\n  if (this.debugShowShadowVolume && !this._debugShowShadowVolume && this._ready) {\n    this._debugShowShadowVolume = true;\n    this._rsStencilPreloadPass = RenderState.fromCache(getStencilPreloadRenderState(false, false));\n    this._rsStencilPreloadPass3DTiles = RenderState.fromCache(getStencilPreloadRenderState(false, true));\n    this._rsStencilDepthPass = RenderState.fromCache(getStencilDepthRenderState(false, false));\n    this._rsStencilDepthPass3DTiles = RenderState.fromCache(getStencilDepthRenderState(false, true));\n    this._rsColorPass = RenderState.fromCache(getColorRenderState(false));\n  } else if (!this.debugShowShadowVolume && this._debugShowShadowVolume) {\n    this._debugShowShadowVolume = false;\n    this._rsStencilPreloadPass = RenderState.fromCache(getStencilPreloadRenderState(true, false));\n    this._rsStencilPreloadPass3DTiles = RenderState.fromCache(getStencilPreloadRenderState(true, true));\n    this._rsStencilDepthPass = RenderState.fromCache(getStencilDepthRenderState(true, false));\n    this._rsStencilDepthPass3DTiles = RenderState.fromCache(getStencilDepthRenderState(true, true));\n    this._rsColorPass = RenderState.fromCache(getColorRenderState(true));\n  } // Update primitive appearance\n\n\n  if (this._primitive.appearance !== appearance) {\n    //>>includeStart('debug', pragmas.debug);\n    // Check if the appearance is supported by the geometry attributes\n    if (!this._hasSphericalExtentsAttribute && !this._hasPlanarExtentsAttributes && defined(appearance.material)) {\n      throw new DeveloperError(\"Materials on ClassificationPrimitives are not supported except via GroundPrimitive\");\n    }\n\n    if (!this._hasPerColorAttribute && appearance instanceof PerInstanceColorAppearance) {\n      throw new DeveloperError(\"PerInstanceColorAppearance requires color GeometryInstanceAttribute\");\n    } //>>includeEnd('debug');\n\n\n    this._primitive.appearance = appearance;\n  }\n\n  this._primitive.show = this.show;\n  this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume;\n\n  this._primitive.update(frameState);\n};\n/**\n * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.\n *\n * @param {*} id The id of the {@link GeometryInstance}.\n * @returns {Object} The typed array in the attribute's format or undefined if the is no instance with id.\n *\n * @exception {DeveloperError} must call update before calling getGeometryInstanceAttributes.\n *\n * @example\n * var attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);\n */\n\n\nClassificationPrimitive.prototype.getGeometryInstanceAttributes = function (id) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(this._primitive)) {\n    throw new DeveloperError(\"must call update before calling getGeometryInstanceAttributes\");\n  } //>>includeEnd('debug');\n\n\n  return this._primitive.getGeometryInstanceAttributes(id);\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ClassificationPrimitive#destroy\n */\n\n\nClassificationPrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * e = e && e.destroy();\n *\n * @see ClassificationPrimitive#isDestroyed\n */\n\n\nClassificationPrimitive.prototype.destroy = function () {\n  this._primitive = this._primitive && this._primitive.destroy();\n  this._sp = this._sp && this._sp.destroy();\n  this._spPick = this._spPick && this._spPick.destroy();\n  this._spColor = this._spColor && this._spColor.destroy(); // Derived programs, destroyed above if they existed.\n\n  this._spPick2D = undefined;\n  this._spColor2D = undefined;\n  return destroyObject(this);\n};\n\nexport default ClassificationPrimitive;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/ClassificationPrimitive.js"],"names":["ColorGeometryInstanceAttribute","combine","defaultValue","defined","destroyObject","DeveloperError","GeometryInstance","DrawCommand","Pass","RenderState","ShaderProgram","ShaderSource","ShadowVolumeAppearanceVS","ShadowVolumeFS","when","BlendingState","ClassificationType","DepthFunction","PerInstanceColorAppearance","Primitive","SceneMode","ShadowVolumeAppearance","StencilConstants","StencilFunction","StencilOperation","ClassificationPrimitive","options","EMPTY_OBJECT","geometryInstances","show","classificationType","BOTH","debugShowBoundingVolume","debugShowShadowVolume","_debugShowShadowVolume","_extruded","_uniformMap","_sp","undefined","_spStencil","_spPick","_spColor","_spPick2D","_spColor2D","_rsStencilPreloadPass","_rsStencilPreloadPass3DTiles","_rsStencilDepthPass","_rsStencilDepthPass3DTiles","_rsColorPass","_rsPickPass","_commandsIgnoreShow","_ready","_readyPromise","defer","_primitive","_pickPrimitive","_hasSphericalExtentsAttribute","_hasPlanarExtentsAttributes","_hasPerColorAttribute","appearance","_createBoundingVolumeFunction","_updateAndQueueCommandsFunction","_usePickOffsets","_primitiveOptions","vertexCacheOptimize","interleave","releaseGeometryInstances","allowPicking","asynchronous","compressVertices","_createRenderStatesFunction","_createShaderProgramFunction","_createCommandsFunction","_createPickOffsets","Object","defineProperties","prototype","get","ready","readyPromise","promise","_needs2DShader","isSupported","scene","context","stencilBuffer","getStencilPreloadRenderState","enableStencil","mask3DTiles","stencilFunction","EQUAL","ALWAYS","colorMask","red","green","blue","alpha","stencilTest","enabled","frontFunction","frontOperation","fail","KEEP","zFail","DECREMENT_WRAP","zPass","backFunction","backOperation","INCREMENT_WRAP","reference","CESIUM_3D_TILE_MASK","mask","stencilMask","CLASSIFICATION_MASK","depthTest","depthMask","getStencilDepthRenderState","func","LESS_OR_EQUAL","getColorRenderState","NOT_EQUAL","blending","ALPHA_BLEND","pickRenderState","createRenderStates","classificationPrimitive","twoPasses","stencilEnabled","fromCache","modifyForEncodedNormals","primitive","vertexShaderSource","search","attributeName","attributeDecl","globalDecl","decode","modifiedVS","replace","replaceMain","compressedMain","join","createShaderProgram","frameState","vs","_batchTable","getVertexShaderCallback","_appendDistanceDisplayConditionToShader","_modifyShaderPosition","scene3DOnly","_updateColorAttribute","planarExtents","cullFragmentsUsingExtents","extrudedDefine","vsSource","defines","sources","fsSource","attributeLocations","_attributeLocations","shadowVolumeAppearance","replaceCache","shaderProgram","fragmentShaderSource","vsPick","createPickVertexShaderSource","_appendShowToShader","_updatePickColorAttribute","pickFS3D","createPickFragmentShader","pickVS3D","createPickVertexShader","mapProjection","pickProgram2D","shaderCache","getDerivedShaderProgram","pickFS2D","pickVS2D","createDerivedShaderProgram","fsColorSource","createFragmentShader","vsColorSource","createVertexShader","colorProgram2D","fsColorSource2D","vsColorSource2D","createColorCommands","colorCommands","length","_va","i","command","derivedCommand","vaIndex","uniformMap","getUniformMapCallback","needs2DShader","vertexArray","owner","primitiveType","_primitiveType","renderState","pass","TERRAIN_CLASSIFICATION","shallowClone","derivedCommands","tileset","CESIUM_3D_TILE_CLASSIFICATION","material","_uniforms","derived2DCommand","appearance2D","commandsIgnoreShow","spStencil","commandIndex","j","commandIgnoreShow","CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW","createPickCommands","pickCommands","usePickOffsets","pickOffsets","pickIndex","pickOffset","_pickOffsets","index","pickOnly","offset","count","pick2D","createCommands","translucent","boundingVolumeIndex","Math","floor","updateAndQueueRenderCommand","modelMatrix","cull","boundingVolume","commandList","push","updateAndQueuePickCommand","updateAndQueueCommands","_updateBoundingVolumes","boundingVolumes","mode","SCENE3D","_boundingSphereWC","COLUMBUS_VIEW","_boundingSphereCV","SCENE2D","_boundingSphere2D","_boundingSphereMorph","queueTerrainCommands","CESIUM_3D_TILE","queue3DTilesCommands","TERRAIN","passes","render","colorLength","invertClassification","ignoreShowCommands","ignoreShowCommandsLength","pick","pickLength","update","that","primitiveOptions","instances","Array","isArray","instance","attributes","hasPerColorAttribute","allColorsSame","firstColor","hasSphericalExtentsAttribute","hasPlanarExtentsAttributes","hasAttributesForSphericalExtents","hasAttributesForTextureCoordinatePlanes","color","equals","flat","geometry","id","pickPrimitive","then","error","_error","resolve","reject","getGeometryInstanceAttributes","isDestroyed","destroy"],"mappings":"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","sourcesContent":["import ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport ShadowVolumeAppearanceVS from \"../Shaders/ShadowVolumeAppearanceVS.js\";\nimport ShadowVolumeFS from \"../Shaders/ShadowVolumeFS.js\";\nimport when from \"../ThirdParty/when.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowVolumeAppearance from \"./ShadowVolumeAppearance.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\n\n/**\n * A classification primitive represents a volume enclosing geometry in the {@link Scene} to be highlighted.\n * <p>\n * A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including\n * {@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,\n * and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix\n * and match most of them and add a new geometry or appearance independently of each other.\n * Only {@link PerInstanceColorAppearance} with the same color across all instances is supported at this time when using\n * ClassificationPrimitive directly.\n * For full {@link Appearance} support when classifying terrain or 3D Tiles use {@link GroundPrimitive} instead.\n * </p>\n * <p>\n * For correct rendering, this feature requires the EXT_frag_depth WebGL extension. For hardware that do not support this extension, there\n * will be rendering artifacts for some viewing angles.\n * </p>\n * <p>\n * Valid geometries are {@link BoxGeometry}, {@link CylinderGeometry}, {@link EllipsoidGeometry}, {@link PolylineVolumeGeometry}, and {@link SphereGeometry}.\n * </p>\n * <p>\n * Geometries that follow the surface of the ellipsoid, such as {@link CircleGeometry}, {@link CorridorGeometry}, {@link EllipseGeometry}, {@link PolygonGeometry}, and {@link RectangleGeometry},\n * are also valid if they are extruded volumes; otherwise, they will not be rendered.\n * </p>\n *\n * @alias ClassificationPrimitive\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Array|GeometryInstance} [options.geometryInstances] The geometry instances to render. This can either be a single instance or an array of length one.\n * @param {Appearance} [options.appearance] The appearance used to render the primitive. Defaults to PerInstanceColorAppearance when GeometryInstances have a color attribute.\n * @param {Boolean} [options.show=true] Determines if this primitive will be shown.\n * @param {Boolean} [options.vertexCacheOptimize=false] When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n * @param {Boolean} [options.interleave=false] When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.\n * @param {Boolean} [options.compressVertices=true] When <code>true</code>, the geometry vertices are compressed, which will save memory.\n * @param {Boolean} [options.releaseGeometryInstances=true] When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n * @param {Boolean} [options.asynchronous=true] Determines if the primitive will be created asynchronously or block until ready. If false initializeTerrainHeights() must be called first.\n * @param {ClassificationType} [options.classificationType=ClassificationType.BOTH] Determines whether terrain, 3D Tiles or both will be classified.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {Boolean} [options.debugShowShadowVolume=false] For debugging only. Determines if the shadow volume for each geometry in the primitive is drawn. Must be <code>true</code> on\n *                  creation for the volumes to be created before the geometry is released or options.releaseGeometryInstance must be <code>false</code>.\n *\n * @see Primitive\n * @see GroundPrimitive\n * @see GeometryInstance\n * @see Appearance\n */\nfunction ClassificationPrimitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var geometryInstances = options.geometryInstances;\n\n  /**\n   * The geometry instance rendered with this primitive.  This may\n   * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>\n   * is <code>true</code> when the primitive is constructed.\n   * <p>\n   * Changing this property after the primitive is rendered has no effect.\n   * </p>\n   * <p>\n   * Because of the rendering technique used, all geometry instances must be the same color.\n   * If there is an instance with a differing color, a <code>DeveloperError</code> will be thrown\n   * on the first attempt to render.\n   * </p>\n   *\n   * @readonly\n   * @type {Array|GeometryInstance}\n   *\n   * @default undefined\n   */\n  this.geometryInstances = geometryInstances;\n  /**\n   * Determines if the primitive will be shown.  This affects all geometry\n   * instances in the primitive.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n  /**\n   * Determines whether terrain, 3D Tiles or both will be classified.\n   *\n   * @type {ClassificationType}\n   *\n   * @default ClassificationType.BOTH\n   */\n  this.classificationType = defaultValue(\n    options.classificationType,\n    ClassificationType.BOTH\n  );\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false\n  );\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the shadow volume for each geometry in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugShowShadowVolume = defaultValue(\n    options.debugShowShadowVolume,\n    false\n  );\n  this._debugShowShadowVolume = false;\n\n  // These are used by GroundPrimitive to augment the shader and uniform map.\n  this._extruded = defaultValue(options._extruded, false);\n  this._uniformMap = options._uniformMap;\n\n  this._sp = undefined;\n  this._spStencil = undefined;\n  this._spPick = undefined;\n  this._spColor = undefined;\n\n  this._spPick2D = undefined; // only derived if necessary\n  this._spColor2D = undefined; // only derived if necessary\n\n  this._rsStencilPreloadPass = undefined;\n  this._rsStencilPreloadPass3DTiles = undefined;\n  this._rsStencilDepthPass = undefined;\n  this._rsStencilDepthPass3DTiles = undefined;\n  this._rsColorPass = undefined;\n  this._rsPickPass = undefined;\n\n  this._commandsIgnoreShow = [];\n\n  this._ready = false;\n  this._readyPromise = when.defer();\n\n  this._primitive = undefined;\n  this._pickPrimitive = options._pickPrimitive;\n\n  // Set in update\n  this._hasSphericalExtentsAttribute = false;\n  this._hasPlanarExtentsAttributes = false;\n  this._hasPerColorAttribute = false;\n\n  this.appearance = options.appearance;\n\n  this._createBoundingVolumeFunction = options._createBoundingVolumeFunction;\n  this._updateAndQueueCommandsFunction =\n    options._updateAndQueueCommandsFunction;\n\n  this._usePickOffsets = false;\n\n  this._primitiveOptions = {\n    geometryInstances: undefined,\n    appearance: undefined,\n    vertexCacheOptimize: defaultValue(options.vertexCacheOptimize, false),\n    interleave: defaultValue(options.interleave, false),\n    releaseGeometryInstances: defaultValue(\n      options.releaseGeometryInstances,\n      true\n    ),\n    allowPicking: defaultValue(options.allowPicking, true),\n    asynchronous: defaultValue(options.asynchronous, true),\n    compressVertices: defaultValue(options.compressVertices, true),\n    _createBoundingVolumeFunction: undefined,\n    _createRenderStatesFunction: undefined,\n    _createShaderProgramFunction: undefined,\n    _createCommandsFunction: undefined,\n    _updateAndQueueCommandsFunction: undefined,\n    _createPickOffsets: true,\n  };\n}\n\nObject.defineProperties(ClassificationPrimitive.prototype, {\n  /**\n   * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  vertexCacheOptimize: {\n    get: function () {\n      return this._primitiveOptions.vertexCacheOptimize;\n    },\n  },\n\n  /**\n   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  interleave: {\n    get: function () {\n      return this._primitiveOptions.interleave;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  releaseGeometryInstances: {\n    get: function () {\n      return this._primitiveOptions.releaseGeometryInstances;\n    },\n  },\n\n  /**\n   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._primitiveOptions.allowPicking;\n    },\n  },\n\n  /**\n   * Determines if the geometry instances will be created and batched on a web worker.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._primitiveOptions.asynchronous;\n    },\n  },\n\n  /**\n   * When <code>true</code>, geometry vertices are compressed, which will save memory.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  compressVertices: {\n    get: function () {\n      return this._primitiveOptions.compressVertices;\n    },\n  },\n\n  /**\n   * Determines if the primitive is complete and ready to render.  If this property is\n   * true, the primitive will be rendered the next time that {@link ClassificationPrimitive#update}\n   * is called.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves when the primitive is ready to render.\n   * @memberof ClassificationPrimitive.prototype\n   * @type {Promise.<ClassificationPrimitive>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n\n  /**\n   * Returns true if the ClassificationPrimitive needs a separate shader and commands for 2D.\n   * This is because texture coordinates on ClassificationPrimitives are computed differently,\n   * and are used for culling when multiple GeometryInstances are batched in one ClassificationPrimitive.\n   * @memberof ClassificationPrimitive.prototype\n   * @type {Boolean}\n   * @readonly\n   * @private\n   */\n  _needs2DShader: {\n    get: function () {\n      return (\n        this._hasPlanarExtentsAttributes || this._hasSphericalExtentsAttribute\n      );\n    },\n  },\n});\n\n/**\n * Determines if ClassificationPrimitive rendering is supported.\n *\n * @param {Scene} scene The scene.\n * @returns {Boolean} <code>true</code> if ClassificationPrimitives are supported; otherwise, returns <code>false</code>\n */\nClassificationPrimitive.isSupported = function (scene) {\n  return scene.context.stencilBuffer;\n};\n\nfunction getStencilPreloadRenderState(enableStencil, mask3DTiles) {\n  var stencilFunction = mask3DTiles\n    ? StencilFunction.EQUAL\n    : StencilFunction.ALWAYS;\n  return {\n    colorMask: {\n      red: false,\n      green: false,\n      blue: false,\n      alpha: false,\n    },\n    stencilTest: {\n      enabled: enableStencil,\n      frontFunction: stencilFunction,\n      frontOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.DECREMENT_WRAP,\n        zPass: StencilOperation.DECREMENT_WRAP,\n      },\n      backFunction: stencilFunction,\n      backOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.INCREMENT_WRAP,\n        zPass: StencilOperation.INCREMENT_WRAP,\n      },\n      reference: StencilConstants.CESIUM_3D_TILE_MASK,\n      mask: StencilConstants.CESIUM_3D_TILE_MASK,\n    },\n    stencilMask: StencilConstants.CLASSIFICATION_MASK,\n    depthTest: {\n      enabled: false,\n    },\n    depthMask: false,\n  };\n}\n\nfunction getStencilDepthRenderState(enableStencil, mask3DTiles) {\n  var stencilFunction = mask3DTiles\n    ? StencilFunction.EQUAL\n    : StencilFunction.ALWAYS;\n  return {\n    colorMask: {\n      red: false,\n      green: false,\n      blue: false,\n      alpha: false,\n    },\n    stencilTest: {\n      enabled: enableStencil,\n      frontFunction: stencilFunction,\n      frontOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.INCREMENT_WRAP,\n      },\n      backFunction: stencilFunction,\n      backOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.DECREMENT_WRAP,\n      },\n      reference: StencilConstants.CESIUM_3D_TILE_MASK,\n      mask: StencilConstants.CESIUM_3D_TILE_MASK,\n    },\n    stencilMask: StencilConstants.CLASSIFICATION_MASK,\n    depthTest: {\n      enabled: true,\n      func: DepthFunction.LESS_OR_EQUAL,\n    },\n    depthMask: false,\n  };\n}\n\nfunction getColorRenderState(enableStencil) {\n  return {\n    stencilTest: {\n      enabled: enableStencil,\n      frontFunction: StencilFunction.NOT_EQUAL,\n      frontOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.DECREMENT_WRAP,\n      },\n      backFunction: StencilFunction.NOT_EQUAL,\n      backOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.DECREMENT_WRAP,\n      },\n      reference: 0,\n      mask: StencilConstants.CLASSIFICATION_MASK,\n    },\n    stencilMask: StencilConstants.CLASSIFICATION_MASK,\n    depthTest: {\n      enabled: false,\n    },\n    depthMask: false,\n    blending: BlendingState.ALPHA_BLEND,\n  };\n}\n\nvar pickRenderState = {\n  stencilTest: {\n    enabled: true,\n    frontFunction: StencilFunction.NOT_EQUAL,\n    frontOperation: {\n      fail: StencilOperation.KEEP,\n      zFail: StencilOperation.KEEP,\n      zPass: StencilOperation.DECREMENT_WRAP,\n    },\n    backFunction: StencilFunction.NOT_EQUAL,\n    backOperation: {\n      fail: StencilOperation.KEEP,\n      zFail: StencilOperation.KEEP,\n      zPass: StencilOperation.DECREMENT_WRAP,\n    },\n    reference: 0,\n    mask: StencilConstants.CLASSIFICATION_MASK,\n  },\n  stencilMask: StencilConstants.CLASSIFICATION_MASK,\n  depthTest: {\n    enabled: false,\n  },\n  depthMask: false,\n};\n\nfunction createRenderStates(\n  classificationPrimitive,\n  context,\n  appearance,\n  twoPasses\n) {\n  if (defined(classificationPrimitive._rsStencilPreloadPass)) {\n    return;\n  }\n  var stencilEnabled = !classificationPrimitive.debugShowShadowVolume;\n\n  classificationPrimitive._rsStencilPreloadPass = RenderState.fromCache(\n    getStencilPreloadRenderState(stencilEnabled, false)\n  );\n  classificationPrimitive._rsStencilPreloadPass3DTiles = RenderState.fromCache(\n    getStencilPreloadRenderState(stencilEnabled, true)\n  );\n  classificationPrimitive._rsStencilDepthPass = RenderState.fromCache(\n    getStencilDepthRenderState(stencilEnabled, false)\n  );\n  classificationPrimitive._rsStencilDepthPass3DTiles = RenderState.fromCache(\n    getStencilDepthRenderState(stencilEnabled, true)\n  );\n  classificationPrimitive._rsColorPass = RenderState.fromCache(\n    getColorRenderState(stencilEnabled, false)\n  );\n  classificationPrimitive._rsPickPass = RenderState.fromCache(pickRenderState);\n}\n\nfunction modifyForEncodedNormals(primitive, vertexShaderSource) {\n  if (!primitive.compressVertices) {\n    return vertexShaderSource;\n  }\n\n  if (\n    vertexShaderSource.search(/attribute\\s+vec3\\s+extrudeDirection;/g) !== -1\n  ) {\n    var attributeName = \"compressedAttributes\";\n\n    //only shadow volumes use extrudeDirection, and shadow volumes use vertexFormat: POSITION_ONLY so we don't need to check other attributes\n    var attributeDecl = \"attribute vec2 \" + attributeName + \";\";\n\n    var globalDecl = \"vec3 extrudeDirection;\\n\";\n    var decode =\n      \"    extrudeDirection = czm_octDecode(\" + attributeName + \", 65535.0);\\n\";\n\n    var modifiedVS = vertexShaderSource;\n    modifiedVS = modifiedVS.replace(\n      /attribute\\s+vec3\\s+extrudeDirection;/g,\n      \"\"\n    );\n    modifiedVS = ShaderSource.replaceMain(\n      modifiedVS,\n      \"czm_non_compressed_main\"\n    );\n    var compressedMain =\n      \"void main() \\n\" +\n      \"{ \\n\" +\n      decode +\n      \"    czm_non_compressed_main(); \\n\" +\n      \"}\";\n\n    return [attributeDecl, globalDecl, modifiedVS, compressedMain].join(\"\\n\");\n  }\n}\n\nfunction createShaderProgram(classificationPrimitive, frameState) {\n  var context = frameState.context;\n  var primitive = classificationPrimitive._primitive;\n  var vs = ShadowVolumeAppearanceVS;\n  vs = classificationPrimitive._primitive._batchTable.getVertexShaderCallback()(\n    vs\n  );\n  vs = Primitive._appendDistanceDisplayConditionToShader(primitive, vs);\n  vs = Primitive._modifyShaderPosition(\n    classificationPrimitive,\n    vs,\n    frameState.scene3DOnly\n  );\n  vs = Primitive._updateColorAttribute(primitive, vs);\n\n  var planarExtents = classificationPrimitive._hasPlanarExtentsAttributes;\n  var cullFragmentsUsingExtents =\n    planarExtents || classificationPrimitive._hasSphericalExtentsAttribute;\n\n  if (classificationPrimitive._extruded) {\n    vs = modifyForEncodedNormals(primitive, vs);\n  }\n\n  var extrudedDefine = classificationPrimitive._extruded\n    ? \"EXTRUDED_GEOMETRY\"\n    : \"\";\n\n  var vsSource = new ShaderSource({\n    defines: [extrudedDefine],\n    sources: [vs],\n  });\n  var fsSource = new ShaderSource({\n    sources: [ShadowVolumeFS],\n  });\n  var attributeLocations =\n    classificationPrimitive._primitive._attributeLocations;\n\n  var shadowVolumeAppearance = new ShadowVolumeAppearance(\n    cullFragmentsUsingExtents,\n    planarExtents,\n    classificationPrimitive.appearance\n  );\n\n  classificationPrimitive._spStencil = ShaderProgram.replaceCache({\n    context: context,\n    shaderProgram: classificationPrimitive._spStencil,\n    vertexShaderSource: vsSource,\n    fragmentShaderSource: fsSource,\n    attributeLocations: attributeLocations,\n  });\n\n  if (classificationPrimitive._primitive.allowPicking) {\n    var vsPick = ShaderSource.createPickVertexShaderSource(vs);\n    vsPick = Primitive._appendShowToShader(primitive, vsPick);\n    vsPick = Primitive._updatePickColorAttribute(vsPick);\n\n    var pickFS3D = shadowVolumeAppearance.createPickFragmentShader(false);\n    var pickVS3D = shadowVolumeAppearance.createPickVertexShader(\n      [extrudedDefine],\n      vsPick,\n      false,\n      frameState.mapProjection\n    );\n\n    classificationPrimitive._spPick = ShaderProgram.replaceCache({\n      context: context,\n      shaderProgram: classificationPrimitive._spPick,\n      vertexShaderSource: pickVS3D,\n      fragmentShaderSource: pickFS3D,\n      attributeLocations: attributeLocations,\n    });\n\n    // Derive a 2D pick shader if the primitive uses texture coordinate-based fragment culling,\n    // since texture coordinates are computed differently in 2D.\n    if (cullFragmentsUsingExtents) {\n      var pickProgram2D = context.shaderCache.getDerivedShaderProgram(\n        classificationPrimitive._spPick,\n        \"2dPick\"\n      );\n      if (!defined(pickProgram2D)) {\n        var pickFS2D = shadowVolumeAppearance.createPickFragmentShader(true);\n        var pickVS2D = shadowVolumeAppearance.createPickVertexShader(\n          [extrudedDefine],\n          vsPick,\n          true,\n          frameState.mapProjection\n        );\n\n        pickProgram2D = context.shaderCache.createDerivedShaderProgram(\n          classificationPrimitive._spPick,\n          \"2dPick\",\n          {\n            vertexShaderSource: pickVS2D,\n            fragmentShaderSource: pickFS2D,\n            attributeLocations: attributeLocations,\n          }\n        );\n      }\n      classificationPrimitive._spPick2D = pickProgram2D;\n    }\n  } else {\n    classificationPrimitive._spPick = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vsSource,\n      fragmentShaderSource: fsSource,\n      attributeLocations: attributeLocations,\n    });\n  }\n\n  vs = Primitive._appendShowToShader(primitive, vs);\n  vsSource = new ShaderSource({\n    defines: [extrudedDefine],\n    sources: [vs],\n  });\n\n  classificationPrimitive._sp = ShaderProgram.replaceCache({\n    context: context,\n    shaderProgram: classificationPrimitive._sp,\n    vertexShaderSource: vsSource,\n    fragmentShaderSource: fsSource,\n    attributeLocations: attributeLocations,\n  });\n\n  // Create a fragment shader that computes only required material hookups using screen space techniques\n  var fsColorSource = shadowVolumeAppearance.createFragmentShader(false);\n  var vsColorSource = shadowVolumeAppearance.createVertexShader(\n    [extrudedDefine],\n    vs,\n    false,\n    frameState.mapProjection\n  );\n\n  classificationPrimitive._spColor = ShaderProgram.replaceCache({\n    context: context,\n    shaderProgram: classificationPrimitive._spColor,\n    vertexShaderSource: vsColorSource,\n    fragmentShaderSource: fsColorSource,\n    attributeLocations: attributeLocations,\n  });\n\n  // Derive a 2D shader if the primitive uses texture coordinate-based fragment culling,\n  // since texture coordinates are computed differently in 2D.\n  // Any material that uses texture coordinates will also equip texture coordinate-based fragment culling.\n  if (cullFragmentsUsingExtents) {\n    var colorProgram2D = context.shaderCache.getDerivedShaderProgram(\n      classificationPrimitive._spColor,\n      \"2dColor\"\n    );\n    if (!defined(colorProgram2D)) {\n      var fsColorSource2D = shadowVolumeAppearance.createFragmentShader(true);\n      var vsColorSource2D = shadowVolumeAppearance.createVertexShader(\n        [extrudedDefine],\n        vs,\n        true,\n        frameState.mapProjection\n      );\n\n      colorProgram2D = context.shaderCache.createDerivedShaderProgram(\n        classificationPrimitive._spColor,\n        \"2dColor\",\n        {\n          vertexShaderSource: vsColorSource2D,\n          fragmentShaderSource: fsColorSource2D,\n          attributeLocations: attributeLocations,\n        }\n      );\n    }\n    classificationPrimitive._spColor2D = colorProgram2D;\n  }\n}\n\nfunction createColorCommands(classificationPrimitive, colorCommands) {\n  var primitive = classificationPrimitive._primitive;\n  var length = primitive._va.length * 3; // each geometry (pack of vertex attributes) needs 3 commands: front/back stencils and fill\n  colorCommands.length = length;\n\n  var i;\n  var command;\n  var derivedCommand;\n  var vaIndex = 0;\n  var uniformMap = primitive._batchTable.getUniformMapCallback()(\n    classificationPrimitive._uniformMap\n  );\n\n  var needs2DShader = classificationPrimitive._needs2DShader;\n\n  for (i = 0; i < length; i += 3) {\n    var vertexArray = primitive._va[vaIndex++];\n\n    // Stencil preload command\n    command = colorCommands[i];\n    if (!defined(command)) {\n      command = colorCommands[i] = new DrawCommand({\n        owner: classificationPrimitive,\n        primitiveType: primitive._primitiveType,\n      });\n    }\n\n    command.vertexArray = vertexArray;\n    command.renderState = classificationPrimitive._rsStencilPreloadPass;\n    command.shaderProgram = classificationPrimitive._sp;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.TERRAIN_CLASSIFICATION;\n\n    derivedCommand = DrawCommand.shallowClone(\n      command,\n      command.derivedCommands.tileset\n    );\n    derivedCommand.renderState =\n      classificationPrimitive._rsStencilPreloadPass3DTiles;\n    derivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedCommand;\n\n    // Stencil depth command\n    command = colorCommands[i + 1];\n    if (!defined(command)) {\n      command = colorCommands[i + 1] = new DrawCommand({\n        owner: classificationPrimitive,\n        primitiveType: primitive._primitiveType,\n      });\n    }\n\n    command.vertexArray = vertexArray;\n    command.renderState = classificationPrimitive._rsStencilDepthPass;\n    command.shaderProgram = classificationPrimitive._sp;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.TERRAIN_CLASSIFICATION;\n\n    derivedCommand = DrawCommand.shallowClone(\n      command,\n      command.derivedCommands.tileset\n    );\n    derivedCommand.renderState =\n      classificationPrimitive._rsStencilDepthPass3DTiles;\n    derivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedCommand;\n\n    // Color command\n    command = colorCommands[i + 2];\n    if (!defined(command)) {\n      command = colorCommands[i + 2] = new DrawCommand({\n        owner: classificationPrimitive,\n        primitiveType: primitive._primitiveType,\n      });\n    }\n\n    command.vertexArray = vertexArray;\n    command.renderState = classificationPrimitive._rsColorPass;\n    command.shaderProgram = classificationPrimitive._spColor;\n    command.pass = Pass.TERRAIN_CLASSIFICATION;\n\n    var appearance = classificationPrimitive.appearance;\n    var material = appearance.material;\n    if (defined(material)) {\n      uniformMap = combine(uniformMap, material._uniforms);\n    }\n\n    command.uniformMap = uniformMap;\n\n    derivedCommand = DrawCommand.shallowClone(\n      command,\n      command.derivedCommands.tileset\n    );\n    derivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedCommand;\n\n    // Derive for 2D if texture coordinates are ever computed\n    if (needs2DShader) {\n      // First derive from the terrain command\n      var derived2DCommand = DrawCommand.shallowClone(\n        command,\n        command.derivedCommands.appearance2D\n      );\n      derived2DCommand.shaderProgram = classificationPrimitive._spColor2D;\n      command.derivedCommands.appearance2D = derived2DCommand;\n\n      // Then derive from the 3D Tiles command\n      derived2DCommand = DrawCommand.shallowClone(\n        derivedCommand,\n        derivedCommand.derivedCommands.appearance2D\n      );\n      derived2DCommand.shaderProgram = classificationPrimitive._spColor2D;\n      derivedCommand.derivedCommands.appearance2D = derived2DCommand;\n    }\n  }\n\n  var commandsIgnoreShow = classificationPrimitive._commandsIgnoreShow;\n  var spStencil = classificationPrimitive._spStencil;\n\n  var commandIndex = 0;\n  length = commandsIgnoreShow.length = (length / 3) * 2;\n\n  for (var j = 0; j < length; j += 2) {\n    var commandIgnoreShow = (commandsIgnoreShow[j] = DrawCommand.shallowClone(\n      colorCommands[commandIndex],\n      commandsIgnoreShow[j]\n    ));\n    commandIgnoreShow.shaderProgram = spStencil;\n    commandIgnoreShow.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW;\n\n    commandIgnoreShow = commandsIgnoreShow[j + 1] = DrawCommand.shallowClone(\n      colorCommands[commandIndex + 1],\n      commandsIgnoreShow[j + 1]\n    );\n    commandIgnoreShow.shaderProgram = spStencil;\n    commandIgnoreShow.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW;\n\n    commandIndex += 3;\n  }\n}\n\nfunction createPickCommands(classificationPrimitive, pickCommands) {\n  var usePickOffsets = classificationPrimitive._usePickOffsets;\n\n  var primitive = classificationPrimitive._primitive;\n  var length = primitive._va.length * 3; // each geometry (pack of vertex attributes) needs 3 commands: front/back stencils and fill\n\n  // Fallback for batching same-color geometry instances\n  var pickOffsets;\n  var pickIndex = 0;\n  var pickOffset;\n  if (usePickOffsets) {\n    pickOffsets = primitive._pickOffsets;\n    length = pickOffsets.length * 3;\n  }\n\n  pickCommands.length = length;\n\n  var j;\n  var command;\n  var derivedCommand;\n  var vaIndex = 0;\n  var uniformMap = primitive._batchTable.getUniformMapCallback()(\n    classificationPrimitive._uniformMap\n  );\n\n  var needs2DShader = classificationPrimitive._needs2DShader;\n\n  for (j = 0; j < length; j += 3) {\n    var vertexArray = primitive._va[vaIndex++];\n    if (usePickOffsets) {\n      pickOffset = pickOffsets[pickIndex++];\n      vertexArray = primitive._va[pickOffset.index];\n    }\n\n    // Stencil preload command\n    command = pickCommands[j];\n    if (!defined(command)) {\n      command = pickCommands[j] = new DrawCommand({\n        owner: classificationPrimitive,\n        primitiveType: primitive._primitiveType,\n        pickOnly: true,\n      });\n    }\n\n    command.vertexArray = vertexArray;\n    command.renderState = classificationPrimitive._rsStencilPreloadPass;\n    command.shaderProgram = classificationPrimitive._sp;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.TERRAIN_CLASSIFICATION;\n    if (usePickOffsets) {\n      command.offset = pickOffset.offset;\n      command.count = pickOffset.count;\n    }\n\n    // Derive for 3D Tiles classification\n    derivedCommand = DrawCommand.shallowClone(\n      command,\n      command.derivedCommands.tileset\n    );\n    derivedCommand.renderState =\n      classificationPrimitive._rsStencilPreloadPass3DTiles;\n    derivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedCommand;\n\n    // Stencil depth command\n    command = pickCommands[j + 1];\n    if (!defined(command)) {\n      command = pickCommands[j + 1] = new DrawCommand({\n        owner: classificationPrimitive,\n        primitiveType: primitive._primitiveType,\n        pickOnly: true,\n      });\n    }\n\n    command.vertexArray = vertexArray;\n    command.renderState = classificationPrimitive._rsStencilDepthPass;\n    command.shaderProgram = classificationPrimitive._sp;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.TERRAIN_CLASSIFICATION;\n    if (usePickOffsets) {\n      command.offset = pickOffset.offset;\n      command.count = pickOffset.count;\n    }\n\n    // Derive for 3D Tiles classification\n    derivedCommand = DrawCommand.shallowClone(\n      command,\n      command.derivedCommands.tileset\n    );\n    derivedCommand.renderState =\n      classificationPrimitive._rsStencilDepthPass3DTiles;\n    derivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedCommand;\n\n    // Pick color command\n    command = pickCommands[j + 2];\n    if (!defined(command)) {\n      command = pickCommands[j + 2] = new DrawCommand({\n        owner: classificationPrimitive,\n        primitiveType: primitive._primitiveType,\n        pickOnly: true,\n      });\n    }\n\n    command.vertexArray = vertexArray;\n    command.renderState = classificationPrimitive._rsPickPass;\n    command.shaderProgram = classificationPrimitive._spPick;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.TERRAIN_CLASSIFICATION;\n    if (usePickOffsets) {\n      command.offset = pickOffset.offset;\n      command.count = pickOffset.count;\n    }\n\n    derivedCommand = DrawCommand.shallowClone(\n      command,\n      command.derivedCommands.tileset\n    );\n    derivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedCommand;\n\n    // Derive for 2D if texture coordinates are ever computed\n    if (needs2DShader) {\n      // First derive from the terrain command\n      var derived2DCommand = DrawCommand.shallowClone(\n        command,\n        command.derivedCommands.pick2D\n      );\n      derived2DCommand.shaderProgram = classificationPrimitive._spPick2D;\n      command.derivedCommands.pick2D = derived2DCommand;\n\n      // Then derive from the 3D Tiles command\n      derived2DCommand = DrawCommand.shallowClone(\n        derivedCommand,\n        derivedCommand.derivedCommands.pick2D\n      );\n      derived2DCommand.shaderProgram = classificationPrimitive._spPick2D;\n      derivedCommand.derivedCommands.pick2D = derived2DCommand;\n    }\n  }\n}\n\nfunction createCommands(\n  classificationPrimitive,\n  appearance,\n  material,\n  translucent,\n  twoPasses,\n  colorCommands,\n  pickCommands\n) {\n  createColorCommands(classificationPrimitive, colorCommands);\n  createPickCommands(classificationPrimitive, pickCommands);\n}\n\nfunction boundingVolumeIndex(commandIndex, length) {\n  return Math.floor((commandIndex % length) / 3);\n}\n\nfunction updateAndQueueRenderCommand(\n  command,\n  frameState,\n  modelMatrix,\n  cull,\n  boundingVolume,\n  debugShowBoundingVolume\n) {\n  command.modelMatrix = modelMatrix;\n  command.boundingVolume = boundingVolume;\n  command.cull = cull;\n  command.debugShowBoundingVolume = debugShowBoundingVolume;\n\n  frameState.commandList.push(command);\n}\n\nfunction updateAndQueuePickCommand(\n  command,\n  frameState,\n  modelMatrix,\n  cull,\n  boundingVolume\n) {\n  command.modelMatrix = modelMatrix;\n  command.boundingVolume = boundingVolume;\n  command.cull = cull;\n\n  frameState.commandList.push(command);\n}\n\nfunction updateAndQueueCommands(\n  classificationPrimitive,\n  frameState,\n  colorCommands,\n  pickCommands,\n  modelMatrix,\n  cull,\n  debugShowBoundingVolume,\n  twoPasses\n) {\n  var primitive = classificationPrimitive._primitive;\n  Primitive._updateBoundingVolumes(primitive, frameState, modelMatrix);\n\n  var boundingVolumes;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingVolumes = primitive._boundingSphereWC;\n  } else if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n    boundingVolumes = primitive._boundingSphereCV;\n  } else if (\n    frameState.mode === SceneMode.SCENE2D &&\n    defined(primitive._boundingSphere2D)\n  ) {\n    boundingVolumes = primitive._boundingSphere2D;\n  } else if (defined(primitive._boundingSphereMorph)) {\n    boundingVolumes = primitive._boundingSphereMorph;\n  }\n\n  var classificationType = classificationPrimitive.classificationType;\n  var queueTerrainCommands =\n    classificationType !== ClassificationType.CESIUM_3D_TILE;\n  var queue3DTilesCommands = classificationType !== ClassificationType.TERRAIN;\n\n  var passes = frameState.passes;\n\n  var i;\n  var boundingVolume;\n  var command;\n\n  if (passes.render) {\n    var colorLength = colorCommands.length;\n    for (i = 0; i < colorLength; ++i) {\n      boundingVolume = boundingVolumes[boundingVolumeIndex(i, colorLength)];\n      if (queueTerrainCommands) {\n        command = colorCommands[i];\n        updateAndQueueRenderCommand(\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume,\n          debugShowBoundingVolume\n        );\n      }\n      if (queue3DTilesCommands) {\n        command = colorCommands[i].derivedCommands.tileset;\n        updateAndQueueRenderCommand(\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume,\n          debugShowBoundingVolume\n        );\n      }\n    }\n\n    if (frameState.invertClassification) {\n      var ignoreShowCommands = classificationPrimitive._commandsIgnoreShow;\n      var ignoreShowCommandsLength = ignoreShowCommands.length;\n      for (i = 0; i < ignoreShowCommandsLength; ++i) {\n        boundingVolume = boundingVolumes[Math.floor(i / 2)];\n        command = ignoreShowCommands[i];\n        updateAndQueueRenderCommand(\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume,\n          debugShowBoundingVolume\n        );\n      }\n    }\n  }\n\n  if (passes.pick) {\n    var pickLength = pickCommands.length;\n    var pickOffsets = primitive._pickOffsets;\n    for (i = 0; i < pickLength; ++i) {\n      var pickOffset = pickOffsets[boundingVolumeIndex(i, pickLength)];\n      boundingVolume = boundingVolumes[pickOffset.index];\n      if (queueTerrainCommands) {\n        command = pickCommands[i];\n        updateAndQueuePickCommand(\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume\n        );\n      }\n      if (queue3DTilesCommands) {\n        command = pickCommands[i].derivedCommands.tileset;\n        updateAndQueuePickCommand(\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume\n        );\n      }\n    }\n  }\n}\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} All instance geometries must have the same primitiveType.\n * @exception {DeveloperError} Appearance and material have a uniform with the same name.\n * @exception {DeveloperError} Not all of the geometry instances have the same color attribute.\n */\nClassificationPrimitive.prototype.update = function (frameState) {\n  if (!defined(this._primitive) && !defined(this.geometryInstances)) {\n    return;\n  }\n\n  var appearance = this.appearance;\n  if (defined(appearance) && defined(appearance.material)) {\n    appearance.material.update(frameState.context);\n  }\n\n  var that = this;\n  var primitiveOptions = this._primitiveOptions;\n\n  if (!defined(this._primitive)) {\n    var instances = Array.isArray(this.geometryInstances)\n      ? this.geometryInstances\n      : [this.geometryInstances];\n    var length = instances.length;\n\n    var i;\n    var instance;\n    var attributes;\n\n    var hasPerColorAttribute = false;\n    var allColorsSame = true;\n    var firstColor;\n    var hasSphericalExtentsAttribute = false;\n    var hasPlanarExtentsAttributes = false;\n\n    if (length > 0) {\n      attributes = instances[0].attributes;\n      // Not expecting these to be set by users, should only be set via GroundPrimitive.\n      // So don't check for mismatch.\n      hasSphericalExtentsAttribute = ShadowVolumeAppearance.hasAttributesForSphericalExtents(\n        attributes\n      );\n      hasPlanarExtentsAttributes = ShadowVolumeAppearance.hasAttributesForTextureCoordinatePlanes(\n        attributes\n      );\n      firstColor = attributes.color;\n    }\n\n    for (i = 0; i < length; i++) {\n      instance = instances[i];\n      var color = instance.attributes.color;\n      if (defined(color)) {\n        hasPerColorAttribute = true;\n      }\n      //>>includeStart('debug', pragmas.debug);\n      else if (hasPerColorAttribute) {\n        throw new DeveloperError(\n          \"All GeometryInstances must have color attributes to use per-instance color.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      allColorsSame =\n        allColorsSame &&\n        defined(color) &&\n        ColorGeometryInstanceAttribute.equals(firstColor, color);\n    }\n\n    // If no attributes exist for computing spherical extents or fragment culling,\n    // throw if the colors aren't all the same.\n    if (\n      !allColorsSame &&\n      !hasSphericalExtentsAttribute &&\n      !hasPlanarExtentsAttributes\n    ) {\n      throw new DeveloperError(\n        \"All GeometryInstances must have the same color attribute except via GroundPrimitives\"\n      );\n    }\n\n    // default to a color appearance\n    if (hasPerColorAttribute && !defined(appearance)) {\n      appearance = new PerInstanceColorAppearance({\n        flat: true,\n      });\n      this.appearance = appearance;\n    }\n\n    //>>includeStart('debug', pragmas.debug);\n    if (\n      !hasPerColorAttribute &&\n      appearance instanceof PerInstanceColorAppearance\n    ) {\n      throw new DeveloperError(\n        \"PerInstanceColorAppearance requires color GeometryInstanceAttributes on all GeometryInstances\"\n      );\n    }\n    if (\n      defined(appearance.material) &&\n      !hasSphericalExtentsAttribute &&\n      !hasPlanarExtentsAttributes\n    ) {\n      throw new DeveloperError(\n        \"Materials on ClassificationPrimitives are not supported except via GroundPrimitives\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    this._usePickOffsets =\n      !hasSphericalExtentsAttribute && !hasPlanarExtentsAttributes;\n    this._hasSphericalExtentsAttribute = hasSphericalExtentsAttribute;\n    this._hasPlanarExtentsAttributes = hasPlanarExtentsAttributes;\n    this._hasPerColorAttribute = hasPerColorAttribute;\n\n    var geometryInstances = new Array(length);\n    for (i = 0; i < length; ++i) {\n      instance = instances[i];\n      geometryInstances[i] = new GeometryInstance({\n        geometry: instance.geometry,\n        attributes: instance.attributes,\n        modelMatrix: instance.modelMatrix,\n        id: instance.id,\n        pickPrimitive: defaultValue(this._pickPrimitive, that),\n      });\n    }\n\n    primitiveOptions.appearance = appearance;\n    primitiveOptions.geometryInstances = geometryInstances;\n\n    if (defined(this._createBoundingVolumeFunction)) {\n      primitiveOptions._createBoundingVolumeFunction = function (\n        frameState,\n        geometry\n      ) {\n        that._createBoundingVolumeFunction(frameState, geometry);\n      };\n    }\n\n    primitiveOptions._createRenderStatesFunction = function (\n      primitive,\n      context,\n      appearance,\n      twoPasses\n    ) {\n      createRenderStates(that, context);\n    };\n    primitiveOptions._createShaderProgramFunction = function (\n      primitive,\n      frameState,\n      appearance\n    ) {\n      createShaderProgram(that, frameState);\n    };\n    primitiveOptions._createCommandsFunction = function (\n      primitive,\n      appearance,\n      material,\n      translucent,\n      twoPasses,\n      colorCommands,\n      pickCommands\n    ) {\n      createCommands(\n        that,\n        undefined,\n        undefined,\n        true,\n        false,\n        colorCommands,\n        pickCommands\n      );\n    };\n\n    if (defined(this._updateAndQueueCommandsFunction)) {\n      primitiveOptions._updateAndQueueCommandsFunction = function (\n        primitive,\n        frameState,\n        colorCommands,\n        pickCommands,\n        modelMatrix,\n        cull,\n        debugShowBoundingVolume,\n        twoPasses\n      ) {\n        that._updateAndQueueCommandsFunction(\n          primitive,\n          frameState,\n          colorCommands,\n          pickCommands,\n          modelMatrix,\n          cull,\n          debugShowBoundingVolume,\n          twoPasses\n        );\n      };\n    } else {\n      primitiveOptions._updateAndQueueCommandsFunction = function (\n        primitive,\n        frameState,\n        colorCommands,\n        pickCommands,\n        modelMatrix,\n        cull,\n        debugShowBoundingVolume,\n        twoPasses\n      ) {\n        updateAndQueueCommands(\n          that,\n          frameState,\n          colorCommands,\n          pickCommands,\n          modelMatrix,\n          cull,\n          debugShowBoundingVolume,\n          twoPasses\n        );\n      };\n    }\n\n    this._primitive = new Primitive(primitiveOptions);\n    this._primitive.readyPromise.then(function (primitive) {\n      that._ready = true;\n\n      if (that.releaseGeometryInstances) {\n        that.geometryInstances = undefined;\n      }\n\n      var error = primitive._error;\n      if (!defined(error)) {\n        that._readyPromise.resolve(that);\n      } else {\n        that._readyPromise.reject(error);\n      }\n    });\n  }\n\n  if (\n    this.debugShowShadowVolume &&\n    !this._debugShowShadowVolume &&\n    this._ready\n  ) {\n    this._debugShowShadowVolume = true;\n    this._rsStencilPreloadPass = RenderState.fromCache(\n      getStencilPreloadRenderState(false, false)\n    );\n    this._rsStencilPreloadPass3DTiles = RenderState.fromCache(\n      getStencilPreloadRenderState(false, true)\n    );\n    this._rsStencilDepthPass = RenderState.fromCache(\n      getStencilDepthRenderState(false, false)\n    );\n    this._rsStencilDepthPass3DTiles = RenderState.fromCache(\n      getStencilDepthRenderState(false, true)\n    );\n    this._rsColorPass = RenderState.fromCache(getColorRenderState(false));\n  } else if (!this.debugShowShadowVolume && this._debugShowShadowVolume) {\n    this._debugShowShadowVolume = false;\n    this._rsStencilPreloadPass = RenderState.fromCache(\n      getStencilPreloadRenderState(true, false)\n    );\n    this._rsStencilPreloadPass3DTiles = RenderState.fromCache(\n      getStencilPreloadRenderState(true, true)\n    );\n    this._rsStencilDepthPass = RenderState.fromCache(\n      getStencilDepthRenderState(true, false)\n    );\n    this._rsStencilDepthPass3DTiles = RenderState.fromCache(\n      getStencilDepthRenderState(true, true)\n    );\n    this._rsColorPass = RenderState.fromCache(getColorRenderState(true));\n  }\n  // Update primitive appearance\n  if (this._primitive.appearance !== appearance) {\n    //>>includeStart('debug', pragmas.debug);\n    // Check if the appearance is supported by the geometry attributes\n    if (\n      !this._hasSphericalExtentsAttribute &&\n      !this._hasPlanarExtentsAttributes &&\n      defined(appearance.material)\n    ) {\n      throw new DeveloperError(\n        \"Materials on ClassificationPrimitives are not supported except via GroundPrimitive\"\n      );\n    }\n    if (\n      !this._hasPerColorAttribute &&\n      appearance instanceof PerInstanceColorAppearance\n    ) {\n      throw new DeveloperError(\n        \"PerInstanceColorAppearance requires color GeometryInstanceAttribute\"\n      );\n    }\n    //>>includeEnd('debug');\n    this._primitive.appearance = appearance;\n  }\n\n  this._primitive.show = this.show;\n  this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume;\n  this._primitive.update(frameState);\n};\n\n/**\n * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.\n *\n * @param {*} id The id of the {@link GeometryInstance}.\n * @returns {Object} The typed array in the attribute's format or undefined if the is no instance with id.\n *\n * @exception {DeveloperError} must call update before calling getGeometryInstanceAttributes.\n *\n * @example\n * var attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);\n */\nClassificationPrimitive.prototype.getGeometryInstanceAttributes = function (\n  id\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(this._primitive)) {\n    throw new DeveloperError(\n      \"must call update before calling getGeometryInstanceAttributes\"\n    );\n  }\n  //>>includeEnd('debug');\n  return this._primitive.getGeometryInstanceAttributes(id);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ClassificationPrimitive#destroy\n */\nClassificationPrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * e = e && e.destroy();\n *\n * @see ClassificationPrimitive#isDestroyed\n */\nClassificationPrimitive.prototype.destroy = function () {\n  this._primitive = this._primitive && this._primitive.destroy();\n  this._sp = this._sp && this._sp.destroy();\n  this._spPick = this._spPick && this._spPick.destroy();\n  this._spColor = this._spColor && this._spColor.destroy();\n\n  // Derived programs, destroyed above if they existed.\n  this._spPick2D = undefined;\n  this._spColor2D = undefined;\n  return destroyObject(this);\n};\nexport default ClassificationPrimitive;\n"]},"metadata":{},"sourceType":"module"}