{"ast":null,"code":"import defined from \"../Core/defined.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\n/**\n * @private\n */\n\nfunction ShadowMapShader() {}\n\nShadowMapShader.getShadowCastShaderKeyword = function (isPointLight, isTerrain, usesDepthTexture, isOpaque) {\n  return \"castShadow \" + isPointLight + \" \" + isTerrain + \" \" + usesDepthTexture + \" \" + isOpaque;\n};\n\nShadowMapShader.createShadowCastVertexShader = function (vs, isPointLight, isTerrain) {\n  var defines = vs.defines.slice(0);\n  var sources = vs.sources.slice(0);\n  defines.push(\"SHADOW_MAP\");\n\n  if (isTerrain) {\n    defines.push(\"GENERATE_POSITION\");\n  }\n\n  var positionVaryingName = ShaderSource.findPositionVarying(vs);\n  var hasPositionVarying = defined(positionVaryingName);\n\n  if (isPointLight && !hasPositionVarying) {\n    var length = sources.length;\n\n    for (var j = 0; j < length; ++j) {\n      sources[j] = ShaderSource.replaceMain(sources[j], \"czm_shadow_cast_main\");\n    }\n\n    var shadowVS = \"varying vec3 v_positionEC; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    czm_shadow_cast_main(); \\n\" + \"    v_positionEC = (czm_inverseProjection * gl_Position).xyz; \\n\" + \"}\";\n    sources.push(shadowVS);\n  }\n\n  return new ShaderSource({\n    defines: defines,\n    sources: sources\n  });\n};\n\nShadowMapShader.createShadowCastFragmentShader = function (fs, isPointLight, usesDepthTexture, opaque) {\n  var defines = fs.defines.slice(0);\n  var sources = fs.sources.slice(0);\n  var positionVaryingName = ShaderSource.findPositionVarying(fs);\n  var hasPositionVarying = defined(positionVaryingName);\n\n  if (!hasPositionVarying) {\n    positionVaryingName = \"v_positionEC\";\n  }\n\n  var length = sources.length;\n\n  for (var i = 0; i < length; ++i) {\n    sources[i] = ShaderSource.replaceMain(sources[i], \"czm_shadow_cast_main\");\n  }\n\n  var fsSource = \"\";\n\n  if (isPointLight) {\n    if (!hasPositionVarying) {\n      fsSource += \"varying vec3 v_positionEC; \\n\";\n    }\n\n    fsSource += \"uniform vec4 shadowMap_lightPositionEC; \\n\";\n  }\n\n  if (opaque) {\n    fsSource += \"void main() \\n\" + \"{ \\n\";\n  } else {\n    fsSource += \"void main() \\n\" + \"{ \\n\" + \"    czm_shadow_cast_main(); \\n\" + \"    if (gl_FragColor.a == 0.0) \\n\" + \"    { \\n\" + \"       discard; \\n\" + \"    } \\n\";\n  }\n\n  if (isPointLight) {\n    fsSource += \"    float distance = length(\" + positionVaryingName + \"); \\n\" + \"    if (distance >= shadowMap_lightPositionEC.w) \\n\" + \"    { \\n\" + \"        discard; \\n\" + \"    } \\n\" + \"    distance /= shadowMap_lightPositionEC.w; // radius \\n\" + \"    gl_FragColor = czm_packDepth(distance); \\n\";\n  } else if (usesDepthTexture) {\n    fsSource += \"    gl_FragColor = vec4(1.0); \\n\";\n  } else {\n    fsSource += \"    gl_FragColor = czm_packDepth(gl_FragCoord.z); \\n\";\n  }\n\n  fsSource += \"} \\n\";\n  sources.push(fsSource);\n  return new ShaderSource({\n    defines: defines,\n    sources: sources\n  });\n};\n\nShadowMapShader.getShadowReceiveShaderKeyword = function (shadowMap, castShadows, isTerrain, hasTerrainNormal) {\n  var usesDepthTexture = shadowMap._usesDepthTexture;\n  var polygonOffsetSupported = shadowMap._polygonOffsetSupported;\n  var isPointLight = shadowMap._isPointLight;\n  var isSpotLight = shadowMap._isSpotLight;\n  var hasCascades = shadowMap._numberOfCascades > 1;\n  var debugCascadeColors = shadowMap.debugCascadeColors;\n  var softShadows = shadowMap.softShadows;\n  return \"receiveShadow \" + usesDepthTexture + polygonOffsetSupported + isPointLight + isSpotLight + hasCascades + debugCascadeColors + softShadows + castShadows + isTerrain + hasTerrainNormal;\n};\n\nShadowMapShader.createShadowReceiveVertexShader = function (vs, isTerrain, hasTerrainNormal) {\n  var defines = vs.defines.slice(0);\n  var sources = vs.sources.slice(0);\n  defines.push(\"SHADOW_MAP\");\n\n  if (isTerrain) {\n    if (hasTerrainNormal) {\n      defines.push(\"GENERATE_POSITION_AND_NORMAL\");\n    } else {\n      defines.push(\"GENERATE_POSITION\");\n    }\n  }\n\n  return new ShaderSource({\n    defines: defines,\n    sources: sources\n  });\n};\n\nShadowMapShader.createShadowReceiveFragmentShader = function (fs, shadowMap, castShadows, isTerrain, hasTerrainNormal) {\n  var normalVaryingName = ShaderSource.findNormalVarying(fs);\n  var hasNormalVarying = !isTerrain && defined(normalVaryingName) || isTerrain && hasTerrainNormal;\n  var positionVaryingName = ShaderSource.findPositionVarying(fs);\n  var hasPositionVarying = defined(positionVaryingName);\n  var usesDepthTexture = shadowMap._usesDepthTexture;\n  var polygonOffsetSupported = shadowMap._polygonOffsetSupported;\n  var isPointLight = shadowMap._isPointLight;\n  var isSpotLight = shadowMap._isSpotLight;\n  var hasCascades = shadowMap._numberOfCascades > 1;\n  var debugCascadeColors = shadowMap.debugCascadeColors;\n  var softShadows = shadowMap.softShadows;\n  var bias = isPointLight ? shadowMap._pointBias : isTerrain ? shadowMap._terrainBias : shadowMap._primitiveBias;\n  var defines = fs.defines.slice(0);\n  var sources = fs.sources.slice(0);\n  var length = sources.length;\n\n  for (var i = 0; i < length; ++i) {\n    sources[i] = ShaderSource.replaceMain(sources[i], \"czm_shadow_receive_main\");\n  }\n\n  if (isPointLight) {\n    defines.push(\"USE_CUBE_MAP_SHADOW\");\n  } else if (usesDepthTexture) {\n    defines.push(\"USE_SHADOW_DEPTH_TEXTURE\");\n  }\n\n  if (softShadows && !isPointLight) {\n    defines.push(\"USE_SOFT_SHADOWS\");\n  } // Enable day-night shading so that the globe is dark when the light is below the horizon\n\n\n  if (hasCascades && castShadows && isTerrain) {\n    if (hasNormalVarying) {\n      defines.push(\"ENABLE_VERTEX_LIGHTING\");\n    } else {\n      defines.push(\"ENABLE_DAYNIGHT_SHADING\");\n    }\n  }\n\n  if (castShadows && bias.normalShading && hasNormalVarying) {\n    defines.push(\"USE_NORMAL_SHADING\");\n\n    if (bias.normalShadingSmooth > 0.0) {\n      defines.push(\"USE_NORMAL_SHADING_SMOOTH\");\n    }\n  }\n\n  var fsSource = \"\";\n\n  if (isPointLight) {\n    fsSource += \"uniform samplerCube shadowMap_textureCube; \\n\";\n  } else {\n    fsSource += \"uniform sampler2D shadowMap_texture; \\n\";\n  }\n\n  var returnPositionEC;\n\n  if (hasPositionVarying) {\n    returnPositionEC = \"    return vec4(\" + positionVaryingName + \", 1.0); \\n\";\n  } else {\n    returnPositionEC = \"#ifndef LOG_DEPTH \\n\" + \"    return czm_windowToEyeCoordinates(gl_FragCoord); \\n\" + \"#else \\n\" + \"    return vec4(v_logPositionEC, 1.0); \\n\" + \"#endif \\n\";\n  }\n\n  fsSource += \"uniform mat4 shadowMap_matrix; \\n\" + \"uniform vec3 shadowMap_lightDirectionEC; \\n\" + \"uniform vec4 shadowMap_lightPositionEC; \\n\" + \"uniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \\n\" + \"uniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \\n\" + \"#ifdef LOG_DEPTH \\n\" + \"varying vec3 v_logPositionEC; \\n\" + \"#endif \\n\" + \"vec4 getPositionEC() \\n\" + \"{ \\n\" + returnPositionEC + \"} \\n\" + \"vec3 getNormalEC() \\n\" + \"{ \\n\" + (hasNormalVarying ? \"    return normalize(\" + normalVaryingName + \"); \\n\" : \"    return vec3(1.0); \\n\") + \"} \\n\" + // Offset the shadow position in the direction of the normal for perpendicular and back faces\n  \"void applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \\n\" + \"{ \\n\" + (bias.normalOffset && hasNormalVarying ? \"    float normalOffset = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.x; \\n\" + \"    float normalOffsetScale = 1.0 - nDotL; \\n\" + \"    vec3 offset = normalOffset * normalOffsetScale * normalEC; \\n\" + \"    positionEC.xyz += offset; \\n\" : \"\") + \"} \\n\";\n  fsSource += \"void main() \\n\" + \"{ \\n\" + \"    czm_shadow_receive_main(); \\n\" + \"    vec4 positionEC = getPositionEC(); \\n\" + \"    vec3 normalEC = getNormalEC(); \\n\" + \"    float depth = -positionEC.z; \\n\";\n  fsSource += \"    czm_shadowParameters shadowParameters; \\n\" + \"    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \\n\" + \"    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \\n\" + \"    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \\n\" + \"    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \\n\";\n\n  if (isTerrain) {\n    // Scale depth bias based on view distance to reduce z-fighting in distant terrain\n    fsSource += \"    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \\n\";\n  } else if (!polygonOffsetSupported) {\n    // If polygon offset isn't supported push the depth back based on view, however this\n    // causes light leaking at further away views\n    fsSource += \"    shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015); \\n\";\n  }\n\n  if (isPointLight) {\n    fsSource += \"    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; \\n\" + \"    float distance = length(directionEC); \\n\" + \"    directionEC = normalize(directionEC); \\n\" + \"    float radius = shadowMap_lightPositionEC.w; \\n\" + \"    // Stop early if the fragment is beyond the point light radius \\n\" + \"    if (distance > radius) \\n\" + \"    { \\n\" + \"        return; \\n\" + \"    } \\n\" + \"    vec3 directionWC  = czm_inverseViewRotation * directionEC; \\n\" + \"    shadowParameters.depth = distance / radius; \\n\" + \"    shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \\n\" + \"    shadowParameters.texCoords = directionWC; \\n\" + \"    float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); \\n\";\n  } else if (isSpotLight) {\n    fsSource += \"    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \\n\" + \"    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \\n\" + \"    applyNormalOffset(positionEC, normalEC, nDotL); \\n\" + \"    vec4 shadowPosition = shadowMap_matrix * positionEC; \\n\" + \"    // Spot light uses a perspective projection, so perform the perspective divide \\n\" + \"    shadowPosition /= shadowPosition.w; \\n\" + \"    // Stop early if the fragment is not in the shadow bounds \\n\" + \"    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \\n\" + \"    { \\n\" + \"        return; \\n\" + \"    } \\n\" + \"    shadowParameters.texCoords = shadowPosition.xy; \\n\" + \"    shadowParameters.depth = shadowPosition.z; \\n\" + \"    shadowParameters.nDotL = nDotL; \\n\" + \"    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \\n\";\n  } else if (hasCascades) {\n    fsSource += \"    float maxDepth = shadowMap_cascadeSplits[1].w; \\n\" + \"    // Stop early if the eye depth exceeds the last cascade \\n\" + \"    if (depth > maxDepth) \\n\" + \"    { \\n\" + \"        return; \\n\" + \"    } \\n\" + \"    // Get the cascade based on the eye-space depth \\n\" + \"    vec4 weights = czm_cascadeWeights(depth); \\n\" + \"    // Apply normal offset \\n\" + \"    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \\n\" + \"    applyNormalOffset(positionEC, normalEC, nDotL); \\n\" + \"    // Transform position into the cascade \\n\" + \"    vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \\n\" + \"    // Get visibility \\n\" + \"    shadowParameters.texCoords = shadowPosition.xy; \\n\" + \"    shadowParameters.depth = shadowPosition.z; \\n\" + \"    shadowParameters.nDotL = nDotL; \\n\" + \"    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \\n\" + \"    // Fade out shadows that are far away \\n\" + \"    float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \\n\" + \"    float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \\n\" + \"    visibility = mix(visibility, 1.0, fade); \\n\" + (debugCascadeColors ? \"    // Draw cascade colors for debugging \\n\" + \"    gl_FragColor *= czm_cascadeColor(weights); \\n\" : \"\");\n  } else {\n    fsSource += \"    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \\n\" + \"    applyNormalOffset(positionEC, normalEC, nDotL); \\n\" + \"    vec4 shadowPosition = shadowMap_matrix * positionEC; \\n\" + \"    // Stop early if the fragment is not in the shadow bounds \\n\" + \"    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \\n\" + \"    { \\n\" + \"        return; \\n\" + \"    } \\n\" + \"    shadowParameters.texCoords = shadowPosition.xy; \\n\" + \"    shadowParameters.depth = shadowPosition.z; \\n\" + \"    shadowParameters.nDotL = nDotL; \\n\" + \"    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \\n\";\n  }\n\n  fsSource += \"    gl_FragColor.rgb *= visibility; \\n\" + \"} \\n\";\n  sources.push(fsSource);\n  return new ShaderSource({\n    defines: defines,\n    sources: sources\n  });\n};\n\nexport default ShadowMapShader;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/ShadowMapShader.js"],"names":["defined","ShaderSource","ShadowMapShader","getShadowCastShaderKeyword","isPointLight","isTerrain","usesDepthTexture","isOpaque","createShadowCastVertexShader","vs","defines","slice","sources","push","positionVaryingName","findPositionVarying","hasPositionVarying","length","j","replaceMain","shadowVS","createShadowCastFragmentShader","fs","opaque","i","fsSource","getShadowReceiveShaderKeyword","shadowMap","castShadows","hasTerrainNormal","_usesDepthTexture","polygonOffsetSupported","_polygonOffsetSupported","_isPointLight","isSpotLight","_isSpotLight","hasCascades","_numberOfCascades","debugCascadeColors","softShadows","createShadowReceiveVertexShader","createShadowReceiveFragmentShader","normalVaryingName","findNormalVarying","hasNormalVarying","bias","_pointBias","_terrainBias","_primitiveBias","normalShading","normalShadingSmooth","returnPositionEC","normalOffset"],"mappings":"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","sourcesContent":["import defined from \"../Core/defined.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\n\n/**\n * @private\n */\nfunction ShadowMapShader() {}\n\nShadowMapShader.getShadowCastShaderKeyword = function (\n  isPointLight,\n  isTerrain,\n  usesDepthTexture,\n  isOpaque\n) {\n  return (\n    \"castShadow \" +\n    isPointLight +\n    \" \" +\n    isTerrain +\n    \" \" +\n    usesDepthTexture +\n    \" \" +\n    isOpaque\n  );\n};\n\nShadowMapShader.createShadowCastVertexShader = function (\n  vs,\n  isPointLight,\n  isTerrain\n) {\n  var defines = vs.defines.slice(0);\n  var sources = vs.sources.slice(0);\n\n  defines.push(\"SHADOW_MAP\");\n\n  if (isTerrain) {\n    defines.push(\"GENERATE_POSITION\");\n  }\n\n  var positionVaryingName = ShaderSource.findPositionVarying(vs);\n  var hasPositionVarying = defined(positionVaryingName);\n\n  if (isPointLight && !hasPositionVarying) {\n    var length = sources.length;\n    for (var j = 0; j < length; ++j) {\n      sources[j] = ShaderSource.replaceMain(sources[j], \"czm_shadow_cast_main\");\n    }\n\n    var shadowVS =\n      \"varying vec3 v_positionEC; \\n\" +\n      \"void main() \\n\" +\n      \"{ \\n\" +\n      \"    czm_shadow_cast_main(); \\n\" +\n      \"    v_positionEC = (czm_inverseProjection * gl_Position).xyz; \\n\" +\n      \"}\";\n    sources.push(shadowVS);\n  }\n\n  return new ShaderSource({\n    defines: defines,\n    sources: sources,\n  });\n};\n\nShadowMapShader.createShadowCastFragmentShader = function (\n  fs,\n  isPointLight,\n  usesDepthTexture,\n  opaque\n) {\n  var defines = fs.defines.slice(0);\n  var sources = fs.sources.slice(0);\n\n  var positionVaryingName = ShaderSource.findPositionVarying(fs);\n  var hasPositionVarying = defined(positionVaryingName);\n  if (!hasPositionVarying) {\n    positionVaryingName = \"v_positionEC\";\n  }\n\n  var length = sources.length;\n  for (var i = 0; i < length; ++i) {\n    sources[i] = ShaderSource.replaceMain(sources[i], \"czm_shadow_cast_main\");\n  }\n\n  var fsSource = \"\";\n\n  if (isPointLight) {\n    if (!hasPositionVarying) {\n      fsSource += \"varying vec3 v_positionEC; \\n\";\n    }\n    fsSource += \"uniform vec4 shadowMap_lightPositionEC; \\n\";\n  }\n\n  if (opaque) {\n    fsSource += \"void main() \\n\" + \"{ \\n\";\n  } else {\n    fsSource +=\n      \"void main() \\n\" +\n      \"{ \\n\" +\n      \"    czm_shadow_cast_main(); \\n\" +\n      \"    if (gl_FragColor.a == 0.0) \\n\" +\n      \"    { \\n\" +\n      \"       discard; \\n\" +\n      \"    } \\n\";\n  }\n\n  if (isPointLight) {\n    fsSource +=\n      \"    float distance = length(\" +\n      positionVaryingName +\n      \"); \\n\" +\n      \"    if (distance >= shadowMap_lightPositionEC.w) \\n\" +\n      \"    { \\n\" +\n      \"        discard; \\n\" +\n      \"    } \\n\" +\n      \"    distance /= shadowMap_lightPositionEC.w; // radius \\n\" +\n      \"    gl_FragColor = czm_packDepth(distance); \\n\";\n  } else if (usesDepthTexture) {\n    fsSource += \"    gl_FragColor = vec4(1.0); \\n\";\n  } else {\n    fsSource += \"    gl_FragColor = czm_packDepth(gl_FragCoord.z); \\n\";\n  }\n\n  fsSource += \"} \\n\";\n\n  sources.push(fsSource);\n\n  return new ShaderSource({\n    defines: defines,\n    sources: sources,\n  });\n};\n\nShadowMapShader.getShadowReceiveShaderKeyword = function (\n  shadowMap,\n  castShadows,\n  isTerrain,\n  hasTerrainNormal\n) {\n  var usesDepthTexture = shadowMap._usesDepthTexture;\n  var polygonOffsetSupported = shadowMap._polygonOffsetSupported;\n  var isPointLight = shadowMap._isPointLight;\n  var isSpotLight = shadowMap._isSpotLight;\n  var hasCascades = shadowMap._numberOfCascades > 1;\n  var debugCascadeColors = shadowMap.debugCascadeColors;\n  var softShadows = shadowMap.softShadows;\n\n  return (\n    \"receiveShadow \" +\n    usesDepthTexture +\n    polygonOffsetSupported +\n    isPointLight +\n    isSpotLight +\n    hasCascades +\n    debugCascadeColors +\n    softShadows +\n    castShadows +\n    isTerrain +\n    hasTerrainNormal\n  );\n};\n\nShadowMapShader.createShadowReceiveVertexShader = function (\n  vs,\n  isTerrain,\n  hasTerrainNormal\n) {\n  var defines = vs.defines.slice(0);\n  var sources = vs.sources.slice(0);\n\n  defines.push(\"SHADOW_MAP\");\n\n  if (isTerrain) {\n    if (hasTerrainNormal) {\n      defines.push(\"GENERATE_POSITION_AND_NORMAL\");\n    } else {\n      defines.push(\"GENERATE_POSITION\");\n    }\n  }\n\n  return new ShaderSource({\n    defines: defines,\n    sources: sources,\n  });\n};\n\nShadowMapShader.createShadowReceiveFragmentShader = function (\n  fs,\n  shadowMap,\n  castShadows,\n  isTerrain,\n  hasTerrainNormal\n) {\n  var normalVaryingName = ShaderSource.findNormalVarying(fs);\n  var hasNormalVarying =\n    (!isTerrain && defined(normalVaryingName)) ||\n    (isTerrain && hasTerrainNormal);\n\n  var positionVaryingName = ShaderSource.findPositionVarying(fs);\n  var hasPositionVarying = defined(positionVaryingName);\n\n  var usesDepthTexture = shadowMap._usesDepthTexture;\n  var polygonOffsetSupported = shadowMap._polygonOffsetSupported;\n  var isPointLight = shadowMap._isPointLight;\n  var isSpotLight = shadowMap._isSpotLight;\n  var hasCascades = shadowMap._numberOfCascades > 1;\n  var debugCascadeColors = shadowMap.debugCascadeColors;\n  var softShadows = shadowMap.softShadows;\n  var bias = isPointLight\n    ? shadowMap._pointBias\n    : isTerrain\n    ? shadowMap._terrainBias\n    : shadowMap._primitiveBias;\n\n  var defines = fs.defines.slice(0);\n  var sources = fs.sources.slice(0);\n\n  var length = sources.length;\n  for (var i = 0; i < length; ++i) {\n    sources[i] = ShaderSource.replaceMain(\n      sources[i],\n      \"czm_shadow_receive_main\"\n    );\n  }\n\n  if (isPointLight) {\n    defines.push(\"USE_CUBE_MAP_SHADOW\");\n  } else if (usesDepthTexture) {\n    defines.push(\"USE_SHADOW_DEPTH_TEXTURE\");\n  }\n\n  if (softShadows && !isPointLight) {\n    defines.push(\"USE_SOFT_SHADOWS\");\n  }\n\n  // Enable day-night shading so that the globe is dark when the light is below the horizon\n  if (hasCascades && castShadows && isTerrain) {\n    if (hasNormalVarying) {\n      defines.push(\"ENABLE_VERTEX_LIGHTING\");\n    } else {\n      defines.push(\"ENABLE_DAYNIGHT_SHADING\");\n    }\n  }\n\n  if (castShadows && bias.normalShading && hasNormalVarying) {\n    defines.push(\"USE_NORMAL_SHADING\");\n    if (bias.normalShadingSmooth > 0.0) {\n      defines.push(\"USE_NORMAL_SHADING_SMOOTH\");\n    }\n  }\n\n  var fsSource = \"\";\n\n  if (isPointLight) {\n    fsSource += \"uniform samplerCube shadowMap_textureCube; \\n\";\n  } else {\n    fsSource += \"uniform sampler2D shadowMap_texture; \\n\";\n  }\n\n  var returnPositionEC;\n  if (hasPositionVarying) {\n    returnPositionEC = \"    return vec4(\" + positionVaryingName + \", 1.0); \\n\";\n  } else {\n    returnPositionEC =\n      \"#ifndef LOG_DEPTH \\n\" +\n      \"    return czm_windowToEyeCoordinates(gl_FragCoord); \\n\" +\n      \"#else \\n\" +\n      \"    return vec4(v_logPositionEC, 1.0); \\n\" +\n      \"#endif \\n\";\n  }\n\n  fsSource +=\n    \"uniform mat4 shadowMap_matrix; \\n\" +\n    \"uniform vec3 shadowMap_lightDirectionEC; \\n\" +\n    \"uniform vec4 shadowMap_lightPositionEC; \\n\" +\n    \"uniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \\n\" +\n    \"uniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \\n\" +\n    \"#ifdef LOG_DEPTH \\n\" +\n    \"varying vec3 v_logPositionEC; \\n\" +\n    \"#endif \\n\" +\n    \"vec4 getPositionEC() \\n\" +\n    \"{ \\n\" +\n    returnPositionEC +\n    \"} \\n\" +\n    \"vec3 getNormalEC() \\n\" +\n    \"{ \\n\" +\n    (hasNormalVarying\n      ? \"    return normalize(\" + normalVaryingName + \"); \\n\"\n      : \"    return vec3(1.0); \\n\") +\n    \"} \\n\" +\n    // Offset the shadow position in the direction of the normal for perpendicular and back faces\n    \"void applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \\n\" +\n    \"{ \\n\" +\n    (bias.normalOffset && hasNormalVarying\n      ? \"    float normalOffset = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.x; \\n\" +\n        \"    float normalOffsetScale = 1.0 - nDotL; \\n\" +\n        \"    vec3 offset = normalOffset * normalOffsetScale * normalEC; \\n\" +\n        \"    positionEC.xyz += offset; \\n\"\n      : \"\") +\n    \"} \\n\";\n\n  fsSource +=\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    czm_shadow_receive_main(); \\n\" +\n    \"    vec4 positionEC = getPositionEC(); \\n\" +\n    \"    vec3 normalEC = getNormalEC(); \\n\" +\n    \"    float depth = -positionEC.z; \\n\";\n\n  fsSource +=\n    \"    czm_shadowParameters shadowParameters; \\n\" +\n    \"    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \\n\" +\n    \"    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \\n\" +\n    \"    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \\n\" +\n    \"    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \\n\";\n\n  if (isTerrain) {\n    // Scale depth bias based on view distance to reduce z-fighting in distant terrain\n    fsSource += \"    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \\n\";\n  } else if (!polygonOffsetSupported) {\n    // If polygon offset isn't supported push the depth back based on view, however this\n    // causes light leaking at further away views\n    fsSource +=\n      \"    shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015); \\n\";\n  }\n\n  if (isPointLight) {\n    fsSource +=\n      \"    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; \\n\" +\n      \"    float distance = length(directionEC); \\n\" +\n      \"    directionEC = normalize(directionEC); \\n\" +\n      \"    float radius = shadowMap_lightPositionEC.w; \\n\" +\n      \"    // Stop early if the fragment is beyond the point light radius \\n\" +\n      \"    if (distance > radius) \\n\" +\n      \"    { \\n\" +\n      \"        return; \\n\" +\n      \"    } \\n\" +\n      \"    vec3 directionWC  = czm_inverseViewRotation * directionEC; \\n\" +\n      \"    shadowParameters.depth = distance / radius; \\n\" +\n      \"    shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \\n\" +\n      \"    shadowParameters.texCoords = directionWC; \\n\" +\n      \"    float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); \\n\";\n  } else if (isSpotLight) {\n    fsSource +=\n      \"    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \\n\" +\n      \"    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \\n\" +\n      \"    applyNormalOffset(positionEC, normalEC, nDotL); \\n\" +\n      \"    vec4 shadowPosition = shadowMap_matrix * positionEC; \\n\" +\n      \"    // Spot light uses a perspective projection, so perform the perspective divide \\n\" +\n      \"    shadowPosition /= shadowPosition.w; \\n\" +\n      \"    // Stop early if the fragment is not in the shadow bounds \\n\" +\n      \"    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \\n\" +\n      \"    { \\n\" +\n      \"        return; \\n\" +\n      \"    } \\n\" +\n      \"    shadowParameters.texCoords = shadowPosition.xy; \\n\" +\n      \"    shadowParameters.depth = shadowPosition.z; \\n\" +\n      \"    shadowParameters.nDotL = nDotL; \\n\" +\n      \"    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \\n\";\n  } else if (hasCascades) {\n    fsSource +=\n      \"    float maxDepth = shadowMap_cascadeSplits[1].w; \\n\" +\n      \"    // Stop early if the eye depth exceeds the last cascade \\n\" +\n      \"    if (depth > maxDepth) \\n\" +\n      \"    { \\n\" +\n      \"        return; \\n\" +\n      \"    } \\n\" +\n      \"    // Get the cascade based on the eye-space depth \\n\" +\n      \"    vec4 weights = czm_cascadeWeights(depth); \\n\" +\n      \"    // Apply normal offset \\n\" +\n      \"    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \\n\" +\n      \"    applyNormalOffset(positionEC, normalEC, nDotL); \\n\" +\n      \"    // Transform position into the cascade \\n\" +\n      \"    vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \\n\" +\n      \"    // Get visibility \\n\" +\n      \"    shadowParameters.texCoords = shadowPosition.xy; \\n\" +\n      \"    shadowParameters.depth = shadowPosition.z; \\n\" +\n      \"    shadowParameters.nDotL = nDotL; \\n\" +\n      \"    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \\n\" +\n      \"    // Fade out shadows that are far away \\n\" +\n      \"    float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \\n\" +\n      \"    float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \\n\" +\n      \"    visibility = mix(visibility, 1.0, fade); \\n\" +\n      (debugCascadeColors\n        ? \"    // Draw cascade colors for debugging \\n\" +\n          \"    gl_FragColor *= czm_cascadeColor(weights); \\n\"\n        : \"\");\n  } else {\n    fsSource +=\n      \"    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \\n\" +\n      \"    applyNormalOffset(positionEC, normalEC, nDotL); \\n\" +\n      \"    vec4 shadowPosition = shadowMap_matrix * positionEC; \\n\" +\n      \"    // Stop early if the fragment is not in the shadow bounds \\n\" +\n      \"    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \\n\" +\n      \"    { \\n\" +\n      \"        return; \\n\" +\n      \"    } \\n\" +\n      \"    shadowParameters.texCoords = shadowPosition.xy; \\n\" +\n      \"    shadowParameters.depth = shadowPosition.z; \\n\" +\n      \"    shadowParameters.nDotL = nDotL; \\n\" +\n      \"    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \\n\";\n  }\n\n  fsSource += \"    gl_FragColor.rgb *= visibility; \\n\" + \"} \\n\";\n\n  sources.push(fsSource);\n\n  return new ShaderSource({\n    defines: defines,\n    sources: sources,\n  });\n};\nexport default ShadowMapShader;\n"]},"metadata":{},"sourceType":"module"}