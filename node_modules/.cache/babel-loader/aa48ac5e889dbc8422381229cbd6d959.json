{"ast":null,"code":"import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport Intersect from \"./Intersect.js\";\nimport Interval from \"./Interval.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Plane from \"./Plane.js\";\nimport Rectangle from \"./Rectangle.js\";\n/**\n * Creates an instance of an OrientedBoundingBox.\n * An OrientedBoundingBox of some object is a closed and convex cuboid. It can provide a tighter bounding volume than {@link BoundingSphere} or {@link AxisAlignedBoundingBox} in many cases.\n * @alias OrientedBoundingBox\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the box.\n * @param {Matrix3} [halfAxes=Matrix3.ZERO] The three orthogonal half-axes of the bounding box.\n *                                          Equivalently, the transformation matrix, to rotate and scale a 0x0x0\n *                                          cube centered at the origin.\n *\n *\n * @example\n * // Create an OrientedBoundingBox using a transformation matrix, a position where the box will be translated, and a scale.\n * var center = new Cesium.Cartesian3(1.0, 0.0, 0.0);\n * var halfAxes = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(1.0, 3.0, 2.0), new Cesium.Matrix3());\n *\n * var obb = new Cesium.OrientedBoundingBox(center, halfAxes);\n *\n * @see BoundingSphere\n * @see BoundingRectangle\n */\n\nfunction OrientedBoundingBox(center, halfAxes) {\n  /**\n   * The center of the box.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));\n  /**\n   * The transformation matrix, to rotate the box to the right position.\n   * @type {Matrix3}\n   * @default {@link Matrix3.ZERO}\n   */\n\n  this.halfAxes = Matrix3.clone(defaultValue(halfAxes, Matrix3.ZERO));\n}\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\n\n\nOrientedBoundingBox.packedLength = Cartesian3.packedLength + Matrix3.packedLength;\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {OrientedBoundingBox} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\nOrientedBoundingBox.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  Cartesian3.pack(value.center, array, startingIndex);\n  Matrix3.pack(value.halfAxes, array, startingIndex + Cartesian3.packedLength);\n  return array;\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {OrientedBoundingBox} [result] The object into which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n */\n\n\nOrientedBoundingBox.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  Cartesian3.unpack(array, startingIndex, result.center);\n  Matrix3.unpack(array, startingIndex + Cartesian3.packedLength, result.halfAxes);\n  return result;\n};\n\nvar scratchCartesian1 = new Cartesian3();\nvar scratchCartesian2 = new Cartesian3();\nvar scratchCartesian3 = new Cartesian3();\nvar scratchCartesian4 = new Cartesian3();\nvar scratchCartesian5 = new Cartesian3();\nvar scratchCartesian6 = new Cartesian3();\nvar scratchCovarianceResult = new Matrix3();\nvar scratchEigenResult = {\n  unitary: new Matrix3(),\n  diagonal: new Matrix3()\n};\n/**\n * Computes an instance of an OrientedBoundingBox of the given positions.\n * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).\n * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf\n *\n * @param {Cartesian3[]} [positions] List of {@link Cartesian3} points that the bounding box will enclose.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n *\n * @example\n * // Compute an object oriented bounding box enclosing two points.\n * var box = Cesium.OrientedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\n */\n\nOrientedBoundingBox.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.halfAxes = Matrix3.ZERO;\n    result.center = Cartesian3.ZERO;\n    return result;\n  }\n\n  var i;\n  var length = positions.length;\n  var meanPoint = Cartesian3.clone(positions[0], scratchCartesian1);\n\n  for (i = 1; i < length; i++) {\n    Cartesian3.add(meanPoint, positions[i], meanPoint);\n  }\n\n  var invLength = 1.0 / length;\n  Cartesian3.multiplyByScalar(meanPoint, invLength, meanPoint);\n  var exx = 0.0;\n  var exy = 0.0;\n  var exz = 0.0;\n  var eyy = 0.0;\n  var eyz = 0.0;\n  var ezz = 0.0;\n  var p;\n\n  for (i = 0; i < length; i++) {\n    p = Cartesian3.subtract(positions[i], meanPoint, scratchCartesian2);\n    exx += p.x * p.x;\n    exy += p.x * p.y;\n    exz += p.x * p.z;\n    eyy += p.y * p.y;\n    eyz += p.y * p.z;\n    ezz += p.z * p.z;\n  }\n\n  exx *= invLength;\n  exy *= invLength;\n  exz *= invLength;\n  eyy *= invLength;\n  eyz *= invLength;\n  ezz *= invLength;\n  var covarianceMatrix = scratchCovarianceResult;\n  covarianceMatrix[0] = exx;\n  covarianceMatrix[1] = exy;\n  covarianceMatrix[2] = exz;\n  covarianceMatrix[3] = exy;\n  covarianceMatrix[4] = eyy;\n  covarianceMatrix[5] = eyz;\n  covarianceMatrix[6] = exz;\n  covarianceMatrix[7] = eyz;\n  covarianceMatrix[8] = ezz;\n  var eigenDecomposition = Matrix3.computeEigenDecomposition(covarianceMatrix, scratchEigenResult);\n  var rotation = Matrix3.clone(eigenDecomposition.unitary, result.halfAxes);\n  var v1 = Matrix3.getColumn(rotation, 0, scratchCartesian4);\n  var v2 = Matrix3.getColumn(rotation, 1, scratchCartesian5);\n  var v3 = Matrix3.getColumn(rotation, 2, scratchCartesian6);\n  var u1 = -Number.MAX_VALUE;\n  var u2 = -Number.MAX_VALUE;\n  var u3 = -Number.MAX_VALUE;\n  var l1 = Number.MAX_VALUE;\n  var l2 = Number.MAX_VALUE;\n  var l3 = Number.MAX_VALUE;\n\n  for (i = 0; i < length; i++) {\n    p = positions[i];\n    u1 = Math.max(Cartesian3.dot(v1, p), u1);\n    u2 = Math.max(Cartesian3.dot(v2, p), u2);\n    u3 = Math.max(Cartesian3.dot(v3, p), u3);\n    l1 = Math.min(Cartesian3.dot(v1, p), l1);\n    l2 = Math.min(Cartesian3.dot(v2, p), l2);\n    l3 = Math.min(Cartesian3.dot(v3, p), l3);\n  }\n\n  v1 = Cartesian3.multiplyByScalar(v1, 0.5 * (l1 + u1), v1);\n  v2 = Cartesian3.multiplyByScalar(v2, 0.5 * (l2 + u2), v2);\n  v3 = Cartesian3.multiplyByScalar(v3, 0.5 * (l3 + u3), v3);\n  var center = Cartesian3.add(v1, v2, result.center);\n  Cartesian3.add(center, v3, center);\n  var scale = scratchCartesian3;\n  scale.x = u1 - l1;\n  scale.y = u2 - l2;\n  scale.z = u3 - l3;\n  Cartesian3.multiplyByScalar(scale, 0.5, scale);\n  Matrix3.multiplyByScale(result.halfAxes, scale, result.halfAxes);\n  return result;\n};\n\nvar scratchOffset = new Cartesian3();\nvar scratchScale = new Cartesian3();\n\nfunction fromPlaneExtents(planeOrigin, planeXAxis, planeYAxis, planeZAxis, minimumX, maximumX, minimumY, maximumY, minimumZ, maximumZ, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(minimumX) || !defined(maximumX) || !defined(minimumY) || !defined(maximumY) || !defined(minimumZ) || !defined(maximumZ)) {\n    throw new DeveloperError(\"all extents (minimum/maximum X/Y/Z) are required.\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  var halfAxes = result.halfAxes;\n  Matrix3.setColumn(halfAxes, 0, planeXAxis, halfAxes);\n  Matrix3.setColumn(halfAxes, 1, planeYAxis, halfAxes);\n  Matrix3.setColumn(halfAxes, 2, planeZAxis, halfAxes);\n  var centerOffset = scratchOffset;\n  centerOffset.x = (minimumX + maximumX) / 2.0;\n  centerOffset.y = (minimumY + maximumY) / 2.0;\n  centerOffset.z = (minimumZ + maximumZ) / 2.0;\n  var scale = scratchScale;\n  scale.x = (maximumX - minimumX) / 2.0;\n  scale.y = (maximumY - minimumY) / 2.0;\n  scale.z = (maximumZ - minimumZ) / 2.0;\n  var center = result.center;\n  centerOffset = Matrix3.multiplyByVector(halfAxes, centerOffset, centerOffset);\n  Cartesian3.add(planeOrigin, centerOffset, center);\n  Matrix3.multiplyByScale(halfAxes, scale, halfAxes);\n  return result;\n}\n\nvar scratchRectangleCenterCartographic = new Cartographic();\nvar scratchRectangleCenter = new Cartesian3();\nvar scratchPerimeterCartographicNC = new Cartographic();\nvar scratchPerimeterCartographicNW = new Cartographic();\nvar scratchPerimeterCartographicCW = new Cartographic();\nvar scratchPerimeterCartographicSW = new Cartographic();\nvar scratchPerimeterCartographicSC = new Cartographic();\nvar scratchPerimeterCartesianNC = new Cartesian3();\nvar scratchPerimeterCartesianNW = new Cartesian3();\nvar scratchPerimeterCartesianCW = new Cartesian3();\nvar scratchPerimeterCartesianSW = new Cartesian3();\nvar scratchPerimeterCartesianSC = new Cartesian3();\nvar scratchPerimeterProjectedNC = new Cartesian2();\nvar scratchPerimeterProjectedNW = new Cartesian2();\nvar scratchPerimeterProjectedCW = new Cartesian2();\nvar scratchPerimeterProjectedSW = new Cartesian2();\nvar scratchPerimeterProjectedSC = new Cartesian2();\nvar scratchPlaneOrigin = new Cartesian3();\nvar scratchPlaneNormal = new Cartesian3();\nvar scratchPlaneXAxis = new Cartesian3();\nvar scratchHorizonCartesian = new Cartesian3();\nvar scratchHorizonProjected = new Cartesian2();\nvar scratchMaxY = new Cartesian3();\nvar scratchMinY = new Cartesian3();\nvar scratchZ = new Cartesian3();\nvar scratchPlane = new Plane(Cartesian3.UNIT_X, 0.0);\n/**\n * Computes an OrientedBoundingBox that bounds a {@link Rectangle} on the surface of an {@link Ellipsoid}.\n * There are no guarantees about the orientation of the bounding box.\n *\n * @param {Rectangle} rectangle The cartographic rectangle on the surface of the ellipsoid.\n * @param {Number} [minimumHeight=0.0] The minimum height (elevation) within the tile.\n * @param {Number} [maximumHeight=0.0] The maximum height (elevation) within the tile.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle is defined.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.\n *\n * @exception {DeveloperError} rectangle.width must be between 0 and pi.\n * @exception {DeveloperError} rectangle.height must be between 0 and pi.\n * @exception {DeveloperError} ellipsoid must be an ellipsoid of revolution (<code>radii.x == radii.y</code>)\n */\n\nOrientedBoundingBox.fromRectangle = function (rectangle, minimumHeight, maximumHeight, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required\");\n  }\n\n  if (rectangle.width < 0.0 || rectangle.width > CesiumMath.TWO_PI) {\n    throw new DeveloperError(\"Rectangle width must be between 0 and 2*pi\");\n  }\n\n  if (rectangle.height < 0.0 || rectangle.height > CesiumMath.PI) {\n    throw new DeveloperError(\"Rectangle height must be between 0 and pi\");\n  }\n\n  if (defined(ellipsoid) && !CesiumMath.equalsEpsilon(ellipsoid.radii.x, ellipsoid.radii.y, CesiumMath.EPSILON15)) {\n    throw new DeveloperError(\"Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\");\n  } //>>includeEnd('debug');\n\n\n  minimumHeight = defaultValue(minimumHeight, 0.0);\n  maximumHeight = defaultValue(maximumHeight, 0.0);\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  var minX, maxX, minY, maxY, minZ, maxZ, plane;\n\n  if (rectangle.width <= CesiumMath.PI) {\n    // The bounding box will be aligned with the tangent plane at the center of the rectangle.\n    var tangentPointCartographic = Rectangle.center(rectangle, scratchRectangleCenterCartographic);\n    var tangentPoint = ellipsoid.cartographicToCartesian(tangentPointCartographic, scratchRectangleCenter);\n    var tangentPlane = new EllipsoidTangentPlane(tangentPoint, ellipsoid);\n    plane = tangentPlane.plane; // If the rectangle spans the equator, CW is instead aligned with the equator (because it sticks out the farthest at the equator).\n\n    var lonCenter = tangentPointCartographic.longitude;\n    var latCenter = rectangle.south < 0.0 && rectangle.north > 0.0 ? 0.0 : tangentPointCartographic.latitude; // Compute XY extents using the rectangle at maximum height\n\n    var perimeterCartographicNC = Cartographic.fromRadians(lonCenter, rectangle.north, maximumHeight, scratchPerimeterCartographicNC);\n    var perimeterCartographicNW = Cartographic.fromRadians(rectangle.west, rectangle.north, maximumHeight, scratchPerimeterCartographicNW);\n    var perimeterCartographicCW = Cartographic.fromRadians(rectangle.west, latCenter, maximumHeight, scratchPerimeterCartographicCW);\n    var perimeterCartographicSW = Cartographic.fromRadians(rectangle.west, rectangle.south, maximumHeight, scratchPerimeterCartographicSW);\n    var perimeterCartographicSC = Cartographic.fromRadians(lonCenter, rectangle.south, maximumHeight, scratchPerimeterCartographicSC);\n    var perimeterCartesianNC = ellipsoid.cartographicToCartesian(perimeterCartographicNC, scratchPerimeterCartesianNC);\n    var perimeterCartesianNW = ellipsoid.cartographicToCartesian(perimeterCartographicNW, scratchPerimeterCartesianNW);\n    var perimeterCartesianCW = ellipsoid.cartographicToCartesian(perimeterCartographicCW, scratchPerimeterCartesianCW);\n    var perimeterCartesianSW = ellipsoid.cartographicToCartesian(perimeterCartographicSW, scratchPerimeterCartesianSW);\n    var perimeterCartesianSC = ellipsoid.cartographicToCartesian(perimeterCartographicSC, scratchPerimeterCartesianSC);\n    var perimeterProjectedNC = tangentPlane.projectPointToNearestOnPlane(perimeterCartesianNC, scratchPerimeterProjectedNC);\n    var perimeterProjectedNW = tangentPlane.projectPointToNearestOnPlane(perimeterCartesianNW, scratchPerimeterProjectedNW);\n    var perimeterProjectedCW = tangentPlane.projectPointToNearestOnPlane(perimeterCartesianCW, scratchPerimeterProjectedCW);\n    var perimeterProjectedSW = tangentPlane.projectPointToNearestOnPlane(perimeterCartesianSW, scratchPerimeterProjectedSW);\n    var perimeterProjectedSC = tangentPlane.projectPointToNearestOnPlane(perimeterCartesianSC, scratchPerimeterProjectedSC);\n    minX = Math.min(perimeterProjectedNW.x, perimeterProjectedCW.x, perimeterProjectedSW.x);\n    maxX = -minX; // symmetrical\n\n    maxY = Math.max(perimeterProjectedNW.y, perimeterProjectedNC.y);\n    minY = Math.min(perimeterProjectedSW.y, perimeterProjectedSC.y); // Compute minimum Z using the rectangle at minimum height, since it will be deeper than the maximum height\n\n    perimeterCartographicNW.height = perimeterCartographicSW.height = minimumHeight;\n    perimeterCartesianNW = ellipsoid.cartographicToCartesian(perimeterCartographicNW, scratchPerimeterCartesianNW);\n    perimeterCartesianSW = ellipsoid.cartographicToCartesian(perimeterCartographicSW, scratchPerimeterCartesianSW);\n    minZ = Math.min(Plane.getPointDistance(plane, perimeterCartesianNW), Plane.getPointDistance(plane, perimeterCartesianSW));\n    maxZ = maximumHeight; // Since the tangent plane touches the surface at height = 0, this is okay\n\n    return fromPlaneExtents(tangentPlane.origin, tangentPlane.xAxis, tangentPlane.yAxis, tangentPlane.zAxis, minX, maxX, minY, maxY, minZ, maxZ, result);\n  } // Handle the case where rectangle width is greater than PI (wraps around more than half the ellipsoid).\n\n\n  var fullyAboveEquator = rectangle.south > 0.0;\n  var fullyBelowEquator = rectangle.north < 0.0;\n  var latitudeNearestToEquator = fullyAboveEquator ? rectangle.south : fullyBelowEquator ? rectangle.north : 0.0;\n  var centerLongitude = Rectangle.center(rectangle, scratchRectangleCenterCartographic).longitude; // Plane is located at the rectangle's center longitude and the rectangle's latitude that is closest to the equator. It rotates around the Z axis.\n  // This results in a better fit than the obb approach for smaller rectangles, which orients with the rectangle's center normal.\n\n  var planeOrigin = Cartesian3.fromRadians(centerLongitude, latitudeNearestToEquator, maximumHeight, ellipsoid, scratchPlaneOrigin);\n  planeOrigin.z = 0.0; // center the plane on the equator to simpify plane normal calculation\n\n  var isPole = Math.abs(planeOrigin.x) < CesiumMath.EPSILON10 && Math.abs(planeOrigin.y) < CesiumMath.EPSILON10;\n  var planeNormal = !isPole ? Cartesian3.normalize(planeOrigin, scratchPlaneNormal) : Cartesian3.UNIT_X;\n  var planeYAxis = Cartesian3.UNIT_Z;\n  var planeXAxis = Cartesian3.cross(planeNormal, planeYAxis, scratchPlaneXAxis);\n  plane = Plane.fromPointNormal(planeOrigin, planeNormal, scratchPlane); // Get the horizon point relative to the center. This will be the farthest extent in the plane's X dimension.\n\n  var horizonCartesian = Cartesian3.fromRadians(centerLongitude + CesiumMath.PI_OVER_TWO, latitudeNearestToEquator, maximumHeight, ellipsoid, scratchHorizonCartesian);\n  maxX = Cartesian3.dot(Plane.projectPointOntoPlane(plane, horizonCartesian, scratchHorizonProjected), planeXAxis);\n  minX = -maxX; // symmetrical\n  // Get the min and max Y, using the height that will give the largest extent\n\n  maxY = Cartesian3.fromRadians(0.0, rectangle.north, fullyBelowEquator ? minimumHeight : maximumHeight, ellipsoid, scratchMaxY).z;\n  minY = Cartesian3.fromRadians(0.0, rectangle.south, fullyAboveEquator ? minimumHeight : maximumHeight, ellipsoid, scratchMinY).z;\n  var farZ = Cartesian3.fromRadians(rectangle.east, latitudeNearestToEquator, maximumHeight, ellipsoid, scratchZ);\n  minZ = Plane.getPointDistance(plane, farZ);\n  maxZ = 0.0; // plane origin starts at maxZ already\n  // min and max are local to the plane axes\n\n  return fromPlaneExtents(planeOrigin, planeXAxis, planeYAxis, planeNormal, minX, maxX, minY, maxY, minZ, maxZ, result);\n};\n/**\n * Duplicates a OrientedBoundingBox instance.\n *\n * @param {OrientedBoundingBox} box The bounding box to duplicate.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\n */\n\n\nOrientedBoundingBox.clone = function (box, result) {\n  if (!defined(box)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new OrientedBoundingBox(box.center, box.halfAxes);\n  }\n\n  Cartesian3.clone(box.center, result.center);\n  Matrix3.clone(box.halfAxes, result.halfAxes);\n  return result;\n};\n/**\n * Determines which side of a plane the oriented bounding box is located.\n *\n * @param {OrientedBoundingBox} box The oriented bounding box to test.\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\n\n\nOrientedBoundingBox.intersectPlane = function (box, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n\n  if (!defined(plane)) {\n    throw new DeveloperError(\"plane is required.\");\n  } //>>includeEnd('debug');\n\n\n  var center = box.center;\n  var normal = plane.normal;\n  var halfAxes = box.halfAxes;\n  var normalX = normal.x,\n      normalY = normal.y,\n      normalZ = normal.z; // plane is used as if it is its normal; the first three components are assumed to be normalized\n\n  var radEffective = Math.abs(normalX * halfAxes[Matrix3.COLUMN0ROW0] + normalY * halfAxes[Matrix3.COLUMN0ROW1] + normalZ * halfAxes[Matrix3.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[Matrix3.COLUMN1ROW0] + normalY * halfAxes[Matrix3.COLUMN1ROW1] + normalZ * halfAxes[Matrix3.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[Matrix3.COLUMN2ROW0] + normalY * halfAxes[Matrix3.COLUMN2ROW1] + normalZ * halfAxes[Matrix3.COLUMN2ROW2]);\n  var distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;\n\n  if (distanceToPlane <= -radEffective) {\n    // The entire box is on the negative side of the plane normal\n    return Intersect.OUTSIDE;\n  } else if (distanceToPlane >= radEffective) {\n    // The entire box is on the positive side of the plane normal\n    return Intersect.INSIDE;\n  }\n\n  return Intersect.INTERSECTING;\n};\n\nvar scratchCartesianU = new Cartesian3();\nvar scratchCartesianV = new Cartesian3();\nvar scratchCartesianW = new Cartesian3();\nvar scratchPPrime = new Cartesian3();\n/**\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\n *\n * @param {OrientedBoundingBox} box The box.\n * @param {Cartesian3} cartesian The point\n * @returns {Number} The estimated distance squared from the bounding sphere to the point.\n *\n * @example\n * // Sort bounding boxes from back to front\n * boxes.sort(function(a, b) {\n *     return Cesium.OrientedBoundingBox.distanceSquaredTo(b, camera.positionWC) - Cesium.OrientedBoundingBox.distanceSquaredTo(a, camera.positionWC);\n * });\n */\n\nOrientedBoundingBox.distanceSquaredTo = function (box, cartesian) {\n  // See Geometric Tools for Computer Graphics 10.4.2\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  } //>>includeEnd('debug');\n\n\n  var offset = Cartesian3.subtract(cartesian, box.center, scratchOffset);\n  var halfAxes = box.halfAxes;\n  var u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\n  var v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\n  var w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\n  var uHalf = Cartesian3.magnitude(u);\n  var vHalf = Cartesian3.magnitude(v);\n  var wHalf = Cartesian3.magnitude(w);\n  Cartesian3.normalize(u, u);\n  Cartesian3.normalize(v, v);\n  Cartesian3.normalize(w, w);\n  var pPrime = scratchPPrime;\n  pPrime.x = Cartesian3.dot(offset, u);\n  pPrime.y = Cartesian3.dot(offset, v);\n  pPrime.z = Cartesian3.dot(offset, w);\n  var distanceSquared = 0.0;\n  var d;\n\n  if (pPrime.x < -uHalf) {\n    d = pPrime.x + uHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.x > uHalf) {\n    d = pPrime.x - uHalf;\n    distanceSquared += d * d;\n  }\n\n  if (pPrime.y < -vHalf) {\n    d = pPrime.y + vHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.y > vHalf) {\n    d = pPrime.y - vHalf;\n    distanceSquared += d * d;\n  }\n\n  if (pPrime.z < -wHalf) {\n    d = pPrime.z + wHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.z > wHalf) {\n    d = pPrime.z - wHalf;\n    distanceSquared += d * d;\n  }\n\n  return distanceSquared;\n};\n\nvar scratchCorner = new Cartesian3();\nvar scratchToCenter = new Cartesian3();\n/**\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding box.\n *\n * @param {OrientedBoundingBox} box The bounding box to calculate the distance to.\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\n */\n\nOrientedBoundingBox.computePlaneDistances = function (box, position, direction, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(result)) {\n    result = new Interval();\n  }\n\n  var minDist = Number.POSITIVE_INFINITY;\n  var maxDist = Number.NEGATIVE_INFINITY;\n  var center = box.center;\n  var halfAxes = box.halfAxes;\n  var u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\n  var v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\n  var w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW); // project first corner\n\n  var corner = Cartesian3.add(u, v, scratchCorner);\n  Cartesian3.add(corner, w, corner);\n  Cartesian3.add(corner, center, corner);\n  var toCenter = Cartesian3.subtract(corner, position, scratchToCenter);\n  var mag = Cartesian3.dot(direction, toCenter);\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist); // project second corner\n\n  Cartesian3.add(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist); // project third corner\n\n  Cartesian3.add(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist); // project fourth corner\n\n  Cartesian3.add(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist); // project fifth corner\n\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist); // project sixth corner\n\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist); // project seventh corner\n\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist); // project eighth corner\n\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n  result.start = minDist;\n  result.stop = maxDist;\n  return result;\n};\n\nvar scratchBoundingSphere = new BoundingSphere();\n/**\n * Determines whether or not a bounding box is hidden from view by the occluder.\n *\n * @param {OrientedBoundingBox} box The bounding box surrounding the occludee object.\n * @param {Occluder} occluder The occluder.\n * @returns {Boolean} <code>true</code> if the box is not visible; otherwise <code>false</code>.\n */\n\nOrientedBoundingBox.isOccluded = function (box, occluder) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n\n  if (!defined(occluder)) {\n    throw new DeveloperError(\"occluder is required.\");\n  } //>>includeEnd('debug');\n\n\n  var sphere = BoundingSphere.fromOrientedBoundingBox(box, scratchBoundingSphere);\n  return !occluder.isBoundingSphereVisible(sphere);\n};\n/**\n * Determines which side of a plane the oriented bounding box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\n\n\nOrientedBoundingBox.prototype.intersectPlane = function (plane) {\n  return OrientedBoundingBox.intersectPlane(this, plane);\n};\n/**\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\n *\n * @param {Cartesian3} cartesian The point\n * @returns {Number} The estimated distance squared from the bounding sphere to the point.\n *\n * @example\n * // Sort bounding boxes from back to front\n * boxes.sort(function(a, b) {\n *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\n * });\n */\n\n\nOrientedBoundingBox.prototype.distanceSquaredTo = function (cartesian) {\n  return OrientedBoundingBox.distanceSquaredTo(this, cartesian);\n};\n/**\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding box.\n *\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\n */\n\n\nOrientedBoundingBox.prototype.computePlaneDistances = function (position, direction, result) {\n  return OrientedBoundingBox.computePlaneDistances(this, position, direction, result);\n};\n/**\n * Determines whether or not a bounding box is hidden from view by the occluder.\n *\n * @param {Occluder} occluder The occluder.\n * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n */\n\n\nOrientedBoundingBox.prototype.isOccluded = function (occluder) {\n  return OrientedBoundingBox.isOccluded(this, occluder);\n};\n/**\n * Compares the provided OrientedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrientedBoundingBox} left The first OrientedBoundingBox.\n * @param {OrientedBoundingBox} right The second OrientedBoundingBox.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\n\n\nOrientedBoundingBox.equals = function (left, right) {\n  return left === right || defined(left) && defined(right) && Cartesian3.equals(left.center, right.center) && Matrix3.equals(left.halfAxes, right.halfAxes);\n};\n/**\n * Duplicates this OrientedBoundingBox instance.\n *\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n */\n\n\nOrientedBoundingBox.prototype.clone = function (result) {\n  return OrientedBoundingBox.clone(this, result);\n};\n/**\n * Compares this OrientedBoundingBox against the provided OrientedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrientedBoundingBox} [right] The right hand side OrientedBoundingBox.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\n\n\nOrientedBoundingBox.prototype.equals = function (right) {\n  return OrientedBoundingBox.equals(this, right);\n};\n\nexport default OrientedBoundingBox;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/OrientedBoundingBox.js"],"names":["BoundingSphere","Cartesian2","Cartesian3","Cartographic","Check","defaultValue","defined","DeveloperError","Ellipsoid","EllipsoidTangentPlane","Intersect","Interval","CesiumMath","Matrix3","Plane","Rectangle","OrientedBoundingBox","center","halfAxes","clone","ZERO","packedLength","pack","value","array","startingIndex","typeOf","object","unpack","result","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchCartesian4","scratchCartesian5","scratchCartesian6","scratchCovarianceResult","scratchEigenResult","unitary","diagonal","fromPoints","positions","length","i","meanPoint","add","invLength","multiplyByScalar","exx","exy","exz","eyy","eyz","ezz","p","subtract","x","y","z","covarianceMatrix","eigenDecomposition","computeEigenDecomposition","rotation","v1","getColumn","v2","v3","u1","Number","MAX_VALUE","u2","u3","l1","l2","l3","Math","max","dot","min","scale","multiplyByScale","scratchOffset","scratchScale","fromPlaneExtents","planeOrigin","planeXAxis","planeYAxis","planeZAxis","minimumX","maximumX","minimumY","maximumY","minimumZ","maximumZ","setColumn","centerOffset","multiplyByVector","scratchRectangleCenterCartographic","scratchRectangleCenter","scratchPerimeterCartographicNC","scratchPerimeterCartographicNW","scratchPerimeterCartographicCW","scratchPerimeterCartographicSW","scratchPerimeterCartographicSC","scratchPerimeterCartesianNC","scratchPerimeterCartesianNW","scratchPerimeterCartesianCW","scratchPerimeterCartesianSW","scratchPerimeterCartesianSC","scratchPerimeterProjectedNC","scratchPerimeterProjectedNW","scratchPerimeterProjectedCW","scratchPerimeterProjectedSW","scratchPerimeterProjectedSC","scratchPlaneOrigin","scratchPlaneNormal","scratchPlaneXAxis","scratchHorizonCartesian","scratchHorizonProjected","scratchMaxY","scratchMinY","scratchZ","scratchPlane","UNIT_X","fromRectangle","rectangle","minimumHeight","maximumHeight","ellipsoid","width","TWO_PI","height","PI","equalsEpsilon","radii","EPSILON15","WGS84","minX","maxX","minY","maxY","minZ","maxZ","plane","tangentPointCartographic","tangentPoint","cartographicToCartesian","tangentPlane","lonCenter","longitude","latCenter","south","north","latitude","perimeterCartographicNC","fromRadians","perimeterCartographicNW","west","perimeterCartographicCW","perimeterCartographicSW","perimeterCartographicSC","perimeterCartesianNC","perimeterCartesianNW","perimeterCartesianCW","perimeterCartesianSW","perimeterCartesianSC","perimeterProjectedNC","projectPointToNearestOnPlane","perimeterProjectedNW","perimeterProjectedCW","perimeterProjectedSW","perimeterProjectedSC","getPointDistance","origin","xAxis","yAxis","zAxis","fullyAboveEquator","fullyBelowEquator","latitudeNearestToEquator","centerLongitude","isPole","abs","EPSILON10","planeNormal","normalize","UNIT_Z","cross","fromPointNormal","horizonCartesian","PI_OVER_TWO","projectPointOntoPlane","farZ","east","box","undefined","intersectPlane","normal","normalX","normalY","normalZ","radEffective","COLUMN0ROW0","COLUMN0ROW1","COLUMN0ROW2","COLUMN1ROW0","COLUMN1ROW1","COLUMN1ROW2","COLUMN2ROW0","COLUMN2ROW1","COLUMN2ROW2","distanceToPlane","distance","OUTSIDE","INSIDE","INTERSECTING","scratchCartesianU","scratchCartesianV","scratchCartesianW","scratchPPrime","distanceSquaredTo","cartesian","offset","u","v","w","uHalf","magnitude","vHalf","wHalf","pPrime","distanceSquared","d","scratchCorner","scratchToCenter","computePlaneDistances","position","direction","minDist","POSITIVE_INFINITY","maxDist","NEGATIVE_INFINITY","corner","toCenter","mag","start","stop","scratchBoundingSphere","isOccluded","occluder","sphere","fromOrientedBoundingBox","isBoundingSphereVisible","prototype","equals","left","right"],"mappings":"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","sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport Intersect from \"./Intersect.js\";\nimport Interval from \"./Interval.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Plane from \"./Plane.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * Creates an instance of an OrientedBoundingBox.\n * An OrientedBoundingBox of some object is a closed and convex cuboid. It can provide a tighter bounding volume than {@link BoundingSphere} or {@link AxisAlignedBoundingBox} in many cases.\n * @alias OrientedBoundingBox\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the box.\n * @param {Matrix3} [halfAxes=Matrix3.ZERO] The three orthogonal half-axes of the bounding box.\n *                                          Equivalently, the transformation matrix, to rotate and scale a 0x0x0\n *                                          cube centered at the origin.\n *\n *\n * @example\n * // Create an OrientedBoundingBox using a transformation matrix, a position where the box will be translated, and a scale.\n * var center = new Cesium.Cartesian3(1.0, 0.0, 0.0);\n * var halfAxes = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(1.0, 3.0, 2.0), new Cesium.Matrix3());\n *\n * var obb = new Cesium.OrientedBoundingBox(center, halfAxes);\n *\n * @see BoundingSphere\n * @see BoundingRectangle\n */\nfunction OrientedBoundingBox(center, halfAxes) {\n  /**\n   * The center of the box.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));\n  /**\n   * The transformation matrix, to rotate the box to the right position.\n   * @type {Matrix3}\n   * @default {@link Matrix3.ZERO}\n   */\n  this.halfAxes = Matrix3.clone(defaultValue(halfAxes, Matrix3.ZERO));\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nOrientedBoundingBox.packedLength =\n  Cartesian3.packedLength + Matrix3.packedLength;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {OrientedBoundingBox} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nOrientedBoundingBox.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value.center, array, startingIndex);\n  Matrix3.pack(value.halfAxes, array, startingIndex + Cartesian3.packedLength);\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {OrientedBoundingBox} [result] The object into which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n */\nOrientedBoundingBox.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  Cartesian3.unpack(array, startingIndex, result.center);\n  Matrix3.unpack(\n    array,\n    startingIndex + Cartesian3.packedLength,\n    result.halfAxes\n  );\n  return result;\n};\n\nvar scratchCartesian1 = new Cartesian3();\nvar scratchCartesian2 = new Cartesian3();\nvar scratchCartesian3 = new Cartesian3();\nvar scratchCartesian4 = new Cartesian3();\nvar scratchCartesian5 = new Cartesian3();\nvar scratchCartesian6 = new Cartesian3();\nvar scratchCovarianceResult = new Matrix3();\nvar scratchEigenResult = {\n  unitary: new Matrix3(),\n  diagonal: new Matrix3(),\n};\n\n/**\n * Computes an instance of an OrientedBoundingBox of the given positions.\n * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).\n * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf\n *\n * @param {Cartesian3[]} [positions] List of {@link Cartesian3} points that the bounding box will enclose.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n *\n * @example\n * // Compute an object oriented bounding box enclosing two points.\n * var box = Cesium.OrientedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\n */\nOrientedBoundingBox.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.halfAxes = Matrix3.ZERO;\n    result.center = Cartesian3.ZERO;\n    return result;\n  }\n\n  var i;\n  var length = positions.length;\n\n  var meanPoint = Cartesian3.clone(positions[0], scratchCartesian1);\n  for (i = 1; i < length; i++) {\n    Cartesian3.add(meanPoint, positions[i], meanPoint);\n  }\n  var invLength = 1.0 / length;\n  Cartesian3.multiplyByScalar(meanPoint, invLength, meanPoint);\n\n  var exx = 0.0;\n  var exy = 0.0;\n  var exz = 0.0;\n  var eyy = 0.0;\n  var eyz = 0.0;\n  var ezz = 0.0;\n  var p;\n\n  for (i = 0; i < length; i++) {\n    p = Cartesian3.subtract(positions[i], meanPoint, scratchCartesian2);\n    exx += p.x * p.x;\n    exy += p.x * p.y;\n    exz += p.x * p.z;\n    eyy += p.y * p.y;\n    eyz += p.y * p.z;\n    ezz += p.z * p.z;\n  }\n\n  exx *= invLength;\n  exy *= invLength;\n  exz *= invLength;\n  eyy *= invLength;\n  eyz *= invLength;\n  ezz *= invLength;\n\n  var covarianceMatrix = scratchCovarianceResult;\n  covarianceMatrix[0] = exx;\n  covarianceMatrix[1] = exy;\n  covarianceMatrix[2] = exz;\n  covarianceMatrix[3] = exy;\n  covarianceMatrix[4] = eyy;\n  covarianceMatrix[5] = eyz;\n  covarianceMatrix[6] = exz;\n  covarianceMatrix[7] = eyz;\n  covarianceMatrix[8] = ezz;\n\n  var eigenDecomposition = Matrix3.computeEigenDecomposition(\n    covarianceMatrix,\n    scratchEigenResult\n  );\n  var rotation = Matrix3.clone(eigenDecomposition.unitary, result.halfAxes);\n\n  var v1 = Matrix3.getColumn(rotation, 0, scratchCartesian4);\n  var v2 = Matrix3.getColumn(rotation, 1, scratchCartesian5);\n  var v3 = Matrix3.getColumn(rotation, 2, scratchCartesian6);\n\n  var u1 = -Number.MAX_VALUE;\n  var u2 = -Number.MAX_VALUE;\n  var u3 = -Number.MAX_VALUE;\n  var l1 = Number.MAX_VALUE;\n  var l2 = Number.MAX_VALUE;\n  var l3 = Number.MAX_VALUE;\n\n  for (i = 0; i < length; i++) {\n    p = positions[i];\n    u1 = Math.max(Cartesian3.dot(v1, p), u1);\n    u2 = Math.max(Cartesian3.dot(v2, p), u2);\n    u3 = Math.max(Cartesian3.dot(v3, p), u3);\n\n    l1 = Math.min(Cartesian3.dot(v1, p), l1);\n    l2 = Math.min(Cartesian3.dot(v2, p), l2);\n    l3 = Math.min(Cartesian3.dot(v3, p), l3);\n  }\n\n  v1 = Cartesian3.multiplyByScalar(v1, 0.5 * (l1 + u1), v1);\n  v2 = Cartesian3.multiplyByScalar(v2, 0.5 * (l2 + u2), v2);\n  v3 = Cartesian3.multiplyByScalar(v3, 0.5 * (l3 + u3), v3);\n\n  var center = Cartesian3.add(v1, v2, result.center);\n  Cartesian3.add(center, v3, center);\n\n  var scale = scratchCartesian3;\n  scale.x = u1 - l1;\n  scale.y = u2 - l2;\n  scale.z = u3 - l3;\n  Cartesian3.multiplyByScalar(scale, 0.5, scale);\n  Matrix3.multiplyByScale(result.halfAxes, scale, result.halfAxes);\n\n  return result;\n};\n\nvar scratchOffset = new Cartesian3();\nvar scratchScale = new Cartesian3();\nfunction fromPlaneExtents(\n  planeOrigin,\n  planeXAxis,\n  planeYAxis,\n  planeZAxis,\n  minimumX,\n  maximumX,\n  minimumY,\n  maximumY,\n  minimumZ,\n  maximumZ,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(minimumX) ||\n    !defined(maximumX) ||\n    !defined(minimumY) ||\n    !defined(maximumY) ||\n    !defined(minimumZ) ||\n    !defined(maximumZ)\n  ) {\n    throw new DeveloperError(\n      \"all extents (minimum/maximum X/Y/Z) are required.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  var halfAxes = result.halfAxes;\n  Matrix3.setColumn(halfAxes, 0, planeXAxis, halfAxes);\n  Matrix3.setColumn(halfAxes, 1, planeYAxis, halfAxes);\n  Matrix3.setColumn(halfAxes, 2, planeZAxis, halfAxes);\n\n  var centerOffset = scratchOffset;\n  centerOffset.x = (minimumX + maximumX) / 2.0;\n  centerOffset.y = (minimumY + maximumY) / 2.0;\n  centerOffset.z = (minimumZ + maximumZ) / 2.0;\n\n  var scale = scratchScale;\n  scale.x = (maximumX - minimumX) / 2.0;\n  scale.y = (maximumY - minimumY) / 2.0;\n  scale.z = (maximumZ - minimumZ) / 2.0;\n\n  var center = result.center;\n  centerOffset = Matrix3.multiplyByVector(halfAxes, centerOffset, centerOffset);\n  Cartesian3.add(planeOrigin, centerOffset, center);\n  Matrix3.multiplyByScale(halfAxes, scale, halfAxes);\n\n  return result;\n}\n\nvar scratchRectangleCenterCartographic = new Cartographic();\nvar scratchRectangleCenter = new Cartesian3();\nvar scratchPerimeterCartographicNC = new Cartographic();\nvar scratchPerimeterCartographicNW = new Cartographic();\nvar scratchPerimeterCartographicCW = new Cartographic();\nvar scratchPerimeterCartographicSW = new Cartographic();\nvar scratchPerimeterCartographicSC = new Cartographic();\nvar scratchPerimeterCartesianNC = new Cartesian3();\nvar scratchPerimeterCartesianNW = new Cartesian3();\nvar scratchPerimeterCartesianCW = new Cartesian3();\nvar scratchPerimeterCartesianSW = new Cartesian3();\nvar scratchPerimeterCartesianSC = new Cartesian3();\nvar scratchPerimeterProjectedNC = new Cartesian2();\nvar scratchPerimeterProjectedNW = new Cartesian2();\nvar scratchPerimeterProjectedCW = new Cartesian2();\nvar scratchPerimeterProjectedSW = new Cartesian2();\nvar scratchPerimeterProjectedSC = new Cartesian2();\n\nvar scratchPlaneOrigin = new Cartesian3();\nvar scratchPlaneNormal = new Cartesian3();\nvar scratchPlaneXAxis = new Cartesian3();\nvar scratchHorizonCartesian = new Cartesian3();\nvar scratchHorizonProjected = new Cartesian2();\nvar scratchMaxY = new Cartesian3();\nvar scratchMinY = new Cartesian3();\nvar scratchZ = new Cartesian3();\nvar scratchPlane = new Plane(Cartesian3.UNIT_X, 0.0);\n\n/**\n * Computes an OrientedBoundingBox that bounds a {@link Rectangle} on the surface of an {@link Ellipsoid}.\n * There are no guarantees about the orientation of the bounding box.\n *\n * @param {Rectangle} rectangle The cartographic rectangle on the surface of the ellipsoid.\n * @param {Number} [minimumHeight=0.0] The minimum height (elevation) within the tile.\n * @param {Number} [maximumHeight=0.0] The maximum height (elevation) within the tile.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle is defined.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.\n *\n * @exception {DeveloperError} rectangle.width must be between 0 and pi.\n * @exception {DeveloperError} rectangle.height must be between 0 and pi.\n * @exception {DeveloperError} ellipsoid must be an ellipsoid of revolution (<code>radii.x == radii.y</code>)\n */\nOrientedBoundingBox.fromRectangle = function (\n  rectangle,\n  minimumHeight,\n  maximumHeight,\n  ellipsoid,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required\");\n  }\n  if (rectangle.width < 0.0 || rectangle.width > CesiumMath.TWO_PI) {\n    throw new DeveloperError(\"Rectangle width must be between 0 and 2*pi\");\n  }\n  if (rectangle.height < 0.0 || rectangle.height > CesiumMath.PI) {\n    throw new DeveloperError(\"Rectangle height must be between 0 and pi\");\n  }\n  if (\n    defined(ellipsoid) &&\n    !CesiumMath.equalsEpsilon(\n      ellipsoid.radii.x,\n      ellipsoid.radii.y,\n      CesiumMath.EPSILON15\n    )\n  ) {\n    throw new DeveloperError(\n      \"Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  minimumHeight = defaultValue(minimumHeight, 0.0);\n  maximumHeight = defaultValue(maximumHeight, 0.0);\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  var minX, maxX, minY, maxY, minZ, maxZ, plane;\n\n  if (rectangle.width <= CesiumMath.PI) {\n    // The bounding box will be aligned with the tangent plane at the center of the rectangle.\n    var tangentPointCartographic = Rectangle.center(\n      rectangle,\n      scratchRectangleCenterCartographic\n    );\n    var tangentPoint = ellipsoid.cartographicToCartesian(\n      tangentPointCartographic,\n      scratchRectangleCenter\n    );\n    var tangentPlane = new EllipsoidTangentPlane(tangentPoint, ellipsoid);\n    plane = tangentPlane.plane;\n\n    // If the rectangle spans the equator, CW is instead aligned with the equator (because it sticks out the farthest at the equator).\n    var lonCenter = tangentPointCartographic.longitude;\n    var latCenter =\n      rectangle.south < 0.0 && rectangle.north > 0.0\n        ? 0.0\n        : tangentPointCartographic.latitude;\n\n    // Compute XY extents using the rectangle at maximum height\n    var perimeterCartographicNC = Cartographic.fromRadians(\n      lonCenter,\n      rectangle.north,\n      maximumHeight,\n      scratchPerimeterCartographicNC\n    );\n    var perimeterCartographicNW = Cartographic.fromRadians(\n      rectangle.west,\n      rectangle.north,\n      maximumHeight,\n      scratchPerimeterCartographicNW\n    );\n    var perimeterCartographicCW = Cartographic.fromRadians(\n      rectangle.west,\n      latCenter,\n      maximumHeight,\n      scratchPerimeterCartographicCW\n    );\n    var perimeterCartographicSW = Cartographic.fromRadians(\n      rectangle.west,\n      rectangle.south,\n      maximumHeight,\n      scratchPerimeterCartographicSW\n    );\n    var perimeterCartographicSC = Cartographic.fromRadians(\n      lonCenter,\n      rectangle.south,\n      maximumHeight,\n      scratchPerimeterCartographicSC\n    );\n\n    var perimeterCartesianNC = ellipsoid.cartographicToCartesian(\n      perimeterCartographicNC,\n      scratchPerimeterCartesianNC\n    );\n    var perimeterCartesianNW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicNW,\n      scratchPerimeterCartesianNW\n    );\n    var perimeterCartesianCW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicCW,\n      scratchPerimeterCartesianCW\n    );\n    var perimeterCartesianSW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicSW,\n      scratchPerimeterCartesianSW\n    );\n    var perimeterCartesianSC = ellipsoid.cartographicToCartesian(\n      perimeterCartographicSC,\n      scratchPerimeterCartesianSC\n    );\n\n    var perimeterProjectedNC = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianNC,\n      scratchPerimeterProjectedNC\n    );\n    var perimeterProjectedNW = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianNW,\n      scratchPerimeterProjectedNW\n    );\n    var perimeterProjectedCW = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianCW,\n      scratchPerimeterProjectedCW\n    );\n    var perimeterProjectedSW = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianSW,\n      scratchPerimeterProjectedSW\n    );\n    var perimeterProjectedSC = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianSC,\n      scratchPerimeterProjectedSC\n    );\n\n    minX = Math.min(\n      perimeterProjectedNW.x,\n      perimeterProjectedCW.x,\n      perimeterProjectedSW.x\n    );\n    maxX = -minX; // symmetrical\n\n    maxY = Math.max(perimeterProjectedNW.y, perimeterProjectedNC.y);\n    minY = Math.min(perimeterProjectedSW.y, perimeterProjectedSC.y);\n\n    // Compute minimum Z using the rectangle at minimum height, since it will be deeper than the maximum height\n    perimeterCartographicNW.height = perimeterCartographicSW.height = minimumHeight;\n    perimeterCartesianNW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicNW,\n      scratchPerimeterCartesianNW\n    );\n    perimeterCartesianSW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicSW,\n      scratchPerimeterCartesianSW\n    );\n\n    minZ = Math.min(\n      Plane.getPointDistance(plane, perimeterCartesianNW),\n      Plane.getPointDistance(plane, perimeterCartesianSW)\n    );\n    maxZ = maximumHeight; // Since the tangent plane touches the surface at height = 0, this is okay\n\n    return fromPlaneExtents(\n      tangentPlane.origin,\n      tangentPlane.xAxis,\n      tangentPlane.yAxis,\n      tangentPlane.zAxis,\n      minX,\n      maxX,\n      minY,\n      maxY,\n      minZ,\n      maxZ,\n      result\n    );\n  }\n\n  // Handle the case where rectangle width is greater than PI (wraps around more than half the ellipsoid).\n  var fullyAboveEquator = rectangle.south > 0.0;\n  var fullyBelowEquator = rectangle.north < 0.0;\n  var latitudeNearestToEquator = fullyAboveEquator\n    ? rectangle.south\n    : fullyBelowEquator\n    ? rectangle.north\n    : 0.0;\n  var centerLongitude = Rectangle.center(\n    rectangle,\n    scratchRectangleCenterCartographic\n  ).longitude;\n\n  // Plane is located at the rectangle's center longitude and the rectangle's latitude that is closest to the equator. It rotates around the Z axis.\n  // This results in a better fit than the obb approach for smaller rectangles, which orients with the rectangle's center normal.\n  var planeOrigin = Cartesian3.fromRadians(\n    centerLongitude,\n    latitudeNearestToEquator,\n    maximumHeight,\n    ellipsoid,\n    scratchPlaneOrigin\n  );\n  planeOrigin.z = 0.0; // center the plane on the equator to simpify plane normal calculation\n  var isPole =\n    Math.abs(planeOrigin.x) < CesiumMath.EPSILON10 &&\n    Math.abs(planeOrigin.y) < CesiumMath.EPSILON10;\n  var planeNormal = !isPole\n    ? Cartesian3.normalize(planeOrigin, scratchPlaneNormal)\n    : Cartesian3.UNIT_X;\n  var planeYAxis = Cartesian3.UNIT_Z;\n  var planeXAxis = Cartesian3.cross(planeNormal, planeYAxis, scratchPlaneXAxis);\n  plane = Plane.fromPointNormal(planeOrigin, planeNormal, scratchPlane);\n\n  // Get the horizon point relative to the center. This will be the farthest extent in the plane's X dimension.\n  var horizonCartesian = Cartesian3.fromRadians(\n    centerLongitude + CesiumMath.PI_OVER_TWO,\n    latitudeNearestToEquator,\n    maximumHeight,\n    ellipsoid,\n    scratchHorizonCartesian\n  );\n  maxX = Cartesian3.dot(\n    Plane.projectPointOntoPlane(\n      plane,\n      horizonCartesian,\n      scratchHorizonProjected\n    ),\n    planeXAxis\n  );\n  minX = -maxX; // symmetrical\n\n  // Get the min and max Y, using the height that will give the largest extent\n  maxY = Cartesian3.fromRadians(\n    0.0,\n    rectangle.north,\n    fullyBelowEquator ? minimumHeight : maximumHeight,\n    ellipsoid,\n    scratchMaxY\n  ).z;\n  minY = Cartesian3.fromRadians(\n    0.0,\n    rectangle.south,\n    fullyAboveEquator ? minimumHeight : maximumHeight,\n    ellipsoid,\n    scratchMinY\n  ).z;\n\n  var farZ = Cartesian3.fromRadians(\n    rectangle.east,\n    latitudeNearestToEquator,\n    maximumHeight,\n    ellipsoid,\n    scratchZ\n  );\n  minZ = Plane.getPointDistance(plane, farZ);\n  maxZ = 0.0; // plane origin starts at maxZ already\n\n  // min and max are local to the plane axes\n  return fromPlaneExtents(\n    planeOrigin,\n    planeXAxis,\n    planeYAxis,\n    planeNormal,\n    minX,\n    maxX,\n    minY,\n    maxY,\n    minZ,\n    maxZ,\n    result\n  );\n};\n\n/**\n * Duplicates a OrientedBoundingBox instance.\n *\n * @param {OrientedBoundingBox} box The bounding box to duplicate.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\n */\nOrientedBoundingBox.clone = function (box, result) {\n  if (!defined(box)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new OrientedBoundingBox(box.center, box.halfAxes);\n  }\n\n  Cartesian3.clone(box.center, result.center);\n  Matrix3.clone(box.halfAxes, result.halfAxes);\n\n  return result;\n};\n\n/**\n * Determines which side of a plane the oriented bounding box is located.\n *\n * @param {OrientedBoundingBox} box The oriented bounding box to test.\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nOrientedBoundingBox.intersectPlane = function (box, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n\n  if (!defined(plane)) {\n    throw new DeveloperError(\"plane is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var center = box.center;\n  var normal = plane.normal;\n  var halfAxes = box.halfAxes;\n  var normalX = normal.x,\n    normalY = normal.y,\n    normalZ = normal.z;\n  // plane is used as if it is its normal; the first three components are assumed to be normalized\n  var radEffective =\n    Math.abs(\n      normalX * halfAxes[Matrix3.COLUMN0ROW0] +\n        normalY * halfAxes[Matrix3.COLUMN0ROW1] +\n        normalZ * halfAxes[Matrix3.COLUMN0ROW2]\n    ) +\n    Math.abs(\n      normalX * halfAxes[Matrix3.COLUMN1ROW0] +\n        normalY * halfAxes[Matrix3.COLUMN1ROW1] +\n        normalZ * halfAxes[Matrix3.COLUMN1ROW2]\n    ) +\n    Math.abs(\n      normalX * halfAxes[Matrix3.COLUMN2ROW0] +\n        normalY * halfAxes[Matrix3.COLUMN2ROW1] +\n        normalZ * halfAxes[Matrix3.COLUMN2ROW2]\n    );\n  var distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;\n\n  if (distanceToPlane <= -radEffective) {\n    // The entire box is on the negative side of the plane normal\n    return Intersect.OUTSIDE;\n  } else if (distanceToPlane >= radEffective) {\n    // The entire box is on the positive side of the plane normal\n    return Intersect.INSIDE;\n  }\n  return Intersect.INTERSECTING;\n};\n\nvar scratchCartesianU = new Cartesian3();\nvar scratchCartesianV = new Cartesian3();\nvar scratchCartesianW = new Cartesian3();\nvar scratchPPrime = new Cartesian3();\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\n *\n * @param {OrientedBoundingBox} box The box.\n * @param {Cartesian3} cartesian The point\n * @returns {Number} The estimated distance squared from the bounding sphere to the point.\n *\n * @example\n * // Sort bounding boxes from back to front\n * boxes.sort(function(a, b) {\n *     return Cesium.OrientedBoundingBox.distanceSquaredTo(b, camera.positionWC) - Cesium.OrientedBoundingBox.distanceSquaredTo(a, camera.positionWC);\n * });\n */\nOrientedBoundingBox.distanceSquaredTo = function (box, cartesian) {\n  // See Geometric Tools for Computer Graphics 10.4.2\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var offset = Cartesian3.subtract(cartesian, box.center, scratchOffset);\n\n  var halfAxes = box.halfAxes;\n  var u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\n  var v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\n  var w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\n\n  var uHalf = Cartesian3.magnitude(u);\n  var vHalf = Cartesian3.magnitude(v);\n  var wHalf = Cartesian3.magnitude(w);\n\n  Cartesian3.normalize(u, u);\n  Cartesian3.normalize(v, v);\n  Cartesian3.normalize(w, w);\n\n  var pPrime = scratchPPrime;\n  pPrime.x = Cartesian3.dot(offset, u);\n  pPrime.y = Cartesian3.dot(offset, v);\n  pPrime.z = Cartesian3.dot(offset, w);\n\n  var distanceSquared = 0.0;\n  var d;\n\n  if (pPrime.x < -uHalf) {\n    d = pPrime.x + uHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.x > uHalf) {\n    d = pPrime.x - uHalf;\n    distanceSquared += d * d;\n  }\n\n  if (pPrime.y < -vHalf) {\n    d = pPrime.y + vHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.y > vHalf) {\n    d = pPrime.y - vHalf;\n    distanceSquared += d * d;\n  }\n\n  if (pPrime.z < -wHalf) {\n    d = pPrime.z + wHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.z > wHalf) {\n    d = pPrime.z - wHalf;\n    distanceSquared += d * d;\n  }\n\n  return distanceSquared;\n};\n\nvar scratchCorner = new Cartesian3();\nvar scratchToCenter = new Cartesian3();\n\n/**\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding box.\n *\n * @param {OrientedBoundingBox} box The bounding box to calculate the distance to.\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\n */\nOrientedBoundingBox.computePlaneDistances = function (\n  box,\n  position,\n  direction,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Interval();\n  }\n\n  var minDist = Number.POSITIVE_INFINITY;\n  var maxDist = Number.NEGATIVE_INFINITY;\n\n  var center = box.center;\n  var halfAxes = box.halfAxes;\n\n  var u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\n  var v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\n  var w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\n\n  // project first corner\n  var corner = Cartesian3.add(u, v, scratchCorner);\n  Cartesian3.add(corner, w, corner);\n  Cartesian3.add(corner, center, corner);\n\n  var toCenter = Cartesian3.subtract(corner, position, scratchToCenter);\n  var mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project second corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project third corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project fourth corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project fifth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project sixth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project seventh corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project eighth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  result.start = minDist;\n  result.stop = maxDist;\n  return result;\n};\n\nvar scratchBoundingSphere = new BoundingSphere();\n\n/**\n * Determines whether or not a bounding box is hidden from view by the occluder.\n *\n * @param {OrientedBoundingBox} box The bounding box surrounding the occludee object.\n * @param {Occluder} occluder The occluder.\n * @returns {Boolean} <code>true</code> if the box is not visible; otherwise <code>false</code>.\n */\nOrientedBoundingBox.isOccluded = function (box, occluder) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n  if (!defined(occluder)) {\n    throw new DeveloperError(\"occluder is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var sphere = BoundingSphere.fromOrientedBoundingBox(\n    box,\n    scratchBoundingSphere\n  );\n\n  return !occluder.isBoundingSphereVisible(sphere);\n};\n\n/**\n * Determines which side of a plane the oriented bounding box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nOrientedBoundingBox.prototype.intersectPlane = function (plane) {\n  return OrientedBoundingBox.intersectPlane(this, plane);\n};\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\n *\n * @param {Cartesian3} cartesian The point\n * @returns {Number} The estimated distance squared from the bounding sphere to the point.\n *\n * @example\n * // Sort bounding boxes from back to front\n * boxes.sort(function(a, b) {\n *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\n * });\n */\nOrientedBoundingBox.prototype.distanceSquaredTo = function (cartesian) {\n  return OrientedBoundingBox.distanceSquaredTo(this, cartesian);\n};\n\n/**\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding box.\n *\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\n */\nOrientedBoundingBox.prototype.computePlaneDistances = function (\n  position,\n  direction,\n  result\n) {\n  return OrientedBoundingBox.computePlaneDistances(\n    this,\n    position,\n    direction,\n    result\n  );\n};\n\n/**\n * Determines whether or not a bounding box is hidden from view by the occluder.\n *\n * @param {Occluder} occluder The occluder.\n * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n */\nOrientedBoundingBox.prototype.isOccluded = function (occluder) {\n  return OrientedBoundingBox.isOccluded(this, occluder);\n};\n\n/**\n * Compares the provided OrientedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrientedBoundingBox} left The first OrientedBoundingBox.\n * @param {OrientedBoundingBox} right The second OrientedBoundingBox.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nOrientedBoundingBox.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Cartesian3.equals(left.center, right.center) &&\n      Matrix3.equals(left.halfAxes, right.halfAxes))\n  );\n};\n\n/**\n * Duplicates this OrientedBoundingBox instance.\n *\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n */\nOrientedBoundingBox.prototype.clone = function (result) {\n  return OrientedBoundingBox.clone(this, result);\n};\n\n/**\n * Compares this OrientedBoundingBox against the provided OrientedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrientedBoundingBox} [right] The right hand side OrientedBoundingBox.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nOrientedBoundingBox.prototype.equals = function (right) {\n  return OrientedBoundingBox.equals(this, right);\n};\nexport default OrientedBoundingBox;\n"]},"metadata":{},"sourceType":"module"}