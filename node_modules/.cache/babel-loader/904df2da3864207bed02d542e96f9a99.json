{"ast":null,"code":"import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CylinderGeometryLibrary from \"./CylinderGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nvar radiusScratch = new Cartesian2();\n/**\n * A description of the outline of a cylinder.\n *\n * @alias CylinderOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number} options.length The length of the cylinder.\n * @param {Number} options.topRadius The radius of the top of the cylinder.\n * @param {Number} options.bottomRadius The radius of the bottom of the cylinder.\n * @param {Number} [options.slices=128] The number of edges around the perimeter of the cylinder.\n * @param {Number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surfaces of the cylinder.\n *\n * @exception {DeveloperError} options.length must be greater than 0.\n * @exception {DeveloperError} options.topRadius must be greater than 0.\n * @exception {DeveloperError} options.bottomRadius must be greater than 0.\n * @exception {DeveloperError} bottomRadius and topRadius cannot both equal 0.\n * @exception {DeveloperError} options.slices must be greater than or equal to 3.\n *\n * @see CylinderOutlineGeometry.createGeometry\n *\n * @example\n * // create cylinder geometry\n * var cylinder = new Cesium.CylinderOutlineGeometry({\n *     length: 200000,\n *     topRadius: 80000,\n *     bottomRadius: 200000,\n * });\n * var geometry = Cesium.CylinderOutlineGeometry.createGeometry(cylinder);\n */\n\nfunction CylinderOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var length = options.length;\n  var topRadius = options.topRadius;\n  var bottomRadius = options.bottomRadius;\n  var slices = defaultValue(options.slices, 128);\n  var numberOfVerticalLines = Math.max(defaultValue(options.numberOfVerticalLines, 16), 0); //>>includeStart('debug', pragmas.debug);\n\n  Check.typeOf.number(\"options.positions\", length);\n  Check.typeOf.number(\"options.topRadius\", topRadius);\n  Check.typeOf.number(\"options.bottomRadius\", bottomRadius);\n  Check.typeOf.number.greaterThanOrEquals(\"options.slices\", slices, 3);\n\n  if (defined(options.offsetAttribute) && options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n    throw new DeveloperError(\"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\");\n  } //>>includeEnd('debug');\n\n\n  this._length = length;\n  this._topRadius = topRadius;\n  this._bottomRadius = bottomRadius;\n  this._slices = slices;\n  this._numberOfVerticalLines = numberOfVerticalLines;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createCylinderOutlineGeometry\";\n}\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\n\n\nCylinderOutlineGeometry.packedLength = 6;\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CylinderOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\nCylinderOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  array[startingIndex++] = value._length;\n  array[startingIndex++] = value._topRadius;\n  array[startingIndex++] = value._bottomRadius;\n  array[startingIndex++] = value._slices;\n  array[startingIndex++] = value._numberOfVerticalLines;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n  return array;\n};\n\nvar scratchOptions = {\n  length: undefined,\n  topRadius: undefined,\n  bottomRadius: undefined,\n  slices: undefined,\n  numberOfVerticalLines: undefined,\n  offsetAttribute: undefined\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CylinderOutlineGeometry} [result] The object into which to store the result.\n * @returns {CylinderOutlineGeometry} The modified result parameter or a new CylinderOutlineGeometry instance if one was not provided.\n */\n\nCylinderOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var length = array[startingIndex++];\n  var topRadius = array[startingIndex++];\n  var bottomRadius = array[startingIndex++];\n  var slices = array[startingIndex++];\n  var numberOfVerticalLines = array[startingIndex++];\n  var offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.length = length;\n    scratchOptions.topRadius = topRadius;\n    scratchOptions.bottomRadius = bottomRadius;\n    scratchOptions.slices = slices;\n    scratchOptions.numberOfVerticalLines = numberOfVerticalLines;\n    scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new CylinderOutlineGeometry(scratchOptions);\n  }\n\n  result._length = length;\n  result._topRadius = topRadius;\n  result._bottomRadius = bottomRadius;\n  result._slices = slices;\n  result._numberOfVerticalLines = numberOfVerticalLines;\n  result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n  return result;\n};\n/**\n * Computes the geometric representation of an outline of a cylinder, including its vertices, indices, and a bounding sphere.\n *\n * @param {CylinderOutlineGeometry} cylinderGeometry A description of the cylinder outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\n\n\nCylinderOutlineGeometry.createGeometry = function (cylinderGeometry) {\n  var length = cylinderGeometry._length;\n  var topRadius = cylinderGeometry._topRadius;\n  var bottomRadius = cylinderGeometry._bottomRadius;\n  var slices = cylinderGeometry._slices;\n  var numberOfVerticalLines = cylinderGeometry._numberOfVerticalLines;\n\n  if (length <= 0 || topRadius < 0 || bottomRadius < 0 || topRadius === 0 && bottomRadius === 0) {\n    return;\n  }\n\n  var numVertices = slices * 2;\n  var positions = CylinderGeometryLibrary.computePositions(length, topRadius, bottomRadius, slices, false);\n  var numIndices = slices * 2;\n  var numSide;\n\n  if (numberOfVerticalLines > 0) {\n    var numSideLines = Math.min(numberOfVerticalLines, slices);\n    numSide = Math.round(slices / numSideLines);\n    numIndices += numSideLines;\n  }\n\n  var indices = IndexDatatype.createTypedArray(numVertices, numIndices * 2);\n  var index = 0;\n  var i;\n\n  for (i = 0; i < slices - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n    indices[index++] = i + slices;\n    indices[index++] = i + 1 + slices;\n  }\n\n  indices[index++] = slices - 1;\n  indices[index++] = 0;\n  indices[index++] = slices + slices - 1;\n  indices[index++] = slices;\n\n  if (numberOfVerticalLines > 0) {\n    for (i = 0; i < slices; i += numSide) {\n      indices[index++] = i;\n      indices[index++] = i + slices;\n    }\n  }\n\n  var attributes = new GeometryAttributes();\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positions\n  });\n  radiusScratch.x = length * 0.5;\n  radiusScratch.y = Math.max(bottomRadius, topRadius);\n  var boundingSphere = new BoundingSphere(Cartesian3.ZERO, Cartesian2.magnitude(radiusScratch));\n\n  if (defined(cylinderGeometry._offsetAttribute)) {\n    length = positions.length;\n    var applyOffset = new Uint8Array(length / 3);\n    var offsetValue = cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n    arrayFill(applyOffset, offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: cylinderGeometry._offsetAttribute\n  });\n};\n\nexport default CylinderOutlineGeometry;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/CylinderOutlineGeometry.js"],"names":["arrayFill","BoundingSphere","Cartesian2","Cartesian3","Check","ComponentDatatype","CylinderGeometryLibrary","defaultValue","defined","DeveloperError","Geometry","GeometryAttribute","GeometryAttributes","GeometryOffsetAttribute","IndexDatatype","PrimitiveType","radiusScratch","CylinderOutlineGeometry","options","EMPTY_OBJECT","length","topRadius","bottomRadius","slices","numberOfVerticalLines","Math","max","typeOf","number","greaterThanOrEquals","offsetAttribute","TOP","_length","_topRadius","_bottomRadius","_slices","_numberOfVerticalLines","_offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","object","scratchOptions","undefined","unpack","result","createGeometry","cylinderGeometry","numVertices","positions","computePositions","numIndices","numSide","numSideLines","min","round","indices","createTypedArray","index","i","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","x","y","boundingSphere","ZERO","magnitude","applyOffset","Uint8Array","offsetValue","NONE","UNSIGNED_BYTE","primitiveType","LINES"],"mappings":"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","sourcesContent":["import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CylinderGeometryLibrary from \"./CylinderGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nvar radiusScratch = new Cartesian2();\n\n/**\n * A description of the outline of a cylinder.\n *\n * @alias CylinderOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number} options.length The length of the cylinder.\n * @param {Number} options.topRadius The radius of the top of the cylinder.\n * @param {Number} options.bottomRadius The radius of the bottom of the cylinder.\n * @param {Number} [options.slices=128] The number of edges around the perimeter of the cylinder.\n * @param {Number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surfaces of the cylinder.\n *\n * @exception {DeveloperError} options.length must be greater than 0.\n * @exception {DeveloperError} options.topRadius must be greater than 0.\n * @exception {DeveloperError} options.bottomRadius must be greater than 0.\n * @exception {DeveloperError} bottomRadius and topRadius cannot both equal 0.\n * @exception {DeveloperError} options.slices must be greater than or equal to 3.\n *\n * @see CylinderOutlineGeometry.createGeometry\n *\n * @example\n * // create cylinder geometry\n * var cylinder = new Cesium.CylinderOutlineGeometry({\n *     length: 200000,\n *     topRadius: 80000,\n *     bottomRadius: 200000,\n * });\n * var geometry = Cesium.CylinderOutlineGeometry.createGeometry(cylinder);\n */\nfunction CylinderOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var length = options.length;\n  var topRadius = options.topRadius;\n  var bottomRadius = options.bottomRadius;\n  var slices = defaultValue(options.slices, 128);\n  var numberOfVerticalLines = Math.max(\n    defaultValue(options.numberOfVerticalLines, 16),\n    0\n  );\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"options.positions\", length);\n  Check.typeOf.number(\"options.topRadius\", topRadius);\n  Check.typeOf.number(\"options.bottomRadius\", bottomRadius);\n  Check.typeOf.number.greaterThanOrEquals(\"options.slices\", slices, 3);\n  if (\n    defined(options.offsetAttribute) &&\n    options.offsetAttribute === GeometryOffsetAttribute.TOP\n  ) {\n    throw new DeveloperError(\n      \"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._length = length;\n  this._topRadius = topRadius;\n  this._bottomRadius = bottomRadius;\n  this._slices = slices;\n  this._numberOfVerticalLines = numberOfVerticalLines;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createCylinderOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nCylinderOutlineGeometry.packedLength = 6;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CylinderOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCylinderOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value._length;\n  array[startingIndex++] = value._topRadius;\n  array[startingIndex++] = value._bottomRadius;\n  array[startingIndex++] = value._slices;\n  array[startingIndex++] = value._numberOfVerticalLines;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nvar scratchOptions = {\n  length: undefined,\n  topRadius: undefined,\n  bottomRadius: undefined,\n  slices: undefined,\n  numberOfVerticalLines: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CylinderOutlineGeometry} [result] The object into which to store the result.\n * @returns {CylinderOutlineGeometry} The modified result parameter or a new CylinderOutlineGeometry instance if one was not provided.\n */\nCylinderOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var length = array[startingIndex++];\n  var topRadius = array[startingIndex++];\n  var bottomRadius = array[startingIndex++];\n  var slices = array[startingIndex++];\n  var numberOfVerticalLines = array[startingIndex++];\n  var offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.length = length;\n    scratchOptions.topRadius = topRadius;\n    scratchOptions.bottomRadius = bottomRadius;\n    scratchOptions.slices = slices;\n    scratchOptions.numberOfVerticalLines = numberOfVerticalLines;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new CylinderOutlineGeometry(scratchOptions);\n  }\n\n  result._length = length;\n  result._topRadius = topRadius;\n  result._bottomRadius = bottomRadius;\n  result._slices = slices;\n  result._numberOfVerticalLines = numberOfVerticalLines;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of a cylinder, including its vertices, indices, and a bounding sphere.\n *\n * @param {CylinderOutlineGeometry} cylinderGeometry A description of the cylinder outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCylinderOutlineGeometry.createGeometry = function (cylinderGeometry) {\n  var length = cylinderGeometry._length;\n  var topRadius = cylinderGeometry._topRadius;\n  var bottomRadius = cylinderGeometry._bottomRadius;\n  var slices = cylinderGeometry._slices;\n  var numberOfVerticalLines = cylinderGeometry._numberOfVerticalLines;\n\n  if (\n    length <= 0 ||\n    topRadius < 0 ||\n    bottomRadius < 0 ||\n    (topRadius === 0 && bottomRadius === 0)\n  ) {\n    return;\n  }\n\n  var numVertices = slices * 2;\n\n  var positions = CylinderGeometryLibrary.computePositions(\n    length,\n    topRadius,\n    bottomRadius,\n    slices,\n    false\n  );\n  var numIndices = slices * 2;\n  var numSide;\n  if (numberOfVerticalLines > 0) {\n    var numSideLines = Math.min(numberOfVerticalLines, slices);\n    numSide = Math.round(slices / numSideLines);\n    numIndices += numSideLines;\n  }\n\n  var indices = IndexDatatype.createTypedArray(numVertices, numIndices * 2);\n  var index = 0;\n  var i;\n  for (i = 0; i < slices - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n    indices[index++] = i + slices;\n    indices[index++] = i + 1 + slices;\n  }\n\n  indices[index++] = slices - 1;\n  indices[index++] = 0;\n  indices[index++] = slices + slices - 1;\n  indices[index++] = slices;\n\n  if (numberOfVerticalLines > 0) {\n    for (i = 0; i < slices; i += numSide) {\n      indices[index++] = i;\n      indices[index++] = i + slices;\n    }\n  }\n\n  var attributes = new GeometryAttributes();\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positions,\n  });\n\n  radiusScratch.x = length * 0.5;\n  radiusScratch.y = Math.max(bottomRadius, topRadius);\n\n  var boundingSphere = new BoundingSphere(\n    Cartesian3.ZERO,\n    Cartesian2.magnitude(radiusScratch)\n  );\n\n  if (defined(cylinderGeometry._offsetAttribute)) {\n    length = positions.length;\n    var applyOffset = new Uint8Array(length / 3);\n    var offsetValue =\n      cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n        ? 0\n        : 1;\n    arrayFill(applyOffset, offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: cylinderGeometry._offsetAttribute,\n  });\n};\nexport default CylinderOutlineGeometry;\n"]},"metadata":{},"sourceType":"module"}