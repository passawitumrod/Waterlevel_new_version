{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport defined from \"../Core/defined.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Request from \"../Core/Request.js\";\nimport RequestState from \"../Core/RequestState.js\";\nimport RequestType from \"../Core/RequestType.js\";\nimport TileProviderError from \"../Core/TileProviderError.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport when from \"../ThirdParty/when.js\";\nimport ImageryState from \"./ImageryState.js\";\nimport QuadtreeTileLoadState from \"./QuadtreeTileLoadState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport TerrainState from \"./TerrainState.js\";\n/**\n * Contains additional information about a {@link QuadtreeTile} of the globe's surface, and\n * encapsulates state transition logic for loading tiles.\n *\n * @constructor\n * @alias GlobeSurfaceTile\n * @private\n */\n\nfunction GlobeSurfaceTile() {\n  /**\n   * The {@link TileImagery} attached to this tile.\n   * @type {TileImagery[]}\n   * @default []\n   */\n  this.imagery = [];\n  this.waterMaskTexture = undefined;\n  this.waterMaskTranslationAndScale = new Cartesian4(0.0, 0.0, 1.0, 1.0);\n  this.terrainData = undefined;\n  this.vertexArray = undefined;\n  this.orientedBoundingBox = undefined;\n  this.boundingVolumeSourceTile = undefined;\n  /**\n   * A bounding region used to estimate distance to the tile. The horizontal bounds are always tight-fitting,\n   * but the `minimumHeight` and `maximumHeight` properties may be derived from the min/max of an ancestor tile\n   * and be quite loose-fitting and thus very poor for estimating distance. The {@link TileBoundingRegion#boundingVolume}\n   * and {@link TileBoundingRegion#boundingSphere} will always be undefined; tiles store these separately.\n   * @type {TileBoundingRegion}\n   */\n\n  this.tileBoundingRegion = undefined;\n  this.occludeePointInScaledSpace = new Cartesian3();\n  this.terrainState = TerrainState.UNLOADED;\n  this.mesh = undefined;\n  this.fill = undefined;\n  this.pickBoundingSphere = new BoundingSphere();\n  this.surfaceShader = undefined;\n  this.isClipped = true;\n  this.clippedByBoundaries = false;\n}\n\nObject.defineProperties(GlobeSurfaceTile.prototype, {\n  /**\n   * Gets a value indicating whether or not this tile is eligible to be unloaded.\n   * Typically, a tile is ineligible to be unloaded while an asynchronous operation,\n   * such as a request for data, is in progress on it.  A tile will never be\n   * unloaded while it is needed for rendering, regardless of the value of this\n   * property.\n   * @memberof GlobeSurfaceTile.prototype\n   * @type {Boolean}\n   */\n  eligibleForUnloading: {\n    get: function get() {\n      // Do not remove tiles that are transitioning or that have\n      // imagery that is transitioning.\n      var terrainState = this.terrainState;\n      var loadingIsTransitioning = terrainState === TerrainState.RECEIVING || terrainState === TerrainState.TRANSFORMING;\n      var shouldRemoveTile = !loadingIsTransitioning;\n      var imagery = this.imagery;\n\n      for (var i = 0, len = imagery.length; shouldRemoveTile && i < len; ++i) {\n        var tileImagery = imagery[i];\n        shouldRemoveTile = !defined(tileImagery.loadingImagery) || tileImagery.loadingImagery.state !== ImageryState.TRANSITIONING;\n      }\n\n      return shouldRemoveTile;\n    }\n  },\n\n  /**\n   * Gets the {@link TerrainMesh} that is used for rendering this tile, if any.\n   * Returns the value of the {@link GlobeSurfaceTile#mesh} property if\n   * {@link GlobeSurfaceTile#vertexArray} is defined. Otherwise, It returns the\n   * {@link TerrainFillMesh#mesh} property of the {@link GlobeSurfaceTile#fill}.\n   * If there is no fill, it returns undefined.\n   *\n   * @memberof GlobeSurfaceTile.prototype\n   * @type {TerrainMesh}\n   */\n  renderedMesh: {\n    get: function get() {\n      if (defined(this.vertexArray)) {\n        return this.mesh;\n      } else if (defined(this.fill)) {\n        return this.fill.mesh;\n      }\n\n      return undefined;\n    }\n  }\n});\n\nfunction getPosition(encoding, mode, projection, vertices, index, result) {\n  encoding.decodePosition(vertices, index, result);\n\n  if (defined(mode) && mode !== SceneMode.SCENE3D) {\n    var ellipsoid = projection.ellipsoid;\n    var positionCart = ellipsoid.cartesianToCartographic(result);\n    projection.project(positionCart, result);\n    Cartesian3.fromElements(result.z, result.x, result.y, result);\n  }\n\n  return result;\n}\n\nvar scratchV0 = new Cartesian3();\nvar scratchV1 = new Cartesian3();\nvar scratchV2 = new Cartesian3();\n\nGlobeSurfaceTile.prototype.pick = function (ray, mode, projection, cullBackFaces, result) {\n  var mesh = this.renderedMesh;\n\n  if (!defined(mesh)) {\n    return undefined;\n  }\n\n  var vertices = mesh.vertices;\n  var indices = mesh.indices;\n  var encoding = mesh.encoding;\n  var indicesLength = indices.length;\n  var minT = Number.MAX_VALUE;\n\n  for (var i = 0; i < indicesLength; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n    var v0 = getPosition(encoding, mode, projection, vertices, i0, scratchV0);\n    var v1 = getPosition(encoding, mode, projection, vertices, i1, scratchV1);\n    var v2 = getPosition(encoding, mode, projection, vertices, i2, scratchV2);\n    var t = IntersectionTests.rayTriangleParametric(ray, v0, v1, v2, cullBackFaces);\n\n    if (defined(t) && t < minT && t >= 0.0) {\n      minT = t;\n    }\n  }\n\n  return minT !== Number.MAX_VALUE ? Ray.getPoint(ray, minT, result) : undefined;\n};\n\nGlobeSurfaceTile.prototype.freeResources = function () {\n  if (defined(this.waterMaskTexture)) {\n    --this.waterMaskTexture.referenceCount;\n\n    if (this.waterMaskTexture.referenceCount === 0) {\n      this.waterMaskTexture.destroy();\n    }\n\n    this.waterMaskTexture = undefined;\n  }\n\n  this.terrainData = undefined;\n  this.terrainState = TerrainState.UNLOADED;\n  this.mesh = undefined;\n  this.fill = this.fill && this.fill.destroy();\n  var imageryList = this.imagery;\n\n  for (var i = 0, len = imageryList.length; i < len; ++i) {\n    imageryList[i].freeResources();\n  }\n\n  this.imagery.length = 0;\n  this.freeVertexArray();\n};\n\nGlobeSurfaceTile.prototype.freeVertexArray = function () {\n  GlobeSurfaceTile._freeVertexArray(this.vertexArray);\n\n  this.vertexArray = undefined;\n\n  GlobeSurfaceTile._freeVertexArray(this.wireframeVertexArray);\n\n  this.wireframeVertexArray = undefined;\n};\n\nGlobeSurfaceTile.initialize = function (tile, terrainProvider, imageryLayerCollection) {\n  var surfaceTile = tile.data;\n\n  if (!defined(surfaceTile)) {\n    surfaceTile = tile.data = new GlobeSurfaceTile();\n  }\n\n  if (tile.state === QuadtreeTileLoadState.START) {\n    prepareNewTile(tile, terrainProvider, imageryLayerCollection);\n    tile.state = QuadtreeTileLoadState.LOADING;\n  }\n};\n\nGlobeSurfaceTile.processStateMachine = function (tile, frameState, terrainProvider, imageryLayerCollection, vertexArraysToDestroy, terrainOnly) {\n  GlobeSurfaceTile.initialize(tile, terrainProvider, imageryLayerCollection);\n  var surfaceTile = tile.data;\n\n  if (tile.state === QuadtreeTileLoadState.LOADING) {\n    processTerrainStateMachine(tile, frameState, terrainProvider, imageryLayerCollection, vertexArraysToDestroy);\n  } // From here down we're loading imagery, not terrain. We don't want to load imagery until\n  // we're certain that the terrain tiles are actually visible, though. We'll load terrainOnly\n  // in these scenarios:\n  //   * our bounding volume isn't accurate so we're not certain this tile is really visible (see GlobeSurfaceTileProvider#loadTile).\n  //   * we want to upsample from this tile but don't plan to render it (see processTerrainStateMachine).\n\n\n  if (terrainOnly) {\n    return;\n  }\n\n  var wasAlreadyRenderable = tile.renderable; // The terrain is renderable as soon as we have a valid vertex array.\n\n  tile.renderable = defined(surfaceTile.vertexArray); // But it's not done loading until it's in the READY state.\n\n  var isTerrainDoneLoading = surfaceTile.terrainState === TerrainState.READY; // If this tile's terrain and imagery are just upsampled from its parent, mark the tile as\n  // upsampled only.  We won't refine a tile if its four children are upsampled only.\n\n  tile.upsampledFromParent = defined(surfaceTile.terrainData) && surfaceTile.terrainData.wasCreatedByUpsampling();\n  var isImageryDoneLoading = surfaceTile.processImagery(tile, terrainProvider, frameState);\n\n  if (isTerrainDoneLoading && isImageryDoneLoading) {\n    var callbacks = tile._loadedCallbacks;\n    var newCallbacks = {};\n\n    for (var layerId in callbacks) {\n      if (callbacks.hasOwnProperty(layerId)) {\n        if (!callbacks[layerId](tile)) {\n          newCallbacks[layerId] = callbacks[layerId];\n        }\n      }\n    }\n\n    tile._loadedCallbacks = newCallbacks;\n    tile.state = QuadtreeTileLoadState.DONE;\n  } // Once a tile is renderable, it stays renderable, because doing otherwise would\n  // cause detail (or maybe even the entire globe) to vanish when adding a new\n  // imagery layer. `GlobeSurfaceTileProvider._onLayerAdded` sets renderable to\n  // false for all affected tiles that are not currently being rendered.\n\n\n  if (wasAlreadyRenderable) {\n    tile.renderable = true;\n  }\n};\n\nGlobeSurfaceTile.prototype.processImagery = function (tile, terrainProvider, frameState, skipLoading) {\n  var surfaceTile = tile.data;\n  var isUpsampledOnly = tile.upsampledFromParent;\n  var isAnyTileLoaded = false;\n  var isDoneLoading = true; // Transition imagery states\n\n  var tileImageryCollection = surfaceTile.imagery;\n  var i, len;\n\n  for (i = 0, len = tileImageryCollection.length; i < len; ++i) {\n    var tileImagery = tileImageryCollection[i];\n\n    if (!defined(tileImagery.loadingImagery)) {\n      isUpsampledOnly = false;\n      continue;\n    }\n\n    if (tileImagery.loadingImagery.state === ImageryState.PLACEHOLDER) {\n      var imageryLayer = tileImagery.loadingImagery.imageryLayer;\n\n      if (imageryLayer.imageryProvider.ready) {\n        // Remove the placeholder and add the actual skeletons (if any)\n        // at the same position.  Then continue the loop at the same index.\n        tileImagery.freeResources();\n        tileImageryCollection.splice(i, 1);\n\n        imageryLayer._createTileImagerySkeletons(tile, terrainProvider, i);\n\n        --i;\n        len = tileImageryCollection.length;\n        continue;\n      } else {\n        isUpsampledOnly = false;\n      }\n    }\n\n    var thisTileDoneLoading = tileImagery.processStateMachine(tile, frameState, skipLoading);\n    isDoneLoading = isDoneLoading && thisTileDoneLoading; // The imagery is renderable as soon as we have any renderable imagery for this region.\n\n    isAnyTileLoaded = isAnyTileLoaded || thisTileDoneLoading || defined(tileImagery.readyImagery);\n    isUpsampledOnly = isUpsampledOnly && defined(tileImagery.loadingImagery) && (tileImagery.loadingImagery.state === ImageryState.FAILED || tileImagery.loadingImagery.state === ImageryState.INVALID);\n  }\n\n  tile.upsampledFromParent = isUpsampledOnly; // Allow rendering if any available layers are loaded\n\n  tile.renderable = tile.renderable && (isAnyTileLoaded || isDoneLoading);\n  return isDoneLoading;\n};\n\nfunction prepareNewTile(tile, terrainProvider, imageryLayerCollection) {\n  var available = terrainProvider.getTileDataAvailable(tile.x, tile.y, tile.level);\n\n  if (!defined(available) && defined(tile.parent)) {\n    // Provider doesn't know if this tile is available. Does the parent tile know?\n    var parent = tile.parent;\n    var parentSurfaceTile = parent.data;\n\n    if (defined(parentSurfaceTile) && defined(parentSurfaceTile.terrainData)) {\n      available = parentSurfaceTile.terrainData.isChildAvailable(parent.x, parent.y, tile.x, tile.y);\n    }\n  }\n\n  if (available === false) {\n    // This tile is not available, so mark it failed so we start upsampling right away.\n    tile.data.terrainState = TerrainState.FAILED;\n  } // Map imagery tiles to this terrain tile\n\n\n  for (var i = 0, len = imageryLayerCollection.length; i < len; ++i) {\n    var layer = imageryLayerCollection.get(i);\n\n    if (layer.show) {\n      layer._createTileImagerySkeletons(tile, terrainProvider);\n    }\n  }\n}\n\nfunction processTerrainStateMachine(tile, frameState, terrainProvider, imageryLayerCollection, vertexArraysToDestroy) {\n  var surfaceTile = tile.data; // If this tile is FAILED, we'll need to upsample from the parent. If the parent isn't\n  // ready for that, let's push it along.\n\n  var parent = tile.parent;\n\n  if (surfaceTile.terrainState === TerrainState.FAILED && parent !== undefined) {\n    var parentReady = parent.data !== undefined && parent.data.terrainData !== undefined && parent.data.terrainData.canUpsample !== false;\n\n    if (!parentReady) {\n      GlobeSurfaceTile.processStateMachine(parent, frameState, terrainProvider, imageryLayerCollection, true);\n    }\n  }\n\n  if (surfaceTile.terrainState === TerrainState.FAILED) {\n    upsample(surfaceTile, tile, frameState, terrainProvider, tile.x, tile.y, tile.level);\n  }\n\n  if (surfaceTile.terrainState === TerrainState.UNLOADED) {\n    requestTileGeometry(surfaceTile, terrainProvider, tile.x, tile.y, tile.level);\n  }\n\n  if (surfaceTile.terrainState === TerrainState.RECEIVED) {\n    transform(surfaceTile, frameState, terrainProvider, tile.x, tile.y, tile.level);\n  }\n\n  if (surfaceTile.terrainState === TerrainState.TRANSFORMED) {\n    createResources(surfaceTile, frameState.context, terrainProvider, tile.x, tile.y, tile.level, vertexArraysToDestroy);\n  }\n\n  if (surfaceTile.terrainState >= TerrainState.RECEIVED && surfaceTile.waterMaskTexture === undefined && terrainProvider.hasWaterMask) {\n    var terrainData = surfaceTile.terrainData;\n\n    if (terrainData.waterMask !== undefined) {\n      createWaterMaskTextureIfNeeded(frameState.context, surfaceTile);\n    } else {\n      var sourceTile = surfaceTile._findAncestorTileWithTerrainData(tile);\n\n      if (defined(sourceTile) && defined(sourceTile.data.waterMaskTexture)) {\n        surfaceTile.waterMaskTexture = sourceTile.data.waterMaskTexture;\n        ++surfaceTile.waterMaskTexture.referenceCount;\n\n        surfaceTile._computeWaterMaskTranslationAndScale(tile, sourceTile, surfaceTile.waterMaskTranslationAndScale);\n      }\n    }\n  }\n}\n\nfunction upsample(surfaceTile, tile, frameState, terrainProvider, x, y, level) {\n  var parent = tile.parent;\n\n  if (!parent) {\n    // Trying to upsample from a root tile. No can do. This tile is a failure.\n    tile.state = QuadtreeTileLoadState.FAILED;\n    return;\n  }\n\n  var sourceData = parent.data.terrainData;\n  var sourceX = parent.x;\n  var sourceY = parent.y;\n  var sourceLevel = parent.level;\n\n  if (!defined(sourceData)) {\n    // Parent is not available, so we can't upsample this tile yet.\n    return;\n  }\n\n  var terrainDataPromise = sourceData.upsample(terrainProvider.tilingScheme, sourceX, sourceY, sourceLevel, x, y, level);\n\n  if (!defined(terrainDataPromise)) {\n    // The upsample request has been deferred - try again later.\n    return;\n  }\n\n  surfaceTile.terrainState = TerrainState.RECEIVING;\n  when(terrainDataPromise, function (terrainData) {\n    surfaceTile.terrainData = terrainData;\n    surfaceTile.terrainState = TerrainState.RECEIVED;\n  }, function () {\n    surfaceTile.terrainState = TerrainState.FAILED;\n  });\n}\n\nfunction requestTileGeometry(surfaceTile, terrainProvider, x, y, level) {\n  function success(terrainData) {\n    surfaceTile.terrainData = terrainData;\n    surfaceTile.terrainState = TerrainState.RECEIVED;\n    surfaceTile.request = undefined;\n  }\n\n  function failure() {\n    if (surfaceTile.request.state === RequestState.CANCELLED) {\n      // Cancelled due to low priority - try again later.\n      surfaceTile.terrainData = undefined;\n      surfaceTile.terrainState = TerrainState.UNLOADED;\n      surfaceTile.request = undefined;\n      return;\n    } // Initially assume failure.  handleError may retry, in which case the state will\n    // change to RECEIVING or UNLOADED.\n\n\n    surfaceTile.terrainState = TerrainState.FAILED;\n    surfaceTile.request = undefined;\n    var message = \"Failed to obtain terrain tile X: \" + x + \" Y: \" + y + \" Level: \" + level + \".\";\n    terrainProvider._requestError = TileProviderError.handleError(terrainProvider._requestError, terrainProvider, terrainProvider.errorEvent, message, x, y, level, doRequest);\n  }\n\n  function doRequest() {\n    // Request the terrain from the terrain provider.\n    var request = new Request({\n      throttle: false,\n      throttleByServer: true,\n      type: RequestType.TERRAIN\n    });\n    surfaceTile.request = request;\n    var requestPromise = terrainProvider.requestTileGeometry(x, y, level, request); // If the request method returns undefined (instead of a promise), the request\n    // has been deferred.\n\n    if (defined(requestPromise)) {\n      surfaceTile.terrainState = TerrainState.RECEIVING;\n      when(requestPromise, success, failure);\n    } else {\n      // Deferred - try again later.\n      surfaceTile.terrainState = TerrainState.UNLOADED;\n      surfaceTile.request = undefined;\n    }\n  }\n\n  doRequest();\n}\n\nfunction transform(surfaceTile, frameState, terrainProvider, x, y, level) {\n  var tilingScheme = terrainProvider.tilingScheme;\n  var terrainData = surfaceTile.terrainData;\n  var meshPromise = terrainData.createMesh(tilingScheme, x, y, level, frameState.terrainExaggeration);\n\n  if (!defined(meshPromise)) {\n    // Postponed.\n    return;\n  }\n\n  surfaceTile.terrainState = TerrainState.TRANSFORMING;\n  when(meshPromise, function (mesh) {\n    surfaceTile.mesh = mesh;\n    surfaceTile.orientedBoundingBox = OrientedBoundingBox.clone(mesh.orientedBoundingBox, surfaceTile.orientedBoundingBox);\n    surfaceTile.occludeePointInScaledSpace = Cartesian3.clone(mesh.occludeePointInScaledSpace, surfaceTile.occludeePointInScaledSpace);\n    surfaceTile.terrainState = TerrainState.TRANSFORMED;\n  }, function () {\n    surfaceTile.terrainState = TerrainState.FAILED;\n  });\n}\n\nGlobeSurfaceTile._createVertexArrayForMesh = function (context, mesh) {\n  var typedArray = mesh.vertices;\n  var buffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: typedArray,\n    usage: BufferUsage.STATIC_DRAW\n  });\n  var attributes = mesh.encoding.getAttributes(buffer);\n  var indexBuffers = mesh.indices.indexBuffers || {};\n  var indexBuffer = indexBuffers[context.id];\n\n  if (!defined(indexBuffer) || indexBuffer.isDestroyed()) {\n    var indices = mesh.indices;\n    indexBuffer = Buffer.createIndexBuffer({\n      context: context,\n      typedArray: indices,\n      usage: BufferUsage.STATIC_DRAW,\n      indexDatatype: IndexDatatype.fromSizeInBytes(indices.BYTES_PER_ELEMENT)\n    });\n    indexBuffer.vertexArrayDestroyable = false;\n    indexBuffer.referenceCount = 1;\n    indexBuffers[context.id] = indexBuffer;\n    mesh.indices.indexBuffers = indexBuffers;\n  } else {\n    ++indexBuffer.referenceCount;\n  }\n\n  return new VertexArray({\n    context: context,\n    attributes: attributes,\n    indexBuffer: indexBuffer\n  });\n};\n\nGlobeSurfaceTile._freeVertexArray = function (vertexArray) {\n  if (defined(vertexArray)) {\n    var indexBuffer = vertexArray.indexBuffer;\n    vertexArray.destroy();\n\n    if (defined(indexBuffer) && !indexBuffer.isDestroyed() && defined(indexBuffer.referenceCount)) {\n      --indexBuffer.referenceCount;\n\n      if (indexBuffer.referenceCount === 0) {\n        indexBuffer.destroy();\n      }\n    }\n  }\n};\n\nfunction createResources(surfaceTile, context, terrainProvider, x, y, level, vertexArraysToDestroy) {\n  surfaceTile.vertexArray = GlobeSurfaceTile._createVertexArrayForMesh(context, surfaceTile.mesh);\n  surfaceTile.terrainState = TerrainState.READY;\n  surfaceTile.fill = surfaceTile.fill && surfaceTile.fill.destroy(vertexArraysToDestroy);\n}\n\nfunction getContextWaterMaskData(context) {\n  var data = context.cache.tile_waterMaskData;\n\n  if (!defined(data)) {\n    var allWaterTexture = Texture.create({\n      context: context,\n      pixelFormat: PixelFormat.LUMINANCE,\n      pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n      source: {\n        arrayBufferView: new Uint8Array([255]),\n        width: 1,\n        height: 1\n      }\n    });\n    allWaterTexture.referenceCount = 1;\n    var sampler = new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: TextureMinificationFilter.LINEAR,\n      magnificationFilter: TextureMagnificationFilter.LINEAR\n    });\n    data = {\n      allWaterTexture: allWaterTexture,\n      sampler: sampler,\n      destroy: function destroy() {\n        this.allWaterTexture.destroy();\n      }\n    };\n    context.cache.tile_waterMaskData = data;\n  }\n\n  return data;\n}\n\nfunction createWaterMaskTextureIfNeeded(context, surfaceTile) {\n  var waterMask = surfaceTile.terrainData.waterMask;\n  var waterMaskData = getContextWaterMaskData(context);\n  var texture;\n  var waterMaskLength = waterMask.length;\n\n  if (waterMaskLength === 1) {\n    // Length 1 means the tile is entirely land or entirely water.\n    // A value of 0 indicates entirely land, a value of 1 indicates entirely water.\n    if (waterMask[0] !== 0) {\n      texture = waterMaskData.allWaterTexture;\n    } else {\n      // Leave the texture undefined if the tile is entirely land.\n      return;\n    }\n  } else {\n    var textureSize = Math.sqrt(waterMaskLength);\n    texture = Texture.create({\n      context: context,\n      pixelFormat: PixelFormat.LUMINANCE,\n      pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n      source: {\n        width: textureSize,\n        height: textureSize,\n        arrayBufferView: waterMask\n      },\n      sampler: waterMaskData.sampler,\n      flipY: false\n    });\n    texture.referenceCount = 0;\n  }\n\n  ++texture.referenceCount;\n  surfaceTile.waterMaskTexture = texture;\n  Cartesian4.fromElements(0.0, 0.0, 1.0, 1.0, surfaceTile.waterMaskTranslationAndScale);\n}\n\nGlobeSurfaceTile.prototype._findAncestorTileWithTerrainData = function (tile) {\n  var sourceTile = tile.parent;\n\n  while (defined(sourceTile) && (!defined(sourceTile.data) || !defined(sourceTile.data.terrainData) || sourceTile.data.terrainData.wasCreatedByUpsampling())) {\n    sourceTile = sourceTile.parent;\n  }\n\n  return sourceTile;\n};\n\nGlobeSurfaceTile.prototype._computeWaterMaskTranslationAndScale = function (tile, sourceTile, result) {\n  var sourceTileRectangle = sourceTile.rectangle;\n  var tileRectangle = tile.rectangle;\n  var tileWidth = tileRectangle.width;\n  var tileHeight = tileRectangle.height;\n  var scaleX = tileWidth / sourceTileRectangle.width;\n  var scaleY = tileHeight / sourceTileRectangle.height;\n  result.x = scaleX * (tileRectangle.west - sourceTileRectangle.west) / tileWidth;\n  result.y = scaleY * (tileRectangle.south - sourceTileRectangle.south) / tileHeight;\n  result.z = scaleX;\n  result.w = scaleY;\n  return result;\n};\n\nexport default GlobeSurfaceTile;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/GlobeSurfaceTile.js"],"names":["BoundingSphere","Cartesian3","Cartesian4","defined","IndexDatatype","IntersectionTests","OrientedBoundingBox","PixelFormat","Ray","Request","RequestState","RequestType","TileProviderError","Buffer","BufferUsage","PixelDatatype","Sampler","Texture","TextureMagnificationFilter","TextureMinificationFilter","TextureWrap","VertexArray","when","ImageryState","QuadtreeTileLoadState","SceneMode","TerrainState","GlobeSurfaceTile","imagery","waterMaskTexture","undefined","waterMaskTranslationAndScale","terrainData","vertexArray","orientedBoundingBox","boundingVolumeSourceTile","tileBoundingRegion","occludeePointInScaledSpace","terrainState","UNLOADED","mesh","fill","pickBoundingSphere","surfaceShader","isClipped","clippedByBoundaries","Object","defineProperties","prototype","eligibleForUnloading","get","loadingIsTransitioning","RECEIVING","TRANSFORMING","shouldRemoveTile","i","len","length","tileImagery","loadingImagery","state","TRANSITIONING","renderedMesh","getPosition","encoding","mode","projection","vertices","index","result","decodePosition","SCENE3D","ellipsoid","positionCart","cartesianToCartographic","project","fromElements","z","x","y","scratchV0","scratchV1","scratchV2","pick","ray","cullBackFaces","indices","indicesLength","minT","Number","MAX_VALUE","i0","i1","i2","v0","v1","v2","t","rayTriangleParametric","getPoint","freeResources","referenceCount","destroy","imageryList","freeVertexArray","_freeVertexArray","wireframeVertexArray","initialize","tile","terrainProvider","imageryLayerCollection","surfaceTile","data","START","prepareNewTile","LOADING","processStateMachine","frameState","vertexArraysToDestroy","terrainOnly","processTerrainStateMachine","wasAlreadyRenderable","renderable","isTerrainDoneLoading","READY","upsampledFromParent","wasCreatedByUpsampling","isImageryDoneLoading","processImagery","callbacks","_loadedCallbacks","newCallbacks","layerId","hasOwnProperty","DONE","skipLoading","isUpsampledOnly","isAnyTileLoaded","isDoneLoading","tileImageryCollection","PLACEHOLDER","imageryLayer","imageryProvider","ready","splice","_createTileImagerySkeletons","thisTileDoneLoading","readyImagery","FAILED","INVALID","available","getTileDataAvailable","level","parent","parentSurfaceTile","isChildAvailable","layer","show","parentReady","canUpsample","upsample","requestTileGeometry","RECEIVED","transform","TRANSFORMED","createResources","context","hasWaterMask","waterMask","createWaterMaskTextureIfNeeded","sourceTile","_findAncestorTileWithTerrainData","_computeWaterMaskTranslationAndScale","sourceData","sourceX","sourceY","sourceLevel","terrainDataPromise","tilingScheme","success","request","failure","CANCELLED","message","_requestError","handleError","errorEvent","doRequest","throttle","throttleByServer","type","TERRAIN","requestPromise","meshPromise","createMesh","terrainExaggeration","clone","_createVertexArrayForMesh","typedArray","buffer","createVertexBuffer","usage","STATIC_DRAW","attributes","getAttributes","indexBuffers","indexBuffer","id","isDestroyed","createIndexBuffer","indexDatatype","fromSizeInBytes","BYTES_PER_ELEMENT","vertexArrayDestroyable","getContextWaterMaskData","cache","tile_waterMaskData","allWaterTexture","create","pixelFormat","LUMINANCE","pixelDatatype","UNSIGNED_BYTE","source","arrayBufferView","Uint8Array","width","height","sampler","wrapS","CLAMP_TO_EDGE","wrapT","minificationFilter","LINEAR","magnificationFilter","waterMaskData","texture","waterMaskLength","textureSize","Math","sqrt","flipY","sourceTileRectangle","rectangle","tileRectangle","tileWidth","tileHeight","scaleX","scaleY","west","south","w"],"mappings":"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","sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport defined from \"../Core/defined.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Request from \"../Core/Request.js\";\nimport RequestState from \"../Core/RequestState.js\";\nimport RequestType from \"../Core/RequestType.js\";\nimport TileProviderError from \"../Core/TileProviderError.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport when from \"../ThirdParty/when.js\";\nimport ImageryState from \"./ImageryState.js\";\nimport QuadtreeTileLoadState from \"./QuadtreeTileLoadState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport TerrainState from \"./TerrainState.js\";\n\n/**\n * Contains additional information about a {@link QuadtreeTile} of the globe's surface, and\n * encapsulates state transition logic for loading tiles.\n *\n * @constructor\n * @alias GlobeSurfaceTile\n * @private\n */\nfunction GlobeSurfaceTile() {\n  /**\n   * The {@link TileImagery} attached to this tile.\n   * @type {TileImagery[]}\n   * @default []\n   */\n  this.imagery = [];\n\n  this.waterMaskTexture = undefined;\n  this.waterMaskTranslationAndScale = new Cartesian4(0.0, 0.0, 1.0, 1.0);\n\n  this.terrainData = undefined;\n  this.vertexArray = undefined;\n  this.orientedBoundingBox = undefined;\n  this.boundingVolumeSourceTile = undefined;\n\n  /**\n   * A bounding region used to estimate distance to the tile. The horizontal bounds are always tight-fitting,\n   * but the `minimumHeight` and `maximumHeight` properties may be derived from the min/max of an ancestor tile\n   * and be quite loose-fitting and thus very poor for estimating distance. The {@link TileBoundingRegion#boundingVolume}\n   * and {@link TileBoundingRegion#boundingSphere} will always be undefined; tiles store these separately.\n   * @type {TileBoundingRegion}\n   */\n  this.tileBoundingRegion = undefined;\n  this.occludeePointInScaledSpace = new Cartesian3();\n\n  this.terrainState = TerrainState.UNLOADED;\n  this.mesh = undefined;\n  this.fill = undefined;\n\n  this.pickBoundingSphere = new BoundingSphere();\n\n  this.surfaceShader = undefined;\n  this.isClipped = true;\n\n  this.clippedByBoundaries = false;\n}\n\nObject.defineProperties(GlobeSurfaceTile.prototype, {\n  /**\n   * Gets a value indicating whether or not this tile is eligible to be unloaded.\n   * Typically, a tile is ineligible to be unloaded while an asynchronous operation,\n   * such as a request for data, is in progress on it.  A tile will never be\n   * unloaded while it is needed for rendering, regardless of the value of this\n   * property.\n   * @memberof GlobeSurfaceTile.prototype\n   * @type {Boolean}\n   */\n  eligibleForUnloading: {\n    get: function () {\n      // Do not remove tiles that are transitioning or that have\n      // imagery that is transitioning.\n      var terrainState = this.terrainState;\n      var loadingIsTransitioning =\n        terrainState === TerrainState.RECEIVING ||\n        terrainState === TerrainState.TRANSFORMING;\n\n      var shouldRemoveTile = !loadingIsTransitioning;\n\n      var imagery = this.imagery;\n      for (var i = 0, len = imagery.length; shouldRemoveTile && i < len; ++i) {\n        var tileImagery = imagery[i];\n        shouldRemoveTile =\n          !defined(tileImagery.loadingImagery) ||\n          tileImagery.loadingImagery.state !== ImageryState.TRANSITIONING;\n      }\n\n      return shouldRemoveTile;\n    },\n  },\n\n  /**\n   * Gets the {@link TerrainMesh} that is used for rendering this tile, if any.\n   * Returns the value of the {@link GlobeSurfaceTile#mesh} property if\n   * {@link GlobeSurfaceTile#vertexArray} is defined. Otherwise, It returns the\n   * {@link TerrainFillMesh#mesh} property of the {@link GlobeSurfaceTile#fill}.\n   * If there is no fill, it returns undefined.\n   *\n   * @memberof GlobeSurfaceTile.prototype\n   * @type {TerrainMesh}\n   */\n  renderedMesh: {\n    get: function () {\n      if (defined(this.vertexArray)) {\n        return this.mesh;\n      } else if (defined(this.fill)) {\n        return this.fill.mesh;\n      }\n      return undefined;\n    },\n  },\n});\n\nfunction getPosition(encoding, mode, projection, vertices, index, result) {\n  encoding.decodePosition(vertices, index, result);\n\n  if (defined(mode) && mode !== SceneMode.SCENE3D) {\n    var ellipsoid = projection.ellipsoid;\n    var positionCart = ellipsoid.cartesianToCartographic(result);\n    projection.project(positionCart, result);\n    Cartesian3.fromElements(result.z, result.x, result.y, result);\n  }\n\n  return result;\n}\n\nvar scratchV0 = new Cartesian3();\nvar scratchV1 = new Cartesian3();\nvar scratchV2 = new Cartesian3();\n\nGlobeSurfaceTile.prototype.pick = function (\n  ray,\n  mode,\n  projection,\n  cullBackFaces,\n  result\n) {\n  var mesh = this.renderedMesh;\n  if (!defined(mesh)) {\n    return undefined;\n  }\n\n  var vertices = mesh.vertices;\n  var indices = mesh.indices;\n  var encoding = mesh.encoding;\n  var indicesLength = indices.length;\n\n  var minT = Number.MAX_VALUE;\n\n  for (var i = 0; i < indicesLength; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n\n    var v0 = getPosition(encoding, mode, projection, vertices, i0, scratchV0);\n    var v1 = getPosition(encoding, mode, projection, vertices, i1, scratchV1);\n    var v2 = getPosition(encoding, mode, projection, vertices, i2, scratchV2);\n\n    var t = IntersectionTests.rayTriangleParametric(\n      ray,\n      v0,\n      v1,\n      v2,\n      cullBackFaces\n    );\n    if (defined(t) && t < minT && t >= 0.0) {\n      minT = t;\n    }\n  }\n\n  return minT !== Number.MAX_VALUE\n    ? Ray.getPoint(ray, minT, result)\n    : undefined;\n};\n\nGlobeSurfaceTile.prototype.freeResources = function () {\n  if (defined(this.waterMaskTexture)) {\n    --this.waterMaskTexture.referenceCount;\n    if (this.waterMaskTexture.referenceCount === 0) {\n      this.waterMaskTexture.destroy();\n    }\n    this.waterMaskTexture = undefined;\n  }\n\n  this.terrainData = undefined;\n\n  this.terrainState = TerrainState.UNLOADED;\n  this.mesh = undefined;\n  this.fill = this.fill && this.fill.destroy();\n\n  var imageryList = this.imagery;\n  for (var i = 0, len = imageryList.length; i < len; ++i) {\n    imageryList[i].freeResources();\n  }\n  this.imagery.length = 0;\n\n  this.freeVertexArray();\n};\n\nGlobeSurfaceTile.prototype.freeVertexArray = function () {\n  GlobeSurfaceTile._freeVertexArray(this.vertexArray);\n  this.vertexArray = undefined;\n  GlobeSurfaceTile._freeVertexArray(this.wireframeVertexArray);\n  this.wireframeVertexArray = undefined;\n};\n\nGlobeSurfaceTile.initialize = function (\n  tile,\n  terrainProvider,\n  imageryLayerCollection\n) {\n  var surfaceTile = tile.data;\n  if (!defined(surfaceTile)) {\n    surfaceTile = tile.data = new GlobeSurfaceTile();\n  }\n\n  if (tile.state === QuadtreeTileLoadState.START) {\n    prepareNewTile(tile, terrainProvider, imageryLayerCollection);\n    tile.state = QuadtreeTileLoadState.LOADING;\n  }\n};\n\nGlobeSurfaceTile.processStateMachine = function (\n  tile,\n  frameState,\n  terrainProvider,\n  imageryLayerCollection,\n  vertexArraysToDestroy,\n  terrainOnly\n) {\n  GlobeSurfaceTile.initialize(tile, terrainProvider, imageryLayerCollection);\n\n  var surfaceTile = tile.data;\n\n  if (tile.state === QuadtreeTileLoadState.LOADING) {\n    processTerrainStateMachine(\n      tile,\n      frameState,\n      terrainProvider,\n      imageryLayerCollection,\n      vertexArraysToDestroy\n    );\n  }\n\n  // From here down we're loading imagery, not terrain. We don't want to load imagery until\n  // we're certain that the terrain tiles are actually visible, though. We'll load terrainOnly\n  // in these scenarios:\n  //   * our bounding volume isn't accurate so we're not certain this tile is really visible (see GlobeSurfaceTileProvider#loadTile).\n  //   * we want to upsample from this tile but don't plan to render it (see processTerrainStateMachine).\n  if (terrainOnly) {\n    return;\n  }\n\n  var wasAlreadyRenderable = tile.renderable;\n\n  // The terrain is renderable as soon as we have a valid vertex array.\n  tile.renderable = defined(surfaceTile.vertexArray);\n\n  // But it's not done loading until it's in the READY state.\n  var isTerrainDoneLoading = surfaceTile.terrainState === TerrainState.READY;\n\n  // If this tile's terrain and imagery are just upsampled from its parent, mark the tile as\n  // upsampled only.  We won't refine a tile if its four children are upsampled only.\n  tile.upsampledFromParent =\n    defined(surfaceTile.terrainData) &&\n    surfaceTile.terrainData.wasCreatedByUpsampling();\n\n  var isImageryDoneLoading = surfaceTile.processImagery(\n    tile,\n    terrainProvider,\n    frameState\n  );\n\n  if (isTerrainDoneLoading && isImageryDoneLoading) {\n    var callbacks = tile._loadedCallbacks;\n    var newCallbacks = {};\n    for (var layerId in callbacks) {\n      if (callbacks.hasOwnProperty(layerId)) {\n        if (!callbacks[layerId](tile)) {\n          newCallbacks[layerId] = callbacks[layerId];\n        }\n      }\n    }\n    tile._loadedCallbacks = newCallbacks;\n\n    tile.state = QuadtreeTileLoadState.DONE;\n  }\n\n  // Once a tile is renderable, it stays renderable, because doing otherwise would\n  // cause detail (or maybe even the entire globe) to vanish when adding a new\n  // imagery layer. `GlobeSurfaceTileProvider._onLayerAdded` sets renderable to\n  // false for all affected tiles that are not currently being rendered.\n  if (wasAlreadyRenderable) {\n    tile.renderable = true;\n  }\n};\n\nGlobeSurfaceTile.prototype.processImagery = function (\n  tile,\n  terrainProvider,\n  frameState,\n  skipLoading\n) {\n  var surfaceTile = tile.data;\n  var isUpsampledOnly = tile.upsampledFromParent;\n  var isAnyTileLoaded = false;\n  var isDoneLoading = true;\n\n  // Transition imagery states\n  var tileImageryCollection = surfaceTile.imagery;\n  var i, len;\n  for (i = 0, len = tileImageryCollection.length; i < len; ++i) {\n    var tileImagery = tileImageryCollection[i];\n    if (!defined(tileImagery.loadingImagery)) {\n      isUpsampledOnly = false;\n      continue;\n    }\n\n    if (tileImagery.loadingImagery.state === ImageryState.PLACEHOLDER) {\n      var imageryLayer = tileImagery.loadingImagery.imageryLayer;\n      if (imageryLayer.imageryProvider.ready) {\n        // Remove the placeholder and add the actual skeletons (if any)\n        // at the same position.  Then continue the loop at the same index.\n        tileImagery.freeResources();\n        tileImageryCollection.splice(i, 1);\n        imageryLayer._createTileImagerySkeletons(tile, terrainProvider, i);\n        --i;\n        len = tileImageryCollection.length;\n        continue;\n      } else {\n        isUpsampledOnly = false;\n      }\n    }\n\n    var thisTileDoneLoading = tileImagery.processStateMachine(\n      tile,\n      frameState,\n      skipLoading\n    );\n    isDoneLoading = isDoneLoading && thisTileDoneLoading;\n\n    // The imagery is renderable as soon as we have any renderable imagery for this region.\n    isAnyTileLoaded =\n      isAnyTileLoaded ||\n      thisTileDoneLoading ||\n      defined(tileImagery.readyImagery);\n\n    isUpsampledOnly =\n      isUpsampledOnly &&\n      defined(tileImagery.loadingImagery) &&\n      (tileImagery.loadingImagery.state === ImageryState.FAILED ||\n        tileImagery.loadingImagery.state === ImageryState.INVALID);\n  }\n\n  tile.upsampledFromParent = isUpsampledOnly;\n\n  // Allow rendering if any available layers are loaded\n  tile.renderable = tile.renderable && (isAnyTileLoaded || isDoneLoading);\n\n  return isDoneLoading;\n};\n\nfunction prepareNewTile(tile, terrainProvider, imageryLayerCollection) {\n  var available = terrainProvider.getTileDataAvailable(\n    tile.x,\n    tile.y,\n    tile.level\n  );\n\n  if (!defined(available) && defined(tile.parent)) {\n    // Provider doesn't know if this tile is available. Does the parent tile know?\n    var parent = tile.parent;\n    var parentSurfaceTile = parent.data;\n    if (defined(parentSurfaceTile) && defined(parentSurfaceTile.terrainData)) {\n      available = parentSurfaceTile.terrainData.isChildAvailable(\n        parent.x,\n        parent.y,\n        tile.x,\n        tile.y\n      );\n    }\n  }\n\n  if (available === false) {\n    // This tile is not available, so mark it failed so we start upsampling right away.\n    tile.data.terrainState = TerrainState.FAILED;\n  }\n\n  // Map imagery tiles to this terrain tile\n  for (var i = 0, len = imageryLayerCollection.length; i < len; ++i) {\n    var layer = imageryLayerCollection.get(i);\n    if (layer.show) {\n      layer._createTileImagerySkeletons(tile, terrainProvider);\n    }\n  }\n}\n\nfunction processTerrainStateMachine(\n  tile,\n  frameState,\n  terrainProvider,\n  imageryLayerCollection,\n  vertexArraysToDestroy\n) {\n  var surfaceTile = tile.data;\n\n  // If this tile is FAILED, we'll need to upsample from the parent. If the parent isn't\n  // ready for that, let's push it along.\n  var parent = tile.parent;\n  if (\n    surfaceTile.terrainState === TerrainState.FAILED &&\n    parent !== undefined\n  ) {\n    var parentReady =\n      parent.data !== undefined &&\n      parent.data.terrainData !== undefined &&\n      parent.data.terrainData.canUpsample !== false;\n    if (!parentReady) {\n      GlobeSurfaceTile.processStateMachine(\n        parent,\n        frameState,\n        terrainProvider,\n        imageryLayerCollection,\n        true\n      );\n    }\n  }\n\n  if (surfaceTile.terrainState === TerrainState.FAILED) {\n    upsample(\n      surfaceTile,\n      tile,\n      frameState,\n      terrainProvider,\n      tile.x,\n      tile.y,\n      tile.level\n    );\n  }\n\n  if (surfaceTile.terrainState === TerrainState.UNLOADED) {\n    requestTileGeometry(\n      surfaceTile,\n      terrainProvider,\n      tile.x,\n      tile.y,\n      tile.level\n    );\n  }\n\n  if (surfaceTile.terrainState === TerrainState.RECEIVED) {\n    transform(\n      surfaceTile,\n      frameState,\n      terrainProvider,\n      tile.x,\n      tile.y,\n      tile.level\n    );\n  }\n\n  if (surfaceTile.terrainState === TerrainState.TRANSFORMED) {\n    createResources(\n      surfaceTile,\n      frameState.context,\n      terrainProvider,\n      tile.x,\n      tile.y,\n      tile.level,\n      vertexArraysToDestroy\n    );\n  }\n\n  if (\n    surfaceTile.terrainState >= TerrainState.RECEIVED &&\n    surfaceTile.waterMaskTexture === undefined &&\n    terrainProvider.hasWaterMask\n  ) {\n    var terrainData = surfaceTile.terrainData;\n    if (terrainData.waterMask !== undefined) {\n      createWaterMaskTextureIfNeeded(frameState.context, surfaceTile);\n    } else {\n      var sourceTile = surfaceTile._findAncestorTileWithTerrainData(tile);\n      if (defined(sourceTile) && defined(sourceTile.data.waterMaskTexture)) {\n        surfaceTile.waterMaskTexture = sourceTile.data.waterMaskTexture;\n        ++surfaceTile.waterMaskTexture.referenceCount;\n        surfaceTile._computeWaterMaskTranslationAndScale(\n          tile,\n          sourceTile,\n          surfaceTile.waterMaskTranslationAndScale\n        );\n      }\n    }\n  }\n}\n\nfunction upsample(surfaceTile, tile, frameState, terrainProvider, x, y, level) {\n  var parent = tile.parent;\n  if (!parent) {\n    // Trying to upsample from a root tile. No can do. This tile is a failure.\n    tile.state = QuadtreeTileLoadState.FAILED;\n    return;\n  }\n\n  var sourceData = parent.data.terrainData;\n  var sourceX = parent.x;\n  var sourceY = parent.y;\n  var sourceLevel = parent.level;\n\n  if (!defined(sourceData)) {\n    // Parent is not available, so we can't upsample this tile yet.\n    return;\n  }\n\n  var terrainDataPromise = sourceData.upsample(\n    terrainProvider.tilingScheme,\n    sourceX,\n    sourceY,\n    sourceLevel,\n    x,\n    y,\n    level\n  );\n  if (!defined(terrainDataPromise)) {\n    // The upsample request has been deferred - try again later.\n    return;\n  }\n\n  surfaceTile.terrainState = TerrainState.RECEIVING;\n\n  when(\n    terrainDataPromise,\n    function (terrainData) {\n      surfaceTile.terrainData = terrainData;\n      surfaceTile.terrainState = TerrainState.RECEIVED;\n    },\n    function () {\n      surfaceTile.terrainState = TerrainState.FAILED;\n    }\n  );\n}\n\nfunction requestTileGeometry(surfaceTile, terrainProvider, x, y, level) {\n  function success(terrainData) {\n    surfaceTile.terrainData = terrainData;\n    surfaceTile.terrainState = TerrainState.RECEIVED;\n    surfaceTile.request = undefined;\n  }\n\n  function failure() {\n    if (surfaceTile.request.state === RequestState.CANCELLED) {\n      // Cancelled due to low priority - try again later.\n      surfaceTile.terrainData = undefined;\n      surfaceTile.terrainState = TerrainState.UNLOADED;\n      surfaceTile.request = undefined;\n      return;\n    }\n\n    // Initially assume failure.  handleError may retry, in which case the state will\n    // change to RECEIVING or UNLOADED.\n    surfaceTile.terrainState = TerrainState.FAILED;\n    surfaceTile.request = undefined;\n\n    var message =\n      \"Failed to obtain terrain tile X: \" +\n      x +\n      \" Y: \" +\n      y +\n      \" Level: \" +\n      level +\n      \".\";\n    terrainProvider._requestError = TileProviderError.handleError(\n      terrainProvider._requestError,\n      terrainProvider,\n      terrainProvider.errorEvent,\n      message,\n      x,\n      y,\n      level,\n      doRequest\n    );\n  }\n\n  function doRequest() {\n    // Request the terrain from the terrain provider.\n    var request = new Request({\n      throttle: false,\n      throttleByServer: true,\n      type: RequestType.TERRAIN,\n    });\n    surfaceTile.request = request;\n    var requestPromise = terrainProvider.requestTileGeometry(\n      x,\n      y,\n      level,\n      request\n    );\n\n    // If the request method returns undefined (instead of a promise), the request\n    // has been deferred.\n    if (defined(requestPromise)) {\n      surfaceTile.terrainState = TerrainState.RECEIVING;\n      when(requestPromise, success, failure);\n    } else {\n      // Deferred - try again later.\n      surfaceTile.terrainState = TerrainState.UNLOADED;\n      surfaceTile.request = undefined;\n    }\n  }\n\n  doRequest();\n}\n\nfunction transform(surfaceTile, frameState, terrainProvider, x, y, level) {\n  var tilingScheme = terrainProvider.tilingScheme;\n\n  var terrainData = surfaceTile.terrainData;\n  var meshPromise = terrainData.createMesh(\n    tilingScheme,\n    x,\n    y,\n    level,\n    frameState.terrainExaggeration\n  );\n\n  if (!defined(meshPromise)) {\n    // Postponed.\n    return;\n  }\n\n  surfaceTile.terrainState = TerrainState.TRANSFORMING;\n\n  when(\n    meshPromise,\n    function (mesh) {\n      surfaceTile.mesh = mesh;\n      surfaceTile.orientedBoundingBox = OrientedBoundingBox.clone(\n        mesh.orientedBoundingBox,\n        surfaceTile.orientedBoundingBox\n      );\n      surfaceTile.occludeePointInScaledSpace = Cartesian3.clone(\n        mesh.occludeePointInScaledSpace,\n        surfaceTile.occludeePointInScaledSpace\n      );\n      surfaceTile.terrainState = TerrainState.TRANSFORMED;\n    },\n    function () {\n      surfaceTile.terrainState = TerrainState.FAILED;\n    }\n  );\n}\n\nGlobeSurfaceTile._createVertexArrayForMesh = function (context, mesh) {\n  var typedArray = mesh.vertices;\n  var buffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: typedArray,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  var attributes = mesh.encoding.getAttributes(buffer);\n\n  var indexBuffers = mesh.indices.indexBuffers || {};\n  var indexBuffer = indexBuffers[context.id];\n  if (!defined(indexBuffer) || indexBuffer.isDestroyed()) {\n    var indices = mesh.indices;\n    indexBuffer = Buffer.createIndexBuffer({\n      context: context,\n      typedArray: indices,\n      usage: BufferUsage.STATIC_DRAW,\n      indexDatatype: IndexDatatype.fromSizeInBytes(indices.BYTES_PER_ELEMENT),\n    });\n    indexBuffer.vertexArrayDestroyable = false;\n    indexBuffer.referenceCount = 1;\n    indexBuffers[context.id] = indexBuffer;\n    mesh.indices.indexBuffers = indexBuffers;\n  } else {\n    ++indexBuffer.referenceCount;\n  }\n\n  return new VertexArray({\n    context: context,\n    attributes: attributes,\n    indexBuffer: indexBuffer,\n  });\n};\n\nGlobeSurfaceTile._freeVertexArray = function (vertexArray) {\n  if (defined(vertexArray)) {\n    var indexBuffer = vertexArray.indexBuffer;\n\n    vertexArray.destroy();\n\n    if (\n      defined(indexBuffer) &&\n      !indexBuffer.isDestroyed() &&\n      defined(indexBuffer.referenceCount)\n    ) {\n      --indexBuffer.referenceCount;\n      if (indexBuffer.referenceCount === 0) {\n        indexBuffer.destroy();\n      }\n    }\n  }\n};\n\nfunction createResources(\n  surfaceTile,\n  context,\n  terrainProvider,\n  x,\n  y,\n  level,\n  vertexArraysToDestroy\n) {\n  surfaceTile.vertexArray = GlobeSurfaceTile._createVertexArrayForMesh(\n    context,\n    surfaceTile.mesh\n  );\n  surfaceTile.terrainState = TerrainState.READY;\n  surfaceTile.fill =\n    surfaceTile.fill && surfaceTile.fill.destroy(vertexArraysToDestroy);\n}\n\nfunction getContextWaterMaskData(context) {\n  var data = context.cache.tile_waterMaskData;\n\n  if (!defined(data)) {\n    var allWaterTexture = Texture.create({\n      context: context,\n      pixelFormat: PixelFormat.LUMINANCE,\n      pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n      source: {\n        arrayBufferView: new Uint8Array([255]),\n        width: 1,\n        height: 1,\n      },\n    });\n    allWaterTexture.referenceCount = 1;\n\n    var sampler = new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: TextureMinificationFilter.LINEAR,\n      magnificationFilter: TextureMagnificationFilter.LINEAR,\n    });\n\n    data = {\n      allWaterTexture: allWaterTexture,\n      sampler: sampler,\n      destroy: function () {\n        this.allWaterTexture.destroy();\n      },\n    };\n\n    context.cache.tile_waterMaskData = data;\n  }\n\n  return data;\n}\n\nfunction createWaterMaskTextureIfNeeded(context, surfaceTile) {\n  var waterMask = surfaceTile.terrainData.waterMask;\n  var waterMaskData = getContextWaterMaskData(context);\n  var texture;\n\n  var waterMaskLength = waterMask.length;\n  if (waterMaskLength === 1) {\n    // Length 1 means the tile is entirely land or entirely water.\n    // A value of 0 indicates entirely land, a value of 1 indicates entirely water.\n    if (waterMask[0] !== 0) {\n      texture = waterMaskData.allWaterTexture;\n    } else {\n      // Leave the texture undefined if the tile is entirely land.\n      return;\n    }\n  } else {\n    var textureSize = Math.sqrt(waterMaskLength);\n    texture = Texture.create({\n      context: context,\n      pixelFormat: PixelFormat.LUMINANCE,\n      pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n      source: {\n        width: textureSize,\n        height: textureSize,\n        arrayBufferView: waterMask,\n      },\n      sampler: waterMaskData.sampler,\n      flipY: false,\n    });\n\n    texture.referenceCount = 0;\n  }\n\n  ++texture.referenceCount;\n  surfaceTile.waterMaskTexture = texture;\n\n  Cartesian4.fromElements(\n    0.0,\n    0.0,\n    1.0,\n    1.0,\n    surfaceTile.waterMaskTranslationAndScale\n  );\n}\n\nGlobeSurfaceTile.prototype._findAncestorTileWithTerrainData = function (tile) {\n  var sourceTile = tile.parent;\n\n  while (\n    defined(sourceTile) &&\n    (!defined(sourceTile.data) ||\n      !defined(sourceTile.data.terrainData) ||\n      sourceTile.data.terrainData.wasCreatedByUpsampling())\n  ) {\n    sourceTile = sourceTile.parent;\n  }\n\n  return sourceTile;\n};\n\nGlobeSurfaceTile.prototype._computeWaterMaskTranslationAndScale = function (\n  tile,\n  sourceTile,\n  result\n) {\n  var sourceTileRectangle = sourceTile.rectangle;\n  var tileRectangle = tile.rectangle;\n  var tileWidth = tileRectangle.width;\n  var tileHeight = tileRectangle.height;\n\n  var scaleX = tileWidth / sourceTileRectangle.width;\n  var scaleY = tileHeight / sourceTileRectangle.height;\n  result.x =\n    (scaleX * (tileRectangle.west - sourceTileRectangle.west)) / tileWidth;\n  result.y =\n    (scaleY * (tileRectangle.south - sourceTileRectangle.south)) / tileHeight;\n  result.z = scaleX;\n  result.w = scaleY;\n\n  return result;\n};\nexport default GlobeSurfaceTile;\n"]},"metadata":{},"sourceType":"module"}