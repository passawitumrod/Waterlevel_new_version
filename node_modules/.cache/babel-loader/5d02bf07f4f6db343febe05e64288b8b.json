{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2000-2005, Sean O'Neil (s_p_oneil@hotmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * * Neither the name of the project nor the names of its contributors may be\n *   used to endorse or promote products derived from this software without\n *   specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Modifications made by Analytical Graphics, Inc.\n */\n//This file is automatically rebuilt by the Cesium build process.\nexport default \"/**\\n\\\n * @license\\n\\\n * Copyright (c) 2000-2005, Sean O'Neil (s_p_oneil@hotmail.com)\\n\\\n * All rights reserved.\\n\\\n *\\n\\\n * Redistribution and use in source and binary forms, with or without\\n\\\n * modification, are permitted provided that the following conditions\\n\\\n * are met:\\n\\\n *\\n\\\n * * Redistributions of source code must retain the above copyright notice,\\n\\\n *   this list of conditions and the following disclaimer.\\n\\\n * * Redistributions in binary form must reproduce the above copyright notice,\\n\\\n *   this list of conditions and the following disclaimer in the documentation\\n\\\n *   and/or other materials provided with the distribution.\\n\\\n * * Neither the name of the project nor the names of its contributors may be\\n\\\n *   used to endorse or promote products derived from this software without\\n\\\n *   specific prior written permission.\\n\\\n *\\n\\\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\"\\n\\\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n\\\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n\\\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\\n\\\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\n\\\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\\n\\\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\\n\\\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\\n\\\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n\\\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\\\n *\\n\\\n * Modifications made by Analytical Graphics, Inc.\\n\\\n */\\n\\\n\\n\\\n // Code:  http://sponeil.net/\\n\\\n // GPU Gems 2 Article:  https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter16.html\\n\\\n\\n\\\nattribute vec4 position;\\n\\\n\\n\\\nuniform vec4 u_cameraAndRadiiAndDynamicAtmosphereColor; // Camera height, outer radius, inner radius, dynamic atmosphere color flag\\n\\\n\\n\\\nconst float Kr = 0.0025;\\n\\\nconst float Kr4PI = Kr * 4.0 * czm_pi;\\n\\\nconst float Km = 0.0015;\\n\\\nconst float Km4PI = Km * 4.0 * czm_pi;\\n\\\nconst float ESun = 15.0;\\n\\\nconst float KmESun = Km * ESun;\\n\\\nconst float KrESun = Kr * ESun;\\n\\\nconst vec3 InvWavelength = vec3(\\n\\\n    5.60204474633241,  // Red = 1.0 / Math.pow(0.650, 4.0)\\n\\\n    9.473284437923038, // Green = 1.0 / Math.pow(0.570, 4.0)\\n\\\n    19.643802610477206); // Blue = 1.0 / Math.pow(0.475, 4.0)\\n\\\nconst float rayleighScaleDepth = 0.25;\\n\\\n\\n\\\nconst int nSamples = 2;\\n\\\nconst float fSamples = 2.0;\\n\\\n\\n\\\nvarying vec3 v_rayleighColor;\\n\\\nvarying vec3 v_mieColor;\\n\\\nvarying vec3 v_toCamera;\\n\\\n\\n\\\nfloat scale(float cosAngle)\\n\\\n{\\n\\\n    float x = 1.0 - cosAngle;\\n\\\n    return rayleighScaleDepth  * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\\n\\\n}\\n\\\n\\n\\\nvoid main(void)\\n\\\n{\\n\\\n    // Unpack attributes\\n\\\n    float cameraHeight = u_cameraAndRadiiAndDynamicAtmosphereColor.x;\\n\\\n    float outerRadius = u_cameraAndRadiiAndDynamicAtmosphereColor.y;\\n\\\n    float innerRadius = u_cameraAndRadiiAndDynamicAtmosphereColor.z;\\n\\\n\\n\\\n    // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\\n\\\n    vec3 positionV3 = position.xyz;\\n\\\n    vec3 ray = positionV3 - czm_viewerPositionWC;\\n\\\n    float far = length(ray);\\n\\\n    ray /= far;\\n\\\n    float atmosphereScale = 1.0 / (outerRadius - innerRadius);\\n\\\n\\n\\\n#ifdef SKY_FROM_SPACE\\n\\\n    // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\\n\\\n    float B = 2.0 * dot(czm_viewerPositionWC, ray);\\n\\\n    float C = cameraHeight * cameraHeight - outerRadius * outerRadius;\\n\\\n    float det = max(0.0, B*B - 4.0 * C);\\n\\\n    float near = 0.5 * (-B - sqrt(det));\\n\\\n\\n\\\n    // Calculate the ray's starting position, then calculate its scattering offset\\n\\\n    vec3 start = czm_viewerPositionWC + ray * near;\\n\\\n    far -= near;\\n\\\n    float startAngle = dot(ray, start) / outerRadius;\\n\\\n    float startDepth = exp(-1.0 / rayleighScaleDepth );\\n\\\n    float startOffset = startDepth*scale(startAngle);\\n\\\n#else // SKY_FROM_ATMOSPHERE\\n\\\n    // Calculate the ray's starting position, then calculate its scattering offset\\n\\\n    vec3 start = czm_viewerPositionWC;\\n\\\n    float height = length(start);\\n\\\n    float depth = exp((atmosphereScale / rayleighScaleDepth ) * (innerRadius - cameraHeight));\\n\\\n    float startAngle = dot(ray, start) / height;\\n\\\n    float startOffset = depth*scale(startAngle);\\n\\\n#endif\\n\\\n\\n\\\n    float lightEnum = u_cameraAndRadiiAndDynamicAtmosphereColor.w;\\n\\\n    vec3 lightDirection =\\n\\\n        czm_viewerPositionWC * float(lightEnum == 0.0) +\\n\\\n        czm_lightDirectionWC * float(lightEnum == 1.0) +\\n\\\n        czm_sunDirectionWC * float(lightEnum == 2.0);\\n\\\n    lightDirection = normalize(lightDirection);\\n\\\n\\n\\\n    // Initialize the scattering loop variables\\n\\\n    float sampleLength = far / fSamples;\\n\\\n    float scaledLength = sampleLength * atmosphereScale;\\n\\\n    vec3 sampleRay = ray * sampleLength;\\n\\\n    vec3 samplePoint = start + sampleRay * 0.5;\\n\\\n\\n\\\n    // Now loop through the sample rays\\n\\\n    vec3 frontColor = vec3(0.0, 0.0, 0.0);\\n\\\n\\n\\\n    for(int i=0; i<nSamples; i++)\\n\\\n    {\\n\\\n        float height = length(samplePoint);\\n\\\n        float depth = exp((atmosphereScale / rayleighScaleDepth ) * (innerRadius - height));\\n\\\n        float fLightAngle = dot(lightDirection, samplePoint) / height;\\n\\\n        float fCameraAngle = dot(ray, samplePoint) / height;\\n\\\n        float fScatter = (startOffset + depth*(scale(fLightAngle) - scale(fCameraAngle)));\\n\\\n        vec3 attenuate = exp(-fScatter * (InvWavelength * Kr4PI + Km4PI));\\n\\\n        frontColor += attenuate * (depth * scaledLength);\\n\\\n        samplePoint += sampleRay;\\n\\\n    }\\n\\\n\\n\\\n    // Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\\n\\\n    v_mieColor = frontColor * KmESun;\\n\\\n    v_rayleighColor = frontColor * (InvWavelength * KrESun);\\n\\\n    v_toCamera = czm_viewerPositionWC - positionV3;\\n\\\n    gl_Position = czm_modelViewProjection * position;\\n\\\n}\\n\\\n\";","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Shaders/SkyAtmosphereVS.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA;AACA,eAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAAf","sourcesContent":["/**\n * @license\n * Copyright (c) 2000-2005, Sean O'Neil (s_p_oneil@hotmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * * Neither the name of the project nor the names of its contributors may be\n *   used to endorse or promote products derived from this software without\n *   specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Modifications made by Analytical Graphics, Inc.\n */\n//This file is automatically rebuilt by the Cesium build process.\nexport default \"/**\\n\\\n * @license\\n\\\n * Copyright (c) 2000-2005, Sean O'Neil (s_p_oneil@hotmail.com)\\n\\\n * All rights reserved.\\n\\\n *\\n\\\n * Redistribution and use in source and binary forms, with or without\\n\\\n * modification, are permitted provided that the following conditions\\n\\\n * are met:\\n\\\n *\\n\\\n * * Redistributions of source code must retain the above copyright notice,\\n\\\n *   this list of conditions and the following disclaimer.\\n\\\n * * Redistributions in binary form must reproduce the above copyright notice,\\n\\\n *   this list of conditions and the following disclaimer in the documentation\\n\\\n *   and/or other materials provided with the distribution.\\n\\\n * * Neither the name of the project nor the names of its contributors may be\\n\\\n *   used to endorse or promote products derived from this software without\\n\\\n *   specific prior written permission.\\n\\\n *\\n\\\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\"\\n\\\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n\\\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n\\\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\\n\\\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\n\\\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\\n\\\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\\n\\\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\\n\\\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n\\\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\\\n *\\n\\\n * Modifications made by Analytical Graphics, Inc.\\n\\\n */\\n\\\n\\n\\\n // Code:  http://sponeil.net/\\n\\\n // GPU Gems 2 Article:  https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter16.html\\n\\\n\\n\\\nattribute vec4 position;\\n\\\n\\n\\\nuniform vec4 u_cameraAndRadiiAndDynamicAtmosphereColor; // Camera height, outer radius, inner radius, dynamic atmosphere color flag\\n\\\n\\n\\\nconst float Kr = 0.0025;\\n\\\nconst float Kr4PI = Kr * 4.0 * czm_pi;\\n\\\nconst float Km = 0.0015;\\n\\\nconst float Km4PI = Km * 4.0 * czm_pi;\\n\\\nconst float ESun = 15.0;\\n\\\nconst float KmESun = Km * ESun;\\n\\\nconst float KrESun = Kr * ESun;\\n\\\nconst vec3 InvWavelength = vec3(\\n\\\n    5.60204474633241,  // Red = 1.0 / Math.pow(0.650, 4.0)\\n\\\n    9.473284437923038, // Green = 1.0 / Math.pow(0.570, 4.0)\\n\\\n    19.643802610477206); // Blue = 1.0 / Math.pow(0.475, 4.0)\\n\\\nconst float rayleighScaleDepth = 0.25;\\n\\\n\\n\\\nconst int nSamples = 2;\\n\\\nconst float fSamples = 2.0;\\n\\\n\\n\\\nvarying vec3 v_rayleighColor;\\n\\\nvarying vec3 v_mieColor;\\n\\\nvarying vec3 v_toCamera;\\n\\\n\\n\\\nfloat scale(float cosAngle)\\n\\\n{\\n\\\n    float x = 1.0 - cosAngle;\\n\\\n    return rayleighScaleDepth  * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\\n\\\n}\\n\\\n\\n\\\nvoid main(void)\\n\\\n{\\n\\\n    // Unpack attributes\\n\\\n    float cameraHeight = u_cameraAndRadiiAndDynamicAtmosphereColor.x;\\n\\\n    float outerRadius = u_cameraAndRadiiAndDynamicAtmosphereColor.y;\\n\\\n    float innerRadius = u_cameraAndRadiiAndDynamicAtmosphereColor.z;\\n\\\n\\n\\\n    // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\\n\\\n    vec3 positionV3 = position.xyz;\\n\\\n    vec3 ray = positionV3 - czm_viewerPositionWC;\\n\\\n    float far = length(ray);\\n\\\n    ray /= far;\\n\\\n    float atmosphereScale = 1.0 / (outerRadius - innerRadius);\\n\\\n\\n\\\n#ifdef SKY_FROM_SPACE\\n\\\n    // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\\n\\\n    float B = 2.0 * dot(czm_viewerPositionWC, ray);\\n\\\n    float C = cameraHeight * cameraHeight - outerRadius * outerRadius;\\n\\\n    float det = max(0.0, B*B - 4.0 * C);\\n\\\n    float near = 0.5 * (-B - sqrt(det));\\n\\\n\\n\\\n    // Calculate the ray's starting position, then calculate its scattering offset\\n\\\n    vec3 start = czm_viewerPositionWC + ray * near;\\n\\\n    far -= near;\\n\\\n    float startAngle = dot(ray, start) / outerRadius;\\n\\\n    float startDepth = exp(-1.0 / rayleighScaleDepth );\\n\\\n    float startOffset = startDepth*scale(startAngle);\\n\\\n#else // SKY_FROM_ATMOSPHERE\\n\\\n    // Calculate the ray's starting position, then calculate its scattering offset\\n\\\n    vec3 start = czm_viewerPositionWC;\\n\\\n    float height = length(start);\\n\\\n    float depth = exp((atmosphereScale / rayleighScaleDepth ) * (innerRadius - cameraHeight));\\n\\\n    float startAngle = dot(ray, start) / height;\\n\\\n    float startOffset = depth*scale(startAngle);\\n\\\n#endif\\n\\\n\\n\\\n    float lightEnum = u_cameraAndRadiiAndDynamicAtmosphereColor.w;\\n\\\n    vec3 lightDirection =\\n\\\n        czm_viewerPositionWC * float(lightEnum == 0.0) +\\n\\\n        czm_lightDirectionWC * float(lightEnum == 1.0) +\\n\\\n        czm_sunDirectionWC * float(lightEnum == 2.0);\\n\\\n    lightDirection = normalize(lightDirection);\\n\\\n\\n\\\n    // Initialize the scattering loop variables\\n\\\n    float sampleLength = far / fSamples;\\n\\\n    float scaledLength = sampleLength * atmosphereScale;\\n\\\n    vec3 sampleRay = ray * sampleLength;\\n\\\n    vec3 samplePoint = start + sampleRay * 0.5;\\n\\\n\\n\\\n    // Now loop through the sample rays\\n\\\n    vec3 frontColor = vec3(0.0, 0.0, 0.0);\\n\\\n\\n\\\n    for(int i=0; i<nSamples; i++)\\n\\\n    {\\n\\\n        float height = length(samplePoint);\\n\\\n        float depth = exp((atmosphereScale / rayleighScaleDepth ) * (innerRadius - height));\\n\\\n        float fLightAngle = dot(lightDirection, samplePoint) / height;\\n\\\n        float fCameraAngle = dot(ray, samplePoint) / height;\\n\\\n        float fScatter = (startOffset + depth*(scale(fLightAngle) - scale(fCameraAngle)));\\n\\\n        vec3 attenuate = exp(-fScatter * (InvWavelength * Kr4PI + Km4PI));\\n\\\n        frontColor += attenuate * (depth * scaledLength);\\n\\\n        samplePoint += sampleRay;\\n\\\n    }\\n\\\n\\n\\\n    // Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\\n\\\n    v_mieColor = frontColor * KmESun;\\n\\\n    v_rayleighColor = frontColor * (InvWavelength * KrESun);\\n\\\n    v_toCamera = czm_viewerPositionWC - positionV3;\\n\\\n    gl_Position = czm_modelViewProjection * position;\\n\\\n}\\n\\\n\";\n"]},"metadata":{},"sourceType":"module"}