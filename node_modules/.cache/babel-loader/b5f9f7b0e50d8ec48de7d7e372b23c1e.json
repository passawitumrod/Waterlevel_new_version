{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Interval from \"./Interval.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport QuadraticRealPolynomial from \"./QuadraticRealPolynomial.js\";\nimport QuarticRealPolynomial from \"./QuarticRealPolynomial.js\";\nimport Ray from \"./Ray.js\";\n/**\n * Functions for computing the intersection between geometries such as rays, planes, triangles, and ellipsoids.\n *\n * @exports IntersectionTests\n * @namespace\n */\n\nvar IntersectionTests = {};\n/**\n * Computes the intersection of a ray and a plane.\n *\n * @param {Ray} ray The ray.\n * @param {Plane} plane The plane.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\n\nIntersectionTests.rayPlane = function (ray, plane, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n\n  if (!defined(plane)) {\n    throw new DeveloperError(\"plane is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  var origin = ray.origin;\n  var direction = ray.direction;\n  var normal = plane.normal;\n  var denominator = Cartesian3.dot(normal, direction);\n\n  if (Math.abs(denominator) < CesiumMath.EPSILON15) {\n    // Ray is parallel to plane.  The ray may be in the polygon's plane.\n    return undefined;\n  }\n\n  var t = (-plane.distance - Cartesian3.dot(normal, origin)) / denominator;\n\n  if (t < 0) {\n    return undefined;\n  }\n\n  result = Cartesian3.multiplyByScalar(direction, t, result);\n  return Cartesian3.add(origin, result, result);\n};\n\nvar scratchEdge0 = new Cartesian3();\nvar scratchEdge1 = new Cartesian3();\nvar scratchPVec = new Cartesian3();\nvar scratchTVec = new Cartesian3();\nvar scratchQVec = new Cartesian3();\n/**\n * Computes the intersection of a ray and a triangle as a parametric distance along the input ray. The result is negative when the triangle is behind the ray.\n *\n * Implements {@link https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf|\n * Fast Minimum Storage Ray/Triangle Intersection} by Tomas Moller and Ben Trumbore.\n *\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {Boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @returns {Number} The intersection as a parametric distance along the ray, or undefined if there is no intersection.\n */\n\nIntersectionTests.rayTriangleParametric = function (ray, p0, p1, p2, cullBackFaces) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n\n  if (!defined(p0)) {\n    throw new DeveloperError(\"p0 is required.\");\n  }\n\n  if (!defined(p1)) {\n    throw new DeveloperError(\"p1 is required.\");\n  }\n\n  if (!defined(p2)) {\n    throw new DeveloperError(\"p2 is required.\");\n  } //>>includeEnd('debug');\n\n\n  cullBackFaces = defaultValue(cullBackFaces, false);\n  var origin = ray.origin;\n  var direction = ray.direction;\n  var edge0 = Cartesian3.subtract(p1, p0, scratchEdge0);\n  var edge1 = Cartesian3.subtract(p2, p0, scratchEdge1);\n  var p = Cartesian3.cross(direction, edge1, scratchPVec);\n  var det = Cartesian3.dot(edge0, p);\n  var tvec;\n  var q;\n  var u;\n  var v;\n  var t;\n\n  if (cullBackFaces) {\n    if (det < CesiumMath.EPSILON6) {\n      return undefined;\n    }\n\n    tvec = Cartesian3.subtract(origin, p0, scratchTVec);\n    u = Cartesian3.dot(tvec, p);\n\n    if (u < 0.0 || u > det) {\n      return undefined;\n    }\n\n    q = Cartesian3.cross(tvec, edge0, scratchQVec);\n    v = Cartesian3.dot(direction, q);\n\n    if (v < 0.0 || u + v > det) {\n      return undefined;\n    }\n\n    t = Cartesian3.dot(edge1, q) / det;\n  } else {\n    if (Math.abs(det) < CesiumMath.EPSILON6) {\n      return undefined;\n    }\n\n    var invDet = 1.0 / det;\n    tvec = Cartesian3.subtract(origin, p0, scratchTVec);\n    u = Cartesian3.dot(tvec, p) * invDet;\n\n    if (u < 0.0 || u > 1.0) {\n      return undefined;\n    }\n\n    q = Cartesian3.cross(tvec, edge0, scratchQVec);\n    v = Cartesian3.dot(direction, q) * invDet;\n\n    if (v < 0.0 || u + v > 1.0) {\n      return undefined;\n    }\n\n    t = Cartesian3.dot(edge1, q) * invDet;\n  }\n\n  return t;\n};\n/**\n * Computes the intersection of a ray and a triangle as a Cartesian3 coordinate.\n *\n * Implements {@link https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf|\n * Fast Minimum Storage Ray/Triangle Intersection} by Tomas Moller and Ben Trumbore.\n *\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {Boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @param {Cartesian3} [result] The <code>Cartesian3</code> onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\n\n\nIntersectionTests.rayTriangle = function (ray, p0, p1, p2, cullBackFaces, result) {\n  var t = IntersectionTests.rayTriangleParametric(ray, p0, p1, p2, cullBackFaces);\n\n  if (!defined(t) || t < 0.0) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  Cartesian3.multiplyByScalar(ray.direction, t, result);\n  return Cartesian3.add(ray.origin, result, result);\n};\n\nvar scratchLineSegmentTriangleRay = new Ray();\n/**\n * Computes the intersection of a line segment and a triangle.\n * @memberof IntersectionTests\n *\n * @param {Cartesian3} v0 The an end point of the line segment.\n * @param {Cartesian3} v1 The other end point of the line segment.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {Boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @param {Cartesian3} [result] The <code>Cartesian3</code> onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\n\nIntersectionTests.lineSegmentTriangle = function (v0, v1, p0, p1, p2, cullBackFaces, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(v0)) {\n    throw new DeveloperError(\"v0 is required.\");\n  }\n\n  if (!defined(v1)) {\n    throw new DeveloperError(\"v1 is required.\");\n  }\n\n  if (!defined(p0)) {\n    throw new DeveloperError(\"p0 is required.\");\n  }\n\n  if (!defined(p1)) {\n    throw new DeveloperError(\"p1 is required.\");\n  }\n\n  if (!defined(p2)) {\n    throw new DeveloperError(\"p2 is required.\");\n  } //>>includeEnd('debug');\n\n\n  var ray = scratchLineSegmentTriangleRay;\n  Cartesian3.clone(v0, ray.origin);\n  Cartesian3.subtract(v1, v0, ray.direction);\n  Cartesian3.normalize(ray.direction, ray.direction);\n  var t = IntersectionTests.rayTriangleParametric(ray, p0, p1, p2, cullBackFaces);\n\n  if (!defined(t) || t < 0.0 || t > Cartesian3.distance(v0, v1)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  Cartesian3.multiplyByScalar(ray.direction, t, result);\n  return Cartesian3.add(ray.origin, result, result);\n};\n\nfunction solveQuadratic(a, b, c, result) {\n  var det = b * b - 4.0 * a * c;\n\n  if (det < 0.0) {\n    return undefined;\n  } else if (det > 0.0) {\n    var denom = 1.0 / (2.0 * a);\n    var disc = Math.sqrt(det);\n    var root0 = (-b + disc) * denom;\n    var root1 = (-b - disc) * denom;\n\n    if (root0 < root1) {\n      result.root0 = root0;\n      result.root1 = root1;\n    } else {\n      result.root0 = root1;\n      result.root1 = root0;\n    }\n\n    return result;\n  }\n\n  var root = -b / (2.0 * a);\n\n  if (root === 0.0) {\n    return undefined;\n  }\n\n  result.root0 = result.root1 = root;\n  return result;\n}\n\nvar raySphereRoots = {\n  root0: 0.0,\n  root1: 0.0\n};\n\nfunction raySphere(ray, sphere, result) {\n  if (!defined(result)) {\n    result = new Interval();\n  }\n\n  var origin = ray.origin;\n  var direction = ray.direction;\n  var center = sphere.center;\n  var radiusSquared = sphere.radius * sphere.radius;\n  var diff = Cartesian3.subtract(origin, center, scratchPVec);\n  var a = Cartesian3.dot(direction, direction);\n  var b = 2.0 * Cartesian3.dot(direction, diff);\n  var c = Cartesian3.magnitudeSquared(diff) - radiusSquared;\n  var roots = solveQuadratic(a, b, c, raySphereRoots);\n\n  if (!defined(roots)) {\n    return undefined;\n  }\n\n  result.start = roots.root0;\n  result.stop = roots.root1;\n  return result;\n}\n/**\n * Computes the intersection points of a ray with a sphere.\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {BoundingSphere} sphere The sphere.\n * @param {Interval} [result] The result onto which to store the result.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\n\n\nIntersectionTests.raySphere = function (ray, sphere, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n\n  if (!defined(sphere)) {\n    throw new DeveloperError(\"sphere is required.\");\n  } //>>includeEnd('debug');\n\n\n  result = raySphere(ray, sphere, result);\n\n  if (!defined(result) || result.stop < 0.0) {\n    return undefined;\n  }\n\n  result.start = Math.max(result.start, 0.0);\n  return result;\n};\n\nvar scratchLineSegmentRay = new Ray();\n/**\n * Computes the intersection points of a line segment with a sphere.\n * @memberof IntersectionTests\n *\n * @param {Cartesian3} p0 An end point of the line segment.\n * @param {Cartesian3} p1 The other end point of the line segment.\n * @param {BoundingSphere} sphere The sphere.\n * @param {Interval} [result] The result onto which to store the result.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\n\nIntersectionTests.lineSegmentSphere = function (p0, p1, sphere, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(p0)) {\n    throw new DeveloperError(\"p0 is required.\");\n  }\n\n  if (!defined(p1)) {\n    throw new DeveloperError(\"p1 is required.\");\n  }\n\n  if (!defined(sphere)) {\n    throw new DeveloperError(\"sphere is required.\");\n  } //>>includeEnd('debug');\n\n\n  var ray = scratchLineSegmentRay;\n  Cartesian3.clone(p0, ray.origin);\n  var direction = Cartesian3.subtract(p1, p0, ray.direction);\n  var maxT = Cartesian3.magnitude(direction);\n  Cartesian3.normalize(direction, direction);\n  result = raySphere(ray, sphere, result);\n\n  if (!defined(result) || result.stop < 0.0 || result.start > maxT) {\n    return undefined;\n  }\n\n  result.start = Math.max(result.start, 0.0);\n  result.stop = Math.min(result.stop, maxT);\n  return result;\n};\n\nvar scratchQ = new Cartesian3();\nvar scratchW = new Cartesian3();\n/**\n * Computes the intersection points of a ray with an ellipsoid.\n *\n * @param {Ray} ray The ray.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\n\nIntersectionTests.rayEllipsoid = function (ray, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n\n  if (!defined(ellipsoid)) {\n    throw new DeveloperError(\"ellipsoid is required.\");\n  } //>>includeEnd('debug');\n\n\n  var inverseRadii = ellipsoid.oneOverRadii;\n  var q = Cartesian3.multiplyComponents(inverseRadii, ray.origin, scratchQ);\n  var w = Cartesian3.multiplyComponents(inverseRadii, ray.direction, scratchW);\n  var q2 = Cartesian3.magnitudeSquared(q);\n  var qw = Cartesian3.dot(q, w);\n  var difference, w2, product, discriminant, temp;\n\n  if (q2 > 1.0) {\n    // Outside ellipsoid.\n    if (qw >= 0.0) {\n      // Looking outward or tangent (0 intersections).\n      return undefined;\n    } // qw < 0.0.\n\n\n    var qw2 = qw * qw;\n    difference = q2 - 1.0; // Positively valued.\n\n    w2 = Cartesian3.magnitudeSquared(w);\n    product = w2 * difference;\n\n    if (qw2 < product) {\n      // Imaginary roots (0 intersections).\n      return undefined;\n    } else if (qw2 > product) {\n      // Distinct roots (2 intersections).\n      discriminant = qw * qw - product;\n      temp = -qw + Math.sqrt(discriminant); // Avoid cancellation.\n\n      var root0 = temp / w2;\n      var root1 = difference / temp;\n\n      if (root0 < root1) {\n        return new Interval(root0, root1);\n      }\n\n      return {\n        start: root1,\n        stop: root0\n      };\n    } // qw2 == product.  Repeated roots (2 intersections).\n\n\n    var root = Math.sqrt(difference / w2);\n    return new Interval(root, root);\n  } else if (q2 < 1.0) {\n    // Inside ellipsoid (2 intersections).\n    difference = q2 - 1.0; // Negatively valued.\n\n    w2 = Cartesian3.magnitudeSquared(w);\n    product = w2 * difference; // Negatively valued.\n\n    discriminant = qw * qw - product;\n    temp = -qw + Math.sqrt(discriminant); // Positively valued.\n\n    return new Interval(0.0, temp / w2);\n  } // q2 == 1.0. On ellipsoid.\n\n\n  if (qw < 0.0) {\n    // Looking inward.\n    w2 = Cartesian3.magnitudeSquared(w);\n    return new Interval(0.0, -qw / w2);\n  } // qw >= 0.0.  Looking outward or tangent.\n\n\n  return undefined;\n};\n\nfunction addWithCancellationCheck(left, right, tolerance) {\n  var difference = left + right;\n\n  if (CesiumMath.sign(left) !== CesiumMath.sign(right) && Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance) {\n    return 0.0;\n  }\n\n  return difference;\n}\n\nfunction quadraticVectorExpression(A, b, c, x, w) {\n  var xSquared = x * x;\n  var wSquared = w * w;\n  var l2 = (A[Matrix3.COLUMN1ROW1] - A[Matrix3.COLUMN2ROW2]) * wSquared;\n  var l1 = w * (x * addWithCancellationCheck(A[Matrix3.COLUMN1ROW0], A[Matrix3.COLUMN0ROW1], CesiumMath.EPSILON15) + b.y);\n  var l0 = A[Matrix3.COLUMN0ROW0] * xSquared + A[Matrix3.COLUMN2ROW2] * wSquared + x * b.x + c;\n  var r1 = wSquared * addWithCancellationCheck(A[Matrix3.COLUMN2ROW1], A[Matrix3.COLUMN1ROW2], CesiumMath.EPSILON15);\n  var r0 = w * (x * addWithCancellationCheck(A[Matrix3.COLUMN2ROW0], A[Matrix3.COLUMN0ROW2]) + b.z);\n  var cosines;\n  var solutions = [];\n\n  if (r0 === 0.0 && r1 === 0.0) {\n    cosines = QuadraticRealPolynomial.computeRealRoots(l2, l1, l0);\n\n    if (cosines.length === 0) {\n      return solutions;\n    }\n\n    var cosine0 = cosines[0];\n    var sine0 = Math.sqrt(Math.max(1.0 - cosine0 * cosine0, 0.0));\n    solutions.push(new Cartesian3(x, w * cosine0, w * -sine0));\n    solutions.push(new Cartesian3(x, w * cosine0, w * sine0));\n\n    if (cosines.length === 2) {\n      var cosine1 = cosines[1];\n      var sine1 = Math.sqrt(Math.max(1.0 - cosine1 * cosine1, 0.0));\n      solutions.push(new Cartesian3(x, w * cosine1, w * -sine1));\n      solutions.push(new Cartesian3(x, w * cosine1, w * sine1));\n    }\n\n    return solutions;\n  }\n\n  var r0Squared = r0 * r0;\n  var r1Squared = r1 * r1;\n  var l2Squared = l2 * l2;\n  var r0r1 = r0 * r1;\n  var c4 = l2Squared + r1Squared;\n  var c3 = 2.0 * (l1 * l2 + r0r1);\n  var c2 = 2.0 * l0 * l2 + l1 * l1 - r1Squared + r0Squared;\n  var c1 = 2.0 * (l0 * l1 - r0r1);\n  var c0 = l0 * l0 - r0Squared;\n\n  if (c4 === 0.0 && c3 === 0.0 && c2 === 0.0 && c1 === 0.0) {\n    return solutions;\n  }\n\n  cosines = QuarticRealPolynomial.computeRealRoots(c4, c3, c2, c1, c0);\n  var length = cosines.length;\n\n  if (length === 0) {\n    return solutions;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    var cosine = cosines[i];\n    var cosineSquared = cosine * cosine;\n    var sineSquared = Math.max(1.0 - cosineSquared, 0.0);\n    var sine = Math.sqrt(sineSquared); //var left = l2 * cosineSquared + l1 * cosine + l0;\n\n    var left;\n\n    if (CesiumMath.sign(l2) === CesiumMath.sign(l0)) {\n      left = addWithCancellationCheck(l2 * cosineSquared + l0, l1 * cosine, CesiumMath.EPSILON12);\n    } else if (CesiumMath.sign(l0) === CesiumMath.sign(l1 * cosine)) {\n      left = addWithCancellationCheck(l2 * cosineSquared, l1 * cosine + l0, CesiumMath.EPSILON12);\n    } else {\n      left = addWithCancellationCheck(l2 * cosineSquared + l1 * cosine, l0, CesiumMath.EPSILON12);\n    }\n\n    var right = addWithCancellationCheck(r1 * cosine, r0, CesiumMath.EPSILON15);\n    var product = left * right;\n\n    if (product < 0.0) {\n      solutions.push(new Cartesian3(x, w * cosine, w * sine));\n    } else if (product > 0.0) {\n      solutions.push(new Cartesian3(x, w * cosine, w * -sine));\n    } else if (sine !== 0.0) {\n      solutions.push(new Cartesian3(x, w * cosine, w * -sine));\n      solutions.push(new Cartesian3(x, w * cosine, w * sine));\n      ++i;\n    } else {\n      solutions.push(new Cartesian3(x, w * cosine, w * sine));\n    }\n  }\n\n  return solutions;\n}\n\nvar firstAxisScratch = new Cartesian3();\nvar secondAxisScratch = new Cartesian3();\nvar thirdAxisScratch = new Cartesian3();\nvar referenceScratch = new Cartesian3();\nvar bCart = new Cartesian3();\nvar bScratch = new Matrix3();\nvar btScratch = new Matrix3();\nvar diScratch = new Matrix3();\nvar dScratch = new Matrix3();\nvar cScratch = new Matrix3();\nvar tempMatrix = new Matrix3();\nvar aScratch = new Matrix3();\nvar sScratch = new Cartesian3();\nvar closestScratch = new Cartesian3();\nvar surfPointScratch = new Cartographic();\n/**\n * Provides the point along the ray which is nearest to the ellipsoid.\n *\n * @param {Ray} ray The ray.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @returns {Cartesian3} The nearest planetodetic point on the ray.\n */\n\nIntersectionTests.grazingAltitudeLocation = function (ray, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n\n  if (!defined(ellipsoid)) {\n    throw new DeveloperError(\"ellipsoid is required.\");\n  } //>>includeEnd('debug');\n\n\n  var position = ray.origin;\n  var direction = ray.direction;\n\n  if (!Cartesian3.equals(position, Cartesian3.ZERO)) {\n    var normal = ellipsoid.geodeticSurfaceNormal(position, firstAxisScratch);\n\n    if (Cartesian3.dot(direction, normal) >= 0.0) {\n      // The location provided is the closest point in altitude\n      return position;\n    }\n  }\n\n  var intersects = defined(this.rayEllipsoid(ray, ellipsoid)); // Compute the scaled direction vector.\n\n  var f = ellipsoid.transformPositionToScaledSpace(direction, firstAxisScratch); // Constructs a basis from the unit scaled direction vector. Construct its rotation and transpose.\n\n  var firstAxis = Cartesian3.normalize(f, f);\n  var reference = Cartesian3.mostOrthogonalAxis(f, referenceScratch);\n  var secondAxis = Cartesian3.normalize(Cartesian3.cross(reference, firstAxis, secondAxisScratch), secondAxisScratch);\n  var thirdAxis = Cartesian3.normalize(Cartesian3.cross(firstAxis, secondAxis, thirdAxisScratch), thirdAxisScratch);\n  var B = bScratch;\n  B[0] = firstAxis.x;\n  B[1] = firstAxis.y;\n  B[2] = firstAxis.z;\n  B[3] = secondAxis.x;\n  B[4] = secondAxis.y;\n  B[5] = secondAxis.z;\n  B[6] = thirdAxis.x;\n  B[7] = thirdAxis.y;\n  B[8] = thirdAxis.z;\n  var B_T = Matrix3.transpose(B, btScratch); // Get the scaling matrix and its inverse.\n\n  var D_I = Matrix3.fromScale(ellipsoid.radii, diScratch);\n  var D = Matrix3.fromScale(ellipsoid.oneOverRadii, dScratch);\n  var C = cScratch;\n  C[0] = 0.0;\n  C[1] = -direction.z;\n  C[2] = direction.y;\n  C[3] = direction.z;\n  C[4] = 0.0;\n  C[5] = -direction.x;\n  C[6] = -direction.y;\n  C[7] = direction.x;\n  C[8] = 0.0;\n  var temp = Matrix3.multiply(Matrix3.multiply(B_T, D, tempMatrix), C, tempMatrix);\n  var A = Matrix3.multiply(Matrix3.multiply(temp, D_I, aScratch), B, aScratch);\n  var b = Matrix3.multiplyByVector(temp, position, bCart); // Solve for the solutions to the expression in standard form:\n\n  var solutions = quadraticVectorExpression(A, Cartesian3.negate(b, firstAxisScratch), 0.0, 0.0, 1.0);\n  var s;\n  var altitude;\n  var length = solutions.length;\n\n  if (length > 0) {\n    var closest = Cartesian3.clone(Cartesian3.ZERO, closestScratch);\n    var maximumValue = Number.NEGATIVE_INFINITY;\n\n    for (var i = 0; i < length; ++i) {\n      s = Matrix3.multiplyByVector(D_I, Matrix3.multiplyByVector(B, solutions[i], sScratch), sScratch);\n      var v = Cartesian3.normalize(Cartesian3.subtract(s, position, referenceScratch), referenceScratch);\n      var dotProduct = Cartesian3.dot(v, direction);\n\n      if (dotProduct > maximumValue) {\n        maximumValue = dotProduct;\n        closest = Cartesian3.clone(s, closest);\n      }\n    }\n\n    var surfacePoint = ellipsoid.cartesianToCartographic(closest, surfPointScratch);\n    maximumValue = CesiumMath.clamp(maximumValue, 0.0, 1.0);\n    altitude = Cartesian3.magnitude(Cartesian3.subtract(closest, position, referenceScratch)) * Math.sqrt(1.0 - maximumValue * maximumValue);\n    altitude = intersects ? -altitude : altitude;\n    surfacePoint.height = altitude;\n    return ellipsoid.cartographicToCartesian(surfacePoint, new Cartesian3());\n  }\n\n  return undefined;\n};\n\nvar lineSegmentPlaneDifference = new Cartesian3();\n/**\n * Computes the intersection of a line segment and a plane.\n *\n * @param {Cartesian3} endPoint0 An end point of the line segment.\n * @param {Cartesian3} endPoint1 The other end point of the line segment.\n * @param {Plane} plane The plane.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersection.\n *\n * @example\n * var origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n * var normal = ellipsoid.geodeticSurfaceNormal(origin);\n * var plane = Cesium.Plane.fromPointNormal(origin, normal);\n *\n * var p0 = new Cesium.Cartesian3(...);\n * var p1 = new Cesium.Cartesian3(...);\n *\n * // find the intersection of the line segment from p0 to p1 and the tangent plane at origin.\n * var intersection = Cesium.IntersectionTests.lineSegmentPlane(p0, p1, plane);\n */\n\nIntersectionTests.lineSegmentPlane = function (endPoint0, endPoint1, plane, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(endPoint0)) {\n    throw new DeveloperError(\"endPoint0 is required.\");\n  }\n\n  if (!defined(endPoint1)) {\n    throw new DeveloperError(\"endPoint1 is required.\");\n  }\n\n  if (!defined(plane)) {\n    throw new DeveloperError(\"plane is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  var difference = Cartesian3.subtract(endPoint1, endPoint0, lineSegmentPlaneDifference);\n  var normal = plane.normal;\n  var nDotDiff = Cartesian3.dot(normal, difference); // check if the segment and plane are parallel\n\n  if (Math.abs(nDotDiff) < CesiumMath.EPSILON6) {\n    return undefined;\n  }\n\n  var nDotP0 = Cartesian3.dot(normal, endPoint0);\n  var t = -(plane.distance + nDotP0) / nDotDiff; // intersection only if t is in [0, 1]\n\n  if (t < 0.0 || t > 1.0) {\n    return undefined;\n  } // intersection is endPoint0 + t * (endPoint1 - endPoint0)\n\n\n  Cartesian3.multiplyByScalar(difference, t, result);\n  Cartesian3.add(endPoint0, result, result);\n  return result;\n};\n/**\n * Computes the intersection of a triangle and a plane\n *\n * @param {Cartesian3} p0 First point of the triangle\n * @param {Cartesian3} p1 Second point of the triangle\n * @param {Cartesian3} p2 Third point of the triangle\n * @param {Plane} plane Intersection plane\n * @returns {Object} An object with properties <code>positions</code> and <code>indices</code>, which are arrays that represent three triangles that do not cross the plane. (Undefined if no intersection exists)\n *\n * @example\n * var origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n * var normal = ellipsoid.geodeticSurfaceNormal(origin);\n * var plane = Cesium.Plane.fromPointNormal(origin, normal);\n *\n * var p0 = new Cesium.Cartesian3(...);\n * var p1 = new Cesium.Cartesian3(...);\n * var p2 = new Cesium.Cartesian3(...);\n *\n * // convert the triangle composed of points (p0, p1, p2) to three triangles that don't cross the plane\n * var triangles = Cesium.IntersectionTests.trianglePlaneIntersection(p0, p1, p2, plane);\n */\n\n\nIntersectionTests.trianglePlaneIntersection = function (p0, p1, p2, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(p0) || !defined(p1) || !defined(p2) || !defined(plane)) {\n    throw new DeveloperError(\"p0, p1, p2, and plane are required.\");\n  } //>>includeEnd('debug');\n\n\n  var planeNormal = plane.normal;\n  var planeD = plane.distance;\n  var p0Behind = Cartesian3.dot(planeNormal, p0) + planeD < 0.0;\n  var p1Behind = Cartesian3.dot(planeNormal, p1) + planeD < 0.0;\n  var p2Behind = Cartesian3.dot(planeNormal, p2) + planeD < 0.0; // Given these dots products, the calls to lineSegmentPlaneIntersection\n  // always have defined results.\n\n  var numBehind = 0;\n  numBehind += p0Behind ? 1 : 0;\n  numBehind += p1Behind ? 1 : 0;\n  numBehind += p2Behind ? 1 : 0;\n  var u1, u2;\n\n  if (numBehind === 1 || numBehind === 2) {\n    u1 = new Cartesian3();\n    u2 = new Cartesian3();\n  }\n\n  if (numBehind === 1) {\n    if (p0Behind) {\n      IntersectionTests.lineSegmentPlane(p0, p1, plane, u1);\n      IntersectionTests.lineSegmentPlane(p0, p2, plane, u2);\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [// Behind\n        0, 3, 4, // In front\n        1, 2, 4, 1, 4, 3]\n      };\n    } else if (p1Behind) {\n      IntersectionTests.lineSegmentPlane(p1, p2, plane, u1);\n      IntersectionTests.lineSegmentPlane(p1, p0, plane, u2);\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [// Behind\n        1, 3, 4, // In front\n        2, 0, 4, 2, 4, 3]\n      };\n    } else if (p2Behind) {\n      IntersectionTests.lineSegmentPlane(p2, p0, plane, u1);\n      IntersectionTests.lineSegmentPlane(p2, p1, plane, u2);\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [// Behind\n        2, 3, 4, // In front\n        0, 1, 4, 0, 4, 3]\n      };\n    }\n  } else if (numBehind === 2) {\n    if (!p0Behind) {\n      IntersectionTests.lineSegmentPlane(p1, p0, plane, u1);\n      IntersectionTests.lineSegmentPlane(p2, p0, plane, u2);\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [// Behind\n        1, 2, 4, 1, 4, 3, // In front\n        0, 3, 4]\n      };\n    } else if (!p1Behind) {\n      IntersectionTests.lineSegmentPlane(p2, p1, plane, u1);\n      IntersectionTests.lineSegmentPlane(p0, p1, plane, u2);\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [// Behind\n        2, 0, 4, 2, 4, 3, // In front\n        1, 3, 4]\n      };\n    } else if (!p2Behind) {\n      IntersectionTests.lineSegmentPlane(p0, p2, plane, u1);\n      IntersectionTests.lineSegmentPlane(p1, p2, plane, u2);\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [// Behind\n        0, 1, 4, 0, 4, 3, // In front\n        2, 3, 4]\n      };\n    }\n  } // if numBehind is 3, the triangle is completely behind the plane;\n  // otherwise, it is completely in front (numBehind is 0).\n\n\n  return undefined;\n};\n\nexport default IntersectionTests;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/IntersectionTests.js"],"names":["Cartesian3","Cartographic","defaultValue","defined","DeveloperError","Interval","CesiumMath","Matrix3","QuadraticRealPolynomial","QuarticRealPolynomial","Ray","IntersectionTests","rayPlane","ray","plane","result","origin","direction","normal","denominator","dot","Math","abs","EPSILON15","undefined","t","distance","multiplyByScalar","add","scratchEdge0","scratchEdge1","scratchPVec","scratchTVec","scratchQVec","rayTriangleParametric","p0","p1","p2","cullBackFaces","edge0","subtract","edge1","p","cross","det","tvec","q","u","v","EPSILON6","invDet","rayTriangle","scratchLineSegmentTriangleRay","lineSegmentTriangle","v0","v1","clone","normalize","solveQuadratic","a","b","c","denom","disc","sqrt","root0","root1","root","raySphereRoots","raySphere","sphere","center","radiusSquared","radius","diff","magnitudeSquared","roots","start","stop","max","scratchLineSegmentRay","lineSegmentSphere","maxT","magnitude","min","scratchQ","scratchW","rayEllipsoid","ellipsoid","inverseRadii","oneOverRadii","multiplyComponents","w","q2","qw","difference","w2","product","discriminant","temp","qw2","addWithCancellationCheck","left","right","tolerance","sign","quadraticVectorExpression","A","x","xSquared","wSquared","l2","COLUMN1ROW1","COLUMN2ROW2","l1","COLUMN1ROW0","COLUMN0ROW1","y","l0","COLUMN0ROW0","r1","COLUMN2ROW1","COLUMN1ROW2","r0","COLUMN2ROW0","COLUMN0ROW2","z","cosines","solutions","computeRealRoots","length","cosine0","sine0","push","cosine1","sine1","r0Squared","r1Squared","l2Squared","r0r1","c4","c3","c2","c1","c0","i","cosine","cosineSquared","sineSquared","sine","EPSILON12","firstAxisScratch","secondAxisScratch","thirdAxisScratch","referenceScratch","bCart","bScratch","btScratch","diScratch","dScratch","cScratch","tempMatrix","aScratch","sScratch","closestScratch","surfPointScratch","grazingAltitudeLocation","position","equals","ZERO","geodeticSurfaceNormal","intersects","f","transformPositionToScaledSpace","firstAxis","reference","mostOrthogonalAxis","secondAxis","thirdAxis","B","B_T","transpose","D_I","fromScale","radii","D","C","multiply","multiplyByVector","negate","s","altitude","closest","maximumValue","Number","NEGATIVE_INFINITY","dotProduct","surfacePoint","cartesianToCartographic","clamp","height","cartographicToCartesian","lineSegmentPlaneDifference","lineSegmentPlane","endPoint0","endPoint1","nDotDiff","nDotP0","trianglePlaneIntersection","planeNormal","planeD","p0Behind","p1Behind","p2Behind","numBehind","u1","u2","positions","indices"],"mappings":"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","sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Interval from \"./Interval.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport QuadraticRealPolynomial from \"./QuadraticRealPolynomial.js\";\nimport QuarticRealPolynomial from \"./QuarticRealPolynomial.js\";\nimport Ray from \"./Ray.js\";\n\n/**\n * Functions for computing the intersection between geometries such as rays, planes, triangles, and ellipsoids.\n *\n * @exports IntersectionTests\n * @namespace\n */\nvar IntersectionTests = {};\n\n/**\n * Computes the intersection of a ray and a plane.\n *\n * @param {Ray} ray The ray.\n * @param {Plane} plane The plane.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\nIntersectionTests.rayPlane = function (ray, plane, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(plane)) {\n    throw new DeveloperError(\"plane is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  var origin = ray.origin;\n  var direction = ray.direction;\n  var normal = plane.normal;\n  var denominator = Cartesian3.dot(normal, direction);\n\n  if (Math.abs(denominator) < CesiumMath.EPSILON15) {\n    // Ray is parallel to plane.  The ray may be in the polygon's plane.\n    return undefined;\n  }\n\n  var t = (-plane.distance - Cartesian3.dot(normal, origin)) / denominator;\n\n  if (t < 0) {\n    return undefined;\n  }\n\n  result = Cartesian3.multiplyByScalar(direction, t, result);\n  return Cartesian3.add(origin, result, result);\n};\n\nvar scratchEdge0 = new Cartesian3();\nvar scratchEdge1 = new Cartesian3();\nvar scratchPVec = new Cartesian3();\nvar scratchTVec = new Cartesian3();\nvar scratchQVec = new Cartesian3();\n\n/**\n * Computes the intersection of a ray and a triangle as a parametric distance along the input ray. The result is negative when the triangle is behind the ray.\n *\n * Implements {@link https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf|\n * Fast Minimum Storage Ray/Triangle Intersection} by Tomas Moller and Ben Trumbore.\n *\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {Boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @returns {Number} The intersection as a parametric distance along the ray, or undefined if there is no intersection.\n */\nIntersectionTests.rayTriangleParametric = function (\n  ray,\n  p0,\n  p1,\n  p2,\n  cullBackFaces\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(p0)) {\n    throw new DeveloperError(\"p0 is required.\");\n  }\n  if (!defined(p1)) {\n    throw new DeveloperError(\"p1 is required.\");\n  }\n  if (!defined(p2)) {\n    throw new DeveloperError(\"p2 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  cullBackFaces = defaultValue(cullBackFaces, false);\n\n  var origin = ray.origin;\n  var direction = ray.direction;\n\n  var edge0 = Cartesian3.subtract(p1, p0, scratchEdge0);\n  var edge1 = Cartesian3.subtract(p2, p0, scratchEdge1);\n\n  var p = Cartesian3.cross(direction, edge1, scratchPVec);\n  var det = Cartesian3.dot(edge0, p);\n\n  var tvec;\n  var q;\n\n  var u;\n  var v;\n  var t;\n\n  if (cullBackFaces) {\n    if (det < CesiumMath.EPSILON6) {\n      return undefined;\n    }\n\n    tvec = Cartesian3.subtract(origin, p0, scratchTVec);\n    u = Cartesian3.dot(tvec, p);\n    if (u < 0.0 || u > det) {\n      return undefined;\n    }\n\n    q = Cartesian3.cross(tvec, edge0, scratchQVec);\n\n    v = Cartesian3.dot(direction, q);\n    if (v < 0.0 || u + v > det) {\n      return undefined;\n    }\n\n    t = Cartesian3.dot(edge1, q) / det;\n  } else {\n    if (Math.abs(det) < CesiumMath.EPSILON6) {\n      return undefined;\n    }\n    var invDet = 1.0 / det;\n\n    tvec = Cartesian3.subtract(origin, p0, scratchTVec);\n    u = Cartesian3.dot(tvec, p) * invDet;\n    if (u < 0.0 || u > 1.0) {\n      return undefined;\n    }\n\n    q = Cartesian3.cross(tvec, edge0, scratchQVec);\n\n    v = Cartesian3.dot(direction, q) * invDet;\n    if (v < 0.0 || u + v > 1.0) {\n      return undefined;\n    }\n\n    t = Cartesian3.dot(edge1, q) * invDet;\n  }\n\n  return t;\n};\n\n/**\n * Computes the intersection of a ray and a triangle as a Cartesian3 coordinate.\n *\n * Implements {@link https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf|\n * Fast Minimum Storage Ray/Triangle Intersection} by Tomas Moller and Ben Trumbore.\n *\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {Boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @param {Cartesian3} [result] The <code>Cartesian3</code> onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\nIntersectionTests.rayTriangle = function (\n  ray,\n  p0,\n  p1,\n  p2,\n  cullBackFaces,\n  result\n) {\n  var t = IntersectionTests.rayTriangleParametric(\n    ray,\n    p0,\n    p1,\n    p2,\n    cullBackFaces\n  );\n  if (!defined(t) || t < 0.0) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  Cartesian3.multiplyByScalar(ray.direction, t, result);\n  return Cartesian3.add(ray.origin, result, result);\n};\n\nvar scratchLineSegmentTriangleRay = new Ray();\n\n/**\n * Computes the intersection of a line segment and a triangle.\n * @memberof IntersectionTests\n *\n * @param {Cartesian3} v0 The an end point of the line segment.\n * @param {Cartesian3} v1 The other end point of the line segment.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {Boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @param {Cartesian3} [result] The <code>Cartesian3</code> onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\nIntersectionTests.lineSegmentTriangle = function (\n  v0,\n  v1,\n  p0,\n  p1,\n  p2,\n  cullBackFaces,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(v0)) {\n    throw new DeveloperError(\"v0 is required.\");\n  }\n  if (!defined(v1)) {\n    throw new DeveloperError(\"v1 is required.\");\n  }\n  if (!defined(p0)) {\n    throw new DeveloperError(\"p0 is required.\");\n  }\n  if (!defined(p1)) {\n    throw new DeveloperError(\"p1 is required.\");\n  }\n  if (!defined(p2)) {\n    throw new DeveloperError(\"p2 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var ray = scratchLineSegmentTriangleRay;\n  Cartesian3.clone(v0, ray.origin);\n  Cartesian3.subtract(v1, v0, ray.direction);\n  Cartesian3.normalize(ray.direction, ray.direction);\n\n  var t = IntersectionTests.rayTriangleParametric(\n    ray,\n    p0,\n    p1,\n    p2,\n    cullBackFaces\n  );\n  if (!defined(t) || t < 0.0 || t > Cartesian3.distance(v0, v1)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  Cartesian3.multiplyByScalar(ray.direction, t, result);\n  return Cartesian3.add(ray.origin, result, result);\n};\n\nfunction solveQuadratic(a, b, c, result) {\n  var det = b * b - 4.0 * a * c;\n  if (det < 0.0) {\n    return undefined;\n  } else if (det > 0.0) {\n    var denom = 1.0 / (2.0 * a);\n    var disc = Math.sqrt(det);\n    var root0 = (-b + disc) * denom;\n    var root1 = (-b - disc) * denom;\n\n    if (root0 < root1) {\n      result.root0 = root0;\n      result.root1 = root1;\n    } else {\n      result.root0 = root1;\n      result.root1 = root0;\n    }\n\n    return result;\n  }\n\n  var root = -b / (2.0 * a);\n  if (root === 0.0) {\n    return undefined;\n  }\n\n  result.root0 = result.root1 = root;\n  return result;\n}\n\nvar raySphereRoots = {\n  root0: 0.0,\n  root1: 0.0,\n};\n\nfunction raySphere(ray, sphere, result) {\n  if (!defined(result)) {\n    result = new Interval();\n  }\n\n  var origin = ray.origin;\n  var direction = ray.direction;\n\n  var center = sphere.center;\n  var radiusSquared = sphere.radius * sphere.radius;\n\n  var diff = Cartesian3.subtract(origin, center, scratchPVec);\n\n  var a = Cartesian3.dot(direction, direction);\n  var b = 2.0 * Cartesian3.dot(direction, diff);\n  var c = Cartesian3.magnitudeSquared(diff) - radiusSquared;\n\n  var roots = solveQuadratic(a, b, c, raySphereRoots);\n  if (!defined(roots)) {\n    return undefined;\n  }\n\n  result.start = roots.root0;\n  result.stop = roots.root1;\n  return result;\n}\n\n/**\n * Computes the intersection points of a ray with a sphere.\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {BoundingSphere} sphere The sphere.\n * @param {Interval} [result] The result onto which to store the result.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\nIntersectionTests.raySphere = function (ray, sphere, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(sphere)) {\n    throw new DeveloperError(\"sphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  result = raySphere(ray, sphere, result);\n  if (!defined(result) || result.stop < 0.0) {\n    return undefined;\n  }\n\n  result.start = Math.max(result.start, 0.0);\n  return result;\n};\n\nvar scratchLineSegmentRay = new Ray();\n\n/**\n * Computes the intersection points of a line segment with a sphere.\n * @memberof IntersectionTests\n *\n * @param {Cartesian3} p0 An end point of the line segment.\n * @param {Cartesian3} p1 The other end point of the line segment.\n * @param {BoundingSphere} sphere The sphere.\n * @param {Interval} [result] The result onto which to store the result.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\nIntersectionTests.lineSegmentSphere = function (p0, p1, sphere, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(p0)) {\n    throw new DeveloperError(\"p0 is required.\");\n  }\n  if (!defined(p1)) {\n    throw new DeveloperError(\"p1 is required.\");\n  }\n  if (!defined(sphere)) {\n    throw new DeveloperError(\"sphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var ray = scratchLineSegmentRay;\n  Cartesian3.clone(p0, ray.origin);\n  var direction = Cartesian3.subtract(p1, p0, ray.direction);\n\n  var maxT = Cartesian3.magnitude(direction);\n  Cartesian3.normalize(direction, direction);\n\n  result = raySphere(ray, sphere, result);\n  if (!defined(result) || result.stop < 0.0 || result.start > maxT) {\n    return undefined;\n  }\n\n  result.start = Math.max(result.start, 0.0);\n  result.stop = Math.min(result.stop, maxT);\n  return result;\n};\n\nvar scratchQ = new Cartesian3();\nvar scratchW = new Cartesian3();\n\n/**\n * Computes the intersection points of a ray with an ellipsoid.\n *\n * @param {Ray} ray The ray.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\nIntersectionTests.rayEllipsoid = function (ray, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(ellipsoid)) {\n    throw new DeveloperError(\"ellipsoid is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var inverseRadii = ellipsoid.oneOverRadii;\n  var q = Cartesian3.multiplyComponents(inverseRadii, ray.origin, scratchQ);\n  var w = Cartesian3.multiplyComponents(inverseRadii, ray.direction, scratchW);\n\n  var q2 = Cartesian3.magnitudeSquared(q);\n  var qw = Cartesian3.dot(q, w);\n\n  var difference, w2, product, discriminant, temp;\n\n  if (q2 > 1.0) {\n    // Outside ellipsoid.\n    if (qw >= 0.0) {\n      // Looking outward or tangent (0 intersections).\n      return undefined;\n    }\n\n    // qw < 0.0.\n    var qw2 = qw * qw;\n    difference = q2 - 1.0; // Positively valued.\n    w2 = Cartesian3.magnitudeSquared(w);\n    product = w2 * difference;\n\n    if (qw2 < product) {\n      // Imaginary roots (0 intersections).\n      return undefined;\n    } else if (qw2 > product) {\n      // Distinct roots (2 intersections).\n      discriminant = qw * qw - product;\n      temp = -qw + Math.sqrt(discriminant); // Avoid cancellation.\n      var root0 = temp / w2;\n      var root1 = difference / temp;\n      if (root0 < root1) {\n        return new Interval(root0, root1);\n      }\n\n      return {\n        start: root1,\n        stop: root0,\n      };\n    }\n    // qw2 == product.  Repeated roots (2 intersections).\n    var root = Math.sqrt(difference / w2);\n    return new Interval(root, root);\n  } else if (q2 < 1.0) {\n    // Inside ellipsoid (2 intersections).\n    difference = q2 - 1.0; // Negatively valued.\n    w2 = Cartesian3.magnitudeSquared(w);\n    product = w2 * difference; // Negatively valued.\n\n    discriminant = qw * qw - product;\n    temp = -qw + Math.sqrt(discriminant); // Positively valued.\n    return new Interval(0.0, temp / w2);\n  }\n  // q2 == 1.0. On ellipsoid.\n  if (qw < 0.0) {\n    // Looking inward.\n    w2 = Cartesian3.magnitudeSquared(w);\n    return new Interval(0.0, -qw / w2);\n  }\n\n  // qw >= 0.0.  Looking outward or tangent.\n  return undefined;\n};\n\nfunction addWithCancellationCheck(left, right, tolerance) {\n  var difference = left + right;\n  if (\n    CesiumMath.sign(left) !== CesiumMath.sign(right) &&\n    Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance\n  ) {\n    return 0.0;\n  }\n\n  return difference;\n}\n\nfunction quadraticVectorExpression(A, b, c, x, w) {\n  var xSquared = x * x;\n  var wSquared = w * w;\n\n  var l2 = (A[Matrix3.COLUMN1ROW1] - A[Matrix3.COLUMN2ROW2]) * wSquared;\n  var l1 =\n    w *\n    (x *\n      addWithCancellationCheck(\n        A[Matrix3.COLUMN1ROW0],\n        A[Matrix3.COLUMN0ROW1],\n        CesiumMath.EPSILON15\n      ) +\n      b.y);\n  var l0 =\n    A[Matrix3.COLUMN0ROW0] * xSquared +\n    A[Matrix3.COLUMN2ROW2] * wSquared +\n    x * b.x +\n    c;\n\n  var r1 =\n    wSquared *\n    addWithCancellationCheck(\n      A[Matrix3.COLUMN2ROW1],\n      A[Matrix3.COLUMN1ROW2],\n      CesiumMath.EPSILON15\n    );\n  var r0 =\n    w *\n    (x *\n      addWithCancellationCheck(A[Matrix3.COLUMN2ROW0], A[Matrix3.COLUMN0ROW2]) +\n      b.z);\n\n  var cosines;\n  var solutions = [];\n  if (r0 === 0.0 && r1 === 0.0) {\n    cosines = QuadraticRealPolynomial.computeRealRoots(l2, l1, l0);\n    if (cosines.length === 0) {\n      return solutions;\n    }\n\n    var cosine0 = cosines[0];\n    var sine0 = Math.sqrt(Math.max(1.0 - cosine0 * cosine0, 0.0));\n    solutions.push(new Cartesian3(x, w * cosine0, w * -sine0));\n    solutions.push(new Cartesian3(x, w * cosine0, w * sine0));\n\n    if (cosines.length === 2) {\n      var cosine1 = cosines[1];\n      var sine1 = Math.sqrt(Math.max(1.0 - cosine1 * cosine1, 0.0));\n      solutions.push(new Cartesian3(x, w * cosine1, w * -sine1));\n      solutions.push(new Cartesian3(x, w * cosine1, w * sine1));\n    }\n\n    return solutions;\n  }\n\n  var r0Squared = r0 * r0;\n  var r1Squared = r1 * r1;\n  var l2Squared = l2 * l2;\n  var r0r1 = r0 * r1;\n\n  var c4 = l2Squared + r1Squared;\n  var c3 = 2.0 * (l1 * l2 + r0r1);\n  var c2 = 2.0 * l0 * l2 + l1 * l1 - r1Squared + r0Squared;\n  var c1 = 2.0 * (l0 * l1 - r0r1);\n  var c0 = l0 * l0 - r0Squared;\n\n  if (c4 === 0.0 && c3 === 0.0 && c2 === 0.0 && c1 === 0.0) {\n    return solutions;\n  }\n\n  cosines = QuarticRealPolynomial.computeRealRoots(c4, c3, c2, c1, c0);\n  var length = cosines.length;\n  if (length === 0) {\n    return solutions;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    var cosine = cosines[i];\n    var cosineSquared = cosine * cosine;\n    var sineSquared = Math.max(1.0 - cosineSquared, 0.0);\n    var sine = Math.sqrt(sineSquared);\n\n    //var left = l2 * cosineSquared + l1 * cosine + l0;\n    var left;\n    if (CesiumMath.sign(l2) === CesiumMath.sign(l0)) {\n      left = addWithCancellationCheck(\n        l2 * cosineSquared + l0,\n        l1 * cosine,\n        CesiumMath.EPSILON12\n      );\n    } else if (CesiumMath.sign(l0) === CesiumMath.sign(l1 * cosine)) {\n      left = addWithCancellationCheck(\n        l2 * cosineSquared,\n        l1 * cosine + l0,\n        CesiumMath.EPSILON12\n      );\n    } else {\n      left = addWithCancellationCheck(\n        l2 * cosineSquared + l1 * cosine,\n        l0,\n        CesiumMath.EPSILON12\n      );\n    }\n\n    var right = addWithCancellationCheck(r1 * cosine, r0, CesiumMath.EPSILON15);\n    var product = left * right;\n\n    if (product < 0.0) {\n      solutions.push(new Cartesian3(x, w * cosine, w * sine));\n    } else if (product > 0.0) {\n      solutions.push(new Cartesian3(x, w * cosine, w * -sine));\n    } else if (sine !== 0.0) {\n      solutions.push(new Cartesian3(x, w * cosine, w * -sine));\n      solutions.push(new Cartesian3(x, w * cosine, w * sine));\n      ++i;\n    } else {\n      solutions.push(new Cartesian3(x, w * cosine, w * sine));\n    }\n  }\n\n  return solutions;\n}\n\nvar firstAxisScratch = new Cartesian3();\nvar secondAxisScratch = new Cartesian3();\nvar thirdAxisScratch = new Cartesian3();\nvar referenceScratch = new Cartesian3();\nvar bCart = new Cartesian3();\nvar bScratch = new Matrix3();\nvar btScratch = new Matrix3();\nvar diScratch = new Matrix3();\nvar dScratch = new Matrix3();\nvar cScratch = new Matrix3();\nvar tempMatrix = new Matrix3();\nvar aScratch = new Matrix3();\nvar sScratch = new Cartesian3();\nvar closestScratch = new Cartesian3();\nvar surfPointScratch = new Cartographic();\n\n/**\n * Provides the point along the ray which is nearest to the ellipsoid.\n *\n * @param {Ray} ray The ray.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @returns {Cartesian3} The nearest planetodetic point on the ray.\n */\nIntersectionTests.grazingAltitudeLocation = function (ray, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(ellipsoid)) {\n    throw new DeveloperError(\"ellipsoid is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var position = ray.origin;\n  var direction = ray.direction;\n\n  if (!Cartesian3.equals(position, Cartesian3.ZERO)) {\n    var normal = ellipsoid.geodeticSurfaceNormal(position, firstAxisScratch);\n    if (Cartesian3.dot(direction, normal) >= 0.0) {\n      // The location provided is the closest point in altitude\n      return position;\n    }\n  }\n\n  var intersects = defined(this.rayEllipsoid(ray, ellipsoid));\n\n  // Compute the scaled direction vector.\n  var f = ellipsoid.transformPositionToScaledSpace(direction, firstAxisScratch);\n\n  // Constructs a basis from the unit scaled direction vector. Construct its rotation and transpose.\n  var firstAxis = Cartesian3.normalize(f, f);\n  var reference = Cartesian3.mostOrthogonalAxis(f, referenceScratch);\n  var secondAxis = Cartesian3.normalize(\n    Cartesian3.cross(reference, firstAxis, secondAxisScratch),\n    secondAxisScratch\n  );\n  var thirdAxis = Cartesian3.normalize(\n    Cartesian3.cross(firstAxis, secondAxis, thirdAxisScratch),\n    thirdAxisScratch\n  );\n  var B = bScratch;\n  B[0] = firstAxis.x;\n  B[1] = firstAxis.y;\n  B[2] = firstAxis.z;\n  B[3] = secondAxis.x;\n  B[4] = secondAxis.y;\n  B[5] = secondAxis.z;\n  B[6] = thirdAxis.x;\n  B[7] = thirdAxis.y;\n  B[8] = thirdAxis.z;\n\n  var B_T = Matrix3.transpose(B, btScratch);\n\n  // Get the scaling matrix and its inverse.\n  var D_I = Matrix3.fromScale(ellipsoid.radii, diScratch);\n  var D = Matrix3.fromScale(ellipsoid.oneOverRadii, dScratch);\n\n  var C = cScratch;\n  C[0] = 0.0;\n  C[1] = -direction.z;\n  C[2] = direction.y;\n  C[3] = direction.z;\n  C[4] = 0.0;\n  C[5] = -direction.x;\n  C[6] = -direction.y;\n  C[7] = direction.x;\n  C[8] = 0.0;\n\n  var temp = Matrix3.multiply(\n    Matrix3.multiply(B_T, D, tempMatrix),\n    C,\n    tempMatrix\n  );\n  var A = Matrix3.multiply(Matrix3.multiply(temp, D_I, aScratch), B, aScratch);\n  var b = Matrix3.multiplyByVector(temp, position, bCart);\n\n  // Solve for the solutions to the expression in standard form:\n  var solutions = quadraticVectorExpression(\n    A,\n    Cartesian3.negate(b, firstAxisScratch),\n    0.0,\n    0.0,\n    1.0\n  );\n\n  var s;\n  var altitude;\n  var length = solutions.length;\n  if (length > 0) {\n    var closest = Cartesian3.clone(Cartesian3.ZERO, closestScratch);\n    var maximumValue = Number.NEGATIVE_INFINITY;\n\n    for (var i = 0; i < length; ++i) {\n      s = Matrix3.multiplyByVector(\n        D_I,\n        Matrix3.multiplyByVector(B, solutions[i], sScratch),\n        sScratch\n      );\n      var v = Cartesian3.normalize(\n        Cartesian3.subtract(s, position, referenceScratch),\n        referenceScratch\n      );\n      var dotProduct = Cartesian3.dot(v, direction);\n\n      if (dotProduct > maximumValue) {\n        maximumValue = dotProduct;\n        closest = Cartesian3.clone(s, closest);\n      }\n    }\n\n    var surfacePoint = ellipsoid.cartesianToCartographic(\n      closest,\n      surfPointScratch\n    );\n    maximumValue = CesiumMath.clamp(maximumValue, 0.0, 1.0);\n    altitude =\n      Cartesian3.magnitude(\n        Cartesian3.subtract(closest, position, referenceScratch)\n      ) * Math.sqrt(1.0 - maximumValue * maximumValue);\n    altitude = intersects ? -altitude : altitude;\n    surfacePoint.height = altitude;\n    return ellipsoid.cartographicToCartesian(surfacePoint, new Cartesian3());\n  }\n\n  return undefined;\n};\n\nvar lineSegmentPlaneDifference = new Cartesian3();\n\n/**\n * Computes the intersection of a line segment and a plane.\n *\n * @param {Cartesian3} endPoint0 An end point of the line segment.\n * @param {Cartesian3} endPoint1 The other end point of the line segment.\n * @param {Plane} plane The plane.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersection.\n *\n * @example\n * var origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n * var normal = ellipsoid.geodeticSurfaceNormal(origin);\n * var plane = Cesium.Plane.fromPointNormal(origin, normal);\n *\n * var p0 = new Cesium.Cartesian3(...);\n * var p1 = new Cesium.Cartesian3(...);\n *\n * // find the intersection of the line segment from p0 to p1 and the tangent plane at origin.\n * var intersection = Cesium.IntersectionTests.lineSegmentPlane(p0, p1, plane);\n */\nIntersectionTests.lineSegmentPlane = function (\n  endPoint0,\n  endPoint1,\n  plane,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(endPoint0)) {\n    throw new DeveloperError(\"endPoint0 is required.\");\n  }\n  if (!defined(endPoint1)) {\n    throw new DeveloperError(\"endPoint1 is required.\");\n  }\n  if (!defined(plane)) {\n    throw new DeveloperError(\"plane is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  var difference = Cartesian3.subtract(\n    endPoint1,\n    endPoint0,\n    lineSegmentPlaneDifference\n  );\n  var normal = plane.normal;\n  var nDotDiff = Cartesian3.dot(normal, difference);\n\n  // check if the segment and plane are parallel\n  if (Math.abs(nDotDiff) < CesiumMath.EPSILON6) {\n    return undefined;\n  }\n\n  var nDotP0 = Cartesian3.dot(normal, endPoint0);\n  var t = -(plane.distance + nDotP0) / nDotDiff;\n\n  // intersection only if t is in [0, 1]\n  if (t < 0.0 || t > 1.0) {\n    return undefined;\n  }\n\n  // intersection is endPoint0 + t * (endPoint1 - endPoint0)\n  Cartesian3.multiplyByScalar(difference, t, result);\n  Cartesian3.add(endPoint0, result, result);\n  return result;\n};\n\n/**\n * Computes the intersection of a triangle and a plane\n *\n * @param {Cartesian3} p0 First point of the triangle\n * @param {Cartesian3} p1 Second point of the triangle\n * @param {Cartesian3} p2 Third point of the triangle\n * @param {Plane} plane Intersection plane\n * @returns {Object} An object with properties <code>positions</code> and <code>indices</code>, which are arrays that represent three triangles that do not cross the plane. (Undefined if no intersection exists)\n *\n * @example\n * var origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n * var normal = ellipsoid.geodeticSurfaceNormal(origin);\n * var plane = Cesium.Plane.fromPointNormal(origin, normal);\n *\n * var p0 = new Cesium.Cartesian3(...);\n * var p1 = new Cesium.Cartesian3(...);\n * var p2 = new Cesium.Cartesian3(...);\n *\n * // convert the triangle composed of points (p0, p1, p2) to three triangles that don't cross the plane\n * var triangles = Cesium.IntersectionTests.trianglePlaneIntersection(p0, p1, p2, plane);\n */\nIntersectionTests.trianglePlaneIntersection = function (p0, p1, p2, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(p0) || !defined(p1) || !defined(p2) || !defined(plane)) {\n    throw new DeveloperError(\"p0, p1, p2, and plane are required.\");\n  }\n  //>>includeEnd('debug');\n\n  var planeNormal = plane.normal;\n  var planeD = plane.distance;\n  var p0Behind = Cartesian3.dot(planeNormal, p0) + planeD < 0.0;\n  var p1Behind = Cartesian3.dot(planeNormal, p1) + planeD < 0.0;\n  var p2Behind = Cartesian3.dot(planeNormal, p2) + planeD < 0.0;\n  // Given these dots products, the calls to lineSegmentPlaneIntersection\n  // always have defined results.\n\n  var numBehind = 0;\n  numBehind += p0Behind ? 1 : 0;\n  numBehind += p1Behind ? 1 : 0;\n  numBehind += p2Behind ? 1 : 0;\n\n  var u1, u2;\n  if (numBehind === 1 || numBehind === 2) {\n    u1 = new Cartesian3();\n    u2 = new Cartesian3();\n  }\n\n  if (numBehind === 1) {\n    if (p0Behind) {\n      IntersectionTests.lineSegmentPlane(p0, p1, plane, u1);\n      IntersectionTests.lineSegmentPlane(p0, p2, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          0,\n          3,\n          4,\n\n          // In front\n          1,\n          2,\n          4,\n          1,\n          4,\n          3,\n        ],\n      };\n    } else if (p1Behind) {\n      IntersectionTests.lineSegmentPlane(p1, p2, plane, u1);\n      IntersectionTests.lineSegmentPlane(p1, p0, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          1,\n          3,\n          4,\n\n          // In front\n          2,\n          0,\n          4,\n          2,\n          4,\n          3,\n        ],\n      };\n    } else if (p2Behind) {\n      IntersectionTests.lineSegmentPlane(p2, p0, plane, u1);\n      IntersectionTests.lineSegmentPlane(p2, p1, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          2,\n          3,\n          4,\n\n          // In front\n          0,\n          1,\n          4,\n          0,\n          4,\n          3,\n        ],\n      };\n    }\n  } else if (numBehind === 2) {\n    if (!p0Behind) {\n      IntersectionTests.lineSegmentPlane(p1, p0, plane, u1);\n      IntersectionTests.lineSegmentPlane(p2, p0, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          1,\n          2,\n          4,\n          1,\n          4,\n          3,\n\n          // In front\n          0,\n          3,\n          4,\n        ],\n      };\n    } else if (!p1Behind) {\n      IntersectionTests.lineSegmentPlane(p2, p1, plane, u1);\n      IntersectionTests.lineSegmentPlane(p0, p1, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          2,\n          0,\n          4,\n          2,\n          4,\n          3,\n\n          // In front\n          1,\n          3,\n          4,\n        ],\n      };\n    } else if (!p2Behind) {\n      IntersectionTests.lineSegmentPlane(p0, p2, plane, u1);\n      IntersectionTests.lineSegmentPlane(p1, p2, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          0,\n          1,\n          4,\n          0,\n          4,\n          3,\n\n          // In front\n          2,\n          3,\n          4,\n        ],\n      };\n    }\n  }\n\n  // if numBehind is 3, the triangle is completely behind the plane;\n  // otherwise, it is completely in front (numBehind is 0).\n  return undefined;\n};\nexport default IntersectionTests;\n"]},"metadata":{},"sourceType":"module"}