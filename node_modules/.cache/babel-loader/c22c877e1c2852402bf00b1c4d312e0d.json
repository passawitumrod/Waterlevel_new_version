{"ast":null,"code":"import defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport TerrainQuantization from \"../Core/TerrainQuantization.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport getClippingFunction from \"./getClippingFunction.js\";\nimport SceneMode from \"./SceneMode.js\";\n\nfunction GlobeSurfaceShader(numberOfDayTextures, flags, material, shaderProgram, clippingShaderState) {\n  this.numberOfDayTextures = numberOfDayTextures;\n  this.flags = flags;\n  this.material = material;\n  this.shaderProgram = shaderProgram;\n  this.clippingShaderState = clippingShaderState;\n}\n/**\n * Manages the shaders used to shade the surface of a {@link Globe}.\n *\n * @alias GlobeSurfaceShaderSet\n * @private\n */\n\n\nfunction GlobeSurfaceShaderSet() {\n  this.baseVertexShaderSource = undefined;\n  this.baseFragmentShaderSource = undefined;\n  this._shadersByTexturesFlags = [];\n  this.material = undefined;\n}\n\nfunction getPositionMode(sceneMode) {\n  var getPosition3DMode = \"vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPosition3DMode(position, height, textureCoordinates); }\";\n  var getPositionColumbusViewAnd2DMode = \"vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPositionColumbusViewMode(position, height, textureCoordinates); }\";\n  var getPositionMorphingMode = \"vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPositionMorphingMode(position, height, textureCoordinates); }\";\n  var positionMode;\n\n  switch (sceneMode) {\n    case SceneMode.SCENE3D:\n      positionMode = getPosition3DMode;\n      break;\n\n    case SceneMode.SCENE2D:\n    case SceneMode.COLUMBUS_VIEW:\n      positionMode = getPositionColumbusViewAnd2DMode;\n      break;\n\n    case SceneMode.MORPHING:\n      positionMode = getPositionMorphingMode;\n      break;\n  }\n\n  return positionMode;\n}\n\nfunction get2DYPositionFraction(useWebMercatorProjection) {\n  var get2DYPositionFractionGeographicProjection = \"float get2DYPositionFraction(vec2 textureCoordinates) { return get2DGeographicYPositionFraction(textureCoordinates); }\";\n  var get2DYPositionFractionMercatorProjection = \"float get2DYPositionFraction(vec2 textureCoordinates) { return get2DMercatorYPositionFraction(textureCoordinates); }\";\n  return useWebMercatorProjection ? get2DYPositionFractionMercatorProjection : get2DYPositionFractionGeographicProjection;\n}\n\nGlobeSurfaceShaderSet.prototype.getShaderProgram = function (options) {\n  var frameState = options.frameState;\n  var surfaceTile = options.surfaceTile;\n  var numberOfDayTextures = options.numberOfDayTextures;\n  var applyBrightness = options.applyBrightness;\n  var applyContrast = options.applyContrast;\n  var applyHue = options.applyHue;\n  var applySaturation = options.applySaturation;\n  var applyGamma = options.applyGamma;\n  var applyAlpha = options.applyAlpha;\n  var applySplit = options.applySplit;\n  var showReflectiveOcean = options.showReflectiveOcean;\n  var showOceanWaves = options.showOceanWaves;\n  var enableLighting = options.enableLighting;\n  var dynamicAtmosphereLighting = options.dynamicAtmosphereLighting;\n  var dynamicAtmosphereLightingFromSun = options.dynamicAtmosphereLightingFromSun;\n  var showGroundAtmosphere = options.showGroundAtmosphere;\n  var perFragmentGroundAtmosphere = options.perFragmentGroundAtmosphere;\n  var hasVertexNormals = options.hasVertexNormals;\n  var useWebMercatorProjection = options.useWebMercatorProjection;\n  var enableFog = options.enableFog;\n  var enableClippingPlanes = options.enableClippingPlanes;\n  var clippingPlanes = options.clippingPlanes;\n  var clippedByBoundaries = options.clippedByBoundaries;\n  var hasImageryLayerCutout = options.hasImageryLayerCutout;\n  var colorCorrect = options.colorCorrect;\n  var highlightFillTile = options.highlightFillTile;\n  var colorToAlpha = options.colorToAlpha;\n  var quantization = 0;\n  var quantizationDefine = \"\";\n  var mesh = surfaceTile.renderedMesh;\n  var terrainEncoding = mesh.encoding;\n  var quantizationMode = terrainEncoding.quantization;\n\n  if (quantizationMode === TerrainQuantization.BITS12) {\n    quantization = 1;\n    quantizationDefine = \"QUANTIZATION_BITS12\";\n  }\n\n  var cartographicLimitRectangleFlag = 0;\n  var cartographicLimitRectangleDefine = \"\";\n\n  if (clippedByBoundaries) {\n    cartographicLimitRectangleFlag = 1;\n    cartographicLimitRectangleDefine = \"TILE_LIMIT_RECTANGLE\";\n  }\n\n  var imageryCutoutFlag = 0;\n  var imageryCutoutDefine = \"\";\n\n  if (hasImageryLayerCutout) {\n    imageryCutoutFlag = 1;\n    imageryCutoutDefine = \"APPLY_IMAGERY_CUTOUT\";\n  }\n\n  var sceneMode = frameState.mode;\n  var flags = sceneMode | applyBrightness << 2 | applyContrast << 3 | applyHue << 4 | applySaturation << 5 | applyGamma << 6 | applyAlpha << 7 | showReflectiveOcean << 8 | showOceanWaves << 9 | enableLighting << 10 | dynamicAtmosphereLighting << 11 | dynamicAtmosphereLightingFromSun << 12 | showGroundAtmosphere << 13 | perFragmentGroundAtmosphere << 14 | hasVertexNormals << 15 | useWebMercatorProjection << 16 | enableFog << 17 | quantization << 18 | applySplit << 19 | enableClippingPlanes << 20 | cartographicLimitRectangleFlag << 21 | imageryCutoutFlag << 22 | colorCorrect << 23 | highlightFillTile << 24 | colorToAlpha << 25;\n  var currentClippingShaderState = 0;\n\n  if (defined(clippingPlanes) && clippingPlanes.length > 0) {\n    currentClippingShaderState = enableClippingPlanes ? clippingPlanes.clippingPlanesState : 0;\n  }\n\n  var surfaceShader = surfaceTile.surfaceShader;\n\n  if (defined(surfaceShader) && surfaceShader.numberOfDayTextures === numberOfDayTextures && surfaceShader.flags === flags && surfaceShader.material === this.material && surfaceShader.clippingShaderState === currentClippingShaderState) {\n    return surfaceShader.shaderProgram;\n  } // New tile, or tile changed number of textures, flags, or clipping planes\n\n\n  var shadersByFlags = this._shadersByTexturesFlags[numberOfDayTextures];\n\n  if (!defined(shadersByFlags)) {\n    shadersByFlags = this._shadersByTexturesFlags[numberOfDayTextures] = [];\n  }\n\n  surfaceShader = shadersByFlags[flags];\n\n  if (!defined(surfaceShader) || surfaceShader.material !== this.material || surfaceShader.clippingShaderState !== currentClippingShaderState) {\n    // Cache miss - we've never seen this combination of numberOfDayTextures and flags before.\n    var vs = this.baseVertexShaderSource.clone();\n    var fs = this.baseFragmentShaderSource.clone();\n\n    if (currentClippingShaderState !== 0) {\n      fs.sources.unshift(getClippingFunction(clippingPlanes, frameState.context)); // Need to go before GlobeFS\n    }\n\n    vs.defines.push(quantizationDefine);\n    fs.defines.push(\"TEXTURE_UNITS \" + numberOfDayTextures, cartographicLimitRectangleDefine, imageryCutoutDefine);\n\n    if (applyBrightness) {\n      fs.defines.push(\"APPLY_BRIGHTNESS\");\n    }\n\n    if (applyContrast) {\n      fs.defines.push(\"APPLY_CONTRAST\");\n    }\n\n    if (applyHue) {\n      fs.defines.push(\"APPLY_HUE\");\n    }\n\n    if (applySaturation) {\n      fs.defines.push(\"APPLY_SATURATION\");\n    }\n\n    if (applyGamma) {\n      fs.defines.push(\"APPLY_GAMMA\");\n    }\n\n    if (applyAlpha) {\n      fs.defines.push(\"APPLY_ALPHA\");\n    }\n\n    if (showReflectiveOcean) {\n      fs.defines.push(\"SHOW_REFLECTIVE_OCEAN\");\n      vs.defines.push(\"SHOW_REFLECTIVE_OCEAN\");\n    }\n\n    if (showOceanWaves) {\n      fs.defines.push(\"SHOW_OCEAN_WAVES\");\n    }\n\n    if (colorToAlpha) {\n      fs.defines.push(\"APPLY_COLOR_TO_ALPHA\");\n    }\n\n    if (enableLighting) {\n      if (hasVertexNormals) {\n        vs.defines.push(\"ENABLE_VERTEX_LIGHTING\");\n        fs.defines.push(\"ENABLE_VERTEX_LIGHTING\");\n      } else {\n        vs.defines.push(\"ENABLE_DAYNIGHT_SHADING\");\n        fs.defines.push(\"ENABLE_DAYNIGHT_SHADING\");\n      }\n    }\n\n    if (dynamicAtmosphereLighting) {\n      fs.defines.push(\"DYNAMIC_ATMOSPHERE_LIGHTING\");\n\n      if (dynamicAtmosphereLightingFromSun) {\n        fs.defines.push(\"DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN\");\n      }\n    }\n\n    if (showGroundAtmosphere) {\n      vs.defines.push(\"GROUND_ATMOSPHERE\");\n      fs.defines.push(\"GROUND_ATMOSPHERE\");\n\n      if (perFragmentGroundAtmosphere) {\n        fs.defines.push(\"PER_FRAGMENT_GROUND_ATMOSPHERE\");\n      }\n    }\n\n    vs.defines.push(\"INCLUDE_WEB_MERCATOR_Y\");\n    fs.defines.push(\"INCLUDE_WEB_MERCATOR_Y\");\n\n    if (enableFog) {\n      vs.defines.push(\"FOG\");\n      fs.defines.push(\"FOG\");\n    }\n\n    if (applySplit) {\n      fs.defines.push(\"APPLY_SPLIT\");\n    }\n\n    if (enableClippingPlanes) {\n      fs.defines.push(\"ENABLE_CLIPPING_PLANES\");\n    }\n\n    if (colorCorrect) {\n      fs.defines.push(\"COLOR_CORRECT\");\n    }\n\n    if (highlightFillTile) {\n      fs.defines.push(\"HIGHLIGHT_FILL_TILE\");\n    }\n\n    var computeDayColor = \"\\\n    vec4 computeDayColor(vec4 initialColor, vec3 textureCoordinates)\\n\\\n    {\\n\\\n        vec4 color = initialColor;\\n\";\n\n    if (hasImageryLayerCutout) {\n      computeDayColor += \"\\\n        vec4 cutoutAndColorResult;\\n\\\n        bool texelUnclipped;\\n\";\n    }\n\n    for (var i = 0; i < numberOfDayTextures; ++i) {\n      if (hasImageryLayerCutout) {\n        computeDayColor += \"\\\n        cutoutAndColorResult = u_dayTextureCutoutRectangles[\" + i + \"];\\n\\\n        texelUnclipped = v_textureCoordinates.x < cutoutAndColorResult.x || cutoutAndColorResult.z < v_textureCoordinates.x || v_textureCoordinates.y < cutoutAndColorResult.y || cutoutAndColorResult.w < v_textureCoordinates.y;\\n\\\n        cutoutAndColorResult = sampleAndBlend(\\n\";\n      } else {\n        computeDayColor += \"\\\n        color = sampleAndBlend(\\n\";\n      }\n\n      computeDayColor += \"\\\n            color,\\n\\\n            u_dayTextures[\" + i + \"],\\n\\\n            u_dayTextureUseWebMercatorT[\" + i + \"] ? textureCoordinates.xz : textureCoordinates.xy,\\n\\\n            u_dayTextureTexCoordsRectangle[\" + i + \"],\\n\\\n            u_dayTextureTranslationAndScale[\" + i + \"],\\n\\\n            \" + (applyAlpha ? \"u_dayTextureAlpha[\" + i + \"]\" : \"1.0\") + \",\\n\\\n            \" + (applyBrightness ? \"u_dayTextureBrightness[\" + i + \"]\" : \"0.0\") + \",\\n\\\n            \" + (applyContrast ? \"u_dayTextureContrast[\" + i + \"]\" : \"0.0\") + \",\\n\\\n            \" + (applyHue ? \"u_dayTextureHue[\" + i + \"]\" : \"0.0\") + \",\\n\\\n            \" + (applySaturation ? \"u_dayTextureSaturation[\" + i + \"]\" : \"0.0\") + \",\\n\\\n            \" + (applyGamma ? \"u_dayTextureOneOverGamma[\" + i + \"]\" : \"0.0\") + \",\\n\\\n            \" + (applySplit ? \"u_dayTextureSplit[\" + i + \"]\" : \"0.0\") + \",\\n\\\n            \" + (colorToAlpha ? \"u_colorsToAlpha[\" + i + \"]\" : \"vec4(0.0)\") + \"\\n\\\n        );\\n\";\n\n      if (hasImageryLayerCutout) {\n        computeDayColor += \"\\\n        color = czm_branchFreeTernary(texelUnclipped, cutoutAndColorResult, color);\\n\";\n      }\n    }\n\n    computeDayColor += \"\\\n        return color;\\n\\\n    }\";\n    fs.sources.push(computeDayColor);\n    vs.sources.push(getPositionMode(sceneMode));\n    vs.sources.push(get2DYPositionFraction(useWebMercatorProjection));\n    var shader = ShaderProgram.fromCache({\n      context: frameState.context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n      attributeLocations: terrainEncoding.getAttributeLocations()\n    });\n    surfaceShader = shadersByFlags[flags] = new GlobeSurfaceShader(numberOfDayTextures, flags, this.material, shader, currentClippingShaderState);\n  }\n\n  surfaceTile.surfaceShader = surfaceShader;\n  return surfaceShader.shaderProgram;\n};\n\nGlobeSurfaceShaderSet.prototype.destroy = function () {\n  var flags;\n  var shader;\n  var shadersByTexturesFlags = this._shadersByTexturesFlags;\n\n  for (var textureCount in shadersByTexturesFlags) {\n    if (shadersByTexturesFlags.hasOwnProperty(textureCount)) {\n      var shadersByFlags = shadersByTexturesFlags[textureCount];\n\n      if (!defined(shadersByFlags)) {\n        continue;\n      }\n\n      for (flags in shadersByFlags) {\n        if (shadersByFlags.hasOwnProperty(flags)) {\n          shader = shadersByFlags[flags];\n\n          if (defined(shader)) {\n            shader.shaderProgram.destroy();\n          }\n        }\n      }\n    }\n  }\n\n  return destroyObject(this);\n};\n\nexport default GlobeSurfaceShaderSet;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/GlobeSurfaceShaderSet.js"],"names":["defined","destroyObject","TerrainQuantization","ShaderProgram","getClippingFunction","SceneMode","GlobeSurfaceShader","numberOfDayTextures","flags","material","shaderProgram","clippingShaderState","GlobeSurfaceShaderSet","baseVertexShaderSource","undefined","baseFragmentShaderSource","_shadersByTexturesFlags","getPositionMode","sceneMode","getPosition3DMode","getPositionColumbusViewAnd2DMode","getPositionMorphingMode","positionMode","SCENE3D","SCENE2D","COLUMBUS_VIEW","MORPHING","get2DYPositionFraction","useWebMercatorProjection","get2DYPositionFractionGeographicProjection","get2DYPositionFractionMercatorProjection","prototype","getShaderProgram","options","frameState","surfaceTile","applyBrightness","applyContrast","applyHue","applySaturation","applyGamma","applyAlpha","applySplit","showReflectiveOcean","showOceanWaves","enableLighting","dynamicAtmosphereLighting","dynamicAtmosphereLightingFromSun","showGroundAtmosphere","perFragmentGroundAtmosphere","hasVertexNormals","enableFog","enableClippingPlanes","clippingPlanes","clippedByBoundaries","hasImageryLayerCutout","colorCorrect","highlightFillTile","colorToAlpha","quantization","quantizationDefine","mesh","renderedMesh","terrainEncoding","encoding","quantizationMode","BITS12","cartographicLimitRectangleFlag","cartographicLimitRectangleDefine","imageryCutoutFlag","imageryCutoutDefine","mode","currentClippingShaderState","length","clippingPlanesState","surfaceShader","shadersByFlags","vs","clone","fs","sources","unshift","context","defines","push","computeDayColor","i","shader","fromCache","vertexShaderSource","fragmentShaderSource","attributeLocations","getAttributeLocations","destroy","shadersByTexturesFlags","textureCount","hasOwnProperty"],"mappings":"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","sourcesContent":["import defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport TerrainQuantization from \"../Core/TerrainQuantization.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport getClippingFunction from \"./getClippingFunction.js\";\nimport SceneMode from \"./SceneMode.js\";\n\nfunction GlobeSurfaceShader(\n  numberOfDayTextures,\n  flags,\n  material,\n  shaderProgram,\n  clippingShaderState\n) {\n  this.numberOfDayTextures = numberOfDayTextures;\n  this.flags = flags;\n  this.material = material;\n  this.shaderProgram = shaderProgram;\n  this.clippingShaderState = clippingShaderState;\n}\n\n/**\n * Manages the shaders used to shade the surface of a {@link Globe}.\n *\n * @alias GlobeSurfaceShaderSet\n * @private\n */\nfunction GlobeSurfaceShaderSet() {\n  this.baseVertexShaderSource = undefined;\n  this.baseFragmentShaderSource = undefined;\n\n  this._shadersByTexturesFlags = [];\n\n  this.material = undefined;\n}\n\nfunction getPositionMode(sceneMode) {\n  var getPosition3DMode =\n    \"vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPosition3DMode(position, height, textureCoordinates); }\";\n  var getPositionColumbusViewAnd2DMode =\n    \"vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPositionColumbusViewMode(position, height, textureCoordinates); }\";\n  var getPositionMorphingMode =\n    \"vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPositionMorphingMode(position, height, textureCoordinates); }\";\n\n  var positionMode;\n\n  switch (sceneMode) {\n    case SceneMode.SCENE3D:\n      positionMode = getPosition3DMode;\n      break;\n    case SceneMode.SCENE2D:\n    case SceneMode.COLUMBUS_VIEW:\n      positionMode = getPositionColumbusViewAnd2DMode;\n      break;\n    case SceneMode.MORPHING:\n      positionMode = getPositionMorphingMode;\n      break;\n  }\n\n  return positionMode;\n}\n\nfunction get2DYPositionFraction(useWebMercatorProjection) {\n  var get2DYPositionFractionGeographicProjection =\n    \"float get2DYPositionFraction(vec2 textureCoordinates) { return get2DGeographicYPositionFraction(textureCoordinates); }\";\n  var get2DYPositionFractionMercatorProjection =\n    \"float get2DYPositionFraction(vec2 textureCoordinates) { return get2DMercatorYPositionFraction(textureCoordinates); }\";\n  return useWebMercatorProjection\n    ? get2DYPositionFractionMercatorProjection\n    : get2DYPositionFractionGeographicProjection;\n}\n\nGlobeSurfaceShaderSet.prototype.getShaderProgram = function (options) {\n  var frameState = options.frameState;\n  var surfaceTile = options.surfaceTile;\n  var numberOfDayTextures = options.numberOfDayTextures;\n  var applyBrightness = options.applyBrightness;\n  var applyContrast = options.applyContrast;\n  var applyHue = options.applyHue;\n  var applySaturation = options.applySaturation;\n  var applyGamma = options.applyGamma;\n  var applyAlpha = options.applyAlpha;\n  var applySplit = options.applySplit;\n  var showReflectiveOcean = options.showReflectiveOcean;\n  var showOceanWaves = options.showOceanWaves;\n  var enableLighting = options.enableLighting;\n  var dynamicAtmosphereLighting = options.dynamicAtmosphereLighting;\n  var dynamicAtmosphereLightingFromSun =\n    options.dynamicAtmosphereLightingFromSun;\n  var showGroundAtmosphere = options.showGroundAtmosphere;\n  var perFragmentGroundAtmosphere = options.perFragmentGroundAtmosphere;\n  var hasVertexNormals = options.hasVertexNormals;\n  var useWebMercatorProjection = options.useWebMercatorProjection;\n  var enableFog = options.enableFog;\n  var enableClippingPlanes = options.enableClippingPlanes;\n  var clippingPlanes = options.clippingPlanes;\n  var clippedByBoundaries = options.clippedByBoundaries;\n  var hasImageryLayerCutout = options.hasImageryLayerCutout;\n  var colorCorrect = options.colorCorrect;\n  var highlightFillTile = options.highlightFillTile;\n  var colorToAlpha = options.colorToAlpha;\n\n  var quantization = 0;\n  var quantizationDefine = \"\";\n\n  var mesh = surfaceTile.renderedMesh;\n  var terrainEncoding = mesh.encoding;\n  var quantizationMode = terrainEncoding.quantization;\n  if (quantizationMode === TerrainQuantization.BITS12) {\n    quantization = 1;\n    quantizationDefine = \"QUANTIZATION_BITS12\";\n  }\n\n  var cartographicLimitRectangleFlag = 0;\n  var cartographicLimitRectangleDefine = \"\";\n  if (clippedByBoundaries) {\n    cartographicLimitRectangleFlag = 1;\n    cartographicLimitRectangleDefine = \"TILE_LIMIT_RECTANGLE\";\n  }\n\n  var imageryCutoutFlag = 0;\n  var imageryCutoutDefine = \"\";\n  if (hasImageryLayerCutout) {\n    imageryCutoutFlag = 1;\n    imageryCutoutDefine = \"APPLY_IMAGERY_CUTOUT\";\n  }\n\n  var sceneMode = frameState.mode;\n  var flags =\n    sceneMode |\n    (applyBrightness << 2) |\n    (applyContrast << 3) |\n    (applyHue << 4) |\n    (applySaturation << 5) |\n    (applyGamma << 6) |\n    (applyAlpha << 7) |\n    (showReflectiveOcean << 8) |\n    (showOceanWaves << 9) |\n    (enableLighting << 10) |\n    (dynamicAtmosphereLighting << 11) |\n    (dynamicAtmosphereLightingFromSun << 12) |\n    (showGroundAtmosphere << 13) |\n    (perFragmentGroundAtmosphere << 14) |\n    (hasVertexNormals << 15) |\n    (useWebMercatorProjection << 16) |\n    (enableFog << 17) |\n    (quantization << 18) |\n    (applySplit << 19) |\n    (enableClippingPlanes << 20) |\n    (cartographicLimitRectangleFlag << 21) |\n    (imageryCutoutFlag << 22) |\n    (colorCorrect << 23) |\n    (highlightFillTile << 24) |\n    (colorToAlpha << 25);\n\n  var currentClippingShaderState = 0;\n  if (defined(clippingPlanes) && clippingPlanes.length > 0) {\n    currentClippingShaderState = enableClippingPlanes\n      ? clippingPlanes.clippingPlanesState\n      : 0;\n  }\n  var surfaceShader = surfaceTile.surfaceShader;\n  if (\n    defined(surfaceShader) &&\n    surfaceShader.numberOfDayTextures === numberOfDayTextures &&\n    surfaceShader.flags === flags &&\n    surfaceShader.material === this.material &&\n    surfaceShader.clippingShaderState === currentClippingShaderState\n  ) {\n    return surfaceShader.shaderProgram;\n  }\n\n  // New tile, or tile changed number of textures, flags, or clipping planes\n  var shadersByFlags = this._shadersByTexturesFlags[numberOfDayTextures];\n  if (!defined(shadersByFlags)) {\n    shadersByFlags = this._shadersByTexturesFlags[numberOfDayTextures] = [];\n  }\n\n  surfaceShader = shadersByFlags[flags];\n  if (\n    !defined(surfaceShader) ||\n    surfaceShader.material !== this.material ||\n    surfaceShader.clippingShaderState !== currentClippingShaderState\n  ) {\n    // Cache miss - we've never seen this combination of numberOfDayTextures and flags before.\n    var vs = this.baseVertexShaderSource.clone();\n    var fs = this.baseFragmentShaderSource.clone();\n\n    if (currentClippingShaderState !== 0) {\n      fs.sources.unshift(\n        getClippingFunction(clippingPlanes, frameState.context)\n      ); // Need to go before GlobeFS\n    }\n\n    vs.defines.push(quantizationDefine);\n    fs.defines.push(\n      \"TEXTURE_UNITS \" + numberOfDayTextures,\n      cartographicLimitRectangleDefine,\n      imageryCutoutDefine\n    );\n\n    if (applyBrightness) {\n      fs.defines.push(\"APPLY_BRIGHTNESS\");\n    }\n    if (applyContrast) {\n      fs.defines.push(\"APPLY_CONTRAST\");\n    }\n    if (applyHue) {\n      fs.defines.push(\"APPLY_HUE\");\n    }\n    if (applySaturation) {\n      fs.defines.push(\"APPLY_SATURATION\");\n    }\n    if (applyGamma) {\n      fs.defines.push(\"APPLY_GAMMA\");\n    }\n    if (applyAlpha) {\n      fs.defines.push(\"APPLY_ALPHA\");\n    }\n    if (showReflectiveOcean) {\n      fs.defines.push(\"SHOW_REFLECTIVE_OCEAN\");\n      vs.defines.push(\"SHOW_REFLECTIVE_OCEAN\");\n    }\n    if (showOceanWaves) {\n      fs.defines.push(\"SHOW_OCEAN_WAVES\");\n    }\n    if (colorToAlpha) {\n      fs.defines.push(\"APPLY_COLOR_TO_ALPHA\");\n    }\n\n    if (enableLighting) {\n      if (hasVertexNormals) {\n        vs.defines.push(\"ENABLE_VERTEX_LIGHTING\");\n        fs.defines.push(\"ENABLE_VERTEX_LIGHTING\");\n      } else {\n        vs.defines.push(\"ENABLE_DAYNIGHT_SHADING\");\n        fs.defines.push(\"ENABLE_DAYNIGHT_SHADING\");\n      }\n    }\n\n    if (dynamicAtmosphereLighting) {\n      fs.defines.push(\"DYNAMIC_ATMOSPHERE_LIGHTING\");\n      if (dynamicAtmosphereLightingFromSun) {\n        fs.defines.push(\"DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN\");\n      }\n    }\n\n    if (showGroundAtmosphere) {\n      vs.defines.push(\"GROUND_ATMOSPHERE\");\n      fs.defines.push(\"GROUND_ATMOSPHERE\");\n      if (perFragmentGroundAtmosphere) {\n        fs.defines.push(\"PER_FRAGMENT_GROUND_ATMOSPHERE\");\n      }\n    }\n\n    vs.defines.push(\"INCLUDE_WEB_MERCATOR_Y\");\n    fs.defines.push(\"INCLUDE_WEB_MERCATOR_Y\");\n\n    if (enableFog) {\n      vs.defines.push(\"FOG\");\n      fs.defines.push(\"FOG\");\n    }\n\n    if (applySplit) {\n      fs.defines.push(\"APPLY_SPLIT\");\n    }\n\n    if (enableClippingPlanes) {\n      fs.defines.push(\"ENABLE_CLIPPING_PLANES\");\n    }\n\n    if (colorCorrect) {\n      fs.defines.push(\"COLOR_CORRECT\");\n    }\n\n    if (highlightFillTile) {\n      fs.defines.push(\"HIGHLIGHT_FILL_TILE\");\n    }\n\n    var computeDayColor =\n      \"\\\n    vec4 computeDayColor(vec4 initialColor, vec3 textureCoordinates)\\n\\\n    {\\n\\\n        vec4 color = initialColor;\\n\";\n\n    if (hasImageryLayerCutout) {\n      computeDayColor +=\n        \"\\\n        vec4 cutoutAndColorResult;\\n\\\n        bool texelUnclipped;\\n\";\n    }\n\n    for (var i = 0; i < numberOfDayTextures; ++i) {\n      if (hasImageryLayerCutout) {\n        computeDayColor +=\n          \"\\\n        cutoutAndColorResult = u_dayTextureCutoutRectangles[\" +\n          i +\n          \"];\\n\\\n        texelUnclipped = v_textureCoordinates.x < cutoutAndColorResult.x || cutoutAndColorResult.z < v_textureCoordinates.x || v_textureCoordinates.y < cutoutAndColorResult.y || cutoutAndColorResult.w < v_textureCoordinates.y;\\n\\\n        cutoutAndColorResult = sampleAndBlend(\\n\";\n      } else {\n        computeDayColor += \"\\\n        color = sampleAndBlend(\\n\";\n      }\n      computeDayColor +=\n        \"\\\n            color,\\n\\\n            u_dayTextures[\" +\n        i +\n        \"],\\n\\\n            u_dayTextureUseWebMercatorT[\" +\n        i +\n        \"] ? textureCoordinates.xz : textureCoordinates.xy,\\n\\\n            u_dayTextureTexCoordsRectangle[\" +\n        i +\n        \"],\\n\\\n            u_dayTextureTranslationAndScale[\" +\n        i +\n        \"],\\n\\\n            \" +\n        (applyAlpha ? \"u_dayTextureAlpha[\" + i + \"]\" : \"1.0\") +\n        \",\\n\\\n            \" +\n        (applyBrightness ? \"u_dayTextureBrightness[\" + i + \"]\" : \"0.0\") +\n        \",\\n\\\n            \" +\n        (applyContrast ? \"u_dayTextureContrast[\" + i + \"]\" : \"0.0\") +\n        \",\\n\\\n            \" +\n        (applyHue ? \"u_dayTextureHue[\" + i + \"]\" : \"0.0\") +\n        \",\\n\\\n            \" +\n        (applySaturation ? \"u_dayTextureSaturation[\" + i + \"]\" : \"0.0\") +\n        \",\\n\\\n            \" +\n        (applyGamma ? \"u_dayTextureOneOverGamma[\" + i + \"]\" : \"0.0\") +\n        \",\\n\\\n            \" +\n        (applySplit ? \"u_dayTextureSplit[\" + i + \"]\" : \"0.0\") +\n        \",\\n\\\n            \" +\n        (colorToAlpha ? \"u_colorsToAlpha[\" + i + \"]\" : \"vec4(0.0)\") +\n        \"\\n\\\n        );\\n\";\n      if (hasImageryLayerCutout) {\n        computeDayColor +=\n          \"\\\n        color = czm_branchFreeTernary(texelUnclipped, cutoutAndColorResult, color);\\n\";\n      }\n    }\n\n    computeDayColor += \"\\\n        return color;\\n\\\n    }\";\n\n    fs.sources.push(computeDayColor);\n\n    vs.sources.push(getPositionMode(sceneMode));\n    vs.sources.push(get2DYPositionFraction(useWebMercatorProjection));\n\n    var shader = ShaderProgram.fromCache({\n      context: frameState.context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n      attributeLocations: terrainEncoding.getAttributeLocations(),\n    });\n\n    surfaceShader = shadersByFlags[flags] = new GlobeSurfaceShader(\n      numberOfDayTextures,\n      flags,\n      this.material,\n      shader,\n      currentClippingShaderState\n    );\n  }\n\n  surfaceTile.surfaceShader = surfaceShader;\n  return surfaceShader.shaderProgram;\n};\n\nGlobeSurfaceShaderSet.prototype.destroy = function () {\n  var flags;\n  var shader;\n\n  var shadersByTexturesFlags = this._shadersByTexturesFlags;\n  for (var textureCount in shadersByTexturesFlags) {\n    if (shadersByTexturesFlags.hasOwnProperty(textureCount)) {\n      var shadersByFlags = shadersByTexturesFlags[textureCount];\n      if (!defined(shadersByFlags)) {\n        continue;\n      }\n\n      for (flags in shadersByFlags) {\n        if (shadersByFlags.hasOwnProperty(flags)) {\n          shader = shadersByFlags[flags];\n          if (defined(shader)) {\n            shader.shaderProgram.destroy();\n          }\n        }\n      }\n    }\n  }\n\n  return destroyObject(this);\n};\nexport default GlobeSurfaceShaderSet;\n"]},"metadata":{},"sourceType":"module"}