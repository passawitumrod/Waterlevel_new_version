{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport clone from \"../Core/clone.js\";\nimport defined from \"../Core/defined.js\";\nimport Matrix2 from \"../Core/Matrix2.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport addToArray from \"../ThirdParty/GltfPipeline/addToArray.js\";\nimport ForEach from \"../ThirdParty/GltfPipeline/ForEach.js\";\nimport hasExtension from \"../ThirdParty/GltfPipeline/hasExtension.js\";\nimport AttributeType from \"./AttributeType.js\";\nimport Axis from \"./Axis.js\";\n/**\n * @private\n */\n\nvar ModelUtility = {};\n/**\n * Updates the model's forward axis if the model is not a 2.0 model.\n *\n * @param {Object} model The model to update.\n */\n\nModelUtility.updateForwardAxis = function (model) {\n  var cachedSourceVersion = model.gltf.extras.sourceVersion;\n\n  if (defined(cachedSourceVersion) && cachedSourceVersion !== \"2.0\" || ModelUtility.getAssetVersion(model.gltf) !== \"2.0\") {\n    model._gltfForwardAxis = Axis.X;\n  }\n};\n/**\n *  Gets the string representing the glTF asset version.\n *\n *  @param {Object} gltf A javascript object containing a glTF asset.\n *  @returns {String} The glTF asset version string.\n */\n\n\nModelUtility.getAssetVersion = function (gltf) {\n  // In glTF 1.0 it was valid to omit the version number.\n  if (!defined(gltf.asset) || !defined(gltf.asset.version)) {\n    return \"1.0\";\n  }\n\n  return gltf.asset.version;\n};\n/**\n * Splits primitive materials with values incompatible for generating techniques.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @returns {Object} The glTF asset with modified materials.\n */\n\n\nModelUtility.splitIncompatibleMaterials = function (gltf) {\n  var accessors = gltf.accessors;\n  var materials = gltf.materials;\n  var primitiveInfoByMaterial = {};\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      var materialIndex = primitive.material;\n      var material = materials[materialIndex];\n      var jointAccessorId = primitive.attributes.JOINTS_0;\n      var componentType;\n      var type;\n\n      if (defined(jointAccessorId)) {\n        var jointAccessor = accessors[jointAccessorId];\n        componentType = jointAccessor.componentType;\n        type = jointAccessor.type;\n      }\n\n      var isSkinned = defined(jointAccessorId);\n      var hasVertexColors = defined(primitive.attributes.COLOR_0);\n      var hasMorphTargets = defined(primitive.targets);\n      var hasNormals = defined(primitive.attributes.NORMAL);\n      var hasTangents = defined(primitive.attributes.TANGENT);\n      var hasTexCoords = defined(primitive.attributes.TEXCOORD_0);\n      var hasOutline = defined(primitive.extensions) && defined(primitive.extensions.CESIUM_primitive_outline);\n      var primitiveInfo = primitiveInfoByMaterial[materialIndex];\n\n      if (!defined(primitiveInfo)) {\n        primitiveInfoByMaterial[materialIndex] = {\n          skinning: {\n            skinned: isSkinned,\n            componentType: componentType,\n            type: type\n          },\n          hasVertexColors: hasVertexColors,\n          hasMorphTargets: hasMorphTargets,\n          hasNormals: hasNormals,\n          hasTangents: hasTangents,\n          hasTexCoords: hasTexCoords,\n          hasOutline: hasOutline\n        };\n      } else if (primitiveInfo.skinning.skinned !== isSkinned || primitiveInfo.skinning.type !== type || primitiveInfo.hasVertexColors !== hasVertexColors || primitiveInfo.hasMorphTargets !== hasMorphTargets || primitiveInfo.hasNormals !== hasNormals || primitiveInfo.hasTangents !== hasTangents || primitiveInfo.hasTexCoords !== hasTexCoords || primitiveInfo.hasOutline !== hasOutline) {\n        // This primitive uses the same material as another one that either:\n        // * Isn't skinned\n        // * Uses a different type to store joints and weights\n        // * Doesn't have vertex colors, morph targets, normals, tangents, or texCoords\n        // * Doesn't have a CESIUM_primitive_outline extension.\n        var clonedMaterial = clone(material, true); // Split this off as a separate material\n\n        materialIndex = addToArray(materials, clonedMaterial);\n        primitive.material = materialIndex;\n        primitiveInfoByMaterial[materialIndex] = {\n          skinning: {\n            skinned: isSkinned,\n            componentType: componentType,\n            type: type\n          },\n          hasVertexColors: hasVertexColors,\n          hasMorphTargets: hasMorphTargets,\n          hasNormals: hasNormals,\n          hasTangents: hasTangents,\n          hasTexCoords: hasTexCoords,\n          hasOutline: hasOutline\n        };\n      }\n    });\n  });\n  return primitiveInfoByMaterial;\n};\n\nModelUtility.getShaderVariable = function (type) {\n  if (type === \"SCALAR\") {\n    return \"float\";\n  }\n\n  return type.toLowerCase();\n};\n\nModelUtility.ModelState = {\n  NEEDS_LOAD: 0,\n  LOADING: 1,\n  LOADED: 2,\n  // Renderable, but textures can still be pending when incrementallyLoadTextures is true.\n  FAILED: 3\n};\n\nModelUtility.getFailedLoadFunction = function (model, type, path) {\n  return function (error) {\n    model._state = ModelUtility.ModelState.FAILED;\n    var message = \"Failed to load \" + type + \": \" + path;\n\n    if (defined(error)) {\n      message += \"\\n\" + error.message;\n    }\n\n    model._readyPromise.reject(new RuntimeError(message));\n  };\n};\n\nModelUtility.parseBuffers = function (model, bufferLoad) {\n  var loadResources = model._loadResources;\n  ForEach.buffer(model.gltf, function (buffer, bufferViewId) {\n    if (defined(buffer.extras._pipeline.source)) {\n      loadResources.buffers[bufferViewId] = buffer.extras._pipeline.source;\n    } else if (defined(bufferLoad)) {\n      var bufferResource = model._resource.getDerivedResource({\n        url: buffer.uri\n      });\n\n      ++loadResources.pendingBufferLoads;\n      bufferResource.fetchArrayBuffer().then(bufferLoad(model, bufferViewId)).otherwise(ModelUtility.getFailedLoadFunction(model, \"buffer\", bufferResource.url));\n    }\n  });\n};\n\nvar aMinScratch = new Cartesian3();\nvar aMaxScratch = new Cartesian3();\n\nModelUtility.computeBoundingSphere = function (model) {\n  var gltf = model.gltf;\n  var gltfNodes = gltf.nodes;\n  var gltfMeshes = gltf.meshes;\n  var rootNodes = gltf.scenes[gltf.scene].nodes;\n  var rootNodesLength = rootNodes.length;\n  var nodeStack = [];\n  var min = new Cartesian3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n  var max = new Cartesian3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n\n  for (var i = 0; i < rootNodesLength; ++i) {\n    var n = gltfNodes[rootNodes[i]];\n    n._transformToRoot = ModelUtility.getTransform(n);\n    nodeStack.push(n);\n\n    while (nodeStack.length > 0) {\n      n = nodeStack.pop();\n      var transformToRoot = n._transformToRoot;\n      var meshId = n.mesh;\n\n      if (defined(meshId)) {\n        var mesh = gltfMeshes[meshId];\n        var primitives = mesh.primitives;\n        var primitivesLength = primitives.length;\n\n        for (var m = 0; m < primitivesLength; ++m) {\n          var positionAccessor = primitives[m].attributes.POSITION;\n\n          if (defined(positionAccessor)) {\n            var minMax = ModelUtility.getAccessorMinMax(gltf, positionAccessor);\n            var aMin = Cartesian3.fromArray(minMax.min, 0, aMinScratch);\n            var aMax = Cartesian3.fromArray(minMax.max, 0, aMaxScratch);\n\n            if (defined(min) && defined(max)) {\n              Matrix4.multiplyByPoint(transformToRoot, aMin, aMin);\n              Matrix4.multiplyByPoint(transformToRoot, aMax, aMax);\n              Cartesian3.minimumByComponent(min, aMin, min);\n              Cartesian3.maximumByComponent(max, aMax, max);\n            }\n          }\n        }\n      }\n\n      var children = n.children;\n\n      if (defined(children)) {\n        var childrenLength = children.length;\n\n        for (var k = 0; k < childrenLength; ++k) {\n          var child = gltfNodes[children[k]];\n          child._transformToRoot = ModelUtility.getTransform(child);\n          Matrix4.multiplyTransformation(transformToRoot, child._transformToRoot, child._transformToRoot);\n          nodeStack.push(child);\n        }\n      }\n\n      delete n._transformToRoot;\n    }\n  }\n\n  var boundingSphere = BoundingSphere.fromCornerPoints(min, max);\n\n  if (model._forwardAxis === Axis.Z) {\n    // glTF 2.0 has a Z-forward convention that must be adapted here to X-forward.\n    BoundingSphere.transformWithoutScale(boundingSphere, Axis.Z_UP_TO_X_UP, boundingSphere);\n  }\n\n  if (model._upAxis === Axis.Y) {\n    BoundingSphere.transformWithoutScale(boundingSphere, Axis.Y_UP_TO_Z_UP, boundingSphere);\n  } else if (model._upAxis === Axis.X) {\n    BoundingSphere.transformWithoutScale(boundingSphere, Axis.X_UP_TO_Z_UP, boundingSphere);\n  }\n\n  return boundingSphere;\n};\n\nfunction techniqueAttributeForSemantic(technique, semantic) {\n  return ForEach.techniqueAttribute(technique, function (attribute, attributeName) {\n    if (attribute.semantic === semantic) {\n      return attributeName;\n    }\n  });\n}\n\nfunction ensureSemanticExistenceForPrimitive(gltf, primitive) {\n  var accessors = gltf.accessors;\n  var materials = gltf.materials;\n  var techniquesWebgl = gltf.extensions.KHR_techniques_webgl;\n  var techniques = techniquesWebgl.techniques;\n  var programs = techniquesWebgl.programs;\n  var shaders = techniquesWebgl.shaders;\n  var targets = primitive.targets;\n  var attributes = primitive.attributes;\n\n  for (var target in targets) {\n    if (targets.hasOwnProperty(target)) {\n      var targetAttributes = targets[target];\n\n      for (var attribute in targetAttributes) {\n        if (attribute !== \"extras\") {\n          attributes[attribute + \"_\" + target] = targetAttributes[attribute];\n        }\n      }\n    }\n  }\n\n  var material = materials[primitive.material];\n  var technique = techniques[material.extensions.KHR_techniques_webgl.technique];\n  var program = programs[technique.program];\n  var vertexShader = shaders[program.vertexShader];\n\n  for (var semantic in attributes) {\n    if (attributes.hasOwnProperty(semantic)) {\n      if (!defined(techniqueAttributeForSemantic(technique, semantic))) {\n        var accessorId = attributes[semantic];\n        var accessor = accessors[accessorId];\n        var lowerCase = semantic.toLowerCase();\n\n        if (lowerCase.charAt(0) === \"_\") {\n          lowerCase = lowerCase.slice(1);\n        }\n\n        var attributeName = \"a_\" + lowerCase;\n        technique.attributes[attributeName] = {\n          semantic: semantic,\n          type: accessor.componentType\n        };\n        var pipelineExtras = vertexShader.extras._pipeline;\n        var shaderText = pipelineExtras.source;\n        shaderText = \"attribute \" + ModelUtility.getShaderVariable(accessor.type) + \" \" + attributeName + \";\\n\" + shaderText;\n        pipelineExtras.source = shaderText;\n      }\n    }\n  }\n}\n/**\n * Ensures all attributes present on the primitive are present in the technique and\n * vertex shader.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @returns {Object} The glTF asset, including any additional attributes.\n */\n\n\nModelUtility.ensureSemanticExistence = function (gltf) {\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      ensureSemanticExistenceForPrimitive(gltf, primitive);\n    });\n  });\n  return gltf;\n};\n/**\n * Creates attribute location for all attributes required by a technique.\n *\n * @param {Object} technique A glTF KHR_techniques_webgl technique object.\n * @param {Object} precreatedAttributes A dictionary object of pre-created attributes for which to also create locations.\n * @returns {Object} A dictionary object containing attribute names and their locations.\n */\n\n\nModelUtility.createAttributeLocations = function (technique, precreatedAttributes) {\n  var attributeLocations = {};\n  var hasIndex0 = false;\n  var i = 1;\n  ForEach.techniqueAttribute(technique, function (attribute, attributeName) {\n    // Set the position attribute to the 0th index. In some WebGL implementations the shader\n    // will not work correctly if the 0th attribute is not active. For example, some glTF models\n    // list the normal attribute first but derived shaders like the cast-shadows shader do not use\n    // the normal attribute.\n    if (/pos/i.test(attributeName) && !hasIndex0) {\n      attributeLocations[attributeName] = 0;\n      hasIndex0 = true;\n    } else {\n      attributeLocations[attributeName] = i++;\n    }\n  });\n\n  if (defined(precreatedAttributes)) {\n    for (var attributeName in precreatedAttributes) {\n      if (precreatedAttributes.hasOwnProperty(attributeName)) {\n        attributeLocations[attributeName] = i++;\n      }\n    }\n  }\n\n  return attributeLocations;\n};\n\nModelUtility.getAccessorMinMax = function (gltf, accessorId) {\n  var accessor = gltf.accessors[accessorId];\n  var extensions = accessor.extensions;\n  var accessorMin = accessor.min;\n  var accessorMax = accessor.max; // If this accessor is quantized, we should use the decoded min and max\n\n  if (defined(extensions)) {\n    var quantizedAttributes = extensions.WEB3D_quantized_attributes;\n\n    if (defined(quantizedAttributes)) {\n      accessorMin = quantizedAttributes.decodedMin;\n      accessorMax = quantizedAttributes.decodedMax;\n    }\n  }\n\n  return {\n    min: accessorMin,\n    max: accessorMax\n  };\n};\n\nfunction getTechniqueAttributeOrUniformFunction(gltf, technique, semantic, ignoreNodes) {\n  if (hasExtension(gltf, \"KHR_techniques_webgl\")) {\n    return function (attributeOrUniform, attributeOrUniformName) {\n      if (attributeOrUniform.semantic === semantic && (!ignoreNodes || !defined(attributeOrUniform.node))) {\n        return attributeOrUniformName;\n      }\n    };\n  }\n\n  return function (parameterName, attributeOrUniformName) {\n    var attributeOrUniform = technique.parameters[parameterName];\n\n    if (attributeOrUniform.semantic === semantic && (!ignoreNodes || !defined(attributeOrUniform.node))) {\n      return attributeOrUniformName;\n    }\n  };\n}\n\nModelUtility.getAttributeOrUniformBySemantic = function (gltf, semantic, programId, ignoreNodes) {\n  return ForEach.technique(gltf, function (technique) {\n    if (defined(programId) && technique.program !== programId) {\n      return;\n    }\n\n    var value = ForEach.techniqueAttribute(technique, getTechniqueAttributeOrUniformFunction(gltf, technique, semantic, ignoreNodes));\n\n    if (defined(value)) {\n      return value;\n    }\n\n    return ForEach.techniqueUniform(technique, getTechniqueAttributeOrUniformFunction(gltf, technique, semantic, ignoreNodes));\n  });\n};\n\nModelUtility.getDiffuseAttributeOrUniform = function (gltf, programId) {\n  var diffuseUniformName = ModelUtility.getAttributeOrUniformBySemantic(gltf, \"COLOR_0\", programId);\n\n  if (!defined(diffuseUniformName)) {\n    diffuseUniformName = ModelUtility.getAttributeOrUniformBySemantic(gltf, \"_3DTILESDIFFUSE\", programId);\n  }\n\n  return diffuseUniformName;\n};\n\nvar nodeTranslationScratch = new Cartesian3();\nvar nodeQuaternionScratch = new Quaternion();\nvar nodeScaleScratch = new Cartesian3();\n\nModelUtility.getTransform = function (node, result) {\n  if (defined(node.matrix)) {\n    return Matrix4.fromColumnMajorArray(node.matrix, result);\n  }\n\n  return Matrix4.fromTranslationQuaternionRotationScale(Cartesian3.fromArray(node.translation, 0, nodeTranslationScratch), Quaternion.unpack(node.rotation, 0, nodeQuaternionScratch), Cartesian3.fromArray(node.scale, 0, nodeScaleScratch), result);\n};\n\nModelUtility.getUsedExtensions = function (gltf) {\n  var extensionsUsed = gltf.extensionsUsed;\n  var cachedExtensionsUsed = {};\n\n  if (defined(extensionsUsed)) {\n    var extensionsUsedLength = extensionsUsed.length;\n\n    for (var i = 0; i < extensionsUsedLength; i++) {\n      var extension = extensionsUsed[i];\n      cachedExtensionsUsed[extension] = true;\n    }\n  }\n\n  return cachedExtensionsUsed;\n};\n\nModelUtility.getRequiredExtensions = function (gltf) {\n  var extensionsRequired = gltf.extensionsRequired;\n  var cachedExtensionsRequired = {};\n\n  if (defined(extensionsRequired)) {\n    var extensionsRequiredLength = extensionsRequired.length;\n\n    for (var i = 0; i < extensionsRequiredLength; i++) {\n      var extension = extensionsRequired[i];\n      cachedExtensionsRequired[extension] = true;\n    }\n  }\n\n  return cachedExtensionsRequired;\n};\n\nModelUtility.supportedExtensions = {\n  AGI_articulations: true,\n  CESIUM_RTC: true,\n  EXT_texture_webp: true,\n  KHR_blend: true,\n  KHR_binary_glTF: true,\n  KHR_draco_mesh_compression: true,\n  KHR_materials_common: true,\n  KHR_techniques_webgl: true,\n  KHR_materials_unlit: true,\n  KHR_materials_pbrSpecularGlossiness: true,\n  KHR_texture_transform: true,\n  WEB3D_quantized_attributes: true\n};\n\nModelUtility.checkSupportedExtensions = function (extensionsRequired, browserSupportsWebp) {\n  for (var extension in extensionsRequired) {\n    if (extensionsRequired.hasOwnProperty(extension)) {\n      if (!ModelUtility.supportedExtensions[extension]) {\n        throw new RuntimeError(\"Unsupported glTF Extension: \" + extension);\n      }\n\n      if (extension === \"EXT_texture_webp\" && browserSupportsWebp === false) {\n        throw new RuntimeError(\"Loaded model requires WebP but browser does not support it.\");\n      }\n    }\n  }\n};\n\nModelUtility.checkSupportedGlExtensions = function (extensionsUsed, context) {\n  if (defined(extensionsUsed)) {\n    var glExtensionsUsedLength = extensionsUsed.length;\n\n    for (var i = 0; i < glExtensionsUsedLength; i++) {\n      var extension = extensionsUsed[i];\n\n      if (extension !== \"OES_element_index_uint\") {\n        throw new RuntimeError(\"Unsupported WebGL Extension: \" + extension);\n      } else if (!context.elementIndexUint) {\n        throw new RuntimeError(\"OES_element_index_uint WebGL extension is not enabled.\");\n      }\n    }\n  }\n};\n\nfunction replaceAllButFirstInString(string, find, replace) {\n  // Limit search to strings that are not a subset of other tokens.\n  find += \"(?!\\\\w)\";\n  find = new RegExp(find, \"g\");\n  var index = string.search(find);\n  return string.replace(find, function (match, offset) {\n    return index === offset ? match : replace;\n  });\n}\n\nfunction getQuantizedAttributes(gltf, accessorId) {\n  var accessor = gltf.accessors[accessorId];\n  var extensions = accessor.extensions;\n\n  if (defined(extensions)) {\n    return extensions.WEB3D_quantized_attributes;\n  }\n\n  return undefined;\n}\n\nfunction getAttributeVariableName(gltf, primitive, attributeSemantic) {\n  var materialId = primitive.material;\n  var material = gltf.materials[materialId];\n\n  if (!hasExtension(gltf, \"KHR_techniques_webgl\") || !defined(material.extensions) || !defined(material.extensions.KHR_techniques_webgl)) {\n    return;\n  }\n\n  var techniqueId = material.extensions.KHR_techniques_webgl.technique;\n  var techniquesWebgl = gltf.extensions.KHR_techniques_webgl;\n  var technique = techniquesWebgl.techniques[techniqueId];\n  return ForEach.techniqueAttribute(technique, function (attribute, attributeName) {\n    var semantic = attribute.semantic;\n\n    if (semantic === attributeSemantic) {\n      return attributeName;\n    }\n  });\n}\n\nModelUtility.modifyShaderForDracoQuantizedAttributes = function (gltf, primitive, shader, decodedAttributes) {\n  var quantizedUniforms = {};\n\n  for (var attributeSemantic in decodedAttributes) {\n    if (decodedAttributes.hasOwnProperty(attributeSemantic)) {\n      var attribute = decodedAttributes[attributeSemantic];\n      var quantization = attribute.quantization;\n\n      if (!defined(quantization)) {\n        continue;\n      }\n\n      var attributeVarName = getAttributeVariableName(gltf, primitive, attributeSemantic);\n\n      if (attributeSemantic.charAt(0) === \"_\") {\n        attributeSemantic = attributeSemantic.substring(1);\n      }\n\n      var decodeUniformVarName = \"gltf_u_dec_\" + attributeSemantic.toLowerCase();\n\n      if (!defined(quantizedUniforms[decodeUniformVarName])) {\n        var newMain = \"gltf_decoded_\" + attributeSemantic;\n        var decodedAttributeVarName = attributeVarName.replace(\"a_\", \"gltf_a_dec_\");\n        var size = attribute.componentsPerAttribute; // replace usages of the original attribute with the decoded version, but not the declaration\n\n        shader = replaceAllButFirstInString(shader, attributeVarName, decodedAttributeVarName); // declare decoded attribute\n\n        var variableType;\n\n        if (quantization.octEncoded) {\n          variableType = \"vec3\";\n        } else if (size > 1) {\n          variableType = \"vec\" + size;\n        } else {\n          variableType = \"float\";\n        }\n\n        shader = variableType + \" \" + decodedAttributeVarName + \";\\n\" + shader; // The gltf 2.0 COLOR_0 vertex attribute can be VEC4 or VEC3\n\n        var vec3Color = size === 3 && attributeSemantic === \"COLOR_0\";\n\n        if (vec3Color) {\n          shader = replaceAllButFirstInString(shader, decodedAttributeVarName, \"vec4(\" + decodedAttributeVarName + \", 1.0)\");\n        } // splice decode function into the shader\n\n\n        var decode = \"\";\n\n        if (quantization.octEncoded) {\n          var decodeUniformVarNameRangeConstant = decodeUniformVarName + \"_rangeConstant\";\n          shader = \"uniform float \" + decodeUniformVarNameRangeConstant + \";\\n\" + shader;\n          decode = \"\\n\" + \"void main() {\\n\" + // Draco oct-encoding decodes to zxy order\n          \"    \" + decodedAttributeVarName + \" = czm_octDecode(\" + attributeVarName + \".xy, \" + decodeUniformVarNameRangeConstant + \").zxy;\\n\" + \"    \" + newMain + \"();\\n\" + \"}\\n\";\n        } else {\n          var decodeUniformVarNameNormConstant = decodeUniformVarName + \"_normConstant\";\n          var decodeUniformVarNameMin = decodeUniformVarName + \"_min\";\n          shader = \"uniform float \" + decodeUniformVarNameNormConstant + \";\\n\" + \"uniform \" + variableType + \" \" + decodeUniformVarNameMin + \";\\n\" + shader;\n          var attributeVarAccess = vec3Color ? \".xyz\" : \"\";\n          decode = \"\\n\" + \"void main() {\\n\" + \"    \" + decodedAttributeVarName + \" = \" + decodeUniformVarNameMin + \" + \" + attributeVarName + attributeVarAccess + \" * \" + decodeUniformVarNameNormConstant + \";\\n\" + \"    \" + newMain + \"();\\n\" + \"}\\n\";\n        }\n\n        shader = ShaderSource.replaceMain(shader, newMain);\n        shader += decode;\n      }\n    }\n  }\n\n  return {\n    shader: shader\n  };\n};\n\nModelUtility.modifyShaderForQuantizedAttributes = function (gltf, primitive, shader) {\n  var quantizedUniforms = {};\n  var attributes = primitive.attributes;\n\n  for (var attributeSemantic in attributes) {\n    if (attributes.hasOwnProperty(attributeSemantic)) {\n      var attributeVarName = getAttributeVariableName(gltf, primitive, attributeSemantic);\n      var accessorId = primitive.attributes[attributeSemantic];\n\n      if (attributeSemantic.charAt(0) === \"_\") {\n        attributeSemantic = attributeSemantic.substring(1);\n      }\n\n      var decodeUniformVarName = \"gltf_u_dec_\" + attributeSemantic.toLowerCase();\n      var decodeUniformVarNameScale = decodeUniformVarName + \"_scale\";\n      var decodeUniformVarNameTranslate = decodeUniformVarName + \"_translate\";\n\n      if (!defined(quantizedUniforms[decodeUniformVarName]) && !defined(quantizedUniforms[decodeUniformVarNameScale])) {\n        var quantizedAttributes = getQuantizedAttributes(gltf, accessorId);\n\n        if (defined(quantizedAttributes)) {\n          var decodeMatrix = quantizedAttributes.decodeMatrix;\n          var newMain = \"gltf_decoded_\" + attributeSemantic;\n          var decodedAttributeVarName = attributeVarName.replace(\"a_\", \"gltf_a_dec_\");\n          var size = Math.floor(Math.sqrt(decodeMatrix.length)); // replace usages of the original attribute with the decoded version, but not the declaration\n\n          shader = replaceAllButFirstInString(shader, attributeVarName, decodedAttributeVarName); // declare decoded attribute\n\n          var variableType;\n\n          if (size > 2) {\n            variableType = \"vec\" + (size - 1);\n          } else {\n            variableType = \"float\";\n          }\n\n          shader = variableType + \" \" + decodedAttributeVarName + \";\\n\" + shader; // splice decode function into the shader - attributes are pre-multiplied with the decode matrix\n          // uniform in the shader (32-bit floating point)\n\n          var decode = \"\";\n\n          if (size === 5) {\n            // separate scale and translate since glsl doesn't have mat5\n            shader = \"uniform mat4 \" + decodeUniformVarNameScale + \";\\n\" + shader;\n            shader = \"uniform vec4 \" + decodeUniformVarNameTranslate + \";\\n\" + shader;\n            decode = \"\\n\" + \"void main() {\\n\" + \"    \" + decodedAttributeVarName + \" = \" + decodeUniformVarNameScale + \" * \" + attributeVarName + \" + \" + decodeUniformVarNameTranslate + \";\\n\" + \"    \" + newMain + \"();\\n\" + \"}\\n\";\n            quantizedUniforms[decodeUniformVarNameScale] = {\n              mat: 4\n            };\n            quantizedUniforms[decodeUniformVarNameTranslate] = {\n              vec: 4\n            };\n          } else {\n            shader = \"uniform mat\" + size + \" \" + decodeUniformVarName + \";\\n\" + shader;\n            decode = \"\\n\" + \"void main() {\\n\" + \"    \" + decodedAttributeVarName + \" = \" + variableType + \"(\" + decodeUniformVarName + \" * vec\" + size + \"(\" + attributeVarName + \",1.0));\\n\" + \"    \" + newMain + \"();\\n\" + \"}\\n\";\n            quantizedUniforms[decodeUniformVarName] = {\n              mat: size\n            };\n          }\n\n          shader = ShaderSource.replaceMain(shader, newMain);\n          shader += decode;\n        }\n      }\n    }\n  }\n\n  return {\n    shader: shader,\n    uniforms: quantizedUniforms\n  };\n};\n\nModelUtility.toClipCoordinatesGLSL = function (gltf, shader) {\n  var positionName = ModelUtility.getAttributeOrUniformBySemantic(gltf, \"POSITION\");\n  var decodedPositionName = positionName.replace(\"a_\", \"gltf_a_dec_\");\n\n  if (shader.indexOf(decodedPositionName) !== -1) {\n    positionName = decodedPositionName;\n  }\n\n  var modelViewProjectionName = ModelUtility.getAttributeOrUniformBySemantic(gltf, \"MODELVIEWPROJECTION\", undefined, true);\n\n  if (!defined(modelViewProjectionName) || shader.indexOf(modelViewProjectionName) === -1) {\n    var projectionName = ModelUtility.getAttributeOrUniformBySemantic(gltf, \"PROJECTION\", undefined, true);\n    var modelViewName = ModelUtility.getAttributeOrUniformBySemantic(gltf, \"MODELVIEW\", undefined, true);\n\n    if (shader.indexOf(\"czm_instanced_modelView \") !== -1) {\n      modelViewName = \"czm_instanced_modelView\";\n    } else if (!defined(modelViewName)) {\n      modelViewName = ModelUtility.getAttributeOrUniformBySemantic(gltf, \"CESIUM_RTC_MODELVIEW\", undefined, true);\n    }\n\n    modelViewProjectionName = projectionName + \" * \" + modelViewName;\n  }\n\n  return modelViewProjectionName + \" * vec4(\" + positionName + \".xyz, 1.0)\";\n};\n\nModelUtility.modifyFragmentShaderForLogDepth = function (shader) {\n  shader = ShaderSource.replaceMain(shader, \"czm_depth_main\");\n  shader += \"\\n\" + \"void main() \\n\" + \"{ \\n\" + \"    czm_depth_main(); \\n\" + \"    czm_writeLogDepth(); \\n\" + \"} \\n\";\n  return shader;\n};\n\nModelUtility.modifyVertexShaderForLogDepth = function (shader, toClipCoordinatesGLSL) {\n  shader = ShaderSource.replaceMain(shader, \"czm_depth_main\");\n  shader += \"\\n\" + \"void main() \\n\" + \"{ \\n\" + \"    czm_depth_main(); \\n\" + \"    czm_vertexLogDepth(\" + toClipCoordinatesGLSL + \"); \\n\" + \"} \\n\";\n  return shader;\n};\n\nfunction getScalarUniformFunction(value) {\n  var that = {\n    value: value,\n    clone: function (source, result) {\n      return source;\n    },\n    func: function () {\n      return that.value;\n    }\n  };\n  return that;\n}\n\nfunction getVec2UniformFunction(value) {\n  var that = {\n    value: Cartesian2.fromArray(value),\n    clone: Cartesian2.clone,\n    func: function () {\n      return that.value;\n    }\n  };\n  return that;\n}\n\nfunction getVec3UniformFunction(value) {\n  var that = {\n    value: Cartesian3.fromArray(value),\n    clone: Cartesian3.clone,\n    func: function () {\n      return that.value;\n    }\n  };\n  return that;\n}\n\nfunction getVec4UniformFunction(value) {\n  var that = {\n    value: Cartesian4.fromArray(value),\n    clone: Cartesian4.clone,\n    func: function () {\n      return that.value;\n    }\n  };\n  return that;\n}\n\nfunction getMat2UniformFunction(value) {\n  var that = {\n    value: Matrix2.fromColumnMajorArray(value),\n    clone: Matrix2.clone,\n    func: function () {\n      return that.value;\n    }\n  };\n  return that;\n}\n\nfunction getMat3UniformFunction(value) {\n  var that = {\n    value: Matrix3.fromColumnMajorArray(value),\n    clone: Matrix3.clone,\n    func: function () {\n      return that.value;\n    }\n  };\n  return that;\n}\n\nfunction getMat4UniformFunction(value) {\n  var that = {\n    value: Matrix4.fromColumnMajorArray(value),\n    clone: Matrix4.clone,\n    func: function () {\n      return that.value;\n    }\n  };\n  return that;\n} ///////////////////////////////////////////////////////////////////////////\n\n\nfunction DelayLoadedTextureUniform(value, textures, defaultTexture) {\n  this._value = undefined;\n  this._textureId = value.index;\n  this._textures = textures;\n  this._defaultTexture = defaultTexture;\n}\n\nObject.defineProperties(DelayLoadedTextureUniform.prototype, {\n  value: {\n    get: function () {\n      // Use the default texture (1x1 white) until the model's texture is loaded\n      if (!defined(this._value)) {\n        var texture = this._textures[this._textureId];\n\n        if (defined(texture)) {\n          this._value = texture;\n        } else {\n          return this._defaultTexture;\n        }\n      }\n\n      return this._value;\n    },\n    set: function (value) {\n      this._value = value;\n    }\n  }\n});\n\nDelayLoadedTextureUniform.prototype.clone = function (source) {\n  return source;\n};\n\nDelayLoadedTextureUniform.prototype.func = undefined; ///////////////////////////////////////////////////////////////////////////\n\nfunction getTextureUniformFunction(value, textures, defaultTexture) {\n  var uniform = new DelayLoadedTextureUniform(value, textures, defaultTexture); // Define function here to access closure since 'this' can't be\n  // used when the Renderer sets uniforms.\n\n  uniform.func = function () {\n    return uniform.value;\n  };\n\n  return uniform;\n}\n\nvar gltfUniformFunctions = {};\ngltfUniformFunctions[WebGLConstants.FLOAT] = getScalarUniformFunction;\ngltfUniformFunctions[WebGLConstants.FLOAT_VEC2] = getVec2UniformFunction;\ngltfUniformFunctions[WebGLConstants.FLOAT_VEC3] = getVec3UniformFunction;\ngltfUniformFunctions[WebGLConstants.FLOAT_VEC4] = getVec4UniformFunction;\ngltfUniformFunctions[WebGLConstants.INT] = getScalarUniformFunction;\ngltfUniformFunctions[WebGLConstants.INT_VEC2] = getVec2UniformFunction;\ngltfUniformFunctions[WebGLConstants.INT_VEC3] = getVec3UniformFunction;\ngltfUniformFunctions[WebGLConstants.INT_VEC4] = getVec4UniformFunction;\ngltfUniformFunctions[WebGLConstants.BOOL] = getScalarUniformFunction;\ngltfUniformFunctions[WebGLConstants.BOOL_VEC2] = getVec2UniformFunction;\ngltfUniformFunctions[WebGLConstants.BOOL_VEC3] = getVec3UniformFunction;\ngltfUniformFunctions[WebGLConstants.BOOL_VEC4] = getVec4UniformFunction;\ngltfUniformFunctions[WebGLConstants.FLOAT_MAT2] = getMat2UniformFunction;\ngltfUniformFunctions[WebGLConstants.FLOAT_MAT3] = getMat3UniformFunction;\ngltfUniformFunctions[WebGLConstants.FLOAT_MAT4] = getMat4UniformFunction;\ngltfUniformFunctions[WebGLConstants.SAMPLER_2D] = getTextureUniformFunction; // GLTF_SPEC: Support SAMPLER_CUBE. https://github.com/KhronosGroup/glTF/issues/40\n\nModelUtility.createUniformFunction = function (type, value, textures, defaultTexture) {\n  return gltfUniformFunctions[type](value, textures, defaultTexture);\n};\n\nfunction scaleFromMatrix5Array(matrix) {\n  return [matrix[0], matrix[1], matrix[2], matrix[3], matrix[5], matrix[6], matrix[7], matrix[8], matrix[10], matrix[11], matrix[12], matrix[13], matrix[15], matrix[16], matrix[17], matrix[18]];\n}\n\nfunction translateFromMatrix5Array(matrix) {\n  return [matrix[20], matrix[21], matrix[22], matrix[23]];\n}\n\nModelUtility.createUniformsForDracoQuantizedAttributes = function (decodedAttributes) {\n  var uniformMap = {};\n\n  for (var attribute in decodedAttributes) {\n    if (decodedAttributes.hasOwnProperty(attribute)) {\n      var decodedData = decodedAttributes[attribute];\n      var quantization = decodedData.quantization;\n\n      if (!defined(quantization)) {\n        continue;\n      }\n\n      if (attribute.charAt(0) === \"_\") {\n        attribute = attribute.substring(1);\n      }\n\n      var uniformVarName = \"gltf_u_dec_\" + attribute.toLowerCase();\n\n      if (quantization.octEncoded) {\n        var uniformVarNameRangeConstant = uniformVarName + \"_rangeConstant\";\n        var rangeConstant = (1 << quantization.quantizationBits) - 1.0;\n        uniformMap[uniformVarNameRangeConstant] = getScalarUniformFunction(rangeConstant).func;\n        continue;\n      }\n\n      var uniformVarNameNormConstant = uniformVarName + \"_normConstant\";\n      var normConstant = quantization.range / (1 << quantization.quantizationBits);\n      uniformMap[uniformVarNameNormConstant] = getScalarUniformFunction(normConstant).func;\n      var uniformVarNameMin = uniformVarName + \"_min\";\n\n      switch (decodedData.componentsPerAttribute) {\n        case 1:\n          uniformMap[uniformVarNameMin] = getScalarUniformFunction(quantization.minValues).func;\n          break;\n\n        case 2:\n          uniformMap[uniformVarNameMin] = getVec2UniformFunction(quantization.minValues).func;\n          break;\n\n        case 3:\n          uniformMap[uniformVarNameMin] = getVec3UniformFunction(quantization.minValues).func;\n          break;\n\n        case 4:\n          uniformMap[uniformVarNameMin] = getVec4UniformFunction(quantization.minValues).func;\n          break;\n      }\n    }\n  }\n\n  return uniformMap;\n};\n\nModelUtility.createUniformsForQuantizedAttributes = function (gltf, primitive, quantizedUniforms) {\n  var accessors = gltf.accessors;\n  var setUniforms = {};\n  var uniformMap = {};\n  var attributes = primitive.attributes;\n\n  for (var attribute in attributes) {\n    if (attributes.hasOwnProperty(attribute)) {\n      var accessorId = attributes[attribute];\n      var a = accessors[accessorId];\n      var extensions = a.extensions;\n\n      if (attribute.charAt(0) === \"_\") {\n        attribute = attribute.substring(1);\n      }\n\n      if (defined(extensions)) {\n        var quantizedAttributes = extensions.WEB3D_quantized_attributes;\n\n        if (defined(quantizedAttributes)) {\n          var decodeMatrix = quantizedAttributes.decodeMatrix;\n          var uniformVariable = \"gltf_u_dec_\" + attribute.toLowerCase();\n\n          switch (a.type) {\n            case AttributeType.SCALAR:\n              uniformMap[uniformVariable] = getMat2UniformFunction(decodeMatrix).func;\n              setUniforms[uniformVariable] = true;\n              break;\n\n            case AttributeType.VEC2:\n              uniformMap[uniformVariable] = getMat3UniformFunction(decodeMatrix).func;\n              setUniforms[uniformVariable] = true;\n              break;\n\n            case AttributeType.VEC3:\n              uniformMap[uniformVariable] = getMat4UniformFunction(decodeMatrix).func;\n              setUniforms[uniformVariable] = true;\n              break;\n\n            case AttributeType.VEC4:\n              // VEC4 attributes are split into scale and translate because there is no mat5 in GLSL\n              var uniformVariableScale = uniformVariable + \"_scale\";\n              var uniformVariableTranslate = uniformVariable + \"_translate\";\n              uniformMap[uniformVariableScale] = getMat4UniformFunction(scaleFromMatrix5Array(decodeMatrix)).func;\n              uniformMap[uniformVariableTranslate] = getVec4UniformFunction(translateFromMatrix5Array(decodeMatrix)).func;\n              setUniforms[uniformVariableScale] = true;\n              setUniforms[uniformVariableTranslate] = true;\n              break;\n          }\n        }\n      }\n    }\n  } // If there are any unset quantized uniforms in this program, they should be set to the identity\n\n\n  for (var quantizedUniform in quantizedUniforms) {\n    if (quantizedUniforms.hasOwnProperty(quantizedUniform)) {\n      if (!setUniforms[quantizedUniform]) {\n        var properties = quantizedUniforms[quantizedUniform];\n\n        if (defined(properties.mat)) {\n          if (properties.mat === 2) {\n            uniformMap[quantizedUniform] = getMat2UniformFunction(Matrix2.IDENTITY).func;\n          } else if (properties.mat === 3) {\n            uniformMap[quantizedUniform] = getMat3UniformFunction(Matrix3.IDENTITY).func;\n          } else if (properties.mat === 4) {\n            uniformMap[quantizedUniform] = getMat4UniformFunction(Matrix4.IDENTITY).func;\n          }\n        }\n\n        if (defined(properties.vec)) {\n          if (properties.vec === 4) {\n            uniformMap[quantizedUniform] = getVec4UniformFunction([0, 0, 0, 0]).func;\n          }\n        }\n      }\n    }\n  }\n\n  return uniformMap;\n}; // This doesn't support LOCAL, which we could add if it is ever used.\n\n\nvar scratchTranslationRtc = new Cartesian3();\nvar gltfSemanticUniforms = {\n  MODEL: function (uniformState, model) {\n    return function () {\n      return uniformState.model;\n    };\n  },\n  VIEW: function (uniformState, model) {\n    return function () {\n      return uniformState.view;\n    };\n  },\n  PROJECTION: function (uniformState, model) {\n    return function () {\n      return uniformState.projection;\n    };\n  },\n  MODELVIEW: function (uniformState, model) {\n    return function () {\n      return uniformState.modelView;\n    };\n  },\n  CESIUM_RTC_MODELVIEW: function (uniformState, model) {\n    // CESIUM_RTC extension\n    var mvRtc = new Matrix4();\n    return function () {\n      if (defined(model._rtcCenter)) {\n        Matrix4.getTranslation(uniformState.model, scratchTranslationRtc);\n        Cartesian3.add(scratchTranslationRtc, model._rtcCenter, scratchTranslationRtc);\n        Matrix4.multiplyByPoint(uniformState.view, scratchTranslationRtc, scratchTranslationRtc);\n        return Matrix4.setTranslation(uniformState.modelView, scratchTranslationRtc, mvRtc);\n      }\n\n      return uniformState.modelView;\n    };\n  },\n  MODELVIEWPROJECTION: function (uniformState, model) {\n    return function () {\n      return uniformState.modelViewProjection;\n    };\n  },\n  MODELINVERSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseModel;\n    };\n  },\n  VIEWINVERSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseView;\n    };\n  },\n  PROJECTIONINVERSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseProjection;\n    };\n  },\n  MODELVIEWINVERSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseModelView;\n    };\n  },\n  MODELVIEWPROJECTIONINVERSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseModelViewProjection;\n    };\n  },\n  MODELINVERSETRANSPOSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseTransposeModel;\n    };\n  },\n  MODELVIEWINVERSETRANSPOSE: function (uniformState, model) {\n    return function () {\n      return uniformState.normal;\n    };\n  },\n  VIEWPORT: function (uniformState, model) {\n    return function () {\n      return uniformState.viewportCartesian4;\n    };\n  } // JOINTMATRIX created in createCommand()\n\n};\n\nModelUtility.getGltfSemanticUniforms = function () {\n  return gltfSemanticUniforms;\n};\n\nexport default ModelUtility;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/ModelUtility.js"],"names":["BoundingSphere","Cartesian2","Cartesian3","Cartesian4","clone","defined","Matrix2","Matrix3","Matrix4","Quaternion","RuntimeError","WebGLConstants","ShaderSource","addToArray","ForEach","hasExtension","AttributeType","Axis","ModelUtility","updateForwardAxis","model","cachedSourceVersion","gltf","extras","sourceVersion","getAssetVersion","_gltfForwardAxis","X","asset","version","splitIncompatibleMaterials","accessors","materials","primitiveInfoByMaterial","mesh","meshPrimitive","primitive","materialIndex","material","jointAccessorId","attributes","JOINTS_0","componentType","type","jointAccessor","isSkinned","hasVertexColors","COLOR_0","hasMorphTargets","targets","hasNormals","NORMAL","hasTangents","TANGENT","hasTexCoords","TEXCOORD_0","hasOutline","extensions","CESIUM_primitive_outline","primitiveInfo","skinning","skinned","clonedMaterial","getShaderVariable","toLowerCase","ModelState","NEEDS_LOAD","LOADING","LOADED","FAILED","getFailedLoadFunction","path","error","_state","message","_readyPromise","reject","parseBuffers","bufferLoad","loadResources","_loadResources","buffer","bufferViewId","_pipeline","source","buffers","bufferResource","_resource","getDerivedResource","url","uri","pendingBufferLoads","fetchArrayBuffer","then","otherwise","aMinScratch","aMaxScratch","computeBoundingSphere","gltfNodes","nodes","gltfMeshes","meshes","rootNodes","scenes","scene","rootNodesLength","length","nodeStack","min","Number","MAX_VALUE","max","i","n","_transformToRoot","getTransform","push","pop","transformToRoot","meshId","primitives","primitivesLength","m","positionAccessor","POSITION","minMax","getAccessorMinMax","aMin","fromArray","aMax","multiplyByPoint","minimumByComponent","maximumByComponent","children","childrenLength","k","child","multiplyTransformation","boundingSphere","fromCornerPoints","_forwardAxis","Z","transformWithoutScale","Z_UP_TO_X_UP","_upAxis","Y","Y_UP_TO_Z_UP","X_UP_TO_Z_UP","techniqueAttributeForSemantic","technique","semantic","techniqueAttribute","attribute","attributeName","ensureSemanticExistenceForPrimitive","techniquesWebgl","KHR_techniques_webgl","techniques","programs","shaders","target","hasOwnProperty","targetAttributes","program","vertexShader","accessorId","accessor","lowerCase","charAt","slice","pipelineExtras","shaderText","ensureSemanticExistence","createAttributeLocations","precreatedAttributes","attributeLocations","hasIndex0","test","accessorMin","accessorMax","quantizedAttributes","WEB3D_quantized_attributes","decodedMin","decodedMax","getTechniqueAttributeOrUniformFunction","ignoreNodes","attributeOrUniform","attributeOrUniformName","node","parameterName","parameters","getAttributeOrUniformBySemantic","programId","value","techniqueUniform","getDiffuseAttributeOrUniform","diffuseUniformName","nodeTranslationScratch","nodeQuaternionScratch","nodeScaleScratch","result","matrix","fromColumnMajorArray","fromTranslationQuaternionRotationScale","translation","unpack","rotation","scale","getUsedExtensions","extensionsUsed","cachedExtensionsUsed","extensionsUsedLength","extension","getRequiredExtensions","extensionsRequired","cachedExtensionsRequired","extensionsRequiredLength","supportedExtensions","AGI_articulations","CESIUM_RTC","EXT_texture_webp","KHR_blend","KHR_binary_glTF","KHR_draco_mesh_compression","KHR_materials_common","KHR_materials_unlit","KHR_materials_pbrSpecularGlossiness","KHR_texture_transform","checkSupportedExtensions","browserSupportsWebp","checkSupportedGlExtensions","context","glExtensionsUsedLength","elementIndexUint","replaceAllButFirstInString","string","find","replace","RegExp","index","search","match","offset","getQuantizedAttributes","undefined","getAttributeVariableName","attributeSemantic","materialId","techniqueId","modifyShaderForDracoQuantizedAttributes","shader","decodedAttributes","quantizedUniforms","quantization","attributeVarName","substring","decodeUniformVarName","newMain","decodedAttributeVarName","size","componentsPerAttribute","variableType","octEncoded","vec3Color","decode","decodeUniformVarNameRangeConstant","decodeUniformVarNameNormConstant","decodeUniformVarNameMin","attributeVarAccess","replaceMain","modifyShaderForQuantizedAttributes","decodeUniformVarNameScale","decodeUniformVarNameTranslate","decodeMatrix","Math","floor","sqrt","mat","vec","uniforms","toClipCoordinatesGLSL","positionName","decodedPositionName","indexOf","modelViewProjectionName","projectionName","modelViewName","modifyFragmentShaderForLogDepth","modifyVertexShaderForLogDepth","getScalarUniformFunction","that","func","getVec2UniformFunction","getVec3UniformFunction","getVec4UniformFunction","getMat2UniformFunction","getMat3UniformFunction","getMat4UniformFunction","DelayLoadedTextureUniform","textures","defaultTexture","_value","_textureId","_textures","_defaultTexture","Object","defineProperties","prototype","get","texture","set","getTextureUniformFunction","uniform","gltfUniformFunctions","FLOAT","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","INT","INT_VEC2","INT_VEC3","INT_VEC4","BOOL","BOOL_VEC2","BOOL_VEC3","BOOL_VEC4","FLOAT_MAT2","FLOAT_MAT3","FLOAT_MAT4","SAMPLER_2D","createUniformFunction","scaleFromMatrix5Array","translateFromMatrix5Array","createUniformsForDracoQuantizedAttributes","uniformMap","decodedData","uniformVarName","uniformVarNameRangeConstant","rangeConstant","quantizationBits","uniformVarNameNormConstant","normConstant","range","uniformVarNameMin","minValues","createUniformsForQuantizedAttributes","setUniforms","a","uniformVariable","SCALAR","VEC2","VEC3","VEC4","uniformVariableScale","uniformVariableTranslate","quantizedUniform","properties","IDENTITY","scratchTranslationRtc","gltfSemanticUniforms","MODEL","uniformState","VIEW","view","PROJECTION","projection","MODELVIEW","modelView","CESIUM_RTC_MODELVIEW","mvRtc","_rtcCenter","getTranslation","add","setTranslation","MODELVIEWPROJECTION","modelViewProjection","MODELINVERSE","inverseModel","VIEWINVERSE","inverseView","PROJECTIONINVERSE","inverseProjection","MODELVIEWINVERSE","inverseModelView","MODELVIEWPROJECTIONINVERSE","inverseModelViewProjection","MODELINVERSETRANSPOSE","inverseTransposeModel","MODELVIEWINVERSETRANSPOSE","normal","VIEWPORT","viewportCartesian4","getGltfSemanticUniforms"],"mappings":"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","sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport clone from \"../Core/clone.js\";\nimport defined from \"../Core/defined.js\";\nimport Matrix2 from \"../Core/Matrix2.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport addToArray from \"../ThirdParty/GltfPipeline/addToArray.js\";\nimport ForEach from \"../ThirdParty/GltfPipeline/ForEach.js\";\nimport hasExtension from \"../ThirdParty/GltfPipeline/hasExtension.js\";\nimport AttributeType from \"./AttributeType.js\";\nimport Axis from \"./Axis.js\";\n\n/**\n * @private\n */\nvar ModelUtility = {};\n\n/**\n * Updates the model's forward axis if the model is not a 2.0 model.\n *\n * @param {Object} model The model to update.\n */\nModelUtility.updateForwardAxis = function (model) {\n  var cachedSourceVersion = model.gltf.extras.sourceVersion;\n\n  if (\n    (defined(cachedSourceVersion) && cachedSourceVersion !== \"2.0\") ||\n    ModelUtility.getAssetVersion(model.gltf) !== \"2.0\"\n  ) {\n    model._gltfForwardAxis = Axis.X;\n  }\n};\n\n/**\n *  Gets the string representing the glTF asset version.\n *\n *  @param {Object} gltf A javascript object containing a glTF asset.\n *  @returns {String} The glTF asset version string.\n */\nModelUtility.getAssetVersion = function (gltf) {\n  // In glTF 1.0 it was valid to omit the version number.\n  if (!defined(gltf.asset) || !defined(gltf.asset.version)) {\n    return \"1.0\";\n  }\n\n  return gltf.asset.version;\n};\n\n/**\n * Splits primitive materials with values incompatible for generating techniques.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @returns {Object} The glTF asset with modified materials.\n */\nModelUtility.splitIncompatibleMaterials = function (gltf) {\n  var accessors = gltf.accessors;\n  var materials = gltf.materials;\n  var primitiveInfoByMaterial = {};\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      var materialIndex = primitive.material;\n      var material = materials[materialIndex];\n\n      var jointAccessorId = primitive.attributes.JOINTS_0;\n      var componentType;\n      var type;\n      if (defined(jointAccessorId)) {\n        var jointAccessor = accessors[jointAccessorId];\n        componentType = jointAccessor.componentType;\n        type = jointAccessor.type;\n      }\n      var isSkinned = defined(jointAccessorId);\n      var hasVertexColors = defined(primitive.attributes.COLOR_0);\n      var hasMorphTargets = defined(primitive.targets);\n      var hasNormals = defined(primitive.attributes.NORMAL);\n      var hasTangents = defined(primitive.attributes.TANGENT);\n      var hasTexCoords = defined(primitive.attributes.TEXCOORD_0);\n      var hasOutline =\n        defined(primitive.extensions) &&\n        defined(primitive.extensions.CESIUM_primitive_outline);\n\n      var primitiveInfo = primitiveInfoByMaterial[materialIndex];\n      if (!defined(primitiveInfo)) {\n        primitiveInfoByMaterial[materialIndex] = {\n          skinning: {\n            skinned: isSkinned,\n            componentType: componentType,\n            type: type,\n          },\n          hasVertexColors: hasVertexColors,\n          hasMorphTargets: hasMorphTargets,\n          hasNormals: hasNormals,\n          hasTangents: hasTangents,\n          hasTexCoords: hasTexCoords,\n          hasOutline: hasOutline,\n        };\n      } else if (\n        primitiveInfo.skinning.skinned !== isSkinned ||\n        primitiveInfo.skinning.type !== type ||\n        primitiveInfo.hasVertexColors !== hasVertexColors ||\n        primitiveInfo.hasMorphTargets !== hasMorphTargets ||\n        primitiveInfo.hasNormals !== hasNormals ||\n        primitiveInfo.hasTangents !== hasTangents ||\n        primitiveInfo.hasTexCoords !== hasTexCoords ||\n        primitiveInfo.hasOutline !== hasOutline\n      ) {\n        // This primitive uses the same material as another one that either:\n        // * Isn't skinned\n        // * Uses a different type to store joints and weights\n        // * Doesn't have vertex colors, morph targets, normals, tangents, or texCoords\n        // * Doesn't have a CESIUM_primitive_outline extension.\n        var clonedMaterial = clone(material, true);\n        // Split this off as a separate material\n        materialIndex = addToArray(materials, clonedMaterial);\n        primitive.material = materialIndex;\n        primitiveInfoByMaterial[materialIndex] = {\n          skinning: {\n            skinned: isSkinned,\n            componentType: componentType,\n            type: type,\n          },\n          hasVertexColors: hasVertexColors,\n          hasMorphTargets: hasMorphTargets,\n          hasNormals: hasNormals,\n          hasTangents: hasTangents,\n          hasTexCoords: hasTexCoords,\n          hasOutline: hasOutline,\n        };\n      }\n    });\n  });\n\n  return primitiveInfoByMaterial;\n};\n\nModelUtility.getShaderVariable = function (type) {\n  if (type === \"SCALAR\") {\n    return \"float\";\n  }\n  return type.toLowerCase();\n};\n\nModelUtility.ModelState = {\n  NEEDS_LOAD: 0,\n  LOADING: 1,\n  LOADED: 2, // Renderable, but textures can still be pending when incrementallyLoadTextures is true.\n  FAILED: 3,\n};\n\nModelUtility.getFailedLoadFunction = function (model, type, path) {\n  return function (error) {\n    model._state = ModelUtility.ModelState.FAILED;\n    var message = \"Failed to load \" + type + \": \" + path;\n    if (defined(error)) {\n      message += \"\\n\" + error.message;\n    }\n    model._readyPromise.reject(new RuntimeError(message));\n  };\n};\n\nModelUtility.parseBuffers = function (model, bufferLoad) {\n  var loadResources = model._loadResources;\n  ForEach.buffer(model.gltf, function (buffer, bufferViewId) {\n    if (defined(buffer.extras._pipeline.source)) {\n      loadResources.buffers[bufferViewId] = buffer.extras._pipeline.source;\n    } else if (defined(bufferLoad)) {\n      var bufferResource = model._resource.getDerivedResource({\n        url: buffer.uri,\n      });\n      ++loadResources.pendingBufferLoads;\n      bufferResource\n        .fetchArrayBuffer()\n        .then(bufferLoad(model, bufferViewId))\n        .otherwise(\n          ModelUtility.getFailedLoadFunction(\n            model,\n            \"buffer\",\n            bufferResource.url\n          )\n        );\n    }\n  });\n};\n\nvar aMinScratch = new Cartesian3();\nvar aMaxScratch = new Cartesian3();\n\nModelUtility.computeBoundingSphere = function (model) {\n  var gltf = model.gltf;\n  var gltfNodes = gltf.nodes;\n  var gltfMeshes = gltf.meshes;\n  var rootNodes = gltf.scenes[gltf.scene].nodes;\n  var rootNodesLength = rootNodes.length;\n\n  var nodeStack = [];\n\n  var min = new Cartesian3(\n    Number.MAX_VALUE,\n    Number.MAX_VALUE,\n    Number.MAX_VALUE\n  );\n  var max = new Cartesian3(\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE\n  );\n\n  for (var i = 0; i < rootNodesLength; ++i) {\n    var n = gltfNodes[rootNodes[i]];\n    n._transformToRoot = ModelUtility.getTransform(n);\n    nodeStack.push(n);\n\n    while (nodeStack.length > 0) {\n      n = nodeStack.pop();\n      var transformToRoot = n._transformToRoot;\n\n      var meshId = n.mesh;\n      if (defined(meshId)) {\n        var mesh = gltfMeshes[meshId];\n        var primitives = mesh.primitives;\n        var primitivesLength = primitives.length;\n        for (var m = 0; m < primitivesLength; ++m) {\n          var positionAccessor = primitives[m].attributes.POSITION;\n          if (defined(positionAccessor)) {\n            var minMax = ModelUtility.getAccessorMinMax(gltf, positionAccessor);\n            var aMin = Cartesian3.fromArray(minMax.min, 0, aMinScratch);\n            var aMax = Cartesian3.fromArray(minMax.max, 0, aMaxScratch);\n            if (defined(min) && defined(max)) {\n              Matrix4.multiplyByPoint(transformToRoot, aMin, aMin);\n              Matrix4.multiplyByPoint(transformToRoot, aMax, aMax);\n              Cartesian3.minimumByComponent(min, aMin, min);\n              Cartesian3.maximumByComponent(max, aMax, max);\n            }\n          }\n        }\n      }\n\n      var children = n.children;\n      if (defined(children)) {\n        var childrenLength = children.length;\n        for (var k = 0; k < childrenLength; ++k) {\n          var child = gltfNodes[children[k]];\n          child._transformToRoot = ModelUtility.getTransform(child);\n          Matrix4.multiplyTransformation(\n            transformToRoot,\n            child._transformToRoot,\n            child._transformToRoot\n          );\n          nodeStack.push(child);\n        }\n      }\n      delete n._transformToRoot;\n    }\n  }\n\n  var boundingSphere = BoundingSphere.fromCornerPoints(min, max);\n  if (model._forwardAxis === Axis.Z) {\n    // glTF 2.0 has a Z-forward convention that must be adapted here to X-forward.\n    BoundingSphere.transformWithoutScale(\n      boundingSphere,\n      Axis.Z_UP_TO_X_UP,\n      boundingSphere\n    );\n  }\n  if (model._upAxis === Axis.Y) {\n    BoundingSphere.transformWithoutScale(\n      boundingSphere,\n      Axis.Y_UP_TO_Z_UP,\n      boundingSphere\n    );\n  } else if (model._upAxis === Axis.X) {\n    BoundingSphere.transformWithoutScale(\n      boundingSphere,\n      Axis.X_UP_TO_Z_UP,\n      boundingSphere\n    );\n  }\n  return boundingSphere;\n};\n\nfunction techniqueAttributeForSemantic(technique, semantic) {\n  return ForEach.techniqueAttribute(technique, function (\n    attribute,\n    attributeName\n  ) {\n    if (attribute.semantic === semantic) {\n      return attributeName;\n    }\n  });\n}\n\nfunction ensureSemanticExistenceForPrimitive(gltf, primitive) {\n  var accessors = gltf.accessors;\n  var materials = gltf.materials;\n  var techniquesWebgl = gltf.extensions.KHR_techniques_webgl;\n\n  var techniques = techniquesWebgl.techniques;\n  var programs = techniquesWebgl.programs;\n  var shaders = techniquesWebgl.shaders;\n  var targets = primitive.targets;\n\n  var attributes = primitive.attributes;\n  for (var target in targets) {\n    if (targets.hasOwnProperty(target)) {\n      var targetAttributes = targets[target];\n      for (var attribute in targetAttributes) {\n        if (attribute !== \"extras\") {\n          attributes[attribute + \"_\" + target] = targetAttributes[attribute];\n        }\n      }\n    }\n  }\n\n  var material = materials[primitive.material];\n  var technique =\n    techniques[material.extensions.KHR_techniques_webgl.technique];\n  var program = programs[technique.program];\n  var vertexShader = shaders[program.vertexShader];\n\n  for (var semantic in attributes) {\n    if (attributes.hasOwnProperty(semantic)) {\n      if (!defined(techniqueAttributeForSemantic(technique, semantic))) {\n        var accessorId = attributes[semantic];\n        var accessor = accessors[accessorId];\n        var lowerCase = semantic.toLowerCase();\n        if (lowerCase.charAt(0) === \"_\") {\n          lowerCase = lowerCase.slice(1);\n        }\n        var attributeName = \"a_\" + lowerCase;\n        technique.attributes[attributeName] = {\n          semantic: semantic,\n          type: accessor.componentType,\n        };\n        var pipelineExtras = vertexShader.extras._pipeline;\n        var shaderText = pipelineExtras.source;\n        shaderText =\n          \"attribute \" +\n          ModelUtility.getShaderVariable(accessor.type) +\n          \" \" +\n          attributeName +\n          \";\\n\" +\n          shaderText;\n        pipelineExtras.source = shaderText;\n      }\n    }\n  }\n}\n\n/**\n * Ensures all attributes present on the primitive are present in the technique and\n * vertex shader.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @returns {Object} The glTF asset, including any additional attributes.\n */\nModelUtility.ensureSemanticExistence = function (gltf) {\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      ensureSemanticExistenceForPrimitive(gltf, primitive);\n    });\n  });\n\n  return gltf;\n};\n\n/**\n * Creates attribute location for all attributes required by a technique.\n *\n * @param {Object} technique A glTF KHR_techniques_webgl technique object.\n * @param {Object} precreatedAttributes A dictionary object of pre-created attributes for which to also create locations.\n * @returns {Object} A dictionary object containing attribute names and their locations.\n */\nModelUtility.createAttributeLocations = function (\n  technique,\n  precreatedAttributes\n) {\n  var attributeLocations = {};\n  var hasIndex0 = false;\n  var i = 1;\n\n  ForEach.techniqueAttribute(technique, function (attribute, attributeName) {\n    // Set the position attribute to the 0th index. In some WebGL implementations the shader\n    // will not work correctly if the 0th attribute is not active. For example, some glTF models\n    // list the normal attribute first but derived shaders like the cast-shadows shader do not use\n    // the normal attribute.\n    if (/pos/i.test(attributeName) && !hasIndex0) {\n      attributeLocations[attributeName] = 0;\n      hasIndex0 = true;\n    } else {\n      attributeLocations[attributeName] = i++;\n    }\n  });\n\n  if (defined(precreatedAttributes)) {\n    for (var attributeName in precreatedAttributes) {\n      if (precreatedAttributes.hasOwnProperty(attributeName)) {\n        attributeLocations[attributeName] = i++;\n      }\n    }\n  }\n\n  return attributeLocations;\n};\n\nModelUtility.getAccessorMinMax = function (gltf, accessorId) {\n  var accessor = gltf.accessors[accessorId];\n  var extensions = accessor.extensions;\n  var accessorMin = accessor.min;\n  var accessorMax = accessor.max;\n  // If this accessor is quantized, we should use the decoded min and max\n  if (defined(extensions)) {\n    var quantizedAttributes = extensions.WEB3D_quantized_attributes;\n    if (defined(quantizedAttributes)) {\n      accessorMin = quantizedAttributes.decodedMin;\n      accessorMax = quantizedAttributes.decodedMax;\n    }\n  }\n  return {\n    min: accessorMin,\n    max: accessorMax,\n  };\n};\n\nfunction getTechniqueAttributeOrUniformFunction(\n  gltf,\n  technique,\n  semantic,\n  ignoreNodes\n) {\n  if (hasExtension(gltf, \"KHR_techniques_webgl\")) {\n    return function (attributeOrUniform, attributeOrUniformName) {\n      if (\n        attributeOrUniform.semantic === semantic &&\n        (!ignoreNodes || !defined(attributeOrUniform.node))\n      ) {\n        return attributeOrUniformName;\n      }\n    };\n  }\n\n  return function (parameterName, attributeOrUniformName) {\n    var attributeOrUniform = technique.parameters[parameterName];\n    if (\n      attributeOrUniform.semantic === semantic &&\n      (!ignoreNodes || !defined(attributeOrUniform.node))\n    ) {\n      return attributeOrUniformName;\n    }\n  };\n}\n\nModelUtility.getAttributeOrUniformBySemantic = function (\n  gltf,\n  semantic,\n  programId,\n  ignoreNodes\n) {\n  return ForEach.technique(gltf, function (technique) {\n    if (defined(programId) && technique.program !== programId) {\n      return;\n    }\n\n    var value = ForEach.techniqueAttribute(\n      technique,\n      getTechniqueAttributeOrUniformFunction(\n        gltf,\n        technique,\n        semantic,\n        ignoreNodes\n      )\n    );\n\n    if (defined(value)) {\n      return value;\n    }\n\n    return ForEach.techniqueUniform(\n      technique,\n      getTechniqueAttributeOrUniformFunction(\n        gltf,\n        technique,\n        semantic,\n        ignoreNodes\n      )\n    );\n  });\n};\n\nModelUtility.getDiffuseAttributeOrUniform = function (gltf, programId) {\n  var diffuseUniformName = ModelUtility.getAttributeOrUniformBySemantic(\n    gltf,\n    \"COLOR_0\",\n    programId\n  );\n  if (!defined(diffuseUniformName)) {\n    diffuseUniformName = ModelUtility.getAttributeOrUniformBySemantic(\n      gltf,\n      \"_3DTILESDIFFUSE\",\n      programId\n    );\n  }\n  return diffuseUniformName;\n};\n\nvar nodeTranslationScratch = new Cartesian3();\nvar nodeQuaternionScratch = new Quaternion();\nvar nodeScaleScratch = new Cartesian3();\n\nModelUtility.getTransform = function (node, result) {\n  if (defined(node.matrix)) {\n    return Matrix4.fromColumnMajorArray(node.matrix, result);\n  }\n\n  return Matrix4.fromTranslationQuaternionRotationScale(\n    Cartesian3.fromArray(node.translation, 0, nodeTranslationScratch),\n    Quaternion.unpack(node.rotation, 0, nodeQuaternionScratch),\n    Cartesian3.fromArray(node.scale, 0, nodeScaleScratch),\n    result\n  );\n};\n\nModelUtility.getUsedExtensions = function (gltf) {\n  var extensionsUsed = gltf.extensionsUsed;\n  var cachedExtensionsUsed = {};\n\n  if (defined(extensionsUsed)) {\n    var extensionsUsedLength = extensionsUsed.length;\n    for (var i = 0; i < extensionsUsedLength; i++) {\n      var extension = extensionsUsed[i];\n      cachedExtensionsUsed[extension] = true;\n    }\n  }\n  return cachedExtensionsUsed;\n};\n\nModelUtility.getRequiredExtensions = function (gltf) {\n  var extensionsRequired = gltf.extensionsRequired;\n  var cachedExtensionsRequired = {};\n\n  if (defined(extensionsRequired)) {\n    var extensionsRequiredLength = extensionsRequired.length;\n    for (var i = 0; i < extensionsRequiredLength; i++) {\n      var extension = extensionsRequired[i];\n      cachedExtensionsRequired[extension] = true;\n    }\n  }\n\n  return cachedExtensionsRequired;\n};\n\nModelUtility.supportedExtensions = {\n  AGI_articulations: true,\n  CESIUM_RTC: true,\n  EXT_texture_webp: true,\n  KHR_blend: true,\n  KHR_binary_glTF: true,\n  KHR_draco_mesh_compression: true,\n  KHR_materials_common: true,\n  KHR_techniques_webgl: true,\n  KHR_materials_unlit: true,\n  KHR_materials_pbrSpecularGlossiness: true,\n  KHR_texture_transform: true,\n  WEB3D_quantized_attributes: true,\n};\n\nModelUtility.checkSupportedExtensions = function (\n  extensionsRequired,\n  browserSupportsWebp\n) {\n  for (var extension in extensionsRequired) {\n    if (extensionsRequired.hasOwnProperty(extension)) {\n      if (!ModelUtility.supportedExtensions[extension]) {\n        throw new RuntimeError(\"Unsupported glTF Extension: \" + extension);\n      }\n\n      if (extension === \"EXT_texture_webp\" && browserSupportsWebp === false) {\n        throw new RuntimeError(\n          \"Loaded model requires WebP but browser does not support it.\"\n        );\n      }\n    }\n  }\n};\n\nModelUtility.checkSupportedGlExtensions = function (extensionsUsed, context) {\n  if (defined(extensionsUsed)) {\n    var glExtensionsUsedLength = extensionsUsed.length;\n    for (var i = 0; i < glExtensionsUsedLength; i++) {\n      var extension = extensionsUsed[i];\n      if (extension !== \"OES_element_index_uint\") {\n        throw new RuntimeError(\"Unsupported WebGL Extension: \" + extension);\n      } else if (!context.elementIndexUint) {\n        throw new RuntimeError(\n          \"OES_element_index_uint WebGL extension is not enabled.\"\n        );\n      }\n    }\n  }\n};\n\nfunction replaceAllButFirstInString(string, find, replace) {\n  // Limit search to strings that are not a subset of other tokens.\n  find += \"(?!\\\\w)\";\n  find = new RegExp(find, \"g\");\n\n  var index = string.search(find);\n  return string.replace(find, function (match, offset) {\n    return index === offset ? match : replace;\n  });\n}\n\nfunction getQuantizedAttributes(gltf, accessorId) {\n  var accessor = gltf.accessors[accessorId];\n  var extensions = accessor.extensions;\n  if (defined(extensions)) {\n    return extensions.WEB3D_quantized_attributes;\n  }\n  return undefined;\n}\n\nfunction getAttributeVariableName(gltf, primitive, attributeSemantic) {\n  var materialId = primitive.material;\n  var material = gltf.materials[materialId];\n\n  if (\n    !hasExtension(gltf, \"KHR_techniques_webgl\") ||\n    !defined(material.extensions) ||\n    !defined(material.extensions.KHR_techniques_webgl)\n  ) {\n    return;\n  }\n\n  var techniqueId = material.extensions.KHR_techniques_webgl.technique;\n  var techniquesWebgl = gltf.extensions.KHR_techniques_webgl;\n  var technique = techniquesWebgl.techniques[techniqueId];\n  return ForEach.techniqueAttribute(technique, function (\n    attribute,\n    attributeName\n  ) {\n    var semantic = attribute.semantic;\n    if (semantic === attributeSemantic) {\n      return attributeName;\n    }\n  });\n}\n\nModelUtility.modifyShaderForDracoQuantizedAttributes = function (\n  gltf,\n  primitive,\n  shader,\n  decodedAttributes\n) {\n  var quantizedUniforms = {};\n  for (var attributeSemantic in decodedAttributes) {\n    if (decodedAttributes.hasOwnProperty(attributeSemantic)) {\n      var attribute = decodedAttributes[attributeSemantic];\n      var quantization = attribute.quantization;\n      if (!defined(quantization)) {\n        continue;\n      }\n\n      var attributeVarName = getAttributeVariableName(\n        gltf,\n        primitive,\n        attributeSemantic\n      );\n\n      if (attributeSemantic.charAt(0) === \"_\") {\n        attributeSemantic = attributeSemantic.substring(1);\n      }\n      var decodeUniformVarName =\n        \"gltf_u_dec_\" + attributeSemantic.toLowerCase();\n\n      if (!defined(quantizedUniforms[decodeUniformVarName])) {\n        var newMain = \"gltf_decoded_\" + attributeSemantic;\n        var decodedAttributeVarName = attributeVarName.replace(\n          \"a_\",\n          \"gltf_a_dec_\"\n        );\n        var size = attribute.componentsPerAttribute;\n\n        // replace usages of the original attribute with the decoded version, but not the declaration\n        shader = replaceAllButFirstInString(\n          shader,\n          attributeVarName,\n          decodedAttributeVarName\n        );\n\n        // declare decoded attribute\n        var variableType;\n        if (quantization.octEncoded) {\n          variableType = \"vec3\";\n        } else if (size > 1) {\n          variableType = \"vec\" + size;\n        } else {\n          variableType = \"float\";\n        }\n        shader = variableType + \" \" + decodedAttributeVarName + \";\\n\" + shader;\n\n        // The gltf 2.0 COLOR_0 vertex attribute can be VEC4 or VEC3\n        var vec3Color = size === 3 && attributeSemantic === \"COLOR_0\";\n        if (vec3Color) {\n          shader = replaceAllButFirstInString(\n            shader,\n            decodedAttributeVarName,\n            \"vec4(\" + decodedAttributeVarName + \", 1.0)\"\n          );\n        }\n\n        // splice decode function into the shader\n        var decode = \"\";\n        if (quantization.octEncoded) {\n          var decodeUniformVarNameRangeConstant =\n            decodeUniformVarName + \"_rangeConstant\";\n          shader =\n            \"uniform float \" +\n            decodeUniformVarNameRangeConstant +\n            \";\\n\" +\n            shader;\n          decode =\n            \"\\n\" +\n            \"void main() {\\n\" +\n            // Draco oct-encoding decodes to zxy order\n            \"    \" +\n            decodedAttributeVarName +\n            \" = czm_octDecode(\" +\n            attributeVarName +\n            \".xy, \" +\n            decodeUniformVarNameRangeConstant +\n            \").zxy;\\n\" +\n            \"    \" +\n            newMain +\n            \"();\\n\" +\n            \"}\\n\";\n        } else {\n          var decodeUniformVarNameNormConstant =\n            decodeUniformVarName + \"_normConstant\";\n          var decodeUniformVarNameMin = decodeUniformVarName + \"_min\";\n          shader =\n            \"uniform float \" +\n            decodeUniformVarNameNormConstant +\n            \";\\n\" +\n            \"uniform \" +\n            variableType +\n            \" \" +\n            decodeUniformVarNameMin +\n            \";\\n\" +\n            shader;\n          var attributeVarAccess = vec3Color ? \".xyz\" : \"\";\n          decode =\n            \"\\n\" +\n            \"void main() {\\n\" +\n            \"    \" +\n            decodedAttributeVarName +\n            \" = \" +\n            decodeUniformVarNameMin +\n            \" + \" +\n            attributeVarName +\n            attributeVarAccess +\n            \" * \" +\n            decodeUniformVarNameNormConstant +\n            \";\\n\" +\n            \"    \" +\n            newMain +\n            \"();\\n\" +\n            \"}\\n\";\n        }\n\n        shader = ShaderSource.replaceMain(shader, newMain);\n        shader += decode;\n      }\n    }\n  }\n  return {\n    shader: shader,\n  };\n};\n\nModelUtility.modifyShaderForQuantizedAttributes = function (\n  gltf,\n  primitive,\n  shader\n) {\n  var quantizedUniforms = {};\n  var attributes = primitive.attributes;\n  for (var attributeSemantic in attributes) {\n    if (attributes.hasOwnProperty(attributeSemantic)) {\n      var attributeVarName = getAttributeVariableName(\n        gltf,\n        primitive,\n        attributeSemantic\n      );\n      var accessorId = primitive.attributes[attributeSemantic];\n\n      if (attributeSemantic.charAt(0) === \"_\") {\n        attributeSemantic = attributeSemantic.substring(1);\n      }\n      var decodeUniformVarName =\n        \"gltf_u_dec_\" + attributeSemantic.toLowerCase();\n\n      var decodeUniformVarNameScale = decodeUniformVarName + \"_scale\";\n      var decodeUniformVarNameTranslate = decodeUniformVarName + \"_translate\";\n      if (\n        !defined(quantizedUniforms[decodeUniformVarName]) &&\n        !defined(quantizedUniforms[decodeUniformVarNameScale])\n      ) {\n        var quantizedAttributes = getQuantizedAttributes(gltf, accessorId);\n        if (defined(quantizedAttributes)) {\n          var decodeMatrix = quantizedAttributes.decodeMatrix;\n          var newMain = \"gltf_decoded_\" + attributeSemantic;\n          var decodedAttributeVarName = attributeVarName.replace(\n            \"a_\",\n            \"gltf_a_dec_\"\n          );\n          var size = Math.floor(Math.sqrt(decodeMatrix.length));\n\n          // replace usages of the original attribute with the decoded version, but not the declaration\n          shader = replaceAllButFirstInString(\n            shader,\n            attributeVarName,\n            decodedAttributeVarName\n          );\n          // declare decoded attribute\n          var variableType;\n          if (size > 2) {\n            variableType = \"vec\" + (size - 1);\n          } else {\n            variableType = \"float\";\n          }\n          shader =\n            variableType + \" \" + decodedAttributeVarName + \";\\n\" + shader;\n          // splice decode function into the shader - attributes are pre-multiplied with the decode matrix\n          // uniform in the shader (32-bit floating point)\n          var decode = \"\";\n          if (size === 5) {\n            // separate scale and translate since glsl doesn't have mat5\n            shader =\n              \"uniform mat4 \" + decodeUniformVarNameScale + \";\\n\" + shader;\n            shader =\n              \"uniform vec4 \" + decodeUniformVarNameTranslate + \";\\n\" + shader;\n            decode =\n              \"\\n\" +\n              \"void main() {\\n\" +\n              \"    \" +\n              decodedAttributeVarName +\n              \" = \" +\n              decodeUniformVarNameScale +\n              \" * \" +\n              attributeVarName +\n              \" + \" +\n              decodeUniformVarNameTranslate +\n              \";\\n\" +\n              \"    \" +\n              newMain +\n              \"();\\n\" +\n              \"}\\n\";\n\n            quantizedUniforms[decodeUniformVarNameScale] = { mat: 4 };\n            quantizedUniforms[decodeUniformVarNameTranslate] = { vec: 4 };\n          } else {\n            shader =\n              \"uniform mat\" +\n              size +\n              \" \" +\n              decodeUniformVarName +\n              \";\\n\" +\n              shader;\n            decode =\n              \"\\n\" +\n              \"void main() {\\n\" +\n              \"    \" +\n              decodedAttributeVarName +\n              \" = \" +\n              variableType +\n              \"(\" +\n              decodeUniformVarName +\n              \" * vec\" +\n              size +\n              \"(\" +\n              attributeVarName +\n              \",1.0));\\n\" +\n              \"    \" +\n              newMain +\n              \"();\\n\" +\n              \"}\\n\";\n\n            quantizedUniforms[decodeUniformVarName] = { mat: size };\n          }\n          shader = ShaderSource.replaceMain(shader, newMain);\n          shader += decode;\n        }\n      }\n    }\n  }\n  return {\n    shader: shader,\n    uniforms: quantizedUniforms,\n  };\n};\n\nModelUtility.toClipCoordinatesGLSL = function (gltf, shader) {\n  var positionName = ModelUtility.getAttributeOrUniformBySemantic(\n    gltf,\n    \"POSITION\"\n  );\n  var decodedPositionName = positionName.replace(\"a_\", \"gltf_a_dec_\");\n  if (shader.indexOf(decodedPositionName) !== -1) {\n    positionName = decodedPositionName;\n  }\n\n  var modelViewProjectionName = ModelUtility.getAttributeOrUniformBySemantic(\n    gltf,\n    \"MODELVIEWPROJECTION\",\n    undefined,\n    true\n  );\n  if (\n    !defined(modelViewProjectionName) ||\n    shader.indexOf(modelViewProjectionName) === -1\n  ) {\n    var projectionName = ModelUtility.getAttributeOrUniformBySemantic(\n      gltf,\n      \"PROJECTION\",\n      undefined,\n      true\n    );\n    var modelViewName = ModelUtility.getAttributeOrUniformBySemantic(\n      gltf,\n      \"MODELVIEW\",\n      undefined,\n      true\n    );\n    if (shader.indexOf(\"czm_instanced_modelView \") !== -1) {\n      modelViewName = \"czm_instanced_modelView\";\n    } else if (!defined(modelViewName)) {\n      modelViewName = ModelUtility.getAttributeOrUniformBySemantic(\n        gltf,\n        \"CESIUM_RTC_MODELVIEW\",\n        undefined,\n        true\n      );\n    }\n    modelViewProjectionName = projectionName + \" * \" + modelViewName;\n  }\n\n  return modelViewProjectionName + \" * vec4(\" + positionName + \".xyz, 1.0)\";\n};\n\nModelUtility.modifyFragmentShaderForLogDepth = function (shader) {\n  shader = ShaderSource.replaceMain(shader, \"czm_depth_main\");\n  shader +=\n    \"\\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    czm_depth_main(); \\n\" +\n    \"    czm_writeLogDepth(); \\n\" +\n    \"} \\n\";\n\n  return shader;\n};\n\nModelUtility.modifyVertexShaderForLogDepth = function (\n  shader,\n  toClipCoordinatesGLSL\n) {\n  shader = ShaderSource.replaceMain(shader, \"czm_depth_main\");\n  shader +=\n    \"\\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    czm_depth_main(); \\n\" +\n    \"    czm_vertexLogDepth(\" +\n    toClipCoordinatesGLSL +\n    \"); \\n\" +\n    \"} \\n\";\n\n  return shader;\n};\n\nfunction getScalarUniformFunction(value) {\n  var that = {\n    value: value,\n    clone: function (source, result) {\n      return source;\n    },\n    func: function () {\n      return that.value;\n    },\n  };\n  return that;\n}\n\nfunction getVec2UniformFunction(value) {\n  var that = {\n    value: Cartesian2.fromArray(value),\n    clone: Cartesian2.clone,\n    func: function () {\n      return that.value;\n    },\n  };\n  return that;\n}\n\nfunction getVec3UniformFunction(value) {\n  var that = {\n    value: Cartesian3.fromArray(value),\n    clone: Cartesian3.clone,\n    func: function () {\n      return that.value;\n    },\n  };\n  return that;\n}\n\nfunction getVec4UniformFunction(value) {\n  var that = {\n    value: Cartesian4.fromArray(value),\n    clone: Cartesian4.clone,\n    func: function () {\n      return that.value;\n    },\n  };\n  return that;\n}\n\nfunction getMat2UniformFunction(value) {\n  var that = {\n    value: Matrix2.fromColumnMajorArray(value),\n    clone: Matrix2.clone,\n    func: function () {\n      return that.value;\n    },\n  };\n  return that;\n}\n\nfunction getMat3UniformFunction(value) {\n  var that = {\n    value: Matrix3.fromColumnMajorArray(value),\n    clone: Matrix3.clone,\n    func: function () {\n      return that.value;\n    },\n  };\n  return that;\n}\n\nfunction getMat4UniformFunction(value) {\n  var that = {\n    value: Matrix4.fromColumnMajorArray(value),\n    clone: Matrix4.clone,\n    func: function () {\n      return that.value;\n    },\n  };\n  return that;\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction DelayLoadedTextureUniform(value, textures, defaultTexture) {\n  this._value = undefined;\n  this._textureId = value.index;\n  this._textures = textures;\n  this._defaultTexture = defaultTexture;\n}\n\nObject.defineProperties(DelayLoadedTextureUniform.prototype, {\n  value: {\n    get: function () {\n      // Use the default texture (1x1 white) until the model's texture is loaded\n      if (!defined(this._value)) {\n        var texture = this._textures[this._textureId];\n        if (defined(texture)) {\n          this._value = texture;\n        } else {\n          return this._defaultTexture;\n        }\n      }\n\n      return this._value;\n    },\n    set: function (value) {\n      this._value = value;\n    },\n  },\n});\n\nDelayLoadedTextureUniform.prototype.clone = function (source) {\n  return source;\n};\n\nDelayLoadedTextureUniform.prototype.func = undefined;\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction getTextureUniformFunction(value, textures, defaultTexture) {\n  var uniform = new DelayLoadedTextureUniform(value, textures, defaultTexture);\n  // Define function here to access closure since 'this' can't be\n  // used when the Renderer sets uniforms.\n  uniform.func = function () {\n    return uniform.value;\n  };\n  return uniform;\n}\n\nvar gltfUniformFunctions = {};\ngltfUniformFunctions[WebGLConstants.FLOAT] = getScalarUniformFunction;\ngltfUniformFunctions[WebGLConstants.FLOAT_VEC2] = getVec2UniformFunction;\ngltfUniformFunctions[WebGLConstants.FLOAT_VEC3] = getVec3UniformFunction;\ngltfUniformFunctions[WebGLConstants.FLOAT_VEC4] = getVec4UniformFunction;\ngltfUniformFunctions[WebGLConstants.INT] = getScalarUniformFunction;\ngltfUniformFunctions[WebGLConstants.INT_VEC2] = getVec2UniformFunction;\ngltfUniformFunctions[WebGLConstants.INT_VEC3] = getVec3UniformFunction;\ngltfUniformFunctions[WebGLConstants.INT_VEC4] = getVec4UniformFunction;\ngltfUniformFunctions[WebGLConstants.BOOL] = getScalarUniformFunction;\ngltfUniformFunctions[WebGLConstants.BOOL_VEC2] = getVec2UniformFunction;\ngltfUniformFunctions[WebGLConstants.BOOL_VEC3] = getVec3UniformFunction;\ngltfUniformFunctions[WebGLConstants.BOOL_VEC4] = getVec4UniformFunction;\ngltfUniformFunctions[WebGLConstants.FLOAT_MAT2] = getMat2UniformFunction;\ngltfUniformFunctions[WebGLConstants.FLOAT_MAT3] = getMat3UniformFunction;\ngltfUniformFunctions[WebGLConstants.FLOAT_MAT4] = getMat4UniformFunction;\ngltfUniformFunctions[WebGLConstants.SAMPLER_2D] = getTextureUniformFunction;\n// GLTF_SPEC: Support SAMPLER_CUBE. https://github.com/KhronosGroup/glTF/issues/40\n\nModelUtility.createUniformFunction = function (\n  type,\n  value,\n  textures,\n  defaultTexture\n) {\n  return gltfUniformFunctions[type](value, textures, defaultTexture);\n};\n\nfunction scaleFromMatrix5Array(matrix) {\n  return [\n    matrix[0],\n    matrix[1],\n    matrix[2],\n    matrix[3],\n    matrix[5],\n    matrix[6],\n    matrix[7],\n    matrix[8],\n    matrix[10],\n    matrix[11],\n    matrix[12],\n    matrix[13],\n    matrix[15],\n    matrix[16],\n    matrix[17],\n    matrix[18],\n  ];\n}\n\nfunction translateFromMatrix5Array(matrix) {\n  return [matrix[20], matrix[21], matrix[22], matrix[23]];\n}\n\nModelUtility.createUniformsForDracoQuantizedAttributes = function (\n  decodedAttributes\n) {\n  var uniformMap = {};\n  for (var attribute in decodedAttributes) {\n    if (decodedAttributes.hasOwnProperty(attribute)) {\n      var decodedData = decodedAttributes[attribute];\n      var quantization = decodedData.quantization;\n\n      if (!defined(quantization)) {\n        continue;\n      }\n\n      if (attribute.charAt(0) === \"_\") {\n        attribute = attribute.substring(1);\n      }\n\n      var uniformVarName = \"gltf_u_dec_\" + attribute.toLowerCase();\n\n      if (quantization.octEncoded) {\n        var uniformVarNameRangeConstant = uniformVarName + \"_rangeConstant\";\n        var rangeConstant = (1 << quantization.quantizationBits) - 1.0;\n        uniformMap[uniformVarNameRangeConstant] = getScalarUniformFunction(\n          rangeConstant\n        ).func;\n        continue;\n      }\n\n      var uniformVarNameNormConstant = uniformVarName + \"_normConstant\";\n      var normConstant =\n        quantization.range / (1 << quantization.quantizationBits);\n      uniformMap[uniformVarNameNormConstant] = getScalarUniformFunction(\n        normConstant\n      ).func;\n\n      var uniformVarNameMin = uniformVarName + \"_min\";\n      switch (decodedData.componentsPerAttribute) {\n        case 1:\n          uniformMap[uniformVarNameMin] = getScalarUniformFunction(\n            quantization.minValues\n          ).func;\n          break;\n        case 2:\n          uniformMap[uniformVarNameMin] = getVec2UniformFunction(\n            quantization.minValues\n          ).func;\n          break;\n        case 3:\n          uniformMap[uniformVarNameMin] = getVec3UniformFunction(\n            quantization.minValues\n          ).func;\n          break;\n        case 4:\n          uniformMap[uniformVarNameMin] = getVec4UniformFunction(\n            quantization.minValues\n          ).func;\n          break;\n      }\n    }\n  }\n\n  return uniformMap;\n};\n\nModelUtility.createUniformsForQuantizedAttributes = function (\n  gltf,\n  primitive,\n  quantizedUniforms\n) {\n  var accessors = gltf.accessors;\n  var setUniforms = {};\n  var uniformMap = {};\n\n  var attributes = primitive.attributes;\n  for (var attribute in attributes) {\n    if (attributes.hasOwnProperty(attribute)) {\n      var accessorId = attributes[attribute];\n      var a = accessors[accessorId];\n      var extensions = a.extensions;\n\n      if (attribute.charAt(0) === \"_\") {\n        attribute = attribute.substring(1);\n      }\n\n      if (defined(extensions)) {\n        var quantizedAttributes = extensions.WEB3D_quantized_attributes;\n        if (defined(quantizedAttributes)) {\n          var decodeMatrix = quantizedAttributes.decodeMatrix;\n          var uniformVariable = \"gltf_u_dec_\" + attribute.toLowerCase();\n\n          switch (a.type) {\n            case AttributeType.SCALAR:\n              uniformMap[uniformVariable] = getMat2UniformFunction(\n                decodeMatrix\n              ).func;\n              setUniforms[uniformVariable] = true;\n              break;\n            case AttributeType.VEC2:\n              uniformMap[uniformVariable] = getMat3UniformFunction(\n                decodeMatrix\n              ).func;\n              setUniforms[uniformVariable] = true;\n              break;\n            case AttributeType.VEC3:\n              uniformMap[uniformVariable] = getMat4UniformFunction(\n                decodeMatrix\n              ).func;\n              setUniforms[uniformVariable] = true;\n              break;\n            case AttributeType.VEC4:\n              // VEC4 attributes are split into scale and translate because there is no mat5 in GLSL\n              var uniformVariableScale = uniformVariable + \"_scale\";\n              var uniformVariableTranslate = uniformVariable + \"_translate\";\n              uniformMap[uniformVariableScale] = getMat4UniformFunction(\n                scaleFromMatrix5Array(decodeMatrix)\n              ).func;\n              uniformMap[uniformVariableTranslate] = getVec4UniformFunction(\n                translateFromMatrix5Array(decodeMatrix)\n              ).func;\n              setUniforms[uniformVariableScale] = true;\n              setUniforms[uniformVariableTranslate] = true;\n              break;\n          }\n        }\n      }\n    }\n  }\n\n  // If there are any unset quantized uniforms in this program, they should be set to the identity\n  for (var quantizedUniform in quantizedUniforms) {\n    if (quantizedUniforms.hasOwnProperty(quantizedUniform)) {\n      if (!setUniforms[quantizedUniform]) {\n        var properties = quantizedUniforms[quantizedUniform];\n        if (defined(properties.mat)) {\n          if (properties.mat === 2) {\n            uniformMap[quantizedUniform] = getMat2UniformFunction(\n              Matrix2.IDENTITY\n            ).func;\n          } else if (properties.mat === 3) {\n            uniformMap[quantizedUniform] = getMat3UniformFunction(\n              Matrix3.IDENTITY\n            ).func;\n          } else if (properties.mat === 4) {\n            uniformMap[quantizedUniform] = getMat4UniformFunction(\n              Matrix4.IDENTITY\n            ).func;\n          }\n        }\n        if (defined(properties.vec)) {\n          if (properties.vec === 4) {\n            uniformMap[quantizedUniform] = getVec4UniformFunction([\n              0,\n              0,\n              0,\n              0,\n            ]).func;\n          }\n        }\n      }\n    }\n  }\n  return uniformMap;\n};\n\n// This doesn't support LOCAL, which we could add if it is ever used.\nvar scratchTranslationRtc = new Cartesian3();\nvar gltfSemanticUniforms = {\n  MODEL: function (uniformState, model) {\n    return function () {\n      return uniformState.model;\n    };\n  },\n  VIEW: function (uniformState, model) {\n    return function () {\n      return uniformState.view;\n    };\n  },\n  PROJECTION: function (uniformState, model) {\n    return function () {\n      return uniformState.projection;\n    };\n  },\n  MODELVIEW: function (uniformState, model) {\n    return function () {\n      return uniformState.modelView;\n    };\n  },\n  CESIUM_RTC_MODELVIEW: function (uniformState, model) {\n    // CESIUM_RTC extension\n    var mvRtc = new Matrix4();\n    return function () {\n      if (defined(model._rtcCenter)) {\n        Matrix4.getTranslation(uniformState.model, scratchTranslationRtc);\n        Cartesian3.add(\n          scratchTranslationRtc,\n          model._rtcCenter,\n          scratchTranslationRtc\n        );\n        Matrix4.multiplyByPoint(\n          uniformState.view,\n          scratchTranslationRtc,\n          scratchTranslationRtc\n        );\n        return Matrix4.setTranslation(\n          uniformState.modelView,\n          scratchTranslationRtc,\n          mvRtc\n        );\n      }\n      return uniformState.modelView;\n    };\n  },\n  MODELVIEWPROJECTION: function (uniformState, model) {\n    return function () {\n      return uniformState.modelViewProjection;\n    };\n  },\n  MODELINVERSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseModel;\n    };\n  },\n  VIEWINVERSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseView;\n    };\n  },\n  PROJECTIONINVERSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseProjection;\n    };\n  },\n  MODELVIEWINVERSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseModelView;\n    };\n  },\n  MODELVIEWPROJECTIONINVERSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseModelViewProjection;\n    };\n  },\n  MODELINVERSETRANSPOSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseTransposeModel;\n    };\n  },\n  MODELVIEWINVERSETRANSPOSE: function (uniformState, model) {\n    return function () {\n      return uniformState.normal;\n    };\n  },\n  VIEWPORT: function (uniformState, model) {\n    return function () {\n      return uniformState.viewportCartesian4;\n    };\n  },\n  // JOINTMATRIX created in createCommand()\n};\n\nModelUtility.getGltfSemanticUniforms = function () {\n  return gltfSemanticUniforms;\n};\nexport default ModelUtility;\n"]},"metadata":{},"sourceType":"module"}