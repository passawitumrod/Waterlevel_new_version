{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n/**\n * A 3x3 matrix, indexable as a column-major order array.\n * Constructor parameters are in row-major order for code readability.\n * @alias Matrix3\n * @constructor\n *\n * @param {Number} [column0Row0=0.0] The value for column 0, row 0.\n * @param {Number} [column1Row0=0.0] The value for column 1, row 0.\n * @param {Number} [column2Row0=0.0] The value for column 2, row 0.\n * @param {Number} [column0Row1=0.0] The value for column 0, row 1.\n * @param {Number} [column1Row1=0.0] The value for column 1, row 1.\n * @param {Number} [column2Row1=0.0] The value for column 2, row 1.\n * @param {Number} [column0Row2=0.0] The value for column 0, row 2.\n * @param {Number} [column1Row2=0.0] The value for column 1, row 2.\n * @param {Number} [column2Row2=0.0] The value for column 2, row 2.\n *\n * @see Matrix3.fromColumnMajorArray\n * @see Matrix3.fromRowMajorArray\n * @see Matrix3.fromQuaternion\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix2\n * @see Matrix4\n */\n\nfunction Matrix3(column0Row0, column1Row0, column2Row0, column0Row1, column1Row1, column2Row1, column0Row2, column1Row2, column2Row2) {\n  this[0] = defaultValue(column0Row0, 0.0);\n  this[1] = defaultValue(column0Row1, 0.0);\n  this[2] = defaultValue(column0Row2, 0.0);\n  this[3] = defaultValue(column1Row0, 0.0);\n  this[4] = defaultValue(column1Row1, 0.0);\n  this[5] = defaultValue(column1Row2, 0.0);\n  this[6] = defaultValue(column2Row0, 0.0);\n  this[7] = defaultValue(column2Row1, 0.0);\n  this[8] = defaultValue(column2Row2, 0.0);\n}\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\n\n\nMatrix3.packedLength = 9;\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Matrix3} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\nMatrix3.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  array[startingIndex++] = value[0];\n  array[startingIndex++] = value[1];\n  array[startingIndex++] = value[2];\n  array[startingIndex++] = value[3];\n  array[startingIndex++] = value[4];\n  array[startingIndex++] = value[5];\n  array[startingIndex++] = value[6];\n  array[startingIndex++] = value[7];\n  array[startingIndex++] = value[8];\n  return array;\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Matrix3} [result] The object into which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n */\n\n\nMatrix3.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  result[0] = array[startingIndex++];\n  result[1] = array[startingIndex++];\n  result[2] = array[startingIndex++];\n  result[3] = array[startingIndex++];\n  result[4] = array[startingIndex++];\n  result[5] = array[startingIndex++];\n  result[6] = array[startingIndex++];\n  result[7] = array[startingIndex++];\n  result[8] = array[startingIndex++];\n  return result;\n};\n/**\n * Duplicates a Matrix3 instance.\n *\n * @param {Matrix3} matrix The matrix to duplicate.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided. (Returns undefined if matrix is undefined)\n */\n\n\nMatrix3.clone = function (matrix, result) {\n  if (!defined(matrix)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Matrix3(matrix[0], matrix[3], matrix[6], matrix[1], matrix[4], matrix[7], matrix[2], matrix[5], matrix[8]);\n  }\n\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n  result[8] = matrix[8];\n  return result;\n};\n/**\n * Creates a Matrix3 from 9 consecutive elements in an array.\n *\n * @param {Number[]} array The array whose 9 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Create the Matrix3:\n * // [1.0, 2.0, 3.0]\n * // [1.0, 2.0, 3.0]\n * // [1.0, 2.0, 3.0]\n *\n * var v = [1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];\n * var m = Cesium.Matrix3.fromArray(v);\n *\n * // Create same Matrix3 with using an offset into an array\n * var v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];\n * var m2 = Cesium.Matrix3.fromArray(v2, 2);\n */\n\n\nMatrix3.fromArray = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  result[0] = array[startingIndex];\n  result[1] = array[startingIndex + 1];\n  result[2] = array[startingIndex + 2];\n  result[3] = array[startingIndex + 3];\n  result[4] = array[startingIndex + 4];\n  result[5] = array[startingIndex + 5];\n  result[6] = array[startingIndex + 6];\n  result[7] = array[startingIndex + 7];\n  result[8] = array[startingIndex + 8];\n  return result;\n};\n/**\n * Creates a Matrix3 instance from a column-major order array.\n *\n * @param {Number[]} values The column-major order array.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n */\n\n\nMatrix3.fromColumnMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values); //>>includeEnd('debug');\n\n  return Matrix3.clone(values, result);\n};\n/**\n * Creates a Matrix3 instance from a row-major order array.\n * The resulting matrix will be in column-major order.\n *\n * @param {Number[]} values The row-major order array.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n */\n\n\nMatrix3.fromRowMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(values[0], values[1], values[2], values[3], values[4], values[5], values[6], values[7], values[8]);\n  }\n\n  result[0] = values[0];\n  result[1] = values[3];\n  result[2] = values[6];\n  result[3] = values[1];\n  result[4] = values[4];\n  result[5] = values[7];\n  result[6] = values[2];\n  result[7] = values[5];\n  result[8] = values[8];\n  return result;\n};\n/**\n * Computes a 3x3 rotation matrix from the provided quaternion.\n *\n * @param {Quaternion} quaternion the quaternion to use.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The 3x3 rotation matrix from this quaternion.\n */\n\n\nMatrix3.fromQuaternion = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion); //>>includeEnd('debug');\n\n  var x2 = quaternion.x * quaternion.x;\n  var xy = quaternion.x * quaternion.y;\n  var xz = quaternion.x * quaternion.z;\n  var xw = quaternion.x * quaternion.w;\n  var y2 = quaternion.y * quaternion.y;\n  var yz = quaternion.y * quaternion.z;\n  var yw = quaternion.y * quaternion.w;\n  var z2 = quaternion.z * quaternion.z;\n  var zw = quaternion.z * quaternion.w;\n  var w2 = quaternion.w * quaternion.w;\n  var m00 = x2 - y2 - z2 + w2;\n  var m01 = 2.0 * (xy - zw);\n  var m02 = 2.0 * (xz + yw);\n  var m10 = 2.0 * (xy + zw);\n  var m11 = -x2 + y2 - z2 + w2;\n  var m12 = 2.0 * (yz - xw);\n  var m20 = 2.0 * (xz - yw);\n  var m21 = 2.0 * (yz + xw);\n  var m22 = -x2 - y2 + z2 + w2;\n\n  if (!defined(result)) {\n    return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);\n  }\n\n  result[0] = m00;\n  result[1] = m10;\n  result[2] = m20;\n  result[3] = m01;\n  result[4] = m11;\n  result[5] = m21;\n  result[6] = m02;\n  result[7] = m12;\n  result[8] = m22;\n  return result;\n};\n/**\n * Computes a 3x3 rotation matrix from the provided headingPitchRoll. (see http://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles )\n *\n * @param {HeadingPitchRoll} headingPitchRoll the headingPitchRoll to use.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The 3x3 rotation matrix from this headingPitchRoll.\n */\n\n\nMatrix3.fromHeadingPitchRoll = function (headingPitchRoll, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"headingPitchRoll\", headingPitchRoll); //>>includeEnd('debug');\n\n  var cosTheta = Math.cos(-headingPitchRoll.pitch);\n  var cosPsi = Math.cos(-headingPitchRoll.heading);\n  var cosPhi = Math.cos(headingPitchRoll.roll);\n  var sinTheta = Math.sin(-headingPitchRoll.pitch);\n  var sinPsi = Math.sin(-headingPitchRoll.heading);\n  var sinPhi = Math.sin(headingPitchRoll.roll);\n  var m00 = cosTheta * cosPsi;\n  var m01 = -cosPhi * sinPsi + sinPhi * sinTheta * cosPsi;\n  var m02 = sinPhi * sinPsi + cosPhi * sinTheta * cosPsi;\n  var m10 = cosTheta * sinPsi;\n  var m11 = cosPhi * cosPsi + sinPhi * sinTheta * sinPsi;\n  var m12 = -sinPhi * cosPsi + cosPhi * sinTheta * sinPsi;\n  var m20 = -sinTheta;\n  var m21 = sinPhi * cosTheta;\n  var m22 = cosPhi * cosTheta;\n\n  if (!defined(result)) {\n    return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);\n  }\n\n  result[0] = m00;\n  result[1] = m10;\n  result[2] = m20;\n  result[3] = m01;\n  result[4] = m11;\n  result[5] = m21;\n  result[6] = m02;\n  result[7] = m12;\n  result[8] = m22;\n  return result;\n};\n/**\n * Computes a Matrix3 instance representing a non-uniform scale.\n *\n * @param {Cartesian3} scale The x, y, and z scale factors.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [7.0, 0.0, 0.0]\n * //   [0.0, 8.0, 0.0]\n * //   [0.0, 0.0, 9.0]\n * var m = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));\n */\n\n\nMatrix3.fromScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scale\", scale); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(scale.x, 0.0, 0.0, 0.0, scale.y, 0.0, 0.0, 0.0, scale.z);\n  }\n\n  result[0] = scale.x;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = scale.y;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = scale.z;\n  return result;\n};\n/**\n * Computes a Matrix3 instance representing a uniform scale.\n *\n * @param {Number} scale The uniform scale factor.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [2.0, 0.0, 0.0]\n * //   [0.0, 2.0, 0.0]\n * //   [0.0, 0.0, 2.0]\n * var m = Cesium.Matrix3.fromUniformScale(2.0);\n */\n\n\nMatrix3.fromUniformScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"scale\", scale); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(scale, 0.0, 0.0, 0.0, scale, 0.0, 0.0, 0.0, scale);\n  }\n\n  result[0] = scale;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = scale;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = scale;\n  return result;\n};\n/**\n * Computes a Matrix3 instance representing the cross product equivalent matrix of a Cartesian3 vector.\n *\n * @param {Cartesian3} vector the vector on the left hand side of the cross product operation.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [0.0, -9.0,  8.0]\n * //   [9.0,  0.0, -7.0]\n * //   [-8.0, 7.0,  0.0]\n * var m = Cesium.Matrix3.fromCrossProduct(new Cesium.Cartesian3(7.0, 8.0, 9.0));\n */\n\n\nMatrix3.fromCrossProduct = function (vector, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"vector\", vector); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(0.0, -vector.z, vector.y, vector.z, 0.0, -vector.x, -vector.y, vector.x, 0.0);\n  }\n\n  result[0] = 0.0;\n  result[1] = vector.z;\n  result[2] = -vector.y;\n  result[3] = -vector.z;\n  result[4] = 0.0;\n  result[5] = vector.x;\n  result[6] = vector.y;\n  result[7] = -vector.x;\n  result[8] = 0.0;\n  return result;\n};\n/**\n * Creates a rotation matrix around the x-axis.\n *\n * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise around the x-axis.\n * var p = new Cesium.Cartesian3(5, 6, 7);\n * var m = Cesium.Matrix3.fromRotationX(Cesium.Math.toRadians(45.0));\n * var rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n */\n\n\nMatrix3.fromRotationX = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle); //>>includeEnd('debug');\n\n  var cosAngle = Math.cos(angle);\n  var sinAngle = Math.sin(angle);\n\n  if (!defined(result)) {\n    return new Matrix3(1.0, 0.0, 0.0, 0.0, cosAngle, -sinAngle, 0.0, sinAngle, cosAngle);\n  }\n\n  result[0] = 1.0;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = cosAngle;\n  result[5] = sinAngle;\n  result[6] = 0.0;\n  result[7] = -sinAngle;\n  result[8] = cosAngle;\n  return result;\n};\n/**\n * Creates a rotation matrix around the y-axis.\n *\n * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise around the y-axis.\n * var p = new Cesium.Cartesian3(5, 6, 7);\n * var m = Cesium.Matrix3.fromRotationY(Cesium.Math.toRadians(45.0));\n * var rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n */\n\n\nMatrix3.fromRotationY = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle); //>>includeEnd('debug');\n\n  var cosAngle = Math.cos(angle);\n  var sinAngle = Math.sin(angle);\n\n  if (!defined(result)) {\n    return new Matrix3(cosAngle, 0.0, sinAngle, 0.0, 1.0, 0.0, -sinAngle, 0.0, cosAngle);\n  }\n\n  result[0] = cosAngle;\n  result[1] = 0.0;\n  result[2] = -sinAngle;\n  result[3] = 0.0;\n  result[4] = 1.0;\n  result[5] = 0.0;\n  result[6] = sinAngle;\n  result[7] = 0.0;\n  result[8] = cosAngle;\n  return result;\n};\n/**\n * Creates a rotation matrix around the z-axis.\n *\n * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise around the z-axis.\n * var p = new Cesium.Cartesian3(5, 6, 7);\n * var m = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(45.0));\n * var rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n */\n\n\nMatrix3.fromRotationZ = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle); //>>includeEnd('debug');\n\n  var cosAngle = Math.cos(angle);\n  var sinAngle = Math.sin(angle);\n\n  if (!defined(result)) {\n    return new Matrix3(cosAngle, -sinAngle, 0.0, sinAngle, cosAngle, 0.0, 0.0, 0.0, 1.0);\n  }\n\n  result[0] = cosAngle;\n  result[1] = sinAngle;\n  result[2] = 0.0;\n  result[3] = -sinAngle;\n  result[4] = cosAngle;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 1.0;\n  return result;\n};\n/**\n * Creates an Array from the provided Matrix3 instance.\n * The array will be in column-major order.\n *\n * @param {Matrix3} matrix The matrix to use..\n * @param {Number[]} [result] The Array onto which to store the result.\n * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.\n */\n\n\nMatrix3.toArray = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return [matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5], matrix[6], matrix[7], matrix[8]];\n  }\n\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n  result[8] = matrix[8];\n  return result;\n};\n/**\n * Computes the array index of the element at the provided row and column.\n *\n * @param {Number} row The zero-based index of the row.\n * @param {Number} column The zero-based index of the column.\n * @returns {Number} The index of the element at the provided row and column.\n *\n * @exception {DeveloperError} row must be 0, 1, or 2.\n * @exception {DeveloperError} column must be 0, 1, or 2.\n *\n * @example\n * var myMatrix = new Cesium.Matrix3();\n * var column1Row0Index = Cesium.Matrix3.getElementIndex(1, 0);\n * var column1Row0 = myMatrix[column1Row0Index]\n * myMatrix[column1Row0Index] = 10.0;\n */\n\n\nMatrix3.getElementIndex = function (column, row) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"row\", row, 0);\n  Check.typeOf.number.lessThanOrEquals(\"row\", row, 2);\n  Check.typeOf.number.greaterThanOrEquals(\"column\", column, 0);\n  Check.typeOf.number.lessThanOrEquals(\"column\", column, 2); //>>includeEnd('debug');\n\n  return column * 3 + row;\n};\n/**\n * Retrieves a copy of the matrix column at the provided index as a Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Number} index The zero-based index of the column to retrieve.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\n\n\nMatrix3.getColumn = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var startIndex = index * 3;\n  var x = matrix[startIndex];\n  var y = matrix[startIndex + 1];\n  var z = matrix[startIndex + 2];\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n/**\n * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Number} index The zero-based index of the column to set.\n * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified column.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\n\n\nMatrix3.setColumn = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result = Matrix3.clone(matrix, result);\n  var startIndex = index * 3;\n  result[startIndex] = cartesian.x;\n  result[startIndex + 1] = cartesian.y;\n  result[startIndex + 2] = cartesian.z;\n  return result;\n};\n/**\n * Retrieves a copy of the matrix row at the provided index as a Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Number} index The zero-based index of the row to retrieve.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\n\n\nMatrix3.getRow = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var x = matrix[index];\n  var y = matrix[index + 3];\n  var z = matrix[index + 6];\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n/**\n * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Number} index The zero-based index of the row to set.\n * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified row.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\n\n\nMatrix3.setRow = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result = Matrix3.clone(matrix, result);\n  result[index] = cartesian.x;\n  result[index + 3] = cartesian.y;\n  result[index + 6] = cartesian.z;\n  return result;\n};\n\nvar scratchColumn = new Cartesian3();\n/**\n * Extracts the non-uniform scale assuming the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\n\nMatrix3.getScale = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = Cartesian3.magnitude(Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn));\n  result.y = Cartesian3.magnitude(Cartesian3.fromElements(matrix[3], matrix[4], matrix[5], scratchColumn));\n  result.z = Cartesian3.magnitude(Cartesian3.fromElements(matrix[6], matrix[7], matrix[8], scratchColumn));\n  return result;\n};\n\nvar scratchScale = new Cartesian3();\n/**\n * Computes the maximum scale assuming the matrix is an affine transformation.\n * The maximum scale is the maximum length of the column vectors.\n *\n * @param {Matrix3} matrix The matrix.\n * @returns {Number} The maximum scale.\n */\n\nMatrix3.getMaximumScale = function (matrix) {\n  Matrix3.getScale(matrix, scratchScale);\n  return Cartesian3.maximumComponent(scratchScale);\n};\n/**\n * Computes the product of two matrices.\n *\n * @param {Matrix3} left The first matrix.\n * @param {Matrix3} right The second matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\n\n\nMatrix3.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var column0Row0 = left[0] * right[0] + left[3] * right[1] + left[6] * right[2];\n  var column0Row1 = left[1] * right[0] + left[4] * right[1] + left[7] * right[2];\n  var column0Row2 = left[2] * right[0] + left[5] * right[1] + left[8] * right[2];\n  var column1Row0 = left[0] * right[3] + left[3] * right[4] + left[6] * right[5];\n  var column1Row1 = left[1] * right[3] + left[4] * right[4] + left[7] * right[5];\n  var column1Row2 = left[2] * right[3] + left[5] * right[4] + left[8] * right[5];\n  var column2Row0 = left[0] * right[6] + left[3] * right[7] + left[6] * right[8];\n  var column2Row1 = left[1] * right[6] + left[4] * right[7] + left[7] * right[8];\n  var column2Row2 = left[2] * right[6] + left[5] * right[7] + left[8] * right[8];\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column0Row2;\n  result[3] = column1Row0;\n  result[4] = column1Row1;\n  result[5] = column1Row2;\n  result[6] = column2Row0;\n  result[7] = column2Row1;\n  result[8] = column2Row2;\n  return result;\n};\n/**\n * Computes the sum of two matrices.\n *\n * @param {Matrix3} left The first matrix.\n * @param {Matrix3} right The second matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\n\n\nMatrix3.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result[0] = left[0] + right[0];\n  result[1] = left[1] + right[1];\n  result[2] = left[2] + right[2];\n  result[3] = left[3] + right[3];\n  result[4] = left[4] + right[4];\n  result[5] = left[5] + right[5];\n  result[6] = left[6] + right[6];\n  result[7] = left[7] + right[7];\n  result[8] = left[8] + right[8];\n  return result;\n};\n/**\n * Computes the difference of two matrices.\n *\n * @param {Matrix3} left The first matrix.\n * @param {Matrix3} right The second matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\n\n\nMatrix3.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result[0] = left[0] - right[0];\n  result[1] = left[1] - right[1];\n  result[2] = left[2] - right[2];\n  result[3] = left[3] - right[3];\n  result[4] = left[4] - right[4];\n  result[5] = left[5] - right[5];\n  result[6] = left[6] - right[6];\n  result[7] = left[7] - right[7];\n  result[8] = left[8] - right[8];\n  return result;\n};\n/**\n * Computes the product of a matrix and a column vector.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Cartesian3} cartesian The column.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\n\n\nMatrix3.multiplyByVector = function (matrix, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var vX = cartesian.x;\n  var vY = cartesian.y;\n  var vZ = cartesian.z;\n  var x = matrix[0] * vX + matrix[3] * vY + matrix[6] * vZ;\n  var y = matrix[1] * vX + matrix[4] * vY + matrix[7] * vZ;\n  var z = matrix[2] * vX + matrix[5] * vY + matrix[8] * vZ;\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n/**\n * Computes the product of a matrix and a scalar.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Number} scalar The number to multiply by.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\n\n\nMatrix3.multiplyByScalar = function (matrix, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scalar;\n  result[1] = matrix[1] * scalar;\n  result[2] = matrix[2] * scalar;\n  result[3] = matrix[3] * scalar;\n  result[4] = matrix[4] * scalar;\n  result[5] = matrix[5] * scalar;\n  result[6] = matrix[6] * scalar;\n  result[7] = matrix[7] * scalar;\n  result[8] = matrix[8] * scalar;\n  return result;\n};\n/**\n * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.\n *\n * @param {Matrix3} matrix The matrix on the left-hand side.\n * @param {Cartesian3} scale The non-uniform scale on the right-hand side.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n *\n * @example\n * // Instead of Cesium.Matrix3.multiply(m, Cesium.Matrix3.fromScale(scale), m);\n * Cesium.Matrix3.multiplyByScale(m, scale, m);\n *\n * @see Matrix3.fromScale\n * @see Matrix3.multiplyByUniformScale\n */\n\n\nMatrix3.multiplyByScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale.x;\n  result[1] = matrix[1] * scale.x;\n  result[2] = matrix[2] * scale.x;\n  result[3] = matrix[3] * scale.y;\n  result[4] = matrix[4] * scale.y;\n  result[5] = matrix[5] * scale.y;\n  result[6] = matrix[6] * scale.z;\n  result[7] = matrix[7] * scale.z;\n  result[8] = matrix[8] * scale.z;\n  return result;\n};\n/**\n * Creates a negated copy of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to negate.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\n\n\nMatrix3.negate = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result[0] = -matrix[0];\n  result[1] = -matrix[1];\n  result[2] = -matrix[2];\n  result[3] = -matrix[3];\n  result[4] = -matrix[4];\n  result[5] = -matrix[5];\n  result[6] = -matrix[6];\n  result[7] = -matrix[7];\n  result[8] = -matrix[8];\n  return result;\n};\n/**\n * Computes the transpose of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to transpose.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\n\n\nMatrix3.transpose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var column0Row0 = matrix[0];\n  var column0Row1 = matrix[3];\n  var column0Row2 = matrix[6];\n  var column1Row0 = matrix[1];\n  var column1Row1 = matrix[4];\n  var column1Row2 = matrix[7];\n  var column2Row0 = matrix[2];\n  var column2Row1 = matrix[5];\n  var column2Row2 = matrix[8];\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column0Row2;\n  result[3] = column1Row0;\n  result[4] = column1Row1;\n  result[5] = column1Row2;\n  result[6] = column2Row0;\n  result[7] = column2Row1;\n  result[8] = column2Row2;\n  return result;\n};\n\nvar UNIT = new Cartesian3(1, 1, 1);\n/**\n * Extracts the rotation assuming the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter\n */\n\nMatrix3.getRotation = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var inverseScale = Cartesian3.divideComponents(UNIT, Matrix3.getScale(matrix, scratchScale), scratchScale);\n  result = Matrix3.multiplyByScale(matrix, inverseScale, result);\n  return result;\n};\n\nfunction computeFrobeniusNorm(matrix) {\n  var norm = 0.0;\n\n  for (var i = 0; i < 9; ++i) {\n    var temp = matrix[i];\n    norm += temp * temp;\n  }\n\n  return Math.sqrt(norm);\n}\n\nvar rowVal = [1, 0, 0];\nvar colVal = [2, 2, 1];\n\nfunction offDiagonalFrobeniusNorm(matrix) {\n  // Computes the \"off-diagonal\" Frobenius norm.\n  // Assumes matrix is symmetric.\n  var norm = 0.0;\n\n  for (var i = 0; i < 3; ++i) {\n    var temp = matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])];\n    norm += 2.0 * temp * temp;\n  }\n\n  return Math.sqrt(norm);\n}\n\nfunction shurDecomposition(matrix, result) {\n  // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n  // section 8.4.2 The 2by2 Symmetric Schur Decomposition.\n  //\n  // The routine takes a matrix, which is assumed to be symmetric, and\n  // finds the largest off-diagonal term, and then creates\n  // a matrix (result) which can be used to help reduce it\n  var tolerance = CesiumMath.EPSILON15;\n  var maxDiagonal = 0.0;\n  var rotAxis = 1; // find pivot (rotAxis) based on max diagonal of matrix\n\n  for (var i = 0; i < 3; ++i) {\n    var temp = Math.abs(matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])]);\n\n    if (temp > maxDiagonal) {\n      rotAxis = i;\n      maxDiagonal = temp;\n    }\n  }\n\n  var c = 1.0;\n  var s = 0.0;\n  var p = rowVal[rotAxis];\n  var q = colVal[rotAxis];\n\n  if (Math.abs(matrix[Matrix3.getElementIndex(q, p)]) > tolerance) {\n    var qq = matrix[Matrix3.getElementIndex(q, q)];\n    var pp = matrix[Matrix3.getElementIndex(p, p)];\n    var qp = matrix[Matrix3.getElementIndex(q, p)];\n    var tau = (qq - pp) / 2.0 / qp;\n    var t;\n\n    if (tau < 0.0) {\n      t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));\n    } else {\n      t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));\n    }\n\n    c = 1.0 / Math.sqrt(1.0 + t * t);\n    s = t * c;\n  }\n\n  result = Matrix3.clone(Matrix3.IDENTITY, result);\n  result[Matrix3.getElementIndex(p, p)] = result[Matrix3.getElementIndex(q, q)] = c;\n  result[Matrix3.getElementIndex(q, p)] = s;\n  result[Matrix3.getElementIndex(p, q)] = -s;\n  return result;\n}\n\nvar jMatrix = new Matrix3();\nvar jMatrixTranspose = new Matrix3();\n/**\n * Computes the eigenvectors and eigenvalues of a symmetric matrix.\n * <p>\n * Returns a diagonal matrix and unitary matrix such that:\n * <code>matrix = unitary matrix * diagonal matrix * transpose(unitary matrix)</code>\n * </p>\n * <p>\n * The values along the diagonal of the diagonal matrix are the eigenvalues. The columns\n * of the unitary matrix are the corresponding eigenvectors.\n * </p>\n *\n * @param {Matrix3} matrix The matrix to decompose into diagonal and unitary matrix. Expected to be symmetric.\n * @param {Object} [result] An object with unitary and diagonal properties which are matrices onto which to store the result.\n * @returns {Object} An object with unitary and diagonal properties which are the unitary and diagonal matrices, respectively.\n *\n * @example\n * var a = //... symetric matrix\n * var result = {\n *     unitary : new Cesium.Matrix3(),\n *     diagonal : new Cesium.Matrix3()\n * };\n * Cesium.Matrix3.computeEigenDecomposition(a, result);\n *\n * var unitaryTranspose = Cesium.Matrix3.transpose(result.unitary, new Cesium.Matrix3());\n * var b = Cesium.Matrix3.multiply(result.unitary, result.diagonal, new Cesium.Matrix3());\n * Cesium.Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a\n *\n * var lambda = Cesium.Matrix3.getColumn(result.diagonal, 0, new Cesium.Cartesian3()).x;  // first eigenvalue\n * var v = Cesium.Matrix3.getColumn(result.unitary, 0, new Cesium.Cartesian3());          // first eigenvector\n * var c = Cesium.Cartesian3.multiplyByScalar(v, lambda, new Cesium.Cartesian3());        // equal to Cesium.Matrix3.multiplyByVector(a, v)\n */\n\nMatrix3.computeEigenDecomposition = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix); //>>includeEnd('debug');\n  // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n  // section 8.4.3 The Classical Jacobi Algorithm\n\n  var tolerance = CesiumMath.EPSILON20;\n  var maxSweeps = 10;\n  var count = 0;\n  var sweep = 0;\n\n  if (!defined(result)) {\n    result = {};\n  }\n\n  var unitaryMatrix = result.unitary = Matrix3.clone(Matrix3.IDENTITY, result.unitary);\n  var diagMatrix = result.diagonal = Matrix3.clone(matrix, result.diagonal);\n  var epsilon = tolerance * computeFrobeniusNorm(diagMatrix);\n\n  while (sweep < maxSweeps && offDiagonalFrobeniusNorm(diagMatrix) > epsilon) {\n    shurDecomposition(diagMatrix, jMatrix);\n    Matrix3.transpose(jMatrix, jMatrixTranspose);\n    Matrix3.multiply(diagMatrix, jMatrix, diagMatrix);\n    Matrix3.multiply(jMatrixTranspose, diagMatrix, diagMatrix);\n    Matrix3.multiply(unitaryMatrix, jMatrix, unitaryMatrix);\n\n    if (++count > 2) {\n      ++sweep;\n      count = 0;\n    }\n  }\n\n  return result;\n};\n/**\n * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.\n *\n * @param {Matrix3} matrix The matrix with signed elements.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\n\n\nMatrix3.abs = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result[0] = Math.abs(matrix[0]);\n  result[1] = Math.abs(matrix[1]);\n  result[2] = Math.abs(matrix[2]);\n  result[3] = Math.abs(matrix[3]);\n  result[4] = Math.abs(matrix[4]);\n  result[5] = Math.abs(matrix[5]);\n  result[6] = Math.abs(matrix[6]);\n  result[7] = Math.abs(matrix[7]);\n  result[8] = Math.abs(matrix[8]);\n  return result;\n};\n/**\n * Computes the determinant of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @returns {Number} The value of the determinant of the matrix.\n */\n\n\nMatrix3.determinant = function (matrix) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix); //>>includeEnd('debug');\n\n  var m11 = matrix[0];\n  var m21 = matrix[3];\n  var m31 = matrix[6];\n  var m12 = matrix[1];\n  var m22 = matrix[4];\n  var m32 = matrix[7];\n  var m13 = matrix[2];\n  var m23 = matrix[5];\n  var m33 = matrix[8];\n  return m11 * (m22 * m33 - m23 * m32) + m12 * (m23 * m31 - m21 * m33) + m13 * (m21 * m32 - m22 * m31);\n};\n/**\n * Computes the inverse of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to invert.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @exception {DeveloperError} matrix is not invertible.\n */\n\n\nMatrix3.inverse = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var m11 = matrix[0];\n  var m21 = matrix[1];\n  var m31 = matrix[2];\n  var m12 = matrix[3];\n  var m22 = matrix[4];\n  var m32 = matrix[5];\n  var m13 = matrix[6];\n  var m23 = matrix[7];\n  var m33 = matrix[8];\n  var determinant = Matrix3.determinant(matrix); //>>includeStart('debug', pragmas.debug);\n\n  if (Math.abs(determinant) <= CesiumMath.EPSILON15) {\n    throw new DeveloperError(\"matrix is not invertible\");\n  } //>>includeEnd('debug');\n\n\n  result[0] = m22 * m33 - m23 * m32;\n  result[1] = m23 * m31 - m21 * m33;\n  result[2] = m21 * m32 - m22 * m31;\n  result[3] = m13 * m32 - m12 * m33;\n  result[4] = m11 * m33 - m13 * m31;\n  result[5] = m12 * m31 - m11 * m32;\n  result[6] = m12 * m23 - m13 * m22;\n  result[7] = m13 * m21 - m11 * m23;\n  result[8] = m11 * m22 - m12 * m21;\n  var scale = 1.0 / determinant;\n  return Matrix3.multiplyByScalar(result, scale, result);\n};\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix3} [left] The first matrix.\n * @param {Matrix3} [right] The second matrix.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\n\n\nMatrix3.equals = function (left, right) {\n  return left === right || defined(left) && defined(right) && left[0] === right[0] && left[1] === right[1] && left[2] === right[2] && left[3] === right[3] && left[4] === right[4] && left[5] === right[5] && left[6] === right[6] && left[7] === right[7] && left[8] === right[8];\n};\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix3} [left] The first matrix.\n * @param {Matrix3} [right] The second matrix.\n * @param {Number} epsilon The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\n\n\nMatrix3.equalsEpsilon = function (left, right, epsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"epsilon\", epsilon); //>>includeEnd('debug');\n\n  return left === right || defined(left) && defined(right) && Math.abs(left[0] - right[0]) <= epsilon && Math.abs(left[1] - right[1]) <= epsilon && Math.abs(left[2] - right[2]) <= epsilon && Math.abs(left[3] - right[3]) <= epsilon && Math.abs(left[4] - right[4]) <= epsilon && Math.abs(left[5] - right[5]) <= epsilon && Math.abs(left[6] - right[6]) <= epsilon && Math.abs(left[7] - right[7]) <= epsilon && Math.abs(left[8] - right[8]) <= epsilon;\n};\n/**\n * An immutable Matrix3 instance initialized to the identity matrix.\n *\n * @type {Matrix3}\n * @constant\n */\n\n\nMatrix3.IDENTITY = Object.freeze(new Matrix3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0));\n/**\n * An immutable Matrix3 instance initialized to the zero matrix.\n *\n * @type {Matrix3}\n * @constant\n */\n\nMatrix3.ZERO = Object.freeze(new Matrix3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));\n/**\n * The index into Matrix3 for column 0, row 0.\n *\n * @type {Number}\n * @constant\n */\n\nMatrix3.COLUMN0ROW0 = 0;\n/**\n * The index into Matrix3 for column 0, row 1.\n *\n * @type {Number}\n * @constant\n */\n\nMatrix3.COLUMN0ROW1 = 1;\n/**\n * The index into Matrix3 for column 0, row 2.\n *\n * @type {Number}\n * @constant\n */\n\nMatrix3.COLUMN0ROW2 = 2;\n/**\n * The index into Matrix3 for column 1, row 0.\n *\n * @type {Number}\n * @constant\n */\n\nMatrix3.COLUMN1ROW0 = 3;\n/**\n * The index into Matrix3 for column 1, row 1.\n *\n * @type {Number}\n * @constant\n */\n\nMatrix3.COLUMN1ROW1 = 4;\n/**\n * The index into Matrix3 for column 1, row 2.\n *\n * @type {Number}\n * @constant\n */\n\nMatrix3.COLUMN1ROW2 = 5;\n/**\n * The index into Matrix3 for column 2, row 0.\n *\n * @type {Number}\n * @constant\n */\n\nMatrix3.COLUMN2ROW0 = 6;\n/**\n * The index into Matrix3 for column 2, row 1.\n *\n * @type {Number}\n * @constant\n */\n\nMatrix3.COLUMN2ROW1 = 7;\n/**\n * The index into Matrix3 for column 2, row 2.\n *\n * @type {Number}\n * @constant\n */\n\nMatrix3.COLUMN2ROW2 = 8;\nObject.defineProperties(Matrix3.prototype, {\n  /**\n   * Gets the number of items in the collection.\n   * @memberof Matrix3.prototype\n   *\n   * @type {Number}\n   */\n  length: {\n    get: function () {\n      return Matrix3.packedLength;\n    }\n  }\n});\n/**\n * Duplicates the provided Matrix3 instance.\n *\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n */\n\nMatrix3.prototype.clone = function (result) {\n  return Matrix3.clone(this, result);\n};\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix3} [right] The right hand side matrix.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\n\n\nMatrix3.prototype.equals = function (right) {\n  return Matrix3.equals(this, right);\n};\n/**\n * @private\n */\n\n\nMatrix3.equalsArray = function (matrix, array, offset) {\n  return matrix[0] === array[offset] && matrix[1] === array[offset + 1] && matrix[2] === array[offset + 2] && matrix[3] === array[offset + 3] && matrix[4] === array[offset + 4] && matrix[5] === array[offset + 5] && matrix[6] === array[offset + 6] && matrix[7] === array[offset + 7] && matrix[8] === array[offset + 8];\n};\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix3} [right] The right hand side matrix.\n * @param {Number} epsilon The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\n\n\nMatrix3.prototype.equalsEpsilon = function (right, epsilon) {\n  return Matrix3.equalsEpsilon(this, right, epsilon);\n};\n/**\n * Creates a string representing this Matrix with each row being\n * on a separate line and in the format '(column0, column1, column2)'.\n *\n * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2)'.\n */\n\n\nMatrix3.prototype.toString = function () {\n  return \"(\" + this[0] + \", \" + this[3] + \", \" + this[6] + \")\\n\" + \"(\" + this[1] + \", \" + this[4] + \", \" + this[7] + \")\\n\" + \"(\" + this[2] + \", \" + this[5] + \", \" + this[8] + \")\";\n};\n\nexport default Matrix3;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/Matrix3.js"],"names":["Cartesian3","Check","defaultValue","defined","DeveloperError","CesiumMath","Matrix3","column0Row0","column1Row0","column2Row0","column0Row1","column1Row1","column2Row1","column0Row2","column1Row2","column2Row2","packedLength","pack","value","array","startingIndex","typeOf","object","unpack","result","clone","matrix","undefined","fromArray","fromColumnMajorArray","values","fromRowMajorArray","fromQuaternion","quaternion","x2","x","xy","y","xz","z","xw","w","y2","yz","yw","z2","zw","w2","m00","m01","m02","m10","m11","m12","m20","m21","m22","fromHeadingPitchRoll","headingPitchRoll","cosTheta","Math","cos","pitch","cosPsi","heading","cosPhi","roll","sinTheta","sin","sinPsi","sinPhi","fromScale","scale","fromUniformScale","number","fromCrossProduct","vector","fromRotationX","angle","cosAngle","sinAngle","fromRotationY","fromRotationZ","toArray","getElementIndex","column","row","greaterThanOrEquals","lessThanOrEquals","getColumn","index","startIndex","setColumn","cartesian","getRow","setRow","scratchColumn","getScale","magnitude","fromElements","scratchScale","getMaximumScale","maximumComponent","multiply","left","right","add","subtract","multiplyByVector","vX","vY","vZ","multiplyByScalar","scalar","multiplyByScale","negate","transpose","UNIT","getRotation","inverseScale","divideComponents","computeFrobeniusNorm","norm","i","temp","sqrt","rowVal","colVal","offDiagonalFrobeniusNorm","shurDecomposition","tolerance","EPSILON15","maxDiagonal","rotAxis","abs","c","s","p","q","qq","pp","qp","tau","t","IDENTITY","jMatrix","jMatrixTranspose","computeEigenDecomposition","EPSILON20","maxSweeps","count","sweep","unitaryMatrix","unitary","diagMatrix","diagonal","epsilon","determinant","m31","m32","m13","m23","m33","inverse","equals","equalsEpsilon","Object","freeze","ZERO","COLUMN0ROW0","COLUMN0ROW1","COLUMN0ROW2","COLUMN1ROW0","COLUMN1ROW1","COLUMN1ROW2","COLUMN2ROW0","COLUMN2ROW1","COLUMN2ROW2","defineProperties","prototype","length","get","equalsArray","offset","toString"],"mappings":"AAAA,OAAOA,UAAP,MAAuB,iBAAvB;AACA,OAAOC,KAAP,MAAkB,YAAlB;AACA,OAAOC,YAAP,MAAyB,mBAAzB;AACA,OAAOC,OAAP,MAAoB,cAApB;AACA,OAAOC,cAAP,MAA2B,qBAA3B;AACA,OAAOC,UAAP,MAAuB,WAAvB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA,SAASC,OAAT,CACEC,WADF,EAEEC,WAFF,EAGEC,WAHF,EAIEC,WAJF,EAKEC,WALF,EAMEC,WANF,EAOEC,WAPF,EAQEC,WARF,EASEC,WATF,EAUE;AACA,OAAK,CAAL,IAAUb,YAAY,CAACK,WAAD,EAAc,GAAd,CAAtB;AACA,OAAK,CAAL,IAAUL,YAAY,CAACQ,WAAD,EAAc,GAAd,CAAtB;AACA,OAAK,CAAL,IAAUR,YAAY,CAACW,WAAD,EAAc,GAAd,CAAtB;AACA,OAAK,CAAL,IAAUX,YAAY,CAACM,WAAD,EAAc,GAAd,CAAtB;AACA,OAAK,CAAL,IAAUN,YAAY,CAACS,WAAD,EAAc,GAAd,CAAtB;AACA,OAAK,CAAL,IAAUT,YAAY,CAACY,WAAD,EAAc,GAAd,CAAtB;AACA,OAAK,CAAL,IAAUZ,YAAY,CAACO,WAAD,EAAc,GAAd,CAAtB;AACA,OAAK,CAAL,IAAUP,YAAY,CAACU,WAAD,EAAc,GAAd,CAAtB;AACA,OAAK,CAAL,IAAUV,YAAY,CAACa,WAAD,EAAc,GAAd,CAAtB;AACD;AAED;;;;;;AAIAT,OAAO,CAACU,YAAR,GAAuB,CAAvB;AAEA;;;;;;;;;;AASAV,OAAO,CAACW,IAAR,GAAe,UAAUC,KAAV,EAAiBC,KAAjB,EAAwBC,aAAxB,EAAuC;AACpD;AACAnB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,OAApB,EAA6BJ,KAA7B;AACAjB,EAAAA,KAAK,CAACE,OAAN,CAAc,OAAd,EAAuBgB,KAAvB,EAHoD,CAIpD;;AAEAC,EAAAA,aAAa,GAAGlB,YAAY,CAACkB,aAAD,EAAgB,CAAhB,CAA5B;AAEAD,EAAAA,KAAK,CAACC,aAAa,EAAd,CAAL,GAAyBF,KAAK,CAAC,CAAD,CAA9B;AACAC,EAAAA,KAAK,CAACC,aAAa,EAAd,CAAL,GAAyBF,KAAK,CAAC,CAAD,CAA9B;AACAC,EAAAA,KAAK,CAACC,aAAa,EAAd,CAAL,GAAyBF,KAAK,CAAC,CAAD,CAA9B;AACAC,EAAAA,KAAK,CAACC,aAAa,EAAd,CAAL,GAAyBF,KAAK,CAAC,CAAD,CAA9B;AACAC,EAAAA,KAAK,CAACC,aAAa,EAAd,CAAL,GAAyBF,KAAK,CAAC,CAAD,CAA9B;AACAC,EAAAA,KAAK,CAACC,aAAa,EAAd,CAAL,GAAyBF,KAAK,CAAC,CAAD,CAA9B;AACAC,EAAAA,KAAK,CAACC,aAAa,EAAd,CAAL,GAAyBF,KAAK,CAAC,CAAD,CAA9B;AACAC,EAAAA,KAAK,CAACC,aAAa,EAAd,CAAL,GAAyBF,KAAK,CAAC,CAAD,CAA9B;AACAC,EAAAA,KAAK,CAACC,aAAa,EAAd,CAAL,GAAyBF,KAAK,CAAC,CAAD,CAA9B;AAEA,SAAOC,KAAP;AACD,CAnBD;AAqBA;;;;;;;;;;AAQAb,OAAO,CAACiB,MAAR,GAAiB,UAAUJ,KAAV,EAAiBC,aAAjB,EAAgCI,MAAhC,EAAwC;AACvD;AACAvB,EAAAA,KAAK,CAACE,OAAN,CAAc,OAAd,EAAuBgB,KAAvB,EAFuD,CAGvD;;AAEAC,EAAAA,aAAa,GAAGlB,YAAY,CAACkB,aAAD,EAAgB,CAAhB,CAA5B;;AAEA,MAAI,CAACjB,OAAO,CAACqB,MAAD,CAAZ,EAAsB;AACpBA,IAAAA,MAAM,GAAG,IAAIlB,OAAJ,EAAT;AACD;;AAEDkB,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYL,KAAK,CAACC,aAAa,EAAd,CAAjB;AACAI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYL,KAAK,CAACC,aAAa,EAAd,CAAjB;AACAI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYL,KAAK,CAACC,aAAa,EAAd,CAAjB;AACAI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYL,KAAK,CAACC,aAAa,EAAd,CAAjB;AACAI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYL,KAAK,CAACC,aAAa,EAAd,CAAjB;AACAI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYL,KAAK,CAACC,aAAa,EAAd,CAAjB;AACAI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYL,KAAK,CAACC,aAAa,EAAd,CAAjB;AACAI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYL,KAAK,CAACC,aAAa,EAAd,CAAjB;AACAI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYL,KAAK,CAACC,aAAa,EAAd,CAAjB;AACA,SAAOI,MAAP;AACD,CArBD;AAuBA;;;;;;;;;AAOAlB,OAAO,CAACmB,KAAR,GAAgB,UAAUC,MAAV,EAAkBF,MAAlB,EAA0B;AACxC,MAAI,CAACrB,OAAO,CAACuB,MAAD,CAAZ,EAAsB;AACpB,WAAOC,SAAP;AACD;;AACD,MAAI,CAACxB,OAAO,CAACqB,MAAD,CAAZ,EAAsB;AACpB,WAAO,IAAIlB,OAAJ,CACLoB,MAAM,CAAC,CAAD,CADD,EAELA,MAAM,CAAC,CAAD,CAFD,EAGLA,MAAM,CAAC,CAAD,CAHD,EAILA,MAAM,CAAC,CAAD,CAJD,EAKLA,MAAM,CAAC,CAAD,CALD,EAMLA,MAAM,CAAC,CAAD,CAND,EAOLA,MAAM,CAAC,CAAD,CAPD,EAQLA,MAAM,CAAC,CAAD,CARD,EASLA,MAAM,CAAC,CAAD,CATD,CAAP;AAWD;;AACDF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAlB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAlB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAlB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAlB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAlB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAlB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAlB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAlB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAlB;AACA,SAAOF,MAAP;AACD,CA3BD;AA6BA;;;;;;;;;;;;;;;;;;;;;;;AAqBAlB,OAAO,CAACsB,SAAR,GAAoB,UAAUT,KAAV,EAAiBC,aAAjB,EAAgCI,MAAhC,EAAwC;AAC1D;AACAvB,EAAAA,KAAK,CAACE,OAAN,CAAc,OAAd,EAAuBgB,KAAvB,EAF0D,CAG1D;;AAEAC,EAAAA,aAAa,GAAGlB,YAAY,CAACkB,aAAD,EAAgB,CAAhB,CAA5B;;AAEA,MAAI,CAACjB,OAAO,CAACqB,MAAD,CAAZ,EAAsB;AACpBA,IAAAA,MAAM,GAAG,IAAIlB,OAAJ,EAAT;AACD;;AAEDkB,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYL,KAAK,CAACC,aAAD,CAAjB;AACAI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYL,KAAK,CAACC,aAAa,GAAG,CAAjB,CAAjB;AACAI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYL,KAAK,CAACC,aAAa,GAAG,CAAjB,CAAjB;AACAI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYL,KAAK,CAACC,aAAa,GAAG,CAAjB,CAAjB;AACAI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYL,KAAK,CAACC,aAAa,GAAG,CAAjB,CAAjB;AACAI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYL,KAAK,CAACC,aAAa,GAAG,CAAjB,CAAjB;AACAI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYL,KAAK,CAACC,aAAa,GAAG,CAAjB,CAAjB;AACAI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYL,KAAK,CAACC,aAAa,GAAG,CAAjB,CAAjB;AACAI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYL,KAAK,CAACC,aAAa,GAAG,CAAjB,CAAjB;AACA,SAAOI,MAAP;AACD,CArBD;AAuBA;;;;;;;;;AAOAlB,OAAO,CAACuB,oBAAR,GAA+B,UAAUC,MAAV,EAAkBN,MAAlB,EAA0B;AACvD;AACAvB,EAAAA,KAAK,CAACE,OAAN,CAAc,QAAd,EAAwB2B,MAAxB,EAFuD,CAGvD;;AAEA,SAAOxB,OAAO,CAACmB,KAAR,CAAcK,MAAd,EAAsBN,MAAtB,CAAP;AACD,CAND;AAQA;;;;;;;;;;AAQAlB,OAAO,CAACyB,iBAAR,GAA4B,UAAUD,MAAV,EAAkBN,MAAlB,EAA0B;AACpD;AACAvB,EAAAA,KAAK,CAACE,OAAN,CAAc,QAAd,EAAwB2B,MAAxB,EAFoD,CAGpD;;AAEA,MAAI,CAAC3B,OAAO,CAACqB,MAAD,CAAZ,EAAsB;AACpB,WAAO,IAAIlB,OAAJ,CACLwB,MAAM,CAAC,CAAD,CADD,EAELA,MAAM,CAAC,CAAD,CAFD,EAGLA,MAAM,CAAC,CAAD,CAHD,EAILA,MAAM,CAAC,CAAD,CAJD,EAKLA,MAAM,CAAC,CAAD,CALD,EAMLA,MAAM,CAAC,CAAD,CAND,EAOLA,MAAM,CAAC,CAAD,CAPD,EAQLA,MAAM,CAAC,CAAD,CARD,EASLA,MAAM,CAAC,CAAD,CATD,CAAP;AAWD;;AACDN,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYM,MAAM,CAAC,CAAD,CAAlB;AACAN,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYM,MAAM,CAAC,CAAD,CAAlB;AACAN,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYM,MAAM,CAAC,CAAD,CAAlB;AACAN,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYM,MAAM,CAAC,CAAD,CAAlB;AACAN,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYM,MAAM,CAAC,CAAD,CAAlB;AACAN,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYM,MAAM,CAAC,CAAD,CAAlB;AACAN,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYM,MAAM,CAAC,CAAD,CAAlB;AACAN,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYM,MAAM,CAAC,CAAD,CAAlB;AACAN,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYM,MAAM,CAAC,CAAD,CAAlB;AACA,SAAON,MAAP;AACD,CA5BD;AA8BA;;;;;;;;;AAOAlB,OAAO,CAAC0B,cAAR,GAAyB,UAAUC,UAAV,EAAsBT,MAAtB,EAA8B;AACrD;AACAvB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,YAApB,EAAkCW,UAAlC,EAFqD,CAGrD;;AAEA,MAAIC,EAAE,GAAGD,UAAU,CAACE,CAAX,GAAeF,UAAU,CAACE,CAAnC;AACA,MAAIC,EAAE,GAAGH,UAAU,CAACE,CAAX,GAAeF,UAAU,CAACI,CAAnC;AACA,MAAIC,EAAE,GAAGL,UAAU,CAACE,CAAX,GAAeF,UAAU,CAACM,CAAnC;AACA,MAAIC,EAAE,GAAGP,UAAU,CAACE,CAAX,GAAeF,UAAU,CAACQ,CAAnC;AACA,MAAIC,EAAE,GAAGT,UAAU,CAACI,CAAX,GAAeJ,UAAU,CAACI,CAAnC;AACA,MAAIM,EAAE,GAAGV,UAAU,CAACI,CAAX,GAAeJ,UAAU,CAACM,CAAnC;AACA,MAAIK,EAAE,GAAGX,UAAU,CAACI,CAAX,GAAeJ,UAAU,CAACQ,CAAnC;AACA,MAAII,EAAE,GAAGZ,UAAU,CAACM,CAAX,GAAeN,UAAU,CAACM,CAAnC;AACA,MAAIO,EAAE,GAAGb,UAAU,CAACM,CAAX,GAAeN,UAAU,CAACQ,CAAnC;AACA,MAAIM,EAAE,GAAGd,UAAU,CAACQ,CAAX,GAAeR,UAAU,CAACQ,CAAnC;AAEA,MAAIO,GAAG,GAAGd,EAAE,GAAGQ,EAAL,GAAUG,EAAV,GAAeE,EAAzB;AACA,MAAIE,GAAG,GAAG,OAAOb,EAAE,GAAGU,EAAZ,CAAV;AACA,MAAII,GAAG,GAAG,OAAOZ,EAAE,GAAGM,EAAZ,CAAV;AAEA,MAAIO,GAAG,GAAG,OAAOf,EAAE,GAAGU,EAAZ,CAAV;AACA,MAAIM,GAAG,GAAG,CAAClB,EAAD,GAAMQ,EAAN,GAAWG,EAAX,GAAgBE,EAA1B;AACA,MAAIM,GAAG,GAAG,OAAOV,EAAE,GAAGH,EAAZ,CAAV;AAEA,MAAIc,GAAG,GAAG,OAAOhB,EAAE,GAAGM,EAAZ,CAAV;AACA,MAAIW,GAAG,GAAG,OAAOZ,EAAE,GAAGH,EAAZ,CAAV;AACA,MAAIgB,GAAG,GAAG,CAACtB,EAAD,GAAMQ,EAAN,GAAWG,EAAX,GAAgBE,EAA1B;;AAEA,MAAI,CAAC5C,OAAO,CAACqB,MAAD,CAAZ,EAAsB;AACpB,WAAO,IAAIlB,OAAJ,CAAY0C,GAAZ,EAAiBC,GAAjB,EAAsBC,GAAtB,EAA2BC,GAA3B,EAAgCC,GAAhC,EAAqCC,GAArC,EAA0CC,GAA1C,EAA+CC,GAA/C,EAAoDC,GAApD,CAAP;AACD;;AACDhC,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYwB,GAAZ;AACAxB,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY2B,GAAZ;AACA3B,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY8B,GAAZ;AACA9B,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYyB,GAAZ;AACAzB,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY4B,GAAZ;AACA5B,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY+B,GAAZ;AACA/B,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY0B,GAAZ;AACA1B,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY6B,GAAZ;AACA7B,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgC,GAAZ;AACA,SAAOhC,MAAP;AACD,CAzCD;AA2CA;;;;;;;;;AAOAlB,OAAO,CAACmD,oBAAR,GAA+B,UAAUC,gBAAV,EAA4BlC,MAA5B,EAAoC;AACjE;AACAvB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,kBAApB,EAAwCoC,gBAAxC,EAFiE,CAGjE;;AAEA,MAAIC,QAAQ,GAAGC,IAAI,CAACC,GAAL,CAAS,CAACH,gBAAgB,CAACI,KAA3B,CAAf;AACA,MAAIC,MAAM,GAAGH,IAAI,CAACC,GAAL,CAAS,CAACH,gBAAgB,CAACM,OAA3B,CAAb;AACA,MAAIC,MAAM,GAAGL,IAAI,CAACC,GAAL,CAASH,gBAAgB,CAACQ,IAA1B,CAAb;AACA,MAAIC,QAAQ,GAAGP,IAAI,CAACQ,GAAL,CAAS,CAACV,gBAAgB,CAACI,KAA3B,CAAf;AACA,MAAIO,MAAM,GAAGT,IAAI,CAACQ,GAAL,CAAS,CAACV,gBAAgB,CAACM,OAA3B,CAAb;AACA,MAAIM,MAAM,GAAGV,IAAI,CAACQ,GAAL,CAASV,gBAAgB,CAACQ,IAA1B,CAAb;AAEA,MAAIlB,GAAG,GAAGW,QAAQ,GAAGI,MAArB;AACA,MAAId,GAAG,GAAG,CAACgB,MAAD,GAAUI,MAAV,GAAmBC,MAAM,GAAGH,QAAT,GAAoBJ,MAAjD;AACA,MAAIb,GAAG,GAAGoB,MAAM,GAAGD,MAAT,GAAkBJ,MAAM,GAAGE,QAAT,GAAoBJ,MAAhD;AAEA,MAAIZ,GAAG,GAAGQ,QAAQ,GAAGU,MAArB;AACA,MAAIjB,GAAG,GAAGa,MAAM,GAAGF,MAAT,GAAkBO,MAAM,GAAGH,QAAT,GAAoBE,MAAhD;AACA,MAAIhB,GAAG,GAAG,CAACiB,MAAD,GAAUP,MAAV,GAAmBE,MAAM,GAAGE,QAAT,GAAoBE,MAAjD;AAEA,MAAIf,GAAG,GAAG,CAACa,QAAX;AACA,MAAIZ,GAAG,GAAGe,MAAM,GAAGX,QAAnB;AACA,MAAIH,GAAG,GAAGS,MAAM,GAAGN,QAAnB;;AAEA,MAAI,CAACxD,OAAO,CAACqB,MAAD,CAAZ,EAAsB;AACpB,WAAO,IAAIlB,OAAJ,CAAY0C,GAAZ,EAAiBC,GAAjB,EAAsBC,GAAtB,EAA2BC,GAA3B,EAAgCC,GAAhC,EAAqCC,GAArC,EAA0CC,GAA1C,EAA+CC,GAA/C,EAAoDC,GAApD,CAAP;AACD;;AACDhC,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYwB,GAAZ;AACAxB,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY2B,GAAZ;AACA3B,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY8B,GAAZ;AACA9B,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYyB,GAAZ;AACAzB,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY4B,GAAZ;AACA5B,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY+B,GAAZ;AACA/B,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY0B,GAAZ;AACA1B,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY6B,GAAZ;AACA7B,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgC,GAAZ;AACA,SAAOhC,MAAP;AACD,CArCD;AAuCA;;;;;;;;;;;;;;;;AAcAlB,OAAO,CAACiE,SAAR,GAAoB,UAAUC,KAAV,EAAiBhD,MAAjB,EAAyB;AAC3C;AACAvB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,OAApB,EAA6BkD,KAA7B,EAF2C,CAG3C;;AAEA,MAAI,CAACrE,OAAO,CAACqB,MAAD,CAAZ,EAAsB;AACpB,WAAO,IAAIlB,OAAJ,CAAYkE,KAAK,CAACrC,CAAlB,EAAqB,GAArB,EAA0B,GAA1B,EAA+B,GAA/B,EAAoCqC,KAAK,CAACnC,CAA1C,EAA6C,GAA7C,EAAkD,GAAlD,EAAuD,GAAvD,EAA4DmC,KAAK,CAACjC,CAAlE,CAAP;AACD;;AAEDf,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgD,KAAK,CAACrC,CAAlB;AACAX,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgD,KAAK,CAACnC,CAAlB;AACAb,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgD,KAAK,CAACjC,CAAlB;AACA,SAAOf,MAAP;AACD,CAnBD;AAqBA;;;;;;;;;;;;;;;;AAcAlB,OAAO,CAACmE,gBAAR,GAA2B,UAAUD,KAAV,EAAiBhD,MAAjB,EAAyB;AAClD;AACAvB,EAAAA,KAAK,CAACoB,MAAN,CAAaqD,MAAb,CAAoB,OAApB,EAA6BF,KAA7B,EAFkD,CAGlD;;AAEA,MAAI,CAACrE,OAAO,CAACqB,MAAD,CAAZ,EAAsB;AACpB,WAAO,IAAIlB,OAAJ,CAAYkE,KAAZ,EAAmB,GAAnB,EAAwB,GAAxB,EAA6B,GAA7B,EAAkCA,KAAlC,EAAyC,GAAzC,EAA8C,GAA9C,EAAmD,GAAnD,EAAwDA,KAAxD,CAAP;AACD;;AAEDhD,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgD,KAAZ;AACAhD,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgD,KAAZ;AACAhD,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgD,KAAZ;AACA,SAAOhD,MAAP;AACD,CAnBD;AAqBA;;;;;;;;;;;;;;;;AAcAlB,OAAO,CAACqE,gBAAR,GAA2B,UAAUC,MAAV,EAAkBpD,MAAlB,EAA0B;AACnD;AACAvB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BsD,MAA9B,EAFmD,CAGnD;;AAEA,MAAI,CAACzE,OAAO,CAACqB,MAAD,CAAZ,EAAsB;AACpB,WAAO,IAAIlB,OAAJ,CACL,GADK,EAEL,CAACsE,MAAM,CAACrC,CAFH,EAGLqC,MAAM,CAACvC,CAHF,EAILuC,MAAM,CAACrC,CAJF,EAKL,GALK,EAML,CAACqC,MAAM,CAACzC,CANH,EAOL,CAACyC,MAAM,CAACvC,CAPH,EAQLuC,MAAM,CAACzC,CARF,EASL,GATK,CAAP;AAWD;;AAEDX,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYoD,MAAM,CAACrC,CAAnB;AACAf,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAACoD,MAAM,CAACvC,CAApB;AACAb,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAACoD,MAAM,CAACrC,CAApB;AACAf,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYoD,MAAM,CAACzC,CAAnB;AACAX,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYoD,MAAM,CAACvC,CAAnB;AACAb,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAACoD,MAAM,CAACzC,CAApB;AACAX,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACA,SAAOA,MAAP;AACD,CA7BD;AA+BA;;;;;;;;;;;;;;;AAaAlB,OAAO,CAACuE,aAAR,GAAwB,UAAUC,KAAV,EAAiBtD,MAAjB,EAAyB;AAC/C;AACAvB,EAAAA,KAAK,CAACoB,MAAN,CAAaqD,MAAb,CAAoB,OAApB,EAA6BI,KAA7B,EAF+C,CAG/C;;AAEA,MAAIC,QAAQ,GAAGnB,IAAI,CAACC,GAAL,CAASiB,KAAT,CAAf;AACA,MAAIE,QAAQ,GAAGpB,IAAI,CAACQ,GAAL,CAASU,KAAT,CAAf;;AAEA,MAAI,CAAC3E,OAAO,CAACqB,MAAD,CAAZ,EAAsB;AACpB,WAAO,IAAIlB,OAAJ,CACL,GADK,EAEL,GAFK,EAGL,GAHK,EAIL,GAJK,EAKLyE,QALK,EAML,CAACC,QANI,EAOL,GAPK,EAQLA,QARK,EASLD,QATK,CAAP;AAWD;;AAEDvD,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYuD,QAAZ;AACAvD,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYwD,QAAZ;AACAxD,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAACwD,QAAb;AACAxD,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYuD,QAAZ;AAEA,SAAOvD,MAAP;AACD,CAjCD;AAmCA;;;;;;;;;;;;;;;AAaAlB,OAAO,CAAC2E,aAAR,GAAwB,UAAUH,KAAV,EAAiBtD,MAAjB,EAAyB;AAC/C;AACAvB,EAAAA,KAAK,CAACoB,MAAN,CAAaqD,MAAb,CAAoB,OAApB,EAA6BI,KAA7B,EAF+C,CAG/C;;AAEA,MAAIC,QAAQ,GAAGnB,IAAI,CAACC,GAAL,CAASiB,KAAT,CAAf;AACA,MAAIE,QAAQ,GAAGpB,IAAI,CAACQ,GAAL,CAASU,KAAT,CAAf;;AAEA,MAAI,CAAC3E,OAAO,CAACqB,MAAD,CAAZ,EAAsB;AACpB,WAAO,IAAIlB,OAAJ,CACLyE,QADK,EAEL,GAFK,EAGLC,QAHK,EAIL,GAJK,EAKL,GALK,EAML,GANK,EAOL,CAACA,QAPI,EAQL,GARK,EASLD,QATK,CAAP;AAWD;;AAEDvD,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYuD,QAAZ;AACAvD,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAACwD,QAAb;AACAxD,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYwD,QAAZ;AACAxD,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYuD,QAAZ;AAEA,SAAOvD,MAAP;AACD,CAjCD;AAmCA;;;;;;;;;;;;;;;AAaAlB,OAAO,CAAC4E,aAAR,GAAwB,UAAUJ,KAAV,EAAiBtD,MAAjB,EAAyB;AAC/C;AACAvB,EAAAA,KAAK,CAACoB,MAAN,CAAaqD,MAAb,CAAoB,OAApB,EAA6BI,KAA7B,EAF+C,CAG/C;;AAEA,MAAIC,QAAQ,GAAGnB,IAAI,CAACC,GAAL,CAASiB,KAAT,CAAf;AACA,MAAIE,QAAQ,GAAGpB,IAAI,CAACQ,GAAL,CAASU,KAAT,CAAf;;AAEA,MAAI,CAAC3E,OAAO,CAACqB,MAAD,CAAZ,EAAsB;AACpB,WAAO,IAAIlB,OAAJ,CACLyE,QADK,EAEL,CAACC,QAFI,EAGL,GAHK,EAILA,QAJK,EAKLD,QALK,EAML,GANK,EAOL,GAPK,EAQL,GARK,EASL,GATK,CAAP;AAWD;;AAEDvD,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYuD,QAAZ;AACAvD,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYwD,QAAZ;AACAxD,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAACwD,QAAb;AACAxD,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYuD,QAAZ;AACAvD,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AAEA,SAAOA,MAAP;AACD,CAjCD;AAmCA;;;;;;;;;;AAQAlB,OAAO,CAAC6E,OAAR,GAAkB,UAAUzD,MAAV,EAAkBF,MAAlB,EAA0B;AAC1C;AACAvB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B,EAF0C,CAG1C;;AAEA,MAAI,CAACvB,OAAO,CAACqB,MAAD,CAAZ,EAAsB;AACpB,WAAO,CACLE,MAAM,CAAC,CAAD,CADD,EAELA,MAAM,CAAC,CAAD,CAFD,EAGLA,MAAM,CAAC,CAAD,CAHD,EAILA,MAAM,CAAC,CAAD,CAJD,EAKLA,MAAM,CAAC,CAAD,CALD,EAMLA,MAAM,CAAC,CAAD,CAND,EAOLA,MAAM,CAAC,CAAD,CAPD,EAQLA,MAAM,CAAC,CAAD,CARD,EASLA,MAAM,CAAC,CAAD,CATD,CAAP;AAWD;;AACDF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAlB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAlB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAlB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAlB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAlB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAlB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAlB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAlB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAlB;AACA,SAAOF,MAAP;AACD,CA5BD;AA8BA;;;;;;;;;;;;;;;;;;AAgBAlB,OAAO,CAAC8E,eAAR,GAA0B,UAAUC,MAAV,EAAkBC,GAAlB,EAAuB;AAC/C;AACArF,EAAAA,KAAK,CAACoB,MAAN,CAAaqD,MAAb,CAAoBa,mBAApB,CAAwC,KAAxC,EAA+CD,GAA/C,EAAoD,CAApD;AACArF,EAAAA,KAAK,CAACoB,MAAN,CAAaqD,MAAb,CAAoBc,gBAApB,CAAqC,KAArC,EAA4CF,GAA5C,EAAiD,CAAjD;AACArF,EAAAA,KAAK,CAACoB,MAAN,CAAaqD,MAAb,CAAoBa,mBAApB,CAAwC,QAAxC,EAAkDF,MAAlD,EAA0D,CAA1D;AACApF,EAAAA,KAAK,CAACoB,MAAN,CAAaqD,MAAb,CAAoBc,gBAApB,CAAqC,QAArC,EAA+CH,MAA/C,EAAuD,CAAvD,EAL+C,CAM/C;;AAEA,SAAOA,MAAM,GAAG,CAAT,GAAaC,GAApB;AACD,CATD;AAWA;;;;;;;;;;;;AAUAhF,OAAO,CAACmF,SAAR,GAAoB,UAAU/D,MAAV,EAAkBgE,KAAlB,EAAyBlE,MAAzB,EAAiC;AACnD;AACAvB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B;AACAzB,EAAAA,KAAK,CAACoB,MAAN,CAAaqD,MAAb,CAAoBa,mBAApB,CAAwC,OAAxC,EAAiDG,KAAjD,EAAwD,CAAxD;AACAzF,EAAAA,KAAK,CAACoB,MAAN,CAAaqD,MAAb,CAAoBc,gBAApB,CAAqC,OAArC,EAA8CE,KAA9C,EAAqD,CAArD;AACAzF,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EALmD,CAMnD;;AAEA,MAAImE,UAAU,GAAGD,KAAK,GAAG,CAAzB;AACA,MAAIvD,CAAC,GAAGT,MAAM,CAACiE,UAAD,CAAd;AACA,MAAItD,CAAC,GAAGX,MAAM,CAACiE,UAAU,GAAG,CAAd,CAAd;AACA,MAAIpD,CAAC,GAAGb,MAAM,CAACiE,UAAU,GAAG,CAAd,CAAd;AAEAnE,EAAAA,MAAM,CAACW,CAAP,GAAWA,CAAX;AACAX,EAAAA,MAAM,CAACa,CAAP,GAAWA,CAAX;AACAb,EAAAA,MAAM,CAACe,CAAP,GAAWA,CAAX;AACA,SAAOf,MAAP;AACD,CAjBD;AAmBA;;;;;;;;;;;;;AAWAlB,OAAO,CAACsF,SAAR,GAAoB,UAAUlE,MAAV,EAAkBgE,KAAlB,EAAyBG,SAAzB,EAAoCrE,MAApC,EAA4C;AAC9D;AACAvB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B;AACAzB,EAAAA,KAAK,CAACoB,MAAN,CAAaqD,MAAb,CAAoBa,mBAApB,CAAwC,OAAxC,EAAiDG,KAAjD,EAAwD,CAAxD;AACAzF,EAAAA,KAAK,CAACoB,MAAN,CAAaqD,MAAb,CAAoBc,gBAApB,CAAqC,OAArC,EAA8CE,KAA9C,EAAqD,CAArD;AACAzF,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,WAApB,EAAiCuE,SAAjC;AACA5F,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAN8D,CAO9D;;AAEAA,EAAAA,MAAM,GAAGlB,OAAO,CAACmB,KAAR,CAAcC,MAAd,EAAsBF,MAAtB,CAAT;AACA,MAAImE,UAAU,GAAGD,KAAK,GAAG,CAAzB;AACAlE,EAAAA,MAAM,CAACmE,UAAD,CAAN,GAAqBE,SAAS,CAAC1D,CAA/B;AACAX,EAAAA,MAAM,CAACmE,UAAU,GAAG,CAAd,CAAN,GAAyBE,SAAS,CAACxD,CAAnC;AACAb,EAAAA,MAAM,CAACmE,UAAU,GAAG,CAAd,CAAN,GAAyBE,SAAS,CAACtD,CAAnC;AACA,SAAOf,MAAP;AACD,CAfD;AAiBA;;;;;;;;;;;;AAUAlB,OAAO,CAACwF,MAAR,GAAiB,UAAUpE,MAAV,EAAkBgE,KAAlB,EAAyBlE,MAAzB,EAAiC;AAChD;AACAvB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B;AACAzB,EAAAA,KAAK,CAACoB,MAAN,CAAaqD,MAAb,CAAoBa,mBAApB,CAAwC,OAAxC,EAAiDG,KAAjD,EAAwD,CAAxD;AACAzF,EAAAA,KAAK,CAACoB,MAAN,CAAaqD,MAAb,CAAoBc,gBAApB,CAAqC,OAArC,EAA8CE,KAA9C,EAAqD,CAArD;AACAzF,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EALgD,CAMhD;;AAEA,MAAIW,CAAC,GAAGT,MAAM,CAACgE,KAAD,CAAd;AACA,MAAIrD,CAAC,GAAGX,MAAM,CAACgE,KAAK,GAAG,CAAT,CAAd;AACA,MAAInD,CAAC,GAAGb,MAAM,CAACgE,KAAK,GAAG,CAAT,CAAd;AAEAlE,EAAAA,MAAM,CAACW,CAAP,GAAWA,CAAX;AACAX,EAAAA,MAAM,CAACa,CAAP,GAAWA,CAAX;AACAb,EAAAA,MAAM,CAACe,CAAP,GAAWA,CAAX;AACA,SAAOf,MAAP;AACD,CAhBD;AAkBA;;;;;;;;;;;;;AAWAlB,OAAO,CAACyF,MAAR,GAAiB,UAAUrE,MAAV,EAAkBgE,KAAlB,EAAyBG,SAAzB,EAAoCrE,MAApC,EAA4C;AAC3D;AACAvB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B;AACAzB,EAAAA,KAAK,CAACoB,MAAN,CAAaqD,MAAb,CAAoBa,mBAApB,CAAwC,OAAxC,EAAiDG,KAAjD,EAAwD,CAAxD;AACAzF,EAAAA,KAAK,CAACoB,MAAN,CAAaqD,MAAb,CAAoBc,gBAApB,CAAqC,OAArC,EAA8CE,KAA9C,EAAqD,CAArD;AACAzF,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,WAApB,EAAiCuE,SAAjC;AACA5F,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAN2D,CAO3D;;AAEAA,EAAAA,MAAM,GAAGlB,OAAO,CAACmB,KAAR,CAAcC,MAAd,EAAsBF,MAAtB,CAAT;AACAA,EAAAA,MAAM,CAACkE,KAAD,CAAN,GAAgBG,SAAS,CAAC1D,CAA1B;AACAX,EAAAA,MAAM,CAACkE,KAAK,GAAG,CAAT,CAAN,GAAoBG,SAAS,CAACxD,CAA9B;AACAb,EAAAA,MAAM,CAACkE,KAAK,GAAG,CAAT,CAAN,GAAoBG,SAAS,CAACtD,CAA9B;AACA,SAAOf,MAAP;AACD,CAdD;;AAgBA,IAAIwE,aAAa,GAAG,IAAIhG,UAAJ,EAApB;AAEA;;;;;;;;AAOAM,OAAO,CAAC2F,QAAR,GAAmB,UAAUvE,MAAV,EAAkBF,MAAlB,EAA0B;AAC3C;AACAvB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B;AACAzB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAH2C,CAI3C;;AAEAA,EAAAA,MAAM,CAACW,CAAP,GAAWnC,UAAU,CAACkG,SAAX,CACTlG,UAAU,CAACmG,YAAX,CAAwBzE,MAAM,CAAC,CAAD,CAA9B,EAAmCA,MAAM,CAAC,CAAD,CAAzC,EAA8CA,MAAM,CAAC,CAAD,CAApD,EAAyDsE,aAAzD,CADS,CAAX;AAGAxE,EAAAA,MAAM,CAACa,CAAP,GAAWrC,UAAU,CAACkG,SAAX,CACTlG,UAAU,CAACmG,YAAX,CAAwBzE,MAAM,CAAC,CAAD,CAA9B,EAAmCA,MAAM,CAAC,CAAD,CAAzC,EAA8CA,MAAM,CAAC,CAAD,CAApD,EAAyDsE,aAAzD,CADS,CAAX;AAGAxE,EAAAA,MAAM,CAACe,CAAP,GAAWvC,UAAU,CAACkG,SAAX,CACTlG,UAAU,CAACmG,YAAX,CAAwBzE,MAAM,CAAC,CAAD,CAA9B,EAAmCA,MAAM,CAAC,CAAD,CAAzC,EAA8CA,MAAM,CAAC,CAAD,CAApD,EAAyDsE,aAAzD,CADS,CAAX;AAGA,SAAOxE,MAAP;AACD,CAhBD;;AAkBA,IAAI4E,YAAY,GAAG,IAAIpG,UAAJ,EAAnB;AAEA;;;;;;;;AAOAM,OAAO,CAAC+F,eAAR,GAA0B,UAAU3E,MAAV,EAAkB;AAC1CpB,EAAAA,OAAO,CAAC2F,QAAR,CAAiBvE,MAAjB,EAAyB0E,YAAzB;AACA,SAAOpG,UAAU,CAACsG,gBAAX,CAA4BF,YAA5B,CAAP;AACD,CAHD;AAKA;;;;;;;;;;AAQA9F,OAAO,CAACiG,QAAR,GAAmB,UAAUC,IAAV,EAAgBC,KAAhB,EAAuBjF,MAAvB,EAA+B;AAChD;AACAvB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,MAApB,EAA4BkF,IAA5B;AACAvG,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,OAApB,EAA6BmF,KAA7B;AACAxG,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAJgD,CAKhD;;AAEA,MAAIjB,WAAW,GACbiG,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAf,GAAqBD,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAApC,GAA0CD,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAD3D;AAEA,MAAI/F,WAAW,GACb8F,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAf,GAAqBD,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAApC,GAA0CD,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAD3D;AAEA,MAAI5F,WAAW,GACb2F,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAf,GAAqBD,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAApC,GAA0CD,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAD3D;AAGA,MAAIjG,WAAW,GACbgG,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAf,GAAqBD,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAApC,GAA0CD,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAD3D;AAEA,MAAI9F,WAAW,GACb6F,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAf,GAAqBD,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAApC,GAA0CD,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAD3D;AAEA,MAAI3F,WAAW,GACb0F,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAf,GAAqBD,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAApC,GAA0CD,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAD3D;AAGA,MAAIhG,WAAW,GACb+F,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAf,GAAqBD,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAApC,GAA0CD,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAD3D;AAEA,MAAI7F,WAAW,GACb4F,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAf,GAAqBD,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAApC,GAA0CD,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAD3D;AAEA,MAAI1F,WAAW,GACbyF,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAf,GAAqBD,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAApC,GAA0CD,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAD3D;AAGAjF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYjB,WAAZ;AACAiB,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYd,WAAZ;AACAc,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYX,WAAZ;AACAW,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYhB,WAAZ;AACAgB,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYb,WAAZ;AACAa,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYV,WAAZ;AACAU,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYf,WAAZ;AACAe,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYZ,WAAZ;AACAY,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYT,WAAZ;AACA,SAAOS,MAAP;AACD,CAtCD;AAwCA;;;;;;;;;;AAQAlB,OAAO,CAACoG,GAAR,GAAc,UAAUF,IAAV,EAAgBC,KAAhB,EAAuBjF,MAAvB,EAA+B;AAC3C;AACAvB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,MAApB,EAA4BkF,IAA5B;AACAvG,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,OAApB,EAA6BmF,KAA7B;AACAxG,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAJ2C,CAK3C;;AAEAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgF,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAA3B;AACAjF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgF,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAA3B;AACAjF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgF,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAA3B;AACAjF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgF,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAA3B;AACAjF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgF,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAA3B;AACAjF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgF,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAA3B;AACAjF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgF,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAA3B;AACAjF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgF,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAA3B;AACAjF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgF,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAA3B;AACA,SAAOjF,MAAP;AACD,CAjBD;AAmBA;;;;;;;;;;AAQAlB,OAAO,CAACqG,QAAR,GAAmB,UAAUH,IAAV,EAAgBC,KAAhB,EAAuBjF,MAAvB,EAA+B;AAChD;AACAvB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,MAApB,EAA4BkF,IAA5B;AACAvG,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,OAApB,EAA6BmF,KAA7B;AACAxG,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAJgD,CAKhD;;AAEAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgF,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAA3B;AACAjF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgF,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAA3B;AACAjF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgF,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAA3B;AACAjF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgF,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAA3B;AACAjF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgF,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAA3B;AACAjF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgF,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAA3B;AACAjF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgF,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAA3B;AACAjF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgF,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAA3B;AACAjF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgF,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAA3B;AACA,SAAOjF,MAAP;AACD,CAjBD;AAmBA;;;;;;;;;;AAQAlB,OAAO,CAACsG,gBAAR,GAA2B,UAAUlF,MAAV,EAAkBmE,SAAlB,EAA6BrE,MAA7B,EAAqC;AAC9D;AACAvB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B;AACAzB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,WAApB,EAAiCuE,SAAjC;AACA5F,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAJ8D,CAK9D;;AAEA,MAAIqF,EAAE,GAAGhB,SAAS,CAAC1D,CAAnB;AACA,MAAI2E,EAAE,GAAGjB,SAAS,CAACxD,CAAnB;AACA,MAAI0E,EAAE,GAAGlB,SAAS,CAACtD,CAAnB;AAEA,MAAIJ,CAAC,GAAGT,MAAM,CAAC,CAAD,CAAN,GAAYmF,EAAZ,GAAiBnF,MAAM,CAAC,CAAD,CAAN,GAAYoF,EAA7B,GAAkCpF,MAAM,CAAC,CAAD,CAAN,GAAYqF,EAAtD;AACA,MAAI1E,CAAC,GAAGX,MAAM,CAAC,CAAD,CAAN,GAAYmF,EAAZ,GAAiBnF,MAAM,CAAC,CAAD,CAAN,GAAYoF,EAA7B,GAAkCpF,MAAM,CAAC,CAAD,CAAN,GAAYqF,EAAtD;AACA,MAAIxE,CAAC,GAAGb,MAAM,CAAC,CAAD,CAAN,GAAYmF,EAAZ,GAAiBnF,MAAM,CAAC,CAAD,CAAN,GAAYoF,EAA7B,GAAkCpF,MAAM,CAAC,CAAD,CAAN,GAAYqF,EAAtD;AAEAvF,EAAAA,MAAM,CAACW,CAAP,GAAWA,CAAX;AACAX,EAAAA,MAAM,CAACa,CAAP,GAAWA,CAAX;AACAb,EAAAA,MAAM,CAACe,CAAP,GAAWA,CAAX;AACA,SAAOf,MAAP;AACD,CAnBD;AAqBA;;;;;;;;;;AAQAlB,OAAO,CAAC0G,gBAAR,GAA2B,UAAUtF,MAAV,EAAkBuF,MAAlB,EAA0BzF,MAA1B,EAAkC;AAC3D;AACAvB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B;AACAzB,EAAAA,KAAK,CAACoB,MAAN,CAAaqD,MAAb,CAAoB,QAApB,EAA8BuC,MAA9B;AACAhH,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAJ2D,CAK3D;;AAEAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAN,GAAYuF,MAAxB;AACAzF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAN,GAAYuF,MAAxB;AACAzF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAN,GAAYuF,MAAxB;AACAzF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAN,GAAYuF,MAAxB;AACAzF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAN,GAAYuF,MAAxB;AACAzF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAN,GAAYuF,MAAxB;AACAzF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAN,GAAYuF,MAAxB;AACAzF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAN,GAAYuF,MAAxB;AACAzF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAN,GAAYuF,MAAxB;AACA,SAAOzF,MAAP;AACD,CAjBD;AAmBA;;;;;;;;;;;;;;;;;;AAgBAlB,OAAO,CAAC4G,eAAR,GAA0B,UAAUxF,MAAV,EAAkB8C,KAAlB,EAAyBhD,MAAzB,EAAiC;AACzD;AACAvB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B;AACAzB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,OAApB,EAA6BkD,KAA7B;AACAvE,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAJyD,CAKzD;;AAEAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAN,GAAY8C,KAAK,CAACrC,CAA9B;AACAX,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAN,GAAY8C,KAAK,CAACrC,CAA9B;AACAX,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAN,GAAY8C,KAAK,CAACrC,CAA9B;AACAX,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAN,GAAY8C,KAAK,CAACnC,CAA9B;AACAb,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAN,GAAY8C,KAAK,CAACnC,CAA9B;AACAb,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAN,GAAY8C,KAAK,CAACnC,CAA9B;AACAb,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAN,GAAY8C,KAAK,CAACjC,CAA9B;AACAf,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAN,GAAY8C,KAAK,CAACjC,CAA9B;AACAf,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAN,GAAY8C,KAAK,CAACjC,CAA9B;AACA,SAAOf,MAAP;AACD,CAjBD;AAmBA;;;;;;;;;AAOAlB,OAAO,CAAC6G,MAAR,GAAiB,UAAUzF,MAAV,EAAkBF,MAAlB,EAA0B;AACzC;AACAvB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B;AACAzB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAHyC,CAIzC;;AAEAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAACE,MAAM,CAAC,CAAD,CAAnB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAACE,MAAM,CAAC,CAAD,CAAnB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAACE,MAAM,CAAC,CAAD,CAAnB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAACE,MAAM,CAAC,CAAD,CAAnB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAACE,MAAM,CAAC,CAAD,CAAnB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAACE,MAAM,CAAC,CAAD,CAAnB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAACE,MAAM,CAAC,CAAD,CAAnB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAACE,MAAM,CAAC,CAAD,CAAnB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAACE,MAAM,CAAC,CAAD,CAAnB;AACA,SAAOF,MAAP;AACD,CAhBD;AAkBA;;;;;;;;;AAOAlB,OAAO,CAAC8G,SAAR,GAAoB,UAAU1F,MAAV,EAAkBF,MAAlB,EAA0B;AAC5C;AACAvB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B;AACAzB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAH4C,CAI5C;;AAEA,MAAIjB,WAAW,GAAGmB,MAAM,CAAC,CAAD,CAAxB;AACA,MAAIhB,WAAW,GAAGgB,MAAM,CAAC,CAAD,CAAxB;AACA,MAAIb,WAAW,GAAGa,MAAM,CAAC,CAAD,CAAxB;AACA,MAAIlB,WAAW,GAAGkB,MAAM,CAAC,CAAD,CAAxB;AACA,MAAIf,WAAW,GAAGe,MAAM,CAAC,CAAD,CAAxB;AACA,MAAIZ,WAAW,GAAGY,MAAM,CAAC,CAAD,CAAxB;AACA,MAAIjB,WAAW,GAAGiB,MAAM,CAAC,CAAD,CAAxB;AACA,MAAId,WAAW,GAAGc,MAAM,CAAC,CAAD,CAAxB;AACA,MAAIX,WAAW,GAAGW,MAAM,CAAC,CAAD,CAAxB;AAEAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYjB,WAAZ;AACAiB,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYd,WAAZ;AACAc,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYX,WAAZ;AACAW,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYhB,WAAZ;AACAgB,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYb,WAAZ;AACAa,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYV,WAAZ;AACAU,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYf,WAAZ;AACAe,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYZ,WAAZ;AACAY,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYT,WAAZ;AACA,SAAOS,MAAP;AACD,CA1BD;;AA4BA,IAAI6F,IAAI,GAAG,IAAIrH,UAAJ,CAAe,CAAf,EAAkB,CAAlB,EAAqB,CAArB,CAAX;AAEA;;;;;;;;AAOAM,OAAO,CAACgH,WAAR,GAAsB,UAAU5F,MAAV,EAAkBF,MAAlB,EAA0B;AAC9C;AACAvB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B;AACAzB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAH8C,CAI9C;;AAEA,MAAI+F,YAAY,GAAGvH,UAAU,CAACwH,gBAAX,CACjBH,IADiB,EAEjB/G,OAAO,CAAC2F,QAAR,CAAiBvE,MAAjB,EAAyB0E,YAAzB,CAFiB,EAGjBA,YAHiB,CAAnB;AAKA5E,EAAAA,MAAM,GAAGlB,OAAO,CAAC4G,eAAR,CAAwBxF,MAAxB,EAAgC6F,YAAhC,EAA8C/F,MAA9C,CAAT;AAEA,SAAOA,MAAP;AACD,CAdD;;AAgBA,SAASiG,oBAAT,CAA8B/F,MAA9B,EAAsC;AACpC,MAAIgG,IAAI,GAAG,GAAX;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuB,EAAEA,CAAzB,EAA4B;AAC1B,QAAIC,IAAI,GAAGlG,MAAM,CAACiG,CAAD,CAAjB;AACAD,IAAAA,IAAI,IAAIE,IAAI,GAAGA,IAAf;AACD;;AAED,SAAOhE,IAAI,CAACiE,IAAL,CAAUH,IAAV,CAAP;AACD;;AAED,IAAII,MAAM,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAb;AACA,IAAIC,MAAM,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAb;;AAEA,SAASC,wBAAT,CAAkCtG,MAAlC,EAA0C;AACxC;AACA;AAEA,MAAIgG,IAAI,GAAG,GAAX;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuB,EAAEA,CAAzB,EAA4B;AAC1B,QAAIC,IAAI,GAAGlG,MAAM,CAACpB,OAAO,CAAC8E,eAAR,CAAwB2C,MAAM,CAACJ,CAAD,CAA9B,EAAmCG,MAAM,CAACH,CAAD,CAAzC,CAAD,CAAjB;AACAD,IAAAA,IAAI,IAAI,MAAME,IAAN,GAAaA,IAArB;AACD;;AAED,SAAOhE,IAAI,CAACiE,IAAL,CAAUH,IAAV,CAAP;AACD;;AAED,SAASO,iBAAT,CAA2BvG,MAA3B,EAAmCF,MAAnC,EAA2C;AACzC;AACA;AACA;AACA;AACA;AACA;AAEA,MAAI0G,SAAS,GAAG7H,UAAU,CAAC8H,SAA3B;AAEA,MAAIC,WAAW,GAAG,GAAlB;AACA,MAAIC,OAAO,GAAG,CAAd,CAXyC,CAazC;;AACA,OAAK,IAAIV,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuB,EAAEA,CAAzB,EAA4B;AAC1B,QAAIC,IAAI,GAAGhE,IAAI,CAAC0E,GAAL,CAAS5G,MAAM,CAACpB,OAAO,CAAC8E,eAAR,CAAwB2C,MAAM,CAACJ,CAAD,CAA9B,EAAmCG,MAAM,CAACH,CAAD,CAAzC,CAAD,CAAf,CAAX;;AACA,QAAIC,IAAI,GAAGQ,WAAX,EAAwB;AACtBC,MAAAA,OAAO,GAAGV,CAAV;AACAS,MAAAA,WAAW,GAAGR,IAAd;AACD;AACF;;AAED,MAAIW,CAAC,GAAG,GAAR;AACA,MAAIC,CAAC,GAAG,GAAR;AAEA,MAAIC,CAAC,GAAGX,MAAM,CAACO,OAAD,CAAd;AACA,MAAIK,CAAC,GAAGX,MAAM,CAACM,OAAD,CAAd;;AAEA,MAAIzE,IAAI,CAAC0E,GAAL,CAAS5G,MAAM,CAACpB,OAAO,CAAC8E,eAAR,CAAwBsD,CAAxB,EAA2BD,CAA3B,CAAD,CAAf,IAAkDP,SAAtD,EAAiE;AAC/D,QAAIS,EAAE,GAAGjH,MAAM,CAACpB,OAAO,CAAC8E,eAAR,CAAwBsD,CAAxB,EAA2BA,CAA3B,CAAD,CAAf;AACA,QAAIE,EAAE,GAAGlH,MAAM,CAACpB,OAAO,CAAC8E,eAAR,CAAwBqD,CAAxB,EAA2BA,CAA3B,CAAD,CAAf;AACA,QAAII,EAAE,GAAGnH,MAAM,CAACpB,OAAO,CAAC8E,eAAR,CAAwBsD,CAAxB,EAA2BD,CAA3B,CAAD,CAAf;AAEA,QAAIK,GAAG,GAAG,CAACH,EAAE,GAAGC,EAAN,IAAY,GAAZ,GAAkBC,EAA5B;AACA,QAAIE,CAAJ;;AAEA,QAAID,GAAG,GAAG,GAAV,EAAe;AACbC,MAAAA,CAAC,GAAG,CAAC,GAAD,IAAQ,CAACD,GAAD,GAAOlF,IAAI,CAACiE,IAAL,CAAU,MAAMiB,GAAG,GAAGA,GAAtB,CAAf,CAAJ;AACD,KAFD,MAEO;AACLC,MAAAA,CAAC,GAAG,OAAOD,GAAG,GAAGlF,IAAI,CAACiE,IAAL,CAAU,MAAMiB,GAAG,GAAGA,GAAtB,CAAb,CAAJ;AACD;;AAEDP,IAAAA,CAAC,GAAG,MAAM3E,IAAI,CAACiE,IAAL,CAAU,MAAMkB,CAAC,GAAGA,CAApB,CAAV;AACAP,IAAAA,CAAC,GAAGO,CAAC,GAAGR,CAAR;AACD;;AAED/G,EAAAA,MAAM,GAAGlB,OAAO,CAACmB,KAAR,CAAcnB,OAAO,CAAC0I,QAAtB,EAAgCxH,MAAhC,CAAT;AAEAA,EAAAA,MAAM,CAAClB,OAAO,CAAC8E,eAAR,CAAwBqD,CAAxB,EAA2BA,CAA3B,CAAD,CAAN,GAAwCjH,MAAM,CAC5ClB,OAAO,CAAC8E,eAAR,CAAwBsD,CAAxB,EAA2BA,CAA3B,CAD4C,CAAN,GAEpCH,CAFJ;AAGA/G,EAAAA,MAAM,CAAClB,OAAO,CAAC8E,eAAR,CAAwBsD,CAAxB,EAA2BD,CAA3B,CAAD,CAAN,GAAwCD,CAAxC;AACAhH,EAAAA,MAAM,CAAClB,OAAO,CAAC8E,eAAR,CAAwBqD,CAAxB,EAA2BC,CAA3B,CAAD,CAAN,GAAwC,CAACF,CAAzC;AAEA,SAAOhH,MAAP;AACD;;AAED,IAAIyH,OAAO,GAAG,IAAI3I,OAAJ,EAAd;AACA,IAAI4I,gBAAgB,GAAG,IAAI5I,OAAJ,EAAvB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BAA,OAAO,CAAC6I,yBAAR,GAAoC,UAAUzH,MAAV,EAAkBF,MAAlB,EAA0B;AAC5D;AACAvB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B,EAF4D,CAG5D;AAEA;AACA;;AAEA,MAAIwG,SAAS,GAAG7H,UAAU,CAAC+I,SAA3B;AACA,MAAIC,SAAS,GAAG,EAAhB;AAEA,MAAIC,KAAK,GAAG,CAAZ;AACA,MAAIC,KAAK,GAAG,CAAZ;;AAEA,MAAI,CAACpJ,OAAO,CAACqB,MAAD,CAAZ,EAAsB;AACpBA,IAAAA,MAAM,GAAG,EAAT;AACD;;AAED,MAAIgI,aAAa,GAAIhI,MAAM,CAACiI,OAAP,GAAiBnJ,OAAO,CAACmB,KAAR,CACpCnB,OAAO,CAAC0I,QAD4B,EAEpCxH,MAAM,CAACiI,OAF6B,CAAtC;AAIA,MAAIC,UAAU,GAAIlI,MAAM,CAACmI,QAAP,GAAkBrJ,OAAO,CAACmB,KAAR,CAAcC,MAAd,EAAsBF,MAAM,CAACmI,QAA7B,CAApC;AAEA,MAAIC,OAAO,GAAG1B,SAAS,GAAGT,oBAAoB,CAACiC,UAAD,CAA9C;;AAEA,SAAOH,KAAK,GAAGF,SAAR,IAAqBrB,wBAAwB,CAAC0B,UAAD,CAAxB,GAAuCE,OAAnE,EAA4E;AAC1E3B,IAAAA,iBAAiB,CAACyB,UAAD,EAAaT,OAAb,CAAjB;AACA3I,IAAAA,OAAO,CAAC8G,SAAR,CAAkB6B,OAAlB,EAA2BC,gBAA3B;AACA5I,IAAAA,OAAO,CAACiG,QAAR,CAAiBmD,UAAjB,EAA6BT,OAA7B,EAAsCS,UAAtC;AACApJ,IAAAA,OAAO,CAACiG,QAAR,CAAiB2C,gBAAjB,EAAmCQ,UAAnC,EAA+CA,UAA/C;AACApJ,IAAAA,OAAO,CAACiG,QAAR,CAAiBiD,aAAjB,EAAgCP,OAAhC,EAAyCO,aAAzC;;AAEA,QAAI,EAAEF,KAAF,GAAU,CAAd,EAAiB;AACf,QAAEC,KAAF;AACAD,MAAAA,KAAK,GAAG,CAAR;AACD;AACF;;AAED,SAAO9H,MAAP;AACD,CAxCD;AA0CA;;;;;;;;;AAOAlB,OAAO,CAACgI,GAAR,GAAc,UAAU5G,MAAV,EAAkBF,MAAlB,EAA0B;AACtC;AACAvB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B;AACAzB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAHsC,CAItC;;AAEAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYoC,IAAI,CAAC0E,GAAL,CAAS5G,MAAM,CAAC,CAAD,CAAf,CAAZ;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYoC,IAAI,CAAC0E,GAAL,CAAS5G,MAAM,CAAC,CAAD,CAAf,CAAZ;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYoC,IAAI,CAAC0E,GAAL,CAAS5G,MAAM,CAAC,CAAD,CAAf,CAAZ;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYoC,IAAI,CAAC0E,GAAL,CAAS5G,MAAM,CAAC,CAAD,CAAf,CAAZ;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYoC,IAAI,CAAC0E,GAAL,CAAS5G,MAAM,CAAC,CAAD,CAAf,CAAZ;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYoC,IAAI,CAAC0E,GAAL,CAAS5G,MAAM,CAAC,CAAD,CAAf,CAAZ;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYoC,IAAI,CAAC0E,GAAL,CAAS5G,MAAM,CAAC,CAAD,CAAf,CAAZ;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYoC,IAAI,CAAC0E,GAAL,CAAS5G,MAAM,CAAC,CAAD,CAAf,CAAZ;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYoC,IAAI,CAAC0E,GAAL,CAAS5G,MAAM,CAAC,CAAD,CAAf,CAAZ;AAEA,SAAOF,MAAP;AACD,CAjBD;AAmBA;;;;;;;;AAMAlB,OAAO,CAACuJ,WAAR,GAAsB,UAAUnI,MAAV,EAAkB;AACtC;AACAzB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B,EAFsC,CAGtC;;AAEA,MAAI0B,GAAG,GAAG1B,MAAM,CAAC,CAAD,CAAhB;AACA,MAAI6B,GAAG,GAAG7B,MAAM,CAAC,CAAD,CAAhB;AACA,MAAIoI,GAAG,GAAGpI,MAAM,CAAC,CAAD,CAAhB;AACA,MAAI2B,GAAG,GAAG3B,MAAM,CAAC,CAAD,CAAhB;AACA,MAAI8B,GAAG,GAAG9B,MAAM,CAAC,CAAD,CAAhB;AACA,MAAIqI,GAAG,GAAGrI,MAAM,CAAC,CAAD,CAAhB;AACA,MAAIsI,GAAG,GAAGtI,MAAM,CAAC,CAAD,CAAhB;AACA,MAAIuI,GAAG,GAAGvI,MAAM,CAAC,CAAD,CAAhB;AACA,MAAIwI,GAAG,GAAGxI,MAAM,CAAC,CAAD,CAAhB;AAEA,SACE0B,GAAG,IAAII,GAAG,GAAG0G,GAAN,GAAYD,GAAG,GAAGF,GAAtB,CAAH,GACA1G,GAAG,IAAI4G,GAAG,GAAGH,GAAN,GAAYvG,GAAG,GAAG2G,GAAtB,CADH,GAEAF,GAAG,IAAIzG,GAAG,GAAGwG,GAAN,GAAYvG,GAAG,GAAGsG,GAAtB,CAHL;AAKD,CApBD;AAsBA;;;;;;;;;;;AASAxJ,OAAO,CAAC6J,OAAR,GAAkB,UAAUzI,MAAV,EAAkBF,MAAlB,EAA0B;AAC1C;AACAvB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B;AACAzB,EAAAA,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAH0C,CAI1C;;AAEA,MAAI4B,GAAG,GAAG1B,MAAM,CAAC,CAAD,CAAhB;AACA,MAAI6B,GAAG,GAAG7B,MAAM,CAAC,CAAD,CAAhB;AACA,MAAIoI,GAAG,GAAGpI,MAAM,CAAC,CAAD,CAAhB;AACA,MAAI2B,GAAG,GAAG3B,MAAM,CAAC,CAAD,CAAhB;AACA,MAAI8B,GAAG,GAAG9B,MAAM,CAAC,CAAD,CAAhB;AACA,MAAIqI,GAAG,GAAGrI,MAAM,CAAC,CAAD,CAAhB;AACA,MAAIsI,GAAG,GAAGtI,MAAM,CAAC,CAAD,CAAhB;AACA,MAAIuI,GAAG,GAAGvI,MAAM,CAAC,CAAD,CAAhB;AACA,MAAIwI,GAAG,GAAGxI,MAAM,CAAC,CAAD,CAAhB;AAEA,MAAImI,WAAW,GAAGvJ,OAAO,CAACuJ,WAAR,CAAoBnI,MAApB,CAAlB,CAhB0C,CAkB1C;;AACA,MAAIkC,IAAI,CAAC0E,GAAL,CAASuB,WAAT,KAAyBxJ,UAAU,CAAC8H,SAAxC,EAAmD;AACjD,UAAM,IAAI/H,cAAJ,CAAmB,0BAAnB,CAAN;AACD,GArByC,CAsB1C;;;AAEAoB,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgC,GAAG,GAAG0G,GAAN,GAAYD,GAAG,GAAGF,GAA9B;AACAvI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYyI,GAAG,GAAGH,GAAN,GAAYvG,GAAG,GAAG2G,GAA9B;AACA1I,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY+B,GAAG,GAAGwG,GAAN,GAAYvG,GAAG,GAAGsG,GAA9B;AACAtI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYwI,GAAG,GAAGD,GAAN,GAAY1G,GAAG,GAAG6G,GAA9B;AACA1I,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY4B,GAAG,GAAG8G,GAAN,GAAYF,GAAG,GAAGF,GAA9B;AACAtI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY6B,GAAG,GAAGyG,GAAN,GAAY1G,GAAG,GAAG2G,GAA9B;AACAvI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY6B,GAAG,GAAG4G,GAAN,GAAYD,GAAG,GAAGxG,GAA9B;AACAhC,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYwI,GAAG,GAAGzG,GAAN,GAAYH,GAAG,GAAG6G,GAA9B;AACAzI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY4B,GAAG,GAAGI,GAAN,GAAYH,GAAG,GAAGE,GAA9B;AAEA,MAAIiB,KAAK,GAAG,MAAMqF,WAAlB;AACA,SAAOvJ,OAAO,CAAC0G,gBAAR,CAAyBxF,MAAzB,EAAiCgD,KAAjC,EAAwChD,MAAxC,CAAP;AACD,CApCD;AAsCA;;;;;;;;;;AAQAlB,OAAO,CAAC8J,MAAR,GAAiB,UAAU5D,IAAV,EAAgBC,KAAhB,EAAuB;AACtC,SACED,IAAI,KAAKC,KAAT,IACCtG,OAAO,CAACqG,IAAD,CAAP,IACCrG,OAAO,CAACsG,KAAD,CADR,IAECD,IAAI,CAAC,CAAD,CAAJ,KAAYC,KAAK,CAAC,CAAD,CAFlB,IAGCD,IAAI,CAAC,CAAD,CAAJ,KAAYC,KAAK,CAAC,CAAD,CAHlB,IAICD,IAAI,CAAC,CAAD,CAAJ,KAAYC,KAAK,CAAC,CAAD,CAJlB,IAKCD,IAAI,CAAC,CAAD,CAAJ,KAAYC,KAAK,CAAC,CAAD,CALlB,IAMCD,IAAI,CAAC,CAAD,CAAJ,KAAYC,KAAK,CAAC,CAAD,CANlB,IAOCD,IAAI,CAAC,CAAD,CAAJ,KAAYC,KAAK,CAAC,CAAD,CAPlB,IAQCD,IAAI,CAAC,CAAD,CAAJ,KAAYC,KAAK,CAAC,CAAD,CARlB,IASCD,IAAI,CAAC,CAAD,CAAJ,KAAYC,KAAK,CAAC,CAAD,CATlB,IAUCD,IAAI,CAAC,CAAD,CAAJ,KAAYC,KAAK,CAAC,CAAD,CAZrB;AAcD,CAfD;AAiBA;;;;;;;;;;;;AAUAnG,OAAO,CAAC+J,aAAR,GAAwB,UAAU7D,IAAV,EAAgBC,KAAhB,EAAuBmD,OAAvB,EAAgC;AACtD;AACA3J,EAAAA,KAAK,CAACoB,MAAN,CAAaqD,MAAb,CAAoB,SAApB,EAA+BkF,OAA/B,EAFsD,CAGtD;;AAEA,SACEpD,IAAI,KAAKC,KAAT,IACCtG,OAAO,CAACqG,IAAD,CAAP,IACCrG,OAAO,CAACsG,KAAD,CADR,IAEC7C,IAAI,CAAC0E,GAAL,CAAS9B,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAxB,KAAgCmD,OAFjC,IAGChG,IAAI,CAAC0E,GAAL,CAAS9B,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAxB,KAAgCmD,OAHjC,IAIChG,IAAI,CAAC0E,GAAL,CAAS9B,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAxB,KAAgCmD,OAJjC,IAKChG,IAAI,CAAC0E,GAAL,CAAS9B,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAxB,KAAgCmD,OALjC,IAMChG,IAAI,CAAC0E,GAAL,CAAS9B,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAxB,KAAgCmD,OANjC,IAOChG,IAAI,CAAC0E,GAAL,CAAS9B,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAxB,KAAgCmD,OAPjC,IAQChG,IAAI,CAAC0E,GAAL,CAAS9B,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAxB,KAAgCmD,OARjC,IASChG,IAAI,CAAC0E,GAAL,CAAS9B,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAxB,KAAgCmD,OATjC,IAUChG,IAAI,CAAC0E,GAAL,CAAS9B,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAxB,KAAgCmD,OAZpC;AAcD,CAnBD;AAqBA;;;;;;;;AAMAtJ,OAAO,CAAC0I,QAAR,GAAmBsB,MAAM,CAACC,MAAP,CACjB,IAAIjK,OAAJ,CAAY,GAAZ,EAAiB,GAAjB,EAAsB,GAAtB,EAA2B,GAA3B,EAAgC,GAAhC,EAAqC,GAArC,EAA0C,GAA1C,EAA+C,GAA/C,EAAoD,GAApD,CADiB,CAAnB;AAIA;;;;;;;AAMAA,OAAO,CAACkK,IAAR,GAAeF,MAAM,CAACC,MAAP,CACb,IAAIjK,OAAJ,CAAY,GAAZ,EAAiB,GAAjB,EAAsB,GAAtB,EAA2B,GAA3B,EAAgC,GAAhC,EAAqC,GAArC,EAA0C,GAA1C,EAA+C,GAA/C,EAAoD,GAApD,CADa,CAAf;AAIA;;;;;;;AAMAA,OAAO,CAACmK,WAAR,GAAsB,CAAtB;AAEA;;;;;;;AAMAnK,OAAO,CAACoK,WAAR,GAAsB,CAAtB;AAEA;;;;;;;AAMApK,OAAO,CAACqK,WAAR,GAAsB,CAAtB;AAEA;;;;;;;AAMArK,OAAO,CAACsK,WAAR,GAAsB,CAAtB;AAEA;;;;;;;AAMAtK,OAAO,CAACuK,WAAR,GAAsB,CAAtB;AAEA;;;;;;;AAMAvK,OAAO,CAACwK,WAAR,GAAsB,CAAtB;AAEA;;;;;;;AAMAxK,OAAO,CAACyK,WAAR,GAAsB,CAAtB;AAEA;;;;;;;AAMAzK,OAAO,CAAC0K,WAAR,GAAsB,CAAtB;AAEA;;;;;;;AAMA1K,OAAO,CAAC2K,WAAR,GAAsB,CAAtB;AAEAX,MAAM,CAACY,gBAAP,CAAwB5K,OAAO,CAAC6K,SAAhC,EAA2C;AACzC;;;;;;AAMAC,EAAAA,MAAM,EAAE;AACNC,IAAAA,GAAG,EAAE,YAAY;AACf,aAAO/K,OAAO,CAACU,YAAf;AACD;AAHK;AAPiC,CAA3C;AAcA;;;;;;;AAMAV,OAAO,CAAC6K,SAAR,CAAkB1J,KAAlB,GAA0B,UAAUD,MAAV,EAAkB;AAC1C,SAAOlB,OAAO,CAACmB,KAAR,CAAc,IAAd,EAAoBD,MAApB,CAAP;AACD,CAFD;AAIA;;;;;;;;;AAOAlB,OAAO,CAAC6K,SAAR,CAAkBf,MAAlB,GAA2B,UAAU3D,KAAV,EAAiB;AAC1C,SAAOnG,OAAO,CAAC8J,MAAR,CAAe,IAAf,EAAqB3D,KAArB,CAAP;AACD,CAFD;AAIA;;;;;AAGAnG,OAAO,CAACgL,WAAR,GAAsB,UAAU5J,MAAV,EAAkBP,KAAlB,EAAyBoK,MAAzB,EAAiC;AACrD,SACE7J,MAAM,CAAC,CAAD,CAAN,KAAcP,KAAK,CAACoK,MAAD,CAAnB,IACA7J,MAAM,CAAC,CAAD,CAAN,KAAcP,KAAK,CAACoK,MAAM,GAAG,CAAV,CADnB,IAEA7J,MAAM,CAAC,CAAD,CAAN,KAAcP,KAAK,CAACoK,MAAM,GAAG,CAAV,CAFnB,IAGA7J,MAAM,CAAC,CAAD,CAAN,KAAcP,KAAK,CAACoK,MAAM,GAAG,CAAV,CAHnB,IAIA7J,MAAM,CAAC,CAAD,CAAN,KAAcP,KAAK,CAACoK,MAAM,GAAG,CAAV,CAJnB,IAKA7J,MAAM,CAAC,CAAD,CAAN,KAAcP,KAAK,CAACoK,MAAM,GAAG,CAAV,CALnB,IAMA7J,MAAM,CAAC,CAAD,CAAN,KAAcP,KAAK,CAACoK,MAAM,GAAG,CAAV,CANnB,IAOA7J,MAAM,CAAC,CAAD,CAAN,KAAcP,KAAK,CAACoK,MAAM,GAAG,CAAV,CAPnB,IAQA7J,MAAM,CAAC,CAAD,CAAN,KAAcP,KAAK,CAACoK,MAAM,GAAG,CAAV,CATrB;AAWD,CAZD;AAcA;;;;;;;;;;;AASAjL,OAAO,CAAC6K,SAAR,CAAkBd,aAAlB,GAAkC,UAAU5D,KAAV,EAAiBmD,OAAjB,EAA0B;AAC1D,SAAOtJ,OAAO,CAAC+J,aAAR,CAAsB,IAAtB,EAA4B5D,KAA5B,EAAmCmD,OAAnC,CAAP;AACD,CAFD;AAIA;;;;;;;;AAMAtJ,OAAO,CAAC6K,SAAR,CAAkBK,QAAlB,GAA6B,YAAY;AACvC,SACE,MACA,KAAK,CAAL,CADA,GAEA,IAFA,GAGA,KAAK,CAAL,CAHA,GAIA,IAJA,GAKA,KAAK,CAAL,CALA,GAMA,KANA,GAOA,GAPA,GAQA,KAAK,CAAL,CARA,GASA,IATA,GAUA,KAAK,CAAL,CAVA,GAWA,IAXA,GAYA,KAAK,CAAL,CAZA,GAaA,KAbA,GAcA,GAdA,GAeA,KAAK,CAAL,CAfA,GAgBA,IAhBA,GAiBA,KAAK,CAAL,CAjBA,GAkBA,IAlBA,GAmBA,KAAK,CAAL,CAnBA,GAoBA,GArBF;AAuBD,CAxBD;;AAyBA,eAAelL,OAAf","sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A 3x3 matrix, indexable as a column-major order array.\n * Constructor parameters are in row-major order for code readability.\n * @alias Matrix3\n * @constructor\n *\n * @param {Number} [column0Row0=0.0] The value for column 0, row 0.\n * @param {Number} [column1Row0=0.0] The value for column 1, row 0.\n * @param {Number} [column2Row0=0.0] The value for column 2, row 0.\n * @param {Number} [column0Row1=0.0] The value for column 0, row 1.\n * @param {Number} [column1Row1=0.0] The value for column 1, row 1.\n * @param {Number} [column2Row1=0.0] The value for column 2, row 1.\n * @param {Number} [column0Row2=0.0] The value for column 0, row 2.\n * @param {Number} [column1Row2=0.0] The value for column 1, row 2.\n * @param {Number} [column2Row2=0.0] The value for column 2, row 2.\n *\n * @see Matrix3.fromColumnMajorArray\n * @see Matrix3.fromRowMajorArray\n * @see Matrix3.fromQuaternion\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix2\n * @see Matrix4\n */\nfunction Matrix3(\n  column0Row0,\n  column1Row0,\n  column2Row0,\n  column0Row1,\n  column1Row1,\n  column2Row1,\n  column0Row2,\n  column1Row2,\n  column2Row2\n) {\n  this[0] = defaultValue(column0Row0, 0.0);\n  this[1] = defaultValue(column0Row1, 0.0);\n  this[2] = defaultValue(column0Row2, 0.0);\n  this[3] = defaultValue(column1Row0, 0.0);\n  this[4] = defaultValue(column1Row1, 0.0);\n  this[5] = defaultValue(column1Row2, 0.0);\n  this[6] = defaultValue(column2Row0, 0.0);\n  this[7] = defaultValue(column2Row1, 0.0);\n  this[8] = defaultValue(column2Row2, 0.0);\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nMatrix3.packedLength = 9;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Matrix3} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nMatrix3.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value[0];\n  array[startingIndex++] = value[1];\n  array[startingIndex++] = value[2];\n  array[startingIndex++] = value[3];\n  array[startingIndex++] = value[4];\n  array[startingIndex++] = value[5];\n  array[startingIndex++] = value[6];\n  array[startingIndex++] = value[7];\n  array[startingIndex++] = value[8];\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Matrix3} [result] The object into which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n */\nMatrix3.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  result[0] = array[startingIndex++];\n  result[1] = array[startingIndex++];\n  result[2] = array[startingIndex++];\n  result[3] = array[startingIndex++];\n  result[4] = array[startingIndex++];\n  result[5] = array[startingIndex++];\n  result[6] = array[startingIndex++];\n  result[7] = array[startingIndex++];\n  result[8] = array[startingIndex++];\n  return result;\n};\n\n/**\n * Duplicates a Matrix3 instance.\n *\n * @param {Matrix3} matrix The matrix to duplicate.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided. (Returns undefined if matrix is undefined)\n */\nMatrix3.clone = function (matrix, result) {\n  if (!defined(matrix)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Matrix3(\n      matrix[0],\n      matrix[3],\n      matrix[6],\n      matrix[1],\n      matrix[4],\n      matrix[7],\n      matrix[2],\n      matrix[5],\n      matrix[8]\n    );\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n  result[8] = matrix[8];\n  return result;\n};\n\n/**\n * Creates a Matrix3 from 9 consecutive elements in an array.\n *\n * @param {Number[]} array The array whose 9 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Create the Matrix3:\n * // [1.0, 2.0, 3.0]\n * // [1.0, 2.0, 3.0]\n * // [1.0, 2.0, 3.0]\n *\n * var v = [1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];\n * var m = Cesium.Matrix3.fromArray(v);\n *\n * // Create same Matrix3 with using an offset into an array\n * var v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];\n * var m2 = Cesium.Matrix3.fromArray(v2, 2);\n */\nMatrix3.fromArray = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  result[0] = array[startingIndex];\n  result[1] = array[startingIndex + 1];\n  result[2] = array[startingIndex + 2];\n  result[3] = array[startingIndex + 3];\n  result[4] = array[startingIndex + 4];\n  result[5] = array[startingIndex + 5];\n  result[6] = array[startingIndex + 6];\n  result[7] = array[startingIndex + 7];\n  result[8] = array[startingIndex + 8];\n  return result;\n};\n\n/**\n * Creates a Matrix3 instance from a column-major order array.\n *\n * @param {Number[]} values The column-major order array.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n */\nMatrix3.fromColumnMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  return Matrix3.clone(values, result);\n};\n\n/**\n * Creates a Matrix3 instance from a row-major order array.\n * The resulting matrix will be in column-major order.\n *\n * @param {Number[]} values The row-major order array.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n */\nMatrix3.fromRowMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(\n      values[0],\n      values[1],\n      values[2],\n      values[3],\n      values[4],\n      values[5],\n      values[6],\n      values[7],\n      values[8]\n    );\n  }\n  result[0] = values[0];\n  result[1] = values[3];\n  result[2] = values[6];\n  result[3] = values[1];\n  result[4] = values[4];\n  result[5] = values[7];\n  result[6] = values[2];\n  result[7] = values[5];\n  result[8] = values[8];\n  return result;\n};\n\n/**\n * Computes a 3x3 rotation matrix from the provided quaternion.\n *\n * @param {Quaternion} quaternion the quaternion to use.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The 3x3 rotation matrix from this quaternion.\n */\nMatrix3.fromQuaternion = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  //>>includeEnd('debug');\n\n  var x2 = quaternion.x * quaternion.x;\n  var xy = quaternion.x * quaternion.y;\n  var xz = quaternion.x * quaternion.z;\n  var xw = quaternion.x * quaternion.w;\n  var y2 = quaternion.y * quaternion.y;\n  var yz = quaternion.y * quaternion.z;\n  var yw = quaternion.y * quaternion.w;\n  var z2 = quaternion.z * quaternion.z;\n  var zw = quaternion.z * quaternion.w;\n  var w2 = quaternion.w * quaternion.w;\n\n  var m00 = x2 - y2 - z2 + w2;\n  var m01 = 2.0 * (xy - zw);\n  var m02 = 2.0 * (xz + yw);\n\n  var m10 = 2.0 * (xy + zw);\n  var m11 = -x2 + y2 - z2 + w2;\n  var m12 = 2.0 * (yz - xw);\n\n  var m20 = 2.0 * (xz - yw);\n  var m21 = 2.0 * (yz + xw);\n  var m22 = -x2 - y2 + z2 + w2;\n\n  if (!defined(result)) {\n    return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);\n  }\n  result[0] = m00;\n  result[1] = m10;\n  result[2] = m20;\n  result[3] = m01;\n  result[4] = m11;\n  result[5] = m21;\n  result[6] = m02;\n  result[7] = m12;\n  result[8] = m22;\n  return result;\n};\n\n/**\n * Computes a 3x3 rotation matrix from the provided headingPitchRoll. (see http://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles )\n *\n * @param {HeadingPitchRoll} headingPitchRoll the headingPitchRoll to use.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The 3x3 rotation matrix from this headingPitchRoll.\n */\nMatrix3.fromHeadingPitchRoll = function (headingPitchRoll, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"headingPitchRoll\", headingPitchRoll);\n  //>>includeEnd('debug');\n\n  var cosTheta = Math.cos(-headingPitchRoll.pitch);\n  var cosPsi = Math.cos(-headingPitchRoll.heading);\n  var cosPhi = Math.cos(headingPitchRoll.roll);\n  var sinTheta = Math.sin(-headingPitchRoll.pitch);\n  var sinPsi = Math.sin(-headingPitchRoll.heading);\n  var sinPhi = Math.sin(headingPitchRoll.roll);\n\n  var m00 = cosTheta * cosPsi;\n  var m01 = -cosPhi * sinPsi + sinPhi * sinTheta * cosPsi;\n  var m02 = sinPhi * sinPsi + cosPhi * sinTheta * cosPsi;\n\n  var m10 = cosTheta * sinPsi;\n  var m11 = cosPhi * cosPsi + sinPhi * sinTheta * sinPsi;\n  var m12 = -sinPhi * cosPsi + cosPhi * sinTheta * sinPsi;\n\n  var m20 = -sinTheta;\n  var m21 = sinPhi * cosTheta;\n  var m22 = cosPhi * cosTheta;\n\n  if (!defined(result)) {\n    return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);\n  }\n  result[0] = m00;\n  result[1] = m10;\n  result[2] = m20;\n  result[3] = m01;\n  result[4] = m11;\n  result[5] = m21;\n  result[6] = m02;\n  result[7] = m12;\n  result[8] = m22;\n  return result;\n};\n\n/**\n * Computes a Matrix3 instance representing a non-uniform scale.\n *\n * @param {Cartesian3} scale The x, y, and z scale factors.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [7.0, 0.0, 0.0]\n * //   [0.0, 8.0, 0.0]\n * //   [0.0, 0.0, 9.0]\n * var m = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));\n */\nMatrix3.fromScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(scale.x, 0.0, 0.0, 0.0, scale.y, 0.0, 0.0, 0.0, scale.z);\n  }\n\n  result[0] = scale.x;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = scale.y;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = scale.z;\n  return result;\n};\n\n/**\n * Computes a Matrix3 instance representing a uniform scale.\n *\n * @param {Number} scale The uniform scale factor.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [2.0, 0.0, 0.0]\n * //   [0.0, 2.0, 0.0]\n * //   [0.0, 0.0, 2.0]\n * var m = Cesium.Matrix3.fromUniformScale(2.0);\n */\nMatrix3.fromUniformScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(scale, 0.0, 0.0, 0.0, scale, 0.0, 0.0, 0.0, scale);\n  }\n\n  result[0] = scale;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = scale;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = scale;\n  return result;\n};\n\n/**\n * Computes a Matrix3 instance representing the cross product equivalent matrix of a Cartesian3 vector.\n *\n * @param {Cartesian3} vector the vector on the left hand side of the cross product operation.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [0.0, -9.0,  8.0]\n * //   [9.0,  0.0, -7.0]\n * //   [-8.0, 7.0,  0.0]\n * var m = Cesium.Matrix3.fromCrossProduct(new Cesium.Cartesian3(7.0, 8.0, 9.0));\n */\nMatrix3.fromCrossProduct = function (vector, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"vector\", vector);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(\n      0.0,\n      -vector.z,\n      vector.y,\n      vector.z,\n      0.0,\n      -vector.x,\n      -vector.y,\n      vector.x,\n      0.0\n    );\n  }\n\n  result[0] = 0.0;\n  result[1] = vector.z;\n  result[2] = -vector.y;\n  result[3] = -vector.z;\n  result[4] = 0.0;\n  result[5] = vector.x;\n  result[6] = vector.y;\n  result[7] = -vector.x;\n  result[8] = 0.0;\n  return result;\n};\n\n/**\n * Creates a rotation matrix around the x-axis.\n *\n * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise around the x-axis.\n * var p = new Cesium.Cartesian3(5, 6, 7);\n * var m = Cesium.Matrix3.fromRotationX(Cesium.Math.toRadians(45.0));\n * var rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n */\nMatrix3.fromRotationX = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  var cosAngle = Math.cos(angle);\n  var sinAngle = Math.sin(angle);\n\n  if (!defined(result)) {\n    return new Matrix3(\n      1.0,\n      0.0,\n      0.0,\n      0.0,\n      cosAngle,\n      -sinAngle,\n      0.0,\n      sinAngle,\n      cosAngle\n    );\n  }\n\n  result[0] = 1.0;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = cosAngle;\n  result[5] = sinAngle;\n  result[6] = 0.0;\n  result[7] = -sinAngle;\n  result[8] = cosAngle;\n\n  return result;\n};\n\n/**\n * Creates a rotation matrix around the y-axis.\n *\n * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise around the y-axis.\n * var p = new Cesium.Cartesian3(5, 6, 7);\n * var m = Cesium.Matrix3.fromRotationY(Cesium.Math.toRadians(45.0));\n * var rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n */\nMatrix3.fromRotationY = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  var cosAngle = Math.cos(angle);\n  var sinAngle = Math.sin(angle);\n\n  if (!defined(result)) {\n    return new Matrix3(\n      cosAngle,\n      0.0,\n      sinAngle,\n      0.0,\n      1.0,\n      0.0,\n      -sinAngle,\n      0.0,\n      cosAngle\n    );\n  }\n\n  result[0] = cosAngle;\n  result[1] = 0.0;\n  result[2] = -sinAngle;\n  result[3] = 0.0;\n  result[4] = 1.0;\n  result[5] = 0.0;\n  result[6] = sinAngle;\n  result[7] = 0.0;\n  result[8] = cosAngle;\n\n  return result;\n};\n\n/**\n * Creates a rotation matrix around the z-axis.\n *\n * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise around the z-axis.\n * var p = new Cesium.Cartesian3(5, 6, 7);\n * var m = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(45.0));\n * var rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n */\nMatrix3.fromRotationZ = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  var cosAngle = Math.cos(angle);\n  var sinAngle = Math.sin(angle);\n\n  if (!defined(result)) {\n    return new Matrix3(\n      cosAngle,\n      -sinAngle,\n      0.0,\n      sinAngle,\n      cosAngle,\n      0.0,\n      0.0,\n      0.0,\n      1.0\n    );\n  }\n\n  result[0] = cosAngle;\n  result[1] = sinAngle;\n  result[2] = 0.0;\n  result[3] = -sinAngle;\n  result[4] = cosAngle;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 1.0;\n\n  return result;\n};\n\n/**\n * Creates an Array from the provided Matrix3 instance.\n * The array will be in column-major order.\n *\n * @param {Matrix3} matrix The matrix to use..\n * @param {Number[]} [result] The Array onto which to store the result.\n * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.\n */\nMatrix3.toArray = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return [\n      matrix[0],\n      matrix[1],\n      matrix[2],\n      matrix[3],\n      matrix[4],\n      matrix[5],\n      matrix[6],\n      matrix[7],\n      matrix[8],\n    ];\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n  result[8] = matrix[8];\n  return result;\n};\n\n/**\n * Computes the array index of the element at the provided row and column.\n *\n * @param {Number} row The zero-based index of the row.\n * @param {Number} column The zero-based index of the column.\n * @returns {Number} The index of the element at the provided row and column.\n *\n * @exception {DeveloperError} row must be 0, 1, or 2.\n * @exception {DeveloperError} column must be 0, 1, or 2.\n *\n * @example\n * var myMatrix = new Cesium.Matrix3();\n * var column1Row0Index = Cesium.Matrix3.getElementIndex(1, 0);\n * var column1Row0 = myMatrix[column1Row0Index]\n * myMatrix[column1Row0Index] = 10.0;\n */\nMatrix3.getElementIndex = function (column, row) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"row\", row, 0);\n  Check.typeOf.number.lessThanOrEquals(\"row\", row, 2);\n  Check.typeOf.number.greaterThanOrEquals(\"column\", column, 0);\n  Check.typeOf.number.lessThanOrEquals(\"column\", column, 2);\n  //>>includeEnd('debug');\n\n  return column * 3 + row;\n};\n\n/**\n * Retrieves a copy of the matrix column at the provided index as a Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Number} index The zero-based index of the column to retrieve.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.getColumn = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var startIndex = index * 3;\n  var x = matrix[startIndex];\n  var y = matrix[startIndex + 1];\n  var z = matrix[startIndex + 2];\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Number} index The zero-based index of the column to set.\n * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified column.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.setColumn = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix3.clone(matrix, result);\n  var startIndex = index * 3;\n  result[startIndex] = cartesian.x;\n  result[startIndex + 1] = cartesian.y;\n  result[startIndex + 2] = cartesian.z;\n  return result;\n};\n\n/**\n * Retrieves a copy of the matrix row at the provided index as a Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Number} index The zero-based index of the row to retrieve.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.getRow = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var x = matrix[index];\n  var y = matrix[index + 3];\n  var z = matrix[index + 6];\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Number} index The zero-based index of the row to set.\n * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified row.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.setRow = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix3.clone(matrix, result);\n  result[index] = cartesian.x;\n  result[index + 3] = cartesian.y;\n  result[index + 6] = cartesian.z;\n  return result;\n};\n\nvar scratchColumn = new Cartesian3();\n\n/**\n * Extracts the non-uniform scale assuming the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nMatrix3.getScale = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Cartesian3.magnitude(\n    Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn)\n  );\n  result.y = Cartesian3.magnitude(\n    Cartesian3.fromElements(matrix[3], matrix[4], matrix[5], scratchColumn)\n  );\n  result.z = Cartesian3.magnitude(\n    Cartesian3.fromElements(matrix[6], matrix[7], matrix[8], scratchColumn)\n  );\n  return result;\n};\n\nvar scratchScale = new Cartesian3();\n\n/**\n * Computes the maximum scale assuming the matrix is an affine transformation.\n * The maximum scale is the maximum length of the column vectors.\n *\n * @param {Matrix3} matrix The matrix.\n * @returns {Number} The maximum scale.\n */\nMatrix3.getMaximumScale = function (matrix) {\n  Matrix3.getScale(matrix, scratchScale);\n  return Cartesian3.maximumComponent(scratchScale);\n};\n\n/**\n * Computes the product of two matrices.\n *\n * @param {Matrix3} left The first matrix.\n * @param {Matrix3} right The second matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var column0Row0 =\n    left[0] * right[0] + left[3] * right[1] + left[6] * right[2];\n  var column0Row1 =\n    left[1] * right[0] + left[4] * right[1] + left[7] * right[2];\n  var column0Row2 =\n    left[2] * right[0] + left[5] * right[1] + left[8] * right[2];\n\n  var column1Row0 =\n    left[0] * right[3] + left[3] * right[4] + left[6] * right[5];\n  var column1Row1 =\n    left[1] * right[3] + left[4] * right[4] + left[7] * right[5];\n  var column1Row2 =\n    left[2] * right[3] + left[5] * right[4] + left[8] * right[5];\n\n  var column2Row0 =\n    left[0] * right[6] + left[3] * right[7] + left[6] * right[8];\n  var column2Row1 =\n    left[1] * right[6] + left[4] * right[7] + left[7] * right[8];\n  var column2Row2 =\n    left[2] * right[6] + left[5] * right[7] + left[8] * right[8];\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column0Row2;\n  result[3] = column1Row0;\n  result[4] = column1Row1;\n  result[5] = column1Row2;\n  result[6] = column2Row0;\n  result[7] = column2Row1;\n  result[8] = column2Row2;\n  return result;\n};\n\n/**\n * Computes the sum of two matrices.\n *\n * @param {Matrix3} left The first matrix.\n * @param {Matrix3} right The second matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] + right[0];\n  result[1] = left[1] + right[1];\n  result[2] = left[2] + right[2];\n  result[3] = left[3] + right[3];\n  result[4] = left[4] + right[4];\n  result[5] = left[5] + right[5];\n  result[6] = left[6] + right[6];\n  result[7] = left[7] + right[7];\n  result[8] = left[8] + right[8];\n  return result;\n};\n\n/**\n * Computes the difference of two matrices.\n *\n * @param {Matrix3} left The first matrix.\n * @param {Matrix3} right The second matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] - right[0];\n  result[1] = left[1] - right[1];\n  result[2] = left[2] - right[2];\n  result[3] = left[3] - right[3];\n  result[4] = left[4] - right[4];\n  result[5] = left[5] - right[5];\n  result[6] = left[6] - right[6];\n  result[7] = left[7] - right[7];\n  result[8] = left[8] - right[8];\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a column vector.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Cartesian3} cartesian The column.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nMatrix3.multiplyByVector = function (matrix, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var vX = cartesian.x;\n  var vY = cartesian.y;\n  var vZ = cartesian.z;\n\n  var x = matrix[0] * vX + matrix[3] * vY + matrix[6] * vZ;\n  var y = matrix[1] * vX + matrix[4] * vY + matrix[7] * vZ;\n  var z = matrix[2] * vX + matrix[5] * vY + matrix[8] * vZ;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a scalar.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Number} scalar The number to multiply by.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.multiplyByScalar = function (matrix, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scalar;\n  result[1] = matrix[1] * scalar;\n  result[2] = matrix[2] * scalar;\n  result[3] = matrix[3] * scalar;\n  result[4] = matrix[4] * scalar;\n  result[5] = matrix[5] * scalar;\n  result[6] = matrix[6] * scalar;\n  result[7] = matrix[7] * scalar;\n  result[8] = matrix[8] * scalar;\n  return result;\n};\n\n/**\n * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.\n *\n * @param {Matrix3} matrix The matrix on the left-hand side.\n * @param {Cartesian3} scale The non-uniform scale on the right-hand side.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n *\n * @example\n * // Instead of Cesium.Matrix3.multiply(m, Cesium.Matrix3.fromScale(scale), m);\n * Cesium.Matrix3.multiplyByScale(m, scale, m);\n *\n * @see Matrix3.fromScale\n * @see Matrix3.multiplyByUniformScale\n */\nMatrix3.multiplyByScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale.x;\n  result[1] = matrix[1] * scale.x;\n  result[2] = matrix[2] * scale.x;\n  result[3] = matrix[3] * scale.y;\n  result[4] = matrix[4] * scale.y;\n  result[5] = matrix[5] * scale.y;\n  result[6] = matrix[6] * scale.z;\n  result[7] = matrix[7] * scale.z;\n  result[8] = matrix[8] * scale.z;\n  return result;\n};\n\n/**\n * Creates a negated copy of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to negate.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.negate = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = -matrix[0];\n  result[1] = -matrix[1];\n  result[2] = -matrix[2];\n  result[3] = -matrix[3];\n  result[4] = -matrix[4];\n  result[5] = -matrix[5];\n  result[6] = -matrix[6];\n  result[7] = -matrix[7];\n  result[8] = -matrix[8];\n  return result;\n};\n\n/**\n * Computes the transpose of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to transpose.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.transpose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var column0Row0 = matrix[0];\n  var column0Row1 = matrix[3];\n  var column0Row2 = matrix[6];\n  var column1Row0 = matrix[1];\n  var column1Row1 = matrix[4];\n  var column1Row2 = matrix[7];\n  var column2Row0 = matrix[2];\n  var column2Row1 = matrix[5];\n  var column2Row2 = matrix[8];\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column0Row2;\n  result[3] = column1Row0;\n  result[4] = column1Row1;\n  result[5] = column1Row2;\n  result[6] = column2Row0;\n  result[7] = column2Row1;\n  result[8] = column2Row2;\n  return result;\n};\n\nvar UNIT = new Cartesian3(1, 1, 1);\n\n/**\n * Extracts the rotation assuming the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter\n */\nMatrix3.getRotation = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var inverseScale = Cartesian3.divideComponents(\n    UNIT,\n    Matrix3.getScale(matrix, scratchScale),\n    scratchScale\n  );\n  result = Matrix3.multiplyByScale(matrix, inverseScale, result);\n\n  return result;\n};\n\nfunction computeFrobeniusNorm(matrix) {\n  var norm = 0.0;\n  for (var i = 0; i < 9; ++i) {\n    var temp = matrix[i];\n    norm += temp * temp;\n  }\n\n  return Math.sqrt(norm);\n}\n\nvar rowVal = [1, 0, 0];\nvar colVal = [2, 2, 1];\n\nfunction offDiagonalFrobeniusNorm(matrix) {\n  // Computes the \"off-diagonal\" Frobenius norm.\n  // Assumes matrix is symmetric.\n\n  var norm = 0.0;\n  for (var i = 0; i < 3; ++i) {\n    var temp = matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])];\n    norm += 2.0 * temp * temp;\n  }\n\n  return Math.sqrt(norm);\n}\n\nfunction shurDecomposition(matrix, result) {\n  // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n  // section 8.4.2 The 2by2 Symmetric Schur Decomposition.\n  //\n  // The routine takes a matrix, which is assumed to be symmetric, and\n  // finds the largest off-diagonal term, and then creates\n  // a matrix (result) which can be used to help reduce it\n\n  var tolerance = CesiumMath.EPSILON15;\n\n  var maxDiagonal = 0.0;\n  var rotAxis = 1;\n\n  // find pivot (rotAxis) based on max diagonal of matrix\n  for (var i = 0; i < 3; ++i) {\n    var temp = Math.abs(matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])]);\n    if (temp > maxDiagonal) {\n      rotAxis = i;\n      maxDiagonal = temp;\n    }\n  }\n\n  var c = 1.0;\n  var s = 0.0;\n\n  var p = rowVal[rotAxis];\n  var q = colVal[rotAxis];\n\n  if (Math.abs(matrix[Matrix3.getElementIndex(q, p)]) > tolerance) {\n    var qq = matrix[Matrix3.getElementIndex(q, q)];\n    var pp = matrix[Matrix3.getElementIndex(p, p)];\n    var qp = matrix[Matrix3.getElementIndex(q, p)];\n\n    var tau = (qq - pp) / 2.0 / qp;\n    var t;\n\n    if (tau < 0.0) {\n      t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));\n    } else {\n      t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));\n    }\n\n    c = 1.0 / Math.sqrt(1.0 + t * t);\n    s = t * c;\n  }\n\n  result = Matrix3.clone(Matrix3.IDENTITY, result);\n\n  result[Matrix3.getElementIndex(p, p)] = result[\n    Matrix3.getElementIndex(q, q)\n  ] = c;\n  result[Matrix3.getElementIndex(q, p)] = s;\n  result[Matrix3.getElementIndex(p, q)] = -s;\n\n  return result;\n}\n\nvar jMatrix = new Matrix3();\nvar jMatrixTranspose = new Matrix3();\n\n/**\n * Computes the eigenvectors and eigenvalues of a symmetric matrix.\n * <p>\n * Returns a diagonal matrix and unitary matrix such that:\n * <code>matrix = unitary matrix * diagonal matrix * transpose(unitary matrix)</code>\n * </p>\n * <p>\n * The values along the diagonal of the diagonal matrix are the eigenvalues. The columns\n * of the unitary matrix are the corresponding eigenvectors.\n * </p>\n *\n * @param {Matrix3} matrix The matrix to decompose into diagonal and unitary matrix. Expected to be symmetric.\n * @param {Object} [result] An object with unitary and diagonal properties which are matrices onto which to store the result.\n * @returns {Object} An object with unitary and diagonal properties which are the unitary and diagonal matrices, respectively.\n *\n * @example\n * var a = //... symetric matrix\n * var result = {\n *     unitary : new Cesium.Matrix3(),\n *     diagonal : new Cesium.Matrix3()\n * };\n * Cesium.Matrix3.computeEigenDecomposition(a, result);\n *\n * var unitaryTranspose = Cesium.Matrix3.transpose(result.unitary, new Cesium.Matrix3());\n * var b = Cesium.Matrix3.multiply(result.unitary, result.diagonal, new Cesium.Matrix3());\n * Cesium.Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a\n *\n * var lambda = Cesium.Matrix3.getColumn(result.diagonal, 0, new Cesium.Cartesian3()).x;  // first eigenvalue\n * var v = Cesium.Matrix3.getColumn(result.unitary, 0, new Cesium.Cartesian3());          // first eigenvector\n * var c = Cesium.Cartesian3.multiplyByScalar(v, lambda, new Cesium.Cartesian3());        // equal to Cesium.Matrix3.multiplyByVector(a, v)\n */\nMatrix3.computeEigenDecomposition = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n  // section 8.4.3 The Classical Jacobi Algorithm\n\n  var tolerance = CesiumMath.EPSILON20;\n  var maxSweeps = 10;\n\n  var count = 0;\n  var sweep = 0;\n\n  if (!defined(result)) {\n    result = {};\n  }\n\n  var unitaryMatrix = (result.unitary = Matrix3.clone(\n    Matrix3.IDENTITY,\n    result.unitary\n  ));\n  var diagMatrix = (result.diagonal = Matrix3.clone(matrix, result.diagonal));\n\n  var epsilon = tolerance * computeFrobeniusNorm(diagMatrix);\n\n  while (sweep < maxSweeps && offDiagonalFrobeniusNorm(diagMatrix) > epsilon) {\n    shurDecomposition(diagMatrix, jMatrix);\n    Matrix3.transpose(jMatrix, jMatrixTranspose);\n    Matrix3.multiply(diagMatrix, jMatrix, diagMatrix);\n    Matrix3.multiply(jMatrixTranspose, diagMatrix, diagMatrix);\n    Matrix3.multiply(unitaryMatrix, jMatrix, unitaryMatrix);\n\n    if (++count > 2) {\n      ++sweep;\n      count = 0;\n    }\n  }\n\n  return result;\n};\n\n/**\n * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.\n *\n * @param {Matrix3} matrix The matrix with signed elements.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.abs = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = Math.abs(matrix[0]);\n  result[1] = Math.abs(matrix[1]);\n  result[2] = Math.abs(matrix[2]);\n  result[3] = Math.abs(matrix[3]);\n  result[4] = Math.abs(matrix[4]);\n  result[5] = Math.abs(matrix[5]);\n  result[6] = Math.abs(matrix[6]);\n  result[7] = Math.abs(matrix[7]);\n  result[8] = Math.abs(matrix[8]);\n\n  return result;\n};\n\n/**\n * Computes the determinant of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @returns {Number} The value of the determinant of the matrix.\n */\nMatrix3.determinant = function (matrix) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  var m11 = matrix[0];\n  var m21 = matrix[3];\n  var m31 = matrix[6];\n  var m12 = matrix[1];\n  var m22 = matrix[4];\n  var m32 = matrix[7];\n  var m13 = matrix[2];\n  var m23 = matrix[5];\n  var m33 = matrix[8];\n\n  return (\n    m11 * (m22 * m33 - m23 * m32) +\n    m12 * (m23 * m31 - m21 * m33) +\n    m13 * (m21 * m32 - m22 * m31)\n  );\n};\n\n/**\n * Computes the inverse of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to invert.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @exception {DeveloperError} matrix is not invertible.\n */\nMatrix3.inverse = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var m11 = matrix[0];\n  var m21 = matrix[1];\n  var m31 = matrix[2];\n  var m12 = matrix[3];\n  var m22 = matrix[4];\n  var m32 = matrix[5];\n  var m13 = matrix[6];\n  var m23 = matrix[7];\n  var m33 = matrix[8];\n\n  var determinant = Matrix3.determinant(matrix);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (Math.abs(determinant) <= CesiumMath.EPSILON15) {\n    throw new DeveloperError(\"matrix is not invertible\");\n  }\n  //>>includeEnd('debug');\n\n  result[0] = m22 * m33 - m23 * m32;\n  result[1] = m23 * m31 - m21 * m33;\n  result[2] = m21 * m32 - m22 * m31;\n  result[3] = m13 * m32 - m12 * m33;\n  result[4] = m11 * m33 - m13 * m31;\n  result[5] = m12 * m31 - m11 * m32;\n  result[6] = m12 * m23 - m13 * m22;\n  result[7] = m13 * m21 - m11 * m23;\n  result[8] = m11 * m22 - m12 * m21;\n\n  var scale = 1.0 / determinant;\n  return Matrix3.multiplyByScalar(result, scale, result);\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix3} [left] The first matrix.\n * @param {Matrix3} [right] The second matrix.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nMatrix3.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left[0] === right[0] &&\n      left[1] === right[1] &&\n      left[2] === right[2] &&\n      left[3] === right[3] &&\n      left[4] === right[4] &&\n      left[5] === right[5] &&\n      left[6] === right[6] &&\n      left[7] === right[7] &&\n      left[8] === right[8])\n  );\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix3} [left] The first matrix.\n * @param {Matrix3} [right] The second matrix.\n * @param {Number} epsilon The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix3.equalsEpsilon = function (left, right, epsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"epsilon\", epsilon);\n  //>>includeEnd('debug');\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(left[0] - right[0]) <= epsilon &&\n      Math.abs(left[1] - right[1]) <= epsilon &&\n      Math.abs(left[2] - right[2]) <= epsilon &&\n      Math.abs(left[3] - right[3]) <= epsilon &&\n      Math.abs(left[4] - right[4]) <= epsilon &&\n      Math.abs(left[5] - right[5]) <= epsilon &&\n      Math.abs(left[6] - right[6]) <= epsilon &&\n      Math.abs(left[7] - right[7]) <= epsilon &&\n      Math.abs(left[8] - right[8]) <= epsilon)\n  );\n};\n\n/**\n * An immutable Matrix3 instance initialized to the identity matrix.\n *\n * @type {Matrix3}\n * @constant\n */\nMatrix3.IDENTITY = Object.freeze(\n  new Matrix3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0)\n);\n\n/**\n * An immutable Matrix3 instance initialized to the zero matrix.\n *\n * @type {Matrix3}\n * @constant\n */\nMatrix3.ZERO = Object.freeze(\n  new Matrix3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n);\n\n/**\n * The index into Matrix3 for column 0, row 0.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN0ROW0 = 0;\n\n/**\n * The index into Matrix3 for column 0, row 1.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN0ROW1 = 1;\n\n/**\n * The index into Matrix3 for column 0, row 2.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN0ROW2 = 2;\n\n/**\n * The index into Matrix3 for column 1, row 0.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN1ROW0 = 3;\n\n/**\n * The index into Matrix3 for column 1, row 1.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN1ROW1 = 4;\n\n/**\n * The index into Matrix3 for column 1, row 2.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN1ROW2 = 5;\n\n/**\n * The index into Matrix3 for column 2, row 0.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN2ROW0 = 6;\n\n/**\n * The index into Matrix3 for column 2, row 1.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN2ROW1 = 7;\n\n/**\n * The index into Matrix3 for column 2, row 2.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN2ROW2 = 8;\n\nObject.defineProperties(Matrix3.prototype, {\n  /**\n   * Gets the number of items in the collection.\n   * @memberof Matrix3.prototype\n   *\n   * @type {Number}\n   */\n  length: {\n    get: function () {\n      return Matrix3.packedLength;\n    },\n  },\n});\n\n/**\n * Duplicates the provided Matrix3 instance.\n *\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n */\nMatrix3.prototype.clone = function (result) {\n  return Matrix3.clone(this, result);\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix3} [right] The right hand side matrix.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nMatrix3.prototype.equals = function (right) {\n  return Matrix3.equals(this, right);\n};\n\n/**\n * @private\n */\nMatrix3.equalsArray = function (matrix, array, offset) {\n  return (\n    matrix[0] === array[offset] &&\n    matrix[1] === array[offset + 1] &&\n    matrix[2] === array[offset + 2] &&\n    matrix[3] === array[offset + 3] &&\n    matrix[4] === array[offset + 4] &&\n    matrix[5] === array[offset + 5] &&\n    matrix[6] === array[offset + 6] &&\n    matrix[7] === array[offset + 7] &&\n    matrix[8] === array[offset + 8]\n  );\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix3} [right] The right hand side matrix.\n * @param {Number} epsilon The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix3.prototype.equalsEpsilon = function (right, epsilon) {\n  return Matrix3.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this Matrix with each row being\n * on a separate line and in the format '(column0, column1, column2)'.\n *\n * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2)'.\n */\nMatrix3.prototype.toString = function () {\n  return (\n    \"(\" +\n    this[0] +\n    \", \" +\n    this[3] +\n    \", \" +\n    this[6] +\n    \")\\n\" +\n    \"(\" +\n    this[1] +\n    \", \" +\n    this[4] +\n    \", \" +\n    this[7] +\n    \")\\n\" +\n    \"(\" +\n    this[2] +\n    \", \" +\n    this[5] +\n    \", \" +\n    this[8] +\n    \")\"\n  );\n};\nexport default Matrix3;\n"]},"metadata":{},"sourceType":"module"}