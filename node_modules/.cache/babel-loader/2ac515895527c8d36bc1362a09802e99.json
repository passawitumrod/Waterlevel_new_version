{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix2 from \"./Matrix2.js\";\nimport Rectangle from \"./Rectangle.js\";\nvar cos = Math.cos;\nvar sin = Math.sin;\nvar sqrt = Math.sqrt;\n/**\n * @private\n */\n\nvar RectangleGeometryLibrary = {};\n/**\n * @private\n */\n\nRectangleGeometryLibrary.computePosition = function (computedOptions, ellipsoid, computeST, row, col, position, st) {\n  var radiiSquared = ellipsoid.radiiSquared;\n  var nwCorner = computedOptions.nwCorner;\n  var rectangle = computedOptions.boundingRectangle;\n  var stLatitude = nwCorner.latitude - computedOptions.granYCos * row + col * computedOptions.granXSin;\n  var cosLatitude = cos(stLatitude);\n  var nZ = sin(stLatitude);\n  var kZ = radiiSquared.z * nZ;\n  var stLongitude = nwCorner.longitude + row * computedOptions.granYSin + col * computedOptions.granXCos;\n  var nX = cosLatitude * cos(stLongitude);\n  var nY = cosLatitude * sin(stLongitude);\n  var kX = radiiSquared.x * nX;\n  var kY = radiiSquared.y * nY;\n  var gamma = sqrt(kX * nX + kY * nY + kZ * nZ);\n  position.x = kX / gamma;\n  position.y = kY / gamma;\n  position.z = kZ / gamma;\n\n  if (computeST) {\n    var stNwCorner = computedOptions.stNwCorner;\n\n    if (defined(stNwCorner)) {\n      stLatitude = stNwCorner.latitude - computedOptions.stGranYCos * row + col * computedOptions.stGranXSin;\n      stLongitude = stNwCorner.longitude + row * computedOptions.stGranYSin + col * computedOptions.stGranXCos;\n      st.x = (stLongitude - computedOptions.stWest) * computedOptions.lonScalar;\n      st.y = (stLatitude - computedOptions.stSouth) * computedOptions.latScalar;\n    } else {\n      st.x = (stLongitude - rectangle.west) * computedOptions.lonScalar;\n      st.y = (stLatitude - rectangle.south) * computedOptions.latScalar;\n    }\n  }\n};\n\nvar rotationMatrixScratch = new Matrix2();\nvar nwCartesian = new Cartesian3();\nvar centerScratch = new Cartographic();\nvar centerCartesian = new Cartesian3();\nvar proj = new GeographicProjection();\n\nfunction getRotationOptions(nwCorner, rotation, granularityX, granularityY, center, width, height) {\n  var cosRotation = Math.cos(rotation);\n  var granYCos = granularityY * cosRotation;\n  var granXCos = granularityX * cosRotation;\n  var sinRotation = Math.sin(rotation);\n  var granYSin = granularityY * sinRotation;\n  var granXSin = granularityX * sinRotation;\n  nwCartesian = proj.project(nwCorner, nwCartesian);\n  nwCartesian = Cartesian3.subtract(nwCartesian, centerCartesian, nwCartesian);\n  var rotationMatrix = Matrix2.fromRotation(rotation, rotationMatrixScratch);\n  nwCartesian = Matrix2.multiplyByVector(rotationMatrix, nwCartesian, nwCartesian);\n  nwCartesian = Cartesian3.add(nwCartesian, centerCartesian, nwCartesian);\n  nwCorner = proj.unproject(nwCartesian, nwCorner);\n  width -= 1;\n  height -= 1;\n  var latitude = nwCorner.latitude;\n  var latitude0 = latitude + width * granXSin;\n  var latitude1 = latitude - granYCos * height;\n  var latitude2 = latitude - granYCos * height + width * granXSin;\n  var north = Math.max(latitude, latitude0, latitude1, latitude2);\n  var south = Math.min(latitude, latitude0, latitude1, latitude2);\n  var longitude = nwCorner.longitude;\n  var longitude0 = longitude + width * granXCos;\n  var longitude1 = longitude + height * granYSin;\n  var longitude2 = longitude + height * granYSin + width * granXCos;\n  var east = Math.max(longitude, longitude0, longitude1, longitude2);\n  var west = Math.min(longitude, longitude0, longitude1, longitude2);\n  return {\n    north: north,\n    south: south,\n    east: east,\n    west: west,\n    granYCos: granYCos,\n    granYSin: granYSin,\n    granXCos: granXCos,\n    granXSin: granXSin,\n    nwCorner: nwCorner\n  };\n}\n/**\n * @private\n */\n\n\nRectangleGeometryLibrary.computeOptions = function (rectangle, granularity, rotation, stRotation, boundingRectangleScratch, nwCornerResult, stNwCornerResult) {\n  var east = rectangle.east;\n  var west = rectangle.west;\n  var north = rectangle.north;\n  var south = rectangle.south;\n  var northCap = false;\n  var southCap = false;\n\n  if (north === CesiumMath.PI_OVER_TWO) {\n    northCap = true;\n  }\n\n  if (south === -CesiumMath.PI_OVER_TWO) {\n    southCap = true;\n  }\n\n  var width;\n  var height;\n  var granularityX;\n  var granularityY;\n  var dx;\n  var dy = north - south;\n\n  if (west > east) {\n    dx = CesiumMath.TWO_PI - west + east;\n  } else {\n    dx = east - west;\n  }\n\n  width = Math.ceil(dx / granularity) + 1;\n  height = Math.ceil(dy / granularity) + 1;\n  granularityX = dx / (width - 1);\n  granularityY = dy / (height - 1);\n  var nwCorner = Rectangle.northwest(rectangle, nwCornerResult);\n  var center = Rectangle.center(rectangle, centerScratch);\n\n  if (rotation !== 0 || stRotation !== 0) {\n    if (center.longitude < nwCorner.longitude) {\n      center.longitude += CesiumMath.TWO_PI;\n    }\n\n    centerCartesian = proj.project(center, centerCartesian);\n  }\n\n  var granYCos = granularityY;\n  var granXCos = granularityX;\n  var granYSin = 0.0;\n  var granXSin = 0.0;\n  var boundingRectangle = Rectangle.clone(rectangle, boundingRectangleScratch);\n  var computedOptions = {\n    granYCos: granYCos,\n    granYSin: granYSin,\n    granXCos: granXCos,\n    granXSin: granXSin,\n    nwCorner: nwCorner,\n    boundingRectangle: boundingRectangle,\n    width: width,\n    height: height,\n    northCap: northCap,\n    southCap: southCap\n  };\n\n  if (rotation !== 0) {\n    var rotationOptions = getRotationOptions(nwCorner, rotation, granularityX, granularityY, center, width, height);\n    north = rotationOptions.north;\n    south = rotationOptions.south;\n    east = rotationOptions.east;\n    west = rotationOptions.west; //>>includeStart('debug', pragmas.debug);\n\n    if (north < -CesiumMath.PI_OVER_TWO || north > CesiumMath.PI_OVER_TWO || south < -CesiumMath.PI_OVER_TWO || south > CesiumMath.PI_OVER_TWO) {\n      throw new DeveloperError(\"Rotated rectangle is invalid.  It crosses over either the north or south pole.\");\n    } //>>includeEnd('debug')\n\n\n    computedOptions.granYCos = rotationOptions.granYCos;\n    computedOptions.granYSin = rotationOptions.granYSin;\n    computedOptions.granXCos = rotationOptions.granXCos;\n    computedOptions.granXSin = rotationOptions.granXSin;\n    boundingRectangle.north = north;\n    boundingRectangle.south = south;\n    boundingRectangle.east = east;\n    boundingRectangle.west = west;\n  }\n\n  if (stRotation !== 0) {\n    rotation = rotation - stRotation;\n    var stNwCorner = Rectangle.northwest(boundingRectangle, stNwCornerResult);\n    var stRotationOptions = getRotationOptions(stNwCorner, rotation, granularityX, granularityY, center, width, height);\n    computedOptions.stGranYCos = stRotationOptions.granYCos;\n    computedOptions.stGranXCos = stRotationOptions.granXCos;\n    computedOptions.stGranYSin = stRotationOptions.granYSin;\n    computedOptions.stGranXSin = stRotationOptions.granXSin;\n    computedOptions.stNwCorner = stNwCorner;\n    computedOptions.stWest = stRotationOptions.west;\n    computedOptions.stSouth = stRotationOptions.south;\n  }\n\n  return computedOptions;\n};\n\nexport default RectangleGeometryLibrary;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/RectangleGeometryLibrary.js"],"names":["Cartesian3","Cartographic","defined","DeveloperError","GeographicProjection","CesiumMath","Matrix2","Rectangle","cos","Math","sin","sqrt","RectangleGeometryLibrary","computePosition","computedOptions","ellipsoid","computeST","row","col","position","st","radiiSquared","nwCorner","rectangle","boundingRectangle","stLatitude","latitude","granYCos","granXSin","cosLatitude","nZ","kZ","z","stLongitude","longitude","granYSin","granXCos","nX","nY","kX","x","kY","y","gamma","stNwCorner","stGranYCos","stGranXSin","stGranYSin","stGranXCos","stWest","lonScalar","stSouth","latScalar","west","south","rotationMatrixScratch","nwCartesian","centerScratch","centerCartesian","proj","getRotationOptions","rotation","granularityX","granularityY","center","width","height","cosRotation","sinRotation","project","subtract","rotationMatrix","fromRotation","multiplyByVector","add","unproject","latitude0","latitude1","latitude2","north","max","min","longitude0","longitude1","longitude2","east","computeOptions","granularity","stRotation","boundingRectangleScratch","nwCornerResult","stNwCornerResult","northCap","southCap","PI_OVER_TWO","dx","dy","TWO_PI","ceil","northwest","clone","rotationOptions","stRotationOptions"],"mappings":"AAAA,OAAOA,UAAP,MAAuB,iBAAvB;AACA,OAAOC,YAAP,MAAyB,mBAAzB;AACA,OAAOC,OAAP,MAAoB,cAApB;AACA,OAAOC,cAAP,MAA2B,qBAA3B;AACA,OAAOC,oBAAP,MAAiC,2BAAjC;AACA,OAAOC,UAAP,MAAuB,WAAvB;AACA,OAAOC,OAAP,MAAoB,cAApB;AACA,OAAOC,SAAP,MAAsB,gBAAtB;AAEA,IAAIC,GAAG,GAAGC,IAAI,CAACD,GAAf;AACA,IAAIE,GAAG,GAAGD,IAAI,CAACC,GAAf;AACA,IAAIC,IAAI,GAAGF,IAAI,CAACE,IAAhB;AAEA;;;;AAGA,IAAIC,wBAAwB,GAAG,EAA/B;AAEA;;;;AAGAA,wBAAwB,CAACC,eAAzB,GAA2C,UACzCC,eADyC,EAEzCC,SAFyC,EAGzCC,SAHyC,EAIzCC,GAJyC,EAKzCC,GALyC,EAMzCC,QANyC,EAOzCC,EAPyC,EAQzC;AACA,MAAIC,YAAY,GAAGN,SAAS,CAACM,YAA7B;AACA,MAAIC,QAAQ,GAAGR,eAAe,CAACQ,QAA/B;AACA,MAAIC,SAAS,GAAGT,eAAe,CAACU,iBAAhC;AAEA,MAAIC,UAAU,GACZH,QAAQ,CAACI,QAAT,GACAZ,eAAe,CAACa,QAAhB,GAA2BV,GAD3B,GAEAC,GAAG,GAAGJ,eAAe,CAACc,QAHxB;AAIA,MAAIC,WAAW,GAAGrB,GAAG,CAACiB,UAAD,CAArB;AACA,MAAIK,EAAE,GAAGpB,GAAG,CAACe,UAAD,CAAZ;AACA,MAAIM,EAAE,GAAGV,YAAY,CAACW,CAAb,GAAiBF,EAA1B;AAEA,MAAIG,WAAW,GACbX,QAAQ,CAACY,SAAT,GACAjB,GAAG,GAAGH,eAAe,CAACqB,QADtB,GAEAjB,GAAG,GAAGJ,eAAe,CAACsB,QAHxB;AAIA,MAAIC,EAAE,GAAGR,WAAW,GAAGrB,GAAG,CAACyB,WAAD,CAA1B;AACA,MAAIK,EAAE,GAAGT,WAAW,GAAGnB,GAAG,CAACuB,WAAD,CAA1B;AAEA,MAAIM,EAAE,GAAGlB,YAAY,CAACmB,CAAb,GAAiBH,EAA1B;AACA,MAAII,EAAE,GAAGpB,YAAY,CAACqB,CAAb,GAAiBJ,EAA1B;AAEA,MAAIK,KAAK,GAAGhC,IAAI,CAAC4B,EAAE,GAAGF,EAAL,GAAUI,EAAE,GAAGH,EAAf,GAAoBP,EAAE,GAAGD,EAA1B,CAAhB;AAEAX,EAAAA,QAAQ,CAACqB,CAAT,GAAaD,EAAE,GAAGI,KAAlB;AACAxB,EAAAA,QAAQ,CAACuB,CAAT,GAAaD,EAAE,GAAGE,KAAlB;AACAxB,EAAAA,QAAQ,CAACa,CAAT,GAAaD,EAAE,GAAGY,KAAlB;;AAEA,MAAI3B,SAAJ,EAAe;AACb,QAAI4B,UAAU,GAAG9B,eAAe,CAAC8B,UAAjC;;AACA,QAAI1C,OAAO,CAAC0C,UAAD,CAAX,EAAyB;AACvBnB,MAAAA,UAAU,GACRmB,UAAU,CAAClB,QAAX,GACAZ,eAAe,CAAC+B,UAAhB,GAA6B5B,GAD7B,GAEAC,GAAG,GAAGJ,eAAe,CAACgC,UAHxB;AAIAb,MAAAA,WAAW,GACTW,UAAU,CAACV,SAAX,GACAjB,GAAG,GAAGH,eAAe,CAACiC,UADtB,GAEA7B,GAAG,GAAGJ,eAAe,CAACkC,UAHxB;AAKA5B,MAAAA,EAAE,CAACoB,CAAH,GAAO,CAACP,WAAW,GAAGnB,eAAe,CAACmC,MAA/B,IAAyCnC,eAAe,CAACoC,SAAhE;AACA9B,MAAAA,EAAE,CAACsB,CAAH,GAAO,CAACjB,UAAU,GAAGX,eAAe,CAACqC,OAA9B,IAAyCrC,eAAe,CAACsC,SAAhE;AACD,KAZD,MAYO;AACLhC,MAAAA,EAAE,CAACoB,CAAH,GAAO,CAACP,WAAW,GAAGV,SAAS,CAAC8B,IAAzB,IAAiCvC,eAAe,CAACoC,SAAxD;AACA9B,MAAAA,EAAE,CAACsB,CAAH,GAAO,CAACjB,UAAU,GAAGF,SAAS,CAAC+B,KAAxB,IAAiCxC,eAAe,CAACsC,SAAxD;AACD;AACF;AACF,CAxDD;;AA0DA,IAAIG,qBAAqB,GAAG,IAAIjD,OAAJ,EAA5B;AACA,IAAIkD,WAAW,GAAG,IAAIxD,UAAJ,EAAlB;AACA,IAAIyD,aAAa,GAAG,IAAIxD,YAAJ,EAApB;AACA,IAAIyD,eAAe,GAAG,IAAI1D,UAAJ,EAAtB;AACA,IAAI2D,IAAI,GAAG,IAAIvD,oBAAJ,EAAX;;AAEA,SAASwD,kBAAT,CACEtC,QADF,EAEEuC,QAFF,EAGEC,YAHF,EAIEC,YAJF,EAKEC,MALF,EAMEC,KANF,EAOEC,MAPF,EAQE;AACA,MAAIC,WAAW,GAAG1D,IAAI,CAACD,GAAL,CAASqD,QAAT,CAAlB;AACA,MAAIlC,QAAQ,GAAGoC,YAAY,GAAGI,WAA9B;AACA,MAAI/B,QAAQ,GAAG0B,YAAY,GAAGK,WAA9B;AAEA,MAAIC,WAAW,GAAG3D,IAAI,CAACC,GAAL,CAASmD,QAAT,CAAlB;AACA,MAAI1B,QAAQ,GAAG4B,YAAY,GAAGK,WAA9B;AACA,MAAIxC,QAAQ,GAAGkC,YAAY,GAAGM,WAA9B;AAEAZ,EAAAA,WAAW,GAAGG,IAAI,CAACU,OAAL,CAAa/C,QAAb,EAAuBkC,WAAvB,CAAd;AAEAA,EAAAA,WAAW,GAAGxD,UAAU,CAACsE,QAAX,CAAoBd,WAApB,EAAiCE,eAAjC,EAAkDF,WAAlD,CAAd;AACA,MAAIe,cAAc,GAAGjE,OAAO,CAACkE,YAAR,CAAqBX,QAArB,EAA+BN,qBAA/B,CAArB;AACAC,EAAAA,WAAW,GAAGlD,OAAO,CAACmE,gBAAR,CACZF,cADY,EAEZf,WAFY,EAGZA,WAHY,CAAd;AAKAA,EAAAA,WAAW,GAAGxD,UAAU,CAAC0E,GAAX,CAAelB,WAAf,EAA4BE,eAA5B,EAA6CF,WAA7C,CAAd;AACAlC,EAAAA,QAAQ,GAAGqC,IAAI,CAACgB,SAAL,CAAenB,WAAf,EAA4BlC,QAA5B,CAAX;AAEA2C,EAAAA,KAAK,IAAI,CAAT;AACAC,EAAAA,MAAM,IAAI,CAAV;AAEA,MAAIxC,QAAQ,GAAGJ,QAAQ,CAACI,QAAxB;AACA,MAAIkD,SAAS,GAAGlD,QAAQ,GAAGuC,KAAK,GAAGrC,QAAnC;AACA,MAAIiD,SAAS,GAAGnD,QAAQ,GAAGC,QAAQ,GAAGuC,MAAtC;AACA,MAAIY,SAAS,GAAGpD,QAAQ,GAAGC,QAAQ,GAAGuC,MAAtB,GAA+BD,KAAK,GAAGrC,QAAvD;AAEA,MAAImD,KAAK,GAAGtE,IAAI,CAACuE,GAAL,CAAStD,QAAT,EAAmBkD,SAAnB,EAA8BC,SAA9B,EAAyCC,SAAzC,CAAZ;AACA,MAAIxB,KAAK,GAAG7C,IAAI,CAACwE,GAAL,CAASvD,QAAT,EAAmBkD,SAAnB,EAA8BC,SAA9B,EAAyCC,SAAzC,CAAZ;AAEA,MAAI5C,SAAS,GAAGZ,QAAQ,CAACY,SAAzB;AACA,MAAIgD,UAAU,GAAGhD,SAAS,GAAG+B,KAAK,GAAG7B,QAArC;AACA,MAAI+C,UAAU,GAAGjD,SAAS,GAAGgC,MAAM,GAAG/B,QAAtC;AACA,MAAIiD,UAAU,GAAGlD,SAAS,GAAGgC,MAAM,GAAG/B,QAArB,GAAgC8B,KAAK,GAAG7B,QAAzD;AAEA,MAAIiD,IAAI,GAAG5E,IAAI,CAACuE,GAAL,CAAS9C,SAAT,EAAoBgD,UAApB,EAAgCC,UAAhC,EAA4CC,UAA5C,CAAX;AACA,MAAI/B,IAAI,GAAG5C,IAAI,CAACwE,GAAL,CAAS/C,SAAT,EAAoBgD,UAApB,EAAgCC,UAAhC,EAA4CC,UAA5C,CAAX;AAEA,SAAO;AACLL,IAAAA,KAAK,EAAEA,KADF;AAELzB,IAAAA,KAAK,EAAEA,KAFF;AAGL+B,IAAAA,IAAI,EAAEA,IAHD;AAILhC,IAAAA,IAAI,EAAEA,IAJD;AAKL1B,IAAAA,QAAQ,EAAEA,QALL;AAMLQ,IAAAA,QAAQ,EAAEA,QANL;AAOLC,IAAAA,QAAQ,EAAEA,QAPL;AAQLR,IAAAA,QAAQ,EAAEA,QARL;AASLN,IAAAA,QAAQ,EAAEA;AATL,GAAP;AAWD;AAED;;;;;AAGAV,wBAAwB,CAAC0E,cAAzB,GAA0C,UACxC/D,SADwC,EAExCgE,WAFwC,EAGxC1B,QAHwC,EAIxC2B,UAJwC,EAKxCC,wBALwC,EAMxCC,cANwC,EAOxCC,gBAPwC,EAQxC;AACA,MAAIN,IAAI,GAAG9D,SAAS,CAAC8D,IAArB;AACA,MAAIhC,IAAI,GAAG9B,SAAS,CAAC8B,IAArB;AACA,MAAI0B,KAAK,GAAGxD,SAAS,CAACwD,KAAtB;AACA,MAAIzB,KAAK,GAAG/B,SAAS,CAAC+B,KAAtB;AAEA,MAAIsC,QAAQ,GAAG,KAAf;AACA,MAAIC,QAAQ,GAAG,KAAf;;AAEA,MAAId,KAAK,KAAK1E,UAAU,CAACyF,WAAzB,EAAsC;AACpCF,IAAAA,QAAQ,GAAG,IAAX;AACD;;AACD,MAAItC,KAAK,KAAK,CAACjD,UAAU,CAACyF,WAA1B,EAAuC;AACrCD,IAAAA,QAAQ,GAAG,IAAX;AACD;;AAED,MAAI5B,KAAJ;AACA,MAAIC,MAAJ;AACA,MAAIJ,YAAJ;AACA,MAAIC,YAAJ;AACA,MAAIgC,EAAJ;AACA,MAAIC,EAAE,GAAGjB,KAAK,GAAGzB,KAAjB;;AACA,MAAID,IAAI,GAAGgC,IAAX,EAAiB;AACfU,IAAAA,EAAE,GAAG1F,UAAU,CAAC4F,MAAX,GAAoB5C,IAApB,GAA2BgC,IAAhC;AACD,GAFD,MAEO;AACLU,IAAAA,EAAE,GAAGV,IAAI,GAAGhC,IAAZ;AACD;;AAEDY,EAAAA,KAAK,GAAGxD,IAAI,CAACyF,IAAL,CAAUH,EAAE,GAAGR,WAAf,IAA8B,CAAtC;AACArB,EAAAA,MAAM,GAAGzD,IAAI,CAACyF,IAAL,CAAUF,EAAE,GAAGT,WAAf,IAA8B,CAAvC;AACAzB,EAAAA,YAAY,GAAGiC,EAAE,IAAI9B,KAAK,GAAG,CAAZ,CAAjB;AACAF,EAAAA,YAAY,GAAGiC,EAAE,IAAI9B,MAAM,GAAG,CAAb,CAAjB;AAEA,MAAI5C,QAAQ,GAAGf,SAAS,CAAC4F,SAAV,CAAoB5E,SAApB,EAA+BmE,cAA/B,CAAf;AACA,MAAI1B,MAAM,GAAGzD,SAAS,CAACyD,MAAV,CAAiBzC,SAAjB,EAA4BkC,aAA5B,CAAb;;AACA,MAAII,QAAQ,KAAK,CAAb,IAAkB2B,UAAU,KAAK,CAArC,EAAwC;AACtC,QAAIxB,MAAM,CAAC9B,SAAP,GAAmBZ,QAAQ,CAACY,SAAhC,EAA2C;AACzC8B,MAAAA,MAAM,CAAC9B,SAAP,IAAoB7B,UAAU,CAAC4F,MAA/B;AACD;;AACDvC,IAAAA,eAAe,GAAGC,IAAI,CAACU,OAAL,CAAaL,MAAb,EAAqBN,eAArB,CAAlB;AACD;;AAED,MAAI/B,QAAQ,GAAGoC,YAAf;AACA,MAAI3B,QAAQ,GAAG0B,YAAf;AACA,MAAI3B,QAAQ,GAAG,GAAf;AACA,MAAIP,QAAQ,GAAG,GAAf;AAEA,MAAIJ,iBAAiB,GAAGjB,SAAS,CAAC6F,KAAV,CAAgB7E,SAAhB,EAA2BkE,wBAA3B,CAAxB;AAEA,MAAI3E,eAAe,GAAG;AACpBa,IAAAA,QAAQ,EAAEA,QADU;AAEpBQ,IAAAA,QAAQ,EAAEA,QAFU;AAGpBC,IAAAA,QAAQ,EAAEA,QAHU;AAIpBR,IAAAA,QAAQ,EAAEA,QAJU;AAKpBN,IAAAA,QAAQ,EAAEA,QALU;AAMpBE,IAAAA,iBAAiB,EAAEA,iBANC;AAOpByC,IAAAA,KAAK,EAAEA,KAPa;AAQpBC,IAAAA,MAAM,EAAEA,MARY;AASpB0B,IAAAA,QAAQ,EAAEA,QATU;AAUpBC,IAAAA,QAAQ,EAAEA;AAVU,GAAtB;;AAaA,MAAIhC,QAAQ,KAAK,CAAjB,EAAoB;AAClB,QAAIwC,eAAe,GAAGzC,kBAAkB,CACtCtC,QADsC,EAEtCuC,QAFsC,EAGtCC,YAHsC,EAItCC,YAJsC,EAKtCC,MALsC,EAMtCC,KANsC,EAOtCC,MAPsC,CAAxC;AASAa,IAAAA,KAAK,GAAGsB,eAAe,CAACtB,KAAxB;AACAzB,IAAAA,KAAK,GAAG+C,eAAe,CAAC/C,KAAxB;AACA+B,IAAAA,IAAI,GAAGgB,eAAe,CAAChB,IAAvB;AACAhC,IAAAA,IAAI,GAAGgD,eAAe,CAAChD,IAAvB,CAbkB,CAelB;;AACA,QACE0B,KAAK,GAAG,CAAC1E,UAAU,CAACyF,WAApB,IACAf,KAAK,GAAG1E,UAAU,CAACyF,WADnB,IAEAxC,KAAK,GAAG,CAACjD,UAAU,CAACyF,WAFpB,IAGAxC,KAAK,GAAGjD,UAAU,CAACyF,WAJrB,EAKE;AACA,YAAM,IAAI3F,cAAJ,CACJ,gFADI,CAAN;AAGD,KAzBiB,CA0BlB;;;AAEAW,IAAAA,eAAe,CAACa,QAAhB,GAA2B0E,eAAe,CAAC1E,QAA3C;AACAb,IAAAA,eAAe,CAACqB,QAAhB,GAA2BkE,eAAe,CAAClE,QAA3C;AACArB,IAAAA,eAAe,CAACsB,QAAhB,GAA2BiE,eAAe,CAACjE,QAA3C;AACAtB,IAAAA,eAAe,CAACc,QAAhB,GAA2ByE,eAAe,CAACzE,QAA3C;AAEAJ,IAAAA,iBAAiB,CAACuD,KAAlB,GAA0BA,KAA1B;AACAvD,IAAAA,iBAAiB,CAAC8B,KAAlB,GAA0BA,KAA1B;AACA9B,IAAAA,iBAAiB,CAAC6D,IAAlB,GAAyBA,IAAzB;AACA7D,IAAAA,iBAAiB,CAAC6B,IAAlB,GAAyBA,IAAzB;AACD;;AAED,MAAImC,UAAU,KAAK,CAAnB,EAAsB;AACpB3B,IAAAA,QAAQ,GAAGA,QAAQ,GAAG2B,UAAtB;AACA,QAAI5C,UAAU,GAAGrC,SAAS,CAAC4F,SAAV,CAAoB3E,iBAApB,EAAuCmE,gBAAvC,CAAjB;AAEA,QAAIW,iBAAiB,GAAG1C,kBAAkB,CACxChB,UADwC,EAExCiB,QAFwC,EAGxCC,YAHwC,EAIxCC,YAJwC,EAKxCC,MALwC,EAMxCC,KANwC,EAOxCC,MAPwC,CAA1C;AAUApD,IAAAA,eAAe,CAAC+B,UAAhB,GAA6ByD,iBAAiB,CAAC3E,QAA/C;AACAb,IAAAA,eAAe,CAACkC,UAAhB,GAA6BsD,iBAAiB,CAAClE,QAA/C;AACAtB,IAAAA,eAAe,CAACiC,UAAhB,GAA6BuD,iBAAiB,CAACnE,QAA/C;AACArB,IAAAA,eAAe,CAACgC,UAAhB,GAA6BwD,iBAAiB,CAAC1E,QAA/C;AACAd,IAAAA,eAAe,CAAC8B,UAAhB,GAA6BA,UAA7B;AACA9B,IAAAA,eAAe,CAACmC,MAAhB,GAAyBqD,iBAAiB,CAACjD,IAA3C;AACAvC,IAAAA,eAAe,CAACqC,OAAhB,GAA0BmD,iBAAiB,CAAChD,KAA5C;AACD;;AAED,SAAOxC,eAAP;AACD,CArID;;AAsIA,eAAeF,wBAAf","sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix2 from \"./Matrix2.js\";\nimport Rectangle from \"./Rectangle.js\";\n\nvar cos = Math.cos;\nvar sin = Math.sin;\nvar sqrt = Math.sqrt;\n\n/**\n * @private\n */\nvar RectangleGeometryLibrary = {};\n\n/**\n * @private\n */\nRectangleGeometryLibrary.computePosition = function (\n  computedOptions,\n  ellipsoid,\n  computeST,\n  row,\n  col,\n  position,\n  st\n) {\n  var radiiSquared = ellipsoid.radiiSquared;\n  var nwCorner = computedOptions.nwCorner;\n  var rectangle = computedOptions.boundingRectangle;\n\n  var stLatitude =\n    nwCorner.latitude -\n    computedOptions.granYCos * row +\n    col * computedOptions.granXSin;\n  var cosLatitude = cos(stLatitude);\n  var nZ = sin(stLatitude);\n  var kZ = radiiSquared.z * nZ;\n\n  var stLongitude =\n    nwCorner.longitude +\n    row * computedOptions.granYSin +\n    col * computedOptions.granXCos;\n  var nX = cosLatitude * cos(stLongitude);\n  var nY = cosLatitude * sin(stLongitude);\n\n  var kX = radiiSquared.x * nX;\n  var kY = radiiSquared.y * nY;\n\n  var gamma = sqrt(kX * nX + kY * nY + kZ * nZ);\n\n  position.x = kX / gamma;\n  position.y = kY / gamma;\n  position.z = kZ / gamma;\n\n  if (computeST) {\n    var stNwCorner = computedOptions.stNwCorner;\n    if (defined(stNwCorner)) {\n      stLatitude =\n        stNwCorner.latitude -\n        computedOptions.stGranYCos * row +\n        col * computedOptions.stGranXSin;\n      stLongitude =\n        stNwCorner.longitude +\n        row * computedOptions.stGranYSin +\n        col * computedOptions.stGranXCos;\n\n      st.x = (stLongitude - computedOptions.stWest) * computedOptions.lonScalar;\n      st.y = (stLatitude - computedOptions.stSouth) * computedOptions.latScalar;\n    } else {\n      st.x = (stLongitude - rectangle.west) * computedOptions.lonScalar;\n      st.y = (stLatitude - rectangle.south) * computedOptions.latScalar;\n    }\n  }\n};\n\nvar rotationMatrixScratch = new Matrix2();\nvar nwCartesian = new Cartesian3();\nvar centerScratch = new Cartographic();\nvar centerCartesian = new Cartesian3();\nvar proj = new GeographicProjection();\n\nfunction getRotationOptions(\n  nwCorner,\n  rotation,\n  granularityX,\n  granularityY,\n  center,\n  width,\n  height\n) {\n  var cosRotation = Math.cos(rotation);\n  var granYCos = granularityY * cosRotation;\n  var granXCos = granularityX * cosRotation;\n\n  var sinRotation = Math.sin(rotation);\n  var granYSin = granularityY * sinRotation;\n  var granXSin = granularityX * sinRotation;\n\n  nwCartesian = proj.project(nwCorner, nwCartesian);\n\n  nwCartesian = Cartesian3.subtract(nwCartesian, centerCartesian, nwCartesian);\n  var rotationMatrix = Matrix2.fromRotation(rotation, rotationMatrixScratch);\n  nwCartesian = Matrix2.multiplyByVector(\n    rotationMatrix,\n    nwCartesian,\n    nwCartesian\n  );\n  nwCartesian = Cartesian3.add(nwCartesian, centerCartesian, nwCartesian);\n  nwCorner = proj.unproject(nwCartesian, nwCorner);\n\n  width -= 1;\n  height -= 1;\n\n  var latitude = nwCorner.latitude;\n  var latitude0 = latitude + width * granXSin;\n  var latitude1 = latitude - granYCos * height;\n  var latitude2 = latitude - granYCos * height + width * granXSin;\n\n  var north = Math.max(latitude, latitude0, latitude1, latitude2);\n  var south = Math.min(latitude, latitude0, latitude1, latitude2);\n\n  var longitude = nwCorner.longitude;\n  var longitude0 = longitude + width * granXCos;\n  var longitude1 = longitude + height * granYSin;\n  var longitude2 = longitude + height * granYSin + width * granXCos;\n\n  var east = Math.max(longitude, longitude0, longitude1, longitude2);\n  var west = Math.min(longitude, longitude0, longitude1, longitude2);\n\n  return {\n    north: north,\n    south: south,\n    east: east,\n    west: west,\n    granYCos: granYCos,\n    granYSin: granYSin,\n    granXCos: granXCos,\n    granXSin: granXSin,\n    nwCorner: nwCorner,\n  };\n}\n\n/**\n * @private\n */\nRectangleGeometryLibrary.computeOptions = function (\n  rectangle,\n  granularity,\n  rotation,\n  stRotation,\n  boundingRectangleScratch,\n  nwCornerResult,\n  stNwCornerResult\n) {\n  var east = rectangle.east;\n  var west = rectangle.west;\n  var north = rectangle.north;\n  var south = rectangle.south;\n\n  var northCap = false;\n  var southCap = false;\n\n  if (north === CesiumMath.PI_OVER_TWO) {\n    northCap = true;\n  }\n  if (south === -CesiumMath.PI_OVER_TWO) {\n    southCap = true;\n  }\n\n  var width;\n  var height;\n  var granularityX;\n  var granularityY;\n  var dx;\n  var dy = north - south;\n  if (west > east) {\n    dx = CesiumMath.TWO_PI - west + east;\n  } else {\n    dx = east - west;\n  }\n\n  width = Math.ceil(dx / granularity) + 1;\n  height = Math.ceil(dy / granularity) + 1;\n  granularityX = dx / (width - 1);\n  granularityY = dy / (height - 1);\n\n  var nwCorner = Rectangle.northwest(rectangle, nwCornerResult);\n  var center = Rectangle.center(rectangle, centerScratch);\n  if (rotation !== 0 || stRotation !== 0) {\n    if (center.longitude < nwCorner.longitude) {\n      center.longitude += CesiumMath.TWO_PI;\n    }\n    centerCartesian = proj.project(center, centerCartesian);\n  }\n\n  var granYCos = granularityY;\n  var granXCos = granularityX;\n  var granYSin = 0.0;\n  var granXSin = 0.0;\n\n  var boundingRectangle = Rectangle.clone(rectangle, boundingRectangleScratch);\n\n  var computedOptions = {\n    granYCos: granYCos,\n    granYSin: granYSin,\n    granXCos: granXCos,\n    granXSin: granXSin,\n    nwCorner: nwCorner,\n    boundingRectangle: boundingRectangle,\n    width: width,\n    height: height,\n    northCap: northCap,\n    southCap: southCap,\n  };\n\n  if (rotation !== 0) {\n    var rotationOptions = getRotationOptions(\n      nwCorner,\n      rotation,\n      granularityX,\n      granularityY,\n      center,\n      width,\n      height\n    );\n    north = rotationOptions.north;\n    south = rotationOptions.south;\n    east = rotationOptions.east;\n    west = rotationOptions.west;\n\n    //>>includeStart('debug', pragmas.debug);\n    if (\n      north < -CesiumMath.PI_OVER_TWO ||\n      north > CesiumMath.PI_OVER_TWO ||\n      south < -CesiumMath.PI_OVER_TWO ||\n      south > CesiumMath.PI_OVER_TWO\n    ) {\n      throw new DeveloperError(\n        \"Rotated rectangle is invalid.  It crosses over either the north or south pole.\"\n      );\n    }\n    //>>includeEnd('debug')\n\n    computedOptions.granYCos = rotationOptions.granYCos;\n    computedOptions.granYSin = rotationOptions.granYSin;\n    computedOptions.granXCos = rotationOptions.granXCos;\n    computedOptions.granXSin = rotationOptions.granXSin;\n\n    boundingRectangle.north = north;\n    boundingRectangle.south = south;\n    boundingRectangle.east = east;\n    boundingRectangle.west = west;\n  }\n\n  if (stRotation !== 0) {\n    rotation = rotation - stRotation;\n    var stNwCorner = Rectangle.northwest(boundingRectangle, stNwCornerResult);\n\n    var stRotationOptions = getRotationOptions(\n      stNwCorner,\n      rotation,\n      granularityX,\n      granularityY,\n      center,\n      width,\n      height\n    );\n\n    computedOptions.stGranYCos = stRotationOptions.granYCos;\n    computedOptions.stGranXCos = stRotationOptions.granXCos;\n    computedOptions.stGranYSin = stRotationOptions.granYSin;\n    computedOptions.stGranXSin = stRotationOptions.granXSin;\n    computedOptions.stNwCorner = stNwCorner;\n    computedOptions.stWest = stRotationOptions.west;\n    computedOptions.stSouth = stRotationOptions.south;\n  }\n\n  return computedOptions;\n};\nexport default RectangleGeometryLibrary;\n"]},"metadata":{},"sourceType":"module"}