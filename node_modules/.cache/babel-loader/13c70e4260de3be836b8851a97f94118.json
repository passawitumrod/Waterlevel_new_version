{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport BufferUsage from \"./BufferUsage.js\";\n/**\n * @private\n */\n\nfunction Buffer(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);\n\n  Check.defined(\"options.context\", options.context);\n\n  if (!defined(options.typedArray) && !defined(options.sizeInBytes)) {\n    throw new DeveloperError(\"Either options.sizeInBytes or options.typedArray is required.\");\n  }\n\n  if (defined(options.typedArray) && defined(options.sizeInBytes)) {\n    throw new DeveloperError(\"Cannot pass in both options.sizeInBytes and options.typedArray.\");\n  }\n\n  if (defined(options.typedArray)) {\n    Check.typeOf.object(\"options.typedArray\", options.typedArray);\n    Check.typeOf.number(\"options.typedArray.byteLength\", options.typedArray.byteLength);\n  }\n\n  if (!BufferUsage.validate(options.usage)) {\n    throw new DeveloperError(\"usage is invalid.\");\n  } //>>includeEnd('debug');\n\n\n  var gl = options.context._gl;\n  var bufferTarget = options.bufferTarget;\n  var typedArray = options.typedArray;\n  var sizeInBytes = options.sizeInBytes;\n  var usage = options.usage;\n  var hasArray = defined(typedArray);\n\n  if (hasArray) {\n    sizeInBytes = typedArray.byteLength;\n  } //>>includeStart('debug', pragmas.debug);\n\n\n  Check.typeOf.number.greaterThan(\"sizeInBytes\", sizeInBytes, 0); //>>includeEnd('debug');\n\n  var buffer = gl.createBuffer();\n  gl.bindBuffer(bufferTarget, buffer);\n  gl.bufferData(bufferTarget, hasArray ? typedArray : sizeInBytes, usage);\n  gl.bindBuffer(bufferTarget, null);\n  this._gl = gl;\n  this._webgl2 = options.context._webgl2;\n  this._bufferTarget = bufferTarget;\n  this._sizeInBytes = sizeInBytes;\n  this._usage = usage;\n  this._buffer = buffer;\n  this.vertexArrayDestroyable = true;\n}\n/**\n * Creates a vertex buffer, which contains untyped vertex data in GPU-controlled memory.\n * <br /><br />\n * A vertex array defines the actual makeup of a vertex, e.g., positions, normals, texture coordinates,\n * etc., by interpreting the raw data in one or more vertex buffers.\n *\n * @param {Object} options An object containing the following properties:\n * @param {Context} options.context The context in which to create the buffer\n * @param {ArrayBufferView} [options.typedArray] A typed array containing the data to copy to the buffer.\n * @param {Number} [options.sizeInBytes] A <code>Number</code> defining the size of the buffer in bytes. Required if options.typedArray is not given.\n * @param {BufferUsage} options.usage Specifies the expected usage pattern of the buffer. On some GL implementations, this can significantly affect performance. See {@link BufferUsage}.\n * @returns {VertexBuffer} The vertex buffer, ready to be attached to a vertex array.\n *\n * @exception {DeveloperError} Must specify either <options.typedArray> or <options.sizeInBytes>, but not both.\n * @exception {DeveloperError} The buffer size must be greater than zero.\n * @exception {DeveloperError} Invalid <code>usage</code>.\n *\n *\n * @example\n * // Example 1. Create a dynamic vertex buffer 16 bytes in size.\n * var buffer = Buffer.createVertexBuffer({\n *     context : context,\n *     sizeInBytes : 16,\n *     usage : BufferUsage.DYNAMIC_DRAW\n * });\n *\n * @example\n * // Example 2. Create a dynamic vertex buffer from three floating-point values.\n * // The data copied to the vertex buffer is considered raw bytes until it is\n * // interpreted as vertices using a vertex array.\n * var positionBuffer = buffer.createVertexBuffer({\n *     context : context,\n *     typedArray : new Float32Array([0, 0, 0]),\n *     usage : BufferUsage.STATIC_DRAW\n * });\n *\n * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGenBuffer.xml|glGenBuffer}\n * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glBindBuffer.xml|glBindBuffer} with <code>ARRAY_BUFFER</code>\n * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glBufferData.xml|glBufferData} with <code>ARRAY_BUFFER</code>\n */\n\n\nBuffer.createVertexBuffer = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context); //>>includeEnd('debug');\n\n  return new Buffer({\n    context: options.context,\n    bufferTarget: WebGLConstants.ARRAY_BUFFER,\n    typedArray: options.typedArray,\n    sizeInBytes: options.sizeInBytes,\n    usage: options.usage\n  });\n};\n/**\n * Creates an index buffer, which contains typed indices in GPU-controlled memory.\n * <br /><br />\n * An index buffer can be attached to a vertex array to select vertices for rendering.\n * <code>Context.draw</code> can render using the entire index buffer or a subset\n * of the index buffer defined by an offset and count.\n *\n * @param {Object} options An object containing the following properties:\n * @param {Context} options.context The context in which to create the buffer\n * @param {ArrayBufferView} [options.typedArray] A typed array containing the data to copy to the buffer.\n * @param {Number} [options.sizeInBytes] A <code>Number</code> defining the size of the buffer in bytes. Required if options.typedArray is not given.\n * @param {BufferUsage} options.usage Specifies the expected usage pattern of the buffer. On some GL implementations, this can significantly affect performance. See {@link BufferUsage}.\n * @param {IndexDatatype} options.indexDatatype The datatype of indices in the buffer.\n * @returns {IndexBuffer} The index buffer, ready to be attached to a vertex array.\n *\n * @exception {DeveloperError} Must specify either <options.typedArray> or <options.sizeInBytes>, but not both.\n * @exception {DeveloperError} IndexDatatype.UNSIGNED_INT requires OES_element_index_uint, which is not supported on this system. Check context.elementIndexUint.\n * @exception {DeveloperError} The size in bytes must be greater than zero.\n * @exception {DeveloperError} Invalid <code>usage</code>.\n * @exception {DeveloperError} Invalid <code>indexDatatype</code>.\n *\n *\n * @example\n * // Example 1. Create a stream index buffer of unsigned shorts that is\n * // 16 bytes in size.\n * var buffer = Buffer.createIndexBuffer({\n *     context : context,\n *     sizeInBytes : 16,\n *     usage : BufferUsage.STREAM_DRAW,\n *     indexDatatype : IndexDatatype.UNSIGNED_SHORT\n * });\n *\n * @example\n * // Example 2. Create a static index buffer containing three unsigned shorts.\n * var buffer = Buffer.createIndexBuffer({\n *     context : context,\n *     typedArray : new Uint16Array([0, 1, 2]),\n *     usage : BufferUsage.STATIC_DRAW,\n *     indexDatatype : IndexDatatype.UNSIGNED_SHORT\n * });\n *\n * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGenBuffer.xml|glGenBuffer}\n * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glBindBuffer.xml|glBindBuffer} with <code>ELEMENT_ARRAY_BUFFER</code>\n * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glBufferData.xml|glBufferData} with <code>ELEMENT_ARRAY_BUFFER</code>\n */\n\n\nBuffer.createIndexBuffer = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n\n  if (!IndexDatatype.validate(options.indexDatatype)) {\n    throw new DeveloperError(\"Invalid indexDatatype.\");\n  }\n\n  if (options.indexDatatype === IndexDatatype.UNSIGNED_INT && !options.context.elementIndexUint) {\n    throw new DeveloperError(\"IndexDatatype.UNSIGNED_INT requires OES_element_index_uint, which is not supported on this system.  Check context.elementIndexUint.\");\n  } //>>includeEnd('debug');\n\n\n  var context = options.context;\n  var indexDatatype = options.indexDatatype;\n  var bytesPerIndex = IndexDatatype.getSizeInBytes(indexDatatype);\n  var buffer = new Buffer({\n    context: context,\n    bufferTarget: WebGLConstants.ELEMENT_ARRAY_BUFFER,\n    typedArray: options.typedArray,\n    sizeInBytes: options.sizeInBytes,\n    usage: options.usage\n  });\n  var numberOfIndices = buffer.sizeInBytes / bytesPerIndex;\n  Object.defineProperties(buffer, {\n    indexDatatype: {\n      get: function () {\n        return indexDatatype;\n      }\n    },\n    bytesPerIndex: {\n      get: function () {\n        return bytesPerIndex;\n      }\n    },\n    numberOfIndices: {\n      get: function () {\n        return numberOfIndices;\n      }\n    }\n  });\n  return buffer;\n};\n\nObject.defineProperties(Buffer.prototype, {\n  sizeInBytes: {\n    get: function () {\n      return this._sizeInBytes;\n    }\n  },\n  usage: {\n    get: function () {\n      return this._usage;\n    }\n  }\n});\n\nBuffer.prototype._getBuffer = function () {\n  return this._buffer;\n};\n\nBuffer.prototype.copyFromArrayView = function (arrayView, offsetInBytes) {\n  offsetInBytes = defaultValue(offsetInBytes, 0); //>>includeStart('debug', pragmas.debug);\n\n  Check.defined(\"arrayView\", arrayView);\n  Check.typeOf.number.lessThanOrEquals(\"offsetInBytes + arrayView.byteLength\", offsetInBytes + arrayView.byteLength, this._sizeInBytes); //>>includeEnd('debug');\n\n  var gl = this._gl;\n  var target = this._bufferTarget;\n  gl.bindBuffer(target, this._buffer);\n  gl.bufferSubData(target, offsetInBytes, arrayView);\n  gl.bindBuffer(target, null);\n};\n\nBuffer.prototype.copyFromBuffer = function (readBuffer, readOffset, writeOffset, sizeInBytes) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._webgl2) {\n    throw new DeveloperError(\"A WebGL 2 context is required.\");\n  }\n\n  if (!defined(readBuffer)) {\n    throw new DeveloperError(\"readBuffer must be defined.\");\n  }\n\n  if (!defined(sizeInBytes) || sizeInBytes <= 0) {\n    throw new DeveloperError(\"sizeInBytes must be defined and be greater than zero.\");\n  }\n\n  if (!defined(readOffset) || readOffset < 0 || readOffset + sizeInBytes > readBuffer._sizeInBytes) {\n    throw new DeveloperError(\"readOffset must be greater than or equal to zero and readOffset + sizeInBytes must be less than of equal to readBuffer.sizeInBytes.\");\n  }\n\n  if (!defined(writeOffset) || writeOffset < 0 || writeOffset + sizeInBytes > this._sizeInBytes) {\n    throw new DeveloperError(\"writeOffset must be greater than or equal to zero and writeOffset + sizeInBytes must be less than of equal to this.sizeInBytes.\");\n  }\n\n  if (this._buffer === readBuffer._buffer && (writeOffset >= readOffset && writeOffset < readOffset + sizeInBytes || readOffset > writeOffset && readOffset < writeOffset + sizeInBytes)) {\n    throw new DeveloperError(\"When readBuffer is equal to this, the ranges [readOffset + sizeInBytes) and [writeOffset, writeOffset + sizeInBytes) must not overlap.\");\n  }\n\n  if (this._bufferTarget === WebGLConstants.ELEMENT_ARRAY_BUFFER && readBuffer._bufferTarget !== WebGLConstants.ELEMENT_ARRAY_BUFFER || this._bufferTarget !== WebGLConstants.ELEMENT_ARRAY_BUFFER && readBuffer._bufferTarget === WebGLConstants.ELEMENT_ARRAY_BUFFER) {\n    throw new DeveloperError(\"Can not copy an index buffer into another buffer type.\");\n  } //>>includeEnd('debug');\n\n\n  var readTarget = WebGLConstants.COPY_READ_BUFFER;\n  var writeTarget = WebGLConstants.COPY_WRITE_BUFFER;\n  var gl = this._gl;\n  gl.bindBuffer(writeTarget, this._buffer);\n  gl.bindBuffer(readTarget, readBuffer._buffer);\n  gl.copyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, sizeInBytes);\n  gl.bindBuffer(writeTarget, null);\n  gl.bindBuffer(readTarget, null);\n};\n\nBuffer.prototype.getBufferData = function (arrayView, sourceOffset, destinationOffset, length) {\n  sourceOffset = defaultValue(sourceOffset, 0);\n  destinationOffset = defaultValue(destinationOffset, 0); //>>includeStart('debug', pragmas.debug);\n\n  if (!this._webgl2) {\n    throw new DeveloperError(\"A WebGL 2 context is required.\");\n  }\n\n  if (!defined(arrayView)) {\n    throw new DeveloperError(\"arrayView is required.\");\n  }\n\n  var copyLength;\n  var elementSize;\n  var arrayLength = arrayView.byteLength;\n\n  if (!defined(length)) {\n    if (defined(arrayLength)) {\n      copyLength = arrayLength - destinationOffset;\n      elementSize = 1;\n    } else {\n      arrayLength = arrayView.length;\n      copyLength = arrayLength - destinationOffset;\n      elementSize = arrayView.BYTES_PER_ELEMENT;\n    }\n  } else {\n    copyLength = length;\n\n    if (defined(arrayLength)) {\n      elementSize = 1;\n    } else {\n      arrayLength = arrayView.length;\n      elementSize = arrayView.BYTES_PER_ELEMENT;\n    }\n  }\n\n  if (destinationOffset < 0 || destinationOffset > arrayLength) {\n    throw new DeveloperError(\"destinationOffset must be greater than zero and less than the arrayView length.\");\n  }\n\n  if (destinationOffset + copyLength > arrayLength) {\n    throw new DeveloperError(\"destinationOffset + length must be less than or equal to the arrayViewLength.\");\n  }\n\n  if (sourceOffset < 0 || sourceOffset > this._sizeInBytes) {\n    throw new DeveloperError(\"sourceOffset must be greater than zero and less than the buffers size.\");\n  }\n\n  if (sourceOffset + copyLength * elementSize > this._sizeInBytes) {\n    throw new DeveloperError(\"sourceOffset + length must be less than the buffers size.\");\n  } //>>includeEnd('debug');\n\n\n  var gl = this._gl;\n  var target = WebGLConstants.COPY_READ_BUFFER;\n  gl.bindBuffer(target, this._buffer);\n  gl.getBufferSubData(target, sourceOffset, arrayView, destinationOffset, length);\n  gl.bindBuffer(target, null);\n};\n\nBuffer.prototype.isDestroyed = function () {\n  return false;\n};\n\nBuffer.prototype.destroy = function () {\n  this._gl.deleteBuffer(this._buffer);\n\n  return destroyObject(this);\n};\n\nexport default Buffer;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Renderer/Buffer.js"],"names":["Check","defaultValue","defined","destroyObject","DeveloperError","IndexDatatype","WebGLConstants","BufferUsage","Buffer","options","EMPTY_OBJECT","context","typedArray","sizeInBytes","typeOf","object","number","byteLength","validate","usage","gl","_gl","bufferTarget","hasArray","greaterThan","buffer","createBuffer","bindBuffer","bufferData","_webgl2","_bufferTarget","_sizeInBytes","_usage","_buffer","vertexArrayDestroyable","createVertexBuffer","ARRAY_BUFFER","createIndexBuffer","indexDatatype","UNSIGNED_INT","elementIndexUint","bytesPerIndex","getSizeInBytes","ELEMENT_ARRAY_BUFFER","numberOfIndices","Object","defineProperties","get","prototype","_getBuffer","copyFromArrayView","arrayView","offsetInBytes","lessThanOrEquals","target","bufferSubData","copyFromBuffer","readBuffer","readOffset","writeOffset","readTarget","COPY_READ_BUFFER","writeTarget","COPY_WRITE_BUFFER","copyBufferSubData","getBufferData","sourceOffset","destinationOffset","length","copyLength","elementSize","arrayLength","BYTES_PER_ELEMENT","getBufferSubData","isDestroyed","destroy","deleteBuffer"],"mappings":"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","sourcesContent":["import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport BufferUsage from \"./BufferUsage.js\";\n\n/**\n * @private\n */\nfunction Buffer(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n\n  if (!defined(options.typedArray) && !defined(options.sizeInBytes)) {\n    throw new DeveloperError(\n      \"Either options.sizeInBytes or options.typedArray is required.\"\n    );\n  }\n\n  if (defined(options.typedArray) && defined(options.sizeInBytes)) {\n    throw new DeveloperError(\n      \"Cannot pass in both options.sizeInBytes and options.typedArray.\"\n    );\n  }\n\n  if (defined(options.typedArray)) {\n    Check.typeOf.object(\"options.typedArray\", options.typedArray);\n    Check.typeOf.number(\n      \"options.typedArray.byteLength\",\n      options.typedArray.byteLength\n    );\n  }\n\n  if (!BufferUsage.validate(options.usage)) {\n    throw new DeveloperError(\"usage is invalid.\");\n  }\n  //>>includeEnd('debug');\n\n  var gl = options.context._gl;\n  var bufferTarget = options.bufferTarget;\n  var typedArray = options.typedArray;\n  var sizeInBytes = options.sizeInBytes;\n  var usage = options.usage;\n  var hasArray = defined(typedArray);\n\n  if (hasArray) {\n    sizeInBytes = typedArray.byteLength;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThan(\"sizeInBytes\", sizeInBytes, 0);\n  //>>includeEnd('debug');\n\n  var buffer = gl.createBuffer();\n  gl.bindBuffer(bufferTarget, buffer);\n  gl.bufferData(bufferTarget, hasArray ? typedArray : sizeInBytes, usage);\n  gl.bindBuffer(bufferTarget, null);\n\n  this._gl = gl;\n  this._webgl2 = options.context._webgl2;\n  this._bufferTarget = bufferTarget;\n  this._sizeInBytes = sizeInBytes;\n  this._usage = usage;\n  this._buffer = buffer;\n  this.vertexArrayDestroyable = true;\n}\n\n/**\n * Creates a vertex buffer, which contains untyped vertex data in GPU-controlled memory.\n * <br /><br />\n * A vertex array defines the actual makeup of a vertex, e.g., positions, normals, texture coordinates,\n * etc., by interpreting the raw data in one or more vertex buffers.\n *\n * @param {Object} options An object containing the following properties:\n * @param {Context} options.context The context in which to create the buffer\n * @param {ArrayBufferView} [options.typedArray] A typed array containing the data to copy to the buffer.\n * @param {Number} [options.sizeInBytes] A <code>Number</code> defining the size of the buffer in bytes. Required if options.typedArray is not given.\n * @param {BufferUsage} options.usage Specifies the expected usage pattern of the buffer. On some GL implementations, this can significantly affect performance. See {@link BufferUsage}.\n * @returns {VertexBuffer} The vertex buffer, ready to be attached to a vertex array.\n *\n * @exception {DeveloperError} Must specify either <options.typedArray> or <options.sizeInBytes>, but not both.\n * @exception {DeveloperError} The buffer size must be greater than zero.\n * @exception {DeveloperError} Invalid <code>usage</code>.\n *\n *\n * @example\n * // Example 1. Create a dynamic vertex buffer 16 bytes in size.\n * var buffer = Buffer.createVertexBuffer({\n *     context : context,\n *     sizeInBytes : 16,\n *     usage : BufferUsage.DYNAMIC_DRAW\n * });\n *\n * @example\n * // Example 2. Create a dynamic vertex buffer from three floating-point values.\n * // The data copied to the vertex buffer is considered raw bytes until it is\n * // interpreted as vertices using a vertex array.\n * var positionBuffer = buffer.createVertexBuffer({\n *     context : context,\n *     typedArray : new Float32Array([0, 0, 0]),\n *     usage : BufferUsage.STATIC_DRAW\n * });\n *\n * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGenBuffer.xml|glGenBuffer}\n * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glBindBuffer.xml|glBindBuffer} with <code>ARRAY_BUFFER</code>\n * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glBufferData.xml|glBufferData} with <code>ARRAY_BUFFER</code>\n */\nBuffer.createVertexBuffer = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n  //>>includeEnd('debug');\n\n  return new Buffer({\n    context: options.context,\n    bufferTarget: WebGLConstants.ARRAY_BUFFER,\n    typedArray: options.typedArray,\n    sizeInBytes: options.sizeInBytes,\n    usage: options.usage,\n  });\n};\n\n/**\n * Creates an index buffer, which contains typed indices in GPU-controlled memory.\n * <br /><br />\n * An index buffer can be attached to a vertex array to select vertices for rendering.\n * <code>Context.draw</code> can render using the entire index buffer or a subset\n * of the index buffer defined by an offset and count.\n *\n * @param {Object} options An object containing the following properties:\n * @param {Context} options.context The context in which to create the buffer\n * @param {ArrayBufferView} [options.typedArray] A typed array containing the data to copy to the buffer.\n * @param {Number} [options.sizeInBytes] A <code>Number</code> defining the size of the buffer in bytes. Required if options.typedArray is not given.\n * @param {BufferUsage} options.usage Specifies the expected usage pattern of the buffer. On some GL implementations, this can significantly affect performance. See {@link BufferUsage}.\n * @param {IndexDatatype} options.indexDatatype The datatype of indices in the buffer.\n * @returns {IndexBuffer} The index buffer, ready to be attached to a vertex array.\n *\n * @exception {DeveloperError} Must specify either <options.typedArray> or <options.sizeInBytes>, but not both.\n * @exception {DeveloperError} IndexDatatype.UNSIGNED_INT requires OES_element_index_uint, which is not supported on this system. Check context.elementIndexUint.\n * @exception {DeveloperError} The size in bytes must be greater than zero.\n * @exception {DeveloperError} Invalid <code>usage</code>.\n * @exception {DeveloperError} Invalid <code>indexDatatype</code>.\n *\n *\n * @example\n * // Example 1. Create a stream index buffer of unsigned shorts that is\n * // 16 bytes in size.\n * var buffer = Buffer.createIndexBuffer({\n *     context : context,\n *     sizeInBytes : 16,\n *     usage : BufferUsage.STREAM_DRAW,\n *     indexDatatype : IndexDatatype.UNSIGNED_SHORT\n * });\n *\n * @example\n * // Example 2. Create a static index buffer containing three unsigned shorts.\n * var buffer = Buffer.createIndexBuffer({\n *     context : context,\n *     typedArray : new Uint16Array([0, 1, 2]),\n *     usage : BufferUsage.STATIC_DRAW,\n *     indexDatatype : IndexDatatype.UNSIGNED_SHORT\n * });\n *\n * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGenBuffer.xml|glGenBuffer}\n * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glBindBuffer.xml|glBindBuffer} with <code>ELEMENT_ARRAY_BUFFER</code>\n * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glBufferData.xml|glBufferData} with <code>ELEMENT_ARRAY_BUFFER</code>\n */\nBuffer.createIndexBuffer = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n\n  if (!IndexDatatype.validate(options.indexDatatype)) {\n    throw new DeveloperError(\"Invalid indexDatatype.\");\n  }\n\n  if (\n    options.indexDatatype === IndexDatatype.UNSIGNED_INT &&\n    !options.context.elementIndexUint\n  ) {\n    throw new DeveloperError(\n      \"IndexDatatype.UNSIGNED_INT requires OES_element_index_uint, which is not supported on this system.  Check context.elementIndexUint.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var context = options.context;\n  var indexDatatype = options.indexDatatype;\n\n  var bytesPerIndex = IndexDatatype.getSizeInBytes(indexDatatype);\n  var buffer = new Buffer({\n    context: context,\n    bufferTarget: WebGLConstants.ELEMENT_ARRAY_BUFFER,\n    typedArray: options.typedArray,\n    sizeInBytes: options.sizeInBytes,\n    usage: options.usage,\n  });\n\n  var numberOfIndices = buffer.sizeInBytes / bytesPerIndex;\n\n  Object.defineProperties(buffer, {\n    indexDatatype: {\n      get: function () {\n        return indexDatatype;\n      },\n    },\n    bytesPerIndex: {\n      get: function () {\n        return bytesPerIndex;\n      },\n    },\n    numberOfIndices: {\n      get: function () {\n        return numberOfIndices;\n      },\n    },\n  });\n\n  return buffer;\n};\n\nObject.defineProperties(Buffer.prototype, {\n  sizeInBytes: {\n    get: function () {\n      return this._sizeInBytes;\n    },\n  },\n\n  usage: {\n    get: function () {\n      return this._usage;\n    },\n  },\n});\n\nBuffer.prototype._getBuffer = function () {\n  return this._buffer;\n};\n\nBuffer.prototype.copyFromArrayView = function (arrayView, offsetInBytes) {\n  offsetInBytes = defaultValue(offsetInBytes, 0);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"arrayView\", arrayView);\n  Check.typeOf.number.lessThanOrEquals(\n    \"offsetInBytes + arrayView.byteLength\",\n    offsetInBytes + arrayView.byteLength,\n    this._sizeInBytes\n  );\n  //>>includeEnd('debug');\n\n  var gl = this._gl;\n  var target = this._bufferTarget;\n  gl.bindBuffer(target, this._buffer);\n  gl.bufferSubData(target, offsetInBytes, arrayView);\n  gl.bindBuffer(target, null);\n};\n\nBuffer.prototype.copyFromBuffer = function (\n  readBuffer,\n  readOffset,\n  writeOffset,\n  sizeInBytes\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._webgl2) {\n    throw new DeveloperError(\"A WebGL 2 context is required.\");\n  }\n  if (!defined(readBuffer)) {\n    throw new DeveloperError(\"readBuffer must be defined.\");\n  }\n  if (!defined(sizeInBytes) || sizeInBytes <= 0) {\n    throw new DeveloperError(\n      \"sizeInBytes must be defined and be greater than zero.\"\n    );\n  }\n  if (\n    !defined(readOffset) ||\n    readOffset < 0 ||\n    readOffset + sizeInBytes > readBuffer._sizeInBytes\n  ) {\n    throw new DeveloperError(\n      \"readOffset must be greater than or equal to zero and readOffset + sizeInBytes must be less than of equal to readBuffer.sizeInBytes.\"\n    );\n  }\n  if (\n    !defined(writeOffset) ||\n    writeOffset < 0 ||\n    writeOffset + sizeInBytes > this._sizeInBytes\n  ) {\n    throw new DeveloperError(\n      \"writeOffset must be greater than or equal to zero and writeOffset + sizeInBytes must be less than of equal to this.sizeInBytes.\"\n    );\n  }\n  if (\n    this._buffer === readBuffer._buffer &&\n    ((writeOffset >= readOffset && writeOffset < readOffset + sizeInBytes) ||\n      (readOffset > writeOffset && readOffset < writeOffset + sizeInBytes))\n  ) {\n    throw new DeveloperError(\n      \"When readBuffer is equal to this, the ranges [readOffset + sizeInBytes) and [writeOffset, writeOffset + sizeInBytes) must not overlap.\"\n    );\n  }\n  if (\n    (this._bufferTarget === WebGLConstants.ELEMENT_ARRAY_BUFFER &&\n      readBuffer._bufferTarget !== WebGLConstants.ELEMENT_ARRAY_BUFFER) ||\n    (this._bufferTarget !== WebGLConstants.ELEMENT_ARRAY_BUFFER &&\n      readBuffer._bufferTarget === WebGLConstants.ELEMENT_ARRAY_BUFFER)\n  ) {\n    throw new DeveloperError(\n      \"Can not copy an index buffer into another buffer type.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var readTarget = WebGLConstants.COPY_READ_BUFFER;\n  var writeTarget = WebGLConstants.COPY_WRITE_BUFFER;\n\n  var gl = this._gl;\n  gl.bindBuffer(writeTarget, this._buffer);\n  gl.bindBuffer(readTarget, readBuffer._buffer);\n  gl.copyBufferSubData(\n    readTarget,\n    writeTarget,\n    readOffset,\n    writeOffset,\n    sizeInBytes\n  );\n  gl.bindBuffer(writeTarget, null);\n  gl.bindBuffer(readTarget, null);\n};\n\nBuffer.prototype.getBufferData = function (\n  arrayView,\n  sourceOffset,\n  destinationOffset,\n  length\n) {\n  sourceOffset = defaultValue(sourceOffset, 0);\n  destinationOffset = defaultValue(destinationOffset, 0);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._webgl2) {\n    throw new DeveloperError(\"A WebGL 2 context is required.\");\n  }\n  if (!defined(arrayView)) {\n    throw new DeveloperError(\"arrayView is required.\");\n  }\n\n  var copyLength;\n  var elementSize;\n  var arrayLength = arrayView.byteLength;\n  if (!defined(length)) {\n    if (defined(arrayLength)) {\n      copyLength = arrayLength - destinationOffset;\n      elementSize = 1;\n    } else {\n      arrayLength = arrayView.length;\n      copyLength = arrayLength - destinationOffset;\n      elementSize = arrayView.BYTES_PER_ELEMENT;\n    }\n  } else {\n    copyLength = length;\n    if (defined(arrayLength)) {\n      elementSize = 1;\n    } else {\n      arrayLength = arrayView.length;\n      elementSize = arrayView.BYTES_PER_ELEMENT;\n    }\n  }\n\n  if (destinationOffset < 0 || destinationOffset > arrayLength) {\n    throw new DeveloperError(\n      \"destinationOffset must be greater than zero and less than the arrayView length.\"\n    );\n  }\n  if (destinationOffset + copyLength > arrayLength) {\n    throw new DeveloperError(\n      \"destinationOffset + length must be less than or equal to the arrayViewLength.\"\n    );\n  }\n  if (sourceOffset < 0 || sourceOffset > this._sizeInBytes) {\n    throw new DeveloperError(\n      \"sourceOffset must be greater than zero and less than the buffers size.\"\n    );\n  }\n  if (sourceOffset + copyLength * elementSize > this._sizeInBytes) {\n    throw new DeveloperError(\n      \"sourceOffset + length must be less than the buffers size.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var gl = this._gl;\n  var target = WebGLConstants.COPY_READ_BUFFER;\n  gl.bindBuffer(target, this._buffer);\n  gl.getBufferSubData(\n    target,\n    sourceOffset,\n    arrayView,\n    destinationOffset,\n    length\n  );\n  gl.bindBuffer(target, null);\n};\n\nBuffer.prototype.isDestroyed = function () {\n  return false;\n};\n\nBuffer.prototype.destroy = function () {\n  this._gl.deleteBuffer(this._buffer);\n  return destroyObject(this);\n};\nexport default Buffer;\n"]},"metadata":{},"sourceType":"module"}