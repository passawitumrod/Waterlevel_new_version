{"ast":null,"code":"/*\n* https://github.com/dy/bitmap-sdf\n* Calculate SDF for image/bitmap/bw data\n* This project is a fork of MapBox's TinySDF that works directly on an input Canvas instead of generating the glyphs themselves.\n*/\nvar INF = 1e20;\n\nfunction clamp(value, min, max) {\n  return min < max ? value < min ? min : value > max ? max : value : value < max ? max : value > min ? min : value;\n}\n\nfunction calcSDF(src, options) {\n  if (!options) options = {};\n  var cutoff = options.cutoff == null ? 0.25 : options.cutoff;\n  var radius = options.radius == null ? 8 : options.radius;\n  var channel = options.channel || 0;\n  var w, h, size, data, intData, stride, ctx, canvas, imgData, i, l; // handle image container\n\n  if (ArrayBuffer.isView(src) || Array.isArray(src)) {\n    if (!options.width || !options.height) throw Error('For raw data width and height should be provided by options');\n    w = options.width, h = options.height;\n    data = src;\n    if (!options.stride) stride = Math.floor(src.length / w / h);else stride = options.stride;\n  } else {\n    if (window.HTMLCanvasElement && src instanceof window.HTMLCanvasElement) {\n      canvas = src;\n      ctx = canvas.getContext('2d');\n      w = canvas.width, h = canvas.height;\n      imgData = ctx.getImageData(0, 0, w, h);\n      data = imgData.data;\n      stride = 4;\n    } else if (window.CanvasRenderingContext2D && src instanceof window.CanvasRenderingContext2D) {\n      canvas = src.canvas;\n      ctx = src;\n      w = canvas.width, h = canvas.height;\n      imgData = ctx.getImageData(0, 0, w, h);\n      data = imgData.data;\n      stride = 4;\n    } else if (window.ImageData && src instanceof window.ImageData) {\n      imgData = src;\n      w = src.width, h = src.height;\n      data = imgData.data;\n      stride = 4;\n    }\n  }\n\n  size = Math.max(w, h); //convert int data to floats\n\n  if (window.Uint8ClampedArray && data instanceof window.Uint8ClampedArray || window.Uint8Array && data instanceof window.Uint8Array) {\n    intData = data;\n    data = Array(w * h);\n\n    for (i = 0, l = intData.length; i < l; i++) {\n      data[i] = intData[i * stride + channel] / 255;\n    }\n  } else {\n    if (stride !== 1) throw Error('Raw data can have only 1 value per pixel');\n  } // temporary arrays for the distance transform\n\n\n  var gridOuter = Array(w * h);\n  var gridInner = Array(w * h);\n  var f = Array(size);\n  var d = Array(size);\n  var z = Array(size + 1);\n  var v = Array(size);\n\n  for (i = 0, l = w * h; i < l; i++) {\n    var a = data[i];\n    gridOuter[i] = a === 1 ? 0 : a === 0 ? INF : Math.pow(Math.max(0, 0.5 - a), 2);\n    gridInner[i] = a === 1 ? INF : a === 0 ? 0 : Math.pow(Math.max(0, a - 0.5), 2);\n  }\n\n  edt(gridOuter, w, h, f, d, v, z);\n  edt(gridInner, w, h, f, d, v, z);\n  var dist = window.Float32Array ? new Float32Array(w * h) : new Array(w * h);\n\n  for (i = 0, l = w * h; i < l; i++) {\n    dist[i] = clamp(1 - ((gridOuter[i] - gridInner[i]) / radius + cutoff), 0, 1);\n  }\n\n  return dist;\n} // 2D Euclidean distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/dt/\n\n\nfunction edt(data, width, height, f, d, v, z) {\n  for (var x = 0; x < width; x++) {\n    for (var y = 0; y < height; y++) {\n      f[y] = data[y * width + x];\n    }\n\n    edt1d(f, d, v, z, height);\n\n    for (y = 0; y < height; y++) {\n      data[y * width + x] = d[y];\n    }\n  }\n\n  for (y = 0; y < height; y++) {\n    for (x = 0; x < width; x++) {\n      f[x] = data[y * width + x];\n    }\n\n    edt1d(f, d, v, z, width);\n\n    for (x = 0; x < width; x++) {\n      data[y * width + x] = Math.sqrt(d[x]);\n    }\n  }\n} // 1D squared distance transform\n\n\nfunction edt1d(f, d, v, z, n) {\n  v[0] = 0;\n  z[0] = -INF;\n  z[1] = +INF;\n\n  for (var q = 1, k = 0; q < n; q++) {\n    var s = (f[q] + q * q - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k]);\n\n    while (s <= z[k]) {\n      k--;\n      s = (f[q] + q * q - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k]);\n    }\n\n    k++;\n    v[k] = q;\n    z[k] = s;\n    z[k + 1] = +INF;\n  }\n\n  for (q = 0, k = 0; q < n; q++) {\n    while (z[k + 1] < q) k++;\n\n    d[q] = (q - v[k]) * (q - v[k]) + f[v[k]];\n  }\n}\n\nexport default calcSDF;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/ThirdParty/bitmap-sdf.js"],"names":["INF","clamp","value","min","max","calcSDF","src","options","cutoff","radius","channel","w","h","size","data","intData","stride","ctx","canvas","imgData","i","l","ArrayBuffer","isView","Array","isArray","width","height","Error","Math","floor","length","window","HTMLCanvasElement","getContext","getImageData","CanvasRenderingContext2D","ImageData","Uint8ClampedArray","Uint8Array","gridOuter","gridInner","f","d","z","v","a","pow","edt","dist","Float32Array","x","y","edt1d","sqrt","n","q","k","s"],"mappings":"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","sourcesContent":["/*\n* https://github.com/dy/bitmap-sdf\n* Calculate SDF for image/bitmap/bw data\n* This project is a fork of MapBox's TinySDF that works directly on an input Canvas instead of generating the glyphs themselves.\n*/\n\n    var INF = 1e20;\n\n    function clamp(value, min, max) {\n        return min < max\n            ? (value < min ? min : value > max ? max : value)\n            : (value < max ? max : value > min ? min : value)\n    }\n\n    function calcSDF(src, options) {\n        if (!options) options = {}\n\n        var cutoff = options.cutoff == null ? 0.25 : options.cutoff\n        var radius = options.radius == null ? 8 : options.radius\n        var channel = options.channel || 0\n        var w, h, size, data, intData, stride, ctx, canvas, imgData, i, l\n\n        // handle image container\n        if (ArrayBuffer.isView(src) || Array.isArray(src)) {\n            if (!options.width || !options.height) throw Error('For raw data width and height should be provided by options')\n            w = options.width, h = options.height\n            data = src\n\n            if (!options.stride) stride = Math.floor(src.length / w / h)\n            else stride = options.stride\n        }\n        else {\n            if (window.HTMLCanvasElement && src instanceof window.HTMLCanvasElement) {\n                canvas = src\n                ctx = canvas.getContext('2d')\n                w = canvas.width, h = canvas.height\n                imgData = ctx.getImageData(0, 0, w, h)\n                data = imgData.data\n                stride = 4\n            }\n            else if (window.CanvasRenderingContext2D && src instanceof window.CanvasRenderingContext2D) {\n                canvas = src.canvas\n                ctx = src\n                w = canvas.width, h = canvas.height\n                imgData = ctx.getImageData(0, 0, w, h)\n                data = imgData.data\n                stride = 4\n            }\n            else if (window.ImageData && src instanceof window.ImageData) {\n                imgData = src\n                w = src.width, h = src.height\n                data = imgData.data\n                stride = 4\n            }\n        }\n\n        size = Math.max(w, h)\n\n        //convert int data to floats\n        if ((window.Uint8ClampedArray && data instanceof window.Uint8ClampedArray) || (window.Uint8Array && data instanceof window.Uint8Array)) {\n            intData = data\n            data = Array(w * h)\n\n            for (i = 0, l = intData.length; i < l; i++) {\n                data[i] = intData[i * stride + channel] / 255\n            }\n        }\n        else {\n            if (stride !== 1) throw Error('Raw data can have only 1 value per pixel')\n        }\n\n        // temporary arrays for the distance transform\n        var gridOuter = Array(w * h)\n        var gridInner = Array(w * h)\n        var f = Array(size)\n        var d = Array(size)\n        var z = Array(size + 1)\n        var v = Array(size)\n\n        for (i = 0, l = w * h; i < l; i++) {\n            var a = data[i]\n            gridOuter[i] = a === 1 ? 0 : a === 0 ? INF : Math.pow(Math.max(0, 0.5 - a), 2)\n            gridInner[i] = a === 1 ? INF : a === 0 ? 0 : Math.pow(Math.max(0, a - 0.5), 2)\n        }\n\n        edt(gridOuter, w, h, f, d, v, z)\n        edt(gridInner, w, h, f, d, v, z)\n\n        var dist = window.Float32Array ? new Float32Array(w * h) : new Array(w * h)\n\n        for (i = 0, l = w * h; i < l; i++) {\n            dist[i] = clamp(1 - ((gridOuter[i] - gridInner[i]) / radius + cutoff), 0, 1)\n        }\n\n        return dist\n    }\n\n    // 2D Euclidean distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/dt/\n    function edt(data, width, height, f, d, v, z) {\n        for (var x = 0; x < width; x++) {\n            for (var y = 0; y < height; y++) {\n                f[y] = data[y * width + x]\n            }\n            edt1d(f, d, v, z, height)\n            for (y = 0; y < height; y++) {\n                data[y * width + x] = d[y]\n            }\n        }\n        for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n                f[x] = data[y * width + x]\n            }\n            edt1d(f, d, v, z, width)\n            for (x = 0; x < width; x++) {\n                data[y * width + x] = Math.sqrt(d[x])\n            }\n        }\n    }\n\n    // 1D squared distance transform\n    function edt1d(f, d, v, z, n) {\n        v[0] = 0;\n        z[0] = -INF\n        z[1] = +INF\n\n        for (var q = 1, k = 0; q < n; q++) {\n            var s = ((f[q] + q * q) - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k])\n            while (s <= z[k]) {\n                k--\n                s = ((f[q] + q * q) - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k])\n            }\n            k++\n            v[k] = q\n            z[k] = s\n            z[k + 1] = +INF\n        }\n\n        for (q = 0, k = 0; q < n; q++) {\n            while (z[k + 1] < q) k++\n            d[q] = (q - v[k]) * (q - v[k]) + f[v[k]]\n        }\n    }\n\n    export default calcSDF;\n"]},"metadata":{},"sourceType":"module"}