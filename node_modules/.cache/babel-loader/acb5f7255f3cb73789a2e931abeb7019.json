{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Event from \"../Core/Event.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport Property from \"./Property.js\";\nvar scratchPosition = new Cartesian3();\nvar scratchCarto = new Cartographic();\n/**\n * @private\n */\n\nfunction TerrainOffsetProperty(scene, positionProperty, heightReferenceProperty, extrudedHeightReferenceProperty) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"scene\", scene);\n  Check.defined(\"positionProperty\", positionProperty); //>>includeEnd('debug');\n\n  this._scene = scene;\n  this._heightReference = heightReferenceProperty;\n  this._extrudedHeightReference = extrudedHeightReferenceProperty;\n  this._positionProperty = positionProperty;\n  this._position = new Cartesian3();\n  this._cartographicPosition = new Cartographic();\n  this._normal = new Cartesian3();\n  this._definitionChanged = new Event();\n  this._terrainHeight = 0;\n  this._removeCallbackFunc = undefined;\n  this._removeEventListener = undefined;\n  this._removeModeListener = undefined;\n  var that = this;\n\n  if (defined(scene.globe)) {\n    this._removeEventListener = scene.terrainProviderChanged.addEventListener(function () {\n      that._updateClamping();\n    });\n    this._removeModeListener = scene.morphComplete.addEventListener(function () {\n      that._updateClamping();\n    });\n  }\n\n  if (positionProperty.isConstant) {\n    var position = positionProperty.getValue(Iso8601.MINIMUM_VALUE, scratchPosition);\n\n    if (!defined(position) || Cartesian3.equals(position, Cartesian3.ZERO) || !defined(scene.globe)) {\n      return;\n    }\n\n    this._position = Cartesian3.clone(position, this._position);\n\n    this._updateClamping();\n\n    this._normal = scene.globe.ellipsoid.geodeticSurfaceNormal(position, this._normal);\n  }\n}\n\nObject.defineProperties(TerrainOffsetProperty.prototype, {\n  /**\n   * Gets a value indicating if this property is constant.\n   * @memberof TerrainOffsetProperty.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  isConstant: {\n    get: function () {\n      return false;\n    }\n  },\n\n  /**\n   * Gets the event that is raised whenever the definition of this property changes.\n   * @memberof TerrainOffsetProperty.prototype\n   *\n   * @type {Event}\n   * @readonly\n   */\n  definitionChanged: {\n    get: function () {\n      return this._definitionChanged;\n    }\n  }\n});\n/**\n * @private\n */\n\nTerrainOffsetProperty.prototype._updateClamping = function () {\n  if (defined(this._removeCallbackFunc)) {\n    this._removeCallbackFunc();\n  }\n\n  var scene = this._scene;\n  var globe = scene.globe;\n  var position = this._position;\n\n  if (!defined(globe) || Cartesian3.equals(position, Cartesian3.ZERO)) {\n    this._terrainHeight = 0;\n    return;\n  }\n\n  var ellipsoid = globe.ellipsoid;\n  var surface = globe._surface;\n  var that = this;\n  var cartographicPosition = ellipsoid.cartesianToCartographic(position, this._cartographicPosition);\n  var height = globe.getHeight(cartographicPosition);\n\n  if (defined(height)) {\n    this._terrainHeight = height;\n  } else {\n    this._terrainHeight = 0;\n  }\n\n  function updateFunction(clampedPosition) {\n    if (scene.mode === SceneMode.SCENE3D) {\n      var carto = ellipsoid.cartesianToCartographic(clampedPosition, scratchCarto);\n      that._terrainHeight = carto.height;\n    } else {\n      that._terrainHeight = clampedPosition.x;\n    }\n\n    that.definitionChanged.raiseEvent();\n  }\n\n  this._removeCallbackFunc = surface.updateHeight(cartographicPosition, updateFunction);\n};\n/**\n * Gets the height relative to the terrain based on the positions.\n *\n * @returns {Cartesian3} The offset\n */\n\n\nTerrainOffsetProperty.prototype.getValue = function (time, result) {\n  var heightReference = Property.getValueOrDefault(this._heightReference, time, HeightReference.NONE);\n  var extrudedHeightReference = Property.getValueOrDefault(this._extrudedHeightReference, time, HeightReference.NONE);\n\n  if (heightReference === HeightReference.NONE && extrudedHeightReference !== HeightReference.RELATIVE_TO_GROUND) {\n    this._position = Cartesian3.clone(Cartesian3.ZERO, this._position);\n    return Cartesian3.clone(Cartesian3.ZERO, result);\n  }\n\n  if (this._positionProperty.isConstant) {\n    return Cartesian3.multiplyByScalar(this._normal, this._terrainHeight, result);\n  }\n\n  var scene = this._scene;\n\n  var position = this._positionProperty.getValue(time, scratchPosition);\n\n  if (!defined(position) || Cartesian3.equals(position, Cartesian3.ZERO) || !defined(scene.globe)) {\n    return Cartesian3.clone(Cartesian3.ZERO, result);\n  }\n\n  if (Cartesian3.equalsEpsilon(this._position, position, CesiumMath.EPSILON10)) {\n    return Cartesian3.multiplyByScalar(this._normal, this._terrainHeight, result);\n  }\n\n  this._position = Cartesian3.clone(position, this._position);\n\n  this._updateClamping();\n\n  var normal = scene.globe.ellipsoid.geodeticSurfaceNormal(position, this._normal);\n  return Cartesian3.multiplyByScalar(normal, this._terrainHeight, result);\n};\n\nTerrainOffsetProperty.prototype.isDestroyed = function () {\n  return false;\n};\n\nTerrainOffsetProperty.prototype.destroy = function () {\n  if (defined(this._removeEventListener)) {\n    this._removeEventListener();\n  }\n\n  if (defined(this._removeModeListener)) {\n    this._removeModeListener();\n  }\n\n  if (defined(this._removeCallbackFunc)) {\n    this._removeCallbackFunc();\n  }\n\n  return destroyObject(this);\n};\n/**\n * A function which creates one or more providers.\n * @callback TerrainOffsetProperty~PositionFunction\n * @param {JulianDate} time The clock time at which to retrieve the position\n * @param {Cartesian3} result The result position\n * @returns {Cartesian3} The position at which to do the terrain height check\n */\n\n\nexport default TerrainOffsetProperty;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/DataSources/TerrainOffsetProperty.js"],"names":["Cartesian3","Cartographic","Check","defined","destroyObject","Event","Iso8601","CesiumMath","HeightReference","SceneMode","Property","scratchPosition","scratchCarto","TerrainOffsetProperty","scene","positionProperty","heightReferenceProperty","extrudedHeightReferenceProperty","_scene","_heightReference","_extrudedHeightReference","_positionProperty","_position","_cartographicPosition","_normal","_definitionChanged","_terrainHeight","_removeCallbackFunc","undefined","_removeEventListener","_removeModeListener","that","globe","terrainProviderChanged","addEventListener","_updateClamping","morphComplete","isConstant","position","getValue","MINIMUM_VALUE","equals","ZERO","clone","ellipsoid","geodeticSurfaceNormal","Object","defineProperties","prototype","get","definitionChanged","surface","_surface","cartographicPosition","cartesianToCartographic","height","getHeight","updateFunction","clampedPosition","mode","SCENE3D","carto","x","raiseEvent","updateHeight","time","result","heightReference","getValueOrDefault","NONE","extrudedHeightReference","RELATIVE_TO_GROUND","multiplyByScalar","equalsEpsilon","EPSILON10","normal","isDestroyed","destroy"],"mappings":"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","sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Event from \"../Core/Event.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport Property from \"./Property.js\";\n\nvar scratchPosition = new Cartesian3();\nvar scratchCarto = new Cartographic();\n\n/**\n * @private\n */\nfunction TerrainOffsetProperty(\n  scene,\n  positionProperty,\n  heightReferenceProperty,\n  extrudedHeightReferenceProperty\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"scene\", scene);\n  Check.defined(\"positionProperty\", positionProperty);\n  //>>includeEnd('debug');\n\n  this._scene = scene;\n  this._heightReference = heightReferenceProperty;\n  this._extrudedHeightReference = extrudedHeightReferenceProperty;\n  this._positionProperty = positionProperty;\n\n  this._position = new Cartesian3();\n  this._cartographicPosition = new Cartographic();\n  this._normal = new Cartesian3();\n\n  this._definitionChanged = new Event();\n  this._terrainHeight = 0;\n  this._removeCallbackFunc = undefined;\n  this._removeEventListener = undefined;\n  this._removeModeListener = undefined;\n\n  var that = this;\n  if (defined(scene.globe)) {\n    this._removeEventListener = scene.terrainProviderChanged.addEventListener(\n      function () {\n        that._updateClamping();\n      }\n    );\n    this._removeModeListener = scene.morphComplete.addEventListener(\n      function () {\n        that._updateClamping();\n      }\n    );\n  }\n\n  if (positionProperty.isConstant) {\n    var position = positionProperty.getValue(\n      Iso8601.MINIMUM_VALUE,\n      scratchPosition\n    );\n    if (\n      !defined(position) ||\n      Cartesian3.equals(position, Cartesian3.ZERO) ||\n      !defined(scene.globe)\n    ) {\n      return;\n    }\n    this._position = Cartesian3.clone(position, this._position);\n\n    this._updateClamping();\n\n    this._normal = scene.globe.ellipsoid.geodeticSurfaceNormal(\n      position,\n      this._normal\n    );\n  }\n}\n\nObject.defineProperties(TerrainOffsetProperty.prototype, {\n  /**\n   * Gets a value indicating if this property is constant.\n   * @memberof TerrainOffsetProperty.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  isConstant: {\n    get: function () {\n      return false;\n    },\n  },\n  /**\n   * Gets the event that is raised whenever the definition of this property changes.\n   * @memberof TerrainOffsetProperty.prototype\n   *\n   * @type {Event}\n   * @readonly\n   */\n  definitionChanged: {\n    get: function () {\n      return this._definitionChanged;\n    },\n  },\n});\n\n/**\n * @private\n */\nTerrainOffsetProperty.prototype._updateClamping = function () {\n  if (defined(this._removeCallbackFunc)) {\n    this._removeCallbackFunc();\n  }\n\n  var scene = this._scene;\n  var globe = scene.globe;\n  var position = this._position;\n\n  if (!defined(globe) || Cartesian3.equals(position, Cartesian3.ZERO)) {\n    this._terrainHeight = 0;\n    return;\n  }\n  var ellipsoid = globe.ellipsoid;\n  var surface = globe._surface;\n\n  var that = this;\n  var cartographicPosition = ellipsoid.cartesianToCartographic(\n    position,\n    this._cartographicPosition\n  );\n  var height = globe.getHeight(cartographicPosition);\n  if (defined(height)) {\n    this._terrainHeight = height;\n  } else {\n    this._terrainHeight = 0;\n  }\n\n  function updateFunction(clampedPosition) {\n    if (scene.mode === SceneMode.SCENE3D) {\n      var carto = ellipsoid.cartesianToCartographic(\n        clampedPosition,\n        scratchCarto\n      );\n      that._terrainHeight = carto.height;\n    } else {\n      that._terrainHeight = clampedPosition.x;\n    }\n    that.definitionChanged.raiseEvent();\n  }\n  this._removeCallbackFunc = surface.updateHeight(\n    cartographicPosition,\n    updateFunction\n  );\n};\n\n/**\n * Gets the height relative to the terrain based on the positions.\n *\n * @returns {Cartesian3} The offset\n */\nTerrainOffsetProperty.prototype.getValue = function (time, result) {\n  var heightReference = Property.getValueOrDefault(\n    this._heightReference,\n    time,\n    HeightReference.NONE\n  );\n  var extrudedHeightReference = Property.getValueOrDefault(\n    this._extrudedHeightReference,\n    time,\n    HeightReference.NONE\n  );\n\n  if (\n    heightReference === HeightReference.NONE &&\n    extrudedHeightReference !== HeightReference.RELATIVE_TO_GROUND\n  ) {\n    this._position = Cartesian3.clone(Cartesian3.ZERO, this._position);\n    return Cartesian3.clone(Cartesian3.ZERO, result);\n  }\n\n  if (this._positionProperty.isConstant) {\n    return Cartesian3.multiplyByScalar(\n      this._normal,\n      this._terrainHeight,\n      result\n    );\n  }\n\n  var scene = this._scene;\n  var position = this._positionProperty.getValue(time, scratchPosition);\n  if (\n    !defined(position) ||\n    Cartesian3.equals(position, Cartesian3.ZERO) ||\n    !defined(scene.globe)\n  ) {\n    return Cartesian3.clone(Cartesian3.ZERO, result);\n  }\n\n  if (\n    Cartesian3.equalsEpsilon(this._position, position, CesiumMath.EPSILON10)\n  ) {\n    return Cartesian3.multiplyByScalar(\n      this._normal,\n      this._terrainHeight,\n      result\n    );\n  }\n\n  this._position = Cartesian3.clone(position, this._position);\n\n  this._updateClamping();\n\n  var normal = scene.globe.ellipsoid.geodeticSurfaceNormal(\n    position,\n    this._normal\n  );\n  return Cartesian3.multiplyByScalar(normal, this._terrainHeight, result);\n};\n\nTerrainOffsetProperty.prototype.isDestroyed = function () {\n  return false;\n};\n\nTerrainOffsetProperty.prototype.destroy = function () {\n  if (defined(this._removeEventListener)) {\n    this._removeEventListener();\n  }\n  if (defined(this._removeModeListener)) {\n    this._removeModeListener();\n  }\n  if (defined(this._removeCallbackFunc)) {\n    this._removeCallbackFunc();\n  }\n  return destroyObject(this);\n};\n\n/**\n * A function which creates one or more providers.\n * @callback TerrainOffsetProperty~PositionFunction\n * @param {JulianDate} time The clock time at which to retrieve the position\n * @param {Cartesian3} result The result position\n * @returns {Cartesian3} The position at which to do the terrain height check\n */\nexport default TerrainOffsetProperty;\n"]},"metadata":{},"sourceType":"module"}