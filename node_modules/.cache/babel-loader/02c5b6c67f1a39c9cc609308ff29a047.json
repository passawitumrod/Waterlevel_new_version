{"ast":null,"code":"import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport CornerType from \"./CornerType.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Transforms from \"./Transforms.js\";\nvar scratch2Array = [new Cartesian3(), new Cartesian3()];\nvar scratchCartesian1 = new Cartesian3();\nvar scratchCartesian2 = new Cartesian3();\nvar scratchCartesian3 = new Cartesian3();\nvar scratchCartesian4 = new Cartesian3();\nvar scratchCartesian5 = new Cartesian3();\nvar scratchCartesian6 = new Cartesian3();\nvar scratchCartesian7 = new Cartesian3();\nvar scratchCartesian8 = new Cartesian3();\nvar scratchCartesian9 = new Cartesian3();\nvar scratch1 = new Cartesian3();\nvar scratch2 = new Cartesian3();\n/**\n * @private\n */\n\nvar PolylineVolumeGeometryLibrary = {};\nvar cartographic = new Cartographic();\n\nfunction scaleToSurface(positions, ellipsoid) {\n  var heights = new Array(positions.length);\n\n  for (var i = 0; i < positions.length; i++) {\n    var pos = positions[i];\n    cartographic = ellipsoid.cartesianToCartographic(pos, cartographic);\n    heights[i] = cartographic.height;\n    positions[i] = ellipsoid.scaleToGeodeticSurface(pos, pos);\n  }\n\n  return heights;\n}\n\nfunction subdivideHeights(points, h0, h1, granularity) {\n  var p0 = points[0];\n  var p1 = points[1];\n  var angleBetween = Cartesian3.angleBetween(p0, p1);\n  var numPoints = Math.ceil(angleBetween / granularity);\n  var heights = new Array(numPoints);\n  var i;\n\n  if (h0 === h1) {\n    for (i = 0; i < numPoints; i++) {\n      heights[i] = h0;\n    }\n\n    heights.push(h1);\n    return heights;\n  }\n\n  var dHeight = h1 - h0;\n  var heightPerVertex = dHeight / numPoints;\n\n  for (i = 1; i < numPoints; i++) {\n    var h = h0 + i * heightPerVertex;\n    heights[i] = h;\n  }\n\n  heights[0] = h0;\n  heights.push(h1);\n  return heights;\n}\n\nvar nextScratch = new Cartesian3();\nvar prevScratch = new Cartesian3();\n\nfunction computeRotationAngle(start, end, position, ellipsoid) {\n  var tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);\n  var next = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, start, nextScratch), nextScratch);\n  var prev = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, end, prevScratch), prevScratch);\n  var angle = Cartesian2.angleBetween(next, prev);\n  return prev.x * next.y - prev.y * next.x >= 0.0 ? -angle : angle;\n}\n\nvar negativeX = new Cartesian3(-1, 0, 0);\nvar transform = new Matrix4();\nvar translation = new Matrix4();\nvar rotationZ = new Matrix3();\nvar scaleMatrix = Matrix3.IDENTITY.clone();\nvar westScratch = new Cartesian3();\nvar finalPosScratch = new Cartesian4();\nvar heightCartesian = new Cartesian3();\n\nfunction addPosition(center, left, shape, finalPositions, ellipsoid, height, xScalar, repeat) {\n  var west = westScratch;\n  var finalPosition = finalPosScratch;\n  transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, transform);\n  west = Matrix4.multiplyByPointAsVector(transform, negativeX, west);\n  west = Cartesian3.normalize(west, west);\n  var angle = computeRotationAngle(west, left, center, ellipsoid);\n  rotationZ = Matrix3.fromRotationZ(angle, rotationZ);\n  heightCartesian.z = height;\n  transform = Matrix4.multiplyTransformation(transform, Matrix4.fromRotationTranslation(rotationZ, heightCartesian, translation), transform);\n  var scale = scaleMatrix;\n  scale[0] = xScalar;\n\n  for (var j = 0; j < repeat; j++) {\n    for (var i = 0; i < shape.length; i += 3) {\n      finalPosition = Cartesian3.fromArray(shape, i, finalPosition);\n      finalPosition = Matrix3.multiplyByVector(scale, finalPosition, finalPosition);\n      finalPosition = Matrix4.multiplyByPoint(transform, finalPosition, finalPosition);\n      finalPositions.push(finalPosition.x, finalPosition.y, finalPosition.z);\n    }\n  }\n\n  return finalPositions;\n}\n\nvar centerScratch = new Cartesian3();\n\nfunction addPositions(centers, left, shape, finalPositions, ellipsoid, heights, xScalar) {\n  for (var i = 0; i < centers.length; i += 3) {\n    var center = Cartesian3.fromArray(centers, i, centerScratch);\n    finalPositions = addPosition(center, left, shape, finalPositions, ellipsoid, heights[i / 3], xScalar, 1);\n  }\n\n  return finalPositions;\n}\n\nfunction convertShapeTo3DDuplicate(shape2D, boundingRectangle) {\n  //orientate 2D shape to XZ plane center at (0, 0, 0), duplicate points\n  var length = shape2D.length;\n  var shape = new Array(length * 6);\n  var index = 0;\n  var xOffset = boundingRectangle.x + boundingRectangle.width / 2;\n  var yOffset = boundingRectangle.y + boundingRectangle.height / 2;\n  var point = shape2D[0];\n  shape[index++] = point.x - xOffset;\n  shape[index++] = 0.0;\n  shape[index++] = point.y - yOffset;\n\n  for (var i = 1; i < length; i++) {\n    point = shape2D[i];\n    var x = point.x - xOffset;\n    var z = point.y - yOffset;\n    shape[index++] = x;\n    shape[index++] = 0.0;\n    shape[index++] = z;\n    shape[index++] = x;\n    shape[index++] = 0.0;\n    shape[index++] = z;\n  }\n\n  point = shape2D[0];\n  shape[index++] = point.x - xOffset;\n  shape[index++] = 0.0;\n  shape[index++] = point.y - yOffset;\n  return shape;\n}\n\nfunction convertShapeTo3D(shape2D, boundingRectangle) {\n  //orientate 2D shape to XZ plane center at (0, 0, 0)\n  var length = shape2D.length;\n  var shape = new Array(length * 3);\n  var index = 0;\n  var xOffset = boundingRectangle.x + boundingRectangle.width / 2;\n  var yOffset = boundingRectangle.y + boundingRectangle.height / 2;\n\n  for (var i = 0; i < length; i++) {\n    shape[index++] = shape2D[i].x - xOffset;\n    shape[index++] = 0;\n    shape[index++] = shape2D[i].y - yOffset;\n  }\n\n  return shape;\n}\n\nvar quaterion = new Quaternion();\nvar startPointScratch = new Cartesian3();\nvar rotMatrix = new Matrix3();\n\nfunction computeRoundCorner(pivot, startPoint, endPoint, cornerType, leftIsOutside, ellipsoid, finalPositions, shape, height, duplicatePoints) {\n  var angle = Cartesian3.angleBetween(Cartesian3.subtract(startPoint, pivot, scratch1), Cartesian3.subtract(endPoint, pivot, scratch2));\n  var granularity = cornerType === CornerType.BEVELED ? 0 : Math.ceil(angle / CesiumMath.toRadians(5));\n  var m;\n\n  if (leftIsOutside) {\n    m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(Cartesian3.negate(pivot, scratch1), angle / (granularity + 1), quaterion), rotMatrix);\n  } else {\n    m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(pivot, angle / (granularity + 1), quaterion), rotMatrix);\n  }\n\n  var left;\n  var surfacePoint;\n  startPoint = Cartesian3.clone(startPoint, startPointScratch);\n\n  if (granularity > 0) {\n    var repeat = duplicatePoints ? 2 : 1;\n\n    for (var i = 0; i < granularity; i++) {\n      startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\n      left = Cartesian3.subtract(startPoint, pivot, scratch1);\n      left = Cartesian3.normalize(left, left);\n\n      if (!leftIsOutside) {\n        left = Cartesian3.negate(left, left);\n      }\n\n      surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);\n      finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, repeat);\n    }\n  } else {\n    left = Cartesian3.subtract(startPoint, pivot, scratch1);\n    left = Cartesian3.normalize(left, left);\n\n    if (!leftIsOutside) {\n      left = Cartesian3.negate(left, left);\n    }\n\n    surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);\n    finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, 1);\n    endPoint = Cartesian3.clone(endPoint, startPointScratch);\n    left = Cartesian3.subtract(endPoint, pivot, scratch1);\n    left = Cartesian3.normalize(left, left);\n\n    if (!leftIsOutside) {\n      left = Cartesian3.negate(left, left);\n    }\n\n    surfacePoint = ellipsoid.scaleToGeodeticSurface(endPoint, scratch2);\n    finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, 1);\n  }\n\n  return finalPositions;\n}\n\nPolylineVolumeGeometryLibrary.removeDuplicatesFromShape = function (shapePositions) {\n  var length = shapePositions.length;\n  var cleanedPositions = [];\n\n  for (var i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {\n    var v0 = shapePositions[i0];\n    var v1 = shapePositions[i1];\n\n    if (!Cartesian2.equals(v0, v1)) {\n      cleanedPositions.push(v1); // Shallow copy!\n    }\n  }\n\n  return cleanedPositions;\n};\n\nPolylineVolumeGeometryLibrary.angleIsGreaterThanPi = function (forward, backward, position, ellipsoid) {\n  var tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);\n  var next = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, forward, nextScratch), nextScratch);\n  var prev = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, backward, prevScratch), prevScratch);\n  return prev.x * next.y - prev.y * next.x >= 0.0;\n};\n\nvar scratchForwardProjection = new Cartesian3();\nvar scratchBackwardProjection = new Cartesian3();\n\nPolylineVolumeGeometryLibrary.computePositions = function (positions, shape2D, boundingRectangle, geometry, duplicatePoints) {\n  var ellipsoid = geometry._ellipsoid;\n  var heights = scaleToSurface(positions, ellipsoid);\n  var granularity = geometry._granularity;\n  var cornerType = geometry._cornerType;\n  var shapeForSides = duplicatePoints ? convertShapeTo3DDuplicate(shape2D, boundingRectangle) : convertShapeTo3D(shape2D, boundingRectangle);\n  var shapeForEnds = duplicatePoints ? convertShapeTo3D(shape2D, boundingRectangle) : undefined;\n  var heightOffset = boundingRectangle.height / 2;\n  var width = boundingRectangle.width / 2;\n  var length = positions.length;\n  var finalPositions = [];\n  var ends = duplicatePoints ? [] : undefined;\n  var forward = scratchCartesian1;\n  var backward = scratchCartesian2;\n  var cornerDirection = scratchCartesian3;\n  var surfaceNormal = scratchCartesian4;\n  var pivot = scratchCartesian5;\n  var start = scratchCartesian6;\n  var end = scratchCartesian7;\n  var left = scratchCartesian8;\n  var previousPosition = scratchCartesian9;\n  var position = positions[0];\n  var nextPosition = positions[1];\n  surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);\n  forward = Cartesian3.subtract(nextPosition, position, forward);\n  forward = Cartesian3.normalize(forward, forward);\n  left = Cartesian3.cross(surfaceNormal, forward, left);\n  left = Cartesian3.normalize(left, left);\n  var h0 = heights[0];\n  var h1 = heights[1];\n\n  if (duplicatePoints) {\n    ends = addPosition(position, left, shapeForEnds, ends, ellipsoid, h0 + heightOffset, 1, 1);\n  }\n\n  previousPosition = Cartesian3.clone(position, previousPosition);\n  position = nextPosition;\n  backward = Cartesian3.negate(forward, backward);\n  var subdividedHeights;\n  var subdividedPositions;\n\n  for (var i = 1; i < length - 1; i++) {\n    var repeat = duplicatePoints ? 2 : 1;\n    nextPosition = positions[i + 1];\n    forward = Cartesian3.subtract(nextPosition, position, forward);\n    forward = Cartesian3.normalize(forward, forward);\n    cornerDirection = Cartesian3.add(forward, backward, cornerDirection);\n    cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n    surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);\n    var forwardProjection = Cartesian3.multiplyByScalar(surfaceNormal, Cartesian3.dot(forward, surfaceNormal), scratchForwardProjection);\n    Cartesian3.subtract(forward, forwardProjection, forwardProjection);\n    Cartesian3.normalize(forwardProjection, forwardProjection);\n    var backwardProjection = Cartesian3.multiplyByScalar(surfaceNormal, Cartesian3.dot(backward, surfaceNormal), scratchBackwardProjection);\n    Cartesian3.subtract(backward, backwardProjection, backwardProjection);\n    Cartesian3.normalize(backwardProjection, backwardProjection);\n    var doCorner = !CesiumMath.equalsEpsilon(Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)), 1.0, CesiumMath.EPSILON7);\n\n    if (doCorner) {\n      cornerDirection = Cartesian3.cross(cornerDirection, surfaceNormal, cornerDirection);\n      cornerDirection = Cartesian3.cross(surfaceNormal, cornerDirection, cornerDirection);\n      cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n      var scalar = 1 / Math.max(0.25, Cartesian3.magnitude(Cartesian3.cross(cornerDirection, backward, scratch1)));\n      var leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(forward, backward, position, ellipsoid);\n\n      if (leftIsOutside) {\n        pivot = Cartesian3.add(position, Cartesian3.multiplyByScalar(cornerDirection, scalar * width, cornerDirection), pivot);\n        start = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, width, start), start);\n        scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n        scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);\n        subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scratch2Array,\n          granularity: granularity,\n          ellipsoid: ellipsoid\n        });\n        finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);\n        left = Cartesian3.cross(surfaceNormal, forward, left);\n        left = Cartesian3.normalize(left, left);\n        end = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, width, end), end);\n\n        if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\n          computeRoundCorner(pivot, start, end, cornerType, leftIsOutside, ellipsoid, finalPositions, shapeForSides, h1 + heightOffset, duplicatePoints);\n        } else {\n          cornerDirection = Cartesian3.negate(cornerDirection, cornerDirection);\n          finalPositions = addPosition(position, cornerDirection, shapeForSides, finalPositions, ellipsoid, h1 + heightOffset, scalar, repeat);\n        }\n\n        previousPosition = Cartesian3.clone(end, previousPosition);\n      } else {\n        pivot = Cartesian3.add(position, Cartesian3.multiplyByScalar(cornerDirection, scalar * width, cornerDirection), pivot);\n        start = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, -width, start), start);\n        scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n        scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);\n        subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scratch2Array,\n          granularity: granularity,\n          ellipsoid: ellipsoid\n        });\n        finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);\n        left = Cartesian3.cross(surfaceNormal, forward, left);\n        left = Cartesian3.normalize(left, left);\n        end = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, -width, end), end);\n\n        if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\n          computeRoundCorner(pivot, start, end, cornerType, leftIsOutside, ellipsoid, finalPositions, shapeForSides, h1 + heightOffset, duplicatePoints);\n        } else {\n          finalPositions = addPosition(position, cornerDirection, shapeForSides, finalPositions, ellipsoid, h1 + heightOffset, scalar, repeat);\n        }\n\n        previousPosition = Cartesian3.clone(end, previousPosition);\n      }\n\n      backward = Cartesian3.negate(forward, backward);\n    } else {\n      finalPositions = addPosition(previousPosition, left, shapeForSides, finalPositions, ellipsoid, h0 + heightOffset, 1, 1);\n      previousPosition = position;\n    }\n\n    h0 = h1;\n    h1 = heights[i + 1];\n    position = nextPosition;\n  }\n\n  scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n  scratch2Array[1] = Cartesian3.clone(position, scratch2Array[1]);\n  subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);\n  subdividedPositions = PolylinePipeline.generateArc({\n    positions: scratch2Array,\n    granularity: granularity,\n    ellipsoid: ellipsoid\n  });\n  finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);\n\n  if (duplicatePoints) {\n    ends = addPosition(position, left, shapeForEnds, ends, ellipsoid, h1 + heightOffset, 1, 1);\n  }\n\n  length = finalPositions.length;\n  var posLength = duplicatePoints ? length + ends.length : length;\n  var combinedPositions = new Float64Array(posLength);\n  combinedPositions.set(finalPositions);\n\n  if (duplicatePoints) {\n    combinedPositions.set(ends, length);\n  }\n\n  return combinedPositions;\n};\n\nexport default PolylineVolumeGeometryLibrary;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/PolylineVolumeGeometryLibrary.js"],"names":["Cartesian2","Cartesian3","Cartesian4","Cartographic","CornerType","EllipsoidTangentPlane","CesiumMath","Matrix3","Matrix4","PolylinePipeline","Quaternion","Transforms","scratch2Array","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchCartesian4","scratchCartesian5","scratchCartesian6","scratchCartesian7","scratchCartesian8","scratchCartesian9","scratch1","scratch2","PolylineVolumeGeometryLibrary","cartographic","scaleToSurface","positions","ellipsoid","heights","Array","length","i","pos","cartesianToCartographic","height","scaleToGeodeticSurface","subdivideHeights","points","h0","h1","granularity","p0","p1","angleBetween","numPoints","Math","ceil","push","dHeight","heightPerVertex","h","nextScratch","prevScratch","computeRotationAngle","start","end","position","tangentPlane","next","projectPointOntoPlane","add","prev","angle","x","y","negativeX","transform","translation","rotationZ","scaleMatrix","IDENTITY","clone","westScratch","finalPosScratch","heightCartesian","addPosition","center","left","shape","finalPositions","xScalar","repeat","west","finalPosition","eastNorthUpToFixedFrame","multiplyByPointAsVector","normalize","fromRotationZ","z","multiplyTransformation","fromRotationTranslation","scale","j","fromArray","multiplyByVector","multiplyByPoint","centerScratch","addPositions","centers","convertShapeTo3DDuplicate","shape2D","boundingRectangle","index","xOffset","width","yOffset","point","convertShapeTo3D","quaterion","startPointScratch","rotMatrix","computeRoundCorner","pivot","startPoint","endPoint","cornerType","leftIsOutside","duplicatePoints","subtract","BEVELED","toRadians","m","fromQuaternion","fromAxisAngle","negate","surfacePoint","removeDuplicatesFromShape","shapePositions","cleanedPositions","i0","i1","v0","v1","equals","angleIsGreaterThanPi","forward","backward","scratchForwardProjection","scratchBackwardProjection","computePositions","geometry","_ellipsoid","_granularity","_cornerType","shapeForSides","shapeForEnds","undefined","heightOffset","ends","cornerDirection","surfaceNormal","previousPosition","nextPosition","geodeticSurfaceNormal","cross","subdividedHeights","subdividedPositions","forwardProjection","multiplyByScalar","dot","backwardProjection","doCorner","equalsEpsilon","abs","EPSILON7","scalar","max","magnitude","generateArc","ROUNDED","posLength","combinedPositions","Float64Array","set"],"mappings":"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","sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport CornerType from \"./CornerType.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Transforms from \"./Transforms.js\";\n\nvar scratch2Array = [new Cartesian3(), new Cartesian3()];\nvar scratchCartesian1 = new Cartesian3();\nvar scratchCartesian2 = new Cartesian3();\nvar scratchCartesian3 = new Cartesian3();\nvar scratchCartesian4 = new Cartesian3();\nvar scratchCartesian5 = new Cartesian3();\nvar scratchCartesian6 = new Cartesian3();\nvar scratchCartesian7 = new Cartesian3();\nvar scratchCartesian8 = new Cartesian3();\nvar scratchCartesian9 = new Cartesian3();\n\nvar scratch1 = new Cartesian3();\nvar scratch2 = new Cartesian3();\n\n/**\n * @private\n */\nvar PolylineVolumeGeometryLibrary = {};\n\nvar cartographic = new Cartographic();\nfunction scaleToSurface(positions, ellipsoid) {\n  var heights = new Array(positions.length);\n  for (var i = 0; i < positions.length; i++) {\n    var pos = positions[i];\n    cartographic = ellipsoid.cartesianToCartographic(pos, cartographic);\n    heights[i] = cartographic.height;\n    positions[i] = ellipsoid.scaleToGeodeticSurface(pos, pos);\n  }\n  return heights;\n}\n\nfunction subdivideHeights(points, h0, h1, granularity) {\n  var p0 = points[0];\n  var p1 = points[1];\n  var angleBetween = Cartesian3.angleBetween(p0, p1);\n  var numPoints = Math.ceil(angleBetween / granularity);\n  var heights = new Array(numPoints);\n  var i;\n  if (h0 === h1) {\n    for (i = 0; i < numPoints; i++) {\n      heights[i] = h0;\n    }\n    heights.push(h1);\n    return heights;\n  }\n\n  var dHeight = h1 - h0;\n  var heightPerVertex = dHeight / numPoints;\n\n  for (i = 1; i < numPoints; i++) {\n    var h = h0 + i * heightPerVertex;\n    heights[i] = h;\n  }\n\n  heights[0] = h0;\n  heights.push(h1);\n  return heights;\n}\n\nvar nextScratch = new Cartesian3();\nvar prevScratch = new Cartesian3();\n\nfunction computeRotationAngle(start, end, position, ellipsoid) {\n  var tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);\n  var next = tangentPlane.projectPointOntoPlane(\n    Cartesian3.add(position, start, nextScratch),\n    nextScratch\n  );\n  var prev = tangentPlane.projectPointOntoPlane(\n    Cartesian3.add(position, end, prevScratch),\n    prevScratch\n  );\n  var angle = Cartesian2.angleBetween(next, prev);\n\n  return prev.x * next.y - prev.y * next.x >= 0.0 ? -angle : angle;\n}\n\nvar negativeX = new Cartesian3(-1, 0, 0);\nvar transform = new Matrix4();\nvar translation = new Matrix4();\nvar rotationZ = new Matrix3();\nvar scaleMatrix = Matrix3.IDENTITY.clone();\nvar westScratch = new Cartesian3();\nvar finalPosScratch = new Cartesian4();\nvar heightCartesian = new Cartesian3();\nfunction addPosition(\n  center,\n  left,\n  shape,\n  finalPositions,\n  ellipsoid,\n  height,\n  xScalar,\n  repeat\n) {\n  var west = westScratch;\n  var finalPosition = finalPosScratch;\n  transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, transform);\n\n  west = Matrix4.multiplyByPointAsVector(transform, negativeX, west);\n  west = Cartesian3.normalize(west, west);\n  var angle = computeRotationAngle(west, left, center, ellipsoid);\n  rotationZ = Matrix3.fromRotationZ(angle, rotationZ);\n\n  heightCartesian.z = height;\n  transform = Matrix4.multiplyTransformation(\n    transform,\n    Matrix4.fromRotationTranslation(rotationZ, heightCartesian, translation),\n    transform\n  );\n  var scale = scaleMatrix;\n  scale[0] = xScalar;\n\n  for (var j = 0; j < repeat; j++) {\n    for (var i = 0; i < shape.length; i += 3) {\n      finalPosition = Cartesian3.fromArray(shape, i, finalPosition);\n      finalPosition = Matrix3.multiplyByVector(\n        scale,\n        finalPosition,\n        finalPosition\n      );\n      finalPosition = Matrix4.multiplyByPoint(\n        transform,\n        finalPosition,\n        finalPosition\n      );\n      finalPositions.push(finalPosition.x, finalPosition.y, finalPosition.z);\n    }\n  }\n\n  return finalPositions;\n}\n\nvar centerScratch = new Cartesian3();\nfunction addPositions(\n  centers,\n  left,\n  shape,\n  finalPositions,\n  ellipsoid,\n  heights,\n  xScalar\n) {\n  for (var i = 0; i < centers.length; i += 3) {\n    var center = Cartesian3.fromArray(centers, i, centerScratch);\n    finalPositions = addPosition(\n      center,\n      left,\n      shape,\n      finalPositions,\n      ellipsoid,\n      heights[i / 3],\n      xScalar,\n      1\n    );\n  }\n  return finalPositions;\n}\n\nfunction convertShapeTo3DDuplicate(shape2D, boundingRectangle) {\n  //orientate 2D shape to XZ plane center at (0, 0, 0), duplicate points\n  var length = shape2D.length;\n  var shape = new Array(length * 6);\n  var index = 0;\n  var xOffset = boundingRectangle.x + boundingRectangle.width / 2;\n  var yOffset = boundingRectangle.y + boundingRectangle.height / 2;\n\n  var point = shape2D[0];\n  shape[index++] = point.x - xOffset;\n  shape[index++] = 0.0;\n  shape[index++] = point.y - yOffset;\n  for (var i = 1; i < length; i++) {\n    point = shape2D[i];\n    var x = point.x - xOffset;\n    var z = point.y - yOffset;\n    shape[index++] = x;\n    shape[index++] = 0.0;\n    shape[index++] = z;\n\n    shape[index++] = x;\n    shape[index++] = 0.0;\n    shape[index++] = z;\n  }\n  point = shape2D[0];\n  shape[index++] = point.x - xOffset;\n  shape[index++] = 0.0;\n  shape[index++] = point.y - yOffset;\n\n  return shape;\n}\n\nfunction convertShapeTo3D(shape2D, boundingRectangle) {\n  //orientate 2D shape to XZ plane center at (0, 0, 0)\n  var length = shape2D.length;\n  var shape = new Array(length * 3);\n  var index = 0;\n  var xOffset = boundingRectangle.x + boundingRectangle.width / 2;\n  var yOffset = boundingRectangle.y + boundingRectangle.height / 2;\n\n  for (var i = 0; i < length; i++) {\n    shape[index++] = shape2D[i].x - xOffset;\n    shape[index++] = 0;\n    shape[index++] = shape2D[i].y - yOffset;\n  }\n\n  return shape;\n}\n\nvar quaterion = new Quaternion();\nvar startPointScratch = new Cartesian3();\nvar rotMatrix = new Matrix3();\nfunction computeRoundCorner(\n  pivot,\n  startPoint,\n  endPoint,\n  cornerType,\n  leftIsOutside,\n  ellipsoid,\n  finalPositions,\n  shape,\n  height,\n  duplicatePoints\n) {\n  var angle = Cartesian3.angleBetween(\n    Cartesian3.subtract(startPoint, pivot, scratch1),\n    Cartesian3.subtract(endPoint, pivot, scratch2)\n  );\n  var granularity =\n    cornerType === CornerType.BEVELED\n      ? 0\n      : Math.ceil(angle / CesiumMath.toRadians(5));\n\n  var m;\n  if (leftIsOutside) {\n    m = Matrix3.fromQuaternion(\n      Quaternion.fromAxisAngle(\n        Cartesian3.negate(pivot, scratch1),\n        angle / (granularity + 1),\n        quaterion\n      ),\n      rotMatrix\n    );\n  } else {\n    m = Matrix3.fromQuaternion(\n      Quaternion.fromAxisAngle(pivot, angle / (granularity + 1), quaterion),\n      rotMatrix\n    );\n  }\n\n  var left;\n  var surfacePoint;\n  startPoint = Cartesian3.clone(startPoint, startPointScratch);\n  if (granularity > 0) {\n    var repeat = duplicatePoints ? 2 : 1;\n    for (var i = 0; i < granularity; i++) {\n      startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\n      left = Cartesian3.subtract(startPoint, pivot, scratch1);\n      left = Cartesian3.normalize(left, left);\n      if (!leftIsOutside) {\n        left = Cartesian3.negate(left, left);\n      }\n      surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);\n      finalPositions = addPosition(\n        surfacePoint,\n        left,\n        shape,\n        finalPositions,\n        ellipsoid,\n        height,\n        1,\n        repeat\n      );\n    }\n  } else {\n    left = Cartesian3.subtract(startPoint, pivot, scratch1);\n    left = Cartesian3.normalize(left, left);\n    if (!leftIsOutside) {\n      left = Cartesian3.negate(left, left);\n    }\n    surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);\n    finalPositions = addPosition(\n      surfacePoint,\n      left,\n      shape,\n      finalPositions,\n      ellipsoid,\n      height,\n      1,\n      1\n    );\n\n    endPoint = Cartesian3.clone(endPoint, startPointScratch);\n    left = Cartesian3.subtract(endPoint, pivot, scratch1);\n    left = Cartesian3.normalize(left, left);\n    if (!leftIsOutside) {\n      left = Cartesian3.negate(left, left);\n    }\n    surfacePoint = ellipsoid.scaleToGeodeticSurface(endPoint, scratch2);\n    finalPositions = addPosition(\n      surfacePoint,\n      left,\n      shape,\n      finalPositions,\n      ellipsoid,\n      height,\n      1,\n      1\n    );\n  }\n\n  return finalPositions;\n}\n\nPolylineVolumeGeometryLibrary.removeDuplicatesFromShape = function (\n  shapePositions\n) {\n  var length = shapePositions.length;\n  var cleanedPositions = [];\n  for (var i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {\n    var v0 = shapePositions[i0];\n    var v1 = shapePositions[i1];\n\n    if (!Cartesian2.equals(v0, v1)) {\n      cleanedPositions.push(v1); // Shallow copy!\n    }\n  }\n\n  return cleanedPositions;\n};\n\nPolylineVolumeGeometryLibrary.angleIsGreaterThanPi = function (\n  forward,\n  backward,\n  position,\n  ellipsoid\n) {\n  var tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);\n  var next = tangentPlane.projectPointOntoPlane(\n    Cartesian3.add(position, forward, nextScratch),\n    nextScratch\n  );\n  var prev = tangentPlane.projectPointOntoPlane(\n    Cartesian3.add(position, backward, prevScratch),\n    prevScratch\n  );\n\n  return prev.x * next.y - prev.y * next.x >= 0.0;\n};\n\nvar scratchForwardProjection = new Cartesian3();\nvar scratchBackwardProjection = new Cartesian3();\n\nPolylineVolumeGeometryLibrary.computePositions = function (\n  positions,\n  shape2D,\n  boundingRectangle,\n  geometry,\n  duplicatePoints\n) {\n  var ellipsoid = geometry._ellipsoid;\n  var heights = scaleToSurface(positions, ellipsoid);\n  var granularity = geometry._granularity;\n  var cornerType = geometry._cornerType;\n  var shapeForSides = duplicatePoints\n    ? convertShapeTo3DDuplicate(shape2D, boundingRectangle)\n    : convertShapeTo3D(shape2D, boundingRectangle);\n  var shapeForEnds = duplicatePoints\n    ? convertShapeTo3D(shape2D, boundingRectangle)\n    : undefined;\n  var heightOffset = boundingRectangle.height / 2;\n  var width = boundingRectangle.width / 2;\n  var length = positions.length;\n  var finalPositions = [];\n  var ends = duplicatePoints ? [] : undefined;\n\n  var forward = scratchCartesian1;\n  var backward = scratchCartesian2;\n  var cornerDirection = scratchCartesian3;\n  var surfaceNormal = scratchCartesian4;\n  var pivot = scratchCartesian5;\n  var start = scratchCartesian6;\n  var end = scratchCartesian7;\n  var left = scratchCartesian8;\n  var previousPosition = scratchCartesian9;\n\n  var position = positions[0];\n  var nextPosition = positions[1];\n  surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);\n  forward = Cartesian3.subtract(nextPosition, position, forward);\n  forward = Cartesian3.normalize(forward, forward);\n  left = Cartesian3.cross(surfaceNormal, forward, left);\n  left = Cartesian3.normalize(left, left);\n  var h0 = heights[0];\n  var h1 = heights[1];\n  if (duplicatePoints) {\n    ends = addPosition(\n      position,\n      left,\n      shapeForEnds,\n      ends,\n      ellipsoid,\n      h0 + heightOffset,\n      1,\n      1\n    );\n  }\n  previousPosition = Cartesian3.clone(position, previousPosition);\n  position = nextPosition;\n  backward = Cartesian3.negate(forward, backward);\n  var subdividedHeights;\n  var subdividedPositions;\n  for (var i = 1; i < length - 1; i++) {\n    var repeat = duplicatePoints ? 2 : 1;\n    nextPosition = positions[i + 1];\n    forward = Cartesian3.subtract(nextPosition, position, forward);\n    forward = Cartesian3.normalize(forward, forward);\n    cornerDirection = Cartesian3.add(forward, backward, cornerDirection);\n    cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n    surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);\n\n    var forwardProjection = Cartesian3.multiplyByScalar(\n      surfaceNormal,\n      Cartesian3.dot(forward, surfaceNormal),\n      scratchForwardProjection\n    );\n    Cartesian3.subtract(forward, forwardProjection, forwardProjection);\n    Cartesian3.normalize(forwardProjection, forwardProjection);\n\n    var backwardProjection = Cartesian3.multiplyByScalar(\n      surfaceNormal,\n      Cartesian3.dot(backward, surfaceNormal),\n      scratchBackwardProjection\n    );\n    Cartesian3.subtract(backward, backwardProjection, backwardProjection);\n    Cartesian3.normalize(backwardProjection, backwardProjection);\n\n    var doCorner = !CesiumMath.equalsEpsilon(\n      Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)),\n      1.0,\n      CesiumMath.EPSILON7\n    );\n\n    if (doCorner) {\n      cornerDirection = Cartesian3.cross(\n        cornerDirection,\n        surfaceNormal,\n        cornerDirection\n      );\n      cornerDirection = Cartesian3.cross(\n        surfaceNormal,\n        cornerDirection,\n        cornerDirection\n      );\n      cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n      var scalar =\n        1 /\n        Math.max(\n          0.25,\n          Cartesian3.magnitude(\n            Cartesian3.cross(cornerDirection, backward, scratch1)\n          )\n        );\n      var leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(\n        forward,\n        backward,\n        position,\n        ellipsoid\n      );\n      if (leftIsOutside) {\n        pivot = Cartesian3.add(\n          position,\n          Cartesian3.multiplyByScalar(\n            cornerDirection,\n            scalar * width,\n            cornerDirection\n          ),\n          pivot\n        );\n        start = Cartesian3.add(\n          pivot,\n          Cartesian3.multiplyByScalar(left, width, start),\n          start\n        );\n        scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n        scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);\n        subdividedHeights = subdivideHeights(\n          scratch2Array,\n          h0 + heightOffset,\n          h1 + heightOffset,\n          granularity\n        );\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scratch2Array,\n          granularity: granularity,\n          ellipsoid: ellipsoid,\n        });\n        finalPositions = addPositions(\n          subdividedPositions,\n          left,\n          shapeForSides,\n          finalPositions,\n          ellipsoid,\n          subdividedHeights,\n          1\n        );\n        left = Cartesian3.cross(surfaceNormal, forward, left);\n        left = Cartesian3.normalize(left, left);\n        end = Cartesian3.add(\n          pivot,\n          Cartesian3.multiplyByScalar(left, width, end),\n          end\n        );\n        if (\n          cornerType === CornerType.ROUNDED ||\n          cornerType === CornerType.BEVELED\n        ) {\n          computeRoundCorner(\n            pivot,\n            start,\n            end,\n            cornerType,\n            leftIsOutside,\n            ellipsoid,\n            finalPositions,\n            shapeForSides,\n            h1 + heightOffset,\n            duplicatePoints\n          );\n        } else {\n          cornerDirection = Cartesian3.negate(cornerDirection, cornerDirection);\n          finalPositions = addPosition(\n            position,\n            cornerDirection,\n            shapeForSides,\n            finalPositions,\n            ellipsoid,\n            h1 + heightOffset,\n            scalar,\n            repeat\n          );\n        }\n        previousPosition = Cartesian3.clone(end, previousPosition);\n      } else {\n        pivot = Cartesian3.add(\n          position,\n          Cartesian3.multiplyByScalar(\n            cornerDirection,\n            scalar * width,\n            cornerDirection\n          ),\n          pivot\n        );\n        start = Cartesian3.add(\n          pivot,\n          Cartesian3.multiplyByScalar(left, -width, start),\n          start\n        );\n        scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n        scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);\n        subdividedHeights = subdivideHeights(\n          scratch2Array,\n          h0 + heightOffset,\n          h1 + heightOffset,\n          granularity\n        );\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scratch2Array,\n          granularity: granularity,\n          ellipsoid: ellipsoid,\n        });\n        finalPositions = addPositions(\n          subdividedPositions,\n          left,\n          shapeForSides,\n          finalPositions,\n          ellipsoid,\n          subdividedHeights,\n          1\n        );\n        left = Cartesian3.cross(surfaceNormal, forward, left);\n        left = Cartesian3.normalize(left, left);\n        end = Cartesian3.add(\n          pivot,\n          Cartesian3.multiplyByScalar(left, -width, end),\n          end\n        );\n        if (\n          cornerType === CornerType.ROUNDED ||\n          cornerType === CornerType.BEVELED\n        ) {\n          computeRoundCorner(\n            pivot,\n            start,\n            end,\n            cornerType,\n            leftIsOutside,\n            ellipsoid,\n            finalPositions,\n            shapeForSides,\n            h1 + heightOffset,\n            duplicatePoints\n          );\n        } else {\n          finalPositions = addPosition(\n            position,\n            cornerDirection,\n            shapeForSides,\n            finalPositions,\n            ellipsoid,\n            h1 + heightOffset,\n            scalar,\n            repeat\n          );\n        }\n        previousPosition = Cartesian3.clone(end, previousPosition);\n      }\n      backward = Cartesian3.negate(forward, backward);\n    } else {\n      finalPositions = addPosition(\n        previousPosition,\n        left,\n        shapeForSides,\n        finalPositions,\n        ellipsoid,\n        h0 + heightOffset,\n        1,\n        1\n      );\n      previousPosition = position;\n    }\n    h0 = h1;\n    h1 = heights[i + 1];\n    position = nextPosition;\n  }\n\n  scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n  scratch2Array[1] = Cartesian3.clone(position, scratch2Array[1]);\n  subdividedHeights = subdivideHeights(\n    scratch2Array,\n    h0 + heightOffset,\n    h1 + heightOffset,\n    granularity\n  );\n  subdividedPositions = PolylinePipeline.generateArc({\n    positions: scratch2Array,\n    granularity: granularity,\n    ellipsoid: ellipsoid,\n  });\n  finalPositions = addPositions(\n    subdividedPositions,\n    left,\n    shapeForSides,\n    finalPositions,\n    ellipsoid,\n    subdividedHeights,\n    1\n  );\n  if (duplicatePoints) {\n    ends = addPosition(\n      position,\n      left,\n      shapeForEnds,\n      ends,\n      ellipsoid,\n      h1 + heightOffset,\n      1,\n      1\n    );\n  }\n\n  length = finalPositions.length;\n  var posLength = duplicatePoints ? length + ends.length : length;\n  var combinedPositions = new Float64Array(posLength);\n  combinedPositions.set(finalPositions);\n  if (duplicatePoints) {\n    combinedPositions.set(ends, length);\n  }\n\n  return combinedPositions;\n};\nexport default PolylineVolumeGeometryLibrary;\n"]},"metadata":{},"sourceType":"module"}