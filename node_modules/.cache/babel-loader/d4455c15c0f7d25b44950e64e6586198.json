{"ast":null,"code":"import arraySlice from \"../Core/arraySlice.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport when from \"../ThirdParty/when.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport Vector3DTileBatch from \"./Vector3DTileBatch.js\";\nimport Vector3DTilePrimitive from \"./Vector3DTilePrimitive.js\";\n/**\n * Creates a batch of box, cylinder, ellipsoid and/or sphere geometries intersecting terrain or 3D Tiles.\n *\n * @alias Vector3DTileGeometry\n * @constructor\n *\n * @param {Object} options An object with following properties:\n * @param {Float32Array} [options.boxes] The boxes in the tile.\n * @param {Uint16Array} [options.boxBatchIds] The batch ids for each box.\n * @param {Float32Array} [options.cylinders] The cylinders in the tile.\n * @param {Uint16Array} [options.cylinderBatchIds] The batch ids for each cylinder.\n * @param {Float32Array} [options.ellipsoids] The ellipsoids in the tile.\n * @param {Uint16Array} [options.ellipsoidBatchIds] The batch ids for each ellipsoid.\n * @param {Float32Array} [options.spheres] The spheres in the tile.\n * @param {Uint16Array} [options.sphereBatchIds] The batch ids for each sphere.\n * @param {Cartesian3} options.center The RTC center of all geometries.\n * @param {Matrix4} options.modelMatrix The model matrix of all geometries. Applied after the individual geometry model matrices.\n * @param {Cesium3DTileBatchTable} options.batchTable The batch table.\n * @param {BoundingSphere} options.boundingVolume The bounding volume containing all of the geometry in the tile.\n *\n * @private\n */\n\nfunction Vector3DTileGeometry(options) {\n  // these will all be released after the primitive is created\n  this._boxes = options.boxes;\n  this._boxBatchIds = options.boxBatchIds;\n  this._cylinders = options.cylinders;\n  this._cylinderBatchIds = options.cylinderBatchIds;\n  this._ellipsoids = options.ellipsoids;\n  this._ellipsoidBatchIds = options.ellipsoidBatchIds;\n  this._spheres = options.spheres;\n  this._sphereBatchIds = options.sphereBatchIds;\n  this._modelMatrix = options.modelMatrix;\n  this._batchTable = options.batchTable;\n  this._boundingVolume = options.boundingVolume;\n  this._center = options.center;\n\n  if (!defined(this._center)) {\n    if (defined(this._boundingVolume)) {\n      this._center = Cartesian3.clone(this._boundingVolume.center);\n    } else {\n      this._center = Cartesian3.clone(Cartesian3.ZERO);\n    }\n  }\n\n  this._boundingVolumes = undefined;\n  this._batchedIndices = undefined;\n  this._indices = undefined;\n  this._indexOffsets = undefined;\n  this._indexCounts = undefined;\n  this._positions = undefined;\n  this._vertexBatchIds = undefined;\n  this._batchIds = undefined;\n  this._batchTableColors = undefined;\n  this._packedBuffer = undefined;\n  this._ready = false;\n  this._readyPromise = when.defer();\n  this._verticesPromise = undefined;\n  this._primitive = undefined;\n  /**\n   * Draws the wireframe of the classification geometries.\n   * @type {Boolean}\n   * @default false\n   */\n\n  this.debugWireframe = false;\n  /**\n   * Forces a re-batch instead of waiting after a number of frames have been rendered. For testing only.\n   * @type {Boolean}\n   * @default false\n   */\n\n  this.forceRebatch = false;\n  /**\n   * What this tile will classify.\n   * @type {ClassificationType}\n   * @default ClassificationType.BOTH\n   */\n\n  this.classificationType = ClassificationType.BOTH;\n}\n\nObject.defineProperties(Vector3DTileGeometry.prototype, {\n  /**\n   * Gets the number of triangles.\n   *\n   * @memberof Vector3DTileGeometry.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  trianglesLength: {\n    get: function () {\n      if (defined(this._primitive)) {\n        return this._primitive.trianglesLength;\n      }\n\n      return 0;\n    }\n  },\n\n  /**\n   * Gets the geometry memory in bytes.\n   *\n   * @memberof Vector3DTileGeometry.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  geometryByteLength: {\n    get: function () {\n      if (defined(this._primitive)) {\n        return this._primitive.geometryByteLength;\n      }\n\n      return 0;\n    }\n  },\n\n  /**\n   * Gets a promise that resolves when the primitive is ready to render.\n   * @memberof Vector3DTileGeometry.prototype\n   * @type {Promise}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    }\n  }\n});\nVector3DTileGeometry.packedBoxLength = Matrix4.packedLength + Cartesian3.packedLength;\nVector3DTileGeometry.packedCylinderLength = Matrix4.packedLength + 2;\nVector3DTileGeometry.packedEllipsoidLength = Matrix4.packedLength + Cartesian3.packedLength;\nVector3DTileGeometry.packedSphereLength = Cartesian3.packedLength + 1;\n\nfunction packBuffer(geometries) {\n  var packedBuffer = new Float64Array(Matrix4.packedLength + Cartesian3.packedLength);\n  var offset = 0;\n  Cartesian3.pack(geometries._center, packedBuffer, offset);\n  offset += Cartesian3.packedLength;\n  Matrix4.pack(geometries._modelMatrix, packedBuffer, offset);\n  return packedBuffer;\n}\n\nfunction unpackBuffer(geometries, packedBuffer) {\n  var offset = 0;\n  var indicesBytesPerElement = packedBuffer[offset++];\n  var numBVS = packedBuffer[offset++];\n  var bvs = geometries._boundingVolumes = new Array(numBVS);\n\n  for (var i = 0; i < numBVS; ++i) {\n    bvs[i] = BoundingSphere.unpack(packedBuffer, offset);\n    offset += BoundingSphere.packedLength;\n  }\n\n  var numBatchedIndices = packedBuffer[offset++];\n  var bis = geometries._batchedIndices = new Array(numBatchedIndices);\n\n  for (var j = 0; j < numBatchedIndices; ++j) {\n    var color = Color.unpack(packedBuffer, offset);\n    offset += Color.packedLength;\n    var indexOffset = packedBuffer[offset++];\n    var count = packedBuffer[offset++];\n    var length = packedBuffer[offset++];\n    var batchIds = new Array(length);\n\n    for (var k = 0; k < length; ++k) {\n      batchIds[k] = packedBuffer[offset++];\n    }\n\n    bis[j] = new Vector3DTileBatch({\n      color: color,\n      offset: indexOffset,\n      count: count,\n      batchIds: batchIds\n    });\n  }\n\n  return indicesBytesPerElement;\n}\n\nvar createVerticesTaskProcessor = new TaskProcessor(\"createVectorTileGeometries\");\nvar scratchColor = new Color();\n\nfunction createPrimitive(geometries) {\n  if (defined(geometries._primitive)) {\n    return;\n  }\n\n  if (!defined(geometries._verticesPromise)) {\n    var boxes = geometries._boxes;\n    var boxBatchIds = geometries._boxBatchIds;\n    var cylinders = geometries._cylinders;\n    var cylinderBatchIds = geometries._cylinderBatchIds;\n    var ellipsoids = geometries._ellipsoids;\n    var ellipsoidBatchIds = geometries._ellipsoidBatchIds;\n    var spheres = geometries._spheres;\n    var sphereBatchIds = geometries._sphereBatchIds;\n    var batchTableColors = geometries._batchTableColors;\n    var packedBuffer = geometries._packedBuffer;\n\n    if (!defined(batchTableColors)) {\n      // Copy because they may be the views on the same buffer.\n      var length = 0;\n\n      if (defined(geometries._boxes)) {\n        boxes = geometries._boxes = arraySlice(boxes);\n        boxBatchIds = geometries._boxBatchIds = arraySlice(boxBatchIds);\n        length += boxBatchIds.length;\n      }\n\n      if (defined(geometries._cylinders)) {\n        cylinders = geometries._cylinders = arraySlice(cylinders);\n        cylinderBatchIds = geometries._cylinderBatchIds = arraySlice(cylinderBatchIds);\n        length += cylinderBatchIds.length;\n      }\n\n      if (defined(geometries._ellipsoids)) {\n        ellipsoids = geometries._ellipsoids = arraySlice(ellipsoids);\n        ellipsoidBatchIds = geometries._ellipsoidBatchIds = arraySlice(ellipsoidBatchIds);\n        length += ellipsoidBatchIds.length;\n      }\n\n      if (defined(geometries._spheres)) {\n        spheres = geometries._sphere = arraySlice(spheres);\n        sphereBatchIds = geometries._sphereBatchIds = arraySlice(sphereBatchIds);\n        length += sphereBatchIds.length;\n      }\n\n      batchTableColors = geometries._batchTableColors = new Uint32Array(length);\n      var batchTable = geometries._batchTable;\n\n      for (var i = 0; i < length; ++i) {\n        var color = batchTable.getColor(i, scratchColor);\n        batchTableColors[i] = color.toRgba();\n      }\n\n      packedBuffer = geometries._packedBuffer = packBuffer(geometries);\n    }\n\n    var transferrableObjects = [];\n\n    if (defined(boxes)) {\n      transferrableObjects.push(boxes.buffer, boxBatchIds.buffer);\n    }\n\n    if (defined(cylinders)) {\n      transferrableObjects.push(cylinders.buffer, cylinderBatchIds.buffer);\n    }\n\n    if (defined(ellipsoids)) {\n      transferrableObjects.push(ellipsoids.buffer, ellipsoidBatchIds.buffer);\n    }\n\n    if (defined(spheres)) {\n      transferrableObjects.push(spheres.buffer, sphereBatchIds.buffer);\n    }\n\n    transferrableObjects.push(batchTableColors.buffer, packedBuffer.buffer);\n    var parameters = {\n      boxes: defined(boxes) ? boxes.buffer : undefined,\n      boxBatchIds: defined(boxes) ? boxBatchIds.buffer : undefined,\n      cylinders: defined(cylinders) ? cylinders.buffer : undefined,\n      cylinderBatchIds: defined(cylinders) ? cylinderBatchIds.buffer : undefined,\n      ellipsoids: defined(ellipsoids) ? ellipsoids.buffer : undefined,\n      ellipsoidBatchIds: defined(ellipsoids) ? ellipsoidBatchIds.buffer : undefined,\n      spheres: defined(spheres) ? spheres.buffer : undefined,\n      sphereBatchIds: defined(spheres) ? sphereBatchIds.buffer : undefined,\n      batchTableColors: batchTableColors.buffer,\n      packedBuffer: packedBuffer.buffer\n    };\n    var verticesPromise = geometries._verticesPromise = createVerticesTaskProcessor.scheduleTask(parameters, transferrableObjects);\n\n    if (!defined(verticesPromise)) {\n      // Postponed\n      return;\n    }\n\n    verticesPromise.then(function (result) {\n      var packedBuffer = new Float64Array(result.packedBuffer);\n      var indicesBytesPerElement = unpackBuffer(geometries, packedBuffer);\n\n      if (indicesBytesPerElement === 2) {\n        geometries._indices = new Uint16Array(result.indices);\n      } else {\n        geometries._indices = new Uint32Array(result.indices);\n      }\n\n      geometries._indexOffsets = new Uint32Array(result.indexOffsets);\n      geometries._indexCounts = new Uint32Array(result.indexCounts);\n      geometries._positions = new Float32Array(result.positions);\n      geometries._vertexBatchIds = new Uint16Array(result.vertexBatchIds);\n      geometries._batchIds = new Uint16Array(result.batchIds);\n      geometries._ready = true;\n    });\n  }\n\n  if (geometries._ready && !defined(geometries._primitive)) {\n    geometries._primitive = new Vector3DTilePrimitive({\n      batchTable: geometries._batchTable,\n      positions: geometries._positions,\n      batchIds: geometries._batchIds,\n      vertexBatchIds: geometries._vertexBatchIds,\n      indices: geometries._indices,\n      indexOffsets: geometries._indexOffsets,\n      indexCounts: geometries._indexCounts,\n      batchedIndices: geometries._batchedIndices,\n      boundingVolume: geometries._boundingVolume,\n      boundingVolumes: geometries._boundingVolumes,\n      center: geometries._center,\n      pickObject: defaultValue(geometries._pickObject, geometries)\n    });\n    geometries._boxes = undefined;\n    geometries._boxBatchIds = undefined;\n    geometries._cylinders = undefined;\n    geometries._cylinderBatchIds = undefined;\n    geometries._ellipsoids = undefined;\n    geometries._ellipsoidBatchIds = undefined;\n    geometries._spheres = undefined;\n    geometries._sphereBatchIds = undefined;\n    geometries._center = undefined;\n    geometries._modelMatrix = undefined;\n    geometries._batchTable = undefined;\n    geometries._boundingVolume = undefined;\n    geometries._boundingVolumes = undefined;\n    geometries._batchedIndices = undefined;\n    geometries._indices = undefined;\n    geometries._indexOffsets = undefined;\n    geometries._indexCounts = undefined;\n    geometries._positions = undefined;\n    geometries._vertexBatchIds = undefined;\n    geometries._batchIds = undefined;\n    geometries._batchTableColors = undefined;\n    geometries._packedBuffer = undefined;\n    geometries._verticesPromise = undefined;\n\n    geometries._readyPromise.resolve();\n  }\n}\n/**\n * Creates features for each geometry and places it at the batch id index of features.\n *\n * @param {Vector3DTileContent} content The vector tile content.\n * @param {Cesium3DTileFeature[]} features An array of features where the polygon features will be placed.\n */\n\n\nVector3DTileGeometry.prototype.createFeatures = function (content, features) {\n  this._primitive.createFeatures(content, features);\n};\n/**\n * Colors the entire tile when enabled is true. The resulting color will be (geometry batch table color * color).\n *\n * @param {Boolean} enabled Whether to enable debug coloring.\n * @param {Color} color The debug color.\n */\n\n\nVector3DTileGeometry.prototype.applyDebugSettings = function (enabled, color) {\n  this._primitive.applyDebugSettings(enabled, color);\n};\n/**\n * Apply a style to the content.\n *\n * @param {Cesium3DTileStyle} style The style.\n * @param {Cesium3DTileFeature[]} features The array of features.\n */\n\n\nVector3DTileGeometry.prototype.applyStyle = function (style, features) {\n  this._primitive.applyStyle(style, features);\n};\n/**\n * Call when updating the color of a geometry with batchId changes color. The geometries will need to be re-batched\n * on the next update.\n *\n * @param {Number} batchId The batch id of the geometries whose color has changed.\n * @param {Color} color The new polygon color.\n */\n\n\nVector3DTileGeometry.prototype.updateCommands = function (batchId, color) {\n  this._primitive.updateCommands(batchId, color);\n};\n/**\n * Updates the batches and queues the commands for rendering.\n *\n * @param {FrameState} frameState The current frame state.\n */\n\n\nVector3DTileGeometry.prototype.update = function (frameState) {\n  createPrimitive(this);\n\n  if (!this._ready) {\n    return;\n  }\n\n  this._primitive.debugWireframe = this.debugWireframe;\n  this._primitive.forceRebatch = this.forceRebatch;\n  this._primitive.classificationType = this.classificationType;\n\n  this._primitive.update(frameState);\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\n\n\nVector3DTileGeometry.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\n\n\nVector3DTileGeometry.prototype.destroy = function () {\n  this._primitive = this._primitive && this._primitive.destroy();\n  return destroyObject(this);\n};\n\nexport default Vector3DTileGeometry;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Scene/Vector3DTileGeometry.js"],"names":["arraySlice","BoundingSphere","Cartesian3","Color","defaultValue","defined","destroyObject","Matrix4","TaskProcessor","when","ClassificationType","Vector3DTileBatch","Vector3DTilePrimitive","Vector3DTileGeometry","options","_boxes","boxes","_boxBatchIds","boxBatchIds","_cylinders","cylinders","_cylinderBatchIds","cylinderBatchIds","_ellipsoids","ellipsoids","_ellipsoidBatchIds","ellipsoidBatchIds","_spheres","spheres","_sphereBatchIds","sphereBatchIds","_modelMatrix","modelMatrix","_batchTable","batchTable","_boundingVolume","boundingVolume","_center","center","clone","ZERO","_boundingVolumes","undefined","_batchedIndices","_indices","_indexOffsets","_indexCounts","_positions","_vertexBatchIds","_batchIds","_batchTableColors","_packedBuffer","_ready","_readyPromise","defer","_verticesPromise","_primitive","debugWireframe","forceRebatch","classificationType","BOTH","Object","defineProperties","prototype","trianglesLength","get","geometryByteLength","readyPromise","promise","packedBoxLength","packedLength","packedCylinderLength","packedEllipsoidLength","packedSphereLength","packBuffer","geometries","packedBuffer","Float64Array","offset","pack","unpackBuffer","indicesBytesPerElement","numBVS","bvs","Array","i","unpack","numBatchedIndices","bis","j","color","indexOffset","count","length","batchIds","k","createVerticesTaskProcessor","scratchColor","createPrimitive","batchTableColors","_sphere","Uint32Array","getColor","toRgba","transferrableObjects","push","buffer","parameters","verticesPromise","scheduleTask","then","result","Uint16Array","indices","indexOffsets","indexCounts","Float32Array","positions","vertexBatchIds","batchedIndices","boundingVolumes","pickObject","_pickObject","resolve","createFeatures","content","features","applyDebugSettings","enabled","applyStyle","style","updateCommands","batchId","update","frameState","isDestroyed","destroy"],"mappings":"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","sourcesContent":["import arraySlice from \"../Core/arraySlice.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport when from \"../ThirdParty/when.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport Vector3DTileBatch from \"./Vector3DTileBatch.js\";\nimport Vector3DTilePrimitive from \"./Vector3DTilePrimitive.js\";\n\n/**\n * Creates a batch of box, cylinder, ellipsoid and/or sphere geometries intersecting terrain or 3D Tiles.\n *\n * @alias Vector3DTileGeometry\n * @constructor\n *\n * @param {Object} options An object with following properties:\n * @param {Float32Array} [options.boxes] The boxes in the tile.\n * @param {Uint16Array} [options.boxBatchIds] The batch ids for each box.\n * @param {Float32Array} [options.cylinders] The cylinders in the tile.\n * @param {Uint16Array} [options.cylinderBatchIds] The batch ids for each cylinder.\n * @param {Float32Array} [options.ellipsoids] The ellipsoids in the tile.\n * @param {Uint16Array} [options.ellipsoidBatchIds] The batch ids for each ellipsoid.\n * @param {Float32Array} [options.spheres] The spheres in the tile.\n * @param {Uint16Array} [options.sphereBatchIds] The batch ids for each sphere.\n * @param {Cartesian3} options.center The RTC center of all geometries.\n * @param {Matrix4} options.modelMatrix The model matrix of all geometries. Applied after the individual geometry model matrices.\n * @param {Cesium3DTileBatchTable} options.batchTable The batch table.\n * @param {BoundingSphere} options.boundingVolume The bounding volume containing all of the geometry in the tile.\n *\n * @private\n */\nfunction Vector3DTileGeometry(options) {\n  // these will all be released after the primitive is created\n  this._boxes = options.boxes;\n  this._boxBatchIds = options.boxBatchIds;\n  this._cylinders = options.cylinders;\n  this._cylinderBatchIds = options.cylinderBatchIds;\n  this._ellipsoids = options.ellipsoids;\n  this._ellipsoidBatchIds = options.ellipsoidBatchIds;\n  this._spheres = options.spheres;\n  this._sphereBatchIds = options.sphereBatchIds;\n  this._modelMatrix = options.modelMatrix;\n  this._batchTable = options.batchTable;\n  this._boundingVolume = options.boundingVolume;\n\n  this._center = options.center;\n  if (!defined(this._center)) {\n    if (defined(this._boundingVolume)) {\n      this._center = Cartesian3.clone(this._boundingVolume.center);\n    } else {\n      this._center = Cartesian3.clone(Cartesian3.ZERO);\n    }\n  }\n\n  this._boundingVolumes = undefined;\n  this._batchedIndices = undefined;\n\n  this._indices = undefined;\n  this._indexOffsets = undefined;\n  this._indexCounts = undefined;\n\n  this._positions = undefined;\n  this._vertexBatchIds = undefined;\n\n  this._batchIds = undefined;\n\n  this._batchTableColors = undefined;\n  this._packedBuffer = undefined;\n\n  this._ready = false;\n  this._readyPromise = when.defer();\n\n  this._verticesPromise = undefined;\n\n  this._primitive = undefined;\n\n  /**\n   * Draws the wireframe of the classification geometries.\n   * @type {Boolean}\n   * @default false\n   */\n  this.debugWireframe = false;\n\n  /**\n   * Forces a re-batch instead of waiting after a number of frames have been rendered. For testing only.\n   * @type {Boolean}\n   * @default false\n   */\n  this.forceRebatch = false;\n\n  /**\n   * What this tile will classify.\n   * @type {ClassificationType}\n   * @default ClassificationType.BOTH\n   */\n  this.classificationType = ClassificationType.BOTH;\n}\n\nObject.defineProperties(Vector3DTileGeometry.prototype, {\n  /**\n   * Gets the number of triangles.\n   *\n   * @memberof Vector3DTileGeometry.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  trianglesLength: {\n    get: function () {\n      if (defined(this._primitive)) {\n        return this._primitive.trianglesLength;\n      }\n      return 0;\n    },\n  },\n\n  /**\n   * Gets the geometry memory in bytes.\n   *\n   * @memberof Vector3DTileGeometry.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  geometryByteLength: {\n    get: function () {\n      if (defined(this._primitive)) {\n        return this._primitive.geometryByteLength;\n      }\n      return 0;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves when the primitive is ready to render.\n   * @memberof Vector3DTileGeometry.prototype\n   * @type {Promise}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n});\n\nVector3DTileGeometry.packedBoxLength =\n  Matrix4.packedLength + Cartesian3.packedLength;\nVector3DTileGeometry.packedCylinderLength = Matrix4.packedLength + 2;\nVector3DTileGeometry.packedEllipsoidLength =\n  Matrix4.packedLength + Cartesian3.packedLength;\nVector3DTileGeometry.packedSphereLength = Cartesian3.packedLength + 1;\n\nfunction packBuffer(geometries) {\n  var packedBuffer = new Float64Array(\n    Matrix4.packedLength + Cartesian3.packedLength\n  );\n\n  var offset = 0;\n  Cartesian3.pack(geometries._center, packedBuffer, offset);\n  offset += Cartesian3.packedLength;\n  Matrix4.pack(geometries._modelMatrix, packedBuffer, offset);\n\n  return packedBuffer;\n}\n\nfunction unpackBuffer(geometries, packedBuffer) {\n  var offset = 0;\n\n  var indicesBytesPerElement = packedBuffer[offset++];\n  var numBVS = packedBuffer[offset++];\n  var bvs = (geometries._boundingVolumes = new Array(numBVS));\n\n  for (var i = 0; i < numBVS; ++i) {\n    bvs[i] = BoundingSphere.unpack(packedBuffer, offset);\n    offset += BoundingSphere.packedLength;\n  }\n\n  var numBatchedIndices = packedBuffer[offset++];\n  var bis = (geometries._batchedIndices = new Array(numBatchedIndices));\n\n  for (var j = 0; j < numBatchedIndices; ++j) {\n    var color = Color.unpack(packedBuffer, offset);\n    offset += Color.packedLength;\n\n    var indexOffset = packedBuffer[offset++];\n    var count = packedBuffer[offset++];\n\n    var length = packedBuffer[offset++];\n    var batchIds = new Array(length);\n\n    for (var k = 0; k < length; ++k) {\n      batchIds[k] = packedBuffer[offset++];\n    }\n\n    bis[j] = new Vector3DTileBatch({\n      color: color,\n      offset: indexOffset,\n      count: count,\n      batchIds: batchIds,\n    });\n  }\n\n  return indicesBytesPerElement;\n}\n\nvar createVerticesTaskProcessor = new TaskProcessor(\n  \"createVectorTileGeometries\"\n);\nvar scratchColor = new Color();\n\nfunction createPrimitive(geometries) {\n  if (defined(geometries._primitive)) {\n    return;\n  }\n\n  if (!defined(geometries._verticesPromise)) {\n    var boxes = geometries._boxes;\n    var boxBatchIds = geometries._boxBatchIds;\n    var cylinders = geometries._cylinders;\n    var cylinderBatchIds = geometries._cylinderBatchIds;\n    var ellipsoids = geometries._ellipsoids;\n    var ellipsoidBatchIds = geometries._ellipsoidBatchIds;\n    var spheres = geometries._spheres;\n    var sphereBatchIds = geometries._sphereBatchIds;\n\n    var batchTableColors = geometries._batchTableColors;\n    var packedBuffer = geometries._packedBuffer;\n\n    if (!defined(batchTableColors)) {\n      // Copy because they may be the views on the same buffer.\n      var length = 0;\n      if (defined(geometries._boxes)) {\n        boxes = geometries._boxes = arraySlice(boxes);\n        boxBatchIds = geometries._boxBatchIds = arraySlice(boxBatchIds);\n        length += boxBatchIds.length;\n      }\n      if (defined(geometries._cylinders)) {\n        cylinders = geometries._cylinders = arraySlice(cylinders);\n        cylinderBatchIds = geometries._cylinderBatchIds = arraySlice(\n          cylinderBatchIds\n        );\n        length += cylinderBatchIds.length;\n      }\n      if (defined(geometries._ellipsoids)) {\n        ellipsoids = geometries._ellipsoids = arraySlice(ellipsoids);\n        ellipsoidBatchIds = geometries._ellipsoidBatchIds = arraySlice(\n          ellipsoidBatchIds\n        );\n        length += ellipsoidBatchIds.length;\n      }\n      if (defined(geometries._spheres)) {\n        spheres = geometries._sphere = arraySlice(spheres);\n        sphereBatchIds = geometries._sphereBatchIds = arraySlice(\n          sphereBatchIds\n        );\n        length += sphereBatchIds.length;\n      }\n\n      batchTableColors = geometries._batchTableColors = new Uint32Array(length);\n      var batchTable = geometries._batchTable;\n\n      for (var i = 0; i < length; ++i) {\n        var color = batchTable.getColor(i, scratchColor);\n        batchTableColors[i] = color.toRgba();\n      }\n\n      packedBuffer = geometries._packedBuffer = packBuffer(geometries);\n    }\n\n    var transferrableObjects = [];\n    if (defined(boxes)) {\n      transferrableObjects.push(boxes.buffer, boxBatchIds.buffer);\n    }\n    if (defined(cylinders)) {\n      transferrableObjects.push(cylinders.buffer, cylinderBatchIds.buffer);\n    }\n    if (defined(ellipsoids)) {\n      transferrableObjects.push(ellipsoids.buffer, ellipsoidBatchIds.buffer);\n    }\n    if (defined(spheres)) {\n      transferrableObjects.push(spheres.buffer, sphereBatchIds.buffer);\n    }\n    transferrableObjects.push(batchTableColors.buffer, packedBuffer.buffer);\n\n    var parameters = {\n      boxes: defined(boxes) ? boxes.buffer : undefined,\n      boxBatchIds: defined(boxes) ? boxBatchIds.buffer : undefined,\n      cylinders: defined(cylinders) ? cylinders.buffer : undefined,\n      cylinderBatchIds: defined(cylinders)\n        ? cylinderBatchIds.buffer\n        : undefined,\n      ellipsoids: defined(ellipsoids) ? ellipsoids.buffer : undefined,\n      ellipsoidBatchIds: defined(ellipsoids)\n        ? ellipsoidBatchIds.buffer\n        : undefined,\n      spheres: defined(spheres) ? spheres.buffer : undefined,\n      sphereBatchIds: defined(spheres) ? sphereBatchIds.buffer : undefined,\n      batchTableColors: batchTableColors.buffer,\n      packedBuffer: packedBuffer.buffer,\n    };\n\n    var verticesPromise = (geometries._verticesPromise = createVerticesTaskProcessor.scheduleTask(\n      parameters,\n      transferrableObjects\n    ));\n    if (!defined(verticesPromise)) {\n      // Postponed\n      return;\n    }\n\n    verticesPromise.then(function (result) {\n      var packedBuffer = new Float64Array(result.packedBuffer);\n      var indicesBytesPerElement = unpackBuffer(geometries, packedBuffer);\n\n      if (indicesBytesPerElement === 2) {\n        geometries._indices = new Uint16Array(result.indices);\n      } else {\n        geometries._indices = new Uint32Array(result.indices);\n      }\n\n      geometries._indexOffsets = new Uint32Array(result.indexOffsets);\n      geometries._indexCounts = new Uint32Array(result.indexCounts);\n\n      geometries._positions = new Float32Array(result.positions);\n      geometries._vertexBatchIds = new Uint16Array(result.vertexBatchIds);\n\n      geometries._batchIds = new Uint16Array(result.batchIds);\n\n      geometries._ready = true;\n    });\n  }\n\n  if (geometries._ready && !defined(geometries._primitive)) {\n    geometries._primitive = new Vector3DTilePrimitive({\n      batchTable: geometries._batchTable,\n      positions: geometries._positions,\n      batchIds: geometries._batchIds,\n      vertexBatchIds: geometries._vertexBatchIds,\n      indices: geometries._indices,\n      indexOffsets: geometries._indexOffsets,\n      indexCounts: geometries._indexCounts,\n      batchedIndices: geometries._batchedIndices,\n      boundingVolume: geometries._boundingVolume,\n      boundingVolumes: geometries._boundingVolumes,\n      center: geometries._center,\n      pickObject: defaultValue(geometries._pickObject, geometries),\n    });\n\n    geometries._boxes = undefined;\n    geometries._boxBatchIds = undefined;\n    geometries._cylinders = undefined;\n    geometries._cylinderBatchIds = undefined;\n    geometries._ellipsoids = undefined;\n    geometries._ellipsoidBatchIds = undefined;\n    geometries._spheres = undefined;\n    geometries._sphereBatchIds = undefined;\n    geometries._center = undefined;\n    geometries._modelMatrix = undefined;\n    geometries._batchTable = undefined;\n    geometries._boundingVolume = undefined;\n\n    geometries._boundingVolumes = undefined;\n    geometries._batchedIndices = undefined;\n\n    geometries._indices = undefined;\n    geometries._indexOffsets = undefined;\n    geometries._indexCounts = undefined;\n\n    geometries._positions = undefined;\n    geometries._vertexBatchIds = undefined;\n\n    geometries._batchIds = undefined;\n\n    geometries._batchTableColors = undefined;\n    geometries._packedBuffer = undefined;\n\n    geometries._verticesPromise = undefined;\n\n    geometries._readyPromise.resolve();\n  }\n}\n\n/**\n * Creates features for each geometry and places it at the batch id index of features.\n *\n * @param {Vector3DTileContent} content The vector tile content.\n * @param {Cesium3DTileFeature[]} features An array of features where the polygon features will be placed.\n */\nVector3DTileGeometry.prototype.createFeatures = function (content, features) {\n  this._primitive.createFeatures(content, features);\n};\n\n/**\n * Colors the entire tile when enabled is true. The resulting color will be (geometry batch table color * color).\n *\n * @param {Boolean} enabled Whether to enable debug coloring.\n * @param {Color} color The debug color.\n */\nVector3DTileGeometry.prototype.applyDebugSettings = function (enabled, color) {\n  this._primitive.applyDebugSettings(enabled, color);\n};\n\n/**\n * Apply a style to the content.\n *\n * @param {Cesium3DTileStyle} style The style.\n * @param {Cesium3DTileFeature[]} features The array of features.\n */\nVector3DTileGeometry.prototype.applyStyle = function (style, features) {\n  this._primitive.applyStyle(style, features);\n};\n\n/**\n * Call when updating the color of a geometry with batchId changes color. The geometries will need to be re-batched\n * on the next update.\n *\n * @param {Number} batchId The batch id of the geometries whose color has changed.\n * @param {Color} color The new polygon color.\n */\nVector3DTileGeometry.prototype.updateCommands = function (batchId, color) {\n  this._primitive.updateCommands(batchId, color);\n};\n\n/**\n * Updates the batches and queues the commands for rendering.\n *\n * @param {FrameState} frameState The current frame state.\n */\nVector3DTileGeometry.prototype.update = function (frameState) {\n  createPrimitive(this);\n\n  if (!this._ready) {\n    return;\n  }\n\n  this._primitive.debugWireframe = this.debugWireframe;\n  this._primitive.forceRebatch = this.forceRebatch;\n  this._primitive.classificationType = this.classificationType;\n  this._primitive.update(frameState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\nVector3DTileGeometry.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nVector3DTileGeometry.prototype.destroy = function () {\n  this._primitive = this._primitive && this._primitive.destroy();\n  return destroyObject(this);\n};\nexport default Vector3DTileGeometry;\n"]},"metadata":{},"sourceType":"module"}