{"ast":null,"code":"import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nvar RIGHT_SHIFT = 1.0 / 256.0;\nvar LEFT_SHIFT = 256.0;\n/**\n * Attribute compression and decompression functions.\n *\n * @exports AttributeCompression\n *\n * @private\n */\n\nvar AttributeCompression = {};\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-rangeMax] following the 'oct' encoding.\n *\n * Oct encoding is a compact representation of unit length vectors.\n * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\",\n * Cigolle et al 2014: {@link http://jcgt.org/published/0003/02/01/}\n *\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 component 'oct' encoding.\n * @param {Cartesian2} result The 2 component oct-encoded unit length vector.\n * @param {Number} rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\n * @returns {Cartesian2} The 2 component oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n *\n * @see AttributeCompression.octDecodeInRange\n */\n\nAttributeCompression.octEncodeInRange = function (vector, rangeMax, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"vector\", vector);\n  Check.defined(\"result\", result);\n  var magSquared = Cartesian3.magnitudeSquared(vector);\n\n  if (Math.abs(magSquared - 1.0) > CesiumMath.EPSILON6) {\n    throw new DeveloperError(\"vector must be normalized.\");\n  } //>>includeEnd('debug');\n\n\n  result.x = vector.x / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n  result.y = vector.y / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n\n  if (vector.z < 0) {\n    var x = result.x;\n    var y = result.y;\n    result.x = (1.0 - Math.abs(y)) * CesiumMath.signNotZero(x);\n    result.y = (1.0 - Math.abs(x)) * CesiumMath.signNotZero(y);\n  }\n\n  result.x = CesiumMath.toSNorm(result.x, rangeMax);\n  result.y = CesiumMath.toSNorm(result.y, rangeMax);\n  return result;\n};\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding.\n *\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 byte 'oct' encoding.\n * @param {Cartesian2} result The 2 byte oct-encoded unit length vector.\n * @returns {Cartesian2} The 2 byte oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n *\n * @see AttributeCompression.octEncodeInRange\n * @see AttributeCompression.octDecode\n */\n\n\nAttributeCompression.octEncode = function (vector, result) {\n  return AttributeCompression.octEncodeInRange(vector, 255, result);\n};\n\nvar octEncodeScratch = new Cartesian2();\nvar uint8ForceArray = new Uint8Array(1);\n\nfunction forceUint8(value) {\n  uint8ForceArray[0] = value;\n  return uint8ForceArray[0];\n}\n/**\n * @param {Cartesian3} vector The normalized vector to be compressed into 4 byte 'oct' encoding.\n * @param {Cartesian4} result The 4 byte oct-encoded unit length vector.\n * @returns {Cartesian4} The 4 byte oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n *\n * @see AttributeCompression.octEncodeInRange\n * @see AttributeCompression.octDecodeFromCartesian4\n */\n\n\nAttributeCompression.octEncodeToCartesian4 = function (vector, result) {\n  AttributeCompression.octEncodeInRange(vector, 65535, octEncodeScratch);\n  result.x = forceUint8(octEncodeScratch.x * RIGHT_SHIFT);\n  result.y = forceUint8(octEncodeScratch.x);\n  result.z = forceUint8(octEncodeScratch.y * RIGHT_SHIFT);\n  result.w = forceUint8(octEncodeScratch.y);\n  return result;\n};\n/**\n * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component vector.\n *\n * @param {Number} x The x component of the oct-encoded unit length vector.\n * @param {Number} y The y component of the oct-encoded unit length vector.\n * @param {Number} rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\n * @param {Cartesian3} result The decoded and normalized vector\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n * @exception {DeveloperError} x and y must be unsigned normalized integers between 0 and rangeMax.\n *\n * @see AttributeCompression.octEncodeInRange\n */\n\n\nAttributeCompression.octDecodeInRange = function (x, y, rangeMax, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"result\", result);\n\n  if (x < 0 || x > rangeMax || y < 0 || y > rangeMax) {\n    throw new DeveloperError(\"x and y must be unsigned normalized integers between 0 and \" + rangeMax);\n  } //>>includeEnd('debug');\n\n\n  result.x = CesiumMath.fromSNorm(x, rangeMax);\n  result.y = CesiumMath.fromSNorm(y, rangeMax);\n  result.z = 1.0 - (Math.abs(result.x) + Math.abs(result.y));\n\n  if (result.z < 0.0) {\n    var oldVX = result.x;\n    result.x = (1.0 - Math.abs(result.y)) * CesiumMath.signNotZero(oldVX);\n    result.y = (1.0 - Math.abs(oldVX)) * CesiumMath.signNotZero(result.y);\n  }\n\n  return Cartesian3.normalize(result, result);\n};\n/**\n * Decodes a unit-length vector in 2 byte 'oct' encoding to a normalized 3-component vector.\n *\n * @param {Number} x The x component of the oct-encoded unit length vector.\n * @param {Number} y The y component of the oct-encoded unit length vector.\n * @param {Cartesian3} result The decoded and normalized vector.\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n * @exception {DeveloperError} x and y must be an unsigned normalized integer between 0 and 255.\n *\n * @see AttributeCompression.octDecodeInRange\n */\n\n\nAttributeCompression.octDecode = function (x, y, result) {\n  return AttributeCompression.octDecodeInRange(x, y, 255, result);\n};\n/**\n * Decodes a unit-length vector in 4 byte 'oct' encoding to a normalized 3-component vector.\n *\n * @param {Cartesian4} encoded The oct-encoded unit length vector.\n * @param {Cartesian3} result The decoded and normalized vector.\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n * @exception {DeveloperError} x, y, z, and w must be unsigned normalized integers between 0 and 255.\n *\n * @see AttributeCompression.octDecodeInRange\n * @see AttributeCompression.octEncodeToCartesian4\n */\n\n\nAttributeCompression.octDecodeFromCartesian4 = function (encoded, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"encoded\", encoded);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var x = encoded.x;\n  var y = encoded.y;\n  var z = encoded.z;\n  var w = encoded.w; //>>includeStart('debug', pragmas.debug);\n\n  if (x < 0 || x > 255 || y < 0 || y > 255 || z < 0 || z > 255 || w < 0 || w > 255) {\n    throw new DeveloperError(\"x, y, z, and w must be unsigned normalized integers between 0 and 255\");\n  } //>>includeEnd('debug');\n\n\n  var xOct16 = x * LEFT_SHIFT + y;\n  var yOct16 = z * LEFT_SHIFT + w;\n  return AttributeCompression.octDecodeInRange(xOct16, yOct16, 65535, result);\n};\n/**\n * Packs an oct encoded vector into a single floating-point number.\n *\n * @param {Cartesian2} encoded The oct encoded vector.\n * @returns {Number} The oct encoded vector packed into a single float.\n *\n */\n\n\nAttributeCompression.octPackFloat = function (encoded) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"encoded\", encoded); //>>includeEnd('debug');\n\n  return 256.0 * encoded.x + encoded.y;\n};\n\nvar scratchEncodeCart2 = new Cartesian2();\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding and\n * stores those values in a single float-point number.\n *\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 byte 'oct' encoding.\n * @returns {Number} The 2 byte oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n */\n\nAttributeCompression.octEncodeFloat = function (vector) {\n  AttributeCompression.octEncode(vector, scratchEncodeCart2);\n  return AttributeCompression.octPackFloat(scratchEncodeCart2);\n};\n/**\n * Decodes a unit-length vector in 'oct' encoding packed in a floating-point number to a normalized 3-component vector.\n *\n * @param {Number} value The oct-encoded unit length vector stored as a single floating-point number.\n * @param {Cartesian3} result The decoded and normalized vector\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n */\n\n\nAttributeCompression.octDecodeFloat = function (value, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"value\", value); //>>includeEnd('debug');\n\n  var temp = value / 256.0;\n  var x = Math.floor(temp);\n  var y = (temp - x) * 256.0;\n  return AttributeCompression.octDecode(x, y, result);\n};\n/**\n * Encodes three normalized vectors into 6 SNORM values in the range of [0-255] following the 'oct' encoding and\n * packs those into two floating-point numbers.\n *\n * @param {Cartesian3} v1 A normalized vector to be compressed.\n * @param {Cartesian3} v2 A normalized vector to be compressed.\n * @param {Cartesian3} v3 A normalized vector to be compressed.\n * @param {Cartesian2} result The 'oct' encoded vectors packed into two floating-point numbers.\n * @returns {Cartesian2} The 'oct' encoded vectors packed into two floating-point numbers.\n *\n */\n\n\nAttributeCompression.octPack = function (v1, v2, v3, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"v1\", v1);\n  Check.defined(\"v2\", v2);\n  Check.defined(\"v3\", v3);\n  Check.defined(\"result\", result); //>>includeEnd('debug');\n\n  var encoded1 = AttributeCompression.octEncodeFloat(v1);\n  var encoded2 = AttributeCompression.octEncodeFloat(v2);\n  var encoded3 = AttributeCompression.octEncode(v3, scratchEncodeCart2);\n  result.x = 65536.0 * encoded3.x + encoded1;\n  result.y = 65536.0 * encoded3.y + encoded2;\n  return result;\n};\n/**\n * Decodes three unit-length vectors in 'oct' encoding packed into a floating-point number to a normalized 3-component vector.\n *\n * @param {Cartesian2} packed The three oct-encoded unit length vectors stored as two floating-point number.\n * @param {Cartesian3} v1 One decoded and normalized vector.\n * @param {Cartesian3} v2 One decoded and normalized vector.\n * @param {Cartesian3} v3 One decoded and normalized vector.\n */\n\n\nAttributeCompression.octUnpack = function (packed, v1, v2, v3) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"packed\", packed);\n  Check.defined(\"v1\", v1);\n  Check.defined(\"v2\", v2);\n  Check.defined(\"v3\", v3); //>>includeEnd('debug');\n\n  var temp = packed.x / 65536.0;\n  var x = Math.floor(temp);\n  var encodedFloat1 = (temp - x) * 65536.0;\n  temp = packed.y / 65536.0;\n  var y = Math.floor(temp);\n  var encodedFloat2 = (temp - y) * 65536.0;\n  AttributeCompression.octDecodeFloat(encodedFloat1, v1);\n  AttributeCompression.octDecodeFloat(encodedFloat2, v2);\n  AttributeCompression.octDecode(x, y, v3);\n};\n/**\n * Pack texture coordinates into a single float. The texture coordinates will only preserve 12 bits of precision.\n *\n * @param {Cartesian2} textureCoordinates The texture coordinates to compress.  Both coordinates must be in the range 0.0-1.0.\n * @returns {Number} The packed texture coordinates.\n *\n */\n\n\nAttributeCompression.compressTextureCoordinates = function (textureCoordinates) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"textureCoordinates\", textureCoordinates); //>>includeEnd('debug');\n  // Move x and y to the range 0-4095;\n\n  var x = textureCoordinates.x * 4095.0 | 0;\n  var y = textureCoordinates.y * 4095.0 | 0;\n  return 4096.0 * x + y;\n};\n/**\n * Decompresses texture coordinates that were packed into a single float.\n *\n * @param {Number} compressed The compressed texture coordinates.\n * @param {Cartesian2} result The decompressed texture coordinates.\n * @returns {Cartesian2} The modified result parameter.\n *\n */\n\n\nAttributeCompression.decompressTextureCoordinates = function (compressed, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"compressed\", compressed);\n  Check.defined(\"result\", result); //>>includeEnd('debug');\n\n  var temp = compressed / 4096.0;\n  var xZeroTo4095 = Math.floor(temp);\n  result.x = xZeroTo4095 / 4095.0;\n  result.y = (compressed - xZeroTo4095 * 4096) / 4095;\n  return result;\n};\n\nfunction zigZagDecode(value) {\n  return value >> 1 ^ -(value & 1);\n}\n/**\n * Decodes delta and ZigZag encoded vertices. This modifies the buffers in place.\n *\n * @param {Uint16Array} uBuffer The buffer view of u values.\n * @param {Uint16Array} vBuffer The buffer view of v values.\n * @param {Uint16Array} [heightBuffer] The buffer view of height values.\n *\n * @see {@link https://github.com/CesiumGS/quantized-mesh|quantized-mesh-1.0 terrain format}\n */\n\n\nAttributeCompression.zigZagDeltaDecode = function (uBuffer, vBuffer, heightBuffer) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"uBuffer\", uBuffer);\n  Check.defined(\"vBuffer\", vBuffer);\n  Check.typeOf.number.equals(\"uBuffer.length\", \"vBuffer.length\", uBuffer.length, vBuffer.length);\n\n  if (defined(heightBuffer)) {\n    Check.typeOf.number.equals(\"uBuffer.length\", \"heightBuffer.length\", uBuffer.length, heightBuffer.length);\n  } //>>includeEnd('debug');\n\n\n  var count = uBuffer.length;\n  var u = 0;\n  var v = 0;\n  var height = 0;\n\n  for (var i = 0; i < count; ++i) {\n    u += zigZagDecode(uBuffer[i]);\n    v += zigZagDecode(vBuffer[i]);\n    uBuffer[i] = u;\n    vBuffer[i] = v;\n\n    if (defined(heightBuffer)) {\n      height += zigZagDecode(heightBuffer[i]);\n      heightBuffer[i] = height;\n    }\n  }\n};\n\nexport default AttributeCompression;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/AttributeCompression.js"],"names":["Cartesian2","Cartesian3","Check","defined","DeveloperError","CesiumMath","RIGHT_SHIFT","LEFT_SHIFT","AttributeCompression","octEncodeInRange","vector","rangeMax","result","magSquared","magnitudeSquared","Math","abs","EPSILON6","x","y","z","signNotZero","toSNorm","octEncode","octEncodeScratch","uint8ForceArray","Uint8Array","forceUint8","value","octEncodeToCartesian4","w","octDecodeInRange","fromSNorm","oldVX","normalize","octDecode","octDecodeFromCartesian4","encoded","typeOf","object","xOct16","yOct16","octPackFloat","scratchEncodeCart2","octEncodeFloat","octDecodeFloat","temp","floor","octPack","v1","v2","v3","encoded1","encoded2","encoded3","octUnpack","packed","encodedFloat1","encodedFloat2","compressTextureCoordinates","textureCoordinates","decompressTextureCoordinates","compressed","xZeroTo4095","zigZagDecode","zigZagDeltaDecode","uBuffer","vBuffer","heightBuffer","number","equals","length","count","u","v","height","i"],"mappings":"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","sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\nvar RIGHT_SHIFT = 1.0 / 256.0;\nvar LEFT_SHIFT = 256.0;\n\n/**\n * Attribute compression and decompression functions.\n *\n * @exports AttributeCompression\n *\n * @private\n */\nvar AttributeCompression = {};\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-rangeMax] following the 'oct' encoding.\n *\n * Oct encoding is a compact representation of unit length vectors.\n * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\",\n * Cigolle et al 2014: {@link http://jcgt.org/published/0003/02/01/}\n *\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 component 'oct' encoding.\n * @param {Cartesian2} result The 2 component oct-encoded unit length vector.\n * @param {Number} rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\n * @returns {Cartesian2} The 2 component oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n *\n * @see AttributeCompression.octDecodeInRange\n */\nAttributeCompression.octEncodeInRange = function (vector, rangeMax, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"vector\", vector);\n  Check.defined(\"result\", result);\n  var magSquared = Cartesian3.magnitudeSquared(vector);\n  if (Math.abs(magSquared - 1.0) > CesiumMath.EPSILON6) {\n    throw new DeveloperError(\"vector must be normalized.\");\n  }\n  //>>includeEnd('debug');\n\n  result.x =\n    vector.x / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n  result.y =\n    vector.y / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n  if (vector.z < 0) {\n    var x = result.x;\n    var y = result.y;\n    result.x = (1.0 - Math.abs(y)) * CesiumMath.signNotZero(x);\n    result.y = (1.0 - Math.abs(x)) * CesiumMath.signNotZero(y);\n  }\n\n  result.x = CesiumMath.toSNorm(result.x, rangeMax);\n  result.y = CesiumMath.toSNorm(result.y, rangeMax);\n\n  return result;\n};\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding.\n *\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 byte 'oct' encoding.\n * @param {Cartesian2} result The 2 byte oct-encoded unit length vector.\n * @returns {Cartesian2} The 2 byte oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n *\n * @see AttributeCompression.octEncodeInRange\n * @see AttributeCompression.octDecode\n */\nAttributeCompression.octEncode = function (vector, result) {\n  return AttributeCompression.octEncodeInRange(vector, 255, result);\n};\n\nvar octEncodeScratch = new Cartesian2();\nvar uint8ForceArray = new Uint8Array(1);\nfunction forceUint8(value) {\n  uint8ForceArray[0] = value;\n  return uint8ForceArray[0];\n}\n/**\n * @param {Cartesian3} vector The normalized vector to be compressed into 4 byte 'oct' encoding.\n * @param {Cartesian4} result The 4 byte oct-encoded unit length vector.\n * @returns {Cartesian4} The 4 byte oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n *\n * @see AttributeCompression.octEncodeInRange\n * @see AttributeCompression.octDecodeFromCartesian4\n */\nAttributeCompression.octEncodeToCartesian4 = function (vector, result) {\n  AttributeCompression.octEncodeInRange(vector, 65535, octEncodeScratch);\n  result.x = forceUint8(octEncodeScratch.x * RIGHT_SHIFT);\n  result.y = forceUint8(octEncodeScratch.x);\n  result.z = forceUint8(octEncodeScratch.y * RIGHT_SHIFT);\n  result.w = forceUint8(octEncodeScratch.y);\n  return result;\n};\n\n/**\n * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component vector.\n *\n * @param {Number} x The x component of the oct-encoded unit length vector.\n * @param {Number} y The y component of the oct-encoded unit length vector.\n * @param {Number} rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\n * @param {Cartesian3} result The decoded and normalized vector\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n * @exception {DeveloperError} x and y must be unsigned normalized integers between 0 and rangeMax.\n *\n * @see AttributeCompression.octEncodeInRange\n */\nAttributeCompression.octDecodeInRange = function (x, y, rangeMax, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"result\", result);\n  if (x < 0 || x > rangeMax || y < 0 || y > rangeMax) {\n    throw new DeveloperError(\n      \"x and y must be unsigned normalized integers between 0 and \" + rangeMax\n    );\n  }\n  //>>includeEnd('debug');\n\n  result.x = CesiumMath.fromSNorm(x, rangeMax);\n  result.y = CesiumMath.fromSNorm(y, rangeMax);\n  result.z = 1.0 - (Math.abs(result.x) + Math.abs(result.y));\n\n  if (result.z < 0.0) {\n    var oldVX = result.x;\n    result.x = (1.0 - Math.abs(result.y)) * CesiumMath.signNotZero(oldVX);\n    result.y = (1.0 - Math.abs(oldVX)) * CesiumMath.signNotZero(result.y);\n  }\n\n  return Cartesian3.normalize(result, result);\n};\n\n/**\n * Decodes a unit-length vector in 2 byte 'oct' encoding to a normalized 3-component vector.\n *\n * @param {Number} x The x component of the oct-encoded unit length vector.\n * @param {Number} y The y component of the oct-encoded unit length vector.\n * @param {Cartesian3} result The decoded and normalized vector.\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n * @exception {DeveloperError} x and y must be an unsigned normalized integer between 0 and 255.\n *\n * @see AttributeCompression.octDecodeInRange\n */\nAttributeCompression.octDecode = function (x, y, result) {\n  return AttributeCompression.octDecodeInRange(x, y, 255, result);\n};\n\n/**\n * Decodes a unit-length vector in 4 byte 'oct' encoding to a normalized 3-component vector.\n *\n * @param {Cartesian4} encoded The oct-encoded unit length vector.\n * @param {Cartesian3} result The decoded and normalized vector.\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n * @exception {DeveloperError} x, y, z, and w must be unsigned normalized integers between 0 and 255.\n *\n * @see AttributeCompression.octDecodeInRange\n * @see AttributeCompression.octEncodeToCartesian4\n */\nAttributeCompression.octDecodeFromCartesian4 = function (encoded, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"encoded\", encoded);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n  var x = encoded.x;\n  var y = encoded.y;\n  var z = encoded.z;\n  var w = encoded.w;\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    x < 0 ||\n    x > 255 ||\n    y < 0 ||\n    y > 255 ||\n    z < 0 ||\n    z > 255 ||\n    w < 0 ||\n    w > 255\n  ) {\n    throw new DeveloperError(\n      \"x, y, z, and w must be unsigned normalized integers between 0 and 255\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var xOct16 = x * LEFT_SHIFT + y;\n  var yOct16 = z * LEFT_SHIFT + w;\n  return AttributeCompression.octDecodeInRange(xOct16, yOct16, 65535, result);\n};\n\n/**\n * Packs an oct encoded vector into a single floating-point number.\n *\n * @param {Cartesian2} encoded The oct encoded vector.\n * @returns {Number} The oct encoded vector packed into a single float.\n *\n */\nAttributeCompression.octPackFloat = function (encoded) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"encoded\", encoded);\n  //>>includeEnd('debug');\n  return 256.0 * encoded.x + encoded.y;\n};\n\nvar scratchEncodeCart2 = new Cartesian2();\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding and\n * stores those values in a single float-point number.\n *\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 byte 'oct' encoding.\n * @returns {Number} The 2 byte oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n */\nAttributeCompression.octEncodeFloat = function (vector) {\n  AttributeCompression.octEncode(vector, scratchEncodeCart2);\n  return AttributeCompression.octPackFloat(scratchEncodeCart2);\n};\n\n/**\n * Decodes a unit-length vector in 'oct' encoding packed in a floating-point number to a normalized 3-component vector.\n *\n * @param {Number} value The oct-encoded unit length vector stored as a single floating-point number.\n * @param {Cartesian3} result The decoded and normalized vector\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n */\nAttributeCompression.octDecodeFloat = function (value, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"value\", value);\n  //>>includeEnd('debug');\n\n  var temp = value / 256.0;\n  var x = Math.floor(temp);\n  var y = (temp - x) * 256.0;\n\n  return AttributeCompression.octDecode(x, y, result);\n};\n\n/**\n * Encodes three normalized vectors into 6 SNORM values in the range of [0-255] following the 'oct' encoding and\n * packs those into two floating-point numbers.\n *\n * @param {Cartesian3} v1 A normalized vector to be compressed.\n * @param {Cartesian3} v2 A normalized vector to be compressed.\n * @param {Cartesian3} v3 A normalized vector to be compressed.\n * @param {Cartesian2} result The 'oct' encoded vectors packed into two floating-point numbers.\n * @returns {Cartesian2} The 'oct' encoded vectors packed into two floating-point numbers.\n *\n */\nAttributeCompression.octPack = function (v1, v2, v3, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"v1\", v1);\n  Check.defined(\"v2\", v2);\n  Check.defined(\"v3\", v3);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  var encoded1 = AttributeCompression.octEncodeFloat(v1);\n  var encoded2 = AttributeCompression.octEncodeFloat(v2);\n\n  var encoded3 = AttributeCompression.octEncode(v3, scratchEncodeCart2);\n  result.x = 65536.0 * encoded3.x + encoded1;\n  result.y = 65536.0 * encoded3.y + encoded2;\n  return result;\n};\n\n/**\n * Decodes three unit-length vectors in 'oct' encoding packed into a floating-point number to a normalized 3-component vector.\n *\n * @param {Cartesian2} packed The three oct-encoded unit length vectors stored as two floating-point number.\n * @param {Cartesian3} v1 One decoded and normalized vector.\n * @param {Cartesian3} v2 One decoded and normalized vector.\n * @param {Cartesian3} v3 One decoded and normalized vector.\n */\nAttributeCompression.octUnpack = function (packed, v1, v2, v3) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"packed\", packed);\n  Check.defined(\"v1\", v1);\n  Check.defined(\"v2\", v2);\n  Check.defined(\"v3\", v3);\n  //>>includeEnd('debug');\n\n  var temp = packed.x / 65536.0;\n  var x = Math.floor(temp);\n  var encodedFloat1 = (temp - x) * 65536.0;\n\n  temp = packed.y / 65536.0;\n  var y = Math.floor(temp);\n  var encodedFloat2 = (temp - y) * 65536.0;\n\n  AttributeCompression.octDecodeFloat(encodedFloat1, v1);\n  AttributeCompression.octDecodeFloat(encodedFloat2, v2);\n  AttributeCompression.octDecode(x, y, v3);\n};\n\n/**\n * Pack texture coordinates into a single float. The texture coordinates will only preserve 12 bits of precision.\n *\n * @param {Cartesian2} textureCoordinates The texture coordinates to compress.  Both coordinates must be in the range 0.0-1.0.\n * @returns {Number} The packed texture coordinates.\n *\n */\nAttributeCompression.compressTextureCoordinates = function (\n  textureCoordinates\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"textureCoordinates\", textureCoordinates);\n  //>>includeEnd('debug');\n\n  // Move x and y to the range 0-4095;\n  var x = (textureCoordinates.x * 4095.0) | 0;\n  var y = (textureCoordinates.y * 4095.0) | 0;\n  return 4096.0 * x + y;\n};\n\n/**\n * Decompresses texture coordinates that were packed into a single float.\n *\n * @param {Number} compressed The compressed texture coordinates.\n * @param {Cartesian2} result The decompressed texture coordinates.\n * @returns {Cartesian2} The modified result parameter.\n *\n */\nAttributeCompression.decompressTextureCoordinates = function (\n  compressed,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"compressed\", compressed);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  var temp = compressed / 4096.0;\n  var xZeroTo4095 = Math.floor(temp);\n  result.x = xZeroTo4095 / 4095.0;\n  result.y = (compressed - xZeroTo4095 * 4096) / 4095;\n  return result;\n};\n\nfunction zigZagDecode(value) {\n  return (value >> 1) ^ -(value & 1);\n}\n\n/**\n * Decodes delta and ZigZag encoded vertices. This modifies the buffers in place.\n *\n * @param {Uint16Array} uBuffer The buffer view of u values.\n * @param {Uint16Array} vBuffer The buffer view of v values.\n * @param {Uint16Array} [heightBuffer] The buffer view of height values.\n *\n * @see {@link https://github.com/CesiumGS/quantized-mesh|quantized-mesh-1.0 terrain format}\n */\nAttributeCompression.zigZagDeltaDecode = function (\n  uBuffer,\n  vBuffer,\n  heightBuffer\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"uBuffer\", uBuffer);\n  Check.defined(\"vBuffer\", vBuffer);\n  Check.typeOf.number.equals(\n    \"uBuffer.length\",\n    \"vBuffer.length\",\n    uBuffer.length,\n    vBuffer.length\n  );\n  if (defined(heightBuffer)) {\n    Check.typeOf.number.equals(\n      \"uBuffer.length\",\n      \"heightBuffer.length\",\n      uBuffer.length,\n      heightBuffer.length\n    );\n  }\n  //>>includeEnd('debug');\n\n  var count = uBuffer.length;\n\n  var u = 0;\n  var v = 0;\n  var height = 0;\n\n  for (var i = 0; i < count; ++i) {\n    u += zigZagDecode(uBuffer[i]);\n    v += zigZagDecode(vBuffer[i]);\n\n    uBuffer[i] = u;\n    vBuffer[i] = v;\n\n    if (defined(heightBuffer)) {\n      height += zigZagDecode(heightBuffer[i]);\n      heightBuffer[i] = height;\n    }\n  }\n};\nexport default AttributeCompression;\n"]},"metadata":{},"sourceType":"module"}