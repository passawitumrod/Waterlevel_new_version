{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\nimport scaleToGeodeticSurface from \"./scaleToGeodeticSurface.js\";\n/**\n * A position defined by longitude, latitude, and height.\n * @alias Cartographic\n * @constructor\n *\n * @param {Number} [longitude=0.0] The longitude, in radians.\n * @param {Number} [latitude=0.0] The latitude, in radians.\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n *\n * @see Ellipsoid\n */\n\nfunction Cartographic(longitude, latitude, height) {\n  /**\n   * The longitude, in radians.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.longitude = defaultValue(longitude, 0.0);\n  /**\n   * The latitude, in radians.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.latitude = defaultValue(latitude, 0.0);\n  /**\n   * The height, in meters, above the ellipsoid.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.height = defaultValue(height, 0.0);\n}\n/**\n * Creates a new Cartographic instance from longitude and latitude\n * specified in radians.\n *\n * @param {Number} longitude The longitude, in radians.\n * @param {Number} latitude The latitude, in radians.\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\n */\n\n\nCartographic.fromRadians = function (longitude, latitude, height, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"longitude\", longitude);\n  Check.typeOf.number(\"latitude\", latitude); //>>includeEnd('debug');\n\n  height = defaultValue(height, 0.0);\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n/**\n * Creates a new Cartographic instance from longitude and latitude\n * specified in degrees.  The values in the resulting object will\n * be in radians.\n *\n * @param {Number} longitude The longitude, in degrees.\n * @param {Number} latitude The latitude, in degrees.\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\n */\n\n\nCartographic.fromDegrees = function (longitude, latitude, height, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"longitude\", longitude);\n  Check.typeOf.number(\"latitude\", latitude); //>>includeEnd('debug');\n\n  longitude = CesiumMath.toRadians(longitude);\n  latitude = CesiumMath.toRadians(latitude);\n  return Cartographic.fromRadians(longitude, latitude, height, result);\n};\n\nvar cartesianToCartographicN = new Cartesian3();\nvar cartesianToCartographicP = new Cartesian3();\nvar cartesianToCartographicH = new Cartesian3();\nvar wgs84OneOverRadii = new Cartesian3(1.0 / 6378137.0, 1.0 / 6378137.0, 1.0 / 6356752.3142451793);\nvar wgs84OneOverRadiiSquared = new Cartesian3(1.0 / (6378137.0 * 6378137.0), 1.0 / (6378137.0 * 6378137.0), 1.0 / (6356752.3142451793 * 6356752.3142451793));\nvar wgs84CenterToleranceSquared = CesiumMath.EPSILON1;\n/**\n * Creates a new Cartographic instance from a Cartesian position. The values in the\n * resulting object will be in radians.\n *\n * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\n */\n\nCartographic.fromCartesian = function (cartesian, ellipsoid, result) {\n  var oneOverRadii = defined(ellipsoid) ? ellipsoid.oneOverRadii : wgs84OneOverRadii;\n  var oneOverRadiiSquared = defined(ellipsoid) ? ellipsoid.oneOverRadiiSquared : wgs84OneOverRadiiSquared;\n  var centerToleranceSquared = defined(ellipsoid) ? ellipsoid._centerToleranceSquared : wgs84CenterToleranceSquared; //`cartesian is required.` is thrown from scaleToGeodeticSurface\n\n  var p = scaleToGeodeticSurface(cartesian, oneOverRadii, oneOverRadiiSquared, centerToleranceSquared, cartesianToCartographicP);\n\n  if (!defined(p)) {\n    return undefined;\n  }\n\n  var n = Cartesian3.multiplyComponents(p, oneOverRadiiSquared, cartesianToCartographicN);\n  n = Cartesian3.normalize(n, n);\n  var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);\n  var longitude = Math.atan2(n.y, n.x);\n  var latitude = Math.asin(n.z);\n  var height = CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n/**\n * Creates a new Cartesian3 instance from a Cartographic input. The values in the inputted\n * object should be in radians.\n *\n * @param {Cartographic} cartographic Input to be converted into a Cartesian3 output.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n */\n\n\nCartographic.toCartesian = function (cartographic, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartographic\", cartographic); //>>includeEnd('debug');\n\n  return Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, cartographic.height, ellipsoid, result);\n};\n/**\n * Duplicates a Cartographic instance.\n *\n * @param {Cartographic} cartographic The cartographic to duplicate.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided. (Returns undefined if cartographic is undefined)\n */\n\n\nCartographic.clone = function (cartographic, result) {\n  if (!defined(cartographic)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Cartographic(cartographic.longitude, cartographic.latitude, cartographic.height);\n  }\n\n  result.longitude = cartographic.longitude;\n  result.latitude = cartographic.latitude;\n  result.height = cartographic.height;\n  return result;\n};\n/**\n * Compares the provided cartographics componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartographic} [left] The first cartographic.\n * @param {Cartographic} [right] The second cartographic.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\n\n\nCartographic.equals = function (left, right) {\n  return left === right || defined(left) && defined(right) && left.longitude === right.longitude && left.latitude === right.latitude && left.height === right.height;\n};\n/**\n * Compares the provided cartographics componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Cartographic} [left] The first cartographic.\n * @param {Cartographic} [right] The second cartographic.\n * @param {Number} epsilon The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\n\n\nCartographic.equalsEpsilon = function (left, right, epsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"epsilon\", epsilon); //>>includeEnd('debug');\n\n  return left === right || defined(left) && defined(right) && Math.abs(left.longitude - right.longitude) <= epsilon && Math.abs(left.latitude - right.latitude) <= epsilon && Math.abs(left.height - right.height) <= epsilon;\n};\n/**\n * An immutable Cartographic instance initialized to (0.0, 0.0, 0.0).\n *\n * @type {Cartographic}\n * @constant\n */\n\n\nCartographic.ZERO = Object.freeze(new Cartographic(0.0, 0.0, 0.0));\n/**\n * Duplicates this instance.\n *\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\n */\n\nCartographic.prototype.clone = function (result) {\n  return Cartographic.clone(this, result);\n};\n/**\n * Compares the provided against this cartographic componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartographic} [right] The second cartographic.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\n\n\nCartographic.prototype.equals = function (right) {\n  return Cartographic.equals(this, right);\n};\n/**\n * Compares the provided against this cartographic componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Cartographic} [right] The second cartographic.\n * @param {Number} epsilon The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\n\n\nCartographic.prototype.equalsEpsilon = function (right, epsilon) {\n  return Cartographic.equalsEpsilon(this, right, epsilon);\n};\n/**\n * Creates a string representing this cartographic in the format '(longitude, latitude, height)'.\n *\n * @returns {String} A string representing the provided cartographic in the format '(longitude, latitude, height)'.\n */\n\n\nCartographic.prototype.toString = function () {\n  return \"(\" + this.longitude + \", \" + this.latitude + \", \" + this.height + \")\";\n};\n\nexport default Cartographic;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/Cartographic.js"],"names":["Cartesian3","Check","defaultValue","defined","CesiumMath","scaleToGeodeticSurface","Cartographic","longitude","latitude","height","fromRadians","result","typeOf","number","fromDegrees","toRadians","cartesianToCartographicN","cartesianToCartographicP","cartesianToCartographicH","wgs84OneOverRadii","wgs84OneOverRadiiSquared","wgs84CenterToleranceSquared","EPSILON1","fromCartesian","cartesian","ellipsoid","oneOverRadii","oneOverRadiiSquared","centerToleranceSquared","_centerToleranceSquared","p","undefined","n","multiplyComponents","normalize","h","subtract","Math","atan2","y","x","asin","z","sign","dot","magnitude","toCartesian","cartographic","clone","equals","left","right","equalsEpsilon","epsilon","abs","ZERO","Object","freeze","prototype","toString"],"mappings":"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","sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\nimport scaleToGeodeticSurface from \"./scaleToGeodeticSurface.js\";\n\n/**\n * A position defined by longitude, latitude, and height.\n * @alias Cartographic\n * @constructor\n *\n * @param {Number} [longitude=0.0] The longitude, in radians.\n * @param {Number} [latitude=0.0] The latitude, in radians.\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n *\n * @see Ellipsoid\n */\nfunction Cartographic(longitude, latitude, height) {\n  /**\n   * The longitude, in radians.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.longitude = defaultValue(longitude, 0.0);\n\n  /**\n   * The latitude, in radians.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.latitude = defaultValue(latitude, 0.0);\n\n  /**\n   * The height, in meters, above the ellipsoid.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.height = defaultValue(height, 0.0);\n}\n\n/**\n * Creates a new Cartographic instance from longitude and latitude\n * specified in radians.\n *\n * @param {Number} longitude The longitude, in radians.\n * @param {Number} latitude The latitude, in radians.\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\n */\nCartographic.fromRadians = function (longitude, latitude, height, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"longitude\", longitude);\n  Check.typeOf.number(\"latitude\", latitude);\n  //>>includeEnd('debug');\n\n  height = defaultValue(height, 0.0);\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n\n/**\n * Creates a new Cartographic instance from longitude and latitude\n * specified in degrees.  The values in the resulting object will\n * be in radians.\n *\n * @param {Number} longitude The longitude, in degrees.\n * @param {Number} latitude The latitude, in degrees.\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\n */\nCartographic.fromDegrees = function (longitude, latitude, height, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"longitude\", longitude);\n  Check.typeOf.number(\"latitude\", latitude);\n  //>>includeEnd('debug');\n  longitude = CesiumMath.toRadians(longitude);\n  latitude = CesiumMath.toRadians(latitude);\n\n  return Cartographic.fromRadians(longitude, latitude, height, result);\n};\n\nvar cartesianToCartographicN = new Cartesian3();\nvar cartesianToCartographicP = new Cartesian3();\nvar cartesianToCartographicH = new Cartesian3();\nvar wgs84OneOverRadii = new Cartesian3(\n  1.0 / 6378137.0,\n  1.0 / 6378137.0,\n  1.0 / 6356752.3142451793\n);\nvar wgs84OneOverRadiiSquared = new Cartesian3(\n  1.0 / (6378137.0 * 6378137.0),\n  1.0 / (6378137.0 * 6378137.0),\n  1.0 / (6356752.3142451793 * 6356752.3142451793)\n);\nvar wgs84CenterToleranceSquared = CesiumMath.EPSILON1;\n\n/**\n * Creates a new Cartographic instance from a Cartesian position. The values in the\n * resulting object will be in radians.\n *\n * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\n */\nCartographic.fromCartesian = function (cartesian, ellipsoid, result) {\n  var oneOverRadii = defined(ellipsoid)\n    ? ellipsoid.oneOverRadii\n    : wgs84OneOverRadii;\n  var oneOverRadiiSquared = defined(ellipsoid)\n    ? ellipsoid.oneOverRadiiSquared\n    : wgs84OneOverRadiiSquared;\n  var centerToleranceSquared = defined(ellipsoid)\n    ? ellipsoid._centerToleranceSquared\n    : wgs84CenterToleranceSquared;\n\n  //`cartesian is required.` is thrown from scaleToGeodeticSurface\n  var p = scaleToGeodeticSurface(\n    cartesian,\n    oneOverRadii,\n    oneOverRadiiSquared,\n    centerToleranceSquared,\n    cartesianToCartographicP\n  );\n\n  if (!defined(p)) {\n    return undefined;\n  }\n\n  var n = Cartesian3.multiplyComponents(\n    p,\n    oneOverRadiiSquared,\n    cartesianToCartographicN\n  );\n  n = Cartesian3.normalize(n, n);\n\n  var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);\n\n  var longitude = Math.atan2(n.y, n.x);\n  var latitude = Math.asin(n.z);\n  var height =\n    CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n\n/**\n * Creates a new Cartesian3 instance from a Cartographic input. The values in the inputted\n * object should be in radians.\n *\n * @param {Cartographic} cartographic Input to be converted into a Cartesian3 output.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n */\nCartographic.toCartesian = function (cartographic, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  return Cartesian3.fromRadians(\n    cartographic.longitude,\n    cartographic.latitude,\n    cartographic.height,\n    ellipsoid,\n    result\n  );\n};\n\n/**\n * Duplicates a Cartographic instance.\n *\n * @param {Cartographic} cartographic The cartographic to duplicate.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided. (Returns undefined if cartographic is undefined)\n */\nCartographic.clone = function (cartographic, result) {\n  if (!defined(cartographic)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Cartographic(\n      cartographic.longitude,\n      cartographic.latitude,\n      cartographic.height\n    );\n  }\n  result.longitude = cartographic.longitude;\n  result.latitude = cartographic.latitude;\n  result.height = cartographic.height;\n  return result;\n};\n\n/**\n * Compares the provided cartographics componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartographic} [left] The first cartographic.\n * @param {Cartographic} [right] The second cartographic.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartographic.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.longitude === right.longitude &&\n      left.latitude === right.latitude &&\n      left.height === right.height)\n  );\n};\n\n/**\n * Compares the provided cartographics componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Cartographic} [left] The first cartographic.\n * @param {Cartographic} [right] The second cartographic.\n * @param {Number} epsilon The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartographic.equalsEpsilon = function (left, right, epsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"epsilon\", epsilon);\n  //>>includeEnd('debug');\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(left.longitude - right.longitude) <= epsilon &&\n      Math.abs(left.latitude - right.latitude) <= epsilon &&\n      Math.abs(left.height - right.height) <= epsilon)\n  );\n};\n\n/**\n * An immutable Cartographic instance initialized to (0.0, 0.0, 0.0).\n *\n * @type {Cartographic}\n * @constant\n */\nCartographic.ZERO = Object.freeze(new Cartographic(0.0, 0.0, 0.0));\n\n/**\n * Duplicates this instance.\n *\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\n */\nCartographic.prototype.clone = function (result) {\n  return Cartographic.clone(this, result);\n};\n\n/**\n * Compares the provided against this cartographic componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartographic} [right] The second cartographic.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartographic.prototype.equals = function (right) {\n  return Cartographic.equals(this, right);\n};\n\n/**\n * Compares the provided against this cartographic componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Cartographic} [right] The second cartographic.\n * @param {Number} epsilon The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartographic.prototype.equalsEpsilon = function (right, epsilon) {\n  return Cartographic.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this cartographic in the format '(longitude, latitude, height)'.\n *\n * @returns {String} A string representing the provided cartographic in the format '(longitude, latitude, height)'.\n */\nCartographic.prototype.toString = function () {\n  return \"(\" + this.longitude + \", \" + this.latitude + \", \" + this.height + \")\";\n};\nexport default Cartographic;\n"]},"metadata":{},"sourceType":"module"}