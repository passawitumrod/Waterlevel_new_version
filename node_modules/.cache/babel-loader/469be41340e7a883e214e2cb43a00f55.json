{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\n/**\n * Represents a ray that extends infinitely from the provided origin in the provided direction.\n * @alias Ray\n * @constructor\n *\n * @param {Cartesian3} [origin=Cartesian3.ZERO] The origin of the ray.\n * @param {Cartesian3} [direction=Cartesian3.ZERO] The direction of the ray.\n */\n\nfunction Ray(origin, direction) {\n  direction = Cartesian3.clone(defaultValue(direction, Cartesian3.ZERO));\n\n  if (!Cartesian3.equals(direction, Cartesian3.ZERO)) {\n    Cartesian3.normalize(direction, direction);\n  }\n  /**\n   * The origin of the ray.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n\n\n  this.origin = Cartesian3.clone(defaultValue(origin, Cartesian3.ZERO));\n  /**\n   * The direction of the ray.\n   * @type {Cartesian3}\n   */\n\n  this.direction = direction;\n}\n/**\n * Duplicates a Ray instance.\n *\n * @param {Ray} ray The ray to duplicate.\n * @param {Ray} [result] The object onto which to store the result.\n * @returns {Ray} The modified result parameter or a new Ray instance if one was not provided. (Returns undefined if ray is undefined)\n */\n\n\nRay.clone = function (ray, result) {\n  if (!defined(ray)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Ray(ray.origin, ray.direction);\n  }\n\n  result.origin = Cartesian3.clone(ray.origin);\n  result.direction = Cartesian3.clone(ray.direction);\n  return result;\n};\n/**\n * Computes the point along the ray given by r(t) = o + t*d,\n * where o is the origin of the ray and d is the direction.\n *\n * @param {Ray} ray The ray.\n * @param {Number} t A scalar value.\n * @param {Cartesian3} [result] The object in which the result will be stored.\n * @returns {Cartesian3} The modified result parameter, or a new instance if none was provided.\n *\n * @example\n * //Get the first intersection point of a ray and an ellipsoid.\n * var intersection = Cesium.IntersectionTests.rayEllipsoid(ray, ellipsoid);\n * var point = Cesium.Ray.getPoint(ray, intersection.start);\n */\n\n\nRay.getPoint = function (ray, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ray\", ray);\n  Check.typeOf.number(\"t\", t); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  result = Cartesian3.multiplyByScalar(ray.direction, t, result);\n  return Cartesian3.add(ray.origin, result, result);\n};\n\nexport default Ray;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/Ray.js"],"names":["Cartesian3","Check","defaultValue","defined","Ray","origin","direction","clone","ZERO","equals","normalize","ray","result","undefined","getPoint","t","typeOf","object","number","multiplyByScalar","add"],"mappings":"AAAA,OAAOA,UAAP,MAAuB,iBAAvB;AACA,OAAOC,KAAP,MAAkB,YAAlB;AACA,OAAOC,YAAP,MAAyB,mBAAzB;AACA,OAAOC,OAAP,MAAoB,cAApB;AAEA;;;;;;;;;AAQA,SAASC,GAAT,CAAaC,MAAb,EAAqBC,SAArB,EAAgC;AAC9BA,EAAAA,SAAS,GAAGN,UAAU,CAACO,KAAX,CAAiBL,YAAY,CAACI,SAAD,EAAYN,UAAU,CAACQ,IAAvB,CAA7B,CAAZ;;AACA,MAAI,CAACR,UAAU,CAACS,MAAX,CAAkBH,SAAlB,EAA6BN,UAAU,CAACQ,IAAxC,CAAL,EAAoD;AAClDR,IAAAA,UAAU,CAACU,SAAX,CAAqBJ,SAArB,EAAgCA,SAAhC;AACD;AAED;;;;;;;AAKA,OAAKD,MAAL,GAAcL,UAAU,CAACO,KAAX,CAAiBL,YAAY,CAACG,MAAD,EAASL,UAAU,CAACQ,IAApB,CAA7B,CAAd;AAEA;;;;;AAIA,OAAKF,SAAL,GAAiBA,SAAjB;AACD;AAED;;;;;;;;;AAOAF,GAAG,CAACG,KAAJ,GAAY,UAAUI,GAAV,EAAeC,MAAf,EAAuB;AACjC,MAAI,CAACT,OAAO,CAACQ,GAAD,CAAZ,EAAmB;AACjB,WAAOE,SAAP;AACD;;AACD,MAAI,CAACV,OAAO,CAACS,MAAD,CAAZ,EAAsB;AACpB,WAAO,IAAIR,GAAJ,CAAQO,GAAG,CAACN,MAAZ,EAAoBM,GAAG,CAACL,SAAxB,CAAP;AACD;;AACDM,EAAAA,MAAM,CAACP,MAAP,GAAgBL,UAAU,CAACO,KAAX,CAAiBI,GAAG,CAACN,MAArB,CAAhB;AACAO,EAAAA,MAAM,CAACN,SAAP,GAAmBN,UAAU,CAACO,KAAX,CAAiBI,GAAG,CAACL,SAArB,CAAnB;AACA,SAAOM,MAAP;AACD,CAVD;AAYA;;;;;;;;;;;;;;;;AAcAR,GAAG,CAACU,QAAJ,GAAe,UAAUH,GAAV,EAAeI,CAAf,EAAkBH,MAAlB,EAA0B;AACvC;AACAX,EAAAA,KAAK,CAACe,MAAN,CAAaC,MAAb,CAAoB,KAApB,EAA2BN,GAA3B;AACAV,EAAAA,KAAK,CAACe,MAAN,CAAaE,MAAb,CAAoB,GAApB,EAAyBH,CAAzB,EAHuC,CAIvC;;AAEA,MAAI,CAACZ,OAAO,CAACS,MAAD,CAAZ,EAAsB;AACpBA,IAAAA,MAAM,GAAG,IAAIZ,UAAJ,EAAT;AACD;;AAEDY,EAAAA,MAAM,GAAGZ,UAAU,CAACmB,gBAAX,CAA4BR,GAAG,CAACL,SAAhC,EAA2CS,CAA3C,EAA8CH,MAA9C,CAAT;AACA,SAAOZ,UAAU,CAACoB,GAAX,CAAeT,GAAG,CAACN,MAAnB,EAA2BO,MAA3B,EAAmCA,MAAnC,CAAP;AACD,CAZD;;AAaA,eAAeR,GAAf","sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\n\n/**\n * Represents a ray that extends infinitely from the provided origin in the provided direction.\n * @alias Ray\n * @constructor\n *\n * @param {Cartesian3} [origin=Cartesian3.ZERO] The origin of the ray.\n * @param {Cartesian3} [direction=Cartesian3.ZERO] The direction of the ray.\n */\nfunction Ray(origin, direction) {\n  direction = Cartesian3.clone(defaultValue(direction, Cartesian3.ZERO));\n  if (!Cartesian3.equals(direction, Cartesian3.ZERO)) {\n    Cartesian3.normalize(direction, direction);\n  }\n\n  /**\n   * The origin of the ray.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.origin = Cartesian3.clone(defaultValue(origin, Cartesian3.ZERO));\n\n  /**\n   * The direction of the ray.\n   * @type {Cartesian3}\n   */\n  this.direction = direction;\n}\n\n/**\n * Duplicates a Ray instance.\n *\n * @param {Ray} ray The ray to duplicate.\n * @param {Ray} [result] The object onto which to store the result.\n * @returns {Ray} The modified result parameter or a new Ray instance if one was not provided. (Returns undefined if ray is undefined)\n */\nRay.clone = function (ray, result) {\n  if (!defined(ray)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Ray(ray.origin, ray.direction);\n  }\n  result.origin = Cartesian3.clone(ray.origin);\n  result.direction = Cartesian3.clone(ray.direction);\n  return result;\n};\n\n/**\n * Computes the point along the ray given by r(t) = o + t*d,\n * where o is the origin of the ray and d is the direction.\n *\n * @param {Ray} ray The ray.\n * @param {Number} t A scalar value.\n * @param {Cartesian3} [result] The object in which the result will be stored.\n * @returns {Cartesian3} The modified result parameter, or a new instance if none was provided.\n *\n * @example\n * //Get the first intersection point of a ray and an ellipsoid.\n * var intersection = Cesium.IntersectionTests.rayEllipsoid(ray, ellipsoid);\n * var point = Cesium.Ray.getPoint(ray, intersection.start);\n */\nRay.getPoint = function (ray, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ray\", ray);\n  Check.typeOf.number(\"t\", t);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  result = Cartesian3.multiplyByScalar(ray.direction, t, result);\n  return Cartesian3.add(ray.origin, result, result);\n};\nexport default Ray;\n"]},"metadata":{},"sourceType":"module"}