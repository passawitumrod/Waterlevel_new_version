{"ast":null,"code":"var tmp = {};\n/*!\n * protobuf.js v6.7.0 (c) 2016, Daniel Wirtz\n * Compiled Wed, 22 Mar 2017 17:30:26 UTC\n * Licensed under the BSD-3-Clause License\n * see: https://github.com/dcodeIO/protobuf.js for details\n */\n\n(function (global, undefined) {\n  \"use strict\";\n\n  (function prelude(modules, cache, entries) {\n    // This is the prelude used to bundle protobuf.js for the browser. Wraps up the CommonJS\n    // sources through a conflict-free require shim and is again wrapped within an iife that\n    // provides a unified `global` and a minification-friendly `undefined` var plus a global\n    // \"use strict\" directive so that minification can remove the directives of each module.\n    function $require(name) {\n      var $module = cache[name];\n      if (!$module) modules[name][0].call($module = cache[name] = {\n        exports: {}\n      }, $require, $module, $module.exports);\n      return $module.exports;\n    } // Expose globally\n\n\n    var protobuf = global.protobuf = $require(entries[0]); // Commented out to avoid polluing the global scope in Node.js\n    // // Be nice to AMD\n    // if (typeof define === \"function\" && define.amd)\n    //     define([], function() {\n    //         protobuf.configure();\n    //         return protobuf;\n    //     });\n    // // Be nice to CommonJS\n    // if (typeof module === \"object\" && module && module.exports)\n    //     module.exports = protobuf;\n  })(\n  /* end of prelude */\n  {\n    1: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = asPromise;\n      /**\n       * Returns a promise from a node-style callback function.\n       * @memberof util\n       * @param {function(?Error, ...*)} fn Function to call\n       * @param {*} ctx Function context\n       * @param {...*} params Function arguments\n       * @returns {Promise<*>} Promisified function\n       */\n\n      function asPromise(fn, ctx\n      /*, varargs */\n      ) {\n        var params = [];\n\n        for (var i = 2; i < arguments.length;) params.push(arguments[i++]);\n\n        var pending = true;\n        return new Promise(function asPromiseExecutor(resolve, reject) {\n          params.push(function asPromiseCallback(err\n          /*, varargs */\n          ) {\n            if (pending) {\n              pending = false;\n              if (err) reject(err);else {\n                var args = [];\n\n                for (var i = 1; i < arguments.length;) args.push(arguments[i++]);\n\n                resolve.apply(null, args);\n              }\n            }\n          });\n\n          try {\n            fn.apply(ctx || this, params); // eslint-disable-line no-invalid-this\n          } catch (err) {\n            if (pending) {\n              pending = false;\n              reject(err);\n            }\n          }\n        });\n      }\n    }, {}],\n    2: [function (require, module, exports) {\n      \"use strict\";\n      /**\n       * A minimal base64 implementation for number arrays.\n       * @memberof util\n       * @namespace\n       */\n\n      var base64 = exports;\n      /**\n       * Calculates the byte length of a base64 encoded string.\n       * @param {string} string Base64 encoded string\n       * @returns {number} Byte length\n       */\n\n      base64.length = function length(string) {\n        var p = string.length;\n        if (!p) return 0;\n        var n = 0;\n\n        while (--p % 4 > 1 && string.charAt(p) === \"=\") ++n;\n\n        return Math.ceil(string.length * 3) / 4 - n;\n      }; // Base64 encoding table\n\n\n      var b64 = new Array(64); // Base64 decoding table\n\n      var s64 = new Array(123); // 65..90, 97..122, 48..57, 43, 47\n\n      for (var i = 0; i < 64;) s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\n      /**\n       * Encodes a buffer to a base64 encoded string.\n       * @param {Uint8Array} buffer Source buffer\n       * @param {number} start Source start\n       * @param {number} end Source end\n       * @returns {string} Base64 encoded string\n       */\n\n\n      base64.encode = function encode(buffer, start, end) {\n        var string = []; // alt: new Array(Math.ceil((end - start) / 3) * 4);\n\n        var i = 0,\n            // output index\n        j = 0,\n            // goto index\n        t; // temporary\n\n        while (start < end) {\n          var b = buffer[start++];\n\n          switch (j) {\n            case 0:\n              string[i++] = b64[b >> 2];\n              t = (b & 3) << 4;\n              j = 1;\n              break;\n\n            case 1:\n              string[i++] = b64[t | b >> 4];\n              t = (b & 15) << 2;\n              j = 2;\n              break;\n\n            case 2:\n              string[i++] = b64[t | b >> 6];\n              string[i++] = b64[b & 63];\n              j = 0;\n              break;\n          }\n        }\n\n        if (j) {\n          string[i++] = b64[t];\n          string[i] = 61;\n          if (j === 1) string[i + 1] = 61;\n        }\n\n        return String.fromCharCode.apply(String, string);\n      };\n\n      var invalidEncoding = \"invalid encoding\";\n      /**\n       * Decodes a base64 encoded string to a buffer.\n       * @param {string} string Source string\n       * @param {Uint8Array} buffer Destination buffer\n       * @param {number} offset Destination offset\n       * @returns {number} Number of bytes written\n       * @throws {Error} If encoding is invalid\n       */\n\n      base64.decode = function decode(string, buffer, offset) {\n        var start = offset;\n        var j = 0,\n            // goto index\n        t; // temporary\n\n        for (var i = 0; i < string.length;) {\n          var c = string.charCodeAt(i++);\n          if (c === 61 && j > 1) break;\n          if ((c = s64[c]) === undefined) throw Error(invalidEncoding);\n\n          switch (j) {\n            case 0:\n              t = c;\n              j = 1;\n              break;\n\n            case 1:\n              buffer[offset++] = t << 2 | (c & 48) >> 4;\n              t = c;\n              j = 2;\n              break;\n\n            case 2:\n              buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\n              t = c;\n              j = 3;\n              break;\n\n            case 3:\n              buffer[offset++] = (t & 3) << 6 | c;\n              j = 0;\n              break;\n          }\n        }\n\n        if (j === 1) throw Error(invalidEncoding);\n        return offset - start;\n      };\n      /**\n       * Tests if the specified string appears to be base64 encoded.\n       * @param {string} string String to test\n       * @returns {boolean} `true` if probably base64 encoded, otherwise false\n       */\n\n\n      base64.test = function test(string) {\n        return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\n      };\n    }, {}],\n    3: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = EventEmitter;\n      /**\n       * Constructs a new event emitter instance.\n       * @classdesc A minimal event emitter.\n       * @memberof util\n       * @constructor\n       */\n\n      function EventEmitter() {\n        /**\n         * Registered listeners.\n         * @type {Object.<string,*>}\n         * @private\n         */\n        this._listeners = {};\n      }\n      /**\n       * Registers an event listener.\n       * @param {string} evt Event name\n       * @param {function} fn Listener\n       * @param {*} [ctx] Listener context\n       * @returns {util.EventEmitter} `this`\n       */\n\n\n      EventEmitter.prototype.on = function on(evt, fn, ctx) {\n        (this._listeners[evt] || (this._listeners[evt] = [])).push({\n          fn: fn,\n          ctx: ctx || this\n        });\n        return this;\n      };\n      /**\n       * Removes an event listener or any matching listeners if arguments are omitted.\n       * @param {string} [evt] Event name. Removes all listeners if omitted.\n       * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\n       * @returns {util.EventEmitter} `this`\n       */\n\n\n      EventEmitter.prototype.off = function off(evt, fn) {\n        if (evt === undefined) this._listeners = {};else {\n          if (fn === undefined) this._listeners[evt] = [];else {\n            var listeners = this._listeners[evt];\n\n            for (var i = 0; i < listeners.length;) if (listeners[i].fn === fn) listeners.splice(i, 1);else ++i;\n          }\n        }\n        return this;\n      };\n      /**\n       * Emits an event by calling its listeners with the specified arguments.\n       * @param {string} evt Event name\n       * @param {...*} args Arguments\n       * @returns {util.EventEmitter} `this`\n       */\n\n\n      EventEmitter.prototype.emit = function emit(evt) {\n        var listeners = this._listeners[evt];\n\n        if (listeners) {\n          var args = [],\n              i = 1;\n\n          for (; i < arguments.length;) args.push(arguments[i++]);\n\n          for (i = 0; i < listeners.length;) listeners[i].fn.apply(listeners[i++].ctx, args);\n        }\n\n        return this;\n      };\n    }, {}],\n    4: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = inquire;\n      /**\n       * Requires a module only if available.\n       * @memberof util\n       * @param {string} moduleName Module to require\n       * @returns {?Object} Required module if available and not empty, otherwise `null`\n       */\n\n      function inquire(moduleName) {\n        try {\n          var mod = eval(\"quire\".replace(/^/, \"re\"))(moduleName); // eslint-disable-line no-eval\n\n          if (mod && (mod.length || Object.keys(mod).length)) return mod;\n        } catch (e) {} // eslint-disable-line no-empty\n\n\n        return null;\n      }\n    }, {}],\n    5: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = pool;\n      /**\n       * An allocator as used by {@link util.pool}.\n       * @typedef PoolAllocator\n       * @type {function}\n       * @param {number} size Buffer size\n       * @returns {Uint8Array} Buffer\n       */\n\n      /**\n       * A slicer as used by {@link util.pool}.\n       * @typedef PoolSlicer\n       * @type {function}\n       * @param {number} start Start offset\n       * @param {number} end End offset\n       * @returns {Uint8Array} Buffer slice\n       * @this {Uint8Array}\n       */\n\n      /**\n       * A general purpose buffer pool.\n       * @memberof util\n       * @function\n       * @param {PoolAllocator} alloc Allocator\n       * @param {PoolSlicer} slice Slicer\n       * @param {number} [size=8192] Slab size\n       * @returns {PoolAllocator} Pooled allocator\n       */\n\n      function pool(alloc, slice, size) {\n        var SIZE = size || 8192;\n        var MAX = SIZE >>> 1;\n        var slab = null;\n        var offset = SIZE;\n        return function pool_alloc(size) {\n          if (size < 1 || size > MAX) return alloc(size);\n\n          if (offset + size > SIZE) {\n            slab = alloc(SIZE);\n            offset = 0;\n          }\n\n          var buf = slice.call(slab, offset, offset += size);\n          if (offset & 7) // align to 32 bit\n            offset = (offset | 7) + 1;\n          return buf;\n        };\n      }\n    }, {}],\n    6: [function (require, module, exports) {\n      \"use strict\";\n      /**\n       * A minimal UTF8 implementation for number arrays.\n       * @memberof util\n       * @namespace\n       */\n\n      var utf8 = exports;\n      /**\n       * Calculates the UTF8 byte length of a string.\n       * @param {string} string String\n       * @returns {number} Byte length\n       */\n\n      utf8.length = function utf8_length(string) {\n        var len = 0,\n            c = 0;\n\n        for (var i = 0; i < string.length; ++i) {\n          c = string.charCodeAt(i);\n          if (c < 128) len += 1;else if (c < 2048) len += 2;else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\n            ++i;\n            len += 4;\n          } else len += 3;\n        }\n\n        return len;\n      };\n      /**\n       * Reads UTF8 bytes as a string.\n       * @param {Uint8Array} buffer Source buffer\n       * @param {number} start Source start\n       * @param {number} end Source end\n       * @returns {string} String read\n       */\n\n\n      utf8.read = function utf8_read(buffer, start, end) {\n        var len = end - start;\n        if (len < 1) return \"\";\n        var parts = null,\n            chunk = [],\n            i = 0,\n            // char offset\n        t; // temporary\n\n        while (start < end) {\n          t = buffer[start++];\n          if (t < 128) chunk[i++] = t;else if (t > 191 && t < 224) chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;else if (t > 239 && t < 365) {\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\n            chunk[i++] = 0xD800 + (t >> 10);\n            chunk[i++] = 0xDC00 + (t & 1023);\n          } else chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\n\n          if (i > 8191) {\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n            i = 0;\n          }\n        }\n\n        if (parts) {\n          if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n          return parts.join(\"\");\n        }\n\n        return String.fromCharCode.apply(String, chunk.slice(0, i));\n      };\n      /**\n       * Writes a string as UTF8 bytes.\n       * @param {string} string Source string\n       * @param {Uint8Array} buffer Destination buffer\n       * @param {number} offset Destination offset\n       * @returns {number} Bytes written\n       */\n\n\n      utf8.write = function utf8_write(string, buffer, offset) {\n        var start = offset,\n            c1,\n            // character 1\n        c2; // character 2\n\n        for (var i = 0; i < string.length; ++i) {\n          c1 = string.charCodeAt(i);\n\n          if (c1 < 128) {\n            buffer[offset++] = c1;\n          } else if (c1 < 2048) {\n            buffer[offset++] = c1 >> 6 | 192;\n            buffer[offset++] = c1 & 63 | 128;\n          } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\n            ++i;\n            buffer[offset++] = c1 >> 18 | 240;\n            buffer[offset++] = c1 >> 12 & 63 | 128;\n            buffer[offset++] = c1 >> 6 & 63 | 128;\n            buffer[offset++] = c1 & 63 | 128;\n          } else {\n            buffer[offset++] = c1 >> 12 | 224;\n            buffer[offset++] = c1 >> 6 & 63 | 128;\n            buffer[offset++] = c1 & 63 | 128;\n          }\n        }\n\n        return offset - start;\n      };\n    }, {}],\n    7: [function (require, module, exports) {\n      \"use strict\";\n\n      var protobuf = exports;\n      /**\n       * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n       * @name build\n       * @type {string}\n       * @const\n       */\n\n      protobuf.build = \"minimal\";\n      /**\n       * Named roots.\n       * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n       * Can also be used manually to make roots available accross modules.\n       * @name roots\n       * @type {Object.<string,Root>}\n       * @example\n       * // pbjs -r myroot -o compiled.js ...\n       *\n       * // in another module:\n       * require(\"./compiled.js\");\n       *\n       * // in any subsequent module:\n       * var root = protobuf.roots[\"myroot\"];\n       */\n\n      protobuf.roots = {}; // Serialization\n\n      protobuf.Writer = require(14);\n      protobuf.BufferWriter = require(15);\n      protobuf.Reader = require(8);\n      protobuf.BufferReader = require(9); // Utility\n\n      protobuf.util = require(13);\n      protobuf.rpc = require(10);\n      protobuf.configure = configure;\n      /* istanbul ignore next */\n\n      /**\n       * Reconfigures the library according to the environment.\n       * @returns {undefined}\n       */\n\n      function configure() {\n        protobuf.Reader._configure(protobuf.BufferReader);\n\n        protobuf.util._configure();\n      } // Configure serialization\n\n\n      protobuf.Writer._configure(protobuf.BufferWriter);\n\n      configure();\n    }, {\n      \"10\": 10,\n      \"13\": 13,\n      \"14\": 14,\n      \"15\": 15,\n      \"8\": 8,\n      \"9\": 9\n    }],\n    8: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = Reader;\n\n      var util = require(13);\n\n      var BufferReader; // cyclic\n\n      var LongBits = util.LongBits,\n          utf8 = util.utf8;\n      /* istanbul ignore next */\n\n      function indexOutOfRange(reader, writeLength) {\n        return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n      }\n      /**\n       * Constructs a new reader instance using the specified buffer.\n       * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n       * @constructor\n       * @param {Uint8Array} buffer Buffer to read from\n       */\n\n\n      function Reader(buffer) {\n        /**\n         * Read buffer.\n         * @type {Uint8Array}\n         */\n        this.buf = buffer;\n        /**\n         * Read buffer position.\n         * @type {number}\n         */\n\n        this.pos = 0;\n        /**\n         * Read buffer length.\n         * @type {number}\n         */\n\n        this.len = buffer.length;\n      }\n\n      var create_array = typeof Uint8Array !== \"undefined\" ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer)) return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n      }\n      /* istanbul ignore next */\n      : function create_array(buffer) {\n        if (Array.isArray(buffer)) return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n      };\n      /**\n       * Creates a new reader using the specified buffer.\n       * @function\n       * @param {Uint8Array|Buffer} buffer Buffer to read from\n       * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n       * @throws {Error} If `buffer` is not a valid buffer\n       */\n\n      Reader.create = util.Buffer ? function create_buffer_setup(buffer) {\n        return (Reader.create = function create_buffer(buffer) {\n          return util.Buffer.isBuffer(buffer) ? new BufferReader(buffer)\n          /* istanbul ignore next */\n          : create_array(buffer);\n        })(buffer);\n      }\n      /* istanbul ignore next */\n      : create_array;\n      Reader.prototype._slice = util.Array.prototype.subarray ||\n      /* istanbul ignore next */\n      util.Array.prototype.slice;\n      /**\n       * Reads a varint as an unsigned 32 bit value.\n       * @function\n       * @returns {number} Value read\n       */\n\n      Reader.prototype.uint32 = function read_uint32_setup() {\n        var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n\n        return function read_uint32() {\n          value = (this.buf[this.pos] & 127) >>> 0;\n          if (this.buf[this.pos++] < 128) return value;\n          value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;\n          if (this.buf[this.pos++] < 128) return value;\n          value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;\n          if (this.buf[this.pos++] < 128) return value;\n          value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;\n          if (this.buf[this.pos++] < 128) return value;\n          value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;\n          if (this.buf[this.pos++] < 128) return value;\n          /* istanbul ignore next */\n\n          if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n          }\n\n          return value;\n        };\n      }();\n      /**\n       * Reads a varint as a signed 32 bit value.\n       * @returns {number} Value read\n       */\n\n\n      Reader.prototype.int32 = function read_int32() {\n        return this.uint32() | 0;\n      };\n      /**\n       * Reads a zig-zag encoded varint as a signed 32 bit value.\n       * @returns {number} Value read\n       */\n\n\n      Reader.prototype.sint32 = function read_sint32() {\n        var value = this.uint32();\n        return value >>> 1 ^ -(value & 1) | 0;\n      };\n      /* eslint-disable no-invalid-this */\n\n\n      function readLongVarint() {\n        // tends to deopt with local vars for octet etc.\n        var bits = new LongBits(0, 0);\n        var i = 0;\n\n        if (this.len - this.pos > 4) {\n          // fast route (lo)\n          for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128) return bits;\n          } // 5th\n\n\n          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n          bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;\n          if (this.buf[this.pos++] < 128) return bits;\n          i = 0;\n        } else {\n          for (; i < 3; ++i) {\n            /* istanbul ignore next */\n            if (this.pos >= this.len) throw indexOutOfRange(this); // 1st..3th\n\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128) return bits;\n          } // 4th\n\n\n          bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n          return bits;\n        }\n\n        if (this.len - this.pos > 4) {\n          // fast route (hi)\n          for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128) return bits;\n          }\n        } else {\n          for (; i < 5; ++i) {\n            /* istanbul ignore next */\n            if (this.pos >= this.len) throw indexOutOfRange(this); // 6th..10th\n\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128) return bits;\n          }\n        }\n        /* istanbul ignore next */\n\n\n        throw Error(\"invalid varint encoding\");\n      }\n      /* eslint-enable no-invalid-this */\n\n      /**\n       * Reads a varint as a signed 64 bit value.\n       * @name Reader#int64\n       * @function\n       * @returns {Long|number} Value read\n       */\n\n      /**\n       * Reads a varint as an unsigned 64 bit value.\n       * @name Reader#uint64\n       * @function\n       * @returns {Long|number} Value read\n       */\n\n      /**\n       * Reads a zig-zag encoded varint as a signed 64 bit value.\n       * @name Reader#sint64\n       * @function\n       * @returns {Long|number} Value read\n       */\n\n      /**\n       * Reads a varint as a boolean.\n       * @returns {boolean} Value read\n       */\n\n\n      Reader.prototype.bool = function read_bool() {\n        return this.uint32() !== 0;\n      };\n\n      function readFixed32(buf, end) {\n        return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;\n      }\n      /**\n       * Reads fixed 32 bits as an unsigned 32 bit integer.\n       * @returns {number} Value read\n       */\n\n\n      Reader.prototype.fixed32 = function read_fixed32() {\n        /* istanbul ignore next */\n        if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);\n        return readFixed32(this.buf, this.pos += 4);\n      };\n      /**\n       * Reads fixed 32 bits as a signed 32 bit integer.\n       * @returns {number} Value read\n       */\n\n\n      Reader.prototype.sfixed32 = function read_sfixed32() {\n        /* istanbul ignore next */\n        if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);\n        return readFixed32(this.buf, this.pos += 4) | 0;\n      };\n      /* eslint-disable no-invalid-this */\n\n\n      function readFixed64()\n      /* this: Reader */\n      {\n        /* istanbul ignore next */\n        if (this.pos + 8 > this.len) throw indexOutOfRange(this, 8);\n        return new LongBits(readFixed32(this.buf, this.pos += 4), readFixed32(this.buf, this.pos += 4));\n      }\n      /* eslint-enable no-invalid-this */\n\n      /**\n       * Reads fixed 64 bits.\n       * @name Reader#fixed64\n       * @function\n       * @returns {Long|number} Value read\n       */\n\n      /**\n       * Reads zig-zag encoded fixed 64 bits.\n       * @name Reader#sfixed64\n       * @function\n       * @returns {Long|number} Value read\n       */\n\n\n      var readFloat = typeof Float32Array !== \"undefined\" ? function () {\n        var f32 = new Float32Array(1),\n            f8b = new Uint8Array(f32.buffer);\n        f32[0] = -0;\n        return f8b[3] // already le?\n        ? function readFloat_f32(buf, pos) {\n          f8b[0] = buf[pos];\n          f8b[1] = buf[pos + 1];\n          f8b[2] = buf[pos + 2];\n          f8b[3] = buf[pos + 3];\n          return f32[0];\n        }\n        /* istanbul ignore next */\n        : function readFloat_f32_le(buf, pos) {\n          f8b[0] = buf[pos + 3];\n          f8b[1] = buf[pos + 2];\n          f8b[2] = buf[pos + 1];\n          f8b[3] = buf[pos];\n          return f32[0];\n        };\n      }()\n      /* istanbul ignore next */\n      : function readFloat_ieee754(buf, pos) {\n        var uint = readFixed32(buf, pos + 4),\n            sign = (uint >> 31) * 2 + 1,\n            exponent = uint >>> 23 & 255,\n            mantissa = uint & 8388607;\n        return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 // denormal\n        ? sign * 1.401298464324817e-45 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\n      };\n      /**\n       * Reads a float (32 bit) as a number.\n       * @function\n       * @returns {number} Value read\n       */\n\n      Reader.prototype.float = function read_float() {\n        /* istanbul ignore next */\n        if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);\n        var value = readFloat(this.buf, this.pos);\n        this.pos += 4;\n        return value;\n      };\n\n      var readDouble = typeof Float64Array !== \"undefined\" ? function () {\n        var f64 = new Float64Array(1),\n            f8b = new Uint8Array(f64.buffer);\n        f64[0] = -0;\n        return f8b[7] // already le?\n        ? function readDouble_f64(buf, pos) {\n          f8b[0] = buf[pos];\n          f8b[1] = buf[pos + 1];\n          f8b[2] = buf[pos + 2];\n          f8b[3] = buf[pos + 3];\n          f8b[4] = buf[pos + 4];\n          f8b[5] = buf[pos + 5];\n          f8b[6] = buf[pos + 6];\n          f8b[7] = buf[pos + 7];\n          return f64[0];\n        }\n        /* istanbul ignore next */\n        : function readDouble_f64_le(buf, pos) {\n          f8b[0] = buf[pos + 7];\n          f8b[1] = buf[pos + 6];\n          f8b[2] = buf[pos + 5];\n          f8b[3] = buf[pos + 4];\n          f8b[4] = buf[pos + 3];\n          f8b[5] = buf[pos + 2];\n          f8b[6] = buf[pos + 1];\n          f8b[7] = buf[pos];\n          return f64[0];\n        };\n      }()\n      /* istanbul ignore next */\n      : function readDouble_ieee754(buf, pos) {\n        var lo = readFixed32(buf, pos + 4),\n            hi = readFixed32(buf, pos + 8);\n        var sign = (hi >> 31) * 2 + 1,\n            exponent = hi >>> 20 & 2047,\n            mantissa = 4294967296 * (hi & 1048575) + lo;\n        return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 // denormal\n        ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\n      };\n      /**\n       * Reads a double (64 bit float) as a number.\n       * @function\n       * @returns {number} Value read\n       */\n\n      Reader.prototype.double = function read_double() {\n        /* istanbul ignore next */\n        if (this.pos + 8 > this.len) throw indexOutOfRange(this, 4);\n        var value = readDouble(this.buf, this.pos);\n        this.pos += 8;\n        return value;\n      };\n      /**\n       * Reads a sequence of bytes preceeded by its length as a varint.\n       * @returns {Uint8Array} Value read\n       */\n\n\n      Reader.prototype.bytes = function read_bytes() {\n        var length = this.uint32(),\n            start = this.pos,\n            end = this.pos + length;\n        /* istanbul ignore next */\n\n        if (end > this.len) throw indexOutOfRange(this, length);\n        this.pos += length;\n        return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1\n        ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);\n      };\n      /**\n       * Reads a string preceeded by its byte length as a varint.\n       * @returns {string} Value read\n       */\n\n\n      Reader.prototype.string = function read_string() {\n        var bytes = this.bytes();\n        return utf8.read(bytes, 0, bytes.length);\n      };\n      /**\n       * Skips the specified number of bytes if specified, otherwise skips a varint.\n       * @param {number} [length] Length if known, otherwise a varint is assumed\n       * @returns {Reader} `this`\n       */\n\n\n      Reader.prototype.skip = function skip(length) {\n        if (typeof length === \"number\") {\n          /* istanbul ignore next */\n          if (this.pos + length > this.len) throw indexOutOfRange(this, length);\n          this.pos += length;\n        } else {\n          /* istanbul ignore next */\n          do {\n            if (this.pos >= this.len) throw indexOutOfRange(this);\n          } while (this.buf[this.pos++] & 128);\n        }\n\n        return this;\n      };\n      /**\n       * Skips the next element of the specified wire type.\n       * @param {number} wireType Wire type received\n       * @returns {Reader} `this`\n       */\n\n\n      Reader.prototype.skipType = function (wireType) {\n        switch (wireType) {\n          case 0:\n            this.skip();\n            break;\n\n          case 1:\n            this.skip(8);\n            break;\n\n          case 2:\n            this.skip(this.uint32());\n            break;\n\n          case 3:\n            do {\n              // eslint-disable-line no-constant-condition\n              if ((wireType = this.uint32() & 7) === 4) break;\n              this.skipType(wireType);\n            } while (true);\n\n            break;\n\n          case 5:\n            this.skip(4);\n            break;\n\n          /* istanbul ignore next */\n\n          default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n        }\n\n        return this;\n      };\n\n      Reader._configure = function (BufferReader_) {\n        BufferReader = BufferReader_;\n        var fn = util.Long ? \"toLong\" :\n        /* istanbul ignore next */\n        \"toNumber\";\n        util.merge(Reader.prototype, {\n          int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n          },\n          uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n          },\n          sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n          },\n          fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n          },\n          sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n          }\n        });\n      };\n    }, {\n      \"13\": 13\n    }],\n    9: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = BufferReader; // extends Reader\n\n      var Reader = require(8);\n\n      (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\n      var util = require(13);\n      /**\n       * Constructs a new buffer reader instance.\n       * @classdesc Wire format reader using node buffers.\n       * @extends Reader\n       * @constructor\n       * @param {Buffer} buffer Buffer to read from\n       */\n\n\n      function BufferReader(buffer) {\n        Reader.call(this, buffer);\n        /**\n         * Read buffer.\n         * @name BufferReader#buf\n         * @type {Buffer}\n         */\n      }\n      /* istanbul ignore else */\n\n\n      if (util.Buffer) BufferReader.prototype._slice = util.Buffer.prototype.slice;\n      /**\n       * @override\n       */\n\n      BufferReader.prototype.string = function read_string_buffer() {\n        var len = this.uint32(); // modifies pos\n\n        return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));\n      };\n      /**\n       * Reads a sequence of bytes preceeded by its length as a varint.\n       * @name BufferReader#bytes\n       * @function\n       * @returns {Buffer} Value read\n       */\n\n    }, {\n      \"13\": 13,\n      \"8\": 8\n    }],\n    10: [function (require, module, exports) {\n      \"use strict\";\n      /**\n       * Streaming RPC helpers.\n       * @namespace\n       */\n\n      var rpc = exports;\n      /**\n       * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n       * @typedef RPCImpl\n       * @type {function}\n       * @param {Method|rpc.ServiceMethod} method Reflected or static method being called\n       * @param {Uint8Array} requestData Request data\n       * @param {RPCImplCallback} callback Callback function\n       * @returns {undefined}\n       * @example\n       * function rpcImpl(method, requestData, callback) {\n       *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n       *         throw Error(\"no such method\");\n       *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n       *         callback(err, responseData);\n       *     });\n       * }\n       */\n\n      /**\n       * Node-style callback as used by {@link RPCImpl}.\n       * @typedef RPCImplCallback\n       * @type {function}\n       * @param {?Error} error Error, if any, otherwise `null`\n       * @param {?Uint8Array} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n       * @returns {undefined}\n       */\n\n      rpc.Service = require(11);\n    }, {\n      \"11\": 11\n    }],\n    11: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = Service;\n\n      var util = require(13); // Extends EventEmitter\n\n\n      (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n      /**\n       * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n       *\n       * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n       * @typedef rpc.ServiceMethodCallback\n       * @type {function}\n       * @param {?Error} error Error, if any\n       * @param {?Message} [response] Response message\n       * @returns {undefined}\n       */\n\n      /**\n       * A service method part of a {@link rpc.ServiceMethodMixin|ServiceMethodMixin} and thus {@link rpc.Service} as created by {@link Service.create}.\n       * @typedef rpc.ServiceMethod\n       * @type {function}\n       * @param {Message|Object.<string,*>} request Request message or plain object\n       * @param {rpc.ServiceMethodCallback} [callback] Node-style callback called with the error, if any, and the response message\n       * @returns {Promise<Message>} Promise if `callback` has been omitted, otherwise `undefined`\n       */\n\n      /**\n       * A service method mixin.\n       *\n       * When using TypeScript, mixed in service methods are only supported directly with a type definition of a static module (used with reflection). Otherwise, explicit casting is required.\n       * @typedef rpc.ServiceMethodMixin\n       * @type {Object.<string,rpc.ServiceMethod>}\n       * @example\n       * // Explicit casting with TypeScript\n       * (myRpcService[\"myMethod\"] as protobuf.rpc.ServiceMethod)(...)\n       */\n\n      /**\n       * Constructs a new RPC service instance.\n       * @classdesc An RPC service as returned by {@link Service#create}.\n       * @exports rpc.Service\n       * @extends util.EventEmitter\n       * @augments rpc.ServiceMethodMixin\n       * @constructor\n       * @param {RPCImpl} rpcImpl RPC implementation\n       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n       */\n\n      function Service(rpcImpl, requestDelimited, responseDelimited) {\n        if (typeof rpcImpl !== \"function\") throw TypeError(\"rpcImpl must be a function\");\n        util.EventEmitter.call(this);\n        /**\n         * RPC implementation. Becomes `null` once the service is ended.\n         * @type {?RPCImpl}\n         */\n\n        this.rpcImpl = rpcImpl;\n        /**\n         * Whether requests are length-delimited.\n         * @type {boolean}\n         */\n\n        this.requestDelimited = Boolean(requestDelimited);\n        /**\n         * Whether responses are length-delimited.\n         * @type {boolean}\n         */\n\n        this.responseDelimited = Boolean(responseDelimited);\n      }\n      /**\n       * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n       * @param {Method|rpc.ServiceMethod} method Reflected or static method\n       * @param {function} requestCtor Request constructor\n       * @param {function} responseCtor Response constructor\n       * @param {Message|Object.<string,*>} request Request message or plain object\n       * @param {rpc.ServiceMethodCallback} callback Service callback\n       * @returns {undefined}\n       */\n\n\n      Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n        if (!request) throw TypeError(\"request must be specified\");\n        var self = this;\n        if (!callback) return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n        if (!self.rpcImpl) {\n          setTimeout(function () {\n            callback(Error(\"already ended\"));\n          }, 0);\n          return undefined;\n        }\n\n        try {\n          return self.rpcImpl(method, requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(), function rpcCallback(err, response) {\n            if (err) {\n              self.emit(\"error\", err, method);\n              return callback(err);\n            }\n\n            if (response === null) {\n              self.end(\n              /* endedByRPC */\n              true);\n              return undefined;\n            }\n\n            if (!(response instanceof responseCtor)) {\n              try {\n                response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n              } catch (err) {\n                self.emit(\"error\", err, method);\n                return callback(err);\n              }\n            }\n\n            self.emit(\"data\", response, method);\n            return callback(null, response);\n          });\n        } catch (err) {\n          self.emit(\"error\", err, method);\n          setTimeout(function () {\n            callback(err);\n          }, 0);\n          return undefined;\n        }\n      };\n      /**\n       * Ends this service and emits the `end` event.\n       * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n       * @returns {rpc.Service} `this`\n       */\n\n\n      Service.prototype.end = function end(endedByRPC) {\n        if (this.rpcImpl) {\n          if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n          this.rpcImpl = null;\n          this.emit(\"end\").off();\n        }\n\n        return this;\n      };\n    }, {\n      \"13\": 13\n    }],\n    12: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = LongBits;\n\n      var util = require(13);\n      /**\n       * Any compatible Long instance.\n       *\n       * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n       * @typedef Long\n       * @type {Object}\n       * @property {number} low Low bits\n       * @property {number} high High bits\n       * @property {boolean} unsigned Whether unsigned or not\n       */\n\n      /**\n       * Constructs new long bits.\n       * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n       * @memberof util\n       * @constructor\n       * @param {number} lo Low 32 bits, unsigned\n       * @param {number} hi High 32 bits, unsigned\n       */\n\n\n      function LongBits(lo, hi) {\n        // note that the casts below are theoretically unnecessary as of today, but older statically\n        // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n        /**\n         * Low bits.\n         * @type {number}\n         */\n        this.lo = lo >>> 0;\n        /**\n         * High bits.\n         * @type {number}\n         */\n\n        this.hi = hi >>> 0;\n      }\n      /**\n       * Zero bits.\n       * @memberof util.LongBits\n       * @type {util.LongBits}\n       */\n\n\n      var zero = LongBits.zero = new LongBits(0, 0);\n\n      zero.toNumber = function () {\n        return 0;\n      };\n\n      zero.zzEncode = zero.zzDecode = function () {\n        return this;\n      };\n\n      zero.length = function () {\n        return 1;\n      };\n      /**\n       * Zero hash.\n       * @memberof util.LongBits\n       * @type {string}\n       */\n\n\n      var zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n      /**\n       * Constructs new long bits from the specified number.\n       * @param {number} value Value\n       * @returns {util.LongBits} Instance\n       */\n\n      LongBits.fromNumber = function fromNumber(value) {\n        if (value === 0) return zero;\n        var sign = value < 0;\n        if (sign) value = -value;\n        var lo = value >>> 0,\n            hi = (value - lo) / 4294967296 >>> 0;\n\n        if (sign) {\n          hi = ~hi >>> 0;\n          lo = ~lo >>> 0;\n\n          if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295) hi = 0;\n          }\n        }\n\n        return new LongBits(lo, hi);\n      };\n      /**\n       * Constructs new long bits from a number, long or string.\n       * @param {Long|number|string} value Value\n       * @returns {util.LongBits} Instance\n       */\n\n\n      LongBits.from = function from(value) {\n        if (typeof value === \"number\") return LongBits.fromNumber(value);\n\n        if (util.isString(value)) {\n          /* istanbul ignore else */\n          if (util.Long) value = util.Long.fromString(value);else return LongBits.fromNumber(parseInt(value, 10));\n        }\n\n        return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n      };\n      /**\n       * Converts this long bits to a possibly unsafe JavaScript number.\n       * @param {boolean} [unsigned=false] Whether unsigned or not\n       * @returns {number} Possibly unsafe number\n       */\n\n\n      LongBits.prototype.toNumber = function toNumber(unsigned) {\n        if (!unsigned && this.hi >>> 31) {\n          var lo = ~this.lo + 1 >>> 0,\n              hi = ~this.hi >>> 0;\n          if (!lo) hi = hi + 1 >>> 0;\n          return -(lo + hi * 4294967296);\n        }\n\n        return this.lo + this.hi * 4294967296;\n      };\n      /**\n       * Converts this long bits to a long.\n       * @param {boolean} [unsigned=false] Whether unsigned or not\n       * @returns {Long} Long\n       */\n\n\n      LongBits.prototype.toLong = function toLong(unsigned) {\n        return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : {\n          low: this.lo | 0,\n          high: this.hi | 0,\n          unsigned: Boolean(unsigned)\n        };\n      };\n\n      var charCodeAt = String.prototype.charCodeAt;\n      /**\n       * Constructs new long bits from the specified 8 characters long hash.\n       * @param {string} hash Hash\n       * @returns {util.LongBits} Bits\n       */\n\n      LongBits.fromHash = function fromHash(hash) {\n        if (hash === zeroHash) return zero;\n        return new LongBits((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);\n      };\n      /**\n       * Converts this long bits to a 8 characters long hash.\n       * @returns {string} Hash\n       */\n\n\n      LongBits.prototype.toHash = function toHash() {\n        return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);\n      };\n      /**\n       * Zig-zag encodes this long bits.\n       * @returns {util.LongBits} `this`\n       */\n\n\n      LongBits.prototype.zzEncode = function zzEncode() {\n        var mask = this.hi >> 31;\n        this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n        this.lo = (this.lo << 1 ^ mask) >>> 0;\n        return this;\n      };\n      /**\n       * Zig-zag decodes this long bits.\n       * @returns {util.LongBits} `this`\n       */\n\n\n      LongBits.prototype.zzDecode = function zzDecode() {\n        var mask = -(this.lo & 1);\n        this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n        this.hi = (this.hi >>> 1 ^ mask) >>> 0;\n        return this;\n      };\n      /**\n       * Calculates the length of this longbits when encoded as a varint.\n       * @returns {number} Length\n       */\n\n\n      LongBits.prototype.length = function length() {\n        var part0 = this.lo,\n            part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n            part2 = this.hi >>> 24;\n        return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;\n      };\n    }, {\n      \"13\": 13\n    }],\n    13: [function (require, module, exports) {\n      \"use strict\";\n\n      var util = exports; // used to return a Promise where callback is omitted\n\n      util.asPromise = require(1); // converts to / from base64 encoded strings\n\n      util.base64 = require(2); // base class of rpc.Service\n\n      util.EventEmitter = require(3); // requires modules optionally and hides the call from bundlers\n\n      util.inquire = require(4); // converts to / from utf8 encoded strings\n\n      util.utf8 = require(6); // provides a node-like buffer pool in the browser\n\n      util.pool = require(5); // utility to work with the low and high bits of a 64 bit value\n\n      util.LongBits = require(12);\n      /**\n       * An immuable empty array.\n       * @memberof util\n       * @type {Array.<*>}\n       */\n\n      util.emptyArray = Object.freeze ? Object.freeze([]) :\n      /* istanbul ignore next */\n      []; // used on prototypes\n\n      /**\n       * An immutable empty object.\n       * @type {Object}\n       */\n\n      util.emptyObject = Object.freeze ? Object.freeze({}) :\n      /* istanbul ignore next */\n      {}; // used on prototypes\n\n      /**\n       * Whether running within node or not.\n       * @memberof util\n       * @type {boolean}\n       */\n\n      util.isNode = Boolean(global.process && global.process.versions && global.process.versions.node);\n      /**\n       * Tests if the specified value is an integer.\n       * @function\n       * @param {*} value Value to test\n       * @returns {boolean} `true` if the value is an integer\n       */\n\n      util.isInteger = Number.isInteger ||\n      /* istanbul ignore next */\n      function isInteger(value) {\n        return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n      };\n      /**\n       * Tests if the specified value is a string.\n       * @param {*} value Value to test\n       * @returns {boolean} `true` if the value is a string\n       */\n\n\n      util.isString = function isString(value) {\n        return typeof value === \"string\" || value instanceof String;\n      };\n      /**\n       * Tests if the specified value is a non-null object.\n       * @param {*} value Value to test\n       * @returns {boolean} `true` if the value is a non-null object\n       */\n\n\n      util.isObject = function isObject(value) {\n        return value && typeof value === \"object\";\n      };\n      /**\n       * Node's Buffer class if available.\n       * @type {?function(new: Buffer)}\n       */\n\n\n      util.Buffer = function () {\n        try {\n          var Buffer = util.inquire(\"buffer\").Buffer; // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n\n          return Buffer.prototype.utf8Write ? Buffer :\n          /* istanbul ignore next */\n          null;\n        } catch (e) {\n          /* istanbul ignore next */\n          return null;\n        }\n      }();\n      /**\n       * Internal alias of or polyfull for Buffer.from.\n       * @type {?function}\n       * @param {string|number[]} value Value\n       * @param {string} [encoding] Encoding if value is a string\n       * @returns {Uint8Array}\n       * @private\n       */\n\n\n      util._Buffer_from = null;\n      /**\n       * Internal alias of or polyfill for Buffer.allocUnsafe.\n       * @type {?function}\n       * @param {number} size Buffer size\n       * @returns {Uint8Array}\n       * @private\n       */\n\n      util._Buffer_allocUnsafe = null;\n      /**\n       * Creates a new buffer of whatever type supported by the environment.\n       * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n       * @returns {Uint8Array|Buffer} Buffer\n       */\n\n      util.newBuffer = function newBuffer(sizeOrArray) {\n        /* istanbul ignore next */\n        return typeof sizeOrArray === \"number\" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === \"undefined\" ? sizeOrArray : new Uint8Array(sizeOrArray);\n      };\n      /**\n       * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n       * @type {?function(new: Uint8Array, *)}\n       */\n\n\n      util.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array\n      /* istanbul ignore next */\n      : Array;\n      /**\n       * Long.js's Long class if available.\n       * @type {?function(new: Long)}\n       */\n\n      util.Long =\n      /* istanbul ignore next */\n      global.dcodeIO &&\n      /* istanbul ignore next */\n      global.dcodeIO.Long || util.inquire(\"long\");\n      /**\n       * Regular expression used to verify 2 bit (`bool`) map keys.\n       * @type {RegExp}\n       */\n\n      util.key2Re = /^true|false|0|1$/;\n      /**\n       * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n       * @type {RegExp}\n       */\n\n      util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n      /**\n       * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n       * @type {RegExp}\n       */\n\n      util.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n      /**\n       * Converts a number or long to an 8 characters long hash string.\n       * @param {Long|number} value Value to convert\n       * @returns {string} Hash\n       */\n\n      util.longToHash = function longToHash(value) {\n        return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;\n      };\n      /**\n       * Converts an 8 characters long hash string to a long or number.\n       * @param {string} hash Hash\n       * @param {boolean} [unsigned=false] Whether unsigned or not\n       * @returns {Long|number} Original value\n       */\n\n\n      util.longFromHash = function longFromHash(hash, unsigned) {\n        var bits = util.LongBits.fromHash(hash);\n        if (util.Long) return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n        return bits.toNumber(Boolean(unsigned));\n      };\n      /**\n       * Merges the properties of the source object into the destination object.\n       * @memberof util\n       * @param {Object.<string,*>} dst Destination object\n       * @param {Object.<string,*>} src Source object\n       * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n       * @returns {Object.<string,*>} Destination object\n       */\n\n\n      function merge(dst, src, ifNotSet) {\n        // used by converters\n        for (var keys = Object.keys(src), i = 0; i < keys.length; ++i) if (dst[keys[i]] === undefined || !ifNotSet) dst[keys[i]] = src[keys[i]];\n\n        return dst;\n      }\n\n      util.merge = merge;\n      /**\n       * Converts the first character of a string to lower case.\n       * @param {string} str String to convert\n       * @returns {string} Converted string\n       */\n\n      util.lcFirst = function lcFirst(str) {\n        return str.charAt(0).toLowerCase() + str.substring(1);\n      };\n      /**\n       * Creates a custom error constructor.\n       * @memberof util\n       * @param {string} name Error name\n       * @returns {function} Custom error constructor\n       */\n\n\n      function newError(name) {\n        function CustomError(message, properties) {\n          if (!(this instanceof CustomError)) return new CustomError(message, properties); // Error.call(this, message);\n          // ^ just returns a new error instance because the ctor can be called as a function\n\n          Object.defineProperty(this, \"message\", {\n            get: function () {\n              return message;\n            }\n          });\n          /* istanbul ignore next */\n\n          if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);else Object.defineProperty(this, \"stack\", {\n            value: new Error().stack || \"\"\n          });\n          if (properties) merge(this, properties);\n        }\n\n        (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;\n        Object.defineProperty(CustomError.prototype, \"name\", {\n          get: function () {\n            return name;\n          }\n        });\n\n        CustomError.prototype.toString = function toString() {\n          return this.name + \": \" + this.message;\n        };\n\n        return CustomError;\n      }\n\n      util.newError = newError;\n      /**\n       * Constructs a new protocol error.\n       * @classdesc Error subclass indicating a protocol specifc error.\n       * @memberof util\n       * @extends Error\n       * @constructor\n       * @param {string} message Error message\n       * @param {Object.<string,*>=} properties Additional properties\n       * @example\n       * try {\n       *     MyMessage.decode(someBuffer); // throws if required fields are missing\n       * } catch (e) {\n       *     if (e instanceof ProtocolError && e.instance)\n       *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n       * }\n       */\n\n      util.ProtocolError = newError(\"ProtocolError\");\n      /**\n       * So far decoded message instance.\n       * @name util.ProtocolError#instance\n       * @type {Message}\n       */\n\n      /**\n       * Builds a getter for a oneof's present field name.\n       * @param {string[]} fieldNames Field names\n       * @returns {function():string|undefined} Unbound getter\n       */\n\n      util.oneOfGetter = function getOneOf(fieldNames) {\n        var fieldMap = {};\n\n        for (var i = 0; i < fieldNames.length; ++i) fieldMap[fieldNames[i]] = 1;\n        /**\n         * @returns {string|undefined} Set field name, if any\n         * @this Object\n         * @ignore\n         */\n\n\n        return function () {\n          // eslint-disable-line consistent-return\n          for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i) if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null) return keys[i];\n        };\n      };\n      /**\n       * Builds a setter for a oneof's present field name.\n       * @param {string[]} fieldNames Field names\n       * @returns {function(?string):undefined} Unbound setter\n       */\n\n\n      util.oneOfSetter = function setOneOf(fieldNames) {\n        /**\n         * @param {string} name Field name\n         * @returns {undefined}\n         * @this Object\n         * @ignore\n         */\n        return function (name) {\n          for (var i = 0; i < fieldNames.length; ++i) if (fieldNames[i] !== name) delete this[fieldNames[i]];\n        };\n      };\n      /**\n       * Lazily resolves fully qualified type names against the specified root.\n       * @param {Root} root Root instanceof\n       * @param {Object.<number,string|ReflectionObject>} lazyTypes Type names\n       * @returns {undefined}\n       */\n\n\n      util.lazyResolve = function lazyResolve(root, lazyTypes) {\n        for (var i = 0; i < lazyTypes.length; ++i) {\n          for (var keys = Object.keys(lazyTypes[i]), j = 0; j < keys.length; ++j) {\n            var path = lazyTypes[i][keys[j]].split(\".\"),\n                ptr = root;\n\n            while (path.length) ptr = ptr[path.shift()];\n\n            lazyTypes[i][keys[j]] = ptr;\n          }\n        }\n      };\n      /**\n       * Default conversion options used for {@link Message#toJSON} implementations. Longs, enums and bytes are converted to strings by default.\n       * @type {ConversionOptions}\n       */\n\n\n      util.toJSONOptions = {\n        longs: String,\n        enums: String,\n        bytes: String\n      };\n\n      util._configure = function () {\n        var Buffer = util.Buffer;\n        /* istanbul ignore if */\n\n        if (!Buffer) {\n          util._Buffer_from = util._Buffer_allocUnsafe = null;\n          return;\n        } // because node 4.x buffers are incompatible & immutable\n        // see: https://github.com/dcodeIO/protobuf.js/pull/665\n\n\n        util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n          return new Buffer(value, encoding);\n        };\n\n        util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n          return new Buffer(size);\n        };\n      };\n    }, {\n      \"1\": 1,\n      \"12\": 12,\n      \"2\": 2,\n      \"3\": 3,\n      \"4\": 4,\n      \"5\": 5,\n      \"6\": 6\n    }],\n    14: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = Writer;\n\n      var util = require(13);\n\n      var BufferWriter; // cyclic\n\n      var LongBits = util.LongBits,\n          base64 = util.base64,\n          utf8 = util.utf8;\n      /**\n       * Constructs a new writer operation instance.\n       * @classdesc Scheduled writer operation.\n       * @constructor\n       * @param {function(*, Uint8Array, number)} fn Function to call\n       * @param {number} len Value byte length\n       * @param {*} val Value to write\n       * @ignore\n       */\n\n      function Op(fn, len, val) {\n        /**\n         * Function to call.\n         * @type {function(Uint8Array, number, *)}\n         */\n        this.fn = fn;\n        /**\n         * Value byte length.\n         * @type {number}\n         */\n\n        this.len = len;\n        /**\n         * Next operation.\n         * @type {Writer.Op|undefined}\n         */\n\n        this.next = undefined;\n        /**\n         * Value to write.\n         * @type {*}\n         */\n\n        this.val = val; // type varies\n      }\n      /* istanbul ignore next */\n\n\n      function noop() {} // eslint-disable-line no-empty-function\n\n      /**\n       * Constructs a new writer state instance.\n       * @classdesc Copied writer state.\n       * @memberof Writer\n       * @constructor\n       * @param {Writer} writer Writer to copy state from\n       * @private\n       * @ignore\n       */\n\n\n      function State(writer) {\n        /**\n         * Current head.\n         * @type {Writer.Op}\n         */\n        this.head = writer.head;\n        /**\n         * Current tail.\n         * @type {Writer.Op}\n         */\n\n        this.tail = writer.tail;\n        /**\n         * Current buffer length.\n         * @type {number}\n         */\n\n        this.len = writer.len;\n        /**\n         * Next state.\n         * @type {?State}\n         */\n\n        this.next = writer.states;\n      }\n      /**\n       * Constructs a new writer instance.\n       * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n       * @constructor\n       */\n\n\n      function Writer() {\n        /**\n         * Current length.\n         * @type {number}\n         */\n        this.len = 0;\n        /**\n         * Operations head.\n         * @type {Object}\n         */\n\n        this.head = new Op(noop, 0, 0);\n        /**\n         * Operations tail\n         * @type {Object}\n         */\n\n        this.tail = this.head;\n        /**\n         * Linked forked states.\n         * @type {?Object}\n         */\n\n        this.states = null; // When a value is written, the writer calculates its byte length and puts it into a linked\n        // list of operations to perform when finish() is called. This both allows us to allocate\n        // buffers of the exact required size and reduces the amount of work we have to do compared\n        // to first calculating over objects and then encoding over objects. In our case, the encoding\n        // part is just a linked list walk calling operations with already prepared values.\n      }\n      /**\n       * Creates a new writer.\n       * @function\n       * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n       */\n\n\n      Writer.create = util.Buffer ? function create_buffer_setup() {\n        return (Writer.create = function create_buffer() {\n          return new BufferWriter();\n        })();\n      }\n      /* istanbul ignore next */\n      : function create_array() {\n        return new Writer();\n      };\n      /**\n       * Allocates a buffer of the specified size.\n       * @param {number} size Buffer size\n       * @returns {Uint8Array} Buffer\n       */\n\n      Writer.alloc = function alloc(size) {\n        return new util.Array(size);\n      }; // Use Uint8Array buffer pool in the browser, just like node does with buffers\n\n      /* istanbul ignore else */\n\n\n      if (util.Array !== Array) Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n      /**\n       * Pushes a new operation to the queue.\n       * @param {function(Uint8Array, number, *)} fn Function to call\n       * @param {number} len Value byte length\n       * @param {number} val Value to write\n       * @returns {Writer} `this`\n       */\n\n      Writer.prototype.push = function push(fn, len, val) {\n        this.tail = this.tail.next = new Op(fn, len, val);\n        this.len += len;\n        return this;\n      };\n\n      function writeByte(val, buf, pos) {\n        buf[pos] = val & 255;\n      }\n\n      function writeVarint32(val, buf, pos) {\n        while (val > 127) {\n          buf[pos++] = val & 127 | 128;\n          val >>>= 7;\n        }\n\n        buf[pos] = val;\n      }\n      /**\n       * Constructs a new varint writer operation instance.\n       * @classdesc Scheduled varint writer operation.\n       * @extends Op\n       * @constructor\n       * @param {number} len Value byte length\n       * @param {number} val Value to write\n       * @ignore\n       */\n\n\n      function VarintOp(len, val) {\n        this.len = len;\n        this.next = undefined;\n        this.val = val;\n      }\n\n      VarintOp.prototype = Object.create(Op.prototype);\n      VarintOp.prototype.fn = writeVarint32;\n      /**\n       * Writes an unsigned 32 bit value as a varint.\n       * @param {number} value Value to write\n       * @returns {Writer} `this`\n       */\n\n      Writer.prototype.uint32 = function write_uint32(value) {\n        // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n        // uint32 is by far the most frequently used operation and benefits significantly from this.\n        this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;\n        return this;\n      };\n      /**\n       * Writes a signed 32 bit value as a varint.\n       * @function\n       * @param {number} value Value to write\n       * @returns {Writer} `this`\n       */\n\n\n      Writer.prototype.int32 = function write_int32(value) {\n        return value < 0 ? this.push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n      };\n      /**\n       * Writes a 32 bit value as a varint, zig-zag encoded.\n       * @param {number} value Value to write\n       * @returns {Writer} `this`\n       */\n\n\n      Writer.prototype.sint32 = function write_sint32(value) {\n        return this.uint32((value << 1 ^ value >> 31) >>> 0);\n      };\n\n      function writeVarint64(val, buf, pos) {\n        while (val.hi) {\n          buf[pos++] = val.lo & 127 | 128;\n          val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n          val.hi >>>= 7;\n        }\n\n        while (val.lo > 127) {\n          buf[pos++] = val.lo & 127 | 128;\n          val.lo = val.lo >>> 7;\n        }\n\n        buf[pos++] = val.lo;\n      }\n      /**\n       * Writes an unsigned 64 bit value as a varint.\n       * @param {Long|number|string} value Value to write\n       * @returns {Writer} `this`\n       * @throws {TypeError} If `value` is a string and no long library is present.\n       */\n\n\n      Writer.prototype.uint64 = function write_uint64(value) {\n        var bits = LongBits.from(value);\n        return this.push(writeVarint64, bits.length(), bits);\n      };\n      /**\n       * Writes a signed 64 bit value as a varint.\n       * @function\n       * @param {Long|number|string} value Value to write\n       * @returns {Writer} `this`\n       * @throws {TypeError} If `value` is a string and no long library is present.\n       */\n\n\n      Writer.prototype.int64 = Writer.prototype.uint64;\n      /**\n       * Writes a signed 64 bit value as a varint, zig-zag encoded.\n       * @param {Long|number|string} value Value to write\n       * @returns {Writer} `this`\n       * @throws {TypeError} If `value` is a string and no long library is present.\n       */\n\n      Writer.prototype.sint64 = function write_sint64(value) {\n        var bits = LongBits.from(value).zzEncode();\n        return this.push(writeVarint64, bits.length(), bits);\n      };\n      /**\n       * Writes a boolish value as a varint.\n       * @param {boolean} value Value to write\n       * @returns {Writer} `this`\n       */\n\n\n      Writer.prototype.bool = function write_bool(value) {\n        return this.push(writeByte, 1, value ? 1 : 0);\n      };\n\n      function writeFixed32(val, buf, pos) {\n        buf[pos++] = val & 255;\n        buf[pos++] = val >>> 8 & 255;\n        buf[pos++] = val >>> 16 & 255;\n        buf[pos] = val >>> 24;\n      }\n      /**\n       * Writes an unsigned 32 bit value as fixed 32 bits.\n       * @param {number} value Value to write\n       * @returns {Writer} `this`\n       */\n\n\n      Writer.prototype.fixed32 = function write_fixed32(value) {\n        return this.push(writeFixed32, 4, value >>> 0);\n      };\n      /**\n       * Writes a signed 32 bit value as fixed 32 bits.\n       * @function\n       * @param {number} value Value to write\n       * @returns {Writer} `this`\n       */\n\n\n      Writer.prototype.sfixed32 = Writer.prototype.fixed32;\n      /**\n       * Writes an unsigned 64 bit value as fixed 64 bits.\n       * @param {Long|number|string} value Value to write\n       * @returns {Writer} `this`\n       * @throws {TypeError} If `value` is a string and no long library is present.\n       */\n\n      Writer.prototype.fixed64 = function write_fixed64(value) {\n        var bits = LongBits.from(value);\n        return this.push(writeFixed32, 4, bits.lo).push(writeFixed32, 4, bits.hi);\n      };\n      /**\n       * Writes a signed 64 bit value as fixed 64 bits.\n       * @function\n       * @param {Long|number|string} value Value to write\n       * @returns {Writer} `this`\n       * @throws {TypeError} If `value` is a string and no long library is present.\n       */\n\n\n      Writer.prototype.sfixed64 = Writer.prototype.fixed64;\n      var writeFloat = typeof Float32Array !== \"undefined\" ? function () {\n        var f32 = new Float32Array(1),\n            f8b = new Uint8Array(f32.buffer);\n        f32[0] = -0;\n        return f8b[3] // already le?\n        ? function writeFloat_f32(val, buf, pos) {\n          f32[0] = val;\n          buf[pos++] = f8b[0];\n          buf[pos++] = f8b[1];\n          buf[pos++] = f8b[2];\n          buf[pos] = f8b[3];\n        }\n        /* istanbul ignore next */\n        : function writeFloat_f32_le(val, buf, pos) {\n          f32[0] = val;\n          buf[pos++] = f8b[3];\n          buf[pos++] = f8b[2];\n          buf[pos++] = f8b[1];\n          buf[pos] = f8b[0];\n        };\n      }()\n      /* istanbul ignore next */\n      : function writeFloat_ieee754(value, buf, pos) {\n        var sign = value < 0 ? 1 : 0;\n        if (sign) value = -value;\n        if (value === 0) writeFixed32(1 / value > 0 ?\n        /* positive */\n        0 :\n        /* negative 0 */\n        2147483648, buf, pos);else if (isNaN(value)) writeFixed32(2147483647, buf, pos);else if (value > 3.4028234663852886e+38) // +-Infinity\n          writeFixed32((sign << 31 | 2139095040) >>> 0, buf, pos);else if (value < 1.1754943508222875e-38) // denormal\n          writeFixed32((sign << 31 | Math.round(value / 1.401298464324817e-45)) >>> 0, buf, pos);else {\n          var exponent = Math.floor(Math.log(value) / Math.LN2),\n              mantissa = Math.round(value * Math.pow(2, -exponent) * 8388608) & 8388607;\n          writeFixed32((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\n        }\n      };\n      /**\n       * Writes a float (32 bit).\n       * @function\n       * @param {number} value Value to write\n       * @returns {Writer} `this`\n       */\n\n      Writer.prototype.float = function write_float(value) {\n        return this.push(writeFloat, 4, value);\n      };\n\n      var writeDouble = typeof Float64Array !== \"undefined\" ? function () {\n        var f64 = new Float64Array(1),\n            f8b = new Uint8Array(f64.buffer);\n        f64[0] = -0;\n        return f8b[7] // already le?\n        ? function writeDouble_f64(val, buf, pos) {\n          f64[0] = val;\n          buf[pos++] = f8b[0];\n          buf[pos++] = f8b[1];\n          buf[pos++] = f8b[2];\n          buf[pos++] = f8b[3];\n          buf[pos++] = f8b[4];\n          buf[pos++] = f8b[5];\n          buf[pos++] = f8b[6];\n          buf[pos] = f8b[7];\n        }\n        /* istanbul ignore next */\n        : function writeDouble_f64_le(val, buf, pos) {\n          f64[0] = val;\n          buf[pos++] = f8b[7];\n          buf[pos++] = f8b[6];\n          buf[pos++] = f8b[5];\n          buf[pos++] = f8b[4];\n          buf[pos++] = f8b[3];\n          buf[pos++] = f8b[2];\n          buf[pos++] = f8b[1];\n          buf[pos] = f8b[0];\n        };\n      }()\n      /* istanbul ignore next */\n      : function writeDouble_ieee754(value, buf, pos) {\n        var sign = value < 0 ? 1 : 0;\n        if (sign) value = -value;\n\n        if (value === 0) {\n          writeFixed32(0, buf, pos);\n          writeFixed32(1 / value > 0 ?\n          /* positive */\n          0 :\n          /* negative 0 */\n          2147483648, buf, pos + 4);\n        } else if (isNaN(value)) {\n          writeFixed32(4294967295, buf, pos);\n          writeFixed32(2147483647, buf, pos + 4);\n        } else if (value > 1.7976931348623157e+308) {\n          // +-Infinity\n          writeFixed32(0, buf, pos);\n          writeFixed32((sign << 31 | 2146435072) >>> 0, buf, pos + 4);\n        } else {\n          var mantissa;\n\n          if (value < 2.2250738585072014e-308) {\n            // denormal\n            mantissa = value / 5e-324;\n            writeFixed32(mantissa >>> 0, buf, pos);\n            writeFixed32((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + 4);\n          } else {\n            var exponent = Math.floor(Math.log(value) / Math.LN2);\n            if (exponent === 1024) exponent = 1023;\n            mantissa = value * Math.pow(2, -exponent);\n            writeFixed32(mantissa * 4503599627370496 >>> 0, buf, pos);\n            writeFixed32((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + 4);\n          }\n        }\n      };\n      /**\n       * Writes a double (64 bit float).\n       * @function\n       * @param {number} value Value to write\n       * @returns {Writer} `this`\n       */\n\n      Writer.prototype.double = function write_double(value) {\n        return this.push(writeDouble, 8, value);\n      };\n\n      var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n      }\n      /* istanbul ignore next */\n      : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i) buf[pos + i] = val[i];\n      };\n      /**\n       * Writes a sequence of bytes.\n       * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n       * @returns {Writer} `this`\n       */\n\n      Writer.prototype.bytes = function write_bytes(value) {\n        var len = value.length >>> 0;\n        if (!len) return this.push(writeByte, 1, 0);\n\n        if (util.isString(value)) {\n          var buf = Writer.alloc(len = base64.length(value));\n          base64.decode(value, buf, 0);\n          value = buf;\n        }\n\n        return this.uint32(len).push(writeBytes, len, value);\n      };\n      /**\n       * Writes a string.\n       * @param {string} value Value to write\n       * @returns {Writer} `this`\n       */\n\n\n      Writer.prototype.string = function write_string(value) {\n        var len = utf8.length(value);\n        return len ? this.uint32(len).push(utf8.write, len, value) : this.push(writeByte, 1, 0);\n      };\n      /**\n       * Forks this writer's state by pushing it to a stack.\n       * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n       * @returns {Writer} `this`\n       */\n\n\n      Writer.prototype.fork = function fork() {\n        this.states = new State(this);\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len = 0;\n        return this;\n      };\n      /**\n       * Resets this instance to the last state.\n       * @returns {Writer} `this`\n       */\n\n\n      Writer.prototype.reset = function reset() {\n        if (this.states) {\n          this.head = this.states.head;\n          this.tail = this.states.tail;\n          this.len = this.states.len;\n          this.states = this.states.next;\n        } else {\n          this.head = this.tail = new Op(noop, 0, 0);\n          this.len = 0;\n        }\n\n        return this;\n      };\n      /**\n       * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n       * @returns {Writer} `this`\n       */\n\n\n      Writer.prototype.ldelim = function ldelim() {\n        var head = this.head,\n            tail = this.tail,\n            len = this.len;\n        this.reset().uint32(len);\n\n        if (len) {\n          this.tail.next = head.next; // skip noop\n\n          this.tail = tail;\n          this.len += len;\n        }\n\n        return this;\n      };\n      /**\n       * Finishes the write operation.\n       * @returns {Uint8Array} Finished buffer\n       */\n\n\n      Writer.prototype.finish = function finish() {\n        var head = this.head.next,\n            // skip noop\n        buf = this.constructor.alloc(this.len),\n            pos = 0;\n\n        while (head) {\n          head.fn(head.val, buf, pos);\n          pos += head.len;\n          head = head.next;\n        } // this.head = this.tail = null;\n\n\n        return buf;\n      };\n\n      Writer._configure = function (BufferWriter_) {\n        BufferWriter = BufferWriter_;\n      };\n    }, {\n      \"13\": 13\n    }],\n    15: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = BufferWriter; // extends Writer\n\n      var Writer = require(14);\n\n      (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\n      var util = require(13);\n\n      var Buffer = util.Buffer;\n      /**\n       * Constructs a new buffer writer instance.\n       * @classdesc Wire format writer using node buffers.\n       * @extends Writer\n       * @constructor\n       */\n\n      function BufferWriter() {\n        Writer.call(this);\n      }\n      /**\n       * Allocates a buffer of the specified size.\n       * @param {number} size Buffer size\n       * @returns {Buffer} Buffer\n       */\n\n\n      BufferWriter.alloc = function alloc_buffer(size) {\n        return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);\n      };\n\n      var writeBytesBuffer = Buffer && Buffer.prototype instanceof Uint8Array && Buffer.prototype.set.name === \"set\" ? function writeBytesBuffer_set(val, buf, pos) {\n        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n        // also works for plain array values\n      }\n      /* istanbul ignore next */\n      : function writeBytesBuffer_copy(val, buf, pos) {\n        if (val.copy) // Buffer values\n          val.copy(buf, pos, 0, val.length);else for (var i = 0; i < val.length;) // plain array values\n        buf[pos++] = val[i++];\n      };\n      /**\n       * @override\n       */\n\n      BufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n        if (util.isString(value)) value = util._Buffer_from(value, \"base64\");\n        var len = value.length >>> 0;\n        this.uint32(len);\n        if (len) this.push(writeBytesBuffer, len, value);\n        return this;\n      };\n\n      function writeStringBuffer(val, buf, pos) {\n        if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n          util.utf8.write(val, buf, pos);else buf.utf8Write(val, pos);\n      }\n      /**\n       * @override\n       */\n\n\n      BufferWriter.prototype.string = function write_string_buffer(value) {\n        var len = Buffer.byteLength(value);\n        this.uint32(len);\n        if (len) this.push(writeStringBuffer, len, value);\n        return this;\n      };\n      /**\n       * Finishes the write operation.\n       * @name BufferWriter#finish\n       * @function\n       * @returns {Buffer} Finished buffer\n       */\n\n    }, {\n      \"13\": 13,\n      \"14\": 14\n    }]\n  }, {}, [7]);\n})(tmp);\n\nexport default tmp.protobuf;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/ThirdParty/protobuf-minimal.js"],"names":["tmp","global","undefined","prelude","modules","cache","entries","$require","name","$module","call","exports","protobuf","require","module","asPromise","fn","ctx","params","i","arguments","length","push","pending","Promise","asPromiseExecutor","resolve","reject","asPromiseCallback","err","args","apply","base64","string","p","n","charAt","Math","ceil","b64","Array","s64","encode","buffer","start","end","j","t","b","String","fromCharCode","invalidEncoding","decode","offset","c","charCodeAt","Error","test","EventEmitter","_listeners","prototype","on","evt","off","listeners","splice","emit","inquire","moduleName","mod","eval","replace","Object","keys","e","pool","alloc","slice","size","SIZE","MAX","slab","pool_alloc","buf","utf8","utf8_length","len","read","utf8_read","parts","chunk","join","write","utf8_write","c1","c2","build","roots","Writer","BufferWriter","Reader","BufferReader","util","rpc","configure","_configure","LongBits","indexOutOfRange","reader","writeLength","RangeError","pos","create_array","Uint8Array","create_typed_array","isArray","create","Buffer","create_buffer_setup","create_buffer","isBuffer","_slice","subarray","uint32","read_uint32_setup","value","read_uint32","int32","read_int32","sint32","read_sint32","readLongVarint","bits","lo","hi","bool","read_bool","readFixed32","fixed32","read_fixed32","sfixed32","read_sfixed32","readFixed64","readFloat","Float32Array","f32","f8b","readFloat_f32","readFloat_f32_le","readFloat_ieee754","uint","sign","exponent","mantissa","NaN","Infinity","pow","float","read_float","readDouble","Float64Array","f64","readDouble_f64","readDouble_f64_le","readDouble_ieee754","double","read_double","bytes","read_bytes","constructor","read_string","skip","skipType","wireType","BufferReader_","Long","merge","int64","read_int64","uint64","read_uint64","sint64","read_sint64","zzDecode","fixed64","read_fixed64","sfixed64","read_sfixed64","read_string_buffer","utf8Slice","min","Service","rpcImpl","requestDelimited","responseDelimited","TypeError","Boolean","rpcCall","method","requestCtor","responseCtor","request","callback","self","setTimeout","finish","rpcCallback","response","endedByRPC","zero","toNumber","zzEncode","zeroHash","fromNumber","from","isString","fromString","parseInt","low","high","unsigned","toLong","fromHash","hash","toHash","mask","part0","part1","part2","emptyArray","freeze","emptyObject","isNode","process","versions","node","isInteger","Number","isFinite","floor","isObject","utf8Write","_Buffer_from","_Buffer_allocUnsafe","newBuffer","sizeOrArray","dcodeIO","key2Re","key32Re","key64Re","longToHash","longFromHash","fromBits","dst","src","ifNotSet","lcFirst","str","toLowerCase","substring","newError","CustomError","message","properties","defineProperty","get","captureStackTrace","stack","toString","ProtocolError","oneOfGetter","getOneOf","fieldNames","fieldMap","oneOfSetter","setOneOf","lazyResolve","root","lazyTypes","path","split","ptr","shift","toJSONOptions","longs","enums","Buffer_from","encoding","allocUnsafe","Buffer_allocUnsafe","Op","val","next","noop","State","writer","head","tail","states","writeByte","writeVarint32","VarintOp","write_uint32","write_int32","writeVarint64","write_sint32","write_uint64","write_sint64","write_bool","writeFixed32","write_fixed32","write_fixed64","writeFloat","writeFloat_f32","writeFloat_f32_le","writeFloat_ieee754","isNaN","round","log","LN2","write_float","writeDouble","writeDouble_f64","writeDouble_f64_le","writeDouble_ieee754","write_double","writeBytes","set","writeBytes_set","writeBytes_for","write_bytes","write_string","fork","reset","ldelim","BufferWriter_","alloc_buffer","writeBytesBuffer","writeBytesBuffer_set","writeBytesBuffer_copy","copy","write_bytes_buffer","writeStringBuffer","write_string_buffer","byteLength"],"mappings":"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","sourcesContent":["var tmp = {};\n/*!\n * protobuf.js v6.7.0 (c) 2016, Daniel Wirtz\n * Compiled Wed, 22 Mar 2017 17:30:26 UTC\n * Licensed under the BSD-3-Clause License\n * see: https://github.com/dcodeIO/protobuf.js for details\n */\n(function(global,undefined){\"use strict\";(function prelude(modules, cache, entries) {\n\n    // This is the prelude used to bundle protobuf.js for the browser. Wraps up the CommonJS\n    // sources through a conflict-free require shim and is again wrapped within an iife that\n    // provides a unified `global` and a minification-friendly `undefined` var plus a global\n    // \"use strict\" directive so that minification can remove the directives of each module.\n\n    function $require(name) {\n        var $module = cache[name];\n        if (!$module)\n            modules[name][0].call($module = cache[name] = { exports: {} }, $require, $module, $module.exports);\n        return $module.exports;\n    }\n\n    // Expose globally\n    var protobuf = global.protobuf = $require(entries[0]);\n\n    // Commented out to avoid polluing the global scope in Node.js\n    // // Be nice to AMD\n    // if (typeof define === \"function\" && define.amd)\n    //     define([], function() {\n    //         protobuf.configure();\n    //         return protobuf;\n    //     });\n\n    // // Be nice to CommonJS\n    // if (typeof module === \"object\" && module && module.exports)\n    //     module.exports = protobuf;\n\n})/* end of prelude */({1:[function(require,module,exports){\n\"use strict\";\nmodule.exports = asPromise;\n\n/**\n * Returns a promise from a node-style callback function.\n * @memberof util\n * @param {function(?Error, ...*)} fn Function to call\n * @param {*} ctx Function context\n * @param {...*} params Function arguments\n * @returns {Promise<*>} Promisified function\n */\nfunction asPromise(fn, ctx/*, varargs */) {\n    var params = [];\n    for (var i = 2; i < arguments.length;)\n        params.push(arguments[i++]);\n    var pending = true;\n    return new Promise(function asPromiseExecutor(resolve, reject) {\n        params.push(function asPromiseCallback(err/*, varargs */) {\n            if (pending) {\n                pending = false;\n                if (err)\n                    reject(err);\n                else {\n                    var args = [];\n                    for (var i = 1; i < arguments.length;)\n                        args.push(arguments[i++]);\n                    resolve.apply(null, args);\n                }\n            }\n        });\n        try {\n            fn.apply(ctx || this, params); // eslint-disable-line no-invalid-this\n        } catch (err) {\n            if (pending) {\n                pending = false;\n                reject(err);\n            }\n        }\n    });\n}\n\n},{}],2:[function(require,module,exports){\n\"use strict\";\n\n/**\n * A minimal base64 implementation for number arrays.\n * @memberof util\n * @namespace\n */\nvar base64 = exports;\n\n/**\n * Calculates the byte length of a base64 encoded string.\n * @param {string} string Base64 encoded string\n * @returns {number} Byte length\n */\nbase64.length = function length(string) {\n    var p = string.length;\n    if (!p)\n        return 0;\n    var n = 0;\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\n        ++n;\n    return Math.ceil(string.length * 3) / 4 - n;\n};\n\n// Base64 encoding table\nvar b64 = new Array(64);\n\n// Base64 decoding table\nvar s64 = new Array(123);\n\n// 65..90, 97..122, 48..57, 43, 47\nfor (var i = 0; i < 64;)\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\n\n/**\n * Encodes a buffer to a base64 encoded string.\n * @param {Uint8Array} buffer Source buffer\n * @param {number} start Source start\n * @param {number} end Source end\n * @returns {string} Base64 encoded string\n */\nbase64.encode = function encode(buffer, start, end) {\n    var string = []; // alt: new Array(Math.ceil((end - start) / 3) * 4);\n    var i = 0, // output index\n        j = 0, // goto index\n        t;     // temporary\n    while (start < end) {\n        var b = buffer[start++];\n        switch (j) {\n            case 0:\n                string[i++] = b64[b >> 2];\n                t = (b & 3) << 4;\n                j = 1;\n                break;\n            case 1:\n                string[i++] = b64[t | b >> 4];\n                t = (b & 15) << 2;\n                j = 2;\n                break;\n            case 2:\n                string[i++] = b64[t | b >> 6];\n                string[i++] = b64[b & 63];\n                j = 0;\n                break;\n        }\n    }\n    if (j) {\n        string[i++] = b64[t];\n        string[i  ] = 61;\n        if (j === 1)\n            string[i + 1] = 61;\n    }\n    return String.fromCharCode.apply(String, string);\n};\n\nvar invalidEncoding = \"invalid encoding\";\n\n/**\n * Decodes a base64 encoded string to a buffer.\n * @param {string} string Source string\n * @param {Uint8Array} buffer Destination buffer\n * @param {number} offset Destination offset\n * @returns {number} Number of bytes written\n * @throws {Error} If encoding is invalid\n */\nbase64.decode = function decode(string, buffer, offset) {\n    var start = offset;\n    var j = 0, // goto index\n        t;     // temporary\n    for (var i = 0; i < string.length;) {\n        var c = string.charCodeAt(i++);\n        if (c === 61 && j > 1)\n            break;\n        if ((c = s64[c]) === undefined)\n            throw Error(invalidEncoding);\n        switch (j) {\n            case 0:\n                t = c;\n                j = 1;\n                break;\n            case 1:\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\n                t = c;\n                j = 2;\n                break;\n            case 2:\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\n                t = c;\n                j = 3;\n                break;\n            case 3:\n                buffer[offset++] = (t & 3) << 6 | c;\n                j = 0;\n                break;\n        }\n    }\n    if (j === 1)\n        throw Error(invalidEncoding);\n    return offset - start;\n};\n\n/**\n * Tests if the specified string appears to be base64 encoded.\n * @param {string} string String to test\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\n */\nbase64.test = function test(string) {\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\n};\n\n},{}],3:[function(require,module,exports){\n\"use strict\";\nmodule.exports = EventEmitter;\n\n/**\n * Constructs a new event emitter instance.\n * @classdesc A minimal event emitter.\n * @memberof util\n * @constructor\n */\nfunction EventEmitter() {\n\n    /**\n     * Registered listeners.\n     * @type {Object.<string,*>}\n     * @private\n     */\n    this._listeners = {};\n}\n\n/**\n * Registers an event listener.\n * @param {string} evt Event name\n * @param {function} fn Listener\n * @param {*} [ctx] Listener context\n * @returns {util.EventEmitter} `this`\n */\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\n        fn  : fn,\n        ctx : ctx || this\n    });\n    return this;\n};\n\n/**\n * Removes an event listener or any matching listeners if arguments are omitted.\n * @param {string} [evt] Event name. Removes all listeners if omitted.\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\n * @returns {util.EventEmitter} `this`\n */\nEventEmitter.prototype.off = function off(evt, fn) {\n    if (evt === undefined)\n        this._listeners = {};\n    else {\n        if (fn === undefined)\n            this._listeners[evt] = [];\n        else {\n            var listeners = this._listeners[evt];\n            for (var i = 0; i < listeners.length;)\n                if (listeners[i].fn === fn)\n                    listeners.splice(i, 1);\n                else\n                    ++i;\n        }\n    }\n    return this;\n};\n\n/**\n * Emits an event by calling its listeners with the specified arguments.\n * @param {string} evt Event name\n * @param {...*} args Arguments\n * @returns {util.EventEmitter} `this`\n */\nEventEmitter.prototype.emit = function emit(evt) {\n    var listeners = this._listeners[evt];\n    if (listeners) {\n        var args = [],\n            i = 1;\n        for (; i < arguments.length;)\n            args.push(arguments[i++]);\n        for (i = 0; i < listeners.length;)\n            listeners[i].fn.apply(listeners[i++].ctx, args);\n    }\n    return this;\n};\n\n},{}],4:[function(require,module,exports){\n\"use strict\";\nmodule.exports = inquire;\n\n/**\n * Requires a module only if available.\n * @memberof util\n * @param {string} moduleName Module to require\n * @returns {?Object} Required module if available and not empty, otherwise `null`\n */\nfunction inquire(moduleName) {\n    try {\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\n        if (mod && (mod.length || Object.keys(mod).length))\n            return mod;\n    } catch (e) {} // eslint-disable-line no-empty\n    return null;\n}\n\n},{}],5:[function(require,module,exports){\n\"use strict\";\nmodule.exports = pool;\n\n/**\n * An allocator as used by {@link util.pool}.\n * @typedef PoolAllocator\n * @type {function}\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\n\n/**\n * A slicer as used by {@link util.pool}.\n * @typedef PoolSlicer\n * @type {function}\n * @param {number} start Start offset\n * @param {number} end End offset\n * @returns {Uint8Array} Buffer slice\n * @this {Uint8Array}\n */\n\n/**\n * A general purpose buffer pool.\n * @memberof util\n * @function\n * @param {PoolAllocator} alloc Allocator\n * @param {PoolSlicer} slice Slicer\n * @param {number} [size=8192] Slab size\n * @returns {PoolAllocator} Pooled allocator\n */\nfunction pool(alloc, slice, size) {\n    var SIZE   = size || 8192;\n    var MAX    = SIZE >>> 1;\n    var slab   = null;\n    var offset = SIZE;\n    return function pool_alloc(size) {\n        if (size < 1 || size > MAX)\n            return alloc(size);\n        if (offset + size > SIZE) {\n            slab = alloc(SIZE);\n            offset = 0;\n        }\n        var buf = slice.call(slab, offset, offset += size);\n        if (offset & 7) // align to 32 bit\n            offset = (offset | 7) + 1;\n        return buf;\n    };\n}\n\n},{}],6:[function(require,module,exports){\n\"use strict\";\n\n/**\n * A minimal UTF8 implementation for number arrays.\n * @memberof util\n * @namespace\n */\nvar utf8 = exports;\n\n/**\n * Calculates the UTF8 byte length of a string.\n * @param {string} string String\n * @returns {number} Byte length\n */\nutf8.length = function utf8_length(string) {\n    var len = 0,\n        c = 0;\n    for (var i = 0; i < string.length; ++i) {\n        c = string.charCodeAt(i);\n        if (c < 128)\n            len += 1;\n        else if (c < 2048)\n            len += 2;\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\n            ++i;\n            len += 4;\n        } else\n            len += 3;\n    }\n    return len;\n};\n\n/**\n * Reads UTF8 bytes as a string.\n * @param {Uint8Array} buffer Source buffer\n * @param {number} start Source start\n * @param {number} end Source end\n * @returns {string} String read\n */\nutf8.read = function utf8_read(buffer, start, end) {\n    var len = end - start;\n    if (len < 1)\n        return \"\";\n    var parts = null,\n        chunk = [],\n        i = 0, // char offset\n        t;     // temporary\n    while (start < end) {\n        t = buffer[start++];\n        if (t < 128)\n            chunk[i++] = t;\n        else if (t > 191 && t < 224)\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\n        else if (t > 239 && t < 365) {\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\n            chunk[i++] = 0xD800 + (t >> 10);\n            chunk[i++] = 0xDC00 + (t & 1023);\n        } else\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\n        if (i > 8191) {\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n            i = 0;\n        }\n    }\n    if (parts) {\n        if (i)\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n        return parts.join(\"\");\n    }\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\n};\n\n/**\n * Writes a string as UTF8 bytes.\n * @param {string} string Source string\n * @param {Uint8Array} buffer Destination buffer\n * @param {number} offset Destination offset\n * @returns {number} Bytes written\n */\nutf8.write = function utf8_write(string, buffer, offset) {\n    var start = offset,\n        c1, // character 1\n        c2; // character 2\n    for (var i = 0; i < string.length; ++i) {\n        c1 = string.charCodeAt(i);\n        if (c1 < 128) {\n            buffer[offset++] = c1;\n        } else if (c1 < 2048) {\n            buffer[offset++] = c1 >> 6       | 192;\n            buffer[offset++] = c1       & 63 | 128;\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\n            ++i;\n            buffer[offset++] = c1 >> 18      | 240;\n            buffer[offset++] = c1 >> 12 & 63 | 128;\n            buffer[offset++] = c1 >> 6  & 63 | 128;\n            buffer[offset++] = c1       & 63 | 128;\n        } else {\n            buffer[offset++] = c1 >> 12      | 224;\n            buffer[offset++] = c1 >> 6  & 63 | 128;\n            buffer[offset++] = c1       & 63 | 128;\n        }\n    }\n    return offset - start;\n};\n\n},{}],7:[function(require,module,exports){\n\"use strict\";\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available accross modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\nprotobuf.roots = {};\n\n// Serialization\nprotobuf.Writer       = require(14);\nprotobuf.BufferWriter = require(15);\nprotobuf.Reader       = require(8);\nprotobuf.BufferReader = require(9);\n\n// Utility\nprotobuf.util         = require(13);\nprotobuf.rpc          = require(10);\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.Reader._configure(protobuf.BufferReader);\n    protobuf.util._configure();\n}\n\n// Configure serialization\nprotobuf.Writer._configure(protobuf.BufferWriter);\nconfigure();\n\n},{\"10\":10,\"13\":13,\"14\":14,\"15\":15,\"8\":8,\"9\":9}],8:[function(require,module,exports){\n\"use strict\";\nmodule.exports = Reader;\n\nvar util      = require(13);\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = util.Buffer\n    ? function create_buffer_setup(buffer) {\n        return (Reader.create = function create_buffer(buffer) {\n            return util.Buffer.isBuffer(buffer)\n                ? new BufferReader(buffer)\n                /* istanbul ignore next */\n                : create_array(buffer);\n        })(buffer);\n    }\n    /* istanbul ignore next */\n    : create_array;\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore next */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore next */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore next */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long|number} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long|number} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long|number} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32(buf, end) {\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore next */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore next */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore next */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32(this.buf, this.pos += 4), readFixed32(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long|number} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long|number} Value read\n */\n\nvar readFloat = typeof Float32Array !== \"undefined\"\n    ? (function() {\n        var f32 = new Float32Array(1),\n            f8b = new Uint8Array(f32.buffer);\n        f32[0] = -0;\n        return f8b[3] // already le?\n            ? function readFloat_f32(buf, pos) {\n                f8b[0] = buf[pos    ];\n                f8b[1] = buf[pos + 1];\n                f8b[2] = buf[pos + 2];\n                f8b[3] = buf[pos + 3];\n                return f32[0];\n            }\n            /* istanbul ignore next */\n            : function readFloat_f32_le(buf, pos) {\n                f8b[0] = buf[pos + 3];\n                f8b[1] = buf[pos + 2];\n                f8b[2] = buf[pos + 1];\n                f8b[3] = buf[pos    ];\n                return f32[0];\n            };\n    })()\n    /* istanbul ignore next */\n    : function readFloat_ieee754(buf, pos) {\n        var uint = readFixed32(buf, pos + 4),\n            sign = (uint >> 31) * 2 + 1,\n            exponent = uint >>> 23 & 255,\n            mantissa = uint & 8388607;\n        return exponent === 255\n            ? mantissa\n              ? NaN\n              : sign * Infinity\n            : exponent === 0 // denormal\n              ? sign * 1.401298464324817e-45 * mantissa\n              : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\n    };\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore next */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = readFloat(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\nvar readDouble = typeof Float64Array !== \"undefined\"\n    ? (function() {\n        var f64 = new Float64Array(1),\n            f8b = new Uint8Array(f64.buffer);\n        f64[0] = -0;\n        return f8b[7] // already le?\n            ? function readDouble_f64(buf, pos) {\n                f8b[0] = buf[pos    ];\n                f8b[1] = buf[pos + 1];\n                f8b[2] = buf[pos + 2];\n                f8b[3] = buf[pos + 3];\n                f8b[4] = buf[pos + 4];\n                f8b[5] = buf[pos + 5];\n                f8b[6] = buf[pos + 6];\n                f8b[7] = buf[pos + 7];\n                return f64[0];\n            }\n            /* istanbul ignore next */\n            : function readDouble_f64_le(buf, pos) {\n                f8b[0] = buf[pos + 7];\n                f8b[1] = buf[pos + 6];\n                f8b[2] = buf[pos + 5];\n                f8b[3] = buf[pos + 4];\n                f8b[4] = buf[pos + 3];\n                f8b[5] = buf[pos + 2];\n                f8b[6] = buf[pos + 1];\n                f8b[7] = buf[pos    ];\n                return f64[0];\n            };\n    })()\n    /* istanbul ignore next */\n    : function readDouble_ieee754(buf, pos) {\n        var lo = readFixed32(buf, pos + 4),\n            hi = readFixed32(buf, pos + 8);\n        var sign = (hi >> 31) * 2 + 1,\n            exponent = hi >>> 20 & 2047,\n            mantissa = 4294967296 * (hi & 1048575) + lo;\n        return exponent === 2047\n            ? mantissa\n              ? NaN\n              : sign * Infinity\n            : exponent === 0 // denormal\n              ? sign * 5e-324 * mantissa\n              : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\n    };\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore next */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = readDouble(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore next */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1\n        ? new this.buf.constructor(0)\n        : this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore next */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        /* istanbul ignore next */\n        do {\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            do { // eslint-disable-line no-constant-condition\n                if ((wireType = this.uint32() & 7) === 4)\n                    break;\n                this.skipType(wireType);\n            } while (true);\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n\n},{\"13\":13}],9:[function(require,module,exports){\n\"use strict\";\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = require(8);\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = require(13);\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\n/* istanbul ignore else */\nif (util.Buffer)\n    BufferReader.prototype._slice = util.Buffer.prototype.slice;\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\n},{\"13\":13,\"8\":8}],10:[function(require,module,exports){\n\"use strict\";\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {?Error} error Error, if any, otherwise `null`\n * @param {?Uint8Array} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = require(11);\n\n},{\"11\":11}],11:[function(require,module,exports){\n\"use strict\";\nmodule.exports = Service;\n\nvar util = require(13);\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @type {function}\n * @param {?Error} error Error, if any\n * @param {?Message} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.ServiceMethodMixin|ServiceMethodMixin} and thus {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @type {function}\n * @param {Message|Object.<string,*>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * A service method mixin.\n *\n * When using TypeScript, mixed in service methods are only supported directly with a type definition of a static module (used with reflection). Otherwise, explicit casting is required.\n * @typedef rpc.ServiceMethodMixin\n * @type {Object.<string,rpc.ServiceMethod>}\n * @example\n * // Explicit casting with TypeScript\n * (myRpcService[\"myMethod\"] as protobuf.rpc.ServiceMethod)(...)\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @augments rpc.ServiceMethodMixin\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {?RPCImpl}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod} method Reflected or static method\n * @param {function} requestCtor Request constructor\n * @param {function} responseCtor Response constructor\n * @param {Message|Object.<string,*>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback} callback Service callback\n * @returns {undefined}\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n\n},{\"13\":13}],12:[function(require,module,exports){\n\"use strict\";\nmodule.exports = LongBits;\n\nvar util = require(13);\n\n/**\n * Any compatible Long instance.\n *\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @typedef Long\n * @type {Object}\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n\n},{\"13\":13}],13:[function(require,module,exports){\n\"use strict\";\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = require(1);\n\n// converts to / from base64 encoded strings\nutil.base64 = require(2);\n\n// base class of rpc.Service\nutil.EventEmitter = require(3);\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = require(4);\n\n// converts to / from utf8 encoded strings\nutil.utf8 = require(6);\n\n// provides a node-like buffer pool in the browser\nutil.pool = require(5);\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = require(12);\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(global.process && global.process.versions && global.process.versions.node);\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Node's Buffer class if available.\n * @type {?function(new: Buffer)}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n/**\n * Internal alias of or polyfull for Buffer.from.\n * @type {?function}\n * @param {string|number[]} value Value\n * @param {string} [encoding] Encoding if value is a string\n * @returns {Uint8Array}\n * @private\n */\nutil._Buffer_from = null;\n\n/**\n * Internal alias of or polyfill for Buffer.allocUnsafe.\n * @type {?function}\n * @param {number} size Buffer size\n * @returns {Uint8Array}\n * @private\n */\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {?function(new: Uint8Array, *)}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Long.js's Long class if available.\n * @type {?function(new: Long)}\n */\nutil.Long = /* istanbul ignore next */ global.dcodeIO && /* istanbul ignore next */ global.dcodeIO.Long || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {function} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: (new Error()).stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;\n\n    Object.defineProperty(CustomError.prototype, \"name\", { get: function() { return name; } });\n\n    CustomError.prototype.toString = function toString() {\n        return this.name + \": \" + this.message;\n    };\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>=} properties Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message}\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {function():string|undefined} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {function(?string):undefined} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Lazily resolves fully qualified type names against the specified root.\n * @param {Root} root Root instanceof\n * @param {Object.<number,string|ReflectionObject>} lazyTypes Type names\n * @returns {undefined}\n */\nutil.lazyResolve = function lazyResolve(root, lazyTypes) {\n    for (var i = 0; i < lazyTypes.length; ++i) {\n        for (var keys = Object.keys(lazyTypes[i]), j = 0; j < keys.length; ++j) {\n            var path = lazyTypes[i][keys[j]].split(\".\"),\n                ptr  = root;\n            while (path.length)\n                ptr = ptr[path.shift()];\n            lazyTypes[i][keys[j]] = ptr;\n        }\n    }\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations. Longs, enums and bytes are converted to strings by default.\n * @type {ConversionOptions}\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String\n};\n\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n\n},{\"1\":1,\"12\":12,\"2\":2,\"3\":3,\"4\":4,\"5\":5,\"6\":6}],14:[function(require,module,exports){\n\"use strict\";\nmodule.exports = Writer;\n\nvar util      = require(13);\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @private\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {?State}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {?Object}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = util.Buffer\n    ? function create_buffer_setup() {\n        return (Writer.create = function create_buffer() {\n            return new BufferWriter();\n        })();\n    }\n    /* istanbul ignore next */\n    : function create_array() {\n        return new Writer();\n    };\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this.push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this.push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this.push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this.push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos++] =  val         & 255;\n    buf[pos++] =  val >>> 8   & 255;\n    buf[pos++] =  val >>> 16  & 255;\n    buf[pos  ] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this.push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this.push(writeFixed32, 4, bits.lo).push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\nvar writeFloat = typeof Float32Array !== \"undefined\"\n    ? (function() {\n        var f32 = new Float32Array(1),\n            f8b = new Uint8Array(f32.buffer);\n        f32[0] = -0;\n        return f8b[3] // already le?\n            ? function writeFloat_f32(val, buf, pos) {\n                f32[0] = val;\n                buf[pos++] = f8b[0];\n                buf[pos++] = f8b[1];\n                buf[pos++] = f8b[2];\n                buf[pos  ] = f8b[3];\n            }\n            /* istanbul ignore next */\n            : function writeFloat_f32_le(val, buf, pos) {\n                f32[0] = val;\n                buf[pos++] = f8b[3];\n                buf[pos++] = f8b[2];\n                buf[pos++] = f8b[1];\n                buf[pos  ] = f8b[0];\n            };\n    })()\n    /* istanbul ignore next */\n    : function writeFloat_ieee754(value, buf, pos) {\n        var sign = value < 0 ? 1 : 0;\n        if (sign)\n            value = -value;\n        if (value === 0)\n            writeFixed32(1 / value > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\n        else if (isNaN(value))\n            writeFixed32(2147483647, buf, pos);\n        else if (value > 3.4028234663852886e+38) // +-Infinity\n            writeFixed32((sign << 31 | 2139095040) >>> 0, buf, pos);\n        else if (value < 1.1754943508222875e-38) // denormal\n            writeFixed32((sign << 31 | Math.round(value / 1.401298464324817e-45)) >>> 0, buf, pos);\n        else {\n            var exponent = Math.floor(Math.log(value) / Math.LN2),\n                mantissa = Math.round(value * Math.pow(2, -exponent) * 8388608) & 8388607;\n            writeFixed32((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\n        }\n    };\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this.push(writeFloat, 4, value);\n};\n\nvar writeDouble = typeof Float64Array !== \"undefined\"\n    ? (function() {\n        var f64 = new Float64Array(1),\n            f8b = new Uint8Array(f64.buffer);\n        f64[0] = -0;\n        return f8b[7] // already le?\n            ? function writeDouble_f64(val, buf, pos) {\n                f64[0] = val;\n                buf[pos++] = f8b[0];\n                buf[pos++] = f8b[1];\n                buf[pos++] = f8b[2];\n                buf[pos++] = f8b[3];\n                buf[pos++] = f8b[4];\n                buf[pos++] = f8b[5];\n                buf[pos++] = f8b[6];\n                buf[pos  ] = f8b[7];\n            }\n            /* istanbul ignore next */\n            : function writeDouble_f64_le(val, buf, pos) {\n                f64[0] = val;\n                buf[pos++] = f8b[7];\n                buf[pos++] = f8b[6];\n                buf[pos++] = f8b[5];\n                buf[pos++] = f8b[4];\n                buf[pos++] = f8b[3];\n                buf[pos++] = f8b[2];\n                buf[pos++] = f8b[1];\n                buf[pos  ] = f8b[0];\n            };\n    })()\n    /* istanbul ignore next */\n    : function writeDouble_ieee754(value, buf, pos) {\n        var sign = value < 0 ? 1 : 0;\n        if (sign)\n            value = -value;\n        if (value === 0) {\n            writeFixed32(0, buf, pos);\n            writeFixed32(1 / value > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + 4);\n        } else if (isNaN(value)) {\n            writeFixed32(4294967295, buf, pos);\n            writeFixed32(2147483647, buf, pos + 4);\n        } else if (value > 1.7976931348623157e+308) { // +-Infinity\n            writeFixed32(0, buf, pos);\n            writeFixed32((sign << 31 | 2146435072) >>> 0, buf, pos + 4);\n        } else {\n            var mantissa;\n            if (value < 2.2250738585072014e-308) { // denormal\n                mantissa = value / 5e-324;\n                writeFixed32(mantissa >>> 0, buf, pos);\n                writeFixed32((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + 4);\n            } else {\n                var exponent = Math.floor(Math.log(value) / Math.LN2);\n                if (exponent === 1024)\n                    exponent = 1023;\n                mantissa = value * Math.pow(2, -exponent);\n                writeFixed32(mantissa * 4503599627370496 >>> 0, buf, pos);\n                writeFixed32((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + 4);\n            }\n        }\n    };\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this.push(writeDouble, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this.push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len).push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len).push(utf8.write, len, value)\n        : this.push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n};\n\n},{\"13\":13}],15:[function(require,module,exports){\n\"use strict\";\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = require(14);\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = require(13);\n\nvar Buffer = util.Buffer;\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Buffer} Buffer\n */\nBufferWriter.alloc = function alloc_buffer(size) {\n    return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);\n};\n\nvar writeBytesBuffer = Buffer && Buffer.prototype instanceof Uint8Array && Buffer.prototype.set.name === \"set\"\n    ? function writeBytesBuffer_set(val, buf, pos) {\n        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n                           // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytesBuffer_copy(val, buf, pos) {\n        if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n        else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n    };\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this.push(writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else\n        buf.utf8Write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this.push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\n},{\"13\":13,\"14\":14}]},{},[7])\n\n})(tmp);\n//# sourceMappingURL=protobuf.js.map\n\nexport default tmp.protobuf;\n"]},"metadata":{},"sourceType":"module"}