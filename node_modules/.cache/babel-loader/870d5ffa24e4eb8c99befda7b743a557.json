{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Intersect from \"./Intersect.js\";\nimport Interval from \"./Interval.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Rectangle from \"./Rectangle.js\";\n/**\n * A bounding sphere with a center and a radius.\n * @alias BoundingSphere\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the bounding sphere.\n * @param {Number} [radius=0.0] The radius of the bounding sphere.\n *\n * @see AxisAlignedBoundingBox\n * @see BoundingRectangle\n * @see Packable\n */\n\nfunction BoundingSphere(center, radius) {\n  /**\n   * The center point of the sphere.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));\n  /**\n   * The radius of the sphere.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.radius = defaultValue(radius, 0.0);\n}\n\nvar fromPointsXMin = new Cartesian3();\nvar fromPointsYMin = new Cartesian3();\nvar fromPointsZMin = new Cartesian3();\nvar fromPointsXMax = new Cartesian3();\nvar fromPointsYMax = new Cartesian3();\nvar fromPointsZMax = new Cartesian3();\nvar fromPointsCurrentPos = new Cartesian3();\nvar fromPointsScratch = new Cartesian3();\nvar fromPointsRitterCenter = new Cartesian3();\nvar fromPointsMinBoxPt = new Cartesian3();\nvar fromPointsMaxBoxPt = new Cartesian3();\nvar fromPointsNaiveCenterScratch = new Cartesian3();\nvar volumeConstant = 4.0 / 3.0 * CesiumMath.PI;\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points.\n * The bounding sphere is computed by running two algorithms, a naive algorithm and\n * Ritter's algorithm. The smaller of the two spheres is used to ensure a tight fit.\n *\n * @param {Cartesian3[]} [positions] An array of points that the bounding sphere will enclose.  Each point must have <code>x</code>, <code>y</code>, and <code>z</code> properties.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n *\n * @see {@link http://help.agi.com/AGIComponents/html/BlogBoundingSphere.htm|Bounding Sphere computation article}\n */\n\nBoundingSphere.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  var currentPos = Cartesian3.clone(positions[0], fromPointsCurrentPos);\n  var xMin = Cartesian3.clone(currentPos, fromPointsXMin);\n  var yMin = Cartesian3.clone(currentPos, fromPointsYMin);\n  var zMin = Cartesian3.clone(currentPos, fromPointsZMin);\n  var xMax = Cartesian3.clone(currentPos, fromPointsXMax);\n  var yMax = Cartesian3.clone(currentPos, fromPointsYMax);\n  var zMax = Cartesian3.clone(currentPos, fromPointsZMax);\n  var numPositions = positions.length;\n  var i;\n\n  for (i = 1; i < numPositions; i++) {\n    Cartesian3.clone(positions[i], currentPos);\n    var x = currentPos.x;\n    var y = currentPos.y;\n    var z = currentPos.z; // Store points containing the the smallest and largest components\n\n    if (x < xMin.x) {\n      Cartesian3.clone(currentPos, xMin);\n    }\n\n    if (x > xMax.x) {\n      Cartesian3.clone(currentPos, xMax);\n    }\n\n    if (y < yMin.y) {\n      Cartesian3.clone(currentPos, yMin);\n    }\n\n    if (y > yMax.y) {\n      Cartesian3.clone(currentPos, yMax);\n    }\n\n    if (z < zMin.z) {\n      Cartesian3.clone(currentPos, zMin);\n    }\n\n    if (z > zMax.z) {\n      Cartesian3.clone(currentPos, zMax);\n    }\n  } // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n\n\n  var xSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(xMax, xMin, fromPointsScratch));\n  var ySpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(yMax, yMin, fromPointsScratch));\n  var zSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(zMax, zMin, fromPointsScratch)); // Set the diameter endpoints to the largest span.\n\n  var diameter1 = xMin;\n  var diameter2 = xMax;\n  var maxSpan = xSpan;\n\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  } // Calculate the center of the initial sphere found by Ritter's algorithm\n\n\n  var ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5; // Calculate the radius of the initial sphere found by Ritter's algorithm\n\n  var radiusSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch));\n  var ritterRadius = Math.sqrt(radiusSquared); // Find the center of the sphere found using the Naive method.\n\n  var minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n  var maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n  var naiveCenter = Cartesian3.midpoint(minBoxPt, maxBoxPt, fromPointsNaiveCenterScratch); // Begin 2nd pass to find naive radius and modify the ritter sphere.\n\n  var naiveRadius = 0;\n\n  for (i = 0; i < numPositions; i++) {\n    Cartesian3.clone(positions[i], currentPos); // Find the furthest point from the naive center to calculate the naive radius.\n\n    var r = Cartesian3.magnitude(Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch));\n\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    } // Make adjustments to the Ritter Sphere to include all points.\n\n\n    var oldCenterToPointSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch));\n\n    if (oldCenterToPointSquared > radiusSquared) {\n      var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared); // Calculate new radius to include the point that lies outside\n\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius; // Calculate center of new Ritter sphere\n\n      var oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\n      ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\n      ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    Cartesian3.clone(ritterCenter, result.center);\n    result.radius = ritterRadius;\n  } else {\n    Cartesian3.clone(naiveCenter, result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n};\n\nvar defaultProjection = new GeographicProjection();\nvar fromRectangle2DLowerLeft = new Cartesian3();\nvar fromRectangle2DUpperRight = new Cartesian3();\nvar fromRectangle2DSouthwest = new Cartographic();\nvar fromRectangle2DNortheast = new Cartographic();\n/**\n * Computes a bounding sphere from a rectangle projected in 2D.\n *\n * @param {Rectangle} [rectangle] The rectangle around which to create a bounding sphere.\n * @param {Object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\n\nBoundingSphere.fromRectangle2D = function (rectangle, projection, result) {\n  return BoundingSphere.fromRectangleWithHeights2D(rectangle, projection, 0.0, 0.0, result);\n};\n/**\n * Computes a bounding sphere from a rectangle projected in 2D.  The bounding sphere accounts for the\n * object's minimum and maximum heights over the rectangle.\n *\n * @param {Rectangle} [rectangle] The rectangle around which to create a bounding sphere.\n * @param {Object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\n * @param {Number} [minimumHeight=0.0] The minimum height over the rectangle.\n * @param {Number} [maximumHeight=0.0] The maximum height over the rectangle.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\n\n\nBoundingSphere.fromRectangleWithHeights2D = function (rectangle, projection, minimumHeight, maximumHeight, result) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!defined(rectangle)) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  projection = defaultValue(projection, defaultProjection);\n  Rectangle.southwest(rectangle, fromRectangle2DSouthwest);\n  fromRectangle2DSouthwest.height = minimumHeight;\n  Rectangle.northeast(rectangle, fromRectangle2DNortheast);\n  fromRectangle2DNortheast.height = maximumHeight;\n  var lowerLeft = projection.project(fromRectangle2DSouthwest, fromRectangle2DLowerLeft);\n  var upperRight = projection.project(fromRectangle2DNortheast, fromRectangle2DUpperRight);\n  var width = upperRight.x - lowerLeft.x;\n  var height = upperRight.y - lowerLeft.y;\n  var elevation = upperRight.z - lowerLeft.z;\n  result.radius = Math.sqrt(width * width + height * height + elevation * elevation) * 0.5;\n  var center = result.center;\n  center.x = lowerLeft.x + width * 0.5;\n  center.y = lowerLeft.y + height * 0.5;\n  center.z = lowerLeft.z + elevation * 0.5;\n  return result;\n};\n\nvar fromRectangle3DScratch = [];\n/**\n * Computes a bounding sphere from a rectangle in 3D. The bounding sphere is created using a subsample of points\n * on the ellipsoid and contained in the rectangle. It may not be accurate for all rectangles on all types of ellipsoids.\n *\n * @param {Rectangle} [rectangle] The valid rectangle used to create a bounding sphere.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid used to determine positions of the rectangle.\n * @param {Number} [surfaceHeight=0.0] The height above the surface of the ellipsoid.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\n\nBoundingSphere.fromRectangle3D = function (rectangle, ellipsoid, surfaceHeight, result) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  surfaceHeight = defaultValue(surfaceHeight, 0.0);\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!defined(rectangle)) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  var positions = Rectangle.subsample(rectangle, ellipsoid, surfaceHeight, fromRectangle3DScratch);\n  return BoundingSphere.fromPoints(positions, result);\n};\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of 3D points, where the points are\n * stored in a flat array in X, Y, Z, order.  The bounding sphere is computed by running two\n * algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to\n * ensure a tight fit.\n *\n * @param {Number[]} [positions] An array of points that the bounding sphere will enclose.  Each point\n *        is formed from three elements in the array in the order X, Y, Z.\n * @param {Cartesian3} [center=Cartesian3.ZERO] The position to which the positions are relative, which need not be the\n *        origin of the coordinate system.  This is useful when the positions are to be used for\n *        relative-to-center (RTC) rendering.\n * @param {Number} [stride=3] The number of array elements per vertex.  It must be at least 3, but it may\n *        be higher.  Regardless of the value of this parameter, the X coordinate of the first position\n *        is at array index 0, the Y coordinate is at array index 1, and the Z coordinate is at array index\n *        2.  When stride is 3, the X coordinate of the next position then begins at array index 3.  If\n *        the stride is 5, however, two array elements are skipped and the next position begins at array\n *        index 5.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n *\n * @example\n * // Compute the bounding sphere from 3 positions, each specified relative to a center.\n * // In addition to the X, Y, and Z coordinates, the points array contains two additional\n * // elements per point which are ignored for the purpose of computing the bounding sphere.\n * var center = new Cesium.Cartesian3(1.0, 2.0, 3.0);\n * var points = [1.0, 2.0, 3.0, 0.1, 0.2,\n *               4.0, 5.0, 6.0, 0.1, 0.2,\n *               7.0, 8.0, 9.0, 0.1, 0.2];\n * var sphere = Cesium.BoundingSphere.fromVertices(points, center, 5);\n *\n * @see {@link http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/|Bounding Sphere computation article}\n */\n\n\nBoundingSphere.fromVertices = function (positions, center, stride, result) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  center = defaultValue(center, Cartesian3.ZERO);\n  stride = defaultValue(stride, 3); //>>includeStart('debug', pragmas.debug);\n\n  Check.typeOf.number.greaterThanOrEquals(\"stride\", stride, 3); //>>includeEnd('debug');\n\n  var currentPos = fromPointsCurrentPos;\n  currentPos.x = positions[0] + center.x;\n  currentPos.y = positions[1] + center.y;\n  currentPos.z = positions[2] + center.z;\n  var xMin = Cartesian3.clone(currentPos, fromPointsXMin);\n  var yMin = Cartesian3.clone(currentPos, fromPointsYMin);\n  var zMin = Cartesian3.clone(currentPos, fromPointsZMin);\n  var xMax = Cartesian3.clone(currentPos, fromPointsXMax);\n  var yMax = Cartesian3.clone(currentPos, fromPointsYMax);\n  var zMax = Cartesian3.clone(currentPos, fromPointsZMax);\n  var numElements = positions.length;\n  var i;\n\n  for (i = 0; i < numElements; i += stride) {\n    var x = positions[i] + center.x;\n    var y = positions[i + 1] + center.y;\n    var z = positions[i + 2] + center.z;\n    currentPos.x = x;\n    currentPos.y = y;\n    currentPos.z = z; // Store points containing the the smallest and largest components\n\n    if (x < xMin.x) {\n      Cartesian3.clone(currentPos, xMin);\n    }\n\n    if (x > xMax.x) {\n      Cartesian3.clone(currentPos, xMax);\n    }\n\n    if (y < yMin.y) {\n      Cartesian3.clone(currentPos, yMin);\n    }\n\n    if (y > yMax.y) {\n      Cartesian3.clone(currentPos, yMax);\n    }\n\n    if (z < zMin.z) {\n      Cartesian3.clone(currentPos, zMin);\n    }\n\n    if (z > zMax.z) {\n      Cartesian3.clone(currentPos, zMax);\n    }\n  } // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n\n\n  var xSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(xMax, xMin, fromPointsScratch));\n  var ySpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(yMax, yMin, fromPointsScratch));\n  var zSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(zMax, zMin, fromPointsScratch)); // Set the diameter endpoints to the largest span.\n\n  var diameter1 = xMin;\n  var diameter2 = xMax;\n  var maxSpan = xSpan;\n\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  } // Calculate the center of the initial sphere found by Ritter's algorithm\n\n\n  var ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5; // Calculate the radius of the initial sphere found by Ritter's algorithm\n\n  var radiusSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch));\n  var ritterRadius = Math.sqrt(radiusSquared); // Find the center of the sphere found using the Naive method.\n\n  var minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n  var maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n  var naiveCenter = Cartesian3.midpoint(minBoxPt, maxBoxPt, fromPointsNaiveCenterScratch); // Begin 2nd pass to find naive radius and modify the ritter sphere.\n\n  var naiveRadius = 0;\n\n  for (i = 0; i < numElements; i += stride) {\n    currentPos.x = positions[i] + center.x;\n    currentPos.y = positions[i + 1] + center.y;\n    currentPos.z = positions[i + 2] + center.z; // Find the furthest point from the naive center to calculate the naive radius.\n\n    var r = Cartesian3.magnitude(Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch));\n\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    } // Make adjustments to the Ritter Sphere to include all points.\n\n\n    var oldCenterToPointSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch));\n\n    if (oldCenterToPointSquared > radiusSquared) {\n      var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared); // Calculate new radius to include the point that lies outside\n\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius; // Calculate center of new Ritter sphere\n\n      var oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\n      ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\n      ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    Cartesian3.clone(ritterCenter, result.center);\n    result.radius = ritterRadius;\n  } else {\n    Cartesian3.clone(naiveCenter, result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n};\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of EncodedCartesian3s, where the points are\n * stored in parallel flat arrays in X, Y, Z, order.  The bounding sphere is computed by running two\n * algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to\n * ensure a tight fit.\n *\n * @param {Number[]} [positionsHigh] An array of high bits of the encoded cartesians that the bounding sphere will enclose.  Each point\n *        is formed from three elements in the array in the order X, Y, Z.\n * @param {Number[]} [positionsLow] An array of low bits of the encoded cartesians that the bounding sphere will enclose.  Each point\n *        is formed from three elements in the array in the order X, Y, Z.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n *\n * @see {@link http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/|Bounding Sphere computation article}\n */\n\n\nBoundingSphere.fromEncodedCartesianVertices = function (positionsHigh, positionsLow, result) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!defined(positionsHigh) || !defined(positionsLow) || positionsHigh.length !== positionsLow.length || positionsHigh.length === 0) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  var currentPos = fromPointsCurrentPos;\n  currentPos.x = positionsHigh[0] + positionsLow[0];\n  currentPos.y = positionsHigh[1] + positionsLow[1];\n  currentPos.z = positionsHigh[2] + positionsLow[2];\n  var xMin = Cartesian3.clone(currentPos, fromPointsXMin);\n  var yMin = Cartesian3.clone(currentPos, fromPointsYMin);\n  var zMin = Cartesian3.clone(currentPos, fromPointsZMin);\n  var xMax = Cartesian3.clone(currentPos, fromPointsXMax);\n  var yMax = Cartesian3.clone(currentPos, fromPointsYMax);\n  var zMax = Cartesian3.clone(currentPos, fromPointsZMax);\n  var numElements = positionsHigh.length;\n  var i;\n\n  for (i = 0; i < numElements; i += 3) {\n    var x = positionsHigh[i] + positionsLow[i];\n    var y = positionsHigh[i + 1] + positionsLow[i + 1];\n    var z = positionsHigh[i + 2] + positionsLow[i + 2];\n    currentPos.x = x;\n    currentPos.y = y;\n    currentPos.z = z; // Store points containing the the smallest and largest components\n\n    if (x < xMin.x) {\n      Cartesian3.clone(currentPos, xMin);\n    }\n\n    if (x > xMax.x) {\n      Cartesian3.clone(currentPos, xMax);\n    }\n\n    if (y < yMin.y) {\n      Cartesian3.clone(currentPos, yMin);\n    }\n\n    if (y > yMax.y) {\n      Cartesian3.clone(currentPos, yMax);\n    }\n\n    if (z < zMin.z) {\n      Cartesian3.clone(currentPos, zMin);\n    }\n\n    if (z > zMax.z) {\n      Cartesian3.clone(currentPos, zMax);\n    }\n  } // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n\n\n  var xSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(xMax, xMin, fromPointsScratch));\n  var ySpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(yMax, yMin, fromPointsScratch));\n  var zSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(zMax, zMin, fromPointsScratch)); // Set the diameter endpoints to the largest span.\n\n  var diameter1 = xMin;\n  var diameter2 = xMax;\n  var maxSpan = xSpan;\n\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  } // Calculate the center of the initial sphere found by Ritter's algorithm\n\n\n  var ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5; // Calculate the radius of the initial sphere found by Ritter's algorithm\n\n  var radiusSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch));\n  var ritterRadius = Math.sqrt(radiusSquared); // Find the center of the sphere found using the Naive method.\n\n  var minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n  var maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n  var naiveCenter = Cartesian3.midpoint(minBoxPt, maxBoxPt, fromPointsNaiveCenterScratch); // Begin 2nd pass to find naive radius and modify the ritter sphere.\n\n  var naiveRadius = 0;\n\n  for (i = 0; i < numElements; i += 3) {\n    currentPos.x = positionsHigh[i] + positionsLow[i];\n    currentPos.y = positionsHigh[i + 1] + positionsLow[i + 1];\n    currentPos.z = positionsHigh[i + 2] + positionsLow[i + 2]; // Find the furthest point from the naive center to calculate the naive radius.\n\n    var r = Cartesian3.magnitude(Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch));\n\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    } // Make adjustments to the Ritter Sphere to include all points.\n\n\n    var oldCenterToPointSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch));\n\n    if (oldCenterToPointSquared > radiusSquared) {\n      var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared); // Calculate new radius to include the point that lies outside\n\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius; // Calculate center of new Ritter sphere\n\n      var oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\n      ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\n      ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    Cartesian3.clone(ritterCenter, result.center);\n    result.radius = ritterRadius;\n  } else {\n    Cartesian3.clone(naiveCenter, result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n};\n/**\n * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere\n * tighly and fully encompases the box.\n *\n * @param {Cartesian3} [corner] The minimum height over the rectangle.\n * @param {Cartesian3} [oppositeCorner] The maximum height over the rectangle.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n *\n * @example\n * // Create a bounding sphere around the unit cube\n * var sphere = Cesium.BoundingSphere.fromCornerPoints(new Cesium.Cartesian3(-0.5, -0.5, -0.5), new Cesium.Cartesian3(0.5, 0.5, 0.5));\n */\n\n\nBoundingSphere.fromCornerPoints = function (corner, oppositeCorner, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"corner\", corner);\n  Check.typeOf.object(\"oppositeCorner\", oppositeCorner); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  var center = Cartesian3.midpoint(corner, oppositeCorner, result.center);\n  result.radius = Cartesian3.distance(center, oppositeCorner);\n  return result;\n};\n/**\n * Creates a bounding sphere encompassing an ellipsoid.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid around which to create a bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n *\n * @example\n * var boundingSphere = Cesium.BoundingSphere.fromEllipsoid(ellipsoid);\n */\n\n\nBoundingSphere.fromEllipsoid = function (ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  Cartesian3.clone(Cartesian3.ZERO, result.center);\n  result.radius = ellipsoid.maximumRadius;\n  return result;\n};\n\nvar fromBoundingSpheresScratch = new Cartesian3();\n/**\n * Computes a tight-fitting bounding sphere enclosing the provided array of bounding spheres.\n *\n * @param {BoundingSphere[]} [boundingSpheres] The array of bounding spheres.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\n\nBoundingSphere.fromBoundingSpheres = function (boundingSpheres, result) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!defined(boundingSpheres) || boundingSpheres.length === 0) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  var length = boundingSpheres.length;\n\n  if (length === 1) {\n    return BoundingSphere.clone(boundingSpheres[0], result);\n  }\n\n  if (length === 2) {\n    return BoundingSphere.union(boundingSpheres[0], boundingSpheres[1], result);\n  }\n\n  var positions = [];\n  var i;\n\n  for (i = 0; i < length; i++) {\n    positions.push(boundingSpheres[i].center);\n  }\n\n  result = BoundingSphere.fromPoints(positions, result);\n  var center = result.center;\n  var radius = result.radius;\n\n  for (i = 0; i < length; i++) {\n    var tmp = boundingSpheres[i];\n    radius = Math.max(radius, Cartesian3.distance(center, tmp.center, fromBoundingSpheresScratch) + tmp.radius);\n  }\n\n  result.radius = radius;\n  return result;\n};\n\nvar fromOrientedBoundingBoxScratchU = new Cartesian3();\nvar fromOrientedBoundingBoxScratchV = new Cartesian3();\nvar fromOrientedBoundingBoxScratchW = new Cartesian3();\n/**\n * Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box.\n *\n * @param {OrientedBoundingBox} orientedBoundingBox The oriented bounding box.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\n\nBoundingSphere.fromOrientedBoundingBox = function (orientedBoundingBox, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"orientedBoundingBox\", orientedBoundingBox); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  var halfAxes = orientedBoundingBox.halfAxes;\n  var u = Matrix3.getColumn(halfAxes, 0, fromOrientedBoundingBoxScratchU);\n  var v = Matrix3.getColumn(halfAxes, 1, fromOrientedBoundingBoxScratchV);\n  var w = Matrix3.getColumn(halfAxes, 2, fromOrientedBoundingBoxScratchW);\n  Cartesian3.add(u, v, u);\n  Cartesian3.add(u, w, u);\n  result.center = Cartesian3.clone(orientedBoundingBox.center, result.center);\n  result.radius = Cartesian3.magnitude(u);\n  return result;\n};\n/**\n * Duplicates a BoundingSphere instance.\n *\n * @param {BoundingSphere} sphere The bounding sphere to duplicate.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided. (Returns undefined if sphere is undefined)\n */\n\n\nBoundingSphere.clone = function (sphere, result) {\n  if (!defined(sphere)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new BoundingSphere(sphere.center, sphere.radius);\n  }\n\n  result.center = Cartesian3.clone(sphere.center, result.center);\n  result.radius = sphere.radius;\n  return result;\n};\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\n\n\nBoundingSphere.packedLength = 4;\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {BoundingSphere} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\nBoundingSphere.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var center = value.center;\n  array[startingIndex++] = center.x;\n  array[startingIndex++] = center.y;\n  array[startingIndex++] = center.z;\n  array[startingIndex] = value.radius;\n  return array;\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {BoundingSphere} [result] The object into which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n */\n\n\nBoundingSphere.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  var center = result.center;\n  center.x = array[startingIndex++];\n  center.y = array[startingIndex++];\n  center.z = array[startingIndex++];\n  result.radius = array[startingIndex];\n  return result;\n};\n\nvar unionScratch = new Cartesian3();\nvar unionScratchCenter = new Cartesian3();\n/**\n * Computes a bounding sphere that contains both the left and right bounding spheres.\n *\n * @param {BoundingSphere} left A sphere to enclose in a bounding sphere.\n * @param {BoundingSphere} right A sphere to enclose in a bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\n\nBoundingSphere.union = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  var leftCenter = left.center;\n  var leftRadius = left.radius;\n  var rightCenter = right.center;\n  var rightRadius = right.radius;\n  var toRightCenter = Cartesian3.subtract(rightCenter, leftCenter, unionScratch);\n  var centerSeparation = Cartesian3.magnitude(toRightCenter);\n\n  if (leftRadius >= centerSeparation + rightRadius) {\n    // Left sphere wins.\n    left.clone(result);\n    return result;\n  }\n\n  if (rightRadius >= centerSeparation + leftRadius) {\n    // Right sphere wins.\n    right.clone(result);\n    return result;\n  } // There are two tangent points, one on far side of each sphere.\n\n\n  var halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5; // Compute the center point halfway between the two tangent points.\n\n  var center = Cartesian3.multiplyByScalar(toRightCenter, (-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation, unionScratchCenter);\n  Cartesian3.add(center, leftCenter, center);\n  Cartesian3.clone(center, result.center);\n  result.radius = halfDistanceBetweenTangentPoints;\n  return result;\n};\n\nvar expandScratch = new Cartesian3();\n/**\n * Computes a bounding sphere by enlarging the provided sphere to contain the provided point.\n *\n * @param {BoundingSphere} sphere A sphere to expand.\n * @param {Cartesian3} point A point to enclose in a bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\n\nBoundingSphere.expand = function (sphere, point, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"point\", point); //>>includeEnd('debug');\n\n  result = BoundingSphere.clone(sphere, result);\n  var radius = Cartesian3.magnitude(Cartesian3.subtract(point, result.center, expandScratch));\n\n  if (radius > result.radius) {\n    result.radius = radius;\n  }\n\n  return result;\n};\n/**\n * Determines which side of a plane a sphere is located.\n *\n * @param {BoundingSphere} sphere The bounding sphere to test.\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere\n *                      intersects the plane.\n */\n\n\nBoundingSphere.intersectPlane = function (sphere, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"plane\", plane); //>>includeEnd('debug');\n\n  var center = sphere.center;\n  var radius = sphere.radius;\n  var normal = plane.normal;\n  var distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;\n\n  if (distanceToPlane < -radius) {\n    // The center point is negative side of the plane normal\n    return Intersect.OUTSIDE;\n  } else if (distanceToPlane < radius) {\n    // The center point is positive side of the plane, but radius extends beyond it; partial overlap\n    return Intersect.INTERSECTING;\n  }\n\n  return Intersect.INSIDE;\n};\n/**\n * Applies a 4x4 affine transformation matrix to a bounding sphere.\n *\n * @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.\n * @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\n\n\nBoundingSphere.transform = function (sphere, transform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"transform\", transform); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  result.center = Matrix4.multiplyByPoint(transform, sphere.center, result.center);\n  result.radius = Matrix4.getMaximumScale(transform) * sphere.radius;\n  return result;\n};\n\nvar distanceSquaredToScratch = new Cartesian3();\n/**\n * Computes the estimated distance squared from the closest point on a bounding sphere to a point.\n *\n * @param {BoundingSphere} sphere The sphere.\n * @param {Cartesian3} cartesian The point\n * @returns {Number} The estimated distance squared from the bounding sphere to the point.\n *\n * @example\n * // Sort bounding spheres from back to front\n * spheres.sort(function(a, b) {\n *     return Cesium.BoundingSphere.distanceSquaredTo(b, camera.positionWC) - Cesium.BoundingSphere.distanceSquaredTo(a, camera.positionWC);\n * });\n */\n\nBoundingSphere.distanceSquaredTo = function (sphere, cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"cartesian\", cartesian); //>>includeEnd('debug');\n\n  var diff = Cartesian3.subtract(sphere.center, cartesian, distanceSquaredToScratch);\n  return Cartesian3.magnitudeSquared(diff) - sphere.radius * sphere.radius;\n};\n/**\n * Applies a 4x4 affine transformation matrix to a bounding sphere where there is no scale\n * The transformation matrix is not verified to have a uniform scale of 1.\n * This method is faster than computing the general bounding sphere transform using {@link BoundingSphere.transform}.\n *\n * @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.\n * @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n *\n * @example\n * var modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(positionOnEllipsoid);\n * var boundingSphere = new Cesium.BoundingSphere();\n * var newBoundingSphere = Cesium.BoundingSphere.transformWithoutScale(boundingSphere, modelMatrix);\n */\n\n\nBoundingSphere.transformWithoutScale = function (sphere, transform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"transform\", transform); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  result.center = Matrix4.multiplyByPoint(transform, sphere.center, result.center);\n  result.radius = sphere.radius;\n  return result;\n};\n\nvar scratchCartesian3 = new Cartesian3();\n/**\n * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction\n * plus/minus the radius of the bounding sphere.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding sphere.\n *\n * @param {BoundingSphere} sphere The bounding sphere to calculate the distance to.\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding sphere from position in direction.\n */\n\nBoundingSphere.computePlaneDistances = function (sphere, position, direction, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"position\", position);\n  Check.typeOf.object(\"direction\", direction); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Interval();\n  }\n\n  var toCenter = Cartesian3.subtract(sphere.center, position, scratchCartesian3);\n  var mag = Cartesian3.dot(direction, toCenter);\n  result.start = mag - sphere.radius;\n  result.stop = mag + sphere.radius;\n  return result;\n};\n\nvar projectTo2DNormalScratch = new Cartesian3();\nvar projectTo2DEastScratch = new Cartesian3();\nvar projectTo2DNorthScratch = new Cartesian3();\nvar projectTo2DWestScratch = new Cartesian3();\nvar projectTo2DSouthScratch = new Cartesian3();\nvar projectTo2DCartographicScratch = new Cartographic();\nvar projectTo2DPositionsScratch = new Array(8);\n\nfor (var n = 0; n < 8; ++n) {\n  projectTo2DPositionsScratch[n] = new Cartesian3();\n}\n\nvar projectTo2DProjection = new GeographicProjection();\n/**\n * Creates a bounding sphere in 2D from a bounding sphere in 3D world coordinates.\n *\n * @param {BoundingSphere} sphere The bounding sphere to transform to 2D.\n * @param {Object} [projection=GeographicProjection] The projection to 2D.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\n\nBoundingSphere.projectTo2D = function (sphere, projection, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere); //>>includeEnd('debug');\n\n  projection = defaultValue(projection, projectTo2DProjection);\n  var ellipsoid = projection.ellipsoid;\n  var center = sphere.center;\n  var radius = sphere.radius;\n  var normal;\n\n  if (Cartesian3.equals(center, Cartesian3.ZERO)) {\n    // Bounding sphere is at the center. The geodetic surface normal is not\n    // defined here so pick the x-axis as a fallback.\n    normal = Cartesian3.clone(Cartesian3.UNIT_X, projectTo2DNormalScratch);\n  } else {\n    normal = ellipsoid.geodeticSurfaceNormal(center, projectTo2DNormalScratch);\n  }\n\n  var east = Cartesian3.cross(Cartesian3.UNIT_Z, normal, projectTo2DEastScratch);\n  Cartesian3.normalize(east, east);\n  var north = Cartesian3.cross(normal, east, projectTo2DNorthScratch);\n  Cartesian3.normalize(north, north);\n  Cartesian3.multiplyByScalar(normal, radius, normal);\n  Cartesian3.multiplyByScalar(north, radius, north);\n  Cartesian3.multiplyByScalar(east, radius, east);\n  var south = Cartesian3.negate(north, projectTo2DSouthScratch);\n  var west = Cartesian3.negate(east, projectTo2DWestScratch);\n  var positions = projectTo2DPositionsScratch; // top NE corner\n\n  var corner = positions[0];\n  Cartesian3.add(normal, north, corner);\n  Cartesian3.add(corner, east, corner); // top NW corner\n\n  corner = positions[1];\n  Cartesian3.add(normal, north, corner);\n  Cartesian3.add(corner, west, corner); // top SW corner\n\n  corner = positions[2];\n  Cartesian3.add(normal, south, corner);\n  Cartesian3.add(corner, west, corner); // top SE corner\n\n  corner = positions[3];\n  Cartesian3.add(normal, south, corner);\n  Cartesian3.add(corner, east, corner);\n  Cartesian3.negate(normal, normal); // bottom NE corner\n\n  corner = positions[4];\n  Cartesian3.add(normal, north, corner);\n  Cartesian3.add(corner, east, corner); // bottom NW corner\n\n  corner = positions[5];\n  Cartesian3.add(normal, north, corner);\n  Cartesian3.add(corner, west, corner); // bottom SW corner\n\n  corner = positions[6];\n  Cartesian3.add(normal, south, corner);\n  Cartesian3.add(corner, west, corner); // bottom SE corner\n\n  corner = positions[7];\n  Cartesian3.add(normal, south, corner);\n  Cartesian3.add(corner, east, corner);\n  var length = positions.length;\n\n  for (var i = 0; i < length; ++i) {\n    var position = positions[i];\n    Cartesian3.add(center, position, position);\n    var cartographic = ellipsoid.cartesianToCartographic(position, projectTo2DCartographicScratch);\n    projection.project(cartographic, position);\n  }\n\n  result = BoundingSphere.fromPoints(positions, result); // swizzle center components\n\n  center = result.center;\n  var x = center.x;\n  var y = center.y;\n  var z = center.z;\n  center.x = z;\n  center.y = x;\n  center.z = y;\n  return result;\n};\n/**\n * Determines whether or not a sphere is hidden from view by the occluder.\n *\n * @param {BoundingSphere} sphere The bounding sphere surrounding the occludee object.\n * @param {Occluder} occluder The occluder.\n * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n */\n\n\nBoundingSphere.isOccluded = function (sphere, occluder) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"occluder\", occluder); //>>includeEnd('debug');\n\n  return !occluder.isBoundingSphereVisible(sphere);\n};\n/**\n * Compares the provided BoundingSphere componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {BoundingSphere} [left] The first BoundingSphere.\n * @param {BoundingSphere} [right] The second BoundingSphere.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\n\n\nBoundingSphere.equals = function (left, right) {\n  return left === right || defined(left) && defined(right) && Cartesian3.equals(left.center, right.center) && left.radius === right.radius;\n};\n/**\n * Determines which side of a plane the sphere is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere\n *                      intersects the plane.\n */\n\n\nBoundingSphere.prototype.intersectPlane = function (plane) {\n  return BoundingSphere.intersectPlane(this, plane);\n};\n/**\n * Computes the estimated distance squared from the closest point on a bounding sphere to a point.\n *\n * @param {Cartesian3} cartesian The point\n * @returns {Number} The estimated distance squared from the bounding sphere to the point.\n *\n * @example\n * // Sort bounding spheres from back to front\n * spheres.sort(function(a, b) {\n *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\n * });\n */\n\n\nBoundingSphere.prototype.distanceSquaredTo = function (cartesian) {\n  return BoundingSphere.distanceSquaredTo(this, cartesian);\n};\n/**\n * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction\n * plus/minus the radius of the bounding sphere.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding sphere.\n *\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding sphere from position in direction.\n */\n\n\nBoundingSphere.prototype.computePlaneDistances = function (position, direction, result) {\n  return BoundingSphere.computePlaneDistances(this, position, direction, result);\n};\n/**\n * Determines whether or not a sphere is hidden from view by the occluder.\n *\n * @param {Occluder} occluder The occluder.\n * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n */\n\n\nBoundingSphere.prototype.isOccluded = function (occluder) {\n  return BoundingSphere.isOccluded(this, occluder);\n};\n/**\n * Compares this BoundingSphere against the provided BoundingSphere componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {BoundingSphere} [right] The right hand side BoundingSphere.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\n\n\nBoundingSphere.prototype.equals = function (right) {\n  return BoundingSphere.equals(this, right);\n};\n/**\n * Duplicates this BoundingSphere instance.\n *\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\n\n\nBoundingSphere.prototype.clone = function (result) {\n  return BoundingSphere.clone(this, result);\n};\n/**\n * Computes the radius of the BoundingSphere.\n * @returns {Number} The radius of the BoundingSphere.\n */\n\n\nBoundingSphere.prototype.volume = function () {\n  var radius = this.radius;\n  return volumeConstant * radius * radius * radius;\n};\n\nexport default BoundingSphere;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/BoundingSphere.js"],"names":["Cartesian3","Cartographic","Check","defaultValue","defined","Ellipsoid","GeographicProjection","Intersect","Interval","CesiumMath","Matrix3","Matrix4","Rectangle","BoundingSphere","center","radius","clone","ZERO","fromPointsXMin","fromPointsYMin","fromPointsZMin","fromPointsXMax","fromPointsYMax","fromPointsZMax","fromPointsCurrentPos","fromPointsScratch","fromPointsRitterCenter","fromPointsMinBoxPt","fromPointsMaxBoxPt","fromPointsNaiveCenterScratch","volumeConstant","PI","fromPoints","positions","result","length","currentPos","xMin","yMin","zMin","xMax","yMax","zMax","numPositions","i","x","y","z","xSpan","magnitudeSquared","subtract","ySpan","zSpan","diameter1","diameter2","maxSpan","ritterCenter","radiusSquared","ritterRadius","Math","sqrt","minBoxPt","maxBoxPt","naiveCenter","midpoint","naiveRadius","r","magnitude","oldCenterToPointSquared","oldCenterToPoint","oldToNew","defaultProjection","fromRectangle2DLowerLeft","fromRectangle2DUpperRight","fromRectangle2DSouthwest","fromRectangle2DNortheast","fromRectangle2D","rectangle","projection","fromRectangleWithHeights2D","minimumHeight","maximumHeight","southwest","height","northeast","lowerLeft","project","upperRight","width","elevation","fromRectangle3DScratch","fromRectangle3D","ellipsoid","surfaceHeight","WGS84","subsample","fromVertices","stride","typeOf","number","greaterThanOrEquals","numElements","fromEncodedCartesianVertices","positionsHigh","positionsLow","fromCornerPoints","corner","oppositeCorner","object","distance","fromEllipsoid","maximumRadius","fromBoundingSpheresScratch","fromBoundingSpheres","boundingSpheres","union","push","tmp","max","fromOrientedBoundingBoxScratchU","fromOrientedBoundingBoxScratchV","fromOrientedBoundingBoxScratchW","fromOrientedBoundingBox","orientedBoundingBox","halfAxes","u","getColumn","v","w","add","sphere","undefined","packedLength","pack","value","array","startingIndex","unpack","unionScratch","unionScratchCenter","left","right","leftCenter","leftRadius","rightCenter","rightRadius","toRightCenter","centerSeparation","halfDistanceBetweenTangentPoints","multiplyByScalar","expandScratch","expand","point","intersectPlane","plane","normal","distanceToPlane","dot","OUTSIDE","INTERSECTING","INSIDE","transform","multiplyByPoint","getMaximumScale","distanceSquaredToScratch","distanceSquaredTo","cartesian","diff","transformWithoutScale","scratchCartesian3","computePlaneDistances","position","direction","toCenter","mag","start","stop","projectTo2DNormalScratch","projectTo2DEastScratch","projectTo2DNorthScratch","projectTo2DWestScratch","projectTo2DSouthScratch","projectTo2DCartographicScratch","projectTo2DPositionsScratch","Array","n","projectTo2DProjection","projectTo2D","equals","UNIT_X","geodeticSurfaceNormal","east","cross","UNIT_Z","normalize","north","south","negate","west","cartographic","cartesianToCartographic","isOccluded","occluder","isBoundingSphereVisible","prototype","volume"],"mappings":"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","sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Intersect from \"./Intersect.js\";\nimport Interval from \"./Interval.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * A bounding sphere with a center and a radius.\n * @alias BoundingSphere\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the bounding sphere.\n * @param {Number} [radius=0.0] The radius of the bounding sphere.\n *\n * @see AxisAlignedBoundingBox\n * @see BoundingRectangle\n * @see Packable\n */\nfunction BoundingSphere(center, radius) {\n  /**\n   * The center point of the sphere.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));\n\n  /**\n   * The radius of the sphere.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.radius = defaultValue(radius, 0.0);\n}\n\nvar fromPointsXMin = new Cartesian3();\nvar fromPointsYMin = new Cartesian3();\nvar fromPointsZMin = new Cartesian3();\nvar fromPointsXMax = new Cartesian3();\nvar fromPointsYMax = new Cartesian3();\nvar fromPointsZMax = new Cartesian3();\nvar fromPointsCurrentPos = new Cartesian3();\nvar fromPointsScratch = new Cartesian3();\nvar fromPointsRitterCenter = new Cartesian3();\nvar fromPointsMinBoxPt = new Cartesian3();\nvar fromPointsMaxBoxPt = new Cartesian3();\nvar fromPointsNaiveCenterScratch = new Cartesian3();\nvar volumeConstant = (4.0 / 3.0) * CesiumMath.PI;\n\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points.\n * The bounding sphere is computed by running two algorithms, a naive algorithm and\n * Ritter's algorithm. The smaller of the two spheres is used to ensure a tight fit.\n *\n * @param {Cartesian3[]} [positions] An array of points that the bounding sphere will enclose.  Each point must have <code>x</code>, <code>y</code>, and <code>z</code> properties.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n *\n * @see {@link http://help.agi.com/AGIComponents/html/BlogBoundingSphere.htm|Bounding Sphere computation article}\n */\nBoundingSphere.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  var currentPos = Cartesian3.clone(positions[0], fromPointsCurrentPos);\n\n  var xMin = Cartesian3.clone(currentPos, fromPointsXMin);\n  var yMin = Cartesian3.clone(currentPos, fromPointsYMin);\n  var zMin = Cartesian3.clone(currentPos, fromPointsZMin);\n\n  var xMax = Cartesian3.clone(currentPos, fromPointsXMax);\n  var yMax = Cartesian3.clone(currentPos, fromPointsYMax);\n  var zMax = Cartesian3.clone(currentPos, fromPointsZMax);\n\n  var numPositions = positions.length;\n  var i;\n  for (i = 1; i < numPositions; i++) {\n    Cartesian3.clone(positions[i], currentPos);\n\n    var x = currentPos.x;\n    var y = currentPos.y;\n    var z = currentPos.z;\n\n    // Store points containing the the smallest and largest components\n    if (x < xMin.x) {\n      Cartesian3.clone(currentPos, xMin);\n    }\n\n    if (x > xMax.x) {\n      Cartesian3.clone(currentPos, xMax);\n    }\n\n    if (y < yMin.y) {\n      Cartesian3.clone(currentPos, yMin);\n    }\n\n    if (y > yMax.y) {\n      Cartesian3.clone(currentPos, yMax);\n    }\n\n    if (z < zMin.z) {\n      Cartesian3.clone(currentPos, zMin);\n    }\n\n    if (z > zMax.z) {\n      Cartesian3.clone(currentPos, zMax);\n    }\n  }\n\n  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n  var xSpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(xMax, xMin, fromPointsScratch)\n  );\n  var ySpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(yMax, yMin, fromPointsScratch)\n  );\n  var zSpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(zMax, zMin, fromPointsScratch)\n  );\n\n  // Set the diameter endpoints to the largest span.\n  var diameter1 = xMin;\n  var diameter2 = xMax;\n  var maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  // Calculate the center of the initial sphere found by Ritter's algorithm\n  var ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n  // Calculate the radius of the initial sphere found by Ritter's algorithm\n  var radiusSquared = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch)\n  );\n  var ritterRadius = Math.sqrt(radiusSquared);\n\n  // Find the center of the sphere found using the Naive method.\n  var minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n\n  var maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n\n  var naiveCenter = Cartesian3.midpoint(\n    minBoxPt,\n    maxBoxPt,\n    fromPointsNaiveCenterScratch\n  );\n\n  // Begin 2nd pass to find naive radius and modify the ritter sphere.\n  var naiveRadius = 0;\n  for (i = 0; i < numPositions; i++) {\n    Cartesian3.clone(positions[i], currentPos);\n\n    // Find the furthest point from the naive center to calculate the naive radius.\n    var r = Cartesian3.magnitude(\n      Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch)\n    );\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    // Make adjustments to the Ritter Sphere to include all points.\n    var oldCenterToPointSquared = Cartesian3.magnitudeSquared(\n      Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch)\n    );\n    if (oldCenterToPointSquared > radiusSquared) {\n      var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      // Calculate new radius to include the point that lies outside\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      // Calculate center of new Ritter sphere\n      var oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x =\n        (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) /\n        oldCenterToPoint;\n      ritterCenter.y =\n        (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) /\n        oldCenterToPoint;\n      ritterCenter.z =\n        (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) /\n        oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    Cartesian3.clone(ritterCenter, result.center);\n    result.radius = ritterRadius;\n  } else {\n    Cartesian3.clone(naiveCenter, result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n};\n\nvar defaultProjection = new GeographicProjection();\nvar fromRectangle2DLowerLeft = new Cartesian3();\nvar fromRectangle2DUpperRight = new Cartesian3();\nvar fromRectangle2DSouthwest = new Cartographic();\nvar fromRectangle2DNortheast = new Cartographic();\n\n/**\n * Computes a bounding sphere from a rectangle projected in 2D.\n *\n * @param {Rectangle} [rectangle] The rectangle around which to create a bounding sphere.\n * @param {Object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromRectangle2D = function (rectangle, projection, result) {\n  return BoundingSphere.fromRectangleWithHeights2D(\n    rectangle,\n    projection,\n    0.0,\n    0.0,\n    result\n  );\n};\n\n/**\n * Computes a bounding sphere from a rectangle projected in 2D.  The bounding sphere accounts for the\n * object's minimum and maximum heights over the rectangle.\n *\n * @param {Rectangle} [rectangle] The rectangle around which to create a bounding sphere.\n * @param {Object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\n * @param {Number} [minimumHeight=0.0] The minimum height over the rectangle.\n * @param {Number} [maximumHeight=0.0] The maximum height over the rectangle.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromRectangleWithHeights2D = function (\n  rectangle,\n  projection,\n  minimumHeight,\n  maximumHeight,\n  result\n) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!defined(rectangle)) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  projection = defaultValue(projection, defaultProjection);\n\n  Rectangle.southwest(rectangle, fromRectangle2DSouthwest);\n  fromRectangle2DSouthwest.height = minimumHeight;\n  Rectangle.northeast(rectangle, fromRectangle2DNortheast);\n  fromRectangle2DNortheast.height = maximumHeight;\n\n  var lowerLeft = projection.project(\n    fromRectangle2DSouthwest,\n    fromRectangle2DLowerLeft\n  );\n  var upperRight = projection.project(\n    fromRectangle2DNortheast,\n    fromRectangle2DUpperRight\n  );\n\n  var width = upperRight.x - lowerLeft.x;\n  var height = upperRight.y - lowerLeft.y;\n  var elevation = upperRight.z - lowerLeft.z;\n\n  result.radius =\n    Math.sqrt(width * width + height * height + elevation * elevation) * 0.5;\n  var center = result.center;\n  center.x = lowerLeft.x + width * 0.5;\n  center.y = lowerLeft.y + height * 0.5;\n  center.z = lowerLeft.z + elevation * 0.5;\n  return result;\n};\n\nvar fromRectangle3DScratch = [];\n\n/**\n * Computes a bounding sphere from a rectangle in 3D. The bounding sphere is created using a subsample of points\n * on the ellipsoid and contained in the rectangle. It may not be accurate for all rectangles on all types of ellipsoids.\n *\n * @param {Rectangle} [rectangle] The valid rectangle used to create a bounding sphere.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid used to determine positions of the rectangle.\n * @param {Number} [surfaceHeight=0.0] The height above the surface of the ellipsoid.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromRectangle3D = function (\n  rectangle,\n  ellipsoid,\n  surfaceHeight,\n  result\n) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  surfaceHeight = defaultValue(surfaceHeight, 0.0);\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!defined(rectangle)) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  var positions = Rectangle.subsample(\n    rectangle,\n    ellipsoid,\n    surfaceHeight,\n    fromRectangle3DScratch\n  );\n  return BoundingSphere.fromPoints(positions, result);\n};\n\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of 3D points, where the points are\n * stored in a flat array in X, Y, Z, order.  The bounding sphere is computed by running two\n * algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to\n * ensure a tight fit.\n *\n * @param {Number[]} [positions] An array of points that the bounding sphere will enclose.  Each point\n *        is formed from three elements in the array in the order X, Y, Z.\n * @param {Cartesian3} [center=Cartesian3.ZERO] The position to which the positions are relative, which need not be the\n *        origin of the coordinate system.  This is useful when the positions are to be used for\n *        relative-to-center (RTC) rendering.\n * @param {Number} [stride=3] The number of array elements per vertex.  It must be at least 3, but it may\n *        be higher.  Regardless of the value of this parameter, the X coordinate of the first position\n *        is at array index 0, the Y coordinate is at array index 1, and the Z coordinate is at array index\n *        2.  When stride is 3, the X coordinate of the next position then begins at array index 3.  If\n *        the stride is 5, however, two array elements are skipped and the next position begins at array\n *        index 5.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n *\n * @example\n * // Compute the bounding sphere from 3 positions, each specified relative to a center.\n * // In addition to the X, Y, and Z coordinates, the points array contains two additional\n * // elements per point which are ignored for the purpose of computing the bounding sphere.\n * var center = new Cesium.Cartesian3(1.0, 2.0, 3.0);\n * var points = [1.0, 2.0, 3.0, 0.1, 0.2,\n *               4.0, 5.0, 6.0, 0.1, 0.2,\n *               7.0, 8.0, 9.0, 0.1, 0.2];\n * var sphere = Cesium.BoundingSphere.fromVertices(points, center, 5);\n *\n * @see {@link http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/|Bounding Sphere computation article}\n */\nBoundingSphere.fromVertices = function (positions, center, stride, result) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  center = defaultValue(center, Cartesian3.ZERO);\n\n  stride = defaultValue(stride, 3);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"stride\", stride, 3);\n  //>>includeEnd('debug');\n\n  var currentPos = fromPointsCurrentPos;\n  currentPos.x = positions[0] + center.x;\n  currentPos.y = positions[1] + center.y;\n  currentPos.z = positions[2] + center.z;\n\n  var xMin = Cartesian3.clone(currentPos, fromPointsXMin);\n  var yMin = Cartesian3.clone(currentPos, fromPointsYMin);\n  var zMin = Cartesian3.clone(currentPos, fromPointsZMin);\n\n  var xMax = Cartesian3.clone(currentPos, fromPointsXMax);\n  var yMax = Cartesian3.clone(currentPos, fromPointsYMax);\n  var zMax = Cartesian3.clone(currentPos, fromPointsZMax);\n\n  var numElements = positions.length;\n  var i;\n  for (i = 0; i < numElements; i += stride) {\n    var x = positions[i] + center.x;\n    var y = positions[i + 1] + center.y;\n    var z = positions[i + 2] + center.z;\n\n    currentPos.x = x;\n    currentPos.y = y;\n    currentPos.z = z;\n\n    // Store points containing the the smallest and largest components\n    if (x < xMin.x) {\n      Cartesian3.clone(currentPos, xMin);\n    }\n\n    if (x > xMax.x) {\n      Cartesian3.clone(currentPos, xMax);\n    }\n\n    if (y < yMin.y) {\n      Cartesian3.clone(currentPos, yMin);\n    }\n\n    if (y > yMax.y) {\n      Cartesian3.clone(currentPos, yMax);\n    }\n\n    if (z < zMin.z) {\n      Cartesian3.clone(currentPos, zMin);\n    }\n\n    if (z > zMax.z) {\n      Cartesian3.clone(currentPos, zMax);\n    }\n  }\n\n  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n  var xSpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(xMax, xMin, fromPointsScratch)\n  );\n  var ySpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(yMax, yMin, fromPointsScratch)\n  );\n  var zSpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(zMax, zMin, fromPointsScratch)\n  );\n\n  // Set the diameter endpoints to the largest span.\n  var diameter1 = xMin;\n  var diameter2 = xMax;\n  var maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  // Calculate the center of the initial sphere found by Ritter's algorithm\n  var ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n  // Calculate the radius of the initial sphere found by Ritter's algorithm\n  var radiusSquared = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch)\n  );\n  var ritterRadius = Math.sqrt(radiusSquared);\n\n  // Find the center of the sphere found using the Naive method.\n  var minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n\n  var maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n\n  var naiveCenter = Cartesian3.midpoint(\n    minBoxPt,\n    maxBoxPt,\n    fromPointsNaiveCenterScratch\n  );\n\n  // Begin 2nd pass to find naive radius and modify the ritter sphere.\n  var naiveRadius = 0;\n  for (i = 0; i < numElements; i += stride) {\n    currentPos.x = positions[i] + center.x;\n    currentPos.y = positions[i + 1] + center.y;\n    currentPos.z = positions[i + 2] + center.z;\n\n    // Find the furthest point from the naive center to calculate the naive radius.\n    var r = Cartesian3.magnitude(\n      Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch)\n    );\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    // Make adjustments to the Ritter Sphere to include all points.\n    var oldCenterToPointSquared = Cartesian3.magnitudeSquared(\n      Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch)\n    );\n    if (oldCenterToPointSquared > radiusSquared) {\n      var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      // Calculate new radius to include the point that lies outside\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      // Calculate center of new Ritter sphere\n      var oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x =\n        (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) /\n        oldCenterToPoint;\n      ritterCenter.y =\n        (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) /\n        oldCenterToPoint;\n      ritterCenter.z =\n        (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) /\n        oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    Cartesian3.clone(ritterCenter, result.center);\n    result.radius = ritterRadius;\n  } else {\n    Cartesian3.clone(naiveCenter, result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n};\n\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of EncodedCartesian3s, where the points are\n * stored in parallel flat arrays in X, Y, Z, order.  The bounding sphere is computed by running two\n * algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to\n * ensure a tight fit.\n *\n * @param {Number[]} [positionsHigh] An array of high bits of the encoded cartesians that the bounding sphere will enclose.  Each point\n *        is formed from three elements in the array in the order X, Y, Z.\n * @param {Number[]} [positionsLow] An array of low bits of the encoded cartesians that the bounding sphere will enclose.  Each point\n *        is formed from three elements in the array in the order X, Y, Z.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n *\n * @see {@link http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/|Bounding Sphere computation article}\n */\nBoundingSphere.fromEncodedCartesianVertices = function (\n  positionsHigh,\n  positionsLow,\n  result\n) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (\n    !defined(positionsHigh) ||\n    !defined(positionsLow) ||\n    positionsHigh.length !== positionsLow.length ||\n    positionsHigh.length === 0\n  ) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  var currentPos = fromPointsCurrentPos;\n  currentPos.x = positionsHigh[0] + positionsLow[0];\n  currentPos.y = positionsHigh[1] + positionsLow[1];\n  currentPos.z = positionsHigh[2] + positionsLow[2];\n\n  var xMin = Cartesian3.clone(currentPos, fromPointsXMin);\n  var yMin = Cartesian3.clone(currentPos, fromPointsYMin);\n  var zMin = Cartesian3.clone(currentPos, fromPointsZMin);\n\n  var xMax = Cartesian3.clone(currentPos, fromPointsXMax);\n  var yMax = Cartesian3.clone(currentPos, fromPointsYMax);\n  var zMax = Cartesian3.clone(currentPos, fromPointsZMax);\n\n  var numElements = positionsHigh.length;\n  var i;\n  for (i = 0; i < numElements; i += 3) {\n    var x = positionsHigh[i] + positionsLow[i];\n    var y = positionsHigh[i + 1] + positionsLow[i + 1];\n    var z = positionsHigh[i + 2] + positionsLow[i + 2];\n\n    currentPos.x = x;\n    currentPos.y = y;\n    currentPos.z = z;\n\n    // Store points containing the the smallest and largest components\n    if (x < xMin.x) {\n      Cartesian3.clone(currentPos, xMin);\n    }\n\n    if (x > xMax.x) {\n      Cartesian3.clone(currentPos, xMax);\n    }\n\n    if (y < yMin.y) {\n      Cartesian3.clone(currentPos, yMin);\n    }\n\n    if (y > yMax.y) {\n      Cartesian3.clone(currentPos, yMax);\n    }\n\n    if (z < zMin.z) {\n      Cartesian3.clone(currentPos, zMin);\n    }\n\n    if (z > zMax.z) {\n      Cartesian3.clone(currentPos, zMax);\n    }\n  }\n\n  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n  var xSpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(xMax, xMin, fromPointsScratch)\n  );\n  var ySpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(yMax, yMin, fromPointsScratch)\n  );\n  var zSpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(zMax, zMin, fromPointsScratch)\n  );\n\n  // Set the diameter endpoints to the largest span.\n  var diameter1 = xMin;\n  var diameter2 = xMax;\n  var maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  // Calculate the center of the initial sphere found by Ritter's algorithm\n  var ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n  // Calculate the radius of the initial sphere found by Ritter's algorithm\n  var radiusSquared = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch)\n  );\n  var ritterRadius = Math.sqrt(radiusSquared);\n\n  // Find the center of the sphere found using the Naive method.\n  var minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n\n  var maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n\n  var naiveCenter = Cartesian3.midpoint(\n    minBoxPt,\n    maxBoxPt,\n    fromPointsNaiveCenterScratch\n  );\n\n  // Begin 2nd pass to find naive radius and modify the ritter sphere.\n  var naiveRadius = 0;\n  for (i = 0; i < numElements; i += 3) {\n    currentPos.x = positionsHigh[i] + positionsLow[i];\n    currentPos.y = positionsHigh[i + 1] + positionsLow[i + 1];\n    currentPos.z = positionsHigh[i + 2] + positionsLow[i + 2];\n\n    // Find the furthest point from the naive center to calculate the naive radius.\n    var r = Cartesian3.magnitude(\n      Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch)\n    );\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    // Make adjustments to the Ritter Sphere to include all points.\n    var oldCenterToPointSquared = Cartesian3.magnitudeSquared(\n      Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch)\n    );\n    if (oldCenterToPointSquared > radiusSquared) {\n      var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      // Calculate new radius to include the point that lies outside\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      // Calculate center of new Ritter sphere\n      var oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x =\n        (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) /\n        oldCenterToPoint;\n      ritterCenter.y =\n        (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) /\n        oldCenterToPoint;\n      ritterCenter.z =\n        (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) /\n        oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    Cartesian3.clone(ritterCenter, result.center);\n    result.radius = ritterRadius;\n  } else {\n    Cartesian3.clone(naiveCenter, result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n};\n\n/**\n * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere\n * tighly and fully encompases the box.\n *\n * @param {Cartesian3} [corner] The minimum height over the rectangle.\n * @param {Cartesian3} [oppositeCorner] The maximum height over the rectangle.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n *\n * @example\n * // Create a bounding sphere around the unit cube\n * var sphere = Cesium.BoundingSphere.fromCornerPoints(new Cesium.Cartesian3(-0.5, -0.5, -0.5), new Cesium.Cartesian3(0.5, 0.5, 0.5));\n */\nBoundingSphere.fromCornerPoints = function (corner, oppositeCorner, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"corner\", corner);\n  Check.typeOf.object(\"oppositeCorner\", oppositeCorner);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  var center = Cartesian3.midpoint(corner, oppositeCorner, result.center);\n  result.radius = Cartesian3.distance(center, oppositeCorner);\n  return result;\n};\n\n/**\n * Creates a bounding sphere encompassing an ellipsoid.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid around which to create a bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n *\n * @example\n * var boundingSphere = Cesium.BoundingSphere.fromEllipsoid(ellipsoid);\n */\nBoundingSphere.fromEllipsoid = function (ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  Cartesian3.clone(Cartesian3.ZERO, result.center);\n  result.radius = ellipsoid.maximumRadius;\n  return result;\n};\n\nvar fromBoundingSpheresScratch = new Cartesian3();\n\n/**\n * Computes a tight-fitting bounding sphere enclosing the provided array of bounding spheres.\n *\n * @param {BoundingSphere[]} [boundingSpheres] The array of bounding spheres.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromBoundingSpheres = function (boundingSpheres, result) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!defined(boundingSpheres) || boundingSpheres.length === 0) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  var length = boundingSpheres.length;\n  if (length === 1) {\n    return BoundingSphere.clone(boundingSpheres[0], result);\n  }\n\n  if (length === 2) {\n    return BoundingSphere.union(boundingSpheres[0], boundingSpheres[1], result);\n  }\n\n  var positions = [];\n  var i;\n  for (i = 0; i < length; i++) {\n    positions.push(boundingSpheres[i].center);\n  }\n\n  result = BoundingSphere.fromPoints(positions, result);\n\n  var center = result.center;\n  var radius = result.radius;\n  for (i = 0; i < length; i++) {\n    var tmp = boundingSpheres[i];\n    radius = Math.max(\n      radius,\n      Cartesian3.distance(center, tmp.center, fromBoundingSpheresScratch) +\n        tmp.radius\n    );\n  }\n  result.radius = radius;\n\n  return result;\n};\n\nvar fromOrientedBoundingBoxScratchU = new Cartesian3();\nvar fromOrientedBoundingBoxScratchV = new Cartesian3();\nvar fromOrientedBoundingBoxScratchW = new Cartesian3();\n\n/**\n * Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box.\n *\n * @param {OrientedBoundingBox} orientedBoundingBox The oriented bounding box.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromOrientedBoundingBox = function (\n  orientedBoundingBox,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"orientedBoundingBox\", orientedBoundingBox);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  var halfAxes = orientedBoundingBox.halfAxes;\n  var u = Matrix3.getColumn(halfAxes, 0, fromOrientedBoundingBoxScratchU);\n  var v = Matrix3.getColumn(halfAxes, 1, fromOrientedBoundingBoxScratchV);\n  var w = Matrix3.getColumn(halfAxes, 2, fromOrientedBoundingBoxScratchW);\n\n  Cartesian3.add(u, v, u);\n  Cartesian3.add(u, w, u);\n\n  result.center = Cartesian3.clone(orientedBoundingBox.center, result.center);\n  result.radius = Cartesian3.magnitude(u);\n\n  return result;\n};\n\n/**\n * Duplicates a BoundingSphere instance.\n *\n * @param {BoundingSphere} sphere The bounding sphere to duplicate.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided. (Returns undefined if sphere is undefined)\n */\nBoundingSphere.clone = function (sphere, result) {\n  if (!defined(sphere)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new BoundingSphere(sphere.center, sphere.radius);\n  }\n\n  result.center = Cartesian3.clone(sphere.center, result.center);\n  result.radius = sphere.radius;\n  return result;\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nBoundingSphere.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {BoundingSphere} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nBoundingSphere.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var center = value.center;\n  array[startingIndex++] = center.x;\n  array[startingIndex++] = center.y;\n  array[startingIndex++] = center.z;\n  array[startingIndex] = value.radius;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {BoundingSphere} [result] The object into which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n */\nBoundingSphere.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  var center = result.center;\n  center.x = array[startingIndex++];\n  center.y = array[startingIndex++];\n  center.z = array[startingIndex++];\n  result.radius = array[startingIndex];\n  return result;\n};\n\nvar unionScratch = new Cartesian3();\nvar unionScratchCenter = new Cartesian3();\n/**\n * Computes a bounding sphere that contains both the left and right bounding spheres.\n *\n * @param {BoundingSphere} left A sphere to enclose in a bounding sphere.\n * @param {BoundingSphere} right A sphere to enclose in a bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.union = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  var leftCenter = left.center;\n  var leftRadius = left.radius;\n  var rightCenter = right.center;\n  var rightRadius = right.radius;\n\n  var toRightCenter = Cartesian3.subtract(\n    rightCenter,\n    leftCenter,\n    unionScratch\n  );\n  var centerSeparation = Cartesian3.magnitude(toRightCenter);\n\n  if (leftRadius >= centerSeparation + rightRadius) {\n    // Left sphere wins.\n    left.clone(result);\n    return result;\n  }\n\n  if (rightRadius >= centerSeparation + leftRadius) {\n    // Right sphere wins.\n    right.clone(result);\n    return result;\n  }\n\n  // There are two tangent points, one on far side of each sphere.\n  var halfDistanceBetweenTangentPoints =\n    (leftRadius + centerSeparation + rightRadius) * 0.5;\n\n  // Compute the center point halfway between the two tangent points.\n  var center = Cartesian3.multiplyByScalar(\n    toRightCenter,\n    (-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation,\n    unionScratchCenter\n  );\n  Cartesian3.add(center, leftCenter, center);\n  Cartesian3.clone(center, result.center);\n  result.radius = halfDistanceBetweenTangentPoints;\n\n  return result;\n};\n\nvar expandScratch = new Cartesian3();\n/**\n * Computes a bounding sphere by enlarging the provided sphere to contain the provided point.\n *\n * @param {BoundingSphere} sphere A sphere to expand.\n * @param {Cartesian3} point A point to enclose in a bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.expand = function (sphere, point, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"point\", point);\n  //>>includeEnd('debug');\n\n  result = BoundingSphere.clone(sphere, result);\n\n  var radius = Cartesian3.magnitude(\n    Cartesian3.subtract(point, result.center, expandScratch)\n  );\n  if (radius > result.radius) {\n    result.radius = radius;\n  }\n\n  return result;\n};\n\n/**\n * Determines which side of a plane a sphere is located.\n *\n * @param {BoundingSphere} sphere The bounding sphere to test.\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere\n *                      intersects the plane.\n */\nBoundingSphere.intersectPlane = function (sphere, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"plane\", plane);\n  //>>includeEnd('debug');\n\n  var center = sphere.center;\n  var radius = sphere.radius;\n  var normal = plane.normal;\n  var distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;\n\n  if (distanceToPlane < -radius) {\n    // The center point is negative side of the plane normal\n    return Intersect.OUTSIDE;\n  } else if (distanceToPlane < radius) {\n    // The center point is positive side of the plane, but radius extends beyond it; partial overlap\n    return Intersect.INTERSECTING;\n  }\n  return Intersect.INSIDE;\n};\n\n/**\n * Applies a 4x4 affine transformation matrix to a bounding sphere.\n *\n * @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.\n * @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.transform = function (sphere, transform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"transform\", transform);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  result.center = Matrix4.multiplyByPoint(\n    transform,\n    sphere.center,\n    result.center\n  );\n  result.radius = Matrix4.getMaximumScale(transform) * sphere.radius;\n\n  return result;\n};\n\nvar distanceSquaredToScratch = new Cartesian3();\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding sphere to a point.\n *\n * @param {BoundingSphere} sphere The sphere.\n * @param {Cartesian3} cartesian The point\n * @returns {Number} The estimated distance squared from the bounding sphere to the point.\n *\n * @example\n * // Sort bounding spheres from back to front\n * spheres.sort(function(a, b) {\n *     return Cesium.BoundingSphere.distanceSquaredTo(b, camera.positionWC) - Cesium.BoundingSphere.distanceSquaredTo(a, camera.positionWC);\n * });\n */\nBoundingSphere.distanceSquaredTo = function (sphere, cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  var diff = Cartesian3.subtract(\n    sphere.center,\n    cartesian,\n    distanceSquaredToScratch\n  );\n  return Cartesian3.magnitudeSquared(diff) - sphere.radius * sphere.radius;\n};\n\n/**\n * Applies a 4x4 affine transformation matrix to a bounding sphere where there is no scale\n * The transformation matrix is not verified to have a uniform scale of 1.\n * This method is faster than computing the general bounding sphere transform using {@link BoundingSphere.transform}.\n *\n * @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.\n * @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n *\n * @example\n * var modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(positionOnEllipsoid);\n * var boundingSphere = new Cesium.BoundingSphere();\n * var newBoundingSphere = Cesium.BoundingSphere.transformWithoutScale(boundingSphere, modelMatrix);\n */\nBoundingSphere.transformWithoutScale = function (sphere, transform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"transform\", transform);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  result.center = Matrix4.multiplyByPoint(\n    transform,\n    sphere.center,\n    result.center\n  );\n  result.radius = sphere.radius;\n\n  return result;\n};\n\nvar scratchCartesian3 = new Cartesian3();\n/**\n * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction\n * plus/minus the radius of the bounding sphere.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding sphere.\n *\n * @param {BoundingSphere} sphere The bounding sphere to calculate the distance to.\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding sphere from position in direction.\n */\nBoundingSphere.computePlaneDistances = function (\n  sphere,\n  position,\n  direction,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"position\", position);\n  Check.typeOf.object(\"direction\", direction);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Interval();\n  }\n\n  var toCenter = Cartesian3.subtract(\n    sphere.center,\n    position,\n    scratchCartesian3\n  );\n  var mag = Cartesian3.dot(direction, toCenter);\n\n  result.start = mag - sphere.radius;\n  result.stop = mag + sphere.radius;\n  return result;\n};\n\nvar projectTo2DNormalScratch = new Cartesian3();\nvar projectTo2DEastScratch = new Cartesian3();\nvar projectTo2DNorthScratch = new Cartesian3();\nvar projectTo2DWestScratch = new Cartesian3();\nvar projectTo2DSouthScratch = new Cartesian3();\nvar projectTo2DCartographicScratch = new Cartographic();\nvar projectTo2DPositionsScratch = new Array(8);\nfor (var n = 0; n < 8; ++n) {\n  projectTo2DPositionsScratch[n] = new Cartesian3();\n}\n\nvar projectTo2DProjection = new GeographicProjection();\n/**\n * Creates a bounding sphere in 2D from a bounding sphere in 3D world coordinates.\n *\n * @param {BoundingSphere} sphere The bounding sphere to transform to 2D.\n * @param {Object} [projection=GeographicProjection] The projection to 2D.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.projectTo2D = function (sphere, projection, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  //>>includeEnd('debug');\n\n  projection = defaultValue(projection, projectTo2DProjection);\n\n  var ellipsoid = projection.ellipsoid;\n  var center = sphere.center;\n  var radius = sphere.radius;\n\n  var normal;\n  if (Cartesian3.equals(center, Cartesian3.ZERO)) {\n    // Bounding sphere is at the center. The geodetic surface normal is not\n    // defined here so pick the x-axis as a fallback.\n    normal = Cartesian3.clone(Cartesian3.UNIT_X, projectTo2DNormalScratch);\n  } else {\n    normal = ellipsoid.geodeticSurfaceNormal(center, projectTo2DNormalScratch);\n  }\n  var east = Cartesian3.cross(\n    Cartesian3.UNIT_Z,\n    normal,\n    projectTo2DEastScratch\n  );\n  Cartesian3.normalize(east, east);\n  var north = Cartesian3.cross(normal, east, projectTo2DNorthScratch);\n  Cartesian3.normalize(north, north);\n\n  Cartesian3.multiplyByScalar(normal, radius, normal);\n  Cartesian3.multiplyByScalar(north, radius, north);\n  Cartesian3.multiplyByScalar(east, radius, east);\n\n  var south = Cartesian3.negate(north, projectTo2DSouthScratch);\n  var west = Cartesian3.negate(east, projectTo2DWestScratch);\n\n  var positions = projectTo2DPositionsScratch;\n\n  // top NE corner\n  var corner = positions[0];\n  Cartesian3.add(normal, north, corner);\n  Cartesian3.add(corner, east, corner);\n\n  // top NW corner\n  corner = positions[1];\n  Cartesian3.add(normal, north, corner);\n  Cartesian3.add(corner, west, corner);\n\n  // top SW corner\n  corner = positions[2];\n  Cartesian3.add(normal, south, corner);\n  Cartesian3.add(corner, west, corner);\n\n  // top SE corner\n  corner = positions[3];\n  Cartesian3.add(normal, south, corner);\n  Cartesian3.add(corner, east, corner);\n\n  Cartesian3.negate(normal, normal);\n\n  // bottom NE corner\n  corner = positions[4];\n  Cartesian3.add(normal, north, corner);\n  Cartesian3.add(corner, east, corner);\n\n  // bottom NW corner\n  corner = positions[5];\n  Cartesian3.add(normal, north, corner);\n  Cartesian3.add(corner, west, corner);\n\n  // bottom SW corner\n  corner = positions[6];\n  Cartesian3.add(normal, south, corner);\n  Cartesian3.add(corner, west, corner);\n\n  // bottom SE corner\n  corner = positions[7];\n  Cartesian3.add(normal, south, corner);\n  Cartesian3.add(corner, east, corner);\n\n  var length = positions.length;\n  for (var i = 0; i < length; ++i) {\n    var position = positions[i];\n    Cartesian3.add(center, position, position);\n    var cartographic = ellipsoid.cartesianToCartographic(\n      position,\n      projectTo2DCartographicScratch\n    );\n    projection.project(cartographic, position);\n  }\n\n  result = BoundingSphere.fromPoints(positions, result);\n\n  // swizzle center components\n  center = result.center;\n  var x = center.x;\n  var y = center.y;\n  var z = center.z;\n  center.x = z;\n  center.y = x;\n  center.z = y;\n\n  return result;\n};\n\n/**\n * Determines whether or not a sphere is hidden from view by the occluder.\n *\n * @param {BoundingSphere} sphere The bounding sphere surrounding the occludee object.\n * @param {Occluder} occluder The occluder.\n * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n */\nBoundingSphere.isOccluded = function (sphere, occluder) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"occluder\", occluder);\n  //>>includeEnd('debug');\n  return !occluder.isBoundingSphereVisible(sphere);\n};\n\n/**\n * Compares the provided BoundingSphere componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {BoundingSphere} [left] The first BoundingSphere.\n * @param {BoundingSphere} [right] The second BoundingSphere.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nBoundingSphere.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Cartesian3.equals(left.center, right.center) &&\n      left.radius === right.radius)\n  );\n};\n\n/**\n * Determines which side of a plane the sphere is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere\n *                      intersects the plane.\n */\nBoundingSphere.prototype.intersectPlane = function (plane) {\n  return BoundingSphere.intersectPlane(this, plane);\n};\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding sphere to a point.\n *\n * @param {Cartesian3} cartesian The point\n * @returns {Number} The estimated distance squared from the bounding sphere to the point.\n *\n * @example\n * // Sort bounding spheres from back to front\n * spheres.sort(function(a, b) {\n *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\n * });\n */\nBoundingSphere.prototype.distanceSquaredTo = function (cartesian) {\n  return BoundingSphere.distanceSquaredTo(this, cartesian);\n};\n\n/**\n * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction\n * plus/minus the radius of the bounding sphere.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding sphere.\n *\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding sphere from position in direction.\n */\nBoundingSphere.prototype.computePlaneDistances = function (\n  position,\n  direction,\n  result\n) {\n  return BoundingSphere.computePlaneDistances(\n    this,\n    position,\n    direction,\n    result\n  );\n};\n\n/**\n * Determines whether or not a sphere is hidden from view by the occluder.\n *\n * @param {Occluder} occluder The occluder.\n * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n */\nBoundingSphere.prototype.isOccluded = function (occluder) {\n  return BoundingSphere.isOccluded(this, occluder);\n};\n\n/**\n * Compares this BoundingSphere against the provided BoundingSphere componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {BoundingSphere} [right] The right hand side BoundingSphere.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nBoundingSphere.prototype.equals = function (right) {\n  return BoundingSphere.equals(this, right);\n};\n\n/**\n * Duplicates this BoundingSphere instance.\n *\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.prototype.clone = function (result) {\n  return BoundingSphere.clone(this, result);\n};\n\n/**\n * Computes the radius of the BoundingSphere.\n * @returns {Number} The radius of the BoundingSphere.\n */\nBoundingSphere.prototype.volume = function () {\n  var radius = this.radius;\n  return volumeConstant * radius * radius * radius;\n};\nexport default BoundingSphere;\n"]},"metadata":{},"sourceType":"module"}