{"ast":null,"code":"import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport BoxOutlineGeometry from \"../Core/BoxOutlineGeometry.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport combine from \"../Core/combine.js\";\nimport CullingVolume from \"../Core/CullingVolume.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport SphereOutlineGeometry from \"../Core/SphereOutlineGeometry.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport CubeMap from \"../Renderer/CubeMap.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Framebuffer from \"../Renderer/Framebuffer.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport PassState from \"../Renderer/PassState.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Renderbuffer from \"../Renderer/Renderbuffer.js\";\nimport RenderbufferFormat from \"../Renderer/RenderbufferFormat.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport Camera from \"./Camera.js\";\nimport CullFace from \"./CullFace.js\";\nimport DebugCameraPrimitive from \"./DebugCameraPrimitive.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport ShadowMapShader from \"./ShadowMapShader.js\";\n/**\n * Use {@link Viewer#shadowMap} to get the scene's shadow map. Do not construct this directly.\n *\n * <p>\n * The normalOffset bias pushes the shadows forward slightly, and may be disabled\n * for applications that require ultra precise shadows.\n * </p>\n *\n * @alias ShadowMap\n * @internalConstructor\n * @class\n *\n * @param {Object} options An object containing the following properties:\n * @param {Camera} options.lightCamera A camera representing the light source.\n * @param {Boolean} [options.enabled=true] Whether the shadow map is enabled.\n * @param {Boolean} [options.isPointLight=false] Whether the light source is a point light. Point light shadows do not use cascades.\n * @param {Boolean} [options.pointLightRadius=100.0] Radius of the point light.\n * @param {Boolean} [options.cascadesEnabled=true] Use multiple shadow maps to cover different partitions of the view frustum.\n * @param {Number} [options.numberOfCascades=4] The number of cascades to use for the shadow map. Supported values are one and four.\n * @param {Number} [options.maximumDistance=5000.0] The maximum distance used for generating cascaded shadows. Lower values improve shadow quality.\n * @param {Number} [options.size=2048] The width and height, in pixels, of each shadow map.\n * @param {Boolean} [options.softShadows=false] Whether percentage-closer-filtering is enabled for producing softer shadows.\n * @param {Number} [options.darkness=0.3] The shadow darkness.\n * @param {Boolean} [options.normalOffset=true] Whether a normal bias is applied to shadows.\n *\n * @exception {DeveloperError} Only one or four cascades are supported.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Shadows.html|Cesium Sandcastle Shadows Demo}\n */\n\nfunction ShadowMap(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); // options.context is an undocumented option\n\n  var context = options.context; //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(context)) {\n    throw new DeveloperError(\"context is required.\");\n  }\n\n  if (!defined(options.lightCamera)) {\n    throw new DeveloperError(\"lightCamera is required.\");\n  }\n\n  if (defined(options.numberOfCascades) && options.numberOfCascades !== 1 && options.numberOfCascades !== 4) {\n    throw new DeveloperError(\"Only one or four cascades are supported.\");\n  } //>>includeEnd('debug');\n\n\n  this._enabled = defaultValue(options.enabled, true);\n  this._softShadows = defaultValue(options.softShadows, false);\n  this._normalOffset = defaultValue(options.normalOffset, true);\n  this.dirty = true;\n  /**\n   * Specifies whether the shadow map originates from a light source. Shadow maps that are used for analytical\n   * purposes should set this to false so as not to affect scene rendering.\n   *\n   * @private\n   */\n\n  this.fromLightSource = defaultValue(options.fromLightSource, true);\n  /**\n   * Determines the darkness of the shadows.\n   *\n   * @type {Number}\n   * @default 0.3\n   */\n\n  this.darkness = defaultValue(options.darkness, 0.3);\n  this._darkness = this.darkness;\n  /**\n   * Determines the maximum distance of the shadow map. Only applicable for cascaded shadows. Larger distances may result in lower quality shadows.\n   *\n   * @type {Number}\n   * @default 5000.0\n   */\n\n  this.maximumDistance = defaultValue(options.maximumDistance, 5000.0);\n  this._outOfView = false;\n  this._outOfViewPrevious = false;\n  this._needsUpdate = true; // In IE11 and Edge polygon offset is not functional.\n  // TODO : Also disabled for instances of Firefox and Chrome running ANGLE that do not support depth textures.\n  // Re-enable once https://github.com/CesiumGS/cesium/issues/4560 is resolved.\n\n  var polygonOffsetSupported = true;\n\n  if (FeatureDetection.isInternetExplorer() || FeatureDetection.isEdge() || (FeatureDetection.isChrome() || FeatureDetection.isFirefox()) && FeatureDetection.isWindows() && !context.depthTexture) {\n    polygonOffsetSupported = false;\n  }\n\n  this._polygonOffsetSupported = polygonOffsetSupported;\n  this._terrainBias = {\n    polygonOffset: polygonOffsetSupported,\n    polygonOffsetFactor: 1.1,\n    polygonOffsetUnits: 4.0,\n    normalOffset: this._normalOffset,\n    normalOffsetScale: 0.5,\n    normalShading: true,\n    normalShadingSmooth: 0.3,\n    depthBias: 0.0001\n  };\n  this._primitiveBias = {\n    polygonOffset: polygonOffsetSupported,\n    polygonOffsetFactor: 1.1,\n    polygonOffsetUnits: 4.0,\n    normalOffset: this._normalOffset,\n    normalOffsetScale: 0.1,\n    normalShading: true,\n    normalShadingSmooth: 0.05,\n    depthBias: 0.00002\n  };\n  this._pointBias = {\n    polygonOffset: false,\n    polygonOffsetFactor: 1.1,\n    polygonOffsetUnits: 4.0,\n    normalOffset: this._normalOffset,\n    normalOffsetScale: 0.0,\n    normalShading: true,\n    normalShadingSmooth: 0.1,\n    depthBias: 0.0005\n  }; // Framebuffer resources\n\n  this._depthAttachment = undefined;\n  this._colorAttachment = undefined; // Uniforms\n\n  this._shadowMapMatrix = new Matrix4();\n  this._shadowMapTexture = undefined;\n  this._lightDirectionEC = new Cartesian3();\n  this._lightPositionEC = new Cartesian4();\n  this._distance = 0.0;\n  this._lightCamera = options.lightCamera;\n  this._shadowMapCamera = new ShadowMapCamera();\n  this._shadowMapCullingVolume = undefined;\n  this._sceneCamera = undefined;\n  this._boundingSphere = new BoundingSphere();\n  this._isPointLight = defaultValue(options.isPointLight, false);\n  this._pointLightRadius = defaultValue(options.pointLightRadius, 100.0);\n  this._cascadesEnabled = this._isPointLight ? false : defaultValue(options.cascadesEnabled, true);\n  this._numberOfCascades = !this._cascadesEnabled ? 0 : defaultValue(options.numberOfCascades, 4);\n  this._fitNearFar = true;\n  this._maximumCascadeDistances = [25.0, 150.0, 700.0, Number.MAX_VALUE];\n  this._textureSize = new Cartesian2();\n  this._isSpotLight = false;\n\n  if (this._cascadesEnabled) {\n    // Cascaded shadows are always orthographic. The frustum dimensions are calculated on the fly.\n    this._shadowMapCamera.frustum = new OrthographicOffCenterFrustum();\n  } else if (defined(this._lightCamera.frustum.fov)) {\n    // If the light camera uses a perspective frustum, then the light source is a spot light\n    this._isSpotLight = true;\n  } // Uniforms\n\n\n  this._cascadeSplits = [new Cartesian4(), new Cartesian4()];\n  this._cascadeMatrices = [new Matrix4(), new Matrix4(), new Matrix4(), new Matrix4()];\n  this._cascadeDistances = new Cartesian4();\n  var numberOfPasses;\n\n  if (this._isPointLight) {\n    numberOfPasses = 6; // One shadow map for each direction\n  } else if (!this._cascadesEnabled) {\n    numberOfPasses = 1;\n  } else {\n    numberOfPasses = this._numberOfCascades;\n  }\n\n  this._passes = new Array(numberOfPasses);\n\n  for (var i = 0; i < numberOfPasses; ++i) {\n    this._passes[i] = new ShadowPass(context);\n  }\n\n  this.debugShow = false;\n  this.debugFreezeFrame = false;\n  this._debugFreezeFrame = false;\n  this._debugCascadeColors = false;\n  this._debugLightFrustum = undefined;\n  this._debugCameraFrustum = undefined;\n  this._debugCascadeFrustums = new Array(this._numberOfCascades);\n  this._debugShadowViewCommand = undefined;\n  this._usesDepthTexture = context.depthTexture;\n\n  if (this._isPointLight) {\n    this._usesDepthTexture = false;\n  } // Create render states for shadow casters\n\n\n  this._primitiveRenderState = undefined;\n  this._terrainRenderState = undefined;\n  this._pointRenderState = undefined;\n  createRenderStates(this); // For clearing the shadow map texture every frame\n\n  this._clearCommand = new ClearCommand({\n    depth: 1.0,\n    color: new Color()\n  });\n  this._clearPassState = new PassState(context);\n  this._size = defaultValue(options.size, 2048);\n  this.size = this._size;\n}\n/**\n * Global maximum shadow distance used to prevent far off receivers from extending\n * the shadow far plane. This helps set a tighter near/far when viewing objects from space.\n *\n * @private\n */\n\n\nShadowMap.MAXIMUM_DISTANCE = 20000.0;\n\nfunction ShadowPass(context) {\n  this.camera = new ShadowMapCamera();\n  this.passState = new PassState(context);\n  this.framebuffer = undefined;\n  this.textureOffsets = undefined;\n  this.commandList = [];\n  this.cullingVolume = undefined;\n}\n\nfunction createRenderState(colorMask, bias) {\n  return RenderState.fromCache({\n    cull: {\n      enabled: true,\n      face: CullFace.BACK\n    },\n    depthTest: {\n      enabled: true\n    },\n    colorMask: {\n      red: colorMask,\n      green: colorMask,\n      blue: colorMask,\n      alpha: colorMask\n    },\n    depthMask: true,\n    polygonOffset: {\n      enabled: bias.polygonOffset,\n      factor: bias.polygonOffsetFactor,\n      units: bias.polygonOffsetUnits\n    }\n  });\n}\n\nfunction createRenderStates(shadowMap) {\n  // Enable the color mask if the shadow map is backed by a color texture, e.g. when depth textures aren't supported\n  var colorMask = !shadowMap._usesDepthTexture;\n  shadowMap._primitiveRenderState = createRenderState(colorMask, shadowMap._primitiveBias);\n  shadowMap._terrainRenderState = createRenderState(colorMask, shadowMap._terrainBias);\n  shadowMap._pointRenderState = createRenderState(colorMask, shadowMap._pointBias);\n}\n/**\n * @private\n */\n\n\nShadowMap.prototype.debugCreateRenderStates = function () {\n  createRenderStates(this);\n};\n\nObject.defineProperties(ShadowMap.prototype, {\n  /**\n   * Determines if the shadow map will be shown.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {Boolean}\n   * @default true\n   */\n  enabled: {\n    get: function get() {\n      return this._enabled;\n    },\n    set: function set(value) {\n      this.dirty = this._enabled !== value;\n      this._enabled = value;\n    }\n  },\n\n  /**\n   * Determines if a normal bias will be applied to shadows.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {Boolean}\n   * @default true\n   */\n  normalOffset: {\n    get: function get() {\n      return this._normalOffset;\n    },\n    set: function set(value) {\n      this.dirty = this._normalOffset !== value;\n      this._normalOffset = value;\n      this._terrainBias.normalOffset = value;\n      this._primitiveBias.normalOffset = value;\n      this._pointBias.normalOffset = value;\n    }\n  },\n\n  /**\n   * Determines if soft shadows are enabled. Uses pcf filtering which requires more texture reads and may hurt performance.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {Boolean}\n   * @default false\n   */\n  softShadows: {\n    get: function get() {\n      return this._softShadows;\n    },\n    set: function set(value) {\n      this.dirty = this._softShadows !== value;\n      this._softShadows = value;\n    }\n  },\n\n  /**\n   * The width and height, in pixels, of each shadow map.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {Number}\n   * @default 2048\n   */\n  size: {\n    get: function get() {\n      return this._size;\n    },\n    set: function set(value) {\n      resize(this, value);\n    }\n  },\n\n  /**\n   * Whether the shadow map is out of view of the scene camera.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {Boolean}\n   * @readonly\n   * @private\n   */\n  outOfView: {\n    get: function get() {\n      return this._outOfView;\n    }\n  },\n\n  /**\n   * The culling volume of the shadow frustum.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {CullingVolume}\n   * @readonly\n   * @private\n   */\n  shadowMapCullingVolume: {\n    get: function get() {\n      return this._shadowMapCullingVolume;\n    }\n  },\n\n  /**\n   * The passes used for rendering shadows. Each face of a point light or each cascade for a cascaded shadow map is a separate pass.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {ShadowPass[]}\n   * @readonly\n   * @private\n   */\n  passes: {\n    get: function get() {\n      return this._passes;\n    }\n  },\n\n  /**\n   * Whether the light source is a point light.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {Boolean}\n   * @readonly\n   * @private\n   */\n  isPointLight: {\n    get: function get() {\n      return this._isPointLight;\n    }\n  },\n\n  /**\n   * Debug option for visualizing the cascades by color.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {Boolean}\n   * @default false\n   * @private\n   */\n  debugCascadeColors: {\n    get: function get() {\n      return this._debugCascadeColors;\n    },\n    set: function set(value) {\n      this.dirty = this._debugCascadeColors !== value;\n      this._debugCascadeColors = value;\n    }\n  }\n});\n\nfunction destroyFramebuffer(shadowMap) {\n  var length = shadowMap._passes.length;\n\n  for (var i = 0; i < length; ++i) {\n    var pass = shadowMap._passes[i];\n    var framebuffer = pass.framebuffer;\n\n    if (defined(framebuffer) && !framebuffer.isDestroyed()) {\n      framebuffer.destroy();\n    }\n\n    pass.framebuffer = undefined;\n  } // Destroy the framebuffer attachments\n\n\n  shadowMap._depthAttachment = shadowMap._depthAttachment && shadowMap._depthAttachment.destroy();\n  shadowMap._colorAttachment = shadowMap._colorAttachment && shadowMap._colorAttachment.destroy();\n}\n\nfunction createFramebufferColor(shadowMap, context) {\n  var depthRenderbuffer = new Renderbuffer({\n    context: context,\n    width: shadowMap._textureSize.x,\n    height: shadowMap._textureSize.y,\n    format: RenderbufferFormat.DEPTH_COMPONENT16\n  });\n  var colorTexture = new Texture({\n    context: context,\n    width: shadowMap._textureSize.x,\n    height: shadowMap._textureSize.y,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n    sampler: Sampler.NEAREST\n  });\n  var framebuffer = new Framebuffer({\n    context: context,\n    depthRenderbuffer: depthRenderbuffer,\n    colorTextures: [colorTexture],\n    destroyAttachments: false\n  });\n  var length = shadowMap._passes.length;\n\n  for (var i = 0; i < length; ++i) {\n    var pass = shadowMap._passes[i];\n    pass.framebuffer = framebuffer;\n    pass.passState.framebuffer = framebuffer;\n  }\n\n  shadowMap._shadowMapTexture = colorTexture;\n  shadowMap._depthAttachment = depthRenderbuffer;\n  shadowMap._colorAttachment = colorTexture;\n}\n\nfunction createFramebufferDepth(shadowMap, context) {\n  var depthStencilTexture = new Texture({\n    context: context,\n    width: shadowMap._textureSize.x,\n    height: shadowMap._textureSize.y,\n    pixelFormat: PixelFormat.DEPTH_STENCIL,\n    pixelDatatype: PixelDatatype.UNSIGNED_INT_24_8,\n    sampler: Sampler.NEAREST\n  });\n  var framebuffer = new Framebuffer({\n    context: context,\n    depthStencilTexture: depthStencilTexture,\n    destroyAttachments: false\n  });\n  var length = shadowMap._passes.length;\n\n  for (var i = 0; i < length; ++i) {\n    var pass = shadowMap._passes[i];\n    pass.framebuffer = framebuffer;\n    pass.passState.framebuffer = framebuffer;\n  }\n\n  shadowMap._shadowMapTexture = depthStencilTexture;\n  shadowMap._depthAttachment = depthStencilTexture;\n}\n\nfunction createFramebufferCube(shadowMap, context) {\n  var depthRenderbuffer = new Renderbuffer({\n    context: context,\n    width: shadowMap._textureSize.x,\n    height: shadowMap._textureSize.y,\n    format: RenderbufferFormat.DEPTH_COMPONENT16\n  });\n  var cubeMap = new CubeMap({\n    context: context,\n    width: shadowMap._textureSize.x,\n    height: shadowMap._textureSize.y,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n    sampler: Sampler.NEAREST\n  });\n  var faces = [cubeMap.negativeX, cubeMap.negativeY, cubeMap.negativeZ, cubeMap.positiveX, cubeMap.positiveY, cubeMap.positiveZ];\n\n  for (var i = 0; i < 6; ++i) {\n    var framebuffer = new Framebuffer({\n      context: context,\n      depthRenderbuffer: depthRenderbuffer,\n      colorTextures: [faces[i]],\n      destroyAttachments: false\n    });\n    var pass = shadowMap._passes[i];\n    pass.framebuffer = framebuffer;\n    pass.passState.framebuffer = framebuffer;\n  }\n\n  shadowMap._shadowMapTexture = cubeMap;\n  shadowMap._depthAttachment = depthRenderbuffer;\n  shadowMap._colorAttachment = cubeMap;\n}\n\nfunction createFramebuffer(shadowMap, context) {\n  if (shadowMap._isPointLight) {\n    createFramebufferCube(shadowMap, context);\n  } else if (shadowMap._usesDepthTexture) {\n    createFramebufferDepth(shadowMap, context);\n  } else {\n    createFramebufferColor(shadowMap, context);\n  }\n}\n\nfunction checkFramebuffer(shadowMap, context) {\n  // Attempt to make an FBO with only a depth texture. If it fails, fallback to a color texture.\n  if (shadowMap._usesDepthTexture && shadowMap._passes[0].framebuffer.status !== WebGLConstants.FRAMEBUFFER_COMPLETE) {\n    shadowMap._usesDepthTexture = false;\n    createRenderStates(shadowMap);\n    destroyFramebuffer(shadowMap);\n    createFramebuffer(shadowMap, context);\n  }\n}\n\nfunction updateFramebuffer(shadowMap, context) {\n  if (!defined(shadowMap._passes[0].framebuffer) || shadowMap._shadowMapTexture.width !== shadowMap._textureSize.x) {\n    destroyFramebuffer(shadowMap);\n    createFramebuffer(shadowMap, context);\n    checkFramebuffer(shadowMap, context);\n    clearFramebuffer(shadowMap, context);\n  }\n}\n\nfunction clearFramebuffer(shadowMap, context, shadowPass) {\n  shadowPass = defaultValue(shadowPass, 0);\n\n  if (shadowMap._isPointLight || shadowPass === 0) {\n    shadowMap._clearCommand.framebuffer = shadowMap._passes[shadowPass].framebuffer;\n\n    shadowMap._clearCommand.execute(context, shadowMap._clearPassState);\n  }\n}\n\nfunction resize(shadowMap, size) {\n  shadowMap._size = size;\n  var passes = shadowMap._passes;\n  var numberOfPasses = passes.length;\n  var textureSize = shadowMap._textureSize;\n\n  if (shadowMap._isPointLight) {\n    size = ContextLimits.maximumCubeMapSize >= size ? size : ContextLimits.maximumCubeMapSize;\n    textureSize.x = size;\n    textureSize.y = size;\n    var faceViewport = new BoundingRectangle(0, 0, size, size);\n    passes[0].passState.viewport = faceViewport;\n    passes[1].passState.viewport = faceViewport;\n    passes[2].passState.viewport = faceViewport;\n    passes[3].passState.viewport = faceViewport;\n    passes[4].passState.viewport = faceViewport;\n    passes[5].passState.viewport = faceViewport;\n  } else if (numberOfPasses === 1) {\n    // +----+\n    // |  1 |\n    // +----+\n    size = ContextLimits.maximumTextureSize >= size ? size : ContextLimits.maximumTextureSize;\n    textureSize.x = size;\n    textureSize.y = size;\n    passes[0].passState.viewport = new BoundingRectangle(0, 0, size, size);\n  } else if (numberOfPasses === 4) {\n    // +----+----+\n    // |  3 |  4 |\n    // +----+----+\n    // |  1 |  2 |\n    // +----+----+\n    size = ContextLimits.maximumTextureSize >= size * 2 ? size : ContextLimits.maximumTextureSize / 2;\n    textureSize.x = size * 2;\n    textureSize.y = size * 2;\n    passes[0].passState.viewport = new BoundingRectangle(0, 0, size, size);\n    passes[1].passState.viewport = new BoundingRectangle(size, 0, size, size);\n    passes[2].passState.viewport = new BoundingRectangle(0, size, size, size);\n    passes[3].passState.viewport = new BoundingRectangle(size, size, size, size);\n  } // Update clear pass state\n\n\n  shadowMap._clearPassState.viewport = new BoundingRectangle(0, 0, textureSize.x, textureSize.y); // Transforms shadow coordinates [0, 1] into the pass's region of the texture\n\n  for (var i = 0; i < numberOfPasses; ++i) {\n    var pass = passes[i];\n    var viewport = pass.passState.viewport;\n    var biasX = viewport.x / textureSize.x;\n    var biasY = viewport.y / textureSize.y;\n    var scaleX = viewport.width / textureSize.x;\n    var scaleY = viewport.height / textureSize.y;\n    pass.textureOffsets = new Matrix4(scaleX, 0.0, 0.0, biasX, 0.0, scaleY, 0.0, biasY, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n  }\n}\n\nvar scratchViewport = new BoundingRectangle();\n\nfunction createDebugShadowViewCommand(shadowMap, context) {\n  var fs;\n\n  if (shadowMap._isPointLight) {\n    fs = \"uniform samplerCube shadowMap_textureCube; \\n\" + \"varying vec2 v_textureCoordinates; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    vec2 uv = v_textureCoordinates; \\n\" + \"    vec3 dir; \\n\" + \" \\n\" + \"    if (uv.y < 0.5) \\n\" + \"    { \\n\" + \"        if (uv.x < 0.333) \\n\" + \"        { \\n\" + \"            dir.x = -1.0; \\n\" + \"            dir.y = uv.x * 6.0 - 1.0; \\n\" + \"            dir.z = uv.y * 4.0 - 1.0; \\n\" + \"        } \\n\" + \"        else if (uv.x < 0.666) \\n\" + \"        { \\n\" + \"            dir.y = -1.0; \\n\" + \"            dir.x = uv.x * 6.0 - 3.0; \\n\" + \"            dir.z = uv.y * 4.0 - 1.0; \\n\" + \"        } \\n\" + \"        else \\n\" + \"        { \\n\" + \"            dir.z = -1.0; \\n\" + \"            dir.x = uv.x * 6.0 - 5.0; \\n\" + \"            dir.y = uv.y * 4.0 - 1.0; \\n\" + \"        } \\n\" + \"    } \\n\" + \"    else \\n\" + \"    { \\n\" + \"        if (uv.x < 0.333) \\n\" + \"        { \\n\" + \"            dir.x = 1.0; \\n\" + \"            dir.y = uv.x * 6.0 - 1.0; \\n\" + \"            dir.z = uv.y * 4.0 - 3.0; \\n\" + \"        } \\n\" + \"        else if (uv.x < 0.666) \\n\" + \"        { \\n\" + \"            dir.y = 1.0; \\n\" + \"            dir.x = uv.x * 6.0 - 3.0; \\n\" + \"            dir.z = uv.y * 4.0 - 3.0; \\n\" + \"        } \\n\" + \"        else \\n\" + \"        { \\n\" + \"            dir.z = 1.0; \\n\" + \"            dir.x = uv.x * 6.0 - 5.0; \\n\" + \"            dir.y = uv.y * 4.0 - 3.0; \\n\" + \"        } \\n\" + \"    } \\n\" + \" \\n\" + \"    float shadow = czm_unpackDepth(textureCube(shadowMap_textureCube, dir)); \\n\" + \"    gl_FragColor = vec4(vec3(shadow), 1.0); \\n\" + \"} \\n\";\n  } else {\n    fs = \"uniform sampler2D shadowMap_texture; \\n\" + \"varying vec2 v_textureCoordinates; \\n\" + \"void main() \\n\" + \"{ \\n\" + (shadowMap._usesDepthTexture ? \"    float shadow = texture2D(shadowMap_texture, v_textureCoordinates).r; \\n\" : \"    float shadow = czm_unpackDepth(texture2D(shadowMap_texture, v_textureCoordinates)); \\n\") + \"    gl_FragColor = vec4(vec3(shadow), 1.0); \\n\" + \"} \\n\";\n  }\n\n  var drawCommand = context.createViewportQuadCommand(fs, {\n    uniformMap: {\n      shadowMap_texture: function shadowMap_texture() {\n        return shadowMap._shadowMapTexture;\n      },\n      shadowMap_textureCube: function shadowMap_textureCube() {\n        return shadowMap._shadowMapTexture;\n      }\n    }\n  });\n  drawCommand.pass = Pass.OVERLAY;\n  return drawCommand;\n}\n\nfunction updateDebugShadowViewCommand(shadowMap, frameState) {\n  // Draws the shadow map on the bottom-right corner of the screen\n  var context = frameState.context;\n  var screenWidth = frameState.context.drawingBufferWidth;\n  var screenHeight = frameState.context.drawingBufferHeight;\n  var size = Math.min(screenWidth, screenHeight) * 0.3;\n  var viewport = scratchViewport;\n  viewport.x = screenWidth - size;\n  viewport.y = 0;\n  viewport.width = size;\n  viewport.height = size;\n  var debugCommand = shadowMap._debugShadowViewCommand;\n\n  if (!defined(debugCommand)) {\n    debugCommand = createDebugShadowViewCommand(shadowMap, context);\n    shadowMap._debugShadowViewCommand = debugCommand;\n  } // Get a new RenderState for the updated viewport size\n\n\n  if (!defined(debugCommand.renderState) || !BoundingRectangle.equals(debugCommand.renderState.viewport, viewport)) {\n    debugCommand.renderState = RenderState.fromCache({\n      viewport: BoundingRectangle.clone(viewport)\n    });\n  }\n\n  frameState.commandList.push(shadowMap._debugShadowViewCommand);\n}\n\nvar frustumCornersNDC = new Array(8);\nfrustumCornersNDC[0] = new Cartesian4(-1.0, -1.0, -1.0, 1.0);\nfrustumCornersNDC[1] = new Cartesian4(1.0, -1.0, -1.0, 1.0);\nfrustumCornersNDC[2] = new Cartesian4(1.0, 1.0, -1.0, 1.0);\nfrustumCornersNDC[3] = new Cartesian4(-1.0, 1.0, -1.0, 1.0);\nfrustumCornersNDC[4] = new Cartesian4(-1.0, -1.0, 1.0, 1.0);\nfrustumCornersNDC[5] = new Cartesian4(1.0, -1.0, 1.0, 1.0);\nfrustumCornersNDC[6] = new Cartesian4(1.0, 1.0, 1.0, 1.0);\nfrustumCornersNDC[7] = new Cartesian4(-1.0, 1.0, 1.0, 1.0);\nvar scratchMatrix = new Matrix4();\nvar scratchFrustumCorners = new Array(8);\n\nfor (var i = 0; i < 8; ++i) {\n  scratchFrustumCorners[i] = new Cartesian4();\n}\n\nfunction createDebugPointLight(modelMatrix, color) {\n  var box = new GeometryInstance({\n    geometry: new BoxOutlineGeometry({\n      minimum: new Cartesian3(-0.5, -0.5, -0.5),\n      maximum: new Cartesian3(0.5, 0.5, 0.5)\n    }),\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color)\n    }\n  });\n  var sphere = new GeometryInstance({\n    geometry: new SphereOutlineGeometry({\n      radius: 0.5\n    }),\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color)\n    }\n  });\n  return new Primitive({\n    geometryInstances: [box, sphere],\n    appearance: new PerInstanceColorAppearance({\n      translucent: false,\n      flat: true\n    }),\n    asynchronous: false,\n    modelMatrix: modelMatrix\n  });\n}\n\nvar debugOutlineColors = [Color.RED, Color.GREEN, Color.BLUE, Color.MAGENTA];\nvar scratchScale = new Cartesian3();\n\nfunction applyDebugSettings(shadowMap, frameState) {\n  updateDebugShadowViewCommand(shadowMap, frameState);\n  var enterFreezeFrame = shadowMap.debugFreezeFrame && !shadowMap._debugFreezeFrame;\n  shadowMap._debugFreezeFrame = shadowMap.debugFreezeFrame; // Draw scene camera in freeze frame mode\n\n  if (shadowMap.debugFreezeFrame) {\n    if (enterFreezeFrame) {\n      // Recreate debug camera when entering freeze frame mode\n      shadowMap._debugCameraFrustum = shadowMap._debugCameraFrustum && shadowMap._debugCameraFrustum.destroy();\n      shadowMap._debugCameraFrustum = new DebugCameraPrimitive({\n        camera: shadowMap._sceneCamera,\n        color: Color.CYAN,\n        updateOnChange: false\n      });\n    }\n\n    shadowMap._debugCameraFrustum.update(frameState);\n  }\n\n  if (shadowMap._cascadesEnabled) {\n    // Draw cascades only in freeze frame mode\n    if (shadowMap.debugFreezeFrame) {\n      if (enterFreezeFrame) {\n        // Recreate debug frustum when entering freeze frame mode\n        shadowMap._debugLightFrustum = shadowMap._debugLightFrustum && shadowMap._debugLightFrustum.destroy();\n        shadowMap._debugLightFrustum = new DebugCameraPrimitive({\n          camera: shadowMap._shadowMapCamera,\n          color: Color.YELLOW,\n          updateOnChange: false\n        });\n      }\n\n      shadowMap._debugLightFrustum.update(frameState);\n\n      for (var i = 0; i < shadowMap._numberOfCascades; ++i) {\n        if (enterFreezeFrame) {\n          // Recreate debug frustum when entering freeze frame mode\n          shadowMap._debugCascadeFrustums[i] = shadowMap._debugCascadeFrustums[i] && shadowMap._debugCascadeFrustums[i].destroy();\n          shadowMap._debugCascadeFrustums[i] = new DebugCameraPrimitive({\n            camera: shadowMap._passes[i].camera,\n            color: debugOutlineColors[i],\n            updateOnChange: false\n          });\n        }\n\n        shadowMap._debugCascadeFrustums[i].update(frameState);\n      }\n    }\n  } else if (shadowMap._isPointLight) {\n    if (!defined(shadowMap._debugLightFrustum) || shadowMap._needsUpdate) {\n      var translation = shadowMap._shadowMapCamera.positionWC;\n      var rotation = Quaternion.IDENTITY;\n      var uniformScale = shadowMap._pointLightRadius * 2.0;\n      var scale = Cartesian3.fromElements(uniformScale, uniformScale, uniformScale, scratchScale);\n      var modelMatrix = Matrix4.fromTranslationQuaternionRotationScale(translation, rotation, scale, scratchMatrix);\n      shadowMap._debugLightFrustum = shadowMap._debugLightFrustum && shadowMap._debugLightFrustum.destroy();\n      shadowMap._debugLightFrustum = createDebugPointLight(modelMatrix, Color.YELLOW);\n    }\n\n    shadowMap._debugLightFrustum.update(frameState);\n  } else {\n    if (!defined(shadowMap._debugLightFrustum) || shadowMap._needsUpdate) {\n      shadowMap._debugLightFrustum = new DebugCameraPrimitive({\n        camera: shadowMap._shadowMapCamera,\n        color: Color.YELLOW,\n        updateOnChange: false\n      });\n    }\n\n    shadowMap._debugLightFrustum.update(frameState);\n  }\n}\n\nfunction ShadowMapCamera() {\n  this.viewMatrix = new Matrix4();\n  this.inverseViewMatrix = new Matrix4();\n  this.frustum = undefined;\n  this.positionCartographic = new Cartographic();\n  this.positionWC = new Cartesian3();\n  this.directionWC = Cartesian3.clone(Cartesian3.UNIT_Z);\n  this.upWC = Cartesian3.clone(Cartesian3.UNIT_Y);\n  this.rightWC = Cartesian3.clone(Cartesian3.UNIT_X);\n  this.viewProjectionMatrix = new Matrix4();\n}\n\nShadowMapCamera.prototype.clone = function (camera) {\n  Matrix4.clone(camera.viewMatrix, this.viewMatrix);\n  Matrix4.clone(camera.inverseViewMatrix, this.inverseViewMatrix);\n  this.frustum = camera.frustum.clone(this.frustum);\n  Cartographic.clone(camera.positionCartographic, this.positionCartographic);\n  Cartesian3.clone(camera.positionWC, this.positionWC);\n  Cartesian3.clone(camera.directionWC, this.directionWC);\n  Cartesian3.clone(camera.upWC, this.upWC);\n  Cartesian3.clone(camera.rightWC, this.rightWC);\n}; // Converts from NDC space to texture space\n\n\nvar scaleBiasMatrix = new Matrix4(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n\nShadowMapCamera.prototype.getViewProjection = function () {\n  var view = this.viewMatrix;\n  var projection = this.frustum.projectionMatrix;\n  Matrix4.multiply(projection, view, this.viewProjectionMatrix);\n  Matrix4.multiply(scaleBiasMatrix, this.viewProjectionMatrix, this.viewProjectionMatrix);\n  return this.viewProjectionMatrix;\n};\n\nvar scratchSplits = new Array(5);\nvar scratchFrustum = new PerspectiveFrustum();\nvar scratchCascadeDistances = new Array(4);\nvar scratchMin = new Cartesian3();\nvar scratchMax = new Cartesian3();\n\nfunction computeCascades(shadowMap, frameState) {\n  var shadowMapCamera = shadowMap._shadowMapCamera;\n  var sceneCamera = shadowMap._sceneCamera;\n  var cameraNear = sceneCamera.frustum.near;\n  var cameraFar = sceneCamera.frustum.far;\n  var numberOfCascades = shadowMap._numberOfCascades; // Split cascades. Use a mix of linear and log splits.\n\n  var i;\n  var range = cameraFar - cameraNear;\n  var ratio = cameraFar / cameraNear;\n  var lambda = 0.9;\n  var clampCascadeDistances = false; // When the camera is close to a relatively small model, provide more detail in the closer cascades.\n  // If the camera is near or inside a large model, such as the root tile of a city, then use the default values.\n  // To get the most accurate cascade splits we would need to find the min and max values from the depth texture.\n\n  if (frameState.shadowState.closestObjectSize < 200.0) {\n    clampCascadeDistances = true;\n    lambda = 0.9;\n  }\n\n  var cascadeDistances = scratchCascadeDistances;\n  var splits = scratchSplits;\n  splits[0] = cameraNear;\n  splits[numberOfCascades] = cameraFar; // Find initial splits\n\n  for (i = 0; i < numberOfCascades; ++i) {\n    var p = (i + 1) / numberOfCascades;\n    var logScale = cameraNear * Math.pow(ratio, p);\n    var uniformScale = cameraNear + range * p;\n    var split = CesiumMath.lerp(uniformScale, logScale, lambda);\n    splits[i + 1] = split;\n    cascadeDistances[i] = split - splits[i];\n  }\n\n  if (clampCascadeDistances) {\n    // Clamp each cascade to its maximum distance\n    for (i = 0; i < numberOfCascades; ++i) {\n      cascadeDistances[i] = Math.min(cascadeDistances[i], shadowMap._maximumCascadeDistances[i]);\n    } // Recompute splits\n\n\n    var distance = splits[0];\n\n    for (i = 0; i < numberOfCascades - 1; ++i) {\n      distance += cascadeDistances[i];\n      splits[i + 1] = distance;\n    }\n  }\n\n  Cartesian4.unpack(splits, 0, shadowMap._cascadeSplits[0]);\n  Cartesian4.unpack(splits, 1, shadowMap._cascadeSplits[1]);\n  Cartesian4.unpack(cascadeDistances, 0, shadowMap._cascadeDistances);\n  var shadowFrustum = shadowMapCamera.frustum;\n  var left = shadowFrustum.left;\n  var right = shadowFrustum.right;\n  var bottom = shadowFrustum.bottom;\n  var top = shadowFrustum.top;\n  var near = shadowFrustum.near;\n  var far = shadowFrustum.far;\n  var position = shadowMapCamera.positionWC;\n  var direction = shadowMapCamera.directionWC;\n  var up = shadowMapCamera.upWC;\n  var cascadeSubFrustum = sceneCamera.frustum.clone(scratchFrustum);\n  var shadowViewProjection = shadowMapCamera.getViewProjection();\n\n  for (i = 0; i < numberOfCascades; ++i) {\n    // Find the bounding box of the camera sub-frustum in shadow map texture space\n    cascadeSubFrustum.near = splits[i];\n    cascadeSubFrustum.far = splits[i + 1];\n    var viewProjection = Matrix4.multiply(cascadeSubFrustum.projectionMatrix, sceneCamera.viewMatrix, scratchMatrix);\n    var inverseViewProjection = Matrix4.inverse(viewProjection, scratchMatrix);\n    var shadowMapMatrix = Matrix4.multiply(shadowViewProjection, inverseViewProjection, scratchMatrix); // Project each corner from camera NDC space to shadow map texture space. Min and max will be from 0 to 1.\n\n    var min = Cartesian3.fromElements(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, scratchMin);\n    var max = Cartesian3.fromElements(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, scratchMax);\n\n    for (var k = 0; k < 8; ++k) {\n      var corner = Cartesian4.clone(frustumCornersNDC[k], scratchFrustumCorners[k]);\n      Matrix4.multiplyByVector(shadowMapMatrix, corner, corner);\n      Cartesian3.divideByScalar(corner, corner.w, corner); // Handle the perspective divide\n\n      Cartesian3.minimumByComponent(corner, min, min);\n      Cartesian3.maximumByComponent(corner, max, max);\n    } // Limit light-space coordinates to the [0, 1] range\n\n\n    min.x = Math.max(min.x, 0.0);\n    min.y = Math.max(min.y, 0.0);\n    min.z = 0.0; // Always start cascade frustum at the top of the light frustum to capture objects in the light's path\n\n    max.x = Math.min(max.x, 1.0);\n    max.y = Math.min(max.y, 1.0);\n    max.z = Math.min(max.z, 1.0);\n    var pass = shadowMap._passes[i];\n    var cascadeCamera = pass.camera;\n    cascadeCamera.clone(shadowMapCamera); // PERFORMANCE_IDEA : could do a shallow clone for all properties except the frustum\n\n    var frustum = cascadeCamera.frustum;\n    frustum.left = left + min.x * (right - left);\n    frustum.right = left + max.x * (right - left);\n    frustum.bottom = bottom + min.y * (top - bottom);\n    frustum.top = bottom + max.y * (top - bottom);\n    frustum.near = near + min.z * (far - near);\n    frustum.far = near + max.z * (far - near);\n    pass.cullingVolume = cascadeCamera.frustum.computeCullingVolume(position, direction, up); // Transforms from eye space to the cascade's texture space\n\n    var cascadeMatrix = shadowMap._cascadeMatrices[i];\n    Matrix4.multiply(cascadeCamera.getViewProjection(), sceneCamera.inverseViewMatrix, cascadeMatrix);\n    Matrix4.multiply(pass.textureOffsets, cascadeMatrix, cascadeMatrix);\n  }\n}\n\nvar scratchLightView = new Matrix4();\nvar scratchRight = new Cartesian3();\nvar scratchUp = new Cartesian3();\nvar scratchTranslation = new Cartesian3();\n\nfunction fitShadowMapToScene(shadowMap, frameState) {\n  var shadowMapCamera = shadowMap._shadowMapCamera;\n  var sceneCamera = shadowMap._sceneCamera; // 1. First find a tight bounding box in light space that contains the entire camera frustum.\n\n  var viewProjection = Matrix4.multiply(sceneCamera.frustum.projectionMatrix, sceneCamera.viewMatrix, scratchMatrix);\n  var inverseViewProjection = Matrix4.inverse(viewProjection, scratchMatrix); // Start to construct the light view matrix. Set translation later once the bounding box is found.\n\n  var lightDir = shadowMapCamera.directionWC;\n  var lightUp = sceneCamera.directionWC; // Align shadows to the camera view.\n\n  if (Cartesian3.equalsEpsilon(lightDir, lightUp, CesiumMath.EPSILON10)) {\n    lightUp = sceneCamera.upWC;\n  }\n\n  var lightRight = Cartesian3.cross(lightDir, lightUp, scratchRight);\n  lightUp = Cartesian3.cross(lightRight, lightDir, scratchUp); // Recalculate up now that right is derived\n\n  Cartesian3.normalize(lightUp, lightUp);\n  Cartesian3.normalize(lightRight, lightRight);\n  var lightPosition = Cartesian3.fromElements(0.0, 0.0, 0.0, scratchTranslation);\n  var lightView = Matrix4.computeView(lightPosition, lightDir, lightUp, lightRight, scratchLightView);\n  var cameraToLight = Matrix4.multiply(lightView, inverseViewProjection, scratchMatrix); // Project each corner from NDC space to light view space, and calculate a min and max in light view space\n\n  var min = Cartesian3.fromElements(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, scratchMin);\n  var max = Cartesian3.fromElements(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, scratchMax);\n\n  for (var i = 0; i < 8; ++i) {\n    var corner = Cartesian4.clone(frustumCornersNDC[i], scratchFrustumCorners[i]);\n    Matrix4.multiplyByVector(cameraToLight, corner, corner);\n    Cartesian3.divideByScalar(corner, corner.w, corner); // Handle the perspective divide\n\n    Cartesian3.minimumByComponent(corner, min, min);\n    Cartesian3.maximumByComponent(corner, max, max);\n  } // 2. Set bounding box back to include objects in the light's view\n\n\n  max.z += 1000.0; // Note: in light space, a positive number is behind the camera\n\n  min.z -= 10.0; // Extend the shadow volume forward slightly to avoid problems right at the edge\n  // 3. Adjust light view matrix so that it is centered on the bounding volume\n\n  var translation = scratchTranslation;\n  translation.x = -(0.5 * (min.x + max.x));\n  translation.y = -(0.5 * (min.y + max.y));\n  translation.z = -max.z;\n  var translationMatrix = Matrix4.fromTranslation(translation, scratchMatrix);\n  lightView = Matrix4.multiply(translationMatrix, lightView, lightView); // 4. Create an orthographic frustum that covers the bounding box extents\n\n  var halfWidth = 0.5 * (max.x - min.x);\n  var halfHeight = 0.5 * (max.y - min.y);\n  var depth = max.z - min.z;\n  var frustum = shadowMapCamera.frustum;\n  frustum.left = -halfWidth;\n  frustum.right = halfWidth;\n  frustum.bottom = -halfHeight;\n  frustum.top = halfHeight;\n  frustum.near = 0.01;\n  frustum.far = depth; // 5. Update the shadow map camera\n\n  Matrix4.clone(lightView, shadowMapCamera.viewMatrix);\n  Matrix4.inverse(lightView, shadowMapCamera.inverseViewMatrix);\n  Matrix4.getTranslation(shadowMapCamera.inverseViewMatrix, shadowMapCamera.positionWC);\n  frameState.mapProjection.ellipsoid.cartesianToCartographic(shadowMapCamera.positionWC, shadowMapCamera.positionCartographic);\n  Cartesian3.clone(lightDir, shadowMapCamera.directionWC);\n  Cartesian3.clone(lightUp, shadowMapCamera.upWC);\n  Cartesian3.clone(lightRight, shadowMapCamera.rightWC);\n}\n\nvar directions = [new Cartesian3(-1.0, 0.0, 0.0), new Cartesian3(0.0, -1.0, 0.0), new Cartesian3(0.0, 0.0, -1.0), new Cartesian3(1.0, 0.0, 0.0), new Cartesian3(0.0, 1.0, 0.0), new Cartesian3(0.0, 0.0, 1.0)];\nvar ups = [new Cartesian3(0.0, -1.0, 0.0), new Cartesian3(0.0, 0.0, -1.0), new Cartesian3(0.0, -1.0, 0.0), new Cartesian3(0.0, -1.0, 0.0), new Cartesian3(0.0, 0.0, 1.0), new Cartesian3(0.0, -1.0, 0.0)];\nvar rights = [new Cartesian3(0.0, 0.0, 1.0), new Cartesian3(1.0, 0.0, 0.0), new Cartesian3(-1.0, 0.0, 0.0), new Cartesian3(0.0, 0.0, -1.0), new Cartesian3(1.0, 0.0, 0.0), new Cartesian3(1.0, 0.0, 0.0)];\n\nfunction computeOmnidirectional(shadowMap, frameState) {\n  // All sides share the same frustum\n  var frustum = new PerspectiveFrustum();\n  frustum.fov = CesiumMath.PI_OVER_TWO;\n  frustum.near = 1.0;\n  frustum.far = shadowMap._pointLightRadius;\n  frustum.aspectRatio = 1.0;\n\n  for (var i = 0; i < 6; ++i) {\n    var camera = shadowMap._passes[i].camera;\n    camera.positionWC = shadowMap._shadowMapCamera.positionWC;\n    camera.positionCartographic = frameState.mapProjection.ellipsoid.cartesianToCartographic(camera.positionWC, camera.positionCartographic);\n    camera.directionWC = directions[i];\n    camera.upWC = ups[i];\n    camera.rightWC = rights[i];\n    Matrix4.computeView(camera.positionWC, camera.directionWC, camera.upWC, camera.rightWC, camera.viewMatrix);\n    Matrix4.inverse(camera.viewMatrix, camera.inverseViewMatrix);\n    camera.frustum = frustum;\n  }\n}\n\nvar scratchCartesian1 = new Cartesian3();\nvar scratchCartesian2 = new Cartesian3();\nvar scratchBoundingSphere = new BoundingSphere();\nvar scratchCenter = scratchBoundingSphere.center;\n\nfunction checkVisibility(shadowMap, frameState) {\n  var sceneCamera = shadowMap._sceneCamera;\n  var shadowMapCamera = shadowMap._shadowMapCamera;\n  var boundingSphere = scratchBoundingSphere; // Check whether the shadow map is in view and needs to be updated\n\n  if (shadowMap._cascadesEnabled) {\n    // If the nearest shadow receiver is further than the shadow map's maximum distance then the shadow map is out of view.\n    if (sceneCamera.frustum.near >= shadowMap.maximumDistance) {\n      shadowMap._outOfView = true;\n      shadowMap._needsUpdate = false;\n      return;\n    } // If the light source is below the horizon then the shadow map is out of view\n\n\n    var surfaceNormal = frameState.mapProjection.ellipsoid.geodeticSurfaceNormal(sceneCamera.positionWC, scratchCartesian1);\n    var lightDirection = Cartesian3.negate(shadowMapCamera.directionWC, scratchCartesian2);\n    var dot = Cartesian3.dot(surfaceNormal, lightDirection); // Shadows start to fade out once the light gets closer to the horizon.\n    // At this point the globe uses vertex lighting alone to darken the surface.\n\n    var darknessAmount = CesiumMath.clamp(dot / 0.1, 0.0, 1.0);\n    shadowMap._darkness = CesiumMath.lerp(1.0, shadowMap.darkness, darknessAmount);\n\n    if (dot < 0.0) {\n      shadowMap._outOfView = true;\n      shadowMap._needsUpdate = false;\n      return;\n    } // By default cascaded shadows need to update and are always in view\n\n\n    shadowMap._needsUpdate = true;\n    shadowMap._outOfView = false;\n  } else if (shadowMap._isPointLight) {\n    // Sphere-frustum intersection test\n    boundingSphere.center = shadowMapCamera.positionWC;\n    boundingSphere.radius = shadowMap._pointLightRadius;\n    shadowMap._outOfView = frameState.cullingVolume.computeVisibility(boundingSphere) === Intersect.OUTSIDE;\n    shadowMap._needsUpdate = !shadowMap._outOfView && !shadowMap._boundingSphere.equals(boundingSphere);\n    BoundingSphere.clone(boundingSphere, shadowMap._boundingSphere);\n  } else {\n    // Simplify frustum-frustum intersection test as a sphere-frustum test\n    var frustumRadius = shadowMapCamera.frustum.far / 2.0;\n    var frustumCenter = Cartesian3.add(shadowMapCamera.positionWC, Cartesian3.multiplyByScalar(shadowMapCamera.directionWC, frustumRadius, scratchCenter), scratchCenter);\n    boundingSphere.center = frustumCenter;\n    boundingSphere.radius = frustumRadius;\n    shadowMap._outOfView = frameState.cullingVolume.computeVisibility(boundingSphere) === Intersect.OUTSIDE;\n    shadowMap._needsUpdate = !shadowMap._outOfView && !shadowMap._boundingSphere.equals(boundingSphere);\n    BoundingSphere.clone(boundingSphere, shadowMap._boundingSphere);\n  }\n}\n\nfunction updateCameras(shadowMap, frameState) {\n  var camera = frameState.camera; // The actual camera in the scene\n\n  var lightCamera = shadowMap._lightCamera; // The external camera representing the light source\n\n  var sceneCamera = shadowMap._sceneCamera; // Clone of camera, with clamped near and far planes\n\n  var shadowMapCamera = shadowMap._shadowMapCamera; // Camera representing the shadow volume, initially cloned from lightCamera\n  // Clone light camera into the shadow map camera\n\n  if (shadowMap._cascadesEnabled) {\n    Cartesian3.clone(lightCamera.directionWC, shadowMapCamera.directionWC);\n  } else if (shadowMap._isPointLight) {\n    Cartesian3.clone(lightCamera.positionWC, shadowMapCamera.positionWC);\n  } else {\n    shadowMapCamera.clone(lightCamera);\n  } // Get the light direction in eye coordinates\n\n\n  var lightDirection = shadowMap._lightDirectionEC;\n  Matrix4.multiplyByPointAsVector(camera.viewMatrix, shadowMapCamera.directionWC, lightDirection);\n  Cartesian3.normalize(lightDirection, lightDirection);\n  Cartesian3.negate(lightDirection, lightDirection); // Get the light position in eye coordinates\n\n  Matrix4.multiplyByPoint(camera.viewMatrix, shadowMapCamera.positionWC, shadowMap._lightPositionEC);\n  shadowMap._lightPositionEC.w = shadowMap._pointLightRadius; // Get the near and far of the scene camera\n\n  var near;\n  var far;\n\n  if (shadowMap._fitNearFar) {\n    // shadowFar can be very large, so limit to shadowMap.maximumDistance\n    // Push the far plane slightly further than the near plane to avoid degenerate frustum\n    near = Math.min(frameState.shadowState.nearPlane, shadowMap.maximumDistance);\n    far = Math.min(frameState.shadowState.farPlane, shadowMap.maximumDistance + 1.0);\n  } else {\n    near = camera.frustum.near;\n    far = shadowMap.maximumDistance;\n  }\n\n  shadowMap._sceneCamera = Camera.clone(camera, sceneCamera);\n  camera.frustum.clone(shadowMap._sceneCamera.frustum);\n  shadowMap._sceneCamera.frustum.near = near;\n  shadowMap._sceneCamera.frustum.far = far;\n  shadowMap._distance = far - near;\n  checkVisibility(shadowMap, frameState);\n\n  if (!shadowMap._outOfViewPrevious && shadowMap._outOfView) {\n    shadowMap._needsUpdate = true;\n  }\n\n  shadowMap._outOfViewPrevious = shadowMap._outOfView;\n}\n/**\n * @private\n */\n\n\nShadowMap.prototype.update = function (frameState) {\n  updateCameras(this, frameState);\n\n  if (this._needsUpdate) {\n    updateFramebuffer(this, frameState.context);\n\n    if (this._isPointLight) {\n      computeOmnidirectional(this, frameState);\n    }\n\n    if (this._cascadesEnabled) {\n      fitShadowMapToScene(this, frameState);\n\n      if (this._numberOfCascades > 1) {\n        computeCascades(this, frameState);\n      }\n    }\n\n    if (!this._isPointLight) {\n      // Compute the culling volume\n      var shadowMapCamera = this._shadowMapCamera;\n      var position = shadowMapCamera.positionWC;\n      var direction = shadowMapCamera.directionWC;\n      var up = shadowMapCamera.upWC;\n      this._shadowMapCullingVolume = shadowMapCamera.frustum.computeCullingVolume(position, direction, up);\n\n      if (this._passes.length === 1) {\n        // Since there is only one pass, use the shadow map camera as the pass camera.\n        this._passes[0].camera.clone(shadowMapCamera);\n      }\n    } else {\n      this._shadowMapCullingVolume = CullingVolume.fromBoundingSphere(this._boundingSphere);\n    }\n  }\n\n  if (this._passes.length === 1) {\n    // Transforms from eye space to shadow texture space.\n    // Always requires an update since the scene camera constantly changes.\n    var inverseView = this._sceneCamera.inverseViewMatrix;\n    Matrix4.multiply(this._shadowMapCamera.getViewProjection(), inverseView, this._shadowMapMatrix);\n  }\n\n  if (this.debugShow) {\n    applyDebugSettings(this, frameState);\n  }\n};\n/**\n * @private\n */\n\n\nShadowMap.prototype.updatePass = function (context, shadowPass) {\n  clearFramebuffer(this, context, shadowPass);\n};\n\nvar scratchTexelStepSize = new Cartesian2();\n\nfunction combineUniforms(shadowMap, uniforms, isTerrain) {\n  var bias = shadowMap._isPointLight ? shadowMap._pointBias : isTerrain ? shadowMap._terrainBias : shadowMap._primitiveBias;\n  var mapUniforms = {\n    shadowMap_texture: function shadowMap_texture() {\n      return shadowMap._shadowMapTexture;\n    },\n    shadowMap_textureCube: function shadowMap_textureCube() {\n      return shadowMap._shadowMapTexture;\n    },\n    shadowMap_matrix: function shadowMap_matrix() {\n      return shadowMap._shadowMapMatrix;\n    },\n    shadowMap_cascadeSplits: function shadowMap_cascadeSplits() {\n      return shadowMap._cascadeSplits;\n    },\n    shadowMap_cascadeMatrices: function shadowMap_cascadeMatrices() {\n      return shadowMap._cascadeMatrices;\n    },\n    shadowMap_lightDirectionEC: function shadowMap_lightDirectionEC() {\n      return shadowMap._lightDirectionEC;\n    },\n    shadowMap_lightPositionEC: function shadowMap_lightPositionEC() {\n      return shadowMap._lightPositionEC;\n    },\n    shadowMap_cascadeDistances: function shadowMap_cascadeDistances() {\n      return shadowMap._cascadeDistances;\n    },\n    shadowMap_texelSizeDepthBiasAndNormalShadingSmooth: function shadowMap_texelSizeDepthBiasAndNormalShadingSmooth() {\n      var texelStepSize = scratchTexelStepSize;\n      texelStepSize.x = 1.0 / shadowMap._textureSize.x;\n      texelStepSize.y = 1.0 / shadowMap._textureSize.y;\n      return Cartesian4.fromElements(texelStepSize.x, texelStepSize.y, bias.depthBias, bias.normalShadingSmooth, this.combinedUniforms1);\n    },\n    shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness: function shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness() {\n      return Cartesian4.fromElements(bias.normalOffsetScale, shadowMap._distance, shadowMap.maximumDistance, shadowMap._darkness, this.combinedUniforms2);\n    },\n    combinedUniforms1: new Cartesian4(),\n    combinedUniforms2: new Cartesian4()\n  };\n  return combine(uniforms, mapUniforms, false);\n}\n\nfunction createCastDerivedCommand(shadowMap, shadowsDirty, command, context, oldShaderId, result) {\n  var castShader;\n  var castRenderState;\n  var castUniformMap;\n\n  if (defined(result)) {\n    castShader = result.shaderProgram;\n    castRenderState = result.renderState;\n    castUniformMap = result.uniformMap;\n  }\n\n  result = DrawCommand.shallowClone(command, result);\n  result.castShadows = true;\n  result.receiveShadows = false;\n\n  if (!defined(castShader) || oldShaderId !== command.shaderProgram.id || shadowsDirty) {\n    var shaderProgram = command.shaderProgram;\n    var isTerrain = command.pass === Pass.GLOBE;\n    var isOpaque = command.pass !== Pass.TRANSLUCENT;\n    var isPointLight = shadowMap._isPointLight;\n    var usesDepthTexture = shadowMap._usesDepthTexture;\n    var keyword = ShadowMapShader.getShadowCastShaderKeyword(isPointLight, isTerrain, usesDepthTexture, isOpaque);\n    castShader = context.shaderCache.getDerivedShaderProgram(shaderProgram, keyword);\n\n    if (!defined(castShader)) {\n      var vertexShaderSource = shaderProgram.vertexShaderSource;\n      var fragmentShaderSource = shaderProgram.fragmentShaderSource;\n      var castVS = ShadowMapShader.createShadowCastVertexShader(vertexShaderSource, isPointLight, isTerrain);\n      var castFS = ShadowMapShader.createShadowCastFragmentShader(fragmentShaderSource, isPointLight, usesDepthTexture, isOpaque);\n      castShader = context.shaderCache.createDerivedShaderProgram(shaderProgram, keyword, {\n        vertexShaderSource: castVS,\n        fragmentShaderSource: castFS,\n        attributeLocations: shaderProgram._attributeLocations\n      });\n    }\n\n    castRenderState = shadowMap._primitiveRenderState;\n\n    if (isPointLight) {\n      castRenderState = shadowMap._pointRenderState;\n    } else if (isTerrain) {\n      castRenderState = shadowMap._terrainRenderState;\n    } // Modify the render state for commands that do not use back-face culling, e.g. flat textured walls\n\n\n    var cullEnabled = command.renderState.cull.enabled;\n\n    if (!cullEnabled) {\n      castRenderState = clone(castRenderState, false);\n      castRenderState.cull = clone(castRenderState.cull, false);\n      castRenderState.cull.enabled = false;\n      castRenderState = RenderState.fromCache(castRenderState);\n    }\n\n    castUniformMap = combineUniforms(shadowMap, command.uniformMap, isTerrain);\n  }\n\n  result.shaderProgram = castShader;\n  result.renderState = castRenderState;\n  result.uniformMap = castUniformMap;\n  return result;\n}\n\nShadowMap.createReceiveDerivedCommand = function (lightShadowMaps, command, shadowsDirty, context, result) {\n  if (!defined(result)) {\n    result = {};\n  }\n\n  var lightShadowMapsEnabled = lightShadowMaps.length > 0;\n  var shaderProgram = command.shaderProgram;\n  var vertexShaderSource = shaderProgram.vertexShaderSource;\n  var fragmentShaderSource = shaderProgram.fragmentShaderSource;\n  var isTerrain = command.pass === Pass.GLOBE;\n  var hasTerrainNormal = false;\n\n  if (isTerrain) {\n    hasTerrainNormal = command.owner.data.renderedMesh.encoding.hasVertexNormals;\n  }\n\n  if (command.receiveShadows && lightShadowMapsEnabled) {\n    // Only generate a receiveCommand if there is a shadow map originating from a light source.\n    var receiveShader;\n    var receiveUniformMap;\n\n    if (defined(result.receiveCommand)) {\n      receiveShader = result.receiveCommand.shaderProgram;\n      receiveUniformMap = result.receiveCommand.uniformMap;\n    }\n\n    result.receiveCommand = DrawCommand.shallowClone(command, result.receiveCommand);\n    result.castShadows = false;\n    result.receiveShadows = true; // If castShadows changed, recompile the receive shadows shader. The normal shading technique simulates\n    // self-shadowing so it should be turned off if castShadows is false.\n\n    var castShadowsDirty = result.receiveShaderCastShadows !== command.castShadows;\n    var shaderDirty = result.receiveShaderProgramId !== command.shaderProgram.id;\n\n    if (!defined(receiveShader) || shaderDirty || shadowsDirty || castShadowsDirty) {\n      var keyword = ShadowMapShader.getShadowReceiveShaderKeyword(lightShadowMaps[0], command.castShadows, isTerrain, hasTerrainNormal);\n      receiveShader = context.shaderCache.getDerivedShaderProgram(shaderProgram, keyword);\n\n      if (!defined(receiveShader)) {\n        var receiveVS = ShadowMapShader.createShadowReceiveVertexShader(vertexShaderSource, isTerrain, hasTerrainNormal);\n        var receiveFS = ShadowMapShader.createShadowReceiveFragmentShader(fragmentShaderSource, lightShadowMaps[0], command.castShadows, isTerrain, hasTerrainNormal);\n        receiveShader = context.shaderCache.createDerivedShaderProgram(shaderProgram, keyword, {\n          vertexShaderSource: receiveVS,\n          fragmentShaderSource: receiveFS,\n          attributeLocations: shaderProgram._attributeLocations\n        });\n      }\n\n      receiveUniformMap = combineUniforms(lightShadowMaps[0], command.uniformMap, isTerrain);\n    }\n\n    result.receiveCommand.shaderProgram = receiveShader;\n    result.receiveCommand.uniformMap = receiveUniformMap;\n    result.receiveShaderProgramId = command.shaderProgram.id;\n    result.receiveShaderCastShadows = command.castShadows;\n  }\n\n  return result;\n};\n\nShadowMap.createCastDerivedCommand = function (shadowMaps, command, shadowsDirty, context, result) {\n  if (!defined(result)) {\n    result = {};\n  }\n\n  if (command.castShadows) {\n    var castCommands = result.castCommands;\n\n    if (!defined(castCommands)) {\n      castCommands = result.castCommands = [];\n    }\n\n    var oldShaderId = result.castShaderProgramId;\n    var shadowMapLength = shadowMaps.length;\n    castCommands.length = shadowMapLength;\n\n    for (var i = 0; i < shadowMapLength; ++i) {\n      castCommands[i] = createCastDerivedCommand(shadowMaps[i], shadowsDirty, command, context, oldShaderId, castCommands[i]);\n    }\n\n    result.castShaderProgramId = command.shaderProgram.id;\n  }\n\n  return result;\n};\n/**\n * @private\n */\n\n\nShadowMap.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * @private\n */\n\n\nShadowMap.prototype.destroy = function () {\n  destroyFramebuffer(this);\n  this._debugLightFrustum = this._debugLightFrustum && this._debugLightFrustum.destroy();\n  this._debugCameraFrustum = this._debugCameraFrustum && this._debugCameraFrustum.destroy();\n  this._debugShadowViewCommand = this._debugShadowViewCommand && this._debugShadowViewCommand.shaderProgram && this._debugShadowViewCommand.shaderProgram.destroy();\n\n  for (var i = 0; i < this._numberOfCascades; ++i) {\n    this._debugCascadeFrustums[i] = this._debugCascadeFrustums[i] && this._debugCascadeFrustums[i].destroy();\n  }\n\n  return destroyObject(this);\n};\n\nexport default ShadowMap;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/ShadowMap.js"],"names":["BoundingRectangle","BoundingSphere","BoxOutlineGeometry","Cartesian2","Cartesian3","Cartesian4","Cartographic","clone","Color","ColorGeometryInstanceAttribute","combine","CullingVolume","defaultValue","defined","destroyObject","DeveloperError","FeatureDetection","GeometryInstance","Intersect","CesiumMath","Matrix4","OrthographicOffCenterFrustum","PerspectiveFrustum","PixelFormat","Quaternion","SphereOutlineGeometry","WebGLConstants","ClearCommand","ContextLimits","CubeMap","DrawCommand","Framebuffer","Pass","PassState","PixelDatatype","Renderbuffer","RenderbufferFormat","RenderState","Sampler","Texture","Camera","CullFace","DebugCameraPrimitive","PerInstanceColorAppearance","Primitive","ShadowMapShader","ShadowMap","options","EMPTY_OBJECT","context","lightCamera","numberOfCascades","_enabled","enabled","_softShadows","softShadows","_normalOffset","normalOffset","dirty","fromLightSource","darkness","_darkness","maximumDistance","_outOfView","_outOfViewPrevious","_needsUpdate","polygonOffsetSupported","isInternetExplorer","isEdge","isChrome","isFirefox","isWindows","depthTexture","_polygonOffsetSupported","_terrainBias","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","normalOffsetScale","normalShading","normalShadingSmooth","depthBias","_primitiveBias","_pointBias","_depthAttachment","undefined","_colorAttachment","_shadowMapMatrix","_shadowMapTexture","_lightDirectionEC","_lightPositionEC","_distance","_lightCamera","_shadowMapCamera","ShadowMapCamera","_shadowMapCullingVolume","_sceneCamera","_boundingSphere","_isPointLight","isPointLight","_pointLightRadius","pointLightRadius","_cascadesEnabled","cascadesEnabled","_numberOfCascades","_fitNearFar","_maximumCascadeDistances","Number","MAX_VALUE","_textureSize","_isSpotLight","frustum","fov","_cascadeSplits","_cascadeMatrices","_cascadeDistances","numberOfPasses","_passes","Array","i","ShadowPass","debugShow","debugFreezeFrame","_debugFreezeFrame","_debugCascadeColors","_debugLightFrustum","_debugCameraFrustum","_debugCascadeFrustums","_debugShadowViewCommand","_usesDepthTexture","_primitiveRenderState","_terrainRenderState","_pointRenderState","createRenderStates","_clearCommand","depth","color","_clearPassState","_size","size","MAXIMUM_DISTANCE","camera","passState","framebuffer","textureOffsets","commandList","cullingVolume","createRenderState","colorMask","bias","fromCache","cull","face","BACK","depthTest","red","green","blue","alpha","depthMask","factor","units","shadowMap","prototype","debugCreateRenderStates","Object","defineProperties","get","set","value","resize","outOfView","shadowMapCullingVolume","passes","debugCascadeColors","destroyFramebuffer","length","pass","isDestroyed","destroy","createFramebufferColor","depthRenderbuffer","width","x","height","y","format","DEPTH_COMPONENT16","colorTexture","pixelFormat","RGBA","pixelDatatype","UNSIGNED_BYTE","sampler","NEAREST","colorTextures","destroyAttachments","createFramebufferDepth","depthStencilTexture","DEPTH_STENCIL","UNSIGNED_INT_24_8","createFramebufferCube","cubeMap","faces","negativeX","negativeY","negativeZ","positiveX","positiveY","positiveZ","createFramebuffer","checkFramebuffer","status","FRAMEBUFFER_COMPLETE","updateFramebuffer","clearFramebuffer","shadowPass","execute","textureSize","maximumCubeMapSize","faceViewport","viewport","maximumTextureSize","biasX","biasY","scaleX","scaleY","scratchViewport","createDebugShadowViewCommand","fs","drawCommand","createViewportQuadCommand","uniformMap","shadowMap_texture","shadowMap_textureCube","OVERLAY","updateDebugShadowViewCommand","frameState","screenWidth","drawingBufferWidth","screenHeight","drawingBufferHeight","Math","min","debugCommand","renderState","equals","push","frustumCornersNDC","scratchMatrix","scratchFrustumCorners","createDebugPointLight","modelMatrix","box","geometry","minimum","maximum","attributes","fromColor","sphere","radius","geometryInstances","appearance","translucent","flat","asynchronous","debugOutlineColors","RED","GREEN","BLUE","MAGENTA","scratchScale","applyDebugSettings","enterFreezeFrame","CYAN","updateOnChange","update","YELLOW","translation","positionWC","rotation","IDENTITY","uniformScale","scale","fromElements","fromTranslationQuaternionRotationScale","viewMatrix","inverseViewMatrix","positionCartographic","directionWC","UNIT_Z","upWC","UNIT_Y","rightWC","UNIT_X","viewProjectionMatrix","scaleBiasMatrix","getViewProjection","view","projection","projectionMatrix","multiply","scratchSplits","scratchFrustum","scratchCascadeDistances","scratchMin","scratchMax","computeCascades","shadowMapCamera","sceneCamera","cameraNear","near","cameraFar","far","range","ratio","lambda","clampCascadeDistances","shadowState","closestObjectSize","cascadeDistances","splits","p","logScale","pow","split","lerp","distance","unpack","shadowFrustum","left","right","bottom","top","position","direction","up","cascadeSubFrustum","shadowViewProjection","viewProjection","inverseViewProjection","inverse","shadowMapMatrix","max","k","corner","multiplyByVector","divideByScalar","w","minimumByComponent","maximumByComponent","z","cascadeCamera","computeCullingVolume","cascadeMatrix","scratchLightView","scratchRight","scratchUp","scratchTranslation","fitShadowMapToScene","lightDir","lightUp","equalsEpsilon","EPSILON10","lightRight","cross","normalize","lightPosition","lightView","computeView","cameraToLight","translationMatrix","fromTranslation","halfWidth","halfHeight","getTranslation","mapProjection","ellipsoid","cartesianToCartographic","directions","ups","rights","computeOmnidirectional","PI_OVER_TWO","aspectRatio","scratchCartesian1","scratchCartesian2","scratchBoundingSphere","scratchCenter","center","checkVisibility","boundingSphere","surfaceNormal","geodeticSurfaceNormal","lightDirection","negate","dot","darknessAmount","clamp","computeVisibility","OUTSIDE","frustumRadius","frustumCenter","add","multiplyByScalar","updateCameras","multiplyByPointAsVector","multiplyByPoint","nearPlane","farPlane","fromBoundingSphere","inverseView","updatePass","scratchTexelStepSize","combineUniforms","uniforms","isTerrain","mapUniforms","shadowMap_matrix","shadowMap_cascadeSplits","shadowMap_cascadeMatrices","shadowMap_lightDirectionEC","shadowMap_lightPositionEC","shadowMap_cascadeDistances","shadowMap_texelSizeDepthBiasAndNormalShadingSmooth","texelStepSize","combinedUniforms1","shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness","combinedUniforms2","createCastDerivedCommand","shadowsDirty","command","oldShaderId","result","castShader","castRenderState","castUniformMap","shaderProgram","shallowClone","castShadows","receiveShadows","id","GLOBE","isOpaque","TRANSLUCENT","usesDepthTexture","keyword","getShadowCastShaderKeyword","shaderCache","getDerivedShaderProgram","vertexShaderSource","fragmentShaderSource","castVS","createShadowCastVertexShader","castFS","createShadowCastFragmentShader","createDerivedShaderProgram","attributeLocations","_attributeLocations","cullEnabled","createReceiveDerivedCommand","lightShadowMaps","lightShadowMapsEnabled","hasTerrainNormal","owner","data","renderedMesh","encoding","hasVertexNormals","receiveShader","receiveUniformMap","receiveCommand","castShadowsDirty","receiveShaderCastShadows","shaderDirty","receiveShaderProgramId","getShadowReceiveShaderKeyword","receiveVS","createShadowReceiveVertexShader","receiveFS","createShadowReceiveFragmentShader","shadowMaps","castCommands","castShaderProgramId","shadowMapLength"],"mappings":"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","sourcesContent":["import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport BoxOutlineGeometry from \"../Core/BoxOutlineGeometry.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport combine from \"../Core/combine.js\";\nimport CullingVolume from \"../Core/CullingVolume.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport SphereOutlineGeometry from \"../Core/SphereOutlineGeometry.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport CubeMap from \"../Renderer/CubeMap.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Framebuffer from \"../Renderer/Framebuffer.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport PassState from \"../Renderer/PassState.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Renderbuffer from \"../Renderer/Renderbuffer.js\";\nimport RenderbufferFormat from \"../Renderer/RenderbufferFormat.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport Camera from \"./Camera.js\";\nimport CullFace from \"./CullFace.js\";\nimport DebugCameraPrimitive from \"./DebugCameraPrimitive.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport ShadowMapShader from \"./ShadowMapShader.js\";\n\n/**\n * Use {@link Viewer#shadowMap} to get the scene's shadow map. Do not construct this directly.\n *\n * <p>\n * The normalOffset bias pushes the shadows forward slightly, and may be disabled\n * for applications that require ultra precise shadows.\n * </p>\n *\n * @alias ShadowMap\n * @internalConstructor\n * @class\n *\n * @param {Object} options An object containing the following properties:\n * @param {Camera} options.lightCamera A camera representing the light source.\n * @param {Boolean} [options.enabled=true] Whether the shadow map is enabled.\n * @param {Boolean} [options.isPointLight=false] Whether the light source is a point light. Point light shadows do not use cascades.\n * @param {Boolean} [options.pointLightRadius=100.0] Radius of the point light.\n * @param {Boolean} [options.cascadesEnabled=true] Use multiple shadow maps to cover different partitions of the view frustum.\n * @param {Number} [options.numberOfCascades=4] The number of cascades to use for the shadow map. Supported values are one and four.\n * @param {Number} [options.maximumDistance=5000.0] The maximum distance used for generating cascaded shadows. Lower values improve shadow quality.\n * @param {Number} [options.size=2048] The width and height, in pixels, of each shadow map.\n * @param {Boolean} [options.softShadows=false] Whether percentage-closer-filtering is enabled for producing softer shadows.\n * @param {Number} [options.darkness=0.3] The shadow darkness.\n * @param {Boolean} [options.normalOffset=true] Whether a normal bias is applied to shadows.\n *\n * @exception {DeveloperError} Only one or four cascades are supported.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Shadows.html|Cesium Sandcastle Shadows Demo}\n */\nfunction ShadowMap(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  // options.context is an undocumented option\n  var context = options.context;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(context)) {\n    throw new DeveloperError(\"context is required.\");\n  }\n  if (!defined(options.lightCamera)) {\n    throw new DeveloperError(\"lightCamera is required.\");\n  }\n  if (\n    defined(options.numberOfCascades) &&\n    options.numberOfCascades !== 1 &&\n    options.numberOfCascades !== 4\n  ) {\n    throw new DeveloperError(\"Only one or four cascades are supported.\");\n  }\n  //>>includeEnd('debug');\n\n  this._enabled = defaultValue(options.enabled, true);\n  this._softShadows = defaultValue(options.softShadows, false);\n  this._normalOffset = defaultValue(options.normalOffset, true);\n  this.dirty = true;\n\n  /**\n   * Specifies whether the shadow map originates from a light source. Shadow maps that are used for analytical\n   * purposes should set this to false so as not to affect scene rendering.\n   *\n   * @private\n   */\n  this.fromLightSource = defaultValue(options.fromLightSource, true);\n\n  /**\n   * Determines the darkness of the shadows.\n   *\n   * @type {Number}\n   * @default 0.3\n   */\n  this.darkness = defaultValue(options.darkness, 0.3);\n  this._darkness = this.darkness;\n\n  /**\n   * Determines the maximum distance of the shadow map. Only applicable for cascaded shadows. Larger distances may result in lower quality shadows.\n   *\n   * @type {Number}\n   * @default 5000.0\n   */\n  this.maximumDistance = defaultValue(options.maximumDistance, 5000.0);\n\n  this._outOfView = false;\n  this._outOfViewPrevious = false;\n  this._needsUpdate = true;\n\n  // In IE11 and Edge polygon offset is not functional.\n  // TODO : Also disabled for instances of Firefox and Chrome running ANGLE that do not support depth textures.\n  // Re-enable once https://github.com/CesiumGS/cesium/issues/4560 is resolved.\n  var polygonOffsetSupported = true;\n  if (\n    FeatureDetection.isInternetExplorer() ||\n    FeatureDetection.isEdge() ||\n    ((FeatureDetection.isChrome() || FeatureDetection.isFirefox()) &&\n      FeatureDetection.isWindows() &&\n      !context.depthTexture)\n  ) {\n    polygonOffsetSupported = false;\n  }\n  this._polygonOffsetSupported = polygonOffsetSupported;\n\n  this._terrainBias = {\n    polygonOffset: polygonOffsetSupported,\n    polygonOffsetFactor: 1.1,\n    polygonOffsetUnits: 4.0,\n    normalOffset: this._normalOffset,\n    normalOffsetScale: 0.5,\n    normalShading: true,\n    normalShadingSmooth: 0.3,\n    depthBias: 0.0001,\n  };\n\n  this._primitiveBias = {\n    polygonOffset: polygonOffsetSupported,\n    polygonOffsetFactor: 1.1,\n    polygonOffsetUnits: 4.0,\n    normalOffset: this._normalOffset,\n    normalOffsetScale: 0.1,\n    normalShading: true,\n    normalShadingSmooth: 0.05,\n    depthBias: 0.00002,\n  };\n\n  this._pointBias = {\n    polygonOffset: false,\n    polygonOffsetFactor: 1.1,\n    polygonOffsetUnits: 4.0,\n    normalOffset: this._normalOffset,\n    normalOffsetScale: 0.0,\n    normalShading: true,\n    normalShadingSmooth: 0.1,\n    depthBias: 0.0005,\n  };\n\n  // Framebuffer resources\n  this._depthAttachment = undefined;\n  this._colorAttachment = undefined;\n\n  // Uniforms\n  this._shadowMapMatrix = new Matrix4();\n  this._shadowMapTexture = undefined;\n  this._lightDirectionEC = new Cartesian3();\n  this._lightPositionEC = new Cartesian4();\n  this._distance = 0.0;\n\n  this._lightCamera = options.lightCamera;\n  this._shadowMapCamera = new ShadowMapCamera();\n  this._shadowMapCullingVolume = undefined;\n  this._sceneCamera = undefined;\n  this._boundingSphere = new BoundingSphere();\n\n  this._isPointLight = defaultValue(options.isPointLight, false);\n  this._pointLightRadius = defaultValue(options.pointLightRadius, 100.0);\n\n  this._cascadesEnabled = this._isPointLight\n    ? false\n    : defaultValue(options.cascadesEnabled, true);\n  this._numberOfCascades = !this._cascadesEnabled\n    ? 0\n    : defaultValue(options.numberOfCascades, 4);\n  this._fitNearFar = true;\n  this._maximumCascadeDistances = [25.0, 150.0, 700.0, Number.MAX_VALUE];\n\n  this._textureSize = new Cartesian2();\n\n  this._isSpotLight = false;\n  if (this._cascadesEnabled) {\n    // Cascaded shadows are always orthographic. The frustum dimensions are calculated on the fly.\n    this._shadowMapCamera.frustum = new OrthographicOffCenterFrustum();\n  } else if (defined(this._lightCamera.frustum.fov)) {\n    // If the light camera uses a perspective frustum, then the light source is a spot light\n    this._isSpotLight = true;\n  }\n\n  // Uniforms\n  this._cascadeSplits = [new Cartesian4(), new Cartesian4()];\n  this._cascadeMatrices = [\n    new Matrix4(),\n    new Matrix4(),\n    new Matrix4(),\n    new Matrix4(),\n  ];\n  this._cascadeDistances = new Cartesian4();\n\n  var numberOfPasses;\n  if (this._isPointLight) {\n    numberOfPasses = 6; // One shadow map for each direction\n  } else if (!this._cascadesEnabled) {\n    numberOfPasses = 1;\n  } else {\n    numberOfPasses = this._numberOfCascades;\n  }\n\n  this._passes = new Array(numberOfPasses);\n  for (var i = 0; i < numberOfPasses; ++i) {\n    this._passes[i] = new ShadowPass(context);\n  }\n\n  this.debugShow = false;\n  this.debugFreezeFrame = false;\n  this._debugFreezeFrame = false;\n  this._debugCascadeColors = false;\n  this._debugLightFrustum = undefined;\n  this._debugCameraFrustum = undefined;\n  this._debugCascadeFrustums = new Array(this._numberOfCascades);\n  this._debugShadowViewCommand = undefined;\n\n  this._usesDepthTexture = context.depthTexture;\n\n  if (this._isPointLight) {\n    this._usesDepthTexture = false;\n  }\n\n  // Create render states for shadow casters\n  this._primitiveRenderState = undefined;\n  this._terrainRenderState = undefined;\n  this._pointRenderState = undefined;\n  createRenderStates(this);\n\n  // For clearing the shadow map texture every frame\n  this._clearCommand = new ClearCommand({\n    depth: 1.0,\n    color: new Color(),\n  });\n\n  this._clearPassState = new PassState(context);\n\n  this._size = defaultValue(options.size, 2048);\n  this.size = this._size;\n}\n\n/**\n * Global maximum shadow distance used to prevent far off receivers from extending\n * the shadow far plane. This helps set a tighter near/far when viewing objects from space.\n *\n * @private\n */\nShadowMap.MAXIMUM_DISTANCE = 20000.0;\n\nfunction ShadowPass(context) {\n  this.camera = new ShadowMapCamera();\n  this.passState = new PassState(context);\n  this.framebuffer = undefined;\n  this.textureOffsets = undefined;\n  this.commandList = [];\n  this.cullingVolume = undefined;\n}\n\nfunction createRenderState(colorMask, bias) {\n  return RenderState.fromCache({\n    cull: {\n      enabled: true,\n      face: CullFace.BACK,\n    },\n    depthTest: {\n      enabled: true,\n    },\n    colorMask: {\n      red: colorMask,\n      green: colorMask,\n      blue: colorMask,\n      alpha: colorMask,\n    },\n    depthMask: true,\n    polygonOffset: {\n      enabled: bias.polygonOffset,\n      factor: bias.polygonOffsetFactor,\n      units: bias.polygonOffsetUnits,\n    },\n  });\n}\n\nfunction createRenderStates(shadowMap) {\n  // Enable the color mask if the shadow map is backed by a color texture, e.g. when depth textures aren't supported\n  var colorMask = !shadowMap._usesDepthTexture;\n  shadowMap._primitiveRenderState = createRenderState(\n    colorMask,\n    shadowMap._primitiveBias\n  );\n  shadowMap._terrainRenderState = createRenderState(\n    colorMask,\n    shadowMap._terrainBias\n  );\n  shadowMap._pointRenderState = createRenderState(\n    colorMask,\n    shadowMap._pointBias\n  );\n}\n\n/**\n * @private\n */\nShadowMap.prototype.debugCreateRenderStates = function () {\n  createRenderStates(this);\n};\n\nObject.defineProperties(ShadowMap.prototype, {\n  /**\n   * Determines if the shadow map will be shown.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {Boolean}\n   * @default true\n   */\n  enabled: {\n    get: function () {\n      return this._enabled;\n    },\n    set: function (value) {\n      this.dirty = this._enabled !== value;\n      this._enabled = value;\n    },\n  },\n\n  /**\n   * Determines if a normal bias will be applied to shadows.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {Boolean}\n   * @default true\n   */\n  normalOffset: {\n    get: function () {\n      return this._normalOffset;\n    },\n    set: function (value) {\n      this.dirty = this._normalOffset !== value;\n      this._normalOffset = value;\n      this._terrainBias.normalOffset = value;\n      this._primitiveBias.normalOffset = value;\n      this._pointBias.normalOffset = value;\n    },\n  },\n\n  /**\n   * Determines if soft shadows are enabled. Uses pcf filtering which requires more texture reads and may hurt performance.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {Boolean}\n   * @default false\n   */\n  softShadows: {\n    get: function () {\n      return this._softShadows;\n    },\n    set: function (value) {\n      this.dirty = this._softShadows !== value;\n      this._softShadows = value;\n    },\n  },\n\n  /**\n   * The width and height, in pixels, of each shadow map.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {Number}\n   * @default 2048\n   */\n  size: {\n    get: function () {\n      return this._size;\n    },\n    set: function (value) {\n      resize(this, value);\n    },\n  },\n\n  /**\n   * Whether the shadow map is out of view of the scene camera.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {Boolean}\n   * @readonly\n   * @private\n   */\n  outOfView: {\n    get: function () {\n      return this._outOfView;\n    },\n  },\n\n  /**\n   * The culling volume of the shadow frustum.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {CullingVolume}\n   * @readonly\n   * @private\n   */\n  shadowMapCullingVolume: {\n    get: function () {\n      return this._shadowMapCullingVolume;\n    },\n  },\n\n  /**\n   * The passes used for rendering shadows. Each face of a point light or each cascade for a cascaded shadow map is a separate pass.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {ShadowPass[]}\n   * @readonly\n   * @private\n   */\n  passes: {\n    get: function () {\n      return this._passes;\n    },\n  },\n\n  /**\n   * Whether the light source is a point light.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {Boolean}\n   * @readonly\n   * @private\n   */\n  isPointLight: {\n    get: function () {\n      return this._isPointLight;\n    },\n  },\n\n  /**\n   * Debug option for visualizing the cascades by color.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {Boolean}\n   * @default false\n   * @private\n   */\n  debugCascadeColors: {\n    get: function () {\n      return this._debugCascadeColors;\n    },\n    set: function (value) {\n      this.dirty = this._debugCascadeColors !== value;\n      this._debugCascadeColors = value;\n    },\n  },\n});\n\nfunction destroyFramebuffer(shadowMap) {\n  var length = shadowMap._passes.length;\n  for (var i = 0; i < length; ++i) {\n    var pass = shadowMap._passes[i];\n    var framebuffer = pass.framebuffer;\n    if (defined(framebuffer) && !framebuffer.isDestroyed()) {\n      framebuffer.destroy();\n    }\n    pass.framebuffer = undefined;\n  }\n\n  // Destroy the framebuffer attachments\n  shadowMap._depthAttachment =\n    shadowMap._depthAttachment && shadowMap._depthAttachment.destroy();\n  shadowMap._colorAttachment =\n    shadowMap._colorAttachment && shadowMap._colorAttachment.destroy();\n}\n\nfunction createFramebufferColor(shadowMap, context) {\n  var depthRenderbuffer = new Renderbuffer({\n    context: context,\n    width: shadowMap._textureSize.x,\n    height: shadowMap._textureSize.y,\n    format: RenderbufferFormat.DEPTH_COMPONENT16,\n  });\n\n  var colorTexture = new Texture({\n    context: context,\n    width: shadowMap._textureSize.x,\n    height: shadowMap._textureSize.y,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n    sampler: Sampler.NEAREST,\n  });\n\n  var framebuffer = new Framebuffer({\n    context: context,\n    depthRenderbuffer: depthRenderbuffer,\n    colorTextures: [colorTexture],\n    destroyAttachments: false,\n  });\n\n  var length = shadowMap._passes.length;\n  for (var i = 0; i < length; ++i) {\n    var pass = shadowMap._passes[i];\n    pass.framebuffer = framebuffer;\n    pass.passState.framebuffer = framebuffer;\n  }\n\n  shadowMap._shadowMapTexture = colorTexture;\n  shadowMap._depthAttachment = depthRenderbuffer;\n  shadowMap._colorAttachment = colorTexture;\n}\n\nfunction createFramebufferDepth(shadowMap, context) {\n  var depthStencilTexture = new Texture({\n    context: context,\n    width: shadowMap._textureSize.x,\n    height: shadowMap._textureSize.y,\n    pixelFormat: PixelFormat.DEPTH_STENCIL,\n    pixelDatatype: PixelDatatype.UNSIGNED_INT_24_8,\n    sampler: Sampler.NEAREST,\n  });\n\n  var framebuffer = new Framebuffer({\n    context: context,\n    depthStencilTexture: depthStencilTexture,\n    destroyAttachments: false,\n  });\n\n  var length = shadowMap._passes.length;\n  for (var i = 0; i < length; ++i) {\n    var pass = shadowMap._passes[i];\n    pass.framebuffer = framebuffer;\n    pass.passState.framebuffer = framebuffer;\n  }\n\n  shadowMap._shadowMapTexture = depthStencilTexture;\n  shadowMap._depthAttachment = depthStencilTexture;\n}\n\nfunction createFramebufferCube(shadowMap, context) {\n  var depthRenderbuffer = new Renderbuffer({\n    context: context,\n    width: shadowMap._textureSize.x,\n    height: shadowMap._textureSize.y,\n    format: RenderbufferFormat.DEPTH_COMPONENT16,\n  });\n\n  var cubeMap = new CubeMap({\n    context: context,\n    width: shadowMap._textureSize.x,\n    height: shadowMap._textureSize.y,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n    sampler: Sampler.NEAREST,\n  });\n\n  var faces = [\n    cubeMap.negativeX,\n    cubeMap.negativeY,\n    cubeMap.negativeZ,\n    cubeMap.positiveX,\n    cubeMap.positiveY,\n    cubeMap.positiveZ,\n  ];\n\n  for (var i = 0; i < 6; ++i) {\n    var framebuffer = new Framebuffer({\n      context: context,\n      depthRenderbuffer: depthRenderbuffer,\n      colorTextures: [faces[i]],\n      destroyAttachments: false,\n    });\n    var pass = shadowMap._passes[i];\n    pass.framebuffer = framebuffer;\n    pass.passState.framebuffer = framebuffer;\n  }\n\n  shadowMap._shadowMapTexture = cubeMap;\n  shadowMap._depthAttachment = depthRenderbuffer;\n  shadowMap._colorAttachment = cubeMap;\n}\n\nfunction createFramebuffer(shadowMap, context) {\n  if (shadowMap._isPointLight) {\n    createFramebufferCube(shadowMap, context);\n  } else if (shadowMap._usesDepthTexture) {\n    createFramebufferDepth(shadowMap, context);\n  } else {\n    createFramebufferColor(shadowMap, context);\n  }\n}\n\nfunction checkFramebuffer(shadowMap, context) {\n  // Attempt to make an FBO with only a depth texture. If it fails, fallback to a color texture.\n  if (\n    shadowMap._usesDepthTexture &&\n    shadowMap._passes[0].framebuffer.status !==\n      WebGLConstants.FRAMEBUFFER_COMPLETE\n  ) {\n    shadowMap._usesDepthTexture = false;\n    createRenderStates(shadowMap);\n    destroyFramebuffer(shadowMap);\n    createFramebuffer(shadowMap, context);\n  }\n}\n\nfunction updateFramebuffer(shadowMap, context) {\n  if (\n    !defined(shadowMap._passes[0].framebuffer) ||\n    shadowMap._shadowMapTexture.width !== shadowMap._textureSize.x\n  ) {\n    destroyFramebuffer(shadowMap);\n    createFramebuffer(shadowMap, context);\n    checkFramebuffer(shadowMap, context);\n    clearFramebuffer(shadowMap, context);\n  }\n}\n\nfunction clearFramebuffer(shadowMap, context, shadowPass) {\n  shadowPass = defaultValue(shadowPass, 0);\n  if (shadowMap._isPointLight || shadowPass === 0) {\n    shadowMap._clearCommand.framebuffer =\n      shadowMap._passes[shadowPass].framebuffer;\n    shadowMap._clearCommand.execute(context, shadowMap._clearPassState);\n  }\n}\n\nfunction resize(shadowMap, size) {\n  shadowMap._size = size;\n  var passes = shadowMap._passes;\n  var numberOfPasses = passes.length;\n  var textureSize = shadowMap._textureSize;\n\n  if (shadowMap._isPointLight) {\n    size =\n      ContextLimits.maximumCubeMapSize >= size\n        ? size\n        : ContextLimits.maximumCubeMapSize;\n    textureSize.x = size;\n    textureSize.y = size;\n    var faceViewport = new BoundingRectangle(0, 0, size, size);\n    passes[0].passState.viewport = faceViewport;\n    passes[1].passState.viewport = faceViewport;\n    passes[2].passState.viewport = faceViewport;\n    passes[3].passState.viewport = faceViewport;\n    passes[4].passState.viewport = faceViewport;\n    passes[5].passState.viewport = faceViewport;\n  } else if (numberOfPasses === 1) {\n    // +----+\n    // |  1 |\n    // +----+\n    size =\n      ContextLimits.maximumTextureSize >= size\n        ? size\n        : ContextLimits.maximumTextureSize;\n    textureSize.x = size;\n    textureSize.y = size;\n    passes[0].passState.viewport = new BoundingRectangle(0, 0, size, size);\n  } else if (numberOfPasses === 4) {\n    // +----+----+\n    // |  3 |  4 |\n    // +----+----+\n    // |  1 |  2 |\n    // +----+----+\n    size =\n      ContextLimits.maximumTextureSize >= size * 2\n        ? size\n        : ContextLimits.maximumTextureSize / 2;\n    textureSize.x = size * 2;\n    textureSize.y = size * 2;\n    passes[0].passState.viewport = new BoundingRectangle(0, 0, size, size);\n    passes[1].passState.viewport = new BoundingRectangle(size, 0, size, size);\n    passes[2].passState.viewport = new BoundingRectangle(0, size, size, size);\n    passes[3].passState.viewport = new BoundingRectangle(\n      size,\n      size,\n      size,\n      size\n    );\n  }\n\n  // Update clear pass state\n  shadowMap._clearPassState.viewport = new BoundingRectangle(\n    0,\n    0,\n    textureSize.x,\n    textureSize.y\n  );\n\n  // Transforms shadow coordinates [0, 1] into the pass's region of the texture\n  for (var i = 0; i < numberOfPasses; ++i) {\n    var pass = passes[i];\n    var viewport = pass.passState.viewport;\n    var biasX = viewport.x / textureSize.x;\n    var biasY = viewport.y / textureSize.y;\n    var scaleX = viewport.width / textureSize.x;\n    var scaleY = viewport.height / textureSize.y;\n    pass.textureOffsets = new Matrix4(\n      scaleX,\n      0.0,\n      0.0,\n      biasX,\n      0.0,\n      scaleY,\n      0.0,\n      biasY,\n      0.0,\n      0.0,\n      1.0,\n      0.0,\n      0.0,\n      0.0,\n      0.0,\n      1.0\n    );\n  }\n}\n\nvar scratchViewport = new BoundingRectangle();\n\nfunction createDebugShadowViewCommand(shadowMap, context) {\n  var fs;\n  if (shadowMap._isPointLight) {\n    fs =\n      \"uniform samplerCube shadowMap_textureCube; \\n\" +\n      \"varying vec2 v_textureCoordinates; \\n\" +\n      \"void main() \\n\" +\n      \"{ \\n\" +\n      \"    vec2 uv = v_textureCoordinates; \\n\" +\n      \"    vec3 dir; \\n\" +\n      \" \\n\" +\n      \"    if (uv.y < 0.5) \\n\" +\n      \"    { \\n\" +\n      \"        if (uv.x < 0.333) \\n\" +\n      \"        { \\n\" +\n      \"            dir.x = -1.0; \\n\" +\n      \"            dir.y = uv.x * 6.0 - 1.0; \\n\" +\n      \"            dir.z = uv.y * 4.0 - 1.0; \\n\" +\n      \"        } \\n\" +\n      \"        else if (uv.x < 0.666) \\n\" +\n      \"        { \\n\" +\n      \"            dir.y = -1.0; \\n\" +\n      \"            dir.x = uv.x * 6.0 - 3.0; \\n\" +\n      \"            dir.z = uv.y * 4.0 - 1.0; \\n\" +\n      \"        } \\n\" +\n      \"        else \\n\" +\n      \"        { \\n\" +\n      \"            dir.z = -1.0; \\n\" +\n      \"            dir.x = uv.x * 6.0 - 5.0; \\n\" +\n      \"            dir.y = uv.y * 4.0 - 1.0; \\n\" +\n      \"        } \\n\" +\n      \"    } \\n\" +\n      \"    else \\n\" +\n      \"    { \\n\" +\n      \"        if (uv.x < 0.333) \\n\" +\n      \"        { \\n\" +\n      \"            dir.x = 1.0; \\n\" +\n      \"            dir.y = uv.x * 6.0 - 1.0; \\n\" +\n      \"            dir.z = uv.y * 4.0 - 3.0; \\n\" +\n      \"        } \\n\" +\n      \"        else if (uv.x < 0.666) \\n\" +\n      \"        { \\n\" +\n      \"            dir.y = 1.0; \\n\" +\n      \"            dir.x = uv.x * 6.0 - 3.0; \\n\" +\n      \"            dir.z = uv.y * 4.0 - 3.0; \\n\" +\n      \"        } \\n\" +\n      \"        else \\n\" +\n      \"        { \\n\" +\n      \"            dir.z = 1.0; \\n\" +\n      \"            dir.x = uv.x * 6.0 - 5.0; \\n\" +\n      \"            dir.y = uv.y * 4.0 - 3.0; \\n\" +\n      \"        } \\n\" +\n      \"    } \\n\" +\n      \" \\n\" +\n      \"    float shadow = czm_unpackDepth(textureCube(shadowMap_textureCube, dir)); \\n\" +\n      \"    gl_FragColor = vec4(vec3(shadow), 1.0); \\n\" +\n      \"} \\n\";\n  } else {\n    fs =\n      \"uniform sampler2D shadowMap_texture; \\n\" +\n      \"varying vec2 v_textureCoordinates; \\n\" +\n      \"void main() \\n\" +\n      \"{ \\n\" +\n      (shadowMap._usesDepthTexture\n        ? \"    float shadow = texture2D(shadowMap_texture, v_textureCoordinates).r; \\n\"\n        : \"    float shadow = czm_unpackDepth(texture2D(shadowMap_texture, v_textureCoordinates)); \\n\") +\n      \"    gl_FragColor = vec4(vec3(shadow), 1.0); \\n\" +\n      \"} \\n\";\n  }\n\n  var drawCommand = context.createViewportQuadCommand(fs, {\n    uniformMap: {\n      shadowMap_texture: function () {\n        return shadowMap._shadowMapTexture;\n      },\n      shadowMap_textureCube: function () {\n        return shadowMap._shadowMapTexture;\n      },\n    },\n  });\n  drawCommand.pass = Pass.OVERLAY;\n  return drawCommand;\n}\n\nfunction updateDebugShadowViewCommand(shadowMap, frameState) {\n  // Draws the shadow map on the bottom-right corner of the screen\n  var context = frameState.context;\n  var screenWidth = frameState.context.drawingBufferWidth;\n  var screenHeight = frameState.context.drawingBufferHeight;\n  var size = Math.min(screenWidth, screenHeight) * 0.3;\n\n  var viewport = scratchViewport;\n  viewport.x = screenWidth - size;\n  viewport.y = 0;\n  viewport.width = size;\n  viewport.height = size;\n\n  var debugCommand = shadowMap._debugShadowViewCommand;\n  if (!defined(debugCommand)) {\n    debugCommand = createDebugShadowViewCommand(shadowMap, context);\n    shadowMap._debugShadowViewCommand = debugCommand;\n  }\n\n  // Get a new RenderState for the updated viewport size\n  if (\n    !defined(debugCommand.renderState) ||\n    !BoundingRectangle.equals(debugCommand.renderState.viewport, viewport)\n  ) {\n    debugCommand.renderState = RenderState.fromCache({\n      viewport: BoundingRectangle.clone(viewport),\n    });\n  }\n\n  frameState.commandList.push(shadowMap._debugShadowViewCommand);\n}\n\nvar frustumCornersNDC = new Array(8);\nfrustumCornersNDC[0] = new Cartesian4(-1.0, -1.0, -1.0, 1.0);\nfrustumCornersNDC[1] = new Cartesian4(1.0, -1.0, -1.0, 1.0);\nfrustumCornersNDC[2] = new Cartesian4(1.0, 1.0, -1.0, 1.0);\nfrustumCornersNDC[3] = new Cartesian4(-1.0, 1.0, -1.0, 1.0);\nfrustumCornersNDC[4] = new Cartesian4(-1.0, -1.0, 1.0, 1.0);\nfrustumCornersNDC[5] = new Cartesian4(1.0, -1.0, 1.0, 1.0);\nfrustumCornersNDC[6] = new Cartesian4(1.0, 1.0, 1.0, 1.0);\nfrustumCornersNDC[7] = new Cartesian4(-1.0, 1.0, 1.0, 1.0);\n\nvar scratchMatrix = new Matrix4();\nvar scratchFrustumCorners = new Array(8);\nfor (var i = 0; i < 8; ++i) {\n  scratchFrustumCorners[i] = new Cartesian4();\n}\n\nfunction createDebugPointLight(modelMatrix, color) {\n  var box = new GeometryInstance({\n    geometry: new BoxOutlineGeometry({\n      minimum: new Cartesian3(-0.5, -0.5, -0.5),\n      maximum: new Cartesian3(0.5, 0.5, 0.5),\n    }),\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color),\n    },\n  });\n\n  var sphere = new GeometryInstance({\n    geometry: new SphereOutlineGeometry({\n      radius: 0.5,\n    }),\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color),\n    },\n  });\n\n  return new Primitive({\n    geometryInstances: [box, sphere],\n    appearance: new PerInstanceColorAppearance({\n      translucent: false,\n      flat: true,\n    }),\n    asynchronous: false,\n    modelMatrix: modelMatrix,\n  });\n}\n\nvar debugOutlineColors = [Color.RED, Color.GREEN, Color.BLUE, Color.MAGENTA];\nvar scratchScale = new Cartesian3();\n\nfunction applyDebugSettings(shadowMap, frameState) {\n  updateDebugShadowViewCommand(shadowMap, frameState);\n\n  var enterFreezeFrame =\n    shadowMap.debugFreezeFrame && !shadowMap._debugFreezeFrame;\n  shadowMap._debugFreezeFrame = shadowMap.debugFreezeFrame;\n\n  // Draw scene camera in freeze frame mode\n  if (shadowMap.debugFreezeFrame) {\n    if (enterFreezeFrame) {\n      // Recreate debug camera when entering freeze frame mode\n      shadowMap._debugCameraFrustum =\n        shadowMap._debugCameraFrustum &&\n        shadowMap._debugCameraFrustum.destroy();\n      shadowMap._debugCameraFrustum = new DebugCameraPrimitive({\n        camera: shadowMap._sceneCamera,\n        color: Color.CYAN,\n        updateOnChange: false,\n      });\n    }\n    shadowMap._debugCameraFrustum.update(frameState);\n  }\n\n  if (shadowMap._cascadesEnabled) {\n    // Draw cascades only in freeze frame mode\n    if (shadowMap.debugFreezeFrame) {\n      if (enterFreezeFrame) {\n        // Recreate debug frustum when entering freeze frame mode\n        shadowMap._debugLightFrustum =\n          shadowMap._debugLightFrustum &&\n          shadowMap._debugLightFrustum.destroy();\n        shadowMap._debugLightFrustum = new DebugCameraPrimitive({\n          camera: shadowMap._shadowMapCamera,\n          color: Color.YELLOW,\n          updateOnChange: false,\n        });\n      }\n      shadowMap._debugLightFrustum.update(frameState);\n\n      for (var i = 0; i < shadowMap._numberOfCascades; ++i) {\n        if (enterFreezeFrame) {\n          // Recreate debug frustum when entering freeze frame mode\n          shadowMap._debugCascadeFrustums[i] =\n            shadowMap._debugCascadeFrustums[i] &&\n            shadowMap._debugCascadeFrustums[i].destroy();\n          shadowMap._debugCascadeFrustums[i] = new DebugCameraPrimitive({\n            camera: shadowMap._passes[i].camera,\n            color: debugOutlineColors[i],\n            updateOnChange: false,\n          });\n        }\n        shadowMap._debugCascadeFrustums[i].update(frameState);\n      }\n    }\n  } else if (shadowMap._isPointLight) {\n    if (!defined(shadowMap._debugLightFrustum) || shadowMap._needsUpdate) {\n      var translation = shadowMap._shadowMapCamera.positionWC;\n      var rotation = Quaternion.IDENTITY;\n      var uniformScale = shadowMap._pointLightRadius * 2.0;\n      var scale = Cartesian3.fromElements(\n        uniformScale,\n        uniformScale,\n        uniformScale,\n        scratchScale\n      );\n      var modelMatrix = Matrix4.fromTranslationQuaternionRotationScale(\n        translation,\n        rotation,\n        scale,\n        scratchMatrix\n      );\n\n      shadowMap._debugLightFrustum =\n        shadowMap._debugLightFrustum && shadowMap._debugLightFrustum.destroy();\n      shadowMap._debugLightFrustum = createDebugPointLight(\n        modelMatrix,\n        Color.YELLOW\n      );\n    }\n    shadowMap._debugLightFrustum.update(frameState);\n  } else {\n    if (!defined(shadowMap._debugLightFrustum) || shadowMap._needsUpdate) {\n      shadowMap._debugLightFrustum = new DebugCameraPrimitive({\n        camera: shadowMap._shadowMapCamera,\n        color: Color.YELLOW,\n        updateOnChange: false,\n      });\n    }\n    shadowMap._debugLightFrustum.update(frameState);\n  }\n}\n\nfunction ShadowMapCamera() {\n  this.viewMatrix = new Matrix4();\n  this.inverseViewMatrix = new Matrix4();\n  this.frustum = undefined;\n  this.positionCartographic = new Cartographic();\n  this.positionWC = new Cartesian3();\n  this.directionWC = Cartesian3.clone(Cartesian3.UNIT_Z);\n  this.upWC = Cartesian3.clone(Cartesian3.UNIT_Y);\n  this.rightWC = Cartesian3.clone(Cartesian3.UNIT_X);\n  this.viewProjectionMatrix = new Matrix4();\n}\n\nShadowMapCamera.prototype.clone = function (camera) {\n  Matrix4.clone(camera.viewMatrix, this.viewMatrix);\n  Matrix4.clone(camera.inverseViewMatrix, this.inverseViewMatrix);\n  this.frustum = camera.frustum.clone(this.frustum);\n  Cartographic.clone(camera.positionCartographic, this.positionCartographic);\n  Cartesian3.clone(camera.positionWC, this.positionWC);\n  Cartesian3.clone(camera.directionWC, this.directionWC);\n  Cartesian3.clone(camera.upWC, this.upWC);\n  Cartesian3.clone(camera.rightWC, this.rightWC);\n};\n\n// Converts from NDC space to texture space\nvar scaleBiasMatrix = new Matrix4(\n  0.5,\n  0.0,\n  0.0,\n  0.5,\n  0.0,\n  0.5,\n  0.0,\n  0.5,\n  0.0,\n  0.0,\n  0.5,\n  0.5,\n  0.0,\n  0.0,\n  0.0,\n  1.0\n);\n\nShadowMapCamera.prototype.getViewProjection = function () {\n  var view = this.viewMatrix;\n  var projection = this.frustum.projectionMatrix;\n  Matrix4.multiply(projection, view, this.viewProjectionMatrix);\n  Matrix4.multiply(\n    scaleBiasMatrix,\n    this.viewProjectionMatrix,\n    this.viewProjectionMatrix\n  );\n  return this.viewProjectionMatrix;\n};\n\nvar scratchSplits = new Array(5);\nvar scratchFrustum = new PerspectiveFrustum();\nvar scratchCascadeDistances = new Array(4);\nvar scratchMin = new Cartesian3();\nvar scratchMax = new Cartesian3();\n\nfunction computeCascades(shadowMap, frameState) {\n  var shadowMapCamera = shadowMap._shadowMapCamera;\n  var sceneCamera = shadowMap._sceneCamera;\n  var cameraNear = sceneCamera.frustum.near;\n  var cameraFar = sceneCamera.frustum.far;\n  var numberOfCascades = shadowMap._numberOfCascades;\n\n  // Split cascades. Use a mix of linear and log splits.\n  var i;\n  var range = cameraFar - cameraNear;\n  var ratio = cameraFar / cameraNear;\n\n  var lambda = 0.9;\n  var clampCascadeDistances = false;\n\n  // When the camera is close to a relatively small model, provide more detail in the closer cascades.\n  // If the camera is near or inside a large model, such as the root tile of a city, then use the default values.\n  // To get the most accurate cascade splits we would need to find the min and max values from the depth texture.\n  if (frameState.shadowState.closestObjectSize < 200.0) {\n    clampCascadeDistances = true;\n    lambda = 0.9;\n  }\n\n  var cascadeDistances = scratchCascadeDistances;\n  var splits = scratchSplits;\n  splits[0] = cameraNear;\n  splits[numberOfCascades] = cameraFar;\n\n  // Find initial splits\n  for (i = 0; i < numberOfCascades; ++i) {\n    var p = (i + 1) / numberOfCascades;\n    var logScale = cameraNear * Math.pow(ratio, p);\n    var uniformScale = cameraNear + range * p;\n    var split = CesiumMath.lerp(uniformScale, logScale, lambda);\n    splits[i + 1] = split;\n    cascadeDistances[i] = split - splits[i];\n  }\n\n  if (clampCascadeDistances) {\n    // Clamp each cascade to its maximum distance\n    for (i = 0; i < numberOfCascades; ++i) {\n      cascadeDistances[i] = Math.min(\n        cascadeDistances[i],\n        shadowMap._maximumCascadeDistances[i]\n      );\n    }\n\n    // Recompute splits\n    var distance = splits[0];\n    for (i = 0; i < numberOfCascades - 1; ++i) {\n      distance += cascadeDistances[i];\n      splits[i + 1] = distance;\n    }\n  }\n\n  Cartesian4.unpack(splits, 0, shadowMap._cascadeSplits[0]);\n  Cartesian4.unpack(splits, 1, shadowMap._cascadeSplits[1]);\n  Cartesian4.unpack(cascadeDistances, 0, shadowMap._cascadeDistances);\n\n  var shadowFrustum = shadowMapCamera.frustum;\n  var left = shadowFrustum.left;\n  var right = shadowFrustum.right;\n  var bottom = shadowFrustum.bottom;\n  var top = shadowFrustum.top;\n  var near = shadowFrustum.near;\n  var far = shadowFrustum.far;\n\n  var position = shadowMapCamera.positionWC;\n  var direction = shadowMapCamera.directionWC;\n  var up = shadowMapCamera.upWC;\n\n  var cascadeSubFrustum = sceneCamera.frustum.clone(scratchFrustum);\n  var shadowViewProjection = shadowMapCamera.getViewProjection();\n\n  for (i = 0; i < numberOfCascades; ++i) {\n    // Find the bounding box of the camera sub-frustum in shadow map texture space\n    cascadeSubFrustum.near = splits[i];\n    cascadeSubFrustum.far = splits[i + 1];\n    var viewProjection = Matrix4.multiply(\n      cascadeSubFrustum.projectionMatrix,\n      sceneCamera.viewMatrix,\n      scratchMatrix\n    );\n    var inverseViewProjection = Matrix4.inverse(viewProjection, scratchMatrix);\n    var shadowMapMatrix = Matrix4.multiply(\n      shadowViewProjection,\n      inverseViewProjection,\n      scratchMatrix\n    );\n\n    // Project each corner from camera NDC space to shadow map texture space. Min and max will be from 0 to 1.\n    var min = Cartesian3.fromElements(\n      Number.MAX_VALUE,\n      Number.MAX_VALUE,\n      Number.MAX_VALUE,\n      scratchMin\n    );\n    var max = Cartesian3.fromElements(\n      -Number.MAX_VALUE,\n      -Number.MAX_VALUE,\n      -Number.MAX_VALUE,\n      scratchMax\n    );\n\n    for (var k = 0; k < 8; ++k) {\n      var corner = Cartesian4.clone(\n        frustumCornersNDC[k],\n        scratchFrustumCorners[k]\n      );\n      Matrix4.multiplyByVector(shadowMapMatrix, corner, corner);\n      Cartesian3.divideByScalar(corner, corner.w, corner); // Handle the perspective divide\n      Cartesian3.minimumByComponent(corner, min, min);\n      Cartesian3.maximumByComponent(corner, max, max);\n    }\n\n    // Limit light-space coordinates to the [0, 1] range\n    min.x = Math.max(min.x, 0.0);\n    min.y = Math.max(min.y, 0.0);\n    min.z = 0.0; // Always start cascade frustum at the top of the light frustum to capture objects in the light's path\n    max.x = Math.min(max.x, 1.0);\n    max.y = Math.min(max.y, 1.0);\n    max.z = Math.min(max.z, 1.0);\n\n    var pass = shadowMap._passes[i];\n    var cascadeCamera = pass.camera;\n    cascadeCamera.clone(shadowMapCamera); // PERFORMANCE_IDEA : could do a shallow clone for all properties except the frustum\n\n    var frustum = cascadeCamera.frustum;\n    frustum.left = left + min.x * (right - left);\n    frustum.right = left + max.x * (right - left);\n    frustum.bottom = bottom + min.y * (top - bottom);\n    frustum.top = bottom + max.y * (top - bottom);\n    frustum.near = near + min.z * (far - near);\n    frustum.far = near + max.z * (far - near);\n\n    pass.cullingVolume = cascadeCamera.frustum.computeCullingVolume(\n      position,\n      direction,\n      up\n    );\n\n    // Transforms from eye space to the cascade's texture space\n    var cascadeMatrix = shadowMap._cascadeMatrices[i];\n    Matrix4.multiply(\n      cascadeCamera.getViewProjection(),\n      sceneCamera.inverseViewMatrix,\n      cascadeMatrix\n    );\n    Matrix4.multiply(pass.textureOffsets, cascadeMatrix, cascadeMatrix);\n  }\n}\n\nvar scratchLightView = new Matrix4();\nvar scratchRight = new Cartesian3();\nvar scratchUp = new Cartesian3();\nvar scratchTranslation = new Cartesian3();\n\nfunction fitShadowMapToScene(shadowMap, frameState) {\n  var shadowMapCamera = shadowMap._shadowMapCamera;\n  var sceneCamera = shadowMap._sceneCamera;\n\n  // 1. First find a tight bounding box in light space that contains the entire camera frustum.\n  var viewProjection = Matrix4.multiply(\n    sceneCamera.frustum.projectionMatrix,\n    sceneCamera.viewMatrix,\n    scratchMatrix\n  );\n  var inverseViewProjection = Matrix4.inverse(viewProjection, scratchMatrix);\n\n  // Start to construct the light view matrix. Set translation later once the bounding box is found.\n  var lightDir = shadowMapCamera.directionWC;\n  var lightUp = sceneCamera.directionWC; // Align shadows to the camera view.\n  if (Cartesian3.equalsEpsilon(lightDir, lightUp, CesiumMath.EPSILON10)) {\n    lightUp = sceneCamera.upWC;\n  }\n  var lightRight = Cartesian3.cross(lightDir, lightUp, scratchRight);\n  lightUp = Cartesian3.cross(lightRight, lightDir, scratchUp); // Recalculate up now that right is derived\n  Cartesian3.normalize(lightUp, lightUp);\n  Cartesian3.normalize(lightRight, lightRight);\n  var lightPosition = Cartesian3.fromElements(\n    0.0,\n    0.0,\n    0.0,\n    scratchTranslation\n  );\n\n  var lightView = Matrix4.computeView(\n    lightPosition,\n    lightDir,\n    lightUp,\n    lightRight,\n    scratchLightView\n  );\n  var cameraToLight = Matrix4.multiply(\n    lightView,\n    inverseViewProjection,\n    scratchMatrix\n  );\n\n  // Project each corner from NDC space to light view space, and calculate a min and max in light view space\n  var min = Cartesian3.fromElements(\n    Number.MAX_VALUE,\n    Number.MAX_VALUE,\n    Number.MAX_VALUE,\n    scratchMin\n  );\n  var max = Cartesian3.fromElements(\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE,\n    scratchMax\n  );\n\n  for (var i = 0; i < 8; ++i) {\n    var corner = Cartesian4.clone(\n      frustumCornersNDC[i],\n      scratchFrustumCorners[i]\n    );\n    Matrix4.multiplyByVector(cameraToLight, corner, corner);\n    Cartesian3.divideByScalar(corner, corner.w, corner); // Handle the perspective divide\n    Cartesian3.minimumByComponent(corner, min, min);\n    Cartesian3.maximumByComponent(corner, max, max);\n  }\n\n  // 2. Set bounding box back to include objects in the light's view\n  max.z += 1000.0; // Note: in light space, a positive number is behind the camera\n  min.z -= 10.0; // Extend the shadow volume forward slightly to avoid problems right at the edge\n\n  // 3. Adjust light view matrix so that it is centered on the bounding volume\n  var translation = scratchTranslation;\n  translation.x = -(0.5 * (min.x + max.x));\n  translation.y = -(0.5 * (min.y + max.y));\n  translation.z = -max.z;\n\n  var translationMatrix = Matrix4.fromTranslation(translation, scratchMatrix);\n  lightView = Matrix4.multiply(translationMatrix, lightView, lightView);\n\n  // 4. Create an orthographic frustum that covers the bounding box extents\n  var halfWidth = 0.5 * (max.x - min.x);\n  var halfHeight = 0.5 * (max.y - min.y);\n  var depth = max.z - min.z;\n\n  var frustum = shadowMapCamera.frustum;\n  frustum.left = -halfWidth;\n  frustum.right = halfWidth;\n  frustum.bottom = -halfHeight;\n  frustum.top = halfHeight;\n  frustum.near = 0.01;\n  frustum.far = depth;\n\n  // 5. Update the shadow map camera\n  Matrix4.clone(lightView, shadowMapCamera.viewMatrix);\n  Matrix4.inverse(lightView, shadowMapCamera.inverseViewMatrix);\n  Matrix4.getTranslation(\n    shadowMapCamera.inverseViewMatrix,\n    shadowMapCamera.positionWC\n  );\n  frameState.mapProjection.ellipsoid.cartesianToCartographic(\n    shadowMapCamera.positionWC,\n    shadowMapCamera.positionCartographic\n  );\n  Cartesian3.clone(lightDir, shadowMapCamera.directionWC);\n  Cartesian3.clone(lightUp, shadowMapCamera.upWC);\n  Cartesian3.clone(lightRight, shadowMapCamera.rightWC);\n}\n\nvar directions = [\n  new Cartesian3(-1.0, 0.0, 0.0),\n  new Cartesian3(0.0, -1.0, 0.0),\n  new Cartesian3(0.0, 0.0, -1.0),\n  new Cartesian3(1.0, 0.0, 0.0),\n  new Cartesian3(0.0, 1.0, 0.0),\n  new Cartesian3(0.0, 0.0, 1.0),\n];\n\nvar ups = [\n  new Cartesian3(0.0, -1.0, 0.0),\n  new Cartesian3(0.0, 0.0, -1.0),\n  new Cartesian3(0.0, -1.0, 0.0),\n  new Cartesian3(0.0, -1.0, 0.0),\n  new Cartesian3(0.0, 0.0, 1.0),\n  new Cartesian3(0.0, -1.0, 0.0),\n];\n\nvar rights = [\n  new Cartesian3(0.0, 0.0, 1.0),\n  new Cartesian3(1.0, 0.0, 0.0),\n  new Cartesian3(-1.0, 0.0, 0.0),\n  new Cartesian3(0.0, 0.0, -1.0),\n  new Cartesian3(1.0, 0.0, 0.0),\n  new Cartesian3(1.0, 0.0, 0.0),\n];\n\nfunction computeOmnidirectional(shadowMap, frameState) {\n  // All sides share the same frustum\n  var frustum = new PerspectiveFrustum();\n  frustum.fov = CesiumMath.PI_OVER_TWO;\n  frustum.near = 1.0;\n  frustum.far = shadowMap._pointLightRadius;\n  frustum.aspectRatio = 1.0;\n\n  for (var i = 0; i < 6; ++i) {\n    var camera = shadowMap._passes[i].camera;\n    camera.positionWC = shadowMap._shadowMapCamera.positionWC;\n    camera.positionCartographic = frameState.mapProjection.ellipsoid.cartesianToCartographic(\n      camera.positionWC,\n      camera.positionCartographic\n    );\n    camera.directionWC = directions[i];\n    camera.upWC = ups[i];\n    camera.rightWC = rights[i];\n\n    Matrix4.computeView(\n      camera.positionWC,\n      camera.directionWC,\n      camera.upWC,\n      camera.rightWC,\n      camera.viewMatrix\n    );\n    Matrix4.inverse(camera.viewMatrix, camera.inverseViewMatrix);\n\n    camera.frustum = frustum;\n  }\n}\n\nvar scratchCartesian1 = new Cartesian3();\nvar scratchCartesian2 = new Cartesian3();\nvar scratchBoundingSphere = new BoundingSphere();\nvar scratchCenter = scratchBoundingSphere.center;\n\nfunction checkVisibility(shadowMap, frameState) {\n  var sceneCamera = shadowMap._sceneCamera;\n  var shadowMapCamera = shadowMap._shadowMapCamera;\n\n  var boundingSphere = scratchBoundingSphere;\n\n  // Check whether the shadow map is in view and needs to be updated\n  if (shadowMap._cascadesEnabled) {\n    // If the nearest shadow receiver is further than the shadow map's maximum distance then the shadow map is out of view.\n    if (sceneCamera.frustum.near >= shadowMap.maximumDistance) {\n      shadowMap._outOfView = true;\n      shadowMap._needsUpdate = false;\n      return;\n    }\n\n    // If the light source is below the horizon then the shadow map is out of view\n    var surfaceNormal = frameState.mapProjection.ellipsoid.geodeticSurfaceNormal(\n      sceneCamera.positionWC,\n      scratchCartesian1\n    );\n    var lightDirection = Cartesian3.negate(\n      shadowMapCamera.directionWC,\n      scratchCartesian2\n    );\n    var dot = Cartesian3.dot(surfaceNormal, lightDirection);\n\n    // Shadows start to fade out once the light gets closer to the horizon.\n    // At this point the globe uses vertex lighting alone to darken the surface.\n    var darknessAmount = CesiumMath.clamp(dot / 0.1, 0.0, 1.0);\n    shadowMap._darkness = CesiumMath.lerp(\n      1.0,\n      shadowMap.darkness,\n      darknessAmount\n    );\n\n    if (dot < 0.0) {\n      shadowMap._outOfView = true;\n      shadowMap._needsUpdate = false;\n      return;\n    }\n\n    // By default cascaded shadows need to update and are always in view\n    shadowMap._needsUpdate = true;\n    shadowMap._outOfView = false;\n  } else if (shadowMap._isPointLight) {\n    // Sphere-frustum intersection test\n    boundingSphere.center = shadowMapCamera.positionWC;\n    boundingSphere.radius = shadowMap._pointLightRadius;\n    shadowMap._outOfView =\n      frameState.cullingVolume.computeVisibility(boundingSphere) ===\n      Intersect.OUTSIDE;\n    shadowMap._needsUpdate =\n      !shadowMap._outOfView &&\n      !shadowMap._boundingSphere.equals(boundingSphere);\n    BoundingSphere.clone(boundingSphere, shadowMap._boundingSphere);\n  } else {\n    // Simplify frustum-frustum intersection test as a sphere-frustum test\n    var frustumRadius = shadowMapCamera.frustum.far / 2.0;\n    var frustumCenter = Cartesian3.add(\n      shadowMapCamera.positionWC,\n      Cartesian3.multiplyByScalar(\n        shadowMapCamera.directionWC,\n        frustumRadius,\n        scratchCenter\n      ),\n      scratchCenter\n    );\n    boundingSphere.center = frustumCenter;\n    boundingSphere.radius = frustumRadius;\n    shadowMap._outOfView =\n      frameState.cullingVolume.computeVisibility(boundingSphere) ===\n      Intersect.OUTSIDE;\n    shadowMap._needsUpdate =\n      !shadowMap._outOfView &&\n      !shadowMap._boundingSphere.equals(boundingSphere);\n    BoundingSphere.clone(boundingSphere, shadowMap._boundingSphere);\n  }\n}\n\nfunction updateCameras(shadowMap, frameState) {\n  var camera = frameState.camera; // The actual camera in the scene\n  var lightCamera = shadowMap._lightCamera; // The external camera representing the light source\n  var sceneCamera = shadowMap._sceneCamera; // Clone of camera, with clamped near and far planes\n  var shadowMapCamera = shadowMap._shadowMapCamera; // Camera representing the shadow volume, initially cloned from lightCamera\n\n  // Clone light camera into the shadow map camera\n  if (shadowMap._cascadesEnabled) {\n    Cartesian3.clone(lightCamera.directionWC, shadowMapCamera.directionWC);\n  } else if (shadowMap._isPointLight) {\n    Cartesian3.clone(lightCamera.positionWC, shadowMapCamera.positionWC);\n  } else {\n    shadowMapCamera.clone(lightCamera);\n  }\n\n  // Get the light direction in eye coordinates\n  var lightDirection = shadowMap._lightDirectionEC;\n  Matrix4.multiplyByPointAsVector(\n    camera.viewMatrix,\n    shadowMapCamera.directionWC,\n    lightDirection\n  );\n  Cartesian3.normalize(lightDirection, lightDirection);\n  Cartesian3.negate(lightDirection, lightDirection);\n\n  // Get the light position in eye coordinates\n  Matrix4.multiplyByPoint(\n    camera.viewMatrix,\n    shadowMapCamera.positionWC,\n    shadowMap._lightPositionEC\n  );\n  shadowMap._lightPositionEC.w = shadowMap._pointLightRadius;\n\n  // Get the near and far of the scene camera\n  var near;\n  var far;\n  if (shadowMap._fitNearFar) {\n    // shadowFar can be very large, so limit to shadowMap.maximumDistance\n    // Push the far plane slightly further than the near plane to avoid degenerate frustum\n    near = Math.min(\n      frameState.shadowState.nearPlane,\n      shadowMap.maximumDistance\n    );\n    far = Math.min(\n      frameState.shadowState.farPlane,\n      shadowMap.maximumDistance + 1.0\n    );\n  } else {\n    near = camera.frustum.near;\n    far = shadowMap.maximumDistance;\n  }\n\n  shadowMap._sceneCamera = Camera.clone(camera, sceneCamera);\n  camera.frustum.clone(shadowMap._sceneCamera.frustum);\n  shadowMap._sceneCamera.frustum.near = near;\n  shadowMap._sceneCamera.frustum.far = far;\n  shadowMap._distance = far - near;\n\n  checkVisibility(shadowMap, frameState);\n\n  if (!shadowMap._outOfViewPrevious && shadowMap._outOfView) {\n    shadowMap._needsUpdate = true;\n  }\n  shadowMap._outOfViewPrevious = shadowMap._outOfView;\n}\n\n/**\n * @private\n */\nShadowMap.prototype.update = function (frameState) {\n  updateCameras(this, frameState);\n\n  if (this._needsUpdate) {\n    updateFramebuffer(this, frameState.context);\n\n    if (this._isPointLight) {\n      computeOmnidirectional(this, frameState);\n    }\n\n    if (this._cascadesEnabled) {\n      fitShadowMapToScene(this, frameState);\n\n      if (this._numberOfCascades > 1) {\n        computeCascades(this, frameState);\n      }\n    }\n\n    if (!this._isPointLight) {\n      // Compute the culling volume\n      var shadowMapCamera = this._shadowMapCamera;\n      var position = shadowMapCamera.positionWC;\n      var direction = shadowMapCamera.directionWC;\n      var up = shadowMapCamera.upWC;\n      this._shadowMapCullingVolume = shadowMapCamera.frustum.computeCullingVolume(\n        position,\n        direction,\n        up\n      );\n\n      if (this._passes.length === 1) {\n        // Since there is only one pass, use the shadow map camera as the pass camera.\n        this._passes[0].camera.clone(shadowMapCamera);\n      }\n    } else {\n      this._shadowMapCullingVolume = CullingVolume.fromBoundingSphere(\n        this._boundingSphere\n      );\n    }\n  }\n\n  if (this._passes.length === 1) {\n    // Transforms from eye space to shadow texture space.\n    // Always requires an update since the scene camera constantly changes.\n    var inverseView = this._sceneCamera.inverseViewMatrix;\n    Matrix4.multiply(\n      this._shadowMapCamera.getViewProjection(),\n      inverseView,\n      this._shadowMapMatrix\n    );\n  }\n\n  if (this.debugShow) {\n    applyDebugSettings(this, frameState);\n  }\n};\n\n/**\n * @private\n */\nShadowMap.prototype.updatePass = function (context, shadowPass) {\n  clearFramebuffer(this, context, shadowPass);\n};\n\nvar scratchTexelStepSize = new Cartesian2();\n\nfunction combineUniforms(shadowMap, uniforms, isTerrain) {\n  var bias = shadowMap._isPointLight\n    ? shadowMap._pointBias\n    : isTerrain\n    ? shadowMap._terrainBias\n    : shadowMap._primitiveBias;\n\n  var mapUniforms = {\n    shadowMap_texture: function () {\n      return shadowMap._shadowMapTexture;\n    },\n    shadowMap_textureCube: function () {\n      return shadowMap._shadowMapTexture;\n    },\n    shadowMap_matrix: function () {\n      return shadowMap._shadowMapMatrix;\n    },\n    shadowMap_cascadeSplits: function () {\n      return shadowMap._cascadeSplits;\n    },\n    shadowMap_cascadeMatrices: function () {\n      return shadowMap._cascadeMatrices;\n    },\n    shadowMap_lightDirectionEC: function () {\n      return shadowMap._lightDirectionEC;\n    },\n    shadowMap_lightPositionEC: function () {\n      return shadowMap._lightPositionEC;\n    },\n    shadowMap_cascadeDistances: function () {\n      return shadowMap._cascadeDistances;\n    },\n    shadowMap_texelSizeDepthBiasAndNormalShadingSmooth: function () {\n      var texelStepSize = scratchTexelStepSize;\n      texelStepSize.x = 1.0 / shadowMap._textureSize.x;\n      texelStepSize.y = 1.0 / shadowMap._textureSize.y;\n\n      return Cartesian4.fromElements(\n        texelStepSize.x,\n        texelStepSize.y,\n        bias.depthBias,\n        bias.normalShadingSmooth,\n        this.combinedUniforms1\n      );\n    },\n    shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness: function () {\n      return Cartesian4.fromElements(\n        bias.normalOffsetScale,\n        shadowMap._distance,\n        shadowMap.maximumDistance,\n        shadowMap._darkness,\n        this.combinedUniforms2\n      );\n    },\n\n    combinedUniforms1: new Cartesian4(),\n    combinedUniforms2: new Cartesian4(),\n  };\n\n  return combine(uniforms, mapUniforms, false);\n}\n\nfunction createCastDerivedCommand(\n  shadowMap,\n  shadowsDirty,\n  command,\n  context,\n  oldShaderId,\n  result\n) {\n  var castShader;\n  var castRenderState;\n  var castUniformMap;\n  if (defined(result)) {\n    castShader = result.shaderProgram;\n    castRenderState = result.renderState;\n    castUniformMap = result.uniformMap;\n  }\n\n  result = DrawCommand.shallowClone(command, result);\n  result.castShadows = true;\n  result.receiveShadows = false;\n\n  if (\n    !defined(castShader) ||\n    oldShaderId !== command.shaderProgram.id ||\n    shadowsDirty\n  ) {\n    var shaderProgram = command.shaderProgram;\n\n    var isTerrain = command.pass === Pass.GLOBE;\n    var isOpaque = command.pass !== Pass.TRANSLUCENT;\n    var isPointLight = shadowMap._isPointLight;\n    var usesDepthTexture = shadowMap._usesDepthTexture;\n\n    var keyword = ShadowMapShader.getShadowCastShaderKeyword(\n      isPointLight,\n      isTerrain,\n      usesDepthTexture,\n      isOpaque\n    );\n    castShader = context.shaderCache.getDerivedShaderProgram(\n      shaderProgram,\n      keyword\n    );\n    if (!defined(castShader)) {\n      var vertexShaderSource = shaderProgram.vertexShaderSource;\n      var fragmentShaderSource = shaderProgram.fragmentShaderSource;\n\n      var castVS = ShadowMapShader.createShadowCastVertexShader(\n        vertexShaderSource,\n        isPointLight,\n        isTerrain\n      );\n      var castFS = ShadowMapShader.createShadowCastFragmentShader(\n        fragmentShaderSource,\n        isPointLight,\n        usesDepthTexture,\n        isOpaque\n      );\n\n      castShader = context.shaderCache.createDerivedShaderProgram(\n        shaderProgram,\n        keyword,\n        {\n          vertexShaderSource: castVS,\n          fragmentShaderSource: castFS,\n          attributeLocations: shaderProgram._attributeLocations,\n        }\n      );\n    }\n\n    castRenderState = shadowMap._primitiveRenderState;\n    if (isPointLight) {\n      castRenderState = shadowMap._pointRenderState;\n    } else if (isTerrain) {\n      castRenderState = shadowMap._terrainRenderState;\n    }\n\n    // Modify the render state for commands that do not use back-face culling, e.g. flat textured walls\n    var cullEnabled = command.renderState.cull.enabled;\n    if (!cullEnabled) {\n      castRenderState = clone(castRenderState, false);\n      castRenderState.cull = clone(castRenderState.cull, false);\n      castRenderState.cull.enabled = false;\n      castRenderState = RenderState.fromCache(castRenderState);\n    }\n\n    castUniformMap = combineUniforms(shadowMap, command.uniformMap, isTerrain);\n  }\n\n  result.shaderProgram = castShader;\n  result.renderState = castRenderState;\n  result.uniformMap = castUniformMap;\n\n  return result;\n}\n\nShadowMap.createReceiveDerivedCommand = function (\n  lightShadowMaps,\n  command,\n  shadowsDirty,\n  context,\n  result\n) {\n  if (!defined(result)) {\n    result = {};\n  }\n\n  var lightShadowMapsEnabled = lightShadowMaps.length > 0;\n  var shaderProgram = command.shaderProgram;\n  var vertexShaderSource = shaderProgram.vertexShaderSource;\n  var fragmentShaderSource = shaderProgram.fragmentShaderSource;\n  var isTerrain = command.pass === Pass.GLOBE;\n\n  var hasTerrainNormal = false;\n  if (isTerrain) {\n    hasTerrainNormal =\n      command.owner.data.renderedMesh.encoding.hasVertexNormals;\n  }\n\n  if (command.receiveShadows && lightShadowMapsEnabled) {\n    // Only generate a receiveCommand if there is a shadow map originating from a light source.\n    var receiveShader;\n    var receiveUniformMap;\n    if (defined(result.receiveCommand)) {\n      receiveShader = result.receiveCommand.shaderProgram;\n      receiveUniformMap = result.receiveCommand.uniformMap;\n    }\n\n    result.receiveCommand = DrawCommand.shallowClone(\n      command,\n      result.receiveCommand\n    );\n    result.castShadows = false;\n    result.receiveShadows = true;\n\n    // If castShadows changed, recompile the receive shadows shader. The normal shading technique simulates\n    // self-shadowing so it should be turned off if castShadows is false.\n    var castShadowsDirty =\n      result.receiveShaderCastShadows !== command.castShadows;\n    var shaderDirty =\n      result.receiveShaderProgramId !== command.shaderProgram.id;\n\n    if (\n      !defined(receiveShader) ||\n      shaderDirty ||\n      shadowsDirty ||\n      castShadowsDirty\n    ) {\n      var keyword = ShadowMapShader.getShadowReceiveShaderKeyword(\n        lightShadowMaps[0],\n        command.castShadows,\n        isTerrain,\n        hasTerrainNormal\n      );\n      receiveShader = context.shaderCache.getDerivedShaderProgram(\n        shaderProgram,\n        keyword\n      );\n      if (!defined(receiveShader)) {\n        var receiveVS = ShadowMapShader.createShadowReceiveVertexShader(\n          vertexShaderSource,\n          isTerrain,\n          hasTerrainNormal\n        );\n        var receiveFS = ShadowMapShader.createShadowReceiveFragmentShader(\n          fragmentShaderSource,\n          lightShadowMaps[0],\n          command.castShadows,\n          isTerrain,\n          hasTerrainNormal\n        );\n\n        receiveShader = context.shaderCache.createDerivedShaderProgram(\n          shaderProgram,\n          keyword,\n          {\n            vertexShaderSource: receiveVS,\n            fragmentShaderSource: receiveFS,\n            attributeLocations: shaderProgram._attributeLocations,\n          }\n        );\n      }\n\n      receiveUniformMap = combineUniforms(\n        lightShadowMaps[0],\n        command.uniformMap,\n        isTerrain\n      );\n    }\n\n    result.receiveCommand.shaderProgram = receiveShader;\n    result.receiveCommand.uniformMap = receiveUniformMap;\n    result.receiveShaderProgramId = command.shaderProgram.id;\n    result.receiveShaderCastShadows = command.castShadows;\n  }\n\n  return result;\n};\n\nShadowMap.createCastDerivedCommand = function (\n  shadowMaps,\n  command,\n  shadowsDirty,\n  context,\n  result\n) {\n  if (!defined(result)) {\n    result = {};\n  }\n\n  if (command.castShadows) {\n    var castCommands = result.castCommands;\n    if (!defined(castCommands)) {\n      castCommands = result.castCommands = [];\n    }\n\n    var oldShaderId = result.castShaderProgramId;\n\n    var shadowMapLength = shadowMaps.length;\n    castCommands.length = shadowMapLength;\n\n    for (var i = 0; i < shadowMapLength; ++i) {\n      castCommands[i] = createCastDerivedCommand(\n        shadowMaps[i],\n        shadowsDirty,\n        command,\n        context,\n        oldShaderId,\n        castCommands[i]\n      );\n    }\n\n    result.castShaderProgramId = command.shaderProgram.id;\n  }\n\n  return result;\n};\n\n/**\n * @private\n */\nShadowMap.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * @private\n */\nShadowMap.prototype.destroy = function () {\n  destroyFramebuffer(this);\n\n  this._debugLightFrustum =\n    this._debugLightFrustum && this._debugLightFrustum.destroy();\n  this._debugCameraFrustum =\n    this._debugCameraFrustum && this._debugCameraFrustum.destroy();\n  this._debugShadowViewCommand =\n    this._debugShadowViewCommand &&\n    this._debugShadowViewCommand.shaderProgram &&\n    this._debugShadowViewCommand.shaderProgram.destroy();\n\n  for (var i = 0; i < this._numberOfCascades; ++i) {\n    this._debugCascadeFrustums[i] =\n      this._debugCascadeFrustums[i] && this._debugCascadeFrustums[i].destroy();\n  }\n\n  return destroyObject(this);\n};\nexport default ShadowMap;\n"]},"metadata":{},"sourceType":"module"}