{"ast":null,"code":"import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport WebGLConstants from \"./WebGLConstants.js\";\n/**\n * Constants for WebGL index datatypes.  These corresponds to the\n * <code>type</code> parameter of {@link http://www.khronos.org/opengles/sdk/docs/man/xhtml/glDrawElements.xml|drawElements}.\n *\n * @exports IndexDatatype\n */\n\nvar IndexDatatype = {\n  /**\n   * 8-bit unsigned byte corresponding to <code>UNSIGNED_BYTE</code> and the type\n   * of an element in <code>Uint8Array</code>.\n   *\n   * @type {Number}\n   * @constant\n   */\n  UNSIGNED_BYTE: WebGLConstants.UNSIGNED_BYTE,\n\n  /**\n   * 16-bit unsigned short corresponding to <code>UNSIGNED_SHORT</code> and the type\n   * of an element in <code>Uint16Array</code>.\n   *\n   * @type {Number}\n   * @constant\n   */\n  UNSIGNED_SHORT: WebGLConstants.UNSIGNED_SHORT,\n\n  /**\n   * 32-bit unsigned int corresponding to <code>UNSIGNED_INT</code> and the type\n   * of an element in <code>Uint32Array</code>.\n   *\n   * @type {Number}\n   * @constant\n   */\n  UNSIGNED_INT: WebGLConstants.UNSIGNED_INT\n};\n/**\n * Returns the size, in bytes, of the corresponding datatype.\n *\n * @param {IndexDatatype} indexDatatype The index datatype to get the size of.\n * @returns {Number} The size in bytes.\n *\n * @example\n * // Returns 2\n * var size = Cesium.IndexDatatype.getSizeInBytes(Cesium.IndexDatatype.UNSIGNED_SHORT);\n */\n\nIndexDatatype.getSizeInBytes = function (indexDatatype) {\n  switch (indexDatatype) {\n    case IndexDatatype.UNSIGNED_BYTE:\n      return Uint8Array.BYTES_PER_ELEMENT;\n\n    case IndexDatatype.UNSIGNED_SHORT:\n      return Uint16Array.BYTES_PER_ELEMENT;\n\n    case IndexDatatype.UNSIGNED_INT:\n      return Uint32Array.BYTES_PER_ELEMENT;\n  } //>>includeStart('debug', pragmas.debug);\n\n\n  throw new DeveloperError(\"indexDatatype is required and must be a valid IndexDatatype constant.\"); //>>includeEnd('debug');\n};\n/**\n * Gets the datatype with a given size in bytes.\n *\n * @param {Number} sizeInBytes The size of a single index in bytes.\n * @returns {IndexDatatype} The index datatype with the given size.\n */\n\n\nIndexDatatype.fromSizeInBytes = function (sizeInBytes) {\n  switch (sizeInBytes) {\n    case 2:\n      return IndexDatatype.UNSIGNED_SHORT;\n\n    case 4:\n      return IndexDatatype.UNSIGNED_INT;\n\n    case 1:\n      return IndexDatatype.UNSIGNED_BYTE;\n    //>>includeStart('debug', pragmas.debug);\n\n    default:\n      throw new DeveloperError(\"Size in bytes cannot be mapped to an IndexDatatype\");\n    //>>includeEnd('debug');\n  }\n};\n/**\n * Validates that the provided index datatype is a valid {@link IndexDatatype}.\n *\n * @param {IndexDatatype} indexDatatype The index datatype to validate.\n * @returns {Boolean} <code>true</code> if the provided index datatype is a valid value; otherwise, <code>false</code>.\n *\n * @example\n * if (!Cesium.IndexDatatype.validate(indexDatatype)) {\n *   throw new Cesium.DeveloperError('indexDatatype must be a valid value.');\n * }\n */\n\n\nIndexDatatype.validate = function (indexDatatype) {\n  return defined(indexDatatype) && (indexDatatype === IndexDatatype.UNSIGNED_BYTE || indexDatatype === IndexDatatype.UNSIGNED_SHORT || indexDatatype === IndexDatatype.UNSIGNED_INT);\n};\n/**\n * Creates a typed array that will store indices, using either <code><Uint16Array</code>\n * or <code>Uint32Array</code> depending on the number of vertices.\n *\n * @param {Number} numberOfVertices Number of vertices that the indices will reference.\n * @param {Number|Array} indicesLengthOrArray Passed through to the typed array constructor.\n * @returns {Uint16Array|Uint32Array} A <code>Uint16Array</code> or <code>Uint32Array</code> constructed with <code>indicesLengthOrArray</code>.\n *\n * @example\n * this.indices = Cesium.IndexDatatype.createTypedArray(positions.length / 3, numberOfIndices);\n */\n\n\nIndexDatatype.createTypedArray = function (numberOfVertices, indicesLengthOrArray) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(numberOfVertices)) {\n    throw new DeveloperError(\"numberOfVertices is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES) {\n    return new Uint32Array(indicesLengthOrArray);\n  }\n\n  return new Uint16Array(indicesLengthOrArray);\n};\n/**\n * Creates a typed array from a source array buffer.  The resulting typed array will store indices, using either <code><Uint16Array</code>\n * or <code>Uint32Array</code> depending on the number of vertices.\n *\n * @param {Number} numberOfVertices Number of vertices that the indices will reference.\n * @param {ArrayBuffer} sourceArray Passed through to the typed array constructor.\n * @param {Number} byteOffset Passed through to the typed array constructor.\n * @param {Number} length Passed through to the typed array constructor.\n * @returns {Uint16Array|Uint32Array} A <code>Uint16Array</code> or <code>Uint32Array</code> constructed with <code>sourceArray</code>, <code>byteOffset</code>, and <code>length</code>.\n *\n */\n\n\nIndexDatatype.createTypedArrayFromArrayBuffer = function (numberOfVertices, sourceArray, byteOffset, length) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(numberOfVertices)) {\n    throw new DeveloperError(\"numberOfVertices is required.\");\n  }\n\n  if (!defined(sourceArray)) {\n    throw new DeveloperError(\"sourceArray is required.\");\n  }\n\n  if (!defined(byteOffset)) {\n    throw new DeveloperError(\"byteOffset is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES) {\n    return new Uint32Array(sourceArray, byteOffset, length);\n  }\n\n  return new Uint16Array(sourceArray, byteOffset, length);\n};\n\nexport default Object.freeze(IndexDatatype);","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/IndexDatatype.js"],"names":["defined","DeveloperError","CesiumMath","WebGLConstants","IndexDatatype","UNSIGNED_BYTE","UNSIGNED_SHORT","UNSIGNED_INT","getSizeInBytes","indexDatatype","Uint8Array","BYTES_PER_ELEMENT","Uint16Array","Uint32Array","fromSizeInBytes","sizeInBytes","validate","createTypedArray","numberOfVertices","indicesLengthOrArray","SIXTY_FOUR_KILOBYTES","createTypedArrayFromArrayBuffer","sourceArray","byteOffset","length","Object","freeze"],"mappings":"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","sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport WebGLConstants from \"./WebGLConstants.js\";\n\n/**\n * Constants for WebGL index datatypes.  These corresponds to the\n * <code>type</code> parameter of {@link http://www.khronos.org/opengles/sdk/docs/man/xhtml/glDrawElements.xml|drawElements}.\n *\n * @exports IndexDatatype\n */\nvar IndexDatatype = {\n  /**\n   * 8-bit unsigned byte corresponding to <code>UNSIGNED_BYTE</code> and the type\n   * of an element in <code>Uint8Array</code>.\n   *\n   * @type {Number}\n   * @constant\n   */\n  UNSIGNED_BYTE: WebGLConstants.UNSIGNED_BYTE,\n\n  /**\n   * 16-bit unsigned short corresponding to <code>UNSIGNED_SHORT</code> and the type\n   * of an element in <code>Uint16Array</code>.\n   *\n   * @type {Number}\n   * @constant\n   */\n  UNSIGNED_SHORT: WebGLConstants.UNSIGNED_SHORT,\n\n  /**\n   * 32-bit unsigned int corresponding to <code>UNSIGNED_INT</code> and the type\n   * of an element in <code>Uint32Array</code>.\n   *\n   * @type {Number}\n   * @constant\n   */\n  UNSIGNED_INT: WebGLConstants.UNSIGNED_INT,\n};\n\n/**\n * Returns the size, in bytes, of the corresponding datatype.\n *\n * @param {IndexDatatype} indexDatatype The index datatype to get the size of.\n * @returns {Number} The size in bytes.\n *\n * @example\n * // Returns 2\n * var size = Cesium.IndexDatatype.getSizeInBytes(Cesium.IndexDatatype.UNSIGNED_SHORT);\n */\nIndexDatatype.getSizeInBytes = function (indexDatatype) {\n  switch (indexDatatype) {\n    case IndexDatatype.UNSIGNED_BYTE:\n      return Uint8Array.BYTES_PER_ELEMENT;\n    case IndexDatatype.UNSIGNED_SHORT:\n      return Uint16Array.BYTES_PER_ELEMENT;\n    case IndexDatatype.UNSIGNED_INT:\n      return Uint32Array.BYTES_PER_ELEMENT;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(\n    \"indexDatatype is required and must be a valid IndexDatatype constant.\"\n  );\n  //>>includeEnd('debug');\n};\n\n/**\n * Gets the datatype with a given size in bytes.\n *\n * @param {Number} sizeInBytes The size of a single index in bytes.\n * @returns {IndexDatatype} The index datatype with the given size.\n */\nIndexDatatype.fromSizeInBytes = function (sizeInBytes) {\n  switch (sizeInBytes) {\n    case 2:\n      return IndexDatatype.UNSIGNED_SHORT;\n    case 4:\n      return IndexDatatype.UNSIGNED_INT;\n    case 1:\n      return IndexDatatype.UNSIGNED_BYTE;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\n        \"Size in bytes cannot be mapped to an IndexDatatype\"\n      );\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Validates that the provided index datatype is a valid {@link IndexDatatype}.\n *\n * @param {IndexDatatype} indexDatatype The index datatype to validate.\n * @returns {Boolean} <code>true</code> if the provided index datatype is a valid value; otherwise, <code>false</code>.\n *\n * @example\n * if (!Cesium.IndexDatatype.validate(indexDatatype)) {\n *   throw new Cesium.DeveloperError('indexDatatype must be a valid value.');\n * }\n */\nIndexDatatype.validate = function (indexDatatype) {\n  return (\n    defined(indexDatatype) &&\n    (indexDatatype === IndexDatatype.UNSIGNED_BYTE ||\n      indexDatatype === IndexDatatype.UNSIGNED_SHORT ||\n      indexDatatype === IndexDatatype.UNSIGNED_INT)\n  );\n};\n\n/**\n * Creates a typed array that will store indices, using either <code><Uint16Array</code>\n * or <code>Uint32Array</code> depending on the number of vertices.\n *\n * @param {Number} numberOfVertices Number of vertices that the indices will reference.\n * @param {Number|Array} indicesLengthOrArray Passed through to the typed array constructor.\n * @returns {Uint16Array|Uint32Array} A <code>Uint16Array</code> or <code>Uint32Array</code> constructed with <code>indicesLengthOrArray</code>.\n *\n * @example\n * this.indices = Cesium.IndexDatatype.createTypedArray(positions.length / 3, numberOfIndices);\n */\nIndexDatatype.createTypedArray = function (\n  numberOfVertices,\n  indicesLengthOrArray\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(numberOfVertices)) {\n    throw new DeveloperError(\"numberOfVertices is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES) {\n    return new Uint32Array(indicesLengthOrArray);\n  }\n\n  return new Uint16Array(indicesLengthOrArray);\n};\n\n/**\n * Creates a typed array from a source array buffer.  The resulting typed array will store indices, using either <code><Uint16Array</code>\n * or <code>Uint32Array</code> depending on the number of vertices.\n *\n * @param {Number} numberOfVertices Number of vertices that the indices will reference.\n * @param {ArrayBuffer} sourceArray Passed through to the typed array constructor.\n * @param {Number} byteOffset Passed through to the typed array constructor.\n * @param {Number} length Passed through to the typed array constructor.\n * @returns {Uint16Array|Uint32Array} A <code>Uint16Array</code> or <code>Uint32Array</code> constructed with <code>sourceArray</code>, <code>byteOffset</code>, and <code>length</code>.\n *\n */\nIndexDatatype.createTypedArrayFromArrayBuffer = function (\n  numberOfVertices,\n  sourceArray,\n  byteOffset,\n  length\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(numberOfVertices)) {\n    throw new DeveloperError(\"numberOfVertices is required.\");\n  }\n  if (!defined(sourceArray)) {\n    throw new DeveloperError(\"sourceArray is required.\");\n  }\n  if (!defined(byteOffset)) {\n    throw new DeveloperError(\"byteOffset is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES) {\n    return new Uint32Array(sourceArray, byteOffset, length);\n  }\n\n  return new Uint16Array(sourceArray, byteOffset, length);\n};\nexport default Object.freeze(IndexDatatype);\n"]},"metadata":{},"sourceType":"module"}