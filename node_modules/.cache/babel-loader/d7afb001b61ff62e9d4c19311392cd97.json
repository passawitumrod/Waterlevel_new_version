{"ast":null,"code":"import AttributeCompression from \"../Core/AttributeCompression.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Plane from \"../Core/Plane.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport ClippingPlane from \"./ClippingPlane.js\";\n/**\n * Specifies a set of clipping planes. Clipping planes selectively disable rendering in a region on the\n * outside of the specified list of {@link ClippingPlane} objects for a single gltf model, 3D Tileset, or the globe.\n * <p>\n * In general the clipping planes' coordinates are relative to the object they're attached to, so a plane with distance set to 0 will clip\n * through the center of the object.\n * </p>\n * <p>\n * For 3D Tiles, the root tile's transform is used to position the clipping planes. If a transform is not defined, the root tile's {@link Cesium3DTile#boundingSphere} is used instead.\n * </p>\n *\n * @alias ClippingPlaneCollection\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {ClippingPlane[]} [options.planes=[]] An array of {@link ClippingPlane} objects used to selectively disable rendering on the outside of each plane.\n * @param {Boolean} [options.enabled=true] Determines whether the clipping planes are active.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix specifying an additional transform relative to the clipping planes original coordinate system.\n * @param {Boolean} [options.unionClippingRegions=false] If true, a region will be clipped if it is on the outside of any plane in the collection. Otherwise, a region will only be clipped if it is on the outside of every plane.\n * @param {Color} [options.edgeColor=Color.WHITE] The color applied to highlight the edge along which an object is clipped.\n * @param {Number} [options.edgeWidth=0.0] The width, in pixels, of the highlight applied to the edge along which an object is clipped.\n *\n * @demo {@link https://sandcastle.cesium.com/?src=3D%20Tiles%20Clipping%20Planes.html|Clipping 3D Tiles and glTF models.}\n * @demo {@link https://sandcastle.cesium.com/?src=Terrain%20Clipping%20Planes.html|Clipping the Globe.}\n *\n * @example\n * // This clipping plane's distance is positive, which means its normal\n * // is facing the origin. This will clip everything that is behind\n * // the plane, which is anything with y coordinate < -5.\n * var clippingPlanes = new Cesium.ClippingPlaneCollection({\n *     planes : [\n *         new Cesium.ClippingPlane(new Cesium.Cartesian3(0.0, 1.0, 0.0), 5.0)\n *     ],\n * });\n * // Create an entity and attach the ClippingPlaneCollection to the model.\n * var entity = viewer.entities.add({\n *     position : Cesium.Cartesian3.fromDegrees(-123.0744619, 44.0503706, 10000),\n *     model : {\n *         uri : 'model.gltf',\n *         minimumPixelSize : 128,\n *         maximumScale : 20000,\n *         clippingPlanes : clippingPlanes\n *     }\n * });\n * viewer.zoomTo(entity);\n */\n\nfunction ClippingPlaneCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  this._planes = []; // Do partial texture updates if just one plane is dirty.\n  // If many planes are dirty, refresh the entire texture.\n\n  this._dirtyIndex = -1;\n  this._multipleDirtyPlanes = false;\n  this._enabled = defaultValue(options.enabled, true);\n  /**\n   * The 4x4 transformation matrix specifying an additional transform relative to the clipping planes\n   * original coordinate system.\n   *\n   * @type {Matrix4}\n   * @default Matrix4.IDENTITY\n   */\n\n  this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));\n  /**\n   * The color applied to highlight the edge along which an object is clipped.\n   *\n   * @type {Color}\n   * @default Color.WHITE\n   */\n\n  this.edgeColor = Color.clone(defaultValue(options.edgeColor, Color.WHITE));\n  /**\n   * The width, in pixels, of the highlight applied to the edge along which an object is clipped.\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.edgeWidth = defaultValue(options.edgeWidth, 0.0);\n  /**\n   * An event triggered when a new clipping plane is added to the collection.  Event handlers\n   * are passed the new plane and the index at which it was added.\n   * @type {Event}\n   * @default Event()\n   */\n\n  this.planeAdded = new Event();\n  /**\n   * An event triggered when a new clipping plane is removed from the collection.  Event handlers\n   * are passed the new plane and the index from which it was removed.\n   * @type {Event}\n   * @default Event()\n   */\n\n  this.planeRemoved = new Event(); // If this ClippingPlaneCollection has an owner, only its owner should update or destroy it.\n  // This is because in a Cesium3DTileset multiple models may reference the tileset's ClippingPlaneCollection.\n\n  this._owner = undefined;\n  var unionClippingRegions = defaultValue(options.unionClippingRegions, false);\n  this._unionClippingRegions = unionClippingRegions;\n  this._testIntersection = unionClippingRegions ? unionIntersectFunction : defaultIntersectFunction;\n  this._uint8View = undefined;\n  this._float32View = undefined;\n  this._clippingPlanesTexture = undefined; // Add each ClippingPlane object.\n\n  var planes = options.planes;\n\n  if (defined(planes)) {\n    var planesLength = planes.length;\n\n    for (var i = 0; i < planesLength; ++i) {\n      this.add(planes[i]);\n    }\n  }\n}\n\nfunction unionIntersectFunction(value) {\n  return value === Intersect.OUTSIDE;\n}\n\nfunction defaultIntersectFunction(value) {\n  return value === Intersect.INSIDE;\n}\n\nObject.defineProperties(ClippingPlaneCollection.prototype, {\n  /**\n   * Returns the number of planes in this collection.  This is commonly used with\n   * {@link ClippingPlaneCollection#get} to iterate over all the planes\n   * in the collection.\n   *\n   * @memberof ClippingPlaneCollection.prototype\n   * @type {Number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._planes.length;\n    }\n  },\n\n  /**\n   * If true, a region will be clipped if it is on the outside of any plane in the\n   * collection. Otherwise, a region will only be clipped if it is on the\n   * outside of every plane.\n   *\n   * @memberof ClippingPlaneCollection.prototype\n   * @type {Boolean}\n   * @default false\n   */\n  unionClippingRegions: {\n    get: function () {\n      return this._unionClippingRegions;\n    },\n    set: function (value) {\n      if (this._unionClippingRegions === value) {\n        return;\n      }\n\n      this._unionClippingRegions = value;\n      this._testIntersection = value ? unionIntersectFunction : defaultIntersectFunction;\n    }\n  },\n\n  /**\n   * If true, clipping will be enabled.\n   *\n   * @memberof ClippingPlaneCollection.prototype\n   * @type {Boolean}\n   * @default true\n   */\n  enabled: {\n    get: function () {\n      return this._enabled;\n    },\n    set: function (value) {\n      if (this._enabled === value) {\n        return;\n      }\n\n      this._enabled = value;\n    }\n  },\n\n  /**\n   * Returns a texture containing packed, untransformed clipping planes.\n   *\n   * @memberof ClippingPlaneCollection.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  texture: {\n    get: function () {\n      return this._clippingPlanesTexture;\n    }\n  },\n\n  /**\n   * A reference to the ClippingPlaneCollection's owner, if any.\n   *\n   * @memberof ClippingPlaneCollection.prototype\n   * @readonly\n   * @private\n   */\n  owner: {\n    get: function () {\n      return this._owner;\n    }\n  },\n\n  /**\n   * Returns a Number encapsulating the state for this ClippingPlaneCollection.\n   *\n   * Clipping mode is encoded in the sign of the number, which is just the plane count.\n   * Used for checking if shader regeneration is necessary.\n   *\n   * @memberof ClippingPlaneCollection.prototype\n   * @returns {Number} A Number that describes the ClippingPlaneCollection's state.\n   * @readonly\n   * @private\n   */\n  clippingPlanesState: {\n    get: function () {\n      return this._unionClippingRegions ? this._planes.length : -this._planes.length;\n    }\n  }\n});\n\nfunction setIndexDirty(collection, index) {\n  // If there's already a different _dirtyIndex set, more than one plane has changed since update.\n  // Entire texture must be reloaded\n  collection._multipleDirtyPlanes = collection._multipleDirtyPlanes || collection._dirtyIndex !== -1 && collection._dirtyIndex !== index;\n  collection._dirtyIndex = index;\n}\n/**\n * Adds the specified {@link ClippingPlane} to the collection to be used to selectively disable rendering\n * on the outside of each plane. Use {@link ClippingPlaneCollection#unionClippingRegions} to modify\n * how modify the clipping behavior of multiple planes.\n *\n * @param {ClippingPlane} plane The ClippingPlane to add to the collection.\n *\n * @see ClippingPlaneCollection#unionClippingRegions\n * @see ClippingPlaneCollection#remove\n * @see ClippingPlaneCollection#removeAll\n */\n\n\nClippingPlaneCollection.prototype.add = function (plane) {\n  var newPlaneIndex = this._planes.length;\n  var that = this;\n\n  plane.onChangeCallback = function (index) {\n    setIndexDirty(that, index);\n  };\n\n  plane.index = newPlaneIndex;\n  setIndexDirty(this, newPlaneIndex);\n\n  this._planes.push(plane);\n\n  this.planeAdded.raiseEvent(plane, newPlaneIndex);\n};\n/**\n * Returns the plane in the collection at the specified index.  Indices are zero-based\n * and increase as planes are added.  Removing a plane shifts all planes after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link ClippingPlaneCollection#length} to iterate over all the planes\n * in the collection.\n *\n * @param {Number} index The zero-based index of the plane.\n * @returns {ClippingPlane} The ClippingPlane at the specified index.\n *\n * @see ClippingPlaneCollection#length\n */\n\n\nClippingPlaneCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index); //>>includeEnd('debug');\n\n  return this._planes[index];\n};\n\nfunction indexOf(planes, plane) {\n  var length = planes.length;\n\n  for (var i = 0; i < length; ++i) {\n    if (Plane.equals(planes[i], plane)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n/**\n * Checks whether this collection contains a ClippingPlane equal to the given ClippingPlane.\n *\n * @param {ClippingPlane} [clippingPlane] The ClippingPlane to check for.\n * @returns {Boolean} true if this collection contains the ClippingPlane, false otherwise.\n *\n * @see ClippingPlaneCollection#get\n */\n\n\nClippingPlaneCollection.prototype.contains = function (clippingPlane) {\n  return indexOf(this._planes, clippingPlane) !== -1;\n};\n/**\n * Removes the first occurrence of the given ClippingPlane from the collection.\n *\n * @param {ClippingPlane} clippingPlane\n * @returns {Boolean} <code>true</code> if the plane was removed; <code>false</code> if the plane was not found in the collection.\n *\n * @see ClippingPlaneCollection#add\n * @see ClippingPlaneCollection#contains\n * @see ClippingPlaneCollection#removeAll\n */\n\n\nClippingPlaneCollection.prototype.remove = function (clippingPlane) {\n  var planes = this._planes;\n  var index = indexOf(planes, clippingPlane);\n\n  if (index === -1) {\n    return false;\n  } // Unlink this ClippingPlaneCollection from the ClippingPlane\n\n\n  if (clippingPlane instanceof ClippingPlane) {\n    clippingPlane.onChangeCallback = undefined;\n    clippingPlane.index = -1;\n  } // Shift and update indices\n\n\n  var length = planes.length - 1;\n\n  for (var i = index; i < length; ++i) {\n    var planeToKeep = planes[i + 1];\n    planes[i] = planeToKeep;\n\n    if (planeToKeep instanceof ClippingPlane) {\n      planeToKeep.index = i;\n    }\n  } // Indicate planes texture is dirty\n\n\n  this._multipleDirtyPlanes = true;\n  planes.length = length;\n  this.planeRemoved.raiseEvent(clippingPlane, index);\n  return true;\n};\n/**\n * Removes all planes from the collection.\n *\n * @see ClippingPlaneCollection#add\n * @see ClippingPlaneCollection#remove\n */\n\n\nClippingPlaneCollection.prototype.removeAll = function () {\n  // Dereference this ClippingPlaneCollection from all ClippingPlanes\n  var planes = this._planes;\n  var planesCount = planes.length;\n\n  for (var i = 0; i < planesCount; ++i) {\n    var plane = planes[i];\n\n    if (plane instanceof ClippingPlane) {\n      plane.onChangeCallback = undefined;\n      plane.index = -1;\n    }\n\n    this.planeRemoved.raiseEvent(plane, i);\n  }\n\n  this._multipleDirtyPlanes = true;\n  this._planes = [];\n};\n\nvar distanceEncodeScratch = new Cartesian4();\nvar oct32EncodeScratch = new Cartesian4();\n\nfunction packPlanesAsUint8(clippingPlaneCollection, startIndex, endIndex) {\n  var uint8View = clippingPlaneCollection._uint8View;\n  var planes = clippingPlaneCollection._planes;\n  var byteIndex = 0;\n\n  for (var i = startIndex; i < endIndex; ++i) {\n    var plane = planes[i];\n    var oct32Normal = AttributeCompression.octEncodeToCartesian4(plane.normal, oct32EncodeScratch);\n    uint8View[byteIndex] = oct32Normal.x;\n    uint8View[byteIndex + 1] = oct32Normal.y;\n    uint8View[byteIndex + 2] = oct32Normal.z;\n    uint8View[byteIndex + 3] = oct32Normal.w;\n    var encodedDistance = Cartesian4.packFloat(plane.distance, distanceEncodeScratch);\n    uint8View[byteIndex + 4] = encodedDistance.x;\n    uint8View[byteIndex + 5] = encodedDistance.y;\n    uint8View[byteIndex + 6] = encodedDistance.z;\n    uint8View[byteIndex + 7] = encodedDistance.w;\n    byteIndex += 8;\n  }\n} // Pack starting at the beginning of the buffer to allow partial update\n\n\nfunction packPlanesAsFloats(clippingPlaneCollection, startIndex, endIndex) {\n  var float32View = clippingPlaneCollection._float32View;\n  var planes = clippingPlaneCollection._planes;\n  var floatIndex = 0;\n\n  for (var i = startIndex; i < endIndex; ++i) {\n    var plane = planes[i];\n    var normal = plane.normal;\n    float32View[floatIndex] = normal.x;\n    float32View[floatIndex + 1] = normal.y;\n    float32View[floatIndex + 2] = normal.z;\n    float32View[floatIndex + 3] = plane.distance;\n    floatIndex += 4; // each plane is 4 floats\n  }\n}\n\nfunction computeTextureResolution(pixelsNeeded, result) {\n  var maxSize = ContextLimits.maximumTextureSize;\n  result.x = Math.min(pixelsNeeded, maxSize);\n  result.y = Math.ceil(pixelsNeeded / result.x);\n  return result;\n}\n\nvar textureResolutionScratch = new Cartesian2();\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * build the resources for clipping planes.\n * <p>\n * Do not call this function directly.\n * </p>\n */\n\nClippingPlaneCollection.prototype.update = function (frameState) {\n  var clippingPlanesTexture = this._clippingPlanesTexture;\n  var context = frameState.context;\n  var useFloatTexture = ClippingPlaneCollection.useFloatTexture(context); // Compute texture requirements for current planes\n  // In RGBA FLOAT, A plane is 4 floats packed to a RGBA.\n  // In RGBA UNSIGNED_BYTE, A plane is a float in [0, 1) packed to RGBA and an Oct32 quantized normal,\n  // so 8 bits or 2 pixels in RGBA.\n\n  var pixelsNeeded = useFloatTexture ? this.length : this.length * 2;\n\n  if (defined(clippingPlanesTexture)) {\n    var currentPixelCount = clippingPlanesTexture.width * clippingPlanesTexture.height; // Recreate the texture to double current requirement if it isn't big enough or is 4 times larger than it needs to be.\n    // Optimization note: this isn't exactly the classic resizeable array algorithm\n    // * not necessarily checking for resize after each add/remove operation\n    // * random-access deletes instead of just pops\n    // * alloc ops likely more expensive than demonstrable via big-O analysis\n\n    if (currentPixelCount < pixelsNeeded || pixelsNeeded < 0.25 * currentPixelCount) {\n      clippingPlanesTexture.destroy();\n      clippingPlanesTexture = undefined;\n      this._clippingPlanesTexture = undefined;\n    }\n  } // If there are no clipping planes, there's nothing to update.\n\n\n  if (this.length === 0) {\n    return;\n  }\n\n  if (!defined(clippingPlanesTexture)) {\n    var requiredResolution = computeTextureResolution(pixelsNeeded, textureResolutionScratch); // Allocate twice as much space as needed to avoid frequent texture reallocation.\n    // Allocate in the Y direction, since texture may be as wide as context texture support.\n\n    requiredResolution.y *= 2;\n\n    if (useFloatTexture) {\n      clippingPlanesTexture = new Texture({\n        context: context,\n        width: requiredResolution.x,\n        height: requiredResolution.y,\n        pixelFormat: PixelFormat.RGBA,\n        pixelDatatype: PixelDatatype.FLOAT,\n        sampler: Sampler.NEAREST,\n        flipY: false\n      });\n      this._float32View = new Float32Array(requiredResolution.x * requiredResolution.y * 4);\n    } else {\n      clippingPlanesTexture = new Texture({\n        context: context,\n        width: requiredResolution.x,\n        height: requiredResolution.y,\n        pixelFormat: PixelFormat.RGBA,\n        pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n        sampler: Sampler.NEAREST,\n        flipY: false\n      });\n      this._uint8View = new Uint8Array(requiredResolution.x * requiredResolution.y * 4);\n    }\n\n    this._clippingPlanesTexture = clippingPlanesTexture;\n    this._multipleDirtyPlanes = true;\n  }\n\n  var dirtyIndex = this._dirtyIndex;\n\n  if (!this._multipleDirtyPlanes && dirtyIndex === -1) {\n    return;\n  }\n\n  if (!this._multipleDirtyPlanes) {\n    // partial updates possible\n    var offsetX = 0;\n    var offsetY = 0;\n\n    if (useFloatTexture) {\n      offsetY = Math.floor(dirtyIndex / clippingPlanesTexture.width);\n      offsetX = Math.floor(dirtyIndex - offsetY * clippingPlanesTexture.width);\n      packPlanesAsFloats(this, dirtyIndex, dirtyIndex + 1);\n      clippingPlanesTexture.copyFrom({\n        width: 1,\n        height: 1,\n        arrayBufferView: this._float32View\n      }, offsetX, offsetY);\n    } else {\n      offsetY = Math.floor(dirtyIndex * 2 / clippingPlanesTexture.width);\n      offsetX = Math.floor(dirtyIndex * 2 - offsetY * clippingPlanesTexture.width);\n      packPlanesAsUint8(this, dirtyIndex, dirtyIndex + 1);\n      clippingPlanesTexture.copyFrom({\n        width: 2,\n        height: 1,\n        arrayBufferView: this._uint8View\n      }, offsetX, offsetY);\n    }\n  } else if (useFloatTexture) {\n    packPlanesAsFloats(this, 0, this._planes.length);\n    clippingPlanesTexture.copyFrom({\n      width: clippingPlanesTexture.width,\n      height: clippingPlanesTexture.height,\n      arrayBufferView: this._float32View\n    });\n  } else {\n    packPlanesAsUint8(this, 0, this._planes.length);\n    clippingPlanesTexture.copyFrom({\n      width: clippingPlanesTexture.width,\n      height: clippingPlanesTexture.height,\n      arrayBufferView: this._uint8View\n    });\n  }\n\n  this._multipleDirtyPlanes = false;\n  this._dirtyIndex = -1;\n};\n\nvar scratchMatrix = new Matrix4();\nvar scratchPlane = new Plane(Cartesian3.UNIT_X, 0.0);\n/**\n * Determines the type intersection with the planes of this ClippingPlaneCollection instance and the specified {@link TileBoundingVolume}.\n * @private\n *\n * @param {Object} tileBoundingVolume The volume to determine the intersection with the planes.\n * @param {Matrix4} [transform] An optional, additional matrix to transform the plane to world coordinates.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire volume is on the side of the planes\n *                      the normal is pointing and should be entirely rendered, {@link Intersect.OUTSIDE}\n *                      if the entire volume is on the opposite side and should be clipped, and\n *                      {@link Intersect.INTERSECTING} if the volume intersects the planes.\n */\n\nClippingPlaneCollection.prototype.computeIntersectionWithBoundingVolume = function (tileBoundingVolume, transform) {\n  var planes = this._planes;\n  var length = planes.length;\n  var modelMatrix = this.modelMatrix;\n\n  if (defined(transform)) {\n    modelMatrix = Matrix4.multiply(transform, modelMatrix, scratchMatrix);\n  } // If the collection is not set to union the clipping regions, the volume must be outside of all planes to be\n  // considered completely clipped. If the collection is set to union the clipping regions, if the volume can be\n  // outside any the planes, it is considered completely clipped.\n  // Lastly, if not completely clipped, if any plane is intersecting, more calculations must be performed.\n\n\n  var intersection = Intersect.INSIDE;\n\n  if (!this.unionClippingRegions && length > 0) {\n    intersection = Intersect.OUTSIDE;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    var plane = planes[i];\n    Plane.transform(plane, modelMatrix, scratchPlane); // ClippingPlane can be used for Plane math\n\n    var value = tileBoundingVolume.intersectPlane(scratchPlane);\n\n    if (value === Intersect.INTERSECTING) {\n      intersection = value;\n    } else if (this._testIntersection(value)) {\n      return value;\n    }\n  }\n\n  return intersection;\n};\n/**\n * Sets the owner for the input ClippingPlaneCollection if there wasn't another owner.\n * Destroys the owner's previous ClippingPlaneCollection if setting is successful.\n *\n * @param {ClippingPlaneCollection} [clippingPlaneCollection] A ClippingPlaneCollection (or undefined) being attached to an object\n * @param {Object} owner An Object that should receive the new ClippingPlaneCollection\n * @param {String} key The Key for the Object to reference the ClippingPlaneCollection\n * @private\n */\n\n\nClippingPlaneCollection.setOwner = function (clippingPlaneCollection, owner, key) {\n  // Don't destroy the ClippingPlaneCollection if it is already owned by newOwner\n  if (clippingPlaneCollection === owner[key]) {\n    return;\n  } // Destroy the existing ClippingPlaneCollection, if any\n\n\n  owner[key] = owner[key] && owner[key].destroy();\n\n  if (defined(clippingPlaneCollection)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (defined(clippingPlaneCollection._owner)) {\n      throw new DeveloperError(\"ClippingPlaneCollection should only be assigned to one object\");\n    } //>>includeEnd('debug');\n\n\n    clippingPlaneCollection._owner = owner;\n    owner[key] = clippingPlaneCollection;\n  }\n};\n/**\n * Function for checking if the context will allow clipping planes with floating point textures.\n *\n * @param {Context} context The Context that will contain clipped objects and clipping textures.\n * @returns {Boolean} <code>true</code> if floating point textures can be used for clipping planes.\n * @private\n */\n\n\nClippingPlaneCollection.useFloatTexture = function (context) {\n  return context.floatingPointTexture;\n};\n/**\n * Function for getting the clipping plane collection's texture resolution.\n * If the ClippingPlaneCollection hasn't been updated, returns the resolution that will be\n * allocated based on the current plane count.\n *\n * @param {ClippingPlaneCollection} clippingPlaneCollection The clipping plane collection\n * @param {Context} context The rendering context\n * @param {Cartesian2} result A Cartesian2 for the result.\n * @returns {Cartesian2} The required resolution.\n * @private\n */\n\n\nClippingPlaneCollection.getTextureResolution = function (clippingPlaneCollection, context, result) {\n  var texture = clippingPlaneCollection.texture;\n\n  if (defined(texture)) {\n    result.x = texture.width;\n    result.y = texture.height;\n    return result;\n  }\n\n  var pixelsNeeded = ClippingPlaneCollection.useFloatTexture(context) ? clippingPlaneCollection.length : clippingPlaneCollection.length * 2;\n  var requiredResolution = computeTextureResolution(pixelsNeeded, result); // Allocate twice as much space as needed to avoid frequent texture reallocation.\n\n  requiredResolution.y *= 2;\n  return requiredResolution;\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ClippingPlaneCollection#destroy\n */\n\n\nClippingPlaneCollection.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * clippingPlanes = clippingPlanes && clippingPlanes .destroy();\n *\n * @see ClippingPlaneCollection#isDestroyed\n */\n\n\nClippingPlaneCollection.prototype.destroy = function () {\n  this._clippingPlanesTexture = this._clippingPlanesTexture && this._clippingPlanesTexture.destroy();\n  return destroyObject(this);\n};\n\nexport default ClippingPlaneCollection;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/ClippingPlaneCollection.js"],"names":["AttributeCompression","Cartesian2","Cartesian3","Cartesian4","Check","Color","defaultValue","defined","destroyObject","DeveloperError","Event","Intersect","Matrix4","PixelFormat","Plane","ContextLimits","PixelDatatype","Sampler","Texture","ClippingPlane","ClippingPlaneCollection","options","EMPTY_OBJECT","_planes","_dirtyIndex","_multipleDirtyPlanes","_enabled","enabled","modelMatrix","clone","IDENTITY","edgeColor","WHITE","edgeWidth","planeAdded","planeRemoved","_owner","undefined","unionClippingRegions","_unionClippingRegions","_testIntersection","unionIntersectFunction","defaultIntersectFunction","_uint8View","_float32View","_clippingPlanesTexture","planes","planesLength","length","i","add","value","OUTSIDE","INSIDE","Object","defineProperties","prototype","get","set","texture","owner","clippingPlanesState","setIndexDirty","collection","index","plane","newPlaneIndex","that","onChangeCallback","push","raiseEvent","typeOf","number","indexOf","equals","contains","clippingPlane","remove","planeToKeep","removeAll","planesCount","distanceEncodeScratch","oct32EncodeScratch","packPlanesAsUint8","clippingPlaneCollection","startIndex","endIndex","uint8View","byteIndex","oct32Normal","octEncodeToCartesian4","normal","x","y","z","w","encodedDistance","packFloat","distance","packPlanesAsFloats","float32View","floatIndex","computeTextureResolution","pixelsNeeded","result","maxSize","maximumTextureSize","Math","min","ceil","textureResolutionScratch","update","frameState","clippingPlanesTexture","context","useFloatTexture","currentPixelCount","width","height","destroy","requiredResolution","pixelFormat","RGBA","pixelDatatype","FLOAT","sampler","NEAREST","flipY","Float32Array","UNSIGNED_BYTE","Uint8Array","dirtyIndex","offsetX","offsetY","floor","copyFrom","arrayBufferView","scratchMatrix","scratchPlane","UNIT_X","computeIntersectionWithBoundingVolume","tileBoundingVolume","transform","multiply","intersection","intersectPlane","INTERSECTING","setOwner","key","floatingPointTexture","getTextureResolution","isDestroyed"],"mappings":"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","sourcesContent":["import AttributeCompression from \"../Core/AttributeCompression.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Plane from \"../Core/Plane.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport ClippingPlane from \"./ClippingPlane.js\";\n\n/**\n * Specifies a set of clipping planes. Clipping planes selectively disable rendering in a region on the\n * outside of the specified list of {@link ClippingPlane} objects for a single gltf model, 3D Tileset, or the globe.\n * <p>\n * In general the clipping planes' coordinates are relative to the object they're attached to, so a plane with distance set to 0 will clip\n * through the center of the object.\n * </p>\n * <p>\n * For 3D Tiles, the root tile's transform is used to position the clipping planes. If a transform is not defined, the root tile's {@link Cesium3DTile#boundingSphere} is used instead.\n * </p>\n *\n * @alias ClippingPlaneCollection\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {ClippingPlane[]} [options.planes=[]] An array of {@link ClippingPlane} objects used to selectively disable rendering on the outside of each plane.\n * @param {Boolean} [options.enabled=true] Determines whether the clipping planes are active.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix specifying an additional transform relative to the clipping planes original coordinate system.\n * @param {Boolean} [options.unionClippingRegions=false] If true, a region will be clipped if it is on the outside of any plane in the collection. Otherwise, a region will only be clipped if it is on the outside of every plane.\n * @param {Color} [options.edgeColor=Color.WHITE] The color applied to highlight the edge along which an object is clipped.\n * @param {Number} [options.edgeWidth=0.0] The width, in pixels, of the highlight applied to the edge along which an object is clipped.\n *\n * @demo {@link https://sandcastle.cesium.com/?src=3D%20Tiles%20Clipping%20Planes.html|Clipping 3D Tiles and glTF models.}\n * @demo {@link https://sandcastle.cesium.com/?src=Terrain%20Clipping%20Planes.html|Clipping the Globe.}\n *\n * @example\n * // This clipping plane's distance is positive, which means its normal\n * // is facing the origin. This will clip everything that is behind\n * // the plane, which is anything with y coordinate < -5.\n * var clippingPlanes = new Cesium.ClippingPlaneCollection({\n *     planes : [\n *         new Cesium.ClippingPlane(new Cesium.Cartesian3(0.0, 1.0, 0.0), 5.0)\n *     ],\n * });\n * // Create an entity and attach the ClippingPlaneCollection to the model.\n * var entity = viewer.entities.add({\n *     position : Cesium.Cartesian3.fromDegrees(-123.0744619, 44.0503706, 10000),\n *     model : {\n *         uri : 'model.gltf',\n *         minimumPixelSize : 128,\n *         maximumScale : 20000,\n *         clippingPlanes : clippingPlanes\n *     }\n * });\n * viewer.zoomTo(entity);\n */\nfunction ClippingPlaneCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._planes = [];\n\n  // Do partial texture updates if just one plane is dirty.\n  // If many planes are dirty, refresh the entire texture.\n  this._dirtyIndex = -1;\n  this._multipleDirtyPlanes = false;\n\n  this._enabled = defaultValue(options.enabled, true);\n\n  /**\n   * The 4x4 transformation matrix specifying an additional transform relative to the clipping planes\n   * original coordinate system.\n   *\n   * @type {Matrix4}\n   * @default Matrix4.IDENTITY\n   */\n  this.modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY)\n  );\n\n  /**\n   * The color applied to highlight the edge along which an object is clipped.\n   *\n   * @type {Color}\n   * @default Color.WHITE\n   */\n  this.edgeColor = Color.clone(defaultValue(options.edgeColor, Color.WHITE));\n\n  /**\n   * The width, in pixels, of the highlight applied to the edge along which an object is clipped.\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n  this.edgeWidth = defaultValue(options.edgeWidth, 0.0);\n\n  /**\n   * An event triggered when a new clipping plane is added to the collection.  Event handlers\n   * are passed the new plane and the index at which it was added.\n   * @type {Event}\n   * @default Event()\n   */\n  this.planeAdded = new Event();\n\n  /**\n   * An event triggered when a new clipping plane is removed from the collection.  Event handlers\n   * are passed the new plane and the index from which it was removed.\n   * @type {Event}\n   * @default Event()\n   */\n  this.planeRemoved = new Event();\n\n  // If this ClippingPlaneCollection has an owner, only its owner should update or destroy it.\n  // This is because in a Cesium3DTileset multiple models may reference the tileset's ClippingPlaneCollection.\n  this._owner = undefined;\n\n  var unionClippingRegions = defaultValue(options.unionClippingRegions, false);\n  this._unionClippingRegions = unionClippingRegions;\n  this._testIntersection = unionClippingRegions\n    ? unionIntersectFunction\n    : defaultIntersectFunction;\n\n  this._uint8View = undefined;\n  this._float32View = undefined;\n\n  this._clippingPlanesTexture = undefined;\n\n  // Add each ClippingPlane object.\n  var planes = options.planes;\n  if (defined(planes)) {\n    var planesLength = planes.length;\n    for (var i = 0; i < planesLength; ++i) {\n      this.add(planes[i]);\n    }\n  }\n}\n\nfunction unionIntersectFunction(value) {\n  return value === Intersect.OUTSIDE;\n}\n\nfunction defaultIntersectFunction(value) {\n  return value === Intersect.INSIDE;\n}\n\nObject.defineProperties(ClippingPlaneCollection.prototype, {\n  /**\n   * Returns the number of planes in this collection.  This is commonly used with\n   * {@link ClippingPlaneCollection#get} to iterate over all the planes\n   * in the collection.\n   *\n   * @memberof ClippingPlaneCollection.prototype\n   * @type {Number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._planes.length;\n    },\n  },\n\n  /**\n   * If true, a region will be clipped if it is on the outside of any plane in the\n   * collection. Otherwise, a region will only be clipped if it is on the\n   * outside of every plane.\n   *\n   * @memberof ClippingPlaneCollection.prototype\n   * @type {Boolean}\n   * @default false\n   */\n  unionClippingRegions: {\n    get: function () {\n      return this._unionClippingRegions;\n    },\n    set: function (value) {\n      if (this._unionClippingRegions === value) {\n        return;\n      }\n      this._unionClippingRegions = value;\n      this._testIntersection = value\n        ? unionIntersectFunction\n        : defaultIntersectFunction;\n    },\n  },\n\n  /**\n   * If true, clipping will be enabled.\n   *\n   * @memberof ClippingPlaneCollection.prototype\n   * @type {Boolean}\n   * @default true\n   */\n  enabled: {\n    get: function () {\n      return this._enabled;\n    },\n    set: function (value) {\n      if (this._enabled === value) {\n        return;\n      }\n      this._enabled = value;\n    },\n  },\n\n  /**\n   * Returns a texture containing packed, untransformed clipping planes.\n   *\n   * @memberof ClippingPlaneCollection.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  texture: {\n    get: function () {\n      return this._clippingPlanesTexture;\n    },\n  },\n\n  /**\n   * A reference to the ClippingPlaneCollection's owner, if any.\n   *\n   * @memberof ClippingPlaneCollection.prototype\n   * @readonly\n   * @private\n   */\n  owner: {\n    get: function () {\n      return this._owner;\n    },\n  },\n\n  /**\n   * Returns a Number encapsulating the state for this ClippingPlaneCollection.\n   *\n   * Clipping mode is encoded in the sign of the number, which is just the plane count.\n   * Used for checking if shader regeneration is necessary.\n   *\n   * @memberof ClippingPlaneCollection.prototype\n   * @returns {Number} A Number that describes the ClippingPlaneCollection's state.\n   * @readonly\n   * @private\n   */\n  clippingPlanesState: {\n    get: function () {\n      return this._unionClippingRegions\n        ? this._planes.length\n        : -this._planes.length;\n    },\n  },\n});\n\nfunction setIndexDirty(collection, index) {\n  // If there's already a different _dirtyIndex set, more than one plane has changed since update.\n  // Entire texture must be reloaded\n  collection._multipleDirtyPlanes =\n    collection._multipleDirtyPlanes ||\n    (collection._dirtyIndex !== -1 && collection._dirtyIndex !== index);\n  collection._dirtyIndex = index;\n}\n\n/**\n * Adds the specified {@link ClippingPlane} to the collection to be used to selectively disable rendering\n * on the outside of each plane. Use {@link ClippingPlaneCollection#unionClippingRegions} to modify\n * how modify the clipping behavior of multiple planes.\n *\n * @param {ClippingPlane} plane The ClippingPlane to add to the collection.\n *\n * @see ClippingPlaneCollection#unionClippingRegions\n * @see ClippingPlaneCollection#remove\n * @see ClippingPlaneCollection#removeAll\n */\nClippingPlaneCollection.prototype.add = function (plane) {\n  var newPlaneIndex = this._planes.length;\n\n  var that = this;\n  plane.onChangeCallback = function (index) {\n    setIndexDirty(that, index);\n  };\n  plane.index = newPlaneIndex;\n\n  setIndexDirty(this, newPlaneIndex);\n  this._planes.push(plane);\n  this.planeAdded.raiseEvent(plane, newPlaneIndex);\n};\n\n/**\n * Returns the plane in the collection at the specified index.  Indices are zero-based\n * and increase as planes are added.  Removing a plane shifts all planes after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link ClippingPlaneCollection#length} to iterate over all the planes\n * in the collection.\n *\n * @param {Number} index The zero-based index of the plane.\n * @returns {ClippingPlane} The ClippingPlane at the specified index.\n *\n * @see ClippingPlaneCollection#length\n */\nClippingPlaneCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  //>>includeEnd('debug');\n\n  return this._planes[index];\n};\n\nfunction indexOf(planes, plane) {\n  var length = planes.length;\n  for (var i = 0; i < length; ++i) {\n    if (Plane.equals(planes[i], plane)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n/**\n * Checks whether this collection contains a ClippingPlane equal to the given ClippingPlane.\n *\n * @param {ClippingPlane} [clippingPlane] The ClippingPlane to check for.\n * @returns {Boolean} true if this collection contains the ClippingPlane, false otherwise.\n *\n * @see ClippingPlaneCollection#get\n */\nClippingPlaneCollection.prototype.contains = function (clippingPlane) {\n  return indexOf(this._planes, clippingPlane) !== -1;\n};\n\n/**\n * Removes the first occurrence of the given ClippingPlane from the collection.\n *\n * @param {ClippingPlane} clippingPlane\n * @returns {Boolean} <code>true</code> if the plane was removed; <code>false</code> if the plane was not found in the collection.\n *\n * @see ClippingPlaneCollection#add\n * @see ClippingPlaneCollection#contains\n * @see ClippingPlaneCollection#removeAll\n */\nClippingPlaneCollection.prototype.remove = function (clippingPlane) {\n  var planes = this._planes;\n  var index = indexOf(planes, clippingPlane);\n\n  if (index === -1) {\n    return false;\n  }\n\n  // Unlink this ClippingPlaneCollection from the ClippingPlane\n  if (clippingPlane instanceof ClippingPlane) {\n    clippingPlane.onChangeCallback = undefined;\n    clippingPlane.index = -1;\n  }\n\n  // Shift and update indices\n  var length = planes.length - 1;\n  for (var i = index; i < length; ++i) {\n    var planeToKeep = planes[i + 1];\n    planes[i] = planeToKeep;\n    if (planeToKeep instanceof ClippingPlane) {\n      planeToKeep.index = i;\n    }\n  }\n\n  // Indicate planes texture is dirty\n  this._multipleDirtyPlanes = true;\n  planes.length = length;\n\n  this.planeRemoved.raiseEvent(clippingPlane, index);\n\n  return true;\n};\n\n/**\n * Removes all planes from the collection.\n *\n * @see ClippingPlaneCollection#add\n * @see ClippingPlaneCollection#remove\n */\nClippingPlaneCollection.prototype.removeAll = function () {\n  // Dereference this ClippingPlaneCollection from all ClippingPlanes\n  var planes = this._planes;\n  var planesCount = planes.length;\n  for (var i = 0; i < planesCount; ++i) {\n    var plane = planes[i];\n    if (plane instanceof ClippingPlane) {\n      plane.onChangeCallback = undefined;\n      plane.index = -1;\n    }\n    this.planeRemoved.raiseEvent(plane, i);\n  }\n  this._multipleDirtyPlanes = true;\n  this._planes = [];\n};\n\nvar distanceEncodeScratch = new Cartesian4();\nvar oct32EncodeScratch = new Cartesian4();\nfunction packPlanesAsUint8(clippingPlaneCollection, startIndex, endIndex) {\n  var uint8View = clippingPlaneCollection._uint8View;\n  var planes = clippingPlaneCollection._planes;\n  var byteIndex = 0;\n  for (var i = startIndex; i < endIndex; ++i) {\n    var plane = planes[i];\n\n    var oct32Normal = AttributeCompression.octEncodeToCartesian4(\n      plane.normal,\n      oct32EncodeScratch\n    );\n    uint8View[byteIndex] = oct32Normal.x;\n    uint8View[byteIndex + 1] = oct32Normal.y;\n    uint8View[byteIndex + 2] = oct32Normal.z;\n    uint8View[byteIndex + 3] = oct32Normal.w;\n\n    var encodedDistance = Cartesian4.packFloat(\n      plane.distance,\n      distanceEncodeScratch\n    );\n    uint8View[byteIndex + 4] = encodedDistance.x;\n    uint8View[byteIndex + 5] = encodedDistance.y;\n    uint8View[byteIndex + 6] = encodedDistance.z;\n    uint8View[byteIndex + 7] = encodedDistance.w;\n\n    byteIndex += 8;\n  }\n}\n\n// Pack starting at the beginning of the buffer to allow partial update\nfunction packPlanesAsFloats(clippingPlaneCollection, startIndex, endIndex) {\n  var float32View = clippingPlaneCollection._float32View;\n  var planes = clippingPlaneCollection._planes;\n\n  var floatIndex = 0;\n  for (var i = startIndex; i < endIndex; ++i) {\n    var plane = planes[i];\n    var normal = plane.normal;\n\n    float32View[floatIndex] = normal.x;\n    float32View[floatIndex + 1] = normal.y;\n    float32View[floatIndex + 2] = normal.z;\n    float32View[floatIndex + 3] = plane.distance;\n\n    floatIndex += 4; // each plane is 4 floats\n  }\n}\n\nfunction computeTextureResolution(pixelsNeeded, result) {\n  var maxSize = ContextLimits.maximumTextureSize;\n  result.x = Math.min(pixelsNeeded, maxSize);\n  result.y = Math.ceil(pixelsNeeded / result.x);\n  return result;\n}\n\nvar textureResolutionScratch = new Cartesian2();\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * build the resources for clipping planes.\n * <p>\n * Do not call this function directly.\n * </p>\n */\nClippingPlaneCollection.prototype.update = function (frameState) {\n  var clippingPlanesTexture = this._clippingPlanesTexture;\n  var context = frameState.context;\n  var useFloatTexture = ClippingPlaneCollection.useFloatTexture(context);\n\n  // Compute texture requirements for current planes\n  // In RGBA FLOAT, A plane is 4 floats packed to a RGBA.\n  // In RGBA UNSIGNED_BYTE, A plane is a float in [0, 1) packed to RGBA and an Oct32 quantized normal,\n  // so 8 bits or 2 pixels in RGBA.\n  var pixelsNeeded = useFloatTexture ? this.length : this.length * 2;\n\n  if (defined(clippingPlanesTexture)) {\n    var currentPixelCount =\n      clippingPlanesTexture.width * clippingPlanesTexture.height;\n    // Recreate the texture to double current requirement if it isn't big enough or is 4 times larger than it needs to be.\n    // Optimization note: this isn't exactly the classic resizeable array algorithm\n    // * not necessarily checking for resize after each add/remove operation\n    // * random-access deletes instead of just pops\n    // * alloc ops likely more expensive than demonstrable via big-O analysis\n    if (\n      currentPixelCount < pixelsNeeded ||\n      pixelsNeeded < 0.25 * currentPixelCount\n    ) {\n      clippingPlanesTexture.destroy();\n      clippingPlanesTexture = undefined;\n      this._clippingPlanesTexture = undefined;\n    }\n  }\n\n  // If there are no clipping planes, there's nothing to update.\n  if (this.length === 0) {\n    return;\n  }\n\n  if (!defined(clippingPlanesTexture)) {\n    var requiredResolution = computeTextureResolution(\n      pixelsNeeded,\n      textureResolutionScratch\n    );\n    // Allocate twice as much space as needed to avoid frequent texture reallocation.\n    // Allocate in the Y direction, since texture may be as wide as context texture support.\n    requiredResolution.y *= 2;\n\n    if (useFloatTexture) {\n      clippingPlanesTexture = new Texture({\n        context: context,\n        width: requiredResolution.x,\n        height: requiredResolution.y,\n        pixelFormat: PixelFormat.RGBA,\n        pixelDatatype: PixelDatatype.FLOAT,\n        sampler: Sampler.NEAREST,\n        flipY: false,\n      });\n      this._float32View = new Float32Array(\n        requiredResolution.x * requiredResolution.y * 4\n      );\n    } else {\n      clippingPlanesTexture = new Texture({\n        context: context,\n        width: requiredResolution.x,\n        height: requiredResolution.y,\n        pixelFormat: PixelFormat.RGBA,\n        pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n        sampler: Sampler.NEAREST,\n        flipY: false,\n      });\n      this._uint8View = new Uint8Array(\n        requiredResolution.x * requiredResolution.y * 4\n      );\n    }\n\n    this._clippingPlanesTexture = clippingPlanesTexture;\n    this._multipleDirtyPlanes = true;\n  }\n\n  var dirtyIndex = this._dirtyIndex;\n  if (!this._multipleDirtyPlanes && dirtyIndex === -1) {\n    return;\n  }\n  if (!this._multipleDirtyPlanes) {\n    // partial updates possible\n    var offsetX = 0;\n    var offsetY = 0;\n    if (useFloatTexture) {\n      offsetY = Math.floor(dirtyIndex / clippingPlanesTexture.width);\n      offsetX = Math.floor(dirtyIndex - offsetY * clippingPlanesTexture.width);\n\n      packPlanesAsFloats(this, dirtyIndex, dirtyIndex + 1);\n      clippingPlanesTexture.copyFrom(\n        {\n          width: 1,\n          height: 1,\n          arrayBufferView: this._float32View,\n        },\n        offsetX,\n        offsetY\n      );\n    } else {\n      offsetY = Math.floor((dirtyIndex * 2) / clippingPlanesTexture.width);\n      offsetX = Math.floor(\n        dirtyIndex * 2 - offsetY * clippingPlanesTexture.width\n      );\n      packPlanesAsUint8(this, dirtyIndex, dirtyIndex + 1);\n      clippingPlanesTexture.copyFrom(\n        {\n          width: 2,\n          height: 1,\n          arrayBufferView: this._uint8View,\n        },\n        offsetX,\n        offsetY\n      );\n    }\n  } else if (useFloatTexture) {\n    packPlanesAsFloats(this, 0, this._planes.length);\n    clippingPlanesTexture.copyFrom({\n      width: clippingPlanesTexture.width,\n      height: clippingPlanesTexture.height,\n      arrayBufferView: this._float32View,\n    });\n  } else {\n    packPlanesAsUint8(this, 0, this._planes.length);\n    clippingPlanesTexture.copyFrom({\n      width: clippingPlanesTexture.width,\n      height: clippingPlanesTexture.height,\n      arrayBufferView: this._uint8View,\n    });\n  }\n\n  this._multipleDirtyPlanes = false;\n  this._dirtyIndex = -1;\n};\n\nvar scratchMatrix = new Matrix4();\nvar scratchPlane = new Plane(Cartesian3.UNIT_X, 0.0);\n/**\n * Determines the type intersection with the planes of this ClippingPlaneCollection instance and the specified {@link TileBoundingVolume}.\n * @private\n *\n * @param {Object} tileBoundingVolume The volume to determine the intersection with the planes.\n * @param {Matrix4} [transform] An optional, additional matrix to transform the plane to world coordinates.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire volume is on the side of the planes\n *                      the normal is pointing and should be entirely rendered, {@link Intersect.OUTSIDE}\n *                      if the entire volume is on the opposite side and should be clipped, and\n *                      {@link Intersect.INTERSECTING} if the volume intersects the planes.\n */\nClippingPlaneCollection.prototype.computeIntersectionWithBoundingVolume = function (\n  tileBoundingVolume,\n  transform\n) {\n  var planes = this._planes;\n  var length = planes.length;\n\n  var modelMatrix = this.modelMatrix;\n  if (defined(transform)) {\n    modelMatrix = Matrix4.multiply(transform, modelMatrix, scratchMatrix);\n  }\n\n  // If the collection is not set to union the clipping regions, the volume must be outside of all planes to be\n  // considered completely clipped. If the collection is set to union the clipping regions, if the volume can be\n  // outside any the planes, it is considered completely clipped.\n  // Lastly, if not completely clipped, if any plane is intersecting, more calculations must be performed.\n  var intersection = Intersect.INSIDE;\n  if (!this.unionClippingRegions && length > 0) {\n    intersection = Intersect.OUTSIDE;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    var plane = planes[i];\n\n    Plane.transform(plane, modelMatrix, scratchPlane); // ClippingPlane can be used for Plane math\n\n    var value = tileBoundingVolume.intersectPlane(scratchPlane);\n    if (value === Intersect.INTERSECTING) {\n      intersection = value;\n    } else if (this._testIntersection(value)) {\n      return value;\n    }\n  }\n\n  return intersection;\n};\n\n/**\n * Sets the owner for the input ClippingPlaneCollection if there wasn't another owner.\n * Destroys the owner's previous ClippingPlaneCollection if setting is successful.\n *\n * @param {ClippingPlaneCollection} [clippingPlaneCollection] A ClippingPlaneCollection (or undefined) being attached to an object\n * @param {Object} owner An Object that should receive the new ClippingPlaneCollection\n * @param {String} key The Key for the Object to reference the ClippingPlaneCollection\n * @private\n */\nClippingPlaneCollection.setOwner = function (\n  clippingPlaneCollection,\n  owner,\n  key\n) {\n  // Don't destroy the ClippingPlaneCollection if it is already owned by newOwner\n  if (clippingPlaneCollection === owner[key]) {\n    return;\n  }\n  // Destroy the existing ClippingPlaneCollection, if any\n  owner[key] = owner[key] && owner[key].destroy();\n  if (defined(clippingPlaneCollection)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (defined(clippingPlaneCollection._owner)) {\n      throw new DeveloperError(\n        \"ClippingPlaneCollection should only be assigned to one object\"\n      );\n    }\n    //>>includeEnd('debug');\n    clippingPlaneCollection._owner = owner;\n    owner[key] = clippingPlaneCollection;\n  }\n};\n\n/**\n * Function for checking if the context will allow clipping planes with floating point textures.\n *\n * @param {Context} context The Context that will contain clipped objects and clipping textures.\n * @returns {Boolean} <code>true</code> if floating point textures can be used for clipping planes.\n * @private\n */\nClippingPlaneCollection.useFloatTexture = function (context) {\n  return context.floatingPointTexture;\n};\n\n/**\n * Function for getting the clipping plane collection's texture resolution.\n * If the ClippingPlaneCollection hasn't been updated, returns the resolution that will be\n * allocated based on the current plane count.\n *\n * @param {ClippingPlaneCollection} clippingPlaneCollection The clipping plane collection\n * @param {Context} context The rendering context\n * @param {Cartesian2} result A Cartesian2 for the result.\n * @returns {Cartesian2} The required resolution.\n * @private\n */\nClippingPlaneCollection.getTextureResolution = function (\n  clippingPlaneCollection,\n  context,\n  result\n) {\n  var texture = clippingPlaneCollection.texture;\n  if (defined(texture)) {\n    result.x = texture.width;\n    result.y = texture.height;\n    return result;\n  }\n\n  var pixelsNeeded = ClippingPlaneCollection.useFloatTexture(context)\n    ? clippingPlaneCollection.length\n    : clippingPlaneCollection.length * 2;\n  var requiredResolution = computeTextureResolution(pixelsNeeded, result);\n\n  // Allocate twice as much space as needed to avoid frequent texture reallocation.\n  requiredResolution.y *= 2;\n  return requiredResolution;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ClippingPlaneCollection#destroy\n */\nClippingPlaneCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * clippingPlanes = clippingPlanes && clippingPlanes .destroy();\n *\n * @see ClippingPlaneCollection#isDestroyed\n */\nClippingPlaneCollection.prototype.destroy = function () {\n  this._clippingPlanesTexture =\n    this._clippingPlanesTexture && this._clippingPlanesTexture.destroy();\n  return destroyObject(this);\n};\nexport default ClippingPlaneCollection;\n"]},"metadata":{},"sourceType":"module"}