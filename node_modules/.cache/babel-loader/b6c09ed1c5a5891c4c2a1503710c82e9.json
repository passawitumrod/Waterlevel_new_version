{"ast":null,"code":"import defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport JobType from \"./JobType.js\";\n/**\n *\n * @private\n * @constructor\n */\n\nfunction JobTypeBudget(total) {\n  /**\n   * Total budget, in milliseconds, allowed for one frame\n   */\n  this._total = total;\n  /**\n   * Time, in milliseconds, used so far during this frame\n   */\n\n  this.usedThisFrame = 0.0;\n  /**\n   * Time, in milliseconds, that other job types stole this frame\n   */\n\n  this.stolenFromMeThisFrame = 0.0;\n  /**\n   * Indicates if this job type was starved this frame, i.e., a job\n   * tried to run but didn't have budget\n   */\n\n  this.starvedThisFrame = false;\n  /**\n   * Indicates if this job was starved last frame.  This prevents it\n   * from being stolen from this frame.\n   */\n\n  this.starvedLastFrame = false;\n}\n\nObject.defineProperties(JobTypeBudget.prototype, {\n  total: {\n    get: function get() {\n      return this._total;\n    }\n  }\n});\n/**\n * Engine for time slicing jobs during a frame to amortize work over multiple frames.  This supports:\n * <ul>\n *   <li>\n *     Separate budgets for different job types, e.g., texture, shader program, and buffer creation.  This\n *     allows all job types to make progress each frame.\n *   </li>\n *   <li>\n *     Stealing from other jobs type budgets if they were not exhausted in the previous frame.  This allows\n *     using the entire budget for all job types each frame even if, for example, all the jobs are the same type.\n *   </li>\n *   <li>\n *     Guaranteed progress on all job types each frame, even if it means exceeding the total budget for the frame.\n *     This prevents, for example, several expensive texture uploads over many frames from prevent a shader compile.\n *   </li>\n * </ul>\n *\n * @private\n */\n\nfunction JobScheduler(budgets) {\n  //>>includeStart('debug', pragmas.debug);\n  if (defined(budgets) && budgets.length !== JobType.NUMBER_OF_JOB_TYPES) {\n    throw new DeveloperError(\"A budget must be specified for each job type; budgets.length should equal JobType.NUMBER_OF_JOB_TYPES.\");\n  } //>>includeEnd('debug');\n  // Total for defaults is half of of one frame at 10 fps\n\n\n  var jobBudgets = new Array(JobType.NUMBER_OF_JOB_TYPES);\n  jobBudgets[JobType.TEXTURE] = new JobTypeBudget(defined(budgets) ? budgets[JobType.TEXTURE] : 10.0); // On cache miss, this most likely only allows one shader compile per frame\n\n  jobBudgets[JobType.PROGRAM] = new JobTypeBudget(defined(budgets) ? budgets[JobType.PROGRAM] : 10.0);\n  jobBudgets[JobType.BUFFER] = new JobTypeBudget(defined(budgets) ? budgets[JobType.BUFFER] : 30.0);\n  var length = jobBudgets.length;\n  var i;\n  var totalBudget = 0.0;\n\n  for (i = 0; i < length; ++i) {\n    totalBudget += jobBudgets[i].total;\n  }\n\n  var executedThisFrame = new Array(length);\n\n  for (i = 0; i < length; ++i) {\n    executedThisFrame[i] = false;\n  }\n\n  this._totalBudget = totalBudget;\n  this._totalUsedThisFrame = 0.0;\n  this._budgets = jobBudgets;\n  this._executedThisFrame = executedThisFrame;\n} // For unit testing\n\n\nJobScheduler.getTimestamp = getTimestamp;\nObject.defineProperties(JobScheduler.prototype, {\n  totalBudget: {\n    get: function get() {\n      return this._totalBudget;\n    }\n  }\n});\n\nJobScheduler.prototype.disableThisFrame = function () {\n  // Prevent jobs from running this frame\n  this._totalUsedThisFrame = this._totalBudget;\n};\n\nJobScheduler.prototype.resetBudgets = function () {\n  var budgets = this._budgets;\n  var length = budgets.length;\n\n  for (var i = 0; i < length; ++i) {\n    var budget = budgets[i];\n    budget.starvedLastFrame = budget.starvedThisFrame;\n    budget.starvedThisFrame = false;\n    budget.usedThisFrame = 0.0;\n    budget.stolenFromMeThisFrame = 0.0;\n  }\n\n  this._totalUsedThisFrame = 0.0;\n};\n\nJobScheduler.prototype.execute = function (job, jobType) {\n  var budgets = this._budgets;\n  var budget = budgets[jobType]; // This ensures each job type makes progress each frame by executing at least once\n\n  var progressThisFrame = this._executedThisFrame[jobType];\n\n  if (this._totalUsedThisFrame >= this._totalBudget && progressThisFrame) {\n    // No budget left this frame for jobs of any type\n    budget.starvedThisFrame = true;\n    return false;\n  }\n\n  var stolenBudget;\n\n  if (budget.usedThisFrame + budget.stolenFromMeThisFrame >= budget.total) {\n    // No budget remaining for jobs of this type. Try to steal from other job types.\n    var length = budgets.length;\n    var i;\n\n    for (i = 0; i < length; ++i) {\n      stolenBudget = budgets[i]; // Steal from this budget if it has time left and it wasn't starved last fame\n\n      if (stolenBudget.usedThisFrame + stolenBudget.stolenFromMeThisFrame < stolenBudget.total && !stolenBudget.starvedLastFrame) {\n        break;\n      }\n    }\n\n    if (i === length && progressThisFrame) {\n      // No other job types can give up their budget this frame, and\n      // this job type already progressed this frame\n      return false;\n    }\n\n    if (progressThisFrame) {\n      // It is considered \"starved\" even if it executes using stolen time so that\n      // next frame, no other job types can steal time from it.\n      budget.starvedThisFrame = true;\n    }\n  }\n\n  var startTime = JobScheduler.getTimestamp();\n  job.execute();\n  var duration = JobScheduler.getTimestamp() - startTime; // Track both time remaining for this job type and all jobs\n  // so budget stealing does send us way over the total budget.\n\n  this._totalUsedThisFrame += duration;\n\n  if (stolenBudget) {\n    stolenBudget.stolenFromMeThisFrame += duration;\n  } else {\n    budget.usedThisFrame += duration;\n  }\n\n  this._executedThisFrame[jobType] = true;\n  return true;\n};\n\nexport default JobScheduler;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/JobScheduler.js"],"names":["defined","DeveloperError","getTimestamp","JobType","JobTypeBudget","total","_total","usedThisFrame","stolenFromMeThisFrame","starvedThisFrame","starvedLastFrame","Object","defineProperties","prototype","get","JobScheduler","budgets","length","NUMBER_OF_JOB_TYPES","jobBudgets","Array","TEXTURE","PROGRAM","BUFFER","i","totalBudget","executedThisFrame","_totalBudget","_totalUsedThisFrame","_budgets","_executedThisFrame","disableThisFrame","resetBudgets","budget","execute","job","jobType","progressThisFrame","stolenBudget","startTime","duration"],"mappings":"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","sourcesContent":["import defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport JobType from \"./JobType.js\";\n\n/**\n *\n * @private\n * @constructor\n */\nfunction JobTypeBudget(total) {\n  /**\n   * Total budget, in milliseconds, allowed for one frame\n   */\n  this._total = total;\n\n  /**\n   * Time, in milliseconds, used so far during this frame\n   */\n  this.usedThisFrame = 0.0;\n\n  /**\n   * Time, in milliseconds, that other job types stole this frame\n   */\n  this.stolenFromMeThisFrame = 0.0;\n\n  /**\n   * Indicates if this job type was starved this frame, i.e., a job\n   * tried to run but didn't have budget\n   */\n  this.starvedThisFrame = false;\n\n  /**\n   * Indicates if this job was starved last frame.  This prevents it\n   * from being stolen from this frame.\n   */\n  this.starvedLastFrame = false;\n}\n\nObject.defineProperties(JobTypeBudget.prototype, {\n  total: {\n    get: function () {\n      return this._total;\n    },\n  },\n});\n\n/**\n * Engine for time slicing jobs during a frame to amortize work over multiple frames.  This supports:\n * <ul>\n *   <li>\n *     Separate budgets for different job types, e.g., texture, shader program, and buffer creation.  This\n *     allows all job types to make progress each frame.\n *   </li>\n *   <li>\n *     Stealing from other jobs type budgets if they were not exhausted in the previous frame.  This allows\n *     using the entire budget for all job types each frame even if, for example, all the jobs are the same type.\n *   </li>\n *   <li>\n *     Guaranteed progress on all job types each frame, even if it means exceeding the total budget for the frame.\n *     This prevents, for example, several expensive texture uploads over many frames from prevent a shader compile.\n *   </li>\n * </ul>\n *\n * @private\n */\nfunction JobScheduler(budgets) {\n  //>>includeStart('debug', pragmas.debug);\n  if (defined(budgets) && budgets.length !== JobType.NUMBER_OF_JOB_TYPES) {\n    throw new DeveloperError(\n      \"A budget must be specified for each job type; budgets.length should equal JobType.NUMBER_OF_JOB_TYPES.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  // Total for defaults is half of of one frame at 10 fps\n  var jobBudgets = new Array(JobType.NUMBER_OF_JOB_TYPES);\n  jobBudgets[JobType.TEXTURE] = new JobTypeBudget(\n    defined(budgets) ? budgets[JobType.TEXTURE] : 10.0\n  );\n  // On cache miss, this most likely only allows one shader compile per frame\n  jobBudgets[JobType.PROGRAM] = new JobTypeBudget(\n    defined(budgets) ? budgets[JobType.PROGRAM] : 10.0\n  );\n  jobBudgets[JobType.BUFFER] = new JobTypeBudget(\n    defined(budgets) ? budgets[JobType.BUFFER] : 30.0\n  );\n\n  var length = jobBudgets.length;\n  var i;\n\n  var totalBudget = 0.0;\n  for (i = 0; i < length; ++i) {\n    totalBudget += jobBudgets[i].total;\n  }\n\n  var executedThisFrame = new Array(length);\n  for (i = 0; i < length; ++i) {\n    executedThisFrame[i] = false;\n  }\n\n  this._totalBudget = totalBudget;\n  this._totalUsedThisFrame = 0.0;\n  this._budgets = jobBudgets;\n  this._executedThisFrame = executedThisFrame;\n}\n\n// For unit testing\nJobScheduler.getTimestamp = getTimestamp;\n\nObject.defineProperties(JobScheduler.prototype, {\n  totalBudget: {\n    get: function () {\n      return this._totalBudget;\n    },\n  },\n});\n\nJobScheduler.prototype.disableThisFrame = function () {\n  // Prevent jobs from running this frame\n  this._totalUsedThisFrame = this._totalBudget;\n};\n\nJobScheduler.prototype.resetBudgets = function () {\n  var budgets = this._budgets;\n  var length = budgets.length;\n  for (var i = 0; i < length; ++i) {\n    var budget = budgets[i];\n    budget.starvedLastFrame = budget.starvedThisFrame;\n    budget.starvedThisFrame = false;\n    budget.usedThisFrame = 0.0;\n    budget.stolenFromMeThisFrame = 0.0;\n  }\n  this._totalUsedThisFrame = 0.0;\n};\n\nJobScheduler.prototype.execute = function (job, jobType) {\n  var budgets = this._budgets;\n  var budget = budgets[jobType];\n\n  // This ensures each job type makes progress each frame by executing at least once\n  var progressThisFrame = this._executedThisFrame[jobType];\n\n  if (this._totalUsedThisFrame >= this._totalBudget && progressThisFrame) {\n    // No budget left this frame for jobs of any type\n    budget.starvedThisFrame = true;\n    return false;\n  }\n\n  var stolenBudget;\n\n  if (budget.usedThisFrame + budget.stolenFromMeThisFrame >= budget.total) {\n    // No budget remaining for jobs of this type. Try to steal from other job types.\n    var length = budgets.length;\n    var i;\n    for (i = 0; i < length; ++i) {\n      stolenBudget = budgets[i];\n\n      // Steal from this budget if it has time left and it wasn't starved last fame\n      if (\n        stolenBudget.usedThisFrame + stolenBudget.stolenFromMeThisFrame <\n          stolenBudget.total &&\n        !stolenBudget.starvedLastFrame\n      ) {\n        break;\n      }\n    }\n\n    if (i === length && progressThisFrame) {\n      // No other job types can give up their budget this frame, and\n      // this job type already progressed this frame\n      return false;\n    }\n\n    if (progressThisFrame) {\n      // It is considered \"starved\" even if it executes using stolen time so that\n      // next frame, no other job types can steal time from it.\n      budget.starvedThisFrame = true;\n    }\n  }\n\n  var startTime = JobScheduler.getTimestamp();\n  job.execute();\n  var duration = JobScheduler.getTimestamp() - startTime;\n\n  // Track both time remaining for this job type and all jobs\n  // so budget stealing does send us way over the total budget.\n  this._totalUsedThisFrame += duration;\n\n  if (stolenBudget) {\n    stolenBudget.stolenFromMeThisFrame += duration;\n  } else {\n    budget.usedThisFrame += duration;\n  }\n  this._executedThisFrame[jobType] = true;\n\n  return true;\n};\nexport default JobScheduler;\n"]},"metadata":{},"sourceType":"module"}