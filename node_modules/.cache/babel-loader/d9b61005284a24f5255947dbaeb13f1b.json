{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\n/**\n * Creates a texture to look up per instance attributes for batched primitives. For example, store each primitive's pick color in the texture.\n *\n * @alias BatchTable\n * @constructor\n * @private\n *\n * @param {Context} context The context in which the batch table is created.\n * @param {Object[]} attributes An array of objects describing a per instance attribute. Each object contains a datatype, components per attributes, whether it is normalized and a function name\n *     to retrieve the value in the vertex shader.\n * @param {Number} numberOfInstances The number of instances in a batch table.\n *\n * @example\n * // create the batch table\n * var attributes = [{\n *     functionName : 'getShow',\n *     componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n *     componentsPerAttribute : 1\n * }, {\n *     functionName : 'getPickColor',\n *     componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n *     componentsPerAttribute : 4,\n *     normalize : true\n * }];\n * var batchTable = new BatchTable(context, attributes, 5);\n *\n * // when creating the draw commands, update the uniform map and the vertex shader\n * vertexShaderSource = batchTable.getVertexShaderCallback()(vertexShaderSource);\n * var shaderProgram = ShaderProgram.fromCache({\n *    // ...\n *    vertexShaderSource : vertexShaderSource,\n * });\n *\n * drawCommand.shaderProgram = shaderProgram;\n * drawCommand.uniformMap = batchTable.getUniformMapCallback()(uniformMap);\n *\n * // use the attribute function names in the shader to retrieve the instance values\n * // ...\n * attribute float batchId;\n *\n * void main() {\n *     // ...\n *     float show = getShow(batchId);\n *     vec3 pickColor = getPickColor(batchId);\n *     // ...\n * }\n */\n\nfunction BatchTable(context, attributes, numberOfInstances) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(context)) {\n    throw new DeveloperError(\"context is required\");\n  }\n\n  if (!defined(attributes)) {\n    throw new DeveloperError(\"attributes is required\");\n  }\n\n  if (!defined(numberOfInstances)) {\n    throw new DeveloperError(\"numberOfInstances is required\");\n  } //>>includeEnd('debug');\n\n\n  this._attributes = attributes;\n  this._numberOfInstances = numberOfInstances;\n\n  if (attributes.length === 0) {\n    return;\n  } // PERFORMANCE_IDEA: We may be able to arrange the attributes so they can be packing into fewer texels.\n  // Right now, an attribute with one component uses an entire texel when 4 single component attributes can\n  // be packed into a texel.\n  //\n  // Packing floats into unsigned byte textures makes the problem worse. A single component float attribute\n  // will be packed into a single texel leaving 3 texels unused. 4 texels are reserved for each float attribute\n  // regardless of how many components it has.\n\n\n  var pixelDatatype = getDatatype(attributes);\n  var textureFloatSupported = context.floatingPointTexture;\n  var packFloats = pixelDatatype === PixelDatatype.FLOAT && !textureFloatSupported;\n  var offsets = createOffsets(attributes, packFloats);\n  var stride = getStride(offsets, attributes, packFloats);\n  var maxNumberOfInstancesPerRow = Math.floor(ContextLimits.maximumTextureSize / stride);\n  var instancesPerWidth = Math.min(numberOfInstances, maxNumberOfInstancesPerRow);\n  var width = stride * instancesPerWidth;\n  var height = Math.ceil(numberOfInstances / instancesPerWidth);\n  var stepX = 1.0 / width;\n  var centerX = stepX * 0.5;\n  var stepY = 1.0 / height;\n  var centerY = stepY * 0.5;\n  this._textureDimensions = new Cartesian2(width, height);\n  this._textureStep = new Cartesian4(stepX, centerX, stepY, centerY);\n  this._pixelDatatype = !packFloats ? pixelDatatype : PixelDatatype.UNSIGNED_BYTE;\n  this._packFloats = packFloats;\n  this._offsets = offsets;\n  this._stride = stride;\n  this._texture = undefined;\n  var batchLength = 4 * width * height;\n  this._batchValues = pixelDatatype === PixelDatatype.FLOAT && !packFloats ? new Float32Array(batchLength) : new Uint8Array(batchLength);\n  this._batchValuesDirty = false;\n}\n\nObject.defineProperties(BatchTable.prototype, {\n  /**\n   * The attribute descriptions.\n   * @memberOf BatchTable.prototype\n   * @type {Object[]}\n   * @readonly\n   */\n  attributes: {\n    get: function () {\n      return this._attributes;\n    }\n  },\n\n  /**\n   * The number of instances.\n   * @memberOf BatchTable.prototype\n   * @type {Number}\n   * @readonly\n   */\n  numberOfInstances: {\n    get: function () {\n      return this._numberOfInstances;\n    }\n  }\n});\n\nfunction getDatatype(attributes) {\n  var foundFloatDatatype = false;\n  var length = attributes.length;\n\n  for (var i = 0; i < length; ++i) {\n    if (attributes[i].componentDatatype !== ComponentDatatype.UNSIGNED_BYTE) {\n      foundFloatDatatype = true;\n      break;\n    }\n  }\n\n  return foundFloatDatatype ? PixelDatatype.FLOAT : PixelDatatype.UNSIGNED_BYTE;\n}\n\nfunction getAttributeType(attributes, attributeIndex) {\n  var componentsPerAttribute = attributes[attributeIndex].componentsPerAttribute;\n\n  if (componentsPerAttribute === 2) {\n    return Cartesian2;\n  } else if (componentsPerAttribute === 3) {\n    return Cartesian3;\n  } else if (componentsPerAttribute === 4) {\n    return Cartesian4;\n  }\n\n  return Number;\n}\n\nfunction createOffsets(attributes, packFloats) {\n  var offsets = new Array(attributes.length);\n  var currentOffset = 0;\n  var attributesLength = attributes.length;\n\n  for (var i = 0; i < attributesLength; ++i) {\n    var attribute = attributes[i];\n    var componentDatatype = attribute.componentDatatype;\n    offsets[i] = currentOffset;\n\n    if (componentDatatype !== ComponentDatatype.UNSIGNED_BYTE && packFloats) {\n      currentOffset += 4;\n    } else {\n      ++currentOffset;\n    }\n  }\n\n  return offsets;\n}\n\nfunction getStride(offsets, attributes, packFloats) {\n  var length = offsets.length;\n  var lastOffset = offsets[length - 1];\n  var lastAttribute = attributes[length - 1];\n  var componentDatatype = lastAttribute.componentDatatype;\n\n  if (componentDatatype !== ComponentDatatype.UNSIGNED_BYTE && packFloats) {\n    return lastOffset + 4;\n  }\n\n  return lastOffset + 1;\n}\n\nvar scratchPackedFloatCartesian4 = new Cartesian4();\n\nfunction getPackedFloat(array, index, result) {\n  var packed = Cartesian4.unpack(array, index, scratchPackedFloatCartesian4);\n  var x = Cartesian4.unpackFloat(packed);\n  packed = Cartesian4.unpack(array, index + 4, scratchPackedFloatCartesian4);\n  var y = Cartesian4.unpackFloat(packed);\n  packed = Cartesian4.unpack(array, index + 8, scratchPackedFloatCartesian4);\n  var z = Cartesian4.unpackFloat(packed);\n  packed = Cartesian4.unpack(array, index + 12, scratchPackedFloatCartesian4);\n  var w = Cartesian4.unpackFloat(packed);\n  return Cartesian4.fromElements(x, y, z, w, result);\n}\n\nfunction setPackedAttribute(value, array, index) {\n  var packed = Cartesian4.packFloat(value.x, scratchPackedFloatCartesian4);\n  Cartesian4.pack(packed, array, index);\n  packed = Cartesian4.packFloat(value.y, packed);\n  Cartesian4.pack(packed, array, index + 4);\n  packed = Cartesian4.packFloat(value.z, packed);\n  Cartesian4.pack(packed, array, index + 8);\n  packed = Cartesian4.packFloat(value.w, packed);\n  Cartesian4.pack(packed, array, index + 12);\n}\n\nvar scratchGetAttributeCartesian4 = new Cartesian4();\n/**\n * Gets the value of an attribute in the table.\n *\n * @param {Number} instanceIndex The index of the instance.\n * @param {Number} attributeIndex The index of the attribute.\n * @param {undefined|Cartesian2|Cartesian3|Cartesian4} [result] The object onto which to store the result. The type is dependent on the attribute's number of components.\n * @returns {Number|Cartesian2|Cartesian3|Cartesian4} The attribute value stored for the instance.\n *\n * @exception {DeveloperError} instanceIndex is out of range.\n * @exception {DeveloperError} attributeIndex is out of range.\n */\n\nBatchTable.prototype.getBatchedAttribute = function (instanceIndex, attributeIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (instanceIndex < 0 || instanceIndex >= this._numberOfInstances) {\n    throw new DeveloperError(\"instanceIndex is out of range.\");\n  }\n\n  if (attributeIndex < 0 || attributeIndex >= this._attributes.length) {\n    throw new DeveloperError(\"attributeIndex is out of range\");\n  } //>>includeEnd('debug');\n\n\n  var attributes = this._attributes;\n  var offset = this._offsets[attributeIndex];\n  var stride = this._stride;\n  var index = 4 * stride * instanceIndex + 4 * offset;\n  var value;\n\n  if (this._packFloats && attributes[attributeIndex].componentDatatype !== PixelDatatype.UNSIGNED_BYTE) {\n    value = getPackedFloat(this._batchValues, index, scratchGetAttributeCartesian4);\n  } else {\n    value = Cartesian4.unpack(this._batchValues, index, scratchGetAttributeCartesian4);\n  }\n\n  var attributeType = getAttributeType(attributes, attributeIndex);\n\n  if (defined(attributeType.fromCartesian4)) {\n    return attributeType.fromCartesian4(value, result);\n  } else if (defined(attributeType.clone)) {\n    return attributeType.clone(value, result);\n  }\n\n  return value.x;\n};\n\nvar setAttributeScratchValues = [undefined, undefined, new Cartesian2(), new Cartesian3(), new Cartesian4()];\nvar setAttributeScratchCartesian4 = new Cartesian4();\n/**\n * Sets the value of an attribute in the table.\n *\n * @param {Number} instanceIndex The index of the instance.\n * @param {Number} attributeIndex The index of the attribute.\n * @param {Number|Cartesian2|Cartesian3|Cartesian4} value The value to be stored in the table. The type of value will depend on the number of components of the attribute.\n *\n * @exception {DeveloperError} instanceIndex is out of range.\n * @exception {DeveloperError} attributeIndex is out of range.\n */\n\nBatchTable.prototype.setBatchedAttribute = function (instanceIndex, attributeIndex, value) {\n  //>>includeStart('debug', pragmas.debug);\n  if (instanceIndex < 0 || instanceIndex >= this._numberOfInstances) {\n    throw new DeveloperError(\"instanceIndex is out of range.\");\n  }\n\n  if (attributeIndex < 0 || attributeIndex >= this._attributes.length) {\n    throw new DeveloperError(\"attributeIndex is out of range\");\n  }\n\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required.\");\n  } //>>includeEnd('debug');\n\n\n  var attributes = this._attributes;\n  var result = setAttributeScratchValues[attributes[attributeIndex].componentsPerAttribute];\n  var currentAttribute = this.getBatchedAttribute(instanceIndex, attributeIndex, result);\n  var attributeType = getAttributeType(this._attributes, attributeIndex);\n  var entriesEqual = defined(attributeType.equals) ? attributeType.equals(currentAttribute, value) : currentAttribute === value;\n\n  if (entriesEqual) {\n    return;\n  }\n\n  var attributeValue = setAttributeScratchCartesian4;\n  attributeValue.x = defined(value.x) ? value.x : value;\n  attributeValue.y = defined(value.y) ? value.y : 0.0;\n  attributeValue.z = defined(value.z) ? value.z : 0.0;\n  attributeValue.w = defined(value.w) ? value.w : 0.0;\n  var offset = this._offsets[attributeIndex];\n  var stride = this._stride;\n  var index = 4 * stride * instanceIndex + 4 * offset;\n\n  if (this._packFloats && attributes[attributeIndex].componentDatatype !== PixelDatatype.UNSIGNED_BYTE) {\n    setPackedAttribute(attributeValue, this._batchValues, index);\n  } else {\n    Cartesian4.pack(attributeValue, this._batchValues, index);\n  }\n\n  this._batchValuesDirty = true;\n};\n\nfunction createTexture(batchTable, context) {\n  var dimensions = batchTable._textureDimensions;\n  batchTable._texture = new Texture({\n    context: context,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: batchTable._pixelDatatype,\n    width: dimensions.x,\n    height: dimensions.y,\n    sampler: Sampler.NEAREST,\n    flipY: false\n  });\n}\n\nfunction updateTexture(batchTable) {\n  var dimensions = batchTable._textureDimensions;\n\n  batchTable._texture.copyFrom({\n    width: dimensions.x,\n    height: dimensions.y,\n    arrayBufferView: batchTable._batchValues\n  });\n}\n/**\n * Creates/updates the batch table texture.\n * @param {FrameState} frameState The frame state.\n *\n * @exception {RuntimeError} The floating point texture extension is required but not supported.\n */\n\n\nBatchTable.prototype.update = function (frameState) {\n  if (defined(this._texture) && !this._batchValuesDirty || this._attributes.length === 0) {\n    return;\n  }\n\n  this._batchValuesDirty = false;\n\n  if (!defined(this._texture)) {\n    createTexture(this, frameState.context);\n  }\n\n  updateTexture(this);\n};\n/**\n * Gets a function that will update a uniform map to contain values for looking up values in the batch table.\n *\n * @returns {BatchTable~updateUniformMapCallback} A callback for updating uniform maps.\n */\n\n\nBatchTable.prototype.getUniformMapCallback = function () {\n  var that = this;\n  return function (uniformMap) {\n    if (that._attributes.length === 0) {\n      return uniformMap;\n    }\n\n    var batchUniformMap = {\n      batchTexture: function () {\n        return that._texture;\n      },\n      batchTextureDimensions: function () {\n        return that._textureDimensions;\n      },\n      batchTextureStep: function () {\n        return that._textureStep;\n      }\n    };\n    return combine(uniformMap, batchUniformMap);\n  };\n};\n\nfunction getGlslComputeSt(batchTable) {\n  var stride = batchTable._stride; // GLSL batchId is zero-based: [0, numberOfInstances - 1]\n\n  if (batchTable._textureDimensions.y === 1) {\n    return \"uniform vec4 batchTextureStep; \\n\" + \"vec2 computeSt(float batchId) \\n\" + \"{ \\n\" + \"    float stepX = batchTextureStep.x; \\n\" + \"    float centerX = batchTextureStep.y; \\n\" + \"    float numberOfAttributes = float(\" + stride + \"); \\n\" + \"    return vec2(centerX + (batchId * numberOfAttributes * stepX), 0.5); \\n\" + \"} \\n\";\n  }\n\n  return \"uniform vec4 batchTextureStep; \\n\" + \"uniform vec2 batchTextureDimensions; \\n\" + \"vec2 computeSt(float batchId) \\n\" + \"{ \\n\" + \"    float stepX = batchTextureStep.x; \\n\" + \"    float centerX = batchTextureStep.y; \\n\" + \"    float stepY = batchTextureStep.z; \\n\" + \"    float centerY = batchTextureStep.w; \\n\" + \"    float numberOfAttributes = float(\" + stride + \"); \\n\" + \"    float xId = mod(batchId * numberOfAttributes, batchTextureDimensions.x); \\n\" + \"    float yId = floor(batchId * numberOfAttributes / batchTextureDimensions.x); \\n\" + \"    return vec2(centerX + (xId * stepX), centerY + (yId * stepY)); \\n\" + \"} \\n\";\n}\n\nfunction getComponentType(componentsPerAttribute) {\n  if (componentsPerAttribute === 1) {\n    return \"float\";\n  }\n\n  return \"vec\" + componentsPerAttribute;\n}\n\nfunction getComponentSwizzle(componentsPerAttribute) {\n  if (componentsPerAttribute === 1) {\n    return \".x\";\n  } else if (componentsPerAttribute === 2) {\n    return \".xy\";\n  } else if (componentsPerAttribute === 3) {\n    return \".xyz\";\n  }\n\n  return \"\";\n}\n\nfunction getGlslAttributeFunction(batchTable, attributeIndex) {\n  var attributes = batchTable._attributes;\n  var attribute = attributes[attributeIndex];\n  var componentsPerAttribute = attribute.componentsPerAttribute;\n  var functionName = attribute.functionName;\n  var functionReturnType = getComponentType(componentsPerAttribute);\n  var functionReturnValue = getComponentSwizzle(componentsPerAttribute);\n  var offset = batchTable._offsets[attributeIndex];\n  var glslFunction = functionReturnType + \" \" + functionName + \"(float batchId) \\n\" + \"{ \\n\" + \"    vec2 st = computeSt(batchId); \\n\" + \"    st.x += batchTextureStep.x * float(\" + offset + \"); \\n\";\n\n  if (batchTable._packFloats && attribute.componentDatatype !== PixelDatatype.UNSIGNED_BYTE) {\n    glslFunction += \"vec4 textureValue; \\n\" + \"textureValue.x = czm_unpackFloat(texture2D(batchTexture, st)); \\n\" + \"textureValue.y = czm_unpackFloat(texture2D(batchTexture, st + vec2(batchTextureStep.x, 0.0))); \\n\" + \"textureValue.z = czm_unpackFloat(texture2D(batchTexture, st + vec2(batchTextureStep.x * 2.0, 0.0))); \\n\" + \"textureValue.w = czm_unpackFloat(texture2D(batchTexture, st + vec2(batchTextureStep.x * 3.0, 0.0))); \\n\";\n  } else {\n    glslFunction += \"    vec4 textureValue = texture2D(batchTexture, st); \\n\";\n  }\n\n  glslFunction += \"    \" + functionReturnType + \" value = textureValue\" + functionReturnValue + \"; \\n\";\n\n  if (batchTable._pixelDatatype === PixelDatatype.UNSIGNED_BYTE && attribute.componentDatatype === ComponentDatatype.UNSIGNED_BYTE && !attribute.normalize) {\n    glslFunction += \"value *= 255.0; \\n\";\n  } else if (batchTable._pixelDatatype === PixelDatatype.FLOAT && attribute.componentDatatype === ComponentDatatype.UNSIGNED_BYTE && attribute.normalize) {\n    glslFunction += \"value /= 255.0; \\n\";\n  }\n\n  glslFunction += \"    return value; \\n\" + \"} \\n\";\n  return glslFunction;\n}\n/**\n * Gets a function that will update a vertex shader to contain functions for looking up values in the batch table.\n *\n * @returns {BatchTable~updateVertexShaderSourceCallback} A callback for updating a vertex shader source.\n */\n\n\nBatchTable.prototype.getVertexShaderCallback = function () {\n  var attributes = this._attributes;\n\n  if (attributes.length === 0) {\n    return function (source) {\n      return source;\n    };\n  }\n\n  var batchTableShader = \"uniform highp sampler2D batchTexture; \\n\";\n  batchTableShader += getGlslComputeSt(this) + \"\\n\";\n  var length = attributes.length;\n\n  for (var i = 0; i < length; ++i) {\n    batchTableShader += getGlslAttributeFunction(this, i);\n  }\n\n  return function (source) {\n    var mainIndex = source.indexOf(\"void main\");\n    var beforeMain = source.substring(0, mainIndex);\n    var afterMain = source.substring(mainIndex);\n    return beforeMain + \"\\n\" + batchTableShader + \"\\n\" + afterMain;\n  };\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see BatchTable#destroy\n */\n\n\nBatchTable.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see BatchTable#isDestroyed\n */\n\n\nBatchTable.prototype.destroy = function () {\n  this._texture = this._texture && this._texture.destroy();\n  return destroyObject(this);\n};\n/**\n * A callback for updating uniform maps.\n * @callback BatchTable~updateUniformMapCallback\n *\n * @param {Object} uniformMap The uniform map.\n * @returns {Object} The new uniform map with properties for retrieving values from the batch table.\n */\n\n/**\n * A callback for updating a vertex shader source.\n * @callback BatchTable~updateVertexShaderSourceCallback\n *\n * @param {String} vertexShaderSource The vertex shader source.\n * @returns {String} The new vertex shader source with the functions for retrieving batch table values injected.\n */\n\n\nexport default BatchTable;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/BatchTable.js"],"names":["Cartesian2","Cartesian3","Cartesian4","combine","ComponentDatatype","defined","destroyObject","DeveloperError","PixelFormat","ContextLimits","PixelDatatype","Sampler","Texture","BatchTable","context","attributes","numberOfInstances","_attributes","_numberOfInstances","length","pixelDatatype","getDatatype","textureFloatSupported","floatingPointTexture","packFloats","FLOAT","offsets","createOffsets","stride","getStride","maxNumberOfInstancesPerRow","Math","floor","maximumTextureSize","instancesPerWidth","min","width","height","ceil","stepX","centerX","stepY","centerY","_textureDimensions","_textureStep","_pixelDatatype","UNSIGNED_BYTE","_packFloats","_offsets","_stride","_texture","undefined","batchLength","_batchValues","Float32Array","Uint8Array","_batchValuesDirty","Object","defineProperties","prototype","get","foundFloatDatatype","i","componentDatatype","getAttributeType","attributeIndex","componentsPerAttribute","Number","Array","currentOffset","attributesLength","attribute","lastOffset","lastAttribute","scratchPackedFloatCartesian4","getPackedFloat","array","index","result","packed","unpack","x","unpackFloat","y","z","w","fromElements","setPackedAttribute","value","packFloat","pack","scratchGetAttributeCartesian4","getBatchedAttribute","instanceIndex","offset","attributeType","fromCartesian4","clone","setAttributeScratchValues","setAttributeScratchCartesian4","setBatchedAttribute","currentAttribute","entriesEqual","equals","attributeValue","createTexture","batchTable","dimensions","pixelFormat","RGBA","sampler","NEAREST","flipY","updateTexture","copyFrom","arrayBufferView","update","frameState","getUniformMapCallback","that","uniformMap","batchUniformMap","batchTexture","batchTextureDimensions","batchTextureStep","getGlslComputeSt","getComponentType","getComponentSwizzle","getGlslAttributeFunction","functionName","functionReturnType","functionReturnValue","glslFunction","normalize","getVertexShaderCallback","source","batchTableShader","mainIndex","indexOf","beforeMain","substring","afterMain","isDestroyed","destroy"],"mappings":"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","sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\n\n/**\n * Creates a texture to look up per instance attributes for batched primitives. For example, store each primitive's pick color in the texture.\n *\n * @alias BatchTable\n * @constructor\n * @private\n *\n * @param {Context} context The context in which the batch table is created.\n * @param {Object[]} attributes An array of objects describing a per instance attribute. Each object contains a datatype, components per attributes, whether it is normalized and a function name\n *     to retrieve the value in the vertex shader.\n * @param {Number} numberOfInstances The number of instances in a batch table.\n *\n * @example\n * // create the batch table\n * var attributes = [{\n *     functionName : 'getShow',\n *     componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n *     componentsPerAttribute : 1\n * }, {\n *     functionName : 'getPickColor',\n *     componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n *     componentsPerAttribute : 4,\n *     normalize : true\n * }];\n * var batchTable = new BatchTable(context, attributes, 5);\n *\n * // when creating the draw commands, update the uniform map and the vertex shader\n * vertexShaderSource = batchTable.getVertexShaderCallback()(vertexShaderSource);\n * var shaderProgram = ShaderProgram.fromCache({\n *    // ...\n *    vertexShaderSource : vertexShaderSource,\n * });\n *\n * drawCommand.shaderProgram = shaderProgram;\n * drawCommand.uniformMap = batchTable.getUniformMapCallback()(uniformMap);\n *\n * // use the attribute function names in the shader to retrieve the instance values\n * // ...\n * attribute float batchId;\n *\n * void main() {\n *     // ...\n *     float show = getShow(batchId);\n *     vec3 pickColor = getPickColor(batchId);\n *     // ...\n * }\n */\nfunction BatchTable(context, attributes, numberOfInstances) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(context)) {\n    throw new DeveloperError(\"context is required\");\n  }\n  if (!defined(attributes)) {\n    throw new DeveloperError(\"attributes is required\");\n  }\n  if (!defined(numberOfInstances)) {\n    throw new DeveloperError(\"numberOfInstances is required\");\n  }\n  //>>includeEnd('debug');\n\n  this._attributes = attributes;\n  this._numberOfInstances = numberOfInstances;\n\n  if (attributes.length === 0) {\n    return;\n  }\n\n  // PERFORMANCE_IDEA: We may be able to arrange the attributes so they can be packing into fewer texels.\n  // Right now, an attribute with one component uses an entire texel when 4 single component attributes can\n  // be packed into a texel.\n  //\n  // Packing floats into unsigned byte textures makes the problem worse. A single component float attribute\n  // will be packed into a single texel leaving 3 texels unused. 4 texels are reserved for each float attribute\n  // regardless of how many components it has.\n  var pixelDatatype = getDatatype(attributes);\n  var textureFloatSupported = context.floatingPointTexture;\n  var packFloats =\n    pixelDatatype === PixelDatatype.FLOAT && !textureFloatSupported;\n  var offsets = createOffsets(attributes, packFloats);\n\n  var stride = getStride(offsets, attributes, packFloats);\n  var maxNumberOfInstancesPerRow = Math.floor(\n    ContextLimits.maximumTextureSize / stride\n  );\n\n  var instancesPerWidth = Math.min(\n    numberOfInstances,\n    maxNumberOfInstancesPerRow\n  );\n  var width = stride * instancesPerWidth;\n  var height = Math.ceil(numberOfInstances / instancesPerWidth);\n\n  var stepX = 1.0 / width;\n  var centerX = stepX * 0.5;\n  var stepY = 1.0 / height;\n  var centerY = stepY * 0.5;\n\n  this._textureDimensions = new Cartesian2(width, height);\n  this._textureStep = new Cartesian4(stepX, centerX, stepY, centerY);\n  this._pixelDatatype = !packFloats\n    ? pixelDatatype\n    : PixelDatatype.UNSIGNED_BYTE;\n  this._packFloats = packFloats;\n  this._offsets = offsets;\n  this._stride = stride;\n  this._texture = undefined;\n\n  var batchLength = 4 * width * height;\n  this._batchValues =\n    pixelDatatype === PixelDatatype.FLOAT && !packFloats\n      ? new Float32Array(batchLength)\n      : new Uint8Array(batchLength);\n  this._batchValuesDirty = false;\n}\n\nObject.defineProperties(BatchTable.prototype, {\n  /**\n   * The attribute descriptions.\n   * @memberOf BatchTable.prototype\n   * @type {Object[]}\n   * @readonly\n   */\n  attributes: {\n    get: function () {\n      return this._attributes;\n    },\n  },\n  /**\n   * The number of instances.\n   * @memberOf BatchTable.prototype\n   * @type {Number}\n   * @readonly\n   */\n  numberOfInstances: {\n    get: function () {\n      return this._numberOfInstances;\n    },\n  },\n});\n\nfunction getDatatype(attributes) {\n  var foundFloatDatatype = false;\n  var length = attributes.length;\n  for (var i = 0; i < length; ++i) {\n    if (attributes[i].componentDatatype !== ComponentDatatype.UNSIGNED_BYTE) {\n      foundFloatDatatype = true;\n      break;\n    }\n  }\n  return foundFloatDatatype ? PixelDatatype.FLOAT : PixelDatatype.UNSIGNED_BYTE;\n}\n\nfunction getAttributeType(attributes, attributeIndex) {\n  var componentsPerAttribute =\n    attributes[attributeIndex].componentsPerAttribute;\n  if (componentsPerAttribute === 2) {\n    return Cartesian2;\n  } else if (componentsPerAttribute === 3) {\n    return Cartesian3;\n  } else if (componentsPerAttribute === 4) {\n    return Cartesian4;\n  }\n  return Number;\n}\n\nfunction createOffsets(attributes, packFloats) {\n  var offsets = new Array(attributes.length);\n\n  var currentOffset = 0;\n  var attributesLength = attributes.length;\n  for (var i = 0; i < attributesLength; ++i) {\n    var attribute = attributes[i];\n    var componentDatatype = attribute.componentDatatype;\n\n    offsets[i] = currentOffset;\n\n    if (componentDatatype !== ComponentDatatype.UNSIGNED_BYTE && packFloats) {\n      currentOffset += 4;\n    } else {\n      ++currentOffset;\n    }\n  }\n\n  return offsets;\n}\n\nfunction getStride(offsets, attributes, packFloats) {\n  var length = offsets.length;\n  var lastOffset = offsets[length - 1];\n  var lastAttribute = attributes[length - 1];\n  var componentDatatype = lastAttribute.componentDatatype;\n\n  if (componentDatatype !== ComponentDatatype.UNSIGNED_BYTE && packFloats) {\n    return lastOffset + 4;\n  }\n  return lastOffset + 1;\n}\n\nvar scratchPackedFloatCartesian4 = new Cartesian4();\n\nfunction getPackedFloat(array, index, result) {\n  var packed = Cartesian4.unpack(array, index, scratchPackedFloatCartesian4);\n  var x = Cartesian4.unpackFloat(packed);\n\n  packed = Cartesian4.unpack(array, index + 4, scratchPackedFloatCartesian4);\n  var y = Cartesian4.unpackFloat(packed);\n\n  packed = Cartesian4.unpack(array, index + 8, scratchPackedFloatCartesian4);\n  var z = Cartesian4.unpackFloat(packed);\n\n  packed = Cartesian4.unpack(array, index + 12, scratchPackedFloatCartesian4);\n  var w = Cartesian4.unpackFloat(packed);\n\n  return Cartesian4.fromElements(x, y, z, w, result);\n}\n\nfunction setPackedAttribute(value, array, index) {\n  var packed = Cartesian4.packFloat(value.x, scratchPackedFloatCartesian4);\n  Cartesian4.pack(packed, array, index);\n\n  packed = Cartesian4.packFloat(value.y, packed);\n  Cartesian4.pack(packed, array, index + 4);\n\n  packed = Cartesian4.packFloat(value.z, packed);\n  Cartesian4.pack(packed, array, index + 8);\n\n  packed = Cartesian4.packFloat(value.w, packed);\n  Cartesian4.pack(packed, array, index + 12);\n}\n\nvar scratchGetAttributeCartesian4 = new Cartesian4();\n\n/**\n * Gets the value of an attribute in the table.\n *\n * @param {Number} instanceIndex The index of the instance.\n * @param {Number} attributeIndex The index of the attribute.\n * @param {undefined|Cartesian2|Cartesian3|Cartesian4} [result] The object onto which to store the result. The type is dependent on the attribute's number of components.\n * @returns {Number|Cartesian2|Cartesian3|Cartesian4} The attribute value stored for the instance.\n *\n * @exception {DeveloperError} instanceIndex is out of range.\n * @exception {DeveloperError} attributeIndex is out of range.\n */\nBatchTable.prototype.getBatchedAttribute = function (\n  instanceIndex,\n  attributeIndex,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (instanceIndex < 0 || instanceIndex >= this._numberOfInstances) {\n    throw new DeveloperError(\"instanceIndex is out of range.\");\n  }\n  if (attributeIndex < 0 || attributeIndex >= this._attributes.length) {\n    throw new DeveloperError(\"attributeIndex is out of range\");\n  }\n  //>>includeEnd('debug');\n\n  var attributes = this._attributes;\n  var offset = this._offsets[attributeIndex];\n  var stride = this._stride;\n\n  var index = 4 * stride * instanceIndex + 4 * offset;\n  var value;\n\n  if (\n    this._packFloats &&\n    attributes[attributeIndex].componentDatatype !== PixelDatatype.UNSIGNED_BYTE\n  ) {\n    value = getPackedFloat(\n      this._batchValues,\n      index,\n      scratchGetAttributeCartesian4\n    );\n  } else {\n    value = Cartesian4.unpack(\n      this._batchValues,\n      index,\n      scratchGetAttributeCartesian4\n    );\n  }\n\n  var attributeType = getAttributeType(attributes, attributeIndex);\n  if (defined(attributeType.fromCartesian4)) {\n    return attributeType.fromCartesian4(value, result);\n  } else if (defined(attributeType.clone)) {\n    return attributeType.clone(value, result);\n  }\n\n  return value.x;\n};\n\nvar setAttributeScratchValues = [\n  undefined,\n  undefined,\n  new Cartesian2(),\n  new Cartesian3(),\n  new Cartesian4(),\n];\nvar setAttributeScratchCartesian4 = new Cartesian4();\n\n/**\n * Sets the value of an attribute in the table.\n *\n * @param {Number} instanceIndex The index of the instance.\n * @param {Number} attributeIndex The index of the attribute.\n * @param {Number|Cartesian2|Cartesian3|Cartesian4} value The value to be stored in the table. The type of value will depend on the number of components of the attribute.\n *\n * @exception {DeveloperError} instanceIndex is out of range.\n * @exception {DeveloperError} attributeIndex is out of range.\n */\nBatchTable.prototype.setBatchedAttribute = function (\n  instanceIndex,\n  attributeIndex,\n  value\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (instanceIndex < 0 || instanceIndex >= this._numberOfInstances) {\n    throw new DeveloperError(\"instanceIndex is out of range.\");\n  }\n  if (attributeIndex < 0 || attributeIndex >= this._attributes.length) {\n    throw new DeveloperError(\"attributeIndex is out of range\");\n  }\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var attributes = this._attributes;\n  var result =\n    setAttributeScratchValues[\n      attributes[attributeIndex].componentsPerAttribute\n    ];\n  var currentAttribute = this.getBatchedAttribute(\n    instanceIndex,\n    attributeIndex,\n    result\n  );\n  var attributeType = getAttributeType(this._attributes, attributeIndex);\n  var entriesEqual = defined(attributeType.equals)\n    ? attributeType.equals(currentAttribute, value)\n    : currentAttribute === value;\n  if (entriesEqual) {\n    return;\n  }\n\n  var attributeValue = setAttributeScratchCartesian4;\n  attributeValue.x = defined(value.x) ? value.x : value;\n  attributeValue.y = defined(value.y) ? value.y : 0.0;\n  attributeValue.z = defined(value.z) ? value.z : 0.0;\n  attributeValue.w = defined(value.w) ? value.w : 0.0;\n\n  var offset = this._offsets[attributeIndex];\n  var stride = this._stride;\n  var index = 4 * stride * instanceIndex + 4 * offset;\n\n  if (\n    this._packFloats &&\n    attributes[attributeIndex].componentDatatype !== PixelDatatype.UNSIGNED_BYTE\n  ) {\n    setPackedAttribute(attributeValue, this._batchValues, index);\n  } else {\n    Cartesian4.pack(attributeValue, this._batchValues, index);\n  }\n\n  this._batchValuesDirty = true;\n};\n\nfunction createTexture(batchTable, context) {\n  var dimensions = batchTable._textureDimensions;\n  batchTable._texture = new Texture({\n    context: context,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: batchTable._pixelDatatype,\n    width: dimensions.x,\n    height: dimensions.y,\n    sampler: Sampler.NEAREST,\n    flipY: false,\n  });\n}\n\nfunction updateTexture(batchTable) {\n  var dimensions = batchTable._textureDimensions;\n  batchTable._texture.copyFrom({\n    width: dimensions.x,\n    height: dimensions.y,\n    arrayBufferView: batchTable._batchValues,\n  });\n}\n\n/**\n * Creates/updates the batch table texture.\n * @param {FrameState} frameState The frame state.\n *\n * @exception {RuntimeError} The floating point texture extension is required but not supported.\n */\nBatchTable.prototype.update = function (frameState) {\n  if (\n    (defined(this._texture) && !this._batchValuesDirty) ||\n    this._attributes.length === 0\n  ) {\n    return;\n  }\n\n  this._batchValuesDirty = false;\n\n  if (!defined(this._texture)) {\n    createTexture(this, frameState.context);\n  }\n  updateTexture(this);\n};\n\n/**\n * Gets a function that will update a uniform map to contain values for looking up values in the batch table.\n *\n * @returns {BatchTable~updateUniformMapCallback} A callback for updating uniform maps.\n */\nBatchTable.prototype.getUniformMapCallback = function () {\n  var that = this;\n  return function (uniformMap) {\n    if (that._attributes.length === 0) {\n      return uniformMap;\n    }\n\n    var batchUniformMap = {\n      batchTexture: function () {\n        return that._texture;\n      },\n      batchTextureDimensions: function () {\n        return that._textureDimensions;\n      },\n      batchTextureStep: function () {\n        return that._textureStep;\n      },\n    };\n    return combine(uniformMap, batchUniformMap);\n  };\n};\n\nfunction getGlslComputeSt(batchTable) {\n  var stride = batchTable._stride;\n\n  // GLSL batchId is zero-based: [0, numberOfInstances - 1]\n  if (batchTable._textureDimensions.y === 1) {\n    return (\n      \"uniform vec4 batchTextureStep; \\n\" +\n      \"vec2 computeSt(float batchId) \\n\" +\n      \"{ \\n\" +\n      \"    float stepX = batchTextureStep.x; \\n\" +\n      \"    float centerX = batchTextureStep.y; \\n\" +\n      \"    float numberOfAttributes = float(\" +\n      stride +\n      \"); \\n\" +\n      \"    return vec2(centerX + (batchId * numberOfAttributes * stepX), 0.5); \\n\" +\n      \"} \\n\"\n    );\n  }\n\n  return (\n    \"uniform vec4 batchTextureStep; \\n\" +\n    \"uniform vec2 batchTextureDimensions; \\n\" +\n    \"vec2 computeSt(float batchId) \\n\" +\n    \"{ \\n\" +\n    \"    float stepX = batchTextureStep.x; \\n\" +\n    \"    float centerX = batchTextureStep.y; \\n\" +\n    \"    float stepY = batchTextureStep.z; \\n\" +\n    \"    float centerY = batchTextureStep.w; \\n\" +\n    \"    float numberOfAttributes = float(\" +\n    stride +\n    \"); \\n\" +\n    \"    float xId = mod(batchId * numberOfAttributes, batchTextureDimensions.x); \\n\" +\n    \"    float yId = floor(batchId * numberOfAttributes / batchTextureDimensions.x); \\n\" +\n    \"    return vec2(centerX + (xId * stepX), centerY + (yId * stepY)); \\n\" +\n    \"} \\n\"\n  );\n}\n\nfunction getComponentType(componentsPerAttribute) {\n  if (componentsPerAttribute === 1) {\n    return \"float\";\n  }\n  return \"vec\" + componentsPerAttribute;\n}\n\nfunction getComponentSwizzle(componentsPerAttribute) {\n  if (componentsPerAttribute === 1) {\n    return \".x\";\n  } else if (componentsPerAttribute === 2) {\n    return \".xy\";\n  } else if (componentsPerAttribute === 3) {\n    return \".xyz\";\n  }\n  return \"\";\n}\n\nfunction getGlslAttributeFunction(batchTable, attributeIndex) {\n  var attributes = batchTable._attributes;\n  var attribute = attributes[attributeIndex];\n  var componentsPerAttribute = attribute.componentsPerAttribute;\n  var functionName = attribute.functionName;\n  var functionReturnType = getComponentType(componentsPerAttribute);\n  var functionReturnValue = getComponentSwizzle(componentsPerAttribute);\n\n  var offset = batchTable._offsets[attributeIndex];\n\n  var glslFunction =\n    functionReturnType +\n    \" \" +\n    functionName +\n    \"(float batchId) \\n\" +\n    \"{ \\n\" +\n    \"    vec2 st = computeSt(batchId); \\n\" +\n    \"    st.x += batchTextureStep.x * float(\" +\n    offset +\n    \"); \\n\";\n\n  if (\n    batchTable._packFloats &&\n    attribute.componentDatatype !== PixelDatatype.UNSIGNED_BYTE\n  ) {\n    glslFunction +=\n      \"vec4 textureValue; \\n\" +\n      \"textureValue.x = czm_unpackFloat(texture2D(batchTexture, st)); \\n\" +\n      \"textureValue.y = czm_unpackFloat(texture2D(batchTexture, st + vec2(batchTextureStep.x, 0.0))); \\n\" +\n      \"textureValue.z = czm_unpackFloat(texture2D(batchTexture, st + vec2(batchTextureStep.x * 2.0, 0.0))); \\n\" +\n      \"textureValue.w = czm_unpackFloat(texture2D(batchTexture, st + vec2(batchTextureStep.x * 3.0, 0.0))); \\n\";\n  } else {\n    glslFunction += \"    vec4 textureValue = texture2D(batchTexture, st); \\n\";\n  }\n\n  glslFunction +=\n    \"    \" +\n    functionReturnType +\n    \" value = textureValue\" +\n    functionReturnValue +\n    \"; \\n\";\n\n  if (\n    batchTable._pixelDatatype === PixelDatatype.UNSIGNED_BYTE &&\n    attribute.componentDatatype === ComponentDatatype.UNSIGNED_BYTE &&\n    !attribute.normalize\n  ) {\n    glslFunction += \"value *= 255.0; \\n\";\n  } else if (\n    batchTable._pixelDatatype === PixelDatatype.FLOAT &&\n    attribute.componentDatatype === ComponentDatatype.UNSIGNED_BYTE &&\n    attribute.normalize\n  ) {\n    glslFunction += \"value /= 255.0; \\n\";\n  }\n\n  glslFunction += \"    return value; \\n\" + \"} \\n\";\n  return glslFunction;\n}\n\n/**\n * Gets a function that will update a vertex shader to contain functions for looking up values in the batch table.\n *\n * @returns {BatchTable~updateVertexShaderSourceCallback} A callback for updating a vertex shader source.\n */\nBatchTable.prototype.getVertexShaderCallback = function () {\n  var attributes = this._attributes;\n  if (attributes.length === 0) {\n    return function (source) {\n      return source;\n    };\n  }\n\n  var batchTableShader = \"uniform highp sampler2D batchTexture; \\n\";\n  batchTableShader += getGlslComputeSt(this) + \"\\n\";\n\n  var length = attributes.length;\n  for (var i = 0; i < length; ++i) {\n    batchTableShader += getGlslAttributeFunction(this, i);\n  }\n\n  return function (source) {\n    var mainIndex = source.indexOf(\"void main\");\n    var beforeMain = source.substring(0, mainIndex);\n    var afterMain = source.substring(mainIndex);\n    return beforeMain + \"\\n\" + batchTableShader + \"\\n\" + afterMain;\n  };\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see BatchTable#destroy\n */\nBatchTable.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see BatchTable#isDestroyed\n */\nBatchTable.prototype.destroy = function () {\n  this._texture = this._texture && this._texture.destroy();\n  return destroyObject(this);\n};\n\n/**\n * A callback for updating uniform maps.\n * @callback BatchTable~updateUniformMapCallback\n *\n * @param {Object} uniformMap The uniform map.\n * @returns {Object} The new uniform map with properties for retrieving values from the batch table.\n */\n\n/**\n * A callback for updating a vertex shader source.\n * @callback BatchTable~updateVertexShaderSourceCallback\n *\n * @param {String} vertexShaderSource The vertex shader source.\n * @returns {String} The new vertex shader source with the functions for retrieving batch table values injected.\n */\nexport default BatchTable;\n"]},"metadata":{},"sourceType":"module"}