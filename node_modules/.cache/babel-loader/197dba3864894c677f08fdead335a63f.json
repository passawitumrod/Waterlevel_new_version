{"ast":null,"code":"import Cartographic from \"./Cartographic.js\";\nimport defined from \"./defined.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport WindingOrder from \"./WindingOrder.js\";\n/**\n * @private\n */\n\nvar WallGeometryLibrary = {};\n\nfunction latLonEquals(c0, c1) {\n  return CesiumMath.equalsEpsilon(c0.latitude, c1.latitude, CesiumMath.EPSILON14) && CesiumMath.equalsEpsilon(c0.longitude, c1.longitude, CesiumMath.EPSILON14);\n}\n\nvar scratchCartographic1 = new Cartographic();\nvar scratchCartographic2 = new Cartographic();\n\nfunction removeDuplicates(ellipsoid, positions, topHeights, bottomHeights) {\n  var length = positions.length;\n\n  if (length < 2) {\n    return;\n  }\n\n  var hasBottomHeights = defined(bottomHeights);\n  var hasTopHeights = defined(topHeights);\n  var hasAllZeroHeights = true;\n  var cleanedPositions = new Array(length);\n  var cleanedTopHeights = new Array(length);\n  var cleanedBottomHeights = new Array(length);\n  var v0 = positions[0];\n  cleanedPositions[0] = v0;\n  var c0 = ellipsoid.cartesianToCartographic(v0, scratchCartographic1);\n\n  if (hasTopHeights) {\n    c0.height = topHeights[0];\n  }\n\n  hasAllZeroHeights = hasAllZeroHeights && c0.height <= 0;\n  cleanedTopHeights[0] = c0.height;\n\n  if (hasBottomHeights) {\n    cleanedBottomHeights[0] = bottomHeights[0];\n  } else {\n    cleanedBottomHeights[0] = 0.0;\n  }\n\n  var index = 1;\n\n  for (var i = 1; i < length; ++i) {\n    var v1 = positions[i];\n    var c1 = ellipsoid.cartesianToCartographic(v1, scratchCartographic2);\n\n    if (hasTopHeights) {\n      c1.height = topHeights[i];\n    }\n\n    hasAllZeroHeights = hasAllZeroHeights && c1.height <= 0;\n\n    if (!latLonEquals(c0, c1)) {\n      cleanedPositions[index] = v1; // Shallow copy!\n\n      cleanedTopHeights[index] = c1.height;\n\n      if (hasBottomHeights) {\n        cleanedBottomHeights[index] = bottomHeights[i];\n      } else {\n        cleanedBottomHeights[index] = 0.0;\n      }\n\n      Cartographic.clone(c1, c0);\n      ++index;\n    } else if (c0.height < c1.height) {\n      cleanedTopHeights[index - 1] = c1.height;\n    }\n  }\n\n  if (hasAllZeroHeights || index < 2) {\n    return;\n  }\n\n  cleanedPositions.length = index;\n  cleanedTopHeights.length = index;\n  cleanedBottomHeights.length = index;\n  return {\n    positions: cleanedPositions,\n    topHeights: cleanedTopHeights,\n    bottomHeights: cleanedBottomHeights\n  };\n}\n\nvar positionsArrayScratch = new Array(2);\nvar heightsArrayScratch = new Array(2);\nvar generateArcOptionsScratch = {\n  positions: undefined,\n  height: undefined,\n  granularity: undefined,\n  ellipsoid: undefined\n};\n/**\n * @private\n */\n\nWallGeometryLibrary.computePositions = function (ellipsoid, wallPositions, maximumHeights, minimumHeights, granularity, duplicateCorners) {\n  var o = removeDuplicates(ellipsoid, wallPositions, maximumHeights, minimumHeights);\n\n  if (!defined(o)) {\n    return;\n  }\n\n  wallPositions = o.positions;\n  maximumHeights = o.topHeights;\n  minimumHeights = o.bottomHeights;\n\n  if (wallPositions.length >= 3) {\n    // Order positions counter-clockwise\n    var tangentPlane = EllipsoidTangentPlane.fromPoints(wallPositions, ellipsoid);\n    var positions2D = tangentPlane.projectPointsOntoPlane(wallPositions);\n\n    if (PolygonPipeline.computeWindingOrder2D(positions2D) === WindingOrder.CLOCKWISE) {\n      wallPositions.reverse();\n      maximumHeights.reverse();\n      minimumHeights.reverse();\n    }\n  }\n\n  var length = wallPositions.length;\n  var numCorners = length - 2;\n  var topPositions;\n  var bottomPositions;\n  var minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n  var generateArcOptions = generateArcOptionsScratch;\n  generateArcOptions.minDistance = minDistance;\n  generateArcOptions.ellipsoid = ellipsoid;\n\n  if (duplicateCorners) {\n    var count = 0;\n    var i;\n\n    for (i = 0; i < length - 1; i++) {\n      count += PolylinePipeline.numberOfPoints(wallPositions[i], wallPositions[i + 1], minDistance) + 1;\n    }\n\n    topPositions = new Float64Array(count * 3);\n    bottomPositions = new Float64Array(count * 3);\n    var generateArcPositions = positionsArrayScratch;\n    var generateArcHeights = heightsArrayScratch;\n    generateArcOptions.positions = generateArcPositions;\n    generateArcOptions.height = generateArcHeights;\n    var offset = 0;\n\n    for (i = 0; i < length - 1; i++) {\n      generateArcPositions[0] = wallPositions[i];\n      generateArcPositions[1] = wallPositions[i + 1];\n      generateArcHeights[0] = maximumHeights[i];\n      generateArcHeights[1] = maximumHeights[i + 1];\n      var pos = PolylinePipeline.generateArc(generateArcOptions);\n      topPositions.set(pos, offset);\n      generateArcHeights[0] = minimumHeights[i];\n      generateArcHeights[1] = minimumHeights[i + 1];\n      bottomPositions.set(PolylinePipeline.generateArc(generateArcOptions), offset);\n      offset += pos.length;\n    }\n  } else {\n    generateArcOptions.positions = wallPositions;\n    generateArcOptions.height = maximumHeights;\n    topPositions = new Float64Array(PolylinePipeline.generateArc(generateArcOptions));\n    generateArcOptions.height = minimumHeights;\n    bottomPositions = new Float64Array(PolylinePipeline.generateArc(generateArcOptions));\n  }\n\n  return {\n    bottomPositions: bottomPositions,\n    topPositions: topPositions,\n    numCorners: numCorners\n  };\n};\n\nexport default WallGeometryLibrary;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/WallGeometryLibrary.js"],"names":["Cartographic","defined","EllipsoidTangentPlane","CesiumMath","PolygonPipeline","PolylinePipeline","WindingOrder","WallGeometryLibrary","latLonEquals","c0","c1","equalsEpsilon","latitude","EPSILON14","longitude","scratchCartographic1","scratchCartographic2","removeDuplicates","ellipsoid","positions","topHeights","bottomHeights","length","hasBottomHeights","hasTopHeights","hasAllZeroHeights","cleanedPositions","Array","cleanedTopHeights","cleanedBottomHeights","v0","cartesianToCartographic","height","index","i","v1","clone","positionsArrayScratch","heightsArrayScratch","generateArcOptionsScratch","undefined","granularity","computePositions","wallPositions","maximumHeights","minimumHeights","duplicateCorners","o","tangentPlane","fromPoints","positions2D","projectPointsOntoPlane","computeWindingOrder2D","CLOCKWISE","reverse","numCorners","topPositions","bottomPositions","minDistance","chordLength","maximumRadius","generateArcOptions","count","numberOfPoints","Float64Array","generateArcPositions","generateArcHeights","offset","pos","generateArc","set"],"mappings":"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","sourcesContent":["import Cartographic from \"./Cartographic.js\";\nimport defined from \"./defined.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport WindingOrder from \"./WindingOrder.js\";\n\n/**\n * @private\n */\nvar WallGeometryLibrary = {};\n\nfunction latLonEquals(c0, c1) {\n  return (\n    CesiumMath.equalsEpsilon(c0.latitude, c1.latitude, CesiumMath.EPSILON14) &&\n    CesiumMath.equalsEpsilon(c0.longitude, c1.longitude, CesiumMath.EPSILON14)\n  );\n}\n\nvar scratchCartographic1 = new Cartographic();\nvar scratchCartographic2 = new Cartographic();\nfunction removeDuplicates(ellipsoid, positions, topHeights, bottomHeights) {\n  var length = positions.length;\n  if (length < 2) {\n    return;\n  }\n\n  var hasBottomHeights = defined(bottomHeights);\n  var hasTopHeights = defined(topHeights);\n  var hasAllZeroHeights = true;\n\n  var cleanedPositions = new Array(length);\n  var cleanedTopHeights = new Array(length);\n  var cleanedBottomHeights = new Array(length);\n\n  var v0 = positions[0];\n  cleanedPositions[0] = v0;\n\n  var c0 = ellipsoid.cartesianToCartographic(v0, scratchCartographic1);\n  if (hasTopHeights) {\n    c0.height = topHeights[0];\n  }\n\n  hasAllZeroHeights = hasAllZeroHeights && c0.height <= 0;\n\n  cleanedTopHeights[0] = c0.height;\n\n  if (hasBottomHeights) {\n    cleanedBottomHeights[0] = bottomHeights[0];\n  } else {\n    cleanedBottomHeights[0] = 0.0;\n  }\n\n  var index = 1;\n  for (var i = 1; i < length; ++i) {\n    var v1 = positions[i];\n    var c1 = ellipsoid.cartesianToCartographic(v1, scratchCartographic2);\n    if (hasTopHeights) {\n      c1.height = topHeights[i];\n    }\n    hasAllZeroHeights = hasAllZeroHeights && c1.height <= 0;\n\n    if (!latLonEquals(c0, c1)) {\n      cleanedPositions[index] = v1; // Shallow copy!\n      cleanedTopHeights[index] = c1.height;\n\n      if (hasBottomHeights) {\n        cleanedBottomHeights[index] = bottomHeights[i];\n      } else {\n        cleanedBottomHeights[index] = 0.0;\n      }\n\n      Cartographic.clone(c1, c0);\n      ++index;\n    } else if (c0.height < c1.height) {\n      cleanedTopHeights[index - 1] = c1.height;\n    }\n  }\n\n  if (hasAllZeroHeights || index < 2) {\n    return;\n  }\n\n  cleanedPositions.length = index;\n  cleanedTopHeights.length = index;\n  cleanedBottomHeights.length = index;\n\n  return {\n    positions: cleanedPositions,\n    topHeights: cleanedTopHeights,\n    bottomHeights: cleanedBottomHeights,\n  };\n}\n\nvar positionsArrayScratch = new Array(2);\nvar heightsArrayScratch = new Array(2);\nvar generateArcOptionsScratch = {\n  positions: undefined,\n  height: undefined,\n  granularity: undefined,\n  ellipsoid: undefined,\n};\n\n/**\n * @private\n */\nWallGeometryLibrary.computePositions = function (\n  ellipsoid,\n  wallPositions,\n  maximumHeights,\n  minimumHeights,\n  granularity,\n  duplicateCorners\n) {\n  var o = removeDuplicates(\n    ellipsoid,\n    wallPositions,\n    maximumHeights,\n    minimumHeights\n  );\n\n  if (!defined(o)) {\n    return;\n  }\n\n  wallPositions = o.positions;\n  maximumHeights = o.topHeights;\n  minimumHeights = o.bottomHeights;\n\n  if (wallPositions.length >= 3) {\n    // Order positions counter-clockwise\n    var tangentPlane = EllipsoidTangentPlane.fromPoints(\n      wallPositions,\n      ellipsoid\n    );\n    var positions2D = tangentPlane.projectPointsOntoPlane(wallPositions);\n\n    if (\n      PolygonPipeline.computeWindingOrder2D(positions2D) ===\n      WindingOrder.CLOCKWISE\n    ) {\n      wallPositions.reverse();\n      maximumHeights.reverse();\n      minimumHeights.reverse();\n    }\n  }\n\n  var length = wallPositions.length;\n  var numCorners = length - 2;\n  var topPositions;\n  var bottomPositions;\n\n  var minDistance = CesiumMath.chordLength(\n    granularity,\n    ellipsoid.maximumRadius\n  );\n\n  var generateArcOptions = generateArcOptionsScratch;\n  generateArcOptions.minDistance = minDistance;\n  generateArcOptions.ellipsoid = ellipsoid;\n\n  if (duplicateCorners) {\n    var count = 0;\n    var i;\n\n    for (i = 0; i < length - 1; i++) {\n      count +=\n        PolylinePipeline.numberOfPoints(\n          wallPositions[i],\n          wallPositions[i + 1],\n          minDistance\n        ) + 1;\n    }\n\n    topPositions = new Float64Array(count * 3);\n    bottomPositions = new Float64Array(count * 3);\n\n    var generateArcPositions = positionsArrayScratch;\n    var generateArcHeights = heightsArrayScratch;\n    generateArcOptions.positions = generateArcPositions;\n    generateArcOptions.height = generateArcHeights;\n\n    var offset = 0;\n    for (i = 0; i < length - 1; i++) {\n      generateArcPositions[0] = wallPositions[i];\n      generateArcPositions[1] = wallPositions[i + 1];\n\n      generateArcHeights[0] = maximumHeights[i];\n      generateArcHeights[1] = maximumHeights[i + 1];\n\n      var pos = PolylinePipeline.generateArc(generateArcOptions);\n      topPositions.set(pos, offset);\n\n      generateArcHeights[0] = minimumHeights[i];\n      generateArcHeights[1] = minimumHeights[i + 1];\n\n      bottomPositions.set(\n        PolylinePipeline.generateArc(generateArcOptions),\n        offset\n      );\n\n      offset += pos.length;\n    }\n  } else {\n    generateArcOptions.positions = wallPositions;\n    generateArcOptions.height = maximumHeights;\n    topPositions = new Float64Array(\n      PolylinePipeline.generateArc(generateArcOptions)\n    );\n\n    generateArcOptions.height = minimumHeights;\n    bottomPositions = new Float64Array(\n      PolylinePipeline.generateArc(generateArcOptions)\n    );\n  }\n\n  return {\n    bottomPositions: bottomPositions,\n    topPositions: topPositions,\n    numCorners: numCorners,\n  };\n};\nexport default WallGeometryLibrary;\n"]},"metadata":{},"sourceType":"module"}