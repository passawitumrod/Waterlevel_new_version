{"ast":null,"code":"import defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport ImageryState from \"./ImageryState.js\";\n/**\n * Stores details about a tile of imagery.\n *\n * @alias Imagery\n * @private\n */\n\nfunction Imagery(imageryLayer, x, y, level, rectangle) {\n  this.imageryLayer = imageryLayer;\n  this.x = x;\n  this.y = y;\n  this.level = level;\n  this.request = undefined;\n\n  if (level !== 0) {\n    var parentX = x / 2 | 0;\n    var parentY = y / 2 | 0;\n    var parentLevel = level - 1;\n    this.parent = imageryLayer.getImageryFromCache(parentX, parentY, parentLevel);\n  }\n\n  this.state = ImageryState.UNLOADED;\n  this.imageUrl = undefined;\n  this.image = undefined;\n  this.texture = undefined;\n  this.textureWebMercator = undefined;\n  this.credits = undefined;\n  this.referenceCount = 0;\n\n  if (!defined(rectangle) && imageryLayer.imageryProvider.ready) {\n    var tilingScheme = imageryLayer.imageryProvider.tilingScheme;\n    rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n  }\n\n  this.rectangle = rectangle;\n}\n\nImagery.createPlaceholder = function (imageryLayer) {\n  var result = new Imagery(imageryLayer, 0, 0, 0);\n  result.addReference();\n  result.state = ImageryState.PLACEHOLDER;\n  return result;\n};\n\nImagery.prototype.addReference = function () {\n  ++this.referenceCount;\n};\n\nImagery.prototype.releaseReference = function () {\n  --this.referenceCount;\n\n  if (this.referenceCount === 0) {\n    this.imageryLayer.removeImageryFromCache(this);\n\n    if (defined(this.parent)) {\n      this.parent.releaseReference();\n    }\n\n    if (defined(this.image) && defined(this.image.destroy)) {\n      this.image.destroy();\n    }\n\n    if (defined(this.texture)) {\n      this.texture.destroy();\n    }\n\n    if (defined(this.textureWebMercator) && this.texture !== this.textureWebMercator) {\n      this.textureWebMercator.destroy();\n    }\n\n    destroyObject(this);\n    return 0;\n  }\n\n  return this.referenceCount;\n};\n\nImagery.prototype.processStateMachine = function (frameState, needGeographicProjection, skipLoading) {\n  if (this.state === ImageryState.UNLOADED && !skipLoading) {\n    this.state = ImageryState.TRANSITIONING;\n\n    this.imageryLayer._requestImagery(this);\n  }\n\n  if (this.state === ImageryState.RECEIVED) {\n    this.state = ImageryState.TRANSITIONING;\n\n    this.imageryLayer._createTexture(frameState.context, this);\n  } // If the imagery is already ready, but we need a geographic version and don't have it yet,\n  // we still need to do the reprojection step. This can happen if the Web Mercator version\n  // is fine initially, but the geographic one is needed later.\n\n\n  var needsReprojection = this.state === ImageryState.READY && needGeographicProjection && !this.texture;\n\n  if (this.state === ImageryState.TEXTURE_LOADED || needsReprojection) {\n    this.state = ImageryState.TRANSITIONING;\n\n    this.imageryLayer._reprojectTexture(frameState, this, needGeographicProjection);\n  }\n};\n\nexport default Imagery;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/Imagery.js"],"names":["defined","destroyObject","ImageryState","Imagery","imageryLayer","x","y","level","rectangle","request","undefined","parentX","parentY","parentLevel","parent","getImageryFromCache","state","UNLOADED","imageUrl","image","texture","textureWebMercator","credits","referenceCount","imageryProvider","ready","tilingScheme","tileXYToRectangle","createPlaceholder","result","addReference","PLACEHOLDER","prototype","releaseReference","removeImageryFromCache","destroy","processStateMachine","frameState","needGeographicProjection","skipLoading","TRANSITIONING","_requestImagery","RECEIVED","_createTexture","context","needsReprojection","READY","TEXTURE_LOADED","_reprojectTexture"],"mappings":"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","sourcesContent":["import defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport ImageryState from \"./ImageryState.js\";\n\n/**\n * Stores details about a tile of imagery.\n *\n * @alias Imagery\n * @private\n */\nfunction Imagery(imageryLayer, x, y, level, rectangle) {\n  this.imageryLayer = imageryLayer;\n  this.x = x;\n  this.y = y;\n  this.level = level;\n  this.request = undefined;\n\n  if (level !== 0) {\n    var parentX = (x / 2) | 0;\n    var parentY = (y / 2) | 0;\n    var parentLevel = level - 1;\n    this.parent = imageryLayer.getImageryFromCache(\n      parentX,\n      parentY,\n      parentLevel\n    );\n  }\n\n  this.state = ImageryState.UNLOADED;\n  this.imageUrl = undefined;\n  this.image = undefined;\n  this.texture = undefined;\n  this.textureWebMercator = undefined;\n  this.credits = undefined;\n  this.referenceCount = 0;\n\n  if (!defined(rectangle) && imageryLayer.imageryProvider.ready) {\n    var tilingScheme = imageryLayer.imageryProvider.tilingScheme;\n    rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n  }\n\n  this.rectangle = rectangle;\n}\nImagery.createPlaceholder = function (imageryLayer) {\n  var result = new Imagery(imageryLayer, 0, 0, 0);\n  result.addReference();\n  result.state = ImageryState.PLACEHOLDER;\n  return result;\n};\n\nImagery.prototype.addReference = function () {\n  ++this.referenceCount;\n};\n\nImagery.prototype.releaseReference = function () {\n  --this.referenceCount;\n\n  if (this.referenceCount === 0) {\n    this.imageryLayer.removeImageryFromCache(this);\n\n    if (defined(this.parent)) {\n      this.parent.releaseReference();\n    }\n\n    if (defined(this.image) && defined(this.image.destroy)) {\n      this.image.destroy();\n    }\n\n    if (defined(this.texture)) {\n      this.texture.destroy();\n    }\n\n    if (\n      defined(this.textureWebMercator) &&\n      this.texture !== this.textureWebMercator\n    ) {\n      this.textureWebMercator.destroy();\n    }\n\n    destroyObject(this);\n\n    return 0;\n  }\n\n  return this.referenceCount;\n};\n\nImagery.prototype.processStateMachine = function (\n  frameState,\n  needGeographicProjection,\n  skipLoading\n) {\n  if (this.state === ImageryState.UNLOADED && !skipLoading) {\n    this.state = ImageryState.TRANSITIONING;\n    this.imageryLayer._requestImagery(this);\n  }\n\n  if (this.state === ImageryState.RECEIVED) {\n    this.state = ImageryState.TRANSITIONING;\n    this.imageryLayer._createTexture(frameState.context, this);\n  }\n\n  // If the imagery is already ready, but we need a geographic version and don't have it yet,\n  // we still need to do the reprojection step. This can happen if the Web Mercator version\n  // is fine initially, but the geographic one is needed later.\n  var needsReprojection =\n    this.state === ImageryState.READY &&\n    needGeographicProjection &&\n    !this.texture;\n\n  if (this.state === ImageryState.TEXTURE_LOADED || needsReprojection) {\n    this.state = ImageryState.TRANSITIONING;\n    this.imageryLayer._reprojectTexture(\n      frameState,\n      this,\n      needGeographicProjection\n    );\n  }\n};\nexport default Imagery;\n"]},"metadata":{},"sourceType":"module"}