{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArrayFacade from \"../Renderer/VertexArrayFacade.js\";\nimport PointPrimitiveCollectionFS from \"../Shaders/PointPrimitiveCollectionFS.js\";\nimport PointPrimitiveCollectionVS from \"../Shaders/PointPrimitiveCollectionVS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport BlendOption from \"./BlendOption.js\";\nimport PointPrimitive from \"./PointPrimitive.js\";\nimport SceneMode from \"./SceneMode.js\";\nvar SHOW_INDEX = PointPrimitive.SHOW_INDEX;\nvar POSITION_INDEX = PointPrimitive.POSITION_INDEX;\nvar COLOR_INDEX = PointPrimitive.COLOR_INDEX;\nvar OUTLINE_COLOR_INDEX = PointPrimitive.OUTLINE_COLOR_INDEX;\nvar OUTLINE_WIDTH_INDEX = PointPrimitive.OUTLINE_WIDTH_INDEX;\nvar PIXEL_SIZE_INDEX = PointPrimitive.PIXEL_SIZE_INDEX;\nvar SCALE_BY_DISTANCE_INDEX = PointPrimitive.SCALE_BY_DISTANCE_INDEX;\nvar TRANSLUCENCY_BY_DISTANCE_INDEX = PointPrimitive.TRANSLUCENCY_BY_DISTANCE_INDEX;\nvar DISTANCE_DISPLAY_CONDITION_INDEX = PointPrimitive.DISTANCE_DISPLAY_CONDITION_INDEX;\nvar DISABLE_DEPTH_DISTANCE_INDEX = PointPrimitive.DISABLE_DEPTH_DISTANCE_INDEX;\nvar NUMBER_OF_PROPERTIES = PointPrimitive.NUMBER_OF_PROPERTIES;\nvar attributeLocations = {\n  positionHighAndSize: 0,\n  positionLowAndOutline: 1,\n  compressedAttribute0: 2,\n  // color, outlineColor, pick color\n  compressedAttribute1: 3,\n  // show, translucency by distance, some free space\n  scaleByDistance: 4,\n  distanceDisplayConditionAndDisableDepth: 5\n};\n/**\n * A renderable collection of points.\n * <br /><br />\n * Points are added and removed from the collection using {@link PointPrimitiveCollection#add}\n * and {@link PointPrimitiveCollection#remove}.\n *\n * @alias PointPrimitiveCollection\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each point from model to world coordinates.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {BlendOption} [options.blendOption=BlendOption.OPAQUE_AND_TRANSLUCENT] The point blending option. The default\n * is used for rendering both opaque and translucent points. However, if either all of the points are completely opaque or all are completely translucent,\n * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve performance by up to 2x.\n *\n * @performance For best performance, prefer a few collections, each with many points, to\n * many collections with only a few points each.  Organize collections so that points\n * with the same update frequency are in the same collection, i.e., points that do not\n * change should be in one collection; points that change every frame should be in another\n * collection; and so on.\n *\n *\n * @example\n * // Create a pointPrimitive collection with two points\n * var points = scene.primitives.add(new Cesium.PointPrimitiveCollection());\n * points.add({\n *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),\n *   color : Cesium.Color.YELLOW\n * });\n * points.add({\n *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),\n *   color : Cesium.Color.CYAN\n * });\n *\n * @see PointPrimitiveCollection#add\n * @see PointPrimitiveCollection#remove\n * @see PointPrimitive\n */\n\nfunction PointPrimitiveCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  this._sp = undefined;\n  this._spTranslucent = undefined;\n  this._rsOpaque = undefined;\n  this._rsTranslucent = undefined;\n  this._vaf = undefined;\n  this._pointPrimitives = [];\n  this._pointPrimitivesToUpdate = [];\n  this._pointPrimitivesToUpdateIndex = 0;\n  this._pointPrimitivesRemoved = false;\n  this._createVertexArray = false;\n  this._shaderScaleByDistance = false;\n  this._compiledShaderScaleByDistance = false;\n  this._shaderTranslucencyByDistance = false;\n  this._compiledShaderTranslucencyByDistance = false;\n  this._shaderDistanceDisplayCondition = false;\n  this._compiledShaderDistanceDisplayCondition = false;\n  this._shaderDisableDepthDistance = false;\n  this._compiledShaderDisableDepthDistance = false;\n  this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);\n  this._maxPixelSize = 1.0;\n  this._baseVolume = new BoundingSphere();\n  this._baseVolumeWC = new BoundingSphere();\n  this._baseVolume2D = new BoundingSphere();\n  this._boundingVolume = new BoundingSphere();\n  this._boundingVolumeDirty = false;\n  this._colorCommands = [];\n  /**\n   * The 4x4 transformation matrix that transforms each point in this collection from model to world coordinates.\n   * When this is the identity matrix, the pointPrimitives are drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type {Matrix4}\n   * @default {@link Matrix4.IDENTITY}\n   *\n   *\n   * @example\n   * var center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n   * pointPrimitives.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n   * pointPrimitives.add({\n   *   color : Cesium.Color.ORANGE,\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0) // center\n   * });\n   * pointPrimitives.add({\n   *   color : Cesium.Color.YELLOW,\n   *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0) // east\n   * });\n   * pointPrimitives.add({\n   *   color : Cesium.Color.GREEN,\n   *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0) // north\n   * });\n   * pointPrimitives.add({\n   *   color : Cesium.Color.CYAN,\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0) // up\n   * });\n   *\n   * @see Transforms.eastNorthUpToFixedFrame\n   */\n\n  this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));\n  this._modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n\n  this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);\n  /**\n   * The point blending option. The default is used for rendering both opaque and translucent points.\n   * However, if either all of the points are completely opaque or all are completely translucent,\n   * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve\n   * performance by up to 2x.\n   * @type {BlendOption}\n   * @default BlendOption.OPAQUE_AND_TRANSLUCENT\n   */\n\n  this.blendOption = defaultValue(options.blendOption, BlendOption.OPAQUE_AND_TRANSLUCENT);\n  this._blendOption = undefined;\n  this._mode = SceneMode.SCENE3D;\n  this._maxTotalPointSize = 1; // The buffer usage for each attribute is determined based on the usage of the attribute over time.\n\n  this._buffersUsage = [BufferUsage.STATIC_DRAW, // SHOW_INDEX\n  BufferUsage.STATIC_DRAW, // POSITION_INDEX\n  BufferUsage.STATIC_DRAW, // COLOR_INDEX\n  BufferUsage.STATIC_DRAW, // OUTLINE_COLOR_INDEX\n  BufferUsage.STATIC_DRAW, // OUTLINE_WIDTH_INDEX\n  BufferUsage.STATIC_DRAW, // PIXEL_SIZE_INDEX\n  BufferUsage.STATIC_DRAW, // SCALE_BY_DISTANCE_INDEX\n  BufferUsage.STATIC_DRAW, // TRANSLUCENCY_BY_DISTANCE_INDEX\n  BufferUsage.STATIC_DRAW // DISTANCE_DISPLAY_CONDITION_INDEX\n  ];\n  var that = this;\n  this._uniforms = {\n    u_maxTotalPointSize: function u_maxTotalPointSize() {\n      return that._maxTotalPointSize;\n    }\n  };\n}\n\nObject.defineProperties(PointPrimitiveCollection.prototype, {\n  /**\n   * Returns the number of points in this collection.  This is commonly used with\n   * {@link PointPrimitiveCollection#get} to iterate over all the points\n   * in the collection.\n   * @memberof PointPrimitiveCollection.prototype\n   * @type {Number}\n   */\n  length: {\n    get: function get() {\n      removePointPrimitives(this);\n      return this._pointPrimitives.length;\n    }\n  }\n});\n\nfunction destroyPointPrimitives(pointPrimitives) {\n  var length = pointPrimitives.length;\n\n  for (var i = 0; i < length; ++i) {\n    if (pointPrimitives[i]) {\n      pointPrimitives[i]._destroy();\n    }\n  }\n}\n/**\n * Creates and adds a point with the specified initial properties to the collection.\n * The added point is returned so it can be modified or removed from the collection later.\n *\n * @param {Object}[options] A template describing the point's properties as shown in Example 1.\n * @returns {PointPrimitive} The point that was added to the collection.\n *\n * @performance Calling <code>add</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, add as many pointPrimitives as possible before calling <code>update</code>.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Example 1:  Add a point, specifying all the default values.\n * var p = pointPrimitives.add({\n *   show : true,\n *   position : Cesium.Cartesian3.ZERO,\n *   pixelSize : 10.0,\n *   color : Cesium.Color.WHITE,\n *   outlineColor : Cesium.Color.TRANSPARENT,\n *   outlineWidth : 0.0,\n *   id : undefined\n * });\n *\n * @example\n * // Example 2:  Specify only the point's cartographic position.\n * var p = pointPrimitives.add({\n *   position : Cesium.Cartesian3.fromDegrees(longitude, latitude, height)\n * });\n *\n * @see PointPrimitiveCollection#remove\n * @see PointPrimitiveCollection#removeAll\n */\n\n\nPointPrimitiveCollection.prototype.add = function (options) {\n  var p = new PointPrimitive(options, this);\n  p._index = this._pointPrimitives.length;\n\n  this._pointPrimitives.push(p);\n\n  this._createVertexArray = true;\n  return p;\n};\n/**\n * Removes a point from the collection.\n *\n * @param {PointPrimitive} pointPrimitive The point to remove.\n * @returns {Boolean} <code>true</code> if the point was removed; <code>false</code> if the point was not found in the collection.\n *\n * @performance Calling <code>remove</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, remove as many points as possible before calling <code>update</code>.\n * If you intend to temporarily hide a point, it is usually more efficient to call\n * {@link PointPrimitive#show} instead of removing and re-adding the point.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * var p = pointPrimitives.add(...);\n * pointPrimitives.remove(p);  // Returns true\n *\n * @see PointPrimitiveCollection#add\n * @see PointPrimitiveCollection#removeAll\n * @see PointPrimitive#show\n */\n\n\nPointPrimitiveCollection.prototype.remove = function (pointPrimitive) {\n  if (this.contains(pointPrimitive)) {\n    this._pointPrimitives[pointPrimitive._index] = null; // Removed later\n\n    this._pointPrimitivesRemoved = true;\n    this._createVertexArray = true;\n\n    pointPrimitive._destroy();\n\n    return true;\n  }\n\n  return false;\n};\n/**\n * Removes all points from the collection.\n *\n * @performance <code>O(n)</code>.  It is more efficient to remove all the points\n * from a collection and then add new ones than to create a new collection entirely.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * pointPrimitives.add(...);\n * pointPrimitives.add(...);\n * pointPrimitives.removeAll();\n *\n * @see PointPrimitiveCollection#add\n * @see PointPrimitiveCollection#remove\n */\n\n\nPointPrimitiveCollection.prototype.removeAll = function () {\n  destroyPointPrimitives(this._pointPrimitives);\n  this._pointPrimitives = [];\n  this._pointPrimitivesToUpdate = [];\n  this._pointPrimitivesToUpdateIndex = 0;\n  this._pointPrimitivesRemoved = false;\n  this._createVertexArray = true;\n};\n\nfunction removePointPrimitives(pointPrimitiveCollection) {\n  if (pointPrimitiveCollection._pointPrimitivesRemoved) {\n    pointPrimitiveCollection._pointPrimitivesRemoved = false;\n    var newPointPrimitives = [];\n    var pointPrimitives = pointPrimitiveCollection._pointPrimitives;\n    var length = pointPrimitives.length;\n\n    for (var i = 0, j = 0; i < length; ++i) {\n      var pointPrimitive = pointPrimitives[i];\n\n      if (pointPrimitive) {\n        pointPrimitive._index = j++;\n        newPointPrimitives.push(pointPrimitive);\n      }\n    }\n\n    pointPrimitiveCollection._pointPrimitives = newPointPrimitives;\n  }\n}\n\nPointPrimitiveCollection.prototype._updatePointPrimitive = function (pointPrimitive, propertyChanged) {\n  if (!pointPrimitive._dirty) {\n    this._pointPrimitivesToUpdate[this._pointPrimitivesToUpdateIndex++] = pointPrimitive;\n  }\n\n  ++this._propertiesChanged[propertyChanged];\n};\n/**\n * Check whether this collection contains a given point.\n *\n * @param {PointPrimitive} [pointPrimitive] The point to check for.\n * @returns {Boolean} true if this collection contains the point, false otherwise.\n *\n * @see PointPrimitiveCollection#get\n */\n\n\nPointPrimitiveCollection.prototype.contains = function (pointPrimitive) {\n  return defined(pointPrimitive) && pointPrimitive._pointPrimitiveCollection === this;\n};\n/**\n * Returns the point in the collection at the specified index.  Indices are zero-based\n * and increase as points are added.  Removing a point shifts all points after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link PointPrimitiveCollection#length} to iterate over all the points\n * in the collection.\n *\n * @param {Number} index The zero-based index of the point.\n * @returns {PointPrimitive} The point at the specified index.\n *\n * @performance Expected constant time.  If points were removed from the collection and\n * {@link PointPrimitiveCollection#update} was not called, an implicit <code>O(n)</code>\n * operation is performed.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Toggle the show property of every point in the collection\n * var len = pointPrimitives.length;\n * for (var i = 0; i < len; ++i) {\n *   var p = pointPrimitives.get(i);\n *   p.show = !p.show;\n * }\n *\n * @see PointPrimitiveCollection#length\n */\n\n\nPointPrimitiveCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  } //>>includeEnd('debug');\n\n\n  removePointPrimitives(this);\n  return this._pointPrimitives[index];\n};\n\nPointPrimitiveCollection.prototype.computeNewBuffersUsage = function () {\n  var buffersUsage = this._buffersUsage;\n  var usageChanged = false;\n  var properties = this._propertiesChanged;\n\n  for (var k = 0; k < NUMBER_OF_PROPERTIES; ++k) {\n    var newUsage = properties[k] === 0 ? BufferUsage.STATIC_DRAW : BufferUsage.STREAM_DRAW;\n    usageChanged = usageChanged || buffersUsage[k] !== newUsage;\n    buffersUsage[k] = newUsage;\n  }\n\n  return usageChanged;\n};\n\nfunction createVAF(context, numberOfPointPrimitives, buffersUsage) {\n  return new VertexArrayFacade(context, [{\n    index: attributeLocations.positionHighAndSize,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[POSITION_INDEX]\n  }, {\n    index: attributeLocations.positionLowAndShow,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[POSITION_INDEX]\n  }, {\n    index: attributeLocations.compressedAttribute0,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[COLOR_INDEX]\n  }, {\n    index: attributeLocations.compressedAttribute1,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[TRANSLUCENCY_BY_DISTANCE_INDEX]\n  }, {\n    index: attributeLocations.scaleByDistance,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[SCALE_BY_DISTANCE_INDEX]\n  }, {\n    index: attributeLocations.distanceDisplayConditionAndDisableDepth,\n    componentsPerAttribute: 3,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[DISTANCE_DISPLAY_CONDITION_INDEX]\n  }], numberOfPointPrimitives); // 1 vertex per pointPrimitive\n} ///////////////////////////////////////////////////////////////////////////\n// PERFORMANCE_IDEA:  Save memory if a property is the same for all pointPrimitives, use a latched attribute state,\n// instead of storing it in a vertex buffer.\n\n\nvar writePositionScratch = new EncodedCartesian3();\n\nfunction writePositionSizeAndOutline(pointPrimitiveCollection, context, vafWriters, pointPrimitive) {\n  var i = pointPrimitive._index;\n\n  var position = pointPrimitive._getActualPosition();\n\n  if (pointPrimitiveCollection._mode === SceneMode.SCENE3D) {\n    BoundingSphere.expand(pointPrimitiveCollection._baseVolume, position, pointPrimitiveCollection._baseVolume);\n    pointPrimitiveCollection._boundingVolumeDirty = true;\n  }\n\n  EncodedCartesian3.fromCartesian(position, writePositionScratch);\n  var pixelSize = pointPrimitive.pixelSize;\n  var outlineWidth = pointPrimitive.outlineWidth;\n  pointPrimitiveCollection._maxPixelSize = Math.max(pointPrimitiveCollection._maxPixelSize, pixelSize + outlineWidth);\n  var positionHighWriter = vafWriters[attributeLocations.positionHighAndSize];\n  var high = writePositionScratch.high;\n  positionHighWriter(i, high.x, high.y, high.z, pixelSize);\n  var positionLowWriter = vafWriters[attributeLocations.positionLowAndOutline];\n  var low = writePositionScratch.low;\n  positionLowWriter(i, low.x, low.y, low.z, outlineWidth);\n}\n\nvar LEFT_SHIFT16 = 65536.0; // 2^16\n\nvar LEFT_SHIFT8 = 256.0; // 2^8\n\nfunction writeCompressedAttrib0(pointPrimitiveCollection, context, vafWriters, pointPrimitive) {\n  var i = pointPrimitive._index;\n  var color = pointPrimitive.color;\n  var pickColor = pointPrimitive.getPickId(context).color;\n  var outlineColor = pointPrimitive.outlineColor;\n  var red = Color.floatToByte(color.red);\n  var green = Color.floatToByte(color.green);\n  var blue = Color.floatToByte(color.blue);\n  var compressed0 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n  red = Color.floatToByte(outlineColor.red);\n  green = Color.floatToByte(outlineColor.green);\n  blue = Color.floatToByte(outlineColor.blue);\n  var compressed1 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n  red = Color.floatToByte(pickColor.red);\n  green = Color.floatToByte(pickColor.green);\n  blue = Color.floatToByte(pickColor.blue);\n  var compressed2 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n  var compressed3 = Color.floatToByte(color.alpha) * LEFT_SHIFT16 + Color.floatToByte(outlineColor.alpha) * LEFT_SHIFT8 + Color.floatToByte(pickColor.alpha);\n  var writer = vafWriters[attributeLocations.compressedAttribute0];\n  writer(i, compressed0, compressed1, compressed2, compressed3);\n}\n\nfunction writeCompressedAttrib1(pointPrimitiveCollection, context, vafWriters, pointPrimitive) {\n  var i = pointPrimitive._index;\n  var near = 0.0;\n  var nearValue = 1.0;\n  var far = 1.0;\n  var farValue = 1.0;\n  var translucency = pointPrimitive.translucencyByDistance;\n\n  if (defined(translucency)) {\n    near = translucency.near;\n    nearValue = translucency.nearValue;\n    far = translucency.far;\n    farValue = translucency.farValue;\n\n    if (nearValue !== 1.0 || farValue !== 1.0) {\n      // translucency by distance calculation in shader need not be enabled\n      // until a pointPrimitive with near and far !== 1.0 is found\n      pointPrimitiveCollection._shaderTranslucencyByDistance = true;\n    }\n  }\n\n  var show = pointPrimitive.show && pointPrimitive.clusterShow; // If the color alphas are zero, do not show this pointPrimitive.  This lets us avoid providing\n  // color during the pick pass and also eliminates a discard in the fragment shader.\n\n  if (pointPrimitive.color.alpha === 0.0 && pointPrimitive.outlineColor.alpha === 0.0) {\n    show = false;\n  }\n\n  nearValue = CesiumMath.clamp(nearValue, 0.0, 1.0);\n  nearValue = nearValue === 1.0 ? 255.0 : nearValue * 255.0 | 0;\n  var compressed0 = (show ? 1.0 : 0.0) * LEFT_SHIFT8 + nearValue;\n  farValue = CesiumMath.clamp(farValue, 0.0, 1.0);\n  farValue = farValue === 1.0 ? 255.0 : farValue * 255.0 | 0;\n  var compressed1 = farValue;\n  var writer = vafWriters[attributeLocations.compressedAttribute1];\n  writer(i, compressed0, compressed1, near, far);\n}\n\nfunction writeScaleByDistance(pointPrimitiveCollection, context, vafWriters, pointPrimitive) {\n  var i = pointPrimitive._index;\n  var writer = vafWriters[attributeLocations.scaleByDistance];\n  var near = 0.0;\n  var nearValue = 1.0;\n  var far = 1.0;\n  var farValue = 1.0;\n  var scale = pointPrimitive.scaleByDistance;\n\n  if (defined(scale)) {\n    near = scale.near;\n    nearValue = scale.nearValue;\n    far = scale.far;\n    farValue = scale.farValue;\n\n    if (nearValue !== 1.0 || farValue !== 1.0) {\n      // scale by distance calculation in shader need not be enabled\n      // until a pointPrimitive with near and far !== 1.0 is found\n      pointPrimitiveCollection._shaderScaleByDistance = true;\n    }\n  }\n\n  writer(i, near, nearValue, far, farValue);\n}\n\nfunction writeDistanceDisplayConditionAndDepthDisable(pointPrimitiveCollection, context, vafWriters, pointPrimitive) {\n  var i = pointPrimitive._index;\n  var writer = vafWriters[attributeLocations.distanceDisplayConditionAndDisableDepth];\n  var near = 0.0;\n  var far = Number.MAX_VALUE;\n  var distanceDisplayCondition = pointPrimitive.distanceDisplayCondition;\n\n  if (defined(distanceDisplayCondition)) {\n    near = distanceDisplayCondition.near;\n    far = distanceDisplayCondition.far;\n    near *= near;\n    far *= far;\n    pointPrimitiveCollection._shaderDistanceDisplayCondition = true;\n  }\n\n  var disableDepthTestDistance = pointPrimitive.disableDepthTestDistance;\n  disableDepthTestDistance *= disableDepthTestDistance;\n\n  if (disableDepthTestDistance > 0.0) {\n    pointPrimitiveCollection._shaderDisableDepthDistance = true;\n\n    if (disableDepthTestDistance === Number.POSITIVE_INFINITY) {\n      disableDepthTestDistance = -1.0;\n    }\n  }\n\n  writer(i, near, far, disableDepthTestDistance);\n}\n\nfunction writePointPrimitive(pointPrimitiveCollection, context, vafWriters, pointPrimitive) {\n  writePositionSizeAndOutline(pointPrimitiveCollection, context, vafWriters, pointPrimitive);\n  writeCompressedAttrib0(pointPrimitiveCollection, context, vafWriters, pointPrimitive);\n  writeCompressedAttrib1(pointPrimitiveCollection, context, vafWriters, pointPrimitive);\n  writeScaleByDistance(pointPrimitiveCollection, context, vafWriters, pointPrimitive);\n  writeDistanceDisplayConditionAndDepthDisable(pointPrimitiveCollection, context, vafWriters, pointPrimitive);\n}\n\nfunction recomputeActualPositions(pointPrimitiveCollection, pointPrimitives, length, frameState, modelMatrix, recomputeBoundingVolume) {\n  var boundingVolume;\n\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingVolume = pointPrimitiveCollection._baseVolume;\n    pointPrimitiveCollection._boundingVolumeDirty = true;\n  } else {\n    boundingVolume = pointPrimitiveCollection._baseVolume2D;\n  }\n\n  var positions = [];\n\n  for (var i = 0; i < length; ++i) {\n    var pointPrimitive = pointPrimitives[i];\n    var position = pointPrimitive.position;\n\n    var actualPosition = PointPrimitive._computeActualPosition(position, frameState, modelMatrix);\n\n    if (defined(actualPosition)) {\n      pointPrimitive._setActualPosition(actualPosition);\n\n      if (recomputeBoundingVolume) {\n        positions.push(actualPosition);\n      } else {\n        BoundingSphere.expand(boundingVolume, actualPosition, boundingVolume);\n      }\n    }\n  }\n\n  if (recomputeBoundingVolume) {\n    BoundingSphere.fromPoints(positions, boundingVolume);\n  }\n}\n\nfunction updateMode(pointPrimitiveCollection, frameState) {\n  var mode = frameState.mode;\n  var pointPrimitives = pointPrimitiveCollection._pointPrimitives;\n  var pointPrimitivesToUpdate = pointPrimitiveCollection._pointPrimitivesToUpdate;\n  var modelMatrix = pointPrimitiveCollection._modelMatrix;\n\n  if (pointPrimitiveCollection._createVertexArray || pointPrimitiveCollection._mode !== mode || mode !== SceneMode.SCENE3D && !Matrix4.equals(modelMatrix, pointPrimitiveCollection.modelMatrix)) {\n    pointPrimitiveCollection._mode = mode;\n    Matrix4.clone(pointPrimitiveCollection.modelMatrix, modelMatrix);\n    pointPrimitiveCollection._createVertexArray = true;\n\n    if (mode === SceneMode.SCENE3D || mode === SceneMode.SCENE2D || mode === SceneMode.COLUMBUS_VIEW) {\n      recomputeActualPositions(pointPrimitiveCollection, pointPrimitives, pointPrimitives.length, frameState, modelMatrix, true);\n    }\n  } else if (mode === SceneMode.MORPHING) {\n    recomputeActualPositions(pointPrimitiveCollection, pointPrimitives, pointPrimitives.length, frameState, modelMatrix, true);\n  } else if (mode === SceneMode.SCENE2D || mode === SceneMode.COLUMBUS_VIEW) {\n    recomputeActualPositions(pointPrimitiveCollection, pointPrimitivesToUpdate, pointPrimitiveCollection._pointPrimitivesToUpdateIndex, frameState, modelMatrix, false);\n  }\n}\n\nfunction updateBoundingVolume(collection, frameState, boundingVolume) {\n  var pixelSize = frameState.camera.getPixelSize(boundingVolume, frameState.context.drawingBufferWidth, frameState.context.drawingBufferHeight);\n  var size = pixelSize * collection._maxPixelSize;\n  boundingVolume.radius += size;\n}\n\nvar scratchWriterArray = [];\n/**\n * @private\n */\n\nPointPrimitiveCollection.prototype.update = function (frameState) {\n  removePointPrimitives(this);\n  this._maxTotalPointSize = ContextLimits.maximumAliasedPointSize;\n  updateMode(this, frameState);\n  var pointPrimitives = this._pointPrimitives;\n  var pointPrimitivesLength = pointPrimitives.length;\n  var pointPrimitivesToUpdate = this._pointPrimitivesToUpdate;\n  var pointPrimitivesToUpdateLength = this._pointPrimitivesToUpdateIndex;\n  var properties = this._propertiesChanged;\n  var createVertexArray = this._createVertexArray;\n  var vafWriters;\n  var context = frameState.context;\n  var pass = frameState.passes;\n  var picking = pass.pick; // PERFORMANCE_IDEA: Round robin multiple buffers.\n\n  if (createVertexArray || !picking && this.computeNewBuffersUsage()) {\n    this._createVertexArray = false;\n\n    for (var k = 0; k < NUMBER_OF_PROPERTIES; ++k) {\n      properties[k] = 0;\n    }\n\n    this._vaf = this._vaf && this._vaf.destroy();\n\n    if (pointPrimitivesLength > 0) {\n      // PERFORMANCE_IDEA:  Instead of creating a new one, resize like std::vector.\n      this._vaf = createVAF(context, pointPrimitivesLength, this._buffersUsage);\n      vafWriters = this._vaf.writers; // Rewrite entire buffer if pointPrimitives were added or removed.\n\n      for (var i = 0; i < pointPrimitivesLength; ++i) {\n        var pointPrimitive = this._pointPrimitives[i];\n        pointPrimitive._dirty = false; // In case it needed an update.\n\n        writePointPrimitive(this, context, vafWriters, pointPrimitive);\n      }\n\n      this._vaf.commit();\n    }\n\n    this._pointPrimitivesToUpdateIndex = 0;\n  } else if (pointPrimitivesToUpdateLength > 0) {\n    // PointPrimitives were modified, but none were added or removed.\n    var writers = scratchWriterArray;\n    writers.length = 0;\n\n    if (properties[POSITION_INDEX] || properties[OUTLINE_WIDTH_INDEX] || properties[PIXEL_SIZE_INDEX]) {\n      writers.push(writePositionSizeAndOutline);\n    }\n\n    if (properties[COLOR_INDEX] || properties[OUTLINE_COLOR_INDEX]) {\n      writers.push(writeCompressedAttrib0);\n    }\n\n    if (properties[SHOW_INDEX] || properties[TRANSLUCENCY_BY_DISTANCE_INDEX]) {\n      writers.push(writeCompressedAttrib1);\n    }\n\n    if (properties[SCALE_BY_DISTANCE_INDEX]) {\n      writers.push(writeScaleByDistance);\n    }\n\n    if (properties[DISTANCE_DISPLAY_CONDITION_INDEX] || properties[DISABLE_DEPTH_DISTANCE_INDEX]) {\n      writers.push(writeDistanceDisplayConditionAndDepthDisable);\n    }\n\n    var numWriters = writers.length;\n    vafWriters = this._vaf.writers;\n\n    if (pointPrimitivesToUpdateLength / pointPrimitivesLength > 0.1) {\n      // If more than 10% of pointPrimitive change, rewrite the entire buffer.\n      // PERFORMANCE_IDEA:  I totally made up 10% :).\n      for (var m = 0; m < pointPrimitivesToUpdateLength; ++m) {\n        var b = pointPrimitivesToUpdate[m];\n        b._dirty = false;\n\n        for (var n = 0; n < numWriters; ++n) {\n          writers[n](this, context, vafWriters, b);\n        }\n      }\n\n      this._vaf.commit();\n    } else {\n      for (var h = 0; h < pointPrimitivesToUpdateLength; ++h) {\n        var bb = pointPrimitivesToUpdate[h];\n        bb._dirty = false;\n\n        for (var o = 0; o < numWriters; ++o) {\n          writers[o](this, context, vafWriters, bb);\n        }\n\n        this._vaf.subCommit(bb._index, 1);\n      }\n\n      this._vaf.endSubCommits();\n    }\n\n    this._pointPrimitivesToUpdateIndex = 0;\n  } // If the number of total pointPrimitives ever shrinks considerably\n  // Truncate pointPrimitivesToUpdate so that we free memory that we're\n  // not going to be using.\n\n\n  if (pointPrimitivesToUpdateLength > pointPrimitivesLength * 1.5) {\n    pointPrimitivesToUpdate.length = pointPrimitivesLength;\n  }\n\n  if (!defined(this._vaf) || !defined(this._vaf.va)) {\n    return;\n  }\n\n  if (this._boundingVolumeDirty) {\n    this._boundingVolumeDirty = false;\n    BoundingSphere.transform(this._baseVolume, this.modelMatrix, this._baseVolumeWC);\n  }\n\n  var boundingVolume;\n  var modelMatrix = Matrix4.IDENTITY;\n\n  if (frameState.mode === SceneMode.SCENE3D) {\n    modelMatrix = this.modelMatrix;\n    boundingVolume = BoundingSphere.clone(this._baseVolumeWC, this._boundingVolume);\n  } else {\n    boundingVolume = BoundingSphere.clone(this._baseVolume2D, this._boundingVolume);\n  }\n\n  updateBoundingVolume(this, frameState, boundingVolume);\n  var blendOptionChanged = this._blendOption !== this.blendOption;\n  this._blendOption = this.blendOption;\n\n  if (blendOptionChanged) {\n    if (this._blendOption === BlendOption.OPAQUE || this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT) {\n      this._rsOpaque = RenderState.fromCache({\n        depthTest: {\n          enabled: true,\n          func: WebGLConstants.LEQUAL\n        },\n        depthMask: true\n      });\n    } else {\n      this._rsOpaque = undefined;\n    }\n\n    if (this._blendOption === BlendOption.TRANSLUCENT || this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT) {\n      this._rsTranslucent = RenderState.fromCache({\n        depthTest: {\n          enabled: true,\n          func: WebGLConstants.LEQUAL\n        },\n        depthMask: false,\n        blending: BlendingState.ALPHA_BLEND\n      });\n    } else {\n      this._rsTranslucent = undefined;\n    }\n  }\n\n  this._shaderDisableDepthDistance = this._shaderDisableDepthDistance || frameState.minimumDisableDepthTestDistance !== 0.0;\n  var vs;\n  var fs;\n\n  if (blendOptionChanged || this._shaderScaleByDistance && !this._compiledShaderScaleByDistance || this._shaderTranslucencyByDistance && !this._compiledShaderTranslucencyByDistance || this._shaderDistanceDisplayCondition && !this._compiledShaderDistanceDisplayCondition || this._shaderDisableDepthDistance !== this._compiledShaderDisableDepthDistance) {\n    vs = new ShaderSource({\n      sources: [PointPrimitiveCollectionVS]\n    });\n\n    if (this._shaderScaleByDistance) {\n      vs.defines.push(\"EYE_DISTANCE_SCALING\");\n    }\n\n    if (this._shaderTranslucencyByDistance) {\n      vs.defines.push(\"EYE_DISTANCE_TRANSLUCENCY\");\n    }\n\n    if (this._shaderDistanceDisplayCondition) {\n      vs.defines.push(\"DISTANCE_DISPLAY_CONDITION\");\n    }\n\n    if (this._shaderDisableDepthDistance) {\n      vs.defines.push(\"DISABLE_DEPTH_DISTANCE\");\n    }\n\n    if (this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT) {\n      fs = new ShaderSource({\n        defines: [\"OPAQUE\"],\n        sources: [PointPrimitiveCollectionFS]\n      });\n      this._sp = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._sp,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations\n      });\n      fs = new ShaderSource({\n        defines: [\"TRANSLUCENT\"],\n        sources: [PointPrimitiveCollectionFS]\n      });\n      this._spTranslucent = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._spTranslucent,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations\n      });\n    }\n\n    if (this._blendOption === BlendOption.OPAQUE) {\n      fs = new ShaderSource({\n        sources: [PointPrimitiveCollectionFS]\n      });\n      this._sp = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._sp,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations\n      });\n    }\n\n    if (this._blendOption === BlendOption.TRANSLUCENT) {\n      fs = new ShaderSource({\n        sources: [PointPrimitiveCollectionFS]\n      });\n      this._spTranslucent = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._spTranslucent,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations\n      });\n    }\n\n    this._compiledShaderScaleByDistance = this._shaderScaleByDistance;\n    this._compiledShaderTranslucencyByDistance = this._shaderTranslucencyByDistance;\n    this._compiledShaderDistanceDisplayCondition = this._shaderDistanceDisplayCondition;\n    this._compiledShaderDisableDepthDistance = this._shaderDisableDepthDistance;\n  }\n\n  var va;\n  var vaLength;\n  var command;\n  var j;\n  var commandList = frameState.commandList;\n\n  if (pass.render || picking) {\n    var colorList = this._colorCommands;\n    var opaque = this._blendOption === BlendOption.OPAQUE;\n    var opaqueAndTranslucent = this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT;\n    va = this._vaf.va;\n    vaLength = va.length;\n    colorList.length = vaLength;\n    var totalLength = opaqueAndTranslucent ? vaLength * 2 : vaLength;\n\n    for (j = 0; j < totalLength; ++j) {\n      var opaqueCommand = opaque || opaqueAndTranslucent && j % 2 === 0;\n      command = colorList[j];\n\n      if (!defined(command)) {\n        command = colorList[j] = new DrawCommand();\n      }\n\n      command.primitiveType = PrimitiveType.POINTS;\n      command.pass = opaqueCommand || !opaqueAndTranslucent ? Pass.OPAQUE : Pass.TRANSLUCENT;\n      command.owner = this;\n      var index = opaqueAndTranslucent ? Math.floor(j / 2.0) : j;\n      command.boundingVolume = boundingVolume;\n      command.modelMatrix = modelMatrix;\n      command.shaderProgram = opaqueCommand ? this._sp : this._spTranslucent;\n      command.uniformMap = this._uniforms;\n      command.vertexArray = va[index].va;\n      command.renderState = opaqueCommand ? this._rsOpaque : this._rsTranslucent;\n      command.debugShowBoundingVolume = this.debugShowBoundingVolume;\n      command.pickId = \"v_pickColor\";\n      commandList.push(command);\n    }\n  }\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see PointPrimitiveCollection#destroy\n */\n\n\nPointPrimitiveCollection.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * pointPrimitives = pointPrimitives && pointPrimitives.destroy();\n *\n * @see PointPrimitiveCollection#isDestroyed\n */\n\n\nPointPrimitiveCollection.prototype.destroy = function () {\n  this._sp = this._sp && this._sp.destroy();\n  this._spTranslucent = this._spTranslucent && this._spTranslucent.destroy();\n  this._spPick = this._spPick && this._spPick.destroy();\n  this._vaf = this._vaf && this._vaf.destroy();\n  destroyPointPrimitives(this._pointPrimitives);\n  return destroyObject(this);\n};\n\nexport default PointPrimitiveCollection;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/PointPrimitiveCollection.js"],"names":["BoundingSphere","Color","ComponentDatatype","defaultValue","defined","destroyObject","DeveloperError","EncodedCartesian3","CesiumMath","Matrix4","PrimitiveType","WebGLConstants","BufferUsage","ContextLimits","DrawCommand","Pass","RenderState","ShaderProgram","ShaderSource","VertexArrayFacade","PointPrimitiveCollectionFS","PointPrimitiveCollectionVS","BlendingState","BlendOption","PointPrimitive","SceneMode","SHOW_INDEX","POSITION_INDEX","COLOR_INDEX","OUTLINE_COLOR_INDEX","OUTLINE_WIDTH_INDEX","PIXEL_SIZE_INDEX","SCALE_BY_DISTANCE_INDEX","TRANSLUCENCY_BY_DISTANCE_INDEX","DISTANCE_DISPLAY_CONDITION_INDEX","DISABLE_DEPTH_DISTANCE_INDEX","NUMBER_OF_PROPERTIES","attributeLocations","positionHighAndSize","positionLowAndOutline","compressedAttribute0","compressedAttribute1","scaleByDistance","distanceDisplayConditionAndDisableDepth","PointPrimitiveCollection","options","EMPTY_OBJECT","_sp","undefined","_spTranslucent","_rsOpaque","_rsTranslucent","_vaf","_pointPrimitives","_pointPrimitivesToUpdate","_pointPrimitivesToUpdateIndex","_pointPrimitivesRemoved","_createVertexArray","_shaderScaleByDistance","_compiledShaderScaleByDistance","_shaderTranslucencyByDistance","_compiledShaderTranslucencyByDistance","_shaderDistanceDisplayCondition","_compiledShaderDistanceDisplayCondition","_shaderDisableDepthDistance","_compiledShaderDisableDepthDistance","_propertiesChanged","Uint32Array","_maxPixelSize","_baseVolume","_baseVolumeWC","_baseVolume2D","_boundingVolume","_boundingVolumeDirty","_colorCommands","modelMatrix","clone","IDENTITY","_modelMatrix","debugShowBoundingVolume","blendOption","OPAQUE_AND_TRANSLUCENT","_blendOption","_mode","SCENE3D","_maxTotalPointSize","_buffersUsage","STATIC_DRAW","that","_uniforms","u_maxTotalPointSize","Object","defineProperties","prototype","length","get","removePointPrimitives","destroyPointPrimitives","pointPrimitives","i","_destroy","add","p","_index","push","remove","pointPrimitive","contains","removeAll","pointPrimitiveCollection","newPointPrimitives","j","_updatePointPrimitive","propertyChanged","_dirty","_pointPrimitiveCollection","index","computeNewBuffersUsage","buffersUsage","usageChanged","properties","k","newUsage","STREAM_DRAW","createVAF","context","numberOfPointPrimitives","componentsPerAttribute","componentDatatype","FLOAT","usage","positionLowAndShow","writePositionScratch","writePositionSizeAndOutline","vafWriters","position","_getActualPosition","expand","fromCartesian","pixelSize","outlineWidth","Math","max","positionHighWriter","high","x","y","z","positionLowWriter","low","LEFT_SHIFT16","LEFT_SHIFT8","writeCompressedAttrib0","color","pickColor","getPickId","outlineColor","red","floatToByte","green","blue","compressed0","compressed1","compressed2","compressed3","alpha","writer","writeCompressedAttrib1","near","nearValue","far","farValue","translucency","translucencyByDistance","show","clusterShow","clamp","writeScaleByDistance","scale","writeDistanceDisplayConditionAndDepthDisable","Number","MAX_VALUE","distanceDisplayCondition","disableDepthTestDistance","POSITIVE_INFINITY","writePointPrimitive","recomputeActualPositions","frameState","recomputeBoundingVolume","boundingVolume","mode","positions","actualPosition","_computeActualPosition","_setActualPosition","fromPoints","updateMode","pointPrimitivesToUpdate","equals","SCENE2D","COLUMBUS_VIEW","MORPHING","updateBoundingVolume","collection","camera","getPixelSize","drawingBufferWidth","drawingBufferHeight","size","radius","scratchWriterArray","update","maximumAliasedPointSize","pointPrimitivesLength","pointPrimitivesToUpdateLength","createVertexArray","pass","passes","picking","pick","destroy","writers","commit","numWriters","m","b","n","h","bb","o","subCommit","endSubCommits","va","transform","blendOptionChanged","OPAQUE","fromCache","depthTest","enabled","func","LEQUAL","depthMask","TRANSLUCENT","blending","ALPHA_BLEND","minimumDisableDepthTestDistance","vs","fs","sources","defines","replaceCache","shaderProgram","vertexShaderSource","fragmentShaderSource","vaLength","command","commandList","render","colorList","opaque","opaqueAndTranslucent","totalLength","opaqueCommand","primitiveType","POINTS","owner","floor","uniformMap","vertexArray","renderState","pickId","isDestroyed","_spPick"],"mappings":"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","sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArrayFacade from \"../Renderer/VertexArrayFacade.js\";\nimport PointPrimitiveCollectionFS from \"../Shaders/PointPrimitiveCollectionFS.js\";\nimport PointPrimitiveCollectionVS from \"../Shaders/PointPrimitiveCollectionVS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport BlendOption from \"./BlendOption.js\";\nimport PointPrimitive from \"./PointPrimitive.js\";\nimport SceneMode from \"./SceneMode.js\";\n\nvar SHOW_INDEX = PointPrimitive.SHOW_INDEX;\nvar POSITION_INDEX = PointPrimitive.POSITION_INDEX;\nvar COLOR_INDEX = PointPrimitive.COLOR_INDEX;\nvar OUTLINE_COLOR_INDEX = PointPrimitive.OUTLINE_COLOR_INDEX;\nvar OUTLINE_WIDTH_INDEX = PointPrimitive.OUTLINE_WIDTH_INDEX;\nvar PIXEL_SIZE_INDEX = PointPrimitive.PIXEL_SIZE_INDEX;\nvar SCALE_BY_DISTANCE_INDEX = PointPrimitive.SCALE_BY_DISTANCE_INDEX;\nvar TRANSLUCENCY_BY_DISTANCE_INDEX =\n  PointPrimitive.TRANSLUCENCY_BY_DISTANCE_INDEX;\nvar DISTANCE_DISPLAY_CONDITION_INDEX =\n  PointPrimitive.DISTANCE_DISPLAY_CONDITION_INDEX;\nvar DISABLE_DEPTH_DISTANCE_INDEX = PointPrimitive.DISABLE_DEPTH_DISTANCE_INDEX;\nvar NUMBER_OF_PROPERTIES = PointPrimitive.NUMBER_OF_PROPERTIES;\n\nvar attributeLocations = {\n  positionHighAndSize: 0,\n  positionLowAndOutline: 1,\n  compressedAttribute0: 2, // color, outlineColor, pick color\n  compressedAttribute1: 3, // show, translucency by distance, some free space\n  scaleByDistance: 4,\n  distanceDisplayConditionAndDisableDepth: 5,\n};\n\n/**\n * A renderable collection of points.\n * <br /><br />\n * Points are added and removed from the collection using {@link PointPrimitiveCollection#add}\n * and {@link PointPrimitiveCollection#remove}.\n *\n * @alias PointPrimitiveCollection\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each point from model to world coordinates.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {BlendOption} [options.blendOption=BlendOption.OPAQUE_AND_TRANSLUCENT] The point blending option. The default\n * is used for rendering both opaque and translucent points. However, if either all of the points are completely opaque or all are completely translucent,\n * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve performance by up to 2x.\n *\n * @performance For best performance, prefer a few collections, each with many points, to\n * many collections with only a few points each.  Organize collections so that points\n * with the same update frequency are in the same collection, i.e., points that do not\n * change should be in one collection; points that change every frame should be in another\n * collection; and so on.\n *\n *\n * @example\n * // Create a pointPrimitive collection with two points\n * var points = scene.primitives.add(new Cesium.PointPrimitiveCollection());\n * points.add({\n *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),\n *   color : Cesium.Color.YELLOW\n * });\n * points.add({\n *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),\n *   color : Cesium.Color.CYAN\n * });\n *\n * @see PointPrimitiveCollection#add\n * @see PointPrimitiveCollection#remove\n * @see PointPrimitive\n */\nfunction PointPrimitiveCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._sp = undefined;\n  this._spTranslucent = undefined;\n  this._rsOpaque = undefined;\n  this._rsTranslucent = undefined;\n  this._vaf = undefined;\n\n  this._pointPrimitives = [];\n  this._pointPrimitivesToUpdate = [];\n  this._pointPrimitivesToUpdateIndex = 0;\n  this._pointPrimitivesRemoved = false;\n  this._createVertexArray = false;\n\n  this._shaderScaleByDistance = false;\n  this._compiledShaderScaleByDistance = false;\n\n  this._shaderTranslucencyByDistance = false;\n  this._compiledShaderTranslucencyByDistance = false;\n\n  this._shaderDistanceDisplayCondition = false;\n  this._compiledShaderDistanceDisplayCondition = false;\n\n  this._shaderDisableDepthDistance = false;\n  this._compiledShaderDisableDepthDistance = false;\n\n  this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);\n\n  this._maxPixelSize = 1.0;\n\n  this._baseVolume = new BoundingSphere();\n  this._baseVolumeWC = new BoundingSphere();\n  this._baseVolume2D = new BoundingSphere();\n  this._boundingVolume = new BoundingSphere();\n  this._boundingVolumeDirty = false;\n\n  this._colorCommands = [];\n\n  /**\n   * The 4x4 transformation matrix that transforms each point in this collection from model to world coordinates.\n   * When this is the identity matrix, the pointPrimitives are drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type {Matrix4}\n   * @default {@link Matrix4.IDENTITY}\n   *\n   *\n   * @example\n   * var center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n   * pointPrimitives.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n   * pointPrimitives.add({\n   *   color : Cesium.Color.ORANGE,\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0) // center\n   * });\n   * pointPrimitives.add({\n   *   color : Cesium.Color.YELLOW,\n   *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0) // east\n   * });\n   * pointPrimitives.add({\n   *   color : Cesium.Color.GREEN,\n   *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0) // north\n   * });\n   * pointPrimitives.add({\n   *   color : Cesium.Color.CYAN,\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0) // up\n   * });\n   *\n   * @see Transforms.eastNorthUpToFixedFrame\n   */\n  this.modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY)\n  );\n  this._modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false\n  );\n\n  /**\n   * The point blending option. The default is used for rendering both opaque and translucent points.\n   * However, if either all of the points are completely opaque or all are completely translucent,\n   * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve\n   * performance by up to 2x.\n   * @type {BlendOption}\n   * @default BlendOption.OPAQUE_AND_TRANSLUCENT\n   */\n  this.blendOption = defaultValue(\n    options.blendOption,\n    BlendOption.OPAQUE_AND_TRANSLUCENT\n  );\n  this._blendOption = undefined;\n\n  this._mode = SceneMode.SCENE3D;\n  this._maxTotalPointSize = 1;\n\n  // The buffer usage for each attribute is determined based on the usage of the attribute over time.\n  this._buffersUsage = [\n    BufferUsage.STATIC_DRAW, // SHOW_INDEX\n    BufferUsage.STATIC_DRAW, // POSITION_INDEX\n    BufferUsage.STATIC_DRAW, // COLOR_INDEX\n    BufferUsage.STATIC_DRAW, // OUTLINE_COLOR_INDEX\n    BufferUsage.STATIC_DRAW, // OUTLINE_WIDTH_INDEX\n    BufferUsage.STATIC_DRAW, // PIXEL_SIZE_INDEX\n    BufferUsage.STATIC_DRAW, // SCALE_BY_DISTANCE_INDEX\n    BufferUsage.STATIC_DRAW, // TRANSLUCENCY_BY_DISTANCE_INDEX\n    BufferUsage.STATIC_DRAW, // DISTANCE_DISPLAY_CONDITION_INDEX\n  ];\n\n  var that = this;\n  this._uniforms = {\n    u_maxTotalPointSize: function () {\n      return that._maxTotalPointSize;\n    },\n  };\n}\n\nObject.defineProperties(PointPrimitiveCollection.prototype, {\n  /**\n   * Returns the number of points in this collection.  This is commonly used with\n   * {@link PointPrimitiveCollection#get} to iterate over all the points\n   * in the collection.\n   * @memberof PointPrimitiveCollection.prototype\n   * @type {Number}\n   */\n  length: {\n    get: function () {\n      removePointPrimitives(this);\n      return this._pointPrimitives.length;\n    },\n  },\n});\n\nfunction destroyPointPrimitives(pointPrimitives) {\n  var length = pointPrimitives.length;\n  for (var i = 0; i < length; ++i) {\n    if (pointPrimitives[i]) {\n      pointPrimitives[i]._destroy();\n    }\n  }\n}\n\n/**\n * Creates and adds a point with the specified initial properties to the collection.\n * The added point is returned so it can be modified or removed from the collection later.\n *\n * @param {Object}[options] A template describing the point's properties as shown in Example 1.\n * @returns {PointPrimitive} The point that was added to the collection.\n *\n * @performance Calling <code>add</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, add as many pointPrimitives as possible before calling <code>update</code>.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Example 1:  Add a point, specifying all the default values.\n * var p = pointPrimitives.add({\n *   show : true,\n *   position : Cesium.Cartesian3.ZERO,\n *   pixelSize : 10.0,\n *   color : Cesium.Color.WHITE,\n *   outlineColor : Cesium.Color.TRANSPARENT,\n *   outlineWidth : 0.0,\n *   id : undefined\n * });\n *\n * @example\n * // Example 2:  Specify only the point's cartographic position.\n * var p = pointPrimitives.add({\n *   position : Cesium.Cartesian3.fromDegrees(longitude, latitude, height)\n * });\n *\n * @see PointPrimitiveCollection#remove\n * @see PointPrimitiveCollection#removeAll\n */\nPointPrimitiveCollection.prototype.add = function (options) {\n  var p = new PointPrimitive(options, this);\n  p._index = this._pointPrimitives.length;\n\n  this._pointPrimitives.push(p);\n  this._createVertexArray = true;\n\n  return p;\n};\n\n/**\n * Removes a point from the collection.\n *\n * @param {PointPrimitive} pointPrimitive The point to remove.\n * @returns {Boolean} <code>true</code> if the point was removed; <code>false</code> if the point was not found in the collection.\n *\n * @performance Calling <code>remove</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, remove as many points as possible before calling <code>update</code>.\n * If you intend to temporarily hide a point, it is usually more efficient to call\n * {@link PointPrimitive#show} instead of removing and re-adding the point.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * var p = pointPrimitives.add(...);\n * pointPrimitives.remove(p);  // Returns true\n *\n * @see PointPrimitiveCollection#add\n * @see PointPrimitiveCollection#removeAll\n * @see PointPrimitive#show\n */\nPointPrimitiveCollection.prototype.remove = function (pointPrimitive) {\n  if (this.contains(pointPrimitive)) {\n    this._pointPrimitives[pointPrimitive._index] = null; // Removed later\n    this._pointPrimitivesRemoved = true;\n    this._createVertexArray = true;\n    pointPrimitive._destroy();\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Removes all points from the collection.\n *\n * @performance <code>O(n)</code>.  It is more efficient to remove all the points\n * from a collection and then add new ones than to create a new collection entirely.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * pointPrimitives.add(...);\n * pointPrimitives.add(...);\n * pointPrimitives.removeAll();\n *\n * @see PointPrimitiveCollection#add\n * @see PointPrimitiveCollection#remove\n */\nPointPrimitiveCollection.prototype.removeAll = function () {\n  destroyPointPrimitives(this._pointPrimitives);\n  this._pointPrimitives = [];\n  this._pointPrimitivesToUpdate = [];\n  this._pointPrimitivesToUpdateIndex = 0;\n  this._pointPrimitivesRemoved = false;\n\n  this._createVertexArray = true;\n};\n\nfunction removePointPrimitives(pointPrimitiveCollection) {\n  if (pointPrimitiveCollection._pointPrimitivesRemoved) {\n    pointPrimitiveCollection._pointPrimitivesRemoved = false;\n\n    var newPointPrimitives = [];\n    var pointPrimitives = pointPrimitiveCollection._pointPrimitives;\n    var length = pointPrimitives.length;\n    for (var i = 0, j = 0; i < length; ++i) {\n      var pointPrimitive = pointPrimitives[i];\n      if (pointPrimitive) {\n        pointPrimitive._index = j++;\n        newPointPrimitives.push(pointPrimitive);\n      }\n    }\n\n    pointPrimitiveCollection._pointPrimitives = newPointPrimitives;\n  }\n}\n\nPointPrimitiveCollection.prototype._updatePointPrimitive = function (\n  pointPrimitive,\n  propertyChanged\n) {\n  if (!pointPrimitive._dirty) {\n    this._pointPrimitivesToUpdate[\n      this._pointPrimitivesToUpdateIndex++\n    ] = pointPrimitive;\n  }\n\n  ++this._propertiesChanged[propertyChanged];\n};\n\n/**\n * Check whether this collection contains a given point.\n *\n * @param {PointPrimitive} [pointPrimitive] The point to check for.\n * @returns {Boolean} true if this collection contains the point, false otherwise.\n *\n * @see PointPrimitiveCollection#get\n */\nPointPrimitiveCollection.prototype.contains = function (pointPrimitive) {\n  return (\n    defined(pointPrimitive) && pointPrimitive._pointPrimitiveCollection === this\n  );\n};\n\n/**\n * Returns the point in the collection at the specified index.  Indices are zero-based\n * and increase as points are added.  Removing a point shifts all points after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link PointPrimitiveCollection#length} to iterate over all the points\n * in the collection.\n *\n * @param {Number} index The zero-based index of the point.\n * @returns {PointPrimitive} The point at the specified index.\n *\n * @performance Expected constant time.  If points were removed from the collection and\n * {@link PointPrimitiveCollection#update} was not called, an implicit <code>O(n)</code>\n * operation is performed.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Toggle the show property of every point in the collection\n * var len = pointPrimitives.length;\n * for (var i = 0; i < len; ++i) {\n *   var p = pointPrimitives.get(i);\n *   p.show = !p.show;\n * }\n *\n * @see PointPrimitiveCollection#length\n */\nPointPrimitiveCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  }\n  //>>includeEnd('debug');\n\n  removePointPrimitives(this);\n  return this._pointPrimitives[index];\n};\n\nPointPrimitiveCollection.prototype.computeNewBuffersUsage = function () {\n  var buffersUsage = this._buffersUsage;\n  var usageChanged = false;\n\n  var properties = this._propertiesChanged;\n  for (var k = 0; k < NUMBER_OF_PROPERTIES; ++k) {\n    var newUsage =\n      properties[k] === 0 ? BufferUsage.STATIC_DRAW : BufferUsage.STREAM_DRAW;\n    usageChanged = usageChanged || buffersUsage[k] !== newUsage;\n    buffersUsage[k] = newUsage;\n  }\n\n  return usageChanged;\n};\n\nfunction createVAF(context, numberOfPointPrimitives, buffersUsage) {\n  return new VertexArrayFacade(\n    context,\n    [\n      {\n        index: attributeLocations.positionHighAndSize,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        usage: buffersUsage[POSITION_INDEX],\n      },\n      {\n        index: attributeLocations.positionLowAndShow,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        usage: buffersUsage[POSITION_INDEX],\n      },\n      {\n        index: attributeLocations.compressedAttribute0,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        usage: buffersUsage[COLOR_INDEX],\n      },\n      {\n        index: attributeLocations.compressedAttribute1,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        usage: buffersUsage[TRANSLUCENCY_BY_DISTANCE_INDEX],\n      },\n      {\n        index: attributeLocations.scaleByDistance,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        usage: buffersUsage[SCALE_BY_DISTANCE_INDEX],\n      },\n      {\n        index: attributeLocations.distanceDisplayConditionAndDisableDepth,\n        componentsPerAttribute: 3,\n        componentDatatype: ComponentDatatype.FLOAT,\n        usage: buffersUsage[DISTANCE_DISPLAY_CONDITION_INDEX],\n      },\n    ],\n    numberOfPointPrimitives\n  ); // 1 vertex per pointPrimitive\n}\n\n///////////////////////////////////////////////////////////////////////////\n\n// PERFORMANCE_IDEA:  Save memory if a property is the same for all pointPrimitives, use a latched attribute state,\n// instead of storing it in a vertex buffer.\n\nvar writePositionScratch = new EncodedCartesian3();\n\nfunction writePositionSizeAndOutline(\n  pointPrimitiveCollection,\n  context,\n  vafWriters,\n  pointPrimitive\n) {\n  var i = pointPrimitive._index;\n  var position = pointPrimitive._getActualPosition();\n\n  if (pointPrimitiveCollection._mode === SceneMode.SCENE3D) {\n    BoundingSphere.expand(\n      pointPrimitiveCollection._baseVolume,\n      position,\n      pointPrimitiveCollection._baseVolume\n    );\n    pointPrimitiveCollection._boundingVolumeDirty = true;\n  }\n\n  EncodedCartesian3.fromCartesian(position, writePositionScratch);\n  var pixelSize = pointPrimitive.pixelSize;\n  var outlineWidth = pointPrimitive.outlineWidth;\n\n  pointPrimitiveCollection._maxPixelSize = Math.max(\n    pointPrimitiveCollection._maxPixelSize,\n    pixelSize + outlineWidth\n  );\n\n  var positionHighWriter = vafWriters[attributeLocations.positionHighAndSize];\n  var high = writePositionScratch.high;\n  positionHighWriter(i, high.x, high.y, high.z, pixelSize);\n\n  var positionLowWriter = vafWriters[attributeLocations.positionLowAndOutline];\n  var low = writePositionScratch.low;\n  positionLowWriter(i, low.x, low.y, low.z, outlineWidth);\n}\n\nvar LEFT_SHIFT16 = 65536.0; // 2^16\nvar LEFT_SHIFT8 = 256.0; // 2^8\n\nfunction writeCompressedAttrib0(\n  pointPrimitiveCollection,\n  context,\n  vafWriters,\n  pointPrimitive\n) {\n  var i = pointPrimitive._index;\n\n  var color = pointPrimitive.color;\n  var pickColor = pointPrimitive.getPickId(context).color;\n  var outlineColor = pointPrimitive.outlineColor;\n\n  var red = Color.floatToByte(color.red);\n  var green = Color.floatToByte(color.green);\n  var blue = Color.floatToByte(color.blue);\n  var compressed0 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n\n  red = Color.floatToByte(outlineColor.red);\n  green = Color.floatToByte(outlineColor.green);\n  blue = Color.floatToByte(outlineColor.blue);\n  var compressed1 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n\n  red = Color.floatToByte(pickColor.red);\n  green = Color.floatToByte(pickColor.green);\n  blue = Color.floatToByte(pickColor.blue);\n  var compressed2 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n\n  var compressed3 =\n    Color.floatToByte(color.alpha) * LEFT_SHIFT16 +\n    Color.floatToByte(outlineColor.alpha) * LEFT_SHIFT8 +\n    Color.floatToByte(pickColor.alpha);\n\n  var writer = vafWriters[attributeLocations.compressedAttribute0];\n  writer(i, compressed0, compressed1, compressed2, compressed3);\n}\n\nfunction writeCompressedAttrib1(\n  pointPrimitiveCollection,\n  context,\n  vafWriters,\n  pointPrimitive\n) {\n  var i = pointPrimitive._index;\n\n  var near = 0.0;\n  var nearValue = 1.0;\n  var far = 1.0;\n  var farValue = 1.0;\n\n  var translucency = pointPrimitive.translucencyByDistance;\n  if (defined(translucency)) {\n    near = translucency.near;\n    nearValue = translucency.nearValue;\n    far = translucency.far;\n    farValue = translucency.farValue;\n\n    if (nearValue !== 1.0 || farValue !== 1.0) {\n      // translucency by distance calculation in shader need not be enabled\n      // until a pointPrimitive with near and far !== 1.0 is found\n      pointPrimitiveCollection._shaderTranslucencyByDistance = true;\n    }\n  }\n\n  var show = pointPrimitive.show && pointPrimitive.clusterShow;\n\n  // If the color alphas are zero, do not show this pointPrimitive.  This lets us avoid providing\n  // color during the pick pass and also eliminates a discard in the fragment shader.\n  if (\n    pointPrimitive.color.alpha === 0.0 &&\n    pointPrimitive.outlineColor.alpha === 0.0\n  ) {\n    show = false;\n  }\n\n  nearValue = CesiumMath.clamp(nearValue, 0.0, 1.0);\n  nearValue = nearValue === 1.0 ? 255.0 : (nearValue * 255.0) | 0;\n  var compressed0 = (show ? 1.0 : 0.0) * LEFT_SHIFT8 + nearValue;\n\n  farValue = CesiumMath.clamp(farValue, 0.0, 1.0);\n  farValue = farValue === 1.0 ? 255.0 : (farValue * 255.0) | 0;\n  var compressed1 = farValue;\n\n  var writer = vafWriters[attributeLocations.compressedAttribute1];\n  writer(i, compressed0, compressed1, near, far);\n}\n\nfunction writeScaleByDistance(\n  pointPrimitiveCollection,\n  context,\n  vafWriters,\n  pointPrimitive\n) {\n  var i = pointPrimitive._index;\n  var writer = vafWriters[attributeLocations.scaleByDistance];\n  var near = 0.0;\n  var nearValue = 1.0;\n  var far = 1.0;\n  var farValue = 1.0;\n\n  var scale = pointPrimitive.scaleByDistance;\n  if (defined(scale)) {\n    near = scale.near;\n    nearValue = scale.nearValue;\n    far = scale.far;\n    farValue = scale.farValue;\n\n    if (nearValue !== 1.0 || farValue !== 1.0) {\n      // scale by distance calculation in shader need not be enabled\n      // until a pointPrimitive with near and far !== 1.0 is found\n      pointPrimitiveCollection._shaderScaleByDistance = true;\n    }\n  }\n\n  writer(i, near, nearValue, far, farValue);\n}\n\nfunction writeDistanceDisplayConditionAndDepthDisable(\n  pointPrimitiveCollection,\n  context,\n  vafWriters,\n  pointPrimitive\n) {\n  var i = pointPrimitive._index;\n  var writer =\n    vafWriters[attributeLocations.distanceDisplayConditionAndDisableDepth];\n  var near = 0.0;\n  var far = Number.MAX_VALUE;\n\n  var distanceDisplayCondition = pointPrimitive.distanceDisplayCondition;\n  if (defined(distanceDisplayCondition)) {\n    near = distanceDisplayCondition.near;\n    far = distanceDisplayCondition.far;\n\n    near *= near;\n    far *= far;\n\n    pointPrimitiveCollection._shaderDistanceDisplayCondition = true;\n  }\n\n  var disableDepthTestDistance = pointPrimitive.disableDepthTestDistance;\n  disableDepthTestDistance *= disableDepthTestDistance;\n  if (disableDepthTestDistance > 0.0) {\n    pointPrimitiveCollection._shaderDisableDepthDistance = true;\n    if (disableDepthTestDistance === Number.POSITIVE_INFINITY) {\n      disableDepthTestDistance = -1.0;\n    }\n  }\n\n  writer(i, near, far, disableDepthTestDistance);\n}\n\nfunction writePointPrimitive(\n  pointPrimitiveCollection,\n  context,\n  vafWriters,\n  pointPrimitive\n) {\n  writePositionSizeAndOutline(\n    pointPrimitiveCollection,\n    context,\n    vafWriters,\n    pointPrimitive\n  );\n  writeCompressedAttrib0(\n    pointPrimitiveCollection,\n    context,\n    vafWriters,\n    pointPrimitive\n  );\n  writeCompressedAttrib1(\n    pointPrimitiveCollection,\n    context,\n    vafWriters,\n    pointPrimitive\n  );\n  writeScaleByDistance(\n    pointPrimitiveCollection,\n    context,\n    vafWriters,\n    pointPrimitive\n  );\n  writeDistanceDisplayConditionAndDepthDisable(\n    pointPrimitiveCollection,\n    context,\n    vafWriters,\n    pointPrimitive\n  );\n}\n\nfunction recomputeActualPositions(\n  pointPrimitiveCollection,\n  pointPrimitives,\n  length,\n  frameState,\n  modelMatrix,\n  recomputeBoundingVolume\n) {\n  var boundingVolume;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingVolume = pointPrimitiveCollection._baseVolume;\n    pointPrimitiveCollection._boundingVolumeDirty = true;\n  } else {\n    boundingVolume = pointPrimitiveCollection._baseVolume2D;\n  }\n\n  var positions = [];\n  for (var i = 0; i < length; ++i) {\n    var pointPrimitive = pointPrimitives[i];\n    var position = pointPrimitive.position;\n    var actualPosition = PointPrimitive._computeActualPosition(\n      position,\n      frameState,\n      modelMatrix\n    );\n    if (defined(actualPosition)) {\n      pointPrimitive._setActualPosition(actualPosition);\n\n      if (recomputeBoundingVolume) {\n        positions.push(actualPosition);\n      } else {\n        BoundingSphere.expand(boundingVolume, actualPosition, boundingVolume);\n      }\n    }\n  }\n\n  if (recomputeBoundingVolume) {\n    BoundingSphere.fromPoints(positions, boundingVolume);\n  }\n}\n\nfunction updateMode(pointPrimitiveCollection, frameState) {\n  var mode = frameState.mode;\n\n  var pointPrimitives = pointPrimitiveCollection._pointPrimitives;\n  var pointPrimitivesToUpdate =\n    pointPrimitiveCollection._pointPrimitivesToUpdate;\n  var modelMatrix = pointPrimitiveCollection._modelMatrix;\n\n  if (\n    pointPrimitiveCollection._createVertexArray ||\n    pointPrimitiveCollection._mode !== mode ||\n    (mode !== SceneMode.SCENE3D &&\n      !Matrix4.equals(modelMatrix, pointPrimitiveCollection.modelMatrix))\n  ) {\n    pointPrimitiveCollection._mode = mode;\n    Matrix4.clone(pointPrimitiveCollection.modelMatrix, modelMatrix);\n    pointPrimitiveCollection._createVertexArray = true;\n\n    if (\n      mode === SceneMode.SCENE3D ||\n      mode === SceneMode.SCENE2D ||\n      mode === SceneMode.COLUMBUS_VIEW\n    ) {\n      recomputeActualPositions(\n        pointPrimitiveCollection,\n        pointPrimitives,\n        pointPrimitives.length,\n        frameState,\n        modelMatrix,\n        true\n      );\n    }\n  } else if (mode === SceneMode.MORPHING) {\n    recomputeActualPositions(\n      pointPrimitiveCollection,\n      pointPrimitives,\n      pointPrimitives.length,\n      frameState,\n      modelMatrix,\n      true\n    );\n  } else if (mode === SceneMode.SCENE2D || mode === SceneMode.COLUMBUS_VIEW) {\n    recomputeActualPositions(\n      pointPrimitiveCollection,\n      pointPrimitivesToUpdate,\n      pointPrimitiveCollection._pointPrimitivesToUpdateIndex,\n      frameState,\n      modelMatrix,\n      false\n    );\n  }\n}\n\nfunction updateBoundingVolume(collection, frameState, boundingVolume) {\n  var pixelSize = frameState.camera.getPixelSize(\n    boundingVolume,\n    frameState.context.drawingBufferWidth,\n    frameState.context.drawingBufferHeight\n  );\n  var size = pixelSize * collection._maxPixelSize;\n  boundingVolume.radius += size;\n}\n\nvar scratchWriterArray = [];\n\n/**\n * @private\n */\nPointPrimitiveCollection.prototype.update = function (frameState) {\n  removePointPrimitives(this);\n\n  this._maxTotalPointSize = ContextLimits.maximumAliasedPointSize;\n\n  updateMode(this, frameState);\n\n  var pointPrimitives = this._pointPrimitives;\n  var pointPrimitivesLength = pointPrimitives.length;\n  var pointPrimitivesToUpdate = this._pointPrimitivesToUpdate;\n  var pointPrimitivesToUpdateLength = this._pointPrimitivesToUpdateIndex;\n\n  var properties = this._propertiesChanged;\n\n  var createVertexArray = this._createVertexArray;\n\n  var vafWriters;\n  var context = frameState.context;\n  var pass = frameState.passes;\n  var picking = pass.pick;\n\n  // PERFORMANCE_IDEA: Round robin multiple buffers.\n  if (createVertexArray || (!picking && this.computeNewBuffersUsage())) {\n    this._createVertexArray = false;\n\n    for (var k = 0; k < NUMBER_OF_PROPERTIES; ++k) {\n      properties[k] = 0;\n    }\n\n    this._vaf = this._vaf && this._vaf.destroy();\n\n    if (pointPrimitivesLength > 0) {\n      // PERFORMANCE_IDEA:  Instead of creating a new one, resize like std::vector.\n      this._vaf = createVAF(context, pointPrimitivesLength, this._buffersUsage);\n      vafWriters = this._vaf.writers;\n\n      // Rewrite entire buffer if pointPrimitives were added or removed.\n      for (var i = 0; i < pointPrimitivesLength; ++i) {\n        var pointPrimitive = this._pointPrimitives[i];\n        pointPrimitive._dirty = false; // In case it needed an update.\n        writePointPrimitive(this, context, vafWriters, pointPrimitive);\n      }\n\n      this._vaf.commit();\n    }\n\n    this._pointPrimitivesToUpdateIndex = 0;\n  } else if (pointPrimitivesToUpdateLength > 0) {\n    // PointPrimitives were modified, but none were added or removed.\n    var writers = scratchWriterArray;\n    writers.length = 0;\n\n    if (\n      properties[POSITION_INDEX] ||\n      properties[OUTLINE_WIDTH_INDEX] ||\n      properties[PIXEL_SIZE_INDEX]\n    ) {\n      writers.push(writePositionSizeAndOutline);\n    }\n\n    if (properties[COLOR_INDEX] || properties[OUTLINE_COLOR_INDEX]) {\n      writers.push(writeCompressedAttrib0);\n    }\n\n    if (properties[SHOW_INDEX] || properties[TRANSLUCENCY_BY_DISTANCE_INDEX]) {\n      writers.push(writeCompressedAttrib1);\n    }\n\n    if (properties[SCALE_BY_DISTANCE_INDEX]) {\n      writers.push(writeScaleByDistance);\n    }\n\n    if (\n      properties[DISTANCE_DISPLAY_CONDITION_INDEX] ||\n      properties[DISABLE_DEPTH_DISTANCE_INDEX]\n    ) {\n      writers.push(writeDistanceDisplayConditionAndDepthDisable);\n    }\n\n    var numWriters = writers.length;\n\n    vafWriters = this._vaf.writers;\n\n    if (pointPrimitivesToUpdateLength / pointPrimitivesLength > 0.1) {\n      // If more than 10% of pointPrimitive change, rewrite the entire buffer.\n\n      // PERFORMANCE_IDEA:  I totally made up 10% :).\n\n      for (var m = 0; m < pointPrimitivesToUpdateLength; ++m) {\n        var b = pointPrimitivesToUpdate[m];\n        b._dirty = false;\n\n        for (var n = 0; n < numWriters; ++n) {\n          writers[n](this, context, vafWriters, b);\n        }\n      }\n      this._vaf.commit();\n    } else {\n      for (var h = 0; h < pointPrimitivesToUpdateLength; ++h) {\n        var bb = pointPrimitivesToUpdate[h];\n        bb._dirty = false;\n\n        for (var o = 0; o < numWriters; ++o) {\n          writers[o](this, context, vafWriters, bb);\n        }\n        this._vaf.subCommit(bb._index, 1);\n      }\n      this._vaf.endSubCommits();\n    }\n\n    this._pointPrimitivesToUpdateIndex = 0;\n  }\n\n  // If the number of total pointPrimitives ever shrinks considerably\n  // Truncate pointPrimitivesToUpdate so that we free memory that we're\n  // not going to be using.\n  if (pointPrimitivesToUpdateLength > pointPrimitivesLength * 1.5) {\n    pointPrimitivesToUpdate.length = pointPrimitivesLength;\n  }\n\n  if (!defined(this._vaf) || !defined(this._vaf.va)) {\n    return;\n  }\n\n  if (this._boundingVolumeDirty) {\n    this._boundingVolumeDirty = false;\n    BoundingSphere.transform(\n      this._baseVolume,\n      this.modelMatrix,\n      this._baseVolumeWC\n    );\n  }\n\n  var boundingVolume;\n  var modelMatrix = Matrix4.IDENTITY;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    modelMatrix = this.modelMatrix;\n    boundingVolume = BoundingSphere.clone(\n      this._baseVolumeWC,\n      this._boundingVolume\n    );\n  } else {\n    boundingVolume = BoundingSphere.clone(\n      this._baseVolume2D,\n      this._boundingVolume\n    );\n  }\n  updateBoundingVolume(this, frameState, boundingVolume);\n\n  var blendOptionChanged = this._blendOption !== this.blendOption;\n  this._blendOption = this.blendOption;\n\n  if (blendOptionChanged) {\n    if (\n      this._blendOption === BlendOption.OPAQUE ||\n      this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT\n    ) {\n      this._rsOpaque = RenderState.fromCache({\n        depthTest: {\n          enabled: true,\n          func: WebGLConstants.LEQUAL,\n        },\n        depthMask: true,\n      });\n    } else {\n      this._rsOpaque = undefined;\n    }\n\n    if (\n      this._blendOption === BlendOption.TRANSLUCENT ||\n      this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT\n    ) {\n      this._rsTranslucent = RenderState.fromCache({\n        depthTest: {\n          enabled: true,\n          func: WebGLConstants.LEQUAL,\n        },\n        depthMask: false,\n        blending: BlendingState.ALPHA_BLEND,\n      });\n    } else {\n      this._rsTranslucent = undefined;\n    }\n  }\n\n  this._shaderDisableDepthDistance =\n    this._shaderDisableDepthDistance ||\n    frameState.minimumDisableDepthTestDistance !== 0.0;\n  var vs;\n  var fs;\n\n  if (\n    blendOptionChanged ||\n    (this._shaderScaleByDistance && !this._compiledShaderScaleByDistance) ||\n    (this._shaderTranslucencyByDistance &&\n      !this._compiledShaderTranslucencyByDistance) ||\n    (this._shaderDistanceDisplayCondition &&\n      !this._compiledShaderDistanceDisplayCondition) ||\n    this._shaderDisableDepthDistance !==\n      this._compiledShaderDisableDepthDistance\n  ) {\n    vs = new ShaderSource({\n      sources: [PointPrimitiveCollectionVS],\n    });\n    if (this._shaderScaleByDistance) {\n      vs.defines.push(\"EYE_DISTANCE_SCALING\");\n    }\n    if (this._shaderTranslucencyByDistance) {\n      vs.defines.push(\"EYE_DISTANCE_TRANSLUCENCY\");\n    }\n    if (this._shaderDistanceDisplayCondition) {\n      vs.defines.push(\"DISTANCE_DISPLAY_CONDITION\");\n    }\n    if (this._shaderDisableDepthDistance) {\n      vs.defines.push(\"DISABLE_DEPTH_DISTANCE\");\n    }\n\n    if (this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT) {\n      fs = new ShaderSource({\n        defines: [\"OPAQUE\"],\n        sources: [PointPrimitiveCollectionFS],\n      });\n      this._sp = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._sp,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      });\n\n      fs = new ShaderSource({\n        defines: [\"TRANSLUCENT\"],\n        sources: [PointPrimitiveCollectionFS],\n      });\n      this._spTranslucent = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._spTranslucent,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      });\n    }\n\n    if (this._blendOption === BlendOption.OPAQUE) {\n      fs = new ShaderSource({\n        sources: [PointPrimitiveCollectionFS],\n      });\n      this._sp = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._sp,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      });\n    }\n\n    if (this._blendOption === BlendOption.TRANSLUCENT) {\n      fs = new ShaderSource({\n        sources: [PointPrimitiveCollectionFS],\n      });\n      this._spTranslucent = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._spTranslucent,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      });\n    }\n\n    this._compiledShaderScaleByDistance = this._shaderScaleByDistance;\n    this._compiledShaderTranslucencyByDistance = this._shaderTranslucencyByDistance;\n    this._compiledShaderDistanceDisplayCondition = this._shaderDistanceDisplayCondition;\n    this._compiledShaderDisableDepthDistance = this._shaderDisableDepthDistance;\n  }\n\n  var va;\n  var vaLength;\n  var command;\n  var j;\n\n  var commandList = frameState.commandList;\n\n  if (pass.render || picking) {\n    var colorList = this._colorCommands;\n\n    var opaque = this._blendOption === BlendOption.OPAQUE;\n    var opaqueAndTranslucent =\n      this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT;\n\n    va = this._vaf.va;\n    vaLength = va.length;\n\n    colorList.length = vaLength;\n    var totalLength = opaqueAndTranslucent ? vaLength * 2 : vaLength;\n    for (j = 0; j < totalLength; ++j) {\n      var opaqueCommand = opaque || (opaqueAndTranslucent && j % 2 === 0);\n\n      command = colorList[j];\n      if (!defined(command)) {\n        command = colorList[j] = new DrawCommand();\n      }\n\n      command.primitiveType = PrimitiveType.POINTS;\n      command.pass =\n        opaqueCommand || !opaqueAndTranslucent ? Pass.OPAQUE : Pass.TRANSLUCENT;\n      command.owner = this;\n\n      var index = opaqueAndTranslucent ? Math.floor(j / 2.0) : j;\n      command.boundingVolume = boundingVolume;\n      command.modelMatrix = modelMatrix;\n      command.shaderProgram = opaqueCommand ? this._sp : this._spTranslucent;\n      command.uniformMap = this._uniforms;\n      command.vertexArray = va[index].va;\n      command.renderState = opaqueCommand\n        ? this._rsOpaque\n        : this._rsTranslucent;\n      command.debugShowBoundingVolume = this.debugShowBoundingVolume;\n      command.pickId = \"v_pickColor\";\n\n      commandList.push(command);\n    }\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see PointPrimitiveCollection#destroy\n */\nPointPrimitiveCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * pointPrimitives = pointPrimitives && pointPrimitives.destroy();\n *\n * @see PointPrimitiveCollection#isDestroyed\n */\nPointPrimitiveCollection.prototype.destroy = function () {\n  this._sp = this._sp && this._sp.destroy();\n  this._spTranslucent = this._spTranslucent && this._spTranslucent.destroy();\n  this._spPick = this._spPick && this._spPick.destroy();\n  this._vaf = this._vaf && this._vaf.destroy();\n  destroyPointPrimitives(this._pointPrimitives);\n\n  return destroyObject(this);\n};\nexport default PointPrimitiveCollection;\n"]},"metadata":{},"sourceType":"module"}