{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Quaternion from \"./Quaternion.js\";\nvar EllipseGeometryLibrary = {};\nvar rotAxis = new Cartesian3();\nvar tempVec = new Cartesian3();\nvar unitQuat = new Quaternion();\nvar rotMtx = new Matrix3();\n\nfunction pointOnEllipsoid(theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, result) {\n  var azimuth = theta + rotation;\n  Cartesian3.multiplyByScalar(eastVec, Math.cos(azimuth), rotAxis);\n  Cartesian3.multiplyByScalar(northVec, Math.sin(azimuth), tempVec);\n  Cartesian3.add(rotAxis, tempVec, rotAxis);\n  var cosThetaSquared = Math.cos(theta);\n  cosThetaSquared = cosThetaSquared * cosThetaSquared;\n  var sinThetaSquared = Math.sin(theta);\n  sinThetaSquared = sinThetaSquared * sinThetaSquared;\n  var radius = ab / Math.sqrt(bSqr * cosThetaSquared + aSqr * sinThetaSquared);\n  var angle = radius / mag; // Create the quaternion to rotate the position vector to the boundary of the ellipse.\n\n  Quaternion.fromAxisAngle(rotAxis, angle, unitQuat);\n  Matrix3.fromQuaternion(unitQuat, rotMtx);\n  Matrix3.multiplyByVector(rotMtx, unitPos, result);\n  Cartesian3.normalize(result, result);\n  Cartesian3.multiplyByScalar(result, mag, result);\n  return result;\n}\n\nvar scratchCartesian1 = new Cartesian3();\nvar scratchCartesian2 = new Cartesian3();\nvar scratchCartesian3 = new Cartesian3();\nvar scratchNormal = new Cartesian3();\n/**\n * Returns the positions raised to the given heights\n * @private\n */\n\nEllipseGeometryLibrary.raisePositionsToHeight = function (positions, options, extrude) {\n  var ellipsoid = options.ellipsoid;\n  var height = options.height;\n  var extrudedHeight = options.extrudedHeight;\n  var size = extrude ? positions.length / 3 * 2 : positions.length / 3;\n  var finalPositions = new Float64Array(size * 3);\n  var length = positions.length;\n  var bottomOffset = extrude ? length : 0;\n\n  for (var i = 0; i < length; i += 3) {\n    var i1 = i + 1;\n    var i2 = i + 2;\n    var position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n    ellipsoid.scaleToGeodeticSurface(position, position);\n    var extrudedPosition = Cartesian3.clone(position, scratchCartesian2);\n    var normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\n    var scaledNormal = Cartesian3.multiplyByScalar(normal, height, scratchCartesian3);\n    Cartesian3.add(position, scaledNormal, position);\n\n    if (extrude) {\n      Cartesian3.multiplyByScalar(normal, extrudedHeight, scaledNormal);\n      Cartesian3.add(extrudedPosition, scaledNormal, extrudedPosition);\n      finalPositions[i + bottomOffset] = extrudedPosition.x;\n      finalPositions[i1 + bottomOffset] = extrudedPosition.y;\n      finalPositions[i2 + bottomOffset] = extrudedPosition.z;\n    }\n\n    finalPositions[i] = position.x;\n    finalPositions[i1] = position.y;\n    finalPositions[i2] = position.z;\n  }\n\n  return finalPositions;\n};\n\nvar unitPosScratch = new Cartesian3();\nvar eastVecScratch = new Cartesian3();\nvar northVecScratch = new Cartesian3();\n/**\n * Returns an array of positions that make up the ellipse.\n * @private\n */\n\nEllipseGeometryLibrary.computeEllipsePositions = function (options, addFillPositions, addEdgePositions) {\n  var semiMinorAxis = options.semiMinorAxis;\n  var semiMajorAxis = options.semiMajorAxis;\n  var rotation = options.rotation;\n  var center = options.center; // Computing the arc-length of the ellipse is too expensive to be practical. Estimating it using the\n  // arc length of the sphere is too inaccurate and creates sharp edges when either the semi-major or\n  // semi-minor axis is much bigger than the other. Instead, scale the angle delta to make\n  // the distance along the ellipse boundary more closely match the granularity.\n\n  var granularity = options.granularity * 8.0;\n  var aSqr = semiMinorAxis * semiMinorAxis;\n  var bSqr = semiMajorAxis * semiMajorAxis;\n  var ab = semiMajorAxis * semiMinorAxis;\n  var mag = Cartesian3.magnitude(center);\n  var unitPos = Cartesian3.normalize(center, unitPosScratch);\n  var eastVec = Cartesian3.cross(Cartesian3.UNIT_Z, center, eastVecScratch);\n  eastVec = Cartesian3.normalize(eastVec, eastVec);\n  var northVec = Cartesian3.cross(unitPos, eastVec, northVecScratch); // The number of points in the first quadrant\n\n  var numPts = 1 + Math.ceil(CesiumMath.PI_OVER_TWO / granularity);\n  var deltaTheta = CesiumMath.PI_OVER_TWO / (numPts - 1);\n  var theta = CesiumMath.PI_OVER_TWO - numPts * deltaTheta;\n\n  if (theta < 0.0) {\n    numPts -= Math.ceil(Math.abs(theta) / deltaTheta);\n  } // If the number of points were three, the ellipse\n  // would be tessellated like below:\n  //\n  //         *---*\n  //       / | \\ | \\\n  //     *---*---*---*\n  //   / | \\ | \\ | \\ | \\\n  //  / .*---*---*---*. \\\n  // * ` | \\ | \\ | \\ | `*\n  //  \\`.*---*---*---*.`/\n  //   \\ | \\ | \\ | \\ | /\n  //     *---*---*---*\n  //       \\ | \\ | /\n  //         *---*\n  // The first and last column have one position and fan to connect to the adjacent column.\n  // Each other vertical column contains an even number of positions.\n\n\n  var size = 2 * (numPts * (numPts + 2));\n  var positions = addFillPositions ? new Array(size * 3) : undefined;\n  var positionIndex = 0;\n  var position = scratchCartesian1;\n  var reflectedPosition = scratchCartesian2;\n  var outerPositionsLength = numPts * 4 * 3;\n  var outerRightIndex = outerPositionsLength - 1;\n  var outerLeftIndex = 0;\n  var outerPositions = addEdgePositions ? new Array(outerPositionsLength) : undefined;\n  var i;\n  var j;\n  var numInterior;\n  var t;\n  var interiorPosition; // Compute points in the 'eastern' half of the ellipse\n\n  theta = CesiumMath.PI_OVER_TWO;\n  position = pointOnEllipsoid(theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\n\n  if (addFillPositions) {\n    positions[positionIndex++] = position.x;\n    positions[positionIndex++] = position.y;\n    positions[positionIndex++] = position.z;\n  }\n\n  if (addEdgePositions) {\n    outerPositions[outerRightIndex--] = position.z;\n    outerPositions[outerRightIndex--] = position.y;\n    outerPositions[outerRightIndex--] = position.x;\n  }\n\n  theta = CesiumMath.PI_OVER_TWO - deltaTheta;\n\n  for (i = 1; i < numPts + 1; ++i) {\n    position = pointOnEllipsoid(theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\n    reflectedPosition = pointOnEllipsoid(Math.PI - theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, reflectedPosition);\n\n    if (addFillPositions) {\n      positions[positionIndex++] = position.x;\n      positions[positionIndex++] = position.y;\n      positions[positionIndex++] = position.z;\n      numInterior = 2 * i + 2;\n\n      for (j = 1; j < numInterior - 1; ++j) {\n        t = j / (numInterior - 1);\n        interiorPosition = Cartesian3.lerp(position, reflectedPosition, t, scratchCartesian3);\n        positions[positionIndex++] = interiorPosition.x;\n        positions[positionIndex++] = interiorPosition.y;\n        positions[positionIndex++] = interiorPosition.z;\n      }\n\n      positions[positionIndex++] = reflectedPosition.x;\n      positions[positionIndex++] = reflectedPosition.y;\n      positions[positionIndex++] = reflectedPosition.z;\n    }\n\n    if (addEdgePositions) {\n      outerPositions[outerRightIndex--] = position.z;\n      outerPositions[outerRightIndex--] = position.y;\n      outerPositions[outerRightIndex--] = position.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.y;\n      outerPositions[outerLeftIndex++] = reflectedPosition.z;\n    }\n\n    theta = CesiumMath.PI_OVER_TWO - (i + 1) * deltaTheta;\n  } // Compute points in the 'western' half of the ellipse\n\n\n  for (i = numPts; i > 1; --i) {\n    theta = CesiumMath.PI_OVER_TWO - (i - 1) * deltaTheta;\n    position = pointOnEllipsoid(-theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\n    reflectedPosition = pointOnEllipsoid(theta + Math.PI, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, reflectedPosition);\n\n    if (addFillPositions) {\n      positions[positionIndex++] = position.x;\n      positions[positionIndex++] = position.y;\n      positions[positionIndex++] = position.z;\n      numInterior = 2 * (i - 1) + 2;\n\n      for (j = 1; j < numInterior - 1; ++j) {\n        t = j / (numInterior - 1);\n        interiorPosition = Cartesian3.lerp(position, reflectedPosition, t, scratchCartesian3);\n        positions[positionIndex++] = interiorPosition.x;\n        positions[positionIndex++] = interiorPosition.y;\n        positions[positionIndex++] = interiorPosition.z;\n      }\n\n      positions[positionIndex++] = reflectedPosition.x;\n      positions[positionIndex++] = reflectedPosition.y;\n      positions[positionIndex++] = reflectedPosition.z;\n    }\n\n    if (addEdgePositions) {\n      outerPositions[outerRightIndex--] = position.z;\n      outerPositions[outerRightIndex--] = position.y;\n      outerPositions[outerRightIndex--] = position.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.y;\n      outerPositions[outerLeftIndex++] = reflectedPosition.z;\n    }\n  }\n\n  theta = CesiumMath.PI_OVER_TWO;\n  position = pointOnEllipsoid(-theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\n  var r = {};\n\n  if (addFillPositions) {\n    positions[positionIndex++] = position.x;\n    positions[positionIndex++] = position.y;\n    positions[positionIndex++] = position.z;\n    r.positions = positions;\n    r.numPts = numPts;\n  }\n\n  if (addEdgePositions) {\n    outerPositions[outerRightIndex--] = position.z;\n    outerPositions[outerRightIndex--] = position.y;\n    outerPositions[outerRightIndex--] = position.x;\n    r.outerPositions = outerPositions;\n  }\n\n  return r;\n};\n\nexport default EllipseGeometryLibrary;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/EllipseGeometryLibrary.js"],"names":["Cartesian3","CesiumMath","Matrix3","Quaternion","EllipseGeometryLibrary","rotAxis","tempVec","unitQuat","rotMtx","pointOnEllipsoid","theta","rotation","northVec","eastVec","aSqr","ab","bSqr","mag","unitPos","result","azimuth","multiplyByScalar","Math","cos","sin","add","cosThetaSquared","sinThetaSquared","radius","sqrt","angle","fromAxisAngle","fromQuaternion","multiplyByVector","normalize","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchNormal","raisePositionsToHeight","positions","options","extrude","ellipsoid","height","extrudedHeight","size","length","finalPositions","Float64Array","bottomOffset","i","i1","i2","position","fromArray","scaleToGeodeticSurface","extrudedPosition","clone","normal","geodeticSurfaceNormal","scaledNormal","x","y","z","unitPosScratch","eastVecScratch","northVecScratch","computeEllipsePositions","addFillPositions","addEdgePositions","semiMinorAxis","semiMajorAxis","center","granularity","magnitude","cross","UNIT_Z","numPts","ceil","PI_OVER_TWO","deltaTheta","abs","Array","undefined","positionIndex","reflectedPosition","outerPositionsLength","outerRightIndex","outerLeftIndex","outerPositions","j","numInterior","t","interiorPosition","PI","lerp","r"],"mappings":"AAAA,OAAOA,UAAP,MAAuB,iBAAvB;AACA,OAAOC,UAAP,MAAuB,WAAvB;AACA,OAAOC,OAAP,MAAoB,cAApB;AACA,OAAOC,UAAP,MAAuB,iBAAvB;AAEA,IAAIC,sBAAsB,GAAG,EAA7B;AAEA,IAAIC,OAAO,GAAG,IAAIL,UAAJ,EAAd;AACA,IAAIM,OAAO,GAAG,IAAIN,UAAJ,EAAd;AACA,IAAIO,QAAQ,GAAG,IAAIJ,UAAJ,EAAf;AACA,IAAIK,MAAM,GAAG,IAAIN,OAAJ,EAAb;;AAEA,SAASO,gBAAT,CACEC,KADF,EAEEC,QAFF,EAGEC,QAHF,EAIEC,OAJF,EAKEC,IALF,EAMEC,EANF,EAOEC,IAPF,EAQEC,GARF,EASEC,OATF,EAUEC,MAVF,EAWE;AACA,MAAIC,OAAO,GAAGV,KAAK,GAAGC,QAAtB;AAEAX,EAAAA,UAAU,CAACqB,gBAAX,CAA4BR,OAA5B,EAAqCS,IAAI,CAACC,GAAL,CAASH,OAAT,CAArC,EAAwDf,OAAxD;AACAL,EAAAA,UAAU,CAACqB,gBAAX,CAA4BT,QAA5B,EAAsCU,IAAI,CAACE,GAAL,CAASJ,OAAT,CAAtC,EAAyDd,OAAzD;AACAN,EAAAA,UAAU,CAACyB,GAAX,CAAepB,OAAf,EAAwBC,OAAxB,EAAiCD,OAAjC;AAEA,MAAIqB,eAAe,GAAGJ,IAAI,CAACC,GAAL,CAASb,KAAT,CAAtB;AACAgB,EAAAA,eAAe,GAAGA,eAAe,GAAGA,eAApC;AAEA,MAAIC,eAAe,GAAGL,IAAI,CAACE,GAAL,CAASd,KAAT,CAAtB;AACAiB,EAAAA,eAAe,GAAGA,eAAe,GAAGA,eAApC;AAEA,MAAIC,MAAM,GAAGb,EAAE,GAAGO,IAAI,CAACO,IAAL,CAAUb,IAAI,GAAGU,eAAP,GAAyBZ,IAAI,GAAGa,eAA1C,CAAlB;AACA,MAAIG,KAAK,GAAGF,MAAM,GAAGX,GAArB,CAdA,CAgBA;;AACAd,EAAAA,UAAU,CAAC4B,aAAX,CAAyB1B,OAAzB,EAAkCyB,KAAlC,EAAyCvB,QAAzC;AACAL,EAAAA,OAAO,CAAC8B,cAAR,CAAuBzB,QAAvB,EAAiCC,MAAjC;AAEAN,EAAAA,OAAO,CAAC+B,gBAAR,CAAyBzB,MAAzB,EAAiCU,OAAjC,EAA0CC,MAA1C;AACAnB,EAAAA,UAAU,CAACkC,SAAX,CAAqBf,MAArB,EAA6BA,MAA7B;AACAnB,EAAAA,UAAU,CAACqB,gBAAX,CAA4BF,MAA5B,EAAoCF,GAApC,EAAyCE,MAAzC;AACA,SAAOA,MAAP;AACD;;AAED,IAAIgB,iBAAiB,GAAG,IAAInC,UAAJ,EAAxB;AACA,IAAIoC,iBAAiB,GAAG,IAAIpC,UAAJ,EAAxB;AACA,IAAIqC,iBAAiB,GAAG,IAAIrC,UAAJ,EAAxB;AACA,IAAIsC,aAAa,GAAG,IAAItC,UAAJ,EAApB;AACA;;;;;AAIAI,sBAAsB,CAACmC,sBAAvB,GAAgD,UAC9CC,SAD8C,EAE9CC,OAF8C,EAG9CC,OAH8C,EAI9C;AACA,MAAIC,SAAS,GAAGF,OAAO,CAACE,SAAxB;AACA,MAAIC,MAAM,GAAGH,OAAO,CAACG,MAArB;AACA,MAAIC,cAAc,GAAGJ,OAAO,CAACI,cAA7B;AACA,MAAIC,IAAI,GAAGJ,OAAO,GAAIF,SAAS,CAACO,MAAV,GAAmB,CAApB,GAAyB,CAA5B,GAAgCP,SAAS,CAACO,MAAV,GAAmB,CAArE;AAEA,MAAIC,cAAc,GAAG,IAAIC,YAAJ,CAAiBH,IAAI,GAAG,CAAxB,CAArB;AAEA,MAAIC,MAAM,GAAGP,SAAS,CAACO,MAAvB;AACA,MAAIG,YAAY,GAAGR,OAAO,GAAGK,MAAH,GAAY,CAAtC;;AACA,OAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,MAApB,EAA4BI,CAAC,IAAI,CAAjC,EAAoC;AAClC,QAAIC,EAAE,GAAGD,CAAC,GAAG,CAAb;AACA,QAAIE,EAAE,GAAGF,CAAC,GAAG,CAAb;AAEA,QAAIG,QAAQ,GAAGtD,UAAU,CAACuD,SAAX,CAAqBf,SAArB,EAAgCW,CAAhC,EAAmChB,iBAAnC,CAAf;AACAQ,IAAAA,SAAS,CAACa,sBAAV,CAAiCF,QAAjC,EAA2CA,QAA3C;AAEA,QAAIG,gBAAgB,GAAGzD,UAAU,CAAC0D,KAAX,CAAiBJ,QAAjB,EAA2BlB,iBAA3B,CAAvB;AACA,QAAIuB,MAAM,GAAGhB,SAAS,CAACiB,qBAAV,CAAgCN,QAAhC,EAA0ChB,aAA1C,CAAb;AACA,QAAIuB,YAAY,GAAG7D,UAAU,CAACqB,gBAAX,CACjBsC,MADiB,EAEjBf,MAFiB,EAGjBP,iBAHiB,CAAnB;AAKArC,IAAAA,UAAU,CAACyB,GAAX,CAAe6B,QAAf,EAAyBO,YAAzB,EAAuCP,QAAvC;;AAEA,QAAIZ,OAAJ,EAAa;AACX1C,MAAAA,UAAU,CAACqB,gBAAX,CAA4BsC,MAA5B,EAAoCd,cAApC,EAAoDgB,YAApD;AACA7D,MAAAA,UAAU,CAACyB,GAAX,CAAegC,gBAAf,EAAiCI,YAAjC,EAA+CJ,gBAA/C;AAEAT,MAAAA,cAAc,CAACG,CAAC,GAAGD,YAAL,CAAd,GAAmCO,gBAAgB,CAACK,CAApD;AACAd,MAAAA,cAAc,CAACI,EAAE,GAAGF,YAAN,CAAd,GAAoCO,gBAAgB,CAACM,CAArD;AACAf,MAAAA,cAAc,CAACK,EAAE,GAAGH,YAAN,CAAd,GAAoCO,gBAAgB,CAACO,CAArD;AACD;;AAEDhB,IAAAA,cAAc,CAACG,CAAD,CAAd,GAAoBG,QAAQ,CAACQ,CAA7B;AACAd,IAAAA,cAAc,CAACI,EAAD,CAAd,GAAqBE,QAAQ,CAACS,CAA9B;AACAf,IAAAA,cAAc,CAACK,EAAD,CAAd,GAAqBC,QAAQ,CAACU,CAA9B;AACD;;AAED,SAAOhB,cAAP;AACD,CA7CD;;AA+CA,IAAIiB,cAAc,GAAG,IAAIjE,UAAJ,EAArB;AACA,IAAIkE,cAAc,GAAG,IAAIlE,UAAJ,EAArB;AACA,IAAImE,eAAe,GAAG,IAAInE,UAAJ,EAAtB;AACA;;;;;AAIAI,sBAAsB,CAACgE,uBAAvB,GAAiD,UAC/C3B,OAD+C,EAE/C4B,gBAF+C,EAG/CC,gBAH+C,EAI/C;AACA,MAAIC,aAAa,GAAG9B,OAAO,CAAC8B,aAA5B;AACA,MAAIC,aAAa,GAAG/B,OAAO,CAAC+B,aAA5B;AACA,MAAI7D,QAAQ,GAAG8B,OAAO,CAAC9B,QAAvB;AACA,MAAI8D,MAAM,GAAGhC,OAAO,CAACgC,MAArB,CAJA,CAMA;AACA;AACA;AACA;;AACA,MAAIC,WAAW,GAAGjC,OAAO,CAACiC,WAAR,GAAsB,GAAxC;AAEA,MAAI5D,IAAI,GAAGyD,aAAa,GAAGA,aAA3B;AACA,MAAIvD,IAAI,GAAGwD,aAAa,GAAGA,aAA3B;AACA,MAAIzD,EAAE,GAAGyD,aAAa,GAAGD,aAAzB;AAEA,MAAItD,GAAG,GAAGjB,UAAU,CAAC2E,SAAX,CAAqBF,MAArB,CAAV;AAEA,MAAIvD,OAAO,GAAGlB,UAAU,CAACkC,SAAX,CAAqBuC,MAArB,EAA6BR,cAA7B,CAAd;AACA,MAAIpD,OAAO,GAAGb,UAAU,CAAC4E,KAAX,CAAiB5E,UAAU,CAAC6E,MAA5B,EAAoCJ,MAApC,EAA4CP,cAA5C,CAAd;AACArD,EAAAA,OAAO,GAAGb,UAAU,CAACkC,SAAX,CAAqBrB,OAArB,EAA8BA,OAA9B,CAAV;AACA,MAAID,QAAQ,GAAGZ,UAAU,CAAC4E,KAAX,CAAiB1D,OAAjB,EAA0BL,OAA1B,EAAmCsD,eAAnC,CAAf,CArBA,CAuBA;;AACA,MAAIW,MAAM,GAAG,IAAIxD,IAAI,CAACyD,IAAL,CAAU9E,UAAU,CAAC+E,WAAX,GAAyBN,WAAnC,CAAjB;AAEA,MAAIO,UAAU,GAAGhF,UAAU,CAAC+E,WAAX,IAA0BF,MAAM,GAAG,CAAnC,CAAjB;AACA,MAAIpE,KAAK,GAAGT,UAAU,CAAC+E,WAAX,GAAyBF,MAAM,GAAGG,UAA9C;;AACA,MAAIvE,KAAK,GAAG,GAAZ,EAAiB;AACfoE,IAAAA,MAAM,IAAIxD,IAAI,CAACyD,IAAL,CAAUzD,IAAI,CAAC4D,GAAL,CAASxE,KAAT,IAAkBuE,UAA5B,CAAV;AACD,GA9BD,CAgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAInC,IAAI,GAAG,KAAKgC,MAAM,IAAIA,MAAM,GAAG,CAAb,CAAX,CAAX;AACA,MAAItC,SAAS,GAAG6B,gBAAgB,GAAG,IAAIc,KAAJ,CAAUrC,IAAI,GAAG,CAAjB,CAAH,GAAyBsC,SAAzD;AACA,MAAIC,aAAa,GAAG,CAApB;AACA,MAAI/B,QAAQ,GAAGnB,iBAAf;AACA,MAAImD,iBAAiB,GAAGlD,iBAAxB;AAEA,MAAImD,oBAAoB,GAAGT,MAAM,GAAG,CAAT,GAAa,CAAxC;AACA,MAAIU,eAAe,GAAGD,oBAAoB,GAAG,CAA7C;AACA,MAAIE,cAAc,GAAG,CAArB;AACA,MAAIC,cAAc,GAAGpB,gBAAgB,GACjC,IAAIa,KAAJ,CAAUI,oBAAV,CADiC,GAEjCH,SAFJ;AAIA,MAAIjC,CAAJ;AACA,MAAIwC,CAAJ;AACA,MAAIC,WAAJ;AACA,MAAIC,CAAJ;AACA,MAAIC,gBAAJ,CAjEA,CAmEA;;AACApF,EAAAA,KAAK,GAAGT,UAAU,CAAC+E,WAAnB;AACA1B,EAAAA,QAAQ,GAAG7C,gBAAgB,CACzBC,KADyB,EAEzBC,QAFyB,EAGzBC,QAHyB,EAIzBC,OAJyB,EAKzBC,IALyB,EAMzBC,EANyB,EAOzBC,IAPyB,EAQzBC,GARyB,EASzBC,OATyB,EAUzBoC,QAVyB,CAA3B;;AAYA,MAAIe,gBAAJ,EAAsB;AACpB7B,IAAAA,SAAS,CAAC6C,aAAa,EAAd,CAAT,GAA6B/B,QAAQ,CAACQ,CAAtC;AACAtB,IAAAA,SAAS,CAAC6C,aAAa,EAAd,CAAT,GAA6B/B,QAAQ,CAACS,CAAtC;AACAvB,IAAAA,SAAS,CAAC6C,aAAa,EAAd,CAAT,GAA6B/B,QAAQ,CAACU,CAAtC;AACD;;AACD,MAAIM,gBAAJ,EAAsB;AACpBoB,IAAAA,cAAc,CAACF,eAAe,EAAhB,CAAd,GAAoClC,QAAQ,CAACU,CAA7C;AACA0B,IAAAA,cAAc,CAACF,eAAe,EAAhB,CAAd,GAAoClC,QAAQ,CAACS,CAA7C;AACA2B,IAAAA,cAAc,CAACF,eAAe,EAAhB,CAAd,GAAoClC,QAAQ,CAACQ,CAA7C;AACD;;AACDpD,EAAAA,KAAK,GAAGT,UAAU,CAAC+E,WAAX,GAAyBC,UAAjC;;AACA,OAAK9B,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG2B,MAAM,GAAG,CAAzB,EAA4B,EAAE3B,CAA9B,EAAiC;AAC/BG,IAAAA,QAAQ,GAAG7C,gBAAgB,CACzBC,KADyB,EAEzBC,QAFyB,EAGzBC,QAHyB,EAIzBC,OAJyB,EAKzBC,IALyB,EAMzBC,EANyB,EAOzBC,IAPyB,EAQzBC,GARyB,EASzBC,OATyB,EAUzBoC,QAVyB,CAA3B;AAYAgC,IAAAA,iBAAiB,GAAG7E,gBAAgB,CAClCa,IAAI,CAACyE,EAAL,GAAUrF,KADwB,EAElCC,QAFkC,EAGlCC,QAHkC,EAIlCC,OAJkC,EAKlCC,IALkC,EAMlCC,EANkC,EAOlCC,IAPkC,EAQlCC,GARkC,EASlCC,OATkC,EAUlCoE,iBAVkC,CAApC;;AAaA,QAAIjB,gBAAJ,EAAsB;AACpB7B,MAAAA,SAAS,CAAC6C,aAAa,EAAd,CAAT,GAA6B/B,QAAQ,CAACQ,CAAtC;AACAtB,MAAAA,SAAS,CAAC6C,aAAa,EAAd,CAAT,GAA6B/B,QAAQ,CAACS,CAAtC;AACAvB,MAAAA,SAAS,CAAC6C,aAAa,EAAd,CAAT,GAA6B/B,QAAQ,CAACU,CAAtC;AAEA4B,MAAAA,WAAW,GAAG,IAAIzC,CAAJ,GAAQ,CAAtB;;AACA,WAAKwC,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGC,WAAW,GAAG,CAA9B,EAAiC,EAAED,CAAnC,EAAsC;AACpCE,QAAAA,CAAC,GAAGF,CAAC,IAAIC,WAAW,GAAG,CAAlB,CAAL;AACAE,QAAAA,gBAAgB,GAAG9F,UAAU,CAACgG,IAAX,CACjB1C,QADiB,EAEjBgC,iBAFiB,EAGjBO,CAHiB,EAIjBxD,iBAJiB,CAAnB;AAMAG,QAAAA,SAAS,CAAC6C,aAAa,EAAd,CAAT,GAA6BS,gBAAgB,CAAChC,CAA9C;AACAtB,QAAAA,SAAS,CAAC6C,aAAa,EAAd,CAAT,GAA6BS,gBAAgB,CAAC/B,CAA9C;AACAvB,QAAAA,SAAS,CAAC6C,aAAa,EAAd,CAAT,GAA6BS,gBAAgB,CAAC9B,CAA9C;AACD;;AAEDxB,MAAAA,SAAS,CAAC6C,aAAa,EAAd,CAAT,GAA6BC,iBAAiB,CAACxB,CAA/C;AACAtB,MAAAA,SAAS,CAAC6C,aAAa,EAAd,CAAT,GAA6BC,iBAAiB,CAACvB,CAA/C;AACAvB,MAAAA,SAAS,CAAC6C,aAAa,EAAd,CAAT,GAA6BC,iBAAiB,CAACtB,CAA/C;AACD;;AAED,QAAIM,gBAAJ,EAAsB;AACpBoB,MAAAA,cAAc,CAACF,eAAe,EAAhB,CAAd,GAAoClC,QAAQ,CAACU,CAA7C;AACA0B,MAAAA,cAAc,CAACF,eAAe,EAAhB,CAAd,GAAoClC,QAAQ,CAACS,CAA7C;AACA2B,MAAAA,cAAc,CAACF,eAAe,EAAhB,CAAd,GAAoClC,QAAQ,CAACQ,CAA7C;AACA4B,MAAAA,cAAc,CAACD,cAAc,EAAf,CAAd,GAAmCH,iBAAiB,CAACxB,CAArD;AACA4B,MAAAA,cAAc,CAACD,cAAc,EAAf,CAAd,GAAmCH,iBAAiB,CAACvB,CAArD;AACA2B,MAAAA,cAAc,CAACD,cAAc,EAAf,CAAd,GAAmCH,iBAAiB,CAACtB,CAArD;AACD;;AAEDtD,IAAAA,KAAK,GAAGT,UAAU,CAAC+E,WAAX,GAAyB,CAAC7B,CAAC,GAAG,CAAL,IAAU8B,UAA3C;AACD,GAxJD,CA0JA;;;AACA,OAAK9B,CAAC,GAAG2B,MAAT,EAAiB3B,CAAC,GAAG,CAArB,EAAwB,EAAEA,CAA1B,EAA6B;AAC3BzC,IAAAA,KAAK,GAAGT,UAAU,CAAC+E,WAAX,GAAyB,CAAC7B,CAAC,GAAG,CAAL,IAAU8B,UAA3C;AAEA3B,IAAAA,QAAQ,GAAG7C,gBAAgB,CACzB,CAACC,KADwB,EAEzBC,QAFyB,EAGzBC,QAHyB,EAIzBC,OAJyB,EAKzBC,IALyB,EAMzBC,EANyB,EAOzBC,IAPyB,EAQzBC,GARyB,EASzBC,OATyB,EAUzBoC,QAVyB,CAA3B;AAYAgC,IAAAA,iBAAiB,GAAG7E,gBAAgB,CAClCC,KAAK,GAAGY,IAAI,CAACyE,EADqB,EAElCpF,QAFkC,EAGlCC,QAHkC,EAIlCC,OAJkC,EAKlCC,IALkC,EAMlCC,EANkC,EAOlCC,IAPkC,EAQlCC,GARkC,EASlCC,OATkC,EAUlCoE,iBAVkC,CAApC;;AAaA,QAAIjB,gBAAJ,EAAsB;AACpB7B,MAAAA,SAAS,CAAC6C,aAAa,EAAd,CAAT,GAA6B/B,QAAQ,CAACQ,CAAtC;AACAtB,MAAAA,SAAS,CAAC6C,aAAa,EAAd,CAAT,GAA6B/B,QAAQ,CAACS,CAAtC;AACAvB,MAAAA,SAAS,CAAC6C,aAAa,EAAd,CAAT,GAA6B/B,QAAQ,CAACU,CAAtC;AAEA4B,MAAAA,WAAW,GAAG,KAAKzC,CAAC,GAAG,CAAT,IAAc,CAA5B;;AACA,WAAKwC,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGC,WAAW,GAAG,CAA9B,EAAiC,EAAED,CAAnC,EAAsC;AACpCE,QAAAA,CAAC,GAAGF,CAAC,IAAIC,WAAW,GAAG,CAAlB,CAAL;AACAE,QAAAA,gBAAgB,GAAG9F,UAAU,CAACgG,IAAX,CACjB1C,QADiB,EAEjBgC,iBAFiB,EAGjBO,CAHiB,EAIjBxD,iBAJiB,CAAnB;AAMAG,QAAAA,SAAS,CAAC6C,aAAa,EAAd,CAAT,GAA6BS,gBAAgB,CAAChC,CAA9C;AACAtB,QAAAA,SAAS,CAAC6C,aAAa,EAAd,CAAT,GAA6BS,gBAAgB,CAAC/B,CAA9C;AACAvB,QAAAA,SAAS,CAAC6C,aAAa,EAAd,CAAT,GAA6BS,gBAAgB,CAAC9B,CAA9C;AACD;;AAEDxB,MAAAA,SAAS,CAAC6C,aAAa,EAAd,CAAT,GAA6BC,iBAAiB,CAACxB,CAA/C;AACAtB,MAAAA,SAAS,CAAC6C,aAAa,EAAd,CAAT,GAA6BC,iBAAiB,CAACvB,CAA/C;AACAvB,MAAAA,SAAS,CAAC6C,aAAa,EAAd,CAAT,GAA6BC,iBAAiB,CAACtB,CAA/C;AACD;;AAED,QAAIM,gBAAJ,EAAsB;AACpBoB,MAAAA,cAAc,CAACF,eAAe,EAAhB,CAAd,GAAoClC,QAAQ,CAACU,CAA7C;AACA0B,MAAAA,cAAc,CAACF,eAAe,EAAhB,CAAd,GAAoClC,QAAQ,CAACS,CAA7C;AACA2B,MAAAA,cAAc,CAACF,eAAe,EAAhB,CAAd,GAAoClC,QAAQ,CAACQ,CAA7C;AACA4B,MAAAA,cAAc,CAACD,cAAc,EAAf,CAAd,GAAmCH,iBAAiB,CAACxB,CAArD;AACA4B,MAAAA,cAAc,CAACD,cAAc,EAAf,CAAd,GAAmCH,iBAAiB,CAACvB,CAArD;AACA2B,MAAAA,cAAc,CAACD,cAAc,EAAf,CAAd,GAAmCH,iBAAiB,CAACtB,CAArD;AACD;AACF;;AAEDtD,EAAAA,KAAK,GAAGT,UAAU,CAAC+E,WAAnB;AACA1B,EAAAA,QAAQ,GAAG7C,gBAAgB,CACzB,CAACC,KADwB,EAEzBC,QAFyB,EAGzBC,QAHyB,EAIzBC,OAJyB,EAKzBC,IALyB,EAMzBC,EANyB,EAOzBC,IAPyB,EAQzBC,GARyB,EASzBC,OATyB,EAUzBoC,QAVyB,CAA3B;AAaA,MAAI2C,CAAC,GAAG,EAAR;;AACA,MAAI5B,gBAAJ,EAAsB;AACpB7B,IAAAA,SAAS,CAAC6C,aAAa,EAAd,CAAT,GAA6B/B,QAAQ,CAACQ,CAAtC;AACAtB,IAAAA,SAAS,CAAC6C,aAAa,EAAd,CAAT,GAA6B/B,QAAQ,CAACS,CAAtC;AACAvB,IAAAA,SAAS,CAAC6C,aAAa,EAAd,CAAT,GAA6B/B,QAAQ,CAACU,CAAtC;AACAiC,IAAAA,CAAC,CAACzD,SAAF,GAAcA,SAAd;AACAyD,IAAAA,CAAC,CAACnB,MAAF,GAAWA,MAAX;AACD;;AACD,MAAIR,gBAAJ,EAAsB;AACpBoB,IAAAA,cAAc,CAACF,eAAe,EAAhB,CAAd,GAAoClC,QAAQ,CAACU,CAA7C;AACA0B,IAAAA,cAAc,CAACF,eAAe,EAAhB,CAAd,GAAoClC,QAAQ,CAACS,CAA7C;AACA2B,IAAAA,cAAc,CAACF,eAAe,EAAhB,CAAd,GAAoClC,QAAQ,CAACQ,CAA7C;AACAmC,IAAAA,CAAC,CAACP,cAAF,GAAmBA,cAAnB;AACD;;AAED,SAAOO,CAAP;AACD,CA3PD;;AA4PA,eAAe7F,sBAAf","sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Quaternion from \"./Quaternion.js\";\n\nvar EllipseGeometryLibrary = {};\n\nvar rotAxis = new Cartesian3();\nvar tempVec = new Cartesian3();\nvar unitQuat = new Quaternion();\nvar rotMtx = new Matrix3();\n\nfunction pointOnEllipsoid(\n  theta,\n  rotation,\n  northVec,\n  eastVec,\n  aSqr,\n  ab,\n  bSqr,\n  mag,\n  unitPos,\n  result\n) {\n  var azimuth = theta + rotation;\n\n  Cartesian3.multiplyByScalar(eastVec, Math.cos(azimuth), rotAxis);\n  Cartesian3.multiplyByScalar(northVec, Math.sin(azimuth), tempVec);\n  Cartesian3.add(rotAxis, tempVec, rotAxis);\n\n  var cosThetaSquared = Math.cos(theta);\n  cosThetaSquared = cosThetaSquared * cosThetaSquared;\n\n  var sinThetaSquared = Math.sin(theta);\n  sinThetaSquared = sinThetaSquared * sinThetaSquared;\n\n  var radius = ab / Math.sqrt(bSqr * cosThetaSquared + aSqr * sinThetaSquared);\n  var angle = radius / mag;\n\n  // Create the quaternion to rotate the position vector to the boundary of the ellipse.\n  Quaternion.fromAxisAngle(rotAxis, angle, unitQuat);\n  Matrix3.fromQuaternion(unitQuat, rotMtx);\n\n  Matrix3.multiplyByVector(rotMtx, unitPos, result);\n  Cartesian3.normalize(result, result);\n  Cartesian3.multiplyByScalar(result, mag, result);\n  return result;\n}\n\nvar scratchCartesian1 = new Cartesian3();\nvar scratchCartesian2 = new Cartesian3();\nvar scratchCartesian3 = new Cartesian3();\nvar scratchNormal = new Cartesian3();\n/**\n * Returns the positions raised to the given heights\n * @private\n */\nEllipseGeometryLibrary.raisePositionsToHeight = function (\n  positions,\n  options,\n  extrude\n) {\n  var ellipsoid = options.ellipsoid;\n  var height = options.height;\n  var extrudedHeight = options.extrudedHeight;\n  var size = extrude ? (positions.length / 3) * 2 : positions.length / 3;\n\n  var finalPositions = new Float64Array(size * 3);\n\n  var length = positions.length;\n  var bottomOffset = extrude ? length : 0;\n  for (var i = 0; i < length; i += 3) {\n    var i1 = i + 1;\n    var i2 = i + 2;\n\n    var position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n    ellipsoid.scaleToGeodeticSurface(position, position);\n\n    var extrudedPosition = Cartesian3.clone(position, scratchCartesian2);\n    var normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\n    var scaledNormal = Cartesian3.multiplyByScalar(\n      normal,\n      height,\n      scratchCartesian3\n    );\n    Cartesian3.add(position, scaledNormal, position);\n\n    if (extrude) {\n      Cartesian3.multiplyByScalar(normal, extrudedHeight, scaledNormal);\n      Cartesian3.add(extrudedPosition, scaledNormal, extrudedPosition);\n\n      finalPositions[i + bottomOffset] = extrudedPosition.x;\n      finalPositions[i1 + bottomOffset] = extrudedPosition.y;\n      finalPositions[i2 + bottomOffset] = extrudedPosition.z;\n    }\n\n    finalPositions[i] = position.x;\n    finalPositions[i1] = position.y;\n    finalPositions[i2] = position.z;\n  }\n\n  return finalPositions;\n};\n\nvar unitPosScratch = new Cartesian3();\nvar eastVecScratch = new Cartesian3();\nvar northVecScratch = new Cartesian3();\n/**\n * Returns an array of positions that make up the ellipse.\n * @private\n */\nEllipseGeometryLibrary.computeEllipsePositions = function (\n  options,\n  addFillPositions,\n  addEdgePositions\n) {\n  var semiMinorAxis = options.semiMinorAxis;\n  var semiMajorAxis = options.semiMajorAxis;\n  var rotation = options.rotation;\n  var center = options.center;\n\n  // Computing the arc-length of the ellipse is too expensive to be practical. Estimating it using the\n  // arc length of the sphere is too inaccurate and creates sharp edges when either the semi-major or\n  // semi-minor axis is much bigger than the other. Instead, scale the angle delta to make\n  // the distance along the ellipse boundary more closely match the granularity.\n  var granularity = options.granularity * 8.0;\n\n  var aSqr = semiMinorAxis * semiMinorAxis;\n  var bSqr = semiMajorAxis * semiMajorAxis;\n  var ab = semiMajorAxis * semiMinorAxis;\n\n  var mag = Cartesian3.magnitude(center);\n\n  var unitPos = Cartesian3.normalize(center, unitPosScratch);\n  var eastVec = Cartesian3.cross(Cartesian3.UNIT_Z, center, eastVecScratch);\n  eastVec = Cartesian3.normalize(eastVec, eastVec);\n  var northVec = Cartesian3.cross(unitPos, eastVec, northVecScratch);\n\n  // The number of points in the first quadrant\n  var numPts = 1 + Math.ceil(CesiumMath.PI_OVER_TWO / granularity);\n\n  var deltaTheta = CesiumMath.PI_OVER_TWO / (numPts - 1);\n  var theta = CesiumMath.PI_OVER_TWO - numPts * deltaTheta;\n  if (theta < 0.0) {\n    numPts -= Math.ceil(Math.abs(theta) / deltaTheta);\n  }\n\n  // If the number of points were three, the ellipse\n  // would be tessellated like below:\n  //\n  //         *---*\n  //       / | \\ | \\\n  //     *---*---*---*\n  //   / | \\ | \\ | \\ | \\\n  //  / .*---*---*---*. \\\n  // * ` | \\ | \\ | \\ | `*\n  //  \\`.*---*---*---*.`/\n  //   \\ | \\ | \\ | \\ | /\n  //     *---*---*---*\n  //       \\ | \\ | /\n  //         *---*\n  // The first and last column have one position and fan to connect to the adjacent column.\n  // Each other vertical column contains an even number of positions.\n  var size = 2 * (numPts * (numPts + 2));\n  var positions = addFillPositions ? new Array(size * 3) : undefined;\n  var positionIndex = 0;\n  var position = scratchCartesian1;\n  var reflectedPosition = scratchCartesian2;\n\n  var outerPositionsLength = numPts * 4 * 3;\n  var outerRightIndex = outerPositionsLength - 1;\n  var outerLeftIndex = 0;\n  var outerPositions = addEdgePositions\n    ? new Array(outerPositionsLength)\n    : undefined;\n\n  var i;\n  var j;\n  var numInterior;\n  var t;\n  var interiorPosition;\n\n  // Compute points in the 'eastern' half of the ellipse\n  theta = CesiumMath.PI_OVER_TWO;\n  position = pointOnEllipsoid(\n    theta,\n    rotation,\n    northVec,\n    eastVec,\n    aSqr,\n    ab,\n    bSqr,\n    mag,\n    unitPos,\n    position\n  );\n  if (addFillPositions) {\n    positions[positionIndex++] = position.x;\n    positions[positionIndex++] = position.y;\n    positions[positionIndex++] = position.z;\n  }\n  if (addEdgePositions) {\n    outerPositions[outerRightIndex--] = position.z;\n    outerPositions[outerRightIndex--] = position.y;\n    outerPositions[outerRightIndex--] = position.x;\n  }\n  theta = CesiumMath.PI_OVER_TWO - deltaTheta;\n  for (i = 1; i < numPts + 1; ++i) {\n    position = pointOnEllipsoid(\n      theta,\n      rotation,\n      northVec,\n      eastVec,\n      aSqr,\n      ab,\n      bSqr,\n      mag,\n      unitPos,\n      position\n    );\n    reflectedPosition = pointOnEllipsoid(\n      Math.PI - theta,\n      rotation,\n      northVec,\n      eastVec,\n      aSqr,\n      ab,\n      bSqr,\n      mag,\n      unitPos,\n      reflectedPosition\n    );\n\n    if (addFillPositions) {\n      positions[positionIndex++] = position.x;\n      positions[positionIndex++] = position.y;\n      positions[positionIndex++] = position.z;\n\n      numInterior = 2 * i + 2;\n      for (j = 1; j < numInterior - 1; ++j) {\n        t = j / (numInterior - 1);\n        interiorPosition = Cartesian3.lerp(\n          position,\n          reflectedPosition,\n          t,\n          scratchCartesian3\n        );\n        positions[positionIndex++] = interiorPosition.x;\n        positions[positionIndex++] = interiorPosition.y;\n        positions[positionIndex++] = interiorPosition.z;\n      }\n\n      positions[positionIndex++] = reflectedPosition.x;\n      positions[positionIndex++] = reflectedPosition.y;\n      positions[positionIndex++] = reflectedPosition.z;\n    }\n\n    if (addEdgePositions) {\n      outerPositions[outerRightIndex--] = position.z;\n      outerPositions[outerRightIndex--] = position.y;\n      outerPositions[outerRightIndex--] = position.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.y;\n      outerPositions[outerLeftIndex++] = reflectedPosition.z;\n    }\n\n    theta = CesiumMath.PI_OVER_TWO - (i + 1) * deltaTheta;\n  }\n\n  // Compute points in the 'western' half of the ellipse\n  for (i = numPts; i > 1; --i) {\n    theta = CesiumMath.PI_OVER_TWO - (i - 1) * deltaTheta;\n\n    position = pointOnEllipsoid(\n      -theta,\n      rotation,\n      northVec,\n      eastVec,\n      aSqr,\n      ab,\n      bSqr,\n      mag,\n      unitPos,\n      position\n    );\n    reflectedPosition = pointOnEllipsoid(\n      theta + Math.PI,\n      rotation,\n      northVec,\n      eastVec,\n      aSqr,\n      ab,\n      bSqr,\n      mag,\n      unitPos,\n      reflectedPosition\n    );\n\n    if (addFillPositions) {\n      positions[positionIndex++] = position.x;\n      positions[positionIndex++] = position.y;\n      positions[positionIndex++] = position.z;\n\n      numInterior = 2 * (i - 1) + 2;\n      for (j = 1; j < numInterior - 1; ++j) {\n        t = j / (numInterior - 1);\n        interiorPosition = Cartesian3.lerp(\n          position,\n          reflectedPosition,\n          t,\n          scratchCartesian3\n        );\n        positions[positionIndex++] = interiorPosition.x;\n        positions[positionIndex++] = interiorPosition.y;\n        positions[positionIndex++] = interiorPosition.z;\n      }\n\n      positions[positionIndex++] = reflectedPosition.x;\n      positions[positionIndex++] = reflectedPosition.y;\n      positions[positionIndex++] = reflectedPosition.z;\n    }\n\n    if (addEdgePositions) {\n      outerPositions[outerRightIndex--] = position.z;\n      outerPositions[outerRightIndex--] = position.y;\n      outerPositions[outerRightIndex--] = position.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.y;\n      outerPositions[outerLeftIndex++] = reflectedPosition.z;\n    }\n  }\n\n  theta = CesiumMath.PI_OVER_TWO;\n  position = pointOnEllipsoid(\n    -theta,\n    rotation,\n    northVec,\n    eastVec,\n    aSqr,\n    ab,\n    bSqr,\n    mag,\n    unitPos,\n    position\n  );\n\n  var r = {};\n  if (addFillPositions) {\n    positions[positionIndex++] = position.x;\n    positions[positionIndex++] = position.y;\n    positions[positionIndex++] = position.z;\n    r.positions = positions;\n    r.numPts = numPts;\n  }\n  if (addEdgePositions) {\n    outerPositions[outerRightIndex--] = position.z;\n    outerPositions[outerRightIndex--] = position.y;\n    outerPositions[outerRightIndex--] = position.x;\n    r.outerPositions = outerPositions;\n  }\n\n  return r;\n};\nexport default EllipseGeometryLibrary;\n"]},"metadata":{},"sourceType":"module"}