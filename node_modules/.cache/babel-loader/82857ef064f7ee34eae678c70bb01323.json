{"ast":null,"code":"import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport BoxGeometry from \"../Core/BoxGeometry.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport CullingVolume from \"../Core/CullingVolume.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EllipsoidGeometry from \"../Core/EllipsoidGeometry.js\";\nimport Event from \"../Core/Event.js\";\nimport GeographicProjection from \"../Core/GeographicProjection.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport mergeSort from \"../Core/mergeSort.js\";\nimport Occluder from \"../Core/Occluder.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport PerspectiveOffCenterFrustum from \"../Core/PerspectiveOffCenterFrustum.js\";\nimport RequestScheduler from \"../Core/RequestScheduler.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport ComputeEngine from \"../Renderer/ComputeEngine.js\";\nimport Context from \"../Renderer/Context.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport BrdfLutGenerator from \"./BrdfLutGenerator.js\";\nimport Camera from \"./Camera.js\";\nimport Cesium3DTilePass from \"./Cesium3DTilePass.js\";\nimport Cesium3DTilePassState from \"./Cesium3DTilePassState.js\";\nimport CreditDisplay from \"./CreditDisplay.js\";\nimport DebugCameraPrimitive from \"./DebugCameraPrimitive.js\";\nimport DepthPlane from \"./DepthPlane.js\";\nimport DerivedCommand from \"./DerivedCommand.js\";\nimport DeviceOrientationCameraController from \"./DeviceOrientationCameraController.js\";\nimport Fog from \"./Fog.js\";\nimport FrameState from \"./FrameState.js\";\nimport GlobeDepth from \"./GlobeDepth.js\";\nimport InvertClassification from \"./InvertClassification.js\";\nimport JobScheduler from \"./JobScheduler.js\";\nimport MapMode2D from \"./MapMode2D.js\";\nimport OctahedralProjectedCubeMap from \"./OctahedralProjectedCubeMap.js\";\nimport PerformanceDisplay from \"./PerformanceDisplay.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Picking from \"./Picking.js\";\nimport PostProcessStageCollection from \"./PostProcessStageCollection.js\";\nimport Primitive from \"./Primitive.js\";\nimport PrimitiveCollection from \"./PrimitiveCollection.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport SceneTransforms from \"./SceneTransforms.js\";\nimport SceneTransitioner from \"./SceneTransitioner.js\";\nimport ScreenSpaceCameraController from \"./ScreenSpaceCameraController.js\";\nimport ShadowMap from \"./ShadowMap.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport SunLight from \"./SunLight.js\";\nimport SunPostProcess from \"./SunPostProcess.js\";\nimport TweenCollection from \"./TweenCollection.js\";\nimport View from \"./View.js\";\n\nvar requestRenderAfterFrame = function (scene) {\n  return function () {\n    scene.frameState.afterRender.push(function () {\n      scene.requestRender();\n    });\n  };\n};\n/**\n * The container for all 3D graphical objects and state in a Cesium virtual scene.  Generally,\n * a scene is not created directly; instead, it is implicitly created by {@link CesiumWidget}.\n * <p>\n * <em><code>contextOptions</code> parameter details:</em>\n * </p>\n * <p>\n * The default values are:\n * <code>\n * {\n *   webgl : {\n *     alpha : false,\n *     depth : true,\n *     stencil : false,\n *     antialias : true,\n *     powerPreference: 'high-performance',\n *     premultipliedAlpha : true,\n *     preserveDrawingBuffer : false,\n *     failIfMajorPerformanceCaveat : false\n *   },\n *   allowTextureFilterAnisotropic : true\n * }\n * </code>\n * </p>\n * <p>\n * The <code>webgl</code> property corresponds to the {@link http://www.khronos.org/registry/webgl/specs/latest/#5.2|WebGLContextAttributes}\n * object used to create the WebGL context.\n * </p>\n * <p>\n * <code>webgl.alpha</code> defaults to false, which can improve performance compared to the standard WebGL default\n * of true.  If an application needs to composite Cesium above other HTML elements using alpha-blending, set\n * <code>webgl.alpha</code> to true.\n * </p>\n * <p>\n * The other <code>webgl</code> properties match the WebGL defaults for {@link http://www.khronos.org/registry/webgl/specs/latest/#5.2|WebGLContextAttributes}.\n * </p>\n * <p>\n * <code>allowTextureFilterAnisotropic</code> defaults to true, which enables anisotropic texture filtering when the\n * WebGL extension is supported.  Setting this to false will improve performance, but hurt visual quality, especially for horizon views.\n * </p>\n *\n * @alias Scene\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Canvas} options.canvas The HTML canvas element to create the scene for.\n * @param {Object} [options.contextOptions] Context and WebGL creation properties.  See details above.\n * @param {Element} [options.creditContainer] The HTML element in which the credits will be displayed.\n * @param {Element} [options.creditViewport] The HTML element in which to display the credit popup.  If not specified, the viewport will be a added as a sibling of the canvas.\n * @param {MapProjection} [options.mapProjection=new GeographicProjection()] The map projection to use in 2D and Columbus View modes.\n * @param {Boolean} [options.orderIndependentTranslucency=true] If true and the configuration supports it, use order independent translucency.\n * @param {Boolean} [options.scene3DOnly=false] If true, optimizes memory use and performance for 3D mode but disables the ability to use 2D or Columbus View.\n * @param {Number} [options.terrainExaggeration=1.0] A scalar used to exaggerate the terrain. Note that terrain exaggeration will not modify any other primitive as they are positioned relative to the ellipsoid.\n * @param {Boolean} [options.shadows=false] Determines if shadows are cast by light sources.\n * @param {MapMode2D} [options.mapMode2D=MapMode2D.INFINITE_SCROLL] Determines if the 2D map is rotatable or can be scrolled infinitely in the horizontal direction.\n * @param {Boolean} [options.requestRenderMode=false] If true, rendering a frame will only occur when needed as determined by changes within the scene. Enabling improves performance of the application, but requires using {@link Scene#requestRender} to render a new frame explicitly in this mode. This will be necessary in many cases after making changes to the scene in other parts of the API. See {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}.\n * @param {Number} [options.maximumRenderTimeChange=0.0] If requestRenderMode is true, this value defines the maximum change in simulation time allowed before a render is requested. See {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}.\n *\n * @see CesiumWidget\n * @see {@link http://www.khronos.org/registry/webgl/specs/latest/#5.2|WebGLContextAttributes}\n *\n * @exception {DeveloperError} options and options.canvas are required.\n *\n * @example\n * // Create scene without anisotropic texture filtering\n * var scene = new Cesium.Scene({\n *   canvas : canvas,\n *   contextOptions : {\n *     allowTextureFilterAnisotropic : false\n *   }\n * });\n */\n\n\nfunction Scene(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var canvas = options.canvas;\n  var creditContainer = options.creditContainer;\n  var creditViewport = options.creditViewport;\n  var contextOptions = clone(options.contextOptions);\n\n  if (!defined(contextOptions)) {\n    contextOptions = {};\n  }\n\n  if (!defined(contextOptions.webgl)) {\n    contextOptions.webgl = {};\n  }\n\n  contextOptions.webgl.powerPreference = defaultValue(contextOptions.webgl.powerPreference, \"high-performance\"); //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(canvas)) {\n    throw new DeveloperError(\"options and options.canvas are required.\");\n  } //>>includeEnd('debug');\n\n\n  var hasCreditContainer = defined(creditContainer);\n  var context = new Context(canvas, contextOptions);\n\n  if (!hasCreditContainer) {\n    creditContainer = document.createElement(\"div\");\n    creditContainer.style.position = \"absolute\";\n    creditContainer.style.bottom = \"0\";\n    creditContainer.style[\"text-shadow\"] = \"0 0 2px #000000\";\n    creditContainer.style.color = \"#ffffff\";\n    creditContainer.style[\"font-size\"] = \"10px\";\n    creditContainer.style[\"padding-right\"] = \"5px\";\n    canvas.parentNode.appendChild(creditContainer);\n  }\n\n  if (!defined(creditViewport)) {\n    creditViewport = canvas.parentNode;\n  }\n\n  this._id = createGuid();\n  this._jobScheduler = new JobScheduler();\n  this._frameState = new FrameState(context, new CreditDisplay(creditContainer, \" â€¢ \", creditViewport), this._jobScheduler);\n  this._frameState.scene3DOnly = defaultValue(options.scene3DOnly, false);\n  this._removeCreditContainer = !hasCreditContainer;\n  this._creditContainer = creditContainer;\n  this._canvas = canvas;\n  this._context = context;\n  this._computeEngine = new ComputeEngine(context);\n  this._globe = undefined;\n  this._primitives = new PrimitiveCollection();\n  this._groundPrimitives = new PrimitiveCollection();\n  this._logDepthBuffer = context.fragmentDepth;\n  this._logDepthBufferDirty = true;\n  this._tweens = new TweenCollection();\n  this._shaderFrameCount = 0;\n  this._sunPostProcess = undefined;\n  this._computeCommandList = [];\n  this._overlayCommandList = [];\n  this._useOIT = defaultValue(options.orderIndependentTranslucency, true);\n  this._executeOITFunction = undefined;\n  this._depthPlane = new DepthPlane();\n  this._clearColorCommand = new ClearCommand({\n    color: new Color(),\n    stencil: 0,\n    owner: this\n  });\n  this._depthClearCommand = new ClearCommand({\n    depth: 1.0,\n    owner: this\n  });\n  this._stencilClearCommand = new ClearCommand({\n    stencil: 0\n  });\n  this._classificationStencilClearCommand = new ClearCommand({\n    stencil: 0,\n    renderState: RenderState.fromCache({\n      stencilMask: StencilConstants.CLASSIFICATION_MASK\n    })\n  });\n  this._depthOnlyRenderStateCache = {};\n  this._transitioner = new SceneTransitioner(this);\n  this._preUpdate = new Event();\n  this._postUpdate = new Event();\n  this._renderError = new Event();\n  this._preRender = new Event();\n  this._postRender = new Event();\n  this._minimumDisableDepthTestDistance = 0.0;\n  /**\n   * Exceptions occurring in <code>render</code> are always caught in order to raise the\n   * <code>renderError</code> event.  If this property is true, the error is rethrown\n   * after the event is raised.  If this property is false, the <code>render</code> function\n   * returns normally after raising the event.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n\n  this.rethrowRenderErrors = false;\n  /**\n   * Determines whether or not to instantly complete the\n   * scene transition animation on user input.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.completeMorphOnUserInput = true;\n  /**\n   * The event fired at the beginning of a scene transition.\n   * @type {Event}\n   * @default Event()\n   */\n\n  this.morphStart = new Event();\n  /**\n   * The event fired at the completion of a scene transition.\n   * @type {Event}\n   * @default Event()\n   */\n\n  this.morphComplete = new Event();\n  /**\n   * The {@link SkyBox} used to draw the stars.\n   *\n   * @type {SkyBox}\n   * @default undefined\n   *\n   * @see Scene#backgroundColor\n   */\n\n  this.skyBox = undefined;\n  /**\n   * The sky atmosphere drawn around the globe.\n   *\n   * @type {SkyAtmosphere}\n   * @default undefined\n   */\n\n  this.skyAtmosphere = undefined;\n  /**\n   * The {@link Sun}.\n   *\n   * @type {Sun}\n   * @default undefined\n   */\n\n  this.sun = undefined;\n  /**\n   * Uses a bloom filter on the sun when enabled.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.sunBloom = true;\n  this._sunBloom = undefined;\n  /**\n   * The {@link Moon}\n   *\n   * @type Moon\n   * @default undefined\n   */\n\n  this.moon = undefined;\n  /**\n   * The background color, which is only visible if there is no sky box, i.e., {@link Scene#skyBox} is undefined.\n   *\n   * @type {Color}\n   * @default {@link Color.BLACK}\n   *\n   * @see Scene#skyBox\n   */\n\n  this.backgroundColor = Color.clone(Color.BLACK);\n  this._mode = SceneMode.SCENE3D;\n  this._mapProjection = defined(options.mapProjection) ? options.mapProjection : new GeographicProjection();\n  /**\n   * The current morph transition time between 2D/Columbus View and 3D,\n   * with 0.0 being 2D or Columbus View and 1.0 being 3D.\n   *\n   * @type {Number}\n   * @default 1.0\n   */\n\n  this.morphTime = 1.0;\n  /**\n   * The far-to-near ratio of the multi-frustum when using a normal depth buffer.\n   * <p>\n   * This value is used to create the near and far values for each frustum of the multi-frustum. It is only used\n   * when {@link Scene#logarithmicDepthBuffer} is <code>false</code>. When <code>logarithmicDepthBuffer</code> is\n   * <code>true</code>, use {@link Scene#logarithmicDepthFarToNearRatio}.\n   * </p>\n   *\n   * @type {Number}\n   * @default 1000.0\n   */\n\n  this.farToNearRatio = 1000.0;\n  /**\n   * The far-to-near ratio of the multi-frustum when using a logarithmic depth buffer.\n   * <p>\n   * This value is used to create the near and far values for each frustum of the multi-frustum. It is only used\n   * when {@link Scene#logarithmicDepthBuffer} is <code>true</code>. When <code>logarithmicDepthBuffer</code> is\n   * <code>false</code>, use {@link Scene#farToNearRatio}.\n   * </p>\n   *\n   * @type {Number}\n   * @default 1e9\n   */\n\n  this.logarithmicDepthFarToNearRatio = 1e9;\n  /**\n   * Determines the uniform depth size in meters of each frustum of the multifrustum in 2D. If a primitive or model close\n   * to the surface shows z-fighting, decreasing this will eliminate the artifact, but decrease performance. On the\n   * other hand, increasing this will increase performance but may cause z-fighting among primitives close to the surface.\n   *\n   * @type {Number}\n   * @default 1.75e6\n   */\n\n  this.nearToFarDistance2D = 1.75e6;\n  /**\n   * This property is for debugging only; it is not for production use.\n   * <p>\n   * A function that determines what commands are executed.  As shown in the examples below,\n   * the function receives the command's <code>owner</code> as an argument, and returns a boolean indicating if the\n   * command should be executed.\n   * </p>\n   * <p>\n   * The default is <code>undefined</code>, indicating that all commands are executed.\n   * </p>\n   *\n   * @type Function\n   *\n   * @default undefined\n   *\n   * @example\n   * // Do not execute any commands.\n   * scene.debugCommandFilter = function(command) {\n   *     return false;\n   * };\n   *\n   * // Execute only the billboard's commands.  That is, only draw the billboard.\n   * var billboards = new Cesium.BillboardCollection();\n   * scene.debugCommandFilter = function(command) {\n   *     return command.owner === billboards;\n   * };\n   */\n\n  this.debugCommandFilter = undefined;\n  /**\n   * This property is for debugging only; it is not for production use.\n   * <p>\n   * When <code>true</code>, commands are randomly shaded.  This is useful\n   * for performance analysis to see what parts of a scene or model are\n   * command-dense and could benefit from batching.\n   * </p>\n   *\n   * @type Boolean\n   *\n   * @default false\n   */\n\n  this.debugShowCommands = false;\n  /**\n   * This property is for debugging only; it is not for production use.\n   * <p>\n   * When <code>true</code>, commands are shaded based on the frustums they\n   * overlap.  Commands in the closest frustum are tinted red, commands in\n   * the next closest are green, and commands in the farthest frustum are\n   * blue.  If a command overlaps more than one frustum, the color components\n   * are combined, e.g., a command overlapping the first two frustums is tinted\n   * yellow.\n   * </p>\n   *\n   * @type Boolean\n   *\n   * @default false\n   */\n\n  this.debugShowFrustums = false;\n  /**\n   * This property is for debugging only; it is not for production use.\n   * <p>\n   * Displays frames per second and time between frames.\n   * </p>\n   *\n   * @type Boolean\n   *\n   * @default false\n   */\n\n  this.debugShowFramesPerSecond = false;\n  /**\n   * This property is for debugging only; it is not for production use.\n   * <p>\n   * Displays depth information for the indicated frustum.\n   * </p>\n   *\n   * @type Boolean\n   *\n   * @default false\n   */\n\n  this.debugShowGlobeDepth = false;\n  /**\n   * This property is for debugging only; it is not for production use.\n   * <p>\n   * Indicates which frustum will have depth information displayed.\n   * </p>\n   *\n   * @type Number\n   *\n   * @default 1\n   */\n\n  this.debugShowDepthFrustum = 1;\n  /**\n   * This property is for debugging only; it is not for production use.\n   * <p>\n   * When <code>true</code>, draws outlines to show the boundaries of the camera frustums\n   * </p>\n   *\n   * @type Boolean\n   *\n   * @default false\n   */\n\n  this.debugShowFrustumPlanes = false;\n  this._debugShowFrustumPlanes = false;\n  this._debugFrustumPlanes = undefined;\n  /**\n   * When <code>true</code>, enables picking using the depth buffer.\n   *\n   * @type Boolean\n   * @default true\n   */\n\n  this.useDepthPicking = true;\n  /**\n   * When <code>true</code>, enables picking translucent geometry using the depth buffer. Note that {@link Scene#useDepthPicking} must also be true for enabling this to work.\n   *\n   * <p>\n   * Render must be called between picks.\n   * <br>There is a decrease in performance when enabled. There are extra draw calls to write depth for\n   * translucent geometry.\n   * </p>\n   *\n   * @example\n   * // picking the position of a translucent primitive\n   * viewer.screenSpaceEventHandler.setInputAction(function onLeftClick(movement) {\n   *      var pickedFeature = viewer.scene.pick(movement.position);\n   *      if (!Cesium.defined(pickedFeature)) {\n   *          // nothing picked\n   *          return;\n   *      }\n   *      viewer.scene.render();\n   *      var worldPosition = viewer.scene.pickPosition(movement.position);\n   * }, Cesium.ScreenSpaceEventType.LEFT_CLICK);\n   *\n   * @type {Boolean}\n   * @default false\n   */\n\n  this.pickTranslucentDepth = false;\n  /**\n   * The time in milliseconds to wait before checking if the camera has not moved and fire the cameraMoveEnd event.\n   * @type {Number}\n   * @default 500.0\n   * @private\n   */\n\n  this.cameraEventWaitTime = 500.0;\n  /**\n   * Blends the atmosphere to geometry far from the camera for horizon views. Allows for additional\n   * performance improvements by rendering less geometry and dispatching less terrain requests.\n   * @type {Fog}\n   */\n\n  this.fog = new Fog();\n  this._shadowMapCamera = new Camera(this);\n  /**\n   * The shadow map for the scene's light source. When enabled, models, primitives, and the globe may cast and receive shadows.\n   * @type {ShadowMap}\n   */\n\n  this.shadowMap = new ShadowMap({\n    context: context,\n    lightCamera: this._shadowMapCamera,\n    enabled: defaultValue(options.shadows, false)\n  });\n  /**\n   * When <code>false</code>, 3D Tiles will render normally. When <code>true</code>, classified 3D Tile geometry will render normally and\n   * unclassified 3D Tile geometry will render with the color multiplied by {@link Scene#invertClassificationColor}.\n   * @type {Boolean}\n   * @default false\n   */\n\n  this.invertClassification = false;\n  /**\n   * The highlight color of unclassified 3D Tile geometry when {@link Scene#invertClassification} is <code>true</code>.\n   * <p>When the color's alpha is less than 1.0, the unclassified portions of the 3D Tiles will not blend correctly with the classified positions of the 3D Tiles.</p>\n   * <p>Also, when the color's alpha is less than 1.0, the WEBGL_depth_texture and EXT_frag_depth WebGL extensions must be supported.</p>\n   * @type {Color}\n   * @default Color.WHITE\n   */\n\n  this.invertClassificationColor = Color.clone(Color.WHITE);\n  this._actualInvertClassificationColor = Color.clone(this._invertClassificationColor);\n  this._invertClassification = new InvertClassification();\n  /**\n   * The focal length for use when with cardboard or WebVR.\n   * @type {Number}\n   */\n\n  this.focalLength = undefined;\n  /**\n   * The eye separation distance in meters for use with cardboard or WebVR.\n   * @type {Number}\n   */\n\n  this.eyeSeparation = undefined;\n  /**\n   * Post processing effects applied to the final render.\n   * @type {PostProcessStageCollection}\n   */\n\n  this.postProcessStages = new PostProcessStageCollection();\n  this._brdfLutGenerator = new BrdfLutGenerator();\n  this._terrainExaggeration = defaultValue(options.terrainExaggeration, 1.0);\n  this._performanceDisplay = undefined;\n  this._debugVolume = undefined;\n  this._screenSpaceCameraController = new ScreenSpaceCameraController(this);\n  this._cameraUnderground = false;\n  this._mapMode2D = defaultValue(options.mapMode2D, MapMode2D.INFINITE_SCROLL); // Keeps track of the state of a frame. FrameState is the state across\n  // the primitives of the scene. This state is for internally keeping track\n  // of celestial and environment effects that need to be updated/rendered in\n  // a certain order as well as updating/tracking framebuffer usage.\n\n  this._environmentState = {\n    skyBoxCommand: undefined,\n    skyAtmosphereCommand: undefined,\n    sunDrawCommand: undefined,\n    sunComputeCommand: undefined,\n    moonCommand: undefined,\n    isSunVisible: false,\n    isMoonVisible: false,\n    isReadyForAtmosphere: false,\n    isSkyAtmosphereVisible: false,\n    clearGlobeDepth: false,\n    useDepthPlane: false,\n    renderTranslucentDepthForPick: false,\n    originalFramebuffer: undefined,\n    useGlobeDepthFramebuffer: false,\n    separatePrimitiveFramebuffer: false,\n    useOIT: false,\n    useInvertClassification: false,\n    usePostProcess: false,\n    usePostProcessSelected: false,\n    useWebVR: false\n  };\n  this._useWebVR = false;\n  this._cameraVR = undefined;\n  this._aspectRatioVR = undefined;\n  /**\n   * When <code>true</code>, rendering a frame will only occur when needed as determined by changes within the scene.\n   * Enabling improves performance of the application, but requires using {@link Scene#requestRender}\n   * to render a new frame explicitly in this mode. This will be necessary in many cases after making changes\n   * to the scene in other parts of the API.\n   *\n   * @see {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}\n   * @see Scene#maximumRenderTimeChange\n   * @see Scene#requestRender\n   *\n   * @type {Boolean}\n   * @default false\n   */\n\n  this.requestRenderMode = defaultValue(options.requestRenderMode, false);\n  this._renderRequested = true;\n  /**\n   * If {@link Scene#requestRenderMode} is <code>true</code>, this value defines the maximum change in\n   * simulation time allowed before a render is requested. Lower values increase the number of frames rendered\n   * and higher values decrease the number of frames rendered. If <code>undefined</code>, changes to\n   * the simulation time will never request a render.\n   * This value impacts the rate of rendering for changes in the scene like lighting, entity property updates,\n   * and animations.\n   *\n   * @see {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}\n   * @see Scene#requestRenderMode\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.maximumRenderTimeChange = defaultValue(options.maximumRenderTimeChange, 0.0);\n  this._lastRenderTime = undefined;\n  this._frameRateMonitor = undefined;\n  this._removeRequestListenerCallback = RequestScheduler.requestCompletedEvent.addEventListener(requestRenderAfterFrame(this));\n  this._removeTaskProcessorListenerCallback = TaskProcessor.taskCompletedEvent.addEventListener(requestRenderAfterFrame(this));\n  this._removeGlobeCallbacks = [];\n  var viewport = new BoundingRectangle(0, 0, context.drawingBufferWidth, context.drawingBufferHeight);\n  var camera = new Camera(this);\n\n  if (this._logDepthBuffer) {\n    camera.frustum.near = 0.1;\n    camera.frustum.far = 10000000000.0;\n  }\n  /**\n   * The camera view for the scene camera flight destination. Used for preloading flight destination tiles.\n   * @type {Camera}\n   * @private\n   */\n\n\n  this.preloadFlightCamera = new Camera(this);\n  /**\n   * The culling volume for the scene camera flight destination. Used for preloading flight destination tiles.\n   * @type {CullingVolume}\n   * @private\n   */\n\n  this.preloadFlightCullingVolume = undefined;\n  this._picking = new Picking(this);\n  this._defaultView = new View(this, camera, viewport);\n  this._view = this._defaultView;\n  this._hdr = undefined;\n  this._hdrDirty = undefined;\n  this.highDynamicRange = false;\n  this.gamma = 2.2;\n  /**\n   * The spherical harmonic coefficients for image-based lighting of PBR models.\n   * @type {Cartesian3[]}\n   */\n\n  this.sphericalHarmonicCoefficients = undefined;\n  /**\n   * The url to the KTX file containing the specular environment map and convoluted mipmaps for image-based lighting of PBR models.\n   * @type {String}\n   */\n\n  this.specularEnvironmentMaps = undefined;\n  this._specularEnvironmentMapAtlas = undefined;\n  /**\n   * The light source for shading. Defaults to a directional light from the Sun.\n   * @type {Light}\n   */\n\n  this.light = new SunLight(); // Give frameState, camera, and screen space camera controller initial state before rendering\n\n  updateFrameNumber(this, 0.0, JulianDate.now());\n  this.updateFrameState();\n  this.initializeFrame();\n}\n\nfunction updateGlobeListeners(scene, globe) {\n  for (var i = 0; i < scene._removeGlobeCallbacks.length; ++i) {\n    scene._removeGlobeCallbacks[i]();\n  }\n\n  scene._removeGlobeCallbacks.length = 0;\n  var removeGlobeCallbacks = [];\n\n  if (defined(globe)) {\n    removeGlobeCallbacks.push(globe.imageryLayersUpdatedEvent.addEventListener(requestRenderAfterFrame(scene)));\n    removeGlobeCallbacks.push(globe.terrainProviderChanged.addEventListener(requestRenderAfterFrame(scene)));\n  }\n\n  scene._removeGlobeCallbacks = removeGlobeCallbacks;\n}\n\nObject.defineProperties(Scene.prototype, {\n  /**\n   * Gets the canvas element to which this scene is bound.\n   * @memberof Scene.prototype\n   *\n   * @type {Canvas}\n   * @readonly\n   */\n  canvas: {\n    get: function () {\n      return this._canvas;\n    }\n  },\n\n  /**\n   * The drawingBufferHeight of the underlying GL context.\n   * @memberof Scene.prototype\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @see {@link https://www.khronos.org/registry/webgl/specs/1.0/#DOM-WebGLRenderingContext-drawingBufferHeight|drawingBufferHeight}\n   */\n  drawingBufferHeight: {\n    get: function () {\n      return this._context.drawingBufferHeight;\n    }\n  },\n\n  /**\n   * The drawingBufferHeight of the underlying GL context.\n   * @memberof Scene.prototype\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @see {@link https://www.khronos.org/registry/webgl/specs/1.0/#DOM-WebGLRenderingContext-drawingBufferHeight|drawingBufferHeight}\n   */\n  drawingBufferWidth: {\n    get: function () {\n      return this._context.drawingBufferWidth;\n    }\n  },\n\n  /**\n   * The maximum aliased line width, in pixels, supported by this WebGL implementation.  It will be at least one.\n   * @memberof Scene.prototype\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>ALIASED_LINE_WIDTH_RANGE</code>.\n   */\n  maximumAliasedLineWidth: {\n    get: function () {\n      return ContextLimits.maximumAliasedLineWidth;\n    }\n  },\n\n  /**\n   * The maximum length in pixels of one edge of a cube map, supported by this WebGL implementation.  It will be at least 16.\n   * @memberof Scene.prototype\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>GL_MAX_CUBE_MAP_TEXTURE_SIZE</code>.\n   */\n  maximumCubeMapSize: {\n    get: function () {\n      return ContextLimits.maximumCubeMapSize;\n    }\n  },\n\n  /**\n   * Returns <code>true</code> if the {@link Scene#pickPosition} function is supported.\n   * @memberof Scene.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @see Scene#pickPosition\n   */\n  pickPositionSupported: {\n    get: function () {\n      return this._context.depthTexture;\n    }\n  },\n\n  /**\n   * Returns <code>true</code> if the {@link Scene#sampleHeight} and {@link Scene#sampleHeightMostDetailed} functions are supported.\n   * @memberof Scene.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @see Scene#sampleHeight\n   * @see Scene#sampleHeightMostDetailed\n   */\n  sampleHeightSupported: {\n    get: function () {\n      return this._context.depthTexture;\n    }\n  },\n\n  /**\n   * Returns <code>true</code> if the {@link Scene#clampToHeight} and {@link Scene#clampToHeightMostDetailed} functions are supported.\n   * @memberof Scene.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @see Scene#clampToHeight\n   * @see Scene#clampToHeightMostDetailed\n   */\n  clampToHeightSupported: {\n    get: function () {\n      return this._context.depthTexture;\n    }\n  },\n\n  /**\n   * Returns <code>true</code> if the {@link Scene#invertClassification} is supported.\n   * @memberof Scene.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @see Scene#invertClassification\n   */\n  invertClassificationSupported: {\n    get: function () {\n      return this._context.depthTexture;\n    }\n  },\n\n  /**\n   * Returns <code>true</code> if specular environment maps are supported.\n   * @memberof Scene.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @see Scene#specularEnvironmentMaps\n   */\n  specularEnvironmentMapsSupported: {\n    get: function () {\n      return OctahedralProjectedCubeMap.isSupported(this._context);\n    }\n  },\n\n  /**\n   * Gets or sets the depth-test ellipsoid.\n   * @memberof Scene.prototype\n   *\n   * @type {Globe}\n   */\n  globe: {\n    get: function () {\n      return this._globe;\n    },\n    set: function (globe) {\n      this._globe = this._globe && this._globe.destroy();\n      this._globe = globe;\n      updateGlobeListeners(this, globe);\n    }\n  },\n\n  /**\n   * Gets the collection of primitives.\n   * @memberof Scene.prototype\n   *\n   * @type {PrimitiveCollection}\n   * @readonly\n   */\n  primitives: {\n    get: function () {\n      return this._primitives;\n    }\n  },\n\n  /**\n   * Gets the collection of ground primitives.\n   * @memberof Scene.prototype\n   *\n   * @type {PrimitiveCollection}\n   * @readonly\n   */\n  groundPrimitives: {\n    get: function () {\n      return this._groundPrimitives;\n    }\n  },\n\n  /**\n   * Gets or sets the camera.\n   * @memberof Scene.prototype\n   *\n   * @type {Camera}\n   * @readonly\n   */\n  camera: {\n    get: function () {\n      return this._view.camera;\n    },\n    set: function (camera) {\n      // For internal use only. Documentation is still @readonly.\n      this._view.camera = camera;\n    }\n  },\n\n  /**\n   * Gets or sets the view.\n   * @memberof Scene.prototype\n   *\n   * @type {View}\n   * @readonly\n   *\n   * @private\n   */\n  view: {\n    get: function () {\n      return this._view;\n    },\n    set: function (view) {\n      // For internal use only. Documentation is still @readonly.\n      this._view = view;\n    }\n  },\n\n  /**\n   * Gets the default view.\n   * @memberof Scene.prototype\n   *\n   * @type {View}\n   * @readonly\n   *\n   * @private\n   */\n  defaultView: {\n    get: function () {\n      return this._defaultView;\n    }\n  },\n\n  /**\n   * Gets picking functions and state\n   * @memberof Scene.prototype\n   *\n   * @type {Picking}\n   * @readonly\n   *\n   * @private\n   */\n  picking: {\n    get: function () {\n      return this._picking;\n    }\n  },\n\n  /**\n   * Gets the controller for camera input handling.\n   * @memberof Scene.prototype\n   *\n   * @type {ScreenSpaceCameraController}\n   * @readonly\n   */\n  screenSpaceCameraController: {\n    get: function () {\n      return this._screenSpaceCameraController;\n    }\n  },\n\n  /**\n   * Get the map projection to use in 2D and Columbus View modes.\n   * @memberof Scene.prototype\n   *\n   * @type {MapProjection}\n   * @readonly\n   *\n   * @default new GeographicProjection()\n   */\n  mapProjection: {\n    get: function () {\n      return this._mapProjection;\n    }\n  },\n\n  /**\n   * Gets the job scheduler\n   * @memberof Scene.prototype\n   * @type {JobScheduler}\n   * @readonly\n   *\n   * @private\n   */\n  jobScheduler: {\n    get: function () {\n      return this._jobScheduler;\n    }\n  },\n\n  /**\n   * Gets state information about the current scene. If called outside of a primitive's <code>update</code>\n   * function, the previous frame's state is returned.\n   * @memberof Scene.prototype\n   *\n   * @type {FrameState}\n   * @readonly\n   *\n   * @private\n   */\n  frameState: {\n    get: function () {\n      return this._frameState;\n    }\n  },\n\n  /**\n   * Gets the environment state.\n   * @memberof Scene.prototype\n   *\n   * @type {EnvironmentState}\n   * @readonly\n   *\n   * @private\n   */\n  environmentState: {\n    get: function () {\n      return this._environmentState;\n    }\n  },\n\n  /**\n   * Gets the collection of tweens taking place in the scene.\n   * @memberof Scene.prototype\n   *\n   * @type {TweenCollection}\n   * @readonly\n   *\n   * @private\n   */\n  tweens: {\n    get: function () {\n      return this._tweens;\n    }\n  },\n\n  /**\n   * Gets the collection of image layers that will be rendered on the globe.\n   * @memberof Scene.prototype\n   *\n   * @type {ImageryLayerCollection}\n   * @readonly\n   */\n  imageryLayers: {\n    get: function () {\n      if (!defined(this.globe)) {\n        return undefined;\n      }\n\n      return this.globe.imageryLayers;\n    }\n  },\n\n  /**\n   * The terrain provider providing surface geometry for the globe.\n   * @memberof Scene.prototype\n   *\n   * @type {TerrainProvider}\n   */\n  terrainProvider: {\n    get: function () {\n      if (!defined(this.globe)) {\n        return undefined;\n      }\n\n      return this.globe.terrainProvider;\n    },\n    set: function (terrainProvider) {\n      if (defined(this.globe)) {\n        this.globe.terrainProvider = terrainProvider;\n      }\n    }\n  },\n\n  /**\n   * Gets an event that's raised when the terrain provider is changed\n   * @memberof Scene.prototype\n   *\n   * @type {Event}\n   * @readonly\n   */\n  terrainProviderChanged: {\n    get: function () {\n      if (!defined(this.globe)) {\n        return undefined;\n      }\n\n      return this.globe.terrainProviderChanged;\n    }\n  },\n\n  /**\n   * Gets the event that will be raised before the scene is updated or rendered.  Subscribers to the event\n   * receive the Scene instance as the first parameter and the current time as the second parameter.\n   * @memberof Scene.prototype\n   *\n   * @see {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}\n   * @see Scene#postUpdate\n   * @see Scene#preRender\n   * @see Scene#postRender\n   *\n   * @type {Event}\n   * @readonly\n   */\n  preUpdate: {\n    get: function () {\n      return this._preUpdate;\n    }\n  },\n\n  /**\n   * Gets the event that will be raised immediately after the scene is updated and before the scene is rendered.\n   * Subscribers to the event receive the Scene instance as the first parameter and the current time as the second\n   * parameter.\n   * @memberof Scene.prototype\n   *\n   * @see {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}\n   * @see Scene#preUpdate\n   * @see Scene#preRender\n   * @see Scene#postRender\n   *\n   * @type {Event}\n   * @readonly\n   */\n  postUpdate: {\n    get: function () {\n      return this._postUpdate;\n    }\n  },\n\n  /**\n   * Gets the event that will be raised when an error is thrown inside the <code>render</code> function.\n   * The Scene instance and the thrown error are the only two parameters passed to the event handler.\n   * By default, errors are not rethrown after this event is raised, but that can be changed by setting\n   * the <code>rethrowRenderErrors</code> property.\n   * @memberof Scene.prototype\n   *\n   * @type {Event}\n   * @readonly\n   */\n  renderError: {\n    get: function () {\n      return this._renderError;\n    }\n  },\n\n  /**\n   * Gets the event that will be raised after the scene is updated and immediately before the scene is rendered.\n   * Subscribers to the event receive the Scene instance as the first parameter and the current time as the second\n   * parameter.\n   * @memberof Scene.prototype\n   *\n   * @see {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}\n   * @see Scene#preUpdate\n   * @see Scene#postUpdate\n   * @see Scene#postRender\n   *\n   * @type {Event}\n   * @readonly\n   */\n  preRender: {\n    get: function () {\n      return this._preRender;\n    }\n  },\n\n  /**\n   * Gets the event that will be raised immediately after the scene is rendered.  Subscribers to the event\n   * receive the Scene instance as the first parameter and the current time as the second parameter.\n   * @memberof Scene.prototype\n   *\n   * @see {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}\n   * @see Scene#preUpdate\n   * @see Scene#postUpdate\n   * @see Scene#postRender\n   *\n   * @type {Event}\n   * @readonly\n   */\n  postRender: {\n    get: function () {\n      return this._postRender;\n    }\n  },\n\n  /**\n   * Gets the simulation time when the scene was last rendered. Returns undefined if the scene has not yet been\n   * rendered.\n   * @memberof Scene.prototype\n   *\n   * @type {JulianDate}\n   * @readonly\n   */\n  lastRenderTime: {\n    get: function () {\n      return this._lastRenderTime;\n    }\n  },\n\n  /**\n   * @memberof Scene.prototype\n   * @private\n   * @readonly\n   */\n  context: {\n    get: function () {\n      return this._context;\n    }\n  },\n\n  /**\n   * This property is for debugging only; it is not for production use.\n   * <p>\n   * When {@link Scene.debugShowFrustums} is <code>true</code>, this contains\n   * properties with statistics about the number of command execute per frustum.\n   * <code>totalCommands</code> is the total number of commands executed, ignoring\n   * overlap. <code>commandsInFrustums</code> is an array with the number of times\n   * commands are executed redundantly, e.g., how many commands overlap two or\n   * three frustums.\n   * </p>\n   *\n   * @memberof Scene.prototype\n   *\n   * @type {Object}\n   * @readonly\n   *\n   * @default undefined\n   */\n  debugFrustumStatistics: {\n    get: function () {\n      return this._view.debugFrustumStatistics;\n    }\n  },\n\n  /**\n   * Gets whether or not the scene is optimized for 3D only viewing.\n   * @memberof Scene.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  scene3DOnly: {\n    get: function () {\n      return this._frameState.scene3DOnly;\n    }\n  },\n\n  /**\n   * Gets whether or not the scene has order independent translucency enabled.\n   * Note that this only reflects the original construction option, and there are\n   * other factors that could prevent OIT from functioning on a given system configuration.\n   * @memberof Scene.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  orderIndependentTranslucency: {\n    get: function () {\n      return this._useOIT;\n    }\n  },\n\n  /**\n   * Gets the unique identifier for this scene.\n   * @memberof Scene.prototype\n   * @type {String}\n   * @readonly\n   */\n  id: {\n    get: function () {\n      return this._id;\n    }\n  },\n\n  /**\n   * Gets or sets the current mode of the scene.\n   * @memberof Scene.prototype\n   * @type {SceneMode}\n   * @default {@link SceneMode.SCENE3D}\n   */\n  mode: {\n    get: function () {\n      return this._mode;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (this.scene3DOnly && value !== SceneMode.SCENE3D) {\n        throw new DeveloperError(\"Only SceneMode.SCENE3D is valid when scene3DOnly is true.\");\n      } //>>includeEnd('debug');\n\n\n      if (value === SceneMode.SCENE2D) {\n        this.morphTo2D(0);\n      } else if (value === SceneMode.SCENE3D) {\n        this.morphTo3D(0);\n      } else if (value === SceneMode.COLUMBUS_VIEW) {\n        this.morphToColumbusView(0); //>>includeStart('debug', pragmas.debug);\n      } else {\n        throw new DeveloperError(\"value must be a valid SceneMode enumeration.\"); //>>includeEnd('debug');\n      }\n\n      this._mode = value;\n    }\n  },\n\n  /**\n   * Gets the number of frustums used in the last frame.\n   * @memberof Scene.prototype\n   * @type {FrustumCommands[]}\n   *\n   * @private\n   */\n  frustumCommandsList: {\n    get: function () {\n      return this._view.frustumCommandsList;\n    }\n  },\n\n  /**\n   * Gets the number of frustums used in the last frame.\n   * @memberof Scene.prototype\n   * @type {Number}\n   *\n   * @private\n   */\n  numberOfFrustums: {\n    get: function () {\n      return this._view.frustumCommandsList.length;\n    }\n  },\n\n  /**\n   * Gets the scalar used to exaggerate the terrain.\n   * @memberof Scene.prototype\n   * @type {Number}\n   * @readonly\n   */\n  terrainExaggeration: {\n    get: function () {\n      return this._terrainExaggeration;\n    }\n  },\n\n  /**\n   * When <code>true</code>, splits the scene into two viewports with steroscopic views for the left and right eyes.\n   * Used for cardboard and WebVR.\n   * @memberof Scene.prototype\n   * @type {Boolean}\n   * @default false\n   */\n  useWebVR: {\n    get: function () {\n      return this._useWebVR;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (this.camera.frustum instanceof OrthographicFrustum) {\n        throw new DeveloperError(\"VR is unsupported with an orthographic projection.\");\n      } //>>includeEnd('debug');\n\n\n      this._useWebVR = value;\n\n      if (this._useWebVR) {\n        this._frameState.creditDisplay.container.style.visibility = \"hidden\";\n        this._cameraVR = new Camera(this);\n\n        if (!defined(this._deviceOrientationCameraController)) {\n          this._deviceOrientationCameraController = new DeviceOrientationCameraController(this);\n        }\n\n        this._aspectRatioVR = this.camera.frustum.aspectRatio;\n      } else {\n        this._frameState.creditDisplay.container.style.visibility = \"visible\";\n        this._cameraVR = undefined;\n        this._deviceOrientationCameraController = this._deviceOrientationCameraController && !this._deviceOrientationCameraController.isDestroyed() && this._deviceOrientationCameraController.destroy();\n        this.camera.frustum.aspectRatio = this._aspectRatioVR;\n        this.camera.frustum.xOffset = 0.0;\n      }\n    }\n  },\n\n  /**\n   * Determines if the 2D map is rotatable or can be scrolled infinitely in the horizontal direction.\n   * @memberof Scene.prototype\n   * @type {MapMode2D}\n   * @readonly\n   */\n  mapMode2D: {\n    get: function () {\n      return this._mapMode2D;\n    }\n  },\n\n  /**\n   * Gets or sets the position of the Imagery splitter within the viewport.  Valid values are between 0.0 and 1.0.\n   * @memberof Scene.prototype\n   *\n   * @type {Number}\n   */\n  imagerySplitPosition: {\n    get: function () {\n      return this._frameState.imagerySplitPosition;\n    },\n    set: function (value) {\n      this._frameState.imagerySplitPosition = value;\n    }\n  },\n\n  /**\n   * The distance from the camera at which to disable the depth test of billboards, labels and points\n   * to, for example, prevent clipping against terrain. When set to zero, the depth test should always\n   * be applied. When less than zero, the depth test should never be applied. Setting the disableDepthTestDistance\n   * property of a billboard, label or point will override this value.\n   * @memberof Scene.prototype\n   * @type {Number}\n   * @default 0.0\n   */\n  minimumDisableDepthTestDistance: {\n    get: function () {\n      return this._minimumDisableDepthTestDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value) || value < 0.0) {\n        throw new DeveloperError(\"minimumDisableDepthTestDistance must be greater than or equal to 0.0.\");\n      } //>>includeEnd('debug');\n\n\n      this._minimumDisableDepthTestDistance = value;\n    }\n  },\n\n  /**\n   * Whether or not to use a logarithmic depth buffer. Enabling this option will allow for less frustums in the multi-frustum,\n   * increasing performance. This property relies on fragmentDepth being supported.\n   * @memberof Scene.prototype\n   * @type {Boolean}\n   */\n  logarithmicDepthBuffer: {\n    get: function () {\n      return this._logDepthBuffer;\n    },\n    set: function (value) {\n      value = this._context.fragmentDepth && value;\n\n      if (this._logDepthBuffer !== value) {\n        this._logDepthBuffer = value;\n        this._logDepthBufferDirty = true;\n        this._defaultView.updateFrustums = true;\n      }\n    }\n  },\n\n  /**\n   * The value used for gamma correction. This is only used when rendering with high dynamic range.\n   * @memberof Scene.prototype\n   * @type {Number}\n   * @default 2.2\n   */\n  gamma: {\n    get: function () {\n      return this._context.uniformState.gamma;\n    },\n    set: function (value) {\n      this._context.uniformState.gamma = value;\n    }\n  },\n\n  /**\n   * Whether or not to use high dynamic range rendering.\n   * @memberof Scene.prototype\n   * @type {Boolean}\n   * @default true\n   */\n  highDynamicRange: {\n    get: function () {\n      return this._hdr;\n    },\n    set: function (value) {\n      var context = this._context;\n      var hdr = value && context.depthTexture && (context.colorBufferFloat || context.colorBufferHalfFloat);\n      this._hdrDirty = hdr !== this._hdr;\n      this._hdr = hdr;\n    }\n  },\n\n  /**\n   * Whether or not high dynamic range rendering is supported.\n   * @memberof Scene.prototype\n   * @type {Boolean}\n   * @readonly\n   * @default true\n   */\n  highDynamicRangeSupported: {\n    get: function () {\n      var context = this._context;\n      return context.depthTexture && (context.colorBufferFloat || context.colorBufferHalfFloat);\n    }\n  },\n\n  /**\n   * Whether or not the camera is underneath the globe.\n   * @memberof Scene.prototype\n   * @type {Boolean}\n   * @readonly\n   * @default false\n   */\n  cameraUnderground: {\n    get: function () {\n      return this._cameraUnderground;\n    }\n  },\n\n  /**\n   * Ratio between a pixel and a density-independent pixel. Provides a standard unit of\n   * measure for real pixel measurements appropriate to a particular device.\n   *\n   * @memberof Scene.prototype\n   * @type {Number}\n   * @default 1.0\n   * @private\n   */\n  pixelRatio: {\n    get: function () {\n      return this._frameState.pixelRatio;\n    },\n    set: function (value) {\n      this._frameState.pixelRatio = value;\n    }\n  },\n\n  /**\n   * @private\n   */\n  opaqueFrustumNearOffset: {\n    get: function () {\n      return 0.9999;\n    }\n  }\n});\n/**\n * Determines if a compressed texture format is supported.\n * @param {String} format The texture format. May be the name of the format or the WebGL extension name, e.g. s3tc or WEBGL_compressed_texture_s3tc.\n * @return {boolean} Whether or not the format is supported.\n */\n\nScene.prototype.getCompressedTextureFormatSupported = function (format) {\n  var context = this.context;\n  return (format === \"WEBGL_compressed_texture_s3tc\" || format === \"s3tc\") && context.s3tc || (format === \"WEBGL_compressed_texture_pvrtc\" || format === \"pvrtc\") && context.pvrtc || (format === \"WEBGL_compressed_texture_etc1\" || format === \"etc1\") && context.etc1;\n};\n\nfunction updateDerivedCommands(scene, command, shadowsDirty) {\n  var frameState = scene._frameState;\n  var context = scene._context;\n  var oit = scene._view.oit;\n  var lightShadowMaps = frameState.shadowState.lightShadowMaps;\n  var lightShadowsEnabled = frameState.shadowState.lightShadowsEnabled;\n  var derivedCommands = command.derivedCommands;\n\n  if (defined(command.pickId)) {\n    derivedCommands.picking = DerivedCommand.createPickDerivedCommand(scene, command, context, derivedCommands.picking);\n  }\n\n  if (!command.pickOnly) {\n    derivedCommands.depth = DerivedCommand.createDepthOnlyDerivedCommand(scene, command, context, derivedCommands.depth);\n  }\n\n  derivedCommands.originalCommand = command;\n\n  if (scene._hdr) {\n    derivedCommands.hdr = DerivedCommand.createHdrCommand(command, context, derivedCommands.hdr);\n    command = derivedCommands.hdr.command;\n    derivedCommands = command.derivedCommands;\n  }\n\n  if (lightShadowsEnabled && command.receiveShadows) {\n    derivedCommands.shadows = ShadowMap.createReceiveDerivedCommand(lightShadowMaps, command, shadowsDirty, context, derivedCommands.shadows);\n  }\n\n  if (command.pass === Pass.TRANSLUCENT && defined(oit) && oit.isSupported()) {\n    if (lightShadowsEnabled && command.receiveShadows) {\n      derivedCommands.oit = defined(derivedCommands.oit) ? derivedCommands.oit : {};\n      derivedCommands.oit.shadows = oit.createDerivedCommands(derivedCommands.shadows.receiveCommand, context, derivedCommands.oit.shadows);\n    } else {\n      derivedCommands.oit = oit.createDerivedCommands(command, context, derivedCommands.oit);\n    }\n  }\n}\n/**\n * @private\n */\n\n\nScene.prototype.updateDerivedCommands = function (command) {\n  if (!defined(command.derivedCommands)) {\n    // Is not a DrawCommand\n    return;\n  }\n\n  var frameState = this._frameState;\n  var context = this._context; // Update derived commands when any shadow maps become dirty\n\n  var shadowsDirty = false;\n  var lastDirtyTime = frameState.shadowState.lastDirtyTime;\n\n  if (command.lastDirtyTime !== lastDirtyTime) {\n    command.lastDirtyTime = lastDirtyTime;\n    command.dirty = true;\n    shadowsDirty = true;\n  }\n\n  var useLogDepth = frameState.useLogDepth;\n  var useHdr = this._hdr;\n  var derivedCommands = command.derivedCommands;\n  var hasLogDepthDerivedCommands = defined(derivedCommands.logDepth);\n  var hasHdrCommands = defined(derivedCommands.hdr);\n  var hasDerivedCommands = defined(derivedCommands.originalCommand);\n  var needsLogDepthDerivedCommands = useLogDepth && !hasLogDepthDerivedCommands;\n  var needsHdrCommands = useHdr && !hasHdrCommands;\n  var needsDerivedCommands = (!useLogDepth || !useHdr) && !hasDerivedCommands;\n  command.dirty = command.dirty || needsLogDepthDerivedCommands || needsHdrCommands || needsDerivedCommands;\n\n  if (command.dirty) {\n    command.dirty = false;\n    var shadowMaps = frameState.shadowState.shadowMaps;\n    var shadowsEnabled = frameState.shadowState.shadowsEnabled;\n\n    if (shadowsEnabled && command.castShadows) {\n      derivedCommands.shadows = ShadowMap.createCastDerivedCommand(shadowMaps, command, shadowsDirty, context, derivedCommands.shadows);\n    }\n\n    if (hasLogDepthDerivedCommands || needsLogDepthDerivedCommands) {\n      derivedCommands.logDepth = DerivedCommand.createLogDepthCommand(command, context, derivedCommands.logDepth);\n      updateDerivedCommands(this, derivedCommands.logDepth.command, shadowsDirty);\n    }\n\n    if (hasDerivedCommands || needsDerivedCommands) {\n      updateDerivedCommands(this, command, shadowsDirty);\n    }\n  }\n};\n\nvar renderTilesetPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.RENDER\n});\nvar preloadTilesetPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.PRELOAD\n});\nvar preloadFlightTilesetPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.PRELOAD_FLIGHT\n});\nvar requestRenderModeDeferCheckPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.REQUEST_RENDER_MODE_DEFER_CHECK\n});\nvar scratchOccluderBoundingSphere = new BoundingSphere();\nvar scratchOccluder;\n\nfunction getOccluder(scene) {\n  // TODO: The occluder is the top-level globe. When we add\n  //       support for multiple central bodies, this should be the closest one.\n  var globe = scene.globe;\n\n  if (scene._mode === SceneMode.SCENE3D && defined(globe) && globe.show && !scene._cameraUnderground) {\n    var ellipsoid = globe.ellipsoid;\n    var minimumTerrainHeight = scene.frameState.minimumTerrainHeight;\n    scratchOccluderBoundingSphere.radius = ellipsoid.minimumRadius + minimumTerrainHeight;\n    scratchOccluder = Occluder.fromBoundingSphere(scratchOccluderBoundingSphere, scene.camera.positionWC, scratchOccluder);\n    return scratchOccluder;\n  }\n\n  return undefined;\n}\n/**\n * @private\n */\n\n\nScene.prototype.clearPasses = function (passes) {\n  passes.render = false;\n  passes.pick = false;\n  passes.depth = false;\n  passes.postProcess = false;\n  passes.offscreen = false;\n};\n\nfunction updateFrameNumber(scene, frameNumber, time) {\n  var frameState = scene._frameState;\n  frameState.frameNumber = frameNumber;\n  frameState.time = JulianDate.clone(time, frameState.time);\n}\n/**\n * @private\n */\n\n\nScene.prototype.updateFrameState = function () {\n  var camera = this.camera;\n  var frameState = this._frameState;\n  frameState.commandList.length = 0;\n  frameState.shadowMaps.length = 0;\n  frameState.brdfLutGenerator = this._brdfLutGenerator;\n  frameState.environmentMap = this.skyBox && this.skyBox._cubeMap;\n  frameState.mode = this._mode;\n  frameState.morphTime = this.morphTime;\n  frameState.mapProjection = this.mapProjection;\n  frameState.camera = camera;\n  frameState.cullingVolume = camera.frustum.computeCullingVolume(camera.positionWC, camera.directionWC, camera.upWC);\n  frameState.occluder = getOccluder(this);\n  frameState.terrainExaggeration = this._terrainExaggeration;\n  frameState.minimumTerrainHeight = 0.0;\n  frameState.minimumDisableDepthTestDistance = this._minimumDisableDepthTestDistance;\n  frameState.invertClassification = this.invertClassification;\n  frameState.useLogDepth = this._logDepthBuffer && !(this.camera.frustum instanceof OrthographicFrustum || this.camera.frustum instanceof OrthographicOffCenterFrustum);\n  frameState.light = this.light;\n  frameState.cameraUnderground = this._cameraUnderground;\n\n  if (defined(this._specularEnvironmentMapAtlas) && this._specularEnvironmentMapAtlas.ready) {\n    frameState.specularEnvironmentMaps = this._specularEnvironmentMapAtlas.texture;\n    frameState.specularEnvironmentMapsMaximumLOD = this._specularEnvironmentMapAtlas.maximumMipmapLevel;\n  } else {\n    frameState.specularEnvironmentMaps = undefined;\n    frameState.specularEnvironmentMapsMaximumLOD = undefined;\n  }\n\n  frameState.sphericalHarmonicCoefficients = this.sphericalHarmonicCoefficients;\n  this._actualInvertClassificationColor = Color.clone(this.invertClassificationColor, this._actualInvertClassificationColor);\n\n  if (!InvertClassification.isTranslucencySupported(this._context)) {\n    this._actualInvertClassificationColor.alpha = 1.0;\n  }\n\n  frameState.invertClassificationColor = this._actualInvertClassificationColor;\n\n  if (defined(this.globe)) {\n    frameState.maximumScreenSpaceError = this.globe.maximumScreenSpaceError;\n  } else {\n    frameState.maximumScreenSpaceError = 2;\n  }\n\n  this.clearPasses(frameState.passes);\n  frameState.tilesetPassState = undefined;\n};\n/**\n * @private\n */\n\n\nScene.prototype.isVisible = function (command, cullingVolume, occluder) {\n  return defined(command) && (!defined(command.boundingVolume) || !command.cull || cullingVolume.computeVisibility(command.boundingVolume) !== Intersect.OUTSIDE && (!defined(occluder) || !command.occlude || !command.boundingVolume.isOccluded(occluder)));\n};\n\nfunction getAttributeLocations(shaderProgram) {\n  var attributeLocations = {};\n  var attributes = shaderProgram.vertexAttributes;\n\n  for (var a in attributes) {\n    if (attributes.hasOwnProperty(a)) {\n      attributeLocations[a] = attributes[a].index;\n    }\n  }\n\n  return attributeLocations;\n}\n\nfunction createDebugFragmentShaderProgram(command, scene, shaderProgram) {\n  var context = scene.context;\n  var sp = defaultValue(shaderProgram, command.shaderProgram);\n  var fs = sp.fragmentShaderSource.clone();\n  var targets = [];\n  fs.sources = fs.sources.map(function (source) {\n    source = ShaderSource.replaceMain(source, \"czm_Debug_main\");\n    var re = /gl_FragData\\[(\\d+)\\]/g;\n    var match;\n\n    while ((match = re.exec(source)) !== null) {\n      if (targets.indexOf(match[1]) === -1) {\n        targets.push(match[1]);\n      }\n    }\n\n    return source;\n  });\n  var length = targets.length;\n  var newMain = \"void main() \\n\" + \"{ \\n\" + \"    czm_Debug_main(); \\n\";\n  var i;\n\n  if (scene.debugShowCommands) {\n    if (!defined(command._debugColor)) {\n      command._debugColor = Color.fromRandom();\n    }\n\n    var c = command._debugColor;\n\n    if (length > 0) {\n      for (i = 0; i < length; ++i) {\n        newMain += \"    gl_FragData[\" + targets[i] + \"].rgb *= vec3(\" + c.red + \", \" + c.green + \", \" + c.blue + \"); \\n\";\n      }\n    } else {\n      newMain += \"    \" + \"gl_FragColor\" + \".rgb *= vec3(\" + c.red + \", \" + c.green + \", \" + c.blue + \"); \\n\";\n    }\n  }\n\n  if (scene.debugShowFrustums) {\n    // Support up to three frustums.  If a command overlaps all\n    // three, it's code is not changed.\n    var r = command.debugOverlappingFrustums & 1 << 0 ? \"1.0\" : \"0.0\";\n    var g = command.debugOverlappingFrustums & 1 << 1 ? \"1.0\" : \"0.0\";\n    var b = command.debugOverlappingFrustums & 1 << 2 ? \"1.0\" : \"0.0\";\n\n    if (length > 0) {\n      for (i = 0; i < length; ++i) {\n        newMain += \"    gl_FragData[\" + targets[i] + \"].rgb *= vec3(\" + r + \", \" + g + \", \" + b + \"); \\n\";\n      }\n    } else {\n      newMain += \"    \" + \"gl_FragColor\" + \".rgb *= vec3(\" + r + \", \" + g + \", \" + b + \"); \\n\";\n    }\n  }\n\n  newMain += \"}\";\n  fs.sources.push(newMain);\n  var attributeLocations = getAttributeLocations(sp);\n  return ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: sp.vertexShaderSource,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations\n  });\n}\n\nfunction executeDebugCommand(command, scene, passState) {\n  var debugCommand = DrawCommand.shallowClone(command);\n  debugCommand.shaderProgram = createDebugFragmentShaderProgram(command, scene);\n  debugCommand.execute(scene.context, passState);\n  debugCommand.shaderProgram.destroy();\n}\n\nvar transformFrom2D = new Matrix4(0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0);\ntransformFrom2D = Matrix4.inverseTransformation(transformFrom2D, transformFrom2D);\n\nfunction debugShowBoundingVolume(command, scene, passState, debugFramebuffer) {\n  // Debug code to draw bounding volume for command.  Not optimized!\n  // Assumes bounding volume is a bounding sphere or box\n  var frameState = scene._frameState;\n  var context = frameState.context;\n  var boundingVolume = command.boundingVolume;\n\n  if (defined(scene._debugVolume)) {\n    scene._debugVolume.destroy();\n  }\n\n  var geometry;\n  var center = Cartesian3.clone(boundingVolume.center);\n\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    center = Matrix4.multiplyByPoint(transformFrom2D, center, center);\n    var projection = frameState.mapProjection;\n    var centerCartographic = projection.unproject(center);\n    center = projection.ellipsoid.cartographicToCartesian(centerCartographic);\n  }\n\n  if (defined(boundingVolume.radius)) {\n    var radius = boundingVolume.radius;\n    geometry = GeometryPipeline.toWireframe(EllipsoidGeometry.createGeometry(new EllipsoidGeometry({\n      radii: new Cartesian3(radius, radius, radius),\n      vertexFormat: PerInstanceColorAppearance.FLAT_VERTEX_FORMAT\n    })));\n    scene._debugVolume = new Primitive({\n      geometryInstances: new GeometryInstance({\n        geometry: geometry,\n        modelMatrix: Matrix4.fromTranslation(center),\n        attributes: {\n          color: new ColorGeometryInstanceAttribute(1.0, 0.0, 0.0, 1.0)\n        }\n      }),\n      appearance: new PerInstanceColorAppearance({\n        flat: true,\n        translucent: false\n      }),\n      asynchronous: false\n    });\n  } else {\n    var halfAxes = boundingVolume.halfAxes;\n    geometry = GeometryPipeline.toWireframe(BoxGeometry.createGeometry(BoxGeometry.fromDimensions({\n      dimensions: new Cartesian3(2.0, 2.0, 2.0),\n      vertexFormat: PerInstanceColorAppearance.FLAT_VERTEX_FORMAT\n    })));\n    scene._debugVolume = new Primitive({\n      geometryInstances: new GeometryInstance({\n        geometry: geometry,\n        modelMatrix: Matrix4.fromRotationTranslation(halfAxes, center, new Matrix4()),\n        attributes: {\n          color: new ColorGeometryInstanceAttribute(1.0, 0.0, 0.0, 1.0)\n        }\n      }),\n      appearance: new PerInstanceColorAppearance({\n        flat: true,\n        translucent: false\n      }),\n      asynchronous: false\n    });\n  }\n\n  var savedCommandList = frameState.commandList;\n  var commandList = frameState.commandList = [];\n\n  scene._debugVolume.update(frameState);\n\n  command = commandList[0];\n\n  if (frameState.useLogDepth) {\n    var logDepth = DerivedCommand.createLogDepthCommand(command, context);\n    command = logDepth.command;\n  }\n\n  var framebuffer;\n\n  if (defined(debugFramebuffer)) {\n    framebuffer = passState.framebuffer;\n    passState.framebuffer = debugFramebuffer;\n  }\n\n  command.execute(context, passState);\n\n  if (defined(framebuffer)) {\n    passState.framebuffer = framebuffer;\n  }\n\n  frameState.commandList = savedCommandList;\n}\n\nfunction executeCommand(command, scene, context, passState, debugFramebuffer) {\n  var frameState = scene._frameState;\n\n  if (defined(scene.debugCommandFilter) && !scene.debugCommandFilter(command)) {\n    return;\n  }\n\n  if (command instanceof ClearCommand) {\n    command.execute(context, passState);\n    return;\n  }\n\n  if (command.debugShowBoundingVolume && defined(command.boundingVolume)) {\n    debugShowBoundingVolume(command, scene, passState, debugFramebuffer);\n  }\n\n  if (frameState.useLogDepth && defined(command.derivedCommands.logDepth)) {\n    command = command.derivedCommands.logDepth.command;\n  }\n\n  var passes = frameState.passes;\n\n  if (!passes.pick && scene._hdr && defined(command.derivedCommands) && defined(command.derivedCommands.hdr)) {\n    command = command.derivedCommands.hdr.command;\n  }\n\n  if (passes.pick || passes.depth) {\n    if (passes.pick && !passes.depth && defined(command.derivedCommands.picking)) {\n      command = command.derivedCommands.picking.pickCommand;\n      command.execute(context, passState);\n      return;\n    } else if (defined(command.derivedCommands.depth)) {\n      command = command.derivedCommands.depth.depthOnlyCommand;\n      command.execute(context, passState);\n      return;\n    }\n  }\n\n  if (scene.debugShowCommands || scene.debugShowFrustums) {\n    executeDebugCommand(command, scene, passState);\n    return;\n  }\n\n  if (frameState.shadowState.lightShadowsEnabled && command.receiveShadows && defined(command.derivedCommands.shadows)) {\n    // If the command receives shadows, execute the derived shadows command.\n    // Some commands, such as OIT derived commands, do not have derived shadow commands themselves\n    // and instead shadowing is built-in. In this case execute the command regularly below.\n    command.derivedCommands.shadows.receiveCommand.execute(context, passState);\n  } else {\n    command.execute(context, passState);\n  }\n}\n\nfunction executeIdCommand(command, scene, context, passState) {\n  var frameState = scene._frameState;\n  var derivedCommands = command.derivedCommands;\n\n  if (!defined(derivedCommands)) {\n    return;\n  }\n\n  if (frameState.useLogDepth && defined(derivedCommands.logDepth)) {\n    command = derivedCommands.logDepth.command;\n  }\n\n  derivedCommands = command.derivedCommands;\n\n  if (defined(derivedCommands.picking)) {\n    command = derivedCommands.picking.pickCommand;\n    command.execute(context, passState);\n  } else if (defined(derivedCommands.depth)) {\n    command = derivedCommands.depth.depthOnlyCommand;\n    command.execute(context, passState);\n  }\n}\n\nfunction backToFront(a, b, position) {\n  return b.boundingVolume.distanceSquaredTo(position) - a.boundingVolume.distanceSquaredTo(position);\n}\n\nfunction frontToBack(a, b, position) {\n  // When distances are equal equal favor sorting b before a. This gives render priority to commands later in the list.\n  return a.boundingVolume.distanceSquaredTo(position) - b.boundingVolume.distanceSquaredTo(position) + CesiumMath.EPSILON12;\n}\n\nfunction executeTranslucentCommandsBackToFront(scene, executeFunction, passState, commands, invertClassification) {\n  var context = scene.context;\n  mergeSort(commands, backToFront, scene.camera.positionWC);\n\n  if (defined(invertClassification)) {\n    executeFunction(invertClassification.unclassifiedCommand, scene, context, passState);\n  }\n\n  var length = commands.length;\n\n  for (var i = 0; i < length; ++i) {\n    executeFunction(commands[i], scene, context, passState);\n  }\n}\n\nfunction executeTranslucentCommandsFrontToBack(scene, executeFunction, passState, commands, invertClassification) {\n  var context = scene.context;\n  mergeSort(commands, frontToBack, scene.camera.positionWC);\n\n  if (defined(invertClassification)) {\n    executeFunction(invertClassification.unclassifiedCommand, scene, context, passState);\n  }\n\n  var length = commands.length;\n\n  for (var i = 0; i < length; ++i) {\n    executeFunction(commands[i], scene, context, passState);\n  }\n}\n\nfunction getDebugGlobeDepth(scene, index) {\n  var globeDepths = scene._view.debugGlobeDepths;\n  var globeDepth = globeDepths[index];\n\n  if (!defined(globeDepth) && scene.context.depthTexture) {\n    globeDepth = new GlobeDepth();\n    globeDepths[index] = globeDepth;\n  }\n\n  return globeDepth;\n}\n\nvar scratchPerspectiveFrustum = new PerspectiveFrustum();\nvar scratchPerspectiveOffCenterFrustum = new PerspectiveOffCenterFrustum();\nvar scratchOrthographicFrustum = new OrthographicFrustum();\nvar scratchOrthographicOffCenterFrustum = new OrthographicOffCenterFrustum();\n\nfunction executeCommands(scene, passState) {\n  var camera = scene.camera;\n  var context = scene.context;\n  var us = context.uniformState;\n  us.updateCamera(camera); // Create a working frustum from the original camera frustum.\n\n  var frustum;\n\n  if (defined(camera.frustum.fov)) {\n    frustum = camera.frustum.clone(scratchPerspectiveFrustum);\n  } else if (defined(camera.frustum.infiniteProjectionMatrix)) {\n    frustum = camera.frustum.clone(scratchPerspectiveOffCenterFrustum);\n  } else if (defined(camera.frustum.width)) {\n    frustum = camera.frustum.clone(scratchOrthographicFrustum);\n  } else {\n    frustum = camera.frustum.clone(scratchOrthographicOffCenterFrustum);\n  } // Ideally, we would render the sky box and atmosphere last for\n  // early-z, but we would have to draw it in each frustum\n\n\n  frustum.near = camera.frustum.near;\n  frustum.far = camera.frustum.far;\n  us.updateFrustum(frustum);\n  us.updatePass(Pass.ENVIRONMENT);\n  var passes = scene._frameState.passes;\n  var picking = passes.pick;\n  var environmentState = scene._environmentState;\n  var view = scene._view;\n  var renderTranslucentDepthForPick = environmentState.renderTranslucentDepthForPick;\n  var useWebVR = environmentState.useWebVR; // Do not render environment primitives during a pick pass since they do not generate picking commands.\n\n  if (!picking) {\n    var skyBoxCommand = environmentState.skyBoxCommand;\n\n    if (defined(skyBoxCommand)) {\n      executeCommand(skyBoxCommand, scene, context, passState);\n    }\n\n    if (environmentState.isSkyAtmosphereVisible) {\n      executeCommand(environmentState.skyAtmosphereCommand, scene, context, passState);\n    }\n\n    if (environmentState.isSunVisible) {\n      environmentState.sunDrawCommand.execute(context, passState);\n\n      if (scene.sunBloom && !useWebVR) {\n        var framebuffer;\n\n        if (environmentState.useGlobeDepthFramebuffer) {\n          framebuffer = view.globeDepth.framebuffer;\n        } else if (environmentState.usePostProcess) {\n          framebuffer = view.sceneFramebuffer.getFramebuffer();\n        } else {\n          framebuffer = environmentState.originalFramebuffer;\n        }\n\n        scene._sunPostProcess.execute(context);\n\n        scene._sunPostProcess.copy(context, framebuffer);\n\n        passState.framebuffer = framebuffer;\n      }\n    } // Moon can be seen through the atmosphere, since the sun is rendered after the atmosphere.\n\n\n    if (environmentState.isMoonVisible) {\n      environmentState.moonCommand.execute(context, passState);\n    }\n  } // Determine how translucent surfaces will be handled.\n\n\n  var executeTranslucentCommands;\n\n  if (environmentState.useOIT) {\n    if (!defined(scene._executeOITFunction)) {\n      scene._executeOITFunction = function (scene, executeFunction, passState, commands, invertClassification) {\n        view.oit.executeCommands(scene, executeFunction, passState, commands, invertClassification);\n      };\n    }\n\n    executeTranslucentCommands = scene._executeOITFunction;\n  } else if (passes.render) {\n    executeTranslucentCommands = executeTranslucentCommandsBackToFront;\n  } else {\n    executeTranslucentCommands = executeTranslucentCommandsFrontToBack;\n  }\n\n  var frustumCommandsList = view.frustumCommandsList;\n  var numFrustums = frustumCommandsList.length;\n  var clearGlobeDepth = environmentState.clearGlobeDepth;\n  var useDepthPlane = environmentState.useDepthPlane;\n  var separatePrimitiveFramebuffer = environmentState.separatePrimitiveFramebuffer = false;\n  var clearDepth = scene._depthClearCommand;\n  var clearStencil = scene._stencilClearCommand;\n  var clearClassificationStencil = scene._classificationStencilClearCommand;\n  var depthPlane = scene._depthPlane;\n  var usePostProcessSelected = environmentState.usePostProcessSelected;\n  var height2D = camera.position.z; // Execute commands in each frustum in back to front order\n\n  var j;\n\n  for (var i = 0; i < numFrustums; ++i) {\n    var index = numFrustums - i - 1;\n    var frustumCommands = frustumCommandsList[index];\n\n    if (scene.mode === SceneMode.SCENE2D) {\n      // To avoid z-fighting in 2D, move the camera to just before the frustum\n      // and scale the frustum depth to be in [1.0, nearToFarDistance2D].\n      camera.position.z = height2D - frustumCommands.near + 1.0;\n      frustum.far = Math.max(1.0, frustumCommands.far - frustumCommands.near);\n      frustum.near = 1.0;\n      us.update(scene.frameState);\n      us.updateFrustum(frustum);\n    } else {\n      // Avoid tearing artifacts between adjacent frustums in the opaque passes\n      frustum.near = index !== 0 ? frustumCommands.near * scene.opaqueFrustumNearOffset : frustumCommands.near;\n      frustum.far = frustumCommands.far;\n      us.updateFrustum(frustum);\n    }\n\n    var globeDepth = scene.debugShowGlobeDepth ? getDebugGlobeDepth(scene, index) : view.globeDepth;\n\n    if (separatePrimitiveFramebuffer) {\n      // Render to globe framebuffer in GLOBE pass\n      passState.framebuffer = globeDepth.framebuffer;\n    }\n\n    var fb;\n\n    if (scene.debugShowGlobeDepth && defined(globeDepth) && environmentState.useGlobeDepthFramebuffer) {\n      globeDepth.update(context, passState, view.viewport, scene._hdr, clearGlobeDepth);\n      globeDepth.clear(context, passState, scene._clearColorCommand.color);\n      fb = passState.framebuffer;\n      passState.framebuffer = globeDepth.framebuffer;\n    }\n\n    clearDepth.execute(context, passState);\n\n    if (context.stencilBuffer) {\n      clearStencil.execute(context, passState);\n    }\n\n    us.updatePass(Pass.GLOBE);\n    var commands = frustumCommands.commands[Pass.GLOBE];\n    var length = frustumCommands.indices[Pass.GLOBE];\n\n    for (j = 0; j < length; ++j) {\n      executeCommand(commands[j], scene, context, passState);\n    }\n\n    if (defined(globeDepth) && environmentState.useGlobeDepthFramebuffer) {\n      globeDepth.executeCopyDepth(context, passState);\n    }\n\n    if (scene.debugShowGlobeDepth && defined(globeDepth) && environmentState.useGlobeDepthFramebuffer) {\n      passState.framebuffer = fb;\n    } // Draw terrain classification\n\n\n    us.updatePass(Pass.TERRAIN_CLASSIFICATION);\n    commands = frustumCommands.commands[Pass.TERRAIN_CLASSIFICATION];\n    length = frustumCommands.indices[Pass.TERRAIN_CLASSIFICATION];\n\n    for (j = 0; j < length; ++j) {\n      executeCommand(commands[j], scene, context, passState);\n    }\n\n    if (clearGlobeDepth) {\n      clearDepth.execute(context, passState);\n\n      if (useDepthPlane) {\n        depthPlane.execute(context, passState);\n      }\n    }\n\n    if (separatePrimitiveFramebuffer) {\n      // Render to primitive framebuffer in all other passes\n      passState.framebuffer = globeDepth.primitiveFramebuffer;\n    }\n\n    if (!environmentState.useInvertClassification || picking) {\n      // Common/fastest path. Draw 3D Tiles and classification normally.\n      // Draw 3D Tiles\n      us.updatePass(Pass.CESIUM_3D_TILE);\n      commands = frustumCommands.commands[Pass.CESIUM_3D_TILE];\n      length = frustumCommands.indices[Pass.CESIUM_3D_TILE];\n\n      for (j = 0; j < length; ++j) {\n        executeCommand(commands[j], scene, context, passState);\n      }\n\n      if (length > 0) {\n        if (defined(globeDepth) && environmentState.useGlobeDepthFramebuffer) {\n          globeDepth.executeUpdateDepth(context, passState, clearGlobeDepth);\n        } // Draw classifications. Modifies 3D Tiles color.\n\n\n        us.updatePass(Pass.CESIUM_3D_TILE_CLASSIFICATION);\n        commands = frustumCommands.commands[Pass.CESIUM_3D_TILE_CLASSIFICATION];\n        length = frustumCommands.indices[Pass.CESIUM_3D_TILE_CLASSIFICATION];\n\n        for (j = 0; j < length; ++j) {\n          executeCommand(commands[j], scene, context, passState);\n        }\n      }\n    } else {\n      // When the invert classification color is opaque:\n      //    Main FBO (FBO1):                   Main_Color   + Main_DepthStencil\n      //    Invert classification FBO (FBO2) : Invert_Color + Main_DepthStencil\n      //\n      //    1. Clear FBO2 color to vec4(0.0) for each frustum\n      //    2. Draw 3D Tiles to FBO2\n      //    3. Draw classification to FBO2\n      //    4. Fullscreen pass to FBO1, draw Invert_Color when:\n      //           * Main_DepthStencil has the stencil bit set > 0 (classified)\n      //    5. Fullscreen pass to FBO1, draw Invert_Color * czm_invertClassificationColor when:\n      //           * Main_DepthStencil has stencil bit set to 0 (unclassified) and\n      //           * Invert_Color !== vec4(0.0)\n      //\n      // When the invert classification color is translucent:\n      //    Main FBO (FBO1):                  Main_Color         + Main_DepthStencil\n      //    Invert classification FBO (FBO2): Invert_Color       + Invert_DepthStencil\n      //    IsClassified FBO (FBO3):          IsClassified_Color + Invert_DepthStencil\n      //\n      //    1. Clear FBO2 and FBO3 color to vec4(0.0), stencil to 0, and depth to 1.0\n      //    2. Draw 3D Tiles to FBO2\n      //    3. Draw classification to FBO2\n      //    4. Fullscreen pass to FBO3, draw any color when\n      //           * Invert_DepthStencil has the stencil bit set > 0 (classified)\n      //    5. Fullscreen pass to FBO1, draw Invert_Color when:\n      //           * Invert_Color !== vec4(0.0) and\n      //           * IsClassified_Color !== vec4(0.0)\n      //    6. Fullscreen pass to FBO1, draw Invert_Color * czm_invertClassificationColor when:\n      //           * Invert_Color !== vec4(0.0) and\n      //           * IsClassified_Color === vec4(0.0)\n      //\n      // NOTE: Step six when translucent invert color occurs after the TRANSLUCENT pass\n      //\n      scene._invertClassification.clear(context, passState);\n\n      var opaqueClassificationFramebuffer = passState.framebuffer;\n      passState.framebuffer = scene._invertClassification._fbo; // Draw normally\n\n      us.updatePass(Pass.CESIUM_3D_TILE);\n      commands = frustumCommands.commands[Pass.CESIUM_3D_TILE];\n      length = frustumCommands.indices[Pass.CESIUM_3D_TILE];\n\n      for (j = 0; j < length; ++j) {\n        executeCommand(commands[j], scene, context, passState);\n      }\n\n      if (defined(globeDepth) && environmentState.useGlobeDepthFramebuffer) {\n        globeDepth.executeUpdateDepth(context, passState, clearGlobeDepth);\n      } // Set stencil\n\n\n      us.updatePass(Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW);\n      commands = frustumCommands.commands[Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW];\n      length = frustumCommands.indices[Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW];\n\n      for (j = 0; j < length; ++j) {\n        executeCommand(commands[j], scene, context, passState);\n      }\n\n      passState.framebuffer = opaqueClassificationFramebuffer; // Fullscreen pass to copy classified fragments\n\n      scene._invertClassification.executeClassified(context, passState);\n\n      if (scene.frameState.invertClassificationColor.alpha === 1.0) {\n        // Fullscreen pass to copy unclassified fragments when alpha == 1.0\n        scene._invertClassification.executeUnclassified(context, passState);\n      } // Clear stencil set by the classification for the next classification pass\n\n\n      if (length > 0 && context.stencilBuffer) {\n        clearClassificationStencil.execute(context, passState);\n      } // Draw style over classification.\n\n\n      us.updatePass(Pass.CESIUM_3D_TILE_CLASSIFICATION);\n      commands = frustumCommands.commands[Pass.CESIUM_3D_TILE_CLASSIFICATION];\n      length = frustumCommands.indices[Pass.CESIUM_3D_TILE_CLASSIFICATION];\n\n      for (j = 0; j < length; ++j) {\n        executeCommand(commands[j], scene, context, passState);\n      }\n    }\n\n    if (length > 0 && context.stencilBuffer) {\n      clearStencil.execute(context, passState);\n    }\n\n    us.updatePass(Pass.OPAQUE);\n    commands = frustumCommands.commands[Pass.OPAQUE];\n    length = frustumCommands.indices[Pass.OPAQUE];\n\n    for (j = 0; j < length; ++j) {\n      executeCommand(commands[j], scene, context, passState);\n    }\n\n    if (index !== 0 && scene.mode !== SceneMode.SCENE2D) {\n      // Do not overlap frustums in the translucent pass to avoid blending artifacts\n      frustum.near = frustumCommands.near;\n      us.updateFrustum(frustum);\n    }\n\n    var invertClassification;\n\n    if (!picking && environmentState.useInvertClassification && scene.frameState.invertClassificationColor.alpha < 1.0) {\n      // Fullscreen pass to copy unclassified fragments when alpha < 1.0.\n      // Not executed when undefined.\n      invertClassification = scene._invertClassification;\n    }\n\n    us.updatePass(Pass.TRANSLUCENT);\n    commands = frustumCommands.commands[Pass.TRANSLUCENT];\n    commands.length = frustumCommands.indices[Pass.TRANSLUCENT];\n    executeTranslucentCommands(scene, executeCommand, passState, commands, invertClassification);\n\n    if (context.depthTexture && scene.useDepthPicking && (environmentState.useGlobeDepthFramebuffer || renderTranslucentDepthForPick)) {\n      // PERFORMANCE_IDEA: Use MRT to avoid the extra copy.\n      var depthStencilTexture = renderTranslucentDepthForPick ? passState.framebuffer.depthStencilTexture : globeDepth.framebuffer.depthStencilTexture;\n\n      var pickDepth = scene._picking.getPickDepth(scene, index);\n\n      pickDepth.update(context, depthStencilTexture);\n      pickDepth.executeCopyDepth(context, passState);\n    }\n\n    if (separatePrimitiveFramebuffer) {\n      // Reset framebuffer\n      passState.framebuffer = globeDepth.framebuffer;\n    }\n\n    if (picking || !usePostProcessSelected) {\n      continue;\n    }\n\n    var originalFramebuffer = passState.framebuffer;\n    passState.framebuffer = view.sceneFramebuffer.getIdFramebuffer(); // reset frustum\n\n    frustum.near = index !== 0 ? frustumCommands.near * scene.opaqueFrustumNearOffset : frustumCommands.near;\n    frustum.far = frustumCommands.far;\n    us.updateFrustum(frustum);\n    us.updatePass(Pass.GLOBE);\n    commands = frustumCommands.commands[Pass.GLOBE];\n    length = frustumCommands.indices[Pass.GLOBE];\n\n    for (j = 0; j < length; ++j) {\n      executeIdCommand(commands[j], scene, context, passState);\n    }\n\n    if (clearGlobeDepth) {\n      clearDepth.framebuffer = passState.framebuffer;\n      clearDepth.execute(context, passState);\n      clearDepth.framebuffer = undefined;\n    }\n\n    if (clearGlobeDepth && useDepthPlane) {\n      depthPlane.execute(context, passState);\n    }\n\n    us.updatePass(Pass.CESIUM_3D_TILE);\n    commands = frustumCommands.commands[Pass.CESIUM_3D_TILE];\n    length = frustumCommands.indices[Pass.CESIUM_3D_TILE];\n\n    for (j = 0; j < length; ++j) {\n      executeIdCommand(commands[j], scene, context, passState);\n    }\n\n    us.updatePass(Pass.OPAQUE);\n    commands = frustumCommands.commands[Pass.OPAQUE];\n    length = frustumCommands.indices[Pass.OPAQUE];\n\n    for (j = 0; j < length; ++j) {\n      executeIdCommand(commands[j], scene, context, passState);\n    }\n\n    us.updatePass(Pass.TRANSLUCENT);\n    commands = frustumCommands.commands[Pass.TRANSLUCENT];\n    length = frustumCommands.indices[Pass.TRANSLUCENT];\n\n    for (j = 0; j < length; ++j) {\n      executeIdCommand(commands[j], scene, context, passState);\n    }\n\n    passState.framebuffer = originalFramebuffer;\n  }\n}\n\nfunction executeComputeCommands(scene) {\n  var us = scene.context.uniformState;\n  us.updatePass(Pass.COMPUTE);\n  var sunComputeCommand = scene._environmentState.sunComputeCommand;\n\n  if (defined(sunComputeCommand)) {\n    sunComputeCommand.execute(scene._computeEngine);\n  }\n\n  var commandList = scene._computeCommandList;\n  var length = commandList.length;\n\n  for (var i = 0; i < length; ++i) {\n    commandList[i].execute(scene._computeEngine);\n  }\n}\n\nfunction executeOverlayCommands(scene, passState) {\n  var us = scene.context.uniformState;\n  us.updatePass(Pass.OVERLAY);\n  var context = scene.context;\n  var commandList = scene._overlayCommandList;\n  var length = commandList.length;\n\n  for (var i = 0; i < length; ++i) {\n    commandList[i].execute(context, passState);\n  }\n}\n\nfunction insertShadowCastCommands(scene, commandList, shadowMap) {\n  var shadowVolume = shadowMap.shadowMapCullingVolume;\n  var isPointLight = shadowMap.isPointLight;\n  var passes = shadowMap.passes;\n  var numberOfPasses = passes.length;\n  var length = commandList.length;\n\n  for (var i = 0; i < length; ++i) {\n    var command = commandList[i];\n    scene.updateDerivedCommands(command);\n\n    if (command.castShadows && (command.pass === Pass.GLOBE || command.pass === Pass.CESIUM_3D_TILE || command.pass === Pass.OPAQUE || command.pass === Pass.TRANSLUCENT)) {\n      if (scene.isVisible(command, shadowVolume)) {\n        if (isPointLight) {\n          for (var k = 0; k < numberOfPasses; ++k) {\n            passes[k].commandList.push(command);\n          }\n        } else if (numberOfPasses === 1) {\n          passes[0].commandList.push(command);\n        } else {\n          var wasVisible = false; // Loop over cascades from largest to smallest\n\n          for (var j = numberOfPasses - 1; j >= 0; --j) {\n            var cascadeVolume = passes[j].cullingVolume;\n\n            if (scene.isVisible(command, cascadeVolume)) {\n              passes[j].commandList.push(command);\n              wasVisible = true;\n            } else if (wasVisible) {\n              // If it was visible in the previous cascade but now isn't\n              // then there is no need to check any more cascades\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction executeShadowMapCastCommands(scene) {\n  var frameState = scene.frameState;\n  var shadowMaps = frameState.shadowState.shadowMaps;\n  var shadowMapLength = shadowMaps.length;\n\n  if (!frameState.shadowState.shadowsEnabled) {\n    return;\n  }\n\n  var context = scene.context;\n  var uniformState = context.uniformState;\n\n  for (var i = 0; i < shadowMapLength; ++i) {\n    var shadowMap = shadowMaps[i];\n\n    if (shadowMap.outOfView) {\n      continue;\n    } // Reset the command lists\n\n\n    var j;\n    var passes = shadowMap.passes;\n    var numberOfPasses = passes.length;\n\n    for (j = 0; j < numberOfPasses; ++j) {\n      passes[j].commandList.length = 0;\n    } // Insert the primitive/model commands into the command lists\n\n\n    var sceneCommands = scene.frameState.commandList;\n    insertShadowCastCommands(scene, sceneCommands, shadowMap);\n\n    for (j = 0; j < numberOfPasses; ++j) {\n      var pass = shadowMap.passes[j];\n      uniformState.updateCamera(pass.camera);\n      shadowMap.updatePass(context, j);\n      var numberOfCommands = pass.commandList.length;\n\n      for (var k = 0; k < numberOfCommands; ++k) {\n        var command = pass.commandList[k]; // Set the correct pass before rendering into the shadow map because some shaders\n        // conditionally render based on whether the pass is translucent or opaque.\n\n        uniformState.updatePass(command.pass);\n        executeCommand(command.derivedCommands.shadows.castCommands[i], scene, context, pass.passState);\n      }\n    }\n  }\n}\n\nvar scratchEyeTranslation = new Cartesian3();\n/**\n * @private\n */\n\nScene.prototype.updateAndExecuteCommands = function (passState, backgroundColor) {\n  var frameState = this._frameState;\n  var mode = frameState.mode;\n  var useWebVR = this._environmentState.useWebVR;\n\n  if (useWebVR) {\n    executeWebVRCommands(this, passState, backgroundColor);\n  } else if (mode !== SceneMode.SCENE2D || this._mapMode2D === MapMode2D.ROTATE) {\n    executeCommandsInViewport(true, this, passState, backgroundColor);\n  } else {\n    updateAndClearFramebuffers(this, passState, backgroundColor);\n    execute2DViewportCommands(this, passState);\n  }\n};\n\nfunction executeWebVRCommands(scene, passState, backgroundColor) {\n  var view = scene._view;\n  var camera = view.camera;\n  var environmentState = scene._environmentState;\n  var renderTranslucentDepthForPick = environmentState.renderTranslucentDepthForPick;\n  updateAndClearFramebuffers(scene, passState, backgroundColor);\n\n  if (!renderTranslucentDepthForPick) {\n    updateAndRenderPrimitives(scene);\n  }\n\n  view.createPotentiallyVisibleSet(scene);\n\n  if (!renderTranslucentDepthForPick) {\n    executeComputeCommands(scene);\n    executeShadowMapCastCommands(scene);\n  } // Based on Calculating Stereo pairs by Paul Bourke\n  // http://paulbourke.net/stereographics/stereorender/\n\n\n  var viewport = passState.viewport;\n  viewport.x = 0;\n  viewport.y = 0;\n  viewport.width = viewport.width * 0.5;\n  var savedCamera = Camera.clone(camera, scene._cameraVR);\n  savedCamera.frustum = camera.frustum;\n  var near = camera.frustum.near;\n  var fo = near * defaultValue(scene.focalLength, 5.0);\n  var eyeSeparation = defaultValue(scene.eyeSeparation, fo / 30.0);\n  var eyeTranslation = Cartesian3.multiplyByScalar(savedCamera.right, eyeSeparation * 0.5, scratchEyeTranslation);\n  camera.frustum.aspectRatio = viewport.width / viewport.height;\n  var offset = 0.5 * eyeSeparation * near / fo;\n  Cartesian3.add(savedCamera.position, eyeTranslation, camera.position);\n  camera.frustum.xOffset = offset;\n  executeCommands(scene, passState);\n  viewport.x = viewport.width;\n  Cartesian3.subtract(savedCamera.position, eyeTranslation, camera.position);\n  camera.frustum.xOffset = -offset;\n  executeCommands(scene, passState);\n  Camera.clone(savedCamera, camera);\n}\n\nvar scratch2DViewportCartographic = new Cartographic(Math.PI, CesiumMath.PI_OVER_TWO);\nvar scratch2DViewportMaxCoord = new Cartesian3();\nvar scratch2DViewportSavedPosition = new Cartesian3();\nvar scratch2DViewportTransform = new Matrix4();\nvar scratch2DViewportCameraTransform = new Matrix4();\nvar scratch2DViewportEyePoint = new Cartesian3();\nvar scratch2DViewportWindowCoords = new Cartesian3();\nvar scratch2DViewport = new BoundingRectangle();\n\nfunction execute2DViewportCommands(scene, passState) {\n  var context = scene.context;\n  var frameState = scene.frameState;\n  var camera = scene.camera;\n  var originalViewport = passState.viewport;\n  var viewport = BoundingRectangle.clone(originalViewport, scratch2DViewport);\n  passState.viewport = viewport;\n  var maxCartographic = scratch2DViewportCartographic;\n  var maxCoord = scratch2DViewportMaxCoord;\n  var projection = scene.mapProjection;\n  projection.project(maxCartographic, maxCoord);\n  var position = Cartesian3.clone(camera.position, scratch2DViewportSavedPosition);\n  var transform = Matrix4.clone(camera.transform, scratch2DViewportCameraTransform);\n  var frustum = camera.frustum.clone();\n\n  camera._setTransform(Matrix4.IDENTITY);\n\n  var viewportTransformation = Matrix4.computeViewportTransformation(viewport, 0.0, 1.0, scratch2DViewportTransform);\n  var projectionMatrix = camera.frustum.projectionMatrix;\n  var x = camera.positionWC.y;\n  var eyePoint = Cartesian3.fromElements(CesiumMath.sign(x) * maxCoord.x - x, 0.0, -camera.positionWC.x, scratch2DViewportEyePoint);\n  var windowCoordinates = Transforms.pointToGLWindowCoordinates(projectionMatrix, viewportTransformation, eyePoint, scratch2DViewportWindowCoords);\n  windowCoordinates.x = Math.floor(windowCoordinates.x);\n  var viewportX = viewport.x;\n  var viewportWidth = viewport.width;\n\n  if (x === 0.0 || windowCoordinates.x <= viewportX || windowCoordinates.x >= viewportX + viewportWidth) {\n    executeCommandsInViewport(true, scene, passState);\n  } else if (Math.abs(viewportX + viewportWidth * 0.5 - windowCoordinates.x) < 1.0) {\n    viewport.width = windowCoordinates.x - viewport.x;\n    camera.position.x *= CesiumMath.sign(camera.position.x);\n    camera.frustum.right = 0.0;\n    frameState.cullingVolume = camera.frustum.computeCullingVolume(camera.positionWC, camera.directionWC, camera.upWC);\n    context.uniformState.update(frameState);\n    executeCommandsInViewport(true, scene, passState);\n    viewport.x = windowCoordinates.x;\n    camera.position.x = -camera.position.x;\n    camera.frustum.right = -camera.frustum.left;\n    camera.frustum.left = 0.0;\n    frameState.cullingVolume = camera.frustum.computeCullingVolume(camera.positionWC, camera.directionWC, camera.upWC);\n    context.uniformState.update(frameState);\n    executeCommandsInViewport(false, scene, passState);\n  } else if (windowCoordinates.x > viewportX + viewportWidth * 0.5) {\n    viewport.width = windowCoordinates.x - viewportX;\n    var right = camera.frustum.right;\n    camera.frustum.right = maxCoord.x - x;\n    frameState.cullingVolume = camera.frustum.computeCullingVolume(camera.positionWC, camera.directionWC, camera.upWC);\n    context.uniformState.update(frameState);\n    executeCommandsInViewport(true, scene, passState);\n    viewport.x = windowCoordinates.x;\n    viewport.width = viewportX + viewportWidth - windowCoordinates.x;\n    camera.position.x = -camera.position.x;\n    camera.frustum.left = -camera.frustum.right;\n    camera.frustum.right = right - camera.frustum.right * 2.0;\n    frameState.cullingVolume = camera.frustum.computeCullingVolume(camera.positionWC, camera.directionWC, camera.upWC);\n    context.uniformState.update(frameState);\n    executeCommandsInViewport(false, scene, passState);\n  } else {\n    viewport.x = windowCoordinates.x;\n    viewport.width = viewportX + viewportWidth - windowCoordinates.x;\n    var left = camera.frustum.left;\n    camera.frustum.left = -maxCoord.x - x;\n    frameState.cullingVolume = camera.frustum.computeCullingVolume(camera.positionWC, camera.directionWC, camera.upWC);\n    context.uniformState.update(frameState);\n    executeCommandsInViewport(true, scene, passState);\n    viewport.x = viewportX;\n    viewport.width = windowCoordinates.x - viewportX;\n    camera.position.x = -camera.position.x;\n    camera.frustum.right = -camera.frustum.left;\n    camera.frustum.left = left - camera.frustum.left * 2.0;\n    frameState.cullingVolume = camera.frustum.computeCullingVolume(camera.positionWC, camera.directionWC, camera.upWC);\n    context.uniformState.update(frameState);\n    executeCommandsInViewport(false, scene, passState);\n  }\n\n  camera._setTransform(transform);\n\n  Cartesian3.clone(position, camera.position);\n  camera.frustum = frustum.clone();\n  passState.viewport = originalViewport;\n}\n\nfunction executeCommandsInViewport(firstViewport, scene, passState, backgroundColor) {\n  var environmentState = scene._environmentState;\n  var view = scene._view;\n  var renderTranslucentDepthForPick = environmentState.renderTranslucentDepthForPick;\n\n  if (!firstViewport && !renderTranslucentDepthForPick) {\n    scene.frameState.commandList.length = 0;\n  }\n\n  if (!renderTranslucentDepthForPick) {\n    updateAndRenderPrimitives(scene);\n  }\n\n  view.createPotentiallyVisibleSet(scene);\n\n  if (firstViewport) {\n    if (defined(backgroundColor)) {\n      updateAndClearFramebuffers(scene, passState, backgroundColor);\n    }\n\n    if (!renderTranslucentDepthForPick) {\n      executeComputeCommands(scene);\n      executeShadowMapCastCommands(scene);\n    }\n  }\n\n  executeCommands(scene, passState);\n}\n\nvar scratchCullingVolume = new CullingVolume();\n/**\n * @private\n */\n\nScene.prototype.updateEnvironment = function () {\n  var frameState = this._frameState;\n  var view = this._view; // Update celestial and terrestrial environment effects.\n\n  var environmentState = this._environmentState;\n  var renderPass = frameState.passes.render;\n  var offscreenPass = frameState.passes.offscreen;\n  var skyAtmosphere = this.skyAtmosphere;\n  var globe = this.globe;\n\n  if (!renderPass || this._mode !== SceneMode.SCENE2D && view.camera.frustum instanceof OrthographicFrustum || this._cameraUnderground) {\n    environmentState.skyAtmosphereCommand = undefined;\n    environmentState.skyBoxCommand = undefined;\n    environmentState.sunDrawCommand = undefined;\n    environmentState.sunComputeCommand = undefined;\n    environmentState.moonCommand = undefined;\n  } else {\n    if (defined(skyAtmosphere)) {\n      if (defined(globe)) {\n        skyAtmosphere.setDynamicAtmosphereColor(globe.enableLighting && globe.dynamicAtmosphereLighting, globe.dynamicAtmosphereLightingFromSun);\n        environmentState.isReadyForAtmosphere = environmentState.isReadyForAtmosphere || globe._surface._tilesToRender.length > 0;\n      }\n\n      environmentState.skyAtmosphereCommand = skyAtmosphere.update(frameState);\n\n      if (defined(environmentState.skyAtmosphereCommand)) {\n        this.updateDerivedCommands(environmentState.skyAtmosphereCommand);\n      }\n    } else {\n      environmentState.skyAtmosphereCommand = undefined;\n    }\n\n    environmentState.skyBoxCommand = defined(this.skyBox) ? this.skyBox.update(frameState, this._hdr) : undefined;\n    var sunCommands = defined(this.sun) ? this.sun.update(frameState, view.passState, this._hdr) : undefined;\n    environmentState.sunDrawCommand = defined(sunCommands) ? sunCommands.drawCommand : undefined;\n    environmentState.sunComputeCommand = defined(sunCommands) ? sunCommands.computeCommand : undefined;\n    environmentState.moonCommand = defined(this.moon) ? this.moon.update(frameState) : undefined;\n  }\n\n  var clearGlobeDepth = environmentState.clearGlobeDepth = defined(globe) && (!globe.depthTestAgainstTerrain || this.mode === SceneMode.SCENE2D);\n  var useDepthPlane = environmentState.useDepthPlane = clearGlobeDepth && this.mode === SceneMode.SCENE3D && !this._cameraUnderground;\n\n  if (useDepthPlane) {\n    // Update the depth plane that is rendered in 3D when the primitives are\n    // not depth tested against terrain so primitives on the backface\n    // of the globe are not picked.\n    this._depthPlane.update(frameState);\n  }\n\n  environmentState.renderTranslucentDepthForPick = false;\n  environmentState.useWebVR = this._useWebVR && this.mode !== SceneMode.SCENE2D && !offscreenPass;\n  var occluder = frameState.mode === SceneMode.SCENE3D ? frameState.occluder : undefined;\n  var cullingVolume = frameState.cullingVolume; // get user culling volume minus the far plane.\n\n  var planes = scratchCullingVolume.planes;\n\n  for (var k = 0; k < 5; ++k) {\n    planes[k] = cullingVolume.planes[k];\n  }\n\n  cullingVolume = scratchCullingVolume; // Determine visibility of celestial and terrestrial environment effects.\n\n  environmentState.isSkyAtmosphereVisible = defined(environmentState.skyAtmosphereCommand) && environmentState.isReadyForAtmosphere;\n  environmentState.isSunVisible = this.isVisible(environmentState.sunDrawCommand, cullingVolume, occluder);\n  environmentState.isMoonVisible = this.isVisible(environmentState.moonCommand, cullingVolume, occluder);\n  var envMaps = this.specularEnvironmentMaps;\n  var envMapAtlas = this._specularEnvironmentMapAtlas;\n\n  if (defined(envMaps) && (!defined(envMapAtlas) || envMapAtlas.url !== envMaps)) {\n    envMapAtlas = envMapAtlas && envMapAtlas.destroy();\n    this._specularEnvironmentMapAtlas = new OctahedralProjectedCubeMap(envMaps);\n  } else if (!defined(envMaps) && defined(envMapAtlas)) {\n    envMapAtlas.destroy();\n    this._specularEnvironmentMapAtlas = undefined;\n  }\n\n  if (defined(this._specularEnvironmentMapAtlas)) {\n    this._specularEnvironmentMapAtlas.update(frameState);\n  }\n};\n\nfunction updateDebugFrustumPlanes(scene) {\n  var frameState = scene._frameState;\n\n  if (scene.debugShowFrustumPlanes !== scene._debugShowFrustumPlanes) {\n    if (scene.debugShowFrustumPlanes) {\n      scene._debugFrustumPlanes = new DebugCameraPrimitive({\n        camera: scene.camera,\n        updateOnChange: false\n      });\n    } else {\n      scene._debugFrustumPlanes = scene._debugFrustumPlanes && scene._debugFrustumPlanes.destroy();\n    }\n\n    scene._debugShowFrustumPlanes = scene.debugShowFrustumPlanes;\n  }\n\n  if (defined(scene._debugFrustumPlanes)) {\n    scene._debugFrustumPlanes.update(frameState);\n  }\n}\n\nfunction updateShadowMaps(scene) {\n  var frameState = scene._frameState;\n  var shadowMaps = frameState.shadowMaps;\n  var length = shadowMaps.length;\n  var shadowsEnabled = length > 0 && !frameState.passes.pick && scene.mode === SceneMode.SCENE3D;\n\n  if (shadowsEnabled !== frameState.shadowState.shadowsEnabled) {\n    // Update derived commands when shadowsEnabled changes\n    ++frameState.shadowState.lastDirtyTime;\n    frameState.shadowState.shadowsEnabled = shadowsEnabled;\n  }\n\n  frameState.shadowState.lightShadowsEnabled = false;\n\n  if (!shadowsEnabled) {\n    return;\n  } // Check if the shadow maps are different than the shadow maps last frame.\n  // If so, the derived commands need to be updated.\n\n\n  for (var j = 0; j < length; ++j) {\n    if (shadowMaps[j] !== frameState.shadowState.shadowMaps[j]) {\n      ++frameState.shadowState.lastDirtyTime;\n      break;\n    }\n  }\n\n  frameState.shadowState.shadowMaps.length = 0;\n  frameState.shadowState.lightShadowMaps.length = 0;\n\n  for (var i = 0; i < length; ++i) {\n    var shadowMap = shadowMaps[i];\n    shadowMap.update(frameState);\n    frameState.shadowState.shadowMaps.push(shadowMap);\n\n    if (shadowMap.fromLightSource) {\n      frameState.shadowState.lightShadowMaps.push(shadowMap);\n      frameState.shadowState.lightShadowsEnabled = true;\n    }\n\n    if (shadowMap.dirty) {\n      ++frameState.shadowState.lastDirtyTime;\n      shadowMap.dirty = false;\n    }\n  }\n}\n\nfunction updateAndRenderPrimitives(scene) {\n  var frameState = scene._frameState;\n\n  scene._groundPrimitives.update(frameState);\n\n  scene._primitives.update(frameState);\n\n  updateDebugFrustumPlanes(scene);\n  updateShadowMaps(scene);\n\n  if (scene._globe) {\n    scene._globe.render(frameState);\n  }\n}\n\nfunction updateAndClearFramebuffers(scene, passState, clearColor) {\n  var context = scene._context;\n  var frameState = scene._frameState;\n  var environmentState = scene._environmentState;\n  var view = scene._view;\n  var passes = scene._frameState.passes;\n  var picking = passes.pick;\n  var useWebVR = environmentState.useWebVR; // Preserve the reference to the original framebuffer.\n\n  environmentState.originalFramebuffer = passState.framebuffer; // Manage sun bloom post-processing effect.\n\n  if (defined(scene.sun) && scene.sunBloom !== scene._sunBloom) {\n    if (scene.sunBloom && !useWebVR) {\n      scene._sunPostProcess = new SunPostProcess();\n    } else if (defined(scene._sunPostProcess)) {\n      scene._sunPostProcess = scene._sunPostProcess.destroy();\n    }\n\n    scene._sunBloom = scene.sunBloom;\n  } else if (!defined(scene.sun) && defined(scene._sunPostProcess)) {\n    scene._sunPostProcess = scene._sunPostProcess.destroy();\n    scene._sunBloom = false;\n  } // Clear the pass state framebuffer.\n\n\n  var clear = scene._clearColorCommand;\n  Color.clone(clearColor, clear.color);\n  clear.execute(context, passState); // Update globe depth rendering based on the current context and clear the globe depth framebuffer.\n  // Globe depth is copied for the pick pass to support picking batched geometries in GroundPrimitives.\n\n  var useGlobeDepthFramebuffer = environmentState.useGlobeDepthFramebuffer = defined(view.globeDepth);\n\n  if (useGlobeDepthFramebuffer) {\n    view.globeDepth.update(context, passState, view.viewport, scene._hdr, environmentState.clearGlobeDepth);\n    view.globeDepth.clear(context, passState, clearColor);\n  } // If supported, configure OIT to use the globe depth framebuffer and clear the OIT framebuffer.\n\n\n  var oit = view.oit;\n  var useOIT = environmentState.useOIT = !picking && defined(oit) && oit.isSupported();\n\n  if (useOIT) {\n    oit.update(context, passState, view.globeDepth.framebuffer, scene._hdr);\n    oit.clear(context, passState, clearColor);\n    environmentState.useOIT = oit.isSupported();\n  }\n\n  var postProcess = scene.postProcessStages;\n  var usePostProcess = environmentState.usePostProcess = !picking && (scene._hdr || postProcess.length > 0 || postProcess.ambientOcclusion.enabled || postProcess.fxaa.enabled || postProcess.bloom.enabled);\n  environmentState.usePostProcessSelected = false;\n\n  if (usePostProcess) {\n    view.sceneFramebuffer.update(context, view.viewport, scene._hdr);\n    view.sceneFramebuffer.clear(context, passState, clearColor);\n    postProcess.update(context, frameState.useLogDepth, scene._hdr);\n    postProcess.clear(context);\n    usePostProcess = environmentState.usePostProcess = postProcess.ready;\n    environmentState.usePostProcessSelected = usePostProcess && postProcess.hasSelected;\n  }\n\n  if (environmentState.isSunVisible && scene.sunBloom && !useWebVR) {\n    passState.framebuffer = scene._sunPostProcess.update(passState);\n\n    scene._sunPostProcess.clear(context, passState, clearColor);\n  } else if (useGlobeDepthFramebuffer) {\n    passState.framebuffer = view.globeDepth.framebuffer;\n  } else if (usePostProcess) {\n    passState.framebuffer = view.sceneFramebuffer.getFramebuffer();\n  }\n\n  if (defined(passState.framebuffer)) {\n    clear.execute(context, passState);\n  }\n\n  var useInvertClassification = environmentState.useInvertClassification = !picking && defined(passState.framebuffer) && scene.invertClassification;\n\n  if (useInvertClassification) {\n    var depthFramebuffer;\n\n    if (scene.frameState.invertClassificationColor.alpha === 1.0) {\n      if (environmentState.useGlobeDepthFramebuffer) {\n        depthFramebuffer = view.globeDepth.framebuffer;\n      }\n    }\n\n    if (defined(depthFramebuffer) || context.depthTexture) {\n      scene._invertClassification.previousFramebuffer = depthFramebuffer;\n\n      scene._invertClassification.update(context);\n\n      scene._invertClassification.clear(context, passState);\n\n      if (scene.frameState.invertClassificationColor.alpha < 1.0 && useOIT) {\n        var command = scene._invertClassification.unclassifiedCommand;\n        var derivedCommands = command.derivedCommands;\n        derivedCommands.oit = oit.createDerivedCommands(command, context, derivedCommands.oit);\n      }\n    } else {\n      environmentState.useInvertClassification = false;\n    }\n  }\n}\n/**\n * @private\n */\n\n\nScene.prototype.resolveFramebuffers = function (passState) {\n  var context = this._context;\n  var frameState = this._frameState;\n  var environmentState = this._environmentState;\n  var view = this._view;\n  var globeDepth = view.globeDepth;\n  var useOIT = environmentState.useOIT;\n  var useGlobeDepthFramebuffer = environmentState.useGlobeDepthFramebuffer;\n  var usePostProcess = environmentState.usePostProcess;\n  var defaultFramebuffer = environmentState.originalFramebuffer;\n  var globeFramebuffer = useGlobeDepthFramebuffer ? globeDepth.framebuffer : undefined;\n  var sceneFramebuffer = view.sceneFramebuffer.getFramebuffer();\n  var idFramebuffer = view.sceneFramebuffer.getIdFramebuffer();\n\n  if (environmentState.separatePrimitiveFramebuffer) {\n    // Merge primitive framebuffer into globe framebuffer\n    globeDepth.executeMergeColor(context, passState);\n  }\n\n  if (useOIT) {\n    passState.framebuffer = usePostProcess ? sceneFramebuffer : defaultFramebuffer;\n    view.oit.execute(context, passState);\n  }\n\n  if (usePostProcess) {\n    var inputFramebuffer = sceneFramebuffer;\n\n    if (useGlobeDepthFramebuffer && !useOIT) {\n      inputFramebuffer = globeFramebuffer;\n    }\n\n    var postProcess = this.postProcessStages;\n    var colorTexture = inputFramebuffer.getColorTexture(0);\n    var idTexture = idFramebuffer.getColorTexture(0);\n    var depthTexture = defaultValue(globeFramebuffer, sceneFramebuffer).depthStencilTexture;\n    postProcess.execute(context, colorTexture, depthTexture, idTexture);\n    postProcess.copy(context, defaultFramebuffer);\n  }\n\n  if (!useOIT && !usePostProcess && useGlobeDepthFramebuffer) {\n    passState.framebuffer = defaultFramebuffer;\n    globeDepth.executeCopyColor(context, passState);\n  }\n\n  var useLogDepth = frameState.useLogDepth;\n\n  if (this.debugShowGlobeDepth && useGlobeDepthFramebuffer) {\n    var gd = getDebugGlobeDepth(this, this.debugShowDepthFrustum - 1);\n    gd.executeDebugGlobeDepth(context, passState, useLogDepth);\n  }\n\n  if (this.debugShowPickDepth && useGlobeDepthFramebuffer) {\n    var pd = this._picking.getPickDepth(this, this.debugShowDepthFrustum - 1);\n\n    pd.executeDebugPickDepth(context, passState, useLogDepth);\n  }\n};\n\nfunction callAfterRenderFunctions(scene) {\n  // Functions are queued up during primitive update and executed here in case\n  // the function modifies scene state that should remain constant over the frame.\n  var functions = scene._frameState.afterRender;\n\n  for (var i = 0, length = functions.length; i < length; ++i) {\n    functions[i]();\n    scene.requestRender();\n  }\n\n  functions.length = 0;\n}\n\nfunction isCameraUnderground(scene) {\n  var camera = scene.camera;\n  var mode = scene._mode;\n  var globe = scene.globe;\n  var cameraController = scene._screenSpaceCameraController;\n  var cartographic = camera.positionCartographic;\n\n  if (!cameraController.onMap() && cartographic.height < 0.0) {\n    // The camera can go off the map while in Columbus View.\n    // Make a best guess as to whether it's underground by checking if its height is less than zero.\n    return true;\n  }\n\n  if (!defined(globe) || !globe.show || mode === SceneMode.SCENE2D || mode === SceneMode.MORPHING) {\n    return false;\n  }\n\n  if (cameraController.adjustedHeightForTerrain()) {\n    // The camera controller already adjusted the camera, no need to call globe.getHeight again\n    return false;\n  }\n\n  var globeHeight = globe.getHeight(cartographic);\n\n  if (defined(globeHeight) && cartographic.height < globeHeight) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * @private\n */\n\n\nScene.prototype.initializeFrame = function () {\n  // Destroy released shaders and textures once every 120 frames to avoid thrashing the cache\n  if (this._shaderFrameCount++ === 120) {\n    this._shaderFrameCount = 0;\n\n    this._context.shaderCache.destroyReleasedShaderPrograms();\n\n    this._context.textureCache.destroyReleasedTextures();\n  }\n\n  this._tweens.update();\n\n  this._screenSpaceCameraController.update();\n\n  if (defined(this._deviceOrientationCameraController)) {\n    this._deviceOrientationCameraController.update();\n  }\n\n  this.camera.update(this._mode);\n\n  this.camera._updateCameraChanged();\n\n  this._cameraUnderground = isCameraUnderground(this);\n};\n\nfunction updateDebugShowFramesPerSecond(scene, renderedThisFrame) {\n  if (scene.debugShowFramesPerSecond) {\n    if (!defined(scene._performanceDisplay)) {\n      var performanceContainer = document.createElement(\"div\");\n      performanceContainer.className = \"cesium-performanceDisplay-defaultContainer\";\n      var container = scene._canvas.parentNode;\n      container.appendChild(performanceContainer);\n      var performanceDisplay = new PerformanceDisplay({\n        container: performanceContainer\n      });\n      scene._performanceDisplay = performanceDisplay;\n      scene._performanceContainer = performanceContainer;\n    }\n\n    scene._performanceDisplay.throttled = scene.requestRenderMode;\n\n    scene._performanceDisplay.update(renderedThisFrame);\n  } else if (defined(scene._performanceDisplay)) {\n    scene._performanceDisplay = scene._performanceDisplay && scene._performanceDisplay.destroy();\n\n    scene._performanceContainer.parentNode.removeChild(scene._performanceContainer);\n  }\n}\n\nfunction prePassesUpdate(scene) {\n  scene._jobScheduler.resetBudgets();\n\n  var frameState = scene._frameState;\n  var primitives = scene.primitives;\n  primitives.prePassesUpdate(frameState);\n\n  if (defined(scene.globe)) {\n    scene.globe.update(frameState);\n  }\n\n  scene._picking.update();\n\n  frameState.creditDisplay.update();\n}\n\nfunction postPassesUpdate(scene) {\n  var frameState = scene._frameState;\n  var primitives = scene.primitives;\n  primitives.postPassesUpdate(frameState);\n  RequestScheduler.update();\n}\n\nvar scratchBackgroundColor = new Color();\n\nfunction render(scene) {\n  var frameState = scene._frameState;\n  var context = scene.context;\n  var us = context.uniformState;\n  var view = scene._defaultView;\n  scene._view = view;\n  scene.updateFrameState();\n  frameState.passes.render = true;\n  frameState.passes.postProcess = scene.postProcessStages.hasSelected;\n  frameState.tilesetPassState = renderTilesetPassState;\n  var backgroundColor = defaultValue(scene.backgroundColor, Color.BLACK);\n\n  if (scene._hdr) {\n    backgroundColor = Color.clone(backgroundColor, scratchBackgroundColor);\n    backgroundColor.red = Math.pow(backgroundColor.red, scene.gamma);\n    backgroundColor.green = Math.pow(backgroundColor.green, scene.gamma);\n    backgroundColor.blue = Math.pow(backgroundColor.blue, scene.gamma);\n  }\n\n  frameState.backgroundColor = backgroundColor;\n  scene.fog.update(frameState);\n  us.update(frameState);\n  var shadowMap = scene.shadowMap;\n\n  if (defined(shadowMap) && shadowMap.enabled) {\n    if (!defined(scene.light) || scene.light instanceof SunLight) {\n      // Negate the sun direction so that it is from the Sun, not to the Sun\n      Cartesian3.negate(us.sunDirectionWC, scene._shadowMapCamera.direction);\n    } else {\n      Cartesian3.clone(scene.light.direction, scene._shadowMapCamera.direction);\n    }\n\n    frameState.shadowMaps.push(shadowMap);\n  }\n\n  scene._computeCommandList.length = 0;\n  scene._overlayCommandList.length = 0;\n  var viewport = view.viewport;\n  viewport.x = 0;\n  viewport.y = 0;\n  viewport.width = context.drawingBufferWidth;\n  viewport.height = context.drawingBufferHeight;\n  var passState = view.passState;\n  passState.framebuffer = undefined;\n  passState.blendingEnabled = undefined;\n  passState.scissorTest = undefined;\n  passState.viewport = BoundingRectangle.clone(viewport, passState.viewport);\n\n  if (defined(scene.globe)) {\n    scene.globe.beginFrame(frameState);\n  }\n\n  scene.updateEnvironment();\n  scene.updateAndExecuteCommands(passState, backgroundColor);\n  scene.resolveFramebuffers(passState);\n  passState.framebuffer = undefined;\n  executeOverlayCommands(scene, passState);\n\n  if (defined(scene.globe)) {\n    scene.globe.endFrame(frameState);\n\n    if (!scene.globe.tilesLoaded) {\n      scene._renderRequested = true;\n    }\n  }\n\n  context.endFrame();\n}\n\nfunction tryAndCatchError(scene, functionToExecute) {\n  try {\n    functionToExecute(scene);\n  } catch (error) {\n    scene._renderError.raiseEvent(scene, error);\n\n    if (scene.rethrowRenderErrors) {\n      throw error;\n    }\n  }\n}\n\nfunction updateMostDetailedRayPicks(scene) {\n  return scene._picking.updateMostDetailedRayPicks(scene);\n}\n/**\n * Update and render the scene.\n * @param {JulianDate} [time] The simulation time at which to render.\n *\n * @private\n */\n\n\nScene.prototype.render = function (time) {\n  /**\n   *\n   * Pre passes update. Execute any pass invariant code that should run before the passes here.\n   *\n   */\n  this._preUpdate.raiseEvent(this, time);\n\n  var frameState = this._frameState;\n  frameState.newFrame = false;\n\n  if (!defined(time)) {\n    time = JulianDate.now();\n  } // Determine if shouldRender\n\n\n  var cameraChanged = this._view.checkForCameraUpdates(this);\n\n  var shouldRender = !this.requestRenderMode || this._renderRequested || cameraChanged || this._logDepthBufferDirty || this._hdrDirty || this.mode === SceneMode.MORPHING;\n\n  if (!shouldRender && defined(this.maximumRenderTimeChange) && defined(this._lastRenderTime)) {\n    var difference = Math.abs(JulianDate.secondsDifference(this._lastRenderTime, time));\n    shouldRender = shouldRender || difference > this.maximumRenderTimeChange;\n  }\n\n  if (shouldRender) {\n    this._lastRenderTime = JulianDate.clone(time, this._lastRenderTime);\n    this._renderRequested = false;\n    this._logDepthBufferDirty = false;\n    this._hdrDirty = false;\n    var frameNumber = CesiumMath.incrementWrap(frameState.frameNumber, 15000000.0, 1.0);\n    updateFrameNumber(this, frameNumber, time);\n    frameState.newFrame = true;\n  }\n\n  tryAndCatchError(this, prePassesUpdate);\n  /**\n   *\n   * Passes update. Add any passes here\n   *\n   */\n\n  if (this.primitives.show) {\n    tryAndCatchError(this, updateMostDetailedRayPicks);\n    tryAndCatchError(this, updatePreloadPass);\n    tryAndCatchError(this, updatePreloadFlightPass);\n\n    if (!shouldRender) {\n      tryAndCatchError(this, updateRequestRenderModeDeferCheckPass);\n    }\n  }\n\n  this._postUpdate.raiseEvent(this, time);\n\n  if (shouldRender) {\n    this._preRender.raiseEvent(this, time);\n\n    frameState.creditDisplay.beginFrame();\n    tryAndCatchError(this, render);\n  }\n  /**\n   *\n   * Post passes update. Execute any pass invariant code that should run after the passes here.\n   *\n   */\n\n\n  updateDebugShowFramesPerSecond(this, shouldRender);\n  tryAndCatchError(this, postPassesUpdate); // Often used to trigger events (so don't want in trycatch) that the user might be subscribed to. Things like the tile load events, ready promises, etc.\n  // We don't want those events to resolve during the render loop because the events might add new primitives\n\n  callAfterRenderFunctions(this);\n\n  if (shouldRender) {\n    this._postRender.raiseEvent(this, time);\n\n    frameState.creditDisplay.endFrame();\n  }\n};\n/**\n * Update and render the scene. Always forces a new render frame regardless of whether a render was\n * previously requested.\n * @param {JulianDate} [time] The simulation time at which to render.\n *\n * @private\n */\n\n\nScene.prototype.forceRender = function (time) {\n  this._renderRequested = true;\n  this.render(time);\n};\n/**\n * Requests a new rendered frame when {@link Scene#requestRenderMode} is set to <code>true</code>.\n * The render rate will not exceed the {@link CesiumWidget#targetFrameRate}.\n *\n * @see Scene#requestRenderMode\n */\n\n\nScene.prototype.requestRender = function () {\n  this._renderRequested = true;\n};\n/**\n * @private\n */\n\n\nScene.prototype.clampLineWidth = function (width) {\n  return Math.max(ContextLimits.minimumAliasedLineWidth, Math.min(width, ContextLimits.maximumAliasedLineWidth));\n};\n/**\n * Returns an object with a `primitive` property that contains the first (top) primitive in the scene\n * at a particular window coordinate or undefined if nothing is at the location. Other properties may\n * potentially be set depending on the type of primitive and may be used to further identify the picked object.\n * <p>\n * When a feature of a 3D Tiles tileset is picked, <code>pick</code> returns a {@link Cesium3DTileFeature} object.\n * </p>\n *\n * @example\n * // On mouse over, color the feature yellow.\n * handler.setInputAction(function(movement) {\n *     var feature = scene.pick(movement.endPosition);\n *     if (feature instanceof Cesium.Cesium3DTileFeature) {\n *         feature.color = Cesium.Color.YELLOW;\n *     }\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n *\n * @param {Cartesian2} windowPosition Window coordinates to perform picking on.\n * @param {Number} [width=3] Width of the pick rectangle.\n * @param {Number} [height=3] Height of the pick rectangle.\n * @returns {Object} Object containing the picked primitive.\n */\n\n\nScene.prototype.pick = function (windowPosition, width, height) {\n  return this._picking.pick(this, windowPosition, width, height);\n};\n/**\n * Returns the cartesian position reconstructed from the depth buffer and window position.\n * The returned position is in world coordinates. Used internally by camera functions to\n * prevent conversion to projected 2D coordinates and then back.\n * <p>\n * Set {@link Scene#pickTranslucentDepth} to <code>true</code> to include the depth of\n * translucent primitives; otherwise, this essentially picks through translucent primitives.\n * </p>\n *\n * @private\n *\n * @param {Cartesian2} windowPosition Window coordinates to perform picking on.\n * @param {Cartesian3} [result] The object on which to restore the result.\n * @returns {Cartesian3} The cartesian position in world coordinates.\n *\n * @exception {DeveloperError} Picking from the depth buffer is not supported. Check pickPositionSupported.\n */\n\n\nScene.prototype.pickPositionWorldCoordinates = function (windowPosition, result) {\n  return this._picking.pickPositionWorldCoordinates(this, windowPosition, result);\n};\n/**\n * Returns the cartesian position reconstructed from the depth buffer and window position.\n * <p>\n * The position reconstructed from the depth buffer in 2D may be slightly different from those\n * reconstructed in 3D and Columbus view. This is caused by the difference in the distribution\n * of depth values of perspective and orthographic projection.\n * </p>\n * <p>\n * Set {@link Scene#pickTranslucentDepth} to <code>true</code> to include the depth of\n * translucent primitives; otherwise, this essentially picks through translucent primitives.\n * </p>\n *\n * @param {Cartesian2} windowPosition Window coordinates to perform picking on.\n * @param {Cartesian3} [result] The object on which to restore the result.\n * @returns {Cartesian3} The cartesian position.\n *\n * @exception {DeveloperError} Picking from the depth buffer is not supported. Check pickPositionSupported.\n */\n\n\nScene.prototype.pickPosition = function (windowPosition, result) {\n  return this._picking.pickPosition(this, windowPosition, result);\n};\n/**\n * Returns a list of objects, each containing a `primitive` property, for all primitives at\n * a particular window coordinate position. Other properties may also be set depending on the\n * type of primitive and may be used to further identify the picked object. The primitives in\n * the list are ordered by their visual order in the scene (front to back).\n *\n * @param {Cartesian2} windowPosition Window coordinates to perform picking on.\n * @param {Number} [limit] If supplied, stop drilling after collecting this many picks.\n * @param {Number} [width=3] Width of the pick rectangle.\n * @param {Number} [height=3] Height of the pick rectangle.\n * @returns {Object[]} Array of objects, each containing 1 picked primitives.\n *\n * @exception {DeveloperError} windowPosition is undefined.\n *\n * @example\n * var pickedObjects = scene.drillPick(new Cesium.Cartesian2(100.0, 200.0));\n *\n * @see Scene#pick\n */\n\n\nScene.prototype.drillPick = function (windowPosition, limit, width, height) {\n  return this._picking.drillPick(this, windowPosition, limit, width, height);\n};\n\nfunction updatePreloadPass(scene) {\n  var frameState = scene._frameState;\n  preloadTilesetPassState.camera = frameState.camera;\n  preloadTilesetPassState.cullingVolume = frameState.cullingVolume;\n  var primitives = scene.primitives;\n  primitives.updateForPass(frameState, preloadTilesetPassState);\n}\n\nfunction updatePreloadFlightPass(scene) {\n  var frameState = scene._frameState;\n  var camera = frameState.camera;\n\n  if (!camera.canPreloadFlight()) {\n    return;\n  }\n\n  preloadFlightTilesetPassState.camera = scene.preloadFlightCamera;\n  preloadFlightTilesetPassState.cullingVolume = scene.preloadFlightCullingVolume;\n  var primitives = scene.primitives;\n  primitives.updateForPass(frameState, preloadFlightTilesetPassState);\n}\n\nfunction updateRequestRenderModeDeferCheckPass(scene) {\n  // Check if any ignored requests are ready to go (to wake rendering up again)\n  scene.primitives.updateForPass(scene._frameState, requestRenderModeDeferCheckPassState);\n}\n/**\n * Returns an object containing the first object intersected by the ray and the position of intersection,\n * or <code>undefined</code> if there were no intersections. The intersected object has a <code>primitive</code>\n * property that contains the intersected primitive. Other properties may be set depending on the type of primitive\n * and may be used to further identify the picked object. The ray must be given in world coordinates.\n * <p>\n * This function only picks globe tiles and 3D Tiles that are rendered in the current view. Picks all other\n * primitives regardless of their visibility.\n * </p>\n *\n * @private\n *\n * @param {Ray} ray The ray.\n * @param {Object[]} [objectsToExclude] A list of primitives, entities, or 3D Tiles features to exclude from the ray intersection.\n * @param {Number} [width=0.1] Width of the intersection volume in meters.\n * @returns {Object} An object containing the object and position of the first intersection.\n *\n * @exception {DeveloperError} Ray intersections are only supported in 3D mode.\n */\n\n\nScene.prototype.pickFromRay = function (ray, objectsToExclude, width) {\n  return this._picking.pickFromRay(this, ray, objectsToExclude, width);\n};\n/**\n * Returns a list of objects, each containing the object intersected by the ray and the position of intersection.\n * The intersected object has a <code>primitive</code> property that contains the intersected primitive. Other\n * properties may also be set depending on the type of primitive and may be used to further identify the picked object.\n * The primitives in the list are ordered by first intersection to last intersection. The ray must be given in\n * world coordinates.\n * <p>\n * This function only picks globe tiles and 3D Tiles that are rendered in the current view. Picks all other\n * primitives regardless of their visibility.\n * </p>\n *\n * @private\n *\n * @param {Ray} ray The ray.\n * @param {Number} [limit=Number.MAX_VALUE] If supplied, stop finding intersections after this many intersections.\n * @param {Object[]} [objectsToExclude] A list of primitives, entities, or 3D Tiles features to exclude from the ray intersection.\n * @param {Number} [width=0.1] Width of the intersection volume in meters.\n * @returns {Object[]} List of objects containing the object and position of each intersection.\n *\n * @exception {DeveloperError} Ray intersections are only supported in 3D mode.\n */\n\n\nScene.prototype.drillPickFromRay = function (ray, limit, objectsToExclude, width) {\n  return this._picking.drillPickFromRay(this, ray, limit, objectsToExclude, width);\n};\n/**\n * Initiates an asynchronous {@link Scene#pickFromRay} request using the maximum level of detail for 3D Tilesets\n * regardless of visibility.\n *\n * @private\n *\n * @param {Ray} ray The ray.\n * @param {Object[]} [objectsToExclude] A list of primitives, entities, or 3D Tiles features to exclude from the ray intersection.\n * @param {Number} [width=0.1] Width of the intersection volume in meters.\n * @returns {Promise.<Object>} A promise that resolves to an object containing the object and position of the first intersection.\n *\n * @exception {DeveloperError} Ray intersections are only supported in 3D mode.\n */\n\n\nScene.prototype.pickFromRayMostDetailed = function (ray, objectsToExclude, width) {\n  return this._picking.pickFromRayMostDetailed(this, ray, objectsToExclude, width);\n};\n/**\n * Initiates an asynchronous {@link Scene#drillPickFromRay} request using the maximum level of detail for 3D Tilesets\n * regardless of visibility.\n *\n * @private\n *\n * @param {Ray} ray The ray.\n * @param {Number} [limit=Number.MAX_VALUE] If supplied, stop finding intersections after this many intersections.\n * @param {Object[]} [objectsToExclude] A list of primitives, entities, or 3D Tiles features to exclude from the ray intersection.\n * @param {Number} [width=0.1] Width of the intersection volume in meters.\n * @returns {Promise.<Object[]>} A promise that resolves to a list of objects containing the object and position of each intersection.\n *\n * @exception {DeveloperError} Ray intersections are only supported in 3D mode.\n */\n\n\nScene.prototype.drillPickFromRayMostDetailed = function (ray, limit, objectsToExclude, width) {\n  return this._picking.drillPickFromRayMostDetailed(this, ray, limit, objectsToExclude, width);\n};\n/**\n * Returns the height of scene geometry at the given cartographic position or <code>undefined</code> if there was no\n * scene geometry to sample height from. The height of the input position is ignored. May be used to clamp objects to\n * the globe, 3D Tiles, or primitives in the scene.\n * <p>\n * This function only samples height from globe tiles and 3D Tiles that are rendered in the current view. Samples height\n * from all other primitives regardless of their visibility.\n * </p>\n *\n * @param {Cartographic} position The cartographic position to sample height from.\n * @param {Object[]} [objectsToExclude] A list of primitives, entities, or 3D Tiles features to not sample height from.\n * @param {Number} [width=0.1] Width of the intersection volume in meters.\n * @returns {Number} The height. This may be <code>undefined</code> if there was no scene geometry to sample height from.\n *\n * @example\n * var position = new Cesium.Cartographic(-1.31968, 0.698874);\n * var height = viewer.scene.sampleHeight(position);\n * console.log(height);\n *\n * @see Scene#clampToHeight\n * @see Scene#clampToHeightMostDetailed\n * @see Scene#sampleHeightMostDetailed\n *\n * @exception {DeveloperError} sampleHeight is only supported in 3D mode.\n * @exception {DeveloperError} sampleHeight requires depth texture support. Check sampleHeightSupported.\n */\n\n\nScene.prototype.sampleHeight = function (position, objectsToExclude, width) {\n  return this._picking.sampleHeight(this, position, objectsToExclude, width);\n};\n/**\n * Clamps the given cartesian position to the scene geometry along the geodetic surface normal. Returns the\n * clamped position or <code>undefined</code> if there was no scene geometry to clamp to. May be used to clamp\n * objects to the globe, 3D Tiles, or primitives in the scene.\n * <p>\n * This function only clamps to globe tiles and 3D Tiles that are rendered in the current view. Clamps to\n * all other primitives regardless of their visibility.\n * </p>\n *\n * @param {Cartesian3} cartesian The cartesian position.\n * @param {Object[]} [objectsToExclude] A list of primitives, entities, or 3D Tiles features to not clamp to.\n * @param {Number} [width=0.1] Width of the intersection volume in meters.\n * @param {Cartesian3} [result] An optional object to return the clamped position.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided. This may be <code>undefined</code> if there was no scene geometry to clamp to.\n *\n * @example\n * // Clamp an entity to the underlying scene geometry\n * var position = entity.position.getValue(Cesium.JulianDate.now());\n * entity.position = viewer.scene.clampToHeight(position);\n *\n * @see Scene#sampleHeight\n * @see Scene#sampleHeightMostDetailed\n * @see Scene#clampToHeightMostDetailed\n *\n * @exception {DeveloperError} clampToHeight is only supported in 3D mode.\n * @exception {DeveloperError} clampToHeight requires depth texture support. Check clampToHeightSupported.\n */\n\n\nScene.prototype.clampToHeight = function (cartesian, objectsToExclude, width, result) {\n  return this._picking.clampToHeight(this, cartesian, objectsToExclude, width, result);\n};\n/**\n * Initiates an asynchronous {@link Scene#sampleHeight} query for an array of {@link Cartographic} positions\n * using the maximum level of detail for 3D Tilesets in the scene. The height of the input positions is ignored.\n * Returns a promise that is resolved when the query completes. Each point height is modified in place.\n * If a height cannot be determined because no geometry can be sampled at that location, or another error occurs,\n * the height is set to undefined.\n *\n * @param {Cartographic[]} positions The cartographic positions to update with sampled heights.\n * @param {Object[]} [objectsToExclude] A list of primitives, entities, or 3D Tiles features to not sample height from.\n * @param {Number} [width=0.1] Width of the intersection volume in meters.\n * @returns {Promise.<Number[]>} A promise that resolves to the provided list of positions when the query has completed.\n *\n * @example\n * var positions = [\n *     new Cesium.Cartographic(-1.31968, 0.69887),\n *     new Cesium.Cartographic(-1.10489, 0.83923)\n * ];\n * var promise = viewer.scene.sampleHeightMostDetailed(positions);\n * promise.then(function(updatedPosition) {\n *     // positions[0].height and positions[1].height have been updated.\n *     // updatedPositions is just a reference to positions.\n * }\n *\n * @see Scene#sampleHeight\n *\n * @exception {DeveloperError} sampleHeightMostDetailed is only supported in 3D mode.\n * @exception {DeveloperError} sampleHeightMostDetailed requires depth texture support. Check sampleHeightSupported.\n */\n\n\nScene.prototype.sampleHeightMostDetailed = function (positions, objectsToExclude, width) {\n  return this._picking.sampleHeightMostDetailed(this, positions, objectsToExclude, width);\n};\n/**\n * Initiates an asynchronous {@link Scene#clampToHeight} query for an array of {@link Cartesian3} positions\n * using the maximum level of detail for 3D Tilesets in the scene. Returns a promise that is resolved when\n * the query completes. Each position is modified in place. If a position cannot be clamped because no geometry\n * can be sampled at that location, or another error occurs, the element in the array is set to undefined.\n *\n * @param {Cartesian3[]} cartesians The cartesian positions to update with clamped positions.\n * @param {Object[]} [objectsToExclude] A list of primitives, entities, or 3D Tiles features to not clamp to.\n * @param {Number} [width=0.1] Width of the intersection volume in meters.\n * @returns {Promise.<Cartesian3[]>} A promise that resolves to the provided list of positions when the query has completed.\n *\n * @example\n * var cartesians = [\n *     entities[0].position.getValue(Cesium.JulianDate.now()),\n *     entities[1].position.getValue(Cesium.JulianDate.now())\n * ];\n * var promise = viewer.scene.clampToHeightMostDetailed(cartesians);\n * promise.then(function(updatedCartesians) {\n *     entities[0].position = updatedCartesians[0];\n *     entities[1].position = updatedCartesians[1];\n * }\n *\n * @see Scene#clampToHeight\n *\n * @exception {DeveloperError} clampToHeightMostDetailed is only supported in 3D mode.\n * @exception {DeveloperError} clampToHeightMostDetailed requires depth texture support. Check clampToHeightSupported.\n */\n\n\nScene.prototype.clampToHeightMostDetailed = function (cartesians, objectsToExclude, width) {\n  return this._picking.clampToHeightMostDetailed(this, cartesians, objectsToExclude, width);\n};\n/**\n * Transforms a position in cartesian coordinates to canvas coordinates.  This is commonly used to place an\n * HTML element at the same screen position as an object in the scene.\n *\n * @param {Cartesian3} position The position in cartesian coordinates.\n * @param {Cartesian2} [result] An optional object to return the input position transformed to canvas coordinates.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.  This may be <code>undefined</code> if the input position is near the center of the ellipsoid.\n *\n * @example\n * // Output the canvas position of longitude/latitude (0, 0) every time the mouse moves.\n * var scene = widget.scene;\n * var ellipsoid = scene.globe.ellipsoid;\n * var position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);\n * handler.setInputAction(function(movement) {\n *     console.log(scene.cartesianToCanvasCoordinates(position));\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n */\n\n\nScene.prototype.cartesianToCanvasCoordinates = function (position, result) {\n  return SceneTransforms.wgs84ToWindowCoordinates(this, position, result);\n};\n/**\n * Instantly completes an active transition.\n */\n\n\nScene.prototype.completeMorph = function () {\n  this._transitioner.completeMorph();\n};\n/**\n * Asynchronously transitions the scene to 2D.\n * @param {Number} [duration=2.0] The amount of time, in seconds, for transition animations to complete.\n */\n\n\nScene.prototype.morphTo2D = function (duration) {\n  var ellipsoid;\n  var globe = this.globe;\n\n  if (defined(globe)) {\n    ellipsoid = globe.ellipsoid;\n  } else {\n    ellipsoid = this.mapProjection.ellipsoid;\n  }\n\n  duration = defaultValue(duration, 2.0);\n\n  this._transitioner.morphTo2D(duration, ellipsoid);\n};\n/**\n * Asynchronously transitions the scene to Columbus View.\n * @param {Number} [duration=2.0] The amount of time, in seconds, for transition animations to complete.\n */\n\n\nScene.prototype.morphToColumbusView = function (duration) {\n  var ellipsoid;\n  var globe = this.globe;\n\n  if (defined(globe)) {\n    ellipsoid = globe.ellipsoid;\n  } else {\n    ellipsoid = this.mapProjection.ellipsoid;\n  }\n\n  duration = defaultValue(duration, 2.0);\n\n  this._transitioner.morphToColumbusView(duration, ellipsoid);\n};\n/**\n * Asynchronously transitions the scene to 3D.\n * @param {Number} [duration=2.0] The amount of time, in seconds, for transition animations to complete.\n */\n\n\nScene.prototype.morphTo3D = function (duration) {\n  var ellipsoid;\n  var globe = this.globe;\n\n  if (defined(globe)) {\n    ellipsoid = globe.ellipsoid;\n  } else {\n    ellipsoid = this.mapProjection.ellipsoid;\n  }\n\n  duration = defaultValue(duration, 2.0);\n\n  this._transitioner.morphTo3D(duration, ellipsoid);\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see Scene#destroy\n */\n\n\nScene.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * scene = scene && scene.destroy();\n *\n * @see Scene#isDestroyed\n */\n\n\nScene.prototype.destroy = function () {\n  this._tweens.removeAll();\n\n  this._computeEngine = this._computeEngine && this._computeEngine.destroy();\n  this._screenSpaceCameraController = this._screenSpaceCameraController && this._screenSpaceCameraController.destroy();\n  this._deviceOrientationCameraController = this._deviceOrientationCameraController && !this._deviceOrientationCameraController.isDestroyed() && this._deviceOrientationCameraController.destroy();\n  this._primitives = this._primitives && this._primitives.destroy();\n  this._groundPrimitives = this._groundPrimitives && this._groundPrimitives.destroy();\n  this._globe = this._globe && this._globe.destroy();\n  this.skyBox = this.skyBox && this.skyBox.destroy();\n  this.skyAtmosphere = this.skyAtmosphere && this.skyAtmosphere.destroy();\n  this._debugSphere = this._debugSphere && this._debugSphere.destroy();\n  this.sun = this.sun && this.sun.destroy();\n  this._sunPostProcess = this._sunPostProcess && this._sunPostProcess.destroy();\n  this._depthPlane = this._depthPlane && this._depthPlane.destroy();\n  this._transitioner = this._transitioner && this._transitioner.destroy();\n  this._debugFrustumPlanes = this._debugFrustumPlanes && this._debugFrustumPlanes.destroy();\n  this._brdfLutGenerator = this._brdfLutGenerator && this._brdfLutGenerator.destroy();\n  this._picking = this._picking && this._picking.destroy();\n  this._defaultView = this._defaultView && this._defaultView.destroy();\n  this._view = undefined;\n\n  if (this._removeCreditContainer) {\n    this._canvas.parentNode.removeChild(this._creditContainer);\n  }\n\n  this.postProcessStages = this.postProcessStages && this.postProcessStages.destroy();\n  this._context = this._context && this._context.destroy();\n  this._frameState.creditDisplay = this._frameState.creditDisplay && this._frameState.creditDisplay.destroy();\n\n  if (defined(this._performanceDisplay)) {\n    this._performanceDisplay = this._performanceDisplay && this._performanceDisplay.destroy();\n\n    this._performanceContainer.parentNode.removeChild(this._performanceContainer);\n  }\n\n  this._removeRequestListenerCallback();\n\n  this._removeTaskProcessorListenerCallback();\n\n  for (var i = 0; i < this._removeGlobeCallbacks.length; ++i) {\n    this._removeGlobeCallbacks[i]();\n  }\n\n  this._removeGlobeCallbacks.length = 0;\n  return destroyObject(this);\n};\n\nexport default Scene;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Scene/Scene.js"],"names":["BoundingRectangle","BoundingSphere","BoxGeometry","Cartesian3","Cartographic","clone","Color","ColorGeometryInstanceAttribute","createGuid","CullingVolume","defaultValue","defined","destroyObject","DeveloperError","EllipsoidGeometry","Event","GeographicProjection","GeometryInstance","GeometryPipeline","Intersect","JulianDate","CesiumMath","Matrix4","mergeSort","Occluder","OrthographicFrustum","OrthographicOffCenterFrustum","PerspectiveFrustum","PerspectiveOffCenterFrustum","RequestScheduler","TaskProcessor","Transforms","ClearCommand","ComputeEngine","Context","ContextLimits","DrawCommand","Pass","RenderState","ShaderProgram","ShaderSource","BrdfLutGenerator","Camera","Cesium3DTilePass","Cesium3DTilePassState","CreditDisplay","DebugCameraPrimitive","DepthPlane","DerivedCommand","DeviceOrientationCameraController","Fog","FrameState","GlobeDepth","InvertClassification","JobScheduler","MapMode2D","OctahedralProjectedCubeMap","PerformanceDisplay","PerInstanceColorAppearance","Picking","PostProcessStageCollection","Primitive","PrimitiveCollection","SceneMode","SceneTransforms","SceneTransitioner","ScreenSpaceCameraController","ShadowMap","StencilConstants","SunLight","SunPostProcess","TweenCollection","View","requestRenderAfterFrame","scene","frameState","afterRender","push","requestRender","Scene","options","EMPTY_OBJECT","canvas","creditContainer","creditViewport","contextOptions","webgl","powerPreference","hasCreditContainer","context","document","createElement","style","position","bottom","color","parentNode","appendChild","_id","_jobScheduler","_frameState","scene3DOnly","_removeCreditContainer","_creditContainer","_canvas","_context","_computeEngine","_globe","undefined","_primitives","_groundPrimitives","_logDepthBuffer","fragmentDepth","_logDepthBufferDirty","_tweens","_shaderFrameCount","_sunPostProcess","_computeCommandList","_overlayCommandList","_useOIT","orderIndependentTranslucency","_executeOITFunction","_depthPlane","_clearColorCommand","stencil","owner","_depthClearCommand","depth","_stencilClearCommand","_classificationStencilClearCommand","renderState","fromCache","stencilMask","CLASSIFICATION_MASK","_depthOnlyRenderStateCache","_transitioner","_preUpdate","_postUpdate","_renderError","_preRender","_postRender","_minimumDisableDepthTestDistance","rethrowRenderErrors","completeMorphOnUserInput","morphStart","morphComplete","skyBox","skyAtmosphere","sun","sunBloom","_sunBloom","moon","backgroundColor","BLACK","_mode","SCENE3D","_mapProjection","mapProjection","morphTime","farToNearRatio","logarithmicDepthFarToNearRatio","nearToFarDistance2D","debugCommandFilter","debugShowCommands","debugShowFrustums","debugShowFramesPerSecond","debugShowGlobeDepth","debugShowDepthFrustum","debugShowFrustumPlanes","_debugShowFrustumPlanes","_debugFrustumPlanes","useDepthPicking","pickTranslucentDepth","cameraEventWaitTime","fog","_shadowMapCamera","shadowMap","lightCamera","enabled","shadows","invertClassification","invertClassificationColor","WHITE","_actualInvertClassificationColor","_invertClassificationColor","_invertClassification","focalLength","eyeSeparation","postProcessStages","_brdfLutGenerator","_terrainExaggeration","terrainExaggeration","_performanceDisplay","_debugVolume","_screenSpaceCameraController","_cameraUnderground","_mapMode2D","mapMode2D","INFINITE_SCROLL","_environmentState","skyBoxCommand","skyAtmosphereCommand","sunDrawCommand","sunComputeCommand","moonCommand","isSunVisible","isMoonVisible","isReadyForAtmosphere","isSkyAtmosphereVisible","clearGlobeDepth","useDepthPlane","renderTranslucentDepthForPick","originalFramebuffer","useGlobeDepthFramebuffer","separatePrimitiveFramebuffer","useOIT","useInvertClassification","usePostProcess","usePostProcessSelected","useWebVR","_useWebVR","_cameraVR","_aspectRatioVR","requestRenderMode","_renderRequested","maximumRenderTimeChange","_lastRenderTime","_frameRateMonitor","_removeRequestListenerCallback","requestCompletedEvent","addEventListener","_removeTaskProcessorListenerCallback","taskCompletedEvent","_removeGlobeCallbacks","viewport","drawingBufferWidth","drawingBufferHeight","camera","frustum","near","far","preloadFlightCamera","preloadFlightCullingVolume","_picking","_defaultView","_view","_hdr","_hdrDirty","highDynamicRange","gamma","sphericalHarmonicCoefficients","specularEnvironmentMaps","_specularEnvironmentMapAtlas","light","updateFrameNumber","now","updateFrameState","initializeFrame","updateGlobeListeners","globe","i","length","removeGlobeCallbacks","imageryLayersUpdatedEvent","terrainProviderChanged","Object","defineProperties","prototype","get","maximumAliasedLineWidth","maximumCubeMapSize","pickPositionSupported","depthTexture","sampleHeightSupported","clampToHeightSupported","invertClassificationSupported","specularEnvironmentMapsSupported","isSupported","set","destroy","primitives","groundPrimitives","view","defaultView","picking","screenSpaceCameraController","jobScheduler","environmentState","tweens","imageryLayers","terrainProvider","preUpdate","postUpdate","renderError","preRender","postRender","lastRenderTime","debugFrustumStatistics","id","mode","value","SCENE2D","morphTo2D","morphTo3D","COLUMBUS_VIEW","morphToColumbusView","frustumCommandsList","numberOfFrustums","creditDisplay","container","visibility","_deviceOrientationCameraController","aspectRatio","isDestroyed","xOffset","imagerySplitPosition","minimumDisableDepthTestDistance","logarithmicDepthBuffer","updateFrustums","uniformState","hdr","colorBufferFloat","colorBufferHalfFloat","highDynamicRangeSupported","cameraUnderground","pixelRatio","opaqueFrustumNearOffset","getCompressedTextureFormatSupported","format","s3tc","pvrtc","etc1","updateDerivedCommands","command","shadowsDirty","oit","lightShadowMaps","shadowState","lightShadowsEnabled","derivedCommands","pickId","createPickDerivedCommand","pickOnly","createDepthOnlyDerivedCommand","originalCommand","createHdrCommand","receiveShadows","createReceiveDerivedCommand","pass","TRANSLUCENT","createDerivedCommands","receiveCommand","lastDirtyTime","dirty","useLogDepth","useHdr","hasLogDepthDerivedCommands","logDepth","hasHdrCommands","hasDerivedCommands","needsLogDepthDerivedCommands","needsHdrCommands","needsDerivedCommands","shadowMaps","shadowsEnabled","castShadows","createCastDerivedCommand","createLogDepthCommand","renderTilesetPassState","RENDER","preloadTilesetPassState","PRELOAD","preloadFlightTilesetPassState","PRELOAD_FLIGHT","requestRenderModeDeferCheckPassState","REQUEST_RENDER_MODE_DEFER_CHECK","scratchOccluderBoundingSphere","scratchOccluder","getOccluder","show","ellipsoid","minimumTerrainHeight","radius","minimumRadius","fromBoundingSphere","positionWC","clearPasses","passes","render","pick","postProcess","offscreen","frameNumber","time","commandList","brdfLutGenerator","environmentMap","_cubeMap","cullingVolume","computeCullingVolume","directionWC","upWC","occluder","ready","texture","specularEnvironmentMapsMaximumLOD","maximumMipmapLevel","isTranslucencySupported","alpha","maximumScreenSpaceError","tilesetPassState","isVisible","boundingVolume","cull","computeVisibility","OUTSIDE","occlude","isOccluded","getAttributeLocations","shaderProgram","attributeLocations","attributes","vertexAttributes","a","hasOwnProperty","index","createDebugFragmentShaderProgram","sp","fs","fragmentShaderSource","targets","sources","map","source","replaceMain","re","match","exec","indexOf","newMain","_debugColor","fromRandom","c","red","green","blue","r","debugOverlappingFrustums","g","b","vertexShaderSource","executeDebugCommand","passState","debugCommand","shallowClone","execute","transformFrom2D","inverseTransformation","debugShowBoundingVolume","debugFramebuffer","geometry","center","multiplyByPoint","projection","centerCartographic","unproject","cartographicToCartesian","toWireframe","createGeometry","radii","vertexFormat","FLAT_VERTEX_FORMAT","geometryInstances","modelMatrix","fromTranslation","appearance","flat","translucent","asynchronous","halfAxes","fromDimensions","dimensions","fromRotationTranslation","savedCommandList","update","framebuffer","executeCommand","pickCommand","depthOnlyCommand","executeIdCommand","backToFront","distanceSquaredTo","frontToBack","EPSILON12","executeTranslucentCommandsBackToFront","executeFunction","commands","unclassifiedCommand","executeTranslucentCommandsFrontToBack","getDebugGlobeDepth","globeDepths","debugGlobeDepths","globeDepth","scratchPerspectiveFrustum","scratchPerspectiveOffCenterFrustum","scratchOrthographicFrustum","scratchOrthographicOffCenterFrustum","executeCommands","us","updateCamera","fov","infiniteProjectionMatrix","width","updateFrustum","updatePass","ENVIRONMENT","sceneFramebuffer","getFramebuffer","copy","executeTranslucentCommands","numFrustums","clearDepth","clearStencil","clearClassificationStencil","depthPlane","height2D","z","j","frustumCommands","Math","max","fb","clear","stencilBuffer","GLOBE","indices","executeCopyDepth","TERRAIN_CLASSIFICATION","primitiveFramebuffer","CESIUM_3D_TILE","executeUpdateDepth","CESIUM_3D_TILE_CLASSIFICATION","opaqueClassificationFramebuffer","_fbo","CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW","executeClassified","executeUnclassified","OPAQUE","depthStencilTexture","pickDepth","getPickDepth","getIdFramebuffer","executeComputeCommands","COMPUTE","executeOverlayCommands","OVERLAY","insertShadowCastCommands","shadowVolume","shadowMapCullingVolume","isPointLight","numberOfPasses","k","wasVisible","cascadeVolume","executeShadowMapCastCommands","shadowMapLength","outOfView","sceneCommands","numberOfCommands","castCommands","scratchEyeTranslation","updateAndExecuteCommands","executeWebVRCommands","ROTATE","executeCommandsInViewport","updateAndClearFramebuffers","execute2DViewportCommands","updateAndRenderPrimitives","createPotentiallyVisibleSet","x","y","savedCamera","fo","eyeTranslation","multiplyByScalar","right","height","offset","add","subtract","scratch2DViewportCartographic","PI","PI_OVER_TWO","scratch2DViewportMaxCoord","scratch2DViewportSavedPosition","scratch2DViewportTransform","scratch2DViewportCameraTransform","scratch2DViewportEyePoint","scratch2DViewportWindowCoords","scratch2DViewport","originalViewport","maxCartographic","maxCoord","project","transform","_setTransform","IDENTITY","viewportTransformation","computeViewportTransformation","projectionMatrix","eyePoint","fromElements","sign","windowCoordinates","pointToGLWindowCoordinates","floor","viewportX","viewportWidth","abs","left","firstViewport","scratchCullingVolume","updateEnvironment","renderPass","offscreenPass","setDynamicAtmosphereColor","enableLighting","dynamicAtmosphereLighting","dynamicAtmosphereLightingFromSun","_surface","_tilesToRender","sunCommands","drawCommand","computeCommand","depthTestAgainstTerrain","planes","envMaps","envMapAtlas","url","updateDebugFrustumPlanes","updateOnChange","updateShadowMaps","fromLightSource","clearColor","ambientOcclusion","fxaa","bloom","hasSelected","depthFramebuffer","previousFramebuffer","resolveFramebuffers","defaultFramebuffer","globeFramebuffer","idFramebuffer","executeMergeColor","inputFramebuffer","colorTexture","getColorTexture","idTexture","executeCopyColor","gd","executeDebugGlobeDepth","debugShowPickDepth","pd","executeDebugPickDepth","callAfterRenderFunctions","functions","isCameraUnderground","cameraController","cartographic","positionCartographic","onMap","MORPHING","adjustedHeightForTerrain","globeHeight","getHeight","shaderCache","destroyReleasedShaderPrograms","textureCache","destroyReleasedTextures","_updateCameraChanged","updateDebugShowFramesPerSecond","renderedThisFrame","performanceContainer","className","performanceDisplay","_performanceContainer","throttled","removeChild","prePassesUpdate","resetBudgets","postPassesUpdate","scratchBackgroundColor","pow","negate","sunDirectionWC","direction","blendingEnabled","scissorTest","beginFrame","endFrame","tilesLoaded","tryAndCatchError","functionToExecute","error","raiseEvent","updateMostDetailedRayPicks","newFrame","cameraChanged","checkForCameraUpdates","shouldRender","difference","secondsDifference","incrementWrap","updatePreloadPass","updatePreloadFlightPass","updateRequestRenderModeDeferCheckPass","forceRender","clampLineWidth","minimumAliasedLineWidth","min","windowPosition","pickPositionWorldCoordinates","result","pickPosition","drillPick","limit","updateForPass","canPreloadFlight","pickFromRay","ray","objectsToExclude","drillPickFromRay","pickFromRayMostDetailed","drillPickFromRayMostDetailed","sampleHeight","clampToHeight","cartesian","sampleHeightMostDetailed","positions","clampToHeightMostDetailed","cartesians","cartesianToCanvasCoordinates","wgs84ToWindowCoordinates","completeMorph","duration","removeAll","_debugSphere"],"mappings":"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","sourcesContent":["import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport BoxGeometry from \"../Core/BoxGeometry.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport CullingVolume from \"../Core/CullingVolume.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EllipsoidGeometry from \"../Core/EllipsoidGeometry.js\";\nimport Event from \"../Core/Event.js\";\nimport GeographicProjection from \"../Core/GeographicProjection.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport mergeSort from \"../Core/mergeSort.js\";\nimport Occluder from \"../Core/Occluder.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport PerspectiveOffCenterFrustum from \"../Core/PerspectiveOffCenterFrustum.js\";\nimport RequestScheduler from \"../Core/RequestScheduler.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport ComputeEngine from \"../Renderer/ComputeEngine.js\";\nimport Context from \"../Renderer/Context.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport BrdfLutGenerator from \"./BrdfLutGenerator.js\";\nimport Camera from \"./Camera.js\";\nimport Cesium3DTilePass from \"./Cesium3DTilePass.js\";\nimport Cesium3DTilePassState from \"./Cesium3DTilePassState.js\";\nimport CreditDisplay from \"./CreditDisplay.js\";\nimport DebugCameraPrimitive from \"./DebugCameraPrimitive.js\";\nimport DepthPlane from \"./DepthPlane.js\";\nimport DerivedCommand from \"./DerivedCommand.js\";\nimport DeviceOrientationCameraController from \"./DeviceOrientationCameraController.js\";\nimport Fog from \"./Fog.js\";\nimport FrameState from \"./FrameState.js\";\nimport GlobeDepth from \"./GlobeDepth.js\";\nimport InvertClassification from \"./InvertClassification.js\";\nimport JobScheduler from \"./JobScheduler.js\";\nimport MapMode2D from \"./MapMode2D.js\";\nimport OctahedralProjectedCubeMap from \"./OctahedralProjectedCubeMap.js\";\nimport PerformanceDisplay from \"./PerformanceDisplay.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Picking from \"./Picking.js\";\nimport PostProcessStageCollection from \"./PostProcessStageCollection.js\";\nimport Primitive from \"./Primitive.js\";\nimport PrimitiveCollection from \"./PrimitiveCollection.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport SceneTransforms from \"./SceneTransforms.js\";\nimport SceneTransitioner from \"./SceneTransitioner.js\";\nimport ScreenSpaceCameraController from \"./ScreenSpaceCameraController.js\";\nimport ShadowMap from \"./ShadowMap.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport SunLight from \"./SunLight.js\";\nimport SunPostProcess from \"./SunPostProcess.js\";\nimport TweenCollection from \"./TweenCollection.js\";\nimport View from \"./View.js\";\n\nvar requestRenderAfterFrame = function (scene) {\n  return function () {\n    scene.frameState.afterRender.push(function () {\n      scene.requestRender();\n    });\n  };\n};\n\n/**\n * The container for all 3D graphical objects and state in a Cesium virtual scene.  Generally,\n * a scene is not created directly; instead, it is implicitly created by {@link CesiumWidget}.\n * <p>\n * <em><code>contextOptions</code> parameter details:</em>\n * </p>\n * <p>\n * The default values are:\n * <code>\n * {\n *   webgl : {\n *     alpha : false,\n *     depth : true,\n *     stencil : false,\n *     antialias : true,\n *     powerPreference: 'high-performance',\n *     premultipliedAlpha : true,\n *     preserveDrawingBuffer : false,\n *     failIfMajorPerformanceCaveat : false\n *   },\n *   allowTextureFilterAnisotropic : true\n * }\n * </code>\n * </p>\n * <p>\n * The <code>webgl</code> property corresponds to the {@link http://www.khronos.org/registry/webgl/specs/latest/#5.2|WebGLContextAttributes}\n * object used to create the WebGL context.\n * </p>\n * <p>\n * <code>webgl.alpha</code> defaults to false, which can improve performance compared to the standard WebGL default\n * of true.  If an application needs to composite Cesium above other HTML elements using alpha-blending, set\n * <code>webgl.alpha</code> to true.\n * </p>\n * <p>\n * The other <code>webgl</code> properties match the WebGL defaults for {@link http://www.khronos.org/registry/webgl/specs/latest/#5.2|WebGLContextAttributes}.\n * </p>\n * <p>\n * <code>allowTextureFilterAnisotropic</code> defaults to true, which enables anisotropic texture filtering when the\n * WebGL extension is supported.  Setting this to false will improve performance, but hurt visual quality, especially for horizon views.\n * </p>\n *\n * @alias Scene\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Canvas} options.canvas The HTML canvas element to create the scene for.\n * @param {Object} [options.contextOptions] Context and WebGL creation properties.  See details above.\n * @param {Element} [options.creditContainer] The HTML element in which the credits will be displayed.\n * @param {Element} [options.creditViewport] The HTML element in which to display the credit popup.  If not specified, the viewport will be a added as a sibling of the canvas.\n * @param {MapProjection} [options.mapProjection=new GeographicProjection()] The map projection to use in 2D and Columbus View modes.\n * @param {Boolean} [options.orderIndependentTranslucency=true] If true and the configuration supports it, use order independent translucency.\n * @param {Boolean} [options.scene3DOnly=false] If true, optimizes memory use and performance for 3D mode but disables the ability to use 2D or Columbus View.\n * @param {Number} [options.terrainExaggeration=1.0] A scalar used to exaggerate the terrain. Note that terrain exaggeration will not modify any other primitive as they are positioned relative to the ellipsoid.\n * @param {Boolean} [options.shadows=false] Determines if shadows are cast by light sources.\n * @param {MapMode2D} [options.mapMode2D=MapMode2D.INFINITE_SCROLL] Determines if the 2D map is rotatable or can be scrolled infinitely in the horizontal direction.\n * @param {Boolean} [options.requestRenderMode=false] If true, rendering a frame will only occur when needed as determined by changes within the scene. Enabling improves performance of the application, but requires using {@link Scene#requestRender} to render a new frame explicitly in this mode. This will be necessary in many cases after making changes to the scene in other parts of the API. See {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}.\n * @param {Number} [options.maximumRenderTimeChange=0.0] If requestRenderMode is true, this value defines the maximum change in simulation time allowed before a render is requested. See {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}.\n *\n * @see CesiumWidget\n * @see {@link http://www.khronos.org/registry/webgl/specs/latest/#5.2|WebGLContextAttributes}\n *\n * @exception {DeveloperError} options and options.canvas are required.\n *\n * @example\n * // Create scene without anisotropic texture filtering\n * var scene = new Cesium.Scene({\n *   canvas : canvas,\n *   contextOptions : {\n *     allowTextureFilterAnisotropic : false\n *   }\n * });\n */\nfunction Scene(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var canvas = options.canvas;\n  var creditContainer = options.creditContainer;\n  var creditViewport = options.creditViewport;\n\n  var contextOptions = clone(options.contextOptions);\n  if (!defined(contextOptions)) {\n    contextOptions = {};\n  }\n  if (!defined(contextOptions.webgl)) {\n    contextOptions.webgl = {};\n  }\n  contextOptions.webgl.powerPreference = defaultValue(\n    contextOptions.webgl.powerPreference,\n    \"high-performance\"\n  );\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(canvas)) {\n    throw new DeveloperError(\"options and options.canvas are required.\");\n  }\n  //>>includeEnd('debug');\n  var hasCreditContainer = defined(creditContainer);\n  var context = new Context(canvas, contextOptions);\n  if (!hasCreditContainer) {\n    creditContainer = document.createElement(\"div\");\n    creditContainer.style.position = \"absolute\";\n    creditContainer.style.bottom = \"0\";\n    creditContainer.style[\"text-shadow\"] = \"0 0 2px #000000\";\n    creditContainer.style.color = \"#ffffff\";\n    creditContainer.style[\"font-size\"] = \"10px\";\n    creditContainer.style[\"padding-right\"] = \"5px\";\n    canvas.parentNode.appendChild(creditContainer);\n  }\n  if (!defined(creditViewport)) {\n    creditViewport = canvas.parentNode;\n  }\n\n  this._id = createGuid();\n  this._jobScheduler = new JobScheduler();\n  this._frameState = new FrameState(\n    context,\n    new CreditDisplay(creditContainer, \" â€¢ \", creditViewport),\n    this._jobScheduler\n  );\n  this._frameState.scene3DOnly = defaultValue(options.scene3DOnly, false);\n  this._removeCreditContainer = !hasCreditContainer;\n  this._creditContainer = creditContainer;\n\n  this._canvas = canvas;\n  this._context = context;\n  this._computeEngine = new ComputeEngine(context);\n  this._globe = undefined;\n  this._primitives = new PrimitiveCollection();\n  this._groundPrimitives = new PrimitiveCollection();\n\n  this._logDepthBuffer = context.fragmentDepth;\n  this._logDepthBufferDirty = true;\n\n  this._tweens = new TweenCollection();\n\n  this._shaderFrameCount = 0;\n\n  this._sunPostProcess = undefined;\n\n  this._computeCommandList = [];\n  this._overlayCommandList = [];\n\n  this._useOIT = defaultValue(options.orderIndependentTranslucency, true);\n  this._executeOITFunction = undefined;\n\n  this._depthPlane = new DepthPlane();\n\n  this._clearColorCommand = new ClearCommand({\n    color: new Color(),\n    stencil: 0,\n    owner: this,\n  });\n  this._depthClearCommand = new ClearCommand({\n    depth: 1.0,\n    owner: this,\n  });\n  this._stencilClearCommand = new ClearCommand({\n    stencil: 0,\n  });\n  this._classificationStencilClearCommand = new ClearCommand({\n    stencil: 0,\n    renderState: RenderState.fromCache({\n      stencilMask: StencilConstants.CLASSIFICATION_MASK,\n    }),\n  });\n\n  this._depthOnlyRenderStateCache = {};\n\n  this._transitioner = new SceneTransitioner(this);\n\n  this._preUpdate = new Event();\n  this._postUpdate = new Event();\n\n  this._renderError = new Event();\n  this._preRender = new Event();\n  this._postRender = new Event();\n\n  this._minimumDisableDepthTestDistance = 0.0;\n\n  /**\n   * Exceptions occurring in <code>render</code> are always caught in order to raise the\n   * <code>renderError</code> event.  If this property is true, the error is rethrown\n   * after the event is raised.  If this property is false, the <code>render</code> function\n   * returns normally after raising the event.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  this.rethrowRenderErrors = false;\n\n  /**\n   * Determines whether or not to instantly complete the\n   * scene transition animation on user input.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.completeMorphOnUserInput = true;\n\n  /**\n   * The event fired at the beginning of a scene transition.\n   * @type {Event}\n   * @default Event()\n   */\n  this.morphStart = new Event();\n\n  /**\n   * The event fired at the completion of a scene transition.\n   * @type {Event}\n   * @default Event()\n   */\n  this.morphComplete = new Event();\n\n  /**\n   * The {@link SkyBox} used to draw the stars.\n   *\n   * @type {SkyBox}\n   * @default undefined\n   *\n   * @see Scene#backgroundColor\n   */\n  this.skyBox = undefined;\n\n  /**\n   * The sky atmosphere drawn around the globe.\n   *\n   * @type {SkyAtmosphere}\n   * @default undefined\n   */\n  this.skyAtmosphere = undefined;\n\n  /**\n   * The {@link Sun}.\n   *\n   * @type {Sun}\n   * @default undefined\n   */\n  this.sun = undefined;\n\n  /**\n   * Uses a bloom filter on the sun when enabled.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.sunBloom = true;\n  this._sunBloom = undefined;\n\n  /**\n   * The {@link Moon}\n   *\n   * @type Moon\n   * @default undefined\n   */\n  this.moon = undefined;\n\n  /**\n   * The background color, which is only visible if there is no sky box, i.e., {@link Scene#skyBox} is undefined.\n   *\n   * @type {Color}\n   * @default {@link Color.BLACK}\n   *\n   * @see Scene#skyBox\n   */\n  this.backgroundColor = Color.clone(Color.BLACK);\n\n  this._mode = SceneMode.SCENE3D;\n\n  this._mapProjection = defined(options.mapProjection)\n    ? options.mapProjection\n    : new GeographicProjection();\n\n  /**\n   * The current morph transition time between 2D/Columbus View and 3D,\n   * with 0.0 being 2D or Columbus View and 1.0 being 3D.\n   *\n   * @type {Number}\n   * @default 1.0\n   */\n  this.morphTime = 1.0;\n\n  /**\n   * The far-to-near ratio of the multi-frustum when using a normal depth buffer.\n   * <p>\n   * This value is used to create the near and far values for each frustum of the multi-frustum. It is only used\n   * when {@link Scene#logarithmicDepthBuffer} is <code>false</code>. When <code>logarithmicDepthBuffer</code> is\n   * <code>true</code>, use {@link Scene#logarithmicDepthFarToNearRatio}.\n   * </p>\n   *\n   * @type {Number}\n   * @default 1000.0\n   */\n  this.farToNearRatio = 1000.0;\n\n  /**\n   * The far-to-near ratio of the multi-frustum when using a logarithmic depth buffer.\n   * <p>\n   * This value is used to create the near and far values for each frustum of the multi-frustum. It is only used\n   * when {@link Scene#logarithmicDepthBuffer} is <code>true</code>. When <code>logarithmicDepthBuffer</code> is\n   * <code>false</code>, use {@link Scene#farToNearRatio}.\n   * </p>\n   *\n   * @type {Number}\n   * @default 1e9\n   */\n  this.logarithmicDepthFarToNearRatio = 1e9;\n\n  /**\n   * Determines the uniform depth size in meters of each frustum of the multifrustum in 2D. If a primitive or model close\n   * to the surface shows z-fighting, decreasing this will eliminate the artifact, but decrease performance. On the\n   * other hand, increasing this will increase performance but may cause z-fighting among primitives close to the surface.\n   *\n   * @type {Number}\n   * @default 1.75e6\n   */\n  this.nearToFarDistance2D = 1.75e6;\n\n  /**\n   * This property is for debugging only; it is not for production use.\n   * <p>\n   * A function that determines what commands are executed.  As shown in the examples below,\n   * the function receives the command's <code>owner</code> as an argument, and returns a boolean indicating if the\n   * command should be executed.\n   * </p>\n   * <p>\n   * The default is <code>undefined</code>, indicating that all commands are executed.\n   * </p>\n   *\n   * @type Function\n   *\n   * @default undefined\n   *\n   * @example\n   * // Do not execute any commands.\n   * scene.debugCommandFilter = function(command) {\n   *     return false;\n   * };\n   *\n   * // Execute only the billboard's commands.  That is, only draw the billboard.\n   * var billboards = new Cesium.BillboardCollection();\n   * scene.debugCommandFilter = function(command) {\n   *     return command.owner === billboards;\n   * };\n   */\n  this.debugCommandFilter = undefined;\n\n  /**\n   * This property is for debugging only; it is not for production use.\n   * <p>\n   * When <code>true</code>, commands are randomly shaded.  This is useful\n   * for performance analysis to see what parts of a scene or model are\n   * command-dense and could benefit from batching.\n   * </p>\n   *\n   * @type Boolean\n   *\n   * @default false\n   */\n  this.debugShowCommands = false;\n\n  /**\n   * This property is for debugging only; it is not for production use.\n   * <p>\n   * When <code>true</code>, commands are shaded based on the frustums they\n   * overlap.  Commands in the closest frustum are tinted red, commands in\n   * the next closest are green, and commands in the farthest frustum are\n   * blue.  If a command overlaps more than one frustum, the color components\n   * are combined, e.g., a command overlapping the first two frustums is tinted\n   * yellow.\n   * </p>\n   *\n   * @type Boolean\n   *\n   * @default false\n   */\n  this.debugShowFrustums = false;\n\n  /**\n   * This property is for debugging only; it is not for production use.\n   * <p>\n   * Displays frames per second and time between frames.\n   * </p>\n   *\n   * @type Boolean\n   *\n   * @default false\n   */\n  this.debugShowFramesPerSecond = false;\n\n  /**\n   * This property is for debugging only; it is not for production use.\n   * <p>\n   * Displays depth information for the indicated frustum.\n   * </p>\n   *\n   * @type Boolean\n   *\n   * @default false\n   */\n  this.debugShowGlobeDepth = false;\n\n  /**\n   * This property is for debugging only; it is not for production use.\n   * <p>\n   * Indicates which frustum will have depth information displayed.\n   * </p>\n   *\n   * @type Number\n   *\n   * @default 1\n   */\n  this.debugShowDepthFrustum = 1;\n\n  /**\n   * This property is for debugging only; it is not for production use.\n   * <p>\n   * When <code>true</code>, draws outlines to show the boundaries of the camera frustums\n   * </p>\n   *\n   * @type Boolean\n   *\n   * @default false\n   */\n  this.debugShowFrustumPlanes = false;\n  this._debugShowFrustumPlanes = false;\n  this._debugFrustumPlanes = undefined;\n\n  /**\n   * When <code>true</code>, enables picking using the depth buffer.\n   *\n   * @type Boolean\n   * @default true\n   */\n  this.useDepthPicking = true;\n\n  /**\n   * When <code>true</code>, enables picking translucent geometry using the depth buffer. Note that {@link Scene#useDepthPicking} must also be true for enabling this to work.\n   *\n   * <p>\n   * Render must be called between picks.\n   * <br>There is a decrease in performance when enabled. There are extra draw calls to write depth for\n   * translucent geometry.\n   * </p>\n   *\n   * @example\n   * // picking the position of a translucent primitive\n   * viewer.screenSpaceEventHandler.setInputAction(function onLeftClick(movement) {\n   *      var pickedFeature = viewer.scene.pick(movement.position);\n   *      if (!Cesium.defined(pickedFeature)) {\n   *          // nothing picked\n   *          return;\n   *      }\n   *      viewer.scene.render();\n   *      var worldPosition = viewer.scene.pickPosition(movement.position);\n   * }, Cesium.ScreenSpaceEventType.LEFT_CLICK);\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  this.pickTranslucentDepth = false;\n\n  /**\n   * The time in milliseconds to wait before checking if the camera has not moved and fire the cameraMoveEnd event.\n   * @type {Number}\n   * @default 500.0\n   * @private\n   */\n  this.cameraEventWaitTime = 500.0;\n\n  /**\n   * Blends the atmosphere to geometry far from the camera for horizon views. Allows for additional\n   * performance improvements by rendering less geometry and dispatching less terrain requests.\n   * @type {Fog}\n   */\n  this.fog = new Fog();\n\n  this._shadowMapCamera = new Camera(this);\n\n  /**\n   * The shadow map for the scene's light source. When enabled, models, primitives, and the globe may cast and receive shadows.\n   * @type {ShadowMap}\n   */\n  this.shadowMap = new ShadowMap({\n    context: context,\n    lightCamera: this._shadowMapCamera,\n    enabled: defaultValue(options.shadows, false),\n  });\n\n  /**\n   * When <code>false</code>, 3D Tiles will render normally. When <code>true</code>, classified 3D Tile geometry will render normally and\n   * unclassified 3D Tile geometry will render with the color multiplied by {@link Scene#invertClassificationColor}.\n   * @type {Boolean}\n   * @default false\n   */\n  this.invertClassification = false;\n\n  /**\n   * The highlight color of unclassified 3D Tile geometry when {@link Scene#invertClassification} is <code>true</code>.\n   * <p>When the color's alpha is less than 1.0, the unclassified portions of the 3D Tiles will not blend correctly with the classified positions of the 3D Tiles.</p>\n   * <p>Also, when the color's alpha is less than 1.0, the WEBGL_depth_texture and EXT_frag_depth WebGL extensions must be supported.</p>\n   * @type {Color}\n   * @default Color.WHITE\n   */\n  this.invertClassificationColor = Color.clone(Color.WHITE);\n\n  this._actualInvertClassificationColor = Color.clone(\n    this._invertClassificationColor\n  );\n  this._invertClassification = new InvertClassification();\n\n  /**\n   * The focal length for use when with cardboard or WebVR.\n   * @type {Number}\n   */\n  this.focalLength = undefined;\n\n  /**\n   * The eye separation distance in meters for use with cardboard or WebVR.\n   * @type {Number}\n   */\n  this.eyeSeparation = undefined;\n\n  /**\n   * Post processing effects applied to the final render.\n   * @type {PostProcessStageCollection}\n   */\n  this.postProcessStages = new PostProcessStageCollection();\n\n  this._brdfLutGenerator = new BrdfLutGenerator();\n\n  this._terrainExaggeration = defaultValue(options.terrainExaggeration, 1.0);\n\n  this._performanceDisplay = undefined;\n  this._debugVolume = undefined;\n\n  this._screenSpaceCameraController = new ScreenSpaceCameraController(this);\n  this._cameraUnderground = false;\n  this._mapMode2D = defaultValue(options.mapMode2D, MapMode2D.INFINITE_SCROLL);\n\n  // Keeps track of the state of a frame. FrameState is the state across\n  // the primitives of the scene. This state is for internally keeping track\n  // of celestial and environment effects that need to be updated/rendered in\n  // a certain order as well as updating/tracking framebuffer usage.\n  this._environmentState = {\n    skyBoxCommand: undefined,\n    skyAtmosphereCommand: undefined,\n    sunDrawCommand: undefined,\n    sunComputeCommand: undefined,\n    moonCommand: undefined,\n\n    isSunVisible: false,\n    isMoonVisible: false,\n    isReadyForAtmosphere: false,\n    isSkyAtmosphereVisible: false,\n\n    clearGlobeDepth: false,\n    useDepthPlane: false,\n    renderTranslucentDepthForPick: false,\n\n    originalFramebuffer: undefined,\n    useGlobeDepthFramebuffer: false,\n    separatePrimitiveFramebuffer: false,\n    useOIT: false,\n    useInvertClassification: false,\n    usePostProcess: false,\n    usePostProcessSelected: false,\n    useWebVR: false,\n  };\n\n  this._useWebVR = false;\n  this._cameraVR = undefined;\n  this._aspectRatioVR = undefined;\n\n  /**\n   * When <code>true</code>, rendering a frame will only occur when needed as determined by changes within the scene.\n   * Enabling improves performance of the application, but requires using {@link Scene#requestRender}\n   * to render a new frame explicitly in this mode. This will be necessary in many cases after making changes\n   * to the scene in other parts of the API.\n   *\n   * @see {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}\n   * @see Scene#maximumRenderTimeChange\n   * @see Scene#requestRender\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  this.requestRenderMode = defaultValue(options.requestRenderMode, false);\n  this._renderRequested = true;\n\n  /**\n   * If {@link Scene#requestRenderMode} is <code>true</code>, this value defines the maximum change in\n   * simulation time allowed before a render is requested. Lower values increase the number of frames rendered\n   * and higher values decrease the number of frames rendered. If <code>undefined</code>, changes to\n   * the simulation time will never request a render.\n   * This value impacts the rate of rendering for changes in the scene like lighting, entity property updates,\n   * and animations.\n   *\n   * @see {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}\n   * @see Scene#requestRenderMode\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n  this.maximumRenderTimeChange = defaultValue(\n    options.maximumRenderTimeChange,\n    0.0\n  );\n  this._lastRenderTime = undefined;\n  this._frameRateMonitor = undefined;\n\n  this._removeRequestListenerCallback = RequestScheduler.requestCompletedEvent.addEventListener(\n    requestRenderAfterFrame(this)\n  );\n  this._removeTaskProcessorListenerCallback = TaskProcessor.taskCompletedEvent.addEventListener(\n    requestRenderAfterFrame(this)\n  );\n  this._removeGlobeCallbacks = [];\n\n  var viewport = new BoundingRectangle(\n    0,\n    0,\n    context.drawingBufferWidth,\n    context.drawingBufferHeight\n  );\n  var camera = new Camera(this);\n\n  if (this._logDepthBuffer) {\n    camera.frustum.near = 0.1;\n    camera.frustum.far = 10000000000.0;\n  }\n\n  /**\n   * The camera view for the scene camera flight destination. Used for preloading flight destination tiles.\n   * @type {Camera}\n   * @private\n   */\n  this.preloadFlightCamera = new Camera(this);\n\n  /**\n   * The culling volume for the scene camera flight destination. Used for preloading flight destination tiles.\n   * @type {CullingVolume}\n   * @private\n   */\n  this.preloadFlightCullingVolume = undefined;\n\n  this._picking = new Picking(this);\n  this._defaultView = new View(this, camera, viewport);\n  this._view = this._defaultView;\n\n  this._hdr = undefined;\n  this._hdrDirty = undefined;\n  this.highDynamicRange = false;\n  this.gamma = 2.2;\n\n  /**\n   * The spherical harmonic coefficients for image-based lighting of PBR models.\n   * @type {Cartesian3[]}\n   */\n  this.sphericalHarmonicCoefficients = undefined;\n\n  /**\n   * The url to the KTX file containing the specular environment map and convoluted mipmaps for image-based lighting of PBR models.\n   * @type {String}\n   */\n  this.specularEnvironmentMaps = undefined;\n  this._specularEnvironmentMapAtlas = undefined;\n\n  /**\n   * The light source for shading. Defaults to a directional light from the Sun.\n   * @type {Light}\n   */\n  this.light = new SunLight();\n\n  // Give frameState, camera, and screen space camera controller initial state before rendering\n  updateFrameNumber(this, 0.0, JulianDate.now());\n  this.updateFrameState();\n  this.initializeFrame();\n}\n\nfunction updateGlobeListeners(scene, globe) {\n  for (var i = 0; i < scene._removeGlobeCallbacks.length; ++i) {\n    scene._removeGlobeCallbacks[i]();\n  }\n  scene._removeGlobeCallbacks.length = 0;\n\n  var removeGlobeCallbacks = [];\n  if (defined(globe)) {\n    removeGlobeCallbacks.push(\n      globe.imageryLayersUpdatedEvent.addEventListener(\n        requestRenderAfterFrame(scene)\n      )\n    );\n    removeGlobeCallbacks.push(\n      globe.terrainProviderChanged.addEventListener(\n        requestRenderAfterFrame(scene)\n      )\n    );\n  }\n  scene._removeGlobeCallbacks = removeGlobeCallbacks;\n}\n\nObject.defineProperties(Scene.prototype, {\n  /**\n   * Gets the canvas element to which this scene is bound.\n   * @memberof Scene.prototype\n   *\n   * @type {Canvas}\n   * @readonly\n   */\n  canvas: {\n    get: function () {\n      return this._canvas;\n    },\n  },\n\n  /**\n   * The drawingBufferHeight of the underlying GL context.\n   * @memberof Scene.prototype\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @see {@link https://www.khronos.org/registry/webgl/specs/1.0/#DOM-WebGLRenderingContext-drawingBufferHeight|drawingBufferHeight}\n   */\n  drawingBufferHeight: {\n    get: function () {\n      return this._context.drawingBufferHeight;\n    },\n  },\n\n  /**\n   * The drawingBufferHeight of the underlying GL context.\n   * @memberof Scene.prototype\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @see {@link https://www.khronos.org/registry/webgl/specs/1.0/#DOM-WebGLRenderingContext-drawingBufferHeight|drawingBufferHeight}\n   */\n  drawingBufferWidth: {\n    get: function () {\n      return this._context.drawingBufferWidth;\n    },\n  },\n\n  /**\n   * The maximum aliased line width, in pixels, supported by this WebGL implementation.  It will be at least one.\n   * @memberof Scene.prototype\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>ALIASED_LINE_WIDTH_RANGE</code>.\n   */\n  maximumAliasedLineWidth: {\n    get: function () {\n      return ContextLimits.maximumAliasedLineWidth;\n    },\n  },\n\n  /**\n   * The maximum length in pixels of one edge of a cube map, supported by this WebGL implementation.  It will be at least 16.\n   * @memberof Scene.prototype\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>GL_MAX_CUBE_MAP_TEXTURE_SIZE</code>.\n   */\n  maximumCubeMapSize: {\n    get: function () {\n      return ContextLimits.maximumCubeMapSize;\n    },\n  },\n\n  /**\n   * Returns <code>true</code> if the {@link Scene#pickPosition} function is supported.\n   * @memberof Scene.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @see Scene#pickPosition\n   */\n  pickPositionSupported: {\n    get: function () {\n      return this._context.depthTexture;\n    },\n  },\n\n  /**\n   * Returns <code>true</code> if the {@link Scene#sampleHeight} and {@link Scene#sampleHeightMostDetailed} functions are supported.\n   * @memberof Scene.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @see Scene#sampleHeight\n   * @see Scene#sampleHeightMostDetailed\n   */\n  sampleHeightSupported: {\n    get: function () {\n      return this._context.depthTexture;\n    },\n  },\n\n  /**\n   * Returns <code>true</code> if the {@link Scene#clampToHeight} and {@link Scene#clampToHeightMostDetailed} functions are supported.\n   * @memberof Scene.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @see Scene#clampToHeight\n   * @see Scene#clampToHeightMostDetailed\n   */\n  clampToHeightSupported: {\n    get: function () {\n      return this._context.depthTexture;\n    },\n  },\n\n  /**\n   * Returns <code>true</code> if the {@link Scene#invertClassification} is supported.\n   * @memberof Scene.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @see Scene#invertClassification\n   */\n  invertClassificationSupported: {\n    get: function () {\n      return this._context.depthTexture;\n    },\n  },\n\n  /**\n   * Returns <code>true</code> if specular environment maps are supported.\n   * @memberof Scene.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @see Scene#specularEnvironmentMaps\n   */\n  specularEnvironmentMapsSupported: {\n    get: function () {\n      return OctahedralProjectedCubeMap.isSupported(this._context);\n    },\n  },\n\n  /**\n   * Gets or sets the depth-test ellipsoid.\n   * @memberof Scene.prototype\n   *\n   * @type {Globe}\n   */\n  globe: {\n    get: function () {\n      return this._globe;\n    },\n\n    set: function (globe) {\n      this._globe = this._globe && this._globe.destroy();\n      this._globe = globe;\n\n      updateGlobeListeners(this, globe);\n    },\n  },\n\n  /**\n   * Gets the collection of primitives.\n   * @memberof Scene.prototype\n   *\n   * @type {PrimitiveCollection}\n   * @readonly\n   */\n  primitives: {\n    get: function () {\n      return this._primitives;\n    },\n  },\n\n  /**\n   * Gets the collection of ground primitives.\n   * @memberof Scene.prototype\n   *\n   * @type {PrimitiveCollection}\n   * @readonly\n   */\n  groundPrimitives: {\n    get: function () {\n      return this._groundPrimitives;\n    },\n  },\n\n  /**\n   * Gets or sets the camera.\n   * @memberof Scene.prototype\n   *\n   * @type {Camera}\n   * @readonly\n   */\n  camera: {\n    get: function () {\n      return this._view.camera;\n    },\n    set: function (camera) {\n      // For internal use only. Documentation is still @readonly.\n      this._view.camera = camera;\n    },\n  },\n\n  /**\n   * Gets or sets the view.\n   * @memberof Scene.prototype\n   *\n   * @type {View}\n   * @readonly\n   *\n   * @private\n   */\n  view: {\n    get: function () {\n      return this._view;\n    },\n    set: function (view) {\n      // For internal use only. Documentation is still @readonly.\n      this._view = view;\n    },\n  },\n\n  /**\n   * Gets the default view.\n   * @memberof Scene.prototype\n   *\n   * @type {View}\n   * @readonly\n   *\n   * @private\n   */\n  defaultView: {\n    get: function () {\n      return this._defaultView;\n    },\n  },\n\n  /**\n   * Gets picking functions and state\n   * @memberof Scene.prototype\n   *\n   * @type {Picking}\n   * @readonly\n   *\n   * @private\n   */\n  picking: {\n    get: function () {\n      return this._picking;\n    },\n  },\n\n  /**\n   * Gets the controller for camera input handling.\n   * @memberof Scene.prototype\n   *\n   * @type {ScreenSpaceCameraController}\n   * @readonly\n   */\n  screenSpaceCameraController: {\n    get: function () {\n      return this._screenSpaceCameraController;\n    },\n  },\n\n  /**\n   * Get the map projection to use in 2D and Columbus View modes.\n   * @memberof Scene.prototype\n   *\n   * @type {MapProjection}\n   * @readonly\n   *\n   * @default new GeographicProjection()\n   */\n  mapProjection: {\n    get: function () {\n      return this._mapProjection;\n    },\n  },\n\n  /**\n   * Gets the job scheduler\n   * @memberof Scene.prototype\n   * @type {JobScheduler}\n   * @readonly\n   *\n   * @private\n   */\n  jobScheduler: {\n    get: function () {\n      return this._jobScheduler;\n    },\n  },\n\n  /**\n   * Gets state information about the current scene. If called outside of a primitive's <code>update</code>\n   * function, the previous frame's state is returned.\n   * @memberof Scene.prototype\n   *\n   * @type {FrameState}\n   * @readonly\n   *\n   * @private\n   */\n  frameState: {\n    get: function () {\n      return this._frameState;\n    },\n  },\n\n  /**\n   * Gets the environment state.\n   * @memberof Scene.prototype\n   *\n   * @type {EnvironmentState}\n   * @readonly\n   *\n   * @private\n   */\n  environmentState: {\n    get: function () {\n      return this._environmentState;\n    },\n  },\n\n  /**\n   * Gets the collection of tweens taking place in the scene.\n   * @memberof Scene.prototype\n   *\n   * @type {TweenCollection}\n   * @readonly\n   *\n   * @private\n   */\n  tweens: {\n    get: function () {\n      return this._tweens;\n    },\n  },\n\n  /**\n   * Gets the collection of image layers that will be rendered on the globe.\n   * @memberof Scene.prototype\n   *\n   * @type {ImageryLayerCollection}\n   * @readonly\n   */\n  imageryLayers: {\n    get: function () {\n      if (!defined(this.globe)) {\n        return undefined;\n      }\n\n      return this.globe.imageryLayers;\n    },\n  },\n\n  /**\n   * The terrain provider providing surface geometry for the globe.\n   * @memberof Scene.prototype\n   *\n   * @type {TerrainProvider}\n   */\n  terrainProvider: {\n    get: function () {\n      if (!defined(this.globe)) {\n        return undefined;\n      }\n\n      return this.globe.terrainProvider;\n    },\n    set: function (terrainProvider) {\n      if (defined(this.globe)) {\n        this.globe.terrainProvider = terrainProvider;\n      }\n    },\n  },\n\n  /**\n   * Gets an event that's raised when the terrain provider is changed\n   * @memberof Scene.prototype\n   *\n   * @type {Event}\n   * @readonly\n   */\n  terrainProviderChanged: {\n    get: function () {\n      if (!defined(this.globe)) {\n        return undefined;\n      }\n\n      return this.globe.terrainProviderChanged;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised before the scene is updated or rendered.  Subscribers to the event\n   * receive the Scene instance as the first parameter and the current time as the second parameter.\n   * @memberof Scene.prototype\n   *\n   * @see {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}\n   * @see Scene#postUpdate\n   * @see Scene#preRender\n   * @see Scene#postRender\n   *\n   * @type {Event}\n   * @readonly\n   */\n  preUpdate: {\n    get: function () {\n      return this._preUpdate;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised immediately after the scene is updated and before the scene is rendered.\n   * Subscribers to the event receive the Scene instance as the first parameter and the current time as the second\n   * parameter.\n   * @memberof Scene.prototype\n   *\n   * @see {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}\n   * @see Scene#preUpdate\n   * @see Scene#preRender\n   * @see Scene#postRender\n   *\n   * @type {Event}\n   * @readonly\n   */\n  postUpdate: {\n    get: function () {\n      return this._postUpdate;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised when an error is thrown inside the <code>render</code> function.\n   * The Scene instance and the thrown error are the only two parameters passed to the event handler.\n   * By default, errors are not rethrown after this event is raised, but that can be changed by setting\n   * the <code>rethrowRenderErrors</code> property.\n   * @memberof Scene.prototype\n   *\n   * @type {Event}\n   * @readonly\n   */\n  renderError: {\n    get: function () {\n      return this._renderError;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised after the scene is updated and immediately before the scene is rendered.\n   * Subscribers to the event receive the Scene instance as the first parameter and the current time as the second\n   * parameter.\n   * @memberof Scene.prototype\n   *\n   * @see {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}\n   * @see Scene#preUpdate\n   * @see Scene#postUpdate\n   * @see Scene#postRender\n   *\n   * @type {Event}\n   * @readonly\n   */\n  preRender: {\n    get: function () {\n      return this._preRender;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised immediately after the scene is rendered.  Subscribers to the event\n   * receive the Scene instance as the first parameter and the current time as the second parameter.\n   * @memberof Scene.prototype\n   *\n   * @see {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}\n   * @see Scene#preUpdate\n   * @see Scene#postUpdate\n   * @see Scene#postRender\n   *\n   * @type {Event}\n   * @readonly\n   */\n  postRender: {\n    get: function () {\n      return this._postRender;\n    },\n  },\n\n  /**\n   * Gets the simulation time when the scene was last rendered. Returns undefined if the scene has not yet been\n   * rendered.\n   * @memberof Scene.prototype\n   *\n   * @type {JulianDate}\n   * @readonly\n   */\n  lastRenderTime: {\n    get: function () {\n      return this._lastRenderTime;\n    },\n  },\n\n  /**\n   * @memberof Scene.prototype\n   * @private\n   * @readonly\n   */\n  context: {\n    get: function () {\n      return this._context;\n    },\n  },\n\n  /**\n   * This property is for debugging only; it is not for production use.\n   * <p>\n   * When {@link Scene.debugShowFrustums} is <code>true</code>, this contains\n   * properties with statistics about the number of command execute per frustum.\n   * <code>totalCommands</code> is the total number of commands executed, ignoring\n   * overlap. <code>commandsInFrustums</code> is an array with the number of times\n   * commands are executed redundantly, e.g., how many commands overlap two or\n   * three frustums.\n   * </p>\n   *\n   * @memberof Scene.prototype\n   *\n   * @type {Object}\n   * @readonly\n   *\n   * @default undefined\n   */\n  debugFrustumStatistics: {\n    get: function () {\n      return this._view.debugFrustumStatistics;\n    },\n  },\n\n  /**\n   * Gets whether or not the scene is optimized for 3D only viewing.\n   * @memberof Scene.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  scene3DOnly: {\n    get: function () {\n      return this._frameState.scene3DOnly;\n    },\n  },\n\n  /**\n   * Gets whether or not the scene has order independent translucency enabled.\n   * Note that this only reflects the original construction option, and there are\n   * other factors that could prevent OIT from functioning on a given system configuration.\n   * @memberof Scene.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  orderIndependentTranslucency: {\n    get: function () {\n      return this._useOIT;\n    },\n  },\n\n  /**\n   * Gets the unique identifier for this scene.\n   * @memberof Scene.prototype\n   * @type {String}\n   * @readonly\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n\n  /**\n   * Gets or sets the current mode of the scene.\n   * @memberof Scene.prototype\n   * @type {SceneMode}\n   * @default {@link SceneMode.SCENE3D}\n   */\n  mode: {\n    get: function () {\n      return this._mode;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (this.scene3DOnly && value !== SceneMode.SCENE3D) {\n        throw new DeveloperError(\n          \"Only SceneMode.SCENE3D is valid when scene3DOnly is true.\"\n        );\n      }\n      //>>includeEnd('debug');\n      if (value === SceneMode.SCENE2D) {\n        this.morphTo2D(0);\n      } else if (value === SceneMode.SCENE3D) {\n        this.morphTo3D(0);\n      } else if (value === SceneMode.COLUMBUS_VIEW) {\n        this.morphToColumbusView(0);\n        //>>includeStart('debug', pragmas.debug);\n      } else {\n        throw new DeveloperError(\n          \"value must be a valid SceneMode enumeration.\"\n        );\n        //>>includeEnd('debug');\n      }\n      this._mode = value;\n    },\n  },\n\n  /**\n   * Gets the number of frustums used in the last frame.\n   * @memberof Scene.prototype\n   * @type {FrustumCommands[]}\n   *\n   * @private\n   */\n  frustumCommandsList: {\n    get: function () {\n      return this._view.frustumCommandsList;\n    },\n  },\n\n  /**\n   * Gets the number of frustums used in the last frame.\n   * @memberof Scene.prototype\n   * @type {Number}\n   *\n   * @private\n   */\n  numberOfFrustums: {\n    get: function () {\n      return this._view.frustumCommandsList.length;\n    },\n  },\n\n  /**\n   * Gets the scalar used to exaggerate the terrain.\n   * @memberof Scene.prototype\n   * @type {Number}\n   * @readonly\n   */\n  terrainExaggeration: {\n    get: function () {\n      return this._terrainExaggeration;\n    },\n  },\n\n  /**\n   * When <code>true</code>, splits the scene into two viewports with steroscopic views for the left and right eyes.\n   * Used for cardboard and WebVR.\n   * @memberof Scene.prototype\n   * @type {Boolean}\n   * @default false\n   */\n  useWebVR: {\n    get: function () {\n      return this._useWebVR;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (this.camera.frustum instanceof OrthographicFrustum) {\n        throw new DeveloperError(\n          \"VR is unsupported with an orthographic projection.\"\n        );\n      }\n      //>>includeEnd('debug');\n      this._useWebVR = value;\n      if (this._useWebVR) {\n        this._frameState.creditDisplay.container.style.visibility = \"hidden\";\n        this._cameraVR = new Camera(this);\n        if (!defined(this._deviceOrientationCameraController)) {\n          this._deviceOrientationCameraController = new DeviceOrientationCameraController(\n            this\n          );\n        }\n\n        this._aspectRatioVR = this.camera.frustum.aspectRatio;\n      } else {\n        this._frameState.creditDisplay.container.style.visibility = \"visible\";\n        this._cameraVR = undefined;\n        this._deviceOrientationCameraController =\n          this._deviceOrientationCameraController &&\n          !this._deviceOrientationCameraController.isDestroyed() &&\n          this._deviceOrientationCameraController.destroy();\n\n        this.camera.frustum.aspectRatio = this._aspectRatioVR;\n        this.camera.frustum.xOffset = 0.0;\n      }\n    },\n  },\n\n  /**\n   * Determines if the 2D map is rotatable or can be scrolled infinitely in the horizontal direction.\n   * @memberof Scene.prototype\n   * @type {MapMode2D}\n   * @readonly\n   */\n  mapMode2D: {\n    get: function () {\n      return this._mapMode2D;\n    },\n  },\n\n  /**\n   * Gets or sets the position of the Imagery splitter within the viewport.  Valid values are between 0.0 and 1.0.\n   * @memberof Scene.prototype\n   *\n   * @type {Number}\n   */\n  imagerySplitPosition: {\n    get: function () {\n      return this._frameState.imagerySplitPosition;\n    },\n    set: function (value) {\n      this._frameState.imagerySplitPosition = value;\n    },\n  },\n\n  /**\n   * The distance from the camera at which to disable the depth test of billboards, labels and points\n   * to, for example, prevent clipping against terrain. When set to zero, the depth test should always\n   * be applied. When less than zero, the depth test should never be applied. Setting the disableDepthTestDistance\n   * property of a billboard, label or point will override this value.\n   * @memberof Scene.prototype\n   * @type {Number}\n   * @default 0.0\n   */\n  minimumDisableDepthTestDistance: {\n    get: function () {\n      return this._minimumDisableDepthTestDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value) || value < 0.0) {\n        throw new DeveloperError(\n          \"minimumDisableDepthTestDistance must be greater than or equal to 0.0.\"\n        );\n      }\n      //>>includeEnd('debug');\n      this._minimumDisableDepthTestDistance = value;\n    },\n  },\n\n  /**\n   * Whether or not to use a logarithmic depth buffer. Enabling this option will allow for less frustums in the multi-frustum,\n   * increasing performance. This property relies on fragmentDepth being supported.\n   * @memberof Scene.prototype\n   * @type {Boolean}\n   */\n  logarithmicDepthBuffer: {\n    get: function () {\n      return this._logDepthBuffer;\n    },\n    set: function (value) {\n      value = this._context.fragmentDepth && value;\n      if (this._logDepthBuffer !== value) {\n        this._logDepthBuffer = value;\n        this._logDepthBufferDirty = true;\n        this._defaultView.updateFrustums = true;\n      }\n    },\n  },\n\n  /**\n   * The value used for gamma correction. This is only used when rendering with high dynamic range.\n   * @memberof Scene.prototype\n   * @type {Number}\n   * @default 2.2\n   */\n  gamma: {\n    get: function () {\n      return this._context.uniformState.gamma;\n    },\n    set: function (value) {\n      this._context.uniformState.gamma = value;\n    },\n  },\n\n  /**\n   * Whether or not to use high dynamic range rendering.\n   * @memberof Scene.prototype\n   * @type {Boolean}\n   * @default true\n   */\n  highDynamicRange: {\n    get: function () {\n      return this._hdr;\n    },\n    set: function (value) {\n      var context = this._context;\n      var hdr =\n        value &&\n        context.depthTexture &&\n        (context.colorBufferFloat || context.colorBufferHalfFloat);\n      this._hdrDirty = hdr !== this._hdr;\n      this._hdr = hdr;\n    },\n  },\n\n  /**\n   * Whether or not high dynamic range rendering is supported.\n   * @memberof Scene.prototype\n   * @type {Boolean}\n   * @readonly\n   * @default true\n   */\n  highDynamicRangeSupported: {\n    get: function () {\n      var context = this._context;\n      return (\n        context.depthTexture &&\n        (context.colorBufferFloat || context.colorBufferHalfFloat)\n      );\n    },\n  },\n\n  /**\n   * Whether or not the camera is underneath the globe.\n   * @memberof Scene.prototype\n   * @type {Boolean}\n   * @readonly\n   * @default false\n   */\n  cameraUnderground: {\n    get: function () {\n      return this._cameraUnderground;\n    },\n  },\n\n  /**\n   * Ratio between a pixel and a density-independent pixel. Provides a standard unit of\n   * measure for real pixel measurements appropriate to a particular device.\n   *\n   * @memberof Scene.prototype\n   * @type {Number}\n   * @default 1.0\n   * @private\n   */\n  pixelRatio: {\n    get: function () {\n      return this._frameState.pixelRatio;\n    },\n    set: function (value) {\n      this._frameState.pixelRatio = value;\n    },\n  },\n\n  /**\n   * @private\n   */\n  opaqueFrustumNearOffset: {\n    get: function () {\n      return 0.9999;\n    },\n  },\n});\n\n/**\n * Determines if a compressed texture format is supported.\n * @param {String} format The texture format. May be the name of the format or the WebGL extension name, e.g. s3tc or WEBGL_compressed_texture_s3tc.\n * @return {boolean} Whether or not the format is supported.\n */\nScene.prototype.getCompressedTextureFormatSupported = function (format) {\n  var context = this.context;\n  return (\n    ((format === \"WEBGL_compressed_texture_s3tc\" || format === \"s3tc\") &&\n      context.s3tc) ||\n    ((format === \"WEBGL_compressed_texture_pvrtc\" || format === \"pvrtc\") &&\n      context.pvrtc) ||\n    ((format === \"WEBGL_compressed_texture_etc1\" || format === \"etc1\") &&\n      context.etc1)\n  );\n};\n\nfunction updateDerivedCommands(scene, command, shadowsDirty) {\n  var frameState = scene._frameState;\n  var context = scene._context;\n  var oit = scene._view.oit;\n  var lightShadowMaps = frameState.shadowState.lightShadowMaps;\n  var lightShadowsEnabled = frameState.shadowState.lightShadowsEnabled;\n\n  var derivedCommands = command.derivedCommands;\n\n  if (defined(command.pickId)) {\n    derivedCommands.picking = DerivedCommand.createPickDerivedCommand(\n      scene,\n      command,\n      context,\n      derivedCommands.picking\n    );\n  }\n\n  if (!command.pickOnly) {\n    derivedCommands.depth = DerivedCommand.createDepthOnlyDerivedCommand(\n      scene,\n      command,\n      context,\n      derivedCommands.depth\n    );\n  }\n\n  derivedCommands.originalCommand = command;\n\n  if (scene._hdr) {\n    derivedCommands.hdr = DerivedCommand.createHdrCommand(\n      command,\n      context,\n      derivedCommands.hdr\n    );\n    command = derivedCommands.hdr.command;\n    derivedCommands = command.derivedCommands;\n  }\n\n  if (lightShadowsEnabled && command.receiveShadows) {\n    derivedCommands.shadows = ShadowMap.createReceiveDerivedCommand(\n      lightShadowMaps,\n      command,\n      shadowsDirty,\n      context,\n      derivedCommands.shadows\n    );\n  }\n\n  if (command.pass === Pass.TRANSLUCENT && defined(oit) && oit.isSupported()) {\n    if (lightShadowsEnabled && command.receiveShadows) {\n      derivedCommands.oit = defined(derivedCommands.oit)\n        ? derivedCommands.oit\n        : {};\n      derivedCommands.oit.shadows = oit.createDerivedCommands(\n        derivedCommands.shadows.receiveCommand,\n        context,\n        derivedCommands.oit.shadows\n      );\n    } else {\n      derivedCommands.oit = oit.createDerivedCommands(\n        command,\n        context,\n        derivedCommands.oit\n      );\n    }\n  }\n}\n\n/**\n * @private\n */\nScene.prototype.updateDerivedCommands = function (command) {\n  if (!defined(command.derivedCommands)) {\n    // Is not a DrawCommand\n    return;\n  }\n\n  var frameState = this._frameState;\n  var context = this._context;\n\n  // Update derived commands when any shadow maps become dirty\n  var shadowsDirty = false;\n  var lastDirtyTime = frameState.shadowState.lastDirtyTime;\n  if (command.lastDirtyTime !== lastDirtyTime) {\n    command.lastDirtyTime = lastDirtyTime;\n    command.dirty = true;\n    shadowsDirty = true;\n  }\n\n  var useLogDepth = frameState.useLogDepth;\n  var useHdr = this._hdr;\n  var derivedCommands = command.derivedCommands;\n  var hasLogDepthDerivedCommands = defined(derivedCommands.logDepth);\n  var hasHdrCommands = defined(derivedCommands.hdr);\n  var hasDerivedCommands = defined(derivedCommands.originalCommand);\n  var needsLogDepthDerivedCommands = useLogDepth && !hasLogDepthDerivedCommands;\n  var needsHdrCommands = useHdr && !hasHdrCommands;\n  var needsDerivedCommands = (!useLogDepth || !useHdr) && !hasDerivedCommands;\n  command.dirty =\n    command.dirty ||\n    needsLogDepthDerivedCommands ||\n    needsHdrCommands ||\n    needsDerivedCommands;\n\n  if (command.dirty) {\n    command.dirty = false;\n\n    var shadowMaps = frameState.shadowState.shadowMaps;\n    var shadowsEnabled = frameState.shadowState.shadowsEnabled;\n    if (shadowsEnabled && command.castShadows) {\n      derivedCommands.shadows = ShadowMap.createCastDerivedCommand(\n        shadowMaps,\n        command,\n        shadowsDirty,\n        context,\n        derivedCommands.shadows\n      );\n    }\n\n    if (hasLogDepthDerivedCommands || needsLogDepthDerivedCommands) {\n      derivedCommands.logDepth = DerivedCommand.createLogDepthCommand(\n        command,\n        context,\n        derivedCommands.logDepth\n      );\n      updateDerivedCommands(\n        this,\n        derivedCommands.logDepth.command,\n        shadowsDirty\n      );\n    }\n    if (hasDerivedCommands || needsDerivedCommands) {\n      updateDerivedCommands(this, command, shadowsDirty);\n    }\n  }\n};\n\nvar renderTilesetPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.RENDER,\n});\n\nvar preloadTilesetPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.PRELOAD,\n});\n\nvar preloadFlightTilesetPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.PRELOAD_FLIGHT,\n});\n\nvar requestRenderModeDeferCheckPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.REQUEST_RENDER_MODE_DEFER_CHECK,\n});\n\nvar scratchOccluderBoundingSphere = new BoundingSphere();\nvar scratchOccluder;\n\nfunction getOccluder(scene) {\n  // TODO: The occluder is the top-level globe. When we add\n  //       support for multiple central bodies, this should be the closest one.\n  var globe = scene.globe;\n  if (\n    scene._mode === SceneMode.SCENE3D &&\n    defined(globe) &&\n    globe.show &&\n    !scene._cameraUnderground\n  ) {\n    var ellipsoid = globe.ellipsoid;\n    var minimumTerrainHeight = scene.frameState.minimumTerrainHeight;\n    scratchOccluderBoundingSphere.radius =\n      ellipsoid.minimumRadius + minimumTerrainHeight;\n    scratchOccluder = Occluder.fromBoundingSphere(\n      scratchOccluderBoundingSphere,\n      scene.camera.positionWC,\n      scratchOccluder\n    );\n    return scratchOccluder;\n  }\n\n  return undefined;\n}\n\n/**\n * @private\n */\nScene.prototype.clearPasses = function (passes) {\n  passes.render = false;\n  passes.pick = false;\n  passes.depth = false;\n  passes.postProcess = false;\n  passes.offscreen = false;\n};\n\nfunction updateFrameNumber(scene, frameNumber, time) {\n  var frameState = scene._frameState;\n  frameState.frameNumber = frameNumber;\n  frameState.time = JulianDate.clone(time, frameState.time);\n}\n\n/**\n * @private\n */\nScene.prototype.updateFrameState = function () {\n  var camera = this.camera;\n\n  var frameState = this._frameState;\n  frameState.commandList.length = 0;\n  frameState.shadowMaps.length = 0;\n  frameState.brdfLutGenerator = this._brdfLutGenerator;\n  frameState.environmentMap = this.skyBox && this.skyBox._cubeMap;\n  frameState.mode = this._mode;\n  frameState.morphTime = this.morphTime;\n  frameState.mapProjection = this.mapProjection;\n  frameState.camera = camera;\n  frameState.cullingVolume = camera.frustum.computeCullingVolume(\n    camera.positionWC,\n    camera.directionWC,\n    camera.upWC\n  );\n  frameState.occluder = getOccluder(this);\n  frameState.terrainExaggeration = this._terrainExaggeration;\n  frameState.minimumTerrainHeight = 0.0;\n  frameState.minimumDisableDepthTestDistance = this._minimumDisableDepthTestDistance;\n  frameState.invertClassification = this.invertClassification;\n  frameState.useLogDepth =\n    this._logDepthBuffer &&\n    !(\n      this.camera.frustum instanceof OrthographicFrustum ||\n      this.camera.frustum instanceof OrthographicOffCenterFrustum\n    );\n  frameState.light = this.light;\n  frameState.cameraUnderground = this._cameraUnderground;\n\n  if (\n    defined(this._specularEnvironmentMapAtlas) &&\n    this._specularEnvironmentMapAtlas.ready\n  ) {\n    frameState.specularEnvironmentMaps = this._specularEnvironmentMapAtlas.texture;\n    frameState.specularEnvironmentMapsMaximumLOD = this._specularEnvironmentMapAtlas.maximumMipmapLevel;\n  } else {\n    frameState.specularEnvironmentMaps = undefined;\n    frameState.specularEnvironmentMapsMaximumLOD = undefined;\n  }\n\n  frameState.sphericalHarmonicCoefficients = this.sphericalHarmonicCoefficients;\n\n  this._actualInvertClassificationColor = Color.clone(\n    this.invertClassificationColor,\n    this._actualInvertClassificationColor\n  );\n  if (!InvertClassification.isTranslucencySupported(this._context)) {\n    this._actualInvertClassificationColor.alpha = 1.0;\n  }\n\n  frameState.invertClassificationColor = this._actualInvertClassificationColor;\n\n  if (defined(this.globe)) {\n    frameState.maximumScreenSpaceError = this.globe.maximumScreenSpaceError;\n  } else {\n    frameState.maximumScreenSpaceError = 2;\n  }\n\n  this.clearPasses(frameState.passes);\n\n  frameState.tilesetPassState = undefined;\n};\n\n/**\n * @private\n */\nScene.prototype.isVisible = function (command, cullingVolume, occluder) {\n  return (\n    defined(command) &&\n    (!defined(command.boundingVolume) ||\n      !command.cull ||\n      (cullingVolume.computeVisibility(command.boundingVolume) !==\n        Intersect.OUTSIDE &&\n        (!defined(occluder) ||\n          !command.occlude ||\n          !command.boundingVolume.isOccluded(occluder))))\n  );\n};\n\nfunction getAttributeLocations(shaderProgram) {\n  var attributeLocations = {};\n  var attributes = shaderProgram.vertexAttributes;\n  for (var a in attributes) {\n    if (attributes.hasOwnProperty(a)) {\n      attributeLocations[a] = attributes[a].index;\n    }\n  }\n\n  return attributeLocations;\n}\n\nfunction createDebugFragmentShaderProgram(command, scene, shaderProgram) {\n  var context = scene.context;\n  var sp = defaultValue(shaderProgram, command.shaderProgram);\n  var fs = sp.fragmentShaderSource.clone();\n\n  var targets = [];\n  fs.sources = fs.sources.map(function (source) {\n    source = ShaderSource.replaceMain(source, \"czm_Debug_main\");\n    var re = /gl_FragData\\[(\\d+)\\]/g;\n    var match;\n    while ((match = re.exec(source)) !== null) {\n      if (targets.indexOf(match[1]) === -1) {\n        targets.push(match[1]);\n      }\n    }\n    return source;\n  });\n  var length = targets.length;\n\n  var newMain = \"void main() \\n\" + \"{ \\n\" + \"    czm_Debug_main(); \\n\";\n\n  var i;\n  if (scene.debugShowCommands) {\n    if (!defined(command._debugColor)) {\n      command._debugColor = Color.fromRandom();\n    }\n    var c = command._debugColor;\n    if (length > 0) {\n      for (i = 0; i < length; ++i) {\n        newMain +=\n          \"    gl_FragData[\" +\n          targets[i] +\n          \"].rgb *= vec3(\" +\n          c.red +\n          \", \" +\n          c.green +\n          \", \" +\n          c.blue +\n          \"); \\n\";\n      }\n    } else {\n      newMain +=\n        \"    \" +\n        \"gl_FragColor\" +\n        \".rgb *= vec3(\" +\n        c.red +\n        \", \" +\n        c.green +\n        \", \" +\n        c.blue +\n        \"); \\n\";\n    }\n  }\n\n  if (scene.debugShowFrustums) {\n    // Support up to three frustums.  If a command overlaps all\n    // three, it's code is not changed.\n    var r = command.debugOverlappingFrustums & (1 << 0) ? \"1.0\" : \"0.0\";\n    var g = command.debugOverlappingFrustums & (1 << 1) ? \"1.0\" : \"0.0\";\n    var b = command.debugOverlappingFrustums & (1 << 2) ? \"1.0\" : \"0.0\";\n    if (length > 0) {\n      for (i = 0; i < length; ++i) {\n        newMain +=\n          \"    gl_FragData[\" +\n          targets[i] +\n          \"].rgb *= vec3(\" +\n          r +\n          \", \" +\n          g +\n          \", \" +\n          b +\n          \"); \\n\";\n      }\n    } else {\n      newMain +=\n        \"    \" +\n        \"gl_FragColor\" +\n        \".rgb *= vec3(\" +\n        r +\n        \", \" +\n        g +\n        \", \" +\n        b +\n        \"); \\n\";\n    }\n  }\n\n  newMain += \"}\";\n\n  fs.sources.push(newMain);\n\n  var attributeLocations = getAttributeLocations(sp);\n\n  return ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: sp.vertexShaderSource,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n}\n\nfunction executeDebugCommand(command, scene, passState) {\n  var debugCommand = DrawCommand.shallowClone(command);\n  debugCommand.shaderProgram = createDebugFragmentShaderProgram(command, scene);\n  debugCommand.execute(scene.context, passState);\n  debugCommand.shaderProgram.destroy();\n}\n\nvar transformFrom2D = new Matrix4(\n  0.0,\n  0.0,\n  1.0,\n  0.0,\n  1.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  1.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  1.0\n);\ntransformFrom2D = Matrix4.inverseTransformation(\n  transformFrom2D,\n  transformFrom2D\n);\n\nfunction debugShowBoundingVolume(command, scene, passState, debugFramebuffer) {\n  // Debug code to draw bounding volume for command.  Not optimized!\n  // Assumes bounding volume is a bounding sphere or box\n  var frameState = scene._frameState;\n  var context = frameState.context;\n  var boundingVolume = command.boundingVolume;\n\n  if (defined(scene._debugVolume)) {\n    scene._debugVolume.destroy();\n  }\n\n  var geometry;\n\n  var center = Cartesian3.clone(boundingVolume.center);\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    center = Matrix4.multiplyByPoint(transformFrom2D, center, center);\n    var projection = frameState.mapProjection;\n    var centerCartographic = projection.unproject(center);\n    center = projection.ellipsoid.cartographicToCartesian(centerCartographic);\n  }\n\n  if (defined(boundingVolume.radius)) {\n    var radius = boundingVolume.radius;\n\n    geometry = GeometryPipeline.toWireframe(\n      EllipsoidGeometry.createGeometry(\n        new EllipsoidGeometry({\n          radii: new Cartesian3(radius, radius, radius),\n          vertexFormat: PerInstanceColorAppearance.FLAT_VERTEX_FORMAT,\n        })\n      )\n    );\n\n    scene._debugVolume = new Primitive({\n      geometryInstances: new GeometryInstance({\n        geometry: geometry,\n        modelMatrix: Matrix4.fromTranslation(center),\n        attributes: {\n          color: new ColorGeometryInstanceAttribute(1.0, 0.0, 0.0, 1.0),\n        },\n      }),\n      appearance: new PerInstanceColorAppearance({\n        flat: true,\n        translucent: false,\n      }),\n      asynchronous: false,\n    });\n  } else {\n    var halfAxes = boundingVolume.halfAxes;\n\n    geometry = GeometryPipeline.toWireframe(\n      BoxGeometry.createGeometry(\n        BoxGeometry.fromDimensions({\n          dimensions: new Cartesian3(2.0, 2.0, 2.0),\n          vertexFormat: PerInstanceColorAppearance.FLAT_VERTEX_FORMAT,\n        })\n      )\n    );\n\n    scene._debugVolume = new Primitive({\n      geometryInstances: new GeometryInstance({\n        geometry: geometry,\n        modelMatrix: Matrix4.fromRotationTranslation(\n          halfAxes,\n          center,\n          new Matrix4()\n        ),\n        attributes: {\n          color: new ColorGeometryInstanceAttribute(1.0, 0.0, 0.0, 1.0),\n        },\n      }),\n      appearance: new PerInstanceColorAppearance({\n        flat: true,\n        translucent: false,\n      }),\n      asynchronous: false,\n    });\n  }\n\n  var savedCommandList = frameState.commandList;\n  var commandList = (frameState.commandList = []);\n  scene._debugVolume.update(frameState);\n\n  command = commandList[0];\n\n  if (frameState.useLogDepth) {\n    var logDepth = DerivedCommand.createLogDepthCommand(command, context);\n    command = logDepth.command;\n  }\n\n  var framebuffer;\n  if (defined(debugFramebuffer)) {\n    framebuffer = passState.framebuffer;\n    passState.framebuffer = debugFramebuffer;\n  }\n\n  command.execute(context, passState);\n\n  if (defined(framebuffer)) {\n    passState.framebuffer = framebuffer;\n  }\n\n  frameState.commandList = savedCommandList;\n}\n\nfunction executeCommand(command, scene, context, passState, debugFramebuffer) {\n  var frameState = scene._frameState;\n\n  if (defined(scene.debugCommandFilter) && !scene.debugCommandFilter(command)) {\n    return;\n  }\n\n  if (command instanceof ClearCommand) {\n    command.execute(context, passState);\n    return;\n  }\n\n  if (command.debugShowBoundingVolume && defined(command.boundingVolume)) {\n    debugShowBoundingVolume(command, scene, passState, debugFramebuffer);\n  }\n\n  if (frameState.useLogDepth && defined(command.derivedCommands.logDepth)) {\n    command = command.derivedCommands.logDepth.command;\n  }\n\n  var passes = frameState.passes;\n  if (\n    !passes.pick &&\n    scene._hdr &&\n    defined(command.derivedCommands) &&\n    defined(command.derivedCommands.hdr)\n  ) {\n    command = command.derivedCommands.hdr.command;\n  }\n\n  if (passes.pick || passes.depth) {\n    if (\n      passes.pick &&\n      !passes.depth &&\n      defined(command.derivedCommands.picking)\n    ) {\n      command = command.derivedCommands.picking.pickCommand;\n      command.execute(context, passState);\n      return;\n    } else if (defined(command.derivedCommands.depth)) {\n      command = command.derivedCommands.depth.depthOnlyCommand;\n      command.execute(context, passState);\n      return;\n    }\n  }\n\n  if (scene.debugShowCommands || scene.debugShowFrustums) {\n    executeDebugCommand(command, scene, passState);\n    return;\n  }\n\n  if (\n    frameState.shadowState.lightShadowsEnabled &&\n    command.receiveShadows &&\n    defined(command.derivedCommands.shadows)\n  ) {\n    // If the command receives shadows, execute the derived shadows command.\n    // Some commands, such as OIT derived commands, do not have derived shadow commands themselves\n    // and instead shadowing is built-in. In this case execute the command regularly below.\n    command.derivedCommands.shadows.receiveCommand.execute(context, passState);\n  } else {\n    command.execute(context, passState);\n  }\n}\n\nfunction executeIdCommand(command, scene, context, passState) {\n  var frameState = scene._frameState;\n  var derivedCommands = command.derivedCommands;\n  if (!defined(derivedCommands)) {\n    return;\n  }\n\n  if (frameState.useLogDepth && defined(derivedCommands.logDepth)) {\n    command = derivedCommands.logDepth.command;\n  }\n\n  derivedCommands = command.derivedCommands;\n  if (defined(derivedCommands.picking)) {\n    command = derivedCommands.picking.pickCommand;\n    command.execute(context, passState);\n  } else if (defined(derivedCommands.depth)) {\n    command = derivedCommands.depth.depthOnlyCommand;\n    command.execute(context, passState);\n  }\n}\n\nfunction backToFront(a, b, position) {\n  return (\n    b.boundingVolume.distanceSquaredTo(position) -\n    a.boundingVolume.distanceSquaredTo(position)\n  );\n}\n\nfunction frontToBack(a, b, position) {\n  // When distances are equal equal favor sorting b before a. This gives render priority to commands later in the list.\n  return (\n    a.boundingVolume.distanceSquaredTo(position) -\n    b.boundingVolume.distanceSquaredTo(position) +\n    CesiumMath.EPSILON12\n  );\n}\n\nfunction executeTranslucentCommandsBackToFront(\n  scene,\n  executeFunction,\n  passState,\n  commands,\n  invertClassification\n) {\n  var context = scene.context;\n\n  mergeSort(commands, backToFront, scene.camera.positionWC);\n\n  if (defined(invertClassification)) {\n    executeFunction(\n      invertClassification.unclassifiedCommand,\n      scene,\n      context,\n      passState\n    );\n  }\n\n  var length = commands.length;\n  for (var i = 0; i < length; ++i) {\n    executeFunction(commands[i], scene, context, passState);\n  }\n}\n\nfunction executeTranslucentCommandsFrontToBack(\n  scene,\n  executeFunction,\n  passState,\n  commands,\n  invertClassification\n) {\n  var context = scene.context;\n\n  mergeSort(commands, frontToBack, scene.camera.positionWC);\n\n  if (defined(invertClassification)) {\n    executeFunction(\n      invertClassification.unclassifiedCommand,\n      scene,\n      context,\n      passState\n    );\n  }\n\n  var length = commands.length;\n  for (var i = 0; i < length; ++i) {\n    executeFunction(commands[i], scene, context, passState);\n  }\n}\n\nfunction getDebugGlobeDepth(scene, index) {\n  var globeDepths = scene._view.debugGlobeDepths;\n  var globeDepth = globeDepths[index];\n  if (!defined(globeDepth) && scene.context.depthTexture) {\n    globeDepth = new GlobeDepth();\n    globeDepths[index] = globeDepth;\n  }\n  return globeDepth;\n}\n\nvar scratchPerspectiveFrustum = new PerspectiveFrustum();\nvar scratchPerspectiveOffCenterFrustum = new PerspectiveOffCenterFrustum();\nvar scratchOrthographicFrustum = new OrthographicFrustum();\nvar scratchOrthographicOffCenterFrustum = new OrthographicOffCenterFrustum();\n\nfunction executeCommands(scene, passState) {\n  var camera = scene.camera;\n  var context = scene.context;\n  var us = context.uniformState;\n\n  us.updateCamera(camera);\n\n  // Create a working frustum from the original camera frustum.\n  var frustum;\n  if (defined(camera.frustum.fov)) {\n    frustum = camera.frustum.clone(scratchPerspectiveFrustum);\n  } else if (defined(camera.frustum.infiniteProjectionMatrix)) {\n    frustum = camera.frustum.clone(scratchPerspectiveOffCenterFrustum);\n  } else if (defined(camera.frustum.width)) {\n    frustum = camera.frustum.clone(scratchOrthographicFrustum);\n  } else {\n    frustum = camera.frustum.clone(scratchOrthographicOffCenterFrustum);\n  }\n\n  // Ideally, we would render the sky box and atmosphere last for\n  // early-z, but we would have to draw it in each frustum\n  frustum.near = camera.frustum.near;\n  frustum.far = camera.frustum.far;\n  us.updateFrustum(frustum);\n  us.updatePass(Pass.ENVIRONMENT);\n\n  var passes = scene._frameState.passes;\n  var picking = passes.pick;\n  var environmentState = scene._environmentState;\n  var view = scene._view;\n  var renderTranslucentDepthForPick =\n    environmentState.renderTranslucentDepthForPick;\n  var useWebVR = environmentState.useWebVR;\n\n  // Do not render environment primitives during a pick pass since they do not generate picking commands.\n  if (!picking) {\n    var skyBoxCommand = environmentState.skyBoxCommand;\n    if (defined(skyBoxCommand)) {\n      executeCommand(skyBoxCommand, scene, context, passState);\n    }\n\n    if (environmentState.isSkyAtmosphereVisible) {\n      executeCommand(\n        environmentState.skyAtmosphereCommand,\n        scene,\n        context,\n        passState\n      );\n    }\n\n    if (environmentState.isSunVisible) {\n      environmentState.sunDrawCommand.execute(context, passState);\n      if (scene.sunBloom && !useWebVR) {\n        var framebuffer;\n        if (environmentState.useGlobeDepthFramebuffer) {\n          framebuffer = view.globeDepth.framebuffer;\n        } else if (environmentState.usePostProcess) {\n          framebuffer = view.sceneFramebuffer.getFramebuffer();\n        } else {\n          framebuffer = environmentState.originalFramebuffer;\n        }\n        scene._sunPostProcess.execute(context);\n        scene._sunPostProcess.copy(context, framebuffer);\n        passState.framebuffer = framebuffer;\n      }\n    }\n\n    // Moon can be seen through the atmosphere, since the sun is rendered after the atmosphere.\n    if (environmentState.isMoonVisible) {\n      environmentState.moonCommand.execute(context, passState);\n    }\n  }\n\n  // Determine how translucent surfaces will be handled.\n  var executeTranslucentCommands;\n  if (environmentState.useOIT) {\n    if (!defined(scene._executeOITFunction)) {\n      scene._executeOITFunction = function (\n        scene,\n        executeFunction,\n        passState,\n        commands,\n        invertClassification\n      ) {\n        view.oit.executeCommands(\n          scene,\n          executeFunction,\n          passState,\n          commands,\n          invertClassification\n        );\n      };\n    }\n    executeTranslucentCommands = scene._executeOITFunction;\n  } else if (passes.render) {\n    executeTranslucentCommands = executeTranslucentCommandsBackToFront;\n  } else {\n    executeTranslucentCommands = executeTranslucentCommandsFrontToBack;\n  }\n\n  var frustumCommandsList = view.frustumCommandsList;\n  var numFrustums = frustumCommandsList.length;\n\n  var clearGlobeDepth = environmentState.clearGlobeDepth;\n  var useDepthPlane = environmentState.useDepthPlane;\n  var separatePrimitiveFramebuffer = (environmentState.separatePrimitiveFramebuffer = false);\n  var clearDepth = scene._depthClearCommand;\n  var clearStencil = scene._stencilClearCommand;\n  var clearClassificationStencil = scene._classificationStencilClearCommand;\n  var depthPlane = scene._depthPlane;\n  var usePostProcessSelected = environmentState.usePostProcessSelected;\n\n  var height2D = camera.position.z;\n\n  // Execute commands in each frustum in back to front order\n  var j;\n  for (var i = 0; i < numFrustums; ++i) {\n    var index = numFrustums - i - 1;\n    var frustumCommands = frustumCommandsList[index];\n\n    if (scene.mode === SceneMode.SCENE2D) {\n      // To avoid z-fighting in 2D, move the camera to just before the frustum\n      // and scale the frustum depth to be in [1.0, nearToFarDistance2D].\n      camera.position.z = height2D - frustumCommands.near + 1.0;\n      frustum.far = Math.max(1.0, frustumCommands.far - frustumCommands.near);\n      frustum.near = 1.0;\n      us.update(scene.frameState);\n      us.updateFrustum(frustum);\n    } else {\n      // Avoid tearing artifacts between adjacent frustums in the opaque passes\n      frustum.near =\n        index !== 0\n          ? frustumCommands.near * scene.opaqueFrustumNearOffset\n          : frustumCommands.near;\n      frustum.far = frustumCommands.far;\n      us.updateFrustum(frustum);\n    }\n\n    var globeDepth = scene.debugShowGlobeDepth\n      ? getDebugGlobeDepth(scene, index)\n      : view.globeDepth;\n\n    if (separatePrimitiveFramebuffer) {\n      // Render to globe framebuffer in GLOBE pass\n      passState.framebuffer = globeDepth.framebuffer;\n    }\n\n    var fb;\n    if (\n      scene.debugShowGlobeDepth &&\n      defined(globeDepth) &&\n      environmentState.useGlobeDepthFramebuffer\n    ) {\n      globeDepth.update(\n        context,\n        passState,\n        view.viewport,\n        scene._hdr,\n        clearGlobeDepth\n      );\n      globeDepth.clear(context, passState, scene._clearColorCommand.color);\n      fb = passState.framebuffer;\n      passState.framebuffer = globeDepth.framebuffer;\n    }\n\n    clearDepth.execute(context, passState);\n\n    if (context.stencilBuffer) {\n      clearStencil.execute(context, passState);\n    }\n\n    us.updatePass(Pass.GLOBE);\n    var commands = frustumCommands.commands[Pass.GLOBE];\n    var length = frustumCommands.indices[Pass.GLOBE];\n    for (j = 0; j < length; ++j) {\n      executeCommand(commands[j], scene, context, passState);\n    }\n\n    if (defined(globeDepth) && environmentState.useGlobeDepthFramebuffer) {\n      globeDepth.executeCopyDepth(context, passState);\n    }\n\n    if (\n      scene.debugShowGlobeDepth &&\n      defined(globeDepth) &&\n      environmentState.useGlobeDepthFramebuffer\n    ) {\n      passState.framebuffer = fb;\n    }\n\n    // Draw terrain classification\n    us.updatePass(Pass.TERRAIN_CLASSIFICATION);\n    commands = frustumCommands.commands[Pass.TERRAIN_CLASSIFICATION];\n    length = frustumCommands.indices[Pass.TERRAIN_CLASSIFICATION];\n    for (j = 0; j < length; ++j) {\n      executeCommand(commands[j], scene, context, passState);\n    }\n\n    if (clearGlobeDepth) {\n      clearDepth.execute(context, passState);\n      if (useDepthPlane) {\n        depthPlane.execute(context, passState);\n      }\n    }\n\n    if (separatePrimitiveFramebuffer) {\n      // Render to primitive framebuffer in all other passes\n      passState.framebuffer = globeDepth.primitiveFramebuffer;\n    }\n\n    if (!environmentState.useInvertClassification || picking) {\n      // Common/fastest path. Draw 3D Tiles and classification normally.\n\n      // Draw 3D Tiles\n      us.updatePass(Pass.CESIUM_3D_TILE);\n      commands = frustumCommands.commands[Pass.CESIUM_3D_TILE];\n      length = frustumCommands.indices[Pass.CESIUM_3D_TILE];\n      for (j = 0; j < length; ++j) {\n        executeCommand(commands[j], scene, context, passState);\n      }\n\n      if (length > 0) {\n        if (defined(globeDepth) && environmentState.useGlobeDepthFramebuffer) {\n          globeDepth.executeUpdateDepth(context, passState, clearGlobeDepth);\n        }\n\n        // Draw classifications. Modifies 3D Tiles color.\n        us.updatePass(Pass.CESIUM_3D_TILE_CLASSIFICATION);\n        commands = frustumCommands.commands[Pass.CESIUM_3D_TILE_CLASSIFICATION];\n        length = frustumCommands.indices[Pass.CESIUM_3D_TILE_CLASSIFICATION];\n        for (j = 0; j < length; ++j) {\n          executeCommand(commands[j], scene, context, passState);\n        }\n      }\n    } else {\n      // When the invert classification color is opaque:\n      //    Main FBO (FBO1):                   Main_Color   + Main_DepthStencil\n      //    Invert classification FBO (FBO2) : Invert_Color + Main_DepthStencil\n      //\n      //    1. Clear FBO2 color to vec4(0.0) for each frustum\n      //    2. Draw 3D Tiles to FBO2\n      //    3. Draw classification to FBO2\n      //    4. Fullscreen pass to FBO1, draw Invert_Color when:\n      //           * Main_DepthStencil has the stencil bit set > 0 (classified)\n      //    5. Fullscreen pass to FBO1, draw Invert_Color * czm_invertClassificationColor when:\n      //           * Main_DepthStencil has stencil bit set to 0 (unclassified) and\n      //           * Invert_Color !== vec4(0.0)\n      //\n      // When the invert classification color is translucent:\n      //    Main FBO (FBO1):                  Main_Color         + Main_DepthStencil\n      //    Invert classification FBO (FBO2): Invert_Color       + Invert_DepthStencil\n      //    IsClassified FBO (FBO3):          IsClassified_Color + Invert_DepthStencil\n      //\n      //    1. Clear FBO2 and FBO3 color to vec4(0.0), stencil to 0, and depth to 1.0\n      //    2. Draw 3D Tiles to FBO2\n      //    3. Draw classification to FBO2\n      //    4. Fullscreen pass to FBO3, draw any color when\n      //           * Invert_DepthStencil has the stencil bit set > 0 (classified)\n      //    5. Fullscreen pass to FBO1, draw Invert_Color when:\n      //           * Invert_Color !== vec4(0.0) and\n      //           * IsClassified_Color !== vec4(0.0)\n      //    6. Fullscreen pass to FBO1, draw Invert_Color * czm_invertClassificationColor when:\n      //           * Invert_Color !== vec4(0.0) and\n      //           * IsClassified_Color === vec4(0.0)\n      //\n      // NOTE: Step six when translucent invert color occurs after the TRANSLUCENT pass\n      //\n      scene._invertClassification.clear(context, passState);\n\n      var opaqueClassificationFramebuffer = passState.framebuffer;\n      passState.framebuffer = scene._invertClassification._fbo;\n\n      // Draw normally\n      us.updatePass(Pass.CESIUM_3D_TILE);\n      commands = frustumCommands.commands[Pass.CESIUM_3D_TILE];\n      length = frustumCommands.indices[Pass.CESIUM_3D_TILE];\n      for (j = 0; j < length; ++j) {\n        executeCommand(commands[j], scene, context, passState);\n      }\n\n      if (defined(globeDepth) && environmentState.useGlobeDepthFramebuffer) {\n        globeDepth.executeUpdateDepth(context, passState, clearGlobeDepth);\n      }\n\n      // Set stencil\n      us.updatePass(Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW);\n      commands =\n        frustumCommands.commands[\n          Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW\n        ];\n      length =\n        frustumCommands.indices[Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW];\n      for (j = 0; j < length; ++j) {\n        executeCommand(commands[j], scene, context, passState);\n      }\n\n      passState.framebuffer = opaqueClassificationFramebuffer;\n\n      // Fullscreen pass to copy classified fragments\n      scene._invertClassification.executeClassified(context, passState);\n      if (scene.frameState.invertClassificationColor.alpha === 1.0) {\n        // Fullscreen pass to copy unclassified fragments when alpha == 1.0\n        scene._invertClassification.executeUnclassified(context, passState);\n      }\n\n      // Clear stencil set by the classification for the next classification pass\n      if (length > 0 && context.stencilBuffer) {\n        clearClassificationStencil.execute(context, passState);\n      }\n\n      // Draw style over classification.\n      us.updatePass(Pass.CESIUM_3D_TILE_CLASSIFICATION);\n      commands = frustumCommands.commands[Pass.CESIUM_3D_TILE_CLASSIFICATION];\n      length = frustumCommands.indices[Pass.CESIUM_3D_TILE_CLASSIFICATION];\n      for (j = 0; j < length; ++j) {\n        executeCommand(commands[j], scene, context, passState);\n      }\n    }\n\n    if (length > 0 && context.stencilBuffer) {\n      clearStencil.execute(context, passState);\n    }\n\n    us.updatePass(Pass.OPAQUE);\n    commands = frustumCommands.commands[Pass.OPAQUE];\n    length = frustumCommands.indices[Pass.OPAQUE];\n    for (j = 0; j < length; ++j) {\n      executeCommand(commands[j], scene, context, passState);\n    }\n\n    if (index !== 0 && scene.mode !== SceneMode.SCENE2D) {\n      // Do not overlap frustums in the translucent pass to avoid blending artifacts\n      frustum.near = frustumCommands.near;\n      us.updateFrustum(frustum);\n    }\n\n    var invertClassification;\n    if (\n      !picking &&\n      environmentState.useInvertClassification &&\n      scene.frameState.invertClassificationColor.alpha < 1.0\n    ) {\n      // Fullscreen pass to copy unclassified fragments when alpha < 1.0.\n      // Not executed when undefined.\n      invertClassification = scene._invertClassification;\n    }\n\n    us.updatePass(Pass.TRANSLUCENT);\n    commands = frustumCommands.commands[Pass.TRANSLUCENT];\n    commands.length = frustumCommands.indices[Pass.TRANSLUCENT];\n    executeTranslucentCommands(\n      scene,\n      executeCommand,\n      passState,\n      commands,\n      invertClassification\n    );\n\n    if (\n      context.depthTexture &&\n      scene.useDepthPicking &&\n      (environmentState.useGlobeDepthFramebuffer ||\n        renderTranslucentDepthForPick)\n    ) {\n      // PERFORMANCE_IDEA: Use MRT to avoid the extra copy.\n      var depthStencilTexture = renderTranslucentDepthForPick\n        ? passState.framebuffer.depthStencilTexture\n        : globeDepth.framebuffer.depthStencilTexture;\n      var pickDepth = scene._picking.getPickDepth(scene, index);\n      pickDepth.update(context, depthStencilTexture);\n      pickDepth.executeCopyDepth(context, passState);\n    }\n\n    if (separatePrimitiveFramebuffer) {\n      // Reset framebuffer\n      passState.framebuffer = globeDepth.framebuffer;\n    }\n\n    if (picking || !usePostProcessSelected) {\n      continue;\n    }\n\n    var originalFramebuffer = passState.framebuffer;\n    passState.framebuffer = view.sceneFramebuffer.getIdFramebuffer();\n\n    // reset frustum\n    frustum.near =\n      index !== 0\n        ? frustumCommands.near * scene.opaqueFrustumNearOffset\n        : frustumCommands.near;\n    frustum.far = frustumCommands.far;\n    us.updateFrustum(frustum);\n\n    us.updatePass(Pass.GLOBE);\n    commands = frustumCommands.commands[Pass.GLOBE];\n    length = frustumCommands.indices[Pass.GLOBE];\n    for (j = 0; j < length; ++j) {\n      executeIdCommand(commands[j], scene, context, passState);\n    }\n\n    if (clearGlobeDepth) {\n      clearDepth.framebuffer = passState.framebuffer;\n      clearDepth.execute(context, passState);\n      clearDepth.framebuffer = undefined;\n    }\n\n    if (clearGlobeDepth && useDepthPlane) {\n      depthPlane.execute(context, passState);\n    }\n\n    us.updatePass(Pass.CESIUM_3D_TILE);\n    commands = frustumCommands.commands[Pass.CESIUM_3D_TILE];\n    length = frustumCommands.indices[Pass.CESIUM_3D_TILE];\n    for (j = 0; j < length; ++j) {\n      executeIdCommand(commands[j], scene, context, passState);\n    }\n\n    us.updatePass(Pass.OPAQUE);\n    commands = frustumCommands.commands[Pass.OPAQUE];\n    length = frustumCommands.indices[Pass.OPAQUE];\n    for (j = 0; j < length; ++j) {\n      executeIdCommand(commands[j], scene, context, passState);\n    }\n\n    us.updatePass(Pass.TRANSLUCENT);\n    commands = frustumCommands.commands[Pass.TRANSLUCENT];\n    length = frustumCommands.indices[Pass.TRANSLUCENT];\n    for (j = 0; j < length; ++j) {\n      executeIdCommand(commands[j], scene, context, passState);\n    }\n\n    passState.framebuffer = originalFramebuffer;\n  }\n}\n\nfunction executeComputeCommands(scene) {\n  var us = scene.context.uniformState;\n  us.updatePass(Pass.COMPUTE);\n\n  var sunComputeCommand = scene._environmentState.sunComputeCommand;\n  if (defined(sunComputeCommand)) {\n    sunComputeCommand.execute(scene._computeEngine);\n  }\n\n  var commandList = scene._computeCommandList;\n  var length = commandList.length;\n  for (var i = 0; i < length; ++i) {\n    commandList[i].execute(scene._computeEngine);\n  }\n}\n\nfunction executeOverlayCommands(scene, passState) {\n  var us = scene.context.uniformState;\n  us.updatePass(Pass.OVERLAY);\n\n  var context = scene.context;\n  var commandList = scene._overlayCommandList;\n  var length = commandList.length;\n  for (var i = 0; i < length; ++i) {\n    commandList[i].execute(context, passState);\n  }\n}\n\nfunction insertShadowCastCommands(scene, commandList, shadowMap) {\n  var shadowVolume = shadowMap.shadowMapCullingVolume;\n  var isPointLight = shadowMap.isPointLight;\n  var passes = shadowMap.passes;\n  var numberOfPasses = passes.length;\n\n  var length = commandList.length;\n  for (var i = 0; i < length; ++i) {\n    var command = commandList[i];\n    scene.updateDerivedCommands(command);\n\n    if (\n      command.castShadows &&\n      (command.pass === Pass.GLOBE ||\n        command.pass === Pass.CESIUM_3D_TILE ||\n        command.pass === Pass.OPAQUE ||\n        command.pass === Pass.TRANSLUCENT)\n    ) {\n      if (scene.isVisible(command, shadowVolume)) {\n        if (isPointLight) {\n          for (var k = 0; k < numberOfPasses; ++k) {\n            passes[k].commandList.push(command);\n          }\n        } else if (numberOfPasses === 1) {\n          passes[0].commandList.push(command);\n        } else {\n          var wasVisible = false;\n          // Loop over cascades from largest to smallest\n          for (var j = numberOfPasses - 1; j >= 0; --j) {\n            var cascadeVolume = passes[j].cullingVolume;\n            if (scene.isVisible(command, cascadeVolume)) {\n              passes[j].commandList.push(command);\n              wasVisible = true;\n            } else if (wasVisible) {\n              // If it was visible in the previous cascade but now isn't\n              // then there is no need to check any more cascades\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction executeShadowMapCastCommands(scene) {\n  var frameState = scene.frameState;\n  var shadowMaps = frameState.shadowState.shadowMaps;\n  var shadowMapLength = shadowMaps.length;\n\n  if (!frameState.shadowState.shadowsEnabled) {\n    return;\n  }\n\n  var context = scene.context;\n  var uniformState = context.uniformState;\n\n  for (var i = 0; i < shadowMapLength; ++i) {\n    var shadowMap = shadowMaps[i];\n    if (shadowMap.outOfView) {\n      continue;\n    }\n\n    // Reset the command lists\n    var j;\n    var passes = shadowMap.passes;\n    var numberOfPasses = passes.length;\n    for (j = 0; j < numberOfPasses; ++j) {\n      passes[j].commandList.length = 0;\n    }\n\n    // Insert the primitive/model commands into the command lists\n    var sceneCommands = scene.frameState.commandList;\n    insertShadowCastCommands(scene, sceneCommands, shadowMap);\n\n    for (j = 0; j < numberOfPasses; ++j) {\n      var pass = shadowMap.passes[j];\n      uniformState.updateCamera(pass.camera);\n      shadowMap.updatePass(context, j);\n      var numberOfCommands = pass.commandList.length;\n      for (var k = 0; k < numberOfCommands; ++k) {\n        var command = pass.commandList[k];\n        // Set the correct pass before rendering into the shadow map because some shaders\n        // conditionally render based on whether the pass is translucent or opaque.\n        uniformState.updatePass(command.pass);\n        executeCommand(\n          command.derivedCommands.shadows.castCommands[i],\n          scene,\n          context,\n          pass.passState\n        );\n      }\n    }\n  }\n}\n\nvar scratchEyeTranslation = new Cartesian3();\n\n/**\n * @private\n */\nScene.prototype.updateAndExecuteCommands = function (\n  passState,\n  backgroundColor\n) {\n  var frameState = this._frameState;\n  var mode = frameState.mode;\n  var useWebVR = this._environmentState.useWebVR;\n\n  if (useWebVR) {\n    executeWebVRCommands(this, passState, backgroundColor);\n  } else if (\n    mode !== SceneMode.SCENE2D ||\n    this._mapMode2D === MapMode2D.ROTATE\n  ) {\n    executeCommandsInViewport(true, this, passState, backgroundColor);\n  } else {\n    updateAndClearFramebuffers(this, passState, backgroundColor);\n    execute2DViewportCommands(this, passState);\n  }\n};\n\nfunction executeWebVRCommands(scene, passState, backgroundColor) {\n  var view = scene._view;\n  var camera = view.camera;\n  var environmentState = scene._environmentState;\n  var renderTranslucentDepthForPick =\n    environmentState.renderTranslucentDepthForPick;\n\n  updateAndClearFramebuffers(scene, passState, backgroundColor);\n\n  if (!renderTranslucentDepthForPick) {\n    updateAndRenderPrimitives(scene);\n  }\n\n  view.createPotentiallyVisibleSet(scene);\n\n  if (!renderTranslucentDepthForPick) {\n    executeComputeCommands(scene);\n    executeShadowMapCastCommands(scene);\n  }\n\n  // Based on Calculating Stereo pairs by Paul Bourke\n  // http://paulbourke.net/stereographics/stereorender/\n  var viewport = passState.viewport;\n  viewport.x = 0;\n  viewport.y = 0;\n  viewport.width = viewport.width * 0.5;\n\n  var savedCamera = Camera.clone(camera, scene._cameraVR);\n  savedCamera.frustum = camera.frustum;\n\n  var near = camera.frustum.near;\n  var fo = near * defaultValue(scene.focalLength, 5.0);\n  var eyeSeparation = defaultValue(scene.eyeSeparation, fo / 30.0);\n  var eyeTranslation = Cartesian3.multiplyByScalar(\n    savedCamera.right,\n    eyeSeparation * 0.5,\n    scratchEyeTranslation\n  );\n\n  camera.frustum.aspectRatio = viewport.width / viewport.height;\n\n  var offset = (0.5 * eyeSeparation * near) / fo;\n\n  Cartesian3.add(savedCamera.position, eyeTranslation, camera.position);\n  camera.frustum.xOffset = offset;\n\n  executeCommands(scene, passState);\n\n  viewport.x = viewport.width;\n\n  Cartesian3.subtract(savedCamera.position, eyeTranslation, camera.position);\n  camera.frustum.xOffset = -offset;\n\n  executeCommands(scene, passState);\n\n  Camera.clone(savedCamera, camera);\n}\n\nvar scratch2DViewportCartographic = new Cartographic(\n  Math.PI,\n  CesiumMath.PI_OVER_TWO\n);\nvar scratch2DViewportMaxCoord = new Cartesian3();\nvar scratch2DViewportSavedPosition = new Cartesian3();\nvar scratch2DViewportTransform = new Matrix4();\nvar scratch2DViewportCameraTransform = new Matrix4();\nvar scratch2DViewportEyePoint = new Cartesian3();\nvar scratch2DViewportWindowCoords = new Cartesian3();\nvar scratch2DViewport = new BoundingRectangle();\n\nfunction execute2DViewportCommands(scene, passState) {\n  var context = scene.context;\n  var frameState = scene.frameState;\n  var camera = scene.camera;\n\n  var originalViewport = passState.viewport;\n  var viewport = BoundingRectangle.clone(originalViewport, scratch2DViewport);\n  passState.viewport = viewport;\n\n  var maxCartographic = scratch2DViewportCartographic;\n  var maxCoord = scratch2DViewportMaxCoord;\n\n  var projection = scene.mapProjection;\n  projection.project(maxCartographic, maxCoord);\n\n  var position = Cartesian3.clone(\n    camera.position,\n    scratch2DViewportSavedPosition\n  );\n  var transform = Matrix4.clone(\n    camera.transform,\n    scratch2DViewportCameraTransform\n  );\n  var frustum = camera.frustum.clone();\n\n  camera._setTransform(Matrix4.IDENTITY);\n\n  var viewportTransformation = Matrix4.computeViewportTransformation(\n    viewport,\n    0.0,\n    1.0,\n    scratch2DViewportTransform\n  );\n  var projectionMatrix = camera.frustum.projectionMatrix;\n\n  var x = camera.positionWC.y;\n  var eyePoint = Cartesian3.fromElements(\n    CesiumMath.sign(x) * maxCoord.x - x,\n    0.0,\n    -camera.positionWC.x,\n    scratch2DViewportEyePoint\n  );\n  var windowCoordinates = Transforms.pointToGLWindowCoordinates(\n    projectionMatrix,\n    viewportTransformation,\n    eyePoint,\n    scratch2DViewportWindowCoords\n  );\n\n  windowCoordinates.x = Math.floor(windowCoordinates.x);\n\n  var viewportX = viewport.x;\n  var viewportWidth = viewport.width;\n\n  if (\n    x === 0.0 ||\n    windowCoordinates.x <= viewportX ||\n    windowCoordinates.x >= viewportX + viewportWidth\n  ) {\n    executeCommandsInViewport(true, scene, passState);\n  } else if (\n    Math.abs(viewportX + viewportWidth * 0.5 - windowCoordinates.x) < 1.0\n  ) {\n    viewport.width = windowCoordinates.x - viewport.x;\n\n    camera.position.x *= CesiumMath.sign(camera.position.x);\n\n    camera.frustum.right = 0.0;\n\n    frameState.cullingVolume = camera.frustum.computeCullingVolume(\n      camera.positionWC,\n      camera.directionWC,\n      camera.upWC\n    );\n    context.uniformState.update(frameState);\n\n    executeCommandsInViewport(true, scene, passState);\n\n    viewport.x = windowCoordinates.x;\n\n    camera.position.x = -camera.position.x;\n\n    camera.frustum.right = -camera.frustum.left;\n    camera.frustum.left = 0.0;\n\n    frameState.cullingVolume = camera.frustum.computeCullingVolume(\n      camera.positionWC,\n      camera.directionWC,\n      camera.upWC\n    );\n    context.uniformState.update(frameState);\n\n    executeCommandsInViewport(false, scene, passState);\n  } else if (windowCoordinates.x > viewportX + viewportWidth * 0.5) {\n    viewport.width = windowCoordinates.x - viewportX;\n\n    var right = camera.frustum.right;\n    camera.frustum.right = maxCoord.x - x;\n\n    frameState.cullingVolume = camera.frustum.computeCullingVolume(\n      camera.positionWC,\n      camera.directionWC,\n      camera.upWC\n    );\n    context.uniformState.update(frameState);\n\n    executeCommandsInViewport(true, scene, passState);\n\n    viewport.x = windowCoordinates.x;\n    viewport.width = viewportX + viewportWidth - windowCoordinates.x;\n\n    camera.position.x = -camera.position.x;\n\n    camera.frustum.left = -camera.frustum.right;\n    camera.frustum.right = right - camera.frustum.right * 2.0;\n\n    frameState.cullingVolume = camera.frustum.computeCullingVolume(\n      camera.positionWC,\n      camera.directionWC,\n      camera.upWC\n    );\n    context.uniformState.update(frameState);\n\n    executeCommandsInViewport(false, scene, passState);\n  } else {\n    viewport.x = windowCoordinates.x;\n    viewport.width = viewportX + viewportWidth - windowCoordinates.x;\n\n    var left = camera.frustum.left;\n    camera.frustum.left = -maxCoord.x - x;\n\n    frameState.cullingVolume = camera.frustum.computeCullingVolume(\n      camera.positionWC,\n      camera.directionWC,\n      camera.upWC\n    );\n    context.uniformState.update(frameState);\n\n    executeCommandsInViewport(true, scene, passState);\n\n    viewport.x = viewportX;\n    viewport.width = windowCoordinates.x - viewportX;\n\n    camera.position.x = -camera.position.x;\n\n    camera.frustum.right = -camera.frustum.left;\n    camera.frustum.left = left - camera.frustum.left * 2.0;\n\n    frameState.cullingVolume = camera.frustum.computeCullingVolume(\n      camera.positionWC,\n      camera.directionWC,\n      camera.upWC\n    );\n    context.uniformState.update(frameState);\n\n    executeCommandsInViewport(false, scene, passState);\n  }\n\n  camera._setTransform(transform);\n  Cartesian3.clone(position, camera.position);\n  camera.frustum = frustum.clone();\n  passState.viewport = originalViewport;\n}\n\nfunction executeCommandsInViewport(\n  firstViewport,\n  scene,\n  passState,\n  backgroundColor\n) {\n  var environmentState = scene._environmentState;\n  var view = scene._view;\n  var renderTranslucentDepthForPick =\n    environmentState.renderTranslucentDepthForPick;\n\n  if (!firstViewport && !renderTranslucentDepthForPick) {\n    scene.frameState.commandList.length = 0;\n  }\n\n  if (!renderTranslucentDepthForPick) {\n    updateAndRenderPrimitives(scene);\n  }\n\n  view.createPotentiallyVisibleSet(scene);\n\n  if (firstViewport) {\n    if (defined(backgroundColor)) {\n      updateAndClearFramebuffers(scene, passState, backgroundColor);\n    }\n    if (!renderTranslucentDepthForPick) {\n      executeComputeCommands(scene);\n      executeShadowMapCastCommands(scene);\n    }\n  }\n\n  executeCommands(scene, passState);\n}\n\nvar scratchCullingVolume = new CullingVolume();\n\n/**\n * @private\n */\nScene.prototype.updateEnvironment = function () {\n  var frameState = this._frameState;\n  var view = this._view;\n\n  // Update celestial and terrestrial environment effects.\n  var environmentState = this._environmentState;\n  var renderPass = frameState.passes.render;\n  var offscreenPass = frameState.passes.offscreen;\n  var skyAtmosphere = this.skyAtmosphere;\n  var globe = this.globe;\n\n  if (\n    !renderPass ||\n    (this._mode !== SceneMode.SCENE2D &&\n      view.camera.frustum instanceof OrthographicFrustum) ||\n    this._cameraUnderground\n  ) {\n    environmentState.skyAtmosphereCommand = undefined;\n    environmentState.skyBoxCommand = undefined;\n    environmentState.sunDrawCommand = undefined;\n    environmentState.sunComputeCommand = undefined;\n    environmentState.moonCommand = undefined;\n  } else {\n    if (defined(skyAtmosphere)) {\n      if (defined(globe)) {\n        skyAtmosphere.setDynamicAtmosphereColor(\n          globe.enableLighting && globe.dynamicAtmosphereLighting,\n          globe.dynamicAtmosphereLightingFromSun\n        );\n        environmentState.isReadyForAtmosphere =\n          environmentState.isReadyForAtmosphere ||\n          globe._surface._tilesToRender.length > 0;\n      }\n      environmentState.skyAtmosphereCommand = skyAtmosphere.update(frameState);\n      if (defined(environmentState.skyAtmosphereCommand)) {\n        this.updateDerivedCommands(environmentState.skyAtmosphereCommand);\n      }\n    } else {\n      environmentState.skyAtmosphereCommand = undefined;\n    }\n\n    environmentState.skyBoxCommand = defined(this.skyBox)\n      ? this.skyBox.update(frameState, this._hdr)\n      : undefined;\n    var sunCommands = defined(this.sun)\n      ? this.sun.update(frameState, view.passState, this._hdr)\n      : undefined;\n    environmentState.sunDrawCommand = defined(sunCommands)\n      ? sunCommands.drawCommand\n      : undefined;\n    environmentState.sunComputeCommand = defined(sunCommands)\n      ? sunCommands.computeCommand\n      : undefined;\n    environmentState.moonCommand = defined(this.moon)\n      ? this.moon.update(frameState)\n      : undefined;\n  }\n\n  var clearGlobeDepth = (environmentState.clearGlobeDepth =\n    defined(globe) &&\n    (!globe.depthTestAgainstTerrain || this.mode === SceneMode.SCENE2D));\n  var useDepthPlane = (environmentState.useDepthPlane =\n    clearGlobeDepth &&\n    this.mode === SceneMode.SCENE3D &&\n    !this._cameraUnderground);\n  if (useDepthPlane) {\n    // Update the depth plane that is rendered in 3D when the primitives are\n    // not depth tested against terrain so primitives on the backface\n    // of the globe are not picked.\n    this._depthPlane.update(frameState);\n  }\n\n  environmentState.renderTranslucentDepthForPick = false;\n  environmentState.useWebVR =\n    this._useWebVR && this.mode !== SceneMode.SCENE2D && !offscreenPass;\n\n  var occluder =\n    frameState.mode === SceneMode.SCENE3D ? frameState.occluder : undefined;\n  var cullingVolume = frameState.cullingVolume;\n\n  // get user culling volume minus the far plane.\n  var planes = scratchCullingVolume.planes;\n  for (var k = 0; k < 5; ++k) {\n    planes[k] = cullingVolume.planes[k];\n  }\n  cullingVolume = scratchCullingVolume;\n\n  // Determine visibility of celestial and terrestrial environment effects.\n  environmentState.isSkyAtmosphereVisible =\n    defined(environmentState.skyAtmosphereCommand) &&\n    environmentState.isReadyForAtmosphere;\n  environmentState.isSunVisible = this.isVisible(\n    environmentState.sunDrawCommand,\n    cullingVolume,\n    occluder\n  );\n  environmentState.isMoonVisible = this.isVisible(\n    environmentState.moonCommand,\n    cullingVolume,\n    occluder\n  );\n\n  var envMaps = this.specularEnvironmentMaps;\n  var envMapAtlas = this._specularEnvironmentMapAtlas;\n  if (\n    defined(envMaps) &&\n    (!defined(envMapAtlas) || envMapAtlas.url !== envMaps)\n  ) {\n    envMapAtlas = envMapAtlas && envMapAtlas.destroy();\n    this._specularEnvironmentMapAtlas = new OctahedralProjectedCubeMap(envMaps);\n  } else if (!defined(envMaps) && defined(envMapAtlas)) {\n    envMapAtlas.destroy();\n    this._specularEnvironmentMapAtlas = undefined;\n  }\n\n  if (defined(this._specularEnvironmentMapAtlas)) {\n    this._specularEnvironmentMapAtlas.update(frameState);\n  }\n};\n\nfunction updateDebugFrustumPlanes(scene) {\n  var frameState = scene._frameState;\n  if (scene.debugShowFrustumPlanes !== scene._debugShowFrustumPlanes) {\n    if (scene.debugShowFrustumPlanes) {\n      scene._debugFrustumPlanes = new DebugCameraPrimitive({\n        camera: scene.camera,\n        updateOnChange: false,\n      });\n    } else {\n      scene._debugFrustumPlanes =\n        scene._debugFrustumPlanes && scene._debugFrustumPlanes.destroy();\n    }\n    scene._debugShowFrustumPlanes = scene.debugShowFrustumPlanes;\n  }\n\n  if (defined(scene._debugFrustumPlanes)) {\n    scene._debugFrustumPlanes.update(frameState);\n  }\n}\n\nfunction updateShadowMaps(scene) {\n  var frameState = scene._frameState;\n  var shadowMaps = frameState.shadowMaps;\n  var length = shadowMaps.length;\n\n  var shadowsEnabled =\n    length > 0 && !frameState.passes.pick && scene.mode === SceneMode.SCENE3D;\n  if (shadowsEnabled !== frameState.shadowState.shadowsEnabled) {\n    // Update derived commands when shadowsEnabled changes\n    ++frameState.shadowState.lastDirtyTime;\n    frameState.shadowState.shadowsEnabled = shadowsEnabled;\n  }\n\n  frameState.shadowState.lightShadowsEnabled = false;\n\n  if (!shadowsEnabled) {\n    return;\n  }\n\n  // Check if the shadow maps are different than the shadow maps last frame.\n  // If so, the derived commands need to be updated.\n  for (var j = 0; j < length; ++j) {\n    if (shadowMaps[j] !== frameState.shadowState.shadowMaps[j]) {\n      ++frameState.shadowState.lastDirtyTime;\n      break;\n    }\n  }\n\n  frameState.shadowState.shadowMaps.length = 0;\n  frameState.shadowState.lightShadowMaps.length = 0;\n\n  for (var i = 0; i < length; ++i) {\n    var shadowMap = shadowMaps[i];\n    shadowMap.update(frameState);\n\n    frameState.shadowState.shadowMaps.push(shadowMap);\n\n    if (shadowMap.fromLightSource) {\n      frameState.shadowState.lightShadowMaps.push(shadowMap);\n      frameState.shadowState.lightShadowsEnabled = true;\n    }\n\n    if (shadowMap.dirty) {\n      ++frameState.shadowState.lastDirtyTime;\n      shadowMap.dirty = false;\n    }\n  }\n}\n\nfunction updateAndRenderPrimitives(scene) {\n  var frameState = scene._frameState;\n\n  scene._groundPrimitives.update(frameState);\n  scene._primitives.update(frameState);\n\n  updateDebugFrustumPlanes(scene);\n  updateShadowMaps(scene);\n\n  if (scene._globe) {\n    scene._globe.render(frameState);\n  }\n}\n\nfunction updateAndClearFramebuffers(scene, passState, clearColor) {\n  var context = scene._context;\n  var frameState = scene._frameState;\n  var environmentState = scene._environmentState;\n  var view = scene._view;\n\n  var passes = scene._frameState.passes;\n  var picking = passes.pick;\n  var useWebVR = environmentState.useWebVR;\n\n  // Preserve the reference to the original framebuffer.\n  environmentState.originalFramebuffer = passState.framebuffer;\n\n  // Manage sun bloom post-processing effect.\n  if (defined(scene.sun) && scene.sunBloom !== scene._sunBloom) {\n    if (scene.sunBloom && !useWebVR) {\n      scene._sunPostProcess = new SunPostProcess();\n    } else if (defined(scene._sunPostProcess)) {\n      scene._sunPostProcess = scene._sunPostProcess.destroy();\n    }\n\n    scene._sunBloom = scene.sunBloom;\n  } else if (!defined(scene.sun) && defined(scene._sunPostProcess)) {\n    scene._sunPostProcess = scene._sunPostProcess.destroy();\n    scene._sunBloom = false;\n  }\n\n  // Clear the pass state framebuffer.\n  var clear = scene._clearColorCommand;\n  Color.clone(clearColor, clear.color);\n  clear.execute(context, passState);\n\n  // Update globe depth rendering based on the current context and clear the globe depth framebuffer.\n  // Globe depth is copied for the pick pass to support picking batched geometries in GroundPrimitives.\n  var useGlobeDepthFramebuffer = (environmentState.useGlobeDepthFramebuffer = defined(\n    view.globeDepth\n  ));\n  if (useGlobeDepthFramebuffer) {\n    view.globeDepth.update(\n      context,\n      passState,\n      view.viewport,\n      scene._hdr,\n      environmentState.clearGlobeDepth\n    );\n    view.globeDepth.clear(context, passState, clearColor);\n  }\n\n  // If supported, configure OIT to use the globe depth framebuffer and clear the OIT framebuffer.\n  var oit = view.oit;\n  var useOIT = (environmentState.useOIT =\n    !picking && defined(oit) && oit.isSupported());\n  if (useOIT) {\n    oit.update(context, passState, view.globeDepth.framebuffer, scene._hdr);\n    oit.clear(context, passState, clearColor);\n    environmentState.useOIT = oit.isSupported();\n  }\n\n  var postProcess = scene.postProcessStages;\n  var usePostProcess = (environmentState.usePostProcess =\n    !picking &&\n    (scene._hdr ||\n      postProcess.length > 0 ||\n      postProcess.ambientOcclusion.enabled ||\n      postProcess.fxaa.enabled ||\n      postProcess.bloom.enabled));\n  environmentState.usePostProcessSelected = false;\n  if (usePostProcess) {\n    view.sceneFramebuffer.update(context, view.viewport, scene._hdr);\n    view.sceneFramebuffer.clear(context, passState, clearColor);\n\n    postProcess.update(context, frameState.useLogDepth, scene._hdr);\n    postProcess.clear(context);\n\n    usePostProcess = environmentState.usePostProcess = postProcess.ready;\n    environmentState.usePostProcessSelected =\n      usePostProcess && postProcess.hasSelected;\n  }\n\n  if (environmentState.isSunVisible && scene.sunBloom && !useWebVR) {\n    passState.framebuffer = scene._sunPostProcess.update(passState);\n    scene._sunPostProcess.clear(context, passState, clearColor);\n  } else if (useGlobeDepthFramebuffer) {\n    passState.framebuffer = view.globeDepth.framebuffer;\n  } else if (usePostProcess) {\n    passState.framebuffer = view.sceneFramebuffer.getFramebuffer();\n  }\n\n  if (defined(passState.framebuffer)) {\n    clear.execute(context, passState);\n  }\n\n  var useInvertClassification = (environmentState.useInvertClassification =\n    !picking && defined(passState.framebuffer) && scene.invertClassification);\n  if (useInvertClassification) {\n    var depthFramebuffer;\n    if (scene.frameState.invertClassificationColor.alpha === 1.0) {\n      if (environmentState.useGlobeDepthFramebuffer) {\n        depthFramebuffer = view.globeDepth.framebuffer;\n      }\n    }\n\n    if (defined(depthFramebuffer) || context.depthTexture) {\n      scene._invertClassification.previousFramebuffer = depthFramebuffer;\n      scene._invertClassification.update(context);\n      scene._invertClassification.clear(context, passState);\n\n      if (scene.frameState.invertClassificationColor.alpha < 1.0 && useOIT) {\n        var command = scene._invertClassification.unclassifiedCommand;\n        var derivedCommands = command.derivedCommands;\n        derivedCommands.oit = oit.createDerivedCommands(\n          command,\n          context,\n          derivedCommands.oit\n        );\n      }\n    } else {\n      environmentState.useInvertClassification = false;\n    }\n  }\n}\n\n/**\n * @private\n */\nScene.prototype.resolveFramebuffers = function (passState) {\n  var context = this._context;\n  var frameState = this._frameState;\n  var environmentState = this._environmentState;\n  var view = this._view;\n  var globeDepth = view.globeDepth;\n\n  var useOIT = environmentState.useOIT;\n  var useGlobeDepthFramebuffer = environmentState.useGlobeDepthFramebuffer;\n  var usePostProcess = environmentState.usePostProcess;\n\n  var defaultFramebuffer = environmentState.originalFramebuffer;\n  var globeFramebuffer = useGlobeDepthFramebuffer\n    ? globeDepth.framebuffer\n    : undefined;\n  var sceneFramebuffer = view.sceneFramebuffer.getFramebuffer();\n  var idFramebuffer = view.sceneFramebuffer.getIdFramebuffer();\n\n  if (environmentState.separatePrimitiveFramebuffer) {\n    // Merge primitive framebuffer into globe framebuffer\n    globeDepth.executeMergeColor(context, passState);\n  }\n\n  if (useOIT) {\n    passState.framebuffer = usePostProcess\n      ? sceneFramebuffer\n      : defaultFramebuffer;\n    view.oit.execute(context, passState);\n  }\n\n  if (usePostProcess) {\n    var inputFramebuffer = sceneFramebuffer;\n    if (useGlobeDepthFramebuffer && !useOIT) {\n      inputFramebuffer = globeFramebuffer;\n    }\n\n    var postProcess = this.postProcessStages;\n    var colorTexture = inputFramebuffer.getColorTexture(0);\n    var idTexture = idFramebuffer.getColorTexture(0);\n    var depthTexture = defaultValue(globeFramebuffer, sceneFramebuffer)\n      .depthStencilTexture;\n    postProcess.execute(context, colorTexture, depthTexture, idTexture);\n    postProcess.copy(context, defaultFramebuffer);\n  }\n\n  if (!useOIT && !usePostProcess && useGlobeDepthFramebuffer) {\n    passState.framebuffer = defaultFramebuffer;\n    globeDepth.executeCopyColor(context, passState);\n  }\n\n  var useLogDepth = frameState.useLogDepth;\n\n  if (this.debugShowGlobeDepth && useGlobeDepthFramebuffer) {\n    var gd = getDebugGlobeDepth(this, this.debugShowDepthFrustum - 1);\n    gd.executeDebugGlobeDepth(context, passState, useLogDepth);\n  }\n\n  if (this.debugShowPickDepth && useGlobeDepthFramebuffer) {\n    var pd = this._picking.getPickDepth(this, this.debugShowDepthFrustum - 1);\n    pd.executeDebugPickDepth(context, passState, useLogDepth);\n  }\n};\n\nfunction callAfterRenderFunctions(scene) {\n  // Functions are queued up during primitive update and executed here in case\n  // the function modifies scene state that should remain constant over the frame.\n  var functions = scene._frameState.afterRender;\n  for (var i = 0, length = functions.length; i < length; ++i) {\n    functions[i]();\n    scene.requestRender();\n  }\n\n  functions.length = 0;\n}\n\nfunction isCameraUnderground(scene) {\n  var camera = scene.camera;\n  var mode = scene._mode;\n  var globe = scene.globe;\n  var cameraController = scene._screenSpaceCameraController;\n  var cartographic = camera.positionCartographic;\n\n  if (!cameraController.onMap() && cartographic.height < 0.0) {\n    // The camera can go off the map while in Columbus View.\n    // Make a best guess as to whether it's underground by checking if its height is less than zero.\n    return true;\n  }\n\n  if (\n    !defined(globe) ||\n    !globe.show ||\n    mode === SceneMode.SCENE2D ||\n    mode === SceneMode.MORPHING\n  ) {\n    return false;\n  }\n\n  if (cameraController.adjustedHeightForTerrain()) {\n    // The camera controller already adjusted the camera, no need to call globe.getHeight again\n    return false;\n  }\n\n  var globeHeight = globe.getHeight(cartographic);\n  if (defined(globeHeight) && cartographic.height < globeHeight) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * @private\n */\nScene.prototype.initializeFrame = function () {\n  // Destroy released shaders and textures once every 120 frames to avoid thrashing the cache\n  if (this._shaderFrameCount++ === 120) {\n    this._shaderFrameCount = 0;\n    this._context.shaderCache.destroyReleasedShaderPrograms();\n    this._context.textureCache.destroyReleasedTextures();\n  }\n\n  this._tweens.update();\n\n  this._screenSpaceCameraController.update();\n  if (defined(this._deviceOrientationCameraController)) {\n    this._deviceOrientationCameraController.update();\n  }\n\n  this.camera.update(this._mode);\n  this.camera._updateCameraChanged();\n\n  this._cameraUnderground = isCameraUnderground(this);\n};\n\nfunction updateDebugShowFramesPerSecond(scene, renderedThisFrame) {\n  if (scene.debugShowFramesPerSecond) {\n    if (!defined(scene._performanceDisplay)) {\n      var performanceContainer = document.createElement(\"div\");\n      performanceContainer.className =\n        \"cesium-performanceDisplay-defaultContainer\";\n      var container = scene._canvas.parentNode;\n      container.appendChild(performanceContainer);\n      var performanceDisplay = new PerformanceDisplay({\n        container: performanceContainer,\n      });\n      scene._performanceDisplay = performanceDisplay;\n      scene._performanceContainer = performanceContainer;\n    }\n\n    scene._performanceDisplay.throttled = scene.requestRenderMode;\n    scene._performanceDisplay.update(renderedThisFrame);\n  } else if (defined(scene._performanceDisplay)) {\n    scene._performanceDisplay =\n      scene._performanceDisplay && scene._performanceDisplay.destroy();\n    scene._performanceContainer.parentNode.removeChild(\n      scene._performanceContainer\n    );\n  }\n}\n\nfunction prePassesUpdate(scene) {\n  scene._jobScheduler.resetBudgets();\n\n  var frameState = scene._frameState;\n  var primitives = scene.primitives;\n  primitives.prePassesUpdate(frameState);\n\n  if (defined(scene.globe)) {\n    scene.globe.update(frameState);\n  }\n\n  scene._picking.update();\n  frameState.creditDisplay.update();\n}\n\nfunction postPassesUpdate(scene) {\n  var frameState = scene._frameState;\n  var primitives = scene.primitives;\n  primitives.postPassesUpdate(frameState);\n\n  RequestScheduler.update();\n}\n\nvar scratchBackgroundColor = new Color();\n\nfunction render(scene) {\n  var frameState = scene._frameState;\n\n  var context = scene.context;\n  var us = context.uniformState;\n\n  var view = scene._defaultView;\n  scene._view = view;\n\n  scene.updateFrameState();\n  frameState.passes.render = true;\n  frameState.passes.postProcess = scene.postProcessStages.hasSelected;\n  frameState.tilesetPassState = renderTilesetPassState;\n\n  var backgroundColor = defaultValue(scene.backgroundColor, Color.BLACK);\n  if (scene._hdr) {\n    backgroundColor = Color.clone(backgroundColor, scratchBackgroundColor);\n    backgroundColor.red = Math.pow(backgroundColor.red, scene.gamma);\n    backgroundColor.green = Math.pow(backgroundColor.green, scene.gamma);\n    backgroundColor.blue = Math.pow(backgroundColor.blue, scene.gamma);\n  }\n  frameState.backgroundColor = backgroundColor;\n\n  scene.fog.update(frameState);\n\n  us.update(frameState);\n\n  var shadowMap = scene.shadowMap;\n  if (defined(shadowMap) && shadowMap.enabled) {\n    if (!defined(scene.light) || scene.light instanceof SunLight) {\n      // Negate the sun direction so that it is from the Sun, not to the Sun\n      Cartesian3.negate(us.sunDirectionWC, scene._shadowMapCamera.direction);\n    } else {\n      Cartesian3.clone(scene.light.direction, scene._shadowMapCamera.direction);\n    }\n    frameState.shadowMaps.push(shadowMap);\n  }\n\n  scene._computeCommandList.length = 0;\n  scene._overlayCommandList.length = 0;\n\n  var viewport = view.viewport;\n  viewport.x = 0;\n  viewport.y = 0;\n  viewport.width = context.drawingBufferWidth;\n  viewport.height = context.drawingBufferHeight;\n\n  var passState = view.passState;\n  passState.framebuffer = undefined;\n  passState.blendingEnabled = undefined;\n  passState.scissorTest = undefined;\n  passState.viewport = BoundingRectangle.clone(viewport, passState.viewport);\n\n  if (defined(scene.globe)) {\n    scene.globe.beginFrame(frameState);\n  }\n\n  scene.updateEnvironment();\n  scene.updateAndExecuteCommands(passState, backgroundColor);\n  scene.resolveFramebuffers(passState);\n\n  passState.framebuffer = undefined;\n  executeOverlayCommands(scene, passState);\n\n  if (defined(scene.globe)) {\n    scene.globe.endFrame(frameState);\n\n    if (!scene.globe.tilesLoaded) {\n      scene._renderRequested = true;\n    }\n  }\n\n  context.endFrame();\n}\n\nfunction tryAndCatchError(scene, functionToExecute) {\n  try {\n    functionToExecute(scene);\n  } catch (error) {\n    scene._renderError.raiseEvent(scene, error);\n\n    if (scene.rethrowRenderErrors) {\n      throw error;\n    }\n  }\n}\n\nfunction updateMostDetailedRayPicks(scene) {\n  return scene._picking.updateMostDetailedRayPicks(scene);\n}\n\n/**\n * Update and render the scene.\n * @param {JulianDate} [time] The simulation time at which to render.\n *\n * @private\n */\nScene.prototype.render = function (time) {\n  /**\n   *\n   * Pre passes update. Execute any pass invariant code that should run before the passes here.\n   *\n   */\n  this._preUpdate.raiseEvent(this, time);\n\n  var frameState = this._frameState;\n  frameState.newFrame = false;\n\n  if (!defined(time)) {\n    time = JulianDate.now();\n  }\n\n  // Determine if shouldRender\n  var cameraChanged = this._view.checkForCameraUpdates(this);\n  var shouldRender =\n    !this.requestRenderMode ||\n    this._renderRequested ||\n    cameraChanged ||\n    this._logDepthBufferDirty ||\n    this._hdrDirty ||\n    this.mode === SceneMode.MORPHING;\n  if (\n    !shouldRender &&\n    defined(this.maximumRenderTimeChange) &&\n    defined(this._lastRenderTime)\n  ) {\n    var difference = Math.abs(\n      JulianDate.secondsDifference(this._lastRenderTime, time)\n    );\n    shouldRender = shouldRender || difference > this.maximumRenderTimeChange;\n  }\n\n  if (shouldRender) {\n    this._lastRenderTime = JulianDate.clone(time, this._lastRenderTime);\n    this._renderRequested = false;\n    this._logDepthBufferDirty = false;\n    this._hdrDirty = false;\n\n    var frameNumber = CesiumMath.incrementWrap(\n      frameState.frameNumber,\n      15000000.0,\n      1.0\n    );\n    updateFrameNumber(this, frameNumber, time);\n    frameState.newFrame = true;\n  }\n\n  tryAndCatchError(this, prePassesUpdate);\n\n  /**\n   *\n   * Passes update. Add any passes here\n   *\n   */\n  if (this.primitives.show) {\n    tryAndCatchError(this, updateMostDetailedRayPicks);\n    tryAndCatchError(this, updatePreloadPass);\n    tryAndCatchError(this, updatePreloadFlightPass);\n    if (!shouldRender) {\n      tryAndCatchError(this, updateRequestRenderModeDeferCheckPass);\n    }\n  }\n\n  this._postUpdate.raiseEvent(this, time);\n\n  if (shouldRender) {\n    this._preRender.raiseEvent(this, time);\n    frameState.creditDisplay.beginFrame();\n    tryAndCatchError(this, render);\n  }\n\n  /**\n   *\n   * Post passes update. Execute any pass invariant code that should run after the passes here.\n   *\n   */\n  updateDebugShowFramesPerSecond(this, shouldRender);\n  tryAndCatchError(this, postPassesUpdate);\n\n  // Often used to trigger events (so don't want in trycatch) that the user might be subscribed to. Things like the tile load events, ready promises, etc.\n  // We don't want those events to resolve during the render loop because the events might add new primitives\n  callAfterRenderFunctions(this);\n\n  if (shouldRender) {\n    this._postRender.raiseEvent(this, time);\n    frameState.creditDisplay.endFrame();\n  }\n};\n\n/**\n * Update and render the scene. Always forces a new render frame regardless of whether a render was\n * previously requested.\n * @param {JulianDate} [time] The simulation time at which to render.\n *\n * @private\n */\nScene.prototype.forceRender = function (time) {\n  this._renderRequested = true;\n  this.render(time);\n};\n\n/**\n * Requests a new rendered frame when {@link Scene#requestRenderMode} is set to <code>true</code>.\n * The render rate will not exceed the {@link CesiumWidget#targetFrameRate}.\n *\n * @see Scene#requestRenderMode\n */\nScene.prototype.requestRender = function () {\n  this._renderRequested = true;\n};\n\n/**\n * @private\n */\nScene.prototype.clampLineWidth = function (width) {\n  return Math.max(\n    ContextLimits.minimumAliasedLineWidth,\n    Math.min(width, ContextLimits.maximumAliasedLineWidth)\n  );\n};\n\n/**\n * Returns an object with a `primitive` property that contains the first (top) primitive in the scene\n * at a particular window coordinate or undefined if nothing is at the location. Other properties may\n * potentially be set depending on the type of primitive and may be used to further identify the picked object.\n * <p>\n * When a feature of a 3D Tiles tileset is picked, <code>pick</code> returns a {@link Cesium3DTileFeature} object.\n * </p>\n *\n * @example\n * // On mouse over, color the feature yellow.\n * handler.setInputAction(function(movement) {\n *     var feature = scene.pick(movement.endPosition);\n *     if (feature instanceof Cesium.Cesium3DTileFeature) {\n *         feature.color = Cesium.Color.YELLOW;\n *     }\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n *\n * @param {Cartesian2} windowPosition Window coordinates to perform picking on.\n * @param {Number} [width=3] Width of the pick rectangle.\n * @param {Number} [height=3] Height of the pick rectangle.\n * @returns {Object} Object containing the picked primitive.\n */\nScene.prototype.pick = function (windowPosition, width, height) {\n  return this._picking.pick(this, windowPosition, width, height);\n};\n\n/**\n * Returns the cartesian position reconstructed from the depth buffer and window position.\n * The returned position is in world coordinates. Used internally by camera functions to\n * prevent conversion to projected 2D coordinates and then back.\n * <p>\n * Set {@link Scene#pickTranslucentDepth} to <code>true</code> to include the depth of\n * translucent primitives; otherwise, this essentially picks through translucent primitives.\n * </p>\n *\n * @private\n *\n * @param {Cartesian2} windowPosition Window coordinates to perform picking on.\n * @param {Cartesian3} [result] The object on which to restore the result.\n * @returns {Cartesian3} The cartesian position in world coordinates.\n *\n * @exception {DeveloperError} Picking from the depth buffer is not supported. Check pickPositionSupported.\n */\nScene.prototype.pickPositionWorldCoordinates = function (\n  windowPosition,\n  result\n) {\n  return this._picking.pickPositionWorldCoordinates(\n    this,\n    windowPosition,\n    result\n  );\n};\n\n/**\n * Returns the cartesian position reconstructed from the depth buffer and window position.\n * <p>\n * The position reconstructed from the depth buffer in 2D may be slightly different from those\n * reconstructed in 3D and Columbus view. This is caused by the difference in the distribution\n * of depth values of perspective and orthographic projection.\n * </p>\n * <p>\n * Set {@link Scene#pickTranslucentDepth} to <code>true</code> to include the depth of\n * translucent primitives; otherwise, this essentially picks through translucent primitives.\n * </p>\n *\n * @param {Cartesian2} windowPosition Window coordinates to perform picking on.\n * @param {Cartesian3} [result] The object on which to restore the result.\n * @returns {Cartesian3} The cartesian position.\n *\n * @exception {DeveloperError} Picking from the depth buffer is not supported. Check pickPositionSupported.\n */\nScene.prototype.pickPosition = function (windowPosition, result) {\n  return this._picking.pickPosition(this, windowPosition, result);\n};\n\n/**\n * Returns a list of objects, each containing a `primitive` property, for all primitives at\n * a particular window coordinate position. Other properties may also be set depending on the\n * type of primitive and may be used to further identify the picked object. The primitives in\n * the list are ordered by their visual order in the scene (front to back).\n *\n * @param {Cartesian2} windowPosition Window coordinates to perform picking on.\n * @param {Number} [limit] If supplied, stop drilling after collecting this many picks.\n * @param {Number} [width=3] Width of the pick rectangle.\n * @param {Number} [height=3] Height of the pick rectangle.\n * @returns {Object[]} Array of objects, each containing 1 picked primitives.\n *\n * @exception {DeveloperError} windowPosition is undefined.\n *\n * @example\n * var pickedObjects = scene.drillPick(new Cesium.Cartesian2(100.0, 200.0));\n *\n * @see Scene#pick\n */\nScene.prototype.drillPick = function (windowPosition, limit, width, height) {\n  return this._picking.drillPick(this, windowPosition, limit, width, height);\n};\n\nfunction updatePreloadPass(scene) {\n  var frameState = scene._frameState;\n  preloadTilesetPassState.camera = frameState.camera;\n  preloadTilesetPassState.cullingVolume = frameState.cullingVolume;\n\n  var primitives = scene.primitives;\n  primitives.updateForPass(frameState, preloadTilesetPassState);\n}\n\nfunction updatePreloadFlightPass(scene) {\n  var frameState = scene._frameState;\n  var camera = frameState.camera;\n  if (!camera.canPreloadFlight()) {\n    return;\n  }\n\n  preloadFlightTilesetPassState.camera = scene.preloadFlightCamera;\n  preloadFlightTilesetPassState.cullingVolume =\n    scene.preloadFlightCullingVolume;\n\n  var primitives = scene.primitives;\n  primitives.updateForPass(frameState, preloadFlightTilesetPassState);\n}\n\nfunction updateRequestRenderModeDeferCheckPass(scene) {\n  // Check if any ignored requests are ready to go (to wake rendering up again)\n  scene.primitives.updateForPass(\n    scene._frameState,\n    requestRenderModeDeferCheckPassState\n  );\n}\n\n/**\n * Returns an object containing the first object intersected by the ray and the position of intersection,\n * or <code>undefined</code> if there were no intersections. The intersected object has a <code>primitive</code>\n * property that contains the intersected primitive. Other properties may be set depending on the type of primitive\n * and may be used to further identify the picked object. The ray must be given in world coordinates.\n * <p>\n * This function only picks globe tiles and 3D Tiles that are rendered in the current view. Picks all other\n * primitives regardless of their visibility.\n * </p>\n *\n * @private\n *\n * @param {Ray} ray The ray.\n * @param {Object[]} [objectsToExclude] A list of primitives, entities, or 3D Tiles features to exclude from the ray intersection.\n * @param {Number} [width=0.1] Width of the intersection volume in meters.\n * @returns {Object} An object containing the object and position of the first intersection.\n *\n * @exception {DeveloperError} Ray intersections are only supported in 3D mode.\n */\nScene.prototype.pickFromRay = function (ray, objectsToExclude, width) {\n  return this._picking.pickFromRay(this, ray, objectsToExclude, width);\n};\n\n/**\n * Returns a list of objects, each containing the object intersected by the ray and the position of intersection.\n * The intersected object has a <code>primitive</code> property that contains the intersected primitive. Other\n * properties may also be set depending on the type of primitive and may be used to further identify the picked object.\n * The primitives in the list are ordered by first intersection to last intersection. The ray must be given in\n * world coordinates.\n * <p>\n * This function only picks globe tiles and 3D Tiles that are rendered in the current view. Picks all other\n * primitives regardless of their visibility.\n * </p>\n *\n * @private\n *\n * @param {Ray} ray The ray.\n * @param {Number} [limit=Number.MAX_VALUE] If supplied, stop finding intersections after this many intersections.\n * @param {Object[]} [objectsToExclude] A list of primitives, entities, or 3D Tiles features to exclude from the ray intersection.\n * @param {Number} [width=0.1] Width of the intersection volume in meters.\n * @returns {Object[]} List of objects containing the object and position of each intersection.\n *\n * @exception {DeveloperError} Ray intersections are only supported in 3D mode.\n */\nScene.prototype.drillPickFromRay = function (\n  ray,\n  limit,\n  objectsToExclude,\n  width\n) {\n  return this._picking.drillPickFromRay(\n    this,\n    ray,\n    limit,\n    objectsToExclude,\n    width\n  );\n};\n\n/**\n * Initiates an asynchronous {@link Scene#pickFromRay} request using the maximum level of detail for 3D Tilesets\n * regardless of visibility.\n *\n * @private\n *\n * @param {Ray} ray The ray.\n * @param {Object[]} [objectsToExclude] A list of primitives, entities, or 3D Tiles features to exclude from the ray intersection.\n * @param {Number} [width=0.1] Width of the intersection volume in meters.\n * @returns {Promise.<Object>} A promise that resolves to an object containing the object and position of the first intersection.\n *\n * @exception {DeveloperError} Ray intersections are only supported in 3D mode.\n */\nScene.prototype.pickFromRayMostDetailed = function (\n  ray,\n  objectsToExclude,\n  width\n) {\n  return this._picking.pickFromRayMostDetailed(\n    this,\n    ray,\n    objectsToExclude,\n    width\n  );\n};\n\n/**\n * Initiates an asynchronous {@link Scene#drillPickFromRay} request using the maximum level of detail for 3D Tilesets\n * regardless of visibility.\n *\n * @private\n *\n * @param {Ray} ray The ray.\n * @param {Number} [limit=Number.MAX_VALUE] If supplied, stop finding intersections after this many intersections.\n * @param {Object[]} [objectsToExclude] A list of primitives, entities, or 3D Tiles features to exclude from the ray intersection.\n * @param {Number} [width=0.1] Width of the intersection volume in meters.\n * @returns {Promise.<Object[]>} A promise that resolves to a list of objects containing the object and position of each intersection.\n *\n * @exception {DeveloperError} Ray intersections are only supported in 3D mode.\n */\nScene.prototype.drillPickFromRayMostDetailed = function (\n  ray,\n  limit,\n  objectsToExclude,\n  width\n) {\n  return this._picking.drillPickFromRayMostDetailed(\n    this,\n    ray,\n    limit,\n    objectsToExclude,\n    width\n  );\n};\n\n/**\n * Returns the height of scene geometry at the given cartographic position or <code>undefined</code> if there was no\n * scene geometry to sample height from. The height of the input position is ignored. May be used to clamp objects to\n * the globe, 3D Tiles, or primitives in the scene.\n * <p>\n * This function only samples height from globe tiles and 3D Tiles that are rendered in the current view. Samples height\n * from all other primitives regardless of their visibility.\n * </p>\n *\n * @param {Cartographic} position The cartographic position to sample height from.\n * @param {Object[]} [objectsToExclude] A list of primitives, entities, or 3D Tiles features to not sample height from.\n * @param {Number} [width=0.1] Width of the intersection volume in meters.\n * @returns {Number} The height. This may be <code>undefined</code> if there was no scene geometry to sample height from.\n *\n * @example\n * var position = new Cesium.Cartographic(-1.31968, 0.698874);\n * var height = viewer.scene.sampleHeight(position);\n * console.log(height);\n *\n * @see Scene#clampToHeight\n * @see Scene#clampToHeightMostDetailed\n * @see Scene#sampleHeightMostDetailed\n *\n * @exception {DeveloperError} sampleHeight is only supported in 3D mode.\n * @exception {DeveloperError} sampleHeight requires depth texture support. Check sampleHeightSupported.\n */\nScene.prototype.sampleHeight = function (position, objectsToExclude, width) {\n  return this._picking.sampleHeight(this, position, objectsToExclude, width);\n};\n\n/**\n * Clamps the given cartesian position to the scene geometry along the geodetic surface normal. Returns the\n * clamped position or <code>undefined</code> if there was no scene geometry to clamp to. May be used to clamp\n * objects to the globe, 3D Tiles, or primitives in the scene.\n * <p>\n * This function only clamps to globe tiles and 3D Tiles that are rendered in the current view. Clamps to\n * all other primitives regardless of their visibility.\n * </p>\n *\n * @param {Cartesian3} cartesian The cartesian position.\n * @param {Object[]} [objectsToExclude] A list of primitives, entities, or 3D Tiles features to not clamp to.\n * @param {Number} [width=0.1] Width of the intersection volume in meters.\n * @param {Cartesian3} [result] An optional object to return the clamped position.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided. This may be <code>undefined</code> if there was no scene geometry to clamp to.\n *\n * @example\n * // Clamp an entity to the underlying scene geometry\n * var position = entity.position.getValue(Cesium.JulianDate.now());\n * entity.position = viewer.scene.clampToHeight(position);\n *\n * @see Scene#sampleHeight\n * @see Scene#sampleHeightMostDetailed\n * @see Scene#clampToHeightMostDetailed\n *\n * @exception {DeveloperError} clampToHeight is only supported in 3D mode.\n * @exception {DeveloperError} clampToHeight requires depth texture support. Check clampToHeightSupported.\n */\nScene.prototype.clampToHeight = function (\n  cartesian,\n  objectsToExclude,\n  width,\n  result\n) {\n  return this._picking.clampToHeight(\n    this,\n    cartesian,\n    objectsToExclude,\n    width,\n    result\n  );\n};\n\n/**\n * Initiates an asynchronous {@link Scene#sampleHeight} query for an array of {@link Cartographic} positions\n * using the maximum level of detail for 3D Tilesets in the scene. The height of the input positions is ignored.\n * Returns a promise that is resolved when the query completes. Each point height is modified in place.\n * If a height cannot be determined because no geometry can be sampled at that location, or another error occurs,\n * the height is set to undefined.\n *\n * @param {Cartographic[]} positions The cartographic positions to update with sampled heights.\n * @param {Object[]} [objectsToExclude] A list of primitives, entities, or 3D Tiles features to not sample height from.\n * @param {Number} [width=0.1] Width of the intersection volume in meters.\n * @returns {Promise.<Number[]>} A promise that resolves to the provided list of positions when the query has completed.\n *\n * @example\n * var positions = [\n *     new Cesium.Cartographic(-1.31968, 0.69887),\n *     new Cesium.Cartographic(-1.10489, 0.83923)\n * ];\n * var promise = viewer.scene.sampleHeightMostDetailed(positions);\n * promise.then(function(updatedPosition) {\n *     // positions[0].height and positions[1].height have been updated.\n *     // updatedPositions is just a reference to positions.\n * }\n *\n * @see Scene#sampleHeight\n *\n * @exception {DeveloperError} sampleHeightMostDetailed is only supported in 3D mode.\n * @exception {DeveloperError} sampleHeightMostDetailed requires depth texture support. Check sampleHeightSupported.\n */\nScene.prototype.sampleHeightMostDetailed = function (\n  positions,\n  objectsToExclude,\n  width\n) {\n  return this._picking.sampleHeightMostDetailed(\n    this,\n    positions,\n    objectsToExclude,\n    width\n  );\n};\n\n/**\n * Initiates an asynchronous {@link Scene#clampToHeight} query for an array of {@link Cartesian3} positions\n * using the maximum level of detail for 3D Tilesets in the scene. Returns a promise that is resolved when\n * the query completes. Each position is modified in place. If a position cannot be clamped because no geometry\n * can be sampled at that location, or another error occurs, the element in the array is set to undefined.\n *\n * @param {Cartesian3[]} cartesians The cartesian positions to update with clamped positions.\n * @param {Object[]} [objectsToExclude] A list of primitives, entities, or 3D Tiles features to not clamp to.\n * @param {Number} [width=0.1] Width of the intersection volume in meters.\n * @returns {Promise.<Cartesian3[]>} A promise that resolves to the provided list of positions when the query has completed.\n *\n * @example\n * var cartesians = [\n *     entities[0].position.getValue(Cesium.JulianDate.now()),\n *     entities[1].position.getValue(Cesium.JulianDate.now())\n * ];\n * var promise = viewer.scene.clampToHeightMostDetailed(cartesians);\n * promise.then(function(updatedCartesians) {\n *     entities[0].position = updatedCartesians[0];\n *     entities[1].position = updatedCartesians[1];\n * }\n *\n * @see Scene#clampToHeight\n *\n * @exception {DeveloperError} clampToHeightMostDetailed is only supported in 3D mode.\n * @exception {DeveloperError} clampToHeightMostDetailed requires depth texture support. Check clampToHeightSupported.\n */\nScene.prototype.clampToHeightMostDetailed = function (\n  cartesians,\n  objectsToExclude,\n  width\n) {\n  return this._picking.clampToHeightMostDetailed(\n    this,\n    cartesians,\n    objectsToExclude,\n    width\n  );\n};\n\n/**\n * Transforms a position in cartesian coordinates to canvas coordinates.  This is commonly used to place an\n * HTML element at the same screen position as an object in the scene.\n *\n * @param {Cartesian3} position The position in cartesian coordinates.\n * @param {Cartesian2} [result] An optional object to return the input position transformed to canvas coordinates.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.  This may be <code>undefined</code> if the input position is near the center of the ellipsoid.\n *\n * @example\n * // Output the canvas position of longitude/latitude (0, 0) every time the mouse moves.\n * var scene = widget.scene;\n * var ellipsoid = scene.globe.ellipsoid;\n * var position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);\n * handler.setInputAction(function(movement) {\n *     console.log(scene.cartesianToCanvasCoordinates(position));\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n */\nScene.prototype.cartesianToCanvasCoordinates = function (position, result) {\n  return SceneTransforms.wgs84ToWindowCoordinates(this, position, result);\n};\n\n/**\n * Instantly completes an active transition.\n */\nScene.prototype.completeMorph = function () {\n  this._transitioner.completeMorph();\n};\n\n/**\n * Asynchronously transitions the scene to 2D.\n * @param {Number} [duration=2.0] The amount of time, in seconds, for transition animations to complete.\n */\nScene.prototype.morphTo2D = function (duration) {\n  var ellipsoid;\n  var globe = this.globe;\n  if (defined(globe)) {\n    ellipsoid = globe.ellipsoid;\n  } else {\n    ellipsoid = this.mapProjection.ellipsoid;\n  }\n  duration = defaultValue(duration, 2.0);\n  this._transitioner.morphTo2D(duration, ellipsoid);\n};\n\n/**\n * Asynchronously transitions the scene to Columbus View.\n * @param {Number} [duration=2.0] The amount of time, in seconds, for transition animations to complete.\n */\nScene.prototype.morphToColumbusView = function (duration) {\n  var ellipsoid;\n  var globe = this.globe;\n  if (defined(globe)) {\n    ellipsoid = globe.ellipsoid;\n  } else {\n    ellipsoid = this.mapProjection.ellipsoid;\n  }\n  duration = defaultValue(duration, 2.0);\n  this._transitioner.morphToColumbusView(duration, ellipsoid);\n};\n\n/**\n * Asynchronously transitions the scene to 3D.\n * @param {Number} [duration=2.0] The amount of time, in seconds, for transition animations to complete.\n */\nScene.prototype.morphTo3D = function (duration) {\n  var ellipsoid;\n  var globe = this.globe;\n  if (defined(globe)) {\n    ellipsoid = globe.ellipsoid;\n  } else {\n    ellipsoid = this.mapProjection.ellipsoid;\n  }\n  duration = defaultValue(duration, 2.0);\n  this._transitioner.morphTo3D(duration, ellipsoid);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see Scene#destroy\n */\nScene.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * scene = scene && scene.destroy();\n *\n * @see Scene#isDestroyed\n */\nScene.prototype.destroy = function () {\n  this._tweens.removeAll();\n  this._computeEngine = this._computeEngine && this._computeEngine.destroy();\n  this._screenSpaceCameraController =\n    this._screenSpaceCameraController &&\n    this._screenSpaceCameraController.destroy();\n  this._deviceOrientationCameraController =\n    this._deviceOrientationCameraController &&\n    !this._deviceOrientationCameraController.isDestroyed() &&\n    this._deviceOrientationCameraController.destroy();\n  this._primitives = this._primitives && this._primitives.destroy();\n  this._groundPrimitives =\n    this._groundPrimitives && this._groundPrimitives.destroy();\n  this._globe = this._globe && this._globe.destroy();\n  this.skyBox = this.skyBox && this.skyBox.destroy();\n  this.skyAtmosphere = this.skyAtmosphere && this.skyAtmosphere.destroy();\n  this._debugSphere = this._debugSphere && this._debugSphere.destroy();\n  this.sun = this.sun && this.sun.destroy();\n  this._sunPostProcess = this._sunPostProcess && this._sunPostProcess.destroy();\n  this._depthPlane = this._depthPlane && this._depthPlane.destroy();\n  this._transitioner = this._transitioner && this._transitioner.destroy();\n  this._debugFrustumPlanes =\n    this._debugFrustumPlanes && this._debugFrustumPlanes.destroy();\n  this._brdfLutGenerator =\n    this._brdfLutGenerator && this._brdfLutGenerator.destroy();\n  this._picking = this._picking && this._picking.destroy();\n\n  this._defaultView = this._defaultView && this._defaultView.destroy();\n  this._view = undefined;\n\n  if (this._removeCreditContainer) {\n    this._canvas.parentNode.removeChild(this._creditContainer);\n  }\n\n  this.postProcessStages =\n    this.postProcessStages && this.postProcessStages.destroy();\n\n  this._context = this._context && this._context.destroy();\n  this._frameState.creditDisplay =\n    this._frameState.creditDisplay && this._frameState.creditDisplay.destroy();\n\n  if (defined(this._performanceDisplay)) {\n    this._performanceDisplay =\n      this._performanceDisplay && this._performanceDisplay.destroy();\n    this._performanceContainer.parentNode.removeChild(\n      this._performanceContainer\n    );\n  }\n\n  this._removeRequestListenerCallback();\n  this._removeTaskProcessorListenerCallback();\n  for (var i = 0; i < this._removeGlobeCallbacks.length; ++i) {\n    this._removeGlobeCallbacks[i]();\n  }\n  this._removeGlobeCallbacks.length = 0;\n\n  return destroyObject(this);\n};\nexport default Scene;\n"]},"metadata":{},"sourceType":"module"}