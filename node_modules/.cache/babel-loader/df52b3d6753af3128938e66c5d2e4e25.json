{"ast":null,"code":"import when from \"../ThirdParty/when.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport sampleTerrain from \"./sampleTerrain.js\";\nvar scratchCartesian2 = new Cartesian2();\n/**\n * Initiates a sampleTerrain() request at the maximum available tile level for a terrain dataset.\n *\n * @exports sampleTerrainMostDetailed\n *\n * @param {TerrainProvider} terrainProvider The terrain provider from which to query heights.\n * @param {Cartographic[]} positions The positions to update with terrain heights.\n * @returns {Promise.<Cartographic[]>} A promise that resolves to the provided list of positions when terrain the query has completed.  This\n *                                     promise will reject if the terrain provider's `availability` property is undefined.\n *\n * @example\n * // Query the terrain height of two Cartographic positions\n * var terrainProvider = Cesium.createWorldTerrain();\n * var positions = [\n *     Cesium.Cartographic.fromDegrees(86.925145, 27.988257),\n *     Cesium.Cartographic.fromDegrees(87.0, 28.0)\n * ];\n * var promise = Cesium.sampleTerrainMostDetailed(terrainProvider, positions);\n * Cesium.when(promise, function(updatedPositions) {\n *     // positions[0].height and positions[1].height have been updated.\n *     // updatedPositions is just a reference to positions.\n * });\n */\n\nfunction sampleTerrainMostDetailed(terrainProvider, positions) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(terrainProvider)) {\n    throw new DeveloperError(\"terrainProvider is required.\");\n  }\n\n  if (!defined(positions)) {\n    throw new DeveloperError(\"positions is required.\");\n  } //>>includeEnd('debug');\n\n\n  return terrainProvider.readyPromise.then(function () {\n    var byLevel = [];\n    var maxLevels = [];\n    var availability = terrainProvider.availability; //>>includeStart('debug', pragmas.debug);\n\n    if (!defined(availability)) {\n      throw new DeveloperError(\"sampleTerrainMostDetailed requires a terrain provider that has tile availability.\");\n    } //>>includeEnd('debug');\n\n\n    var promises = [];\n\n    for (var i = 0; i < positions.length; ++i) {\n      var position = positions[i];\n      var maxLevel = availability.computeMaximumLevelAtPosition(position);\n      maxLevels[i] = maxLevel;\n\n      if (maxLevel === 0) {\n        // This is a special case where we have a parent terrain and we are requesting\n        // heights from an area that isn't covered by the top level terrain at all.\n        // This will essentially trigger the loading of the parent terrains root tile\n        terrainProvider.tilingScheme.positionToTileXY(position, 1, scratchCartesian2);\n        var promise = terrainProvider.loadTileDataAvailability(scratchCartesian2.x, scratchCartesian2.y, 1);\n\n        if (defined(promise)) {\n          promises.push(promise);\n        }\n      }\n\n      var atLevel = byLevel[maxLevel];\n\n      if (!defined(atLevel)) {\n        byLevel[maxLevel] = atLevel = [];\n      }\n\n      atLevel.push(position);\n    }\n\n    return when.all(promises).then(function () {\n      return when.all(byLevel.map(function (positionsAtLevel, index) {\n        if (defined(positionsAtLevel)) {\n          return sampleTerrain(terrainProvider, index, positionsAtLevel);\n        }\n      }));\n    }).then(function () {\n      var changedPositions = [];\n\n      for (var i = 0; i < positions.length; ++i) {\n        var position = positions[i];\n        var maxLevel = availability.computeMaximumLevelAtPosition(position);\n\n        if (maxLevel !== maxLevels[i]) {\n          // Now that we loaded the max availability, a higher level has become available\n          changedPositions.push(position);\n        }\n      }\n\n      if (changedPositions.length > 0) {\n        return sampleTerrainMostDetailed(terrainProvider, changedPositions);\n      }\n    }).then(function () {\n      return positions;\n    });\n  });\n}\n\nexport default sampleTerrainMostDetailed;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/sampleTerrainMostDetailed.js"],"names":["when","Cartesian2","defined","DeveloperError","sampleTerrain","scratchCartesian2","sampleTerrainMostDetailed","terrainProvider","positions","readyPromise","then","byLevel","maxLevels","availability","promises","i","length","position","maxLevel","computeMaximumLevelAtPosition","tilingScheme","positionToTileXY","promise","loadTileDataAvailability","x","y","push","atLevel","all","map","positionsAtLevel","index","changedPositions"],"mappings":"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","sourcesContent":["import when from \"../ThirdParty/when.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport sampleTerrain from \"./sampleTerrain.js\";\n\nvar scratchCartesian2 = new Cartesian2();\n\n/**\n * Initiates a sampleTerrain() request at the maximum available tile level for a terrain dataset.\n *\n * @exports sampleTerrainMostDetailed\n *\n * @param {TerrainProvider} terrainProvider The terrain provider from which to query heights.\n * @param {Cartographic[]} positions The positions to update with terrain heights.\n * @returns {Promise.<Cartographic[]>} A promise that resolves to the provided list of positions when terrain the query has completed.  This\n *                                     promise will reject if the terrain provider's `availability` property is undefined.\n *\n * @example\n * // Query the terrain height of two Cartographic positions\n * var terrainProvider = Cesium.createWorldTerrain();\n * var positions = [\n *     Cesium.Cartographic.fromDegrees(86.925145, 27.988257),\n *     Cesium.Cartographic.fromDegrees(87.0, 28.0)\n * ];\n * var promise = Cesium.sampleTerrainMostDetailed(terrainProvider, positions);\n * Cesium.when(promise, function(updatedPositions) {\n *     // positions[0].height and positions[1].height have been updated.\n *     // updatedPositions is just a reference to positions.\n * });\n */\nfunction sampleTerrainMostDetailed(terrainProvider, positions) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(terrainProvider)) {\n    throw new DeveloperError(\"terrainProvider is required.\");\n  }\n  if (!defined(positions)) {\n    throw new DeveloperError(\"positions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return terrainProvider.readyPromise.then(function () {\n    var byLevel = [];\n    var maxLevels = [];\n\n    var availability = terrainProvider.availability;\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(availability)) {\n      throw new DeveloperError(\n        \"sampleTerrainMostDetailed requires a terrain provider that has tile availability.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    var promises = [];\n    for (var i = 0; i < positions.length; ++i) {\n      var position = positions[i];\n      var maxLevel = availability.computeMaximumLevelAtPosition(position);\n      maxLevels[i] = maxLevel;\n      if (maxLevel === 0) {\n        // This is a special case where we have a parent terrain and we are requesting\n        // heights from an area that isn't covered by the top level terrain at all.\n        // This will essentially trigger the loading of the parent terrains root tile\n        terrainProvider.tilingScheme.positionToTileXY(\n          position,\n          1,\n          scratchCartesian2\n        );\n        var promise = terrainProvider.loadTileDataAvailability(\n          scratchCartesian2.x,\n          scratchCartesian2.y,\n          1\n        );\n        if (defined(promise)) {\n          promises.push(promise);\n        }\n      }\n\n      var atLevel = byLevel[maxLevel];\n      if (!defined(atLevel)) {\n        byLevel[maxLevel] = atLevel = [];\n      }\n      atLevel.push(position);\n    }\n\n    return when\n      .all(promises)\n      .then(function () {\n        return when.all(\n          byLevel.map(function (positionsAtLevel, index) {\n            if (defined(positionsAtLevel)) {\n              return sampleTerrain(terrainProvider, index, positionsAtLevel);\n            }\n          })\n        );\n      })\n      .then(function () {\n        var changedPositions = [];\n        for (var i = 0; i < positions.length; ++i) {\n          var position = positions[i];\n          var maxLevel = availability.computeMaximumLevelAtPosition(position);\n\n          if (maxLevel !== maxLevels[i]) {\n            // Now that we loaded the max availability, a higher level has become available\n            changedPositions.push(position);\n          }\n        }\n\n        if (changedPositions.length > 0) {\n          return sampleTerrainMostDetailed(terrainProvider, changedPositions);\n        }\n      })\n      .then(function () {\n        return positions;\n      });\n  });\n}\nexport default sampleTerrainMostDetailed;\n"]},"metadata":{},"sourceType":"module"}