{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport HeadingPitchRange from \"../Core/HeadingPitchRange.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nvar updateTransformMatrix3Scratch1 = new Matrix3();\nvar updateTransformMatrix3Scratch2 = new Matrix3();\nvar updateTransformMatrix3Scratch3 = new Matrix3();\nvar updateTransformMatrix4Scratch = new Matrix4();\nvar updateTransformCartesian3Scratch1 = new Cartesian3();\nvar updateTransformCartesian3Scratch2 = new Cartesian3();\nvar updateTransformCartesian3Scratch3 = new Cartesian3();\nvar updateTransformCartesian3Scratch4 = new Cartesian3();\nvar updateTransformCartesian3Scratch5 = new Cartesian3();\nvar updateTransformCartesian3Scratch6 = new Cartesian3();\nvar deltaTime = new JulianDate();\nvar northUpAxisFactor = 1.25; // times ellipsoid's maximum radius\n\nfunction updateTransform(that, camera, updateLookAt, saveCamera, positionProperty, time, ellipsoid) {\n  var mode = that.scene.mode;\n  var cartesian = positionProperty.getValue(time, that._lastCartesian);\n\n  if (defined(cartesian)) {\n    var hasBasis = false;\n    var invertVelocity = false;\n    var xBasis;\n    var yBasis;\n    var zBasis;\n\n    if (mode === SceneMode.SCENE3D) {\n      // The time delta was determined based on how fast satellites move compared to vehicles near the surface.\n      // Slower moving vehicles will most likely default to east-north-up, while faster ones will be VVLH.\n      JulianDate.addSeconds(time, 0.001, deltaTime);\n      var deltaCartesian = positionProperty.getValue(deltaTime, updateTransformCartesian3Scratch1); // If no valid position at (time + 0.001), sample at (time - 0.001) and invert the vector\n\n      if (!defined(deltaCartesian)) {\n        JulianDate.addSeconds(time, -0.001, deltaTime);\n        deltaCartesian = positionProperty.getValue(deltaTime, updateTransformCartesian3Scratch1);\n        invertVelocity = true;\n      }\n\n      if (defined(deltaCartesian)) {\n        var toInertial = Transforms.computeFixedToIcrfMatrix(time, updateTransformMatrix3Scratch1);\n        var toInertialDelta = Transforms.computeFixedToIcrfMatrix(deltaTime, updateTransformMatrix3Scratch2);\n        var toFixed;\n\n        if (!defined(toInertial) || !defined(toInertialDelta)) {\n          toFixed = Transforms.computeTemeToPseudoFixedMatrix(time, updateTransformMatrix3Scratch3);\n          toInertial = Matrix3.transpose(toFixed, updateTransformMatrix3Scratch1);\n          toInertialDelta = Transforms.computeTemeToPseudoFixedMatrix(deltaTime, updateTransformMatrix3Scratch2);\n          Matrix3.transpose(toInertialDelta, toInertialDelta);\n        } else {\n          toFixed = Matrix3.transpose(toInertial, updateTransformMatrix3Scratch3);\n        }\n\n        var inertialCartesian = Matrix3.multiplyByVector(toInertial, cartesian, updateTransformCartesian3Scratch5);\n        var inertialDeltaCartesian = Matrix3.multiplyByVector(toInertialDelta, deltaCartesian, updateTransformCartesian3Scratch6);\n        Cartesian3.subtract(inertialCartesian, inertialDeltaCartesian, updateTransformCartesian3Scratch4);\n        var inertialVelocity = Cartesian3.magnitude(updateTransformCartesian3Scratch4) * 1000.0; // meters/sec\n\n        var mu = CesiumMath.GRAVITATIONALPARAMETER; // m^3 / sec^2\n\n        var semiMajorAxis = -mu / (inertialVelocity * inertialVelocity - 2 * mu / Cartesian3.magnitude(inertialCartesian));\n\n        if (semiMajorAxis < 0 || semiMajorAxis > northUpAxisFactor * ellipsoid.maximumRadius) {\n          // North-up viewing from deep space.\n          // X along the nadir\n          xBasis = updateTransformCartesian3Scratch2;\n          Cartesian3.normalize(cartesian, xBasis);\n          Cartesian3.negate(xBasis, xBasis); // Z is North\n\n          zBasis = Cartesian3.clone(Cartesian3.UNIT_Z, updateTransformCartesian3Scratch3); // Y is along the cross of z and x (right handed basis / in the direction of motion)\n\n          yBasis = Cartesian3.cross(zBasis, xBasis, updateTransformCartesian3Scratch1);\n\n          if (Cartesian3.magnitude(yBasis) > CesiumMath.EPSILON7) {\n            Cartesian3.normalize(xBasis, xBasis);\n            Cartesian3.normalize(yBasis, yBasis);\n            zBasis = Cartesian3.cross(xBasis, yBasis, updateTransformCartesian3Scratch3);\n            Cartesian3.normalize(zBasis, zBasis);\n            hasBasis = true;\n          }\n        } else if (!Cartesian3.equalsEpsilon(cartesian, deltaCartesian, CesiumMath.EPSILON7)) {\n          // Approximation of VVLH (Vehicle Velocity Local Horizontal) with the Z-axis flipped.\n          // Z along the position\n          zBasis = updateTransformCartesian3Scratch2;\n          Cartesian3.normalize(inertialCartesian, zBasis);\n          Cartesian3.normalize(inertialDeltaCartesian, inertialDeltaCartesian); // Y is along the angular momentum vector (e.g. \"orbit normal\")\n\n          yBasis = Cartesian3.cross(zBasis, inertialDeltaCartesian, updateTransformCartesian3Scratch3);\n\n          if (invertVelocity) {\n            yBasis = Cartesian3.multiplyByScalar(yBasis, -1, yBasis);\n          }\n\n          if (!Cartesian3.equalsEpsilon(yBasis, Cartesian3.ZERO, CesiumMath.EPSILON7)) {\n            // X is along the cross of y and z (right handed basis / in the direction of motion)\n            xBasis = Cartesian3.cross(yBasis, zBasis, updateTransformCartesian3Scratch1);\n            Matrix3.multiplyByVector(toFixed, xBasis, xBasis);\n            Matrix3.multiplyByVector(toFixed, yBasis, yBasis);\n            Matrix3.multiplyByVector(toFixed, zBasis, zBasis);\n            Cartesian3.normalize(xBasis, xBasis);\n            Cartesian3.normalize(yBasis, yBasis);\n            Cartesian3.normalize(zBasis, zBasis);\n            hasBasis = true;\n          }\n        }\n      }\n    }\n\n    if (defined(that.boundingSphere)) {\n      cartesian = that.boundingSphere.center;\n    }\n\n    var position;\n    var direction;\n    var up;\n\n    if (saveCamera) {\n      position = Cartesian3.clone(camera.position, updateTransformCartesian3Scratch4);\n      direction = Cartesian3.clone(camera.direction, updateTransformCartesian3Scratch5);\n      up = Cartesian3.clone(camera.up, updateTransformCartesian3Scratch6);\n    }\n\n    var transform = updateTransformMatrix4Scratch;\n\n    if (hasBasis) {\n      transform[0] = xBasis.x;\n      transform[1] = xBasis.y;\n      transform[2] = xBasis.z;\n      transform[3] = 0.0;\n      transform[4] = yBasis.x;\n      transform[5] = yBasis.y;\n      transform[6] = yBasis.z;\n      transform[7] = 0.0;\n      transform[8] = zBasis.x;\n      transform[9] = zBasis.y;\n      transform[10] = zBasis.z;\n      transform[11] = 0.0;\n      transform[12] = cartesian.x;\n      transform[13] = cartesian.y;\n      transform[14] = cartesian.z;\n      transform[15] = 0.0;\n    } else {\n      // Stationary or slow-moving, low-altitude objects use East-North-Up.\n      Transforms.eastNorthUpToFixedFrame(cartesian, ellipsoid, transform);\n    }\n\n    camera._setTransform(transform);\n\n    if (saveCamera) {\n      Cartesian3.clone(position, camera.position);\n      Cartesian3.clone(direction, camera.direction);\n      Cartesian3.clone(up, camera.up);\n      Cartesian3.cross(direction, up, camera.right);\n    }\n  }\n\n  if (updateLookAt) {\n    var offset = mode === SceneMode.SCENE2D || Cartesian3.equals(that._offset3D, Cartesian3.ZERO) ? undefined : that._offset3D;\n    camera.lookAtTransform(camera.transform, offset);\n  }\n}\n/**\n * A utility object for tracking an entity with the camera.\n * @alias EntityView\n * @constructor\n *\n * @param {Entity} entity The entity to track with the camera.\n * @param {Scene} scene The scene to use.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use for orienting the camera.\n */\n\n\nfunction EntityView(entity, scene, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"entity\", entity);\n  Check.defined(\"scene\", scene); //>>includeEnd('debug');\n\n  /**\n   * The entity to track with the camera.\n   * @type {Entity}\n   */\n\n  this.entity = entity;\n  /**\n   * The scene in which to track the object.\n   * @type {Scene}\n   */\n\n  this.scene = scene;\n  /**\n   * The ellipsoid to use for orienting the camera.\n   * @type {Ellipsoid}\n   */\n\n  this.ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  /**\n   * The bounding sphere of the object.\n   * @type {BoundingSphere}\n   */\n\n  this.boundingSphere = undefined; // Shadow copies of the objects so we can detect changes.\n\n  this._lastEntity = undefined;\n  this._mode = undefined;\n  this._lastCartesian = new Cartesian3();\n  this._defaultOffset3D = undefined;\n  this._offset3D = new Cartesian3();\n} // STATIC properties defined here, not per-instance.\n\n\nObject.defineProperties(EntityView, {\n  /**\n   * Gets or sets a camera offset that will be used to\n   * initialize subsequent EntityViews.\n   * @memberof EntityView\n   * @type {Cartesian3}\n   */\n  defaultOffset3D: {\n    get: function get() {\n      return this._defaultOffset3D;\n    },\n    set: function set(vector) {\n      this._defaultOffset3D = Cartesian3.clone(vector, new Cartesian3());\n    }\n  }\n}); // Initialize the static property.\n\nEntityView.defaultOffset3D = new Cartesian3(-14000, 3500, 3500);\nvar scratchHeadingPitchRange = new HeadingPitchRange();\nvar scratchCartesian = new Cartesian3();\n/**\n * Should be called each animation frame to update the camera\n * to the latest settings.\n * @param {JulianDate} time The current animation time.\n * @param {BoundingSphere} [boundingSphere] bounding sphere of the object.\n */\n\nEntityView.prototype.update = function (time, boundingSphere) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time); //>>includeEnd('debug');\n\n  var scene = this.scene;\n  var ellipsoid = this.ellipsoid;\n  var sceneMode = scene.mode;\n\n  if (sceneMode === SceneMode.MORPHING) {\n    return;\n  }\n\n  var entity = this.entity;\n  var positionProperty = entity.position;\n\n  if (!defined(positionProperty)) {\n    return;\n  }\n\n  var objectChanged = entity !== this._lastEntity;\n  var sceneModeChanged = sceneMode !== this._mode;\n  var camera = scene.camera;\n  var updateLookAt = objectChanged || sceneModeChanged;\n  var saveCamera = true;\n\n  if (objectChanged) {\n    var viewFromProperty = entity.viewFrom;\n    var hasViewFrom = defined(viewFromProperty);\n\n    if (!hasViewFrom && defined(boundingSphere)) {\n      // The default HPR is not ideal for high altitude objects so\n      // we scale the pitch as we get further from the earth for a more\n      // downward view.\n      scratchHeadingPitchRange.pitch = -CesiumMath.PI_OVER_FOUR;\n      scratchHeadingPitchRange.range = 0;\n      var position = positionProperty.getValue(time, scratchCartesian);\n\n      if (defined(position)) {\n        var factor = 2 - 1 / Math.max(1, Cartesian3.magnitude(position) / ellipsoid.maximumRadius);\n        scratchHeadingPitchRange.pitch *= factor;\n      }\n\n      camera.viewBoundingSphere(boundingSphere, scratchHeadingPitchRange);\n      this.boundingSphere = boundingSphere;\n      updateLookAt = false;\n      saveCamera = false;\n    } else if (!hasViewFrom || !defined(viewFromProperty.getValue(time, this._offset3D))) {\n      Cartesian3.clone(EntityView._defaultOffset3D, this._offset3D);\n    }\n  } else if (!sceneModeChanged && this._mode !== SceneMode.SCENE2D) {\n    Cartesian3.clone(camera.position, this._offset3D);\n  }\n\n  this._lastEntity = entity;\n  this._mode = sceneMode;\n  updateTransform(this, camera, updateLookAt, saveCamera, positionProperty, time, ellipsoid);\n};\n\nexport default EntityView;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/DataSources/EntityView.js"],"names":["Cartesian3","Check","defaultValue","defined","Ellipsoid","HeadingPitchRange","JulianDate","CesiumMath","Matrix3","Matrix4","Transforms","SceneMode","updateTransformMatrix3Scratch1","updateTransformMatrix3Scratch2","updateTransformMatrix3Scratch3","updateTransformMatrix4Scratch","updateTransformCartesian3Scratch1","updateTransformCartesian3Scratch2","updateTransformCartesian3Scratch3","updateTransformCartesian3Scratch4","updateTransformCartesian3Scratch5","updateTransformCartesian3Scratch6","deltaTime","northUpAxisFactor","updateTransform","that","camera","updateLookAt","saveCamera","positionProperty","time","ellipsoid","mode","scene","cartesian","getValue","_lastCartesian","hasBasis","invertVelocity","xBasis","yBasis","zBasis","SCENE3D","addSeconds","deltaCartesian","toInertial","computeFixedToIcrfMatrix","toInertialDelta","toFixed","computeTemeToPseudoFixedMatrix","transpose","inertialCartesian","multiplyByVector","inertialDeltaCartesian","subtract","inertialVelocity","magnitude","mu","GRAVITATIONALPARAMETER","semiMajorAxis","maximumRadius","normalize","negate","clone","UNIT_Z","cross","EPSILON7","equalsEpsilon","multiplyByScalar","ZERO","boundingSphere","center","position","direction","up","transform","x","y","z","eastNorthUpToFixedFrame","_setTransform","right","offset","SCENE2D","equals","_offset3D","undefined","lookAtTransform","EntityView","entity","WGS84","_lastEntity","_mode","_defaultOffset3D","Object","defineProperties","defaultOffset3D","get","set","vector","scratchHeadingPitchRange","scratchCartesian","prototype","update","sceneMode","MORPHING","objectChanged","sceneModeChanged","viewFromProperty","viewFrom","hasViewFrom","pitch","PI_OVER_FOUR","range","factor","Math","max","viewBoundingSphere"],"mappings":"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","sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport HeadingPitchRange from \"../Core/HeadingPitchRange.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\n\nvar updateTransformMatrix3Scratch1 = new Matrix3();\nvar updateTransformMatrix3Scratch2 = new Matrix3();\nvar updateTransformMatrix3Scratch3 = new Matrix3();\nvar updateTransformMatrix4Scratch = new Matrix4();\nvar updateTransformCartesian3Scratch1 = new Cartesian3();\nvar updateTransformCartesian3Scratch2 = new Cartesian3();\nvar updateTransformCartesian3Scratch3 = new Cartesian3();\nvar updateTransformCartesian3Scratch4 = new Cartesian3();\nvar updateTransformCartesian3Scratch5 = new Cartesian3();\nvar updateTransformCartesian3Scratch6 = new Cartesian3();\nvar deltaTime = new JulianDate();\nvar northUpAxisFactor = 1.25; // times ellipsoid's maximum radius\n\nfunction updateTransform(\n  that,\n  camera,\n  updateLookAt,\n  saveCamera,\n  positionProperty,\n  time,\n  ellipsoid\n) {\n  var mode = that.scene.mode;\n  var cartesian = positionProperty.getValue(time, that._lastCartesian);\n  if (defined(cartesian)) {\n    var hasBasis = false;\n    var invertVelocity = false;\n    var xBasis;\n    var yBasis;\n    var zBasis;\n\n    if (mode === SceneMode.SCENE3D) {\n      // The time delta was determined based on how fast satellites move compared to vehicles near the surface.\n      // Slower moving vehicles will most likely default to east-north-up, while faster ones will be VVLH.\n      JulianDate.addSeconds(time, 0.001, deltaTime);\n      var deltaCartesian = positionProperty.getValue(\n        deltaTime,\n        updateTransformCartesian3Scratch1\n      );\n\n      // If no valid position at (time + 0.001), sample at (time - 0.001) and invert the vector\n      if (!defined(deltaCartesian)) {\n        JulianDate.addSeconds(time, -0.001, deltaTime);\n        deltaCartesian = positionProperty.getValue(\n          deltaTime,\n          updateTransformCartesian3Scratch1\n        );\n        invertVelocity = true;\n      }\n\n      if (defined(deltaCartesian)) {\n        var toInertial = Transforms.computeFixedToIcrfMatrix(\n          time,\n          updateTransformMatrix3Scratch1\n        );\n        var toInertialDelta = Transforms.computeFixedToIcrfMatrix(\n          deltaTime,\n          updateTransformMatrix3Scratch2\n        );\n        var toFixed;\n\n        if (!defined(toInertial) || !defined(toInertialDelta)) {\n          toFixed = Transforms.computeTemeToPseudoFixedMatrix(\n            time,\n            updateTransformMatrix3Scratch3\n          );\n          toInertial = Matrix3.transpose(\n            toFixed,\n            updateTransformMatrix3Scratch1\n          );\n          toInertialDelta = Transforms.computeTemeToPseudoFixedMatrix(\n            deltaTime,\n            updateTransformMatrix3Scratch2\n          );\n          Matrix3.transpose(toInertialDelta, toInertialDelta);\n        } else {\n          toFixed = Matrix3.transpose(\n            toInertial,\n            updateTransformMatrix3Scratch3\n          );\n        }\n\n        var inertialCartesian = Matrix3.multiplyByVector(\n          toInertial,\n          cartesian,\n          updateTransformCartesian3Scratch5\n        );\n        var inertialDeltaCartesian = Matrix3.multiplyByVector(\n          toInertialDelta,\n          deltaCartesian,\n          updateTransformCartesian3Scratch6\n        );\n\n        Cartesian3.subtract(\n          inertialCartesian,\n          inertialDeltaCartesian,\n          updateTransformCartesian3Scratch4\n        );\n        var inertialVelocity =\n          Cartesian3.magnitude(updateTransformCartesian3Scratch4) * 1000.0; // meters/sec\n\n        var mu = CesiumMath.GRAVITATIONALPARAMETER; // m^3 / sec^2\n        var semiMajorAxis =\n          -mu /\n          (inertialVelocity * inertialVelocity -\n            (2 * mu) / Cartesian3.magnitude(inertialCartesian));\n\n        if (\n          semiMajorAxis < 0 ||\n          semiMajorAxis > northUpAxisFactor * ellipsoid.maximumRadius\n        ) {\n          // North-up viewing from deep space.\n\n          // X along the nadir\n          xBasis = updateTransformCartesian3Scratch2;\n          Cartesian3.normalize(cartesian, xBasis);\n          Cartesian3.negate(xBasis, xBasis);\n\n          // Z is North\n          zBasis = Cartesian3.clone(\n            Cartesian3.UNIT_Z,\n            updateTransformCartesian3Scratch3\n          );\n\n          // Y is along the cross of z and x (right handed basis / in the direction of motion)\n          yBasis = Cartesian3.cross(\n            zBasis,\n            xBasis,\n            updateTransformCartesian3Scratch1\n          );\n          if (Cartesian3.magnitude(yBasis) > CesiumMath.EPSILON7) {\n            Cartesian3.normalize(xBasis, xBasis);\n            Cartesian3.normalize(yBasis, yBasis);\n\n            zBasis = Cartesian3.cross(\n              xBasis,\n              yBasis,\n              updateTransformCartesian3Scratch3\n            );\n            Cartesian3.normalize(zBasis, zBasis);\n\n            hasBasis = true;\n          }\n        } else if (\n          !Cartesian3.equalsEpsilon(\n            cartesian,\n            deltaCartesian,\n            CesiumMath.EPSILON7\n          )\n        ) {\n          // Approximation of VVLH (Vehicle Velocity Local Horizontal) with the Z-axis flipped.\n\n          // Z along the position\n          zBasis = updateTransformCartesian3Scratch2;\n          Cartesian3.normalize(inertialCartesian, zBasis);\n          Cartesian3.normalize(inertialDeltaCartesian, inertialDeltaCartesian);\n\n          // Y is along the angular momentum vector (e.g. \"orbit normal\")\n          yBasis = Cartesian3.cross(\n            zBasis,\n            inertialDeltaCartesian,\n            updateTransformCartesian3Scratch3\n          );\n\n          if (invertVelocity) {\n            yBasis = Cartesian3.multiplyByScalar(yBasis, -1, yBasis);\n          }\n\n          if (\n            !Cartesian3.equalsEpsilon(\n              yBasis,\n              Cartesian3.ZERO,\n              CesiumMath.EPSILON7\n            )\n          ) {\n            // X is along the cross of y and z (right handed basis / in the direction of motion)\n            xBasis = Cartesian3.cross(\n              yBasis,\n              zBasis,\n              updateTransformCartesian3Scratch1\n            );\n\n            Matrix3.multiplyByVector(toFixed, xBasis, xBasis);\n            Matrix3.multiplyByVector(toFixed, yBasis, yBasis);\n            Matrix3.multiplyByVector(toFixed, zBasis, zBasis);\n\n            Cartesian3.normalize(xBasis, xBasis);\n            Cartesian3.normalize(yBasis, yBasis);\n            Cartesian3.normalize(zBasis, zBasis);\n\n            hasBasis = true;\n          }\n        }\n      }\n    }\n\n    if (defined(that.boundingSphere)) {\n      cartesian = that.boundingSphere.center;\n    }\n\n    var position;\n    var direction;\n    var up;\n\n    if (saveCamera) {\n      position = Cartesian3.clone(\n        camera.position,\n        updateTransformCartesian3Scratch4\n      );\n      direction = Cartesian3.clone(\n        camera.direction,\n        updateTransformCartesian3Scratch5\n      );\n      up = Cartesian3.clone(camera.up, updateTransformCartesian3Scratch6);\n    }\n\n    var transform = updateTransformMatrix4Scratch;\n    if (hasBasis) {\n      transform[0] = xBasis.x;\n      transform[1] = xBasis.y;\n      transform[2] = xBasis.z;\n      transform[3] = 0.0;\n      transform[4] = yBasis.x;\n      transform[5] = yBasis.y;\n      transform[6] = yBasis.z;\n      transform[7] = 0.0;\n      transform[8] = zBasis.x;\n      transform[9] = zBasis.y;\n      transform[10] = zBasis.z;\n      transform[11] = 0.0;\n      transform[12] = cartesian.x;\n      transform[13] = cartesian.y;\n      transform[14] = cartesian.z;\n      transform[15] = 0.0;\n    } else {\n      // Stationary or slow-moving, low-altitude objects use East-North-Up.\n      Transforms.eastNorthUpToFixedFrame(cartesian, ellipsoid, transform);\n    }\n\n    camera._setTransform(transform);\n\n    if (saveCamera) {\n      Cartesian3.clone(position, camera.position);\n      Cartesian3.clone(direction, camera.direction);\n      Cartesian3.clone(up, camera.up);\n      Cartesian3.cross(direction, up, camera.right);\n    }\n  }\n\n  if (updateLookAt) {\n    var offset =\n      mode === SceneMode.SCENE2D ||\n      Cartesian3.equals(that._offset3D, Cartesian3.ZERO)\n        ? undefined\n        : that._offset3D;\n    camera.lookAtTransform(camera.transform, offset);\n  }\n}\n\n/**\n * A utility object for tracking an entity with the camera.\n * @alias EntityView\n * @constructor\n *\n * @param {Entity} entity The entity to track with the camera.\n * @param {Scene} scene The scene to use.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use for orienting the camera.\n */\nfunction EntityView(entity, scene, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"entity\", entity);\n  Check.defined(\"scene\", scene);\n  //>>includeEnd('debug');\n\n  /**\n   * The entity to track with the camera.\n   * @type {Entity}\n   */\n  this.entity = entity;\n\n  /**\n   * The scene in which to track the object.\n   * @type {Scene}\n   */\n  this.scene = scene;\n\n  /**\n   * The ellipsoid to use for orienting the camera.\n   * @type {Ellipsoid}\n   */\n  this.ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  /**\n   * The bounding sphere of the object.\n   * @type {BoundingSphere}\n   */\n  this.boundingSphere = undefined;\n\n  // Shadow copies of the objects so we can detect changes.\n  this._lastEntity = undefined;\n  this._mode = undefined;\n\n  this._lastCartesian = new Cartesian3();\n  this._defaultOffset3D = undefined;\n\n  this._offset3D = new Cartesian3();\n}\n\n// STATIC properties defined here, not per-instance.\nObject.defineProperties(EntityView, {\n  /**\n   * Gets or sets a camera offset that will be used to\n   * initialize subsequent EntityViews.\n   * @memberof EntityView\n   * @type {Cartesian3}\n   */\n  defaultOffset3D: {\n    get: function () {\n      return this._defaultOffset3D;\n    },\n    set: function (vector) {\n      this._defaultOffset3D = Cartesian3.clone(vector, new Cartesian3());\n    },\n  },\n});\n\n// Initialize the static property.\nEntityView.defaultOffset3D = new Cartesian3(-14000, 3500, 3500);\n\nvar scratchHeadingPitchRange = new HeadingPitchRange();\nvar scratchCartesian = new Cartesian3();\n\n/**\n * Should be called each animation frame to update the camera\n * to the latest settings.\n * @param {JulianDate} time The current animation time.\n * @param {BoundingSphere} [boundingSphere] bounding sphere of the object.\n */\nEntityView.prototype.update = function (time, boundingSphere) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  //>>includeEnd('debug');\n\n  var scene = this.scene;\n  var ellipsoid = this.ellipsoid;\n  var sceneMode = scene.mode;\n  if (sceneMode === SceneMode.MORPHING) {\n    return;\n  }\n\n  var entity = this.entity;\n  var positionProperty = entity.position;\n  if (!defined(positionProperty)) {\n    return;\n  }\n  var objectChanged = entity !== this._lastEntity;\n  var sceneModeChanged = sceneMode !== this._mode;\n\n  var camera = scene.camera;\n\n  var updateLookAt = objectChanged || sceneModeChanged;\n  var saveCamera = true;\n\n  if (objectChanged) {\n    var viewFromProperty = entity.viewFrom;\n    var hasViewFrom = defined(viewFromProperty);\n\n    if (!hasViewFrom && defined(boundingSphere)) {\n      // The default HPR is not ideal for high altitude objects so\n      // we scale the pitch as we get further from the earth for a more\n      // downward view.\n      scratchHeadingPitchRange.pitch = -CesiumMath.PI_OVER_FOUR;\n      scratchHeadingPitchRange.range = 0;\n      var position = positionProperty.getValue(time, scratchCartesian);\n      if (defined(position)) {\n        var factor =\n          2 -\n          1 /\n            Math.max(\n              1,\n              Cartesian3.magnitude(position) / ellipsoid.maximumRadius\n            );\n        scratchHeadingPitchRange.pitch *= factor;\n      }\n\n      camera.viewBoundingSphere(boundingSphere, scratchHeadingPitchRange);\n      this.boundingSphere = boundingSphere;\n      updateLookAt = false;\n      saveCamera = false;\n    } else if (\n      !hasViewFrom ||\n      !defined(viewFromProperty.getValue(time, this._offset3D))\n    ) {\n      Cartesian3.clone(EntityView._defaultOffset3D, this._offset3D);\n    }\n  } else if (!sceneModeChanged && this._mode !== SceneMode.SCENE2D) {\n    Cartesian3.clone(camera.position, this._offset3D);\n  }\n\n  this._lastEntity = entity;\n  this._mode = sceneMode;\n\n  updateTransform(\n    this,\n    camera,\n    updateLookAt,\n    saveCamera,\n    positionProperty,\n    time,\n    ellipsoid\n  );\n};\nexport default EntityView;\n"]},"metadata":{},"sourceType":"module"}