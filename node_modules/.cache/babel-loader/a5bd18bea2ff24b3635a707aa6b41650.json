{"ast":null,"code":"import defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport ShaderProgram from \"./ShaderProgram.js\";\nimport ShaderSource from \"./ShaderSource.js\";\n/**\n * @private\n */\n\nfunction ShaderCache(context) {\n  this._context = context;\n  this._shaders = {};\n  this._numberOfShaders = 0;\n  this._shadersToRelease = {};\n}\n\nObject.defineProperties(ShaderCache.prototype, {\n  numberOfShaders: {\n    get: function () {\n      return this._numberOfShaders;\n    }\n  }\n});\n/**\n     * Returns a shader program from the cache, or creates and caches a new shader program,\n     * given the GLSL vertex and fragment shader source and attribute locations.\n     * <p>\n     * The difference between this and {@link ShaderCache#getShaderProgram}, is this is used to\n     * replace an existing reference to a shader program, which is passed as the first argument.\n     * </p>\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {ShaderProgram} [options.shaderProgram] The shader program that is being reassigned.\n     * @param {String|ShaderSource} options.vertexShaderSource The GLSL source for the vertex shader.\n     * @param {String|ShaderSource} options.fragmentShaderSource The GLSL source for the fragment shader.\n     * @param {Object} options.attributeLocations Indices for the attribute inputs to the vertex shader.\n\n     * @returns {ShaderProgram} The cached or newly created shader program.\n     *\n     *\n     * @example\n     * this._shaderProgram = context.shaderCache.replaceShaderProgram({\n     *     shaderProgram : this._shaderProgram,\n     *     vertexShaderSource : vs,\n     *     fragmentShaderSource : fs,\n     *     attributeLocations : attributeLocations\n     * });\n     *\n     * @see ShaderCache#getShaderProgram\n     */\n\nShaderCache.prototype.replaceShaderProgram = function (options) {\n  if (defined(options.shaderProgram)) {\n    options.shaderProgram.destroy();\n  }\n\n  return this.getShaderProgram(options);\n};\n/**\n * Returns a shader program from the cache, or creates and caches a new shader program,\n * given the GLSL vertex and fragment shader source and attribute locations.\n *\n * @param {Object} options Object with the following properties:\n * @param {String|ShaderSource} options.vertexShaderSource The GLSL source for the vertex shader.\n * @param {String|ShaderSource} options.fragmentShaderSource The GLSL source for the fragment shader.\n * @param {Object} options.attributeLocations Indices for the attribute inputs to the vertex shader.\n *\n * @returns {ShaderProgram} The cached or newly created shader program.\n */\n\n\nShaderCache.prototype.getShaderProgram = function (options) {\n  // convert shaders which are provided as strings into ShaderSource objects\n  // because ShaderSource handles all the automatic including of built-in functions, etc.\n  var vertexShaderSource = options.vertexShaderSource;\n  var fragmentShaderSource = options.fragmentShaderSource;\n  var attributeLocations = options.attributeLocations;\n\n  if (typeof vertexShaderSource === \"string\") {\n    vertexShaderSource = new ShaderSource({\n      sources: [vertexShaderSource]\n    });\n  }\n\n  if (typeof fragmentShaderSource === \"string\") {\n    fragmentShaderSource = new ShaderSource({\n      sources: [fragmentShaderSource]\n    });\n  }\n\n  var vertexShaderText = vertexShaderSource.createCombinedVertexShader(this._context);\n  var fragmentShaderText = fragmentShaderSource.createCombinedFragmentShader(this._context);\n  var keyword = vertexShaderText + fragmentShaderText + JSON.stringify(attributeLocations);\n  var cachedShader;\n\n  if (defined(this._shaders[keyword])) {\n    cachedShader = this._shaders[keyword]; // No longer want to release this if it was previously released.\n\n    delete this._shadersToRelease[keyword];\n  } else {\n    var context = this._context;\n    var shaderProgram = new ShaderProgram({\n      gl: context._gl,\n      logShaderCompilation: context.logShaderCompilation,\n      debugShaders: context.debugShaders,\n      vertexShaderSource: vertexShaderSource,\n      vertexShaderText: vertexShaderText,\n      fragmentShaderSource: fragmentShaderSource,\n      fragmentShaderText: fragmentShaderText,\n      attributeLocations: attributeLocations\n    });\n    cachedShader = {\n      cache: this,\n      shaderProgram: shaderProgram,\n      keyword: keyword,\n      derivedKeywords: [],\n      count: 0\n    }; // A shader can't be in more than one cache.\n\n    shaderProgram._cachedShader = cachedShader;\n    this._shaders[keyword] = cachedShader;\n    ++this._numberOfShaders;\n  }\n\n  ++cachedShader.count;\n  return cachedShader.shaderProgram;\n};\n\nShaderCache.prototype.replaceDerivedShaderProgram = function (shaderProgram, keyword, options) {\n  var cachedShader = shaderProgram._cachedShader;\n  var derivedKeyword = keyword + cachedShader.keyword;\n  var cachedDerivedShader = this._shaders[derivedKeyword];\n\n  if (defined(cachedDerivedShader)) {\n    destroyShader(this, cachedDerivedShader);\n    var index = cachedShader.derivedKeywords.indexOf(keyword);\n\n    if (index > -1) {\n      cachedShader.derivedKeywords.splice(index, 1);\n    }\n  }\n\n  return this.createDerivedShaderProgram(shaderProgram, keyword, options);\n};\n\nShaderCache.prototype.getDerivedShaderProgram = function (shaderProgram, keyword) {\n  var cachedShader = shaderProgram._cachedShader;\n  var derivedKeyword = keyword + cachedShader.keyword;\n  var cachedDerivedShader = this._shaders[derivedKeyword];\n\n  if (!defined(cachedDerivedShader)) {\n    return undefined;\n  }\n\n  return cachedDerivedShader.shaderProgram;\n};\n\nShaderCache.prototype.createDerivedShaderProgram = function (shaderProgram, keyword, options) {\n  var cachedShader = shaderProgram._cachedShader;\n  var derivedKeyword = keyword + cachedShader.keyword;\n  var vertexShaderSource = options.vertexShaderSource;\n  var fragmentShaderSource = options.fragmentShaderSource;\n  var attributeLocations = options.attributeLocations;\n\n  if (typeof vertexShaderSource === \"string\") {\n    vertexShaderSource = new ShaderSource({\n      sources: [vertexShaderSource]\n    });\n  }\n\n  if (typeof fragmentShaderSource === \"string\") {\n    fragmentShaderSource = new ShaderSource({\n      sources: [fragmentShaderSource]\n    });\n  }\n\n  var context = this._context;\n  var vertexShaderText = vertexShaderSource.createCombinedVertexShader(context);\n  var fragmentShaderText = fragmentShaderSource.createCombinedFragmentShader(context);\n  var derivedShaderProgram = new ShaderProgram({\n    gl: context._gl,\n    logShaderCompilation: context.logShaderCompilation,\n    debugShaders: context.debugShaders,\n    vertexShaderSource: vertexShaderSource,\n    vertexShaderText: vertexShaderText,\n    fragmentShaderSource: fragmentShaderSource,\n    fragmentShaderText: fragmentShaderText,\n    attributeLocations: attributeLocations\n  });\n  var derivedCachedShader = {\n    cache: this,\n    shaderProgram: derivedShaderProgram,\n    keyword: derivedKeyword,\n    derivedKeywords: [],\n    count: 0\n  };\n  cachedShader.derivedKeywords.push(keyword);\n  derivedShaderProgram._cachedShader = derivedCachedShader;\n  this._shaders[derivedKeyword] = derivedCachedShader;\n  return derivedShaderProgram;\n};\n\nfunction destroyShader(cache, cachedShader) {\n  var derivedKeywords = cachedShader.derivedKeywords;\n  var length = derivedKeywords.length;\n\n  for (var i = 0; i < length; ++i) {\n    var keyword = derivedKeywords[i] + cachedShader.keyword;\n    var derivedCachedShader = cache._shaders[keyword];\n    destroyShader(cache, derivedCachedShader);\n  }\n\n  delete cache._shaders[cachedShader.keyword];\n  cachedShader.shaderProgram.finalDestroy();\n}\n\nShaderCache.prototype.destroyReleasedShaderPrograms = function () {\n  var shadersToRelease = this._shadersToRelease;\n\n  for (var keyword in shadersToRelease) {\n    if (shadersToRelease.hasOwnProperty(keyword)) {\n      var cachedShader = shadersToRelease[keyword];\n      destroyShader(this, cachedShader);\n      --this._numberOfShaders;\n    }\n  }\n\n  this._shadersToRelease = {};\n};\n\nShaderCache.prototype.releaseShaderProgram = function (shaderProgram) {\n  if (defined(shaderProgram)) {\n    var cachedShader = shaderProgram._cachedShader;\n\n    if (cachedShader && --cachedShader.count === 0) {\n      this._shadersToRelease[cachedShader.keyword] = cachedShader;\n    }\n  }\n};\n\nShaderCache.prototype.isDestroyed = function () {\n  return false;\n};\n\nShaderCache.prototype.destroy = function () {\n  var shaders = this._shaders;\n\n  for (var keyword in shaders) {\n    if (shaders.hasOwnProperty(keyword)) {\n      shaders[keyword].shaderProgram.finalDestroy();\n    }\n  }\n\n  return destroyObject(this);\n};\n\nexport default ShaderCache;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Renderer/ShaderCache.js"],"names":["defined","destroyObject","ShaderProgram","ShaderSource","ShaderCache","context","_context","_shaders","_numberOfShaders","_shadersToRelease","Object","defineProperties","prototype","numberOfShaders","get","replaceShaderProgram","options","shaderProgram","destroy","getShaderProgram","vertexShaderSource","fragmentShaderSource","attributeLocations","sources","vertexShaderText","createCombinedVertexShader","fragmentShaderText","createCombinedFragmentShader","keyword","JSON","stringify","cachedShader","gl","_gl","logShaderCompilation","debugShaders","cache","derivedKeywords","count","_cachedShader","replaceDerivedShaderProgram","derivedKeyword","cachedDerivedShader","destroyShader","index","indexOf","splice","createDerivedShaderProgram","getDerivedShaderProgram","undefined","derivedShaderProgram","derivedCachedShader","push","length","i","finalDestroy","destroyReleasedShaderPrograms","shadersToRelease","hasOwnProperty","releaseShaderProgram","isDestroyed","shaders"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,oBAApB;AACA,OAAOC,aAAP,MAA0B,0BAA1B;AACA,OAAOC,aAAP,MAA0B,oBAA1B;AACA,OAAOC,YAAP,MAAyB,mBAAzB;AAEA;;;;AAGA,SAASC,WAAT,CAAqBC,OAArB,EAA8B;AAC5B,OAAKC,QAAL,GAAgBD,OAAhB;AACA,OAAKE,QAAL,GAAgB,EAAhB;AACA,OAAKC,gBAAL,GAAwB,CAAxB;AACA,OAAKC,iBAAL,GAAyB,EAAzB;AACD;;AAEDC,MAAM,CAACC,gBAAP,CAAwBP,WAAW,CAACQ,SAApC,EAA+C;AAC7CC,EAAAA,eAAe,EAAE;AACfC,IAAAA,GAAG,EAAE,YAAY;AACf,aAAO,KAAKN,gBAAZ;AACD;AAHc;AAD4B,CAA/C;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BAJ,WAAW,CAACQ,SAAZ,CAAsBG,oBAAtB,GAA6C,UAAUC,OAAV,EAAmB;AAC9D,MAAIhB,OAAO,CAACgB,OAAO,CAACC,aAAT,CAAX,EAAoC;AAClCD,IAAAA,OAAO,CAACC,aAAR,CAAsBC,OAAtB;AACD;;AAED,SAAO,KAAKC,gBAAL,CAAsBH,OAAtB,CAAP;AACD,CAND;AAQA;;;;;;;;;;;;;AAWAZ,WAAW,CAACQ,SAAZ,CAAsBO,gBAAtB,GAAyC,UAAUH,OAAV,EAAmB;AAC1D;AACA;AAEA,MAAII,kBAAkB,GAAGJ,OAAO,CAACI,kBAAjC;AACA,MAAIC,oBAAoB,GAAGL,OAAO,CAACK,oBAAnC;AACA,MAAIC,kBAAkB,GAAGN,OAAO,CAACM,kBAAjC;;AAEA,MAAI,OAAOF,kBAAP,KAA8B,QAAlC,EAA4C;AAC1CA,IAAAA,kBAAkB,GAAG,IAAIjB,YAAJ,CAAiB;AACpCoB,MAAAA,OAAO,EAAE,CAACH,kBAAD;AAD2B,KAAjB,CAArB;AAGD;;AAED,MAAI,OAAOC,oBAAP,KAAgC,QAApC,EAA8C;AAC5CA,IAAAA,oBAAoB,GAAG,IAAIlB,YAAJ,CAAiB;AACtCoB,MAAAA,OAAO,EAAE,CAACF,oBAAD;AAD6B,KAAjB,CAAvB;AAGD;;AAED,MAAIG,gBAAgB,GAAGJ,kBAAkB,CAACK,0BAAnB,CACrB,KAAKnB,QADgB,CAAvB;AAGA,MAAIoB,kBAAkB,GAAGL,oBAAoB,CAACM,4BAArB,CACvB,KAAKrB,QADkB,CAAzB;AAIA,MAAIsB,OAAO,GACTJ,gBAAgB,GAAGE,kBAAnB,GAAwCG,IAAI,CAACC,SAAL,CAAeR,kBAAf,CAD1C;AAEA,MAAIS,YAAJ;;AAEA,MAAI/B,OAAO,CAAC,KAAKO,QAAL,CAAcqB,OAAd,CAAD,CAAX,EAAqC;AACnCG,IAAAA,YAAY,GAAG,KAAKxB,QAAL,CAAcqB,OAAd,CAAf,CADmC,CAGnC;;AACA,WAAO,KAAKnB,iBAAL,CAAuBmB,OAAvB,CAAP;AACD,GALD,MAKO;AACL,QAAIvB,OAAO,GAAG,KAAKC,QAAnB;AACA,QAAIW,aAAa,GAAG,IAAIf,aAAJ,CAAkB;AACpC8B,MAAAA,EAAE,EAAE3B,OAAO,CAAC4B,GADwB;AAEpCC,MAAAA,oBAAoB,EAAE7B,OAAO,CAAC6B,oBAFM;AAGpCC,MAAAA,YAAY,EAAE9B,OAAO,CAAC8B,YAHc;AAIpCf,MAAAA,kBAAkB,EAAEA,kBAJgB;AAKpCI,MAAAA,gBAAgB,EAAEA,gBALkB;AAMpCH,MAAAA,oBAAoB,EAAEA,oBANc;AAOpCK,MAAAA,kBAAkB,EAAEA,kBAPgB;AAQpCJ,MAAAA,kBAAkB,EAAEA;AARgB,KAAlB,CAApB;AAWAS,IAAAA,YAAY,GAAG;AACbK,MAAAA,KAAK,EAAE,IADM;AAEbnB,MAAAA,aAAa,EAAEA,aAFF;AAGbW,MAAAA,OAAO,EAAEA,OAHI;AAIbS,MAAAA,eAAe,EAAE,EAJJ;AAKbC,MAAAA,KAAK,EAAE;AALM,KAAf,CAbK,CAqBL;;AACArB,IAAAA,aAAa,CAACsB,aAAd,GAA8BR,YAA9B;AACA,SAAKxB,QAAL,CAAcqB,OAAd,IAAyBG,YAAzB;AACA,MAAE,KAAKvB,gBAAP;AACD;;AAED,IAAEuB,YAAY,CAACO,KAAf;AACA,SAAOP,YAAY,CAACd,aAApB;AACD,CAjED;;AAmEAb,WAAW,CAACQ,SAAZ,CAAsB4B,2BAAtB,GAAoD,UAClDvB,aADkD,EAElDW,OAFkD,EAGlDZ,OAHkD,EAIlD;AACA,MAAIe,YAAY,GAAGd,aAAa,CAACsB,aAAjC;AACA,MAAIE,cAAc,GAAGb,OAAO,GAAGG,YAAY,CAACH,OAA5C;AACA,MAAIc,mBAAmB,GAAG,KAAKnC,QAAL,CAAckC,cAAd,CAA1B;;AACA,MAAIzC,OAAO,CAAC0C,mBAAD,CAAX,EAAkC;AAChCC,IAAAA,aAAa,CAAC,IAAD,EAAOD,mBAAP,CAAb;AACA,QAAIE,KAAK,GAAGb,YAAY,CAACM,eAAb,CAA6BQ,OAA7B,CAAqCjB,OAArC,CAAZ;;AACA,QAAIgB,KAAK,GAAG,CAAC,CAAb,EAAgB;AACdb,MAAAA,YAAY,CAACM,eAAb,CAA6BS,MAA7B,CAAoCF,KAApC,EAA2C,CAA3C;AACD;AACF;;AAED,SAAO,KAAKG,0BAAL,CAAgC9B,aAAhC,EAA+CW,OAA/C,EAAwDZ,OAAxD,CAAP;AACD,CAjBD;;AAmBAZ,WAAW,CAACQ,SAAZ,CAAsBoC,uBAAtB,GAAgD,UAC9C/B,aAD8C,EAE9CW,OAF8C,EAG9C;AACA,MAAIG,YAAY,GAAGd,aAAa,CAACsB,aAAjC;AACA,MAAIE,cAAc,GAAGb,OAAO,GAAGG,YAAY,CAACH,OAA5C;AACA,MAAIc,mBAAmB,GAAG,KAAKnC,QAAL,CAAckC,cAAd,CAA1B;;AACA,MAAI,CAACzC,OAAO,CAAC0C,mBAAD,CAAZ,EAAmC;AACjC,WAAOO,SAAP;AACD;;AAED,SAAOP,mBAAmB,CAACzB,aAA3B;AACD,CAZD;;AAcAb,WAAW,CAACQ,SAAZ,CAAsBmC,0BAAtB,GAAmD,UACjD9B,aADiD,EAEjDW,OAFiD,EAGjDZ,OAHiD,EAIjD;AACA,MAAIe,YAAY,GAAGd,aAAa,CAACsB,aAAjC;AACA,MAAIE,cAAc,GAAGb,OAAO,GAAGG,YAAY,CAACH,OAA5C;AAEA,MAAIR,kBAAkB,GAAGJ,OAAO,CAACI,kBAAjC;AACA,MAAIC,oBAAoB,GAAGL,OAAO,CAACK,oBAAnC;AACA,MAAIC,kBAAkB,GAAGN,OAAO,CAACM,kBAAjC;;AAEA,MAAI,OAAOF,kBAAP,KAA8B,QAAlC,EAA4C;AAC1CA,IAAAA,kBAAkB,GAAG,IAAIjB,YAAJ,CAAiB;AACpCoB,MAAAA,OAAO,EAAE,CAACH,kBAAD;AAD2B,KAAjB,CAArB;AAGD;;AAED,MAAI,OAAOC,oBAAP,KAAgC,QAApC,EAA8C;AAC5CA,IAAAA,oBAAoB,GAAG,IAAIlB,YAAJ,CAAiB;AACtCoB,MAAAA,OAAO,EAAE,CAACF,oBAAD;AAD6B,KAAjB,CAAvB;AAGD;;AAED,MAAIhB,OAAO,GAAG,KAAKC,QAAnB;AAEA,MAAIkB,gBAAgB,GAAGJ,kBAAkB,CAACK,0BAAnB,CAA8CpB,OAA9C,CAAvB;AACA,MAAIqB,kBAAkB,GAAGL,oBAAoB,CAACM,4BAArB,CACvBtB,OADuB,CAAzB;AAIA,MAAI6C,oBAAoB,GAAG,IAAIhD,aAAJ,CAAkB;AAC3C8B,IAAAA,EAAE,EAAE3B,OAAO,CAAC4B,GAD+B;AAE3CC,IAAAA,oBAAoB,EAAE7B,OAAO,CAAC6B,oBAFa;AAG3CC,IAAAA,YAAY,EAAE9B,OAAO,CAAC8B,YAHqB;AAI3Cf,IAAAA,kBAAkB,EAAEA,kBAJuB;AAK3CI,IAAAA,gBAAgB,EAAEA,gBALyB;AAM3CH,IAAAA,oBAAoB,EAAEA,oBANqB;AAO3CK,IAAAA,kBAAkB,EAAEA,kBAPuB;AAQ3CJ,IAAAA,kBAAkB,EAAEA;AARuB,GAAlB,CAA3B;AAWA,MAAI6B,mBAAmB,GAAG;AACxBf,IAAAA,KAAK,EAAE,IADiB;AAExBnB,IAAAA,aAAa,EAAEiC,oBAFS;AAGxBtB,IAAAA,OAAO,EAAEa,cAHe;AAIxBJ,IAAAA,eAAe,EAAE,EAJO;AAKxBC,IAAAA,KAAK,EAAE;AALiB,GAA1B;AAQAP,EAAAA,YAAY,CAACM,eAAb,CAA6Be,IAA7B,CAAkCxB,OAAlC;AACAsB,EAAAA,oBAAoB,CAACX,aAArB,GAAqCY,mBAArC;AACA,OAAK5C,QAAL,CAAckC,cAAd,IAAgCU,mBAAhC;AACA,SAAOD,oBAAP;AACD,CAtDD;;AAwDA,SAASP,aAAT,CAAuBP,KAAvB,EAA8BL,YAA9B,EAA4C;AAC1C,MAAIM,eAAe,GAAGN,YAAY,CAACM,eAAnC;AACA,MAAIgB,MAAM,GAAGhB,eAAe,CAACgB,MAA7B;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4B,EAAEC,CAA9B,EAAiC;AAC/B,QAAI1B,OAAO,GAAGS,eAAe,CAACiB,CAAD,CAAf,GAAqBvB,YAAY,CAACH,OAAhD;AACA,QAAIuB,mBAAmB,GAAGf,KAAK,CAAC7B,QAAN,CAAeqB,OAAf,CAA1B;AACAe,IAAAA,aAAa,CAACP,KAAD,EAAQe,mBAAR,CAAb;AACD;;AAED,SAAOf,KAAK,CAAC7B,QAAN,CAAewB,YAAY,CAACH,OAA5B,CAAP;AACAG,EAAAA,YAAY,CAACd,aAAb,CAA2BsC,YAA3B;AACD;;AAEDnD,WAAW,CAACQ,SAAZ,CAAsB4C,6BAAtB,GAAsD,YAAY;AAChE,MAAIC,gBAAgB,GAAG,KAAKhD,iBAA5B;;AAEA,OAAK,IAAImB,OAAT,IAAoB6B,gBAApB,EAAsC;AACpC,QAAIA,gBAAgB,CAACC,cAAjB,CAAgC9B,OAAhC,CAAJ,EAA8C;AAC5C,UAAIG,YAAY,GAAG0B,gBAAgB,CAAC7B,OAAD,CAAnC;AACAe,MAAAA,aAAa,CAAC,IAAD,EAAOZ,YAAP,CAAb;AACA,QAAE,KAAKvB,gBAAP;AACD;AACF;;AAED,OAAKC,iBAAL,GAAyB,EAAzB;AACD,CAZD;;AAcAL,WAAW,CAACQ,SAAZ,CAAsB+C,oBAAtB,GAA6C,UAAU1C,aAAV,EAAyB;AACpE,MAAIjB,OAAO,CAACiB,aAAD,CAAX,EAA4B;AAC1B,QAAIc,YAAY,GAAGd,aAAa,CAACsB,aAAjC;;AACA,QAAIR,YAAY,IAAI,EAAEA,YAAY,CAACO,KAAf,KAAyB,CAA7C,EAAgD;AAC9C,WAAK7B,iBAAL,CAAuBsB,YAAY,CAACH,OAApC,IAA+CG,YAA/C;AACD;AACF;AACF,CAPD;;AASA3B,WAAW,CAACQ,SAAZ,CAAsBgD,WAAtB,GAAoC,YAAY;AAC9C,SAAO,KAAP;AACD,CAFD;;AAIAxD,WAAW,CAACQ,SAAZ,CAAsBM,OAAtB,GAAgC,YAAY;AAC1C,MAAI2C,OAAO,GAAG,KAAKtD,QAAnB;;AACA,OAAK,IAAIqB,OAAT,IAAoBiC,OAApB,EAA6B;AAC3B,QAAIA,OAAO,CAACH,cAAR,CAAuB9B,OAAvB,CAAJ,EAAqC;AACnCiC,MAAAA,OAAO,CAACjC,OAAD,CAAP,CAAiBX,aAAjB,CAA+BsC,YAA/B;AACD;AACF;;AACD,SAAOtD,aAAa,CAAC,IAAD,CAApB;AACD,CARD;;AASA,eAAeG,WAAf","sourcesContent":["import defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport ShaderProgram from \"./ShaderProgram.js\";\nimport ShaderSource from \"./ShaderSource.js\";\n\n/**\n * @private\n */\nfunction ShaderCache(context) {\n  this._context = context;\n  this._shaders = {};\n  this._numberOfShaders = 0;\n  this._shadersToRelease = {};\n}\n\nObject.defineProperties(ShaderCache.prototype, {\n  numberOfShaders: {\n    get: function () {\n      return this._numberOfShaders;\n    },\n  },\n});\n\n/**\n     * Returns a shader program from the cache, or creates and caches a new shader program,\n     * given the GLSL vertex and fragment shader source and attribute locations.\n     * <p>\n     * The difference between this and {@link ShaderCache#getShaderProgram}, is this is used to\n     * replace an existing reference to a shader program, which is passed as the first argument.\n     * </p>\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {ShaderProgram} [options.shaderProgram] The shader program that is being reassigned.\n     * @param {String|ShaderSource} options.vertexShaderSource The GLSL source for the vertex shader.\n     * @param {String|ShaderSource} options.fragmentShaderSource The GLSL source for the fragment shader.\n     * @param {Object} options.attributeLocations Indices for the attribute inputs to the vertex shader.\n\n     * @returns {ShaderProgram} The cached or newly created shader program.\n     *\n     *\n     * @example\n     * this._shaderProgram = context.shaderCache.replaceShaderProgram({\n     *     shaderProgram : this._shaderProgram,\n     *     vertexShaderSource : vs,\n     *     fragmentShaderSource : fs,\n     *     attributeLocations : attributeLocations\n     * });\n     *\n     * @see ShaderCache#getShaderProgram\n     */\nShaderCache.prototype.replaceShaderProgram = function (options) {\n  if (defined(options.shaderProgram)) {\n    options.shaderProgram.destroy();\n  }\n\n  return this.getShaderProgram(options);\n};\n\n/**\n * Returns a shader program from the cache, or creates and caches a new shader program,\n * given the GLSL vertex and fragment shader source and attribute locations.\n *\n * @param {Object} options Object with the following properties:\n * @param {String|ShaderSource} options.vertexShaderSource The GLSL source for the vertex shader.\n * @param {String|ShaderSource} options.fragmentShaderSource The GLSL source for the fragment shader.\n * @param {Object} options.attributeLocations Indices for the attribute inputs to the vertex shader.\n *\n * @returns {ShaderProgram} The cached or newly created shader program.\n */\nShaderCache.prototype.getShaderProgram = function (options) {\n  // convert shaders which are provided as strings into ShaderSource objects\n  // because ShaderSource handles all the automatic including of built-in functions, etc.\n\n  var vertexShaderSource = options.vertexShaderSource;\n  var fragmentShaderSource = options.fragmentShaderSource;\n  var attributeLocations = options.attributeLocations;\n\n  if (typeof vertexShaderSource === \"string\") {\n    vertexShaderSource = new ShaderSource({\n      sources: [vertexShaderSource],\n    });\n  }\n\n  if (typeof fragmentShaderSource === \"string\") {\n    fragmentShaderSource = new ShaderSource({\n      sources: [fragmentShaderSource],\n    });\n  }\n\n  var vertexShaderText = vertexShaderSource.createCombinedVertexShader(\n    this._context\n  );\n  var fragmentShaderText = fragmentShaderSource.createCombinedFragmentShader(\n    this._context\n  );\n\n  var keyword =\n    vertexShaderText + fragmentShaderText + JSON.stringify(attributeLocations);\n  var cachedShader;\n\n  if (defined(this._shaders[keyword])) {\n    cachedShader = this._shaders[keyword];\n\n    // No longer want to release this if it was previously released.\n    delete this._shadersToRelease[keyword];\n  } else {\n    var context = this._context;\n    var shaderProgram = new ShaderProgram({\n      gl: context._gl,\n      logShaderCompilation: context.logShaderCompilation,\n      debugShaders: context.debugShaders,\n      vertexShaderSource: vertexShaderSource,\n      vertexShaderText: vertexShaderText,\n      fragmentShaderSource: fragmentShaderSource,\n      fragmentShaderText: fragmentShaderText,\n      attributeLocations: attributeLocations,\n    });\n\n    cachedShader = {\n      cache: this,\n      shaderProgram: shaderProgram,\n      keyword: keyword,\n      derivedKeywords: [],\n      count: 0,\n    };\n\n    // A shader can't be in more than one cache.\n    shaderProgram._cachedShader = cachedShader;\n    this._shaders[keyword] = cachedShader;\n    ++this._numberOfShaders;\n  }\n\n  ++cachedShader.count;\n  return cachedShader.shaderProgram;\n};\n\nShaderCache.prototype.replaceDerivedShaderProgram = function (\n  shaderProgram,\n  keyword,\n  options\n) {\n  var cachedShader = shaderProgram._cachedShader;\n  var derivedKeyword = keyword + cachedShader.keyword;\n  var cachedDerivedShader = this._shaders[derivedKeyword];\n  if (defined(cachedDerivedShader)) {\n    destroyShader(this, cachedDerivedShader);\n    var index = cachedShader.derivedKeywords.indexOf(keyword);\n    if (index > -1) {\n      cachedShader.derivedKeywords.splice(index, 1);\n    }\n  }\n\n  return this.createDerivedShaderProgram(shaderProgram, keyword, options);\n};\n\nShaderCache.prototype.getDerivedShaderProgram = function (\n  shaderProgram,\n  keyword\n) {\n  var cachedShader = shaderProgram._cachedShader;\n  var derivedKeyword = keyword + cachedShader.keyword;\n  var cachedDerivedShader = this._shaders[derivedKeyword];\n  if (!defined(cachedDerivedShader)) {\n    return undefined;\n  }\n\n  return cachedDerivedShader.shaderProgram;\n};\n\nShaderCache.prototype.createDerivedShaderProgram = function (\n  shaderProgram,\n  keyword,\n  options\n) {\n  var cachedShader = shaderProgram._cachedShader;\n  var derivedKeyword = keyword + cachedShader.keyword;\n\n  var vertexShaderSource = options.vertexShaderSource;\n  var fragmentShaderSource = options.fragmentShaderSource;\n  var attributeLocations = options.attributeLocations;\n\n  if (typeof vertexShaderSource === \"string\") {\n    vertexShaderSource = new ShaderSource({\n      sources: [vertexShaderSource],\n    });\n  }\n\n  if (typeof fragmentShaderSource === \"string\") {\n    fragmentShaderSource = new ShaderSource({\n      sources: [fragmentShaderSource],\n    });\n  }\n\n  var context = this._context;\n\n  var vertexShaderText = vertexShaderSource.createCombinedVertexShader(context);\n  var fragmentShaderText = fragmentShaderSource.createCombinedFragmentShader(\n    context\n  );\n\n  var derivedShaderProgram = new ShaderProgram({\n    gl: context._gl,\n    logShaderCompilation: context.logShaderCompilation,\n    debugShaders: context.debugShaders,\n    vertexShaderSource: vertexShaderSource,\n    vertexShaderText: vertexShaderText,\n    fragmentShaderSource: fragmentShaderSource,\n    fragmentShaderText: fragmentShaderText,\n    attributeLocations: attributeLocations,\n  });\n\n  var derivedCachedShader = {\n    cache: this,\n    shaderProgram: derivedShaderProgram,\n    keyword: derivedKeyword,\n    derivedKeywords: [],\n    count: 0,\n  };\n\n  cachedShader.derivedKeywords.push(keyword);\n  derivedShaderProgram._cachedShader = derivedCachedShader;\n  this._shaders[derivedKeyword] = derivedCachedShader;\n  return derivedShaderProgram;\n};\n\nfunction destroyShader(cache, cachedShader) {\n  var derivedKeywords = cachedShader.derivedKeywords;\n  var length = derivedKeywords.length;\n  for (var i = 0; i < length; ++i) {\n    var keyword = derivedKeywords[i] + cachedShader.keyword;\n    var derivedCachedShader = cache._shaders[keyword];\n    destroyShader(cache, derivedCachedShader);\n  }\n\n  delete cache._shaders[cachedShader.keyword];\n  cachedShader.shaderProgram.finalDestroy();\n}\n\nShaderCache.prototype.destroyReleasedShaderPrograms = function () {\n  var shadersToRelease = this._shadersToRelease;\n\n  for (var keyword in shadersToRelease) {\n    if (shadersToRelease.hasOwnProperty(keyword)) {\n      var cachedShader = shadersToRelease[keyword];\n      destroyShader(this, cachedShader);\n      --this._numberOfShaders;\n    }\n  }\n\n  this._shadersToRelease = {};\n};\n\nShaderCache.prototype.releaseShaderProgram = function (shaderProgram) {\n  if (defined(shaderProgram)) {\n    var cachedShader = shaderProgram._cachedShader;\n    if (cachedShader && --cachedShader.count === 0) {\n      this._shadersToRelease[cachedShader.keyword] = cachedShader;\n    }\n  }\n};\n\nShaderCache.prototype.isDestroyed = function () {\n  return false;\n};\n\nShaderCache.prototype.destroy = function () {\n  var shaders = this._shaders;\n  for (var keyword in shaders) {\n    if (shaders.hasOwnProperty(keyword)) {\n      shaders[keyword].shaderProgram.finalDestroy();\n    }\n  }\n  return destroyObject(this);\n};\nexport default ShaderCache;\n"]},"metadata":{},"sourceType":"module"}