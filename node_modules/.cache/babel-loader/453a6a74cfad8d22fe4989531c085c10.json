{"ast":null,"code":"import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport when from \"../ThirdParty/when.js\";\nimport ClassificationPrimitive from \"./ClassificationPrimitive.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowVolumeAppearance from \"./ShadowVolumeAppearance.js\";\nvar GroundPrimitiveUniformMap = {\n  u_globeMinimumAltitude: function () {\n    return 55000.0;\n  }\n};\n/**\n * A ground primitive represents geometry draped over terrain or 3D Tiles in the {@link Scene}.\n * <p>\n * A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including\n * {@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,\n * and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix\n * and match most of them and add a new geometry or appearance independently of each other.\n * </p>\n * <p>\n * Support for the WEBGL_depth_texture extension is required to use GeometryInstances with different PerInstanceColors\n * or materials besides PerInstanceColorAppearance.\n * </p>\n * <p>\n * Textured GroundPrimitives were designed for notional patterns and are not meant for precisely mapping\n * textures to terrain - for that use case, use {@link SingleTileImageryProvider}.\n * </p>\n * <p>\n * For correct rendering, this feature requires the EXT_frag_depth WebGL extension. For hardware that do not support this extension, there\n * will be rendering artifacts for some viewing angles.\n * </p>\n * <p>\n * Valid geometries are {@link CircleGeometry}, {@link CorridorGeometry}, {@link EllipseGeometry}, {@link PolygonGeometry}, and {@link RectangleGeometry}.\n * </p>\n *\n * @alias GroundPrimitive\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Array|GeometryInstance} [options.geometryInstances] The geometry instances to render.\n * @param {Appearance} [options.appearance] The appearance used to render the primitive. Defaults to a flat PerInstanceColorAppearance when GeometryInstances have a color attribute.\n * @param {Boolean} [options.show=true] Determines if this primitive will be shown.\n * @param {Boolean} [options.vertexCacheOptimize=false] When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n * @param {Boolean} [options.interleave=false] When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.\n * @param {Boolean} [options.compressVertices=true] When <code>true</code>, the geometry vertices are compressed, which will save memory.\n * @param {Boolean} [options.releaseGeometryInstances=true] When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n * @param {Boolean} [options.asynchronous=true] Determines if the primitive will be created asynchronously or block until ready. If false initializeTerrainHeights() must be called first.\n * @param {ClassificationType} [options.classificationType=ClassificationType.BOTH] Determines whether terrain, 3D Tiles or both will be classified.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {Boolean} [options.debugShowShadowVolume=false] For debugging only. Determines if the shadow volume for each geometry in the primitive is drawn. Must be <code>true</code> on\n *                  creation for the volumes to be created before the geometry is released or options.releaseGeometryInstance must be <code>false</code>.\n *\n * @example\n * // Example 1: Create primitive with a single instance\n * var rectangleInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0)\n *   }),\n *   id : 'rectangle',\n *   attributes : {\n *     color : new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5)\n *   }\n * });\n * scene.primitives.add(new Cesium.GroundPrimitive({\n *   geometryInstances : rectangleInstance\n * }));\n *\n * // Example 2: Batch instances\n * var color = new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5); // Both instances must have the same color.\n * var rectangleInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0)\n *   }),\n *   id : 'rectangle',\n *   attributes : {\n *     color : color\n *   }\n * });\n * var ellipseInstance = new Cesium.GeometryInstance({\n *     geometry : new Cesium.EllipseGeometry({\n *         center : Cesium.Cartesian3.fromDegrees(-105.0, 40.0),\n *         semiMinorAxis : 300000.0,\n *         semiMajorAxis : 400000.0\n *     }),\n *     id : 'ellipse',\n *     attributes : {\n *         color : color\n *     }\n * });\n * scene.primitives.add(new Cesium.GroundPrimitive({\n *   geometryInstances : [rectangleInstance, ellipseInstance]\n * }));\n *\n * @see Primitive\n * @see ClassificationPrimitive\n * @see GeometryInstance\n * @see Appearance\n */\n\nfunction GroundPrimitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var appearance = options.appearance;\n  var geometryInstances = options.geometryInstances;\n\n  if (!defined(appearance) && defined(geometryInstances)) {\n    var geometryInstancesArray = Array.isArray(geometryInstances) ? geometryInstances : [geometryInstances];\n    var geometryInstanceCount = geometryInstancesArray.length;\n\n    for (var i = 0; i < geometryInstanceCount; i++) {\n      var attributes = geometryInstancesArray[i].attributes;\n\n      if (defined(attributes) && defined(attributes.color)) {\n        appearance = new PerInstanceColorAppearance({\n          flat: true\n        });\n        break;\n      }\n    }\n  }\n  /**\n   * The {@link Appearance} used to shade this primitive. Each geometry\n   * instance is shaded with the same appearance.  Some appearances, like\n   * {@link PerInstanceColorAppearance} allow giving each instance unique\n   * properties.\n   *\n   * @type Appearance\n   *\n   * @default undefined\n   */\n\n\n  this.appearance = appearance;\n  /**\n   * The geometry instances rendered with this primitive.  This may\n   * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>\n   * is <code>true</code> when the primitive is constructed.\n   * <p>\n   * Changing this property after the primitive is rendered has no effect.\n   * </p>\n   *\n   * @readonly\n   * @type {Array|GeometryInstance}\n   *\n   * @default undefined\n   */\n\n  this.geometryInstances = options.geometryInstances;\n  /**\n   * Determines if the primitive will be shown.  This affects all geometry\n   * instances in the primitive.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n\n  this.show = defaultValue(options.show, true);\n  /**\n   * Determines whether terrain, 3D Tiles or both will be classified.\n   *\n   * @type {ClassificationType}\n   *\n   * @default ClassificationType.BOTH\n   */\n\n  this.classificationType = defaultValue(options.classificationType, ClassificationType.BOTH);\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n\n  this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the shadow volume for each geometry in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n\n  this.debugShowShadowVolume = defaultValue(options.debugShowShadowVolume, false);\n  this._boundingVolumes = [];\n  this._boundingVolumes2D = [];\n  this._ready = false;\n  this._readyPromise = when.defer();\n  this._primitive = undefined;\n  this._maxHeight = undefined;\n  this._minHeight = undefined;\n  this._maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n  this._minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\n  this._boundingSpheresKeys = [];\n  this._boundingSpheres = [];\n  this._useFragmentCulling = false; // Used when inserting in an OrderedPrimitiveCollection\n\n  this._zIndex = undefined;\n  var that = this;\n  this._classificationPrimitiveOptions = {\n    geometryInstances: undefined,\n    appearance: undefined,\n    vertexCacheOptimize: defaultValue(options.vertexCacheOptimize, false),\n    interleave: defaultValue(options.interleave, false),\n    releaseGeometryInstances: defaultValue(options.releaseGeometryInstances, true),\n    allowPicking: defaultValue(options.allowPicking, true),\n    asynchronous: defaultValue(options.asynchronous, true),\n    compressVertices: defaultValue(options.compressVertices, true),\n    _createBoundingVolumeFunction: undefined,\n    _updateAndQueueCommandsFunction: undefined,\n    _pickPrimitive: that,\n    _extruded: true,\n    _uniformMap: GroundPrimitiveUniformMap\n  };\n}\n\nObject.defineProperties(GroundPrimitive.prototype, {\n  /**\n   * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  vertexCacheOptimize: {\n    get: function () {\n      return this._classificationPrimitiveOptions.vertexCacheOptimize;\n    }\n  },\n\n  /**\n   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  interleave: {\n    get: function () {\n      return this._classificationPrimitiveOptions.interleave;\n    }\n  },\n\n  /**\n   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  releaseGeometryInstances: {\n    get: function () {\n      return this._classificationPrimitiveOptions.releaseGeometryInstances;\n    }\n  },\n\n  /**\n   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._classificationPrimitiveOptions.allowPicking;\n    }\n  },\n\n  /**\n   * Determines if the geometry instances will be created and batched on a web worker.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._classificationPrimitiveOptions.asynchronous;\n    }\n  },\n\n  /**\n   * When <code>true</code>, geometry vertices are compressed, which will save memory.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  compressVertices: {\n    get: function () {\n      return this._classificationPrimitiveOptions.compressVertices;\n    }\n  },\n\n  /**\n   * Determines if the primitive is complete and ready to render.  If this property is\n   * true, the primitive will be rendered the next time that {@link GroundPrimitive#update}\n   * is called.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n\n  /**\n   * Gets a promise that resolves when the primitive is ready to render.\n   * @memberof GroundPrimitive.prototype\n   * @type {Promise.<GroundPrimitive>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    }\n  }\n});\n/**\n * Determines if GroundPrimitive rendering is supported.\n *\n * @function\n * @param {Scene} scene The scene.\n * @returns {Boolean} <code>true</code> if GroundPrimitives are supported; otherwise, returns <code>false</code>\n */\n\nGroundPrimitive.isSupported = ClassificationPrimitive.isSupported;\n\nfunction getComputeMaximumHeightFunction(primitive) {\n  return function (granularity, ellipsoid) {\n    var r = ellipsoid.maximumRadius;\n    var delta = r / Math.cos(granularity * 0.5) - r;\n    return primitive._maxHeight + delta;\n  };\n}\n\nfunction getComputeMinimumHeightFunction(primitive) {\n  return function (granularity, ellipsoid) {\n    return primitive._minHeight;\n  };\n}\n\nvar scratchBVCartesianHigh = new Cartesian3();\nvar scratchBVCartesianLow = new Cartesian3();\nvar scratchBVCartesian = new Cartesian3();\nvar scratchBVCartographic = new Cartographic();\nvar scratchBVRectangle = new Rectangle();\n\nfunction getRectangle(frameState, geometry) {\n  var ellipsoid = frameState.mapProjection.ellipsoid;\n\n  if (!defined(geometry.attributes) || !defined(geometry.attributes.position3DHigh)) {\n    if (defined(geometry.rectangle)) {\n      return geometry.rectangle;\n    }\n\n    return undefined;\n  }\n\n  var highPositions = geometry.attributes.position3DHigh.values;\n  var lowPositions = geometry.attributes.position3DLow.values;\n  var length = highPositions.length;\n  var minLat = Number.POSITIVE_INFINITY;\n  var minLon = Number.POSITIVE_INFINITY;\n  var maxLat = Number.NEGATIVE_INFINITY;\n  var maxLon = Number.NEGATIVE_INFINITY;\n\n  for (var i = 0; i < length; i += 3) {\n    var highPosition = Cartesian3.unpack(highPositions, i, scratchBVCartesianHigh);\n    var lowPosition = Cartesian3.unpack(lowPositions, i, scratchBVCartesianLow);\n    var position = Cartesian3.add(highPosition, lowPosition, scratchBVCartesian);\n    var cartographic = ellipsoid.cartesianToCartographic(position, scratchBVCartographic);\n    var latitude = cartographic.latitude;\n    var longitude = cartographic.longitude;\n    minLat = Math.min(minLat, latitude);\n    minLon = Math.min(minLon, longitude);\n    maxLat = Math.max(maxLat, latitude);\n    maxLon = Math.max(maxLon, longitude);\n  }\n\n  var rectangle = scratchBVRectangle;\n  rectangle.north = maxLat;\n  rectangle.south = minLat;\n  rectangle.east = maxLon;\n  rectangle.west = minLon;\n  return rectangle;\n}\n\nfunction setMinMaxTerrainHeights(primitive, rectangle, ellipsoid) {\n  var result = ApproximateTerrainHeights.getMinimumMaximumHeights(rectangle, ellipsoid);\n  primitive._minTerrainHeight = result.minimumTerrainHeight;\n  primitive._maxTerrainHeight = result.maximumTerrainHeight;\n}\n\nfunction createBoundingVolume(groundPrimitive, frameState, geometry) {\n  var ellipsoid = frameState.mapProjection.ellipsoid;\n  var rectangle = getRectangle(frameState, geometry);\n  var obb = OrientedBoundingBox.fromRectangle(rectangle, groundPrimitive._minHeight, groundPrimitive._maxHeight, ellipsoid);\n\n  groundPrimitive._boundingVolumes.push(obb);\n\n  if (!frameState.scene3DOnly) {\n    var projection = frameState.mapProjection;\n    var boundingVolume = BoundingSphere.fromRectangleWithHeights2D(rectangle, projection, groundPrimitive._maxHeight, groundPrimitive._minHeight);\n    Cartesian3.fromElements(boundingVolume.center.z, boundingVolume.center.x, boundingVolume.center.y, boundingVolume.center);\n\n    groundPrimitive._boundingVolumes2D.push(boundingVolume);\n  }\n}\n\nfunction boundingVolumeIndex(commandIndex, length) {\n  return Math.floor(commandIndex % length / 3);\n}\n\nfunction updateAndQueueRenderCommand(groundPrimitive, command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume) {\n  // Use derived appearance command for 2D if needed\n  var classificationPrimitive = groundPrimitive._primitive;\n\n  if (frameState.mode !== SceneMode.SCENE3D && command.shaderProgram === classificationPrimitive._spColor && classificationPrimitive._needs2DShader) {\n    command = command.derivedCommands.appearance2D;\n  }\n\n  command.owner = groundPrimitive;\n  command.modelMatrix = modelMatrix;\n  command.boundingVolume = boundingVolume;\n  command.cull = cull;\n  command.debugShowBoundingVolume = debugShowBoundingVolume;\n  frameState.commandList.push(command);\n}\n\nfunction updateAndQueuePickCommand(groundPrimitive, command, frameState, modelMatrix, cull, boundingVolume) {\n  // Use derived pick command for 2D if needed\n  var classificationPrimitive = groundPrimitive._primitive;\n\n  if (frameState.mode !== SceneMode.SCENE3D && command.shaderProgram === classificationPrimitive._spPick && classificationPrimitive._needs2DShader) {\n    command = command.derivedCommands.pick2D;\n  }\n\n  command.owner = groundPrimitive;\n  command.modelMatrix = modelMatrix;\n  command.boundingVolume = boundingVolume;\n  command.cull = cull;\n  frameState.commandList.push(command);\n}\n\nfunction updateAndQueueCommands(groundPrimitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {\n  var boundingVolumes;\n\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingVolumes = groundPrimitive._boundingVolumes;\n  } else {\n    boundingVolumes = groundPrimitive._boundingVolumes2D;\n  }\n\n  var classificationType = groundPrimitive.classificationType;\n  var queueTerrainCommands = classificationType !== ClassificationType.CESIUM_3D_TILE;\n  var queue3DTilesCommands = classificationType !== ClassificationType.TERRAIN;\n  var passes = frameState.passes;\n  var classificationPrimitive = groundPrimitive._primitive;\n  var i;\n  var boundingVolume;\n  var command;\n\n  if (passes.render) {\n    var colorLength = colorCommands.length;\n\n    for (i = 0; i < colorLength; ++i) {\n      boundingVolume = boundingVolumes[boundingVolumeIndex(i, colorLength)];\n\n      if (queueTerrainCommands) {\n        command = colorCommands[i];\n        updateAndQueueRenderCommand(groundPrimitive, command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume);\n      }\n\n      if (queue3DTilesCommands) {\n        command = colorCommands[i].derivedCommands.tileset;\n        updateAndQueueRenderCommand(groundPrimitive, command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume);\n      }\n    }\n\n    if (frameState.invertClassification) {\n      var ignoreShowCommands = classificationPrimitive._commandsIgnoreShow;\n      var ignoreShowCommandsLength = ignoreShowCommands.length;\n\n      for (i = 0; i < ignoreShowCommandsLength; ++i) {\n        boundingVolume = boundingVolumes[Math.floor(i / 2)];\n        command = ignoreShowCommands[i];\n        updateAndQueueRenderCommand(groundPrimitive, command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume);\n      }\n    }\n  }\n\n  if (passes.pick) {\n    var pickLength = pickCommands.length;\n    var pickOffsets;\n\n    if (!groundPrimitive._useFragmentCulling) {\n      // Must be using pick offsets\n      pickOffsets = classificationPrimitive._primitive._pickOffsets;\n    }\n\n    for (i = 0; i < pickLength; ++i) {\n      boundingVolume = boundingVolumes[boundingVolumeIndex(i, pickLength)];\n\n      if (!groundPrimitive._useFragmentCulling) {\n        var pickOffset = pickOffsets[boundingVolumeIndex(i, pickLength)];\n        boundingVolume = boundingVolumes[pickOffset.index];\n      }\n\n      if (queueTerrainCommands) {\n        command = pickCommands[i];\n        updateAndQueuePickCommand(groundPrimitive, command, frameState, modelMatrix, cull, boundingVolume);\n      }\n\n      if (queue3DTilesCommands) {\n        command = pickCommands[i].derivedCommands.tileset;\n        updateAndQueuePickCommand(groundPrimitive, command, frameState, modelMatrix, cull, boundingVolume);\n      }\n    }\n  }\n}\n/**\n * Initializes the minimum and maximum terrain heights. This only needs to be called if you are creating the\n * GroundPrimitive synchronously.\n *\n * @returns {Promise} A promise that will resolve once the terrain heights have been loaded.\n *\n */\n\n\nGroundPrimitive.initializeTerrainHeights = function () {\n  return ApproximateTerrainHeights.initialize();\n};\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} For synchronous GroundPrimitive, you must call GroundPrimitive.initializeTerrainHeights() and wait for the returned promise to resolve.\n * @exception {DeveloperError} All instance geometries must have the same primitiveType.\n * @exception {DeveloperError} Appearance and material have a uniform with the same name.\n */\n\n\nGroundPrimitive.prototype.update = function (frameState) {\n  if (!defined(this._primitive) && !defined(this.geometryInstances)) {\n    return;\n  }\n\n  if (!ApproximateTerrainHeights.initialized) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!this.asynchronous) {\n      throw new DeveloperError(\"For synchronous GroundPrimitives, you must call GroundPrimitive.initializeTerrainHeights() and wait for the returned promise to resolve.\");\n    } //>>includeEnd('debug');\n\n\n    GroundPrimitive.initializeTerrainHeights();\n    return;\n  }\n\n  var that = this;\n  var primitiveOptions = this._classificationPrimitiveOptions;\n\n  if (!defined(this._primitive)) {\n    var ellipsoid = frameState.mapProjection.ellipsoid;\n    var instance;\n    var geometry;\n    var instanceType;\n    var instances = Array.isArray(this.geometryInstances) ? this.geometryInstances : [this.geometryInstances];\n    var length = instances.length;\n    var groundInstances = new Array(length);\n    var i;\n    var rectangle;\n\n    for (i = 0; i < length; ++i) {\n      instance = instances[i];\n      geometry = instance.geometry;\n      var instanceRectangle = getRectangle(frameState, geometry);\n\n      if (!defined(rectangle)) {\n        rectangle = Rectangle.clone(instanceRectangle);\n      } else if (defined(instanceRectangle)) {\n        Rectangle.union(rectangle, instanceRectangle, rectangle);\n      }\n\n      var id = instance.id;\n\n      if (defined(id) && defined(instanceRectangle)) {\n        var boundingSphere = ApproximateTerrainHeights.getBoundingSphere(instanceRectangle, ellipsoid);\n\n        this._boundingSpheresKeys.push(id);\n\n        this._boundingSpheres.push(boundingSphere);\n      }\n\n      instanceType = geometry.constructor;\n\n      if (!defined(instanceType) || !defined(instanceType.createShadowVolume)) {\n        //>>includeStart('debug', pragmas.debug);\n        throw new DeveloperError(\"Not all of the geometry instances have GroundPrimitive support.\"); //>>includeEnd('debug');\n      }\n    } // Now compute the min/max heights for the primitive\n\n\n    setMinMaxTerrainHeights(this, rectangle, ellipsoid);\n    var exaggeration = frameState.terrainExaggeration;\n    this._minHeight = this._minTerrainHeight * exaggeration;\n    this._maxHeight = this._maxTerrainHeight * exaggeration;\n\n    var useFragmentCulling = GroundPrimitive._supportsMaterials(frameState.context);\n\n    this._useFragmentCulling = useFragmentCulling;\n\n    if (useFragmentCulling) {\n      // Determine whether to add spherical or planar extent attributes for computing texture coordinates.\n      // This depends on the size of the GeometryInstances.\n      var attributes;\n      var usePlanarExtents = true;\n\n      for (i = 0; i < length; ++i) {\n        instance = instances[i];\n        geometry = instance.geometry;\n        rectangle = getRectangle(frameState, geometry);\n\n        if (ShadowVolumeAppearance.shouldUseSphericalCoordinates(rectangle)) {\n          usePlanarExtents = false;\n          break;\n        }\n      }\n\n      for (i = 0; i < length; ++i) {\n        instance = instances[i];\n        geometry = instance.geometry;\n        instanceType = geometry.constructor;\n        var boundingRectangle = getRectangle(frameState, geometry);\n        var textureCoordinateRotationPoints = geometry.textureCoordinateRotationPoints;\n\n        if (usePlanarExtents) {\n          attributes = ShadowVolumeAppearance.getPlanarTextureCoordinateAttributes(boundingRectangle, textureCoordinateRotationPoints, ellipsoid, frameState.mapProjection, this._maxHeight);\n        } else {\n          attributes = ShadowVolumeAppearance.getSphericalExtentGeometryInstanceAttributes(boundingRectangle, textureCoordinateRotationPoints, ellipsoid, frameState.mapProjection);\n        }\n\n        var instanceAttributes = instance.attributes;\n\n        for (var attributeKey in instanceAttributes) {\n          if (instanceAttributes.hasOwnProperty(attributeKey)) {\n            attributes[attributeKey] = instanceAttributes[attributeKey];\n          }\n        }\n\n        groundInstances[i] = new GeometryInstance({\n          geometry: instanceType.createShadowVolume(geometry, getComputeMinimumHeightFunction(this), getComputeMaximumHeightFunction(this)),\n          attributes: attributes,\n          id: instance.id\n        });\n      }\n    } else {\n      // ClassificationPrimitive will check if the colors are all the same if it detects lack of fragment culling attributes\n      for (i = 0; i < length; ++i) {\n        instance = instances[i];\n        geometry = instance.geometry;\n        instanceType = geometry.constructor;\n        groundInstances[i] = new GeometryInstance({\n          geometry: instanceType.createShadowVolume(geometry, getComputeMinimumHeightFunction(this), getComputeMaximumHeightFunction(this)),\n          attributes: instance.attributes,\n          id: instance.id\n        });\n      }\n    }\n\n    primitiveOptions.geometryInstances = groundInstances;\n    primitiveOptions.appearance = this.appearance;\n\n    primitiveOptions._createBoundingVolumeFunction = function (frameState, geometry) {\n      createBoundingVolume(that, frameState, geometry);\n    };\n\n    primitiveOptions._updateAndQueueCommandsFunction = function (primitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {\n      updateAndQueueCommands(that, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses);\n    };\n\n    this._primitive = new ClassificationPrimitive(primitiveOptions);\n\n    this._primitive.readyPromise.then(function (primitive) {\n      that._ready = true;\n\n      if (that.releaseGeometryInstances) {\n        that.geometryInstances = undefined;\n      }\n\n      var error = primitive._error;\n\n      if (!defined(error)) {\n        that._readyPromise.resolve(that);\n      } else {\n        that._readyPromise.reject(error);\n      }\n    });\n  }\n\n  this._primitive.appearance = this.appearance;\n  this._primitive.show = this.show;\n  this._primitive.debugShowShadowVolume = this.debugShowShadowVolume;\n  this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume;\n\n  this._primitive.update(frameState);\n};\n/**\n * @private\n */\n\n\nGroundPrimitive.prototype.getBoundingSphere = function (id) {\n  var index = this._boundingSpheresKeys.indexOf(id);\n\n  if (index !== -1) {\n    return this._boundingSpheres[index];\n  }\n\n  return undefined;\n};\n/**\n * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.\n *\n * @param {*} id The id of the {@link GeometryInstance}.\n * @returns {Object} The typed array in the attribute's format or undefined if the is no instance with id.\n *\n * @exception {DeveloperError} must call update before calling getGeometryInstanceAttributes.\n *\n * @example\n * var attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);\n */\n\n\nGroundPrimitive.prototype.getGeometryInstanceAttributes = function (id) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(this._primitive)) {\n    throw new DeveloperError(\"must call update before calling getGeometryInstanceAttributes\");\n  } //>>includeEnd('debug');\n\n\n  return this._primitive.getGeometryInstanceAttributes(id);\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see GroundPrimitive#destroy\n */\n\n\nGroundPrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * e = e && e.destroy();\n *\n * @see GroundPrimitive#isDestroyed\n */\n\n\nGroundPrimitive.prototype.destroy = function () {\n  this._primitive = this._primitive && this._primitive.destroy();\n  return destroyObject(this);\n};\n/**\n * Exposed for testing.\n *\n * @param {Context} context Rendering context\n * @returns {Boolean} Whether or not the current context supports materials on GroundPrimitives.\n * @private\n */\n\n\nGroundPrimitive._supportsMaterials = function (context) {\n  return context.depthTexture;\n};\n/**\n * Checks if the given Scene supports materials on GroundPrimitives.\n * Materials on GroundPrimitives require support for the WEBGL_depth_texture extension.\n *\n * @param {Scene} scene The current scene.\n * @returns {Boolean} Whether or not the current scene supports materials on GroundPrimitives.\n */\n\n\nGroundPrimitive.supportsMaterials = function (scene) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scene\", scene); //>>includeEnd('debug');\n\n  return GroundPrimitive._supportsMaterials(scene.frameState.context);\n};\n\nexport default GroundPrimitive;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Scene/GroundPrimitive.js"],"names":["ApproximateTerrainHeights","BoundingSphere","Cartesian3","Cartographic","Check","defaultValue","defined","destroyObject","DeveloperError","GeometryInstance","OrientedBoundingBox","Rectangle","when","ClassificationPrimitive","ClassificationType","PerInstanceColorAppearance","SceneMode","ShadowVolumeAppearance","GroundPrimitiveUniformMap","u_globeMinimumAltitude","GroundPrimitive","options","EMPTY_OBJECT","appearance","geometryInstances","geometryInstancesArray","Array","isArray","geometryInstanceCount","length","i","attributes","color","flat","show","classificationType","BOTH","debugShowBoundingVolume","debugShowShadowVolume","_boundingVolumes","_boundingVolumes2D","_ready","_readyPromise","defer","_primitive","undefined","_maxHeight","_minHeight","_maxTerrainHeight","_defaultMaxTerrainHeight","_minTerrainHeight","_defaultMinTerrainHeight","_boundingSpheresKeys","_boundingSpheres","_useFragmentCulling","_zIndex","that","_classificationPrimitiveOptions","vertexCacheOptimize","interleave","releaseGeometryInstances","allowPicking","asynchronous","compressVertices","_createBoundingVolumeFunction","_updateAndQueueCommandsFunction","_pickPrimitive","_extruded","_uniformMap","Object","defineProperties","prototype","get","ready","readyPromise","promise","isSupported","getComputeMaximumHeightFunction","primitive","granularity","ellipsoid","r","maximumRadius","delta","Math","cos","getComputeMinimumHeightFunction","scratchBVCartesianHigh","scratchBVCartesianLow","scratchBVCartesian","scratchBVCartographic","scratchBVRectangle","getRectangle","frameState","geometry","mapProjection","position3DHigh","rectangle","highPositions","values","lowPositions","position3DLow","minLat","Number","POSITIVE_INFINITY","minLon","maxLat","NEGATIVE_INFINITY","maxLon","highPosition","unpack","lowPosition","position","add","cartographic","cartesianToCartographic","latitude","longitude","min","max","north","south","east","west","setMinMaxTerrainHeights","result","getMinimumMaximumHeights","minimumTerrainHeight","maximumTerrainHeight","createBoundingVolume","groundPrimitive","obb","fromRectangle","push","scene3DOnly","projection","boundingVolume","fromRectangleWithHeights2D","fromElements","center","z","x","y","boundingVolumeIndex","commandIndex","floor","updateAndQueueRenderCommand","command","modelMatrix","cull","classificationPrimitive","mode","SCENE3D","shaderProgram","_spColor","_needs2DShader","derivedCommands","appearance2D","owner","commandList","updateAndQueuePickCommand","_spPick","pick2D","updateAndQueueCommands","colorCommands","pickCommands","twoPasses","boundingVolumes","queueTerrainCommands","CESIUM_3D_TILE","queue3DTilesCommands","TERRAIN","passes","render","colorLength","tileset","invertClassification","ignoreShowCommands","_commandsIgnoreShow","ignoreShowCommandsLength","pick","pickLength","pickOffsets","_pickOffsets","pickOffset","index","initializeTerrainHeights","initialize","update","initialized","primitiveOptions","instance","instanceType","instances","groundInstances","instanceRectangle","clone","union","id","boundingSphere","getBoundingSphere","constructor","createShadowVolume","exaggeration","terrainExaggeration","useFragmentCulling","_supportsMaterials","context","usePlanarExtents","shouldUseSphericalCoordinates","boundingRectangle","textureCoordinateRotationPoints","getPlanarTextureCoordinateAttributes","getSphericalExtentGeometryInstanceAttributes","instanceAttributes","attributeKey","hasOwnProperty","then","error","_error","resolve","reject","indexOf","getGeometryInstanceAttributes","isDestroyed","destroy","depthTexture","supportsMaterials","scene","typeOf","object"],"mappings":"AAAA,OAAOA,yBAAP,MAAsC,sCAAtC;AACA,OAAOC,cAAP,MAA2B,2BAA3B;AACA,OAAOC,UAAP,MAAuB,uBAAvB;AACA,OAAOC,YAAP,MAAyB,yBAAzB;AACA,OAAOC,KAAP,MAAkB,kBAAlB;AACA,OAAOC,YAAP,MAAyB,yBAAzB;AACA,OAAOC,OAAP,MAAoB,oBAApB;AACA,OAAOC,aAAP,MAA0B,0BAA1B;AACA,OAAOC,cAAP,MAA2B,2BAA3B;AACA,OAAOC,gBAAP,MAA6B,6BAA7B;AACA,OAAOC,mBAAP,MAAgC,gCAAhC;AACA,OAAOC,SAAP,MAAsB,sBAAtB;AACA,OAAOC,IAAP,MAAiB,uBAAjB;AACA,OAAOC,uBAAP,MAAoC,8BAApC;AACA,OAAOC,kBAAP,MAA+B,yBAA/B;AACA,OAAOC,0BAAP,MAAuC,iCAAvC;AACA,OAAOC,SAAP,MAAsB,gBAAtB;AACA,OAAOC,sBAAP,MAAmC,6BAAnC;AAEA,IAAIC,yBAAyB,GAAG;AAC9BC,EAAAA,sBAAsB,EAAE,YAAY;AAClC,WAAO,OAAP;AACD;AAH6B,CAAhC;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwFA,SAASC,eAAT,CAAyBC,OAAzB,EAAkC;AAChCA,EAAAA,OAAO,GAAGhB,YAAY,CAACgB,OAAD,EAAUhB,YAAY,CAACiB,YAAvB,CAAtB;AAEA,MAAIC,UAAU,GAAGF,OAAO,CAACE,UAAzB;AACA,MAAIC,iBAAiB,GAAGH,OAAO,CAACG,iBAAhC;;AACA,MAAI,CAAClB,OAAO,CAACiB,UAAD,CAAR,IAAwBjB,OAAO,CAACkB,iBAAD,CAAnC,EAAwD;AACtD,QAAIC,sBAAsB,GAAGC,KAAK,CAACC,OAAN,CAAcH,iBAAd,IACzBA,iBADyB,GAEzB,CAACA,iBAAD,CAFJ;AAGA,QAAII,qBAAqB,GAAGH,sBAAsB,CAACI,MAAnD;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,qBAApB,EAA2CE,CAAC,EAA5C,EAAgD;AAC9C,UAAIC,UAAU,GAAGN,sBAAsB,CAACK,CAAD,CAAtB,CAA0BC,UAA3C;;AACA,UAAIzB,OAAO,CAACyB,UAAD,CAAP,IAAuBzB,OAAO,CAACyB,UAAU,CAACC,KAAZ,CAAlC,EAAsD;AACpDT,QAAAA,UAAU,GAAG,IAAIR,0BAAJ,CAA+B;AAC1CkB,UAAAA,IAAI,EAAE;AADoC,SAA/B,CAAb;AAGA;AACD;AACF;AACF;AACD;;;;;;;;;;;;AAUA,OAAKV,UAAL,GAAkBA,UAAlB;AAEA;;;;;;;;;;;;;;AAaA,OAAKC,iBAAL,GAAyBH,OAAO,CAACG,iBAAjC;AACA;;;;;;;;;AAQA,OAAKU,IAAL,GAAY7B,YAAY,CAACgB,OAAO,CAACa,IAAT,EAAe,IAAf,CAAxB;AACA;;;;;;;;AAOA,OAAKC,kBAAL,GAA0B9B,YAAY,CACpCgB,OAAO,CAACc,kBAD4B,EAEpCrB,kBAAkB,CAACsB,IAFiB,CAAtC;AAIA;;;;;;;;;;;AAUA,OAAKC,uBAAL,GAA+BhC,YAAY,CACzCgB,OAAO,CAACgB,uBADiC,EAEzC,KAFyC,CAA3C;AAKA;;;;;;;;;;;AAUA,OAAKC,qBAAL,GAA6BjC,YAAY,CACvCgB,OAAO,CAACiB,qBAD+B,EAEvC,KAFuC,CAAzC;AAKA,OAAKC,gBAAL,GAAwB,EAAxB;AACA,OAAKC,kBAAL,GAA0B,EAA1B;AAEA,OAAKC,MAAL,GAAc,KAAd;AACA,OAAKC,aAAL,GAAqB9B,IAAI,CAAC+B,KAAL,EAArB;AAEA,OAAKC,UAAL,GAAkBC,SAAlB;AAEA,OAAKC,UAAL,GAAkBD,SAAlB;AACA,OAAKE,UAAL,GAAkBF,SAAlB;AAEA,OAAKG,iBAAL,GAAyBhD,yBAAyB,CAACiD,wBAAnD;AACA,OAAKC,iBAAL,GAAyBlD,yBAAyB,CAACmD,wBAAnD;AAEA,OAAKC,oBAAL,GAA4B,EAA5B;AACA,OAAKC,gBAAL,GAAwB,EAAxB;AAEA,OAAKC,mBAAL,GAA2B,KAA3B,CAjHgC,CAkHhC;;AACA,OAAKC,OAAL,GAAeV,SAAf;AAEA,MAAIW,IAAI,GAAG,IAAX;AACA,OAAKC,+BAAL,GAAuC;AACrCjC,IAAAA,iBAAiB,EAAEqB,SADkB;AAErCtB,IAAAA,UAAU,EAAEsB,SAFyB;AAGrCa,IAAAA,mBAAmB,EAAErD,YAAY,CAACgB,OAAO,CAACqC,mBAAT,EAA8B,KAA9B,CAHI;AAIrCC,IAAAA,UAAU,EAAEtD,YAAY,CAACgB,OAAO,CAACsC,UAAT,EAAqB,KAArB,CAJa;AAKrCC,IAAAA,wBAAwB,EAAEvD,YAAY,CACpCgB,OAAO,CAACuC,wBAD4B,EAEpC,IAFoC,CALD;AASrCC,IAAAA,YAAY,EAAExD,YAAY,CAACgB,OAAO,CAACwC,YAAT,EAAuB,IAAvB,CATW;AAUrCC,IAAAA,YAAY,EAAEzD,YAAY,CAACgB,OAAO,CAACyC,YAAT,EAAuB,IAAvB,CAVW;AAWrCC,IAAAA,gBAAgB,EAAE1D,YAAY,CAACgB,OAAO,CAAC0C,gBAAT,EAA2B,IAA3B,CAXO;AAYrCC,IAAAA,6BAA6B,EAAEnB,SAZM;AAarCoB,IAAAA,+BAA+B,EAAEpB,SAbI;AAcrCqB,IAAAA,cAAc,EAAEV,IAdqB;AAerCW,IAAAA,SAAS,EAAE,IAf0B;AAgBrCC,IAAAA,WAAW,EAAElD;AAhBwB,GAAvC;AAkBD;;AAEDmD,MAAM,CAACC,gBAAP,CAAwBlD,eAAe,CAACmD,SAAxC,EAAmD;AACjD;;;;;;;;;;AAUAb,EAAAA,mBAAmB,EAAE;AACnBc,IAAAA,GAAG,EAAE,YAAY;AACf,aAAO,KAAKf,+BAAL,CAAqCC,mBAA5C;AACD;AAHkB,GAX4B;;AAiBjD;;;;;;;;;;AAUAC,EAAAA,UAAU,EAAE;AACVa,IAAAA,GAAG,EAAE,YAAY;AACf,aAAO,KAAKf,+BAAL,CAAqCE,UAA5C;AACD;AAHS,GA3BqC;;AAiCjD;;;;;;;;;;AAUAC,EAAAA,wBAAwB,EAAE;AACxBY,IAAAA,GAAG,EAAE,YAAY;AACf,aAAO,KAAKf,+BAAL,CAAqCG,wBAA5C;AACD;AAHuB,GA3CuB;;AAiDjD;;;;;;;;;;AAUAC,EAAAA,YAAY,EAAE;AACZW,IAAAA,GAAG,EAAE,YAAY;AACf,aAAO,KAAKf,+BAAL,CAAqCI,YAA5C;AACD;AAHW,GA3DmC;;AAiEjD;;;;;;;;;;AAUAC,EAAAA,YAAY,EAAE;AACZU,IAAAA,GAAG,EAAE,YAAY;AACf,aAAO,KAAKf,+BAAL,CAAqCK,YAA5C;AACD;AAHW,GA3EmC;;AAiFjD;;;;;;;;;;AAUAC,EAAAA,gBAAgB,EAAE;AAChBS,IAAAA,GAAG,EAAE,YAAY;AACf,aAAO,KAAKf,+BAAL,CAAqCM,gBAA5C;AACD;AAHe,GA3F+B;;AAiGjD;;;;;;;;;;AAUAU,EAAAA,KAAK,EAAE;AACLD,IAAAA,GAAG,EAAE,YAAY;AACf,aAAO,KAAK/B,MAAZ;AACD;AAHI,GA3G0C;;AAiHjD;;;;;;AAMAiC,EAAAA,YAAY,EAAE;AACZF,IAAAA,GAAG,EAAE,YAAY;AACf,aAAO,KAAK9B,aAAL,CAAmBiC,OAA1B;AACD;AAHW;AAvHmC,CAAnD;AA8HA;;;;;;;;AAOAvD,eAAe,CAACwD,WAAhB,GAA8B/D,uBAAuB,CAAC+D,WAAtD;;AAEA,SAASC,+BAAT,CAAyCC,SAAzC,EAAoD;AAClD,SAAO,UAAUC,WAAV,EAAuBC,SAAvB,EAAkC;AACvC,QAAIC,CAAC,GAAGD,SAAS,CAACE,aAAlB;AACA,QAAIC,KAAK,GAAGF,CAAC,GAAGG,IAAI,CAACC,GAAL,CAASN,WAAW,GAAG,GAAvB,CAAJ,GAAkCE,CAA9C;AACA,WAAOH,SAAS,CAAChC,UAAV,GAAuBqC,KAA9B;AACD,GAJD;AAKD;;AAED,SAASG,+BAAT,CAAyCR,SAAzC,EAAoD;AAClD,SAAO,UAAUC,WAAV,EAAuBC,SAAvB,EAAkC;AACvC,WAAOF,SAAS,CAAC/B,UAAjB;AACD,GAFD;AAGD;;AAED,IAAIwC,sBAAsB,GAAG,IAAIrF,UAAJ,EAA7B;AACA,IAAIsF,qBAAqB,GAAG,IAAItF,UAAJ,EAA5B;AACA,IAAIuF,kBAAkB,GAAG,IAAIvF,UAAJ,EAAzB;AACA,IAAIwF,qBAAqB,GAAG,IAAIvF,YAAJ,EAA5B;AACA,IAAIwF,kBAAkB,GAAG,IAAIhF,SAAJ,EAAzB;;AAEA,SAASiF,YAAT,CAAsBC,UAAtB,EAAkCC,QAAlC,EAA4C;AAC1C,MAAId,SAAS,GAAGa,UAAU,CAACE,aAAX,CAAyBf,SAAzC;;AAEA,MACE,CAAC1E,OAAO,CAACwF,QAAQ,CAAC/D,UAAV,CAAR,IACA,CAACzB,OAAO,CAACwF,QAAQ,CAAC/D,UAAT,CAAoBiE,cAArB,CAFV,EAGE;AACA,QAAI1F,OAAO,CAACwF,QAAQ,CAACG,SAAV,CAAX,EAAiC;AAC/B,aAAOH,QAAQ,CAACG,SAAhB;AACD;;AAED,WAAOpD,SAAP;AACD;;AAED,MAAIqD,aAAa,GAAGJ,QAAQ,CAAC/D,UAAT,CAAoBiE,cAApB,CAAmCG,MAAvD;AACA,MAAIC,YAAY,GAAGN,QAAQ,CAAC/D,UAAT,CAAoBsE,aAApB,CAAkCF,MAArD;AACA,MAAItE,MAAM,GAAGqE,aAAa,CAACrE,MAA3B;AAEA,MAAIyE,MAAM,GAAGC,MAAM,CAACC,iBAApB;AACA,MAAIC,MAAM,GAAGF,MAAM,CAACC,iBAApB;AACA,MAAIE,MAAM,GAAGH,MAAM,CAACI,iBAApB;AACA,MAAIC,MAAM,GAAGL,MAAM,CAACI,iBAApB;;AAEA,OAAK,IAAI7E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4BC,CAAC,IAAI,CAAjC,EAAoC;AAClC,QAAI+E,YAAY,GAAG3G,UAAU,CAAC4G,MAAX,CACjBZ,aADiB,EAEjBpE,CAFiB,EAGjByD,sBAHiB,CAAnB;AAKA,QAAIwB,WAAW,GAAG7G,UAAU,CAAC4G,MAAX,CAAkBV,YAAlB,EAAgCtE,CAAhC,EAAmC0D,qBAAnC,CAAlB;AAEA,QAAIwB,QAAQ,GAAG9G,UAAU,CAAC+G,GAAX,CACbJ,YADa,EAEbE,WAFa,EAGbtB,kBAHa,CAAf;AAKA,QAAIyB,YAAY,GAAGlC,SAAS,CAACmC,uBAAV,CACjBH,QADiB,EAEjBtB,qBAFiB,CAAnB;AAKA,QAAI0B,QAAQ,GAAGF,YAAY,CAACE,QAA5B;AACA,QAAIC,SAAS,GAAGH,YAAY,CAACG,SAA7B;AAEAf,IAAAA,MAAM,GAAGlB,IAAI,CAACkC,GAAL,CAAShB,MAAT,EAAiBc,QAAjB,CAAT;AACAX,IAAAA,MAAM,GAAGrB,IAAI,CAACkC,GAAL,CAASb,MAAT,EAAiBY,SAAjB,CAAT;AACAX,IAAAA,MAAM,GAAGtB,IAAI,CAACmC,GAAL,CAASb,MAAT,EAAiBU,QAAjB,CAAT;AACAR,IAAAA,MAAM,GAAGxB,IAAI,CAACmC,GAAL,CAASX,MAAT,EAAiBS,SAAjB,CAAT;AACD;;AAED,MAAIpB,SAAS,GAAGN,kBAAhB;AACAM,EAAAA,SAAS,CAACuB,KAAV,GAAkBd,MAAlB;AACAT,EAAAA,SAAS,CAACwB,KAAV,GAAkBnB,MAAlB;AACAL,EAAAA,SAAS,CAACyB,IAAV,GAAiBd,MAAjB;AACAX,EAAAA,SAAS,CAAC0B,IAAV,GAAiBlB,MAAjB;AAEA,SAAOR,SAAP;AACD;;AAED,SAAS2B,uBAAT,CAAiC9C,SAAjC,EAA4CmB,SAA5C,EAAuDjB,SAAvD,EAAkE;AAChE,MAAI6C,MAAM,GAAG7H,yBAAyB,CAAC8H,wBAA1B,CACX7B,SADW,EAEXjB,SAFW,CAAb;AAKAF,EAAAA,SAAS,CAAC5B,iBAAV,GAA8B2E,MAAM,CAACE,oBAArC;AACAjD,EAAAA,SAAS,CAAC9B,iBAAV,GAA8B6E,MAAM,CAACG,oBAArC;AACD;;AAED,SAASC,oBAAT,CAA8BC,eAA9B,EAA+CrC,UAA/C,EAA2DC,QAA3D,EAAqE;AACnE,MAAId,SAAS,GAAGa,UAAU,CAACE,aAAX,CAAyBf,SAAzC;AACA,MAAIiB,SAAS,GAAGL,YAAY,CAACC,UAAD,EAAaC,QAAb,CAA5B;AAEA,MAAIqC,GAAG,GAAGzH,mBAAmB,CAAC0H,aAApB,CACRnC,SADQ,EAERiC,eAAe,CAACnF,UAFR,EAGRmF,eAAe,CAACpF,UAHR,EAIRkC,SAJQ,CAAV;;AAMAkD,EAAAA,eAAe,CAAC3F,gBAAhB,CAAiC8F,IAAjC,CAAsCF,GAAtC;;AAEA,MAAI,CAACtC,UAAU,CAACyC,WAAhB,EAA6B;AAC3B,QAAIC,UAAU,GAAG1C,UAAU,CAACE,aAA5B;AACA,QAAIyC,cAAc,GAAGvI,cAAc,CAACwI,0BAAf,CACnBxC,SADmB,EAEnBsC,UAFmB,EAGnBL,eAAe,CAACpF,UAHG,EAInBoF,eAAe,CAACnF,UAJG,CAArB;AAMA7C,IAAAA,UAAU,CAACwI,YAAX,CACEF,cAAc,CAACG,MAAf,CAAsBC,CADxB,EAEEJ,cAAc,CAACG,MAAf,CAAsBE,CAFxB,EAGEL,cAAc,CAACG,MAAf,CAAsBG,CAHxB,EAIEN,cAAc,CAACG,MAJjB;;AAOAT,IAAAA,eAAe,CAAC1F,kBAAhB,CAAmC6F,IAAnC,CAAwCG,cAAxC;AACD;AACF;;AAED,SAASO,mBAAT,CAA6BC,YAA7B,EAA2CnH,MAA3C,EAAmD;AACjD,SAAOuD,IAAI,CAAC6D,KAAL,CAAYD,YAAY,GAAGnH,MAAhB,GAA0B,CAArC,CAAP;AACD;;AAED,SAASqH,2BAAT,CACEhB,eADF,EAEEiB,OAFF,EAGEtD,UAHF,EAIEuD,WAJF,EAKEC,IALF,EAMEb,cANF,EAOEnG,uBAPF,EAQE;AACA;AACA,MAAIiH,uBAAuB,GAAGpB,eAAe,CAACtF,UAA9C;;AACA,MACEiD,UAAU,CAAC0D,IAAX,KAAoBvI,SAAS,CAACwI,OAA9B,IACAL,OAAO,CAACM,aAAR,KAA0BH,uBAAuB,CAACI,QADlD,IAEAJ,uBAAuB,CAACK,cAH1B,EAIE;AACAR,IAAAA,OAAO,GAAGA,OAAO,CAACS,eAAR,CAAwBC,YAAlC;AACD;;AAEDV,EAAAA,OAAO,CAACW,KAAR,GAAgB5B,eAAhB;AACAiB,EAAAA,OAAO,CAACC,WAAR,GAAsBA,WAAtB;AACAD,EAAAA,OAAO,CAACX,cAAR,GAAyBA,cAAzB;AACAW,EAAAA,OAAO,CAACE,IAAR,GAAeA,IAAf;AACAF,EAAAA,OAAO,CAAC9G,uBAAR,GAAkCA,uBAAlC;AAEAwD,EAAAA,UAAU,CAACkE,WAAX,CAAuB1B,IAAvB,CAA4Bc,OAA5B;AACD;;AAED,SAASa,yBAAT,CACE9B,eADF,EAEEiB,OAFF,EAGEtD,UAHF,EAIEuD,WAJF,EAKEC,IALF,EAMEb,cANF,EAOE;AACA;AACA,MAAIc,uBAAuB,GAAGpB,eAAe,CAACtF,UAA9C;;AACA,MACEiD,UAAU,CAAC0D,IAAX,KAAoBvI,SAAS,CAACwI,OAA9B,IACAL,OAAO,CAACM,aAAR,KAA0BH,uBAAuB,CAACW,OADlD,IAEAX,uBAAuB,CAACK,cAH1B,EAIE;AACAR,IAAAA,OAAO,GAAGA,OAAO,CAACS,eAAR,CAAwBM,MAAlC;AACD;;AAEDf,EAAAA,OAAO,CAACW,KAAR,GAAgB5B,eAAhB;AACAiB,EAAAA,OAAO,CAACC,WAAR,GAAsBA,WAAtB;AACAD,EAAAA,OAAO,CAACX,cAAR,GAAyBA,cAAzB;AACAW,EAAAA,OAAO,CAACE,IAAR,GAAeA,IAAf;AAEAxD,EAAAA,UAAU,CAACkE,WAAX,CAAuB1B,IAAvB,CAA4Bc,OAA5B;AACD;;AAED,SAASgB,sBAAT,CACEjC,eADF,EAEErC,UAFF,EAGEuE,aAHF,EAIEC,YAJF,EAKEjB,WALF,EAMEC,IANF,EAOEhH,uBAPF,EAQEiI,SARF,EASE;AACA,MAAIC,eAAJ;;AACA,MAAI1E,UAAU,CAAC0D,IAAX,KAAoBvI,SAAS,CAACwI,OAAlC,EAA2C;AACzCe,IAAAA,eAAe,GAAGrC,eAAe,CAAC3F,gBAAlC;AACD,GAFD,MAEO;AACLgI,IAAAA,eAAe,GAAGrC,eAAe,CAAC1F,kBAAlC;AACD;;AAED,MAAIL,kBAAkB,GAAG+F,eAAe,CAAC/F,kBAAzC;AACA,MAAIqI,oBAAoB,GACtBrI,kBAAkB,KAAKrB,kBAAkB,CAAC2J,cAD5C;AAEA,MAAIC,oBAAoB,GAAGvI,kBAAkB,KAAKrB,kBAAkB,CAAC6J,OAArE;AAEA,MAAIC,MAAM,GAAG/E,UAAU,CAAC+E,MAAxB;AACA,MAAItB,uBAAuB,GAAGpB,eAAe,CAACtF,UAA9C;AAEA,MAAId,CAAJ;AACA,MAAI0G,cAAJ;AACA,MAAIW,OAAJ;;AAEA,MAAIyB,MAAM,CAACC,MAAX,EAAmB;AACjB,QAAIC,WAAW,GAAGV,aAAa,CAACvI,MAAhC;;AAEA,SAAKC,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGgJ,WAAhB,EAA6B,EAAEhJ,CAA/B,EAAkC;AAChC0G,MAAAA,cAAc,GAAG+B,eAAe,CAACxB,mBAAmB,CAACjH,CAAD,EAAIgJ,WAAJ,CAApB,CAAhC;;AACA,UAAIN,oBAAJ,EAA0B;AACxBrB,QAAAA,OAAO,GAAGiB,aAAa,CAACtI,CAAD,CAAvB;AACAoH,QAAAA,2BAA2B,CACzBhB,eADyB,EAEzBiB,OAFyB,EAGzBtD,UAHyB,EAIzBuD,WAJyB,EAKzBC,IALyB,EAMzBb,cANyB,EAOzBnG,uBAPyB,CAA3B;AASD;;AACD,UAAIqI,oBAAJ,EAA0B;AACxBvB,QAAAA,OAAO,GAAGiB,aAAa,CAACtI,CAAD,CAAb,CAAiB8H,eAAjB,CAAiCmB,OAA3C;AACA7B,QAAAA,2BAA2B,CACzBhB,eADyB,EAEzBiB,OAFyB,EAGzBtD,UAHyB,EAIzBuD,WAJyB,EAKzBC,IALyB,EAMzBb,cANyB,EAOzBnG,uBAPyB,CAA3B;AASD;AACF;;AAED,QAAIwD,UAAU,CAACmF,oBAAf,EAAqC;AACnC,UAAIC,kBAAkB,GAAG3B,uBAAuB,CAAC4B,mBAAjD;AACA,UAAIC,wBAAwB,GAAGF,kBAAkB,CAACpJ,MAAlD;;AACA,WAAKC,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGqJ,wBAAhB,EAA0C,EAAErJ,CAA5C,EAA+C;AAC7C0G,QAAAA,cAAc,GAAG+B,eAAe,CAACnF,IAAI,CAAC6D,KAAL,CAAWnH,CAAC,GAAG,CAAf,CAAD,CAAhC;AACAqH,QAAAA,OAAO,GAAG8B,kBAAkB,CAACnJ,CAAD,CAA5B;AACAoH,QAAAA,2BAA2B,CACzBhB,eADyB,EAEzBiB,OAFyB,EAGzBtD,UAHyB,EAIzBuD,WAJyB,EAKzBC,IALyB,EAMzBb,cANyB,EAOzBnG,uBAPyB,CAA3B;AASD;AACF;AACF;;AAED,MAAIuI,MAAM,CAACQ,IAAX,EAAiB;AACf,QAAIC,UAAU,GAAGhB,YAAY,CAACxI,MAA9B;AAEA,QAAIyJ,WAAJ;;AACA,QAAI,CAACpD,eAAe,CAAC5E,mBAArB,EAA0C;AACxC;AACAgI,MAAAA,WAAW,GAAGhC,uBAAuB,CAAC1G,UAAxB,CAAmC2I,YAAjD;AACD;;AACD,SAAKzJ,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGuJ,UAAhB,EAA4B,EAAEvJ,CAA9B,EAAiC;AAC/B0G,MAAAA,cAAc,GAAG+B,eAAe,CAACxB,mBAAmB,CAACjH,CAAD,EAAIuJ,UAAJ,CAApB,CAAhC;;AACA,UAAI,CAACnD,eAAe,CAAC5E,mBAArB,EAA0C;AACxC,YAAIkI,UAAU,GAAGF,WAAW,CAACvC,mBAAmB,CAACjH,CAAD,EAAIuJ,UAAJ,CAApB,CAA5B;AACA7C,QAAAA,cAAc,GAAG+B,eAAe,CAACiB,UAAU,CAACC,KAAZ,CAAhC;AACD;;AACD,UAAIjB,oBAAJ,EAA0B;AACxBrB,QAAAA,OAAO,GAAGkB,YAAY,CAACvI,CAAD,CAAtB;AACAkI,QAAAA,yBAAyB,CACvB9B,eADuB,EAEvBiB,OAFuB,EAGvBtD,UAHuB,EAIvBuD,WAJuB,EAKvBC,IALuB,EAMvBb,cANuB,CAAzB;AAQD;;AACD,UAAIkC,oBAAJ,EAA0B;AACxBvB,QAAAA,OAAO,GAAGkB,YAAY,CAACvI,CAAD,CAAZ,CAAgB8H,eAAhB,CAAgCmB,OAA1C;AACAf,QAAAA,yBAAyB,CACvB9B,eADuB,EAEvBiB,OAFuB,EAGvBtD,UAHuB,EAIvBuD,WAJuB,EAKvBC,IALuB,EAMvBb,cANuB,CAAzB;AAQD;AACF;AACF;AACF;AAED;;;;;;;;;AAOApH,eAAe,CAACsK,wBAAhB,GAA2C,YAAY;AACrD,SAAO1L,yBAAyB,CAAC2L,UAA1B,EAAP;AACD,CAFD;AAIA;;;;;;;;;;;;;;AAYAvK,eAAe,CAACmD,SAAhB,CAA0BqH,MAA1B,GAAmC,UAAU/F,UAAV,EAAsB;AACvD,MAAI,CAACvF,OAAO,CAAC,KAAKsC,UAAN,CAAR,IAA6B,CAACtC,OAAO,CAAC,KAAKkB,iBAAN,CAAzC,EAAmE;AACjE;AACD;;AAED,MAAI,CAACxB,yBAAyB,CAAC6L,WAA/B,EAA4C;AAC1C;AACA,QAAI,CAAC,KAAK/H,YAAV,EAAwB;AACtB,YAAM,IAAItD,cAAJ,CACJ,0IADI,CAAN;AAGD,KANyC,CAO1C;;;AAEAY,IAAAA,eAAe,CAACsK,wBAAhB;AACA;AACD;;AAED,MAAIlI,IAAI,GAAG,IAAX;AACA,MAAIsI,gBAAgB,GAAG,KAAKrI,+BAA5B;;AAEA,MAAI,CAACnD,OAAO,CAAC,KAAKsC,UAAN,CAAZ,EAA+B;AAC7B,QAAIoC,SAAS,GAAGa,UAAU,CAACE,aAAX,CAAyBf,SAAzC;AAEA,QAAI+G,QAAJ;AACA,QAAIjG,QAAJ;AACA,QAAIkG,YAAJ;AAEA,QAAIC,SAAS,GAAGvK,KAAK,CAACC,OAAN,CAAc,KAAKH,iBAAnB,IACZ,KAAKA,iBADO,GAEZ,CAAC,KAAKA,iBAAN,CAFJ;AAGA,QAAIK,MAAM,GAAGoK,SAAS,CAACpK,MAAvB;AACA,QAAIqK,eAAe,GAAG,IAAIxK,KAAJ,CAAUG,MAAV,CAAtB;AAEA,QAAIC,CAAJ;AACA,QAAImE,SAAJ;;AACA,SAAKnE,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGD,MAAhB,EAAwB,EAAEC,CAA1B,EAA6B;AAC3BiK,MAAAA,QAAQ,GAAGE,SAAS,CAACnK,CAAD,CAApB;AACAgE,MAAAA,QAAQ,GAAGiG,QAAQ,CAACjG,QAApB;AACA,UAAIqG,iBAAiB,GAAGvG,YAAY,CAACC,UAAD,EAAaC,QAAb,CAApC;;AACA,UAAI,CAACxF,OAAO,CAAC2F,SAAD,CAAZ,EAAyB;AACvBA,QAAAA,SAAS,GAAGtF,SAAS,CAACyL,KAAV,CAAgBD,iBAAhB,CAAZ;AACD,OAFD,MAEO,IAAI7L,OAAO,CAAC6L,iBAAD,CAAX,EAAgC;AACrCxL,QAAAA,SAAS,CAAC0L,KAAV,CAAgBpG,SAAhB,EAA2BkG,iBAA3B,EAA8ClG,SAA9C;AACD;;AAED,UAAIqG,EAAE,GAAGP,QAAQ,CAACO,EAAlB;;AACA,UAAIhM,OAAO,CAACgM,EAAD,CAAP,IAAehM,OAAO,CAAC6L,iBAAD,CAA1B,EAA+C;AAC7C,YAAII,cAAc,GAAGvM,yBAAyB,CAACwM,iBAA1B,CACnBL,iBADmB,EAEnBnH,SAFmB,CAArB;;AAIA,aAAK5B,oBAAL,CAA0BiF,IAA1B,CAA+BiE,EAA/B;;AACA,aAAKjJ,gBAAL,CAAsBgF,IAAtB,CAA2BkE,cAA3B;AACD;;AAEDP,MAAAA,YAAY,GAAGlG,QAAQ,CAAC2G,WAAxB;;AACA,UAAI,CAACnM,OAAO,CAAC0L,YAAD,CAAR,IAA0B,CAAC1L,OAAO,CAAC0L,YAAY,CAACU,kBAAd,CAAtC,EAAyE;AACvE;AACA,cAAM,IAAIlM,cAAJ,CACJ,iEADI,CAAN,CAFuE,CAKvE;AACD;AACF,KA3C4B,CA6C7B;;;AACAoH,IAAAA,uBAAuB,CAAC,IAAD,EAAO3B,SAAP,EAAkBjB,SAAlB,CAAvB;AACA,QAAI2H,YAAY,GAAG9G,UAAU,CAAC+G,mBAA9B;AACA,SAAK7J,UAAL,GAAkB,KAAKG,iBAAL,GAAyByJ,YAA3C;AACA,SAAK7J,UAAL,GAAkB,KAAKE,iBAAL,GAAyB2J,YAA3C;;AAEA,QAAIE,kBAAkB,GAAGzL,eAAe,CAAC0L,kBAAhB,CACvBjH,UAAU,CAACkH,OADY,CAAzB;;AAGA,SAAKzJ,mBAAL,GAA2BuJ,kBAA3B;;AAEA,QAAIA,kBAAJ,EAAwB;AACtB;AACA;AACA,UAAI9K,UAAJ;AACA,UAAIiL,gBAAgB,GAAG,IAAvB;;AACA,WAAKlL,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGD,MAAhB,EAAwB,EAAEC,CAA1B,EAA6B;AAC3BiK,QAAAA,QAAQ,GAAGE,SAAS,CAACnK,CAAD,CAApB;AACAgE,QAAAA,QAAQ,GAAGiG,QAAQ,CAACjG,QAApB;AACAG,QAAAA,SAAS,GAAGL,YAAY,CAACC,UAAD,EAAaC,QAAb,CAAxB;;AACA,YAAI7E,sBAAsB,CAACgM,6BAAvB,CAAqDhH,SAArD,CAAJ,EAAqE;AACnE+G,UAAAA,gBAAgB,GAAG,KAAnB;AACA;AACD;AACF;;AAED,WAAKlL,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGD,MAAhB,EAAwB,EAAEC,CAA1B,EAA6B;AAC3BiK,QAAAA,QAAQ,GAAGE,SAAS,CAACnK,CAAD,CAApB;AACAgE,QAAAA,QAAQ,GAAGiG,QAAQ,CAACjG,QAApB;AACAkG,QAAAA,YAAY,GAAGlG,QAAQ,CAAC2G,WAAxB;AAEA,YAAIS,iBAAiB,GAAGtH,YAAY,CAACC,UAAD,EAAaC,QAAb,CAApC;AACA,YAAIqH,+BAA+B,GACjCrH,QAAQ,CAACqH,+BADX;;AAGA,YAAIH,gBAAJ,EAAsB;AACpBjL,UAAAA,UAAU,GAAGd,sBAAsB,CAACmM,oCAAvB,CACXF,iBADW,EAEXC,+BAFW,EAGXnI,SAHW,EAIXa,UAAU,CAACE,aAJA,EAKX,KAAKjD,UALM,CAAb;AAOD,SARD,MAQO;AACLf,UAAAA,UAAU,GAAGd,sBAAsB,CAACoM,4CAAvB,CACXH,iBADW,EAEXC,+BAFW,EAGXnI,SAHW,EAIXa,UAAU,CAACE,aAJA,CAAb;AAMD;;AAED,YAAIuH,kBAAkB,GAAGvB,QAAQ,CAAChK,UAAlC;;AACA,aAAK,IAAIwL,YAAT,IAAyBD,kBAAzB,EAA6C;AAC3C,cAAIA,kBAAkB,CAACE,cAAnB,CAAkCD,YAAlC,CAAJ,EAAqD;AACnDxL,YAAAA,UAAU,CAACwL,YAAD,CAAV,GAA2BD,kBAAkB,CAACC,YAAD,CAA7C;AACD;AACF;;AAEDrB,QAAAA,eAAe,CAACpK,CAAD,CAAf,GAAqB,IAAIrB,gBAAJ,CAAqB;AACxCqF,UAAAA,QAAQ,EAAEkG,YAAY,CAACU,kBAAb,CACR5G,QADQ,EAERR,+BAA+B,CAAC,IAAD,CAFvB,EAGRT,+BAA+B,CAAC,IAAD,CAHvB,CAD8B;AAMxC9C,UAAAA,UAAU,EAAEA,UAN4B;AAOxCuK,UAAAA,EAAE,EAAEP,QAAQ,CAACO;AAP2B,SAArB,CAArB;AASD;AACF,KA1DD,MA0DO;AACL;AACA,WAAKxK,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGD,MAAhB,EAAwB,EAAEC,CAA1B,EAA6B;AAC3BiK,QAAAA,QAAQ,GAAGE,SAAS,CAACnK,CAAD,CAApB;AACAgE,QAAAA,QAAQ,GAAGiG,QAAQ,CAACjG,QAApB;AACAkG,QAAAA,YAAY,GAAGlG,QAAQ,CAAC2G,WAAxB;AACAP,QAAAA,eAAe,CAACpK,CAAD,CAAf,GAAqB,IAAIrB,gBAAJ,CAAqB;AACxCqF,UAAAA,QAAQ,EAAEkG,YAAY,CAACU,kBAAb,CACR5G,QADQ,EAERR,+BAA+B,CAAC,IAAD,CAFvB,EAGRT,+BAA+B,CAAC,IAAD,CAHvB,CAD8B;AAMxC9C,UAAAA,UAAU,EAAEgK,QAAQ,CAAChK,UANmB;AAOxCuK,UAAAA,EAAE,EAAEP,QAAQ,CAACO;AAP2B,SAArB,CAArB;AASD;AACF;;AAEDR,IAAAA,gBAAgB,CAACtK,iBAAjB,GAAqC0K,eAArC;AACAJ,IAAAA,gBAAgB,CAACvK,UAAjB,GAA8B,KAAKA,UAAnC;;AAEAuK,IAAAA,gBAAgB,CAAC9H,6BAAjB,GAAiD,UAC/C6B,UAD+C,EAE/CC,QAF+C,EAG/C;AACAmC,MAAAA,oBAAoB,CAACzE,IAAD,EAAOqC,UAAP,EAAmBC,QAAnB,CAApB;AACD,KALD;;AAMAgG,IAAAA,gBAAgB,CAAC7H,+BAAjB,GAAmD,UACjDa,SADiD,EAEjDe,UAFiD,EAGjDuE,aAHiD,EAIjDC,YAJiD,EAKjDjB,WALiD,EAMjDC,IANiD,EAOjDhH,uBAPiD,EAQjDiI,SARiD,EASjD;AACAH,MAAAA,sBAAsB,CACpB3G,IADoB,EAEpBqC,UAFoB,EAGpBuE,aAHoB,EAIpBC,YAJoB,EAKpBjB,WALoB,EAMpBC,IANoB,EAOpBhH,uBAPoB,EAQpBiI,SARoB,CAAtB;AAUD,KApBD;;AAsBA,SAAK1H,UAAL,GAAkB,IAAI/B,uBAAJ,CAA4BiL,gBAA5B,CAAlB;;AACA,SAAKlJ,UAAL,CAAgB8B,YAAhB,CAA6B+I,IAA7B,CAAkC,UAAU3I,SAAV,EAAqB;AACrDtB,MAAAA,IAAI,CAACf,MAAL,GAAc,IAAd;;AAEA,UAAIe,IAAI,CAACI,wBAAT,EAAmC;AACjCJ,QAAAA,IAAI,CAAChC,iBAAL,GAAyBqB,SAAzB;AACD;;AAED,UAAI6K,KAAK,GAAG5I,SAAS,CAAC6I,MAAtB;;AACA,UAAI,CAACrN,OAAO,CAACoN,KAAD,CAAZ,EAAqB;AACnBlK,QAAAA,IAAI,CAACd,aAAL,CAAmBkL,OAAnB,CAA2BpK,IAA3B;AACD,OAFD,MAEO;AACLA,QAAAA,IAAI,CAACd,aAAL,CAAmBmL,MAAnB,CAA0BH,KAA1B;AACD;AACF,KAbD;AAcD;;AAED,OAAK9K,UAAL,CAAgBrB,UAAhB,GAA6B,KAAKA,UAAlC;AACA,OAAKqB,UAAL,CAAgBV,IAAhB,GAAuB,KAAKA,IAA5B;AACA,OAAKU,UAAL,CAAgBN,qBAAhB,GAAwC,KAAKA,qBAA7C;AACA,OAAKM,UAAL,CAAgBP,uBAAhB,GAA0C,KAAKA,uBAA/C;;AACA,OAAKO,UAAL,CAAgBgJ,MAAhB,CAAuB/F,UAAvB;AACD,CA9MD;AAgNA;;;;;AAGAzE,eAAe,CAACmD,SAAhB,CAA0BiI,iBAA1B,GAA8C,UAAUF,EAAV,EAAc;AAC1D,MAAIb,KAAK,GAAG,KAAKrI,oBAAL,CAA0B0K,OAA1B,CAAkCxB,EAAlC,CAAZ;;AACA,MAAIb,KAAK,KAAK,CAAC,CAAf,EAAkB;AAChB,WAAO,KAAKpI,gBAAL,CAAsBoI,KAAtB,CAAP;AACD;;AAED,SAAO5I,SAAP;AACD,CAPD;AASA;;;;;;;;;;;;;;;AAaAzB,eAAe,CAACmD,SAAhB,CAA0BwJ,6BAA1B,GAA0D,UAAUzB,EAAV,EAAc;AACtE;AACA,MAAI,CAAChM,OAAO,CAAC,KAAKsC,UAAN,CAAZ,EAA+B;AAC7B,UAAM,IAAIpC,cAAJ,CACJ,+DADI,CAAN;AAGD,GANqE,CAOtE;;;AACA,SAAO,KAAKoC,UAAL,CAAgBmL,6BAAhB,CAA8CzB,EAA9C,CAAP;AACD,CATD;AAWA;;;;;;;;;;;;;AAWAlL,eAAe,CAACmD,SAAhB,CAA0ByJ,WAA1B,GAAwC,YAAY;AAClD,SAAO,KAAP;AACD,CAFD;AAIA;;;;;;;;;;;;;;;;;;AAgBA5M,eAAe,CAACmD,SAAhB,CAA0B0J,OAA1B,GAAoC,YAAY;AAC9C,OAAKrL,UAAL,GAAkB,KAAKA,UAAL,IAAmB,KAAKA,UAAL,CAAgBqL,OAAhB,EAArC;AACA,SAAO1N,aAAa,CAAC,IAAD,CAApB;AACD,CAHD;AAKA;;;;;;;;;AAOAa,eAAe,CAAC0L,kBAAhB,GAAqC,UAAUC,OAAV,EAAmB;AACtD,SAAOA,OAAO,CAACmB,YAAf;AACD,CAFD;AAIA;;;;;;;;;AAOA9M,eAAe,CAAC+M,iBAAhB,GAAoC,UAAUC,KAAV,EAAiB;AACnD;AACAhO,EAAAA,KAAK,CAACiO,MAAN,CAAaC,MAAb,CAAoB,OAApB,EAA6BF,KAA7B,EAFmD,CAGnD;;AAEA,SAAOhN,eAAe,CAAC0L,kBAAhB,CAAmCsB,KAAK,CAACvI,UAAN,CAAiBkH,OAApD,CAAP;AACD,CAND;;AAOA,eAAe3L,eAAf","sourcesContent":["import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport when from \"../ThirdParty/when.js\";\nimport ClassificationPrimitive from \"./ClassificationPrimitive.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowVolumeAppearance from \"./ShadowVolumeAppearance.js\";\n\nvar GroundPrimitiveUniformMap = {\n  u_globeMinimumAltitude: function () {\n    return 55000.0;\n  },\n};\n\n/**\n * A ground primitive represents geometry draped over terrain or 3D Tiles in the {@link Scene}.\n * <p>\n * A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including\n * {@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,\n * and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix\n * and match most of them and add a new geometry or appearance independently of each other.\n * </p>\n * <p>\n * Support for the WEBGL_depth_texture extension is required to use GeometryInstances with different PerInstanceColors\n * or materials besides PerInstanceColorAppearance.\n * </p>\n * <p>\n * Textured GroundPrimitives were designed for notional patterns and are not meant for precisely mapping\n * textures to terrain - for that use case, use {@link SingleTileImageryProvider}.\n * </p>\n * <p>\n * For correct rendering, this feature requires the EXT_frag_depth WebGL extension. For hardware that do not support this extension, there\n * will be rendering artifacts for some viewing angles.\n * </p>\n * <p>\n * Valid geometries are {@link CircleGeometry}, {@link CorridorGeometry}, {@link EllipseGeometry}, {@link PolygonGeometry}, and {@link RectangleGeometry}.\n * </p>\n *\n * @alias GroundPrimitive\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Array|GeometryInstance} [options.geometryInstances] The geometry instances to render.\n * @param {Appearance} [options.appearance] The appearance used to render the primitive. Defaults to a flat PerInstanceColorAppearance when GeometryInstances have a color attribute.\n * @param {Boolean} [options.show=true] Determines if this primitive will be shown.\n * @param {Boolean} [options.vertexCacheOptimize=false] When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n * @param {Boolean} [options.interleave=false] When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.\n * @param {Boolean} [options.compressVertices=true] When <code>true</code>, the geometry vertices are compressed, which will save memory.\n * @param {Boolean} [options.releaseGeometryInstances=true] When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n * @param {Boolean} [options.asynchronous=true] Determines if the primitive will be created asynchronously or block until ready. If false initializeTerrainHeights() must be called first.\n * @param {ClassificationType} [options.classificationType=ClassificationType.BOTH] Determines whether terrain, 3D Tiles or both will be classified.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {Boolean} [options.debugShowShadowVolume=false] For debugging only. Determines if the shadow volume for each geometry in the primitive is drawn. Must be <code>true</code> on\n *                  creation for the volumes to be created before the geometry is released or options.releaseGeometryInstance must be <code>false</code>.\n *\n * @example\n * // Example 1: Create primitive with a single instance\n * var rectangleInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0)\n *   }),\n *   id : 'rectangle',\n *   attributes : {\n *     color : new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5)\n *   }\n * });\n * scene.primitives.add(new Cesium.GroundPrimitive({\n *   geometryInstances : rectangleInstance\n * }));\n *\n * // Example 2: Batch instances\n * var color = new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5); // Both instances must have the same color.\n * var rectangleInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0)\n *   }),\n *   id : 'rectangle',\n *   attributes : {\n *     color : color\n *   }\n * });\n * var ellipseInstance = new Cesium.GeometryInstance({\n *     geometry : new Cesium.EllipseGeometry({\n *         center : Cesium.Cartesian3.fromDegrees(-105.0, 40.0),\n *         semiMinorAxis : 300000.0,\n *         semiMajorAxis : 400000.0\n *     }),\n *     id : 'ellipse',\n *     attributes : {\n *         color : color\n *     }\n * });\n * scene.primitives.add(new Cesium.GroundPrimitive({\n *   geometryInstances : [rectangleInstance, ellipseInstance]\n * }));\n *\n * @see Primitive\n * @see ClassificationPrimitive\n * @see GeometryInstance\n * @see Appearance\n */\nfunction GroundPrimitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var appearance = options.appearance;\n  var geometryInstances = options.geometryInstances;\n  if (!defined(appearance) && defined(geometryInstances)) {\n    var geometryInstancesArray = Array.isArray(geometryInstances)\n      ? geometryInstances\n      : [geometryInstances];\n    var geometryInstanceCount = geometryInstancesArray.length;\n    for (var i = 0; i < geometryInstanceCount; i++) {\n      var attributes = geometryInstancesArray[i].attributes;\n      if (defined(attributes) && defined(attributes.color)) {\n        appearance = new PerInstanceColorAppearance({\n          flat: true,\n        });\n        break;\n      }\n    }\n  }\n  /**\n   * The {@link Appearance} used to shade this primitive. Each geometry\n   * instance is shaded with the same appearance.  Some appearances, like\n   * {@link PerInstanceColorAppearance} allow giving each instance unique\n   * properties.\n   *\n   * @type Appearance\n   *\n   * @default undefined\n   */\n  this.appearance = appearance;\n\n  /**\n   * The geometry instances rendered with this primitive.  This may\n   * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>\n   * is <code>true</code> when the primitive is constructed.\n   * <p>\n   * Changing this property after the primitive is rendered has no effect.\n   * </p>\n   *\n   * @readonly\n   * @type {Array|GeometryInstance}\n   *\n   * @default undefined\n   */\n  this.geometryInstances = options.geometryInstances;\n  /**\n   * Determines if the primitive will be shown.  This affects all geometry\n   * instances in the primitive.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n  /**\n   * Determines whether terrain, 3D Tiles or both will be classified.\n   *\n   * @type {ClassificationType}\n   *\n   * @default ClassificationType.BOTH\n   */\n  this.classificationType = defaultValue(\n    options.classificationType,\n    ClassificationType.BOTH\n  );\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false\n  );\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the shadow volume for each geometry in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugShowShadowVolume = defaultValue(\n    options.debugShowShadowVolume,\n    false\n  );\n\n  this._boundingVolumes = [];\n  this._boundingVolumes2D = [];\n\n  this._ready = false;\n  this._readyPromise = when.defer();\n\n  this._primitive = undefined;\n\n  this._maxHeight = undefined;\n  this._minHeight = undefined;\n\n  this._maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n  this._minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\n\n  this._boundingSpheresKeys = [];\n  this._boundingSpheres = [];\n\n  this._useFragmentCulling = false;\n  // Used when inserting in an OrderedPrimitiveCollection\n  this._zIndex = undefined;\n\n  var that = this;\n  this._classificationPrimitiveOptions = {\n    geometryInstances: undefined,\n    appearance: undefined,\n    vertexCacheOptimize: defaultValue(options.vertexCacheOptimize, false),\n    interleave: defaultValue(options.interleave, false),\n    releaseGeometryInstances: defaultValue(\n      options.releaseGeometryInstances,\n      true\n    ),\n    allowPicking: defaultValue(options.allowPicking, true),\n    asynchronous: defaultValue(options.asynchronous, true),\n    compressVertices: defaultValue(options.compressVertices, true),\n    _createBoundingVolumeFunction: undefined,\n    _updateAndQueueCommandsFunction: undefined,\n    _pickPrimitive: that,\n    _extruded: true,\n    _uniformMap: GroundPrimitiveUniformMap,\n  };\n}\n\nObject.defineProperties(GroundPrimitive.prototype, {\n  /**\n   * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  vertexCacheOptimize: {\n    get: function () {\n      return this._classificationPrimitiveOptions.vertexCacheOptimize;\n    },\n  },\n\n  /**\n   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  interleave: {\n    get: function () {\n      return this._classificationPrimitiveOptions.interleave;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  releaseGeometryInstances: {\n    get: function () {\n      return this._classificationPrimitiveOptions.releaseGeometryInstances;\n    },\n  },\n\n  /**\n   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._classificationPrimitiveOptions.allowPicking;\n    },\n  },\n\n  /**\n   * Determines if the geometry instances will be created and batched on a web worker.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._classificationPrimitiveOptions.asynchronous;\n    },\n  },\n\n  /**\n   * When <code>true</code>, geometry vertices are compressed, which will save memory.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  compressVertices: {\n    get: function () {\n      return this._classificationPrimitiveOptions.compressVertices;\n    },\n  },\n\n  /**\n   * Determines if the primitive is complete and ready to render.  If this property is\n   * true, the primitive will be rendered the next time that {@link GroundPrimitive#update}\n   * is called.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves when the primitive is ready to render.\n   * @memberof GroundPrimitive.prototype\n   * @type {Promise.<GroundPrimitive>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n});\n\n/**\n * Determines if GroundPrimitive rendering is supported.\n *\n * @function\n * @param {Scene} scene The scene.\n * @returns {Boolean} <code>true</code> if GroundPrimitives are supported; otherwise, returns <code>false</code>\n */\nGroundPrimitive.isSupported = ClassificationPrimitive.isSupported;\n\nfunction getComputeMaximumHeightFunction(primitive) {\n  return function (granularity, ellipsoid) {\n    var r = ellipsoid.maximumRadius;\n    var delta = r / Math.cos(granularity * 0.5) - r;\n    return primitive._maxHeight + delta;\n  };\n}\n\nfunction getComputeMinimumHeightFunction(primitive) {\n  return function (granularity, ellipsoid) {\n    return primitive._minHeight;\n  };\n}\n\nvar scratchBVCartesianHigh = new Cartesian3();\nvar scratchBVCartesianLow = new Cartesian3();\nvar scratchBVCartesian = new Cartesian3();\nvar scratchBVCartographic = new Cartographic();\nvar scratchBVRectangle = new Rectangle();\n\nfunction getRectangle(frameState, geometry) {\n  var ellipsoid = frameState.mapProjection.ellipsoid;\n\n  if (\n    !defined(geometry.attributes) ||\n    !defined(geometry.attributes.position3DHigh)\n  ) {\n    if (defined(geometry.rectangle)) {\n      return geometry.rectangle;\n    }\n\n    return undefined;\n  }\n\n  var highPositions = geometry.attributes.position3DHigh.values;\n  var lowPositions = geometry.attributes.position3DLow.values;\n  var length = highPositions.length;\n\n  var minLat = Number.POSITIVE_INFINITY;\n  var minLon = Number.POSITIVE_INFINITY;\n  var maxLat = Number.NEGATIVE_INFINITY;\n  var maxLon = Number.NEGATIVE_INFINITY;\n\n  for (var i = 0; i < length; i += 3) {\n    var highPosition = Cartesian3.unpack(\n      highPositions,\n      i,\n      scratchBVCartesianHigh\n    );\n    var lowPosition = Cartesian3.unpack(lowPositions, i, scratchBVCartesianLow);\n\n    var position = Cartesian3.add(\n      highPosition,\n      lowPosition,\n      scratchBVCartesian\n    );\n    var cartographic = ellipsoid.cartesianToCartographic(\n      position,\n      scratchBVCartographic\n    );\n\n    var latitude = cartographic.latitude;\n    var longitude = cartographic.longitude;\n\n    minLat = Math.min(minLat, latitude);\n    minLon = Math.min(minLon, longitude);\n    maxLat = Math.max(maxLat, latitude);\n    maxLon = Math.max(maxLon, longitude);\n  }\n\n  var rectangle = scratchBVRectangle;\n  rectangle.north = maxLat;\n  rectangle.south = minLat;\n  rectangle.east = maxLon;\n  rectangle.west = minLon;\n\n  return rectangle;\n}\n\nfunction setMinMaxTerrainHeights(primitive, rectangle, ellipsoid) {\n  var result = ApproximateTerrainHeights.getMinimumMaximumHeights(\n    rectangle,\n    ellipsoid\n  );\n\n  primitive._minTerrainHeight = result.minimumTerrainHeight;\n  primitive._maxTerrainHeight = result.maximumTerrainHeight;\n}\n\nfunction createBoundingVolume(groundPrimitive, frameState, geometry) {\n  var ellipsoid = frameState.mapProjection.ellipsoid;\n  var rectangle = getRectangle(frameState, geometry);\n\n  var obb = OrientedBoundingBox.fromRectangle(\n    rectangle,\n    groundPrimitive._minHeight,\n    groundPrimitive._maxHeight,\n    ellipsoid\n  );\n  groundPrimitive._boundingVolumes.push(obb);\n\n  if (!frameState.scene3DOnly) {\n    var projection = frameState.mapProjection;\n    var boundingVolume = BoundingSphere.fromRectangleWithHeights2D(\n      rectangle,\n      projection,\n      groundPrimitive._maxHeight,\n      groundPrimitive._minHeight\n    );\n    Cartesian3.fromElements(\n      boundingVolume.center.z,\n      boundingVolume.center.x,\n      boundingVolume.center.y,\n      boundingVolume.center\n    );\n\n    groundPrimitive._boundingVolumes2D.push(boundingVolume);\n  }\n}\n\nfunction boundingVolumeIndex(commandIndex, length) {\n  return Math.floor((commandIndex % length) / 3);\n}\n\nfunction updateAndQueueRenderCommand(\n  groundPrimitive,\n  command,\n  frameState,\n  modelMatrix,\n  cull,\n  boundingVolume,\n  debugShowBoundingVolume\n) {\n  // Use derived appearance command for 2D if needed\n  var classificationPrimitive = groundPrimitive._primitive;\n  if (\n    frameState.mode !== SceneMode.SCENE3D &&\n    command.shaderProgram === classificationPrimitive._spColor &&\n    classificationPrimitive._needs2DShader\n  ) {\n    command = command.derivedCommands.appearance2D;\n  }\n\n  command.owner = groundPrimitive;\n  command.modelMatrix = modelMatrix;\n  command.boundingVolume = boundingVolume;\n  command.cull = cull;\n  command.debugShowBoundingVolume = debugShowBoundingVolume;\n\n  frameState.commandList.push(command);\n}\n\nfunction updateAndQueuePickCommand(\n  groundPrimitive,\n  command,\n  frameState,\n  modelMatrix,\n  cull,\n  boundingVolume\n) {\n  // Use derived pick command for 2D if needed\n  var classificationPrimitive = groundPrimitive._primitive;\n  if (\n    frameState.mode !== SceneMode.SCENE3D &&\n    command.shaderProgram === classificationPrimitive._spPick &&\n    classificationPrimitive._needs2DShader\n  ) {\n    command = command.derivedCommands.pick2D;\n  }\n\n  command.owner = groundPrimitive;\n  command.modelMatrix = modelMatrix;\n  command.boundingVolume = boundingVolume;\n  command.cull = cull;\n\n  frameState.commandList.push(command);\n}\n\nfunction updateAndQueueCommands(\n  groundPrimitive,\n  frameState,\n  colorCommands,\n  pickCommands,\n  modelMatrix,\n  cull,\n  debugShowBoundingVolume,\n  twoPasses\n) {\n  var boundingVolumes;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingVolumes = groundPrimitive._boundingVolumes;\n  } else {\n    boundingVolumes = groundPrimitive._boundingVolumes2D;\n  }\n\n  var classificationType = groundPrimitive.classificationType;\n  var queueTerrainCommands =\n    classificationType !== ClassificationType.CESIUM_3D_TILE;\n  var queue3DTilesCommands = classificationType !== ClassificationType.TERRAIN;\n\n  var passes = frameState.passes;\n  var classificationPrimitive = groundPrimitive._primitive;\n\n  var i;\n  var boundingVolume;\n  var command;\n\n  if (passes.render) {\n    var colorLength = colorCommands.length;\n\n    for (i = 0; i < colorLength; ++i) {\n      boundingVolume = boundingVolumes[boundingVolumeIndex(i, colorLength)];\n      if (queueTerrainCommands) {\n        command = colorCommands[i];\n        updateAndQueueRenderCommand(\n          groundPrimitive,\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume,\n          debugShowBoundingVolume\n        );\n      }\n      if (queue3DTilesCommands) {\n        command = colorCommands[i].derivedCommands.tileset;\n        updateAndQueueRenderCommand(\n          groundPrimitive,\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume,\n          debugShowBoundingVolume\n        );\n      }\n    }\n\n    if (frameState.invertClassification) {\n      var ignoreShowCommands = classificationPrimitive._commandsIgnoreShow;\n      var ignoreShowCommandsLength = ignoreShowCommands.length;\n      for (i = 0; i < ignoreShowCommandsLength; ++i) {\n        boundingVolume = boundingVolumes[Math.floor(i / 2)];\n        command = ignoreShowCommands[i];\n        updateAndQueueRenderCommand(\n          groundPrimitive,\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume,\n          debugShowBoundingVolume\n        );\n      }\n    }\n  }\n\n  if (passes.pick) {\n    var pickLength = pickCommands.length;\n\n    var pickOffsets;\n    if (!groundPrimitive._useFragmentCulling) {\n      // Must be using pick offsets\n      pickOffsets = classificationPrimitive._primitive._pickOffsets;\n    }\n    for (i = 0; i < pickLength; ++i) {\n      boundingVolume = boundingVolumes[boundingVolumeIndex(i, pickLength)];\n      if (!groundPrimitive._useFragmentCulling) {\n        var pickOffset = pickOffsets[boundingVolumeIndex(i, pickLength)];\n        boundingVolume = boundingVolumes[pickOffset.index];\n      }\n      if (queueTerrainCommands) {\n        command = pickCommands[i];\n        updateAndQueuePickCommand(\n          groundPrimitive,\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume\n        );\n      }\n      if (queue3DTilesCommands) {\n        command = pickCommands[i].derivedCommands.tileset;\n        updateAndQueuePickCommand(\n          groundPrimitive,\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume\n        );\n      }\n    }\n  }\n}\n\n/**\n * Initializes the minimum and maximum terrain heights. This only needs to be called if you are creating the\n * GroundPrimitive synchronously.\n *\n * @returns {Promise} A promise that will resolve once the terrain heights have been loaded.\n *\n */\nGroundPrimitive.initializeTerrainHeights = function () {\n  return ApproximateTerrainHeights.initialize();\n};\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} For synchronous GroundPrimitive, you must call GroundPrimitive.initializeTerrainHeights() and wait for the returned promise to resolve.\n * @exception {DeveloperError} All instance geometries must have the same primitiveType.\n * @exception {DeveloperError} Appearance and material have a uniform with the same name.\n */\nGroundPrimitive.prototype.update = function (frameState) {\n  if (!defined(this._primitive) && !defined(this.geometryInstances)) {\n    return;\n  }\n\n  if (!ApproximateTerrainHeights.initialized) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!this.asynchronous) {\n      throw new DeveloperError(\n        \"For synchronous GroundPrimitives, you must call GroundPrimitive.initializeTerrainHeights() and wait for the returned promise to resolve.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    GroundPrimitive.initializeTerrainHeights();\n    return;\n  }\n\n  var that = this;\n  var primitiveOptions = this._classificationPrimitiveOptions;\n\n  if (!defined(this._primitive)) {\n    var ellipsoid = frameState.mapProjection.ellipsoid;\n\n    var instance;\n    var geometry;\n    var instanceType;\n\n    var instances = Array.isArray(this.geometryInstances)\n      ? this.geometryInstances\n      : [this.geometryInstances];\n    var length = instances.length;\n    var groundInstances = new Array(length);\n\n    var i;\n    var rectangle;\n    for (i = 0; i < length; ++i) {\n      instance = instances[i];\n      geometry = instance.geometry;\n      var instanceRectangle = getRectangle(frameState, geometry);\n      if (!defined(rectangle)) {\n        rectangle = Rectangle.clone(instanceRectangle);\n      } else if (defined(instanceRectangle)) {\n        Rectangle.union(rectangle, instanceRectangle, rectangle);\n      }\n\n      var id = instance.id;\n      if (defined(id) && defined(instanceRectangle)) {\n        var boundingSphere = ApproximateTerrainHeights.getBoundingSphere(\n          instanceRectangle,\n          ellipsoid\n        );\n        this._boundingSpheresKeys.push(id);\n        this._boundingSpheres.push(boundingSphere);\n      }\n\n      instanceType = geometry.constructor;\n      if (!defined(instanceType) || !defined(instanceType.createShadowVolume)) {\n        //>>includeStart('debug', pragmas.debug);\n        throw new DeveloperError(\n          \"Not all of the geometry instances have GroundPrimitive support.\"\n        );\n        //>>includeEnd('debug');\n      }\n    }\n\n    // Now compute the min/max heights for the primitive\n    setMinMaxTerrainHeights(this, rectangle, ellipsoid);\n    var exaggeration = frameState.terrainExaggeration;\n    this._minHeight = this._minTerrainHeight * exaggeration;\n    this._maxHeight = this._maxTerrainHeight * exaggeration;\n\n    var useFragmentCulling = GroundPrimitive._supportsMaterials(\n      frameState.context\n    );\n    this._useFragmentCulling = useFragmentCulling;\n\n    if (useFragmentCulling) {\n      // Determine whether to add spherical or planar extent attributes for computing texture coordinates.\n      // This depends on the size of the GeometryInstances.\n      var attributes;\n      var usePlanarExtents = true;\n      for (i = 0; i < length; ++i) {\n        instance = instances[i];\n        geometry = instance.geometry;\n        rectangle = getRectangle(frameState, geometry);\n        if (ShadowVolumeAppearance.shouldUseSphericalCoordinates(rectangle)) {\n          usePlanarExtents = false;\n          break;\n        }\n      }\n\n      for (i = 0; i < length; ++i) {\n        instance = instances[i];\n        geometry = instance.geometry;\n        instanceType = geometry.constructor;\n\n        var boundingRectangle = getRectangle(frameState, geometry);\n        var textureCoordinateRotationPoints =\n          geometry.textureCoordinateRotationPoints;\n\n        if (usePlanarExtents) {\n          attributes = ShadowVolumeAppearance.getPlanarTextureCoordinateAttributes(\n            boundingRectangle,\n            textureCoordinateRotationPoints,\n            ellipsoid,\n            frameState.mapProjection,\n            this._maxHeight\n          );\n        } else {\n          attributes = ShadowVolumeAppearance.getSphericalExtentGeometryInstanceAttributes(\n            boundingRectangle,\n            textureCoordinateRotationPoints,\n            ellipsoid,\n            frameState.mapProjection\n          );\n        }\n\n        var instanceAttributes = instance.attributes;\n        for (var attributeKey in instanceAttributes) {\n          if (instanceAttributes.hasOwnProperty(attributeKey)) {\n            attributes[attributeKey] = instanceAttributes[attributeKey];\n          }\n        }\n\n        groundInstances[i] = new GeometryInstance({\n          geometry: instanceType.createShadowVolume(\n            geometry,\n            getComputeMinimumHeightFunction(this),\n            getComputeMaximumHeightFunction(this)\n          ),\n          attributes: attributes,\n          id: instance.id,\n        });\n      }\n    } else {\n      // ClassificationPrimitive will check if the colors are all the same if it detects lack of fragment culling attributes\n      for (i = 0; i < length; ++i) {\n        instance = instances[i];\n        geometry = instance.geometry;\n        instanceType = geometry.constructor;\n        groundInstances[i] = new GeometryInstance({\n          geometry: instanceType.createShadowVolume(\n            geometry,\n            getComputeMinimumHeightFunction(this),\n            getComputeMaximumHeightFunction(this)\n          ),\n          attributes: instance.attributes,\n          id: instance.id,\n        });\n      }\n    }\n\n    primitiveOptions.geometryInstances = groundInstances;\n    primitiveOptions.appearance = this.appearance;\n\n    primitiveOptions._createBoundingVolumeFunction = function (\n      frameState,\n      geometry\n    ) {\n      createBoundingVolume(that, frameState, geometry);\n    };\n    primitiveOptions._updateAndQueueCommandsFunction = function (\n      primitive,\n      frameState,\n      colorCommands,\n      pickCommands,\n      modelMatrix,\n      cull,\n      debugShowBoundingVolume,\n      twoPasses\n    ) {\n      updateAndQueueCommands(\n        that,\n        frameState,\n        colorCommands,\n        pickCommands,\n        modelMatrix,\n        cull,\n        debugShowBoundingVolume,\n        twoPasses\n      );\n    };\n\n    this._primitive = new ClassificationPrimitive(primitiveOptions);\n    this._primitive.readyPromise.then(function (primitive) {\n      that._ready = true;\n\n      if (that.releaseGeometryInstances) {\n        that.geometryInstances = undefined;\n      }\n\n      var error = primitive._error;\n      if (!defined(error)) {\n        that._readyPromise.resolve(that);\n      } else {\n        that._readyPromise.reject(error);\n      }\n    });\n  }\n\n  this._primitive.appearance = this.appearance;\n  this._primitive.show = this.show;\n  this._primitive.debugShowShadowVolume = this.debugShowShadowVolume;\n  this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume;\n  this._primitive.update(frameState);\n};\n\n/**\n * @private\n */\nGroundPrimitive.prototype.getBoundingSphere = function (id) {\n  var index = this._boundingSpheresKeys.indexOf(id);\n  if (index !== -1) {\n    return this._boundingSpheres[index];\n  }\n\n  return undefined;\n};\n\n/**\n * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.\n *\n * @param {*} id The id of the {@link GeometryInstance}.\n * @returns {Object} The typed array in the attribute's format or undefined if the is no instance with id.\n *\n * @exception {DeveloperError} must call update before calling getGeometryInstanceAttributes.\n *\n * @example\n * var attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);\n */\nGroundPrimitive.prototype.getGeometryInstanceAttributes = function (id) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(this._primitive)) {\n    throw new DeveloperError(\n      \"must call update before calling getGeometryInstanceAttributes\"\n    );\n  }\n  //>>includeEnd('debug');\n  return this._primitive.getGeometryInstanceAttributes(id);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see GroundPrimitive#destroy\n */\nGroundPrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * e = e && e.destroy();\n *\n * @see GroundPrimitive#isDestroyed\n */\nGroundPrimitive.prototype.destroy = function () {\n  this._primitive = this._primitive && this._primitive.destroy();\n  return destroyObject(this);\n};\n\n/**\n * Exposed for testing.\n *\n * @param {Context} context Rendering context\n * @returns {Boolean} Whether or not the current context supports materials on GroundPrimitives.\n * @private\n */\nGroundPrimitive._supportsMaterials = function (context) {\n  return context.depthTexture;\n};\n\n/**\n * Checks if the given Scene supports materials on GroundPrimitives.\n * Materials on GroundPrimitives require support for the WEBGL_depth_texture extension.\n *\n * @param {Scene} scene The current scene.\n * @returns {Boolean} Whether or not the current scene supports materials on GroundPrimitives.\n */\nGroundPrimitive.supportsMaterials = function (scene) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scene\", scene);\n  //>>includeEnd('debug');\n\n  return GroundPrimitive._supportsMaterials(scene.frameState.context);\n};\nexport default GroundPrimitive;\n"]},"metadata":{},"sourceType":"module"}