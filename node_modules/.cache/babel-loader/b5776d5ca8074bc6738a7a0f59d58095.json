{"ast":null,"code":"import defined from \"../Core/defined.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport ManagedArray from \"../Core/ManagedArray.js\";\nimport Cesium3DTileOptimizationHint from \"./Cesium3DTileOptimizationHint.js\";\nimport Cesium3DTileRefine from \"./Cesium3DTileRefine.js\";\n/**\n * @private\n */\n\nfunction Cesium3DTilesetTraversal() {}\n\nfunction isVisible(tile) {\n  return tile._visible && tile._inRequestVolume;\n}\n\nvar traversal = {\n  stack: new ManagedArray(),\n  stackMaximumLength: 0\n};\nvar emptyTraversal = {\n  stack: new ManagedArray(),\n  stackMaximumLength: 0\n};\nvar descendantTraversal = {\n  stack: new ManagedArray(),\n  stackMaximumLength: 0\n};\nvar selectionTraversal = {\n  stack: new ManagedArray(),\n  stackMaximumLength: 0,\n  ancestorStack: new ManagedArray(),\n  ancestorStackMaximumLength: 0\n};\nvar descendantSelectionDepth = 2;\n\nCesium3DTilesetTraversal.selectTiles = function (tileset, frameState) {\n  tileset._requestedTiles.length = 0;\n\n  if (tileset.debugFreezeFrame) {\n    return;\n  }\n\n  tileset._selectedTiles.length = 0;\n  tileset._selectedTilesToStyle.length = 0;\n  tileset._emptyTiles.length = 0;\n  tileset._hasMixedContent = false;\n  var root = tileset.root;\n  updateTile(tileset, root, frameState); // The root tile is not visible\n\n  if (!isVisible(root)) {\n    return;\n  } // The tileset doesn't meet the SSE requirement, therefore the tree does not need to be rendered\n\n\n  if (root.getScreenSpaceError(frameState, true) <= tileset._maximumScreenSpaceError) {\n    return;\n  }\n\n  if (!skipLevelOfDetail(tileset)) {\n    executeBaseTraversal(tileset, root, frameState);\n  } else if (tileset.immediatelyLoadDesiredLevelOfDetail) {\n    executeSkipTraversal(tileset, root, frameState);\n  } else {\n    executeBaseAndSkipTraversal(tileset, root, frameState);\n  }\n\n  traversal.stack.trim(traversal.stackMaximumLength);\n  emptyTraversal.stack.trim(emptyTraversal.stackMaximumLength);\n  descendantTraversal.stack.trim(descendantTraversal.stackMaximumLength);\n  selectionTraversal.stack.trim(selectionTraversal.stackMaximumLength);\n  selectionTraversal.ancestorStack.trim(selectionTraversal.ancestorStackMaximumLength); // Update the priority for any requests found during traversal\n  // Update after traversal so that min and max values can be used to normalize priority values\n\n  var requestedTiles = tileset._requestedTiles;\n  var length = requestedTiles.length;\n\n  for (var i = 0; i < length; ++i) {\n    requestedTiles[i].updatePriority();\n  }\n};\n\nfunction executeBaseTraversal(tileset, root, frameState) {\n  var baseScreenSpaceError = tileset._maximumScreenSpaceError;\n  var maximumScreenSpaceError = tileset._maximumScreenSpaceError;\n  executeTraversal(tileset, root, baseScreenSpaceError, maximumScreenSpaceError, frameState);\n}\n\nfunction executeSkipTraversal(tileset, root, frameState) {\n  var baseScreenSpaceError = Number.MAX_VALUE;\n  var maximumScreenSpaceError = tileset._maximumScreenSpaceError;\n  executeTraversal(tileset, root, baseScreenSpaceError, maximumScreenSpaceError, frameState);\n  traverseAndSelect(tileset, root, frameState);\n}\n\nfunction executeBaseAndSkipTraversal(tileset, root, frameState) {\n  var baseScreenSpaceError = Math.max(tileset.baseScreenSpaceError, tileset.maximumScreenSpaceError);\n  var maximumScreenSpaceError = tileset.maximumScreenSpaceError;\n  executeTraversal(tileset, root, baseScreenSpaceError, maximumScreenSpaceError, frameState);\n  traverseAndSelect(tileset, root, frameState);\n}\n\nfunction skipLevelOfDetail(tileset) {\n  return tileset._skipLevelOfDetail;\n}\n\nfunction addEmptyTile(tileset, tile) {\n  tileset._emptyTiles.push(tile);\n}\n\nfunction selectTile(tileset, tile, frameState) {\n  if (tile.contentVisibility(frameState) !== Intersect.OUTSIDE) {\n    var tileContent = tile.content;\n\n    if (tileContent.featurePropertiesDirty) {\n      // A feature's property in this tile changed, the tile needs to be re-styled.\n      tileContent.featurePropertiesDirty = false;\n      tile.lastStyleTime = 0; // Force applying the style to this tile\n\n      tileset._selectedTilesToStyle.push(tile);\n    } else if (tile._selectedFrame < frameState.frameNumber - 1) {\n      // Tile is newly selected; it is selected this frame, but was not selected last frame.\n      tileset._selectedTilesToStyle.push(tile);\n    }\n\n    tile._selectedFrame = frameState.frameNumber;\n\n    tileset._selectedTiles.push(tile);\n  }\n}\n\nfunction selectDescendants(tileset, root, frameState) {\n  var stack = descendantTraversal.stack;\n  stack.push(root);\n\n  while (stack.length > 0) {\n    descendantTraversal.stackMaximumLength = Math.max(descendantTraversal.stackMaximumLength, stack.length);\n    var tile = stack.pop();\n    var children = tile.children;\n    var childrenLength = children.length;\n\n    for (var i = 0; i < childrenLength; ++i) {\n      var child = children[i];\n\n      if (isVisible(child)) {\n        if (child.contentAvailable) {\n          updateTile(tileset, child, frameState);\n          touchTile(tileset, child, frameState);\n          selectTile(tileset, child, frameState);\n        } else if (child._depth - root._depth < descendantSelectionDepth) {\n          // Continue traversing, but not too far\n          stack.push(child);\n        }\n      }\n    }\n  }\n}\n\nfunction selectDesiredTile(tileset, tile, frameState) {\n  if (!skipLevelOfDetail(tileset)) {\n    if (tile.contentAvailable) {\n      // The tile can be selected right away and does not require traverseAndSelect\n      selectTile(tileset, tile, frameState);\n    }\n\n    return;\n  } // If this tile is not loaded attempt to select its ancestor instead\n\n\n  var loadedTile = tile.contentAvailable ? tile : tile._ancestorWithContentAvailable;\n\n  if (defined(loadedTile)) {\n    // Tiles will actually be selected in traverseAndSelect\n    loadedTile._shouldSelect = true;\n  } else {\n    // If no ancestors are ready traverse down and select tiles to minimize empty regions.\n    // This happens often for immediatelyLoadDesiredLevelOfDetail where parent tiles are not necessarily loaded before zooming out.\n    selectDescendants(tileset, tile, frameState);\n  }\n}\n\nfunction visitTile(tileset, tile, frameState) {\n  ++tileset._statistics.visited;\n  tile._visitedFrame = frameState.frameNumber;\n}\n\nfunction touchTile(tileset, tile, frameState) {\n  if (tile._touchedFrame === frameState.frameNumber) {\n    // Prevents another pass from touching the frame again\n    return;\n  }\n\n  tileset._cache.touch(tile);\n\n  tile._touchedFrame = frameState.frameNumber;\n}\n\nfunction updateMinimumMaximumPriority(tileset, tile) {\n  tileset._maximumPriority.distance = Math.max(tile._priorityHolder._distanceToCamera, tileset._maximumPriority.distance);\n  tileset._minimumPriority.distance = Math.min(tile._priorityHolder._distanceToCamera, tileset._minimumPriority.distance);\n  tileset._maximumPriority.depth = Math.max(tile._depth, tileset._maximumPriority.depth);\n  tileset._minimumPriority.depth = Math.min(tile._depth, tileset._minimumPriority.depth);\n  tileset._maximumPriority.foveatedFactor = Math.max(tile._priorityHolder._foveatedFactor, tileset._maximumPriority.foveatedFactor);\n  tileset._minimumPriority.foveatedFactor = Math.min(tile._priorityHolder._foveatedFactor, tileset._minimumPriority.foveatedFactor);\n  tileset._maximumPriority.reverseScreenSpaceError = Math.max(tile._priorityReverseScreenSpaceError, tileset._maximumPriority.reverseScreenSpaceError);\n  tileset._minimumPriority.reverseScreenSpaceError = Math.min(tile._priorityReverseScreenSpaceError, tileset._minimumPriority.reverseScreenSpaceError);\n}\n\nfunction isOnScreenLongEnough(tileset, tile, frameState) {\n  // Prevent unnecessary loads while camera is moving by getting the ratio of travel distance to tile size.\n  if (!tileset._cullRequestsWhileMoving) {\n    return true;\n  }\n\n  var sphere = tile.boundingSphere;\n  var diameter = Math.max(sphere.radius * 2.0, 1.0);\n  var camera = frameState.camera;\n  var deltaMagnitude = camera.positionWCDeltaMagnitude !== 0.0 ? camera.positionWCDeltaMagnitude : camera.positionWCDeltaMagnitudeLastFrame;\n  var movementRatio = tileset.cullRequestsWhileMovingMultiplier * deltaMagnitude / diameter; // How do n frames of this movement compare to the tile's physical size.\n\n  return movementRatio < 1.0;\n}\n\nfunction loadTile(tileset, tile, frameState) {\n  if (tile._requestedFrame === frameState.frameNumber || !hasUnloadedContent(tile) && !tile.contentExpired) {\n    return;\n  }\n\n  if (!isOnScreenLongEnough(tileset, tile, frameState)) {\n    return;\n  }\n\n  var cameraHasNotStoppedMovingLongEnough = frameState.camera.timeSinceMoved < tileset.foveatedTimeDelay;\n\n  if (tile.priorityDeferred && cameraHasNotStoppedMovingLongEnough) {\n    return;\n  }\n\n  tile._requestedFrame = frameState.frameNumber;\n\n  tileset._requestedTiles.push(tile);\n}\n\nfunction updateVisibility(tileset, tile, frameState) {\n  if (tile._updatedVisibilityFrame === tileset._updatedVisibilityFrame) {\n    // Return early if visibility has already been checked during the traversal.\n    // The visibility may have already been checked if the cullWithChildrenBounds optimization is used.\n    return;\n  }\n\n  tile.updateVisibility(frameState);\n  tile._updatedVisibilityFrame = tileset._updatedVisibilityFrame;\n}\n\nfunction anyChildrenVisible(tileset, tile, frameState) {\n  var anyVisible = false;\n  var children = tile.children;\n  var length = children.length;\n\n  for (var i = 0; i < length; ++i) {\n    var child = children[i];\n    updateVisibility(tileset, child, frameState);\n    anyVisible = anyVisible || isVisible(child);\n  }\n\n  return anyVisible;\n}\n\nfunction meetsScreenSpaceErrorEarly(tileset, tile, frameState) {\n  var parent = tile.parent;\n\n  if (!defined(parent) || parent.hasTilesetContent || parent.refine !== Cesium3DTileRefine.ADD) {\n    return false;\n  } // Use parent's geometric error with child's box to see if the tile already meet the SSE\n\n\n  return tile.getScreenSpaceError(frameState, true) <= tileset._maximumScreenSpaceError;\n}\n\nfunction updateTileVisibility(tileset, tile, frameState) {\n  updateVisibility(tileset, tile, frameState);\n\n  if (!isVisible(tile)) {\n    return;\n  }\n\n  var hasChildren = tile.children.length > 0;\n\n  if (tile.hasTilesetContent && hasChildren) {\n    // Use the root tile's visibility instead of this tile's visibility.\n    // The root tile may be culled by the children bounds optimization in which\n    // case this tile should also be culled.\n    var child = tile.children[0];\n    updateTileVisibility(tileset, child, frameState);\n    tile._visible = child._visible;\n    return;\n  }\n\n  if (meetsScreenSpaceErrorEarly(tileset, tile, frameState)) {\n    tile._visible = false;\n    return;\n  } // Optimization - if none of the tile's children are visible then this tile isn't visible\n\n\n  var replace = tile.refine === Cesium3DTileRefine.REPLACE;\n  var useOptimization = tile._optimChildrenWithinParent === Cesium3DTileOptimizationHint.USE_OPTIMIZATION;\n\n  if (replace && useOptimization && hasChildren) {\n    if (!anyChildrenVisible(tileset, tile, frameState)) {\n      ++tileset._statistics.numberOfTilesCulledWithChildrenUnion;\n      tile._visible = false;\n      return;\n    }\n  }\n}\n\nfunction updateTile(tileset, tile, frameState) {\n  // Reset some of the tile's flags and re-evaluate visibility\n  updateTileVisibility(tileset, tile, frameState);\n  tile.updateExpiration(); // Request priority\n\n  tile._wasMinPriorityChild = false;\n  tile._priorityHolder = tile;\n  updateMinimumMaximumPriority(tileset, tile); // SkipLOD\n\n  tile._shouldSelect = false;\n  tile._finalResolution = true;\n}\n\nfunction updateTileAncestorContentLinks(tile, frameState) {\n  tile._ancestorWithContent = undefined;\n  tile._ancestorWithContentAvailable = undefined;\n  var parent = tile.parent;\n\n  if (defined(parent)) {\n    // ancestorWithContent is an ancestor that has content or has the potential to have\n    // content. Used in conjunction with tileset.skipLevels to know when to skip a tile.\n    // ancestorWithContentAvailable is an ancestor that is rendered if a desired tile is not loaded.\n    var hasContent = !hasUnloadedContent(parent) || parent._requestedFrame === frameState.frameNumber;\n    tile._ancestorWithContent = hasContent ? parent : parent._ancestorWithContent;\n    tile._ancestorWithContentAvailable = parent.contentAvailable ? parent : parent._ancestorWithContentAvailable; // Links a descendant up to its contentAvailable ancestor as the traversal progresses.\n  }\n}\n\nfunction hasEmptyContent(tile) {\n  return tile.hasEmptyContent || tile.hasTilesetContent;\n}\n\nfunction hasUnloadedContent(tile) {\n  return !hasEmptyContent(tile) && tile.contentUnloaded;\n}\n\nfunction reachedSkippingThreshold(tileset, tile) {\n  var ancestor = tile._ancestorWithContent;\n  return !tileset.immediatelyLoadDesiredLevelOfDetail && (tile._priorityProgressiveResolutionScreenSpaceErrorLeaf || defined(ancestor) && tile._screenSpaceError < ancestor._screenSpaceError / tileset.skipScreenSpaceErrorFactor && tile._depth > ancestor._depth + tileset.skipLevels);\n}\n\nfunction sortChildrenByDistanceToCamera(a, b) {\n  // Sort by farthest child first since this is going on a stack\n  if (b._distanceToCamera === 0 && a._distanceToCamera === 0) {\n    return b._centerZDepth - a._centerZDepth;\n  }\n\n  return b._distanceToCamera - a._distanceToCamera;\n}\n\nfunction updateAndPushChildren(tileset, tile, stack, frameState) {\n  var i;\n  var replace = tile.refine === Cesium3DTileRefine.REPLACE;\n  var children = tile.children;\n  var length = children.length;\n\n  for (i = 0; i < length; ++i) {\n    updateTile(tileset, children[i], frameState);\n  } // Sort by distance to take advantage of early Z and reduce artifacts for skipLevelOfDetail\n\n\n  children.sort(sortChildrenByDistanceToCamera); // For traditional replacement refinement only refine if all children are loaded.\n  // Empty tiles are exempt since it looks better if children stream in as they are loaded to fill the empty space.\n\n  var checkRefines = !skipLevelOfDetail(tileset) && replace && !hasEmptyContent(tile);\n  var refines = true;\n  var anyChildrenVisible = false; // Determining min child\n\n  var minIndex = -1;\n  var minimumPriority = Number.MAX_VALUE;\n  var child;\n\n  for (i = 0; i < length; ++i) {\n    child = children[i];\n\n    if (isVisible(child)) {\n      stack.push(child);\n\n      if (child._foveatedFactor < minimumPriority) {\n        minIndex = i;\n        minimumPriority = child._foveatedFactor;\n      }\n\n      anyChildrenVisible = true;\n    } else if (checkRefines || tileset.loadSiblings) {\n      // Keep non-visible children loaded since they are still needed before the parent can refine.\n      // Or loadSiblings is true so always load tiles regardless of visibility.\n      if (child._foveatedFactor < minimumPriority) {\n        minIndex = i;\n        minimumPriority = child._foveatedFactor;\n      }\n\n      loadTile(tileset, child, frameState);\n      touchTile(tileset, child, frameState);\n    }\n\n    if (checkRefines) {\n      var childRefines;\n\n      if (!child._inRequestVolume) {\n        childRefines = false;\n      } else if (hasEmptyContent(child)) {\n        childRefines = executeEmptyTraversal(tileset, child, frameState);\n      } else {\n        childRefines = child.contentAvailable;\n      }\n\n      refines = refines && childRefines;\n    }\n  }\n\n  if (!anyChildrenVisible) {\n    refines = false;\n  }\n\n  if (minIndex !== -1 && !skipLevelOfDetail(tileset) && replace) {\n    // An ancestor will hold the _foveatedFactor and _distanceToCamera for descendants between itself and its highest priority descendant. Siblings of a min children along the way use this ancestor as their priority holder as well.\n    // Priority of all tiles that refer to the _foveatedFactor and _distanceToCamera stored in the common ancestor will be differentiated based on their _depth.\n    var minPriorityChild = children[minIndex];\n    minPriorityChild._wasMinPriorityChild = true;\n    var priorityHolder = (tile._wasMinPriorityChild || tile === tileset.root) && minimumPriority <= tile._priorityHolder._foveatedFactor ? tile._priorityHolder : tile; // This is where priority dependency chains are wired up or started anew.\n\n    priorityHolder._foveatedFactor = Math.min(minPriorityChild._foveatedFactor, priorityHolder._foveatedFactor);\n    priorityHolder._distanceToCamera = Math.min(minPriorityChild._distanceToCamera, priorityHolder._distanceToCamera);\n\n    for (i = 0; i < length; ++i) {\n      child = children[i];\n      child._priorityHolder = priorityHolder;\n    }\n  }\n\n  return refines;\n}\n\nfunction inBaseTraversal(tileset, tile, baseScreenSpaceError) {\n  if (!skipLevelOfDetail(tileset)) {\n    return true;\n  }\n\n  if (tileset.immediatelyLoadDesiredLevelOfDetail) {\n    return false;\n  }\n\n  if (!defined(tile._ancestorWithContent)) {\n    // Include root or near-root tiles in the base traversal so there is something to select up to\n    return true;\n  }\n\n  if (tile._screenSpaceError === 0.0) {\n    // If a leaf, use parent's SSE\n    return tile.parent._screenSpaceError > baseScreenSpaceError;\n  }\n\n  return tile._screenSpaceError > baseScreenSpaceError;\n}\n\nfunction canTraverse(tileset, tile) {\n  if (tile.children.length === 0) {\n    return false;\n  }\n\n  if (tile.hasTilesetContent) {\n    // Traverse external tileset to visit its root tile\n    // Don't traverse if the subtree is expired because it will be destroyed\n    return !tile.contentExpired;\n  }\n\n  return tile._screenSpaceError > tileset._maximumScreenSpaceError;\n}\n\nfunction executeTraversal(tileset, root, baseScreenSpaceError, maximumScreenSpaceError, frameState) {\n  // Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n  // If skipLevelOfDetail is off then a tile does not refine until all children are loaded.\n  // This is the traditional replacement refinement approach and is called the base traversal.\n  // Tiles that have a greater screen space error than the base screen space error are part of the base traversal,\n  // all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree\n  // and rendering children and parent tiles simultaneously.\n  var stack = traversal.stack;\n  stack.push(root);\n\n  while (stack.length > 0) {\n    traversal.stackMaximumLength = Math.max(traversal.stackMaximumLength, stack.length);\n    var tile = stack.pop();\n    updateTileAncestorContentLinks(tile, frameState);\n    var baseTraversal = inBaseTraversal(tileset, tile, baseScreenSpaceError);\n    var add = tile.refine === Cesium3DTileRefine.ADD;\n    var replace = tile.refine === Cesium3DTileRefine.REPLACE;\n    var parent = tile.parent;\n    var parentRefines = !defined(parent) || parent._refines;\n    var refines = false;\n\n    if (canTraverse(tileset, tile)) {\n      refines = updateAndPushChildren(tileset, tile, stack, frameState) && parentRefines;\n    }\n\n    var stoppedRefining = !refines && parentRefines;\n\n    if (hasEmptyContent(tile)) {\n      // Add empty tile just to show its debug bounding volume\n      // If the tile has tileset content load the external tileset\n      // If the tile cannot refine further select its nearest loaded ancestor\n      addEmptyTile(tileset, tile, frameState);\n      loadTile(tileset, tile, frameState);\n\n      if (stoppedRefining) {\n        selectDesiredTile(tileset, tile, frameState);\n      }\n    } else if (add) {\n      // Additive tiles are always loaded and selected\n      selectDesiredTile(tileset, tile, frameState);\n      loadTile(tileset, tile, frameState);\n    } else if (replace) {\n      if (baseTraversal) {\n        // Always load tiles in the base traversal\n        // Select tiles that can't refine further\n        loadTile(tileset, tile, frameState);\n\n        if (stoppedRefining) {\n          selectDesiredTile(tileset, tile, frameState);\n        }\n      } else if (stoppedRefining) {\n        // In skip traversal, load and select tiles that can't refine further\n        selectDesiredTile(tileset, tile, frameState);\n        loadTile(tileset, tile, frameState);\n      } else if (reachedSkippingThreshold(tileset, tile)) {\n        // In skip traversal, load tiles that aren't skipped. In practice roughly half the tiles stay unloaded.\n        loadTile(tileset, tile, frameState);\n      }\n    }\n\n    visitTile(tileset, tile, frameState);\n    touchTile(tileset, tile, frameState);\n    tile._refines = refines;\n  }\n}\n\nfunction executeEmptyTraversal(tileset, root, frameState) {\n  // Depth-first traversal that checks if all nearest descendants with content are loaded. Ignores visibility.\n  var allDescendantsLoaded = true;\n  var stack = emptyTraversal.stack;\n  stack.push(root);\n\n  while (stack.length > 0) {\n    emptyTraversal.stackMaximumLength = Math.max(emptyTraversal.stackMaximumLength, stack.length);\n    var tile = stack.pop();\n    var children = tile.children;\n    var childrenLength = children.length; // Only traverse if the tile is empty - traversal stop at descendants with content\n\n    var traverse = hasEmptyContent(tile) && canTraverse(tileset, tile); // Traversal stops but the tile does not have content yet.\n    // There will be holes if the parent tries to refine to its children, so don't refine.\n\n    if (!traverse && !tile.contentAvailable) {\n      allDescendantsLoaded = false;\n    }\n\n    updateTile(tileset, tile, frameState);\n\n    if (!isVisible(tile)) {\n      // Load tiles that aren't visible since they are still needed for the parent to refine\n      loadTile(tileset, tile, frameState);\n      touchTile(tileset, tile, frameState);\n    }\n\n    if (traverse) {\n      for (var i = 0; i < childrenLength; ++i) {\n        var child = children[i];\n        stack.push(child);\n      }\n    }\n  }\n\n  return allDescendantsLoaded;\n}\n/**\n * Traverse the tree and check if their selected frame is the current frame. If so, add it to a selection queue.\n * This is a preorder traversal so children tiles are selected before ancestor tiles.\n *\n * The reason for the preorder traversal is so that tiles can easily be marked with their\n * selection depth. A tile's _selectionDepth is its depth in the tree where all non-selected tiles are removed.\n * This property is important for use in the stencil test because we want to render deeper tiles on top of their\n * ancestors. If a tileset is very deep, the depth is unlikely to fit into the stencil buffer.\n *\n * We want to select children before their ancestors because there is no guarantee on the relationship between\n * the children's z-depth and the ancestor's z-depth. We cannot rely on Z because we want the child to appear on top\n * of ancestor regardless of true depth. The stencil tests used require children to be drawn first.\n *\n * NOTE: 3D Tiles uses 3 bits from the stencil buffer meaning this will not work when there is a chain of\n * selected tiles that is deeper than 7. This is not very likely.\n * @private\n */\n\n\nfunction traverseAndSelect(tileset, root, frameState) {\n  var stack = selectionTraversal.stack;\n  var ancestorStack = selectionTraversal.ancestorStack;\n  var lastAncestor;\n  stack.push(root);\n\n  while (stack.length > 0 || ancestorStack.length > 0) {\n    selectionTraversal.stackMaximumLength = Math.max(selectionTraversal.stackMaximumLength, stack.length);\n    selectionTraversal.ancestorStackMaximumLength = Math.max(selectionTraversal.ancestorStackMaximumLength, ancestorStack.length);\n\n    if (ancestorStack.length > 0) {\n      var waitingTile = ancestorStack.peek();\n\n      if (waitingTile._stackLength === stack.length) {\n        ancestorStack.pop();\n\n        if (waitingTile !== lastAncestor) {\n          waitingTile._finalResolution = false;\n        }\n\n        selectTile(tileset, waitingTile, frameState);\n        continue;\n      }\n    }\n\n    var tile = stack.pop();\n\n    if (!defined(tile)) {\n      // stack is empty but ancestorStack isn't\n      continue;\n    }\n\n    var add = tile.refine === Cesium3DTileRefine.ADD;\n    var shouldSelect = tile._shouldSelect;\n    var children = tile.children;\n    var childrenLength = children.length;\n    var traverse = canTraverse(tileset, tile);\n\n    if (shouldSelect) {\n      if (add) {\n        selectTile(tileset, tile, frameState);\n      } else {\n        tile._selectionDepth = ancestorStack.length;\n\n        if (tile._selectionDepth > 0) {\n          tileset._hasMixedContent = true;\n        }\n\n        lastAncestor = tile;\n\n        if (!traverse) {\n          selectTile(tileset, tile, frameState);\n          continue;\n        }\n\n        ancestorStack.push(tile);\n        tile._stackLength = stack.length;\n      }\n    }\n\n    if (traverse) {\n      for (var i = 0; i < childrenLength; ++i) {\n        var child = children[i];\n\n        if (isVisible(child)) {\n          stack.push(child);\n        }\n      }\n    }\n  }\n}\n\nexport default Cesium3DTilesetTraversal;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/Cesium3DTilesetTraversal.js"],"names":["defined","Intersect","ManagedArray","Cesium3DTileOptimizationHint","Cesium3DTileRefine","Cesium3DTilesetTraversal","isVisible","tile","_visible","_inRequestVolume","traversal","stack","stackMaximumLength","emptyTraversal","descendantTraversal","selectionTraversal","ancestorStack","ancestorStackMaximumLength","descendantSelectionDepth","selectTiles","tileset","frameState","_requestedTiles","length","debugFreezeFrame","_selectedTiles","_selectedTilesToStyle","_emptyTiles","_hasMixedContent","root","updateTile","getScreenSpaceError","_maximumScreenSpaceError","skipLevelOfDetail","executeBaseTraversal","immediatelyLoadDesiredLevelOfDetail","executeSkipTraversal","executeBaseAndSkipTraversal","trim","requestedTiles","i","updatePriority","baseScreenSpaceError","maximumScreenSpaceError","executeTraversal","Number","MAX_VALUE","traverseAndSelect","Math","max","_skipLevelOfDetail","addEmptyTile","push","selectTile","contentVisibility","OUTSIDE","tileContent","content","featurePropertiesDirty","lastStyleTime","_selectedFrame","frameNumber","selectDescendants","pop","children","childrenLength","child","contentAvailable","touchTile","_depth","selectDesiredTile","loadedTile","_ancestorWithContentAvailable","_shouldSelect","visitTile","_statistics","visited","_visitedFrame","_touchedFrame","_cache","touch","updateMinimumMaximumPriority","_maximumPriority","distance","_priorityHolder","_distanceToCamera","_minimumPriority","min","depth","foveatedFactor","_foveatedFactor","reverseScreenSpaceError","_priorityReverseScreenSpaceError","isOnScreenLongEnough","_cullRequestsWhileMoving","sphere","boundingSphere","diameter","radius","camera","deltaMagnitude","positionWCDeltaMagnitude","positionWCDeltaMagnitudeLastFrame","movementRatio","cullRequestsWhileMovingMultiplier","loadTile","_requestedFrame","hasUnloadedContent","contentExpired","cameraHasNotStoppedMovingLongEnough","timeSinceMoved","foveatedTimeDelay","priorityDeferred","updateVisibility","_updatedVisibilityFrame","anyChildrenVisible","anyVisible","meetsScreenSpaceErrorEarly","parent","hasTilesetContent","refine","ADD","updateTileVisibility","hasChildren","replace","REPLACE","useOptimization","_optimChildrenWithinParent","USE_OPTIMIZATION","numberOfTilesCulledWithChildrenUnion","updateExpiration","_wasMinPriorityChild","_finalResolution","updateTileAncestorContentLinks","_ancestorWithContent","undefined","hasContent","hasEmptyContent","contentUnloaded","reachedSkippingThreshold","ancestor","_priorityProgressiveResolutionScreenSpaceErrorLeaf","_screenSpaceError","skipScreenSpaceErrorFactor","skipLevels","sortChildrenByDistanceToCamera","a","b","_centerZDepth","updateAndPushChildren","sort","checkRefines","refines","minIndex","minimumPriority","loadSiblings","childRefines","executeEmptyTraversal","minPriorityChild","priorityHolder","inBaseTraversal","canTraverse","baseTraversal","add","parentRefines","_refines","stoppedRefining","allDescendantsLoaded","traverse","lastAncestor","waitingTile","peek","_stackLength","shouldSelect","_selectionDepth"],"mappings":"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","sourcesContent":["import defined from \"../Core/defined.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport ManagedArray from \"../Core/ManagedArray.js\";\nimport Cesium3DTileOptimizationHint from \"./Cesium3DTileOptimizationHint.js\";\nimport Cesium3DTileRefine from \"./Cesium3DTileRefine.js\";\n\n/**\n * @private\n */\nfunction Cesium3DTilesetTraversal() {}\n\nfunction isVisible(tile) {\n  return tile._visible && tile._inRequestVolume;\n}\n\nvar traversal = {\n  stack: new ManagedArray(),\n  stackMaximumLength: 0,\n};\n\nvar emptyTraversal = {\n  stack: new ManagedArray(),\n  stackMaximumLength: 0,\n};\n\nvar descendantTraversal = {\n  stack: new ManagedArray(),\n  stackMaximumLength: 0,\n};\n\nvar selectionTraversal = {\n  stack: new ManagedArray(),\n  stackMaximumLength: 0,\n  ancestorStack: new ManagedArray(),\n  ancestorStackMaximumLength: 0,\n};\n\nvar descendantSelectionDepth = 2;\n\nCesium3DTilesetTraversal.selectTiles = function (tileset, frameState) {\n  tileset._requestedTiles.length = 0;\n\n  if (tileset.debugFreezeFrame) {\n    return;\n  }\n\n  tileset._selectedTiles.length = 0;\n  tileset._selectedTilesToStyle.length = 0;\n  tileset._emptyTiles.length = 0;\n  tileset._hasMixedContent = false;\n\n  var root = tileset.root;\n  updateTile(tileset, root, frameState);\n\n  // The root tile is not visible\n  if (!isVisible(root)) {\n    return;\n  }\n\n  // The tileset doesn't meet the SSE requirement, therefore the tree does not need to be rendered\n  if (\n    root.getScreenSpaceError(frameState, true) <=\n    tileset._maximumScreenSpaceError\n  ) {\n    return;\n  }\n\n  if (!skipLevelOfDetail(tileset)) {\n    executeBaseTraversal(tileset, root, frameState);\n  } else if (tileset.immediatelyLoadDesiredLevelOfDetail) {\n    executeSkipTraversal(tileset, root, frameState);\n  } else {\n    executeBaseAndSkipTraversal(tileset, root, frameState);\n  }\n\n  traversal.stack.trim(traversal.stackMaximumLength);\n  emptyTraversal.stack.trim(emptyTraversal.stackMaximumLength);\n  descendantTraversal.stack.trim(descendantTraversal.stackMaximumLength);\n  selectionTraversal.stack.trim(selectionTraversal.stackMaximumLength);\n  selectionTraversal.ancestorStack.trim(\n    selectionTraversal.ancestorStackMaximumLength\n  );\n\n  // Update the priority for any requests found during traversal\n  // Update after traversal so that min and max values can be used to normalize priority values\n  var requestedTiles = tileset._requestedTiles;\n  var length = requestedTiles.length;\n  for (var i = 0; i < length; ++i) {\n    requestedTiles[i].updatePriority();\n  }\n};\n\nfunction executeBaseTraversal(tileset, root, frameState) {\n  var baseScreenSpaceError = tileset._maximumScreenSpaceError;\n  var maximumScreenSpaceError = tileset._maximumScreenSpaceError;\n  executeTraversal(\n    tileset,\n    root,\n    baseScreenSpaceError,\n    maximumScreenSpaceError,\n    frameState\n  );\n}\n\nfunction executeSkipTraversal(tileset, root, frameState) {\n  var baseScreenSpaceError = Number.MAX_VALUE;\n  var maximumScreenSpaceError = tileset._maximumScreenSpaceError;\n  executeTraversal(\n    tileset,\n    root,\n    baseScreenSpaceError,\n    maximumScreenSpaceError,\n    frameState\n  );\n  traverseAndSelect(tileset, root, frameState);\n}\n\nfunction executeBaseAndSkipTraversal(tileset, root, frameState) {\n  var baseScreenSpaceError = Math.max(\n    tileset.baseScreenSpaceError,\n    tileset.maximumScreenSpaceError\n  );\n  var maximumScreenSpaceError = tileset.maximumScreenSpaceError;\n  executeTraversal(\n    tileset,\n    root,\n    baseScreenSpaceError,\n    maximumScreenSpaceError,\n    frameState\n  );\n  traverseAndSelect(tileset, root, frameState);\n}\n\nfunction skipLevelOfDetail(tileset) {\n  return tileset._skipLevelOfDetail;\n}\n\nfunction addEmptyTile(tileset, tile) {\n  tileset._emptyTiles.push(tile);\n}\n\nfunction selectTile(tileset, tile, frameState) {\n  if (tile.contentVisibility(frameState) !== Intersect.OUTSIDE) {\n    var tileContent = tile.content;\n    if (tileContent.featurePropertiesDirty) {\n      // A feature's property in this tile changed, the tile needs to be re-styled.\n      tileContent.featurePropertiesDirty = false;\n      tile.lastStyleTime = 0; // Force applying the style to this tile\n      tileset._selectedTilesToStyle.push(tile);\n    } else if (tile._selectedFrame < frameState.frameNumber - 1) {\n      // Tile is newly selected; it is selected this frame, but was not selected last frame.\n      tileset._selectedTilesToStyle.push(tile);\n    }\n    tile._selectedFrame = frameState.frameNumber;\n    tileset._selectedTiles.push(tile);\n  }\n}\n\nfunction selectDescendants(tileset, root, frameState) {\n  var stack = descendantTraversal.stack;\n  stack.push(root);\n  while (stack.length > 0) {\n    descendantTraversal.stackMaximumLength = Math.max(\n      descendantTraversal.stackMaximumLength,\n      stack.length\n    );\n    var tile = stack.pop();\n    var children = tile.children;\n    var childrenLength = children.length;\n    for (var i = 0; i < childrenLength; ++i) {\n      var child = children[i];\n      if (isVisible(child)) {\n        if (child.contentAvailable) {\n          updateTile(tileset, child, frameState);\n          touchTile(tileset, child, frameState);\n          selectTile(tileset, child, frameState);\n        } else if (child._depth - root._depth < descendantSelectionDepth) {\n          // Continue traversing, but not too far\n          stack.push(child);\n        }\n      }\n    }\n  }\n}\n\nfunction selectDesiredTile(tileset, tile, frameState) {\n  if (!skipLevelOfDetail(tileset)) {\n    if (tile.contentAvailable) {\n      // The tile can be selected right away and does not require traverseAndSelect\n      selectTile(tileset, tile, frameState);\n    }\n    return;\n  }\n\n  // If this tile is not loaded attempt to select its ancestor instead\n  var loadedTile = tile.contentAvailable\n    ? tile\n    : tile._ancestorWithContentAvailable;\n  if (defined(loadedTile)) {\n    // Tiles will actually be selected in traverseAndSelect\n    loadedTile._shouldSelect = true;\n  } else {\n    // If no ancestors are ready traverse down and select tiles to minimize empty regions.\n    // This happens often for immediatelyLoadDesiredLevelOfDetail where parent tiles are not necessarily loaded before zooming out.\n    selectDescendants(tileset, tile, frameState);\n  }\n}\n\nfunction visitTile(tileset, tile, frameState) {\n  ++tileset._statistics.visited;\n  tile._visitedFrame = frameState.frameNumber;\n}\n\nfunction touchTile(tileset, tile, frameState) {\n  if (tile._touchedFrame === frameState.frameNumber) {\n    // Prevents another pass from touching the frame again\n    return;\n  }\n  tileset._cache.touch(tile);\n  tile._touchedFrame = frameState.frameNumber;\n}\n\nfunction updateMinimumMaximumPriority(tileset, tile) {\n  tileset._maximumPriority.distance = Math.max(\n    tile._priorityHolder._distanceToCamera,\n    tileset._maximumPriority.distance\n  );\n  tileset._minimumPriority.distance = Math.min(\n    tile._priorityHolder._distanceToCamera,\n    tileset._minimumPriority.distance\n  );\n  tileset._maximumPriority.depth = Math.max(\n    tile._depth,\n    tileset._maximumPriority.depth\n  );\n  tileset._minimumPriority.depth = Math.min(\n    tile._depth,\n    tileset._minimumPriority.depth\n  );\n  tileset._maximumPriority.foveatedFactor = Math.max(\n    tile._priorityHolder._foveatedFactor,\n    tileset._maximumPriority.foveatedFactor\n  );\n  tileset._minimumPriority.foveatedFactor = Math.min(\n    tile._priorityHolder._foveatedFactor,\n    tileset._minimumPriority.foveatedFactor\n  );\n  tileset._maximumPriority.reverseScreenSpaceError = Math.max(\n    tile._priorityReverseScreenSpaceError,\n    tileset._maximumPriority.reverseScreenSpaceError\n  );\n  tileset._minimumPriority.reverseScreenSpaceError = Math.min(\n    tile._priorityReverseScreenSpaceError,\n    tileset._minimumPriority.reverseScreenSpaceError\n  );\n}\n\nfunction isOnScreenLongEnough(tileset, tile, frameState) {\n  // Prevent unnecessary loads while camera is moving by getting the ratio of travel distance to tile size.\n  if (!tileset._cullRequestsWhileMoving) {\n    return true;\n  }\n\n  var sphere = tile.boundingSphere;\n  var diameter = Math.max(sphere.radius * 2.0, 1.0);\n\n  var camera = frameState.camera;\n  var deltaMagnitude =\n    camera.positionWCDeltaMagnitude !== 0.0\n      ? camera.positionWCDeltaMagnitude\n      : camera.positionWCDeltaMagnitudeLastFrame;\n  var movementRatio =\n    (tileset.cullRequestsWhileMovingMultiplier * deltaMagnitude) / diameter; // How do n frames of this movement compare to the tile's physical size.\n  return movementRatio < 1.0;\n}\n\nfunction loadTile(tileset, tile, frameState) {\n  if (\n    tile._requestedFrame === frameState.frameNumber ||\n    (!hasUnloadedContent(tile) && !tile.contentExpired)\n  ) {\n    return;\n  }\n\n  if (!isOnScreenLongEnough(tileset, tile, frameState)) {\n    return;\n  }\n\n  var cameraHasNotStoppedMovingLongEnough =\n    frameState.camera.timeSinceMoved < tileset.foveatedTimeDelay;\n  if (tile.priorityDeferred && cameraHasNotStoppedMovingLongEnough) {\n    return;\n  }\n\n  tile._requestedFrame = frameState.frameNumber;\n  tileset._requestedTiles.push(tile);\n}\n\nfunction updateVisibility(tileset, tile, frameState) {\n  if (tile._updatedVisibilityFrame === tileset._updatedVisibilityFrame) {\n    // Return early if visibility has already been checked during the traversal.\n    // The visibility may have already been checked if the cullWithChildrenBounds optimization is used.\n    return;\n  }\n\n  tile.updateVisibility(frameState);\n  tile._updatedVisibilityFrame = tileset._updatedVisibilityFrame;\n}\n\nfunction anyChildrenVisible(tileset, tile, frameState) {\n  var anyVisible = false;\n  var children = tile.children;\n  var length = children.length;\n  for (var i = 0; i < length; ++i) {\n    var child = children[i];\n    updateVisibility(tileset, child, frameState);\n    anyVisible = anyVisible || isVisible(child);\n  }\n  return anyVisible;\n}\n\nfunction meetsScreenSpaceErrorEarly(tileset, tile, frameState) {\n  var parent = tile.parent;\n  if (\n    !defined(parent) ||\n    parent.hasTilesetContent ||\n    parent.refine !== Cesium3DTileRefine.ADD\n  ) {\n    return false;\n  }\n\n  // Use parent's geometric error with child's box to see if the tile already meet the SSE\n  return (\n    tile.getScreenSpaceError(frameState, true) <=\n    tileset._maximumScreenSpaceError\n  );\n}\n\nfunction updateTileVisibility(tileset, tile, frameState) {\n  updateVisibility(tileset, tile, frameState);\n\n  if (!isVisible(tile)) {\n    return;\n  }\n\n  var hasChildren = tile.children.length > 0;\n  if (tile.hasTilesetContent && hasChildren) {\n    // Use the root tile's visibility instead of this tile's visibility.\n    // The root tile may be culled by the children bounds optimization in which\n    // case this tile should also be culled.\n    var child = tile.children[0];\n    updateTileVisibility(tileset, child, frameState);\n    tile._visible = child._visible;\n    return;\n  }\n\n  if (meetsScreenSpaceErrorEarly(tileset, tile, frameState)) {\n    tile._visible = false;\n    return;\n  }\n\n  // Optimization - if none of the tile's children are visible then this tile isn't visible\n  var replace = tile.refine === Cesium3DTileRefine.REPLACE;\n  var useOptimization =\n    tile._optimChildrenWithinParent ===\n    Cesium3DTileOptimizationHint.USE_OPTIMIZATION;\n  if (replace && useOptimization && hasChildren) {\n    if (!anyChildrenVisible(tileset, tile, frameState)) {\n      ++tileset._statistics.numberOfTilesCulledWithChildrenUnion;\n      tile._visible = false;\n      return;\n    }\n  }\n}\n\nfunction updateTile(tileset, tile, frameState) {\n  // Reset some of the tile's flags and re-evaluate visibility\n  updateTileVisibility(tileset, tile, frameState);\n  tile.updateExpiration();\n\n  // Request priority\n  tile._wasMinPriorityChild = false;\n  tile._priorityHolder = tile;\n  updateMinimumMaximumPriority(tileset, tile);\n\n  // SkipLOD\n  tile._shouldSelect = false;\n  tile._finalResolution = true;\n}\n\nfunction updateTileAncestorContentLinks(tile, frameState) {\n  tile._ancestorWithContent = undefined;\n  tile._ancestorWithContentAvailable = undefined;\n\n  var parent = tile.parent;\n  if (defined(parent)) {\n    // ancestorWithContent is an ancestor that has content or has the potential to have\n    // content. Used in conjunction with tileset.skipLevels to know when to skip a tile.\n    // ancestorWithContentAvailable is an ancestor that is rendered if a desired tile is not loaded.\n    var hasContent =\n      !hasUnloadedContent(parent) ||\n      parent._requestedFrame === frameState.frameNumber;\n    tile._ancestorWithContent = hasContent\n      ? parent\n      : parent._ancestorWithContent;\n    tile._ancestorWithContentAvailable = parent.contentAvailable\n      ? parent\n      : parent._ancestorWithContentAvailable; // Links a descendant up to its contentAvailable ancestor as the traversal progresses.\n  }\n}\n\nfunction hasEmptyContent(tile) {\n  return tile.hasEmptyContent || tile.hasTilesetContent;\n}\n\nfunction hasUnloadedContent(tile) {\n  return !hasEmptyContent(tile) && tile.contentUnloaded;\n}\n\nfunction reachedSkippingThreshold(tileset, tile) {\n  var ancestor = tile._ancestorWithContent;\n  return (\n    !tileset.immediatelyLoadDesiredLevelOfDetail &&\n    (tile._priorityProgressiveResolutionScreenSpaceErrorLeaf ||\n      (defined(ancestor) &&\n        tile._screenSpaceError <\n          ancestor._screenSpaceError / tileset.skipScreenSpaceErrorFactor &&\n        tile._depth > ancestor._depth + tileset.skipLevels))\n  );\n}\n\nfunction sortChildrenByDistanceToCamera(a, b) {\n  // Sort by farthest child first since this is going on a stack\n  if (b._distanceToCamera === 0 && a._distanceToCamera === 0) {\n    return b._centerZDepth - a._centerZDepth;\n  }\n\n  return b._distanceToCamera - a._distanceToCamera;\n}\n\nfunction updateAndPushChildren(tileset, tile, stack, frameState) {\n  var i;\n  var replace = tile.refine === Cesium3DTileRefine.REPLACE;\n  var children = tile.children;\n  var length = children.length;\n\n  for (i = 0; i < length; ++i) {\n    updateTile(tileset, children[i], frameState);\n  }\n\n  // Sort by distance to take advantage of early Z and reduce artifacts for skipLevelOfDetail\n  children.sort(sortChildrenByDistanceToCamera);\n\n  // For traditional replacement refinement only refine if all children are loaded.\n  // Empty tiles are exempt since it looks better if children stream in as they are loaded to fill the empty space.\n  var checkRefines =\n    !skipLevelOfDetail(tileset) && replace && !hasEmptyContent(tile);\n  var refines = true;\n\n  var anyChildrenVisible = false;\n\n  // Determining min child\n  var minIndex = -1;\n  var minimumPriority = Number.MAX_VALUE;\n\n  var child;\n  for (i = 0; i < length; ++i) {\n    child = children[i];\n    if (isVisible(child)) {\n      stack.push(child);\n      if (child._foveatedFactor < minimumPriority) {\n        minIndex = i;\n        minimumPriority = child._foveatedFactor;\n      }\n      anyChildrenVisible = true;\n    } else if (checkRefines || tileset.loadSiblings) {\n      // Keep non-visible children loaded since they are still needed before the parent can refine.\n      // Or loadSiblings is true so always load tiles regardless of visibility.\n      if (child._foveatedFactor < minimumPriority) {\n        minIndex = i;\n        minimumPriority = child._foveatedFactor;\n      }\n      loadTile(tileset, child, frameState);\n      touchTile(tileset, child, frameState);\n    }\n    if (checkRefines) {\n      var childRefines;\n      if (!child._inRequestVolume) {\n        childRefines = false;\n      } else if (hasEmptyContent(child)) {\n        childRefines = executeEmptyTraversal(tileset, child, frameState);\n      } else {\n        childRefines = child.contentAvailable;\n      }\n      refines = refines && childRefines;\n    }\n  }\n\n  if (!anyChildrenVisible) {\n    refines = false;\n  }\n\n  if (minIndex !== -1 && !skipLevelOfDetail(tileset) && replace) {\n    // An ancestor will hold the _foveatedFactor and _distanceToCamera for descendants between itself and its highest priority descendant. Siblings of a min children along the way use this ancestor as their priority holder as well.\n    // Priority of all tiles that refer to the _foveatedFactor and _distanceToCamera stored in the common ancestor will be differentiated based on their _depth.\n    var minPriorityChild = children[minIndex];\n    minPriorityChild._wasMinPriorityChild = true;\n    var priorityHolder =\n      (tile._wasMinPriorityChild || tile === tileset.root) &&\n      minimumPriority <= tile._priorityHolder._foveatedFactor\n        ? tile._priorityHolder\n        : tile; // This is where priority dependency chains are wired up or started anew.\n    priorityHolder._foveatedFactor = Math.min(\n      minPriorityChild._foveatedFactor,\n      priorityHolder._foveatedFactor\n    );\n    priorityHolder._distanceToCamera = Math.min(\n      minPriorityChild._distanceToCamera,\n      priorityHolder._distanceToCamera\n    );\n\n    for (i = 0; i < length; ++i) {\n      child = children[i];\n      child._priorityHolder = priorityHolder;\n    }\n  }\n\n  return refines;\n}\n\nfunction inBaseTraversal(tileset, tile, baseScreenSpaceError) {\n  if (!skipLevelOfDetail(tileset)) {\n    return true;\n  }\n  if (tileset.immediatelyLoadDesiredLevelOfDetail) {\n    return false;\n  }\n  if (!defined(tile._ancestorWithContent)) {\n    // Include root or near-root tiles in the base traversal so there is something to select up to\n    return true;\n  }\n  if (tile._screenSpaceError === 0.0) {\n    // If a leaf, use parent's SSE\n    return tile.parent._screenSpaceError > baseScreenSpaceError;\n  }\n  return tile._screenSpaceError > baseScreenSpaceError;\n}\n\nfunction canTraverse(tileset, tile) {\n  if (tile.children.length === 0) {\n    return false;\n  }\n  if (tile.hasTilesetContent) {\n    // Traverse external tileset to visit its root tile\n    // Don't traverse if the subtree is expired because it will be destroyed\n    return !tile.contentExpired;\n  }\n  return tile._screenSpaceError > tileset._maximumScreenSpaceError;\n}\n\nfunction executeTraversal(\n  tileset,\n  root,\n  baseScreenSpaceError,\n  maximumScreenSpaceError,\n  frameState\n) {\n  // Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n  // If skipLevelOfDetail is off then a tile does not refine until all children are loaded.\n  // This is the traditional replacement refinement approach and is called the base traversal.\n  // Tiles that have a greater screen space error than the base screen space error are part of the base traversal,\n  // all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree\n  // and rendering children and parent tiles simultaneously.\n  var stack = traversal.stack;\n  stack.push(root);\n\n  while (stack.length > 0) {\n    traversal.stackMaximumLength = Math.max(\n      traversal.stackMaximumLength,\n      stack.length\n    );\n\n    var tile = stack.pop();\n\n    updateTileAncestorContentLinks(tile, frameState);\n    var baseTraversal = inBaseTraversal(tileset, tile, baseScreenSpaceError);\n    var add = tile.refine === Cesium3DTileRefine.ADD;\n    var replace = tile.refine === Cesium3DTileRefine.REPLACE;\n    var parent = tile.parent;\n    var parentRefines = !defined(parent) || parent._refines;\n    var refines = false;\n\n    if (canTraverse(tileset, tile)) {\n      refines =\n        updateAndPushChildren(tileset, tile, stack, frameState) &&\n        parentRefines;\n    }\n\n    var stoppedRefining = !refines && parentRefines;\n\n    if (hasEmptyContent(tile)) {\n      // Add empty tile just to show its debug bounding volume\n      // If the tile has tileset content load the external tileset\n      // If the tile cannot refine further select its nearest loaded ancestor\n      addEmptyTile(tileset, tile, frameState);\n      loadTile(tileset, tile, frameState);\n      if (stoppedRefining) {\n        selectDesiredTile(tileset, tile, frameState);\n      }\n    } else if (add) {\n      // Additive tiles are always loaded and selected\n      selectDesiredTile(tileset, tile, frameState);\n      loadTile(tileset, tile, frameState);\n    } else if (replace) {\n      if (baseTraversal) {\n        // Always load tiles in the base traversal\n        // Select tiles that can't refine further\n        loadTile(tileset, tile, frameState);\n        if (stoppedRefining) {\n          selectDesiredTile(tileset, tile, frameState);\n        }\n      } else if (stoppedRefining) {\n        // In skip traversal, load and select tiles that can't refine further\n        selectDesiredTile(tileset, tile, frameState);\n        loadTile(tileset, tile, frameState);\n      } else if (reachedSkippingThreshold(tileset, tile)) {\n        // In skip traversal, load tiles that aren't skipped. In practice roughly half the tiles stay unloaded.\n        loadTile(tileset, tile, frameState);\n      }\n    }\n\n    visitTile(tileset, tile, frameState);\n    touchTile(tileset, tile, frameState);\n    tile._refines = refines;\n  }\n}\n\nfunction executeEmptyTraversal(tileset, root, frameState) {\n  // Depth-first traversal that checks if all nearest descendants with content are loaded. Ignores visibility.\n  var allDescendantsLoaded = true;\n  var stack = emptyTraversal.stack;\n  stack.push(root);\n\n  while (stack.length > 0) {\n    emptyTraversal.stackMaximumLength = Math.max(\n      emptyTraversal.stackMaximumLength,\n      stack.length\n    );\n\n    var tile = stack.pop();\n    var children = tile.children;\n    var childrenLength = children.length;\n\n    // Only traverse if the tile is empty - traversal stop at descendants with content\n    var traverse = hasEmptyContent(tile) && canTraverse(tileset, tile);\n\n    // Traversal stops but the tile does not have content yet.\n    // There will be holes if the parent tries to refine to its children, so don't refine.\n    if (!traverse && !tile.contentAvailable) {\n      allDescendantsLoaded = false;\n    }\n\n    updateTile(tileset, tile, frameState);\n    if (!isVisible(tile)) {\n      // Load tiles that aren't visible since they are still needed for the parent to refine\n      loadTile(tileset, tile, frameState);\n      touchTile(tileset, tile, frameState);\n    }\n\n    if (traverse) {\n      for (var i = 0; i < childrenLength; ++i) {\n        var child = children[i];\n        stack.push(child);\n      }\n    }\n  }\n\n  return allDescendantsLoaded;\n}\n\n/**\n * Traverse the tree and check if their selected frame is the current frame. If so, add it to a selection queue.\n * This is a preorder traversal so children tiles are selected before ancestor tiles.\n *\n * The reason for the preorder traversal is so that tiles can easily be marked with their\n * selection depth. A tile's _selectionDepth is its depth in the tree where all non-selected tiles are removed.\n * This property is important for use in the stencil test because we want to render deeper tiles on top of their\n * ancestors. If a tileset is very deep, the depth is unlikely to fit into the stencil buffer.\n *\n * We want to select children before their ancestors because there is no guarantee on the relationship between\n * the children's z-depth and the ancestor's z-depth. We cannot rely on Z because we want the child to appear on top\n * of ancestor regardless of true depth. The stencil tests used require children to be drawn first.\n *\n * NOTE: 3D Tiles uses 3 bits from the stencil buffer meaning this will not work when there is a chain of\n * selected tiles that is deeper than 7. This is not very likely.\n * @private\n */\nfunction traverseAndSelect(tileset, root, frameState) {\n  var stack = selectionTraversal.stack;\n  var ancestorStack = selectionTraversal.ancestorStack;\n  var lastAncestor;\n\n  stack.push(root);\n\n  while (stack.length > 0 || ancestorStack.length > 0) {\n    selectionTraversal.stackMaximumLength = Math.max(\n      selectionTraversal.stackMaximumLength,\n      stack.length\n    );\n    selectionTraversal.ancestorStackMaximumLength = Math.max(\n      selectionTraversal.ancestorStackMaximumLength,\n      ancestorStack.length\n    );\n\n    if (ancestorStack.length > 0) {\n      var waitingTile = ancestorStack.peek();\n      if (waitingTile._stackLength === stack.length) {\n        ancestorStack.pop();\n        if (waitingTile !== lastAncestor) {\n          waitingTile._finalResolution = false;\n        }\n        selectTile(tileset, waitingTile, frameState);\n        continue;\n      }\n    }\n\n    var tile = stack.pop();\n    if (!defined(tile)) {\n      // stack is empty but ancestorStack isn't\n      continue;\n    }\n\n    var add = tile.refine === Cesium3DTileRefine.ADD;\n    var shouldSelect = tile._shouldSelect;\n    var children = tile.children;\n    var childrenLength = children.length;\n    var traverse = canTraverse(tileset, tile);\n\n    if (shouldSelect) {\n      if (add) {\n        selectTile(tileset, tile, frameState);\n      } else {\n        tile._selectionDepth = ancestorStack.length;\n        if (tile._selectionDepth > 0) {\n          tileset._hasMixedContent = true;\n        }\n        lastAncestor = tile;\n        if (!traverse) {\n          selectTile(tileset, tile, frameState);\n          continue;\n        }\n        ancestorStack.push(tile);\n        tile._stackLength = stack.length;\n      }\n    }\n\n    if (traverse) {\n      for (var i = 0; i < childrenLength; ++i) {\n        var child = children[i];\n        if (isVisible(child)) {\n          stack.push(child);\n        }\n      }\n    }\n  }\n}\nexport default Cesium3DTilesetTraversal;\n"]},"metadata":{},"sourceType":"module"}