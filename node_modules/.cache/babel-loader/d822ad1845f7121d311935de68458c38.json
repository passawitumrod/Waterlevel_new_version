{"ast":null,"code":"import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport EllipseGeometry from \"../Core/EllipseGeometry.js\";\nimport EllipseOutlineGeometry from \"../Core/EllipseOutlineGeometry.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport DynamicGeometryUpdater from \"./DynamicGeometryUpdater.js\";\nimport GeometryUpdater from \"./GeometryUpdater.js\";\nimport GroundGeometryUpdater from \"./GroundGeometryUpdater.js\";\nimport Property from \"./Property.js\";\nvar scratchColor = new Color();\nvar defaultOffset = Cartesian3.ZERO;\nvar offsetScratch = new Cartesian3();\nvar scratchRectangle = new Rectangle();\n\nfunction EllipseGeometryOptions(entity) {\n  this.id = entity;\n  this.vertexFormat = undefined;\n  this.center = undefined;\n  this.semiMajorAxis = undefined;\n  this.semiMinorAxis = undefined;\n  this.rotation = undefined;\n  this.height = undefined;\n  this.extrudedHeight = undefined;\n  this.granularity = undefined;\n  this.stRotation = undefined;\n  this.numberOfVerticalLines = undefined;\n  this.offsetAttribute = undefined;\n}\n/**\n * A {@link GeometryUpdater} for ellipses.\n * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n * @alias EllipseGeometryUpdater\n * @constructor\n *\n * @param {Entity} entity The entity containing the geometry to be visualized.\n * @param {Scene} scene The scene where visualization is taking place.\n */\n\n\nfunction EllipseGeometryUpdater(entity, scene) {\n  GroundGeometryUpdater.call(this, {\n    entity: entity,\n    scene: scene,\n    geometryOptions: new EllipseGeometryOptions(entity),\n    geometryPropertyName: \"ellipse\",\n    observedPropertyNames: [\"availability\", \"position\", \"ellipse\"]\n  });\n\n  this._onEntityPropertyChanged(entity, \"ellipse\", entity.ellipse, undefined);\n}\n\nif (defined(Object.create)) {\n  EllipseGeometryUpdater.prototype = Object.create(GroundGeometryUpdater.prototype);\n  EllipseGeometryUpdater.prototype.constructor = EllipseGeometryUpdater;\n}\n/**\n * Creates the geometry instance which represents the fill of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent a filled geometry.\n */\n\n\nEllipseGeometryUpdater.prototype.createFillGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n\n  if (!this._fillEnabled) {\n    throw new DeveloperError(\"This instance does not represent a filled geometry.\");\n  } //>>includeEnd('debug');\n\n\n  var entity = this._entity;\n  var isAvailable = entity.isAvailable(time);\n  var attributes = {\n    show: new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time)),\n    distanceDisplayCondition: DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),\n    offset: undefined,\n    color: undefined\n  };\n\n  if (this._materialProperty instanceof ColorMaterialProperty) {\n    var currentColor;\n\n    if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n      currentColor = this._materialProperty.color.getValue(time, scratchColor);\n    }\n\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n\n    attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n  }\n\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new EllipseGeometry(this._options),\n    attributes: attributes\n  });\n};\n/**\n * Creates the geometry instance which represents the outline of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent an outlined geometry.\n */\n\n\nEllipseGeometryUpdater.prototype.createOutlineGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n\n  if (!this._outlineEnabled) {\n    throw new DeveloperError(\"This instance does not represent an outlined geometry.\");\n  } //>>includeEnd('debug');\n\n\n  var entity = this._entity;\n  var isAvailable = entity.isAvailable(time);\n  var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n\n  var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n  var attributes = {\n    show: new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n    color: ColorGeometryInstanceAttribute.fromColor(outlineColor),\n    distanceDisplayCondition: DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n    offset: undefined\n  };\n\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new EllipseOutlineGeometry(this._options),\n    attributes: attributes\n  });\n};\n\nEllipseGeometryUpdater.prototype._computeCenter = function (time, result) {\n  return Property.getValueOrUndefined(this._entity.position, time, result);\n};\n\nEllipseGeometryUpdater.prototype._isHidden = function (entity, ellipse) {\n  var position = entity.position;\n  return !defined(position) || !defined(ellipse.semiMajorAxis) || !defined(ellipse.semiMinorAxis) || GeometryUpdater.prototype._isHidden.call(this, entity, ellipse);\n};\n\nEllipseGeometryUpdater.prototype._isDynamic = function (entity, ellipse) {\n  return !entity.position.isConstant || //\n  !ellipse.semiMajorAxis.isConstant || //\n  !ellipse.semiMinorAxis.isConstant || //\n  !Property.isConstant(ellipse.rotation) || //\n  !Property.isConstant(ellipse.height) || //\n  !Property.isConstant(ellipse.extrudedHeight) || //\n  !Property.isConstant(ellipse.granularity) || //\n  !Property.isConstant(ellipse.stRotation) || //\n  !Property.isConstant(ellipse.outlineWidth) || //\n  !Property.isConstant(ellipse.numberOfVerticalLines) || //\n  !Property.isConstant(ellipse.zIndex) || //\n  this._onTerrain && !Property.isConstant(this._materialProperty) && !(this._materialProperty instanceof ColorMaterialProperty);\n};\n\nEllipseGeometryUpdater.prototype._setStaticOptions = function (entity, ellipse) {\n  var heightValue = Property.getValueOrUndefined(ellipse.height, Iso8601.MINIMUM_VALUE);\n  var heightReferenceValue = Property.getValueOrDefault(ellipse.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n  var extrudedHeightValue = Property.getValueOrUndefined(ellipse.extrudedHeight, Iso8601.MINIMUM_VALUE);\n  var extrudedHeightReferenceValue = Property.getValueOrDefault(ellipse.extrudedHeightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n\n  if (defined(extrudedHeightValue) && !defined(heightValue)) {\n    heightValue = 0;\n  }\n\n  var options = this._options;\n  options.vertexFormat = this._materialProperty instanceof ColorMaterialProperty ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n  options.center = entity.position.getValue(Iso8601.MINIMUM_VALUE, options.center);\n  options.semiMajorAxis = ellipse.semiMajorAxis.getValue(Iso8601.MINIMUM_VALUE, options.semiMajorAxis);\n  options.semiMinorAxis = ellipse.semiMinorAxis.getValue(Iso8601.MINIMUM_VALUE, options.semiMinorAxis);\n  options.rotation = Property.getValueOrUndefined(ellipse.rotation, Iso8601.MINIMUM_VALUE);\n  options.granularity = Property.getValueOrUndefined(ellipse.granularity, Iso8601.MINIMUM_VALUE);\n  options.stRotation = Property.getValueOrUndefined(ellipse.stRotation, Iso8601.MINIMUM_VALUE);\n  options.numberOfVerticalLines = Property.getValueOrUndefined(ellipse.numberOfVerticalLines, Iso8601.MINIMUM_VALUE);\n  options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n  options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n  extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n\n  if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n    extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(EllipseGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n  }\n\n  options.extrudedHeight = extrudedHeightValue;\n};\n\nEllipseGeometryUpdater.DynamicGeometryUpdater = DynamicEllipseGeometryUpdater;\n/**\n * @private\n */\n\nfunction DynamicEllipseGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n  DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n}\n\nif (defined(Object.create)) {\n  DynamicEllipseGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n  DynamicEllipseGeometryUpdater.prototype.constructor = DynamicEllipseGeometryUpdater;\n}\n\nDynamicEllipseGeometryUpdater.prototype._isHidden = function (entity, ellipse, time) {\n  var options = this._options;\n  return !defined(options.center) || !defined(options.semiMajorAxis) || !defined(options.semiMinorAxis) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, ellipse, time);\n};\n\nDynamicEllipseGeometryUpdater.prototype._setOptions = function (entity, ellipse, time) {\n  var options = this._options;\n  var heightValue = Property.getValueOrUndefined(ellipse.height, time);\n  var heightReferenceValue = Property.getValueOrDefault(ellipse.heightReference, time, HeightReference.NONE);\n  var extrudedHeightValue = Property.getValueOrUndefined(ellipse.extrudedHeight, time);\n  var extrudedHeightReferenceValue = Property.getValueOrDefault(ellipse.extrudedHeightReference, time, HeightReference.NONE);\n\n  if (defined(extrudedHeightValue) && !defined(heightValue)) {\n    heightValue = 0;\n  }\n\n  options.center = Property.getValueOrUndefined(entity.position, time, options.center);\n  options.semiMajorAxis = Property.getValueOrUndefined(ellipse.semiMajorAxis, time);\n  options.semiMinorAxis = Property.getValueOrUndefined(ellipse.semiMinorAxis, time);\n  options.rotation = Property.getValueOrUndefined(ellipse.rotation, time);\n  options.granularity = Property.getValueOrUndefined(ellipse.granularity, time);\n  options.stRotation = Property.getValueOrUndefined(ellipse.stRotation, time);\n  options.numberOfVerticalLines = Property.getValueOrUndefined(ellipse.numberOfVerticalLines, time);\n  options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n  options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n  extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n\n  if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n    extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(EllipseGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n  }\n\n  options.extrudedHeight = extrudedHeightValue;\n};\n\nexport default EllipseGeometryUpdater;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/DataSources/EllipseGeometryUpdater.js"],"names":["ApproximateTerrainHeights","Cartesian3","Check","Color","ColorGeometryInstanceAttribute","defined","DeveloperError","DistanceDisplayConditionGeometryInstanceAttribute","EllipseGeometry","EllipseOutlineGeometry","GeometryInstance","Iso8601","OffsetGeometryInstanceAttribute","Rectangle","ShowGeometryInstanceAttribute","HeightReference","MaterialAppearance","PerInstanceColorAppearance","ColorMaterialProperty","DynamicGeometryUpdater","GeometryUpdater","GroundGeometryUpdater","Property","scratchColor","defaultOffset","ZERO","offsetScratch","scratchRectangle","EllipseGeometryOptions","entity","id","vertexFormat","undefined","center","semiMajorAxis","semiMinorAxis","rotation","height","extrudedHeight","granularity","stRotation","numberOfVerticalLines","offsetAttribute","EllipseGeometryUpdater","scene","call","geometryOptions","geometryPropertyName","observedPropertyNames","_onEntityPropertyChanged","ellipse","Object","create","prototype","constructor","createFillGeometryInstance","time","_fillEnabled","_entity","isAvailable","attributes","show","isShowing","_showProperty","getValue","_fillProperty","distanceDisplayCondition","fromDistanceDisplayCondition","_distanceDisplayConditionProperty","offset","color","_materialProperty","currentColor","isConstant","WHITE","fromColor","_options","fromCartesian3","getValueOrDefault","_terrainOffsetProperty","geometry","createOutlineGeometryInstance","_outlineEnabled","outlineColor","_outlineColorProperty","BLACK","_showOutlineProperty","_computeCenter","result","getValueOrUndefined","position","_isHidden","_isDynamic","outlineWidth","zIndex","_onTerrain","_setStaticOptions","heightValue","MINIMUM_VALUE","heightReferenceValue","heightReference","NONE","extrudedHeightValue","extrudedHeightReferenceValue","extrudedHeightReference","options","VERTEX_FORMAT","MaterialSupport","TEXTURED","computeGeometryOffsetAttribute","getGeometryHeight","getGeometryExtrudedHeight","CLAMP_TO_GROUND","getMinimumMaximumHeights","computeRectangle","minimumTerrainHeight","DynamicEllipseGeometryUpdater","geometryUpdater","primitives","groundPrimitives","_setOptions"],"mappings":"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","sourcesContent":["import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport EllipseGeometry from \"../Core/EllipseGeometry.js\";\nimport EllipseOutlineGeometry from \"../Core/EllipseOutlineGeometry.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport DynamicGeometryUpdater from \"./DynamicGeometryUpdater.js\";\nimport GeometryUpdater from \"./GeometryUpdater.js\";\nimport GroundGeometryUpdater from \"./GroundGeometryUpdater.js\";\nimport Property from \"./Property.js\";\n\nvar scratchColor = new Color();\nvar defaultOffset = Cartesian3.ZERO;\nvar offsetScratch = new Cartesian3();\nvar scratchRectangle = new Rectangle();\n\nfunction EllipseGeometryOptions(entity) {\n  this.id = entity;\n  this.vertexFormat = undefined;\n  this.center = undefined;\n  this.semiMajorAxis = undefined;\n  this.semiMinorAxis = undefined;\n  this.rotation = undefined;\n  this.height = undefined;\n  this.extrudedHeight = undefined;\n  this.granularity = undefined;\n  this.stRotation = undefined;\n  this.numberOfVerticalLines = undefined;\n  this.offsetAttribute = undefined;\n}\n\n/**\n * A {@link GeometryUpdater} for ellipses.\n * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n * @alias EllipseGeometryUpdater\n * @constructor\n *\n * @param {Entity} entity The entity containing the geometry to be visualized.\n * @param {Scene} scene The scene where visualization is taking place.\n */\nfunction EllipseGeometryUpdater(entity, scene) {\n  GroundGeometryUpdater.call(this, {\n    entity: entity,\n    scene: scene,\n    geometryOptions: new EllipseGeometryOptions(entity),\n    geometryPropertyName: \"ellipse\",\n    observedPropertyNames: [\"availability\", \"position\", \"ellipse\"],\n  });\n\n  this._onEntityPropertyChanged(entity, \"ellipse\", entity.ellipse, undefined);\n}\n\nif (defined(Object.create)) {\n  EllipseGeometryUpdater.prototype = Object.create(\n    GroundGeometryUpdater.prototype\n  );\n  EllipseGeometryUpdater.prototype.constructor = EllipseGeometryUpdater;\n}\n\n/**\n * Creates the geometry instance which represents the fill of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent a filled geometry.\n */\nEllipseGeometryUpdater.prototype.createFillGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n\n  if (!this._fillEnabled) {\n    throw new DeveloperError(\n      \"This instance does not represent a filled geometry.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var entity = this._entity;\n  var isAvailable = entity.isAvailable(time);\n\n  var attributes = {\n    show: new ShowGeometryInstanceAttribute(\n      isAvailable &&\n        entity.isShowing &&\n        this._showProperty.getValue(time) &&\n        this._fillProperty.getValue(time)\n    ),\n    distanceDisplayCondition: DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(\n      this._distanceDisplayConditionProperty.getValue(time)\n    ),\n    offset: undefined,\n    color: undefined,\n  };\n\n  if (this._materialProperty instanceof ColorMaterialProperty) {\n    var currentColor;\n    if (\n      defined(this._materialProperty.color) &&\n      (this._materialProperty.color.isConstant || isAvailable)\n    ) {\n      currentColor = this._materialProperty.color.getValue(time, scratchColor);\n    }\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n    attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n  }\n\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(\n      Property.getValueOrDefault(\n        this._terrainOffsetProperty,\n        time,\n        defaultOffset,\n        offsetScratch\n      )\n    );\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new EllipseGeometry(this._options),\n    attributes: attributes,\n  });\n};\n\n/**\n * Creates the geometry instance which represents the outline of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent an outlined geometry.\n */\nEllipseGeometryUpdater.prototype.createOutlineGeometryInstance = function (\n  time\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n\n  if (!this._outlineEnabled) {\n    throw new DeveloperError(\n      \"This instance does not represent an outlined geometry.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var entity = this._entity;\n  var isAvailable = entity.isAvailable(time);\n  var outlineColor = Property.getValueOrDefault(\n    this._outlineColorProperty,\n    time,\n    Color.BLACK,\n    scratchColor\n  );\n  var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(\n    time\n  );\n\n  var attributes = {\n    show: new ShowGeometryInstanceAttribute(\n      isAvailable &&\n        entity.isShowing &&\n        this._showProperty.getValue(time) &&\n        this._showOutlineProperty.getValue(time)\n    ),\n    color: ColorGeometryInstanceAttribute.fromColor(outlineColor),\n    distanceDisplayCondition: DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(\n      distanceDisplayCondition\n    ),\n    offset: undefined,\n  };\n\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(\n      Property.getValueOrDefault(\n        this._terrainOffsetProperty,\n        time,\n        defaultOffset,\n        offsetScratch\n      )\n    );\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new EllipseOutlineGeometry(this._options),\n    attributes: attributes,\n  });\n};\n\nEllipseGeometryUpdater.prototype._computeCenter = function (time, result) {\n  return Property.getValueOrUndefined(this._entity.position, time, result);\n};\n\nEllipseGeometryUpdater.prototype._isHidden = function (entity, ellipse) {\n  var position = entity.position;\n\n  return (\n    !defined(position) ||\n    !defined(ellipse.semiMajorAxis) ||\n    !defined(ellipse.semiMinorAxis) ||\n    GeometryUpdater.prototype._isHidden.call(this, entity, ellipse)\n  );\n};\n\nEllipseGeometryUpdater.prototype._isDynamic = function (entity, ellipse) {\n  return (\n    !entity.position.isConstant || //\n    !ellipse.semiMajorAxis.isConstant || //\n    !ellipse.semiMinorAxis.isConstant || //\n    !Property.isConstant(ellipse.rotation) || //\n    !Property.isConstant(ellipse.height) || //\n    !Property.isConstant(ellipse.extrudedHeight) || //\n    !Property.isConstant(ellipse.granularity) || //\n    !Property.isConstant(ellipse.stRotation) || //\n    !Property.isConstant(ellipse.outlineWidth) || //\n    !Property.isConstant(ellipse.numberOfVerticalLines) || //\n    !Property.isConstant(ellipse.zIndex) || //\n    (this._onTerrain &&\n      !Property.isConstant(this._materialProperty) &&\n      !(this._materialProperty instanceof ColorMaterialProperty))\n  );\n};\n\nEllipseGeometryUpdater.prototype._setStaticOptions = function (\n  entity,\n  ellipse\n) {\n  var heightValue = Property.getValueOrUndefined(\n    ellipse.height,\n    Iso8601.MINIMUM_VALUE\n  );\n  var heightReferenceValue = Property.getValueOrDefault(\n    ellipse.heightReference,\n    Iso8601.MINIMUM_VALUE,\n    HeightReference.NONE\n  );\n  var extrudedHeightValue = Property.getValueOrUndefined(\n    ellipse.extrudedHeight,\n    Iso8601.MINIMUM_VALUE\n  );\n  var extrudedHeightReferenceValue = Property.getValueOrDefault(\n    ellipse.extrudedHeightReference,\n    Iso8601.MINIMUM_VALUE,\n    HeightReference.NONE\n  );\n  if (defined(extrudedHeightValue) && !defined(heightValue)) {\n    heightValue = 0;\n  }\n\n  var options = this._options;\n  options.vertexFormat =\n    this._materialProperty instanceof ColorMaterialProperty\n      ? PerInstanceColorAppearance.VERTEX_FORMAT\n      : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n  options.center = entity.position.getValue(\n    Iso8601.MINIMUM_VALUE,\n    options.center\n  );\n  options.semiMajorAxis = ellipse.semiMajorAxis.getValue(\n    Iso8601.MINIMUM_VALUE,\n    options.semiMajorAxis\n  );\n  options.semiMinorAxis = ellipse.semiMinorAxis.getValue(\n    Iso8601.MINIMUM_VALUE,\n    options.semiMinorAxis\n  );\n  options.rotation = Property.getValueOrUndefined(\n    ellipse.rotation,\n    Iso8601.MINIMUM_VALUE\n  );\n  options.granularity = Property.getValueOrUndefined(\n    ellipse.granularity,\n    Iso8601.MINIMUM_VALUE\n  );\n  options.stRotation = Property.getValueOrUndefined(\n    ellipse.stRotation,\n    Iso8601.MINIMUM_VALUE\n  );\n  options.numberOfVerticalLines = Property.getValueOrUndefined(\n    ellipse.numberOfVerticalLines,\n    Iso8601.MINIMUM_VALUE\n  );\n  options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(\n    heightValue,\n    heightReferenceValue,\n    extrudedHeightValue,\n    extrudedHeightReferenceValue\n  );\n  options.height = GroundGeometryUpdater.getGeometryHeight(\n    heightValue,\n    heightReferenceValue\n  );\n\n  extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(\n    extrudedHeightValue,\n    extrudedHeightReferenceValue\n  );\n  if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n    extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(\n      EllipseGeometry.computeRectangle(options, scratchRectangle)\n    ).minimumTerrainHeight;\n  }\n\n  options.extrudedHeight = extrudedHeightValue;\n};\n\nEllipseGeometryUpdater.DynamicGeometryUpdater = DynamicEllipseGeometryUpdater;\n\n/**\n * @private\n */\nfunction DynamicEllipseGeometryUpdater(\n  geometryUpdater,\n  primitives,\n  groundPrimitives\n) {\n  DynamicGeometryUpdater.call(\n    this,\n    geometryUpdater,\n    primitives,\n    groundPrimitives\n  );\n}\n\nif (defined(Object.create)) {\n  DynamicEllipseGeometryUpdater.prototype = Object.create(\n    DynamicGeometryUpdater.prototype\n  );\n  DynamicEllipseGeometryUpdater.prototype.constructor = DynamicEllipseGeometryUpdater;\n}\n\nDynamicEllipseGeometryUpdater.prototype._isHidden = function (\n  entity,\n  ellipse,\n  time\n) {\n  var options = this._options;\n  return (\n    !defined(options.center) ||\n    !defined(options.semiMajorAxis) ||\n    !defined(options.semiMinorAxis) ||\n    DynamicGeometryUpdater.prototype._isHidden.call(this, entity, ellipse, time)\n  );\n};\n\nDynamicEllipseGeometryUpdater.prototype._setOptions = function (\n  entity,\n  ellipse,\n  time\n) {\n  var options = this._options;\n  var heightValue = Property.getValueOrUndefined(ellipse.height, time);\n  var heightReferenceValue = Property.getValueOrDefault(\n    ellipse.heightReference,\n    time,\n    HeightReference.NONE\n  );\n  var extrudedHeightValue = Property.getValueOrUndefined(\n    ellipse.extrudedHeight,\n    time\n  );\n  var extrudedHeightReferenceValue = Property.getValueOrDefault(\n    ellipse.extrudedHeightReference,\n    time,\n    HeightReference.NONE\n  );\n  if (defined(extrudedHeightValue) && !defined(heightValue)) {\n    heightValue = 0;\n  }\n\n  options.center = Property.getValueOrUndefined(\n    entity.position,\n    time,\n    options.center\n  );\n  options.semiMajorAxis = Property.getValueOrUndefined(\n    ellipse.semiMajorAxis,\n    time\n  );\n  options.semiMinorAxis = Property.getValueOrUndefined(\n    ellipse.semiMinorAxis,\n    time\n  );\n  options.rotation = Property.getValueOrUndefined(ellipse.rotation, time);\n  options.granularity = Property.getValueOrUndefined(ellipse.granularity, time);\n  options.stRotation = Property.getValueOrUndefined(ellipse.stRotation, time);\n  options.numberOfVerticalLines = Property.getValueOrUndefined(\n    ellipse.numberOfVerticalLines,\n    time\n  );\n  options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(\n    heightValue,\n    heightReferenceValue,\n    extrudedHeightValue,\n    extrudedHeightReferenceValue\n  );\n  options.height = GroundGeometryUpdater.getGeometryHeight(\n    heightValue,\n    heightReferenceValue\n  );\n\n  extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(\n    extrudedHeightValue,\n    extrudedHeightReferenceValue\n  );\n  if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n    extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(\n      EllipseGeometry.computeRectangle(options, scratchRectangle)\n    ).minimumTerrainHeight;\n  }\n\n  options.extrudedHeight = extrudedHeightValue;\n};\nexport default EllipseGeometryUpdater;\n"]},"metadata":{},"sourceType":"module"}