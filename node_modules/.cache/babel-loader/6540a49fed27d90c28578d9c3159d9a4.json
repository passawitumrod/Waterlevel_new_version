{"ast":null,"code":"import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Framebuffer from \"../Renderer/Framebuffer.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport when from \"../ThirdParty/when.js\"; // The atlas is made up of regions of space called nodes that contain images or child nodes.\n\nfunction TextureAtlasNode(bottomLeft, topRight, childNode1, childNode2, imageIndex) {\n  this.bottomLeft = defaultValue(bottomLeft, Cartesian2.ZERO);\n  this.topRight = defaultValue(topRight, Cartesian2.ZERO);\n  this.childNode1 = childNode1;\n  this.childNode2 = childNode2;\n  this.imageIndex = imageIndex;\n}\n\nvar defaultInitialSize = new Cartesian2(16.0, 16.0);\n/**\n * A TextureAtlas stores multiple images in one square texture and keeps\n * track of the texture coordinates for each image. TextureAtlas is dynamic,\n * meaning new images can be added at any point in time.\n * Texture coordinates are subject to change if the texture atlas resizes, so it is\n * important to check {@link TextureAtlas#getGUID} before using old values.\n *\n * @alias TextureAtlas\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Scene} options.context The context in which the texture gets created.\n * @param {PixelFormat} [options.pixelFormat=PixelFormat.RGBA] The pixel format of the texture.\n * @param {Number} [options.borderWidthInPixels=1] The amount of spacing between adjacent images in pixels.\n * @param {Cartesian2} [options.initialSize=new Cartesian2(16.0, 16.0)] The initial side lengths of the texture.\n *\n * @exception {DeveloperError} borderWidthInPixels must be greater than or equal to zero.\n * @exception {DeveloperError} initialSize must be greater than zero.\n *\n * @private\n */\n\nfunction TextureAtlas(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var borderWidthInPixels = defaultValue(options.borderWidthInPixels, 1.0);\n  var initialSize = defaultValue(options.initialSize, defaultInitialSize); //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(options.context)) {\n    throw new DeveloperError(\"context is required.\");\n  }\n\n  if (borderWidthInPixels < 0) {\n    throw new DeveloperError(\"borderWidthInPixels must be greater than or equal to zero.\");\n  }\n\n  if (initialSize.x < 1 || initialSize.y < 1) {\n    throw new DeveloperError(\"initialSize must be greater than zero.\");\n  } //>>includeEnd('debug');\n\n\n  this._context = options.context;\n  this._pixelFormat = defaultValue(options.pixelFormat, PixelFormat.RGBA);\n  this._borderWidthInPixels = borderWidthInPixels;\n  this._textureCoordinates = [];\n  this._guid = createGuid();\n  this._idHash = {};\n  this._initialSize = initialSize;\n  this._root = undefined;\n}\n\nObject.defineProperties(TextureAtlas.prototype, {\n  /**\n   * The amount of spacing between adjacent images in pixels.\n   * @memberof TextureAtlas.prototype\n   * @type {Number}\n   */\n  borderWidthInPixels: {\n    get: function () {\n      return this._borderWidthInPixels;\n    }\n  },\n\n  /**\n   * An array of {@link BoundingRectangle} texture coordinate regions for all the images in the texture atlas.\n   * The x and y values of the rectangle correspond to the bottom-left corner of the texture coordinate.\n   * The coordinates are in the order that the corresponding images were added to the atlas.\n   * @memberof TextureAtlas.prototype\n   * @type {BoundingRectangle[]}\n   */\n  textureCoordinates: {\n    get: function () {\n      return this._textureCoordinates;\n    }\n  },\n\n  /**\n   * The texture that all of the images are being written to.\n   * @memberof TextureAtlas.prototype\n   * @type {Texture}\n   */\n  texture: {\n    get: function () {\n      if (!defined(this._texture)) {\n        this._texture = new Texture({\n          context: this._context,\n          width: this._initialSize.x,\n          height: this._initialSize.y,\n          pixelFormat: this._pixelFormat\n        });\n      }\n\n      return this._texture;\n    }\n  },\n\n  /**\n   * The number of images in the texture atlas. This value increases\n   * every time addImage or addImages is called.\n   * Texture coordinates are subject to change if the texture atlas resizes, so it is\n   * important to check {@link TextureAtlas#getGUID} before using old values.\n   * @memberof TextureAtlas.prototype\n   * @type {Number}\n   */\n  numberOfImages: {\n    get: function () {\n      return this._textureCoordinates.length;\n    }\n  },\n\n  /**\n   * The atlas' globally unique identifier (GUID).\n   * The GUID changes whenever the texture atlas is modified.\n   * Classes that use a texture atlas should check if the GUID\n   * has changed before processing the atlas data.\n   * @memberof TextureAtlas.prototype\n   * @type {String}\n   */\n  guid: {\n    get: function () {\n      return this._guid;\n    }\n  }\n}); // Builds a larger texture and copies the old texture into the new one.\n\nfunction resizeAtlas(textureAtlas, image) {\n  var context = textureAtlas._context;\n  var numImages = textureAtlas.numberOfImages;\n  var scalingFactor = 2.0;\n  var borderWidthInPixels = textureAtlas._borderWidthInPixels;\n\n  if (numImages > 0) {\n    var oldAtlasWidth = textureAtlas._texture.width;\n    var oldAtlasHeight = textureAtlas._texture.height;\n    var atlasWidth = scalingFactor * (oldAtlasWidth + image.width + borderWidthInPixels);\n    var atlasHeight = scalingFactor * (oldAtlasHeight + image.height + borderWidthInPixels);\n    var widthRatio = oldAtlasWidth / atlasWidth;\n    var heightRatio = oldAtlasHeight / atlasHeight; // Create new node structure, putting the old root node in the bottom left.\n\n    var nodeBottomRight = new TextureAtlasNode(new Cartesian2(oldAtlasWidth + borderWidthInPixels, borderWidthInPixels), new Cartesian2(atlasWidth, oldAtlasHeight));\n    var nodeBottomHalf = new TextureAtlasNode(new Cartesian2(), new Cartesian2(atlasWidth, oldAtlasHeight), textureAtlas._root, nodeBottomRight);\n    var nodeTopHalf = new TextureAtlasNode(new Cartesian2(borderWidthInPixels, oldAtlasHeight + borderWidthInPixels), new Cartesian2(atlasWidth, atlasHeight));\n    var nodeMain = new TextureAtlasNode(new Cartesian2(), new Cartesian2(atlasWidth, atlasHeight), nodeBottomHalf, nodeTopHalf); // Resize texture coordinates.\n\n    for (var i = 0; i < textureAtlas._textureCoordinates.length; i++) {\n      var texCoord = textureAtlas._textureCoordinates[i];\n\n      if (defined(texCoord)) {\n        texCoord.x *= widthRatio;\n        texCoord.y *= heightRatio;\n        texCoord.width *= widthRatio;\n        texCoord.height *= heightRatio;\n      }\n    } // Copy larger texture.\n\n\n    var newTexture = new Texture({\n      context: textureAtlas._context,\n      width: atlasWidth,\n      height: atlasHeight,\n      pixelFormat: textureAtlas._pixelFormat\n    });\n    var framebuffer = new Framebuffer({\n      context: context,\n      colorTextures: [textureAtlas._texture],\n      destroyAttachments: false\n    });\n\n    framebuffer._bind();\n\n    newTexture.copyFromFramebuffer(0, 0, 0, 0, atlasWidth, atlasHeight);\n\n    framebuffer._unBind();\n\n    framebuffer.destroy();\n    textureAtlas._texture = textureAtlas._texture && textureAtlas._texture.destroy();\n    textureAtlas._texture = newTexture;\n    textureAtlas._root = nodeMain;\n  } else {\n    // First image exceeds initialSize\n    var initialWidth = scalingFactor * (image.width + 2 * borderWidthInPixels);\n    var initialHeight = scalingFactor * (image.height + 2 * borderWidthInPixels);\n\n    if (initialWidth < textureAtlas._initialSize.x) {\n      initialWidth = textureAtlas._initialSize.x;\n    }\n\n    if (initialHeight < textureAtlas._initialSize.y) {\n      initialHeight = textureAtlas._initialSize.y;\n    }\n\n    textureAtlas._texture = textureAtlas._texture && textureAtlas._texture.destroy();\n    textureAtlas._texture = new Texture({\n      context: textureAtlas._context,\n      width: initialWidth,\n      height: initialHeight,\n      pixelFormat: textureAtlas._pixelFormat\n    });\n    textureAtlas._root = new TextureAtlasNode(new Cartesian2(borderWidthInPixels, borderWidthInPixels), new Cartesian2(initialWidth, initialHeight));\n  }\n} // A recursive function that finds the best place to insert\n// a new image based on existing image 'nodes'.\n// Inspired by: http://blackpawn.com/texts/lightmaps/default.html\n\n\nfunction findNode(textureAtlas, node, image) {\n  if (!defined(node)) {\n    return undefined;\n  } // If a leaf node\n\n\n  if (!defined(node.childNode1) && !defined(node.childNode2)) {\n    // Node already contains an image, don't add to it.\n    if (defined(node.imageIndex)) {\n      return undefined;\n    }\n\n    var nodeWidth = node.topRight.x - node.bottomLeft.x;\n    var nodeHeight = node.topRight.y - node.bottomLeft.y;\n    var widthDifference = nodeWidth - image.width;\n    var heightDifference = nodeHeight - image.height; // Node is smaller than the image.\n\n    if (widthDifference < 0 || heightDifference < 0) {\n      return undefined;\n    } // If the node is the same size as the image, return the node\n\n\n    if (widthDifference === 0 && heightDifference === 0) {\n      return node;\n    } // Vertical split (childNode1 = left half, childNode2 = right half).\n\n\n    if (widthDifference > heightDifference) {\n      node.childNode1 = new TextureAtlasNode(new Cartesian2(node.bottomLeft.x, node.bottomLeft.y), new Cartesian2(node.bottomLeft.x + image.width, node.topRight.y)); // Only make a second child if the border gives enough space.\n\n      var childNode2BottomLeftX = node.bottomLeft.x + image.width + textureAtlas._borderWidthInPixels;\n\n      if (childNode2BottomLeftX < node.topRight.x) {\n        node.childNode2 = new TextureAtlasNode(new Cartesian2(childNode2BottomLeftX, node.bottomLeft.y), new Cartesian2(node.topRight.x, node.topRight.y));\n      }\n    } // Horizontal split (childNode1 = bottom half, childNode2 = top half).\n    else {\n        node.childNode1 = new TextureAtlasNode(new Cartesian2(node.bottomLeft.x, node.bottomLeft.y), new Cartesian2(node.topRight.x, node.bottomLeft.y + image.height)); // Only make a second child if the border gives enough space.\n\n        var childNode2BottomLeftY = node.bottomLeft.y + image.height + textureAtlas._borderWidthInPixels;\n\n        if (childNode2BottomLeftY < node.topRight.y) {\n          node.childNode2 = new TextureAtlasNode(new Cartesian2(node.bottomLeft.x, childNode2BottomLeftY), new Cartesian2(node.topRight.x, node.topRight.y));\n        }\n      }\n\n    return findNode(textureAtlas, node.childNode1, image);\n  } // If not a leaf node\n\n\n  return findNode(textureAtlas, node.childNode1, image) || findNode(textureAtlas, node.childNode2, image);\n} // Adds image of given index to the texture atlas. Called from addImage and addImages.\n\n\nfunction addImage(textureAtlas, image, index) {\n  var node = findNode(textureAtlas, textureAtlas._root, image);\n\n  if (defined(node)) {\n    // Found a node that can hold the image.\n    node.imageIndex = index; // Add texture coordinate and write to texture\n\n    var atlasWidth = textureAtlas._texture.width;\n    var atlasHeight = textureAtlas._texture.height;\n    var nodeWidth = node.topRight.x - node.bottomLeft.x;\n    var nodeHeight = node.topRight.y - node.bottomLeft.y;\n    var x = node.bottomLeft.x / atlasWidth;\n    var y = node.bottomLeft.y / atlasHeight;\n    var w = nodeWidth / atlasWidth;\n    var h = nodeHeight / atlasHeight;\n    textureAtlas._textureCoordinates[index] = new BoundingRectangle(x, y, w, h);\n\n    textureAtlas._texture.copyFrom(image, node.bottomLeft.x, node.bottomLeft.y);\n  } else {\n    // No node found, must resize the texture atlas.\n    resizeAtlas(textureAtlas, image);\n    addImage(textureAtlas, image, index);\n  }\n\n  textureAtlas._guid = createGuid();\n}\n/**\n * Adds an image to the atlas.  If the image is already in the atlas, the atlas is unchanged and\n * the existing index is used.\n *\n * @param {String} id An identifier to detect whether the image already exists in the atlas.\n * @param {Image|Canvas|String|Resource|Promise|TextureAtlas~CreateImageCallback} image An image or canvas to add to the texture atlas,\n *        or a URL to an Image, or a Promise for an image, or a function that creates an image.\n * @returns {Promise.<Number>} A Promise for the image index.\n */\n\n\nTextureAtlas.prototype.addImage = function (id, image) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required.\");\n  }\n\n  if (!defined(image)) {\n    throw new DeveloperError(\"image is required.\");\n  } //>>includeEnd('debug');\n\n\n  var indexPromise = this._idHash[id];\n\n  if (defined(indexPromise)) {\n    // we're already aware of this source\n    return indexPromise;\n  } // not in atlas, create the promise for the index\n\n\n  if (typeof image === \"function\") {\n    // if image is a function, call it\n    image = image(id); //>>includeStart('debug', pragmas.debug);\n\n    if (!defined(image)) {\n      throw new DeveloperError(\"image is required.\");\n    } //>>includeEnd('debug');\n\n  } else if (typeof image === \"string\" || image instanceof Resource) {\n    // Get a resource\n    var resource = Resource.createIfNeeded(image);\n    image = resource.fetchImage();\n  }\n\n  var that = this;\n  indexPromise = when(image, function (image) {\n    if (that.isDestroyed()) {\n      return -1;\n    }\n\n    var index = that.numberOfImages;\n    addImage(that, image, index);\n    return index;\n  }); // store the promise\n\n  this._idHash[id] = indexPromise;\n  return indexPromise;\n};\n/**\n * Add a sub-region of an existing atlas image as additional image indices.\n *\n * @param {String} id The identifier of the existing image.\n * @param {BoundingRectangle} subRegion An {@link BoundingRectangle} sub-region measured in pixels from the bottom-left.\n *\n * @returns {Promise.<Number>} A Promise for the image index.\n */\n\n\nTextureAtlas.prototype.addSubRegion = function (id, subRegion) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required.\");\n  }\n\n  if (!defined(subRegion)) {\n    throw new DeveloperError(\"subRegion is required.\");\n  } //>>includeEnd('debug');\n\n\n  var indexPromise = this._idHash[id];\n\n  if (!defined(indexPromise)) {\n    throw new RuntimeError('image with id \"' + id + '\" not found in the atlas.');\n  }\n\n  var that = this;\n  return when(indexPromise, function (index) {\n    if (index === -1) {\n      // the atlas is destroyed\n      return -1;\n    }\n\n    var atlasWidth = that._texture.width;\n    var atlasHeight = that._texture.height;\n    var numImages = that.numberOfImages;\n    var baseRegion = that._textureCoordinates[index];\n    var x = baseRegion.x + subRegion.x / atlasWidth;\n    var y = baseRegion.y + subRegion.y / atlasHeight;\n    var w = subRegion.width / atlasWidth;\n    var h = subRegion.height / atlasHeight;\n\n    that._textureCoordinates.push(new BoundingRectangle(x, y, w, h));\n\n    that._guid = createGuid();\n    return numImages;\n  });\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see TextureAtlas#destroy\n */\n\n\nTextureAtlas.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * atlas = atlas && atlas.destroy();\n *\n * @see TextureAtlas#isDestroyed\n */\n\n\nTextureAtlas.prototype.destroy = function () {\n  this._texture = this._texture && this._texture.destroy();\n  return destroyObject(this);\n};\n/**\n * A function that creates an image.\n * @callback TextureAtlas~CreateImageCallback\n * @param {String} id The identifier of the image to load.\n * @returns {Image|Promise} The image, or a promise that will resolve to an image.\n */\n\n\nexport default TextureAtlas;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/TextureAtlas.js"],"names":["BoundingRectangle","Cartesian2","createGuid","defaultValue","defined","destroyObject","DeveloperError","PixelFormat","Resource","RuntimeError","Framebuffer","Texture","when","TextureAtlasNode","bottomLeft","topRight","childNode1","childNode2","imageIndex","ZERO","defaultInitialSize","TextureAtlas","options","EMPTY_OBJECT","borderWidthInPixels","initialSize","context","x","y","_context","_pixelFormat","pixelFormat","RGBA","_borderWidthInPixels","_textureCoordinates","_guid","_idHash","_initialSize","_root","undefined","Object","defineProperties","prototype","get","textureCoordinates","texture","_texture","width","height","numberOfImages","length","guid","resizeAtlas","textureAtlas","image","numImages","scalingFactor","oldAtlasWidth","oldAtlasHeight","atlasWidth","atlasHeight","widthRatio","heightRatio","nodeBottomRight","nodeBottomHalf","nodeTopHalf","nodeMain","i","texCoord","newTexture","framebuffer","colorTextures","destroyAttachments","_bind","copyFromFramebuffer","_unBind","destroy","initialWidth","initialHeight","findNode","node","nodeWidth","nodeHeight","widthDifference","heightDifference","childNode2BottomLeftX","childNode2BottomLeftY","addImage","index","w","h","copyFrom","id","indexPromise","resource","createIfNeeded","fetchImage","that","isDestroyed","addSubRegion","subRegion","baseRegion","push"],"mappings":"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","sourcesContent":["import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Framebuffer from \"../Renderer/Framebuffer.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport when from \"../ThirdParty/when.js\";\n\n// The atlas is made up of regions of space called nodes that contain images or child nodes.\nfunction TextureAtlasNode(\n  bottomLeft,\n  topRight,\n  childNode1,\n  childNode2,\n  imageIndex\n) {\n  this.bottomLeft = defaultValue(bottomLeft, Cartesian2.ZERO);\n  this.topRight = defaultValue(topRight, Cartesian2.ZERO);\n  this.childNode1 = childNode1;\n  this.childNode2 = childNode2;\n  this.imageIndex = imageIndex;\n}\n\nvar defaultInitialSize = new Cartesian2(16.0, 16.0);\n\n/**\n * A TextureAtlas stores multiple images in one square texture and keeps\n * track of the texture coordinates for each image. TextureAtlas is dynamic,\n * meaning new images can be added at any point in time.\n * Texture coordinates are subject to change if the texture atlas resizes, so it is\n * important to check {@link TextureAtlas#getGUID} before using old values.\n *\n * @alias TextureAtlas\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Scene} options.context The context in which the texture gets created.\n * @param {PixelFormat} [options.pixelFormat=PixelFormat.RGBA] The pixel format of the texture.\n * @param {Number} [options.borderWidthInPixels=1] The amount of spacing between adjacent images in pixels.\n * @param {Cartesian2} [options.initialSize=new Cartesian2(16.0, 16.0)] The initial side lengths of the texture.\n *\n * @exception {DeveloperError} borderWidthInPixels must be greater than or equal to zero.\n * @exception {DeveloperError} initialSize must be greater than zero.\n *\n * @private\n */\nfunction TextureAtlas(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var borderWidthInPixels = defaultValue(options.borderWidthInPixels, 1.0);\n  var initialSize = defaultValue(options.initialSize, defaultInitialSize);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.context)) {\n    throw new DeveloperError(\"context is required.\");\n  }\n  if (borderWidthInPixels < 0) {\n    throw new DeveloperError(\n      \"borderWidthInPixels must be greater than or equal to zero.\"\n    );\n  }\n  if (initialSize.x < 1 || initialSize.y < 1) {\n    throw new DeveloperError(\"initialSize must be greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  this._context = options.context;\n  this._pixelFormat = defaultValue(options.pixelFormat, PixelFormat.RGBA);\n  this._borderWidthInPixels = borderWidthInPixels;\n  this._textureCoordinates = [];\n  this._guid = createGuid();\n  this._idHash = {};\n  this._initialSize = initialSize;\n\n  this._root = undefined;\n}\n\nObject.defineProperties(TextureAtlas.prototype, {\n  /**\n   * The amount of spacing between adjacent images in pixels.\n   * @memberof TextureAtlas.prototype\n   * @type {Number}\n   */\n  borderWidthInPixels: {\n    get: function () {\n      return this._borderWidthInPixels;\n    },\n  },\n\n  /**\n   * An array of {@link BoundingRectangle} texture coordinate regions for all the images in the texture atlas.\n   * The x and y values of the rectangle correspond to the bottom-left corner of the texture coordinate.\n   * The coordinates are in the order that the corresponding images were added to the atlas.\n   * @memberof TextureAtlas.prototype\n   * @type {BoundingRectangle[]}\n   */\n  textureCoordinates: {\n    get: function () {\n      return this._textureCoordinates;\n    },\n  },\n\n  /**\n   * The texture that all of the images are being written to.\n   * @memberof TextureAtlas.prototype\n   * @type {Texture}\n   */\n  texture: {\n    get: function () {\n      if (!defined(this._texture)) {\n        this._texture = new Texture({\n          context: this._context,\n          width: this._initialSize.x,\n          height: this._initialSize.y,\n          pixelFormat: this._pixelFormat,\n        });\n      }\n      return this._texture;\n    },\n  },\n\n  /**\n   * The number of images in the texture atlas. This value increases\n   * every time addImage or addImages is called.\n   * Texture coordinates are subject to change if the texture atlas resizes, so it is\n   * important to check {@link TextureAtlas#getGUID} before using old values.\n   * @memberof TextureAtlas.prototype\n   * @type {Number}\n   */\n  numberOfImages: {\n    get: function () {\n      return this._textureCoordinates.length;\n    },\n  },\n\n  /**\n   * The atlas' globally unique identifier (GUID).\n   * The GUID changes whenever the texture atlas is modified.\n   * Classes that use a texture atlas should check if the GUID\n   * has changed before processing the atlas data.\n   * @memberof TextureAtlas.prototype\n   * @type {String}\n   */\n  guid: {\n    get: function () {\n      return this._guid;\n    },\n  },\n});\n\n// Builds a larger texture and copies the old texture into the new one.\nfunction resizeAtlas(textureAtlas, image) {\n  var context = textureAtlas._context;\n  var numImages = textureAtlas.numberOfImages;\n  var scalingFactor = 2.0;\n  var borderWidthInPixels = textureAtlas._borderWidthInPixels;\n  if (numImages > 0) {\n    var oldAtlasWidth = textureAtlas._texture.width;\n    var oldAtlasHeight = textureAtlas._texture.height;\n    var atlasWidth =\n      scalingFactor * (oldAtlasWidth + image.width + borderWidthInPixels);\n    var atlasHeight =\n      scalingFactor * (oldAtlasHeight + image.height + borderWidthInPixels);\n    var widthRatio = oldAtlasWidth / atlasWidth;\n    var heightRatio = oldAtlasHeight / atlasHeight;\n\n    // Create new node structure, putting the old root node in the bottom left.\n    var nodeBottomRight = new TextureAtlasNode(\n      new Cartesian2(oldAtlasWidth + borderWidthInPixels, borderWidthInPixels),\n      new Cartesian2(atlasWidth, oldAtlasHeight)\n    );\n    var nodeBottomHalf = new TextureAtlasNode(\n      new Cartesian2(),\n      new Cartesian2(atlasWidth, oldAtlasHeight),\n      textureAtlas._root,\n      nodeBottomRight\n    );\n    var nodeTopHalf = new TextureAtlasNode(\n      new Cartesian2(borderWidthInPixels, oldAtlasHeight + borderWidthInPixels),\n      new Cartesian2(atlasWidth, atlasHeight)\n    );\n    var nodeMain = new TextureAtlasNode(\n      new Cartesian2(),\n      new Cartesian2(atlasWidth, atlasHeight),\n      nodeBottomHalf,\n      nodeTopHalf\n    );\n\n    // Resize texture coordinates.\n    for (var i = 0; i < textureAtlas._textureCoordinates.length; i++) {\n      var texCoord = textureAtlas._textureCoordinates[i];\n      if (defined(texCoord)) {\n        texCoord.x *= widthRatio;\n        texCoord.y *= heightRatio;\n        texCoord.width *= widthRatio;\n        texCoord.height *= heightRatio;\n      }\n    }\n\n    // Copy larger texture.\n    var newTexture = new Texture({\n      context: textureAtlas._context,\n      width: atlasWidth,\n      height: atlasHeight,\n      pixelFormat: textureAtlas._pixelFormat,\n    });\n\n    var framebuffer = new Framebuffer({\n      context: context,\n      colorTextures: [textureAtlas._texture],\n      destroyAttachments: false,\n    });\n\n    framebuffer._bind();\n    newTexture.copyFromFramebuffer(0, 0, 0, 0, atlasWidth, atlasHeight);\n    framebuffer._unBind();\n    framebuffer.destroy();\n    textureAtlas._texture =\n      textureAtlas._texture && textureAtlas._texture.destroy();\n    textureAtlas._texture = newTexture;\n    textureAtlas._root = nodeMain;\n  } else {\n    // First image exceeds initialSize\n    var initialWidth = scalingFactor * (image.width + 2 * borderWidthInPixels);\n    var initialHeight =\n      scalingFactor * (image.height + 2 * borderWidthInPixels);\n    if (initialWidth < textureAtlas._initialSize.x) {\n      initialWidth = textureAtlas._initialSize.x;\n    }\n    if (initialHeight < textureAtlas._initialSize.y) {\n      initialHeight = textureAtlas._initialSize.y;\n    }\n    textureAtlas._texture =\n      textureAtlas._texture && textureAtlas._texture.destroy();\n    textureAtlas._texture = new Texture({\n      context: textureAtlas._context,\n      width: initialWidth,\n      height: initialHeight,\n      pixelFormat: textureAtlas._pixelFormat,\n    });\n    textureAtlas._root = new TextureAtlasNode(\n      new Cartesian2(borderWidthInPixels, borderWidthInPixels),\n      new Cartesian2(initialWidth, initialHeight)\n    );\n  }\n}\n\n// A recursive function that finds the best place to insert\n// a new image based on existing image 'nodes'.\n// Inspired by: http://blackpawn.com/texts/lightmaps/default.html\nfunction findNode(textureAtlas, node, image) {\n  if (!defined(node)) {\n    return undefined;\n  }\n\n  // If a leaf node\n  if (!defined(node.childNode1) && !defined(node.childNode2)) {\n    // Node already contains an image, don't add to it.\n    if (defined(node.imageIndex)) {\n      return undefined;\n    }\n\n    var nodeWidth = node.topRight.x - node.bottomLeft.x;\n    var nodeHeight = node.topRight.y - node.bottomLeft.y;\n    var widthDifference = nodeWidth - image.width;\n    var heightDifference = nodeHeight - image.height;\n\n    // Node is smaller than the image.\n    if (widthDifference < 0 || heightDifference < 0) {\n      return undefined;\n    }\n\n    // If the node is the same size as the image, return the node\n    if (widthDifference === 0 && heightDifference === 0) {\n      return node;\n    }\n\n    // Vertical split (childNode1 = left half, childNode2 = right half).\n    if (widthDifference > heightDifference) {\n      node.childNode1 = new TextureAtlasNode(\n        new Cartesian2(node.bottomLeft.x, node.bottomLeft.y),\n        new Cartesian2(node.bottomLeft.x + image.width, node.topRight.y)\n      );\n      // Only make a second child if the border gives enough space.\n      var childNode2BottomLeftX =\n        node.bottomLeft.x + image.width + textureAtlas._borderWidthInPixels;\n      if (childNode2BottomLeftX < node.topRight.x) {\n        node.childNode2 = new TextureAtlasNode(\n          new Cartesian2(childNode2BottomLeftX, node.bottomLeft.y),\n          new Cartesian2(node.topRight.x, node.topRight.y)\n        );\n      }\n    }\n    // Horizontal split (childNode1 = bottom half, childNode2 = top half).\n    else {\n      node.childNode1 = new TextureAtlasNode(\n        new Cartesian2(node.bottomLeft.x, node.bottomLeft.y),\n        new Cartesian2(node.topRight.x, node.bottomLeft.y + image.height)\n      );\n      // Only make a second child if the border gives enough space.\n      var childNode2BottomLeftY =\n        node.bottomLeft.y + image.height + textureAtlas._borderWidthInPixels;\n      if (childNode2BottomLeftY < node.topRight.y) {\n        node.childNode2 = new TextureAtlasNode(\n          new Cartesian2(node.bottomLeft.x, childNode2BottomLeftY),\n          new Cartesian2(node.topRight.x, node.topRight.y)\n        );\n      }\n    }\n    return findNode(textureAtlas, node.childNode1, image);\n  }\n\n  // If not a leaf node\n  return (\n    findNode(textureAtlas, node.childNode1, image) ||\n    findNode(textureAtlas, node.childNode2, image)\n  );\n}\n\n// Adds image of given index to the texture atlas. Called from addImage and addImages.\nfunction addImage(textureAtlas, image, index) {\n  var node = findNode(textureAtlas, textureAtlas._root, image);\n  if (defined(node)) {\n    // Found a node that can hold the image.\n    node.imageIndex = index;\n\n    // Add texture coordinate and write to texture\n    var atlasWidth = textureAtlas._texture.width;\n    var atlasHeight = textureAtlas._texture.height;\n    var nodeWidth = node.topRight.x - node.bottomLeft.x;\n    var nodeHeight = node.topRight.y - node.bottomLeft.y;\n    var x = node.bottomLeft.x / atlasWidth;\n    var y = node.bottomLeft.y / atlasHeight;\n    var w = nodeWidth / atlasWidth;\n    var h = nodeHeight / atlasHeight;\n    textureAtlas._textureCoordinates[index] = new BoundingRectangle(x, y, w, h);\n    textureAtlas._texture.copyFrom(image, node.bottomLeft.x, node.bottomLeft.y);\n  } else {\n    // No node found, must resize the texture atlas.\n    resizeAtlas(textureAtlas, image);\n    addImage(textureAtlas, image, index);\n  }\n\n  textureAtlas._guid = createGuid();\n}\n\n/**\n * Adds an image to the atlas.  If the image is already in the atlas, the atlas is unchanged and\n * the existing index is used.\n *\n * @param {String} id An identifier to detect whether the image already exists in the atlas.\n * @param {Image|Canvas|String|Resource|Promise|TextureAtlas~CreateImageCallback} image An image or canvas to add to the texture atlas,\n *        or a URL to an Image, or a Promise for an image, or a function that creates an image.\n * @returns {Promise.<Number>} A Promise for the image index.\n */\nTextureAtlas.prototype.addImage = function (id, image) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required.\");\n  }\n  if (!defined(image)) {\n    throw new DeveloperError(\"image is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var indexPromise = this._idHash[id];\n  if (defined(indexPromise)) {\n    // we're already aware of this source\n    return indexPromise;\n  }\n\n  // not in atlas, create the promise for the index\n\n  if (typeof image === \"function\") {\n    // if image is a function, call it\n    image = image(id);\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(image)) {\n      throw new DeveloperError(\"image is required.\");\n    }\n    //>>includeEnd('debug');\n  } else if (typeof image === \"string\" || image instanceof Resource) {\n    // Get a resource\n    var resource = Resource.createIfNeeded(image);\n    image = resource.fetchImage();\n  }\n\n  var that = this;\n\n  indexPromise = when(image, function (image) {\n    if (that.isDestroyed()) {\n      return -1;\n    }\n\n    var index = that.numberOfImages;\n\n    addImage(that, image, index);\n\n    return index;\n  });\n\n  // store the promise\n  this._idHash[id] = indexPromise;\n\n  return indexPromise;\n};\n\n/**\n * Add a sub-region of an existing atlas image as additional image indices.\n *\n * @param {String} id The identifier of the existing image.\n * @param {BoundingRectangle} subRegion An {@link BoundingRectangle} sub-region measured in pixels from the bottom-left.\n *\n * @returns {Promise.<Number>} A Promise for the image index.\n */\nTextureAtlas.prototype.addSubRegion = function (id, subRegion) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required.\");\n  }\n  if (!defined(subRegion)) {\n    throw new DeveloperError(\"subRegion is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var indexPromise = this._idHash[id];\n  if (!defined(indexPromise)) {\n    throw new RuntimeError(\n      'image with id \"' + id + '\" not found in the atlas.'\n    );\n  }\n\n  var that = this;\n  return when(indexPromise, function (index) {\n    if (index === -1) {\n      // the atlas is destroyed\n      return -1;\n    }\n    var atlasWidth = that._texture.width;\n    var atlasHeight = that._texture.height;\n    var numImages = that.numberOfImages;\n\n    var baseRegion = that._textureCoordinates[index];\n    var x = baseRegion.x + subRegion.x / atlasWidth;\n    var y = baseRegion.y + subRegion.y / atlasHeight;\n    var w = subRegion.width / atlasWidth;\n    var h = subRegion.height / atlasHeight;\n    that._textureCoordinates.push(new BoundingRectangle(x, y, w, h));\n    that._guid = createGuid();\n\n    return numImages;\n  });\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see TextureAtlas#destroy\n */\nTextureAtlas.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * atlas = atlas && atlas.destroy();\n *\n * @see TextureAtlas#isDestroyed\n */\nTextureAtlas.prototype.destroy = function () {\n  this._texture = this._texture && this._texture.destroy();\n  return destroyObject(this);\n};\n\n/**\n * A function that creates an image.\n * @callback TextureAtlas~CreateImageCallback\n * @param {String} id The identifier of the image to load.\n * @returns {Image|Promise} The image, or a promise that will resolve to an image.\n */\nexport default TextureAtlas;\n"]},"metadata":{},"sourceType":"module"}