{"ast":null,"code":"import BoxGeometry from \"../Core/BoxGeometry.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport VertexFormat from \"../Core/VertexFormat.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport CubeMap from \"../Renderer/CubeMap.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport loadCubeMap from \"../Renderer/loadCubeMap.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport SkyBoxFS from \"../Shaders/SkyBoxFS.js\";\nimport SkyBoxVS from \"../Shaders/SkyBoxVS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport SceneMode from \"./SceneMode.js\";\n/**\n * A sky box around the scene to draw stars.  The sky box is defined using the True Equator Mean Equinox (TEME) axes.\n * <p>\n * This is only supported in 3D.  The sky box is faded out when morphing to 2D or Columbus view.  The size of\n * the sky box must not exceed {@link Scene#maximumCubeMapSize}.\n * </p>\n *\n * @alias SkyBox\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} [options.sources] The source URL or <code>Image</code> object for each of the six cube map faces.  See the example below.\n * @param {Boolean} [options.show=true] Determines if this primitive will be shown.\n *\n *\n * @example\n * scene.skyBox = new Cesium.SkyBox({\n *   sources : {\n *     positiveX : 'skybox_px.png',\n *     negativeX : 'skybox_nx.png',\n *     positiveY : 'skybox_py.png',\n *     negativeY : 'skybox_ny.png',\n *     positiveZ : 'skybox_pz.png',\n *     negativeZ : 'skybox_nz.png'\n *   }\n * });\n *\n * @see Scene#skyBox\n * @see Transforms.computeTemeToPseudoFixedMatrix\n */\n\nfunction SkyBox(options) {\n  /**\n   * The sources used to create the cube map faces: an object\n   * with <code>positiveX</code>, <code>negativeX</code>, <code>positiveY</code>,\n   * <code>negativeY</code>, <code>positiveZ</code>, and <code>negativeZ</code> properties.\n   * These can be either URLs or <code>Image</code> objects.\n   *\n   * @type Object\n   * @default undefined\n   */\n  this.sources = options.sources;\n  this._sources = undefined;\n  /**\n   * Determines if the sky box will be shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.show = defaultValue(options.show, true);\n  this._command = new DrawCommand({\n    modelMatrix: Matrix4.clone(Matrix4.IDENTITY),\n    owner: this\n  });\n  this._cubeMap = undefined;\n  this._attributeLocations = undefined;\n  this._useHdr = undefined;\n}\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} this.sources is required and must have positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ properties.\n * @exception {DeveloperError} this.sources properties must all be the same type.\n */\n\n\nSkyBox.prototype.update = function (frameState, useHdr) {\n  var that = this;\n\n  if (!this.show) {\n    return undefined;\n  }\n\n  if (frameState.mode !== SceneMode.SCENE3D && frameState.mode !== SceneMode.MORPHING) {\n    return undefined;\n  } // The sky box is only rendered during the render pass; it is not pickable, it doesn't cast shadows, etc.\n\n\n  if (!frameState.passes.render) {\n    return undefined;\n  }\n\n  var context = frameState.context;\n\n  if (this._sources !== this.sources) {\n    this._sources = this.sources;\n    var sources = this.sources; //>>includeStart('debug', pragmas.debug);\n\n    if (!defined(sources.positiveX) || !defined(sources.negativeX) || !defined(sources.positiveY) || !defined(sources.negativeY) || !defined(sources.positiveZ) || !defined(sources.negativeZ)) {\n      throw new DeveloperError(\"this.sources is required and must have positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ properties.\");\n    }\n\n    if (typeof sources.positiveX !== typeof sources.negativeX || typeof sources.positiveX !== typeof sources.positiveY || typeof sources.positiveX !== typeof sources.negativeY || typeof sources.positiveX !== typeof sources.positiveZ || typeof sources.positiveX !== typeof sources.negativeZ) {\n      throw new DeveloperError(\"this.sources properties must all be the same type.\");\n    } //>>includeEnd('debug');\n\n\n    if (typeof sources.positiveX === \"string\") {\n      // Given urls for cube-map images.  Load them.\n      loadCubeMap(context, this._sources).then(function (cubeMap) {\n        that._cubeMap = that._cubeMap && that._cubeMap.destroy();\n        that._cubeMap = cubeMap;\n      });\n    } else {\n      this._cubeMap = this._cubeMap && this._cubeMap.destroy();\n      this._cubeMap = new CubeMap({\n        context: context,\n        source: sources\n      });\n    }\n  }\n\n  var command = this._command;\n\n  if (!defined(command.vertexArray)) {\n    command.uniformMap = {\n      u_cubeMap: function () {\n        return that._cubeMap;\n      }\n    };\n    var geometry = BoxGeometry.createGeometry(BoxGeometry.fromDimensions({\n      dimensions: new Cartesian3(2.0, 2.0, 2.0),\n      vertexFormat: VertexFormat.POSITION_ONLY\n    }));\n    var attributeLocations = this._attributeLocations = GeometryPipeline.createAttributeLocations(geometry);\n    command.vertexArray = VertexArray.fromGeometry({\n      context: context,\n      geometry: geometry,\n      attributeLocations: attributeLocations,\n      bufferUsage: BufferUsage.STATIC_DRAW\n    });\n    command.renderState = RenderState.fromCache({\n      blending: BlendingState.ALPHA_BLEND\n    });\n  }\n\n  if (!defined(command.shaderProgram) || this._useHdr !== useHdr) {\n    var fs = new ShaderSource({\n      defines: [useHdr ? \"HDR\" : \"\"],\n      sources: [SkyBoxFS]\n    });\n    command.shaderProgram = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: SkyBoxVS,\n      fragmentShaderSource: fs,\n      attributeLocations: this._attributeLocations\n    });\n    this._useHdr = useHdr;\n  }\n\n  if (!defined(this._cubeMap)) {\n    return undefined;\n  }\n\n  return command;\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see SkyBox#destroy\n */\n\n\nSkyBox.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * skyBox = skyBox && skyBox.destroy();\n *\n * @see SkyBox#isDestroyed\n */\n\n\nSkyBox.prototype.destroy = function () {\n  var command = this._command;\n  command.vertexArray = command.vertexArray && command.vertexArray.destroy();\n  command.shaderProgram = command.shaderProgram && command.shaderProgram.destroy();\n  this._cubeMap = this._cubeMap && this._cubeMap.destroy();\n  return destroyObject(this);\n};\n\nexport default SkyBox;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Scene/SkyBox.js"],"names":["BoxGeometry","Cartesian3","defaultValue","defined","destroyObject","DeveloperError","GeometryPipeline","Matrix4","VertexFormat","BufferUsage","CubeMap","DrawCommand","loadCubeMap","RenderState","ShaderProgram","ShaderSource","VertexArray","SkyBoxFS","SkyBoxVS","BlendingState","SceneMode","SkyBox","options","sources","_sources","undefined","show","_command","modelMatrix","clone","IDENTITY","owner","_cubeMap","_attributeLocations","_useHdr","prototype","update","frameState","useHdr","that","mode","SCENE3D","MORPHING","passes","render","context","positiveX","negativeX","positiveY","negativeY","positiveZ","negativeZ","then","cubeMap","destroy","source","command","vertexArray","uniformMap","u_cubeMap","geometry","createGeometry","fromDimensions","dimensions","vertexFormat","POSITION_ONLY","attributeLocations","createAttributeLocations","fromGeometry","bufferUsage","STATIC_DRAW","renderState","fromCache","blending","ALPHA_BLEND","shaderProgram","fs","defines","vertexShaderSource","fragmentShaderSource","isDestroyed"],"mappings":"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","sourcesContent":["import BoxGeometry from \"../Core/BoxGeometry.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport VertexFormat from \"../Core/VertexFormat.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport CubeMap from \"../Renderer/CubeMap.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport loadCubeMap from \"../Renderer/loadCubeMap.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport SkyBoxFS from \"../Shaders/SkyBoxFS.js\";\nimport SkyBoxVS from \"../Shaders/SkyBoxVS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * A sky box around the scene to draw stars.  The sky box is defined using the True Equator Mean Equinox (TEME) axes.\n * <p>\n * This is only supported in 3D.  The sky box is faded out when morphing to 2D or Columbus view.  The size of\n * the sky box must not exceed {@link Scene#maximumCubeMapSize}.\n * </p>\n *\n * @alias SkyBox\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} [options.sources] The source URL or <code>Image</code> object for each of the six cube map faces.  See the example below.\n * @param {Boolean} [options.show=true] Determines if this primitive will be shown.\n *\n *\n * @example\n * scene.skyBox = new Cesium.SkyBox({\n *   sources : {\n *     positiveX : 'skybox_px.png',\n *     negativeX : 'skybox_nx.png',\n *     positiveY : 'skybox_py.png',\n *     negativeY : 'skybox_ny.png',\n *     positiveZ : 'skybox_pz.png',\n *     negativeZ : 'skybox_nz.png'\n *   }\n * });\n *\n * @see Scene#skyBox\n * @see Transforms.computeTemeToPseudoFixedMatrix\n */\nfunction SkyBox(options) {\n  /**\n   * The sources used to create the cube map faces: an object\n   * with <code>positiveX</code>, <code>negativeX</code>, <code>positiveY</code>,\n   * <code>negativeY</code>, <code>positiveZ</code>, and <code>negativeZ</code> properties.\n   * These can be either URLs or <code>Image</code> objects.\n   *\n   * @type Object\n   * @default undefined\n   */\n  this.sources = options.sources;\n  this._sources = undefined;\n\n  /**\n   * Determines if the sky box will be shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  this._command = new DrawCommand({\n    modelMatrix: Matrix4.clone(Matrix4.IDENTITY),\n    owner: this,\n  });\n  this._cubeMap = undefined;\n\n  this._attributeLocations = undefined;\n  this._useHdr = undefined;\n}\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} this.sources is required and must have positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ properties.\n * @exception {DeveloperError} this.sources properties must all be the same type.\n */\nSkyBox.prototype.update = function (frameState, useHdr) {\n  var that = this;\n\n  if (!this.show) {\n    return undefined;\n  }\n\n  if (\n    frameState.mode !== SceneMode.SCENE3D &&\n    frameState.mode !== SceneMode.MORPHING\n  ) {\n    return undefined;\n  }\n\n  // The sky box is only rendered during the render pass; it is not pickable, it doesn't cast shadows, etc.\n  if (!frameState.passes.render) {\n    return undefined;\n  }\n\n  var context = frameState.context;\n\n  if (this._sources !== this.sources) {\n    this._sources = this.sources;\n    var sources = this.sources;\n\n    //>>includeStart('debug', pragmas.debug);\n    if (\n      !defined(sources.positiveX) ||\n      !defined(sources.negativeX) ||\n      !defined(sources.positiveY) ||\n      !defined(sources.negativeY) ||\n      !defined(sources.positiveZ) ||\n      !defined(sources.negativeZ)\n    ) {\n      throw new DeveloperError(\n        \"this.sources is required and must have positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ properties.\"\n      );\n    }\n\n    if (\n      typeof sources.positiveX !== typeof sources.negativeX ||\n      typeof sources.positiveX !== typeof sources.positiveY ||\n      typeof sources.positiveX !== typeof sources.negativeY ||\n      typeof sources.positiveX !== typeof sources.positiveZ ||\n      typeof sources.positiveX !== typeof sources.negativeZ\n    ) {\n      throw new DeveloperError(\n        \"this.sources properties must all be the same type.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    if (typeof sources.positiveX === \"string\") {\n      // Given urls for cube-map images.  Load them.\n      loadCubeMap(context, this._sources).then(function (cubeMap) {\n        that._cubeMap = that._cubeMap && that._cubeMap.destroy();\n        that._cubeMap = cubeMap;\n      });\n    } else {\n      this._cubeMap = this._cubeMap && this._cubeMap.destroy();\n      this._cubeMap = new CubeMap({\n        context: context,\n        source: sources,\n      });\n    }\n  }\n\n  var command = this._command;\n\n  if (!defined(command.vertexArray)) {\n    command.uniformMap = {\n      u_cubeMap: function () {\n        return that._cubeMap;\n      },\n    };\n\n    var geometry = BoxGeometry.createGeometry(\n      BoxGeometry.fromDimensions({\n        dimensions: new Cartesian3(2.0, 2.0, 2.0),\n        vertexFormat: VertexFormat.POSITION_ONLY,\n      })\n    );\n    var attributeLocations = (this._attributeLocations = GeometryPipeline.createAttributeLocations(\n      geometry\n    ));\n\n    command.vertexArray = VertexArray.fromGeometry({\n      context: context,\n      geometry: geometry,\n      attributeLocations: attributeLocations,\n      bufferUsage: BufferUsage.STATIC_DRAW,\n    });\n\n    command.renderState = RenderState.fromCache({\n      blending: BlendingState.ALPHA_BLEND,\n    });\n  }\n\n  if (!defined(command.shaderProgram) || this._useHdr !== useHdr) {\n    var fs = new ShaderSource({\n      defines: [useHdr ? \"HDR\" : \"\"],\n      sources: [SkyBoxFS],\n    });\n    command.shaderProgram = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: SkyBoxVS,\n      fragmentShaderSource: fs,\n      attributeLocations: this._attributeLocations,\n    });\n    this._useHdr = useHdr;\n  }\n\n  if (!defined(this._cubeMap)) {\n    return undefined;\n  }\n\n  return command;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see SkyBox#destroy\n */\nSkyBox.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * skyBox = skyBox && skyBox.destroy();\n *\n * @see SkyBox#isDestroyed\n */\nSkyBox.prototype.destroy = function () {\n  var command = this._command;\n  command.vertexArray = command.vertexArray && command.vertexArray.destroy();\n  command.shaderProgram =\n    command.shaderProgram && command.shaderProgram.destroy();\n  this._cubeMap = this._cubeMap && this._cubeMap.destroy();\n  return destroyObject(this);\n};\nexport default SkyBox;\n"]},"metadata":{},"sourceType":"module"}