{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Intersect from \"./Intersect.js\";\n/**\n * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.\n * @alias AxisAlignedBoundingBox\n * @constructor\n *\n * @param {Cartesian3} [minimum=Cartesian3.ZERO] The minimum point along the x, y, and z axes.\n * @param {Cartesian3} [maximum=Cartesian3.ZERO] The maximum point along the x, y, and z axes.\n * @param {Cartesian3} [center] The center of the box; automatically computed if not supplied.\n *\n * @see BoundingSphere\n * @see BoundingRectangle\n */\n\nfunction AxisAlignedBoundingBox(minimum, maximum, center) {\n  /**\n   * The minimum point defining the bounding box.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.minimum = Cartesian3.clone(defaultValue(minimum, Cartesian3.ZERO));\n  /**\n   * The maximum point defining the bounding box.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n\n  this.maximum = Cartesian3.clone(defaultValue(maximum, Cartesian3.ZERO)); //If center was not defined, compute it.\n\n  if (!defined(center)) {\n    center = Cartesian3.midpoint(this.minimum, this.maximum, new Cartesian3());\n  } else {\n    center = Cartesian3.clone(center);\n  }\n  /**\n   * The center point of the bounding box.\n   * @type {Cartesian3}\n   */\n\n\n  this.center = center;\n}\n/**\n * Computes an instance of an AxisAlignedBoundingBox. The box is determined by\n * finding the points spaced the farthest apart on the x, y, and z axes.\n *\n * @param {Cartesian3[]} positions List of points that the bounding box will enclose.  Each point must have a <code>x</code>, <code>y</code>, and <code>z</code> properties.\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\n *\n * @example\n * // Compute an axis aligned bounding box enclosing two points.\n * var box = Cesium.AxisAlignedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\n */\n\n\nAxisAlignedBoundingBox.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new AxisAlignedBoundingBox();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.minimum = Cartesian3.clone(Cartesian3.ZERO, result.minimum);\n    result.maximum = Cartesian3.clone(Cartesian3.ZERO, result.maximum);\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    return result;\n  }\n\n  var minimumX = positions[0].x;\n  var minimumY = positions[0].y;\n  var minimumZ = positions[0].z;\n  var maximumX = positions[0].x;\n  var maximumY = positions[0].y;\n  var maximumZ = positions[0].z;\n  var length = positions.length;\n\n  for (var i = 1; i < length; i++) {\n    var p = positions[i];\n    var x = p.x;\n    var y = p.y;\n    var z = p.z;\n    minimumX = Math.min(x, minimumX);\n    maximumX = Math.max(x, maximumX);\n    minimumY = Math.min(y, minimumY);\n    maximumY = Math.max(y, maximumY);\n    minimumZ = Math.min(z, minimumZ);\n    maximumZ = Math.max(z, maximumZ);\n  }\n\n  var minimum = result.minimum;\n  minimum.x = minimumX;\n  minimum.y = minimumY;\n  minimum.z = minimumZ;\n  var maximum = result.maximum;\n  maximum.x = maximumX;\n  maximum.y = maximumY;\n  maximum.z = maximumZ;\n  result.center = Cartesian3.midpoint(minimum, maximum, result.center);\n  return result;\n};\n/**\n * Duplicates a AxisAlignedBoundingBox instance.\n *\n * @param {AxisAlignedBoundingBox} box The bounding box to duplicate.\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\n */\n\n\nAxisAlignedBoundingBox.clone = function (box, result) {\n  if (!defined(box)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new AxisAlignedBoundingBox(box.minimum, box.maximum, box.center);\n  }\n\n  result.minimum = Cartesian3.clone(box.minimum, result.minimum);\n  result.maximum = Cartesian3.clone(box.maximum, result.maximum);\n  result.center = Cartesian3.clone(box.center, result.center);\n  return result;\n};\n/**\n * Compares the provided AxisAlignedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {AxisAlignedBoundingBox} [left] The first AxisAlignedBoundingBox.\n * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\n\n\nAxisAlignedBoundingBox.equals = function (left, right) {\n  return left === right || defined(left) && defined(right) && Cartesian3.equals(left.center, right.center) && Cartesian3.equals(left.minimum, right.minimum) && Cartesian3.equals(left.maximum, right.maximum);\n};\n\nvar intersectScratch = new Cartesian3();\n/**\n * Determines which side of a plane a box is located.\n *\n * @param {AxisAlignedBoundingBox} box The bounding box to test.\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\n\nAxisAlignedBoundingBox.intersectPlane = function (box, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"box\", box);\n  Check.defined(\"plane\", plane); //>>includeEnd('debug');\n\n  intersectScratch = Cartesian3.subtract(box.maximum, box.minimum, intersectScratch);\n  var h = Cartesian3.multiplyByScalar(intersectScratch, 0.5, intersectScratch); //The positive half diagonal\n\n  var normal = plane.normal;\n  var e = h.x * Math.abs(normal.x) + h.y * Math.abs(normal.y) + h.z * Math.abs(normal.z);\n  var s = Cartesian3.dot(box.center, normal) + plane.distance; //signed distance from center\n\n  if (s - e > 0) {\n    return Intersect.INSIDE;\n  }\n\n  if (s + e < 0) {\n    //Not in front because normals point inward\n    return Intersect.OUTSIDE;\n  }\n\n  return Intersect.INTERSECTING;\n};\n/**\n * Duplicates this AxisAlignedBoundingBox instance.\n *\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\n */\n\n\nAxisAlignedBoundingBox.prototype.clone = function (result) {\n  return AxisAlignedBoundingBox.clone(this, result);\n};\n/**\n * Determines which side of a plane this box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\n\n\nAxisAlignedBoundingBox.prototype.intersectPlane = function (plane) {\n  return AxisAlignedBoundingBox.intersectPlane(this, plane);\n};\n/**\n * Compares this AxisAlignedBoundingBox against the provided AxisAlignedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {AxisAlignedBoundingBox} [right] The right hand side AxisAlignedBoundingBox.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\n\n\nAxisAlignedBoundingBox.prototype.equals = function (right) {\n  return AxisAlignedBoundingBox.equals(this, right);\n};\n\nexport default AxisAlignedBoundingBox;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/AxisAlignedBoundingBox.js"],"names":["Cartesian3","Check","defaultValue","defined","Intersect","AxisAlignedBoundingBox","minimum","maximum","center","clone","ZERO","midpoint","fromPoints","positions","result","length","minimumX","x","minimumY","y","minimumZ","z","maximumX","maximumY","maximumZ","i","p","Math","min","max","box","undefined","equals","left","right","intersectScratch","intersectPlane","plane","subtract","h","multiplyByScalar","normal","e","abs","s","dot","distance","INSIDE","OUTSIDE","INTERSECTING","prototype"],"mappings":"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","sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Intersect from \"./Intersect.js\";\n\n/**\n * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.\n * @alias AxisAlignedBoundingBox\n * @constructor\n *\n * @param {Cartesian3} [minimum=Cartesian3.ZERO] The minimum point along the x, y, and z axes.\n * @param {Cartesian3} [maximum=Cartesian3.ZERO] The maximum point along the x, y, and z axes.\n * @param {Cartesian3} [center] The center of the box; automatically computed if not supplied.\n *\n * @see BoundingSphere\n * @see BoundingRectangle\n */\nfunction AxisAlignedBoundingBox(minimum, maximum, center) {\n  /**\n   * The minimum point defining the bounding box.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.minimum = Cartesian3.clone(defaultValue(minimum, Cartesian3.ZERO));\n\n  /**\n   * The maximum point defining the bounding box.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.maximum = Cartesian3.clone(defaultValue(maximum, Cartesian3.ZERO));\n\n  //If center was not defined, compute it.\n  if (!defined(center)) {\n    center = Cartesian3.midpoint(this.minimum, this.maximum, new Cartesian3());\n  } else {\n    center = Cartesian3.clone(center);\n  }\n\n  /**\n   * The center point of the bounding box.\n   * @type {Cartesian3}\n   */\n  this.center = center;\n}\n\n/**\n * Computes an instance of an AxisAlignedBoundingBox. The box is determined by\n * finding the points spaced the farthest apart on the x, y, and z axes.\n *\n * @param {Cartesian3[]} positions List of points that the bounding box will enclose.  Each point must have a <code>x</code>, <code>y</code>, and <code>z</code> properties.\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\n *\n * @example\n * // Compute an axis aligned bounding box enclosing two points.\n * var box = Cesium.AxisAlignedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\n */\nAxisAlignedBoundingBox.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new AxisAlignedBoundingBox();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.minimum = Cartesian3.clone(Cartesian3.ZERO, result.minimum);\n    result.maximum = Cartesian3.clone(Cartesian3.ZERO, result.maximum);\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    return result;\n  }\n\n  var minimumX = positions[0].x;\n  var minimumY = positions[0].y;\n  var minimumZ = positions[0].z;\n\n  var maximumX = positions[0].x;\n  var maximumY = positions[0].y;\n  var maximumZ = positions[0].z;\n\n  var length = positions.length;\n  for (var i = 1; i < length; i++) {\n    var p = positions[i];\n    var x = p.x;\n    var y = p.y;\n    var z = p.z;\n\n    minimumX = Math.min(x, minimumX);\n    maximumX = Math.max(x, maximumX);\n    minimumY = Math.min(y, minimumY);\n    maximumY = Math.max(y, maximumY);\n    minimumZ = Math.min(z, minimumZ);\n    maximumZ = Math.max(z, maximumZ);\n  }\n\n  var minimum = result.minimum;\n  minimum.x = minimumX;\n  minimum.y = minimumY;\n  minimum.z = minimumZ;\n\n  var maximum = result.maximum;\n  maximum.x = maximumX;\n  maximum.y = maximumY;\n  maximum.z = maximumZ;\n\n  result.center = Cartesian3.midpoint(minimum, maximum, result.center);\n\n  return result;\n};\n\n/**\n * Duplicates a AxisAlignedBoundingBox instance.\n *\n * @param {AxisAlignedBoundingBox} box The bounding box to duplicate.\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\n */\nAxisAlignedBoundingBox.clone = function (box, result) {\n  if (!defined(box)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new AxisAlignedBoundingBox(box.minimum, box.maximum, box.center);\n  }\n\n  result.minimum = Cartesian3.clone(box.minimum, result.minimum);\n  result.maximum = Cartesian3.clone(box.maximum, result.maximum);\n  result.center = Cartesian3.clone(box.center, result.center);\n  return result;\n};\n\n/**\n * Compares the provided AxisAlignedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {AxisAlignedBoundingBox} [left] The first AxisAlignedBoundingBox.\n * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nAxisAlignedBoundingBox.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Cartesian3.equals(left.center, right.center) &&\n      Cartesian3.equals(left.minimum, right.minimum) &&\n      Cartesian3.equals(left.maximum, right.maximum))\n  );\n};\n\nvar intersectScratch = new Cartesian3();\n/**\n * Determines which side of a plane a box is located.\n *\n * @param {AxisAlignedBoundingBox} box The bounding box to test.\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nAxisAlignedBoundingBox.intersectPlane = function (box, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"box\", box);\n  Check.defined(\"plane\", plane);\n  //>>includeEnd('debug');\n\n  intersectScratch = Cartesian3.subtract(\n    box.maximum,\n    box.minimum,\n    intersectScratch\n  );\n  var h = Cartesian3.multiplyByScalar(intersectScratch, 0.5, intersectScratch); //The positive half diagonal\n  var normal = plane.normal;\n  var e =\n    h.x * Math.abs(normal.x) +\n    h.y * Math.abs(normal.y) +\n    h.z * Math.abs(normal.z);\n  var s = Cartesian3.dot(box.center, normal) + plane.distance; //signed distance from center\n\n  if (s - e > 0) {\n    return Intersect.INSIDE;\n  }\n\n  if (s + e < 0) {\n    //Not in front because normals point inward\n    return Intersect.OUTSIDE;\n  }\n\n  return Intersect.INTERSECTING;\n};\n\n/**\n * Duplicates this AxisAlignedBoundingBox instance.\n *\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\n */\nAxisAlignedBoundingBox.prototype.clone = function (result) {\n  return AxisAlignedBoundingBox.clone(this, result);\n};\n\n/**\n * Determines which side of a plane this box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nAxisAlignedBoundingBox.prototype.intersectPlane = function (plane) {\n  return AxisAlignedBoundingBox.intersectPlane(this, plane);\n};\n\n/**\n * Compares this AxisAlignedBoundingBox against the provided AxisAlignedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {AxisAlignedBoundingBox} [right] The right hand side AxisAlignedBoundingBox.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nAxisAlignedBoundingBox.prototype.equals = function (right) {\n  return AxisAlignedBoundingBox.equals(this, right);\n};\nexport default AxisAlignedBoundingBox;\n"]},"metadata":{},"sourceType":"module"}