{"ast":null,"code":"import AttributeCompression from \"./AttributeCompression.js\";\nimport barycentricCoordinates from \"./barycentricCoordinates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport EncodedCartesian3 from \"./EncodedCartesian3.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryType from \"./GeometryType.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport Intersect from \"./Intersect.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Tipsify from \"./Tipsify.js\";\n/**\n * Content pipeline functions for geometries.\n *\n * @exports GeometryPipeline\n *\n * @see Geometry\n */\n\nvar GeometryPipeline = {};\n\nfunction addTriangle(lines, index, i0, i1, i2) {\n  lines[index++] = i0;\n  lines[index++] = i1;\n  lines[index++] = i1;\n  lines[index++] = i2;\n  lines[index++] = i2;\n  lines[index] = i0;\n}\n\nfunction trianglesToLines(triangles) {\n  var count = triangles.length;\n  var size = count / 3 * 6;\n  var lines = IndexDatatype.createTypedArray(count, size);\n  var index = 0;\n\n  for (var i = 0; i < count; i += 3, index += 6) {\n    addTriangle(lines, index, triangles[i], triangles[i + 1], triangles[i + 2]);\n  }\n\n  return lines;\n}\n\nfunction triangleStripToLines(triangles) {\n  var count = triangles.length;\n\n  if (count >= 3) {\n    var size = (count - 2) * 6;\n    var lines = IndexDatatype.createTypedArray(count, size);\n    addTriangle(lines, 0, triangles[0], triangles[1], triangles[2]);\n    var index = 6;\n\n    for (var i = 3; i < count; ++i, index += 6) {\n      addTriangle(lines, index, triangles[i - 1], triangles[i], triangles[i - 2]);\n    }\n\n    return lines;\n  }\n\n  return new Uint16Array();\n}\n\nfunction triangleFanToLines(triangles) {\n  if (triangles.length > 0) {\n    var count = triangles.length - 1;\n    var size = (count - 1) * 6;\n    var lines = IndexDatatype.createTypedArray(count, size);\n    var base = triangles[0];\n    var index = 0;\n\n    for (var i = 1; i < count; ++i, index += 6) {\n      addTriangle(lines, index, base, triangles[i], triangles[i + 1]);\n    }\n\n    return lines;\n  }\n\n  return new Uint16Array();\n}\n/**\n * Converts a geometry's triangle indices to line indices.  If the geometry has an <code>indices</code>\n * and its <code>primitiveType</code> is <code>TRIANGLES</code>, <code>TRIANGLE_STRIP</code>,\n * <code>TRIANGLE_FAN</code>, it is converted to <code>LINES</code>; otherwise, the geometry is not changed.\n * <p>\n * This is commonly used to create a wireframe geometry for visual debugging.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its triangle indices converted to lines.\n *\n * @exception {DeveloperError} geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.toWireframe(geometry);\n */\n\n\nGeometryPipeline.toWireframe = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  } //>>includeEnd('debug');\n\n\n  var indices = geometry.indices;\n\n  if (defined(indices)) {\n    switch (geometry.primitiveType) {\n      case PrimitiveType.TRIANGLES:\n        geometry.indices = trianglesToLines(indices);\n        break;\n\n      case PrimitiveType.TRIANGLE_STRIP:\n        geometry.indices = triangleStripToLines(indices);\n        break;\n\n      case PrimitiveType.TRIANGLE_FAN:\n        geometry.indices = triangleFanToLines(indices);\n        break;\n      //>>includeStart('debug', pragmas.debug);\n\n      default:\n        throw new DeveloperError(\"geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.\");\n      //>>includeEnd('debug');\n    }\n\n    geometry.primitiveType = PrimitiveType.LINES;\n  }\n\n  return geometry;\n};\n/**\n * Creates a new {@link Geometry} with <code>LINES</code> representing the provided\n * attribute (<code>attributeName</code>) for the provided geometry.  This is used to\n * visualize vector attributes like normals, tangents, and bitangents.\n *\n * @param {Geometry} geometry The <code>Geometry</code> instance with the attribute.\n * @param {String} [attributeName='normal'] The name of the attribute.\n * @param {Number} [length=10000.0] The length of each line segment in meters.  This can be negative to point the vector in the opposite direction.\n * @returns {Geometry} A new <code>Geometry</code> instance with line segments for the vector.\n *\n * @exception {DeveloperError} geometry.attributes must have an attribute with the same name as the attributeName parameter.\n *\n * @example\n * var geometry = Cesium.GeometryPipeline.createLineSegmentsForVectors(instance.geometry, 'bitangent', 100000.0);\n */\n\n\nGeometryPipeline.createLineSegmentsForVectors = function (geometry, attributeName, length) {\n  attributeName = defaultValue(attributeName, \"normal\"); //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n\n  if (!defined(geometry.attributes.position)) {\n    throw new DeveloperError(\"geometry.attributes.position is required.\");\n  }\n\n  if (!defined(geometry.attributes[attributeName])) {\n    throw new DeveloperError(\"geometry.attributes must have an attribute with the same name as the attributeName parameter, \" + attributeName + \".\");\n  } //>>includeEnd('debug');\n\n\n  length = defaultValue(length, 10000.0);\n  var positions = geometry.attributes.position.values;\n  var vectors = geometry.attributes[attributeName].values;\n  var positionsLength = positions.length;\n  var newPositions = new Float64Array(2 * positionsLength);\n  var j = 0;\n\n  for (var i = 0; i < positionsLength; i += 3) {\n    newPositions[j++] = positions[i];\n    newPositions[j++] = positions[i + 1];\n    newPositions[j++] = positions[i + 2];\n    newPositions[j++] = positions[i] + vectors[i] * length;\n    newPositions[j++] = positions[i + 1] + vectors[i + 1] * length;\n    newPositions[j++] = positions[i + 2] + vectors[i + 2] * length;\n  }\n\n  var newBoundingSphere;\n  var bs = geometry.boundingSphere;\n\n  if (defined(bs)) {\n    newBoundingSphere = new BoundingSphere(bs.center, bs.radius + length);\n  }\n\n  return new Geometry({\n    attributes: {\n      position: new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: newPositions\n      })\n    },\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: newBoundingSphere\n  });\n};\n/**\n * Creates an object that maps attribute names to unique locations (indices)\n * for matching vertex attributes and shader programs.\n *\n * @param {Geometry} geometry The geometry, which is not modified, to create the object for.\n * @returns {Object} An object with attribute name / index pairs.\n *\n * @example\n * var attributeLocations = Cesium.GeometryPipeline.createAttributeLocations(geometry);\n * // Example output\n * // {\n * //   'position' : 0,\n * //   'normal' : 1\n * // }\n */\n\n\nGeometryPipeline.createAttributeLocations = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  } //>>includeEnd('debug')\n  // There can be a WebGL performance hit when attribute 0 is disabled, so\n  // assign attribute locations to well-known attributes.\n\n\n  var semantics = [\"position\", \"positionHigh\", \"positionLow\", // From VertexFormat.position - after 2D projection and high-precision encoding\n  \"position3DHigh\", \"position3DLow\", \"position2DHigh\", \"position2DLow\", // From Primitive\n  \"pickColor\", // From VertexFormat\n  \"normal\", \"st\", \"tangent\", \"bitangent\", // For shadow volumes\n  \"extrudeDirection\", // From compressing texture coordinates and normals\n  \"compressedAttributes\"];\n  var attributes = geometry.attributes;\n  var indices = {};\n  var j = 0;\n  var i;\n  var len = semantics.length; // Attribute locations for well-known attributes\n\n  for (i = 0; i < len; ++i) {\n    var semantic = semantics[i];\n\n    if (defined(attributes[semantic])) {\n      indices[semantic] = j++;\n    }\n  } // Locations for custom attributes\n\n\n  for (var name in attributes) {\n    if (attributes.hasOwnProperty(name) && !defined(indices[name])) {\n      indices[name] = j++;\n    }\n  }\n\n  return indices;\n};\n/**\n * Reorders a geometry's attributes and <code>indices</code> to achieve better performance from the GPU's pre-vertex-shader cache.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its attributes and indices reordered for the GPU's pre-vertex-shader cache.\n *\n * @exception {DeveloperError} Each attribute array in geometry.attributes must have the same number of attributes.\n *\n *\n * @example\n * geometry = Cesium.GeometryPipeline.reorderForPreVertexCache(geometry);\n *\n * @see GeometryPipeline.reorderForPostVertexCache\n */\n\n\nGeometryPipeline.reorderForPreVertexCache = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  } //>>includeEnd('debug');\n\n\n  var numVertices = Geometry.computeNumberOfVertices(geometry);\n  var indices = geometry.indices;\n\n  if (defined(indices)) {\n    var indexCrossReferenceOldToNew = new Int32Array(numVertices);\n\n    for (var i = 0; i < numVertices; i++) {\n      indexCrossReferenceOldToNew[i] = -1;\n    } // Construct cross reference and reorder indices\n\n\n    var indicesIn = indices;\n    var numIndices = indicesIn.length;\n    var indicesOut = IndexDatatype.createTypedArray(numVertices, numIndices);\n    var intoIndicesIn = 0;\n    var intoIndicesOut = 0;\n    var nextIndex = 0;\n    var tempIndex;\n\n    while (intoIndicesIn < numIndices) {\n      tempIndex = indexCrossReferenceOldToNew[indicesIn[intoIndicesIn]];\n\n      if (tempIndex !== -1) {\n        indicesOut[intoIndicesOut] = tempIndex;\n      } else {\n        tempIndex = indicesIn[intoIndicesIn];\n        indexCrossReferenceOldToNew[tempIndex] = nextIndex;\n        indicesOut[intoIndicesOut] = nextIndex;\n        ++nextIndex;\n      }\n\n      ++intoIndicesIn;\n      ++intoIndicesOut;\n    }\n\n    geometry.indices = indicesOut; // Reorder attributes\n\n    var attributes = geometry.attributes;\n\n    for (var property in attributes) {\n      if (attributes.hasOwnProperty(property) && defined(attributes[property]) && defined(attributes[property].values)) {\n        var attribute = attributes[property];\n        var elementsIn = attribute.values;\n        var intoElementsIn = 0;\n        var numComponents = attribute.componentsPerAttribute;\n        var elementsOut = ComponentDatatype.createTypedArray(attribute.componentDatatype, nextIndex * numComponents);\n\n        while (intoElementsIn < numVertices) {\n          var temp = indexCrossReferenceOldToNew[intoElementsIn];\n\n          if (temp !== -1) {\n            for (var j = 0; j < numComponents; j++) {\n              elementsOut[numComponents * temp + j] = elementsIn[numComponents * intoElementsIn + j];\n            }\n          }\n\n          ++intoElementsIn;\n        }\n\n        attribute.values = elementsOut;\n      }\n    }\n  }\n\n  return geometry;\n};\n/**\n * Reorders a geometry's <code>indices</code> to achieve better performance from the GPU's\n * post vertex-shader cache by using the Tipsify algorithm.  If the geometry <code>primitiveType</code>\n * is not <code>TRIANGLES</code> or the geometry does not have an <code>indices</code>, this function has no effect.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @param {Number} [cacheCapacity=24] The number of vertices that can be held in the GPU's vertex cache.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its indices reordered for the post-vertex-shader cache.\n *\n * @exception {DeveloperError} cacheCapacity must be greater than two.\n *\n *\n * @example\n * geometry = Cesium.GeometryPipeline.reorderForPostVertexCache(geometry);\n *\n * @see GeometryPipeline.reorderForPreVertexCache\n * @see {@link http://gfx.cs.princ0eton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf|Fast Triangle Reordering for Vertex Locality and Reduced Overdraw}\n * by Sander, Nehab, and Barczak\n */\n\n\nGeometryPipeline.reorderForPostVertexCache = function (geometry, cacheCapacity) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  } //>>includeEnd('debug');\n\n\n  var indices = geometry.indices;\n\n  if (geometry.primitiveType === PrimitiveType.TRIANGLES && defined(indices)) {\n    var numIndices = indices.length;\n    var maximumIndex = 0;\n\n    for (var j = 0; j < numIndices; j++) {\n      if (indices[j] > maximumIndex) {\n        maximumIndex = indices[j];\n      }\n    }\n\n    geometry.indices = Tipsify.tipsify({\n      indices: indices,\n      maximumIndex: maximumIndex,\n      cacheSize: cacheCapacity\n    });\n  }\n\n  return geometry;\n};\n\nfunction copyAttributesDescriptions(attributes) {\n  var newAttributes = {};\n\n  for (var attribute in attributes) {\n    if (attributes.hasOwnProperty(attribute) && defined(attributes[attribute]) && defined(attributes[attribute].values)) {\n      var attr = attributes[attribute];\n      newAttributes[attribute] = new GeometryAttribute({\n        componentDatatype: attr.componentDatatype,\n        componentsPerAttribute: attr.componentsPerAttribute,\n        normalize: attr.normalize,\n        values: []\n      });\n    }\n  }\n\n  return newAttributes;\n}\n\nfunction copyVertex(destinationAttributes, sourceAttributes, index) {\n  for (var attribute in sourceAttributes) {\n    if (sourceAttributes.hasOwnProperty(attribute) && defined(sourceAttributes[attribute]) && defined(sourceAttributes[attribute].values)) {\n      var attr = sourceAttributes[attribute];\n\n      for (var k = 0; k < attr.componentsPerAttribute; ++k) {\n        destinationAttributes[attribute].values.push(attr.values[index * attr.componentsPerAttribute + k]);\n      }\n    }\n  }\n}\n/**\n * Splits a geometry into multiple geometries, if necessary, to ensure that indices in the\n * <code>indices</code> fit into unsigned shorts.  This is used to meet the WebGL requirements\n * when unsigned int indices are not supported.\n * <p>\n * If the geometry does not have any <code>indices</code>, this function has no effect.\n * </p>\n *\n * @param {Geometry} geometry The geometry to be split into multiple geometries.\n * @returns {Geometry[]} An array of geometries, each with indices that fit into unsigned shorts.\n *\n * @exception {DeveloperError} geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS\n * @exception {DeveloperError} All geometry attribute lists must have the same number of attributes.\n *\n * @example\n * var geometries = Cesium.GeometryPipeline.fitToUnsignedShortIndices(geometry);\n */\n\n\nGeometryPipeline.fitToUnsignedShortIndices = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n\n  if (defined(geometry.indices) && geometry.primitiveType !== PrimitiveType.TRIANGLES && geometry.primitiveType !== PrimitiveType.LINES && geometry.primitiveType !== PrimitiveType.POINTS) {\n    throw new DeveloperError(\"geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS.\");\n  } //>>includeEnd('debug');\n\n\n  var geometries = []; // If there's an index list and more than 64K attributes, it is possible that\n  // some indices are outside the range of unsigned short [0, 64K - 1]\n\n  var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  if (defined(geometry.indices) && numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES) {\n    var oldToNewIndex = [];\n    var newIndices = [];\n    var currentIndex = 0;\n    var newAttributes = copyAttributesDescriptions(geometry.attributes);\n    var originalIndices = geometry.indices;\n    var numberOfIndices = originalIndices.length;\n    var indicesPerPrimitive;\n\n    if (geometry.primitiveType === PrimitiveType.TRIANGLES) {\n      indicesPerPrimitive = 3;\n    } else if (geometry.primitiveType === PrimitiveType.LINES) {\n      indicesPerPrimitive = 2;\n    } else if (geometry.primitiveType === PrimitiveType.POINTS) {\n      indicesPerPrimitive = 1;\n    }\n\n    for (var j = 0; j < numberOfIndices; j += indicesPerPrimitive) {\n      for (var k = 0; k < indicesPerPrimitive; ++k) {\n        var x = originalIndices[j + k];\n        var i = oldToNewIndex[x];\n\n        if (!defined(i)) {\n          i = currentIndex++;\n          oldToNewIndex[x] = i;\n          copyVertex(newAttributes, geometry.attributes, x);\n        }\n\n        newIndices.push(i);\n      }\n\n      if (currentIndex + indicesPerPrimitive >= CesiumMath.SIXTY_FOUR_KILOBYTES) {\n        geometries.push(new Geometry({\n          attributes: newAttributes,\n          indices: newIndices,\n          primitiveType: geometry.primitiveType,\n          boundingSphere: geometry.boundingSphere,\n          boundingSphereCV: geometry.boundingSphereCV\n        })); // Reset for next vertex-array\n\n        oldToNewIndex = [];\n        newIndices = [];\n        currentIndex = 0;\n        newAttributes = copyAttributesDescriptions(geometry.attributes);\n      }\n    }\n\n    if (newIndices.length !== 0) {\n      geometries.push(new Geometry({\n        attributes: newAttributes,\n        indices: newIndices,\n        primitiveType: geometry.primitiveType,\n        boundingSphere: geometry.boundingSphere,\n        boundingSphereCV: geometry.boundingSphereCV\n      }));\n    }\n  } else {\n    // No need to split into multiple geometries\n    geometries.push(geometry);\n  }\n\n  return geometries;\n};\n\nvar scratchProjectTo2DCartesian3 = new Cartesian3();\nvar scratchProjectTo2DCartographic = new Cartographic();\n/**\n * Projects a geometry's 3D <code>position</code> attribute to 2D, replacing the <code>position</code>\n * attribute with separate <code>position3D</code> and <code>position2D</code> attributes.\n * <p>\n * If the geometry does not have a <code>position</code>, this function has no effect.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @param {String} attributeName The name of the attribute.\n * @param {String} attributeName3D The name of the attribute in 3D.\n * @param {String} attributeName2D The name of the attribute in 2D.\n * @param {Object} [projection=new GeographicProjection()] The projection to use.\n * @returns {Geometry} The modified <code>geometry</code> argument with <code>position3D</code> and <code>position2D</code> attributes.\n *\n * @exception {DeveloperError} geometry must have attribute matching the attributeName argument.\n * @exception {DeveloperError} The attribute componentDatatype must be ComponentDatatype.DOUBLE.\n * @exception {DeveloperError} Could not project a point to 2D.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.projectTo2D(geometry, 'position', 'position3D', 'position2D');\n */\n\nGeometryPipeline.projectTo2D = function (geometry, attributeName, attributeName3D, attributeName2D, projection) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n\n  if (!defined(attributeName)) {\n    throw new DeveloperError(\"attributeName is required.\");\n  }\n\n  if (!defined(attributeName3D)) {\n    throw new DeveloperError(\"attributeName3D is required.\");\n  }\n\n  if (!defined(attributeName2D)) {\n    throw new DeveloperError(\"attributeName2D is required.\");\n  }\n\n  if (!defined(geometry.attributes[attributeName])) {\n    throw new DeveloperError(\"geometry must have attribute matching the attributeName argument: \" + attributeName + \".\");\n  }\n\n  if (geometry.attributes[attributeName].componentDatatype !== ComponentDatatype.DOUBLE) {\n    throw new DeveloperError(\"The attribute componentDatatype must be ComponentDatatype.DOUBLE.\");\n  } //>>includeEnd('debug');\n\n\n  var attribute = geometry.attributes[attributeName];\n  projection = defined(projection) ? projection : new GeographicProjection();\n  var ellipsoid = projection.ellipsoid; // Project original values to 2D.\n\n  var values3D = attribute.values;\n  var projectedValues = new Float64Array(values3D.length);\n  var index = 0;\n\n  for (var i = 0; i < values3D.length; i += 3) {\n    var value = Cartesian3.fromArray(values3D, i, scratchProjectTo2DCartesian3);\n    var lonLat = ellipsoid.cartesianToCartographic(value, scratchProjectTo2DCartographic); //>>includeStart('debug', pragmas.debug);\n\n    if (!defined(lonLat)) {\n      throw new DeveloperError(\"Could not project point (\" + value.x + \", \" + value.y + \", \" + value.z + \") to 2D.\");\n    } //>>includeEnd('debug');\n\n\n    var projectedLonLat = projection.project(lonLat, scratchProjectTo2DCartesian3);\n    projectedValues[index++] = projectedLonLat.x;\n    projectedValues[index++] = projectedLonLat.y;\n    projectedValues[index++] = projectedLonLat.z;\n  } // Rename original cartesians to WGS84 cartesians.\n\n\n  geometry.attributes[attributeName3D] = attribute; // Replace original cartesians with 2D projected cartesians\n\n  geometry.attributes[attributeName2D] = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: projectedValues\n  });\n  delete geometry.attributes[attributeName];\n  return geometry;\n};\n\nvar encodedResult = {\n  high: 0.0,\n  low: 0.0\n};\n/**\n * Encodes floating-point geometry attribute values as two separate attributes to improve\n * rendering precision.\n * <p>\n * This is commonly used to create high-precision position vertex attributes.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @param {String} attributeName The name of the attribute.\n * @param {String} attributeHighName The name of the attribute for the encoded high bits.\n * @param {String} attributeLowName The name of the attribute for the encoded low bits.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its encoded attribute.\n *\n * @exception {DeveloperError} geometry must have attribute matching the attributeName argument.\n * @exception {DeveloperError} The attribute componentDatatype must be ComponentDatatype.DOUBLE.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.encodeAttribute(geometry, 'position3D', 'position3DHigh', 'position3DLow');\n */\n\nGeometryPipeline.encodeAttribute = function (geometry, attributeName, attributeHighName, attributeLowName) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n\n  if (!defined(attributeName)) {\n    throw new DeveloperError(\"attributeName is required.\");\n  }\n\n  if (!defined(attributeHighName)) {\n    throw new DeveloperError(\"attributeHighName is required.\");\n  }\n\n  if (!defined(attributeLowName)) {\n    throw new DeveloperError(\"attributeLowName is required.\");\n  }\n\n  if (!defined(geometry.attributes[attributeName])) {\n    throw new DeveloperError(\"geometry must have attribute matching the attributeName argument: \" + attributeName + \".\");\n  }\n\n  if (geometry.attributes[attributeName].componentDatatype !== ComponentDatatype.DOUBLE) {\n    throw new DeveloperError(\"The attribute componentDatatype must be ComponentDatatype.DOUBLE.\");\n  } //>>includeEnd('debug');\n\n\n  var attribute = geometry.attributes[attributeName];\n  var values = attribute.values;\n  var length = values.length;\n  var highValues = new Float32Array(length);\n  var lowValues = new Float32Array(length);\n\n  for (var i = 0; i < length; ++i) {\n    EncodedCartesian3.encode(values[i], encodedResult);\n    highValues[i] = encodedResult.high;\n    lowValues[i] = encodedResult.low;\n  }\n\n  var componentsPerAttribute = attribute.componentsPerAttribute;\n  geometry.attributes[attributeHighName] = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: componentsPerAttribute,\n    values: highValues\n  });\n  geometry.attributes[attributeLowName] = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: componentsPerAttribute,\n    values: lowValues\n  });\n  delete geometry.attributes[attributeName];\n  return geometry;\n};\n\nvar scratchCartesian3 = new Cartesian3();\n\nfunction transformPoint(matrix, attribute) {\n  if (defined(attribute)) {\n    var values = attribute.values;\n    var length = values.length;\n\n    for (var i = 0; i < length; i += 3) {\n      Cartesian3.unpack(values, i, scratchCartesian3);\n      Matrix4.multiplyByPoint(matrix, scratchCartesian3, scratchCartesian3);\n      Cartesian3.pack(scratchCartesian3, values, i);\n    }\n  }\n}\n\nfunction transformVector(matrix, attribute) {\n  if (defined(attribute)) {\n    var values = attribute.values;\n    var length = values.length;\n\n    for (var i = 0; i < length; i += 3) {\n      Cartesian3.unpack(values, i, scratchCartesian3);\n      Matrix3.multiplyByVector(matrix, scratchCartesian3, scratchCartesian3);\n      scratchCartesian3 = Cartesian3.normalize(scratchCartesian3, scratchCartesian3);\n      Cartesian3.pack(scratchCartesian3, values, i);\n    }\n  }\n}\n\nvar inverseTranspose = new Matrix4();\nvar normalMatrix = new Matrix3();\n/**\n * Transforms a geometry instance to world coordinates.  This changes\n * the instance's <code>modelMatrix</code> to {@link Matrix4.IDENTITY} and transforms the\n * following attributes if they are present: <code>position</code>, <code>normal</code>,\n * <code>tangent</code>, and <code>bitangent</code>.\n *\n * @param {GeometryInstance} instance The geometry instance to modify.\n * @returns {GeometryInstance} The modified <code>instance</code> argument, with its attributes transforms to world coordinates.\n *\n * @example\n * Cesium.GeometryPipeline.transformToWorldCoordinates(instance);\n */\n\nGeometryPipeline.transformToWorldCoordinates = function (instance) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(instance)) {\n    throw new DeveloperError(\"instance is required.\");\n  } //>>includeEnd('debug');\n\n\n  var modelMatrix = instance.modelMatrix;\n\n  if (Matrix4.equals(modelMatrix, Matrix4.IDENTITY)) {\n    // Already in world coordinates\n    return instance;\n  }\n\n  var attributes = instance.geometry.attributes; // Transform attributes in known vertex formats\n\n  transformPoint(modelMatrix, attributes.position);\n  transformPoint(modelMatrix, attributes.prevPosition);\n  transformPoint(modelMatrix, attributes.nextPosition);\n\n  if (defined(attributes.normal) || defined(attributes.tangent) || defined(attributes.bitangent)) {\n    Matrix4.inverse(modelMatrix, inverseTranspose);\n    Matrix4.transpose(inverseTranspose, inverseTranspose);\n    Matrix4.getMatrix3(inverseTranspose, normalMatrix);\n    transformVector(normalMatrix, attributes.normal);\n    transformVector(normalMatrix, attributes.tangent);\n    transformVector(normalMatrix, attributes.bitangent);\n  }\n\n  var boundingSphere = instance.geometry.boundingSphere;\n\n  if (defined(boundingSphere)) {\n    instance.geometry.boundingSphere = BoundingSphere.transform(boundingSphere, modelMatrix, boundingSphere);\n  }\n\n  instance.modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  return instance;\n};\n\nfunction findAttributesInAllGeometries(instances, propertyName) {\n  var length = instances.length;\n  var attributesInAllGeometries = {};\n  var attributes0 = instances[0][propertyName].attributes;\n  var name;\n\n  for (name in attributes0) {\n    if (attributes0.hasOwnProperty(name) && defined(attributes0[name]) && defined(attributes0[name].values)) {\n      var attribute = attributes0[name];\n      var numberOfComponents = attribute.values.length;\n      var inAllGeometries = true; // Does this same attribute exist in all geometries?\n\n      for (var i = 1; i < length; ++i) {\n        var otherAttribute = instances[i][propertyName].attributes[name];\n\n        if (!defined(otherAttribute) || attribute.componentDatatype !== otherAttribute.componentDatatype || attribute.componentsPerAttribute !== otherAttribute.componentsPerAttribute || attribute.normalize !== otherAttribute.normalize) {\n          inAllGeometries = false;\n          break;\n        }\n\n        numberOfComponents += otherAttribute.values.length;\n      }\n\n      if (inAllGeometries) {\n        attributesInAllGeometries[name] = new GeometryAttribute({\n          componentDatatype: attribute.componentDatatype,\n          componentsPerAttribute: attribute.componentsPerAttribute,\n          normalize: attribute.normalize,\n          values: ComponentDatatype.createTypedArray(attribute.componentDatatype, numberOfComponents)\n        });\n      }\n    }\n  }\n\n  return attributesInAllGeometries;\n}\n\nvar tempScratch = new Cartesian3();\n\nfunction combineGeometries(instances, propertyName) {\n  var length = instances.length;\n  var name;\n  var i;\n  var j;\n  var k;\n  var m = instances[0].modelMatrix;\n  var haveIndices = defined(instances[0][propertyName].indices);\n  var primitiveType = instances[0][propertyName].primitiveType; //>>includeStart('debug', pragmas.debug);\n\n  for (i = 1; i < length; ++i) {\n    if (!Matrix4.equals(instances[i].modelMatrix, m)) {\n      throw new DeveloperError(\"All instances must have the same modelMatrix.\");\n    }\n\n    if (defined(instances[i][propertyName].indices) !== haveIndices) {\n      throw new DeveloperError(\"All instance geometries must have an indices or not have one.\");\n    }\n\n    if (instances[i][propertyName].primitiveType !== primitiveType) {\n      throw new DeveloperError(\"All instance geometries must have the same primitiveType.\");\n    }\n  } //>>includeEnd('debug');\n  // Find subset of attributes in all geometries\n\n\n  var attributes = findAttributesInAllGeometries(instances, propertyName);\n  var values;\n  var sourceValues;\n  var sourceValuesLength; // Combine attributes from each geometry into a single typed array\n\n  for (name in attributes) {\n    if (attributes.hasOwnProperty(name)) {\n      values = attributes[name].values;\n      k = 0;\n\n      for (i = 0; i < length; ++i) {\n        sourceValues = instances[i][propertyName].attributes[name].values;\n        sourceValuesLength = sourceValues.length;\n\n        for (j = 0; j < sourceValuesLength; ++j) {\n          values[k++] = sourceValues[j];\n        }\n      }\n    }\n  } // Combine index lists\n\n\n  var indices;\n\n  if (haveIndices) {\n    var numberOfIndices = 0;\n\n    for (i = 0; i < length; ++i) {\n      numberOfIndices += instances[i][propertyName].indices.length;\n    }\n\n    var numberOfVertices = Geometry.computeNumberOfVertices(new Geometry({\n      attributes: attributes,\n      primitiveType: PrimitiveType.POINTS\n    }));\n    var destIndices = IndexDatatype.createTypedArray(numberOfVertices, numberOfIndices);\n    var destOffset = 0;\n    var offset = 0;\n\n    for (i = 0; i < length; ++i) {\n      var sourceIndices = instances[i][propertyName].indices;\n      var sourceIndicesLen = sourceIndices.length;\n\n      for (k = 0; k < sourceIndicesLen; ++k) {\n        destIndices[destOffset++] = offset + sourceIndices[k];\n      }\n\n      offset += Geometry.computeNumberOfVertices(instances[i][propertyName]);\n    }\n\n    indices = destIndices;\n  } // Create bounding sphere that includes all instances\n\n\n  var center = new Cartesian3();\n  var radius = 0.0;\n  var bs;\n\n  for (i = 0; i < length; ++i) {\n    bs = instances[i][propertyName].boundingSphere;\n\n    if (!defined(bs)) {\n      // If any geometries have an undefined bounding sphere, then so does the combined geometry\n      center = undefined;\n      break;\n    }\n\n    Cartesian3.add(bs.center, center, center);\n  }\n\n  if (defined(center)) {\n    Cartesian3.divideByScalar(center, length, center);\n\n    for (i = 0; i < length; ++i) {\n      bs = instances[i][propertyName].boundingSphere;\n      var tempRadius = Cartesian3.magnitude(Cartesian3.subtract(bs.center, center, tempScratch)) + bs.radius;\n\n      if (tempRadius > radius) {\n        radius = tempRadius;\n      }\n    }\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: primitiveType,\n    boundingSphere: defined(center) ? new BoundingSphere(center, radius) : undefined\n  });\n}\n/**\n * Combines geometry from several {@link GeometryInstance} objects into one geometry.\n * This concatenates the attributes, concatenates and adjusts the indices, and creates\n * a bounding sphere encompassing all instances.\n * <p>\n * If the instances do not have the same attributes, a subset of attributes common\n * to all instances is used, and the others are ignored.\n * </p>\n * <p>\n * This is used by {@link Primitive} to efficiently render a large amount of static data.\n * </p>\n *\n * @private\n *\n * @param {GeometryInstance[]} [instances] The array of {@link GeometryInstance} objects whose geometry will be combined.\n * @returns {Geometry} A single geometry created from the provided geometry instances.\n *\n * @exception {DeveloperError} All instances must have the same modelMatrix.\n * @exception {DeveloperError} All instance geometries must have an indices or not have one.\n * @exception {DeveloperError} All instance geometries must have the same primitiveType.\n *\n *\n * @example\n * for (var i = 0; i < instances.length; ++i) {\n *   Cesium.GeometryPipeline.transformToWorldCoordinates(instances[i]);\n * }\n * var geometries = Cesium.GeometryPipeline.combineInstances(instances);\n *\n * @see GeometryPipeline.transformToWorldCoordinates\n */\n\n\nGeometryPipeline.combineInstances = function (instances) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(instances) || instances.length < 1) {\n    throw new DeveloperError(\"instances is required and must have length greater than zero.\");\n  } //>>includeEnd('debug');\n\n\n  var instanceGeometry = [];\n  var instanceSplitGeometry = [];\n  var length = instances.length;\n\n  for (var i = 0; i < length; ++i) {\n    var instance = instances[i];\n\n    if (defined(instance.geometry)) {\n      instanceGeometry.push(instance);\n    } else if (defined(instance.westHemisphereGeometry) && defined(instance.eastHemisphereGeometry)) {\n      instanceSplitGeometry.push(instance);\n    }\n  }\n\n  var geometries = [];\n\n  if (instanceGeometry.length > 0) {\n    geometries.push(combineGeometries(instanceGeometry, \"geometry\"));\n  }\n\n  if (instanceSplitGeometry.length > 0) {\n    geometries.push(combineGeometries(instanceSplitGeometry, \"westHemisphereGeometry\"));\n    geometries.push(combineGeometries(instanceSplitGeometry, \"eastHemisphereGeometry\"));\n  }\n\n  return geometries;\n};\n\nvar normal = new Cartesian3();\nvar v0 = new Cartesian3();\nvar v1 = new Cartesian3();\nvar v2 = new Cartesian3();\n/**\n * Computes per-vertex normals for a geometry containing <code>TRIANGLES</code> by averaging the normals of\n * all triangles incident to the vertex.  The result is a new <code>normal</code> attribute added to the geometry.\n * This assumes a counter-clockwise winding order.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument with the computed <code>normal</code> attribute.\n *\n * @exception {DeveloperError} geometry.indices length must be greater than 0 and be a multiple of 3.\n * @exception {DeveloperError} geometry.primitiveType must be {@link PrimitiveType.TRIANGLES}.\n *\n * @example\n * Cesium.GeometryPipeline.computeNormal(geometry);\n */\n\nGeometryPipeline.computeNormal = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n\n  if (!defined(geometry.attributes.position) || !defined(geometry.attributes.position.values)) {\n    throw new DeveloperError(\"geometry.attributes.position.values is required.\");\n  }\n\n  if (!defined(geometry.indices)) {\n    throw new DeveloperError(\"geometry.indices is required.\");\n  }\n\n  if (geometry.indices.length < 2 || geometry.indices.length % 3 !== 0) {\n    throw new DeveloperError(\"geometry.indices length must be greater than 0 and be a multiple of 3.\");\n  }\n\n  if (geometry.primitiveType !== PrimitiveType.TRIANGLES) {\n    throw new DeveloperError(\"geometry.primitiveType must be PrimitiveType.TRIANGLES.\");\n  } //>>includeEnd('debug');\n\n\n  var indices = geometry.indices;\n  var attributes = geometry.attributes;\n  var vertices = attributes.position.values;\n  var numVertices = attributes.position.values.length / 3;\n  var numIndices = indices.length;\n  var normalsPerVertex = new Array(numVertices);\n  var normalsPerTriangle = new Array(numIndices / 3);\n  var normalIndices = new Array(numIndices);\n  var i;\n\n  for (i = 0; i < numVertices; i++) {\n    normalsPerVertex[i] = {\n      indexOffset: 0,\n      count: 0,\n      currentCount: 0\n    };\n  }\n\n  var j = 0;\n\n  for (i = 0; i < numIndices; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n    var i03 = i0 * 3;\n    var i13 = i1 * 3;\n    var i23 = i2 * 3;\n    v0.x = vertices[i03];\n    v0.y = vertices[i03 + 1];\n    v0.z = vertices[i03 + 2];\n    v1.x = vertices[i13];\n    v1.y = vertices[i13 + 1];\n    v1.z = vertices[i13 + 2];\n    v2.x = vertices[i23];\n    v2.y = vertices[i23 + 1];\n    v2.z = vertices[i23 + 2];\n    normalsPerVertex[i0].count++;\n    normalsPerVertex[i1].count++;\n    normalsPerVertex[i2].count++;\n    Cartesian3.subtract(v1, v0, v1);\n    Cartesian3.subtract(v2, v0, v2);\n    normalsPerTriangle[j] = Cartesian3.cross(v1, v2, new Cartesian3());\n    j++;\n  }\n\n  var indexOffset = 0;\n\n  for (i = 0; i < numVertices; i++) {\n    normalsPerVertex[i].indexOffset += indexOffset;\n    indexOffset += normalsPerVertex[i].count;\n  }\n\n  j = 0;\n  var vertexNormalData;\n\n  for (i = 0; i < numIndices; i += 3) {\n    vertexNormalData = normalsPerVertex[indices[i]];\n    var index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\n    normalIndices[index] = j;\n    vertexNormalData.currentCount++;\n    vertexNormalData = normalsPerVertex[indices[i + 1]];\n    index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\n    normalIndices[index] = j;\n    vertexNormalData.currentCount++;\n    vertexNormalData = normalsPerVertex[indices[i + 2]];\n    index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\n    normalIndices[index] = j;\n    vertexNormalData.currentCount++;\n    j++;\n  }\n\n  var normalValues = new Float32Array(numVertices * 3);\n\n  for (i = 0; i < numVertices; i++) {\n    var i3 = i * 3;\n    vertexNormalData = normalsPerVertex[i];\n    Cartesian3.clone(Cartesian3.ZERO, normal);\n\n    if (vertexNormalData.count > 0) {\n      for (j = 0; j < vertexNormalData.count; j++) {\n        Cartesian3.add(normal, normalsPerTriangle[normalIndices[vertexNormalData.indexOffset + j]], normal);\n      } // We can run into an issue where a vertex is used with 2 primitives that have opposite winding order.\n\n\n      if (Cartesian3.equalsEpsilon(Cartesian3.ZERO, normal, CesiumMath.EPSILON10)) {\n        Cartesian3.clone(normalsPerTriangle[normalIndices[vertexNormalData.indexOffset]], normal);\n      }\n    } // We end up with a zero vector probably because of a degenerate triangle\n\n\n    if (Cartesian3.equalsEpsilon(Cartesian3.ZERO, normal, CesiumMath.EPSILON10)) {\n      // Default to (0,0,1)\n      normal.z = 1.0;\n    }\n\n    Cartesian3.normalize(normal, normal);\n    normalValues[i3] = normal.x;\n    normalValues[i3 + 1] = normal.y;\n    normalValues[i3 + 2] = normal.z;\n  }\n\n  geometry.attributes.normal = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    values: normalValues\n  });\n  return geometry;\n};\n\nvar normalScratch = new Cartesian3();\nvar normalScale = new Cartesian3();\nvar tScratch = new Cartesian3();\n/**\n * Computes per-vertex tangents and bitangents for a geometry containing <code>TRIANGLES</code>.\n * The result is new <code>tangent</code> and <code>bitangent</code> attributes added to the geometry.\n * This assumes a counter-clockwise winding order.\n * <p>\n * Based on <a href=\"http://www.terathon.com/code/tangent.html\">Computing Tangent Space Basis Vectors\n * for an Arbitrary Mesh</a> by Eric Lengyel.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument with the computed <code>tangent</code> and <code>bitangent</code> attributes.\n *\n * @exception {DeveloperError} geometry.indices length must be greater than 0 and be a multiple of 3.\n * @exception {DeveloperError} geometry.primitiveType must be {@link PrimitiveType.TRIANGLES}.\n *\n * @example\n * Cesium.GeometryPipeline.computeTangentAndBiTangent(geometry);\n */\n\nGeometryPipeline.computeTangentAndBitangent = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  } //>>includeEnd('debug');\n\n\n  var attributes = geometry.attributes;\n  var indices = geometry.indices; //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(attributes.position) || !defined(attributes.position.values)) {\n    throw new DeveloperError(\"geometry.attributes.position.values is required.\");\n  }\n\n  if (!defined(attributes.normal) || !defined(attributes.normal.values)) {\n    throw new DeveloperError(\"geometry.attributes.normal.values is required.\");\n  }\n\n  if (!defined(attributes.st) || !defined(attributes.st.values)) {\n    throw new DeveloperError(\"geometry.attributes.st.values is required.\");\n  }\n\n  if (!defined(indices)) {\n    throw new DeveloperError(\"geometry.indices is required.\");\n  }\n\n  if (indices.length < 2 || indices.length % 3 !== 0) {\n    throw new DeveloperError(\"geometry.indices length must be greater than 0 and be a multiple of 3.\");\n  }\n\n  if (geometry.primitiveType !== PrimitiveType.TRIANGLES) {\n    throw new DeveloperError(\"geometry.primitiveType must be PrimitiveType.TRIANGLES.\");\n  } //>>includeEnd('debug');\n\n\n  var vertices = geometry.attributes.position.values;\n  var normals = geometry.attributes.normal.values;\n  var st = geometry.attributes.st.values;\n  var numVertices = geometry.attributes.position.values.length / 3;\n  var numIndices = indices.length;\n  var tan1 = new Array(numVertices * 3);\n  var i;\n\n  for (i = 0; i < tan1.length; i++) {\n    tan1[i] = 0;\n  }\n\n  var i03;\n  var i13;\n  var i23;\n\n  for (i = 0; i < numIndices; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n    i03 = i0 * 3;\n    i13 = i1 * 3;\n    i23 = i2 * 3;\n    var i02 = i0 * 2;\n    var i12 = i1 * 2;\n    var i22 = i2 * 2;\n    var ux = vertices[i03];\n    var uy = vertices[i03 + 1];\n    var uz = vertices[i03 + 2];\n    var wx = st[i02];\n    var wy = st[i02 + 1];\n    var t1 = st[i12 + 1] - wy;\n    var t2 = st[i22 + 1] - wy;\n    var r = 1.0 / ((st[i12] - wx) * t2 - (st[i22] - wx) * t1);\n    var sdirx = (t2 * (vertices[i13] - ux) - t1 * (vertices[i23] - ux)) * r;\n    var sdiry = (t2 * (vertices[i13 + 1] - uy) - t1 * (vertices[i23 + 1] - uy)) * r;\n    var sdirz = (t2 * (vertices[i13 + 2] - uz) - t1 * (vertices[i23 + 2] - uz)) * r;\n    tan1[i03] += sdirx;\n    tan1[i03 + 1] += sdiry;\n    tan1[i03 + 2] += sdirz;\n    tan1[i13] += sdirx;\n    tan1[i13 + 1] += sdiry;\n    tan1[i13 + 2] += sdirz;\n    tan1[i23] += sdirx;\n    tan1[i23 + 1] += sdiry;\n    tan1[i23 + 2] += sdirz;\n  }\n\n  var tangentValues = new Float32Array(numVertices * 3);\n  var bitangentValues = new Float32Array(numVertices * 3);\n\n  for (i = 0; i < numVertices; i++) {\n    i03 = i * 3;\n    i13 = i03 + 1;\n    i23 = i03 + 2;\n    var n = Cartesian3.fromArray(normals, i03, normalScratch);\n    var t = Cartesian3.fromArray(tan1, i03, tScratch);\n    var scalar = Cartesian3.dot(n, t);\n    Cartesian3.multiplyByScalar(n, scalar, normalScale);\n    Cartesian3.normalize(Cartesian3.subtract(t, normalScale, t), t);\n    tangentValues[i03] = t.x;\n    tangentValues[i13] = t.y;\n    tangentValues[i23] = t.z;\n    Cartesian3.normalize(Cartesian3.cross(n, t, t), t);\n    bitangentValues[i03] = t.x;\n    bitangentValues[i13] = t.y;\n    bitangentValues[i23] = t.z;\n  }\n\n  geometry.attributes.tangent = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    values: tangentValues\n  });\n  geometry.attributes.bitangent = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    values: bitangentValues\n  });\n  return geometry;\n};\n\nvar scratchCartesian2 = new Cartesian2();\nvar toEncode1 = new Cartesian3();\nvar toEncode2 = new Cartesian3();\nvar toEncode3 = new Cartesian3();\nvar encodeResult2 = new Cartesian2();\n/**\n * Compresses and packs geometry normal attribute values to save memory.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its normals compressed and packed.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.compressVertices(geometry);\n */\n\nGeometryPipeline.compressVertices = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  } //>>includeEnd('debug');\n\n\n  var extrudeAttribute = geometry.attributes.extrudeDirection;\n  var i;\n  var numVertices;\n\n  if (defined(extrudeAttribute)) {\n    //only shadow volumes use extrudeDirection, and shadow volumes use vertexFormat: POSITION_ONLY so we don't need to check other attributes\n    var extrudeDirections = extrudeAttribute.values;\n    numVertices = extrudeDirections.length / 3.0;\n    var compressedDirections = new Float32Array(numVertices * 2);\n    var i2 = 0;\n\n    for (i = 0; i < numVertices; ++i) {\n      Cartesian3.fromArray(extrudeDirections, i * 3.0, toEncode1);\n\n      if (Cartesian3.equals(toEncode1, Cartesian3.ZERO)) {\n        i2 += 2;\n        continue;\n      }\n\n      encodeResult2 = AttributeCompression.octEncodeInRange(toEncode1, 65535, encodeResult2);\n      compressedDirections[i2++] = encodeResult2.x;\n      compressedDirections[i2++] = encodeResult2.y;\n    }\n\n    geometry.attributes.compressedAttributes = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: compressedDirections\n    });\n    delete geometry.attributes.extrudeDirection;\n    return geometry;\n  }\n\n  var normalAttribute = geometry.attributes.normal;\n  var stAttribute = geometry.attributes.st;\n  var hasNormal = defined(normalAttribute);\n  var hasSt = defined(stAttribute);\n\n  if (!hasNormal && !hasSt) {\n    return geometry;\n  }\n\n  var tangentAttribute = geometry.attributes.tangent;\n  var bitangentAttribute = geometry.attributes.bitangent;\n  var hasTangent = defined(tangentAttribute);\n  var hasBitangent = defined(bitangentAttribute);\n  var normals;\n  var st;\n  var tangents;\n  var bitangents;\n\n  if (hasNormal) {\n    normals = normalAttribute.values;\n  }\n\n  if (hasSt) {\n    st = stAttribute.values;\n  }\n\n  if (hasTangent) {\n    tangents = tangentAttribute.values;\n  }\n\n  if (hasBitangent) {\n    bitangents = bitangentAttribute.values;\n  }\n\n  var length = hasNormal ? normals.length : st.length;\n  var numComponents = hasNormal ? 3.0 : 2.0;\n  numVertices = length / numComponents;\n  var compressedLength = numVertices;\n  var numCompressedComponents = hasSt && hasNormal ? 2.0 : 1.0;\n  numCompressedComponents += hasTangent || hasBitangent ? 1.0 : 0.0;\n  compressedLength *= numCompressedComponents;\n  var compressedAttributes = new Float32Array(compressedLength);\n  var normalIndex = 0;\n\n  for (i = 0; i < numVertices; ++i) {\n    if (hasSt) {\n      Cartesian2.fromArray(st, i * 2.0, scratchCartesian2);\n      compressedAttributes[normalIndex++] = AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n    }\n\n    var index = i * 3.0;\n\n    if (hasNormal && defined(tangents) && defined(bitangents)) {\n      Cartesian3.fromArray(normals, index, toEncode1);\n      Cartesian3.fromArray(tangents, index, toEncode2);\n      Cartesian3.fromArray(bitangents, index, toEncode3);\n      AttributeCompression.octPack(toEncode1, toEncode2, toEncode3, scratchCartesian2);\n      compressedAttributes[normalIndex++] = scratchCartesian2.x;\n      compressedAttributes[normalIndex++] = scratchCartesian2.y;\n    } else {\n      if (hasNormal) {\n        Cartesian3.fromArray(normals, index, toEncode1);\n        compressedAttributes[normalIndex++] = AttributeCompression.octEncodeFloat(toEncode1);\n      }\n\n      if (hasTangent) {\n        Cartesian3.fromArray(tangents, index, toEncode1);\n        compressedAttributes[normalIndex++] = AttributeCompression.octEncodeFloat(toEncode1);\n      }\n\n      if (hasBitangent) {\n        Cartesian3.fromArray(bitangents, index, toEncode1);\n        compressedAttributes[normalIndex++] = AttributeCompression.octEncodeFloat(toEncode1);\n      }\n    }\n  }\n\n  geometry.attributes.compressedAttributes = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: numCompressedComponents,\n    values: compressedAttributes\n  });\n\n  if (hasNormal) {\n    delete geometry.attributes.normal;\n  }\n\n  if (hasSt) {\n    delete geometry.attributes.st;\n  }\n\n  if (hasBitangent) {\n    delete geometry.attributes.bitangent;\n  }\n\n  if (hasTangent) {\n    delete geometry.attributes.tangent;\n  }\n\n  return geometry;\n};\n\nfunction indexTriangles(geometry) {\n  if (defined(geometry.indices)) {\n    return geometry;\n  }\n\n  var numberOfVertices = Geometry.computeNumberOfVertices(geometry); //>>includeStart('debug', pragmas.debug);\n\n  if (numberOfVertices < 3) {\n    throw new DeveloperError(\"The number of vertices must be at least three.\");\n  }\n\n  if (numberOfVertices % 3 !== 0) {\n    throw new DeveloperError(\"The number of vertices must be a multiple of three.\");\n  } //>>includeEnd('debug');\n\n\n  var indices = IndexDatatype.createTypedArray(numberOfVertices, numberOfVertices);\n\n  for (var i = 0; i < numberOfVertices; ++i) {\n    indices[i] = i;\n  }\n\n  geometry.indices = indices;\n  return geometry;\n}\n\nfunction indexTriangleFan(geometry) {\n  var numberOfVertices = Geometry.computeNumberOfVertices(geometry); //>>includeStart('debug', pragmas.debug);\n\n  if (numberOfVertices < 3) {\n    throw new DeveloperError(\"The number of vertices must be at least three.\");\n  } //>>includeEnd('debug');\n\n\n  var indices = IndexDatatype.createTypedArray(numberOfVertices, (numberOfVertices - 2) * 3);\n  indices[0] = 1;\n  indices[1] = 0;\n  indices[2] = 2;\n  var indicesIndex = 3;\n\n  for (var i = 3; i < numberOfVertices; ++i) {\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = 0;\n    indices[indicesIndex++] = i;\n  }\n\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.TRIANGLES;\n  return geometry;\n}\n\nfunction indexTriangleStrip(geometry) {\n  var numberOfVertices = Geometry.computeNumberOfVertices(geometry); //>>includeStart('debug', pragmas.debug);\n\n  if (numberOfVertices < 3) {\n    throw new DeveloperError(\"The number of vertices must be at least 3.\");\n  } //>>includeEnd('debug');\n\n\n  var indices = IndexDatatype.createTypedArray(numberOfVertices, (numberOfVertices - 2) * 3);\n  indices[0] = 0;\n  indices[1] = 1;\n  indices[2] = 2;\n\n  if (numberOfVertices > 3) {\n    indices[3] = 0;\n    indices[4] = 2;\n    indices[5] = 3;\n  }\n\n  var indicesIndex = 6;\n\n  for (var i = 3; i < numberOfVertices - 1; i += 2) {\n    indices[indicesIndex++] = i;\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = i + 1;\n\n    if (i + 2 < numberOfVertices) {\n      indices[indicesIndex++] = i;\n      indices[indicesIndex++] = i + 1;\n      indices[indicesIndex++] = i + 2;\n    }\n  }\n\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.TRIANGLES;\n  return geometry;\n}\n\nfunction indexLines(geometry) {\n  if (defined(geometry.indices)) {\n    return geometry;\n  }\n\n  var numberOfVertices = Geometry.computeNumberOfVertices(geometry); //>>includeStart('debug', pragmas.debug);\n\n  if (numberOfVertices < 2) {\n    throw new DeveloperError(\"The number of vertices must be at least two.\");\n  }\n\n  if (numberOfVertices % 2 !== 0) {\n    throw new DeveloperError(\"The number of vertices must be a multiple of 2.\");\n  } //>>includeEnd('debug');\n\n\n  var indices = IndexDatatype.createTypedArray(numberOfVertices, numberOfVertices);\n\n  for (var i = 0; i < numberOfVertices; ++i) {\n    indices[i] = i;\n  }\n\n  geometry.indices = indices;\n  return geometry;\n}\n\nfunction indexLineStrip(geometry) {\n  var numberOfVertices = Geometry.computeNumberOfVertices(geometry); //>>includeStart('debug', pragmas.debug);\n\n  if (numberOfVertices < 2) {\n    throw new DeveloperError(\"The number of vertices must be at least two.\");\n  } //>>includeEnd('debug');\n\n\n  var indices = IndexDatatype.createTypedArray(numberOfVertices, (numberOfVertices - 1) * 2);\n  indices[0] = 0;\n  indices[1] = 1;\n  var indicesIndex = 2;\n\n  for (var i = 2; i < numberOfVertices; ++i) {\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = i;\n  }\n\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.LINES;\n  return geometry;\n}\n\nfunction indexLineLoop(geometry) {\n  var numberOfVertices = Geometry.computeNumberOfVertices(geometry); //>>includeStart('debug', pragmas.debug);\n\n  if (numberOfVertices < 2) {\n    throw new DeveloperError(\"The number of vertices must be at least two.\");\n  } //>>includeEnd('debug');\n\n\n  var indices = IndexDatatype.createTypedArray(numberOfVertices, numberOfVertices * 2);\n  indices[0] = 0;\n  indices[1] = 1;\n  var indicesIndex = 2;\n\n  for (var i = 2; i < numberOfVertices; ++i) {\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = i;\n  }\n\n  indices[indicesIndex++] = numberOfVertices - 1;\n  indices[indicesIndex] = 0;\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.LINES;\n  return geometry;\n}\n\nfunction indexPrimitive(geometry) {\n  switch (geometry.primitiveType) {\n    case PrimitiveType.TRIANGLE_FAN:\n      return indexTriangleFan(geometry);\n\n    case PrimitiveType.TRIANGLE_STRIP:\n      return indexTriangleStrip(geometry);\n\n    case PrimitiveType.TRIANGLES:\n      return indexTriangles(geometry);\n\n    case PrimitiveType.LINE_STRIP:\n      return indexLineStrip(geometry);\n\n    case PrimitiveType.LINE_LOOP:\n      return indexLineLoop(geometry);\n\n    case PrimitiveType.LINES:\n      return indexLines(geometry);\n  }\n\n  return geometry;\n}\n\nfunction offsetPointFromXZPlane(p, isBehind) {\n  if (Math.abs(p.y) < CesiumMath.EPSILON6) {\n    if (isBehind) {\n      p.y = -CesiumMath.EPSILON6;\n    } else {\n      p.y = CesiumMath.EPSILON6;\n    }\n  }\n}\n\nfunction offsetTriangleFromXZPlane(p0, p1, p2) {\n  if (p0.y !== 0.0 && p1.y !== 0.0 && p2.y !== 0.0) {\n    offsetPointFromXZPlane(p0, p0.y < 0.0);\n    offsetPointFromXZPlane(p1, p1.y < 0.0);\n    offsetPointFromXZPlane(p2, p2.y < 0.0);\n    return;\n  }\n\n  var p0y = Math.abs(p0.y);\n  var p1y = Math.abs(p1.y);\n  var p2y = Math.abs(p2.y);\n  var sign;\n\n  if (p0y > p1y) {\n    if (p0y > p2y) {\n      sign = CesiumMath.sign(p0.y);\n    } else {\n      sign = CesiumMath.sign(p2.y);\n    }\n  } else if (p1y > p2y) {\n    sign = CesiumMath.sign(p1.y);\n  } else {\n    sign = CesiumMath.sign(p2.y);\n  }\n\n  var isBehind = sign < 0.0;\n  offsetPointFromXZPlane(p0, isBehind);\n  offsetPointFromXZPlane(p1, isBehind);\n  offsetPointFromXZPlane(p2, isBehind);\n}\n\nvar c3 = new Cartesian3();\n\nfunction getXZIntersectionOffsetPoints(p, p1, u1, v1) {\n  Cartesian3.add(p, Cartesian3.multiplyByScalar(Cartesian3.subtract(p1, p, c3), p.y / (p.y - p1.y), c3), u1);\n  Cartesian3.clone(u1, v1);\n  offsetPointFromXZPlane(u1, true);\n  offsetPointFromXZPlane(v1, false);\n}\n\nvar u1 = new Cartesian3();\nvar u2 = new Cartesian3();\nvar q1 = new Cartesian3();\nvar q2 = new Cartesian3();\nvar splitTriangleResult = {\n  positions: new Array(7),\n  indices: new Array(3 * 3)\n};\n\nfunction splitTriangle(p0, p1, p2) {\n  // In WGS84 coordinates, for a triangle approximately on the\n  // ellipsoid to cross the IDL, first it needs to be on the\n  // negative side of the plane x = 0.\n  if (p0.x >= 0.0 || p1.x >= 0.0 || p2.x >= 0.0) {\n    return undefined;\n  }\n\n  offsetTriangleFromXZPlane(p0, p1, p2);\n  var p0Behind = p0.y < 0.0;\n  var p1Behind = p1.y < 0.0;\n  var p2Behind = p2.y < 0.0;\n  var numBehind = 0;\n  numBehind += p0Behind ? 1 : 0;\n  numBehind += p1Behind ? 1 : 0;\n  numBehind += p2Behind ? 1 : 0;\n  var indices = splitTriangleResult.indices;\n\n  if (numBehind === 1) {\n    indices[1] = 3;\n    indices[2] = 4;\n    indices[5] = 6;\n    indices[7] = 6;\n    indices[8] = 5;\n\n    if (p0Behind) {\n      getXZIntersectionOffsetPoints(p0, p1, u1, q1);\n      getXZIntersectionOffsetPoints(p0, p2, u2, q2);\n      indices[0] = 0;\n      indices[3] = 1;\n      indices[4] = 2;\n      indices[6] = 1;\n    } else if (p1Behind) {\n      getXZIntersectionOffsetPoints(p1, p2, u1, q1);\n      getXZIntersectionOffsetPoints(p1, p0, u2, q2);\n      indices[0] = 1;\n      indices[3] = 2;\n      indices[4] = 0;\n      indices[6] = 2;\n    } else if (p2Behind) {\n      getXZIntersectionOffsetPoints(p2, p0, u1, q1);\n      getXZIntersectionOffsetPoints(p2, p1, u2, q2);\n      indices[0] = 2;\n      indices[3] = 0;\n      indices[4] = 1;\n      indices[6] = 0;\n    }\n  } else if (numBehind === 2) {\n    indices[2] = 4;\n    indices[4] = 4;\n    indices[5] = 3;\n    indices[7] = 5;\n    indices[8] = 6;\n\n    if (!p0Behind) {\n      getXZIntersectionOffsetPoints(p0, p1, u1, q1);\n      getXZIntersectionOffsetPoints(p0, p2, u2, q2);\n      indices[0] = 1;\n      indices[1] = 2;\n      indices[3] = 1;\n      indices[6] = 0;\n    } else if (!p1Behind) {\n      getXZIntersectionOffsetPoints(p1, p2, u1, q1);\n      getXZIntersectionOffsetPoints(p1, p0, u2, q2);\n      indices[0] = 2;\n      indices[1] = 0;\n      indices[3] = 2;\n      indices[6] = 1;\n    } else if (!p2Behind) {\n      getXZIntersectionOffsetPoints(p2, p0, u1, q1);\n      getXZIntersectionOffsetPoints(p2, p1, u2, q2);\n      indices[0] = 0;\n      indices[1] = 1;\n      indices[3] = 0;\n      indices[6] = 2;\n    }\n  }\n\n  var positions = splitTriangleResult.positions;\n  positions[0] = p0;\n  positions[1] = p1;\n  positions[2] = p2;\n  positions.length = 3;\n\n  if (numBehind === 1 || numBehind === 2) {\n    positions[3] = u1;\n    positions[4] = u2;\n    positions[5] = q1;\n    positions[6] = q2;\n    positions.length = 7;\n  }\n\n  return splitTriangleResult;\n}\n\nfunction updateGeometryAfterSplit(geometry, computeBoundingSphere) {\n  var attributes = geometry.attributes;\n\n  if (attributes.position.values.length === 0) {\n    return undefined;\n  }\n\n  for (var property in attributes) {\n    if (attributes.hasOwnProperty(property) && defined(attributes[property]) && defined(attributes[property].values)) {\n      var attribute = attributes[property];\n      attribute.values = ComponentDatatype.createTypedArray(attribute.componentDatatype, attribute.values);\n    }\n  }\n\n  var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n  geometry.indices = IndexDatatype.createTypedArray(numberOfVertices, geometry.indices);\n\n  if (computeBoundingSphere) {\n    geometry.boundingSphere = BoundingSphere.fromVertices(attributes.position.values);\n  }\n\n  return geometry;\n}\n\nfunction copyGeometryForSplit(geometry) {\n  var attributes = geometry.attributes;\n  var copiedAttributes = {};\n\n  for (var property in attributes) {\n    if (attributes.hasOwnProperty(property) && defined(attributes[property]) && defined(attributes[property].values)) {\n      var attribute = attributes[property];\n      copiedAttributes[property] = new GeometryAttribute({\n        componentDatatype: attribute.componentDatatype,\n        componentsPerAttribute: attribute.componentsPerAttribute,\n        normalize: attribute.normalize,\n        values: []\n      });\n    }\n  }\n\n  return new Geometry({\n    attributes: copiedAttributes,\n    indices: [],\n    primitiveType: geometry.primitiveType\n  });\n}\n\nfunction updateInstanceAfterSplit(instance, westGeometry, eastGeometry) {\n  var computeBoundingSphere = defined(instance.geometry.boundingSphere);\n  westGeometry = updateGeometryAfterSplit(westGeometry, computeBoundingSphere);\n  eastGeometry = updateGeometryAfterSplit(eastGeometry, computeBoundingSphere);\n\n  if (defined(eastGeometry) && !defined(westGeometry)) {\n    instance.geometry = eastGeometry;\n  } else if (!defined(eastGeometry) && defined(westGeometry)) {\n    instance.geometry = westGeometry;\n  } else {\n    instance.westHemisphereGeometry = westGeometry;\n    instance.eastHemisphereGeometry = eastGeometry;\n    instance.geometry = undefined;\n  }\n}\n\nfunction generateBarycentricInterpolateFunction(CartesianType, numberOfComponents) {\n  var v0Scratch = new CartesianType();\n  var v1Scratch = new CartesianType();\n  var v2Scratch = new CartesianType();\n  return function (i0, i1, i2, coords, sourceValues, currentValues, insertedIndex, normalize) {\n    var v0 = CartesianType.fromArray(sourceValues, i0 * numberOfComponents, v0Scratch);\n    var v1 = CartesianType.fromArray(sourceValues, i1 * numberOfComponents, v1Scratch);\n    var v2 = CartesianType.fromArray(sourceValues, i2 * numberOfComponents, v2Scratch);\n    CartesianType.multiplyByScalar(v0, coords.x, v0);\n    CartesianType.multiplyByScalar(v1, coords.y, v1);\n    CartesianType.multiplyByScalar(v2, coords.z, v2);\n    var value = CartesianType.add(v0, v1, v0);\n    CartesianType.add(value, v2, value);\n\n    if (normalize) {\n      CartesianType.normalize(value, value);\n    }\n\n    CartesianType.pack(value, currentValues, insertedIndex * numberOfComponents);\n  };\n}\n\nvar interpolateAndPackCartesian4 = generateBarycentricInterpolateFunction(Cartesian4, 4);\nvar interpolateAndPackCartesian3 = generateBarycentricInterpolateFunction(Cartesian3, 3);\nvar interpolateAndPackCartesian2 = generateBarycentricInterpolateFunction(Cartesian2, 2);\n\nvar interpolateAndPackBoolean = function (i0, i1, i2, coords, sourceValues, currentValues, insertedIndex) {\n  var v1 = sourceValues[i0] * coords.x;\n  var v2 = sourceValues[i1] * coords.y;\n  var v3 = sourceValues[i2] * coords.z;\n  currentValues[insertedIndex] = v1 + v2 + v3 > CesiumMath.EPSILON6 ? 1 : 0;\n};\n\nvar p0Scratch = new Cartesian3();\nvar p1Scratch = new Cartesian3();\nvar p2Scratch = new Cartesian3();\nvar barycentricScratch = new Cartesian3();\n\nfunction computeTriangleAttributes(i0, i1, i2, point, positions, normals, tangents, bitangents, texCoords, extrudeDirections, applyOffset, currentAttributes, customAttributeNames, customAttributesLength, allAttributes, insertedIndex) {\n  if (!defined(normals) && !defined(tangents) && !defined(bitangents) && !defined(texCoords) && !defined(extrudeDirections) && customAttributesLength === 0) {\n    return;\n  }\n\n  var p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\n  var p1 = Cartesian3.fromArray(positions, i1 * 3, p1Scratch);\n  var p2 = Cartesian3.fromArray(positions, i2 * 3, p2Scratch);\n  var coords = barycentricCoordinates(point, p0, p1, p2, barycentricScratch);\n\n  if (defined(normals)) {\n    interpolateAndPackCartesian3(i0, i1, i2, coords, normals, currentAttributes.normal.values, insertedIndex, true);\n  }\n\n  if (defined(extrudeDirections)) {\n    var d0 = Cartesian3.fromArray(extrudeDirections, i0 * 3, p0Scratch);\n    var d1 = Cartesian3.fromArray(extrudeDirections, i1 * 3, p1Scratch);\n    var d2 = Cartesian3.fromArray(extrudeDirections, i2 * 3, p2Scratch);\n    Cartesian3.multiplyByScalar(d0, coords.x, d0);\n    Cartesian3.multiplyByScalar(d1, coords.y, d1);\n    Cartesian3.multiplyByScalar(d2, coords.z, d2);\n    var direction;\n\n    if (!Cartesian3.equals(d0, Cartesian3.ZERO) || !Cartesian3.equals(d1, Cartesian3.ZERO) || !Cartesian3.equals(d2, Cartesian3.ZERO)) {\n      direction = Cartesian3.add(d0, d1, d0);\n      Cartesian3.add(direction, d2, direction);\n      Cartesian3.normalize(direction, direction);\n    } else {\n      direction = p0Scratch;\n      direction.x = 0;\n      direction.y = 0;\n      direction.z = 0;\n    }\n\n    Cartesian3.pack(direction, currentAttributes.extrudeDirection.values, insertedIndex * 3);\n  }\n\n  if (defined(applyOffset)) {\n    interpolateAndPackBoolean(i0, i1, i2, coords, applyOffset, currentAttributes.applyOffset.values, insertedIndex);\n  }\n\n  if (defined(tangents)) {\n    interpolateAndPackCartesian3(i0, i1, i2, coords, tangents, currentAttributes.tangent.values, insertedIndex, true);\n  }\n\n  if (defined(bitangents)) {\n    interpolateAndPackCartesian3(i0, i1, i2, coords, bitangents, currentAttributes.bitangent.values, insertedIndex, true);\n  }\n\n  if (defined(texCoords)) {\n    interpolateAndPackCartesian2(i0, i1, i2, coords, texCoords, currentAttributes.st.values, insertedIndex);\n  }\n\n  if (customAttributesLength > 0) {\n    for (var i = 0; i < customAttributesLength; i++) {\n      var attributeName = customAttributeNames[i];\n      genericInterpolate(i0, i1, i2, coords, insertedIndex, allAttributes[attributeName], currentAttributes[attributeName]);\n    }\n  }\n}\n\nfunction genericInterpolate(i0, i1, i2, coords, insertedIndex, sourceAttribute, currentAttribute) {\n  var componentsPerAttribute = sourceAttribute.componentsPerAttribute;\n  var sourceValues = sourceAttribute.values;\n  var currentValues = currentAttribute.values;\n\n  switch (componentsPerAttribute) {\n    case 4:\n      interpolateAndPackCartesian4(i0, i1, i2, coords, sourceValues, currentValues, insertedIndex, false);\n      break;\n\n    case 3:\n      interpolateAndPackCartesian3(i0, i1, i2, coords, sourceValues, currentValues, insertedIndex, false);\n      break;\n\n    case 2:\n      interpolateAndPackCartesian2(i0, i1, i2, coords, sourceValues, currentValues, insertedIndex, false);\n      break;\n\n    default:\n      currentValues[insertedIndex] = sourceValues[i0] * coords.x + sourceValues[i1] * coords.y + sourceValues[i2] * coords.z;\n  }\n}\n\nfunction insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, currentIndex, point) {\n  var insertIndex = currentAttributes.position.values.length / 3;\n\n  if (currentIndex !== -1) {\n    var prevIndex = indices[currentIndex];\n    var newIndex = currentIndexMap[prevIndex];\n\n    if (newIndex === -1) {\n      currentIndexMap[prevIndex] = insertIndex;\n      currentAttributes.position.values.push(point.x, point.y, point.z);\n      currentIndices.push(insertIndex);\n      return insertIndex;\n    }\n\n    currentIndices.push(newIndex);\n    return newIndex;\n  }\n\n  currentAttributes.position.values.push(point.x, point.y, point.z);\n  currentIndices.push(insertIndex);\n  return insertIndex;\n}\n\nvar NAMED_ATTRIBUTES = {\n  position: true,\n  normal: true,\n  bitangent: true,\n  tangent: true,\n  st: true,\n  extrudeDirection: true,\n  applyOffset: true\n};\n\nfunction splitLongitudeTriangles(instance) {\n  var geometry = instance.geometry;\n  var attributes = geometry.attributes;\n  var positions = attributes.position.values;\n  var normals = defined(attributes.normal) ? attributes.normal.values : undefined;\n  var bitangents = defined(attributes.bitangent) ? attributes.bitangent.values : undefined;\n  var tangents = defined(attributes.tangent) ? attributes.tangent.values : undefined;\n  var texCoords = defined(attributes.st) ? attributes.st.values : undefined;\n  var extrudeDirections = defined(attributes.extrudeDirection) ? attributes.extrudeDirection.values : undefined;\n  var applyOffset = defined(attributes.applyOffset) ? attributes.applyOffset.values : undefined;\n  var indices = geometry.indices;\n  var customAttributeNames = [];\n\n  for (var attributeName in attributes) {\n    if (attributes.hasOwnProperty(attributeName) && !NAMED_ATTRIBUTES[attributeName] && defined(attributes[attributeName])) {\n      customAttributeNames.push(attributeName);\n    }\n  }\n\n  var customAttributesLength = customAttributeNames.length;\n  var eastGeometry = copyGeometryForSplit(geometry);\n  var westGeometry = copyGeometryForSplit(geometry);\n  var currentAttributes;\n  var currentIndices;\n  var currentIndexMap;\n  var insertedIndex;\n  var i;\n  var westGeometryIndexMap = [];\n  westGeometryIndexMap.length = positions.length / 3;\n  var eastGeometryIndexMap = [];\n  eastGeometryIndexMap.length = positions.length / 3;\n\n  for (i = 0; i < westGeometryIndexMap.length; ++i) {\n    westGeometryIndexMap[i] = -1;\n    eastGeometryIndexMap[i] = -1;\n  }\n\n  var len = indices.length;\n\n  for (i = 0; i < len; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n    var p0 = Cartesian3.fromArray(positions, i0 * 3);\n    var p1 = Cartesian3.fromArray(positions, i1 * 3);\n    var p2 = Cartesian3.fromArray(positions, i2 * 3);\n    var result = splitTriangle(p0, p1, p2);\n\n    if (defined(result) && result.positions.length > 3) {\n      var resultPositions = result.positions;\n      var resultIndices = result.indices;\n      var resultLength = resultIndices.length;\n\n      for (var j = 0; j < resultLength; ++j) {\n        var resultIndex = resultIndices[j];\n        var point = resultPositions[resultIndex];\n\n        if (point.y < 0.0) {\n          currentAttributes = westGeometry.attributes;\n          currentIndices = westGeometry.indices;\n          currentIndexMap = westGeometryIndexMap;\n        } else {\n          currentAttributes = eastGeometry.attributes;\n          currentIndices = eastGeometry.indices;\n          currentIndexMap = eastGeometryIndexMap;\n        }\n\n        insertedIndex = insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, resultIndex < 3 ? i + resultIndex : -1, point);\n        computeTriangleAttributes(i0, i1, i2, point, positions, normals, tangents, bitangents, texCoords, extrudeDirections, applyOffset, currentAttributes, customAttributeNames, customAttributesLength, attributes, insertedIndex);\n      }\n    } else {\n      if (defined(result)) {\n        p0 = result.positions[0];\n        p1 = result.positions[1];\n        p2 = result.positions[2];\n      }\n\n      if (p0.y < 0.0) {\n        currentAttributes = westGeometry.attributes;\n        currentIndices = westGeometry.indices;\n        currentIndexMap = westGeometryIndexMap;\n      } else {\n        currentAttributes = eastGeometry.attributes;\n        currentIndices = eastGeometry.indices;\n        currentIndexMap = eastGeometryIndexMap;\n      }\n\n      insertedIndex = insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, i, p0);\n      computeTriangleAttributes(i0, i1, i2, p0, positions, normals, tangents, bitangents, texCoords, extrudeDirections, applyOffset, currentAttributes, customAttributeNames, customAttributesLength, attributes, insertedIndex);\n      insertedIndex = insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, i + 1, p1);\n      computeTriangleAttributes(i0, i1, i2, p1, positions, normals, tangents, bitangents, texCoords, extrudeDirections, applyOffset, currentAttributes, customAttributeNames, customAttributesLength, attributes, insertedIndex);\n      insertedIndex = insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, i + 2, p2);\n      computeTriangleAttributes(i0, i1, i2, p2, positions, normals, tangents, bitangents, texCoords, extrudeDirections, applyOffset, currentAttributes, customAttributeNames, customAttributesLength, attributes, insertedIndex);\n    }\n  }\n\n  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\n}\n\nvar xzPlane = Plane.fromPointNormal(Cartesian3.ZERO, Cartesian3.UNIT_Y);\nvar offsetScratch = new Cartesian3();\nvar offsetPointScratch = new Cartesian3();\n\nfunction computeLineAttributes(i0, i1, point, positions, insertIndex, currentAttributes, applyOffset) {\n  if (!defined(applyOffset)) {\n    return;\n  }\n\n  var p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\n\n  if (Cartesian3.equalsEpsilon(p0, point, CesiumMath.EPSILON10)) {\n    currentAttributes.applyOffset.values[insertIndex] = applyOffset[i0];\n  } else {\n    currentAttributes.applyOffset.values[insertIndex] = applyOffset[i1];\n  }\n}\n\nfunction splitLongitudeLines(instance) {\n  var geometry = instance.geometry;\n  var attributes = geometry.attributes;\n  var positions = attributes.position.values;\n  var applyOffset = defined(attributes.applyOffset) ? attributes.applyOffset.values : undefined;\n  var indices = geometry.indices;\n  var eastGeometry = copyGeometryForSplit(geometry);\n  var westGeometry = copyGeometryForSplit(geometry);\n  var i;\n  var length = indices.length;\n  var westGeometryIndexMap = [];\n  westGeometryIndexMap.length = positions.length / 3;\n  var eastGeometryIndexMap = [];\n  eastGeometryIndexMap.length = positions.length / 3;\n\n  for (i = 0; i < westGeometryIndexMap.length; ++i) {\n    westGeometryIndexMap[i] = -1;\n    eastGeometryIndexMap[i] = -1;\n  }\n\n  for (i = 0; i < length; i += 2) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\n    var p1 = Cartesian3.fromArray(positions, i1 * 3, p1Scratch);\n    var insertIndex;\n\n    if (Math.abs(p0.y) < CesiumMath.EPSILON6) {\n      if (p0.y < 0.0) {\n        p0.y = -CesiumMath.EPSILON6;\n      } else {\n        p0.y = CesiumMath.EPSILON6;\n      }\n    }\n\n    if (Math.abs(p1.y) < CesiumMath.EPSILON6) {\n      if (p1.y < 0.0) {\n        p1.y = -CesiumMath.EPSILON6;\n      } else {\n        p1.y = CesiumMath.EPSILON6;\n      }\n    }\n\n    var p0Attributes = eastGeometry.attributes;\n    var p0Indices = eastGeometry.indices;\n    var p0IndexMap = eastGeometryIndexMap;\n    var p1Attributes = westGeometry.attributes;\n    var p1Indices = westGeometry.indices;\n    var p1IndexMap = westGeometryIndexMap;\n    var intersection = IntersectionTests.lineSegmentPlane(p0, p1, xzPlane, p2Scratch);\n\n    if (defined(intersection)) {\n      // move point on the xz-plane slightly away from the plane\n      var offset = Cartesian3.multiplyByScalar(Cartesian3.UNIT_Y, 5.0 * CesiumMath.EPSILON9, offsetScratch);\n\n      if (p0.y < 0.0) {\n        Cartesian3.negate(offset, offset);\n        p0Attributes = westGeometry.attributes;\n        p0Indices = westGeometry.indices;\n        p0IndexMap = westGeometryIndexMap;\n        p1Attributes = eastGeometry.attributes;\n        p1Indices = eastGeometry.indices;\n        p1IndexMap = eastGeometryIndexMap;\n      }\n\n      var offsetPoint = Cartesian3.add(intersection, offset, offsetPointScratch);\n      insertIndex = insertSplitPoint(p0Attributes, p0Indices, p0IndexMap, indices, i, p0);\n      computeLineAttributes(i0, i1, p0, positions, insertIndex, p0Attributes, applyOffset);\n      insertIndex = insertSplitPoint(p0Attributes, p0Indices, p0IndexMap, indices, -1, offsetPoint);\n      computeLineAttributes(i0, i1, offsetPoint, positions, insertIndex, p0Attributes, applyOffset);\n      Cartesian3.negate(offset, offset);\n      Cartesian3.add(intersection, offset, offsetPoint);\n      insertIndex = insertSplitPoint(p1Attributes, p1Indices, p1IndexMap, indices, -1, offsetPoint);\n      computeLineAttributes(i0, i1, offsetPoint, positions, insertIndex, p1Attributes, applyOffset);\n      insertIndex = insertSplitPoint(p1Attributes, p1Indices, p1IndexMap, indices, i + 1, p1);\n      computeLineAttributes(i0, i1, p1, positions, insertIndex, p1Attributes, applyOffset);\n    } else {\n      var currentAttributes;\n      var currentIndices;\n      var currentIndexMap;\n\n      if (p0.y < 0.0) {\n        currentAttributes = westGeometry.attributes;\n        currentIndices = westGeometry.indices;\n        currentIndexMap = westGeometryIndexMap;\n      } else {\n        currentAttributes = eastGeometry.attributes;\n        currentIndices = eastGeometry.indices;\n        currentIndexMap = eastGeometryIndexMap;\n      }\n\n      insertIndex = insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, i, p0);\n      computeLineAttributes(i0, i1, p0, positions, insertIndex, currentAttributes, applyOffset);\n      insertIndex = insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, i + 1, p1);\n      computeLineAttributes(i0, i1, p1, positions, insertIndex, currentAttributes, applyOffset);\n    }\n  }\n\n  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\n}\n\nvar cartesian2Scratch0 = new Cartesian2();\nvar cartesian2Scratch1 = new Cartesian2();\nvar cartesian3Scratch0 = new Cartesian3();\nvar cartesian3Scratch2 = new Cartesian3();\nvar cartesian3Scratch3 = new Cartesian3();\nvar cartesian3Scratch4 = new Cartesian3();\nvar cartesian3Scratch5 = new Cartesian3();\nvar cartesian3Scratch6 = new Cartesian3();\nvar cartesian4Scratch0 = new Cartesian4();\n\nfunction updateAdjacencyAfterSplit(geometry) {\n  var attributes = geometry.attributes;\n  var positions = attributes.position.values;\n  var prevPositions = attributes.prevPosition.values;\n  var nextPositions = attributes.nextPosition.values;\n  var length = positions.length;\n\n  for (var j = 0; j < length; j += 3) {\n    var position = Cartesian3.unpack(positions, j, cartesian3Scratch0);\n\n    if (position.x > 0.0) {\n      continue;\n    }\n\n    var prevPosition = Cartesian3.unpack(prevPositions, j, cartesian3Scratch2);\n\n    if (position.y < 0.0 && prevPosition.y > 0.0 || position.y > 0.0 && prevPosition.y < 0.0) {\n      if (j - 3 > 0) {\n        prevPositions[j] = positions[j - 3];\n        prevPositions[j + 1] = positions[j - 2];\n        prevPositions[j + 2] = positions[j - 1];\n      } else {\n        Cartesian3.pack(position, prevPositions, j);\n      }\n    }\n\n    var nextPosition = Cartesian3.unpack(nextPositions, j, cartesian3Scratch3);\n\n    if (position.y < 0.0 && nextPosition.y > 0.0 || position.y > 0.0 && nextPosition.y < 0.0) {\n      if (j + 3 < length) {\n        nextPositions[j] = positions[j + 3];\n        nextPositions[j + 1] = positions[j + 4];\n        nextPositions[j + 2] = positions[j + 5];\n      } else {\n        Cartesian3.pack(position, nextPositions, j);\n      }\n    }\n  }\n}\n\nvar offsetScalar = 5.0 * CesiumMath.EPSILON9;\nvar coplanarOffset = CesiumMath.EPSILON6;\n\nfunction splitLongitudePolyline(instance) {\n  var geometry = instance.geometry;\n  var attributes = geometry.attributes;\n  var positions = attributes.position.values;\n  var prevPositions = attributes.prevPosition.values;\n  var nextPositions = attributes.nextPosition.values;\n  var expandAndWidths = attributes.expandAndWidth.values;\n  var texCoords = defined(attributes.st) ? attributes.st.values : undefined;\n  var colors = defined(attributes.color) ? attributes.color.values : undefined;\n  var eastGeometry = copyGeometryForSplit(geometry);\n  var westGeometry = copyGeometryForSplit(geometry);\n  var i;\n  var j;\n  var index;\n  var intersectionFound = false;\n  var length = positions.length / 3;\n\n  for (i = 0; i < length; i += 4) {\n    var i0 = i;\n    var i2 = i + 2;\n    var p0 = Cartesian3.fromArray(positions, i0 * 3, cartesian3Scratch0);\n    var p2 = Cartesian3.fromArray(positions, i2 * 3, cartesian3Scratch2); // Offset points that are close to the 180 longitude and change the previous/next point\n    // to be the same offset point so it can be projected to 2D. There is special handling in the\n    // shader for when position == prevPosition || position == nextPosition.\n\n    if (Math.abs(p0.y) < coplanarOffset) {\n      p0.y = coplanarOffset * (p2.y < 0.0 ? -1.0 : 1.0);\n      positions[i * 3 + 1] = p0.y;\n      positions[(i + 1) * 3 + 1] = p0.y;\n\n      for (j = i0 * 3; j < i0 * 3 + 4 * 3; j += 3) {\n        prevPositions[j] = positions[i * 3];\n        prevPositions[j + 1] = positions[i * 3 + 1];\n        prevPositions[j + 2] = positions[i * 3 + 2];\n      }\n    } // Do the same but for when the line crosses 180 longitude in the opposite direction.\n\n\n    if (Math.abs(p2.y) < coplanarOffset) {\n      p2.y = coplanarOffset * (p0.y < 0.0 ? -1.0 : 1.0);\n      positions[(i + 2) * 3 + 1] = p2.y;\n      positions[(i + 3) * 3 + 1] = p2.y;\n\n      for (j = i0 * 3; j < i0 * 3 + 4 * 3; j += 3) {\n        nextPositions[j] = positions[(i + 2) * 3];\n        nextPositions[j + 1] = positions[(i + 2) * 3 + 1];\n        nextPositions[j + 2] = positions[(i + 2) * 3 + 2];\n      }\n    }\n\n    var p0Attributes = eastGeometry.attributes;\n    var p0Indices = eastGeometry.indices;\n    var p2Attributes = westGeometry.attributes;\n    var p2Indices = westGeometry.indices;\n    var intersection = IntersectionTests.lineSegmentPlane(p0, p2, xzPlane, cartesian3Scratch4);\n\n    if (defined(intersection)) {\n      intersectionFound = true; // move point on the xz-plane slightly away from the plane\n\n      var offset = Cartesian3.multiplyByScalar(Cartesian3.UNIT_Y, offsetScalar, cartesian3Scratch5);\n\n      if (p0.y < 0.0) {\n        Cartesian3.negate(offset, offset);\n        p0Attributes = westGeometry.attributes;\n        p0Indices = westGeometry.indices;\n        p2Attributes = eastGeometry.attributes;\n        p2Indices = eastGeometry.indices;\n      }\n\n      var offsetPoint = Cartesian3.add(intersection, offset, cartesian3Scratch6);\n      p0Attributes.position.values.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z);\n      p0Attributes.position.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n      p0Attributes.position.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n      p0Attributes.prevPosition.values.push(prevPositions[i0 * 3], prevPositions[i0 * 3 + 1], prevPositions[i0 * 3 + 2]);\n      p0Attributes.prevPosition.values.push(prevPositions[i0 * 3 + 3], prevPositions[i0 * 3 + 4], prevPositions[i0 * 3 + 5]);\n      p0Attributes.prevPosition.values.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z);\n      p0Attributes.nextPosition.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n      p0Attributes.nextPosition.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n      p0Attributes.nextPosition.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n      p0Attributes.nextPosition.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n      Cartesian3.negate(offset, offset);\n      Cartesian3.add(intersection, offset, offsetPoint);\n      p2Attributes.position.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n      p2Attributes.position.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n      p2Attributes.position.values.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);\n      p2Attributes.prevPosition.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n      p2Attributes.prevPosition.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n      p2Attributes.prevPosition.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n      p2Attributes.prevPosition.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n      p2Attributes.nextPosition.values.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);\n      p2Attributes.nextPosition.values.push(nextPositions[i2 * 3], nextPositions[i2 * 3 + 1], nextPositions[i2 * 3 + 2]);\n      p2Attributes.nextPosition.values.push(nextPositions[i2 * 3 + 3], nextPositions[i2 * 3 + 4], nextPositions[i2 * 3 + 5]);\n      var ew0 = Cartesian2.fromArray(expandAndWidths, i0 * 2, cartesian2Scratch0);\n      var width = Math.abs(ew0.y);\n      p0Attributes.expandAndWidth.values.push(-1, width, 1, width);\n      p0Attributes.expandAndWidth.values.push(-1, -width, 1, -width);\n      p2Attributes.expandAndWidth.values.push(-1, width, 1, width);\n      p2Attributes.expandAndWidth.values.push(-1, -width, 1, -width);\n      var t = Cartesian3.magnitudeSquared(Cartesian3.subtract(intersection, p0, cartesian3Scratch3));\n      t /= Cartesian3.magnitudeSquared(Cartesian3.subtract(p2, p0, cartesian3Scratch3));\n\n      if (defined(colors)) {\n        var c0 = Cartesian4.fromArray(colors, i0 * 4, cartesian4Scratch0);\n        var c2 = Cartesian4.fromArray(colors, i2 * 4, cartesian4Scratch0);\n        var r = CesiumMath.lerp(c0.x, c2.x, t);\n        var g = CesiumMath.lerp(c0.y, c2.y, t);\n        var b = CesiumMath.lerp(c0.z, c2.z, t);\n        var a = CesiumMath.lerp(c0.w, c2.w, t);\n\n        for (j = i0 * 4; j < i0 * 4 + 2 * 4; ++j) {\n          p0Attributes.color.values.push(colors[j]);\n        }\n\n        p0Attributes.color.values.push(r, g, b, a);\n        p0Attributes.color.values.push(r, g, b, a);\n        p2Attributes.color.values.push(r, g, b, a);\n        p2Attributes.color.values.push(r, g, b, a);\n\n        for (j = i2 * 4; j < i2 * 4 + 2 * 4; ++j) {\n          p2Attributes.color.values.push(colors[j]);\n        }\n      }\n\n      if (defined(texCoords)) {\n        var s0 = Cartesian2.fromArray(texCoords, i0 * 2, cartesian2Scratch0);\n        var s3 = Cartesian2.fromArray(texCoords, (i + 3) * 2, cartesian2Scratch1);\n        var sx = CesiumMath.lerp(s0.x, s3.x, t);\n\n        for (j = i0 * 2; j < i0 * 2 + 2 * 2; ++j) {\n          p0Attributes.st.values.push(texCoords[j]);\n        }\n\n        p0Attributes.st.values.push(sx, s0.y);\n        p0Attributes.st.values.push(sx, s3.y);\n        p2Attributes.st.values.push(sx, s0.y);\n        p2Attributes.st.values.push(sx, s3.y);\n\n        for (j = i2 * 2; j < i2 * 2 + 2 * 2; ++j) {\n          p2Attributes.st.values.push(texCoords[j]);\n        }\n      }\n\n      index = p0Attributes.position.values.length / 3 - 4;\n      p0Indices.push(index, index + 2, index + 1);\n      p0Indices.push(index + 1, index + 2, index + 3);\n      index = p2Attributes.position.values.length / 3 - 4;\n      p2Indices.push(index, index + 2, index + 1);\n      p2Indices.push(index + 1, index + 2, index + 3);\n    } else {\n      var currentAttributes;\n      var currentIndices;\n\n      if (p0.y < 0.0) {\n        currentAttributes = westGeometry.attributes;\n        currentIndices = westGeometry.indices;\n      } else {\n        currentAttributes = eastGeometry.attributes;\n        currentIndices = eastGeometry.indices;\n      }\n\n      currentAttributes.position.values.push(p0.x, p0.y, p0.z);\n      currentAttributes.position.values.push(p0.x, p0.y, p0.z);\n      currentAttributes.position.values.push(p2.x, p2.y, p2.z);\n      currentAttributes.position.values.push(p2.x, p2.y, p2.z);\n\n      for (j = i * 3; j < i * 3 + 4 * 3; ++j) {\n        currentAttributes.prevPosition.values.push(prevPositions[j]);\n        currentAttributes.nextPosition.values.push(nextPositions[j]);\n      }\n\n      for (j = i * 2; j < i * 2 + 4 * 2; ++j) {\n        currentAttributes.expandAndWidth.values.push(expandAndWidths[j]);\n\n        if (defined(texCoords)) {\n          currentAttributes.st.values.push(texCoords[j]);\n        }\n      }\n\n      if (defined(colors)) {\n        for (j = i * 4; j < i * 4 + 4 * 4; ++j) {\n          currentAttributes.color.values.push(colors[j]);\n        }\n      }\n\n      index = currentAttributes.position.values.length / 3 - 4;\n      currentIndices.push(index, index + 2, index + 1);\n      currentIndices.push(index + 1, index + 2, index + 3);\n    }\n  }\n\n  if (intersectionFound) {\n    updateAdjacencyAfterSplit(westGeometry);\n    updateAdjacencyAfterSplit(eastGeometry);\n  }\n\n  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\n}\n/**\n * Splits the instances's geometry, by introducing new vertices and indices,that\n * intersect the International Date Line and Prime Meridian so that no primitives cross longitude\n * -180/180 degrees.  This is not required for 3D drawing, but is required for\n * correcting drawing in 2D and Columbus view.\n *\n * @private\n *\n * @param {GeometryInstance} instance The instance to modify.\n * @returns {GeometryInstance} The modified <code>instance</code> argument, with it's geometry split at the International Date Line.\n *\n * @example\n * instance = Cesium.GeometryPipeline.splitLongitude(instance);\n */\n\n\nGeometryPipeline.splitLongitude = function (instance) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(instance)) {\n    throw new DeveloperError(\"instance is required.\");\n  } //>>includeEnd('debug');\n\n\n  var geometry = instance.geometry;\n  var boundingSphere = geometry.boundingSphere;\n\n  if (defined(boundingSphere)) {\n    var minX = boundingSphere.center.x - boundingSphere.radius;\n\n    if (minX > 0 || BoundingSphere.intersectPlane(boundingSphere, Plane.ORIGIN_ZX_PLANE) !== Intersect.INTERSECTING) {\n      return instance;\n    }\n  }\n\n  if (geometry.geometryType !== GeometryType.NONE) {\n    switch (geometry.geometryType) {\n      case GeometryType.POLYLINES:\n        splitLongitudePolyline(instance);\n        break;\n\n      case GeometryType.TRIANGLES:\n        splitLongitudeTriangles(instance);\n        break;\n\n      case GeometryType.LINES:\n        splitLongitudeLines(instance);\n        break;\n    }\n  } else {\n    indexPrimitive(geometry);\n\n    if (geometry.primitiveType === PrimitiveType.TRIANGLES) {\n      splitLongitudeTriangles(instance);\n    } else if (geometry.primitiveType === PrimitiveType.LINES) {\n      splitLongitudeLines(instance);\n    }\n  }\n\n  return instance;\n};\n\nexport default GeometryPipeline;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/GeometryPipeline.js"],"names":["AttributeCompression","barycentricCoordinates","BoundingSphere","Cartesian2","Cartesian3","Cartesian4","Cartographic","ComponentDatatype","defaultValue","defined","DeveloperError","EncodedCartesian3","GeographicProjection","Geometry","GeometryAttribute","GeometryType","IndexDatatype","Intersect","IntersectionTests","CesiumMath","Matrix3","Matrix4","Plane","PrimitiveType","Tipsify","GeometryPipeline","addTriangle","lines","index","i0","i1","i2","trianglesToLines","triangles","count","length","size","createTypedArray","i","triangleStripToLines","Uint16Array","triangleFanToLines","base","toWireframe","geometry","indices","primitiveType","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","LINES","createLineSegmentsForVectors","attributeName","attributes","position","positions","values","vectors","positionsLength","newPositions","Float64Array","j","newBoundingSphere","bs","boundingSphere","center","radius","componentDatatype","DOUBLE","componentsPerAttribute","createAttributeLocations","semantics","len","semantic","name","hasOwnProperty","reorderForPreVertexCache","numVertices","computeNumberOfVertices","indexCrossReferenceOldToNew","Int32Array","indicesIn","numIndices","indicesOut","intoIndicesIn","intoIndicesOut","nextIndex","tempIndex","property","attribute","elementsIn","intoElementsIn","numComponents","elementsOut","temp","reorderForPostVertexCache","cacheCapacity","maximumIndex","tipsify","cacheSize","copyAttributesDescriptions","newAttributes","attr","normalize","copyVertex","destinationAttributes","sourceAttributes","k","push","fitToUnsignedShortIndices","POINTS","geometries","numberOfVertices","SIXTY_FOUR_KILOBYTES","oldToNewIndex","newIndices","currentIndex","originalIndices","numberOfIndices","indicesPerPrimitive","x","boundingSphereCV","scratchProjectTo2DCartesian3","scratchProjectTo2DCartographic","projectTo2D","attributeName3D","attributeName2D","projection","ellipsoid","values3D","projectedValues","value","fromArray","lonLat","cartesianToCartographic","y","z","projectedLonLat","project","encodedResult","high","low","encodeAttribute","attributeHighName","attributeLowName","highValues","Float32Array","lowValues","encode","FLOAT","scratchCartesian3","transformPoint","matrix","unpack","multiplyByPoint","pack","transformVector","multiplyByVector","inverseTranspose","normalMatrix","transformToWorldCoordinates","instance","modelMatrix","equals","IDENTITY","prevPosition","nextPosition","normal","tangent","bitangent","inverse","transpose","getMatrix3","transform","clone","findAttributesInAllGeometries","instances","propertyName","attributesInAllGeometries","attributes0","numberOfComponents","inAllGeometries","otherAttribute","tempScratch","combineGeometries","m","haveIndices","sourceValues","sourceValuesLength","destIndices","destOffset","offset","sourceIndices","sourceIndicesLen","undefined","add","divideByScalar","tempRadius","magnitude","subtract","combineInstances","instanceGeometry","instanceSplitGeometry","westHemisphereGeometry","eastHemisphereGeometry","v0","v1","v2","computeNormal","vertices","normalsPerVertex","Array","normalsPerTriangle","normalIndices","indexOffset","currentCount","i03","i13","i23","cross","vertexNormalData","normalValues","i3","ZERO","equalsEpsilon","EPSILON10","normalScratch","normalScale","tScratch","computeTangentAndBitangent","st","normals","tan1","i02","i12","i22","ux","uy","uz","wx","wy","t1","t2","r","sdirx","sdiry","sdirz","tangentValues","bitangentValues","n","t","scalar","dot","multiplyByScalar","scratchCartesian2","toEncode1","toEncode2","toEncode3","encodeResult2","compressVertices","extrudeAttribute","extrudeDirection","extrudeDirections","compressedDirections","octEncodeInRange","compressedAttributes","normalAttribute","stAttribute","hasNormal","hasSt","tangentAttribute","bitangentAttribute","hasTangent","hasBitangent","tangents","bitangents","compressedLength","numCompressedComponents","normalIndex","compressTextureCoordinates","octPack","octEncodeFloat","indexTriangles","indexTriangleFan","indicesIndex","indexTriangleStrip","indexLines","indexLineStrip","indexLineLoop","indexPrimitive","LINE_STRIP","LINE_LOOP","offsetPointFromXZPlane","p","isBehind","Math","abs","EPSILON6","offsetTriangleFromXZPlane","p0","p1","p2","p0y","p1y","p2y","sign","c3","getXZIntersectionOffsetPoints","u1","u2","q1","q2","splitTriangleResult","splitTriangle","p0Behind","p1Behind","p2Behind","numBehind","updateGeometryAfterSplit","computeBoundingSphere","fromVertices","copyGeometryForSplit","copiedAttributes","updateInstanceAfterSplit","westGeometry","eastGeometry","generateBarycentricInterpolateFunction","CartesianType","v0Scratch","v1Scratch","v2Scratch","coords","currentValues","insertedIndex","interpolateAndPackCartesian4","interpolateAndPackCartesian3","interpolateAndPackCartesian2","interpolateAndPackBoolean","v3","p0Scratch","p1Scratch","p2Scratch","barycentricScratch","computeTriangleAttributes","point","texCoords","applyOffset","currentAttributes","customAttributeNames","customAttributesLength","allAttributes","d0","d1","d2","direction","genericInterpolate","sourceAttribute","currentAttribute","insertSplitPoint","currentIndices","currentIndexMap","insertIndex","prevIndex","newIndex","NAMED_ATTRIBUTES","splitLongitudeTriangles","westGeometryIndexMap","eastGeometryIndexMap","result","resultPositions","resultIndices","resultLength","resultIndex","xzPlane","fromPointNormal","UNIT_Y","offsetScratch","offsetPointScratch","computeLineAttributes","splitLongitudeLines","p0Attributes","p0Indices","p0IndexMap","p1Attributes","p1Indices","p1IndexMap","intersection","lineSegmentPlane","EPSILON9","negate","offsetPoint","cartesian2Scratch0","cartesian2Scratch1","cartesian3Scratch0","cartesian3Scratch2","cartesian3Scratch3","cartesian3Scratch4","cartesian3Scratch5","cartesian3Scratch6","cartesian4Scratch0","updateAdjacencyAfterSplit","prevPositions","nextPositions","offsetScalar","coplanarOffset","splitLongitudePolyline","expandAndWidths","expandAndWidth","colors","color","intersectionFound","p2Attributes","p2Indices","ew0","width","magnitudeSquared","c0","c2","lerp","g","b","a","w","s0","s3","sx","splitLongitude","minX","intersectPlane","ORIGIN_ZX_PLANE","INTERSECTING","geometryType","NONE","POLYLINES"],"mappings":"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","sourcesContent":["import AttributeCompression from \"./AttributeCompression.js\";\nimport barycentricCoordinates from \"./barycentricCoordinates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport EncodedCartesian3 from \"./EncodedCartesian3.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryType from \"./GeometryType.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport Intersect from \"./Intersect.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Tipsify from \"./Tipsify.js\";\n\n/**\n * Content pipeline functions for geometries.\n *\n * @exports GeometryPipeline\n *\n * @see Geometry\n */\nvar GeometryPipeline = {};\n\nfunction addTriangle(lines, index, i0, i1, i2) {\n  lines[index++] = i0;\n  lines[index++] = i1;\n\n  lines[index++] = i1;\n  lines[index++] = i2;\n\n  lines[index++] = i2;\n  lines[index] = i0;\n}\n\nfunction trianglesToLines(triangles) {\n  var count = triangles.length;\n  var size = (count / 3) * 6;\n  var lines = IndexDatatype.createTypedArray(count, size);\n\n  var index = 0;\n  for (var i = 0; i < count; i += 3, index += 6) {\n    addTriangle(lines, index, triangles[i], triangles[i + 1], triangles[i + 2]);\n  }\n\n  return lines;\n}\n\nfunction triangleStripToLines(triangles) {\n  var count = triangles.length;\n  if (count >= 3) {\n    var size = (count - 2) * 6;\n    var lines = IndexDatatype.createTypedArray(count, size);\n\n    addTriangle(lines, 0, triangles[0], triangles[1], triangles[2]);\n    var index = 6;\n\n    for (var i = 3; i < count; ++i, index += 6) {\n      addTriangle(\n        lines,\n        index,\n        triangles[i - 1],\n        triangles[i],\n        triangles[i - 2]\n      );\n    }\n\n    return lines;\n  }\n\n  return new Uint16Array();\n}\n\nfunction triangleFanToLines(triangles) {\n  if (triangles.length > 0) {\n    var count = triangles.length - 1;\n    var size = (count - 1) * 6;\n    var lines = IndexDatatype.createTypedArray(count, size);\n\n    var base = triangles[0];\n    var index = 0;\n    for (var i = 1; i < count; ++i, index += 6) {\n      addTriangle(lines, index, base, triangles[i], triangles[i + 1]);\n    }\n\n    return lines;\n  }\n\n  return new Uint16Array();\n}\n\n/**\n * Converts a geometry's triangle indices to line indices.  If the geometry has an <code>indices</code>\n * and its <code>primitiveType</code> is <code>TRIANGLES</code>, <code>TRIANGLE_STRIP</code>,\n * <code>TRIANGLE_FAN</code>, it is converted to <code>LINES</code>; otherwise, the geometry is not changed.\n * <p>\n * This is commonly used to create a wireframe geometry for visual debugging.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its triangle indices converted to lines.\n *\n * @exception {DeveloperError} geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.toWireframe(geometry);\n */\nGeometryPipeline.toWireframe = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var indices = geometry.indices;\n  if (defined(indices)) {\n    switch (geometry.primitiveType) {\n      case PrimitiveType.TRIANGLES:\n        geometry.indices = trianglesToLines(indices);\n        break;\n      case PrimitiveType.TRIANGLE_STRIP:\n        geometry.indices = triangleStripToLines(indices);\n        break;\n      case PrimitiveType.TRIANGLE_FAN:\n        geometry.indices = triangleFanToLines(indices);\n        break;\n      //>>includeStart('debug', pragmas.debug);\n      default:\n        throw new DeveloperError(\n          \"geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.\"\n        );\n      //>>includeEnd('debug');\n    }\n\n    geometry.primitiveType = PrimitiveType.LINES;\n  }\n\n  return geometry;\n};\n\n/**\n * Creates a new {@link Geometry} with <code>LINES</code> representing the provided\n * attribute (<code>attributeName</code>) for the provided geometry.  This is used to\n * visualize vector attributes like normals, tangents, and bitangents.\n *\n * @param {Geometry} geometry The <code>Geometry</code> instance with the attribute.\n * @param {String} [attributeName='normal'] The name of the attribute.\n * @param {Number} [length=10000.0] The length of each line segment in meters.  This can be negative to point the vector in the opposite direction.\n * @returns {Geometry} A new <code>Geometry</code> instance with line segments for the vector.\n *\n * @exception {DeveloperError} geometry.attributes must have an attribute with the same name as the attributeName parameter.\n *\n * @example\n * var geometry = Cesium.GeometryPipeline.createLineSegmentsForVectors(instance.geometry, 'bitangent', 100000.0);\n */\nGeometryPipeline.createLineSegmentsForVectors = function (\n  geometry,\n  attributeName,\n  length\n) {\n  attributeName = defaultValue(attributeName, \"normal\");\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (!defined(geometry.attributes.position)) {\n    throw new DeveloperError(\"geometry.attributes.position is required.\");\n  }\n  if (!defined(geometry.attributes[attributeName])) {\n    throw new DeveloperError(\n      \"geometry.attributes must have an attribute with the same name as the attributeName parameter, \" +\n        attributeName +\n        \".\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  length = defaultValue(length, 10000.0);\n\n  var positions = geometry.attributes.position.values;\n  var vectors = geometry.attributes[attributeName].values;\n  var positionsLength = positions.length;\n\n  var newPositions = new Float64Array(2 * positionsLength);\n\n  var j = 0;\n  for (var i = 0; i < positionsLength; i += 3) {\n    newPositions[j++] = positions[i];\n    newPositions[j++] = positions[i + 1];\n    newPositions[j++] = positions[i + 2];\n\n    newPositions[j++] = positions[i] + vectors[i] * length;\n    newPositions[j++] = positions[i + 1] + vectors[i + 1] * length;\n    newPositions[j++] = positions[i + 2] + vectors[i + 2] * length;\n  }\n\n  var newBoundingSphere;\n  var bs = geometry.boundingSphere;\n  if (defined(bs)) {\n    newBoundingSphere = new BoundingSphere(bs.center, bs.radius + length);\n  }\n\n  return new Geometry({\n    attributes: {\n      position: new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: newPositions,\n      }),\n    },\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: newBoundingSphere,\n  });\n};\n\n/**\n * Creates an object that maps attribute names to unique locations (indices)\n * for matching vertex attributes and shader programs.\n *\n * @param {Geometry} geometry The geometry, which is not modified, to create the object for.\n * @returns {Object} An object with attribute name / index pairs.\n *\n * @example\n * var attributeLocations = Cesium.GeometryPipeline.createAttributeLocations(geometry);\n * // Example output\n * // {\n * //   'position' : 0,\n * //   'normal' : 1\n * // }\n */\nGeometryPipeline.createAttributeLocations = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug')\n\n  // There can be a WebGL performance hit when attribute 0 is disabled, so\n  // assign attribute locations to well-known attributes.\n  var semantics = [\n    \"position\",\n    \"positionHigh\",\n    \"positionLow\",\n\n    // From VertexFormat.position - after 2D projection and high-precision encoding\n    \"position3DHigh\",\n    \"position3DLow\",\n    \"position2DHigh\",\n    \"position2DLow\",\n\n    // From Primitive\n    \"pickColor\",\n\n    // From VertexFormat\n    \"normal\",\n    \"st\",\n    \"tangent\",\n    \"bitangent\",\n\n    // For shadow volumes\n    \"extrudeDirection\",\n\n    // From compressing texture coordinates and normals\n    \"compressedAttributes\",\n  ];\n\n  var attributes = geometry.attributes;\n  var indices = {};\n  var j = 0;\n  var i;\n  var len = semantics.length;\n\n  // Attribute locations for well-known attributes\n  for (i = 0; i < len; ++i) {\n    var semantic = semantics[i];\n\n    if (defined(attributes[semantic])) {\n      indices[semantic] = j++;\n    }\n  }\n\n  // Locations for custom attributes\n  for (var name in attributes) {\n    if (attributes.hasOwnProperty(name) && !defined(indices[name])) {\n      indices[name] = j++;\n    }\n  }\n\n  return indices;\n};\n\n/**\n * Reorders a geometry's attributes and <code>indices</code> to achieve better performance from the GPU's pre-vertex-shader cache.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its attributes and indices reordered for the GPU's pre-vertex-shader cache.\n *\n * @exception {DeveloperError} Each attribute array in geometry.attributes must have the same number of attributes.\n *\n *\n * @example\n * geometry = Cesium.GeometryPipeline.reorderForPreVertexCache(geometry);\n *\n * @see GeometryPipeline.reorderForPostVertexCache\n */\nGeometryPipeline.reorderForPreVertexCache = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var numVertices = Geometry.computeNumberOfVertices(geometry);\n\n  var indices = geometry.indices;\n  if (defined(indices)) {\n    var indexCrossReferenceOldToNew = new Int32Array(numVertices);\n    for (var i = 0; i < numVertices; i++) {\n      indexCrossReferenceOldToNew[i] = -1;\n    }\n\n    // Construct cross reference and reorder indices\n    var indicesIn = indices;\n    var numIndices = indicesIn.length;\n    var indicesOut = IndexDatatype.createTypedArray(numVertices, numIndices);\n\n    var intoIndicesIn = 0;\n    var intoIndicesOut = 0;\n    var nextIndex = 0;\n    var tempIndex;\n    while (intoIndicesIn < numIndices) {\n      tempIndex = indexCrossReferenceOldToNew[indicesIn[intoIndicesIn]];\n      if (tempIndex !== -1) {\n        indicesOut[intoIndicesOut] = tempIndex;\n      } else {\n        tempIndex = indicesIn[intoIndicesIn];\n        indexCrossReferenceOldToNew[tempIndex] = nextIndex;\n\n        indicesOut[intoIndicesOut] = nextIndex;\n        ++nextIndex;\n      }\n      ++intoIndicesIn;\n      ++intoIndicesOut;\n    }\n    geometry.indices = indicesOut;\n\n    // Reorder attributes\n    var attributes = geometry.attributes;\n    for (var property in attributes) {\n      if (\n        attributes.hasOwnProperty(property) &&\n        defined(attributes[property]) &&\n        defined(attributes[property].values)\n      ) {\n        var attribute = attributes[property];\n        var elementsIn = attribute.values;\n        var intoElementsIn = 0;\n        var numComponents = attribute.componentsPerAttribute;\n        var elementsOut = ComponentDatatype.createTypedArray(\n          attribute.componentDatatype,\n          nextIndex * numComponents\n        );\n        while (intoElementsIn < numVertices) {\n          var temp = indexCrossReferenceOldToNew[intoElementsIn];\n          if (temp !== -1) {\n            for (var j = 0; j < numComponents; j++) {\n              elementsOut[numComponents * temp + j] =\n                elementsIn[numComponents * intoElementsIn + j];\n            }\n          }\n          ++intoElementsIn;\n        }\n        attribute.values = elementsOut;\n      }\n    }\n  }\n\n  return geometry;\n};\n\n/**\n * Reorders a geometry's <code>indices</code> to achieve better performance from the GPU's\n * post vertex-shader cache by using the Tipsify algorithm.  If the geometry <code>primitiveType</code>\n * is not <code>TRIANGLES</code> or the geometry does not have an <code>indices</code>, this function has no effect.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @param {Number} [cacheCapacity=24] The number of vertices that can be held in the GPU's vertex cache.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its indices reordered for the post-vertex-shader cache.\n *\n * @exception {DeveloperError} cacheCapacity must be greater than two.\n *\n *\n * @example\n * geometry = Cesium.GeometryPipeline.reorderForPostVertexCache(geometry);\n *\n * @see GeometryPipeline.reorderForPreVertexCache\n * @see {@link http://gfx.cs.princ0eton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf|Fast Triangle Reordering for Vertex Locality and Reduced Overdraw}\n * by Sander, Nehab, and Barczak\n */\nGeometryPipeline.reorderForPostVertexCache = function (\n  geometry,\n  cacheCapacity\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var indices = geometry.indices;\n  if (geometry.primitiveType === PrimitiveType.TRIANGLES && defined(indices)) {\n    var numIndices = indices.length;\n    var maximumIndex = 0;\n    for (var j = 0; j < numIndices; j++) {\n      if (indices[j] > maximumIndex) {\n        maximumIndex = indices[j];\n      }\n    }\n    geometry.indices = Tipsify.tipsify({\n      indices: indices,\n      maximumIndex: maximumIndex,\n      cacheSize: cacheCapacity,\n    });\n  }\n\n  return geometry;\n};\n\nfunction copyAttributesDescriptions(attributes) {\n  var newAttributes = {};\n\n  for (var attribute in attributes) {\n    if (\n      attributes.hasOwnProperty(attribute) &&\n      defined(attributes[attribute]) &&\n      defined(attributes[attribute].values)\n    ) {\n      var attr = attributes[attribute];\n      newAttributes[attribute] = new GeometryAttribute({\n        componentDatatype: attr.componentDatatype,\n        componentsPerAttribute: attr.componentsPerAttribute,\n        normalize: attr.normalize,\n        values: [],\n      });\n    }\n  }\n\n  return newAttributes;\n}\n\nfunction copyVertex(destinationAttributes, sourceAttributes, index) {\n  for (var attribute in sourceAttributes) {\n    if (\n      sourceAttributes.hasOwnProperty(attribute) &&\n      defined(sourceAttributes[attribute]) &&\n      defined(sourceAttributes[attribute].values)\n    ) {\n      var attr = sourceAttributes[attribute];\n\n      for (var k = 0; k < attr.componentsPerAttribute; ++k) {\n        destinationAttributes[attribute].values.push(\n          attr.values[index * attr.componentsPerAttribute + k]\n        );\n      }\n    }\n  }\n}\n\n/**\n * Splits a geometry into multiple geometries, if necessary, to ensure that indices in the\n * <code>indices</code> fit into unsigned shorts.  This is used to meet the WebGL requirements\n * when unsigned int indices are not supported.\n * <p>\n * If the geometry does not have any <code>indices</code>, this function has no effect.\n * </p>\n *\n * @param {Geometry} geometry The geometry to be split into multiple geometries.\n * @returns {Geometry[]} An array of geometries, each with indices that fit into unsigned shorts.\n *\n * @exception {DeveloperError} geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS\n * @exception {DeveloperError} All geometry attribute lists must have the same number of attributes.\n *\n * @example\n * var geometries = Cesium.GeometryPipeline.fitToUnsignedShortIndices(geometry);\n */\nGeometryPipeline.fitToUnsignedShortIndices = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (\n    defined(geometry.indices) &&\n    geometry.primitiveType !== PrimitiveType.TRIANGLES &&\n    geometry.primitiveType !== PrimitiveType.LINES &&\n    geometry.primitiveType !== PrimitiveType.POINTS\n  ) {\n    throw new DeveloperError(\n      \"geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var geometries = [];\n\n  // If there's an index list and more than 64K attributes, it is possible that\n  // some indices are outside the range of unsigned short [0, 64K - 1]\n  var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n  if (\n    defined(geometry.indices) &&\n    numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES\n  ) {\n    var oldToNewIndex = [];\n    var newIndices = [];\n    var currentIndex = 0;\n    var newAttributes = copyAttributesDescriptions(geometry.attributes);\n\n    var originalIndices = geometry.indices;\n    var numberOfIndices = originalIndices.length;\n\n    var indicesPerPrimitive;\n\n    if (geometry.primitiveType === PrimitiveType.TRIANGLES) {\n      indicesPerPrimitive = 3;\n    } else if (geometry.primitiveType === PrimitiveType.LINES) {\n      indicesPerPrimitive = 2;\n    } else if (geometry.primitiveType === PrimitiveType.POINTS) {\n      indicesPerPrimitive = 1;\n    }\n\n    for (var j = 0; j < numberOfIndices; j += indicesPerPrimitive) {\n      for (var k = 0; k < indicesPerPrimitive; ++k) {\n        var x = originalIndices[j + k];\n        var i = oldToNewIndex[x];\n        if (!defined(i)) {\n          i = currentIndex++;\n          oldToNewIndex[x] = i;\n          copyVertex(newAttributes, geometry.attributes, x);\n        }\n        newIndices.push(i);\n      }\n\n      if (\n        currentIndex + indicesPerPrimitive >=\n        CesiumMath.SIXTY_FOUR_KILOBYTES\n      ) {\n        geometries.push(\n          new Geometry({\n            attributes: newAttributes,\n            indices: newIndices,\n            primitiveType: geometry.primitiveType,\n            boundingSphere: geometry.boundingSphere,\n            boundingSphereCV: geometry.boundingSphereCV,\n          })\n        );\n\n        // Reset for next vertex-array\n        oldToNewIndex = [];\n        newIndices = [];\n        currentIndex = 0;\n        newAttributes = copyAttributesDescriptions(geometry.attributes);\n      }\n    }\n\n    if (newIndices.length !== 0) {\n      geometries.push(\n        new Geometry({\n          attributes: newAttributes,\n          indices: newIndices,\n          primitiveType: geometry.primitiveType,\n          boundingSphere: geometry.boundingSphere,\n          boundingSphereCV: geometry.boundingSphereCV,\n        })\n      );\n    }\n  } else {\n    // No need to split into multiple geometries\n    geometries.push(geometry);\n  }\n\n  return geometries;\n};\n\nvar scratchProjectTo2DCartesian3 = new Cartesian3();\nvar scratchProjectTo2DCartographic = new Cartographic();\n\n/**\n * Projects a geometry's 3D <code>position</code> attribute to 2D, replacing the <code>position</code>\n * attribute with separate <code>position3D</code> and <code>position2D</code> attributes.\n * <p>\n * If the geometry does not have a <code>position</code>, this function has no effect.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @param {String} attributeName The name of the attribute.\n * @param {String} attributeName3D The name of the attribute in 3D.\n * @param {String} attributeName2D The name of the attribute in 2D.\n * @param {Object} [projection=new GeographicProjection()] The projection to use.\n * @returns {Geometry} The modified <code>geometry</code> argument with <code>position3D</code> and <code>position2D</code> attributes.\n *\n * @exception {DeveloperError} geometry must have attribute matching the attributeName argument.\n * @exception {DeveloperError} The attribute componentDatatype must be ComponentDatatype.DOUBLE.\n * @exception {DeveloperError} Could not project a point to 2D.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.projectTo2D(geometry, 'position', 'position3D', 'position2D');\n */\nGeometryPipeline.projectTo2D = function (\n  geometry,\n  attributeName,\n  attributeName3D,\n  attributeName2D,\n  projection\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (!defined(attributeName)) {\n    throw new DeveloperError(\"attributeName is required.\");\n  }\n  if (!defined(attributeName3D)) {\n    throw new DeveloperError(\"attributeName3D is required.\");\n  }\n  if (!defined(attributeName2D)) {\n    throw new DeveloperError(\"attributeName2D is required.\");\n  }\n  if (!defined(geometry.attributes[attributeName])) {\n    throw new DeveloperError(\n      \"geometry must have attribute matching the attributeName argument: \" +\n        attributeName +\n        \".\"\n    );\n  }\n  if (\n    geometry.attributes[attributeName].componentDatatype !==\n    ComponentDatatype.DOUBLE\n  ) {\n    throw new DeveloperError(\n      \"The attribute componentDatatype must be ComponentDatatype.DOUBLE.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var attribute = geometry.attributes[attributeName];\n  projection = defined(projection) ? projection : new GeographicProjection();\n  var ellipsoid = projection.ellipsoid;\n\n  // Project original values to 2D.\n  var values3D = attribute.values;\n  var projectedValues = new Float64Array(values3D.length);\n  var index = 0;\n\n  for (var i = 0; i < values3D.length; i += 3) {\n    var value = Cartesian3.fromArray(values3D, i, scratchProjectTo2DCartesian3);\n\n    var lonLat = ellipsoid.cartesianToCartographic(\n      value,\n      scratchProjectTo2DCartographic\n    );\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(lonLat)) {\n      throw new DeveloperError(\n        \"Could not project point (\" +\n          value.x +\n          \", \" +\n          value.y +\n          \", \" +\n          value.z +\n          \") to 2D.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    var projectedLonLat = projection.project(\n      lonLat,\n      scratchProjectTo2DCartesian3\n    );\n\n    projectedValues[index++] = projectedLonLat.x;\n    projectedValues[index++] = projectedLonLat.y;\n    projectedValues[index++] = projectedLonLat.z;\n  }\n\n  // Rename original cartesians to WGS84 cartesians.\n  geometry.attributes[attributeName3D] = attribute;\n\n  // Replace original cartesians with 2D projected cartesians\n  geometry.attributes[attributeName2D] = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: projectedValues,\n  });\n  delete geometry.attributes[attributeName];\n\n  return geometry;\n};\n\nvar encodedResult = {\n  high: 0.0,\n  low: 0.0,\n};\n\n/**\n * Encodes floating-point geometry attribute values as two separate attributes to improve\n * rendering precision.\n * <p>\n * This is commonly used to create high-precision position vertex attributes.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @param {String} attributeName The name of the attribute.\n * @param {String} attributeHighName The name of the attribute for the encoded high bits.\n * @param {String} attributeLowName The name of the attribute for the encoded low bits.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its encoded attribute.\n *\n * @exception {DeveloperError} geometry must have attribute matching the attributeName argument.\n * @exception {DeveloperError} The attribute componentDatatype must be ComponentDatatype.DOUBLE.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.encodeAttribute(geometry, 'position3D', 'position3DHigh', 'position3DLow');\n */\nGeometryPipeline.encodeAttribute = function (\n  geometry,\n  attributeName,\n  attributeHighName,\n  attributeLowName\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (!defined(attributeName)) {\n    throw new DeveloperError(\"attributeName is required.\");\n  }\n  if (!defined(attributeHighName)) {\n    throw new DeveloperError(\"attributeHighName is required.\");\n  }\n  if (!defined(attributeLowName)) {\n    throw new DeveloperError(\"attributeLowName is required.\");\n  }\n  if (!defined(geometry.attributes[attributeName])) {\n    throw new DeveloperError(\n      \"geometry must have attribute matching the attributeName argument: \" +\n        attributeName +\n        \".\"\n    );\n  }\n  if (\n    geometry.attributes[attributeName].componentDatatype !==\n    ComponentDatatype.DOUBLE\n  ) {\n    throw new DeveloperError(\n      \"The attribute componentDatatype must be ComponentDatatype.DOUBLE.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var attribute = geometry.attributes[attributeName];\n  var values = attribute.values;\n  var length = values.length;\n  var highValues = new Float32Array(length);\n  var lowValues = new Float32Array(length);\n\n  for (var i = 0; i < length; ++i) {\n    EncodedCartesian3.encode(values[i], encodedResult);\n    highValues[i] = encodedResult.high;\n    lowValues[i] = encodedResult.low;\n  }\n\n  var componentsPerAttribute = attribute.componentsPerAttribute;\n\n  geometry.attributes[attributeHighName] = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: componentsPerAttribute,\n    values: highValues,\n  });\n  geometry.attributes[attributeLowName] = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: componentsPerAttribute,\n    values: lowValues,\n  });\n  delete geometry.attributes[attributeName];\n\n  return geometry;\n};\n\nvar scratchCartesian3 = new Cartesian3();\n\nfunction transformPoint(matrix, attribute) {\n  if (defined(attribute)) {\n    var values = attribute.values;\n    var length = values.length;\n    for (var i = 0; i < length; i += 3) {\n      Cartesian3.unpack(values, i, scratchCartesian3);\n      Matrix4.multiplyByPoint(matrix, scratchCartesian3, scratchCartesian3);\n      Cartesian3.pack(scratchCartesian3, values, i);\n    }\n  }\n}\n\nfunction transformVector(matrix, attribute) {\n  if (defined(attribute)) {\n    var values = attribute.values;\n    var length = values.length;\n    for (var i = 0; i < length; i += 3) {\n      Cartesian3.unpack(values, i, scratchCartesian3);\n      Matrix3.multiplyByVector(matrix, scratchCartesian3, scratchCartesian3);\n      scratchCartesian3 = Cartesian3.normalize(\n        scratchCartesian3,\n        scratchCartesian3\n      );\n      Cartesian3.pack(scratchCartesian3, values, i);\n    }\n  }\n}\n\nvar inverseTranspose = new Matrix4();\nvar normalMatrix = new Matrix3();\n\n/**\n * Transforms a geometry instance to world coordinates.  This changes\n * the instance's <code>modelMatrix</code> to {@link Matrix4.IDENTITY} and transforms the\n * following attributes if they are present: <code>position</code>, <code>normal</code>,\n * <code>tangent</code>, and <code>bitangent</code>.\n *\n * @param {GeometryInstance} instance The geometry instance to modify.\n * @returns {GeometryInstance} The modified <code>instance</code> argument, with its attributes transforms to world coordinates.\n *\n * @example\n * Cesium.GeometryPipeline.transformToWorldCoordinates(instance);\n */\nGeometryPipeline.transformToWorldCoordinates = function (instance) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(instance)) {\n    throw new DeveloperError(\"instance is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var modelMatrix = instance.modelMatrix;\n\n  if (Matrix4.equals(modelMatrix, Matrix4.IDENTITY)) {\n    // Already in world coordinates\n    return instance;\n  }\n\n  var attributes = instance.geometry.attributes;\n\n  // Transform attributes in known vertex formats\n  transformPoint(modelMatrix, attributes.position);\n  transformPoint(modelMatrix, attributes.prevPosition);\n  transformPoint(modelMatrix, attributes.nextPosition);\n\n  if (\n    defined(attributes.normal) ||\n    defined(attributes.tangent) ||\n    defined(attributes.bitangent)\n  ) {\n    Matrix4.inverse(modelMatrix, inverseTranspose);\n    Matrix4.transpose(inverseTranspose, inverseTranspose);\n    Matrix4.getMatrix3(inverseTranspose, normalMatrix);\n\n    transformVector(normalMatrix, attributes.normal);\n    transformVector(normalMatrix, attributes.tangent);\n    transformVector(normalMatrix, attributes.bitangent);\n  }\n\n  var boundingSphere = instance.geometry.boundingSphere;\n  if (defined(boundingSphere)) {\n    instance.geometry.boundingSphere = BoundingSphere.transform(\n      boundingSphere,\n      modelMatrix,\n      boundingSphere\n    );\n  }\n\n  instance.modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n\n  return instance;\n};\n\nfunction findAttributesInAllGeometries(instances, propertyName) {\n  var length = instances.length;\n\n  var attributesInAllGeometries = {};\n\n  var attributes0 = instances[0][propertyName].attributes;\n  var name;\n\n  for (name in attributes0) {\n    if (\n      attributes0.hasOwnProperty(name) &&\n      defined(attributes0[name]) &&\n      defined(attributes0[name].values)\n    ) {\n      var attribute = attributes0[name];\n      var numberOfComponents = attribute.values.length;\n      var inAllGeometries = true;\n\n      // Does this same attribute exist in all geometries?\n      for (var i = 1; i < length; ++i) {\n        var otherAttribute = instances[i][propertyName].attributes[name];\n\n        if (\n          !defined(otherAttribute) ||\n          attribute.componentDatatype !== otherAttribute.componentDatatype ||\n          attribute.componentsPerAttribute !==\n            otherAttribute.componentsPerAttribute ||\n          attribute.normalize !== otherAttribute.normalize\n        ) {\n          inAllGeometries = false;\n          break;\n        }\n\n        numberOfComponents += otherAttribute.values.length;\n      }\n\n      if (inAllGeometries) {\n        attributesInAllGeometries[name] = new GeometryAttribute({\n          componentDatatype: attribute.componentDatatype,\n          componentsPerAttribute: attribute.componentsPerAttribute,\n          normalize: attribute.normalize,\n          values: ComponentDatatype.createTypedArray(\n            attribute.componentDatatype,\n            numberOfComponents\n          ),\n        });\n      }\n    }\n  }\n\n  return attributesInAllGeometries;\n}\n\nvar tempScratch = new Cartesian3();\n\nfunction combineGeometries(instances, propertyName) {\n  var length = instances.length;\n\n  var name;\n  var i;\n  var j;\n  var k;\n\n  var m = instances[0].modelMatrix;\n  var haveIndices = defined(instances[0][propertyName].indices);\n  var primitiveType = instances[0][propertyName].primitiveType;\n\n  //>>includeStart('debug', pragmas.debug);\n  for (i = 1; i < length; ++i) {\n    if (!Matrix4.equals(instances[i].modelMatrix, m)) {\n      throw new DeveloperError(\"All instances must have the same modelMatrix.\");\n    }\n    if (defined(instances[i][propertyName].indices) !== haveIndices) {\n      throw new DeveloperError(\n        \"All instance geometries must have an indices or not have one.\"\n      );\n    }\n    if (instances[i][propertyName].primitiveType !== primitiveType) {\n      throw new DeveloperError(\n        \"All instance geometries must have the same primitiveType.\"\n      );\n    }\n  }\n  //>>includeEnd('debug');\n\n  // Find subset of attributes in all geometries\n  var attributes = findAttributesInAllGeometries(instances, propertyName);\n  var values;\n  var sourceValues;\n  var sourceValuesLength;\n\n  // Combine attributes from each geometry into a single typed array\n  for (name in attributes) {\n    if (attributes.hasOwnProperty(name)) {\n      values = attributes[name].values;\n\n      k = 0;\n      for (i = 0; i < length; ++i) {\n        sourceValues = instances[i][propertyName].attributes[name].values;\n        sourceValuesLength = sourceValues.length;\n\n        for (j = 0; j < sourceValuesLength; ++j) {\n          values[k++] = sourceValues[j];\n        }\n      }\n    }\n  }\n\n  // Combine index lists\n  var indices;\n\n  if (haveIndices) {\n    var numberOfIndices = 0;\n    for (i = 0; i < length; ++i) {\n      numberOfIndices += instances[i][propertyName].indices.length;\n    }\n\n    var numberOfVertices = Geometry.computeNumberOfVertices(\n      new Geometry({\n        attributes: attributes,\n        primitiveType: PrimitiveType.POINTS,\n      })\n    );\n    var destIndices = IndexDatatype.createTypedArray(\n      numberOfVertices,\n      numberOfIndices\n    );\n\n    var destOffset = 0;\n    var offset = 0;\n\n    for (i = 0; i < length; ++i) {\n      var sourceIndices = instances[i][propertyName].indices;\n      var sourceIndicesLen = sourceIndices.length;\n\n      for (k = 0; k < sourceIndicesLen; ++k) {\n        destIndices[destOffset++] = offset + sourceIndices[k];\n      }\n\n      offset += Geometry.computeNumberOfVertices(instances[i][propertyName]);\n    }\n\n    indices = destIndices;\n  }\n\n  // Create bounding sphere that includes all instances\n  var center = new Cartesian3();\n  var radius = 0.0;\n  var bs;\n\n  for (i = 0; i < length; ++i) {\n    bs = instances[i][propertyName].boundingSphere;\n    if (!defined(bs)) {\n      // If any geometries have an undefined bounding sphere, then so does the combined geometry\n      center = undefined;\n      break;\n    }\n\n    Cartesian3.add(bs.center, center, center);\n  }\n\n  if (defined(center)) {\n    Cartesian3.divideByScalar(center, length, center);\n\n    for (i = 0; i < length; ++i) {\n      bs = instances[i][propertyName].boundingSphere;\n      var tempRadius =\n        Cartesian3.magnitude(\n          Cartesian3.subtract(bs.center, center, tempScratch)\n        ) + bs.radius;\n\n      if (tempRadius > radius) {\n        radius = tempRadius;\n      }\n    }\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: primitiveType,\n    boundingSphere: defined(center)\n      ? new BoundingSphere(center, radius)\n      : undefined,\n  });\n}\n\n/**\n * Combines geometry from several {@link GeometryInstance} objects into one geometry.\n * This concatenates the attributes, concatenates and adjusts the indices, and creates\n * a bounding sphere encompassing all instances.\n * <p>\n * If the instances do not have the same attributes, a subset of attributes common\n * to all instances is used, and the others are ignored.\n * </p>\n * <p>\n * This is used by {@link Primitive} to efficiently render a large amount of static data.\n * </p>\n *\n * @private\n *\n * @param {GeometryInstance[]} [instances] The array of {@link GeometryInstance} objects whose geometry will be combined.\n * @returns {Geometry} A single geometry created from the provided geometry instances.\n *\n * @exception {DeveloperError} All instances must have the same modelMatrix.\n * @exception {DeveloperError} All instance geometries must have an indices or not have one.\n * @exception {DeveloperError} All instance geometries must have the same primitiveType.\n *\n *\n * @example\n * for (var i = 0; i < instances.length; ++i) {\n *   Cesium.GeometryPipeline.transformToWorldCoordinates(instances[i]);\n * }\n * var geometries = Cesium.GeometryPipeline.combineInstances(instances);\n *\n * @see GeometryPipeline.transformToWorldCoordinates\n */\nGeometryPipeline.combineInstances = function (instances) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(instances) || instances.length < 1) {\n    throw new DeveloperError(\n      \"instances is required and must have length greater than zero.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var instanceGeometry = [];\n  var instanceSplitGeometry = [];\n  var length = instances.length;\n  for (var i = 0; i < length; ++i) {\n    var instance = instances[i];\n\n    if (defined(instance.geometry)) {\n      instanceGeometry.push(instance);\n    } else if (\n      defined(instance.westHemisphereGeometry) &&\n      defined(instance.eastHemisphereGeometry)\n    ) {\n      instanceSplitGeometry.push(instance);\n    }\n  }\n\n  var geometries = [];\n  if (instanceGeometry.length > 0) {\n    geometries.push(combineGeometries(instanceGeometry, \"geometry\"));\n  }\n\n  if (instanceSplitGeometry.length > 0) {\n    geometries.push(\n      combineGeometries(instanceSplitGeometry, \"westHemisphereGeometry\")\n    );\n    geometries.push(\n      combineGeometries(instanceSplitGeometry, \"eastHemisphereGeometry\")\n    );\n  }\n\n  return geometries;\n};\n\nvar normal = new Cartesian3();\nvar v0 = new Cartesian3();\nvar v1 = new Cartesian3();\nvar v2 = new Cartesian3();\n\n/**\n * Computes per-vertex normals for a geometry containing <code>TRIANGLES</code> by averaging the normals of\n * all triangles incident to the vertex.  The result is a new <code>normal</code> attribute added to the geometry.\n * This assumes a counter-clockwise winding order.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument with the computed <code>normal</code> attribute.\n *\n * @exception {DeveloperError} geometry.indices length must be greater than 0 and be a multiple of 3.\n * @exception {DeveloperError} geometry.primitiveType must be {@link PrimitiveType.TRIANGLES}.\n *\n * @example\n * Cesium.GeometryPipeline.computeNormal(geometry);\n */\nGeometryPipeline.computeNormal = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (\n    !defined(geometry.attributes.position) ||\n    !defined(geometry.attributes.position.values)\n  ) {\n    throw new DeveloperError(\n      \"geometry.attributes.position.values is required.\"\n    );\n  }\n  if (!defined(geometry.indices)) {\n    throw new DeveloperError(\"geometry.indices is required.\");\n  }\n  if (geometry.indices.length < 2 || geometry.indices.length % 3 !== 0) {\n    throw new DeveloperError(\n      \"geometry.indices length must be greater than 0 and be a multiple of 3.\"\n    );\n  }\n  if (geometry.primitiveType !== PrimitiveType.TRIANGLES) {\n    throw new DeveloperError(\n      \"geometry.primitiveType must be PrimitiveType.TRIANGLES.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var indices = geometry.indices;\n  var attributes = geometry.attributes;\n  var vertices = attributes.position.values;\n  var numVertices = attributes.position.values.length / 3;\n  var numIndices = indices.length;\n  var normalsPerVertex = new Array(numVertices);\n  var normalsPerTriangle = new Array(numIndices / 3);\n  var normalIndices = new Array(numIndices);\n  var i;\n  for (i = 0; i < numVertices; i++) {\n    normalsPerVertex[i] = {\n      indexOffset: 0,\n      count: 0,\n      currentCount: 0,\n    };\n  }\n\n  var j = 0;\n  for (i = 0; i < numIndices; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n    var i03 = i0 * 3;\n    var i13 = i1 * 3;\n    var i23 = i2 * 3;\n\n    v0.x = vertices[i03];\n    v0.y = vertices[i03 + 1];\n    v0.z = vertices[i03 + 2];\n    v1.x = vertices[i13];\n    v1.y = vertices[i13 + 1];\n    v1.z = vertices[i13 + 2];\n    v2.x = vertices[i23];\n    v2.y = vertices[i23 + 1];\n    v2.z = vertices[i23 + 2];\n\n    normalsPerVertex[i0].count++;\n    normalsPerVertex[i1].count++;\n    normalsPerVertex[i2].count++;\n\n    Cartesian3.subtract(v1, v0, v1);\n    Cartesian3.subtract(v2, v0, v2);\n    normalsPerTriangle[j] = Cartesian3.cross(v1, v2, new Cartesian3());\n    j++;\n  }\n\n  var indexOffset = 0;\n  for (i = 0; i < numVertices; i++) {\n    normalsPerVertex[i].indexOffset += indexOffset;\n    indexOffset += normalsPerVertex[i].count;\n  }\n\n  j = 0;\n  var vertexNormalData;\n  for (i = 0; i < numIndices; i += 3) {\n    vertexNormalData = normalsPerVertex[indices[i]];\n    var index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\n    normalIndices[index] = j;\n    vertexNormalData.currentCount++;\n\n    vertexNormalData = normalsPerVertex[indices[i + 1]];\n    index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\n    normalIndices[index] = j;\n    vertexNormalData.currentCount++;\n\n    vertexNormalData = normalsPerVertex[indices[i + 2]];\n    index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\n    normalIndices[index] = j;\n    vertexNormalData.currentCount++;\n\n    j++;\n  }\n\n  var normalValues = new Float32Array(numVertices * 3);\n  for (i = 0; i < numVertices; i++) {\n    var i3 = i * 3;\n    vertexNormalData = normalsPerVertex[i];\n    Cartesian3.clone(Cartesian3.ZERO, normal);\n    if (vertexNormalData.count > 0) {\n      for (j = 0; j < vertexNormalData.count; j++) {\n        Cartesian3.add(\n          normal,\n          normalsPerTriangle[normalIndices[vertexNormalData.indexOffset + j]],\n          normal\n        );\n      }\n\n      // We can run into an issue where a vertex is used with 2 primitives that have opposite winding order.\n      if (\n        Cartesian3.equalsEpsilon(Cartesian3.ZERO, normal, CesiumMath.EPSILON10)\n      ) {\n        Cartesian3.clone(\n          normalsPerTriangle[normalIndices[vertexNormalData.indexOffset]],\n          normal\n        );\n      }\n    }\n\n    // We end up with a zero vector probably because of a degenerate triangle\n    if (\n      Cartesian3.equalsEpsilon(Cartesian3.ZERO, normal, CesiumMath.EPSILON10)\n    ) {\n      // Default to (0,0,1)\n      normal.z = 1.0;\n    }\n\n    Cartesian3.normalize(normal, normal);\n    normalValues[i3] = normal.x;\n    normalValues[i3 + 1] = normal.y;\n    normalValues[i3 + 2] = normal.z;\n  }\n\n  geometry.attributes.normal = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    values: normalValues,\n  });\n\n  return geometry;\n};\n\nvar normalScratch = new Cartesian3();\nvar normalScale = new Cartesian3();\nvar tScratch = new Cartesian3();\n\n/**\n * Computes per-vertex tangents and bitangents for a geometry containing <code>TRIANGLES</code>.\n * The result is new <code>tangent</code> and <code>bitangent</code> attributes added to the geometry.\n * This assumes a counter-clockwise winding order.\n * <p>\n * Based on <a href=\"http://www.terathon.com/code/tangent.html\">Computing Tangent Space Basis Vectors\n * for an Arbitrary Mesh</a> by Eric Lengyel.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument with the computed <code>tangent</code> and <code>bitangent</code> attributes.\n *\n * @exception {DeveloperError} geometry.indices length must be greater than 0 and be a multiple of 3.\n * @exception {DeveloperError} geometry.primitiveType must be {@link PrimitiveType.TRIANGLES}.\n *\n * @example\n * Cesium.GeometryPipeline.computeTangentAndBiTangent(geometry);\n */\nGeometryPipeline.computeTangentAndBitangent = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var attributes = geometry.attributes;\n  var indices = geometry.indices;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(attributes.position) || !defined(attributes.position.values)) {\n    throw new DeveloperError(\n      \"geometry.attributes.position.values is required.\"\n    );\n  }\n  if (!defined(attributes.normal) || !defined(attributes.normal.values)) {\n    throw new DeveloperError(\"geometry.attributes.normal.values is required.\");\n  }\n  if (!defined(attributes.st) || !defined(attributes.st.values)) {\n    throw new DeveloperError(\"geometry.attributes.st.values is required.\");\n  }\n  if (!defined(indices)) {\n    throw new DeveloperError(\"geometry.indices is required.\");\n  }\n  if (indices.length < 2 || indices.length % 3 !== 0) {\n    throw new DeveloperError(\n      \"geometry.indices length must be greater than 0 and be a multiple of 3.\"\n    );\n  }\n  if (geometry.primitiveType !== PrimitiveType.TRIANGLES) {\n    throw new DeveloperError(\n      \"geometry.primitiveType must be PrimitiveType.TRIANGLES.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var vertices = geometry.attributes.position.values;\n  var normals = geometry.attributes.normal.values;\n  var st = geometry.attributes.st.values;\n\n  var numVertices = geometry.attributes.position.values.length / 3;\n  var numIndices = indices.length;\n  var tan1 = new Array(numVertices * 3);\n\n  var i;\n  for (i = 0; i < tan1.length; i++) {\n    tan1[i] = 0;\n  }\n\n  var i03;\n  var i13;\n  var i23;\n  for (i = 0; i < numIndices; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n    i03 = i0 * 3;\n    i13 = i1 * 3;\n    i23 = i2 * 3;\n    var i02 = i0 * 2;\n    var i12 = i1 * 2;\n    var i22 = i2 * 2;\n\n    var ux = vertices[i03];\n    var uy = vertices[i03 + 1];\n    var uz = vertices[i03 + 2];\n\n    var wx = st[i02];\n    var wy = st[i02 + 1];\n    var t1 = st[i12 + 1] - wy;\n    var t2 = st[i22 + 1] - wy;\n\n    var r = 1.0 / ((st[i12] - wx) * t2 - (st[i22] - wx) * t1);\n    var sdirx = (t2 * (vertices[i13] - ux) - t1 * (vertices[i23] - ux)) * r;\n    var sdiry =\n      (t2 * (vertices[i13 + 1] - uy) - t1 * (vertices[i23 + 1] - uy)) * r;\n    var sdirz =\n      (t2 * (vertices[i13 + 2] - uz) - t1 * (vertices[i23 + 2] - uz)) * r;\n\n    tan1[i03] += sdirx;\n    tan1[i03 + 1] += sdiry;\n    tan1[i03 + 2] += sdirz;\n\n    tan1[i13] += sdirx;\n    tan1[i13 + 1] += sdiry;\n    tan1[i13 + 2] += sdirz;\n\n    tan1[i23] += sdirx;\n    tan1[i23 + 1] += sdiry;\n    tan1[i23 + 2] += sdirz;\n  }\n\n  var tangentValues = new Float32Array(numVertices * 3);\n  var bitangentValues = new Float32Array(numVertices * 3);\n\n  for (i = 0; i < numVertices; i++) {\n    i03 = i * 3;\n    i13 = i03 + 1;\n    i23 = i03 + 2;\n\n    var n = Cartesian3.fromArray(normals, i03, normalScratch);\n    var t = Cartesian3.fromArray(tan1, i03, tScratch);\n    var scalar = Cartesian3.dot(n, t);\n    Cartesian3.multiplyByScalar(n, scalar, normalScale);\n    Cartesian3.normalize(Cartesian3.subtract(t, normalScale, t), t);\n\n    tangentValues[i03] = t.x;\n    tangentValues[i13] = t.y;\n    tangentValues[i23] = t.z;\n\n    Cartesian3.normalize(Cartesian3.cross(n, t, t), t);\n\n    bitangentValues[i03] = t.x;\n    bitangentValues[i13] = t.y;\n    bitangentValues[i23] = t.z;\n  }\n\n  geometry.attributes.tangent = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    values: tangentValues,\n  });\n\n  geometry.attributes.bitangent = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    values: bitangentValues,\n  });\n\n  return geometry;\n};\n\nvar scratchCartesian2 = new Cartesian2();\nvar toEncode1 = new Cartesian3();\nvar toEncode2 = new Cartesian3();\nvar toEncode3 = new Cartesian3();\nvar encodeResult2 = new Cartesian2();\n/**\n * Compresses and packs geometry normal attribute values to save memory.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its normals compressed and packed.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.compressVertices(geometry);\n */\nGeometryPipeline.compressVertices = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var extrudeAttribute = geometry.attributes.extrudeDirection;\n  var i;\n  var numVertices;\n  if (defined(extrudeAttribute)) {\n    //only shadow volumes use extrudeDirection, and shadow volumes use vertexFormat: POSITION_ONLY so we don't need to check other attributes\n    var extrudeDirections = extrudeAttribute.values;\n    numVertices = extrudeDirections.length / 3.0;\n    var compressedDirections = new Float32Array(numVertices * 2);\n\n    var i2 = 0;\n    for (i = 0; i < numVertices; ++i) {\n      Cartesian3.fromArray(extrudeDirections, i * 3.0, toEncode1);\n      if (Cartesian3.equals(toEncode1, Cartesian3.ZERO)) {\n        i2 += 2;\n        continue;\n      }\n      encodeResult2 = AttributeCompression.octEncodeInRange(\n        toEncode1,\n        65535,\n        encodeResult2\n      );\n      compressedDirections[i2++] = encodeResult2.x;\n      compressedDirections[i2++] = encodeResult2.y;\n    }\n\n    geometry.attributes.compressedAttributes = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: compressedDirections,\n    });\n    delete geometry.attributes.extrudeDirection;\n    return geometry;\n  }\n\n  var normalAttribute = geometry.attributes.normal;\n  var stAttribute = geometry.attributes.st;\n\n  var hasNormal = defined(normalAttribute);\n  var hasSt = defined(stAttribute);\n  if (!hasNormal && !hasSt) {\n    return geometry;\n  }\n\n  var tangentAttribute = geometry.attributes.tangent;\n  var bitangentAttribute = geometry.attributes.bitangent;\n\n  var hasTangent = defined(tangentAttribute);\n  var hasBitangent = defined(bitangentAttribute);\n\n  var normals;\n  var st;\n  var tangents;\n  var bitangents;\n\n  if (hasNormal) {\n    normals = normalAttribute.values;\n  }\n  if (hasSt) {\n    st = stAttribute.values;\n  }\n  if (hasTangent) {\n    tangents = tangentAttribute.values;\n  }\n  if (hasBitangent) {\n    bitangents = bitangentAttribute.values;\n  }\n\n  var length = hasNormal ? normals.length : st.length;\n  var numComponents = hasNormal ? 3.0 : 2.0;\n  numVertices = length / numComponents;\n\n  var compressedLength = numVertices;\n  var numCompressedComponents = hasSt && hasNormal ? 2.0 : 1.0;\n  numCompressedComponents += hasTangent || hasBitangent ? 1.0 : 0.0;\n  compressedLength *= numCompressedComponents;\n\n  var compressedAttributes = new Float32Array(compressedLength);\n\n  var normalIndex = 0;\n  for (i = 0; i < numVertices; ++i) {\n    if (hasSt) {\n      Cartesian2.fromArray(st, i * 2.0, scratchCartesian2);\n      compressedAttributes[\n        normalIndex++\n      ] = AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n    }\n\n    var index = i * 3.0;\n    if (hasNormal && defined(tangents) && defined(bitangents)) {\n      Cartesian3.fromArray(normals, index, toEncode1);\n      Cartesian3.fromArray(tangents, index, toEncode2);\n      Cartesian3.fromArray(bitangents, index, toEncode3);\n\n      AttributeCompression.octPack(\n        toEncode1,\n        toEncode2,\n        toEncode3,\n        scratchCartesian2\n      );\n      compressedAttributes[normalIndex++] = scratchCartesian2.x;\n      compressedAttributes[normalIndex++] = scratchCartesian2.y;\n    } else {\n      if (hasNormal) {\n        Cartesian3.fromArray(normals, index, toEncode1);\n        compressedAttributes[\n          normalIndex++\n        ] = AttributeCompression.octEncodeFloat(toEncode1);\n      }\n\n      if (hasTangent) {\n        Cartesian3.fromArray(tangents, index, toEncode1);\n        compressedAttributes[\n          normalIndex++\n        ] = AttributeCompression.octEncodeFloat(toEncode1);\n      }\n\n      if (hasBitangent) {\n        Cartesian3.fromArray(bitangents, index, toEncode1);\n        compressedAttributes[\n          normalIndex++\n        ] = AttributeCompression.octEncodeFloat(toEncode1);\n      }\n    }\n  }\n\n  geometry.attributes.compressedAttributes = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: numCompressedComponents,\n    values: compressedAttributes,\n  });\n\n  if (hasNormal) {\n    delete geometry.attributes.normal;\n  }\n  if (hasSt) {\n    delete geometry.attributes.st;\n  }\n  if (hasBitangent) {\n    delete geometry.attributes.bitangent;\n  }\n  if (hasTangent) {\n    delete geometry.attributes.tangent;\n  }\n\n  return geometry;\n};\n\nfunction indexTriangles(geometry) {\n  if (defined(geometry.indices)) {\n    return geometry;\n  }\n  var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 3) {\n    throw new DeveloperError(\"The number of vertices must be at least three.\");\n  }\n  if (numberOfVertices % 3 !== 0) {\n    throw new DeveloperError(\n      \"The number of vertices must be a multiple of three.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    numberOfVertices\n  );\n  for (var i = 0; i < numberOfVertices; ++i) {\n    indices[i] = i;\n  }\n\n  geometry.indices = indices;\n  return geometry;\n}\n\nfunction indexTriangleFan(geometry) {\n  var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 3) {\n    throw new DeveloperError(\"The number of vertices must be at least three.\");\n  }\n  //>>includeEnd('debug');\n\n  var indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    (numberOfVertices - 2) * 3\n  );\n  indices[0] = 1;\n  indices[1] = 0;\n  indices[2] = 2;\n\n  var indicesIndex = 3;\n  for (var i = 3; i < numberOfVertices; ++i) {\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = 0;\n    indices[indicesIndex++] = i;\n  }\n\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.TRIANGLES;\n  return geometry;\n}\n\nfunction indexTriangleStrip(geometry) {\n  var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 3) {\n    throw new DeveloperError(\"The number of vertices must be at least 3.\");\n  }\n  //>>includeEnd('debug');\n\n  var indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    (numberOfVertices - 2) * 3\n  );\n  indices[0] = 0;\n  indices[1] = 1;\n  indices[2] = 2;\n\n  if (numberOfVertices > 3) {\n    indices[3] = 0;\n    indices[4] = 2;\n    indices[5] = 3;\n  }\n\n  var indicesIndex = 6;\n  for (var i = 3; i < numberOfVertices - 1; i += 2) {\n    indices[indicesIndex++] = i;\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = i + 1;\n\n    if (i + 2 < numberOfVertices) {\n      indices[indicesIndex++] = i;\n      indices[indicesIndex++] = i + 1;\n      indices[indicesIndex++] = i + 2;\n    }\n  }\n\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.TRIANGLES;\n  return geometry;\n}\n\nfunction indexLines(geometry) {\n  if (defined(geometry.indices)) {\n    return geometry;\n  }\n  var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 2) {\n    throw new DeveloperError(\"The number of vertices must be at least two.\");\n  }\n  if (numberOfVertices % 2 !== 0) {\n    throw new DeveloperError(\"The number of vertices must be a multiple of 2.\");\n  }\n  //>>includeEnd('debug');\n\n  var indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    numberOfVertices\n  );\n  for (var i = 0; i < numberOfVertices; ++i) {\n    indices[i] = i;\n  }\n\n  geometry.indices = indices;\n  return geometry;\n}\n\nfunction indexLineStrip(geometry) {\n  var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 2) {\n    throw new DeveloperError(\"The number of vertices must be at least two.\");\n  }\n  //>>includeEnd('debug');\n\n  var indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    (numberOfVertices - 1) * 2\n  );\n  indices[0] = 0;\n  indices[1] = 1;\n  var indicesIndex = 2;\n  for (var i = 2; i < numberOfVertices; ++i) {\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = i;\n  }\n\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.LINES;\n  return geometry;\n}\n\nfunction indexLineLoop(geometry) {\n  var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 2) {\n    throw new DeveloperError(\"The number of vertices must be at least two.\");\n  }\n  //>>includeEnd('debug');\n\n  var indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    numberOfVertices * 2\n  );\n\n  indices[0] = 0;\n  indices[1] = 1;\n\n  var indicesIndex = 2;\n  for (var i = 2; i < numberOfVertices; ++i) {\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = i;\n  }\n\n  indices[indicesIndex++] = numberOfVertices - 1;\n  indices[indicesIndex] = 0;\n\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.LINES;\n  return geometry;\n}\n\nfunction indexPrimitive(geometry) {\n  switch (geometry.primitiveType) {\n    case PrimitiveType.TRIANGLE_FAN:\n      return indexTriangleFan(geometry);\n    case PrimitiveType.TRIANGLE_STRIP:\n      return indexTriangleStrip(geometry);\n    case PrimitiveType.TRIANGLES:\n      return indexTriangles(geometry);\n    case PrimitiveType.LINE_STRIP:\n      return indexLineStrip(geometry);\n    case PrimitiveType.LINE_LOOP:\n      return indexLineLoop(geometry);\n    case PrimitiveType.LINES:\n      return indexLines(geometry);\n  }\n\n  return geometry;\n}\n\nfunction offsetPointFromXZPlane(p, isBehind) {\n  if (Math.abs(p.y) < CesiumMath.EPSILON6) {\n    if (isBehind) {\n      p.y = -CesiumMath.EPSILON6;\n    } else {\n      p.y = CesiumMath.EPSILON6;\n    }\n  }\n}\n\nfunction offsetTriangleFromXZPlane(p0, p1, p2) {\n  if (p0.y !== 0.0 && p1.y !== 0.0 && p2.y !== 0.0) {\n    offsetPointFromXZPlane(p0, p0.y < 0.0);\n    offsetPointFromXZPlane(p1, p1.y < 0.0);\n    offsetPointFromXZPlane(p2, p2.y < 0.0);\n    return;\n  }\n\n  var p0y = Math.abs(p0.y);\n  var p1y = Math.abs(p1.y);\n  var p2y = Math.abs(p2.y);\n\n  var sign;\n  if (p0y > p1y) {\n    if (p0y > p2y) {\n      sign = CesiumMath.sign(p0.y);\n    } else {\n      sign = CesiumMath.sign(p2.y);\n    }\n  } else if (p1y > p2y) {\n    sign = CesiumMath.sign(p1.y);\n  } else {\n    sign = CesiumMath.sign(p2.y);\n  }\n\n  var isBehind = sign < 0.0;\n  offsetPointFromXZPlane(p0, isBehind);\n  offsetPointFromXZPlane(p1, isBehind);\n  offsetPointFromXZPlane(p2, isBehind);\n}\n\nvar c3 = new Cartesian3();\nfunction getXZIntersectionOffsetPoints(p, p1, u1, v1) {\n  Cartesian3.add(\n    p,\n    Cartesian3.multiplyByScalar(\n      Cartesian3.subtract(p1, p, c3),\n      p.y / (p.y - p1.y),\n      c3\n    ),\n    u1\n  );\n  Cartesian3.clone(u1, v1);\n  offsetPointFromXZPlane(u1, true);\n  offsetPointFromXZPlane(v1, false);\n}\n\nvar u1 = new Cartesian3();\nvar u2 = new Cartesian3();\nvar q1 = new Cartesian3();\nvar q2 = new Cartesian3();\n\nvar splitTriangleResult = {\n  positions: new Array(7),\n  indices: new Array(3 * 3),\n};\n\nfunction splitTriangle(p0, p1, p2) {\n  // In WGS84 coordinates, for a triangle approximately on the\n  // ellipsoid to cross the IDL, first it needs to be on the\n  // negative side of the plane x = 0.\n  if (p0.x >= 0.0 || p1.x >= 0.0 || p2.x >= 0.0) {\n    return undefined;\n  }\n\n  offsetTriangleFromXZPlane(p0, p1, p2);\n\n  var p0Behind = p0.y < 0.0;\n  var p1Behind = p1.y < 0.0;\n  var p2Behind = p2.y < 0.0;\n\n  var numBehind = 0;\n  numBehind += p0Behind ? 1 : 0;\n  numBehind += p1Behind ? 1 : 0;\n  numBehind += p2Behind ? 1 : 0;\n\n  var indices = splitTriangleResult.indices;\n\n  if (numBehind === 1) {\n    indices[1] = 3;\n    indices[2] = 4;\n    indices[5] = 6;\n    indices[7] = 6;\n    indices[8] = 5;\n\n    if (p0Behind) {\n      getXZIntersectionOffsetPoints(p0, p1, u1, q1);\n      getXZIntersectionOffsetPoints(p0, p2, u2, q2);\n\n      indices[0] = 0;\n      indices[3] = 1;\n      indices[4] = 2;\n      indices[6] = 1;\n    } else if (p1Behind) {\n      getXZIntersectionOffsetPoints(p1, p2, u1, q1);\n      getXZIntersectionOffsetPoints(p1, p0, u2, q2);\n\n      indices[0] = 1;\n      indices[3] = 2;\n      indices[4] = 0;\n      indices[6] = 2;\n    } else if (p2Behind) {\n      getXZIntersectionOffsetPoints(p2, p0, u1, q1);\n      getXZIntersectionOffsetPoints(p2, p1, u2, q2);\n\n      indices[0] = 2;\n      indices[3] = 0;\n      indices[4] = 1;\n      indices[6] = 0;\n    }\n  } else if (numBehind === 2) {\n    indices[2] = 4;\n    indices[4] = 4;\n    indices[5] = 3;\n    indices[7] = 5;\n    indices[8] = 6;\n\n    if (!p0Behind) {\n      getXZIntersectionOffsetPoints(p0, p1, u1, q1);\n      getXZIntersectionOffsetPoints(p0, p2, u2, q2);\n\n      indices[0] = 1;\n      indices[1] = 2;\n      indices[3] = 1;\n      indices[6] = 0;\n    } else if (!p1Behind) {\n      getXZIntersectionOffsetPoints(p1, p2, u1, q1);\n      getXZIntersectionOffsetPoints(p1, p0, u2, q2);\n\n      indices[0] = 2;\n      indices[1] = 0;\n      indices[3] = 2;\n      indices[6] = 1;\n    } else if (!p2Behind) {\n      getXZIntersectionOffsetPoints(p2, p0, u1, q1);\n      getXZIntersectionOffsetPoints(p2, p1, u2, q2);\n\n      indices[0] = 0;\n      indices[1] = 1;\n      indices[3] = 0;\n      indices[6] = 2;\n    }\n  }\n\n  var positions = splitTriangleResult.positions;\n  positions[0] = p0;\n  positions[1] = p1;\n  positions[2] = p2;\n  positions.length = 3;\n\n  if (numBehind === 1 || numBehind === 2) {\n    positions[3] = u1;\n    positions[4] = u2;\n    positions[5] = q1;\n    positions[6] = q2;\n    positions.length = 7;\n  }\n\n  return splitTriangleResult;\n}\n\nfunction updateGeometryAfterSplit(geometry, computeBoundingSphere) {\n  var attributes = geometry.attributes;\n\n  if (attributes.position.values.length === 0) {\n    return undefined;\n  }\n\n  for (var property in attributes) {\n    if (\n      attributes.hasOwnProperty(property) &&\n      defined(attributes[property]) &&\n      defined(attributes[property].values)\n    ) {\n      var attribute = attributes[property];\n      attribute.values = ComponentDatatype.createTypedArray(\n        attribute.componentDatatype,\n        attribute.values\n      );\n    }\n  }\n\n  var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n  geometry.indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    geometry.indices\n  );\n\n  if (computeBoundingSphere) {\n    geometry.boundingSphere = BoundingSphere.fromVertices(\n      attributes.position.values\n    );\n  }\n\n  return geometry;\n}\n\nfunction copyGeometryForSplit(geometry) {\n  var attributes = geometry.attributes;\n  var copiedAttributes = {};\n\n  for (var property in attributes) {\n    if (\n      attributes.hasOwnProperty(property) &&\n      defined(attributes[property]) &&\n      defined(attributes[property].values)\n    ) {\n      var attribute = attributes[property];\n      copiedAttributes[property] = new GeometryAttribute({\n        componentDatatype: attribute.componentDatatype,\n        componentsPerAttribute: attribute.componentsPerAttribute,\n        normalize: attribute.normalize,\n        values: [],\n      });\n    }\n  }\n\n  return new Geometry({\n    attributes: copiedAttributes,\n    indices: [],\n    primitiveType: geometry.primitiveType,\n  });\n}\n\nfunction updateInstanceAfterSplit(instance, westGeometry, eastGeometry) {\n  var computeBoundingSphere = defined(instance.geometry.boundingSphere);\n\n  westGeometry = updateGeometryAfterSplit(westGeometry, computeBoundingSphere);\n  eastGeometry = updateGeometryAfterSplit(eastGeometry, computeBoundingSphere);\n\n  if (defined(eastGeometry) && !defined(westGeometry)) {\n    instance.geometry = eastGeometry;\n  } else if (!defined(eastGeometry) && defined(westGeometry)) {\n    instance.geometry = westGeometry;\n  } else {\n    instance.westHemisphereGeometry = westGeometry;\n    instance.eastHemisphereGeometry = eastGeometry;\n    instance.geometry = undefined;\n  }\n}\n\nfunction generateBarycentricInterpolateFunction(\n  CartesianType,\n  numberOfComponents\n) {\n  var v0Scratch = new CartesianType();\n  var v1Scratch = new CartesianType();\n  var v2Scratch = new CartesianType();\n\n  return function (\n    i0,\n    i1,\n    i2,\n    coords,\n    sourceValues,\n    currentValues,\n    insertedIndex,\n    normalize\n  ) {\n    var v0 = CartesianType.fromArray(\n      sourceValues,\n      i0 * numberOfComponents,\n      v0Scratch\n    );\n    var v1 = CartesianType.fromArray(\n      sourceValues,\n      i1 * numberOfComponents,\n      v1Scratch\n    );\n    var v2 = CartesianType.fromArray(\n      sourceValues,\n      i2 * numberOfComponents,\n      v2Scratch\n    );\n\n    CartesianType.multiplyByScalar(v0, coords.x, v0);\n    CartesianType.multiplyByScalar(v1, coords.y, v1);\n    CartesianType.multiplyByScalar(v2, coords.z, v2);\n\n    var value = CartesianType.add(v0, v1, v0);\n    CartesianType.add(value, v2, value);\n\n    if (normalize) {\n      CartesianType.normalize(value, value);\n    }\n\n    CartesianType.pack(\n      value,\n      currentValues,\n      insertedIndex * numberOfComponents\n    );\n  };\n}\n\nvar interpolateAndPackCartesian4 = generateBarycentricInterpolateFunction(\n  Cartesian4,\n  4\n);\nvar interpolateAndPackCartesian3 = generateBarycentricInterpolateFunction(\n  Cartesian3,\n  3\n);\nvar interpolateAndPackCartesian2 = generateBarycentricInterpolateFunction(\n  Cartesian2,\n  2\n);\nvar interpolateAndPackBoolean = function (\n  i0,\n  i1,\n  i2,\n  coords,\n  sourceValues,\n  currentValues,\n  insertedIndex\n) {\n  var v1 = sourceValues[i0] * coords.x;\n  var v2 = sourceValues[i1] * coords.y;\n  var v3 = sourceValues[i2] * coords.z;\n  currentValues[insertedIndex] = v1 + v2 + v3 > CesiumMath.EPSILON6 ? 1 : 0;\n};\n\nvar p0Scratch = new Cartesian3();\nvar p1Scratch = new Cartesian3();\nvar p2Scratch = new Cartesian3();\nvar barycentricScratch = new Cartesian3();\n\nfunction computeTriangleAttributes(\n  i0,\n  i1,\n  i2,\n  point,\n  positions,\n  normals,\n  tangents,\n  bitangents,\n  texCoords,\n  extrudeDirections,\n  applyOffset,\n  currentAttributes,\n  customAttributeNames,\n  customAttributesLength,\n  allAttributes,\n  insertedIndex\n) {\n  if (\n    !defined(normals) &&\n    !defined(tangents) &&\n    !defined(bitangents) &&\n    !defined(texCoords) &&\n    !defined(extrudeDirections) &&\n    customAttributesLength === 0\n  ) {\n    return;\n  }\n\n  var p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\n  var p1 = Cartesian3.fromArray(positions, i1 * 3, p1Scratch);\n  var p2 = Cartesian3.fromArray(positions, i2 * 3, p2Scratch);\n  var coords = barycentricCoordinates(point, p0, p1, p2, barycentricScratch);\n\n  if (defined(normals)) {\n    interpolateAndPackCartesian3(\n      i0,\n      i1,\n      i2,\n      coords,\n      normals,\n      currentAttributes.normal.values,\n      insertedIndex,\n      true\n    );\n  }\n\n  if (defined(extrudeDirections)) {\n    var d0 = Cartesian3.fromArray(extrudeDirections, i0 * 3, p0Scratch);\n    var d1 = Cartesian3.fromArray(extrudeDirections, i1 * 3, p1Scratch);\n    var d2 = Cartesian3.fromArray(extrudeDirections, i2 * 3, p2Scratch);\n\n    Cartesian3.multiplyByScalar(d0, coords.x, d0);\n    Cartesian3.multiplyByScalar(d1, coords.y, d1);\n    Cartesian3.multiplyByScalar(d2, coords.z, d2);\n\n    var direction;\n    if (\n      !Cartesian3.equals(d0, Cartesian3.ZERO) ||\n      !Cartesian3.equals(d1, Cartesian3.ZERO) ||\n      !Cartesian3.equals(d2, Cartesian3.ZERO)\n    ) {\n      direction = Cartesian3.add(d0, d1, d0);\n      Cartesian3.add(direction, d2, direction);\n      Cartesian3.normalize(direction, direction);\n    } else {\n      direction = p0Scratch;\n      direction.x = 0;\n      direction.y = 0;\n      direction.z = 0;\n    }\n    Cartesian3.pack(\n      direction,\n      currentAttributes.extrudeDirection.values,\n      insertedIndex * 3\n    );\n  }\n\n  if (defined(applyOffset)) {\n    interpolateAndPackBoolean(\n      i0,\n      i1,\n      i2,\n      coords,\n      applyOffset,\n      currentAttributes.applyOffset.values,\n      insertedIndex\n    );\n  }\n\n  if (defined(tangents)) {\n    interpolateAndPackCartesian3(\n      i0,\n      i1,\n      i2,\n      coords,\n      tangents,\n      currentAttributes.tangent.values,\n      insertedIndex,\n      true\n    );\n  }\n\n  if (defined(bitangents)) {\n    interpolateAndPackCartesian3(\n      i0,\n      i1,\n      i2,\n      coords,\n      bitangents,\n      currentAttributes.bitangent.values,\n      insertedIndex,\n      true\n    );\n  }\n\n  if (defined(texCoords)) {\n    interpolateAndPackCartesian2(\n      i0,\n      i1,\n      i2,\n      coords,\n      texCoords,\n      currentAttributes.st.values,\n      insertedIndex\n    );\n  }\n\n  if (customAttributesLength > 0) {\n    for (var i = 0; i < customAttributesLength; i++) {\n      var attributeName = customAttributeNames[i];\n      genericInterpolate(\n        i0,\n        i1,\n        i2,\n        coords,\n        insertedIndex,\n        allAttributes[attributeName],\n        currentAttributes[attributeName]\n      );\n    }\n  }\n}\n\nfunction genericInterpolate(\n  i0,\n  i1,\n  i2,\n  coords,\n  insertedIndex,\n  sourceAttribute,\n  currentAttribute\n) {\n  var componentsPerAttribute = sourceAttribute.componentsPerAttribute;\n  var sourceValues = sourceAttribute.values;\n  var currentValues = currentAttribute.values;\n  switch (componentsPerAttribute) {\n    case 4:\n      interpolateAndPackCartesian4(\n        i0,\n        i1,\n        i2,\n        coords,\n        sourceValues,\n        currentValues,\n        insertedIndex,\n        false\n      );\n      break;\n    case 3:\n      interpolateAndPackCartesian3(\n        i0,\n        i1,\n        i2,\n        coords,\n        sourceValues,\n        currentValues,\n        insertedIndex,\n        false\n      );\n      break;\n    case 2:\n      interpolateAndPackCartesian2(\n        i0,\n        i1,\n        i2,\n        coords,\n        sourceValues,\n        currentValues,\n        insertedIndex,\n        false\n      );\n      break;\n    default:\n      currentValues[insertedIndex] =\n        sourceValues[i0] * coords.x +\n        sourceValues[i1] * coords.y +\n        sourceValues[i2] * coords.z;\n  }\n}\n\nfunction insertSplitPoint(\n  currentAttributes,\n  currentIndices,\n  currentIndexMap,\n  indices,\n  currentIndex,\n  point\n) {\n  var insertIndex = currentAttributes.position.values.length / 3;\n\n  if (currentIndex !== -1) {\n    var prevIndex = indices[currentIndex];\n    var newIndex = currentIndexMap[prevIndex];\n\n    if (newIndex === -1) {\n      currentIndexMap[prevIndex] = insertIndex;\n      currentAttributes.position.values.push(point.x, point.y, point.z);\n      currentIndices.push(insertIndex);\n      return insertIndex;\n    }\n\n    currentIndices.push(newIndex);\n    return newIndex;\n  }\n\n  currentAttributes.position.values.push(point.x, point.y, point.z);\n  currentIndices.push(insertIndex);\n  return insertIndex;\n}\n\nvar NAMED_ATTRIBUTES = {\n  position: true,\n  normal: true,\n  bitangent: true,\n  tangent: true,\n  st: true,\n  extrudeDirection: true,\n  applyOffset: true,\n};\nfunction splitLongitudeTriangles(instance) {\n  var geometry = instance.geometry;\n  var attributes = geometry.attributes;\n  var positions = attributes.position.values;\n  var normals = defined(attributes.normal)\n    ? attributes.normal.values\n    : undefined;\n  var bitangents = defined(attributes.bitangent)\n    ? attributes.bitangent.values\n    : undefined;\n  var tangents = defined(attributes.tangent)\n    ? attributes.tangent.values\n    : undefined;\n  var texCoords = defined(attributes.st) ? attributes.st.values : undefined;\n  var extrudeDirections = defined(attributes.extrudeDirection)\n    ? attributes.extrudeDirection.values\n    : undefined;\n  var applyOffset = defined(attributes.applyOffset)\n    ? attributes.applyOffset.values\n    : undefined;\n  var indices = geometry.indices;\n\n  var customAttributeNames = [];\n  for (var attributeName in attributes) {\n    if (\n      attributes.hasOwnProperty(attributeName) &&\n      !NAMED_ATTRIBUTES[attributeName] &&\n      defined(attributes[attributeName])\n    ) {\n      customAttributeNames.push(attributeName);\n    }\n  }\n  var customAttributesLength = customAttributeNames.length;\n\n  var eastGeometry = copyGeometryForSplit(geometry);\n  var westGeometry = copyGeometryForSplit(geometry);\n\n  var currentAttributes;\n  var currentIndices;\n  var currentIndexMap;\n  var insertedIndex;\n  var i;\n\n  var westGeometryIndexMap = [];\n  westGeometryIndexMap.length = positions.length / 3;\n\n  var eastGeometryIndexMap = [];\n  eastGeometryIndexMap.length = positions.length / 3;\n\n  for (i = 0; i < westGeometryIndexMap.length; ++i) {\n    westGeometryIndexMap[i] = -1;\n    eastGeometryIndexMap[i] = -1;\n  }\n\n  var len = indices.length;\n  for (i = 0; i < len; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n\n    var p0 = Cartesian3.fromArray(positions, i0 * 3);\n    var p1 = Cartesian3.fromArray(positions, i1 * 3);\n    var p2 = Cartesian3.fromArray(positions, i2 * 3);\n\n    var result = splitTriangle(p0, p1, p2);\n    if (defined(result) && result.positions.length > 3) {\n      var resultPositions = result.positions;\n      var resultIndices = result.indices;\n      var resultLength = resultIndices.length;\n\n      for (var j = 0; j < resultLength; ++j) {\n        var resultIndex = resultIndices[j];\n        var point = resultPositions[resultIndex];\n\n        if (point.y < 0.0) {\n          currentAttributes = westGeometry.attributes;\n          currentIndices = westGeometry.indices;\n          currentIndexMap = westGeometryIndexMap;\n        } else {\n          currentAttributes = eastGeometry.attributes;\n          currentIndices = eastGeometry.indices;\n          currentIndexMap = eastGeometryIndexMap;\n        }\n\n        insertedIndex = insertSplitPoint(\n          currentAttributes,\n          currentIndices,\n          currentIndexMap,\n          indices,\n          resultIndex < 3 ? i + resultIndex : -1,\n          point\n        );\n        computeTriangleAttributes(\n          i0,\n          i1,\n          i2,\n          point,\n          positions,\n          normals,\n          tangents,\n          bitangents,\n          texCoords,\n          extrudeDirections,\n          applyOffset,\n          currentAttributes,\n          customAttributeNames,\n          customAttributesLength,\n          attributes,\n          insertedIndex\n        );\n      }\n    } else {\n      if (defined(result)) {\n        p0 = result.positions[0];\n        p1 = result.positions[1];\n        p2 = result.positions[2];\n      }\n\n      if (p0.y < 0.0) {\n        currentAttributes = westGeometry.attributes;\n        currentIndices = westGeometry.indices;\n        currentIndexMap = westGeometryIndexMap;\n      } else {\n        currentAttributes = eastGeometry.attributes;\n        currentIndices = eastGeometry.indices;\n        currentIndexMap = eastGeometryIndexMap;\n      }\n\n      insertedIndex = insertSplitPoint(\n        currentAttributes,\n        currentIndices,\n        currentIndexMap,\n        indices,\n        i,\n        p0\n      );\n      computeTriangleAttributes(\n        i0,\n        i1,\n        i2,\n        p0,\n        positions,\n        normals,\n        tangents,\n        bitangents,\n        texCoords,\n        extrudeDirections,\n        applyOffset,\n        currentAttributes,\n        customAttributeNames,\n        customAttributesLength,\n        attributes,\n        insertedIndex\n      );\n\n      insertedIndex = insertSplitPoint(\n        currentAttributes,\n        currentIndices,\n        currentIndexMap,\n        indices,\n        i + 1,\n        p1\n      );\n      computeTriangleAttributes(\n        i0,\n        i1,\n        i2,\n        p1,\n        positions,\n        normals,\n        tangents,\n        bitangents,\n        texCoords,\n        extrudeDirections,\n        applyOffset,\n        currentAttributes,\n        customAttributeNames,\n        customAttributesLength,\n        attributes,\n        insertedIndex\n      );\n\n      insertedIndex = insertSplitPoint(\n        currentAttributes,\n        currentIndices,\n        currentIndexMap,\n        indices,\n        i + 2,\n        p2\n      );\n      computeTriangleAttributes(\n        i0,\n        i1,\n        i2,\n        p2,\n        positions,\n        normals,\n        tangents,\n        bitangents,\n        texCoords,\n        extrudeDirections,\n        applyOffset,\n        currentAttributes,\n        customAttributeNames,\n        customAttributesLength,\n        attributes,\n        insertedIndex\n      );\n    }\n  }\n\n  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\n}\n\nvar xzPlane = Plane.fromPointNormal(Cartesian3.ZERO, Cartesian3.UNIT_Y);\n\nvar offsetScratch = new Cartesian3();\nvar offsetPointScratch = new Cartesian3();\n\nfunction computeLineAttributes(\n  i0,\n  i1,\n  point,\n  positions,\n  insertIndex,\n  currentAttributes,\n  applyOffset\n) {\n  if (!defined(applyOffset)) {\n    return;\n  }\n\n  var p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\n  if (Cartesian3.equalsEpsilon(p0, point, CesiumMath.EPSILON10)) {\n    currentAttributes.applyOffset.values[insertIndex] = applyOffset[i0];\n  } else {\n    currentAttributes.applyOffset.values[insertIndex] = applyOffset[i1];\n  }\n}\n\nfunction splitLongitudeLines(instance) {\n  var geometry = instance.geometry;\n  var attributes = geometry.attributes;\n  var positions = attributes.position.values;\n  var applyOffset = defined(attributes.applyOffset)\n    ? attributes.applyOffset.values\n    : undefined;\n  var indices = geometry.indices;\n\n  var eastGeometry = copyGeometryForSplit(geometry);\n  var westGeometry = copyGeometryForSplit(geometry);\n\n  var i;\n  var length = indices.length;\n\n  var westGeometryIndexMap = [];\n  westGeometryIndexMap.length = positions.length / 3;\n\n  var eastGeometryIndexMap = [];\n  eastGeometryIndexMap.length = positions.length / 3;\n\n  for (i = 0; i < westGeometryIndexMap.length; ++i) {\n    westGeometryIndexMap[i] = -1;\n    eastGeometryIndexMap[i] = -1;\n  }\n\n  for (i = 0; i < length; i += 2) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n\n    var p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\n    var p1 = Cartesian3.fromArray(positions, i1 * 3, p1Scratch);\n    var insertIndex;\n\n    if (Math.abs(p0.y) < CesiumMath.EPSILON6) {\n      if (p0.y < 0.0) {\n        p0.y = -CesiumMath.EPSILON6;\n      } else {\n        p0.y = CesiumMath.EPSILON6;\n      }\n    }\n\n    if (Math.abs(p1.y) < CesiumMath.EPSILON6) {\n      if (p1.y < 0.0) {\n        p1.y = -CesiumMath.EPSILON6;\n      } else {\n        p1.y = CesiumMath.EPSILON6;\n      }\n    }\n\n    var p0Attributes = eastGeometry.attributes;\n    var p0Indices = eastGeometry.indices;\n    var p0IndexMap = eastGeometryIndexMap;\n    var p1Attributes = westGeometry.attributes;\n    var p1Indices = westGeometry.indices;\n    var p1IndexMap = westGeometryIndexMap;\n\n    var intersection = IntersectionTests.lineSegmentPlane(\n      p0,\n      p1,\n      xzPlane,\n      p2Scratch\n    );\n    if (defined(intersection)) {\n      // move point on the xz-plane slightly away from the plane\n      var offset = Cartesian3.multiplyByScalar(\n        Cartesian3.UNIT_Y,\n        5.0 * CesiumMath.EPSILON9,\n        offsetScratch\n      );\n      if (p0.y < 0.0) {\n        Cartesian3.negate(offset, offset);\n\n        p0Attributes = westGeometry.attributes;\n        p0Indices = westGeometry.indices;\n        p0IndexMap = westGeometryIndexMap;\n        p1Attributes = eastGeometry.attributes;\n        p1Indices = eastGeometry.indices;\n        p1IndexMap = eastGeometryIndexMap;\n      }\n\n      var offsetPoint = Cartesian3.add(\n        intersection,\n        offset,\n        offsetPointScratch\n      );\n\n      insertIndex = insertSplitPoint(\n        p0Attributes,\n        p0Indices,\n        p0IndexMap,\n        indices,\n        i,\n        p0\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        p0,\n        positions,\n        insertIndex,\n        p0Attributes,\n        applyOffset\n      );\n\n      insertIndex = insertSplitPoint(\n        p0Attributes,\n        p0Indices,\n        p0IndexMap,\n        indices,\n        -1,\n        offsetPoint\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        offsetPoint,\n        positions,\n        insertIndex,\n        p0Attributes,\n        applyOffset\n      );\n\n      Cartesian3.negate(offset, offset);\n      Cartesian3.add(intersection, offset, offsetPoint);\n      insertIndex = insertSplitPoint(\n        p1Attributes,\n        p1Indices,\n        p1IndexMap,\n        indices,\n        -1,\n        offsetPoint\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        offsetPoint,\n        positions,\n        insertIndex,\n        p1Attributes,\n        applyOffset\n      );\n\n      insertIndex = insertSplitPoint(\n        p1Attributes,\n        p1Indices,\n        p1IndexMap,\n        indices,\n        i + 1,\n        p1\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        p1,\n        positions,\n        insertIndex,\n        p1Attributes,\n        applyOffset\n      );\n    } else {\n      var currentAttributes;\n      var currentIndices;\n      var currentIndexMap;\n\n      if (p0.y < 0.0) {\n        currentAttributes = westGeometry.attributes;\n        currentIndices = westGeometry.indices;\n        currentIndexMap = westGeometryIndexMap;\n      } else {\n        currentAttributes = eastGeometry.attributes;\n        currentIndices = eastGeometry.indices;\n        currentIndexMap = eastGeometryIndexMap;\n      }\n\n      insertIndex = insertSplitPoint(\n        currentAttributes,\n        currentIndices,\n        currentIndexMap,\n        indices,\n        i,\n        p0\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        p0,\n        positions,\n        insertIndex,\n        currentAttributes,\n        applyOffset\n      );\n\n      insertIndex = insertSplitPoint(\n        currentAttributes,\n        currentIndices,\n        currentIndexMap,\n        indices,\n        i + 1,\n        p1\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        p1,\n        positions,\n        insertIndex,\n        currentAttributes,\n        applyOffset\n      );\n    }\n  }\n\n  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\n}\n\nvar cartesian2Scratch0 = new Cartesian2();\nvar cartesian2Scratch1 = new Cartesian2();\n\nvar cartesian3Scratch0 = new Cartesian3();\nvar cartesian3Scratch2 = new Cartesian3();\nvar cartesian3Scratch3 = new Cartesian3();\nvar cartesian3Scratch4 = new Cartesian3();\nvar cartesian3Scratch5 = new Cartesian3();\nvar cartesian3Scratch6 = new Cartesian3();\n\nvar cartesian4Scratch0 = new Cartesian4();\n\nfunction updateAdjacencyAfterSplit(geometry) {\n  var attributes = geometry.attributes;\n  var positions = attributes.position.values;\n  var prevPositions = attributes.prevPosition.values;\n  var nextPositions = attributes.nextPosition.values;\n\n  var length = positions.length;\n  for (var j = 0; j < length; j += 3) {\n    var position = Cartesian3.unpack(positions, j, cartesian3Scratch0);\n    if (position.x > 0.0) {\n      continue;\n    }\n\n    var prevPosition = Cartesian3.unpack(prevPositions, j, cartesian3Scratch2);\n    if (\n      (position.y < 0.0 && prevPosition.y > 0.0) ||\n      (position.y > 0.0 && prevPosition.y < 0.0)\n    ) {\n      if (j - 3 > 0) {\n        prevPositions[j] = positions[j - 3];\n        prevPositions[j + 1] = positions[j - 2];\n        prevPositions[j + 2] = positions[j - 1];\n      } else {\n        Cartesian3.pack(position, prevPositions, j);\n      }\n    }\n\n    var nextPosition = Cartesian3.unpack(nextPositions, j, cartesian3Scratch3);\n    if (\n      (position.y < 0.0 && nextPosition.y > 0.0) ||\n      (position.y > 0.0 && nextPosition.y < 0.0)\n    ) {\n      if (j + 3 < length) {\n        nextPositions[j] = positions[j + 3];\n        nextPositions[j + 1] = positions[j + 4];\n        nextPositions[j + 2] = positions[j + 5];\n      } else {\n        Cartesian3.pack(position, nextPositions, j);\n      }\n    }\n  }\n}\n\nvar offsetScalar = 5.0 * CesiumMath.EPSILON9;\nvar coplanarOffset = CesiumMath.EPSILON6;\n\nfunction splitLongitudePolyline(instance) {\n  var geometry = instance.geometry;\n  var attributes = geometry.attributes;\n  var positions = attributes.position.values;\n  var prevPositions = attributes.prevPosition.values;\n  var nextPositions = attributes.nextPosition.values;\n  var expandAndWidths = attributes.expandAndWidth.values;\n\n  var texCoords = defined(attributes.st) ? attributes.st.values : undefined;\n  var colors = defined(attributes.color) ? attributes.color.values : undefined;\n\n  var eastGeometry = copyGeometryForSplit(geometry);\n  var westGeometry = copyGeometryForSplit(geometry);\n\n  var i;\n  var j;\n  var index;\n\n  var intersectionFound = false;\n\n  var length = positions.length / 3;\n  for (i = 0; i < length; i += 4) {\n    var i0 = i;\n    var i2 = i + 2;\n\n    var p0 = Cartesian3.fromArray(positions, i0 * 3, cartesian3Scratch0);\n    var p2 = Cartesian3.fromArray(positions, i2 * 3, cartesian3Scratch2);\n\n    // Offset points that are close to the 180 longitude and change the previous/next point\n    // to be the same offset point so it can be projected to 2D. There is special handling in the\n    // shader for when position == prevPosition || position == nextPosition.\n    if (Math.abs(p0.y) < coplanarOffset) {\n      p0.y = coplanarOffset * (p2.y < 0.0 ? -1.0 : 1.0);\n      positions[i * 3 + 1] = p0.y;\n      positions[(i + 1) * 3 + 1] = p0.y;\n\n      for (j = i0 * 3; j < i0 * 3 + 4 * 3; j += 3) {\n        prevPositions[j] = positions[i * 3];\n        prevPositions[j + 1] = positions[i * 3 + 1];\n        prevPositions[j + 2] = positions[i * 3 + 2];\n      }\n    }\n\n    // Do the same but for when the line crosses 180 longitude in the opposite direction.\n    if (Math.abs(p2.y) < coplanarOffset) {\n      p2.y = coplanarOffset * (p0.y < 0.0 ? -1.0 : 1.0);\n      positions[(i + 2) * 3 + 1] = p2.y;\n      positions[(i + 3) * 3 + 1] = p2.y;\n\n      for (j = i0 * 3; j < i0 * 3 + 4 * 3; j += 3) {\n        nextPositions[j] = positions[(i + 2) * 3];\n        nextPositions[j + 1] = positions[(i + 2) * 3 + 1];\n        nextPositions[j + 2] = positions[(i + 2) * 3 + 2];\n      }\n    }\n\n    var p0Attributes = eastGeometry.attributes;\n    var p0Indices = eastGeometry.indices;\n    var p2Attributes = westGeometry.attributes;\n    var p2Indices = westGeometry.indices;\n\n    var intersection = IntersectionTests.lineSegmentPlane(\n      p0,\n      p2,\n      xzPlane,\n      cartesian3Scratch4\n    );\n    if (defined(intersection)) {\n      intersectionFound = true;\n\n      // move point on the xz-plane slightly away from the plane\n      var offset = Cartesian3.multiplyByScalar(\n        Cartesian3.UNIT_Y,\n        offsetScalar,\n        cartesian3Scratch5\n      );\n      if (p0.y < 0.0) {\n        Cartesian3.negate(offset, offset);\n        p0Attributes = westGeometry.attributes;\n        p0Indices = westGeometry.indices;\n        p2Attributes = eastGeometry.attributes;\n        p2Indices = eastGeometry.indices;\n      }\n\n      var offsetPoint = Cartesian3.add(\n        intersection,\n        offset,\n        cartesian3Scratch6\n      );\n      p0Attributes.position.values.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z);\n      p0Attributes.position.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p0Attributes.position.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n\n      p0Attributes.prevPosition.values.push(\n        prevPositions[i0 * 3],\n        prevPositions[i0 * 3 + 1],\n        prevPositions[i0 * 3 + 2]\n      );\n      p0Attributes.prevPosition.values.push(\n        prevPositions[i0 * 3 + 3],\n        prevPositions[i0 * 3 + 4],\n        prevPositions[i0 * 3 + 5]\n      );\n      p0Attributes.prevPosition.values.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z);\n\n      p0Attributes.nextPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p0Attributes.nextPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p0Attributes.nextPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p0Attributes.nextPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n\n      Cartesian3.negate(offset, offset);\n      Cartesian3.add(intersection, offset, offsetPoint);\n      p2Attributes.position.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p2Attributes.position.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p2Attributes.position.values.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);\n\n      p2Attributes.prevPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p2Attributes.prevPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p2Attributes.prevPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p2Attributes.prevPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n\n      p2Attributes.nextPosition.values.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);\n      p2Attributes.nextPosition.values.push(\n        nextPositions[i2 * 3],\n        nextPositions[i2 * 3 + 1],\n        nextPositions[i2 * 3 + 2]\n      );\n      p2Attributes.nextPosition.values.push(\n        nextPositions[i2 * 3 + 3],\n        nextPositions[i2 * 3 + 4],\n        nextPositions[i2 * 3 + 5]\n      );\n\n      var ew0 = Cartesian2.fromArray(\n        expandAndWidths,\n        i0 * 2,\n        cartesian2Scratch0\n      );\n      var width = Math.abs(ew0.y);\n\n      p0Attributes.expandAndWidth.values.push(-1, width, 1, width);\n      p0Attributes.expandAndWidth.values.push(-1, -width, 1, -width);\n      p2Attributes.expandAndWidth.values.push(-1, width, 1, width);\n      p2Attributes.expandAndWidth.values.push(-1, -width, 1, -width);\n\n      var t = Cartesian3.magnitudeSquared(\n        Cartesian3.subtract(intersection, p0, cartesian3Scratch3)\n      );\n      t /= Cartesian3.magnitudeSquared(\n        Cartesian3.subtract(p2, p0, cartesian3Scratch3)\n      );\n\n      if (defined(colors)) {\n        var c0 = Cartesian4.fromArray(colors, i0 * 4, cartesian4Scratch0);\n        var c2 = Cartesian4.fromArray(colors, i2 * 4, cartesian4Scratch0);\n\n        var r = CesiumMath.lerp(c0.x, c2.x, t);\n        var g = CesiumMath.lerp(c0.y, c2.y, t);\n        var b = CesiumMath.lerp(c0.z, c2.z, t);\n        var a = CesiumMath.lerp(c0.w, c2.w, t);\n\n        for (j = i0 * 4; j < i0 * 4 + 2 * 4; ++j) {\n          p0Attributes.color.values.push(colors[j]);\n        }\n        p0Attributes.color.values.push(r, g, b, a);\n        p0Attributes.color.values.push(r, g, b, a);\n        p2Attributes.color.values.push(r, g, b, a);\n        p2Attributes.color.values.push(r, g, b, a);\n        for (j = i2 * 4; j < i2 * 4 + 2 * 4; ++j) {\n          p2Attributes.color.values.push(colors[j]);\n        }\n      }\n\n      if (defined(texCoords)) {\n        var s0 = Cartesian2.fromArray(texCoords, i0 * 2, cartesian2Scratch0);\n        var s3 = Cartesian2.fromArray(\n          texCoords,\n          (i + 3) * 2,\n          cartesian2Scratch1\n        );\n\n        var sx = CesiumMath.lerp(s0.x, s3.x, t);\n\n        for (j = i0 * 2; j < i0 * 2 + 2 * 2; ++j) {\n          p0Attributes.st.values.push(texCoords[j]);\n        }\n        p0Attributes.st.values.push(sx, s0.y);\n        p0Attributes.st.values.push(sx, s3.y);\n        p2Attributes.st.values.push(sx, s0.y);\n        p2Attributes.st.values.push(sx, s3.y);\n        for (j = i2 * 2; j < i2 * 2 + 2 * 2; ++j) {\n          p2Attributes.st.values.push(texCoords[j]);\n        }\n      }\n\n      index = p0Attributes.position.values.length / 3 - 4;\n      p0Indices.push(index, index + 2, index + 1);\n      p0Indices.push(index + 1, index + 2, index + 3);\n\n      index = p2Attributes.position.values.length / 3 - 4;\n      p2Indices.push(index, index + 2, index + 1);\n      p2Indices.push(index + 1, index + 2, index + 3);\n    } else {\n      var currentAttributes;\n      var currentIndices;\n\n      if (p0.y < 0.0) {\n        currentAttributes = westGeometry.attributes;\n        currentIndices = westGeometry.indices;\n      } else {\n        currentAttributes = eastGeometry.attributes;\n        currentIndices = eastGeometry.indices;\n      }\n\n      currentAttributes.position.values.push(p0.x, p0.y, p0.z);\n      currentAttributes.position.values.push(p0.x, p0.y, p0.z);\n      currentAttributes.position.values.push(p2.x, p2.y, p2.z);\n      currentAttributes.position.values.push(p2.x, p2.y, p2.z);\n\n      for (j = i * 3; j < i * 3 + 4 * 3; ++j) {\n        currentAttributes.prevPosition.values.push(prevPositions[j]);\n        currentAttributes.nextPosition.values.push(nextPositions[j]);\n      }\n\n      for (j = i * 2; j < i * 2 + 4 * 2; ++j) {\n        currentAttributes.expandAndWidth.values.push(expandAndWidths[j]);\n        if (defined(texCoords)) {\n          currentAttributes.st.values.push(texCoords[j]);\n        }\n      }\n\n      if (defined(colors)) {\n        for (j = i * 4; j < i * 4 + 4 * 4; ++j) {\n          currentAttributes.color.values.push(colors[j]);\n        }\n      }\n\n      index = currentAttributes.position.values.length / 3 - 4;\n      currentIndices.push(index, index + 2, index + 1);\n      currentIndices.push(index + 1, index + 2, index + 3);\n    }\n  }\n\n  if (intersectionFound) {\n    updateAdjacencyAfterSplit(westGeometry);\n    updateAdjacencyAfterSplit(eastGeometry);\n  }\n\n  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\n}\n\n/**\n * Splits the instances's geometry, by introducing new vertices and indices,that\n * intersect the International Date Line and Prime Meridian so that no primitives cross longitude\n * -180/180 degrees.  This is not required for 3D drawing, but is required for\n * correcting drawing in 2D and Columbus view.\n *\n * @private\n *\n * @param {GeometryInstance} instance The instance to modify.\n * @returns {GeometryInstance} The modified <code>instance</code> argument, with it's geometry split at the International Date Line.\n *\n * @example\n * instance = Cesium.GeometryPipeline.splitLongitude(instance);\n */\nGeometryPipeline.splitLongitude = function (instance) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(instance)) {\n    throw new DeveloperError(\"instance is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var geometry = instance.geometry;\n  var boundingSphere = geometry.boundingSphere;\n  if (defined(boundingSphere)) {\n    var minX = boundingSphere.center.x - boundingSphere.radius;\n    if (\n      minX > 0 ||\n      BoundingSphere.intersectPlane(boundingSphere, Plane.ORIGIN_ZX_PLANE) !==\n        Intersect.INTERSECTING\n    ) {\n      return instance;\n    }\n  }\n\n  if (geometry.geometryType !== GeometryType.NONE) {\n    switch (geometry.geometryType) {\n      case GeometryType.POLYLINES:\n        splitLongitudePolyline(instance);\n        break;\n      case GeometryType.TRIANGLES:\n        splitLongitudeTriangles(instance);\n        break;\n      case GeometryType.LINES:\n        splitLongitudeLines(instance);\n        break;\n    }\n  } else {\n    indexPrimitive(geometry);\n    if (geometry.primitiveType === PrimitiveType.TRIANGLES) {\n      splitLongitudeTriangles(instance);\n    } else if (geometry.primitiveType === PrimitiveType.LINES) {\n      splitLongitudeLines(instance);\n    }\n  }\n\n  return instance;\n};\nexport default GeometryPipeline;\n"]},"metadata":{},"sourceType":"module"}