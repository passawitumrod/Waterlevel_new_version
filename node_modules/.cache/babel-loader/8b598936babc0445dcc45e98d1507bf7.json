{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EasingFunction from \"../Core/EasingFunction.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport PerspectiveOffCenterFrustum from \"../Core/PerspectiveOffCenterFrustum.js\";\nimport SceneMode from \"./SceneMode.js\";\n/**\n * Creates tweens for camera flights.\n * <br /><br />\n * Mouse interaction is disabled during flights.\n *\n * @private\n */\n\nvar CameraFlightPath = {};\n\nfunction getAltitude(frustum, dx, dy) {\n  var near;\n  var top;\n  var right;\n\n  if (frustum instanceof PerspectiveFrustum) {\n    var tanTheta = Math.tan(0.5 * frustum.fovy);\n    near = frustum.near;\n    top = frustum.near * tanTheta;\n    right = frustum.aspectRatio * top;\n    return Math.max(dx * near / right, dy * near / top);\n  } else if (frustum instanceof PerspectiveOffCenterFrustum) {\n    near = frustum.near;\n    top = frustum.top;\n    right = frustum.right;\n    return Math.max(dx * near / right, dy * near / top);\n  }\n\n  return Math.max(dx, dy);\n}\n\nvar scratchCart = new Cartesian3();\nvar scratchCart2 = new Cartesian3();\n\nfunction createPitchFunction(startPitch, endPitch, heightFunction, pitchAdjustHeight) {\n  if (defined(pitchAdjustHeight) && heightFunction(0.5) > pitchAdjustHeight) {\n    var startHeight = heightFunction(0.0);\n    var endHeight = heightFunction(1.0);\n    var middleHeight = heightFunction(0.5);\n    var d1 = middleHeight - startHeight;\n    var d2 = middleHeight - endHeight;\n    return function (time) {\n      var altitude = heightFunction(time);\n\n      if (time <= 0.5) {\n        var t1 = (altitude - startHeight) / d1;\n        return CesiumMath.lerp(startPitch, -CesiumMath.PI_OVER_TWO, t1);\n      }\n\n      var t2 = (altitude - endHeight) / d2;\n      return CesiumMath.lerp(-CesiumMath.PI_OVER_TWO, endPitch, 1 - t2);\n    };\n  }\n\n  return function (time) {\n    return CesiumMath.lerp(startPitch, endPitch, time);\n  };\n}\n\nfunction createHeightFunction(camera, destination, startHeight, endHeight, optionAltitude) {\n  var altitude = optionAltitude;\n  var maxHeight = Math.max(startHeight, endHeight);\n\n  if (!defined(altitude)) {\n    var start = camera.position;\n    var end = destination;\n    var up = camera.up;\n    var right = camera.right;\n    var frustum = camera.frustum;\n    var diff = Cartesian3.subtract(start, end, scratchCart);\n    var verticalDistance = Cartesian3.magnitude(Cartesian3.multiplyByScalar(up, Cartesian3.dot(diff, up), scratchCart2));\n    var horizontalDistance = Cartesian3.magnitude(Cartesian3.multiplyByScalar(right, Cartesian3.dot(diff, right), scratchCart2));\n    altitude = Math.min(getAltitude(frustum, verticalDistance, horizontalDistance) * 0.2, 1000000000.0);\n  }\n\n  if (maxHeight < altitude) {\n    var power = 8.0;\n    var factor = 1000000.0;\n    var s = -Math.pow((altitude - startHeight) * factor, 1.0 / power);\n    var e = Math.pow((altitude - endHeight) * factor, 1.0 / power);\n    return function (t) {\n      var x = t * (e - s) + s;\n      return -Math.pow(x, power) / factor + altitude;\n    };\n  }\n\n  return function (t) {\n    return CesiumMath.lerp(startHeight, endHeight, t);\n  };\n}\n\nfunction adjustAngleForLERP(startAngle, endAngle) {\n  if (CesiumMath.equalsEpsilon(startAngle, CesiumMath.TWO_PI, CesiumMath.EPSILON11)) {\n    startAngle = 0.0;\n  }\n\n  if (endAngle > startAngle + Math.PI) {\n    startAngle += CesiumMath.TWO_PI;\n  } else if (endAngle < startAngle - Math.PI) {\n    startAngle -= CesiumMath.TWO_PI;\n  }\n\n  return startAngle;\n}\n\nvar scratchStart = new Cartesian3();\n\nfunction createUpdateCV(scene, duration, destination, heading, pitch, roll, optionAltitude) {\n  var camera = scene.camera;\n  var start = Cartesian3.clone(camera.position, scratchStart);\n  var startPitch = camera.pitch;\n  var startHeading = adjustAngleForLERP(camera.heading, heading);\n  var startRoll = adjustAngleForLERP(camera.roll, roll);\n  var heightFunction = createHeightFunction(camera, destination, start.z, destination.z, optionAltitude);\n\n  function update(value) {\n    var time = value.time / duration;\n    camera.setView({\n      orientation: {\n        heading: CesiumMath.lerp(startHeading, heading, time),\n        pitch: CesiumMath.lerp(startPitch, pitch, time),\n        roll: CesiumMath.lerp(startRoll, roll, time)\n      }\n    });\n    Cartesian2.lerp(start, destination, time, camera.position);\n    camera.position.z = heightFunction(time);\n  }\n\n  return update;\n}\n\nfunction useLongestFlight(startCart, destCart) {\n  if (startCart.longitude < destCart.longitude) {\n    startCart.longitude += CesiumMath.TWO_PI;\n  } else {\n    destCart.longitude += CesiumMath.TWO_PI;\n  }\n}\n\nfunction useShortestFlight(startCart, destCart) {\n  var diff = startCart.longitude - destCart.longitude;\n\n  if (diff < -CesiumMath.PI) {\n    startCart.longitude += CesiumMath.TWO_PI;\n  } else if (diff > CesiumMath.PI) {\n    destCart.longitude += CesiumMath.TWO_PI;\n  }\n}\n\nvar scratchStartCart = new Cartographic();\nvar scratchEndCart = new Cartographic();\n\nfunction createUpdate3D(scene, duration, destination, heading, pitch, roll, optionAltitude, optionFlyOverLongitude, optionFlyOverLongitudeWeight, optionPitchAdjustHeight) {\n  var camera = scene.camera;\n  var projection = scene.mapProjection;\n  var ellipsoid = projection.ellipsoid;\n  var startCart = Cartographic.clone(camera.positionCartographic, scratchStartCart);\n  var startPitch = camera.pitch;\n  var startHeading = adjustAngleForLERP(camera.heading, heading);\n  var startRoll = adjustAngleForLERP(camera.roll, roll);\n  var destCart = ellipsoid.cartesianToCartographic(destination, scratchEndCart);\n  startCart.longitude = CesiumMath.zeroToTwoPi(startCart.longitude);\n  destCart.longitude = CesiumMath.zeroToTwoPi(destCart.longitude);\n  var useLongFlight = false;\n\n  if (defined(optionFlyOverLongitude)) {\n    var hitLon = CesiumMath.zeroToTwoPi(optionFlyOverLongitude);\n    var lonMin = Math.min(startCart.longitude, destCart.longitude);\n    var lonMax = Math.max(startCart.longitude, destCart.longitude);\n    var hitInside = hitLon >= lonMin && hitLon <= lonMax;\n\n    if (defined(optionFlyOverLongitudeWeight)) {\n      // Distance inside  (0...2Pi)\n      var din = Math.abs(startCart.longitude - destCart.longitude); // Distance outside (0...2Pi)\n\n      var dot = CesiumMath.TWO_PI - din;\n      var hitDistance = hitInside ? din : dot;\n      var offDistance = hitInside ? dot : din;\n\n      if (hitDistance < offDistance * optionFlyOverLongitudeWeight && !hitInside) {\n        useLongFlight = true;\n      }\n    } else if (!hitInside) {\n      useLongFlight = true;\n    }\n  }\n\n  if (useLongFlight) {\n    useLongestFlight(startCart, destCart);\n  } else {\n    useShortestFlight(startCart, destCart);\n  }\n\n  var heightFunction = createHeightFunction(camera, destination, startCart.height, destCart.height, optionAltitude);\n  var pitchFunction = createPitchFunction(startPitch, pitch, heightFunction, optionPitchAdjustHeight); // Isolate scope for update function.\n  // to have local copies of vars used in lerp\n  // Othervise, if you call nex\n  // createUpdate3D (createAnimationTween)\n  // before you played animation, variables will be overwriten.\n\n  function isolateUpdateFunction() {\n    var startLongitude = startCart.longitude;\n    var destLongitude = destCart.longitude;\n    var startLatitude = startCart.latitude;\n    var destLatitude = destCart.latitude;\n    return function update(value) {\n      var time = value.time / duration;\n      var position = Cartesian3.fromRadians(CesiumMath.lerp(startLongitude, destLongitude, time), CesiumMath.lerp(startLatitude, destLatitude, time), heightFunction(time));\n      camera.setView({\n        destination: position,\n        orientation: {\n          heading: CesiumMath.lerp(startHeading, heading, time),\n          pitch: pitchFunction(time),\n          roll: CesiumMath.lerp(startRoll, roll, time)\n        }\n      });\n    };\n  }\n\n  return isolateUpdateFunction();\n}\n\nfunction createUpdate2D(scene, duration, destination, heading, pitch, roll, optionAltitude) {\n  var camera = scene.camera;\n  var start = Cartesian3.clone(camera.position, scratchStart);\n  var startHeading = adjustAngleForLERP(camera.heading, heading);\n  var startHeight = camera.frustum.right - camera.frustum.left;\n  var heightFunction = createHeightFunction(camera, destination, startHeight, destination.z, optionAltitude);\n\n  function update(value) {\n    var time = value.time / duration;\n    camera.setView({\n      orientation: {\n        heading: CesiumMath.lerp(startHeading, heading, time)\n      }\n    });\n    Cartesian2.lerp(start, destination, time, camera.position);\n    var zoom = heightFunction(time);\n    var frustum = camera.frustum;\n    var ratio = frustum.top / frustum.right;\n    var incrementAmount = (zoom - (frustum.right - frustum.left)) * 0.5;\n    frustum.right += incrementAmount;\n    frustum.left -= incrementAmount;\n    frustum.top = ratio * frustum.right;\n    frustum.bottom = -frustum.top;\n  }\n\n  return update;\n}\n\nvar scratchCartographic = new Cartographic();\nvar scratchDestination = new Cartesian3();\n\nfunction emptyFlight(complete, cancel) {\n  return {\n    startObject: {},\n    stopObject: {},\n    duration: 0.0,\n    complete: complete,\n    cancel: cancel\n  };\n}\n\nfunction wrapCallback(controller, cb) {\n  function wrapped() {\n    if (typeof cb === \"function\") {\n      cb();\n    }\n\n    controller.enableInputs = true;\n  }\n\n  return wrapped;\n}\n\nCameraFlightPath.createTween = function (scene, options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var destination = options.destination; //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n\n  if (!defined(destination)) {\n    throw new DeveloperError(\"destination is required.\");\n  } //>>includeEnd('debug');\n\n\n  var mode = scene.mode;\n\n  if (mode === SceneMode.MORPHING) {\n    return emptyFlight();\n  }\n\n  var convert = defaultValue(options.convert, true);\n  var projection = scene.mapProjection;\n  var ellipsoid = projection.ellipsoid;\n  var maximumHeight = options.maximumHeight;\n  var flyOverLongitude = options.flyOverLongitude;\n  var flyOverLongitudeWeight = options.flyOverLongitudeWeight;\n  var pitchAdjustHeight = options.pitchAdjustHeight;\n  var easingFunction = options.easingFunction;\n\n  if (convert && mode !== SceneMode.SCENE3D) {\n    ellipsoid.cartesianToCartographic(destination, scratchCartographic);\n    destination = projection.project(scratchCartographic, scratchDestination);\n  }\n\n  var camera = scene.camera;\n  var transform = options.endTransform;\n\n  if (defined(transform)) {\n    camera._setTransform(transform);\n  }\n\n  var duration = options.duration;\n\n  if (!defined(duration)) {\n    duration = Math.ceil(Cartesian3.distance(camera.position, destination) / 1000000.0) + 2.0;\n    duration = Math.min(duration, 3.0);\n  }\n\n  var heading = defaultValue(options.heading, 0.0);\n  var pitch = defaultValue(options.pitch, -CesiumMath.PI_OVER_TWO);\n  var roll = defaultValue(options.roll, 0.0);\n  var controller = scene.screenSpaceCameraController;\n  controller.enableInputs = false;\n  var complete = wrapCallback(controller, options.complete);\n  var cancel = wrapCallback(controller, options.cancel);\n  var frustum = camera.frustum;\n  var empty = scene.mode === SceneMode.SCENE2D;\n  empty = empty && Cartesian2.equalsEpsilon(camera.position, destination, CesiumMath.EPSILON6);\n  empty = empty && CesiumMath.equalsEpsilon(Math.max(frustum.right - frustum.left, frustum.top - frustum.bottom), destination.z, CesiumMath.EPSILON6);\n  empty = empty || scene.mode !== SceneMode.SCENE2D && Cartesian3.equalsEpsilon(destination, camera.position, CesiumMath.EPSILON10);\n  empty = empty && CesiumMath.equalsEpsilon(CesiumMath.negativePiToPi(heading), CesiumMath.negativePiToPi(camera.heading), CesiumMath.EPSILON10) && CesiumMath.equalsEpsilon(CesiumMath.negativePiToPi(pitch), CesiumMath.negativePiToPi(camera.pitch), CesiumMath.EPSILON10) && CesiumMath.equalsEpsilon(CesiumMath.negativePiToPi(roll), CesiumMath.negativePiToPi(camera.roll), CesiumMath.EPSILON10);\n\n  if (empty) {\n    return emptyFlight(complete, cancel);\n  }\n\n  var updateFunctions = new Array(4);\n  updateFunctions[SceneMode.SCENE2D] = createUpdate2D;\n  updateFunctions[SceneMode.SCENE3D] = createUpdate3D;\n  updateFunctions[SceneMode.COLUMBUS_VIEW] = createUpdateCV;\n\n  if (duration <= 0.0) {\n    var newOnComplete = function () {\n      var update = updateFunctions[mode](scene, 1.0, destination, heading, pitch, roll, maximumHeight, flyOverLongitude, flyOverLongitudeWeight, pitchAdjustHeight);\n      update({\n        time: 1.0\n      });\n\n      if (typeof complete === \"function\") {\n        complete();\n      }\n    };\n\n    return emptyFlight(newOnComplete, cancel);\n  }\n\n  var update = updateFunctions[mode](scene, duration, destination, heading, pitch, roll, maximumHeight, flyOverLongitude, flyOverLongitudeWeight, pitchAdjustHeight);\n\n  if (!defined(easingFunction)) {\n    var startHeight = camera.positionCartographic.height;\n    var endHeight = mode === SceneMode.SCENE3D ? ellipsoid.cartesianToCartographic(destination).height : destination.z;\n\n    if (startHeight > endHeight && startHeight > 11500.0) {\n      easingFunction = EasingFunction.CUBIC_OUT;\n    } else {\n      easingFunction = EasingFunction.QUINTIC_IN_OUT;\n    }\n  }\n\n  return {\n    duration: duration,\n    easingFunction: easingFunction,\n    startObject: {\n      time: 0.0\n    },\n    stopObject: {\n      time: duration\n    },\n    update: update,\n    complete: complete,\n    cancel: cancel\n  };\n};\n\nexport default CameraFlightPath;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Scene/CameraFlightPath.js"],"names":["Cartesian2","Cartesian3","Cartographic","defaultValue","defined","DeveloperError","EasingFunction","CesiumMath","PerspectiveFrustum","PerspectiveOffCenterFrustum","SceneMode","CameraFlightPath","getAltitude","frustum","dx","dy","near","top","right","tanTheta","Math","tan","fovy","aspectRatio","max","scratchCart","scratchCart2","createPitchFunction","startPitch","endPitch","heightFunction","pitchAdjustHeight","startHeight","endHeight","middleHeight","d1","d2","time","altitude","t1","lerp","PI_OVER_TWO","t2","createHeightFunction","camera","destination","optionAltitude","maxHeight","start","position","end","up","diff","subtract","verticalDistance","magnitude","multiplyByScalar","dot","horizontalDistance","min","power","factor","s","pow","e","t","x","adjustAngleForLERP","startAngle","endAngle","equalsEpsilon","TWO_PI","EPSILON11","PI","scratchStart","createUpdateCV","scene","duration","heading","pitch","roll","clone","startHeading","startRoll","z","update","value","setView","orientation","useLongestFlight","startCart","destCart","longitude","useShortestFlight","scratchStartCart","scratchEndCart","createUpdate3D","optionFlyOverLongitude","optionFlyOverLongitudeWeight","optionPitchAdjustHeight","projection","mapProjection","ellipsoid","positionCartographic","cartesianToCartographic","zeroToTwoPi","useLongFlight","hitLon","lonMin","lonMax","hitInside","din","abs","hitDistance","offDistance","height","pitchFunction","isolateUpdateFunction","startLongitude","destLongitude","startLatitude","latitude","destLatitude","fromRadians","createUpdate2D","left","zoom","ratio","incrementAmount","bottom","scratchCartographic","scratchDestination","emptyFlight","complete","cancel","startObject","stopObject","wrapCallback","controller","cb","wrapped","enableInputs","createTween","options","EMPTY_OBJECT","mode","MORPHING","convert","maximumHeight","flyOverLongitude","flyOverLongitudeWeight","easingFunction","SCENE3D","project","transform","endTransform","_setTransform","ceil","distance","screenSpaceCameraController","empty","SCENE2D","EPSILON6","EPSILON10","negativePiToPi","updateFunctions","Array","COLUMBUS_VIEW","newOnComplete","CUBIC_OUT","QUINTIC_IN_OUT"],"mappings":"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","sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EasingFunction from \"../Core/EasingFunction.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport PerspectiveOffCenterFrustum from \"../Core/PerspectiveOffCenterFrustum.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * Creates tweens for camera flights.\n * <br /><br />\n * Mouse interaction is disabled during flights.\n *\n * @private\n */\nvar CameraFlightPath = {};\n\nfunction getAltitude(frustum, dx, dy) {\n  var near;\n  var top;\n  var right;\n  if (frustum instanceof PerspectiveFrustum) {\n    var tanTheta = Math.tan(0.5 * frustum.fovy);\n    near = frustum.near;\n    top = frustum.near * tanTheta;\n    right = frustum.aspectRatio * top;\n    return Math.max((dx * near) / right, (dy * near) / top);\n  } else if (frustum instanceof PerspectiveOffCenterFrustum) {\n    near = frustum.near;\n    top = frustum.top;\n    right = frustum.right;\n    return Math.max((dx * near) / right, (dy * near) / top);\n  }\n\n  return Math.max(dx, dy);\n}\n\nvar scratchCart = new Cartesian3();\nvar scratchCart2 = new Cartesian3();\n\nfunction createPitchFunction(\n  startPitch,\n  endPitch,\n  heightFunction,\n  pitchAdjustHeight\n) {\n  if (defined(pitchAdjustHeight) && heightFunction(0.5) > pitchAdjustHeight) {\n    var startHeight = heightFunction(0.0);\n    var endHeight = heightFunction(1.0);\n    var middleHeight = heightFunction(0.5);\n\n    var d1 = middleHeight - startHeight;\n    var d2 = middleHeight - endHeight;\n\n    return function (time) {\n      var altitude = heightFunction(time);\n      if (time <= 0.5) {\n        var t1 = (altitude - startHeight) / d1;\n        return CesiumMath.lerp(startPitch, -CesiumMath.PI_OVER_TWO, t1);\n      }\n\n      var t2 = (altitude - endHeight) / d2;\n      return CesiumMath.lerp(-CesiumMath.PI_OVER_TWO, endPitch, 1 - t2);\n    };\n  }\n  return function (time) {\n    return CesiumMath.lerp(startPitch, endPitch, time);\n  };\n}\n\nfunction createHeightFunction(\n  camera,\n  destination,\n  startHeight,\n  endHeight,\n  optionAltitude\n) {\n  var altitude = optionAltitude;\n  var maxHeight = Math.max(startHeight, endHeight);\n\n  if (!defined(altitude)) {\n    var start = camera.position;\n    var end = destination;\n    var up = camera.up;\n    var right = camera.right;\n    var frustum = camera.frustum;\n\n    var diff = Cartesian3.subtract(start, end, scratchCart);\n    var verticalDistance = Cartesian3.magnitude(\n      Cartesian3.multiplyByScalar(up, Cartesian3.dot(diff, up), scratchCart2)\n    );\n    var horizontalDistance = Cartesian3.magnitude(\n      Cartesian3.multiplyByScalar(\n        right,\n        Cartesian3.dot(diff, right),\n        scratchCart2\n      )\n    );\n\n    altitude = Math.min(\n      getAltitude(frustum, verticalDistance, horizontalDistance) * 0.2,\n      1000000000.0\n    );\n  }\n\n  if (maxHeight < altitude) {\n    var power = 8.0;\n    var factor = 1000000.0;\n\n    var s = -Math.pow((altitude - startHeight) * factor, 1.0 / power);\n    var e = Math.pow((altitude - endHeight) * factor, 1.0 / power);\n\n    return function (t) {\n      var x = t * (e - s) + s;\n      return -Math.pow(x, power) / factor + altitude;\n    };\n  }\n\n  return function (t) {\n    return CesiumMath.lerp(startHeight, endHeight, t);\n  };\n}\n\nfunction adjustAngleForLERP(startAngle, endAngle) {\n  if (\n    CesiumMath.equalsEpsilon(\n      startAngle,\n      CesiumMath.TWO_PI,\n      CesiumMath.EPSILON11\n    )\n  ) {\n    startAngle = 0.0;\n  }\n\n  if (endAngle > startAngle + Math.PI) {\n    startAngle += CesiumMath.TWO_PI;\n  } else if (endAngle < startAngle - Math.PI) {\n    startAngle -= CesiumMath.TWO_PI;\n  }\n\n  return startAngle;\n}\n\nvar scratchStart = new Cartesian3();\n\nfunction createUpdateCV(\n  scene,\n  duration,\n  destination,\n  heading,\n  pitch,\n  roll,\n  optionAltitude\n) {\n  var camera = scene.camera;\n\n  var start = Cartesian3.clone(camera.position, scratchStart);\n  var startPitch = camera.pitch;\n  var startHeading = adjustAngleForLERP(camera.heading, heading);\n  var startRoll = adjustAngleForLERP(camera.roll, roll);\n\n  var heightFunction = createHeightFunction(\n    camera,\n    destination,\n    start.z,\n    destination.z,\n    optionAltitude\n  );\n\n  function update(value) {\n    var time = value.time / duration;\n\n    camera.setView({\n      orientation: {\n        heading: CesiumMath.lerp(startHeading, heading, time),\n        pitch: CesiumMath.lerp(startPitch, pitch, time),\n        roll: CesiumMath.lerp(startRoll, roll, time),\n      },\n    });\n\n    Cartesian2.lerp(start, destination, time, camera.position);\n    camera.position.z = heightFunction(time);\n  }\n  return update;\n}\n\nfunction useLongestFlight(startCart, destCart) {\n  if (startCart.longitude < destCart.longitude) {\n    startCart.longitude += CesiumMath.TWO_PI;\n  } else {\n    destCart.longitude += CesiumMath.TWO_PI;\n  }\n}\n\nfunction useShortestFlight(startCart, destCart) {\n  var diff = startCart.longitude - destCart.longitude;\n  if (diff < -CesiumMath.PI) {\n    startCart.longitude += CesiumMath.TWO_PI;\n  } else if (diff > CesiumMath.PI) {\n    destCart.longitude += CesiumMath.TWO_PI;\n  }\n}\n\nvar scratchStartCart = new Cartographic();\nvar scratchEndCart = new Cartographic();\n\nfunction createUpdate3D(\n  scene,\n  duration,\n  destination,\n  heading,\n  pitch,\n  roll,\n  optionAltitude,\n  optionFlyOverLongitude,\n  optionFlyOverLongitudeWeight,\n  optionPitchAdjustHeight\n) {\n  var camera = scene.camera;\n  var projection = scene.mapProjection;\n  var ellipsoid = projection.ellipsoid;\n\n  var startCart = Cartographic.clone(\n    camera.positionCartographic,\n    scratchStartCart\n  );\n  var startPitch = camera.pitch;\n  var startHeading = adjustAngleForLERP(camera.heading, heading);\n  var startRoll = adjustAngleForLERP(camera.roll, roll);\n\n  var destCart = ellipsoid.cartesianToCartographic(destination, scratchEndCart);\n  startCart.longitude = CesiumMath.zeroToTwoPi(startCart.longitude);\n  destCart.longitude = CesiumMath.zeroToTwoPi(destCart.longitude);\n\n  var useLongFlight = false;\n\n  if (defined(optionFlyOverLongitude)) {\n    var hitLon = CesiumMath.zeroToTwoPi(optionFlyOverLongitude);\n\n    var lonMin = Math.min(startCart.longitude, destCart.longitude);\n    var lonMax = Math.max(startCart.longitude, destCart.longitude);\n\n    var hitInside = hitLon >= lonMin && hitLon <= lonMax;\n\n    if (defined(optionFlyOverLongitudeWeight)) {\n      // Distance inside  (0...2Pi)\n      var din = Math.abs(startCart.longitude - destCart.longitude);\n      // Distance outside (0...2Pi)\n      var dot = CesiumMath.TWO_PI - din;\n\n      var hitDistance = hitInside ? din : dot;\n      var offDistance = hitInside ? dot : din;\n\n      if (\n        hitDistance < offDistance * optionFlyOverLongitudeWeight &&\n        !hitInside\n      ) {\n        useLongFlight = true;\n      }\n    } else if (!hitInside) {\n      useLongFlight = true;\n    }\n  }\n\n  if (useLongFlight) {\n    useLongestFlight(startCart, destCart);\n  } else {\n    useShortestFlight(startCart, destCart);\n  }\n\n  var heightFunction = createHeightFunction(\n    camera,\n    destination,\n    startCart.height,\n    destCart.height,\n    optionAltitude\n  );\n  var pitchFunction = createPitchFunction(\n    startPitch,\n    pitch,\n    heightFunction,\n    optionPitchAdjustHeight\n  );\n\n  // Isolate scope for update function.\n  // to have local copies of vars used in lerp\n  // Othervise, if you call nex\n  // createUpdate3D (createAnimationTween)\n  // before you played animation, variables will be overwriten.\n  function isolateUpdateFunction() {\n    var startLongitude = startCart.longitude;\n    var destLongitude = destCart.longitude;\n    var startLatitude = startCart.latitude;\n    var destLatitude = destCart.latitude;\n\n    return function update(value) {\n      var time = value.time / duration;\n\n      var position = Cartesian3.fromRadians(\n        CesiumMath.lerp(startLongitude, destLongitude, time),\n        CesiumMath.lerp(startLatitude, destLatitude, time),\n        heightFunction(time)\n      );\n\n      camera.setView({\n        destination: position,\n        orientation: {\n          heading: CesiumMath.lerp(startHeading, heading, time),\n          pitch: pitchFunction(time),\n          roll: CesiumMath.lerp(startRoll, roll, time),\n        },\n      });\n    };\n  }\n  return isolateUpdateFunction();\n}\n\nfunction createUpdate2D(\n  scene,\n  duration,\n  destination,\n  heading,\n  pitch,\n  roll,\n  optionAltitude\n) {\n  var camera = scene.camera;\n\n  var start = Cartesian3.clone(camera.position, scratchStart);\n  var startHeading = adjustAngleForLERP(camera.heading, heading);\n\n  var startHeight = camera.frustum.right - camera.frustum.left;\n  var heightFunction = createHeightFunction(\n    camera,\n    destination,\n    startHeight,\n    destination.z,\n    optionAltitude\n  );\n\n  function update(value) {\n    var time = value.time / duration;\n\n    camera.setView({\n      orientation: {\n        heading: CesiumMath.lerp(startHeading, heading, time),\n      },\n    });\n\n    Cartesian2.lerp(start, destination, time, camera.position);\n\n    var zoom = heightFunction(time);\n\n    var frustum = camera.frustum;\n    var ratio = frustum.top / frustum.right;\n\n    var incrementAmount = (zoom - (frustum.right - frustum.left)) * 0.5;\n    frustum.right += incrementAmount;\n    frustum.left -= incrementAmount;\n    frustum.top = ratio * frustum.right;\n    frustum.bottom = -frustum.top;\n  }\n  return update;\n}\n\nvar scratchCartographic = new Cartographic();\nvar scratchDestination = new Cartesian3();\n\nfunction emptyFlight(complete, cancel) {\n  return {\n    startObject: {},\n    stopObject: {},\n    duration: 0.0,\n    complete: complete,\n    cancel: cancel,\n  };\n}\n\nfunction wrapCallback(controller, cb) {\n  function wrapped() {\n    if (typeof cb === \"function\") {\n      cb();\n    }\n\n    controller.enableInputs = true;\n  }\n  return wrapped;\n}\n\nCameraFlightPath.createTween = function (scene, options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var destination = options.destination;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  if (!defined(destination)) {\n    throw new DeveloperError(\"destination is required.\");\n  }\n  //>>includeEnd('debug');\n  var mode = scene.mode;\n\n  if (mode === SceneMode.MORPHING) {\n    return emptyFlight();\n  }\n\n  var convert = defaultValue(options.convert, true);\n  var projection = scene.mapProjection;\n  var ellipsoid = projection.ellipsoid;\n  var maximumHeight = options.maximumHeight;\n  var flyOverLongitude = options.flyOverLongitude;\n  var flyOverLongitudeWeight = options.flyOverLongitudeWeight;\n  var pitchAdjustHeight = options.pitchAdjustHeight;\n  var easingFunction = options.easingFunction;\n\n  if (convert && mode !== SceneMode.SCENE3D) {\n    ellipsoid.cartesianToCartographic(destination, scratchCartographic);\n    destination = projection.project(scratchCartographic, scratchDestination);\n  }\n\n  var camera = scene.camera;\n  var transform = options.endTransform;\n  if (defined(transform)) {\n    camera._setTransform(transform);\n  }\n\n  var duration = options.duration;\n  if (!defined(duration)) {\n    duration =\n      Math.ceil(Cartesian3.distance(camera.position, destination) / 1000000.0) +\n      2.0;\n    duration = Math.min(duration, 3.0);\n  }\n\n  var heading = defaultValue(options.heading, 0.0);\n  var pitch = defaultValue(options.pitch, -CesiumMath.PI_OVER_TWO);\n  var roll = defaultValue(options.roll, 0.0);\n\n  var controller = scene.screenSpaceCameraController;\n  controller.enableInputs = false;\n\n  var complete = wrapCallback(controller, options.complete);\n  var cancel = wrapCallback(controller, options.cancel);\n\n  var frustum = camera.frustum;\n\n  var empty = scene.mode === SceneMode.SCENE2D;\n  empty =\n    empty &&\n    Cartesian2.equalsEpsilon(camera.position, destination, CesiumMath.EPSILON6);\n  empty =\n    empty &&\n    CesiumMath.equalsEpsilon(\n      Math.max(frustum.right - frustum.left, frustum.top - frustum.bottom),\n      destination.z,\n      CesiumMath.EPSILON6\n    );\n\n  empty =\n    empty ||\n    (scene.mode !== SceneMode.SCENE2D &&\n      Cartesian3.equalsEpsilon(\n        destination,\n        camera.position,\n        CesiumMath.EPSILON10\n      ));\n\n  empty =\n    empty &&\n    CesiumMath.equalsEpsilon(\n      CesiumMath.negativePiToPi(heading),\n      CesiumMath.negativePiToPi(camera.heading),\n      CesiumMath.EPSILON10\n    ) &&\n    CesiumMath.equalsEpsilon(\n      CesiumMath.negativePiToPi(pitch),\n      CesiumMath.negativePiToPi(camera.pitch),\n      CesiumMath.EPSILON10\n    ) &&\n    CesiumMath.equalsEpsilon(\n      CesiumMath.negativePiToPi(roll),\n      CesiumMath.negativePiToPi(camera.roll),\n      CesiumMath.EPSILON10\n    );\n\n  if (empty) {\n    return emptyFlight(complete, cancel);\n  }\n\n  var updateFunctions = new Array(4);\n  updateFunctions[SceneMode.SCENE2D] = createUpdate2D;\n  updateFunctions[SceneMode.SCENE3D] = createUpdate3D;\n  updateFunctions[SceneMode.COLUMBUS_VIEW] = createUpdateCV;\n\n  if (duration <= 0.0) {\n    var newOnComplete = function () {\n      var update = updateFunctions[mode](\n        scene,\n        1.0,\n        destination,\n        heading,\n        pitch,\n        roll,\n        maximumHeight,\n        flyOverLongitude,\n        flyOverLongitudeWeight,\n        pitchAdjustHeight\n      );\n      update({ time: 1.0 });\n\n      if (typeof complete === \"function\") {\n        complete();\n      }\n    };\n    return emptyFlight(newOnComplete, cancel);\n  }\n\n  var update = updateFunctions[mode](\n    scene,\n    duration,\n    destination,\n    heading,\n    pitch,\n    roll,\n    maximumHeight,\n    flyOverLongitude,\n    flyOverLongitudeWeight,\n    pitchAdjustHeight\n  );\n\n  if (!defined(easingFunction)) {\n    var startHeight = camera.positionCartographic.height;\n    var endHeight =\n      mode === SceneMode.SCENE3D\n        ? ellipsoid.cartesianToCartographic(destination).height\n        : destination.z;\n\n    if (startHeight > endHeight && startHeight > 11500.0) {\n      easingFunction = EasingFunction.CUBIC_OUT;\n    } else {\n      easingFunction = EasingFunction.QUINTIC_IN_OUT;\n    }\n  }\n\n  return {\n    duration: duration,\n    easingFunction: easingFunction,\n    startObject: {\n      time: 0.0,\n    },\n    stopObject: {\n      time: duration,\n    },\n    update: update,\n    complete: complete,\n    cancel: cancel,\n  };\n};\nexport default CameraFlightPath;\n"]},"metadata":{},"sourceType":"module"}