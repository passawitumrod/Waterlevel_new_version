{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport buildModuleUrl from \"../Core/buildModuleUrl.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EllipsoidTerrainProvider from \"../Core/EllipsoidTerrainProvider.js\";\nimport Event from \"../Core/Event.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Resource from \"../Core/Resource.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport GlobeFS from \"../Shaders/GlobeFS.js\";\nimport GlobeVS from \"../Shaders/GlobeVS.js\";\nimport GroundAtmosphere from \"../Shaders/GroundAtmosphere.js\";\nimport when from \"../ThirdParty/when.js\";\nimport GlobeSurfaceShaderSet from \"./GlobeSurfaceShaderSet.js\";\nimport GlobeSurfaceTileProvider from \"./GlobeSurfaceTileProvider.js\";\nimport ImageryLayerCollection from \"./ImageryLayerCollection.js\";\nimport QuadtreePrimitive from \"./QuadtreePrimitive.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\n/**\n * The globe rendered in the scene, including its terrain ({@link Globe#terrainProvider})\n * and imagery layers ({@link Globe#imageryLayers}).  Access the globe using {@link Scene#globe}.\n *\n * @alias Globe\n * @constructor\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] Determines the size and shape of the\n * globe.\n */\n\nfunction Globe(ellipsoid) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  var terrainProvider = new EllipsoidTerrainProvider({\n    ellipsoid: ellipsoid\n  });\n  var imageryLayerCollection = new ImageryLayerCollection();\n  this._ellipsoid = ellipsoid;\n  this._imageryLayerCollection = imageryLayerCollection;\n  this._surfaceShaderSet = new GlobeSurfaceShaderSet();\n  this._material = undefined;\n  this._surface = new QuadtreePrimitive({\n    tileProvider: new GlobeSurfaceTileProvider({\n      terrainProvider: terrainProvider,\n      imageryLayers: imageryLayerCollection,\n      surfaceShaderSet: this._surfaceShaderSet\n    })\n  });\n  this._terrainProvider = terrainProvider;\n  this._terrainProviderChanged = new Event();\n  makeShadersDirty(this);\n  /**\n   * Determines if the globe will be shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.show = true;\n  this._oceanNormalMapResourceDirty = true;\n  this._oceanNormalMapResource = new Resource({\n    url: buildModuleUrl(\"Assets/Textures/waterNormalsSmall.jpg\")\n  });\n  /**\n   * The maximum screen-space error used to drive level-of-detail refinement.  Higher\n   * values will provide better performance but lower visual quality.\n   *\n   * @type {Number}\n   * @default 2\n   */\n\n  this.maximumScreenSpaceError = 2;\n  /**\n   * The size of the terrain tile cache, expressed as a number of tiles.  Any additional\n   * tiles beyond this number will be freed, as long as they aren't needed for rendering\n   * this frame.  A larger number will consume more memory but will show detail faster\n   * when, for example, zooming out and then back in.\n   *\n   * @type {Number}\n   * @default 100\n   */\n\n  this.tileCacheSize = 100;\n  /**\n   * Gets or sets the number of loading descendant tiles that is considered \"too many\".\n   * If a tile has too many loading descendants, that tile will be loaded and rendered before any of\n   * its descendants are loaded and rendered. This means more feedback for the user that something\n   * is happening at the cost of a longer overall load time. Setting this to 0 will cause each\n   * tile level to be loaded successively, significantly increasing load time. Setting it to a large\n   * number (e.g. 1000) will minimize the number of tiles that are loaded but tend to make\n   * detail appear all at once after a long wait.\n   * @type {Number}\n   * @default 20\n   */\n\n  this.loadingDescendantLimit = 20;\n  /**\n   * Gets or sets a value indicating whether the ancestors of rendered tiles should be preloaded.\n   * Setting this to true optimizes the zoom-out experience and provides more detail in\n   * newly-exposed areas when panning. The down side is that it requires loading more tiles.\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.preloadAncestors = true;\n  /**\n   * Gets or sets a value indicating whether the siblings of rendered tiles should be preloaded.\n   * Setting this to true causes tiles with the same parent as a rendered tile to be loaded, even\n   * if they are culled. Setting this to true may provide a better panning experience at the\n   * cost of loading more tiles.\n   * @type {Boolean}\n   * @default false\n   */\n\n  this.preloadSiblings = false;\n  /**\n   * The color to use to highlight terrain fill tiles. If undefined, fill tiles are not\n   * highlighted at all. The alpha value is used to alpha blend with the tile's\n   * actual color. Because terrain fill tiles do not represent the actual terrain surface,\n   * it may be useful in some applications to indicate visually that they are not to be trusted.\n   * @type {Color}\n   * @default undefined\n   */\n\n  this.fillHighlightColor = undefined;\n  /**\n   * Enable lighting the globe with the scene's light source.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n\n  this.enableLighting = false;\n  /**\n   * Enable dynamic lighting effects on atmosphere and fog. This only takes effect\n   * when <code>enableLighting</code> is <code>true</code>.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.dynamicAtmosphereLighting = true;\n  /**\n   * Whether dynamic atmosphere lighting uses the sun direction instead of the scene's\n   * light direction. This only takes effect when <code>enableLighting</code> and\n   * <code>dynamicAtmosphereLighting</code> are <code>true</code>.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n\n  this.dynamicAtmosphereLightingFromSun = false;\n  /**\n   * Enable the ground atmosphere, which is drawn over the globe when viewed from a distance between <code>lightingFadeInDistance</code> and <code>lightingFadeOutDistance</code>.\n   *\n   * @demo {@link https://sandcastle.cesium.com/index.html?src=Ground%20Atmosphere.html|Ground atmosphere demo in Sandcastle}\n   *\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.showGroundAtmosphere = true;\n  /**\n   * The distance where everything becomes lit. This only takes effect\n   * when <code>enableLighting</code> or <code>showGroundAtmosphere</code> is <code>true</code>.\n   *\n   * @type {Number}\n   * @default 10000000.0\n   */\n\n  this.lightingFadeOutDistance = 1.0e7;\n  /**\n   * The distance where lighting resumes. This only takes effect\n   * when <code>enableLighting</code> or <code>showGroundAtmosphere</code> is <code>true</code>.\n   *\n   * @type {Number}\n   * @default 20000000.0\n   */\n\n  this.lightingFadeInDistance = 2.0e7;\n  /**\n   * The distance where the darkness of night from the ground atmosphere fades out to a lit ground atmosphere.\n   * This only takes effect when <code>showGroundAtmosphere</code>, <code>enableLighting</code>, and\n   * <code>dynamicAtmosphereLighting</code> are <code>true</code>.\n   *\n   * @type {Number}\n   * @default 10000000.0\n   */\n\n  this.nightFadeOutDistance = 1.0e7;\n  /**\n   * The distance where the darkness of night from the ground atmosphere fades in to an unlit ground atmosphere.\n   * This only takes effect when <code>showGroundAtmosphere</code>, <code>enableLighting</code>, and\n   * <code>dynamicAtmosphereLighting</code> are <code>true</code>.\n   *\n   * @type {Number}\n   * @default 50000000.0\n   */\n\n  this.nightFadeInDistance = 5.0e7;\n  /**\n   * True if an animated wave effect should be shown in areas of the globe\n   * covered by water; otherwise, false.  This property is ignored if the\n   * <code>terrainProvider</code> does not provide a water mask.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.showWaterEffect = true;\n  /**\n   * True if primitives such as billboards, polylines, labels, etc. should be depth-tested\n   * against the terrain surface, or false if such primitives should always be drawn on top\n   * of terrain unless they're on the opposite side of the globe.  The disadvantage of depth\n   * testing primitives against terrain is that slight numerical noise or terrain level-of-detail\n   * switched can sometimes make a primitive that should be on the surface disappear underneath it.\n   *\n   * @type {Boolean}\n   * @default false\n   *\n   */\n\n  this.depthTestAgainstTerrain = false;\n  /**\n   * Determines whether the globe casts or receives shadows from light sources. Setting the globe\n   * to cast shadows may impact performance since the terrain is rendered again from the light's perspective.\n   * Currently only terrain that is in view casts shadows. By default the globe does not cast shadows.\n   *\n   * @type {ShadowMode}\n   * @default ShadowMode.RECEIVE_ONLY\n   */\n\n  this.shadows = ShadowMode.RECEIVE_ONLY;\n  /**\n   * The hue shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A hue shift of 1.0 indicates a complete rotation of the hues available.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.atmosphereHueShift = 0.0;\n  /**\n   * The saturation shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A saturation shift of -1.0 is monochrome.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.atmosphereSaturationShift = 0.0;\n  /**\n   * The brightness shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A brightness shift of -1.0 is complete darkness, which will let space show through.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.atmosphereBrightnessShift = 0.0;\n  /**\n   * Whether to show terrain skirts. Terrain skirts are geometry extending downwards from a tile's edges used to hide seams between neighboring tiles.\n   * It may be desirable to hide terrain skirts if terrain is translucent or when viewing terrain from below the surface.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.showSkirts = true;\n  /**\n   * Whether to cull back-facing terrain. Set this to false when viewing terrain from below the surface.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.backFaceCulling = true;\n  this._oceanNormalMap = undefined;\n  this._zoomedOutOceanSpecularIntensity = undefined;\n}\n\nObject.defineProperties(Globe.prototype, {\n  /**\n   * Gets an ellipsoid describing the shape of this globe.\n   * @memberof Globe.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function get() {\n      return this._ellipsoid;\n    }\n  },\n\n  /**\n   * Gets the collection of image layers that will be rendered on this globe.\n   * @memberof Globe.prototype\n   * @type {ImageryLayerCollection}\n   */\n  imageryLayers: {\n    get: function get() {\n      return this._imageryLayerCollection;\n    }\n  },\n\n  /**\n   * Gets an event that's raised when an imagery layer is added, shown, hidden, moved, or removed.\n   *\n   * @memberof Globe.prototype\n   * @type {Event}\n   * @readonly\n   */\n  imageryLayersUpdatedEvent: {\n    get: function get() {\n      return this._surface.tileProvider.imageryLayersUpdatedEvent;\n    }\n  },\n\n  /**\n   * Returns <code>true</code> when the tile load queue is empty, <code>false</code> otherwise.  When the load queue is empty,\n   * all terrain and imagery for the current view have been loaded.\n   * @memberof Globe.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  tilesLoaded: {\n    get: function get() {\n      if (!defined(this._surface)) {\n        return true;\n      }\n\n      return this._surface.tileProvider.ready && this._surface._tileLoadQueueHigh.length === 0 && this._surface._tileLoadQueueMedium.length === 0 && this._surface._tileLoadQueueLow.length === 0;\n    }\n  },\n\n  /**\n   * Gets or sets the color of the globe when no imagery is available.\n   * @memberof Globe.prototype\n   * @type {Color}\n   */\n  baseColor: {\n    get: function get() {\n      return this._surface.tileProvider.baseColor;\n    },\n    set: function set(value) {\n      this._surface.tileProvider.baseColor = value;\n    }\n  },\n\n  /**\n   * A property specifying a {@link ClippingPlaneCollection} used to selectively disable rendering on the outside of each plane.\n   *\n   * @memberof Globe.prototype\n   * @type {ClippingPlaneCollection}\n   */\n  clippingPlanes: {\n    get: function get() {\n      return this._surface.tileProvider.clippingPlanes;\n    },\n    set: function set(value) {\n      this._surface.tileProvider.clippingPlanes = value;\n    }\n  },\n\n  /**\n   * A property specifying a {@link Rectangle} used to limit globe rendering to a cartographic area.\n   * Defaults to the maximum extent of cartographic coordinates.\n   *\n   * @member Globe.prototype\n   * @type {Rectangle}\n   * @default Rectangle.MAX_VALUE\n   */\n  cartographicLimitRectangle: {\n    get: function get() {\n      return this._surface.tileProvider.cartographicLimitRectangle;\n    },\n    set: function set(value) {\n      if (!defined(value)) {\n        value = Rectangle.clone(Rectangle.MAX_VALUE);\n      }\n\n      this._surface.tileProvider.cartographicLimitRectangle = value;\n    }\n  },\n\n  /**\n   * The normal map to use for rendering waves in the ocean.  Setting this property will\n   * only have an effect if the configured terrain provider includes a water mask.\n   * @memberof Globe.prototype\n   * @type {String}\n   * @default buildModuleUrl('Assets/Textures/waterNormalsSmall.jpg')\n   */\n  oceanNormalMapUrl: {\n    get: function get() {\n      return this._oceanNormalMapResource.url;\n    },\n    set: function set(value) {\n      this._oceanNormalMapResource.url = value;\n      this._oceanNormalMapResourceDirty = true;\n    }\n  },\n\n  /**\n   * The terrain provider providing surface geometry for this globe.\n   * @type {TerrainProvider}\n   *\n   * @memberof Globe.prototype\n   * @type {TerrainProvider}\n   *\n   */\n  terrainProvider: {\n    get: function get() {\n      return this._terrainProvider;\n    },\n    set: function set(value) {\n      if (value !== this._terrainProvider) {\n        this._terrainProvider = value;\n\n        this._terrainProviderChanged.raiseEvent(value);\n\n        if (defined(this._material)) {\n          makeShadersDirty(this);\n        }\n      }\n    }\n  },\n\n  /**\n   * Gets an event that's raised when the terrain provider is changed\n   *\n   * @memberof Globe.prototype\n   * @type {Event}\n   * @readonly\n   */\n  terrainProviderChanged: {\n    get: function get() {\n      return this._terrainProviderChanged;\n    }\n  },\n\n  /**\n   * Gets an event that's raised when the length of the tile load queue has changed since the last render frame.  When the load queue is empty,\n   * all terrain and imagery for the current view have been loaded.  The event passes the new length of the tile load queue.\n   *\n   * @memberof Globe.prototype\n   * @type {Event}\n   */\n  tileLoadProgressEvent: {\n    get: function get() {\n      return this._surface.tileLoadProgressEvent;\n    }\n  },\n\n  /**\n   * Gets or sets the material appearance of the Globe.  This can be one of several built-in {@link Material} objects or a custom material, scripted with\n   * {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}.\n   * @memberof Globe.prototype\n   * @type {Material}\n   */\n  material: {\n    get: function get() {\n      return this._material;\n    },\n    set: function set(material) {\n      if (this._material !== material) {\n        this._material = material;\n        makeShadersDirty(this);\n      }\n    }\n  }\n});\n\nfunction makeShadersDirty(globe) {\n  var defines = [];\n\n  var requireNormals = defined(globe._material) && (globe._material.shaderSource.match(/slope/) || globe._material.shaderSource.match(\"normalEC\"));\n\n  var fragmentSources = [GroundAtmosphere];\n\n  if (defined(globe._material) && (!requireNormals || globe._terrainProvider.requestVertexNormals)) {\n    fragmentSources.push(globe._material.shaderSource);\n    defines.push(\"APPLY_MATERIAL\");\n    globe._surface._tileProvider.uniformMap = globe._material._uniforms;\n  } else {\n    globe._surface._tileProvider.uniformMap = undefined;\n  }\n\n  fragmentSources.push(GlobeFS);\n  globe._surfaceShaderSet.baseVertexShaderSource = new ShaderSource({\n    sources: [GroundAtmosphere, GlobeVS],\n    defines: defines\n  });\n  globe._surfaceShaderSet.baseFragmentShaderSource = new ShaderSource({\n    sources: fragmentSources,\n    defines: defines\n  });\n  globe._surfaceShaderSet.material = globe._material;\n}\n\nfunction createComparePickTileFunction(rayOrigin) {\n  return function (a, b) {\n    var aDist = BoundingSphere.distanceSquaredTo(a.pickBoundingSphere, rayOrigin);\n    var bDist = BoundingSphere.distanceSquaredTo(b.pickBoundingSphere, rayOrigin);\n    return aDist - bDist;\n  };\n}\n\nvar scratchArray = [];\nvar scratchSphereIntersectionResult = {\n  start: 0.0,\n  stop: 0.0\n};\n/**\n * Find an intersection between a ray and the globe surface that was rendered. The ray must be given in world coordinates.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {Scene} scene The scene.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3|undefined} The intersection or <code>undefined</code> if none was found.  The returned position is in projected coordinates for 2D and Columbus View.\n *\n * @private\n */\n\nGlobe.prototype.pickWorldCoordinates = function (ray, scene, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required\");\n  }\n\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required\");\n  } //>>includeEnd('debug');\n\n\n  var mode = scene.mode;\n  var projection = scene.mapProjection;\n  var sphereIntersections = scratchArray;\n  sphereIntersections.length = 0;\n  var tilesToRender = this._surface._tilesToRender;\n  var length = tilesToRender.length;\n  var tile;\n  var i;\n\n  for (i = 0; i < length; ++i) {\n    tile = tilesToRender[i];\n    var surfaceTile = tile.data;\n\n    if (!defined(surfaceTile)) {\n      continue;\n    }\n\n    var boundingVolume = surfaceTile.pickBoundingSphere;\n\n    if (mode !== SceneMode.SCENE3D) {\n      surfaceTile.pickBoundingSphere = boundingVolume = BoundingSphere.fromRectangleWithHeights2D(tile.rectangle, projection, surfaceTile.tileBoundingRegion.minimumHeight, surfaceTile.tileBoundingRegion.maximumHeight, boundingVolume);\n      Cartesian3.fromElements(boundingVolume.center.z, boundingVolume.center.x, boundingVolume.center.y, boundingVolume.center);\n    } else if (defined(surfaceTile.renderedMesh)) {\n      BoundingSphere.clone(surfaceTile.renderedMesh.boundingSphere3D, boundingVolume);\n    } else {\n      // So wait how did we render this thing then? It shouldn't be possible to get here.\n      continue;\n    }\n\n    var boundingSphereIntersection = IntersectionTests.raySphere(ray, boundingVolume, scratchSphereIntersectionResult);\n\n    if (defined(boundingSphereIntersection)) {\n      sphereIntersections.push(surfaceTile);\n    }\n  }\n\n  sphereIntersections.sort(createComparePickTileFunction(ray.origin));\n  var intersection;\n  length = sphereIntersections.length;\n\n  for (i = 0; i < length; ++i) {\n    intersection = sphereIntersections[i].pick(ray, scene.mode, scene.mapProjection, true, result);\n\n    if (defined(intersection)) {\n      break;\n    }\n  }\n\n  return intersection;\n};\n\nvar cartoScratch = new Cartographic();\n/**\n * Find an intersection between a ray and the globe surface that was rendered. The ray must be given in world coordinates.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {Scene} scene The scene.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3|undefined} The intersection or <code>undefined</code> if none was found.\n *\n * @example\n * // find intersection of ray through a pixel and the globe\n * var ray = viewer.camera.getPickRay(windowCoordinates);\n * var intersection = globe.pick(ray, scene);\n */\n\nGlobe.prototype.pick = function (ray, scene, result) {\n  result = this.pickWorldCoordinates(ray, scene, result);\n\n  if (defined(result) && scene.mode !== SceneMode.SCENE3D) {\n    result = Cartesian3.fromElements(result.y, result.z, result.x, result);\n    var carto = scene.mapProjection.unproject(result, cartoScratch);\n    result = scene.globe.ellipsoid.cartographicToCartesian(carto, result);\n  }\n\n  return result;\n};\n\nvar scratchGetHeightCartesian = new Cartesian3();\nvar scratchGetHeightIntersection = new Cartesian3();\nvar scratchGetHeightCartographic = new Cartographic();\nvar scratchGetHeightRay = new Ray();\n\nfunction tileIfContainsCartographic(tile, cartographic) {\n  return defined(tile) && Rectangle.contains(tile.rectangle, cartographic) ? tile : undefined;\n}\n/**\n * Get the height of the surface at a given cartographic.\n *\n * @param {Cartographic} cartographic The cartographic for which to find the height.\n * @returns {Number|undefined} The height of the cartographic or undefined if it could not be found.\n */\n\n\nGlobe.prototype.getHeight = function (cartographic) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartographic)) {\n    throw new DeveloperError(\"cartographic is required\");\n  } //>>includeEnd('debug');\n\n\n  var levelZeroTiles = this._surface._levelZeroTiles;\n\n  if (!defined(levelZeroTiles)) {\n    return;\n  }\n\n  var tile;\n  var i;\n  var length = levelZeroTiles.length;\n\n  for (i = 0; i < length; ++i) {\n    tile = levelZeroTiles[i];\n\n    if (Rectangle.contains(tile.rectangle, cartographic)) {\n      break;\n    }\n  }\n\n  if (i >= length) {\n    return undefined;\n  }\n\n  var tileWithMesh = tile;\n\n  while (defined(tile)) {\n    tile = tileIfContainsCartographic(tile._southwestChild, cartographic) || tileIfContainsCartographic(tile._southeastChild, cartographic) || tileIfContainsCartographic(tile._northwestChild, cartographic) || tile._northeastChild;\n\n    if (defined(tile) && defined(tile.data) && defined(tile.data.renderedMesh)) {\n      tileWithMesh = tile;\n    }\n  }\n\n  tile = tileWithMesh; // This tile was either rendered or culled.\n  // It is sometimes useful to get a height from a culled tile,\n  // e.g. when we're getting a height in order to place a billboard\n  // on terrain, and the camera is looking at that same billboard.\n  // The culled tile must have a valid mesh, though.\n\n  if (!defined(tile) || !defined(tile.data) || !defined(tile.data.renderedMesh)) {\n    // Tile was not rendered (culled).\n    return undefined;\n  }\n\n  var ellipsoid = this._surface._tileProvider.tilingScheme.ellipsoid; //cartesian has to be on the ellipsoid surface for `ellipsoid.geodeticSurfaceNormal`\n\n  var cartesian = Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, 0.0, ellipsoid, scratchGetHeightCartesian);\n  var ray = scratchGetHeightRay;\n  var surfaceNormal = ellipsoid.geodeticSurfaceNormal(cartesian, ray.direction); // Try to find the intersection point between the surface normal and z-axis.\n  // minimum height (-11500.0) for the terrain set, need to get this information from the terrain provider\n\n  var rayOrigin = ellipsoid.getSurfaceNormalIntersectionWithZAxis(cartesian, 11500.0, ray.origin); // Theoretically, not with Earth datums, the intersection point can be outside the ellipsoid\n\n  if (!defined(rayOrigin)) {\n    // intersection point is outside the ellipsoid, try other value\n    // minimum height (-11500.0) for the terrain set, need to get this information from the terrain provider\n    var minimumHeight;\n\n    if (defined(tile.data.tileBoundingRegion)) {\n      minimumHeight = tile.data.tileBoundingRegion.minimumHeight;\n    }\n\n    var magnitude = Math.min(defaultValue(minimumHeight, 0.0), -11500.0); // multiply by the *positive* value of the magnitude\n\n    var vectorToMinimumPoint = Cartesian3.multiplyByScalar(surfaceNormal, Math.abs(magnitude) + 1, scratchGetHeightIntersection);\n    Cartesian3.subtract(cartesian, vectorToMinimumPoint, ray.origin);\n  }\n\n  var intersection = tile.data.pick(ray, undefined, undefined, false, scratchGetHeightIntersection);\n\n  if (!defined(intersection)) {\n    return undefined;\n  }\n\n  return ellipsoid.cartesianToCartographic(intersection, scratchGetHeightCartographic).height;\n};\n/**\n * @private\n */\n\n\nGlobe.prototype.update = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  if (frameState.passes.render) {\n    this._surface.update(frameState);\n  }\n};\n/**\n * @private\n */\n\n\nGlobe.prototype.beginFrame = function (frameState) {\n  var surface = this._surface;\n  var tileProvider = surface.tileProvider;\n  var terrainProvider = this.terrainProvider;\n  var hasWaterMask = this.showWaterEffect && terrainProvider.ready && terrainProvider.hasWaterMask;\n\n  if (hasWaterMask && this._oceanNormalMapResourceDirty) {\n    // url changed, load new normal map asynchronously\n    this._oceanNormalMapResourceDirty = false;\n    var oceanNormalMapResource = this._oceanNormalMapResource;\n    var oceanNormalMapUrl = oceanNormalMapResource.url;\n\n    if (defined(oceanNormalMapUrl)) {\n      var that = this;\n      when(oceanNormalMapResource.fetchImage(), function (image) {\n        if (oceanNormalMapUrl !== that._oceanNormalMapResource.url) {\n          // url changed while we were loading\n          return;\n        }\n\n        that._oceanNormalMap = that._oceanNormalMap && that._oceanNormalMap.destroy();\n        that._oceanNormalMap = new Texture({\n          context: frameState.context,\n          source: image\n        });\n      });\n    } else {\n      this._oceanNormalMap = this._oceanNormalMap && this._oceanNormalMap.destroy();\n    }\n  }\n\n  var pass = frameState.passes;\n  var mode = frameState.mode;\n\n  if (pass.render) {\n    if (this.showGroundAtmosphere) {\n      this._zoomedOutOceanSpecularIntensity = 0.4;\n    } else {\n      this._zoomedOutOceanSpecularIntensity = 0.5;\n    }\n\n    surface.maximumScreenSpaceError = this.maximumScreenSpaceError;\n    surface.tileCacheSize = this.tileCacheSize;\n    surface.loadingDescendantLimit = this.loadingDescendantLimit;\n    surface.preloadAncestors = this.preloadAncestors;\n    surface.preloadSiblings = this.preloadSiblings;\n    tileProvider.terrainProvider = this.terrainProvider;\n    tileProvider.lightingFadeOutDistance = this.lightingFadeOutDistance;\n    tileProvider.lightingFadeInDistance = this.lightingFadeInDistance;\n    tileProvider.nightFadeOutDistance = this.nightFadeOutDistance;\n    tileProvider.nightFadeInDistance = this.nightFadeInDistance;\n    tileProvider.zoomedOutOceanSpecularIntensity = mode === SceneMode.SCENE3D ? this._zoomedOutOceanSpecularIntensity : 0.0;\n    tileProvider.hasWaterMask = hasWaterMask;\n    tileProvider.oceanNormalMap = this._oceanNormalMap;\n    tileProvider.enableLighting = this.enableLighting;\n    tileProvider.dynamicAtmosphereLighting = this.dynamicAtmosphereLighting;\n    tileProvider.dynamicAtmosphereLightingFromSun = this.dynamicAtmosphereLightingFromSun;\n    tileProvider.showGroundAtmosphere = this.showGroundAtmosphere;\n    tileProvider.shadows = this.shadows;\n    tileProvider.hueShift = this.atmosphereHueShift;\n    tileProvider.saturationShift = this.atmosphereSaturationShift;\n    tileProvider.brightnessShift = this.atmosphereBrightnessShift;\n    tileProvider.fillHighlightColor = this.fillHighlightColor;\n    tileProvider.showSkirts = this.showSkirts;\n    tileProvider.backFaceCulling = this.backFaceCulling;\n    surface.beginFrame(frameState);\n  }\n};\n/**\n * @private\n */\n\n\nGlobe.prototype.render = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  if (defined(this._material)) {\n    this._material.update(frameState.context);\n  }\n\n  this._surface.render(frameState);\n};\n/**\n * @private\n */\n\n\nGlobe.prototype.endFrame = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  if (frameState.passes.render) {\n    this._surface.endFrame(frameState);\n  }\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see Globe#destroy\n */\n\n\nGlobe.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * globe = globe && globe.destroy();\n *\n * @see Globe#isDestroyed\n */\n\n\nGlobe.prototype.destroy = function () {\n  this._surfaceShaderSet = this._surfaceShaderSet && this._surfaceShaderSet.destroy();\n  this._surface = this._surface && this._surface.destroy();\n  this._oceanNormalMap = this._oceanNormalMap && this._oceanNormalMap.destroy();\n  return destroyObject(this);\n};\n\nexport default Globe;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/Globe.js"],"names":["BoundingSphere","buildModuleUrl","Cartesian3","Cartographic","defaultValue","defined","destroyObject","DeveloperError","Ellipsoid","EllipsoidTerrainProvider","Event","IntersectionTests","Ray","Rectangle","Resource","ShaderSource","Texture","GlobeFS","GlobeVS","GroundAtmosphere","when","GlobeSurfaceShaderSet","GlobeSurfaceTileProvider","ImageryLayerCollection","QuadtreePrimitive","SceneMode","ShadowMode","Globe","ellipsoid","WGS84","terrainProvider","imageryLayerCollection","_ellipsoid","_imageryLayerCollection","_surfaceShaderSet","_material","undefined","_surface","tileProvider","imageryLayers","surfaceShaderSet","_terrainProvider","_terrainProviderChanged","makeShadersDirty","show","_oceanNormalMapResourceDirty","_oceanNormalMapResource","url","maximumScreenSpaceError","tileCacheSize","loadingDescendantLimit","preloadAncestors","preloadSiblings","fillHighlightColor","enableLighting","dynamicAtmosphereLighting","dynamicAtmosphereLightingFromSun","showGroundAtmosphere","lightingFadeOutDistance","lightingFadeInDistance","nightFadeOutDistance","nightFadeInDistance","showWaterEffect","depthTestAgainstTerrain","shadows","RECEIVE_ONLY","atmosphereHueShift","atmosphereSaturationShift","atmosphereBrightnessShift","showSkirts","backFaceCulling","_oceanNormalMap","_zoomedOutOceanSpecularIntensity","Object","defineProperties","prototype","get","imageryLayersUpdatedEvent","tilesLoaded","ready","_tileLoadQueueHigh","length","_tileLoadQueueMedium","_tileLoadQueueLow","baseColor","set","value","clippingPlanes","cartographicLimitRectangle","clone","MAX_VALUE","oceanNormalMapUrl","raiseEvent","terrainProviderChanged","tileLoadProgressEvent","material","globe","defines","requireNormals","shaderSource","match","fragmentSources","requestVertexNormals","push","_tileProvider","uniformMap","_uniforms","baseVertexShaderSource","sources","baseFragmentShaderSource","createComparePickTileFunction","rayOrigin","a","b","aDist","distanceSquaredTo","pickBoundingSphere","bDist","scratchArray","scratchSphereIntersectionResult","start","stop","pickWorldCoordinates","ray","scene","result","mode","projection","mapProjection","sphereIntersections","tilesToRender","_tilesToRender","tile","i","surfaceTile","data","boundingVolume","SCENE3D","fromRectangleWithHeights2D","rectangle","tileBoundingRegion","minimumHeight","maximumHeight","fromElements","center","z","x","y","renderedMesh","boundingSphere3D","boundingSphereIntersection","raySphere","sort","origin","intersection","pick","cartoScratch","carto","unproject","cartographicToCartesian","scratchGetHeightCartesian","scratchGetHeightIntersection","scratchGetHeightCartographic","scratchGetHeightRay","tileIfContainsCartographic","cartographic","contains","getHeight","levelZeroTiles","_levelZeroTiles","tileWithMesh","_southwestChild","_southeastChild","_northwestChild","_northeastChild","tilingScheme","cartesian","fromRadians","longitude","latitude","surfaceNormal","geodeticSurfaceNormal","direction","getSurfaceNormalIntersectionWithZAxis","magnitude","Math","min","vectorToMinimumPoint","multiplyByScalar","abs","subtract","cartesianToCartographic","height","update","frameState","passes","render","beginFrame","surface","hasWaterMask","oceanNormalMapResource","that","fetchImage","image","destroy","context","source","pass","zoomedOutOceanSpecularIntensity","oceanNormalMap","hueShift","saturationShift","brightnessShift","endFrame","isDestroyed"],"mappings":"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","sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport buildModuleUrl from \"../Core/buildModuleUrl.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EllipsoidTerrainProvider from \"../Core/EllipsoidTerrainProvider.js\";\nimport Event from \"../Core/Event.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Resource from \"../Core/Resource.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport GlobeFS from \"../Shaders/GlobeFS.js\";\nimport GlobeVS from \"../Shaders/GlobeVS.js\";\nimport GroundAtmosphere from \"../Shaders/GroundAtmosphere.js\";\nimport when from \"../ThirdParty/when.js\";\nimport GlobeSurfaceShaderSet from \"./GlobeSurfaceShaderSet.js\";\nimport GlobeSurfaceTileProvider from \"./GlobeSurfaceTileProvider.js\";\nimport ImageryLayerCollection from \"./ImageryLayerCollection.js\";\nimport QuadtreePrimitive from \"./QuadtreePrimitive.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\n\n/**\n * The globe rendered in the scene, including its terrain ({@link Globe#terrainProvider})\n * and imagery layers ({@link Globe#imageryLayers}).  Access the globe using {@link Scene#globe}.\n *\n * @alias Globe\n * @constructor\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] Determines the size and shape of the\n * globe.\n */\nfunction Globe(ellipsoid) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  var terrainProvider = new EllipsoidTerrainProvider({\n    ellipsoid: ellipsoid,\n  });\n  var imageryLayerCollection = new ImageryLayerCollection();\n\n  this._ellipsoid = ellipsoid;\n  this._imageryLayerCollection = imageryLayerCollection;\n\n  this._surfaceShaderSet = new GlobeSurfaceShaderSet();\n  this._material = undefined;\n\n  this._surface = new QuadtreePrimitive({\n    tileProvider: new GlobeSurfaceTileProvider({\n      terrainProvider: terrainProvider,\n      imageryLayers: imageryLayerCollection,\n      surfaceShaderSet: this._surfaceShaderSet,\n    }),\n  });\n\n  this._terrainProvider = terrainProvider;\n  this._terrainProviderChanged = new Event();\n\n  makeShadersDirty(this);\n\n  /**\n   * Determines if the globe will be shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.show = true;\n\n  this._oceanNormalMapResourceDirty = true;\n  this._oceanNormalMapResource = new Resource({\n    url: buildModuleUrl(\"Assets/Textures/waterNormalsSmall.jpg\"),\n  });\n\n  /**\n   * The maximum screen-space error used to drive level-of-detail refinement.  Higher\n   * values will provide better performance but lower visual quality.\n   *\n   * @type {Number}\n   * @default 2\n   */\n  this.maximumScreenSpaceError = 2;\n\n  /**\n   * The size of the terrain tile cache, expressed as a number of tiles.  Any additional\n   * tiles beyond this number will be freed, as long as they aren't needed for rendering\n   * this frame.  A larger number will consume more memory but will show detail faster\n   * when, for example, zooming out and then back in.\n   *\n   * @type {Number}\n   * @default 100\n   */\n  this.tileCacheSize = 100;\n\n  /**\n   * Gets or sets the number of loading descendant tiles that is considered \"too many\".\n   * If a tile has too many loading descendants, that tile will be loaded and rendered before any of\n   * its descendants are loaded and rendered. This means more feedback for the user that something\n   * is happening at the cost of a longer overall load time. Setting this to 0 will cause each\n   * tile level to be loaded successively, significantly increasing load time. Setting it to a large\n   * number (e.g. 1000) will minimize the number of tiles that are loaded but tend to make\n   * detail appear all at once after a long wait.\n   * @type {Number}\n   * @default 20\n   */\n  this.loadingDescendantLimit = 20;\n\n  /**\n   * Gets or sets a value indicating whether the ancestors of rendered tiles should be preloaded.\n   * Setting this to true optimizes the zoom-out experience and provides more detail in\n   * newly-exposed areas when panning. The down side is that it requires loading more tiles.\n   * @type {Boolean}\n   * @default true\n   */\n  this.preloadAncestors = true;\n\n  /**\n   * Gets or sets a value indicating whether the siblings of rendered tiles should be preloaded.\n   * Setting this to true causes tiles with the same parent as a rendered tile to be loaded, even\n   * if they are culled. Setting this to true may provide a better panning experience at the\n   * cost of loading more tiles.\n   * @type {Boolean}\n   * @default false\n   */\n  this.preloadSiblings = false;\n\n  /**\n   * The color to use to highlight terrain fill tiles. If undefined, fill tiles are not\n   * highlighted at all. The alpha value is used to alpha blend with the tile's\n   * actual color. Because terrain fill tiles do not represent the actual terrain surface,\n   * it may be useful in some applications to indicate visually that they are not to be trusted.\n   * @type {Color}\n   * @default undefined\n   */\n  this.fillHighlightColor = undefined;\n\n  /**\n   * Enable lighting the globe with the scene's light source.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  this.enableLighting = false;\n\n  /**\n   * Enable dynamic lighting effects on atmosphere and fog. This only takes effect\n   * when <code>enableLighting</code> is <code>true</code>.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.dynamicAtmosphereLighting = true;\n\n  /**\n   * Whether dynamic atmosphere lighting uses the sun direction instead of the scene's\n   * light direction. This only takes effect when <code>enableLighting</code> and\n   * <code>dynamicAtmosphereLighting</code> are <code>true</code>.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  this.dynamicAtmosphereLightingFromSun = false;\n\n  /**\n   * Enable the ground atmosphere, which is drawn over the globe when viewed from a distance between <code>lightingFadeInDistance</code> and <code>lightingFadeOutDistance</code>.\n   *\n   * @demo {@link https://sandcastle.cesium.com/index.html?src=Ground%20Atmosphere.html|Ground atmosphere demo in Sandcastle}\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.showGroundAtmosphere = true;\n\n  /**\n   * The distance where everything becomes lit. This only takes effect\n   * when <code>enableLighting</code> or <code>showGroundAtmosphere</code> is <code>true</code>.\n   *\n   * @type {Number}\n   * @default 10000000.0\n   */\n  this.lightingFadeOutDistance = 1.0e7;\n\n  /**\n   * The distance where lighting resumes. This only takes effect\n   * when <code>enableLighting</code> or <code>showGroundAtmosphere</code> is <code>true</code>.\n   *\n   * @type {Number}\n   * @default 20000000.0\n   */\n  this.lightingFadeInDistance = 2.0e7;\n\n  /**\n   * The distance where the darkness of night from the ground atmosphere fades out to a lit ground atmosphere.\n   * This only takes effect when <code>showGroundAtmosphere</code>, <code>enableLighting</code>, and\n   * <code>dynamicAtmosphereLighting</code> are <code>true</code>.\n   *\n   * @type {Number}\n   * @default 10000000.0\n   */\n  this.nightFadeOutDistance = 1.0e7;\n\n  /**\n   * The distance where the darkness of night from the ground atmosphere fades in to an unlit ground atmosphere.\n   * This only takes effect when <code>showGroundAtmosphere</code>, <code>enableLighting</code>, and\n   * <code>dynamicAtmosphereLighting</code> are <code>true</code>.\n   *\n   * @type {Number}\n   * @default 50000000.0\n   */\n  this.nightFadeInDistance = 5.0e7;\n\n  /**\n   * True if an animated wave effect should be shown in areas of the globe\n   * covered by water; otherwise, false.  This property is ignored if the\n   * <code>terrainProvider</code> does not provide a water mask.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.showWaterEffect = true;\n\n  /**\n   * True if primitives such as billboards, polylines, labels, etc. should be depth-tested\n   * against the terrain surface, or false if such primitives should always be drawn on top\n   * of terrain unless they're on the opposite side of the globe.  The disadvantage of depth\n   * testing primitives against terrain is that slight numerical noise or terrain level-of-detail\n   * switched can sometimes make a primitive that should be on the surface disappear underneath it.\n   *\n   * @type {Boolean}\n   * @default false\n   *\n   */\n  this.depthTestAgainstTerrain = false;\n\n  /**\n   * Determines whether the globe casts or receives shadows from light sources. Setting the globe\n   * to cast shadows may impact performance since the terrain is rendered again from the light's perspective.\n   * Currently only terrain that is in view casts shadows. By default the globe does not cast shadows.\n   *\n   * @type {ShadowMode}\n   * @default ShadowMode.RECEIVE_ONLY\n   */\n  this.shadows = ShadowMode.RECEIVE_ONLY;\n\n  /**\n   * The hue shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A hue shift of 1.0 indicates a complete rotation of the hues available.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.atmosphereHueShift = 0.0;\n\n  /**\n   * The saturation shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A saturation shift of -1.0 is monochrome.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.atmosphereSaturationShift = 0.0;\n\n  /**\n   * The brightness shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A brightness shift of -1.0 is complete darkness, which will let space show through.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.atmosphereBrightnessShift = 0.0;\n\n  /**\n   * Whether to show terrain skirts. Terrain skirts are geometry extending downwards from a tile's edges used to hide seams between neighboring tiles.\n   * It may be desirable to hide terrain skirts if terrain is translucent or when viewing terrain from below the surface.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.showSkirts = true;\n\n  /**\n   * Whether to cull back-facing terrain. Set this to false when viewing terrain from below the surface.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.backFaceCulling = true;\n\n  this._oceanNormalMap = undefined;\n  this._zoomedOutOceanSpecularIntensity = undefined;\n}\n\nObject.defineProperties(Globe.prototype, {\n  /**\n   * Gets an ellipsoid describing the shape of this globe.\n   * @memberof Globe.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n  /**\n   * Gets the collection of image layers that will be rendered on this globe.\n   * @memberof Globe.prototype\n   * @type {ImageryLayerCollection}\n   */\n  imageryLayers: {\n    get: function () {\n      return this._imageryLayerCollection;\n    },\n  },\n  /**\n   * Gets an event that's raised when an imagery layer is added, shown, hidden, moved, or removed.\n   *\n   * @memberof Globe.prototype\n   * @type {Event}\n   * @readonly\n   */\n  imageryLayersUpdatedEvent: {\n    get: function () {\n      return this._surface.tileProvider.imageryLayersUpdatedEvent;\n    },\n  },\n  /**\n   * Returns <code>true</code> when the tile load queue is empty, <code>false</code> otherwise.  When the load queue is empty,\n   * all terrain and imagery for the current view have been loaded.\n   * @memberof Globe.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  tilesLoaded: {\n    get: function () {\n      if (!defined(this._surface)) {\n        return true;\n      }\n      return (\n        this._surface.tileProvider.ready &&\n        this._surface._tileLoadQueueHigh.length === 0 &&\n        this._surface._tileLoadQueueMedium.length === 0 &&\n        this._surface._tileLoadQueueLow.length === 0\n      );\n    },\n  },\n  /**\n   * Gets or sets the color of the globe when no imagery is available.\n   * @memberof Globe.prototype\n   * @type {Color}\n   */\n  baseColor: {\n    get: function () {\n      return this._surface.tileProvider.baseColor;\n    },\n    set: function (value) {\n      this._surface.tileProvider.baseColor = value;\n    },\n  },\n  /**\n   * A property specifying a {@link ClippingPlaneCollection} used to selectively disable rendering on the outside of each plane.\n   *\n   * @memberof Globe.prototype\n   * @type {ClippingPlaneCollection}\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._surface.tileProvider.clippingPlanes;\n    },\n    set: function (value) {\n      this._surface.tileProvider.clippingPlanes = value;\n    },\n  },\n  /**\n   * A property specifying a {@link Rectangle} used to limit globe rendering to a cartographic area.\n   * Defaults to the maximum extent of cartographic coordinates.\n   *\n   * @member Globe.prototype\n   * @type {Rectangle}\n   * @default Rectangle.MAX_VALUE\n   */\n  cartographicLimitRectangle: {\n    get: function () {\n      return this._surface.tileProvider.cartographicLimitRectangle;\n    },\n    set: function (value) {\n      if (!defined(value)) {\n        value = Rectangle.clone(Rectangle.MAX_VALUE);\n      }\n      this._surface.tileProvider.cartographicLimitRectangle = value;\n    },\n  },\n  /**\n   * The normal map to use for rendering waves in the ocean.  Setting this property will\n   * only have an effect if the configured terrain provider includes a water mask.\n   * @memberof Globe.prototype\n   * @type {String}\n   * @default buildModuleUrl('Assets/Textures/waterNormalsSmall.jpg')\n   */\n  oceanNormalMapUrl: {\n    get: function () {\n      return this._oceanNormalMapResource.url;\n    },\n    set: function (value) {\n      this._oceanNormalMapResource.url = value;\n      this._oceanNormalMapResourceDirty = true;\n    },\n  },\n  /**\n   * The terrain provider providing surface geometry for this globe.\n   * @type {TerrainProvider}\n   *\n   * @memberof Globe.prototype\n   * @type {TerrainProvider}\n   *\n   */\n  terrainProvider: {\n    get: function () {\n      return this._terrainProvider;\n    },\n    set: function (value) {\n      if (value !== this._terrainProvider) {\n        this._terrainProvider = value;\n        this._terrainProviderChanged.raiseEvent(value);\n        if (defined(this._material)) {\n          makeShadersDirty(this);\n        }\n      }\n    },\n  },\n  /**\n   * Gets an event that's raised when the terrain provider is changed\n   *\n   * @memberof Globe.prototype\n   * @type {Event}\n   * @readonly\n   */\n  terrainProviderChanged: {\n    get: function () {\n      return this._terrainProviderChanged;\n    },\n  },\n  /**\n   * Gets an event that's raised when the length of the tile load queue has changed since the last render frame.  When the load queue is empty,\n   * all terrain and imagery for the current view have been loaded.  The event passes the new length of the tile load queue.\n   *\n   * @memberof Globe.prototype\n   * @type {Event}\n   */\n  tileLoadProgressEvent: {\n    get: function () {\n      return this._surface.tileLoadProgressEvent;\n    },\n  },\n\n  /**\n   * Gets or sets the material appearance of the Globe.  This can be one of several built-in {@link Material} objects or a custom material, scripted with\n   * {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}.\n   * @memberof Globe.prototype\n   * @type {Material}\n   */\n  material: {\n    get: function () {\n      return this._material;\n    },\n    set: function (material) {\n      if (this._material !== material) {\n        this._material = material;\n        makeShadersDirty(this);\n      }\n    },\n  },\n});\n\nfunction makeShadersDirty(globe) {\n  var defines = [];\n\n  var requireNormals =\n    defined(globe._material) &&\n    (globe._material.shaderSource.match(/slope/) ||\n      globe._material.shaderSource.match(\"normalEC\"));\n\n  var fragmentSources = [GroundAtmosphere];\n  if (\n    defined(globe._material) &&\n    (!requireNormals || globe._terrainProvider.requestVertexNormals)\n  ) {\n    fragmentSources.push(globe._material.shaderSource);\n    defines.push(\"APPLY_MATERIAL\");\n    globe._surface._tileProvider.uniformMap = globe._material._uniforms;\n  } else {\n    globe._surface._tileProvider.uniformMap = undefined;\n  }\n  fragmentSources.push(GlobeFS);\n\n  globe._surfaceShaderSet.baseVertexShaderSource = new ShaderSource({\n    sources: [GroundAtmosphere, GlobeVS],\n    defines: defines,\n  });\n\n  globe._surfaceShaderSet.baseFragmentShaderSource = new ShaderSource({\n    sources: fragmentSources,\n    defines: defines,\n  });\n  globe._surfaceShaderSet.material = globe._material;\n}\n\nfunction createComparePickTileFunction(rayOrigin) {\n  return function (a, b) {\n    var aDist = BoundingSphere.distanceSquaredTo(\n      a.pickBoundingSphere,\n      rayOrigin\n    );\n    var bDist = BoundingSphere.distanceSquaredTo(\n      b.pickBoundingSphere,\n      rayOrigin\n    );\n\n    return aDist - bDist;\n  };\n}\n\nvar scratchArray = [];\nvar scratchSphereIntersectionResult = {\n  start: 0.0,\n  stop: 0.0,\n};\n\n/**\n * Find an intersection between a ray and the globe surface that was rendered. The ray must be given in world coordinates.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {Scene} scene The scene.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3|undefined} The intersection or <code>undefined</code> if none was found.  The returned position is in projected coordinates for 2D and Columbus View.\n *\n * @private\n */\nGlobe.prototype.pickWorldCoordinates = function (ray, scene, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required\");\n  }\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required\");\n  }\n  //>>includeEnd('debug');\n\n  var mode = scene.mode;\n  var projection = scene.mapProjection;\n\n  var sphereIntersections = scratchArray;\n  sphereIntersections.length = 0;\n\n  var tilesToRender = this._surface._tilesToRender;\n  var length = tilesToRender.length;\n\n  var tile;\n  var i;\n\n  for (i = 0; i < length; ++i) {\n    tile = tilesToRender[i];\n    var surfaceTile = tile.data;\n\n    if (!defined(surfaceTile)) {\n      continue;\n    }\n\n    var boundingVolume = surfaceTile.pickBoundingSphere;\n    if (mode !== SceneMode.SCENE3D) {\n      surfaceTile.pickBoundingSphere = boundingVolume = BoundingSphere.fromRectangleWithHeights2D(\n        tile.rectangle,\n        projection,\n        surfaceTile.tileBoundingRegion.minimumHeight,\n        surfaceTile.tileBoundingRegion.maximumHeight,\n        boundingVolume\n      );\n      Cartesian3.fromElements(\n        boundingVolume.center.z,\n        boundingVolume.center.x,\n        boundingVolume.center.y,\n        boundingVolume.center\n      );\n    } else if (defined(surfaceTile.renderedMesh)) {\n      BoundingSphere.clone(\n        surfaceTile.renderedMesh.boundingSphere3D,\n        boundingVolume\n      );\n    } else {\n      // So wait how did we render this thing then? It shouldn't be possible to get here.\n      continue;\n    }\n\n    var boundingSphereIntersection = IntersectionTests.raySphere(\n      ray,\n      boundingVolume,\n      scratchSphereIntersectionResult\n    );\n    if (defined(boundingSphereIntersection)) {\n      sphereIntersections.push(surfaceTile);\n    }\n  }\n\n  sphereIntersections.sort(createComparePickTileFunction(ray.origin));\n\n  var intersection;\n  length = sphereIntersections.length;\n  for (i = 0; i < length; ++i) {\n    intersection = sphereIntersections[i].pick(\n      ray,\n      scene.mode,\n      scene.mapProjection,\n      true,\n      result\n    );\n    if (defined(intersection)) {\n      break;\n    }\n  }\n\n  return intersection;\n};\n\nvar cartoScratch = new Cartographic();\n/**\n * Find an intersection between a ray and the globe surface that was rendered. The ray must be given in world coordinates.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {Scene} scene The scene.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3|undefined} The intersection or <code>undefined</code> if none was found.\n *\n * @example\n * // find intersection of ray through a pixel and the globe\n * var ray = viewer.camera.getPickRay(windowCoordinates);\n * var intersection = globe.pick(ray, scene);\n */\nGlobe.prototype.pick = function (ray, scene, result) {\n  result = this.pickWorldCoordinates(ray, scene, result);\n  if (defined(result) && scene.mode !== SceneMode.SCENE3D) {\n    result = Cartesian3.fromElements(result.y, result.z, result.x, result);\n    var carto = scene.mapProjection.unproject(result, cartoScratch);\n    result = scene.globe.ellipsoid.cartographicToCartesian(carto, result);\n  }\n\n  return result;\n};\n\nvar scratchGetHeightCartesian = new Cartesian3();\nvar scratchGetHeightIntersection = new Cartesian3();\nvar scratchGetHeightCartographic = new Cartographic();\nvar scratchGetHeightRay = new Ray();\n\nfunction tileIfContainsCartographic(tile, cartographic) {\n  return defined(tile) && Rectangle.contains(tile.rectangle, cartographic)\n    ? tile\n    : undefined;\n}\n\n/**\n * Get the height of the surface at a given cartographic.\n *\n * @param {Cartographic} cartographic The cartographic for which to find the height.\n * @returns {Number|undefined} The height of the cartographic or undefined if it could not be found.\n */\nGlobe.prototype.getHeight = function (cartographic) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartographic)) {\n    throw new DeveloperError(\"cartographic is required\");\n  }\n  //>>includeEnd('debug');\n\n  var levelZeroTiles = this._surface._levelZeroTiles;\n  if (!defined(levelZeroTiles)) {\n    return;\n  }\n\n  var tile;\n  var i;\n\n  var length = levelZeroTiles.length;\n  for (i = 0; i < length; ++i) {\n    tile = levelZeroTiles[i];\n    if (Rectangle.contains(tile.rectangle, cartographic)) {\n      break;\n    }\n  }\n\n  if (i >= length) {\n    return undefined;\n  }\n\n  var tileWithMesh = tile;\n\n  while (defined(tile)) {\n    tile =\n      tileIfContainsCartographic(tile._southwestChild, cartographic) ||\n      tileIfContainsCartographic(tile._southeastChild, cartographic) ||\n      tileIfContainsCartographic(tile._northwestChild, cartographic) ||\n      tile._northeastChild;\n\n    if (\n      defined(tile) &&\n      defined(tile.data) &&\n      defined(tile.data.renderedMesh)\n    ) {\n      tileWithMesh = tile;\n    }\n  }\n\n  tile = tileWithMesh;\n\n  // This tile was either rendered or culled.\n  // It is sometimes useful to get a height from a culled tile,\n  // e.g. when we're getting a height in order to place a billboard\n  // on terrain, and the camera is looking at that same billboard.\n  // The culled tile must have a valid mesh, though.\n  if (\n    !defined(tile) ||\n    !defined(tile.data) ||\n    !defined(tile.data.renderedMesh)\n  ) {\n    // Tile was not rendered (culled).\n    return undefined;\n  }\n\n  var ellipsoid = this._surface._tileProvider.tilingScheme.ellipsoid;\n\n  //cartesian has to be on the ellipsoid surface for `ellipsoid.geodeticSurfaceNormal`\n  var cartesian = Cartesian3.fromRadians(\n    cartographic.longitude,\n    cartographic.latitude,\n    0.0,\n    ellipsoid,\n    scratchGetHeightCartesian\n  );\n\n  var ray = scratchGetHeightRay;\n  var surfaceNormal = ellipsoid.geodeticSurfaceNormal(cartesian, ray.direction);\n\n  // Try to find the intersection point between the surface normal and z-axis.\n  // minimum height (-11500.0) for the terrain set, need to get this information from the terrain provider\n  var rayOrigin = ellipsoid.getSurfaceNormalIntersectionWithZAxis(\n    cartesian,\n    11500.0,\n    ray.origin\n  );\n\n  // Theoretically, not with Earth datums, the intersection point can be outside the ellipsoid\n  if (!defined(rayOrigin)) {\n    // intersection point is outside the ellipsoid, try other value\n    // minimum height (-11500.0) for the terrain set, need to get this information from the terrain provider\n    var minimumHeight;\n    if (defined(tile.data.tileBoundingRegion)) {\n      minimumHeight = tile.data.tileBoundingRegion.minimumHeight;\n    }\n    var magnitude = Math.min(defaultValue(minimumHeight, 0.0), -11500.0);\n\n    // multiply by the *positive* value of the magnitude\n    var vectorToMinimumPoint = Cartesian3.multiplyByScalar(\n      surfaceNormal,\n      Math.abs(magnitude) + 1,\n      scratchGetHeightIntersection\n    );\n    Cartesian3.subtract(cartesian, vectorToMinimumPoint, ray.origin);\n  }\n\n  var intersection = tile.data.pick(\n    ray,\n    undefined,\n    undefined,\n    false,\n    scratchGetHeightIntersection\n  );\n  if (!defined(intersection)) {\n    return undefined;\n  }\n\n  return ellipsoid.cartesianToCartographic(\n    intersection,\n    scratchGetHeightCartographic\n  ).height;\n};\n\n/**\n * @private\n */\nGlobe.prototype.update = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  if (frameState.passes.render) {\n    this._surface.update(frameState);\n  }\n};\n\n/**\n * @private\n */\nGlobe.prototype.beginFrame = function (frameState) {\n  var surface = this._surface;\n  var tileProvider = surface.tileProvider;\n  var terrainProvider = this.terrainProvider;\n  var hasWaterMask =\n    this.showWaterEffect &&\n    terrainProvider.ready &&\n    terrainProvider.hasWaterMask;\n\n  if (hasWaterMask && this._oceanNormalMapResourceDirty) {\n    // url changed, load new normal map asynchronously\n    this._oceanNormalMapResourceDirty = false;\n    var oceanNormalMapResource = this._oceanNormalMapResource;\n    var oceanNormalMapUrl = oceanNormalMapResource.url;\n    if (defined(oceanNormalMapUrl)) {\n      var that = this;\n      when(oceanNormalMapResource.fetchImage(), function (image) {\n        if (oceanNormalMapUrl !== that._oceanNormalMapResource.url) {\n          // url changed while we were loading\n          return;\n        }\n\n        that._oceanNormalMap =\n          that._oceanNormalMap && that._oceanNormalMap.destroy();\n        that._oceanNormalMap = new Texture({\n          context: frameState.context,\n          source: image,\n        });\n      });\n    } else {\n      this._oceanNormalMap =\n        this._oceanNormalMap && this._oceanNormalMap.destroy();\n    }\n  }\n\n  var pass = frameState.passes;\n  var mode = frameState.mode;\n\n  if (pass.render) {\n    if (this.showGroundAtmosphere) {\n      this._zoomedOutOceanSpecularIntensity = 0.4;\n    } else {\n      this._zoomedOutOceanSpecularIntensity = 0.5;\n    }\n\n    surface.maximumScreenSpaceError = this.maximumScreenSpaceError;\n    surface.tileCacheSize = this.tileCacheSize;\n    surface.loadingDescendantLimit = this.loadingDescendantLimit;\n    surface.preloadAncestors = this.preloadAncestors;\n    surface.preloadSiblings = this.preloadSiblings;\n\n    tileProvider.terrainProvider = this.terrainProvider;\n    tileProvider.lightingFadeOutDistance = this.lightingFadeOutDistance;\n    tileProvider.lightingFadeInDistance = this.lightingFadeInDistance;\n    tileProvider.nightFadeOutDistance = this.nightFadeOutDistance;\n    tileProvider.nightFadeInDistance = this.nightFadeInDistance;\n    tileProvider.zoomedOutOceanSpecularIntensity =\n      mode === SceneMode.SCENE3D ? this._zoomedOutOceanSpecularIntensity : 0.0;\n    tileProvider.hasWaterMask = hasWaterMask;\n    tileProvider.oceanNormalMap = this._oceanNormalMap;\n    tileProvider.enableLighting = this.enableLighting;\n    tileProvider.dynamicAtmosphereLighting = this.dynamicAtmosphereLighting;\n    tileProvider.dynamicAtmosphereLightingFromSun = this.dynamicAtmosphereLightingFromSun;\n    tileProvider.showGroundAtmosphere = this.showGroundAtmosphere;\n    tileProvider.shadows = this.shadows;\n    tileProvider.hueShift = this.atmosphereHueShift;\n    tileProvider.saturationShift = this.atmosphereSaturationShift;\n    tileProvider.brightnessShift = this.atmosphereBrightnessShift;\n    tileProvider.fillHighlightColor = this.fillHighlightColor;\n    tileProvider.showSkirts = this.showSkirts;\n    tileProvider.backFaceCulling = this.backFaceCulling;\n    surface.beginFrame(frameState);\n  }\n};\n\n/**\n * @private\n */\nGlobe.prototype.render = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  if (defined(this._material)) {\n    this._material.update(frameState.context);\n  }\n\n  this._surface.render(frameState);\n};\n\n/**\n * @private\n */\nGlobe.prototype.endFrame = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  if (frameState.passes.render) {\n    this._surface.endFrame(frameState);\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see Globe#destroy\n */\nGlobe.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * globe = globe && globe.destroy();\n *\n * @see Globe#isDestroyed\n */\nGlobe.prototype.destroy = function () {\n  this._surfaceShaderSet =\n    this._surfaceShaderSet && this._surfaceShaderSet.destroy();\n  this._surface = this._surface && this._surface.destroy();\n  this._oceanNormalMap = this._oceanNormalMap && this._oceanNormalMap.destroy();\n  return destroyObject(this);\n};\nexport default Globe;\n"]},"metadata":{},"sourceType":"module"}