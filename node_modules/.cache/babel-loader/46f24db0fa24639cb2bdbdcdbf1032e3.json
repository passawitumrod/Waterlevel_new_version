{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Plane from \"../Core/Plane.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport PolylineCommon from \"../Shaders/PolylineCommon.js\";\nimport PolylineFS from \"../Shaders/PolylineFS.js\";\nimport PolylineVS from \"../Shaders/PolylineVS.js\";\nimport BatchTable from \"./BatchTable.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Material from \"./Material.js\";\nimport Polyline from \"./Polyline.js\";\nimport SceneMode from \"./SceneMode.js\";\nvar SHOW_INDEX = Polyline.SHOW_INDEX;\nvar WIDTH_INDEX = Polyline.WIDTH_INDEX;\nvar POSITION_INDEX = Polyline.POSITION_INDEX;\nvar MATERIAL_INDEX = Polyline.MATERIAL_INDEX; //POSITION_SIZE_INDEX is needed for when the polyline's position array changes size.\n//When it does, we need to recreate the indicesBuffer.\n\nvar POSITION_SIZE_INDEX = Polyline.POSITION_SIZE_INDEX;\nvar DISTANCE_DISPLAY_CONDITION = Polyline.DISTANCE_DISPLAY_CONDITION;\nvar NUMBER_OF_PROPERTIES = Polyline.NUMBER_OF_PROPERTIES;\nvar attributeLocations = {\n  texCoordExpandAndBatchIndex: 0,\n  position3DHigh: 1,\n  position3DLow: 2,\n  position2DHigh: 3,\n  position2DLow: 4,\n  prevPosition3DHigh: 5,\n  prevPosition3DLow: 6,\n  prevPosition2DHigh: 7,\n  prevPosition2DLow: 8,\n  nextPosition3DHigh: 9,\n  nextPosition3DLow: 10,\n  nextPosition2DHigh: 11,\n  nextPosition2DLow: 12\n};\n/**\n * A renderable collection of polylines.\n * <br /><br />\n * <div align=\"center\">\n * <img src=\"Images/Polyline.png\" width=\"400\" height=\"300\" /><br />\n * Example polylines\n * </div>\n * <br /><br />\n * Polylines are added and removed from the collection using {@link PolylineCollection#add}\n * and {@link PolylineCollection#remove}.\n *\n * @alias PolylineCollection\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each polyline from model to world coordinates.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n *\n * @performance For best performance, prefer a few collections, each with many polylines, to\n * many collections with only a few polylines each.  Organize collections so that polylines\n * with the same update frequency are in the same collection, i.e., polylines that do not\n * change should be in one collection; polylines that change every frame should be in another\n * collection; and so on.\n *\n * @see PolylineCollection#add\n * @see PolylineCollection#remove\n * @see Polyline\n * @see LabelCollection\n *\n * @example\n * // Create a polyline collection with two polylines\n * var polylines = new Cesium.PolylineCollection();\n * polylines.add({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -75.10, 39.57,\n *     -77.02, 38.53,\n *     -80.50, 35.14,\n *     -80.12, 25.46]),\n *   width : 2\n * });\n *\n * polylines.add({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -73.10, 37.57,\n *     -75.02, 36.53,\n *     -78.50, 33.14,\n *     -78.12, 23.46]),\n *   width : 4\n * });\n */\n\nfunction PolylineCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  /**\n   * The 4x4 transformation matrix that transforms each polyline in this collection from model to world coordinates.\n   * When this is the identity matrix, the polylines are drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type {Matrix4}\n   * @default {@link Matrix4.IDENTITY}\n   */\n\n  this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));\n  this._modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n\n  this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);\n  this._opaqueRS = undefined;\n  this._translucentRS = undefined;\n  this._colorCommands = [];\n  this._polylinesUpdated = false;\n  this._polylinesRemoved = false;\n  this._createVertexArray = false;\n  this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);\n  this._polylines = [];\n  this._polylineBuckets = {}; // The buffer usage is determined based on the usage of the attribute over time.\n\n  this._positionBufferUsage = {\n    bufferUsage: BufferUsage.STATIC_DRAW,\n    frameCount: 0\n  };\n  this._mode = undefined;\n  this._polylinesToUpdate = [];\n  this._vertexArrays = [];\n  this._positionBuffer = undefined;\n  this._texCoordExpandAndBatchIndexBuffer = undefined;\n  this._batchTable = undefined;\n  this._createBatchTable = false; // Only used by Vector3DTilePoints\n\n  this._useHighlightColor = false;\n  this._highlightColor = Color.clone(Color.WHITE);\n  var that = this;\n  this._uniformMap = {\n    u_highlightColor: function () {\n      return that._highlightColor;\n    }\n  };\n}\n\nObject.defineProperties(PolylineCollection.prototype, {\n  /**\n   * Returns the number of polylines in this collection.  This is commonly used with\n   * {@link PolylineCollection#get} to iterate over all the polylines\n   * in the collection.\n   * @memberof PolylineCollection.prototype\n   * @type {Number}\n   */\n  length: {\n    get: function () {\n      removePolylines(this);\n      return this._polylines.length;\n    }\n  }\n});\n/**\n     * Creates and adds a polyline with the specified initial properties to the collection.\n     * The added polyline is returned so it can be modified or removed from the collection later.\n     *\n     * @param {Object}[options] A template describing the polyline's properties as shown in Example 1.\n     * @returns {Polyline} The polyline that was added to the collection.\n     *\n     * @performance After calling <code>add</code>, {@link PolylineCollection#update} is called and\n     * the collection's vertex buffer is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.\n     * For best performance, add as many polylines as possible before calling <code>update</code>.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     *\n     *\n     * @example\n     * // Example 1:  Add a polyline, specifying all the default values.\n     * var p = polylines.add({\n     *   show : true,\n     *   positions : ellipsoid.cartographicArrayToCartesianArray([\n           Cesium.Cartographic.fromDegrees(-75.10, 39.57),\n           Cesium.Cartographic.fromDegrees(-77.02, 38.53)]),\n     *   width : 1\n     * });\n     *\n     * @see PolylineCollection#remove\n     * @see PolylineCollection#removeAll\n     * @see PolylineCollection#update\n     */\n\nPolylineCollection.prototype.add = function (options) {\n  var p = new Polyline(options, this);\n  p._index = this._polylines.length;\n\n  this._polylines.push(p);\n\n  this._createVertexArray = true;\n  this._createBatchTable = true;\n  return p;\n};\n/**\n * Removes a polyline from the collection.\n *\n * @param {Polyline} polyline The polyline to remove.\n * @returns {Boolean} <code>true</code> if the polyline was removed; <code>false</code> if the polyline was not found in the collection.\n *\n * @performance After calling <code>remove</code>, {@link PolylineCollection#update} is called and\n * the collection's vertex buffer is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.\n * For best performance, remove as many polylines as possible before calling <code>update</code>.\n * If you intend to temporarily hide a polyline, it is usually more efficient to call\n * {@link Polyline#show} instead of removing and re-adding the polyline.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * var p = polylines.add(...);\n * polylines.remove(p);  // Returns true\n *\n * @see PolylineCollection#add\n * @see PolylineCollection#removeAll\n * @see PolylineCollection#update\n * @see Polyline#show\n */\n\n\nPolylineCollection.prototype.remove = function (polyline) {\n  if (this.contains(polyline)) {\n    this._polylinesRemoved = true;\n    this._createVertexArray = true;\n    this._createBatchTable = true;\n\n    if (defined(polyline._bucket)) {\n      var bucket = polyline._bucket;\n      bucket.shaderProgram = bucket.shaderProgram && bucket.shaderProgram.destroy();\n    }\n\n    polyline._destroy();\n\n    return true;\n  }\n\n  return false;\n};\n/**\n * Removes all polylines from the collection.\n *\n * @performance <code>O(n)</code>.  It is more efficient to remove all the polylines\n * from a collection and then add new ones than to create a new collection entirely.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * polylines.add(...);\n * polylines.add(...);\n * polylines.removeAll();\n *\n * @see PolylineCollection#add\n * @see PolylineCollection#remove\n * @see PolylineCollection#update\n */\n\n\nPolylineCollection.prototype.removeAll = function () {\n  releaseShaders(this);\n  destroyPolylines(this);\n  this._polylineBuckets = {};\n  this._polylinesRemoved = false;\n  this._polylines.length = 0;\n  this._polylinesToUpdate.length = 0;\n  this._createVertexArray = true;\n};\n/**\n * Determines if this collection contains the specified polyline.\n *\n * @param {Polyline} polyline The polyline to check for.\n * @returns {Boolean} true if this collection contains the polyline, false otherwise.\n *\n * @see PolylineCollection#get\n */\n\n\nPolylineCollection.prototype.contains = function (polyline) {\n  return defined(polyline) && polyline._polylineCollection === this;\n};\n/**\n * Returns the polyline in the collection at the specified index.  Indices are zero-based\n * and increase as polylines are added.  Removing a polyline shifts all polylines after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link PolylineCollection#length} to iterate over all the polylines\n * in the collection.\n *\n * @param {Number} index The zero-based index of the polyline.\n * @returns {Polyline} The polyline at the specified index.\n *\n * @performance If polylines were removed from the collection and\n * {@link PolylineCollection#update} was not called, an implicit <code>O(n)</code>\n * operation is performed.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * // Toggle the show property of every polyline in the collection\n * var len = polylines.length;\n * for (var i = 0; i < len; ++i) {\n *   var p = polylines.get(i);\n *   p.show = !p.show;\n * }\n *\n * @see PolylineCollection#length\n */\n\n\nPolylineCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  } //>>includeEnd('debug');\n\n\n  removePolylines(this);\n  return this._polylines[index];\n};\n\nfunction createBatchTable(collection, context) {\n  if (defined(collection._batchTable)) {\n    collection._batchTable.destroy();\n  }\n\n  var attributes = [{\n    functionName: \"batchTable_getWidthAndShow\",\n    componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n    componentsPerAttribute: 2\n  }, {\n    functionName: \"batchTable_getPickColor\",\n    componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n    componentsPerAttribute: 4,\n    normalize: true\n  }, {\n    functionName: \"batchTable_getCenterHigh\",\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3\n  }, {\n    functionName: \"batchTable_getCenterLowAndRadius\",\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4\n  }, {\n    functionName: \"batchTable_getDistanceDisplayCondition\",\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 2\n  }];\n  collection._batchTable = new BatchTable(context, attributes, collection._polylines.length);\n}\n\nvar scratchUpdatePolylineEncodedCartesian = new EncodedCartesian3();\nvar scratchUpdatePolylineCartesian4 = new Cartesian4();\nvar scratchNearFarCartesian2 = new Cartesian2();\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {RuntimeError} Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.\n */\n\nPolylineCollection.prototype.update = function (frameState) {\n  removePolylines(this);\n\n  if (this._polylines.length === 0) {\n    return;\n  }\n\n  updateMode(this, frameState);\n  var context = frameState.context;\n  var projection = frameState.mapProjection;\n  var polyline;\n  var properties = this._propertiesChanged;\n\n  if (this._createBatchTable) {\n    if (ContextLimits.maximumVertexTextureImageUnits === 0) {\n      throw new RuntimeError(\"Vertex texture fetch support is required to render polylines. The maximum number of vertex texture image units must be greater than zero.\");\n    }\n\n    createBatchTable(this, context);\n    this._createBatchTable = false;\n  }\n\n  if (this._createVertexArray || computeNewBuffersUsage(this)) {\n    createVertexArrays(this, context, projection);\n  } else if (this._polylinesUpdated) {\n    // Polylines were modified, but no polylines were added or removed.\n    var polylinesToUpdate = this._polylinesToUpdate;\n\n    if (this._mode !== SceneMode.SCENE3D) {\n      var updateLength = polylinesToUpdate.length;\n\n      for (var i = 0; i < updateLength; ++i) {\n        polyline = polylinesToUpdate[i];\n        polyline.update();\n      }\n    } // if a polyline's positions size changes, we need to recreate the vertex arrays and vertex buffers because the indices will be different.\n    // if a polyline's material changes, we need to recreate the VAOs and VBOs because they will be batched differently.\n\n\n    if (properties[POSITION_SIZE_INDEX] || properties[MATERIAL_INDEX]) {\n      createVertexArrays(this, context, projection);\n    } else {\n      var length = polylinesToUpdate.length;\n      var polylineBuckets = this._polylineBuckets;\n\n      for (var ii = 0; ii < length; ++ii) {\n        polyline = polylinesToUpdate[ii];\n        properties = polyline._propertiesChanged;\n        var bucket = polyline._bucket;\n        var index = 0;\n\n        for (var x in polylineBuckets) {\n          if (polylineBuckets.hasOwnProperty(x)) {\n            if (polylineBuckets[x] === bucket) {\n              if (properties[POSITION_INDEX]) {\n                bucket.writeUpdate(index, polyline, this._positionBuffer, projection);\n              }\n\n              break;\n            }\n\n            index += polylineBuckets[x].lengthOfPositions;\n          }\n        }\n\n        if (properties[SHOW_INDEX] || properties[WIDTH_INDEX]) {\n          this._batchTable.setBatchedAttribute(polyline._index, 0, new Cartesian2(polyline._width, polyline._show));\n        }\n\n        if (this._batchTable.attributes.length > 2) {\n          if (properties[POSITION_INDEX] || properties[POSITION_SIZE_INDEX]) {\n            var boundingSphere = frameState.mode === SceneMode.SCENE2D ? polyline._boundingVolume2D : polyline._boundingVolumeWC;\n            var encodedCenter = EncodedCartesian3.fromCartesian(boundingSphere.center, scratchUpdatePolylineEncodedCartesian);\n            var low = Cartesian4.fromElements(encodedCenter.low.x, encodedCenter.low.y, encodedCenter.low.z, boundingSphere.radius, scratchUpdatePolylineCartesian4);\n\n            this._batchTable.setBatchedAttribute(polyline._index, 2, encodedCenter.high);\n\n            this._batchTable.setBatchedAttribute(polyline._index, 3, low);\n          }\n\n          if (properties[DISTANCE_DISPLAY_CONDITION]) {\n            var nearFarCartesian = scratchNearFarCartesian2;\n            nearFarCartesian.x = 0.0;\n            nearFarCartesian.y = Number.MAX_VALUE;\n            var distanceDisplayCondition = polyline.distanceDisplayCondition;\n\n            if (defined(distanceDisplayCondition)) {\n              nearFarCartesian.x = distanceDisplayCondition.near;\n              nearFarCartesian.y = distanceDisplayCondition.far;\n            }\n\n            this._batchTable.setBatchedAttribute(polyline._index, 4, nearFarCartesian);\n          }\n        }\n\n        polyline._clean();\n      }\n    }\n\n    polylinesToUpdate.length = 0;\n    this._polylinesUpdated = false;\n  }\n\n  properties = this._propertiesChanged;\n\n  for (var k = 0; k < NUMBER_OF_PROPERTIES; ++k) {\n    properties[k] = 0;\n  }\n\n  var modelMatrix = Matrix4.IDENTITY;\n\n  if (frameState.mode === SceneMode.SCENE3D) {\n    modelMatrix = this.modelMatrix;\n  }\n\n  var pass = frameState.passes;\n  var useDepthTest = frameState.morphTime !== 0.0;\n\n  if (!defined(this._opaqueRS) || this._opaqueRS.depthTest.enabled !== useDepthTest) {\n    this._opaqueRS = RenderState.fromCache({\n      depthMask: useDepthTest,\n      depthTest: {\n        enabled: useDepthTest\n      }\n    });\n  }\n\n  if (!defined(this._translucentRS) || this._translucentRS.depthTest.enabled !== useDepthTest) {\n    this._translucentRS = RenderState.fromCache({\n      blending: BlendingState.ALPHA_BLEND,\n      depthMask: !useDepthTest,\n      depthTest: {\n        enabled: useDepthTest\n      }\n    });\n  }\n\n  this._batchTable.update(frameState);\n\n  if (pass.render || pass.pick) {\n    var colorList = this._colorCommands;\n    createCommandLists(this, frameState, colorList, modelMatrix);\n  }\n};\n\nvar boundingSphereScratch = new BoundingSphere();\nvar boundingSphereScratch2 = new BoundingSphere();\n\nfunction createCommandLists(polylineCollection, frameState, commands, modelMatrix) {\n  var context = frameState.context;\n  var commandList = frameState.commandList;\n  var commandsLength = commands.length;\n  var commandIndex = 0;\n  var cloneBoundingSphere = true;\n  var vertexArrays = polylineCollection._vertexArrays;\n  var debugShowBoundingVolume = polylineCollection.debugShowBoundingVolume;\n  var batchTable = polylineCollection._batchTable;\n  var uniformCallback = batchTable.getUniformMapCallback();\n  var length = vertexArrays.length;\n\n  for (var m = 0; m < length; ++m) {\n    var va = vertexArrays[m];\n    var buckets = va.buckets;\n    var bucketLength = buckets.length;\n\n    for (var n = 0; n < bucketLength; ++n) {\n      var bucketLocator = buckets[n];\n      var offset = bucketLocator.offset;\n      var sp = bucketLocator.bucket.shaderProgram;\n      var polylines = bucketLocator.bucket.polylines;\n      var polylineLength = polylines.length;\n      var currentId;\n      var currentMaterial;\n      var count = 0;\n      var command;\n      var uniformMap;\n\n      for (var s = 0; s < polylineLength; ++s) {\n        var polyline = polylines[s];\n        var mId = createMaterialId(polyline._material);\n\n        if (mId !== currentId) {\n          if (defined(currentId) && count > 0) {\n            var translucent = currentMaterial.isTranslucent();\n\n            if (commandIndex >= commandsLength) {\n              command = new DrawCommand({\n                owner: polylineCollection\n              });\n              commands.push(command);\n            } else {\n              command = commands[commandIndex];\n            }\n\n            ++commandIndex;\n            uniformMap = combine(uniformCallback(currentMaterial._uniforms), polylineCollection._uniformMap);\n            command.boundingVolume = BoundingSphere.clone(boundingSphereScratch, command.boundingVolume);\n            command.modelMatrix = modelMatrix;\n            command.shaderProgram = sp;\n            command.vertexArray = va.va;\n            command.renderState = translucent ? polylineCollection._translucentRS : polylineCollection._opaqueRS;\n            command.pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;\n            command.debugShowBoundingVolume = debugShowBoundingVolume;\n            command.pickId = \"v_pickColor\";\n            command.uniformMap = uniformMap;\n            command.count = count;\n            command.offset = offset;\n            offset += count;\n            count = 0;\n            cloneBoundingSphere = true;\n            commandList.push(command);\n          }\n\n          currentMaterial = polyline._material;\n          currentMaterial.update(context);\n          currentId = mId;\n        }\n\n        var locators = polyline._locatorBuckets;\n        var locatorLength = locators.length;\n\n        for (var t = 0; t < locatorLength; ++t) {\n          var locator = locators[t];\n\n          if (locator.locator === bucketLocator) {\n            count += locator.count;\n          }\n        }\n\n        var boundingVolume;\n\n        if (frameState.mode === SceneMode.SCENE3D) {\n          boundingVolume = polyline._boundingVolumeWC;\n        } else if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n          boundingVolume = polyline._boundingVolume2D;\n        } else if (frameState.mode === SceneMode.SCENE2D) {\n          if (defined(polyline._boundingVolume2D)) {\n            boundingVolume = BoundingSphere.clone(polyline._boundingVolume2D, boundingSphereScratch2);\n            boundingVolume.center.x = 0.0;\n          }\n        } else if (defined(polyline._boundingVolumeWC) && defined(polyline._boundingVolume2D)) {\n          boundingVolume = BoundingSphere.union(polyline._boundingVolumeWC, polyline._boundingVolume2D, boundingSphereScratch2);\n        }\n\n        if (cloneBoundingSphere) {\n          cloneBoundingSphere = false;\n          BoundingSphere.clone(boundingVolume, boundingSphereScratch);\n        } else {\n          BoundingSphere.union(boundingVolume, boundingSphereScratch, boundingSphereScratch);\n        }\n      }\n\n      if (defined(currentId) && count > 0) {\n        if (commandIndex >= commandsLength) {\n          command = new DrawCommand({\n            owner: polylineCollection\n          });\n          commands.push(command);\n        } else {\n          command = commands[commandIndex];\n        }\n\n        ++commandIndex;\n        uniformMap = combine(uniformCallback(currentMaterial._uniforms), polylineCollection._uniformMap);\n        command.boundingVolume = BoundingSphere.clone(boundingSphereScratch, command.boundingVolume);\n        command.modelMatrix = modelMatrix;\n        command.shaderProgram = sp;\n        command.vertexArray = va.va;\n        command.renderState = currentMaterial.isTranslucent() ? polylineCollection._translucentRS : polylineCollection._opaqueRS;\n        command.pass = currentMaterial.isTranslucent() ? Pass.TRANSLUCENT : Pass.OPAQUE;\n        command.debugShowBoundingVolume = debugShowBoundingVolume;\n        command.pickId = \"v_pickColor\";\n        command.uniformMap = uniformMap;\n        command.count = count;\n        command.offset = offset;\n        cloneBoundingSphere = true;\n        commandList.push(command);\n      }\n\n      currentId = undefined;\n    }\n  }\n\n  commands.length = commandIndex;\n}\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see PolylineCollection#destroy\n */\n\n\nPolylineCollection.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * polylines = polylines && polylines.destroy();\n *\n * @see PolylineCollection#isDestroyed\n */\n\n\nPolylineCollection.prototype.destroy = function () {\n  destroyVertexArrays(this);\n  releaseShaders(this);\n  destroyPolylines(this);\n  this._batchTable = this._batchTable && this._batchTable.destroy();\n  return destroyObject(this);\n};\n\nfunction computeNewBuffersUsage(collection) {\n  var usageChanged = false;\n  var properties = collection._propertiesChanged;\n  var bufferUsage = collection._positionBufferUsage;\n\n  if (properties[POSITION_INDEX]) {\n    if (bufferUsage.bufferUsage !== BufferUsage.STREAM_DRAW) {\n      usageChanged = true;\n      bufferUsage.bufferUsage = BufferUsage.STREAM_DRAW;\n      bufferUsage.frameCount = 100;\n    } else {\n      bufferUsage.frameCount = 100;\n    }\n  } else if (bufferUsage.bufferUsage !== BufferUsage.STATIC_DRAW) {\n    if (bufferUsage.frameCount === 0) {\n      usageChanged = true;\n      bufferUsage.bufferUsage = BufferUsage.STATIC_DRAW;\n    } else {\n      bufferUsage.frameCount--;\n    }\n  }\n\n  return usageChanged;\n}\n\nvar emptyVertexBuffer = [0.0, 0.0, 0.0];\n\nfunction createVertexArrays(collection, context, projection) {\n  collection._createVertexArray = false;\n  releaseShaders(collection);\n  destroyVertexArrays(collection);\n  sortPolylinesIntoBuckets(collection); //stores all of the individual indices arrays.\n\n  var totalIndices = [[]];\n  var indices = totalIndices[0];\n  var batchTable = collection._batchTable;\n  var useHighlightColor = collection._useHighlightColor; //used to determine the vertexBuffer offset if the indicesArray goes over 64k.\n  //if it's the same polyline while it goes over 64k, the offset needs to backtrack componentsPerAttribute * componentDatatype bytes\n  //so that the polyline looks contiguous.\n  //if the polyline ends at the 64k mark, then the offset is just 64k * componentsPerAttribute * componentDatatype\n\n  var vertexBufferOffset = [0];\n  var offset = 0;\n  var vertexArrayBuckets = [[]];\n  var totalLength = 0;\n  var polylineBuckets = collection._polylineBuckets;\n  var x;\n  var bucket;\n\n  for (x in polylineBuckets) {\n    if (polylineBuckets.hasOwnProperty(x)) {\n      bucket = polylineBuckets[x];\n      bucket.updateShader(context, batchTable, useHighlightColor);\n      totalLength += bucket.lengthOfPositions;\n    }\n  }\n\n  if (totalLength > 0) {\n    var mode = collection._mode;\n    var positionArray = new Float32Array(6 * totalLength * 3);\n    var texCoordExpandAndBatchIndexArray = new Float32Array(totalLength * 4);\n    var position3DArray;\n    var positionIndex = 0;\n    var colorIndex = 0;\n    var texCoordExpandAndBatchIndexIndex = 0;\n\n    for (x in polylineBuckets) {\n      if (polylineBuckets.hasOwnProperty(x)) {\n        bucket = polylineBuckets[x];\n        bucket.write(positionArray, texCoordExpandAndBatchIndexArray, positionIndex, colorIndex, texCoordExpandAndBatchIndexIndex, batchTable, context, projection);\n\n        if (mode === SceneMode.MORPHING) {\n          if (!defined(position3DArray)) {\n            position3DArray = new Float32Array(6 * totalLength * 3);\n          }\n\n          bucket.writeForMorph(position3DArray, positionIndex);\n        }\n\n        var bucketLength = bucket.lengthOfPositions;\n        positionIndex += 6 * bucketLength * 3;\n        colorIndex += bucketLength * 4;\n        texCoordExpandAndBatchIndexIndex += bucketLength * 4;\n        offset = bucket.updateIndices(totalIndices, vertexBufferOffset, vertexArrayBuckets, offset);\n      }\n    }\n\n    var positionBufferUsage = collection._positionBufferUsage.bufferUsage;\n    var texCoordExpandAndBatchIndexBufferUsage = BufferUsage.STATIC_DRAW;\n    collection._positionBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: positionArray,\n      usage: positionBufferUsage\n    });\n    var position3DBuffer;\n\n    if (defined(position3DArray)) {\n      position3DBuffer = Buffer.createVertexBuffer({\n        context: context,\n        typedArray: position3DArray,\n        usage: positionBufferUsage\n      });\n    }\n\n    collection._texCoordExpandAndBatchIndexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: texCoordExpandAndBatchIndexArray,\n      usage: texCoordExpandAndBatchIndexBufferUsage\n    });\n    var positionSizeInBytes = 3 * Float32Array.BYTES_PER_ELEMENT;\n    var texCoordExpandAndBatchIndexSizeInBytes = 4 * Float32Array.BYTES_PER_ELEMENT;\n    var vbo = 0;\n    var numberOfIndicesArrays = totalIndices.length;\n\n    for (var k = 0; k < numberOfIndicesArrays; ++k) {\n      indices = totalIndices[k];\n\n      if (indices.length > 0) {\n        var indicesArray = new Uint16Array(indices);\n        var indexBuffer = Buffer.createIndexBuffer({\n          context: context,\n          typedArray: indicesArray,\n          usage: BufferUsage.STATIC_DRAW,\n          indexDatatype: IndexDatatype.UNSIGNED_SHORT\n        });\n        vbo += vertexBufferOffset[k];\n        var positionHighOffset = 6 * (k * (positionSizeInBytes * CesiumMath.SIXTY_FOUR_KILOBYTES) - vbo * positionSizeInBytes); //componentsPerAttribute(3) * componentDatatype(4)\n\n        var positionLowOffset = positionSizeInBytes + positionHighOffset;\n        var prevPositionHighOffset = positionSizeInBytes + positionLowOffset;\n        var prevPositionLowOffset = positionSizeInBytes + prevPositionHighOffset;\n        var nextPositionHighOffset = positionSizeInBytes + prevPositionLowOffset;\n        var nextPositionLowOffset = positionSizeInBytes + nextPositionHighOffset;\n        var vertexTexCoordExpandAndBatchIndexBufferOffset = k * (texCoordExpandAndBatchIndexSizeInBytes * CesiumMath.SIXTY_FOUR_KILOBYTES) - vbo * texCoordExpandAndBatchIndexSizeInBytes;\n        var attributes = [{\n          index: attributeLocations.position3DHigh,\n          componentsPerAttribute: 3,\n          componentDatatype: ComponentDatatype.FLOAT,\n          offsetInBytes: positionHighOffset,\n          strideInBytes: 6 * positionSizeInBytes\n        }, {\n          index: attributeLocations.position3DLow,\n          componentsPerAttribute: 3,\n          componentDatatype: ComponentDatatype.FLOAT,\n          offsetInBytes: positionLowOffset,\n          strideInBytes: 6 * positionSizeInBytes\n        }, {\n          index: attributeLocations.position2DHigh,\n          componentsPerAttribute: 3,\n          componentDatatype: ComponentDatatype.FLOAT,\n          offsetInBytes: positionHighOffset,\n          strideInBytes: 6 * positionSizeInBytes\n        }, {\n          index: attributeLocations.position2DLow,\n          componentsPerAttribute: 3,\n          componentDatatype: ComponentDatatype.FLOAT,\n          offsetInBytes: positionLowOffset,\n          strideInBytes: 6 * positionSizeInBytes\n        }, {\n          index: attributeLocations.prevPosition3DHigh,\n          componentsPerAttribute: 3,\n          componentDatatype: ComponentDatatype.FLOAT,\n          offsetInBytes: prevPositionHighOffset,\n          strideInBytes: 6 * positionSizeInBytes\n        }, {\n          index: attributeLocations.prevPosition3DLow,\n          componentsPerAttribute: 3,\n          componentDatatype: ComponentDatatype.FLOAT,\n          offsetInBytes: prevPositionLowOffset,\n          strideInBytes: 6 * positionSizeInBytes\n        }, {\n          index: attributeLocations.prevPosition2DHigh,\n          componentsPerAttribute: 3,\n          componentDatatype: ComponentDatatype.FLOAT,\n          offsetInBytes: prevPositionHighOffset,\n          strideInBytes: 6 * positionSizeInBytes\n        }, {\n          index: attributeLocations.prevPosition2DLow,\n          componentsPerAttribute: 3,\n          componentDatatype: ComponentDatatype.FLOAT,\n          offsetInBytes: prevPositionLowOffset,\n          strideInBytes: 6 * positionSizeInBytes\n        }, {\n          index: attributeLocations.nextPosition3DHigh,\n          componentsPerAttribute: 3,\n          componentDatatype: ComponentDatatype.FLOAT,\n          offsetInBytes: nextPositionHighOffset,\n          strideInBytes: 6 * positionSizeInBytes\n        }, {\n          index: attributeLocations.nextPosition3DLow,\n          componentsPerAttribute: 3,\n          componentDatatype: ComponentDatatype.FLOAT,\n          offsetInBytes: nextPositionLowOffset,\n          strideInBytes: 6 * positionSizeInBytes\n        }, {\n          index: attributeLocations.nextPosition2DHigh,\n          componentsPerAttribute: 3,\n          componentDatatype: ComponentDatatype.FLOAT,\n          offsetInBytes: nextPositionHighOffset,\n          strideInBytes: 6 * positionSizeInBytes\n        }, {\n          index: attributeLocations.nextPosition2DLow,\n          componentsPerAttribute: 3,\n          componentDatatype: ComponentDatatype.FLOAT,\n          offsetInBytes: nextPositionLowOffset,\n          strideInBytes: 6 * positionSizeInBytes\n        }, {\n          index: attributeLocations.texCoordExpandAndBatchIndex,\n          componentsPerAttribute: 4,\n          componentDatatype: ComponentDatatype.FLOAT,\n          vertexBuffer: collection._texCoordExpandAndBatchIndexBuffer,\n          offsetInBytes: vertexTexCoordExpandAndBatchIndexBufferOffset\n        }];\n        var buffer3D;\n        var bufferProperty3D;\n        var buffer2D;\n        var bufferProperty2D;\n\n        if (mode === SceneMode.SCENE3D) {\n          buffer3D = collection._positionBuffer;\n          bufferProperty3D = \"vertexBuffer\";\n          buffer2D = emptyVertexBuffer;\n          bufferProperty2D = \"value\";\n        } else if (mode === SceneMode.SCENE2D || mode === SceneMode.COLUMBUS_VIEW) {\n          buffer3D = emptyVertexBuffer;\n          bufferProperty3D = \"value\";\n          buffer2D = collection._positionBuffer;\n          bufferProperty2D = \"vertexBuffer\";\n        } else {\n          buffer3D = position3DBuffer;\n          bufferProperty3D = \"vertexBuffer\";\n          buffer2D = collection._positionBuffer;\n          bufferProperty2D = \"vertexBuffer\";\n        }\n\n        attributes[0][bufferProperty3D] = buffer3D;\n        attributes[1][bufferProperty3D] = buffer3D;\n        attributes[2][bufferProperty2D] = buffer2D;\n        attributes[3][bufferProperty2D] = buffer2D;\n        attributes[4][bufferProperty3D] = buffer3D;\n        attributes[5][bufferProperty3D] = buffer3D;\n        attributes[6][bufferProperty2D] = buffer2D;\n        attributes[7][bufferProperty2D] = buffer2D;\n        attributes[8][bufferProperty3D] = buffer3D;\n        attributes[9][bufferProperty3D] = buffer3D;\n        attributes[10][bufferProperty2D] = buffer2D;\n        attributes[11][bufferProperty2D] = buffer2D;\n        var va = new VertexArray({\n          context: context,\n          attributes: attributes,\n          indexBuffer: indexBuffer\n        });\n\n        collection._vertexArrays.push({\n          va: va,\n          buckets: vertexArrayBuckets[k]\n        });\n      }\n    }\n  }\n}\n\nfunction replacer(key, value) {\n  if (value instanceof Texture) {\n    return value.id;\n  }\n\n  return value;\n}\n\nvar scratchUniformArray = [];\n\nfunction createMaterialId(material) {\n  var uniforms = Material._uniformList[material.type];\n  var length = uniforms.length;\n  scratchUniformArray.length = 2.0 * length;\n  var index = 0;\n\n  for (var i = 0; i < length; ++i) {\n    var uniform = uniforms[i];\n    scratchUniformArray[index] = uniform;\n    scratchUniformArray[index + 1] = material._uniforms[uniform]();\n    index += 2;\n  }\n\n  return material.type + \":\" + JSON.stringify(scratchUniformArray, replacer);\n}\n\nfunction sortPolylinesIntoBuckets(collection) {\n  var mode = collection._mode;\n  var modelMatrix = collection._modelMatrix;\n  var polylineBuckets = collection._polylineBuckets = {};\n  var polylines = collection._polylines;\n  var length = polylines.length;\n\n  for (var i = 0; i < length; ++i) {\n    var p = polylines[i];\n\n    if (p._actualPositions.length > 1) {\n      p.update();\n      var material = p.material;\n      var value = polylineBuckets[material.type];\n\n      if (!defined(value)) {\n        value = polylineBuckets[material.type] = new PolylineBucket(material, mode, modelMatrix);\n      }\n\n      value.addPolyline(p);\n    }\n  }\n}\n\nfunction updateMode(collection, frameState) {\n  var mode = frameState.mode;\n\n  if (collection._mode !== mode || !Matrix4.equals(collection._modelMatrix, collection.modelMatrix)) {\n    collection._mode = mode;\n    collection._modelMatrix = Matrix4.clone(collection.modelMatrix);\n    collection._createVertexArray = true;\n  }\n}\n\nfunction removePolylines(collection) {\n  if (collection._polylinesRemoved) {\n    collection._polylinesRemoved = false;\n    var definedPolylines = [];\n    var definedPolylinesToUpdate = [];\n    var polyIndex = 0;\n    var polyline;\n    var length = collection._polylines.length;\n\n    for (var i = 0; i < length; ++i) {\n      polyline = collection._polylines[i];\n\n      if (!polyline.isDestroyed) {\n        polyline._index = polyIndex++;\n        definedPolylinesToUpdate.push(polyline);\n        definedPolylines.push(polyline);\n      }\n    }\n\n    collection._polylines = definedPolylines;\n    collection._polylinesToUpdate = definedPolylinesToUpdate;\n  }\n}\n\nfunction releaseShaders(collection) {\n  var polylines = collection._polylines;\n  var length = polylines.length;\n\n  for (var i = 0; i < length; ++i) {\n    if (!polylines[i].isDestroyed) {\n      var bucket = polylines[i]._bucket;\n\n      if (defined(bucket)) {\n        bucket.shaderProgram = bucket.shaderProgram && bucket.shaderProgram.destroy();\n      }\n    }\n  }\n}\n\nfunction destroyVertexArrays(collection) {\n  var length = collection._vertexArrays.length;\n\n  for (var t = 0; t < length; ++t) {\n    collection._vertexArrays[t].va.destroy();\n  }\n\n  collection._vertexArrays.length = 0;\n}\n\nPolylineCollection.prototype._updatePolyline = function (polyline, propertyChanged) {\n  this._polylinesUpdated = true;\n\n  if (!polyline._dirty) {\n    this._polylinesToUpdate.push(polyline);\n  }\n\n  ++this._propertiesChanged[propertyChanged];\n};\n\nfunction destroyPolylines(collection) {\n  var polylines = collection._polylines;\n  var length = polylines.length;\n\n  for (var i = 0; i < length; ++i) {\n    if (!polylines[i].isDestroyed) {\n      polylines[i]._destroy();\n    }\n  }\n}\n\nfunction VertexArrayBucketLocator(count, offset, bucket) {\n  this.count = count;\n  this.offset = offset;\n  this.bucket = bucket;\n}\n\nfunction PolylineBucket(material, mode, modelMatrix) {\n  this.polylines = [];\n  this.lengthOfPositions = 0;\n  this.material = material;\n  this.shaderProgram = undefined;\n  this.mode = mode;\n  this.modelMatrix = modelMatrix;\n}\n\nPolylineBucket.prototype.addPolyline = function (p) {\n  var polylines = this.polylines;\n  polylines.push(p);\n  p._actualLength = this.getPolylinePositionsLength(p);\n  this.lengthOfPositions += p._actualLength;\n  p._bucket = this;\n};\n\nPolylineBucket.prototype.updateShader = function (context, batchTable, useHighlightColor) {\n  if (defined(this.shaderProgram)) {\n    return;\n  }\n\n  var defines = [\"DISTANCE_DISPLAY_CONDITION\"];\n\n  if (useHighlightColor) {\n    defines.push(\"VECTOR_TILE\");\n  } // Check for use of v_polylineAngle in material shader\n\n\n  if (this.material.shaderSource.search(/varying\\s+float\\s+v_polylineAngle;/g) !== -1) {\n    defines.push(\"POLYLINE_DASH\");\n  }\n\n  if (!FeatureDetection.isInternetExplorer()) {\n    defines.push(\"CLIP_POLYLINE\");\n  }\n\n  var fs = new ShaderSource({\n    defines: defines,\n    sources: [\"varying vec4 v_pickColor;\\n\", this.material.shaderSource, PolylineFS]\n  });\n  var vsSource = batchTable.getVertexShaderCallback()(PolylineVS);\n  var vs = new ShaderSource({\n    defines: defines,\n    sources: [PolylineCommon, vsSource]\n  });\n  this.shaderProgram = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations\n  });\n};\n\nfunction intersectsIDL(polyline) {\n  return Cartesian3.dot(Cartesian3.UNIT_X, polyline._boundingVolume.center) < 0 || polyline._boundingVolume.intersectPlane(Plane.ORIGIN_ZX_PLANE) === Intersect.INTERSECTING;\n}\n\nPolylineBucket.prototype.getPolylinePositionsLength = function (polyline) {\n  var length;\n\n  if (this.mode === SceneMode.SCENE3D || !intersectsIDL(polyline)) {\n    length = polyline._actualPositions.length;\n    return length * 4.0 - 4.0;\n  }\n\n  var count = 0;\n  var segmentLengths = polyline._segments.lengths;\n  length = segmentLengths.length;\n\n  for (var i = 0; i < length; ++i) {\n    count += segmentLengths[i] * 4.0 - 4.0;\n  }\n\n  return count;\n};\n\nvar scratchWritePosition = new Cartesian3();\nvar scratchWritePrevPosition = new Cartesian3();\nvar scratchWriteNextPosition = new Cartesian3();\nvar scratchWriteVector = new Cartesian3();\nvar scratchPickColorCartesian = new Cartesian4();\nvar scratchWidthShowCartesian = new Cartesian2();\n\nPolylineBucket.prototype.write = function (positionArray, texCoordExpandAndBatchIndexArray, positionIndex, colorIndex, texCoordExpandAndBatchIndexIndex, batchTable, context, projection) {\n  var mode = this.mode;\n  var maxLon = projection.ellipsoid.maximumRadius * CesiumMath.PI;\n  var polylines = this.polylines;\n  var length = polylines.length;\n\n  for (var i = 0; i < length; ++i) {\n    var polyline = polylines[i];\n    var width = polyline.width;\n    var show = polyline.show && width > 0.0;\n    var polylineBatchIndex = polyline._index;\n    var segments = this.getSegments(polyline, projection);\n    var positions = segments.positions;\n    var lengths = segments.lengths;\n    var positionsLength = positions.length;\n    var pickColor = polyline.getPickId(context).color;\n    var segmentIndex = 0;\n    var count = 0;\n    var position;\n\n    for (var j = 0; j < positionsLength; ++j) {\n      if (j === 0) {\n        if (polyline._loop) {\n          position = positions[positionsLength - 2];\n        } else {\n          position = scratchWriteVector;\n          Cartesian3.subtract(positions[0], positions[1], position);\n          Cartesian3.add(positions[0], position, position);\n        }\n      } else {\n        position = positions[j - 1];\n      }\n\n      Cartesian3.clone(position, scratchWritePrevPosition);\n      Cartesian3.clone(positions[j], scratchWritePosition);\n\n      if (j === positionsLength - 1) {\n        if (polyline._loop) {\n          position = positions[1];\n        } else {\n          position = scratchWriteVector;\n          Cartesian3.subtract(positions[positionsLength - 1], positions[positionsLength - 2], position);\n          Cartesian3.add(positions[positionsLength - 1], position, position);\n        }\n      } else {\n        position = positions[j + 1];\n      }\n\n      Cartesian3.clone(position, scratchWriteNextPosition);\n      var segmentLength = lengths[segmentIndex];\n\n      if (j === count + segmentLength) {\n        count += segmentLength;\n        ++segmentIndex;\n      }\n\n      var segmentStart = j - count === 0;\n      var segmentEnd = j === count + lengths[segmentIndex] - 1;\n\n      if (mode === SceneMode.SCENE2D) {\n        scratchWritePrevPosition.z = 0.0;\n        scratchWritePosition.z = 0.0;\n        scratchWriteNextPosition.z = 0.0;\n      }\n\n      if (mode === SceneMode.SCENE2D || mode === SceneMode.MORPHING) {\n        if ((segmentStart || segmentEnd) && maxLon - Math.abs(scratchWritePosition.x) < 1.0) {\n          if (scratchWritePosition.x < 0.0 && scratchWritePrevPosition.x > 0.0 || scratchWritePosition.x > 0.0 && scratchWritePrevPosition.x < 0.0) {\n            Cartesian3.clone(scratchWritePosition, scratchWritePrevPosition);\n          }\n\n          if (scratchWritePosition.x < 0.0 && scratchWriteNextPosition.x > 0.0 || scratchWritePosition.x > 0.0 && scratchWriteNextPosition.x < 0.0) {\n            Cartesian3.clone(scratchWritePosition, scratchWriteNextPosition);\n          }\n        }\n      }\n\n      var startK = segmentStart ? 2 : 0;\n      var endK = segmentEnd ? 2 : 4;\n\n      for (var k = startK; k < endK; ++k) {\n        EncodedCartesian3.writeElements(scratchWritePosition, positionArray, positionIndex);\n        EncodedCartesian3.writeElements(scratchWritePrevPosition, positionArray, positionIndex + 6);\n        EncodedCartesian3.writeElements(scratchWriteNextPosition, positionArray, positionIndex + 12);\n        var direction = k - 2 < 0 ? -1.0 : 1.0;\n        texCoordExpandAndBatchIndexArray[texCoordExpandAndBatchIndexIndex] = j / (positionsLength - 1); // s tex coord\n\n        texCoordExpandAndBatchIndexArray[texCoordExpandAndBatchIndexIndex + 1] = 2 * (k % 2) - 1; // expand direction\n\n        texCoordExpandAndBatchIndexArray[texCoordExpandAndBatchIndexIndex + 2] = direction;\n        texCoordExpandAndBatchIndexArray[texCoordExpandAndBatchIndexIndex + 3] = polylineBatchIndex;\n        positionIndex += 6 * 3;\n        texCoordExpandAndBatchIndexIndex += 4;\n      }\n    }\n\n    var colorCartesian = scratchPickColorCartesian;\n    colorCartesian.x = Color.floatToByte(pickColor.red);\n    colorCartesian.y = Color.floatToByte(pickColor.green);\n    colorCartesian.z = Color.floatToByte(pickColor.blue);\n    colorCartesian.w = Color.floatToByte(pickColor.alpha);\n    var widthShowCartesian = scratchWidthShowCartesian;\n    widthShowCartesian.x = width;\n    widthShowCartesian.y = show ? 1.0 : 0.0;\n    var boundingSphere = mode === SceneMode.SCENE2D ? polyline._boundingVolume2D : polyline._boundingVolumeWC;\n    var encodedCenter = EncodedCartesian3.fromCartesian(boundingSphere.center, scratchUpdatePolylineEncodedCartesian);\n    var high = encodedCenter.high;\n    var low = Cartesian4.fromElements(encodedCenter.low.x, encodedCenter.low.y, encodedCenter.low.z, boundingSphere.radius, scratchUpdatePolylineCartesian4);\n    var nearFarCartesian = scratchNearFarCartesian2;\n    nearFarCartesian.x = 0.0;\n    nearFarCartesian.y = Number.MAX_VALUE;\n    var distanceDisplayCondition = polyline.distanceDisplayCondition;\n\n    if (defined(distanceDisplayCondition)) {\n      nearFarCartesian.x = distanceDisplayCondition.near;\n      nearFarCartesian.y = distanceDisplayCondition.far;\n    }\n\n    batchTable.setBatchedAttribute(polylineBatchIndex, 0, widthShowCartesian);\n    batchTable.setBatchedAttribute(polylineBatchIndex, 1, colorCartesian);\n\n    if (batchTable.attributes.length > 2) {\n      batchTable.setBatchedAttribute(polylineBatchIndex, 2, high);\n      batchTable.setBatchedAttribute(polylineBatchIndex, 3, low);\n      batchTable.setBatchedAttribute(polylineBatchIndex, 4, nearFarCartesian);\n    }\n  }\n};\n\nvar morphPositionScratch = new Cartesian3();\nvar morphPrevPositionScratch = new Cartesian3();\nvar morphNextPositionScratch = new Cartesian3();\nvar morphVectorScratch = new Cartesian3();\n\nPolylineBucket.prototype.writeForMorph = function (positionArray, positionIndex) {\n  var modelMatrix = this.modelMatrix;\n  var polylines = this.polylines;\n  var length = polylines.length;\n\n  for (var i = 0; i < length; ++i) {\n    var polyline = polylines[i];\n    var positions = polyline._segments.positions;\n    var lengths = polyline._segments.lengths;\n    var positionsLength = positions.length;\n    var segmentIndex = 0;\n    var count = 0;\n\n    for (var j = 0; j < positionsLength; ++j) {\n      var prevPosition;\n\n      if (j === 0) {\n        if (polyline._loop) {\n          prevPosition = positions[positionsLength - 2];\n        } else {\n          prevPosition = morphVectorScratch;\n          Cartesian3.subtract(positions[0], positions[1], prevPosition);\n          Cartesian3.add(positions[0], prevPosition, prevPosition);\n        }\n      } else {\n        prevPosition = positions[j - 1];\n      }\n\n      prevPosition = Matrix4.multiplyByPoint(modelMatrix, prevPosition, morphPrevPositionScratch);\n      var position = Matrix4.multiplyByPoint(modelMatrix, positions[j], morphPositionScratch);\n      var nextPosition;\n\n      if (j === positionsLength - 1) {\n        if (polyline._loop) {\n          nextPosition = positions[1];\n        } else {\n          nextPosition = morphVectorScratch;\n          Cartesian3.subtract(positions[positionsLength - 1], positions[positionsLength - 2], nextPosition);\n          Cartesian3.add(positions[positionsLength - 1], nextPosition, nextPosition);\n        }\n      } else {\n        nextPosition = positions[j + 1];\n      }\n\n      nextPosition = Matrix4.multiplyByPoint(modelMatrix, nextPosition, morphNextPositionScratch);\n      var segmentLength = lengths[segmentIndex];\n\n      if (j === count + segmentLength) {\n        count += segmentLength;\n        ++segmentIndex;\n      }\n\n      var segmentStart = j - count === 0;\n      var segmentEnd = j === count + lengths[segmentIndex] - 1;\n      var startK = segmentStart ? 2 : 0;\n      var endK = segmentEnd ? 2 : 4;\n\n      for (var k = startK; k < endK; ++k) {\n        EncodedCartesian3.writeElements(position, positionArray, positionIndex);\n        EncodedCartesian3.writeElements(prevPosition, positionArray, positionIndex + 6);\n        EncodedCartesian3.writeElements(nextPosition, positionArray, positionIndex + 12);\n        positionIndex += 6 * 3;\n      }\n    }\n  }\n};\n\nvar scratchSegmentLengths = new Array(1);\n\nPolylineBucket.prototype.updateIndices = function (totalIndices, vertexBufferOffset, vertexArrayBuckets, offset) {\n  var vaCount = vertexArrayBuckets.length - 1;\n  var bucketLocator = new VertexArrayBucketLocator(0, offset, this);\n  vertexArrayBuckets[vaCount].push(bucketLocator);\n  var count = 0;\n  var indices = totalIndices[totalIndices.length - 1];\n  var indicesCount = 0;\n\n  if (indices.length > 0) {\n    indicesCount = indices[indices.length - 1] + 1;\n  }\n\n  var polylines = this.polylines;\n  var length = polylines.length;\n\n  for (var i = 0; i < length; ++i) {\n    var polyline = polylines[i];\n    polyline._locatorBuckets = [];\n    var segments;\n\n    if (this.mode === SceneMode.SCENE3D) {\n      segments = scratchSegmentLengths;\n      var positionsLength = polyline._actualPositions.length;\n\n      if (positionsLength > 0) {\n        segments[0] = positionsLength;\n      } else {\n        continue;\n      }\n    } else {\n      segments = polyline._segments.lengths;\n    }\n\n    var numberOfSegments = segments.length;\n\n    if (numberOfSegments > 0) {\n      var segmentIndexCount = 0;\n\n      for (var j = 0; j < numberOfSegments; ++j) {\n        var segmentLength = segments[j] - 1.0;\n\n        for (var k = 0; k < segmentLength; ++k) {\n          if (indicesCount + 4 > CesiumMath.SIXTY_FOUR_KILOBYTES) {\n            polyline._locatorBuckets.push({\n              locator: bucketLocator,\n              count: segmentIndexCount\n            });\n\n            segmentIndexCount = 0;\n            vertexBufferOffset.push(4);\n            indices = [];\n            totalIndices.push(indices);\n            indicesCount = 0;\n            bucketLocator.count = count;\n            count = 0;\n            offset = 0;\n            bucketLocator = new VertexArrayBucketLocator(0, 0, this);\n            vertexArrayBuckets[++vaCount] = [bucketLocator];\n          }\n\n          indices.push(indicesCount, indicesCount + 2, indicesCount + 1);\n          indices.push(indicesCount + 1, indicesCount + 2, indicesCount + 3);\n          segmentIndexCount += 6;\n          count += 6;\n          offset += 6;\n          indicesCount += 4;\n        }\n      }\n\n      polyline._locatorBuckets.push({\n        locator: bucketLocator,\n        count: segmentIndexCount\n      });\n\n      if (indicesCount + 4 > CesiumMath.SIXTY_FOUR_KILOBYTES) {\n        vertexBufferOffset.push(0);\n        indices = [];\n        totalIndices.push(indices);\n        indicesCount = 0;\n        bucketLocator.count = count;\n        offset = 0;\n        count = 0;\n        bucketLocator = new VertexArrayBucketLocator(0, 0, this);\n        vertexArrayBuckets[++vaCount] = [bucketLocator];\n      }\n    }\n\n    polyline._clean();\n  }\n\n  bucketLocator.count = count;\n  return offset;\n};\n\nPolylineBucket.prototype.getPolylineStartIndex = function (polyline) {\n  var polylines = this.polylines;\n  var positionIndex = 0;\n  var length = polylines.length;\n\n  for (var i = 0; i < length; ++i) {\n    var p = polylines[i];\n\n    if (p === polyline) {\n      break;\n    }\n\n    positionIndex += p._actualLength;\n  }\n\n  return positionIndex;\n};\n\nvar scratchSegments = {\n  positions: undefined,\n  lengths: undefined\n};\nvar scratchLengths = new Array(1);\nvar pscratch = new Cartesian3();\nvar scratchCartographic = new Cartographic();\n\nPolylineBucket.prototype.getSegments = function (polyline, projection) {\n  var positions = polyline._actualPositions;\n\n  if (this.mode === SceneMode.SCENE3D) {\n    scratchLengths[0] = positions.length;\n    scratchSegments.positions = positions;\n    scratchSegments.lengths = scratchLengths;\n    return scratchSegments;\n  }\n\n  if (intersectsIDL(polyline)) {\n    positions = polyline._segments.positions;\n  }\n\n  var ellipsoid = projection.ellipsoid;\n  var newPositions = [];\n  var modelMatrix = this.modelMatrix;\n  var length = positions.length;\n  var position;\n  var p = pscratch;\n\n  for (var n = 0; n < length; ++n) {\n    position = positions[n];\n    p = Matrix4.multiplyByPoint(modelMatrix, position, p);\n    newPositions.push(projection.project(ellipsoid.cartesianToCartographic(p, scratchCartographic)));\n  }\n\n  if (newPositions.length > 0) {\n    polyline._boundingVolume2D = BoundingSphere.fromPoints(newPositions, polyline._boundingVolume2D);\n    var center2D = polyline._boundingVolume2D.center;\n    polyline._boundingVolume2D.center = new Cartesian3(center2D.z, center2D.x, center2D.y);\n  }\n\n  scratchSegments.positions = newPositions;\n  scratchSegments.lengths = polyline._segments.lengths;\n  return scratchSegments;\n};\n\nvar scratchPositionsArray;\n\nPolylineBucket.prototype.writeUpdate = function (index, polyline, positionBuffer, projection) {\n  var mode = this.mode;\n  var maxLon = projection.ellipsoid.maximumRadius * CesiumMath.PI;\n  var positionsLength = polyline._actualLength;\n\n  if (positionsLength) {\n    index += this.getPolylineStartIndex(polyline);\n    var positionArray = scratchPositionsArray;\n    var positionsArrayLength = 6 * positionsLength * 3;\n\n    if (!defined(positionArray) || positionArray.length < positionsArrayLength) {\n      positionArray = scratchPositionsArray = new Float32Array(positionsArrayLength);\n    } else if (positionArray.length > positionsArrayLength) {\n      positionArray = new Float32Array(positionArray.buffer, 0, positionsArrayLength);\n    }\n\n    var segments = this.getSegments(polyline, projection);\n    var positions = segments.positions;\n    var lengths = segments.lengths;\n    var positionIndex = 0;\n    var segmentIndex = 0;\n    var count = 0;\n    var position;\n    positionsLength = positions.length;\n\n    for (var i = 0; i < positionsLength; ++i) {\n      if (i === 0) {\n        if (polyline._loop) {\n          position = positions[positionsLength - 2];\n        } else {\n          position = scratchWriteVector;\n          Cartesian3.subtract(positions[0], positions[1], position);\n          Cartesian3.add(positions[0], position, position);\n        }\n      } else {\n        position = positions[i - 1];\n      }\n\n      Cartesian3.clone(position, scratchWritePrevPosition);\n      Cartesian3.clone(positions[i], scratchWritePosition);\n\n      if (i === positionsLength - 1) {\n        if (polyline._loop) {\n          position = positions[1];\n        } else {\n          position = scratchWriteVector;\n          Cartesian3.subtract(positions[positionsLength - 1], positions[positionsLength - 2], position);\n          Cartesian3.add(positions[positionsLength - 1], position, position);\n        }\n      } else {\n        position = positions[i + 1];\n      }\n\n      Cartesian3.clone(position, scratchWriteNextPosition);\n      var segmentLength = lengths[segmentIndex];\n\n      if (i === count + segmentLength) {\n        count += segmentLength;\n        ++segmentIndex;\n      }\n\n      var segmentStart = i - count === 0;\n      var segmentEnd = i === count + lengths[segmentIndex] - 1;\n\n      if (mode === SceneMode.SCENE2D) {\n        scratchWritePrevPosition.z = 0.0;\n        scratchWritePosition.z = 0.0;\n        scratchWriteNextPosition.z = 0.0;\n      }\n\n      if (mode === SceneMode.SCENE2D || mode === SceneMode.MORPHING) {\n        if ((segmentStart || segmentEnd) && maxLon - Math.abs(scratchWritePosition.x) < 1.0) {\n          if (scratchWritePosition.x < 0.0 && scratchWritePrevPosition.x > 0.0 || scratchWritePosition.x > 0.0 && scratchWritePrevPosition.x < 0.0) {\n            Cartesian3.clone(scratchWritePosition, scratchWritePrevPosition);\n          }\n\n          if (scratchWritePosition.x < 0.0 && scratchWriteNextPosition.x > 0.0 || scratchWritePosition.x > 0.0 && scratchWriteNextPosition.x < 0.0) {\n            Cartesian3.clone(scratchWritePosition, scratchWriteNextPosition);\n          }\n        }\n      }\n\n      var startJ = segmentStart ? 2 : 0;\n      var endJ = segmentEnd ? 2 : 4;\n\n      for (var j = startJ; j < endJ; ++j) {\n        EncodedCartesian3.writeElements(scratchWritePosition, positionArray, positionIndex);\n        EncodedCartesian3.writeElements(scratchWritePrevPosition, positionArray, positionIndex + 6);\n        EncodedCartesian3.writeElements(scratchWriteNextPosition, positionArray, positionIndex + 12);\n        positionIndex += 6 * 3;\n      }\n    }\n\n    positionBuffer.copyFromArrayView(positionArray, 6 * 3 * Float32Array.BYTES_PER_ELEMENT * index);\n  }\n};\n\nexport default PolylineCollection;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Scene/PolylineCollection.js"],"names":["BoundingSphere","Cartesian2","Cartesian3","Cartesian4","Cartographic","Color","combine","ComponentDatatype","defaultValue","defined","destroyObject","DeveloperError","EncodedCartesian3","FeatureDetection","IndexDatatype","Intersect","CesiumMath","Matrix4","Plane","RuntimeError","Buffer","BufferUsage","ContextLimits","DrawCommand","Pass","RenderState","ShaderProgram","ShaderSource","Texture","VertexArray","PolylineCommon","PolylineFS","PolylineVS","BatchTable","BlendingState","Material","Polyline","SceneMode","SHOW_INDEX","WIDTH_INDEX","POSITION_INDEX","MATERIAL_INDEX","POSITION_SIZE_INDEX","DISTANCE_DISPLAY_CONDITION","NUMBER_OF_PROPERTIES","attributeLocations","texCoordExpandAndBatchIndex","position3DHigh","position3DLow","position2DHigh","position2DLow","prevPosition3DHigh","prevPosition3DLow","prevPosition2DHigh","prevPosition2DLow","nextPosition3DHigh","nextPosition3DLow","nextPosition2DHigh","nextPosition2DLow","PolylineCollection","options","EMPTY_OBJECT","modelMatrix","clone","IDENTITY","_modelMatrix","debugShowBoundingVolume","_opaqueRS","undefined","_translucentRS","_colorCommands","_polylinesUpdated","_polylinesRemoved","_createVertexArray","_propertiesChanged","Uint32Array","_polylines","_polylineBuckets","_positionBufferUsage","bufferUsage","STATIC_DRAW","frameCount","_mode","_polylinesToUpdate","_vertexArrays","_positionBuffer","_texCoordExpandAndBatchIndexBuffer","_batchTable","_createBatchTable","_useHighlightColor","_highlightColor","WHITE","that","_uniformMap","u_highlightColor","Object","defineProperties","prototype","length","get","removePolylines","add","p","_index","push","remove","polyline","contains","_bucket","bucket","shaderProgram","destroy","_destroy","removeAll","releaseShaders","destroyPolylines","_polylineCollection","index","createBatchTable","collection","context","attributes","functionName","componentDatatype","UNSIGNED_BYTE","componentsPerAttribute","normalize","FLOAT","scratchUpdatePolylineEncodedCartesian","scratchUpdatePolylineCartesian4","scratchNearFarCartesian2","update","frameState","updateMode","projection","mapProjection","properties","maximumVertexTextureImageUnits","computeNewBuffersUsage","createVertexArrays","polylinesToUpdate","SCENE3D","updateLength","i","polylineBuckets","ii","x","hasOwnProperty","writeUpdate","lengthOfPositions","setBatchedAttribute","_width","_show","boundingSphere","mode","SCENE2D","_boundingVolume2D","_boundingVolumeWC","encodedCenter","fromCartesian","center","low","fromElements","y","z","radius","high","nearFarCartesian","Number","MAX_VALUE","distanceDisplayCondition","near","far","_clean","k","pass","passes","useDepthTest","morphTime","depthTest","enabled","fromCache","depthMask","blending","ALPHA_BLEND","render","pick","colorList","createCommandLists","boundingSphereScratch","boundingSphereScratch2","polylineCollection","commands","commandList","commandsLength","commandIndex","cloneBoundingSphere","vertexArrays","batchTable","uniformCallback","getUniformMapCallback","m","va","buckets","bucketLength","n","bucketLocator","offset","sp","polylines","polylineLength","currentId","currentMaterial","count","command","uniformMap","s","mId","createMaterialId","_material","translucent","isTranslucent","owner","_uniforms","boundingVolume","vertexArray","renderState","TRANSLUCENT","OPAQUE","pickId","locators","_locatorBuckets","locatorLength","t","locator","COLUMBUS_VIEW","union","isDestroyed","destroyVertexArrays","usageChanged","STREAM_DRAW","emptyVertexBuffer","sortPolylinesIntoBuckets","totalIndices","indices","useHighlightColor","vertexBufferOffset","vertexArrayBuckets","totalLength","updateShader","positionArray","Float32Array","texCoordExpandAndBatchIndexArray","position3DArray","positionIndex","colorIndex","texCoordExpandAndBatchIndexIndex","write","MORPHING","writeForMorph","updateIndices","positionBufferUsage","texCoordExpandAndBatchIndexBufferUsage","createVertexBuffer","typedArray","usage","position3DBuffer","positionSizeInBytes","BYTES_PER_ELEMENT","texCoordExpandAndBatchIndexSizeInBytes","vbo","numberOfIndicesArrays","indicesArray","Uint16Array","indexBuffer","createIndexBuffer","indexDatatype","UNSIGNED_SHORT","positionHighOffset","SIXTY_FOUR_KILOBYTES","positionLowOffset","prevPositionHighOffset","prevPositionLowOffset","nextPositionHighOffset","nextPositionLowOffset","vertexTexCoordExpandAndBatchIndexBufferOffset","offsetInBytes","strideInBytes","vertexBuffer","buffer3D","bufferProperty3D","buffer2D","bufferProperty2D","replacer","key","value","id","scratchUniformArray","material","uniforms","_uniformList","type","uniform","JSON","stringify","_actualPositions","PolylineBucket","addPolyline","equals","definedPolylines","definedPolylinesToUpdate","polyIndex","_updatePolyline","propertyChanged","_dirty","VertexArrayBucketLocator","_actualLength","getPolylinePositionsLength","defines","shaderSource","search","isInternetExplorer","fs","sources","vsSource","getVertexShaderCallback","vs","vertexShaderSource","fragmentShaderSource","intersectsIDL","dot","UNIT_X","_boundingVolume","intersectPlane","ORIGIN_ZX_PLANE","INTERSECTING","segmentLengths","_segments","lengths","scratchWritePosition","scratchWritePrevPosition","scratchWriteNextPosition","scratchWriteVector","scratchPickColorCartesian","scratchWidthShowCartesian","maxLon","ellipsoid","maximumRadius","PI","width","show","polylineBatchIndex","segments","getSegments","positions","positionsLength","pickColor","getPickId","color","segmentIndex","position","j","_loop","subtract","segmentLength","segmentStart","segmentEnd","Math","abs","startK","endK","writeElements","direction","colorCartesian","floatToByte","red","green","blue","w","alpha","widthShowCartesian","morphPositionScratch","morphPrevPositionScratch","morphNextPositionScratch","morphVectorScratch","prevPosition","multiplyByPoint","nextPosition","scratchSegmentLengths","Array","vaCount","indicesCount","numberOfSegments","segmentIndexCount","getPolylineStartIndex","scratchSegments","scratchLengths","pscratch","scratchCartographic","newPositions","project","cartesianToCartographic","fromPoints","center2D","scratchPositionsArray","positionBuffer","positionsArrayLength","buffer","startJ","endJ","copyFromArrayView"],"mappings":"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","sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Plane from \"../Core/Plane.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport PolylineCommon from \"../Shaders/PolylineCommon.js\";\nimport PolylineFS from \"../Shaders/PolylineFS.js\";\nimport PolylineVS from \"../Shaders/PolylineVS.js\";\nimport BatchTable from \"./BatchTable.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Material from \"./Material.js\";\nimport Polyline from \"./Polyline.js\";\nimport SceneMode from \"./SceneMode.js\";\n\nvar SHOW_INDEX = Polyline.SHOW_INDEX;\nvar WIDTH_INDEX = Polyline.WIDTH_INDEX;\nvar POSITION_INDEX = Polyline.POSITION_INDEX;\nvar MATERIAL_INDEX = Polyline.MATERIAL_INDEX;\n//POSITION_SIZE_INDEX is needed for when the polyline's position array changes size.\n//When it does, we need to recreate the indicesBuffer.\nvar POSITION_SIZE_INDEX = Polyline.POSITION_SIZE_INDEX;\nvar DISTANCE_DISPLAY_CONDITION = Polyline.DISTANCE_DISPLAY_CONDITION;\nvar NUMBER_OF_PROPERTIES = Polyline.NUMBER_OF_PROPERTIES;\n\nvar attributeLocations = {\n  texCoordExpandAndBatchIndex: 0,\n  position3DHigh: 1,\n  position3DLow: 2,\n  position2DHigh: 3,\n  position2DLow: 4,\n  prevPosition3DHigh: 5,\n  prevPosition3DLow: 6,\n  prevPosition2DHigh: 7,\n  prevPosition2DLow: 8,\n  nextPosition3DHigh: 9,\n  nextPosition3DLow: 10,\n  nextPosition2DHigh: 11,\n  nextPosition2DLow: 12,\n};\n\n/**\n * A renderable collection of polylines.\n * <br /><br />\n * <div align=\"center\">\n * <img src=\"Images/Polyline.png\" width=\"400\" height=\"300\" /><br />\n * Example polylines\n * </div>\n * <br /><br />\n * Polylines are added and removed from the collection using {@link PolylineCollection#add}\n * and {@link PolylineCollection#remove}.\n *\n * @alias PolylineCollection\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each polyline from model to world coordinates.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n *\n * @performance For best performance, prefer a few collections, each with many polylines, to\n * many collections with only a few polylines each.  Organize collections so that polylines\n * with the same update frequency are in the same collection, i.e., polylines that do not\n * change should be in one collection; polylines that change every frame should be in another\n * collection; and so on.\n *\n * @see PolylineCollection#add\n * @see PolylineCollection#remove\n * @see Polyline\n * @see LabelCollection\n *\n * @example\n * // Create a polyline collection with two polylines\n * var polylines = new Cesium.PolylineCollection();\n * polylines.add({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -75.10, 39.57,\n *     -77.02, 38.53,\n *     -80.50, 35.14,\n *     -80.12, 25.46]),\n *   width : 2\n * });\n *\n * polylines.add({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -73.10, 37.57,\n *     -75.02, 36.53,\n *     -78.50, 33.14,\n *     -78.12, 23.46]),\n *   width : 4\n * });\n */\nfunction PolylineCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The 4x4 transformation matrix that transforms each polyline in this collection from model to world coordinates.\n   * When this is the identity matrix, the polylines are drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type {Matrix4}\n   * @default {@link Matrix4.IDENTITY}\n   */\n  this.modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY)\n  );\n  this._modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false\n  );\n\n  this._opaqueRS = undefined;\n  this._translucentRS = undefined;\n\n  this._colorCommands = [];\n\n  this._polylinesUpdated = false;\n  this._polylinesRemoved = false;\n  this._createVertexArray = false;\n  this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);\n  this._polylines = [];\n  this._polylineBuckets = {};\n\n  // The buffer usage is determined based on the usage of the attribute over time.\n  this._positionBufferUsage = {\n    bufferUsage: BufferUsage.STATIC_DRAW,\n    frameCount: 0,\n  };\n\n  this._mode = undefined;\n\n  this._polylinesToUpdate = [];\n  this._vertexArrays = [];\n  this._positionBuffer = undefined;\n  this._texCoordExpandAndBatchIndexBuffer = undefined;\n\n  this._batchTable = undefined;\n  this._createBatchTable = false;\n\n  // Only used by Vector3DTilePoints\n  this._useHighlightColor = false;\n  this._highlightColor = Color.clone(Color.WHITE);\n\n  var that = this;\n  this._uniformMap = {\n    u_highlightColor: function () {\n      return that._highlightColor;\n    },\n  };\n}\n\nObject.defineProperties(PolylineCollection.prototype, {\n  /**\n   * Returns the number of polylines in this collection.  This is commonly used with\n   * {@link PolylineCollection#get} to iterate over all the polylines\n   * in the collection.\n   * @memberof PolylineCollection.prototype\n   * @type {Number}\n   */\n  length: {\n    get: function () {\n      removePolylines(this);\n      return this._polylines.length;\n    },\n  },\n});\n\n/**\n     * Creates and adds a polyline with the specified initial properties to the collection.\n     * The added polyline is returned so it can be modified or removed from the collection later.\n     *\n     * @param {Object}[options] A template describing the polyline's properties as shown in Example 1.\n     * @returns {Polyline} The polyline that was added to the collection.\n     *\n     * @performance After calling <code>add</code>, {@link PolylineCollection#update} is called and\n     * the collection's vertex buffer is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.\n     * For best performance, add as many polylines as possible before calling <code>update</code>.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     *\n     *\n     * @example\n     * // Example 1:  Add a polyline, specifying all the default values.\n     * var p = polylines.add({\n     *   show : true,\n     *   positions : ellipsoid.cartographicArrayToCartesianArray([\n           Cesium.Cartographic.fromDegrees(-75.10, 39.57),\n           Cesium.Cartographic.fromDegrees(-77.02, 38.53)]),\n     *   width : 1\n     * });\n     *\n     * @see PolylineCollection#remove\n     * @see PolylineCollection#removeAll\n     * @see PolylineCollection#update\n     */\nPolylineCollection.prototype.add = function (options) {\n  var p = new Polyline(options, this);\n  p._index = this._polylines.length;\n  this._polylines.push(p);\n  this._createVertexArray = true;\n  this._createBatchTable = true;\n  return p;\n};\n\n/**\n * Removes a polyline from the collection.\n *\n * @param {Polyline} polyline The polyline to remove.\n * @returns {Boolean} <code>true</code> if the polyline was removed; <code>false</code> if the polyline was not found in the collection.\n *\n * @performance After calling <code>remove</code>, {@link PolylineCollection#update} is called and\n * the collection's vertex buffer is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.\n * For best performance, remove as many polylines as possible before calling <code>update</code>.\n * If you intend to temporarily hide a polyline, it is usually more efficient to call\n * {@link Polyline#show} instead of removing and re-adding the polyline.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * var p = polylines.add(...);\n * polylines.remove(p);  // Returns true\n *\n * @see PolylineCollection#add\n * @see PolylineCollection#removeAll\n * @see PolylineCollection#update\n * @see Polyline#show\n */\nPolylineCollection.prototype.remove = function (polyline) {\n  if (this.contains(polyline)) {\n    this._polylinesRemoved = true;\n    this._createVertexArray = true;\n    this._createBatchTable = true;\n    if (defined(polyline._bucket)) {\n      var bucket = polyline._bucket;\n      bucket.shaderProgram =\n        bucket.shaderProgram && bucket.shaderProgram.destroy();\n    }\n    polyline._destroy();\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Removes all polylines from the collection.\n *\n * @performance <code>O(n)</code>.  It is more efficient to remove all the polylines\n * from a collection and then add new ones than to create a new collection entirely.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * polylines.add(...);\n * polylines.add(...);\n * polylines.removeAll();\n *\n * @see PolylineCollection#add\n * @see PolylineCollection#remove\n * @see PolylineCollection#update\n */\nPolylineCollection.prototype.removeAll = function () {\n  releaseShaders(this);\n  destroyPolylines(this);\n  this._polylineBuckets = {};\n  this._polylinesRemoved = false;\n  this._polylines.length = 0;\n  this._polylinesToUpdate.length = 0;\n  this._createVertexArray = true;\n};\n\n/**\n * Determines if this collection contains the specified polyline.\n *\n * @param {Polyline} polyline The polyline to check for.\n * @returns {Boolean} true if this collection contains the polyline, false otherwise.\n *\n * @see PolylineCollection#get\n */\nPolylineCollection.prototype.contains = function (polyline) {\n  return defined(polyline) && polyline._polylineCollection === this;\n};\n\n/**\n * Returns the polyline in the collection at the specified index.  Indices are zero-based\n * and increase as polylines are added.  Removing a polyline shifts all polylines after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link PolylineCollection#length} to iterate over all the polylines\n * in the collection.\n *\n * @param {Number} index The zero-based index of the polyline.\n * @returns {Polyline} The polyline at the specified index.\n *\n * @performance If polylines were removed from the collection and\n * {@link PolylineCollection#update} was not called, an implicit <code>O(n)</code>\n * operation is performed.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * // Toggle the show property of every polyline in the collection\n * var len = polylines.length;\n * for (var i = 0; i < len; ++i) {\n *   var p = polylines.get(i);\n *   p.show = !p.show;\n * }\n *\n * @see PolylineCollection#length\n */\nPolylineCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  }\n  //>>includeEnd('debug');\n\n  removePolylines(this);\n  return this._polylines[index];\n};\n\nfunction createBatchTable(collection, context) {\n  if (defined(collection._batchTable)) {\n    collection._batchTable.destroy();\n  }\n\n  var attributes = [\n    {\n      functionName: \"batchTable_getWidthAndShow\",\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 2,\n    },\n    {\n      functionName: \"batchTable_getPickColor\",\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 4,\n      normalize: true,\n    },\n    {\n      functionName: \"batchTable_getCenterHigh\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n    },\n    {\n      functionName: \"batchTable_getCenterLowAndRadius\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 4,\n    },\n    {\n      functionName: \"batchTable_getDistanceDisplayCondition\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n    },\n  ];\n\n  collection._batchTable = new BatchTable(\n    context,\n    attributes,\n    collection._polylines.length\n  );\n}\n\nvar scratchUpdatePolylineEncodedCartesian = new EncodedCartesian3();\nvar scratchUpdatePolylineCartesian4 = new Cartesian4();\nvar scratchNearFarCartesian2 = new Cartesian2();\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {RuntimeError} Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.\n */\nPolylineCollection.prototype.update = function (frameState) {\n  removePolylines(this);\n\n  if (this._polylines.length === 0) {\n    return;\n  }\n\n  updateMode(this, frameState);\n\n  var context = frameState.context;\n  var projection = frameState.mapProjection;\n  var polyline;\n  var properties = this._propertiesChanged;\n\n  if (this._createBatchTable) {\n    if (ContextLimits.maximumVertexTextureImageUnits === 0) {\n      throw new RuntimeError(\n        \"Vertex texture fetch support is required to render polylines. The maximum number of vertex texture image units must be greater than zero.\"\n      );\n    }\n    createBatchTable(this, context);\n    this._createBatchTable = false;\n  }\n\n  if (this._createVertexArray || computeNewBuffersUsage(this)) {\n    createVertexArrays(this, context, projection);\n  } else if (this._polylinesUpdated) {\n    // Polylines were modified, but no polylines were added or removed.\n    var polylinesToUpdate = this._polylinesToUpdate;\n    if (this._mode !== SceneMode.SCENE3D) {\n      var updateLength = polylinesToUpdate.length;\n      for (var i = 0; i < updateLength; ++i) {\n        polyline = polylinesToUpdate[i];\n        polyline.update();\n      }\n    }\n\n    // if a polyline's positions size changes, we need to recreate the vertex arrays and vertex buffers because the indices will be different.\n    // if a polyline's material changes, we need to recreate the VAOs and VBOs because they will be batched differently.\n    if (properties[POSITION_SIZE_INDEX] || properties[MATERIAL_INDEX]) {\n      createVertexArrays(this, context, projection);\n    } else {\n      var length = polylinesToUpdate.length;\n      var polylineBuckets = this._polylineBuckets;\n      for (var ii = 0; ii < length; ++ii) {\n        polyline = polylinesToUpdate[ii];\n        properties = polyline._propertiesChanged;\n        var bucket = polyline._bucket;\n        var index = 0;\n        for (var x in polylineBuckets) {\n          if (polylineBuckets.hasOwnProperty(x)) {\n            if (polylineBuckets[x] === bucket) {\n              if (properties[POSITION_INDEX]) {\n                bucket.writeUpdate(\n                  index,\n                  polyline,\n                  this._positionBuffer,\n                  projection\n                );\n              }\n              break;\n            }\n            index += polylineBuckets[x].lengthOfPositions;\n          }\n        }\n\n        if (properties[SHOW_INDEX] || properties[WIDTH_INDEX]) {\n          this._batchTable.setBatchedAttribute(\n            polyline._index,\n            0,\n            new Cartesian2(polyline._width, polyline._show)\n          );\n        }\n\n        if (this._batchTable.attributes.length > 2) {\n          if (properties[POSITION_INDEX] || properties[POSITION_SIZE_INDEX]) {\n            var boundingSphere =\n              frameState.mode === SceneMode.SCENE2D\n                ? polyline._boundingVolume2D\n                : polyline._boundingVolumeWC;\n            var encodedCenter = EncodedCartesian3.fromCartesian(\n              boundingSphere.center,\n              scratchUpdatePolylineEncodedCartesian\n            );\n            var low = Cartesian4.fromElements(\n              encodedCenter.low.x,\n              encodedCenter.low.y,\n              encodedCenter.low.z,\n              boundingSphere.radius,\n              scratchUpdatePolylineCartesian4\n            );\n            this._batchTable.setBatchedAttribute(\n              polyline._index,\n              2,\n              encodedCenter.high\n            );\n            this._batchTable.setBatchedAttribute(polyline._index, 3, low);\n          }\n\n          if (properties[DISTANCE_DISPLAY_CONDITION]) {\n            var nearFarCartesian = scratchNearFarCartesian2;\n            nearFarCartesian.x = 0.0;\n            nearFarCartesian.y = Number.MAX_VALUE;\n\n            var distanceDisplayCondition = polyline.distanceDisplayCondition;\n            if (defined(distanceDisplayCondition)) {\n              nearFarCartesian.x = distanceDisplayCondition.near;\n              nearFarCartesian.y = distanceDisplayCondition.far;\n            }\n\n            this._batchTable.setBatchedAttribute(\n              polyline._index,\n              4,\n              nearFarCartesian\n            );\n          }\n        }\n\n        polyline._clean();\n      }\n    }\n    polylinesToUpdate.length = 0;\n    this._polylinesUpdated = false;\n  }\n\n  properties = this._propertiesChanged;\n  for (var k = 0; k < NUMBER_OF_PROPERTIES; ++k) {\n    properties[k] = 0;\n  }\n\n  var modelMatrix = Matrix4.IDENTITY;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    modelMatrix = this.modelMatrix;\n  }\n\n  var pass = frameState.passes;\n  var useDepthTest = frameState.morphTime !== 0.0;\n\n  if (\n    !defined(this._opaqueRS) ||\n    this._opaqueRS.depthTest.enabled !== useDepthTest\n  ) {\n    this._opaqueRS = RenderState.fromCache({\n      depthMask: useDepthTest,\n      depthTest: {\n        enabled: useDepthTest,\n      },\n    });\n  }\n\n  if (\n    !defined(this._translucentRS) ||\n    this._translucentRS.depthTest.enabled !== useDepthTest\n  ) {\n    this._translucentRS = RenderState.fromCache({\n      blending: BlendingState.ALPHA_BLEND,\n      depthMask: !useDepthTest,\n      depthTest: {\n        enabled: useDepthTest,\n      },\n    });\n  }\n\n  this._batchTable.update(frameState);\n\n  if (pass.render || pass.pick) {\n    var colorList = this._colorCommands;\n    createCommandLists(this, frameState, colorList, modelMatrix);\n  }\n};\n\nvar boundingSphereScratch = new BoundingSphere();\nvar boundingSphereScratch2 = new BoundingSphere();\n\nfunction createCommandLists(\n  polylineCollection,\n  frameState,\n  commands,\n  modelMatrix\n) {\n  var context = frameState.context;\n  var commandList = frameState.commandList;\n\n  var commandsLength = commands.length;\n  var commandIndex = 0;\n  var cloneBoundingSphere = true;\n\n  var vertexArrays = polylineCollection._vertexArrays;\n  var debugShowBoundingVolume = polylineCollection.debugShowBoundingVolume;\n\n  var batchTable = polylineCollection._batchTable;\n  var uniformCallback = batchTable.getUniformMapCallback();\n\n  var length = vertexArrays.length;\n  for (var m = 0; m < length; ++m) {\n    var va = vertexArrays[m];\n    var buckets = va.buckets;\n    var bucketLength = buckets.length;\n\n    for (var n = 0; n < bucketLength; ++n) {\n      var bucketLocator = buckets[n];\n\n      var offset = bucketLocator.offset;\n      var sp = bucketLocator.bucket.shaderProgram;\n\n      var polylines = bucketLocator.bucket.polylines;\n      var polylineLength = polylines.length;\n      var currentId;\n      var currentMaterial;\n      var count = 0;\n      var command;\n      var uniformMap;\n\n      for (var s = 0; s < polylineLength; ++s) {\n        var polyline = polylines[s];\n        var mId = createMaterialId(polyline._material);\n        if (mId !== currentId) {\n          if (defined(currentId) && count > 0) {\n            var translucent = currentMaterial.isTranslucent();\n\n            if (commandIndex >= commandsLength) {\n              command = new DrawCommand({\n                owner: polylineCollection,\n              });\n              commands.push(command);\n            } else {\n              command = commands[commandIndex];\n            }\n\n            ++commandIndex;\n\n            uniformMap = combine(\n              uniformCallback(currentMaterial._uniforms),\n              polylineCollection._uniformMap\n            );\n\n            command.boundingVolume = BoundingSphere.clone(\n              boundingSphereScratch,\n              command.boundingVolume\n            );\n            command.modelMatrix = modelMatrix;\n            command.shaderProgram = sp;\n            command.vertexArray = va.va;\n            command.renderState = translucent\n              ? polylineCollection._translucentRS\n              : polylineCollection._opaqueRS;\n            command.pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;\n            command.debugShowBoundingVolume = debugShowBoundingVolume;\n            command.pickId = \"v_pickColor\";\n\n            command.uniformMap = uniformMap;\n            command.count = count;\n            command.offset = offset;\n\n            offset += count;\n            count = 0;\n            cloneBoundingSphere = true;\n\n            commandList.push(command);\n          }\n\n          currentMaterial = polyline._material;\n          currentMaterial.update(context);\n          currentId = mId;\n        }\n\n        var locators = polyline._locatorBuckets;\n        var locatorLength = locators.length;\n        for (var t = 0; t < locatorLength; ++t) {\n          var locator = locators[t];\n          if (locator.locator === bucketLocator) {\n            count += locator.count;\n          }\n        }\n\n        var boundingVolume;\n        if (frameState.mode === SceneMode.SCENE3D) {\n          boundingVolume = polyline._boundingVolumeWC;\n        } else if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n          boundingVolume = polyline._boundingVolume2D;\n        } else if (frameState.mode === SceneMode.SCENE2D) {\n          if (defined(polyline._boundingVolume2D)) {\n            boundingVolume = BoundingSphere.clone(\n              polyline._boundingVolume2D,\n              boundingSphereScratch2\n            );\n            boundingVolume.center.x = 0.0;\n          }\n        } else if (\n          defined(polyline._boundingVolumeWC) &&\n          defined(polyline._boundingVolume2D)\n        ) {\n          boundingVolume = BoundingSphere.union(\n            polyline._boundingVolumeWC,\n            polyline._boundingVolume2D,\n            boundingSphereScratch2\n          );\n        }\n\n        if (cloneBoundingSphere) {\n          cloneBoundingSphere = false;\n          BoundingSphere.clone(boundingVolume, boundingSphereScratch);\n        } else {\n          BoundingSphere.union(\n            boundingVolume,\n            boundingSphereScratch,\n            boundingSphereScratch\n          );\n        }\n      }\n\n      if (defined(currentId) && count > 0) {\n        if (commandIndex >= commandsLength) {\n          command = new DrawCommand({\n            owner: polylineCollection,\n          });\n          commands.push(command);\n        } else {\n          command = commands[commandIndex];\n        }\n\n        ++commandIndex;\n\n        uniformMap = combine(\n          uniformCallback(currentMaterial._uniforms),\n          polylineCollection._uniformMap\n        );\n\n        command.boundingVolume = BoundingSphere.clone(\n          boundingSphereScratch,\n          command.boundingVolume\n        );\n        command.modelMatrix = modelMatrix;\n        command.shaderProgram = sp;\n        command.vertexArray = va.va;\n        command.renderState = currentMaterial.isTranslucent()\n          ? polylineCollection._translucentRS\n          : polylineCollection._opaqueRS;\n        command.pass = currentMaterial.isTranslucent()\n          ? Pass.TRANSLUCENT\n          : Pass.OPAQUE;\n        command.debugShowBoundingVolume = debugShowBoundingVolume;\n        command.pickId = \"v_pickColor\";\n\n        command.uniformMap = uniformMap;\n        command.count = count;\n        command.offset = offset;\n\n        cloneBoundingSphere = true;\n\n        commandList.push(command);\n      }\n\n      currentId = undefined;\n    }\n  }\n\n  commands.length = commandIndex;\n}\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see PolylineCollection#destroy\n */\nPolylineCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * polylines = polylines && polylines.destroy();\n *\n * @see PolylineCollection#isDestroyed\n */\nPolylineCollection.prototype.destroy = function () {\n  destroyVertexArrays(this);\n  releaseShaders(this);\n  destroyPolylines(this);\n  this._batchTable = this._batchTable && this._batchTable.destroy();\n  return destroyObject(this);\n};\n\nfunction computeNewBuffersUsage(collection) {\n  var usageChanged = false;\n  var properties = collection._propertiesChanged;\n  var bufferUsage = collection._positionBufferUsage;\n  if (properties[POSITION_INDEX]) {\n    if (bufferUsage.bufferUsage !== BufferUsage.STREAM_DRAW) {\n      usageChanged = true;\n      bufferUsage.bufferUsage = BufferUsage.STREAM_DRAW;\n      bufferUsage.frameCount = 100;\n    } else {\n      bufferUsage.frameCount = 100;\n    }\n  } else if (bufferUsage.bufferUsage !== BufferUsage.STATIC_DRAW) {\n    if (bufferUsage.frameCount === 0) {\n      usageChanged = true;\n      bufferUsage.bufferUsage = BufferUsage.STATIC_DRAW;\n    } else {\n      bufferUsage.frameCount--;\n    }\n  }\n\n  return usageChanged;\n}\n\nvar emptyVertexBuffer = [0.0, 0.0, 0.0];\n\nfunction createVertexArrays(collection, context, projection) {\n  collection._createVertexArray = false;\n  releaseShaders(collection);\n  destroyVertexArrays(collection);\n  sortPolylinesIntoBuckets(collection);\n\n  //stores all of the individual indices arrays.\n  var totalIndices = [[]];\n  var indices = totalIndices[0];\n\n  var batchTable = collection._batchTable;\n  var useHighlightColor = collection._useHighlightColor;\n\n  //used to determine the vertexBuffer offset if the indicesArray goes over 64k.\n  //if it's the same polyline while it goes over 64k, the offset needs to backtrack componentsPerAttribute * componentDatatype bytes\n  //so that the polyline looks contiguous.\n  //if the polyline ends at the 64k mark, then the offset is just 64k * componentsPerAttribute * componentDatatype\n  var vertexBufferOffset = [0];\n  var offset = 0;\n  var vertexArrayBuckets = [[]];\n  var totalLength = 0;\n  var polylineBuckets = collection._polylineBuckets;\n  var x;\n  var bucket;\n  for (x in polylineBuckets) {\n    if (polylineBuckets.hasOwnProperty(x)) {\n      bucket = polylineBuckets[x];\n      bucket.updateShader(context, batchTable, useHighlightColor);\n      totalLength += bucket.lengthOfPositions;\n    }\n  }\n\n  if (totalLength > 0) {\n    var mode = collection._mode;\n\n    var positionArray = new Float32Array(6 * totalLength * 3);\n    var texCoordExpandAndBatchIndexArray = new Float32Array(totalLength * 4);\n    var position3DArray;\n\n    var positionIndex = 0;\n    var colorIndex = 0;\n    var texCoordExpandAndBatchIndexIndex = 0;\n    for (x in polylineBuckets) {\n      if (polylineBuckets.hasOwnProperty(x)) {\n        bucket = polylineBuckets[x];\n        bucket.write(\n          positionArray,\n          texCoordExpandAndBatchIndexArray,\n          positionIndex,\n          colorIndex,\n          texCoordExpandAndBatchIndexIndex,\n          batchTable,\n          context,\n          projection\n        );\n\n        if (mode === SceneMode.MORPHING) {\n          if (!defined(position3DArray)) {\n            position3DArray = new Float32Array(6 * totalLength * 3);\n          }\n          bucket.writeForMorph(position3DArray, positionIndex);\n        }\n\n        var bucketLength = bucket.lengthOfPositions;\n        positionIndex += 6 * bucketLength * 3;\n        colorIndex += bucketLength * 4;\n        texCoordExpandAndBatchIndexIndex += bucketLength * 4;\n        offset = bucket.updateIndices(\n          totalIndices,\n          vertexBufferOffset,\n          vertexArrayBuckets,\n          offset\n        );\n      }\n    }\n\n    var positionBufferUsage = collection._positionBufferUsage.bufferUsage;\n    var texCoordExpandAndBatchIndexBufferUsage = BufferUsage.STATIC_DRAW;\n\n    collection._positionBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: positionArray,\n      usage: positionBufferUsage,\n    });\n    var position3DBuffer;\n    if (defined(position3DArray)) {\n      position3DBuffer = Buffer.createVertexBuffer({\n        context: context,\n        typedArray: position3DArray,\n        usage: positionBufferUsage,\n      });\n    }\n    collection._texCoordExpandAndBatchIndexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: texCoordExpandAndBatchIndexArray,\n      usage: texCoordExpandAndBatchIndexBufferUsage,\n    });\n\n    var positionSizeInBytes = 3 * Float32Array.BYTES_PER_ELEMENT;\n    var texCoordExpandAndBatchIndexSizeInBytes =\n      4 * Float32Array.BYTES_PER_ELEMENT;\n\n    var vbo = 0;\n    var numberOfIndicesArrays = totalIndices.length;\n    for (var k = 0; k < numberOfIndicesArrays; ++k) {\n      indices = totalIndices[k];\n\n      if (indices.length > 0) {\n        var indicesArray = new Uint16Array(indices);\n        var indexBuffer = Buffer.createIndexBuffer({\n          context: context,\n          typedArray: indicesArray,\n          usage: BufferUsage.STATIC_DRAW,\n          indexDatatype: IndexDatatype.UNSIGNED_SHORT,\n        });\n\n        vbo += vertexBufferOffset[k];\n\n        var positionHighOffset =\n          6 *\n          (k * (positionSizeInBytes * CesiumMath.SIXTY_FOUR_KILOBYTES) -\n            vbo * positionSizeInBytes); //componentsPerAttribute(3) * componentDatatype(4)\n        var positionLowOffset = positionSizeInBytes + positionHighOffset;\n        var prevPositionHighOffset = positionSizeInBytes + positionLowOffset;\n        var prevPositionLowOffset =\n          positionSizeInBytes + prevPositionHighOffset;\n        var nextPositionHighOffset =\n          positionSizeInBytes + prevPositionLowOffset;\n        var nextPositionLowOffset =\n          positionSizeInBytes + nextPositionHighOffset;\n        var vertexTexCoordExpandAndBatchIndexBufferOffset =\n          k *\n            (texCoordExpandAndBatchIndexSizeInBytes *\n              CesiumMath.SIXTY_FOUR_KILOBYTES) -\n          vbo * texCoordExpandAndBatchIndexSizeInBytes;\n\n        var attributes = [\n          {\n            index: attributeLocations.position3DHigh,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: positionHighOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.position3DLow,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: positionLowOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.position2DHigh,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: positionHighOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.position2DLow,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: positionLowOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.prevPosition3DHigh,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: prevPositionHighOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.prevPosition3DLow,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: prevPositionLowOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.prevPosition2DHigh,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: prevPositionHighOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.prevPosition2DLow,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: prevPositionLowOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.nextPosition3DHigh,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: nextPositionHighOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.nextPosition3DLow,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: nextPositionLowOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.nextPosition2DHigh,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: nextPositionHighOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.nextPosition2DLow,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: nextPositionLowOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.texCoordExpandAndBatchIndex,\n            componentsPerAttribute: 4,\n            componentDatatype: ComponentDatatype.FLOAT,\n            vertexBuffer: collection._texCoordExpandAndBatchIndexBuffer,\n            offsetInBytes: vertexTexCoordExpandAndBatchIndexBufferOffset,\n          },\n        ];\n\n        var buffer3D;\n        var bufferProperty3D;\n        var buffer2D;\n        var bufferProperty2D;\n\n        if (mode === SceneMode.SCENE3D) {\n          buffer3D = collection._positionBuffer;\n          bufferProperty3D = \"vertexBuffer\";\n          buffer2D = emptyVertexBuffer;\n          bufferProperty2D = \"value\";\n        } else if (\n          mode === SceneMode.SCENE2D ||\n          mode === SceneMode.COLUMBUS_VIEW\n        ) {\n          buffer3D = emptyVertexBuffer;\n          bufferProperty3D = \"value\";\n          buffer2D = collection._positionBuffer;\n          bufferProperty2D = \"vertexBuffer\";\n        } else {\n          buffer3D = position3DBuffer;\n          bufferProperty3D = \"vertexBuffer\";\n          buffer2D = collection._positionBuffer;\n          bufferProperty2D = \"vertexBuffer\";\n        }\n\n        attributes[0][bufferProperty3D] = buffer3D;\n        attributes[1][bufferProperty3D] = buffer3D;\n        attributes[2][bufferProperty2D] = buffer2D;\n        attributes[3][bufferProperty2D] = buffer2D;\n        attributes[4][bufferProperty3D] = buffer3D;\n        attributes[5][bufferProperty3D] = buffer3D;\n        attributes[6][bufferProperty2D] = buffer2D;\n        attributes[7][bufferProperty2D] = buffer2D;\n        attributes[8][bufferProperty3D] = buffer3D;\n        attributes[9][bufferProperty3D] = buffer3D;\n        attributes[10][bufferProperty2D] = buffer2D;\n        attributes[11][bufferProperty2D] = buffer2D;\n\n        var va = new VertexArray({\n          context: context,\n          attributes: attributes,\n          indexBuffer: indexBuffer,\n        });\n        collection._vertexArrays.push({\n          va: va,\n          buckets: vertexArrayBuckets[k],\n        });\n      }\n    }\n  }\n}\n\nfunction replacer(key, value) {\n  if (value instanceof Texture) {\n    return value.id;\n  }\n\n  return value;\n}\n\nvar scratchUniformArray = [];\nfunction createMaterialId(material) {\n  var uniforms = Material._uniformList[material.type];\n  var length = uniforms.length;\n  scratchUniformArray.length = 2.0 * length;\n\n  var index = 0;\n  for (var i = 0; i < length; ++i) {\n    var uniform = uniforms[i];\n    scratchUniformArray[index] = uniform;\n    scratchUniformArray[index + 1] = material._uniforms[uniform]();\n    index += 2;\n  }\n\n  return material.type + \":\" + JSON.stringify(scratchUniformArray, replacer);\n}\n\nfunction sortPolylinesIntoBuckets(collection) {\n  var mode = collection._mode;\n  var modelMatrix = collection._modelMatrix;\n\n  var polylineBuckets = (collection._polylineBuckets = {});\n  var polylines = collection._polylines;\n  var length = polylines.length;\n  for (var i = 0; i < length; ++i) {\n    var p = polylines[i];\n    if (p._actualPositions.length > 1) {\n      p.update();\n      var material = p.material;\n      var value = polylineBuckets[material.type];\n      if (!defined(value)) {\n        value = polylineBuckets[material.type] = new PolylineBucket(\n          material,\n          mode,\n          modelMatrix\n        );\n      }\n      value.addPolyline(p);\n    }\n  }\n}\n\nfunction updateMode(collection, frameState) {\n  var mode = frameState.mode;\n\n  if (\n    collection._mode !== mode ||\n    !Matrix4.equals(collection._modelMatrix, collection.modelMatrix)\n  ) {\n    collection._mode = mode;\n    collection._modelMatrix = Matrix4.clone(collection.modelMatrix);\n    collection._createVertexArray = true;\n  }\n}\n\nfunction removePolylines(collection) {\n  if (collection._polylinesRemoved) {\n    collection._polylinesRemoved = false;\n    var definedPolylines = [];\n    var definedPolylinesToUpdate = [];\n    var polyIndex = 0;\n    var polyline;\n\n    var length = collection._polylines.length;\n    for (var i = 0; i < length; ++i) {\n      polyline = collection._polylines[i];\n      if (!polyline.isDestroyed) {\n        polyline._index = polyIndex++;\n        definedPolylinesToUpdate.push(polyline);\n        definedPolylines.push(polyline);\n      }\n    }\n\n    collection._polylines = definedPolylines;\n    collection._polylinesToUpdate = definedPolylinesToUpdate;\n  }\n}\n\nfunction releaseShaders(collection) {\n  var polylines = collection._polylines;\n  var length = polylines.length;\n  for (var i = 0; i < length; ++i) {\n    if (!polylines[i].isDestroyed) {\n      var bucket = polylines[i]._bucket;\n      if (defined(bucket)) {\n        bucket.shaderProgram =\n          bucket.shaderProgram && bucket.shaderProgram.destroy();\n      }\n    }\n  }\n}\n\nfunction destroyVertexArrays(collection) {\n  var length = collection._vertexArrays.length;\n  for (var t = 0; t < length; ++t) {\n    collection._vertexArrays[t].va.destroy();\n  }\n  collection._vertexArrays.length = 0;\n}\n\nPolylineCollection.prototype._updatePolyline = function (\n  polyline,\n  propertyChanged\n) {\n  this._polylinesUpdated = true;\n  if (!polyline._dirty) {\n    this._polylinesToUpdate.push(polyline);\n  }\n  ++this._propertiesChanged[propertyChanged];\n};\n\nfunction destroyPolylines(collection) {\n  var polylines = collection._polylines;\n  var length = polylines.length;\n  for (var i = 0; i < length; ++i) {\n    if (!polylines[i].isDestroyed) {\n      polylines[i]._destroy();\n    }\n  }\n}\n\nfunction VertexArrayBucketLocator(count, offset, bucket) {\n  this.count = count;\n  this.offset = offset;\n  this.bucket = bucket;\n}\n\nfunction PolylineBucket(material, mode, modelMatrix) {\n  this.polylines = [];\n  this.lengthOfPositions = 0;\n  this.material = material;\n  this.shaderProgram = undefined;\n  this.mode = mode;\n  this.modelMatrix = modelMatrix;\n}\n\nPolylineBucket.prototype.addPolyline = function (p) {\n  var polylines = this.polylines;\n  polylines.push(p);\n  p._actualLength = this.getPolylinePositionsLength(p);\n  this.lengthOfPositions += p._actualLength;\n  p._bucket = this;\n};\n\nPolylineBucket.prototype.updateShader = function (\n  context,\n  batchTable,\n  useHighlightColor\n) {\n  if (defined(this.shaderProgram)) {\n    return;\n  }\n\n  var defines = [\"DISTANCE_DISPLAY_CONDITION\"];\n  if (useHighlightColor) {\n    defines.push(\"VECTOR_TILE\");\n  }\n\n  // Check for use of v_polylineAngle in material shader\n  if (\n    this.material.shaderSource.search(/varying\\s+float\\s+v_polylineAngle;/g) !==\n    -1\n  ) {\n    defines.push(\"POLYLINE_DASH\");\n  }\n\n  if (!FeatureDetection.isInternetExplorer()) {\n    defines.push(\"CLIP_POLYLINE\");\n  }\n\n  var fs = new ShaderSource({\n    defines: defines,\n    sources: [\n      \"varying vec4 v_pickColor;\\n\",\n      this.material.shaderSource,\n      PolylineFS,\n    ],\n  });\n\n  var vsSource = batchTable.getVertexShaderCallback()(PolylineVS);\n  var vs = new ShaderSource({\n    defines: defines,\n    sources: [PolylineCommon, vsSource],\n  });\n\n  this.shaderProgram = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n};\n\nfunction intersectsIDL(polyline) {\n  return (\n    Cartesian3.dot(Cartesian3.UNIT_X, polyline._boundingVolume.center) < 0 ||\n    polyline._boundingVolume.intersectPlane(Plane.ORIGIN_ZX_PLANE) ===\n      Intersect.INTERSECTING\n  );\n}\n\nPolylineBucket.prototype.getPolylinePositionsLength = function (polyline) {\n  var length;\n  if (this.mode === SceneMode.SCENE3D || !intersectsIDL(polyline)) {\n    length = polyline._actualPositions.length;\n    return length * 4.0 - 4.0;\n  }\n\n  var count = 0;\n  var segmentLengths = polyline._segments.lengths;\n  length = segmentLengths.length;\n  for (var i = 0; i < length; ++i) {\n    count += segmentLengths[i] * 4.0 - 4.0;\n  }\n\n  return count;\n};\n\nvar scratchWritePosition = new Cartesian3();\nvar scratchWritePrevPosition = new Cartesian3();\nvar scratchWriteNextPosition = new Cartesian3();\nvar scratchWriteVector = new Cartesian3();\nvar scratchPickColorCartesian = new Cartesian4();\nvar scratchWidthShowCartesian = new Cartesian2();\n\nPolylineBucket.prototype.write = function (\n  positionArray,\n  texCoordExpandAndBatchIndexArray,\n  positionIndex,\n  colorIndex,\n  texCoordExpandAndBatchIndexIndex,\n  batchTable,\n  context,\n  projection\n) {\n  var mode = this.mode;\n  var maxLon = projection.ellipsoid.maximumRadius * CesiumMath.PI;\n\n  var polylines = this.polylines;\n  var length = polylines.length;\n  for (var i = 0; i < length; ++i) {\n    var polyline = polylines[i];\n    var width = polyline.width;\n    var show = polyline.show && width > 0.0;\n    var polylineBatchIndex = polyline._index;\n    var segments = this.getSegments(polyline, projection);\n    var positions = segments.positions;\n    var lengths = segments.lengths;\n    var positionsLength = positions.length;\n\n    var pickColor = polyline.getPickId(context).color;\n\n    var segmentIndex = 0;\n    var count = 0;\n    var position;\n\n    for (var j = 0; j < positionsLength; ++j) {\n      if (j === 0) {\n        if (polyline._loop) {\n          position = positions[positionsLength - 2];\n        } else {\n          position = scratchWriteVector;\n          Cartesian3.subtract(positions[0], positions[1], position);\n          Cartesian3.add(positions[0], position, position);\n        }\n      } else {\n        position = positions[j - 1];\n      }\n\n      Cartesian3.clone(position, scratchWritePrevPosition);\n      Cartesian3.clone(positions[j], scratchWritePosition);\n\n      if (j === positionsLength - 1) {\n        if (polyline._loop) {\n          position = positions[1];\n        } else {\n          position = scratchWriteVector;\n          Cartesian3.subtract(\n            positions[positionsLength - 1],\n            positions[positionsLength - 2],\n            position\n          );\n          Cartesian3.add(positions[positionsLength - 1], position, position);\n        }\n      } else {\n        position = positions[j + 1];\n      }\n\n      Cartesian3.clone(position, scratchWriteNextPosition);\n\n      var segmentLength = lengths[segmentIndex];\n      if (j === count + segmentLength) {\n        count += segmentLength;\n        ++segmentIndex;\n      }\n\n      var segmentStart = j - count === 0;\n      var segmentEnd = j === count + lengths[segmentIndex] - 1;\n\n      if (mode === SceneMode.SCENE2D) {\n        scratchWritePrevPosition.z = 0.0;\n        scratchWritePosition.z = 0.0;\n        scratchWriteNextPosition.z = 0.0;\n      }\n\n      if (mode === SceneMode.SCENE2D || mode === SceneMode.MORPHING) {\n        if (\n          (segmentStart || segmentEnd) &&\n          maxLon - Math.abs(scratchWritePosition.x) < 1.0\n        ) {\n          if (\n            (scratchWritePosition.x < 0.0 &&\n              scratchWritePrevPosition.x > 0.0) ||\n            (scratchWritePosition.x > 0.0 && scratchWritePrevPosition.x < 0.0)\n          ) {\n            Cartesian3.clone(scratchWritePosition, scratchWritePrevPosition);\n          }\n\n          if (\n            (scratchWritePosition.x < 0.0 &&\n              scratchWriteNextPosition.x > 0.0) ||\n            (scratchWritePosition.x > 0.0 && scratchWriteNextPosition.x < 0.0)\n          ) {\n            Cartesian3.clone(scratchWritePosition, scratchWriteNextPosition);\n          }\n        }\n      }\n\n      var startK = segmentStart ? 2 : 0;\n      var endK = segmentEnd ? 2 : 4;\n\n      for (var k = startK; k < endK; ++k) {\n        EncodedCartesian3.writeElements(\n          scratchWritePosition,\n          positionArray,\n          positionIndex\n        );\n        EncodedCartesian3.writeElements(\n          scratchWritePrevPosition,\n          positionArray,\n          positionIndex + 6\n        );\n        EncodedCartesian3.writeElements(\n          scratchWriteNextPosition,\n          positionArray,\n          positionIndex + 12\n        );\n\n        var direction = k - 2 < 0 ? -1.0 : 1.0;\n        texCoordExpandAndBatchIndexArray[texCoordExpandAndBatchIndexIndex] =\n          j / (positionsLength - 1); // s tex coord\n        texCoordExpandAndBatchIndexArray[texCoordExpandAndBatchIndexIndex + 1] =\n          2 * (k % 2) - 1; // expand direction\n        texCoordExpandAndBatchIndexArray[\n          texCoordExpandAndBatchIndexIndex + 2\n        ] = direction;\n        texCoordExpandAndBatchIndexArray[\n          texCoordExpandAndBatchIndexIndex + 3\n        ] = polylineBatchIndex;\n\n        positionIndex += 6 * 3;\n        texCoordExpandAndBatchIndexIndex += 4;\n      }\n    }\n\n    var colorCartesian = scratchPickColorCartesian;\n    colorCartesian.x = Color.floatToByte(pickColor.red);\n    colorCartesian.y = Color.floatToByte(pickColor.green);\n    colorCartesian.z = Color.floatToByte(pickColor.blue);\n    colorCartesian.w = Color.floatToByte(pickColor.alpha);\n\n    var widthShowCartesian = scratchWidthShowCartesian;\n    widthShowCartesian.x = width;\n    widthShowCartesian.y = show ? 1.0 : 0.0;\n\n    var boundingSphere =\n      mode === SceneMode.SCENE2D\n        ? polyline._boundingVolume2D\n        : polyline._boundingVolumeWC;\n    var encodedCenter = EncodedCartesian3.fromCartesian(\n      boundingSphere.center,\n      scratchUpdatePolylineEncodedCartesian\n    );\n    var high = encodedCenter.high;\n    var low = Cartesian4.fromElements(\n      encodedCenter.low.x,\n      encodedCenter.low.y,\n      encodedCenter.low.z,\n      boundingSphere.radius,\n      scratchUpdatePolylineCartesian4\n    );\n\n    var nearFarCartesian = scratchNearFarCartesian2;\n    nearFarCartesian.x = 0.0;\n    nearFarCartesian.y = Number.MAX_VALUE;\n\n    var distanceDisplayCondition = polyline.distanceDisplayCondition;\n    if (defined(distanceDisplayCondition)) {\n      nearFarCartesian.x = distanceDisplayCondition.near;\n      nearFarCartesian.y = distanceDisplayCondition.far;\n    }\n\n    batchTable.setBatchedAttribute(polylineBatchIndex, 0, widthShowCartesian);\n    batchTable.setBatchedAttribute(polylineBatchIndex, 1, colorCartesian);\n\n    if (batchTable.attributes.length > 2) {\n      batchTable.setBatchedAttribute(polylineBatchIndex, 2, high);\n      batchTable.setBatchedAttribute(polylineBatchIndex, 3, low);\n      batchTable.setBatchedAttribute(polylineBatchIndex, 4, nearFarCartesian);\n    }\n  }\n};\n\nvar morphPositionScratch = new Cartesian3();\nvar morphPrevPositionScratch = new Cartesian3();\nvar morphNextPositionScratch = new Cartesian3();\nvar morphVectorScratch = new Cartesian3();\n\nPolylineBucket.prototype.writeForMorph = function (\n  positionArray,\n  positionIndex\n) {\n  var modelMatrix = this.modelMatrix;\n  var polylines = this.polylines;\n  var length = polylines.length;\n  for (var i = 0; i < length; ++i) {\n    var polyline = polylines[i];\n    var positions = polyline._segments.positions;\n    var lengths = polyline._segments.lengths;\n    var positionsLength = positions.length;\n\n    var segmentIndex = 0;\n    var count = 0;\n\n    for (var j = 0; j < positionsLength; ++j) {\n      var prevPosition;\n      if (j === 0) {\n        if (polyline._loop) {\n          prevPosition = positions[positionsLength - 2];\n        } else {\n          prevPosition = morphVectorScratch;\n          Cartesian3.subtract(positions[0], positions[1], prevPosition);\n          Cartesian3.add(positions[0], prevPosition, prevPosition);\n        }\n      } else {\n        prevPosition = positions[j - 1];\n      }\n\n      prevPosition = Matrix4.multiplyByPoint(\n        modelMatrix,\n        prevPosition,\n        morphPrevPositionScratch\n      );\n\n      var position = Matrix4.multiplyByPoint(\n        modelMatrix,\n        positions[j],\n        morphPositionScratch\n      );\n\n      var nextPosition;\n      if (j === positionsLength - 1) {\n        if (polyline._loop) {\n          nextPosition = positions[1];\n        } else {\n          nextPosition = morphVectorScratch;\n          Cartesian3.subtract(\n            positions[positionsLength - 1],\n            positions[positionsLength - 2],\n            nextPosition\n          );\n          Cartesian3.add(\n            positions[positionsLength - 1],\n            nextPosition,\n            nextPosition\n          );\n        }\n      } else {\n        nextPosition = positions[j + 1];\n      }\n\n      nextPosition = Matrix4.multiplyByPoint(\n        modelMatrix,\n        nextPosition,\n        morphNextPositionScratch\n      );\n\n      var segmentLength = lengths[segmentIndex];\n      if (j === count + segmentLength) {\n        count += segmentLength;\n        ++segmentIndex;\n      }\n\n      var segmentStart = j - count === 0;\n      var segmentEnd = j === count + lengths[segmentIndex] - 1;\n\n      var startK = segmentStart ? 2 : 0;\n      var endK = segmentEnd ? 2 : 4;\n\n      for (var k = startK; k < endK; ++k) {\n        EncodedCartesian3.writeElements(position, positionArray, positionIndex);\n        EncodedCartesian3.writeElements(\n          prevPosition,\n          positionArray,\n          positionIndex + 6\n        );\n        EncodedCartesian3.writeElements(\n          nextPosition,\n          positionArray,\n          positionIndex + 12\n        );\n\n        positionIndex += 6 * 3;\n      }\n    }\n  }\n};\n\nvar scratchSegmentLengths = new Array(1);\n\nPolylineBucket.prototype.updateIndices = function (\n  totalIndices,\n  vertexBufferOffset,\n  vertexArrayBuckets,\n  offset\n) {\n  var vaCount = vertexArrayBuckets.length - 1;\n  var bucketLocator = new VertexArrayBucketLocator(0, offset, this);\n  vertexArrayBuckets[vaCount].push(bucketLocator);\n  var count = 0;\n  var indices = totalIndices[totalIndices.length - 1];\n  var indicesCount = 0;\n  if (indices.length > 0) {\n    indicesCount = indices[indices.length - 1] + 1;\n  }\n  var polylines = this.polylines;\n  var length = polylines.length;\n  for (var i = 0; i < length; ++i) {\n    var polyline = polylines[i];\n    polyline._locatorBuckets = [];\n\n    var segments;\n    if (this.mode === SceneMode.SCENE3D) {\n      segments = scratchSegmentLengths;\n      var positionsLength = polyline._actualPositions.length;\n      if (positionsLength > 0) {\n        segments[0] = positionsLength;\n      } else {\n        continue;\n      }\n    } else {\n      segments = polyline._segments.lengths;\n    }\n\n    var numberOfSegments = segments.length;\n    if (numberOfSegments > 0) {\n      var segmentIndexCount = 0;\n      for (var j = 0; j < numberOfSegments; ++j) {\n        var segmentLength = segments[j] - 1.0;\n        for (var k = 0; k < segmentLength; ++k) {\n          if (indicesCount + 4 > CesiumMath.SIXTY_FOUR_KILOBYTES) {\n            polyline._locatorBuckets.push({\n              locator: bucketLocator,\n              count: segmentIndexCount,\n            });\n            segmentIndexCount = 0;\n            vertexBufferOffset.push(4);\n            indices = [];\n            totalIndices.push(indices);\n            indicesCount = 0;\n            bucketLocator.count = count;\n            count = 0;\n            offset = 0;\n            bucketLocator = new VertexArrayBucketLocator(0, 0, this);\n            vertexArrayBuckets[++vaCount] = [bucketLocator];\n          }\n\n          indices.push(indicesCount, indicesCount + 2, indicesCount + 1);\n          indices.push(indicesCount + 1, indicesCount + 2, indicesCount + 3);\n\n          segmentIndexCount += 6;\n          count += 6;\n          offset += 6;\n          indicesCount += 4;\n        }\n      }\n\n      polyline._locatorBuckets.push({\n        locator: bucketLocator,\n        count: segmentIndexCount,\n      });\n\n      if (indicesCount + 4 > CesiumMath.SIXTY_FOUR_KILOBYTES) {\n        vertexBufferOffset.push(0);\n        indices = [];\n        totalIndices.push(indices);\n        indicesCount = 0;\n        bucketLocator.count = count;\n        offset = 0;\n        count = 0;\n        bucketLocator = new VertexArrayBucketLocator(0, 0, this);\n        vertexArrayBuckets[++vaCount] = [bucketLocator];\n      }\n    }\n    polyline._clean();\n  }\n  bucketLocator.count = count;\n  return offset;\n};\n\nPolylineBucket.prototype.getPolylineStartIndex = function (polyline) {\n  var polylines = this.polylines;\n  var positionIndex = 0;\n  var length = polylines.length;\n  for (var i = 0; i < length; ++i) {\n    var p = polylines[i];\n    if (p === polyline) {\n      break;\n    }\n    positionIndex += p._actualLength;\n  }\n  return positionIndex;\n};\n\nvar scratchSegments = {\n  positions: undefined,\n  lengths: undefined,\n};\nvar scratchLengths = new Array(1);\nvar pscratch = new Cartesian3();\nvar scratchCartographic = new Cartographic();\n\nPolylineBucket.prototype.getSegments = function (polyline, projection) {\n  var positions = polyline._actualPositions;\n\n  if (this.mode === SceneMode.SCENE3D) {\n    scratchLengths[0] = positions.length;\n    scratchSegments.positions = positions;\n    scratchSegments.lengths = scratchLengths;\n    return scratchSegments;\n  }\n\n  if (intersectsIDL(polyline)) {\n    positions = polyline._segments.positions;\n  }\n\n  var ellipsoid = projection.ellipsoid;\n  var newPositions = [];\n  var modelMatrix = this.modelMatrix;\n  var length = positions.length;\n  var position;\n  var p = pscratch;\n\n  for (var n = 0; n < length; ++n) {\n    position = positions[n];\n    p = Matrix4.multiplyByPoint(modelMatrix, position, p);\n    newPositions.push(\n      projection.project(\n        ellipsoid.cartesianToCartographic(p, scratchCartographic)\n      )\n    );\n  }\n\n  if (newPositions.length > 0) {\n    polyline._boundingVolume2D = BoundingSphere.fromPoints(\n      newPositions,\n      polyline._boundingVolume2D\n    );\n    var center2D = polyline._boundingVolume2D.center;\n    polyline._boundingVolume2D.center = new Cartesian3(\n      center2D.z,\n      center2D.x,\n      center2D.y\n    );\n  }\n\n  scratchSegments.positions = newPositions;\n  scratchSegments.lengths = polyline._segments.lengths;\n  return scratchSegments;\n};\n\nvar scratchPositionsArray;\n\nPolylineBucket.prototype.writeUpdate = function (\n  index,\n  polyline,\n  positionBuffer,\n  projection\n) {\n  var mode = this.mode;\n  var maxLon = projection.ellipsoid.maximumRadius * CesiumMath.PI;\n\n  var positionsLength = polyline._actualLength;\n  if (positionsLength) {\n    index += this.getPolylineStartIndex(polyline);\n\n    var positionArray = scratchPositionsArray;\n    var positionsArrayLength = 6 * positionsLength * 3;\n\n    if (\n      !defined(positionArray) ||\n      positionArray.length < positionsArrayLength\n    ) {\n      positionArray = scratchPositionsArray = new Float32Array(\n        positionsArrayLength\n      );\n    } else if (positionArray.length > positionsArrayLength) {\n      positionArray = new Float32Array(\n        positionArray.buffer,\n        0,\n        positionsArrayLength\n      );\n    }\n\n    var segments = this.getSegments(polyline, projection);\n    var positions = segments.positions;\n    var lengths = segments.lengths;\n\n    var positionIndex = 0;\n    var segmentIndex = 0;\n    var count = 0;\n    var position;\n\n    positionsLength = positions.length;\n    for (var i = 0; i < positionsLength; ++i) {\n      if (i === 0) {\n        if (polyline._loop) {\n          position = positions[positionsLength - 2];\n        } else {\n          position = scratchWriteVector;\n          Cartesian3.subtract(positions[0], positions[1], position);\n          Cartesian3.add(positions[0], position, position);\n        }\n      } else {\n        position = positions[i - 1];\n      }\n\n      Cartesian3.clone(position, scratchWritePrevPosition);\n      Cartesian3.clone(positions[i], scratchWritePosition);\n\n      if (i === positionsLength - 1) {\n        if (polyline._loop) {\n          position = positions[1];\n        } else {\n          position = scratchWriteVector;\n          Cartesian3.subtract(\n            positions[positionsLength - 1],\n            positions[positionsLength - 2],\n            position\n          );\n          Cartesian3.add(positions[positionsLength - 1], position, position);\n        }\n      } else {\n        position = positions[i + 1];\n      }\n\n      Cartesian3.clone(position, scratchWriteNextPosition);\n\n      var segmentLength = lengths[segmentIndex];\n      if (i === count + segmentLength) {\n        count += segmentLength;\n        ++segmentIndex;\n      }\n\n      var segmentStart = i - count === 0;\n      var segmentEnd = i === count + lengths[segmentIndex] - 1;\n\n      if (mode === SceneMode.SCENE2D) {\n        scratchWritePrevPosition.z = 0.0;\n        scratchWritePosition.z = 0.0;\n        scratchWriteNextPosition.z = 0.0;\n      }\n\n      if (mode === SceneMode.SCENE2D || mode === SceneMode.MORPHING) {\n        if (\n          (segmentStart || segmentEnd) &&\n          maxLon - Math.abs(scratchWritePosition.x) < 1.0\n        ) {\n          if (\n            (scratchWritePosition.x < 0.0 &&\n              scratchWritePrevPosition.x > 0.0) ||\n            (scratchWritePosition.x > 0.0 && scratchWritePrevPosition.x < 0.0)\n          ) {\n            Cartesian3.clone(scratchWritePosition, scratchWritePrevPosition);\n          }\n\n          if (\n            (scratchWritePosition.x < 0.0 &&\n              scratchWriteNextPosition.x > 0.0) ||\n            (scratchWritePosition.x > 0.0 && scratchWriteNextPosition.x < 0.0)\n          ) {\n            Cartesian3.clone(scratchWritePosition, scratchWriteNextPosition);\n          }\n        }\n      }\n\n      var startJ = segmentStart ? 2 : 0;\n      var endJ = segmentEnd ? 2 : 4;\n\n      for (var j = startJ; j < endJ; ++j) {\n        EncodedCartesian3.writeElements(\n          scratchWritePosition,\n          positionArray,\n          positionIndex\n        );\n        EncodedCartesian3.writeElements(\n          scratchWritePrevPosition,\n          positionArray,\n          positionIndex + 6\n        );\n        EncodedCartesian3.writeElements(\n          scratchWriteNextPosition,\n          positionArray,\n          positionIndex + 12\n        );\n        positionIndex += 6 * 3;\n      }\n    }\n\n    positionBuffer.copyFromArrayView(\n      positionArray,\n      6 * 3 * Float32Array.BYTES_PER_ELEMENT * index\n    );\n  }\n};\nexport default PolylineCollection;\n"]},"metadata":{},"sourceType":"module"}