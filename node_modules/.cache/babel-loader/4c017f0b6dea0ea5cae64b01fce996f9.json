{"ast":null,"code":"import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nvar defaultRadii = new Cartesian3(1.0, 1.0, 1.0);\nvar cos = Math.cos;\nvar sin = Math.sin;\n/**\n * A description of the outline of an ellipsoid centered at the origin.\n *\n * @alias EllipsoidOutlineGeometry\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Cartesian3} [options.radii=Cartesian3(1.0, 1.0, 1.0)] The radii of the ellipsoid in the x, y, and z directions.\n * @param {Cartesian3} [options.innerRadii=options.radii] The inner radii of the ellipsoid in the x, y, and z directions.\n * @param {Number} [options.minimumClock=0.0] The minimum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {Number} [options.maximumClock=2*PI] The maximum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {Number} [options.minimumCone=0.0] The minimum angle measured from the positive z-axis and toward the negative z-axis.\n * @param {Number} [options.maximumCone=PI] The maximum angle measured from the positive z-axis and toward the negative z-axis.\n * @param {Number} [options.stackPartitions=10] The count of stacks for the ellipsoid (1 greater than the number of parallel lines).\n * @param {Number} [options.slicePartitions=8] The count of slices for the ellipsoid (Equal to the number of radial lines).\n * @param {Number} [options.subdivisions=128] The number of points per line, determining the granularity of the curvature.\n *\n * @exception {DeveloperError} options.stackPartitions must be greater than or equal to one.\n * @exception {DeveloperError} options.slicePartitions must be greater than or equal to zero.\n * @exception {DeveloperError} options.subdivisions must be greater than or equal to zero.\n *\n * @example\n * var ellipsoid = new Cesium.EllipsoidOutlineGeometry({\n *   radii : new Cesium.Cartesian3(1000000.0, 500000.0, 500000.0),\n *   stackPartitions: 6,\n *   slicePartitions: 5\n * });\n * var geometry = Cesium.EllipsoidOutlineGeometry.createGeometry(ellipsoid);\n */\n\nfunction EllipsoidOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var radii = defaultValue(options.radii, defaultRadii);\n  var innerRadii = defaultValue(options.innerRadii, radii);\n  var minimumClock = defaultValue(options.minimumClock, 0.0);\n  var maximumClock = defaultValue(options.maximumClock, CesiumMath.TWO_PI);\n  var minimumCone = defaultValue(options.minimumCone, 0.0);\n  var maximumCone = defaultValue(options.maximumCone, CesiumMath.PI);\n  var stackPartitions = Math.round(defaultValue(options.stackPartitions, 10));\n  var slicePartitions = Math.round(defaultValue(options.slicePartitions, 8));\n  var subdivisions = Math.round(defaultValue(options.subdivisions, 128)); //>>includeStart('debug', pragmas.debug);\n\n  if (stackPartitions < 1) {\n    throw new DeveloperError(\"options.stackPartitions cannot be less than 1\");\n  }\n\n  if (slicePartitions < 0) {\n    throw new DeveloperError(\"options.slicePartitions cannot be less than 0\");\n  }\n\n  if (subdivisions < 0) {\n    throw new DeveloperError(\"options.subdivisions must be greater than or equal to zero.\");\n  }\n\n  if (defined(options.offsetAttribute) && options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n    throw new DeveloperError(\"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\");\n  } //>>includeEnd('debug');\n\n\n  this._radii = Cartesian3.clone(radii);\n  this._innerRadii = Cartesian3.clone(innerRadii);\n  this._minimumClock = minimumClock;\n  this._maximumClock = maximumClock;\n  this._minimumCone = minimumCone;\n  this._maximumCone = maximumCone;\n  this._stackPartitions = stackPartitions;\n  this._slicePartitions = slicePartitions;\n  this._subdivisions = subdivisions;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createEllipsoidOutlineGeometry\";\n}\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\n\n\nEllipsoidOutlineGeometry.packedLength = 2 * Cartesian3.packedLength + 8;\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipsoidOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\nEllipsoidOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  } //>>includeEnd('debug');\n\n\n  startingIndex = defaultValue(startingIndex, 0);\n  Cartesian3.pack(value._radii, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n  Cartesian3.pack(value._innerRadii, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n  array[startingIndex++] = value._minimumClock;\n  array[startingIndex++] = value._maximumClock;\n  array[startingIndex++] = value._minimumCone;\n  array[startingIndex++] = value._maximumCone;\n  array[startingIndex++] = value._stackPartitions;\n  array[startingIndex++] = value._slicePartitions;\n  array[startingIndex++] = value._subdivisions;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n  return array;\n};\n\nvar scratchRadii = new Cartesian3();\nvar scratchInnerRadii = new Cartesian3();\nvar scratchOptions = {\n  radii: scratchRadii,\n  innerRadii: scratchInnerRadii,\n  minimumClock: undefined,\n  maximumClock: undefined,\n  minimumCone: undefined,\n  maximumCone: undefined,\n  stackPartitions: undefined,\n  slicePartitions: undefined,\n  subdivisions: undefined,\n  offsetAttribute: undefined\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipsoidOutlineGeometry} [result] The object into which to store the result.\n * @returns {EllipsoidOutlineGeometry} The modified result parameter or a new EllipsoidOutlineGeometry instance if one was not provided.\n */\n\nEllipsoidOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  } //>>includeEnd('debug');\n\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var radii = Cartesian3.unpack(array, startingIndex, scratchRadii);\n  startingIndex += Cartesian3.packedLength;\n  var innerRadii = Cartesian3.unpack(array, startingIndex, scratchInnerRadii);\n  startingIndex += Cartesian3.packedLength;\n  var minimumClock = array[startingIndex++];\n  var maximumClock = array[startingIndex++];\n  var minimumCone = array[startingIndex++];\n  var maximumCone = array[startingIndex++];\n  var stackPartitions = array[startingIndex++];\n  var slicePartitions = array[startingIndex++];\n  var subdivisions = array[startingIndex++];\n  var offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.minimumClock = minimumClock;\n    scratchOptions.maximumClock = maximumClock;\n    scratchOptions.minimumCone = minimumCone;\n    scratchOptions.maximumCone = maximumCone;\n    scratchOptions.stackPartitions = stackPartitions;\n    scratchOptions.slicePartitions = slicePartitions;\n    scratchOptions.subdivisions = subdivisions;\n    scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new EllipsoidOutlineGeometry(scratchOptions);\n  }\n\n  result._radii = Cartesian3.clone(radii, result._radii);\n  result._innerRadii = Cartesian3.clone(innerRadii, result._innerRadii);\n  result._minimumClock = minimumClock;\n  result._maximumClock = maximumClock;\n  result._minimumCone = minimumCone;\n  result._maximumCone = maximumCone;\n  result._stackPartitions = stackPartitions;\n  result._slicePartitions = slicePartitions;\n  result._subdivisions = subdivisions;\n  result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n  return result;\n};\n/**\n * Computes the geometric representation of an outline of an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipsoidOutlineGeometry} ellipsoidGeometry A description of the ellipsoid outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\n\n\nEllipsoidOutlineGeometry.createGeometry = function (ellipsoidGeometry) {\n  var radii = ellipsoidGeometry._radii;\n\n  if (radii.x <= 0 || radii.y <= 0 || radii.z <= 0) {\n    return;\n  }\n\n  var innerRadii = ellipsoidGeometry._innerRadii;\n\n  if (innerRadii.x <= 0 || innerRadii.y <= 0 || innerRadii.z <= 0) {\n    return;\n  }\n\n  var minimumClock = ellipsoidGeometry._minimumClock;\n  var maximumClock = ellipsoidGeometry._maximumClock;\n  var minimumCone = ellipsoidGeometry._minimumCone;\n  var maximumCone = ellipsoidGeometry._maximumCone;\n  var subdivisions = ellipsoidGeometry._subdivisions;\n  var ellipsoid = Ellipsoid.fromCartesian3(radii); // Add an extra slice and stack to remain consistent with EllipsoidGeometry\n\n  var slicePartitions = ellipsoidGeometry._slicePartitions + 1;\n  var stackPartitions = ellipsoidGeometry._stackPartitions + 1;\n  slicePartitions = Math.round(slicePartitions * Math.abs(maximumClock - minimumClock) / CesiumMath.TWO_PI);\n  stackPartitions = Math.round(stackPartitions * Math.abs(maximumCone - minimumCone) / CesiumMath.PI);\n\n  if (slicePartitions < 2) {\n    slicePartitions = 2;\n  }\n\n  if (stackPartitions < 2) {\n    stackPartitions = 2;\n  }\n\n  var extraIndices = 0;\n  var vertexMultiplier = 1.0;\n  var hasInnerSurface = innerRadii.x !== radii.x || innerRadii.y !== radii.y || innerRadii.z !== radii.z;\n  var isTopOpen = false;\n  var isBotOpen = false;\n\n  if (hasInnerSurface) {\n    vertexMultiplier = 2.0; // Add 2x slicePartitions to connect the top/bottom of the outer to\n    // the top/bottom of the inner\n\n    if (minimumCone > 0.0) {\n      isTopOpen = true;\n      extraIndices += slicePartitions;\n    }\n\n    if (maximumCone < Math.PI) {\n      isBotOpen = true;\n      extraIndices += slicePartitions;\n    }\n  }\n\n  var vertexCount = subdivisions * vertexMultiplier * (stackPartitions + slicePartitions);\n  var positions = new Float64Array(vertexCount * 3); // Multiply by two because two points define each line segment\n\n  var numIndices = 2 * (vertexCount + extraIndices - (slicePartitions + stackPartitions) * vertexMultiplier);\n  var indices = IndexDatatype.createTypedArray(vertexCount, numIndices);\n  var i;\n  var j;\n  var theta;\n  var phi;\n  var index = 0; // Calculate sin/cos phi\n\n  var sinPhi = new Array(stackPartitions);\n  var cosPhi = new Array(stackPartitions);\n\n  for (i = 0; i < stackPartitions; i++) {\n    phi = minimumCone + i * (maximumCone - minimumCone) / (stackPartitions - 1);\n    sinPhi[i] = sin(phi);\n    cosPhi[i] = cos(phi);\n  } // Calculate sin/cos theta\n\n\n  var sinTheta = new Array(subdivisions);\n  var cosTheta = new Array(subdivisions);\n\n  for (i = 0; i < subdivisions; i++) {\n    theta = minimumClock + i * (maximumClock - minimumClock) / (subdivisions - 1);\n    sinTheta[i] = sin(theta);\n    cosTheta[i] = cos(theta);\n  } // Calculate the latitude lines on the outer surface\n\n\n  for (i = 0; i < stackPartitions; i++) {\n    for (j = 0; j < subdivisions; j++) {\n      positions[index++] = radii.x * sinPhi[i] * cosTheta[j];\n      positions[index++] = radii.y * sinPhi[i] * sinTheta[j];\n      positions[index++] = radii.z * cosPhi[i];\n    }\n  } // Calculate the latitude lines on the inner surface\n\n\n  if (hasInnerSurface) {\n    for (i = 0; i < stackPartitions; i++) {\n      for (j = 0; j < subdivisions; j++) {\n        positions[index++] = innerRadii.x * sinPhi[i] * cosTheta[j];\n        positions[index++] = innerRadii.y * sinPhi[i] * sinTheta[j];\n        positions[index++] = innerRadii.z * cosPhi[i];\n      }\n    }\n  } // Calculate sin/cos phi\n\n\n  sinPhi.length = subdivisions;\n  cosPhi.length = subdivisions;\n\n  for (i = 0; i < subdivisions; i++) {\n    phi = minimumCone + i * (maximumCone - minimumCone) / (subdivisions - 1);\n    sinPhi[i] = sin(phi);\n    cosPhi[i] = cos(phi);\n  } // Calculate sin/cos theta for each slice partition\n\n\n  sinTheta.length = slicePartitions;\n  cosTheta.length = slicePartitions;\n\n  for (i = 0; i < slicePartitions; i++) {\n    theta = minimumClock + i * (maximumClock - minimumClock) / (slicePartitions - 1);\n    sinTheta[i] = sin(theta);\n    cosTheta[i] = cos(theta);\n  } // Calculate the longitude lines on the outer surface\n\n\n  for (i = 0; i < subdivisions; i++) {\n    for (j = 0; j < slicePartitions; j++) {\n      positions[index++] = radii.x * sinPhi[i] * cosTheta[j];\n      positions[index++] = radii.y * sinPhi[i] * sinTheta[j];\n      positions[index++] = radii.z * cosPhi[i];\n    }\n  } // Calculate the longitude lines on the inner surface\n\n\n  if (hasInnerSurface) {\n    for (i = 0; i < subdivisions; i++) {\n      for (j = 0; j < slicePartitions; j++) {\n        positions[index++] = innerRadii.x * sinPhi[i] * cosTheta[j];\n        positions[index++] = innerRadii.y * sinPhi[i] * sinTheta[j];\n        positions[index++] = innerRadii.z * cosPhi[i];\n      }\n    }\n  } // Create indices for the latitude lines\n\n\n  index = 0;\n\n  for (i = 0; i < stackPartitions * vertexMultiplier; i++) {\n    var topOffset = i * subdivisions;\n\n    for (j = 0; j < subdivisions - 1; j++) {\n      indices[index++] = topOffset + j;\n      indices[index++] = topOffset + j + 1;\n    }\n  } // Create indices for the outer longitude lines\n\n\n  var offset = stackPartitions * subdivisions * vertexMultiplier;\n\n  for (i = 0; i < slicePartitions; i++) {\n    for (j = 0; j < subdivisions - 1; j++) {\n      indices[index++] = offset + i + j * slicePartitions;\n      indices[index++] = offset + i + (j + 1) * slicePartitions;\n    }\n  } // Create indices for the inner longitude lines\n\n\n  if (hasInnerSurface) {\n    offset = stackPartitions * subdivisions * vertexMultiplier + slicePartitions * subdivisions;\n\n    for (i = 0; i < slicePartitions; i++) {\n      for (j = 0; j < subdivisions - 1; j++) {\n        indices[index++] = offset + i + j * slicePartitions;\n        indices[index++] = offset + i + (j + 1) * slicePartitions;\n      }\n    }\n  }\n\n  if (hasInnerSurface) {\n    var outerOffset = stackPartitions * subdivisions * vertexMultiplier;\n    var innerOffset = outerOffset + subdivisions * slicePartitions;\n\n    if (isTopOpen) {\n      // Draw lines from the top of the inner surface to the top of the outer surface\n      for (i = 0; i < slicePartitions; i++) {\n        indices[index++] = outerOffset + i;\n        indices[index++] = innerOffset + i;\n      }\n    }\n\n    if (isBotOpen) {\n      // Draw lines from the top of the inner surface to the top of the outer surface\n      outerOffset += subdivisions * slicePartitions - slicePartitions;\n      innerOffset += subdivisions * slicePartitions - slicePartitions;\n\n      for (i = 0; i < slicePartitions; i++) {\n        indices[index++] = outerOffset + i;\n        indices[index++] = innerOffset + i;\n      }\n    }\n  }\n\n  var attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions\n    })\n  });\n\n  if (defined(ellipsoidGeometry._offsetAttribute)) {\n    var length = positions.length;\n    var applyOffset = new Uint8Array(length / 3);\n    var offsetValue = ellipsoidGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n    arrayFill(applyOffset, offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: BoundingSphere.fromEllipsoid(ellipsoid),\n    offsetAttribute: ellipsoidGeometry._offsetAttribute\n  });\n};\n\nexport default EllipsoidOutlineGeometry;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/EllipsoidOutlineGeometry.js"],"names":["arrayFill","BoundingSphere","Cartesian3","ComponentDatatype","defaultValue","defined","DeveloperError","Ellipsoid","Geometry","GeometryAttribute","GeometryAttributes","GeometryOffsetAttribute","IndexDatatype","CesiumMath","PrimitiveType","defaultRadii","cos","Math","sin","EllipsoidOutlineGeometry","options","EMPTY_OBJECT","radii","innerRadii","minimumClock","maximumClock","TWO_PI","minimumCone","maximumCone","PI","stackPartitions","round","slicePartitions","subdivisions","offsetAttribute","TOP","_radii","clone","_innerRadii","_minimumClock","_maximumClock","_minimumCone","_maximumCone","_stackPartitions","_slicePartitions","_subdivisions","_offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","scratchRadii","scratchInnerRadii","scratchOptions","undefined","unpack","result","createGeometry","ellipsoidGeometry","x","y","z","ellipsoid","fromCartesian3","abs","extraIndices","vertexMultiplier","hasInnerSurface","isTopOpen","isBotOpen","vertexCount","positions","Float64Array","numIndices","indices","createTypedArray","i","j","theta","phi","index","sinPhi","Array","cosPhi","sinTheta","cosTheta","length","topOffset","offset","outerOffset","innerOffset","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","applyOffset","Uint8Array","offsetValue","NONE","UNSIGNED_BYTE","primitiveType","LINES","boundingSphere","fromEllipsoid"],"mappings":"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","sourcesContent":["import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nvar defaultRadii = new Cartesian3(1.0, 1.0, 1.0);\nvar cos = Math.cos;\nvar sin = Math.sin;\n\n/**\n * A description of the outline of an ellipsoid centered at the origin.\n *\n * @alias EllipsoidOutlineGeometry\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Cartesian3} [options.radii=Cartesian3(1.0, 1.0, 1.0)] The radii of the ellipsoid in the x, y, and z directions.\n * @param {Cartesian3} [options.innerRadii=options.radii] The inner radii of the ellipsoid in the x, y, and z directions.\n * @param {Number} [options.minimumClock=0.0] The minimum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {Number} [options.maximumClock=2*PI] The maximum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {Number} [options.minimumCone=0.0] The minimum angle measured from the positive z-axis and toward the negative z-axis.\n * @param {Number} [options.maximumCone=PI] The maximum angle measured from the positive z-axis and toward the negative z-axis.\n * @param {Number} [options.stackPartitions=10] The count of stacks for the ellipsoid (1 greater than the number of parallel lines).\n * @param {Number} [options.slicePartitions=8] The count of slices for the ellipsoid (Equal to the number of radial lines).\n * @param {Number} [options.subdivisions=128] The number of points per line, determining the granularity of the curvature.\n *\n * @exception {DeveloperError} options.stackPartitions must be greater than or equal to one.\n * @exception {DeveloperError} options.slicePartitions must be greater than or equal to zero.\n * @exception {DeveloperError} options.subdivisions must be greater than or equal to zero.\n *\n * @example\n * var ellipsoid = new Cesium.EllipsoidOutlineGeometry({\n *   radii : new Cesium.Cartesian3(1000000.0, 500000.0, 500000.0),\n *   stackPartitions: 6,\n *   slicePartitions: 5\n * });\n * var geometry = Cesium.EllipsoidOutlineGeometry.createGeometry(ellipsoid);\n */\nfunction EllipsoidOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var radii = defaultValue(options.radii, defaultRadii);\n  var innerRadii = defaultValue(options.innerRadii, radii);\n  var minimumClock = defaultValue(options.minimumClock, 0.0);\n  var maximumClock = defaultValue(options.maximumClock, CesiumMath.TWO_PI);\n  var minimumCone = defaultValue(options.minimumCone, 0.0);\n  var maximumCone = defaultValue(options.maximumCone, CesiumMath.PI);\n  var stackPartitions = Math.round(defaultValue(options.stackPartitions, 10));\n  var slicePartitions = Math.round(defaultValue(options.slicePartitions, 8));\n  var subdivisions = Math.round(defaultValue(options.subdivisions, 128));\n\n  //>>includeStart('debug', pragmas.debug);\n  if (stackPartitions < 1) {\n    throw new DeveloperError(\"options.stackPartitions cannot be less than 1\");\n  }\n  if (slicePartitions < 0) {\n    throw new DeveloperError(\"options.slicePartitions cannot be less than 0\");\n  }\n  if (subdivisions < 0) {\n    throw new DeveloperError(\n      \"options.subdivisions must be greater than or equal to zero.\"\n    );\n  }\n  if (\n    defined(options.offsetAttribute) &&\n    options.offsetAttribute === GeometryOffsetAttribute.TOP\n  ) {\n    throw new DeveloperError(\n      \"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._radii = Cartesian3.clone(radii);\n  this._innerRadii = Cartesian3.clone(innerRadii);\n  this._minimumClock = minimumClock;\n  this._maximumClock = maximumClock;\n  this._minimumCone = minimumCone;\n  this._maximumCone = maximumCone;\n  this._stackPartitions = stackPartitions;\n  this._slicePartitions = slicePartitions;\n  this._subdivisions = subdivisions;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createEllipsoidOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nEllipsoidOutlineGeometry.packedLength = 2 * Cartesian3.packedLength + 8;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipsoidOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nEllipsoidOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value._radii, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n\n  Cartesian3.pack(value._innerRadii, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n\n  array[startingIndex++] = value._minimumClock;\n  array[startingIndex++] = value._maximumClock;\n  array[startingIndex++] = value._minimumCone;\n  array[startingIndex++] = value._maximumCone;\n  array[startingIndex++] = value._stackPartitions;\n  array[startingIndex++] = value._slicePartitions;\n  array[startingIndex++] = value._subdivisions;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nvar scratchRadii = new Cartesian3();\nvar scratchInnerRadii = new Cartesian3();\nvar scratchOptions = {\n  radii: scratchRadii,\n  innerRadii: scratchInnerRadii,\n  minimumClock: undefined,\n  maximumClock: undefined,\n  minimumCone: undefined,\n  maximumCone: undefined,\n  stackPartitions: undefined,\n  slicePartitions: undefined,\n  subdivisions: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipsoidOutlineGeometry} [result] The object into which to store the result.\n * @returns {EllipsoidOutlineGeometry} The modified result parameter or a new EllipsoidOutlineGeometry instance if one was not provided.\n */\nEllipsoidOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var radii = Cartesian3.unpack(array, startingIndex, scratchRadii);\n  startingIndex += Cartesian3.packedLength;\n\n  var innerRadii = Cartesian3.unpack(array, startingIndex, scratchInnerRadii);\n  startingIndex += Cartesian3.packedLength;\n\n  var minimumClock = array[startingIndex++];\n  var maximumClock = array[startingIndex++];\n  var minimumCone = array[startingIndex++];\n  var maximumCone = array[startingIndex++];\n  var stackPartitions = array[startingIndex++];\n  var slicePartitions = array[startingIndex++];\n  var subdivisions = array[startingIndex++];\n  var offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.minimumClock = minimumClock;\n    scratchOptions.maximumClock = maximumClock;\n    scratchOptions.minimumCone = minimumCone;\n    scratchOptions.maximumCone = maximumCone;\n    scratchOptions.stackPartitions = stackPartitions;\n    scratchOptions.slicePartitions = slicePartitions;\n    scratchOptions.subdivisions = subdivisions;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new EllipsoidOutlineGeometry(scratchOptions);\n  }\n\n  result._radii = Cartesian3.clone(radii, result._radii);\n  result._innerRadii = Cartesian3.clone(innerRadii, result._innerRadii);\n  result._minimumClock = minimumClock;\n  result._maximumClock = maximumClock;\n  result._minimumCone = minimumCone;\n  result._maximumCone = maximumCone;\n  result._stackPartitions = stackPartitions;\n  result._slicePartitions = slicePartitions;\n  result._subdivisions = subdivisions;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipsoidOutlineGeometry} ellipsoidGeometry A description of the ellipsoid outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nEllipsoidOutlineGeometry.createGeometry = function (ellipsoidGeometry) {\n  var radii = ellipsoidGeometry._radii;\n  if (radii.x <= 0 || radii.y <= 0 || radii.z <= 0) {\n    return;\n  }\n\n  var innerRadii = ellipsoidGeometry._innerRadii;\n  if (innerRadii.x <= 0 || innerRadii.y <= 0 || innerRadii.z <= 0) {\n    return;\n  }\n\n  var minimumClock = ellipsoidGeometry._minimumClock;\n  var maximumClock = ellipsoidGeometry._maximumClock;\n  var minimumCone = ellipsoidGeometry._minimumCone;\n  var maximumCone = ellipsoidGeometry._maximumCone;\n  var subdivisions = ellipsoidGeometry._subdivisions;\n  var ellipsoid = Ellipsoid.fromCartesian3(radii);\n\n  // Add an extra slice and stack to remain consistent with EllipsoidGeometry\n  var slicePartitions = ellipsoidGeometry._slicePartitions + 1;\n  var stackPartitions = ellipsoidGeometry._stackPartitions + 1;\n\n  slicePartitions = Math.round(\n    (slicePartitions * Math.abs(maximumClock - minimumClock)) /\n      CesiumMath.TWO_PI\n  );\n  stackPartitions = Math.round(\n    (stackPartitions * Math.abs(maximumCone - minimumCone)) / CesiumMath.PI\n  );\n\n  if (slicePartitions < 2) {\n    slicePartitions = 2;\n  }\n  if (stackPartitions < 2) {\n    stackPartitions = 2;\n  }\n\n  var extraIndices = 0;\n  var vertexMultiplier = 1.0;\n  var hasInnerSurface =\n    innerRadii.x !== radii.x ||\n    innerRadii.y !== radii.y ||\n    innerRadii.z !== radii.z;\n  var isTopOpen = false;\n  var isBotOpen = false;\n  if (hasInnerSurface) {\n    vertexMultiplier = 2.0;\n    // Add 2x slicePartitions to connect the top/bottom of the outer to\n    // the top/bottom of the inner\n    if (minimumCone > 0.0) {\n      isTopOpen = true;\n      extraIndices += slicePartitions;\n    }\n    if (maximumCone < Math.PI) {\n      isBotOpen = true;\n      extraIndices += slicePartitions;\n    }\n  }\n\n  var vertexCount =\n    subdivisions * vertexMultiplier * (stackPartitions + slicePartitions);\n  var positions = new Float64Array(vertexCount * 3);\n\n  // Multiply by two because two points define each line segment\n  var numIndices =\n    2 *\n    (vertexCount +\n      extraIndices -\n      (slicePartitions + stackPartitions) * vertexMultiplier);\n  var indices = IndexDatatype.createTypedArray(vertexCount, numIndices);\n\n  var i;\n  var j;\n  var theta;\n  var phi;\n  var index = 0;\n\n  // Calculate sin/cos phi\n  var sinPhi = new Array(stackPartitions);\n  var cosPhi = new Array(stackPartitions);\n  for (i = 0; i < stackPartitions; i++) {\n    phi =\n      minimumCone + (i * (maximumCone - minimumCone)) / (stackPartitions - 1);\n    sinPhi[i] = sin(phi);\n    cosPhi[i] = cos(phi);\n  }\n\n  // Calculate sin/cos theta\n  var sinTheta = new Array(subdivisions);\n  var cosTheta = new Array(subdivisions);\n  for (i = 0; i < subdivisions; i++) {\n    theta =\n      minimumClock + (i * (maximumClock - minimumClock)) / (subdivisions - 1);\n    sinTheta[i] = sin(theta);\n    cosTheta[i] = cos(theta);\n  }\n\n  // Calculate the latitude lines on the outer surface\n  for (i = 0; i < stackPartitions; i++) {\n    for (j = 0; j < subdivisions; j++) {\n      positions[index++] = radii.x * sinPhi[i] * cosTheta[j];\n      positions[index++] = radii.y * sinPhi[i] * sinTheta[j];\n      positions[index++] = radii.z * cosPhi[i];\n    }\n  }\n\n  // Calculate the latitude lines on the inner surface\n  if (hasInnerSurface) {\n    for (i = 0; i < stackPartitions; i++) {\n      for (j = 0; j < subdivisions; j++) {\n        positions[index++] = innerRadii.x * sinPhi[i] * cosTheta[j];\n        positions[index++] = innerRadii.y * sinPhi[i] * sinTheta[j];\n        positions[index++] = innerRadii.z * cosPhi[i];\n      }\n    }\n  }\n\n  // Calculate sin/cos phi\n  sinPhi.length = subdivisions;\n  cosPhi.length = subdivisions;\n  for (i = 0; i < subdivisions; i++) {\n    phi = minimumCone + (i * (maximumCone - minimumCone)) / (subdivisions - 1);\n    sinPhi[i] = sin(phi);\n    cosPhi[i] = cos(phi);\n  }\n\n  // Calculate sin/cos theta for each slice partition\n  sinTheta.length = slicePartitions;\n  cosTheta.length = slicePartitions;\n  for (i = 0; i < slicePartitions; i++) {\n    theta =\n      minimumClock +\n      (i * (maximumClock - minimumClock)) / (slicePartitions - 1);\n    sinTheta[i] = sin(theta);\n    cosTheta[i] = cos(theta);\n  }\n\n  // Calculate the longitude lines on the outer surface\n  for (i = 0; i < subdivisions; i++) {\n    for (j = 0; j < slicePartitions; j++) {\n      positions[index++] = radii.x * sinPhi[i] * cosTheta[j];\n      positions[index++] = radii.y * sinPhi[i] * sinTheta[j];\n      positions[index++] = radii.z * cosPhi[i];\n    }\n  }\n\n  // Calculate the longitude lines on the inner surface\n  if (hasInnerSurface) {\n    for (i = 0; i < subdivisions; i++) {\n      for (j = 0; j < slicePartitions; j++) {\n        positions[index++] = innerRadii.x * sinPhi[i] * cosTheta[j];\n        positions[index++] = innerRadii.y * sinPhi[i] * sinTheta[j];\n        positions[index++] = innerRadii.z * cosPhi[i];\n      }\n    }\n  }\n\n  // Create indices for the latitude lines\n  index = 0;\n  for (i = 0; i < stackPartitions * vertexMultiplier; i++) {\n    var topOffset = i * subdivisions;\n    for (j = 0; j < subdivisions - 1; j++) {\n      indices[index++] = topOffset + j;\n      indices[index++] = topOffset + j + 1;\n    }\n  }\n\n  // Create indices for the outer longitude lines\n  var offset = stackPartitions * subdivisions * vertexMultiplier;\n  for (i = 0; i < slicePartitions; i++) {\n    for (j = 0; j < subdivisions - 1; j++) {\n      indices[index++] = offset + i + j * slicePartitions;\n      indices[index++] = offset + i + (j + 1) * slicePartitions;\n    }\n  }\n\n  // Create indices for the inner longitude lines\n  if (hasInnerSurface) {\n    offset =\n      stackPartitions * subdivisions * vertexMultiplier +\n      slicePartitions * subdivisions;\n    for (i = 0; i < slicePartitions; i++) {\n      for (j = 0; j < subdivisions - 1; j++) {\n        indices[index++] = offset + i + j * slicePartitions;\n        indices[index++] = offset + i + (j + 1) * slicePartitions;\n      }\n    }\n  }\n\n  if (hasInnerSurface) {\n    var outerOffset = stackPartitions * subdivisions * vertexMultiplier;\n    var innerOffset = outerOffset + subdivisions * slicePartitions;\n    if (isTopOpen) {\n      // Draw lines from the top of the inner surface to the top of the outer surface\n      for (i = 0; i < slicePartitions; i++) {\n        indices[index++] = outerOffset + i;\n        indices[index++] = innerOffset + i;\n      }\n    }\n\n    if (isBotOpen) {\n      // Draw lines from the top of the inner surface to the top of the outer surface\n      outerOffset += subdivisions * slicePartitions - slicePartitions;\n      innerOffset += subdivisions * slicePartitions - slicePartitions;\n      for (i = 0; i < slicePartitions; i++) {\n        indices[index++] = outerOffset + i;\n        indices[index++] = innerOffset + i;\n      }\n    }\n  }\n\n  var attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    }),\n  });\n\n  if (defined(ellipsoidGeometry._offsetAttribute)) {\n    var length = positions.length;\n    var applyOffset = new Uint8Array(length / 3);\n    var offsetValue =\n      ellipsoidGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n        ? 0\n        : 1;\n    arrayFill(applyOffset, offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: BoundingSphere.fromEllipsoid(ellipsoid),\n    offsetAttribute: ellipsoidGeometry._offsetAttribute,\n  });\n};\nexport default EllipsoidOutlineGeometry;\n"]},"metadata":{},"sourceType":"module"}