{"ast":null,"code":"import arraySlice from \"../Core/arraySlice.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport addDefaults from \"../ThirdParty/GltfPipeline/addDefaults.js\";\nimport ForEach from \"../ThirdParty/GltfPipeline/ForEach.js\";\nimport getAccessorByteStride from \"../ThirdParty/GltfPipeline/getAccessorByteStride.js\";\nimport numberOfComponentsForType from \"../ThirdParty/GltfPipeline/numberOfComponentsForType.js\";\nimport parseGlb from \"../ThirdParty/GltfPipeline/parseGlb.js\";\nimport updateVersion from \"../ThirdParty/GltfPipeline/updateVersion.js\";\nimport when from \"../ThirdParty/when.js\";\nimport Axis from \"./Axis.js\";\nimport ModelLoadResources from \"./ModelLoadResources.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport processModelMaterialsCommon from \"./processModelMaterialsCommon.js\";\nimport processPbrMaterials from \"./processPbrMaterials.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport Vector3DTileBatch from \"./Vector3DTileBatch.js\";\nimport Vector3DTilePrimitive from \"./Vector3DTilePrimitive.js\";\nvar boundingSphereCartesian3Scratch = new Cartesian3();\nvar ModelState = ModelUtility.ModelState; ///////////////////////////////////////////////////////////////////////////\n\n/**\n * A 3D model for classifying other 3D assets based on glTF, the runtime 3D asset format.\n * This is a special case when a model of a 3D tileset becomes a classifier when setting {@link Cesium3DTileset#classificationType}.\n *\n * @alias ClassificationModel\n * @constructor\n *\n * @private\n *\n * @param {Object} options Object with the following properties:\n * @param {ArrayBuffer|Uint8Array} options.gltf A binary glTF buffer.\n * @param {Boolean} [options.show=true] Determines if the model primitive will be shown.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the model from model to world coordinates.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Draws the bounding sphere for each draw command in the model.\n * @param {Boolean} [options.debugWireframe=false] For debugging only. Draws the model in wireframe.\n * @param {ClassificationType} [options.classificationType] What this model will classify.\n *\n * @exception {RuntimeError} Only binary glTF is supported.\n * @exception {RuntimeError} Buffer data must be embedded in the binary glTF.\n * @exception {RuntimeError} Only one node is supported for classification and it must have a mesh.\n * @exception {RuntimeError} Only one mesh is supported when using b3dm for classification.\n * @exception {RuntimeError} Only one primitive per mesh is supported when using b3dm for classification.\n * @exception {RuntimeError} The mesh must have a position attribute.\n * @exception {RuntimeError} The mesh must have a batch id attribute.\n */\n\nfunction ClassificationModel(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var gltf = options.gltf;\n\n  if (gltf instanceof ArrayBuffer) {\n    gltf = new Uint8Array(gltf);\n  }\n\n  if (gltf instanceof Uint8Array) {\n    // Parse and update binary glTF\n    gltf = parseGlb(gltf);\n    updateVersion(gltf);\n    addDefaults(gltf);\n    processModelMaterialsCommon(gltf);\n    processPbrMaterials(gltf);\n  } else {\n    throw new RuntimeError(\"Only binary glTF is supported as a classifier.\");\n  }\n\n  ForEach.buffer(gltf, function (buffer) {\n    if (!defined(buffer.extras._pipeline.source)) {\n      throw new RuntimeError(\"Buffer data must be embedded in the binary gltf.\");\n    }\n  });\n  var gltfNodes = gltf.nodes;\n  var gltfMeshes = gltf.meshes;\n  var gltfNode = gltfNodes[0];\n  var meshId = gltfNode.mesh;\n\n  if (gltfNodes.length !== 1 || !defined(meshId)) {\n    throw new RuntimeError(\"Only one node is supported for classification and it must have a mesh.\");\n  }\n\n  if (gltfMeshes.length !== 1) {\n    throw new RuntimeError(\"Only one mesh is supported when using b3dm for classification.\");\n  }\n\n  var gltfPrimitives = gltfMeshes[0].primitives;\n\n  if (gltfPrimitives.length !== 1) {\n    throw new RuntimeError(\"Only one primitive per mesh is supported when using b3dm for classification.\");\n  }\n\n  var gltfPositionAttribute = gltfPrimitives[0].attributes.POSITION;\n\n  if (!defined(gltfPositionAttribute)) {\n    throw new RuntimeError(\"The mesh must have a position attribute.\");\n  }\n\n  var gltfBatchIdAttribute = gltfPrimitives[0].attributes._BATCHID;\n\n  if (!defined(gltfBatchIdAttribute)) {\n    throw new RuntimeError(\"The mesh must have a batch id attribute.\");\n  }\n\n  this._gltf = gltf;\n  /**\n   * Determines if the model primitive will be shown.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n\n  this.show = defaultValue(options.show, true);\n  /**\n   * The 4x4 transformation matrix that transforms the model from model to world coordinates.\n   * When this is the identity matrix, the model is drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type {Matrix4}\n   *\n   * @default {@link Matrix4.IDENTITY}\n   *\n   * @example\n   * var origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n   * m.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);\n   */\n\n  this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));\n  this._modelMatrix = Matrix4.clone(this.modelMatrix);\n  this._ready = false;\n  this._readyPromise = when.defer();\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the model.  A glTF primitive corresponds\n   * to one draw command.  A glTF mesh has an array of primitives, often of length one.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n\n  this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);\n  this._debugShowBoundingVolume = false;\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the model in wireframe.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n\n  this.debugWireframe = defaultValue(options.debugWireframe, false);\n  this._debugWireframe = false;\n  this._classificationType = options.classificationType; // Undocumented options\n\n  this._vertexShaderLoaded = options.vertexShaderLoaded;\n  this._classificationShaderLoaded = options.classificationShaderLoaded;\n  this._uniformMapLoaded = options.uniformMapLoaded;\n  this._pickIdLoaded = options.pickIdLoaded;\n  this._ignoreCommands = defaultValue(options.ignoreCommands, false);\n  this._upAxis = defaultValue(options.upAxis, Axis.Y);\n  this._batchTable = options.batchTable;\n  this._computedModelMatrix = new Matrix4(); // Derived from modelMatrix and axis\n\n  this._initialRadius = undefined; // Radius without model's scale property, model-matrix scale, animations, or skins\n\n  this._boundingSphere = undefined;\n  this._scaledBoundingSphere = new BoundingSphere();\n  this._state = ModelState.NEEDS_LOAD;\n  this._loadResources = undefined;\n  this._mode = undefined;\n  this._dirty = false; // true when the model was transformed this frame\n\n  this._nodeMatrix = new Matrix4();\n  this._primitive = undefined;\n  this._extensionsUsed = undefined; // Cached used glTF extensions\n\n  this._extensionsRequired = undefined; // Cached required glTF extensions\n\n  this._quantizedUniforms = undefined; // Quantized uniforms for WEB3D_quantized_attributes\n\n  this._buffers = {};\n  this._vertexArray = undefined;\n  this._shaderProgram = undefined;\n  this._uniformMap = undefined;\n  this._geometryByteLength = 0;\n  this._trianglesLength = 0; // CESIUM_RTC extension\n\n  this._rtcCenter = undefined; // reference to either 3D or 2D\n\n  this._rtcCenterEye = undefined; // in eye coordinates\n\n  this._rtcCenter3D = undefined; // in world coordinates\n\n  this._rtcCenter2D = undefined; // in projected world coordinates\n}\n\nObject.defineProperties(ClassificationModel.prototype, {\n  /**\n   * The object for the glTF JSON, including properties with default values omitted\n   * from the JSON provided to this model.\n   *\n   * @memberof ClassificationModel.prototype\n   *\n   * @type {Object}\n   * @readonly\n   *\n   * @default undefined\n   */\n  gltf: {\n    get: function () {\n      return this._gltf;\n    }\n  },\n\n  /**\n   * The model's bounding sphere in its local coordinate system.\n   *\n   * @memberof ClassificationModel.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   *\n   * @default undefined\n   *\n   * @exception {DeveloperError} The model is not loaded.  Use ClassificationModel.readyPromise or wait for ClassificationModel.ready to be true.\n   *\n   * @example\n   * // Center in WGS84 coordinates\n   * var center = Cesium.Matrix4.multiplyByPoint(model.modelMatrix, model.boundingSphere.center, new Cesium.Cartesian3());\n   */\n  boundingSphere: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (this._state !== ModelState.LOADED) {\n        throw new DeveloperError(\"The model is not loaded.  Use ClassificationModel.readyPromise or wait for ClassificationModel.ready to be true.\");\n      } //>>includeEnd('debug');\n\n\n      var modelMatrix = this.modelMatrix;\n      var nonUniformScale = Matrix4.getScale(modelMatrix, boundingSphereCartesian3Scratch);\n      var scaledBoundingSphere = this._scaledBoundingSphere;\n      scaledBoundingSphere.center = Cartesian3.multiplyComponents(this._boundingSphere.center, nonUniformScale, scaledBoundingSphere.center);\n      scaledBoundingSphere.radius = Cartesian3.maximumComponent(nonUniformScale) * this._initialRadius;\n\n      if (defined(this._rtcCenter)) {\n        Cartesian3.add(this._rtcCenter, scaledBoundingSphere.center, scaledBoundingSphere.center);\n      }\n\n      return scaledBoundingSphere;\n    }\n  },\n\n  /**\n   * When <code>true</code>, this model is ready to render, i.e., the external binary, image,\n   * and shader files were downloaded and the WebGL resources were created.  This is set to\n   * <code>true</code> right before {@link ClassificationModel#readyPromise} is resolved.\n   *\n   * @memberof ClassificationModel.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n\n  /**\n   * Gets the promise that will be resolved when this model is ready to render, i.e., when the external binary, image,\n   * and shader files were downloaded and the WebGL resources were created.\n   * <p>\n   * This promise is resolved at the end of the frame before the first frame the model is rendered in.\n   * </p>\n   *\n   * @memberof ClassificationModel.prototype\n   * @type {Promise.<ClassificationModel>}\n   * @readonly\n   *\n   * @see ClassificationModel#ready\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    }\n  },\n\n  /**\n   * Returns true if the model was transformed this frame\n   *\n   * @memberof ClassificationModel.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @private\n   */\n  dirty: {\n    get: function () {\n      return this._dirty;\n    }\n  },\n\n  /**\n   * Returns an object with all of the glTF extensions used.\n   *\n   * @memberof ClassificationModel.prototype\n   *\n   * @type {Object}\n   * @readonly\n   */\n  extensionsUsed: {\n    get: function () {\n      if (!defined(this._extensionsUsed)) {\n        this._extensionsUsed = ModelUtility.getUsedExtensions(this.gltf);\n      }\n\n      return this._extensionsUsed;\n    }\n  },\n\n  /**\n   * Returns an object with all of the glTF extensions required.\n   *\n   * @memberof ClassificationModel.prototype\n   *\n   * @type {Object}\n   * @readonly\n   */\n  extensionsRequired: {\n    get: function () {\n      if (!defined(this._extensionsRequired)) {\n        this._extensionsRequired = ModelUtility.getRequiredExtensions(this.gltf);\n      }\n\n      return this._extensionsRequired;\n    }\n  },\n\n  /**\n   * Gets the model's up-axis.\n   * By default models are y-up according to the glTF spec, however geo-referenced models will typically be z-up.\n   *\n   * @memberof ClassificationModel.prototype\n   *\n   * @type {Number}\n   * @default Axis.Y\n   * @readonly\n   *\n   * @private\n   */\n  upAxis: {\n    get: function () {\n      return this._upAxis;\n    }\n  },\n\n  /**\n   * Gets the model's triangle count.\n   *\n   * @private\n   */\n  trianglesLength: {\n    get: function () {\n      return this._trianglesLength;\n    }\n  },\n\n  /**\n   * Gets the model's geometry memory in bytes. This includes all vertex and index buffers.\n   *\n   * @private\n   */\n  geometryByteLength: {\n    get: function () {\n      return this._geometryByteLength;\n    }\n  },\n\n  /**\n   * Gets the model's texture memory in bytes.\n   *\n   * @private\n   */\n  texturesByteLength: {\n    get: function () {\n      return 0;\n    }\n  },\n\n  /**\n   * Gets the model's classification type.\n   * @memberof ClassificationModel.prototype\n   * @type {ClassificationType}\n   */\n  classificationType: {\n    get: function () {\n      return this._classificationType;\n    }\n  }\n}); ///////////////////////////////////////////////////////////////////////////\n\nfunction addBuffersToLoadResources(model) {\n  var gltf = model.gltf;\n  var loadResources = model._loadResources;\n  ForEach.buffer(gltf, function (buffer, id) {\n    loadResources.buffers[id] = buffer.extras._pipeline.source;\n  });\n}\n\nfunction parseBufferViews(model) {\n  var bufferViews = model.gltf.bufferViews;\n  var vertexBuffersToCreate = model._loadResources.vertexBuffersToCreate; // Only ARRAY_BUFFER here.  ELEMENT_ARRAY_BUFFER created below.\n\n  ForEach.bufferView(model.gltf, function (bufferView, id) {\n    if (bufferView.target === WebGLConstants.ARRAY_BUFFER) {\n      vertexBuffersToCreate.enqueue(id);\n    }\n  });\n  var indexBuffersToCreate = model._loadResources.indexBuffersToCreate;\n  var indexBufferIds = {}; // The Cesium Renderer requires knowing the datatype for an index buffer\n  // at creation type, which is not part of the glTF bufferview so loop\n  // through glTF accessors to create the bufferview's index buffer.\n\n  ForEach.accessor(model.gltf, function (accessor) {\n    var bufferViewId = accessor.bufferView;\n    var bufferView = bufferViews[bufferViewId];\n\n    if (bufferView.target === WebGLConstants.ELEMENT_ARRAY_BUFFER && !defined(indexBufferIds[bufferViewId])) {\n      indexBufferIds[bufferViewId] = true;\n      indexBuffersToCreate.enqueue({\n        id: bufferViewId,\n        componentType: accessor.componentType\n      });\n    }\n  });\n}\n\nfunction createVertexBuffer(bufferViewId, model) {\n  var loadResources = model._loadResources;\n  var bufferViews = model.gltf.bufferViews;\n  var bufferView = bufferViews[bufferViewId];\n  var vertexBuffer = loadResources.getBuffer(bufferView);\n  model._buffers[bufferViewId] = vertexBuffer;\n  model._geometryByteLength += vertexBuffer.byteLength;\n}\n\nfunction createIndexBuffer(bufferViewId, componentType, model) {\n  var loadResources = model._loadResources;\n  var bufferViews = model.gltf.bufferViews;\n  var bufferView = bufferViews[bufferViewId];\n  var indexBuffer = {\n    typedArray: loadResources.getBuffer(bufferView),\n    indexDatatype: componentType\n  };\n  model._buffers[bufferViewId] = indexBuffer;\n  model._geometryByteLength += indexBuffer.typedArray.byteLength;\n}\n\nfunction createBuffers(model) {\n  var loadResources = model._loadResources;\n\n  if (loadResources.pendingBufferLoads !== 0) {\n    return;\n  }\n\n  var vertexBuffersToCreate = loadResources.vertexBuffersToCreate;\n  var indexBuffersToCreate = loadResources.indexBuffersToCreate;\n\n  while (vertexBuffersToCreate.length > 0) {\n    createVertexBuffer(vertexBuffersToCreate.dequeue(), model);\n  }\n\n  while (indexBuffersToCreate.length > 0) {\n    var i = indexBuffersToCreate.dequeue();\n    createIndexBuffer(i.id, i.componentType, model);\n  }\n}\n\nfunction modifyShaderForQuantizedAttributes(shader, model) {\n  var primitive = model.gltf.meshes[0].primitives[0];\n  var result = ModelUtility.modifyShaderForQuantizedAttributes(model.gltf, primitive, shader);\n  model._quantizedUniforms = result.uniforms;\n  return result.shader;\n}\n\nfunction modifyShader(shader, callback) {\n  if (defined(callback)) {\n    shader = callback(shader);\n  }\n\n  return shader;\n}\n\nfunction createProgram(model) {\n  var gltf = model.gltf;\n  var positionName = ModelUtility.getAttributeOrUniformBySemantic(gltf, \"POSITION\");\n  var batchIdName = ModelUtility.getAttributeOrUniformBySemantic(gltf, \"_BATCHID\");\n  var attributeLocations = {};\n  attributeLocations[positionName] = 0;\n  attributeLocations[batchIdName] = 1;\n  var modelViewProjectionName = ModelUtility.getAttributeOrUniformBySemantic(gltf, \"MODELVIEWPROJECTION\");\n  var uniformDecl;\n  var toClip;\n\n  if (!defined(modelViewProjectionName)) {\n    var projectionName = ModelUtility.getAttributeOrUniformBySemantic(gltf, \"PROJECTION\");\n    var modelViewName = ModelUtility.getAttributeOrUniformBySemantic(gltf, \"MODELVIEW\");\n\n    if (!defined(modelViewName)) {\n      modelViewName = ModelUtility.getAttributeOrUniformBySemantic(gltf, \"CESIUM_RTC_MODELVIEW\");\n    }\n\n    uniformDecl = \"uniform mat4 \" + modelViewName + \";\\n\" + \"uniform mat4 \" + projectionName + \";\\n\";\n    toClip = projectionName + \" * \" + modelViewName + \" * vec4(\" + positionName + \", 1.0)\";\n  } else {\n    uniformDecl = \"uniform mat4 \" + modelViewProjectionName + \";\\n\";\n    toClip = modelViewProjectionName + \" * vec4(\" + positionName + \", 1.0)\";\n  }\n\n  var computePosition = \"    vec4 positionInClipCoords = \" + toClip + \";\\n\";\n  var vs = \"attribute vec3 \" + positionName + \";\\n\" + \"attribute float \" + batchIdName + \";\\n\" + uniformDecl + \"void main() {\\n\" + computePosition + \"    gl_Position = czm_depthClampFarPlane(positionInClipCoords);\\n\" + \"}\\n\";\n  var fs = \"#ifdef GL_EXT_frag_depth\\n\" + \"#extension GL_EXT_frag_depth : enable\\n\" + \"#endif\\n\" + \"void main() \\n\" + \"{ \\n\" + \"    gl_FragColor = vec4(1.0); \\n\" + \"    czm_writeDepthClampedToFarPlane();\\n\" + \"}\\n\";\n\n  if (model.extensionsUsed.WEB3D_quantized_attributes) {\n    vs = modifyShaderForQuantizedAttributes(vs, model);\n  }\n\n  var drawVS = modifyShader(vs, model._vertexShaderLoaded);\n  var drawFS = modifyShader(fs, model._classificationShaderLoaded);\n  drawVS = ModelUtility.modifyVertexShaderForLogDepth(drawVS, toClip);\n  drawFS = ModelUtility.modifyFragmentShaderForLogDepth(drawFS);\n  model._shaderProgram = {\n    vertexShaderSource: drawVS,\n    fragmentShaderSource: drawFS,\n    attributeLocations: attributeLocations\n  };\n}\n\nfunction getAttributeLocations() {\n  return {\n    POSITION: 0,\n    _BATCHID: 1\n  };\n}\n\nfunction createVertexArray(model) {\n  var loadResources = model._loadResources;\n\n  if (!loadResources.finishedBuffersCreation() || defined(model._vertexArray)) {\n    return;\n  }\n\n  var rendererBuffers = model._buffers;\n  var gltf = model.gltf;\n  var accessors = gltf.accessors;\n  var meshes = gltf.meshes;\n  var primitives = meshes[0].primitives;\n  var primitive = primitives[0];\n  var attributeLocations = getAttributeLocations();\n  var attributes = {};\n  ForEach.meshPrimitiveAttribute(primitive, function (accessorId, attributeName) {\n    // Skip if the attribute is not used by the material, e.g., because the asset\n    // was exported with an attribute that wasn't used and the asset wasn't optimized.\n    var attributeLocation = attributeLocations[attributeName];\n\n    if (defined(attributeLocation)) {\n      var a = accessors[accessorId];\n      attributes[attributeName] = {\n        index: attributeLocation,\n        vertexBuffer: rendererBuffers[a.bufferView],\n        componentsPerAttribute: numberOfComponentsForType(a.type),\n        componentDatatype: a.componentType,\n        offsetInBytes: a.byteOffset,\n        strideInBytes: getAccessorByteStride(gltf, a)\n      };\n    }\n  });\n  var indexBuffer;\n\n  if (defined(primitive.indices)) {\n    var accessor = accessors[primitive.indices];\n    indexBuffer = rendererBuffers[accessor.bufferView];\n  }\n\n  model._vertexArray = {\n    attributes: attributes,\n    indexBuffer: indexBuffer\n  };\n}\n\nvar gltfSemanticUniforms = {\n  PROJECTION: function (uniformState, model) {\n    return ModelUtility.getGltfSemanticUniforms().PROJECTION(uniformState, model);\n  },\n  MODELVIEW: function (uniformState, model) {\n    return ModelUtility.getGltfSemanticUniforms().MODELVIEW(uniformState, model);\n  },\n  CESIUM_RTC_MODELVIEW: function (uniformState, model) {\n    return ModelUtility.getGltfSemanticUniforms().CESIUM_RTC_MODELVIEW(uniformState, model);\n  },\n  MODELVIEWPROJECTION: function (uniformState, model) {\n    return ModelUtility.getGltfSemanticUniforms().MODELVIEWPROJECTION(uniformState, model);\n  }\n};\n\nfunction createUniformMap(model, context) {\n  if (defined(model._uniformMap)) {\n    return;\n  }\n\n  var uniformMap = {};\n  ForEach.technique(model.gltf, function (technique) {\n    ForEach.techniqueUniform(technique, function (uniform, uniformName) {\n      if (!defined(uniform.semantic) || !defined(gltfSemanticUniforms[uniform.semantic])) {\n        return;\n      }\n\n      uniformMap[uniformName] = gltfSemanticUniforms[uniform.semantic](context.uniformState, model);\n    });\n  });\n  model._uniformMap = uniformMap;\n}\n\nfunction createUniformsForQuantizedAttributes(model, primitive) {\n  return ModelUtility.createUniformsForQuantizedAttributes(model.gltf, primitive, model._quantizedUniforms);\n}\n\nfunction triangleCountFromPrimitiveIndices(primitive, indicesCount) {\n  switch (primitive.mode) {\n    case PrimitiveType.TRIANGLES:\n      return indicesCount / 3;\n\n    case PrimitiveType.TRIANGLE_STRIP:\n    case PrimitiveType.TRIANGLE_FAN:\n      return Math.max(indicesCount - 2, 0);\n\n    default:\n      return 0;\n  }\n}\n\nfunction createPrimitive(model) {\n  var batchTable = model._batchTable;\n  var uniformMap = model._uniformMap;\n  var vertexArray = model._vertexArray;\n  var gltf = model.gltf;\n  var accessors = gltf.accessors;\n  var gltfMeshes = gltf.meshes;\n  var primitive = gltfMeshes[0].primitives[0];\n  var ix = accessors[primitive.indices];\n  var positionAccessor = primitive.attributes.POSITION;\n  var minMax = ModelUtility.getAccessorMinMax(gltf, positionAccessor);\n  var boundingSphere = BoundingSphere.fromCornerPoints(Cartesian3.fromArray(minMax.min), Cartesian3.fromArray(minMax.max));\n  var offset;\n  var count;\n\n  if (defined(ix)) {\n    count = ix.count;\n    offset = ix.byteOffset / IndexDatatype.getSizeInBytes(ix.componentType); // glTF has offset in bytes.  Cesium has offsets in indices\n  } else {\n    var positions = accessors[primitive.attributes.POSITION];\n    count = positions.count;\n    offset = 0;\n  } // Update model triangle count using number of indices\n\n\n  model._trianglesLength += triangleCountFromPrimitiveIndices(primitive, count); // Allow callback to modify the uniformMap\n\n  if (defined(model._uniformMapLoaded)) {\n    uniformMap = model._uniformMapLoaded(uniformMap);\n  } // Add uniforms for decoding quantized attributes if used\n\n\n  if (model.extensionsUsed.WEB3D_quantized_attributes) {\n    var quantizedUniformMap = createUniformsForQuantizedAttributes(model, primitive);\n    uniformMap = combine(uniformMap, quantizedUniformMap);\n  }\n\n  var attribute = vertexArray.attributes.POSITION;\n  var componentDatatype = attribute.componentDatatype;\n  var typedArray = attribute.vertexBuffer;\n  var byteOffset = typedArray.byteOffset;\n  var bufferLength = typedArray.byteLength / ComponentDatatype.getSizeInBytes(componentDatatype);\n  var positionsBuffer = ComponentDatatype.createArrayBufferView(componentDatatype, typedArray.buffer, byteOffset, bufferLength);\n  attribute = vertexArray.attributes._BATCHID;\n  componentDatatype = attribute.componentDatatype;\n  typedArray = attribute.vertexBuffer;\n  byteOffset = typedArray.byteOffset;\n  bufferLength = typedArray.byteLength / ComponentDatatype.getSizeInBytes(componentDatatype);\n  var vertexBatchIds = ComponentDatatype.createArrayBufferView(componentDatatype, typedArray.buffer, byteOffset, bufferLength);\n  var buffer = vertexArray.indexBuffer.typedArray;\n  var indices;\n\n  if (vertexArray.indexBuffer.indexDatatype === IndexDatatype.UNSIGNED_SHORT) {\n    indices = new Uint16Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / Uint16Array.BYTES_PER_ELEMENT);\n  } else {\n    indices = new Uint32Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / Uint32Array.BYTES_PER_ELEMENT);\n  }\n\n  positionsBuffer = arraySlice(positionsBuffer);\n  vertexBatchIds = arraySlice(vertexBatchIds);\n  indices = arraySlice(indices, offset, offset + count);\n  var batchIds = [];\n  var indexCounts = [];\n  var indexOffsets = [];\n  var batchedIndices = [];\n  var currentId = vertexBatchIds[indices[0]];\n  batchIds.push(currentId);\n  indexOffsets.push(0);\n  var batchId;\n  var indexOffset;\n  var indexCount;\n  var indicesLength = indices.length;\n\n  for (var j = 1; j < indicesLength; ++j) {\n    batchId = vertexBatchIds[indices[j]];\n\n    if (batchId !== currentId) {\n      indexOffset = indexOffsets[indexOffsets.length - 1];\n      indexCount = j - indexOffset;\n      batchIds.push(batchId);\n      indexCounts.push(indexCount);\n      indexOffsets.push(j);\n      batchedIndices.push(new Vector3DTileBatch({\n        offset: indexOffset,\n        count: indexCount,\n        batchIds: [currentId],\n        color: Color.WHITE\n      }));\n      currentId = batchId;\n    }\n  }\n\n  indexOffset = indexOffsets[indexOffsets.length - 1];\n  indexCount = indicesLength - indexOffset;\n  indexCounts.push(indexCount);\n  batchedIndices.push(new Vector3DTileBatch({\n    offset: indexOffset,\n    count: indexCount,\n    batchIds: [currentId],\n    color: Color.WHITE\n  }));\n  var shader = model._shaderProgram;\n  var vertexShaderSource = shader.vertexShaderSource;\n  var fragmentShaderSource = shader.fragmentShaderSource;\n  var attributeLocations = shader.attributeLocations;\n  var pickId = defined(model._pickIdLoaded) ? model._pickIdLoaded() : undefined;\n  model._primitive = new Vector3DTilePrimitive({\n    classificationType: model._classificationType,\n    positions: positionsBuffer,\n    indices: indices,\n    indexOffsets: indexOffsets,\n    indexCounts: indexCounts,\n    batchIds: batchIds,\n    vertexBatchIds: vertexBatchIds,\n    batchedIndices: batchedIndices,\n    batchTable: batchTable,\n    boundingVolume: new BoundingSphere(),\n    // updated in update()\n    _vertexShaderSource: vertexShaderSource,\n    _fragmentShaderSource: fragmentShaderSource,\n    _attributeLocations: attributeLocations,\n    _uniformMap: uniformMap,\n    _pickId: pickId,\n    _modelMatrix: new Matrix4(),\n    // updated in update()\n    _boundingSphere: boundingSphere // used to update boundingVolume\n\n  }); // Release CPU resources\n\n  model._buffers = undefined;\n  model._vertexArray = undefined;\n  model._shaderProgram = undefined;\n  model._uniformMap = undefined;\n}\n\nfunction createRuntimeNodes(model) {\n  var loadResources = model._loadResources;\n\n  if (!loadResources.finished()) {\n    return;\n  }\n\n  if (defined(model._primitive)) {\n    return;\n  }\n\n  var gltf = model.gltf;\n  var nodes = gltf.nodes;\n  var gltfNode = nodes[0];\n  model._nodeMatrix = ModelUtility.getTransform(gltfNode, model._nodeMatrix);\n  createPrimitive(model);\n}\n\nfunction createResources(model, frameState) {\n  var context = frameState.context;\n  ModelUtility.checkSupportedGlExtensions(model.gltf.glExtensionsUsed, context);\n  createBuffers(model); // using glTF bufferViews\n\n  createProgram(model);\n  createVertexArray(model); // using glTF meshes\n\n  createUniformMap(model, context); // using glTF materials/techniques\n\n  createRuntimeNodes(model); // using glTF scene\n} ///////////////////////////////////////////////////////////////////////////\n\n\nvar scratchComputedTranslation = new Cartesian4();\nvar scratchComputedMatrixIn2D = new Matrix4();\n\nfunction updateNodeModelMatrix(model, modelTransformChanged, justLoaded, projection) {\n  var computedModelMatrix = model._computedModelMatrix;\n\n  if (model._mode !== SceneMode.SCENE3D && !model._ignoreCommands) {\n    var translation = Matrix4.getColumn(computedModelMatrix, 3, scratchComputedTranslation);\n\n    if (!Cartesian4.equals(translation, Cartesian4.UNIT_W)) {\n      computedModelMatrix = Transforms.basisTo2D(projection, computedModelMatrix, scratchComputedMatrixIn2D);\n      model._rtcCenter = model._rtcCenter3D;\n    } else {\n      var center = model.boundingSphere.center;\n      var to2D = Transforms.wgs84To2DModelMatrix(projection, center, scratchComputedMatrixIn2D);\n      computedModelMatrix = Matrix4.multiply(to2D, computedModelMatrix, scratchComputedMatrixIn2D);\n\n      if (defined(model._rtcCenter)) {\n        Matrix4.setTranslation(computedModelMatrix, Cartesian4.UNIT_W, computedModelMatrix);\n        model._rtcCenter = model._rtcCenter2D;\n      }\n    }\n  }\n\n  var primitive = model._primitive;\n\n  if (modelTransformChanged || justLoaded) {\n    Matrix4.multiplyTransformation(computedModelMatrix, model._nodeMatrix, primitive._modelMatrix);\n    BoundingSphere.transform(primitive._boundingSphere, primitive._modelMatrix, primitive._boundingVolume);\n\n    if (defined(model._rtcCenter)) {\n      Cartesian3.add(model._rtcCenter, primitive._boundingVolume.center, primitive._boundingVolume.center);\n    }\n  }\n} ///////////////////////////////////////////////////////////////////////////\n\n\nClassificationModel.prototype.updateCommands = function (batchId, color) {\n  this._primitive.updateCommands(batchId, color);\n};\n\nClassificationModel.prototype.update = function (frameState) {\n  if (frameState.mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  if (!FeatureDetection.supportsWebP.initialized) {\n    FeatureDetection.supportsWebP.initialize();\n    return;\n  }\n\n  var supportsWebP = FeatureDetection.supportsWebP();\n\n  if (this._state === ModelState.NEEDS_LOAD && defined(this.gltf)) {\n    this._state = ModelState.LOADING;\n\n    if (this._state !== ModelState.FAILED) {\n      var extensions = this.gltf.extensions;\n\n      if (defined(extensions) && defined(extensions.CESIUM_RTC)) {\n        var center = Cartesian3.fromArray(extensions.CESIUM_RTC.center);\n\n        if (!Cartesian3.equals(center, Cartesian3.ZERO)) {\n          this._rtcCenter3D = center;\n          var projection = frameState.mapProjection;\n          var ellipsoid = projection.ellipsoid;\n          var cartographic = ellipsoid.cartesianToCartographic(this._rtcCenter3D);\n          var projectedCart = projection.project(cartographic);\n          Cartesian3.fromElements(projectedCart.z, projectedCart.x, projectedCart.y, projectedCart);\n          this._rtcCenter2D = projectedCart;\n          this._rtcCenterEye = new Cartesian3();\n          this._rtcCenter = this._rtcCenter3D;\n        }\n      }\n\n      this._loadResources = new ModelLoadResources();\n      ModelUtility.parseBuffers(this);\n    }\n  }\n\n  var loadResources = this._loadResources;\n  var justLoaded = false;\n\n  if (this._state === ModelState.LOADING) {\n    // Transition from LOADING -> LOADED once resources are downloaded and created.\n    // Textures may continue to stream in while in the LOADED state.\n    if (loadResources.pendingBufferLoads === 0) {\n      ModelUtility.checkSupportedExtensions(this.extensionsRequired, supportsWebP);\n      addBuffersToLoadResources(this);\n      parseBufferViews(this);\n      this._boundingSphere = ModelUtility.computeBoundingSphere(this);\n      this._initialRadius = this._boundingSphere.radius;\n      createResources(this, frameState);\n    }\n\n    if (loadResources.finished()) {\n      this._state = ModelState.LOADED;\n      justLoaded = true;\n    }\n  }\n\n  if (defined(loadResources) && this._state === ModelState.LOADED) {\n    if (!justLoaded) {\n      createResources(this, frameState);\n    }\n\n    if (loadResources.finished()) {\n      this._loadResources = undefined; // Clear CPU memory since WebGL resources were created.\n    }\n  }\n\n  var show = this.show;\n\n  if (show && this._state === ModelState.LOADED || justLoaded) {\n    this._dirty = false;\n    var modelMatrix = this.modelMatrix;\n    var modeChanged = frameState.mode !== this._mode;\n    this._mode = frameState.mode; // ClassificationModel's model matrix needs to be updated\n\n    var modelTransformChanged = !Matrix4.equals(this._modelMatrix, modelMatrix) || modeChanged;\n\n    if (modelTransformChanged || justLoaded) {\n      Matrix4.clone(modelMatrix, this._modelMatrix);\n      var computedModelMatrix = this._computedModelMatrix;\n      Matrix4.clone(modelMatrix, computedModelMatrix);\n\n      if (this._upAxis === Axis.Y) {\n        Matrix4.multiplyTransformation(computedModelMatrix, Axis.Y_UP_TO_Z_UP, computedModelMatrix);\n      } else if (this._upAxis === Axis.X) {\n        Matrix4.multiplyTransformation(computedModelMatrix, Axis.X_UP_TO_Z_UP, computedModelMatrix);\n      }\n    } // Update modelMatrix throughout the graph as needed\n\n\n    if (modelTransformChanged || justLoaded) {\n      updateNodeModelMatrix(this, modelTransformChanged, justLoaded, frameState.mapProjection);\n      this._dirty = true;\n    }\n  }\n\n  if (justLoaded) {\n    // Called after modelMatrix update.\n    var model = this;\n    frameState.afterRender.push(function () {\n      model._ready = true;\n\n      model._readyPromise.resolve(model);\n    });\n    return;\n  }\n\n  if (show && !this._ignoreCommands) {\n    this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume;\n    this._primitive.debugWireframe = this.debugWireframe;\n\n    this._primitive.update(frameState);\n  }\n};\n\nClassificationModel.prototype.isDestroyed = function () {\n  return false;\n};\n\nClassificationModel.prototype.destroy = function () {\n  this._primitive = this._primitive && this._primitive.destroy();\n  return destroyObject(this);\n};\n\nexport default ClassificationModel;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/ClassificationModel.js"],"names":["arraySlice","BoundingSphere","Cartesian3","Cartesian4","Color","combine","ComponentDatatype","defaultValue","defined","destroyObject","DeveloperError","FeatureDetection","IndexDatatype","Matrix4","PrimitiveType","RuntimeError","Transforms","WebGLConstants","addDefaults","ForEach","getAccessorByteStride","numberOfComponentsForType","parseGlb","updateVersion","when","Axis","ModelLoadResources","ModelUtility","processModelMaterialsCommon","processPbrMaterials","SceneMode","Vector3DTileBatch","Vector3DTilePrimitive","boundingSphereCartesian3Scratch","ModelState","ClassificationModel","options","EMPTY_OBJECT","gltf","ArrayBuffer","Uint8Array","buffer","extras","_pipeline","source","gltfNodes","nodes","gltfMeshes","meshes","gltfNode","meshId","mesh","length","gltfPrimitives","primitives","gltfPositionAttribute","attributes","POSITION","gltfBatchIdAttribute","_BATCHID","_gltf","show","modelMatrix","clone","IDENTITY","_modelMatrix","_ready","_readyPromise","defer","debugShowBoundingVolume","_debugShowBoundingVolume","debugWireframe","_debugWireframe","_classificationType","classificationType","_vertexShaderLoaded","vertexShaderLoaded","_classificationShaderLoaded","classificationShaderLoaded","_uniformMapLoaded","uniformMapLoaded","_pickIdLoaded","pickIdLoaded","_ignoreCommands","ignoreCommands","_upAxis","upAxis","Y","_batchTable","batchTable","_computedModelMatrix","_initialRadius","undefined","_boundingSphere","_scaledBoundingSphere","_state","NEEDS_LOAD","_loadResources","_mode","_dirty","_nodeMatrix","_primitive","_extensionsUsed","_extensionsRequired","_quantizedUniforms","_buffers","_vertexArray","_shaderProgram","_uniformMap","_geometryByteLength","_trianglesLength","_rtcCenter","_rtcCenterEye","_rtcCenter3D","_rtcCenter2D","Object","defineProperties","prototype","get","boundingSphere","LOADED","nonUniformScale","getScale","scaledBoundingSphere","center","multiplyComponents","radius","maximumComponent","add","ready","readyPromise","promise","dirty","extensionsUsed","getUsedExtensions","extensionsRequired","getRequiredExtensions","trianglesLength","geometryByteLength","texturesByteLength","addBuffersToLoadResources","model","loadResources","id","buffers","parseBufferViews","bufferViews","vertexBuffersToCreate","bufferView","target","ARRAY_BUFFER","enqueue","indexBuffersToCreate","indexBufferIds","accessor","bufferViewId","ELEMENT_ARRAY_BUFFER","componentType","createVertexBuffer","vertexBuffer","getBuffer","byteLength","createIndexBuffer","indexBuffer","typedArray","indexDatatype","createBuffers","pendingBufferLoads","dequeue","i","modifyShaderForQuantizedAttributes","shader","primitive","result","uniforms","modifyShader","callback","createProgram","positionName","getAttributeOrUniformBySemantic","batchIdName","attributeLocations","modelViewProjectionName","uniformDecl","toClip","projectionName","modelViewName","computePosition","vs","fs","WEB3D_quantized_attributes","drawVS","drawFS","modifyVertexShaderForLogDepth","modifyFragmentShaderForLogDepth","vertexShaderSource","fragmentShaderSource","getAttributeLocations","createVertexArray","finishedBuffersCreation","rendererBuffers","accessors","meshPrimitiveAttribute","accessorId","attributeName","attributeLocation","a","index","componentsPerAttribute","type","componentDatatype","offsetInBytes","byteOffset","strideInBytes","indices","gltfSemanticUniforms","PROJECTION","uniformState","getGltfSemanticUniforms","MODELVIEW","CESIUM_RTC_MODELVIEW","MODELVIEWPROJECTION","createUniformMap","context","uniformMap","technique","techniqueUniform","uniform","uniformName","semantic","createUniformsForQuantizedAttributes","triangleCountFromPrimitiveIndices","indicesCount","mode","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","Math","max","createPrimitive","vertexArray","ix","positionAccessor","minMax","getAccessorMinMax","fromCornerPoints","fromArray","min","offset","count","getSizeInBytes","positions","quantizedUniformMap","attribute","bufferLength","positionsBuffer","createArrayBufferView","vertexBatchIds","UNSIGNED_SHORT","Uint16Array","BYTES_PER_ELEMENT","Uint32Array","batchIds","indexCounts","indexOffsets","batchedIndices","currentId","push","batchId","indexOffset","indexCount","indicesLength","j","color","WHITE","pickId","boundingVolume","_vertexShaderSource","_fragmentShaderSource","_attributeLocations","_pickId","createRuntimeNodes","finished","getTransform","createResources","frameState","checkSupportedGlExtensions","glExtensionsUsed","scratchComputedTranslation","scratchComputedMatrixIn2D","updateNodeModelMatrix","modelTransformChanged","justLoaded","projection","computedModelMatrix","SCENE3D","translation","getColumn","equals","UNIT_W","basisTo2D","to2D","wgs84To2DModelMatrix","multiply","setTranslation","multiplyTransformation","transform","_boundingVolume","updateCommands","update","MORPHING","supportsWebP","initialized","initialize","LOADING","FAILED","extensions","CESIUM_RTC","ZERO","mapProjection","ellipsoid","cartographic","cartesianToCartographic","projectedCart","project","fromElements","z","x","y","parseBuffers","checkSupportedExtensions","computeBoundingSphere","modeChanged","Y_UP_TO_Z_UP","X","X_UP_TO_Z_UP","afterRender","resolve","isDestroyed","destroy"],"mappings":"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","sourcesContent":["import arraySlice from \"../Core/arraySlice.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport addDefaults from \"../ThirdParty/GltfPipeline/addDefaults.js\";\nimport ForEach from \"../ThirdParty/GltfPipeline/ForEach.js\";\nimport getAccessorByteStride from \"../ThirdParty/GltfPipeline/getAccessorByteStride.js\";\nimport numberOfComponentsForType from \"../ThirdParty/GltfPipeline/numberOfComponentsForType.js\";\nimport parseGlb from \"../ThirdParty/GltfPipeline/parseGlb.js\";\nimport updateVersion from \"../ThirdParty/GltfPipeline/updateVersion.js\";\nimport when from \"../ThirdParty/when.js\";\nimport Axis from \"./Axis.js\";\nimport ModelLoadResources from \"./ModelLoadResources.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport processModelMaterialsCommon from \"./processModelMaterialsCommon.js\";\nimport processPbrMaterials from \"./processPbrMaterials.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport Vector3DTileBatch from \"./Vector3DTileBatch.js\";\nimport Vector3DTilePrimitive from \"./Vector3DTilePrimitive.js\";\n\nvar boundingSphereCartesian3Scratch = new Cartesian3();\n\nvar ModelState = ModelUtility.ModelState;\n\n///////////////////////////////////////////////////////////////////////////\n\n/**\n * A 3D model for classifying other 3D assets based on glTF, the runtime 3D asset format.\n * This is a special case when a model of a 3D tileset becomes a classifier when setting {@link Cesium3DTileset#classificationType}.\n *\n * @alias ClassificationModel\n * @constructor\n *\n * @private\n *\n * @param {Object} options Object with the following properties:\n * @param {ArrayBuffer|Uint8Array} options.gltf A binary glTF buffer.\n * @param {Boolean} [options.show=true] Determines if the model primitive will be shown.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the model from model to world coordinates.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Draws the bounding sphere for each draw command in the model.\n * @param {Boolean} [options.debugWireframe=false] For debugging only. Draws the model in wireframe.\n * @param {ClassificationType} [options.classificationType] What this model will classify.\n *\n * @exception {RuntimeError} Only binary glTF is supported.\n * @exception {RuntimeError} Buffer data must be embedded in the binary glTF.\n * @exception {RuntimeError} Only one node is supported for classification and it must have a mesh.\n * @exception {RuntimeError} Only one mesh is supported when using b3dm for classification.\n * @exception {RuntimeError} Only one primitive per mesh is supported when using b3dm for classification.\n * @exception {RuntimeError} The mesh must have a position attribute.\n * @exception {RuntimeError} The mesh must have a batch id attribute.\n */\nfunction ClassificationModel(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var gltf = options.gltf;\n  if (gltf instanceof ArrayBuffer) {\n    gltf = new Uint8Array(gltf);\n  }\n\n  if (gltf instanceof Uint8Array) {\n    // Parse and update binary glTF\n    gltf = parseGlb(gltf);\n    updateVersion(gltf);\n    addDefaults(gltf);\n    processModelMaterialsCommon(gltf);\n    processPbrMaterials(gltf);\n  } else {\n    throw new RuntimeError(\"Only binary glTF is supported as a classifier.\");\n  }\n\n  ForEach.buffer(gltf, function (buffer) {\n    if (!defined(buffer.extras._pipeline.source)) {\n      throw new RuntimeError(\n        \"Buffer data must be embedded in the binary gltf.\"\n      );\n    }\n  });\n\n  var gltfNodes = gltf.nodes;\n  var gltfMeshes = gltf.meshes;\n\n  var gltfNode = gltfNodes[0];\n  var meshId = gltfNode.mesh;\n  if (gltfNodes.length !== 1 || !defined(meshId)) {\n    throw new RuntimeError(\n      \"Only one node is supported for classification and it must have a mesh.\"\n    );\n  }\n\n  if (gltfMeshes.length !== 1) {\n    throw new RuntimeError(\n      \"Only one mesh is supported when using b3dm for classification.\"\n    );\n  }\n\n  var gltfPrimitives = gltfMeshes[0].primitives;\n  if (gltfPrimitives.length !== 1) {\n    throw new RuntimeError(\n      \"Only one primitive per mesh is supported when using b3dm for classification.\"\n    );\n  }\n\n  var gltfPositionAttribute = gltfPrimitives[0].attributes.POSITION;\n  if (!defined(gltfPositionAttribute)) {\n    throw new RuntimeError(\"The mesh must have a position attribute.\");\n  }\n\n  var gltfBatchIdAttribute = gltfPrimitives[0].attributes._BATCHID;\n  if (!defined(gltfBatchIdAttribute)) {\n    throw new RuntimeError(\"The mesh must have a batch id attribute.\");\n  }\n\n  this._gltf = gltf;\n\n  /**\n   * Determines if the model primitive will be shown.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  /**\n   * The 4x4 transformation matrix that transforms the model from model to world coordinates.\n   * When this is the identity matrix, the model is drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type {Matrix4}\n   *\n   * @default {@link Matrix4.IDENTITY}\n   *\n   * @example\n   * var origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n   * m.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);\n   */\n  this.modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY)\n  );\n  this._modelMatrix = Matrix4.clone(this.modelMatrix);\n\n  this._ready = false;\n  this._readyPromise = when.defer();\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the model.  A glTF primitive corresponds\n   * to one draw command.  A glTF mesh has an array of primitives, often of length one.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false\n  );\n  this._debugShowBoundingVolume = false;\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the model in wireframe.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugWireframe = defaultValue(options.debugWireframe, false);\n  this._debugWireframe = false;\n\n  this._classificationType = options.classificationType;\n\n  // Undocumented options\n  this._vertexShaderLoaded = options.vertexShaderLoaded;\n  this._classificationShaderLoaded = options.classificationShaderLoaded;\n  this._uniformMapLoaded = options.uniformMapLoaded;\n  this._pickIdLoaded = options.pickIdLoaded;\n  this._ignoreCommands = defaultValue(options.ignoreCommands, false);\n  this._upAxis = defaultValue(options.upAxis, Axis.Y);\n  this._batchTable = options.batchTable;\n\n  this._computedModelMatrix = new Matrix4(); // Derived from modelMatrix and axis\n  this._initialRadius = undefined; // Radius without model's scale property, model-matrix scale, animations, or skins\n  this._boundingSphere = undefined;\n  this._scaledBoundingSphere = new BoundingSphere();\n  this._state = ModelState.NEEDS_LOAD;\n  this._loadResources = undefined;\n\n  this._mode = undefined;\n  this._dirty = false; // true when the model was transformed this frame\n\n  this._nodeMatrix = new Matrix4();\n  this._primitive = undefined;\n\n  this._extensionsUsed = undefined; // Cached used glTF extensions\n  this._extensionsRequired = undefined; // Cached required glTF extensions\n  this._quantizedUniforms = undefined; // Quantized uniforms for WEB3D_quantized_attributes\n\n  this._buffers = {};\n  this._vertexArray = undefined;\n  this._shaderProgram = undefined;\n  this._uniformMap = undefined;\n\n  this._geometryByteLength = 0;\n  this._trianglesLength = 0;\n\n  // CESIUM_RTC extension\n  this._rtcCenter = undefined; // reference to either 3D or 2D\n  this._rtcCenterEye = undefined; // in eye coordinates\n  this._rtcCenter3D = undefined; // in world coordinates\n  this._rtcCenter2D = undefined; // in projected world coordinates\n}\n\nObject.defineProperties(ClassificationModel.prototype, {\n  /**\n   * The object for the glTF JSON, including properties with default values omitted\n   * from the JSON provided to this model.\n   *\n   * @memberof ClassificationModel.prototype\n   *\n   * @type {Object}\n   * @readonly\n   *\n   * @default undefined\n   */\n  gltf: {\n    get: function () {\n      return this._gltf;\n    },\n  },\n\n  /**\n   * The model's bounding sphere in its local coordinate system.\n   *\n   * @memberof ClassificationModel.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   *\n   * @default undefined\n   *\n   * @exception {DeveloperError} The model is not loaded.  Use ClassificationModel.readyPromise or wait for ClassificationModel.ready to be true.\n   *\n   * @example\n   * // Center in WGS84 coordinates\n   * var center = Cesium.Matrix4.multiplyByPoint(model.modelMatrix, model.boundingSphere.center, new Cesium.Cartesian3());\n   */\n  boundingSphere: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (this._state !== ModelState.LOADED) {\n        throw new DeveloperError(\n          \"The model is not loaded.  Use ClassificationModel.readyPromise or wait for ClassificationModel.ready to be true.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      var modelMatrix = this.modelMatrix;\n      var nonUniformScale = Matrix4.getScale(\n        modelMatrix,\n        boundingSphereCartesian3Scratch\n      );\n\n      var scaledBoundingSphere = this._scaledBoundingSphere;\n      scaledBoundingSphere.center = Cartesian3.multiplyComponents(\n        this._boundingSphere.center,\n        nonUniformScale,\n        scaledBoundingSphere.center\n      );\n      scaledBoundingSphere.radius =\n        Cartesian3.maximumComponent(nonUniformScale) * this._initialRadius;\n\n      if (defined(this._rtcCenter)) {\n        Cartesian3.add(\n          this._rtcCenter,\n          scaledBoundingSphere.center,\n          scaledBoundingSphere.center\n        );\n      }\n\n      return scaledBoundingSphere;\n    },\n  },\n\n  /**\n   * When <code>true</code>, this model is ready to render, i.e., the external binary, image,\n   * and shader files were downloaded and the WebGL resources were created.  This is set to\n   * <code>true</code> right before {@link ClassificationModel#readyPromise} is resolved.\n   *\n   * @memberof ClassificationModel.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets the promise that will be resolved when this model is ready to render, i.e., when the external binary, image,\n   * and shader files were downloaded and the WebGL resources were created.\n   * <p>\n   * This promise is resolved at the end of the frame before the first frame the model is rendered in.\n   * </p>\n   *\n   * @memberof ClassificationModel.prototype\n   * @type {Promise.<ClassificationModel>}\n   * @readonly\n   *\n   * @see ClassificationModel#ready\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n\n  /**\n   * Returns true if the model was transformed this frame\n   *\n   * @memberof ClassificationModel.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @private\n   */\n  dirty: {\n    get: function () {\n      return this._dirty;\n    },\n  },\n\n  /**\n   * Returns an object with all of the glTF extensions used.\n   *\n   * @memberof ClassificationModel.prototype\n   *\n   * @type {Object}\n   * @readonly\n   */\n  extensionsUsed: {\n    get: function () {\n      if (!defined(this._extensionsUsed)) {\n        this._extensionsUsed = ModelUtility.getUsedExtensions(this.gltf);\n      }\n      return this._extensionsUsed;\n    },\n  },\n\n  /**\n   * Returns an object with all of the glTF extensions required.\n   *\n   * @memberof ClassificationModel.prototype\n   *\n   * @type {Object}\n   * @readonly\n   */\n  extensionsRequired: {\n    get: function () {\n      if (!defined(this._extensionsRequired)) {\n        this._extensionsRequired = ModelUtility.getRequiredExtensions(\n          this.gltf\n        );\n      }\n      return this._extensionsRequired;\n    },\n  },\n\n  /**\n   * Gets the model's up-axis.\n   * By default models are y-up according to the glTF spec, however geo-referenced models will typically be z-up.\n   *\n   * @memberof ClassificationModel.prototype\n   *\n   * @type {Number}\n   * @default Axis.Y\n   * @readonly\n   *\n   * @private\n   */\n  upAxis: {\n    get: function () {\n      return this._upAxis;\n    },\n  },\n\n  /**\n   * Gets the model's triangle count.\n   *\n   * @private\n   */\n  trianglesLength: {\n    get: function () {\n      return this._trianglesLength;\n    },\n  },\n\n  /**\n   * Gets the model's geometry memory in bytes. This includes all vertex and index buffers.\n   *\n   * @private\n   */\n  geometryByteLength: {\n    get: function () {\n      return this._geometryByteLength;\n    },\n  },\n\n  /**\n   * Gets the model's texture memory in bytes.\n   *\n   * @private\n   */\n  texturesByteLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  /**\n   * Gets the model's classification type.\n   * @memberof ClassificationModel.prototype\n   * @type {ClassificationType}\n   */\n  classificationType: {\n    get: function () {\n      return this._classificationType;\n    },\n  },\n});\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction addBuffersToLoadResources(model) {\n  var gltf = model.gltf;\n  var loadResources = model._loadResources;\n  ForEach.buffer(gltf, function (buffer, id) {\n    loadResources.buffers[id] = buffer.extras._pipeline.source;\n  });\n}\n\nfunction parseBufferViews(model) {\n  var bufferViews = model.gltf.bufferViews;\n\n  var vertexBuffersToCreate = model._loadResources.vertexBuffersToCreate;\n\n  // Only ARRAY_BUFFER here.  ELEMENT_ARRAY_BUFFER created below.\n  ForEach.bufferView(model.gltf, function (bufferView, id) {\n    if (bufferView.target === WebGLConstants.ARRAY_BUFFER) {\n      vertexBuffersToCreate.enqueue(id);\n    }\n  });\n\n  var indexBuffersToCreate = model._loadResources.indexBuffersToCreate;\n  var indexBufferIds = {};\n\n  // The Cesium Renderer requires knowing the datatype for an index buffer\n  // at creation type, which is not part of the glTF bufferview so loop\n  // through glTF accessors to create the bufferview's index buffer.\n  ForEach.accessor(model.gltf, function (accessor) {\n    var bufferViewId = accessor.bufferView;\n    var bufferView = bufferViews[bufferViewId];\n\n    if (\n      bufferView.target === WebGLConstants.ELEMENT_ARRAY_BUFFER &&\n      !defined(indexBufferIds[bufferViewId])\n    ) {\n      indexBufferIds[bufferViewId] = true;\n      indexBuffersToCreate.enqueue({\n        id: bufferViewId,\n        componentType: accessor.componentType,\n      });\n    }\n  });\n}\n\nfunction createVertexBuffer(bufferViewId, model) {\n  var loadResources = model._loadResources;\n  var bufferViews = model.gltf.bufferViews;\n  var bufferView = bufferViews[bufferViewId];\n  var vertexBuffer = loadResources.getBuffer(bufferView);\n  model._buffers[bufferViewId] = vertexBuffer;\n  model._geometryByteLength += vertexBuffer.byteLength;\n}\n\nfunction createIndexBuffer(bufferViewId, componentType, model) {\n  var loadResources = model._loadResources;\n  var bufferViews = model.gltf.bufferViews;\n  var bufferView = bufferViews[bufferViewId];\n  var indexBuffer = {\n    typedArray: loadResources.getBuffer(bufferView),\n    indexDatatype: componentType,\n  };\n  model._buffers[bufferViewId] = indexBuffer;\n  model._geometryByteLength += indexBuffer.typedArray.byteLength;\n}\n\nfunction createBuffers(model) {\n  var loadResources = model._loadResources;\n\n  if (loadResources.pendingBufferLoads !== 0) {\n    return;\n  }\n\n  var vertexBuffersToCreate = loadResources.vertexBuffersToCreate;\n  var indexBuffersToCreate = loadResources.indexBuffersToCreate;\n\n  while (vertexBuffersToCreate.length > 0) {\n    createVertexBuffer(vertexBuffersToCreate.dequeue(), model);\n  }\n\n  while (indexBuffersToCreate.length > 0) {\n    var i = indexBuffersToCreate.dequeue();\n    createIndexBuffer(i.id, i.componentType, model);\n  }\n}\n\nfunction modifyShaderForQuantizedAttributes(shader, model) {\n  var primitive = model.gltf.meshes[0].primitives[0];\n  var result = ModelUtility.modifyShaderForQuantizedAttributes(\n    model.gltf,\n    primitive,\n    shader\n  );\n  model._quantizedUniforms = result.uniforms;\n  return result.shader;\n}\n\nfunction modifyShader(shader, callback) {\n  if (defined(callback)) {\n    shader = callback(shader);\n  }\n  return shader;\n}\n\nfunction createProgram(model) {\n  var gltf = model.gltf;\n\n  var positionName = ModelUtility.getAttributeOrUniformBySemantic(\n    gltf,\n    \"POSITION\"\n  );\n  var batchIdName = ModelUtility.getAttributeOrUniformBySemantic(\n    gltf,\n    \"_BATCHID\"\n  );\n\n  var attributeLocations = {};\n  attributeLocations[positionName] = 0;\n  attributeLocations[batchIdName] = 1;\n\n  var modelViewProjectionName = ModelUtility.getAttributeOrUniformBySemantic(\n    gltf,\n    \"MODELVIEWPROJECTION\"\n  );\n\n  var uniformDecl;\n  var toClip;\n\n  if (!defined(modelViewProjectionName)) {\n    var projectionName = ModelUtility.getAttributeOrUniformBySemantic(\n      gltf,\n      \"PROJECTION\"\n    );\n    var modelViewName = ModelUtility.getAttributeOrUniformBySemantic(\n      gltf,\n      \"MODELVIEW\"\n    );\n    if (!defined(modelViewName)) {\n      modelViewName = ModelUtility.getAttributeOrUniformBySemantic(\n        gltf,\n        \"CESIUM_RTC_MODELVIEW\"\n      );\n    }\n\n    uniformDecl =\n      \"uniform mat4 \" +\n      modelViewName +\n      \";\\n\" +\n      \"uniform mat4 \" +\n      projectionName +\n      \";\\n\";\n    toClip =\n      projectionName +\n      \" * \" +\n      modelViewName +\n      \" * vec4(\" +\n      positionName +\n      \", 1.0)\";\n  } else {\n    uniformDecl = \"uniform mat4 \" + modelViewProjectionName + \";\\n\";\n    toClip = modelViewProjectionName + \" * vec4(\" + positionName + \", 1.0)\";\n  }\n\n  var computePosition = \"    vec4 positionInClipCoords = \" + toClip + \";\\n\";\n\n  var vs =\n    \"attribute vec3 \" +\n    positionName +\n    \";\\n\" +\n    \"attribute float \" +\n    batchIdName +\n    \";\\n\" +\n    uniformDecl +\n    \"void main() {\\n\" +\n    computePosition +\n    \"    gl_Position = czm_depthClampFarPlane(positionInClipCoords);\\n\" +\n    \"}\\n\";\n  var fs =\n    \"#ifdef GL_EXT_frag_depth\\n\" +\n    \"#extension GL_EXT_frag_depth : enable\\n\" +\n    \"#endif\\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    gl_FragColor = vec4(1.0); \\n\" +\n    \"    czm_writeDepthClampedToFarPlane();\\n\" +\n    \"}\\n\";\n\n  if (model.extensionsUsed.WEB3D_quantized_attributes) {\n    vs = modifyShaderForQuantizedAttributes(vs, model);\n  }\n\n  var drawVS = modifyShader(vs, model._vertexShaderLoaded);\n  var drawFS = modifyShader(fs, model._classificationShaderLoaded);\n\n  drawVS = ModelUtility.modifyVertexShaderForLogDepth(drawVS, toClip);\n  drawFS = ModelUtility.modifyFragmentShaderForLogDepth(drawFS);\n\n  model._shaderProgram = {\n    vertexShaderSource: drawVS,\n    fragmentShaderSource: drawFS,\n    attributeLocations: attributeLocations,\n  };\n}\n\nfunction getAttributeLocations() {\n  return {\n    POSITION: 0,\n    _BATCHID: 1,\n  };\n}\n\nfunction createVertexArray(model) {\n  var loadResources = model._loadResources;\n  if (!loadResources.finishedBuffersCreation() || defined(model._vertexArray)) {\n    return;\n  }\n\n  var rendererBuffers = model._buffers;\n  var gltf = model.gltf;\n  var accessors = gltf.accessors;\n  var meshes = gltf.meshes;\n  var primitives = meshes[0].primitives;\n\n  var primitive = primitives[0];\n  var attributeLocations = getAttributeLocations();\n  var attributes = {};\n  ForEach.meshPrimitiveAttribute(primitive, function (\n    accessorId,\n    attributeName\n  ) {\n    // Skip if the attribute is not used by the material, e.g., because the asset\n    // was exported with an attribute that wasn't used and the asset wasn't optimized.\n    var attributeLocation = attributeLocations[attributeName];\n    if (defined(attributeLocation)) {\n      var a = accessors[accessorId];\n      attributes[attributeName] = {\n        index: attributeLocation,\n        vertexBuffer: rendererBuffers[a.bufferView],\n        componentsPerAttribute: numberOfComponentsForType(a.type),\n        componentDatatype: a.componentType,\n        offsetInBytes: a.byteOffset,\n        strideInBytes: getAccessorByteStride(gltf, a),\n      };\n    }\n  });\n\n  var indexBuffer;\n  if (defined(primitive.indices)) {\n    var accessor = accessors[primitive.indices];\n    indexBuffer = rendererBuffers[accessor.bufferView];\n  }\n  model._vertexArray = {\n    attributes: attributes,\n    indexBuffer: indexBuffer,\n  };\n}\n\nvar gltfSemanticUniforms = {\n  PROJECTION: function (uniformState, model) {\n    return ModelUtility.getGltfSemanticUniforms().PROJECTION(\n      uniformState,\n      model\n    );\n  },\n  MODELVIEW: function (uniformState, model) {\n    return ModelUtility.getGltfSemanticUniforms().MODELVIEW(\n      uniformState,\n      model\n    );\n  },\n  CESIUM_RTC_MODELVIEW: function (uniformState, model) {\n    return ModelUtility.getGltfSemanticUniforms().CESIUM_RTC_MODELVIEW(\n      uniformState,\n      model\n    );\n  },\n  MODELVIEWPROJECTION: function (uniformState, model) {\n    return ModelUtility.getGltfSemanticUniforms().MODELVIEWPROJECTION(\n      uniformState,\n      model\n    );\n  },\n};\n\nfunction createUniformMap(model, context) {\n  if (defined(model._uniformMap)) {\n    return;\n  }\n\n  var uniformMap = {};\n  ForEach.technique(model.gltf, function (technique) {\n    ForEach.techniqueUniform(technique, function (uniform, uniformName) {\n      if (\n        !defined(uniform.semantic) ||\n        !defined(gltfSemanticUniforms[uniform.semantic])\n      ) {\n        return;\n      }\n\n      uniformMap[uniformName] = gltfSemanticUniforms[uniform.semantic](\n        context.uniformState,\n        model\n      );\n    });\n  });\n\n  model._uniformMap = uniformMap;\n}\n\nfunction createUniformsForQuantizedAttributes(model, primitive) {\n  return ModelUtility.createUniformsForQuantizedAttributes(\n    model.gltf,\n    primitive,\n    model._quantizedUniforms\n  );\n}\n\nfunction triangleCountFromPrimitiveIndices(primitive, indicesCount) {\n  switch (primitive.mode) {\n    case PrimitiveType.TRIANGLES:\n      return indicesCount / 3;\n    case PrimitiveType.TRIANGLE_STRIP:\n    case PrimitiveType.TRIANGLE_FAN:\n      return Math.max(indicesCount - 2, 0);\n    default:\n      return 0;\n  }\n}\n\nfunction createPrimitive(model) {\n  var batchTable = model._batchTable;\n\n  var uniformMap = model._uniformMap;\n  var vertexArray = model._vertexArray;\n\n  var gltf = model.gltf;\n  var accessors = gltf.accessors;\n  var gltfMeshes = gltf.meshes;\n  var primitive = gltfMeshes[0].primitives[0];\n  var ix = accessors[primitive.indices];\n\n  var positionAccessor = primitive.attributes.POSITION;\n  var minMax = ModelUtility.getAccessorMinMax(gltf, positionAccessor);\n  var boundingSphere = BoundingSphere.fromCornerPoints(\n    Cartesian3.fromArray(minMax.min),\n    Cartesian3.fromArray(minMax.max)\n  );\n\n  var offset;\n  var count;\n  if (defined(ix)) {\n    count = ix.count;\n    offset = ix.byteOffset / IndexDatatype.getSizeInBytes(ix.componentType); // glTF has offset in bytes.  Cesium has offsets in indices\n  } else {\n    var positions = accessors[primitive.attributes.POSITION];\n    count = positions.count;\n    offset = 0;\n  }\n\n  // Update model triangle count using number of indices\n  model._trianglesLength += triangleCountFromPrimitiveIndices(primitive, count);\n\n  // Allow callback to modify the uniformMap\n  if (defined(model._uniformMapLoaded)) {\n    uniformMap = model._uniformMapLoaded(uniformMap);\n  }\n\n  // Add uniforms for decoding quantized attributes if used\n  if (model.extensionsUsed.WEB3D_quantized_attributes) {\n    var quantizedUniformMap = createUniformsForQuantizedAttributes(\n      model,\n      primitive\n    );\n    uniformMap = combine(uniformMap, quantizedUniformMap);\n  }\n\n  var attribute = vertexArray.attributes.POSITION;\n  var componentDatatype = attribute.componentDatatype;\n  var typedArray = attribute.vertexBuffer;\n  var byteOffset = typedArray.byteOffset;\n  var bufferLength =\n    typedArray.byteLength / ComponentDatatype.getSizeInBytes(componentDatatype);\n  var positionsBuffer = ComponentDatatype.createArrayBufferView(\n    componentDatatype,\n    typedArray.buffer,\n    byteOffset,\n    bufferLength\n  );\n\n  attribute = vertexArray.attributes._BATCHID;\n  componentDatatype = attribute.componentDatatype;\n  typedArray = attribute.vertexBuffer;\n  byteOffset = typedArray.byteOffset;\n  bufferLength =\n    typedArray.byteLength / ComponentDatatype.getSizeInBytes(componentDatatype);\n  var vertexBatchIds = ComponentDatatype.createArrayBufferView(\n    componentDatatype,\n    typedArray.buffer,\n    byteOffset,\n    bufferLength\n  );\n\n  var buffer = vertexArray.indexBuffer.typedArray;\n  var indices;\n  if (vertexArray.indexBuffer.indexDatatype === IndexDatatype.UNSIGNED_SHORT) {\n    indices = new Uint16Array(\n      buffer.buffer,\n      buffer.byteOffset,\n      buffer.byteLength / Uint16Array.BYTES_PER_ELEMENT\n    );\n  } else {\n    indices = new Uint32Array(\n      buffer.buffer,\n      buffer.byteOffset,\n      buffer.byteLength / Uint32Array.BYTES_PER_ELEMENT\n    );\n  }\n\n  positionsBuffer = arraySlice(positionsBuffer);\n  vertexBatchIds = arraySlice(vertexBatchIds);\n  indices = arraySlice(indices, offset, offset + count);\n\n  var batchIds = [];\n  var indexCounts = [];\n  var indexOffsets = [];\n  var batchedIndices = [];\n\n  var currentId = vertexBatchIds[indices[0]];\n  batchIds.push(currentId);\n  indexOffsets.push(0);\n\n  var batchId;\n  var indexOffset;\n  var indexCount;\n  var indicesLength = indices.length;\n  for (var j = 1; j < indicesLength; ++j) {\n    batchId = vertexBatchIds[indices[j]];\n    if (batchId !== currentId) {\n      indexOffset = indexOffsets[indexOffsets.length - 1];\n      indexCount = j - indexOffset;\n\n      batchIds.push(batchId);\n      indexCounts.push(indexCount);\n      indexOffsets.push(j);\n\n      batchedIndices.push(\n        new Vector3DTileBatch({\n          offset: indexOffset,\n          count: indexCount,\n          batchIds: [currentId],\n          color: Color.WHITE,\n        })\n      );\n\n      currentId = batchId;\n    }\n  }\n\n  indexOffset = indexOffsets[indexOffsets.length - 1];\n  indexCount = indicesLength - indexOffset;\n\n  indexCounts.push(indexCount);\n  batchedIndices.push(\n    new Vector3DTileBatch({\n      offset: indexOffset,\n      count: indexCount,\n      batchIds: [currentId],\n      color: Color.WHITE,\n    })\n  );\n\n  var shader = model._shaderProgram;\n  var vertexShaderSource = shader.vertexShaderSource;\n  var fragmentShaderSource = shader.fragmentShaderSource;\n  var attributeLocations = shader.attributeLocations;\n  var pickId = defined(model._pickIdLoaded) ? model._pickIdLoaded() : undefined;\n\n  model._primitive = new Vector3DTilePrimitive({\n    classificationType: model._classificationType,\n    positions: positionsBuffer,\n    indices: indices,\n    indexOffsets: indexOffsets,\n    indexCounts: indexCounts,\n    batchIds: batchIds,\n    vertexBatchIds: vertexBatchIds,\n    batchedIndices: batchedIndices,\n    batchTable: batchTable,\n    boundingVolume: new BoundingSphere(), // updated in update()\n    _vertexShaderSource: vertexShaderSource,\n    _fragmentShaderSource: fragmentShaderSource,\n    _attributeLocations: attributeLocations,\n    _uniformMap: uniformMap,\n    _pickId: pickId,\n    _modelMatrix: new Matrix4(), // updated in update()\n    _boundingSphere: boundingSphere, // used to update boundingVolume\n  });\n\n  // Release CPU resources\n  model._buffers = undefined;\n  model._vertexArray = undefined;\n  model._shaderProgram = undefined;\n  model._uniformMap = undefined;\n}\n\nfunction createRuntimeNodes(model) {\n  var loadResources = model._loadResources;\n  if (!loadResources.finished()) {\n    return;\n  }\n\n  if (defined(model._primitive)) {\n    return;\n  }\n\n  var gltf = model.gltf;\n  var nodes = gltf.nodes;\n  var gltfNode = nodes[0];\n  model._nodeMatrix = ModelUtility.getTransform(gltfNode, model._nodeMatrix);\n\n  createPrimitive(model);\n}\n\nfunction createResources(model, frameState) {\n  var context = frameState.context;\n\n  ModelUtility.checkSupportedGlExtensions(model.gltf.glExtensionsUsed, context);\n  createBuffers(model); // using glTF bufferViews\n  createProgram(model);\n  createVertexArray(model); // using glTF meshes\n  createUniformMap(model, context); // using glTF materials/techniques\n  createRuntimeNodes(model); // using glTF scene\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nvar scratchComputedTranslation = new Cartesian4();\nvar scratchComputedMatrixIn2D = new Matrix4();\n\nfunction updateNodeModelMatrix(\n  model,\n  modelTransformChanged,\n  justLoaded,\n  projection\n) {\n  var computedModelMatrix = model._computedModelMatrix;\n\n  if (model._mode !== SceneMode.SCENE3D && !model._ignoreCommands) {\n    var translation = Matrix4.getColumn(\n      computedModelMatrix,\n      3,\n      scratchComputedTranslation\n    );\n    if (!Cartesian4.equals(translation, Cartesian4.UNIT_W)) {\n      computedModelMatrix = Transforms.basisTo2D(\n        projection,\n        computedModelMatrix,\n        scratchComputedMatrixIn2D\n      );\n      model._rtcCenter = model._rtcCenter3D;\n    } else {\n      var center = model.boundingSphere.center;\n      var to2D = Transforms.wgs84To2DModelMatrix(\n        projection,\n        center,\n        scratchComputedMatrixIn2D\n      );\n      computedModelMatrix = Matrix4.multiply(\n        to2D,\n        computedModelMatrix,\n        scratchComputedMatrixIn2D\n      );\n\n      if (defined(model._rtcCenter)) {\n        Matrix4.setTranslation(\n          computedModelMatrix,\n          Cartesian4.UNIT_W,\n          computedModelMatrix\n        );\n        model._rtcCenter = model._rtcCenter2D;\n      }\n    }\n  }\n\n  var primitive = model._primitive;\n\n  if (modelTransformChanged || justLoaded) {\n    Matrix4.multiplyTransformation(\n      computedModelMatrix,\n      model._nodeMatrix,\n      primitive._modelMatrix\n    );\n    BoundingSphere.transform(\n      primitive._boundingSphere,\n      primitive._modelMatrix,\n      primitive._boundingVolume\n    );\n\n    if (defined(model._rtcCenter)) {\n      Cartesian3.add(\n        model._rtcCenter,\n        primitive._boundingVolume.center,\n        primitive._boundingVolume.center\n      );\n    }\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nClassificationModel.prototype.updateCommands = function (batchId, color) {\n  this._primitive.updateCommands(batchId, color);\n};\n\nClassificationModel.prototype.update = function (frameState) {\n  if (frameState.mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  if (!FeatureDetection.supportsWebP.initialized) {\n    FeatureDetection.supportsWebP.initialize();\n    return;\n  }\n  var supportsWebP = FeatureDetection.supportsWebP();\n\n  if (this._state === ModelState.NEEDS_LOAD && defined(this.gltf)) {\n    this._state = ModelState.LOADING;\n    if (this._state !== ModelState.FAILED) {\n      var extensions = this.gltf.extensions;\n      if (defined(extensions) && defined(extensions.CESIUM_RTC)) {\n        var center = Cartesian3.fromArray(extensions.CESIUM_RTC.center);\n        if (!Cartesian3.equals(center, Cartesian3.ZERO)) {\n          this._rtcCenter3D = center;\n\n          var projection = frameState.mapProjection;\n          var ellipsoid = projection.ellipsoid;\n          var cartographic = ellipsoid.cartesianToCartographic(\n            this._rtcCenter3D\n          );\n          var projectedCart = projection.project(cartographic);\n          Cartesian3.fromElements(\n            projectedCart.z,\n            projectedCart.x,\n            projectedCart.y,\n            projectedCart\n          );\n          this._rtcCenter2D = projectedCart;\n\n          this._rtcCenterEye = new Cartesian3();\n          this._rtcCenter = this._rtcCenter3D;\n        }\n      }\n\n      this._loadResources = new ModelLoadResources();\n      ModelUtility.parseBuffers(this);\n    }\n  }\n\n  var loadResources = this._loadResources;\n  var justLoaded = false;\n\n  if (this._state === ModelState.LOADING) {\n    // Transition from LOADING -> LOADED once resources are downloaded and created.\n    // Textures may continue to stream in while in the LOADED state.\n    if (loadResources.pendingBufferLoads === 0) {\n      ModelUtility.checkSupportedExtensions(\n        this.extensionsRequired,\n        supportsWebP\n      );\n\n      addBuffersToLoadResources(this);\n      parseBufferViews(this);\n\n      this._boundingSphere = ModelUtility.computeBoundingSphere(this);\n      this._initialRadius = this._boundingSphere.radius;\n      createResources(this, frameState);\n    }\n    if (loadResources.finished()) {\n      this._state = ModelState.LOADED;\n      justLoaded = true;\n    }\n  }\n\n  if (defined(loadResources) && this._state === ModelState.LOADED) {\n    if (!justLoaded) {\n      createResources(this, frameState);\n    }\n\n    if (loadResources.finished()) {\n      this._loadResources = undefined; // Clear CPU memory since WebGL resources were created.\n    }\n  }\n\n  var show = this.show;\n\n  if ((show && this._state === ModelState.LOADED) || justLoaded) {\n    this._dirty = false;\n    var modelMatrix = this.modelMatrix;\n\n    var modeChanged = frameState.mode !== this._mode;\n    this._mode = frameState.mode;\n\n    // ClassificationModel's model matrix needs to be updated\n    var modelTransformChanged =\n      !Matrix4.equals(this._modelMatrix, modelMatrix) || modeChanged;\n\n    if (modelTransformChanged || justLoaded) {\n      Matrix4.clone(modelMatrix, this._modelMatrix);\n\n      var computedModelMatrix = this._computedModelMatrix;\n      Matrix4.clone(modelMatrix, computedModelMatrix);\n      if (this._upAxis === Axis.Y) {\n        Matrix4.multiplyTransformation(\n          computedModelMatrix,\n          Axis.Y_UP_TO_Z_UP,\n          computedModelMatrix\n        );\n      } else if (this._upAxis === Axis.X) {\n        Matrix4.multiplyTransformation(\n          computedModelMatrix,\n          Axis.X_UP_TO_Z_UP,\n          computedModelMatrix\n        );\n      }\n    }\n\n    // Update modelMatrix throughout the graph as needed\n    if (modelTransformChanged || justLoaded) {\n      updateNodeModelMatrix(\n        this,\n        modelTransformChanged,\n        justLoaded,\n        frameState.mapProjection\n      );\n      this._dirty = true;\n    }\n  }\n\n  if (justLoaded) {\n    // Called after modelMatrix update.\n    var model = this;\n    frameState.afterRender.push(function () {\n      model._ready = true;\n      model._readyPromise.resolve(model);\n    });\n    return;\n  }\n\n  if (show && !this._ignoreCommands) {\n    this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume;\n    this._primitive.debugWireframe = this.debugWireframe;\n    this._primitive.update(frameState);\n  }\n};\n\nClassificationModel.prototype.isDestroyed = function () {\n  return false;\n};\n\nClassificationModel.prototype.destroy = function () {\n  this._primitive = this._primitive && this._primitive.destroy();\n  return destroyObject(this);\n};\nexport default ClassificationModel;\n"]},"metadata":{},"sourceType":"module"}