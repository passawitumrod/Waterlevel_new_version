{"ast":null,"code":"import when from \"../ThirdParty/when.js\";\nimport Credit from \"./Credit.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Event from \"./Event.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport getImagePixels from \"./getImagePixels.js\";\nimport HeightmapTerrainData from \"./HeightmapTerrainData.js\";\nimport CesiumMath from \"./Math.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Resource from \"./Resource.js\";\nimport TerrainProvider from \"./TerrainProvider.js\";\nimport TileProviderError from \"./TileProviderError.js\";\n\nfunction DataRectangle(rectangle, maxLevel) {\n  this.rectangle = rectangle;\n  this.maxLevel = maxLevel;\n}\n/**\n * A {@link TerrainProvider} that produces terrain geometry by tessellating height maps\n * retrieved from a {@link http://vr-theworld.com/|VT MÃ„K VR-TheWorld server}.\n *\n * @alias VRTheWorldTerrainProvider\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource|String} options.url The URL of the VR-TheWorld TileMap.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid.  If this parameter is not\n *                    specified, the WGS84 ellipsoid is used.\n * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.\n *\n *\n * @example\n * var terrainProvider = new Cesium.VRTheWorldTerrainProvider({\n *   url : 'https://www.vr-theworld.com/vr-theworld/tiles1.0.0/73/'\n * });\n * viewer.terrainProvider = terrainProvider;\n *\n * @see TerrainProvider\n */\n\n\nfunction VRTheWorldTerrainProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(options.url)) {\n    throw new DeveloperError(\"options.url is required.\");\n  } //>>includeEnd('debug');\n\n\n  var resource = Resource.createIfNeeded(options.url);\n  this._resource = resource;\n  this._errorEvent = new Event();\n  this._ready = false;\n  this._readyPromise = when.defer();\n  this._terrainDataStructure = {\n    heightScale: 1.0 / 1000.0,\n    heightOffset: -1000.0,\n    elementsPerHeight: 3,\n    stride: 4,\n    elementMultiplier: 256.0,\n    isBigEndian: true,\n    lowestEncodedHeight: 0,\n    highestEncodedHeight: 256 * 256 * 256 - 1\n  };\n  var credit = options.credit;\n\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n\n  this._credit = credit;\n  this._tilingScheme = undefined;\n  this._rectangles = [];\n  var that = this;\n  var metadataError;\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n\n  function metadataSuccess(xml) {\n    var srs = xml.getElementsByTagName(\"SRS\")[0].textContent;\n\n    if (srs === \"EPSG:4326\") {\n      that._tilingScheme = new GeographicTilingScheme({\n        ellipsoid: ellipsoid\n      });\n    } else {\n      metadataFailure(\"SRS \" + srs + \" is not supported.\");\n      return;\n    }\n\n    var tileFormat = xml.getElementsByTagName(\"TileFormat\")[0];\n    that._heightmapWidth = parseInt(tileFormat.getAttribute(\"width\"), 10);\n    that._heightmapHeight = parseInt(tileFormat.getAttribute(\"height\"), 10);\n    that._levelZeroMaximumGeometricError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(ellipsoid, Math.min(that._heightmapWidth, that._heightmapHeight), that._tilingScheme.getNumberOfXTilesAtLevel(0));\n    var dataRectangles = xml.getElementsByTagName(\"DataExtent\");\n\n    for (var i = 0; i < dataRectangles.length; ++i) {\n      var dataRectangle = dataRectangles[i];\n      var west = CesiumMath.toRadians(parseFloat(dataRectangle.getAttribute(\"minx\")));\n      var south = CesiumMath.toRadians(parseFloat(dataRectangle.getAttribute(\"miny\")));\n      var east = CesiumMath.toRadians(parseFloat(dataRectangle.getAttribute(\"maxx\")));\n      var north = CesiumMath.toRadians(parseFloat(dataRectangle.getAttribute(\"maxy\")));\n      var maxLevel = parseInt(dataRectangle.getAttribute(\"maxlevel\"), 10);\n\n      that._rectangles.push(new DataRectangle(new Rectangle(west, south, east, north), maxLevel));\n    }\n\n    that._ready = true;\n\n    that._readyPromise.resolve(true);\n  }\n\n  function metadataFailure(e) {\n    var message = defaultValue(e, \"An error occurred while accessing \" + that._resource.url + \".\");\n    metadataError = TileProviderError.handleError(metadataError, that, that._errorEvent, message, undefined, undefined, undefined, requestMetadata);\n  }\n\n  function requestMetadata() {\n    when(that._resource.fetchXML(), metadataSuccess, metadataFailure);\n  }\n\n  requestMetadata();\n}\n\nObject.defineProperties(VRTheWorldTerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    }\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.  This function should not be called before {@link VRTheWorldTerrainProvider#ready} returns true.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {Credit}\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    }\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.  This function should\n   * not be called before {@link VRTheWorldTerrainProvider#ready} returns true.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {GeographicTilingScheme}\n   */\n  tilingScheme: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this.ready) {\n        throw new DeveloperError(\"requestTileGeometry must not be called before ready returns true.\");\n      } //>>includeEnd('debug');\n\n\n      return this._tilingScheme;\n    }\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {Boolean}\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    }\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.  This function should not be\n   * called before {@link VRTheWorldTerrainProvider#ready} returns true.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {Boolean}\n   */\n  hasWaterMask: {\n    get: function () {\n      return false;\n    }\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * This function should not be called before {@link VRTheWorldTerrainProvider#ready} returns true.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {Boolean}\n   */\n  hasVertexNormals: {\n    get: function () {\n      return false;\n    }\n  }\n});\n/**\n * Requests the geometry for a given tile.  This function should not be called before\n * {@link VRTheWorldTerrainProvider#ready} returns true.  The result includes terrain\n * data and indicates that all child tiles are available.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n */\n\nVRTheWorldTerrainProvider.prototype.requestTileGeometry = function (x, y, level, request) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this.ready) {\n    throw new DeveloperError(\"requestTileGeometry must not be called before ready returns true.\");\n  } //>>includeEnd('debug');\n\n\n  var yTiles = this._tilingScheme.getNumberOfYTilesAtLevel(level);\n\n  var resource = this._resource.getDerivedResource({\n    url: level + \"/\" + x + \"/\" + (yTiles - y - 1) + \".tif\",\n    queryParameters: {\n      cesium: true\n    },\n    request: request\n  });\n\n  var promise = resource.fetchImage({\n    preferImageBitmap: true\n  });\n\n  if (!defined(promise)) {\n    return undefined;\n  }\n\n  var that = this;\n  return when(promise).then(function (image) {\n    return new HeightmapTerrainData({\n      buffer: getImagePixels(image),\n      width: that._heightmapWidth,\n      height: that._heightmapHeight,\n      childTileMask: getChildMask(that, x, y, level),\n      structure: that._terrainDataStructure\n    });\n  });\n};\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n *\n * @param {Number} level The tile level for which to get the maximum geometric error.\n * @returns {Number} The maximum geometric error.\n */\n\n\nVRTheWorldTerrainProvider.prototype.getLevelMaximumGeometricError = function (level) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this.ready) {\n    throw new DeveloperError(\"requestTileGeometry must not be called before ready returns true.\");\n  } //>>includeEnd('debug');\n\n\n  return this._levelZeroMaximumGeometricError / (1 << level);\n};\n\nvar rectangleScratch = new Rectangle();\n\nfunction getChildMask(provider, x, y, level) {\n  var tilingScheme = provider._tilingScheme;\n  var rectangles = provider._rectangles;\n  var parentRectangle = tilingScheme.tileXYToRectangle(x, y, level);\n  var childMask = 0;\n\n  for (var i = 0; i < rectangles.length && childMask !== 15; ++i) {\n    var rectangle = rectangles[i];\n\n    if (rectangle.maxLevel <= level) {\n      continue;\n    }\n\n    var testRectangle = rectangle.rectangle;\n    var intersection = Rectangle.intersection(testRectangle, parentRectangle, rectangleScratch);\n\n    if (defined(intersection)) {\n      // Parent tile is inside this rectangle, so at least one child is, too.\n      if (isTileInRectangle(tilingScheme, testRectangle, x * 2, y * 2, level + 1)) {\n        childMask |= 4; // northwest\n      }\n\n      if (isTileInRectangle(tilingScheme, testRectangle, x * 2 + 1, y * 2, level + 1)) {\n        childMask |= 8; // northeast\n      }\n\n      if (isTileInRectangle(tilingScheme, testRectangle, x * 2, y * 2 + 1, level + 1)) {\n        childMask |= 1; // southwest\n      }\n\n      if (isTileInRectangle(tilingScheme, testRectangle, x * 2 + 1, y * 2 + 1, level + 1)) {\n        childMask |= 2; // southeast\n      }\n    }\n  }\n\n  return childMask;\n}\n\nfunction isTileInRectangle(tilingScheme, rectangle, x, y, level) {\n  var tileRectangle = tilingScheme.tileXYToRectangle(x, y, level);\n  return defined(Rectangle.intersection(tileRectangle, rectangle, rectangleScratch));\n}\n/**\n * Determines whether data for a tile is available to be loaded.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {Boolean} Undefined if not supported, otherwise true or false.\n */\n\n\nVRTheWorldTerrainProvider.prototype.getTileDataAvailable = function (x, y, level) {\n  return undefined;\n};\n/**\n * Makes sure we load availability data for a tile\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {undefined|Promise} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\n */\n\n\nVRTheWorldTerrainProvider.prototype.loadTileDataAvailability = function (x, y, level) {\n  return undefined;\n};\n\nexport default VRTheWorldTerrainProvider;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/VRTheWorldTerrainProvider.js"],"names":["when","Credit","defaultValue","defined","DeveloperError","Ellipsoid","Event","GeographicTilingScheme","getImagePixels","HeightmapTerrainData","CesiumMath","Rectangle","Resource","TerrainProvider","TileProviderError","DataRectangle","rectangle","maxLevel","VRTheWorldTerrainProvider","options","EMPTY_OBJECT","url","resource","createIfNeeded","_resource","_errorEvent","_ready","_readyPromise","defer","_terrainDataStructure","heightScale","heightOffset","elementsPerHeight","stride","elementMultiplier","isBigEndian","lowestEncodedHeight","highestEncodedHeight","credit","_credit","_tilingScheme","undefined","_rectangles","that","metadataError","ellipsoid","WGS84","metadataSuccess","xml","srs","getElementsByTagName","textContent","metadataFailure","tileFormat","_heightmapWidth","parseInt","getAttribute","_heightmapHeight","_levelZeroMaximumGeometricError","getEstimatedLevelZeroGeometricErrorForAHeightmap","Math","min","getNumberOfXTilesAtLevel","dataRectangles","i","length","dataRectangle","west","toRadians","parseFloat","south","east","north","push","resolve","e","message","handleError","requestMetadata","fetchXML","Object","defineProperties","prototype","errorEvent","get","tilingScheme","ready","readyPromise","promise","hasWaterMask","hasVertexNormals","requestTileGeometry","x","y","level","request","yTiles","getNumberOfYTilesAtLevel","getDerivedResource","queryParameters","cesium","fetchImage","preferImageBitmap","then","image","buffer","width","height","childTileMask","getChildMask","structure","getLevelMaximumGeometricError","rectangleScratch","provider","rectangles","parentRectangle","tileXYToRectangle","childMask","testRectangle","intersection","isTileInRectangle","tileRectangle","getTileDataAvailable","loadTileDataAvailability"],"mappings":"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","sourcesContent":["import when from \"../ThirdParty/when.js\";\nimport Credit from \"./Credit.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Event from \"./Event.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport getImagePixels from \"./getImagePixels.js\";\nimport HeightmapTerrainData from \"./HeightmapTerrainData.js\";\nimport CesiumMath from \"./Math.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Resource from \"./Resource.js\";\nimport TerrainProvider from \"./TerrainProvider.js\";\nimport TileProviderError from \"./TileProviderError.js\";\n\nfunction DataRectangle(rectangle, maxLevel) {\n  this.rectangle = rectangle;\n  this.maxLevel = maxLevel;\n}\n\n/**\n * A {@link TerrainProvider} that produces terrain geometry by tessellating height maps\n * retrieved from a {@link http://vr-theworld.com/|VT MÃ„K VR-TheWorld server}.\n *\n * @alias VRTheWorldTerrainProvider\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource|String} options.url The URL of the VR-TheWorld TileMap.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid.  If this parameter is not\n *                    specified, the WGS84 ellipsoid is used.\n * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.\n *\n *\n * @example\n * var terrainProvider = new Cesium.VRTheWorldTerrainProvider({\n *   url : 'https://www.vr-theworld.com/vr-theworld/tiles1.0.0/73/'\n * });\n * viewer.terrainProvider = terrainProvider;\n *\n * @see TerrainProvider\n */\nfunction VRTheWorldTerrainProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.url)) {\n    throw new DeveloperError(\"options.url is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var resource = Resource.createIfNeeded(options.url);\n\n  this._resource = resource;\n\n  this._errorEvent = new Event();\n  this._ready = false;\n  this._readyPromise = when.defer();\n\n  this._terrainDataStructure = {\n    heightScale: 1.0 / 1000.0,\n    heightOffset: -1000.0,\n    elementsPerHeight: 3,\n    stride: 4,\n    elementMultiplier: 256.0,\n    isBigEndian: true,\n    lowestEncodedHeight: 0,\n    highestEncodedHeight: 256 * 256 * 256 - 1,\n  };\n\n  var credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  this._credit = credit;\n\n  this._tilingScheme = undefined;\n  this._rectangles = [];\n\n  var that = this;\n  var metadataError;\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n\n  function metadataSuccess(xml) {\n    var srs = xml.getElementsByTagName(\"SRS\")[0].textContent;\n    if (srs === \"EPSG:4326\") {\n      that._tilingScheme = new GeographicTilingScheme({ ellipsoid: ellipsoid });\n    } else {\n      metadataFailure(\"SRS \" + srs + \" is not supported.\");\n      return;\n    }\n\n    var tileFormat = xml.getElementsByTagName(\"TileFormat\")[0];\n    that._heightmapWidth = parseInt(tileFormat.getAttribute(\"width\"), 10);\n    that._heightmapHeight = parseInt(tileFormat.getAttribute(\"height\"), 10);\n    that._levelZeroMaximumGeometricError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n      ellipsoid,\n      Math.min(that._heightmapWidth, that._heightmapHeight),\n      that._tilingScheme.getNumberOfXTilesAtLevel(0)\n    );\n\n    var dataRectangles = xml.getElementsByTagName(\"DataExtent\");\n\n    for (var i = 0; i < dataRectangles.length; ++i) {\n      var dataRectangle = dataRectangles[i];\n\n      var west = CesiumMath.toRadians(\n        parseFloat(dataRectangle.getAttribute(\"minx\"))\n      );\n      var south = CesiumMath.toRadians(\n        parseFloat(dataRectangle.getAttribute(\"miny\"))\n      );\n      var east = CesiumMath.toRadians(\n        parseFloat(dataRectangle.getAttribute(\"maxx\"))\n      );\n      var north = CesiumMath.toRadians(\n        parseFloat(dataRectangle.getAttribute(\"maxy\"))\n      );\n      var maxLevel = parseInt(dataRectangle.getAttribute(\"maxlevel\"), 10);\n\n      that._rectangles.push(\n        new DataRectangle(new Rectangle(west, south, east, north), maxLevel)\n      );\n    }\n\n    that._ready = true;\n    that._readyPromise.resolve(true);\n  }\n\n  function metadataFailure(e) {\n    var message = defaultValue(\n      e,\n      \"An error occurred while accessing \" + that._resource.url + \".\"\n    );\n    metadataError = TileProviderError.handleError(\n      metadataError,\n      that,\n      that._errorEvent,\n      message,\n      undefined,\n      undefined,\n      undefined,\n      requestMetadata\n    );\n  }\n\n  function requestMetadata() {\n    when(that._resource.fetchXML(), metadataSuccess, metadataFailure);\n  }\n\n  requestMetadata();\n}\n\nObject.defineProperties(VRTheWorldTerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.  This function should not be called before {@link VRTheWorldTerrainProvider#ready} returns true.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {Credit}\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.  This function should\n   * not be called before {@link VRTheWorldTerrainProvider#ready} returns true.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {GeographicTilingScheme}\n   */\n  tilingScheme: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this.ready) {\n        throw new DeveloperError(\n          \"requestTileGeometry must not be called before ready returns true.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {Boolean}\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.  This function should not be\n   * called before {@link VRTheWorldTerrainProvider#ready} returns true.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {Boolean}\n   */\n  hasWaterMask: {\n    get: function () {\n      return false;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * This function should not be called before {@link VRTheWorldTerrainProvider#ready} returns true.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {Boolean}\n   */\n  hasVertexNormals: {\n    get: function () {\n      return false;\n    },\n  },\n});\n\n/**\n * Requests the geometry for a given tile.  This function should not be called before\n * {@link VRTheWorldTerrainProvider#ready} returns true.  The result includes terrain\n * data and indicates that all child tiles are available.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n */\nVRTheWorldTerrainProvider.prototype.requestTileGeometry = function (\n  x,\n  y,\n  level,\n  request\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this.ready) {\n    throw new DeveloperError(\n      \"requestTileGeometry must not be called before ready returns true.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var yTiles = this._tilingScheme.getNumberOfYTilesAtLevel(level);\n  var resource = this._resource.getDerivedResource({\n    url: level + \"/\" + x + \"/\" + (yTiles - y - 1) + \".tif\",\n    queryParameters: {\n      cesium: true,\n    },\n    request: request,\n  });\n  var promise = resource.fetchImage({\n    preferImageBitmap: true,\n  });\n  if (!defined(promise)) {\n    return undefined;\n  }\n\n  var that = this;\n  return when(promise).then(function (image) {\n    return new HeightmapTerrainData({\n      buffer: getImagePixels(image),\n      width: that._heightmapWidth,\n      height: that._heightmapHeight,\n      childTileMask: getChildMask(that, x, y, level),\n      structure: that._terrainDataStructure,\n    });\n  });\n};\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n *\n * @param {Number} level The tile level for which to get the maximum geometric error.\n * @returns {Number} The maximum geometric error.\n */\nVRTheWorldTerrainProvider.prototype.getLevelMaximumGeometricError = function (\n  level\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this.ready) {\n    throw new DeveloperError(\n      \"requestTileGeometry must not be called before ready returns true.\"\n    );\n  }\n  //>>includeEnd('debug');\n  return this._levelZeroMaximumGeometricError / (1 << level);\n};\n\nvar rectangleScratch = new Rectangle();\n\nfunction getChildMask(provider, x, y, level) {\n  var tilingScheme = provider._tilingScheme;\n  var rectangles = provider._rectangles;\n  var parentRectangle = tilingScheme.tileXYToRectangle(x, y, level);\n\n  var childMask = 0;\n\n  for (var i = 0; i < rectangles.length && childMask !== 15; ++i) {\n    var rectangle = rectangles[i];\n    if (rectangle.maxLevel <= level) {\n      continue;\n    }\n\n    var testRectangle = rectangle.rectangle;\n\n    var intersection = Rectangle.intersection(\n      testRectangle,\n      parentRectangle,\n      rectangleScratch\n    );\n    if (defined(intersection)) {\n      // Parent tile is inside this rectangle, so at least one child is, too.\n      if (\n        isTileInRectangle(tilingScheme, testRectangle, x * 2, y * 2, level + 1)\n      ) {\n        childMask |= 4; // northwest\n      }\n      if (\n        isTileInRectangle(\n          tilingScheme,\n          testRectangle,\n          x * 2 + 1,\n          y * 2,\n          level + 1\n        )\n      ) {\n        childMask |= 8; // northeast\n      }\n      if (\n        isTileInRectangle(\n          tilingScheme,\n          testRectangle,\n          x * 2,\n          y * 2 + 1,\n          level + 1\n        )\n      ) {\n        childMask |= 1; // southwest\n      }\n      if (\n        isTileInRectangle(\n          tilingScheme,\n          testRectangle,\n          x * 2 + 1,\n          y * 2 + 1,\n          level + 1\n        )\n      ) {\n        childMask |= 2; // southeast\n      }\n    }\n  }\n\n  return childMask;\n}\n\nfunction isTileInRectangle(tilingScheme, rectangle, x, y, level) {\n  var tileRectangle = tilingScheme.tileXYToRectangle(x, y, level);\n  return defined(\n    Rectangle.intersection(tileRectangle, rectangle, rectangleScratch)\n  );\n}\n\n/**\n * Determines whether data for a tile is available to be loaded.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {Boolean} Undefined if not supported, otherwise true or false.\n */\nVRTheWorldTerrainProvider.prototype.getTileDataAvailable = function (\n  x,\n  y,\n  level\n) {\n  return undefined;\n};\n\n/**\n * Makes sure we load availability data for a tile\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {undefined|Promise} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\n */\nVRTheWorldTerrainProvider.prototype.loadTileDataAvailability = function (\n  x,\n  y,\n  level\n) {\n  return undefined;\n};\nexport default VRTheWorldTerrainProvider;\n"]},"metadata":{},"sourceType":"module"}