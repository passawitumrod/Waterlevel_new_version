{"ast":null,"code":"import binarySearch from \"../Core/binarySearch.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport ExtrapolationType from \"../Core/ExtrapolationType.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport LinearApproximation from \"../Core/LinearApproximation.js\";\nvar PackableNumber = {\n  packedLength: 1,\n  pack: function (value, array, startingIndex) {\n    startingIndex = defaultValue(startingIndex, 0);\n    array[startingIndex] = value;\n  },\n  unpack: function (array, startingIndex, result) {\n    startingIndex = defaultValue(startingIndex, 0);\n    return array[startingIndex];\n  }\n}; //We can't use splice for inserting new elements because function apply can't handle\n//a huge number of arguments.  See https://code.google.com/p/chromium/issues/detail?id=56588\n\nfunction arrayInsert(array, startIndex, items) {\n  var i;\n  var arrayLength = array.length;\n  var itemsLength = items.length;\n  var newLength = arrayLength + itemsLength;\n  array.length = newLength;\n\n  if (arrayLength !== startIndex) {\n    var q = arrayLength - 1;\n\n    for (i = newLength - 1; i >= startIndex; i--) {\n      array[i] = array[q--];\n    }\n  }\n\n  for (i = 0; i < itemsLength; i++) {\n    array[startIndex++] = items[i];\n  }\n}\n\nfunction convertDate(date, epoch) {\n  if (date instanceof JulianDate) {\n    return date;\n  }\n\n  if (typeof date === \"string\") {\n    return JulianDate.fromIso8601(date);\n  }\n\n  return JulianDate.addSeconds(epoch, date, new JulianDate());\n}\n\nvar timesSpliceArgs = [];\nvar valuesSpliceArgs = [];\n\nfunction mergeNewSamples(epoch, times, values, newData, packedLength) {\n  var newDataIndex = 0;\n  var i;\n  var prevItem;\n  var timesInsertionPoint;\n  var valuesInsertionPoint;\n  var currentTime;\n  var nextTime;\n\n  while (newDataIndex < newData.length) {\n    currentTime = convertDate(newData[newDataIndex], epoch);\n    timesInsertionPoint = binarySearch(times, currentTime, JulianDate.compare);\n    var timesSpliceArgsCount = 0;\n    var valuesSpliceArgsCount = 0;\n\n    if (timesInsertionPoint < 0) {\n      //Doesn't exist, insert as many additional values as we can.\n      timesInsertionPoint = ~timesInsertionPoint;\n      valuesInsertionPoint = timesInsertionPoint * packedLength;\n      prevItem = undefined;\n      nextTime = times[timesInsertionPoint];\n\n      while (newDataIndex < newData.length) {\n        currentTime = convertDate(newData[newDataIndex], epoch);\n\n        if (defined(prevItem) && JulianDate.compare(prevItem, currentTime) >= 0 || defined(nextTime) && JulianDate.compare(currentTime, nextTime) >= 0) {\n          break;\n        }\n\n        timesSpliceArgs[timesSpliceArgsCount++] = currentTime;\n        newDataIndex = newDataIndex + 1;\n\n        for (i = 0; i < packedLength; i++) {\n          valuesSpliceArgs[valuesSpliceArgsCount++] = newData[newDataIndex];\n          newDataIndex = newDataIndex + 1;\n        }\n\n        prevItem = currentTime;\n      }\n\n      if (timesSpliceArgsCount > 0) {\n        valuesSpliceArgs.length = valuesSpliceArgsCount;\n        arrayInsert(values, valuesInsertionPoint, valuesSpliceArgs);\n        timesSpliceArgs.length = timesSpliceArgsCount;\n        arrayInsert(times, timesInsertionPoint, timesSpliceArgs);\n      }\n    } else {\n      //Found an exact match\n      for (i = 0; i < packedLength; i++) {\n        newDataIndex++;\n        values[timesInsertionPoint * packedLength + i] = newData[newDataIndex];\n      }\n\n      newDataIndex++;\n    }\n  }\n}\n/**\n * A {@link Property} whose value is interpolated for a given time from the\n * provided set of samples and specified interpolation algorithm and degree.\n * @alias SampledProperty\n * @constructor\n *\n * @param {Number|Packable} type The type of property.\n * @param {Packable[]} [derivativeTypes] When supplied, indicates that samples will contain derivative information of the specified types.\n *\n *\n * @example\n * //Create a linearly interpolated Cartesian2\n * var property = new Cesium.SampledProperty(Cesium.Cartesian2);\n *\n * //Populate it with data\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:00:00.00Z'), new Cesium.Cartesian2(0, 0));\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-02T00:00:00.00Z'), new Cesium.Cartesian2(4, 7));\n *\n * //Retrieve an interpolated value\n * var result = property.getValue(Cesium.JulianDate.fromIso8601('2012-08-01T12:00:00.00Z'));\n *\n * @example\n * //Create a simple numeric SampledProperty that uses third degree Hermite Polynomial Approximation\n * var property = new Cesium.SampledProperty(Number);\n * property.setInterpolationOptions({\n *     interpolationDegree : 3,\n *     interpolationAlgorithm : Cesium.HermitePolynomialApproximation\n * });\n *\n * //Populate it with data\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:00:00.00Z'), 1.0);\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:01:00.00Z'), 6.0);\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:02:00.00Z'), 12.0);\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:03:30.00Z'), 5.0);\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:06:30.00Z'), 2.0);\n *\n * //Samples can be added in any order.\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:00:30.00Z'), 6.2);\n *\n * //Retrieve an interpolated value\n * var result = property.getValue(Cesium.JulianDate.fromIso8601('2012-08-01T00:02:34.00Z'));\n *\n * @see SampledPositionProperty\n */\n\n\nfunction SampledProperty(type, derivativeTypes) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"type\", type); //>>includeEnd('debug');\n\n  var innerType = type;\n\n  if (innerType === Number) {\n    innerType = PackableNumber;\n  }\n\n  var packedLength = innerType.packedLength;\n  var packedInterpolationLength = defaultValue(innerType.packedInterpolationLength, packedLength);\n  var inputOrder = 0;\n  var innerDerivativeTypes;\n\n  if (defined(derivativeTypes)) {\n    var length = derivativeTypes.length;\n    innerDerivativeTypes = new Array(length);\n\n    for (var i = 0; i < length; i++) {\n      var derivativeType = derivativeTypes[i];\n\n      if (derivativeType === Number) {\n        derivativeType = PackableNumber;\n      }\n\n      var derivativePackedLength = derivativeType.packedLength;\n      packedLength += derivativePackedLength;\n      packedInterpolationLength += defaultValue(derivativeType.packedInterpolationLength, derivativePackedLength);\n      innerDerivativeTypes[i] = derivativeType;\n    }\n\n    inputOrder = length;\n  }\n\n  this._type = type;\n  this._innerType = innerType;\n  this._interpolationDegree = 1;\n  this._interpolationAlgorithm = LinearApproximation;\n  this._numberOfPoints = 0;\n  this._times = [];\n  this._values = [];\n  this._xTable = [];\n  this._yTable = [];\n  this._packedLength = packedLength;\n  this._packedInterpolationLength = packedInterpolationLength;\n  this._updateTableLength = true;\n  this._interpolationResult = new Array(packedInterpolationLength);\n  this._definitionChanged = new Event();\n  this._derivativeTypes = derivativeTypes;\n  this._innerDerivativeTypes = innerDerivativeTypes;\n  this._inputOrder = inputOrder;\n  this._forwardExtrapolationType = ExtrapolationType.NONE;\n  this._forwardExtrapolationDuration = 0;\n  this._backwardExtrapolationType = ExtrapolationType.NONE;\n  this._backwardExtrapolationDuration = 0;\n}\n\nObject.defineProperties(SampledProperty.prototype, {\n  /**\n   * Gets a value indicating if this property is constant.  A property is considered\n   * constant if getValue always returns the same result for the current definition.\n   * @memberof SampledProperty.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  isConstant: {\n    get: function () {\n      return this._values.length === 0;\n    }\n  },\n\n  /**\n   * Gets the event that is raised whenever the definition of this property changes.\n   * The definition is considered to have changed if a call to getValue would return\n   * a different result for the same time.\n   * @memberof SampledProperty.prototype\n   *\n   * @type {Event}\n   * @readonly\n   */\n  definitionChanged: {\n    get: function () {\n      return this._definitionChanged;\n    }\n  },\n\n  /**\n   * Gets the type of property.\n   * @memberof SampledProperty.prototype\n   * @type {*}\n   */\n  type: {\n    get: function () {\n      return this._type;\n    }\n  },\n\n  /**\n   * Gets the derivative types used by this property.\n   * @memberof SampledProperty.prototype\n   * @type {Packable[]}\n   */\n  derivativeTypes: {\n    get: function () {\n      return this._derivativeTypes;\n    }\n  },\n\n  /**\n   * Gets the degree of interpolation to perform when retrieving a value.\n   * @memberof SampledProperty.prototype\n   * @type {Number}\n   * @default 1\n   */\n  interpolationDegree: {\n    get: function () {\n      return this._interpolationDegree;\n    }\n  },\n\n  /**\n   * Gets the interpolation algorithm to use when retrieving a value.\n   * @memberof SampledProperty.prototype\n   * @type {InterpolationAlgorithm}\n   * @default LinearApproximation\n   */\n  interpolationAlgorithm: {\n    get: function () {\n      return this._interpolationAlgorithm;\n    }\n  },\n\n  /**\n   * Gets or sets the type of extrapolation to perform when a value\n   * is requested at a time after any available samples.\n   * @memberof SampledProperty.prototype\n   * @type {ExtrapolationType}\n   * @default ExtrapolationType.NONE\n   */\n  forwardExtrapolationType: {\n    get: function () {\n      return this._forwardExtrapolationType;\n    },\n    set: function (value) {\n      if (this._forwardExtrapolationType !== value) {\n        this._forwardExtrapolationType = value;\n\n        this._definitionChanged.raiseEvent(this);\n      }\n    }\n  },\n\n  /**\n   * Gets or sets the amount of time to extrapolate forward before\n   * the property becomes undefined.  A value of 0 will extrapolate forever.\n   * @memberof SampledProperty.prototype\n   * @type {Number}\n   * @default 0\n   */\n  forwardExtrapolationDuration: {\n    get: function () {\n      return this._forwardExtrapolationDuration;\n    },\n    set: function (value) {\n      if (this._forwardExtrapolationDuration !== value) {\n        this._forwardExtrapolationDuration = value;\n\n        this._definitionChanged.raiseEvent(this);\n      }\n    }\n  },\n\n  /**\n   * Gets or sets the type of extrapolation to perform when a value\n   * is requested at a time before any available samples.\n   * @memberof SampledProperty.prototype\n   * @type {ExtrapolationType}\n   * @default ExtrapolationType.NONE\n   */\n  backwardExtrapolationType: {\n    get: function () {\n      return this._backwardExtrapolationType;\n    },\n    set: function (value) {\n      if (this._backwardExtrapolationType !== value) {\n        this._backwardExtrapolationType = value;\n\n        this._definitionChanged.raiseEvent(this);\n      }\n    }\n  },\n\n  /**\n   * Gets or sets the amount of time to extrapolate backward\n   * before the property becomes undefined.  A value of 0 will extrapolate forever.\n   * @memberof SampledProperty.prototype\n   * @type {Number}\n   * @default 0\n   */\n  backwardExtrapolationDuration: {\n    get: function () {\n      return this._backwardExtrapolationDuration;\n    },\n    set: function (value) {\n      if (this._backwardExtrapolationDuration !== value) {\n        this._backwardExtrapolationDuration = value;\n\n        this._definitionChanged.raiseEvent(this);\n      }\n    }\n  }\n});\n/**\n * Gets the value of the property at the provided time.\n *\n * @param {JulianDate} time The time for which to retrieve the value.\n * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.\n */\n\nSampledProperty.prototype.getValue = function (time, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time); //>>includeEnd('debug');\n\n  var times = this._times;\n  var timesLength = times.length;\n\n  if (timesLength === 0) {\n    return undefined;\n  }\n\n  var timeout;\n  var innerType = this._innerType;\n  var values = this._values;\n  var index = binarySearch(times, time, JulianDate.compare);\n\n  if (index < 0) {\n    index = ~index;\n\n    if (index === 0) {\n      var startTime = times[index];\n      timeout = this._backwardExtrapolationDuration;\n\n      if (this._backwardExtrapolationType === ExtrapolationType.NONE || timeout !== 0 && JulianDate.secondsDifference(startTime, time) > timeout) {\n        return undefined;\n      }\n\n      if (this._backwardExtrapolationType === ExtrapolationType.HOLD) {\n        return innerType.unpack(values, 0, result);\n      }\n    }\n\n    if (index >= timesLength) {\n      index = timesLength - 1;\n      var endTime = times[index];\n      timeout = this._forwardExtrapolationDuration;\n\n      if (this._forwardExtrapolationType === ExtrapolationType.NONE || timeout !== 0 && JulianDate.secondsDifference(time, endTime) > timeout) {\n        return undefined;\n      }\n\n      if (this._forwardExtrapolationType === ExtrapolationType.HOLD) {\n        index = timesLength - 1;\n        return innerType.unpack(values, index * innerType.packedLength, result);\n      }\n    }\n\n    var xTable = this._xTable;\n    var yTable = this._yTable;\n    var interpolationAlgorithm = this._interpolationAlgorithm;\n    var packedInterpolationLength = this._packedInterpolationLength;\n    var inputOrder = this._inputOrder;\n\n    if (this._updateTableLength) {\n      this._updateTableLength = false;\n      var numberOfPoints = Math.min(interpolationAlgorithm.getRequiredDataPoints(this._interpolationDegree, inputOrder), timesLength);\n\n      if (numberOfPoints !== this._numberOfPoints) {\n        this._numberOfPoints = numberOfPoints;\n        xTable.length = numberOfPoints;\n        yTable.length = numberOfPoints * packedInterpolationLength;\n      }\n    }\n\n    var degree = this._numberOfPoints - 1;\n\n    if (degree < 1) {\n      return undefined;\n    }\n\n    var firstIndex = 0;\n    var lastIndex = timesLength - 1;\n    var pointsInCollection = lastIndex - firstIndex + 1;\n\n    if (pointsInCollection >= degree + 1) {\n      var computedFirstIndex = index - (degree / 2 | 0) - 1;\n\n      if (computedFirstIndex < firstIndex) {\n        computedFirstIndex = firstIndex;\n      }\n\n      var computedLastIndex = computedFirstIndex + degree;\n\n      if (computedLastIndex > lastIndex) {\n        computedLastIndex = lastIndex;\n        computedFirstIndex = computedLastIndex - degree;\n\n        if (computedFirstIndex < firstIndex) {\n          computedFirstIndex = firstIndex;\n        }\n      }\n\n      firstIndex = computedFirstIndex;\n      lastIndex = computedLastIndex;\n    }\n\n    var length = lastIndex - firstIndex + 1; // Build the tables\n\n    for (var i = 0; i < length; ++i) {\n      xTable[i] = JulianDate.secondsDifference(times[firstIndex + i], times[lastIndex]);\n    }\n\n    if (!defined(innerType.convertPackedArrayForInterpolation)) {\n      var destinationIndex = 0;\n      var packedLength = this._packedLength;\n      var sourceIndex = firstIndex * packedLength;\n      var stop = (lastIndex + 1) * packedLength;\n\n      while (sourceIndex < stop) {\n        yTable[destinationIndex] = values[sourceIndex];\n        sourceIndex++;\n        destinationIndex++;\n      }\n    } else {\n      innerType.convertPackedArrayForInterpolation(values, firstIndex, lastIndex, yTable);\n    } // Interpolate!\n\n\n    var x = JulianDate.secondsDifference(time, times[lastIndex]);\n    var interpolationResult;\n\n    if (inputOrder === 0 || !defined(interpolationAlgorithm.interpolate)) {\n      interpolationResult = interpolationAlgorithm.interpolateOrderZero(x, xTable, yTable, packedInterpolationLength, this._interpolationResult);\n    } else {\n      var yStride = Math.floor(packedInterpolationLength / (inputOrder + 1));\n      interpolationResult = interpolationAlgorithm.interpolate(x, xTable, yTable, yStride, inputOrder, inputOrder, this._interpolationResult);\n    }\n\n    if (!defined(innerType.unpackInterpolationResult)) {\n      return innerType.unpack(interpolationResult, 0, result);\n    }\n\n    return innerType.unpackInterpolationResult(interpolationResult, values, firstIndex, lastIndex, result);\n  }\n\n  return innerType.unpack(values, index * this._packedLength, result);\n};\n/**\n * Sets the algorithm and degree to use when interpolating a value.\n *\n * @param {Object} [options] Object with the following properties:\n * @param {InterpolationAlgorithm} [options.interpolationAlgorithm] The new interpolation algorithm.  If undefined, the existing property will be unchanged.\n * @param {Number} [options.interpolationDegree] The new interpolation degree.  If undefined, the existing property will be unchanged.\n */\n\n\nSampledProperty.prototype.setInterpolationOptions = function (options) {\n  if (!defined(options)) {\n    return;\n  }\n\n  var valuesChanged = false;\n  var interpolationAlgorithm = options.interpolationAlgorithm;\n  var interpolationDegree = options.interpolationDegree;\n\n  if (defined(interpolationAlgorithm) && this._interpolationAlgorithm !== interpolationAlgorithm) {\n    this._interpolationAlgorithm = interpolationAlgorithm;\n    valuesChanged = true;\n  }\n\n  if (defined(interpolationDegree) && this._interpolationDegree !== interpolationDegree) {\n    this._interpolationDegree = interpolationDegree;\n    valuesChanged = true;\n  }\n\n  if (valuesChanged) {\n    this._updateTableLength = true;\n\n    this._definitionChanged.raiseEvent(this);\n  }\n};\n/**\n * Adds a new sample.\n *\n * @param {JulianDate} time The sample time.\n * @param {Packable} value The value at the provided time.\n * @param {Packable[]} [derivatives] The array of derivatives at the provided time.\n */\n\n\nSampledProperty.prototype.addSample = function (time, value, derivatives) {\n  var innerDerivativeTypes = this._innerDerivativeTypes;\n  var hasDerivatives = defined(innerDerivativeTypes); //>>includeStart('debug', pragmas.debug);\n\n  Check.defined(\"time\", time);\n  Check.defined(\"value\", value);\n\n  if (hasDerivatives) {\n    Check.defined(\"derivatives\", derivatives);\n  } //>>includeEnd('debug');\n\n\n  var innerType = this._innerType;\n  var data = [];\n  data.push(time);\n  innerType.pack(value, data, data.length);\n\n  if (hasDerivatives) {\n    var derivativesLength = innerDerivativeTypes.length;\n\n    for (var x = 0; x < derivativesLength; x++) {\n      innerDerivativeTypes[x].pack(derivatives[x], data, data.length);\n    }\n  }\n\n  mergeNewSamples(undefined, this._times, this._values, data, this._packedLength);\n  this._updateTableLength = true;\n\n  this._definitionChanged.raiseEvent(this);\n};\n/**\n * Adds an array of samples.\n *\n * @param {JulianDate[]} times An array of JulianDate instances where each index is a sample time.\n * @param {Packable[]} values The array of values, where each value corresponds to the provided times index.\n * @param {Array[]} [derivativeValues] An array where each item is the array of derivatives at the equivalent time index.\n *\n * @exception {DeveloperError} times and values must be the same length.\n * @exception {DeveloperError} times and derivativeValues must be the same length.\n */\n\n\nSampledProperty.prototype.addSamples = function (times, values, derivativeValues) {\n  var innerDerivativeTypes = this._innerDerivativeTypes;\n  var hasDerivatives = defined(innerDerivativeTypes); //>>includeStart('debug', pragmas.debug);\n\n  Check.defined(\"times\", times);\n  Check.defined(\"values\", values);\n\n  if (times.length !== values.length) {\n    throw new DeveloperError(\"times and values must be the same length.\");\n  }\n\n  if (hasDerivatives && (!defined(derivativeValues) || derivativeValues.length !== times.length)) {\n    throw new DeveloperError(\"times and derivativeValues must be the same length.\");\n  } //>>includeEnd('debug');\n\n\n  var innerType = this._innerType;\n  var length = times.length;\n  var data = [];\n\n  for (var i = 0; i < length; i++) {\n    data.push(times[i]);\n    innerType.pack(values[i], data, data.length);\n\n    if (hasDerivatives) {\n      var derivatives = derivativeValues[i];\n      var derivativesLength = innerDerivativeTypes.length;\n\n      for (var x = 0; x < derivativesLength; x++) {\n        innerDerivativeTypes[x].pack(derivatives[x], data, data.length);\n      }\n    }\n  }\n\n  mergeNewSamples(undefined, this._times, this._values, data, this._packedLength);\n  this._updateTableLength = true;\n\n  this._definitionChanged.raiseEvent(this);\n};\n/**\n * Adds samples as a single packed array where each new sample is represented as a date,\n * followed by the packed representation of the corresponding value and derivatives.\n *\n * @param {Number[]} packedSamples The array of packed samples.\n * @param {JulianDate} [epoch] If any of the dates in packedSamples are numbers, they are considered an offset from this epoch, in seconds.\n */\n\n\nSampledProperty.prototype.addSamplesPackedArray = function (packedSamples, epoch) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"packedSamples\", packedSamples); //>>includeEnd('debug');\n\n  mergeNewSamples(epoch, this._times, this._values, packedSamples, this._packedLength);\n  this._updateTableLength = true;\n\n  this._definitionChanged.raiseEvent(this);\n};\n/**\n * Removes a sample at the given time, if present.\n *\n * @param {JulianDate} time The sample time.\n * @returns {Boolean} <code>true</code> if a sample at time was removed, <code>false</code> otherwise.\n */\n\n\nSampledProperty.prototype.removeSample = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time); //>>includeEnd('debug');\n\n  var index = binarySearch(this._times, time, JulianDate.compare);\n\n  if (index < 0) {\n    return false;\n  }\n\n  removeSamples(this, index, 1);\n  return true;\n};\n\nfunction removeSamples(property, startIndex, numberToRemove) {\n  var packedLength = property._packedLength;\n\n  property._times.splice(startIndex, numberToRemove);\n\n  property._values.splice(startIndex * packedLength, numberToRemove * packedLength);\n\n  property._updateTableLength = true;\n\n  property._definitionChanged.raiseEvent(property);\n}\n/**\n * Removes all samples for the given time interval.\n *\n * @param {TimeInterval} time The time interval for which to remove all samples.\n */\n\n\nSampledProperty.prototype.removeSamples = function (timeInterval) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"timeInterval\", timeInterval); //>>includeEnd('debug');\n\n  var times = this._times;\n  var startIndex = binarySearch(times, timeInterval.start, JulianDate.compare);\n\n  if (startIndex < 0) {\n    startIndex = ~startIndex;\n  } else if (!timeInterval.isStartIncluded) {\n    ++startIndex;\n  }\n\n  var stopIndex = binarySearch(times, timeInterval.stop, JulianDate.compare);\n\n  if (stopIndex < 0) {\n    stopIndex = ~stopIndex;\n  } else if (timeInterval.isStopIncluded) {\n    ++stopIndex;\n  }\n\n  removeSamples(this, startIndex, stopIndex - startIndex);\n};\n/**\n * Compares this property to the provided property and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Property} [other] The other property.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\n\n\nSampledProperty.prototype.equals = function (other) {\n  if (this === other) {\n    return true;\n  }\n\n  if (!defined(other)) {\n    return false;\n  }\n\n  if (this._type !== other._type || //\n  this._interpolationDegree !== other._interpolationDegree || //\n  this._interpolationAlgorithm !== other._interpolationAlgorithm) {\n    return false;\n  }\n\n  var derivativeTypes = this._derivativeTypes;\n  var hasDerivatives = defined(derivativeTypes);\n  var otherDerivativeTypes = other._derivativeTypes;\n  var otherHasDerivatives = defined(otherDerivativeTypes);\n\n  if (hasDerivatives !== otherHasDerivatives) {\n    return false;\n  }\n\n  var i;\n  var length;\n\n  if (hasDerivatives) {\n    length = derivativeTypes.length;\n\n    if (length !== otherDerivativeTypes.length) {\n      return false;\n    }\n\n    for (i = 0; i < length; i++) {\n      if (derivativeTypes[i] !== otherDerivativeTypes[i]) {\n        return false;\n      }\n    }\n  }\n\n  var times = this._times;\n  var otherTimes = other._times;\n  length = times.length;\n\n  if (length !== otherTimes.length) {\n    return false;\n  }\n\n  for (i = 0; i < length; i++) {\n    if (!JulianDate.equals(times[i], otherTimes[i])) {\n      return false;\n    }\n  }\n\n  var values = this._values;\n  var otherValues = other._values;\n\n  for (i = 0; i < length; i++) {\n    if (values[i] !== otherValues[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}; //Exposed for testing.\n\n\nSampledProperty._mergeNewSamples = mergeNewSamples;\nexport default SampledProperty;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/DataSources/SampledProperty.js"],"names":["binarySearch","Check","defaultValue","defined","DeveloperError","Event","ExtrapolationType","JulianDate","LinearApproximation","PackableNumber","packedLength","pack","value","array","startingIndex","unpack","result","arrayInsert","startIndex","items","i","arrayLength","length","itemsLength","newLength","q","convertDate","date","epoch","fromIso8601","addSeconds","timesSpliceArgs","valuesSpliceArgs","mergeNewSamples","times","values","newData","newDataIndex","prevItem","timesInsertionPoint","valuesInsertionPoint","currentTime","nextTime","compare","timesSpliceArgsCount","valuesSpliceArgsCount","undefined","SampledProperty","type","derivativeTypes","innerType","Number","packedInterpolationLength","inputOrder","innerDerivativeTypes","Array","derivativeType","derivativePackedLength","_type","_innerType","_interpolationDegree","_interpolationAlgorithm","_numberOfPoints","_times","_values","_xTable","_yTable","_packedLength","_packedInterpolationLength","_updateTableLength","_interpolationResult","_definitionChanged","_derivativeTypes","_innerDerivativeTypes","_inputOrder","_forwardExtrapolationType","NONE","_forwardExtrapolationDuration","_backwardExtrapolationType","_backwardExtrapolationDuration","Object","defineProperties","prototype","isConstant","get","definitionChanged","interpolationDegree","interpolationAlgorithm","forwardExtrapolationType","set","raiseEvent","forwardExtrapolationDuration","backwardExtrapolationType","backwardExtrapolationDuration","getValue","time","timesLength","timeout","index","startTime","secondsDifference","HOLD","endTime","xTable","yTable","numberOfPoints","Math","min","getRequiredDataPoints","degree","firstIndex","lastIndex","pointsInCollection","computedFirstIndex","computedLastIndex","convertPackedArrayForInterpolation","destinationIndex","sourceIndex","stop","x","interpolationResult","interpolate","interpolateOrderZero","yStride","floor","unpackInterpolationResult","setInterpolationOptions","options","valuesChanged","addSample","derivatives","hasDerivatives","data","push","derivativesLength","addSamples","derivativeValues","addSamplesPackedArray","packedSamples","removeSample","removeSamples","property","numberToRemove","splice","timeInterval","start","isStartIncluded","stopIndex","isStopIncluded","equals","other","otherDerivativeTypes","otherHasDerivatives","otherTimes","otherValues","_mergeNewSamples"],"mappings":"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","sourcesContent":["import binarySearch from \"../Core/binarySearch.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport ExtrapolationType from \"../Core/ExtrapolationType.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport LinearApproximation from \"../Core/LinearApproximation.js\";\n\nvar PackableNumber = {\n  packedLength: 1,\n  pack: function (value, array, startingIndex) {\n    startingIndex = defaultValue(startingIndex, 0);\n    array[startingIndex] = value;\n  },\n  unpack: function (array, startingIndex, result) {\n    startingIndex = defaultValue(startingIndex, 0);\n    return array[startingIndex];\n  },\n};\n\n//We can't use splice for inserting new elements because function apply can't handle\n//a huge number of arguments.  See https://code.google.com/p/chromium/issues/detail?id=56588\nfunction arrayInsert(array, startIndex, items) {\n  var i;\n  var arrayLength = array.length;\n  var itemsLength = items.length;\n  var newLength = arrayLength + itemsLength;\n\n  array.length = newLength;\n  if (arrayLength !== startIndex) {\n    var q = arrayLength - 1;\n    for (i = newLength - 1; i >= startIndex; i--) {\n      array[i] = array[q--];\n    }\n  }\n\n  for (i = 0; i < itemsLength; i++) {\n    array[startIndex++] = items[i];\n  }\n}\n\nfunction convertDate(date, epoch) {\n  if (date instanceof JulianDate) {\n    return date;\n  }\n  if (typeof date === \"string\") {\n    return JulianDate.fromIso8601(date);\n  }\n  return JulianDate.addSeconds(epoch, date, new JulianDate());\n}\n\nvar timesSpliceArgs = [];\nvar valuesSpliceArgs = [];\n\nfunction mergeNewSamples(epoch, times, values, newData, packedLength) {\n  var newDataIndex = 0;\n  var i;\n  var prevItem;\n  var timesInsertionPoint;\n  var valuesInsertionPoint;\n  var currentTime;\n  var nextTime;\n\n  while (newDataIndex < newData.length) {\n    currentTime = convertDate(newData[newDataIndex], epoch);\n    timesInsertionPoint = binarySearch(times, currentTime, JulianDate.compare);\n    var timesSpliceArgsCount = 0;\n    var valuesSpliceArgsCount = 0;\n\n    if (timesInsertionPoint < 0) {\n      //Doesn't exist, insert as many additional values as we can.\n      timesInsertionPoint = ~timesInsertionPoint;\n\n      valuesInsertionPoint = timesInsertionPoint * packedLength;\n      prevItem = undefined;\n      nextTime = times[timesInsertionPoint];\n      while (newDataIndex < newData.length) {\n        currentTime = convertDate(newData[newDataIndex], epoch);\n        if (\n          (defined(prevItem) &&\n            JulianDate.compare(prevItem, currentTime) >= 0) ||\n          (defined(nextTime) && JulianDate.compare(currentTime, nextTime) >= 0)\n        ) {\n          break;\n        }\n        timesSpliceArgs[timesSpliceArgsCount++] = currentTime;\n        newDataIndex = newDataIndex + 1;\n        for (i = 0; i < packedLength; i++) {\n          valuesSpliceArgs[valuesSpliceArgsCount++] = newData[newDataIndex];\n          newDataIndex = newDataIndex + 1;\n        }\n        prevItem = currentTime;\n      }\n\n      if (timesSpliceArgsCount > 0) {\n        valuesSpliceArgs.length = valuesSpliceArgsCount;\n        arrayInsert(values, valuesInsertionPoint, valuesSpliceArgs);\n\n        timesSpliceArgs.length = timesSpliceArgsCount;\n        arrayInsert(times, timesInsertionPoint, timesSpliceArgs);\n      }\n    } else {\n      //Found an exact match\n      for (i = 0; i < packedLength; i++) {\n        newDataIndex++;\n        values[timesInsertionPoint * packedLength + i] = newData[newDataIndex];\n      }\n      newDataIndex++;\n    }\n  }\n}\n\n/**\n * A {@link Property} whose value is interpolated for a given time from the\n * provided set of samples and specified interpolation algorithm and degree.\n * @alias SampledProperty\n * @constructor\n *\n * @param {Number|Packable} type The type of property.\n * @param {Packable[]} [derivativeTypes] When supplied, indicates that samples will contain derivative information of the specified types.\n *\n *\n * @example\n * //Create a linearly interpolated Cartesian2\n * var property = new Cesium.SampledProperty(Cesium.Cartesian2);\n *\n * //Populate it with data\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:00:00.00Z'), new Cesium.Cartesian2(0, 0));\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-02T00:00:00.00Z'), new Cesium.Cartesian2(4, 7));\n *\n * //Retrieve an interpolated value\n * var result = property.getValue(Cesium.JulianDate.fromIso8601('2012-08-01T12:00:00.00Z'));\n *\n * @example\n * //Create a simple numeric SampledProperty that uses third degree Hermite Polynomial Approximation\n * var property = new Cesium.SampledProperty(Number);\n * property.setInterpolationOptions({\n *     interpolationDegree : 3,\n *     interpolationAlgorithm : Cesium.HermitePolynomialApproximation\n * });\n *\n * //Populate it with data\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:00:00.00Z'), 1.0);\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:01:00.00Z'), 6.0);\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:02:00.00Z'), 12.0);\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:03:30.00Z'), 5.0);\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:06:30.00Z'), 2.0);\n *\n * //Samples can be added in any order.\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:00:30.00Z'), 6.2);\n *\n * //Retrieve an interpolated value\n * var result = property.getValue(Cesium.JulianDate.fromIso8601('2012-08-01T00:02:34.00Z'));\n *\n * @see SampledPositionProperty\n */\nfunction SampledProperty(type, derivativeTypes) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"type\", type);\n  //>>includeEnd('debug');\n\n  var innerType = type;\n  if (innerType === Number) {\n    innerType = PackableNumber;\n  }\n  var packedLength = innerType.packedLength;\n  var packedInterpolationLength = defaultValue(\n    innerType.packedInterpolationLength,\n    packedLength\n  );\n\n  var inputOrder = 0;\n  var innerDerivativeTypes;\n  if (defined(derivativeTypes)) {\n    var length = derivativeTypes.length;\n    innerDerivativeTypes = new Array(length);\n    for (var i = 0; i < length; i++) {\n      var derivativeType = derivativeTypes[i];\n      if (derivativeType === Number) {\n        derivativeType = PackableNumber;\n      }\n      var derivativePackedLength = derivativeType.packedLength;\n      packedLength += derivativePackedLength;\n      packedInterpolationLength += defaultValue(\n        derivativeType.packedInterpolationLength,\n        derivativePackedLength\n      );\n      innerDerivativeTypes[i] = derivativeType;\n    }\n    inputOrder = length;\n  }\n\n  this._type = type;\n  this._innerType = innerType;\n  this._interpolationDegree = 1;\n  this._interpolationAlgorithm = LinearApproximation;\n  this._numberOfPoints = 0;\n  this._times = [];\n  this._values = [];\n  this._xTable = [];\n  this._yTable = [];\n  this._packedLength = packedLength;\n  this._packedInterpolationLength = packedInterpolationLength;\n  this._updateTableLength = true;\n  this._interpolationResult = new Array(packedInterpolationLength);\n  this._definitionChanged = new Event();\n  this._derivativeTypes = derivativeTypes;\n  this._innerDerivativeTypes = innerDerivativeTypes;\n  this._inputOrder = inputOrder;\n  this._forwardExtrapolationType = ExtrapolationType.NONE;\n  this._forwardExtrapolationDuration = 0;\n  this._backwardExtrapolationType = ExtrapolationType.NONE;\n  this._backwardExtrapolationDuration = 0;\n}\n\nObject.defineProperties(SampledProperty.prototype, {\n  /**\n   * Gets a value indicating if this property is constant.  A property is considered\n   * constant if getValue always returns the same result for the current definition.\n   * @memberof SampledProperty.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  isConstant: {\n    get: function () {\n      return this._values.length === 0;\n    },\n  },\n  /**\n   * Gets the event that is raised whenever the definition of this property changes.\n   * The definition is considered to have changed if a call to getValue would return\n   * a different result for the same time.\n   * @memberof SampledProperty.prototype\n   *\n   * @type {Event}\n   * @readonly\n   */\n  definitionChanged: {\n    get: function () {\n      return this._definitionChanged;\n    },\n  },\n  /**\n   * Gets the type of property.\n   * @memberof SampledProperty.prototype\n   * @type {*}\n   */\n  type: {\n    get: function () {\n      return this._type;\n    },\n  },\n  /**\n   * Gets the derivative types used by this property.\n   * @memberof SampledProperty.prototype\n   * @type {Packable[]}\n   */\n  derivativeTypes: {\n    get: function () {\n      return this._derivativeTypes;\n    },\n  },\n  /**\n   * Gets the degree of interpolation to perform when retrieving a value.\n   * @memberof SampledProperty.prototype\n   * @type {Number}\n   * @default 1\n   */\n  interpolationDegree: {\n    get: function () {\n      return this._interpolationDegree;\n    },\n  },\n  /**\n   * Gets the interpolation algorithm to use when retrieving a value.\n   * @memberof SampledProperty.prototype\n   * @type {InterpolationAlgorithm}\n   * @default LinearApproximation\n   */\n  interpolationAlgorithm: {\n    get: function () {\n      return this._interpolationAlgorithm;\n    },\n  },\n  /**\n   * Gets or sets the type of extrapolation to perform when a value\n   * is requested at a time after any available samples.\n   * @memberof SampledProperty.prototype\n   * @type {ExtrapolationType}\n   * @default ExtrapolationType.NONE\n   */\n  forwardExtrapolationType: {\n    get: function () {\n      return this._forwardExtrapolationType;\n    },\n    set: function (value) {\n      if (this._forwardExtrapolationType !== value) {\n        this._forwardExtrapolationType = value;\n        this._definitionChanged.raiseEvent(this);\n      }\n    },\n  },\n  /**\n   * Gets or sets the amount of time to extrapolate forward before\n   * the property becomes undefined.  A value of 0 will extrapolate forever.\n   * @memberof SampledProperty.prototype\n   * @type {Number}\n   * @default 0\n   */\n  forwardExtrapolationDuration: {\n    get: function () {\n      return this._forwardExtrapolationDuration;\n    },\n    set: function (value) {\n      if (this._forwardExtrapolationDuration !== value) {\n        this._forwardExtrapolationDuration = value;\n        this._definitionChanged.raiseEvent(this);\n      }\n    },\n  },\n  /**\n   * Gets or sets the type of extrapolation to perform when a value\n   * is requested at a time before any available samples.\n   * @memberof SampledProperty.prototype\n   * @type {ExtrapolationType}\n   * @default ExtrapolationType.NONE\n   */\n  backwardExtrapolationType: {\n    get: function () {\n      return this._backwardExtrapolationType;\n    },\n    set: function (value) {\n      if (this._backwardExtrapolationType !== value) {\n        this._backwardExtrapolationType = value;\n        this._definitionChanged.raiseEvent(this);\n      }\n    },\n  },\n  /**\n   * Gets or sets the amount of time to extrapolate backward\n   * before the property becomes undefined.  A value of 0 will extrapolate forever.\n   * @memberof SampledProperty.prototype\n   * @type {Number}\n   * @default 0\n   */\n  backwardExtrapolationDuration: {\n    get: function () {\n      return this._backwardExtrapolationDuration;\n    },\n    set: function (value) {\n      if (this._backwardExtrapolationDuration !== value) {\n        this._backwardExtrapolationDuration = value;\n        this._definitionChanged.raiseEvent(this);\n      }\n    },\n  },\n});\n\n/**\n * Gets the value of the property at the provided time.\n *\n * @param {JulianDate} time The time for which to retrieve the value.\n * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.\n */\nSampledProperty.prototype.getValue = function (time, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  //>>includeEnd('debug');\n\n  var times = this._times;\n  var timesLength = times.length;\n  if (timesLength === 0) {\n    return undefined;\n  }\n\n  var timeout;\n  var innerType = this._innerType;\n  var values = this._values;\n  var index = binarySearch(times, time, JulianDate.compare);\n\n  if (index < 0) {\n    index = ~index;\n\n    if (index === 0) {\n      var startTime = times[index];\n      timeout = this._backwardExtrapolationDuration;\n      if (\n        this._backwardExtrapolationType === ExtrapolationType.NONE ||\n        (timeout !== 0 &&\n          JulianDate.secondsDifference(startTime, time) > timeout)\n      ) {\n        return undefined;\n      }\n      if (this._backwardExtrapolationType === ExtrapolationType.HOLD) {\n        return innerType.unpack(values, 0, result);\n      }\n    }\n\n    if (index >= timesLength) {\n      index = timesLength - 1;\n      var endTime = times[index];\n      timeout = this._forwardExtrapolationDuration;\n      if (\n        this._forwardExtrapolationType === ExtrapolationType.NONE ||\n        (timeout !== 0 && JulianDate.secondsDifference(time, endTime) > timeout)\n      ) {\n        return undefined;\n      }\n      if (this._forwardExtrapolationType === ExtrapolationType.HOLD) {\n        index = timesLength - 1;\n        return innerType.unpack(values, index * innerType.packedLength, result);\n      }\n    }\n\n    var xTable = this._xTable;\n    var yTable = this._yTable;\n    var interpolationAlgorithm = this._interpolationAlgorithm;\n    var packedInterpolationLength = this._packedInterpolationLength;\n    var inputOrder = this._inputOrder;\n\n    if (this._updateTableLength) {\n      this._updateTableLength = false;\n      var numberOfPoints = Math.min(\n        interpolationAlgorithm.getRequiredDataPoints(\n          this._interpolationDegree,\n          inputOrder\n        ),\n        timesLength\n      );\n      if (numberOfPoints !== this._numberOfPoints) {\n        this._numberOfPoints = numberOfPoints;\n        xTable.length = numberOfPoints;\n        yTable.length = numberOfPoints * packedInterpolationLength;\n      }\n    }\n\n    var degree = this._numberOfPoints - 1;\n    if (degree < 1) {\n      return undefined;\n    }\n\n    var firstIndex = 0;\n    var lastIndex = timesLength - 1;\n    var pointsInCollection = lastIndex - firstIndex + 1;\n\n    if (pointsInCollection >= degree + 1) {\n      var computedFirstIndex = index - ((degree / 2) | 0) - 1;\n      if (computedFirstIndex < firstIndex) {\n        computedFirstIndex = firstIndex;\n      }\n      var computedLastIndex = computedFirstIndex + degree;\n      if (computedLastIndex > lastIndex) {\n        computedLastIndex = lastIndex;\n        computedFirstIndex = computedLastIndex - degree;\n        if (computedFirstIndex < firstIndex) {\n          computedFirstIndex = firstIndex;\n        }\n      }\n\n      firstIndex = computedFirstIndex;\n      lastIndex = computedLastIndex;\n    }\n    var length = lastIndex - firstIndex + 1;\n\n    // Build the tables\n    for (var i = 0; i < length; ++i) {\n      xTable[i] = JulianDate.secondsDifference(\n        times[firstIndex + i],\n        times[lastIndex]\n      );\n    }\n\n    if (!defined(innerType.convertPackedArrayForInterpolation)) {\n      var destinationIndex = 0;\n      var packedLength = this._packedLength;\n      var sourceIndex = firstIndex * packedLength;\n      var stop = (lastIndex + 1) * packedLength;\n\n      while (sourceIndex < stop) {\n        yTable[destinationIndex] = values[sourceIndex];\n        sourceIndex++;\n        destinationIndex++;\n      }\n    } else {\n      innerType.convertPackedArrayForInterpolation(\n        values,\n        firstIndex,\n        lastIndex,\n        yTable\n      );\n    }\n\n    // Interpolate!\n    var x = JulianDate.secondsDifference(time, times[lastIndex]);\n    var interpolationResult;\n    if (inputOrder === 0 || !defined(interpolationAlgorithm.interpolate)) {\n      interpolationResult = interpolationAlgorithm.interpolateOrderZero(\n        x,\n        xTable,\n        yTable,\n        packedInterpolationLength,\n        this._interpolationResult\n      );\n    } else {\n      var yStride = Math.floor(packedInterpolationLength / (inputOrder + 1));\n      interpolationResult = interpolationAlgorithm.interpolate(\n        x,\n        xTable,\n        yTable,\n        yStride,\n        inputOrder,\n        inputOrder,\n        this._interpolationResult\n      );\n    }\n\n    if (!defined(innerType.unpackInterpolationResult)) {\n      return innerType.unpack(interpolationResult, 0, result);\n    }\n    return innerType.unpackInterpolationResult(\n      interpolationResult,\n      values,\n      firstIndex,\n      lastIndex,\n      result\n    );\n  }\n  return innerType.unpack(values, index * this._packedLength, result);\n};\n\n/**\n * Sets the algorithm and degree to use when interpolating a value.\n *\n * @param {Object} [options] Object with the following properties:\n * @param {InterpolationAlgorithm} [options.interpolationAlgorithm] The new interpolation algorithm.  If undefined, the existing property will be unchanged.\n * @param {Number} [options.interpolationDegree] The new interpolation degree.  If undefined, the existing property will be unchanged.\n */\nSampledProperty.prototype.setInterpolationOptions = function (options) {\n  if (!defined(options)) {\n    return;\n  }\n\n  var valuesChanged = false;\n\n  var interpolationAlgorithm = options.interpolationAlgorithm;\n  var interpolationDegree = options.interpolationDegree;\n\n  if (\n    defined(interpolationAlgorithm) &&\n    this._interpolationAlgorithm !== interpolationAlgorithm\n  ) {\n    this._interpolationAlgorithm = interpolationAlgorithm;\n    valuesChanged = true;\n  }\n\n  if (\n    defined(interpolationDegree) &&\n    this._interpolationDegree !== interpolationDegree\n  ) {\n    this._interpolationDegree = interpolationDegree;\n    valuesChanged = true;\n  }\n\n  if (valuesChanged) {\n    this._updateTableLength = true;\n    this._definitionChanged.raiseEvent(this);\n  }\n};\n\n/**\n * Adds a new sample.\n *\n * @param {JulianDate} time The sample time.\n * @param {Packable} value The value at the provided time.\n * @param {Packable[]} [derivatives] The array of derivatives at the provided time.\n */\nSampledProperty.prototype.addSample = function (time, value, derivatives) {\n  var innerDerivativeTypes = this._innerDerivativeTypes;\n  var hasDerivatives = defined(innerDerivativeTypes);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  Check.defined(\"value\", value);\n  if (hasDerivatives) {\n    Check.defined(\"derivatives\", derivatives);\n  }\n  //>>includeEnd('debug');\n\n  var innerType = this._innerType;\n  var data = [];\n  data.push(time);\n  innerType.pack(value, data, data.length);\n\n  if (hasDerivatives) {\n    var derivativesLength = innerDerivativeTypes.length;\n    for (var x = 0; x < derivativesLength; x++) {\n      innerDerivativeTypes[x].pack(derivatives[x], data, data.length);\n    }\n  }\n  mergeNewSamples(\n    undefined,\n    this._times,\n    this._values,\n    data,\n    this._packedLength\n  );\n  this._updateTableLength = true;\n  this._definitionChanged.raiseEvent(this);\n};\n\n/**\n * Adds an array of samples.\n *\n * @param {JulianDate[]} times An array of JulianDate instances where each index is a sample time.\n * @param {Packable[]} values The array of values, where each value corresponds to the provided times index.\n * @param {Array[]} [derivativeValues] An array where each item is the array of derivatives at the equivalent time index.\n *\n * @exception {DeveloperError} times and values must be the same length.\n * @exception {DeveloperError} times and derivativeValues must be the same length.\n */\nSampledProperty.prototype.addSamples = function (\n  times,\n  values,\n  derivativeValues\n) {\n  var innerDerivativeTypes = this._innerDerivativeTypes;\n  var hasDerivatives = defined(innerDerivativeTypes);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"times\", times);\n  Check.defined(\"values\", values);\n  if (times.length !== values.length) {\n    throw new DeveloperError(\"times and values must be the same length.\");\n  }\n  if (\n    hasDerivatives &&\n    (!defined(derivativeValues) || derivativeValues.length !== times.length)\n  ) {\n    throw new DeveloperError(\n      \"times and derivativeValues must be the same length.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var innerType = this._innerType;\n  var length = times.length;\n  var data = [];\n  for (var i = 0; i < length; i++) {\n    data.push(times[i]);\n    innerType.pack(values[i], data, data.length);\n\n    if (hasDerivatives) {\n      var derivatives = derivativeValues[i];\n      var derivativesLength = innerDerivativeTypes.length;\n      for (var x = 0; x < derivativesLength; x++) {\n        innerDerivativeTypes[x].pack(derivatives[x], data, data.length);\n      }\n    }\n  }\n  mergeNewSamples(\n    undefined,\n    this._times,\n    this._values,\n    data,\n    this._packedLength\n  );\n  this._updateTableLength = true;\n  this._definitionChanged.raiseEvent(this);\n};\n\n/**\n * Adds samples as a single packed array where each new sample is represented as a date,\n * followed by the packed representation of the corresponding value and derivatives.\n *\n * @param {Number[]} packedSamples The array of packed samples.\n * @param {JulianDate} [epoch] If any of the dates in packedSamples are numbers, they are considered an offset from this epoch, in seconds.\n */\nSampledProperty.prototype.addSamplesPackedArray = function (\n  packedSamples,\n  epoch\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"packedSamples\", packedSamples);\n  //>>includeEnd('debug');\n\n  mergeNewSamples(\n    epoch,\n    this._times,\n    this._values,\n    packedSamples,\n    this._packedLength\n  );\n  this._updateTableLength = true;\n  this._definitionChanged.raiseEvent(this);\n};\n\n/**\n * Removes a sample at the given time, if present.\n *\n * @param {JulianDate} time The sample time.\n * @returns {Boolean} <code>true</code> if a sample at time was removed, <code>false</code> otherwise.\n */\nSampledProperty.prototype.removeSample = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  //>>includeEnd('debug');\n\n  var index = binarySearch(this._times, time, JulianDate.compare);\n  if (index < 0) {\n    return false;\n  }\n  removeSamples(this, index, 1);\n  return true;\n};\n\nfunction removeSamples(property, startIndex, numberToRemove) {\n  var packedLength = property._packedLength;\n  property._times.splice(startIndex, numberToRemove);\n  property._values.splice(\n    startIndex * packedLength,\n    numberToRemove * packedLength\n  );\n  property._updateTableLength = true;\n  property._definitionChanged.raiseEvent(property);\n}\n\n/**\n * Removes all samples for the given time interval.\n *\n * @param {TimeInterval} time The time interval for which to remove all samples.\n */\nSampledProperty.prototype.removeSamples = function (timeInterval) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"timeInterval\", timeInterval);\n  //>>includeEnd('debug');\n\n  var times = this._times;\n  var startIndex = binarySearch(times, timeInterval.start, JulianDate.compare);\n  if (startIndex < 0) {\n    startIndex = ~startIndex;\n  } else if (!timeInterval.isStartIncluded) {\n    ++startIndex;\n  }\n  var stopIndex = binarySearch(times, timeInterval.stop, JulianDate.compare);\n  if (stopIndex < 0) {\n    stopIndex = ~stopIndex;\n  } else if (timeInterval.isStopIncluded) {\n    ++stopIndex;\n  }\n\n  removeSamples(this, startIndex, stopIndex - startIndex);\n};\n\n/**\n * Compares this property to the provided property and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Property} [other] The other property.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nSampledProperty.prototype.equals = function (other) {\n  if (this === other) {\n    return true;\n  }\n  if (!defined(other)) {\n    return false;\n  }\n\n  if (\n    this._type !== other._type || //\n    this._interpolationDegree !== other._interpolationDegree || //\n    this._interpolationAlgorithm !== other._interpolationAlgorithm\n  ) {\n    return false;\n  }\n\n  var derivativeTypes = this._derivativeTypes;\n  var hasDerivatives = defined(derivativeTypes);\n  var otherDerivativeTypes = other._derivativeTypes;\n  var otherHasDerivatives = defined(otherDerivativeTypes);\n  if (hasDerivatives !== otherHasDerivatives) {\n    return false;\n  }\n\n  var i;\n  var length;\n  if (hasDerivatives) {\n    length = derivativeTypes.length;\n    if (length !== otherDerivativeTypes.length) {\n      return false;\n    }\n\n    for (i = 0; i < length; i++) {\n      if (derivativeTypes[i] !== otherDerivativeTypes[i]) {\n        return false;\n      }\n    }\n  }\n\n  var times = this._times;\n  var otherTimes = other._times;\n  length = times.length;\n\n  if (length !== otherTimes.length) {\n    return false;\n  }\n\n  for (i = 0; i < length; i++) {\n    if (!JulianDate.equals(times[i], otherTimes[i])) {\n      return false;\n    }\n  }\n\n  var values = this._values;\n  var otherValues = other._values;\n  for (i = 0; i < length; i++) {\n    if (values[i] !== otherValues[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n//Exposed for testing.\nSampledProperty._mergeNewSamples = mergeNewSamples;\nexport default SampledProperty;\n"]},"metadata":{},"sourceType":"module"}