{"ast":null,"code":"import arrayFill from \"../Core/arrayFill.js\";\nimport Check from \"../Core/Check.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Event from \"../Core/Event.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Resource from \"../Core/Resource.js\";\nimport when from \"../ThirdParty/when.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nimport PointCloud from \"./PointCloud.js\";\nimport PointCloudEyeDomeLighting from \"./PointCloudEyeDomeLighting.js\";\nimport PointCloudShading from \"./PointCloudShading.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\n/**\n * Provides playback of time-dynamic point cloud data.\n * <p>\n * Point cloud frames are prefetched in intervals determined by the average frame load time and the current clock speed.\n * If intermediate frames cannot be loaded in time to meet playback speed, they will be skipped. If frames are sufficiently\n * small or the clock is sufficiently slow then no frames will be skipped.\n * </p>\n *\n * @alias TimeDynamicPointCloud\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Clock} options.clock A {@link Clock} instance that is used when determining the value for the time dimension.\n * @param {TimeIntervalCollection} options.intervals A {@link TimeIntervalCollection} with its data property being an object containing a <code>uri</code> to a 3D Tiles Point Cloud tile and an optional <code>transform</code>.\n * @param {Boolean} [options.show=true] Determines if the point cloud will be shown.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] A 4x4 transformation matrix that transforms the point cloud.\n * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the point cloud casts or receives shadows from light sources.\n * @param {Number} [options.maximumMemoryUsage=256] The maximum amount of memory in MB that can be used by the point cloud.\n * @param {Object} [options.shading] Options for constructing a {@link PointCloudShading} object to control point attenuation and eye dome lighting.\n * @param {Cesium3DTileStyle} [options.style] The style, defined using the {@link https://github.com/CesiumGS/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language}, applied to each point in the point cloud.\n * @param {ClippingPlaneCollection} [options.clippingPlanes] The {@link ClippingPlaneCollection} used to selectively disable rendering the point cloud.\n */\n\nfunction TimeDynamicPointCloud(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);\n\n  Check.typeOf.object(\"options.clock\", options.clock);\n  Check.typeOf.object(\"options.intervals\", options.intervals); //>>includeEnd('debug');\n\n  /**\n   * Determines if the point cloud will be shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.show = defaultValue(options.show, true);\n  /**\n   * A 4x4 transformation matrix that transforms the point cloud.\n   *\n   * @type {Matrix4}\n   * @default Matrix4.IDENTITY\n   */\n\n  this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));\n  /**\n   * Determines whether the point cloud casts or receives shadows from light sources.\n   * <p>\n   * Enabling shadows has a performance impact. A point cloud that casts shadows must be rendered twice, once from the camera and again from the light's point of view.\n   * </p>\n   * <p>\n   * Shadows are rendered only when {@link Viewer#shadows} is <code>true</code>.\n   * </p>\n   *\n   * @type {ShadowMode}\n   * @default ShadowMode.ENABLED\n   */\n\n  this.shadows = defaultValue(options.shadows, ShadowMode.ENABLED);\n  /**\n   * The maximum amount of GPU memory (in MB) that may be used to cache point cloud frames.\n   * <p>\n   * Frames that are not being loaded or rendered are unloaded to enforce this.\n   * </p>\n   * <p>\n   * If decreasing this value results in unloading tiles, the tiles are unloaded the next frame.\n   * </p>\n   *\n   * @type {Number}\n   * @default 256\n   *\n   * @see TimeDynamicPointCloud#totalMemoryUsageInBytes\n   */\n\n  this.maximumMemoryUsage = defaultValue(options.maximumMemoryUsage, 256);\n  /**\n   * Options for controlling point size based on geometric error and eye dome lighting.\n   * @type {PointCloudShading}\n   */\n\n  this.shading = new PointCloudShading(options.shading);\n  /**\n   * The style, defined using the\n   * {@link https://github.com/CesiumGS/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language},\n   * applied to each point in the point cloud.\n   * <p>\n   * Assign <code>undefined</code> to remove the style, which will restore the visual\n   * appearance of the point cloud to its default when no style was applied.\n   * </p>\n   *\n   * @type {Cesium3DTileStyle}\n   *\n   * @example\n   * pointCloud.style = new Cesium.Cesium3DTileStyle({\n   *    color : {\n   *        conditions : [\n   *            ['${Classification} === 0', 'color(\"purple\", 0.5)'],\n   *            ['${Classification} === 1', 'color(\"red\")'],\n   *            ['true', '${COLOR}']\n   *        ]\n   *    },\n   *    show : '${Classification} !== 2'\n   * });\n   *\n   * @see {@link https://github.com/CesiumGS/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language}\n   */\n\n  this.style = options.style;\n  /**\n   * The event fired to indicate that a frame failed to load. A frame may fail to load if the\n   * request for its uri fails or processing fails due to invalid content.\n   * <p>\n   * If there are no event listeners, error messages will be logged to the console.\n   * </p>\n   * <p>\n   * The error object passed to the listener contains two properties:\n   * <ul>\n   * <li><code>uri</code>: the uri of the failed frame.</li>\n   * <li><code>message</code>: the error message.</li>\n   * </ul>\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * pointCloud.frameFailed.addEventListener(function(error) {\n   *     console.log('An error occurred loading frame: ' + error.uri);\n   *     console.log('Error: ' + error.message);\n   * });\n   */\n\n  this.frameFailed = new Event();\n  /**\n   * The event fired to indicate that a new frame was rendered.\n   * <p>\n   * The time dynamic point cloud {@link TimeDynamicPointCloud} is passed to the event listener.\n   * </p>\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * pointCloud.frameChanged.addEventListener(function(timeDynamicPointCloud) {\n   *     viewer.camera.viewBoundingSphere(timeDynamicPointCloud.boundingSphere);\n   * });\n   */\n\n  this.frameChanged = new Event();\n  this._clock = options.clock;\n  this._intervals = options.intervals;\n  this._clippingPlanes = undefined;\n  this.clippingPlanes = options.clippingPlanes; // Call setter\n\n  this._pointCloudEyeDomeLighting = new PointCloudEyeDomeLighting();\n  this._loadTimestamp = undefined;\n  this._clippingPlanesState = 0;\n  this._styleDirty = false;\n  this._pickId = undefined;\n  this._totalMemoryUsageInBytes = 0;\n  this._frames = [];\n  this._previousInterval = undefined;\n  this._nextInterval = undefined;\n  this._lastRenderedFrame = undefined;\n  this._clockMultiplier = 0.0;\n  this._readyPromise = when.defer(); // For calculating average load time of the last N frames\n\n  this._runningSum = 0.0;\n  this._runningLength = 0;\n  this._runningIndex = 0;\n  this._runningSamples = arrayFill(new Array(5), 0.0);\n  this._runningAverage = 0.0;\n}\n\nObject.defineProperties(TimeDynamicPointCloud.prototype, {\n  /**\n   * The {@link ClippingPlaneCollection} used to selectively disable rendering the point cloud.\n   *\n   * @memberof TimeDynamicPointCloud.prototype\n   *\n   * @type {ClippingPlaneCollection}\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._clippingPlanes;\n    },\n    set: function (value) {\n      ClippingPlaneCollection.setOwner(value, this, \"_clippingPlanes\");\n    }\n  },\n\n  /**\n   * The total amount of GPU memory in bytes used by the point cloud.\n   *\n   * @memberof TimeDynamicPointCloud.prototype\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @see TimeDynamicPointCloud#maximumMemoryUsage\n   */\n  totalMemoryUsageInBytes: {\n    get: function () {\n      return this._totalMemoryUsageInBytes;\n    }\n  },\n\n  /**\n   * The bounding sphere of the frame being rendered. Returns <code>undefined</code> if no frame is being rendered.\n   *\n   * @memberof TimeDynamicPointCloud.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      if (defined(this._lastRenderedFrame)) {\n        return this._lastRenderedFrame.pointCloud.boundingSphere;\n      }\n\n      return undefined;\n    }\n  },\n\n  /**\n   * Gets the promise that will be resolved when the point cloud renders a frame for the first time.\n   *\n   * @memberof TimeDynamicPointCloud.prototype\n   *\n   * @type {Promise.<TimeDynamicPointCloud>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    }\n  }\n});\n\nfunction getFragmentShaderLoaded(fs) {\n  return \"uniform vec4 czm_pickColor;\\n\" + fs;\n}\n\nfunction getUniformMapLoaded(stream) {\n  return function (uniformMap) {\n    return combine(uniformMap, {\n      czm_pickColor: function () {\n        return stream._pickId.color;\n      }\n    });\n  };\n}\n\nfunction getPickIdLoaded() {\n  return \"czm_pickColor\";\n}\n/**\n * Marks the point cloud's {@link TimeDynamicPointCloud#style} as dirty, which forces all\n * points to re-evaluate the style in the next frame.\n */\n\n\nTimeDynamicPointCloud.prototype.makeStyleDirty = function () {\n  this._styleDirty = true;\n};\n/**\n * Exposed for testing.\n *\n * @private\n */\n\n\nTimeDynamicPointCloud.prototype._getAverageLoadTime = function () {\n  if (this._runningLength === 0) {\n    // Before any frames have loaded make a best guess about the average load time\n    return 0.05;\n  }\n\n  return this._runningAverage;\n};\n\nvar scratchDate = new JulianDate();\n\nfunction getClockMultiplier(that) {\n  var clock = that._clock;\n  var isAnimating = clock.canAnimate && clock.shouldAnimate;\n  var multiplier = clock.multiplier;\n  return isAnimating ? multiplier : 0.0;\n}\n\nfunction getIntervalIndex(that, interval) {\n  return that._intervals.indexOf(interval.start);\n}\n\nfunction getNextInterval(that, currentInterval) {\n  var intervals = that._intervals;\n  var clock = that._clock;\n  var multiplier = getClockMultiplier(that);\n\n  if (multiplier === 0.0) {\n    return undefined;\n  }\n\n  var averageLoadTime = that._getAverageLoadTime();\n\n  var time = JulianDate.addSeconds(clock.currentTime, averageLoadTime * multiplier, scratchDate);\n  var index = intervals.indexOf(time);\n  var currentIndex = getIntervalIndex(that, currentInterval);\n\n  if (index === currentIndex) {\n    if (multiplier >= 0) {\n      ++index;\n    } else {\n      --index;\n    }\n  } // Returns undefined if not in range\n\n\n  return intervals.get(index);\n}\n\nfunction getCurrentInterval(that) {\n  var intervals = that._intervals;\n  var clock = that._clock;\n  var time = clock.currentTime;\n  var index = intervals.indexOf(time); // Returns undefined if not in range\n\n  return intervals.get(index);\n}\n\nfunction reachedInterval(that, currentInterval, nextInterval) {\n  var multiplier = getClockMultiplier(that);\n  var currentIndex = getIntervalIndex(that, currentInterval);\n  var nextIndex = getIntervalIndex(that, nextInterval);\n\n  if (multiplier >= 0) {\n    return currentIndex >= nextIndex;\n  }\n\n  return currentIndex <= nextIndex;\n}\n\nfunction handleFrameFailure(that, uri) {\n  return function (error) {\n    var message = defined(error.message) ? error.message : error.toString();\n\n    if (that.frameFailed.numberOfListeners > 0) {\n      that.frameFailed.raiseEvent({\n        uri: uri,\n        message: message\n      });\n    } else {\n      console.log(\"A frame failed to load: \" + uri);\n      console.log(\"Error: \" + message);\n    }\n  };\n}\n\nfunction requestFrame(that, interval, frameState) {\n  var index = getIntervalIndex(that, interval);\n  var frames = that._frames;\n  var frame = frames[index];\n\n  if (!defined(frame)) {\n    var transformArray = interval.data.transform;\n    var transform = defined(transformArray) ? Matrix4.fromArray(transformArray) : undefined;\n    var uri = interval.data.uri;\n    frame = {\n      pointCloud: undefined,\n      transform: transform,\n      timestamp: getTimestamp(),\n      sequential: true,\n      ready: false,\n      touchedFrameNumber: frameState.frameNumber\n    };\n    frames[index] = frame;\n    Resource.fetchArrayBuffer({\n      url: uri\n    }).then(function (arrayBuffer) {\n      // PERFORMANCE_IDEA: share a memory pool, render states, shaders, and other resources among all\n      // frames. Each frame just needs an index/offset into the pool.\n      frame.pointCloud = new PointCloud({\n        arrayBuffer: arrayBuffer,\n        cull: true,\n        fragmentShaderLoaded: getFragmentShaderLoaded,\n        uniformMapLoaded: getUniformMapLoaded(that),\n        pickIdLoaded: getPickIdLoaded\n      });\n      return frame.pointCloud.readyPromise;\n    }).otherwise(handleFrameFailure(that, uri));\n  }\n\n  return frame;\n}\n\nfunction updateAverageLoadTime(that, loadTime) {\n  that._runningSum += loadTime;\n  that._runningSum -= that._runningSamples[that._runningIndex];\n  that._runningSamples[that._runningIndex] = loadTime;\n  that._runningLength = Math.min(that._runningLength + 1, that._runningSamples.length);\n  that._runningIndex = (that._runningIndex + 1) % that._runningSamples.length;\n  that._runningAverage = that._runningSum / that._runningLength;\n}\n\nfunction prepareFrame(that, frame, updateState, frameState) {\n  if (frame.touchedFrameNumber < frameState.frameNumber - 1) {\n    // If this frame was not loaded in sequential updates then it can't be used it for calculating the average load time.\n    // For example: selecting a frame on the timeline, selecting another frame before the request finishes, then selecting this frame later.\n    frame.sequential = false;\n  }\n\n  var pointCloud = frame.pointCloud;\n\n  if (defined(pointCloud) && !frame.ready) {\n    // Call update to prepare renderer resources. Don't render anything yet.\n    var commandList = frameState.commandList;\n    var lengthBeforeUpdate = commandList.length;\n    renderFrame(that, frame, updateState, frameState);\n\n    if (pointCloud.ready) {\n      // Point cloud became ready this update\n      frame.ready = true;\n      that._totalMemoryUsageInBytes += pointCloud.geometryByteLength;\n      commandList.length = lengthBeforeUpdate; // Don't allow preparing frame to insert commands.\n\n      if (frame.sequential) {\n        // Update the values used to calculate average load time\n        var loadTime = (getTimestamp() - frame.timestamp) / 1000.0;\n        updateAverageLoadTime(that, loadTime);\n      }\n    }\n  }\n\n  frame.touchedFrameNumber = frameState.frameNumber;\n}\n\nvar scratchModelMatrix = new Matrix4();\n\nfunction getGeometricError(that, pointCloud) {\n  var shading = that.shading;\n\n  if (defined(shading) && defined(shading.baseResolution)) {\n    return shading.baseResolution;\n  } else if (defined(pointCloud.boundingSphere)) {\n    return CesiumMath.cbrt(pointCloud.boundingSphere.volume() / pointCloud.pointsLength);\n  }\n\n  return 0.0;\n}\n\nfunction getMaximumAttenuation(that) {\n  var shading = that.shading;\n\n  if (defined(shading) && defined(shading.maximumAttenuation)) {\n    return shading.maximumAttenuation;\n  } // Return a hardcoded maximum attenuation. For a tileset this would instead be the maximum screen space error.\n\n\n  return 10.0;\n}\n\nvar defaultShading = new PointCloudShading();\n\nfunction renderFrame(that, frame, updateState, frameState) {\n  var shading = defaultValue(that.shading, defaultShading);\n  var pointCloud = frame.pointCloud;\n  var transform = defaultValue(frame.transform, Matrix4.IDENTITY);\n  pointCloud.modelMatrix = Matrix4.multiplyTransformation(that.modelMatrix, transform, scratchModelMatrix);\n  pointCloud.style = that.style;\n  pointCloud.time = updateState.timeSinceLoad;\n  pointCloud.shadows = that.shadows;\n  pointCloud.clippingPlanes = that._clippingPlanes;\n  pointCloud.isClipped = updateState.isClipped;\n  pointCloud.attenuation = shading.attenuation;\n  pointCloud.backFaceCulling = shading.backFaceCulling;\n  pointCloud.normalShading = shading.normalShading;\n  pointCloud.geometricError = getGeometricError(that, pointCloud);\n  pointCloud.geometricErrorScale = shading.geometricErrorScale;\n  pointCloud.maximumAttenuation = getMaximumAttenuation(that);\n  pointCloud.update(frameState);\n  frame.touchedFrameNumber = frameState.frameNumber;\n}\n\nfunction loadFrame(that, interval, updateState, frameState) {\n  var frame = requestFrame(that, interval, frameState);\n  prepareFrame(that, frame, updateState, frameState);\n}\n\nfunction getUnloadCondition(frameState) {\n  return function (frame) {\n    // Unload all frames that aren't currently being loaded or rendered\n    return frame.touchedFrameNumber < frameState.frameNumber;\n  };\n}\n\nfunction unloadFrames(that, unloadCondition) {\n  var frames = that._frames;\n  var length = frames.length;\n\n  for (var i = 0; i < length; ++i) {\n    var frame = frames[i];\n\n    if (defined(frame)) {\n      if (!defined(unloadCondition) || unloadCondition(frame)) {\n        var pointCloud = frame.pointCloud;\n\n        if (frame.ready) {\n          that._totalMemoryUsageInBytes -= pointCloud.geometryByteLength;\n        }\n\n        if (defined(pointCloud)) {\n          pointCloud.destroy();\n        }\n\n        if (frame === that._lastRenderedFrame) {\n          that._lastRenderedFrame = undefined;\n        }\n\n        frames[i] = undefined;\n      }\n    }\n  }\n}\n\nfunction getFrame(that, interval) {\n  var index = getIntervalIndex(that, interval);\n  var frame = that._frames[index];\n\n  if (defined(frame) && frame.ready) {\n    return frame;\n  }\n}\n\nfunction updateInterval(that, interval, frame, updateState, frameState) {\n  if (defined(frame)) {\n    if (frame.ready) {\n      return true;\n    }\n\n    loadFrame(that, interval, updateState, frameState);\n    return frame.ready;\n  }\n\n  return false;\n}\n\nfunction getNearestReadyInterval(that, previousInterval, currentInterval, updateState, frameState) {\n  var i;\n  var interval;\n  var frame;\n  var intervals = that._intervals;\n  var frames = that._frames;\n  var currentIndex = getIntervalIndex(that, currentInterval);\n  var previousIndex = getIntervalIndex(that, previousInterval);\n\n  if (currentIndex >= previousIndex) {\n    // look backwards\n    for (i = currentIndex; i >= previousIndex; --i) {\n      interval = intervals.get(i);\n      frame = frames[i];\n\n      if (updateInterval(that, interval, frame, updateState, frameState)) {\n        return interval;\n      }\n    }\n  } else {\n    // look forwards\n    for (i = currentIndex; i <= previousIndex; ++i) {\n      interval = intervals.get(i);\n      frame = frames[i];\n\n      if (updateInterval(that, interval, frame, updateState, frameState)) {\n        return interval;\n      }\n    }\n  } // If no intervals are ready return the previous interval\n\n\n  return previousInterval;\n}\n\nfunction setFramesDirty(that, clippingPlanesDirty, styleDirty) {\n  var frames = that._frames;\n  var framesLength = frames.length;\n\n  for (var i = 0; i < framesLength; ++i) {\n    var frame = frames[i];\n\n    if (defined(frame) && defined(frame.pointCloud)) {\n      frame.pointCloud.clippingPlanesDirty = clippingPlanesDirty;\n      frame.pointCloud.styleDirty = styleDirty;\n    }\n  }\n}\n\nvar updateState = {\n  timeSinceLoad: 0,\n  isClipped: false,\n  clippingPlanesDirty: false\n};\n/**\n * @private\n */\n\nTimeDynamicPointCloud.prototype.update = function (frameState) {\n  if (frameState.mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  if (!this.show) {\n    return;\n  }\n\n  if (!defined(this._pickId)) {\n    this._pickId = frameState.context.createPickId({\n      primitive: this\n    });\n  }\n\n  if (!defined(this._loadTimestamp)) {\n    this._loadTimestamp = JulianDate.clone(frameState.time);\n  } // For styling\n\n\n  var timeSinceLoad = Math.max(JulianDate.secondsDifference(frameState.time, this._loadTimestamp) * 1000, 0.0); // Update clipping planes\n\n  var clippingPlanes = this._clippingPlanes;\n  var clippingPlanesState = 0;\n  var clippingPlanesDirty = false;\n  var isClipped = defined(clippingPlanes) && clippingPlanes.enabled;\n\n  if (isClipped) {\n    clippingPlanes.update(frameState);\n    clippingPlanesState = clippingPlanes.clippingPlanesState;\n  }\n\n  if (this._clippingPlanesState !== clippingPlanesState) {\n    this._clippingPlanesState = clippingPlanesState;\n    clippingPlanesDirty = true;\n  }\n\n  var styleDirty = this._styleDirty;\n  this._styleDirty = false;\n\n  if (clippingPlanesDirty || styleDirty) {\n    setFramesDirty(this, clippingPlanesDirty, styleDirty);\n  }\n\n  updateState.timeSinceLoad = timeSinceLoad;\n  updateState.isClipped = isClipped;\n  var shading = this.shading;\n  var eyeDomeLighting = this._pointCloudEyeDomeLighting;\n  var commandList = frameState.commandList;\n  var lengthBeforeUpdate = commandList.length;\n  var previousInterval = this._previousInterval;\n  var nextInterval = this._nextInterval;\n  var currentInterval = getCurrentInterval(this);\n\n  if (!defined(currentInterval)) {\n    return;\n  }\n\n  var clockMultiplierChanged = false;\n  var clockMultiplier = getClockMultiplier(this);\n  var clockPaused = clockMultiplier === 0;\n\n  if (clockMultiplier !== this._clockMultiplier) {\n    clockMultiplierChanged = true;\n    this._clockMultiplier = clockMultiplier;\n  }\n\n  if (!defined(previousInterval) || clockPaused) {\n    previousInterval = currentInterval;\n  }\n\n  if (!defined(nextInterval) || clockMultiplierChanged || reachedInterval(this, currentInterval, nextInterval)) {\n    nextInterval = getNextInterval(this, currentInterval);\n  }\n\n  previousInterval = getNearestReadyInterval(this, previousInterval, currentInterval, updateState, frameState);\n  var frame = getFrame(this, previousInterval);\n\n  if (!defined(frame)) {\n    // The frame is not ready to render. This can happen when the simulation starts or when scrubbing the timeline\n    // to a frame that hasn't loaded yet. Just render the last rendered frame in its place until it finishes loading.\n    loadFrame(this, previousInterval, updateState, frameState);\n    frame = this._lastRenderedFrame;\n  }\n\n  if (defined(frame)) {\n    renderFrame(this, frame, updateState, frameState);\n  }\n\n  if (defined(nextInterval)) {\n    // Start loading the next frame\n    loadFrame(this, nextInterval, updateState, frameState);\n  }\n\n  var that = this;\n\n  if (defined(frame) && !defined(this._lastRenderedFrame)) {\n    frameState.afterRender.push(function () {\n      that._readyPromise.resolve(that);\n    });\n  }\n\n  if (defined(frame) && frame !== this._lastRenderedFrame) {\n    if (that.frameChanged.numberOfListeners > 0) {\n      frameState.afterRender.push(function () {\n        that.frameChanged.raiseEvent(that);\n      });\n    }\n  }\n\n  this._previousInterval = previousInterval;\n  this._nextInterval = nextInterval;\n  this._lastRenderedFrame = frame;\n  var totalMemoryUsageInBytes = this._totalMemoryUsageInBytes;\n  var maximumMemoryUsageInBytes = this.maximumMemoryUsage * 1024 * 1024;\n\n  if (totalMemoryUsageInBytes > maximumMemoryUsageInBytes) {\n    unloadFrames(this, getUnloadCondition(frameState));\n  }\n\n  var lengthAfterUpdate = commandList.length;\n  var addedCommandsLength = lengthAfterUpdate - lengthBeforeUpdate;\n\n  if (defined(shading) && shading.attenuation && shading.eyeDomeLighting && addedCommandsLength > 0) {\n    eyeDomeLighting.update(frameState, lengthBeforeUpdate, shading, this.boundingSphere);\n  }\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see TimeDynamicPointCloud#destroy\n */\n\n\nTimeDynamicPointCloud.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * pointCloud = pointCloud && pointCloud.destroy();\n *\n * @see TimeDynamicPointCloud#isDestroyed\n */\n\n\nTimeDynamicPointCloud.prototype.destroy = function () {\n  unloadFrames(this);\n  this._clippingPlanes = this._clippingPlanes && this._clippingPlanes.destroy();\n  this._pickId = this._pickId && this._pickId.destroy();\n  return destroyObject(this);\n};\n\nexport default TimeDynamicPointCloud;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/TimeDynamicPointCloud.js"],"names":["arrayFill","Check","combine","defaultValue","defined","destroyObject","Event","getTimestamp","JulianDate","CesiumMath","Matrix4","Resource","when","ClippingPlaneCollection","PointCloud","PointCloudEyeDomeLighting","PointCloudShading","SceneMode","ShadowMode","TimeDynamicPointCloud","options","EMPTY_OBJECT","typeOf","object","clock","intervals","show","modelMatrix","clone","IDENTITY","shadows","ENABLED","maximumMemoryUsage","shading","style","frameFailed","frameChanged","_clock","_intervals","_clippingPlanes","undefined","clippingPlanes","_pointCloudEyeDomeLighting","_loadTimestamp","_clippingPlanesState","_styleDirty","_pickId","_totalMemoryUsageInBytes","_frames","_previousInterval","_nextInterval","_lastRenderedFrame","_clockMultiplier","_readyPromise","defer","_runningSum","_runningLength","_runningIndex","_runningSamples","Array","_runningAverage","Object","defineProperties","prototype","get","set","value","setOwner","totalMemoryUsageInBytes","boundingSphere","pointCloud","readyPromise","promise","getFragmentShaderLoaded","fs","getUniformMapLoaded","stream","uniformMap","czm_pickColor","color","getPickIdLoaded","makeStyleDirty","_getAverageLoadTime","scratchDate","getClockMultiplier","that","isAnimating","canAnimate","shouldAnimate","multiplier","getIntervalIndex","interval","indexOf","start","getNextInterval","currentInterval","averageLoadTime","time","addSeconds","currentTime","index","currentIndex","getCurrentInterval","reachedInterval","nextInterval","nextIndex","handleFrameFailure","uri","error","message","toString","numberOfListeners","raiseEvent","console","log","requestFrame","frameState","frames","frame","transformArray","data","transform","fromArray","timestamp","sequential","ready","touchedFrameNumber","frameNumber","fetchArrayBuffer","url","then","arrayBuffer","cull","fragmentShaderLoaded","uniformMapLoaded","pickIdLoaded","otherwise","updateAverageLoadTime","loadTime","Math","min","length","prepareFrame","updateState","commandList","lengthBeforeUpdate","renderFrame","geometryByteLength","scratchModelMatrix","getGeometricError","baseResolution","cbrt","volume","pointsLength","getMaximumAttenuation","maximumAttenuation","defaultShading","multiplyTransformation","timeSinceLoad","isClipped","attenuation","backFaceCulling","normalShading","geometricError","geometricErrorScale","update","loadFrame","getUnloadCondition","unloadFrames","unloadCondition","i","destroy","getFrame","updateInterval","getNearestReadyInterval","previousInterval","previousIndex","setFramesDirty","clippingPlanesDirty","styleDirty","framesLength","mode","MORPHING","context","createPickId","primitive","max","secondsDifference","clippingPlanesState","enabled","eyeDomeLighting","clockMultiplierChanged","clockMultiplier","clockPaused","afterRender","push","resolve","maximumMemoryUsageInBytes","lengthAfterUpdate","addedCommandsLength","isDestroyed"],"mappings":"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","sourcesContent":["import arrayFill from \"../Core/arrayFill.js\";\nimport Check from \"../Core/Check.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Event from \"../Core/Event.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Resource from \"../Core/Resource.js\";\nimport when from \"../ThirdParty/when.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nimport PointCloud from \"./PointCloud.js\";\nimport PointCloudEyeDomeLighting from \"./PointCloudEyeDomeLighting.js\";\nimport PointCloudShading from \"./PointCloudShading.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\n\n/**\n * Provides playback of time-dynamic point cloud data.\n * <p>\n * Point cloud frames are prefetched in intervals determined by the average frame load time and the current clock speed.\n * If intermediate frames cannot be loaded in time to meet playback speed, they will be skipped. If frames are sufficiently\n * small or the clock is sufficiently slow then no frames will be skipped.\n * </p>\n *\n * @alias TimeDynamicPointCloud\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Clock} options.clock A {@link Clock} instance that is used when determining the value for the time dimension.\n * @param {TimeIntervalCollection} options.intervals A {@link TimeIntervalCollection} with its data property being an object containing a <code>uri</code> to a 3D Tiles Point Cloud tile and an optional <code>transform</code>.\n * @param {Boolean} [options.show=true] Determines if the point cloud will be shown.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] A 4x4 transformation matrix that transforms the point cloud.\n * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the point cloud casts or receives shadows from light sources.\n * @param {Number} [options.maximumMemoryUsage=256] The maximum amount of memory in MB that can be used by the point cloud.\n * @param {Object} [options.shading] Options for constructing a {@link PointCloudShading} object to control point attenuation and eye dome lighting.\n * @param {Cesium3DTileStyle} [options.style] The style, defined using the {@link https://github.com/CesiumGS/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language}, applied to each point in the point cloud.\n * @param {ClippingPlaneCollection} [options.clippingPlanes] The {@link ClippingPlaneCollection} used to selectively disable rendering the point cloud.\n */\nfunction TimeDynamicPointCloud(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.clock\", options.clock);\n  Check.typeOf.object(\"options.intervals\", options.intervals);\n  //>>includeEnd('debug');\n\n  /**\n   * Determines if the point cloud will be shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  /**\n   * A 4x4 transformation matrix that transforms the point cloud.\n   *\n   * @type {Matrix4}\n   * @default Matrix4.IDENTITY\n   */\n  this.modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY)\n  );\n\n  /**\n   * Determines whether the point cloud casts or receives shadows from light sources.\n   * <p>\n   * Enabling shadows has a performance impact. A point cloud that casts shadows must be rendered twice, once from the camera and again from the light's point of view.\n   * </p>\n   * <p>\n   * Shadows are rendered only when {@link Viewer#shadows} is <code>true</code>.\n   * </p>\n   *\n   * @type {ShadowMode}\n   * @default ShadowMode.ENABLED\n   */\n  this.shadows = defaultValue(options.shadows, ShadowMode.ENABLED);\n\n  /**\n   * The maximum amount of GPU memory (in MB) that may be used to cache point cloud frames.\n   * <p>\n   * Frames that are not being loaded or rendered are unloaded to enforce this.\n   * </p>\n   * <p>\n   * If decreasing this value results in unloading tiles, the tiles are unloaded the next frame.\n   * </p>\n   *\n   * @type {Number}\n   * @default 256\n   *\n   * @see TimeDynamicPointCloud#totalMemoryUsageInBytes\n   */\n  this.maximumMemoryUsage = defaultValue(options.maximumMemoryUsage, 256);\n\n  /**\n   * Options for controlling point size based on geometric error and eye dome lighting.\n   * @type {PointCloudShading}\n   */\n  this.shading = new PointCloudShading(options.shading);\n\n  /**\n   * The style, defined using the\n   * {@link https://github.com/CesiumGS/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language},\n   * applied to each point in the point cloud.\n   * <p>\n   * Assign <code>undefined</code> to remove the style, which will restore the visual\n   * appearance of the point cloud to its default when no style was applied.\n   * </p>\n   *\n   * @type {Cesium3DTileStyle}\n   *\n   * @example\n   * pointCloud.style = new Cesium.Cesium3DTileStyle({\n   *    color : {\n   *        conditions : [\n   *            ['${Classification} === 0', 'color(\"purple\", 0.5)'],\n   *            ['${Classification} === 1', 'color(\"red\")'],\n   *            ['true', '${COLOR}']\n   *        ]\n   *    },\n   *    show : '${Classification} !== 2'\n   * });\n   *\n   * @see {@link https://github.com/CesiumGS/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language}\n   */\n  this.style = options.style;\n\n  /**\n   * The event fired to indicate that a frame failed to load. A frame may fail to load if the\n   * request for its uri fails or processing fails due to invalid content.\n   * <p>\n   * If there are no event listeners, error messages will be logged to the console.\n   * </p>\n   * <p>\n   * The error object passed to the listener contains two properties:\n   * <ul>\n   * <li><code>uri</code>: the uri of the failed frame.</li>\n   * <li><code>message</code>: the error message.</li>\n   * </ul>\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * pointCloud.frameFailed.addEventListener(function(error) {\n   *     console.log('An error occurred loading frame: ' + error.uri);\n   *     console.log('Error: ' + error.message);\n   * });\n   */\n  this.frameFailed = new Event();\n\n  /**\n   * The event fired to indicate that a new frame was rendered.\n   * <p>\n   * The time dynamic point cloud {@link TimeDynamicPointCloud} is passed to the event listener.\n   * </p>\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * pointCloud.frameChanged.addEventListener(function(timeDynamicPointCloud) {\n   *     viewer.camera.viewBoundingSphere(timeDynamicPointCloud.boundingSphere);\n   * });\n   */\n  this.frameChanged = new Event();\n\n  this._clock = options.clock;\n  this._intervals = options.intervals;\n  this._clippingPlanes = undefined;\n  this.clippingPlanes = options.clippingPlanes; // Call setter\n  this._pointCloudEyeDomeLighting = new PointCloudEyeDomeLighting();\n  this._loadTimestamp = undefined;\n  this._clippingPlanesState = 0;\n  this._styleDirty = false;\n  this._pickId = undefined;\n  this._totalMemoryUsageInBytes = 0;\n  this._frames = [];\n  this._previousInterval = undefined;\n  this._nextInterval = undefined;\n  this._lastRenderedFrame = undefined;\n  this._clockMultiplier = 0.0;\n  this._readyPromise = when.defer();\n\n  // For calculating average load time of the last N frames\n  this._runningSum = 0.0;\n  this._runningLength = 0;\n  this._runningIndex = 0;\n  this._runningSamples = arrayFill(new Array(5), 0.0);\n  this._runningAverage = 0.0;\n}\n\nObject.defineProperties(TimeDynamicPointCloud.prototype, {\n  /**\n   * The {@link ClippingPlaneCollection} used to selectively disable rendering the point cloud.\n   *\n   * @memberof TimeDynamicPointCloud.prototype\n   *\n   * @type {ClippingPlaneCollection}\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._clippingPlanes;\n    },\n    set: function (value) {\n      ClippingPlaneCollection.setOwner(value, this, \"_clippingPlanes\");\n    },\n  },\n\n  /**\n   * The total amount of GPU memory in bytes used by the point cloud.\n   *\n   * @memberof TimeDynamicPointCloud.prototype\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @see TimeDynamicPointCloud#maximumMemoryUsage\n   */\n  totalMemoryUsageInBytes: {\n    get: function () {\n      return this._totalMemoryUsageInBytes;\n    },\n  },\n\n  /**\n   * The bounding sphere of the frame being rendered. Returns <code>undefined</code> if no frame is being rendered.\n   *\n   * @memberof TimeDynamicPointCloud.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      if (defined(this._lastRenderedFrame)) {\n        return this._lastRenderedFrame.pointCloud.boundingSphere;\n      }\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the promise that will be resolved when the point cloud renders a frame for the first time.\n   *\n   * @memberof TimeDynamicPointCloud.prototype\n   *\n   * @type {Promise.<TimeDynamicPointCloud>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n});\n\nfunction getFragmentShaderLoaded(fs) {\n  return \"uniform vec4 czm_pickColor;\\n\" + fs;\n}\n\nfunction getUniformMapLoaded(stream) {\n  return function (uniformMap) {\n    return combine(uniformMap, {\n      czm_pickColor: function () {\n        return stream._pickId.color;\n      },\n    });\n  };\n}\n\nfunction getPickIdLoaded() {\n  return \"czm_pickColor\";\n}\n\n/**\n * Marks the point cloud's {@link TimeDynamicPointCloud#style} as dirty, which forces all\n * points to re-evaluate the style in the next frame.\n */\nTimeDynamicPointCloud.prototype.makeStyleDirty = function () {\n  this._styleDirty = true;\n};\n\n/**\n * Exposed for testing.\n *\n * @private\n */\nTimeDynamicPointCloud.prototype._getAverageLoadTime = function () {\n  if (this._runningLength === 0) {\n    // Before any frames have loaded make a best guess about the average load time\n    return 0.05;\n  }\n  return this._runningAverage;\n};\n\nvar scratchDate = new JulianDate();\n\nfunction getClockMultiplier(that) {\n  var clock = that._clock;\n  var isAnimating = clock.canAnimate && clock.shouldAnimate;\n  var multiplier = clock.multiplier;\n  return isAnimating ? multiplier : 0.0;\n}\n\nfunction getIntervalIndex(that, interval) {\n  return that._intervals.indexOf(interval.start);\n}\n\nfunction getNextInterval(that, currentInterval) {\n  var intervals = that._intervals;\n  var clock = that._clock;\n  var multiplier = getClockMultiplier(that);\n\n  if (multiplier === 0.0) {\n    return undefined;\n  }\n\n  var averageLoadTime = that._getAverageLoadTime();\n  var time = JulianDate.addSeconds(\n    clock.currentTime,\n    averageLoadTime * multiplier,\n    scratchDate\n  );\n  var index = intervals.indexOf(time);\n\n  var currentIndex = getIntervalIndex(that, currentInterval);\n  if (index === currentIndex) {\n    if (multiplier >= 0) {\n      ++index;\n    } else {\n      --index;\n    }\n  }\n\n  // Returns undefined if not in range\n  return intervals.get(index);\n}\n\nfunction getCurrentInterval(that) {\n  var intervals = that._intervals;\n  var clock = that._clock;\n  var time = clock.currentTime;\n  var index = intervals.indexOf(time);\n\n  // Returns undefined if not in range\n  return intervals.get(index);\n}\n\nfunction reachedInterval(that, currentInterval, nextInterval) {\n  var multiplier = getClockMultiplier(that);\n  var currentIndex = getIntervalIndex(that, currentInterval);\n  var nextIndex = getIntervalIndex(that, nextInterval);\n\n  if (multiplier >= 0) {\n    return currentIndex >= nextIndex;\n  }\n  return currentIndex <= nextIndex;\n}\n\nfunction handleFrameFailure(that, uri) {\n  return function (error) {\n    var message = defined(error.message) ? error.message : error.toString();\n    if (that.frameFailed.numberOfListeners > 0) {\n      that.frameFailed.raiseEvent({\n        uri: uri,\n        message: message,\n      });\n    } else {\n      console.log(\"A frame failed to load: \" + uri);\n      console.log(\"Error: \" + message);\n    }\n  };\n}\n\nfunction requestFrame(that, interval, frameState) {\n  var index = getIntervalIndex(that, interval);\n  var frames = that._frames;\n  var frame = frames[index];\n  if (!defined(frame)) {\n    var transformArray = interval.data.transform;\n    var transform = defined(transformArray)\n      ? Matrix4.fromArray(transformArray)\n      : undefined;\n    var uri = interval.data.uri;\n    frame = {\n      pointCloud: undefined,\n      transform: transform,\n      timestamp: getTimestamp(),\n      sequential: true,\n      ready: false,\n      touchedFrameNumber: frameState.frameNumber,\n    };\n    frames[index] = frame;\n    Resource.fetchArrayBuffer({\n      url: uri,\n    })\n      .then(function (arrayBuffer) {\n        // PERFORMANCE_IDEA: share a memory pool, render states, shaders, and other resources among all\n        // frames. Each frame just needs an index/offset into the pool.\n        frame.pointCloud = new PointCloud({\n          arrayBuffer: arrayBuffer,\n          cull: true,\n          fragmentShaderLoaded: getFragmentShaderLoaded,\n          uniformMapLoaded: getUniformMapLoaded(that),\n          pickIdLoaded: getPickIdLoaded,\n        });\n        return frame.pointCloud.readyPromise;\n      })\n      .otherwise(handleFrameFailure(that, uri));\n  }\n  return frame;\n}\n\nfunction updateAverageLoadTime(that, loadTime) {\n  that._runningSum += loadTime;\n  that._runningSum -= that._runningSamples[that._runningIndex];\n  that._runningSamples[that._runningIndex] = loadTime;\n  that._runningLength = Math.min(\n    that._runningLength + 1,\n    that._runningSamples.length\n  );\n  that._runningIndex = (that._runningIndex + 1) % that._runningSamples.length;\n  that._runningAverage = that._runningSum / that._runningLength;\n}\n\nfunction prepareFrame(that, frame, updateState, frameState) {\n  if (frame.touchedFrameNumber < frameState.frameNumber - 1) {\n    // If this frame was not loaded in sequential updates then it can't be used it for calculating the average load time.\n    // For example: selecting a frame on the timeline, selecting another frame before the request finishes, then selecting this frame later.\n    frame.sequential = false;\n  }\n\n  var pointCloud = frame.pointCloud;\n\n  if (defined(pointCloud) && !frame.ready) {\n    // Call update to prepare renderer resources. Don't render anything yet.\n    var commandList = frameState.commandList;\n    var lengthBeforeUpdate = commandList.length;\n    renderFrame(that, frame, updateState, frameState);\n\n    if (pointCloud.ready) {\n      // Point cloud became ready this update\n      frame.ready = true;\n      that._totalMemoryUsageInBytes += pointCloud.geometryByteLength;\n      commandList.length = lengthBeforeUpdate; // Don't allow preparing frame to insert commands.\n      if (frame.sequential) {\n        // Update the values used to calculate average load time\n        var loadTime = (getTimestamp() - frame.timestamp) / 1000.0;\n        updateAverageLoadTime(that, loadTime);\n      }\n    }\n  }\n\n  frame.touchedFrameNumber = frameState.frameNumber;\n}\n\nvar scratchModelMatrix = new Matrix4();\n\nfunction getGeometricError(that, pointCloud) {\n  var shading = that.shading;\n  if (defined(shading) && defined(shading.baseResolution)) {\n    return shading.baseResolution;\n  } else if (defined(pointCloud.boundingSphere)) {\n    return CesiumMath.cbrt(\n      pointCloud.boundingSphere.volume() / pointCloud.pointsLength\n    );\n  }\n  return 0.0;\n}\n\nfunction getMaximumAttenuation(that) {\n  var shading = that.shading;\n  if (defined(shading) && defined(shading.maximumAttenuation)) {\n    return shading.maximumAttenuation;\n  }\n\n  // Return a hardcoded maximum attenuation. For a tileset this would instead be the maximum screen space error.\n  return 10.0;\n}\n\nvar defaultShading = new PointCloudShading();\n\nfunction renderFrame(that, frame, updateState, frameState) {\n  var shading = defaultValue(that.shading, defaultShading);\n  var pointCloud = frame.pointCloud;\n  var transform = defaultValue(frame.transform, Matrix4.IDENTITY);\n  pointCloud.modelMatrix = Matrix4.multiplyTransformation(\n    that.modelMatrix,\n    transform,\n    scratchModelMatrix\n  );\n  pointCloud.style = that.style;\n  pointCloud.time = updateState.timeSinceLoad;\n  pointCloud.shadows = that.shadows;\n  pointCloud.clippingPlanes = that._clippingPlanes;\n  pointCloud.isClipped = updateState.isClipped;\n  pointCloud.attenuation = shading.attenuation;\n  pointCloud.backFaceCulling = shading.backFaceCulling;\n  pointCloud.normalShading = shading.normalShading;\n  pointCloud.geometricError = getGeometricError(that, pointCloud);\n  pointCloud.geometricErrorScale = shading.geometricErrorScale;\n  pointCloud.maximumAttenuation = getMaximumAttenuation(that);\n\n  pointCloud.update(frameState);\n  frame.touchedFrameNumber = frameState.frameNumber;\n}\n\nfunction loadFrame(that, interval, updateState, frameState) {\n  var frame = requestFrame(that, interval, frameState);\n  prepareFrame(that, frame, updateState, frameState);\n}\n\nfunction getUnloadCondition(frameState) {\n  return function (frame) {\n    // Unload all frames that aren't currently being loaded or rendered\n    return frame.touchedFrameNumber < frameState.frameNumber;\n  };\n}\n\nfunction unloadFrames(that, unloadCondition) {\n  var frames = that._frames;\n  var length = frames.length;\n  for (var i = 0; i < length; ++i) {\n    var frame = frames[i];\n    if (defined(frame)) {\n      if (!defined(unloadCondition) || unloadCondition(frame)) {\n        var pointCloud = frame.pointCloud;\n        if (frame.ready) {\n          that._totalMemoryUsageInBytes -= pointCloud.geometryByteLength;\n        }\n        if (defined(pointCloud)) {\n          pointCloud.destroy();\n        }\n        if (frame === that._lastRenderedFrame) {\n          that._lastRenderedFrame = undefined;\n        }\n        frames[i] = undefined;\n      }\n    }\n  }\n}\n\nfunction getFrame(that, interval) {\n  var index = getIntervalIndex(that, interval);\n  var frame = that._frames[index];\n  if (defined(frame) && frame.ready) {\n    return frame;\n  }\n}\n\nfunction updateInterval(that, interval, frame, updateState, frameState) {\n  if (defined(frame)) {\n    if (frame.ready) {\n      return true;\n    }\n    loadFrame(that, interval, updateState, frameState);\n    return frame.ready;\n  }\n  return false;\n}\n\nfunction getNearestReadyInterval(\n  that,\n  previousInterval,\n  currentInterval,\n  updateState,\n  frameState\n) {\n  var i;\n  var interval;\n  var frame;\n  var intervals = that._intervals;\n  var frames = that._frames;\n  var currentIndex = getIntervalIndex(that, currentInterval);\n  var previousIndex = getIntervalIndex(that, previousInterval);\n\n  if (currentIndex >= previousIndex) {\n    // look backwards\n    for (i = currentIndex; i >= previousIndex; --i) {\n      interval = intervals.get(i);\n      frame = frames[i];\n      if (updateInterval(that, interval, frame, updateState, frameState)) {\n        return interval;\n      }\n    }\n  } else {\n    // look forwards\n    for (i = currentIndex; i <= previousIndex; ++i) {\n      interval = intervals.get(i);\n      frame = frames[i];\n      if (updateInterval(that, interval, frame, updateState, frameState)) {\n        return interval;\n      }\n    }\n  }\n\n  // If no intervals are ready return the previous interval\n  return previousInterval;\n}\n\nfunction setFramesDirty(that, clippingPlanesDirty, styleDirty) {\n  var frames = that._frames;\n  var framesLength = frames.length;\n  for (var i = 0; i < framesLength; ++i) {\n    var frame = frames[i];\n    if (defined(frame) && defined(frame.pointCloud)) {\n      frame.pointCloud.clippingPlanesDirty = clippingPlanesDirty;\n      frame.pointCloud.styleDirty = styleDirty;\n    }\n  }\n}\n\nvar updateState = {\n  timeSinceLoad: 0,\n  isClipped: false,\n  clippingPlanesDirty: false,\n};\n\n/**\n * @private\n */\nTimeDynamicPointCloud.prototype.update = function (frameState) {\n  if (frameState.mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  if (!this.show) {\n    return;\n  }\n\n  if (!defined(this._pickId)) {\n    this._pickId = frameState.context.createPickId({\n      primitive: this,\n    });\n  }\n\n  if (!defined(this._loadTimestamp)) {\n    this._loadTimestamp = JulianDate.clone(frameState.time);\n  }\n\n  // For styling\n  var timeSinceLoad = Math.max(\n    JulianDate.secondsDifference(frameState.time, this._loadTimestamp) * 1000,\n    0.0\n  );\n\n  // Update clipping planes\n  var clippingPlanes = this._clippingPlanes;\n  var clippingPlanesState = 0;\n  var clippingPlanesDirty = false;\n  var isClipped = defined(clippingPlanes) && clippingPlanes.enabled;\n\n  if (isClipped) {\n    clippingPlanes.update(frameState);\n    clippingPlanesState = clippingPlanes.clippingPlanesState;\n  }\n\n  if (this._clippingPlanesState !== clippingPlanesState) {\n    this._clippingPlanesState = clippingPlanesState;\n    clippingPlanesDirty = true;\n  }\n\n  var styleDirty = this._styleDirty;\n  this._styleDirty = false;\n\n  if (clippingPlanesDirty || styleDirty) {\n    setFramesDirty(this, clippingPlanesDirty, styleDirty);\n  }\n\n  updateState.timeSinceLoad = timeSinceLoad;\n  updateState.isClipped = isClipped;\n\n  var shading = this.shading;\n  var eyeDomeLighting = this._pointCloudEyeDomeLighting;\n\n  var commandList = frameState.commandList;\n  var lengthBeforeUpdate = commandList.length;\n\n  var previousInterval = this._previousInterval;\n  var nextInterval = this._nextInterval;\n  var currentInterval = getCurrentInterval(this);\n\n  if (!defined(currentInterval)) {\n    return;\n  }\n\n  var clockMultiplierChanged = false;\n  var clockMultiplier = getClockMultiplier(this);\n  var clockPaused = clockMultiplier === 0;\n  if (clockMultiplier !== this._clockMultiplier) {\n    clockMultiplierChanged = true;\n    this._clockMultiplier = clockMultiplier;\n  }\n\n  if (!defined(previousInterval) || clockPaused) {\n    previousInterval = currentInterval;\n  }\n\n  if (\n    !defined(nextInterval) ||\n    clockMultiplierChanged ||\n    reachedInterval(this, currentInterval, nextInterval)\n  ) {\n    nextInterval = getNextInterval(this, currentInterval);\n  }\n\n  previousInterval = getNearestReadyInterval(\n    this,\n    previousInterval,\n    currentInterval,\n    updateState,\n    frameState\n  );\n  var frame = getFrame(this, previousInterval);\n\n  if (!defined(frame)) {\n    // The frame is not ready to render. This can happen when the simulation starts or when scrubbing the timeline\n    // to a frame that hasn't loaded yet. Just render the last rendered frame in its place until it finishes loading.\n    loadFrame(this, previousInterval, updateState, frameState);\n    frame = this._lastRenderedFrame;\n  }\n\n  if (defined(frame)) {\n    renderFrame(this, frame, updateState, frameState);\n  }\n\n  if (defined(nextInterval)) {\n    // Start loading the next frame\n    loadFrame(this, nextInterval, updateState, frameState);\n  }\n\n  var that = this;\n  if (defined(frame) && !defined(this._lastRenderedFrame)) {\n    frameState.afterRender.push(function () {\n      that._readyPromise.resolve(that);\n    });\n  }\n\n  if (defined(frame) && frame !== this._lastRenderedFrame) {\n    if (that.frameChanged.numberOfListeners > 0) {\n      frameState.afterRender.push(function () {\n        that.frameChanged.raiseEvent(that);\n      });\n    }\n  }\n\n  this._previousInterval = previousInterval;\n  this._nextInterval = nextInterval;\n  this._lastRenderedFrame = frame;\n\n  var totalMemoryUsageInBytes = this._totalMemoryUsageInBytes;\n  var maximumMemoryUsageInBytes = this.maximumMemoryUsage * 1024 * 1024;\n\n  if (totalMemoryUsageInBytes > maximumMemoryUsageInBytes) {\n    unloadFrames(this, getUnloadCondition(frameState));\n  }\n\n  var lengthAfterUpdate = commandList.length;\n  var addedCommandsLength = lengthAfterUpdate - lengthBeforeUpdate;\n\n  if (\n    defined(shading) &&\n    shading.attenuation &&\n    shading.eyeDomeLighting &&\n    addedCommandsLength > 0\n  ) {\n    eyeDomeLighting.update(\n      frameState,\n      lengthBeforeUpdate,\n      shading,\n      this.boundingSphere\n    );\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see TimeDynamicPointCloud#destroy\n */\nTimeDynamicPointCloud.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * pointCloud = pointCloud && pointCloud.destroy();\n *\n * @see TimeDynamicPointCloud#isDestroyed\n */\nTimeDynamicPointCloud.prototype.destroy = function () {\n  unloadFrames(this);\n  this._clippingPlanes = this._clippingPlanes && this._clippingPlanes.destroy();\n  this._pickId = this._pickId && this._pickId.destroy();\n  return destroyObject(this);\n};\nexport default TimeDynamicPointCloud;\n"]},"metadata":{},"sourceType":"module"}