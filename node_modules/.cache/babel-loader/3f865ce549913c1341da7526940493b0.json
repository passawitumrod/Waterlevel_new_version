{"ast":null,"code":"import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport RectangleGeometryLibrary from \"./RectangleGeometryLibrary.js\";\nvar bottomBoundingSphere = new BoundingSphere();\nvar topBoundingSphere = new BoundingSphere();\nvar positionScratch = new Cartesian3();\nvar rectangleScratch = new Rectangle();\n\nfunction constructRectangle(geometry, computedOptions) {\n  var ellipsoid = geometry._ellipsoid;\n  var height = computedOptions.height;\n  var width = computedOptions.width;\n  var northCap = computedOptions.northCap;\n  var southCap = computedOptions.southCap;\n  var rowHeight = height;\n  var widthMultiplier = 2;\n  var size = 0;\n  var corners = 4;\n\n  if (northCap) {\n    widthMultiplier -= 1;\n    rowHeight -= 1;\n    size += 1;\n    corners -= 2;\n  }\n\n  if (southCap) {\n    widthMultiplier -= 1;\n    rowHeight -= 1;\n    size += 1;\n    corners -= 2;\n  }\n\n  size += widthMultiplier * width + 2 * rowHeight - corners;\n  var positions = new Float64Array(size * 3);\n  var posIndex = 0;\n  var row = 0;\n  var col;\n  var position = positionScratch;\n\n  if (northCap) {\n    RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, row, 0, position);\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n  } else {\n    for (col = 0; col < width; col++) {\n      RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, row, col, position);\n      positions[posIndex++] = position.x;\n      positions[posIndex++] = position.y;\n      positions[posIndex++] = position.z;\n    }\n  }\n\n  col = width - 1;\n\n  for (row = 1; row < height; row++) {\n    RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, row, col, position);\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n  }\n\n  row = height - 1;\n\n  if (!southCap) {\n    // if southCap is true, we dont need to add any more points because the south pole point was added by the iteration above\n    for (col = width - 2; col >= 0; col--) {\n      RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, row, col, position);\n      positions[posIndex++] = position.x;\n      positions[posIndex++] = position.y;\n      positions[posIndex++] = position.z;\n    }\n  }\n\n  col = 0;\n\n  for (row = height - 2; row > 0; row--) {\n    RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, row, col, position);\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n  }\n\n  var indicesSize = positions.length / 3 * 2;\n  var indices = IndexDatatype.createTypedArray(positions.length / 3, indicesSize);\n  var index = 0;\n\n  for (var i = 0; i < positions.length / 3 - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n  }\n\n  indices[index++] = positions.length / 3 - 1;\n  indices[index++] = 0;\n  var geo = new Geometry({\n    attributes: new GeometryAttributes(),\n    primitiveType: PrimitiveType.LINES\n  });\n  geo.attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positions\n  });\n  geo.indices = indices;\n  return geo;\n}\n\nfunction constructExtrudedRectangle(rectangleGeometry, computedOptions) {\n  var surfaceHeight = rectangleGeometry._surfaceHeight;\n  var extrudedHeight = rectangleGeometry._extrudedHeight;\n  var ellipsoid = rectangleGeometry._ellipsoid;\n  var minHeight = extrudedHeight;\n  var maxHeight = surfaceHeight;\n  var geo = constructRectangle(rectangleGeometry, computedOptions);\n  var height = computedOptions.height;\n  var width = computedOptions.width;\n  var topPositions = PolygonPipeline.scaleToGeodeticHeight(geo.attributes.position.values, maxHeight, ellipsoid, false);\n  var length = topPositions.length;\n  var positions = new Float64Array(length * 2);\n  positions.set(topPositions);\n  var bottomPositions = PolygonPipeline.scaleToGeodeticHeight(geo.attributes.position.values, minHeight, ellipsoid);\n  positions.set(bottomPositions, length);\n  geo.attributes.position.values = positions;\n  var northCap = computedOptions.northCap;\n  var southCap = computedOptions.southCap;\n  var corners = 4;\n\n  if (northCap) {\n    corners -= 1;\n  }\n\n  if (southCap) {\n    corners -= 1;\n  }\n\n  var indicesSize = (positions.length / 3 + corners) * 2;\n  var indices = IndexDatatype.createTypedArray(positions.length / 3, indicesSize);\n  length = positions.length / 6;\n  var index = 0;\n\n  for (var i = 0; i < length - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n    indices[index++] = i + length;\n    indices[index++] = i + length + 1;\n  }\n\n  indices[index++] = length - 1;\n  indices[index++] = 0;\n  indices[index++] = length + length - 1;\n  indices[index++] = length;\n  indices[index++] = 0;\n  indices[index++] = length;\n  var bottomCorner;\n\n  if (northCap) {\n    bottomCorner = height - 1;\n  } else {\n    var topRightCorner = width - 1;\n    indices[index++] = topRightCorner;\n    indices[index++] = topRightCorner + length;\n    bottomCorner = width + height - 2;\n  }\n\n  indices[index++] = bottomCorner;\n  indices[index++] = bottomCorner + length;\n\n  if (!southCap) {\n    var bottomLeftCorner = width + bottomCorner - 1;\n    indices[index++] = bottomLeftCorner;\n    indices[index] = bottomLeftCorner + length;\n  }\n\n  geo.indices = indices;\n  return geo;\n}\n/**\n * A description of the outline of a a cartographic rectangle on an ellipsoid centered at the origin.\n *\n * @alias RectangleOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Number} [options.height=0.0] The distance in meters between the rectangle and the ellipsoid surface.\n * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\n * @param {Number} [options.extrudedHeight] The distance in meters between the rectangle's extruded face and the ellipsoid surface.\n *\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>options.rectangle.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>options.rectangle.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>options.rectangle.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be greater than <code>rectangle.south</code>.\n *\n * @see RectangleOutlineGeometry#createGeometry\n *\n * @example\n * var rectangle = new Cesium.RectangleOutlineGeometry({\n *   ellipsoid : Cesium.Ellipsoid.WGS84,\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n *   height : 10000.0\n * });\n * var geometry = Cesium.RectangleOutlineGeometry.createGeometry(rectangle);\n */\n\n\nfunction RectangleOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var rectangle = options.rectangle;\n  var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var rotation = defaultValue(options.rotation, 0.0); //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required.\");\n  }\n\n  Rectangle.validate(rectangle);\n\n  if (rectangle.north < rectangle.south) {\n    throw new DeveloperError(\"options.rectangle.north must be greater than options.rectangle.south\");\n  } //>>includeEnd('debug');\n\n\n  var height = defaultValue(options.height, 0.0);\n  var extrudedHeight = defaultValue(options.extrudedHeight, height);\n  this._rectangle = Rectangle.clone(rectangle);\n  this._granularity = granularity;\n  this._ellipsoid = ellipsoid;\n  this._surfaceHeight = Math.max(height, extrudedHeight);\n  this._rotation = rotation;\n  this._extrudedHeight = Math.min(height, extrudedHeight);\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createRectangleOutlineGeometry\";\n}\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\n\n\nRectangleOutlineGeometry.packedLength = Rectangle.packedLength + Ellipsoid.packedLength + 5;\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {RectangleOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\nRectangleOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  } //>>includeEnd('debug');\n\n\n  startingIndex = defaultValue(startingIndex, 0);\n  Rectangle.pack(value._rectangle, array, startingIndex);\n  startingIndex += Rectangle.packedLength;\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._surfaceHeight;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n  return array;\n};\n\nvar scratchRectangle = new Rectangle();\nvar scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nvar scratchOptions = {\n  rectangle: scratchRectangle,\n  ellipsoid: scratchEllipsoid,\n  granularity: undefined,\n  height: undefined,\n  rotation: undefined,\n  extrudedHeight: undefined,\n  offsetAttribute: undefined\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {RectangleOutlineGeometry} [result] The object into which to store the result.\n * @returns {RectangleOutlineGeometry} The modified result parameter or a new Quaternion instance if one was not provided.\n */\n\nRectangleOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  } //>>includeEnd('debug');\n\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var rectangle = Rectangle.unpack(array, startingIndex, scratchRectangle);\n  startingIndex += Rectangle.packedLength;\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n  var granularity = array[startingIndex++];\n  var height = array[startingIndex++];\n  var rotation = array[startingIndex++];\n  var extrudedHeight = array[startingIndex++];\n  var offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.granularity = granularity;\n    scratchOptions.height = height;\n    scratchOptions.rotation = rotation;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new RectangleOutlineGeometry(scratchOptions);\n  }\n\n  result._rectangle = Rectangle.clone(rectangle, result._rectangle);\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._surfaceHeight = height;\n  result._rotation = rotation;\n  result._extrudedHeight = extrudedHeight;\n  result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n  return result;\n};\n\nvar nwScratch = new Cartographic();\n/**\n * Computes the geometric representation of an outline of a rectangle, including its vertices, indices, and a bounding sphere.\n *\n * @param {RectangleOutlineGeometry} rectangleGeometry A description of the rectangle outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n *\n * @exception {DeveloperError} Rotated rectangle is invalid.\n */\n\nRectangleOutlineGeometry.createGeometry = function (rectangleGeometry) {\n  var rectangle = rectangleGeometry._rectangle;\n  var ellipsoid = rectangleGeometry._ellipsoid;\n  var computedOptions = RectangleGeometryLibrary.computeOptions(rectangle, rectangleGeometry._granularity, rectangleGeometry._rotation, 0, rectangleScratch, nwScratch);\n  var geometry;\n  var boundingSphere;\n\n  if (CesiumMath.equalsEpsilon(rectangle.north, rectangle.south, CesiumMath.EPSILON10) || CesiumMath.equalsEpsilon(rectangle.east, rectangle.west, CesiumMath.EPSILON10)) {\n    return undefined;\n  }\n\n  var surfaceHeight = rectangleGeometry._surfaceHeight;\n  var extrudedHeight = rectangleGeometry._extrudedHeight;\n  var extrude = !CesiumMath.equalsEpsilon(surfaceHeight, extrudedHeight, 0, CesiumMath.EPSILON2);\n  var offsetValue;\n\n  if (extrude) {\n    geometry = constructExtrudedRectangle(rectangleGeometry, computedOptions);\n\n    if (defined(rectangleGeometry._offsetAttribute)) {\n      var size = geometry.attributes.position.values.length / 3;\n      var offsetAttribute = new Uint8Array(size);\n\n      if (rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.TOP) {\n        offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n      } else {\n        offsetValue = rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n        offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n      }\n\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: offsetAttribute\n      });\n    }\n\n    var topBS = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, surfaceHeight, topBoundingSphere);\n    var bottomBS = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, extrudedHeight, bottomBoundingSphere);\n    boundingSphere = BoundingSphere.union(topBS, bottomBS);\n  } else {\n    geometry = constructRectangle(rectangleGeometry, computedOptions);\n    geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(geometry.attributes.position.values, surfaceHeight, ellipsoid, false);\n\n    if (defined(rectangleGeometry._offsetAttribute)) {\n      var length = geometry.attributes.position.values.length;\n      var applyOffset = new Uint8Array(length / 3);\n      offsetValue = rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      arrayFill(applyOffset, offsetValue);\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset\n      });\n    }\n\n    boundingSphere = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, surfaceHeight);\n  }\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: rectangleGeometry._offsetAttribute\n  });\n};\n\nexport default RectangleOutlineGeometry;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/RectangleOutlineGeometry.js"],"names":["arrayFill","BoundingSphere","Cartesian3","Cartographic","ComponentDatatype","defaultValue","defined","DeveloperError","Ellipsoid","Geometry","GeometryAttribute","GeometryAttributes","GeometryOffsetAttribute","IndexDatatype","CesiumMath","PolygonPipeline","PrimitiveType","Rectangle","RectangleGeometryLibrary","bottomBoundingSphere","topBoundingSphere","positionScratch","rectangleScratch","constructRectangle","geometry","computedOptions","ellipsoid","_ellipsoid","height","width","northCap","southCap","rowHeight","widthMultiplier","size","corners","positions","Float64Array","posIndex","row","col","position","computePosition","x","y","z","indicesSize","length","indices","createTypedArray","index","i","geo","attributes","primitiveType","LINES","componentDatatype","DOUBLE","componentsPerAttribute","values","constructExtrudedRectangle","rectangleGeometry","surfaceHeight","_surfaceHeight","extrudedHeight","_extrudedHeight","minHeight","maxHeight","topPositions","scaleToGeodeticHeight","set","bottomPositions","bottomCorner","topRightCorner","bottomLeftCorner","RectangleOutlineGeometry","options","EMPTY_OBJECT","rectangle","granularity","RADIANS_PER_DEGREE","WGS84","rotation","validate","north","south","_rectangle","clone","_granularity","Math","max","_rotation","min","_offsetAttribute","offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","scratchRectangle","scratchEllipsoid","UNIT_SPHERE","scratchOptions","undefined","unpack","result","nwScratch","createGeometry","computeOptions","boundingSphere","equalsEpsilon","EPSILON10","east","west","extrude","EPSILON2","offsetValue","Uint8Array","TOP","NONE","applyOffset","UNSIGNED_BYTE","topBS","fromRectangle3D","bottomBS","union"],"mappings":"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","sourcesContent":["import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport RectangleGeometryLibrary from \"./RectangleGeometryLibrary.js\";\n\nvar bottomBoundingSphere = new BoundingSphere();\nvar topBoundingSphere = new BoundingSphere();\nvar positionScratch = new Cartesian3();\nvar rectangleScratch = new Rectangle();\n\nfunction constructRectangle(geometry, computedOptions) {\n  var ellipsoid = geometry._ellipsoid;\n  var height = computedOptions.height;\n  var width = computedOptions.width;\n  var northCap = computedOptions.northCap;\n  var southCap = computedOptions.southCap;\n\n  var rowHeight = height;\n  var widthMultiplier = 2;\n  var size = 0;\n  var corners = 4;\n  if (northCap) {\n    widthMultiplier -= 1;\n    rowHeight -= 1;\n    size += 1;\n    corners -= 2;\n  }\n  if (southCap) {\n    widthMultiplier -= 1;\n    rowHeight -= 1;\n    size += 1;\n    corners -= 2;\n  }\n  size += widthMultiplier * width + 2 * rowHeight - corners;\n\n  var positions = new Float64Array(size * 3);\n\n  var posIndex = 0;\n  var row = 0;\n  var col;\n  var position = positionScratch;\n  if (northCap) {\n    RectangleGeometryLibrary.computePosition(\n      computedOptions,\n      ellipsoid,\n      false,\n      row,\n      0,\n      position\n    );\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n  } else {\n    for (col = 0; col < width; col++) {\n      RectangleGeometryLibrary.computePosition(\n        computedOptions,\n        ellipsoid,\n        false,\n        row,\n        col,\n        position\n      );\n      positions[posIndex++] = position.x;\n      positions[posIndex++] = position.y;\n      positions[posIndex++] = position.z;\n    }\n  }\n\n  col = width - 1;\n  for (row = 1; row < height; row++) {\n    RectangleGeometryLibrary.computePosition(\n      computedOptions,\n      ellipsoid,\n      false,\n      row,\n      col,\n      position\n    );\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n  }\n\n  row = height - 1;\n  if (!southCap) {\n    // if southCap is true, we dont need to add any more points because the south pole point was added by the iteration above\n    for (col = width - 2; col >= 0; col--) {\n      RectangleGeometryLibrary.computePosition(\n        computedOptions,\n        ellipsoid,\n        false,\n        row,\n        col,\n        position\n      );\n      positions[posIndex++] = position.x;\n      positions[posIndex++] = position.y;\n      positions[posIndex++] = position.z;\n    }\n  }\n\n  col = 0;\n  for (row = height - 2; row > 0; row--) {\n    RectangleGeometryLibrary.computePosition(\n      computedOptions,\n      ellipsoid,\n      false,\n      row,\n      col,\n      position\n    );\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n  }\n\n  var indicesSize = (positions.length / 3) * 2;\n  var indices = IndexDatatype.createTypedArray(\n    positions.length / 3,\n    indicesSize\n  );\n\n  var index = 0;\n  for (var i = 0; i < positions.length / 3 - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n  }\n  indices[index++] = positions.length / 3 - 1;\n  indices[index++] = 0;\n\n  var geo = new Geometry({\n    attributes: new GeometryAttributes(),\n    primitiveType: PrimitiveType.LINES,\n  });\n\n  geo.attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positions,\n  });\n  geo.indices = indices;\n\n  return geo;\n}\n\nfunction constructExtrudedRectangle(rectangleGeometry, computedOptions) {\n  var surfaceHeight = rectangleGeometry._surfaceHeight;\n  var extrudedHeight = rectangleGeometry._extrudedHeight;\n  var ellipsoid = rectangleGeometry._ellipsoid;\n  var minHeight = extrudedHeight;\n  var maxHeight = surfaceHeight;\n  var geo = constructRectangle(rectangleGeometry, computedOptions);\n\n  var height = computedOptions.height;\n  var width = computedOptions.width;\n\n  var topPositions = PolygonPipeline.scaleToGeodeticHeight(\n    geo.attributes.position.values,\n    maxHeight,\n    ellipsoid,\n    false\n  );\n  var length = topPositions.length;\n  var positions = new Float64Array(length * 2);\n  positions.set(topPositions);\n  var bottomPositions = PolygonPipeline.scaleToGeodeticHeight(\n    geo.attributes.position.values,\n    minHeight,\n    ellipsoid\n  );\n  positions.set(bottomPositions, length);\n  geo.attributes.position.values = positions;\n\n  var northCap = computedOptions.northCap;\n  var southCap = computedOptions.southCap;\n  var corners = 4;\n  if (northCap) {\n    corners -= 1;\n  }\n  if (southCap) {\n    corners -= 1;\n  }\n\n  var indicesSize = (positions.length / 3 + corners) * 2;\n  var indices = IndexDatatype.createTypedArray(\n    positions.length / 3,\n    indicesSize\n  );\n  length = positions.length / 6;\n  var index = 0;\n  for (var i = 0; i < length - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n    indices[index++] = i + length;\n    indices[index++] = i + length + 1;\n  }\n  indices[index++] = length - 1;\n  indices[index++] = 0;\n  indices[index++] = length + length - 1;\n  indices[index++] = length;\n\n  indices[index++] = 0;\n  indices[index++] = length;\n\n  var bottomCorner;\n  if (northCap) {\n    bottomCorner = height - 1;\n  } else {\n    var topRightCorner = width - 1;\n    indices[index++] = topRightCorner;\n    indices[index++] = topRightCorner + length;\n    bottomCorner = width + height - 2;\n  }\n\n  indices[index++] = bottomCorner;\n  indices[index++] = bottomCorner + length;\n\n  if (!southCap) {\n    var bottomLeftCorner = width + bottomCorner - 1;\n    indices[index++] = bottomLeftCorner;\n    indices[index] = bottomLeftCorner + length;\n  }\n\n  geo.indices = indices;\n\n  return geo;\n}\n\n/**\n * A description of the outline of a a cartographic rectangle on an ellipsoid centered at the origin.\n *\n * @alias RectangleOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Number} [options.height=0.0] The distance in meters between the rectangle and the ellipsoid surface.\n * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\n * @param {Number} [options.extrudedHeight] The distance in meters between the rectangle's extruded face and the ellipsoid surface.\n *\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>options.rectangle.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>options.rectangle.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>options.rectangle.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be greater than <code>rectangle.south</code>.\n *\n * @see RectangleOutlineGeometry#createGeometry\n *\n * @example\n * var rectangle = new Cesium.RectangleOutlineGeometry({\n *   ellipsoid : Cesium.Ellipsoid.WGS84,\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n *   height : 10000.0\n * });\n * var geometry = Cesium.RectangleOutlineGeometry.createGeometry(rectangle);\n */\nfunction RectangleOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var rectangle = options.rectangle;\n  var granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var rotation = defaultValue(options.rotation, 0.0);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required.\");\n  }\n  Rectangle.validate(rectangle);\n  if (rectangle.north < rectangle.south) {\n    throw new DeveloperError(\n      \"options.rectangle.north must be greater than options.rectangle.south\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var height = defaultValue(options.height, 0.0);\n  var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  this._rectangle = Rectangle.clone(rectangle);\n  this._granularity = granularity;\n  this._ellipsoid = ellipsoid;\n  this._surfaceHeight = Math.max(height, extrudedHeight);\n  this._rotation = rotation;\n  this._extrudedHeight = Math.min(height, extrudedHeight);\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createRectangleOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nRectangleOutlineGeometry.packedLength =\n  Rectangle.packedLength + Ellipsoid.packedLength + 5;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {RectangleOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nRectangleOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Rectangle.pack(value._rectangle, array, startingIndex);\n  startingIndex += Rectangle.packedLength;\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._surfaceHeight;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nvar scratchRectangle = new Rectangle();\nvar scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nvar scratchOptions = {\n  rectangle: scratchRectangle,\n  ellipsoid: scratchEllipsoid,\n  granularity: undefined,\n  height: undefined,\n  rotation: undefined,\n  extrudedHeight: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {RectangleOutlineGeometry} [result] The object into which to store the result.\n * @returns {RectangleOutlineGeometry} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nRectangleOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var rectangle = Rectangle.unpack(array, startingIndex, scratchRectangle);\n  startingIndex += Rectangle.packedLength;\n\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  var granularity = array[startingIndex++];\n  var height = array[startingIndex++];\n  var rotation = array[startingIndex++];\n  var extrudedHeight = array[startingIndex++];\n  var offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.granularity = granularity;\n    scratchOptions.height = height;\n    scratchOptions.rotation = rotation;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n\n    return new RectangleOutlineGeometry(scratchOptions);\n  }\n\n  result._rectangle = Rectangle.clone(rectangle, result._rectangle);\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._surfaceHeight = height;\n  result._rotation = rotation;\n  result._extrudedHeight = extrudedHeight;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\nvar nwScratch = new Cartographic();\n/**\n * Computes the geometric representation of an outline of a rectangle, including its vertices, indices, and a bounding sphere.\n *\n * @param {RectangleOutlineGeometry} rectangleGeometry A description of the rectangle outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n *\n * @exception {DeveloperError} Rotated rectangle is invalid.\n */\nRectangleOutlineGeometry.createGeometry = function (rectangleGeometry) {\n  var rectangle = rectangleGeometry._rectangle;\n  var ellipsoid = rectangleGeometry._ellipsoid;\n  var computedOptions = RectangleGeometryLibrary.computeOptions(\n    rectangle,\n    rectangleGeometry._granularity,\n    rectangleGeometry._rotation,\n    0,\n    rectangleScratch,\n    nwScratch\n  );\n\n  var geometry;\n  var boundingSphere;\n\n  if (\n    CesiumMath.equalsEpsilon(\n      rectangle.north,\n      rectangle.south,\n      CesiumMath.EPSILON10\n    ) ||\n    CesiumMath.equalsEpsilon(\n      rectangle.east,\n      rectangle.west,\n      CesiumMath.EPSILON10\n    )\n  ) {\n    return undefined;\n  }\n\n  var surfaceHeight = rectangleGeometry._surfaceHeight;\n  var extrudedHeight = rectangleGeometry._extrudedHeight;\n  var extrude = !CesiumMath.equalsEpsilon(\n    surfaceHeight,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2\n  );\n  var offsetValue;\n  if (extrude) {\n    geometry = constructExtrudedRectangle(rectangleGeometry, computedOptions);\n    if (defined(rectangleGeometry._offsetAttribute)) {\n      var size = geometry.attributes.position.values.length / 3;\n      var offsetAttribute = new Uint8Array(size);\n      if (rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.TOP) {\n        offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n      } else {\n        offsetValue =\n          rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n            ? 0\n            : 1;\n        offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n      }\n\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: offsetAttribute,\n      });\n    }\n    var topBS = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      surfaceHeight,\n      topBoundingSphere\n    );\n    var bottomBS = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      extrudedHeight,\n      bottomBoundingSphere\n    );\n    boundingSphere = BoundingSphere.union(topBS, bottomBS);\n  } else {\n    geometry = constructRectangle(rectangleGeometry, computedOptions);\n    geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n      geometry.attributes.position.values,\n      surfaceHeight,\n      ellipsoid,\n      false\n    );\n\n    if (defined(rectangleGeometry._offsetAttribute)) {\n      var length = geometry.attributes.position.values.length;\n      var applyOffset = new Uint8Array(length / 3);\n      offsetValue =\n        rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      arrayFill(applyOffset, offsetValue);\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n\n    boundingSphere = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      surfaceHeight\n    );\n  }\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: rectangleGeometry._offsetAttribute,\n  });\n};\nexport default RectangleOutlineGeometry;\n"]},"metadata":{},"sourceType":"module"}