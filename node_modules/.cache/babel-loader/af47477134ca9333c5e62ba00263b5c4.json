{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport ContextLimits from \"./ContextLimits.js\";\nimport CubeMapFace from \"./CubeMapFace.js\";\nimport MipmapHint from \"./MipmapHint.js\";\nimport PixelDatatype from \"./PixelDatatype.js\";\nimport Sampler from \"./Sampler.js\";\nimport TextureMagnificationFilter from \"./TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"./TextureMinificationFilter.js\";\n/**\n * @private\n */\n\nfunction CubeMap(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);\n\n  Check.defined(\"options.context\", options.context); //>>includeEnd('debug');\n\n  var context = options.context;\n  var source = options.source;\n  var width;\n  var height;\n\n  if (defined(source)) {\n    var faces = [source.positiveX, source.negativeX, source.positiveY, source.negativeY, source.positiveZ, source.negativeZ]; //>>includeStart('debug', pragmas.debug);\n\n    if (!faces[0] || !faces[1] || !faces[2] || !faces[3] || !faces[4] || !faces[5]) {\n      throw new DeveloperError(\"options.source requires positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ faces.\");\n    } //>>includeEnd('debug');\n\n\n    width = faces[0].width;\n    height = faces[0].height; //>>includeStart('debug', pragmas.debug);\n\n    for (var i = 1; i < 6; ++i) {\n      if (Number(faces[i].width) !== width || Number(faces[i].height) !== height) {\n        throw new DeveloperError(\"Each face in options.source must have the same width and height.\");\n      }\n    } //>>includeEnd('debug');\n\n  } else {\n    width = options.width;\n    height = options.height;\n  }\n\n  var size = width;\n  var pixelFormat = defaultValue(options.pixelFormat, PixelFormat.RGBA);\n  var pixelDatatype = defaultValue(options.pixelDatatype, PixelDatatype.UNSIGNED_BYTE); //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(width) || !defined(height)) {\n    throw new DeveloperError(\"options requires a source field to create an initialized cube map or width and height fields to create a blank cube map.\");\n  }\n\n  if (width !== height) {\n    throw new DeveloperError(\"Width must equal height.\");\n  }\n\n  if (size <= 0) {\n    throw new DeveloperError(\"Width and height must be greater than zero.\");\n  }\n\n  if (size > ContextLimits.maximumCubeMapSize) {\n    throw new DeveloperError(\"Width and height must be less than or equal to the maximum cube map size (\" + ContextLimits.maximumCubeMapSize + \").  Check maximumCubeMapSize.\");\n  }\n\n  if (!PixelFormat.validate(pixelFormat)) {\n    throw new DeveloperError(\"Invalid options.pixelFormat.\");\n  }\n\n  if (PixelFormat.isDepthFormat(pixelFormat)) {\n    throw new DeveloperError(\"options.pixelFormat cannot be DEPTH_COMPONENT or DEPTH_STENCIL.\");\n  }\n\n  if (!PixelDatatype.validate(pixelDatatype)) {\n    throw new DeveloperError(\"Invalid options.pixelDatatype.\");\n  }\n\n  if (pixelDatatype === PixelDatatype.FLOAT && !context.floatingPointTexture) {\n    throw new DeveloperError(\"When options.pixelDatatype is FLOAT, this WebGL implementation must support the OES_texture_float extension.\");\n  }\n\n  if (pixelDatatype === PixelDatatype.HALF_FLOAT && !context.halfFloatingPointTexture) {\n    throw new DeveloperError(\"When options.pixelDatatype is HALF_FLOAT, this WebGL implementation must support the OES_texture_half_float extension.\");\n  } //>>includeEnd('debug');\n\n\n  var sizeInBytes = PixelFormat.textureSizeInBytes(pixelFormat, pixelDatatype, size, size) * 6; // Use premultiplied alpha for opaque textures should perform better on Chrome:\n  // http://media.tojicode.com/webglCamp4/#20\n\n  var preMultiplyAlpha = options.preMultiplyAlpha || pixelFormat === PixelFormat.RGB || pixelFormat === PixelFormat.LUMINANCE;\n  var flipY = defaultValue(options.flipY, true);\n  var gl = context._gl;\n  var textureTarget = gl.TEXTURE_CUBE_MAP;\n  var texture = gl.createTexture();\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(textureTarget, texture);\n\n  function createFace(target, sourceFace, preMultiplyAlpha, flipY) {\n    var arrayBufferView = sourceFace.arrayBufferView;\n\n    if (!defined(arrayBufferView)) {\n      arrayBufferView = sourceFace.bufferView;\n    }\n\n    var unpackAlignment = 4;\n\n    if (defined(arrayBufferView)) {\n      unpackAlignment = PixelFormat.alignmentInBytes(pixelFormat, pixelDatatype, width);\n    }\n\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);\n\n    if (defined(arrayBufferView)) {\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n\n      if (flipY) {\n        arrayBufferView = PixelFormat.flipY(arrayBufferView, pixelFormat, pixelDatatype, size, size);\n      }\n\n      gl.texImage2D(target, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, arrayBufferView);\n    } else {\n      // Only valid for DOM-Element uploads\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY); // Source: ImageData, HTMLImageElement, HTMLCanvasElement, or HTMLVideoElement\n\n      gl.texImage2D(target, 0, pixelFormat, pixelFormat, pixelDatatype, sourceFace);\n    }\n  }\n\n  if (defined(source)) {\n    createFace(gl.TEXTURE_CUBE_MAP_POSITIVE_X, source.positiveX, preMultiplyAlpha, flipY);\n    createFace(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, source.negativeX, preMultiplyAlpha, flipY);\n    createFace(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, source.positiveY, preMultiplyAlpha, flipY);\n    createFace(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, source.negativeY, preMultiplyAlpha, flipY);\n    createFace(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, source.positiveZ, preMultiplyAlpha, flipY);\n    createFace(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, source.negativeZ, preMultiplyAlpha, flipY);\n  } else {\n    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, null);\n    gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, null);\n    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, null);\n    gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, null);\n    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, null);\n    gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, null);\n  }\n\n  gl.bindTexture(textureTarget, null);\n  this._context = context;\n  this._textureFilterAnisotropic = context._textureFilterAnisotropic;\n  this._textureTarget = textureTarget;\n  this._texture = texture;\n  this._pixelFormat = pixelFormat;\n  this._pixelDatatype = pixelDatatype;\n  this._size = size;\n  this._hasMipmap = false;\n  this._sizeInBytes = sizeInBytes;\n  this._preMultiplyAlpha = preMultiplyAlpha;\n  this._flipY = flipY;\n  this._sampler = undefined;\n  var initialized = defined(source);\n  this._positiveX = new CubeMapFace(gl, texture, textureTarget, gl.TEXTURE_CUBE_MAP_POSITIVE_X, pixelFormat, pixelDatatype, size, preMultiplyAlpha, flipY, initialized);\n  this._negativeX = new CubeMapFace(gl, texture, textureTarget, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, pixelFormat, pixelDatatype, size, preMultiplyAlpha, flipY, initialized);\n  this._positiveY = new CubeMapFace(gl, texture, textureTarget, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, pixelFormat, pixelDatatype, size, preMultiplyAlpha, flipY, initialized);\n  this._negativeY = new CubeMapFace(gl, texture, textureTarget, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, pixelFormat, pixelDatatype, size, preMultiplyAlpha, flipY, initialized);\n  this._positiveZ = new CubeMapFace(gl, texture, textureTarget, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, pixelFormat, pixelDatatype, size, preMultiplyAlpha, flipY, initialized);\n  this._negativeZ = new CubeMapFace(gl, texture, textureTarget, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, pixelFormat, pixelDatatype, size, preMultiplyAlpha, flipY, initialized);\n  this.sampler = defined(options.sampler) ? options.sampler : new Sampler();\n}\n\nObject.defineProperties(CubeMap.prototype, {\n  positiveX: {\n    get: function get() {\n      return this._positiveX;\n    }\n  },\n  negativeX: {\n    get: function get() {\n      return this._negativeX;\n    }\n  },\n  positiveY: {\n    get: function get() {\n      return this._positiveY;\n    }\n  },\n  negativeY: {\n    get: function get() {\n      return this._negativeY;\n    }\n  },\n  positiveZ: {\n    get: function get() {\n      return this._positiveZ;\n    }\n  },\n  negativeZ: {\n    get: function get() {\n      return this._negativeZ;\n    }\n  },\n  sampler: {\n    get: function get() {\n      return this._sampler;\n    },\n    set: function set(sampler) {\n      var minificationFilter = sampler.minificationFilter;\n      var magnificationFilter = sampler.magnificationFilter;\n      var mipmap = minificationFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST || minificationFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR || minificationFilter === TextureMinificationFilter.LINEAR_MIPMAP_NEAREST || minificationFilter === TextureMinificationFilter.LINEAR_MIPMAP_LINEAR;\n      var context = this._context;\n      var pixelDatatype = this._pixelDatatype; // float textures only support nearest filtering unless the linear extensions are supported, so override the sampler's settings\n\n      if (pixelDatatype === PixelDatatype.FLOAT && !context.textureFloatLinear || pixelDatatype === PixelDatatype.HALF_FLOAT && !context.textureHalfFloatLinear) {\n        minificationFilter = mipmap ? TextureMinificationFilter.NEAREST_MIPMAP_NEAREST : TextureMinificationFilter.NEAREST;\n        magnificationFilter = TextureMagnificationFilter.NEAREST;\n      }\n\n      var gl = context._gl;\n      var target = this._textureTarget;\n      gl.activeTexture(gl.TEXTURE0);\n      gl.bindTexture(target, this._texture);\n      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, minificationFilter);\n      gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, magnificationFilter);\n      gl.texParameteri(target, gl.TEXTURE_WRAP_S, sampler.wrapS);\n      gl.texParameteri(target, gl.TEXTURE_WRAP_T, sampler.wrapT);\n\n      if (defined(this._textureFilterAnisotropic)) {\n        gl.texParameteri(target, this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, sampler.maximumAnisotropy);\n      }\n\n      gl.bindTexture(target, null);\n      this._sampler = sampler;\n    }\n  },\n  pixelFormat: {\n    get: function get() {\n      return this._pixelFormat;\n    }\n  },\n  pixelDatatype: {\n    get: function get() {\n      return this._pixelDatatype;\n    }\n  },\n  width: {\n    get: function get() {\n      return this._size;\n    }\n  },\n  height: {\n    get: function get() {\n      return this._size;\n    }\n  },\n  sizeInBytes: {\n    get: function get() {\n      if (this._hasMipmap) {\n        return Math.floor(this._sizeInBytes * 4 / 3);\n      }\n\n      return this._sizeInBytes;\n    }\n  },\n  preMultiplyAlpha: {\n    get: function get() {\n      return this._preMultiplyAlpha;\n    }\n  },\n  flipY: {\n    get: function get() {\n      return this._flipY;\n    }\n  },\n  _target: {\n    get: function get() {\n      return this._textureTarget;\n    }\n  }\n});\n/**\n * Generates a complete mipmap chain for each cubemap face.\n *\n * @param {MipmapHint} [hint=MipmapHint.DONT_CARE] A performance vs. quality hint.\n *\n * @exception {DeveloperError} hint is invalid.\n * @exception {DeveloperError} This CubeMap's width must be a power of two to call generateMipmap().\n * @exception {DeveloperError} This CubeMap's height must be a power of two to call generateMipmap().\n * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.\n *\n * @example\n * // Generate mipmaps, and then set the sampler so mipmaps are used for\n * // minification when the cube map is sampled.\n * cubeMap.generateMipmap();\n * cubeMap.sampler = new Sampler({\n *   minificationFilter : Cesium.TextureMinificationFilter.NEAREST_MIPMAP_LINEAR\n * });\n */\n\nCubeMap.prototype.generateMipmap = function (hint) {\n  hint = defaultValue(hint, MipmapHint.DONT_CARE); //>>includeStart('debug', pragmas.debug);\n\n  if (this._size > 1 && !CesiumMath.isPowerOfTwo(this._size)) {\n    throw new DeveloperError(\"width and height must be a power of two to call generateMipmap().\");\n  }\n\n  if (!MipmapHint.validate(hint)) {\n    throw new DeveloperError(\"hint is invalid.\");\n  } //>>includeEnd('debug');\n\n\n  this._hasMipmap = true;\n  var gl = this._context._gl;\n  var target = this._textureTarget;\n  gl.hint(gl.GENERATE_MIPMAP_HINT, hint);\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(target, this._texture);\n  gl.generateMipmap(target);\n  gl.bindTexture(target, null);\n};\n\nCubeMap.prototype.isDestroyed = function () {\n  return false;\n};\n\nCubeMap.prototype.destroy = function () {\n  this._context._gl.deleteTexture(this._texture);\n\n  this._positiveX = destroyObject(this._positiveX);\n  this._negativeX = destroyObject(this._negativeX);\n  this._positiveY = destroyObject(this._positiveY);\n  this._negativeY = destroyObject(this._negativeY);\n  this._positiveZ = destroyObject(this._positiveZ);\n  this._negativeZ = destroyObject(this._negativeZ);\n  return destroyObject(this);\n};\n\nexport default CubeMap;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Renderer/CubeMap.js"],"names":["Check","defaultValue","defined","destroyObject","DeveloperError","CesiumMath","PixelFormat","ContextLimits","CubeMapFace","MipmapHint","PixelDatatype","Sampler","TextureMagnificationFilter","TextureMinificationFilter","CubeMap","options","EMPTY_OBJECT","context","source","width","height","faces","positiveX","negativeX","positiveY","negativeY","positiveZ","negativeZ","i","Number","size","pixelFormat","RGBA","pixelDatatype","UNSIGNED_BYTE","maximumCubeMapSize","validate","isDepthFormat","FLOAT","floatingPointTexture","HALF_FLOAT","halfFloatingPointTexture","sizeInBytes","textureSizeInBytes","preMultiplyAlpha","RGB","LUMINANCE","flipY","gl","_gl","textureTarget","TEXTURE_CUBE_MAP","texture","createTexture","activeTexture","TEXTURE0","bindTexture","createFace","target","sourceFace","arrayBufferView","bufferView","unpackAlignment","alignmentInBytes","pixelStorei","UNPACK_ALIGNMENT","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_FLIP_Y_WEBGL","texImage2D","TEXTURE_CUBE_MAP_POSITIVE_X","TEXTURE_CUBE_MAP_NEGATIVE_X","TEXTURE_CUBE_MAP_POSITIVE_Y","TEXTURE_CUBE_MAP_NEGATIVE_Y","TEXTURE_CUBE_MAP_POSITIVE_Z","TEXTURE_CUBE_MAP_NEGATIVE_Z","_context","_textureFilterAnisotropic","_textureTarget","_texture","_pixelFormat","_pixelDatatype","_size","_hasMipmap","_sizeInBytes","_preMultiplyAlpha","_flipY","_sampler","undefined","initialized","_positiveX","_negativeX","_positiveY","_negativeY","_positiveZ","_negativeZ","sampler","Object","defineProperties","prototype","get","set","minificationFilter","magnificationFilter","mipmap","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","textureFloatLinear","textureHalfFloatLinear","NEAREST","texParameteri","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","wrapS","TEXTURE_WRAP_T","wrapT","TEXTURE_MAX_ANISOTROPY_EXT","maximumAnisotropy","Math","floor","_target","generateMipmap","hint","DONT_CARE","isPowerOfTwo","GENERATE_MIPMAP_HINT","isDestroyed","destroy","deleteTexture"],"mappings":"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","sourcesContent":["import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport ContextLimits from \"./ContextLimits.js\";\nimport CubeMapFace from \"./CubeMapFace.js\";\nimport MipmapHint from \"./MipmapHint.js\";\nimport PixelDatatype from \"./PixelDatatype.js\";\nimport Sampler from \"./Sampler.js\";\nimport TextureMagnificationFilter from \"./TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"./TextureMinificationFilter.js\";\n\n/**\n * @private\n */\nfunction CubeMap(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n  //>>includeEnd('debug');\n\n  var context = options.context;\n  var source = options.source;\n  var width;\n  var height;\n\n  if (defined(source)) {\n    var faces = [\n      source.positiveX,\n      source.negativeX,\n      source.positiveY,\n      source.negativeY,\n      source.positiveZ,\n      source.negativeZ,\n    ];\n\n    //>>includeStart('debug', pragmas.debug);\n    if (\n      !faces[0] ||\n      !faces[1] ||\n      !faces[2] ||\n      !faces[3] ||\n      !faces[4] ||\n      !faces[5]\n    ) {\n      throw new DeveloperError(\n        \"options.source requires positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ faces.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    width = faces[0].width;\n    height = faces[0].height;\n\n    //>>includeStart('debug', pragmas.debug);\n    for (var i = 1; i < 6; ++i) {\n      if (\n        Number(faces[i].width) !== width ||\n        Number(faces[i].height) !== height\n      ) {\n        throw new DeveloperError(\n          \"Each face in options.source must have the same width and height.\"\n        );\n      }\n    }\n    //>>includeEnd('debug');\n  } else {\n    width = options.width;\n    height = options.height;\n  }\n\n  var size = width;\n  var pixelFormat = defaultValue(options.pixelFormat, PixelFormat.RGBA);\n  var pixelDatatype = defaultValue(\n    options.pixelDatatype,\n    PixelDatatype.UNSIGNED_BYTE\n  );\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(width) || !defined(height)) {\n    throw new DeveloperError(\n      \"options requires a source field to create an initialized cube map or width and height fields to create a blank cube map.\"\n    );\n  }\n\n  if (width !== height) {\n    throw new DeveloperError(\"Width must equal height.\");\n  }\n\n  if (size <= 0) {\n    throw new DeveloperError(\"Width and height must be greater than zero.\");\n  }\n\n  if (size > ContextLimits.maximumCubeMapSize) {\n    throw new DeveloperError(\n      \"Width and height must be less than or equal to the maximum cube map size (\" +\n        ContextLimits.maximumCubeMapSize +\n        \").  Check maximumCubeMapSize.\"\n    );\n  }\n\n  if (!PixelFormat.validate(pixelFormat)) {\n    throw new DeveloperError(\"Invalid options.pixelFormat.\");\n  }\n\n  if (PixelFormat.isDepthFormat(pixelFormat)) {\n    throw new DeveloperError(\n      \"options.pixelFormat cannot be DEPTH_COMPONENT or DEPTH_STENCIL.\"\n    );\n  }\n\n  if (!PixelDatatype.validate(pixelDatatype)) {\n    throw new DeveloperError(\"Invalid options.pixelDatatype.\");\n  }\n\n  if (pixelDatatype === PixelDatatype.FLOAT && !context.floatingPointTexture) {\n    throw new DeveloperError(\n      \"When options.pixelDatatype is FLOAT, this WebGL implementation must support the OES_texture_float extension.\"\n    );\n  }\n\n  if (\n    pixelDatatype === PixelDatatype.HALF_FLOAT &&\n    !context.halfFloatingPointTexture\n  ) {\n    throw new DeveloperError(\n      \"When options.pixelDatatype is HALF_FLOAT, this WebGL implementation must support the OES_texture_half_float extension.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var sizeInBytes =\n    PixelFormat.textureSizeInBytes(pixelFormat, pixelDatatype, size, size) * 6;\n\n  // Use premultiplied alpha for opaque textures should perform better on Chrome:\n  // http://media.tojicode.com/webglCamp4/#20\n  var preMultiplyAlpha =\n    options.preMultiplyAlpha ||\n    pixelFormat === PixelFormat.RGB ||\n    pixelFormat === PixelFormat.LUMINANCE;\n  var flipY = defaultValue(options.flipY, true);\n\n  var gl = context._gl;\n  var textureTarget = gl.TEXTURE_CUBE_MAP;\n  var texture = gl.createTexture();\n\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(textureTarget, texture);\n\n  function createFace(target, sourceFace, preMultiplyAlpha, flipY) {\n    var arrayBufferView = sourceFace.arrayBufferView;\n    if (!defined(arrayBufferView)) {\n      arrayBufferView = sourceFace.bufferView;\n    }\n\n    var unpackAlignment = 4;\n    if (defined(arrayBufferView)) {\n      unpackAlignment = PixelFormat.alignmentInBytes(\n        pixelFormat,\n        pixelDatatype,\n        width\n      );\n    }\n\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);\n\n    if (defined(arrayBufferView)) {\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n\n      if (flipY) {\n        arrayBufferView = PixelFormat.flipY(\n          arrayBufferView,\n          pixelFormat,\n          pixelDatatype,\n          size,\n          size\n        );\n      }\n      gl.texImage2D(\n        target,\n        0,\n        pixelFormat,\n        size,\n        size,\n        0,\n        pixelFormat,\n        pixelDatatype,\n        arrayBufferView\n      );\n    } else {\n      // Only valid for DOM-Element uploads\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\n\n      // Source: ImageData, HTMLImageElement, HTMLCanvasElement, or HTMLVideoElement\n      gl.texImage2D(\n        target,\n        0,\n        pixelFormat,\n        pixelFormat,\n        pixelDatatype,\n        sourceFace\n      );\n    }\n  }\n\n  if (defined(source)) {\n    createFace(\n      gl.TEXTURE_CUBE_MAP_POSITIVE_X,\n      source.positiveX,\n      preMultiplyAlpha,\n      flipY\n    );\n    createFace(\n      gl.TEXTURE_CUBE_MAP_NEGATIVE_X,\n      source.negativeX,\n      preMultiplyAlpha,\n      flipY\n    );\n    createFace(\n      gl.TEXTURE_CUBE_MAP_POSITIVE_Y,\n      source.positiveY,\n      preMultiplyAlpha,\n      flipY\n    );\n    createFace(\n      gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,\n      source.negativeY,\n      preMultiplyAlpha,\n      flipY\n    );\n    createFace(\n      gl.TEXTURE_CUBE_MAP_POSITIVE_Z,\n      source.positiveZ,\n      preMultiplyAlpha,\n      flipY\n    );\n    createFace(\n      gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,\n      source.negativeZ,\n      preMultiplyAlpha,\n      flipY\n    );\n  } else {\n    gl.texImage2D(\n      gl.TEXTURE_CUBE_MAP_POSITIVE_X,\n      0,\n      pixelFormat,\n      size,\n      size,\n      0,\n      pixelFormat,\n      pixelDatatype,\n      null\n    );\n    gl.texImage2D(\n      gl.TEXTURE_CUBE_MAP_NEGATIVE_X,\n      0,\n      pixelFormat,\n      size,\n      size,\n      0,\n      pixelFormat,\n      pixelDatatype,\n      null\n    );\n    gl.texImage2D(\n      gl.TEXTURE_CUBE_MAP_POSITIVE_Y,\n      0,\n      pixelFormat,\n      size,\n      size,\n      0,\n      pixelFormat,\n      pixelDatatype,\n      null\n    );\n    gl.texImage2D(\n      gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,\n      0,\n      pixelFormat,\n      size,\n      size,\n      0,\n      pixelFormat,\n      pixelDatatype,\n      null\n    );\n    gl.texImage2D(\n      gl.TEXTURE_CUBE_MAP_POSITIVE_Z,\n      0,\n      pixelFormat,\n      size,\n      size,\n      0,\n      pixelFormat,\n      pixelDatatype,\n      null\n    );\n    gl.texImage2D(\n      gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,\n      0,\n      pixelFormat,\n      size,\n      size,\n      0,\n      pixelFormat,\n      pixelDatatype,\n      null\n    );\n  }\n  gl.bindTexture(textureTarget, null);\n\n  this._context = context;\n  this._textureFilterAnisotropic = context._textureFilterAnisotropic;\n  this._textureTarget = textureTarget;\n  this._texture = texture;\n  this._pixelFormat = pixelFormat;\n  this._pixelDatatype = pixelDatatype;\n  this._size = size;\n  this._hasMipmap = false;\n  this._sizeInBytes = sizeInBytes;\n  this._preMultiplyAlpha = preMultiplyAlpha;\n  this._flipY = flipY;\n  this._sampler = undefined;\n\n  var initialized = defined(source);\n  this._positiveX = new CubeMapFace(\n    gl,\n    texture,\n    textureTarget,\n    gl.TEXTURE_CUBE_MAP_POSITIVE_X,\n    pixelFormat,\n    pixelDatatype,\n    size,\n    preMultiplyAlpha,\n    flipY,\n    initialized\n  );\n  this._negativeX = new CubeMapFace(\n    gl,\n    texture,\n    textureTarget,\n    gl.TEXTURE_CUBE_MAP_NEGATIVE_X,\n    pixelFormat,\n    pixelDatatype,\n    size,\n    preMultiplyAlpha,\n    flipY,\n    initialized\n  );\n  this._positiveY = new CubeMapFace(\n    gl,\n    texture,\n    textureTarget,\n    gl.TEXTURE_CUBE_MAP_POSITIVE_Y,\n    pixelFormat,\n    pixelDatatype,\n    size,\n    preMultiplyAlpha,\n    flipY,\n    initialized\n  );\n  this._negativeY = new CubeMapFace(\n    gl,\n    texture,\n    textureTarget,\n    gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,\n    pixelFormat,\n    pixelDatatype,\n    size,\n    preMultiplyAlpha,\n    flipY,\n    initialized\n  );\n  this._positiveZ = new CubeMapFace(\n    gl,\n    texture,\n    textureTarget,\n    gl.TEXTURE_CUBE_MAP_POSITIVE_Z,\n    pixelFormat,\n    pixelDatatype,\n    size,\n    preMultiplyAlpha,\n    flipY,\n    initialized\n  );\n  this._negativeZ = new CubeMapFace(\n    gl,\n    texture,\n    textureTarget,\n    gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,\n    pixelFormat,\n    pixelDatatype,\n    size,\n    preMultiplyAlpha,\n    flipY,\n    initialized\n  );\n\n  this.sampler = defined(options.sampler) ? options.sampler : new Sampler();\n}\n\nObject.defineProperties(CubeMap.prototype, {\n  positiveX: {\n    get: function () {\n      return this._positiveX;\n    },\n  },\n  negativeX: {\n    get: function () {\n      return this._negativeX;\n    },\n  },\n  positiveY: {\n    get: function () {\n      return this._positiveY;\n    },\n  },\n  negativeY: {\n    get: function () {\n      return this._negativeY;\n    },\n  },\n  positiveZ: {\n    get: function () {\n      return this._positiveZ;\n    },\n  },\n  negativeZ: {\n    get: function () {\n      return this._negativeZ;\n    },\n  },\n  sampler: {\n    get: function () {\n      return this._sampler;\n    },\n    set: function (sampler) {\n      var minificationFilter = sampler.minificationFilter;\n      var magnificationFilter = sampler.magnificationFilter;\n\n      var mipmap =\n        minificationFilter ===\n          TextureMinificationFilter.NEAREST_MIPMAP_NEAREST ||\n        minificationFilter ===\n          TextureMinificationFilter.NEAREST_MIPMAP_LINEAR ||\n        minificationFilter ===\n          TextureMinificationFilter.LINEAR_MIPMAP_NEAREST ||\n        minificationFilter === TextureMinificationFilter.LINEAR_MIPMAP_LINEAR;\n\n      var context = this._context;\n      var pixelDatatype = this._pixelDatatype;\n\n      // float textures only support nearest filtering unless the linear extensions are supported, so override the sampler's settings\n      if (\n        (pixelDatatype === PixelDatatype.FLOAT &&\n          !context.textureFloatLinear) ||\n        (pixelDatatype === PixelDatatype.HALF_FLOAT &&\n          !context.textureHalfFloatLinear)\n      ) {\n        minificationFilter = mipmap\n          ? TextureMinificationFilter.NEAREST_MIPMAP_NEAREST\n          : TextureMinificationFilter.NEAREST;\n        magnificationFilter = TextureMagnificationFilter.NEAREST;\n      }\n\n      var gl = context._gl;\n      var target = this._textureTarget;\n\n      gl.activeTexture(gl.TEXTURE0);\n      gl.bindTexture(target, this._texture);\n      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, minificationFilter);\n      gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, magnificationFilter);\n      gl.texParameteri(target, gl.TEXTURE_WRAP_S, sampler.wrapS);\n      gl.texParameteri(target, gl.TEXTURE_WRAP_T, sampler.wrapT);\n      if (defined(this._textureFilterAnisotropic)) {\n        gl.texParameteri(\n          target,\n          this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,\n          sampler.maximumAnisotropy\n        );\n      }\n      gl.bindTexture(target, null);\n\n      this._sampler = sampler;\n    },\n  },\n  pixelFormat: {\n    get: function () {\n      return this._pixelFormat;\n    },\n  },\n  pixelDatatype: {\n    get: function () {\n      return this._pixelDatatype;\n    },\n  },\n  width: {\n    get: function () {\n      return this._size;\n    },\n  },\n  height: {\n    get: function () {\n      return this._size;\n    },\n  },\n  sizeInBytes: {\n    get: function () {\n      if (this._hasMipmap) {\n        return Math.floor((this._sizeInBytes * 4) / 3);\n      }\n      return this._sizeInBytes;\n    },\n  },\n  preMultiplyAlpha: {\n    get: function () {\n      return this._preMultiplyAlpha;\n    },\n  },\n  flipY: {\n    get: function () {\n      return this._flipY;\n    },\n  },\n\n  _target: {\n    get: function () {\n      return this._textureTarget;\n    },\n  },\n});\n\n/**\n * Generates a complete mipmap chain for each cubemap face.\n *\n * @param {MipmapHint} [hint=MipmapHint.DONT_CARE] A performance vs. quality hint.\n *\n * @exception {DeveloperError} hint is invalid.\n * @exception {DeveloperError} This CubeMap's width must be a power of two to call generateMipmap().\n * @exception {DeveloperError} This CubeMap's height must be a power of two to call generateMipmap().\n * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.\n *\n * @example\n * // Generate mipmaps, and then set the sampler so mipmaps are used for\n * // minification when the cube map is sampled.\n * cubeMap.generateMipmap();\n * cubeMap.sampler = new Sampler({\n *   minificationFilter : Cesium.TextureMinificationFilter.NEAREST_MIPMAP_LINEAR\n * });\n */\nCubeMap.prototype.generateMipmap = function (hint) {\n  hint = defaultValue(hint, MipmapHint.DONT_CARE);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (this._size > 1 && !CesiumMath.isPowerOfTwo(this._size)) {\n    throw new DeveloperError(\n      \"width and height must be a power of two to call generateMipmap().\"\n    );\n  }\n  if (!MipmapHint.validate(hint)) {\n    throw new DeveloperError(\"hint is invalid.\");\n  }\n  //>>includeEnd('debug');\n\n  this._hasMipmap = true;\n\n  var gl = this._context._gl;\n  var target = this._textureTarget;\n  gl.hint(gl.GENERATE_MIPMAP_HINT, hint);\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(target, this._texture);\n  gl.generateMipmap(target);\n  gl.bindTexture(target, null);\n};\n\nCubeMap.prototype.isDestroyed = function () {\n  return false;\n};\n\nCubeMap.prototype.destroy = function () {\n  this._context._gl.deleteTexture(this._texture);\n  this._positiveX = destroyObject(this._positiveX);\n  this._negativeX = destroyObject(this._negativeX);\n  this._positiveY = destroyObject(this._positiveY);\n  this._negativeY = destroyObject(this._negativeY);\n  this._positiveZ = destroyObject(this._positiveZ);\n  this._negativeZ = destroyObject(this._negativeZ);\n  return destroyObject(this);\n};\nexport default CubeMap;\n"]},"metadata":{},"sourceType":"module"}