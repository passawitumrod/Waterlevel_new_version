{"ast":null,"code":"import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport ModelAnimation from \"./ModelAnimation.js\";\nimport ModelAnimationLoop from \"./ModelAnimationLoop.js\";\nimport ModelAnimationState from \"./ModelAnimationState.js\";\n/**\n * A collection of active model animations.  Access this using {@link Model#activeAnimations}.\n *\n * @alias ModelAnimationCollection\n * @internalConstructor\n * @class\n *\n * @see Model#activeAnimations\n */\n\nfunction ModelAnimationCollection(model) {\n  /**\n   * The event fired when an animation is added to the collection.  This can be used, for\n   * example, to keep a UI in sync.\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * model.activeAnimations.animationAdded.addEventListener(function(model, animation) {\n   *   console.log('Animation added: ' + animation.name);\n   * });\n   */\n  this.animationAdded = new Event();\n  /**\n   * The event fired when an animation is removed from the collection.  This can be used, for\n   * example, to keep a UI in sync.\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * model.activeAnimations.animationRemoved.addEventListener(function(model, animation) {\n   *   console.log('Animation removed: ' + animation.name);\n   * });\n   */\n\n  this.animationRemoved = new Event();\n  this._model = model;\n  this._scheduledAnimations = [];\n  this._previousTime = undefined;\n}\n\nObject.defineProperties(ModelAnimationCollection.prototype, {\n  /**\n   * The number of animations in the collection.\n   *\n   * @memberof ModelAnimationCollection.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  length: {\n    get: function get() {\n      return this._scheduledAnimations.length;\n    }\n  }\n});\n\nfunction add(collection, index, options) {\n  var model = collection._model;\n  var animations = model._runtime.animations;\n  var animation = animations[index];\n  var scheduledAnimation = new ModelAnimation(options, model, animation);\n\n  collection._scheduledAnimations.push(scheduledAnimation);\n\n  collection.animationAdded.raiseEvent(model, scheduledAnimation);\n  return scheduledAnimation;\n}\n/**\n * Creates and adds an animation with the specified initial properties to the collection.\n * <p>\n * This raises the {@link ModelAnimationCollection#animationAdded} event so, for example, a UI can stay in sync.\n * </p>\n *\n * @param {Object} options Object with the following properties:\n * @param {String} [options.name] The glTF animation name that identifies the animation. Must be defined if <code>options.index</code> is <code>undefined</code>.\n * @param {Number} [options.index] The glTF animation index that identifies the animation. Must be defined if <code>options.name</code> is <code>undefined</code>.\n * @param {JulianDate} [options.startTime] The scene time to start playing the animation.  When this is <code>undefined</code>, the animation starts at the next frame.\n * @param {Number} [options.delay=0.0] The delay, in seconds, from <code>startTime</code> to start playing.\n * @param {JulianDate} [options.stopTime] The scene time to stop playing the animation.  When this is <code>undefined</code>, the animation is played for its full duration.\n * @param {Boolean} [options.removeOnStop=false] When <code>true</code>, the animation is removed after it stops playing.\n * @param {Number} [options.multiplier=1.0] Values greater than <code>1.0</code> increase the speed that the animation is played relative to the scene clock speed; values less than <code>1.0</code> decrease the speed.\n * @param {Boolean} [options.reverse=false] When <code>true</code>, the animation is played in reverse.\n * @param {ModelAnimationLoop} [options.loop=ModelAnimationLoop.NONE] Determines if and how the animation is looped.\n * @returns {ModelAnimation} The animation that was added to the collection.\n *\n * @exception {DeveloperError} Animations are not loaded.  Wait for the {@link Model#readyPromise} to resolve.\n * @exception {DeveloperError} options.name must be a valid animation name.\n * @exception {DeveloperError} options.index must be a valid animation index.\n * @exception {DeveloperError} Either options.name or options.index must be defined.\n * @exception {DeveloperError} options.multiplier must be greater than zero.\n *\n * @example\n * // Example 1. Add an animation by name\n * model.activeAnimations.add({\n *   name : 'animation name'\n * });\n *\n * // Example 2. Add an animation by index\n * model.activeAnimations.add({\n *   index : 0\n * });\n *\n * @example\n * // Example 3. Add an animation and provide all properties and events\n * var startTime = Cesium.JulianDate.now();\n *\n * var animation = model.activeAnimations.add({\n *   name : 'another animation name',\n *   startTime : startTime,\n *   delay : 0.0,                          // Play at startTime (default)\n *   stopTime : Cesium.JulianDate.addSeconds(startTime, 4.0, new Cesium.JulianDate()),\n *   removeOnStop : false,                 // Do not remove when animation stops (default)\n *   multiplier : 2.0,                        // Play at double speed\n *   reverse : true,                       // Play in reverse\n *   loop : Cesium.ModelAnimationLoop.REPEAT      // Loop the animation\n * });\n *\n * animation.start.addEventListener(function(model, animation) {\n *   console.log('Animation started: ' + animation.name);\n * });\n * animation.update.addEventListener(function(model, animation, time) {\n *   console.log('Animation updated: ' + animation.name + '. glTF animation time: ' + time);\n * });\n * animation.stop.addEventListener(function(model, animation) {\n *   console.log('Animation stopped: ' + animation.name);\n * });\n */\n\n\nModelAnimationCollection.prototype.add = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var model = this._model;\n  var animations = model._runtime.animations; //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(animations)) {\n    throw new DeveloperError(\"Animations are not loaded.  Wait for Model.readyPromise to resolve.\");\n  }\n\n  if (!defined(options.name) && !defined(options.index)) {\n    throw new DeveloperError(\"Either options.name or options.index must be defined.\");\n  }\n\n  if (defined(options.multiplier) && options.multiplier <= 0.0) {\n    throw new DeveloperError(\"options.multiplier must be greater than zero.\");\n  }\n\n  if (defined(options.index) && (options.index >= animations.length || options.index < 0)) {\n    throw new DeveloperError(\"options.index must be a valid animation index.\");\n  } //>>includeEnd('debug');\n\n\n  if (defined(options.index)) {\n    return add(this, options.index, options);\n  } // Find the index of the animation with the given name\n\n\n  var index;\n  var length = animations.length;\n\n  for (var i = 0; i < length; ++i) {\n    if (animations[i].name === options.name) {\n      index = i;\n      break;\n    }\n  } //>>includeStart('debug', pragmas.debug);\n\n\n  if (!defined(index)) {\n    throw new DeveloperError(\"options.name must be a valid animation name.\");\n  } //>>includeEnd('debug');\n\n\n  return add(this, index, options);\n};\n/**\n * Creates and adds an animation with the specified initial properties to the collection\n * for each animation in the model.\n * <p>\n * This raises the {@link ModelAnimationCollection#animationAdded} event for each model so, for example, a UI can stay in sync.\n * </p>\n *\n * @param {Object} [options] Object with the following properties:\n * @param {JulianDate} [options.startTime] The scene time to start playing the animations.  When this is <code>undefined</code>, the animations starts at the next frame.\n * @param {Number} [options.delay=0.0] The delay, in seconds, from <code>startTime</code> to start playing.\n * @param {JulianDate} [options.stopTime] The scene time to stop playing the animations.  When this is <code>undefined</code>, the animations are played for its full duration.\n * @param {Boolean} [options.removeOnStop=false] When <code>true</code>, the animations are removed after they stop playing.\n * @param {Number} [options.multiplier=1.0] Values greater than <code>1.0</code> increase the speed that the animations play relative to the scene clock speed; values less than <code>1.0</code> decrease the speed.\n * @param {Boolean} [options.reverse=false] When <code>true</code>, the animations are played in reverse.\n * @param {ModelAnimationLoop} [options.loop=ModelAnimationLoop.NONE] Determines if and how the animations are looped.\n * @returns {ModelAnimation[]} An array of {@link ModelAnimation} objects, one for each animation added to the collection.  If there are no glTF animations, the array is empty.\n *\n * @exception {DeveloperError} Animations are not loaded.  Wait for the {@link Model#readyPromise} to resolve.\n * @exception {DeveloperError} options.multiplier must be greater than zero.\n *\n * @example\n * model.activeAnimations.addAll({\n *   multiplier : 0.5,                        // Play at half-speed\n *   loop : Cesium.ModelAnimationLoop.REPEAT      // Loop the animations\n * });\n */\n\n\nModelAnimationCollection.prototype.addAll = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(this._model._runtime.animations)) {\n    throw new DeveloperError(\"Animations are not loaded.  Wait for Model.readyPromise to resolve.\");\n  }\n\n  if (defined(options.multiplier) && options.multiplier <= 0.0) {\n    throw new DeveloperError(\"options.multiplier must be greater than zero.\");\n  } //>>includeEnd('debug');\n\n\n  var scheduledAnimations = [];\n  var model = this._model;\n  var animations = model._runtime.animations;\n  var length = animations.length;\n\n  for (var i = 0; i < length; ++i) {\n    scheduledAnimations.push(add(this, i, options));\n  }\n\n  return scheduledAnimations;\n};\n/**\n * Removes an animation from the collection.\n * <p>\n * This raises the {@link ModelAnimationCollection#animationRemoved} event so, for example, a UI can stay in sync.\n * </p>\n * <p>\n * An animation can also be implicitly removed from the collection by setting {@link ModelAnimation#removeOnStop} to\n * <code>true</code>.  The {@link ModelAnimationCollection#animationRemoved} event is still fired when the animation is removed.\n * </p>\n *\n * @param {ModelAnimation} animation The animation to remove.\n * @returns {Boolean} <code>true</code> if the animation was removed; <code>false</code> if the animation was not found in the collection.\n *\n * @example\n * var a = model.activeAnimations.add({\n *   name : 'animation name'\n * });\n * model.activeAnimations.remove(a); // Returns true\n */\n\n\nModelAnimationCollection.prototype.remove = function (animation) {\n  if (defined(animation)) {\n    var animations = this._scheduledAnimations;\n    var i = animations.indexOf(animation);\n\n    if (i !== -1) {\n      animations.splice(i, 1);\n      this.animationRemoved.raiseEvent(this._model, animation);\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Removes all animations from the collection.\n * <p>\n * This raises the {@link ModelAnimationCollection#animationRemoved} event for each\n * animation so, for example, a UI can stay in sync.\n * </p>\n */\n\n\nModelAnimationCollection.prototype.removeAll = function () {\n  var model = this._model;\n  var animations = this._scheduledAnimations;\n  var length = animations.length;\n  this._scheduledAnimations = [];\n\n  for (var i = 0; i < length; ++i) {\n    this.animationRemoved.raiseEvent(model, animations[i]);\n  }\n};\n/**\n * Determines whether this collection contains a given animation.\n *\n * @param {ModelAnimation} animation The animation to check for.\n * @returns {Boolean} <code>true</code> if this collection contains the animation, <code>false</code> otherwise.\n */\n\n\nModelAnimationCollection.prototype.contains = function (animation) {\n  if (defined(animation)) {\n    return this._scheduledAnimations.indexOf(animation) !== -1;\n  }\n\n  return false;\n};\n/**\n * Returns the animation in the collection at the specified index.  Indices are zero-based\n * and increase as animations are added.  Removing an animation shifts all animations after\n * it to the left, changing their indices.  This function is commonly used to iterate over\n * all the animations in the collection.\n *\n * @param {Number} index The zero-based index of the animation.\n * @returns {ModelAnimation} The animation at the specified index.\n *\n * @example\n * // Output the names of all the animations in the collection.\n * var animations = model.activeAnimations;\n * var length = animations.length;\n * for (var i = 0; i < length; ++i) {\n *   console.log(animations.get(i).name);\n * }\n */\n\n\nModelAnimationCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  } //>>includeEnd('debug');\n\n\n  return this._scheduledAnimations[index];\n};\n\nfunction animateChannels(runtimeAnimation, localAnimationTime) {\n  var channelEvaluators = runtimeAnimation.channelEvaluators;\n  var length = channelEvaluators.length;\n\n  for (var i = 0; i < length; ++i) {\n    channelEvaluators[i](localAnimationTime);\n  }\n}\n\nvar animationsToRemove = [];\n\nfunction createAnimationRemovedFunction(modelAnimationCollection, model, animation) {\n  return function () {\n    modelAnimationCollection.animationRemoved.raiseEvent(model, animation);\n  };\n}\n/**\n * @private\n */\n\n\nModelAnimationCollection.prototype.update = function (frameState) {\n  var scheduledAnimations = this._scheduledAnimations;\n  var length = scheduledAnimations.length;\n\n  if (length === 0) {\n    // No animations - quick return for performance\n    this._previousTime = undefined;\n    return false;\n  }\n\n  if (JulianDate.equals(frameState.time, this._previousTime)) {\n    // Animations are currently only time-dependent so do not animate when paused or picking\n    return false;\n  }\n\n  this._previousTime = JulianDate.clone(frameState.time, this._previousTime);\n  var animationOccured = false;\n  var sceneTime = frameState.time;\n  var model = this._model;\n\n  for (var i = 0; i < length; ++i) {\n    var scheduledAnimation = scheduledAnimations[i];\n    var runtimeAnimation = scheduledAnimation._runtimeAnimation;\n\n    if (!defined(scheduledAnimation._computedStartTime)) {\n      scheduledAnimation._computedStartTime = JulianDate.addSeconds(defaultValue(scheduledAnimation.startTime, sceneTime), scheduledAnimation.delay, new JulianDate());\n    }\n\n    if (!defined(scheduledAnimation._duration)) {\n      scheduledAnimation._duration = runtimeAnimation.stopTime * (1.0 / scheduledAnimation.multiplier);\n    }\n\n    var startTime = scheduledAnimation._computedStartTime;\n    var duration = scheduledAnimation._duration;\n    var stopTime = scheduledAnimation.stopTime; // [0.0, 1.0] normalized local animation time\n\n    var delta = duration !== 0.0 ? JulianDate.secondsDifference(sceneTime, startTime) / duration : 0.0; // Clamp delta to stop time, if defined.\n\n    if (duration !== 0.0 && defined(stopTime) && JulianDate.greaterThan(sceneTime, stopTime)) {\n      delta = JulianDate.secondsDifference(stopTime, startTime) / duration;\n    }\n\n    var pastStartTime = delta >= 0.0; // Play animation if\n    // * we are after the start time or the animation is being repeated, and\n    // * before the end of the animation's duration or the animation is being repeated, and\n    // * we did not reach a user-provided stop time.\n\n    var repeat = scheduledAnimation.loop === ModelAnimationLoop.REPEAT || scheduledAnimation.loop === ModelAnimationLoop.MIRRORED_REPEAT;\n    var play = (pastStartTime || repeat && !defined(scheduledAnimation.startTime)) && (delta <= 1.0 || repeat) && (!defined(stopTime) || JulianDate.lessThanOrEquals(sceneTime, stopTime)); // If it IS, or WAS, animating...\n\n    if (play || scheduledAnimation._state === ModelAnimationState.ANIMATING) {\n      // STOPPED -> ANIMATING state transition?\n      if (play && scheduledAnimation._state === ModelAnimationState.STOPPED) {\n        scheduledAnimation._state = ModelAnimationState.ANIMATING;\n\n        if (scheduledAnimation.start.numberOfListeners > 0) {\n          frameState.afterRender.push(scheduledAnimation._raiseStartEvent);\n        }\n      } // Truncate to [0.0, 1.0] for repeating animations\n\n\n      if (scheduledAnimation.loop === ModelAnimationLoop.REPEAT) {\n        delta = delta - Math.floor(delta);\n      } else if (scheduledAnimation.loop === ModelAnimationLoop.MIRRORED_REPEAT) {\n        var floor = Math.floor(delta);\n        var fract = delta - floor; // When even use (1.0 - fract) to mirror repeat\n\n        delta = floor % 2 === 1.0 ? 1.0 - fract : fract;\n      }\n\n      if (scheduledAnimation.reverse) {\n        delta = 1.0 - delta;\n      }\n\n      var localAnimationTime = delta * duration * scheduledAnimation.multiplier; // Clamp in case floating-point roundoff goes outside the animation's first or last keyframe\n\n      localAnimationTime = CesiumMath.clamp(localAnimationTime, runtimeAnimation.startTime, runtimeAnimation.stopTime);\n      animateChannels(runtimeAnimation, localAnimationTime);\n\n      if (scheduledAnimation.update.numberOfListeners > 0) {\n        scheduledAnimation._updateEventTime = localAnimationTime;\n        frameState.afterRender.push(scheduledAnimation._raiseUpdateEvent);\n      }\n\n      animationOccured = true;\n\n      if (!play) {\n        // ANIMATING -> STOPPED state transition?\n        scheduledAnimation._state = ModelAnimationState.STOPPED;\n\n        if (scheduledAnimation.stop.numberOfListeners > 0) {\n          frameState.afterRender.push(scheduledAnimation._raiseStopEvent);\n        }\n\n        if (scheduledAnimation.removeOnStop) {\n          animationsToRemove.push(scheduledAnimation);\n        }\n      }\n    }\n  } // Remove animations that stopped\n\n\n  length = animationsToRemove.length;\n\n  for (var j = 0; j < length; ++j) {\n    var animationToRemove = animationsToRemove[j];\n    scheduledAnimations.splice(scheduledAnimations.indexOf(animationToRemove), 1);\n    frameState.afterRender.push(createAnimationRemovedFunction(this, model, animationToRemove));\n  }\n\n  animationsToRemove.length = 0;\n  return animationOccured;\n};\n\nexport default ModelAnimationCollection;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/ModelAnimationCollection.js"],"names":["defaultValue","defined","DeveloperError","Event","JulianDate","CesiumMath","ModelAnimation","ModelAnimationLoop","ModelAnimationState","ModelAnimationCollection","model","animationAdded","animationRemoved","_model","_scheduledAnimations","_previousTime","undefined","Object","defineProperties","prototype","length","get","add","collection","index","options","animations","_runtime","animation","scheduledAnimation","push","raiseEvent","EMPTY_OBJECT","name","multiplier","i","addAll","scheduledAnimations","remove","indexOf","splice","removeAll","contains","animateChannels","runtimeAnimation","localAnimationTime","channelEvaluators","animationsToRemove","createAnimationRemovedFunction","modelAnimationCollection","update","frameState","equals","time","clone","animationOccured","sceneTime","_runtimeAnimation","_computedStartTime","addSeconds","startTime","delay","_duration","stopTime","duration","delta","secondsDifference","greaterThan","pastStartTime","repeat","loop","REPEAT","MIRRORED_REPEAT","play","lessThanOrEquals","_state","ANIMATING","STOPPED","start","numberOfListeners","afterRender","_raiseStartEvent","Math","floor","fract","reverse","clamp","_updateEventTime","_raiseUpdateEvent","stop","_raiseStopEvent","removeOnStop","j","animationToRemove"],"mappings":"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","sourcesContent":["import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport ModelAnimation from \"./ModelAnimation.js\";\nimport ModelAnimationLoop from \"./ModelAnimationLoop.js\";\nimport ModelAnimationState from \"./ModelAnimationState.js\";\n\n/**\n * A collection of active model animations.  Access this using {@link Model#activeAnimations}.\n *\n * @alias ModelAnimationCollection\n * @internalConstructor\n * @class\n *\n * @see Model#activeAnimations\n */\nfunction ModelAnimationCollection(model) {\n  /**\n   * The event fired when an animation is added to the collection.  This can be used, for\n   * example, to keep a UI in sync.\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * model.activeAnimations.animationAdded.addEventListener(function(model, animation) {\n   *   console.log('Animation added: ' + animation.name);\n   * });\n   */\n  this.animationAdded = new Event();\n\n  /**\n   * The event fired when an animation is removed from the collection.  This can be used, for\n   * example, to keep a UI in sync.\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * model.activeAnimations.animationRemoved.addEventListener(function(model, animation) {\n   *   console.log('Animation removed: ' + animation.name);\n   * });\n   */\n  this.animationRemoved = new Event();\n\n  this._model = model;\n  this._scheduledAnimations = [];\n  this._previousTime = undefined;\n}\n\nObject.defineProperties(ModelAnimationCollection.prototype, {\n  /**\n   * The number of animations in the collection.\n   *\n   * @memberof ModelAnimationCollection.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._scheduledAnimations.length;\n    },\n  },\n});\n\nfunction add(collection, index, options) {\n  var model = collection._model;\n  var animations = model._runtime.animations;\n  var animation = animations[index];\n  var scheduledAnimation = new ModelAnimation(options, model, animation);\n  collection._scheduledAnimations.push(scheduledAnimation);\n  collection.animationAdded.raiseEvent(model, scheduledAnimation);\n  return scheduledAnimation;\n}\n\n/**\n * Creates and adds an animation with the specified initial properties to the collection.\n * <p>\n * This raises the {@link ModelAnimationCollection#animationAdded} event so, for example, a UI can stay in sync.\n * </p>\n *\n * @param {Object} options Object with the following properties:\n * @param {String} [options.name] The glTF animation name that identifies the animation. Must be defined if <code>options.index</code> is <code>undefined</code>.\n * @param {Number} [options.index] The glTF animation index that identifies the animation. Must be defined if <code>options.name</code> is <code>undefined</code>.\n * @param {JulianDate} [options.startTime] The scene time to start playing the animation.  When this is <code>undefined</code>, the animation starts at the next frame.\n * @param {Number} [options.delay=0.0] The delay, in seconds, from <code>startTime</code> to start playing.\n * @param {JulianDate} [options.stopTime] The scene time to stop playing the animation.  When this is <code>undefined</code>, the animation is played for its full duration.\n * @param {Boolean} [options.removeOnStop=false] When <code>true</code>, the animation is removed after it stops playing.\n * @param {Number} [options.multiplier=1.0] Values greater than <code>1.0</code> increase the speed that the animation is played relative to the scene clock speed; values less than <code>1.0</code> decrease the speed.\n * @param {Boolean} [options.reverse=false] When <code>true</code>, the animation is played in reverse.\n * @param {ModelAnimationLoop} [options.loop=ModelAnimationLoop.NONE] Determines if and how the animation is looped.\n * @returns {ModelAnimation} The animation that was added to the collection.\n *\n * @exception {DeveloperError} Animations are not loaded.  Wait for the {@link Model#readyPromise} to resolve.\n * @exception {DeveloperError} options.name must be a valid animation name.\n * @exception {DeveloperError} options.index must be a valid animation index.\n * @exception {DeveloperError} Either options.name or options.index must be defined.\n * @exception {DeveloperError} options.multiplier must be greater than zero.\n *\n * @example\n * // Example 1. Add an animation by name\n * model.activeAnimations.add({\n *   name : 'animation name'\n * });\n *\n * // Example 2. Add an animation by index\n * model.activeAnimations.add({\n *   index : 0\n * });\n *\n * @example\n * // Example 3. Add an animation and provide all properties and events\n * var startTime = Cesium.JulianDate.now();\n *\n * var animation = model.activeAnimations.add({\n *   name : 'another animation name',\n *   startTime : startTime,\n *   delay : 0.0,                          // Play at startTime (default)\n *   stopTime : Cesium.JulianDate.addSeconds(startTime, 4.0, new Cesium.JulianDate()),\n *   removeOnStop : false,                 // Do not remove when animation stops (default)\n *   multiplier : 2.0,                        // Play at double speed\n *   reverse : true,                       // Play in reverse\n *   loop : Cesium.ModelAnimationLoop.REPEAT      // Loop the animation\n * });\n *\n * animation.start.addEventListener(function(model, animation) {\n *   console.log('Animation started: ' + animation.name);\n * });\n * animation.update.addEventListener(function(model, animation, time) {\n *   console.log('Animation updated: ' + animation.name + '. glTF animation time: ' + time);\n * });\n * animation.stop.addEventListener(function(model, animation) {\n *   console.log('Animation stopped: ' + animation.name);\n * });\n */\nModelAnimationCollection.prototype.add = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var model = this._model;\n  var animations = model._runtime.animations;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(animations)) {\n    throw new DeveloperError(\n      \"Animations are not loaded.  Wait for Model.readyPromise to resolve.\"\n    );\n  }\n  if (!defined(options.name) && !defined(options.index)) {\n    throw new DeveloperError(\n      \"Either options.name or options.index must be defined.\"\n    );\n  }\n\n  if (defined(options.multiplier) && options.multiplier <= 0.0) {\n    throw new DeveloperError(\"options.multiplier must be greater than zero.\");\n  }\n  if (\n    defined(options.index) &&\n    (options.index >= animations.length || options.index < 0)\n  ) {\n    throw new DeveloperError(\"options.index must be a valid animation index.\");\n  }\n  //>>includeEnd('debug');\n\n  if (defined(options.index)) {\n    return add(this, options.index, options);\n  }\n\n  // Find the index of the animation with the given name\n  var index;\n  var length = animations.length;\n  for (var i = 0; i < length; ++i) {\n    if (animations[i].name === options.name) {\n      index = i;\n      break;\n    }\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"options.name must be a valid animation name.\");\n  }\n  //>>includeEnd('debug');\n\n  return add(this, index, options);\n};\n\n/**\n * Creates and adds an animation with the specified initial properties to the collection\n * for each animation in the model.\n * <p>\n * This raises the {@link ModelAnimationCollection#animationAdded} event for each model so, for example, a UI can stay in sync.\n * </p>\n *\n * @param {Object} [options] Object with the following properties:\n * @param {JulianDate} [options.startTime] The scene time to start playing the animations.  When this is <code>undefined</code>, the animations starts at the next frame.\n * @param {Number} [options.delay=0.0] The delay, in seconds, from <code>startTime</code> to start playing.\n * @param {JulianDate} [options.stopTime] The scene time to stop playing the animations.  When this is <code>undefined</code>, the animations are played for its full duration.\n * @param {Boolean} [options.removeOnStop=false] When <code>true</code>, the animations are removed after they stop playing.\n * @param {Number} [options.multiplier=1.0] Values greater than <code>1.0</code> increase the speed that the animations play relative to the scene clock speed; values less than <code>1.0</code> decrease the speed.\n * @param {Boolean} [options.reverse=false] When <code>true</code>, the animations are played in reverse.\n * @param {ModelAnimationLoop} [options.loop=ModelAnimationLoop.NONE] Determines if and how the animations are looped.\n * @returns {ModelAnimation[]} An array of {@link ModelAnimation} objects, one for each animation added to the collection.  If there are no glTF animations, the array is empty.\n *\n * @exception {DeveloperError} Animations are not loaded.  Wait for the {@link Model#readyPromise} to resolve.\n * @exception {DeveloperError} options.multiplier must be greater than zero.\n *\n * @example\n * model.activeAnimations.addAll({\n *   multiplier : 0.5,                        // Play at half-speed\n *   loop : Cesium.ModelAnimationLoop.REPEAT      // Loop the animations\n * });\n */\nModelAnimationCollection.prototype.addAll = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(this._model._runtime.animations)) {\n    throw new DeveloperError(\n      \"Animations are not loaded.  Wait for Model.readyPromise to resolve.\"\n    );\n  }\n\n  if (defined(options.multiplier) && options.multiplier <= 0.0) {\n    throw new DeveloperError(\"options.multiplier must be greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  var scheduledAnimations = [];\n  var model = this._model;\n  var animations = model._runtime.animations;\n  var length = animations.length;\n  for (var i = 0; i < length; ++i) {\n    scheduledAnimations.push(add(this, i, options));\n  }\n  return scheduledAnimations;\n};\n\n/**\n * Removes an animation from the collection.\n * <p>\n * This raises the {@link ModelAnimationCollection#animationRemoved} event so, for example, a UI can stay in sync.\n * </p>\n * <p>\n * An animation can also be implicitly removed from the collection by setting {@link ModelAnimation#removeOnStop} to\n * <code>true</code>.  The {@link ModelAnimationCollection#animationRemoved} event is still fired when the animation is removed.\n * </p>\n *\n * @param {ModelAnimation} animation The animation to remove.\n * @returns {Boolean} <code>true</code> if the animation was removed; <code>false</code> if the animation was not found in the collection.\n *\n * @example\n * var a = model.activeAnimations.add({\n *   name : 'animation name'\n * });\n * model.activeAnimations.remove(a); // Returns true\n */\nModelAnimationCollection.prototype.remove = function (animation) {\n  if (defined(animation)) {\n    var animations = this._scheduledAnimations;\n    var i = animations.indexOf(animation);\n    if (i !== -1) {\n      animations.splice(i, 1);\n      this.animationRemoved.raiseEvent(this._model, animation);\n      return true;\n    }\n  }\n\n  return false;\n};\n\n/**\n * Removes all animations from the collection.\n * <p>\n * This raises the {@link ModelAnimationCollection#animationRemoved} event for each\n * animation so, for example, a UI can stay in sync.\n * </p>\n */\nModelAnimationCollection.prototype.removeAll = function () {\n  var model = this._model;\n  var animations = this._scheduledAnimations;\n  var length = animations.length;\n\n  this._scheduledAnimations = [];\n\n  for (var i = 0; i < length; ++i) {\n    this.animationRemoved.raiseEvent(model, animations[i]);\n  }\n};\n\n/**\n * Determines whether this collection contains a given animation.\n *\n * @param {ModelAnimation} animation The animation to check for.\n * @returns {Boolean} <code>true</code> if this collection contains the animation, <code>false</code> otherwise.\n */\nModelAnimationCollection.prototype.contains = function (animation) {\n  if (defined(animation)) {\n    return this._scheduledAnimations.indexOf(animation) !== -1;\n  }\n\n  return false;\n};\n\n/**\n * Returns the animation in the collection at the specified index.  Indices are zero-based\n * and increase as animations are added.  Removing an animation shifts all animations after\n * it to the left, changing their indices.  This function is commonly used to iterate over\n * all the animations in the collection.\n *\n * @param {Number} index The zero-based index of the animation.\n * @returns {ModelAnimation} The animation at the specified index.\n *\n * @example\n * // Output the names of all the animations in the collection.\n * var animations = model.activeAnimations;\n * var length = animations.length;\n * for (var i = 0; i < length; ++i) {\n *   console.log(animations.get(i).name);\n * }\n */\nModelAnimationCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return this._scheduledAnimations[index];\n};\n\nfunction animateChannels(runtimeAnimation, localAnimationTime) {\n  var channelEvaluators = runtimeAnimation.channelEvaluators;\n  var length = channelEvaluators.length;\n  for (var i = 0; i < length; ++i) {\n    channelEvaluators[i](localAnimationTime);\n  }\n}\n\nvar animationsToRemove = [];\n\nfunction createAnimationRemovedFunction(\n  modelAnimationCollection,\n  model,\n  animation\n) {\n  return function () {\n    modelAnimationCollection.animationRemoved.raiseEvent(model, animation);\n  };\n}\n\n/**\n * @private\n */\nModelAnimationCollection.prototype.update = function (frameState) {\n  var scheduledAnimations = this._scheduledAnimations;\n  var length = scheduledAnimations.length;\n\n  if (length === 0) {\n    // No animations - quick return for performance\n    this._previousTime = undefined;\n    return false;\n  }\n\n  if (JulianDate.equals(frameState.time, this._previousTime)) {\n    // Animations are currently only time-dependent so do not animate when paused or picking\n    return false;\n  }\n  this._previousTime = JulianDate.clone(frameState.time, this._previousTime);\n\n  var animationOccured = false;\n  var sceneTime = frameState.time;\n  var model = this._model;\n\n  for (var i = 0; i < length; ++i) {\n    var scheduledAnimation = scheduledAnimations[i];\n    var runtimeAnimation = scheduledAnimation._runtimeAnimation;\n\n    if (!defined(scheduledAnimation._computedStartTime)) {\n      scheduledAnimation._computedStartTime = JulianDate.addSeconds(\n        defaultValue(scheduledAnimation.startTime, sceneTime),\n        scheduledAnimation.delay,\n        new JulianDate()\n      );\n    }\n\n    if (!defined(scheduledAnimation._duration)) {\n      scheduledAnimation._duration =\n        runtimeAnimation.stopTime * (1.0 / scheduledAnimation.multiplier);\n    }\n\n    var startTime = scheduledAnimation._computedStartTime;\n    var duration = scheduledAnimation._duration;\n    var stopTime = scheduledAnimation.stopTime;\n\n    // [0.0, 1.0] normalized local animation time\n    var delta =\n      duration !== 0.0\n        ? JulianDate.secondsDifference(sceneTime, startTime) / duration\n        : 0.0;\n\n    // Clamp delta to stop time, if defined.\n    if (\n      duration !== 0.0 &&\n      defined(stopTime) &&\n      JulianDate.greaterThan(sceneTime, stopTime)\n    ) {\n      delta = JulianDate.secondsDifference(stopTime, startTime) / duration;\n    }\n\n    var pastStartTime = delta >= 0.0;\n\n    // Play animation if\n    // * we are after the start time or the animation is being repeated, and\n    // * before the end of the animation's duration or the animation is being repeated, and\n    // * we did not reach a user-provided stop time.\n\n    var repeat =\n      scheduledAnimation.loop === ModelAnimationLoop.REPEAT ||\n      scheduledAnimation.loop === ModelAnimationLoop.MIRRORED_REPEAT;\n\n    var play =\n      (pastStartTime || (repeat && !defined(scheduledAnimation.startTime))) &&\n      (delta <= 1.0 || repeat) &&\n      (!defined(stopTime) || JulianDate.lessThanOrEquals(sceneTime, stopTime));\n\n    // If it IS, or WAS, animating...\n    if (play || scheduledAnimation._state === ModelAnimationState.ANIMATING) {\n      // STOPPED -> ANIMATING state transition?\n      if (play && scheduledAnimation._state === ModelAnimationState.STOPPED) {\n        scheduledAnimation._state = ModelAnimationState.ANIMATING;\n        if (scheduledAnimation.start.numberOfListeners > 0) {\n          frameState.afterRender.push(scheduledAnimation._raiseStartEvent);\n        }\n      }\n\n      // Truncate to [0.0, 1.0] for repeating animations\n      if (scheduledAnimation.loop === ModelAnimationLoop.REPEAT) {\n        delta = delta - Math.floor(delta);\n      } else if (\n        scheduledAnimation.loop === ModelAnimationLoop.MIRRORED_REPEAT\n      ) {\n        var floor = Math.floor(delta);\n        var fract = delta - floor;\n        // When even use (1.0 - fract) to mirror repeat\n        delta = floor % 2 === 1.0 ? 1.0 - fract : fract;\n      }\n\n      if (scheduledAnimation.reverse) {\n        delta = 1.0 - delta;\n      }\n\n      var localAnimationTime = delta * duration * scheduledAnimation.multiplier;\n      // Clamp in case floating-point roundoff goes outside the animation's first or last keyframe\n      localAnimationTime = CesiumMath.clamp(\n        localAnimationTime,\n        runtimeAnimation.startTime,\n        runtimeAnimation.stopTime\n      );\n\n      animateChannels(runtimeAnimation, localAnimationTime);\n\n      if (scheduledAnimation.update.numberOfListeners > 0) {\n        scheduledAnimation._updateEventTime = localAnimationTime;\n        frameState.afterRender.push(scheduledAnimation._raiseUpdateEvent);\n      }\n      animationOccured = true;\n\n      if (!play) {\n        // ANIMATING -> STOPPED state transition?\n        scheduledAnimation._state = ModelAnimationState.STOPPED;\n        if (scheduledAnimation.stop.numberOfListeners > 0) {\n          frameState.afterRender.push(scheduledAnimation._raiseStopEvent);\n        }\n\n        if (scheduledAnimation.removeOnStop) {\n          animationsToRemove.push(scheduledAnimation);\n        }\n      }\n    }\n  }\n\n  // Remove animations that stopped\n  length = animationsToRemove.length;\n  for (var j = 0; j < length; ++j) {\n    var animationToRemove = animationsToRemove[j];\n    scheduledAnimations.splice(\n      scheduledAnimations.indexOf(animationToRemove),\n      1\n    );\n    frameState.afterRender.push(\n      createAnimationRemovedFunction(this, model, animationToRemove)\n    );\n  }\n  animationsToRemove.length = 0;\n\n  return animationOccured;\n};\nexport default ModelAnimationCollection;\n"]},"metadata":{},"sourceType":"module"}