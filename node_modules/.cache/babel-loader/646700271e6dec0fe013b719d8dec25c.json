{"ast":null,"code":"import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\nvar scratchCartesian1 = new Cartesian3();\nvar scratchCartesian2 = new Cartesian3();\nvar scratchCartesian3 = new Cartesian3();\n/**\n * Computes the barycentric coordinates for a point with respect to a triangle.\n *\n * @exports barycentricCoordinates\n *\n * @param {Cartesian2|Cartesian3} point The point to test.\n * @param {Cartesian2|Cartesian3} p0 The first point of the triangle, corresponding to the barycentric x-axis.\n * @param {Cartesian2|Cartesian3} p1 The second point of the triangle, corresponding to the barycentric y-axis.\n * @param {Cartesian2|Cartesian3} p2 The third point of the triangle, corresponding to the barycentric z-axis.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n *\n * @example\n * // Returns Cartesian3.UNIT_X\n * var p = new Cesium.Cartesian3(-1.0, 0.0, 0.0);\n * var b = Cesium.barycentricCoordinates(p,\n *   new Cesium.Cartesian3(-1.0, 0.0, 0.0),\n *   new Cesium.Cartesian3( 1.0, 0.0, 0.0),\n *   new Cesium.Cartesian3( 0.0, 1.0, 1.0));\n */\n\nfunction barycentricCoordinates(point, p0, p1, p2, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"point\", point);\n  Check.defined(\"p0\", p0);\n  Check.defined(\"p1\", p1);\n  Check.defined(\"p2\", p2); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  } // Implementation based on http://www.blackpawn.com/texts/pointinpoly/default.html.\n\n\n  var v0;\n  var v1;\n  var v2;\n  var dot00;\n  var dot01;\n  var dot02;\n  var dot11;\n  var dot12;\n\n  if (!defined(p0.z)) {\n    if (Cartesian2.equalsEpsilon(point, p0, CesiumMath.EPSILON14)) {\n      return Cartesian3.clone(Cartesian3.UNIT_X, result);\n    }\n\n    if (Cartesian2.equalsEpsilon(point, p1, CesiumMath.EPSILON14)) {\n      return Cartesian3.clone(Cartesian3.UNIT_Y, result);\n    }\n\n    if (Cartesian2.equalsEpsilon(point, p2, CesiumMath.EPSILON14)) {\n      return Cartesian3.clone(Cartesian3.UNIT_Z, result);\n    }\n\n    v0 = Cartesian2.subtract(p1, p0, scratchCartesian1);\n    v1 = Cartesian2.subtract(p2, p0, scratchCartesian2);\n    v2 = Cartesian2.subtract(point, p0, scratchCartesian3);\n    dot00 = Cartesian2.dot(v0, v0);\n    dot01 = Cartesian2.dot(v0, v1);\n    dot02 = Cartesian2.dot(v0, v2);\n    dot11 = Cartesian2.dot(v1, v1);\n    dot12 = Cartesian2.dot(v1, v2);\n  } else {\n    if (Cartesian3.equalsEpsilon(point, p0, CesiumMath.EPSILON14)) {\n      return Cartesian3.clone(Cartesian3.UNIT_X, result);\n    }\n\n    if (Cartesian3.equalsEpsilon(point, p1, CesiumMath.EPSILON14)) {\n      return Cartesian3.clone(Cartesian3.UNIT_Y, result);\n    }\n\n    if (Cartesian3.equalsEpsilon(point, p2, CesiumMath.EPSILON14)) {\n      return Cartesian3.clone(Cartesian3.UNIT_Z, result);\n    }\n\n    v0 = Cartesian3.subtract(p1, p0, scratchCartesian1);\n    v1 = Cartesian3.subtract(p2, p0, scratchCartesian2);\n    v2 = Cartesian3.subtract(point, p0, scratchCartesian3);\n    dot00 = Cartesian3.dot(v0, v0);\n    dot01 = Cartesian3.dot(v0, v1);\n    dot02 = Cartesian3.dot(v0, v2);\n    dot11 = Cartesian3.dot(v1, v1);\n    dot12 = Cartesian3.dot(v1, v2);\n  }\n\n  result.y = dot11 * dot02 - dot01 * dot12;\n  result.z = dot00 * dot12 - dot01 * dot02;\n  var q = dot00 * dot11 - dot01 * dot01; // This is done to avoid dividing by infinity causing a NaN\n\n  if (result.y !== 0) {\n    result.y /= q;\n  }\n\n  if (result.z !== 0) {\n    result.z /= q;\n  }\n\n  result.x = 1.0 - result.y - result.z;\n  return result;\n}\n\nexport default barycentricCoordinates;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/barycentricCoordinates.js"],"names":["Cartesian2","Cartesian3","Check","defined","CesiumMath","scratchCartesian1","scratchCartesian2","scratchCartesian3","barycentricCoordinates","point","p0","p1","p2","result","v0","v1","v2","dot00","dot01","dot02","dot11","dot12","z","equalsEpsilon","EPSILON14","clone","UNIT_X","UNIT_Y","UNIT_Z","subtract","dot","y","q","x"],"mappings":"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","sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\n\nvar scratchCartesian1 = new Cartesian3();\nvar scratchCartesian2 = new Cartesian3();\nvar scratchCartesian3 = new Cartesian3();\n\n/**\n * Computes the barycentric coordinates for a point with respect to a triangle.\n *\n * @exports barycentricCoordinates\n *\n * @param {Cartesian2|Cartesian3} point The point to test.\n * @param {Cartesian2|Cartesian3} p0 The first point of the triangle, corresponding to the barycentric x-axis.\n * @param {Cartesian2|Cartesian3} p1 The second point of the triangle, corresponding to the barycentric y-axis.\n * @param {Cartesian2|Cartesian3} p2 The third point of the triangle, corresponding to the barycentric z-axis.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n *\n * @example\n * // Returns Cartesian3.UNIT_X\n * var p = new Cesium.Cartesian3(-1.0, 0.0, 0.0);\n * var b = Cesium.barycentricCoordinates(p,\n *   new Cesium.Cartesian3(-1.0, 0.0, 0.0),\n *   new Cesium.Cartesian3( 1.0, 0.0, 0.0),\n *   new Cesium.Cartesian3( 0.0, 1.0, 1.0));\n */\nfunction barycentricCoordinates(point, p0, p1, p2, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"point\", point);\n  Check.defined(\"p0\", p0);\n  Check.defined(\"p1\", p1);\n  Check.defined(\"p2\", p2);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  // Implementation based on http://www.blackpawn.com/texts/pointinpoly/default.html.\n  var v0;\n  var v1;\n  var v2;\n  var dot00;\n  var dot01;\n  var dot02;\n  var dot11;\n  var dot12;\n\n  if (!defined(p0.z)) {\n    if (Cartesian2.equalsEpsilon(point, p0, CesiumMath.EPSILON14)) {\n      return Cartesian3.clone(Cartesian3.UNIT_X, result);\n    }\n    if (Cartesian2.equalsEpsilon(point, p1, CesiumMath.EPSILON14)) {\n      return Cartesian3.clone(Cartesian3.UNIT_Y, result);\n    }\n    if (Cartesian2.equalsEpsilon(point, p2, CesiumMath.EPSILON14)) {\n      return Cartesian3.clone(Cartesian3.UNIT_Z, result);\n    }\n\n    v0 = Cartesian2.subtract(p1, p0, scratchCartesian1);\n    v1 = Cartesian2.subtract(p2, p0, scratchCartesian2);\n    v2 = Cartesian2.subtract(point, p0, scratchCartesian3);\n\n    dot00 = Cartesian2.dot(v0, v0);\n    dot01 = Cartesian2.dot(v0, v1);\n    dot02 = Cartesian2.dot(v0, v2);\n    dot11 = Cartesian2.dot(v1, v1);\n    dot12 = Cartesian2.dot(v1, v2);\n  } else {\n    if (Cartesian3.equalsEpsilon(point, p0, CesiumMath.EPSILON14)) {\n      return Cartesian3.clone(Cartesian3.UNIT_X, result);\n    }\n    if (Cartesian3.equalsEpsilon(point, p1, CesiumMath.EPSILON14)) {\n      return Cartesian3.clone(Cartesian3.UNIT_Y, result);\n    }\n    if (Cartesian3.equalsEpsilon(point, p2, CesiumMath.EPSILON14)) {\n      return Cartesian3.clone(Cartesian3.UNIT_Z, result);\n    }\n\n    v0 = Cartesian3.subtract(p1, p0, scratchCartesian1);\n    v1 = Cartesian3.subtract(p2, p0, scratchCartesian2);\n    v2 = Cartesian3.subtract(point, p0, scratchCartesian3);\n\n    dot00 = Cartesian3.dot(v0, v0);\n    dot01 = Cartesian3.dot(v0, v1);\n    dot02 = Cartesian3.dot(v0, v2);\n    dot11 = Cartesian3.dot(v1, v1);\n    dot12 = Cartesian3.dot(v1, v2);\n  }\n\n  result.y = dot11 * dot02 - dot01 * dot12;\n  result.z = dot00 * dot12 - dot01 * dot02;\n  var q = dot00 * dot11 - dot01 * dot01;\n\n  // This is done to avoid dividing by infinity causing a NaN\n  if (result.y !== 0) {\n    result.y /= q;\n  }\n  if (result.z !== 0) {\n    result.z /= q;\n  }\n\n  result.x = 1.0 - result.y - result.z;\n  return result;\n}\nexport default barycentricCoordinates;\n"]},"metadata":{},"sourceType":"module"}