{"ast":null,"code":"import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n/**\n * A 4D Cartesian point.\n * @alias Cartesian4\n * @constructor\n *\n * @param {Number} [x=0.0] The X component.\n * @param {Number} [y=0.0] The Y component.\n * @param {Number} [z=0.0] The Z component.\n * @param {Number} [w=0.0] The W component.\n *\n * @see Cartesian2\n * @see Cartesian3\n * @see Packable\n */\n\nfunction Cartesian4(x, y, z, w) {\n  /**\n   * The X component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.x = defaultValue(x, 0.0);\n  /**\n   * The Y component.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.y = defaultValue(y, 0.0);\n  /**\n   * The Z component.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.z = defaultValue(z, 0.0);\n  /**\n   * The W component.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.w = defaultValue(w, 0.0);\n}\n/**\n * Creates a Cartesian4 instance from x, y, z and w coordinates.\n *\n * @param {Number} x The x coordinate.\n * @param {Number} y The y coordinate.\n * @param {Number} z The z coordinate.\n * @param {Number} w The w coordinate.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\n\n\nCartesian4.fromElements = function (x, y, z, w, result) {\n  if (!defined(result)) {\n    return new Cartesian4(x, y, z, w);\n  }\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n/**\n * Creates a Cartesian4 instance from a {@link Color}. <code>red</code>, <code>green</code>, <code>blue</code>,\n * and <code>alpha</code> map to <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code>, respectively.\n *\n * @param {Color} color The source color.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\n\n\nCartesian4.fromColor = function (color, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"color\", color); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartesian4(color.red, color.green, color.blue, color.alpha);\n  }\n\n  result.x = color.red;\n  result.y = color.green;\n  result.z = color.blue;\n  result.w = color.alpha;\n  return result;\n};\n/**\n * Duplicates a Cartesian4 instance.\n *\n * @param {Cartesian4} cartesian The Cartesian to duplicate.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\n\n\nCartesian4.clone = function (cartesian, result) {\n  if (!defined(cartesian)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Cartesian4(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  result.z = cartesian.z;\n  result.w = cartesian.w;\n  return result;\n};\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\n\n\nCartesian4.packedLength = 4;\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian4} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\nCartesian4.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex++] = value.z;\n  array[startingIndex] = value.w;\n  return array;\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian4} [result] The object into which to store the result.\n * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\n\n\nCartesian4.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex++];\n  result.z = array[startingIndex++];\n  result.w = array[startingIndex];\n  return result;\n};\n/**\n     * Flattens an array of Cartesian4s into and array of components.\n     *\n     * @param {Cartesian4[]} array The array of cartesians to pack.\n     * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 4 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 4) elements.\n\n     * @returns {Number[]} The packed array.\n     */\n\n\nCartesian4.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  var length = array.length;\n  var resultLength = length * 4;\n\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    throw new DeveloperError(\"If result is a typed array, it must have exactly array.length * 4 elements\");\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    Cartesian4.pack(array[i], result, i * 4);\n  }\n\n  return result;\n};\n/**\n * Unpacks an array of cartesian components into and array of Cartesian4s.\n *\n * @param {Number[]} array The array of components to unpack.\n * @param {Cartesian4[]} [result] The array onto which to store the result.\n * @returns {Cartesian4[]} The unpacked array.\n */\n\n\nCartesian4.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 4);\n\n  if (array.length % 4 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 4.\");\n  } //>>includeEnd('debug');\n\n\n  var length = array.length;\n\n  if (!defined(result)) {\n    result = new Array(length / 4);\n  } else {\n    result.length = length / 4;\n  }\n\n  for (var i = 0; i < length; i += 4) {\n    var index = i / 4;\n    result[index] = Cartesian4.unpack(array, i, result[index]);\n  }\n\n  return result;\n};\n/**\n * Creates a Cartesian4 from four consecutive elements in an array.\n * @function\n *\n * @param {Number[]} array The array whose four consecutive elements correspond to the x, y, z, and w components, respectively.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0)\n * var v = [1.0, 2.0, 3.0, 4.0];\n * var p = Cesium.Cartesian4.fromArray(v);\n *\n * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0) using an offset into an array\n * var v2 = [0.0, 0.0, 1.0, 2.0, 3.0, 4.0];\n * var p2 = Cesium.Cartesian4.fromArray(v2, 2);\n */\n\n\nCartesian4.fromArray = Cartesian4.unpack;\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The cartesian to use.\n * @returns {Number} The value of the maximum component.\n */\n\nCartesian4.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian); //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n};\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The cartesian to use.\n * @returns {Number} The value of the minimum component.\n */\n\n\nCartesian4.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian); //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n};\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian4} first A cartesian to compare.\n * @param {Cartesian4} second A cartesian to compare.\n * @param {Cartesian4} result The object into which to store the result.\n * @returns {Cartesian4} A cartesian with the minimum components.\n */\n\n\nCartesian4.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n  result.z = Math.min(first.z, second.z);\n  result.w = Math.min(first.w, second.w);\n  return result;\n};\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian4} first A cartesian to compare.\n * @param {Cartesian4} second A cartesian to compare.\n * @param {Cartesian4} result The object into which to store the result.\n * @returns {Cartesian4} A cartesian with the maximum components.\n */\n\n\nCartesian4.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  result.z = Math.max(first.z, second.z);\n  result.w = Math.max(first.w, second.w);\n  return result;\n};\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian4} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {Number} The squared magnitude.\n */\n\n\nCartesian4.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian); //>>includeEnd('debug');\n\n  return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z + cartesian.w * cartesian.w;\n};\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian4} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {Number} The magnitude.\n */\n\n\nCartesian4.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian4.magnitudeSquared(cartesian));\n};\n\nvar distanceScratch = new Cartesian4();\n/**\n * Computes the 4-space distance between two points.\n *\n * @param {Cartesian4} left The first point to compute the distance from.\n * @param {Cartesian4} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * var d = Cesium.Cartesian4.distance(\n *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\n *   new Cesium.Cartesian4(2.0, 0.0, 0.0, 0.0));\n */\n\nCartesian4.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right); //>>includeEnd('debug');\n\n  Cartesian4.subtract(left, right, distanceScratch);\n  return Cartesian4.magnitude(distanceScratch);\n};\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian4#distance}.\n *\n * @param {Cartesian4} left The first point to compute the distance from.\n * @param {Cartesian4} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * var d = Cesium.Cartesian4.distance(\n *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\n *   new Cesium.Cartesian4(3.0, 0.0, 0.0, 0.0));\n */\n\n\nCartesian4.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right); //>>includeEnd('debug');\n\n  Cartesian4.subtract(left, right, distanceScratch);\n  return Cartesian4.magnitudeSquared(distanceScratch);\n};\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian to be normalized.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\n\n\nCartesian4.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var magnitude = Cartesian4.magnitude(cartesian);\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n  result.z = cartesian.z / magnitude;\n  result.w = cartesian.w / magnitude; //>>includeStart('debug', pragmas.debug);\n\n  if (isNaN(result.x) || isNaN(result.y) || isNaN(result.z) || isNaN(result.w)) {\n    throw new DeveloperError(\"normalized result is not a number\");\n  } //>>includeEnd('debug');\n\n\n  return result;\n};\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @returns {Number} The dot product.\n */\n\n\nCartesian4.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right); //>>includeEnd('debug');\n\n  return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;\n};\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\n\n\nCartesian4.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  result.z = left.z * right.z;\n  result.w = left.w * right.w;\n  return result;\n};\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\n\n\nCartesian4.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  result.z = left.z / right.z;\n  result.w = left.w / right.w;\n  return result;\n};\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\n\n\nCartesian4.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  result.w = left.w + right.w;\n  return result;\n};\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\n\n\nCartesian4.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  result.w = left.w - right.w;\n  return result;\n};\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian4} cartesian The Cartesian to be scaled.\n * @param {Number} scalar The scalar to multiply with.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\n\n\nCartesian4.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  result.z = cartesian.z * scalar;\n  result.w = cartesian.w * scalar;\n  return result;\n};\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian4} cartesian The Cartesian to be divided.\n * @param {Number} scalar The scalar to divide by.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\n\n\nCartesian4.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  result.z = cartesian.z / scalar;\n  result.w = cartesian.w / scalar;\n  return result;\n};\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian to be negated.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\n\n\nCartesian4.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  result.z = -cartesian.z;\n  result.w = -cartesian.w;\n  return result;\n};\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\n\n\nCartesian4.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  result.z = Math.abs(cartesian.z);\n  result.w = Math.abs(cartesian.w);\n  return result;\n};\n\nvar lerpScratch = new Cartesian4();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian4} start The value corresponding to t at 0.0.\n * @param {Cartesian4}end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\n\nCartesian4.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  Cartesian4.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian4.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian4.add(lerpScratch, result, result);\n};\n\nvar mostOrthogonalAxisScratch = new Cartesian4();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The most orthogonal axis.\n */\n\nCartesian4.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var f = Cartesian4.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian4.abs(f, f);\n\n  if (f.x <= f.y) {\n    if (f.x <= f.z) {\n      if (f.x <= f.w) {\n        result = Cartesian4.clone(Cartesian4.UNIT_X, result);\n      } else {\n        result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n      }\n    } else if (f.z <= f.w) {\n      result = Cartesian4.clone(Cartesian4.UNIT_Z, result);\n    } else {\n      result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n    }\n  } else if (f.y <= f.z) {\n    if (f.y <= f.w) {\n      result = Cartesian4.clone(Cartesian4.UNIT_Y, result);\n    } else {\n      result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n    }\n  } else if (f.z <= f.w) {\n    result = Cartesian4.clone(Cartesian4.UNIT_Z, result);\n  } else {\n    result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n  }\n\n  return result;\n};\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian4} [left] The first Cartesian.\n * @param {Cartesian4} [right] The second Cartesian.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\n\n\nCartesian4.equals = function (left, right) {\n  return left === right || defined(left) && defined(right) && left.x === right.x && left.y === right.y && left.z === right.z && left.w === right.w;\n};\n/**\n * @private\n */\n\n\nCartesian4.equalsArray = function (cartesian, array, offset) {\n  return cartesian.x === array[offset] && cartesian.y === array[offset + 1] && cartesian.z === array[offset + 2] && cartesian.w === array[offset + 3];\n};\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian4} [left] The first Cartesian.\n * @param {Cartesian4} [right] The second Cartesian.\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\n\n\nCartesian4.equalsEpsilon = function (left, right, relativeEpsilon, absoluteEpsilon) {\n  return left === right || defined(left) && defined(right) && CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.z, right.z, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.w, right.w, relativeEpsilon, absoluteEpsilon);\n};\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\n\n\nCartesian4.ZERO = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 0.0));\n/**\n * An immutable Cartesian4 instance initialized to (1.0, 0.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\n\nCartesian4.UNIT_X = Object.freeze(new Cartesian4(1.0, 0.0, 0.0, 0.0));\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 1.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\n\nCartesian4.UNIT_Y = Object.freeze(new Cartesian4(0.0, 1.0, 0.0, 0.0));\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 1.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\n\nCartesian4.UNIT_Z = Object.freeze(new Cartesian4(0.0, 0.0, 1.0, 0.0));\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 1.0).\n *\n * @type {Cartesian4}\n * @constant\n */\n\nCartesian4.UNIT_W = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 1.0));\n/**\n * Duplicates this Cartesian4 instance.\n *\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\n\nCartesian4.prototype.clone = function (result) {\n  return Cartesian4.clone(this, result);\n};\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian4} [right] The right hand side Cartesian.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\n\n\nCartesian4.prototype.equals = function (right) {\n  return Cartesian4.equals(this, right);\n};\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian4} [right] The right hand side Cartesian.\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\n\n\nCartesian4.prototype.equalsEpsilon = function (right, relativeEpsilon, absoluteEpsilon) {\n  return Cartesian4.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);\n};\n/**\n * Creates a string representing this Cartesian in the format '(x, y, z, w)'.\n *\n * @returns {String} A string representing the provided Cartesian in the format '(x, y, z, w)'.\n */\n\n\nCartesian4.prototype.toString = function () {\n  return \"(\" + this.x + \", \" + this.y + \", \" + this.z + \", \" + this.w + \")\";\n};\n\nvar scratchFloatArray = new Float32Array(1);\nvar SHIFT_LEFT_8 = 256.0;\nvar SHIFT_LEFT_16 = 65536.0;\nvar SHIFT_LEFT_24 = 16777216.0;\nvar SHIFT_RIGHT_8 = 1.0 / SHIFT_LEFT_8;\nvar SHIFT_RIGHT_16 = 1.0 / SHIFT_LEFT_16;\nvar SHIFT_RIGHT_24 = 1.0 / SHIFT_LEFT_24;\nvar BIAS = 38.0;\n/**\n * Packs an arbitrary floating point value to 4 values representable using uint8.\n *\n * @param {Number} value A floating point number\n * @param {Cartesian4} [result] The Cartesian4 that will contain the packed float.\n * @returns {Cartesian4} A Cartesian4 representing the float packed to values in x, y, z, and w.\n */\n\nCartesian4.packFloat = function (value, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"value\", value); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  } // Force the value to 32 bit precision\n\n\n  scratchFloatArray[0] = value;\n  value = scratchFloatArray[0];\n\n  if (value === 0.0) {\n    return Cartesian4.clone(Cartesian4.ZERO, result);\n  }\n\n  var sign = value < 0.0 ? 1.0 : 0.0;\n  var exponent;\n\n  if (!isFinite(value)) {\n    value = 0.1;\n    exponent = BIAS;\n  } else {\n    value = Math.abs(value);\n    exponent = Math.floor(CesiumMath.logBase(value, 10)) + 1.0;\n    value = value / Math.pow(10.0, exponent);\n  }\n\n  var temp = value * SHIFT_LEFT_8;\n  result.x = Math.floor(temp);\n  temp = (temp - result.x) * SHIFT_LEFT_8;\n  result.y = Math.floor(temp);\n  temp = (temp - result.y) * SHIFT_LEFT_8;\n  result.z = Math.floor(temp);\n  result.w = (exponent + BIAS) * 2.0 + sign;\n  return result;\n};\n/**\n * Unpacks a float packed using Cartesian4.packFloat.\n *\n * @param {Cartesian4} packedFloat A Cartesian4 containing a float packed to 4 values representable using uint8.\n * @returns {Number} The unpacked float.\n * @private\n */\n\n\nCartesian4.unpackFloat = function (packedFloat) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"packedFloat\", packedFloat); //>>includeEnd('debug');\n\n  var temp = packedFloat.w / 2.0;\n  var exponent = Math.floor(temp);\n  var sign = (temp - exponent) * 2.0;\n  exponent = exponent - BIAS;\n  sign = sign * 2.0 - 1.0;\n  sign = -sign;\n\n  if (exponent >= BIAS) {\n    return sign < 0.0 ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n  }\n\n  var unpacked = sign * packedFloat.x * SHIFT_RIGHT_8;\n  unpacked += sign * packedFloat.y * SHIFT_RIGHT_16;\n  unpacked += sign * packedFloat.z * SHIFT_RIGHT_24;\n  return unpacked * Math.pow(10.0, exponent);\n};\n\nexport default Cartesian4;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/Cartesian4.js"],"names":["Check","defaultValue","defined","DeveloperError","CesiumMath","Cartesian4","x","y","z","w","fromElements","result","fromColor","color","typeOf","object","red","green","blue","alpha","clone","cartesian","undefined","packedLength","pack","value","array","startingIndex","unpack","packArray","length","resultLength","Array","isArray","i","unpackArray","number","greaterThanOrEquals","index","fromArray","maximumComponent","Math","max","minimumComponent","min","minimumByComponent","first","second","maximumByComponent","magnitudeSquared","magnitude","sqrt","distanceScratch","distance","left","right","subtract","distanceSquared","normalize","isNaN","dot","multiplyComponents","divideComponents","add","multiplyByScalar","scalar","divideByScalar","negate","abs","lerpScratch","lerp","start","end","t","mostOrthogonalAxisScratch","mostOrthogonalAxis","f","UNIT_X","UNIT_W","UNIT_Z","UNIT_Y","equals","equalsArray","offset","equalsEpsilon","relativeEpsilon","absoluteEpsilon","ZERO","Object","freeze","prototype","toString","scratchFloatArray","Float32Array","SHIFT_LEFT_8","SHIFT_LEFT_16","SHIFT_LEFT_24","SHIFT_RIGHT_8","SHIFT_RIGHT_16","SHIFT_RIGHT_24","BIAS","packFloat","sign","exponent","isFinite","floor","logBase","pow","temp","unpackFloat","packedFloat","Number","NEGATIVE_INFINITY","POSITIVE_INFINITY","unpacked"],"mappings":"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","sourcesContent":["import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A 4D Cartesian point.\n * @alias Cartesian4\n * @constructor\n *\n * @param {Number} [x=0.0] The X component.\n * @param {Number} [y=0.0] The Y component.\n * @param {Number} [z=0.0] The Z component.\n * @param {Number} [w=0.0] The W component.\n *\n * @see Cartesian2\n * @see Cartesian3\n * @see Packable\n */\nfunction Cartesian4(x, y, z, w) {\n  /**\n   * The X component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.x = defaultValue(x, 0.0);\n\n  /**\n   * The Y component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.y = defaultValue(y, 0.0);\n\n  /**\n   * The Z component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.z = defaultValue(z, 0.0);\n\n  /**\n   * The W component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.w = defaultValue(w, 0.0);\n}\n\n/**\n * Creates a Cartesian4 instance from x, y, z and w coordinates.\n *\n * @param {Number} x The x coordinate.\n * @param {Number} y The y coordinate.\n * @param {Number} z The z coordinate.\n * @param {Number} w The w coordinate.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.fromElements = function (x, y, z, w, result) {\n  if (!defined(result)) {\n    return new Cartesian4(x, y, z, w);\n  }\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Creates a Cartesian4 instance from a {@link Color}. <code>red</code>, <code>green</code>, <code>blue</code>,\n * and <code>alpha</code> map to <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code>, respectively.\n *\n * @param {Color} color The source color.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.fromColor = function (color, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"color\", color);\n  //>>includeEnd('debug');\n  if (!defined(result)) {\n    return new Cartesian4(color.red, color.green, color.blue, color.alpha);\n  }\n\n  result.x = color.red;\n  result.y = color.green;\n  result.z = color.blue;\n  result.w = color.alpha;\n  return result;\n};\n\n/**\n * Duplicates a Cartesian4 instance.\n *\n * @param {Cartesian4} cartesian The Cartesian to duplicate.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\nCartesian4.clone = function (cartesian, result) {\n  if (!defined(cartesian)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Cartesian4(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  result.z = cartesian.z;\n  result.w = cartesian.w;\n  return result;\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nCartesian4.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian4} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCartesian4.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex++] = value.z;\n  array[startingIndex] = value.w;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian4} [result] The object into which to store the result.\n * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex++];\n  result.z = array[startingIndex++];\n  result.w = array[startingIndex];\n  return result;\n};\n\n/**\n     * Flattens an array of Cartesian4s into and array of components.\n     *\n     * @param {Cartesian4[]} array The array of cartesians to pack.\n     * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 4 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 4) elements.\n\n     * @returns {Number[]} The packed array.\n     */\nCartesian4.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  var length = array.length;\n  var resultLength = length * 4;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    throw new DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 4 elements\"\n    );\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    Cartesian4.pack(array[i], result, i * 4);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of cartesian components into and array of Cartesian4s.\n *\n * @param {Number[]} array The array of components to unpack.\n * @param {Cartesian4[]} [result] The array onto which to store the result.\n * @returns {Cartesian4[]} The unpacked array.\n */\nCartesian4.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 4);\n  if (array.length % 4 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 4.\");\n  }\n  //>>includeEnd('debug');\n\n  var length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 4);\n  } else {\n    result.length = length / 4;\n  }\n\n  for (var i = 0; i < length; i += 4) {\n    var index = i / 4;\n    result[index] = Cartesian4.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Creates a Cartesian4 from four consecutive elements in an array.\n * @function\n *\n * @param {Number[]} array The array whose four consecutive elements correspond to the x, y, z, and w components, respectively.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0)\n * var v = [1.0, 2.0, 3.0, 4.0];\n * var p = Cesium.Cartesian4.fromArray(v);\n *\n * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0) using an offset into an array\n * var v2 = [0.0, 0.0, 1.0, 2.0, 3.0, 4.0];\n * var p2 = Cesium.Cartesian4.fromArray(v2, 2);\n */\nCartesian4.fromArray = Cartesian4.unpack;\n\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The cartesian to use.\n * @returns {Number} The value of the maximum component.\n */\nCartesian4.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n};\n\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The cartesian to use.\n * @returns {Number} The value of the minimum component.\n */\nCartesian4.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian4} first A cartesian to compare.\n * @param {Cartesian4} second A cartesian to compare.\n * @param {Cartesian4} result The object into which to store the result.\n * @returns {Cartesian4} A cartesian with the minimum components.\n */\nCartesian4.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n  result.z = Math.min(first.z, second.z);\n  result.w = Math.min(first.w, second.w);\n\n  return result;\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian4} first A cartesian to compare.\n * @param {Cartesian4} second A cartesian to compare.\n * @param {Cartesian4} result The object into which to store the result.\n * @returns {Cartesian4} A cartesian with the maximum components.\n */\nCartesian4.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  result.z = Math.max(first.z, second.z);\n  result.w = Math.max(first.w, second.w);\n\n  return result;\n};\n\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian4} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {Number} The squared magnitude.\n */\nCartesian4.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return (\n    cartesian.x * cartesian.x +\n    cartesian.y * cartesian.y +\n    cartesian.z * cartesian.z +\n    cartesian.w * cartesian.w\n  );\n};\n\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian4} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {Number} The magnitude.\n */\nCartesian4.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian4.magnitudeSquared(cartesian));\n};\n\nvar distanceScratch = new Cartesian4();\n\n/**\n * Computes the 4-space distance between two points.\n *\n * @param {Cartesian4} left The first point to compute the distance from.\n * @param {Cartesian4} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * var d = Cesium.Cartesian4.distance(\n *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\n *   new Cesium.Cartesian4(2.0, 0.0, 0.0, 0.0));\n */\nCartesian4.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian4.subtract(left, right, distanceScratch);\n  return Cartesian4.magnitude(distanceScratch);\n};\n\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian4#distance}.\n *\n * @param {Cartesian4} left The first point to compute the distance from.\n * @param {Cartesian4} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * var d = Cesium.Cartesian4.distance(\n *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\n *   new Cesium.Cartesian4(3.0, 0.0, 0.0, 0.0));\n */\nCartesian4.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian4.subtract(left, right, distanceScratch);\n  return Cartesian4.magnitudeSquared(distanceScratch);\n};\n\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian to be normalized.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var magnitude = Cartesian4.magnitude(cartesian);\n\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n  result.z = cartesian.z / magnitude;\n  result.w = cartesian.w / magnitude;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    isNaN(result.x) ||\n    isNaN(result.y) ||\n    isNaN(result.z) ||\n    isNaN(result.w)\n  ) {\n    throw new DeveloperError(\"normalized result is not a number\");\n  }\n  //>>includeEnd('debug');\n\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @returns {Number} The dot product.\n */\nCartesian4.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return (\n    left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w\n  );\n};\n\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  result.z = left.z * right.z;\n  result.w = left.w * right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  result.z = left.z / right.z;\n  result.w = left.w / right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  result.w = left.w + right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  result.w = left.w - right.w;\n  return result;\n};\n\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian4} cartesian The Cartesian to be scaled.\n * @param {Number} scalar The scalar to multiply with.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  result.z = cartesian.z * scalar;\n  result.w = cartesian.w * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian4} cartesian The Cartesian to be divided.\n * @param {Number} scalar The scalar to divide by.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  result.z = cartesian.z / scalar;\n  result.w = cartesian.w / scalar;\n  return result;\n};\n\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian to be negated.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  result.z = -cartesian.z;\n  result.w = -cartesian.w;\n  return result;\n};\n\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  result.z = Math.abs(cartesian.z);\n  result.w = Math.abs(cartesian.w);\n  return result;\n};\n\nvar lerpScratch = new Cartesian4();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian4} start The value corresponding to t at 0.0.\n * @param {Cartesian4}end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  Cartesian4.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian4.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian4.add(lerpScratch, result, result);\n};\n\nvar mostOrthogonalAxisScratch = new Cartesian4();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The most orthogonal axis.\n */\nCartesian4.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var f = Cartesian4.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian4.abs(f, f);\n\n  if (f.x <= f.y) {\n    if (f.x <= f.z) {\n      if (f.x <= f.w) {\n        result = Cartesian4.clone(Cartesian4.UNIT_X, result);\n      } else {\n        result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n      }\n    } else if (f.z <= f.w) {\n      result = Cartesian4.clone(Cartesian4.UNIT_Z, result);\n    } else {\n      result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n    }\n  } else if (f.y <= f.z) {\n    if (f.y <= f.w) {\n      result = Cartesian4.clone(Cartesian4.UNIT_Y, result);\n    } else {\n      result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n    }\n  } else if (f.z <= f.w) {\n    result = Cartesian4.clone(Cartesian4.UNIT_Z, result);\n  } else {\n    result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n  }\n\n  return result;\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian4} [left] The first Cartesian.\n * @param {Cartesian4} [right] The second Cartesian.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartesian4.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.x === right.x &&\n      left.y === right.y &&\n      left.z === right.z &&\n      left.w === right.w)\n  );\n};\n\n/**\n * @private\n */\nCartesian4.equalsArray = function (cartesian, array, offset) {\n  return (\n    cartesian.x === array[offset] &&\n    cartesian.y === array[offset + 1] &&\n    cartesian.z === array[offset + 2] &&\n    cartesian.w === array[offset + 3]\n  );\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian4} [left] The first Cartesian.\n * @param {Cartesian4} [right] The second Cartesian.\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian4.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      CesiumMath.equalsEpsilon(\n        left.x,\n        right.x,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.y,\n        right.y,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.z,\n        right.z,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.w,\n        right.w,\n        relativeEpsilon,\n        absoluteEpsilon\n      ))\n  );\n};\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.ZERO = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (1.0, 0.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_X = Object.freeze(new Cartesian4(1.0, 0.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 1.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_Y = Object.freeze(new Cartesian4(0.0, 1.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 1.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_Z = Object.freeze(new Cartesian4(0.0, 0.0, 1.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 1.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_W = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 1.0));\n\n/**\n * Duplicates this Cartesian4 instance.\n *\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.prototype.clone = function (result) {\n  return Cartesian4.clone(this, result);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian4} [right] The right hand side Cartesian.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nCartesian4.prototype.equals = function (right) {\n  return Cartesian4.equals(this, right);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian4} [right] The right hand side Cartesian.\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian4.prototype.equalsEpsilon = function (\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return Cartesian4.equalsEpsilon(\n    this,\n    right,\n    relativeEpsilon,\n    absoluteEpsilon\n  );\n};\n\n/**\n * Creates a string representing this Cartesian in the format '(x, y, z, w)'.\n *\n * @returns {String} A string representing the provided Cartesian in the format '(x, y, z, w)'.\n */\nCartesian4.prototype.toString = function () {\n  return \"(\" + this.x + \", \" + this.y + \", \" + this.z + \", \" + this.w + \")\";\n};\n\nvar scratchFloatArray = new Float32Array(1);\nvar SHIFT_LEFT_8 = 256.0;\nvar SHIFT_LEFT_16 = 65536.0;\nvar SHIFT_LEFT_24 = 16777216.0;\n\nvar SHIFT_RIGHT_8 = 1.0 / SHIFT_LEFT_8;\nvar SHIFT_RIGHT_16 = 1.0 / SHIFT_LEFT_16;\nvar SHIFT_RIGHT_24 = 1.0 / SHIFT_LEFT_24;\n\nvar BIAS = 38.0;\n\n/**\n * Packs an arbitrary floating point value to 4 values representable using uint8.\n *\n * @param {Number} value A floating point number\n * @param {Cartesian4} [result] The Cartesian4 that will contain the packed float.\n * @returns {Cartesian4} A Cartesian4 representing the float packed to values in x, y, z, and w.\n */\nCartesian4.packFloat = function (value, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"value\", value);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n\n  // Force the value to 32 bit precision\n  scratchFloatArray[0] = value;\n  value = scratchFloatArray[0];\n\n  if (value === 0.0) {\n    return Cartesian4.clone(Cartesian4.ZERO, result);\n  }\n\n  var sign = value < 0.0 ? 1.0 : 0.0;\n  var exponent;\n\n  if (!isFinite(value)) {\n    value = 0.1;\n    exponent = BIAS;\n  } else {\n    value = Math.abs(value);\n    exponent = Math.floor(CesiumMath.logBase(value, 10)) + 1.0;\n    value = value / Math.pow(10.0, exponent);\n  }\n\n  var temp = value * SHIFT_LEFT_8;\n  result.x = Math.floor(temp);\n  temp = (temp - result.x) * SHIFT_LEFT_8;\n  result.y = Math.floor(temp);\n  temp = (temp - result.y) * SHIFT_LEFT_8;\n  result.z = Math.floor(temp);\n  result.w = (exponent + BIAS) * 2.0 + sign;\n\n  return result;\n};\n\n/**\n * Unpacks a float packed using Cartesian4.packFloat.\n *\n * @param {Cartesian4} packedFloat A Cartesian4 containing a float packed to 4 values representable using uint8.\n * @returns {Number} The unpacked float.\n * @private\n */\nCartesian4.unpackFloat = function (packedFloat) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"packedFloat\", packedFloat);\n  //>>includeEnd('debug');\n\n  var temp = packedFloat.w / 2.0;\n  var exponent = Math.floor(temp);\n  var sign = (temp - exponent) * 2.0;\n  exponent = exponent - BIAS;\n\n  sign = sign * 2.0 - 1.0;\n  sign = -sign;\n\n  if (exponent >= BIAS) {\n    return sign < 0.0 ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n  }\n\n  var unpacked = sign * packedFloat.x * SHIFT_RIGHT_8;\n  unpacked += sign * packedFloat.y * SHIFT_RIGHT_16;\n  unpacked += sign * packedFloat.z * SHIFT_RIGHT_24;\n\n  return unpacked * Math.pow(10.0, exponent);\n};\nexport default Cartesian4;\n"]},"metadata":{},"sourceType":"module"}