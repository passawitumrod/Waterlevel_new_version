{"ast":null,"code":"import defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\n/**\n * A model's material with modifiable parameters.  A glTF material\n * contains parameters defined by the material's technique with values\n * defined by the technique and potentially overridden by the material.\n * This class allows changing these values at runtime.\n * <p>\n * Use {@link Model#getMaterial} to create an instance.\n * </p>\n *\n * @alias ModelMaterial\n * @internalConstructor\n * @class\n *\n * @see Model#getMaterial\n */\n\nfunction ModelMaterial(model, material, id) {\n  this._name = material.name;\n  this._id = id;\n  this._uniformMap = model._uniformMaps[id];\n  this._technique = undefined;\n  this._program = undefined;\n  this._values = undefined;\n}\n\nObject.defineProperties(ModelMaterial.prototype, {\n  /**\n   * The value of the <code>name</code> property of this material.\n   *\n   * @memberof ModelMaterial.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  name: {\n    get: function get() {\n      return this._name;\n    }\n  },\n\n  /**\n   * The index of the material.\n   *\n   * @memberof ModelMaterial.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  id: {\n    get: function get() {\n      return this._id;\n    }\n  }\n});\n/**\n * Assigns a value to a material parameter.  The type for <code>value</code>\n * depends on the glTF type of the parameter.  It will be a floating-point\n * number, Cartesian, or matrix.\n *\n * @param {String} name The name of the parameter.\n * @param {*} [value] The value to assign to the parameter.\n *\n * @exception {DeveloperError} name must match a parameter name in the material's technique that is targetable and not optimized out.\n *\n * @example\n * material.setValue('diffuse', new Cesium.Cartesian4(1.0, 0.0, 0.0, 1.0));  // vec4\n * material.setValue('shininess', 256.0); // scalar\n */\n\nModelMaterial.prototype.setValue = function (name, value) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(name)) {\n    throw new DeveloperError(\"name is required.\");\n  } //>>includeEnd('debug');\n\n\n  var uniformName = \"u_\" + name;\n  var v = this._uniformMap.values[uniformName]; //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(v)) {\n    throw new DeveloperError(\"name must match a parameter name in the material's technique that is targetable and not optimized out.\");\n  } //>>includeEnd('debug');\n\n\n  v.value = v.clone(value, v.value);\n};\n/**\n * Returns the value of the parameter with the given <code>name</code>.  The type of the\n * returned object depends on the glTF type of the parameter.  It will be a floating-point\n * number, Cartesian, or matrix.\n *\n * @param {String} name The name of the parameter.\n * @returns {*} The value of the parameter or <code>undefined</code> if the parameter does not exist.\n */\n\n\nModelMaterial.prototype.getValue = function (name) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(name)) {\n    throw new DeveloperError(\"name is required.\");\n  } //>>includeEnd('debug');\n\n\n  var uniformName = \"u_\" + name;\n  var v = this._uniformMap.values[uniformName];\n\n  if (!defined(v)) {\n    return undefined;\n  }\n\n  return v.value;\n};\n\nexport default ModelMaterial;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/ModelMaterial.js"],"names":["defined","DeveloperError","ModelMaterial","model","material","id","_name","name","_id","_uniformMap","_uniformMaps","_technique","undefined","_program","_values","Object","defineProperties","prototype","get","setValue","value","uniformName","v","values","clone","getValue"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,oBAApB;AACA,OAAOC,cAAP,MAA2B,2BAA3B;AAEA;;;;;;;;;;;;;;;;AAeA,SAASC,aAAT,CAAuBC,KAAvB,EAA8BC,QAA9B,EAAwCC,EAAxC,EAA4C;AAC1C,OAAKC,KAAL,GAAaF,QAAQ,CAACG,IAAtB;AACA,OAAKC,GAAL,GAAWH,EAAX;AACA,OAAKI,WAAL,GAAmBN,KAAK,CAACO,YAAN,CAAmBL,EAAnB,CAAnB;AAEA,OAAKM,UAAL,GAAkBC,SAAlB;AACA,OAAKC,QAAL,GAAgBD,SAAhB;AACA,OAAKE,OAAL,GAAeF,SAAf;AACD;;AAEDG,MAAM,CAACC,gBAAP,CAAwBd,aAAa,CAACe,SAAtC,EAAiD;AAC/C;;;;;;;;AAQAV,EAAAA,IAAI,EAAE;AACJW,IAAAA,GAAG,EAAE,eAAY;AACf,aAAO,KAAKZ,KAAZ;AACD;AAHG,GATyC;;AAe/C;;;;;;;;AAQAD,EAAAA,EAAE,EAAE;AACFa,IAAAA,GAAG,EAAE,eAAY;AACf,aAAO,KAAKV,GAAZ;AACD;AAHC;AAvB2C,CAAjD;AA8BA;;;;;;;;;;;;;;;AAcAN,aAAa,CAACe,SAAd,CAAwBE,QAAxB,GAAmC,UAAUZ,IAAV,EAAgBa,KAAhB,EAAuB;AACxD;AACA,MAAI,CAACpB,OAAO,CAACO,IAAD,CAAZ,EAAoB;AAClB,UAAM,IAAIN,cAAJ,CAAmB,mBAAnB,CAAN;AACD,GAJuD,CAKxD;;;AAEA,MAAIoB,WAAW,GAAG,OAAOd,IAAzB;AACA,MAAIe,CAAC,GAAG,KAAKb,WAAL,CAAiBc,MAAjB,CAAwBF,WAAxB,CAAR,CARwD,CAUxD;;AACA,MAAI,CAACrB,OAAO,CAACsB,CAAD,CAAZ,EAAiB;AACf,UAAM,IAAIrB,cAAJ,CACJ,wGADI,CAAN;AAGD,GAfuD,CAgBxD;;;AAEAqB,EAAAA,CAAC,CAACF,KAAF,GAAUE,CAAC,CAACE,KAAF,CAAQJ,KAAR,EAAeE,CAAC,CAACF,KAAjB,CAAV;AACD,CAnBD;AAqBA;;;;;;;;;;AAQAlB,aAAa,CAACe,SAAd,CAAwBQ,QAAxB,GAAmC,UAAUlB,IAAV,EAAgB;AACjD;AACA,MAAI,CAACP,OAAO,CAACO,IAAD,CAAZ,EAAoB;AAClB,UAAM,IAAIN,cAAJ,CAAmB,mBAAnB,CAAN;AACD,GAJgD,CAKjD;;;AAEA,MAAIoB,WAAW,GAAG,OAAOd,IAAzB;AACA,MAAIe,CAAC,GAAG,KAAKb,WAAL,CAAiBc,MAAjB,CAAwBF,WAAxB,CAAR;;AAEA,MAAI,CAACrB,OAAO,CAACsB,CAAD,CAAZ,EAAiB;AACf,WAAOV,SAAP;AACD;;AAED,SAAOU,CAAC,CAACF,KAAT;AACD,CAfD;;AAgBA,eAAelB,aAAf","sourcesContent":["import defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\n\n/**\n * A model's material with modifiable parameters.  A glTF material\n * contains parameters defined by the material's technique with values\n * defined by the technique and potentially overridden by the material.\n * This class allows changing these values at runtime.\n * <p>\n * Use {@link Model#getMaterial} to create an instance.\n * </p>\n *\n * @alias ModelMaterial\n * @internalConstructor\n * @class\n *\n * @see Model#getMaterial\n */\nfunction ModelMaterial(model, material, id) {\n  this._name = material.name;\n  this._id = id;\n  this._uniformMap = model._uniformMaps[id];\n\n  this._technique = undefined;\n  this._program = undefined;\n  this._values = undefined;\n}\n\nObject.defineProperties(ModelMaterial.prototype, {\n  /**\n   * The value of the <code>name</code> property of this material.\n   *\n   * @memberof ModelMaterial.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n\n  /**\n   * The index of the material.\n   *\n   * @memberof ModelMaterial.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n});\n\n/**\n * Assigns a value to a material parameter.  The type for <code>value</code>\n * depends on the glTF type of the parameter.  It will be a floating-point\n * number, Cartesian, or matrix.\n *\n * @param {String} name The name of the parameter.\n * @param {*} [value] The value to assign to the parameter.\n *\n * @exception {DeveloperError} name must match a parameter name in the material's technique that is targetable and not optimized out.\n *\n * @example\n * material.setValue('diffuse', new Cesium.Cartesian4(1.0, 0.0, 0.0, 1.0));  // vec4\n * material.setValue('shininess', 256.0); // scalar\n */\nModelMaterial.prototype.setValue = function (name, value) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(name)) {\n    throw new DeveloperError(\"name is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var uniformName = \"u_\" + name;\n  var v = this._uniformMap.values[uniformName];\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(v)) {\n    throw new DeveloperError(\n      \"name must match a parameter name in the material's technique that is targetable and not optimized out.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  v.value = v.clone(value, v.value);\n};\n\n/**\n * Returns the value of the parameter with the given <code>name</code>.  The type of the\n * returned object depends on the glTF type of the parameter.  It will be a floating-point\n * number, Cartesian, or matrix.\n *\n * @param {String} name The name of the parameter.\n * @returns {*} The value of the parameter or <code>undefined</code> if the parameter does not exist.\n */\nModelMaterial.prototype.getValue = function (name) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(name)) {\n    throw new DeveloperError(\"name is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var uniformName = \"u_\" + name;\n  var v = this._uniformMap.values[uniformName];\n\n  if (!defined(v)) {\n    return undefined;\n  }\n\n  return v.value;\n};\nexport default ModelMaterial;\n"]},"metadata":{},"sourceType":"module"}