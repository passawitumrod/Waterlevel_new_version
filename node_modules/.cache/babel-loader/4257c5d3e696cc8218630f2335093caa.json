{"ast":null,"code":"import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport when from \"../ThirdParty/when.js\";\nimport ImageryLayer from \"./ImageryLayer.js\";\n/**\n * An ordered collection of imagery layers.\n *\n * @alias ImageryLayerCollection\n * @constructor\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Imagery%20Adjustment.html|Cesium Sandcastle Imagery Adjustment Demo}\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Imagery%20Layers%20Manipulation.html|Cesium Sandcastle Imagery Manipulation Demo}\n */\n\nfunction ImageryLayerCollection() {\n  this._layers = [];\n  /**\n   * An event that is raised when a layer is added to the collection.  Event handlers are passed the layer that\n   * was added and the index at which it was added.\n   * @type {Event}\n   * @default Event()\n   */\n\n  this.layerAdded = new Event();\n  /**\n   * An event that is raised when a layer is removed from the collection.  Event handlers are passed the layer that\n   * was removed and the index from which it was removed.\n   * @type {Event}\n   * @default Event()\n   */\n\n  this.layerRemoved = new Event();\n  /**\n   * An event that is raised when a layer changes position in the collection.  Event handlers are passed the layer that\n   * was moved, its new index after the move, and its old index prior to the move.\n   * @type {Event}\n   * @default Event()\n   */\n\n  this.layerMoved = new Event();\n  /**\n   * An event that is raised when a layer is shown or hidden by setting the\n   * {@link ImageryLayer#show} property.  Event handlers are passed a reference to this layer,\n   * the index of the layer in the collection, and a flag that is true if the layer is now\n   * shown or false if it is now hidden.\n   *\n   * @type {Event}\n   * @default Event()\n   */\n\n  this.layerShownOrHidden = new Event();\n}\n\nObject.defineProperties(ImageryLayerCollection.prototype, {\n  /**\n   * Gets the number of layers in this collection.\n   * @memberof ImageryLayerCollection.prototype\n   * @type {Number}\n   */\n  length: {\n    get: function () {\n      return this._layers.length;\n    }\n  }\n});\n/**\n * Adds a layer to the collection.\n *\n * @param {ImageryLayer} layer the layer to add.\n * @param {Number} [index] the index to add the layer at.  If omitted, the layer will\n *                         added on top of all existing layers.\n *\n * @exception {DeveloperError} index, if supplied, must be greater than or equal to zero and less than or equal to the number of the layers.\n */\n\nImageryLayerCollection.prototype.add = function (layer, index) {\n  var hasIndex = defined(index); //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(layer)) {\n    throw new DeveloperError(\"layer is required.\");\n  }\n\n  if (hasIndex) {\n    if (index < 0) {\n      throw new DeveloperError(\"index must be greater than or equal to zero.\");\n    } else if (index > this._layers.length) {\n      throw new DeveloperError(\"index must be less than or equal to the number of layers.\");\n    }\n  } //>>includeEnd('debug');\n\n\n  if (!hasIndex) {\n    index = this._layers.length;\n\n    this._layers.push(layer);\n  } else {\n    this._layers.splice(index, 0, layer);\n  }\n\n  this._update();\n\n  this.layerAdded.raiseEvent(layer, index);\n};\n/**\n * Creates a new layer using the given ImageryProvider and adds it to the collection.\n *\n * @param {ImageryProvider} imageryProvider the imagery provider to create a new layer for.\n * @param {Number} [index] the index to add the layer at.  If omitted, the layer will\n *                         added on top of all existing layers.\n * @returns {ImageryLayer} The newly created layer.\n */\n\n\nImageryLayerCollection.prototype.addImageryProvider = function (imageryProvider, index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(imageryProvider)) {\n    throw new DeveloperError(\"imageryProvider is required.\");\n  } //>>includeEnd('debug');\n\n\n  var layer = new ImageryLayer(imageryProvider);\n  this.add(layer, index);\n  return layer;\n};\n/**\n * Removes a layer from this collection, if present.\n *\n * @param {ImageryLayer} layer The layer to remove.\n * @param {Boolean} [destroy=true] whether to destroy the layers in addition to removing them.\n * @returns {Boolean} true if the layer was in the collection and was removed,\n *                    false if the layer was not in the collection.\n */\n\n\nImageryLayerCollection.prototype.remove = function (layer, destroy) {\n  destroy = defaultValue(destroy, true);\n\n  var index = this._layers.indexOf(layer);\n\n  if (index !== -1) {\n    this._layers.splice(index, 1);\n\n    this._update();\n\n    this.layerRemoved.raiseEvent(layer, index);\n\n    if (destroy) {\n      layer.destroy();\n    }\n\n    return true;\n  }\n\n  return false;\n};\n/**\n * Removes all layers from this collection.\n *\n * @param {Boolean} [destroy=true] whether to destroy the layers in addition to removing them.\n */\n\n\nImageryLayerCollection.prototype.removeAll = function (destroy) {\n  destroy = defaultValue(destroy, true);\n  var layers = this._layers;\n\n  for (var i = 0, len = layers.length; i < len; i++) {\n    var layer = layers[i];\n    this.layerRemoved.raiseEvent(layer, i);\n\n    if (destroy) {\n      layer.destroy();\n    }\n  }\n\n  this._layers = [];\n};\n/**\n * Checks to see if the collection contains a given layer.\n *\n * @param {ImageryLayer} layer the layer to check for.\n *\n * @returns {Boolean} true if the collection contains the layer, false otherwise.\n */\n\n\nImageryLayerCollection.prototype.contains = function (layer) {\n  return this.indexOf(layer) !== -1;\n};\n/**\n * Determines the index of a given layer in the collection.\n *\n * @param {ImageryLayer} layer The layer to find the index of.\n *\n * @returns {Number} The index of the layer in the collection, or -1 if the layer does not exist in the collection.\n */\n\n\nImageryLayerCollection.prototype.indexOf = function (layer) {\n  return this._layers.indexOf(layer);\n};\n/**\n * Gets a layer by index from the collection.\n *\n * @param {Number} index the index to retrieve.\n *\n * @returns {ImageryLayer} The imagery layer at the given index.\n */\n\n\nImageryLayerCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\", \"index\");\n  } //>>includeEnd('debug');\n\n\n  return this._layers[index];\n};\n\nfunction getLayerIndex(layers, layer) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(layer)) {\n    throw new DeveloperError(\"layer is required.\");\n  } //>>includeEnd('debug');\n\n\n  var index = layers.indexOf(layer); //>>includeStart('debug', pragmas.debug);\n\n  if (index === -1) {\n    throw new DeveloperError(\"layer is not in this collection.\");\n  } //>>includeEnd('debug');\n\n\n  return index;\n}\n\nfunction swapLayers(collection, i, j) {\n  var arr = collection._layers;\n  i = CesiumMath.clamp(i, 0, arr.length - 1);\n  j = CesiumMath.clamp(j, 0, arr.length - 1);\n\n  if (i === j) {\n    return;\n  }\n\n  var temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n\n  collection._update();\n\n  collection.layerMoved.raiseEvent(temp, j, i);\n}\n/**\n * Raises a layer up one position in the collection.\n *\n * @param {ImageryLayer} layer the layer to move.\n *\n * @exception {DeveloperError} layer is not in this collection.\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\n\n\nImageryLayerCollection.prototype.raise = function (layer) {\n  var index = getLayerIndex(this._layers, layer);\n  swapLayers(this, index, index + 1);\n};\n/**\n * Lowers a layer down one position in the collection.\n *\n * @param {ImageryLayer} layer the layer to move.\n *\n * @exception {DeveloperError} layer is not in this collection.\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\n\n\nImageryLayerCollection.prototype.lower = function (layer) {\n  var index = getLayerIndex(this._layers, layer);\n  swapLayers(this, index, index - 1);\n};\n/**\n * Raises a layer to the top of the collection.\n *\n * @param {ImageryLayer} layer the layer to move.\n *\n * @exception {DeveloperError} layer is not in this collection.\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\n\n\nImageryLayerCollection.prototype.raiseToTop = function (layer) {\n  var index = getLayerIndex(this._layers, layer);\n\n  if (index === this._layers.length - 1) {\n    return;\n  }\n\n  this._layers.splice(index, 1);\n\n  this._layers.push(layer);\n\n  this._update();\n\n  this.layerMoved.raiseEvent(layer, this._layers.length - 1, index);\n};\n/**\n * Lowers a layer to the bottom of the collection.\n *\n * @param {ImageryLayer} layer the layer to move.\n *\n * @exception {DeveloperError} layer is not in this collection.\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\n\n\nImageryLayerCollection.prototype.lowerToBottom = function (layer) {\n  var index = getLayerIndex(this._layers, layer);\n\n  if (index === 0) {\n    return;\n  }\n\n  this._layers.splice(index, 1);\n\n  this._layers.splice(0, 0, layer);\n\n  this._update();\n\n  this.layerMoved.raiseEvent(layer, 0, index);\n};\n\nvar applicableRectangleScratch = new Rectangle();\n/**\n * Asynchronously determines the imagery layer features that are intersected by a pick ray.  The intersected imagery\n * layer features are found by invoking {@link ImageryProvider#pickFeatures} for each imagery layer tile intersected\n * by the pick ray.  To compute a pick ray from a location on the screen, use {@link Camera.getPickRay}.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {Scene} scene The scene.\n * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise that resolves to an array of features intersected by the pick ray.\n *                                             If it can be quickly determined that no features are intersected (for example,\n *                                             because no active imagery providers support {@link ImageryProvider#pickFeatures}\n *                                             or because the pick ray does not intersect the surface), this function will\n *                                             return undefined.\n *\n * @example\n * var pickRay = viewer.camera.getPickRay(windowPosition);\n * var featuresPromise = viewer.imageryLayers.pickImageryLayerFeatures(pickRay, viewer.scene);\n * if (!Cesium.defined(featuresPromise)) {\n *     console.log('No features picked.');\n * } else {\n *     Cesium.when(featuresPromise, function(features) {\n *         // This function is called asynchronously when the list if picked features is available.\n *         console.log('Number of features: ' + features.length);\n *         if (features.length > 0) {\n *             console.log('First feature name: ' + features[0].name);\n *         }\n *     });\n * }\n */\n\nImageryLayerCollection.prototype.pickImageryLayerFeatures = function (ray, scene) {\n  // Find the picked location on the globe.\n  var pickedPosition = scene.globe.pick(ray, scene);\n\n  if (!defined(pickedPosition)) {\n    return undefined;\n  }\n\n  var pickedLocation = scene.globe.ellipsoid.cartesianToCartographic(pickedPosition); // Find the terrain tile containing the picked location.\n\n  var tilesToRender = scene.globe._surface._tilesToRender;\n  var pickedTile;\n\n  for (var textureIndex = 0; !defined(pickedTile) && textureIndex < tilesToRender.length; ++textureIndex) {\n    var tile = tilesToRender[textureIndex];\n\n    if (Rectangle.contains(tile.rectangle, pickedLocation)) {\n      pickedTile = tile;\n    }\n  }\n\n  if (!defined(pickedTile)) {\n    return undefined;\n  } // Pick against all attached imagery tiles containing the pickedLocation.\n\n\n  var imageryTiles = pickedTile.data.imagery;\n  var promises = [];\n  var imageryLayers = [];\n\n  for (var i = imageryTiles.length - 1; i >= 0; --i) {\n    var terrainImagery = imageryTiles[i];\n    var imagery = terrainImagery.readyImagery;\n\n    if (!defined(imagery)) {\n      continue;\n    }\n\n    var provider = imagery.imageryLayer.imageryProvider;\n\n    if (!defined(provider.pickFeatures)) {\n      continue;\n    }\n\n    if (!Rectangle.contains(imagery.rectangle, pickedLocation)) {\n      continue;\n    } // If this imagery came from a parent, it may not be applicable to its entire rectangle.\n    // Check the textureCoordinateRectangle.\n\n\n    var applicableRectangle = applicableRectangleScratch;\n    var epsilon = 1 / 1024; // 1/4 of a pixel in a typical 256x256 tile.\n\n    applicableRectangle.west = CesiumMath.lerp(pickedTile.rectangle.west, pickedTile.rectangle.east, terrainImagery.textureCoordinateRectangle.x - epsilon);\n    applicableRectangle.east = CesiumMath.lerp(pickedTile.rectangle.west, pickedTile.rectangle.east, terrainImagery.textureCoordinateRectangle.z + epsilon);\n    applicableRectangle.south = CesiumMath.lerp(pickedTile.rectangle.south, pickedTile.rectangle.north, terrainImagery.textureCoordinateRectangle.y - epsilon);\n    applicableRectangle.north = CesiumMath.lerp(pickedTile.rectangle.south, pickedTile.rectangle.north, terrainImagery.textureCoordinateRectangle.w + epsilon);\n\n    if (!Rectangle.contains(applicableRectangle, pickedLocation)) {\n      continue;\n    }\n\n    var promise = provider.pickFeatures(imagery.x, imagery.y, imagery.level, pickedLocation.longitude, pickedLocation.latitude);\n\n    if (!defined(promise)) {\n      continue;\n    }\n\n    promises.push(promise);\n    imageryLayers.push(imagery.imageryLayer);\n  }\n\n  if (promises.length === 0) {\n    return undefined;\n  }\n\n  return when.all(promises, function (results) {\n    var features = [];\n\n    for (var resultIndex = 0; resultIndex < results.length; ++resultIndex) {\n      var result = results[resultIndex];\n      var image = imageryLayers[resultIndex];\n\n      if (defined(result) && result.length > 0) {\n        for (var featureIndex = 0; featureIndex < result.length; ++featureIndex) {\n          var feature = result[featureIndex];\n          feature.imageryLayer = image; // For features without a position, use the picked location.\n\n          if (!defined(feature.position)) {\n            feature.position = pickedLocation;\n          }\n\n          features.push(feature);\n        }\n      }\n    }\n\n    return features;\n  });\n};\n/**\n * Updates frame state to execute any queued texture re-projections.\n *\n * @private\n *\n * @param {FrameState} frameState The frameState.\n */\n\n\nImageryLayerCollection.prototype.queueReprojectionCommands = function (frameState) {\n  var layers = this._layers;\n\n  for (var i = 0, len = layers.length; i < len; ++i) {\n    layers[i].queueReprojectionCommands(frameState);\n  }\n};\n/**\n * Cancels re-projection commands queued for the next frame.\n *\n * @private\n */\n\n\nImageryLayerCollection.prototype.cancelReprojections = function () {\n  var layers = this._layers;\n\n  for (var i = 0, len = layers.length; i < len; ++i) {\n    layers[i].cancelReprojections();\n  }\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} true if this object was destroyed; otherwise, false.\n *\n * @see ImageryLayerCollection#destroy\n */\n\n\nImageryLayerCollection.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by all layers in this collection.  Explicitly destroying this\n * object allows for deterministic release of WebGL resources, instead of relying on the garbage\n * collector.\n * <br /><br />\n * Once this object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * layerCollection = layerCollection && layerCollection.destroy();\n *\n * @see ImageryLayerCollection#isDestroyed\n */\n\n\nImageryLayerCollection.prototype.destroy = function () {\n  this.removeAll(true);\n  return destroyObject(this);\n};\n\nImageryLayerCollection.prototype._update = function () {\n  var isBaseLayer = true;\n  var layers = this._layers;\n  var layersShownOrHidden;\n  var layer;\n  var i, len;\n\n  for (i = 0, len = layers.length; i < len; ++i) {\n    layer = layers[i];\n    layer._layerIndex = i;\n\n    if (layer.show) {\n      layer._isBaseLayer = isBaseLayer;\n      isBaseLayer = false;\n    } else {\n      layer._isBaseLayer = false;\n    }\n\n    if (layer.show !== layer._show) {\n      if (defined(layer._show)) {\n        if (!defined(layersShownOrHidden)) {\n          layersShownOrHidden = [];\n        }\n\n        layersShownOrHidden.push(layer);\n      }\n\n      layer._show = layer.show;\n    }\n  }\n\n  if (defined(layersShownOrHidden)) {\n    for (i = 0, len = layersShownOrHidden.length; i < len; ++i) {\n      layer = layersShownOrHidden[i];\n      this.layerShownOrHidden.raiseEvent(layer, layer._layerIndex, layer.show);\n    }\n  }\n};\n\nexport default ImageryLayerCollection;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/ImageryLayerCollection.js"],"names":["defaultValue","defined","destroyObject","DeveloperError","Event","CesiumMath","Rectangle","when","ImageryLayer","ImageryLayerCollection","_layers","layerAdded","layerRemoved","layerMoved","layerShownOrHidden","Object","defineProperties","prototype","length","get","add","layer","index","hasIndex","push","splice","_update","raiseEvent","addImageryProvider","imageryProvider","remove","destroy","indexOf","removeAll","layers","i","len","contains","getLayerIndex","swapLayers","collection","j","arr","clamp","temp","raise","lower","raiseToTop","lowerToBottom","applicableRectangleScratch","pickImageryLayerFeatures","ray","scene","pickedPosition","globe","pick","undefined","pickedLocation","ellipsoid","cartesianToCartographic","tilesToRender","_surface","_tilesToRender","pickedTile","textureIndex","tile","rectangle","imageryTiles","data","imagery","promises","imageryLayers","terrainImagery","readyImagery","provider","imageryLayer","pickFeatures","applicableRectangle","epsilon","west","lerp","east","textureCoordinateRectangle","x","z","south","north","y","w","promise","level","longitude","latitude","all","results","features","resultIndex","result","image","featureIndex","feature","position","queueReprojectionCommands","frameState","cancelReprojections","isDestroyed","isBaseLayer","layersShownOrHidden","_layerIndex","show","_isBaseLayer","_show"],"mappings":"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","sourcesContent":["import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport when from \"../ThirdParty/when.js\";\nimport ImageryLayer from \"./ImageryLayer.js\";\n\n/**\n * An ordered collection of imagery layers.\n *\n * @alias ImageryLayerCollection\n * @constructor\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Imagery%20Adjustment.html|Cesium Sandcastle Imagery Adjustment Demo}\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Imagery%20Layers%20Manipulation.html|Cesium Sandcastle Imagery Manipulation Demo}\n */\nfunction ImageryLayerCollection() {\n  this._layers = [];\n\n  /**\n   * An event that is raised when a layer is added to the collection.  Event handlers are passed the layer that\n   * was added and the index at which it was added.\n   * @type {Event}\n   * @default Event()\n   */\n  this.layerAdded = new Event();\n\n  /**\n   * An event that is raised when a layer is removed from the collection.  Event handlers are passed the layer that\n   * was removed and the index from which it was removed.\n   * @type {Event}\n   * @default Event()\n   */\n  this.layerRemoved = new Event();\n\n  /**\n   * An event that is raised when a layer changes position in the collection.  Event handlers are passed the layer that\n   * was moved, its new index after the move, and its old index prior to the move.\n   * @type {Event}\n   * @default Event()\n   */\n  this.layerMoved = new Event();\n\n  /**\n   * An event that is raised when a layer is shown or hidden by setting the\n   * {@link ImageryLayer#show} property.  Event handlers are passed a reference to this layer,\n   * the index of the layer in the collection, and a flag that is true if the layer is now\n   * shown or false if it is now hidden.\n   *\n   * @type {Event}\n   * @default Event()\n   */\n  this.layerShownOrHidden = new Event();\n}\n\nObject.defineProperties(ImageryLayerCollection.prototype, {\n  /**\n   * Gets the number of layers in this collection.\n   * @memberof ImageryLayerCollection.prototype\n   * @type {Number}\n   */\n  length: {\n    get: function () {\n      return this._layers.length;\n    },\n  },\n});\n\n/**\n * Adds a layer to the collection.\n *\n * @param {ImageryLayer} layer the layer to add.\n * @param {Number} [index] the index to add the layer at.  If omitted, the layer will\n *                         added on top of all existing layers.\n *\n * @exception {DeveloperError} index, if supplied, must be greater than or equal to zero and less than or equal to the number of the layers.\n */\nImageryLayerCollection.prototype.add = function (layer, index) {\n  var hasIndex = defined(index);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(layer)) {\n    throw new DeveloperError(\"layer is required.\");\n  }\n  if (hasIndex) {\n    if (index < 0) {\n      throw new DeveloperError(\"index must be greater than or equal to zero.\");\n    } else if (index > this._layers.length) {\n      throw new DeveloperError(\n        \"index must be less than or equal to the number of layers.\"\n      );\n    }\n  }\n  //>>includeEnd('debug');\n\n  if (!hasIndex) {\n    index = this._layers.length;\n    this._layers.push(layer);\n  } else {\n    this._layers.splice(index, 0, layer);\n  }\n\n  this._update();\n  this.layerAdded.raiseEvent(layer, index);\n};\n\n/**\n * Creates a new layer using the given ImageryProvider and adds it to the collection.\n *\n * @param {ImageryProvider} imageryProvider the imagery provider to create a new layer for.\n * @param {Number} [index] the index to add the layer at.  If omitted, the layer will\n *                         added on top of all existing layers.\n * @returns {ImageryLayer} The newly created layer.\n */\nImageryLayerCollection.prototype.addImageryProvider = function (\n  imageryProvider,\n  index\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(imageryProvider)) {\n    throw new DeveloperError(\"imageryProvider is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var layer = new ImageryLayer(imageryProvider);\n  this.add(layer, index);\n  return layer;\n};\n\n/**\n * Removes a layer from this collection, if present.\n *\n * @param {ImageryLayer} layer The layer to remove.\n * @param {Boolean} [destroy=true] whether to destroy the layers in addition to removing them.\n * @returns {Boolean} true if the layer was in the collection and was removed,\n *                    false if the layer was not in the collection.\n */\nImageryLayerCollection.prototype.remove = function (layer, destroy) {\n  destroy = defaultValue(destroy, true);\n\n  var index = this._layers.indexOf(layer);\n  if (index !== -1) {\n    this._layers.splice(index, 1);\n\n    this._update();\n\n    this.layerRemoved.raiseEvent(layer, index);\n\n    if (destroy) {\n      layer.destroy();\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Removes all layers from this collection.\n *\n * @param {Boolean} [destroy=true] whether to destroy the layers in addition to removing them.\n */\nImageryLayerCollection.prototype.removeAll = function (destroy) {\n  destroy = defaultValue(destroy, true);\n\n  var layers = this._layers;\n  for (var i = 0, len = layers.length; i < len; i++) {\n    var layer = layers[i];\n    this.layerRemoved.raiseEvent(layer, i);\n\n    if (destroy) {\n      layer.destroy();\n    }\n  }\n\n  this._layers = [];\n};\n\n/**\n * Checks to see if the collection contains a given layer.\n *\n * @param {ImageryLayer} layer the layer to check for.\n *\n * @returns {Boolean} true if the collection contains the layer, false otherwise.\n */\nImageryLayerCollection.prototype.contains = function (layer) {\n  return this.indexOf(layer) !== -1;\n};\n\n/**\n * Determines the index of a given layer in the collection.\n *\n * @param {ImageryLayer} layer The layer to find the index of.\n *\n * @returns {Number} The index of the layer in the collection, or -1 if the layer does not exist in the collection.\n */\nImageryLayerCollection.prototype.indexOf = function (layer) {\n  return this._layers.indexOf(layer);\n};\n\n/**\n * Gets a layer by index from the collection.\n *\n * @param {Number} index the index to retrieve.\n *\n * @returns {ImageryLayer} The imagery layer at the given index.\n */\nImageryLayerCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\", \"index\");\n  }\n  //>>includeEnd('debug');\n\n  return this._layers[index];\n};\n\nfunction getLayerIndex(layers, layer) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(layer)) {\n    throw new DeveloperError(\"layer is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var index = layers.indexOf(layer);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (index === -1) {\n    throw new DeveloperError(\"layer is not in this collection.\");\n  }\n  //>>includeEnd('debug');\n\n  return index;\n}\n\nfunction swapLayers(collection, i, j) {\n  var arr = collection._layers;\n  i = CesiumMath.clamp(i, 0, arr.length - 1);\n  j = CesiumMath.clamp(j, 0, arr.length - 1);\n\n  if (i === j) {\n    return;\n  }\n\n  var temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n\n  collection._update();\n\n  collection.layerMoved.raiseEvent(temp, j, i);\n}\n\n/**\n * Raises a layer up one position in the collection.\n *\n * @param {ImageryLayer} layer the layer to move.\n *\n * @exception {DeveloperError} layer is not in this collection.\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nImageryLayerCollection.prototype.raise = function (layer) {\n  var index = getLayerIndex(this._layers, layer);\n  swapLayers(this, index, index + 1);\n};\n\n/**\n * Lowers a layer down one position in the collection.\n *\n * @param {ImageryLayer} layer the layer to move.\n *\n * @exception {DeveloperError} layer is not in this collection.\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nImageryLayerCollection.prototype.lower = function (layer) {\n  var index = getLayerIndex(this._layers, layer);\n  swapLayers(this, index, index - 1);\n};\n\n/**\n * Raises a layer to the top of the collection.\n *\n * @param {ImageryLayer} layer the layer to move.\n *\n * @exception {DeveloperError} layer is not in this collection.\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nImageryLayerCollection.prototype.raiseToTop = function (layer) {\n  var index = getLayerIndex(this._layers, layer);\n  if (index === this._layers.length - 1) {\n    return;\n  }\n  this._layers.splice(index, 1);\n  this._layers.push(layer);\n\n  this._update();\n\n  this.layerMoved.raiseEvent(layer, this._layers.length - 1, index);\n};\n\n/**\n * Lowers a layer to the bottom of the collection.\n *\n * @param {ImageryLayer} layer the layer to move.\n *\n * @exception {DeveloperError} layer is not in this collection.\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nImageryLayerCollection.prototype.lowerToBottom = function (layer) {\n  var index = getLayerIndex(this._layers, layer);\n  if (index === 0) {\n    return;\n  }\n  this._layers.splice(index, 1);\n  this._layers.splice(0, 0, layer);\n\n  this._update();\n\n  this.layerMoved.raiseEvent(layer, 0, index);\n};\n\nvar applicableRectangleScratch = new Rectangle();\n\n/**\n * Asynchronously determines the imagery layer features that are intersected by a pick ray.  The intersected imagery\n * layer features are found by invoking {@link ImageryProvider#pickFeatures} for each imagery layer tile intersected\n * by the pick ray.  To compute a pick ray from a location on the screen, use {@link Camera.getPickRay}.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {Scene} scene The scene.\n * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise that resolves to an array of features intersected by the pick ray.\n *                                             If it can be quickly determined that no features are intersected (for example,\n *                                             because no active imagery providers support {@link ImageryProvider#pickFeatures}\n *                                             or because the pick ray does not intersect the surface), this function will\n *                                             return undefined.\n *\n * @example\n * var pickRay = viewer.camera.getPickRay(windowPosition);\n * var featuresPromise = viewer.imageryLayers.pickImageryLayerFeatures(pickRay, viewer.scene);\n * if (!Cesium.defined(featuresPromise)) {\n *     console.log('No features picked.');\n * } else {\n *     Cesium.when(featuresPromise, function(features) {\n *         // This function is called asynchronously when the list if picked features is available.\n *         console.log('Number of features: ' + features.length);\n *         if (features.length > 0) {\n *             console.log('First feature name: ' + features[0].name);\n *         }\n *     });\n * }\n */\nImageryLayerCollection.prototype.pickImageryLayerFeatures = function (\n  ray,\n  scene\n) {\n  // Find the picked location on the globe.\n  var pickedPosition = scene.globe.pick(ray, scene);\n  if (!defined(pickedPosition)) {\n    return undefined;\n  }\n\n  var pickedLocation = scene.globe.ellipsoid.cartesianToCartographic(\n    pickedPosition\n  );\n\n  // Find the terrain tile containing the picked location.\n  var tilesToRender = scene.globe._surface._tilesToRender;\n  var pickedTile;\n\n  for (\n    var textureIndex = 0;\n    !defined(pickedTile) && textureIndex < tilesToRender.length;\n    ++textureIndex\n  ) {\n    var tile = tilesToRender[textureIndex];\n    if (Rectangle.contains(tile.rectangle, pickedLocation)) {\n      pickedTile = tile;\n    }\n  }\n\n  if (!defined(pickedTile)) {\n    return undefined;\n  }\n\n  // Pick against all attached imagery tiles containing the pickedLocation.\n  var imageryTiles = pickedTile.data.imagery;\n\n  var promises = [];\n  var imageryLayers = [];\n  for (var i = imageryTiles.length - 1; i >= 0; --i) {\n    var terrainImagery = imageryTiles[i];\n    var imagery = terrainImagery.readyImagery;\n    if (!defined(imagery)) {\n      continue;\n    }\n    var provider = imagery.imageryLayer.imageryProvider;\n    if (!defined(provider.pickFeatures)) {\n      continue;\n    }\n\n    if (!Rectangle.contains(imagery.rectangle, pickedLocation)) {\n      continue;\n    }\n\n    // If this imagery came from a parent, it may not be applicable to its entire rectangle.\n    // Check the textureCoordinateRectangle.\n    var applicableRectangle = applicableRectangleScratch;\n\n    var epsilon = 1 / 1024; // 1/4 of a pixel in a typical 256x256 tile.\n    applicableRectangle.west = CesiumMath.lerp(\n      pickedTile.rectangle.west,\n      pickedTile.rectangle.east,\n      terrainImagery.textureCoordinateRectangle.x - epsilon\n    );\n    applicableRectangle.east = CesiumMath.lerp(\n      pickedTile.rectangle.west,\n      pickedTile.rectangle.east,\n      terrainImagery.textureCoordinateRectangle.z + epsilon\n    );\n    applicableRectangle.south = CesiumMath.lerp(\n      pickedTile.rectangle.south,\n      pickedTile.rectangle.north,\n      terrainImagery.textureCoordinateRectangle.y - epsilon\n    );\n    applicableRectangle.north = CesiumMath.lerp(\n      pickedTile.rectangle.south,\n      pickedTile.rectangle.north,\n      terrainImagery.textureCoordinateRectangle.w + epsilon\n    );\n    if (!Rectangle.contains(applicableRectangle, pickedLocation)) {\n      continue;\n    }\n\n    var promise = provider.pickFeatures(\n      imagery.x,\n      imagery.y,\n      imagery.level,\n      pickedLocation.longitude,\n      pickedLocation.latitude\n    );\n    if (!defined(promise)) {\n      continue;\n    }\n\n    promises.push(promise);\n    imageryLayers.push(imagery.imageryLayer);\n  }\n\n  if (promises.length === 0) {\n    return undefined;\n  }\n\n  return when.all(promises, function (results) {\n    var features = [];\n\n    for (var resultIndex = 0; resultIndex < results.length; ++resultIndex) {\n      var result = results[resultIndex];\n      var image = imageryLayers[resultIndex];\n\n      if (defined(result) && result.length > 0) {\n        for (\n          var featureIndex = 0;\n          featureIndex < result.length;\n          ++featureIndex\n        ) {\n          var feature = result[featureIndex];\n          feature.imageryLayer = image;\n\n          // For features without a position, use the picked location.\n          if (!defined(feature.position)) {\n            feature.position = pickedLocation;\n          }\n\n          features.push(feature);\n        }\n      }\n    }\n\n    return features;\n  });\n};\n\n/**\n * Updates frame state to execute any queued texture re-projections.\n *\n * @private\n *\n * @param {FrameState} frameState The frameState.\n */\nImageryLayerCollection.prototype.queueReprojectionCommands = function (\n  frameState\n) {\n  var layers = this._layers;\n  for (var i = 0, len = layers.length; i < len; ++i) {\n    layers[i].queueReprojectionCommands(frameState);\n  }\n};\n\n/**\n * Cancels re-projection commands queued for the next frame.\n *\n * @private\n */\nImageryLayerCollection.prototype.cancelReprojections = function () {\n  var layers = this._layers;\n  for (var i = 0, len = layers.length; i < len; ++i) {\n    layers[i].cancelReprojections();\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} true if this object was destroyed; otherwise, false.\n *\n * @see ImageryLayerCollection#destroy\n */\nImageryLayerCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by all layers in this collection.  Explicitly destroying this\n * object allows for deterministic release of WebGL resources, instead of relying on the garbage\n * collector.\n * <br /><br />\n * Once this object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * layerCollection = layerCollection && layerCollection.destroy();\n *\n * @see ImageryLayerCollection#isDestroyed\n */\nImageryLayerCollection.prototype.destroy = function () {\n  this.removeAll(true);\n  return destroyObject(this);\n};\n\nImageryLayerCollection.prototype._update = function () {\n  var isBaseLayer = true;\n  var layers = this._layers;\n  var layersShownOrHidden;\n  var layer;\n  var i, len;\n  for (i = 0, len = layers.length; i < len; ++i) {\n    layer = layers[i];\n\n    layer._layerIndex = i;\n\n    if (layer.show) {\n      layer._isBaseLayer = isBaseLayer;\n      isBaseLayer = false;\n    } else {\n      layer._isBaseLayer = false;\n    }\n\n    if (layer.show !== layer._show) {\n      if (defined(layer._show)) {\n        if (!defined(layersShownOrHidden)) {\n          layersShownOrHidden = [];\n        }\n        layersShownOrHidden.push(layer);\n      }\n      layer._show = layer.show;\n    }\n  }\n\n  if (defined(layersShownOrHidden)) {\n    for (i = 0, len = layersShownOrHidden.length; i < len; ++i) {\n      layer = layersShownOrHidden[i];\n      this.layerShownOrHidden.raiseEvent(layer, layer._layerIndex, layer.show);\n    }\n  }\n};\nexport default ImageryLayerCollection;\n"]},"metadata":{},"sourceType":"module"}