{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Intersect from \"./Intersect.js\";\nimport Plane from \"./Plane.js\";\n/**\n * The culling volume defined by planes.\n *\n * @alias CullingVolume\n * @constructor\n *\n * @param {Cartesian4[]} [planes] An array of clipping planes.\n */\n\nfunction CullingVolume(planes) {\n  /**\n   * Each plane is represented by a Cartesian4 object, where the x, y, and z components\n   * define the unit vector normal to the plane, and the w component is the distance of the\n   * plane from the origin.\n   * @type {Cartesian4[]}\n   * @default []\n   */\n  this.planes = defaultValue(planes, []);\n}\n\nvar faces = [new Cartesian3(), new Cartesian3(), new Cartesian3()];\nCartesian3.clone(Cartesian3.UNIT_X, faces[0]);\nCartesian3.clone(Cartesian3.UNIT_Y, faces[1]);\nCartesian3.clone(Cartesian3.UNIT_Z, faces[2]);\nvar scratchPlaneCenter = new Cartesian3();\nvar scratchPlaneNormal = new Cartesian3();\nvar scratchPlane = new Plane(new Cartesian3(1.0, 0.0, 0.0), 0.0);\n/**\n * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.\n * The planes are aligned to the x, y, and z axes in world coordinates.\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere used to create the culling volume.\n * @param {CullingVolume} [result] The object onto which to store the result.\n * @returns {CullingVolume} The culling volume created from the bounding sphere.\n */\n\nCullingVolume.fromBoundingSphere = function (boundingSphere, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(result)) {\n    result = new CullingVolume();\n  }\n\n  var length = faces.length;\n  var planes = result.planes;\n  planes.length = 2 * length;\n  var center = boundingSphere.center;\n  var radius = boundingSphere.radius;\n  var planeIndex = 0;\n\n  for (var i = 0; i < length; ++i) {\n    var faceNormal = faces[i];\n    var plane0 = planes[planeIndex];\n    var plane1 = planes[planeIndex + 1];\n\n    if (!defined(plane0)) {\n      plane0 = planes[planeIndex] = new Cartesian4();\n    }\n\n    if (!defined(plane1)) {\n      plane1 = planes[planeIndex + 1] = new Cartesian4();\n    }\n\n    Cartesian3.multiplyByScalar(faceNormal, -radius, scratchPlaneCenter);\n    Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);\n    plane0.x = faceNormal.x;\n    plane0.y = faceNormal.y;\n    plane0.z = faceNormal.z;\n    plane0.w = -Cartesian3.dot(faceNormal, scratchPlaneCenter);\n    Cartesian3.multiplyByScalar(faceNormal, radius, scratchPlaneCenter);\n    Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);\n    plane1.x = -faceNormal.x;\n    plane1.y = -faceNormal.y;\n    plane1.z = -faceNormal.z;\n    plane1.w = -Cartesian3.dot(Cartesian3.negate(faceNormal, scratchPlaneNormal), scratchPlaneCenter);\n    planeIndex += 2;\n  }\n\n  return result;\n};\n/**\n * Determines whether a bounding volume intersects the culling volume.\n *\n * @param {Object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.\n * @returns {Intersect}  Intersect.OUTSIDE, Intersect.INTERSECTING, or Intersect.INSIDE.\n */\n\n\nCullingVolume.prototype.computeVisibility = function (boundingVolume) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingVolume)) {\n    throw new DeveloperError(\"boundingVolume is required.\");\n  } //>>includeEnd('debug');\n\n\n  var planes = this.planes;\n  var intersecting = false;\n\n  for (var k = 0, len = planes.length; k < len; ++k) {\n    var result = boundingVolume.intersectPlane(Plane.fromCartesian4(planes[k], scratchPlane));\n\n    if (result === Intersect.OUTSIDE) {\n      return Intersect.OUTSIDE;\n    } else if (result === Intersect.INTERSECTING) {\n      intersecting = true;\n    }\n  }\n\n  return intersecting ? Intersect.INTERSECTING : Intersect.INSIDE;\n};\n/**\n * Determines whether a bounding volume intersects the culling volume.\n *\n * @param {Object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.\n * @param {Number} parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling\n *                                 volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then\n *                                 the parent (and therefore this) volume is completely inside plane[planeIndex]\n *                                 and that plane check can be skipped.\n * @returns {Number} A plane mask as described above (which can be applied to this boundingVolume's children).\n *\n * @private\n */\n\n\nCullingVolume.prototype.computeVisibilityWithPlaneMask = function (boundingVolume, parentPlaneMask) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingVolume)) {\n    throw new DeveloperError(\"boundingVolume is required.\");\n  }\n\n  if (!defined(parentPlaneMask)) {\n    throw new DeveloperError(\"parentPlaneMask is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (parentPlaneMask === CullingVolume.MASK_OUTSIDE || parentPlaneMask === CullingVolume.MASK_INSIDE) {\n    // parent is completely outside or completely inside, so this child is as well.\n    return parentPlaneMask;\n  } // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\n  // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\n\n\n  var mask = CullingVolume.MASK_INSIDE;\n  var planes = this.planes;\n\n  for (var k = 0, len = planes.length; k < len; ++k) {\n    // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\n    var flag = k < 31 ? 1 << k : 0;\n\n    if (k < 31 && (parentPlaneMask & flag) === 0) {\n      // boundingVolume is known to be INSIDE this plane.\n      continue;\n    }\n\n    var result = boundingVolume.intersectPlane(Plane.fromCartesian4(planes[k], scratchPlane));\n\n    if (result === Intersect.OUTSIDE) {\n      return CullingVolume.MASK_OUTSIDE;\n    } else if (result === Intersect.INTERSECTING) {\n      mask |= flag;\n    }\n  }\n\n  return mask;\n};\n/**\n * For plane masks (as used in {@link CullingVolume#computeVisibilityWithPlaneMask}), this special value\n * represents the case where the object bounding volume is entirely outside the culling volume.\n *\n * @type {Number}\n * @private\n */\n\n\nCullingVolume.MASK_OUTSIDE = 0xffffffff;\n/**\n * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n * represents the case where the object bounding volume is entirely inside the culling volume.\n *\n * @type {Number}\n * @private\n */\n\nCullingVolume.MASK_INSIDE = 0x00000000;\n/**\n * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n * represents the case where the object bounding volume (may) intersect all planes of the culling volume.\n *\n * @type {Number}\n * @private\n */\n\nCullingVolume.MASK_INDETERMINATE = 0x7fffffff;\nexport default CullingVolume;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/CullingVolume.js"],"names":["Cartesian3","Cartesian4","defaultValue","defined","DeveloperError","Intersect","Plane","CullingVolume","planes","faces","clone","UNIT_X","UNIT_Y","UNIT_Z","scratchPlaneCenter","scratchPlaneNormal","scratchPlane","fromBoundingSphere","boundingSphere","result","length","center","radius","planeIndex","i","faceNormal","plane0","plane1","multiplyByScalar","add","x","y","z","w","dot","negate","prototype","computeVisibility","boundingVolume","intersecting","k","len","intersectPlane","fromCartesian4","OUTSIDE","INTERSECTING","INSIDE","computeVisibilityWithPlaneMask","parentPlaneMask","MASK_OUTSIDE","MASK_INSIDE","mask","flag","MASK_INDETERMINATE"],"mappings":"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","sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Intersect from \"./Intersect.js\";\nimport Plane from \"./Plane.js\";\n\n/**\n * The culling volume defined by planes.\n *\n * @alias CullingVolume\n * @constructor\n *\n * @param {Cartesian4[]} [planes] An array of clipping planes.\n */\nfunction CullingVolume(planes) {\n  /**\n   * Each plane is represented by a Cartesian4 object, where the x, y, and z components\n   * define the unit vector normal to the plane, and the w component is the distance of the\n   * plane from the origin.\n   * @type {Cartesian4[]}\n   * @default []\n   */\n  this.planes = defaultValue(planes, []);\n}\n\nvar faces = [new Cartesian3(), new Cartesian3(), new Cartesian3()];\nCartesian3.clone(Cartesian3.UNIT_X, faces[0]);\nCartesian3.clone(Cartesian3.UNIT_Y, faces[1]);\nCartesian3.clone(Cartesian3.UNIT_Z, faces[2]);\n\nvar scratchPlaneCenter = new Cartesian3();\nvar scratchPlaneNormal = new Cartesian3();\nvar scratchPlane = new Plane(new Cartesian3(1.0, 0.0, 0.0), 0.0);\n\n/**\n * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.\n * The planes are aligned to the x, y, and z axes in world coordinates.\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere used to create the culling volume.\n * @param {CullingVolume} [result] The object onto which to store the result.\n * @returns {CullingVolume} The culling volume created from the bounding sphere.\n */\nCullingVolume.fromBoundingSphere = function (boundingSphere, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new CullingVolume();\n  }\n\n  var length = faces.length;\n  var planes = result.planes;\n  planes.length = 2 * length;\n\n  var center = boundingSphere.center;\n  var radius = boundingSphere.radius;\n\n  var planeIndex = 0;\n\n  for (var i = 0; i < length; ++i) {\n    var faceNormal = faces[i];\n\n    var plane0 = planes[planeIndex];\n    var plane1 = planes[planeIndex + 1];\n\n    if (!defined(plane0)) {\n      plane0 = planes[planeIndex] = new Cartesian4();\n    }\n    if (!defined(plane1)) {\n      plane1 = planes[planeIndex + 1] = new Cartesian4();\n    }\n\n    Cartesian3.multiplyByScalar(faceNormal, -radius, scratchPlaneCenter);\n    Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);\n\n    plane0.x = faceNormal.x;\n    plane0.y = faceNormal.y;\n    plane0.z = faceNormal.z;\n    plane0.w = -Cartesian3.dot(faceNormal, scratchPlaneCenter);\n\n    Cartesian3.multiplyByScalar(faceNormal, radius, scratchPlaneCenter);\n    Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);\n\n    plane1.x = -faceNormal.x;\n    plane1.y = -faceNormal.y;\n    plane1.z = -faceNormal.z;\n    plane1.w = -Cartesian3.dot(\n      Cartesian3.negate(faceNormal, scratchPlaneNormal),\n      scratchPlaneCenter\n    );\n\n    planeIndex += 2;\n  }\n\n  return result;\n};\n\n/**\n * Determines whether a bounding volume intersects the culling volume.\n *\n * @param {Object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.\n * @returns {Intersect}  Intersect.OUTSIDE, Intersect.INTERSECTING, or Intersect.INSIDE.\n */\nCullingVolume.prototype.computeVisibility = function (boundingVolume) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingVolume)) {\n    throw new DeveloperError(\"boundingVolume is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var planes = this.planes;\n  var intersecting = false;\n  for (var k = 0, len = planes.length; k < len; ++k) {\n    var result = boundingVolume.intersectPlane(\n      Plane.fromCartesian4(planes[k], scratchPlane)\n    );\n    if (result === Intersect.OUTSIDE) {\n      return Intersect.OUTSIDE;\n    } else if (result === Intersect.INTERSECTING) {\n      intersecting = true;\n    }\n  }\n\n  return intersecting ? Intersect.INTERSECTING : Intersect.INSIDE;\n};\n\n/**\n * Determines whether a bounding volume intersects the culling volume.\n *\n * @param {Object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.\n * @param {Number} parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling\n *                                 volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then\n *                                 the parent (and therefore this) volume is completely inside plane[planeIndex]\n *                                 and that plane check can be skipped.\n * @returns {Number} A plane mask as described above (which can be applied to this boundingVolume's children).\n *\n * @private\n */\nCullingVolume.prototype.computeVisibilityWithPlaneMask = function (\n  boundingVolume,\n  parentPlaneMask\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingVolume)) {\n    throw new DeveloperError(\"boundingVolume is required.\");\n  }\n  if (!defined(parentPlaneMask)) {\n    throw new DeveloperError(\"parentPlaneMask is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (\n    parentPlaneMask === CullingVolume.MASK_OUTSIDE ||\n    parentPlaneMask === CullingVolume.MASK_INSIDE\n  ) {\n    // parent is completely outside or completely inside, so this child is as well.\n    return parentPlaneMask;\n  }\n\n  // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\n  // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\n  var mask = CullingVolume.MASK_INSIDE;\n\n  var planes = this.planes;\n  for (var k = 0, len = planes.length; k < len; ++k) {\n    // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\n    var flag = k < 31 ? 1 << k : 0;\n    if (k < 31 && (parentPlaneMask & flag) === 0) {\n      // boundingVolume is known to be INSIDE this plane.\n      continue;\n    }\n\n    var result = boundingVolume.intersectPlane(\n      Plane.fromCartesian4(planes[k], scratchPlane)\n    );\n    if (result === Intersect.OUTSIDE) {\n      return CullingVolume.MASK_OUTSIDE;\n    } else if (result === Intersect.INTERSECTING) {\n      mask |= flag;\n    }\n  }\n\n  return mask;\n};\n\n/**\n * For plane masks (as used in {@link CullingVolume#computeVisibilityWithPlaneMask}), this special value\n * represents the case where the object bounding volume is entirely outside the culling volume.\n *\n * @type {Number}\n * @private\n */\nCullingVolume.MASK_OUTSIDE = 0xffffffff;\n\n/**\n * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n * represents the case where the object bounding volume is entirely inside the culling volume.\n *\n * @type {Number}\n * @private\n */\nCullingVolume.MASK_INSIDE = 0x00000000;\n\n/**\n * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n * represents the case where the object bounding volume (may) intersect all planes of the culling volume.\n *\n * @type {Number}\n * @private\n */\nCullingVolume.MASK_INDETERMINATE = 0x7fffffff;\nexport default CullingVolume;\n"]},"metadata":{},"sourceType":"module"}