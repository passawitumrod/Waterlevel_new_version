{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport ReferenceFrame from \"../Core/ReferenceFrame.js\";\nimport PositionProperty from \"./PositionProperty.js\";\nimport Property from \"./Property.js\";\nimport SampledProperty from \"./SampledProperty.js\";\n/**\n * A {@link SampledProperty} which is also a {@link PositionProperty}.\n *\n * @alias SampledPositionProperty\n * @constructor\n *\n * @param {ReferenceFrame} [referenceFrame=ReferenceFrame.FIXED] The reference frame in which the position is defined.\n * @param {Number} [numberOfDerivatives=0] The number of derivatives that accompany each position; i.e. velocity, acceleration, etc...\n */\n\nfunction SampledPositionProperty(referenceFrame, numberOfDerivatives) {\n  numberOfDerivatives = defaultValue(numberOfDerivatives, 0);\n  var derivativeTypes;\n\n  if (numberOfDerivatives > 0) {\n    derivativeTypes = new Array(numberOfDerivatives);\n\n    for (var i = 0; i < numberOfDerivatives; i++) {\n      derivativeTypes[i] = Cartesian3;\n    }\n  }\n\n  this._numberOfDerivatives = numberOfDerivatives;\n  this._property = new SampledProperty(Cartesian3, derivativeTypes);\n  this._definitionChanged = new Event();\n  this._referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);\n\n  this._property._definitionChanged.addEventListener(function () {\n    this._definitionChanged.raiseEvent(this);\n  }, this);\n}\n\nObject.defineProperties(SampledPositionProperty.prototype, {\n  /**\n   * Gets a value indicating if this property is constant.  A property is considered\n   * constant if getValue always returns the same result for the current definition.\n   * @memberof SampledPositionProperty.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  isConstant: {\n    get: function () {\n      return this._property.isConstant;\n    }\n  },\n\n  /**\n   * Gets the event that is raised whenever the definition of this property changes.\n   * The definition is considered to have changed if a call to getValue would return\n   * a different result for the same time.\n   * @memberof SampledPositionProperty.prototype\n   *\n   * @type {Event}\n   * @readonly\n   */\n  definitionChanged: {\n    get: function () {\n      return this._definitionChanged;\n    }\n  },\n\n  /**\n   * Gets the reference frame in which the position is defined.\n   * @memberof SampledPositionProperty.prototype\n   * @type {ReferenceFrame}\n   * @default ReferenceFrame.FIXED;\n   */\n  referenceFrame: {\n    get: function () {\n      return this._referenceFrame;\n    }\n  },\n\n  /**\n   * Gets the degree of interpolation to perform when retrieving a value.\n   * @memberof SampledPositionProperty.prototype\n   *\n   * @type {Number}\n   * @default 1\n   */\n  interpolationDegree: {\n    get: function () {\n      return this._property.interpolationDegree;\n    }\n  },\n\n  /**\n   * Gets the interpolation algorithm to use when retrieving a value.\n   * @memberof SampledPositionProperty.prototype\n   *\n   * @type {InterpolationAlgorithm}\n   * @default LinearApproximation\n   */\n  interpolationAlgorithm: {\n    get: function () {\n      return this._property.interpolationAlgorithm;\n    }\n  },\n\n  /**\n   * The number of derivatives contained by this property; i.e. 0 for just position, 1 for velocity, etc.\n   * @memberof SampledPositionProperty.prototype\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  numberOfDerivatives: {\n    get: function () {\n      return this._numberOfDerivatives;\n    }\n  },\n\n  /**\n   * Gets or sets the type of extrapolation to perform when a value\n   * is requested at a time after any available samples.\n   * @memberof SampledPositionProperty.prototype\n   * @type {ExtrapolationType}\n   * @default ExtrapolationType.NONE\n   */\n  forwardExtrapolationType: {\n    get: function () {\n      return this._property.forwardExtrapolationType;\n    },\n    set: function (value) {\n      this._property.forwardExtrapolationType = value;\n    }\n  },\n\n  /**\n   * Gets or sets the amount of time to extrapolate forward before\n   * the property becomes undefined.  A value of 0 will extrapolate forever.\n   * @memberof SampledPositionProperty.prototype\n   * @type {Number}\n   * @default 0\n   */\n  forwardExtrapolationDuration: {\n    get: function () {\n      return this._property.forwardExtrapolationDuration;\n    },\n    set: function (value) {\n      this._property.forwardExtrapolationDuration = value;\n    }\n  },\n\n  /**\n   * Gets or sets the type of extrapolation to perform when a value\n   * is requested at a time before any available samples.\n   * @memberof SampledPositionProperty.prototype\n   * @type {ExtrapolationType}\n   * @default ExtrapolationType.NONE\n   */\n  backwardExtrapolationType: {\n    get: function () {\n      return this._property.backwardExtrapolationType;\n    },\n    set: function (value) {\n      this._property.backwardExtrapolationType = value;\n    }\n  },\n\n  /**\n   * Gets or sets the amount of time to extrapolate backward\n   * before the property becomes undefined.  A value of 0 will extrapolate forever.\n   * @memberof SampledPositionProperty.prototype\n   * @type {Number}\n   * @default 0\n   */\n  backwardExtrapolationDuration: {\n    get: function () {\n      return this._property.backwardExtrapolationDuration;\n    },\n    set: function (value) {\n      this._property.backwardExtrapolationDuration = value;\n    }\n  }\n});\n/**\n * Gets the position at the provided time.\n *\n * @param {JulianDate} time The time for which to retrieve the value.\n * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.\n * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.\n */\n\nSampledPositionProperty.prototype.getValue = function (time, result) {\n  return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);\n};\n/**\n * Gets the position at the provided time and in the provided reference frame.\n *\n * @param {JulianDate} time The time for which to retrieve the value.\n * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.\n * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.\n * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.\n */\n\n\nSampledPositionProperty.prototype.getValueInReferenceFrame = function (time, referenceFrame, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  Check.defined(\"referenceFrame\", referenceFrame); //>>includeEnd('debug');\n\n  result = this._property.getValue(time, result);\n\n  if (defined(result)) {\n    return PositionProperty.convertToReferenceFrame(time, result, this._referenceFrame, referenceFrame, result);\n  }\n\n  return undefined;\n};\n/**\n * Sets the algorithm and degree to use when interpolating a position.\n *\n * @param {Object} [options] Object with the following properties:\n * @param {InterpolationAlgorithm} [options.interpolationAlgorithm] The new interpolation algorithm.  If undefined, the existing property will be unchanged.\n * @param {Number} [options.interpolationDegree] The new interpolation degree.  If undefined, the existing property will be unchanged.\n */\n\n\nSampledPositionProperty.prototype.setInterpolationOptions = function (options) {\n  this._property.setInterpolationOptions(options);\n};\n/**\n * Adds a new sample.\n *\n * @param {JulianDate} time The sample time.\n * @param {Cartesian3} position The position at the provided time.\n * @param {Cartesian3[]} [derivatives] The array of derivative values at the provided time.\n */\n\n\nSampledPositionProperty.prototype.addSample = function (time, position, derivatives) {\n  var numberOfDerivatives = this._numberOfDerivatives; //>>includeStart('debug', pragmas.debug);\n\n  if (numberOfDerivatives > 0 && (!defined(derivatives) || derivatives.length !== numberOfDerivatives)) {\n    throw new DeveloperError(\"derivatives length must be equal to the number of derivatives.\");\n  } //>>includeEnd('debug');\n\n\n  this._property.addSample(time, position, derivatives);\n};\n/**\n * Adds multiple samples via parallel arrays.\n *\n * @param {JulianDate[]} times An array of JulianDate instances where each index is a sample time.\n * @param {Cartesian3[]} positions An array of Cartesian3 position instances, where each value corresponds to the provided time index.\n * @param {Array[]} [derivatives] An array where each value is another array containing derivatives for the corresponding time index.\n *\n * @exception {DeveloperError} All arrays must be the same length.\n */\n\n\nSampledPositionProperty.prototype.addSamples = function (times, positions, derivatives) {\n  this._property.addSamples(times, positions, derivatives);\n};\n/**\n * Adds samples as a single packed array where each new sample is represented as a date,\n * followed by the packed representation of the corresponding value and derivatives.\n *\n * @param {Number[]} packedSamples The array of packed samples.\n * @param {JulianDate} [epoch] If any of the dates in packedSamples are numbers, they are considered an offset from this epoch, in seconds.\n */\n\n\nSampledPositionProperty.prototype.addSamplesPackedArray = function (packedSamples, epoch) {\n  this._property.addSamplesPackedArray(packedSamples, epoch);\n};\n/**\n * Removes a sample at the given time, if present.\n *\n * @param {JulianDate} time The sample time.\n * @returns {Boolean} <code>true</code> if a sample at time was removed, <code>false</code> otherwise.\n */\n\n\nSampledPositionProperty.prototype.removeSample = function (time) {\n  this._property.removeSample(time);\n};\n/**\n * Removes all samples for the given time interval.\n *\n * @param {TimeInterval} time The time interval for which to remove all samples.\n */\n\n\nSampledPositionProperty.prototype.removeSamples = function (timeInterval) {\n  this._property.removeSamples(timeInterval);\n};\n/**\n * Compares this property to the provided property and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Property} [other] The other property.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\n\n\nSampledPositionProperty.prototype.equals = function (other) {\n  return this === other || //\n  other instanceof SampledPositionProperty && Property.equals(this._property, other._property) && //\n  this._referenceFrame === other._referenceFrame;\n};\n\nexport default SampledPositionProperty;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/DataSources/SampledPositionProperty.js"],"names":["Cartesian3","Check","defaultValue","defined","DeveloperError","Event","ReferenceFrame","PositionProperty","Property","SampledProperty","SampledPositionProperty","referenceFrame","numberOfDerivatives","derivativeTypes","Array","i","_numberOfDerivatives","_property","_definitionChanged","_referenceFrame","FIXED","addEventListener","raiseEvent","Object","defineProperties","prototype","isConstant","get","definitionChanged","interpolationDegree","interpolationAlgorithm","forwardExtrapolationType","set","value","forwardExtrapolationDuration","backwardExtrapolationType","backwardExtrapolationDuration","getValue","time","result","getValueInReferenceFrame","convertToReferenceFrame","undefined","setInterpolationOptions","options","addSample","position","derivatives","length","addSamples","times","positions","addSamplesPackedArray","packedSamples","epoch","removeSample","removeSamples","timeInterval","equals","other"],"mappings":"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","sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport ReferenceFrame from \"../Core/ReferenceFrame.js\";\nimport PositionProperty from \"./PositionProperty.js\";\nimport Property from \"./Property.js\";\nimport SampledProperty from \"./SampledProperty.js\";\n\n/**\n * A {@link SampledProperty} which is also a {@link PositionProperty}.\n *\n * @alias SampledPositionProperty\n * @constructor\n *\n * @param {ReferenceFrame} [referenceFrame=ReferenceFrame.FIXED] The reference frame in which the position is defined.\n * @param {Number} [numberOfDerivatives=0] The number of derivatives that accompany each position; i.e. velocity, acceleration, etc...\n */\nfunction SampledPositionProperty(referenceFrame, numberOfDerivatives) {\n  numberOfDerivatives = defaultValue(numberOfDerivatives, 0);\n\n  var derivativeTypes;\n  if (numberOfDerivatives > 0) {\n    derivativeTypes = new Array(numberOfDerivatives);\n    for (var i = 0; i < numberOfDerivatives; i++) {\n      derivativeTypes[i] = Cartesian3;\n    }\n  }\n\n  this._numberOfDerivatives = numberOfDerivatives;\n  this._property = new SampledProperty(Cartesian3, derivativeTypes);\n  this._definitionChanged = new Event();\n  this._referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);\n\n  this._property._definitionChanged.addEventListener(function () {\n    this._definitionChanged.raiseEvent(this);\n  }, this);\n}\n\nObject.defineProperties(SampledPositionProperty.prototype, {\n  /**\n   * Gets a value indicating if this property is constant.  A property is considered\n   * constant if getValue always returns the same result for the current definition.\n   * @memberof SampledPositionProperty.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  isConstant: {\n    get: function () {\n      return this._property.isConstant;\n    },\n  },\n  /**\n   * Gets the event that is raised whenever the definition of this property changes.\n   * The definition is considered to have changed if a call to getValue would return\n   * a different result for the same time.\n   * @memberof SampledPositionProperty.prototype\n   *\n   * @type {Event}\n   * @readonly\n   */\n  definitionChanged: {\n    get: function () {\n      return this._definitionChanged;\n    },\n  },\n  /**\n   * Gets the reference frame in which the position is defined.\n   * @memberof SampledPositionProperty.prototype\n   * @type {ReferenceFrame}\n   * @default ReferenceFrame.FIXED;\n   */\n  referenceFrame: {\n    get: function () {\n      return this._referenceFrame;\n    },\n  },\n  /**\n   * Gets the degree of interpolation to perform when retrieving a value.\n   * @memberof SampledPositionProperty.prototype\n   *\n   * @type {Number}\n   * @default 1\n   */\n  interpolationDegree: {\n    get: function () {\n      return this._property.interpolationDegree;\n    },\n  },\n  /**\n   * Gets the interpolation algorithm to use when retrieving a value.\n   * @memberof SampledPositionProperty.prototype\n   *\n   * @type {InterpolationAlgorithm}\n   * @default LinearApproximation\n   */\n  interpolationAlgorithm: {\n    get: function () {\n      return this._property.interpolationAlgorithm;\n    },\n  },\n  /**\n   * The number of derivatives contained by this property; i.e. 0 for just position, 1 for velocity, etc.\n   * @memberof SampledPositionProperty.prototype\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  numberOfDerivatives: {\n    get: function () {\n      return this._numberOfDerivatives;\n    },\n  },\n  /**\n   * Gets or sets the type of extrapolation to perform when a value\n   * is requested at a time after any available samples.\n   * @memberof SampledPositionProperty.prototype\n   * @type {ExtrapolationType}\n   * @default ExtrapolationType.NONE\n   */\n  forwardExtrapolationType: {\n    get: function () {\n      return this._property.forwardExtrapolationType;\n    },\n    set: function (value) {\n      this._property.forwardExtrapolationType = value;\n    },\n  },\n  /**\n   * Gets or sets the amount of time to extrapolate forward before\n   * the property becomes undefined.  A value of 0 will extrapolate forever.\n   * @memberof SampledPositionProperty.prototype\n   * @type {Number}\n   * @default 0\n   */\n  forwardExtrapolationDuration: {\n    get: function () {\n      return this._property.forwardExtrapolationDuration;\n    },\n    set: function (value) {\n      this._property.forwardExtrapolationDuration = value;\n    },\n  },\n  /**\n   * Gets or sets the type of extrapolation to perform when a value\n   * is requested at a time before any available samples.\n   * @memberof SampledPositionProperty.prototype\n   * @type {ExtrapolationType}\n   * @default ExtrapolationType.NONE\n   */\n  backwardExtrapolationType: {\n    get: function () {\n      return this._property.backwardExtrapolationType;\n    },\n    set: function (value) {\n      this._property.backwardExtrapolationType = value;\n    },\n  },\n  /**\n   * Gets or sets the amount of time to extrapolate backward\n   * before the property becomes undefined.  A value of 0 will extrapolate forever.\n   * @memberof SampledPositionProperty.prototype\n   * @type {Number}\n   * @default 0\n   */\n  backwardExtrapolationDuration: {\n    get: function () {\n      return this._property.backwardExtrapolationDuration;\n    },\n    set: function (value) {\n      this._property.backwardExtrapolationDuration = value;\n    },\n  },\n});\n\n/**\n * Gets the position at the provided time.\n *\n * @param {JulianDate} time The time for which to retrieve the value.\n * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.\n * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.\n */\nSampledPositionProperty.prototype.getValue = function (time, result) {\n  return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);\n};\n\n/**\n * Gets the position at the provided time and in the provided reference frame.\n *\n * @param {JulianDate} time The time for which to retrieve the value.\n * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.\n * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.\n * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.\n */\nSampledPositionProperty.prototype.getValueInReferenceFrame = function (\n  time,\n  referenceFrame,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  Check.defined(\"referenceFrame\", referenceFrame);\n  //>>includeEnd('debug');\n\n  result = this._property.getValue(time, result);\n  if (defined(result)) {\n    return PositionProperty.convertToReferenceFrame(\n      time,\n      result,\n      this._referenceFrame,\n      referenceFrame,\n      result\n    );\n  }\n  return undefined;\n};\n\n/**\n * Sets the algorithm and degree to use when interpolating a position.\n *\n * @param {Object} [options] Object with the following properties:\n * @param {InterpolationAlgorithm} [options.interpolationAlgorithm] The new interpolation algorithm.  If undefined, the existing property will be unchanged.\n * @param {Number} [options.interpolationDegree] The new interpolation degree.  If undefined, the existing property will be unchanged.\n */\nSampledPositionProperty.prototype.setInterpolationOptions = function (options) {\n  this._property.setInterpolationOptions(options);\n};\n\n/**\n * Adds a new sample.\n *\n * @param {JulianDate} time The sample time.\n * @param {Cartesian3} position The position at the provided time.\n * @param {Cartesian3[]} [derivatives] The array of derivative values at the provided time.\n */\nSampledPositionProperty.prototype.addSample = function (\n  time,\n  position,\n  derivatives\n) {\n  var numberOfDerivatives = this._numberOfDerivatives;\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    numberOfDerivatives > 0 &&\n    (!defined(derivatives) || derivatives.length !== numberOfDerivatives)\n  ) {\n    throw new DeveloperError(\n      \"derivatives length must be equal to the number of derivatives.\"\n    );\n  }\n  //>>includeEnd('debug');\n  this._property.addSample(time, position, derivatives);\n};\n\n/**\n * Adds multiple samples via parallel arrays.\n *\n * @param {JulianDate[]} times An array of JulianDate instances where each index is a sample time.\n * @param {Cartesian3[]} positions An array of Cartesian3 position instances, where each value corresponds to the provided time index.\n * @param {Array[]} [derivatives] An array where each value is another array containing derivatives for the corresponding time index.\n *\n * @exception {DeveloperError} All arrays must be the same length.\n */\nSampledPositionProperty.prototype.addSamples = function (\n  times,\n  positions,\n  derivatives\n) {\n  this._property.addSamples(times, positions, derivatives);\n};\n\n/**\n * Adds samples as a single packed array where each new sample is represented as a date,\n * followed by the packed representation of the corresponding value and derivatives.\n *\n * @param {Number[]} packedSamples The array of packed samples.\n * @param {JulianDate} [epoch] If any of the dates in packedSamples are numbers, they are considered an offset from this epoch, in seconds.\n */\nSampledPositionProperty.prototype.addSamplesPackedArray = function (\n  packedSamples,\n  epoch\n) {\n  this._property.addSamplesPackedArray(packedSamples, epoch);\n};\n\n/**\n * Removes a sample at the given time, if present.\n *\n * @param {JulianDate} time The sample time.\n * @returns {Boolean} <code>true</code> if a sample at time was removed, <code>false</code> otherwise.\n */\nSampledPositionProperty.prototype.removeSample = function (time) {\n  this._property.removeSample(time);\n};\n\n/**\n * Removes all samples for the given time interval.\n *\n * @param {TimeInterval} time The time interval for which to remove all samples.\n */\nSampledPositionProperty.prototype.removeSamples = function (timeInterval) {\n  this._property.removeSamples(timeInterval);\n};\n\n/**\n * Compares this property to the provided property and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Property} [other] The other property.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nSampledPositionProperty.prototype.equals = function (other) {\n  return (\n    this === other || //\n    (other instanceof SampledPositionProperty &&\n    Property.equals(this._property, other._property) && //\n      this._referenceFrame === other._referenceFrame)\n  );\n};\nexport default SampledPositionProperty;\n"]},"metadata":{},"sourceType":"module"}