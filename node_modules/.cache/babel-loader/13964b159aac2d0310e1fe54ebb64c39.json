{"ast":null,"code":"import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport JulianDate from \"./JulianDate.js\";\n/**\n * An interval defined by a start and a stop time; optionally including those times as part of the interval.\n * Arbitrary data can optionally be associated with each instance for used with {@link TimeIntervalCollection}.\n *\n * @alias TimeInterval\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {JulianDate} [options.start=new JulianDate()] The start time of the interval.\n * @param {JulianDate} [options.stop=new JulianDate()] The stop time of the interval.\n * @param {Boolean} [options.isStartIncluded=true] <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.\n * @param {Boolean} [options.isStopIncluded=true] <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.\n * @param {Object} [options.data] Arbitrary data associated with this interval.\n *\n * @example\n * // Create an instance that spans August 1st, 1980 and is associated\n * // with a Cartesian position.\n * var timeInterval = new Cesium.TimeInterval({\n *     start : Cesium.JulianDate.fromIso8601('1980-08-01T00:00:00Z'),\n *     stop : Cesium.JulianDate.fromIso8601('1980-08-02T00:00:00Z'),\n *     isStartIncluded : true,\n *     isStopIncluded : false,\n *     data : Cesium.Cartesian3.fromDegrees(39.921037, -75.170082)\n * });\n *\n * @example\n * // Create two instances from ISO 8601 intervals with associated numeric data\n * // then compute their intersection, summing the data they contain.\n * var left = Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '2000/2010',\n *     data : 2\n * });\n *\n * var right = Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '1995/2005',\n *     data : 3\n * });\n *\n * //The result of the below intersection will be an interval equivalent to\n * //var intersection = Cesium.TimeInterval.fromIso8601({\n * //  iso8601 : '2000/2005',\n * //  data : 5\n * //});\n * var intersection = new Cesium.TimeInterval();\n * Cesium.TimeInterval.intersect(left, right, intersection, function(leftData, rightData) {\n *     return leftData + rightData;\n * });\n *\n * @example\n * // Check if an interval contains a specific time.\n * var dateToCheck = Cesium.JulianDate.fromIso8601('1982-09-08T11:30:00Z');\n * var containsDate = Cesium.TimeInterval.contains(timeInterval, dateToCheck);\n */\n\nfunction TimeInterval(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  /**\n   * Gets or sets the start time of this interval.\n   * @type {JulianDate}\n   */\n\n  this.start = defined(options.start) ? JulianDate.clone(options.start) : new JulianDate();\n  /**\n   * Gets or sets the stop time of this interval.\n   * @type {JulianDate}\n   */\n\n  this.stop = defined(options.stop) ? JulianDate.clone(options.stop) : new JulianDate();\n  /**\n   * Gets or sets the data associated with this interval.\n   * @type {*}\n   */\n\n  this.data = options.data;\n  /**\n   * Gets or sets whether or not the start time is included in this interval.\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.isStartIncluded = defaultValue(options.isStartIncluded, true);\n  /**\n   * Gets or sets whether or not the stop time is included in this interval.\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.isStopIncluded = defaultValue(options.isStopIncluded, true);\n}\n\nObject.defineProperties(TimeInterval.prototype, {\n  /**\n   * Gets whether or not this interval is empty.\n   * @memberof TimeInterval.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  isEmpty: {\n    get: function get() {\n      var stopComparedToStart = JulianDate.compare(this.stop, this.start);\n      return stopComparedToStart < 0 || stopComparedToStart === 0 && (!this.isStartIncluded || !this.isStopIncluded);\n    }\n  }\n});\nvar scratchInterval = {\n  start: undefined,\n  stop: undefined,\n  isStartIncluded: undefined,\n  isStopIncluded: undefined,\n  data: undefined\n};\n/**\n * Creates a new instance from a {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} interval.\n *\n * @throws DeveloperError if options.iso8601 does not match proper formatting.\n *\n * @param {Object} options Object with the following properties:\n * @param {String} options.iso8601 An ISO 8601 interval.\n * @param {Boolean} [options.isStartIncluded=true] <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.\n * @param {Boolean} [options.isStopIncluded=true] <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.\n * @param {Object} [options.data] Arbitrary data associated with this interval.\n * @param {TimeInterval} [result] An existing instance to use for the result.\n * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.\n */\n\nTimeInterval.fromIso8601 = function (options, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.string(\"options.iso8601\", options.iso8601); //>>includeEnd('debug');\n\n  var dates = options.iso8601.split(\"/\");\n\n  if (dates.length !== 2) {\n    throw new DeveloperError(\"options.iso8601 is an invalid ISO 8601 interval.\");\n  }\n\n  var start = JulianDate.fromIso8601(dates[0]);\n  var stop = JulianDate.fromIso8601(dates[1]);\n  var isStartIncluded = defaultValue(options.isStartIncluded, true);\n  var isStopIncluded = defaultValue(options.isStopIncluded, true);\n  var data = options.data;\n\n  if (!defined(result)) {\n    scratchInterval.start = start;\n    scratchInterval.stop = stop;\n    scratchInterval.isStartIncluded = isStartIncluded;\n    scratchInterval.isStopIncluded = isStopIncluded;\n    scratchInterval.data = data;\n    return new TimeInterval(scratchInterval);\n  }\n\n  result.start = start;\n  result.stop = stop;\n  result.isStartIncluded = isStartIncluded;\n  result.isStopIncluded = isStopIncluded;\n  result.data = data;\n  return result;\n};\n/**\n * Creates an ISO8601 representation of the provided interval.\n *\n * @param {TimeInterval} timeInterval The interval to be converted.\n * @param {Number} [precision] The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.\n * @returns {String} The ISO8601 representation of the provided interval.\n */\n\n\nTimeInterval.toIso8601 = function (timeInterval, precision) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"timeInterval\", timeInterval); //>>includeEnd('debug');\n\n  return JulianDate.toIso8601(timeInterval.start, precision) + \"/\" + JulianDate.toIso8601(timeInterval.stop, precision);\n};\n/**\n * Duplicates the provided instance.\n *\n * @param {TimeInterval} [timeInterval] The instance to clone.\n * @param {TimeInterval} [result] An existing instance to use for the result.\n * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.\n */\n\n\nTimeInterval.clone = function (timeInterval, result) {\n  if (!defined(timeInterval)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new TimeInterval(timeInterval);\n  }\n\n  result.start = timeInterval.start;\n  result.stop = timeInterval.stop;\n  result.isStartIncluded = timeInterval.isStartIncluded;\n  result.isStopIncluded = timeInterval.isStopIncluded;\n  result.data = timeInterval.data;\n  return result;\n};\n/**\n * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {TimeInterval} [left] The first instance.\n * @param {TimeInterval} [right] The second instance.\n * @param {TimeInterval~DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {Boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.\n */\n\n\nTimeInterval.equals = function (left, right, dataComparer) {\n  return left === right || defined(left) && defined(right) && (left.isEmpty && right.isEmpty || left.isStartIncluded === right.isStartIncluded && left.isStopIncluded === right.isStopIncluded && JulianDate.equals(left.start, right.start) && JulianDate.equals(left.stop, right.stop) && (left.data === right.data || defined(dataComparer) && dataComparer(left.data, right.data)));\n};\n/**\n * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of\n * each other.  That is, in order for the dates to be considered equal (and for\n * this function to return <code>true</code>), the absolute value of the difference between them, in\n * seconds, must be less than <code>epsilon</code>.\n *\n * @param {TimeInterval} [left] The first instance.\n * @param {TimeInterval} [right] The second instance.\n * @param {Number} epsilon The maximum number of seconds that should separate the two instances.\n * @param {TimeInterval~DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {Boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.\n */\n\n\nTimeInterval.equalsEpsilon = function (left, right, epsilon, dataComparer) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"epsilon\", epsilon); //>>includeEnd('debug');\n\n  return left === right || defined(left) && defined(right) && (left.isEmpty && right.isEmpty || left.isStartIncluded === right.isStartIncluded && left.isStopIncluded === right.isStopIncluded && JulianDate.equalsEpsilon(left.start, right.start, epsilon) && JulianDate.equalsEpsilon(left.stop, right.stop, epsilon) && (left.data === right.data || defined(dataComparer) && dataComparer(left.data, right.data)));\n};\n/**\n * Computes the intersection of two intervals, optionally merging their data.\n *\n * @param {TimeInterval} left The first interval.\n * @param {TimeInterval} [right] The second interval.\n * @param {TimeInterval} result An existing instance to use for the result.\n * @param {TimeInterval~MergeCallback} [mergeCallback] A function which merges the data of the two intervals. If omitted, the data from the left interval will be used.\n * @returns {TimeInterval} The modified result parameter.\n */\n\n\nTimeInterval.intersect = function (left, right, result, mergeCallback) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  if (!defined(right)) {\n    return TimeInterval.clone(TimeInterval.EMPTY, result);\n  }\n\n  var leftStart = left.start;\n  var leftStop = left.stop;\n  var rightStart = right.start;\n  var rightStop = right.stop;\n  var intersectsStartRight = JulianDate.greaterThanOrEquals(rightStart, leftStart) && JulianDate.greaterThanOrEquals(leftStop, rightStart);\n  var intersectsStartLeft = !intersectsStartRight && JulianDate.lessThanOrEquals(rightStart, leftStart) && JulianDate.lessThanOrEquals(leftStart, rightStop);\n\n  if (!intersectsStartRight && !intersectsStartLeft) {\n    return TimeInterval.clone(TimeInterval.EMPTY, result);\n  }\n\n  var leftIsStartIncluded = left.isStartIncluded;\n  var leftIsStopIncluded = left.isStopIncluded;\n  var rightIsStartIncluded = right.isStartIncluded;\n  var rightIsStopIncluded = right.isStopIncluded;\n  var leftLessThanRight = JulianDate.lessThan(leftStop, rightStop);\n  result.start = intersectsStartRight ? rightStart : leftStart;\n  result.isStartIncluded = leftIsStartIncluded && rightIsStartIncluded || !JulianDate.equals(rightStart, leftStart) && (intersectsStartRight && rightIsStartIncluded || intersectsStartLeft && leftIsStartIncluded);\n  result.stop = leftLessThanRight ? leftStop : rightStop;\n  result.isStopIncluded = leftLessThanRight ? leftIsStopIncluded : leftIsStopIncluded && rightIsStopIncluded || !JulianDate.equals(rightStop, leftStop) && rightIsStopIncluded;\n  result.data = defined(mergeCallback) ? mergeCallback(left.data, right.data) : left.data;\n  return result;\n};\n/**\n * Checks if the specified date is inside the provided interval.\n *\n * @param {TimeInterval} timeInterval The interval.\n * @param {JulianDate} julianDate The date to check.\n * @returns {Boolean} <code>true</code> if the interval contains the specified date, <code>false</code> otherwise.\n */\n\n\nTimeInterval.contains = function (timeInterval, julianDate) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"timeInterval\", timeInterval);\n  Check.typeOf.object(\"julianDate\", julianDate); //>>includeEnd('debug');\n\n  if (timeInterval.isEmpty) {\n    return false;\n  }\n\n  var startComparedToDate = JulianDate.compare(timeInterval.start, julianDate);\n\n  if (startComparedToDate === 0) {\n    return timeInterval.isStartIncluded;\n  }\n\n  var dateComparedToStop = JulianDate.compare(julianDate, timeInterval.stop);\n\n  if (dateComparedToStop === 0) {\n    return timeInterval.isStopIncluded;\n  }\n\n  return startComparedToDate < 0 && dateComparedToStop < 0;\n};\n/**\n * Duplicates this instance.\n *\n * @param {TimeInterval} [result] An existing instance to use for the result.\n * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.\n */\n\n\nTimeInterval.prototype.clone = function (result) {\n  return TimeInterval.clone(this, result);\n};\n/**\n * Compares this instance against the provided instance componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {TimeInterval} [right] The right hand side interval.\n * @param {TimeInterval~DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\n\n\nTimeInterval.prototype.equals = function (right, dataComparer) {\n  return TimeInterval.equals(this, right, dataComparer);\n};\n/**\n * Compares this instance against the provided instance componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {TimeInterval} [right] The right hand side interval.\n * @param {Number} epsilon The epsilon to use for equality testing.\n * @param {TimeInterval~DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\n\n\nTimeInterval.prototype.equalsEpsilon = function (right, epsilon, dataComparer) {\n  return TimeInterval.equalsEpsilon(this, right, epsilon, dataComparer);\n};\n/**\n * Creates a string representing this TimeInterval in ISO8601 format.\n *\n * @returns {String} A string representing this TimeInterval in ISO8601 format.\n */\n\n\nTimeInterval.prototype.toString = function () {\n  return TimeInterval.toIso8601(this);\n};\n/**\n * An immutable empty interval.\n *\n * @type {TimeInterval}\n * @constant\n */\n\n\nTimeInterval.EMPTY = Object.freeze(new TimeInterval({\n  start: new JulianDate(),\n  stop: new JulianDate(),\n  isStartIncluded: false,\n  isStopIncluded: false\n}));\n/**\n * Function interface for merging interval data.\n * @callback TimeInterval~MergeCallback\n *\n * @param {*} leftData The first data instance.\n * @param {*} rightData The second data instance.\n * @returns {*} The result of merging the two data instances.\n */\n\n/**\n * Function interface for comparing interval data.\n * @callback TimeInterval~DataComparer\n * @param {*} leftData The first data instance.\n * @param {*} rightData The second data instance.\n * @returns {Boolean} <code>true</code> if the provided instances are equal, <code>false</code> otherwise.\n */\n\nexport default TimeInterval;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/TimeInterval.js"],"names":["Check","defaultValue","defined","DeveloperError","JulianDate","TimeInterval","options","EMPTY_OBJECT","start","clone","stop","data","isStartIncluded","isStopIncluded","Object","defineProperties","prototype","isEmpty","get","stopComparedToStart","compare","scratchInterval","undefined","fromIso8601","result","typeOf","object","string","iso8601","dates","split","length","toIso8601","timeInterval","precision","equals","left","right","dataComparer","equalsEpsilon","epsilon","number","intersect","mergeCallback","EMPTY","leftStart","leftStop","rightStart","rightStop","intersectsStartRight","greaterThanOrEquals","intersectsStartLeft","lessThanOrEquals","leftIsStartIncluded","leftIsStopIncluded","rightIsStartIncluded","rightIsStopIncluded","leftLessThanRight","lessThan","contains","julianDate","startComparedToDate","dateComparedToStop","toString","freeze"],"mappings":"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","sourcesContent":["import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport JulianDate from \"./JulianDate.js\";\n\n/**\n * An interval defined by a start and a stop time; optionally including those times as part of the interval.\n * Arbitrary data can optionally be associated with each instance for used with {@link TimeIntervalCollection}.\n *\n * @alias TimeInterval\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {JulianDate} [options.start=new JulianDate()] The start time of the interval.\n * @param {JulianDate} [options.stop=new JulianDate()] The stop time of the interval.\n * @param {Boolean} [options.isStartIncluded=true] <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.\n * @param {Boolean} [options.isStopIncluded=true] <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.\n * @param {Object} [options.data] Arbitrary data associated with this interval.\n *\n * @example\n * // Create an instance that spans August 1st, 1980 and is associated\n * // with a Cartesian position.\n * var timeInterval = new Cesium.TimeInterval({\n *     start : Cesium.JulianDate.fromIso8601('1980-08-01T00:00:00Z'),\n *     stop : Cesium.JulianDate.fromIso8601('1980-08-02T00:00:00Z'),\n *     isStartIncluded : true,\n *     isStopIncluded : false,\n *     data : Cesium.Cartesian3.fromDegrees(39.921037, -75.170082)\n * });\n *\n * @example\n * // Create two instances from ISO 8601 intervals with associated numeric data\n * // then compute their intersection, summing the data they contain.\n * var left = Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '2000/2010',\n *     data : 2\n * });\n *\n * var right = Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '1995/2005',\n *     data : 3\n * });\n *\n * //The result of the below intersection will be an interval equivalent to\n * //var intersection = Cesium.TimeInterval.fromIso8601({\n * //  iso8601 : '2000/2005',\n * //  data : 5\n * //});\n * var intersection = new Cesium.TimeInterval();\n * Cesium.TimeInterval.intersect(left, right, intersection, function(leftData, rightData) {\n *     return leftData + rightData;\n * });\n *\n * @example\n * // Check if an interval contains a specific time.\n * var dateToCheck = Cesium.JulianDate.fromIso8601('1982-09-08T11:30:00Z');\n * var containsDate = Cesium.TimeInterval.contains(timeInterval, dateToCheck);\n */\nfunction TimeInterval(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  /**\n   * Gets or sets the start time of this interval.\n   * @type {JulianDate}\n   */\n  this.start = defined(options.start)\n    ? JulianDate.clone(options.start)\n    : new JulianDate();\n\n  /**\n   * Gets or sets the stop time of this interval.\n   * @type {JulianDate}\n   */\n  this.stop = defined(options.stop)\n    ? JulianDate.clone(options.stop)\n    : new JulianDate();\n\n  /**\n   * Gets or sets the data associated with this interval.\n   * @type {*}\n   */\n  this.data = options.data;\n\n  /**\n   * Gets or sets whether or not the start time is included in this interval.\n   * @type {Boolean}\n   * @default true\n   */\n  this.isStartIncluded = defaultValue(options.isStartIncluded, true);\n\n  /**\n   * Gets or sets whether or not the stop time is included in this interval.\n   * @type {Boolean}\n   * @default true\n   */\n  this.isStopIncluded = defaultValue(options.isStopIncluded, true);\n}\n\nObject.defineProperties(TimeInterval.prototype, {\n  /**\n   * Gets whether or not this interval is empty.\n   * @memberof TimeInterval.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  isEmpty: {\n    get: function () {\n      var stopComparedToStart = JulianDate.compare(this.stop, this.start);\n      return (\n        stopComparedToStart < 0 ||\n        (stopComparedToStart === 0 &&\n          (!this.isStartIncluded || !this.isStopIncluded))\n      );\n    },\n  },\n});\n\nvar scratchInterval = {\n  start: undefined,\n  stop: undefined,\n  isStartIncluded: undefined,\n  isStopIncluded: undefined,\n  data: undefined,\n};\n\n/**\n * Creates a new instance from a {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} interval.\n *\n * @throws DeveloperError if options.iso8601 does not match proper formatting.\n *\n * @param {Object} options Object with the following properties:\n * @param {String} options.iso8601 An ISO 8601 interval.\n * @param {Boolean} [options.isStartIncluded=true] <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.\n * @param {Boolean} [options.isStopIncluded=true] <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.\n * @param {Object} [options.data] Arbitrary data associated with this interval.\n * @param {TimeInterval} [result] An existing instance to use for the result.\n * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.\n */\nTimeInterval.fromIso8601 = function (options, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.string(\"options.iso8601\", options.iso8601);\n  //>>includeEnd('debug');\n\n  var dates = options.iso8601.split(\"/\");\n  if (dates.length !== 2) {\n    throw new DeveloperError(\n      \"options.iso8601 is an invalid ISO 8601 interval.\"\n    );\n  }\n  var start = JulianDate.fromIso8601(dates[0]);\n  var stop = JulianDate.fromIso8601(dates[1]);\n  var isStartIncluded = defaultValue(options.isStartIncluded, true);\n  var isStopIncluded = defaultValue(options.isStopIncluded, true);\n  var data = options.data;\n\n  if (!defined(result)) {\n    scratchInterval.start = start;\n    scratchInterval.stop = stop;\n    scratchInterval.isStartIncluded = isStartIncluded;\n    scratchInterval.isStopIncluded = isStopIncluded;\n    scratchInterval.data = data;\n    return new TimeInterval(scratchInterval);\n  }\n\n  result.start = start;\n  result.stop = stop;\n  result.isStartIncluded = isStartIncluded;\n  result.isStopIncluded = isStopIncluded;\n  result.data = data;\n  return result;\n};\n\n/**\n * Creates an ISO8601 representation of the provided interval.\n *\n * @param {TimeInterval} timeInterval The interval to be converted.\n * @param {Number} [precision] The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.\n * @returns {String} The ISO8601 representation of the provided interval.\n */\nTimeInterval.toIso8601 = function (timeInterval, precision) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"timeInterval\", timeInterval);\n  //>>includeEnd('debug');\n\n  return (\n    JulianDate.toIso8601(timeInterval.start, precision) +\n    \"/\" +\n    JulianDate.toIso8601(timeInterval.stop, precision)\n  );\n};\n\n/**\n * Duplicates the provided instance.\n *\n * @param {TimeInterval} [timeInterval] The instance to clone.\n * @param {TimeInterval} [result] An existing instance to use for the result.\n * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.\n */\nTimeInterval.clone = function (timeInterval, result) {\n  if (!defined(timeInterval)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new TimeInterval(timeInterval);\n  }\n  result.start = timeInterval.start;\n  result.stop = timeInterval.stop;\n  result.isStartIncluded = timeInterval.isStartIncluded;\n  result.isStopIncluded = timeInterval.isStopIncluded;\n  result.data = timeInterval.data;\n  return result;\n};\n\n/**\n * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {TimeInterval} [left] The first instance.\n * @param {TimeInterval} [right] The second instance.\n * @param {TimeInterval~DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {Boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.\n */\nTimeInterval.equals = function (left, right, dataComparer) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      ((left.isEmpty && right.isEmpty) ||\n        (left.isStartIncluded === right.isStartIncluded &&\n          left.isStopIncluded === right.isStopIncluded &&\n          JulianDate.equals(left.start, right.start) &&\n          JulianDate.equals(left.stop, right.stop) &&\n          (left.data === right.data ||\n            (defined(dataComparer) && dataComparer(left.data, right.data))))))\n  );\n};\n\n/**\n * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of\n * each other.  That is, in order for the dates to be considered equal (and for\n * this function to return <code>true</code>), the absolute value of the difference between them, in\n * seconds, must be less than <code>epsilon</code>.\n *\n * @param {TimeInterval} [left] The first instance.\n * @param {TimeInterval} [right] The second instance.\n * @param {Number} epsilon The maximum number of seconds that should separate the two instances.\n * @param {TimeInterval~DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {Boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.\n */\nTimeInterval.equalsEpsilon = function (left, right, epsilon, dataComparer) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"epsilon\", epsilon);\n  //>>includeEnd('debug');\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      ((left.isEmpty && right.isEmpty) ||\n        (left.isStartIncluded === right.isStartIncluded &&\n          left.isStopIncluded === right.isStopIncluded &&\n          JulianDate.equalsEpsilon(left.start, right.start, epsilon) &&\n          JulianDate.equalsEpsilon(left.stop, right.stop, epsilon) &&\n          (left.data === right.data ||\n            (defined(dataComparer) && dataComparer(left.data, right.data))))))\n  );\n};\n\n/**\n * Computes the intersection of two intervals, optionally merging their data.\n *\n * @param {TimeInterval} left The first interval.\n * @param {TimeInterval} [right] The second interval.\n * @param {TimeInterval} result An existing instance to use for the result.\n * @param {TimeInterval~MergeCallback} [mergeCallback] A function which merges the data of the two intervals. If omitted, the data from the left interval will be used.\n * @returns {TimeInterval} The modified result parameter.\n */\nTimeInterval.intersect = function (left, right, result, mergeCallback) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  if (!defined(right)) {\n    return TimeInterval.clone(TimeInterval.EMPTY, result);\n  }\n\n  var leftStart = left.start;\n  var leftStop = left.stop;\n\n  var rightStart = right.start;\n  var rightStop = right.stop;\n\n  var intersectsStartRight =\n    JulianDate.greaterThanOrEquals(rightStart, leftStart) &&\n    JulianDate.greaterThanOrEquals(leftStop, rightStart);\n  var intersectsStartLeft =\n    !intersectsStartRight &&\n    JulianDate.lessThanOrEquals(rightStart, leftStart) &&\n    JulianDate.lessThanOrEquals(leftStart, rightStop);\n\n  if (!intersectsStartRight && !intersectsStartLeft) {\n    return TimeInterval.clone(TimeInterval.EMPTY, result);\n  }\n\n  var leftIsStartIncluded = left.isStartIncluded;\n  var leftIsStopIncluded = left.isStopIncluded;\n  var rightIsStartIncluded = right.isStartIncluded;\n  var rightIsStopIncluded = right.isStopIncluded;\n  var leftLessThanRight = JulianDate.lessThan(leftStop, rightStop);\n\n  result.start = intersectsStartRight ? rightStart : leftStart;\n  result.isStartIncluded =\n    (leftIsStartIncluded && rightIsStartIncluded) ||\n    (!JulianDate.equals(rightStart, leftStart) &&\n      ((intersectsStartRight && rightIsStartIncluded) ||\n        (intersectsStartLeft && leftIsStartIncluded)));\n  result.stop = leftLessThanRight ? leftStop : rightStop;\n  result.isStopIncluded = leftLessThanRight\n    ? leftIsStopIncluded\n    : (leftIsStopIncluded && rightIsStopIncluded) ||\n      (!JulianDate.equals(rightStop, leftStop) && rightIsStopIncluded);\n  result.data = defined(mergeCallback)\n    ? mergeCallback(left.data, right.data)\n    : left.data;\n  return result;\n};\n\n/**\n * Checks if the specified date is inside the provided interval.\n *\n * @param {TimeInterval} timeInterval The interval.\n * @param {JulianDate} julianDate The date to check.\n * @returns {Boolean} <code>true</code> if the interval contains the specified date, <code>false</code> otherwise.\n */\nTimeInterval.contains = function (timeInterval, julianDate) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"timeInterval\", timeInterval);\n  Check.typeOf.object(\"julianDate\", julianDate);\n  //>>includeEnd('debug');\n\n  if (timeInterval.isEmpty) {\n    return false;\n  }\n\n  var startComparedToDate = JulianDate.compare(timeInterval.start, julianDate);\n  if (startComparedToDate === 0) {\n    return timeInterval.isStartIncluded;\n  }\n\n  var dateComparedToStop = JulianDate.compare(julianDate, timeInterval.stop);\n  if (dateComparedToStop === 0) {\n    return timeInterval.isStopIncluded;\n  }\n\n  return startComparedToDate < 0 && dateComparedToStop < 0;\n};\n\n/**\n * Duplicates this instance.\n *\n * @param {TimeInterval} [result] An existing instance to use for the result.\n * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.\n */\nTimeInterval.prototype.clone = function (result) {\n  return TimeInterval.clone(this, result);\n};\n\n/**\n * Compares this instance against the provided instance componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {TimeInterval} [right] The right hand side interval.\n * @param {TimeInterval~DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nTimeInterval.prototype.equals = function (right, dataComparer) {\n  return TimeInterval.equals(this, right, dataComparer);\n};\n\n/**\n * Compares this instance against the provided instance componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {TimeInterval} [right] The right hand side interval.\n * @param {Number} epsilon The epsilon to use for equality testing.\n * @param {TimeInterval~DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nTimeInterval.prototype.equalsEpsilon = function (right, epsilon, dataComparer) {\n  return TimeInterval.equalsEpsilon(this, right, epsilon, dataComparer);\n};\n\n/**\n * Creates a string representing this TimeInterval in ISO8601 format.\n *\n * @returns {String} A string representing this TimeInterval in ISO8601 format.\n */\nTimeInterval.prototype.toString = function () {\n  return TimeInterval.toIso8601(this);\n};\n\n/**\n * An immutable empty interval.\n *\n * @type {TimeInterval}\n * @constant\n */\nTimeInterval.EMPTY = Object.freeze(\n  new TimeInterval({\n    start: new JulianDate(),\n    stop: new JulianDate(),\n    isStartIncluded: false,\n    isStopIncluded: false,\n  })\n);\n\n/**\n * Function interface for merging interval data.\n * @callback TimeInterval~MergeCallback\n *\n * @param {*} leftData The first data instance.\n * @param {*} rightData The second data instance.\n * @returns {*} The result of merging the two data instances.\n */\n\n/**\n * Function interface for comparing interval data.\n * @callback TimeInterval~DataComparer\n * @param {*} leftData The first data instance.\n * @param {*} rightData The second data instance.\n * @returns {Boolean} <code>true</code> if the provided instances are equal, <code>false</code> otherwise.\n */\nexport default TimeInterval;\n"]},"metadata":{},"sourceType":"module"}