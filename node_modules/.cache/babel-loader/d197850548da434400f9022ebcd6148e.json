{"ast":null,"code":"import ArcType from \"./ArcType.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Queue from \"./Queue.js\";\nimport WindingOrder from \"./WindingOrder.js\";\n/**\n * @private\n */\n\nvar PolygonGeometryLibrary = {};\n\nPolygonGeometryLibrary.computeHierarchyPackedLength = function (polygonHierarchy) {\n  var numComponents = 0;\n  var stack = [polygonHierarchy];\n\n  while (stack.length > 0) {\n    var hierarchy = stack.pop();\n\n    if (!defined(hierarchy)) {\n      continue;\n    }\n\n    numComponents += 2;\n    var positions = hierarchy.positions;\n    var holes = hierarchy.holes;\n\n    if (defined(positions)) {\n      numComponents += positions.length * Cartesian3.packedLength;\n    }\n\n    if (defined(holes)) {\n      var length = holes.length;\n\n      for (var i = 0; i < length; ++i) {\n        stack.push(holes[i]);\n      }\n    }\n  }\n\n  return numComponents;\n};\n\nPolygonGeometryLibrary.packPolygonHierarchy = function (polygonHierarchy, array, startingIndex) {\n  var stack = [polygonHierarchy];\n\n  while (stack.length > 0) {\n    var hierarchy = stack.pop();\n\n    if (!defined(hierarchy)) {\n      continue;\n    }\n\n    var positions = hierarchy.positions;\n    var holes = hierarchy.holes;\n    array[startingIndex++] = defined(positions) ? positions.length : 0;\n    array[startingIndex++] = defined(holes) ? holes.length : 0;\n\n    if (defined(positions)) {\n      var positionsLength = positions.length;\n\n      for (var i = 0; i < positionsLength; ++i, startingIndex += 3) {\n        Cartesian3.pack(positions[i], array, startingIndex);\n      }\n    }\n\n    if (defined(holes)) {\n      var holesLength = holes.length;\n\n      for (var j = 0; j < holesLength; ++j) {\n        stack.push(holes[j]);\n      }\n    }\n  }\n\n  return startingIndex;\n};\n\nPolygonGeometryLibrary.unpackPolygonHierarchy = function (array, startingIndex) {\n  var positionsLength = array[startingIndex++];\n  var holesLength = array[startingIndex++];\n  var positions = new Array(positionsLength);\n  var holes = holesLength > 0 ? new Array(holesLength) : undefined;\n\n  for (var i = 0; i < positionsLength; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  for (var j = 0; j < holesLength; ++j) {\n    holes[j] = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);\n    startingIndex = holes[j].startingIndex;\n    delete holes[j].startingIndex;\n  }\n\n  return {\n    positions: positions,\n    holes: holes,\n    startingIndex: startingIndex\n  };\n};\n\nvar distanceScratch = new Cartesian3();\n\nfunction getPointAtDistance(p0, p1, distance, length) {\n  Cartesian3.subtract(p1, p0, distanceScratch);\n  Cartesian3.multiplyByScalar(distanceScratch, distance / length, distanceScratch);\n  Cartesian3.add(p0, distanceScratch, distanceScratch);\n  return [distanceScratch.x, distanceScratch.y, distanceScratch.z];\n}\n\nPolygonGeometryLibrary.subdivideLineCount = function (p0, p1, minDistance) {\n  var distance = Cartesian3.distance(p0, p1);\n  var n = distance / minDistance;\n  var countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\n  return Math.pow(2, countDivide);\n};\n\nvar scratchCartographic0 = new Cartographic();\nvar scratchCartographic1 = new Cartographic();\nvar scratchCartographic2 = new Cartographic();\nvar scratchCartesian0 = new Cartesian3();\n\nPolygonGeometryLibrary.subdivideRhumbLineCount = function (ellipsoid, p0, p1, minDistance) {\n  var c0 = ellipsoid.cartesianToCartographic(p0, scratchCartographic0);\n  var c1 = ellipsoid.cartesianToCartographic(p1, scratchCartographic1);\n  var rhumb = new EllipsoidRhumbLine(c0, c1, ellipsoid);\n  var n = rhumb.surfaceDistance / minDistance;\n  var countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\n  return Math.pow(2, countDivide);\n};\n\nPolygonGeometryLibrary.subdivideLine = function (p0, p1, minDistance, result) {\n  var numVertices = PolygonGeometryLibrary.subdivideLineCount(p0, p1, minDistance);\n  var length = Cartesian3.distance(p0, p1);\n  var distanceBetweenVertices = length / numVertices;\n\n  if (!defined(result)) {\n    result = [];\n  }\n\n  var positions = result;\n  positions.length = numVertices * 3;\n  var index = 0;\n\n  for (var i = 0; i < numVertices; i++) {\n    var p = getPointAtDistance(p0, p1, i * distanceBetweenVertices, length);\n    positions[index++] = p[0];\n    positions[index++] = p[1];\n    positions[index++] = p[2];\n  }\n\n  return positions;\n};\n\nPolygonGeometryLibrary.subdivideRhumbLine = function (ellipsoid, p0, p1, minDistance, result) {\n  var c0 = ellipsoid.cartesianToCartographic(p0, scratchCartographic0);\n  var c1 = ellipsoid.cartesianToCartographic(p1, scratchCartographic1);\n  var rhumb = new EllipsoidRhumbLine(c0, c1, ellipsoid);\n  var n = rhumb.surfaceDistance / minDistance;\n  var countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\n  var numVertices = Math.pow(2, countDivide);\n  var distanceBetweenVertices = rhumb.surfaceDistance / numVertices;\n\n  if (!defined(result)) {\n    result = [];\n  }\n\n  var positions = result;\n  positions.length = numVertices * 3;\n  var index = 0;\n\n  for (var i = 0; i < numVertices; i++) {\n    var c = rhumb.interpolateUsingSurfaceDistance(i * distanceBetweenVertices, scratchCartographic2);\n    var p = ellipsoid.cartographicToCartesian(c, scratchCartesian0);\n    positions[index++] = p.x;\n    positions[index++] = p.y;\n    positions[index++] = p.z;\n  }\n\n  return positions;\n};\n\nvar scaleToGeodeticHeightN1 = new Cartesian3();\nvar scaleToGeodeticHeightN2 = new Cartesian3();\nvar scaleToGeodeticHeightP1 = new Cartesian3();\nvar scaleToGeodeticHeightP2 = new Cartesian3();\n\nPolygonGeometryLibrary.scaleToGeodeticHeightExtruded = function (geometry, maxHeight, minHeight, ellipsoid, perPositionHeight) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  var n1 = scaleToGeodeticHeightN1;\n  var n2 = scaleToGeodeticHeightN2;\n  var p = scaleToGeodeticHeightP1;\n  var p2 = scaleToGeodeticHeightP2;\n\n  if (defined(geometry) && defined(geometry.attributes) && defined(geometry.attributes.position)) {\n    var positions = geometry.attributes.position.values;\n    var length = positions.length / 2;\n\n    for (var i = 0; i < length; i += 3) {\n      Cartesian3.fromArray(positions, i, p);\n      ellipsoid.geodeticSurfaceNormal(p, n1);\n      p2 = ellipsoid.scaleToGeodeticSurface(p, p2);\n      n2 = Cartesian3.multiplyByScalar(n1, minHeight, n2);\n      n2 = Cartesian3.add(p2, n2, n2);\n      positions[i + length] = n2.x;\n      positions[i + 1 + length] = n2.y;\n      positions[i + 2 + length] = n2.z;\n\n      if (perPositionHeight) {\n        p2 = Cartesian3.clone(p, p2);\n      }\n\n      n2 = Cartesian3.multiplyByScalar(n1, maxHeight, n2);\n      n2 = Cartesian3.add(p2, n2, n2);\n      positions[i] = n2.x;\n      positions[i + 1] = n2.y;\n      positions[i + 2] = n2.z;\n    }\n  }\n\n  return geometry;\n};\n\nPolygonGeometryLibrary.polygonOutlinesFromHierarchy = function (polygonHierarchy, scaleToEllipsoidSurface, ellipsoid) {\n  // create from a polygon hierarchy\n  // Algorithm adapted from http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\n  var polygons = [];\n  var queue = new Queue();\n  queue.enqueue(polygonHierarchy);\n  var i;\n  var j;\n  var length;\n\n  while (queue.length !== 0) {\n    var outerNode = queue.dequeue();\n    var outerRing = outerNode.positions;\n\n    if (scaleToEllipsoidSurface) {\n      length = outerRing.length;\n\n      for (i = 0; i < length; i++) {\n        ellipsoid.scaleToGeodeticSurface(outerRing[i], outerRing[i]);\n      }\n    }\n\n    outerRing = arrayRemoveDuplicates(outerRing, Cartesian3.equalsEpsilon, true);\n\n    if (outerRing.length < 3) {\n      continue;\n    }\n\n    var numChildren = outerNode.holes ? outerNode.holes.length : 0; // The outer polygon contains inner polygons\n\n    for (i = 0; i < numChildren; i++) {\n      var hole = outerNode.holes[i];\n      var holePositions = hole.positions;\n\n      if (scaleToEllipsoidSurface) {\n        length = holePositions.length;\n\n        for (j = 0; j < length; ++j) {\n          ellipsoid.scaleToGeodeticSurface(holePositions[j], holePositions[j]);\n        }\n      }\n\n      holePositions = arrayRemoveDuplicates(holePositions, Cartesian3.equalsEpsilon, true);\n\n      if (holePositions.length < 3) {\n        continue;\n      }\n\n      polygons.push(holePositions);\n      var numGrandchildren = 0;\n\n      if (defined(hole.holes)) {\n        numGrandchildren = hole.holes.length;\n      }\n\n      for (j = 0; j < numGrandchildren; j++) {\n        queue.enqueue(hole.holes[j]);\n      }\n    }\n\n    polygons.push(outerRing);\n  }\n\n  return polygons;\n};\n\nPolygonGeometryLibrary.polygonsFromHierarchy = function (polygonHierarchy, projectPointsTo2D, scaleToEllipsoidSurface, ellipsoid) {\n  // create from a polygon hierarchy\n  // Algorithm adapted from http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\n  var hierarchy = [];\n  var polygons = [];\n  var queue = new Queue();\n  queue.enqueue(polygonHierarchy);\n\n  while (queue.length !== 0) {\n    var outerNode = queue.dequeue();\n    var outerRing = outerNode.positions;\n    var holes = outerNode.holes;\n    var i;\n    var length;\n\n    if (scaleToEllipsoidSurface) {\n      length = outerRing.length;\n\n      for (i = 0; i < length; i++) {\n        ellipsoid.scaleToGeodeticSurface(outerRing[i], outerRing[i]);\n      }\n    }\n\n    outerRing = arrayRemoveDuplicates(outerRing, Cartesian3.equalsEpsilon, true);\n\n    if (outerRing.length < 3) {\n      continue;\n    }\n\n    var positions2D = projectPointsTo2D(outerRing);\n\n    if (!defined(positions2D)) {\n      continue;\n    }\n\n    var holeIndices = [];\n    var originalWindingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n\n    if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n      positions2D.reverse();\n      outerRing = outerRing.slice().reverse();\n    }\n\n    var positions = outerRing.slice();\n    var numChildren = defined(holes) ? holes.length : 0;\n    var polygonHoles = [];\n    var j;\n\n    for (i = 0; i < numChildren; i++) {\n      var hole = holes[i];\n      var holePositions = hole.positions;\n\n      if (scaleToEllipsoidSurface) {\n        length = holePositions.length;\n\n        for (j = 0; j < length; ++j) {\n          ellipsoid.scaleToGeodeticSurface(holePositions[j], holePositions[j]);\n        }\n      }\n\n      holePositions = arrayRemoveDuplicates(holePositions, Cartesian3.equalsEpsilon, true);\n\n      if (holePositions.length < 3) {\n        continue;\n      }\n\n      var holePositions2D = projectPointsTo2D(holePositions);\n\n      if (!defined(holePositions2D)) {\n        continue;\n      }\n\n      originalWindingOrder = PolygonPipeline.computeWindingOrder2D(holePositions2D);\n\n      if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n        holePositions2D.reverse();\n        holePositions = holePositions.slice().reverse();\n      }\n\n      polygonHoles.push(holePositions);\n      holeIndices.push(positions.length);\n      positions = positions.concat(holePositions);\n      positions2D = positions2D.concat(holePositions2D);\n      var numGrandchildren = 0;\n\n      if (defined(hole.holes)) {\n        numGrandchildren = hole.holes.length;\n      }\n\n      for (j = 0; j < numGrandchildren; j++) {\n        queue.enqueue(hole.holes[j]);\n      }\n    }\n\n    hierarchy.push({\n      outerRing: outerRing,\n      holes: polygonHoles\n    });\n    polygons.push({\n      positions: positions,\n      positions2D: positions2D,\n      holes: holeIndices\n    });\n  }\n\n  return {\n    hierarchy: hierarchy,\n    polygons: polygons\n  };\n};\n\nvar computeBoundingRectangleCartesian2 = new Cartesian2();\nvar computeBoundingRectangleCartesian3 = new Cartesian3();\nvar computeBoundingRectangleQuaternion = new Quaternion();\nvar computeBoundingRectangleMatrix3 = new Matrix3();\n\nPolygonGeometryLibrary.computeBoundingRectangle = function (planeNormal, projectPointTo2D, positions, angle, result) {\n  var rotation = Quaternion.fromAxisAngle(planeNormal, angle, computeBoundingRectangleQuaternion);\n  var textureMatrix = Matrix3.fromQuaternion(rotation, computeBoundingRectangleMatrix3);\n  var minX = Number.POSITIVE_INFINITY;\n  var maxX = Number.NEGATIVE_INFINITY;\n  var minY = Number.POSITIVE_INFINITY;\n  var maxY = Number.NEGATIVE_INFINITY;\n  var length = positions.length;\n\n  for (var i = 0; i < length; ++i) {\n    var p = Cartesian3.clone(positions[i], computeBoundingRectangleCartesian3);\n    Matrix3.multiplyByVector(textureMatrix, p, p);\n    var st = projectPointTo2D(p, computeBoundingRectangleCartesian2);\n\n    if (defined(st)) {\n      minX = Math.min(minX, st.x);\n      maxX = Math.max(maxX, st.x);\n      minY = Math.min(minY, st.y);\n      maxY = Math.max(maxY, st.y);\n    }\n  }\n\n  result.x = minX;\n  result.y = minY;\n  result.width = maxX - minX;\n  result.height = maxY - minY;\n  return result;\n};\n\nPolygonGeometryLibrary.createGeometryFromPositions = function (ellipsoid, polygon, granularity, perPositionHeight, vertexFormat, arcType) {\n  var indices = PolygonPipeline.triangulate(polygon.positions2D, polygon.holes);\n  /* If polygon is completely unrenderable, just use the first three vertices */\n\n  if (indices.length < 3) {\n    indices = [0, 1, 2];\n  }\n\n  var positions = polygon.positions;\n\n  if (perPositionHeight) {\n    var length = positions.length;\n    var flattenedPositions = new Array(length * 3);\n    var index = 0;\n\n    for (var i = 0; i < length; i++) {\n      var p = positions[i];\n      flattenedPositions[index++] = p.x;\n      flattenedPositions[index++] = p.y;\n      flattenedPositions[index++] = p.z;\n    }\n\n    var geometry = new Geometry({\n      attributes: {\n        position: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.DOUBLE,\n          componentsPerAttribute: 3,\n          values: flattenedPositions\n        })\n      },\n      indices: indices,\n      primitiveType: PrimitiveType.TRIANGLES\n    });\n\n    if (vertexFormat.normal) {\n      return GeometryPipeline.computeNormal(geometry);\n    }\n\n    return geometry;\n  }\n\n  if (arcType === ArcType.GEODESIC) {\n    return PolygonPipeline.computeSubdivision(ellipsoid, positions, indices, granularity);\n  } else if (arcType === ArcType.RHUMB) {\n    return PolygonPipeline.computeRhumbLineSubdivision(ellipsoid, positions, indices, granularity);\n  }\n};\n\nvar computeWallIndicesSubdivided = [];\nvar p1Scratch = new Cartesian3();\nvar p2Scratch = new Cartesian3();\n\nPolygonGeometryLibrary.computeWallGeometry = function (positions, ellipsoid, granularity, perPositionHeight, arcType) {\n  var edgePositions;\n  var topEdgeLength;\n  var i;\n  var p1;\n  var p2;\n  var length = positions.length;\n  var index = 0;\n\n  if (!perPositionHeight) {\n    var minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n    var numVertices = 0;\n\n    if (arcType === ArcType.GEODESIC) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideLineCount(positions[i], positions[(i + 1) % length], minDistance);\n      }\n    } else if (arcType === ArcType.RHUMB) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(ellipsoid, positions[i], positions[(i + 1) % length], minDistance);\n      }\n    }\n\n    topEdgeLength = (numVertices + length) * 3;\n    edgePositions = new Array(topEdgeLength * 2);\n\n    for (i = 0; i < length; i++) {\n      p1 = positions[i];\n      p2 = positions[(i + 1) % length];\n      var tempPositions;\n\n      if (arcType === ArcType.GEODESIC) {\n        tempPositions = PolygonGeometryLibrary.subdivideLine(p1, p2, minDistance, computeWallIndicesSubdivided);\n      } else if (arcType === ArcType.RHUMB) {\n        tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(ellipsoid, p1, p2, minDistance, computeWallIndicesSubdivided);\n      }\n\n      var tempPositionsLength = tempPositions.length;\n\n      for (var j = 0; j < tempPositionsLength; ++j, ++index) {\n        edgePositions[index] = tempPositions[j];\n        edgePositions[index + topEdgeLength] = tempPositions[j];\n      }\n\n      edgePositions[index] = p2.x;\n      edgePositions[index + topEdgeLength] = p2.x;\n      ++index;\n      edgePositions[index] = p2.y;\n      edgePositions[index + topEdgeLength] = p2.y;\n      ++index;\n      edgePositions[index] = p2.z;\n      edgePositions[index + topEdgeLength] = p2.z;\n      ++index;\n    }\n  } else {\n    topEdgeLength = length * 3 * 2;\n    edgePositions = new Array(topEdgeLength * 2);\n\n    for (i = 0; i < length; i++) {\n      p1 = positions[i];\n      p2 = positions[(i + 1) % length];\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.x;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.y;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.z;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.x;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.y;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.z;\n      ++index;\n    }\n  }\n\n  length = edgePositions.length;\n  var indices = IndexDatatype.createTypedArray(length / 3, length - positions.length * 6);\n  var edgeIndex = 0;\n  length /= 6;\n\n  for (i = 0; i < length; i++) {\n    var UL = i;\n    var UR = UL + 1;\n    var LL = UL + length;\n    var LR = LL + 1;\n    p1 = Cartesian3.fromArray(edgePositions, UL * 3, p1Scratch);\n    p2 = Cartesian3.fromArray(edgePositions, UR * 3, p2Scratch);\n\n    if (Cartesian3.equalsEpsilon(p1, p2, CesiumMath.EPSILON10, CesiumMath.EPSILON10)) {\n      //skip corner\n      continue;\n    }\n\n    indices[edgeIndex++] = UL;\n    indices[edgeIndex++] = LL;\n    indices[edgeIndex++] = UR;\n    indices[edgeIndex++] = UR;\n    indices[edgeIndex++] = LL;\n    indices[edgeIndex++] = LR;\n  }\n\n  return new Geometry({\n    attributes: new GeometryAttributes({\n      position: new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: edgePositions\n      })\n    }),\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES\n  });\n};\n\nexport default PolygonGeometryLibrary;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/PolygonGeometryLibrary.js"],"names":["ArcType","arrayRemoveDuplicates","Cartesian2","Cartesian3","Cartographic","ComponentDatatype","defaultValue","defined","Ellipsoid","EllipsoidRhumbLine","Geometry","GeometryAttribute","GeometryAttributes","GeometryPipeline","IndexDatatype","CesiumMath","Matrix3","PolygonPipeline","PrimitiveType","Quaternion","Queue","WindingOrder","PolygonGeometryLibrary","computeHierarchyPackedLength","polygonHierarchy","numComponents","stack","length","hierarchy","pop","positions","holes","packedLength","i","push","packPolygonHierarchy","array","startingIndex","positionsLength","pack","holesLength","j","unpackPolygonHierarchy","Array","undefined","unpack","distanceScratch","getPointAtDistance","p0","p1","distance","subtract","multiplyByScalar","add","x","y","z","subdivideLineCount","minDistance","n","countDivide","Math","max","ceil","log2","pow","scratchCartographic0","scratchCartographic1","scratchCartographic2","scratchCartesian0","subdivideRhumbLineCount","ellipsoid","c0","cartesianToCartographic","c1","rhumb","surfaceDistance","subdivideLine","result","numVertices","distanceBetweenVertices","index","p","subdivideRhumbLine","c","interpolateUsingSurfaceDistance","cartographicToCartesian","scaleToGeodeticHeightN1","scaleToGeodeticHeightN2","scaleToGeodeticHeightP1","scaleToGeodeticHeightP2","scaleToGeodeticHeightExtruded","geometry","maxHeight","minHeight","perPositionHeight","WGS84","n1","n2","p2","attributes","position","values","fromArray","geodeticSurfaceNormal","scaleToGeodeticSurface","clone","polygonOutlinesFromHierarchy","scaleToEllipsoidSurface","polygons","queue","enqueue","outerNode","dequeue","outerRing","equalsEpsilon","numChildren","hole","holePositions","numGrandchildren","polygonsFromHierarchy","projectPointsTo2D","positions2D","holeIndices","originalWindingOrder","computeWindingOrder2D","CLOCKWISE","reverse","slice","polygonHoles","holePositions2D","concat","computeBoundingRectangleCartesian2","computeBoundingRectangleCartesian3","computeBoundingRectangleQuaternion","computeBoundingRectangleMatrix3","computeBoundingRectangle","planeNormal","projectPointTo2D","angle","rotation","fromAxisAngle","textureMatrix","fromQuaternion","minX","Number","POSITIVE_INFINITY","maxX","NEGATIVE_INFINITY","minY","maxY","multiplyByVector","st","min","width","height","createGeometryFromPositions","polygon","granularity","vertexFormat","arcType","indices","triangulate","flattenedPositions","componentDatatype","DOUBLE","componentsPerAttribute","primitiveType","TRIANGLES","normal","computeNormal","GEODESIC","computeSubdivision","RHUMB","computeRhumbLineSubdivision","computeWallIndicesSubdivided","p1Scratch","p2Scratch","computeWallGeometry","edgePositions","topEdgeLength","chordLength","maximumRadius","tempPositions","tempPositionsLength","createTypedArray","edgeIndex","UL","UR","LL","LR","EPSILON10"],"mappings":"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","sourcesContent":["import ArcType from \"./ArcType.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Queue from \"./Queue.js\";\nimport WindingOrder from \"./WindingOrder.js\";\n\n/**\n * @private\n */\nvar PolygonGeometryLibrary = {};\n\nPolygonGeometryLibrary.computeHierarchyPackedLength = function (\n  polygonHierarchy\n) {\n  var numComponents = 0;\n  var stack = [polygonHierarchy];\n  while (stack.length > 0) {\n    var hierarchy = stack.pop();\n    if (!defined(hierarchy)) {\n      continue;\n    }\n\n    numComponents += 2;\n\n    var positions = hierarchy.positions;\n    var holes = hierarchy.holes;\n\n    if (defined(positions)) {\n      numComponents += positions.length * Cartesian3.packedLength;\n    }\n\n    if (defined(holes)) {\n      var length = holes.length;\n      for (var i = 0; i < length; ++i) {\n        stack.push(holes[i]);\n      }\n    }\n  }\n\n  return numComponents;\n};\n\nPolygonGeometryLibrary.packPolygonHierarchy = function (\n  polygonHierarchy,\n  array,\n  startingIndex\n) {\n  var stack = [polygonHierarchy];\n  while (stack.length > 0) {\n    var hierarchy = stack.pop();\n    if (!defined(hierarchy)) {\n      continue;\n    }\n\n    var positions = hierarchy.positions;\n    var holes = hierarchy.holes;\n\n    array[startingIndex++] = defined(positions) ? positions.length : 0;\n    array[startingIndex++] = defined(holes) ? holes.length : 0;\n\n    if (defined(positions)) {\n      var positionsLength = positions.length;\n      for (var i = 0; i < positionsLength; ++i, startingIndex += 3) {\n        Cartesian3.pack(positions[i], array, startingIndex);\n      }\n    }\n\n    if (defined(holes)) {\n      var holesLength = holes.length;\n      for (var j = 0; j < holesLength; ++j) {\n        stack.push(holes[j]);\n      }\n    }\n  }\n\n  return startingIndex;\n};\n\nPolygonGeometryLibrary.unpackPolygonHierarchy = function (\n  array,\n  startingIndex\n) {\n  var positionsLength = array[startingIndex++];\n  var holesLength = array[startingIndex++];\n\n  var positions = new Array(positionsLength);\n  var holes = holesLength > 0 ? new Array(holesLength) : undefined;\n\n  for (\n    var i = 0;\n    i < positionsLength;\n    ++i, startingIndex += Cartesian3.packedLength\n  ) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  for (var j = 0; j < holesLength; ++j) {\n    holes[j] = PolygonGeometryLibrary.unpackPolygonHierarchy(\n      array,\n      startingIndex\n    );\n    startingIndex = holes[j].startingIndex;\n    delete holes[j].startingIndex;\n  }\n\n  return {\n    positions: positions,\n    holes: holes,\n    startingIndex: startingIndex,\n  };\n};\n\nvar distanceScratch = new Cartesian3();\nfunction getPointAtDistance(p0, p1, distance, length) {\n  Cartesian3.subtract(p1, p0, distanceScratch);\n  Cartesian3.multiplyByScalar(\n    distanceScratch,\n    distance / length,\n    distanceScratch\n  );\n  Cartesian3.add(p0, distanceScratch, distanceScratch);\n  return [distanceScratch.x, distanceScratch.y, distanceScratch.z];\n}\n\nPolygonGeometryLibrary.subdivideLineCount = function (p0, p1, minDistance) {\n  var distance = Cartesian3.distance(p0, p1);\n  var n = distance / minDistance;\n  var countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\n  return Math.pow(2, countDivide);\n};\n\nvar scratchCartographic0 = new Cartographic();\nvar scratchCartographic1 = new Cartographic();\nvar scratchCartographic2 = new Cartographic();\nvar scratchCartesian0 = new Cartesian3();\nPolygonGeometryLibrary.subdivideRhumbLineCount = function (\n  ellipsoid,\n  p0,\n  p1,\n  minDistance\n) {\n  var c0 = ellipsoid.cartesianToCartographic(p0, scratchCartographic0);\n  var c1 = ellipsoid.cartesianToCartographic(p1, scratchCartographic1);\n  var rhumb = new EllipsoidRhumbLine(c0, c1, ellipsoid);\n  var n = rhumb.surfaceDistance / minDistance;\n  var countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\n  return Math.pow(2, countDivide);\n};\n\nPolygonGeometryLibrary.subdivideLine = function (p0, p1, minDistance, result) {\n  var numVertices = PolygonGeometryLibrary.subdivideLineCount(\n    p0,\n    p1,\n    minDistance\n  );\n  var length = Cartesian3.distance(p0, p1);\n  var distanceBetweenVertices = length / numVertices;\n\n  if (!defined(result)) {\n    result = [];\n  }\n\n  var positions = result;\n  positions.length = numVertices * 3;\n\n  var index = 0;\n  for (var i = 0; i < numVertices; i++) {\n    var p = getPointAtDistance(p0, p1, i * distanceBetweenVertices, length);\n    positions[index++] = p[0];\n    positions[index++] = p[1];\n    positions[index++] = p[2];\n  }\n\n  return positions;\n};\n\nPolygonGeometryLibrary.subdivideRhumbLine = function (\n  ellipsoid,\n  p0,\n  p1,\n  minDistance,\n  result\n) {\n  var c0 = ellipsoid.cartesianToCartographic(p0, scratchCartographic0);\n  var c1 = ellipsoid.cartesianToCartographic(p1, scratchCartographic1);\n  var rhumb = new EllipsoidRhumbLine(c0, c1, ellipsoid);\n\n  var n = rhumb.surfaceDistance / minDistance;\n  var countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\n  var numVertices = Math.pow(2, countDivide);\n  var distanceBetweenVertices = rhumb.surfaceDistance / numVertices;\n\n  if (!defined(result)) {\n    result = [];\n  }\n\n  var positions = result;\n  positions.length = numVertices * 3;\n\n  var index = 0;\n  for (var i = 0; i < numVertices; i++) {\n    var c = rhumb.interpolateUsingSurfaceDistance(\n      i * distanceBetweenVertices,\n      scratchCartographic2\n    );\n    var p = ellipsoid.cartographicToCartesian(c, scratchCartesian0);\n    positions[index++] = p.x;\n    positions[index++] = p.y;\n    positions[index++] = p.z;\n  }\n\n  return positions;\n};\n\nvar scaleToGeodeticHeightN1 = new Cartesian3();\nvar scaleToGeodeticHeightN2 = new Cartesian3();\nvar scaleToGeodeticHeightP1 = new Cartesian3();\nvar scaleToGeodeticHeightP2 = new Cartesian3();\n\nPolygonGeometryLibrary.scaleToGeodeticHeightExtruded = function (\n  geometry,\n  maxHeight,\n  minHeight,\n  ellipsoid,\n  perPositionHeight\n) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  var n1 = scaleToGeodeticHeightN1;\n  var n2 = scaleToGeodeticHeightN2;\n  var p = scaleToGeodeticHeightP1;\n  var p2 = scaleToGeodeticHeightP2;\n\n  if (\n    defined(geometry) &&\n    defined(geometry.attributes) &&\n    defined(geometry.attributes.position)\n  ) {\n    var positions = geometry.attributes.position.values;\n    var length = positions.length / 2;\n\n    for (var i = 0; i < length; i += 3) {\n      Cartesian3.fromArray(positions, i, p);\n\n      ellipsoid.geodeticSurfaceNormal(p, n1);\n      p2 = ellipsoid.scaleToGeodeticSurface(p, p2);\n      n2 = Cartesian3.multiplyByScalar(n1, minHeight, n2);\n      n2 = Cartesian3.add(p2, n2, n2);\n      positions[i + length] = n2.x;\n      positions[i + 1 + length] = n2.y;\n      positions[i + 2 + length] = n2.z;\n\n      if (perPositionHeight) {\n        p2 = Cartesian3.clone(p, p2);\n      }\n      n2 = Cartesian3.multiplyByScalar(n1, maxHeight, n2);\n      n2 = Cartesian3.add(p2, n2, n2);\n      positions[i] = n2.x;\n      positions[i + 1] = n2.y;\n      positions[i + 2] = n2.z;\n    }\n  }\n  return geometry;\n};\n\nPolygonGeometryLibrary.polygonOutlinesFromHierarchy = function (\n  polygonHierarchy,\n  scaleToEllipsoidSurface,\n  ellipsoid\n) {\n  // create from a polygon hierarchy\n  // Algorithm adapted from http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\n  var polygons = [];\n  var queue = new Queue();\n  queue.enqueue(polygonHierarchy);\n  var i;\n  var j;\n  var length;\n  while (queue.length !== 0) {\n    var outerNode = queue.dequeue();\n    var outerRing = outerNode.positions;\n    if (scaleToEllipsoidSurface) {\n      length = outerRing.length;\n      for (i = 0; i < length; i++) {\n        ellipsoid.scaleToGeodeticSurface(outerRing[i], outerRing[i]);\n      }\n    }\n    outerRing = arrayRemoveDuplicates(\n      outerRing,\n      Cartesian3.equalsEpsilon,\n      true\n    );\n    if (outerRing.length < 3) {\n      continue;\n    }\n\n    var numChildren = outerNode.holes ? outerNode.holes.length : 0;\n    // The outer polygon contains inner polygons\n    for (i = 0; i < numChildren; i++) {\n      var hole = outerNode.holes[i];\n      var holePositions = hole.positions;\n      if (scaleToEllipsoidSurface) {\n        length = holePositions.length;\n        for (j = 0; j < length; ++j) {\n          ellipsoid.scaleToGeodeticSurface(holePositions[j], holePositions[j]);\n        }\n      }\n      holePositions = arrayRemoveDuplicates(\n        holePositions,\n        Cartesian3.equalsEpsilon,\n        true\n      );\n      if (holePositions.length < 3) {\n        continue;\n      }\n      polygons.push(holePositions);\n\n      var numGrandchildren = 0;\n      if (defined(hole.holes)) {\n        numGrandchildren = hole.holes.length;\n      }\n\n      for (j = 0; j < numGrandchildren; j++) {\n        queue.enqueue(hole.holes[j]);\n      }\n    }\n\n    polygons.push(outerRing);\n  }\n\n  return polygons;\n};\n\nPolygonGeometryLibrary.polygonsFromHierarchy = function (\n  polygonHierarchy,\n  projectPointsTo2D,\n  scaleToEllipsoidSurface,\n  ellipsoid\n) {\n  // create from a polygon hierarchy\n  // Algorithm adapted from http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\n  var hierarchy = [];\n  var polygons = [];\n\n  var queue = new Queue();\n  queue.enqueue(polygonHierarchy);\n\n  while (queue.length !== 0) {\n    var outerNode = queue.dequeue();\n    var outerRing = outerNode.positions;\n    var holes = outerNode.holes;\n\n    var i;\n    var length;\n    if (scaleToEllipsoidSurface) {\n      length = outerRing.length;\n      for (i = 0; i < length; i++) {\n        ellipsoid.scaleToGeodeticSurface(outerRing[i], outerRing[i]);\n      }\n    }\n\n    outerRing = arrayRemoveDuplicates(\n      outerRing,\n      Cartesian3.equalsEpsilon,\n      true\n    );\n    if (outerRing.length < 3) {\n      continue;\n    }\n\n    var positions2D = projectPointsTo2D(outerRing);\n    if (!defined(positions2D)) {\n      continue;\n    }\n    var holeIndices = [];\n\n    var originalWindingOrder = PolygonPipeline.computeWindingOrder2D(\n      positions2D\n    );\n    if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n      positions2D.reverse();\n      outerRing = outerRing.slice().reverse();\n    }\n\n    var positions = outerRing.slice();\n    var numChildren = defined(holes) ? holes.length : 0;\n    var polygonHoles = [];\n    var j;\n\n    for (i = 0; i < numChildren; i++) {\n      var hole = holes[i];\n      var holePositions = hole.positions;\n      if (scaleToEllipsoidSurface) {\n        length = holePositions.length;\n        for (j = 0; j < length; ++j) {\n          ellipsoid.scaleToGeodeticSurface(holePositions[j], holePositions[j]);\n        }\n      }\n\n      holePositions = arrayRemoveDuplicates(\n        holePositions,\n        Cartesian3.equalsEpsilon,\n        true\n      );\n      if (holePositions.length < 3) {\n        continue;\n      }\n\n      var holePositions2D = projectPointsTo2D(holePositions);\n      if (!defined(holePositions2D)) {\n        continue;\n      }\n\n      originalWindingOrder = PolygonPipeline.computeWindingOrder2D(\n        holePositions2D\n      );\n      if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n        holePositions2D.reverse();\n        holePositions = holePositions.slice().reverse();\n      }\n\n      polygonHoles.push(holePositions);\n      holeIndices.push(positions.length);\n      positions = positions.concat(holePositions);\n      positions2D = positions2D.concat(holePositions2D);\n\n      var numGrandchildren = 0;\n      if (defined(hole.holes)) {\n        numGrandchildren = hole.holes.length;\n      }\n\n      for (j = 0; j < numGrandchildren; j++) {\n        queue.enqueue(hole.holes[j]);\n      }\n    }\n\n    hierarchy.push({\n      outerRing: outerRing,\n      holes: polygonHoles,\n    });\n    polygons.push({\n      positions: positions,\n      positions2D: positions2D,\n      holes: holeIndices,\n    });\n  }\n\n  return {\n    hierarchy: hierarchy,\n    polygons: polygons,\n  };\n};\n\nvar computeBoundingRectangleCartesian2 = new Cartesian2();\nvar computeBoundingRectangleCartesian3 = new Cartesian3();\nvar computeBoundingRectangleQuaternion = new Quaternion();\nvar computeBoundingRectangleMatrix3 = new Matrix3();\nPolygonGeometryLibrary.computeBoundingRectangle = function (\n  planeNormal,\n  projectPointTo2D,\n  positions,\n  angle,\n  result\n) {\n  var rotation = Quaternion.fromAxisAngle(\n    planeNormal,\n    angle,\n    computeBoundingRectangleQuaternion\n  );\n  var textureMatrix = Matrix3.fromQuaternion(\n    rotation,\n    computeBoundingRectangleMatrix3\n  );\n\n  var minX = Number.POSITIVE_INFINITY;\n  var maxX = Number.NEGATIVE_INFINITY;\n  var minY = Number.POSITIVE_INFINITY;\n  var maxY = Number.NEGATIVE_INFINITY;\n\n  var length = positions.length;\n  for (var i = 0; i < length; ++i) {\n    var p = Cartesian3.clone(positions[i], computeBoundingRectangleCartesian3);\n    Matrix3.multiplyByVector(textureMatrix, p, p);\n    var st = projectPointTo2D(p, computeBoundingRectangleCartesian2);\n\n    if (defined(st)) {\n      minX = Math.min(minX, st.x);\n      maxX = Math.max(maxX, st.x);\n\n      minY = Math.min(minY, st.y);\n      maxY = Math.max(maxY, st.y);\n    }\n  }\n\n  result.x = minX;\n  result.y = minY;\n  result.width = maxX - minX;\n  result.height = maxY - minY;\n  return result;\n};\n\nPolygonGeometryLibrary.createGeometryFromPositions = function (\n  ellipsoid,\n  polygon,\n  granularity,\n  perPositionHeight,\n  vertexFormat,\n  arcType\n) {\n  var indices = PolygonPipeline.triangulate(polygon.positions2D, polygon.holes);\n\n  /* If polygon is completely unrenderable, just use the first three vertices */\n  if (indices.length < 3) {\n    indices = [0, 1, 2];\n  }\n\n  var positions = polygon.positions;\n\n  if (perPositionHeight) {\n    var length = positions.length;\n    var flattenedPositions = new Array(length * 3);\n    var index = 0;\n    for (var i = 0; i < length; i++) {\n      var p = positions[i];\n      flattenedPositions[index++] = p.x;\n      flattenedPositions[index++] = p.y;\n      flattenedPositions[index++] = p.z;\n    }\n    var geometry = new Geometry({\n      attributes: {\n        position: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.DOUBLE,\n          componentsPerAttribute: 3,\n          values: flattenedPositions,\n        }),\n      },\n      indices: indices,\n      primitiveType: PrimitiveType.TRIANGLES,\n    });\n\n    if (vertexFormat.normal) {\n      return GeometryPipeline.computeNormal(geometry);\n    }\n\n    return geometry;\n  }\n\n  if (arcType === ArcType.GEODESIC) {\n    return PolygonPipeline.computeSubdivision(\n      ellipsoid,\n      positions,\n      indices,\n      granularity\n    );\n  } else if (arcType === ArcType.RHUMB) {\n    return PolygonPipeline.computeRhumbLineSubdivision(\n      ellipsoid,\n      positions,\n      indices,\n      granularity\n    );\n  }\n};\n\nvar computeWallIndicesSubdivided = [];\nvar p1Scratch = new Cartesian3();\nvar p2Scratch = new Cartesian3();\n\nPolygonGeometryLibrary.computeWallGeometry = function (\n  positions,\n  ellipsoid,\n  granularity,\n  perPositionHeight,\n  arcType\n) {\n  var edgePositions;\n  var topEdgeLength;\n  var i;\n  var p1;\n  var p2;\n\n  var length = positions.length;\n  var index = 0;\n\n  if (!perPositionHeight) {\n    var minDistance = CesiumMath.chordLength(\n      granularity,\n      ellipsoid.maximumRadius\n    );\n\n    var numVertices = 0;\n    if (arcType === ArcType.GEODESIC) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideLineCount(\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance\n        );\n      }\n    } else if (arcType === ArcType.RHUMB) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(\n          ellipsoid,\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance\n        );\n      }\n    }\n\n    topEdgeLength = (numVertices + length) * 3;\n    edgePositions = new Array(topEdgeLength * 2);\n    for (i = 0; i < length; i++) {\n      p1 = positions[i];\n      p2 = positions[(i + 1) % length];\n\n      var tempPositions;\n      if (arcType === ArcType.GEODESIC) {\n        tempPositions = PolygonGeometryLibrary.subdivideLine(\n          p1,\n          p2,\n          minDistance,\n          computeWallIndicesSubdivided\n        );\n      } else if (arcType === ArcType.RHUMB) {\n        tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(\n          ellipsoid,\n          p1,\n          p2,\n          minDistance,\n          computeWallIndicesSubdivided\n        );\n      }\n      var tempPositionsLength = tempPositions.length;\n      for (var j = 0; j < tempPositionsLength; ++j, ++index) {\n        edgePositions[index] = tempPositions[j];\n        edgePositions[index + topEdgeLength] = tempPositions[j];\n      }\n\n      edgePositions[index] = p2.x;\n      edgePositions[index + topEdgeLength] = p2.x;\n      ++index;\n\n      edgePositions[index] = p2.y;\n      edgePositions[index + topEdgeLength] = p2.y;\n      ++index;\n\n      edgePositions[index] = p2.z;\n      edgePositions[index + topEdgeLength] = p2.z;\n      ++index;\n    }\n  } else {\n    topEdgeLength = length * 3 * 2;\n    edgePositions = new Array(topEdgeLength * 2);\n    for (i = 0; i < length; i++) {\n      p1 = positions[i];\n      p2 = positions[(i + 1) % length];\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.x;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.y;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.z;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.x;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.y;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.z;\n      ++index;\n    }\n  }\n\n  length = edgePositions.length;\n  var indices = IndexDatatype.createTypedArray(\n    length / 3,\n    length - positions.length * 6\n  );\n  var edgeIndex = 0;\n  length /= 6;\n\n  for (i = 0; i < length; i++) {\n    var UL = i;\n    var UR = UL + 1;\n    var LL = UL + length;\n    var LR = LL + 1;\n\n    p1 = Cartesian3.fromArray(edgePositions, UL * 3, p1Scratch);\n    p2 = Cartesian3.fromArray(edgePositions, UR * 3, p2Scratch);\n    if (\n      Cartesian3.equalsEpsilon(\n        p1,\n        p2,\n        CesiumMath.EPSILON10,\n        CesiumMath.EPSILON10\n      )\n    ) {\n      //skip corner\n      continue;\n    }\n\n    indices[edgeIndex++] = UL;\n    indices[edgeIndex++] = LL;\n    indices[edgeIndex++] = UR;\n    indices[edgeIndex++] = UR;\n    indices[edgeIndex++] = LL;\n    indices[edgeIndex++] = LR;\n  }\n\n  return new Geometry({\n    attributes: new GeometryAttributes({\n      position: new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: edgePositions,\n      }),\n    }),\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  });\n};\nexport default PolygonGeometryLibrary;\n"]},"metadata":{},"sourceType":"module"}