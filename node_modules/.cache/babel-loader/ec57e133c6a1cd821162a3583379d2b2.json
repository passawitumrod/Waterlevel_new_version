{"ast":null,"code":"import Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport Framebuffer from \"../Renderer/Framebuffer.js\";\nimport Texture from \"../Renderer/Texture.js\";\n/**\n * Creates a minimal amount of textures and framebuffers.\n *\n * @alias PostProcessStageTextureCache\n * @constructor\n *\n * @param {PostProcessStageCollection} postProcessStageCollection The post process collection.\n *\n * @private\n */\n\nfunction PostProcessStageTextureCache(postProcessStageCollection) {\n  this._collection = postProcessStageCollection;\n  this._framebuffers = [];\n  this._stageNameToFramebuffer = {};\n  this._width = undefined;\n  this._height = undefined;\n  this._updateDependencies = false;\n}\n\nfunction getLastStageName(stage) {\n  while (defined(stage.length)) {\n    stage = stage.get(stage.length - 1);\n  }\n\n  return stage.name;\n}\n\nfunction getStageDependencies(collection, context, dependencies, stage, previousName) {\n  if (!stage.enabled || !stage._isSupported(context)) {\n    return previousName;\n  }\n\n  var stageDependencies = dependencies[stage.name] = {};\n\n  if (defined(previousName)) {\n    var previous = collection.getStageByName(previousName);\n    stageDependencies[getLastStageName(previous)] = true;\n  }\n\n  var uniforms = stage.uniforms;\n\n  if (defined(uniforms)) {\n    var uniformNames = Object.getOwnPropertyNames(uniforms);\n    var uniformNamesLength = uniformNames.length;\n\n    for (var i = 0; i < uniformNamesLength; ++i) {\n      var value = uniforms[uniformNames[i]];\n\n      if (typeof value === \"string\") {\n        var dependent = collection.getStageByName(value);\n\n        if (defined(dependent)) {\n          stageDependencies[getLastStageName(dependent)] = true;\n        }\n      }\n    }\n  }\n\n  return stage.name;\n}\n\nfunction getCompositeDependencies(collection, context, dependencies, composite, previousName) {\n  if (defined(composite.enabled) && !composite.enabled || defined(composite._isSupported) && !composite._isSupported(context)) {\n    return previousName;\n  }\n\n  var originalDependency = previousName;\n  var inSeries = !defined(composite.inputPreviousStageTexture) || composite.inputPreviousStageTexture;\n  var currentName = previousName;\n  var length = composite.length;\n\n  for (var i = 0; i < length; ++i) {\n    var stage = composite.get(i);\n\n    if (defined(stage.length)) {\n      currentName = getCompositeDependencies(collection, context, dependencies, stage, previousName);\n    } else {\n      currentName = getStageDependencies(collection, context, dependencies, stage, previousName);\n    } // Stages in a series only depend on the previous stage\n\n\n    if (inSeries) {\n      previousName = currentName;\n    }\n  } // Stages not in a series depend on every stage executed before it since it could reference it as a uniform.\n  // This prevents looking at the dependencies of each stage in the composite, but might create more framebuffers than necessary.\n  // In practice, there are only 2-3 stages in these composites.\n\n\n  var j;\n  var name;\n\n  if (!inSeries) {\n    for (j = 1; j < length; ++j) {\n      name = getLastStageName(composite.get(j));\n      var currentDependencies = dependencies[name];\n\n      for (var k = 0; k < j; ++k) {\n        currentDependencies[getLastStageName(composite.get(k))] = true;\n      }\n    }\n  } else {\n    for (j = 1; j < length; ++j) {\n      name = getLastStageName(composite.get(j));\n\n      if (!defined(dependencies[name])) {\n        dependencies[name] = {};\n      }\n\n      dependencies[name][originalDependency] = true;\n    }\n  }\n\n  return currentName;\n}\n\nfunction getDependencies(collection, context) {\n  var dependencies = {};\n\n  if (defined(collection.ambientOcclusion)) {\n    var ao = collection.ambientOcclusion;\n    var bloom = collection.bloom;\n    var tonemapping = collection._tonemapping;\n    var fxaa = collection.fxaa;\n    var previousName = getCompositeDependencies(collection, context, dependencies, ao, undefined);\n    previousName = getCompositeDependencies(collection, context, dependencies, bloom, previousName);\n    previousName = getStageDependencies(collection, context, dependencies, tonemapping, previousName);\n    previousName = getCompositeDependencies(collection, context, dependencies, collection, previousName);\n    getStageDependencies(collection, context, dependencies, fxaa, previousName);\n  } else {\n    getCompositeDependencies(collection, context, dependencies, collection, undefined);\n  }\n\n  return dependencies;\n}\n\nfunction getFramebuffer(cache, stageName, dependencies) {\n  var collection = cache._collection;\n  var stage = collection.getStageByName(stageName);\n  var textureScale = stage._textureScale;\n  var forcePowerOfTwo = stage._forcePowerOfTwo;\n  var pixelFormat = stage._pixelFormat;\n  var pixelDatatype = stage._pixelDatatype;\n  var clearColor = stage._clearColor;\n  var i;\n  var framebuffer;\n  var framebuffers = cache._framebuffers;\n  var length = framebuffers.length;\n\n  for (i = 0; i < length; ++i) {\n    framebuffer = framebuffers[i];\n\n    if (textureScale !== framebuffer.textureScale || forcePowerOfTwo !== framebuffer.forcePowerOfTwo || pixelFormat !== framebuffer.pixelFormat || pixelDatatype !== framebuffer.pixelDatatype || !Color.equals(clearColor, framebuffer.clearColor)) {\n      continue;\n    }\n\n    var stageNames = framebuffer.stages;\n    var stagesLength = stageNames.length;\n    var foundConflict = false;\n\n    for (var j = 0; j < stagesLength; ++j) {\n      if (dependencies[stageNames[j]]) {\n        foundConflict = true;\n        break;\n      }\n    }\n\n    if (!foundConflict) {\n      break;\n    }\n  }\n\n  if (defined(framebuffer) && i < length) {\n    framebuffer.stages.push(stageName);\n    return framebuffer;\n  }\n\n  framebuffer = {\n    textureScale: textureScale,\n    forcePowerOfTwo: forcePowerOfTwo,\n    pixelFormat: pixelFormat,\n    pixelDatatype: pixelDatatype,\n    clearColor: clearColor,\n    stages: [stageName],\n    buffer: undefined,\n    clear: undefined\n  };\n  framebuffers.push(framebuffer);\n  return framebuffer;\n}\n\nfunction createFramebuffers(cache, context) {\n  var dependencies = getDependencies(cache._collection, context);\n\n  for (var stageName in dependencies) {\n    if (dependencies.hasOwnProperty(stageName)) {\n      cache._stageNameToFramebuffer[stageName] = getFramebuffer(cache, stageName, dependencies[stageName]);\n    }\n  }\n}\n\nfunction releaseResources(cache) {\n  var framebuffers = cache._framebuffers;\n  var length = framebuffers.length;\n\n  for (var i = 0; i < length; ++i) {\n    var framebuffer = framebuffers[i];\n    framebuffer.buffer = framebuffer.buffer && framebuffer.buffer.destroy();\n    framebuffer.buffer = undefined;\n  }\n}\n\nfunction updateFramebuffers(cache, context) {\n  var width = cache._width;\n  var height = cache._height;\n  var framebuffers = cache._framebuffers;\n  var length = framebuffers.length;\n\n  for (var i = 0; i < length; ++i) {\n    var framebuffer = framebuffers[i];\n    var scale = framebuffer.textureScale;\n    var textureWidth = Math.ceil(width * scale);\n    var textureHeight = Math.ceil(height * scale);\n    var size = Math.min(textureWidth, textureHeight);\n\n    if (framebuffer.forcePowerOfTwo) {\n      if (!CesiumMath.isPowerOfTwo(size)) {\n        size = CesiumMath.nextPowerOfTwo(size);\n      }\n\n      textureWidth = size;\n      textureHeight = size;\n    }\n\n    framebuffer.buffer = new Framebuffer({\n      context: context,\n      colorTextures: [new Texture({\n        context: context,\n        width: textureWidth,\n        height: textureHeight,\n        pixelFormat: framebuffer.pixelFormat,\n        pixelDatatype: framebuffer.pixelDatatype\n      })]\n    });\n    framebuffer.clear = new ClearCommand({\n      color: framebuffer.clearColor,\n      framebuffer: framebuffer.buffer\n    });\n  }\n}\n\nPostProcessStageTextureCache.prototype.updateDependencies = function () {\n  this._updateDependencies = true;\n};\n/**\n * Called before the stages in the collection are executed. Creates the minimum amount of framebuffers for a post-process collection.\n *\n * @param {Context} context The context.\n */\n\n\nPostProcessStageTextureCache.prototype.update = function (context) {\n  var collection = this._collection;\n  var updateDependencies = this._updateDependencies;\n\n  var aoEnabled = defined(collection.ambientOcclusion) && collection.ambientOcclusion.enabled && collection.ambientOcclusion._isSupported(context);\n\n  var bloomEnabled = defined(collection.bloom) && collection.bloom.enabled && collection.bloom._isSupported(context);\n\n  var tonemappingEnabled = defined(collection._tonemapping) && collection._tonemapping.enabled && collection._tonemapping._isSupported(context);\n\n  var fxaaEnabled = defined(collection.fxaa) && collection.fxaa.enabled && collection.fxaa._isSupported(context);\n\n  var needsCheckDimensionsUpdate = !defined(collection._activeStages) || collection._activeStages.length > 0 || aoEnabled || bloomEnabled || tonemappingEnabled || fxaaEnabled;\n\n  if (updateDependencies || !needsCheckDimensionsUpdate && this._framebuffers.length > 0) {\n    releaseResources(this);\n    this._framebuffers.length = 0;\n    this._stageNameToFramebuffer = {};\n    this._width = undefined;\n    this._height = undefined;\n  }\n\n  if (!updateDependencies && !needsCheckDimensionsUpdate) {\n    return;\n  }\n\n  if (this._framebuffers.length === 0) {\n    createFramebuffers(this, context);\n  }\n\n  var width = context.drawingBufferWidth;\n  var height = context.drawingBufferHeight;\n  var dimensionsChanged = this._width !== width || this._height !== height;\n\n  if (!updateDependencies && !dimensionsChanged) {\n    return;\n  }\n\n  this._width = width;\n  this._height = height;\n  this._updateDependencies = false;\n  releaseResources(this);\n  updateFramebuffers(this, context);\n};\n/**\n * Clears all of the framebuffers.\n *\n * @param {Context} context The context.\n */\n\n\nPostProcessStageTextureCache.prototype.clear = function (context) {\n  var framebuffers = this._framebuffers;\n\n  for (var i = 0; i < framebuffers.length; ++i) {\n    framebuffers[i].clear.execute(context);\n  }\n};\n/**\n * Gets the stage with the given name.\n * @param {String} name The name of the stage.\n * @return {PostProcessStage|PostProcessStageComposite}\n */\n\n\nPostProcessStageTextureCache.prototype.getStageByName = function (name) {\n  return this._collection.getStageByName(name);\n};\n/**\n * Gets the output texture for a stage with the given name.\n * @param {String} name The name of the stage.\n * @return {Texture|undefined} The output texture of the stage with the given name.\n */\n\n\nPostProcessStageTextureCache.prototype.getOutputTexture = function (name) {\n  return this._collection.getOutputTexture(name);\n};\n/**\n * Gets the framebuffer for a stage with the given name.\n *\n * @param {String} name The name of the stage.\n * @return {Framebuffer|undefined} The framebuffer for the stage with the given name.\n */\n\n\nPostProcessStageTextureCache.prototype.getFramebuffer = function (name) {\n  var framebuffer = this._stageNameToFramebuffer[name];\n\n  if (!defined(framebuffer)) {\n    return undefined;\n  }\n\n  return framebuffer.buffer;\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see PostProcessStageTextureCache#destroy\n */\n\n\nPostProcessStageTextureCache.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see PostProcessStageTextureCache#isDestroyed\n */\n\n\nPostProcessStageTextureCache.prototype.destroy = function () {\n  releaseResources(this);\n  return destroyObject(this);\n};\n\nexport default PostProcessStageTextureCache;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/PostProcessStageTextureCache.js"],"names":["Color","defined","destroyObject","CesiumMath","ClearCommand","Framebuffer","Texture","PostProcessStageTextureCache","postProcessStageCollection","_collection","_framebuffers","_stageNameToFramebuffer","_width","undefined","_height","_updateDependencies","getLastStageName","stage","length","get","name","getStageDependencies","collection","context","dependencies","previousName","enabled","_isSupported","stageDependencies","previous","getStageByName","uniforms","uniformNames","Object","getOwnPropertyNames","uniformNamesLength","i","value","dependent","getCompositeDependencies","composite","originalDependency","inSeries","inputPreviousStageTexture","currentName","j","currentDependencies","k","getDependencies","ambientOcclusion","ao","bloom","tonemapping","_tonemapping","fxaa","getFramebuffer","cache","stageName","textureScale","_textureScale","forcePowerOfTwo","_forcePowerOfTwo","pixelFormat","_pixelFormat","pixelDatatype","_pixelDatatype","clearColor","_clearColor","framebuffer","framebuffers","equals","stageNames","stages","stagesLength","foundConflict","push","buffer","clear","createFramebuffers","hasOwnProperty","releaseResources","destroy","updateFramebuffers","width","height","scale","textureWidth","Math","ceil","textureHeight","size","min","isPowerOfTwo","nextPowerOfTwo","colorTextures","color","prototype","updateDependencies","update","aoEnabled","bloomEnabled","tonemappingEnabled","fxaaEnabled","needsCheckDimensionsUpdate","_activeStages","drawingBufferWidth","drawingBufferHeight","dimensionsChanged","execute","getOutputTexture","isDestroyed"],"mappings":"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","sourcesContent":["import Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport Framebuffer from \"../Renderer/Framebuffer.js\";\nimport Texture from \"../Renderer/Texture.js\";\n\n/**\n * Creates a minimal amount of textures and framebuffers.\n *\n * @alias PostProcessStageTextureCache\n * @constructor\n *\n * @param {PostProcessStageCollection} postProcessStageCollection The post process collection.\n *\n * @private\n */\nfunction PostProcessStageTextureCache(postProcessStageCollection) {\n  this._collection = postProcessStageCollection;\n\n  this._framebuffers = [];\n  this._stageNameToFramebuffer = {};\n\n  this._width = undefined;\n  this._height = undefined;\n  this._updateDependencies = false;\n}\n\nfunction getLastStageName(stage) {\n  while (defined(stage.length)) {\n    stage = stage.get(stage.length - 1);\n  }\n  return stage.name;\n}\n\nfunction getStageDependencies(\n  collection,\n  context,\n  dependencies,\n  stage,\n  previousName\n) {\n  if (!stage.enabled || !stage._isSupported(context)) {\n    return previousName;\n  }\n\n  var stageDependencies = (dependencies[stage.name] = {});\n  if (defined(previousName)) {\n    var previous = collection.getStageByName(previousName);\n    stageDependencies[getLastStageName(previous)] = true;\n  }\n  var uniforms = stage.uniforms;\n  if (defined(uniforms)) {\n    var uniformNames = Object.getOwnPropertyNames(uniforms);\n    var uniformNamesLength = uniformNames.length;\n    for (var i = 0; i < uniformNamesLength; ++i) {\n      var value = uniforms[uniformNames[i]];\n      if (typeof value === \"string\") {\n        var dependent = collection.getStageByName(value);\n        if (defined(dependent)) {\n          stageDependencies[getLastStageName(dependent)] = true;\n        }\n      }\n    }\n  }\n\n  return stage.name;\n}\n\nfunction getCompositeDependencies(\n  collection,\n  context,\n  dependencies,\n  composite,\n  previousName\n) {\n  if (\n    (defined(composite.enabled) && !composite.enabled) ||\n    (defined(composite._isSupported) && !composite._isSupported(context))\n  ) {\n    return previousName;\n  }\n\n  var originalDependency = previousName;\n\n  var inSeries =\n    !defined(composite.inputPreviousStageTexture) ||\n    composite.inputPreviousStageTexture;\n  var currentName = previousName;\n  var length = composite.length;\n  for (var i = 0; i < length; ++i) {\n    var stage = composite.get(i);\n    if (defined(stage.length)) {\n      currentName = getCompositeDependencies(\n        collection,\n        context,\n        dependencies,\n        stage,\n        previousName\n      );\n    } else {\n      currentName = getStageDependencies(\n        collection,\n        context,\n        dependencies,\n        stage,\n        previousName\n      );\n    }\n    // Stages in a series only depend on the previous stage\n    if (inSeries) {\n      previousName = currentName;\n    }\n  }\n\n  // Stages not in a series depend on every stage executed before it since it could reference it as a uniform.\n  // This prevents looking at the dependencies of each stage in the composite, but might create more framebuffers than necessary.\n  // In practice, there are only 2-3 stages in these composites.\n  var j;\n  var name;\n  if (!inSeries) {\n    for (j = 1; j < length; ++j) {\n      name = getLastStageName(composite.get(j));\n      var currentDependencies = dependencies[name];\n      for (var k = 0; k < j; ++k) {\n        currentDependencies[getLastStageName(composite.get(k))] = true;\n      }\n    }\n  } else {\n    for (j = 1; j < length; ++j) {\n      name = getLastStageName(composite.get(j));\n      if (!defined(dependencies[name])) {\n        dependencies[name] = {};\n      }\n      dependencies[name][originalDependency] = true;\n    }\n  }\n\n  return currentName;\n}\n\nfunction getDependencies(collection, context) {\n  var dependencies = {};\n\n  if (defined(collection.ambientOcclusion)) {\n    var ao = collection.ambientOcclusion;\n    var bloom = collection.bloom;\n    var tonemapping = collection._tonemapping;\n    var fxaa = collection.fxaa;\n\n    var previousName = getCompositeDependencies(\n      collection,\n      context,\n      dependencies,\n      ao,\n      undefined\n    );\n    previousName = getCompositeDependencies(\n      collection,\n      context,\n      dependencies,\n      bloom,\n      previousName\n    );\n    previousName = getStageDependencies(\n      collection,\n      context,\n      dependencies,\n      tonemapping,\n      previousName\n    );\n    previousName = getCompositeDependencies(\n      collection,\n      context,\n      dependencies,\n      collection,\n      previousName\n    );\n    getStageDependencies(collection, context, dependencies, fxaa, previousName);\n  } else {\n    getCompositeDependencies(\n      collection,\n      context,\n      dependencies,\n      collection,\n      undefined\n    );\n  }\n\n  return dependencies;\n}\n\nfunction getFramebuffer(cache, stageName, dependencies) {\n  var collection = cache._collection;\n  var stage = collection.getStageByName(stageName);\n\n  var textureScale = stage._textureScale;\n  var forcePowerOfTwo = stage._forcePowerOfTwo;\n  var pixelFormat = stage._pixelFormat;\n  var pixelDatatype = stage._pixelDatatype;\n  var clearColor = stage._clearColor;\n\n  var i;\n  var framebuffer;\n  var framebuffers = cache._framebuffers;\n  var length = framebuffers.length;\n  for (i = 0; i < length; ++i) {\n    framebuffer = framebuffers[i];\n\n    if (\n      textureScale !== framebuffer.textureScale ||\n      forcePowerOfTwo !== framebuffer.forcePowerOfTwo ||\n      pixelFormat !== framebuffer.pixelFormat ||\n      pixelDatatype !== framebuffer.pixelDatatype ||\n      !Color.equals(clearColor, framebuffer.clearColor)\n    ) {\n      continue;\n    }\n\n    var stageNames = framebuffer.stages;\n    var stagesLength = stageNames.length;\n    var foundConflict = false;\n    for (var j = 0; j < stagesLength; ++j) {\n      if (dependencies[stageNames[j]]) {\n        foundConflict = true;\n        break;\n      }\n    }\n\n    if (!foundConflict) {\n      break;\n    }\n  }\n\n  if (defined(framebuffer) && i < length) {\n    framebuffer.stages.push(stageName);\n    return framebuffer;\n  }\n\n  framebuffer = {\n    textureScale: textureScale,\n    forcePowerOfTwo: forcePowerOfTwo,\n    pixelFormat: pixelFormat,\n    pixelDatatype: pixelDatatype,\n    clearColor: clearColor,\n    stages: [stageName],\n    buffer: undefined,\n    clear: undefined,\n  };\n\n  framebuffers.push(framebuffer);\n  return framebuffer;\n}\n\nfunction createFramebuffers(cache, context) {\n  var dependencies = getDependencies(cache._collection, context);\n  for (var stageName in dependencies) {\n    if (dependencies.hasOwnProperty(stageName)) {\n      cache._stageNameToFramebuffer[stageName] = getFramebuffer(\n        cache,\n        stageName,\n        dependencies[stageName]\n      );\n    }\n  }\n}\n\nfunction releaseResources(cache) {\n  var framebuffers = cache._framebuffers;\n  var length = framebuffers.length;\n  for (var i = 0; i < length; ++i) {\n    var framebuffer = framebuffers[i];\n    framebuffer.buffer = framebuffer.buffer && framebuffer.buffer.destroy();\n    framebuffer.buffer = undefined;\n  }\n}\n\nfunction updateFramebuffers(cache, context) {\n  var width = cache._width;\n  var height = cache._height;\n\n  var framebuffers = cache._framebuffers;\n  var length = framebuffers.length;\n  for (var i = 0; i < length; ++i) {\n    var framebuffer = framebuffers[i];\n\n    var scale = framebuffer.textureScale;\n    var textureWidth = Math.ceil(width * scale);\n    var textureHeight = Math.ceil(height * scale);\n\n    var size = Math.min(textureWidth, textureHeight);\n    if (framebuffer.forcePowerOfTwo) {\n      if (!CesiumMath.isPowerOfTwo(size)) {\n        size = CesiumMath.nextPowerOfTwo(size);\n      }\n      textureWidth = size;\n      textureHeight = size;\n    }\n\n    framebuffer.buffer = new Framebuffer({\n      context: context,\n      colorTextures: [\n        new Texture({\n          context: context,\n          width: textureWidth,\n          height: textureHeight,\n          pixelFormat: framebuffer.pixelFormat,\n          pixelDatatype: framebuffer.pixelDatatype,\n        }),\n      ],\n    });\n    framebuffer.clear = new ClearCommand({\n      color: framebuffer.clearColor,\n      framebuffer: framebuffer.buffer,\n    });\n  }\n}\n\nPostProcessStageTextureCache.prototype.updateDependencies = function () {\n  this._updateDependencies = true;\n};\n\n/**\n * Called before the stages in the collection are executed. Creates the minimum amount of framebuffers for a post-process collection.\n *\n * @param {Context} context The context.\n */\nPostProcessStageTextureCache.prototype.update = function (context) {\n  var collection = this._collection;\n  var updateDependencies = this._updateDependencies;\n  var aoEnabled =\n    defined(collection.ambientOcclusion) &&\n    collection.ambientOcclusion.enabled &&\n    collection.ambientOcclusion._isSupported(context);\n  var bloomEnabled =\n    defined(collection.bloom) &&\n    collection.bloom.enabled &&\n    collection.bloom._isSupported(context);\n  var tonemappingEnabled =\n    defined(collection._tonemapping) &&\n    collection._tonemapping.enabled &&\n    collection._tonemapping._isSupported(context);\n  var fxaaEnabled =\n    defined(collection.fxaa) &&\n    collection.fxaa.enabled &&\n    collection.fxaa._isSupported(context);\n  var needsCheckDimensionsUpdate =\n    !defined(collection._activeStages) ||\n    collection._activeStages.length > 0 ||\n    aoEnabled ||\n    bloomEnabled ||\n    tonemappingEnabled ||\n    fxaaEnabled;\n  if (\n    updateDependencies ||\n    (!needsCheckDimensionsUpdate && this._framebuffers.length > 0)\n  ) {\n    releaseResources(this);\n    this._framebuffers.length = 0;\n    this._stageNameToFramebuffer = {};\n    this._width = undefined;\n    this._height = undefined;\n  }\n\n  if (!updateDependencies && !needsCheckDimensionsUpdate) {\n    return;\n  }\n\n  if (this._framebuffers.length === 0) {\n    createFramebuffers(this, context);\n  }\n\n  var width = context.drawingBufferWidth;\n  var height = context.drawingBufferHeight;\n  var dimensionsChanged = this._width !== width || this._height !== height;\n  if (!updateDependencies && !dimensionsChanged) {\n    return;\n  }\n\n  this._width = width;\n  this._height = height;\n  this._updateDependencies = false;\n  releaseResources(this);\n  updateFramebuffers(this, context);\n};\n\n/**\n * Clears all of the framebuffers.\n *\n * @param {Context} context The context.\n */\nPostProcessStageTextureCache.prototype.clear = function (context) {\n  var framebuffers = this._framebuffers;\n  for (var i = 0; i < framebuffers.length; ++i) {\n    framebuffers[i].clear.execute(context);\n  }\n};\n\n/**\n * Gets the stage with the given name.\n * @param {String} name The name of the stage.\n * @return {PostProcessStage|PostProcessStageComposite}\n */\nPostProcessStageTextureCache.prototype.getStageByName = function (name) {\n  return this._collection.getStageByName(name);\n};\n\n/**\n * Gets the output texture for a stage with the given name.\n * @param {String} name The name of the stage.\n * @return {Texture|undefined} The output texture of the stage with the given name.\n */\nPostProcessStageTextureCache.prototype.getOutputTexture = function (name) {\n  return this._collection.getOutputTexture(name);\n};\n\n/**\n * Gets the framebuffer for a stage with the given name.\n *\n * @param {String} name The name of the stage.\n * @return {Framebuffer|undefined} The framebuffer for the stage with the given name.\n */\nPostProcessStageTextureCache.prototype.getFramebuffer = function (name) {\n  var framebuffer = this._stageNameToFramebuffer[name];\n  if (!defined(framebuffer)) {\n    return undefined;\n  }\n  return framebuffer.buffer;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see PostProcessStageTextureCache#destroy\n */\nPostProcessStageTextureCache.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see PostProcessStageTextureCache#isDestroyed\n */\nPostProcessStageTextureCache.prototype.destroy = function () {\n  releaseResources(this);\n  return destroyObject(this);\n};\nexport default PostProcessStageTextureCache;\n"]},"metadata":{},"sourceType":"module"}