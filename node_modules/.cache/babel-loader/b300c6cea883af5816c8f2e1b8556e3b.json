{"ast":null,"code":"import when from \"../ThirdParty/when.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport HeightmapEncoding from \"./HeightmapEncoding.js\";\nimport HeightmapTessellator from \"./HeightmapTessellator.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport TerrainMesh from \"./TerrainMesh.js\";\nimport TerrainProvider from \"./TerrainProvider.js\";\n/**\n * Terrain data for a single tile where the terrain data is represented as a heightmap.  A heightmap\n * is a rectangular array of heights in row-major order from north to south and west to east.\n *\n * @alias HeightmapTerrainData\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {TypedArray} options.buffer The buffer containing height data.\n * @param {Number} options.width The width (longitude direction) of the heightmap, in samples.\n * @param {Number} options.height The height (latitude direction) of the heightmap, in samples.\n * @param {Number} [options.childTileMask=15] A bit mask indicating which of this tile's four children exist.\n *                 If a child's bit is set, geometry will be requested for that tile as well when it\n *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is\n *                 instead upsampled from the parent.  The bit values are as follows:\n *                 <table>\n *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *                  <tr><td>2</td><td>4</td><td>Northwest</td></tr>\n *                  <tr><td>3</td><td>8</td><td>Northeast</td></tr>\n *                 </table>\n * @param {Uint8Array} [options.waterMask] The water mask included in this terrain data, if any.  A water mask is a square\n *                     Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n *                     Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n * @param {Object} [options.structure] An object describing the structure of the height data.\n * @param {Number} [options.structure.heightScale=1.0] The factor by which to multiply height samples in order to obtain\n *                 the height above the heightOffset, in meters.  The heightOffset is added to the resulting\n *                 height after multiplying by the scale.\n * @param {Number} [options.structure.heightOffset=0.0] The offset to add to the scaled height to obtain the final\n *                 height in meters.  The offset is added after the height sample is multiplied by the\n *                 heightScale.\n * @param {Number} [options.structure.elementsPerHeight=1] The number of elements in the buffer that make up a single height\n *                 sample.  This is usually 1, indicating that each element is a separate height sample.  If\n *                 it is greater than 1, that number of elements together form the height sample, which is\n *                 computed according to the structure.elementMultiplier and structure.isBigEndian properties.\n * @param {Number} [options.structure.stride=1] The number of elements to skip to get from the first element of\n *                 one height to the first element of the next height.\n * @param {Number} [options.structure.elementMultiplier=256.0] The multiplier used to compute the height value when the\n *                 stride property is greater than 1.  For example, if the stride is 4 and the strideMultiplier\n *                 is 256, the height is computed as follows:\n *                 `height = buffer[index] + buffer[index + 1] * 256 + buffer[index + 2] * 256 * 256 + buffer[index + 3] * 256 * 256 * 256`\n *                 This is assuming that the isBigEndian property is false.  If it is true, the order of the\n *                 elements is reversed.\n * @param {Boolean} [options.structure.isBigEndian=false] Indicates endianness of the elements in the buffer when the\n *                  stride property is greater than 1.  If this property is false, the first element is the\n *                  low-order element.  If it is true, the first element is the high-order element.\n * @param {Number} [options.structure.lowestEncodedHeight] The lowest value that can be stored in the height buffer.  Any heights that are lower\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be 0 because a `Uint16Array` cannot store negative numbers.  If this parameter is\n *                 not specified, no minimum value is enforced.\n * @param {Number} [options.structure.highestEncodedHeight] The highest value that can be stored in the height buffer.  Any heights that are higher\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be `256 * 256 - 1` or 65535 because a `Uint16Array` cannot store numbers larger\n *                 than 65535.  If this parameter is not specified, no maximum value is enforced.\n * @param {HeightmapEncoding} [options.encoding=HeightmapEncoding.NONE] The encoding that is used on the buffer.\n * @param {Boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;\n *                  otherwise, false.\n *\n *\n * @example\n * var buffer = ...\n * var heightBuffer = new Uint16Array(buffer, 0, that._heightmapWidth * that._heightmapWidth);\n * var childTileMask = new Uint8Array(buffer, heightBuffer.byteLength, 1)[0];\n * var waterMask = new Uint8Array(buffer, heightBuffer.byteLength + 1, buffer.byteLength - heightBuffer.byteLength - 1);\n * var terrainData = new Cesium.HeightmapTerrainData({\n *   buffer : heightBuffer,\n *   width : 65,\n *   height : 65,\n *   childTileMask : childTileMask,\n *   waterMask : waterMask\n * });\n *\n * @see TerrainData\n * @see QuantizedMeshTerrainData\n * @see GoogleEarthEnterpriseTerrainData\n */\n\nfunction HeightmapTerrainData(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.buffer)) {\n    throw new DeveloperError(\"options.buffer is required.\");\n  }\n\n  if (!defined(options.width)) {\n    throw new DeveloperError(\"options.width is required.\");\n  }\n\n  if (!defined(options.height)) {\n    throw new DeveloperError(\"options.height is required.\");\n  } //>>includeEnd('debug');\n\n\n  this._buffer = options.buffer;\n  this._width = options.width;\n  this._height = options.height;\n  this._childTileMask = defaultValue(options.childTileMask, 15);\n  this._encoding = defaultValue(options.encoding, HeightmapEncoding.NONE);\n  var defaultStructure = HeightmapTessellator.DEFAULT_STRUCTURE;\n  var structure = options.structure;\n\n  if (!defined(structure)) {\n    structure = defaultStructure;\n  } else if (structure !== defaultStructure) {\n    structure.heightScale = defaultValue(structure.heightScale, defaultStructure.heightScale);\n    structure.heightOffset = defaultValue(structure.heightOffset, defaultStructure.heightOffset);\n    structure.elementsPerHeight = defaultValue(structure.elementsPerHeight, defaultStructure.elementsPerHeight);\n    structure.stride = defaultValue(structure.stride, defaultStructure.stride);\n    structure.elementMultiplier = defaultValue(structure.elementMultiplier, defaultStructure.elementMultiplier);\n    structure.isBigEndian = defaultValue(structure.isBigEndian, defaultStructure.isBigEndian);\n  }\n\n  this._structure = structure;\n  this._createdByUpsampling = defaultValue(options.createdByUpsampling, false);\n  this._waterMask = options.waterMask;\n  this._skirtHeight = undefined;\n  this._bufferType = this._encoding === HeightmapEncoding.LERC ? Float32Array : this._buffer.constructor;\n  this._mesh = undefined;\n}\n\nObject.defineProperties(HeightmapTerrainData.prototype, {\n  /**\n   * An array of credits for this tile.\n   * @memberof HeightmapTerrainData.prototype\n   * @type {Credit[]}\n   */\n  credits: {\n    get: function () {\n      return undefined;\n    }\n  },\n\n  /**\n   * The water mask included in this terrain data, if any.  A water mask is a square\n   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n   * @memberof HeightmapTerrainData.prototype\n   * @type {Uint8Array|Image|Canvas}\n   */\n  waterMask: {\n    get: function () {\n      return this._waterMask;\n    }\n  },\n  childTileMask: {\n    get: function () {\n      return this._childTileMask;\n    }\n  }\n});\nvar taskProcessor = new TaskProcessor(\"createVerticesFromHeightmap\");\n/**\n * Creates a {@link TerrainMesh} from this terrain data.\n *\n * @private\n *\n * @param {TilingScheme} tilingScheme The tiling scheme to which this tile belongs.\n * @param {Number} x The X coordinate of the tile for which to create the terrain data.\n * @param {Number} y The Y coordinate of the tile for which to create the terrain data.\n * @param {Number} level The level of the tile for which to create the terrain data.\n * @param {Number} [exaggeration=1.0] The scale used to exaggerate the terrain.\n * @returns {Promise.<TerrainMesh>|undefined} A promise for the terrain mesh, or undefined if too many\n *          asynchronous mesh creations are already in progress and the operation should\n *          be retried later.\n */\n\nHeightmapTerrainData.prototype.createMesh = function (tilingScheme, x, y, level, exaggeration) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(tilingScheme)) {\n    throw new DeveloperError(\"tilingScheme is required.\");\n  }\n\n  if (!defined(x)) {\n    throw new DeveloperError(\"x is required.\");\n  }\n\n  if (!defined(y)) {\n    throw new DeveloperError(\"y is required.\");\n  }\n\n  if (!defined(level)) {\n    throw new DeveloperError(\"level is required.\");\n  } //>>includeEnd('debug');\n\n\n  var ellipsoid = tilingScheme.ellipsoid;\n  var nativeRectangle = tilingScheme.tileXYToNativeRectangle(x, y, level);\n  var rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n  exaggeration = defaultValue(exaggeration, 1.0); // Compute the center of the tile for RTC rendering.\n\n  var center = ellipsoid.cartographicToCartesian(Rectangle.center(rectangle));\n  var structure = this._structure;\n  var levelZeroMaxError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(ellipsoid, this._width, tilingScheme.getNumberOfXTilesAtLevel(0));\n  var thisLevelMaxError = levelZeroMaxError / (1 << level);\n  this._skirtHeight = Math.min(thisLevelMaxError * 4.0, 1000.0);\n  var verticesPromise = taskProcessor.scheduleTask({\n    heightmap: this._buffer,\n    structure: structure,\n    includeWebMercatorT: true,\n    width: this._width,\n    height: this._height,\n    nativeRectangle: nativeRectangle,\n    rectangle: rectangle,\n    relativeToCenter: center,\n    ellipsoid: ellipsoid,\n    skirtHeight: this._skirtHeight,\n    isGeographic: tilingScheme.projection instanceof GeographicProjection,\n    exaggeration: exaggeration,\n    encoding: this._encoding\n  });\n\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  var that = this;\n  return when(verticesPromise, function (result) {\n    var indicesAndEdges;\n\n    if (that._skirtHeight > 0.0) {\n      indicesAndEdges = TerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices(result.gridWidth, result.gridHeight);\n    } else {\n      indicesAndEdges = TerrainProvider.getRegularGridIndicesAndEdgeIndices(result.gridWidth, result.gridHeight);\n    }\n\n    var vertexCountWithoutSkirts = result.gridWidth * result.gridHeight; // Clone complex result objects because the transfer from the web worker\n    // has stripped them down to JSON-style objects.\n\n    that._mesh = new TerrainMesh(center, new Float32Array(result.vertices), indicesAndEdges.indices, indicesAndEdges.indexCountWithoutSkirts, vertexCountWithoutSkirts, result.minimumHeight, result.maximumHeight, BoundingSphere.clone(result.boundingSphere3D), Cartesian3.clone(result.occludeePointInScaledSpace), result.numberOfAttributes, OrientedBoundingBox.clone(result.orientedBoundingBox), TerrainEncoding.clone(result.encoding), exaggeration, indicesAndEdges.westIndicesSouthToNorth, indicesAndEdges.southIndicesEastToWest, indicesAndEdges.eastIndicesNorthToSouth, indicesAndEdges.northIndicesWestToEast); // Free memory received from server after mesh is created.\n\n    that._buffer = undefined;\n    return that._mesh;\n  });\n};\n/**\n * @private\n */\n\n\nHeightmapTerrainData.prototype._createMeshSync = function (tilingScheme, x, y, level, exaggeration) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(tilingScheme)) {\n    throw new DeveloperError(\"tilingScheme is required.\");\n  }\n\n  if (!defined(x)) {\n    throw new DeveloperError(\"x is required.\");\n  }\n\n  if (!defined(y)) {\n    throw new DeveloperError(\"y is required.\");\n  }\n\n  if (!defined(level)) {\n    throw new DeveloperError(\"level is required.\");\n  } //>>includeEnd('debug');\n\n\n  var ellipsoid = tilingScheme.ellipsoid;\n  var nativeRectangle = tilingScheme.tileXYToNativeRectangle(x, y, level);\n  var rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n  exaggeration = defaultValue(exaggeration, 1.0); // Compute the center of the tile for RTC rendering.\n\n  var center = ellipsoid.cartographicToCartesian(Rectangle.center(rectangle));\n  var structure = this._structure;\n  var levelZeroMaxError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(ellipsoid, this._width, tilingScheme.getNumberOfXTilesAtLevel(0));\n  var thisLevelMaxError = levelZeroMaxError / (1 << level);\n  this._skirtHeight = Math.min(thisLevelMaxError * 4.0, 1000.0);\n  var result = HeightmapTessellator.computeVertices({\n    heightmap: this._buffer,\n    structure: structure,\n    includeWebMercatorT: true,\n    width: this._width,\n    height: this._height,\n    nativeRectangle: nativeRectangle,\n    rectangle: rectangle,\n    relativeToCenter: center,\n    ellipsoid: ellipsoid,\n    skirtHeight: this._skirtHeight,\n    isGeographic: tilingScheme.projection instanceof GeographicProjection,\n    exaggeration: exaggeration\n  }); // Free memory received from server after mesh is created.\n\n  this._buffer = undefined;\n  var indicesAndEdges;\n\n  if (this._skirtHeight > 0.0) {\n    indicesAndEdges = TerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices(this._width, this._height);\n  } else {\n    indicesAndEdges = TerrainProvider.getRegularGridIndicesAndEdgeIndices(this._width, this._height);\n  }\n\n  var vertexCountWithoutSkirts = result.gridWidth * result.gridHeight; // No need to clone here (as we do in the async version) because the result\n  // is not coming from a web worker.\n\n  return new TerrainMesh(center, result.vertices, indicesAndEdges.indices, indicesAndEdges.indexCountWithoutSkirts, vertexCountWithoutSkirts, result.minimumHeight, result.maximumHeight, result.boundingSphere3D, result.occludeePointInScaledSpace, result.encoding.getStride(), result.orientedBoundingBox, result.encoding, exaggeration, indicesAndEdges.westIndicesSouthToNorth, indicesAndEdges.southIndicesEastToWest, indicesAndEdges.eastIndicesNorthToSouth, indicesAndEdges.northIndicesWestToEast);\n};\n/**\n * Computes the terrain height at a specified longitude and latitude.\n *\n * @param {Rectangle} rectangle The rectangle covered by this terrain data.\n * @param {Number} longitude The longitude in radians.\n * @param {Number} latitude The latitude in radians.\n * @returns {Number} The terrain height at the specified position.  If the position\n *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly\n *          incorrect for positions far outside the rectangle.\n */\n\n\nHeightmapTerrainData.prototype.interpolateHeight = function (rectangle, longitude, latitude) {\n  var width = this._width;\n  var height = this._height;\n  var structure = this._structure;\n  var stride = structure.stride;\n  var elementsPerHeight = structure.elementsPerHeight;\n  var elementMultiplier = structure.elementMultiplier;\n  var isBigEndian = structure.isBigEndian;\n  var heightOffset = structure.heightOffset;\n  var heightScale = structure.heightScale;\n  var heightSample;\n\n  if (defined(this._mesh)) {\n    var buffer = this._mesh.vertices;\n    var encoding = this._mesh.encoding;\n    var exaggeration = this._mesh.exaggeration;\n    heightSample = interpolateMeshHeight(buffer, encoding, heightOffset, heightScale, rectangle, width, height, longitude, latitude, exaggeration);\n  } else {\n    heightSample = interpolateHeight(this._buffer, elementsPerHeight, elementMultiplier, stride, isBigEndian, rectangle, width, height, longitude, latitude);\n    heightSample = heightSample * heightScale + heightOffset;\n  }\n\n  return heightSample;\n};\n/**\n * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the\n * height samples in this instance, interpolated if necessary.\n *\n * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.\n * @param {Number} thisX The X coordinate of this tile in the tiling scheme.\n * @param {Number} thisY The Y coordinate of this tile in the tiling scheme.\n * @param {Number} thisLevel The level of this tile in the tiling scheme.\n * @param {Number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.\n * @returns {Promise.<HeightmapTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,\n *          or undefined if too many asynchronous upsample operations are in progress and the request has been\n *          deferred.\n */\n\n\nHeightmapTerrainData.prototype.upsample = function (tilingScheme, thisX, thisY, thisLevel, descendantX, descendantY, descendantLevel) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(tilingScheme)) {\n    throw new DeveloperError(\"tilingScheme is required.\");\n  }\n\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n\n  if (!defined(thisLevel)) {\n    throw new DeveloperError(\"thisLevel is required.\");\n  }\n\n  if (!defined(descendantX)) {\n    throw new DeveloperError(\"descendantX is required.\");\n  }\n\n  if (!defined(descendantY)) {\n    throw new DeveloperError(\"descendantY is required.\");\n  }\n\n  if (!defined(descendantLevel)) {\n    throw new DeveloperError(\"descendantLevel is required.\");\n  }\n\n  var levelDifference = descendantLevel - thisLevel;\n\n  if (levelDifference > 1) {\n    throw new DeveloperError(\"Upsampling through more than one level at a time is not currently supported.\");\n  } //>>includeEnd('debug');\n\n\n  var meshData = this._mesh;\n\n  if (!defined(meshData)) {\n    return undefined;\n  }\n\n  var width = this._width;\n  var height = this._height;\n  var structure = this._structure;\n  var stride = structure.stride;\n  var heights = new this._bufferType(width * height * stride);\n  var buffer = meshData.vertices;\n  var encoding = meshData.encoding; // PERFORMANCE_IDEA: don't recompute these rectangles - the caller already knows them.\n\n  var sourceRectangle = tilingScheme.tileXYToRectangle(thisX, thisY, thisLevel);\n  var destinationRectangle = tilingScheme.tileXYToRectangle(descendantX, descendantY, descendantLevel);\n  var heightOffset = structure.heightOffset;\n  var heightScale = structure.heightScale;\n  var exaggeration = meshData.exaggeration;\n  var elementsPerHeight = structure.elementsPerHeight;\n  var elementMultiplier = structure.elementMultiplier;\n  var isBigEndian = structure.isBigEndian;\n  var divisor = Math.pow(elementMultiplier, elementsPerHeight - 1);\n\n  for (var j = 0; j < height; ++j) {\n    var latitude = CesiumMath.lerp(destinationRectangle.north, destinationRectangle.south, j / (height - 1));\n\n    for (var i = 0; i < width; ++i) {\n      var longitude = CesiumMath.lerp(destinationRectangle.west, destinationRectangle.east, i / (width - 1));\n      var heightSample = interpolateMeshHeight(buffer, encoding, heightOffset, heightScale, sourceRectangle, width, height, longitude, latitude, exaggeration); // Use conditionals here instead of Math.min and Math.max so that an undefined\n      // lowestEncodedHeight or highestEncodedHeight has no effect.\n\n      heightSample = heightSample < structure.lowestEncodedHeight ? structure.lowestEncodedHeight : heightSample;\n      heightSample = heightSample > structure.highestEncodedHeight ? structure.highestEncodedHeight : heightSample;\n      setHeight(heights, elementsPerHeight, elementMultiplier, divisor, stride, isBigEndian, j * width + i, heightSample);\n    }\n  }\n\n  return new HeightmapTerrainData({\n    buffer: heights,\n    width: width,\n    height: height,\n    childTileMask: 0,\n    structure: this._structure,\n    createdByUpsampling: true\n  });\n};\n/**\n * Determines if a given child tile is available, based on the\n * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed\n * to be one of the four children of this tile.  If non-child tile coordinates are\n * given, the availability of the southeast child tile is returned.\n *\n * @param {Number} thisX The tile X coordinate of this (the parent) tile.\n * @param {Number} thisY The tile Y coordinate of this (the parent) tile.\n * @param {Number} childX The tile X coordinate of the child tile to check for availability.\n * @param {Number} childY The tile Y coordinate of the child tile to check for availability.\n * @returns {Boolean} True if the child tile is available; otherwise, false.\n */\n\n\nHeightmapTerrainData.prototype.isChildAvailable = function (thisX, thisY, childX, childY) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n\n  if (!defined(childX)) {\n    throw new DeveloperError(\"childX is required.\");\n  }\n\n  if (!defined(childY)) {\n    throw new DeveloperError(\"childY is required.\");\n  } //>>includeEnd('debug');\n\n\n  var bitNumber = 2; // northwest child\n\n  if (childX !== thisX * 2) {\n    ++bitNumber; // east child\n  }\n\n  if (childY !== thisY * 2) {\n    bitNumber -= 2; // south child\n  }\n\n  return (this._childTileMask & 1 << bitNumber) !== 0;\n};\n/**\n * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution\n * terrain data.  If this value is false, the data was obtained from some other source, such\n * as by downloading it from a remote server.  This method should return true for instances\n * returned from a call to {@link HeightmapTerrainData#upsample}.\n *\n * @returns {Boolean} True if this instance was created by upsampling; otherwise, false.\n */\n\n\nHeightmapTerrainData.prototype.wasCreatedByUpsampling = function () {\n  return this._createdByUpsampling;\n};\n\nfunction interpolateHeight(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, sourceRectangle, width, height, longitude, latitude) {\n  var fromWest = (longitude - sourceRectangle.west) * (width - 1) / (sourceRectangle.east - sourceRectangle.west);\n  var fromSouth = (latitude - sourceRectangle.south) * (height - 1) / (sourceRectangle.north - sourceRectangle.south);\n  var westInteger = fromWest | 0;\n  var eastInteger = westInteger + 1;\n\n  if (eastInteger >= width) {\n    eastInteger = width - 1;\n    westInteger = width - 2;\n  }\n\n  var southInteger = fromSouth | 0;\n  var northInteger = southInteger + 1;\n\n  if (northInteger >= height) {\n    northInteger = height - 1;\n    southInteger = height - 2;\n  }\n\n  var dx = fromWest - westInteger;\n  var dy = fromSouth - southInteger;\n  southInteger = height - 1 - southInteger;\n  northInteger = height - 1 - northInteger;\n  var southwestHeight = getHeight(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, southInteger * width + westInteger);\n  var southeastHeight = getHeight(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, southInteger * width + eastInteger);\n  var northwestHeight = getHeight(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, northInteger * width + westInteger);\n  var northeastHeight = getHeight(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, northInteger * width + eastInteger);\n  return triangleInterpolateHeight(dx, dy, southwestHeight, southeastHeight, northwestHeight, northeastHeight);\n}\n\nfunction interpolateMeshHeight(buffer, encoding, heightOffset, heightScale, sourceRectangle, width, height, longitude, latitude, exaggeration) {\n  // returns a height encoded according to the structure's heightScale and heightOffset.\n  var fromWest = (longitude - sourceRectangle.west) * (width - 1) / (sourceRectangle.east - sourceRectangle.west);\n  var fromSouth = (latitude - sourceRectangle.south) * (height - 1) / (sourceRectangle.north - sourceRectangle.south);\n  var westInteger = fromWest | 0;\n  var eastInteger = westInteger + 1;\n\n  if (eastInteger >= width) {\n    eastInteger = width - 1;\n    westInteger = width - 2;\n  }\n\n  var southInteger = fromSouth | 0;\n  var northInteger = southInteger + 1;\n\n  if (northInteger >= height) {\n    northInteger = height - 1;\n    southInteger = height - 2;\n  }\n\n  var dx = fromWest - westInteger;\n  var dy = fromSouth - southInteger;\n  southInteger = height - 1 - southInteger;\n  northInteger = height - 1 - northInteger;\n  var southwestHeight = (encoding.decodeHeight(buffer, southInteger * width + westInteger) / exaggeration - heightOffset) / heightScale;\n  var southeastHeight = (encoding.decodeHeight(buffer, southInteger * width + eastInteger) / exaggeration - heightOffset) / heightScale;\n  var northwestHeight = (encoding.decodeHeight(buffer, northInteger * width + westInteger) / exaggeration - heightOffset) / heightScale;\n  var northeastHeight = (encoding.decodeHeight(buffer, northInteger * width + eastInteger) / exaggeration - heightOffset) / heightScale;\n  return triangleInterpolateHeight(dx, dy, southwestHeight, southeastHeight, northwestHeight, northeastHeight);\n}\n\nfunction triangleInterpolateHeight(dX, dY, southwestHeight, southeastHeight, northwestHeight, northeastHeight) {\n  // The HeightmapTessellator bisects the quad from southwest to northeast.\n  if (dY < dX) {\n    // Lower right triangle\n    return southwestHeight + dX * (southeastHeight - southwestHeight) + dY * (northeastHeight - southeastHeight);\n  } // Upper left triangle\n\n\n  return southwestHeight + dX * (northeastHeight - northwestHeight) + dY * (northwestHeight - southwestHeight);\n}\n\nfunction getHeight(heights, elementsPerHeight, elementMultiplier, stride, isBigEndian, index) {\n  index *= stride;\n  var height = 0;\n  var i;\n\n  if (isBigEndian) {\n    for (i = 0; i < elementsPerHeight; ++i) {\n      height = height * elementMultiplier + heights[index + i];\n    }\n  } else {\n    for (i = elementsPerHeight - 1; i >= 0; --i) {\n      height = height * elementMultiplier + heights[index + i];\n    }\n  }\n\n  return height;\n}\n\nfunction setHeight(heights, elementsPerHeight, elementMultiplier, divisor, stride, isBigEndian, index, height) {\n  index *= stride;\n  var i;\n\n  if (isBigEndian) {\n    for (i = 0; i < elementsPerHeight - 1; ++i) {\n      heights[index + i] = height / divisor | 0;\n      height -= heights[index + i] * divisor;\n      divisor /= elementMultiplier;\n    }\n  } else {\n    for (i = elementsPerHeight - 1; i > 0; --i) {\n      heights[index + i] = height / divisor | 0;\n      height -= heights[index + i] * divisor;\n      divisor /= elementMultiplier;\n    }\n  }\n\n  heights[index + i] = height;\n}\n\nexport default HeightmapTerrainData;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/HeightmapTerrainData.js"],"names":["when","BoundingSphere","Cartesian3","defaultValue","defined","DeveloperError","GeographicProjection","HeightmapEncoding","HeightmapTessellator","CesiumMath","OrientedBoundingBox","Rectangle","TaskProcessor","TerrainEncoding","TerrainMesh","TerrainProvider","HeightmapTerrainData","options","buffer","width","height","_buffer","_width","_height","_childTileMask","childTileMask","_encoding","encoding","NONE","defaultStructure","DEFAULT_STRUCTURE","structure","heightScale","heightOffset","elementsPerHeight","stride","elementMultiplier","isBigEndian","_structure","_createdByUpsampling","createdByUpsampling","_waterMask","waterMask","_skirtHeight","undefined","_bufferType","LERC","Float32Array","constructor","_mesh","Object","defineProperties","prototype","credits","get","taskProcessor","createMesh","tilingScheme","x","y","level","exaggeration","ellipsoid","nativeRectangle","tileXYToNativeRectangle","rectangle","tileXYToRectangle","center","cartographicToCartesian","levelZeroMaxError","getEstimatedLevelZeroGeometricErrorForAHeightmap","getNumberOfXTilesAtLevel","thisLevelMaxError","Math","min","verticesPromise","scheduleTask","heightmap","includeWebMercatorT","relativeToCenter","skirtHeight","isGeographic","projection","that","result","indicesAndEdges","getRegularGridAndSkirtIndicesAndEdgeIndices","gridWidth","gridHeight","getRegularGridIndicesAndEdgeIndices","vertexCountWithoutSkirts","vertices","indices","indexCountWithoutSkirts","minimumHeight","maximumHeight","clone","boundingSphere3D","occludeePointInScaledSpace","numberOfAttributes","orientedBoundingBox","westIndicesSouthToNorth","southIndicesEastToWest","eastIndicesNorthToSouth","northIndicesWestToEast","_createMeshSync","computeVertices","getStride","interpolateHeight","longitude","latitude","heightSample","interpolateMeshHeight","upsample","thisX","thisY","thisLevel","descendantX","descendantY","descendantLevel","levelDifference","meshData","heights","sourceRectangle","destinationRectangle","divisor","pow","j","lerp","north","south","i","west","east","lowestEncodedHeight","highestEncodedHeight","setHeight","isChildAvailable","childX","childY","bitNumber","wasCreatedByUpsampling","sourceHeights","fromWest","fromSouth","westInteger","eastInteger","southInteger","northInteger","dx","dy","southwestHeight","getHeight","southeastHeight","northwestHeight","northeastHeight","triangleInterpolateHeight","decodeHeight","dX","dY","index"],"mappings":"AAAA,OAAOA,IAAP,MAAiB,uBAAjB;AACA,OAAOC,cAAP,MAA2B,qBAA3B;AACA,OAAOC,UAAP,MAAuB,iBAAvB;AACA,OAAOC,YAAP,MAAyB,mBAAzB;AACA,OAAOC,OAAP,MAAoB,cAApB;AACA,OAAOC,cAAP,MAA2B,qBAA3B;AACA,OAAOC,oBAAP,MAAiC,2BAAjC;AACA,OAAOC,iBAAP,MAA8B,wBAA9B;AACA,OAAOC,oBAAP,MAAiC,2BAAjC;AACA,OAAOC,UAAP,MAAuB,WAAvB;AACA,OAAOC,mBAAP,MAAgC,0BAAhC;AACA,OAAOC,SAAP,MAAsB,gBAAtB;AACA,OAAOC,aAAP,MAA0B,oBAA1B;AACA,OAAOC,eAAP,MAA4B,sBAA5B;AACA,OAAOC,WAAP,MAAwB,kBAAxB;AACA,OAAOC,eAAP,MAA4B,sBAA5B;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6EA,SAASC,oBAAT,CAA8BC,OAA9B,EAAuC;AACrC;AACA,MAAI,CAACb,OAAO,CAACa,OAAD,CAAR,IAAqB,CAACb,OAAO,CAACa,OAAO,CAACC,MAAT,CAAjC,EAAmD;AACjD,UAAM,IAAIb,cAAJ,CAAmB,6BAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAACa,OAAO,CAACE,KAAT,CAAZ,EAA6B;AAC3B,UAAM,IAAId,cAAJ,CAAmB,4BAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAACa,OAAO,CAACG,MAAT,CAAZ,EAA8B;AAC5B,UAAM,IAAIf,cAAJ,CAAmB,6BAAnB,CAAN;AACD,GAVoC,CAWrC;;;AAEA,OAAKgB,OAAL,GAAeJ,OAAO,CAACC,MAAvB;AACA,OAAKI,MAAL,GAAcL,OAAO,CAACE,KAAtB;AACA,OAAKI,OAAL,GAAeN,OAAO,CAACG,MAAvB;AACA,OAAKI,cAAL,GAAsBrB,YAAY,CAACc,OAAO,CAACQ,aAAT,EAAwB,EAAxB,CAAlC;AACA,OAAKC,SAAL,GAAiBvB,YAAY,CAACc,OAAO,CAACU,QAAT,EAAmBpB,iBAAiB,CAACqB,IAArC,CAA7B;AAEA,MAAIC,gBAAgB,GAAGrB,oBAAoB,CAACsB,iBAA5C;AACA,MAAIC,SAAS,GAAGd,OAAO,CAACc,SAAxB;;AACA,MAAI,CAAC3B,OAAO,CAAC2B,SAAD,CAAZ,EAAyB;AACvBA,IAAAA,SAAS,GAAGF,gBAAZ;AACD,GAFD,MAEO,IAAIE,SAAS,KAAKF,gBAAlB,EAAoC;AACzCE,IAAAA,SAAS,CAACC,WAAV,GAAwB7B,YAAY,CAClC4B,SAAS,CAACC,WADwB,EAElCH,gBAAgB,CAACG,WAFiB,CAApC;AAIAD,IAAAA,SAAS,CAACE,YAAV,GAAyB9B,YAAY,CACnC4B,SAAS,CAACE,YADyB,EAEnCJ,gBAAgB,CAACI,YAFkB,CAArC;AAIAF,IAAAA,SAAS,CAACG,iBAAV,GAA8B/B,YAAY,CACxC4B,SAAS,CAACG,iBAD8B,EAExCL,gBAAgB,CAACK,iBAFuB,CAA1C;AAIAH,IAAAA,SAAS,CAACI,MAAV,GAAmBhC,YAAY,CAAC4B,SAAS,CAACI,MAAX,EAAmBN,gBAAgB,CAACM,MAApC,CAA/B;AACAJ,IAAAA,SAAS,CAACK,iBAAV,GAA8BjC,YAAY,CACxC4B,SAAS,CAACK,iBAD8B,EAExCP,gBAAgB,CAACO,iBAFuB,CAA1C;AAIAL,IAAAA,SAAS,CAACM,WAAV,GAAwBlC,YAAY,CAClC4B,SAAS,CAACM,WADwB,EAElCR,gBAAgB,CAACQ,WAFiB,CAApC;AAID;;AAED,OAAKC,UAAL,GAAkBP,SAAlB;AACA,OAAKQ,oBAAL,GAA4BpC,YAAY,CAACc,OAAO,CAACuB,mBAAT,EAA8B,KAA9B,CAAxC;AACA,OAAKC,UAAL,GAAkBxB,OAAO,CAACyB,SAA1B;AAEA,OAAKC,YAAL,GAAoBC,SAApB;AACA,OAAKC,WAAL,GACE,KAAKnB,SAAL,KAAmBnB,iBAAiB,CAACuC,IAArC,GACIC,YADJ,GAEI,KAAK1B,OAAL,CAAa2B,WAHnB;AAIA,OAAKC,KAAL,GAAaL,SAAb;AACD;;AAEDM,MAAM,CAACC,gBAAP,CAAwBnC,oBAAoB,CAACoC,SAA7C,EAAwD;AACtD;;;;;AAKAC,EAAAA,OAAO,EAAE;AACPC,IAAAA,GAAG,EAAE,YAAY;AACf,aAAOV,SAAP;AACD;AAHM,GAN6C;;AAWtD;;;;;;;AAOAF,EAAAA,SAAS,EAAE;AACTY,IAAAA,GAAG,EAAE,YAAY;AACf,aAAO,KAAKb,UAAZ;AACD;AAHQ,GAlB2C;AAwBtDhB,EAAAA,aAAa,EAAE;AACb6B,IAAAA,GAAG,EAAE,YAAY;AACf,aAAO,KAAK9B,cAAZ;AACD;AAHY;AAxBuC,CAAxD;AA+BA,IAAI+B,aAAa,GAAG,IAAI3C,aAAJ,CAAkB,6BAAlB,CAApB;AAEA;;;;;;;;;;;;;;;AAcAI,oBAAoB,CAACoC,SAArB,CAA+BI,UAA/B,GAA4C,UAC1CC,YAD0C,EAE1CC,CAF0C,EAG1CC,CAH0C,EAI1CC,KAJ0C,EAK1CC,YAL0C,EAM1C;AACA;AACA,MAAI,CAACzD,OAAO,CAACqD,YAAD,CAAZ,EAA4B;AAC1B,UAAM,IAAIpD,cAAJ,CAAmB,2BAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAACsD,CAAD,CAAZ,EAAiB;AACf,UAAM,IAAIrD,cAAJ,CAAmB,gBAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAACuD,CAAD,CAAZ,EAAiB;AACf,UAAM,IAAItD,cAAJ,CAAmB,gBAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAACwD,KAAD,CAAZ,EAAqB;AACnB,UAAM,IAAIvD,cAAJ,CAAmB,oBAAnB,CAAN;AACD,GAbD,CAcA;;;AAEA,MAAIyD,SAAS,GAAGL,YAAY,CAACK,SAA7B;AACA,MAAIC,eAAe,GAAGN,YAAY,CAACO,uBAAb,CAAqCN,CAArC,EAAwCC,CAAxC,EAA2CC,KAA3C,CAAtB;AACA,MAAIK,SAAS,GAAGR,YAAY,CAACS,iBAAb,CAA+BR,CAA/B,EAAkCC,CAAlC,EAAqCC,KAArC,CAAhB;AACAC,EAAAA,YAAY,GAAG1D,YAAY,CAAC0D,YAAD,EAAe,GAAf,CAA3B,CAnBA,CAqBA;;AACA,MAAIM,MAAM,GAAGL,SAAS,CAACM,uBAAV,CAAkCzD,SAAS,CAACwD,MAAV,CAAiBF,SAAjB,CAAlC,CAAb;AAEA,MAAIlC,SAAS,GAAG,KAAKO,UAArB;AAEA,MAAI+B,iBAAiB,GAAGtD,eAAe,CAACuD,gDAAhB,CACtBR,SADsB,EAEtB,KAAKxC,MAFiB,EAGtBmC,YAAY,CAACc,wBAAb,CAAsC,CAAtC,CAHsB,CAAxB;AAKA,MAAIC,iBAAiB,GAAGH,iBAAiB,IAAI,KAAKT,KAAT,CAAzC;AACA,OAAKjB,YAAL,GAAoB8B,IAAI,CAACC,GAAL,CAASF,iBAAiB,GAAG,GAA7B,EAAkC,MAAlC,CAApB;AAEA,MAAIG,eAAe,GAAGpB,aAAa,CAACqB,YAAd,CAA2B;AAC/CC,IAAAA,SAAS,EAAE,KAAKxD,OAD+B;AAE/CU,IAAAA,SAAS,EAAEA,SAFoC;AAG/C+C,IAAAA,mBAAmB,EAAE,IAH0B;AAI/C3D,IAAAA,KAAK,EAAE,KAAKG,MAJmC;AAK/CF,IAAAA,MAAM,EAAE,KAAKG,OALkC;AAM/CwC,IAAAA,eAAe,EAAEA,eAN8B;AAO/CE,IAAAA,SAAS,EAAEA,SAPoC;AAQ/Cc,IAAAA,gBAAgB,EAAEZ,MAR6B;AAS/CL,IAAAA,SAAS,EAAEA,SAToC;AAU/CkB,IAAAA,WAAW,EAAE,KAAKrC,YAV6B;AAW/CsC,IAAAA,YAAY,EAAExB,YAAY,CAACyB,UAAb,YAAmC5E,oBAXF;AAY/CuD,IAAAA,YAAY,EAAEA,YAZiC;AAa/ClC,IAAAA,QAAQ,EAAE,KAAKD;AAbgC,GAA3B,CAAtB;;AAgBA,MAAI,CAACtB,OAAO,CAACuE,eAAD,CAAZ,EAA+B;AAC7B;AACA,WAAO/B,SAAP;AACD;;AAED,MAAIuC,IAAI,GAAG,IAAX;AACA,SAAOnF,IAAI,CAAC2E,eAAD,EAAkB,UAAUS,MAAV,EAAkB;AAC7C,QAAIC,eAAJ;;AACA,QAAIF,IAAI,CAACxC,YAAL,GAAoB,GAAxB,EAA6B;AAC3B0C,MAAAA,eAAe,GAAGtE,eAAe,CAACuE,2CAAhB,CAChBF,MAAM,CAACG,SADS,EAEhBH,MAAM,CAACI,UAFS,CAAlB;AAID,KALD,MAKO;AACLH,MAAAA,eAAe,GAAGtE,eAAe,CAAC0E,mCAAhB,CAChBL,MAAM,CAACG,SADS,EAEhBH,MAAM,CAACI,UAFS,CAAlB;AAID;;AAED,QAAIE,wBAAwB,GAAGN,MAAM,CAACG,SAAP,GAAmBH,MAAM,CAACI,UAAzD,CAd6C,CAgB7C;AACA;;AACAL,IAAAA,IAAI,CAAClC,KAAL,GAAa,IAAInC,WAAJ,CACXqD,MADW,EAEX,IAAIpB,YAAJ,CAAiBqC,MAAM,CAACO,QAAxB,CAFW,EAGXN,eAAe,CAACO,OAHL,EAIXP,eAAe,CAACQ,uBAJL,EAKXH,wBALW,EAMXN,MAAM,CAACU,aANI,EAOXV,MAAM,CAACW,aAPI,EAQX9F,cAAc,CAAC+F,KAAf,CAAqBZ,MAAM,CAACa,gBAA5B,CARW,EASX/F,UAAU,CAAC8F,KAAX,CAAiBZ,MAAM,CAACc,0BAAxB,CATW,EAUXd,MAAM,CAACe,kBAVI,EAWXzF,mBAAmB,CAACsF,KAApB,CAA0BZ,MAAM,CAACgB,mBAAjC,CAXW,EAYXvF,eAAe,CAACmF,KAAhB,CAAsBZ,MAAM,CAACzD,QAA7B,CAZW,EAaXkC,YAbW,EAcXwB,eAAe,CAACgB,uBAdL,EAeXhB,eAAe,CAACiB,sBAfL,EAgBXjB,eAAe,CAACkB,uBAhBL,EAiBXlB,eAAe,CAACmB,sBAjBL,CAAb,CAlB6C,CAsC7C;;AACArB,IAAAA,IAAI,CAAC9D,OAAL,GAAeuB,SAAf;AACA,WAAOuC,IAAI,CAAClC,KAAZ;AACD,GAzCU,CAAX;AA0CD,CAxGD;AA0GA;;;;;AAGAjC,oBAAoB,CAACoC,SAArB,CAA+BqD,eAA/B,GAAiD,UAC/ChD,YAD+C,EAE/CC,CAF+C,EAG/CC,CAH+C,EAI/CC,KAJ+C,EAK/CC,YAL+C,EAM/C;AACA;AACA,MAAI,CAACzD,OAAO,CAACqD,YAAD,CAAZ,EAA4B;AAC1B,UAAM,IAAIpD,cAAJ,CAAmB,2BAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAACsD,CAAD,CAAZ,EAAiB;AACf,UAAM,IAAIrD,cAAJ,CAAmB,gBAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAACuD,CAAD,CAAZ,EAAiB;AACf,UAAM,IAAItD,cAAJ,CAAmB,gBAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAACwD,KAAD,CAAZ,EAAqB;AACnB,UAAM,IAAIvD,cAAJ,CAAmB,oBAAnB,CAAN;AACD,GAbD,CAcA;;;AAEA,MAAIyD,SAAS,GAAGL,YAAY,CAACK,SAA7B;AACA,MAAIC,eAAe,GAAGN,YAAY,CAACO,uBAAb,CAAqCN,CAArC,EAAwCC,CAAxC,EAA2CC,KAA3C,CAAtB;AACA,MAAIK,SAAS,GAAGR,YAAY,CAACS,iBAAb,CAA+BR,CAA/B,EAAkCC,CAAlC,EAAqCC,KAArC,CAAhB;AACAC,EAAAA,YAAY,GAAG1D,YAAY,CAAC0D,YAAD,EAAe,GAAf,CAA3B,CAnBA,CAqBA;;AACA,MAAIM,MAAM,GAAGL,SAAS,CAACM,uBAAV,CAAkCzD,SAAS,CAACwD,MAAV,CAAiBF,SAAjB,CAAlC,CAAb;AAEA,MAAIlC,SAAS,GAAG,KAAKO,UAArB;AAEA,MAAI+B,iBAAiB,GAAGtD,eAAe,CAACuD,gDAAhB,CACtBR,SADsB,EAEtB,KAAKxC,MAFiB,EAGtBmC,YAAY,CAACc,wBAAb,CAAsC,CAAtC,CAHsB,CAAxB;AAKA,MAAIC,iBAAiB,GAAGH,iBAAiB,IAAI,KAAKT,KAAT,CAAzC;AACA,OAAKjB,YAAL,GAAoB8B,IAAI,CAACC,GAAL,CAASF,iBAAiB,GAAG,GAA7B,EAAkC,MAAlC,CAApB;AAEA,MAAIY,MAAM,GAAG5E,oBAAoB,CAACkG,eAArB,CAAqC;AAChD7B,IAAAA,SAAS,EAAE,KAAKxD,OADgC;AAEhDU,IAAAA,SAAS,EAAEA,SAFqC;AAGhD+C,IAAAA,mBAAmB,EAAE,IAH2B;AAIhD3D,IAAAA,KAAK,EAAE,KAAKG,MAJoC;AAKhDF,IAAAA,MAAM,EAAE,KAAKG,OALmC;AAMhDwC,IAAAA,eAAe,EAAEA,eAN+B;AAOhDE,IAAAA,SAAS,EAAEA,SAPqC;AAQhDc,IAAAA,gBAAgB,EAAEZ,MAR8B;AAShDL,IAAAA,SAAS,EAAEA,SATqC;AAUhDkB,IAAAA,WAAW,EAAE,KAAKrC,YAV8B;AAWhDsC,IAAAA,YAAY,EAAExB,YAAY,CAACyB,UAAb,YAAmC5E,oBAXD;AAYhDuD,IAAAA,YAAY,EAAEA;AAZkC,GAArC,CAAb,CAlCA,CAiDA;;AACA,OAAKxC,OAAL,GAAeuB,SAAf;AAEA,MAAIyC,eAAJ;;AACA,MAAI,KAAK1C,YAAL,GAAoB,GAAxB,EAA6B;AAC3B0C,IAAAA,eAAe,GAAGtE,eAAe,CAACuE,2CAAhB,CAChB,KAAKhE,MADW,EAEhB,KAAKC,OAFW,CAAlB;AAID,GALD,MAKO;AACL8D,IAAAA,eAAe,GAAGtE,eAAe,CAAC0E,mCAAhB,CAChB,KAAKnE,MADW,EAEhB,KAAKC,OAFW,CAAlB;AAID;;AAED,MAAImE,wBAAwB,GAAGN,MAAM,CAACG,SAAP,GAAmBH,MAAM,CAACI,UAAzD,CAjEA,CAmEA;AACA;;AACA,SAAO,IAAI1E,WAAJ,CACLqD,MADK,EAELiB,MAAM,CAACO,QAFF,EAGLN,eAAe,CAACO,OAHX,EAILP,eAAe,CAACQ,uBAJX,EAKLH,wBALK,EAMLN,MAAM,CAACU,aANF,EAOLV,MAAM,CAACW,aAPF,EAQLX,MAAM,CAACa,gBARF,EASLb,MAAM,CAACc,0BATF,EAULd,MAAM,CAACzD,QAAP,CAAgBgF,SAAhB,EAVK,EAWLvB,MAAM,CAACgB,mBAXF,EAYLhB,MAAM,CAACzD,QAZF,EAaLkC,YAbK,EAcLwB,eAAe,CAACgB,uBAdX,EAeLhB,eAAe,CAACiB,sBAfX,EAgBLjB,eAAe,CAACkB,uBAhBX,EAiBLlB,eAAe,CAACmB,sBAjBX,CAAP;AAmBD,CA9FD;AAgGA;;;;;;;;;;;;AAUAxF,oBAAoB,CAACoC,SAArB,CAA+BwD,iBAA/B,GAAmD,UACjD3C,SADiD,EAEjD4C,SAFiD,EAGjDC,QAHiD,EAIjD;AACA,MAAI3F,KAAK,GAAG,KAAKG,MAAjB;AACA,MAAIF,MAAM,GAAG,KAAKG,OAAlB;AAEA,MAAIQ,SAAS,GAAG,KAAKO,UAArB;AACA,MAAIH,MAAM,GAAGJ,SAAS,CAACI,MAAvB;AACA,MAAID,iBAAiB,GAAGH,SAAS,CAACG,iBAAlC;AACA,MAAIE,iBAAiB,GAAGL,SAAS,CAACK,iBAAlC;AACA,MAAIC,WAAW,GAAGN,SAAS,CAACM,WAA5B;AACA,MAAIJ,YAAY,GAAGF,SAAS,CAACE,YAA7B;AACA,MAAID,WAAW,GAAGD,SAAS,CAACC,WAA5B;AAEA,MAAI+E,YAAJ;;AACA,MAAI3G,OAAO,CAAC,KAAK6C,KAAN,CAAX,EAAyB;AACvB,QAAI/B,MAAM,GAAG,KAAK+B,KAAL,CAAW0C,QAAxB;AACA,QAAIhE,QAAQ,GAAG,KAAKsB,KAAL,CAAWtB,QAA1B;AACA,QAAIkC,YAAY,GAAG,KAAKZ,KAAL,CAAWY,YAA9B;AACAkD,IAAAA,YAAY,GAAGC,qBAAqB,CAClC9F,MADkC,EAElCS,QAFkC,EAGlCM,YAHkC,EAIlCD,WAJkC,EAKlCiC,SALkC,EAMlC9C,KANkC,EAOlCC,MAPkC,EAQlCyF,SARkC,EASlCC,QATkC,EAUlCjD,YAVkC,CAApC;AAYD,GAhBD,MAgBO;AACLkD,IAAAA,YAAY,GAAGH,iBAAiB,CAC9B,KAAKvF,OADyB,EAE9Ba,iBAF8B,EAG9BE,iBAH8B,EAI9BD,MAJ8B,EAK9BE,WAL8B,EAM9B4B,SAN8B,EAO9B9C,KAP8B,EAQ9BC,MAR8B,EAS9ByF,SAT8B,EAU9BC,QAV8B,CAAhC;AAYAC,IAAAA,YAAY,GAAGA,YAAY,GAAG/E,WAAf,GAA6BC,YAA5C;AACD;;AAED,SAAO8E,YAAP;AACD,CAlDD;AAoDA;;;;;;;;;;;;;;;;;AAeA/F,oBAAoB,CAACoC,SAArB,CAA+B6D,QAA/B,GAA0C,UACxCxD,YADwC,EAExCyD,KAFwC,EAGxCC,KAHwC,EAIxCC,SAJwC,EAKxCC,WALwC,EAMxCC,WANwC,EAOxCC,eAPwC,EAQxC;AACA;AACA,MAAI,CAACnH,OAAO,CAACqD,YAAD,CAAZ,EAA4B;AAC1B,UAAM,IAAIpD,cAAJ,CAAmB,2BAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAAC8G,KAAD,CAAZ,EAAqB;AACnB,UAAM,IAAI7G,cAAJ,CAAmB,oBAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAAC+G,KAAD,CAAZ,EAAqB;AACnB,UAAM,IAAI9G,cAAJ,CAAmB,oBAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAACgH,SAAD,CAAZ,EAAyB;AACvB,UAAM,IAAI/G,cAAJ,CAAmB,wBAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAACiH,WAAD,CAAZ,EAA2B;AACzB,UAAM,IAAIhH,cAAJ,CAAmB,0BAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAACkH,WAAD,CAAZ,EAA2B;AACzB,UAAM,IAAIjH,cAAJ,CAAmB,0BAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAACmH,eAAD,CAAZ,EAA+B;AAC7B,UAAM,IAAIlH,cAAJ,CAAmB,8BAAnB,CAAN;AACD;;AACD,MAAImH,eAAe,GAAGD,eAAe,GAAGH,SAAxC;;AACA,MAAII,eAAe,GAAG,CAAtB,EAAyB;AACvB,UAAM,IAAInH,cAAJ,CACJ,8EADI,CAAN;AAGD,GA5BD,CA6BA;;;AAEA,MAAIoH,QAAQ,GAAG,KAAKxE,KAApB;;AACA,MAAI,CAAC7C,OAAO,CAACqH,QAAD,CAAZ,EAAwB;AACtB,WAAO7E,SAAP;AACD;;AAED,MAAIzB,KAAK,GAAG,KAAKG,MAAjB;AACA,MAAIF,MAAM,GAAG,KAAKG,OAAlB;AACA,MAAIQ,SAAS,GAAG,KAAKO,UAArB;AACA,MAAIH,MAAM,GAAGJ,SAAS,CAACI,MAAvB;AAEA,MAAIuF,OAAO,GAAG,IAAI,KAAK7E,WAAT,CAAqB1B,KAAK,GAAGC,MAAR,GAAiBe,MAAtC,CAAd;AAEA,MAAIjB,MAAM,GAAGuG,QAAQ,CAAC9B,QAAtB;AACA,MAAIhE,QAAQ,GAAG8F,QAAQ,CAAC9F,QAAxB,CA5CA,CA8CA;;AACA,MAAIgG,eAAe,GAAGlE,YAAY,CAACS,iBAAb,CAA+BgD,KAA/B,EAAsCC,KAAtC,EAA6CC,SAA7C,CAAtB;AACA,MAAIQ,oBAAoB,GAAGnE,YAAY,CAACS,iBAAb,CACzBmD,WADyB,EAEzBC,WAFyB,EAGzBC,eAHyB,CAA3B;AAMA,MAAItF,YAAY,GAAGF,SAAS,CAACE,YAA7B;AACA,MAAID,WAAW,GAAGD,SAAS,CAACC,WAA5B;AACA,MAAI6B,YAAY,GAAG4D,QAAQ,CAAC5D,YAA5B;AAEA,MAAI3B,iBAAiB,GAAGH,SAAS,CAACG,iBAAlC;AACA,MAAIE,iBAAiB,GAAGL,SAAS,CAACK,iBAAlC;AACA,MAAIC,WAAW,GAAGN,SAAS,CAACM,WAA5B;AAEA,MAAIwF,OAAO,GAAGpD,IAAI,CAACqD,GAAL,CAAS1F,iBAAT,EAA4BF,iBAAiB,GAAG,CAAhD,CAAd;;AAEA,OAAK,IAAI6F,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG3G,MAApB,EAA4B,EAAE2G,CAA9B,EAAiC;AAC/B,QAAIjB,QAAQ,GAAGrG,UAAU,CAACuH,IAAX,CACbJ,oBAAoB,CAACK,KADR,EAEbL,oBAAoB,CAACM,KAFR,EAGbH,CAAC,IAAI3G,MAAM,GAAG,CAAb,CAHY,CAAf;;AAKA,SAAK,IAAI+G,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhH,KAApB,EAA2B,EAAEgH,CAA7B,EAAgC;AAC9B,UAAItB,SAAS,GAAGpG,UAAU,CAACuH,IAAX,CACdJ,oBAAoB,CAACQ,IADP,EAEdR,oBAAoB,CAACS,IAFP,EAGdF,CAAC,IAAIhH,KAAK,GAAG,CAAZ,CAHa,CAAhB;AAKA,UAAI4F,YAAY,GAAGC,qBAAqB,CACtC9F,MADsC,EAEtCS,QAFsC,EAGtCM,YAHsC,EAItCD,WAJsC,EAKtC2F,eALsC,EAMtCxG,KANsC,EAOtCC,MAPsC,EAQtCyF,SARsC,EAStCC,QATsC,EAUtCjD,YAVsC,CAAxC,CAN8B,CAmB9B;AACA;;AACAkD,MAAAA,YAAY,GACVA,YAAY,GAAGhF,SAAS,CAACuG,mBAAzB,GACIvG,SAAS,CAACuG,mBADd,GAEIvB,YAHN;AAIAA,MAAAA,YAAY,GACVA,YAAY,GAAGhF,SAAS,CAACwG,oBAAzB,GACIxG,SAAS,CAACwG,oBADd,GAEIxB,YAHN;AAKAyB,MAAAA,SAAS,CACPd,OADO,EAEPxF,iBAFO,EAGPE,iBAHO,EAIPyF,OAJO,EAKP1F,MALO,EAMPE,WANO,EAOP0F,CAAC,GAAG5G,KAAJ,GAAYgH,CAPL,EAQPpB,YARO,CAAT;AAUD;AACF;;AAED,SAAO,IAAI/F,oBAAJ,CAAyB;AAC9BE,IAAAA,MAAM,EAAEwG,OADsB;AAE9BvG,IAAAA,KAAK,EAAEA,KAFuB;AAG9BC,IAAAA,MAAM,EAAEA,MAHsB;AAI9BK,IAAAA,aAAa,EAAE,CAJe;AAK9BM,IAAAA,SAAS,EAAE,KAAKO,UALc;AAM9BE,IAAAA,mBAAmB,EAAE;AANS,GAAzB,CAAP;AAQD,CAjID;AAmIA;;;;;;;;;;;;;;AAYAxB,oBAAoB,CAACoC,SAArB,CAA+BqF,gBAA/B,GAAkD,UAChDvB,KADgD,EAEhDC,KAFgD,EAGhDuB,MAHgD,EAIhDC,MAJgD,EAKhD;AACA;AACA,MAAI,CAACvI,OAAO,CAAC8G,KAAD,CAAZ,EAAqB;AACnB,UAAM,IAAI7G,cAAJ,CAAmB,oBAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAAC+G,KAAD,CAAZ,EAAqB;AACnB,UAAM,IAAI9G,cAAJ,CAAmB,oBAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAACsI,MAAD,CAAZ,EAAsB;AACpB,UAAM,IAAIrI,cAAJ,CAAmB,qBAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAACuI,MAAD,CAAZ,EAAsB;AACpB,UAAM,IAAItI,cAAJ,CAAmB,qBAAnB,CAAN;AACD,GAbD,CAcA;;;AAEA,MAAIuI,SAAS,GAAG,CAAhB,CAhBA,CAgBmB;;AACnB,MAAIF,MAAM,KAAKxB,KAAK,GAAG,CAAvB,EAA0B;AACxB,MAAE0B,SAAF,CADwB,CACX;AACd;;AACD,MAAID,MAAM,KAAKxB,KAAK,GAAG,CAAvB,EAA0B;AACxByB,IAAAA,SAAS,IAAI,CAAb,CADwB,CACR;AACjB;;AAED,SAAO,CAAC,KAAKpH,cAAL,GAAuB,KAAKoH,SAA7B,MAA6C,CAApD;AACD,CA9BD;AAgCA;;;;;;;;;;AAQA5H,oBAAoB,CAACoC,SAArB,CAA+ByF,sBAA/B,GAAwD,YAAY;AAClE,SAAO,KAAKtG,oBAAZ;AACD,CAFD;;AAIA,SAASqE,iBAAT,CACEkC,aADF,EAEE5G,iBAFF,EAGEE,iBAHF,EAIED,MAJF,EAKEE,WALF,EAMEsF,eANF,EAOExG,KAPF,EAQEC,MARF,EASEyF,SATF,EAUEC,QAVF,EAWE;AACA,MAAIiC,QAAQ,GACT,CAAClC,SAAS,GAAGc,eAAe,CAACS,IAA7B,KAAsCjH,KAAK,GAAG,CAA9C,CAAD,IACCwG,eAAe,CAACU,IAAhB,GAAuBV,eAAe,CAACS,IADxC,CADF;AAGA,MAAIY,SAAS,GACV,CAAClC,QAAQ,GAAGa,eAAe,CAACO,KAA5B,KAAsC9G,MAAM,GAAG,CAA/C,CAAD,IACCuG,eAAe,CAACM,KAAhB,GAAwBN,eAAe,CAACO,KADzC,CADF;AAIA,MAAIe,WAAW,GAAGF,QAAQ,GAAG,CAA7B;AACA,MAAIG,WAAW,GAAGD,WAAW,GAAG,CAAhC;;AACA,MAAIC,WAAW,IAAI/H,KAAnB,EAA0B;AACxB+H,IAAAA,WAAW,GAAG/H,KAAK,GAAG,CAAtB;AACA8H,IAAAA,WAAW,GAAG9H,KAAK,GAAG,CAAtB;AACD;;AAED,MAAIgI,YAAY,GAAGH,SAAS,GAAG,CAA/B;AACA,MAAII,YAAY,GAAGD,YAAY,GAAG,CAAlC;;AACA,MAAIC,YAAY,IAAIhI,MAApB,EAA4B;AAC1BgI,IAAAA,YAAY,GAAGhI,MAAM,GAAG,CAAxB;AACA+H,IAAAA,YAAY,GAAG/H,MAAM,GAAG,CAAxB;AACD;;AAED,MAAIiI,EAAE,GAAGN,QAAQ,GAAGE,WAApB;AACA,MAAIK,EAAE,GAAGN,SAAS,GAAGG,YAArB;AAEAA,EAAAA,YAAY,GAAG/H,MAAM,GAAG,CAAT,GAAa+H,YAA5B;AACAC,EAAAA,YAAY,GAAGhI,MAAM,GAAG,CAAT,GAAagI,YAA5B;AAEA,MAAIG,eAAe,GAAGC,SAAS,CAC7BV,aAD6B,EAE7B5G,iBAF6B,EAG7BE,iBAH6B,EAI7BD,MAJ6B,EAK7BE,WAL6B,EAM7B8G,YAAY,GAAGhI,KAAf,GAAuB8H,WANM,CAA/B;AAQA,MAAIQ,eAAe,GAAGD,SAAS,CAC7BV,aAD6B,EAE7B5G,iBAF6B,EAG7BE,iBAH6B,EAI7BD,MAJ6B,EAK7BE,WAL6B,EAM7B8G,YAAY,GAAGhI,KAAf,GAAuB+H,WANM,CAA/B;AAQA,MAAIQ,eAAe,GAAGF,SAAS,CAC7BV,aAD6B,EAE7B5G,iBAF6B,EAG7BE,iBAH6B,EAI7BD,MAJ6B,EAK7BE,WAL6B,EAM7B+G,YAAY,GAAGjI,KAAf,GAAuB8H,WANM,CAA/B;AAQA,MAAIU,eAAe,GAAGH,SAAS,CAC7BV,aAD6B,EAE7B5G,iBAF6B,EAG7BE,iBAH6B,EAI7BD,MAJ6B,EAK7BE,WAL6B,EAM7B+G,YAAY,GAAGjI,KAAf,GAAuB+H,WANM,CAA/B;AASA,SAAOU,yBAAyB,CAC9BP,EAD8B,EAE9BC,EAF8B,EAG9BC,eAH8B,EAI9BE,eAJ8B,EAK9BC,eAL8B,EAM9BC,eAN8B,CAAhC;AAQD;;AAED,SAAS3C,qBAAT,CACE9F,MADF,EAEES,QAFF,EAGEM,YAHF,EAIED,WAJF,EAKE2F,eALF,EAMExG,KANF,EAOEC,MAPF,EAQEyF,SARF,EASEC,QATF,EAUEjD,YAVF,EAWE;AACA;AACA,MAAIkF,QAAQ,GACT,CAAClC,SAAS,GAAGc,eAAe,CAACS,IAA7B,KAAsCjH,KAAK,GAAG,CAA9C,CAAD,IACCwG,eAAe,CAACU,IAAhB,GAAuBV,eAAe,CAACS,IADxC,CADF;AAGA,MAAIY,SAAS,GACV,CAAClC,QAAQ,GAAGa,eAAe,CAACO,KAA5B,KAAsC9G,MAAM,GAAG,CAA/C,CAAD,IACCuG,eAAe,CAACM,KAAhB,GAAwBN,eAAe,CAACO,KADzC,CADF;AAIA,MAAIe,WAAW,GAAGF,QAAQ,GAAG,CAA7B;AACA,MAAIG,WAAW,GAAGD,WAAW,GAAG,CAAhC;;AACA,MAAIC,WAAW,IAAI/H,KAAnB,EAA0B;AACxB+H,IAAAA,WAAW,GAAG/H,KAAK,GAAG,CAAtB;AACA8H,IAAAA,WAAW,GAAG9H,KAAK,GAAG,CAAtB;AACD;;AAED,MAAIgI,YAAY,GAAGH,SAAS,GAAG,CAA/B;AACA,MAAII,YAAY,GAAGD,YAAY,GAAG,CAAlC;;AACA,MAAIC,YAAY,IAAIhI,MAApB,EAA4B;AAC1BgI,IAAAA,YAAY,GAAGhI,MAAM,GAAG,CAAxB;AACA+H,IAAAA,YAAY,GAAG/H,MAAM,GAAG,CAAxB;AACD;;AAED,MAAIiI,EAAE,GAAGN,QAAQ,GAAGE,WAApB;AACA,MAAIK,EAAE,GAAGN,SAAS,GAAGG,YAArB;AAEAA,EAAAA,YAAY,GAAG/H,MAAM,GAAG,CAAT,GAAa+H,YAA5B;AACAC,EAAAA,YAAY,GAAGhI,MAAM,GAAG,CAAT,GAAagI,YAA5B;AAEA,MAAIG,eAAe,GACjB,CAAC5H,QAAQ,CAACkI,YAAT,CAAsB3I,MAAtB,EAA8BiI,YAAY,GAAGhI,KAAf,GAAuB8H,WAArD,IACCpF,YADD,GAEC5B,YAFF,IAGAD,WAJF;AAKA,MAAIyH,eAAe,GACjB,CAAC9H,QAAQ,CAACkI,YAAT,CAAsB3I,MAAtB,EAA8BiI,YAAY,GAAGhI,KAAf,GAAuB+H,WAArD,IACCrF,YADD,GAEC5B,YAFF,IAGAD,WAJF;AAKA,MAAI0H,eAAe,GACjB,CAAC/H,QAAQ,CAACkI,YAAT,CAAsB3I,MAAtB,EAA8BkI,YAAY,GAAGjI,KAAf,GAAuB8H,WAArD,IACCpF,YADD,GAEC5B,YAFF,IAGAD,WAJF;AAKA,MAAI2H,eAAe,GACjB,CAAChI,QAAQ,CAACkI,YAAT,CAAsB3I,MAAtB,EAA8BkI,YAAY,GAAGjI,KAAf,GAAuB+H,WAArD,IACCrF,YADD,GAEC5B,YAFF,IAGAD,WAJF;AAMA,SAAO4H,yBAAyB,CAC9BP,EAD8B,EAE9BC,EAF8B,EAG9BC,eAH8B,EAI9BE,eAJ8B,EAK9BC,eAL8B,EAM9BC,eAN8B,CAAhC;AAQD;;AAED,SAASC,yBAAT,CACEE,EADF,EAEEC,EAFF,EAGER,eAHF,EAIEE,eAJF,EAKEC,eALF,EAMEC,eANF,EAOE;AACA;AACA,MAAII,EAAE,GAAGD,EAAT,EAAa;AACX;AACA,WACEP,eAAe,GACfO,EAAE,IAAIL,eAAe,GAAGF,eAAtB,CADF,GAEAQ,EAAE,IAAIJ,eAAe,GAAGF,eAAtB,CAHJ;AAKD,GATD,CAWA;;;AACA,SACEF,eAAe,GACfO,EAAE,IAAIH,eAAe,GAAGD,eAAtB,CADF,GAEAK,EAAE,IAAIL,eAAe,GAAGH,eAAtB,CAHJ;AAKD;;AAED,SAASC,SAAT,CACE9B,OADF,EAEExF,iBAFF,EAGEE,iBAHF,EAIED,MAJF,EAKEE,WALF,EAME2H,KANF,EAOE;AACAA,EAAAA,KAAK,IAAI7H,MAAT;AAEA,MAAIf,MAAM,GAAG,CAAb;AACA,MAAI+G,CAAJ;;AAEA,MAAI9F,WAAJ,EAAiB;AACf,SAAK8F,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGjG,iBAAhB,EAAmC,EAAEiG,CAArC,EAAwC;AACtC/G,MAAAA,MAAM,GAAGA,MAAM,GAAGgB,iBAAT,GAA6BsF,OAAO,CAACsC,KAAK,GAAG7B,CAAT,CAA7C;AACD;AACF,GAJD,MAIO;AACL,SAAKA,CAAC,GAAGjG,iBAAiB,GAAG,CAA7B,EAAgCiG,CAAC,IAAI,CAArC,EAAwC,EAAEA,CAA1C,EAA6C;AAC3C/G,MAAAA,MAAM,GAAGA,MAAM,GAAGgB,iBAAT,GAA6BsF,OAAO,CAACsC,KAAK,GAAG7B,CAAT,CAA7C;AACD;AACF;;AAED,SAAO/G,MAAP;AACD;;AAED,SAASoH,SAAT,CACEd,OADF,EAEExF,iBAFF,EAGEE,iBAHF,EAIEyF,OAJF,EAKE1F,MALF,EAMEE,WANF,EAOE2H,KAPF,EAQE5I,MARF,EASE;AACA4I,EAAAA,KAAK,IAAI7H,MAAT;AAEA,MAAIgG,CAAJ;;AACA,MAAI9F,WAAJ,EAAiB;AACf,SAAK8F,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGjG,iBAAiB,GAAG,CAApC,EAAuC,EAAEiG,CAAzC,EAA4C;AAC1CT,MAAAA,OAAO,CAACsC,KAAK,GAAG7B,CAAT,CAAP,GAAsB/G,MAAM,GAAGyG,OAAV,GAAqB,CAA1C;AACAzG,MAAAA,MAAM,IAAIsG,OAAO,CAACsC,KAAK,GAAG7B,CAAT,CAAP,GAAqBN,OAA/B;AACAA,MAAAA,OAAO,IAAIzF,iBAAX;AACD;AACF,GAND,MAMO;AACL,SAAK+F,CAAC,GAAGjG,iBAAiB,GAAG,CAA7B,EAAgCiG,CAAC,GAAG,CAApC,EAAuC,EAAEA,CAAzC,EAA4C;AAC1CT,MAAAA,OAAO,CAACsC,KAAK,GAAG7B,CAAT,CAAP,GAAsB/G,MAAM,GAAGyG,OAAV,GAAqB,CAA1C;AACAzG,MAAAA,MAAM,IAAIsG,OAAO,CAACsC,KAAK,GAAG7B,CAAT,CAAP,GAAqBN,OAA/B;AACAA,MAAAA,OAAO,IAAIzF,iBAAX;AACD;AACF;;AACDsF,EAAAA,OAAO,CAACsC,KAAK,GAAG7B,CAAT,CAAP,GAAqB/G,MAArB;AACD;;AACD,eAAeJ,oBAAf","sourcesContent":["import when from \"../ThirdParty/when.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport HeightmapEncoding from \"./HeightmapEncoding.js\";\nimport HeightmapTessellator from \"./HeightmapTessellator.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport TerrainMesh from \"./TerrainMesh.js\";\nimport TerrainProvider from \"./TerrainProvider.js\";\n\n/**\n * Terrain data for a single tile where the terrain data is represented as a heightmap.  A heightmap\n * is a rectangular array of heights in row-major order from north to south and west to east.\n *\n * @alias HeightmapTerrainData\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {TypedArray} options.buffer The buffer containing height data.\n * @param {Number} options.width The width (longitude direction) of the heightmap, in samples.\n * @param {Number} options.height The height (latitude direction) of the heightmap, in samples.\n * @param {Number} [options.childTileMask=15] A bit mask indicating which of this tile's four children exist.\n *                 If a child's bit is set, geometry will be requested for that tile as well when it\n *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is\n *                 instead upsampled from the parent.  The bit values are as follows:\n *                 <table>\n *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *                  <tr><td>2</td><td>4</td><td>Northwest</td></tr>\n *                  <tr><td>3</td><td>8</td><td>Northeast</td></tr>\n *                 </table>\n * @param {Uint8Array} [options.waterMask] The water mask included in this terrain data, if any.  A water mask is a square\n *                     Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n *                     Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n * @param {Object} [options.structure] An object describing the structure of the height data.\n * @param {Number} [options.structure.heightScale=1.0] The factor by which to multiply height samples in order to obtain\n *                 the height above the heightOffset, in meters.  The heightOffset is added to the resulting\n *                 height after multiplying by the scale.\n * @param {Number} [options.structure.heightOffset=0.0] The offset to add to the scaled height to obtain the final\n *                 height in meters.  The offset is added after the height sample is multiplied by the\n *                 heightScale.\n * @param {Number} [options.structure.elementsPerHeight=1] The number of elements in the buffer that make up a single height\n *                 sample.  This is usually 1, indicating that each element is a separate height sample.  If\n *                 it is greater than 1, that number of elements together form the height sample, which is\n *                 computed according to the structure.elementMultiplier and structure.isBigEndian properties.\n * @param {Number} [options.structure.stride=1] The number of elements to skip to get from the first element of\n *                 one height to the first element of the next height.\n * @param {Number} [options.structure.elementMultiplier=256.0] The multiplier used to compute the height value when the\n *                 stride property is greater than 1.  For example, if the stride is 4 and the strideMultiplier\n *                 is 256, the height is computed as follows:\n *                 `height = buffer[index] + buffer[index + 1] * 256 + buffer[index + 2] * 256 * 256 + buffer[index + 3] * 256 * 256 * 256`\n *                 This is assuming that the isBigEndian property is false.  If it is true, the order of the\n *                 elements is reversed.\n * @param {Boolean} [options.structure.isBigEndian=false] Indicates endianness of the elements in the buffer when the\n *                  stride property is greater than 1.  If this property is false, the first element is the\n *                  low-order element.  If it is true, the first element is the high-order element.\n * @param {Number} [options.structure.lowestEncodedHeight] The lowest value that can be stored in the height buffer.  Any heights that are lower\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be 0 because a `Uint16Array` cannot store negative numbers.  If this parameter is\n *                 not specified, no minimum value is enforced.\n * @param {Number} [options.structure.highestEncodedHeight] The highest value that can be stored in the height buffer.  Any heights that are higher\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be `256 * 256 - 1` or 65535 because a `Uint16Array` cannot store numbers larger\n *                 than 65535.  If this parameter is not specified, no maximum value is enforced.\n * @param {HeightmapEncoding} [options.encoding=HeightmapEncoding.NONE] The encoding that is used on the buffer.\n * @param {Boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;\n *                  otherwise, false.\n *\n *\n * @example\n * var buffer = ...\n * var heightBuffer = new Uint16Array(buffer, 0, that._heightmapWidth * that._heightmapWidth);\n * var childTileMask = new Uint8Array(buffer, heightBuffer.byteLength, 1)[0];\n * var waterMask = new Uint8Array(buffer, heightBuffer.byteLength + 1, buffer.byteLength - heightBuffer.byteLength - 1);\n * var terrainData = new Cesium.HeightmapTerrainData({\n *   buffer : heightBuffer,\n *   width : 65,\n *   height : 65,\n *   childTileMask : childTileMask,\n *   waterMask : waterMask\n * });\n *\n * @see TerrainData\n * @see QuantizedMeshTerrainData\n * @see GoogleEarthEnterpriseTerrainData\n */\nfunction HeightmapTerrainData(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.buffer)) {\n    throw new DeveloperError(\"options.buffer is required.\");\n  }\n  if (!defined(options.width)) {\n    throw new DeveloperError(\"options.width is required.\");\n  }\n  if (!defined(options.height)) {\n    throw new DeveloperError(\"options.height is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._buffer = options.buffer;\n  this._width = options.width;\n  this._height = options.height;\n  this._childTileMask = defaultValue(options.childTileMask, 15);\n  this._encoding = defaultValue(options.encoding, HeightmapEncoding.NONE);\n\n  var defaultStructure = HeightmapTessellator.DEFAULT_STRUCTURE;\n  var structure = options.structure;\n  if (!defined(structure)) {\n    structure = defaultStructure;\n  } else if (structure !== defaultStructure) {\n    structure.heightScale = defaultValue(\n      structure.heightScale,\n      defaultStructure.heightScale\n    );\n    structure.heightOffset = defaultValue(\n      structure.heightOffset,\n      defaultStructure.heightOffset\n    );\n    structure.elementsPerHeight = defaultValue(\n      structure.elementsPerHeight,\n      defaultStructure.elementsPerHeight\n    );\n    structure.stride = defaultValue(structure.stride, defaultStructure.stride);\n    structure.elementMultiplier = defaultValue(\n      structure.elementMultiplier,\n      defaultStructure.elementMultiplier\n    );\n    structure.isBigEndian = defaultValue(\n      structure.isBigEndian,\n      defaultStructure.isBigEndian\n    );\n  }\n\n  this._structure = structure;\n  this._createdByUpsampling = defaultValue(options.createdByUpsampling, false);\n  this._waterMask = options.waterMask;\n\n  this._skirtHeight = undefined;\n  this._bufferType =\n    this._encoding === HeightmapEncoding.LERC\n      ? Float32Array\n      : this._buffer.constructor;\n  this._mesh = undefined;\n}\n\nObject.defineProperties(HeightmapTerrainData.prototype, {\n  /**\n   * An array of credits for this tile.\n   * @memberof HeightmapTerrainData.prototype\n   * @type {Credit[]}\n   */\n  credits: {\n    get: function () {\n      return undefined;\n    },\n  },\n  /**\n   * The water mask included in this terrain data, if any.  A water mask is a square\n   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n   * @memberof HeightmapTerrainData.prototype\n   * @type {Uint8Array|Image|Canvas}\n   */\n  waterMask: {\n    get: function () {\n      return this._waterMask;\n    },\n  },\n\n  childTileMask: {\n    get: function () {\n      return this._childTileMask;\n    },\n  },\n});\n\nvar taskProcessor = new TaskProcessor(\"createVerticesFromHeightmap\");\n\n/**\n * Creates a {@link TerrainMesh} from this terrain data.\n *\n * @private\n *\n * @param {TilingScheme} tilingScheme The tiling scheme to which this tile belongs.\n * @param {Number} x The X coordinate of the tile for which to create the terrain data.\n * @param {Number} y The Y coordinate of the tile for which to create the terrain data.\n * @param {Number} level The level of the tile for which to create the terrain data.\n * @param {Number} [exaggeration=1.0] The scale used to exaggerate the terrain.\n * @returns {Promise.<TerrainMesh>|undefined} A promise for the terrain mesh, or undefined if too many\n *          asynchronous mesh creations are already in progress and the operation should\n *          be retried later.\n */\nHeightmapTerrainData.prototype.createMesh = function (\n  tilingScheme,\n  x,\n  y,\n  level,\n  exaggeration\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(tilingScheme)) {\n    throw new DeveloperError(\"tilingScheme is required.\");\n  }\n  if (!defined(x)) {\n    throw new DeveloperError(\"x is required.\");\n  }\n  if (!defined(y)) {\n    throw new DeveloperError(\"y is required.\");\n  }\n  if (!defined(level)) {\n    throw new DeveloperError(\"level is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var ellipsoid = tilingScheme.ellipsoid;\n  var nativeRectangle = tilingScheme.tileXYToNativeRectangle(x, y, level);\n  var rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n  exaggeration = defaultValue(exaggeration, 1.0);\n\n  // Compute the center of the tile for RTC rendering.\n  var center = ellipsoid.cartographicToCartesian(Rectangle.center(rectangle));\n\n  var structure = this._structure;\n\n  var levelZeroMaxError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n    ellipsoid,\n    this._width,\n    tilingScheme.getNumberOfXTilesAtLevel(0)\n  );\n  var thisLevelMaxError = levelZeroMaxError / (1 << level);\n  this._skirtHeight = Math.min(thisLevelMaxError * 4.0, 1000.0);\n\n  var verticesPromise = taskProcessor.scheduleTask({\n    heightmap: this._buffer,\n    structure: structure,\n    includeWebMercatorT: true,\n    width: this._width,\n    height: this._height,\n    nativeRectangle: nativeRectangle,\n    rectangle: rectangle,\n    relativeToCenter: center,\n    ellipsoid: ellipsoid,\n    skirtHeight: this._skirtHeight,\n    isGeographic: tilingScheme.projection instanceof GeographicProjection,\n    exaggeration: exaggeration,\n    encoding: this._encoding,\n  });\n\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  var that = this;\n  return when(verticesPromise, function (result) {\n    var indicesAndEdges;\n    if (that._skirtHeight > 0.0) {\n      indicesAndEdges = TerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices(\n        result.gridWidth,\n        result.gridHeight\n      );\n    } else {\n      indicesAndEdges = TerrainProvider.getRegularGridIndicesAndEdgeIndices(\n        result.gridWidth,\n        result.gridHeight\n      );\n    }\n\n    var vertexCountWithoutSkirts = result.gridWidth * result.gridHeight;\n\n    // Clone complex result objects because the transfer from the web worker\n    // has stripped them down to JSON-style objects.\n    that._mesh = new TerrainMesh(\n      center,\n      new Float32Array(result.vertices),\n      indicesAndEdges.indices,\n      indicesAndEdges.indexCountWithoutSkirts,\n      vertexCountWithoutSkirts,\n      result.minimumHeight,\n      result.maximumHeight,\n      BoundingSphere.clone(result.boundingSphere3D),\n      Cartesian3.clone(result.occludeePointInScaledSpace),\n      result.numberOfAttributes,\n      OrientedBoundingBox.clone(result.orientedBoundingBox),\n      TerrainEncoding.clone(result.encoding),\n      exaggeration,\n      indicesAndEdges.westIndicesSouthToNorth,\n      indicesAndEdges.southIndicesEastToWest,\n      indicesAndEdges.eastIndicesNorthToSouth,\n      indicesAndEdges.northIndicesWestToEast\n    );\n\n    // Free memory received from server after mesh is created.\n    that._buffer = undefined;\n    return that._mesh;\n  });\n};\n\n/**\n * @private\n */\nHeightmapTerrainData.prototype._createMeshSync = function (\n  tilingScheme,\n  x,\n  y,\n  level,\n  exaggeration\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(tilingScheme)) {\n    throw new DeveloperError(\"tilingScheme is required.\");\n  }\n  if (!defined(x)) {\n    throw new DeveloperError(\"x is required.\");\n  }\n  if (!defined(y)) {\n    throw new DeveloperError(\"y is required.\");\n  }\n  if (!defined(level)) {\n    throw new DeveloperError(\"level is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var ellipsoid = tilingScheme.ellipsoid;\n  var nativeRectangle = tilingScheme.tileXYToNativeRectangle(x, y, level);\n  var rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n  exaggeration = defaultValue(exaggeration, 1.0);\n\n  // Compute the center of the tile for RTC rendering.\n  var center = ellipsoid.cartographicToCartesian(Rectangle.center(rectangle));\n\n  var structure = this._structure;\n\n  var levelZeroMaxError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n    ellipsoid,\n    this._width,\n    tilingScheme.getNumberOfXTilesAtLevel(0)\n  );\n  var thisLevelMaxError = levelZeroMaxError / (1 << level);\n  this._skirtHeight = Math.min(thisLevelMaxError * 4.0, 1000.0);\n\n  var result = HeightmapTessellator.computeVertices({\n    heightmap: this._buffer,\n    structure: structure,\n    includeWebMercatorT: true,\n    width: this._width,\n    height: this._height,\n    nativeRectangle: nativeRectangle,\n    rectangle: rectangle,\n    relativeToCenter: center,\n    ellipsoid: ellipsoid,\n    skirtHeight: this._skirtHeight,\n    isGeographic: tilingScheme.projection instanceof GeographicProjection,\n    exaggeration: exaggeration,\n  });\n\n  // Free memory received from server after mesh is created.\n  this._buffer = undefined;\n\n  var indicesAndEdges;\n  if (this._skirtHeight > 0.0) {\n    indicesAndEdges = TerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices(\n      this._width,\n      this._height\n    );\n  } else {\n    indicesAndEdges = TerrainProvider.getRegularGridIndicesAndEdgeIndices(\n      this._width,\n      this._height\n    );\n  }\n\n  var vertexCountWithoutSkirts = result.gridWidth * result.gridHeight;\n\n  // No need to clone here (as we do in the async version) because the result\n  // is not coming from a web worker.\n  return new TerrainMesh(\n    center,\n    result.vertices,\n    indicesAndEdges.indices,\n    indicesAndEdges.indexCountWithoutSkirts,\n    vertexCountWithoutSkirts,\n    result.minimumHeight,\n    result.maximumHeight,\n    result.boundingSphere3D,\n    result.occludeePointInScaledSpace,\n    result.encoding.getStride(),\n    result.orientedBoundingBox,\n    result.encoding,\n    exaggeration,\n    indicesAndEdges.westIndicesSouthToNorth,\n    indicesAndEdges.southIndicesEastToWest,\n    indicesAndEdges.eastIndicesNorthToSouth,\n    indicesAndEdges.northIndicesWestToEast\n  );\n};\n\n/**\n * Computes the terrain height at a specified longitude and latitude.\n *\n * @param {Rectangle} rectangle The rectangle covered by this terrain data.\n * @param {Number} longitude The longitude in radians.\n * @param {Number} latitude The latitude in radians.\n * @returns {Number} The terrain height at the specified position.  If the position\n *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly\n *          incorrect for positions far outside the rectangle.\n */\nHeightmapTerrainData.prototype.interpolateHeight = function (\n  rectangle,\n  longitude,\n  latitude\n) {\n  var width = this._width;\n  var height = this._height;\n\n  var structure = this._structure;\n  var stride = structure.stride;\n  var elementsPerHeight = structure.elementsPerHeight;\n  var elementMultiplier = structure.elementMultiplier;\n  var isBigEndian = structure.isBigEndian;\n  var heightOffset = structure.heightOffset;\n  var heightScale = structure.heightScale;\n\n  var heightSample;\n  if (defined(this._mesh)) {\n    var buffer = this._mesh.vertices;\n    var encoding = this._mesh.encoding;\n    var exaggeration = this._mesh.exaggeration;\n    heightSample = interpolateMeshHeight(\n      buffer,\n      encoding,\n      heightOffset,\n      heightScale,\n      rectangle,\n      width,\n      height,\n      longitude,\n      latitude,\n      exaggeration\n    );\n  } else {\n    heightSample = interpolateHeight(\n      this._buffer,\n      elementsPerHeight,\n      elementMultiplier,\n      stride,\n      isBigEndian,\n      rectangle,\n      width,\n      height,\n      longitude,\n      latitude\n    );\n    heightSample = heightSample * heightScale + heightOffset;\n  }\n\n  return heightSample;\n};\n\n/**\n * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the\n * height samples in this instance, interpolated if necessary.\n *\n * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.\n * @param {Number} thisX The X coordinate of this tile in the tiling scheme.\n * @param {Number} thisY The Y coordinate of this tile in the tiling scheme.\n * @param {Number} thisLevel The level of this tile in the tiling scheme.\n * @param {Number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.\n * @returns {Promise.<HeightmapTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,\n *          or undefined if too many asynchronous upsample operations are in progress and the request has been\n *          deferred.\n */\nHeightmapTerrainData.prototype.upsample = function (\n  tilingScheme,\n  thisX,\n  thisY,\n  thisLevel,\n  descendantX,\n  descendantY,\n  descendantLevel\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(tilingScheme)) {\n    throw new DeveloperError(\"tilingScheme is required.\");\n  }\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n  if (!defined(thisLevel)) {\n    throw new DeveloperError(\"thisLevel is required.\");\n  }\n  if (!defined(descendantX)) {\n    throw new DeveloperError(\"descendantX is required.\");\n  }\n  if (!defined(descendantY)) {\n    throw new DeveloperError(\"descendantY is required.\");\n  }\n  if (!defined(descendantLevel)) {\n    throw new DeveloperError(\"descendantLevel is required.\");\n  }\n  var levelDifference = descendantLevel - thisLevel;\n  if (levelDifference > 1) {\n    throw new DeveloperError(\n      \"Upsampling through more than one level at a time is not currently supported.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var meshData = this._mesh;\n  if (!defined(meshData)) {\n    return undefined;\n  }\n\n  var width = this._width;\n  var height = this._height;\n  var structure = this._structure;\n  var stride = structure.stride;\n\n  var heights = new this._bufferType(width * height * stride);\n\n  var buffer = meshData.vertices;\n  var encoding = meshData.encoding;\n\n  // PERFORMANCE_IDEA: don't recompute these rectangles - the caller already knows them.\n  var sourceRectangle = tilingScheme.tileXYToRectangle(thisX, thisY, thisLevel);\n  var destinationRectangle = tilingScheme.tileXYToRectangle(\n    descendantX,\n    descendantY,\n    descendantLevel\n  );\n\n  var heightOffset = structure.heightOffset;\n  var heightScale = structure.heightScale;\n  var exaggeration = meshData.exaggeration;\n\n  var elementsPerHeight = structure.elementsPerHeight;\n  var elementMultiplier = structure.elementMultiplier;\n  var isBigEndian = structure.isBigEndian;\n\n  var divisor = Math.pow(elementMultiplier, elementsPerHeight - 1);\n\n  for (var j = 0; j < height; ++j) {\n    var latitude = CesiumMath.lerp(\n      destinationRectangle.north,\n      destinationRectangle.south,\n      j / (height - 1)\n    );\n    for (var i = 0; i < width; ++i) {\n      var longitude = CesiumMath.lerp(\n        destinationRectangle.west,\n        destinationRectangle.east,\n        i / (width - 1)\n      );\n      var heightSample = interpolateMeshHeight(\n        buffer,\n        encoding,\n        heightOffset,\n        heightScale,\n        sourceRectangle,\n        width,\n        height,\n        longitude,\n        latitude,\n        exaggeration\n      );\n\n      // Use conditionals here instead of Math.min and Math.max so that an undefined\n      // lowestEncodedHeight or highestEncodedHeight has no effect.\n      heightSample =\n        heightSample < structure.lowestEncodedHeight\n          ? structure.lowestEncodedHeight\n          : heightSample;\n      heightSample =\n        heightSample > structure.highestEncodedHeight\n          ? structure.highestEncodedHeight\n          : heightSample;\n\n      setHeight(\n        heights,\n        elementsPerHeight,\n        elementMultiplier,\n        divisor,\n        stride,\n        isBigEndian,\n        j * width + i,\n        heightSample\n      );\n    }\n  }\n\n  return new HeightmapTerrainData({\n    buffer: heights,\n    width: width,\n    height: height,\n    childTileMask: 0,\n    structure: this._structure,\n    createdByUpsampling: true,\n  });\n};\n\n/**\n * Determines if a given child tile is available, based on the\n * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed\n * to be one of the four children of this tile.  If non-child tile coordinates are\n * given, the availability of the southeast child tile is returned.\n *\n * @param {Number} thisX The tile X coordinate of this (the parent) tile.\n * @param {Number} thisY The tile Y coordinate of this (the parent) tile.\n * @param {Number} childX The tile X coordinate of the child tile to check for availability.\n * @param {Number} childY The tile Y coordinate of the child tile to check for availability.\n * @returns {Boolean} True if the child tile is available; otherwise, false.\n */\nHeightmapTerrainData.prototype.isChildAvailable = function (\n  thisX,\n  thisY,\n  childX,\n  childY\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n  if (!defined(childX)) {\n    throw new DeveloperError(\"childX is required.\");\n  }\n  if (!defined(childY)) {\n    throw new DeveloperError(\"childY is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var bitNumber = 2; // northwest child\n  if (childX !== thisX * 2) {\n    ++bitNumber; // east child\n  }\n  if (childY !== thisY * 2) {\n    bitNumber -= 2; // south child\n  }\n\n  return (this._childTileMask & (1 << bitNumber)) !== 0;\n};\n\n/**\n * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution\n * terrain data.  If this value is false, the data was obtained from some other source, such\n * as by downloading it from a remote server.  This method should return true for instances\n * returned from a call to {@link HeightmapTerrainData#upsample}.\n *\n * @returns {Boolean} True if this instance was created by upsampling; otherwise, false.\n */\nHeightmapTerrainData.prototype.wasCreatedByUpsampling = function () {\n  return this._createdByUpsampling;\n};\n\nfunction interpolateHeight(\n  sourceHeights,\n  elementsPerHeight,\n  elementMultiplier,\n  stride,\n  isBigEndian,\n  sourceRectangle,\n  width,\n  height,\n  longitude,\n  latitude\n) {\n  var fromWest =\n    ((longitude - sourceRectangle.west) * (width - 1)) /\n    (sourceRectangle.east - sourceRectangle.west);\n  var fromSouth =\n    ((latitude - sourceRectangle.south) * (height - 1)) /\n    (sourceRectangle.north - sourceRectangle.south);\n\n  var westInteger = fromWest | 0;\n  var eastInteger = westInteger + 1;\n  if (eastInteger >= width) {\n    eastInteger = width - 1;\n    westInteger = width - 2;\n  }\n\n  var southInteger = fromSouth | 0;\n  var northInteger = southInteger + 1;\n  if (northInteger >= height) {\n    northInteger = height - 1;\n    southInteger = height - 2;\n  }\n\n  var dx = fromWest - westInteger;\n  var dy = fromSouth - southInteger;\n\n  southInteger = height - 1 - southInteger;\n  northInteger = height - 1 - northInteger;\n\n  var southwestHeight = getHeight(\n    sourceHeights,\n    elementsPerHeight,\n    elementMultiplier,\n    stride,\n    isBigEndian,\n    southInteger * width + westInteger\n  );\n  var southeastHeight = getHeight(\n    sourceHeights,\n    elementsPerHeight,\n    elementMultiplier,\n    stride,\n    isBigEndian,\n    southInteger * width + eastInteger\n  );\n  var northwestHeight = getHeight(\n    sourceHeights,\n    elementsPerHeight,\n    elementMultiplier,\n    stride,\n    isBigEndian,\n    northInteger * width + westInteger\n  );\n  var northeastHeight = getHeight(\n    sourceHeights,\n    elementsPerHeight,\n    elementMultiplier,\n    stride,\n    isBigEndian,\n    northInteger * width + eastInteger\n  );\n\n  return triangleInterpolateHeight(\n    dx,\n    dy,\n    southwestHeight,\n    southeastHeight,\n    northwestHeight,\n    northeastHeight\n  );\n}\n\nfunction interpolateMeshHeight(\n  buffer,\n  encoding,\n  heightOffset,\n  heightScale,\n  sourceRectangle,\n  width,\n  height,\n  longitude,\n  latitude,\n  exaggeration\n) {\n  // returns a height encoded according to the structure's heightScale and heightOffset.\n  var fromWest =\n    ((longitude - sourceRectangle.west) * (width - 1)) /\n    (sourceRectangle.east - sourceRectangle.west);\n  var fromSouth =\n    ((latitude - sourceRectangle.south) * (height - 1)) /\n    (sourceRectangle.north - sourceRectangle.south);\n\n  var westInteger = fromWest | 0;\n  var eastInteger = westInteger + 1;\n  if (eastInteger >= width) {\n    eastInteger = width - 1;\n    westInteger = width - 2;\n  }\n\n  var southInteger = fromSouth | 0;\n  var northInteger = southInteger + 1;\n  if (northInteger >= height) {\n    northInteger = height - 1;\n    southInteger = height - 2;\n  }\n\n  var dx = fromWest - westInteger;\n  var dy = fromSouth - southInteger;\n\n  southInteger = height - 1 - southInteger;\n  northInteger = height - 1 - northInteger;\n\n  var southwestHeight =\n    (encoding.decodeHeight(buffer, southInteger * width + westInteger) /\n      exaggeration -\n      heightOffset) /\n    heightScale;\n  var southeastHeight =\n    (encoding.decodeHeight(buffer, southInteger * width + eastInteger) /\n      exaggeration -\n      heightOffset) /\n    heightScale;\n  var northwestHeight =\n    (encoding.decodeHeight(buffer, northInteger * width + westInteger) /\n      exaggeration -\n      heightOffset) /\n    heightScale;\n  var northeastHeight =\n    (encoding.decodeHeight(buffer, northInteger * width + eastInteger) /\n      exaggeration -\n      heightOffset) /\n    heightScale;\n\n  return triangleInterpolateHeight(\n    dx,\n    dy,\n    southwestHeight,\n    southeastHeight,\n    northwestHeight,\n    northeastHeight\n  );\n}\n\nfunction triangleInterpolateHeight(\n  dX,\n  dY,\n  southwestHeight,\n  southeastHeight,\n  northwestHeight,\n  northeastHeight\n) {\n  // The HeightmapTessellator bisects the quad from southwest to northeast.\n  if (dY < dX) {\n    // Lower right triangle\n    return (\n      southwestHeight +\n      dX * (southeastHeight - southwestHeight) +\n      dY * (northeastHeight - southeastHeight)\n    );\n  }\n\n  // Upper left triangle\n  return (\n    southwestHeight +\n    dX * (northeastHeight - northwestHeight) +\n    dY * (northwestHeight - southwestHeight)\n  );\n}\n\nfunction getHeight(\n  heights,\n  elementsPerHeight,\n  elementMultiplier,\n  stride,\n  isBigEndian,\n  index\n) {\n  index *= stride;\n\n  var height = 0;\n  var i;\n\n  if (isBigEndian) {\n    for (i = 0; i < elementsPerHeight; ++i) {\n      height = height * elementMultiplier + heights[index + i];\n    }\n  } else {\n    for (i = elementsPerHeight - 1; i >= 0; --i) {\n      height = height * elementMultiplier + heights[index + i];\n    }\n  }\n\n  return height;\n}\n\nfunction setHeight(\n  heights,\n  elementsPerHeight,\n  elementMultiplier,\n  divisor,\n  stride,\n  isBigEndian,\n  index,\n  height\n) {\n  index *= stride;\n\n  var i;\n  if (isBigEndian) {\n    for (i = 0; i < elementsPerHeight - 1; ++i) {\n      heights[index + i] = (height / divisor) | 0;\n      height -= heights[index + i] * divisor;\n      divisor /= elementMultiplier;\n    }\n  } else {\n    for (i = elementsPerHeight - 1; i > 0; --i) {\n      heights[index + i] = (height / divisor) | 0;\n      height -= heights[index + i] * divisor;\n      divisor /= elementMultiplier;\n    }\n  }\n  heights[index + i] = height;\n}\nexport default HeightmapTerrainData;\n"]},"metadata":{},"sourceType":"module"}