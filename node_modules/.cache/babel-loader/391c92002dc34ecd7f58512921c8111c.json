{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Cesium3DTileOptimizationHint from \"./Cesium3DTileOptimizationHint.js\";\nimport TileBoundingRegion from \"./TileBoundingRegion.js\";\nimport TileOrientedBoundingBox from \"./TileOrientedBoundingBox.js\";\n/**\n * Utility functions for computing optimization hints for a {@link Cesium3DTileset}.\n *\n * @exports Cesium3DTileOptimizations\n *\n * @private\n */\n\nvar Cesium3DTileOptimizations = {};\nvar scratchAxis = new Cartesian3();\n/**\n * Evaluates support for the childrenWithinParent optimization. This is used to more tightly cull tilesets if\n * children bounds are fully contained within the parent. Currently, support for the optimization only works for\n * oriented bounding boxes, so both the child and parent tile must be either a {@link TileOrientedBoundingBox} or\n * {@link TileBoundingRegion}. The purpose of this check is to prevent use of a culling optimization when the child\n * bounds exceed those of the parent. If the child bounds are greater, it is more likely that the optimization will\n * waste CPU cycles. Bounding spheres are not supported for the reason that the child bounds can very often be\n * partially outside of the parent bounds.\n *\n * @param {Cesium3DTile} tile The tile to check.\n * @returns {Boolean} Whether the childrenWithinParent optimization is supported.\n */\n\nCesium3DTileOptimizations.checkChildrenWithinParent = function (tile) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"tile\", tile); //>>includeEnd('debug');\n\n  var children = tile.children;\n  var length = children.length; // Check if the parent has an oriented bounding box.\n\n  var boundingVolume = tile.boundingVolume;\n\n  if (boundingVolume instanceof TileOrientedBoundingBox || boundingVolume instanceof TileBoundingRegion) {\n    var orientedBoundingBox = boundingVolume._orientedBoundingBox;\n    tile._optimChildrenWithinParent = Cesium3DTileOptimizationHint.USE_OPTIMIZATION;\n\n    for (var i = 0; i < length; ++i) {\n      var child = children[i]; // Check if the child has an oriented bounding box.\n\n      var childBoundingVolume = child.boundingVolume;\n\n      if (!(childBoundingVolume instanceof TileOrientedBoundingBox || childBoundingVolume instanceof TileBoundingRegion)) {\n        // Do not support if the parent and child both do not have oriented bounding boxes.\n        tile._optimChildrenWithinParent = Cesium3DTileOptimizationHint.SKIP_OPTIMIZATION;\n        break;\n      }\n\n      var childOrientedBoundingBox = childBoundingVolume._orientedBoundingBox; // Compute the axis from the parent to the child.\n\n      var axis = Cartesian3.subtract(childOrientedBoundingBox.center, orientedBoundingBox.center, scratchAxis);\n      var axisLength = Cartesian3.magnitude(axis);\n      Cartesian3.divideByScalar(axis, axisLength, axis); // Project the bounding box of the parent onto the axis. Because the axis is a ray from the parent\n      // to the child, the projection parameterized along the ray will be (+/- proj1).\n\n      var proj1 = Math.abs(orientedBoundingBox.halfAxes[0] * axis.x) + Math.abs(orientedBoundingBox.halfAxes[1] * axis.y) + Math.abs(orientedBoundingBox.halfAxes[2] * axis.z) + Math.abs(orientedBoundingBox.halfAxes[3] * axis.x) + Math.abs(orientedBoundingBox.halfAxes[4] * axis.y) + Math.abs(orientedBoundingBox.halfAxes[5] * axis.z) + Math.abs(orientedBoundingBox.halfAxes[6] * axis.x) + Math.abs(orientedBoundingBox.halfAxes[7] * axis.y) + Math.abs(orientedBoundingBox.halfAxes[8] * axis.z); // Project the bounding box of the child onto the axis. Because the axis is a ray from the parent\n      // to the child, the projection parameterized along the ray will be (+/- proj2) + axis.length.\n\n      var proj2 = Math.abs(childOrientedBoundingBox.halfAxes[0] * axis.x) + Math.abs(childOrientedBoundingBox.halfAxes[1] * axis.y) + Math.abs(childOrientedBoundingBox.halfAxes[2] * axis.z) + Math.abs(childOrientedBoundingBox.halfAxes[3] * axis.x) + Math.abs(childOrientedBoundingBox.halfAxes[4] * axis.y) + Math.abs(childOrientedBoundingBox.halfAxes[5] * axis.z) + Math.abs(childOrientedBoundingBox.halfAxes[6] * axis.x) + Math.abs(childOrientedBoundingBox.halfAxes[7] * axis.y) + Math.abs(childOrientedBoundingBox.halfAxes[8] * axis.z); // If the child extends the parent's bounds, the optimization is not valid and we skip it.\n\n      if (proj1 <= proj2 + axisLength) {\n        tile._optimChildrenWithinParent = Cesium3DTileOptimizationHint.SKIP_OPTIMIZATION;\n        break;\n      }\n    }\n  }\n\n  return tile._optimChildrenWithinParent === Cesium3DTileOptimizationHint.USE_OPTIMIZATION;\n};\n\nexport default Cesium3DTileOptimizations;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/Cesium3DTileOptimizations.js"],"names":["Cartesian3","Check","Cesium3DTileOptimizationHint","TileBoundingRegion","TileOrientedBoundingBox","Cesium3DTileOptimizations","scratchAxis","checkChildrenWithinParent","tile","typeOf","object","children","length","boundingVolume","orientedBoundingBox","_orientedBoundingBox","_optimChildrenWithinParent","USE_OPTIMIZATION","i","child","childBoundingVolume","SKIP_OPTIMIZATION","childOrientedBoundingBox","axis","subtract","center","axisLength","magnitude","divideByScalar","proj1","Math","abs","halfAxes","x","y","z","proj2"],"mappings":"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","sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Cesium3DTileOptimizationHint from \"./Cesium3DTileOptimizationHint.js\";\nimport TileBoundingRegion from \"./TileBoundingRegion.js\";\nimport TileOrientedBoundingBox from \"./TileOrientedBoundingBox.js\";\n\n/**\n * Utility functions for computing optimization hints for a {@link Cesium3DTileset}.\n *\n * @exports Cesium3DTileOptimizations\n *\n * @private\n */\nvar Cesium3DTileOptimizations = {};\n\nvar scratchAxis = new Cartesian3();\n\n/**\n * Evaluates support for the childrenWithinParent optimization. This is used to more tightly cull tilesets if\n * children bounds are fully contained within the parent. Currently, support for the optimization only works for\n * oriented bounding boxes, so both the child and parent tile must be either a {@link TileOrientedBoundingBox} or\n * {@link TileBoundingRegion}. The purpose of this check is to prevent use of a culling optimization when the child\n * bounds exceed those of the parent. If the child bounds are greater, it is more likely that the optimization will\n * waste CPU cycles. Bounding spheres are not supported for the reason that the child bounds can very often be\n * partially outside of the parent bounds.\n *\n * @param {Cesium3DTile} tile The tile to check.\n * @returns {Boolean} Whether the childrenWithinParent optimization is supported.\n */\nCesium3DTileOptimizations.checkChildrenWithinParent = function (tile) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"tile\", tile);\n  //>>includeEnd('debug');\n\n  var children = tile.children;\n  var length = children.length;\n\n  // Check if the parent has an oriented bounding box.\n  var boundingVolume = tile.boundingVolume;\n  if (\n    boundingVolume instanceof TileOrientedBoundingBox ||\n    boundingVolume instanceof TileBoundingRegion\n  ) {\n    var orientedBoundingBox = boundingVolume._orientedBoundingBox;\n    tile._optimChildrenWithinParent =\n      Cesium3DTileOptimizationHint.USE_OPTIMIZATION;\n    for (var i = 0; i < length; ++i) {\n      var child = children[i];\n\n      // Check if the child has an oriented bounding box.\n      var childBoundingVolume = child.boundingVolume;\n      if (\n        !(\n          childBoundingVolume instanceof TileOrientedBoundingBox ||\n          childBoundingVolume instanceof TileBoundingRegion\n        )\n      ) {\n        // Do not support if the parent and child both do not have oriented bounding boxes.\n        tile._optimChildrenWithinParent =\n          Cesium3DTileOptimizationHint.SKIP_OPTIMIZATION;\n        break;\n      }\n\n      var childOrientedBoundingBox = childBoundingVolume._orientedBoundingBox;\n\n      // Compute the axis from the parent to the child.\n      var axis = Cartesian3.subtract(\n        childOrientedBoundingBox.center,\n        orientedBoundingBox.center,\n        scratchAxis\n      );\n      var axisLength = Cartesian3.magnitude(axis);\n      Cartesian3.divideByScalar(axis, axisLength, axis);\n\n      // Project the bounding box of the parent onto the axis. Because the axis is a ray from the parent\n      // to the child, the projection parameterized along the ray will be (+/- proj1).\n      var proj1 =\n        Math.abs(orientedBoundingBox.halfAxes[0] * axis.x) +\n        Math.abs(orientedBoundingBox.halfAxes[1] * axis.y) +\n        Math.abs(orientedBoundingBox.halfAxes[2] * axis.z) +\n        Math.abs(orientedBoundingBox.halfAxes[3] * axis.x) +\n        Math.abs(orientedBoundingBox.halfAxes[4] * axis.y) +\n        Math.abs(orientedBoundingBox.halfAxes[5] * axis.z) +\n        Math.abs(orientedBoundingBox.halfAxes[6] * axis.x) +\n        Math.abs(orientedBoundingBox.halfAxes[7] * axis.y) +\n        Math.abs(orientedBoundingBox.halfAxes[8] * axis.z);\n\n      // Project the bounding box of the child onto the axis. Because the axis is a ray from the parent\n      // to the child, the projection parameterized along the ray will be (+/- proj2) + axis.length.\n      var proj2 =\n        Math.abs(childOrientedBoundingBox.halfAxes[0] * axis.x) +\n        Math.abs(childOrientedBoundingBox.halfAxes[1] * axis.y) +\n        Math.abs(childOrientedBoundingBox.halfAxes[2] * axis.z) +\n        Math.abs(childOrientedBoundingBox.halfAxes[3] * axis.x) +\n        Math.abs(childOrientedBoundingBox.halfAxes[4] * axis.y) +\n        Math.abs(childOrientedBoundingBox.halfAxes[5] * axis.z) +\n        Math.abs(childOrientedBoundingBox.halfAxes[6] * axis.x) +\n        Math.abs(childOrientedBoundingBox.halfAxes[7] * axis.y) +\n        Math.abs(childOrientedBoundingBox.halfAxes[8] * axis.z);\n\n      // If the child extends the parent's bounds, the optimization is not valid and we skip it.\n      if (proj1 <= proj2 + axisLength) {\n        tile._optimChildrenWithinParent =\n          Cesium3DTileOptimizationHint.SKIP_OPTIMIZATION;\n        break;\n      }\n    }\n  }\n\n  return (\n    tile._optimChildrenWithinParent ===\n    Cesium3DTileOptimizationHint.USE_OPTIMIZATION\n  );\n};\nexport default Cesium3DTileOptimizations;\n"]},"metadata":{},"sourceType":"module"}