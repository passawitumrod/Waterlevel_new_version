{"ast":null,"code":"import binarySearch from \"./binarySearch.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defined from \"./defined.js\";\nimport Rectangle from \"./Rectangle.js\";\n/**\n * Reports the availability of tiles in a {@link TilingScheme}.\n *\n * @alias TileAvailability\n * @constructor\n *\n * @param {TilingScheme} tilingScheme The tiling scheme in which to report availability.\n * @param {Number} maximumLevel The maximum tile level that is potentially available.\n */\n\nfunction TileAvailability(tilingScheme, maximumLevel) {\n  this._tilingScheme = tilingScheme;\n  this._maximumLevel = maximumLevel;\n  this._rootNodes = [];\n}\n\nvar rectangleScratch = new Rectangle();\n\nfunction findNode(level, x, y, nodes) {\n  var count = nodes.length;\n\n  for (var i = 0; i < count; ++i) {\n    var node = nodes[i];\n\n    if (node.x === x && node.y === y && node.level === level) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Marks a rectangular range of tiles in a particular level as being available.  For best performance,\n * add your ranges in order of increasing level.\n *\n * @param {Number} level The level.\n * @param {Number} startX The X coordinate of the first available tiles at the level.\n * @param {Number} startY The Y coordinate of the first available tiles at the level.\n * @param {Number} endX The X coordinate of the last available tiles at the level.\n * @param {Number} endY The Y coordinate of the last available tiles at the level.\n */\n\n\nTileAvailability.prototype.addAvailableTileRange = function (level, startX, startY, endX, endY) {\n  var tilingScheme = this._tilingScheme;\n  var rootNodes = this._rootNodes;\n\n  if (level === 0) {\n    for (var y = startY; y <= endY; ++y) {\n      for (var x = startX; x <= endX; ++x) {\n        if (!findNode(level, x, y, rootNodes)) {\n          rootNodes.push(new QuadtreeNode(tilingScheme, undefined, 0, x, y));\n        }\n      }\n    }\n  }\n\n  tilingScheme.tileXYToRectangle(startX, startY, level, rectangleScratch);\n  var west = rectangleScratch.west;\n  var north = rectangleScratch.north;\n  tilingScheme.tileXYToRectangle(endX, endY, level, rectangleScratch);\n  var east = rectangleScratch.east;\n  var south = rectangleScratch.south;\n  var rectangleWithLevel = new RectangleWithLevel(level, west, south, east, north);\n\n  for (var i = 0; i < rootNodes.length; ++i) {\n    var rootNode = rootNodes[i];\n\n    if (rectanglesOverlap(rootNode.extent, rectangleWithLevel)) {\n      putRectangleInQuadtree(this._maximumLevel, rootNode, rectangleWithLevel);\n    }\n  }\n};\n/**\n * Determines the level of the most detailed tile covering the position.  This function\n * usually completes in time logarithmic to the number of rectangles added with\n * {@link TileAvailability#addAvailableTileRange}.\n *\n * @param {Cartographic} position The position for which to determine the maximum available level.  The height component is ignored.\n * @return {Number} The level of the most detailed tile covering the position.\n * @throws {DeveloperError} If position is outside any tile according to the tiling scheme.\n */\n\n\nTileAvailability.prototype.computeMaximumLevelAtPosition = function (position) {\n  // Find the root node that contains this position.\n  var node;\n\n  for (var nodeIndex = 0; nodeIndex < this._rootNodes.length; ++nodeIndex) {\n    var rootNode = this._rootNodes[nodeIndex];\n\n    if (rectangleContainsPosition(rootNode.extent, position)) {\n      node = rootNode;\n      break;\n    }\n  }\n\n  if (!defined(node)) {\n    return -1;\n  }\n\n  return findMaxLevelFromNode(undefined, node, position);\n};\n\nvar rectanglesScratch = [];\nvar remainingToCoverByLevelScratch = [];\nvar westScratch = new Rectangle();\nvar eastScratch = new Rectangle();\n/**\n * Finds the most detailed level that is available _everywhere_ within a given rectangle.  More detailed\n * tiles may be available in parts of the rectangle, but not the whole thing.  The return value of this\n * function may be safely passed to {@link sampleTerrain} for any position within the rectangle.  This function\n * usually completes in time logarithmic to the number of rectangles added with\n * {@link TileAvailability#addAvailableTileRange}.\n *\n * @param {Rectangle} rectangle The rectangle.\n * @return {Number} The best available level for the entire rectangle.\n */\n\nTileAvailability.prototype.computeBestAvailableLevelOverRectangle = function (rectangle) {\n  var rectangles = rectanglesScratch;\n  rectangles.length = 0;\n\n  if (rectangle.east < rectangle.west) {\n    // Rectangle crosses the IDL, make it two rectangles.\n    rectangles.push(Rectangle.fromRadians(-Math.PI, rectangle.south, rectangle.east, rectangle.north, westScratch));\n    rectangles.push(Rectangle.fromRadians(rectangle.west, rectangle.south, Math.PI, rectangle.north, eastScratch));\n  } else {\n    rectangles.push(rectangle);\n  }\n\n  var remainingToCoverByLevel = remainingToCoverByLevelScratch;\n  remainingToCoverByLevel.length = 0;\n  var i;\n\n  for (i = 0; i < this._rootNodes.length; ++i) {\n    updateCoverageWithNode(remainingToCoverByLevel, this._rootNodes[i], rectangles);\n  }\n\n  for (i = remainingToCoverByLevel.length - 1; i >= 0; --i) {\n    if (defined(remainingToCoverByLevel[i]) && remainingToCoverByLevel[i].length === 0) {\n      return i;\n    }\n  }\n\n  return 0;\n};\n\nvar cartographicScratch = new Cartographic();\n/**\n * Determines if a particular tile is available.\n * @param {Number} level The tile level to check.\n * @param {Number} x The X coordinate of the tile to check.\n * @param {Number} y The Y coordinate of the tile to check.\n * @return {Boolean} True if the tile is available; otherwise, false.\n */\n\nTileAvailability.prototype.isTileAvailable = function (level, x, y) {\n  // Get the center of the tile and find the maximum level at that position.\n  // Because availability is by tile, if the level is available at that point, it\n  // is sure to be available for the whole tile.  We assume that if a tile at level n exists,\n  // then all its parent tiles back to level 0 exist too.  This isn't really enforced\n  // anywhere, but Cesium would never load a tile for which this is not true.\n  var rectangle = this._tilingScheme.tileXYToRectangle(x, y, level, rectangleScratch);\n\n  Rectangle.center(rectangle, cartographicScratch);\n  return this.computeMaximumLevelAtPosition(cartographicScratch) >= level;\n};\n/**\n * Computes a bit mask indicating which of a tile's four children exist.\n * If a child's bit is set, a tile is available for that child.  If it is cleared,\n * the tile is not available.  The bit values are as follows:\n * <table>\n *     <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *     <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *     <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *     <tr><td>2</td><td>4</td><td>Northwest</td></tr>\n *     <tr><td>3</td><td>8</td><td>Northeast</td></tr>\n * </table>\n *\n * @param {Number} level The level of the parent tile.\n * @param {Number} x The X coordinate of the parent tile.\n * @param {Number} y The Y coordinate of the parent tile.\n * @return {Number} The bit mask indicating child availability.\n */\n\n\nTileAvailability.prototype.computeChildMaskForTile = function (level, x, y) {\n  var childLevel = level + 1;\n\n  if (childLevel >= this._maximumLevel) {\n    return 0;\n  }\n\n  var mask = 0;\n  mask |= this.isTileAvailable(childLevel, 2 * x, 2 * y + 1) ? 1 : 0;\n  mask |= this.isTileAvailable(childLevel, 2 * x + 1, 2 * y + 1) ? 2 : 0;\n  mask |= this.isTileAvailable(childLevel, 2 * x, 2 * y) ? 4 : 0;\n  mask |= this.isTileAvailable(childLevel, 2 * x + 1, 2 * y) ? 8 : 0;\n  return mask;\n};\n\nfunction QuadtreeNode(tilingScheme, parent, level, x, y) {\n  this.tilingScheme = tilingScheme;\n  this.parent = parent;\n  this.level = level;\n  this.x = x;\n  this.y = y;\n  this.extent = tilingScheme.tileXYToRectangle(x, y, level);\n  this.rectangles = [];\n  this._sw = undefined;\n  this._se = undefined;\n  this._nw = undefined;\n  this._ne = undefined;\n}\n\nObject.defineProperties(QuadtreeNode.prototype, {\n  nw: {\n    get: function get() {\n      if (!this._nw) {\n        this._nw = new QuadtreeNode(this.tilingScheme, this, this.level + 1, this.x * 2, this.y * 2);\n      }\n\n      return this._nw;\n    }\n  },\n  ne: {\n    get: function get() {\n      if (!this._ne) {\n        this._ne = new QuadtreeNode(this.tilingScheme, this, this.level + 1, this.x * 2 + 1, this.y * 2);\n      }\n\n      return this._ne;\n    }\n  },\n  sw: {\n    get: function get() {\n      if (!this._sw) {\n        this._sw = new QuadtreeNode(this.tilingScheme, this, this.level + 1, this.x * 2, this.y * 2 + 1);\n      }\n\n      return this._sw;\n    }\n  },\n  se: {\n    get: function get() {\n      if (!this._se) {\n        this._se = new QuadtreeNode(this.tilingScheme, this, this.level + 1, this.x * 2 + 1, this.y * 2 + 1);\n      }\n\n      return this._se;\n    }\n  }\n});\n\nfunction RectangleWithLevel(level, west, south, east, north) {\n  this.level = level;\n  this.west = west;\n  this.south = south;\n  this.east = east;\n  this.north = north;\n}\n\nfunction rectanglesOverlap(rectangle1, rectangle2) {\n  var west = Math.max(rectangle1.west, rectangle2.west);\n  var south = Math.max(rectangle1.south, rectangle2.south);\n  var east = Math.min(rectangle1.east, rectangle2.east);\n  var north = Math.min(rectangle1.north, rectangle2.north);\n  return south < north && west < east;\n}\n\nfunction putRectangleInQuadtree(maxDepth, node, rectangle) {\n  while (node.level < maxDepth) {\n    if (rectangleFullyContainsRectangle(node.nw.extent, rectangle)) {\n      node = node.nw;\n    } else if (rectangleFullyContainsRectangle(node.ne.extent, rectangle)) {\n      node = node.ne;\n    } else if (rectangleFullyContainsRectangle(node.sw.extent, rectangle)) {\n      node = node.sw;\n    } else if (rectangleFullyContainsRectangle(node.se.extent, rectangle)) {\n      node = node.se;\n    } else {\n      break;\n    }\n  }\n\n  if (node.rectangles.length === 0 || node.rectangles[node.rectangles.length - 1].level <= rectangle.level) {\n    node.rectangles.push(rectangle);\n  } else {\n    // Maintain ordering by level when inserting.\n    var index = binarySearch(node.rectangles, rectangle.level, rectangleLevelComparator);\n\n    if (index <= 0) {\n      index = ~index;\n    }\n\n    node.rectangles.splice(index, 0, rectangle);\n  }\n}\n\nfunction rectangleLevelComparator(a, b) {\n  return a.level - b;\n}\n\nfunction rectangleFullyContainsRectangle(potentialContainer, rectangleToTest) {\n  return rectangleToTest.west >= potentialContainer.west && rectangleToTest.east <= potentialContainer.east && rectangleToTest.south >= potentialContainer.south && rectangleToTest.north <= potentialContainer.north;\n}\n\nfunction rectangleContainsPosition(potentialContainer, positionToTest) {\n  return positionToTest.longitude >= potentialContainer.west && positionToTest.longitude <= potentialContainer.east && positionToTest.latitude >= potentialContainer.south && positionToTest.latitude <= potentialContainer.north;\n}\n\nfunction findMaxLevelFromNode(stopNode, node, position) {\n  var maxLevel = 0; // Find the deepest quadtree node containing this point.\n\n  var found = false;\n\n  while (!found) {\n    var nw = node._nw && rectangleContainsPosition(node._nw.extent, position);\n    var ne = node._ne && rectangleContainsPosition(node._ne.extent, position);\n    var sw = node._sw && rectangleContainsPosition(node._sw.extent, position);\n    var se = node._se && rectangleContainsPosition(node._se.extent, position); // The common scenario is that the point is in only one quadrant and we can simply\n    // iterate down the tree.  But if the point is on a boundary between tiles, it is\n    // in multiple tiles and we need to check all of them, so use recursion.\n\n    if (nw + ne + sw + se > 1) {\n      if (nw) {\n        maxLevel = Math.max(maxLevel, findMaxLevelFromNode(node, node._nw, position));\n      }\n\n      if (ne) {\n        maxLevel = Math.max(maxLevel, findMaxLevelFromNode(node, node._ne, position));\n      }\n\n      if (sw) {\n        maxLevel = Math.max(maxLevel, findMaxLevelFromNode(node, node._sw, position));\n      }\n\n      if (se) {\n        maxLevel = Math.max(maxLevel, findMaxLevelFromNode(node, node._se, position));\n      }\n\n      break;\n    } else if (nw) {\n      node = node._nw;\n    } else if (ne) {\n      node = node._ne;\n    } else if (sw) {\n      node = node._sw;\n    } else if (se) {\n      node = node._se;\n    } else {\n      found = true;\n    }\n  } // Work up the tree until we find a rectangle that contains this point.\n\n\n  while (node !== stopNode) {\n    var rectangles = node.rectangles; // Rectangles are sorted by level, lowest first.\n\n    for (var i = rectangles.length - 1; i >= 0 && rectangles[i].level > maxLevel; --i) {\n      var rectangle = rectangles[i];\n\n      if (rectangleContainsPosition(rectangle, position)) {\n        maxLevel = rectangle.level;\n      }\n    }\n\n    node = node.parent;\n  }\n\n  return maxLevel;\n}\n\nfunction updateCoverageWithNode(remainingToCoverByLevel, node, rectanglesToCover) {\n  if (!node) {\n    return;\n  }\n\n  var i;\n  var anyOverlap = false;\n\n  for (i = 0; i < rectanglesToCover.length; ++i) {\n    anyOverlap = anyOverlap || rectanglesOverlap(node.extent, rectanglesToCover[i]);\n  }\n\n  if (!anyOverlap) {\n    // This node is not applicable to the rectangle(s).\n    return;\n  }\n\n  var rectangles = node.rectangles;\n\n  for (i = 0; i < rectangles.length; ++i) {\n    var rectangle = rectangles[i];\n\n    if (!remainingToCoverByLevel[rectangle.level]) {\n      remainingToCoverByLevel[rectangle.level] = rectanglesToCover;\n    }\n\n    remainingToCoverByLevel[rectangle.level] = subtractRectangle(remainingToCoverByLevel[rectangle.level], rectangle);\n  } // Update with child nodes.\n\n\n  updateCoverageWithNode(remainingToCoverByLevel, node._nw, rectanglesToCover);\n  updateCoverageWithNode(remainingToCoverByLevel, node._ne, rectanglesToCover);\n  updateCoverageWithNode(remainingToCoverByLevel, node._sw, rectanglesToCover);\n  updateCoverageWithNode(remainingToCoverByLevel, node._se, rectanglesToCover);\n}\n\nfunction subtractRectangle(rectangleList, rectangleToSubtract) {\n  var result = [];\n\n  for (var i = 0; i < rectangleList.length; ++i) {\n    var rectangle = rectangleList[i];\n\n    if (!rectanglesOverlap(rectangle, rectangleToSubtract)) {\n      // Disjoint rectangles.  Original rectangle is unmodified.\n      result.push(rectangle);\n    } else {\n      // rectangleToSubtract partially or completely overlaps rectangle.\n      if (rectangle.west < rectangleToSubtract.west) {\n        result.push(new Rectangle(rectangle.west, rectangle.south, rectangleToSubtract.west, rectangle.north));\n      }\n\n      if (rectangle.east > rectangleToSubtract.east) {\n        result.push(new Rectangle(rectangleToSubtract.east, rectangle.south, rectangle.east, rectangle.north));\n      }\n\n      if (rectangle.south < rectangleToSubtract.south) {\n        result.push(new Rectangle(Math.max(rectangleToSubtract.west, rectangle.west), rectangle.south, Math.min(rectangleToSubtract.east, rectangle.east), rectangleToSubtract.south));\n      }\n\n      if (rectangle.north > rectangleToSubtract.north) {\n        result.push(new Rectangle(Math.max(rectangleToSubtract.west, rectangle.west), rectangleToSubtract.north, Math.min(rectangleToSubtract.east, rectangle.east), rectangle.north));\n      }\n    }\n  }\n\n  return result;\n}\n\nexport default TileAvailability;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/TileAvailability.js"],"names":["binarySearch","Cartographic","defined","Rectangle","TileAvailability","tilingScheme","maximumLevel","_tilingScheme","_maximumLevel","_rootNodes","rectangleScratch","findNode","level","x","y","nodes","count","length","i","node","prototype","addAvailableTileRange","startX","startY","endX","endY","rootNodes","push","QuadtreeNode","undefined","tileXYToRectangle","west","north","east","south","rectangleWithLevel","RectangleWithLevel","rootNode","rectanglesOverlap","extent","putRectangleInQuadtree","computeMaximumLevelAtPosition","position","nodeIndex","rectangleContainsPosition","findMaxLevelFromNode","rectanglesScratch","remainingToCoverByLevelScratch","westScratch","eastScratch","computeBestAvailableLevelOverRectangle","rectangle","rectangles","fromRadians","Math","PI","remainingToCoverByLevel","updateCoverageWithNode","cartographicScratch","isTileAvailable","center","computeChildMaskForTile","childLevel","mask","parent","_sw","_se","_nw","_ne","Object","defineProperties","nw","get","ne","sw","se","rectangle1","rectangle2","max","min","maxDepth","rectangleFullyContainsRectangle","index","rectangleLevelComparator","splice","a","b","potentialContainer","rectangleToTest","positionToTest","longitude","latitude","stopNode","maxLevel","found","rectanglesToCover","anyOverlap","subtractRectangle","rectangleList","rectangleToSubtract","result"],"mappings":"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","sourcesContent":["import binarySearch from \"./binarySearch.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defined from \"./defined.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * Reports the availability of tiles in a {@link TilingScheme}.\n *\n * @alias TileAvailability\n * @constructor\n *\n * @param {TilingScheme} tilingScheme The tiling scheme in which to report availability.\n * @param {Number} maximumLevel The maximum tile level that is potentially available.\n */\nfunction TileAvailability(tilingScheme, maximumLevel) {\n  this._tilingScheme = tilingScheme;\n  this._maximumLevel = maximumLevel;\n\n  this._rootNodes = [];\n}\n\nvar rectangleScratch = new Rectangle();\n\nfunction findNode(level, x, y, nodes) {\n  var count = nodes.length;\n  for (var i = 0; i < count; ++i) {\n    var node = nodes[i];\n    if (node.x === x && node.y === y && node.level === level) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Marks a rectangular range of tiles in a particular level as being available.  For best performance,\n * add your ranges in order of increasing level.\n *\n * @param {Number} level The level.\n * @param {Number} startX The X coordinate of the first available tiles at the level.\n * @param {Number} startY The Y coordinate of the first available tiles at the level.\n * @param {Number} endX The X coordinate of the last available tiles at the level.\n * @param {Number} endY The Y coordinate of the last available tiles at the level.\n */\nTileAvailability.prototype.addAvailableTileRange = function (\n  level,\n  startX,\n  startY,\n  endX,\n  endY\n) {\n  var tilingScheme = this._tilingScheme;\n\n  var rootNodes = this._rootNodes;\n  if (level === 0) {\n    for (var y = startY; y <= endY; ++y) {\n      for (var x = startX; x <= endX; ++x) {\n        if (!findNode(level, x, y, rootNodes)) {\n          rootNodes.push(new QuadtreeNode(tilingScheme, undefined, 0, x, y));\n        }\n      }\n    }\n  }\n\n  tilingScheme.tileXYToRectangle(startX, startY, level, rectangleScratch);\n  var west = rectangleScratch.west;\n  var north = rectangleScratch.north;\n\n  tilingScheme.tileXYToRectangle(endX, endY, level, rectangleScratch);\n  var east = rectangleScratch.east;\n  var south = rectangleScratch.south;\n\n  var rectangleWithLevel = new RectangleWithLevel(\n    level,\n    west,\n    south,\n    east,\n    north\n  );\n\n  for (var i = 0; i < rootNodes.length; ++i) {\n    var rootNode = rootNodes[i];\n    if (rectanglesOverlap(rootNode.extent, rectangleWithLevel)) {\n      putRectangleInQuadtree(this._maximumLevel, rootNode, rectangleWithLevel);\n    }\n  }\n};\n\n/**\n * Determines the level of the most detailed tile covering the position.  This function\n * usually completes in time logarithmic to the number of rectangles added with\n * {@link TileAvailability#addAvailableTileRange}.\n *\n * @param {Cartographic} position The position for which to determine the maximum available level.  The height component is ignored.\n * @return {Number} The level of the most detailed tile covering the position.\n * @throws {DeveloperError} If position is outside any tile according to the tiling scheme.\n */\nTileAvailability.prototype.computeMaximumLevelAtPosition = function (position) {\n  // Find the root node that contains this position.\n  var node;\n  for (var nodeIndex = 0; nodeIndex < this._rootNodes.length; ++nodeIndex) {\n    var rootNode = this._rootNodes[nodeIndex];\n    if (rectangleContainsPosition(rootNode.extent, position)) {\n      node = rootNode;\n      break;\n    }\n  }\n\n  if (!defined(node)) {\n    return -1;\n  }\n\n  return findMaxLevelFromNode(undefined, node, position);\n};\n\nvar rectanglesScratch = [];\nvar remainingToCoverByLevelScratch = [];\nvar westScratch = new Rectangle();\nvar eastScratch = new Rectangle();\n\n/**\n * Finds the most detailed level that is available _everywhere_ within a given rectangle.  More detailed\n * tiles may be available in parts of the rectangle, but not the whole thing.  The return value of this\n * function may be safely passed to {@link sampleTerrain} for any position within the rectangle.  This function\n * usually completes in time logarithmic to the number of rectangles added with\n * {@link TileAvailability#addAvailableTileRange}.\n *\n * @param {Rectangle} rectangle The rectangle.\n * @return {Number} The best available level for the entire rectangle.\n */\nTileAvailability.prototype.computeBestAvailableLevelOverRectangle = function (\n  rectangle\n) {\n  var rectangles = rectanglesScratch;\n  rectangles.length = 0;\n\n  if (rectangle.east < rectangle.west) {\n    // Rectangle crosses the IDL, make it two rectangles.\n    rectangles.push(\n      Rectangle.fromRadians(\n        -Math.PI,\n        rectangle.south,\n        rectangle.east,\n        rectangle.north,\n        westScratch\n      )\n    );\n    rectangles.push(\n      Rectangle.fromRadians(\n        rectangle.west,\n        rectangle.south,\n        Math.PI,\n        rectangle.north,\n        eastScratch\n      )\n    );\n  } else {\n    rectangles.push(rectangle);\n  }\n\n  var remainingToCoverByLevel = remainingToCoverByLevelScratch;\n  remainingToCoverByLevel.length = 0;\n\n  var i;\n  for (i = 0; i < this._rootNodes.length; ++i) {\n    updateCoverageWithNode(\n      remainingToCoverByLevel,\n      this._rootNodes[i],\n      rectangles\n    );\n  }\n\n  for (i = remainingToCoverByLevel.length - 1; i >= 0; --i) {\n    if (\n      defined(remainingToCoverByLevel[i]) &&\n      remainingToCoverByLevel[i].length === 0\n    ) {\n      return i;\n    }\n  }\n\n  return 0;\n};\n\nvar cartographicScratch = new Cartographic();\n\n/**\n * Determines if a particular tile is available.\n * @param {Number} level The tile level to check.\n * @param {Number} x The X coordinate of the tile to check.\n * @param {Number} y The Y coordinate of the tile to check.\n * @return {Boolean} True if the tile is available; otherwise, false.\n */\nTileAvailability.prototype.isTileAvailable = function (level, x, y) {\n  // Get the center of the tile and find the maximum level at that position.\n  // Because availability is by tile, if the level is available at that point, it\n  // is sure to be available for the whole tile.  We assume that if a tile at level n exists,\n  // then all its parent tiles back to level 0 exist too.  This isn't really enforced\n  // anywhere, but Cesium would never load a tile for which this is not true.\n  var rectangle = this._tilingScheme.tileXYToRectangle(\n    x,\n    y,\n    level,\n    rectangleScratch\n  );\n  Rectangle.center(rectangle, cartographicScratch);\n  return this.computeMaximumLevelAtPosition(cartographicScratch) >= level;\n};\n\n/**\n * Computes a bit mask indicating which of a tile's four children exist.\n * If a child's bit is set, a tile is available for that child.  If it is cleared,\n * the tile is not available.  The bit values are as follows:\n * <table>\n *     <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *     <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *     <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *     <tr><td>2</td><td>4</td><td>Northwest</td></tr>\n *     <tr><td>3</td><td>8</td><td>Northeast</td></tr>\n * </table>\n *\n * @param {Number} level The level of the parent tile.\n * @param {Number} x The X coordinate of the parent tile.\n * @param {Number} y The Y coordinate of the parent tile.\n * @return {Number} The bit mask indicating child availability.\n */\nTileAvailability.prototype.computeChildMaskForTile = function (level, x, y) {\n  var childLevel = level + 1;\n  if (childLevel >= this._maximumLevel) {\n    return 0;\n  }\n\n  var mask = 0;\n\n  mask |= this.isTileAvailable(childLevel, 2 * x, 2 * y + 1) ? 1 : 0;\n  mask |= this.isTileAvailable(childLevel, 2 * x + 1, 2 * y + 1) ? 2 : 0;\n  mask |= this.isTileAvailable(childLevel, 2 * x, 2 * y) ? 4 : 0;\n  mask |= this.isTileAvailable(childLevel, 2 * x + 1, 2 * y) ? 8 : 0;\n\n  return mask;\n};\n\nfunction QuadtreeNode(tilingScheme, parent, level, x, y) {\n  this.tilingScheme = tilingScheme;\n  this.parent = parent;\n  this.level = level;\n  this.x = x;\n  this.y = y;\n  this.extent = tilingScheme.tileXYToRectangle(x, y, level);\n\n  this.rectangles = [];\n  this._sw = undefined;\n  this._se = undefined;\n  this._nw = undefined;\n  this._ne = undefined;\n}\n\nObject.defineProperties(QuadtreeNode.prototype, {\n  nw: {\n    get: function () {\n      if (!this._nw) {\n        this._nw = new QuadtreeNode(\n          this.tilingScheme,\n          this,\n          this.level + 1,\n          this.x * 2,\n          this.y * 2\n        );\n      }\n      return this._nw;\n    },\n  },\n\n  ne: {\n    get: function () {\n      if (!this._ne) {\n        this._ne = new QuadtreeNode(\n          this.tilingScheme,\n          this,\n          this.level + 1,\n          this.x * 2 + 1,\n          this.y * 2\n        );\n      }\n      return this._ne;\n    },\n  },\n\n  sw: {\n    get: function () {\n      if (!this._sw) {\n        this._sw = new QuadtreeNode(\n          this.tilingScheme,\n          this,\n          this.level + 1,\n          this.x * 2,\n          this.y * 2 + 1\n        );\n      }\n      return this._sw;\n    },\n  },\n\n  se: {\n    get: function () {\n      if (!this._se) {\n        this._se = new QuadtreeNode(\n          this.tilingScheme,\n          this,\n          this.level + 1,\n          this.x * 2 + 1,\n          this.y * 2 + 1\n        );\n      }\n      return this._se;\n    },\n  },\n});\n\nfunction RectangleWithLevel(level, west, south, east, north) {\n  this.level = level;\n  this.west = west;\n  this.south = south;\n  this.east = east;\n  this.north = north;\n}\n\nfunction rectanglesOverlap(rectangle1, rectangle2) {\n  var west = Math.max(rectangle1.west, rectangle2.west);\n  var south = Math.max(rectangle1.south, rectangle2.south);\n  var east = Math.min(rectangle1.east, rectangle2.east);\n  var north = Math.min(rectangle1.north, rectangle2.north);\n  return south < north && west < east;\n}\n\nfunction putRectangleInQuadtree(maxDepth, node, rectangle) {\n  while (node.level < maxDepth) {\n    if (rectangleFullyContainsRectangle(node.nw.extent, rectangle)) {\n      node = node.nw;\n    } else if (rectangleFullyContainsRectangle(node.ne.extent, rectangle)) {\n      node = node.ne;\n    } else if (rectangleFullyContainsRectangle(node.sw.extent, rectangle)) {\n      node = node.sw;\n    } else if (rectangleFullyContainsRectangle(node.se.extent, rectangle)) {\n      node = node.se;\n    } else {\n      break;\n    }\n  }\n\n  if (\n    node.rectangles.length === 0 ||\n    node.rectangles[node.rectangles.length - 1].level <= rectangle.level\n  ) {\n    node.rectangles.push(rectangle);\n  } else {\n    // Maintain ordering by level when inserting.\n    var index = binarySearch(\n      node.rectangles,\n      rectangle.level,\n      rectangleLevelComparator\n    );\n    if (index <= 0) {\n      index = ~index;\n    }\n    node.rectangles.splice(index, 0, rectangle);\n  }\n}\n\nfunction rectangleLevelComparator(a, b) {\n  return a.level - b;\n}\n\nfunction rectangleFullyContainsRectangle(potentialContainer, rectangleToTest) {\n  return (\n    rectangleToTest.west >= potentialContainer.west &&\n    rectangleToTest.east <= potentialContainer.east &&\n    rectangleToTest.south >= potentialContainer.south &&\n    rectangleToTest.north <= potentialContainer.north\n  );\n}\n\nfunction rectangleContainsPosition(potentialContainer, positionToTest) {\n  return (\n    positionToTest.longitude >= potentialContainer.west &&\n    positionToTest.longitude <= potentialContainer.east &&\n    positionToTest.latitude >= potentialContainer.south &&\n    positionToTest.latitude <= potentialContainer.north\n  );\n}\n\nfunction findMaxLevelFromNode(stopNode, node, position) {\n  var maxLevel = 0;\n\n  // Find the deepest quadtree node containing this point.\n  var found = false;\n  while (!found) {\n    var nw = node._nw && rectangleContainsPosition(node._nw.extent, position);\n    var ne = node._ne && rectangleContainsPosition(node._ne.extent, position);\n    var sw = node._sw && rectangleContainsPosition(node._sw.extent, position);\n    var se = node._se && rectangleContainsPosition(node._se.extent, position);\n\n    // The common scenario is that the point is in only one quadrant and we can simply\n    // iterate down the tree.  But if the point is on a boundary between tiles, it is\n    // in multiple tiles and we need to check all of them, so use recursion.\n    if (nw + ne + sw + se > 1) {\n      if (nw) {\n        maxLevel = Math.max(\n          maxLevel,\n          findMaxLevelFromNode(node, node._nw, position)\n        );\n      }\n      if (ne) {\n        maxLevel = Math.max(\n          maxLevel,\n          findMaxLevelFromNode(node, node._ne, position)\n        );\n      }\n      if (sw) {\n        maxLevel = Math.max(\n          maxLevel,\n          findMaxLevelFromNode(node, node._sw, position)\n        );\n      }\n      if (se) {\n        maxLevel = Math.max(\n          maxLevel,\n          findMaxLevelFromNode(node, node._se, position)\n        );\n      }\n      break;\n    } else if (nw) {\n      node = node._nw;\n    } else if (ne) {\n      node = node._ne;\n    } else if (sw) {\n      node = node._sw;\n    } else if (se) {\n      node = node._se;\n    } else {\n      found = true;\n    }\n  }\n\n  // Work up the tree until we find a rectangle that contains this point.\n  while (node !== stopNode) {\n    var rectangles = node.rectangles;\n\n    // Rectangles are sorted by level, lowest first.\n    for (\n      var i = rectangles.length - 1;\n      i >= 0 && rectangles[i].level > maxLevel;\n      --i\n    ) {\n      var rectangle = rectangles[i];\n      if (rectangleContainsPosition(rectangle, position)) {\n        maxLevel = rectangle.level;\n      }\n    }\n\n    node = node.parent;\n  }\n\n  return maxLevel;\n}\n\nfunction updateCoverageWithNode(\n  remainingToCoverByLevel,\n  node,\n  rectanglesToCover\n) {\n  if (!node) {\n    return;\n  }\n\n  var i;\n  var anyOverlap = false;\n  for (i = 0; i < rectanglesToCover.length; ++i) {\n    anyOverlap =\n      anyOverlap || rectanglesOverlap(node.extent, rectanglesToCover[i]);\n  }\n\n  if (!anyOverlap) {\n    // This node is not applicable to the rectangle(s).\n    return;\n  }\n\n  var rectangles = node.rectangles;\n  for (i = 0; i < rectangles.length; ++i) {\n    var rectangle = rectangles[i];\n\n    if (!remainingToCoverByLevel[rectangle.level]) {\n      remainingToCoverByLevel[rectangle.level] = rectanglesToCover;\n    }\n\n    remainingToCoverByLevel[rectangle.level] = subtractRectangle(\n      remainingToCoverByLevel[rectangle.level],\n      rectangle\n    );\n  }\n\n  // Update with child nodes.\n  updateCoverageWithNode(remainingToCoverByLevel, node._nw, rectanglesToCover);\n  updateCoverageWithNode(remainingToCoverByLevel, node._ne, rectanglesToCover);\n  updateCoverageWithNode(remainingToCoverByLevel, node._sw, rectanglesToCover);\n  updateCoverageWithNode(remainingToCoverByLevel, node._se, rectanglesToCover);\n}\n\nfunction subtractRectangle(rectangleList, rectangleToSubtract) {\n  var result = [];\n  for (var i = 0; i < rectangleList.length; ++i) {\n    var rectangle = rectangleList[i];\n    if (!rectanglesOverlap(rectangle, rectangleToSubtract)) {\n      // Disjoint rectangles.  Original rectangle is unmodified.\n      result.push(rectangle);\n    } else {\n      // rectangleToSubtract partially or completely overlaps rectangle.\n      if (rectangle.west < rectangleToSubtract.west) {\n        result.push(\n          new Rectangle(\n            rectangle.west,\n            rectangle.south,\n            rectangleToSubtract.west,\n            rectangle.north\n          )\n        );\n      }\n      if (rectangle.east > rectangleToSubtract.east) {\n        result.push(\n          new Rectangle(\n            rectangleToSubtract.east,\n            rectangle.south,\n            rectangle.east,\n            rectangle.north\n          )\n        );\n      }\n      if (rectangle.south < rectangleToSubtract.south) {\n        result.push(\n          new Rectangle(\n            Math.max(rectangleToSubtract.west, rectangle.west),\n            rectangle.south,\n            Math.min(rectangleToSubtract.east, rectangle.east),\n            rectangleToSubtract.south\n          )\n        );\n      }\n      if (rectangle.north > rectangleToSubtract.north) {\n        result.push(\n          new Rectangle(\n            Math.max(rectangleToSubtract.west, rectangle.west),\n            rectangleToSubtract.north,\n            Math.min(rectangleToSubtract.east, rectangle.east),\n            rectangle.north\n          )\n        );\n      }\n    }\n  }\n\n  return result;\n}\nexport default TileAvailability;\n"]},"metadata":{},"sourceType":"module"}