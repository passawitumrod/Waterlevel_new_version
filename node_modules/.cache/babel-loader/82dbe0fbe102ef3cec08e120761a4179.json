{"ast":null,"code":"import Cartesian2 from \"./Cartesian2.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport CesiumMath from \"./Math.js\";\nimport Rectangle from \"./Rectangle.js\";\n/**\n * A tiling scheme for geometry referenced to a simple {@link GeographicProjection} where\n * longitude and latitude are directly mapped to X and Y.  This projection is commonly\n * known as geographic, equirectangular, equidistant cylindrical, or plate carrée.\n *\n * @alias GeographicTilingScheme\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid whose surface is being tiled. Defaults to\n * the WGS84 ellipsoid.\n * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the tiling scheme.\n * @param {Number} [options.numberOfLevelZeroTilesX=2] The number of tiles in the X direction at level zero of\n * the tile tree.\n * @param {Number} [options.numberOfLevelZeroTilesY=1] The number of tiles in the Y direction at level zero of\n * the tile tree.\n */\n\nfunction GeographicTilingScheme(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  this._rectangle = defaultValue(options.rectangle, Rectangle.MAX_VALUE);\n  this._projection = new GeographicProjection(this._ellipsoid);\n  this._numberOfLevelZeroTilesX = defaultValue(options.numberOfLevelZeroTilesX, 2);\n  this._numberOfLevelZeroTilesY = defaultValue(options.numberOfLevelZeroTilesY, 1);\n}\n\nObject.defineProperties(GeographicTilingScheme.prototype, {\n  /**\n   * Gets the ellipsoid that is tiled by this tiling scheme.\n   * @memberof GeographicTilingScheme.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    }\n  },\n\n  /**\n   * Gets the rectangle, in radians, covered by this tiling scheme.\n   * @memberof GeographicTilingScheme.prototype\n   * @type {Rectangle}\n   */\n  rectangle: {\n    get: function () {\n      return this._rectangle;\n    }\n  },\n\n  /**\n   * Gets the map projection used by this tiling scheme.\n   * @memberof GeographicTilingScheme.prototype\n   * @type {MapProjection}\n   */\n  projection: {\n    get: function () {\n      return this._projection;\n    }\n  }\n});\n/**\n * Gets the total number of tiles in the X direction at a specified level-of-detail.\n *\n * @param {Number} level The level-of-detail.\n * @returns {Number} The number of tiles in the X direction at the given level.\n */\n\nGeographicTilingScheme.prototype.getNumberOfXTilesAtLevel = function (level) {\n  return this._numberOfLevelZeroTilesX << level;\n};\n/**\n * Gets the total number of tiles in the Y direction at a specified level-of-detail.\n *\n * @param {Number} level The level-of-detail.\n * @returns {Number} The number of tiles in the Y direction at the given level.\n */\n\n\nGeographicTilingScheme.prototype.getNumberOfYTilesAtLevel = function (level) {\n  return this._numberOfLevelZeroTilesY << level;\n};\n/**\n * Transforms a rectangle specified in geodetic radians to the native coordinate system\n * of this tiling scheme.\n *\n * @param {Rectangle} rectangle The rectangle to transform.\n * @param {Rectangle} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the native rectangle if 'result'\n *          is undefined.\n */\n\n\nGeographicTilingScheme.prototype.rectangleToNativeRectangle = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"rectangle\", rectangle); //>>includeEnd('debug');\n\n  var west = CesiumMath.toDegrees(rectangle.west);\n  var south = CesiumMath.toDegrees(rectangle.south);\n  var east = CesiumMath.toDegrees(rectangle.east);\n  var north = CesiumMath.toDegrees(rectangle.north);\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n/**\n * Converts tile x, y coordinates and level to a rectangle expressed in the native coordinates\n * of the tiling scheme.\n *\n * @param {Number} x The integer x coordinate of the tile.\n * @param {Number} y The integer y coordinate of the tile.\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\n *          if 'result' is undefined.\n */\n\n\nGeographicTilingScheme.prototype.tileXYToNativeRectangle = function (x, y, level, result) {\n  var rectangleRadians = this.tileXYToRectangle(x, y, level, result);\n  rectangleRadians.west = CesiumMath.toDegrees(rectangleRadians.west);\n  rectangleRadians.south = CesiumMath.toDegrees(rectangleRadians.south);\n  rectangleRadians.east = CesiumMath.toDegrees(rectangleRadians.east);\n  rectangleRadians.north = CesiumMath.toDegrees(rectangleRadians.north);\n  return rectangleRadians;\n};\n/**\n * Converts tile x, y coordinates and level to a cartographic rectangle in radians.\n *\n * @param {Number} x The integer x coordinate of the tile.\n * @param {Number} y The integer y coordinate of the tile.\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\n *          if 'result' is undefined.\n */\n\n\nGeographicTilingScheme.prototype.tileXYToRectangle = function (x, y, level, result) {\n  var rectangle = this._rectangle;\n  var xTiles = this.getNumberOfXTilesAtLevel(level);\n  var yTiles = this.getNumberOfYTilesAtLevel(level);\n  var xTileWidth = rectangle.width / xTiles;\n  var west = x * xTileWidth + rectangle.west;\n  var east = (x + 1) * xTileWidth + rectangle.west;\n  var yTileHeight = rectangle.height / yTiles;\n  var north = rectangle.north - y * yTileHeight;\n  var south = rectangle.north - (y + 1) * yTileHeight;\n\n  if (!defined(result)) {\n    result = new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n/**\n * Calculates the tile x, y coordinates of the tile containing\n * a given cartographic position.\n *\n * @param {Cartographic} position The position.\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {Cartesian2} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Cartesian2} The specified 'result', or a new object containing the tile x, y coordinates\n *          if 'result' is undefined.\n */\n\n\nGeographicTilingScheme.prototype.positionToTileXY = function (position, level, result) {\n  var rectangle = this._rectangle;\n\n  if (!Rectangle.contains(rectangle, position)) {\n    // outside the bounds of the tiling scheme\n    return undefined;\n  }\n\n  var xTiles = this.getNumberOfXTilesAtLevel(level);\n  var yTiles = this.getNumberOfYTilesAtLevel(level);\n  var xTileWidth = rectangle.width / xTiles;\n  var yTileHeight = rectangle.height / yTiles;\n  var longitude = position.longitude;\n\n  if (rectangle.east < rectangle.west) {\n    longitude += CesiumMath.TWO_PI;\n  }\n\n  var xTileCoordinate = (longitude - rectangle.west) / xTileWidth | 0;\n\n  if (xTileCoordinate >= xTiles) {\n    xTileCoordinate = xTiles - 1;\n  }\n\n  var yTileCoordinate = (rectangle.north - position.latitude) / yTileHeight | 0;\n\n  if (yTileCoordinate >= yTiles) {\n    yTileCoordinate = yTiles - 1;\n  }\n\n  if (!defined(result)) {\n    return new Cartesian2(xTileCoordinate, yTileCoordinate);\n  }\n\n  result.x = xTileCoordinate;\n  result.y = yTileCoordinate;\n  return result;\n};\n\nexport default GeographicTilingScheme;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/GeographicTilingScheme.js"],"names":["Cartesian2","Check","defaultValue","defined","Ellipsoid","GeographicProjection","CesiumMath","Rectangle","GeographicTilingScheme","options","EMPTY_OBJECT","_ellipsoid","ellipsoid","WGS84","_rectangle","rectangle","MAX_VALUE","_projection","_numberOfLevelZeroTilesX","numberOfLevelZeroTilesX","_numberOfLevelZeroTilesY","numberOfLevelZeroTilesY","Object","defineProperties","prototype","get","projection","getNumberOfXTilesAtLevel","level","getNumberOfYTilesAtLevel","rectangleToNativeRectangle","result","west","toDegrees","south","east","north","tileXYToNativeRectangle","x","y","rectangleRadians","tileXYToRectangle","xTiles","yTiles","xTileWidth","width","yTileHeight","height","positionToTileXY","position","contains","undefined","longitude","TWO_PI","xTileCoordinate","yTileCoordinate","latitude"],"mappings":"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","sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport CesiumMath from \"./Math.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * A tiling scheme for geometry referenced to a simple {@link GeographicProjection} where\n * longitude and latitude are directly mapped to X and Y.  This projection is commonly\n * known as geographic, equirectangular, equidistant cylindrical, or plate carrée.\n *\n * @alias GeographicTilingScheme\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid whose surface is being tiled. Defaults to\n * the WGS84 ellipsoid.\n * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the tiling scheme.\n * @param {Number} [options.numberOfLevelZeroTilesX=2] The number of tiles in the X direction at level zero of\n * the tile tree.\n * @param {Number} [options.numberOfLevelZeroTilesY=1] The number of tiles in the Y direction at level zero of\n * the tile tree.\n */\nfunction GeographicTilingScheme(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  this._rectangle = defaultValue(options.rectangle, Rectangle.MAX_VALUE);\n  this._projection = new GeographicProjection(this._ellipsoid);\n  this._numberOfLevelZeroTilesX = defaultValue(\n    options.numberOfLevelZeroTilesX,\n    2\n  );\n  this._numberOfLevelZeroTilesY = defaultValue(\n    options.numberOfLevelZeroTilesY,\n    1\n  );\n}\n\nObject.defineProperties(GeographicTilingScheme.prototype, {\n  /**\n   * Gets the ellipsoid that is tiled by this tiling scheme.\n   * @memberof GeographicTilingScheme.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n\n  /**\n   * Gets the rectangle, in radians, covered by this tiling scheme.\n   * @memberof GeographicTilingScheme.prototype\n   * @type {Rectangle}\n   */\n  rectangle: {\n    get: function () {\n      return this._rectangle;\n    },\n  },\n\n  /**\n   * Gets the map projection used by this tiling scheme.\n   * @memberof GeographicTilingScheme.prototype\n   * @type {MapProjection}\n   */\n  projection: {\n    get: function () {\n      return this._projection;\n    },\n  },\n});\n\n/**\n * Gets the total number of tiles in the X direction at a specified level-of-detail.\n *\n * @param {Number} level The level-of-detail.\n * @returns {Number} The number of tiles in the X direction at the given level.\n */\nGeographicTilingScheme.prototype.getNumberOfXTilesAtLevel = function (level) {\n  return this._numberOfLevelZeroTilesX << level;\n};\n\n/**\n * Gets the total number of tiles in the Y direction at a specified level-of-detail.\n *\n * @param {Number} level The level-of-detail.\n * @returns {Number} The number of tiles in the Y direction at the given level.\n */\nGeographicTilingScheme.prototype.getNumberOfYTilesAtLevel = function (level) {\n  return this._numberOfLevelZeroTilesY << level;\n};\n\n/**\n * Transforms a rectangle specified in geodetic radians to the native coordinate system\n * of this tiling scheme.\n *\n * @param {Rectangle} rectangle The rectangle to transform.\n * @param {Rectangle} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the native rectangle if 'result'\n *          is undefined.\n */\nGeographicTilingScheme.prototype.rectangleToNativeRectangle = function (\n  rectangle,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  var west = CesiumMath.toDegrees(rectangle.west);\n  var south = CesiumMath.toDegrees(rectangle.south);\n  var east = CesiumMath.toDegrees(rectangle.east);\n  var north = CesiumMath.toDegrees(rectangle.north);\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Converts tile x, y coordinates and level to a rectangle expressed in the native coordinates\n * of the tiling scheme.\n *\n * @param {Number} x The integer x coordinate of the tile.\n * @param {Number} y The integer y coordinate of the tile.\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\n *          if 'result' is undefined.\n */\nGeographicTilingScheme.prototype.tileXYToNativeRectangle = function (\n  x,\n  y,\n  level,\n  result\n) {\n  var rectangleRadians = this.tileXYToRectangle(x, y, level, result);\n  rectangleRadians.west = CesiumMath.toDegrees(rectangleRadians.west);\n  rectangleRadians.south = CesiumMath.toDegrees(rectangleRadians.south);\n  rectangleRadians.east = CesiumMath.toDegrees(rectangleRadians.east);\n  rectangleRadians.north = CesiumMath.toDegrees(rectangleRadians.north);\n  return rectangleRadians;\n};\n\n/**\n * Converts tile x, y coordinates and level to a cartographic rectangle in radians.\n *\n * @param {Number} x The integer x coordinate of the tile.\n * @param {Number} y The integer y coordinate of the tile.\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\n *          if 'result' is undefined.\n */\nGeographicTilingScheme.prototype.tileXYToRectangle = function (\n  x,\n  y,\n  level,\n  result\n) {\n  var rectangle = this._rectangle;\n\n  var xTiles = this.getNumberOfXTilesAtLevel(level);\n  var yTiles = this.getNumberOfYTilesAtLevel(level);\n\n  var xTileWidth = rectangle.width / xTiles;\n  var west = x * xTileWidth + rectangle.west;\n  var east = (x + 1) * xTileWidth + rectangle.west;\n\n  var yTileHeight = rectangle.height / yTiles;\n  var north = rectangle.north - y * yTileHeight;\n  var south = rectangle.north - (y + 1) * yTileHeight;\n\n  if (!defined(result)) {\n    result = new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Calculates the tile x, y coordinates of the tile containing\n * a given cartographic position.\n *\n * @param {Cartographic} position The position.\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {Cartesian2} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Cartesian2} The specified 'result', or a new object containing the tile x, y coordinates\n *          if 'result' is undefined.\n */\nGeographicTilingScheme.prototype.positionToTileXY = function (\n  position,\n  level,\n  result\n) {\n  var rectangle = this._rectangle;\n  if (!Rectangle.contains(rectangle, position)) {\n    // outside the bounds of the tiling scheme\n    return undefined;\n  }\n\n  var xTiles = this.getNumberOfXTilesAtLevel(level);\n  var yTiles = this.getNumberOfYTilesAtLevel(level);\n\n  var xTileWidth = rectangle.width / xTiles;\n  var yTileHeight = rectangle.height / yTiles;\n\n  var longitude = position.longitude;\n  if (rectangle.east < rectangle.west) {\n    longitude += CesiumMath.TWO_PI;\n  }\n\n  var xTileCoordinate = ((longitude - rectangle.west) / xTileWidth) | 0;\n  if (xTileCoordinate >= xTiles) {\n    xTileCoordinate = xTiles - 1;\n  }\n\n  var yTileCoordinate =\n    ((rectangle.north - position.latitude) / yTileHeight) | 0;\n  if (yTileCoordinate >= yTiles) {\n    yTileCoordinate = yTiles - 1;\n  }\n\n  if (!defined(result)) {\n    return new Cartesian2(xTileCoordinate, yTileCoordinate);\n  }\n\n  result.x = xTileCoordinate;\n  result.y = yTileCoordinate;\n  return result;\n};\nexport default GeographicTilingScheme;\n"]},"metadata":{},"sourceType":"module"}