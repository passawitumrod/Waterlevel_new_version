{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Plane from \"../Core/Plane.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport RectangleOutlineGeometry from \"../Core/RectangleOutlineGeometry.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport SceneMode from \"./SceneMode.js\";\n/**\n * A tile bounding volume specified as a longitude/latitude/height region.\n * @alias TileBoundingRegion\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Rectangle} options.rectangle The rectangle specifying the longitude and latitude range of the region.\n * @param {Number} [options.minimumHeight=0.0] The minimum height of the region.\n * @param {Number} [options.maximumHeight=0.0] The maximum height of the region.\n * @param {Ellipsoid} [options.ellipsoid=Cesium.Ellipsoid.WGS84] The ellipsoid.\n * @param {Boolean} [options.computeBoundingVolumes=true] True to compute the {@link TileBoundingRegion#boundingVolume} and\n *                  {@link TileBoundingVolume#boundingSphere}. If false, these properties will be undefined.\n *\n * @private\n */\n\nfunction TileBoundingRegion(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.rectangle\", options.rectangle); //>>includeEnd('debug');\n\n  this.rectangle = Rectangle.clone(options.rectangle);\n  this.minimumHeight = defaultValue(options.minimumHeight, 0.0);\n  this.maximumHeight = defaultValue(options.maximumHeight, 0.0);\n  /**\n   * The world coordinates of the southwest corner of the tile's rectangle.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n\n  this.southwestCornerCartesian = new Cartesian3();\n  /**\n   * The world coordinates of the northeast corner of the tile's rectangle.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n\n  this.northeastCornerCartesian = new Cartesian3();\n  /**\n   * A normal that, along with southwestCornerCartesian, defines a plane at the western edge of\n   * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n\n  this.westNormal = new Cartesian3();\n  /**\n   * A normal that, along with southwestCornerCartesian, defines a plane at the southern edge of\n   * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.\n   * Because points of constant latitude do not necessary lie in a plane, positions below this\n   * plane are not necessarily inside the tile, but they are close.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n\n  this.southNormal = new Cartesian3();\n  /**\n   * A normal that, along with northeastCornerCartesian, defines a plane at the eastern edge of\n   * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n\n  this.eastNormal = new Cartesian3();\n  /**\n   * A normal that, along with northeastCornerCartesian, defines a plane at the eastern edge of\n   * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.\n   * Because points of constant latitude do not necessary lie in a plane, positions below this\n   * plane are not necessarily inside the tile, but they are close.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n\n  this.northNormal = new Cartesian3();\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  computeBox(this, options.rectangle, ellipsoid);\n\n  if (defaultValue(options.computeBoundingVolumes, true)) {\n    // An oriented bounding box that encloses this tile's region.  This is used to calculate tile visibility.\n    this._orientedBoundingBox = OrientedBoundingBox.fromRectangle(this.rectangle, this.minimumHeight, this.maximumHeight, ellipsoid);\n    this._boundingSphere = BoundingSphere.fromOrientedBoundingBox(this._orientedBoundingBox);\n  }\n}\n\nObject.defineProperties(TileBoundingRegion.prototype, {\n  /**\n   * The underlying bounding volume\n   *\n   * @memberof TileBoundingRegion.prototype\n   *\n   * @type {Object}\n   * @readonly\n   */\n  boundingVolume: {\n    get: function get() {\n      return this._orientedBoundingBox;\n    }\n  },\n\n  /**\n   * The underlying bounding sphere\n   *\n   * @memberof TileBoundingRegion.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function get() {\n      return this._boundingSphere;\n    }\n  }\n});\nvar cartesian3Scratch = new Cartesian3();\nvar cartesian3Scratch2 = new Cartesian3();\nvar cartesian3Scratch3 = new Cartesian3();\nvar eastWestNormalScratch = new Cartesian3();\nvar westernMidpointScratch = new Cartesian3();\nvar easternMidpointScratch = new Cartesian3();\nvar cartographicScratch = new Cartographic();\nvar planeScratch = new Plane(Cartesian3.UNIT_X, 0.0);\nvar rayScratch = new Ray();\n\nfunction computeBox(tileBB, rectangle, ellipsoid) {\n  ellipsoid.cartographicToCartesian(Rectangle.southwest(rectangle), tileBB.southwestCornerCartesian);\n  ellipsoid.cartographicToCartesian(Rectangle.northeast(rectangle), tileBB.northeastCornerCartesian); // The middle latitude on the western edge.\n\n  cartographicScratch.longitude = rectangle.west;\n  cartographicScratch.latitude = (rectangle.south + rectangle.north) * 0.5;\n  cartographicScratch.height = 0.0;\n  var westernMidpointCartesian = ellipsoid.cartographicToCartesian(cartographicScratch, westernMidpointScratch); // Compute the normal of the plane on the western edge of the tile.\n\n  var westNormal = Cartesian3.cross(westernMidpointCartesian, Cartesian3.UNIT_Z, cartesian3Scratch);\n  Cartesian3.normalize(westNormal, tileBB.westNormal); // The middle latitude on the eastern edge.\n\n  cartographicScratch.longitude = rectangle.east;\n  var easternMidpointCartesian = ellipsoid.cartographicToCartesian(cartographicScratch, easternMidpointScratch); // Compute the normal of the plane on the eastern edge of the tile.\n\n  var eastNormal = Cartesian3.cross(Cartesian3.UNIT_Z, easternMidpointCartesian, cartesian3Scratch);\n  Cartesian3.normalize(eastNormal, tileBB.eastNormal); // Compute the normal of the plane bounding the southern edge of the tile.\n\n  var westVector = Cartesian3.subtract(westernMidpointCartesian, easternMidpointCartesian, cartesian3Scratch);\n  var eastWestNormal = Cartesian3.normalize(westVector, eastWestNormalScratch);\n  var south = rectangle.south;\n  var southSurfaceNormal;\n\n  if (south > 0.0) {\n    // Compute a plane that doesn't cut through the tile.\n    cartographicScratch.longitude = (rectangle.west + rectangle.east) * 0.5;\n    cartographicScratch.latitude = south;\n    var southCenterCartesian = ellipsoid.cartographicToCartesian(cartographicScratch, rayScratch.origin);\n    Cartesian3.clone(eastWestNormal, rayScratch.direction);\n    var westPlane = Plane.fromPointNormal(tileBB.southwestCornerCartesian, tileBB.westNormal, planeScratch); // Find a point that is on the west and the south planes\n\n    IntersectionTests.rayPlane(rayScratch, westPlane, tileBB.southwestCornerCartesian);\n    southSurfaceNormal = ellipsoid.geodeticSurfaceNormal(southCenterCartesian, cartesian3Scratch2);\n  } else {\n    southSurfaceNormal = ellipsoid.geodeticSurfaceNormalCartographic(Rectangle.southeast(rectangle), cartesian3Scratch2);\n  }\n\n  var southNormal = Cartesian3.cross(southSurfaceNormal, westVector, cartesian3Scratch3);\n  Cartesian3.normalize(southNormal, tileBB.southNormal); // Compute the normal of the plane bounding the northern edge of the tile.\n\n  var north = rectangle.north;\n  var northSurfaceNormal;\n\n  if (north < 0.0) {\n    // Compute a plane that doesn't cut through the tile.\n    cartographicScratch.longitude = (rectangle.west + rectangle.east) * 0.5;\n    cartographicScratch.latitude = north;\n    var northCenterCartesian = ellipsoid.cartographicToCartesian(cartographicScratch, rayScratch.origin);\n    Cartesian3.negate(eastWestNormal, rayScratch.direction);\n    var eastPlane = Plane.fromPointNormal(tileBB.northeastCornerCartesian, tileBB.eastNormal, planeScratch); // Find a point that is on the east and the north planes\n\n    IntersectionTests.rayPlane(rayScratch, eastPlane, tileBB.northeastCornerCartesian);\n    northSurfaceNormal = ellipsoid.geodeticSurfaceNormal(northCenterCartesian, cartesian3Scratch2);\n  } else {\n    northSurfaceNormal = ellipsoid.geodeticSurfaceNormalCartographic(Rectangle.northwest(rectangle), cartesian3Scratch2);\n  }\n\n  var northNormal = Cartesian3.cross(westVector, northSurfaceNormal, cartesian3Scratch3);\n  Cartesian3.normalize(northNormal, tileBB.northNormal);\n}\n\nvar southwestCornerScratch = new Cartesian3();\nvar northeastCornerScratch = new Cartesian3();\nvar negativeUnitY = new Cartesian3(0.0, -1.0, 0.0);\nvar negativeUnitZ = new Cartesian3(0.0, 0.0, -1.0);\nvar vectorScratch = new Cartesian3();\n/**\n * Gets the distance from the camera to the closest point on the tile.  This is used for level of detail selection.\n *\n * @param {FrameState} frameState The state information of the current rendering frame.\n * @returns {Number} The distance from the camera to the closest point on the tile, in meters.\n */\n\nTileBoundingRegion.prototype.distanceToCamera = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"frameState\", frameState); //>>includeEnd('debug');\n\n  var camera = frameState.camera;\n  var cameraCartesianPosition = camera.positionWC;\n  var cameraCartographicPosition = camera.positionCartographic;\n  var result = 0.0;\n\n  if (!Rectangle.contains(this.rectangle, cameraCartographicPosition)) {\n    var southwestCornerCartesian = this.southwestCornerCartesian;\n    var northeastCornerCartesian = this.northeastCornerCartesian;\n    var westNormal = this.westNormal;\n    var southNormal = this.southNormal;\n    var eastNormal = this.eastNormal;\n    var northNormal = this.northNormal;\n\n    if (frameState.mode !== SceneMode.SCENE3D) {\n      southwestCornerCartesian = frameState.mapProjection.project(Rectangle.southwest(this.rectangle), southwestCornerScratch);\n      southwestCornerCartesian.z = southwestCornerCartesian.y;\n      southwestCornerCartesian.y = southwestCornerCartesian.x;\n      southwestCornerCartesian.x = 0.0;\n      northeastCornerCartesian = frameState.mapProjection.project(Rectangle.northeast(this.rectangle), northeastCornerScratch);\n      northeastCornerCartesian.z = northeastCornerCartesian.y;\n      northeastCornerCartesian.y = northeastCornerCartesian.x;\n      northeastCornerCartesian.x = 0.0;\n      westNormal = negativeUnitY;\n      eastNormal = Cartesian3.UNIT_Y;\n      southNormal = negativeUnitZ;\n      northNormal = Cartesian3.UNIT_Z;\n    }\n\n    var vectorFromSouthwestCorner = Cartesian3.subtract(cameraCartesianPosition, southwestCornerCartesian, vectorScratch);\n    var distanceToWestPlane = Cartesian3.dot(vectorFromSouthwestCorner, westNormal);\n    var distanceToSouthPlane = Cartesian3.dot(vectorFromSouthwestCorner, southNormal);\n    var vectorFromNortheastCorner = Cartesian3.subtract(cameraCartesianPosition, northeastCornerCartesian, vectorScratch);\n    var distanceToEastPlane = Cartesian3.dot(vectorFromNortheastCorner, eastNormal);\n    var distanceToNorthPlane = Cartesian3.dot(vectorFromNortheastCorner, northNormal);\n\n    if (distanceToWestPlane > 0.0) {\n      result += distanceToWestPlane * distanceToWestPlane;\n    } else if (distanceToEastPlane > 0.0) {\n      result += distanceToEastPlane * distanceToEastPlane;\n    }\n\n    if (distanceToSouthPlane > 0.0) {\n      result += distanceToSouthPlane * distanceToSouthPlane;\n    } else if (distanceToNorthPlane > 0.0) {\n      result += distanceToNorthPlane * distanceToNorthPlane;\n    }\n  }\n\n  var cameraHeight;\n  var minimumHeight;\n  var maximumHeight;\n\n  if (frameState.mode === SceneMode.SCENE3D) {\n    cameraHeight = cameraCartographicPosition.height;\n    minimumHeight = this.minimumHeight;\n    maximumHeight = this.maximumHeight;\n  } else {\n    cameraHeight = cameraCartesianPosition.x;\n    minimumHeight = 0.0;\n    maximumHeight = 0.0;\n  }\n\n  if (cameraHeight > maximumHeight) {\n    var distanceAboveTop = cameraHeight - maximumHeight;\n    result += distanceAboveTop * distanceAboveTop;\n  } else if (cameraHeight < minimumHeight) {\n    var distanceBelowBottom = minimumHeight - cameraHeight;\n    result += distanceBelowBottom * distanceBelowBottom;\n  }\n\n  return Math.sqrt(result);\n};\n/**\n * Determines which side of a plane this box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\n\n\nTileBoundingRegion.prototype.intersectPlane = function (plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"plane\", plane); //>>includeEnd('debug');\n\n  return this._orientedBoundingBox.intersectPlane(plane);\n};\n/**\n * Creates a debug primitive that shows the outline of the tile bounding region.\n *\n * @param {Color} color The desired color of the primitive's mesh\n * @return {Primitive}\n *\n * @private\n */\n\n\nTileBoundingRegion.prototype.createDebugVolume = function (color) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"color\", color); //>>includeEnd('debug');\n\n  var modelMatrix = new Matrix4.clone(Matrix4.IDENTITY);\n  var geometry = new RectangleOutlineGeometry({\n    rectangle: this.rectangle,\n    height: this.minimumHeight,\n    extrudedHeight: this.maximumHeight\n  });\n  var instance = new GeometryInstance({\n    geometry: geometry,\n    id: \"outline\",\n    modelMatrix: modelMatrix,\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color)\n    }\n  });\n  return new Primitive({\n    geometryInstances: instance,\n    appearance: new PerInstanceColorAppearance({\n      translucent: false,\n      flat: true\n    }),\n    asynchronous: false\n  });\n};\n\nexport default TileBoundingRegion;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/TileBoundingRegion.js"],"names":["BoundingSphere","Cartesian3","Cartographic","Check","ColorGeometryInstanceAttribute","defaultValue","Ellipsoid","GeometryInstance","IntersectionTests","Matrix4","OrientedBoundingBox","Plane","Ray","Rectangle","RectangleOutlineGeometry","PerInstanceColorAppearance","Primitive","SceneMode","TileBoundingRegion","options","typeOf","object","rectangle","clone","minimumHeight","maximumHeight","southwestCornerCartesian","northeastCornerCartesian","westNormal","southNormal","eastNormal","northNormal","ellipsoid","WGS84","computeBox","computeBoundingVolumes","_orientedBoundingBox","fromRectangle","_boundingSphere","fromOrientedBoundingBox","Object","defineProperties","prototype","boundingVolume","get","boundingSphere","cartesian3Scratch","cartesian3Scratch2","cartesian3Scratch3","eastWestNormalScratch","westernMidpointScratch","easternMidpointScratch","cartographicScratch","planeScratch","UNIT_X","rayScratch","tileBB","cartographicToCartesian","southwest","northeast","longitude","west","latitude","south","north","height","westernMidpointCartesian","cross","UNIT_Z","normalize","east","easternMidpointCartesian","westVector","subtract","eastWestNormal","southSurfaceNormal","southCenterCartesian","origin","direction","westPlane","fromPointNormal","rayPlane","geodeticSurfaceNormal","geodeticSurfaceNormalCartographic","southeast","northSurfaceNormal","northCenterCartesian","negate","eastPlane","northwest","southwestCornerScratch","northeastCornerScratch","negativeUnitY","negativeUnitZ","vectorScratch","distanceToCamera","frameState","defined","camera","cameraCartesianPosition","positionWC","cameraCartographicPosition","positionCartographic","result","contains","mode","SCENE3D","mapProjection","project","z","y","x","UNIT_Y","vectorFromSouthwestCorner","distanceToWestPlane","dot","distanceToSouthPlane","vectorFromNortheastCorner","distanceToEastPlane","distanceToNorthPlane","cameraHeight","distanceAboveTop","distanceBelowBottom","Math","sqrt","intersectPlane","plane","createDebugVolume","color","modelMatrix","IDENTITY","geometry","extrudedHeight","instance","id","attributes","fromColor","geometryInstances","appearance","translucent","flat","asynchronous"],"mappings":"AAAA,OAAOA,cAAP,MAA2B,2BAA3B;AACA,OAAOC,UAAP,MAAuB,uBAAvB;AACA,OAAOC,YAAP,MAAyB,yBAAzB;AACA,OAAOC,KAAP,MAAkB,kBAAlB;AACA,OAAOC,8BAAP,MAA2C,2CAA3C;AACA,OAAOC,YAAP,MAAyB,yBAAzB;AACA,OAAOC,SAAP,MAAsB,sBAAtB;AACA,OAAOC,gBAAP,MAA6B,6BAA7B;AACA,OAAOC,iBAAP,MAA8B,8BAA9B;AACA,OAAOC,OAAP,MAAoB,oBAApB;AACA,OAAOC,mBAAP,MAAgC,gCAAhC;AACA,OAAOC,KAAP,MAAkB,kBAAlB;AACA,OAAOC,GAAP,MAAgB,gBAAhB;AACA,OAAOC,SAAP,MAAsB,sBAAtB;AACA,OAAOC,wBAAP,MAAqC,qCAArC;AACA,OAAOC,0BAAP,MAAuC,iCAAvC;AACA,OAAOC,SAAP,MAAsB,gBAAtB;AACA,OAAOC,SAAP,MAAsB,gBAAtB;AAEA;;;;;;;;;;;;;;;;AAeA,SAASC,kBAAT,CAA4BC,OAA5B,EAAqC;AACnC;AACAhB,EAAAA,KAAK,CAACiB,MAAN,CAAaC,MAAb,CAAoB,SAApB,EAA+BF,OAA/B;AACAhB,EAAAA,KAAK,CAACiB,MAAN,CAAaC,MAAb,CAAoB,mBAApB,EAAyCF,OAAO,CAACG,SAAjD,EAHmC,CAInC;;AAEA,OAAKA,SAAL,GAAiBT,SAAS,CAACU,KAAV,CAAgBJ,OAAO,CAACG,SAAxB,CAAjB;AACA,OAAKE,aAAL,GAAqBnB,YAAY,CAACc,OAAO,CAACK,aAAT,EAAwB,GAAxB,CAAjC;AACA,OAAKC,aAAL,GAAqBpB,YAAY,CAACc,OAAO,CAACM,aAAT,EAAwB,GAAxB,CAAjC;AAEA;;;;;;;AAMA,OAAKC,wBAAL,GAAgC,IAAIzB,UAAJ,EAAhC;AAEA;;;;;;;AAMA,OAAK0B,wBAAL,GAAgC,IAAI1B,UAAJ,EAAhC;AAEA;;;;;;;;AAOA,OAAK2B,UAAL,GAAkB,IAAI3B,UAAJ,EAAlB;AAEA;;;;;;;;;;AASA,OAAK4B,WAAL,GAAmB,IAAI5B,UAAJ,EAAnB;AAEA;;;;;;;;AAOA,OAAK6B,UAAL,GAAkB,IAAI7B,UAAJ,EAAlB;AAEA;;;;;;;;;;AASA,OAAK8B,WAAL,GAAmB,IAAI9B,UAAJ,EAAnB;AAEA,MAAI+B,SAAS,GAAG3B,YAAY,CAACc,OAAO,CAACa,SAAT,EAAoB1B,SAAS,CAAC2B,KAA9B,CAA5B;AACAC,EAAAA,UAAU,CAAC,IAAD,EAAOf,OAAO,CAACG,SAAf,EAA0BU,SAA1B,CAAV;;AAEA,MAAI3B,YAAY,CAACc,OAAO,CAACgB,sBAAT,EAAiC,IAAjC,CAAhB,EAAwD;AACtD;AACA,SAAKC,oBAAL,GAA4B1B,mBAAmB,CAAC2B,aAApB,CAC1B,KAAKf,SADqB,EAE1B,KAAKE,aAFqB,EAG1B,KAAKC,aAHqB,EAI1BO,SAJ0B,CAA5B;AAOA,SAAKM,eAAL,GAAuBtC,cAAc,CAACuC,uBAAf,CACrB,KAAKH,oBADgB,CAAvB;AAGD;AACF;;AAEDI,MAAM,CAACC,gBAAP,CAAwBvB,kBAAkB,CAACwB,SAA3C,EAAsD;AACpD;;;;;;;;AAQAC,EAAAA,cAAc,EAAE;AACdC,IAAAA,GAAG,EAAE,eAAY;AACf,aAAO,KAAKR,oBAAZ;AACD;AAHa,GAToC;;AAcpD;;;;;;;;AAQAS,EAAAA,cAAc,EAAE;AACdD,IAAAA,GAAG,EAAE,eAAY;AACf,aAAO,KAAKN,eAAZ;AACD;AAHa;AAtBoC,CAAtD;AA6BA,IAAIQ,iBAAiB,GAAG,IAAI7C,UAAJ,EAAxB;AACA,IAAI8C,kBAAkB,GAAG,IAAI9C,UAAJ,EAAzB;AACA,IAAI+C,kBAAkB,GAAG,IAAI/C,UAAJ,EAAzB;AACA,IAAIgD,qBAAqB,GAAG,IAAIhD,UAAJ,EAA5B;AACA,IAAIiD,sBAAsB,GAAG,IAAIjD,UAAJ,EAA7B;AACA,IAAIkD,sBAAsB,GAAG,IAAIlD,UAAJ,EAA7B;AACA,IAAImD,mBAAmB,GAAG,IAAIlD,YAAJ,EAA1B;AACA,IAAImD,YAAY,GAAG,IAAI1C,KAAJ,CAAUV,UAAU,CAACqD,MAArB,EAA6B,GAA7B,CAAnB;AACA,IAAIC,UAAU,GAAG,IAAI3C,GAAJ,EAAjB;;AAEA,SAASsB,UAAT,CAAoBsB,MAApB,EAA4BlC,SAA5B,EAAuCU,SAAvC,EAAkD;AAChDA,EAAAA,SAAS,CAACyB,uBAAV,CACE5C,SAAS,CAAC6C,SAAV,CAAoBpC,SAApB,CADF,EAEEkC,MAAM,CAAC9B,wBAFT;AAIAM,EAAAA,SAAS,CAACyB,uBAAV,CACE5C,SAAS,CAAC8C,SAAV,CAAoBrC,SAApB,CADF,EAEEkC,MAAM,CAAC7B,wBAFT,EALgD,CAUhD;;AACAyB,EAAAA,mBAAmB,CAACQ,SAApB,GAAgCtC,SAAS,CAACuC,IAA1C;AACAT,EAAAA,mBAAmB,CAACU,QAApB,GAA+B,CAACxC,SAAS,CAACyC,KAAV,GAAkBzC,SAAS,CAAC0C,KAA7B,IAAsC,GAArE;AACAZ,EAAAA,mBAAmB,CAACa,MAApB,GAA6B,GAA7B;AACA,MAAIC,wBAAwB,GAAGlC,SAAS,CAACyB,uBAAV,CAC7BL,mBAD6B,EAE7BF,sBAF6B,CAA/B,CAdgD,CAmBhD;;AACA,MAAItB,UAAU,GAAG3B,UAAU,CAACkE,KAAX,CACfD,wBADe,EAEfjE,UAAU,CAACmE,MAFI,EAGftB,iBAHe,CAAjB;AAKA7C,EAAAA,UAAU,CAACoE,SAAX,CAAqBzC,UAArB,EAAiC4B,MAAM,CAAC5B,UAAxC,EAzBgD,CA2BhD;;AACAwB,EAAAA,mBAAmB,CAACQ,SAApB,GAAgCtC,SAAS,CAACgD,IAA1C;AACA,MAAIC,wBAAwB,GAAGvC,SAAS,CAACyB,uBAAV,CAC7BL,mBAD6B,EAE7BD,sBAF6B,CAA/B,CA7BgD,CAkChD;;AACA,MAAIrB,UAAU,GAAG7B,UAAU,CAACkE,KAAX,CACflE,UAAU,CAACmE,MADI,EAEfG,wBAFe,EAGfzB,iBAHe,CAAjB;AAKA7C,EAAAA,UAAU,CAACoE,SAAX,CAAqBvC,UAArB,EAAiC0B,MAAM,CAAC1B,UAAxC,EAxCgD,CA0ChD;;AACA,MAAI0C,UAAU,GAAGvE,UAAU,CAACwE,QAAX,CACfP,wBADe,EAEfK,wBAFe,EAGfzB,iBAHe,CAAjB;AAKA,MAAI4B,cAAc,GAAGzE,UAAU,CAACoE,SAAX,CAAqBG,UAArB,EAAiCvB,qBAAjC,CAArB;AAEA,MAAIc,KAAK,GAAGzC,SAAS,CAACyC,KAAtB;AACA,MAAIY,kBAAJ;;AAEA,MAAIZ,KAAK,GAAG,GAAZ,EAAiB;AACf;AACAX,IAAAA,mBAAmB,CAACQ,SAApB,GAAgC,CAACtC,SAAS,CAACuC,IAAV,GAAiBvC,SAAS,CAACgD,IAA5B,IAAoC,GAApE;AACAlB,IAAAA,mBAAmB,CAACU,QAApB,GAA+BC,KAA/B;AACA,QAAIa,oBAAoB,GAAG5C,SAAS,CAACyB,uBAAV,CACzBL,mBADyB,EAEzBG,UAAU,CAACsB,MAFc,CAA3B;AAIA5E,IAAAA,UAAU,CAACsB,KAAX,CAAiBmD,cAAjB,EAAiCnB,UAAU,CAACuB,SAA5C;AACA,QAAIC,SAAS,GAAGpE,KAAK,CAACqE,eAAN,CACdxB,MAAM,CAAC9B,wBADO,EAEd8B,MAAM,CAAC5B,UAFO,EAGdyB,YAHc,CAAhB,CATe,CAcf;;AACA7C,IAAAA,iBAAiB,CAACyE,QAAlB,CACE1B,UADF,EAEEwB,SAFF,EAGEvB,MAAM,CAAC9B,wBAHT;AAKAiD,IAAAA,kBAAkB,GAAG3C,SAAS,CAACkD,qBAAV,CACnBN,oBADmB,EAEnB7B,kBAFmB,CAArB;AAID,GAxBD,MAwBO;AACL4B,IAAAA,kBAAkB,GAAG3C,SAAS,CAACmD,iCAAV,CACnBtE,SAAS,CAACuE,SAAV,CAAoB9D,SAApB,CADmB,EAEnByB,kBAFmB,CAArB;AAID;;AACD,MAAIlB,WAAW,GAAG5B,UAAU,CAACkE,KAAX,CAChBQ,kBADgB,EAEhBH,UAFgB,EAGhBxB,kBAHgB,CAAlB;AAKA/C,EAAAA,UAAU,CAACoE,SAAX,CAAqBxC,WAArB,EAAkC2B,MAAM,CAAC3B,WAAzC,EAxFgD,CA0FhD;;AACA,MAAImC,KAAK,GAAG1C,SAAS,CAAC0C,KAAtB;AACA,MAAIqB,kBAAJ;;AACA,MAAIrB,KAAK,GAAG,GAAZ,EAAiB;AACf;AACAZ,IAAAA,mBAAmB,CAACQ,SAApB,GAAgC,CAACtC,SAAS,CAACuC,IAAV,GAAiBvC,SAAS,CAACgD,IAA5B,IAAoC,GAApE;AACAlB,IAAAA,mBAAmB,CAACU,QAApB,GAA+BE,KAA/B;AACA,QAAIsB,oBAAoB,GAAGtD,SAAS,CAACyB,uBAAV,CACzBL,mBADyB,EAEzBG,UAAU,CAACsB,MAFc,CAA3B;AAIA5E,IAAAA,UAAU,CAACsF,MAAX,CAAkBb,cAAlB,EAAkCnB,UAAU,CAACuB,SAA7C;AACA,QAAIU,SAAS,GAAG7E,KAAK,CAACqE,eAAN,CACdxB,MAAM,CAAC7B,wBADO,EAEd6B,MAAM,CAAC1B,UAFO,EAGduB,YAHc,CAAhB,CATe,CAcf;;AACA7C,IAAAA,iBAAiB,CAACyE,QAAlB,CACE1B,UADF,EAEEiC,SAFF,EAGEhC,MAAM,CAAC7B,wBAHT;AAKA0D,IAAAA,kBAAkB,GAAGrD,SAAS,CAACkD,qBAAV,CACnBI,oBADmB,EAEnBvC,kBAFmB,CAArB;AAID,GAxBD,MAwBO;AACLsC,IAAAA,kBAAkB,GAAGrD,SAAS,CAACmD,iCAAV,CACnBtE,SAAS,CAAC4E,SAAV,CAAoBnE,SAApB,CADmB,EAEnByB,kBAFmB,CAArB;AAID;;AACD,MAAIhB,WAAW,GAAG9B,UAAU,CAACkE,KAAX,CAChBK,UADgB,EAEhBa,kBAFgB,EAGhBrC,kBAHgB,CAAlB;AAKA/C,EAAAA,UAAU,CAACoE,SAAX,CAAqBtC,WAArB,EAAkCyB,MAAM,CAACzB,WAAzC;AACD;;AAED,IAAI2D,sBAAsB,GAAG,IAAIzF,UAAJ,EAA7B;AACA,IAAI0F,sBAAsB,GAAG,IAAI1F,UAAJ,EAA7B;AACA,IAAI2F,aAAa,GAAG,IAAI3F,UAAJ,CAAe,GAAf,EAAoB,CAAC,GAArB,EAA0B,GAA1B,CAApB;AACA,IAAI4F,aAAa,GAAG,IAAI5F,UAAJ,CAAe,GAAf,EAAoB,GAApB,EAAyB,CAAC,GAA1B,CAApB;AACA,IAAI6F,aAAa,GAAG,IAAI7F,UAAJ,EAApB;AAEA;;;;;;;AAMAiB,kBAAkB,CAACwB,SAAnB,CAA6BqD,gBAA7B,GAAgD,UAAUC,UAAV,EAAsB;AACpE;AACA7F,EAAAA,KAAK,CAAC8F,OAAN,CAAc,YAAd,EAA4BD,UAA5B,EAFoE,CAGpE;;AACA,MAAIE,MAAM,GAAGF,UAAU,CAACE,MAAxB;AACA,MAAIC,uBAAuB,GAAGD,MAAM,CAACE,UAArC;AACA,MAAIC,0BAA0B,GAAGH,MAAM,CAACI,oBAAxC;AAEA,MAAIC,MAAM,GAAG,GAAb;;AACA,MAAI,CAAC1F,SAAS,CAAC2F,QAAV,CAAmB,KAAKlF,SAAxB,EAAmC+E,0BAAnC,CAAL,EAAqE;AACnE,QAAI3E,wBAAwB,GAAG,KAAKA,wBAApC;AACA,QAAIC,wBAAwB,GAAG,KAAKA,wBAApC;AACA,QAAIC,UAAU,GAAG,KAAKA,UAAtB;AACA,QAAIC,WAAW,GAAG,KAAKA,WAAvB;AACA,QAAIC,UAAU,GAAG,KAAKA,UAAtB;AACA,QAAIC,WAAW,GAAG,KAAKA,WAAvB;;AAEA,QAAIiE,UAAU,CAACS,IAAX,KAAoBxF,SAAS,CAACyF,OAAlC,EAA2C;AACzChF,MAAAA,wBAAwB,GAAGsE,UAAU,CAACW,aAAX,CAAyBC,OAAzB,CACzB/F,SAAS,CAAC6C,SAAV,CAAoB,KAAKpC,SAAzB,CADyB,EAEzBoE,sBAFyB,CAA3B;AAIAhE,MAAAA,wBAAwB,CAACmF,CAAzB,GAA6BnF,wBAAwB,CAACoF,CAAtD;AACApF,MAAAA,wBAAwB,CAACoF,CAAzB,GAA6BpF,wBAAwB,CAACqF,CAAtD;AACArF,MAAAA,wBAAwB,CAACqF,CAAzB,GAA6B,GAA7B;AACApF,MAAAA,wBAAwB,GAAGqE,UAAU,CAACW,aAAX,CAAyBC,OAAzB,CACzB/F,SAAS,CAAC8C,SAAV,CAAoB,KAAKrC,SAAzB,CADyB,EAEzBqE,sBAFyB,CAA3B;AAIAhE,MAAAA,wBAAwB,CAACkF,CAAzB,GAA6BlF,wBAAwB,CAACmF,CAAtD;AACAnF,MAAAA,wBAAwB,CAACmF,CAAzB,GAA6BnF,wBAAwB,CAACoF,CAAtD;AACApF,MAAAA,wBAAwB,CAACoF,CAAzB,GAA6B,GAA7B;AACAnF,MAAAA,UAAU,GAAGgE,aAAb;AACA9D,MAAAA,UAAU,GAAG7B,UAAU,CAAC+G,MAAxB;AACAnF,MAAAA,WAAW,GAAGgE,aAAd;AACA9D,MAAAA,WAAW,GAAG9B,UAAU,CAACmE,MAAzB;AACD;;AAED,QAAI6C,yBAAyB,GAAGhH,UAAU,CAACwE,QAAX,CAC9B0B,uBAD8B,EAE9BzE,wBAF8B,EAG9BoE,aAH8B,CAAhC;AAKA,QAAIoB,mBAAmB,GAAGjH,UAAU,CAACkH,GAAX,CACxBF,yBADwB,EAExBrF,UAFwB,CAA1B;AAIA,QAAIwF,oBAAoB,GAAGnH,UAAU,CAACkH,GAAX,CACzBF,yBADyB,EAEzBpF,WAFyB,CAA3B;AAKA,QAAIwF,yBAAyB,GAAGpH,UAAU,CAACwE,QAAX,CAC9B0B,uBAD8B,EAE9BxE,wBAF8B,EAG9BmE,aAH8B,CAAhC;AAKA,QAAIwB,mBAAmB,GAAGrH,UAAU,CAACkH,GAAX,CACxBE,yBADwB,EAExBvF,UAFwB,CAA1B;AAIA,QAAIyF,oBAAoB,GAAGtH,UAAU,CAACkH,GAAX,CACzBE,yBADyB,EAEzBtF,WAFyB,CAA3B;;AAKA,QAAImF,mBAAmB,GAAG,GAA1B,EAA+B;AAC7BX,MAAAA,MAAM,IAAIW,mBAAmB,GAAGA,mBAAhC;AACD,KAFD,MAEO,IAAII,mBAAmB,GAAG,GAA1B,EAA+B;AACpCf,MAAAA,MAAM,IAAIe,mBAAmB,GAAGA,mBAAhC;AACD;;AAED,QAAIF,oBAAoB,GAAG,GAA3B,EAAgC;AAC9Bb,MAAAA,MAAM,IAAIa,oBAAoB,GAAGA,oBAAjC;AACD,KAFD,MAEO,IAAIG,oBAAoB,GAAG,GAA3B,EAAgC;AACrChB,MAAAA,MAAM,IAAIgB,oBAAoB,GAAGA,oBAAjC;AACD;AACF;;AAED,MAAIC,YAAJ;AACA,MAAIhG,aAAJ;AACA,MAAIC,aAAJ;;AACA,MAAIuE,UAAU,CAACS,IAAX,KAAoBxF,SAAS,CAACyF,OAAlC,EAA2C;AACzCc,IAAAA,YAAY,GAAGnB,0BAA0B,CAACpC,MAA1C;AACAzC,IAAAA,aAAa,GAAG,KAAKA,aAArB;AACAC,IAAAA,aAAa,GAAG,KAAKA,aAArB;AACD,GAJD,MAIO;AACL+F,IAAAA,YAAY,GAAGrB,uBAAuB,CAACY,CAAvC;AACAvF,IAAAA,aAAa,GAAG,GAAhB;AACAC,IAAAA,aAAa,GAAG,GAAhB;AACD;;AAED,MAAI+F,YAAY,GAAG/F,aAAnB,EAAkC;AAChC,QAAIgG,gBAAgB,GAAGD,YAAY,GAAG/F,aAAtC;AACA8E,IAAAA,MAAM,IAAIkB,gBAAgB,GAAGA,gBAA7B;AACD,GAHD,MAGO,IAAID,YAAY,GAAGhG,aAAnB,EAAkC;AACvC,QAAIkG,mBAAmB,GAAGlG,aAAa,GAAGgG,YAA1C;AACAjB,IAAAA,MAAM,IAAImB,mBAAmB,GAAGA,mBAAhC;AACD;;AAED,SAAOC,IAAI,CAACC,IAAL,CAAUrB,MAAV,CAAP;AACD,CArGD;AAuGA;;;;;;;;;;;AASArF,kBAAkB,CAACwB,SAAnB,CAA6BmF,cAA7B,GAA8C,UAAUC,KAAV,EAAiB;AAC7D;AACA3H,EAAAA,KAAK,CAAC8F,OAAN,CAAc,OAAd,EAAuB6B,KAAvB,EAF6D,CAG7D;;AACA,SAAO,KAAK1F,oBAAL,CAA0ByF,cAA1B,CAAyCC,KAAzC,CAAP;AACD,CALD;AAOA;;;;;;;;;;AAQA5G,kBAAkB,CAACwB,SAAnB,CAA6BqF,iBAA7B,GAAiD,UAAUC,KAAV,EAAiB;AAChE;AACA7H,EAAAA,KAAK,CAAC8F,OAAN,CAAc,OAAd,EAAuB+B,KAAvB,EAFgE,CAGhE;;AAEA,MAAIC,WAAW,GAAG,IAAIxH,OAAO,CAACc,KAAZ,CAAkBd,OAAO,CAACyH,QAA1B,CAAlB;AACA,MAAIC,QAAQ,GAAG,IAAIrH,wBAAJ,CAA6B;AAC1CQ,IAAAA,SAAS,EAAE,KAAKA,SAD0B;AAE1C2C,IAAAA,MAAM,EAAE,KAAKzC,aAF6B;AAG1C4G,IAAAA,cAAc,EAAE,KAAK3G;AAHqB,GAA7B,CAAf;AAKA,MAAI4G,QAAQ,GAAG,IAAI9H,gBAAJ,CAAqB;AAClC4H,IAAAA,QAAQ,EAAEA,QADwB;AAElCG,IAAAA,EAAE,EAAE,SAF8B;AAGlCL,IAAAA,WAAW,EAAEA,WAHqB;AAIlCM,IAAAA,UAAU,EAAE;AACVP,MAAAA,KAAK,EAAE5H,8BAA8B,CAACoI,SAA/B,CAAyCR,KAAzC;AADG;AAJsB,GAArB,CAAf;AASA,SAAO,IAAIhH,SAAJ,CAAc;AACnByH,IAAAA,iBAAiB,EAAEJ,QADA;AAEnBK,IAAAA,UAAU,EAAE,IAAI3H,0BAAJ,CAA+B;AACzC4H,MAAAA,WAAW,EAAE,KAD4B;AAEzCC,MAAAA,IAAI,EAAE;AAFmC,KAA/B,CAFO;AAMnBC,IAAAA,YAAY,EAAE;AANK,GAAd,CAAP;AAQD,CA5BD;;AA6BA,eAAe3H,kBAAf","sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Plane from \"../Core/Plane.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport RectangleOutlineGeometry from \"../Core/RectangleOutlineGeometry.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * A tile bounding volume specified as a longitude/latitude/height region.\n * @alias TileBoundingRegion\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Rectangle} options.rectangle The rectangle specifying the longitude and latitude range of the region.\n * @param {Number} [options.minimumHeight=0.0] The minimum height of the region.\n * @param {Number} [options.maximumHeight=0.0] The maximum height of the region.\n * @param {Ellipsoid} [options.ellipsoid=Cesium.Ellipsoid.WGS84] The ellipsoid.\n * @param {Boolean} [options.computeBoundingVolumes=true] True to compute the {@link TileBoundingRegion#boundingVolume} and\n *                  {@link TileBoundingVolume#boundingSphere}. If false, these properties will be undefined.\n *\n * @private\n */\nfunction TileBoundingRegion(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.rectangle\", options.rectangle);\n  //>>includeEnd('debug');\n\n  this.rectangle = Rectangle.clone(options.rectangle);\n  this.minimumHeight = defaultValue(options.minimumHeight, 0.0);\n  this.maximumHeight = defaultValue(options.maximumHeight, 0.0);\n\n  /**\n   * The world coordinates of the southwest corner of the tile's rectangle.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n  this.southwestCornerCartesian = new Cartesian3();\n\n  /**\n   * The world coordinates of the northeast corner of the tile's rectangle.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n  this.northeastCornerCartesian = new Cartesian3();\n\n  /**\n   * A normal that, along with southwestCornerCartesian, defines a plane at the western edge of\n   * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n  this.westNormal = new Cartesian3();\n\n  /**\n   * A normal that, along with southwestCornerCartesian, defines a plane at the southern edge of\n   * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.\n   * Because points of constant latitude do not necessary lie in a plane, positions below this\n   * plane are not necessarily inside the tile, but they are close.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n  this.southNormal = new Cartesian3();\n\n  /**\n   * A normal that, along with northeastCornerCartesian, defines a plane at the eastern edge of\n   * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n  this.eastNormal = new Cartesian3();\n\n  /**\n   * A normal that, along with northeastCornerCartesian, defines a plane at the eastern edge of\n   * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.\n   * Because points of constant latitude do not necessary lie in a plane, positions below this\n   * plane are not necessarily inside the tile, but they are close.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n  this.northNormal = new Cartesian3();\n\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  computeBox(this, options.rectangle, ellipsoid);\n\n  if (defaultValue(options.computeBoundingVolumes, true)) {\n    // An oriented bounding box that encloses this tile's region.  This is used to calculate tile visibility.\n    this._orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n      this.rectangle,\n      this.minimumHeight,\n      this.maximumHeight,\n      ellipsoid\n    );\n\n    this._boundingSphere = BoundingSphere.fromOrientedBoundingBox(\n      this._orientedBoundingBox\n    );\n  }\n}\n\nObject.defineProperties(TileBoundingRegion.prototype, {\n  /**\n   * The underlying bounding volume\n   *\n   * @memberof TileBoundingRegion.prototype\n   *\n   * @type {Object}\n   * @readonly\n   */\n  boundingVolume: {\n    get: function () {\n      return this._orientedBoundingBox;\n    },\n  },\n  /**\n   * The underlying bounding sphere\n   *\n   * @memberof TileBoundingRegion.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    },\n  },\n});\n\nvar cartesian3Scratch = new Cartesian3();\nvar cartesian3Scratch2 = new Cartesian3();\nvar cartesian3Scratch3 = new Cartesian3();\nvar eastWestNormalScratch = new Cartesian3();\nvar westernMidpointScratch = new Cartesian3();\nvar easternMidpointScratch = new Cartesian3();\nvar cartographicScratch = new Cartographic();\nvar planeScratch = new Plane(Cartesian3.UNIT_X, 0.0);\nvar rayScratch = new Ray();\n\nfunction computeBox(tileBB, rectangle, ellipsoid) {\n  ellipsoid.cartographicToCartesian(\n    Rectangle.southwest(rectangle),\n    tileBB.southwestCornerCartesian\n  );\n  ellipsoid.cartographicToCartesian(\n    Rectangle.northeast(rectangle),\n    tileBB.northeastCornerCartesian\n  );\n\n  // The middle latitude on the western edge.\n  cartographicScratch.longitude = rectangle.west;\n  cartographicScratch.latitude = (rectangle.south + rectangle.north) * 0.5;\n  cartographicScratch.height = 0.0;\n  var westernMidpointCartesian = ellipsoid.cartographicToCartesian(\n    cartographicScratch,\n    westernMidpointScratch\n  );\n\n  // Compute the normal of the plane on the western edge of the tile.\n  var westNormal = Cartesian3.cross(\n    westernMidpointCartesian,\n    Cartesian3.UNIT_Z,\n    cartesian3Scratch\n  );\n  Cartesian3.normalize(westNormal, tileBB.westNormal);\n\n  // The middle latitude on the eastern edge.\n  cartographicScratch.longitude = rectangle.east;\n  var easternMidpointCartesian = ellipsoid.cartographicToCartesian(\n    cartographicScratch,\n    easternMidpointScratch\n  );\n\n  // Compute the normal of the plane on the eastern edge of the tile.\n  var eastNormal = Cartesian3.cross(\n    Cartesian3.UNIT_Z,\n    easternMidpointCartesian,\n    cartesian3Scratch\n  );\n  Cartesian3.normalize(eastNormal, tileBB.eastNormal);\n\n  // Compute the normal of the plane bounding the southern edge of the tile.\n  var westVector = Cartesian3.subtract(\n    westernMidpointCartesian,\n    easternMidpointCartesian,\n    cartesian3Scratch\n  );\n  var eastWestNormal = Cartesian3.normalize(westVector, eastWestNormalScratch);\n\n  var south = rectangle.south;\n  var southSurfaceNormal;\n\n  if (south > 0.0) {\n    // Compute a plane that doesn't cut through the tile.\n    cartographicScratch.longitude = (rectangle.west + rectangle.east) * 0.5;\n    cartographicScratch.latitude = south;\n    var southCenterCartesian = ellipsoid.cartographicToCartesian(\n      cartographicScratch,\n      rayScratch.origin\n    );\n    Cartesian3.clone(eastWestNormal, rayScratch.direction);\n    var westPlane = Plane.fromPointNormal(\n      tileBB.southwestCornerCartesian,\n      tileBB.westNormal,\n      planeScratch\n    );\n    // Find a point that is on the west and the south planes\n    IntersectionTests.rayPlane(\n      rayScratch,\n      westPlane,\n      tileBB.southwestCornerCartesian\n    );\n    southSurfaceNormal = ellipsoid.geodeticSurfaceNormal(\n      southCenterCartesian,\n      cartesian3Scratch2\n    );\n  } else {\n    southSurfaceNormal = ellipsoid.geodeticSurfaceNormalCartographic(\n      Rectangle.southeast(rectangle),\n      cartesian3Scratch2\n    );\n  }\n  var southNormal = Cartesian3.cross(\n    southSurfaceNormal,\n    westVector,\n    cartesian3Scratch3\n  );\n  Cartesian3.normalize(southNormal, tileBB.southNormal);\n\n  // Compute the normal of the plane bounding the northern edge of the tile.\n  var north = rectangle.north;\n  var northSurfaceNormal;\n  if (north < 0.0) {\n    // Compute a plane that doesn't cut through the tile.\n    cartographicScratch.longitude = (rectangle.west + rectangle.east) * 0.5;\n    cartographicScratch.latitude = north;\n    var northCenterCartesian = ellipsoid.cartographicToCartesian(\n      cartographicScratch,\n      rayScratch.origin\n    );\n    Cartesian3.negate(eastWestNormal, rayScratch.direction);\n    var eastPlane = Plane.fromPointNormal(\n      tileBB.northeastCornerCartesian,\n      tileBB.eastNormal,\n      planeScratch\n    );\n    // Find a point that is on the east and the north planes\n    IntersectionTests.rayPlane(\n      rayScratch,\n      eastPlane,\n      tileBB.northeastCornerCartesian\n    );\n    northSurfaceNormal = ellipsoid.geodeticSurfaceNormal(\n      northCenterCartesian,\n      cartesian3Scratch2\n    );\n  } else {\n    northSurfaceNormal = ellipsoid.geodeticSurfaceNormalCartographic(\n      Rectangle.northwest(rectangle),\n      cartesian3Scratch2\n    );\n  }\n  var northNormal = Cartesian3.cross(\n    westVector,\n    northSurfaceNormal,\n    cartesian3Scratch3\n  );\n  Cartesian3.normalize(northNormal, tileBB.northNormal);\n}\n\nvar southwestCornerScratch = new Cartesian3();\nvar northeastCornerScratch = new Cartesian3();\nvar negativeUnitY = new Cartesian3(0.0, -1.0, 0.0);\nvar negativeUnitZ = new Cartesian3(0.0, 0.0, -1.0);\nvar vectorScratch = new Cartesian3();\n\n/**\n * Gets the distance from the camera to the closest point on the tile.  This is used for level of detail selection.\n *\n * @param {FrameState} frameState The state information of the current rendering frame.\n * @returns {Number} The distance from the camera to the closest point on the tile, in meters.\n */\nTileBoundingRegion.prototype.distanceToCamera = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"frameState\", frameState);\n  //>>includeEnd('debug');\n  var camera = frameState.camera;\n  var cameraCartesianPosition = camera.positionWC;\n  var cameraCartographicPosition = camera.positionCartographic;\n\n  var result = 0.0;\n  if (!Rectangle.contains(this.rectangle, cameraCartographicPosition)) {\n    var southwestCornerCartesian = this.southwestCornerCartesian;\n    var northeastCornerCartesian = this.northeastCornerCartesian;\n    var westNormal = this.westNormal;\n    var southNormal = this.southNormal;\n    var eastNormal = this.eastNormal;\n    var northNormal = this.northNormal;\n\n    if (frameState.mode !== SceneMode.SCENE3D) {\n      southwestCornerCartesian = frameState.mapProjection.project(\n        Rectangle.southwest(this.rectangle),\n        southwestCornerScratch\n      );\n      southwestCornerCartesian.z = southwestCornerCartesian.y;\n      southwestCornerCartesian.y = southwestCornerCartesian.x;\n      southwestCornerCartesian.x = 0.0;\n      northeastCornerCartesian = frameState.mapProjection.project(\n        Rectangle.northeast(this.rectangle),\n        northeastCornerScratch\n      );\n      northeastCornerCartesian.z = northeastCornerCartesian.y;\n      northeastCornerCartesian.y = northeastCornerCartesian.x;\n      northeastCornerCartesian.x = 0.0;\n      westNormal = negativeUnitY;\n      eastNormal = Cartesian3.UNIT_Y;\n      southNormal = negativeUnitZ;\n      northNormal = Cartesian3.UNIT_Z;\n    }\n\n    var vectorFromSouthwestCorner = Cartesian3.subtract(\n      cameraCartesianPosition,\n      southwestCornerCartesian,\n      vectorScratch\n    );\n    var distanceToWestPlane = Cartesian3.dot(\n      vectorFromSouthwestCorner,\n      westNormal\n    );\n    var distanceToSouthPlane = Cartesian3.dot(\n      vectorFromSouthwestCorner,\n      southNormal\n    );\n\n    var vectorFromNortheastCorner = Cartesian3.subtract(\n      cameraCartesianPosition,\n      northeastCornerCartesian,\n      vectorScratch\n    );\n    var distanceToEastPlane = Cartesian3.dot(\n      vectorFromNortheastCorner,\n      eastNormal\n    );\n    var distanceToNorthPlane = Cartesian3.dot(\n      vectorFromNortheastCorner,\n      northNormal\n    );\n\n    if (distanceToWestPlane > 0.0) {\n      result += distanceToWestPlane * distanceToWestPlane;\n    } else if (distanceToEastPlane > 0.0) {\n      result += distanceToEastPlane * distanceToEastPlane;\n    }\n\n    if (distanceToSouthPlane > 0.0) {\n      result += distanceToSouthPlane * distanceToSouthPlane;\n    } else if (distanceToNorthPlane > 0.0) {\n      result += distanceToNorthPlane * distanceToNorthPlane;\n    }\n  }\n\n  var cameraHeight;\n  var minimumHeight;\n  var maximumHeight;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    cameraHeight = cameraCartographicPosition.height;\n    minimumHeight = this.minimumHeight;\n    maximumHeight = this.maximumHeight;\n  } else {\n    cameraHeight = cameraCartesianPosition.x;\n    minimumHeight = 0.0;\n    maximumHeight = 0.0;\n  }\n\n  if (cameraHeight > maximumHeight) {\n    var distanceAboveTop = cameraHeight - maximumHeight;\n    result += distanceAboveTop * distanceAboveTop;\n  } else if (cameraHeight < minimumHeight) {\n    var distanceBelowBottom = minimumHeight - cameraHeight;\n    result += distanceBelowBottom * distanceBelowBottom;\n  }\n\n  return Math.sqrt(result);\n};\n\n/**\n * Determines which side of a plane this box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nTileBoundingRegion.prototype.intersectPlane = function (plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"plane\", plane);\n  //>>includeEnd('debug');\n  return this._orientedBoundingBox.intersectPlane(plane);\n};\n\n/**\n * Creates a debug primitive that shows the outline of the tile bounding region.\n *\n * @param {Color} color The desired color of the primitive's mesh\n * @return {Primitive}\n *\n * @private\n */\nTileBoundingRegion.prototype.createDebugVolume = function (color) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"color\", color);\n  //>>includeEnd('debug');\n\n  var modelMatrix = new Matrix4.clone(Matrix4.IDENTITY);\n  var geometry = new RectangleOutlineGeometry({\n    rectangle: this.rectangle,\n    height: this.minimumHeight,\n    extrudedHeight: this.maximumHeight,\n  });\n  var instance = new GeometryInstance({\n    geometry: geometry,\n    id: \"outline\",\n    modelMatrix: modelMatrix,\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color),\n    },\n  });\n\n  return new Primitive({\n    geometryInstances: instance,\n    appearance: new PerInstanceColorAppearance({\n      translucent: false,\n      flat: true,\n    }),\n    asynchronous: false,\n  });\n};\nexport default TileBoundingRegion;\n"]},"metadata":{},"sourceType":"module"}