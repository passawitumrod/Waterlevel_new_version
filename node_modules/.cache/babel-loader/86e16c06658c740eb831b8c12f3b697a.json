{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport CullingVolume from \"./CullingVolume.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\n/**\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias PerspectiveOffCenterFrustum\n * @constructor\n *\n * @param {Object} [options] An object with the following properties:\n * @param {Number} [options.left] The left clipping plane distance.\n * @param {Number} [options.right] The right clipping plane distance.\n * @param {Number} [options.top] The top clipping plane distance.\n * @param {Number} [options.bottom] The bottom clipping plane distance.\n * @param {Number} [options.near=1.0] The near clipping plane distance.\n * @param {Number} [options.far=500000000.0] The far clipping plane distance.\n *\n * @example\n * var frustum = new Cesium.PerspectiveOffCenterFrustum({\n *     left : -1.0,\n *     right : 1.0,\n *     top : 1.0,\n *     bottom : -1.0,\n *     near : 1.0,\n *     far : 100.0\n * });\n *\n * @see PerspectiveFrustum\n */\n\nfunction PerspectiveOffCenterFrustum(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  /**\n   * Defines the left clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n\n  this.left = options.left;\n  this._left = undefined;\n  /**\n   * Defines the right clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n\n  this.right = options.right;\n  this._right = undefined;\n  /**\n   * Defines the top clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n\n  this.top = options.top;\n  this._top = undefined;\n  /**\n   * Defines the bottom clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n\n  this.bottom = options.bottom;\n  this._bottom = undefined;\n  /**\n   * The distance of the near plane.\n   * @type {Number}\n   * @default 1.0\n   */\n\n  this.near = defaultValue(options.near, 1.0);\n  this._near = this.near;\n  /**\n   * The distance of the far plane.\n   * @type {Number}\n   * @default 500000000.0\n   */\n\n  this.far = defaultValue(options.far, 500000000.0);\n  this._far = this.far;\n  this._cullingVolume = new CullingVolume();\n  this._perspectiveMatrix = new Matrix4();\n  this._infinitePerspective = new Matrix4();\n}\n\nfunction update(frustum) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(frustum.right) || !defined(frustum.left) || !defined(frustum.top) || !defined(frustum.bottom) || !defined(frustum.near) || !defined(frustum.far)) {\n    throw new DeveloperError(\"right, left, top, bottom, near, or far parameters are not set.\");\n  } //>>includeEnd('debug');\n\n\n  var t = frustum.top;\n  var b = frustum.bottom;\n  var r = frustum.right;\n  var l = frustum.left;\n  var n = frustum.near;\n  var f = frustum.far;\n\n  if (t !== frustum._top || b !== frustum._bottom || l !== frustum._left || r !== frustum._right || n !== frustum._near || f !== frustum._far) {\n    //>>includeStart('debug', pragmas.debug);\n    if (frustum.near <= 0 || frustum.near > frustum.far) {\n      throw new DeveloperError(\"near must be greater than zero and less than far.\");\n    } //>>includeEnd('debug');\n\n\n    frustum._left = l;\n    frustum._right = r;\n    frustum._top = t;\n    frustum._bottom = b;\n    frustum._near = n;\n    frustum._far = f;\n    frustum._perspectiveMatrix = Matrix4.computePerspectiveOffCenter(l, r, b, t, n, f, frustum._perspectiveMatrix);\n    frustum._infinitePerspective = Matrix4.computeInfinitePerspectiveOffCenter(l, r, b, t, n, frustum._infinitePerspective);\n  }\n}\n\nObject.defineProperties(PerspectiveOffCenterFrustum.prototype, {\n  /**\n   * Gets the perspective projection matrix computed from the view frustum.\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveOffCenterFrustum#infiniteProjectionMatrix\n   */\n  projectionMatrix: {\n    get: function () {\n      update(this);\n      return this._perspectiveMatrix;\n    }\n  },\n\n  /**\n   * Gets the perspective projection matrix computed from the view frustum with an infinite far plane.\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveOffCenterFrustum#projectionMatrix\n   */\n  infiniteProjectionMatrix: {\n    get: function () {\n      update(this);\n      return this._infinitePerspective;\n    }\n  }\n});\nvar getPlanesRight = new Cartesian3();\nvar getPlanesNearCenter = new Cartesian3();\nvar getPlanesFarCenter = new Cartesian3();\nvar getPlanesNormal = new Cartesian3();\n/**\n * Creates a culling volume for this frustum.\n *\n * @param {Cartesian3} position The eye position.\n * @param {Cartesian3} direction The view direction.\n * @param {Cartesian3} up The up direction.\n * @returns {CullingVolume} A culling volume at the given position and orientation.\n *\n * @example\n * // Check if a bounding volume intersects the frustum.\n * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * var intersect = cullingVolume.computeVisibility(boundingVolume);\n */\n\nPerspectiveOffCenterFrustum.prototype.computeCullingVolume = function (position, direction, up) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  }\n\n  if (!defined(up)) {\n    throw new DeveloperError(\"up is required.\");\n  } //>>includeEnd('debug');\n\n\n  var planes = this._cullingVolume.planes;\n  var t = this.top;\n  var b = this.bottom;\n  var r = this.right;\n  var l = this.left;\n  var n = this.near;\n  var f = this.far;\n  var right = Cartesian3.cross(direction, up, getPlanesRight);\n  var nearCenter = getPlanesNearCenter;\n  Cartesian3.multiplyByScalar(direction, n, nearCenter);\n  Cartesian3.add(position, nearCenter, nearCenter);\n  var farCenter = getPlanesFarCenter;\n  Cartesian3.multiplyByScalar(direction, f, farCenter);\n  Cartesian3.add(position, farCenter, farCenter);\n  var normal = getPlanesNormal; //Left plane computation\n\n  Cartesian3.multiplyByScalar(right, l, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.normalize(normal, normal);\n  Cartesian3.cross(normal, up, normal);\n  Cartesian3.normalize(normal, normal);\n  var plane = planes[0];\n\n  if (!defined(plane)) {\n    plane = planes[0] = new Cartesian4();\n  }\n\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position); //Right plane computation\n\n  Cartesian3.multiplyByScalar(right, r, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.cross(up, normal, normal);\n  Cartesian3.normalize(normal, normal);\n  plane = planes[1];\n\n  if (!defined(plane)) {\n    plane = planes[1] = new Cartesian4();\n  }\n\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position); //Bottom plane computation\n\n  Cartesian3.multiplyByScalar(up, b, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.cross(right, normal, normal);\n  Cartesian3.normalize(normal, normal);\n  plane = planes[2];\n\n  if (!defined(plane)) {\n    plane = planes[2] = new Cartesian4();\n  }\n\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position); //Top plane computation\n\n  Cartesian3.multiplyByScalar(up, t, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.cross(normal, right, normal);\n  Cartesian3.normalize(normal, normal);\n  plane = planes[3];\n\n  if (!defined(plane)) {\n    plane = planes[3] = new Cartesian4();\n  }\n\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position); //Near plane computation\n\n  plane = planes[4];\n\n  if (!defined(plane)) {\n    plane = planes[4] = new Cartesian4();\n  }\n\n  plane.x = direction.x;\n  plane.y = direction.y;\n  plane.z = direction.z;\n  plane.w = -Cartesian3.dot(direction, nearCenter); //Far plane computation\n\n  Cartesian3.negate(direction, normal);\n  plane = planes[5];\n\n  if (!defined(plane)) {\n    plane = planes[5] = new Cartesian4();\n  }\n\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, farCenter);\n  return this._cullingVolume;\n};\n/**\n * Returns the pixel's width and height in meters.\n *\n * @param {Number} drawingBufferWidth The width of the drawing buffer.\n * @param {Number} drawingBufferHeight The height of the drawing buffer.\n * @param {Number} distance The distance to the near plane in meters.\n * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\n *\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n * @exception {DeveloperError} pixelRatio must be greater than zero.\n *\n * @example\n * // Example 1\n * // Get the width and height of a pixel.\n * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new Cesium.Cartesian2());\n *\n * @example\n * // Example 2\n * // Get the width and height of a pixel if the near plane was set to 'distance'.\n * // For example, get the size of a pixel of an image on a billboard.\n * var position = camera.position;\n * var direction = camera.direction;\n * var toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive\n * var toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector\n * var distance = Cesium.Cartesian3.magnitude(toCenterProj);\n * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, scene.pixelRatio, new Cesium.Cartesian2());\n */\n\n\nPerspectiveOffCenterFrustum.prototype.getPixelDimensions = function (drawingBufferWidth, drawingBufferHeight, distance, pixelRatio, result) {\n  update(this); //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(drawingBufferWidth) || !defined(drawingBufferHeight)) {\n    throw new DeveloperError(\"Both drawingBufferWidth and drawingBufferHeight are required.\");\n  }\n\n  if (drawingBufferWidth <= 0) {\n    throw new DeveloperError(\"drawingBufferWidth must be greater than zero.\");\n  }\n\n  if (drawingBufferHeight <= 0) {\n    throw new DeveloperError(\"drawingBufferHeight must be greater than zero.\");\n  }\n\n  if (!defined(distance)) {\n    throw new DeveloperError(\"distance is required.\");\n  }\n\n  if (!defined(pixelRatio)) {\n    throw new DeveloperError(\"pixelRatio is required\");\n  }\n\n  if (pixelRatio <= 0) {\n    throw new DeveloperError(\"pixelRatio must be greater than zero.\");\n  }\n\n  if (!defined(result)) {\n    throw new DeveloperError(\"A result object is required.\");\n  } //>>includeEnd('debug');\n\n\n  var inverseNear = 1.0 / this.near;\n  var tanTheta = this.top * inverseNear;\n  var pixelHeight = 2.0 * pixelRatio * distance * tanTheta / drawingBufferHeight;\n  tanTheta = this.right * inverseNear;\n  var pixelWidth = 2.0 * pixelRatio * distance * tanTheta / drawingBufferWidth;\n  result.x = pixelWidth;\n  result.y = pixelHeight;\n  return result;\n};\n/**\n * Returns a duplicate of a PerspectiveOffCenterFrustum instance.\n *\n * @param {PerspectiveOffCenterFrustum} [result] The object onto which to store the result.\n * @returns {PerspectiveOffCenterFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\n */\n\n\nPerspectiveOffCenterFrustum.prototype.clone = function (result) {\n  if (!defined(result)) {\n    result = new PerspectiveOffCenterFrustum();\n  }\n\n  result.right = this.right;\n  result.left = this.left;\n  result.top = this.top;\n  result.bottom = this.bottom;\n  result.near = this.near;\n  result.far = this.far; // force update of clone to compute matrices\n\n  result._left = undefined;\n  result._right = undefined;\n  result._top = undefined;\n  result._bottom = undefined;\n  result._near = undefined;\n  result._far = undefined;\n  return result;\n};\n/**\n * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {PerspectiveOffCenterFrustum} [other] The right hand side PerspectiveOffCenterFrustum.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\n\n\nPerspectiveOffCenterFrustum.prototype.equals = function (other) {\n  return defined(other) && other instanceof PerspectiveOffCenterFrustum && this.right === other.right && this.left === other.left && this.top === other.top && this.bottom === other.bottom && this.near === other.near && this.far === other.far;\n};\n/**\n * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {PerspectiveOffCenterFrustum} other The right hand side PerspectiveOffCenterFrustum.\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\n */\n\n\nPerspectiveOffCenterFrustum.prototype.equalsEpsilon = function (other, relativeEpsilon, absoluteEpsilon) {\n  return other === this || defined(other) && other instanceof PerspectiveOffCenterFrustum && CesiumMath.equalsEpsilon(this.right, other.right, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(this.left, other.left, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(this.top, other.top, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(this.bottom, other.bottom, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(this.near, other.near, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(this.far, other.far, relativeEpsilon, absoluteEpsilon);\n};\n\nexport default PerspectiveOffCenterFrustum;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/PerspectiveOffCenterFrustum.js"],"names":["Cartesian3","Cartesian4","CullingVolume","defaultValue","defined","DeveloperError","CesiumMath","Matrix4","PerspectiveOffCenterFrustum","options","EMPTY_OBJECT","left","_left","undefined","right","_right","top","_top","bottom","_bottom","near","_near","far","_far","_cullingVolume","_perspectiveMatrix","_infinitePerspective","update","frustum","t","b","r","l","n","f","computePerspectiveOffCenter","computeInfinitePerspectiveOffCenter","Object","defineProperties","prototype","projectionMatrix","get","infiniteProjectionMatrix","getPlanesRight","getPlanesNearCenter","getPlanesFarCenter","getPlanesNormal","computeCullingVolume","position","direction","up","planes","cross","nearCenter","multiplyByScalar","add","farCenter","normal","subtract","normalize","plane","x","y","z","w","dot","negate","getPixelDimensions","drawingBufferWidth","drawingBufferHeight","distance","pixelRatio","result","inverseNear","tanTheta","pixelHeight","pixelWidth","clone","equals","other","equalsEpsilon","relativeEpsilon","absoluteEpsilon"],"mappings":"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","sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport CullingVolume from \"./CullingVolume.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\n\n/**\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias PerspectiveOffCenterFrustum\n * @constructor\n *\n * @param {Object} [options] An object with the following properties:\n * @param {Number} [options.left] The left clipping plane distance.\n * @param {Number} [options.right] The right clipping plane distance.\n * @param {Number} [options.top] The top clipping plane distance.\n * @param {Number} [options.bottom] The bottom clipping plane distance.\n * @param {Number} [options.near=1.0] The near clipping plane distance.\n * @param {Number} [options.far=500000000.0] The far clipping plane distance.\n *\n * @example\n * var frustum = new Cesium.PerspectiveOffCenterFrustum({\n *     left : -1.0,\n *     right : 1.0,\n *     top : 1.0,\n *     bottom : -1.0,\n *     near : 1.0,\n *     far : 100.0\n * });\n *\n * @see PerspectiveFrustum\n */\nfunction PerspectiveOffCenterFrustum(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * Defines the left clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.left = options.left;\n  this._left = undefined;\n\n  /**\n   * Defines the right clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.right = options.right;\n  this._right = undefined;\n\n  /**\n   * Defines the top clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.top = options.top;\n  this._top = undefined;\n\n  /**\n   * Defines the bottom clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.bottom = options.bottom;\n  this._bottom = undefined;\n\n  /**\n   * The distance of the near plane.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.near = defaultValue(options.near, 1.0);\n  this._near = this.near;\n\n  /**\n   * The distance of the far plane.\n   * @type {Number}\n   * @default 500000000.0\n   */\n  this.far = defaultValue(options.far, 500000000.0);\n  this._far = this.far;\n\n  this._cullingVolume = new CullingVolume();\n  this._perspectiveMatrix = new Matrix4();\n  this._infinitePerspective = new Matrix4();\n}\n\nfunction update(frustum) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(frustum.right) ||\n    !defined(frustum.left) ||\n    !defined(frustum.top) ||\n    !defined(frustum.bottom) ||\n    !defined(frustum.near) ||\n    !defined(frustum.far)\n  ) {\n    throw new DeveloperError(\n      \"right, left, top, bottom, near, or far parameters are not set.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var t = frustum.top;\n  var b = frustum.bottom;\n  var r = frustum.right;\n  var l = frustum.left;\n  var n = frustum.near;\n  var f = frustum.far;\n\n  if (\n    t !== frustum._top ||\n    b !== frustum._bottom ||\n    l !== frustum._left ||\n    r !== frustum._right ||\n    n !== frustum._near ||\n    f !== frustum._far\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    if (frustum.near <= 0 || frustum.near > frustum.far) {\n      throw new DeveloperError(\n        \"near must be greater than zero and less than far.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    frustum._left = l;\n    frustum._right = r;\n    frustum._top = t;\n    frustum._bottom = b;\n    frustum._near = n;\n    frustum._far = f;\n    frustum._perspectiveMatrix = Matrix4.computePerspectiveOffCenter(\n      l,\n      r,\n      b,\n      t,\n      n,\n      f,\n      frustum._perspectiveMatrix\n    );\n    frustum._infinitePerspective = Matrix4.computeInfinitePerspectiveOffCenter(\n      l,\n      r,\n      b,\n      t,\n      n,\n      frustum._infinitePerspective\n    );\n  }\n}\n\nObject.defineProperties(PerspectiveOffCenterFrustum.prototype, {\n  /**\n   * Gets the perspective projection matrix computed from the view frustum.\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveOffCenterFrustum#infiniteProjectionMatrix\n   */\n  projectionMatrix: {\n    get: function () {\n      update(this);\n      return this._perspectiveMatrix;\n    },\n  },\n\n  /**\n   * Gets the perspective projection matrix computed from the view frustum with an infinite far plane.\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveOffCenterFrustum#projectionMatrix\n   */\n  infiniteProjectionMatrix: {\n    get: function () {\n      update(this);\n      return this._infinitePerspective;\n    },\n  },\n});\n\nvar getPlanesRight = new Cartesian3();\nvar getPlanesNearCenter = new Cartesian3();\nvar getPlanesFarCenter = new Cartesian3();\nvar getPlanesNormal = new Cartesian3();\n/**\n * Creates a culling volume for this frustum.\n *\n * @param {Cartesian3} position The eye position.\n * @param {Cartesian3} direction The view direction.\n * @param {Cartesian3} up The up direction.\n * @returns {CullingVolume} A culling volume at the given position and orientation.\n *\n * @example\n * // Check if a bounding volume intersects the frustum.\n * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * var intersect = cullingVolume.computeVisibility(boundingVolume);\n */\nPerspectiveOffCenterFrustum.prototype.computeCullingVolume = function (\n  position,\n  direction,\n  up\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  }\n\n  if (!defined(up)) {\n    throw new DeveloperError(\"up is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var planes = this._cullingVolume.planes;\n\n  var t = this.top;\n  var b = this.bottom;\n  var r = this.right;\n  var l = this.left;\n  var n = this.near;\n  var f = this.far;\n\n  var right = Cartesian3.cross(direction, up, getPlanesRight);\n\n  var nearCenter = getPlanesNearCenter;\n  Cartesian3.multiplyByScalar(direction, n, nearCenter);\n  Cartesian3.add(position, nearCenter, nearCenter);\n\n  var farCenter = getPlanesFarCenter;\n  Cartesian3.multiplyByScalar(direction, f, farCenter);\n  Cartesian3.add(position, farCenter, farCenter);\n\n  var normal = getPlanesNormal;\n\n  //Left plane computation\n  Cartesian3.multiplyByScalar(right, l, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.normalize(normal, normal);\n  Cartesian3.cross(normal, up, normal);\n  Cartesian3.normalize(normal, normal);\n\n  var plane = planes[0];\n  if (!defined(plane)) {\n    plane = planes[0] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position);\n\n  //Right plane computation\n  Cartesian3.multiplyByScalar(right, r, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.cross(up, normal, normal);\n  Cartesian3.normalize(normal, normal);\n\n  plane = planes[1];\n  if (!defined(plane)) {\n    plane = planes[1] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position);\n\n  //Bottom plane computation\n  Cartesian3.multiplyByScalar(up, b, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.cross(right, normal, normal);\n  Cartesian3.normalize(normal, normal);\n\n  plane = planes[2];\n  if (!defined(plane)) {\n    plane = planes[2] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position);\n\n  //Top plane computation\n  Cartesian3.multiplyByScalar(up, t, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.cross(normal, right, normal);\n  Cartesian3.normalize(normal, normal);\n\n  plane = planes[3];\n  if (!defined(plane)) {\n    plane = planes[3] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position);\n\n  //Near plane computation\n  plane = planes[4];\n  if (!defined(plane)) {\n    plane = planes[4] = new Cartesian4();\n  }\n  plane.x = direction.x;\n  plane.y = direction.y;\n  plane.z = direction.z;\n  plane.w = -Cartesian3.dot(direction, nearCenter);\n\n  //Far plane computation\n  Cartesian3.negate(direction, normal);\n\n  plane = planes[5];\n  if (!defined(plane)) {\n    plane = planes[5] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, farCenter);\n\n  return this._cullingVolume;\n};\n\n/**\n * Returns the pixel's width and height in meters.\n *\n * @param {Number} drawingBufferWidth The width of the drawing buffer.\n * @param {Number} drawingBufferHeight The height of the drawing buffer.\n * @param {Number} distance The distance to the near plane in meters.\n * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\n *\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n * @exception {DeveloperError} pixelRatio must be greater than zero.\n *\n * @example\n * // Example 1\n * // Get the width and height of a pixel.\n * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new Cesium.Cartesian2());\n *\n * @example\n * // Example 2\n * // Get the width and height of a pixel if the near plane was set to 'distance'.\n * // For example, get the size of a pixel of an image on a billboard.\n * var position = camera.position;\n * var direction = camera.direction;\n * var toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive\n * var toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector\n * var distance = Cesium.Cartesian3.magnitude(toCenterProj);\n * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, scene.pixelRatio, new Cesium.Cartesian2());\n */\nPerspectiveOffCenterFrustum.prototype.getPixelDimensions = function (\n  drawingBufferWidth,\n  drawingBufferHeight,\n  distance,\n  pixelRatio,\n  result\n) {\n  update(this);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(drawingBufferWidth) || !defined(drawingBufferHeight)) {\n    throw new DeveloperError(\n      \"Both drawingBufferWidth and drawingBufferHeight are required.\"\n    );\n  }\n  if (drawingBufferWidth <= 0) {\n    throw new DeveloperError(\"drawingBufferWidth must be greater than zero.\");\n  }\n  if (drawingBufferHeight <= 0) {\n    throw new DeveloperError(\"drawingBufferHeight must be greater than zero.\");\n  }\n  if (!defined(distance)) {\n    throw new DeveloperError(\"distance is required.\");\n  }\n  if (!defined(pixelRatio)) {\n    throw new DeveloperError(\"pixelRatio is required\");\n  }\n  if (pixelRatio <= 0) {\n    throw new DeveloperError(\"pixelRatio must be greater than zero.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"A result object is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var inverseNear = 1.0 / this.near;\n  var tanTheta = this.top * inverseNear;\n  var pixelHeight =\n    (2.0 * pixelRatio * distance * tanTheta) / drawingBufferHeight;\n  tanTheta = this.right * inverseNear;\n  var pixelWidth =\n    (2.0 * pixelRatio * distance * tanTheta) / drawingBufferWidth;\n\n  result.x = pixelWidth;\n  result.y = pixelHeight;\n  return result;\n};\n\n/**\n * Returns a duplicate of a PerspectiveOffCenterFrustum instance.\n *\n * @param {PerspectiveOffCenterFrustum} [result] The object onto which to store the result.\n * @returns {PerspectiveOffCenterFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\n */\nPerspectiveOffCenterFrustum.prototype.clone = function (result) {\n  if (!defined(result)) {\n    result = new PerspectiveOffCenterFrustum();\n  }\n\n  result.right = this.right;\n  result.left = this.left;\n  result.top = this.top;\n  result.bottom = this.bottom;\n  result.near = this.near;\n  result.far = this.far;\n\n  // force update of clone to compute matrices\n  result._left = undefined;\n  result._right = undefined;\n  result._top = undefined;\n  result._bottom = undefined;\n  result._near = undefined;\n  result._far = undefined;\n\n  return result;\n};\n\n/**\n * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {PerspectiveOffCenterFrustum} [other] The right hand side PerspectiveOffCenterFrustum.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nPerspectiveOffCenterFrustum.prototype.equals = function (other) {\n  return (\n    defined(other) &&\n    other instanceof PerspectiveOffCenterFrustum &&\n    this.right === other.right &&\n    this.left === other.left &&\n    this.top === other.top &&\n    this.bottom === other.bottom &&\n    this.near === other.near &&\n    this.far === other.far\n  );\n};\n\n/**\n * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {PerspectiveOffCenterFrustum} other The right hand side PerspectiveOffCenterFrustum.\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\n */\nPerspectiveOffCenterFrustum.prototype.equalsEpsilon = function (\n  other,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return (\n    other === this ||\n    (defined(other) &&\n      other instanceof PerspectiveOffCenterFrustum &&\n      CesiumMath.equalsEpsilon(\n        this.right,\n        other.right,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.left,\n        other.left,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.top,\n        other.top,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.bottom,\n        other.bottom,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.near,\n        other.near,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.far,\n        other.far,\n        relativeEpsilon,\n        absoluteEpsilon\n      ))\n  );\n};\nexport default PerspectiveOffCenterFrustum;\n"]},"metadata":{},"sourceType":"module"}