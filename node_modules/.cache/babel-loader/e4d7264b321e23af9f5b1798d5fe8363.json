{"ast":null,"code":"import defined from \"../Core/defined.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport ForEach from \"../ThirdParty/GltfPipeline/ForEach.js\";\n/**\n * Creates face outlines for glTF primitives with the `CESIUM_primitive_outline` extension.\n * @private\n */\n\nfunction ModelOutlineLoader() {}\n/**\n * Returns true if the model uses or requires CESIUM_primitive_outline.\n * @private\n */\n\n\nModelOutlineLoader.hasExtension = function (model) {\n  return defined(model.extensionsRequired.CESIUM_primitive_outline) || defined(model.extensionsUsed.CESIUM_primitive_outline);\n};\n/**\n * Arranges to outline any primitives with the CESIUM_primitive_outline extension.\n * It is expected that all buffer data is loaded and available in\n * `extras._pipeline.source` before this function is called, and that vertex\n * and index WebGL buffers are not yet created.\n * @private\n */\n\n\nModelOutlineLoader.outlinePrimitives = function (model) {\n  if (!ModelOutlineLoader.hasExtension(model)) {\n    return;\n  }\n\n  var gltf = model.gltf; // Assumption: A single bufferView contains a single zero-indexed range of vertices.\n  // No trickery with using large accessor byteOffsets to store multiple zero-based\n  // ranges of vertices in a single bufferView. Use separate bufferViews for that,\n  // you monster.\n  // Note that interleaved vertex attributes (e.g. position0, normal0, uv0,\n  // position1, normal1, uv1, ...) _are_ supported and should not be confused with\n  // the above.\n\n  var vertexNumberingScopes = [];\n  ForEach.mesh(gltf, function (mesh, meshId) {\n    ForEach.meshPrimitive(mesh, function (primitive, primitiveId) {\n      if (!defined(primitive.extensions)) {\n        return;\n      }\n\n      var outlineData = primitive.extensions.CESIUM_primitive_outline;\n\n      if (!defined(outlineData)) {\n        return;\n      }\n\n      var vertexNumberingScope = getVertexNumberingScope(model, primitive);\n\n      if (vertexNumberingScope === undefined) {\n        return;\n      }\n\n      if (vertexNumberingScopes.indexOf(vertexNumberingScope) < 0) {\n        vertexNumberingScopes.push(vertexNumberingScope);\n      } // Add the outline to this primitive\n\n\n      addOutline(model, meshId, primitiveId, outlineData.indices, vertexNumberingScope);\n    });\n  }); // Update all relevant bufferViews to include the duplicate vertices that are\n  // needed for outlining.\n\n  for (var i = 0; i < vertexNumberingScopes.length; ++i) {\n    updateBufferViewsWithNewVertices(model, vertexNumberingScopes[i].bufferViews);\n  } // Remove data not referenced by any bufferViews anymore.\n\n\n  compactBuffers(model);\n};\n\nModelOutlineLoader.createTexture = function (model, context) {\n  var cache = context.cache.modelOutliningCache;\n\n  if (!defined(cache)) {\n    cache = context.cache.modelOutliningCache = {};\n  }\n\n  if (defined(cache.outlineTexture)) {\n    return cache.outlineTexture;\n  }\n\n  var maxSize = Math.min(4096, ContextLimits.maximumTextureSize);\n  var size = maxSize;\n  var levelZero = createTexture(size);\n  var mipLevels = [];\n\n  while (size > 1) {\n    size >>= 1;\n    mipLevels.push(createTexture(size));\n  }\n\n  var texture = new Texture({\n    context: context,\n    source: {\n      arrayBufferView: levelZero,\n      mipLevels: mipLevels\n    },\n    width: maxSize,\n    height: 1,\n    pixelFormat: PixelFormat.LUMINANCE,\n    sampler: new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: TextureMinificationFilter.LINEAR_MIPMAP_LINEAR,\n      magnificationFilter: TextureMagnificationFilter.LINEAR\n    })\n  });\n  cache.outlineTexture = texture;\n  return texture;\n};\n\nfunction addOutline(model, meshId, primitiveId, edgeIndicesAccessorId, vertexNumberingScope) {\n  var vertexCopies = vertexNumberingScope.vertexCopies;\n  var extraVertices = vertexNumberingScope.extraVertices;\n  var outlineCoordinates = vertexNumberingScope.outlineCoordinates;\n  var gltf = model.gltf;\n  var mesh = gltf.meshes[meshId];\n  var primitive = mesh.primitives[primitiveId];\n  var accessors = gltf.accessors;\n  var bufferViews = gltf.bufferViews; // Find the number of vertices in this primitive by looking at\n  // the first attribute. Others are required to be the same.\n\n  var numVertices;\n\n  for (var semantic in primitive.attributes) {\n    if (primitive.attributes.hasOwnProperty(semantic)) {\n      var attributeId = primitive.attributes[semantic];\n      var accessor = accessors[attributeId];\n\n      if (defined(accessor)) {\n        numVertices = accessor.count;\n        break;\n      }\n    }\n  }\n\n  if (!defined(numVertices)) {\n    return undefined;\n  }\n\n  var triangleIndexAccessorGltf = accessors[primitive.indices];\n  var triangleIndexBufferViewGltf = bufferViews[triangleIndexAccessorGltf.bufferView];\n  var edgeIndexAccessorGltf = accessors[edgeIndicesAccessorId];\n  var edgeIndexBufferViewGltf = bufferViews[edgeIndexAccessorGltf.bufferView];\n  var loadResources = model._loadResources;\n  var triangleIndexBufferView = loadResources.getBuffer(triangleIndexBufferViewGltf);\n  var edgeIndexBufferView = loadResources.getBuffer(edgeIndexBufferViewGltf);\n  var triangleIndices = triangleIndexAccessorGltf.componentType === 5123 ? new Uint16Array(triangleIndexBufferView.buffer, triangleIndexBufferView.byteOffset + triangleIndexAccessorGltf.byteOffset, triangleIndexAccessorGltf.count) : new Uint32Array(triangleIndexBufferView.buffer, triangleIndexBufferView.byteOffset + triangleIndexAccessorGltf.byteOffset, triangleIndexAccessorGltf.count);\n  var edgeIndices = edgeIndexAccessorGltf.componentType === 5123 ? new Uint16Array(edgeIndexBufferView.buffer, edgeIndexBufferView.byteOffset + edgeIndexAccessorGltf.byteOffset, edgeIndexAccessorGltf.count) : new Uint32Array(edgeIndexBufferView.buffer, edgeIndexBufferView.byteOffset + edgeIndexAccessorGltf.byteOffset, edgeIndexAccessorGltf.count); // Make a hash table for quick lookups of whether an edge exists between two\n  // vertices. The hash is a sparse array indexed by\n  //   `smallerVertexIndex * totalNumberOfVertices + biggerVertexIndex`\n  // A value of 1 indicates an edge exists between the two vertex indices; any\n  // other value indicates that it does not. We store the\n  // `edgeSmallMultipler` - that is, the number of vertices in the equation\n  // above - at index 0 for easy access to it later.\n\n  var edgeSmallMultiplier = numVertices;\n  var edges = [edgeSmallMultiplier];\n  var i;\n\n  for (i = 0; i < edgeIndices.length; i += 2) {\n    var a = edgeIndices[i];\n    var b = edgeIndices[i + 1];\n    var small = Math.min(a, b);\n    var big = Math.max(a, b);\n    edges[small * edgeSmallMultiplier + big] = 1;\n  } // For each triangle, adjust vertex data so that the correct edges are outlined.\n\n\n  for (i = 0; i < triangleIndices.length; i += 3) {\n    var i0 = triangleIndices[i];\n    var i1 = triangleIndices[i + 1];\n    var i2 = triangleIndices[i + 2];\n    var all = false; // set this to true to draw a full wireframe.\n\n    var has01 = all || isHighlighted(edges, i0, i1);\n    var has12 = all || isHighlighted(edges, i1, i2);\n    var has20 = all || isHighlighted(edges, i2, i0);\n    var unmatchableVertexIndex = matchAndStoreCoordinates(outlineCoordinates, i0, i1, i2, has01, has12, has20);\n\n    while (unmatchableVertexIndex >= 0) {\n      // Copy the unmatchable index and try again.\n      var copy;\n\n      if (unmatchableVertexIndex === i0) {\n        copy = vertexCopies[i0];\n      } else if (unmatchableVertexIndex === i1) {\n        copy = vertexCopies[i1];\n      } else {\n        copy = vertexCopies[i2];\n      }\n\n      if (copy === undefined) {\n        copy = numVertices + extraVertices.length;\n        var original = unmatchableVertexIndex;\n\n        while (original >= numVertices) {\n          original = extraVertices[original - numVertices];\n        }\n\n        extraVertices.push(original);\n        vertexCopies[unmatchableVertexIndex] = copy;\n      }\n\n      if (copy >= 65536 && triangleIndices instanceof Uint16Array) {\n        // We outgrew a 16-bit index buffer, switch to 32-bit.\n        triangleIndices = new Uint32Array(triangleIndices);\n        triangleIndexAccessorGltf.componentType = 5125; // UNSIGNED_INT\n\n        triangleIndexBufferViewGltf.buffer = gltf.buffers.push({\n          byteLength: triangleIndices.byteLength,\n          extras: {\n            _pipeline: {\n              source: triangleIndices.buffer\n            }\n          }\n        }) - 1;\n        triangleIndexBufferViewGltf.byteLength = triangleIndices.byteLength;\n        triangleIndexBufferViewGltf.byteOffset = 0;\n        model._loadResources.buffers[triangleIndexBufferViewGltf.buffer] = new Uint8Array(triangleIndices.buffer, 0, triangleIndices.byteLength);\n      }\n\n      if (unmatchableVertexIndex === i0) {\n        i0 = copy;\n        triangleIndices[i] = copy;\n      } else if (unmatchableVertexIndex === i1) {\n        i1 = copy;\n        triangleIndices[i + 1] = copy;\n      } else {\n        i2 = copy;\n        triangleIndices[i + 2] = copy;\n      }\n\n      if (defined(triangleIndexAccessorGltf.max)) {\n        triangleIndexAccessorGltf.max[0] = Math.max(triangleIndexAccessorGltf.max[0], copy);\n      }\n\n      unmatchableVertexIndex = matchAndStoreCoordinates(outlineCoordinates, i0, i1, i2, has01, has12, has20);\n    }\n  }\n} // Each vertex has three coordinates, a, b, and c.\n// a is the coordinate that applies to edge 2-0 for the vertex.\n// b is the coordinate that applies to edge 0-1 for the vertex.\n// c is the coordinate that applies to edge 1-2 for the vertex.\n// A single triangle with all edges highlighted:\n//\n//                 | a | b | c |\n//                 | 1 | 1 | 0 |\n//                       0\n//                      / \\\n//                     /   \\\n//           edge 0-1 /     \\ edge 2-0\n//                   /       \\\n//                  /         \\\n// | a | b | c |   1-----------2   | a | b | c |\n// | 0 | 1 | 1 |     edge 1-2      | 1 | 0 | 1 |\n//\n// There are 6 possible orderings of coordinates a, b, and c:\n// 0 - abc\n// 1 - acb\n// 2 - bac\n// 3 - bca\n// 4 - cab\n// 5 - cba\n// All vertices must use the _same ordering_ for the edges to be rendered\n// correctly. So we compute a bitmask for each vertex, where the bit at\n// each position indicates whether that ordering works (i.e. doesn't\n// conflict with already-assigned coordinates) for that vertex.\n// Then we can find an ordering that works for all three vertices with a\n// bitwise AND.\n\n\nfunction computeOrderMask(outlineCoordinates, vertexIndex, a, b, c) {\n  var startIndex = vertexIndex * 3;\n  var first = outlineCoordinates[startIndex];\n  var second = outlineCoordinates[startIndex + 1];\n  var third = outlineCoordinates[startIndex + 2];\n\n  if (first === undefined) {\n    // If one coordinate is undefined, they all are, and all orderings are fine.\n    return 63; // 0b111111;\n  }\n\n  return ((first === a && second === b && third === c) << 0) + ((first === a && second === c && third === b) << 1) + ((first === b && second === a && third === c) << 2) + ((first === b && second === c && third === a) << 3) + ((first === c && second === a && third === b) << 4) + ((first === c && second === b && third === a) << 5);\n} // popcount for integers 0-63, inclusive.\n// i.e. how many 1s are in the binary representation of the integer.\n\n\nfunction popcount0to63(value) {\n  return (value & 1) + (value >> 1 & 1) + (value >> 2 & 1) + (value >> 3 & 1) + (value >> 4 & 1) + (value >> 5 & 1);\n}\n\nfunction matchAndStoreCoordinates(outlineCoordinates, i0, i1, i2, has01, has12, has20) {\n  var a0 = has20 ? 1.0 : 0.0;\n  var b0 = has01 ? 1.0 : 0.0;\n  var c0 = 0.0;\n  var i0Mask = computeOrderMask(outlineCoordinates, i0, a0, b0, c0);\n\n  if (i0Mask === 0) {\n    return i0;\n  }\n\n  var a1 = 0.0;\n  var b1 = has01 ? 1.0 : 0.0;\n  var c1 = has12 ? 1.0 : 0.0;\n  var i1Mask = computeOrderMask(outlineCoordinates, i1, a1, b1, c1);\n\n  if (i1Mask === 0) {\n    return i1;\n  }\n\n  var a2 = has20 ? 1.0 : 0.0;\n  var b2 = 0.0;\n  var c2 = has12 ? 1.0 : 0.0;\n  var i2Mask = computeOrderMask(outlineCoordinates, i2, a2, b2, c2);\n\n  if (i2Mask === 0) {\n    return i2;\n  }\n\n  var workingOrders = i0Mask & i1Mask & i2Mask;\n  var a, b, c;\n\n  if (workingOrders & 1 << 0) {\n    // 0 - abc\n    a = 0;\n    b = 1;\n    c = 2;\n  } else if (workingOrders & 1 << 1) {\n    // 1 - acb\n    a = 0;\n    c = 1;\n    b = 2;\n  } else if (workingOrders & 1 << 2) {\n    // 2 - bac\n    b = 0;\n    a = 1;\n    c = 2;\n  } else if (workingOrders & 1 << 3) {\n    // 3 - bca\n    b = 0;\n    c = 1;\n    a = 2;\n  } else if (workingOrders & 1 << 4) {\n    // 4 - cab\n    c = 0;\n    a = 1;\n    b = 2;\n  } else if (workingOrders & 1 << 5) {\n    // 5 - cba\n    c = 0;\n    b = 1;\n    a = 2;\n  } else {\n    // No ordering works.\n    // Report the most constrained vertex as unmatched so we copy that one.\n    var i0Popcount = popcount0to63(i0Mask);\n    var i1Popcount = popcount0to63(i1Mask);\n    var i2Popcount = popcount0to63(i2Mask);\n\n    if (i0Popcount < i1Popcount && i0Popcount < i2Popcount) {\n      return i0;\n    } else if (i1Popcount < i2Popcount) {\n      return i1;\n    }\n\n    return i2;\n  }\n\n  var i0Start = i0 * 3;\n  outlineCoordinates[i0Start + a] = a0;\n  outlineCoordinates[i0Start + b] = b0;\n  outlineCoordinates[i0Start + c] = c0;\n  var i1Start = i1 * 3;\n  outlineCoordinates[i1Start + a] = a1;\n  outlineCoordinates[i1Start + b] = b1;\n  outlineCoordinates[i1Start + c] = c1;\n  var i2Start = i2 * 3;\n  outlineCoordinates[i2Start + a] = a2;\n  outlineCoordinates[i2Start + b] = b2;\n  outlineCoordinates[i2Start + c] = c2;\n  return -1;\n}\n\nfunction isHighlighted(edges, i0, i1) {\n  var edgeSmallMultiplier = edges[0];\n  var index = Math.min(i0, i1) * edgeSmallMultiplier + Math.max(i0, i1); // If i0 and i1 are both 0, then our index will be 0 and we'll end up\n  // accessing the edgeSmallMultiplier that we've sneakily squirreled away\n  // in index 0. But it makes no sense to have an edge between vertex 0 and\n  // itself, so for any edgeSmallMultiplier other than 1 we'll return the\n  // correct answer: false. If edgeSmallMultiplier is 1, that means there is\n  // only a single vertex, so no danger of forming a meaningful triangle\n  // with that.\n\n  return edges[index] === 1;\n}\n\nfunction createTexture(size) {\n  var texture = new Uint8Array(size);\n  texture[size - 1] = 192;\n\n  if (size === 8) {\n    texture[size - 1] = 96;\n  } else if (size === 4) {\n    texture[size - 1] = 48;\n  } else if (size === 2) {\n    texture[size - 1] = 24;\n  } else if (size === 1) {\n    texture[size - 1] = 12;\n  }\n\n  return texture;\n}\n\nfunction updateBufferViewsWithNewVertices(model, bufferViews) {\n  var gltf = model.gltf;\n  var loadResources = model._loadResources;\n  var i, j;\n\n  for (i = 0; i < bufferViews.length; ++i) {\n    var bufferView = bufferViews[i];\n    var vertexNumberingScope = bufferView.extras._pipeline.vertexNumberingScope; // Let the temporary data be garbage collected.\n\n    bufferView.extras._pipeline.vertexNumberingScope = undefined;\n    var newVertices = vertexNumberingScope.extraVertices;\n    var sourceData = loadResources.getBuffer(bufferView);\n    var byteStride = bufferView.byteStride || 4;\n    var newVerticesLength = newVertices.length;\n    var destData = new Uint8Array(sourceData.byteLength + newVerticesLength * byteStride); // Copy the original vertices\n\n    destData.set(sourceData); // Copy the vertices added for outlining\n\n    for (j = 0; j < newVerticesLength; ++j) {\n      var sourceIndex = newVertices[j] * byteStride;\n      var destIndex = sourceData.length + j * byteStride;\n\n      for (var k = 0; k < byteStride; ++k) {\n        destData[destIndex + k] = destData[sourceIndex + k];\n      }\n    } // This bufferView is an independent buffer now. Update the model accordingly.\n\n\n    bufferView.byteOffset = 0;\n    bufferView.byteLength = destData.byteLength;\n    var bufferId = gltf.buffers.push({\n      byteLength: destData.byteLength,\n      extras: {\n        _pipeline: {\n          source: destData.buffer\n        }\n      }\n    }) - 1;\n    bufferView.buffer = bufferId;\n    loadResources.buffers[bufferId] = destData; // Update the accessors to reflect the added vertices.\n\n    var accessors = vertexNumberingScope.accessors;\n\n    for (j = 0; j < accessors.length; ++j) {\n      var accessorId = accessors[j];\n      gltf.accessors[accessorId].count += newVerticesLength;\n    }\n\n    if (!vertexNumberingScope.createdOutlines) {\n      // Create the buffers, views, and accessors for the outline texture coordinates.\n      var outlineCoordinates = vertexNumberingScope.outlineCoordinates;\n      var outlineCoordinateBuffer = new Float32Array(outlineCoordinates);\n      var bufferIndex = model.gltf.buffers.push({\n        byteLength: outlineCoordinateBuffer.byteLength,\n        extras: {\n          _pipeline: {\n            source: outlineCoordinateBuffer.buffer\n          }\n        }\n      }) - 1;\n      loadResources.buffers[bufferIndex] = new Uint8Array(outlineCoordinateBuffer.buffer, 0, outlineCoordinateBuffer.byteLength);\n      var bufferViewIndex = model.gltf.bufferViews.push({\n        buffer: bufferIndex,\n        byteLength: outlineCoordinateBuffer.byteLength,\n        byteOffset: 0,\n        byteStride: 3 * Float32Array.BYTES_PER_ELEMENT,\n        target: 34962\n      }) - 1;\n      var accessorIndex = model.gltf.accessors.push({\n        bufferView: bufferViewIndex,\n        byteOffset: 0,\n        componentType: 5126,\n        count: outlineCoordinateBuffer.length / 3,\n        type: \"VEC3\",\n        min: [0.0, 0.0, 0.0],\n        max: [1.0, 1.0, 1.0]\n      }) - 1;\n      var primitives = vertexNumberingScope.primitives;\n\n      for (j = 0; j < primitives.length; ++j) {\n        primitives[j].attributes._OUTLINE_COORDINATES = accessorIndex;\n      }\n\n      loadResources.vertexBuffersToCreate.enqueue(bufferViewIndex);\n      vertexNumberingScope.createdOutlines = true;\n    }\n  }\n}\n\nfunction compactBuffers(model) {\n  var gltf = model.gltf;\n  var loadResources = model._loadResources;\n  var i;\n\n  for (i = 0; i < gltf.buffers.length; ++i) {\n    var buffer = gltf.buffers[i];\n    var bufferViewsUsingThisBuffer = gltf.bufferViews.filter(usesBuffer.bind(undefined, i));\n    var newLength = bufferViewsUsingThisBuffer.reduce(function (previous, current) {\n      return previous + current.byteLength;\n    }, 0);\n\n    if (newLength === buffer.byteLength) {\n      continue;\n    }\n\n    var newBuffer = new Uint8Array(newLength);\n    var offset = 0;\n\n    for (var j = 0; j < bufferViewsUsingThisBuffer.length; ++j) {\n      var bufferView = bufferViewsUsingThisBuffer[j];\n      var sourceData = loadResources.getBuffer(bufferView);\n      newBuffer.set(sourceData, offset);\n      bufferView.byteOffset = offset;\n      offset += sourceData.byteLength;\n    }\n\n    loadResources.buffers[i] = newBuffer;\n    buffer.extras._pipeline.source = newBuffer.buffer;\n    buffer.byteLength = newLength;\n  }\n}\n\nfunction usesBuffer(bufferId, bufferView) {\n  return bufferView.buffer === bufferId;\n}\n\nfunction getVertexNumberingScope(model, primitive) {\n  var attributes = primitive.attributes;\n\n  if (attributes === undefined) {\n    return undefined;\n  }\n\n  var gltf = model.gltf;\n  var vertexNumberingScope; // Initialize common details for all bufferViews used by this primitive's vertices.\n  // All bufferViews used by this primitive must use a common vertex numbering scheme.\n\n  for (var semantic in attributes) {\n    if (!attributes.hasOwnProperty(semantic)) {\n      continue;\n    }\n\n    var accessorId = attributes[semantic];\n    var accessor = gltf.accessors[accessorId];\n    var bufferViewId = accessor.bufferView;\n    var bufferView = gltf.bufferViews[bufferViewId];\n\n    if (!defined(bufferView.extras)) {\n      bufferView.extras = {};\n    }\n\n    if (!defined(bufferView.extras._pipeline)) {\n      bufferView.extras._pipeline = {};\n    }\n\n    if (!defined(bufferView.extras._pipeline.vertexNumberingScope)) {\n      bufferView.extras._pipeline.vertexNumberingScope = vertexNumberingScope || {\n        // Each element in this array is:\n        // a) undefined, if the vertex at this index has no copies\n        // b) the index of the copy.\n        vertexCopies: [],\n        // Extra vertices appended after the ones originally included in the model.\n        // Each element is the index of the vertex that this one is a copy of.\n        extraVertices: [],\n        // The texture coordinates used for outlining, three floats per vertex.\n        outlineCoordinates: [],\n        // The IDs of accessors that use this vertex numbering.\n        accessors: [],\n        // The IDs of bufferViews that use this vertex numbering.\n        bufferViews: [],\n        // The primitives that use this vertex numbering.\n        primitives: [],\n        // True if the buffer for the outlines has already been created.\n        createdOutlines: false\n      };\n    } else if (vertexNumberingScope !== undefined && bufferView.extras._pipeline.vertexNumberingScope !== vertexNumberingScope) {\n      // Conflicting vertex numbering, let's give up.\n      return undefined;\n    }\n\n    vertexNumberingScope = bufferView.extras._pipeline.vertexNumberingScope;\n\n    if (vertexNumberingScope.bufferViews.indexOf(bufferView) < 0) {\n      vertexNumberingScope.bufferViews.push(bufferView);\n    }\n\n    if (vertexNumberingScope.accessors.indexOf(accessorId) < 0) {\n      vertexNumberingScope.accessors.push(accessorId);\n    }\n  }\n\n  vertexNumberingScope.primitives.push(primitive);\n  return vertexNumberingScope;\n}\n\nexport default ModelOutlineLoader;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/ModelOutlineLoader.js"],"names":["defined","PixelFormat","ContextLimits","Sampler","Texture","TextureMagnificationFilter","TextureMinificationFilter","TextureWrap","ForEach","ModelOutlineLoader","hasExtension","model","extensionsRequired","CESIUM_primitive_outline","extensionsUsed","outlinePrimitives","gltf","vertexNumberingScopes","mesh","meshId","meshPrimitive","primitive","primitiveId","extensions","outlineData","vertexNumberingScope","getVertexNumberingScope","undefined","indexOf","push","addOutline","indices","i","length","updateBufferViewsWithNewVertices","bufferViews","compactBuffers","createTexture","context","cache","modelOutliningCache","outlineTexture","maxSize","Math","min","maximumTextureSize","size","levelZero","mipLevels","texture","source","arrayBufferView","width","height","pixelFormat","LUMINANCE","sampler","wrapS","CLAMP_TO_EDGE","wrapT","minificationFilter","LINEAR_MIPMAP_LINEAR","magnificationFilter","LINEAR","edgeIndicesAccessorId","vertexCopies","extraVertices","outlineCoordinates","meshes","primitives","accessors","numVertices","semantic","attributes","hasOwnProperty","attributeId","accessor","count","triangleIndexAccessorGltf","triangleIndexBufferViewGltf","bufferView","edgeIndexAccessorGltf","edgeIndexBufferViewGltf","loadResources","_loadResources","triangleIndexBufferView","getBuffer","edgeIndexBufferView","triangleIndices","componentType","Uint16Array","buffer","byteOffset","Uint32Array","edgeIndices","edgeSmallMultiplier","edges","a","b","small","big","max","i0","i1","i2","all","has01","isHighlighted","has12","has20","unmatchableVertexIndex","matchAndStoreCoordinates","copy","original","buffers","byteLength","extras","_pipeline","Uint8Array","computeOrderMask","vertexIndex","c","startIndex","first","second","third","popcount0to63","value","a0","b0","c0","i0Mask","a1","b1","c1","i1Mask","a2","b2","c2","i2Mask","workingOrders","i0Popcount","i1Popcount","i2Popcount","i0Start","i1Start","i2Start","index","j","newVertices","sourceData","byteStride","newVerticesLength","destData","set","sourceIndex","destIndex","k","bufferId","accessorId","createdOutlines","outlineCoordinateBuffer","Float32Array","bufferIndex","bufferViewIndex","BYTES_PER_ELEMENT","target","accessorIndex","type","_OUTLINE_COORDINATES","vertexBuffersToCreate","enqueue","bufferViewsUsingThisBuffer","filter","usesBuffer","bind","newLength","reduce","previous","current","newBuffer","offset","bufferViewId"],"mappings":"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","sourcesContent":["import defined from \"../Core/defined.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport ForEach from \"../ThirdParty/GltfPipeline/ForEach.js\";\n\n/**\n * Creates face outlines for glTF primitives with the `CESIUM_primitive_outline` extension.\n * @private\n */\nfunction ModelOutlineLoader() {}\n\n/**\n * Returns true if the model uses or requires CESIUM_primitive_outline.\n * @private\n */\nModelOutlineLoader.hasExtension = function (model) {\n  return (\n    defined(model.extensionsRequired.CESIUM_primitive_outline) ||\n    defined(model.extensionsUsed.CESIUM_primitive_outline)\n  );\n};\n\n/**\n * Arranges to outline any primitives with the CESIUM_primitive_outline extension.\n * It is expected that all buffer data is loaded and available in\n * `extras._pipeline.source` before this function is called, and that vertex\n * and index WebGL buffers are not yet created.\n * @private\n */\nModelOutlineLoader.outlinePrimitives = function (model) {\n  if (!ModelOutlineLoader.hasExtension(model)) {\n    return;\n  }\n\n  var gltf = model.gltf;\n\n  // Assumption: A single bufferView contains a single zero-indexed range of vertices.\n  // No trickery with using large accessor byteOffsets to store multiple zero-based\n  // ranges of vertices in a single bufferView. Use separate bufferViews for that,\n  // you monster.\n  // Note that interleaved vertex attributes (e.g. position0, normal0, uv0,\n  // position1, normal1, uv1, ...) _are_ supported and should not be confused with\n  // the above.\n\n  var vertexNumberingScopes = [];\n\n  ForEach.mesh(gltf, function (mesh, meshId) {\n    ForEach.meshPrimitive(mesh, function (primitive, primitiveId) {\n      if (!defined(primitive.extensions)) {\n        return;\n      }\n\n      var outlineData = primitive.extensions.CESIUM_primitive_outline;\n      if (!defined(outlineData)) {\n        return;\n      }\n\n      var vertexNumberingScope = getVertexNumberingScope(model, primitive);\n      if (vertexNumberingScope === undefined) {\n        return;\n      }\n\n      if (vertexNumberingScopes.indexOf(vertexNumberingScope) < 0) {\n        vertexNumberingScopes.push(vertexNumberingScope);\n      }\n\n      // Add the outline to this primitive\n      addOutline(\n        model,\n        meshId,\n        primitiveId,\n        outlineData.indices,\n        vertexNumberingScope\n      );\n    });\n  });\n\n  // Update all relevant bufferViews to include the duplicate vertices that are\n  // needed for outlining.\n  for (var i = 0; i < vertexNumberingScopes.length; ++i) {\n    updateBufferViewsWithNewVertices(\n      model,\n      vertexNumberingScopes[i].bufferViews\n    );\n  }\n\n  // Remove data not referenced by any bufferViews anymore.\n  compactBuffers(model);\n};\n\nModelOutlineLoader.createTexture = function (model, context) {\n  var cache = context.cache.modelOutliningCache;\n  if (!defined(cache)) {\n    cache = context.cache.modelOutliningCache = {};\n  }\n\n  if (defined(cache.outlineTexture)) {\n    return cache.outlineTexture;\n  }\n\n  var maxSize = Math.min(4096, ContextLimits.maximumTextureSize);\n\n  var size = maxSize;\n  var levelZero = createTexture(size);\n\n  var mipLevels = [];\n\n  while (size > 1) {\n    size >>= 1;\n    mipLevels.push(createTexture(size));\n  }\n\n  var texture = new Texture({\n    context: context,\n    source: {\n      arrayBufferView: levelZero,\n      mipLevels: mipLevels,\n    },\n    width: maxSize,\n    height: 1,\n    pixelFormat: PixelFormat.LUMINANCE,\n    sampler: new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: TextureMinificationFilter.LINEAR_MIPMAP_LINEAR,\n      magnificationFilter: TextureMagnificationFilter.LINEAR,\n    }),\n  });\n\n  cache.outlineTexture = texture;\n\n  return texture;\n};\n\nfunction addOutline(\n  model,\n  meshId,\n  primitiveId,\n  edgeIndicesAccessorId,\n  vertexNumberingScope\n) {\n  var vertexCopies = vertexNumberingScope.vertexCopies;\n  var extraVertices = vertexNumberingScope.extraVertices;\n  var outlineCoordinates = vertexNumberingScope.outlineCoordinates;\n\n  var gltf = model.gltf;\n  var mesh = gltf.meshes[meshId];\n  var primitive = mesh.primitives[primitiveId];\n  var accessors = gltf.accessors;\n  var bufferViews = gltf.bufferViews;\n\n  // Find the number of vertices in this primitive by looking at\n  // the first attribute. Others are required to be the same.\n  var numVertices;\n  for (var semantic in primitive.attributes) {\n    if (primitive.attributes.hasOwnProperty(semantic)) {\n      var attributeId = primitive.attributes[semantic];\n      var accessor = accessors[attributeId];\n      if (defined(accessor)) {\n        numVertices = accessor.count;\n        break;\n      }\n    }\n  }\n\n  if (!defined(numVertices)) {\n    return undefined;\n  }\n\n  var triangleIndexAccessorGltf = accessors[primitive.indices];\n  var triangleIndexBufferViewGltf =\n    bufferViews[triangleIndexAccessorGltf.bufferView];\n  var edgeIndexAccessorGltf = accessors[edgeIndicesAccessorId];\n  var edgeIndexBufferViewGltf = bufferViews[edgeIndexAccessorGltf.bufferView];\n\n  var loadResources = model._loadResources;\n  var triangleIndexBufferView = loadResources.getBuffer(\n    triangleIndexBufferViewGltf\n  );\n  var edgeIndexBufferView = loadResources.getBuffer(edgeIndexBufferViewGltf);\n\n  var triangleIndices =\n    triangleIndexAccessorGltf.componentType === 5123\n      ? new Uint16Array(\n          triangleIndexBufferView.buffer,\n          triangleIndexBufferView.byteOffset +\n            triangleIndexAccessorGltf.byteOffset,\n          triangleIndexAccessorGltf.count\n        )\n      : new Uint32Array(\n          triangleIndexBufferView.buffer,\n          triangleIndexBufferView.byteOffset +\n            triangleIndexAccessorGltf.byteOffset,\n          triangleIndexAccessorGltf.count\n        );\n  var edgeIndices =\n    edgeIndexAccessorGltf.componentType === 5123\n      ? new Uint16Array(\n          edgeIndexBufferView.buffer,\n          edgeIndexBufferView.byteOffset + edgeIndexAccessorGltf.byteOffset,\n          edgeIndexAccessorGltf.count\n        )\n      : new Uint32Array(\n          edgeIndexBufferView.buffer,\n          edgeIndexBufferView.byteOffset + edgeIndexAccessorGltf.byteOffset,\n          edgeIndexAccessorGltf.count\n        );\n\n  // Make a hash table for quick lookups of whether an edge exists between two\n  // vertices. The hash is a sparse array indexed by\n  //   `smallerVertexIndex * totalNumberOfVertices + biggerVertexIndex`\n  // A value of 1 indicates an edge exists between the two vertex indices; any\n  // other value indicates that it does not. We store the\n  // `edgeSmallMultipler` - that is, the number of vertices in the equation\n  // above - at index 0 for easy access to it later.\n\n  var edgeSmallMultiplier = numVertices;\n\n  var edges = [edgeSmallMultiplier];\n  var i;\n  for (i = 0; i < edgeIndices.length; i += 2) {\n    var a = edgeIndices[i];\n    var b = edgeIndices[i + 1];\n    var small = Math.min(a, b);\n    var big = Math.max(a, b);\n    edges[small * edgeSmallMultiplier + big] = 1;\n  }\n\n  // For each triangle, adjust vertex data so that the correct edges are outlined.\n  for (i = 0; i < triangleIndices.length; i += 3) {\n    var i0 = triangleIndices[i];\n    var i1 = triangleIndices[i + 1];\n    var i2 = triangleIndices[i + 2];\n\n    var all = false; // set this to true to draw a full wireframe.\n    var has01 = all || isHighlighted(edges, i0, i1);\n    var has12 = all || isHighlighted(edges, i1, i2);\n    var has20 = all || isHighlighted(edges, i2, i0);\n\n    var unmatchableVertexIndex = matchAndStoreCoordinates(\n      outlineCoordinates,\n      i0,\n      i1,\n      i2,\n      has01,\n      has12,\n      has20\n    );\n    while (unmatchableVertexIndex >= 0) {\n      // Copy the unmatchable index and try again.\n      var copy;\n      if (unmatchableVertexIndex === i0) {\n        copy = vertexCopies[i0];\n      } else if (unmatchableVertexIndex === i1) {\n        copy = vertexCopies[i1];\n      } else {\n        copy = vertexCopies[i2];\n      }\n\n      if (copy === undefined) {\n        copy = numVertices + extraVertices.length;\n\n        var original = unmatchableVertexIndex;\n        while (original >= numVertices) {\n          original = extraVertices[original - numVertices];\n        }\n        extraVertices.push(original);\n        vertexCopies[unmatchableVertexIndex] = copy;\n      }\n\n      if (copy >= 65536 && triangleIndices instanceof Uint16Array) {\n        // We outgrew a 16-bit index buffer, switch to 32-bit.\n        triangleIndices = new Uint32Array(triangleIndices);\n        triangleIndexAccessorGltf.componentType = 5125; // UNSIGNED_INT\n        triangleIndexBufferViewGltf.buffer =\n          gltf.buffers.push({\n            byteLength: triangleIndices.byteLength,\n            extras: {\n              _pipeline: {\n                source: triangleIndices.buffer,\n              },\n            },\n          }) - 1;\n        triangleIndexBufferViewGltf.byteLength = triangleIndices.byteLength;\n        triangleIndexBufferViewGltf.byteOffset = 0;\n        model._loadResources.buffers[\n          triangleIndexBufferViewGltf.buffer\n        ] = new Uint8Array(\n          triangleIndices.buffer,\n          0,\n          triangleIndices.byteLength\n        );\n      }\n\n      if (unmatchableVertexIndex === i0) {\n        i0 = copy;\n        triangleIndices[i] = copy;\n      } else if (unmatchableVertexIndex === i1) {\n        i1 = copy;\n        triangleIndices[i + 1] = copy;\n      } else {\n        i2 = copy;\n        triangleIndices[i + 2] = copy;\n      }\n\n      if (defined(triangleIndexAccessorGltf.max)) {\n        triangleIndexAccessorGltf.max[0] = Math.max(\n          triangleIndexAccessorGltf.max[0],\n          copy\n        );\n      }\n\n      unmatchableVertexIndex = matchAndStoreCoordinates(\n        outlineCoordinates,\n        i0,\n        i1,\n        i2,\n        has01,\n        has12,\n        has20\n      );\n    }\n  }\n}\n\n// Each vertex has three coordinates, a, b, and c.\n// a is the coordinate that applies to edge 2-0 for the vertex.\n// b is the coordinate that applies to edge 0-1 for the vertex.\n// c is the coordinate that applies to edge 1-2 for the vertex.\n\n// A single triangle with all edges highlighted:\n//\n//                 | a | b | c |\n//                 | 1 | 1 | 0 |\n//                       0\n//                      / \\\n//                     /   \\\n//           edge 0-1 /     \\ edge 2-0\n//                   /       \\\n//                  /         \\\n// | a | b | c |   1-----------2   | a | b | c |\n// | 0 | 1 | 1 |     edge 1-2      | 1 | 0 | 1 |\n//\n// There are 6 possible orderings of coordinates a, b, and c:\n// 0 - abc\n// 1 - acb\n// 2 - bac\n// 3 - bca\n// 4 - cab\n// 5 - cba\n\n// All vertices must use the _same ordering_ for the edges to be rendered\n// correctly. So we compute a bitmask for each vertex, where the bit at\n// each position indicates whether that ordering works (i.e. doesn't\n// conflict with already-assigned coordinates) for that vertex.\n\n// Then we can find an ordering that works for all three vertices with a\n// bitwise AND.\n\nfunction computeOrderMask(outlineCoordinates, vertexIndex, a, b, c) {\n  var startIndex = vertexIndex * 3;\n  var first = outlineCoordinates[startIndex];\n  var second = outlineCoordinates[startIndex + 1];\n  var third = outlineCoordinates[startIndex + 2];\n\n  if (first === undefined) {\n    // If one coordinate is undefined, they all are, and all orderings are fine.\n    return 63; // 0b111111;\n  }\n\n  return (\n    ((first === a && second === b && third === c) << 0) +\n    ((first === a && second === c && third === b) << 1) +\n    ((first === b && second === a && third === c) << 2) +\n    ((first === b && second === c && third === a) << 3) +\n    ((first === c && second === a && third === b) << 4) +\n    ((first === c && second === b && third === a) << 5)\n  );\n}\n\n// popcount for integers 0-63, inclusive.\n// i.e. how many 1s are in the binary representation of the integer.\nfunction popcount0to63(value) {\n  return (\n    (value & 1) +\n    ((value >> 1) & 1) +\n    ((value >> 2) & 1) +\n    ((value >> 3) & 1) +\n    ((value >> 4) & 1) +\n    ((value >> 5) & 1)\n  );\n}\n\nfunction matchAndStoreCoordinates(\n  outlineCoordinates,\n  i0,\n  i1,\n  i2,\n  has01,\n  has12,\n  has20\n) {\n  var a0 = has20 ? 1.0 : 0.0;\n  var b0 = has01 ? 1.0 : 0.0;\n  var c0 = 0.0;\n\n  var i0Mask = computeOrderMask(outlineCoordinates, i0, a0, b0, c0);\n  if (i0Mask === 0) {\n    return i0;\n  }\n\n  var a1 = 0.0;\n  var b1 = has01 ? 1.0 : 0.0;\n  var c1 = has12 ? 1.0 : 0.0;\n\n  var i1Mask = computeOrderMask(outlineCoordinates, i1, a1, b1, c1);\n  if (i1Mask === 0) {\n    return i1;\n  }\n\n  var a2 = has20 ? 1.0 : 0.0;\n  var b2 = 0.0;\n  var c2 = has12 ? 1.0 : 0.0;\n\n  var i2Mask = computeOrderMask(outlineCoordinates, i2, a2, b2, c2);\n  if (i2Mask === 0) {\n    return i2;\n  }\n\n  var workingOrders = i0Mask & i1Mask & i2Mask;\n\n  var a, b, c;\n\n  if (workingOrders & (1 << 0)) {\n    // 0 - abc\n    a = 0;\n    b = 1;\n    c = 2;\n  } else if (workingOrders & (1 << 1)) {\n    // 1 - acb\n    a = 0;\n    c = 1;\n    b = 2;\n  } else if (workingOrders & (1 << 2)) {\n    // 2 - bac\n    b = 0;\n    a = 1;\n    c = 2;\n  } else if (workingOrders & (1 << 3)) {\n    // 3 - bca\n    b = 0;\n    c = 1;\n    a = 2;\n  } else if (workingOrders & (1 << 4)) {\n    // 4 - cab\n    c = 0;\n    a = 1;\n    b = 2;\n  } else if (workingOrders & (1 << 5)) {\n    // 5 - cba\n    c = 0;\n    b = 1;\n    a = 2;\n  } else {\n    // No ordering works.\n    // Report the most constrained vertex as unmatched so we copy that one.\n    var i0Popcount = popcount0to63(i0Mask);\n    var i1Popcount = popcount0to63(i1Mask);\n    var i2Popcount = popcount0to63(i2Mask);\n    if (i0Popcount < i1Popcount && i0Popcount < i2Popcount) {\n      return i0;\n    } else if (i1Popcount < i2Popcount) {\n      return i1;\n    }\n    return i2;\n  }\n\n  var i0Start = i0 * 3;\n  outlineCoordinates[i0Start + a] = a0;\n  outlineCoordinates[i0Start + b] = b0;\n  outlineCoordinates[i0Start + c] = c0;\n\n  var i1Start = i1 * 3;\n  outlineCoordinates[i1Start + a] = a1;\n  outlineCoordinates[i1Start + b] = b1;\n  outlineCoordinates[i1Start + c] = c1;\n\n  var i2Start = i2 * 3;\n  outlineCoordinates[i2Start + a] = a2;\n  outlineCoordinates[i2Start + b] = b2;\n  outlineCoordinates[i2Start + c] = c2;\n\n  return -1;\n}\n\nfunction isHighlighted(edges, i0, i1) {\n  var edgeSmallMultiplier = edges[0];\n  var index = Math.min(i0, i1) * edgeSmallMultiplier + Math.max(i0, i1);\n\n  // If i0 and i1 are both 0, then our index will be 0 and we'll end up\n  // accessing the edgeSmallMultiplier that we've sneakily squirreled away\n  // in index 0. But it makes no sense to have an edge between vertex 0 and\n  // itself, so for any edgeSmallMultiplier other than 1 we'll return the\n  // correct answer: false. If edgeSmallMultiplier is 1, that means there is\n  // only a single vertex, so no danger of forming a meaningful triangle\n  // with that.\n  return edges[index] === 1;\n}\n\nfunction createTexture(size) {\n  var texture = new Uint8Array(size);\n  texture[size - 1] = 192;\n  if (size === 8) {\n    texture[size - 1] = 96;\n  } else if (size === 4) {\n    texture[size - 1] = 48;\n  } else if (size === 2) {\n    texture[size - 1] = 24;\n  } else if (size === 1) {\n    texture[size - 1] = 12;\n  }\n  return texture;\n}\n\nfunction updateBufferViewsWithNewVertices(model, bufferViews) {\n  var gltf = model.gltf;\n  var loadResources = model._loadResources;\n\n  var i, j;\n  for (i = 0; i < bufferViews.length; ++i) {\n    var bufferView = bufferViews[i];\n    var vertexNumberingScope = bufferView.extras._pipeline.vertexNumberingScope;\n\n    // Let the temporary data be garbage collected.\n    bufferView.extras._pipeline.vertexNumberingScope = undefined;\n\n    var newVertices = vertexNumberingScope.extraVertices;\n\n    var sourceData = loadResources.getBuffer(bufferView);\n    var byteStride = bufferView.byteStride || 4;\n    var newVerticesLength = newVertices.length;\n    var destData = new Uint8Array(\n      sourceData.byteLength + newVerticesLength * byteStride\n    );\n\n    // Copy the original vertices\n    destData.set(sourceData);\n\n    // Copy the vertices added for outlining\n    for (j = 0; j < newVerticesLength; ++j) {\n      var sourceIndex = newVertices[j] * byteStride;\n      var destIndex = sourceData.length + j * byteStride;\n      for (var k = 0; k < byteStride; ++k) {\n        destData[destIndex + k] = destData[sourceIndex + k];\n      }\n    }\n\n    // This bufferView is an independent buffer now. Update the model accordingly.\n    bufferView.byteOffset = 0;\n    bufferView.byteLength = destData.byteLength;\n\n    var bufferId =\n      gltf.buffers.push({\n        byteLength: destData.byteLength,\n        extras: {\n          _pipeline: {\n            source: destData.buffer,\n          },\n        },\n      }) - 1;\n\n    bufferView.buffer = bufferId;\n    loadResources.buffers[bufferId] = destData;\n\n    // Update the accessors to reflect the added vertices.\n    var accessors = vertexNumberingScope.accessors;\n    for (j = 0; j < accessors.length; ++j) {\n      var accessorId = accessors[j];\n      gltf.accessors[accessorId].count += newVerticesLength;\n    }\n\n    if (!vertexNumberingScope.createdOutlines) {\n      // Create the buffers, views, and accessors for the outline texture coordinates.\n      var outlineCoordinates = vertexNumberingScope.outlineCoordinates;\n      var outlineCoordinateBuffer = new Float32Array(outlineCoordinates);\n      var bufferIndex =\n        model.gltf.buffers.push({\n          byteLength: outlineCoordinateBuffer.byteLength,\n          extras: {\n            _pipeline: {\n              source: outlineCoordinateBuffer.buffer,\n            },\n          },\n        }) - 1;\n      loadResources.buffers[bufferIndex] = new Uint8Array(\n        outlineCoordinateBuffer.buffer,\n        0,\n        outlineCoordinateBuffer.byteLength\n      );\n\n      var bufferViewIndex =\n        model.gltf.bufferViews.push({\n          buffer: bufferIndex,\n          byteLength: outlineCoordinateBuffer.byteLength,\n          byteOffset: 0,\n          byteStride: 3 * Float32Array.BYTES_PER_ELEMENT,\n          target: 34962,\n        }) - 1;\n\n      var accessorIndex =\n        model.gltf.accessors.push({\n          bufferView: bufferViewIndex,\n          byteOffset: 0,\n          componentType: 5126,\n          count: outlineCoordinateBuffer.length / 3,\n          type: \"VEC3\",\n          min: [0.0, 0.0, 0.0],\n          max: [1.0, 1.0, 1.0],\n        }) - 1;\n\n      var primitives = vertexNumberingScope.primitives;\n      for (j = 0; j < primitives.length; ++j) {\n        primitives[j].attributes._OUTLINE_COORDINATES = accessorIndex;\n      }\n\n      loadResources.vertexBuffersToCreate.enqueue(bufferViewIndex);\n\n      vertexNumberingScope.createdOutlines = true;\n    }\n  }\n}\n\nfunction compactBuffers(model) {\n  var gltf = model.gltf;\n  var loadResources = model._loadResources;\n\n  var i;\n  for (i = 0; i < gltf.buffers.length; ++i) {\n    var buffer = gltf.buffers[i];\n    var bufferViewsUsingThisBuffer = gltf.bufferViews.filter(\n      usesBuffer.bind(undefined, i)\n    );\n    var newLength = bufferViewsUsingThisBuffer.reduce(function (\n      previous,\n      current\n    ) {\n      return previous + current.byteLength;\n    },\n    0);\n    if (newLength === buffer.byteLength) {\n      continue;\n    }\n\n    var newBuffer = new Uint8Array(newLength);\n    var offset = 0;\n    for (var j = 0; j < bufferViewsUsingThisBuffer.length; ++j) {\n      var bufferView = bufferViewsUsingThisBuffer[j];\n      var sourceData = loadResources.getBuffer(bufferView);\n      newBuffer.set(sourceData, offset);\n\n      bufferView.byteOffset = offset;\n      offset += sourceData.byteLength;\n    }\n\n    loadResources.buffers[i] = newBuffer;\n    buffer.extras._pipeline.source = newBuffer.buffer;\n    buffer.byteLength = newLength;\n  }\n}\n\nfunction usesBuffer(bufferId, bufferView) {\n  return bufferView.buffer === bufferId;\n}\n\nfunction getVertexNumberingScope(model, primitive) {\n  var attributes = primitive.attributes;\n  if (attributes === undefined) {\n    return undefined;\n  }\n\n  var gltf = model.gltf;\n\n  var vertexNumberingScope;\n\n  // Initialize common details for all bufferViews used by this primitive's vertices.\n  // All bufferViews used by this primitive must use a common vertex numbering scheme.\n  for (var semantic in attributes) {\n    if (!attributes.hasOwnProperty(semantic)) {\n      continue;\n    }\n\n    var accessorId = attributes[semantic];\n    var accessor = gltf.accessors[accessorId];\n    var bufferViewId = accessor.bufferView;\n    var bufferView = gltf.bufferViews[bufferViewId];\n\n    if (!defined(bufferView.extras)) {\n      bufferView.extras = {};\n    }\n    if (!defined(bufferView.extras._pipeline)) {\n      bufferView.extras._pipeline = {};\n    }\n\n    if (!defined(bufferView.extras._pipeline.vertexNumberingScope)) {\n      bufferView.extras._pipeline.vertexNumberingScope = vertexNumberingScope || {\n        // Each element in this array is:\n        // a) undefined, if the vertex at this index has no copies\n        // b) the index of the copy.\n        vertexCopies: [],\n\n        // Extra vertices appended after the ones originally included in the model.\n        // Each element is the index of the vertex that this one is a copy of.\n        extraVertices: [],\n\n        // The texture coordinates used for outlining, three floats per vertex.\n        outlineCoordinates: [],\n\n        // The IDs of accessors that use this vertex numbering.\n        accessors: [],\n\n        // The IDs of bufferViews that use this vertex numbering.\n        bufferViews: [],\n\n        // The primitives that use this vertex numbering.\n        primitives: [],\n\n        // True if the buffer for the outlines has already been created.\n        createdOutlines: false,\n      };\n    } else if (\n      vertexNumberingScope !== undefined &&\n      bufferView.extras._pipeline.vertexNumberingScope !== vertexNumberingScope\n    ) {\n      // Conflicting vertex numbering, let's give up.\n      return undefined;\n    }\n\n    vertexNumberingScope = bufferView.extras._pipeline.vertexNumberingScope;\n\n    if (vertexNumberingScope.bufferViews.indexOf(bufferView) < 0) {\n      vertexNumberingScope.bufferViews.push(bufferView);\n    }\n\n    if (vertexNumberingScope.accessors.indexOf(accessorId) < 0) {\n      vertexNumberingScope.accessors.push(accessorId);\n    }\n  }\n\n  vertexNumberingScope.primitives.push(primitive);\n\n  return vertexNumberingScope;\n}\n\nexport default ModelOutlineLoader;\n"]},"metadata":{},"sourceType":"module"}