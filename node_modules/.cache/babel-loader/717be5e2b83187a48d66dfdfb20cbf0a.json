{"ast":null,"code":"import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\n/**\n * Provides terrain or other geometry for the surface of an ellipsoid.  The surface geometry is\n * organized into a pyramid of tiles according to a {@link TilingScheme}.  This type describes an\n * interface and is not intended to be instantiated directly.\n *\n * @alias TerrainProvider\n * @constructor\n *\n * @see EllipsoidTerrainProvider\n * @see CesiumTerrainProvider\n * @see VRTheWorldTerrainProvider\n * @see GoogleEarthEnterpriseTerrainProvider\n */\n\nfunction TerrainProvider() {\n  DeveloperError.throwInstantiationError();\n}\n\nObject.defineProperties(TerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error..  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof TerrainProvider.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: DeveloperError.throwInstantiationError\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain. This function should\n   * not be called before {@link TerrainProvider#ready} returns true.\n   * @memberof TerrainProvider.prototype\n   * @type {Credit}\n   */\n  credit: {\n    get: DeveloperError.throwInstantiationError\n  },\n\n  /**\n   * Gets the tiling scheme used by the provider.  This function should\n   * not be called before {@link TerrainProvider#ready} returns true.\n   * @memberof TerrainProvider.prototype\n   * @type {TilingScheme}\n   */\n  tilingScheme: {\n    get: DeveloperError.throwInstantiationError\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof TerrainProvider.prototype\n   * @type {Boolean}\n   */\n  ready: {\n    get: DeveloperError.throwInstantiationError\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof TerrainProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: DeveloperError.throwInstantiationError\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.  This function should not be\n   * called before {@link TerrainProvider#ready} returns true.\n   * @memberof TerrainProvider.prototype\n   * @type {Boolean}\n   */\n  hasWaterMask: {\n    get: DeveloperError.throwInstantiationError\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * This function should not be called before {@link TerrainProvider#ready} returns true.\n   * @memberof TerrainProvider.prototype\n   * @type {Boolean}\n   */\n  hasVertexNormals: {\n    get: DeveloperError.throwInstantiationError\n  },\n\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles.  This function should not be called before\n   * {@link TerrainProvider#ready} returns true.  This property may be undefined if availability\n   * information is not available.\n   * @memberof TerrainProvider.prototype\n   * @type {TileAvailability}\n   */\n  availability: {\n    get: DeveloperError.throwInstantiationError\n  }\n});\nvar regularGridIndicesCache = [];\n/**\n * Gets a list of indices for a triangle mesh representing a regular grid.  Calling\n * this function multiple times with the same grid width and height returns the\n * same list of indices.  The total number of vertices must be less than or equal\n * to 65536.\n *\n * @param {Number} width The number of vertices in the regular grid in the horizontal direction.\n * @param {Number} height The number of vertices in the regular grid in the vertical direction.\n * @returns {Uint16Array|Uint32Array} The list of indices. Uint16Array gets returned for 64KB or less and Uint32Array for 4GB or less.\n */\n\nTerrainProvider.getRegularGridIndices = function (width, height) {\n  //>>includeStart('debug', pragmas.debug);\n  if (width * height >= CesiumMath.FOUR_GIGABYTES) {\n    throw new DeveloperError(\"The total number of vertices (width * height) must be less than 4,294,967,296.\");\n  } //>>includeEnd('debug');\n\n\n  var byWidth = regularGridIndicesCache[width];\n\n  if (!defined(byWidth)) {\n    regularGridIndicesCache[width] = byWidth = [];\n  }\n\n  var indices = byWidth[height];\n\n  if (!defined(indices)) {\n    if (width * height < CesiumMath.SIXTY_FOUR_KILOBYTES) {\n      indices = byWidth[height] = new Uint16Array((width - 1) * (height - 1) * 6);\n    } else {\n      indices = byWidth[height] = new Uint32Array((width - 1) * (height - 1) * 6);\n    }\n\n    addRegularGridIndices(width, height, indices, 0);\n  }\n\n  return indices;\n};\n\nvar regularGridAndEdgeIndicesCache = [];\n/**\n * @private\n */\n\nTerrainProvider.getRegularGridIndicesAndEdgeIndices = function (width, height) {\n  //>>includeStart('debug', pragmas.debug);\n  if (width * height >= CesiumMath.FOUR_GIGABYTES) {\n    throw new DeveloperError(\"The total number of vertices (width * height) must be less than 4,294,967,296.\");\n  } //>>includeEnd('debug');\n\n\n  var byWidth = regularGridAndEdgeIndicesCache[width];\n\n  if (!defined(byWidth)) {\n    regularGridAndEdgeIndicesCache[width] = byWidth = [];\n  }\n\n  var indicesAndEdges = byWidth[height];\n\n  if (!defined(indicesAndEdges)) {\n    var indices = TerrainProvider.getRegularGridIndices(width, height);\n    var edgeIndices = getEdgeIndices(width, height);\n    var westIndicesSouthToNorth = edgeIndices.westIndicesSouthToNorth;\n    var southIndicesEastToWest = edgeIndices.southIndicesEastToWest;\n    var eastIndicesNorthToSouth = edgeIndices.eastIndicesNorthToSouth;\n    var northIndicesWestToEast = edgeIndices.northIndicesWestToEast;\n    indicesAndEdges = byWidth[height] = {\n      indices: indices,\n      westIndicesSouthToNorth: westIndicesSouthToNorth,\n      southIndicesEastToWest: southIndicesEastToWest,\n      eastIndicesNorthToSouth: eastIndicesNorthToSouth,\n      northIndicesWestToEast: northIndicesWestToEast\n    };\n  }\n\n  return indicesAndEdges;\n};\n\nvar regularGridAndSkirtAndEdgeIndicesCache = [];\n/**\n * @private\n */\n\nTerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices = function (width, height) {\n  //>>includeStart('debug', pragmas.debug);\n  if (width * height >= CesiumMath.FOUR_GIGABYTES) {\n    throw new DeveloperError(\"The total number of vertices (width * height) must be less than 4,294,967,296.\");\n  } //>>includeEnd('debug');\n\n\n  var byWidth = regularGridAndSkirtAndEdgeIndicesCache[width];\n\n  if (!defined(byWidth)) {\n    regularGridAndSkirtAndEdgeIndicesCache[width] = byWidth = [];\n  }\n\n  var indicesAndEdges = byWidth[height];\n\n  if (!defined(indicesAndEdges)) {\n    var gridVertexCount = width * height;\n    var gridIndexCount = (width - 1) * (height - 1) * 6;\n    var edgeVertexCount = width * 2 + height * 2;\n    var edgeIndexCount = Math.max(0, edgeVertexCount - 4) * 6;\n    var vertexCount = gridVertexCount + edgeVertexCount;\n    var indexCount = gridIndexCount + edgeIndexCount;\n    var edgeIndices = getEdgeIndices(width, height);\n    var westIndicesSouthToNorth = edgeIndices.westIndicesSouthToNorth;\n    var southIndicesEastToWest = edgeIndices.southIndicesEastToWest;\n    var eastIndicesNorthToSouth = edgeIndices.eastIndicesNorthToSouth;\n    var northIndicesWestToEast = edgeIndices.northIndicesWestToEast;\n    var indices = IndexDatatype.createTypedArray(vertexCount, indexCount);\n    addRegularGridIndices(width, height, indices, 0);\n    TerrainProvider.addSkirtIndices(westIndicesSouthToNorth, southIndicesEastToWest, eastIndicesNorthToSouth, northIndicesWestToEast, gridVertexCount, indices, gridIndexCount);\n    indicesAndEdges = byWidth[height] = {\n      indices: indices,\n      westIndicesSouthToNorth: westIndicesSouthToNorth,\n      southIndicesEastToWest: southIndicesEastToWest,\n      eastIndicesNorthToSouth: eastIndicesNorthToSouth,\n      northIndicesWestToEast: northIndicesWestToEast,\n      indexCountWithoutSkirts: gridIndexCount\n    };\n  }\n\n  return indicesAndEdges;\n};\n/**\n * @private\n */\n\n\nTerrainProvider.addSkirtIndices = function (westIndicesSouthToNorth, southIndicesEastToWest, eastIndicesNorthToSouth, northIndicesWestToEast, vertexCount, indices, offset) {\n  var vertexIndex = vertexCount;\n  offset = addSkirtIndices(westIndicesSouthToNorth, vertexIndex, indices, offset);\n  vertexIndex += westIndicesSouthToNorth.length;\n  offset = addSkirtIndices(southIndicesEastToWest, vertexIndex, indices, offset);\n  vertexIndex += southIndicesEastToWest.length;\n  offset = addSkirtIndices(eastIndicesNorthToSouth, vertexIndex, indices, offset);\n  vertexIndex += eastIndicesNorthToSouth.length;\n  addSkirtIndices(northIndicesWestToEast, vertexIndex, indices, offset);\n};\n\nfunction getEdgeIndices(width, height) {\n  var westIndicesSouthToNorth = new Array(height);\n  var southIndicesEastToWest = new Array(width);\n  var eastIndicesNorthToSouth = new Array(height);\n  var northIndicesWestToEast = new Array(width);\n  var i;\n\n  for (i = 0; i < width; ++i) {\n    northIndicesWestToEast[i] = i;\n    southIndicesEastToWest[i] = width * height - 1 - i;\n  }\n\n  for (i = 0; i < height; ++i) {\n    eastIndicesNorthToSouth[i] = (i + 1) * width - 1;\n    westIndicesSouthToNorth[i] = (height - i - 1) * width;\n  }\n\n  return {\n    westIndicesSouthToNorth: westIndicesSouthToNorth,\n    southIndicesEastToWest: southIndicesEastToWest,\n    eastIndicesNorthToSouth: eastIndicesNorthToSouth,\n    northIndicesWestToEast: northIndicesWestToEast\n  };\n}\n\nfunction addRegularGridIndices(width, height, indices, offset) {\n  var index = 0;\n\n  for (var j = 0; j < height - 1; ++j) {\n    for (var i = 0; i < width - 1; ++i) {\n      var upperLeft = index;\n      var lowerLeft = upperLeft + width;\n      var lowerRight = lowerLeft + 1;\n      var upperRight = upperLeft + 1;\n      indices[offset++] = upperLeft;\n      indices[offset++] = lowerLeft;\n      indices[offset++] = upperRight;\n      indices[offset++] = upperRight;\n      indices[offset++] = lowerLeft;\n      indices[offset++] = lowerRight;\n      ++index;\n    }\n\n    ++index;\n  }\n}\n\nfunction addSkirtIndices(edgeIndices, vertexIndex, indices, offset) {\n  var previousIndex = edgeIndices[0];\n  var length = edgeIndices.length;\n\n  for (var i = 1; i < length; ++i) {\n    var index = edgeIndices[i];\n    indices[offset++] = previousIndex;\n    indices[offset++] = index;\n    indices[offset++] = vertexIndex;\n    indices[offset++] = vertexIndex;\n    indices[offset++] = index;\n    indices[offset++] = vertexIndex + 1;\n    previousIndex = index;\n    ++vertexIndex;\n  }\n\n  return offset;\n}\n/**\n * Specifies the quality of terrain created from heightmaps.  A value of 1.0 will\n * ensure that adjacent heightmap vertices are separated by no more than\n * {@link Globe.maximumScreenSpaceError} screen pixels and will probably go very slowly.\n * A value of 0.5 will cut the estimated level zero geometric error in half, allowing twice the\n * screen pixels between adjacent heightmap vertices and thus rendering more quickly.\n * @type {Number}\n */\n\n\nTerrainProvider.heightmapTerrainQuality = 0.25;\n/**\n * Determines an appropriate geometric error estimate when the geometry comes from a heightmap.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to which the terrain is attached.\n * @param {Number} tileImageWidth The width, in pixels, of the heightmap associated with a single tile.\n * @param {Number} numberOfTilesAtLevelZero The number of tiles in the horizontal direction at tile level zero.\n * @returns {Number} An estimated geometric error.\n */\n\nTerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap = function (ellipsoid, tileImageWidth, numberOfTilesAtLevelZero) {\n  return ellipsoid.maximumRadius * 2 * Math.PI * TerrainProvider.heightmapTerrainQuality / (tileImageWidth * numberOfTilesAtLevelZero);\n};\n/**\n * Requests the geometry for a given tile.  This function should not be called before\n * {@link TerrainProvider#ready} returns true.  The result must include terrain data and\n * may optionally include a water mask and an indication of which child tiles are available.\n * @function\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n *\n * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n */\n\n\nTerrainProvider.prototype.requestTileGeometry = DeveloperError.throwInstantiationError;\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.  This function should not be\n * called before {@link TerrainProvider#ready} returns true.\n * @function\n *\n * @param {Number} level The tile level for which to get the maximum geometric error.\n * @returns {Number} The maximum geometric error.\n */\n\nTerrainProvider.prototype.getLevelMaximumGeometricError = DeveloperError.throwInstantiationError;\n/**\n * Determines whether data for a tile is available to be loaded.\n * @function\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {Boolean} Undefined if not supported by the terrain provider, otherwise true or false.\n */\n\nTerrainProvider.prototype.getTileDataAvailable = DeveloperError.throwInstantiationError;\n/**\n * Makes sure we load availability data for a tile\n * @function\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {undefined|Promise} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\n */\n\nTerrainProvider.prototype.loadTileDataAvailability = DeveloperError.throwInstantiationError;\nexport default TerrainProvider;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/TerrainProvider.js"],"names":["defined","DeveloperError","IndexDatatype","CesiumMath","TerrainProvider","throwInstantiationError","Object","defineProperties","prototype","errorEvent","get","credit","tilingScheme","ready","readyPromise","hasWaterMask","hasVertexNormals","availability","regularGridIndicesCache","getRegularGridIndices","width","height","FOUR_GIGABYTES","byWidth","indices","SIXTY_FOUR_KILOBYTES","Uint16Array","Uint32Array","addRegularGridIndices","regularGridAndEdgeIndicesCache","getRegularGridIndicesAndEdgeIndices","indicesAndEdges","edgeIndices","getEdgeIndices","westIndicesSouthToNorth","southIndicesEastToWest","eastIndicesNorthToSouth","northIndicesWestToEast","regularGridAndSkirtAndEdgeIndicesCache","getRegularGridAndSkirtIndicesAndEdgeIndices","gridVertexCount","gridIndexCount","edgeVertexCount","edgeIndexCount","Math","max","vertexCount","indexCount","createTypedArray","addSkirtIndices","indexCountWithoutSkirts","offset","vertexIndex","length","Array","i","index","j","upperLeft","lowerLeft","lowerRight","upperRight","previousIndex","heightmapTerrainQuality","getEstimatedLevelZeroGeometricErrorForAHeightmap","ellipsoid","tileImageWidth","numberOfTilesAtLevelZero","maximumRadius","PI","requestTileGeometry","getLevelMaximumGeometricError","getTileDataAvailable","loadTileDataAvailability"],"mappings":"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","sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * Provides terrain or other geometry for the surface of an ellipsoid.  The surface geometry is\n * organized into a pyramid of tiles according to a {@link TilingScheme}.  This type describes an\n * interface and is not intended to be instantiated directly.\n *\n * @alias TerrainProvider\n * @constructor\n *\n * @see EllipsoidTerrainProvider\n * @see CesiumTerrainProvider\n * @see VRTheWorldTerrainProvider\n * @see GoogleEarthEnterpriseTerrainProvider\n */\nfunction TerrainProvider() {\n  DeveloperError.throwInstantiationError();\n}\n\nObject.defineProperties(TerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error..  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof TerrainProvider.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain. This function should\n   * not be called before {@link TerrainProvider#ready} returns true.\n   * @memberof TerrainProvider.prototype\n   * @type {Credit}\n   */\n  credit: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets the tiling scheme used by the provider.  This function should\n   * not be called before {@link TerrainProvider#ready} returns true.\n   * @memberof TerrainProvider.prototype\n   * @type {TilingScheme}\n   */\n  tilingScheme: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof TerrainProvider.prototype\n   * @type {Boolean}\n   */\n  ready: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof TerrainProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.  This function should not be\n   * called before {@link TerrainProvider#ready} returns true.\n   * @memberof TerrainProvider.prototype\n   * @type {Boolean}\n   */\n  hasWaterMask: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * This function should not be called before {@link TerrainProvider#ready} returns true.\n   * @memberof TerrainProvider.prototype\n   * @type {Boolean}\n   */\n  hasVertexNormals: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles.  This function should not be called before\n   * {@link TerrainProvider#ready} returns true.  This property may be undefined if availability\n   * information is not available.\n   * @memberof TerrainProvider.prototype\n   * @type {TileAvailability}\n   */\n  availability: {\n    get: DeveloperError.throwInstantiationError,\n  },\n});\n\nvar regularGridIndicesCache = [];\n\n/**\n * Gets a list of indices for a triangle mesh representing a regular grid.  Calling\n * this function multiple times with the same grid width and height returns the\n * same list of indices.  The total number of vertices must be less than or equal\n * to 65536.\n *\n * @param {Number} width The number of vertices in the regular grid in the horizontal direction.\n * @param {Number} height The number of vertices in the regular grid in the vertical direction.\n * @returns {Uint16Array|Uint32Array} The list of indices. Uint16Array gets returned for 64KB or less and Uint32Array for 4GB or less.\n */\nTerrainProvider.getRegularGridIndices = function (width, height) {\n  //>>includeStart('debug', pragmas.debug);\n  if (width * height >= CesiumMath.FOUR_GIGABYTES) {\n    throw new DeveloperError(\n      \"The total number of vertices (width * height) must be less than 4,294,967,296.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var byWidth = regularGridIndicesCache[width];\n  if (!defined(byWidth)) {\n    regularGridIndicesCache[width] = byWidth = [];\n  }\n\n  var indices = byWidth[height];\n  if (!defined(indices)) {\n    if (width * height < CesiumMath.SIXTY_FOUR_KILOBYTES) {\n      indices = byWidth[height] = new Uint16Array(\n        (width - 1) * (height - 1) * 6\n      );\n    } else {\n      indices = byWidth[height] = new Uint32Array(\n        (width - 1) * (height - 1) * 6\n      );\n    }\n    addRegularGridIndices(width, height, indices, 0);\n  }\n\n  return indices;\n};\n\nvar regularGridAndEdgeIndicesCache = [];\n\n/**\n * @private\n */\nTerrainProvider.getRegularGridIndicesAndEdgeIndices = function (width, height) {\n  //>>includeStart('debug', pragmas.debug);\n  if (width * height >= CesiumMath.FOUR_GIGABYTES) {\n    throw new DeveloperError(\n      \"The total number of vertices (width * height) must be less than 4,294,967,296.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var byWidth = regularGridAndEdgeIndicesCache[width];\n  if (!defined(byWidth)) {\n    regularGridAndEdgeIndicesCache[width] = byWidth = [];\n  }\n\n  var indicesAndEdges = byWidth[height];\n  if (!defined(indicesAndEdges)) {\n    var indices = TerrainProvider.getRegularGridIndices(width, height);\n\n    var edgeIndices = getEdgeIndices(width, height);\n    var westIndicesSouthToNorth = edgeIndices.westIndicesSouthToNorth;\n    var southIndicesEastToWest = edgeIndices.southIndicesEastToWest;\n    var eastIndicesNorthToSouth = edgeIndices.eastIndicesNorthToSouth;\n    var northIndicesWestToEast = edgeIndices.northIndicesWestToEast;\n\n    indicesAndEdges = byWidth[height] = {\n      indices: indices,\n      westIndicesSouthToNorth: westIndicesSouthToNorth,\n      southIndicesEastToWest: southIndicesEastToWest,\n      eastIndicesNorthToSouth: eastIndicesNorthToSouth,\n      northIndicesWestToEast: northIndicesWestToEast,\n    };\n  }\n\n  return indicesAndEdges;\n};\n\nvar regularGridAndSkirtAndEdgeIndicesCache = [];\n\n/**\n * @private\n */\nTerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices = function (\n  width,\n  height\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (width * height >= CesiumMath.FOUR_GIGABYTES) {\n    throw new DeveloperError(\n      \"The total number of vertices (width * height) must be less than 4,294,967,296.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var byWidth = regularGridAndSkirtAndEdgeIndicesCache[width];\n  if (!defined(byWidth)) {\n    regularGridAndSkirtAndEdgeIndicesCache[width] = byWidth = [];\n  }\n\n  var indicesAndEdges = byWidth[height];\n  if (!defined(indicesAndEdges)) {\n    var gridVertexCount = width * height;\n    var gridIndexCount = (width - 1) * (height - 1) * 6;\n    var edgeVertexCount = width * 2 + height * 2;\n    var edgeIndexCount = Math.max(0, edgeVertexCount - 4) * 6;\n    var vertexCount = gridVertexCount + edgeVertexCount;\n    var indexCount = gridIndexCount + edgeIndexCount;\n\n    var edgeIndices = getEdgeIndices(width, height);\n    var westIndicesSouthToNorth = edgeIndices.westIndicesSouthToNorth;\n    var southIndicesEastToWest = edgeIndices.southIndicesEastToWest;\n    var eastIndicesNorthToSouth = edgeIndices.eastIndicesNorthToSouth;\n    var northIndicesWestToEast = edgeIndices.northIndicesWestToEast;\n\n    var indices = IndexDatatype.createTypedArray(vertexCount, indexCount);\n    addRegularGridIndices(width, height, indices, 0);\n    TerrainProvider.addSkirtIndices(\n      westIndicesSouthToNorth,\n      southIndicesEastToWest,\n      eastIndicesNorthToSouth,\n      northIndicesWestToEast,\n      gridVertexCount,\n      indices,\n      gridIndexCount\n    );\n\n    indicesAndEdges = byWidth[height] = {\n      indices: indices,\n      westIndicesSouthToNorth: westIndicesSouthToNorth,\n      southIndicesEastToWest: southIndicesEastToWest,\n      eastIndicesNorthToSouth: eastIndicesNorthToSouth,\n      northIndicesWestToEast: northIndicesWestToEast,\n      indexCountWithoutSkirts: gridIndexCount,\n    };\n  }\n\n  return indicesAndEdges;\n};\n\n/**\n * @private\n */\nTerrainProvider.addSkirtIndices = function (\n  westIndicesSouthToNorth,\n  southIndicesEastToWest,\n  eastIndicesNorthToSouth,\n  northIndicesWestToEast,\n  vertexCount,\n  indices,\n  offset\n) {\n  var vertexIndex = vertexCount;\n  offset = addSkirtIndices(\n    westIndicesSouthToNorth,\n    vertexIndex,\n    indices,\n    offset\n  );\n  vertexIndex += westIndicesSouthToNorth.length;\n  offset = addSkirtIndices(\n    southIndicesEastToWest,\n    vertexIndex,\n    indices,\n    offset\n  );\n  vertexIndex += southIndicesEastToWest.length;\n  offset = addSkirtIndices(\n    eastIndicesNorthToSouth,\n    vertexIndex,\n    indices,\n    offset\n  );\n  vertexIndex += eastIndicesNorthToSouth.length;\n  addSkirtIndices(northIndicesWestToEast, vertexIndex, indices, offset);\n};\n\nfunction getEdgeIndices(width, height) {\n  var westIndicesSouthToNorth = new Array(height);\n  var southIndicesEastToWest = new Array(width);\n  var eastIndicesNorthToSouth = new Array(height);\n  var northIndicesWestToEast = new Array(width);\n\n  var i;\n  for (i = 0; i < width; ++i) {\n    northIndicesWestToEast[i] = i;\n    southIndicesEastToWest[i] = width * height - 1 - i;\n  }\n\n  for (i = 0; i < height; ++i) {\n    eastIndicesNorthToSouth[i] = (i + 1) * width - 1;\n    westIndicesSouthToNorth[i] = (height - i - 1) * width;\n  }\n\n  return {\n    westIndicesSouthToNorth: westIndicesSouthToNorth,\n    southIndicesEastToWest: southIndicesEastToWest,\n    eastIndicesNorthToSouth: eastIndicesNorthToSouth,\n    northIndicesWestToEast: northIndicesWestToEast,\n  };\n}\n\nfunction addRegularGridIndices(width, height, indices, offset) {\n  var index = 0;\n  for (var j = 0; j < height - 1; ++j) {\n    for (var i = 0; i < width - 1; ++i) {\n      var upperLeft = index;\n      var lowerLeft = upperLeft + width;\n      var lowerRight = lowerLeft + 1;\n      var upperRight = upperLeft + 1;\n\n      indices[offset++] = upperLeft;\n      indices[offset++] = lowerLeft;\n      indices[offset++] = upperRight;\n      indices[offset++] = upperRight;\n      indices[offset++] = lowerLeft;\n      indices[offset++] = lowerRight;\n\n      ++index;\n    }\n    ++index;\n  }\n}\n\nfunction addSkirtIndices(edgeIndices, vertexIndex, indices, offset) {\n  var previousIndex = edgeIndices[0];\n\n  var length = edgeIndices.length;\n  for (var i = 1; i < length; ++i) {\n    var index = edgeIndices[i];\n\n    indices[offset++] = previousIndex;\n    indices[offset++] = index;\n    indices[offset++] = vertexIndex;\n\n    indices[offset++] = vertexIndex;\n    indices[offset++] = index;\n    indices[offset++] = vertexIndex + 1;\n\n    previousIndex = index;\n    ++vertexIndex;\n  }\n\n  return offset;\n}\n\n/**\n * Specifies the quality of terrain created from heightmaps.  A value of 1.0 will\n * ensure that adjacent heightmap vertices are separated by no more than\n * {@link Globe.maximumScreenSpaceError} screen pixels and will probably go very slowly.\n * A value of 0.5 will cut the estimated level zero geometric error in half, allowing twice the\n * screen pixels between adjacent heightmap vertices and thus rendering more quickly.\n * @type {Number}\n */\nTerrainProvider.heightmapTerrainQuality = 0.25;\n\n/**\n * Determines an appropriate geometric error estimate when the geometry comes from a heightmap.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to which the terrain is attached.\n * @param {Number} tileImageWidth The width, in pixels, of the heightmap associated with a single tile.\n * @param {Number} numberOfTilesAtLevelZero The number of tiles in the horizontal direction at tile level zero.\n * @returns {Number} An estimated geometric error.\n */\nTerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap = function (\n  ellipsoid,\n  tileImageWidth,\n  numberOfTilesAtLevelZero\n) {\n  return (\n    (ellipsoid.maximumRadius *\n      2 *\n      Math.PI *\n      TerrainProvider.heightmapTerrainQuality) /\n    (tileImageWidth * numberOfTilesAtLevelZero)\n  );\n};\n\n/**\n * Requests the geometry for a given tile.  This function should not be called before\n * {@link TerrainProvider#ready} returns true.  The result must include terrain data and\n * may optionally include a water mask and an indication of which child tiles are available.\n * @function\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n *\n * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n */\nTerrainProvider.prototype.requestTileGeometry =\n  DeveloperError.throwInstantiationError;\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.  This function should not be\n * called before {@link TerrainProvider#ready} returns true.\n * @function\n *\n * @param {Number} level The tile level for which to get the maximum geometric error.\n * @returns {Number} The maximum geometric error.\n */\nTerrainProvider.prototype.getLevelMaximumGeometricError =\n  DeveloperError.throwInstantiationError;\n\n/**\n * Determines whether data for a tile is available to be loaded.\n * @function\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {Boolean} Undefined if not supported by the terrain provider, otherwise true or false.\n */\nTerrainProvider.prototype.getTileDataAvailable =\n  DeveloperError.throwInstantiationError;\n\n/**\n * Makes sure we load availability data for a tile\n * @function\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {undefined|Promise} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\n */\nTerrainProvider.prototype.loadTileDataAvailability =\n  DeveloperError.throwInstantiationError;\nexport default TerrainProvider;\n"]},"metadata":{},"sourceType":"module"}