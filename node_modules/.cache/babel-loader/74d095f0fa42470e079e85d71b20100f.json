{"ast":null,"code":"import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport Event from \"../Core/Event.js\";\nimport TranslationRotationScale from \"../Core/TranslationRotationScale.js\";\nimport createPropertyDescriptor from \"./createPropertyDescriptor.js\";\nimport Property from \"./Property.js\";\nvar defaultNodeTransformation = new TranslationRotationScale();\n/**\n * A {@link Property} that produces {@link TranslationRotationScale} data.\n * @alias NodeTransformationProperty\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Property} [options.translation=Cartesian3.ZERO] A {@link Cartesian3} Property specifying the (x, y, z) translation to apply to the node.\n * @param {Property} [options.rotation=Quaternion.IDENTITY] A {@link Quaternion} Property specifying the (x, y, z, w) rotation to apply to the node.\n * @param {Property} [options.scale=new Cartesian3(1.0, 1.0, 1.0)] A {@link Cartesian3} Property specifying the (x, y, z) scaling to apply to the node.\n */\n\nfunction NodeTransformationProperty(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  this._definitionChanged = new Event();\n  this._translation = undefined;\n  this._translationSubscription = undefined;\n  this._rotation = undefined;\n  this._rotationSubscription = undefined;\n  this._scale = undefined;\n  this._scaleSubscription = undefined;\n  this.translation = options.translation;\n  this.rotation = options.rotation;\n  this.scale = options.scale;\n}\n\nObject.defineProperties(NodeTransformationProperty.prototype, {\n  /**\n   * Gets a value indicating if this property is constant.  A property is considered\n   * constant if getValue always returns the same result for the current definition.\n   * @memberof NodeTransformationProperty.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  isConstant: {\n    get: function () {\n      return Property.isConstant(this._translation) && Property.isConstant(this._rotation) && Property.isConstant(this._scale);\n    }\n  },\n\n  /**\n   * Gets the event that is raised whenever the definition of this property changes.\n   * The definition is considered to have changed if a call to getValue would return\n   * a different result for the same time.\n   * @memberof NodeTransformationProperty.prototype\n   *\n   * @type {Event}\n   * @readonly\n   */\n  definitionChanged: {\n    get: function () {\n      return this._definitionChanged;\n    }\n  },\n\n  /**\n   * Gets or sets the {@link Cartesian3} Property specifying the (x, y, z) translation to apply to the node.\n   * @memberof NodeTransformationProperty.prototype\n   * @type {Property}\n   * @default Cartesian3.ZERO\n   */\n  translation: createPropertyDescriptor(\"translation\"),\n\n  /**\n   * Gets or sets the {@link Quaternion} Property specifying the (x, y, z, w) rotation to apply to the node.\n   * @memberof NodeTransformationProperty.prototype\n   * @type {Property}\n   * @default Quaternion.IDENTITY\n   */\n  rotation: createPropertyDescriptor(\"rotation\"),\n\n  /**\n   * Gets or sets the {@link Cartesian3} Property specifying the (x, y, z) scaling to apply to the node.\n   * @memberof NodeTransformationProperty.prototype\n   * @type {Property}\n   * @default new Cartesian3(1.0, 1.0, 1.0)\n   */\n  scale: createPropertyDescriptor(\"scale\")\n});\n/**\n * Gets the value of the property at the provided time.\n *\n * @param {JulianDate} time The time for which to retrieve the value.\n * @param {TranslationRotationScale} [result] The object to store the value into, if omitted, a new instance is created and returned.\n * @returns {TranslationRotationScale} The modified result parameter or a new instance if the result parameter was not supplied.\n */\n\nNodeTransformationProperty.prototype.getValue = function (time, result) {\n  if (!defined(result)) {\n    result = new TranslationRotationScale();\n  }\n\n  result.translation = Property.getValueOrClonedDefault(this._translation, time, defaultNodeTransformation.translation, result.translation);\n  result.rotation = Property.getValueOrClonedDefault(this._rotation, time, defaultNodeTransformation.rotation, result.rotation);\n  result.scale = Property.getValueOrClonedDefault(this._scale, time, defaultNodeTransformation.scale, result.scale);\n  return result;\n};\n/**\n * Compares this property to the provided property and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Property} [other] The other property.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\n\n\nNodeTransformationProperty.prototype.equals = function (other) {\n  return this === other || other instanceof NodeTransformationProperty && Property.equals(this._translation, other._translation) && Property.equals(this._rotation, other._rotation) && Property.equals(this._scale, other._scale);\n};\n\nexport default NodeTransformationProperty;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/DataSources/NodeTransformationProperty.js"],"names":["defaultValue","defined","Event","TranslationRotationScale","createPropertyDescriptor","Property","defaultNodeTransformation","NodeTransformationProperty","options","EMPTY_OBJECT","_definitionChanged","_translation","undefined","_translationSubscription","_rotation","_rotationSubscription","_scale","_scaleSubscription","translation","rotation","scale","Object","defineProperties","prototype","isConstant","get","definitionChanged","getValue","time","result","getValueOrClonedDefault","equals","other"],"mappings":"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","sourcesContent":["import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport Event from \"../Core/Event.js\";\nimport TranslationRotationScale from \"../Core/TranslationRotationScale.js\";\nimport createPropertyDescriptor from \"./createPropertyDescriptor.js\";\nimport Property from \"./Property.js\";\n\nvar defaultNodeTransformation = new TranslationRotationScale();\n\n/**\n * A {@link Property} that produces {@link TranslationRotationScale} data.\n * @alias NodeTransformationProperty\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Property} [options.translation=Cartesian3.ZERO] A {@link Cartesian3} Property specifying the (x, y, z) translation to apply to the node.\n * @param {Property} [options.rotation=Quaternion.IDENTITY] A {@link Quaternion} Property specifying the (x, y, z, w) rotation to apply to the node.\n * @param {Property} [options.scale=new Cartesian3(1.0, 1.0, 1.0)] A {@link Cartesian3} Property specifying the (x, y, z) scaling to apply to the node.\n */\nfunction NodeTransformationProperty(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._definitionChanged = new Event();\n  this._translation = undefined;\n  this._translationSubscription = undefined;\n  this._rotation = undefined;\n  this._rotationSubscription = undefined;\n  this._scale = undefined;\n  this._scaleSubscription = undefined;\n\n  this.translation = options.translation;\n  this.rotation = options.rotation;\n  this.scale = options.scale;\n}\n\nObject.defineProperties(NodeTransformationProperty.prototype, {\n  /**\n   * Gets a value indicating if this property is constant.  A property is considered\n   * constant if getValue always returns the same result for the current definition.\n   * @memberof NodeTransformationProperty.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  isConstant: {\n    get: function () {\n      return (\n        Property.isConstant(this._translation) &&\n        Property.isConstant(this._rotation) &&\n        Property.isConstant(this._scale)\n      );\n    },\n  },\n\n  /**\n   * Gets the event that is raised whenever the definition of this property changes.\n   * The definition is considered to have changed if a call to getValue would return\n   * a different result for the same time.\n   * @memberof NodeTransformationProperty.prototype\n   *\n   * @type {Event}\n   * @readonly\n   */\n  definitionChanged: {\n    get: function () {\n      return this._definitionChanged;\n    },\n  },\n\n  /**\n   * Gets or sets the {@link Cartesian3} Property specifying the (x, y, z) translation to apply to the node.\n   * @memberof NodeTransformationProperty.prototype\n   * @type {Property}\n   * @default Cartesian3.ZERO\n   */\n  translation: createPropertyDescriptor(\"translation\"),\n\n  /**\n   * Gets or sets the {@link Quaternion} Property specifying the (x, y, z, w) rotation to apply to the node.\n   * @memberof NodeTransformationProperty.prototype\n   * @type {Property}\n   * @default Quaternion.IDENTITY\n   */\n  rotation: createPropertyDescriptor(\"rotation\"),\n\n  /**\n   * Gets or sets the {@link Cartesian3} Property specifying the (x, y, z) scaling to apply to the node.\n   * @memberof NodeTransformationProperty.prototype\n   * @type {Property}\n   * @default new Cartesian3(1.0, 1.0, 1.0)\n   */\n  scale: createPropertyDescriptor(\"scale\"),\n});\n\n/**\n * Gets the value of the property at the provided time.\n *\n * @param {JulianDate} time The time for which to retrieve the value.\n * @param {TranslationRotationScale} [result] The object to store the value into, if omitted, a new instance is created and returned.\n * @returns {TranslationRotationScale} The modified result parameter or a new instance if the result parameter was not supplied.\n */\nNodeTransformationProperty.prototype.getValue = function (time, result) {\n  if (!defined(result)) {\n    result = new TranslationRotationScale();\n  }\n\n  result.translation = Property.getValueOrClonedDefault(\n    this._translation,\n    time,\n    defaultNodeTransformation.translation,\n    result.translation\n  );\n  result.rotation = Property.getValueOrClonedDefault(\n    this._rotation,\n    time,\n    defaultNodeTransformation.rotation,\n    result.rotation\n  );\n  result.scale = Property.getValueOrClonedDefault(\n    this._scale,\n    time,\n    defaultNodeTransformation.scale,\n    result.scale\n  );\n  return result;\n};\n\n/**\n * Compares this property to the provided property and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Property} [other] The other property.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nNodeTransformationProperty.prototype.equals = function (other) {\n  return (\n    this === other ||\n    (other instanceof NodeTransformationProperty &&\n      Property.equals(this._translation, other._translation) &&\n      Property.equals(this._rotation, other._rotation) &&\n      Property.equals(this._scale, other._scale))\n  );\n};\nexport default NodeTransformationProperty;\n"]},"metadata":{},"sourceType":"module"}