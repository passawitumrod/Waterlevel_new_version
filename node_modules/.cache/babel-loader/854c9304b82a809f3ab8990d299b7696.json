{"ast":null,"code":"import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport PerspectiveOffCenterFrustum from \"../Core/PerspectiveOffCenterFrustum.js\";\nimport Ray from \"../Core/Ray.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport when from \"../ThirdParty/when.js\";\nimport Camera from \"./Camera.js\";\nimport Cesium3DTileFeature from \"./Cesium3DTileFeature.js\";\nimport Cesium3DTilePass from \"./Cesium3DTilePass.js\";\nimport Cesium3DTilePassState from \"./Cesium3DTilePassState.js\";\nimport PickDepth from \"./PickDepth.js\";\nimport PrimitiveCollection from \"./PrimitiveCollection.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport SceneTransforms from \"./SceneTransforms.js\";\nimport View from \"./View.js\";\nvar offscreenDefaultWidth = 0.1;\nvar mostDetailedPreloadTilesetPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.MOST_DETAILED_PRELOAD\n});\nvar mostDetailedPickTilesetPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.MOST_DETAILED_PICK\n});\nvar pickTilesetPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.PICK\n});\n/**\n * @private\n */\n\nfunction Picking(scene) {\n  this._mostDetailedRayPicks = [];\n  this.pickRenderStateCache = {};\n  this._pickPositionCache = {};\n  this._pickPositionCacheDirty = false;\n  var pickOffscreenViewport = new BoundingRectangle(0, 0, 1, 1);\n  var pickOffscreenCamera = new Camera(scene);\n  pickOffscreenCamera.frustum = new OrthographicFrustum({\n    width: offscreenDefaultWidth,\n    aspectRatio: 1.0,\n    near: 0.1\n  });\n  this._pickOffscreenView = new View(scene, pickOffscreenCamera, pickOffscreenViewport);\n}\n\nPicking.prototype.update = function () {\n  this._pickPositionCacheDirty = true;\n};\n\nPicking.prototype.getPickDepth = function (scene, index) {\n  var pickDepths = scene.view.pickDepths;\n  var pickDepth = pickDepths[index];\n\n  if (!defined(pickDepth)) {\n    pickDepth = new PickDepth();\n    pickDepths[index] = pickDepth;\n  }\n\n  return pickDepth;\n};\n\nvar scratchOrthoPickingFrustum = new OrthographicOffCenterFrustum();\nvar scratchOrthoOrigin = new Cartesian3();\nvar scratchOrthoDirection = new Cartesian3();\nvar scratchOrthoPixelSize = new Cartesian2();\nvar scratchOrthoPickVolumeMatrix4 = new Matrix4();\n\nfunction getPickOrthographicCullingVolume(scene, drawingBufferPosition, width, height, viewport) {\n  var camera = scene.camera;\n  var frustum = camera.frustum;\n\n  if (defined(frustum._offCenterFrustum)) {\n    frustum = frustum._offCenterFrustum;\n  }\n\n  var x = 2.0 * (drawingBufferPosition.x - viewport.x) / viewport.width - 1.0;\n  x *= (frustum.right - frustum.left) * 0.5;\n  var y = 2.0 * (viewport.height - drawingBufferPosition.y - viewport.y) / viewport.height - 1.0;\n  y *= (frustum.top - frustum.bottom) * 0.5;\n  var transform = Matrix4.clone(camera.transform, scratchOrthoPickVolumeMatrix4);\n\n  camera._setTransform(Matrix4.IDENTITY);\n\n  var origin = Cartesian3.clone(camera.position, scratchOrthoOrigin);\n  Cartesian3.multiplyByScalar(camera.right, x, scratchOrthoDirection);\n  Cartesian3.add(scratchOrthoDirection, origin, origin);\n  Cartesian3.multiplyByScalar(camera.up, y, scratchOrthoDirection);\n  Cartesian3.add(scratchOrthoDirection, origin, origin);\n\n  camera._setTransform(transform);\n\n  if (scene.mode === SceneMode.SCENE2D) {\n    Cartesian3.fromElements(origin.z, origin.x, origin.y, origin);\n  }\n\n  var pixelSize = frustum.getPixelDimensions(viewport.width, viewport.height, 1.0, 1.0, scratchOrthoPixelSize);\n  var ortho = scratchOrthoPickingFrustum;\n  ortho.right = pixelSize.x * 0.5;\n  ortho.left = -ortho.right;\n  ortho.top = pixelSize.y * 0.5;\n  ortho.bottom = -ortho.top;\n  ortho.near = frustum.near;\n  ortho.far = frustum.far;\n  return ortho.computeCullingVolume(origin, camera.directionWC, camera.upWC);\n}\n\nvar scratchPerspPickingFrustum = new PerspectiveOffCenterFrustum();\nvar scratchPerspPixelSize = new Cartesian2();\n\nfunction getPickPerspectiveCullingVolume(scene, drawingBufferPosition, width, height, viewport) {\n  var camera = scene.camera;\n  var frustum = camera.frustum;\n  var near = frustum.near;\n  var tanPhi = Math.tan(frustum.fovy * 0.5);\n  var tanTheta = frustum.aspectRatio * tanPhi;\n  var x = 2.0 * (drawingBufferPosition.x - viewport.x) / viewport.width - 1.0;\n  var y = 2.0 * (viewport.height - drawingBufferPosition.y - viewport.y) / viewport.height - 1.0;\n  var xDir = x * near * tanTheta;\n  var yDir = y * near * tanPhi;\n  var pixelSize = frustum.getPixelDimensions(viewport.width, viewport.height, 1.0, 1.0, scratchPerspPixelSize);\n  var pickWidth = pixelSize.x * width * 0.5;\n  var pickHeight = pixelSize.y * height * 0.5;\n  var offCenter = scratchPerspPickingFrustum;\n  offCenter.top = yDir + pickHeight;\n  offCenter.bottom = yDir - pickHeight;\n  offCenter.right = xDir + pickWidth;\n  offCenter.left = xDir - pickWidth;\n  offCenter.near = near;\n  offCenter.far = frustum.far;\n  return offCenter.computeCullingVolume(camera.positionWC, camera.directionWC, camera.upWC);\n}\n\nfunction getPickCullingVolume(scene, drawingBufferPosition, width, height, viewport) {\n  var frustum = scene.camera.frustum;\n\n  if (frustum instanceof OrthographicFrustum || frustum instanceof OrthographicOffCenterFrustum) {\n    return getPickOrthographicCullingVolume(scene, drawingBufferPosition, width, height, viewport);\n  }\n\n  return getPickPerspectiveCullingVolume(scene, drawingBufferPosition, width, height, viewport);\n} // pick rectangle width and height, assumed odd\n\n\nvar scratchRectangleWidth = 3.0;\nvar scratchRectangleHeight = 3.0;\nvar scratchRectangle = new BoundingRectangle(0.0, 0.0, scratchRectangleWidth, scratchRectangleHeight);\nvar scratchPosition = new Cartesian2();\nvar scratchColorZero = new Color(0.0, 0.0, 0.0, 0.0);\n\nPicking.prototype.pick = function (scene, windowPosition, width, height) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(windowPosition)) {\n    throw new DeveloperError(\"windowPosition is undefined.\");\n  } //>>includeEnd('debug');\n\n\n  scratchRectangleWidth = defaultValue(width, 3.0);\n  scratchRectangleHeight = defaultValue(height, scratchRectangleWidth);\n  var context = scene.context;\n  var us = context.uniformState;\n  var frameState = scene.frameState;\n  var view = scene.defaultView;\n  scene.view = view;\n  var viewport = view.viewport;\n  viewport.x = 0;\n  viewport.y = 0;\n  viewport.width = context.drawingBufferWidth;\n  viewport.height = context.drawingBufferHeight;\n  var passState = view.passState;\n  passState.viewport = BoundingRectangle.clone(viewport, passState.viewport);\n  var drawingBufferPosition = SceneTransforms.transformWindowToDrawingBuffer(scene, windowPosition, scratchPosition);\n  scene.jobScheduler.disableThisFrame();\n  scene.updateFrameState();\n  frameState.cullingVolume = getPickCullingVolume(scene, drawingBufferPosition, scratchRectangleWidth, scratchRectangleHeight, viewport);\n  frameState.invertClassification = false;\n  frameState.passes.pick = true;\n  frameState.tilesetPassState = pickTilesetPassState;\n  us.update(frameState);\n  scene.updateEnvironment();\n  scratchRectangle.x = drawingBufferPosition.x - (scratchRectangleWidth - 1.0) * 0.5;\n  scratchRectangle.y = scene.drawingBufferHeight - drawingBufferPosition.y - (scratchRectangleHeight - 1.0) * 0.5;\n  scratchRectangle.width = scratchRectangleWidth;\n  scratchRectangle.height = scratchRectangleHeight;\n  passState = view.pickFramebuffer.begin(scratchRectangle, view.viewport);\n  scene.updateAndExecuteCommands(passState, scratchColorZero);\n  scene.resolveFramebuffers(passState);\n  var object = view.pickFramebuffer.end(scratchRectangle);\n  context.endFrame();\n  return object;\n};\n\nfunction renderTranslucentDepthForPick(scene, drawingBufferPosition) {\n  // PERFORMANCE_IDEA: render translucent only and merge with the previous frame\n  var context = scene.context;\n  var frameState = scene.frameState;\n  var environmentState = scene.environmentState;\n  var view = scene.defaultView;\n  scene.view = view;\n  var viewport = view.viewport;\n  viewport.x = 0;\n  viewport.y = 0;\n  viewport.width = context.drawingBufferWidth;\n  viewport.height = context.drawingBufferHeight;\n  var passState = view.passState;\n  passState.viewport = BoundingRectangle.clone(viewport, passState.viewport);\n  scene.clearPasses(frameState.passes);\n  frameState.passes.pick = true;\n  frameState.passes.depth = true;\n  frameState.cullingVolume = getPickCullingVolume(scene, drawingBufferPosition, 1, 1, viewport);\n  frameState.tilesetPassState = pickTilesetPassState;\n  scene.updateEnvironment();\n  environmentState.renderTranslucentDepthForPick = true;\n  passState = view.pickDepthFramebuffer.update(context, drawingBufferPosition, viewport);\n  scene.updateAndExecuteCommands(passState, scratchColorZero);\n  scene.resolveFramebuffers(passState);\n  context.endFrame();\n}\n\nvar scratchPerspectiveFrustum = new PerspectiveFrustum();\nvar scratchPerspectiveOffCenterFrustum = new PerspectiveOffCenterFrustum();\nvar scratchOrthographicFrustum = new OrthographicFrustum();\nvar scratchOrthographicOffCenterFrustum = new OrthographicOffCenterFrustum();\n\nPicking.prototype.pickPositionWorldCoordinates = function (scene, windowPosition, result) {\n  if (!scene.useDepthPicking) {\n    return undefined;\n  } //>>includeStart('debug', pragmas.debug);\n\n\n  if (!defined(windowPosition)) {\n    throw new DeveloperError(\"windowPosition is undefined.\");\n  }\n\n  if (!scene.context.depthTexture) {\n    throw new DeveloperError(\"Picking from the depth buffer is not supported. Check pickPositionSupported.\");\n  } //>>includeEnd('debug');\n\n\n  var cacheKey = windowPosition.toString();\n\n  if (this._pickPositionCacheDirty) {\n    this._pickPositionCache = {};\n    this._pickPositionCacheDirty = false;\n  } else if (this._pickPositionCache.hasOwnProperty(cacheKey)) {\n    return Cartesian3.clone(this._pickPositionCache[cacheKey], result);\n  }\n\n  var frameState = scene.frameState;\n  var context = scene.context;\n  var uniformState = context.uniformState;\n  var view = scene.defaultView;\n  scene.view = view;\n  var drawingBufferPosition = SceneTransforms.transformWindowToDrawingBuffer(scene, windowPosition, scratchPosition);\n\n  if (scene.pickTranslucentDepth) {\n    renderTranslucentDepthForPick(scene, drawingBufferPosition);\n  } else {\n    scene.updateFrameState();\n    uniformState.update(frameState);\n    scene.updateEnvironment();\n  }\n\n  drawingBufferPosition.y = scene.drawingBufferHeight - drawingBufferPosition.y;\n  var camera = scene.camera; // Create a working frustum from the original camera frustum.\n\n  var frustum;\n\n  if (defined(camera.frustum.fov)) {\n    frustum = camera.frustum.clone(scratchPerspectiveFrustum);\n  } else if (defined(camera.frustum.infiniteProjectionMatrix)) {\n    frustum = camera.frustum.clone(scratchPerspectiveOffCenterFrustum);\n  } else if (defined(camera.frustum.width)) {\n    frustum = camera.frustum.clone(scratchOrthographicFrustum);\n  } else {\n    frustum = camera.frustum.clone(scratchOrthographicOffCenterFrustum);\n  }\n\n  var frustumCommandsList = view.frustumCommandsList;\n  var numFrustums = frustumCommandsList.length;\n\n  for (var i = 0; i < numFrustums; ++i) {\n    var pickDepth = this.getPickDepth(scene, i);\n    var depth = pickDepth.getDepth(context, drawingBufferPosition.x, drawingBufferPosition.y);\n\n    if (depth > 0.0 && depth < 1.0) {\n      var renderedFrustum = frustumCommandsList[i];\n      var height2D;\n\n      if (scene.mode === SceneMode.SCENE2D) {\n        height2D = camera.position.z;\n        camera.position.z = height2D - renderedFrustum.near + 1.0;\n        frustum.far = Math.max(1.0, renderedFrustum.far - renderedFrustum.near);\n        frustum.near = 1.0;\n        uniformState.update(frameState);\n        uniformState.updateFrustum(frustum);\n      } else {\n        frustum.near = renderedFrustum.near * (i !== 0 ? scene.opaqueFrustumNearOffset : 1.0);\n        frustum.far = renderedFrustum.far;\n        uniformState.updateFrustum(frustum);\n      }\n\n      result = SceneTransforms.drawingBufferToWgs84Coordinates(scene, drawingBufferPosition, depth, result);\n\n      if (scene.mode === SceneMode.SCENE2D) {\n        camera.position.z = height2D;\n        uniformState.update(frameState);\n      }\n\n      this._pickPositionCache[cacheKey] = Cartesian3.clone(result);\n      return result;\n    }\n  }\n\n  this._pickPositionCache[cacheKey] = undefined;\n  return undefined;\n};\n\nvar scratchPickPositionCartographic = new Cartographic();\n\nPicking.prototype.pickPosition = function (scene, windowPosition, result) {\n  result = this.pickPositionWorldCoordinates(scene, windowPosition, result);\n\n  if (defined(result) && scene.mode !== SceneMode.SCENE3D) {\n    Cartesian3.fromElements(result.y, result.z, result.x, result);\n    var projection = scene.mapProjection;\n    var ellipsoid = projection.ellipsoid;\n    var cart = projection.unproject(result, scratchPickPositionCartographic);\n    ellipsoid.cartographicToCartesian(cart, result);\n  }\n\n  return result;\n};\n\nfunction drillPick(limit, pickCallback) {\n  // PERFORMANCE_IDEA: This function calls each primitive's update for each pass. Instead\n  // we could update the primitive once, and then just execute their commands for each pass,\n  // and cull commands for picked primitives.  e.g., base on the command's owner.\n  var i;\n  var attributes;\n  var result = [];\n  var pickedPrimitives = [];\n  var pickedAttributes = [];\n  var pickedFeatures = [];\n\n  if (!defined(limit)) {\n    limit = Number.MAX_VALUE;\n  }\n\n  var pickedResult = pickCallback();\n\n  while (defined(pickedResult)) {\n    var object = pickedResult.object;\n    var position = pickedResult.position;\n    var exclude = pickedResult.exclude;\n\n    if (defined(position) && !defined(object)) {\n      result.push(pickedResult);\n      break;\n    }\n\n    if (!defined(object) || !defined(object.primitive)) {\n      break;\n    }\n\n    if (!exclude) {\n      result.push(pickedResult);\n\n      if (0 >= --limit) {\n        break;\n      }\n    }\n\n    var primitive = object.primitive;\n    var hasShowAttribute = false; // If the picked object has a show attribute, use it.\n\n    if (typeof primitive.getGeometryInstanceAttributes === \"function\") {\n      if (defined(object.id)) {\n        attributes = primitive.getGeometryInstanceAttributes(object.id);\n\n        if (defined(attributes) && defined(attributes.show)) {\n          hasShowAttribute = true;\n          attributes.show = ShowGeometryInstanceAttribute.toValue(false, attributes.show);\n          pickedAttributes.push(attributes);\n        }\n      }\n    }\n\n    if (object instanceof Cesium3DTileFeature) {\n      hasShowAttribute = true;\n      object.show = false;\n      pickedFeatures.push(object);\n    } // Otherwise, hide the entire primitive\n\n\n    if (!hasShowAttribute) {\n      primitive.show = false;\n      pickedPrimitives.push(primitive);\n    }\n\n    pickedResult = pickCallback();\n  } // Unhide everything we hid while drill picking\n\n\n  for (i = 0; i < pickedPrimitives.length; ++i) {\n    pickedPrimitives[i].show = true;\n  }\n\n  for (i = 0; i < pickedAttributes.length; ++i) {\n    attributes = pickedAttributes[i];\n    attributes.show = ShowGeometryInstanceAttribute.toValue(true, attributes.show);\n  }\n\n  for (i = 0; i < pickedFeatures.length; ++i) {\n    pickedFeatures[i].show = true;\n  }\n\n  return result;\n}\n\nPicking.prototype.drillPick = function (scene, windowPosition, limit, width, height) {\n  var that = this;\n\n  var pickCallback = function () {\n    var object = that.pick(scene, windowPosition, width, height);\n\n    if (defined(object)) {\n      return {\n        object: object,\n        position: undefined,\n        exclude: false\n      };\n    }\n  };\n\n  var objects = drillPick(limit, pickCallback);\n  return objects.map(function (element) {\n    return element.object;\n  });\n};\n\nvar scratchRight = new Cartesian3();\nvar scratchUp = new Cartesian3();\n\nfunction MostDetailedRayPick(ray, width, tilesets) {\n  this.ray = ray;\n  this.width = width;\n  this.tilesets = tilesets;\n  this.ready = false;\n  this.deferred = when.defer();\n  this.promise = this.deferred.promise;\n}\n\nfunction updateOffscreenCameraFromRay(picking, ray, width, camera) {\n  var direction = ray.direction;\n  var orthogonalAxis = Cartesian3.mostOrthogonalAxis(direction, scratchRight);\n  var right = Cartesian3.cross(direction, orthogonalAxis, scratchRight);\n  var up = Cartesian3.cross(direction, right, scratchUp);\n  camera.position = ray.origin;\n  camera.direction = direction;\n  camera.up = up;\n  camera.right = right;\n  camera.frustum.width = defaultValue(width, offscreenDefaultWidth);\n  return camera.frustum.computeCullingVolume(camera.positionWC, camera.directionWC, camera.upWC);\n}\n\nfunction updateMostDetailedRayPick(picking, scene, rayPick) {\n  var frameState = scene.frameState;\n  var ray = rayPick.ray;\n  var width = rayPick.width;\n  var tilesets = rayPick.tilesets;\n  var camera = picking._pickOffscreenView.camera;\n  var cullingVolume = updateOffscreenCameraFromRay(picking, ray, width, camera);\n  var tilesetPassState = mostDetailedPreloadTilesetPassState;\n  tilesetPassState.camera = camera;\n  tilesetPassState.cullingVolume = cullingVolume;\n  var ready = true;\n  var tilesetsLength = tilesets.length;\n\n  for (var i = 0; i < tilesetsLength; ++i) {\n    var tileset = tilesets[i];\n\n    if (tileset.show && scene.primitives.contains(tileset)) {\n      // Only update tilesets that are still contained in the scene's primitive collection and are still visible\n      // Update tilesets continually until all tilesets are ready. This way tiles are never removed from the cache.\n      tileset.updateForPass(frameState, tilesetPassState);\n      ready = ready && tilesetPassState.ready;\n    }\n  }\n\n  if (ready) {\n    rayPick.deferred.resolve();\n  }\n\n  return ready;\n}\n\nPicking.prototype.updateMostDetailedRayPicks = function (scene) {\n  // Modifies array during iteration\n  var rayPicks = this._mostDetailedRayPicks;\n\n  for (var i = 0; i < rayPicks.length; ++i) {\n    if (updateMostDetailedRayPick(this, scene, rayPicks[i])) {\n      rayPicks.splice(i--, 1);\n    }\n  }\n};\n\nfunction getTilesets(primitives, objectsToExclude, tilesets) {\n  var length = primitives.length;\n\n  for (var i = 0; i < length; ++i) {\n    var primitive = primitives.get(i);\n\n    if (primitive.show) {\n      if (defined(primitive.isCesium3DTileset)) {\n        if (!defined(objectsToExclude) || objectsToExclude.indexOf(primitive) === -1) {\n          tilesets.push(primitive);\n        }\n      } else if (primitive instanceof PrimitiveCollection) {\n        getTilesets(primitive, objectsToExclude, tilesets);\n      }\n    }\n  }\n}\n\nfunction launchMostDetailedRayPick(picking, scene, ray, objectsToExclude, width, callback) {\n  var tilesets = [];\n  getTilesets(scene.primitives, objectsToExclude, tilesets);\n\n  if (tilesets.length === 0) {\n    return when.resolve(callback());\n  }\n\n  var rayPick = new MostDetailedRayPick(ray, width, tilesets);\n\n  picking._mostDetailedRayPicks.push(rayPick);\n\n  return rayPick.promise.then(function () {\n    return callback();\n  });\n}\n\nfunction isExcluded(object, objectsToExclude) {\n  if (!defined(object) || !defined(objectsToExclude) || objectsToExclude.length === 0) {\n    return false;\n  }\n\n  return objectsToExclude.indexOf(object) > -1 || objectsToExclude.indexOf(object.primitive) > -1 || objectsToExclude.indexOf(object.id) > -1;\n}\n\nfunction getRayIntersection(picking, scene, ray, objectsToExclude, width, requirePosition, mostDetailed) {\n  var context = scene.context;\n  var uniformState = context.uniformState;\n  var frameState = scene.frameState;\n  var view = picking._pickOffscreenView;\n  scene.view = view;\n  updateOffscreenCameraFromRay(picking, ray, width, view.camera);\n  scratchRectangle = BoundingRectangle.clone(view.viewport, scratchRectangle);\n  var passState = view.pickFramebuffer.begin(scratchRectangle, view.viewport);\n  scene.jobScheduler.disableThisFrame();\n  scene.updateFrameState();\n  frameState.invertClassification = false;\n  frameState.passes.pick = true;\n  frameState.passes.offscreen = true;\n\n  if (mostDetailed) {\n    frameState.tilesetPassState = mostDetailedPickTilesetPassState;\n  } else {\n    frameState.tilesetPassState = pickTilesetPassState;\n  }\n\n  uniformState.update(frameState);\n  scene.updateEnvironment();\n  scene.updateAndExecuteCommands(passState, scratchColorZero);\n  scene.resolveFramebuffers(passState);\n  var position;\n  var object = view.pickFramebuffer.end(context);\n\n  if (scene.context.depthTexture) {\n    var numFrustums = view.frustumCommandsList.length;\n\n    for (var i = 0; i < numFrustums; ++i) {\n      var pickDepth = picking.getPickDepth(scene, i);\n      var depth = pickDepth.getDepth(context, 0, 0);\n\n      if (depth > 0.0 && depth < 1.0) {\n        var renderedFrustum = view.frustumCommandsList[i];\n        var near = renderedFrustum.near * (i !== 0 ? scene.opaqueFrustumNearOffset : 1.0);\n        var far = renderedFrustum.far;\n        var distance = near + depth * (far - near);\n        position = Ray.getPoint(ray, distance);\n        break;\n      }\n    }\n  }\n\n  scene.view = scene.defaultView;\n  context.endFrame();\n\n  if (defined(object) || defined(position)) {\n    return {\n      object: object,\n      position: position,\n      exclude: !defined(position) && requirePosition || isExcluded(object, objectsToExclude)\n    };\n  }\n}\n\nfunction getRayIntersections(picking, scene, ray, limit, objectsToExclude, width, requirePosition, mostDetailed) {\n  var pickCallback = function () {\n    return getRayIntersection(picking, scene, ray, objectsToExclude, width, requirePosition, mostDetailed);\n  };\n\n  return drillPick(limit, pickCallback);\n}\n\nfunction pickFromRay(picking, scene, ray, objectsToExclude, width, requirePosition, mostDetailed) {\n  var results = getRayIntersections(picking, scene, ray, 1, objectsToExclude, width, requirePosition, mostDetailed);\n\n  if (results.length > 0) {\n    return results[0];\n  }\n}\n\nfunction drillPickFromRay(picking, scene, ray, limit, objectsToExclude, width, requirePosition, mostDetailed) {\n  return getRayIntersections(picking, scene, ray, limit, objectsToExclude, width, requirePosition, mostDetailed);\n}\n\nfunction deferPromiseUntilPostRender(scene, promise) {\n  // Resolve promise after scene's postRender in case entities are created when the promise resolves.\n  // Entities can't be created between viewer._onTick and viewer._postRender.\n  var deferred = when.defer();\n  promise.then(function (result) {\n    var removeCallback = scene.postRender.addEventListener(function () {\n      deferred.resolve(result);\n      removeCallback();\n    });\n    scene.requestRender();\n  }).otherwise(function (error) {\n    deferred.reject(error);\n  });\n  return deferred.promise;\n}\n\nPicking.prototype.pickFromRay = function (scene, ray, objectsToExclude, width) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"ray\", ray);\n\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\"Ray intersections are only supported in 3D mode.\");\n  } //>>includeEnd('debug');\n\n\n  return pickFromRay(this, scene, ray, objectsToExclude, width, false, false);\n};\n\nPicking.prototype.drillPickFromRay = function (scene, ray, limit, objectsToExclude, width) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"ray\", ray);\n\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\"Ray intersections are only supported in 3D mode.\");\n  } //>>includeEnd('debug');\n\n\n  return drillPickFromRay(this, scene, ray, limit, objectsToExclude, width, false, false);\n};\n\nPicking.prototype.pickFromRayMostDetailed = function (scene, ray, objectsToExclude, width) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"ray\", ray);\n\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\"Ray intersections are only supported in 3D mode.\");\n  } //>>includeEnd('debug');\n\n\n  var that = this;\n  ray = Ray.clone(ray);\n  objectsToExclude = defined(objectsToExclude) ? objectsToExclude.slice() : objectsToExclude;\n  return deferPromiseUntilPostRender(scene, launchMostDetailedRayPick(that, scene, ray, objectsToExclude, width, function () {\n    return pickFromRay(that, scene, ray, objectsToExclude, width, false, true);\n  }));\n};\n\nPicking.prototype.drillPickFromRayMostDetailed = function (scene, ray, limit, objectsToExclude, width) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"ray\", ray);\n\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\"Ray intersections are only supported in 3D mode.\");\n  } //>>includeEnd('debug');\n\n\n  var that = this;\n  ray = Ray.clone(ray);\n  objectsToExclude = defined(objectsToExclude) ? objectsToExclude.slice() : objectsToExclude;\n  return deferPromiseUntilPostRender(scene, launchMostDetailedRayPick(that, scene, ray, objectsToExclude, width, function () {\n    return drillPickFromRay(that, scene, ray, limit, objectsToExclude, width, false, true);\n  }));\n};\n\nvar scratchSurfacePosition = new Cartesian3();\nvar scratchSurfaceNormal = new Cartesian3();\nvar scratchSurfaceRay = new Ray();\nvar scratchCartographic = new Cartographic();\n\nfunction getRayForSampleHeight(scene, cartographic) {\n  var globe = scene.globe;\n  var ellipsoid = defined(globe) ? globe.ellipsoid : scene.mapProjection.ellipsoid;\n  var height = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n  var surfaceNormal = ellipsoid.geodeticSurfaceNormalCartographic(cartographic, scratchSurfaceNormal);\n  var surfacePosition = Cartographic.toCartesian(cartographic, ellipsoid, scratchSurfacePosition);\n  var surfaceRay = scratchSurfaceRay;\n  surfaceRay.origin = surfacePosition;\n  surfaceRay.direction = surfaceNormal;\n  var ray = new Ray();\n  Ray.getPoint(surfaceRay, height, ray.origin);\n  Cartesian3.negate(surfaceNormal, ray.direction);\n  return ray;\n}\n\nfunction getRayForClampToHeight(scene, cartesian) {\n  var globe = scene.globe;\n  var ellipsoid = defined(globe) ? globe.ellipsoid : scene.mapProjection.ellipsoid;\n  var cartographic = Cartographic.fromCartesian(cartesian, ellipsoid, scratchCartographic);\n  return getRayForSampleHeight(scene, cartographic);\n}\n\nfunction getHeightFromCartesian(scene, cartesian) {\n  var globe = scene.globe;\n  var ellipsoid = defined(globe) ? globe.ellipsoid : scene.mapProjection.ellipsoid;\n  var cartographic = Cartographic.fromCartesian(cartesian, ellipsoid, scratchCartographic);\n  return cartographic.height;\n}\n\nfunction sampleHeightMostDetailed(picking, scene, cartographic, objectsToExclude, width) {\n  var ray = getRayForSampleHeight(scene, cartographic);\n  return launchMostDetailedRayPick(picking, scene, ray, objectsToExclude, width, function () {\n    var pickResult = pickFromRay(picking, scene, ray, objectsToExclude, width, true, true);\n\n    if (defined(pickResult)) {\n      return getHeightFromCartesian(scene, pickResult.position);\n    }\n  });\n}\n\nfunction clampToHeightMostDetailed(picking, scene, cartesian, objectsToExclude, width, result) {\n  var ray = getRayForClampToHeight(scene, cartesian);\n  return launchMostDetailedRayPick(picking, scene, ray, objectsToExclude, width, function () {\n    var pickResult = pickFromRay(picking, scene, ray, objectsToExclude, width, true, true);\n\n    if (defined(pickResult)) {\n      return Cartesian3.clone(pickResult.position, result);\n    }\n  });\n}\n\nPicking.prototype.sampleHeight = function (scene, position, objectsToExclude, width) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"position\", position);\n\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\"sampleHeight is only supported in 3D mode.\");\n  }\n\n  if (!scene.sampleHeightSupported) {\n    throw new DeveloperError(\"sampleHeight requires depth texture support. Check sampleHeightSupported.\");\n  } //>>includeEnd('debug');\n\n\n  var ray = getRayForSampleHeight(scene, position);\n  var pickResult = pickFromRay(this, scene, ray, objectsToExclude, width, true, false);\n\n  if (defined(pickResult)) {\n    return getHeightFromCartesian(scene, pickResult.position);\n  }\n};\n\nPicking.prototype.clampToHeight = function (scene, cartesian, objectsToExclude, width, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian);\n\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\"clampToHeight is only supported in 3D mode.\");\n  }\n\n  if (!scene.clampToHeightSupported) {\n    throw new DeveloperError(\"clampToHeight requires depth texture support. Check clampToHeightSupported.\");\n  } //>>includeEnd('debug');\n\n\n  var ray = getRayForClampToHeight(scene, cartesian);\n  var pickResult = pickFromRay(this, scene, ray, objectsToExclude, width, true, false);\n\n  if (defined(pickResult)) {\n    return Cartesian3.clone(pickResult.position, result);\n  }\n};\n\nPicking.prototype.sampleHeightMostDetailed = function (scene, positions, objectsToExclude, width) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"positions\", positions);\n\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\"sampleHeightMostDetailed is only supported in 3D mode.\");\n  }\n\n  if (!scene.sampleHeightSupported) {\n    throw new DeveloperError(\"sampleHeightMostDetailed requires depth texture support. Check sampleHeightSupported.\");\n  } //>>includeEnd('debug');\n\n\n  objectsToExclude = defined(objectsToExclude) ? objectsToExclude.slice() : objectsToExclude;\n  var length = positions.length;\n  var promises = new Array(length);\n\n  for (var i = 0; i < length; ++i) {\n    promises[i] = sampleHeightMostDetailed(this, scene, positions[i], objectsToExclude, width);\n  }\n\n  return deferPromiseUntilPostRender(scene, when.all(promises).then(function (heights) {\n    var length = heights.length;\n\n    for (var i = 0; i < length; ++i) {\n      positions[i].height = heights[i];\n    }\n\n    return positions;\n  }));\n};\n\nPicking.prototype.clampToHeightMostDetailed = function (scene, cartesians, objectsToExclude, width) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\"clampToHeightMostDetailed is only supported in 3D mode.\");\n  }\n\n  if (!scene.clampToHeightSupported) {\n    throw new DeveloperError(\"clampToHeightMostDetailed requires depth texture support. Check clampToHeightSupported.\");\n  } //>>includeEnd('debug');\n\n\n  objectsToExclude = defined(objectsToExclude) ? objectsToExclude.slice() : objectsToExclude;\n  var length = cartesians.length;\n  var promises = new Array(length);\n\n  for (var i = 0; i < length; ++i) {\n    promises[i] = clampToHeightMostDetailed(this, scene, cartesians[i], objectsToExclude, width, cartesians[i]);\n  }\n\n  return deferPromiseUntilPostRender(scene, when.all(promises).then(function (clampedCartesians) {\n    var length = clampedCartesians.length;\n\n    for (var i = 0; i < length; ++i) {\n      cartesians[i] = clampedCartesians[i];\n    }\n\n    return cartesians;\n  }));\n};\n\nPicking.prototype.destroy = function () {\n  this._pickOffscreenView = this._pickOffscreenView && this._pickOffscreenView.destroy();\n};\n\nexport default Picking;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Scene/Picking.js"],"names":["ApproximateTerrainHeights","BoundingRectangle","Cartesian2","Cartesian3","Cartographic","Check","Color","defaultValue","defined","DeveloperError","Matrix4","OrthographicFrustum","OrthographicOffCenterFrustum","PerspectiveFrustum","PerspectiveOffCenterFrustum","Ray","ShowGeometryInstanceAttribute","when","Camera","Cesium3DTileFeature","Cesium3DTilePass","Cesium3DTilePassState","PickDepth","PrimitiveCollection","SceneMode","SceneTransforms","View","offscreenDefaultWidth","mostDetailedPreloadTilesetPassState","pass","MOST_DETAILED_PRELOAD","mostDetailedPickTilesetPassState","MOST_DETAILED_PICK","pickTilesetPassState","PICK","Picking","scene","_mostDetailedRayPicks","pickRenderStateCache","_pickPositionCache","_pickPositionCacheDirty","pickOffscreenViewport","pickOffscreenCamera","frustum","width","aspectRatio","near","_pickOffscreenView","prototype","update","getPickDepth","index","pickDepths","view","pickDepth","scratchOrthoPickingFrustum","scratchOrthoOrigin","scratchOrthoDirection","scratchOrthoPixelSize","scratchOrthoPickVolumeMatrix4","getPickOrthographicCullingVolume","drawingBufferPosition","height","viewport","camera","_offCenterFrustum","x","right","left","y","top","bottom","transform","clone","_setTransform","IDENTITY","origin","position","multiplyByScalar","add","up","mode","SCENE2D","fromElements","z","pixelSize","getPixelDimensions","ortho","far","computeCullingVolume","directionWC","upWC","scratchPerspPickingFrustum","scratchPerspPixelSize","getPickPerspectiveCullingVolume","tanPhi","Math","tan","fovy","tanTheta","xDir","yDir","pickWidth","pickHeight","offCenter","positionWC","getPickCullingVolume","scratchRectangleWidth","scratchRectangleHeight","scratchRectangle","scratchPosition","scratchColorZero","pick","windowPosition","context","us","uniformState","frameState","defaultView","drawingBufferWidth","drawingBufferHeight","passState","transformWindowToDrawingBuffer","jobScheduler","disableThisFrame","updateFrameState","cullingVolume","invertClassification","passes","tilesetPassState","updateEnvironment","pickFramebuffer","begin","updateAndExecuteCommands","resolveFramebuffers","object","end","endFrame","renderTranslucentDepthForPick","environmentState","clearPasses","depth","pickDepthFramebuffer","scratchPerspectiveFrustum","scratchPerspectiveOffCenterFrustum","scratchOrthographicFrustum","scratchOrthographicOffCenterFrustum","pickPositionWorldCoordinates","result","useDepthPicking","undefined","depthTexture","cacheKey","toString","hasOwnProperty","pickTranslucentDepth","fov","infiniteProjectionMatrix","frustumCommandsList","numFrustums","length","i","getDepth","renderedFrustum","height2D","max","updateFrustum","opaqueFrustumNearOffset","drawingBufferToWgs84Coordinates","scratchPickPositionCartographic","pickPosition","SCENE3D","projection","mapProjection","ellipsoid","cart","unproject","cartographicToCartesian","drillPick","limit","pickCallback","attributes","pickedPrimitives","pickedAttributes","pickedFeatures","Number","MAX_VALUE","pickedResult","exclude","push","primitive","hasShowAttribute","getGeometryInstanceAttributes","id","show","toValue","that","objects","map","element","scratchRight","scratchUp","MostDetailedRayPick","ray","tilesets","ready","deferred","defer","promise","updateOffscreenCameraFromRay","picking","direction","orthogonalAxis","mostOrthogonalAxis","cross","updateMostDetailedRayPick","rayPick","tilesetsLength","tileset","primitives","contains","updateForPass","resolve","updateMostDetailedRayPicks","rayPicks","splice","getTilesets","objectsToExclude","get","isCesium3DTileset","indexOf","launchMostDetailedRayPick","callback","then","isExcluded","getRayIntersection","requirePosition","mostDetailed","offscreen","distance","getPoint","getRayIntersections","pickFromRay","results","drillPickFromRay","deferPromiseUntilPostRender","removeCallback","postRender","addEventListener","requestRender","otherwise","error","reject","pickFromRayMostDetailed","slice","drillPickFromRayMostDetailed","scratchSurfacePosition","scratchSurfaceNormal","scratchSurfaceRay","scratchCartographic","getRayForSampleHeight","cartographic","globe","_defaultMaxTerrainHeight","surfaceNormal","geodeticSurfaceNormalCartographic","surfacePosition","toCartesian","surfaceRay","negate","getRayForClampToHeight","cartesian","fromCartesian","getHeightFromCartesian","sampleHeightMostDetailed","pickResult","clampToHeightMostDetailed","sampleHeight","sampleHeightSupported","clampToHeight","clampToHeightSupported","positions","promises","Array","all","heights","cartesians","clampedCartesians","destroy"],"mappings":"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","sourcesContent":["import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport PerspectiveOffCenterFrustum from \"../Core/PerspectiveOffCenterFrustum.js\";\nimport Ray from \"../Core/Ray.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport when from \"../ThirdParty/when.js\";\nimport Camera from \"./Camera.js\";\nimport Cesium3DTileFeature from \"./Cesium3DTileFeature.js\";\nimport Cesium3DTilePass from \"./Cesium3DTilePass.js\";\nimport Cesium3DTilePassState from \"./Cesium3DTilePassState.js\";\nimport PickDepth from \"./PickDepth.js\";\nimport PrimitiveCollection from \"./PrimitiveCollection.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport SceneTransforms from \"./SceneTransforms.js\";\nimport View from \"./View.js\";\n\nvar offscreenDefaultWidth = 0.1;\n\nvar mostDetailedPreloadTilesetPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.MOST_DETAILED_PRELOAD,\n});\n\nvar mostDetailedPickTilesetPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.MOST_DETAILED_PICK,\n});\n\nvar pickTilesetPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.PICK,\n});\n\n/**\n * @private\n */\nfunction Picking(scene) {\n  this._mostDetailedRayPicks = [];\n  this.pickRenderStateCache = {};\n  this._pickPositionCache = {};\n  this._pickPositionCacheDirty = false;\n\n  var pickOffscreenViewport = new BoundingRectangle(0, 0, 1, 1);\n  var pickOffscreenCamera = new Camera(scene);\n  pickOffscreenCamera.frustum = new OrthographicFrustum({\n    width: offscreenDefaultWidth,\n    aspectRatio: 1.0,\n    near: 0.1,\n  });\n\n  this._pickOffscreenView = new View(\n    scene,\n    pickOffscreenCamera,\n    pickOffscreenViewport\n  );\n}\n\nPicking.prototype.update = function () {\n  this._pickPositionCacheDirty = true;\n};\n\nPicking.prototype.getPickDepth = function (scene, index) {\n  var pickDepths = scene.view.pickDepths;\n  var pickDepth = pickDepths[index];\n  if (!defined(pickDepth)) {\n    pickDepth = new PickDepth();\n    pickDepths[index] = pickDepth;\n  }\n  return pickDepth;\n};\n\nvar scratchOrthoPickingFrustum = new OrthographicOffCenterFrustum();\nvar scratchOrthoOrigin = new Cartesian3();\nvar scratchOrthoDirection = new Cartesian3();\nvar scratchOrthoPixelSize = new Cartesian2();\nvar scratchOrthoPickVolumeMatrix4 = new Matrix4();\n\nfunction getPickOrthographicCullingVolume(\n  scene,\n  drawingBufferPosition,\n  width,\n  height,\n  viewport\n) {\n  var camera = scene.camera;\n  var frustum = camera.frustum;\n  if (defined(frustum._offCenterFrustum)) {\n    frustum = frustum._offCenterFrustum;\n  }\n\n  var x = (2.0 * (drawingBufferPosition.x - viewport.x)) / viewport.width - 1.0;\n  x *= (frustum.right - frustum.left) * 0.5;\n  var y =\n    (2.0 * (viewport.height - drawingBufferPosition.y - viewport.y)) /\n      viewport.height -\n    1.0;\n  y *= (frustum.top - frustum.bottom) * 0.5;\n\n  var transform = Matrix4.clone(\n    camera.transform,\n    scratchOrthoPickVolumeMatrix4\n  );\n  camera._setTransform(Matrix4.IDENTITY);\n\n  var origin = Cartesian3.clone(camera.position, scratchOrthoOrigin);\n  Cartesian3.multiplyByScalar(camera.right, x, scratchOrthoDirection);\n  Cartesian3.add(scratchOrthoDirection, origin, origin);\n  Cartesian3.multiplyByScalar(camera.up, y, scratchOrthoDirection);\n  Cartesian3.add(scratchOrthoDirection, origin, origin);\n\n  camera._setTransform(transform);\n\n  if (scene.mode === SceneMode.SCENE2D) {\n    Cartesian3.fromElements(origin.z, origin.x, origin.y, origin);\n  }\n\n  var pixelSize = frustum.getPixelDimensions(\n    viewport.width,\n    viewport.height,\n    1.0,\n    1.0,\n    scratchOrthoPixelSize\n  );\n\n  var ortho = scratchOrthoPickingFrustum;\n  ortho.right = pixelSize.x * 0.5;\n  ortho.left = -ortho.right;\n  ortho.top = pixelSize.y * 0.5;\n  ortho.bottom = -ortho.top;\n  ortho.near = frustum.near;\n  ortho.far = frustum.far;\n\n  return ortho.computeCullingVolume(origin, camera.directionWC, camera.upWC);\n}\n\nvar scratchPerspPickingFrustum = new PerspectiveOffCenterFrustum();\nvar scratchPerspPixelSize = new Cartesian2();\n\nfunction getPickPerspectiveCullingVolume(\n  scene,\n  drawingBufferPosition,\n  width,\n  height,\n  viewport\n) {\n  var camera = scene.camera;\n  var frustum = camera.frustum;\n  var near = frustum.near;\n\n  var tanPhi = Math.tan(frustum.fovy * 0.5);\n  var tanTheta = frustum.aspectRatio * tanPhi;\n\n  var x = (2.0 * (drawingBufferPosition.x - viewport.x)) / viewport.width - 1.0;\n  var y =\n    (2.0 * (viewport.height - drawingBufferPosition.y - viewport.y)) /\n      viewport.height -\n    1.0;\n\n  var xDir = x * near * tanTheta;\n  var yDir = y * near * tanPhi;\n\n  var pixelSize = frustum.getPixelDimensions(\n    viewport.width,\n    viewport.height,\n    1.0,\n    1.0,\n    scratchPerspPixelSize\n  );\n  var pickWidth = pixelSize.x * width * 0.5;\n  var pickHeight = pixelSize.y * height * 0.5;\n\n  var offCenter = scratchPerspPickingFrustum;\n  offCenter.top = yDir + pickHeight;\n  offCenter.bottom = yDir - pickHeight;\n  offCenter.right = xDir + pickWidth;\n  offCenter.left = xDir - pickWidth;\n  offCenter.near = near;\n  offCenter.far = frustum.far;\n\n  return offCenter.computeCullingVolume(\n    camera.positionWC,\n    camera.directionWC,\n    camera.upWC\n  );\n}\n\nfunction getPickCullingVolume(\n  scene,\n  drawingBufferPosition,\n  width,\n  height,\n  viewport\n) {\n  var frustum = scene.camera.frustum;\n  if (\n    frustum instanceof OrthographicFrustum ||\n    frustum instanceof OrthographicOffCenterFrustum\n  ) {\n    return getPickOrthographicCullingVolume(\n      scene,\n      drawingBufferPosition,\n      width,\n      height,\n      viewport\n    );\n  }\n\n  return getPickPerspectiveCullingVolume(\n    scene,\n    drawingBufferPosition,\n    width,\n    height,\n    viewport\n  );\n}\n\n// pick rectangle width and height, assumed odd\nvar scratchRectangleWidth = 3.0;\nvar scratchRectangleHeight = 3.0;\nvar scratchRectangle = new BoundingRectangle(\n  0.0,\n  0.0,\n  scratchRectangleWidth,\n  scratchRectangleHeight\n);\nvar scratchPosition = new Cartesian2();\nvar scratchColorZero = new Color(0.0, 0.0, 0.0, 0.0);\n\nPicking.prototype.pick = function (scene, windowPosition, width, height) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(windowPosition)) {\n    throw new DeveloperError(\"windowPosition is undefined.\");\n  }\n  //>>includeEnd('debug');\n\n  scratchRectangleWidth = defaultValue(width, 3.0);\n  scratchRectangleHeight = defaultValue(height, scratchRectangleWidth);\n\n  var context = scene.context;\n  var us = context.uniformState;\n  var frameState = scene.frameState;\n\n  var view = scene.defaultView;\n  scene.view = view;\n\n  var viewport = view.viewport;\n  viewport.x = 0;\n  viewport.y = 0;\n  viewport.width = context.drawingBufferWidth;\n  viewport.height = context.drawingBufferHeight;\n\n  var passState = view.passState;\n  passState.viewport = BoundingRectangle.clone(viewport, passState.viewport);\n\n  var drawingBufferPosition = SceneTransforms.transformWindowToDrawingBuffer(\n    scene,\n    windowPosition,\n    scratchPosition\n  );\n\n  scene.jobScheduler.disableThisFrame();\n\n  scene.updateFrameState();\n  frameState.cullingVolume = getPickCullingVolume(\n    scene,\n    drawingBufferPosition,\n    scratchRectangleWidth,\n    scratchRectangleHeight,\n    viewport\n  );\n  frameState.invertClassification = false;\n  frameState.passes.pick = true;\n  frameState.tilesetPassState = pickTilesetPassState;\n\n  us.update(frameState);\n\n  scene.updateEnvironment();\n\n  scratchRectangle.x =\n    drawingBufferPosition.x - (scratchRectangleWidth - 1.0) * 0.5;\n  scratchRectangle.y =\n    scene.drawingBufferHeight -\n    drawingBufferPosition.y -\n    (scratchRectangleHeight - 1.0) * 0.5;\n  scratchRectangle.width = scratchRectangleWidth;\n  scratchRectangle.height = scratchRectangleHeight;\n  passState = view.pickFramebuffer.begin(scratchRectangle, view.viewport);\n\n  scene.updateAndExecuteCommands(passState, scratchColorZero);\n  scene.resolveFramebuffers(passState);\n\n  var object = view.pickFramebuffer.end(scratchRectangle);\n  context.endFrame();\n  return object;\n};\n\nfunction renderTranslucentDepthForPick(scene, drawingBufferPosition) {\n  // PERFORMANCE_IDEA: render translucent only and merge with the previous frame\n  var context = scene.context;\n  var frameState = scene.frameState;\n  var environmentState = scene.environmentState;\n\n  var view = scene.defaultView;\n  scene.view = view;\n\n  var viewport = view.viewport;\n  viewport.x = 0;\n  viewport.y = 0;\n  viewport.width = context.drawingBufferWidth;\n  viewport.height = context.drawingBufferHeight;\n\n  var passState = view.passState;\n  passState.viewport = BoundingRectangle.clone(viewport, passState.viewport);\n\n  scene.clearPasses(frameState.passes);\n  frameState.passes.pick = true;\n  frameState.passes.depth = true;\n  frameState.cullingVolume = getPickCullingVolume(\n    scene,\n    drawingBufferPosition,\n    1,\n    1,\n    viewport\n  );\n  frameState.tilesetPassState = pickTilesetPassState;\n\n  scene.updateEnvironment();\n  environmentState.renderTranslucentDepthForPick = true;\n  passState = view.pickDepthFramebuffer.update(\n    context,\n    drawingBufferPosition,\n    viewport\n  );\n\n  scene.updateAndExecuteCommands(passState, scratchColorZero);\n  scene.resolveFramebuffers(passState);\n\n  context.endFrame();\n}\n\nvar scratchPerspectiveFrustum = new PerspectiveFrustum();\nvar scratchPerspectiveOffCenterFrustum = new PerspectiveOffCenterFrustum();\nvar scratchOrthographicFrustum = new OrthographicFrustum();\nvar scratchOrthographicOffCenterFrustum = new OrthographicOffCenterFrustum();\n\nPicking.prototype.pickPositionWorldCoordinates = function (\n  scene,\n  windowPosition,\n  result\n) {\n  if (!scene.useDepthPicking) {\n    return undefined;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(windowPosition)) {\n    throw new DeveloperError(\"windowPosition is undefined.\");\n  }\n  if (!scene.context.depthTexture) {\n    throw new DeveloperError(\n      \"Picking from the depth buffer is not supported. Check pickPositionSupported.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var cacheKey = windowPosition.toString();\n\n  if (this._pickPositionCacheDirty) {\n    this._pickPositionCache = {};\n    this._pickPositionCacheDirty = false;\n  } else if (this._pickPositionCache.hasOwnProperty(cacheKey)) {\n    return Cartesian3.clone(this._pickPositionCache[cacheKey], result);\n  }\n\n  var frameState = scene.frameState;\n  var context = scene.context;\n  var uniformState = context.uniformState;\n\n  var view = scene.defaultView;\n  scene.view = view;\n\n  var drawingBufferPosition = SceneTransforms.transformWindowToDrawingBuffer(\n    scene,\n    windowPosition,\n    scratchPosition\n  );\n  if (scene.pickTranslucentDepth) {\n    renderTranslucentDepthForPick(scene, drawingBufferPosition);\n  } else {\n    scene.updateFrameState();\n    uniformState.update(frameState);\n    scene.updateEnvironment();\n  }\n  drawingBufferPosition.y = scene.drawingBufferHeight - drawingBufferPosition.y;\n\n  var camera = scene.camera;\n\n  // Create a working frustum from the original camera frustum.\n  var frustum;\n  if (defined(camera.frustum.fov)) {\n    frustum = camera.frustum.clone(scratchPerspectiveFrustum);\n  } else if (defined(camera.frustum.infiniteProjectionMatrix)) {\n    frustum = camera.frustum.clone(scratchPerspectiveOffCenterFrustum);\n  } else if (defined(camera.frustum.width)) {\n    frustum = camera.frustum.clone(scratchOrthographicFrustum);\n  } else {\n    frustum = camera.frustum.clone(scratchOrthographicOffCenterFrustum);\n  }\n\n  var frustumCommandsList = view.frustumCommandsList;\n  var numFrustums = frustumCommandsList.length;\n  for (var i = 0; i < numFrustums; ++i) {\n    var pickDepth = this.getPickDepth(scene, i);\n    var depth = pickDepth.getDepth(\n      context,\n      drawingBufferPosition.x,\n      drawingBufferPosition.y\n    );\n    if (depth > 0.0 && depth < 1.0) {\n      var renderedFrustum = frustumCommandsList[i];\n      var height2D;\n      if (scene.mode === SceneMode.SCENE2D) {\n        height2D = camera.position.z;\n        camera.position.z = height2D - renderedFrustum.near + 1.0;\n        frustum.far = Math.max(1.0, renderedFrustum.far - renderedFrustum.near);\n        frustum.near = 1.0;\n        uniformState.update(frameState);\n        uniformState.updateFrustum(frustum);\n      } else {\n        frustum.near =\n          renderedFrustum.near *\n          (i !== 0 ? scene.opaqueFrustumNearOffset : 1.0);\n        frustum.far = renderedFrustum.far;\n        uniformState.updateFrustum(frustum);\n      }\n\n      result = SceneTransforms.drawingBufferToWgs84Coordinates(\n        scene,\n        drawingBufferPosition,\n        depth,\n        result\n      );\n\n      if (scene.mode === SceneMode.SCENE2D) {\n        camera.position.z = height2D;\n        uniformState.update(frameState);\n      }\n\n      this._pickPositionCache[cacheKey] = Cartesian3.clone(result);\n      return result;\n    }\n  }\n\n  this._pickPositionCache[cacheKey] = undefined;\n  return undefined;\n};\n\nvar scratchPickPositionCartographic = new Cartographic();\n\nPicking.prototype.pickPosition = function (scene, windowPosition, result) {\n  result = this.pickPositionWorldCoordinates(scene, windowPosition, result);\n  if (defined(result) && scene.mode !== SceneMode.SCENE3D) {\n    Cartesian3.fromElements(result.y, result.z, result.x, result);\n\n    var projection = scene.mapProjection;\n    var ellipsoid = projection.ellipsoid;\n\n    var cart = projection.unproject(result, scratchPickPositionCartographic);\n    ellipsoid.cartographicToCartesian(cart, result);\n  }\n\n  return result;\n};\n\nfunction drillPick(limit, pickCallback) {\n  // PERFORMANCE_IDEA: This function calls each primitive's update for each pass. Instead\n  // we could update the primitive once, and then just execute their commands for each pass,\n  // and cull commands for picked primitives.  e.g., base on the command's owner.\n  var i;\n  var attributes;\n  var result = [];\n  var pickedPrimitives = [];\n  var pickedAttributes = [];\n  var pickedFeatures = [];\n  if (!defined(limit)) {\n    limit = Number.MAX_VALUE;\n  }\n\n  var pickedResult = pickCallback();\n  while (defined(pickedResult)) {\n    var object = pickedResult.object;\n    var position = pickedResult.position;\n    var exclude = pickedResult.exclude;\n\n    if (defined(position) && !defined(object)) {\n      result.push(pickedResult);\n      break;\n    }\n\n    if (!defined(object) || !defined(object.primitive)) {\n      break;\n    }\n\n    if (!exclude) {\n      result.push(pickedResult);\n      if (0 >= --limit) {\n        break;\n      }\n    }\n\n    var primitive = object.primitive;\n    var hasShowAttribute = false;\n\n    // If the picked object has a show attribute, use it.\n    if (typeof primitive.getGeometryInstanceAttributes === \"function\") {\n      if (defined(object.id)) {\n        attributes = primitive.getGeometryInstanceAttributes(object.id);\n        if (defined(attributes) && defined(attributes.show)) {\n          hasShowAttribute = true;\n          attributes.show = ShowGeometryInstanceAttribute.toValue(\n            false,\n            attributes.show\n          );\n          pickedAttributes.push(attributes);\n        }\n      }\n    }\n\n    if (object instanceof Cesium3DTileFeature) {\n      hasShowAttribute = true;\n      object.show = false;\n      pickedFeatures.push(object);\n    }\n\n    // Otherwise, hide the entire primitive\n    if (!hasShowAttribute) {\n      primitive.show = false;\n      pickedPrimitives.push(primitive);\n    }\n\n    pickedResult = pickCallback();\n  }\n\n  // Unhide everything we hid while drill picking\n  for (i = 0; i < pickedPrimitives.length; ++i) {\n    pickedPrimitives[i].show = true;\n  }\n\n  for (i = 0; i < pickedAttributes.length; ++i) {\n    attributes = pickedAttributes[i];\n    attributes.show = ShowGeometryInstanceAttribute.toValue(\n      true,\n      attributes.show\n    );\n  }\n\n  for (i = 0; i < pickedFeatures.length; ++i) {\n    pickedFeatures[i].show = true;\n  }\n\n  return result;\n}\n\nPicking.prototype.drillPick = function (\n  scene,\n  windowPosition,\n  limit,\n  width,\n  height\n) {\n  var that = this;\n  var pickCallback = function () {\n    var object = that.pick(scene, windowPosition, width, height);\n    if (defined(object)) {\n      return {\n        object: object,\n        position: undefined,\n        exclude: false,\n      };\n    }\n  };\n  var objects = drillPick(limit, pickCallback);\n  return objects.map(function (element) {\n    return element.object;\n  });\n};\n\nvar scratchRight = new Cartesian3();\nvar scratchUp = new Cartesian3();\n\nfunction MostDetailedRayPick(ray, width, tilesets) {\n  this.ray = ray;\n  this.width = width;\n  this.tilesets = tilesets;\n  this.ready = false;\n  this.deferred = when.defer();\n  this.promise = this.deferred.promise;\n}\n\nfunction updateOffscreenCameraFromRay(picking, ray, width, camera) {\n  var direction = ray.direction;\n  var orthogonalAxis = Cartesian3.mostOrthogonalAxis(direction, scratchRight);\n  var right = Cartesian3.cross(direction, orthogonalAxis, scratchRight);\n  var up = Cartesian3.cross(direction, right, scratchUp);\n\n  camera.position = ray.origin;\n  camera.direction = direction;\n  camera.up = up;\n  camera.right = right;\n\n  camera.frustum.width = defaultValue(width, offscreenDefaultWidth);\n  return camera.frustum.computeCullingVolume(\n    camera.positionWC,\n    camera.directionWC,\n    camera.upWC\n  );\n}\n\nfunction updateMostDetailedRayPick(picking, scene, rayPick) {\n  var frameState = scene.frameState;\n\n  var ray = rayPick.ray;\n  var width = rayPick.width;\n  var tilesets = rayPick.tilesets;\n\n  var camera = picking._pickOffscreenView.camera;\n  var cullingVolume = updateOffscreenCameraFromRay(picking, ray, width, camera);\n\n  var tilesetPassState = mostDetailedPreloadTilesetPassState;\n  tilesetPassState.camera = camera;\n  tilesetPassState.cullingVolume = cullingVolume;\n\n  var ready = true;\n  var tilesetsLength = tilesets.length;\n  for (var i = 0; i < tilesetsLength; ++i) {\n    var tileset = tilesets[i];\n    if (tileset.show && scene.primitives.contains(tileset)) {\n      // Only update tilesets that are still contained in the scene's primitive collection and are still visible\n      // Update tilesets continually until all tilesets are ready. This way tiles are never removed from the cache.\n      tileset.updateForPass(frameState, tilesetPassState);\n      ready = ready && tilesetPassState.ready;\n    }\n  }\n\n  if (ready) {\n    rayPick.deferred.resolve();\n  }\n\n  return ready;\n}\n\nPicking.prototype.updateMostDetailedRayPicks = function (scene) {\n  // Modifies array during iteration\n  var rayPicks = this._mostDetailedRayPicks;\n  for (var i = 0; i < rayPicks.length; ++i) {\n    if (updateMostDetailedRayPick(this, scene, rayPicks[i])) {\n      rayPicks.splice(i--, 1);\n    }\n  }\n};\n\nfunction getTilesets(primitives, objectsToExclude, tilesets) {\n  var length = primitives.length;\n  for (var i = 0; i < length; ++i) {\n    var primitive = primitives.get(i);\n    if (primitive.show) {\n      if (defined(primitive.isCesium3DTileset)) {\n        if (\n          !defined(objectsToExclude) ||\n          objectsToExclude.indexOf(primitive) === -1\n        ) {\n          tilesets.push(primitive);\n        }\n      } else if (primitive instanceof PrimitiveCollection) {\n        getTilesets(primitive, objectsToExclude, tilesets);\n      }\n    }\n  }\n}\n\nfunction launchMostDetailedRayPick(\n  picking,\n  scene,\n  ray,\n  objectsToExclude,\n  width,\n  callback\n) {\n  var tilesets = [];\n  getTilesets(scene.primitives, objectsToExclude, tilesets);\n  if (tilesets.length === 0) {\n    return when.resolve(callback());\n  }\n\n  var rayPick = new MostDetailedRayPick(ray, width, tilesets);\n  picking._mostDetailedRayPicks.push(rayPick);\n  return rayPick.promise.then(function () {\n    return callback();\n  });\n}\n\nfunction isExcluded(object, objectsToExclude) {\n  if (\n    !defined(object) ||\n    !defined(objectsToExclude) ||\n    objectsToExclude.length === 0\n  ) {\n    return false;\n  }\n  return (\n    objectsToExclude.indexOf(object) > -1 ||\n    objectsToExclude.indexOf(object.primitive) > -1 ||\n    objectsToExclude.indexOf(object.id) > -1\n  );\n}\n\nfunction getRayIntersection(\n  picking,\n  scene,\n  ray,\n  objectsToExclude,\n  width,\n  requirePosition,\n  mostDetailed\n) {\n  var context = scene.context;\n  var uniformState = context.uniformState;\n  var frameState = scene.frameState;\n\n  var view = picking._pickOffscreenView;\n  scene.view = view;\n\n  updateOffscreenCameraFromRay(picking, ray, width, view.camera);\n\n  scratchRectangle = BoundingRectangle.clone(view.viewport, scratchRectangle);\n\n  var passState = view.pickFramebuffer.begin(scratchRectangle, view.viewport);\n\n  scene.jobScheduler.disableThisFrame();\n\n  scene.updateFrameState();\n  frameState.invertClassification = false;\n  frameState.passes.pick = true;\n  frameState.passes.offscreen = true;\n\n  if (mostDetailed) {\n    frameState.tilesetPassState = mostDetailedPickTilesetPassState;\n  } else {\n    frameState.tilesetPassState = pickTilesetPassState;\n  }\n\n  uniformState.update(frameState);\n\n  scene.updateEnvironment();\n  scene.updateAndExecuteCommands(passState, scratchColorZero);\n  scene.resolveFramebuffers(passState);\n\n  var position;\n  var object = view.pickFramebuffer.end(context);\n\n  if (scene.context.depthTexture) {\n    var numFrustums = view.frustumCommandsList.length;\n    for (var i = 0; i < numFrustums; ++i) {\n      var pickDepth = picking.getPickDepth(scene, i);\n      var depth = pickDepth.getDepth(context, 0, 0);\n      if (depth > 0.0 && depth < 1.0) {\n        var renderedFrustum = view.frustumCommandsList[i];\n        var near =\n          renderedFrustum.near *\n          (i !== 0 ? scene.opaqueFrustumNearOffset : 1.0);\n        var far = renderedFrustum.far;\n        var distance = near + depth * (far - near);\n        position = Ray.getPoint(ray, distance);\n        break;\n      }\n    }\n  }\n\n  scene.view = scene.defaultView;\n  context.endFrame();\n\n  if (defined(object) || defined(position)) {\n    return {\n      object: object,\n      position: position,\n      exclude:\n        (!defined(position) && requirePosition) ||\n        isExcluded(object, objectsToExclude),\n    };\n  }\n}\n\nfunction getRayIntersections(\n  picking,\n  scene,\n  ray,\n  limit,\n  objectsToExclude,\n  width,\n  requirePosition,\n  mostDetailed\n) {\n  var pickCallback = function () {\n    return getRayIntersection(\n      picking,\n      scene,\n      ray,\n      objectsToExclude,\n      width,\n      requirePosition,\n      mostDetailed\n    );\n  };\n  return drillPick(limit, pickCallback);\n}\n\nfunction pickFromRay(\n  picking,\n  scene,\n  ray,\n  objectsToExclude,\n  width,\n  requirePosition,\n  mostDetailed\n) {\n  var results = getRayIntersections(\n    picking,\n    scene,\n    ray,\n    1,\n    objectsToExclude,\n    width,\n    requirePosition,\n    mostDetailed\n  );\n  if (results.length > 0) {\n    return results[0];\n  }\n}\n\nfunction drillPickFromRay(\n  picking,\n  scene,\n  ray,\n  limit,\n  objectsToExclude,\n  width,\n  requirePosition,\n  mostDetailed\n) {\n  return getRayIntersections(\n    picking,\n    scene,\n    ray,\n    limit,\n    objectsToExclude,\n    width,\n    requirePosition,\n    mostDetailed\n  );\n}\n\nfunction deferPromiseUntilPostRender(scene, promise) {\n  // Resolve promise after scene's postRender in case entities are created when the promise resolves.\n  // Entities can't be created between viewer._onTick and viewer._postRender.\n  var deferred = when.defer();\n  promise\n    .then(function (result) {\n      var removeCallback = scene.postRender.addEventListener(function () {\n        deferred.resolve(result);\n        removeCallback();\n      });\n      scene.requestRender();\n    })\n    .otherwise(function (error) {\n      deferred.reject(error);\n    });\n  return deferred.promise;\n}\n\nPicking.prototype.pickFromRay = function (scene, ray, objectsToExclude, width) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"ray\", ray);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\n      \"Ray intersections are only supported in 3D mode.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  return pickFromRay(this, scene, ray, objectsToExclude, width, false, false);\n};\n\nPicking.prototype.drillPickFromRay = function (\n  scene,\n  ray,\n  limit,\n  objectsToExclude,\n  width\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"ray\", ray);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\n      \"Ray intersections are only supported in 3D mode.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  return drillPickFromRay(\n    this,\n    scene,\n    ray,\n    limit,\n    objectsToExclude,\n    width,\n    false,\n    false\n  );\n};\n\nPicking.prototype.pickFromRayMostDetailed = function (\n  scene,\n  ray,\n  objectsToExclude,\n  width\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"ray\", ray);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\n      \"Ray intersections are only supported in 3D mode.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var that = this;\n  ray = Ray.clone(ray);\n  objectsToExclude = defined(objectsToExclude)\n    ? objectsToExclude.slice()\n    : objectsToExclude;\n  return deferPromiseUntilPostRender(\n    scene,\n    launchMostDetailedRayPick(\n      that,\n      scene,\n      ray,\n      objectsToExclude,\n      width,\n      function () {\n        return pickFromRay(\n          that,\n          scene,\n          ray,\n          objectsToExclude,\n          width,\n          false,\n          true\n        );\n      }\n    )\n  );\n};\n\nPicking.prototype.drillPickFromRayMostDetailed = function (\n  scene,\n  ray,\n  limit,\n  objectsToExclude,\n  width\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"ray\", ray);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\n      \"Ray intersections are only supported in 3D mode.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var that = this;\n  ray = Ray.clone(ray);\n  objectsToExclude = defined(objectsToExclude)\n    ? objectsToExclude.slice()\n    : objectsToExclude;\n  return deferPromiseUntilPostRender(\n    scene,\n    launchMostDetailedRayPick(\n      that,\n      scene,\n      ray,\n      objectsToExclude,\n      width,\n      function () {\n        return drillPickFromRay(\n          that,\n          scene,\n          ray,\n          limit,\n          objectsToExclude,\n          width,\n          false,\n          true\n        );\n      }\n    )\n  );\n};\n\nvar scratchSurfacePosition = new Cartesian3();\nvar scratchSurfaceNormal = new Cartesian3();\nvar scratchSurfaceRay = new Ray();\nvar scratchCartographic = new Cartographic();\n\nfunction getRayForSampleHeight(scene, cartographic) {\n  var globe = scene.globe;\n  var ellipsoid = defined(globe)\n    ? globe.ellipsoid\n    : scene.mapProjection.ellipsoid;\n  var height = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n  var surfaceNormal = ellipsoid.geodeticSurfaceNormalCartographic(\n    cartographic,\n    scratchSurfaceNormal\n  );\n  var surfacePosition = Cartographic.toCartesian(\n    cartographic,\n    ellipsoid,\n    scratchSurfacePosition\n  );\n  var surfaceRay = scratchSurfaceRay;\n  surfaceRay.origin = surfacePosition;\n  surfaceRay.direction = surfaceNormal;\n  var ray = new Ray();\n  Ray.getPoint(surfaceRay, height, ray.origin);\n  Cartesian3.negate(surfaceNormal, ray.direction);\n  return ray;\n}\n\nfunction getRayForClampToHeight(scene, cartesian) {\n  var globe = scene.globe;\n  var ellipsoid = defined(globe)\n    ? globe.ellipsoid\n    : scene.mapProjection.ellipsoid;\n  var cartographic = Cartographic.fromCartesian(\n    cartesian,\n    ellipsoid,\n    scratchCartographic\n  );\n  return getRayForSampleHeight(scene, cartographic);\n}\n\nfunction getHeightFromCartesian(scene, cartesian) {\n  var globe = scene.globe;\n  var ellipsoid = defined(globe)\n    ? globe.ellipsoid\n    : scene.mapProjection.ellipsoid;\n  var cartographic = Cartographic.fromCartesian(\n    cartesian,\n    ellipsoid,\n    scratchCartographic\n  );\n  return cartographic.height;\n}\n\nfunction sampleHeightMostDetailed(\n  picking,\n  scene,\n  cartographic,\n  objectsToExclude,\n  width\n) {\n  var ray = getRayForSampleHeight(scene, cartographic);\n  return launchMostDetailedRayPick(\n    picking,\n    scene,\n    ray,\n    objectsToExclude,\n    width,\n    function () {\n      var pickResult = pickFromRay(\n        picking,\n        scene,\n        ray,\n        objectsToExclude,\n        width,\n        true,\n        true\n      );\n      if (defined(pickResult)) {\n        return getHeightFromCartesian(scene, pickResult.position);\n      }\n    }\n  );\n}\n\nfunction clampToHeightMostDetailed(\n  picking,\n  scene,\n  cartesian,\n  objectsToExclude,\n  width,\n  result\n) {\n  var ray = getRayForClampToHeight(scene, cartesian);\n  return launchMostDetailedRayPick(\n    picking,\n    scene,\n    ray,\n    objectsToExclude,\n    width,\n    function () {\n      var pickResult = pickFromRay(\n        picking,\n        scene,\n        ray,\n        objectsToExclude,\n        width,\n        true,\n        true\n      );\n      if (defined(pickResult)) {\n        return Cartesian3.clone(pickResult.position, result);\n      }\n    }\n  );\n}\n\nPicking.prototype.sampleHeight = function (\n  scene,\n  position,\n  objectsToExclude,\n  width\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"position\", position);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\"sampleHeight is only supported in 3D mode.\");\n  }\n  if (!scene.sampleHeightSupported) {\n    throw new DeveloperError(\n      \"sampleHeight requires depth texture support. Check sampleHeightSupported.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var ray = getRayForSampleHeight(scene, position);\n  var pickResult = pickFromRay(\n    this,\n    scene,\n    ray,\n    objectsToExclude,\n    width,\n    true,\n    false\n  );\n  if (defined(pickResult)) {\n    return getHeightFromCartesian(scene, pickResult.position);\n  }\n};\n\nPicking.prototype.clampToHeight = function (\n  scene,\n  cartesian,\n  objectsToExclude,\n  width,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\"clampToHeight is only supported in 3D mode.\");\n  }\n  if (!scene.clampToHeightSupported) {\n    throw new DeveloperError(\n      \"clampToHeight requires depth texture support. Check clampToHeightSupported.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var ray = getRayForClampToHeight(scene, cartesian);\n  var pickResult = pickFromRay(\n    this,\n    scene,\n    ray,\n    objectsToExclude,\n    width,\n    true,\n    false\n  );\n  if (defined(pickResult)) {\n    return Cartesian3.clone(pickResult.position, result);\n  }\n};\n\nPicking.prototype.sampleHeightMostDetailed = function (\n  scene,\n  positions,\n  objectsToExclude,\n  width\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"positions\", positions);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\n      \"sampleHeightMostDetailed is only supported in 3D mode.\"\n    );\n  }\n  if (!scene.sampleHeightSupported) {\n    throw new DeveloperError(\n      \"sampleHeightMostDetailed requires depth texture support. Check sampleHeightSupported.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  objectsToExclude = defined(objectsToExclude)\n    ? objectsToExclude.slice()\n    : objectsToExclude;\n  var length = positions.length;\n  var promises = new Array(length);\n  for (var i = 0; i < length; ++i) {\n    promises[i] = sampleHeightMostDetailed(\n      this,\n      scene,\n      positions[i],\n      objectsToExclude,\n      width\n    );\n  }\n  return deferPromiseUntilPostRender(\n    scene,\n    when.all(promises).then(function (heights) {\n      var length = heights.length;\n      for (var i = 0; i < length; ++i) {\n        positions[i].height = heights[i];\n      }\n      return positions;\n    })\n  );\n};\n\nPicking.prototype.clampToHeightMostDetailed = function (\n  scene,\n  cartesians,\n  objectsToExclude,\n  width\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\n      \"clampToHeightMostDetailed is only supported in 3D mode.\"\n    );\n  }\n  if (!scene.clampToHeightSupported) {\n    throw new DeveloperError(\n      \"clampToHeightMostDetailed requires depth texture support. Check clampToHeightSupported.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  objectsToExclude = defined(objectsToExclude)\n    ? objectsToExclude.slice()\n    : objectsToExclude;\n  var length = cartesians.length;\n  var promises = new Array(length);\n  for (var i = 0; i < length; ++i) {\n    promises[i] = clampToHeightMostDetailed(\n      this,\n      scene,\n      cartesians[i],\n      objectsToExclude,\n      width,\n      cartesians[i]\n    );\n  }\n  return deferPromiseUntilPostRender(\n    scene,\n    when.all(promises).then(function (clampedCartesians) {\n      var length = clampedCartesians.length;\n      for (var i = 0; i < length; ++i) {\n        cartesians[i] = clampedCartesians[i];\n      }\n      return cartesians;\n    })\n  );\n};\n\nPicking.prototype.destroy = function () {\n  this._pickOffscreenView =\n    this._pickOffscreenView && this._pickOffscreenView.destroy();\n};\nexport default Picking;\n"]},"metadata":{},"sourceType":"module"}