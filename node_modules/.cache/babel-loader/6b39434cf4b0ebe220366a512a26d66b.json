{"ast":null,"code":"import ArcType from \"./ArcType.js\";\nimport arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonGeometryLibrary from \"./PolygonGeometryLibrary.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport WindingOrder from \"./WindingOrder.js\";\nvar createGeometryFromPositionsPositions = [];\nvar createGeometryFromPositionsSubdivided = [];\n\nfunction createGeometryFromPositions(ellipsoid, positions, minDistance, perPositionHeight, arcType) {\n  var tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n  var positions2D = tangentPlane.projectPointsOntoPlane(positions, createGeometryFromPositionsPositions);\n  var originalWindingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n\n  if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n    positions2D.reverse();\n    positions = positions.slice().reverse();\n  }\n\n  var subdividedPositions;\n  var i;\n  var length = positions.length;\n  var index = 0;\n\n  if (!perPositionHeight) {\n    var numVertices = 0;\n\n    if (arcType === ArcType.GEODESIC) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideLineCount(positions[i], positions[(i + 1) % length], minDistance);\n      }\n    } else if (arcType === ArcType.RHUMB) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(ellipsoid, positions[i], positions[(i + 1) % length], minDistance);\n      }\n    }\n\n    subdividedPositions = new Float64Array(numVertices * 3);\n\n    for (i = 0; i < length; i++) {\n      var tempPositions;\n\n      if (arcType === ArcType.GEODESIC) {\n        tempPositions = PolygonGeometryLibrary.subdivideLine(positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);\n      } else if (arcType === ArcType.RHUMB) {\n        tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(ellipsoid, positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);\n      }\n\n      var tempPositionsLength = tempPositions.length;\n\n      for (var j = 0; j < tempPositionsLength; ++j) {\n        subdividedPositions[index++] = tempPositions[j];\n      }\n    }\n  } else {\n    subdividedPositions = new Float64Array(length * 2 * 3);\n\n    for (i = 0; i < length; i++) {\n      var p0 = positions[i];\n      var p1 = positions[(i + 1) % length];\n      subdividedPositions[index++] = p0.x;\n      subdividedPositions[index++] = p0.y;\n      subdividedPositions[index++] = p0.z;\n      subdividedPositions[index++] = p1.x;\n      subdividedPositions[index++] = p1.y;\n      subdividedPositions[index++] = p1.z;\n    }\n  }\n\n  length = subdividedPositions.length / 3;\n  var indicesSize = length * 2;\n  var indices = IndexDatatype.createTypedArray(length, indicesSize);\n  index = 0;\n\n  for (i = 0; i < length - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n  }\n\n  indices[index++] = length - 1;\n  indices[index++] = 0;\n  return new GeometryInstance({\n    geometry: new Geometry({\n      attributes: new GeometryAttributes({\n        position: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.DOUBLE,\n          componentsPerAttribute: 3,\n          values: subdividedPositions\n        })\n      }),\n      indices: indices,\n      primitiveType: PrimitiveType.LINES\n    })\n  });\n}\n\nfunction createGeometryFromPositionsExtruded(ellipsoid, positions, minDistance, perPositionHeight, arcType) {\n  var tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n  var positions2D = tangentPlane.projectPointsOntoPlane(positions, createGeometryFromPositionsPositions);\n  var originalWindingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n\n  if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n    positions2D.reverse();\n    positions = positions.slice().reverse();\n  }\n\n  var subdividedPositions;\n  var i;\n  var length = positions.length;\n  var corners = new Array(length);\n  var index = 0;\n\n  if (!perPositionHeight) {\n    var numVertices = 0;\n\n    if (arcType === ArcType.GEODESIC) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideLineCount(positions[i], positions[(i + 1) % length], minDistance);\n      }\n    } else if (arcType === ArcType.RHUMB) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(ellipsoid, positions[i], positions[(i + 1) % length], minDistance);\n      }\n    }\n\n    subdividedPositions = new Float64Array(numVertices * 3 * 2);\n\n    for (i = 0; i < length; ++i) {\n      corners[i] = index / 3;\n      var tempPositions;\n\n      if (arcType === ArcType.GEODESIC) {\n        tempPositions = PolygonGeometryLibrary.subdivideLine(positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);\n      } else if (arcType === ArcType.RHUMB) {\n        tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(ellipsoid, positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);\n      }\n\n      var tempPositionsLength = tempPositions.length;\n\n      for (var j = 0; j < tempPositionsLength; ++j) {\n        subdividedPositions[index++] = tempPositions[j];\n      }\n    }\n  } else {\n    subdividedPositions = new Float64Array(length * 2 * 3 * 2);\n\n    for (i = 0; i < length; ++i) {\n      corners[i] = index / 3;\n      var p0 = positions[i];\n      var p1 = positions[(i + 1) % length];\n      subdividedPositions[index++] = p0.x;\n      subdividedPositions[index++] = p0.y;\n      subdividedPositions[index++] = p0.z;\n      subdividedPositions[index++] = p1.x;\n      subdividedPositions[index++] = p1.y;\n      subdividedPositions[index++] = p1.z;\n    }\n  }\n\n  length = subdividedPositions.length / (3 * 2);\n  var cornersLength = corners.length;\n  var indicesSize = (length * 2 + cornersLength) * 2;\n  var indices = IndexDatatype.createTypedArray(length + cornersLength, indicesSize);\n  index = 0;\n\n  for (i = 0; i < length; ++i) {\n    indices[index++] = i;\n    indices[index++] = (i + 1) % length;\n    indices[index++] = i + length;\n    indices[index++] = (i + 1) % length + length;\n  }\n\n  for (i = 0; i < cornersLength; i++) {\n    var corner = corners[i];\n    indices[index++] = corner;\n    indices[index++] = corner + length;\n  }\n\n  return new GeometryInstance({\n    geometry: new Geometry({\n      attributes: new GeometryAttributes({\n        position: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.DOUBLE,\n          componentsPerAttribute: 3,\n          values: subdividedPositions\n        })\n      }),\n      indices: indices,\n      primitiveType: PrimitiveType.LINES\n    })\n  });\n}\n/**\n * A description of the outline of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy.\n *\n * @alias PolygonOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n * @param {Number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\n * @param {Number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of path the outline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n *\n * @see PolygonOutlineGeometry#createGeometry\n * @see PolygonOutlineGeometry#fromPositions\n *\n * @example\n * // 1. create a polygon outline from points\n * var polygon = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   )\n * });\n * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\n *\n * // 2. create a nested polygon with holes outline\n * var polygonWithHole = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -109.0, 30.0,\n *       -95.0, 30.0,\n *       -95.0, 40.0,\n *       -109.0, 40.0\n *     ]),\n *     [new Cesium.PolygonHierarchy(\n *       Cesium.Cartesian3.fromDegreesArray([\n *         -107.0, 31.0,\n *         -107.0, 39.0,\n *         -97.0, 39.0,\n *         -97.0, 31.0\n *       ]),\n *       [new Cesium.PolygonHierarchy(\n *         Cesium.Cartesian3.fromDegreesArray([\n *           -105.0, 33.0,\n *           -99.0, 33.0,\n *           -99.0, 37.0,\n *           -105.0, 37.0\n *         ]),\n *         [new Cesium.PolygonHierarchy(\n *           Cesium.Cartesian3.fromDegreesArray([\n *             -103.0, 34.0,\n *             -101.0, 34.0,\n *             -101.0, 36.0,\n *             -103.0, 36.0\n *           ])\n *         )]\n *       )]\n *     )]\n *   )\n * });\n * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygonWithHole);\n *\n * // 3. create extruded polygon outline\n * var extrudedPolygon = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   ),\n *   extrudedHeight: 300000\n * });\n * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(extrudedPolygon);\n */\n\n\nfunction PolygonOutlineGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.polygonHierarchy\", options.polygonHierarchy);\n\n  if (options.perPositionHeight && defined(options.height)) {\n    throw new DeveloperError(\"Cannot use both options.perPositionHeight and options.height\");\n  }\n\n  if (defined(options.arcType) && options.arcType !== ArcType.GEODESIC && options.arcType !== ArcType.RHUMB) {\n    throw new DeveloperError(\"Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.\");\n  } //>>includeEnd('debug');\n\n\n  var polygonHierarchy = options.polygonHierarchy;\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n  var perPositionHeight = defaultValue(options.perPositionHeight, false);\n  var perPositionHeightExtrude = perPositionHeight && defined(options.extrudedHeight);\n  var arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n  var height = defaultValue(options.height, 0.0);\n  var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  if (!perPositionHeightExtrude) {\n    var h = Math.max(height, extrudedHeight);\n    extrudedHeight = Math.min(height, extrudedHeight);\n    height = h;\n  }\n\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._granularity = granularity;\n  this._height = height;\n  this._extrudedHeight = extrudedHeight;\n  this._arcType = arcType;\n  this._polygonHierarchy = polygonHierarchy;\n  this._perPositionHeight = perPositionHeight;\n  this._perPositionHeightExtrude = perPositionHeightExtrude;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createPolygonOutlineGeometry\";\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n\n  this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + Ellipsoid.packedLength + 8;\n}\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolygonOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\n\nPolygonOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\n  array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\n  array[startingIndex++] = value._arcType;\n  array[startingIndex++] = defaultValue(value._offsetAttribute, -1);\n  array[startingIndex] = value.packedLength;\n  return array;\n};\n\nvar scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nvar dummyOptions = {\n  polygonHierarchy: {}\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolygonOutlineGeometry} [result] The object into which to store the result.\n * @returns {PolygonOutlineGeometry} The modified result parameter or a new PolygonOutlineGeometry instance if one was not provided.\n */\n\nPolygonOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);\n  startingIndex = polygonHierarchy.startingIndex;\n  delete polygonHierarchy.startingIndex;\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n  var height = array[startingIndex++];\n  var extrudedHeight = array[startingIndex++];\n  var granularity = array[startingIndex++];\n  var perPositionHeightExtrude = array[startingIndex++] === 1.0;\n  var perPositionHeight = array[startingIndex++] === 1.0;\n  var arcType = array[startingIndex++];\n  var offsetAttribute = array[startingIndex++];\n  var packedLength = array[startingIndex];\n\n  if (!defined(result)) {\n    result = new PolygonOutlineGeometry(dummyOptions);\n  }\n\n  result._polygonHierarchy = polygonHierarchy;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._granularity = granularity;\n  result._perPositionHeight = perPositionHeight;\n  result._perPositionHeightExtrude = perPositionHeightExtrude;\n  result._arcType = arcType;\n  result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n  result.packedLength = packedLength;\n  return result;\n};\n/**\n * A description of a polygon outline from an array of positions.\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n * @param {Number} [options.height=0.0] The height of the polygon.\n * @param {Number} [options.extrudedHeight] The height of the polygon extrusion.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of path the outline must follow. Valid options are {@link LinkType.GEODESIC} and {@link ArcType.RHUMB}.\n * @returns {PolygonOutlineGeometry}\n *\n *\n * @example\n * // create a polygon from points\n * var polygon = Cesium.PolygonOutlineGeometry.fromPositions({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0,\n *     -75.0, 30.0,\n *     -70.0, 30.0,\n *     -68.0, 40.0\n *   ])\n * });\n * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\n *\n * @see PolygonOutlineGeometry#createGeometry\n */\n\n\nPolygonOutlineGeometry.fromPositions = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);\n\n  Check.defined(\"options.positions\", options.positions); //>>includeEnd('debug');\n\n  var newOptions = {\n    polygonHierarchy: {\n      positions: options.positions\n    },\n    height: options.height,\n    extrudedHeight: options.extrudedHeight,\n    ellipsoid: options.ellipsoid,\n    granularity: options.granularity,\n    perPositionHeight: options.perPositionHeight,\n    arcType: options.arcType,\n    offsetAttribute: options.offsetAttribute\n  };\n  return new PolygonOutlineGeometry(newOptions);\n};\n/**\n * Computes the geometric representation of a polygon outline, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolygonOutlineGeometry} polygonGeometry A description of the polygon outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\n\n\nPolygonOutlineGeometry.createGeometry = function (polygonGeometry) {\n  var ellipsoid = polygonGeometry._ellipsoid;\n  var granularity = polygonGeometry._granularity;\n  var polygonHierarchy = polygonGeometry._polygonHierarchy;\n  var perPositionHeight = polygonGeometry._perPositionHeight;\n  var arcType = polygonGeometry._arcType;\n  var polygons = PolygonGeometryLibrary.polygonOutlinesFromHierarchy(polygonHierarchy, !perPositionHeight, ellipsoid);\n\n  if (polygons.length === 0) {\n    return undefined;\n  }\n\n  var geometryInstance;\n  var geometries = [];\n  var minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n  var height = polygonGeometry._height;\n  var extrudedHeight = polygonGeometry._extrudedHeight;\n  var extrude = polygonGeometry._perPositionHeightExtrude || !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n  var offsetValue;\n  var i;\n\n  if (extrude) {\n    for (i = 0; i < polygons.length; i++) {\n      geometryInstance = createGeometryFromPositionsExtruded(ellipsoid, polygons[i], minDistance, perPositionHeight, arcType);\n      geometryInstance.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(geometryInstance.geometry, height, extrudedHeight, ellipsoid, perPositionHeight);\n\n      if (defined(polygonGeometry._offsetAttribute)) {\n        var size = geometryInstance.geometry.attributes.position.values.length / 3;\n        var offsetAttribute = new Uint8Array(size);\n\n        if (polygonGeometry._offsetAttribute === GeometryOffsetAttribute.TOP) {\n          offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n        } else {\n          offsetValue = polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n          offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n        }\n\n        geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute({\n          componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n          componentsPerAttribute: 1,\n          values: offsetAttribute\n        });\n      }\n\n      geometries.push(geometryInstance);\n    }\n  } else {\n    for (i = 0; i < polygons.length; i++) {\n      geometryInstance = createGeometryFromPositions(ellipsoid, polygons[i], minDistance, perPositionHeight, arcType);\n      geometryInstance.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(geometryInstance.geometry.attributes.position.values, height, ellipsoid, !perPositionHeight);\n\n      if (defined(polygonGeometry._offsetAttribute)) {\n        var length = geometryInstance.geometry.attributes.position.values.length;\n        var applyOffset = new Uint8Array(length / 3);\n        offsetValue = polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n        arrayFill(applyOffset, offsetValue);\n        geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute({\n          componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n          componentsPerAttribute: 1,\n          values: applyOffset\n        });\n      }\n\n      geometries.push(geometryInstance);\n    }\n  }\n\n  var geometry = GeometryPipeline.combineInstances(geometries)[0];\n  var boundingSphere = BoundingSphere.fromVertices(geometry.attributes.position.values);\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: boundingSphere,\n    offsetAttribute: polygonGeometry._offsetAttribute\n  });\n};\n\nexport default PolygonOutlineGeometry;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/PolygonOutlineGeometry.js"],"names":["ArcType","arrayFill","BoundingSphere","Check","ComponentDatatype","defaultValue","defined","DeveloperError","Ellipsoid","EllipsoidTangentPlane","Geometry","GeometryAttribute","GeometryAttributes","GeometryInstance","GeometryOffsetAttribute","GeometryPipeline","IndexDatatype","CesiumMath","PolygonGeometryLibrary","PolygonPipeline","PrimitiveType","WindingOrder","createGeometryFromPositionsPositions","createGeometryFromPositionsSubdivided","createGeometryFromPositions","ellipsoid","positions","minDistance","perPositionHeight","arcType","tangentPlane","fromPoints","positions2D","projectPointsOntoPlane","originalWindingOrder","computeWindingOrder2D","CLOCKWISE","reverse","slice","subdividedPositions","i","length","index","numVertices","GEODESIC","subdivideLineCount","RHUMB","subdivideRhumbLineCount","Float64Array","tempPositions","subdivideLine","subdivideRhumbLine","tempPositionsLength","j","p0","p1","x","y","z","indicesSize","indices","createTypedArray","geometry","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","primitiveType","LINES","createGeometryFromPositionsExtruded","corners","Array","cornersLength","corner","PolygonOutlineGeometry","options","typeOf","object","polygonHierarchy","height","WGS84","granularity","RADIANS_PER_DEGREE","perPositionHeightExtrude","extrudedHeight","h","Math","max","min","_ellipsoid","clone","_granularity","_height","_extrudedHeight","_arcType","_polygonHierarchy","_perPositionHeight","_perPositionHeightExtrude","_offsetAttribute","offsetAttribute","_workerName","packedLength","computeHierarchyPackedLength","pack","value","array","startingIndex","packPolygonHierarchy","scratchEllipsoid","UNIT_SPHERE","dummyOptions","unpack","result","unpackPolygonHierarchy","undefined","fromPositions","EMPTY_OBJECT","newOptions","createGeometry","polygonGeometry","polygons","polygonOutlinesFromHierarchy","geometryInstance","geometries","chordLength","maximumRadius","extrude","equalsEpsilon","EPSILON2","offsetValue","scaleToGeodeticHeightExtruded","size","Uint8Array","TOP","NONE","applyOffset","UNSIGNED_BYTE","push","scaleToGeodeticHeight","combineInstances","boundingSphere","fromVertices"],"mappings":"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","sourcesContent":["import ArcType from \"./ArcType.js\";\nimport arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonGeometryLibrary from \"./PolygonGeometryLibrary.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport WindingOrder from \"./WindingOrder.js\";\nvar createGeometryFromPositionsPositions = [];\nvar createGeometryFromPositionsSubdivided = [];\n\nfunction createGeometryFromPositions(\n  ellipsoid,\n  positions,\n  minDistance,\n  perPositionHeight,\n  arcType\n) {\n  var tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n  var positions2D = tangentPlane.projectPointsOntoPlane(\n    positions,\n    createGeometryFromPositionsPositions\n  );\n\n  var originalWindingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n  if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n    positions2D.reverse();\n    positions = positions.slice().reverse();\n  }\n\n  var subdividedPositions;\n  var i;\n\n  var length = positions.length;\n  var index = 0;\n\n  if (!perPositionHeight) {\n    var numVertices = 0;\n    if (arcType === ArcType.GEODESIC) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideLineCount(\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance\n        );\n      }\n    } else if (arcType === ArcType.RHUMB) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(\n          ellipsoid,\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance\n        );\n      }\n    }\n    subdividedPositions = new Float64Array(numVertices * 3);\n    for (i = 0; i < length; i++) {\n      var tempPositions;\n      if (arcType === ArcType.GEODESIC) {\n        tempPositions = PolygonGeometryLibrary.subdivideLine(\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n          createGeometryFromPositionsSubdivided\n        );\n      } else if (arcType === ArcType.RHUMB) {\n        tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(\n          ellipsoid,\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n          createGeometryFromPositionsSubdivided\n        );\n      }\n      var tempPositionsLength = tempPositions.length;\n      for (var j = 0; j < tempPositionsLength; ++j) {\n        subdividedPositions[index++] = tempPositions[j];\n      }\n    }\n  } else {\n    subdividedPositions = new Float64Array(length * 2 * 3);\n    for (i = 0; i < length; i++) {\n      var p0 = positions[i];\n      var p1 = positions[(i + 1) % length];\n      subdividedPositions[index++] = p0.x;\n      subdividedPositions[index++] = p0.y;\n      subdividedPositions[index++] = p0.z;\n      subdividedPositions[index++] = p1.x;\n      subdividedPositions[index++] = p1.y;\n      subdividedPositions[index++] = p1.z;\n    }\n  }\n\n  length = subdividedPositions.length / 3;\n  var indicesSize = length * 2;\n  var indices = IndexDatatype.createTypedArray(length, indicesSize);\n  index = 0;\n  for (i = 0; i < length - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n  }\n  indices[index++] = length - 1;\n  indices[index++] = 0;\n\n  return new GeometryInstance({\n    geometry: new Geometry({\n      attributes: new GeometryAttributes({\n        position: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.DOUBLE,\n          componentsPerAttribute: 3,\n          values: subdividedPositions,\n        }),\n      }),\n      indices: indices,\n      primitiveType: PrimitiveType.LINES,\n    }),\n  });\n}\n\nfunction createGeometryFromPositionsExtruded(\n  ellipsoid,\n  positions,\n  minDistance,\n  perPositionHeight,\n  arcType\n) {\n  var tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n  var positions2D = tangentPlane.projectPointsOntoPlane(\n    positions,\n    createGeometryFromPositionsPositions\n  );\n\n  var originalWindingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n  if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n    positions2D.reverse();\n    positions = positions.slice().reverse();\n  }\n\n  var subdividedPositions;\n  var i;\n\n  var length = positions.length;\n  var corners = new Array(length);\n  var index = 0;\n\n  if (!perPositionHeight) {\n    var numVertices = 0;\n    if (arcType === ArcType.GEODESIC) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideLineCount(\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance\n        );\n      }\n    } else if (arcType === ArcType.RHUMB) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(\n          ellipsoid,\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance\n        );\n      }\n    }\n\n    subdividedPositions = new Float64Array(numVertices * 3 * 2);\n    for (i = 0; i < length; ++i) {\n      corners[i] = index / 3;\n      var tempPositions;\n      if (arcType === ArcType.GEODESIC) {\n        tempPositions = PolygonGeometryLibrary.subdivideLine(\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n          createGeometryFromPositionsSubdivided\n        );\n      } else if (arcType === ArcType.RHUMB) {\n        tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(\n          ellipsoid,\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n          createGeometryFromPositionsSubdivided\n        );\n      }\n      var tempPositionsLength = tempPositions.length;\n      for (var j = 0; j < tempPositionsLength; ++j) {\n        subdividedPositions[index++] = tempPositions[j];\n      }\n    }\n  } else {\n    subdividedPositions = new Float64Array(length * 2 * 3 * 2);\n    for (i = 0; i < length; ++i) {\n      corners[i] = index / 3;\n      var p0 = positions[i];\n      var p1 = positions[(i + 1) % length];\n\n      subdividedPositions[index++] = p0.x;\n      subdividedPositions[index++] = p0.y;\n      subdividedPositions[index++] = p0.z;\n      subdividedPositions[index++] = p1.x;\n      subdividedPositions[index++] = p1.y;\n      subdividedPositions[index++] = p1.z;\n    }\n  }\n\n  length = subdividedPositions.length / (3 * 2);\n  var cornersLength = corners.length;\n\n  var indicesSize = (length * 2 + cornersLength) * 2;\n  var indices = IndexDatatype.createTypedArray(\n    length + cornersLength,\n    indicesSize\n  );\n\n  index = 0;\n  for (i = 0; i < length; ++i) {\n    indices[index++] = i;\n    indices[index++] = (i + 1) % length;\n    indices[index++] = i + length;\n    indices[index++] = ((i + 1) % length) + length;\n  }\n\n  for (i = 0; i < cornersLength; i++) {\n    var corner = corners[i];\n    indices[index++] = corner;\n    indices[index++] = corner + length;\n  }\n\n  return new GeometryInstance({\n    geometry: new Geometry({\n      attributes: new GeometryAttributes({\n        position: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.DOUBLE,\n          componentsPerAttribute: 3,\n          values: subdividedPositions,\n        }),\n      }),\n      indices: indices,\n      primitiveType: PrimitiveType.LINES,\n    }),\n  });\n}\n\n/**\n * A description of the outline of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy.\n *\n * @alias PolygonOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n * @param {Number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\n * @param {Number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of path the outline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n *\n * @see PolygonOutlineGeometry#createGeometry\n * @see PolygonOutlineGeometry#fromPositions\n *\n * @example\n * // 1. create a polygon outline from points\n * var polygon = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   )\n * });\n * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\n *\n * // 2. create a nested polygon with holes outline\n * var polygonWithHole = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -109.0, 30.0,\n *       -95.0, 30.0,\n *       -95.0, 40.0,\n *       -109.0, 40.0\n *     ]),\n *     [new Cesium.PolygonHierarchy(\n *       Cesium.Cartesian3.fromDegreesArray([\n *         -107.0, 31.0,\n *         -107.0, 39.0,\n *         -97.0, 39.0,\n *         -97.0, 31.0\n *       ]),\n *       [new Cesium.PolygonHierarchy(\n *         Cesium.Cartesian3.fromDegreesArray([\n *           -105.0, 33.0,\n *           -99.0, 33.0,\n *           -99.0, 37.0,\n *           -105.0, 37.0\n *         ]),\n *         [new Cesium.PolygonHierarchy(\n *           Cesium.Cartesian3.fromDegreesArray([\n *             -103.0, 34.0,\n *             -101.0, 34.0,\n *             -101.0, 36.0,\n *             -103.0, 36.0\n *           ])\n *         )]\n *       )]\n *     )]\n *   )\n * });\n * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygonWithHole);\n *\n * // 3. create extruded polygon outline\n * var extrudedPolygon = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   ),\n *   extrudedHeight: 300000\n * });\n * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(extrudedPolygon);\n */\nfunction PolygonOutlineGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.polygonHierarchy\", options.polygonHierarchy);\n\n  if (options.perPositionHeight && defined(options.height)) {\n    throw new DeveloperError(\n      \"Cannot use both options.perPositionHeight and options.height\"\n    );\n  }\n  if (\n    defined(options.arcType) &&\n    options.arcType !== ArcType.GEODESIC &&\n    options.arcType !== ArcType.RHUMB\n  ) {\n    throw new DeveloperError(\n      \"Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var polygonHierarchy = options.polygonHierarchy;\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  var perPositionHeight = defaultValue(options.perPositionHeight, false);\n  var perPositionHeightExtrude =\n    perPositionHeight && defined(options.extrudedHeight);\n  var arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n\n  var height = defaultValue(options.height, 0.0);\n  var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  if (!perPositionHeightExtrude) {\n    var h = Math.max(height, extrudedHeight);\n    extrudedHeight = Math.min(height, extrudedHeight);\n    height = h;\n  }\n\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._granularity = granularity;\n  this._height = height;\n  this._extrudedHeight = extrudedHeight;\n  this._arcType = arcType;\n  this._polygonHierarchy = polygonHierarchy;\n  this._perPositionHeight = perPositionHeight;\n  this._perPositionHeightExtrude = perPositionHeightExtrude;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createPolygonOutlineGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  this.packedLength =\n    PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) +\n    Ellipsoid.packedLength +\n    8;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolygonOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nPolygonOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(\n    value._polygonHierarchy,\n    array,\n    startingIndex\n  );\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\n  array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\n  array[startingIndex++] = value._arcType;\n  array[startingIndex++] = defaultValue(value._offsetAttribute, -1);\n  array[startingIndex] = value.packedLength;\n\n  return array;\n};\n\nvar scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nvar dummyOptions = {\n  polygonHierarchy: {},\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolygonOutlineGeometry} [result] The object into which to store the result.\n * @returns {PolygonOutlineGeometry} The modified result parameter or a new PolygonOutlineGeometry instance if one was not provided.\n */\nPolygonOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(\n    array,\n    startingIndex\n  );\n  startingIndex = polygonHierarchy.startingIndex;\n  delete polygonHierarchy.startingIndex;\n\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  var height = array[startingIndex++];\n  var extrudedHeight = array[startingIndex++];\n  var granularity = array[startingIndex++];\n  var perPositionHeightExtrude = array[startingIndex++] === 1.0;\n  var perPositionHeight = array[startingIndex++] === 1.0;\n  var arcType = array[startingIndex++];\n  var offsetAttribute = array[startingIndex++];\n  var packedLength = array[startingIndex];\n\n  if (!defined(result)) {\n    result = new PolygonOutlineGeometry(dummyOptions);\n  }\n\n  result._polygonHierarchy = polygonHierarchy;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._granularity = granularity;\n  result._perPositionHeight = perPositionHeight;\n  result._perPositionHeightExtrude = perPositionHeightExtrude;\n  result._arcType = arcType;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n  result.packedLength = packedLength;\n\n  return result;\n};\n\n/**\n * A description of a polygon outline from an array of positions.\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n * @param {Number} [options.height=0.0] The height of the polygon.\n * @param {Number} [options.extrudedHeight] The height of the polygon extrusion.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of path the outline must follow. Valid options are {@link LinkType.GEODESIC} and {@link ArcType.RHUMB}.\n * @returns {PolygonOutlineGeometry}\n *\n *\n * @example\n * // create a polygon from points\n * var polygon = Cesium.PolygonOutlineGeometry.fromPositions({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0,\n *     -75.0, 30.0,\n *     -70.0, 30.0,\n *     -68.0, 40.0\n *   ])\n * });\n * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\n *\n * @see PolygonOutlineGeometry#createGeometry\n */\nPolygonOutlineGeometry.fromPositions = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", options.positions);\n  //>>includeEnd('debug');\n\n  var newOptions = {\n    polygonHierarchy: {\n      positions: options.positions,\n    },\n    height: options.height,\n    extrudedHeight: options.extrudedHeight,\n    ellipsoid: options.ellipsoid,\n    granularity: options.granularity,\n    perPositionHeight: options.perPositionHeight,\n    arcType: options.arcType,\n    offsetAttribute: options.offsetAttribute,\n  };\n  return new PolygonOutlineGeometry(newOptions);\n};\n\n/**\n * Computes the geometric representation of a polygon outline, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolygonOutlineGeometry} polygonGeometry A description of the polygon outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPolygonOutlineGeometry.createGeometry = function (polygonGeometry) {\n  var ellipsoid = polygonGeometry._ellipsoid;\n  var granularity = polygonGeometry._granularity;\n  var polygonHierarchy = polygonGeometry._polygonHierarchy;\n  var perPositionHeight = polygonGeometry._perPositionHeight;\n  var arcType = polygonGeometry._arcType;\n\n  var polygons = PolygonGeometryLibrary.polygonOutlinesFromHierarchy(\n    polygonHierarchy,\n    !perPositionHeight,\n    ellipsoid\n  );\n\n  if (polygons.length === 0) {\n    return undefined;\n  }\n\n  var geometryInstance;\n  var geometries = [];\n  var minDistance = CesiumMath.chordLength(\n    granularity,\n    ellipsoid.maximumRadius\n  );\n\n  var height = polygonGeometry._height;\n  var extrudedHeight = polygonGeometry._extrudedHeight;\n  var extrude =\n    polygonGeometry._perPositionHeightExtrude ||\n    !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n  var offsetValue;\n  var i;\n  if (extrude) {\n    for (i = 0; i < polygons.length; i++) {\n      geometryInstance = createGeometryFromPositionsExtruded(\n        ellipsoid,\n        polygons[i],\n        minDistance,\n        perPositionHeight,\n        arcType\n      );\n      geometryInstance.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(\n        geometryInstance.geometry,\n        height,\n        extrudedHeight,\n        ellipsoid,\n        perPositionHeight\n      );\n      if (defined(polygonGeometry._offsetAttribute)) {\n        var size =\n          geometryInstance.geometry.attributes.position.values.length / 3;\n        var offsetAttribute = new Uint8Array(size);\n        if (polygonGeometry._offsetAttribute === GeometryOffsetAttribute.TOP) {\n          offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n        } else {\n          offsetValue =\n            polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n              ? 0\n              : 1;\n          offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n        }\n\n        geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute(\n          {\n            componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n            componentsPerAttribute: 1,\n            values: offsetAttribute,\n          }\n        );\n      }\n      geometries.push(geometryInstance);\n    }\n  } else {\n    for (i = 0; i < polygons.length; i++) {\n      geometryInstance = createGeometryFromPositions(\n        ellipsoid,\n        polygons[i],\n        minDistance,\n        perPositionHeight,\n        arcType\n      );\n      geometryInstance.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n        geometryInstance.geometry.attributes.position.values,\n        height,\n        ellipsoid,\n        !perPositionHeight\n      );\n\n      if (defined(polygonGeometry._offsetAttribute)) {\n        var length =\n          geometryInstance.geometry.attributes.position.values.length;\n        var applyOffset = new Uint8Array(length / 3);\n        offsetValue =\n          polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n            ? 0\n            : 1;\n        arrayFill(applyOffset, offsetValue);\n        geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute(\n          {\n            componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n            componentsPerAttribute: 1,\n            values: applyOffset,\n          }\n        );\n      }\n\n      geometries.push(geometryInstance);\n    }\n  }\n\n  var geometry = GeometryPipeline.combineInstances(geometries)[0];\n  var boundingSphere = BoundingSphere.fromVertices(\n    geometry.attributes.position.values\n  );\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: boundingSphere,\n    offsetAttribute: polygonGeometry._offsetAttribute,\n  });\n};\nexport default PolygonOutlineGeometry;\n"]},"metadata":{},"sourceType":"module"}