{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport CornerType from \"./CornerType.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport PolylineVolumeGeometryLibrary from \"./PolylineVolumeGeometryLibrary.js\";\nimport Quaternion from \"./Quaternion.js\";\n/**\n * @private\n */\n\nvar CorridorGeometryLibrary = {};\nvar scratch1 = new Cartesian3();\nvar scratch2 = new Cartesian3();\nvar scratch3 = new Cartesian3();\nvar scratch4 = new Cartesian3();\nvar scaleArray2 = [new Cartesian3(), new Cartesian3()];\nvar cartesian1 = new Cartesian3();\nvar cartesian2 = new Cartesian3();\nvar cartesian3 = new Cartesian3();\nvar cartesian4 = new Cartesian3();\nvar cartesian5 = new Cartesian3();\nvar cartesian6 = new Cartesian3();\nvar cartesian7 = new Cartesian3();\nvar cartesian8 = new Cartesian3();\nvar cartesian9 = new Cartesian3();\nvar cartesian10 = new Cartesian3();\nvar quaterion = new Quaternion();\nvar rotMatrix = new Matrix3();\n\nfunction computeRoundCorner(cornerPoint, startPoint, endPoint, cornerType, leftIsOutside) {\n  var angle = Cartesian3.angleBetween(Cartesian3.subtract(startPoint, cornerPoint, scratch1), Cartesian3.subtract(endPoint, cornerPoint, scratch2));\n  var granularity = cornerType === CornerType.BEVELED ? 1 : Math.ceil(angle / CesiumMath.toRadians(5)) + 1;\n  var size = granularity * 3;\n  var array = new Array(size);\n  array[size - 3] = endPoint.x;\n  array[size - 2] = endPoint.y;\n  array[size - 1] = endPoint.z;\n  var m;\n\n  if (leftIsOutside) {\n    m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(Cartesian3.negate(cornerPoint, scratch1), angle / granularity, quaterion), rotMatrix);\n  } else {\n    m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(cornerPoint, angle / granularity, quaterion), rotMatrix);\n  }\n\n  var index = 0;\n  startPoint = Cartesian3.clone(startPoint, scratch1);\n\n  for (var i = 0; i < granularity; i++) {\n    startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\n    array[index++] = startPoint.x;\n    array[index++] = startPoint.y;\n    array[index++] = startPoint.z;\n  }\n\n  return array;\n}\n\nfunction addEndCaps(calculatedPositions) {\n  var cornerPoint = cartesian1;\n  var startPoint = cartesian2;\n  var endPoint = cartesian3;\n  var leftEdge = calculatedPositions[1];\n  startPoint = Cartesian3.fromArray(calculatedPositions[1], leftEdge.length - 3, startPoint);\n  endPoint = Cartesian3.fromArray(calculatedPositions[0], 0, endPoint);\n  cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\n  var firstEndCap = computeRoundCorner(cornerPoint, startPoint, endPoint, CornerType.ROUNDED, false);\n  var length = calculatedPositions.length - 1;\n  var rightEdge = calculatedPositions[length - 1];\n  leftEdge = calculatedPositions[length];\n  startPoint = Cartesian3.fromArray(rightEdge, rightEdge.length - 3, startPoint);\n  endPoint = Cartesian3.fromArray(leftEdge, 0, endPoint);\n  cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\n  var lastEndCap = computeRoundCorner(cornerPoint, startPoint, endPoint, CornerType.ROUNDED, false);\n  return [firstEndCap, lastEndCap];\n}\n\nfunction computeMiteredCorner(position, leftCornerDirection, lastPoint, leftIsOutside) {\n  var cornerPoint = scratch1;\n\n  if (leftIsOutside) {\n    cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\n  } else {\n    leftCornerDirection = Cartesian3.negate(leftCornerDirection, leftCornerDirection);\n    cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\n  }\n\n  return [cornerPoint.x, cornerPoint.y, cornerPoint.z, lastPoint.x, lastPoint.y, lastPoint.z];\n}\n\nfunction addShiftedPositions(positions, left, scalar, calculatedPositions) {\n  var rightPositions = new Array(positions.length);\n  var leftPositions = new Array(positions.length);\n  var scaledLeft = Cartesian3.multiplyByScalar(left, scalar, scratch1);\n  var scaledRight = Cartesian3.negate(scaledLeft, scratch2);\n  var rightIndex = 0;\n  var leftIndex = positions.length - 1;\n\n  for (var i = 0; i < positions.length; i += 3) {\n    var pos = Cartesian3.fromArray(positions, i, scratch3);\n    var rightPos = Cartesian3.add(pos, scaledRight, scratch4);\n    rightPositions[rightIndex++] = rightPos.x;\n    rightPositions[rightIndex++] = rightPos.y;\n    rightPositions[rightIndex++] = rightPos.z;\n    var leftPos = Cartesian3.add(pos, scaledLeft, scratch4);\n    leftPositions[leftIndex--] = leftPos.z;\n    leftPositions[leftIndex--] = leftPos.y;\n    leftPositions[leftIndex--] = leftPos.x;\n  }\n\n  calculatedPositions.push(rightPositions, leftPositions);\n  return calculatedPositions;\n}\n/**\n * @private\n */\n\n\nCorridorGeometryLibrary.addAttribute = function (attribute, value, front, back) {\n  var x = value.x;\n  var y = value.y;\n  var z = value.z;\n\n  if (defined(front)) {\n    attribute[front] = x;\n    attribute[front + 1] = y;\n    attribute[front + 2] = z;\n  }\n\n  if (defined(back)) {\n    attribute[back] = z;\n    attribute[back - 1] = y;\n    attribute[back - 2] = x;\n  }\n};\n\nvar scratchForwardProjection = new Cartesian3();\nvar scratchBackwardProjection = new Cartesian3();\n/**\n * @private\n */\n\nCorridorGeometryLibrary.computePositions = function (params) {\n  var granularity = params.granularity;\n  var positions = params.positions;\n  var ellipsoid = params.ellipsoid;\n  var width = params.width / 2;\n  var cornerType = params.cornerType;\n  var saveAttributes = params.saveAttributes;\n  var normal = cartesian1;\n  var forward = cartesian2;\n  var backward = cartesian3;\n  var left = cartesian4;\n  var cornerDirection = cartesian5;\n  var startPoint = cartesian6;\n  var previousPos = cartesian7;\n  var rightPos = cartesian8;\n  var leftPos = cartesian9;\n  var center = cartesian10;\n  var calculatedPositions = [];\n  var calculatedLefts = saveAttributes ? [] : undefined;\n  var calculatedNormals = saveAttributes ? [] : undefined;\n  var position = positions[0]; //add first point\n\n  var nextPosition = positions[1];\n  forward = Cartesian3.normalize(Cartesian3.subtract(nextPosition, position, forward), forward);\n  normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n  left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\n\n  if (saveAttributes) {\n    calculatedLefts.push(left.x, left.y, left.z);\n    calculatedNormals.push(normal.x, normal.y, normal.z);\n  }\n\n  previousPos = Cartesian3.clone(position, previousPos);\n  position = nextPosition;\n  backward = Cartesian3.negate(forward, backward);\n  var subdividedPositions;\n  var corners = [];\n  var i;\n  var length = positions.length;\n\n  for (i = 1; i < length - 1; i++) {\n    // add middle points and corners\n    normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n    nextPosition = positions[i + 1];\n    forward = Cartesian3.normalize(Cartesian3.subtract(nextPosition, position, forward), forward);\n    cornerDirection = Cartesian3.normalize(Cartesian3.add(forward, backward, cornerDirection), cornerDirection);\n    var forwardProjection = Cartesian3.multiplyByScalar(normal, Cartesian3.dot(forward, normal), scratchForwardProjection);\n    Cartesian3.subtract(forward, forwardProjection, forwardProjection);\n    Cartesian3.normalize(forwardProjection, forwardProjection);\n    var backwardProjection = Cartesian3.multiplyByScalar(normal, Cartesian3.dot(backward, normal), scratchBackwardProjection);\n    Cartesian3.subtract(backward, backwardProjection, backwardProjection);\n    Cartesian3.normalize(backwardProjection, backwardProjection);\n    var doCorner = !CesiumMath.equalsEpsilon(Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)), 1.0, CesiumMath.EPSILON7);\n\n    if (doCorner) {\n      cornerDirection = Cartesian3.cross(cornerDirection, normal, cornerDirection);\n      cornerDirection = Cartesian3.cross(normal, cornerDirection, cornerDirection);\n      cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n      var scalar = width / Math.max(0.25, Cartesian3.magnitude(Cartesian3.cross(cornerDirection, backward, scratch1)));\n      var leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(forward, backward, position, ellipsoid);\n      cornerDirection = Cartesian3.multiplyByScalar(cornerDirection, scalar, cornerDirection);\n\n      if (leftIsOutside) {\n        rightPos = Cartesian3.add(position, cornerDirection, rightPos);\n        center = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width, center), center);\n        leftPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width * 2, leftPos), leftPos);\n        scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n        scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scaleArray2,\n          granularity: granularity,\n          ellipsoid: ellipsoid\n        });\n        calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);\n\n        if (saveAttributes) {\n          calculatedLefts.push(left.x, left.y, left.z);\n          calculatedNormals.push(normal.x, normal.y, normal.z);\n        }\n\n        startPoint = Cartesian3.clone(leftPos, startPoint);\n        left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\n        leftPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width * 2, leftPos), leftPos);\n        previousPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width, previousPos), previousPos);\n\n        if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\n          corners.push({\n            leftPositions: computeRoundCorner(rightPos, startPoint, leftPos, cornerType, leftIsOutside)\n          });\n        } else {\n          corners.push({\n            leftPositions: computeMiteredCorner(position, Cartesian3.negate(cornerDirection, cornerDirection), leftPos, leftIsOutside)\n          });\n        }\n      } else {\n        leftPos = Cartesian3.add(position, cornerDirection, leftPos);\n        center = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width, center), center), center);\n        rightPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width * 2, rightPos), rightPos), rightPos);\n        scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n        scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scaleArray2,\n          granularity: granularity,\n          ellipsoid: ellipsoid\n        });\n        calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);\n\n        if (saveAttributes) {\n          calculatedLefts.push(left.x, left.y, left.z);\n          calculatedNormals.push(normal.x, normal.y, normal.z);\n        }\n\n        startPoint = Cartesian3.clone(rightPos, startPoint);\n        left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\n        rightPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width * 2, rightPos), rightPos), rightPos);\n        previousPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width, previousPos), previousPos), previousPos);\n\n        if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\n          corners.push({\n            rightPositions: computeRoundCorner(leftPos, startPoint, rightPos, cornerType, leftIsOutside)\n          });\n        } else {\n          corners.push({\n            rightPositions: computeMiteredCorner(position, cornerDirection, rightPos, leftIsOutside)\n          });\n        }\n      }\n\n      backward = Cartesian3.negate(forward, backward);\n    }\n\n    position = nextPosition;\n  }\n\n  normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n  scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n  scaleArray2[1] = Cartesian3.clone(position, scaleArray2[1]);\n  subdividedPositions = PolylinePipeline.generateArc({\n    positions: scaleArray2,\n    granularity: granularity,\n    ellipsoid: ellipsoid\n  });\n  calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);\n\n  if (saveAttributes) {\n    calculatedLefts.push(left.x, left.y, left.z);\n    calculatedNormals.push(normal.x, normal.y, normal.z);\n  }\n\n  var endPositions;\n\n  if (cornerType === CornerType.ROUNDED) {\n    endPositions = addEndCaps(calculatedPositions);\n  }\n\n  return {\n    positions: calculatedPositions,\n    corners: corners,\n    lefts: calculatedLefts,\n    normals: calculatedNormals,\n    endPositions: endPositions\n  };\n};\n\nexport default CorridorGeometryLibrary;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/CorridorGeometryLibrary.js"],"names":["Cartesian3","CornerType","defined","CesiumMath","Matrix3","PolylinePipeline","PolylineVolumeGeometryLibrary","Quaternion","CorridorGeometryLibrary","scratch1","scratch2","scratch3","scratch4","scaleArray2","cartesian1","cartesian2","cartesian3","cartesian4","cartesian5","cartesian6","cartesian7","cartesian8","cartesian9","cartesian10","quaterion","rotMatrix","computeRoundCorner","cornerPoint","startPoint","endPoint","cornerType","leftIsOutside","angle","angleBetween","subtract","granularity","BEVELED","Math","ceil","toRadians","size","array","Array","x","y","z","m","fromQuaternion","fromAxisAngle","negate","index","clone","i","multiplyByVector","addEndCaps","calculatedPositions","leftEdge","fromArray","length","midpoint","firstEndCap","ROUNDED","rightEdge","lastEndCap","computeMiteredCorner","position","leftCornerDirection","lastPoint","add","addShiftedPositions","positions","left","scalar","rightPositions","leftPositions","scaledLeft","multiplyByScalar","scaledRight","rightIndex","leftIndex","pos","rightPos","leftPos","push","addAttribute","attribute","value","front","back","scratchForwardProjection","scratchBackwardProjection","computePositions","params","ellipsoid","width","saveAttributes","normal","forward","backward","cornerDirection","previousPos","center","calculatedLefts","undefined","calculatedNormals","nextPosition","normalize","geodeticSurfaceNormal","cross","subdividedPositions","corners","forwardProjection","dot","backwardProjection","doCorner","equalsEpsilon","abs","EPSILON7","max","magnitude","angleIsGreaterThanPi","generateArc","endPositions","lefts","normals"],"mappings":"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","sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport CornerType from \"./CornerType.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport PolylineVolumeGeometryLibrary from \"./PolylineVolumeGeometryLibrary.js\";\nimport Quaternion from \"./Quaternion.js\";\n\n/**\n * @private\n */\nvar CorridorGeometryLibrary = {};\n\nvar scratch1 = new Cartesian3();\nvar scratch2 = new Cartesian3();\nvar scratch3 = new Cartesian3();\nvar scratch4 = new Cartesian3();\n\nvar scaleArray2 = [new Cartesian3(), new Cartesian3()];\n\nvar cartesian1 = new Cartesian3();\nvar cartesian2 = new Cartesian3();\nvar cartesian3 = new Cartesian3();\nvar cartesian4 = new Cartesian3();\nvar cartesian5 = new Cartesian3();\nvar cartesian6 = new Cartesian3();\nvar cartesian7 = new Cartesian3();\nvar cartesian8 = new Cartesian3();\nvar cartesian9 = new Cartesian3();\nvar cartesian10 = new Cartesian3();\n\nvar quaterion = new Quaternion();\nvar rotMatrix = new Matrix3();\nfunction computeRoundCorner(\n  cornerPoint,\n  startPoint,\n  endPoint,\n  cornerType,\n  leftIsOutside\n) {\n  var angle = Cartesian3.angleBetween(\n    Cartesian3.subtract(startPoint, cornerPoint, scratch1),\n    Cartesian3.subtract(endPoint, cornerPoint, scratch2)\n  );\n  var granularity =\n    cornerType === CornerType.BEVELED\n      ? 1\n      : Math.ceil(angle / CesiumMath.toRadians(5)) + 1;\n\n  var size = granularity * 3;\n  var array = new Array(size);\n\n  array[size - 3] = endPoint.x;\n  array[size - 2] = endPoint.y;\n  array[size - 1] = endPoint.z;\n\n  var m;\n  if (leftIsOutside) {\n    m = Matrix3.fromQuaternion(\n      Quaternion.fromAxisAngle(\n        Cartesian3.negate(cornerPoint, scratch1),\n        angle / granularity,\n        quaterion\n      ),\n      rotMatrix\n    );\n  } else {\n    m = Matrix3.fromQuaternion(\n      Quaternion.fromAxisAngle(cornerPoint, angle / granularity, quaterion),\n      rotMatrix\n    );\n  }\n\n  var index = 0;\n  startPoint = Cartesian3.clone(startPoint, scratch1);\n  for (var i = 0; i < granularity; i++) {\n    startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\n    array[index++] = startPoint.x;\n    array[index++] = startPoint.y;\n    array[index++] = startPoint.z;\n  }\n\n  return array;\n}\n\nfunction addEndCaps(calculatedPositions) {\n  var cornerPoint = cartesian1;\n  var startPoint = cartesian2;\n  var endPoint = cartesian3;\n\n  var leftEdge = calculatedPositions[1];\n  startPoint = Cartesian3.fromArray(\n    calculatedPositions[1],\n    leftEdge.length - 3,\n    startPoint\n  );\n  endPoint = Cartesian3.fromArray(calculatedPositions[0], 0, endPoint);\n  cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\n  var firstEndCap = computeRoundCorner(\n    cornerPoint,\n    startPoint,\n    endPoint,\n    CornerType.ROUNDED,\n    false\n  );\n\n  var length = calculatedPositions.length - 1;\n  var rightEdge = calculatedPositions[length - 1];\n  leftEdge = calculatedPositions[length];\n  startPoint = Cartesian3.fromArray(\n    rightEdge,\n    rightEdge.length - 3,\n    startPoint\n  );\n  endPoint = Cartesian3.fromArray(leftEdge, 0, endPoint);\n  cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\n  var lastEndCap = computeRoundCorner(\n    cornerPoint,\n    startPoint,\n    endPoint,\n    CornerType.ROUNDED,\n    false\n  );\n\n  return [firstEndCap, lastEndCap];\n}\n\nfunction computeMiteredCorner(\n  position,\n  leftCornerDirection,\n  lastPoint,\n  leftIsOutside\n) {\n  var cornerPoint = scratch1;\n  if (leftIsOutside) {\n    cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\n  } else {\n    leftCornerDirection = Cartesian3.negate(\n      leftCornerDirection,\n      leftCornerDirection\n    );\n    cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\n  }\n  return [\n    cornerPoint.x,\n    cornerPoint.y,\n    cornerPoint.z,\n    lastPoint.x,\n    lastPoint.y,\n    lastPoint.z,\n  ];\n}\n\nfunction addShiftedPositions(positions, left, scalar, calculatedPositions) {\n  var rightPositions = new Array(positions.length);\n  var leftPositions = new Array(positions.length);\n  var scaledLeft = Cartesian3.multiplyByScalar(left, scalar, scratch1);\n  var scaledRight = Cartesian3.negate(scaledLeft, scratch2);\n  var rightIndex = 0;\n  var leftIndex = positions.length - 1;\n\n  for (var i = 0; i < positions.length; i += 3) {\n    var pos = Cartesian3.fromArray(positions, i, scratch3);\n    var rightPos = Cartesian3.add(pos, scaledRight, scratch4);\n    rightPositions[rightIndex++] = rightPos.x;\n    rightPositions[rightIndex++] = rightPos.y;\n    rightPositions[rightIndex++] = rightPos.z;\n\n    var leftPos = Cartesian3.add(pos, scaledLeft, scratch4);\n    leftPositions[leftIndex--] = leftPos.z;\n    leftPositions[leftIndex--] = leftPos.y;\n    leftPositions[leftIndex--] = leftPos.x;\n  }\n  calculatedPositions.push(rightPositions, leftPositions);\n\n  return calculatedPositions;\n}\n\n/**\n * @private\n */\nCorridorGeometryLibrary.addAttribute = function (\n  attribute,\n  value,\n  front,\n  back\n) {\n  var x = value.x;\n  var y = value.y;\n  var z = value.z;\n  if (defined(front)) {\n    attribute[front] = x;\n    attribute[front + 1] = y;\n    attribute[front + 2] = z;\n  }\n  if (defined(back)) {\n    attribute[back] = z;\n    attribute[back - 1] = y;\n    attribute[back - 2] = x;\n  }\n};\n\nvar scratchForwardProjection = new Cartesian3();\nvar scratchBackwardProjection = new Cartesian3();\n\n/**\n * @private\n */\nCorridorGeometryLibrary.computePositions = function (params) {\n  var granularity = params.granularity;\n  var positions = params.positions;\n  var ellipsoid = params.ellipsoid;\n  var width = params.width / 2;\n  var cornerType = params.cornerType;\n  var saveAttributes = params.saveAttributes;\n  var normal = cartesian1;\n  var forward = cartesian2;\n  var backward = cartesian3;\n  var left = cartesian4;\n  var cornerDirection = cartesian5;\n  var startPoint = cartesian6;\n  var previousPos = cartesian7;\n  var rightPos = cartesian8;\n  var leftPos = cartesian9;\n  var center = cartesian10;\n  var calculatedPositions = [];\n  var calculatedLefts = saveAttributes ? [] : undefined;\n  var calculatedNormals = saveAttributes ? [] : undefined;\n  var position = positions[0]; //add first point\n  var nextPosition = positions[1];\n\n  forward = Cartesian3.normalize(\n    Cartesian3.subtract(nextPosition, position, forward),\n    forward\n  );\n  normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n  left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\n  if (saveAttributes) {\n    calculatedLefts.push(left.x, left.y, left.z);\n    calculatedNormals.push(normal.x, normal.y, normal.z);\n  }\n  previousPos = Cartesian3.clone(position, previousPos);\n  position = nextPosition;\n  backward = Cartesian3.negate(forward, backward);\n\n  var subdividedPositions;\n  var corners = [];\n  var i;\n  var length = positions.length;\n  for (i = 1; i < length - 1; i++) {\n    // add middle points and corners\n    normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n    nextPosition = positions[i + 1];\n    forward = Cartesian3.normalize(\n      Cartesian3.subtract(nextPosition, position, forward),\n      forward\n    );\n    cornerDirection = Cartesian3.normalize(\n      Cartesian3.add(forward, backward, cornerDirection),\n      cornerDirection\n    );\n\n    var forwardProjection = Cartesian3.multiplyByScalar(\n      normal,\n      Cartesian3.dot(forward, normal),\n      scratchForwardProjection\n    );\n    Cartesian3.subtract(forward, forwardProjection, forwardProjection);\n    Cartesian3.normalize(forwardProjection, forwardProjection);\n\n    var backwardProjection = Cartesian3.multiplyByScalar(\n      normal,\n      Cartesian3.dot(backward, normal),\n      scratchBackwardProjection\n    );\n    Cartesian3.subtract(backward, backwardProjection, backwardProjection);\n    Cartesian3.normalize(backwardProjection, backwardProjection);\n\n    var doCorner = !CesiumMath.equalsEpsilon(\n      Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)),\n      1.0,\n      CesiumMath.EPSILON7\n    );\n\n    if (doCorner) {\n      cornerDirection = Cartesian3.cross(\n        cornerDirection,\n        normal,\n        cornerDirection\n      );\n      cornerDirection = Cartesian3.cross(\n        normal,\n        cornerDirection,\n        cornerDirection\n      );\n      cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n      var scalar =\n        width /\n        Math.max(\n          0.25,\n          Cartesian3.magnitude(\n            Cartesian3.cross(cornerDirection, backward, scratch1)\n          )\n        );\n      var leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(\n        forward,\n        backward,\n        position,\n        ellipsoid\n      );\n      cornerDirection = Cartesian3.multiplyByScalar(\n        cornerDirection,\n        scalar,\n        cornerDirection\n      );\n      if (leftIsOutside) {\n        rightPos = Cartesian3.add(position, cornerDirection, rightPos);\n        center = Cartesian3.add(\n          rightPos,\n          Cartesian3.multiplyByScalar(left, width, center),\n          center\n        );\n        leftPos = Cartesian3.add(\n          rightPos,\n          Cartesian3.multiplyByScalar(left, width * 2, leftPos),\n          leftPos\n        );\n        scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n        scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scaleArray2,\n          granularity: granularity,\n          ellipsoid: ellipsoid,\n        });\n        calculatedPositions = addShiftedPositions(\n          subdividedPositions,\n          left,\n          width,\n          calculatedPositions\n        );\n        if (saveAttributes) {\n          calculatedLefts.push(left.x, left.y, left.z);\n          calculatedNormals.push(normal.x, normal.y, normal.z);\n        }\n        startPoint = Cartesian3.clone(leftPos, startPoint);\n        left = Cartesian3.normalize(\n          Cartesian3.cross(normal, forward, left),\n          left\n        );\n        leftPos = Cartesian3.add(\n          rightPos,\n          Cartesian3.multiplyByScalar(left, width * 2, leftPos),\n          leftPos\n        );\n        previousPos = Cartesian3.add(\n          rightPos,\n          Cartesian3.multiplyByScalar(left, width, previousPos),\n          previousPos\n        );\n        if (\n          cornerType === CornerType.ROUNDED ||\n          cornerType === CornerType.BEVELED\n        ) {\n          corners.push({\n            leftPositions: computeRoundCorner(\n              rightPos,\n              startPoint,\n              leftPos,\n              cornerType,\n              leftIsOutside\n            ),\n          });\n        } else {\n          corners.push({\n            leftPositions: computeMiteredCorner(\n              position,\n              Cartesian3.negate(cornerDirection, cornerDirection),\n              leftPos,\n              leftIsOutside\n            ),\n          });\n        }\n      } else {\n        leftPos = Cartesian3.add(position, cornerDirection, leftPos);\n        center = Cartesian3.add(\n          leftPos,\n          Cartesian3.negate(\n            Cartesian3.multiplyByScalar(left, width, center),\n            center\n          ),\n          center\n        );\n        rightPos = Cartesian3.add(\n          leftPos,\n          Cartesian3.negate(\n            Cartesian3.multiplyByScalar(left, width * 2, rightPos),\n            rightPos\n          ),\n          rightPos\n        );\n        scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n        scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scaleArray2,\n          granularity: granularity,\n          ellipsoid: ellipsoid,\n        });\n        calculatedPositions = addShiftedPositions(\n          subdividedPositions,\n          left,\n          width,\n          calculatedPositions\n        );\n        if (saveAttributes) {\n          calculatedLefts.push(left.x, left.y, left.z);\n          calculatedNormals.push(normal.x, normal.y, normal.z);\n        }\n        startPoint = Cartesian3.clone(rightPos, startPoint);\n        left = Cartesian3.normalize(\n          Cartesian3.cross(normal, forward, left),\n          left\n        );\n        rightPos = Cartesian3.add(\n          leftPos,\n          Cartesian3.negate(\n            Cartesian3.multiplyByScalar(left, width * 2, rightPos),\n            rightPos\n          ),\n          rightPos\n        );\n        previousPos = Cartesian3.add(\n          leftPos,\n          Cartesian3.negate(\n            Cartesian3.multiplyByScalar(left, width, previousPos),\n            previousPos\n          ),\n          previousPos\n        );\n        if (\n          cornerType === CornerType.ROUNDED ||\n          cornerType === CornerType.BEVELED\n        ) {\n          corners.push({\n            rightPositions: computeRoundCorner(\n              leftPos,\n              startPoint,\n              rightPos,\n              cornerType,\n              leftIsOutside\n            ),\n          });\n        } else {\n          corners.push({\n            rightPositions: computeMiteredCorner(\n              position,\n              cornerDirection,\n              rightPos,\n              leftIsOutside\n            ),\n          });\n        }\n      }\n      backward = Cartesian3.negate(forward, backward);\n    }\n    position = nextPosition;\n  }\n\n  normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n  scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n  scaleArray2[1] = Cartesian3.clone(position, scaleArray2[1]);\n  subdividedPositions = PolylinePipeline.generateArc({\n    positions: scaleArray2,\n    granularity: granularity,\n    ellipsoid: ellipsoid,\n  });\n  calculatedPositions = addShiftedPositions(\n    subdividedPositions,\n    left,\n    width,\n    calculatedPositions\n  );\n  if (saveAttributes) {\n    calculatedLefts.push(left.x, left.y, left.z);\n    calculatedNormals.push(normal.x, normal.y, normal.z);\n  }\n\n  var endPositions;\n  if (cornerType === CornerType.ROUNDED) {\n    endPositions = addEndCaps(calculatedPositions);\n  }\n\n  return {\n    positions: calculatedPositions,\n    corners: corners,\n    lefts: calculatedLefts,\n    normals: calculatedNormals,\n    endPositions: endPositions,\n  };\n};\nexport default CorridorGeometryLibrary;\n"]},"metadata":{},"sourceType":"module"}