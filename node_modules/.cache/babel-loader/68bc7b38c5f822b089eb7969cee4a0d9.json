{"ast":null,"code":"import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport CorridorGeometry from \"../Core/CorridorGeometry.js\";\nimport CorridorOutlineGeometry from \"../Core/CorridorOutlineGeometry.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport DynamicGeometryUpdater from \"./DynamicGeometryUpdater.js\";\nimport GeometryUpdater from \"./GeometryUpdater.js\";\nimport GroundGeometryUpdater from \"./GroundGeometryUpdater.js\";\nimport Property from \"./Property.js\";\nvar scratchColor = new Color();\nvar defaultOffset = Cartesian3.ZERO;\nvar offsetScratch = new Cartesian3();\nvar scratchRectangle = new Rectangle();\n\nfunction CorridorGeometryOptions(entity) {\n  this.id = entity;\n  this.vertexFormat = undefined;\n  this.positions = undefined;\n  this.width = undefined;\n  this.cornerType = undefined;\n  this.height = undefined;\n  this.extrudedHeight = undefined;\n  this.granularity = undefined;\n  this.offsetAttribute = undefined;\n}\n/**\n * A {@link GeometryUpdater} for corridors.\n * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n * @alias CorridorGeometryUpdater\n * @constructor\n *\n * @param {Entity} entity The entity containing the geometry to be visualized.\n * @param {Scene} scene The scene where visualization is taking place.\n */\n\n\nfunction CorridorGeometryUpdater(entity, scene) {\n  GroundGeometryUpdater.call(this, {\n    entity: entity,\n    scene: scene,\n    geometryOptions: new CorridorGeometryOptions(entity),\n    geometryPropertyName: \"corridor\",\n    observedPropertyNames: [\"availability\", \"corridor\"]\n  });\n\n  this._onEntityPropertyChanged(entity, \"corridor\", entity.corridor, undefined);\n}\n\nif (defined(Object.create)) {\n  CorridorGeometryUpdater.prototype = Object.create(GroundGeometryUpdater.prototype);\n  CorridorGeometryUpdater.prototype.constructor = CorridorGeometryUpdater;\n}\n/**\n * Creates the geometry instance which represents the fill of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent a filled geometry.\n */\n\n\nCorridorGeometryUpdater.prototype.createFillGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n\n  if (!this._fillEnabled) {\n    throw new DeveloperError(\"This instance does not represent a filled geometry.\");\n  } //>>includeEnd('debug');\n\n\n  var entity = this._entity;\n  var isAvailable = entity.isAvailable(time);\n  var attributes = {\n    show: new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time)),\n    distanceDisplayCondition: DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),\n    offset: undefined,\n    color: undefined\n  };\n\n  if (this._materialProperty instanceof ColorMaterialProperty) {\n    var currentColor;\n\n    if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n      currentColor = this._materialProperty.color.getValue(time, scratchColor);\n    }\n\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n\n    attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n  }\n\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new CorridorGeometry(this._options),\n    attributes: attributes\n  });\n};\n/**\n * Creates the geometry instance which represents the outline of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent an outlined geometry.\n */\n\n\nCorridorGeometryUpdater.prototype.createOutlineGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n\n  if (!this._outlineEnabled) {\n    throw new DeveloperError(\"This instance does not represent an outlined geometry.\");\n  } //>>includeEnd('debug');\n\n\n  var entity = this._entity;\n  var isAvailable = entity.isAvailable(time);\n  var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n  var attributes = {\n    show: new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n    color: ColorGeometryInstanceAttribute.fromColor(outlineColor),\n    distanceDisplayCondition: DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),\n    offset: undefined\n  };\n\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new CorridorOutlineGeometry(this._options),\n    attributes: attributes\n  });\n};\n\nCorridorGeometryUpdater.prototype._computeCenter = function (time, result) {\n  var positions = Property.getValueOrUndefined(this._entity.corridor.positions, time);\n\n  if (!defined(positions) || positions.length === 0) {\n    return;\n  }\n\n  return Cartesian3.clone(positions[Math.floor(positions.length / 2.0)], result);\n};\n\nCorridorGeometryUpdater.prototype._isHidden = function (entity, corridor) {\n  return !defined(corridor.positions) || !defined(corridor.width) || GeometryUpdater.prototype._isHidden.call(this, entity, corridor);\n};\n\nCorridorGeometryUpdater.prototype._isDynamic = function (entity, corridor) {\n  return !corridor.positions.isConstant || //\n  !Property.isConstant(corridor.height) || //\n  !Property.isConstant(corridor.extrudedHeight) || //\n  !Property.isConstant(corridor.granularity) || //\n  !Property.isConstant(corridor.width) || //\n  !Property.isConstant(corridor.outlineWidth) || //\n  !Property.isConstant(corridor.cornerType) || //\n  !Property.isConstant(corridor.zIndex) || //\n  this._onTerrain && !Property.isConstant(this._materialProperty) && !(this._materialProperty instanceof ColorMaterialProperty);\n};\n\nCorridorGeometryUpdater.prototype._setStaticOptions = function (entity, corridor) {\n  var heightValue = Property.getValueOrUndefined(corridor.height, Iso8601.MINIMUM_VALUE);\n  var heightReferenceValue = Property.getValueOrDefault(corridor.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n  var extrudedHeightValue = Property.getValueOrUndefined(corridor.extrudedHeight, Iso8601.MINIMUM_VALUE);\n  var extrudedHeightReferenceValue = Property.getValueOrDefault(corridor.extrudedHeightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n\n  if (defined(extrudedHeightValue) && !defined(heightValue)) {\n    heightValue = 0;\n  }\n\n  var options = this._options;\n  options.vertexFormat = this._materialProperty instanceof ColorMaterialProperty ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n  options.positions = corridor.positions.getValue(Iso8601.MINIMUM_VALUE, options.positions);\n  options.width = corridor.width.getValue(Iso8601.MINIMUM_VALUE);\n  options.granularity = Property.getValueOrUndefined(corridor.granularity, Iso8601.MINIMUM_VALUE);\n  options.cornerType = Property.getValueOrUndefined(corridor.cornerType, Iso8601.MINIMUM_VALUE);\n  options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n  options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n  extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n\n  if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n    extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(CorridorGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n  }\n\n  options.extrudedHeight = extrudedHeightValue;\n};\n\nCorridorGeometryUpdater.DynamicGeometryUpdater = DynamicCorridorGeometryUpdater;\n/**\n * @private\n */\n\nfunction DynamicCorridorGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n  DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n}\n\nif (defined(Object.create)) {\n  DynamicCorridorGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n  DynamicCorridorGeometryUpdater.prototype.constructor = DynamicCorridorGeometryUpdater;\n}\n\nDynamicCorridorGeometryUpdater.prototype._isHidden = function (entity, corridor, time) {\n  var options = this._options;\n  return !defined(options.positions) || !defined(options.width) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, corridor, time);\n};\n\nDynamicCorridorGeometryUpdater.prototype._setOptions = function (entity, corridor, time) {\n  var options = this._options;\n  var heightValue = Property.getValueOrUndefined(corridor.height, time);\n  var heightReferenceValue = Property.getValueOrDefault(corridor.heightReference, time, HeightReference.NONE);\n  var extrudedHeightValue = Property.getValueOrUndefined(corridor.extrudedHeight, time);\n  var extrudedHeightReferenceValue = Property.getValueOrDefault(corridor.extrudedHeightReference, time, HeightReference.NONE);\n\n  if (defined(extrudedHeightValue) && !defined(heightValue)) {\n    heightValue = 0;\n  }\n\n  options.positions = Property.getValueOrUndefined(corridor.positions, time);\n  options.width = Property.getValueOrUndefined(corridor.width, time);\n  options.granularity = Property.getValueOrUndefined(corridor.granularity, time);\n  options.cornerType = Property.getValueOrUndefined(corridor.cornerType, time);\n  options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n  options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n  extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n\n  if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n    extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(CorridorGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n  }\n\n  options.extrudedHeight = extrudedHeightValue;\n};\n\nexport default CorridorGeometryUpdater;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/DataSources/CorridorGeometryUpdater.js"],"names":["ApproximateTerrainHeights","Cartesian3","Check","Color","ColorGeometryInstanceAttribute","CorridorGeometry","CorridorOutlineGeometry","defined","DeveloperError","DistanceDisplayConditionGeometryInstanceAttribute","GeometryInstance","Iso8601","OffsetGeometryInstanceAttribute","Rectangle","ShowGeometryInstanceAttribute","HeightReference","MaterialAppearance","PerInstanceColorAppearance","ColorMaterialProperty","DynamicGeometryUpdater","GeometryUpdater","GroundGeometryUpdater","Property","scratchColor","defaultOffset","ZERO","offsetScratch","scratchRectangle","CorridorGeometryOptions","entity","id","vertexFormat","undefined","positions","width","cornerType","height","extrudedHeight","granularity","offsetAttribute","CorridorGeometryUpdater","scene","call","geometryOptions","geometryPropertyName","observedPropertyNames","_onEntityPropertyChanged","corridor","Object","create","prototype","constructor","createFillGeometryInstance","time","_fillEnabled","_entity","isAvailable","attributes","show","isShowing","_showProperty","getValue","_fillProperty","distanceDisplayCondition","fromDistanceDisplayCondition","_distanceDisplayConditionProperty","offset","color","_materialProperty","currentColor","isConstant","WHITE","fromColor","_options","fromCartesian3","getValueOrDefault","_terrainOffsetProperty","geometry","createOutlineGeometryInstance","_outlineEnabled","outlineColor","_outlineColorProperty","BLACK","_showOutlineProperty","_computeCenter","result","getValueOrUndefined","length","clone","Math","floor","_isHidden","_isDynamic","outlineWidth","zIndex","_onTerrain","_setStaticOptions","heightValue","MINIMUM_VALUE","heightReferenceValue","heightReference","NONE","extrudedHeightValue","extrudedHeightReferenceValue","extrudedHeightReference","options","VERTEX_FORMAT","MaterialSupport","TEXTURED","computeGeometryOffsetAttribute","getGeometryHeight","getGeometryExtrudedHeight","CLAMP_TO_GROUND","getMinimumMaximumHeights","computeRectangle","minimumTerrainHeight","DynamicCorridorGeometryUpdater","geometryUpdater","primitives","groundPrimitives","_setOptions"],"mappings":"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","sourcesContent":["import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport CorridorGeometry from \"../Core/CorridorGeometry.js\";\nimport CorridorOutlineGeometry from \"../Core/CorridorOutlineGeometry.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport DynamicGeometryUpdater from \"./DynamicGeometryUpdater.js\";\nimport GeometryUpdater from \"./GeometryUpdater.js\";\nimport GroundGeometryUpdater from \"./GroundGeometryUpdater.js\";\nimport Property from \"./Property.js\";\n\nvar scratchColor = new Color();\nvar defaultOffset = Cartesian3.ZERO;\nvar offsetScratch = new Cartesian3();\nvar scratchRectangle = new Rectangle();\n\nfunction CorridorGeometryOptions(entity) {\n  this.id = entity;\n  this.vertexFormat = undefined;\n  this.positions = undefined;\n  this.width = undefined;\n  this.cornerType = undefined;\n  this.height = undefined;\n  this.extrudedHeight = undefined;\n  this.granularity = undefined;\n  this.offsetAttribute = undefined;\n}\n\n/**\n * A {@link GeometryUpdater} for corridors.\n * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n * @alias CorridorGeometryUpdater\n * @constructor\n *\n * @param {Entity} entity The entity containing the geometry to be visualized.\n * @param {Scene} scene The scene where visualization is taking place.\n */\nfunction CorridorGeometryUpdater(entity, scene) {\n  GroundGeometryUpdater.call(this, {\n    entity: entity,\n    scene: scene,\n    geometryOptions: new CorridorGeometryOptions(entity),\n    geometryPropertyName: \"corridor\",\n    observedPropertyNames: [\"availability\", \"corridor\"],\n  });\n\n  this._onEntityPropertyChanged(entity, \"corridor\", entity.corridor, undefined);\n}\n\nif (defined(Object.create)) {\n  CorridorGeometryUpdater.prototype = Object.create(\n    GroundGeometryUpdater.prototype\n  );\n  CorridorGeometryUpdater.prototype.constructor = CorridorGeometryUpdater;\n}\n\n/**\n * Creates the geometry instance which represents the fill of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent a filled geometry.\n */\nCorridorGeometryUpdater.prototype.createFillGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n\n  if (!this._fillEnabled) {\n    throw new DeveloperError(\n      \"This instance does not represent a filled geometry.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var entity = this._entity;\n  var isAvailable = entity.isAvailable(time);\n\n  var attributes = {\n    show: new ShowGeometryInstanceAttribute(\n      isAvailable &&\n        entity.isShowing &&\n        this._showProperty.getValue(time) &&\n        this._fillProperty.getValue(time)\n    ),\n    distanceDisplayCondition: DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(\n      this._distanceDisplayConditionProperty.getValue(time)\n    ),\n    offset: undefined,\n    color: undefined,\n  };\n\n  if (this._materialProperty instanceof ColorMaterialProperty) {\n    var currentColor;\n    if (\n      defined(this._materialProperty.color) &&\n      (this._materialProperty.color.isConstant || isAvailable)\n    ) {\n      currentColor = this._materialProperty.color.getValue(time, scratchColor);\n    }\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n    attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n  }\n\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(\n      Property.getValueOrDefault(\n        this._terrainOffsetProperty,\n        time,\n        defaultOffset,\n        offsetScratch\n      )\n    );\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new CorridorGeometry(this._options),\n    attributes: attributes,\n  });\n};\n\n/**\n * Creates the geometry instance which represents the outline of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent an outlined geometry.\n */\nCorridorGeometryUpdater.prototype.createOutlineGeometryInstance = function (\n  time\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n\n  if (!this._outlineEnabled) {\n    throw new DeveloperError(\n      \"This instance does not represent an outlined geometry.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var entity = this._entity;\n  var isAvailable = entity.isAvailable(time);\n  var outlineColor = Property.getValueOrDefault(\n    this._outlineColorProperty,\n    time,\n    Color.BLACK,\n    scratchColor\n  );\n\n  var attributes = {\n    show: new ShowGeometryInstanceAttribute(\n      isAvailable &&\n        entity.isShowing &&\n        this._showProperty.getValue(time) &&\n        this._showOutlineProperty.getValue(time)\n    ),\n    color: ColorGeometryInstanceAttribute.fromColor(outlineColor),\n    distanceDisplayCondition: DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(\n      this._distanceDisplayConditionProperty.getValue(time)\n    ),\n    offset: undefined,\n  };\n\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(\n      Property.getValueOrDefault(\n        this._terrainOffsetProperty,\n        time,\n        defaultOffset,\n        offsetScratch\n      )\n    );\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new CorridorOutlineGeometry(this._options),\n    attributes: attributes,\n  });\n};\n\nCorridorGeometryUpdater.prototype._computeCenter = function (time, result) {\n  var positions = Property.getValueOrUndefined(\n    this._entity.corridor.positions,\n    time\n  );\n  if (!defined(positions) || positions.length === 0) {\n    return;\n  }\n  return Cartesian3.clone(\n    positions[Math.floor(positions.length / 2.0)],\n    result\n  );\n};\n\nCorridorGeometryUpdater.prototype._isHidden = function (entity, corridor) {\n  return (\n    !defined(corridor.positions) ||\n    !defined(corridor.width) ||\n    GeometryUpdater.prototype._isHidden.call(this, entity, corridor)\n  );\n};\n\nCorridorGeometryUpdater.prototype._isDynamic = function (entity, corridor) {\n  return (\n    !corridor.positions.isConstant || //\n    !Property.isConstant(corridor.height) || //\n    !Property.isConstant(corridor.extrudedHeight) || //\n    !Property.isConstant(corridor.granularity) || //\n    !Property.isConstant(corridor.width) || //\n    !Property.isConstant(corridor.outlineWidth) || //\n    !Property.isConstant(corridor.cornerType) || //\n    !Property.isConstant(corridor.zIndex) || //\n    (this._onTerrain &&\n      !Property.isConstant(this._materialProperty) &&\n      !(this._materialProperty instanceof ColorMaterialProperty))\n  );\n};\n\nCorridorGeometryUpdater.prototype._setStaticOptions = function (\n  entity,\n  corridor\n) {\n  var heightValue = Property.getValueOrUndefined(\n    corridor.height,\n    Iso8601.MINIMUM_VALUE\n  );\n  var heightReferenceValue = Property.getValueOrDefault(\n    corridor.heightReference,\n    Iso8601.MINIMUM_VALUE,\n    HeightReference.NONE\n  );\n  var extrudedHeightValue = Property.getValueOrUndefined(\n    corridor.extrudedHeight,\n    Iso8601.MINIMUM_VALUE\n  );\n  var extrudedHeightReferenceValue = Property.getValueOrDefault(\n    corridor.extrudedHeightReference,\n    Iso8601.MINIMUM_VALUE,\n    HeightReference.NONE\n  );\n  if (defined(extrudedHeightValue) && !defined(heightValue)) {\n    heightValue = 0;\n  }\n\n  var options = this._options;\n  options.vertexFormat =\n    this._materialProperty instanceof ColorMaterialProperty\n      ? PerInstanceColorAppearance.VERTEX_FORMAT\n      : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n  options.positions = corridor.positions.getValue(\n    Iso8601.MINIMUM_VALUE,\n    options.positions\n  );\n  options.width = corridor.width.getValue(Iso8601.MINIMUM_VALUE);\n  options.granularity = Property.getValueOrUndefined(\n    corridor.granularity,\n    Iso8601.MINIMUM_VALUE\n  );\n  options.cornerType = Property.getValueOrUndefined(\n    corridor.cornerType,\n    Iso8601.MINIMUM_VALUE\n  );\n  options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(\n    heightValue,\n    heightReferenceValue,\n    extrudedHeightValue,\n    extrudedHeightReferenceValue\n  );\n  options.height = GroundGeometryUpdater.getGeometryHeight(\n    heightValue,\n    heightReferenceValue\n  );\n\n  extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(\n    extrudedHeightValue,\n    extrudedHeightReferenceValue\n  );\n  if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n    extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(\n      CorridorGeometry.computeRectangle(options, scratchRectangle)\n    ).minimumTerrainHeight;\n  }\n\n  options.extrudedHeight = extrudedHeightValue;\n};\n\nCorridorGeometryUpdater.DynamicGeometryUpdater = DynamicCorridorGeometryUpdater;\n\n/**\n * @private\n */\nfunction DynamicCorridorGeometryUpdater(\n  geometryUpdater,\n  primitives,\n  groundPrimitives\n) {\n  DynamicGeometryUpdater.call(\n    this,\n    geometryUpdater,\n    primitives,\n    groundPrimitives\n  );\n}\n\nif (defined(Object.create)) {\n  DynamicCorridorGeometryUpdater.prototype = Object.create(\n    DynamicGeometryUpdater.prototype\n  );\n  DynamicCorridorGeometryUpdater.prototype.constructor = DynamicCorridorGeometryUpdater;\n}\n\nDynamicCorridorGeometryUpdater.prototype._isHidden = function (\n  entity,\n  corridor,\n  time\n) {\n  var options = this._options;\n  return (\n    !defined(options.positions) ||\n    !defined(options.width) ||\n    DynamicGeometryUpdater.prototype._isHidden.call(\n      this,\n      entity,\n      corridor,\n      time\n    )\n  );\n};\n\nDynamicCorridorGeometryUpdater.prototype._setOptions = function (\n  entity,\n  corridor,\n  time\n) {\n  var options = this._options;\n  var heightValue = Property.getValueOrUndefined(corridor.height, time);\n  var heightReferenceValue = Property.getValueOrDefault(\n    corridor.heightReference,\n    time,\n    HeightReference.NONE\n  );\n  var extrudedHeightValue = Property.getValueOrUndefined(\n    corridor.extrudedHeight,\n    time\n  );\n  var extrudedHeightReferenceValue = Property.getValueOrDefault(\n    corridor.extrudedHeightReference,\n    time,\n    HeightReference.NONE\n  );\n  if (defined(extrudedHeightValue) && !defined(heightValue)) {\n    heightValue = 0;\n  }\n\n  options.positions = Property.getValueOrUndefined(corridor.positions, time);\n  options.width = Property.getValueOrUndefined(corridor.width, time);\n  options.granularity = Property.getValueOrUndefined(\n    corridor.granularity,\n    time\n  );\n  options.cornerType = Property.getValueOrUndefined(corridor.cornerType, time);\n  options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(\n    heightValue,\n    heightReferenceValue,\n    extrudedHeightValue,\n    extrudedHeightReferenceValue\n  );\n  options.height = GroundGeometryUpdater.getGeometryHeight(\n    heightValue,\n    heightReferenceValue\n  );\n\n  extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(\n    extrudedHeightValue,\n    extrudedHeightReferenceValue\n  );\n  if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n    extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(\n      CorridorGeometry.computeRectangle(options, scratchRectangle)\n    ).minimumTerrainHeight;\n  }\n\n  options.extrudedHeight = extrudedHeightValue;\n};\nexport default CorridorGeometryUpdater;\n"]},"metadata":{},"sourceType":"module"}