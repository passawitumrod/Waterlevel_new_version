{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport LinearSpline from \"./LinearSpline.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Spline from \"./Spline.js\";\nimport TridiagonalSystemSolver from \"./TridiagonalSystemSolver.js\";\nvar scratchLower = [];\nvar scratchDiagonal = [];\nvar scratchUpper = [];\nvar scratchRight = [];\n\nfunction generateClamped(points, firstTangent, lastTangent) {\n  var l = scratchLower;\n  var u = scratchUpper;\n  var d = scratchDiagonal;\n  var r = scratchRight;\n  l.length = u.length = points.length - 1;\n  d.length = r.length = points.length;\n  var i;\n  l[0] = d[0] = 1.0;\n  u[0] = 0.0;\n  var right = r[0];\n\n  if (!defined(right)) {\n    right = r[0] = new Cartesian3();\n  }\n\n  Cartesian3.clone(firstTangent, right);\n\n  for (i = 1; i < l.length - 1; ++i) {\n    l[i] = u[i] = 1.0;\n    d[i] = 4.0;\n    right = r[i];\n\n    if (!defined(right)) {\n      right = r[i] = new Cartesian3();\n    }\n\n    Cartesian3.subtract(points[i + 1], points[i - 1], right);\n    Cartesian3.multiplyByScalar(right, 3.0, right);\n  }\n\n  l[i] = 0.0;\n  u[i] = 1.0;\n  d[i] = 4.0;\n  right = r[i];\n\n  if (!defined(right)) {\n    right = r[i] = new Cartesian3();\n  }\n\n  Cartesian3.subtract(points[i + 1], points[i - 1], right);\n  Cartesian3.multiplyByScalar(right, 3.0, right);\n  d[i + 1] = 1.0;\n  right = r[i + 1];\n\n  if (!defined(right)) {\n    right = r[i + 1] = new Cartesian3();\n  }\n\n  Cartesian3.clone(lastTangent, right);\n  return TridiagonalSystemSolver.solve(l, d, u, r);\n}\n\nfunction generateNatural(points) {\n  var l = scratchLower;\n  var u = scratchUpper;\n  var d = scratchDiagonal;\n  var r = scratchRight;\n  l.length = u.length = points.length - 1;\n  d.length = r.length = points.length;\n  var i;\n  l[0] = u[0] = 1.0;\n  d[0] = 2.0;\n  var right = r[0];\n\n  if (!defined(right)) {\n    right = r[0] = new Cartesian3();\n  }\n\n  Cartesian3.subtract(points[1], points[0], right);\n  Cartesian3.multiplyByScalar(right, 3.0, right);\n\n  for (i = 1; i < l.length; ++i) {\n    l[i] = u[i] = 1.0;\n    d[i] = 4.0;\n    right = r[i];\n\n    if (!defined(right)) {\n      right = r[i] = new Cartesian3();\n    }\n\n    Cartesian3.subtract(points[i + 1], points[i - 1], right);\n    Cartesian3.multiplyByScalar(right, 3.0, right);\n  }\n\n  d[i] = 2.0;\n  right = r[i];\n\n  if (!defined(right)) {\n    right = r[i] = new Cartesian3();\n  }\n\n  Cartesian3.subtract(points[i], points[i - 1], right);\n  Cartesian3.multiplyByScalar(right, 3.0, right);\n  return TridiagonalSystemSolver.solve(l, d, u, r);\n}\n/**\n * A Hermite spline is a cubic interpolating spline. Points, incoming tangents, outgoing tangents, and times\n * must be defined for each control point. The outgoing tangents are defined for points [0, n - 2] and the incoming\n * tangents are defined for points [1, n - 1]. For example, when interpolating a segment of the curve between <code>points[i]</code> and\n * <code>points[i + 1]</code>, the tangents at the points will be <code>outTangents[i]</code> and <code>inTangents[i]</code>,\n * respectively.\n *\n * @alias HermiteSpline\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {Cartesian3[]} options.points The array of {@link Cartesian3} control points.\n * @param {Cartesian3[]} options.inTangents The array of {@link Cartesian3} incoming tangents at each control point.\n * @param {Cartesian3[]} options.outTangents The array of {@link Cartesian3} outgoing tangents at each control point.\n *\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n * @exception {DeveloperError} inTangents and outTangents must have a length equal to points.length - 1.\n *\n *\n * @example\n * // Create a G<sup>1</sup> continuous Hermite spline\n * var times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * var spline = new Cesium.HermiteSpline({\n *     times : times,\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ],\n *     outTangents : [\n *         new Cesium.Cartesian3(1125196, -161816, 270551),\n *         new Cesium.Cartesian3(-996690.5, -365906.5, 184028.5),\n *         new Cesium.Cartesian3(-2096917, 48379.5, -292683.5),\n *         new Cesium.Cartesian3(-890902.5, 408999.5, -447115)\n *     ],\n *     inTangents : [\n *         new Cesium.Cartesian3(-1993381, -731813, 368057),\n *         new Cesium.Cartesian3(-4193834, 96759, -585367),\n *         new Cesium.Cartesian3(-1781805, 817999, -894230),\n *         new Cesium.Cartesian3(1165345, 112641, 47281)\n *     ]\n * });\n *\n * var p0 = spline.evaluate(times[0]);\n *\n * @see CatmullRomSpline\n * @see LinearSpline\n * @see QuaternionSpline\n * @see WeightSpline\n */\n\n\nfunction HermiteSpline(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var points = options.points;\n  var times = options.times;\n  var inTangents = options.inTangents;\n  var outTangents = options.outTangents; //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(points) || !defined(times) || !defined(inTangents) || !defined(outTangents)) {\n    throw new DeveloperError(\"times, points, inTangents, and outTangents are required.\");\n  }\n\n  if (points.length < 2) {\n    throw new DeveloperError(\"points.length must be greater than or equal to 2.\");\n  }\n\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n\n  if (inTangents.length !== outTangents.length || inTangents.length !== points.length - 1) {\n    throw new DeveloperError(\"inTangents and outTangents must have a length equal to points.length - 1.\");\n  } //>>includeEnd('debug');\n\n\n  this._times = times;\n  this._points = points;\n  this._inTangents = inTangents;\n  this._outTangents = outTangents;\n  this._lastTimeIndex = 0;\n}\n\nObject.defineProperties(HermiteSpline.prototype, {\n  /**\n   * An array of times for the control points.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {Number[]}\n   * @readonly\n   */\n  times: {\n    get: function get() {\n      return this._times;\n    }\n  },\n\n  /**\n   * An array of {@link Cartesian3} control points.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  points: {\n    get: function get() {\n      return this._points;\n    }\n  },\n\n  /**\n   * An array of {@link Cartesian3} incoming tangents at each control point.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  inTangents: {\n    get: function get() {\n      return this._inTangents;\n    }\n  },\n\n  /**\n   * An array of {@link Cartesian3} outgoing tangents at each control point.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  outTangents: {\n    get: function get() {\n      return this._outTangents;\n    }\n  }\n});\n/**\n * Creates a spline where the tangents at each control point are the same.\n * The curves are guaranteed to be at least in the class C<sup>1</sup>.\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times The array of control point times.\n * @param {Cartesian3[]} options.points The array of control points.\n * @param {Cartesian3[]} options.tangents The array of tangents at the control points.\n * @returns {HermiteSpline} A hermite spline.\n *\n * @exception {DeveloperError} points, times and tangents are required.\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times, points and tangents must have the same length.\n *\n * @example\n * var points = [\n *     new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *     new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *     new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *     new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *     new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n * ];\n *\n * // Add tangents\n * var tangents = new Array(points.length);\n * tangents[0] = new Cesium.Cartesian3(1125196, -161816, 270551);\n * var temp = new Cesium.Cartesian3();\n * for (var i = 1; i < tangents.length - 1; ++i) {\n *     tangents[i] = Cesium.Cartesian3.multiplyByScalar(Cesium.Cartesian3.subtract(points[i + 1], points[i - 1], temp), 0.5, new Cesium.Cartesian3());\n * }\n * tangents[tangents.length - 1] = new Cesium.Cartesian3(1165345, 112641, 47281);\n *\n * var spline = Cesium.HermiteSpline.createC1({\n *     times : times,\n *     points : points,\n *     tangents : tangents\n * });\n */\n\nHermiteSpline.createC1 = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var times = options.times;\n  var points = options.points;\n  var tangents = options.tangents; //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(points) || !defined(times) || !defined(tangents)) {\n    throw new DeveloperError(\"points, times and tangents are required.\");\n  }\n\n  if (points.length < 2) {\n    throw new DeveloperError(\"points.length must be greater than or equal to 2.\");\n  }\n\n  if (times.length !== points.length || times.length !== tangents.length) {\n    throw new DeveloperError(\"times, points and tangents must have the same length.\");\n  } //>>includeEnd('debug');\n\n\n  var outTangents = tangents.slice(0, tangents.length - 1);\n  var inTangents = tangents.slice(1, tangents.length);\n  return new HermiteSpline({\n    times: times,\n    points: points,\n    inTangents: inTangents,\n    outTangents: outTangents\n  });\n};\n/**\n * Creates a natural cubic spline. The tangents at the control points are generated\n * to create a curve in the class C<sup>2</sup>.\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times The array of control point times.\n * @param {Cartesian3[]} options.points The array of control points.\n * @returns {HermiteSpline|LinearSpline} A hermite spline or a linear spline if less than 3 control points were given.\n *\n * @exception {DeveloperError} points and times are required.\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n *\n * @example\n * // Create a natural cubic spline above the earth from Philadelphia to Los Angeles.\n * var spline = Cesium.HermiteSpline.createNaturalCubic({\n *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });\n */\n\n\nHermiteSpline.createNaturalCubic = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var times = options.times;\n  var points = options.points; //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(points) || !defined(times)) {\n    throw new DeveloperError(\"points and times are required.\");\n  }\n\n  if (points.length < 2) {\n    throw new DeveloperError(\"points.length must be greater than or equal to 2.\");\n  }\n\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  } //>>includeEnd('debug');\n\n\n  if (points.length < 3) {\n    return new LinearSpline({\n      points: points,\n      times: times\n    });\n  }\n\n  var tangents = generateNatural(points);\n  var outTangents = tangents.slice(0, tangents.length - 1);\n  var inTangents = tangents.slice(1, tangents.length);\n  return new HermiteSpline({\n    times: times,\n    points: points,\n    inTangents: inTangents,\n    outTangents: outTangents\n  });\n};\n/**\n * Creates a clamped cubic spline. The tangents at the interior control points are generated\n * to create a curve in the class C<sup>2</sup>.\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times The array of control point times.\n * @param {Cartesian3[]} options.points The array of control points.\n * @param {Cartesian3} options.firstTangent The outgoing tangent of the first control point.\n * @param {Cartesian3} options.lastTangent The incoming tangent of the last control point.\n * @returns {HermiteSpline|LinearSpline} A hermite spline or a linear spline if less than 3 control points were given.\n *\n * @exception {DeveloperError} points, times, firstTangent and lastTangent are required.\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n *\n * @example\n * // Create a clamped cubic spline above the earth from Philadelphia to Los Angeles.\n * var spline = Cesium.HermiteSpline.createClampedCubic({\n *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ],\n *     firstTangent : new Cesium.Cartesian3(1125196, -161816, 270551),\n *     lastTangent : new Cesium.Cartesian3(1165345, 112641, 47281)\n * });\n */\n\n\nHermiteSpline.createClampedCubic = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var times = options.times;\n  var points = options.points;\n  var firstTangent = options.firstTangent;\n  var lastTangent = options.lastTangent; //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(points) || !defined(times) || !defined(firstTangent) || !defined(lastTangent)) {\n    throw new DeveloperError(\"points, times, firstTangent and lastTangent are required.\");\n  }\n\n  if (points.length < 2) {\n    throw new DeveloperError(\"points.length must be greater than or equal to 2.\");\n  }\n\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  } //>>includeEnd('debug');\n\n\n  if (points.length < 3) {\n    return new LinearSpline({\n      points: points,\n      times: times\n    });\n  }\n\n  var tangents = generateClamped(points, firstTangent, lastTangent);\n  var outTangents = tangents.slice(0, tangents.length - 1);\n  var inTangents = tangents.slice(1, tangents.length);\n  return new HermiteSpline({\n    times: times,\n    points: points,\n    inTangents: inTangents,\n    outTangents: outTangents\n  });\n};\n\nHermiteSpline.hermiteCoefficientMatrix = new Matrix4(2.0, -3.0, 0.0, 1.0, -2.0, 3.0, 0.0, 0.0, 1.0, -2.0, 1.0, 0.0, 1.0, -1.0, 0.0, 0.0);\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {Number} time The time.\n * @returns {Number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\n\nHermiteSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\nvar scratchTimeVec = new Cartesian4();\nvar scratchTemp = new Cartesian3();\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, wrapped around to the updated animation.\n */\n\nHermiteSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, clamped to the animation period.\n */\n\nHermiteSpline.prototype.clampTime = Spline.prototype.clampTime;\n/**\n * Evaluates the curve at a given time.\n *\n * @param {Number} time The time at which to evaluate the curve.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\n\nHermiteSpline.prototype.evaluate = function (time, result) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  var points = this.points;\n  var times = this.times;\n  var inTangents = this.inTangents;\n  var outTangents = this.outTangents;\n  var i = this._lastTimeIndex = this.findTimeInterval(time, this._lastTimeIndex);\n  var u = (time - times[i]) / (times[i + 1] - times[i]);\n  var timeVec = scratchTimeVec;\n  timeVec.z = u;\n  timeVec.y = u * u;\n  timeVec.x = timeVec.y * u;\n  timeVec.w = 1.0;\n  var coefs = Matrix4.multiplyByVector(HermiteSpline.hermiteCoefficientMatrix, timeVec, timeVec);\n  result = Cartesian3.multiplyByScalar(points[i], coefs.x, result);\n  Cartesian3.multiplyByScalar(points[i + 1], coefs.y, scratchTemp);\n  Cartesian3.add(result, scratchTemp, result);\n  Cartesian3.multiplyByScalar(outTangents[i], coefs.z, scratchTemp);\n  Cartesian3.add(result, scratchTemp, result);\n  Cartesian3.multiplyByScalar(inTangents[i], coefs.w, scratchTemp);\n  return Cartesian3.add(result, scratchTemp, result);\n};\n\nexport default HermiteSpline;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/HermiteSpline.js"],"names":["Cartesian3","Cartesian4","defaultValue","defined","DeveloperError","LinearSpline","Matrix4","Spline","TridiagonalSystemSolver","scratchLower","scratchDiagonal","scratchUpper","scratchRight","generateClamped","points","firstTangent","lastTangent","l","u","d","r","length","i","right","clone","subtract","multiplyByScalar","solve","generateNatural","HermiteSpline","options","EMPTY_OBJECT","times","inTangents","outTangents","_times","_points","_inTangents","_outTangents","_lastTimeIndex","Object","defineProperties","prototype","get","createC1","tangents","slice","createNaturalCubic","createClampedCubic","hermiteCoefficientMatrix","findTimeInterval","scratchTimeVec","scratchTemp","wrapTime","clampTime","evaluate","time","result","timeVec","z","y","x","w","coefs","multiplyByVector","add"],"mappings":"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","sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport LinearSpline from \"./LinearSpline.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Spline from \"./Spline.js\";\nimport TridiagonalSystemSolver from \"./TridiagonalSystemSolver.js\";\n\nvar scratchLower = [];\nvar scratchDiagonal = [];\nvar scratchUpper = [];\nvar scratchRight = [];\n\nfunction generateClamped(points, firstTangent, lastTangent) {\n  var l = scratchLower;\n  var u = scratchUpper;\n  var d = scratchDiagonal;\n  var r = scratchRight;\n\n  l.length = u.length = points.length - 1;\n  d.length = r.length = points.length;\n\n  var i;\n  l[0] = d[0] = 1.0;\n  u[0] = 0.0;\n\n  var right = r[0];\n  if (!defined(right)) {\n    right = r[0] = new Cartesian3();\n  }\n  Cartesian3.clone(firstTangent, right);\n\n  for (i = 1; i < l.length - 1; ++i) {\n    l[i] = u[i] = 1.0;\n    d[i] = 4.0;\n\n    right = r[i];\n    if (!defined(right)) {\n      right = r[i] = new Cartesian3();\n    }\n    Cartesian3.subtract(points[i + 1], points[i - 1], right);\n    Cartesian3.multiplyByScalar(right, 3.0, right);\n  }\n\n  l[i] = 0.0;\n  u[i] = 1.0;\n  d[i] = 4.0;\n\n  right = r[i];\n  if (!defined(right)) {\n    right = r[i] = new Cartesian3();\n  }\n  Cartesian3.subtract(points[i + 1], points[i - 1], right);\n  Cartesian3.multiplyByScalar(right, 3.0, right);\n\n  d[i + 1] = 1.0;\n  right = r[i + 1];\n  if (!defined(right)) {\n    right = r[i + 1] = new Cartesian3();\n  }\n  Cartesian3.clone(lastTangent, right);\n\n  return TridiagonalSystemSolver.solve(l, d, u, r);\n}\n\nfunction generateNatural(points) {\n  var l = scratchLower;\n  var u = scratchUpper;\n  var d = scratchDiagonal;\n  var r = scratchRight;\n\n  l.length = u.length = points.length - 1;\n  d.length = r.length = points.length;\n\n  var i;\n  l[0] = u[0] = 1.0;\n  d[0] = 2.0;\n\n  var right = r[0];\n  if (!defined(right)) {\n    right = r[0] = new Cartesian3();\n  }\n  Cartesian3.subtract(points[1], points[0], right);\n  Cartesian3.multiplyByScalar(right, 3.0, right);\n\n  for (i = 1; i < l.length; ++i) {\n    l[i] = u[i] = 1.0;\n    d[i] = 4.0;\n\n    right = r[i];\n    if (!defined(right)) {\n      right = r[i] = new Cartesian3();\n    }\n    Cartesian3.subtract(points[i + 1], points[i - 1], right);\n    Cartesian3.multiplyByScalar(right, 3.0, right);\n  }\n\n  d[i] = 2.0;\n\n  right = r[i];\n  if (!defined(right)) {\n    right = r[i] = new Cartesian3();\n  }\n  Cartesian3.subtract(points[i], points[i - 1], right);\n  Cartesian3.multiplyByScalar(right, 3.0, right);\n\n  return TridiagonalSystemSolver.solve(l, d, u, r);\n}\n\n/**\n * A Hermite spline is a cubic interpolating spline. Points, incoming tangents, outgoing tangents, and times\n * must be defined for each control point. The outgoing tangents are defined for points [0, n - 2] and the incoming\n * tangents are defined for points [1, n - 1]. For example, when interpolating a segment of the curve between <code>points[i]</code> and\n * <code>points[i + 1]</code>, the tangents at the points will be <code>outTangents[i]</code> and <code>inTangents[i]</code>,\n * respectively.\n *\n * @alias HermiteSpline\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {Cartesian3[]} options.points The array of {@link Cartesian3} control points.\n * @param {Cartesian3[]} options.inTangents The array of {@link Cartesian3} incoming tangents at each control point.\n * @param {Cartesian3[]} options.outTangents The array of {@link Cartesian3} outgoing tangents at each control point.\n *\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n * @exception {DeveloperError} inTangents and outTangents must have a length equal to points.length - 1.\n *\n *\n * @example\n * // Create a G<sup>1</sup> continuous Hermite spline\n * var times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * var spline = new Cesium.HermiteSpline({\n *     times : times,\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ],\n *     outTangents : [\n *         new Cesium.Cartesian3(1125196, -161816, 270551),\n *         new Cesium.Cartesian3(-996690.5, -365906.5, 184028.5),\n *         new Cesium.Cartesian3(-2096917, 48379.5, -292683.5),\n *         new Cesium.Cartesian3(-890902.5, 408999.5, -447115)\n *     ],\n *     inTangents : [\n *         new Cesium.Cartesian3(-1993381, -731813, 368057),\n *         new Cesium.Cartesian3(-4193834, 96759, -585367),\n *         new Cesium.Cartesian3(-1781805, 817999, -894230),\n *         new Cesium.Cartesian3(1165345, 112641, 47281)\n *     ]\n * });\n *\n * var p0 = spline.evaluate(times[0]);\n *\n * @see CatmullRomSpline\n * @see LinearSpline\n * @see QuaternionSpline\n * @see WeightSpline\n */\nfunction HermiteSpline(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var points = options.points;\n  var times = options.times;\n  var inTangents = options.inTangents;\n  var outTangents = options.outTangents;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(points) ||\n    !defined(times) ||\n    !defined(inTangents) ||\n    !defined(outTangents)\n  ) {\n    throw new DeveloperError(\n      \"times, points, inTangents, and outTangents are required.\"\n    );\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\n      \"points.length must be greater than or equal to 2.\"\n    );\n  }\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n  if (\n    inTangents.length !== outTangents.length ||\n    inTangents.length !== points.length - 1\n  ) {\n    throw new DeveloperError(\n      \"inTangents and outTangents must have a length equal to points.length - 1.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._times = times;\n  this._points = points;\n  this._inTangents = inTangents;\n  this._outTangents = outTangents;\n\n  this._lastTimeIndex = 0;\n}\n\nObject.defineProperties(HermiteSpline.prototype, {\n  /**\n   * An array of times for the control points.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {Number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    },\n  },\n\n  /**\n   * An array of {@link Cartesian3} control points.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  points: {\n    get: function () {\n      return this._points;\n    },\n  },\n\n  /**\n   * An array of {@link Cartesian3} incoming tangents at each control point.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  inTangents: {\n    get: function () {\n      return this._inTangents;\n    },\n  },\n\n  /**\n   * An array of {@link Cartesian3} outgoing tangents at each control point.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  outTangents: {\n    get: function () {\n      return this._outTangents;\n    },\n  },\n});\n\n/**\n * Creates a spline where the tangents at each control point are the same.\n * The curves are guaranteed to be at least in the class C<sup>1</sup>.\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times The array of control point times.\n * @param {Cartesian3[]} options.points The array of control points.\n * @param {Cartesian3[]} options.tangents The array of tangents at the control points.\n * @returns {HermiteSpline} A hermite spline.\n *\n * @exception {DeveloperError} points, times and tangents are required.\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times, points and tangents must have the same length.\n *\n * @example\n * var points = [\n *     new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *     new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *     new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *     new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *     new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n * ];\n *\n * // Add tangents\n * var tangents = new Array(points.length);\n * tangents[0] = new Cesium.Cartesian3(1125196, -161816, 270551);\n * var temp = new Cesium.Cartesian3();\n * for (var i = 1; i < tangents.length - 1; ++i) {\n *     tangents[i] = Cesium.Cartesian3.multiplyByScalar(Cesium.Cartesian3.subtract(points[i + 1], points[i - 1], temp), 0.5, new Cesium.Cartesian3());\n * }\n * tangents[tangents.length - 1] = new Cesium.Cartesian3(1165345, 112641, 47281);\n *\n * var spline = Cesium.HermiteSpline.createC1({\n *     times : times,\n *     points : points,\n *     tangents : tangents\n * });\n */\nHermiteSpline.createC1 = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var times = options.times;\n  var points = options.points;\n  var tangents = options.tangents;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(points) || !defined(times) || !defined(tangents)) {\n    throw new DeveloperError(\"points, times and tangents are required.\");\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\n      \"points.length must be greater than or equal to 2.\"\n    );\n  }\n  if (times.length !== points.length || times.length !== tangents.length) {\n    throw new DeveloperError(\n      \"times, points and tangents must have the same length.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var outTangents = tangents.slice(0, tangents.length - 1);\n  var inTangents = tangents.slice(1, tangents.length);\n\n  return new HermiteSpline({\n    times: times,\n    points: points,\n    inTangents: inTangents,\n    outTangents: outTangents,\n  });\n};\n\n/**\n * Creates a natural cubic spline. The tangents at the control points are generated\n * to create a curve in the class C<sup>2</sup>.\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times The array of control point times.\n * @param {Cartesian3[]} options.points The array of control points.\n * @returns {HermiteSpline|LinearSpline} A hermite spline or a linear spline if less than 3 control points were given.\n *\n * @exception {DeveloperError} points and times are required.\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n *\n * @example\n * // Create a natural cubic spline above the earth from Philadelphia to Los Angeles.\n * var spline = Cesium.HermiteSpline.createNaturalCubic({\n *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });\n */\nHermiteSpline.createNaturalCubic = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var times = options.times;\n  var points = options.points;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(points) || !defined(times)) {\n    throw new DeveloperError(\"points and times are required.\");\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\n      \"points.length must be greater than or equal to 2.\"\n    );\n  }\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n  //>>includeEnd('debug');\n\n  if (points.length < 3) {\n    return new LinearSpline({\n      points: points,\n      times: times,\n    });\n  }\n\n  var tangents = generateNatural(points);\n  var outTangents = tangents.slice(0, tangents.length - 1);\n  var inTangents = tangents.slice(1, tangents.length);\n\n  return new HermiteSpline({\n    times: times,\n    points: points,\n    inTangents: inTangents,\n    outTangents: outTangents,\n  });\n};\n\n/**\n * Creates a clamped cubic spline. The tangents at the interior control points are generated\n * to create a curve in the class C<sup>2</sup>.\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times The array of control point times.\n * @param {Cartesian3[]} options.points The array of control points.\n * @param {Cartesian3} options.firstTangent The outgoing tangent of the first control point.\n * @param {Cartesian3} options.lastTangent The incoming tangent of the last control point.\n * @returns {HermiteSpline|LinearSpline} A hermite spline or a linear spline if less than 3 control points were given.\n *\n * @exception {DeveloperError} points, times, firstTangent and lastTangent are required.\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n *\n * @example\n * // Create a clamped cubic spline above the earth from Philadelphia to Los Angeles.\n * var spline = Cesium.HermiteSpline.createClampedCubic({\n *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ],\n *     firstTangent : new Cesium.Cartesian3(1125196, -161816, 270551),\n *     lastTangent : new Cesium.Cartesian3(1165345, 112641, 47281)\n * });\n */\nHermiteSpline.createClampedCubic = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var times = options.times;\n  var points = options.points;\n  var firstTangent = options.firstTangent;\n  var lastTangent = options.lastTangent;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(points) ||\n    !defined(times) ||\n    !defined(firstTangent) ||\n    !defined(lastTangent)\n  ) {\n    throw new DeveloperError(\n      \"points, times, firstTangent and lastTangent are required.\"\n    );\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\n      \"points.length must be greater than or equal to 2.\"\n    );\n  }\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n  //>>includeEnd('debug');\n\n  if (points.length < 3) {\n    return new LinearSpline({\n      points: points,\n      times: times,\n    });\n  }\n\n  var tangents = generateClamped(points, firstTangent, lastTangent);\n  var outTangents = tangents.slice(0, tangents.length - 1);\n  var inTangents = tangents.slice(1, tangents.length);\n\n  return new HermiteSpline({\n    times: times,\n    points: points,\n    inTangents: inTangents,\n    outTangents: outTangents,\n  });\n};\n\nHermiteSpline.hermiteCoefficientMatrix = new Matrix4(\n  2.0,\n  -3.0,\n  0.0,\n  1.0,\n  -2.0,\n  3.0,\n  0.0,\n  0.0,\n  1.0,\n  -2.0,\n  1.0,\n  0.0,\n  1.0,\n  -1.0,\n  0.0,\n  0.0\n);\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {Number} time The time.\n * @returns {Number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nHermiteSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n\nvar scratchTimeVec = new Cartesian4();\nvar scratchTemp = new Cartesian3();\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, wrapped around to the updated animation.\n */\nHermiteSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, clamped to the animation period.\n */\nHermiteSpline.prototype.clampTime = Spline.prototype.clampTime;\n\n/**\n * Evaluates the curve at a given time.\n *\n * @param {Number} time The time at which to evaluate the curve.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nHermiteSpline.prototype.evaluate = function (time, result) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  var points = this.points;\n  var times = this.times;\n  var inTangents = this.inTangents;\n  var outTangents = this.outTangents;\n\n  var i = (this._lastTimeIndex = this.findTimeInterval(\n    time,\n    this._lastTimeIndex\n  ));\n  var u = (time - times[i]) / (times[i + 1] - times[i]);\n\n  var timeVec = scratchTimeVec;\n  timeVec.z = u;\n  timeVec.y = u * u;\n  timeVec.x = timeVec.y * u;\n  timeVec.w = 1.0;\n\n  var coefs = Matrix4.multiplyByVector(\n    HermiteSpline.hermiteCoefficientMatrix,\n    timeVec,\n    timeVec\n  );\n\n  result = Cartesian3.multiplyByScalar(points[i], coefs.x, result);\n  Cartesian3.multiplyByScalar(points[i + 1], coefs.y, scratchTemp);\n  Cartesian3.add(result, scratchTemp, result);\n  Cartesian3.multiplyByScalar(outTangents[i], coefs.z, scratchTemp);\n  Cartesian3.add(result, scratchTemp, result);\n  Cartesian3.multiplyByScalar(inTangents[i], coefs.w, scratchTemp);\n  return Cartesian3.add(result, scratchTemp, result);\n};\nexport default HermiteSpline;\n"]},"metadata":{},"sourceType":"module"}