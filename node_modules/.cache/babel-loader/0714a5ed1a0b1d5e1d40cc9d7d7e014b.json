{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport BoxGeometry from \"../Core/BoxGeometry.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport VertexFormat from \"../Core/VertexFormat.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport EllipsoidFS from \"../Shaders/EllipsoidFS.js\";\nimport EllipsoidVS from \"../Shaders/EllipsoidVS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport CullFace from \"./CullFace.js\";\nimport Material from \"./Material.js\";\nimport SceneMode from \"./SceneMode.js\";\nvar attributeLocations = {\n  position: 0\n};\n/**\n * A renderable ellipsoid.  It can also draw spheres when the three {@link EllipsoidPrimitive#radii} components are equal.\n * <p>\n * This is only supported in 3D.  The ellipsoid is not shown in 2D or Columbus view.\n * </p>\n *\n * @alias EllipsoidPrimitive\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Cartesian3} [options.center=Cartesian3.ZERO] The center of the ellipsoid in the ellipsoid's model coordinates.\n * @param {Cartesian3} [options.radii] The radius of the ellipsoid along the <code>x</code>, <code>y</code>, and <code>z</code> axes in the ellipsoid's model coordinates.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the ellipsoid from model to world coordinates.\n * @param {Boolean} [options.show=true] Determines if this primitive will be shown.\n * @param {Material} [options.material=Material.ColorType] The surface appearance of the primitive.\n * @param {Object} [options.id] A user-defined object to return when the instance is picked with {@link Scene#pick}\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n *\n * @private\n */\n\nfunction EllipsoidPrimitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  /**\n   * The center of the ellipsoid in the ellipsoid's model coordinates.\n   * <p>\n   * The default is {@link Cartesian3.ZERO}.\n   * </p>\n   *\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   *\n   * @see EllipsoidPrimitive#modelMatrix\n   */\n\n  this.center = Cartesian3.clone(defaultValue(options.center, Cartesian3.ZERO));\n  this._center = new Cartesian3();\n  /**\n   * The radius of the ellipsoid along the <code>x</code>, <code>y</code>, and <code>z</code> axes in the ellipsoid's model coordinates.\n   * When these are the same, the ellipsoid is a sphere.\n   * <p>\n   * The default is <code>undefined</code>.  The ellipsoid is not drawn until a radii is provided.\n   * </p>\n   *\n   * @type {Cartesian3}\n   * @default undefined\n   *\n   *\n   * @example\n   * // A sphere with a radius of 2.0\n   * e.radii = new Cesium.Cartesian3(2.0, 2.0, 2.0);\n   *\n   * @see EllipsoidPrimitive#modelMatrix\n   */\n\n  this.radii = Cartesian3.clone(options.radii);\n  this._radii = new Cartesian3();\n  this._oneOverEllipsoidRadiiSquared = new Cartesian3();\n  this._boundingSphere = new BoundingSphere();\n  /**\n   * The 4x4 transformation matrix that transforms the ellipsoid from model to world coordinates.\n   * When this is the identity matrix, the ellipsoid is drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type {Matrix4}\n   * @default {@link Matrix4.IDENTITY}\n   *\n   * @example\n   * var origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n   * e.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);\n   */\n\n  this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));\n  this._modelMatrix = new Matrix4();\n  this._computedModelMatrix = new Matrix4();\n  /**\n   * Determines if the ellipsoid primitive will be shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.show = defaultValue(options.show, true);\n  /**\n   * The surface appearance of the ellipsoid.  This can be one of several built-in {@link Material} objects or a custom material, scripted with\n   * {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}.\n   * <p>\n   * The default material is <code>Material.ColorType</code>.\n   * </p>\n   *\n   * @type {Material}\n   * @default Material.fromType(Material.ColorType)\n   *\n   *\n   * @example\n   * // 1. Change the color of the default material to yellow\n   * e.material.uniforms.color = new Cesium.Color(1.0, 1.0, 0.0, 1.0);\n   *\n   * // 2. Change material to horizontal stripes\n   * e.material = Cesium.Material.fromType(Cesium.Material.StripeType);\n   *\n   * @see {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}\n   */\n\n  this.material = defaultValue(options.material, Material.fromType(Material.ColorType));\n  this._material = undefined;\n  this._translucent = undefined;\n  /**\n   * User-defined object returned when the ellipsoid is picked.\n   *\n   * @type Object\n   *\n   * @default undefined\n   *\n   * @see Scene#pick\n   */\n\n  this.id = options.id;\n  this._id = undefined;\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n\n  this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);\n  /**\n   * @private\n   */\n\n  this.onlySunLighting = defaultValue(options.onlySunLighting, false);\n  this._onlySunLighting = false;\n  /**\n   * @private\n   */\n\n  this._depthTestEnabled = defaultValue(options.depthTestEnabled, true);\n  this._useLogDepth = false;\n  this._sp = undefined;\n  this._rs = undefined;\n  this._va = undefined;\n  this._pickSP = undefined;\n  this._pickId = undefined;\n  this._colorCommand = new DrawCommand({\n    owner: defaultValue(options._owner, this)\n  });\n  this._pickCommand = new DrawCommand({\n    owner: defaultValue(options._owner, this),\n    pickOnly: true\n  });\n  var that = this;\n  this._uniforms = {\n    u_radii: function () {\n      return that.radii;\n    },\n    u_oneOverEllipsoidRadiiSquared: function () {\n      return that._oneOverEllipsoidRadiiSquared;\n    }\n  };\n  this._pickUniforms = {\n    czm_pickColor: function () {\n      return that._pickId.color;\n    }\n  };\n}\n\nfunction getVertexArray(context) {\n  var vertexArray = context.cache.ellipsoidPrimitive_vertexArray;\n\n  if (defined(vertexArray)) {\n    return vertexArray;\n  }\n\n  var geometry = BoxGeometry.createGeometry(BoxGeometry.fromDimensions({\n    dimensions: new Cartesian3(2.0, 2.0, 2.0),\n    vertexFormat: VertexFormat.POSITION_ONLY\n  }));\n  vertexArray = VertexArray.fromGeometry({\n    context: context,\n    geometry: geometry,\n    attributeLocations: attributeLocations,\n    bufferUsage: BufferUsage.STATIC_DRAW,\n    interleave: true\n  });\n  context.cache.ellipsoidPrimitive_vertexArray = vertexArray;\n  return vertexArray;\n}\n\nvar logDepthExtension = \"#ifdef GL_EXT_frag_depth \\n\" + \"#extension GL_EXT_frag_depth : enable \\n\" + \"#endif \\n\\n\";\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} this.material must be defined.\n */\n\nEllipsoidPrimitive.prototype.update = function (frameState) {\n  if (!this.show || frameState.mode !== SceneMode.SCENE3D || !defined(this.center) || !defined(this.radii)) {\n    return;\n  } //>>includeStart('debug', pragmas.debug);\n\n\n  if (!defined(this.material)) {\n    throw new DeveloperError(\"this.material must be defined.\");\n  } //>>includeEnd('debug');\n\n\n  var context = frameState.context;\n  var translucent = this.material.isTranslucent();\n  var translucencyChanged = this._translucent !== translucent;\n\n  if (!defined(this._rs) || translucencyChanged) {\n    this._translucent = translucent; // If this render state is ever updated to use a non-default\n    // depth range, the hard-coded values in EllipsoidVS.glsl need\n    // to be updated as well.\n\n    this._rs = RenderState.fromCache({\n      // Cull front faces - not back faces - so the ellipsoid doesn't\n      // disappear if the viewer enters the bounding box.\n      cull: {\n        enabled: true,\n        face: CullFace.FRONT\n      },\n      depthTest: {\n        enabled: this._depthTestEnabled\n      },\n      // Only write depth when EXT_frag_depth is supported since the depth for\n      // the bounding box is wrong; it is not the true depth of the ray casted ellipsoid.\n      depthMask: !translucent && context.fragmentDepth,\n      blending: translucent ? BlendingState.ALPHA_BLEND : undefined\n    });\n  }\n\n  if (!defined(this._va)) {\n    this._va = getVertexArray(context);\n  }\n\n  var boundingSphereDirty = false;\n  var radii = this.radii;\n\n  if (!Cartesian3.equals(this._radii, radii)) {\n    Cartesian3.clone(radii, this._radii);\n    var r = this._oneOverEllipsoidRadiiSquared;\n    r.x = 1.0 / (radii.x * radii.x);\n    r.y = 1.0 / (radii.y * radii.y);\n    r.z = 1.0 / (radii.z * radii.z);\n    boundingSphereDirty = true;\n  }\n\n  if (!Matrix4.equals(this.modelMatrix, this._modelMatrix) || !Cartesian3.equals(this.center, this._center)) {\n    Matrix4.clone(this.modelMatrix, this._modelMatrix);\n    Cartesian3.clone(this.center, this._center); // Translate model coordinates used for rendering such that the origin is the center of the ellipsoid.\n\n    Matrix4.multiplyByTranslation(this.modelMatrix, this.center, this._computedModelMatrix);\n    boundingSphereDirty = true;\n  }\n\n  if (boundingSphereDirty) {\n    Cartesian3.clone(Cartesian3.ZERO, this._boundingSphere.center);\n    this._boundingSphere.radius = Cartesian3.maximumComponent(radii);\n    BoundingSphere.transform(this._boundingSphere, this._computedModelMatrix, this._boundingSphere);\n  }\n\n  var materialChanged = this._material !== this.material;\n  this._material = this.material;\n\n  this._material.update(context);\n\n  var lightingChanged = this.onlySunLighting !== this._onlySunLighting;\n  this._onlySunLighting = this.onlySunLighting;\n  var useLogDepth = frameState.useLogDepth;\n  var useLogDepthChanged = this._useLogDepth !== useLogDepth;\n  this._useLogDepth = useLogDepth;\n  var colorCommand = this._colorCommand;\n  var vs;\n  var fs; // Recompile shader when material, lighting, or translucency changes\n\n  if (materialChanged || lightingChanged || translucencyChanged || useLogDepthChanged) {\n    vs = new ShaderSource({\n      sources: [EllipsoidVS]\n    });\n    fs = new ShaderSource({\n      sources: [this.material.shaderSource, EllipsoidFS]\n    });\n\n    if (this.onlySunLighting) {\n      fs.defines.push(\"ONLY_SUN_LIGHTING\");\n    }\n\n    if (!translucent && context.fragmentDepth) {\n      fs.defines.push(\"WRITE_DEPTH\");\n    }\n\n    if (this._useLogDepth) {\n      vs.defines.push(\"LOG_DEPTH\");\n      fs.defines.push(\"LOG_DEPTH\");\n      fs.sources.push(logDepthExtension);\n    }\n\n    this._sp = ShaderProgram.replaceCache({\n      context: context,\n      shaderProgram: this._sp,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n      attributeLocations: attributeLocations\n    });\n    colorCommand.vertexArray = this._va;\n    colorCommand.renderState = this._rs;\n    colorCommand.shaderProgram = this._sp;\n    colorCommand.uniformMap = combine(this._uniforms, this.material._uniforms);\n    colorCommand.executeInClosestFrustum = translucent;\n  }\n\n  var commandList = frameState.commandList;\n  var passes = frameState.passes;\n\n  if (passes.render) {\n    colorCommand.boundingVolume = this._boundingSphere;\n    colorCommand.debugShowBoundingVolume = this.debugShowBoundingVolume;\n    colorCommand.modelMatrix = this._computedModelMatrix;\n    colorCommand.pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;\n    commandList.push(colorCommand);\n  }\n\n  if (passes.pick) {\n    var pickCommand = this._pickCommand;\n\n    if (!defined(this._pickId) || this._id !== this.id) {\n      this._id = this.id;\n      this._pickId = this._pickId && this._pickId.destroy();\n      this._pickId = context.createPickId({\n        primitive: this,\n        id: this.id\n      });\n    } // Recompile shader when material changes\n\n\n    if (materialChanged || lightingChanged || !defined(this._pickSP) || useLogDepthChanged) {\n      vs = new ShaderSource({\n        sources: [EllipsoidVS]\n      });\n      fs = new ShaderSource({\n        sources: [this.material.shaderSource, EllipsoidFS],\n        pickColorQualifier: \"uniform\"\n      });\n\n      if (this.onlySunLighting) {\n        fs.defines.push(\"ONLY_SUN_LIGHTING\");\n      }\n\n      if (!translucent && context.fragmentDepth) {\n        fs.defines.push(\"WRITE_DEPTH\");\n      }\n\n      if (this._useLogDepth) {\n        vs.defines.push(\"LOG_DEPTH\");\n        fs.defines.push(\"LOG_DEPTH\");\n        fs.sources.push(logDepthExtension);\n      }\n\n      this._pickSP = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._pickSP,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations\n      });\n      pickCommand.vertexArray = this._va;\n      pickCommand.renderState = this._rs;\n      pickCommand.shaderProgram = this._pickSP;\n      pickCommand.uniformMap = combine(combine(this._uniforms, this._pickUniforms), this.material._uniforms);\n      pickCommand.executeInClosestFrustum = translucent;\n    }\n\n    pickCommand.boundingVolume = this._boundingSphere;\n    pickCommand.modelMatrix = this._computedModelMatrix;\n    pickCommand.pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;\n    commandList.push(pickCommand);\n  }\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see EllipsoidPrimitive#destroy\n */\n\n\nEllipsoidPrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * e = e && e.destroy();\n *\n * @see EllipsoidPrimitive#isDestroyed\n */\n\n\nEllipsoidPrimitive.prototype.destroy = function () {\n  this._sp = this._sp && this._sp.destroy();\n  this._pickSP = this._pickSP && this._pickSP.destroy();\n  this._pickId = this._pickId && this._pickId.destroy();\n  return destroyObject(this);\n};\n\nexport default EllipsoidPrimitive;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Scene/EllipsoidPrimitive.js"],"names":["BoundingSphere","BoxGeometry","Cartesian3","combine","defaultValue","defined","destroyObject","DeveloperError","Matrix4","VertexFormat","BufferUsage","DrawCommand","Pass","RenderState","ShaderProgram","ShaderSource","VertexArray","EllipsoidFS","EllipsoidVS","BlendingState","CullFace","Material","SceneMode","attributeLocations","position","EllipsoidPrimitive","options","EMPTY_OBJECT","center","clone","ZERO","_center","radii","_radii","_oneOverEllipsoidRadiiSquared","_boundingSphere","modelMatrix","IDENTITY","_modelMatrix","_computedModelMatrix","show","material","fromType","ColorType","_material","undefined","_translucent","id","_id","debugShowBoundingVolume","onlySunLighting","_onlySunLighting","_depthTestEnabled","depthTestEnabled","_useLogDepth","_sp","_rs","_va","_pickSP","_pickId","_colorCommand","owner","_owner","_pickCommand","pickOnly","that","_uniforms","u_radii","u_oneOverEllipsoidRadiiSquared","_pickUniforms","czm_pickColor","color","getVertexArray","context","vertexArray","cache","ellipsoidPrimitive_vertexArray","geometry","createGeometry","fromDimensions","dimensions","vertexFormat","POSITION_ONLY","fromGeometry","bufferUsage","STATIC_DRAW","interleave","logDepthExtension","prototype","update","frameState","mode","SCENE3D","translucent","isTranslucent","translucencyChanged","fromCache","cull","enabled","face","FRONT","depthTest","depthMask","fragmentDepth","blending","ALPHA_BLEND","boundingSphereDirty","equals","r","x","y","z","multiplyByTranslation","radius","maximumComponent","transform","materialChanged","lightingChanged","useLogDepth","useLogDepthChanged","colorCommand","vs","fs","sources","shaderSource","defines","push","replaceCache","shaderProgram","vertexShaderSource","fragmentShaderSource","renderState","uniformMap","executeInClosestFrustum","commandList","passes","render","boundingVolume","pass","TRANSLUCENT","OPAQUE","pick","pickCommand","destroy","createPickId","primitive","pickColorQualifier","isDestroyed"],"mappings":"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","sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport BoxGeometry from \"../Core/BoxGeometry.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport VertexFormat from \"../Core/VertexFormat.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport EllipsoidFS from \"../Shaders/EllipsoidFS.js\";\nimport EllipsoidVS from \"../Shaders/EllipsoidVS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport CullFace from \"./CullFace.js\";\nimport Material from \"./Material.js\";\nimport SceneMode from \"./SceneMode.js\";\n\nvar attributeLocations = {\n  position: 0,\n};\n\n/**\n * A renderable ellipsoid.  It can also draw spheres when the three {@link EllipsoidPrimitive#radii} components are equal.\n * <p>\n * This is only supported in 3D.  The ellipsoid is not shown in 2D or Columbus view.\n * </p>\n *\n * @alias EllipsoidPrimitive\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Cartesian3} [options.center=Cartesian3.ZERO] The center of the ellipsoid in the ellipsoid's model coordinates.\n * @param {Cartesian3} [options.radii] The radius of the ellipsoid along the <code>x</code>, <code>y</code>, and <code>z</code> axes in the ellipsoid's model coordinates.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the ellipsoid from model to world coordinates.\n * @param {Boolean} [options.show=true] Determines if this primitive will be shown.\n * @param {Material} [options.material=Material.ColorType] The surface appearance of the primitive.\n * @param {Object} [options.id] A user-defined object to return when the instance is picked with {@link Scene#pick}\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n *\n * @private\n */\nfunction EllipsoidPrimitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The center of the ellipsoid in the ellipsoid's model coordinates.\n   * <p>\n   * The default is {@link Cartesian3.ZERO}.\n   * </p>\n   *\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   *\n   * @see EllipsoidPrimitive#modelMatrix\n   */\n  this.center = Cartesian3.clone(defaultValue(options.center, Cartesian3.ZERO));\n  this._center = new Cartesian3();\n\n  /**\n   * The radius of the ellipsoid along the <code>x</code>, <code>y</code>, and <code>z</code> axes in the ellipsoid's model coordinates.\n   * When these are the same, the ellipsoid is a sphere.\n   * <p>\n   * The default is <code>undefined</code>.  The ellipsoid is not drawn until a radii is provided.\n   * </p>\n   *\n   * @type {Cartesian3}\n   * @default undefined\n   *\n   *\n   * @example\n   * // A sphere with a radius of 2.0\n   * e.radii = new Cesium.Cartesian3(2.0, 2.0, 2.0);\n   *\n   * @see EllipsoidPrimitive#modelMatrix\n   */\n  this.radii = Cartesian3.clone(options.radii);\n  this._radii = new Cartesian3();\n\n  this._oneOverEllipsoidRadiiSquared = new Cartesian3();\n  this._boundingSphere = new BoundingSphere();\n\n  /**\n   * The 4x4 transformation matrix that transforms the ellipsoid from model to world coordinates.\n   * When this is the identity matrix, the ellipsoid is drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type {Matrix4}\n   * @default {@link Matrix4.IDENTITY}\n   *\n   * @example\n   * var origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n   * e.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);\n   */\n  this.modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY)\n  );\n  this._modelMatrix = new Matrix4();\n  this._computedModelMatrix = new Matrix4();\n\n  /**\n   * Determines if the ellipsoid primitive will be shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  /**\n   * The surface appearance of the ellipsoid.  This can be one of several built-in {@link Material} objects or a custom material, scripted with\n   * {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}.\n   * <p>\n   * The default material is <code>Material.ColorType</code>.\n   * </p>\n   *\n   * @type {Material}\n   * @default Material.fromType(Material.ColorType)\n   *\n   *\n   * @example\n   * // 1. Change the color of the default material to yellow\n   * e.material.uniforms.color = new Cesium.Color(1.0, 1.0, 0.0, 1.0);\n   *\n   * // 2. Change material to horizontal stripes\n   * e.material = Cesium.Material.fromType(Cesium.Material.StripeType);\n   *\n   * @see {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}\n   */\n  this.material = defaultValue(\n    options.material,\n    Material.fromType(Material.ColorType)\n  );\n  this._material = undefined;\n  this._translucent = undefined;\n\n  /**\n   * User-defined object returned when the ellipsoid is picked.\n   *\n   * @type Object\n   *\n   * @default undefined\n   *\n   * @see Scene#pick\n   */\n  this.id = options.id;\n  this._id = undefined;\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false\n  );\n\n  /**\n   * @private\n   */\n  this.onlySunLighting = defaultValue(options.onlySunLighting, false);\n  this._onlySunLighting = false;\n\n  /**\n   * @private\n   */\n  this._depthTestEnabled = defaultValue(options.depthTestEnabled, true);\n\n  this._useLogDepth = false;\n\n  this._sp = undefined;\n  this._rs = undefined;\n  this._va = undefined;\n\n  this._pickSP = undefined;\n  this._pickId = undefined;\n\n  this._colorCommand = new DrawCommand({\n    owner: defaultValue(options._owner, this),\n  });\n  this._pickCommand = new DrawCommand({\n    owner: defaultValue(options._owner, this),\n    pickOnly: true,\n  });\n\n  var that = this;\n  this._uniforms = {\n    u_radii: function () {\n      return that.radii;\n    },\n    u_oneOverEllipsoidRadiiSquared: function () {\n      return that._oneOverEllipsoidRadiiSquared;\n    },\n  };\n\n  this._pickUniforms = {\n    czm_pickColor: function () {\n      return that._pickId.color;\n    },\n  };\n}\n\nfunction getVertexArray(context) {\n  var vertexArray = context.cache.ellipsoidPrimitive_vertexArray;\n\n  if (defined(vertexArray)) {\n    return vertexArray;\n  }\n\n  var geometry = BoxGeometry.createGeometry(\n    BoxGeometry.fromDimensions({\n      dimensions: new Cartesian3(2.0, 2.0, 2.0),\n      vertexFormat: VertexFormat.POSITION_ONLY,\n    })\n  );\n\n  vertexArray = VertexArray.fromGeometry({\n    context: context,\n    geometry: geometry,\n    attributeLocations: attributeLocations,\n    bufferUsage: BufferUsage.STATIC_DRAW,\n    interleave: true,\n  });\n\n  context.cache.ellipsoidPrimitive_vertexArray = vertexArray;\n  return vertexArray;\n}\n\nvar logDepthExtension =\n  \"#ifdef GL_EXT_frag_depth \\n\" +\n  \"#extension GL_EXT_frag_depth : enable \\n\" +\n  \"#endif \\n\\n\";\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} this.material must be defined.\n */\nEllipsoidPrimitive.prototype.update = function (frameState) {\n  if (\n    !this.show ||\n    frameState.mode !== SceneMode.SCENE3D ||\n    !defined(this.center) ||\n    !defined(this.radii)\n  ) {\n    return;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(this.material)) {\n    throw new DeveloperError(\"this.material must be defined.\");\n  }\n  //>>includeEnd('debug');\n\n  var context = frameState.context;\n  var translucent = this.material.isTranslucent();\n  var translucencyChanged = this._translucent !== translucent;\n\n  if (!defined(this._rs) || translucencyChanged) {\n    this._translucent = translucent;\n\n    // If this render state is ever updated to use a non-default\n    // depth range, the hard-coded values in EllipsoidVS.glsl need\n    // to be updated as well.\n\n    this._rs = RenderState.fromCache({\n      // Cull front faces - not back faces - so the ellipsoid doesn't\n      // disappear if the viewer enters the bounding box.\n      cull: {\n        enabled: true,\n        face: CullFace.FRONT,\n      },\n      depthTest: {\n        enabled: this._depthTestEnabled,\n      },\n      // Only write depth when EXT_frag_depth is supported since the depth for\n      // the bounding box is wrong; it is not the true depth of the ray casted ellipsoid.\n      depthMask: !translucent && context.fragmentDepth,\n      blending: translucent ? BlendingState.ALPHA_BLEND : undefined,\n    });\n  }\n\n  if (!defined(this._va)) {\n    this._va = getVertexArray(context);\n  }\n\n  var boundingSphereDirty = false;\n\n  var radii = this.radii;\n  if (!Cartesian3.equals(this._radii, radii)) {\n    Cartesian3.clone(radii, this._radii);\n\n    var r = this._oneOverEllipsoidRadiiSquared;\n    r.x = 1.0 / (radii.x * radii.x);\n    r.y = 1.0 / (radii.y * radii.y);\n    r.z = 1.0 / (radii.z * radii.z);\n\n    boundingSphereDirty = true;\n  }\n\n  if (\n    !Matrix4.equals(this.modelMatrix, this._modelMatrix) ||\n    !Cartesian3.equals(this.center, this._center)\n  ) {\n    Matrix4.clone(this.modelMatrix, this._modelMatrix);\n    Cartesian3.clone(this.center, this._center);\n\n    // Translate model coordinates used for rendering such that the origin is the center of the ellipsoid.\n    Matrix4.multiplyByTranslation(\n      this.modelMatrix,\n      this.center,\n      this._computedModelMatrix\n    );\n    boundingSphereDirty = true;\n  }\n\n  if (boundingSphereDirty) {\n    Cartesian3.clone(Cartesian3.ZERO, this._boundingSphere.center);\n    this._boundingSphere.radius = Cartesian3.maximumComponent(radii);\n    BoundingSphere.transform(\n      this._boundingSphere,\n      this._computedModelMatrix,\n      this._boundingSphere\n    );\n  }\n\n  var materialChanged = this._material !== this.material;\n  this._material = this.material;\n  this._material.update(context);\n\n  var lightingChanged = this.onlySunLighting !== this._onlySunLighting;\n  this._onlySunLighting = this.onlySunLighting;\n\n  var useLogDepth = frameState.useLogDepth;\n  var useLogDepthChanged = this._useLogDepth !== useLogDepth;\n  this._useLogDepth = useLogDepth;\n\n  var colorCommand = this._colorCommand;\n  var vs;\n  var fs;\n\n  // Recompile shader when material, lighting, or translucency changes\n  if (\n    materialChanged ||\n    lightingChanged ||\n    translucencyChanged ||\n    useLogDepthChanged\n  ) {\n    vs = new ShaderSource({\n      sources: [EllipsoidVS],\n    });\n    fs = new ShaderSource({\n      sources: [this.material.shaderSource, EllipsoidFS],\n    });\n    if (this.onlySunLighting) {\n      fs.defines.push(\"ONLY_SUN_LIGHTING\");\n    }\n    if (!translucent && context.fragmentDepth) {\n      fs.defines.push(\"WRITE_DEPTH\");\n    }\n    if (this._useLogDepth) {\n      vs.defines.push(\"LOG_DEPTH\");\n      fs.defines.push(\"LOG_DEPTH\");\n      fs.sources.push(logDepthExtension);\n    }\n\n    this._sp = ShaderProgram.replaceCache({\n      context: context,\n      shaderProgram: this._sp,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n      attributeLocations: attributeLocations,\n    });\n\n    colorCommand.vertexArray = this._va;\n    colorCommand.renderState = this._rs;\n    colorCommand.shaderProgram = this._sp;\n    colorCommand.uniformMap = combine(this._uniforms, this.material._uniforms);\n    colorCommand.executeInClosestFrustum = translucent;\n  }\n\n  var commandList = frameState.commandList;\n  var passes = frameState.passes;\n\n  if (passes.render) {\n    colorCommand.boundingVolume = this._boundingSphere;\n    colorCommand.debugShowBoundingVolume = this.debugShowBoundingVolume;\n    colorCommand.modelMatrix = this._computedModelMatrix;\n    colorCommand.pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;\n\n    commandList.push(colorCommand);\n  }\n\n  if (passes.pick) {\n    var pickCommand = this._pickCommand;\n\n    if (!defined(this._pickId) || this._id !== this.id) {\n      this._id = this.id;\n      this._pickId = this._pickId && this._pickId.destroy();\n      this._pickId = context.createPickId({\n        primitive: this,\n        id: this.id,\n      });\n    }\n\n    // Recompile shader when material changes\n    if (\n      materialChanged ||\n      lightingChanged ||\n      !defined(this._pickSP) ||\n      useLogDepthChanged\n    ) {\n      vs = new ShaderSource({\n        sources: [EllipsoidVS],\n      });\n      fs = new ShaderSource({\n        sources: [this.material.shaderSource, EllipsoidFS],\n        pickColorQualifier: \"uniform\",\n      });\n      if (this.onlySunLighting) {\n        fs.defines.push(\"ONLY_SUN_LIGHTING\");\n      }\n      if (!translucent && context.fragmentDepth) {\n        fs.defines.push(\"WRITE_DEPTH\");\n      }\n      if (this._useLogDepth) {\n        vs.defines.push(\"LOG_DEPTH\");\n        fs.defines.push(\"LOG_DEPTH\");\n        fs.sources.push(logDepthExtension);\n      }\n\n      this._pickSP = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._pickSP,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      });\n\n      pickCommand.vertexArray = this._va;\n      pickCommand.renderState = this._rs;\n      pickCommand.shaderProgram = this._pickSP;\n      pickCommand.uniformMap = combine(\n        combine(this._uniforms, this._pickUniforms),\n        this.material._uniforms\n      );\n      pickCommand.executeInClosestFrustum = translucent;\n    }\n\n    pickCommand.boundingVolume = this._boundingSphere;\n    pickCommand.modelMatrix = this._computedModelMatrix;\n    pickCommand.pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;\n\n    commandList.push(pickCommand);\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see EllipsoidPrimitive#destroy\n */\nEllipsoidPrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * e = e && e.destroy();\n *\n * @see EllipsoidPrimitive#isDestroyed\n */\nEllipsoidPrimitive.prototype.destroy = function () {\n  this._sp = this._sp && this._sp.destroy();\n  this._pickSP = this._pickSP && this._pickSP.destroy();\n  this._pickId = this._pickId && this._pickId.destroy();\n  return destroyObject(this);\n};\nexport default EllipsoidPrimitive;\n"]},"metadata":{},"sourceType":"module"}