{"ast":null,"code":"import sprintf from \"../ThirdParty/sprintf.js\";\nimport binarySearch from \"./binarySearch.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport GregorianDate from \"./GregorianDate.js\";\nimport isLeapYear from \"./isLeapYear.js\";\nimport LeapSecond from \"./LeapSecond.js\";\nimport TimeConstants from \"./TimeConstants.js\";\nimport TimeStandard from \"./TimeStandard.js\";\nvar gregorianDateScratch = new GregorianDate();\nvar daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nvar daysInLeapFeburary = 29;\n\nfunction compareLeapSecondDates(leapSecond, dateToFind) {\n  return JulianDate.compare(leapSecond.julianDate, dateToFind.julianDate);\n} // we don't really need a leap second instance, anything with a julianDate property will do\n\n\nvar binarySearchScratchLeapSecond = new LeapSecond();\n\nfunction convertUtcToTai(julianDate) {\n  //Even though julianDate is in UTC, we'll treat it as TAI and\n  //search the leap second table for it.\n  binarySearchScratchLeapSecond.julianDate = julianDate;\n  var leapSeconds = JulianDate.leapSeconds;\n  var index = binarySearch(leapSeconds, binarySearchScratchLeapSecond, compareLeapSecondDates);\n\n  if (index < 0) {\n    index = ~index;\n  }\n\n  if (index >= leapSeconds.length) {\n    index = leapSeconds.length - 1;\n  }\n\n  var offset = leapSeconds[index].offset;\n\n  if (index > 0) {\n    //Now we have the index of the closest leap second that comes on or after our UTC time.\n    //However, if the difference between the UTC date being converted and the TAI\n    //defined leap second is greater than the offset, we are off by one and need to use\n    //the previous leap second.\n    var difference = JulianDate.secondsDifference(leapSeconds[index].julianDate, julianDate);\n\n    if (difference > offset) {\n      index--;\n      offset = leapSeconds[index].offset;\n    }\n  }\n\n  JulianDate.addSeconds(julianDate, offset, julianDate);\n}\n\nfunction convertTaiToUtc(julianDate, result) {\n  binarySearchScratchLeapSecond.julianDate = julianDate;\n  var leapSeconds = JulianDate.leapSeconds;\n  var index = binarySearch(leapSeconds, binarySearchScratchLeapSecond, compareLeapSecondDates);\n\n  if (index < 0) {\n    index = ~index;\n  } //All times before our first leap second get the first offset.\n\n\n  if (index === 0) {\n    return JulianDate.addSeconds(julianDate, -leapSeconds[0].offset, result);\n  } //All times after our leap second get the last offset.\n\n\n  if (index >= leapSeconds.length) {\n    return JulianDate.addSeconds(julianDate, -leapSeconds[index - 1].offset, result);\n  } //Compute the difference between the found leap second and the time we are converting.\n\n\n  var difference = JulianDate.secondsDifference(leapSeconds[index].julianDate, julianDate);\n\n  if (difference === 0) {\n    //The date is in our leap second table.\n    return JulianDate.addSeconds(julianDate, -leapSeconds[index].offset, result);\n  }\n\n  if (difference <= 1.0) {\n    //The requested date is during the moment of a leap second, then we cannot convert to UTC\n    return undefined;\n  } //The time is in between two leap seconds, index is the leap second after the date\n  //we're converting, so we subtract one to get the correct LeapSecond instance.\n\n\n  return JulianDate.addSeconds(julianDate, -leapSeconds[--index].offset, result);\n}\n\nfunction setComponents(wholeDays, secondsOfDay, julianDate) {\n  var extraDays = secondsOfDay / TimeConstants.SECONDS_PER_DAY | 0;\n  wholeDays += extraDays;\n  secondsOfDay -= TimeConstants.SECONDS_PER_DAY * extraDays;\n\n  if (secondsOfDay < 0) {\n    wholeDays--;\n    secondsOfDay += TimeConstants.SECONDS_PER_DAY;\n  }\n\n  julianDate.dayNumber = wholeDays;\n  julianDate.secondsOfDay = secondsOfDay;\n  return julianDate;\n}\n\nfunction computeJulianDateComponents(year, month, day, hour, minute, second, millisecond) {\n  // Algorithm from page 604 of the Explanatory Supplement to the\n  // Astronomical Almanac (Seidelmann 1992).\n  var a = (month - 14) / 12 | 0;\n  var b = year + 4800 + a;\n  var dayNumber = (1461 * b / 4 | 0) + (367 * (month - 2 - 12 * a) / 12 | 0) - (3 * ((b + 100) / 100 | 0) / 4 | 0) + day - 32075; // JulianDates are noon-based\n\n  hour = hour - 12;\n\n  if (hour < 0) {\n    hour += 24;\n  }\n\n  var secondsOfDay = second + (hour * TimeConstants.SECONDS_PER_HOUR + minute * TimeConstants.SECONDS_PER_MINUTE + millisecond * TimeConstants.SECONDS_PER_MILLISECOND);\n\n  if (secondsOfDay >= 43200.0) {\n    dayNumber -= 1;\n  }\n\n  return [dayNumber, secondsOfDay];\n} //Regular expressions used for ISO8601 date parsing.\n//YYYY\n\n\nvar matchCalendarYear = /^(\\d{4})$/; //YYYY-MM (YYYYMM is invalid)\n\nvar matchCalendarMonth = /^(\\d{4})-(\\d{2})$/; //YYYY-DDD or YYYYDDD\n\nvar matchOrdinalDate = /^(\\d{4})-?(\\d{3})$/; //YYYY-Www or YYYYWww or YYYY-Www-D or YYYYWwwD\n\nvar matchWeekDate = /^(\\d{4})-?W(\\d{2})-?(\\d{1})?$/; //YYYY-MM-DD or YYYYMMDD\n\nvar matchCalendarDate = /^(\\d{4})-?(\\d{2})-?(\\d{2})$/; // Match utc offset\n\nvar utcOffset = /([Z+\\-])?(\\d{2})?:?(\\d{2})?$/; // Match hours HH or HH.xxxxx\n\nvar matchHours = /^(\\d{2})(\\.\\d+)?/.source + utcOffset.source; // Match hours/minutes HH:MM HHMM.xxxxx\n\nvar matchHoursMinutes = /^(\\d{2}):?(\\d{2})(\\.\\d+)?/.source + utcOffset.source; // Match hours/minutes HH:MM:SS HHMMSS.xxxxx\n\nvar matchHoursMinutesSeconds = /^(\\d{2}):?(\\d{2}):?(\\d{2})(\\.\\d+)?/.source + utcOffset.source;\nvar iso8601ErrorMessage = \"Invalid ISO 8601 date.\";\n/**\n * Represents an astronomical Julian date, which is the number of days since noon on January 1, -4712 (4713 BC).\n * For increased precision, this class stores the whole number part of the date and the seconds\n * part of the date in separate components.  In order to be safe for arithmetic and represent\n * leap seconds, the date is always stored in the International Atomic Time standard\n * {@link TimeStandard.TAI}.\n * @alias JulianDate\n * @constructor\n *\n * @param {Number} [julianDayNumber=0.0] The Julian Day Number representing the number of whole days.  Fractional days will also be handled correctly.\n * @param {Number} [secondsOfDay=0.0] The number of seconds into the current Julian Day Number.  Fractional seconds, negative seconds and seconds greater than a day will be handled correctly.\n * @param {TimeStandard} [timeStandard=TimeStandard.UTC] The time standard in which the first two parameters are defined.\n */\n\nfunction JulianDate(julianDayNumber, secondsOfDay, timeStandard) {\n  /**\n   * Gets or sets the number of whole days.\n   * @type {Number}\n   */\n  this.dayNumber = undefined;\n  /**\n   * Gets or sets the number of seconds into the current day.\n   * @type {Number}\n   */\n\n  this.secondsOfDay = undefined;\n  julianDayNumber = defaultValue(julianDayNumber, 0.0);\n  secondsOfDay = defaultValue(secondsOfDay, 0.0);\n  timeStandard = defaultValue(timeStandard, TimeStandard.UTC); //If julianDayNumber is fractional, make it an integer and add the number of seconds the fraction represented.\n\n  var wholeDays = julianDayNumber | 0;\n  secondsOfDay = secondsOfDay + (julianDayNumber - wholeDays) * TimeConstants.SECONDS_PER_DAY;\n  setComponents(wholeDays, secondsOfDay, this);\n\n  if (timeStandard === TimeStandard.UTC) {\n    convertUtcToTai(this);\n  }\n}\n/**\n * Creates a new instance from a GregorianDate.\n *\n * @param {GregorianDate} date A GregorianDate.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n *\n * @exception {DeveloperError} date must be a valid GregorianDate.\n */\n\n\nJulianDate.fromGregorianDate = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!(date instanceof GregorianDate)) {\n    throw new DeveloperError(\"date must be a valid GregorianDate.\");\n  } //>>includeEnd('debug');\n\n\n  var components = computeJulianDateComponents(date.year, date.month, date.day, date.hour, date.minute, date.second, date.millisecond);\n\n  if (!defined(result)) {\n    return new JulianDate(components[0], components[1], TimeStandard.UTC);\n  }\n\n  setComponents(components[0], components[1], result);\n  convertUtcToTai(result);\n  return result;\n};\n/**\n * Creates a new instance from a JavaScript Date.\n *\n * @param {Date} date A JavaScript Date.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n *\n * @exception {DeveloperError} date must be a valid JavaScript Date.\n */\n\n\nJulianDate.fromDate = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!(date instanceof Date) || isNaN(date.getTime())) {\n    throw new DeveloperError(\"date must be a valid JavaScript Date.\");\n  } //>>includeEnd('debug');\n\n\n  var components = computeJulianDateComponents(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());\n\n  if (!defined(result)) {\n    return new JulianDate(components[0], components[1], TimeStandard.UTC);\n  }\n\n  setComponents(components[0], components[1], result);\n  convertUtcToTai(result);\n  return result;\n};\n/**\n * Creates a new instance from a from an {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} date.\n * This method is superior to <code>Date.parse</code> because it will handle all valid formats defined by the ISO 8601\n * specification, including leap seconds and sub-millisecond times, which discarded by most JavaScript implementations.\n *\n * @param {String} iso8601String An ISO 8601 date.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n *\n * @exception {DeveloperError} Invalid ISO 8601 date.\n */\n\n\nJulianDate.fromIso8601 = function (iso8601String, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof iso8601String !== \"string\") {\n    throw new DeveloperError(iso8601ErrorMessage);\n  } //>>includeEnd('debug');\n  //Comma and decimal point both indicate a fractional number according to ISO 8601,\n  //start out by blanket replacing , with . which is the only valid such symbol in JS.\n\n\n  iso8601String = iso8601String.replace(\",\", \".\"); //Split the string into its date and time components, denoted by a mandatory T\n\n  var tokens = iso8601String.split(\"T\");\n  var year;\n  var month = 1;\n  var day = 1;\n  var hour = 0;\n  var minute = 0;\n  var second = 0;\n  var millisecond = 0; //Lacking a time is okay, but a missing date is illegal.\n\n  var date = tokens[0];\n  var time = tokens[1];\n  var tmp;\n  var inLeapYear; //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(date)) {\n    throw new DeveloperError(iso8601ErrorMessage);\n  }\n\n  var dashCount; //>>includeEnd('debug');\n  //First match the date against possible regular expressions.\n\n  tokens = date.match(matchCalendarDate);\n\n  if (tokens !== null) {\n    //>>includeStart('debug', pragmas.debug);\n    dashCount = date.split(\"-\").length - 1;\n\n    if (dashCount > 0 && dashCount !== 2) {\n      throw new DeveloperError(iso8601ErrorMessage);\n    } //>>includeEnd('debug');\n\n\n    year = +tokens[1];\n    month = +tokens[2];\n    day = +tokens[3];\n  } else {\n    tokens = date.match(matchCalendarMonth);\n\n    if (tokens !== null) {\n      year = +tokens[1];\n      month = +tokens[2];\n    } else {\n      tokens = date.match(matchCalendarYear);\n\n      if (tokens !== null) {\n        year = +tokens[1];\n      } else {\n        //Not a year/month/day so it must be an ordinal date.\n        var dayOfYear;\n        tokens = date.match(matchOrdinalDate);\n\n        if (tokens !== null) {\n          year = +tokens[1];\n          dayOfYear = +tokens[2];\n          inLeapYear = isLeapYear(year); //This validation is only applicable for this format.\n          //>>includeStart('debug', pragmas.debug);\n\n          if (dayOfYear < 1 || inLeapYear && dayOfYear > 366 || !inLeapYear && dayOfYear > 365) {\n            throw new DeveloperError(iso8601ErrorMessage);\n          } //>>includeEnd('debug')\n\n        } else {\n          tokens = date.match(matchWeekDate);\n\n          if (tokens !== null) {\n            //ISO week date to ordinal date from\n            //http://en.wikipedia.org/w/index.php?title=ISO_week_date&oldid=474176775\n            year = +tokens[1];\n            var weekNumber = +tokens[2];\n            var dayOfWeek = +tokens[3] || 0; //>>includeStart('debug', pragmas.debug);\n\n            dashCount = date.split(\"-\").length - 1;\n\n            if (dashCount > 0 && (!defined(tokens[3]) && dashCount !== 1 || defined(tokens[3]) && dashCount !== 2)) {\n              throw new DeveloperError(iso8601ErrorMessage);\n            } //>>includeEnd('debug')\n\n\n            var january4 = new Date(Date.UTC(year, 0, 4));\n            dayOfYear = weekNumber * 7 + dayOfWeek - january4.getUTCDay() - 3;\n          } else {\n            //None of our regular expressions succeeded in parsing the date properly.\n            //>>includeStart('debug', pragmas.debug);\n            throw new DeveloperError(iso8601ErrorMessage); //>>includeEnd('debug')\n          }\n        } //Split an ordinal date into month/day.\n\n\n        tmp = new Date(Date.UTC(year, 0, 1));\n        tmp.setUTCDate(dayOfYear);\n        month = tmp.getUTCMonth() + 1;\n        day = tmp.getUTCDate();\n      }\n    }\n  } //Now that we have all of the date components, validate them to make sure nothing is out of range.\n\n\n  inLeapYear = isLeapYear(year); //>>includeStart('debug', pragmas.debug);\n\n  if (month < 1 || month > 12 || day < 1 || (month !== 2 || !inLeapYear) && day > daysInMonth[month - 1] || inLeapYear && month === 2 && day > daysInLeapFeburary) {\n    throw new DeveloperError(iso8601ErrorMessage);\n  } //>>includeEnd('debug')\n  //Now move onto the time string, which is much simpler.\n  //If no time is specified, it is considered the beginning of the day, UTC to match Javascript's implementation.\n\n\n  var offsetIndex;\n\n  if (defined(time)) {\n    tokens = time.match(matchHoursMinutesSeconds);\n\n    if (tokens !== null) {\n      //>>includeStart('debug', pragmas.debug);\n      dashCount = time.split(\":\").length - 1;\n\n      if (dashCount > 0 && dashCount !== 2 && dashCount !== 3) {\n        throw new DeveloperError(iso8601ErrorMessage);\n      } //>>includeEnd('debug')\n\n\n      hour = +tokens[1];\n      minute = +tokens[2];\n      second = +tokens[3];\n      millisecond = +(tokens[4] || 0) * 1000.0;\n      offsetIndex = 5;\n    } else {\n      tokens = time.match(matchHoursMinutes);\n\n      if (tokens !== null) {\n        //>>includeStart('debug', pragmas.debug);\n        dashCount = time.split(\":\").length - 1;\n\n        if (dashCount > 2) {\n          throw new DeveloperError(iso8601ErrorMessage);\n        } //>>includeEnd('debug')\n\n\n        hour = +tokens[1];\n        minute = +tokens[2];\n        second = +(tokens[3] || 0) * 60.0;\n        offsetIndex = 4;\n      } else {\n        tokens = time.match(matchHours);\n\n        if (tokens !== null) {\n          hour = +tokens[1];\n          minute = +(tokens[2] || 0) * 60.0;\n          offsetIndex = 3;\n        } else {\n          //>>includeStart('debug', pragmas.debug);\n          throw new DeveloperError(iso8601ErrorMessage); //>>includeEnd('debug')\n        }\n      }\n    } //Validate that all values are in proper range.  Minutes and hours have special cases at 60 and 24.\n    //>>includeStart('debug', pragmas.debug);\n\n\n    if (minute >= 60 || second >= 61 || hour > 24 || hour === 24 && (minute > 0 || second > 0 || millisecond > 0)) {\n      throw new DeveloperError(iso8601ErrorMessage);\n    } //>>includeEnd('debug');\n    //Check the UTC offset value, if no value exists, use local time\n    //a Z indicates UTC, + or - are offsets.\n\n\n    var offset = tokens[offsetIndex];\n    var offsetHours = +tokens[offsetIndex + 1];\n    var offsetMinutes = +(tokens[offsetIndex + 2] || 0);\n\n    switch (offset) {\n      case \"+\":\n        hour = hour - offsetHours;\n        minute = minute - offsetMinutes;\n        break;\n\n      case \"-\":\n        hour = hour + offsetHours;\n        minute = minute + offsetMinutes;\n        break;\n\n      case \"Z\":\n        break;\n\n      default:\n        minute = minute + new Date(Date.UTC(year, month - 1, day, hour, minute)).getTimezoneOffset();\n        break;\n    }\n  } //ISO8601 denotes a leap second by any time having a seconds component of 60 seconds.\n  //If that's the case, we need to temporarily subtract a second in order to build a UTC date.\n  //Then we add it back in after converting to TAI.\n\n\n  var isLeapSecond = second === 60;\n\n  if (isLeapSecond) {\n    second--;\n  } //Even if we successfully parsed the string into its components, after applying UTC offset or\n  //special cases like 24:00:00 denoting midnight, we need to normalize the data appropriately.\n  //milliseconds can never be greater than 1000, and seconds can't be above 60, so we start with minutes\n\n\n  while (minute >= 60) {\n    minute -= 60;\n    hour++;\n  }\n\n  while (hour >= 24) {\n    hour -= 24;\n    day++;\n  }\n\n  tmp = inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];\n\n  while (day > tmp) {\n    day -= tmp;\n    month++;\n\n    if (month > 12) {\n      month -= 12;\n      year++;\n    }\n\n    tmp = inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];\n  } //If UTC offset is at the beginning/end of the day, minutes can be negative.\n\n\n  while (minute < 0) {\n    minute += 60;\n    hour--;\n  }\n\n  while (hour < 0) {\n    hour += 24;\n    day--;\n  }\n\n  while (day < 1) {\n    month--;\n\n    if (month < 1) {\n      month += 12;\n      year--;\n    }\n\n    tmp = inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];\n    day += tmp;\n  } //Now create the JulianDate components from the Gregorian date and actually create our instance.\n\n\n  var components = computeJulianDateComponents(year, month, day, hour, minute, second, millisecond);\n\n  if (!defined(result)) {\n    result = new JulianDate(components[0], components[1], TimeStandard.UTC);\n  } else {\n    setComponents(components[0], components[1], result);\n    convertUtcToTai(result);\n  } //If we were on a leap second, add it back.\n\n\n  if (isLeapSecond) {\n    JulianDate.addSeconds(result, 1, result);\n  }\n\n  return result;\n};\n/**\n * Creates a new instance that represents the current system time.\n * This is equivalent to calling <code>JulianDate.fromDate(new Date());</code>.\n *\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n */\n\n\nJulianDate.now = function (result) {\n  return JulianDate.fromDate(new Date(), result);\n};\n\nvar toGregorianDateScratch = new JulianDate(0, 0, TimeStandard.TAI);\n/**\n * Creates a {@link GregorianDate} from the provided instance.\n *\n * @param {JulianDate} julianDate The date to be converted.\n * @param {GregorianDate} [result] An existing instance to use for the result.\n * @returns {GregorianDate} The modified result parameter or a new instance if none was provided.\n */\n\nJulianDate.toGregorianDate = function (julianDate, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  } //>>includeEnd('debug');\n\n\n  var isLeapSecond = false;\n  var thisUtc = convertTaiToUtc(julianDate, toGregorianDateScratch);\n\n  if (!defined(thisUtc)) {\n    //Conversion to UTC will fail if we are during a leap second.\n    //If that's the case, subtract a second and convert again.\n    //JavaScript doesn't support leap seconds, so this results in second 59 being repeated twice.\n    JulianDate.addSeconds(julianDate, -1, toGregorianDateScratch);\n    thisUtc = convertTaiToUtc(toGregorianDateScratch, toGregorianDateScratch);\n    isLeapSecond = true;\n  }\n\n  var julianDayNumber = thisUtc.dayNumber;\n  var secondsOfDay = thisUtc.secondsOfDay;\n\n  if (secondsOfDay >= 43200.0) {\n    julianDayNumber += 1;\n  } // Algorithm from page 604 of the Explanatory Supplement to the\n  // Astronomical Almanac (Seidelmann 1992).\n\n\n  var L = julianDayNumber + 68569 | 0;\n  var N = 4 * L / 146097 | 0;\n  L = L - ((146097 * N + 3) / 4 | 0) | 0;\n  var I = 4000 * (L + 1) / 1461001 | 0;\n  L = L - (1461 * I / 4 | 0) + 31 | 0;\n  var J = 80 * L / 2447 | 0;\n  var day = L - (2447 * J / 80 | 0) | 0;\n  L = J / 11 | 0;\n  var month = J + 2 - 12 * L | 0;\n  var year = 100 * (N - 49) + I + L | 0;\n  var hour = secondsOfDay / TimeConstants.SECONDS_PER_HOUR | 0;\n  var remainingSeconds = secondsOfDay - hour * TimeConstants.SECONDS_PER_HOUR;\n  var minute = remainingSeconds / TimeConstants.SECONDS_PER_MINUTE | 0;\n  remainingSeconds = remainingSeconds - minute * TimeConstants.SECONDS_PER_MINUTE;\n  var second = remainingSeconds | 0;\n  var millisecond = (remainingSeconds - second) / TimeConstants.SECONDS_PER_MILLISECOND; // JulianDates are noon-based\n\n  hour += 12;\n\n  if (hour > 23) {\n    hour -= 24;\n  } //If we were on a leap second, add it back.\n\n\n  if (isLeapSecond) {\n    second += 1;\n  }\n\n  if (!defined(result)) {\n    return new GregorianDate(year, month, day, hour, minute, second, millisecond, isLeapSecond);\n  }\n\n  result.year = year;\n  result.month = month;\n  result.day = day;\n  result.hour = hour;\n  result.minute = minute;\n  result.second = second;\n  result.millisecond = millisecond;\n  result.isLeapSecond = isLeapSecond;\n  return result;\n};\n/**\n * Creates a JavaScript Date from the provided instance.\n * Since JavaScript dates are only accurate to the nearest millisecond and\n * cannot represent a leap second, consider using {@link JulianDate.toGregorianDate} instead.\n * If the provided JulianDate is during a leap second, the previous second is used.\n *\n * @param {JulianDate} julianDate The date to be converted.\n * @returns {Date} A new instance representing the provided date.\n */\n\n\nJulianDate.toDate = function (julianDate) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  } //>>includeEnd('debug');\n\n\n  var gDate = JulianDate.toGregorianDate(julianDate, gregorianDateScratch);\n  var second = gDate.second;\n\n  if (gDate.isLeapSecond) {\n    second -= 1;\n  }\n\n  return new Date(Date.UTC(gDate.year, gDate.month - 1, gDate.day, gDate.hour, gDate.minute, second, gDate.millisecond));\n};\n/**\n * Creates an ISO8601 representation of the provided date.\n *\n * @param {JulianDate} julianDate The date to be converted.\n * @param {Number} [precision] The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.\n * @returns {String} The ISO8601 representation of the provided date.\n */\n\n\nJulianDate.toIso8601 = function (julianDate, precision) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  } //>>includeEnd('debug');\n\n\n  var gDate = JulianDate.toGregorianDate(julianDate, gregorianDateScratch);\n  var year = gDate.year;\n  var month = gDate.month;\n  var day = gDate.day;\n  var hour = gDate.hour;\n  var minute = gDate.minute;\n  var second = gDate.second;\n  var millisecond = gDate.millisecond; // special case - Iso8601.MAXIMUM_VALUE produces a string which we can't parse unless we adjust.\n  // 10000-01-01T00:00:00 is the same instant as 9999-12-31T24:00:00\n\n  if (year === 10000 && month === 1 && day === 1 && hour === 0 && minute === 0 && second === 0 && millisecond === 0) {\n    year = 9999;\n    month = 12;\n    day = 31;\n    hour = 24;\n  }\n\n  var millisecondStr;\n\n  if (!defined(precision) && millisecond !== 0) {\n    //Forces milliseconds into a number with at least 3 digits to whatever the default toString() precision is.\n    millisecondStr = (millisecond * 0.01).toString().replace(\".\", \"\");\n    return sprintf(\"%04d-%02d-%02dT%02d:%02d:%02d.%sZ\", year, month, day, hour, minute, second, millisecondStr);\n  } //Precision is either 0 or milliseconds is 0 with undefined precision, in either case, leave off milliseconds entirely\n\n\n  if (!defined(precision) || precision === 0) {\n    return sprintf(\"%04d-%02d-%02dT%02d:%02d:%02dZ\", year, month, day, hour, minute, second);\n  } //Forces milliseconds into a number with at least 3 digits to whatever the specified precision is.\n\n\n  millisecondStr = (millisecond * 0.01).toFixed(precision).replace(\".\", \"\").slice(0, precision);\n  return sprintf(\"%04d-%02d-%02dT%02d:%02d:%02d.%sZ\", year, month, day, hour, minute, second, millisecondStr);\n};\n/**\n * Duplicates a JulianDate instance.\n *\n * @param {JulianDate} julianDate The date to duplicate.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided. Returns undefined if julianDate is undefined.\n */\n\n\nJulianDate.clone = function (julianDate, result) {\n  if (!defined(julianDate)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new JulianDate(julianDate.dayNumber, julianDate.secondsOfDay, TimeStandard.TAI);\n  }\n\n  result.dayNumber = julianDate.dayNumber;\n  result.secondsOfDay = julianDate.secondsOfDay;\n  return result;\n};\n/**\n * Compares two instances.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Number} A negative value if left is less than right, a positive value if left is greater than right, or zero if left and right are equal.\n */\n\n\nJulianDate.compare = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"left is required.\");\n  }\n\n  if (!defined(right)) {\n    throw new DeveloperError(\"right is required.\");\n  } //>>includeEnd('debug');\n\n\n  var julianDayNumberDifference = left.dayNumber - right.dayNumber;\n\n  if (julianDayNumberDifference !== 0) {\n    return julianDayNumberDifference;\n  }\n\n  return left.secondsOfDay - right.secondsOfDay;\n};\n/**\n * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {JulianDate} [left] The first instance.\n * @param {JulianDate} [right] The second instance.\n * @returns {Boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.\n */\n\n\nJulianDate.equals = function (left, right) {\n  return left === right || defined(left) && defined(right) && left.dayNumber === right.dayNumber && left.secondsOfDay === right.secondsOfDay;\n};\n/**\n * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of\n * each other.  That is, in order for the dates to be considered equal (and for\n * this function to return <code>true</code>), the absolute value of the difference between them, in\n * seconds, must be less than <code>epsilon</code>.\n *\n * @param {JulianDate} [left] The first instance.\n * @param {JulianDate} [right] The second instance.\n * @param {Number} epsilon The maximum number of seconds that should separate the two instances.\n * @returns {Boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.\n */\n\n\nJulianDate.equalsEpsilon = function (left, right, epsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(epsilon)) {\n    throw new DeveloperError(\"epsilon is required.\");\n  } //>>includeEnd('debug');\n\n\n  return left === right || defined(left) && defined(right) && Math.abs(JulianDate.secondsDifference(left, right)) <= epsilon;\n};\n/**\n * Computes the total number of whole and fractional days represented by the provided instance.\n *\n * @param {JulianDate} julianDate The date.\n * @returns {Number} The Julian date as single floating point number.\n */\n\n\nJulianDate.totalDays = function (julianDate) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  } //>>includeEnd('debug');\n\n\n  return julianDate.dayNumber + julianDate.secondsOfDay / TimeConstants.SECONDS_PER_DAY;\n};\n/**\n * Computes the difference in seconds between the provided instance.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Number} The difference, in seconds, when subtracting <code>right</code> from <code>left</code>.\n */\n\n\nJulianDate.secondsDifference = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"left is required.\");\n  }\n\n  if (!defined(right)) {\n    throw new DeveloperError(\"right is required.\");\n  } //>>includeEnd('debug');\n\n\n  var dayDifference = (left.dayNumber - right.dayNumber) * TimeConstants.SECONDS_PER_DAY;\n  return dayDifference + (left.secondsOfDay - right.secondsOfDay);\n};\n/**\n * Computes the difference in days between the provided instance.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Number} The difference, in days, when subtracting <code>right</code> from <code>left</code>.\n */\n\n\nJulianDate.daysDifference = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"left is required.\");\n  }\n\n  if (!defined(right)) {\n    throw new DeveloperError(\"right is required.\");\n  } //>>includeEnd('debug');\n\n\n  var dayDifference = left.dayNumber - right.dayNumber;\n  var secondDifference = (left.secondsOfDay - right.secondsOfDay) / TimeConstants.SECONDS_PER_DAY;\n  return dayDifference + secondDifference;\n};\n/**\n * Computes the number of seconds the provided instance is ahead of UTC.\n *\n * @param {JulianDate} julianDate The date.\n * @returns {Number} The number of seconds the provided instance is ahead of UTC\n */\n\n\nJulianDate.computeTaiMinusUtc = function (julianDate) {\n  binarySearchScratchLeapSecond.julianDate = julianDate;\n  var leapSeconds = JulianDate.leapSeconds;\n  var index = binarySearch(leapSeconds, binarySearchScratchLeapSecond, compareLeapSecondDates);\n\n  if (index < 0) {\n    index = ~index;\n    --index;\n\n    if (index < 0) {\n      index = 0;\n    }\n  }\n\n  return leapSeconds[index].offset;\n};\n/**\n * Adds the provided number of seconds to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {Number} seconds The number of seconds to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\n\n\nJulianDate.addSeconds = function (julianDate, seconds, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n\n  if (!defined(seconds)) {\n    throw new DeveloperError(\"seconds is required.\");\n  }\n\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  } //>>includeEnd('debug');\n\n\n  return setComponents(julianDate.dayNumber, julianDate.secondsOfDay + seconds, result);\n};\n/**\n * Adds the provided number of minutes to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {Number} minutes The number of minutes to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\n\n\nJulianDate.addMinutes = function (julianDate, minutes, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n\n  if (!defined(minutes)) {\n    throw new DeveloperError(\"minutes is required.\");\n  }\n\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  } //>>includeEnd('debug');\n\n\n  var newSecondsOfDay = julianDate.secondsOfDay + minutes * TimeConstants.SECONDS_PER_MINUTE;\n  return setComponents(julianDate.dayNumber, newSecondsOfDay, result);\n};\n/**\n * Adds the provided number of hours to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {Number} hours The number of hours to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\n\n\nJulianDate.addHours = function (julianDate, hours, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n\n  if (!defined(hours)) {\n    throw new DeveloperError(\"hours is required.\");\n  }\n\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  } //>>includeEnd('debug');\n\n\n  var newSecondsOfDay = julianDate.secondsOfDay + hours * TimeConstants.SECONDS_PER_HOUR;\n  return setComponents(julianDate.dayNumber, newSecondsOfDay, result);\n};\n/**\n * Adds the provided number of days to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {Number} days The number of days to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\n\n\nJulianDate.addDays = function (julianDate, days, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n\n  if (!defined(days)) {\n    throw new DeveloperError(\"days is required.\");\n  }\n\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  } //>>includeEnd('debug');\n\n\n  var newJulianDayNumber = julianDate.dayNumber + days;\n  return setComponents(newJulianDayNumber, julianDate.secondsOfDay, result);\n};\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Boolean} <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.\n */\n\n\nJulianDate.lessThan = function (left, right) {\n  return JulianDate.compare(left, right) < 0;\n};\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Boolean} <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.\n */\n\n\nJulianDate.lessThanOrEquals = function (left, right) {\n  return JulianDate.compare(left, right) <= 0;\n};\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Boolean} <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.\n */\n\n\nJulianDate.greaterThan = function (left, right) {\n  return JulianDate.compare(left, right) > 0;\n};\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Boolean} <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.\n */\n\n\nJulianDate.greaterThanOrEquals = function (left, right) {\n  return JulianDate.compare(left, right) >= 0;\n};\n/**\n * Duplicates this instance.\n *\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n */\n\n\nJulianDate.prototype.clone = function (result) {\n  return JulianDate.clone(this, result);\n};\n/**\n * Compares this and the provided instance and returns <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {JulianDate} [right] The second instance.\n * @returns {Boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.\n */\n\n\nJulianDate.prototype.equals = function (right) {\n  return JulianDate.equals(this, right);\n};\n/**\n * Compares this and the provided instance and returns <code>true</code> if they are within <code>epsilon</code> seconds of\n * each other.  That is, in order for the dates to be considered equal (and for\n * this function to return <code>true</code>), the absolute value of the difference between them, in\n * seconds, must be less than <code>epsilon</code>.\n *\n * @param {JulianDate} [right] The second instance.\n * @param {Number} epsilon The maximum number of seconds that should separate the two instances.\n * @returns {Boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.\n */\n\n\nJulianDate.prototype.equalsEpsilon = function (right, epsilon) {\n  return JulianDate.equalsEpsilon(this, right, epsilon);\n};\n/**\n * Creates a string representing this date in ISO8601 format.\n *\n * @returns {String} A string representing this date in ISO8601 format.\n */\n\n\nJulianDate.prototype.toString = function () {\n  return JulianDate.toIso8601(this);\n};\n/**\n * Gets or sets the list of leap seconds used throughout Cesium.\n * @memberof JulianDate\n * @type {LeapSecond[]}\n */\n\n\nJulianDate.leapSeconds = [new LeapSecond(new JulianDate(2441317, 43210.0, TimeStandard.TAI), 10), // January 1, 1972 00:00:00 UTC\nnew LeapSecond(new JulianDate(2441499, 43211.0, TimeStandard.TAI), 11), // July 1, 1972 00:00:00 UTC\nnew LeapSecond(new JulianDate(2441683, 43212.0, TimeStandard.TAI), 12), // January 1, 1973 00:00:00 UTC\nnew LeapSecond(new JulianDate(2442048, 43213.0, TimeStandard.TAI), 13), // January 1, 1974 00:00:00 UTC\nnew LeapSecond(new JulianDate(2442413, 43214.0, TimeStandard.TAI), 14), // January 1, 1975 00:00:00 UTC\nnew LeapSecond(new JulianDate(2442778, 43215.0, TimeStandard.TAI), 15), // January 1, 1976 00:00:00 UTC\nnew LeapSecond(new JulianDate(2443144, 43216.0, TimeStandard.TAI), 16), // January 1, 1977 00:00:00 UTC\nnew LeapSecond(new JulianDate(2443509, 43217.0, TimeStandard.TAI), 17), // January 1, 1978 00:00:00 UTC\nnew LeapSecond(new JulianDate(2443874, 43218.0, TimeStandard.TAI), 18), // January 1, 1979 00:00:00 UTC\nnew LeapSecond(new JulianDate(2444239, 43219.0, TimeStandard.TAI), 19), // January 1, 1980 00:00:00 UTC\nnew LeapSecond(new JulianDate(2444786, 43220.0, TimeStandard.TAI), 20), // July 1, 1981 00:00:00 UTC\nnew LeapSecond(new JulianDate(2445151, 43221.0, TimeStandard.TAI), 21), // July 1, 1982 00:00:00 UTC\nnew LeapSecond(new JulianDate(2445516, 43222.0, TimeStandard.TAI), 22), // July 1, 1983 00:00:00 UTC\nnew LeapSecond(new JulianDate(2446247, 43223.0, TimeStandard.TAI), 23), // July 1, 1985 00:00:00 UTC\nnew LeapSecond(new JulianDate(2447161, 43224.0, TimeStandard.TAI), 24), // January 1, 1988 00:00:00 UTC\nnew LeapSecond(new JulianDate(2447892, 43225.0, TimeStandard.TAI), 25), // January 1, 1990 00:00:00 UTC\nnew LeapSecond(new JulianDate(2448257, 43226.0, TimeStandard.TAI), 26), // January 1, 1991 00:00:00 UTC\nnew LeapSecond(new JulianDate(2448804, 43227.0, TimeStandard.TAI), 27), // July 1, 1992 00:00:00 UTC\nnew LeapSecond(new JulianDate(2449169, 43228.0, TimeStandard.TAI), 28), // July 1, 1993 00:00:00 UTC\nnew LeapSecond(new JulianDate(2449534, 43229.0, TimeStandard.TAI), 29), // July 1, 1994 00:00:00 UTC\nnew LeapSecond(new JulianDate(2450083, 43230.0, TimeStandard.TAI), 30), // January 1, 1996 00:00:00 UTC\nnew LeapSecond(new JulianDate(2450630, 43231.0, TimeStandard.TAI), 31), // July 1, 1997 00:00:00 UTC\nnew LeapSecond(new JulianDate(2451179, 43232.0, TimeStandard.TAI), 32), // January 1, 1999 00:00:00 UTC\nnew LeapSecond(new JulianDate(2453736, 43233.0, TimeStandard.TAI), 33), // January 1, 2006 00:00:00 UTC\nnew LeapSecond(new JulianDate(2454832, 43234.0, TimeStandard.TAI), 34), // January 1, 2009 00:00:00 UTC\nnew LeapSecond(new JulianDate(2456109, 43235.0, TimeStandard.TAI), 35), // July 1, 2012 00:00:00 UTC\nnew LeapSecond(new JulianDate(2457204, 43236.0, TimeStandard.TAI), 36), // July 1, 2015 00:00:00 UTC\nnew LeapSecond(new JulianDate(2457754, 43237.0, TimeStandard.TAI), 37) // January 1, 2017 00:00:00 UTC\n];\nexport default JulianDate;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/JulianDate.js"],"names":["sprintf","binarySearch","defaultValue","defined","DeveloperError","GregorianDate","isLeapYear","LeapSecond","TimeConstants","TimeStandard","gregorianDateScratch","daysInMonth","daysInLeapFeburary","compareLeapSecondDates","leapSecond","dateToFind","JulianDate","compare","julianDate","binarySearchScratchLeapSecond","convertUtcToTai","leapSeconds","index","length","offset","difference","secondsDifference","addSeconds","convertTaiToUtc","result","undefined","setComponents","wholeDays","secondsOfDay","extraDays","SECONDS_PER_DAY","dayNumber","computeJulianDateComponents","year","month","day","hour","minute","second","millisecond","a","b","SECONDS_PER_HOUR","SECONDS_PER_MINUTE","SECONDS_PER_MILLISECOND","matchCalendarYear","matchCalendarMonth","matchOrdinalDate","matchWeekDate","matchCalendarDate","utcOffset","matchHours","source","matchHoursMinutes","matchHoursMinutesSeconds","iso8601ErrorMessage","julianDayNumber","timeStandard","UTC","fromGregorianDate","date","components","fromDate","Date","isNaN","getTime","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","fromIso8601","iso8601String","replace","tokens","split","time","tmp","inLeapYear","dashCount","match","dayOfYear","weekNumber","dayOfWeek","january4","getUTCDay","setUTCDate","offsetIndex","offsetHours","offsetMinutes","getTimezoneOffset","isLeapSecond","now","toGregorianDateScratch","TAI","toGregorianDate","thisUtc","L","N","I","J","remainingSeconds","toDate","gDate","toIso8601","precision","millisecondStr","toString","toFixed","slice","clone","left","right","julianDayNumberDifference","equals","equalsEpsilon","epsilon","Math","abs","totalDays","dayDifference","daysDifference","secondDifference","computeTaiMinusUtc","seconds","addMinutes","minutes","newSecondsOfDay","addHours","hours","addDays","days","newJulianDayNumber","lessThan","lessThanOrEquals","greaterThan","greaterThanOrEquals","prototype"],"mappings":"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","sourcesContent":["import sprintf from \"../ThirdParty/sprintf.js\";\nimport binarySearch from \"./binarySearch.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport GregorianDate from \"./GregorianDate.js\";\nimport isLeapYear from \"./isLeapYear.js\";\nimport LeapSecond from \"./LeapSecond.js\";\nimport TimeConstants from \"./TimeConstants.js\";\nimport TimeStandard from \"./TimeStandard.js\";\n\nvar gregorianDateScratch = new GregorianDate();\nvar daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nvar daysInLeapFeburary = 29;\n\nfunction compareLeapSecondDates(leapSecond, dateToFind) {\n  return JulianDate.compare(leapSecond.julianDate, dateToFind.julianDate);\n}\n\n// we don't really need a leap second instance, anything with a julianDate property will do\nvar binarySearchScratchLeapSecond = new LeapSecond();\n\nfunction convertUtcToTai(julianDate) {\n  //Even though julianDate is in UTC, we'll treat it as TAI and\n  //search the leap second table for it.\n  binarySearchScratchLeapSecond.julianDate = julianDate;\n  var leapSeconds = JulianDate.leapSeconds;\n  var index = binarySearch(\n    leapSeconds,\n    binarySearchScratchLeapSecond,\n    compareLeapSecondDates\n  );\n\n  if (index < 0) {\n    index = ~index;\n  }\n\n  if (index >= leapSeconds.length) {\n    index = leapSeconds.length - 1;\n  }\n\n  var offset = leapSeconds[index].offset;\n  if (index > 0) {\n    //Now we have the index of the closest leap second that comes on or after our UTC time.\n    //However, if the difference between the UTC date being converted and the TAI\n    //defined leap second is greater than the offset, we are off by one and need to use\n    //the previous leap second.\n    var difference = JulianDate.secondsDifference(\n      leapSeconds[index].julianDate,\n      julianDate\n    );\n    if (difference > offset) {\n      index--;\n      offset = leapSeconds[index].offset;\n    }\n  }\n\n  JulianDate.addSeconds(julianDate, offset, julianDate);\n}\n\nfunction convertTaiToUtc(julianDate, result) {\n  binarySearchScratchLeapSecond.julianDate = julianDate;\n  var leapSeconds = JulianDate.leapSeconds;\n  var index = binarySearch(\n    leapSeconds,\n    binarySearchScratchLeapSecond,\n    compareLeapSecondDates\n  );\n  if (index < 0) {\n    index = ~index;\n  }\n\n  //All times before our first leap second get the first offset.\n  if (index === 0) {\n    return JulianDate.addSeconds(julianDate, -leapSeconds[0].offset, result);\n  }\n\n  //All times after our leap second get the last offset.\n  if (index >= leapSeconds.length) {\n    return JulianDate.addSeconds(\n      julianDate,\n      -leapSeconds[index - 1].offset,\n      result\n    );\n  }\n\n  //Compute the difference between the found leap second and the time we are converting.\n  var difference = JulianDate.secondsDifference(\n    leapSeconds[index].julianDate,\n    julianDate\n  );\n\n  if (difference === 0) {\n    //The date is in our leap second table.\n    return JulianDate.addSeconds(\n      julianDate,\n      -leapSeconds[index].offset,\n      result\n    );\n  }\n\n  if (difference <= 1.0) {\n    //The requested date is during the moment of a leap second, then we cannot convert to UTC\n    return undefined;\n  }\n\n  //The time is in between two leap seconds, index is the leap second after the date\n  //we're converting, so we subtract one to get the correct LeapSecond instance.\n  return JulianDate.addSeconds(\n    julianDate,\n    -leapSeconds[--index].offset,\n    result\n  );\n}\n\nfunction setComponents(wholeDays, secondsOfDay, julianDate) {\n  var extraDays = (secondsOfDay / TimeConstants.SECONDS_PER_DAY) | 0;\n  wholeDays += extraDays;\n  secondsOfDay -= TimeConstants.SECONDS_PER_DAY * extraDays;\n\n  if (secondsOfDay < 0) {\n    wholeDays--;\n    secondsOfDay += TimeConstants.SECONDS_PER_DAY;\n  }\n\n  julianDate.dayNumber = wholeDays;\n  julianDate.secondsOfDay = secondsOfDay;\n  return julianDate;\n}\n\nfunction computeJulianDateComponents(\n  year,\n  month,\n  day,\n  hour,\n  minute,\n  second,\n  millisecond\n) {\n  // Algorithm from page 604 of the Explanatory Supplement to the\n  // Astronomical Almanac (Seidelmann 1992).\n\n  var a = ((month - 14) / 12) | 0;\n  var b = year + 4800 + a;\n  var dayNumber =\n    (((1461 * b) / 4) | 0) +\n    (((367 * (month - 2 - 12 * a)) / 12) | 0) -\n    (((3 * (((b + 100) / 100) | 0)) / 4) | 0) +\n    day -\n    32075;\n\n  // JulianDates are noon-based\n  hour = hour - 12;\n  if (hour < 0) {\n    hour += 24;\n  }\n\n  var secondsOfDay =\n    second +\n    (hour * TimeConstants.SECONDS_PER_HOUR +\n      minute * TimeConstants.SECONDS_PER_MINUTE +\n      millisecond * TimeConstants.SECONDS_PER_MILLISECOND);\n\n  if (secondsOfDay >= 43200.0) {\n    dayNumber -= 1;\n  }\n\n  return [dayNumber, secondsOfDay];\n}\n\n//Regular expressions used for ISO8601 date parsing.\n//YYYY\nvar matchCalendarYear = /^(\\d{4})$/;\n//YYYY-MM (YYYYMM is invalid)\nvar matchCalendarMonth = /^(\\d{4})-(\\d{2})$/;\n//YYYY-DDD or YYYYDDD\nvar matchOrdinalDate = /^(\\d{4})-?(\\d{3})$/;\n//YYYY-Www or YYYYWww or YYYY-Www-D or YYYYWwwD\nvar matchWeekDate = /^(\\d{4})-?W(\\d{2})-?(\\d{1})?$/;\n//YYYY-MM-DD or YYYYMMDD\nvar matchCalendarDate = /^(\\d{4})-?(\\d{2})-?(\\d{2})$/;\n// Match utc offset\nvar utcOffset = /([Z+\\-])?(\\d{2})?:?(\\d{2})?$/;\n// Match hours HH or HH.xxxxx\nvar matchHours = /^(\\d{2})(\\.\\d+)?/.source + utcOffset.source;\n// Match hours/minutes HH:MM HHMM.xxxxx\nvar matchHoursMinutes = /^(\\d{2}):?(\\d{2})(\\.\\d+)?/.source + utcOffset.source;\n// Match hours/minutes HH:MM:SS HHMMSS.xxxxx\nvar matchHoursMinutesSeconds =\n  /^(\\d{2}):?(\\d{2}):?(\\d{2})(\\.\\d+)?/.source + utcOffset.source;\n\nvar iso8601ErrorMessage = \"Invalid ISO 8601 date.\";\n\n/**\n * Represents an astronomical Julian date, which is the number of days since noon on January 1, -4712 (4713 BC).\n * For increased precision, this class stores the whole number part of the date and the seconds\n * part of the date in separate components.  In order to be safe for arithmetic and represent\n * leap seconds, the date is always stored in the International Atomic Time standard\n * {@link TimeStandard.TAI}.\n * @alias JulianDate\n * @constructor\n *\n * @param {Number} [julianDayNumber=0.0] The Julian Day Number representing the number of whole days.  Fractional days will also be handled correctly.\n * @param {Number} [secondsOfDay=0.0] The number of seconds into the current Julian Day Number.  Fractional seconds, negative seconds and seconds greater than a day will be handled correctly.\n * @param {TimeStandard} [timeStandard=TimeStandard.UTC] The time standard in which the first two parameters are defined.\n */\nfunction JulianDate(julianDayNumber, secondsOfDay, timeStandard) {\n  /**\n   * Gets or sets the number of whole days.\n   * @type {Number}\n   */\n  this.dayNumber = undefined;\n\n  /**\n   * Gets or sets the number of seconds into the current day.\n   * @type {Number}\n   */\n  this.secondsOfDay = undefined;\n\n  julianDayNumber = defaultValue(julianDayNumber, 0.0);\n  secondsOfDay = defaultValue(secondsOfDay, 0.0);\n  timeStandard = defaultValue(timeStandard, TimeStandard.UTC);\n\n  //If julianDayNumber is fractional, make it an integer and add the number of seconds the fraction represented.\n  var wholeDays = julianDayNumber | 0;\n  secondsOfDay =\n    secondsOfDay +\n    (julianDayNumber - wholeDays) * TimeConstants.SECONDS_PER_DAY;\n\n  setComponents(wholeDays, secondsOfDay, this);\n\n  if (timeStandard === TimeStandard.UTC) {\n    convertUtcToTai(this);\n  }\n}\n\n/**\n * Creates a new instance from a GregorianDate.\n *\n * @param {GregorianDate} date A GregorianDate.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n *\n * @exception {DeveloperError} date must be a valid GregorianDate.\n */\nJulianDate.fromGregorianDate = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!(date instanceof GregorianDate)) {\n    throw new DeveloperError(\"date must be a valid GregorianDate.\");\n  }\n  //>>includeEnd('debug');\n\n  var components = computeJulianDateComponents(\n    date.year,\n    date.month,\n    date.day,\n    date.hour,\n    date.minute,\n    date.second,\n    date.millisecond\n  );\n  if (!defined(result)) {\n    return new JulianDate(components[0], components[1], TimeStandard.UTC);\n  }\n  setComponents(components[0], components[1], result);\n  convertUtcToTai(result);\n  return result;\n};\n\n/**\n * Creates a new instance from a JavaScript Date.\n *\n * @param {Date} date A JavaScript Date.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n *\n * @exception {DeveloperError} date must be a valid JavaScript Date.\n */\nJulianDate.fromDate = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!(date instanceof Date) || isNaN(date.getTime())) {\n    throw new DeveloperError(\"date must be a valid JavaScript Date.\");\n  }\n  //>>includeEnd('debug');\n\n  var components = computeJulianDateComponents(\n    date.getUTCFullYear(),\n    date.getUTCMonth() + 1,\n    date.getUTCDate(),\n    date.getUTCHours(),\n    date.getUTCMinutes(),\n    date.getUTCSeconds(),\n    date.getUTCMilliseconds()\n  );\n  if (!defined(result)) {\n    return new JulianDate(components[0], components[1], TimeStandard.UTC);\n  }\n  setComponents(components[0], components[1], result);\n  convertUtcToTai(result);\n  return result;\n};\n\n/**\n * Creates a new instance from a from an {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} date.\n * This method is superior to <code>Date.parse</code> because it will handle all valid formats defined by the ISO 8601\n * specification, including leap seconds and sub-millisecond times, which discarded by most JavaScript implementations.\n *\n * @param {String} iso8601String An ISO 8601 date.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n *\n * @exception {DeveloperError} Invalid ISO 8601 date.\n */\nJulianDate.fromIso8601 = function (iso8601String, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof iso8601String !== \"string\") {\n    throw new DeveloperError(iso8601ErrorMessage);\n  }\n  //>>includeEnd('debug');\n\n  //Comma and decimal point both indicate a fractional number according to ISO 8601,\n  //start out by blanket replacing , with . which is the only valid such symbol in JS.\n  iso8601String = iso8601String.replace(\",\", \".\");\n\n  //Split the string into its date and time components, denoted by a mandatory T\n  var tokens = iso8601String.split(\"T\");\n  var year;\n  var month = 1;\n  var day = 1;\n  var hour = 0;\n  var minute = 0;\n  var second = 0;\n  var millisecond = 0;\n\n  //Lacking a time is okay, but a missing date is illegal.\n  var date = tokens[0];\n  var time = tokens[1];\n  var tmp;\n  var inLeapYear;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(iso8601ErrorMessage);\n  }\n\n  var dashCount;\n  //>>includeEnd('debug');\n\n  //First match the date against possible regular expressions.\n  tokens = date.match(matchCalendarDate);\n  if (tokens !== null) {\n    //>>includeStart('debug', pragmas.debug);\n    dashCount = date.split(\"-\").length - 1;\n    if (dashCount > 0 && dashCount !== 2) {\n      throw new DeveloperError(iso8601ErrorMessage);\n    }\n    //>>includeEnd('debug');\n    year = +tokens[1];\n    month = +tokens[2];\n    day = +tokens[3];\n  } else {\n    tokens = date.match(matchCalendarMonth);\n    if (tokens !== null) {\n      year = +tokens[1];\n      month = +tokens[2];\n    } else {\n      tokens = date.match(matchCalendarYear);\n      if (tokens !== null) {\n        year = +tokens[1];\n      } else {\n        //Not a year/month/day so it must be an ordinal date.\n        var dayOfYear;\n        tokens = date.match(matchOrdinalDate);\n        if (tokens !== null) {\n          year = +tokens[1];\n          dayOfYear = +tokens[2];\n          inLeapYear = isLeapYear(year);\n\n          //This validation is only applicable for this format.\n          //>>includeStart('debug', pragmas.debug);\n          if (\n            dayOfYear < 1 ||\n            (inLeapYear && dayOfYear > 366) ||\n            (!inLeapYear && dayOfYear > 365)\n          ) {\n            throw new DeveloperError(iso8601ErrorMessage);\n          }\n          //>>includeEnd('debug')\n        } else {\n          tokens = date.match(matchWeekDate);\n          if (tokens !== null) {\n            //ISO week date to ordinal date from\n            //http://en.wikipedia.org/w/index.php?title=ISO_week_date&oldid=474176775\n            year = +tokens[1];\n            var weekNumber = +tokens[2];\n            var dayOfWeek = +tokens[3] || 0;\n\n            //>>includeStart('debug', pragmas.debug);\n            dashCount = date.split(\"-\").length - 1;\n            if (\n              dashCount > 0 &&\n              ((!defined(tokens[3]) && dashCount !== 1) ||\n                (defined(tokens[3]) && dashCount !== 2))\n            ) {\n              throw new DeveloperError(iso8601ErrorMessage);\n            }\n            //>>includeEnd('debug')\n\n            var january4 = new Date(Date.UTC(year, 0, 4));\n            dayOfYear = weekNumber * 7 + dayOfWeek - january4.getUTCDay() - 3;\n          } else {\n            //None of our regular expressions succeeded in parsing the date properly.\n            //>>includeStart('debug', pragmas.debug);\n            throw new DeveloperError(iso8601ErrorMessage);\n            //>>includeEnd('debug')\n          }\n        }\n        //Split an ordinal date into month/day.\n        tmp = new Date(Date.UTC(year, 0, 1));\n        tmp.setUTCDate(dayOfYear);\n        month = tmp.getUTCMonth() + 1;\n        day = tmp.getUTCDate();\n      }\n    }\n  }\n\n  //Now that we have all of the date components, validate them to make sure nothing is out of range.\n  inLeapYear = isLeapYear(year);\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    month < 1 ||\n    month > 12 ||\n    day < 1 ||\n    ((month !== 2 || !inLeapYear) && day > daysInMonth[month - 1]) ||\n    (inLeapYear && month === 2 && day > daysInLeapFeburary)\n  ) {\n    throw new DeveloperError(iso8601ErrorMessage);\n  }\n  //>>includeEnd('debug')\n\n  //Now move onto the time string, which is much simpler.\n  //If no time is specified, it is considered the beginning of the day, UTC to match Javascript's implementation.\n  var offsetIndex;\n  if (defined(time)) {\n    tokens = time.match(matchHoursMinutesSeconds);\n    if (tokens !== null) {\n      //>>includeStart('debug', pragmas.debug);\n      dashCount = time.split(\":\").length - 1;\n      if (dashCount > 0 && dashCount !== 2 && dashCount !== 3) {\n        throw new DeveloperError(iso8601ErrorMessage);\n      }\n      //>>includeEnd('debug')\n\n      hour = +tokens[1];\n      minute = +tokens[2];\n      second = +tokens[3];\n      millisecond = +(tokens[4] || 0) * 1000.0;\n      offsetIndex = 5;\n    } else {\n      tokens = time.match(matchHoursMinutes);\n      if (tokens !== null) {\n        //>>includeStart('debug', pragmas.debug);\n        dashCount = time.split(\":\").length - 1;\n        if (dashCount > 2) {\n          throw new DeveloperError(iso8601ErrorMessage);\n        }\n        //>>includeEnd('debug')\n\n        hour = +tokens[1];\n        minute = +tokens[2];\n        second = +(tokens[3] || 0) * 60.0;\n        offsetIndex = 4;\n      } else {\n        tokens = time.match(matchHours);\n        if (tokens !== null) {\n          hour = +tokens[1];\n          minute = +(tokens[2] || 0) * 60.0;\n          offsetIndex = 3;\n        } else {\n          //>>includeStart('debug', pragmas.debug);\n          throw new DeveloperError(iso8601ErrorMessage);\n          //>>includeEnd('debug')\n        }\n      }\n    }\n\n    //Validate that all values are in proper range.  Minutes and hours have special cases at 60 and 24.\n    //>>includeStart('debug', pragmas.debug);\n    if (\n      minute >= 60 ||\n      second >= 61 ||\n      hour > 24 ||\n      (hour === 24 && (minute > 0 || second > 0 || millisecond > 0))\n    ) {\n      throw new DeveloperError(iso8601ErrorMessage);\n    }\n    //>>includeEnd('debug');\n\n    //Check the UTC offset value, if no value exists, use local time\n    //a Z indicates UTC, + or - are offsets.\n    var offset = tokens[offsetIndex];\n    var offsetHours = +tokens[offsetIndex + 1];\n    var offsetMinutes = +(tokens[offsetIndex + 2] || 0);\n    switch (offset) {\n      case \"+\":\n        hour = hour - offsetHours;\n        minute = minute - offsetMinutes;\n        break;\n      case \"-\":\n        hour = hour + offsetHours;\n        minute = minute + offsetMinutes;\n        break;\n      case \"Z\":\n        break;\n      default:\n        minute =\n          minute +\n          new Date(\n            Date.UTC(year, month - 1, day, hour, minute)\n          ).getTimezoneOffset();\n        break;\n    }\n  }\n\n  //ISO8601 denotes a leap second by any time having a seconds component of 60 seconds.\n  //If that's the case, we need to temporarily subtract a second in order to build a UTC date.\n  //Then we add it back in after converting to TAI.\n  var isLeapSecond = second === 60;\n  if (isLeapSecond) {\n    second--;\n  }\n\n  //Even if we successfully parsed the string into its components, after applying UTC offset or\n  //special cases like 24:00:00 denoting midnight, we need to normalize the data appropriately.\n\n  //milliseconds can never be greater than 1000, and seconds can't be above 60, so we start with minutes\n  while (minute >= 60) {\n    minute -= 60;\n    hour++;\n  }\n\n  while (hour >= 24) {\n    hour -= 24;\n    day++;\n  }\n\n  tmp = inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];\n  while (day > tmp) {\n    day -= tmp;\n    month++;\n\n    if (month > 12) {\n      month -= 12;\n      year++;\n    }\n\n    tmp =\n      inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];\n  }\n\n  //If UTC offset is at the beginning/end of the day, minutes can be negative.\n  while (minute < 0) {\n    minute += 60;\n    hour--;\n  }\n\n  while (hour < 0) {\n    hour += 24;\n    day--;\n  }\n\n  while (day < 1) {\n    month--;\n    if (month < 1) {\n      month += 12;\n      year--;\n    }\n\n    tmp =\n      inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];\n    day += tmp;\n  }\n\n  //Now create the JulianDate components from the Gregorian date and actually create our instance.\n  var components = computeJulianDateComponents(\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond\n  );\n\n  if (!defined(result)) {\n    result = new JulianDate(components[0], components[1], TimeStandard.UTC);\n  } else {\n    setComponents(components[0], components[1], result);\n    convertUtcToTai(result);\n  }\n\n  //If we were on a leap second, add it back.\n  if (isLeapSecond) {\n    JulianDate.addSeconds(result, 1, result);\n  }\n\n  return result;\n};\n\n/**\n * Creates a new instance that represents the current system time.\n * This is equivalent to calling <code>JulianDate.fromDate(new Date());</code>.\n *\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n */\nJulianDate.now = function (result) {\n  return JulianDate.fromDate(new Date(), result);\n};\n\nvar toGregorianDateScratch = new JulianDate(0, 0, TimeStandard.TAI);\n\n/**\n * Creates a {@link GregorianDate} from the provided instance.\n *\n * @param {JulianDate} julianDate The date to be converted.\n * @param {GregorianDate} [result] An existing instance to use for the result.\n * @returns {GregorianDate} The modified result parameter or a new instance if none was provided.\n */\nJulianDate.toGregorianDate = function (julianDate, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var isLeapSecond = false;\n  var thisUtc = convertTaiToUtc(julianDate, toGregorianDateScratch);\n  if (!defined(thisUtc)) {\n    //Conversion to UTC will fail if we are during a leap second.\n    //If that's the case, subtract a second and convert again.\n    //JavaScript doesn't support leap seconds, so this results in second 59 being repeated twice.\n    JulianDate.addSeconds(julianDate, -1, toGregorianDateScratch);\n    thisUtc = convertTaiToUtc(toGregorianDateScratch, toGregorianDateScratch);\n    isLeapSecond = true;\n  }\n\n  var julianDayNumber = thisUtc.dayNumber;\n  var secondsOfDay = thisUtc.secondsOfDay;\n\n  if (secondsOfDay >= 43200.0) {\n    julianDayNumber += 1;\n  }\n\n  // Algorithm from page 604 of the Explanatory Supplement to the\n  // Astronomical Almanac (Seidelmann 1992).\n  var L = (julianDayNumber + 68569) | 0;\n  var N = ((4 * L) / 146097) | 0;\n  L = (L - (((146097 * N + 3) / 4) | 0)) | 0;\n  var I = ((4000 * (L + 1)) / 1461001) | 0;\n  L = (L - (((1461 * I) / 4) | 0) + 31) | 0;\n  var J = ((80 * L) / 2447) | 0;\n  var day = (L - (((2447 * J) / 80) | 0)) | 0;\n  L = (J / 11) | 0;\n  var month = (J + 2 - 12 * L) | 0;\n  var year = (100 * (N - 49) + I + L) | 0;\n\n  var hour = (secondsOfDay / TimeConstants.SECONDS_PER_HOUR) | 0;\n  var remainingSeconds = secondsOfDay - hour * TimeConstants.SECONDS_PER_HOUR;\n  var minute = (remainingSeconds / TimeConstants.SECONDS_PER_MINUTE) | 0;\n  remainingSeconds =\n    remainingSeconds - minute * TimeConstants.SECONDS_PER_MINUTE;\n  var second = remainingSeconds | 0;\n  var millisecond =\n    (remainingSeconds - second) / TimeConstants.SECONDS_PER_MILLISECOND;\n\n  // JulianDates are noon-based\n  hour += 12;\n  if (hour > 23) {\n    hour -= 24;\n  }\n\n  //If we were on a leap second, add it back.\n  if (isLeapSecond) {\n    second += 1;\n  }\n\n  if (!defined(result)) {\n    return new GregorianDate(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      isLeapSecond\n    );\n  }\n\n  result.year = year;\n  result.month = month;\n  result.day = day;\n  result.hour = hour;\n  result.minute = minute;\n  result.second = second;\n  result.millisecond = millisecond;\n  result.isLeapSecond = isLeapSecond;\n  return result;\n};\n\n/**\n * Creates a JavaScript Date from the provided instance.\n * Since JavaScript dates are only accurate to the nearest millisecond and\n * cannot represent a leap second, consider using {@link JulianDate.toGregorianDate} instead.\n * If the provided JulianDate is during a leap second, the previous second is used.\n *\n * @param {JulianDate} julianDate The date to be converted.\n * @returns {Date} A new instance representing the provided date.\n */\nJulianDate.toDate = function (julianDate) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var gDate = JulianDate.toGregorianDate(julianDate, gregorianDateScratch);\n  var second = gDate.second;\n  if (gDate.isLeapSecond) {\n    second -= 1;\n  }\n  return new Date(\n    Date.UTC(\n      gDate.year,\n      gDate.month - 1,\n      gDate.day,\n      gDate.hour,\n      gDate.minute,\n      second,\n      gDate.millisecond\n    )\n  );\n};\n\n/**\n * Creates an ISO8601 representation of the provided date.\n *\n * @param {JulianDate} julianDate The date to be converted.\n * @param {Number} [precision] The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.\n * @returns {String} The ISO8601 representation of the provided date.\n */\nJulianDate.toIso8601 = function (julianDate, precision) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var gDate = JulianDate.toGregorianDate(julianDate, gregorianDateScratch);\n  var year = gDate.year;\n  var month = gDate.month;\n  var day = gDate.day;\n  var hour = gDate.hour;\n  var minute = gDate.minute;\n  var second = gDate.second;\n  var millisecond = gDate.millisecond;\n\n  // special case - Iso8601.MAXIMUM_VALUE produces a string which we can't parse unless we adjust.\n  // 10000-01-01T00:00:00 is the same instant as 9999-12-31T24:00:00\n  if (\n    year === 10000 &&\n    month === 1 &&\n    day === 1 &&\n    hour === 0 &&\n    minute === 0 &&\n    second === 0 &&\n    millisecond === 0\n  ) {\n    year = 9999;\n    month = 12;\n    day = 31;\n    hour = 24;\n  }\n\n  var millisecondStr;\n\n  if (!defined(precision) && millisecond !== 0) {\n    //Forces milliseconds into a number with at least 3 digits to whatever the default toString() precision is.\n    millisecondStr = (millisecond * 0.01).toString().replace(\".\", \"\");\n    return sprintf(\n      \"%04d-%02d-%02dT%02d:%02d:%02d.%sZ\",\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecondStr\n    );\n  }\n\n  //Precision is either 0 or milliseconds is 0 with undefined precision, in either case, leave off milliseconds entirely\n  if (!defined(precision) || precision === 0) {\n    return sprintf(\n      \"%04d-%02d-%02dT%02d:%02d:%02dZ\",\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second\n    );\n  }\n\n  //Forces milliseconds into a number with at least 3 digits to whatever the specified precision is.\n  millisecondStr = (millisecond * 0.01)\n    .toFixed(precision)\n    .replace(\".\", \"\")\n    .slice(0, precision);\n  return sprintf(\n    \"%04d-%02d-%02dT%02d:%02d:%02d.%sZ\",\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecondStr\n  );\n};\n\n/**\n * Duplicates a JulianDate instance.\n *\n * @param {JulianDate} julianDate The date to duplicate.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided. Returns undefined if julianDate is undefined.\n */\nJulianDate.clone = function (julianDate, result) {\n  if (!defined(julianDate)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new JulianDate(\n      julianDate.dayNumber,\n      julianDate.secondsOfDay,\n      TimeStandard.TAI\n    );\n  }\n  result.dayNumber = julianDate.dayNumber;\n  result.secondsOfDay = julianDate.secondsOfDay;\n  return result;\n};\n\n/**\n * Compares two instances.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Number} A negative value if left is less than right, a positive value if left is greater than right, or zero if left and right are equal.\n */\nJulianDate.compare = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"left is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"right is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var julianDayNumberDifference = left.dayNumber - right.dayNumber;\n  if (julianDayNumberDifference !== 0) {\n    return julianDayNumberDifference;\n  }\n  return left.secondsOfDay - right.secondsOfDay;\n};\n\n/**\n * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {JulianDate} [left] The first instance.\n * @param {JulianDate} [right] The second instance.\n * @returns {Boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.\n */\nJulianDate.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.dayNumber === right.dayNumber &&\n      left.secondsOfDay === right.secondsOfDay)\n  );\n};\n\n/**\n * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of\n * each other.  That is, in order for the dates to be considered equal (and for\n * this function to return <code>true</code>), the absolute value of the difference between them, in\n * seconds, must be less than <code>epsilon</code>.\n *\n * @param {JulianDate} [left] The first instance.\n * @param {JulianDate} [right] The second instance.\n * @param {Number} epsilon The maximum number of seconds that should separate the two instances.\n * @returns {Boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.\n */\nJulianDate.equalsEpsilon = function (left, right, epsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(epsilon)) {\n    throw new DeveloperError(\"epsilon is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(JulianDate.secondsDifference(left, right)) <= epsilon)\n  );\n};\n\n/**\n * Computes the total number of whole and fractional days represented by the provided instance.\n *\n * @param {JulianDate} julianDate The date.\n * @returns {Number} The Julian date as single floating point number.\n */\nJulianDate.totalDays = function (julianDate) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  //>>includeEnd('debug');\n  return (\n    julianDate.dayNumber +\n    julianDate.secondsOfDay / TimeConstants.SECONDS_PER_DAY\n  );\n};\n\n/**\n * Computes the difference in seconds between the provided instance.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Number} The difference, in seconds, when subtracting <code>right</code> from <code>left</code>.\n */\nJulianDate.secondsDifference = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"left is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"right is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var dayDifference =\n    (left.dayNumber - right.dayNumber) * TimeConstants.SECONDS_PER_DAY;\n  return dayDifference + (left.secondsOfDay - right.secondsOfDay);\n};\n\n/**\n * Computes the difference in days between the provided instance.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Number} The difference, in days, when subtracting <code>right</code> from <code>left</code>.\n */\nJulianDate.daysDifference = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"left is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"right is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var dayDifference = left.dayNumber - right.dayNumber;\n  var secondDifference =\n    (left.secondsOfDay - right.secondsOfDay) / TimeConstants.SECONDS_PER_DAY;\n  return dayDifference + secondDifference;\n};\n\n/**\n * Computes the number of seconds the provided instance is ahead of UTC.\n *\n * @param {JulianDate} julianDate The date.\n * @returns {Number} The number of seconds the provided instance is ahead of UTC\n */\nJulianDate.computeTaiMinusUtc = function (julianDate) {\n  binarySearchScratchLeapSecond.julianDate = julianDate;\n  var leapSeconds = JulianDate.leapSeconds;\n  var index = binarySearch(\n    leapSeconds,\n    binarySearchScratchLeapSecond,\n    compareLeapSecondDates\n  );\n  if (index < 0) {\n    index = ~index;\n    --index;\n    if (index < 0) {\n      index = 0;\n    }\n  }\n  return leapSeconds[index].offset;\n};\n\n/**\n * Adds the provided number of seconds to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {Number} seconds The number of seconds to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addSeconds = function (julianDate, seconds, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  if (!defined(seconds)) {\n    throw new DeveloperError(\"seconds is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return setComponents(\n    julianDate.dayNumber,\n    julianDate.secondsOfDay + seconds,\n    result\n  );\n};\n\n/**\n * Adds the provided number of minutes to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {Number} minutes The number of minutes to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addMinutes = function (julianDate, minutes, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  if (!defined(minutes)) {\n    throw new DeveloperError(\"minutes is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var newSecondsOfDay =\n    julianDate.secondsOfDay + minutes * TimeConstants.SECONDS_PER_MINUTE;\n  return setComponents(julianDate.dayNumber, newSecondsOfDay, result);\n};\n\n/**\n * Adds the provided number of hours to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {Number} hours The number of hours to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addHours = function (julianDate, hours, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  if (!defined(hours)) {\n    throw new DeveloperError(\"hours is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var newSecondsOfDay =\n    julianDate.secondsOfDay + hours * TimeConstants.SECONDS_PER_HOUR;\n  return setComponents(julianDate.dayNumber, newSecondsOfDay, result);\n};\n\n/**\n * Adds the provided number of days to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {Number} days The number of days to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addDays = function (julianDate, days, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  if (!defined(days)) {\n    throw new DeveloperError(\"days is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var newJulianDayNumber = julianDate.dayNumber + days;\n  return setComponents(newJulianDayNumber, julianDate.secondsOfDay, result);\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Boolean} <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.lessThan = function (left, right) {\n  return JulianDate.compare(left, right) < 0;\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Boolean} <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.lessThanOrEquals = function (left, right) {\n  return JulianDate.compare(left, right) <= 0;\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Boolean} <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.greaterThan = function (left, right) {\n  return JulianDate.compare(left, right) > 0;\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Boolean} <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.greaterThanOrEquals = function (left, right) {\n  return JulianDate.compare(left, right) >= 0;\n};\n\n/**\n * Duplicates this instance.\n *\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n */\nJulianDate.prototype.clone = function (result) {\n  return JulianDate.clone(this, result);\n};\n\n/**\n * Compares this and the provided instance and returns <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {JulianDate} [right] The second instance.\n * @returns {Boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.\n */\nJulianDate.prototype.equals = function (right) {\n  return JulianDate.equals(this, right);\n};\n\n/**\n * Compares this and the provided instance and returns <code>true</code> if they are within <code>epsilon</code> seconds of\n * each other.  That is, in order for the dates to be considered equal (and for\n * this function to return <code>true</code>), the absolute value of the difference between them, in\n * seconds, must be less than <code>epsilon</code>.\n *\n * @param {JulianDate} [right] The second instance.\n * @param {Number} epsilon The maximum number of seconds that should separate the two instances.\n * @returns {Boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.\n */\nJulianDate.prototype.equalsEpsilon = function (right, epsilon) {\n  return JulianDate.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this date in ISO8601 format.\n *\n * @returns {String} A string representing this date in ISO8601 format.\n */\nJulianDate.prototype.toString = function () {\n  return JulianDate.toIso8601(this);\n};\n\n/**\n * Gets or sets the list of leap seconds used throughout Cesium.\n * @memberof JulianDate\n * @type {LeapSecond[]}\n */\nJulianDate.leapSeconds = [\n  new LeapSecond(new JulianDate(2441317, 43210.0, TimeStandard.TAI), 10), // January 1, 1972 00:00:00 UTC\n  new LeapSecond(new JulianDate(2441499, 43211.0, TimeStandard.TAI), 11), // July 1, 1972 00:00:00 UTC\n  new LeapSecond(new JulianDate(2441683, 43212.0, TimeStandard.TAI), 12), // January 1, 1973 00:00:00 UTC\n  new LeapSecond(new JulianDate(2442048, 43213.0, TimeStandard.TAI), 13), // January 1, 1974 00:00:00 UTC\n  new LeapSecond(new JulianDate(2442413, 43214.0, TimeStandard.TAI), 14), // January 1, 1975 00:00:00 UTC\n  new LeapSecond(new JulianDate(2442778, 43215.0, TimeStandard.TAI), 15), // January 1, 1976 00:00:00 UTC\n  new LeapSecond(new JulianDate(2443144, 43216.0, TimeStandard.TAI), 16), // January 1, 1977 00:00:00 UTC\n  new LeapSecond(new JulianDate(2443509, 43217.0, TimeStandard.TAI), 17), // January 1, 1978 00:00:00 UTC\n  new LeapSecond(new JulianDate(2443874, 43218.0, TimeStandard.TAI), 18), // January 1, 1979 00:00:00 UTC\n  new LeapSecond(new JulianDate(2444239, 43219.0, TimeStandard.TAI), 19), // January 1, 1980 00:00:00 UTC\n  new LeapSecond(new JulianDate(2444786, 43220.0, TimeStandard.TAI), 20), // July 1, 1981 00:00:00 UTC\n  new LeapSecond(new JulianDate(2445151, 43221.0, TimeStandard.TAI), 21), // July 1, 1982 00:00:00 UTC\n  new LeapSecond(new JulianDate(2445516, 43222.0, TimeStandard.TAI), 22), // July 1, 1983 00:00:00 UTC\n  new LeapSecond(new JulianDate(2446247, 43223.0, TimeStandard.TAI), 23), // July 1, 1985 00:00:00 UTC\n  new LeapSecond(new JulianDate(2447161, 43224.0, TimeStandard.TAI), 24), // January 1, 1988 00:00:00 UTC\n  new LeapSecond(new JulianDate(2447892, 43225.0, TimeStandard.TAI), 25), // January 1, 1990 00:00:00 UTC\n  new LeapSecond(new JulianDate(2448257, 43226.0, TimeStandard.TAI), 26), // January 1, 1991 00:00:00 UTC\n  new LeapSecond(new JulianDate(2448804, 43227.0, TimeStandard.TAI), 27), // July 1, 1992 00:00:00 UTC\n  new LeapSecond(new JulianDate(2449169, 43228.0, TimeStandard.TAI), 28), // July 1, 1993 00:00:00 UTC\n  new LeapSecond(new JulianDate(2449534, 43229.0, TimeStandard.TAI), 29), // July 1, 1994 00:00:00 UTC\n  new LeapSecond(new JulianDate(2450083, 43230.0, TimeStandard.TAI), 30), // January 1, 1996 00:00:00 UTC\n  new LeapSecond(new JulianDate(2450630, 43231.0, TimeStandard.TAI), 31), // July 1, 1997 00:00:00 UTC\n  new LeapSecond(new JulianDate(2451179, 43232.0, TimeStandard.TAI), 32), // January 1, 1999 00:00:00 UTC\n  new LeapSecond(new JulianDate(2453736, 43233.0, TimeStandard.TAI), 33), // January 1, 2006 00:00:00 UTC\n  new LeapSecond(new JulianDate(2454832, 43234.0, TimeStandard.TAI), 34), // January 1, 2009 00:00:00 UTC\n  new LeapSecond(new JulianDate(2456109, 43235.0, TimeStandard.TAI), 35), // July 1, 2012 00:00:00 UTC\n  new LeapSecond(new JulianDate(2457204, 43236.0, TimeStandard.TAI), 36), // July 1, 2015 00:00:00 UTC\n  new LeapSecond(new JulianDate(2457754, 43237.0, TimeStandard.TAI), 37), // January 1, 2017 00:00:00 UTC\n];\nexport default JulianDate;\n"]},"metadata":{},"sourceType":"module"}