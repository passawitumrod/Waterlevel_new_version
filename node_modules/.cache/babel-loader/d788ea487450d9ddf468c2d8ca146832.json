{"ast":null,"code":"import defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Spline from \"./Spline.js\";\n\nfunction createEvaluateFunction(spline) {\n  var points = spline.points;\n  var times = spline.times; // use slerp interpolation\n\n  return function (time, result) {\n    if (!defined(result)) {\n      result = new Quaternion();\n    }\n\n    var i = spline._lastTimeIndex = spline.findTimeInterval(time, spline._lastTimeIndex);\n    var u = (time - times[i]) / (times[i + 1] - times[i]);\n    var q0 = points[i];\n    var q1 = points[i + 1];\n    return Quaternion.fastSlerp(q0, q1, u, result);\n  };\n}\n/**\n * A spline that uses spherical linear (slerp) interpolation to create a quaternion curve.\n * The generated curve is in the class C<sup>1</sup>.\n *\n * @alias QuaternionSpline\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {Quaternion[]} options.points The array of {@link Quaternion} control points.\n *\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n *\n * @see HermiteSpline\n * @see CatmullRomSpline\n * @see LinearSpline\n * @see WeightSpline\n */\n\n\nfunction QuaternionSpline(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var points = options.points;\n  var times = options.times; //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(points) || !defined(times)) {\n    throw new DeveloperError(\"points and times are required.\");\n  }\n\n  if (points.length < 2) {\n    throw new DeveloperError(\"points.length must be greater than or equal to 2.\");\n  }\n\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  } //>>includeEnd('debug');\n\n\n  this._times = times;\n  this._points = points;\n  this._evaluateFunction = createEvaluateFunction(this);\n  this._lastTimeIndex = 0;\n}\n\nObject.defineProperties(QuaternionSpline.prototype, {\n  /**\n   * An array of times for the control points.\n   *\n   * @memberof QuaternionSpline.prototype\n   *\n   * @type {Number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    }\n  },\n\n  /**\n   * An array of {@link Quaternion} control points.\n   *\n   * @memberof QuaternionSpline.prototype\n   *\n   * @type {Quaternion[]}\n   * @readonly\n   */\n  points: {\n    get: function () {\n      return this._points;\n    }\n  }\n});\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {Number} time The time.\n * @returns {Number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\n\nQuaternionSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, wrapped around to the updated animation.\n */\n\nQuaternionSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, clamped to the animation period.\n */\n\nQuaternionSpline.prototype.clampTime = Spline.prototype.clampTime;\n/**\n * Evaluates the curve at a given time.\n *\n * @param {Number} time The time at which to evaluate the curve.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\n\nQuaternionSpline.prototype.evaluate = function (time, result) {\n  return this._evaluateFunction(time, result);\n};\n\nexport default QuaternionSpline;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/QuaternionSpline.js"],"names":["defaultValue","defined","DeveloperError","Quaternion","Spline","createEvaluateFunction","spline","points","times","time","result","i","_lastTimeIndex","findTimeInterval","u","q0","q1","fastSlerp","QuaternionSpline","options","EMPTY_OBJECT","length","_times","_points","_evaluateFunction","Object","defineProperties","prototype","get","wrapTime","clampTime","evaluate"],"mappings":"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","sourcesContent":["import defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Spline from \"./Spline.js\";\n\nfunction createEvaluateFunction(spline) {\n  var points = spline.points;\n  var times = spline.times;\n\n  // use slerp interpolation\n  return function (time, result) {\n    if (!defined(result)) {\n      result = new Quaternion();\n    }\n    var i = (spline._lastTimeIndex = spline.findTimeInterval(\n      time,\n      spline._lastTimeIndex\n    ));\n    var u = (time - times[i]) / (times[i + 1] - times[i]);\n\n    var q0 = points[i];\n    var q1 = points[i + 1];\n\n    return Quaternion.fastSlerp(q0, q1, u, result);\n  };\n}\n\n/**\n * A spline that uses spherical linear (slerp) interpolation to create a quaternion curve.\n * The generated curve is in the class C<sup>1</sup>.\n *\n * @alias QuaternionSpline\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {Quaternion[]} options.points The array of {@link Quaternion} control points.\n *\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n *\n * @see HermiteSpline\n * @see CatmullRomSpline\n * @see LinearSpline\n * @see WeightSpline\n */\nfunction QuaternionSpline(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var points = options.points;\n  var times = options.times;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(points) || !defined(times)) {\n    throw new DeveloperError(\"points and times are required.\");\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\n      \"points.length must be greater than or equal to 2.\"\n    );\n  }\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n  //>>includeEnd('debug');\n\n  this._times = times;\n  this._points = points;\n\n  this._evaluateFunction = createEvaluateFunction(this);\n  this._lastTimeIndex = 0;\n}\n\nObject.defineProperties(QuaternionSpline.prototype, {\n  /**\n   * An array of times for the control points.\n   *\n   * @memberof QuaternionSpline.prototype\n   *\n   * @type {Number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    },\n  },\n\n  /**\n   * An array of {@link Quaternion} control points.\n   *\n   * @memberof QuaternionSpline.prototype\n   *\n   * @type {Quaternion[]}\n   * @readonly\n   */\n  points: {\n    get: function () {\n      return this._points;\n    },\n  },\n});\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {Number} time The time.\n * @returns {Number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nQuaternionSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, wrapped around to the updated animation.\n */\nQuaternionSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, clamped to the animation period.\n */\nQuaternionSpline.prototype.clampTime = Spline.prototype.clampTime;\n\n/**\n * Evaluates the curve at a given time.\n *\n * @param {Number} time The time at which to evaluate the curve.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nQuaternionSpline.prototype.evaluate = function (time, result) {\n  return this._evaluateFunction(time, result);\n};\nexport default QuaternionSpline;\n"]},"metadata":{},"sourceType":"module"}