{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport EllipsoidGeometry from \"../Core/EllipsoidGeometry.js\";\nimport EllipsoidOutlineGeometry from \"../Core/EllipsoidOutlineGeometry.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"../Core/GeometryOffsetAttribute.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport Primitive from \"../Scene/Primitive.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport DynamicGeometryUpdater from \"./DynamicGeometryUpdater.js\";\nimport GeometryUpdater from \"./GeometryUpdater.js\";\nimport heightReferenceOnEntityPropertyChanged from \"./heightReferenceOnEntityPropertyChanged.js\";\nimport MaterialProperty from \"./MaterialProperty.js\";\nimport Property from \"./Property.js\";\nvar defaultMaterial = new ColorMaterialProperty(Color.WHITE);\nvar defaultOffset = Cartesian3.ZERO;\nvar offsetScratch = new Cartesian3();\nvar radiiScratch = new Cartesian3();\nvar innerRadiiScratch = new Cartesian3();\nvar scratchColor = new Color();\nvar unitSphere = new Cartesian3(1, 1, 1);\n\nfunction EllipsoidGeometryOptions(entity) {\n  this.id = entity;\n  this.vertexFormat = undefined;\n  this.radii = undefined;\n  this.innerRadii = undefined;\n  this.minimumClock = undefined;\n  this.maximumClock = undefined;\n  this.minimumCone = undefined;\n  this.maximumCone = undefined;\n  this.stackPartitions = undefined;\n  this.slicePartitions = undefined;\n  this.subdivisions = undefined;\n  this.offsetAttribute = undefined;\n}\n/**\n * A {@link GeometryUpdater} for ellipsoids.\n * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n * @alias EllipsoidGeometryUpdater\n * @constructor\n *\n * @param {Entity} entity The entity containing the geometry to be visualized.\n * @param {Scene} scene The scene where visualization is taking place.\n */\n\n\nfunction EllipsoidGeometryUpdater(entity, scene) {\n  GeometryUpdater.call(this, {\n    entity: entity,\n    scene: scene,\n    geometryOptions: new EllipsoidGeometryOptions(entity),\n    geometryPropertyName: \"ellipsoid\",\n    observedPropertyNames: [\"availability\", \"position\", \"orientation\", \"ellipsoid\"]\n  });\n\n  this._onEntityPropertyChanged(entity, \"ellipsoid\", entity.ellipsoid, undefined);\n}\n\nif (defined(Object.create)) {\n  EllipsoidGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n  EllipsoidGeometryUpdater.prototype.constructor = EllipsoidGeometryUpdater;\n}\n\nObject.defineProperties(EllipsoidGeometryUpdater.prototype, {\n  /**\n   * Gets the terrain offset property\n   * @type {TerrainOffsetProperty}\n   * @memberof EllipsoidGeometryUpdater.prototype\n   * @readonly\n   */\n  terrainOffsetProperty: {\n    get: function get() {\n      return this._terrainOffsetProperty;\n    }\n  }\n});\n/**\n * Creates the geometry instance which represents the fill of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @param {Boolean} [skipModelMatrix=false] Whether to compute a model matrix for the geometry instance\n * @param {Matrix4} [modelMatrixResult] Used to store the result of the model matrix calculation\n * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent a filled geometry.\n */\n\nEllipsoidGeometryUpdater.prototype.createFillGeometryInstance = function (time, skipModelMatrix, modelMatrixResult) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time); //>>includeEnd('debug');\n\n  var entity = this._entity;\n  var isAvailable = entity.isAvailable(time);\n  var color;\n  var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n\n  var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n  var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n  var attributes = {\n    show: show,\n    distanceDisplayCondition: distanceDisplayConditionAttribute,\n    color: undefined,\n    offset: undefined\n  };\n\n  if (this._materialProperty instanceof ColorMaterialProperty) {\n    var currentColor;\n\n    if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n      currentColor = this._materialProperty.color.getValue(time, scratchColor);\n    }\n\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n\n    color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n    attributes.color = color;\n  }\n\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new EllipsoidGeometry(this._options),\n    modelMatrix: skipModelMatrix ? undefined : entity.computeModelMatrixForHeightReference(time, entity.ellipsoid.heightReference, this._options.radii.z * 0.5, this._scene.mapProjection.ellipsoid, modelMatrixResult),\n    attributes: attributes\n  });\n};\n/**\n * Creates the geometry instance which represents the outline of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @param {Boolean} [skipModelMatrix=false] Whether to compute a model matrix for the geometry instance\n * @param {Matrix4} [modelMatrixResult] Used to store the result of the model matrix calculation\n * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent an outlined geometry.\n */\n\n\nEllipsoidGeometryUpdater.prototype.createOutlineGeometryInstance = function (time, skipModelMatrix, modelMatrixResult) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time); //>>includeEnd('debug');\n\n  var entity = this._entity;\n  var isAvailable = entity.isAvailable(time);\n  var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n\n  var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n  var attributes = {\n    show: new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n    color: ColorGeometryInstanceAttribute.fromColor(outlineColor),\n    distanceDisplayCondition: DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n    offset: undefined\n  };\n\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new EllipsoidOutlineGeometry(this._options),\n    modelMatrix: skipModelMatrix ? undefined : entity.computeModelMatrixForHeightReference(time, entity.ellipsoid.heightReference, this._options.radii.z * 0.5, this._scene.mapProjection.ellipsoid, modelMatrixResult),\n    attributes: attributes\n  });\n};\n\nEllipsoidGeometryUpdater.prototype._computeCenter = function (time, result) {\n  return Property.getValueOrUndefined(this._entity.position, time, result);\n};\n\nEllipsoidGeometryUpdater.prototype._isHidden = function (entity, ellipsoid) {\n  return !defined(entity.position) || !defined(ellipsoid.radii) || GeometryUpdater.prototype._isHidden.call(this, entity, ellipsoid);\n};\n\nEllipsoidGeometryUpdater.prototype._isDynamic = function (entity, ellipsoid) {\n  return !entity.position.isConstant || //\n  !Property.isConstant(entity.orientation) || //\n  !ellipsoid.radii.isConstant || //\n  !Property.isConstant(ellipsoid.innerRadii) || //\n  !Property.isConstant(ellipsoid.stackPartitions) || //\n  !Property.isConstant(ellipsoid.slicePartitions) || //\n  !Property.isConstant(ellipsoid.outlineWidth) || //\n  !Property.isConstant(ellipsoid.minimumClock) || //\n  !Property.isConstant(ellipsoid.maximumClock) || //\n  !Property.isConstant(ellipsoid.minimumCone) || //\n  !Property.isConstant(ellipsoid.maximumCone) || //\n  !Property.isConstant(ellipsoid.subdivisions);\n};\n\nEllipsoidGeometryUpdater.prototype._setStaticOptions = function (entity, ellipsoid) {\n  var heightReference = Property.getValueOrDefault(ellipsoid.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n  var options = this._options;\n  options.vertexFormat = this._materialProperty instanceof ColorMaterialProperty ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n  options.radii = ellipsoid.radii.getValue(Iso8601.MINIMUM_VALUE, options.radii);\n  options.innerRadii = Property.getValueOrUndefined(ellipsoid.innerRadii, options.radii);\n  options.minimumClock = Property.getValueOrUndefined(ellipsoid.minimumClock, Iso8601.MINIMUM_VALUE);\n  options.maximumClock = Property.getValueOrUndefined(ellipsoid.maximumClock, Iso8601.MINIMUM_VALUE);\n  options.minimumCone = Property.getValueOrUndefined(ellipsoid.minimumCone, Iso8601.MINIMUM_VALUE);\n  options.maximumCone = Property.getValueOrUndefined(ellipsoid.maximumCone, Iso8601.MINIMUM_VALUE);\n  options.stackPartitions = Property.getValueOrUndefined(ellipsoid.stackPartitions, Iso8601.MINIMUM_VALUE);\n  options.slicePartitions = Property.getValueOrUndefined(ellipsoid.slicePartitions, Iso8601.MINIMUM_VALUE);\n  options.subdivisions = Property.getValueOrUndefined(ellipsoid.subdivisions, Iso8601.MINIMUM_VALUE);\n  options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n};\n\nEllipsoidGeometryUpdater.prototype._onEntityPropertyChanged = heightReferenceOnEntityPropertyChanged;\nEllipsoidGeometryUpdater.DynamicGeometryUpdater = DynamicEllipsoidGeometryUpdater;\n/**\n * @private\n */\n\nfunction DynamicEllipsoidGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n  DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n  this._scene = geometryUpdater._scene;\n  this._modelMatrix = new Matrix4();\n  this._attributes = undefined;\n  this._outlineAttributes = undefined;\n  this._lastSceneMode = undefined;\n  this._lastShow = undefined;\n  this._lastOutlineShow = undefined;\n  this._lastOutlineWidth = undefined;\n  this._lastOutlineColor = undefined;\n  this._lastOffset = new Cartesian3();\n  this._material = {};\n}\n\nif (defined(Object.create)) {\n  DynamicEllipsoidGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n  DynamicEllipsoidGeometryUpdater.prototype.constructor = DynamicEllipsoidGeometryUpdater;\n}\n\nDynamicEllipsoidGeometryUpdater.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time); //>>includeEnd('debug');\n\n  var entity = this._entity;\n  var ellipsoid = entity.ellipsoid;\n\n  if (!entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(ellipsoid.show, time, true)) {\n    if (defined(this._primitive)) {\n      this._primitive.show = false;\n    }\n\n    if (defined(this._outlinePrimitive)) {\n      this._outlinePrimitive.show = false;\n    }\n\n    return;\n  }\n\n  var radii = Property.getValueOrUndefined(ellipsoid.radii, time, radiiScratch);\n  var modelMatrix = defined(radii) ? entity.computeModelMatrixForHeightReference(time, ellipsoid.heightReference, radii.z * 0.5, this._scene.mapProjection.ellipsoid, this._modelMatrix) : undefined;\n\n  if (!defined(modelMatrix) || !defined(radii)) {\n    if (defined(this._primitive)) {\n      this._primitive.show = false;\n    }\n\n    if (defined(this._outlinePrimitive)) {\n      this._outlinePrimitive.show = false;\n    }\n\n    return;\n  } //Compute attributes and material.\n\n\n  var showFill = Property.getValueOrDefault(ellipsoid.fill, time, true);\n  var showOutline = Property.getValueOrDefault(ellipsoid.outline, time, false);\n  var outlineColor = Property.getValueOrClonedDefault(ellipsoid.outlineColor, time, Color.BLACK, scratchColor);\n  var material = MaterialProperty.getValue(time, defaultValue(ellipsoid.material, defaultMaterial), this._material); // Check properties that could trigger a primitive rebuild.\n\n  var innerRadii = Property.getValueOrUndefined(ellipsoid.innerRadii, time, innerRadiiScratch);\n  var minimumClock = Property.getValueOrUndefined(ellipsoid.minimumClock, time);\n  var maximumClock = Property.getValueOrUndefined(ellipsoid.maximumClock, time);\n  var minimumCone = Property.getValueOrUndefined(ellipsoid.minimumCone, time);\n  var maximumCone = Property.getValueOrUndefined(ellipsoid.maximumCone, time);\n  var stackPartitions = Property.getValueOrUndefined(ellipsoid.stackPartitions, time);\n  var slicePartitions = Property.getValueOrUndefined(ellipsoid.slicePartitions, time);\n  var subdivisions = Property.getValueOrUndefined(ellipsoid.subdivisions, time);\n  var outlineWidth = Property.getValueOrDefault(ellipsoid.outlineWidth, time, 1.0);\n  var heightReference = Property.getValueOrDefault(ellipsoid.heightReference, time, HeightReference.NONE);\n  var offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined; //In 3D we use a fast path by modifying Primitive.modelMatrix instead of regenerating the primitive every frame.\n  //Also check for height reference because this method doesn't work when the height is relative to terrain.\n\n  var sceneMode = this._scene.mode;\n  var in3D = sceneMode === SceneMode.SCENE3D && heightReference === HeightReference.NONE;\n  var options = this._options;\n\n  var shadows = this._geometryUpdater.shadowsProperty.getValue(time);\n\n  var distanceDisplayConditionProperty = this._geometryUpdater.distanceDisplayConditionProperty;\n  var distanceDisplayCondition = distanceDisplayConditionProperty.getValue(time);\n  var offset = Property.getValueOrDefault(this._geometryUpdater.terrainOffsetProperty, time, defaultOffset, offsetScratch); //We only rebuild the primitive if something other than the radii has changed\n  //For the radii, we use unit sphere and then deform it with a scale matrix.\n\n  var rebuildPrimitives = !in3D || this._lastSceneMode !== sceneMode || !defined(this._primitive) || //\n  options.stackPartitions !== stackPartitions || options.slicePartitions !== slicePartitions || //\n  defined(innerRadii) && !Cartesian3.equals(options.innerRadii !== innerRadii) || options.minimumClock !== minimumClock || //\n  options.maximumClock !== maximumClock || options.minimumCone !== minimumCone || //\n  options.maximumCone !== maximumCone || options.subdivisions !== subdivisions || //\n  this._lastOutlineWidth !== outlineWidth || options.offsetAttribute !== offsetAttribute;\n\n  if (rebuildPrimitives) {\n    var primitives = this._primitives;\n    primitives.removeAndDestroy(this._primitive);\n    primitives.removeAndDestroy(this._outlinePrimitive);\n    this._primitive = undefined;\n    this._outlinePrimitive = undefined;\n    this._lastSceneMode = sceneMode;\n    this._lastOutlineWidth = outlineWidth;\n    options.stackPartitions = stackPartitions;\n    options.slicePartitions = slicePartitions;\n    options.subdivisions = subdivisions;\n    options.offsetAttribute = offsetAttribute;\n    options.radii = Cartesian3.clone(in3D ? unitSphere : radii, options.radii);\n\n    if (defined(innerRadii)) {\n      if (in3D) {\n        var mag = Cartesian3.magnitude(radii);\n        options.innerRadii = Cartesian3.fromElements(innerRadii.x / mag, innerRadii.y / mag, innerRadii.z / mag, options.innerRadii);\n      } else {\n        options.innerRadii = Cartesian3.clone(innerRadii, options.innerRadii);\n      }\n    } else {\n      options.innerRadii = undefined;\n    }\n\n    options.minimumClock = minimumClock;\n    options.maximumClock = maximumClock;\n    options.minimumCone = minimumCone;\n    options.maximumCone = maximumCone;\n    var appearance = new MaterialAppearance({\n      material: material,\n      translucent: material.isTranslucent(),\n      closed: true\n    });\n    options.vertexFormat = appearance.vertexFormat;\n\n    var fillInstance = this._geometryUpdater.createFillGeometryInstance(time, in3D, this._modelMatrix);\n\n    this._primitive = primitives.add(new Primitive({\n      geometryInstances: fillInstance,\n      appearance: appearance,\n      asynchronous: false,\n      shadows: shadows\n    }));\n\n    var outlineInstance = this._geometryUpdater.createOutlineGeometryInstance(time, in3D, this._modelMatrix);\n\n    this._outlinePrimitive = primitives.add(new Primitive({\n      geometryInstances: outlineInstance,\n      appearance: new PerInstanceColorAppearance({\n        flat: true,\n        translucent: outlineInstance.attributes.color.value[3] !== 255,\n        renderState: {\n          lineWidth: this._geometryUpdater._scene.clampLineWidth(outlineWidth)\n        }\n      }),\n      asynchronous: false,\n      shadows: shadows\n    }));\n    this._lastShow = showFill;\n    this._lastOutlineShow = showOutline;\n    this._lastOutlineColor = Color.clone(outlineColor, this._lastOutlineColor);\n    this._lastDistanceDisplayCondition = distanceDisplayCondition;\n    this._lastOffset = Cartesian3.clone(offset, this._lastOffset);\n  } else if (this._primitive.ready) {\n    //Update attributes only.\n    var primitive = this._primitive;\n    var outlinePrimitive = this._outlinePrimitive;\n    primitive.show = true;\n    outlinePrimitive.show = true;\n    primitive.appearance.material = material;\n    var attributes = this._attributes;\n\n    if (!defined(attributes)) {\n      attributes = primitive.getGeometryInstanceAttributes(entity);\n      this._attributes = attributes;\n    }\n\n    if (showFill !== this._lastShow) {\n      attributes.show = ShowGeometryInstanceAttribute.toValue(showFill, attributes.show);\n      this._lastShow = showFill;\n    }\n\n    var outlineAttributes = this._outlineAttributes;\n\n    if (!defined(outlineAttributes)) {\n      outlineAttributes = outlinePrimitive.getGeometryInstanceAttributes(entity);\n      this._outlineAttributes = outlineAttributes;\n    }\n\n    if (showOutline !== this._lastOutlineShow) {\n      outlineAttributes.show = ShowGeometryInstanceAttribute.toValue(showOutline, outlineAttributes.show);\n      this._lastOutlineShow = showOutline;\n    }\n\n    if (!Color.equals(outlineColor, this._lastOutlineColor)) {\n      outlineAttributes.color = ColorGeometryInstanceAttribute.toValue(outlineColor, outlineAttributes.color);\n      Color.clone(outlineColor, this._lastOutlineColor);\n    }\n\n    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, this._lastDistanceDisplayCondition)) {\n      attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n      outlineAttributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, outlineAttributes.distanceDisplayCondition);\n      DistanceDisplayCondition.clone(distanceDisplayCondition, this._lastDistanceDisplayCondition);\n    }\n\n    if (!Cartesian3.equals(offset, this._lastOffset)) {\n      attributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);\n      outlineAttributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);\n      Cartesian3.clone(offset, this._lastOffset);\n    }\n  }\n\n  if (in3D) {\n    //Since we are scaling a unit sphere, we can't let any of the values go to zero.\n    //Instead we clamp them to a small value.  To the naked eye, this produces the same results\n    //that you get passing EllipsoidGeometry a radii with a zero component.\n    radii.x = Math.max(radii.x, 0.001);\n    radii.y = Math.max(radii.y, 0.001);\n    radii.z = Math.max(radii.z, 0.001);\n    modelMatrix = Matrix4.multiplyByScale(modelMatrix, radii, modelMatrix);\n    this._primitive.modelMatrix = modelMatrix;\n    this._outlinePrimitive.modelMatrix = modelMatrix;\n  }\n};\n\nexport default EllipsoidGeometryUpdater;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/DataSources/EllipsoidGeometryUpdater.js"],"names":["Cartesian3","Check","Color","ColorGeometryInstanceAttribute","defaultValue","defined","DistanceDisplayCondition","DistanceDisplayConditionGeometryInstanceAttribute","EllipsoidGeometry","EllipsoidOutlineGeometry","GeometryInstance","GeometryOffsetAttribute","Iso8601","Matrix4","OffsetGeometryInstanceAttribute","ShowGeometryInstanceAttribute","HeightReference","MaterialAppearance","PerInstanceColorAppearance","Primitive","SceneMode","ColorMaterialProperty","DynamicGeometryUpdater","GeometryUpdater","heightReferenceOnEntityPropertyChanged","MaterialProperty","Property","defaultMaterial","WHITE","defaultOffset","ZERO","offsetScratch","radiiScratch","innerRadiiScratch","scratchColor","unitSphere","EllipsoidGeometryOptions","entity","id","vertexFormat","undefined","radii","innerRadii","minimumClock","maximumClock","minimumCone","maximumCone","stackPartitions","slicePartitions","subdivisions","offsetAttribute","EllipsoidGeometryUpdater","scene","call","geometryOptions","geometryPropertyName","observedPropertyNames","_onEntityPropertyChanged","ellipsoid","Object","create","prototype","constructor","defineProperties","terrainOffsetProperty","get","_terrainOffsetProperty","createFillGeometryInstance","time","skipModelMatrix","modelMatrixResult","_entity","isAvailable","color","show","isShowing","_showProperty","getValue","_fillProperty","distanceDisplayCondition","_distanceDisplayConditionProperty","distanceDisplayConditionAttribute","fromDistanceDisplayCondition","attributes","offset","_materialProperty","currentColor","isConstant","fromColor","_options","fromCartesian3","getValueOrDefault","geometry","modelMatrix","computeModelMatrixForHeightReference","heightReference","z","_scene","mapProjection","createOutlineGeometryInstance","outlineColor","_outlineColorProperty","BLACK","_showOutlineProperty","_computeCenter","result","getValueOrUndefined","position","_isHidden","_isDynamic","orientation","outlineWidth","_setStaticOptions","MINIMUM_VALUE","NONE","options","VERTEX_FORMAT","MaterialSupport","TEXTURED","ALL","DynamicEllipsoidGeometryUpdater","geometryUpdater","primitives","groundPrimitives","_modelMatrix","_attributes","_outlineAttributes","_lastSceneMode","_lastShow","_lastOutlineShow","_lastOutlineWidth","_lastOutlineColor","_lastOffset","_material","update","_primitive","_outlinePrimitive","showFill","fill","showOutline","outline","getValueOrClonedDefault","material","sceneMode","mode","in3D","SCENE3D","shadows","_geometryUpdater","shadowsProperty","distanceDisplayConditionProperty","rebuildPrimitives","equals","_primitives","removeAndDestroy","clone","mag","magnitude","fromElements","x","y","appearance","translucent","isTranslucent","closed","fillInstance","add","geometryInstances","asynchronous","outlineInstance","flat","value","renderState","lineWidth","clampLineWidth","_lastDistanceDisplayCondition","ready","primitive","outlinePrimitive","getGeometryInstanceAttributes","toValue","outlineAttributes","Math","max","multiplyByScale"],"mappings":"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","sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport EllipsoidGeometry from \"../Core/EllipsoidGeometry.js\";\nimport EllipsoidOutlineGeometry from \"../Core/EllipsoidOutlineGeometry.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"../Core/GeometryOffsetAttribute.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport Primitive from \"../Scene/Primitive.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport DynamicGeometryUpdater from \"./DynamicGeometryUpdater.js\";\nimport GeometryUpdater from \"./GeometryUpdater.js\";\nimport heightReferenceOnEntityPropertyChanged from \"./heightReferenceOnEntityPropertyChanged.js\";\nimport MaterialProperty from \"./MaterialProperty.js\";\nimport Property from \"./Property.js\";\n\nvar defaultMaterial = new ColorMaterialProperty(Color.WHITE);\nvar defaultOffset = Cartesian3.ZERO;\n\nvar offsetScratch = new Cartesian3();\nvar radiiScratch = new Cartesian3();\nvar innerRadiiScratch = new Cartesian3();\nvar scratchColor = new Color();\nvar unitSphere = new Cartesian3(1, 1, 1);\n\nfunction EllipsoidGeometryOptions(entity) {\n  this.id = entity;\n  this.vertexFormat = undefined;\n  this.radii = undefined;\n  this.innerRadii = undefined;\n  this.minimumClock = undefined;\n  this.maximumClock = undefined;\n  this.minimumCone = undefined;\n  this.maximumCone = undefined;\n  this.stackPartitions = undefined;\n  this.slicePartitions = undefined;\n  this.subdivisions = undefined;\n  this.offsetAttribute = undefined;\n}\n\n/**\n * A {@link GeometryUpdater} for ellipsoids.\n * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n * @alias EllipsoidGeometryUpdater\n * @constructor\n *\n * @param {Entity} entity The entity containing the geometry to be visualized.\n * @param {Scene} scene The scene where visualization is taking place.\n */\nfunction EllipsoidGeometryUpdater(entity, scene) {\n  GeometryUpdater.call(this, {\n    entity: entity,\n    scene: scene,\n    geometryOptions: new EllipsoidGeometryOptions(entity),\n    geometryPropertyName: \"ellipsoid\",\n    observedPropertyNames: [\n      \"availability\",\n      \"position\",\n      \"orientation\",\n      \"ellipsoid\",\n    ],\n  });\n\n  this._onEntityPropertyChanged(\n    entity,\n    \"ellipsoid\",\n    entity.ellipsoid,\n    undefined\n  );\n}\n\nif (defined(Object.create)) {\n  EllipsoidGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n  EllipsoidGeometryUpdater.prototype.constructor = EllipsoidGeometryUpdater;\n}\n\nObject.defineProperties(EllipsoidGeometryUpdater.prototype, {\n  /**\n   * Gets the terrain offset property\n   * @type {TerrainOffsetProperty}\n   * @memberof EllipsoidGeometryUpdater.prototype\n   * @readonly\n   */\n  terrainOffsetProperty: {\n    get: function () {\n      return this._terrainOffsetProperty;\n    },\n  },\n});\n\n/**\n * Creates the geometry instance which represents the fill of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @param {Boolean} [skipModelMatrix=false] Whether to compute a model matrix for the geometry instance\n * @param {Matrix4} [modelMatrixResult] Used to store the result of the model matrix calculation\n * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent a filled geometry.\n */\nEllipsoidGeometryUpdater.prototype.createFillGeometryInstance = function (\n  time,\n  skipModelMatrix,\n  modelMatrixResult\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  //>>includeEnd('debug');\n\n  var entity = this._entity;\n  var isAvailable = entity.isAvailable(time);\n\n  var color;\n  var show = new ShowGeometryInstanceAttribute(\n    isAvailable &&\n      entity.isShowing &&\n      this._showProperty.getValue(time) &&\n      this._fillProperty.getValue(time)\n  );\n  var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(\n    time\n  );\n  var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(\n    distanceDisplayCondition\n  );\n\n  var attributes = {\n    show: show,\n    distanceDisplayCondition: distanceDisplayConditionAttribute,\n    color: undefined,\n    offset: undefined,\n  };\n\n  if (this._materialProperty instanceof ColorMaterialProperty) {\n    var currentColor;\n    if (\n      defined(this._materialProperty.color) &&\n      (this._materialProperty.color.isConstant || isAvailable)\n    ) {\n      currentColor = this._materialProperty.color.getValue(time, scratchColor);\n    }\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n    color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n    attributes.color = color;\n  }\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(\n      Property.getValueOrDefault(\n        this._terrainOffsetProperty,\n        time,\n        defaultOffset,\n        offsetScratch\n      )\n    );\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new EllipsoidGeometry(this._options),\n    modelMatrix: skipModelMatrix\n      ? undefined\n      : entity.computeModelMatrixForHeightReference(\n          time,\n          entity.ellipsoid.heightReference,\n          this._options.radii.z * 0.5,\n          this._scene.mapProjection.ellipsoid,\n          modelMatrixResult\n        ),\n    attributes: attributes,\n  });\n};\n\n/**\n * Creates the geometry instance which represents the outline of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @param {Boolean} [skipModelMatrix=false] Whether to compute a model matrix for the geometry instance\n * @param {Matrix4} [modelMatrixResult] Used to store the result of the model matrix calculation\n * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent an outlined geometry.\n */\nEllipsoidGeometryUpdater.prototype.createOutlineGeometryInstance = function (\n  time,\n  skipModelMatrix,\n  modelMatrixResult\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  //>>includeEnd('debug');\n\n  var entity = this._entity;\n  var isAvailable = entity.isAvailable(time);\n\n  var outlineColor = Property.getValueOrDefault(\n    this._outlineColorProperty,\n    time,\n    Color.BLACK,\n    scratchColor\n  );\n  var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(\n    time\n  );\n\n  var attributes = {\n    show: new ShowGeometryInstanceAttribute(\n      isAvailable &&\n        entity.isShowing &&\n        this._showProperty.getValue(time) &&\n        this._showOutlineProperty.getValue(time)\n    ),\n    color: ColorGeometryInstanceAttribute.fromColor(outlineColor),\n    distanceDisplayCondition: DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(\n      distanceDisplayCondition\n    ),\n    offset: undefined,\n  };\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(\n      Property.getValueOrDefault(\n        this._terrainOffsetProperty,\n        time,\n        defaultOffset,\n        offsetScratch\n      )\n    );\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new EllipsoidOutlineGeometry(this._options),\n    modelMatrix: skipModelMatrix\n      ? undefined\n      : entity.computeModelMatrixForHeightReference(\n          time,\n          entity.ellipsoid.heightReference,\n          this._options.radii.z * 0.5,\n          this._scene.mapProjection.ellipsoid,\n          modelMatrixResult\n        ),\n    attributes: attributes,\n  });\n};\n\nEllipsoidGeometryUpdater.prototype._computeCenter = function (time, result) {\n  return Property.getValueOrUndefined(this._entity.position, time, result);\n};\n\nEllipsoidGeometryUpdater.prototype._isHidden = function (entity, ellipsoid) {\n  return (\n    !defined(entity.position) ||\n    !defined(ellipsoid.radii) ||\n    GeometryUpdater.prototype._isHidden.call(this, entity, ellipsoid)\n  );\n};\n\nEllipsoidGeometryUpdater.prototype._isDynamic = function (entity, ellipsoid) {\n  return (\n    !entity.position.isConstant || //\n    !Property.isConstant(entity.orientation) || //\n    !ellipsoid.radii.isConstant || //\n    !Property.isConstant(ellipsoid.innerRadii) || //\n    !Property.isConstant(ellipsoid.stackPartitions) || //\n    !Property.isConstant(ellipsoid.slicePartitions) || //\n    !Property.isConstant(ellipsoid.outlineWidth) || //\n    !Property.isConstant(ellipsoid.minimumClock) || //\n    !Property.isConstant(ellipsoid.maximumClock) || //\n    !Property.isConstant(ellipsoid.minimumCone) || //\n    !Property.isConstant(ellipsoid.maximumCone) || //\n    !Property.isConstant(ellipsoid.subdivisions)\n  );\n};\n\nEllipsoidGeometryUpdater.prototype._setStaticOptions = function (\n  entity,\n  ellipsoid\n) {\n  var heightReference = Property.getValueOrDefault(\n    ellipsoid.heightReference,\n    Iso8601.MINIMUM_VALUE,\n    HeightReference.NONE\n  );\n  var options = this._options;\n  options.vertexFormat =\n    this._materialProperty instanceof ColorMaterialProperty\n      ? PerInstanceColorAppearance.VERTEX_FORMAT\n      : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n  options.radii = ellipsoid.radii.getValue(\n    Iso8601.MINIMUM_VALUE,\n    options.radii\n  );\n  options.innerRadii = Property.getValueOrUndefined(\n    ellipsoid.innerRadii,\n    options.radii\n  );\n  options.minimumClock = Property.getValueOrUndefined(\n    ellipsoid.minimumClock,\n    Iso8601.MINIMUM_VALUE\n  );\n  options.maximumClock = Property.getValueOrUndefined(\n    ellipsoid.maximumClock,\n    Iso8601.MINIMUM_VALUE\n  );\n  options.minimumCone = Property.getValueOrUndefined(\n    ellipsoid.minimumCone,\n    Iso8601.MINIMUM_VALUE\n  );\n  options.maximumCone = Property.getValueOrUndefined(\n    ellipsoid.maximumCone,\n    Iso8601.MINIMUM_VALUE\n  );\n  options.stackPartitions = Property.getValueOrUndefined(\n    ellipsoid.stackPartitions,\n    Iso8601.MINIMUM_VALUE\n  );\n  options.slicePartitions = Property.getValueOrUndefined(\n    ellipsoid.slicePartitions,\n    Iso8601.MINIMUM_VALUE\n  );\n  options.subdivisions = Property.getValueOrUndefined(\n    ellipsoid.subdivisions,\n    Iso8601.MINIMUM_VALUE\n  );\n  options.offsetAttribute =\n    heightReference !== HeightReference.NONE\n      ? GeometryOffsetAttribute.ALL\n      : undefined;\n};\n\nEllipsoidGeometryUpdater.prototype._onEntityPropertyChanged = heightReferenceOnEntityPropertyChanged;\n\nEllipsoidGeometryUpdater.DynamicGeometryUpdater = DynamicEllipsoidGeometryUpdater;\n\n/**\n * @private\n */\nfunction DynamicEllipsoidGeometryUpdater(\n  geometryUpdater,\n  primitives,\n  groundPrimitives\n) {\n  DynamicGeometryUpdater.call(\n    this,\n    geometryUpdater,\n    primitives,\n    groundPrimitives\n  );\n\n  this._scene = geometryUpdater._scene;\n  this._modelMatrix = new Matrix4();\n  this._attributes = undefined;\n  this._outlineAttributes = undefined;\n  this._lastSceneMode = undefined;\n  this._lastShow = undefined;\n  this._lastOutlineShow = undefined;\n  this._lastOutlineWidth = undefined;\n  this._lastOutlineColor = undefined;\n  this._lastOffset = new Cartesian3();\n  this._material = {};\n}\n\nif (defined(Object.create)) {\n  DynamicEllipsoidGeometryUpdater.prototype = Object.create(\n    DynamicGeometryUpdater.prototype\n  );\n  DynamicEllipsoidGeometryUpdater.prototype.constructor = DynamicEllipsoidGeometryUpdater;\n}\n\nDynamicEllipsoidGeometryUpdater.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  //>>includeEnd('debug');\n\n  var entity = this._entity;\n  var ellipsoid = entity.ellipsoid;\n  if (\n    !entity.isShowing ||\n    !entity.isAvailable(time) ||\n    !Property.getValueOrDefault(ellipsoid.show, time, true)\n  ) {\n    if (defined(this._primitive)) {\n      this._primitive.show = false;\n    }\n\n    if (defined(this._outlinePrimitive)) {\n      this._outlinePrimitive.show = false;\n    }\n    return;\n  }\n\n  var radii = Property.getValueOrUndefined(ellipsoid.radii, time, radiiScratch);\n  var modelMatrix = defined(radii)\n    ? entity.computeModelMatrixForHeightReference(\n        time,\n        ellipsoid.heightReference,\n        radii.z * 0.5,\n        this._scene.mapProjection.ellipsoid,\n        this._modelMatrix\n      )\n    : undefined;\n  if (!defined(modelMatrix) || !defined(radii)) {\n    if (defined(this._primitive)) {\n      this._primitive.show = false;\n    }\n\n    if (defined(this._outlinePrimitive)) {\n      this._outlinePrimitive.show = false;\n    }\n    return;\n  }\n\n  //Compute attributes and material.\n  var showFill = Property.getValueOrDefault(ellipsoid.fill, time, true);\n  var showOutline = Property.getValueOrDefault(ellipsoid.outline, time, false);\n  var outlineColor = Property.getValueOrClonedDefault(\n    ellipsoid.outlineColor,\n    time,\n    Color.BLACK,\n    scratchColor\n  );\n  var material = MaterialProperty.getValue(\n    time,\n    defaultValue(ellipsoid.material, defaultMaterial),\n    this._material\n  );\n\n  // Check properties that could trigger a primitive rebuild.\n  var innerRadii = Property.getValueOrUndefined(\n    ellipsoid.innerRadii,\n    time,\n    innerRadiiScratch\n  );\n  var minimumClock = Property.getValueOrUndefined(ellipsoid.minimumClock, time);\n  var maximumClock = Property.getValueOrUndefined(ellipsoid.maximumClock, time);\n  var minimumCone = Property.getValueOrUndefined(ellipsoid.minimumCone, time);\n  var maximumCone = Property.getValueOrUndefined(ellipsoid.maximumCone, time);\n  var stackPartitions = Property.getValueOrUndefined(\n    ellipsoid.stackPartitions,\n    time\n  );\n  var slicePartitions = Property.getValueOrUndefined(\n    ellipsoid.slicePartitions,\n    time\n  );\n  var subdivisions = Property.getValueOrUndefined(ellipsoid.subdivisions, time);\n  var outlineWidth = Property.getValueOrDefault(\n    ellipsoid.outlineWidth,\n    time,\n    1.0\n  );\n  var heightReference = Property.getValueOrDefault(\n    ellipsoid.heightReference,\n    time,\n    HeightReference.NONE\n  );\n  var offsetAttribute =\n    heightReference !== HeightReference.NONE\n      ? GeometryOffsetAttribute.ALL\n      : undefined;\n\n  //In 3D we use a fast path by modifying Primitive.modelMatrix instead of regenerating the primitive every frame.\n  //Also check for height reference because this method doesn't work when the height is relative to terrain.\n  var sceneMode = this._scene.mode;\n  var in3D =\n    sceneMode === SceneMode.SCENE3D && heightReference === HeightReference.NONE;\n\n  var options = this._options;\n\n  var shadows = this._geometryUpdater.shadowsProperty.getValue(time);\n\n  var distanceDisplayConditionProperty = this._geometryUpdater\n    .distanceDisplayConditionProperty;\n  var distanceDisplayCondition = distanceDisplayConditionProperty.getValue(\n    time\n  );\n\n  var offset = Property.getValueOrDefault(\n    this._geometryUpdater.terrainOffsetProperty,\n    time,\n    defaultOffset,\n    offsetScratch\n  );\n\n  //We only rebuild the primitive if something other than the radii has changed\n  //For the radii, we use unit sphere and then deform it with a scale matrix.\n  var rebuildPrimitives =\n    !in3D ||\n    this._lastSceneMode !== sceneMode ||\n    !defined(this._primitive) || //\n    options.stackPartitions !== stackPartitions ||\n    options.slicePartitions !== slicePartitions || //\n    (defined(innerRadii) &&\n      !Cartesian3.equals(options.innerRadii !== innerRadii)) ||\n    options.minimumClock !== minimumClock || //\n    options.maximumClock !== maximumClock ||\n    options.minimumCone !== minimumCone || //\n    options.maximumCone !== maximumCone ||\n    options.subdivisions !== subdivisions || //\n    this._lastOutlineWidth !== outlineWidth ||\n    options.offsetAttribute !== offsetAttribute;\n\n  if (rebuildPrimitives) {\n    var primitives = this._primitives;\n    primitives.removeAndDestroy(this._primitive);\n    primitives.removeAndDestroy(this._outlinePrimitive);\n    this._primitive = undefined;\n    this._outlinePrimitive = undefined;\n    this._lastSceneMode = sceneMode;\n    this._lastOutlineWidth = outlineWidth;\n\n    options.stackPartitions = stackPartitions;\n    options.slicePartitions = slicePartitions;\n    options.subdivisions = subdivisions;\n    options.offsetAttribute = offsetAttribute;\n    options.radii = Cartesian3.clone(in3D ? unitSphere : radii, options.radii);\n    if (defined(innerRadii)) {\n      if (in3D) {\n        var mag = Cartesian3.magnitude(radii);\n        options.innerRadii = Cartesian3.fromElements(\n          innerRadii.x / mag,\n          innerRadii.y / mag,\n          innerRadii.z / mag,\n          options.innerRadii\n        );\n      } else {\n        options.innerRadii = Cartesian3.clone(innerRadii, options.innerRadii);\n      }\n    } else {\n      options.innerRadii = undefined;\n    }\n    options.minimumClock = minimumClock;\n    options.maximumClock = maximumClock;\n    options.minimumCone = minimumCone;\n    options.maximumCone = maximumCone;\n\n    var appearance = new MaterialAppearance({\n      material: material,\n      translucent: material.isTranslucent(),\n      closed: true,\n    });\n    options.vertexFormat = appearance.vertexFormat;\n\n    var fillInstance = this._geometryUpdater.createFillGeometryInstance(\n      time,\n      in3D,\n      this._modelMatrix\n    );\n\n    this._primitive = primitives.add(\n      new Primitive({\n        geometryInstances: fillInstance,\n        appearance: appearance,\n        asynchronous: false,\n        shadows: shadows,\n      })\n    );\n\n    var outlineInstance = this._geometryUpdater.createOutlineGeometryInstance(\n      time,\n      in3D,\n      this._modelMatrix\n    );\n    this._outlinePrimitive = primitives.add(\n      new Primitive({\n        geometryInstances: outlineInstance,\n        appearance: new PerInstanceColorAppearance({\n          flat: true,\n          translucent: outlineInstance.attributes.color.value[3] !== 255,\n          renderState: {\n            lineWidth: this._geometryUpdater._scene.clampLineWidth(\n              outlineWidth\n            ),\n          },\n        }),\n        asynchronous: false,\n        shadows: shadows,\n      })\n    );\n\n    this._lastShow = showFill;\n    this._lastOutlineShow = showOutline;\n    this._lastOutlineColor = Color.clone(outlineColor, this._lastOutlineColor);\n    this._lastDistanceDisplayCondition = distanceDisplayCondition;\n    this._lastOffset = Cartesian3.clone(offset, this._lastOffset);\n  } else if (this._primitive.ready) {\n    //Update attributes only.\n    var primitive = this._primitive;\n    var outlinePrimitive = this._outlinePrimitive;\n\n    primitive.show = true;\n    outlinePrimitive.show = true;\n    primitive.appearance.material = material;\n\n    var attributes = this._attributes;\n    if (!defined(attributes)) {\n      attributes = primitive.getGeometryInstanceAttributes(entity);\n      this._attributes = attributes;\n    }\n    if (showFill !== this._lastShow) {\n      attributes.show = ShowGeometryInstanceAttribute.toValue(\n        showFill,\n        attributes.show\n      );\n      this._lastShow = showFill;\n    }\n\n    var outlineAttributes = this._outlineAttributes;\n\n    if (!defined(outlineAttributes)) {\n      outlineAttributes = outlinePrimitive.getGeometryInstanceAttributes(\n        entity\n      );\n      this._outlineAttributes = outlineAttributes;\n    }\n\n    if (showOutline !== this._lastOutlineShow) {\n      outlineAttributes.show = ShowGeometryInstanceAttribute.toValue(\n        showOutline,\n        outlineAttributes.show\n      );\n      this._lastOutlineShow = showOutline;\n    }\n\n    if (!Color.equals(outlineColor, this._lastOutlineColor)) {\n      outlineAttributes.color = ColorGeometryInstanceAttribute.toValue(\n        outlineColor,\n        outlineAttributes.color\n      );\n      Color.clone(outlineColor, this._lastOutlineColor);\n    }\n\n    if (\n      !DistanceDisplayCondition.equals(\n        distanceDisplayCondition,\n        this._lastDistanceDisplayCondition\n      )\n    ) {\n      attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(\n        distanceDisplayCondition,\n        attributes.distanceDisplayCondition\n      );\n      outlineAttributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(\n        distanceDisplayCondition,\n        outlineAttributes.distanceDisplayCondition\n      );\n      DistanceDisplayCondition.clone(\n        distanceDisplayCondition,\n        this._lastDistanceDisplayCondition\n      );\n    }\n\n    if (!Cartesian3.equals(offset, this._lastOffset)) {\n      attributes.offset = OffsetGeometryInstanceAttribute.toValue(\n        offset,\n        attributes.offset\n      );\n      outlineAttributes.offset = OffsetGeometryInstanceAttribute.toValue(\n        offset,\n        attributes.offset\n      );\n      Cartesian3.clone(offset, this._lastOffset);\n    }\n  }\n\n  if (in3D) {\n    //Since we are scaling a unit sphere, we can't let any of the values go to zero.\n    //Instead we clamp them to a small value.  To the naked eye, this produces the same results\n    //that you get passing EllipsoidGeometry a radii with a zero component.\n    radii.x = Math.max(radii.x, 0.001);\n    radii.y = Math.max(radii.y, 0.001);\n    radii.z = Math.max(radii.z, 0.001);\n\n    modelMatrix = Matrix4.multiplyByScale(modelMatrix, radii, modelMatrix);\n    this._primitive.modelMatrix = modelMatrix;\n    this._outlinePrimitive.modelMatrix = modelMatrix;\n  }\n};\nexport default EllipsoidGeometryUpdater;\n"]},"metadata":{},"sourceType":"module"}