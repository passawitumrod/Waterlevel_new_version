{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EasingFunction from \"../Core/EasingFunction.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EllipsoidGeodesic from \"../Core/EllipsoidGeodesic.js\";\nimport Event from \"../Core/Event.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport HeadingPitchRange from \"../Core/HeadingPitchRange.js\";\nimport HeadingPitchRoll from \"../Core/HeadingPitchRoll.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport CameraFlightPath from \"./CameraFlightPath.js\";\nimport MapMode2D from \"./MapMode2D.js\";\nimport SceneMode from \"./SceneMode.js\";\n/**\n * The camera is defined by a position, orientation, and view frustum.\n * <br /><br />\n * The orientation forms an orthonormal basis with a view, up and right = view x up unit vectors.\n * <br /><br />\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias Camera\n *\n * @constructor\n *\n * @param {Scene} scene The scene.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Camera.html|Cesium Sandcastle Camera Demo}\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Camera%20Tutorial.html\">Sandcastle Example</a> from the <a href=\"https://cesium.com/docs/tutorials/camera/|Camera Tutorial}\n *\n * @example\n * // Create a camera looking down the negative z-axis, positioned at the origin,\n * // with a field of view of 60 degrees, and 1:1 aspect ratio.\n * var camera = new Cesium.Camera(scene);\n * camera.position = new Cesium.Cartesian3();\n * camera.direction = Cesium.Cartesian3.negate(Cesium.Cartesian3.UNIT_Z, new Cesium.Cartesian3());\n * camera.up = Cesium.Cartesian3.clone(Cesium.Cartesian3.UNIT_Y);\n * camera.frustum.fov = Cesium.Math.PI_OVER_THREE;\n * camera.frustum.near = 1.0;\n * camera.frustum.far = 2.0;\n */\n\nfunction Camera(scene) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  } //>>includeEnd('debug');\n\n\n  this._scene = scene;\n  this._transform = Matrix4.clone(Matrix4.IDENTITY);\n  this._invTransform = Matrix4.clone(Matrix4.IDENTITY);\n  this._actualTransform = Matrix4.clone(Matrix4.IDENTITY);\n  this._actualInvTransform = Matrix4.clone(Matrix4.IDENTITY);\n  this._transformChanged = false;\n  /**\n   * The position of the camera.\n   *\n   * @type {Cartesian3}\n   */\n\n  this.position = new Cartesian3();\n  this._position = new Cartesian3();\n  this._positionWC = new Cartesian3();\n  this._positionCartographic = new Cartographic();\n  this._oldPositionWC = undefined;\n  /**\n   * The position delta magnitude.\n   *\n   * @private\n   */\n\n  this.positionWCDeltaMagnitude = 0.0;\n  /**\n   * The position delta magnitude last frame.\n   *\n   * @private\n   */\n\n  this.positionWCDeltaMagnitudeLastFrame = 0.0;\n  /**\n   * How long in seconds since the camera has stopped moving\n   *\n   * @private\n   */\n\n  this.timeSinceMoved = 0.0;\n  this._lastMovedTimestamp = 0.0;\n  /**\n   * The view direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n\n  this.direction = new Cartesian3();\n  this._direction = new Cartesian3();\n  this._directionWC = new Cartesian3();\n  /**\n   * The up direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n\n  this.up = new Cartesian3();\n  this._up = new Cartesian3();\n  this._upWC = new Cartesian3();\n  /**\n   * The right direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n\n  this.right = new Cartesian3();\n  this._right = new Cartesian3();\n  this._rightWC = new Cartesian3();\n  /**\n   * The region of space in view.\n   *\n   * @type {Frustum}\n   * @default PerspectiveFrustum()\n   *\n   * @see PerspectiveFrustum\n   * @see PerspectiveOffCenterFrustum\n   * @see OrthographicFrustum\n   */\n\n  this.frustum = new PerspectiveFrustum();\n  this.frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight;\n  this.frustum.fov = CesiumMath.toRadians(60.0);\n  /**\n   * The default amount to move the camera when an argument is not\n   * provided to the move methods.\n   * @type {Number}\n   * @default 100000.0;\n   */\n\n  this.defaultMoveAmount = 100000.0;\n  /**\n   * The default amount to rotate the camera when an argument is not\n   * provided to the look methods.\n   * @type {Number}\n   * @default Math.PI / 60.0\n   */\n\n  this.defaultLookAmount = Math.PI / 60.0;\n  /**\n   * The default amount to rotate the camera when an argument is not\n   * provided to the rotate methods.\n   * @type {Number}\n   * @default Math.PI / 3600.0\n   */\n\n  this.defaultRotateAmount = Math.PI / 3600.0;\n  /**\n   * The default amount to move the camera when an argument is not\n   * provided to the zoom methods.\n   * @type {Number}\n   * @default 100000.0;\n   */\n\n  this.defaultZoomAmount = 100000.0;\n  /**\n   * If set, the camera will not be able to rotate past this axis in either direction.\n   * @type {Cartesian3}\n   * @default undefined\n   */\n\n  this.constrainedAxis = undefined;\n  /**\n   * The factor multiplied by the the map size used to determine where to clamp the camera position\n   * when zooming out from the surface. The default is 1.5. Only valid for 2D and the map is rotatable.\n   * @type {Number}\n   * @default 1.5\n   */\n\n  this.maximumZoomFactor = 1.5;\n  this._moveStart = new Event();\n  this._moveEnd = new Event();\n  this._changed = new Event();\n  this._changedPosition = undefined;\n  this._changedDirection = undefined;\n  this._changedFrustum = undefined;\n  /**\n   * The amount the camera has to change before the <code>changed</code> event is raised. The value is a percentage in the [0, 1] range.\n   * @type {number}\n   * @default 0.5\n   */\n\n  this.percentageChanged = 0.5;\n  this._viewMatrix = new Matrix4();\n  this._invViewMatrix = new Matrix4();\n  updateViewMatrix(this);\n  this._mode = SceneMode.SCENE3D;\n  this._modeChanged = true;\n  var projection = scene.mapProjection;\n  this._projection = projection;\n  this._maxCoord = projection.project(new Cartographic(Math.PI, CesiumMath.PI_OVER_TWO));\n  this._max2Dfrustum = undefined; // set default view\n\n  rectangleCameraPosition3D(this, Camera.DEFAULT_VIEW_RECTANGLE, this.position, true);\n  var mag = Cartesian3.magnitude(this.position);\n  mag += mag * Camera.DEFAULT_VIEW_FACTOR;\n  Cartesian3.normalize(this.position, this.position);\n  Cartesian3.multiplyByScalar(this.position, mag, this.position);\n}\n/**\n * @private\n */\n\n\nCamera.TRANSFORM_2D = new Matrix4(0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n/**\n * @private\n */\n\nCamera.TRANSFORM_2D_INVERSE = Matrix4.inverseTransformation(Camera.TRANSFORM_2D, new Matrix4());\n/**\n * The default rectangle the camera will view on creation.\n * @type Rectangle\n */\n\nCamera.DEFAULT_VIEW_RECTANGLE = Rectangle.fromDegrees(-95.0, -20.0, -70.0, 90.0);\n/**\n * A scalar to multiply to the camera position and add it back after setting the camera to view the rectangle.\n * A value of zero means the camera will view the entire {@link Camera#DEFAULT_VIEW_RECTANGLE}, a value greater than zero\n * will move it further away from the extent, and a value less than zero will move it close to the extent.\n * @type Number\n */\n\nCamera.DEFAULT_VIEW_FACTOR = 0.5;\n/**\n * The default heading/pitch/range that is used when the camera flies to a location that contains a bounding sphere.\n * @type HeadingPitchRange\n */\n\nCamera.DEFAULT_OFFSET = new HeadingPitchRange(0.0, -CesiumMath.PI_OVER_FOUR, 0.0);\n\nfunction updateViewMatrix(camera) {\n  Matrix4.computeView(camera._position, camera._direction, camera._up, camera._right, camera._viewMatrix);\n  Matrix4.multiply(camera._viewMatrix, camera._actualInvTransform, camera._viewMatrix);\n  Matrix4.inverseTransformation(camera._viewMatrix, camera._invViewMatrix);\n}\n\nfunction updateCameraDeltas(camera) {\n  if (!defined(camera._oldPositionWC)) {\n    camera._oldPositionWC = Cartesian3.clone(camera.positionWC, camera._oldPositionWC);\n  } else {\n    camera.positionWCDeltaMagnitudeLastFrame = camera.positionWCDeltaMagnitude;\n    var delta = Cartesian3.subtract(camera.positionWC, camera._oldPositionWC, camera._oldPositionWC);\n    camera.positionWCDeltaMagnitude = Cartesian3.magnitude(delta);\n    camera._oldPositionWC = Cartesian3.clone(camera.positionWC, camera._oldPositionWC); // Update move timers\n\n    if (camera.positionWCDeltaMagnitude > 0.0) {\n      camera.timeSinceMoved = 0.0;\n      camera._lastMovedTimestamp = getTimestamp();\n    } else {\n      camera.timeSinceMoved = Math.max(getTimestamp() - camera._lastMovedTimestamp, 0.0) / 1000.0;\n    }\n  }\n}\n/**\n * Checks if there's a camera flight with preload for this camera.\n *\n * @returns {Boolean} Whether or not this camera has a current flight with a valid preloadFlightCamera in scene.\n *\n * @private\n *\n */\n\n\nCamera.prototype.canPreloadFlight = function () {\n  return defined(this._currentFlight) && this._mode !== SceneMode.SCENE2D;\n};\n\nCamera.prototype._updateCameraChanged = function () {\n  var camera = this;\n  updateCameraDeltas(camera);\n\n  if (camera._changed.numberOfListeners === 0) {\n    return;\n  }\n\n  var percentageChanged = camera.percentageChanged;\n\n  if (camera._mode === SceneMode.SCENE2D) {\n    if (!defined(camera._changedFrustum)) {\n      camera._changedPosition = Cartesian3.clone(camera.position, camera._changedPosition);\n      camera._changedFrustum = camera.frustum.clone();\n      return;\n    }\n\n    var position = camera.position;\n    var lastPosition = camera._changedPosition;\n    var frustum = camera.frustum;\n    var lastFrustum = camera._changedFrustum;\n    var x0 = position.x + frustum.left;\n    var x1 = position.x + frustum.right;\n    var x2 = lastPosition.x + lastFrustum.left;\n    var x3 = lastPosition.x + lastFrustum.right;\n    var y0 = position.y + frustum.bottom;\n    var y1 = position.y + frustum.top;\n    var y2 = lastPosition.y + lastFrustum.bottom;\n    var y3 = lastPosition.y + lastFrustum.top;\n    var leftX = Math.max(x0, x2);\n    var rightX = Math.min(x1, x3);\n    var bottomY = Math.max(y0, y2);\n    var topY = Math.min(y1, y3);\n    var areaPercentage;\n\n    if (leftX >= rightX || bottomY >= y1) {\n      areaPercentage = 1.0;\n    } else {\n      var areaRef = lastFrustum;\n\n      if (x0 < x2 && x1 > x3 && y0 < y2 && y1 > y3) {\n        areaRef = frustum;\n      }\n\n      areaPercentage = 1.0 - (rightX - leftX) * (topY - bottomY) / ((areaRef.right - areaRef.left) * (areaRef.top - areaRef.bottom));\n    }\n\n    if (areaPercentage > percentageChanged) {\n      camera._changed.raiseEvent(areaPercentage);\n\n      camera._changedPosition = Cartesian3.clone(camera.position, camera._changedPosition);\n      camera._changedFrustum = camera.frustum.clone(camera._changedFrustum);\n    }\n\n    return;\n  }\n\n  if (!defined(camera._changedDirection)) {\n    camera._changedPosition = Cartesian3.clone(camera.positionWC, camera._changedPosition);\n    camera._changedDirection = Cartesian3.clone(camera.directionWC, camera._changedDirection);\n    return;\n  }\n\n  var dirAngle = CesiumMath.acosClamped(Cartesian3.dot(camera.directionWC, camera._changedDirection));\n  var dirPercentage;\n\n  if (defined(camera.frustum.fovy)) {\n    dirPercentage = dirAngle / (camera.frustum.fovy * 0.5);\n  } else {\n    dirPercentage = dirAngle;\n  }\n\n  var distance = Cartesian3.distance(camera.positionWC, camera._changedPosition);\n  var heightPercentage = distance / camera.positionCartographic.height;\n\n  if (dirPercentage > percentageChanged || heightPercentage > percentageChanged) {\n    camera._changed.raiseEvent(Math.max(dirPercentage, heightPercentage));\n\n    camera._changedPosition = Cartesian3.clone(camera.positionWC, camera._changedPosition);\n    camera._changedDirection = Cartesian3.clone(camera.directionWC, camera._changedDirection);\n  }\n};\n\nfunction convertTransformForColumbusView(camera) {\n  Transforms.basisTo2D(camera._projection, camera._transform, camera._actualTransform);\n}\n\nvar scratchCartographic = new Cartographic();\nvar scratchCartesian3Projection = new Cartesian3();\nvar scratchCartesian3 = new Cartesian3();\nvar scratchCartesian4Origin = new Cartesian4();\nvar scratchCartesian4NewOrigin = new Cartesian4();\nvar scratchCartesian4NewXAxis = new Cartesian4();\nvar scratchCartesian4NewYAxis = new Cartesian4();\nvar scratchCartesian4NewZAxis = new Cartesian4();\n\nfunction convertTransformFor2D(camera) {\n  var projection = camera._projection;\n  var ellipsoid = projection.ellipsoid;\n  var origin = Matrix4.getColumn(camera._transform, 3, scratchCartesian4Origin);\n  var cartographic = ellipsoid.cartesianToCartographic(origin, scratchCartographic);\n  var projectedPosition = projection.project(cartographic, scratchCartesian3Projection);\n  var newOrigin = scratchCartesian4NewOrigin;\n  newOrigin.x = projectedPosition.z;\n  newOrigin.y = projectedPosition.x;\n  newOrigin.z = projectedPosition.y;\n  newOrigin.w = 1.0;\n  var newZAxis = Cartesian4.clone(Cartesian4.UNIT_X, scratchCartesian4NewZAxis);\n  var xAxis = Cartesian4.add(Matrix4.getColumn(camera._transform, 0, scratchCartesian3), origin, scratchCartesian3);\n  ellipsoid.cartesianToCartographic(xAxis, cartographic);\n  projection.project(cartographic, projectedPosition);\n  var newXAxis = scratchCartesian4NewXAxis;\n  newXAxis.x = projectedPosition.z;\n  newXAxis.y = projectedPosition.x;\n  newXAxis.z = projectedPosition.y;\n  newXAxis.w = 0.0;\n  Cartesian3.subtract(newXAxis, newOrigin, newXAxis);\n  newXAxis.x = 0.0;\n  var newYAxis = scratchCartesian4NewYAxis;\n\n  if (Cartesian3.magnitudeSquared(newXAxis) > CesiumMath.EPSILON10) {\n    Cartesian3.cross(newZAxis, newXAxis, newYAxis);\n  } else {\n    var yAxis = Cartesian4.add(Matrix4.getColumn(camera._transform, 1, scratchCartesian3), origin, scratchCartesian3);\n    ellipsoid.cartesianToCartographic(yAxis, cartographic);\n    projection.project(cartographic, projectedPosition);\n    newYAxis.x = projectedPosition.z;\n    newYAxis.y = projectedPosition.x;\n    newYAxis.z = projectedPosition.y;\n    newYAxis.w = 0.0;\n    Cartesian3.subtract(newYAxis, newOrigin, newYAxis);\n    newYAxis.x = 0.0;\n\n    if (Cartesian3.magnitudeSquared(newYAxis) < CesiumMath.EPSILON10) {\n      Cartesian4.clone(Cartesian4.UNIT_Y, newXAxis);\n      Cartesian4.clone(Cartesian4.UNIT_Z, newYAxis);\n    }\n  }\n\n  Cartesian3.cross(newYAxis, newZAxis, newXAxis);\n  Cartesian3.normalize(newXAxis, newXAxis);\n  Cartesian3.cross(newZAxis, newXAxis, newYAxis);\n  Cartesian3.normalize(newYAxis, newYAxis);\n  Matrix4.setColumn(camera._actualTransform, 0, newXAxis, camera._actualTransform);\n  Matrix4.setColumn(camera._actualTransform, 1, newYAxis, camera._actualTransform);\n  Matrix4.setColumn(camera._actualTransform, 2, newZAxis, camera._actualTransform);\n  Matrix4.setColumn(camera._actualTransform, 3, newOrigin, camera._actualTransform);\n}\n\nvar scratchCartesian = new Cartesian3();\n\nfunction updateMembers(camera) {\n  var mode = camera._mode;\n  var heightChanged = false;\n  var height = 0.0;\n\n  if (mode === SceneMode.SCENE2D) {\n    height = camera.frustum.right - camera.frustum.left;\n    heightChanged = height !== camera._positionCartographic.height;\n  }\n\n  var position = camera._position;\n  var positionChanged = !Cartesian3.equals(position, camera.position) || heightChanged;\n\n  if (positionChanged) {\n    position = Cartesian3.clone(camera.position, camera._position);\n  }\n\n  var direction = camera._direction;\n  var directionChanged = !Cartesian3.equals(direction, camera.direction);\n\n  if (directionChanged) {\n    Cartesian3.normalize(camera.direction, camera.direction);\n    direction = Cartesian3.clone(camera.direction, camera._direction);\n  }\n\n  var up = camera._up;\n  var upChanged = !Cartesian3.equals(up, camera.up);\n\n  if (upChanged) {\n    Cartesian3.normalize(camera.up, camera.up);\n    up = Cartesian3.clone(camera.up, camera._up);\n  }\n\n  var right = camera._right;\n  var rightChanged = !Cartesian3.equals(right, camera.right);\n\n  if (rightChanged) {\n    Cartesian3.normalize(camera.right, camera.right);\n    right = Cartesian3.clone(camera.right, camera._right);\n  }\n\n  var transformChanged = camera._transformChanged || camera._modeChanged;\n  camera._transformChanged = false;\n\n  if (transformChanged) {\n    Matrix4.inverseTransformation(camera._transform, camera._invTransform);\n\n    if (camera._mode === SceneMode.COLUMBUS_VIEW || camera._mode === SceneMode.SCENE2D) {\n      if (Matrix4.equals(Matrix4.IDENTITY, camera._transform)) {\n        Matrix4.clone(Camera.TRANSFORM_2D, camera._actualTransform);\n      } else if (camera._mode === SceneMode.COLUMBUS_VIEW) {\n        convertTransformForColumbusView(camera);\n      } else {\n        convertTransformFor2D(camera);\n      }\n    } else {\n      Matrix4.clone(camera._transform, camera._actualTransform);\n    }\n\n    Matrix4.inverseTransformation(camera._actualTransform, camera._actualInvTransform);\n    camera._modeChanged = false;\n  }\n\n  var transform = camera._actualTransform;\n\n  if (positionChanged || transformChanged) {\n    camera._positionWC = Matrix4.multiplyByPoint(transform, position, camera._positionWC); // Compute the Cartographic position of the camera.\n\n    if (mode === SceneMode.SCENE3D || mode === SceneMode.MORPHING) {\n      camera._positionCartographic = camera._projection.ellipsoid.cartesianToCartographic(camera._positionWC, camera._positionCartographic);\n    } else {\n      // The camera position is expressed in the 2D coordinate system where the Y axis is to the East,\n      // the Z axis is to the North, and the X axis is out of the map.  Express them instead in the ENU axes where\n      // X is to the East, Y is to the North, and Z is out of the local horizontal plane.\n      var positionENU = scratchCartesian;\n      positionENU.x = camera._positionWC.y;\n      positionENU.y = camera._positionWC.z;\n      positionENU.z = camera._positionWC.x; // In 2D, the camera height is always 12.7 million meters.\n      // The apparent height is equal to half the frustum width.\n\n      if (mode === SceneMode.SCENE2D) {\n        positionENU.z = height;\n      }\n\n      camera._projection.unproject(positionENU, camera._positionCartographic);\n    }\n  }\n\n  if (directionChanged || upChanged || rightChanged) {\n    var det = Cartesian3.dot(direction, Cartesian3.cross(up, right, scratchCartesian));\n\n    if (Math.abs(1.0 - det) > CesiumMath.EPSILON2) {\n      //orthonormalize axes\n      var invUpMag = 1.0 / Cartesian3.magnitudeSquared(up);\n      var scalar = Cartesian3.dot(up, direction) * invUpMag;\n      var w0 = Cartesian3.multiplyByScalar(direction, scalar, scratchCartesian);\n      up = Cartesian3.normalize(Cartesian3.subtract(up, w0, camera._up), camera._up);\n      Cartesian3.clone(up, camera.up);\n      right = Cartesian3.cross(direction, up, camera._right);\n      Cartesian3.clone(right, camera.right);\n    }\n  }\n\n  if (directionChanged || transformChanged) {\n    camera._directionWC = Matrix4.multiplyByPointAsVector(transform, direction, camera._directionWC);\n    Cartesian3.normalize(camera._directionWC, camera._directionWC);\n  }\n\n  if (upChanged || transformChanged) {\n    camera._upWC = Matrix4.multiplyByPointAsVector(transform, up, camera._upWC);\n    Cartesian3.normalize(camera._upWC, camera._upWC);\n  }\n\n  if (rightChanged || transformChanged) {\n    camera._rightWC = Matrix4.multiplyByPointAsVector(transform, right, camera._rightWC);\n    Cartesian3.normalize(camera._rightWC, camera._rightWC);\n  }\n\n  if (positionChanged || directionChanged || upChanged || rightChanged || transformChanged) {\n    updateViewMatrix(camera);\n  }\n}\n\nfunction getHeading(direction, up) {\n  var heading;\n\n  if (!CesiumMath.equalsEpsilon(Math.abs(direction.z), 1.0, CesiumMath.EPSILON3)) {\n    heading = Math.atan2(direction.y, direction.x) - CesiumMath.PI_OVER_TWO;\n  } else {\n    heading = Math.atan2(up.y, up.x) - CesiumMath.PI_OVER_TWO;\n  }\n\n  return CesiumMath.TWO_PI - CesiumMath.zeroToTwoPi(heading);\n}\n\nfunction getPitch(direction) {\n  return CesiumMath.PI_OVER_TWO - CesiumMath.acosClamped(direction.z);\n}\n\nfunction getRoll(direction, up, right) {\n  var roll = 0.0;\n\n  if (!CesiumMath.equalsEpsilon(Math.abs(direction.z), 1.0, CesiumMath.EPSILON3)) {\n    roll = Math.atan2(-right.z, up.z);\n    roll = CesiumMath.zeroToTwoPi(roll + CesiumMath.TWO_PI);\n  }\n\n  return roll;\n}\n\nvar scratchHPRMatrix1 = new Matrix4();\nvar scratchHPRMatrix2 = new Matrix4();\nObject.defineProperties(Camera.prototype, {\n  /**\n   * Gets the camera's reference frame. The inverse of this transformation is appended to the view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @default {@link Matrix4.IDENTITY}\n   */\n  transform: {\n    get: function get() {\n      return this._transform;\n    }\n  },\n\n  /**\n   * Gets the inverse camera transform.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @default {@link Matrix4.IDENTITY}\n   */\n  inverseTransform: {\n    get: function get() {\n      updateMembers(this);\n      return this._invTransform;\n    }\n  },\n\n  /**\n   * Gets the view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see Camera#inverseViewMatrix\n   */\n  viewMatrix: {\n    get: function get() {\n      updateMembers(this);\n      return this._viewMatrix;\n    }\n  },\n\n  /**\n   * Gets the inverse view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see Camera#viewMatrix\n   */\n  inverseViewMatrix: {\n    get: function get() {\n      updateMembers(this);\n      return this._invViewMatrix;\n    }\n  },\n\n  /**\n   * Gets the {@link Cartographic} position of the camera, with longitude and latitude\n   * expressed in radians and height in meters.  In 2D and Columbus View, it is possible\n   * for the returned longitude and latitude to be outside the range of valid longitudes\n   * and latitudes when the camera is outside the map.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartographic}\n   * @readonly\n   */\n  positionCartographic: {\n    get: function get() {\n      updateMembers(this);\n      return this._positionCartographic;\n    }\n  },\n\n  /**\n   * Gets the position of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  positionWC: {\n    get: function get() {\n      updateMembers(this);\n      return this._positionWC;\n    }\n  },\n\n  /**\n   * Gets the view direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  directionWC: {\n    get: function get() {\n      updateMembers(this);\n      return this._directionWC;\n    }\n  },\n\n  /**\n   * Gets the up direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  upWC: {\n    get: function get() {\n      updateMembers(this);\n      return this._upWC;\n    }\n  },\n\n  /**\n   * Gets the right direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  rightWC: {\n    get: function get() {\n      updateMembers(this);\n      return this._rightWC;\n    }\n  },\n\n  /**\n   * Gets the camera heading in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  heading: {\n    get: function get() {\n      if (this._mode !== SceneMode.MORPHING) {\n        var ellipsoid = this._projection.ellipsoid;\n        var oldTransform = Matrix4.clone(this._transform, scratchHPRMatrix1);\n        var transform = Transforms.eastNorthUpToFixedFrame(this.positionWC, ellipsoid, scratchHPRMatrix2);\n\n        this._setTransform(transform);\n\n        var heading = getHeading(this.direction, this.up);\n\n        this._setTransform(oldTransform);\n\n        return heading;\n      }\n\n      return undefined;\n    }\n  },\n\n  /**\n   * Gets the camera pitch in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  pitch: {\n    get: function get() {\n      if (this._mode !== SceneMode.MORPHING) {\n        var ellipsoid = this._projection.ellipsoid;\n        var oldTransform = Matrix4.clone(this._transform, scratchHPRMatrix1);\n        var transform = Transforms.eastNorthUpToFixedFrame(this.positionWC, ellipsoid, scratchHPRMatrix2);\n\n        this._setTransform(transform);\n\n        var pitch = getPitch(this.direction);\n\n        this._setTransform(oldTransform);\n\n        return pitch;\n      }\n\n      return undefined;\n    }\n  },\n\n  /**\n   * Gets the camera roll in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  roll: {\n    get: function get() {\n      if (this._mode !== SceneMode.MORPHING) {\n        var ellipsoid = this._projection.ellipsoid;\n        var oldTransform = Matrix4.clone(this._transform, scratchHPRMatrix1);\n        var transform = Transforms.eastNorthUpToFixedFrame(this.positionWC, ellipsoid, scratchHPRMatrix2);\n\n        this._setTransform(transform);\n\n        var roll = getRoll(this.direction, this.up, this.right);\n\n        this._setTransform(oldTransform);\n\n        return roll;\n      }\n\n      return undefined;\n    }\n  },\n\n  /**\n   * Gets the event that will be raised at when the camera starts to move.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  moveStart: {\n    get: function get() {\n      return this._moveStart;\n    }\n  },\n\n  /**\n   * Gets the event that will be raised when the camera has stopped moving.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  moveEnd: {\n    get: function get() {\n      return this._moveEnd;\n    }\n  },\n\n  /**\n   * Gets the event that will be raised when the camera has changed by <code>percentageChanged</code>.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  changed: {\n    get: function get() {\n      return this._changed;\n    }\n  }\n});\n/**\n * @private\n */\n\nCamera.prototype.update = function (mode) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(mode)) {\n    throw new DeveloperError(\"mode is required.\");\n  }\n\n  if (mode === SceneMode.SCENE2D && !(this.frustum instanceof OrthographicOffCenterFrustum)) {\n    throw new DeveloperError(\"An OrthographicOffCenterFrustum is required in 2D.\");\n  }\n\n  if ((mode === SceneMode.SCENE3D || mode === SceneMode.COLUMBUS_VIEW) && !(this.frustum instanceof PerspectiveFrustum) && !(this.frustum instanceof OrthographicFrustum)) {\n    throw new DeveloperError(\"A PerspectiveFrustum or OrthographicFrustum is required in 3D and Columbus view\");\n  } //>>includeEnd('debug');\n\n\n  var updateFrustum = false;\n\n  if (mode !== this._mode) {\n    this._mode = mode;\n    this._modeChanged = mode !== SceneMode.MORPHING;\n    updateFrustum = this._mode === SceneMode.SCENE2D;\n  }\n\n  if (updateFrustum) {\n    var frustum = this._max2Dfrustum = this.frustum.clone(); //>>includeStart('debug', pragmas.debug);\n\n    if (!(frustum instanceof OrthographicOffCenterFrustum)) {\n      throw new DeveloperError(\"The camera frustum is expected to be orthographic for 2D camera control.\");\n    } //>>includeEnd('debug');\n\n\n    var maxZoomOut = 2.0;\n    var ratio = frustum.top / frustum.right;\n    frustum.right = this._maxCoord.x * maxZoomOut;\n    frustum.left = -frustum.right;\n    frustum.top = ratio * frustum.right;\n    frustum.bottom = -frustum.top;\n  }\n\n  if (this._mode === SceneMode.SCENE2D) {\n    clampMove2D(this, this.position);\n  }\n};\n\nvar setTransformPosition = new Cartesian3();\nvar setTransformUp = new Cartesian3();\nvar setTransformDirection = new Cartesian3();\n\nCamera.prototype._setTransform = function (transform) {\n  var position = Cartesian3.clone(this.positionWC, setTransformPosition);\n  var up = Cartesian3.clone(this.upWC, setTransformUp);\n  var direction = Cartesian3.clone(this.directionWC, setTransformDirection);\n  Matrix4.clone(transform, this._transform);\n  this._transformChanged = true;\n  updateMembers(this);\n  var inverse = this._actualInvTransform;\n  Matrix4.multiplyByPoint(inverse, position, this.position);\n  Matrix4.multiplyByPointAsVector(inverse, direction, this.direction);\n  Matrix4.multiplyByPointAsVector(inverse, up, this.up);\n  Cartesian3.cross(this.direction, this.up, this.right);\n  updateMembers(this);\n};\n\nvar scratchAdjustOrtghographicFrustumMousePosition = new Cartesian2();\nvar pickGlobeScratchRay = new Ray();\nvar scratchRayIntersection = new Cartesian3();\nvar scratchDepthIntersection = new Cartesian3();\n\nCamera.prototype._adjustOrthographicFrustum = function (zooming) {\n  if (!(this.frustum instanceof OrthographicFrustum)) {\n    return;\n  }\n\n  if (!zooming && this._positionCartographic.height < 150000.0) {\n    return;\n  }\n\n  if (!Matrix4.equals(Matrix4.IDENTITY, this.transform)) {\n    this.frustum.width = Cartesian3.magnitude(this.position);\n    return;\n  }\n\n  var scene = this._scene;\n  var globe = scene.globe;\n  var rayIntersection;\n  var depthIntersection;\n\n  if (defined(globe)) {\n    var mousePosition = scratchAdjustOrtghographicFrustumMousePosition;\n    mousePosition.x = scene.drawingBufferWidth / 2.0;\n    mousePosition.y = scene.drawingBufferHeight / 2.0;\n    var ray = this.getPickRay(mousePosition, pickGlobeScratchRay);\n    rayIntersection = globe.pickWorldCoordinates(ray, scene, scratchRayIntersection);\n\n    if (scene.pickPositionSupported) {\n      depthIntersection = scene.pickPositionWorldCoordinates(mousePosition, scratchDepthIntersection);\n    }\n\n    if (defined(rayIntersection) && defined(depthIntersection)) {\n      var depthDistance = defined(depthIntersection) ? Cartesian3.distance(depthIntersection, this.positionWC) : Number.POSITIVE_INFINITY;\n      var rayDistance = defined(rayIntersection) ? Cartesian3.distance(rayIntersection, this.positionWC) : Number.POSITIVE_INFINITY;\n      this.frustum.width = Math.min(depthDistance, rayDistance);\n    } else if (defined(depthIntersection)) {\n      this.frustum.width = Cartesian3.distance(depthIntersection, this.positionWC);\n    } else if (defined(rayIntersection)) {\n      this.frustum.width = Cartesian3.distance(rayIntersection, this.positionWC);\n    }\n  }\n\n  if (!defined(globe) || !defined(rayIntersection) && !defined(depthIntersection)) {\n    var distance = Math.max(this.positionCartographic.height, 0.0);\n    this.frustum.width = distance;\n  }\n};\n\nvar scratchSetViewCartesian = new Cartesian3();\nvar scratchSetViewTransform1 = new Matrix4();\nvar scratchSetViewTransform2 = new Matrix4();\nvar scratchSetViewQuaternion = new Quaternion();\nvar scratchSetViewMatrix3 = new Matrix3();\nvar scratchSetViewCartographic = new Cartographic();\n\nfunction setView3D(camera, position, hpr) {\n  var currentTransform = Matrix4.clone(camera.transform, scratchSetViewTransform1);\n  var localTransform = Transforms.eastNorthUpToFixedFrame(position, camera._projection.ellipsoid, scratchSetViewTransform2);\n\n  camera._setTransform(localTransform);\n\n  Cartesian3.clone(Cartesian3.ZERO, camera.position);\n  hpr.heading = hpr.heading - CesiumMath.PI_OVER_TWO;\n  var rotQuat = Quaternion.fromHeadingPitchRoll(hpr, scratchSetViewQuaternion);\n  var rotMat = Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n  Matrix3.getColumn(rotMat, 0, camera.direction);\n  Matrix3.getColumn(rotMat, 2, camera.up);\n  Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n  camera._setTransform(currentTransform);\n\n  camera._adjustOrthographicFrustum(true);\n}\n\nfunction setViewCV(camera, position, hpr, convert) {\n  var currentTransform = Matrix4.clone(camera.transform, scratchSetViewTransform1);\n\n  camera._setTransform(Matrix4.IDENTITY);\n\n  if (!Cartesian3.equals(position, camera.positionWC)) {\n    if (convert) {\n      var projection = camera._projection;\n      var cartographic = projection.ellipsoid.cartesianToCartographic(position, scratchSetViewCartographic);\n      position = projection.project(cartographic, scratchSetViewCartesian);\n    }\n\n    Cartesian3.clone(position, camera.position);\n  }\n\n  hpr.heading = hpr.heading - CesiumMath.PI_OVER_TWO;\n  var rotQuat = Quaternion.fromHeadingPitchRoll(hpr, scratchSetViewQuaternion);\n  var rotMat = Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n  Matrix3.getColumn(rotMat, 0, camera.direction);\n  Matrix3.getColumn(rotMat, 2, camera.up);\n  Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n  camera._setTransform(currentTransform);\n\n  camera._adjustOrthographicFrustum(true);\n}\n\nfunction setView2D(camera, position, hpr, convert) {\n  var currentTransform = Matrix4.clone(camera.transform, scratchSetViewTransform1);\n\n  camera._setTransform(Matrix4.IDENTITY);\n\n  if (!Cartesian3.equals(position, camera.positionWC)) {\n    if (convert) {\n      var projection = camera._projection;\n      var cartographic = projection.ellipsoid.cartesianToCartographic(position, scratchSetViewCartographic);\n      position = projection.project(cartographic, scratchSetViewCartesian);\n    }\n\n    Cartesian2.clone(position, camera.position);\n    var newLeft = -position.z * 0.5;\n    var newRight = -newLeft;\n    var frustum = camera.frustum;\n\n    if (newRight > newLeft) {\n      var ratio = frustum.top / frustum.right;\n      frustum.right = newRight;\n      frustum.left = newLeft;\n      frustum.top = frustum.right * ratio;\n      frustum.bottom = -frustum.top;\n    }\n  }\n\n  if (camera._scene.mapMode2D === MapMode2D.ROTATE) {\n    hpr.heading = hpr.heading - CesiumMath.PI_OVER_TWO;\n    hpr.pitch = -CesiumMath.PI_OVER_TWO;\n    hpr.roll = 0.0;\n    var rotQuat = Quaternion.fromHeadingPitchRoll(hpr, scratchSetViewQuaternion);\n    var rotMat = Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n    Matrix3.getColumn(rotMat, 2, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n  }\n\n  camera._setTransform(currentTransform);\n}\n\nvar scratchToHPRDirection = new Cartesian3();\nvar scratchToHPRUp = new Cartesian3();\nvar scratchToHPRRight = new Cartesian3();\n\nfunction directionUpToHeadingPitchRoll(camera, position, orientation, result) {\n  var direction = Cartesian3.clone(orientation.direction, scratchToHPRDirection);\n  var up = Cartesian3.clone(orientation.up, scratchToHPRUp);\n\n  if (camera._scene.mode === SceneMode.SCENE3D) {\n    var ellipsoid = camera._projection.ellipsoid;\n    var transform = Transforms.eastNorthUpToFixedFrame(position, ellipsoid, scratchHPRMatrix1);\n    var invTransform = Matrix4.inverseTransformation(transform, scratchHPRMatrix2);\n    Matrix4.multiplyByPointAsVector(invTransform, direction, direction);\n    Matrix4.multiplyByPointAsVector(invTransform, up, up);\n  }\n\n  var right = Cartesian3.cross(direction, up, scratchToHPRRight);\n  result.heading = getHeading(direction, up);\n  result.pitch = getPitch(direction);\n  result.roll = getRoll(direction, up, right);\n  return result;\n}\n\nvar scratchSetViewOptions = {\n  destination: undefined,\n  orientation: {\n    direction: undefined,\n    up: undefined,\n    heading: undefined,\n    pitch: undefined,\n    roll: undefined\n  },\n  convert: undefined,\n  endTransform: undefined\n};\nvar scratchHpr = new HeadingPitchRoll();\n/**\n * Sets the camera position, orientation and transform.\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3|Rectangle} [options.destination] The final position of the camera in WGS84 (world) coordinates or a rectangle that would be visible from a top-down view.\n * @param {Object} [options.orientation] An object that contains either direction and up properties or heading, pitch and roll properties. By default, the direction will point\n * towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive\n * y direction in Columbus view. Orientation is not used in 2D when in infinite scrolling mode.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame of the camera.\n * @param {Boolean} [options.convert] Whether to convert the destination from world coordinates to scene coordinates (only relevant when not using 3D). Defaults to <code>true</code>.\n *\n * @example\n * // 1. Set position with a top-down view\n * viewer.camera.setView({\n *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)\n * });\n *\n * // 2 Set view with heading, pitch and roll\n * viewer.camera.setView({\n *     destination : cartesianPosition,\n *     orientation: {\n *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)\n *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)\n *         roll : 0.0                             // default value\n *     }\n * });\n *\n * // 3. Change heading, pitch and roll with the camera position remaining the same.\n * viewer.camera.setView({\n *     orientation: {\n *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)\n *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)\n *         roll : 0.0                             // default value\n *     }\n * });\n *\n *\n * // 4. View rectangle with a top-down view\n * viewer.camera.setView({\n *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)\n * });\n *\n * // 5. Set position with an orientation using unit vectors.\n * viewer.camera.setView({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),\n *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)\n *     }\n * });\n */\n\nCamera.prototype.setView = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var orientation = defaultValue(options.orientation, defaultValue.EMPTY_OBJECT);\n  var mode = this._mode;\n\n  if (mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  if (defined(options.endTransform)) {\n    this._setTransform(options.endTransform);\n  }\n\n  var convert = defaultValue(options.convert, true);\n  var destination = defaultValue(options.destination, Cartesian3.clone(this.positionWC, scratchSetViewCartesian));\n\n  if (defined(destination) && defined(destination.west)) {\n    destination = this.getRectangleCameraCoordinates(destination, scratchSetViewCartesian);\n    convert = false;\n  }\n\n  if (defined(orientation.direction)) {\n    orientation = directionUpToHeadingPitchRoll(this, destination, orientation, scratchSetViewOptions.orientation);\n  }\n\n  scratchHpr.heading = defaultValue(orientation.heading, 0.0);\n  scratchHpr.pitch = defaultValue(orientation.pitch, -CesiumMath.PI_OVER_TWO);\n  scratchHpr.roll = defaultValue(orientation.roll, 0.0);\n\n  if (mode === SceneMode.SCENE3D) {\n    setView3D(this, destination, scratchHpr);\n  } else if (mode === SceneMode.SCENE2D) {\n    setView2D(this, destination, scratchHpr, convert);\n  } else {\n    setViewCV(this, destination, scratchHpr, convert);\n  }\n};\n\nvar pitchScratch = new Cartesian3();\n/**\n * Fly the camera to the home view.  Use {@link Camera#.DEFAULT_VIEW_RECTANGLE} to set\n * the default view for the 3D scene.  The home view for 2D and columbus view shows the\n * entire map.\n *\n * @param {Number} [duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight. See {@link Camera#flyTo}\n */\n\nCamera.prototype.flyHome = function (duration) {\n  var mode = this._mode;\n\n  if (mode === SceneMode.MORPHING) {\n    this._scene.completeMorph();\n  }\n\n  if (mode === SceneMode.SCENE2D) {\n    this.flyTo({\n      destination: Camera.DEFAULT_VIEW_RECTANGLE,\n      duration: duration,\n      endTransform: Matrix4.IDENTITY\n    });\n  } else if (mode === SceneMode.SCENE3D) {\n    var destination = this.getRectangleCameraCoordinates(Camera.DEFAULT_VIEW_RECTANGLE);\n    var mag = Cartesian3.magnitude(destination);\n    mag += mag * Camera.DEFAULT_VIEW_FACTOR;\n    Cartesian3.normalize(destination, destination);\n    Cartesian3.multiplyByScalar(destination, mag, destination);\n    this.flyTo({\n      destination: destination,\n      duration: duration,\n      endTransform: Matrix4.IDENTITY\n    });\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    var maxRadii = this._projection.ellipsoid.maximumRadius;\n    var position = new Cartesian3(0.0, -1.0, 1.0);\n    position = Cartesian3.multiplyByScalar(Cartesian3.normalize(position, position), 5.0 * maxRadii, position);\n    this.flyTo({\n      destination: position,\n      duration: duration,\n      orientation: {\n        heading: 0.0,\n        pitch: -Math.acos(Cartesian3.normalize(position, pitchScratch).z),\n        roll: 0.0\n      },\n      endTransform: Matrix4.IDENTITY,\n      convert: false\n    });\n  }\n};\n/**\n * Transform a vector or point from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian4} cartesian The vector or point to transform.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The transformed vector or point.\n */\n\n\nCamera.prototype.worldToCameraCoordinates = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n\n  updateMembers(this);\n  return Matrix4.multiplyByVector(this._actualInvTransform, cartesian, result);\n};\n/**\n * Transform a point from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian3} cartesian The point to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed point.\n */\n\n\nCamera.prototype.worldToCameraCoordinatesPoint = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  updateMembers(this);\n  return Matrix4.multiplyByPoint(this._actualInvTransform, cartesian, result);\n};\n/**\n * Transform a vector from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian3} cartesian The vector to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed vector.\n */\n\n\nCamera.prototype.worldToCameraCoordinatesVector = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  updateMembers(this);\n  return Matrix4.multiplyByPointAsVector(this._actualInvTransform, cartesian, result);\n};\n/**\n * Transform a vector or point from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian4} cartesian The vector or point to transform.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The transformed vector or point.\n */\n\n\nCamera.prototype.cameraToWorldCoordinates = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n\n  updateMembers(this);\n  return Matrix4.multiplyByVector(this._actualTransform, cartesian, result);\n};\n/**\n * Transform a point from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian3} cartesian The point to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed point.\n */\n\n\nCamera.prototype.cameraToWorldCoordinatesPoint = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  updateMembers(this);\n  return Matrix4.multiplyByPoint(this._actualTransform, cartesian, result);\n};\n/**\n * Transform a vector from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian3} cartesian The vector to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed vector.\n */\n\n\nCamera.prototype.cameraToWorldCoordinatesVector = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  updateMembers(this);\n  return Matrix4.multiplyByPointAsVector(this._actualTransform, cartesian, result);\n};\n\nfunction clampMove2D(camera, position) {\n  var rotatable2D = camera._scene.mapMode2D === MapMode2D.ROTATE;\n  var maxProjectedX = camera._maxCoord.x;\n  var maxProjectedY = camera._maxCoord.y;\n  var minX;\n  var maxX;\n\n  if (rotatable2D) {\n    maxX = maxProjectedX;\n    minX = -maxX;\n  } else {\n    maxX = position.x - maxProjectedX * 2.0;\n    minX = position.x + maxProjectedX * 2.0;\n  }\n\n  if (position.x > maxProjectedX) {\n    position.x = maxX;\n  }\n\n  if (position.x < -maxProjectedX) {\n    position.x = minX;\n  }\n\n  if (position.y > maxProjectedY) {\n    position.y = maxProjectedY;\n  }\n\n  if (position.y < -maxProjectedY) {\n    position.y = -maxProjectedY;\n  }\n}\n\nvar moveScratch = new Cartesian3();\n/**\n * Translates the camera's position by <code>amount</code> along <code>direction</code>.\n *\n * @param {Cartesian3} direction The direction to move.\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveBackward\n * @see Camera#moveForward\n * @see Camera#moveLeft\n * @see Camera#moveRight\n * @see Camera#moveUp\n * @see Camera#moveDown\n */\n\nCamera.prototype.move = function (direction, amount) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  } //>>includeEnd('debug');\n\n\n  var cameraPosition = this.position;\n  Cartesian3.multiplyByScalar(direction, amount, moveScratch);\n  Cartesian3.add(cameraPosition, moveScratch, cameraPosition);\n\n  if (this._mode === SceneMode.SCENE2D) {\n    clampMove2D(this, cameraPosition);\n  }\n\n  this._adjustOrthographicFrustum(true);\n};\n/**\n * Translates the camera's position by <code>amount</code> along the camera's view vector.\n * When in 2D mode, this will zoom in the camera instead of translating the camera's position.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveBackward\n */\n\n\nCamera.prototype.moveForward = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n\n  if (this._mode === SceneMode.SCENE2D) {\n    // 2D mode\n    zoom2D(this, amount);\n  } else {\n    // 3D or Columbus view mode\n    this.move(this.direction, amount);\n  }\n};\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's view vector.\n * When in 2D mode, this will zoom out the camera instead of translating the camera's position.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveForward\n */\n\n\nCamera.prototype.moveBackward = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n\n  if (this._mode === SceneMode.SCENE2D) {\n    // 2D mode\n    zoom2D(this, -amount);\n  } else {\n    // 3D or Columbus view mode\n    this.move(this.direction, -amount);\n  }\n};\n/**\n * Translates the camera's position by <code>amount</code> along the camera's up vector.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveDown\n */\n\n\nCamera.prototype.moveUp = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.up, amount);\n};\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's up vector.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveUp\n */\n\n\nCamera.prototype.moveDown = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.up, -amount);\n};\n/**\n * Translates the camera's position by <code>amount</code> along the camera's right vector.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveLeft\n */\n\n\nCamera.prototype.moveRight = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.right, amount);\n};\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's right vector.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveRight\n */\n\n\nCamera.prototype.moveLeft = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.right, -amount);\n};\n/**\n * Rotates the camera around its up vector by amount, in radians, in the opposite direction\n * of its right vector if not in 2D mode.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookRight\n */\n\n\nCamera.prototype.lookLeft = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount); // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.up, -amount);\n  }\n};\n/**\n * Rotates the camera around its up vector by amount, in radians, in the direction\n * of its right vector if not in 2D mode.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookLeft\n */\n\n\nCamera.prototype.lookRight = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount); // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.up, amount);\n  }\n};\n/**\n * Rotates the camera around its right vector by amount, in radians, in the direction\n * of its up vector if not in 2D mode.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookDown\n */\n\n\nCamera.prototype.lookUp = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount); // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.right, -amount);\n  }\n};\n/**\n * Rotates the camera around its right vector by amount, in radians, in the opposite direction\n * of its up vector if not in 2D mode.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookUp\n */\n\n\nCamera.prototype.lookDown = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount); // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.right, amount);\n  }\n};\n\nvar lookScratchQuaternion = new Quaternion();\nvar lookScratchMatrix = new Matrix3();\n/**\n * Rotate each of the camera's orientation vectors around <code>axis</code> by <code>angle</code>\n *\n * @param {Cartesian3} axis The axis to rotate around.\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookUp\n * @see Camera#lookDown\n * @see Camera#lookLeft\n * @see Camera#lookRight\n */\n\nCamera.prototype.look = function (axis, angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(axis)) {\n    throw new DeveloperError(\"axis is required.\");\n  } //>>includeEnd('debug');\n\n\n  var turnAngle = defaultValue(angle, this.defaultLookAmount);\n  var quaternion = Quaternion.fromAxisAngle(axis, -turnAngle, lookScratchQuaternion);\n  var rotation = Matrix3.fromQuaternion(quaternion, lookScratchMatrix);\n  var direction = this.direction;\n  var up = this.up;\n  var right = this.right;\n  Matrix3.multiplyByVector(rotation, direction, direction);\n  Matrix3.multiplyByVector(rotation, up, up);\n  Matrix3.multiplyByVector(rotation, right, right);\n};\n/**\n * Rotate the camera counter-clockwise around its direction vector by amount, in radians.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#twistRight\n */\n\n\nCamera.prototype.twistLeft = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n  this.look(this.direction, amount);\n};\n/**\n * Rotate the camera clockwise around its direction vector by amount, in radians.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#twistLeft\n */\n\n\nCamera.prototype.twistRight = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n  this.look(this.direction, -amount);\n};\n\nvar rotateScratchQuaternion = new Quaternion();\nvar rotateScratchMatrix = new Matrix3();\n/**\n * Rotates the camera around <code>axis</code> by <code>angle</code>. The distance\n * of the camera's position to the center of the camera's reference frame remains the same.\n *\n * @param {Cartesian3} axis The axis to rotate around given in world coordinates.\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateUp\n * @see Camera#rotateDown\n * @see Camera#rotateLeft\n * @see Camera#rotateRight\n */\n\nCamera.prototype.rotate = function (axis, angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(axis)) {\n    throw new DeveloperError(\"axis is required.\");\n  } //>>includeEnd('debug');\n\n\n  var turnAngle = defaultValue(angle, this.defaultRotateAmount);\n  var quaternion = Quaternion.fromAxisAngle(axis, -turnAngle, rotateScratchQuaternion);\n  var rotation = Matrix3.fromQuaternion(quaternion, rotateScratchMatrix);\n  Matrix3.multiplyByVector(rotation, this.position, this.position);\n  Matrix3.multiplyByVector(rotation, this.direction, this.direction);\n  Matrix3.multiplyByVector(rotation, this.up, this.up);\n  Cartesian3.cross(this.direction, this.up, this.right);\n  Cartesian3.cross(this.right, this.direction, this.up);\n\n  this._adjustOrthographicFrustum(false);\n};\n/**\n * Rotates the camera around the center of the camera's reference frame by angle downwards.\n *\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateUp\n * @see Camera#rotate\n */\n\n\nCamera.prototype.rotateDown = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateVertical(this, angle);\n};\n/**\n * Rotates the camera around the center of the camera's reference frame by angle upwards.\n *\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateDown\n * @see Camera#rotate\n */\n\n\nCamera.prototype.rotateUp = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateVertical(this, -angle);\n};\n\nvar rotateVertScratchP = new Cartesian3();\nvar rotateVertScratchA = new Cartesian3();\nvar rotateVertScratchTan = new Cartesian3();\nvar rotateVertScratchNegate = new Cartesian3();\n\nfunction rotateVertical(camera, angle) {\n  var position = camera.position;\n\n  if (defined(camera.constrainedAxis) && !Cartesian3.equalsEpsilon(camera.position, Cartesian3.ZERO, CesiumMath.EPSILON2)) {\n    var p = Cartesian3.normalize(position, rotateVertScratchP);\n    var northParallel = Cartesian3.equalsEpsilon(p, camera.constrainedAxis, CesiumMath.EPSILON2);\n    var southParallel = Cartesian3.equalsEpsilon(p, Cartesian3.negate(camera.constrainedAxis, rotateVertScratchNegate), CesiumMath.EPSILON2);\n\n    if (!northParallel && !southParallel) {\n      var constrainedAxis = Cartesian3.normalize(camera.constrainedAxis, rotateVertScratchA);\n      var dot = Cartesian3.dot(p, constrainedAxis);\n      var angleToAxis = CesiumMath.acosClamped(dot);\n\n      if (angle > 0 && angle > angleToAxis) {\n        angle = angleToAxis - CesiumMath.EPSILON4;\n      }\n\n      dot = Cartesian3.dot(p, Cartesian3.negate(constrainedAxis, rotateVertScratchNegate));\n      angleToAxis = CesiumMath.acosClamped(dot);\n\n      if (angle < 0 && -angle > angleToAxis) {\n        angle = -angleToAxis + CesiumMath.EPSILON4;\n      }\n\n      var tangent = Cartesian3.cross(constrainedAxis, p, rotateVertScratchTan);\n      camera.rotate(tangent, angle);\n    } else if (northParallel && angle < 0 || southParallel && angle > 0) {\n      camera.rotate(camera.right, angle);\n    }\n  } else {\n    camera.rotate(camera.right, angle);\n  }\n}\n/**\n * Rotates the camera around the center of the camera's reference frame by angle to the right.\n *\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateLeft\n * @see Camera#rotate\n */\n\n\nCamera.prototype.rotateRight = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateHorizontal(this, -angle);\n};\n/**\n * Rotates the camera around the center of the camera's reference frame by angle to the left.\n *\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateRight\n * @see Camera#rotate\n */\n\n\nCamera.prototype.rotateLeft = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateHorizontal(this, angle);\n};\n\nfunction rotateHorizontal(camera, angle) {\n  if (defined(camera.constrainedAxis)) {\n    camera.rotate(camera.constrainedAxis, angle);\n  } else {\n    camera.rotate(camera.up, angle);\n  }\n}\n\nfunction zoom2D(camera, amount) {\n  var frustum = camera.frustum; //>>includeStart('debug', pragmas.debug);\n\n  if (!(frustum instanceof OrthographicOffCenterFrustum) || !defined(frustum.left) || !defined(frustum.right) || !defined(frustum.bottom) || !defined(frustum.top)) {\n    throw new DeveloperError(\"The camera frustum is expected to be orthographic for 2D camera control.\");\n  } //>>includeEnd('debug');\n\n\n  var ratio;\n  amount = amount * 0.5;\n\n  if (Math.abs(frustum.top) + Math.abs(frustum.bottom) > Math.abs(frustum.left) + Math.abs(frustum.right)) {\n    var newTop = frustum.top - amount;\n    var newBottom = frustum.bottom + amount;\n    var maxBottom = camera._maxCoord.y;\n\n    if (camera._scene.mapMode2D === MapMode2D.ROTATE) {\n      maxBottom *= camera.maximumZoomFactor;\n    }\n\n    if (newBottom > maxBottom) {\n      newBottom = maxBottom;\n      newTop = -maxBottom;\n    }\n\n    if (newTop <= newBottom) {\n      newTop = 1.0;\n      newBottom = -1.0;\n    }\n\n    ratio = frustum.right / frustum.top;\n    frustum.top = newTop;\n    frustum.bottom = newBottom;\n    frustum.right = frustum.top * ratio;\n    frustum.left = -frustum.right;\n  } else {\n    var newRight = frustum.right - amount;\n    var newLeft = frustum.left + amount;\n    var maxRight = camera._maxCoord.x;\n\n    if (camera._scene.mapMode2D === MapMode2D.ROTATE) {\n      maxRight *= camera.maximumZoomFactor;\n    }\n\n    if (newRight > maxRight) {\n      newRight = maxRight;\n      newLeft = -maxRight;\n    }\n\n    if (newRight <= newLeft) {\n      newRight = 1.0;\n      newLeft = -1.0;\n    }\n\n    ratio = frustum.top / frustum.right;\n    frustum.right = newRight;\n    frustum.left = newLeft;\n    frustum.top = frustum.right * ratio;\n    frustum.bottom = -frustum.top;\n  }\n}\n\nfunction zoom3D(camera, amount) {\n  camera.move(camera.direction, amount);\n}\n/**\n * Zooms <code>amount</code> along the camera's view vector.\n *\n * @param {Number} [amount] The amount to move. Defaults to <code>defaultZoomAmount</code>.\n *\n * @see Camera#zoomOut\n */\n\n\nCamera.prototype.zoomIn = function (amount) {\n  amount = defaultValue(amount, this.defaultZoomAmount);\n\n  if (this._mode === SceneMode.SCENE2D) {\n    zoom2D(this, amount);\n  } else {\n    zoom3D(this, amount);\n  }\n};\n/**\n * Zooms <code>amount</code> along the opposite direction of\n * the camera's view vector.\n *\n * @param {Number} [amount] The amount to move. Defaults to <code>defaultZoomAmount</code>.\n *\n * @see Camera#zoomIn\n */\n\n\nCamera.prototype.zoomOut = function (amount) {\n  amount = defaultValue(amount, this.defaultZoomAmount);\n\n  if (this._mode === SceneMode.SCENE2D) {\n    zoom2D(this, -amount);\n  } else {\n    zoom3D(this, -amount);\n  }\n};\n/**\n * Gets the magnitude of the camera position. In 3D, this is the vector magnitude. In 2D and\n * Columbus view, this is the distance to the map.\n *\n * @returns {Number} The magnitude of the position.\n */\n\n\nCamera.prototype.getMagnitude = function () {\n  if (this._mode === SceneMode.SCENE3D) {\n    return Cartesian3.magnitude(this.position);\n  } else if (this._mode === SceneMode.COLUMBUS_VIEW) {\n    return Math.abs(this.position.z);\n  } else if (this._mode === SceneMode.SCENE2D) {\n    return Math.max(this.frustum.right - this.frustum.left, this.frustum.top - this.frustum.bottom);\n  }\n};\n\nvar scratchLookAtMatrix4 = new Matrix4();\n/**\n * Sets the camera position and orientation using a target and offset. The target must be given in\n * world coordinates. The offset can be either a cartesian or heading/pitch/range in the local east-north-up reference frame centered at the target.\n * If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset\n * is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.\n *\n * In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.\n *\n * @param {Cartesian3} target The target position in world coordinates.\n * @param {Cartesian3|HeadingPitchRange} offset The offset from the target in the local east-north-up reference frame centered at the target.\n *\n * @exception {DeveloperError} lookAt is not supported while morphing.\n *\n * @example\n * // 1. Using a cartesian offset\n * var center = Cesium.Cartesian3.fromDegrees(-98.0, 40.0);\n * viewer.camera.lookAt(center, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));\n *\n * // 2. Using a HeadingPitchRange offset\n * var center = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);\n * var heading = Cesium.Math.toRadians(50.0);\n * var pitch = Cesium.Math.toRadians(-20.0);\n * var range = 5000.0;\n * viewer.camera.lookAt(center, new Cesium.HeadingPitchRange(heading, pitch, range));\n */\n\nCamera.prototype.lookAt = function (target, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(target)) {\n    throw new DeveloperError(\"target is required\");\n  }\n\n  if (!defined(offset)) {\n    throw new DeveloperError(\"offset is required\");\n  }\n\n  if (this._mode === SceneMode.MORPHING) {\n    throw new DeveloperError(\"lookAt is not supported while morphing.\");\n  } //>>includeEnd('debug');\n\n\n  var transform = Transforms.eastNorthUpToFixedFrame(target, Ellipsoid.WGS84, scratchLookAtMatrix4);\n  this.lookAtTransform(transform, offset);\n};\n\nvar scratchLookAtHeadingPitchRangeOffset = new Cartesian3();\nvar scratchLookAtHeadingPitchRangeQuaternion1 = new Quaternion();\nvar scratchLookAtHeadingPitchRangeQuaternion2 = new Quaternion();\nvar scratchHeadingPitchRangeMatrix3 = new Matrix3();\n\nfunction offsetFromHeadingPitchRange(heading, pitch, range) {\n  pitch = CesiumMath.clamp(pitch, -CesiumMath.PI_OVER_TWO, CesiumMath.PI_OVER_TWO);\n  heading = CesiumMath.zeroToTwoPi(heading) - CesiumMath.PI_OVER_TWO;\n  var pitchQuat = Quaternion.fromAxisAngle(Cartesian3.UNIT_Y, -pitch, scratchLookAtHeadingPitchRangeQuaternion1);\n  var headingQuat = Quaternion.fromAxisAngle(Cartesian3.UNIT_Z, -heading, scratchLookAtHeadingPitchRangeQuaternion2);\n  var rotQuat = Quaternion.multiply(headingQuat, pitchQuat, headingQuat);\n  var rotMatrix = Matrix3.fromQuaternion(rotQuat, scratchHeadingPitchRangeMatrix3);\n  var offset = Cartesian3.clone(Cartesian3.UNIT_X, scratchLookAtHeadingPitchRangeOffset);\n  Matrix3.multiplyByVector(rotMatrix, offset, offset);\n  Cartesian3.negate(offset, offset);\n  Cartesian3.multiplyByScalar(offset, range, offset);\n  return offset;\n}\n/**\n * Sets the camera position and orientation using a target and transformation matrix. The offset can be either a cartesian or heading/pitch/range.\n * If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset\n * is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.\n *\n * In 2D, there must be a top down view. The camera will be placed above the center of the reference frame. The height above the\n * target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.\n *\n * @param {Matrix4} transform The transformation matrix defining the reference frame.\n * @param {Cartesian3|HeadingPitchRange} [offset] The offset from the target in a reference frame centered at the target.\n *\n * @exception {DeveloperError} lookAtTransform is not supported while morphing.\n *\n * @example\n * // 1. Using a cartesian offset\n * var transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-98.0, 40.0));\n * viewer.camera.lookAtTransform(transform, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));\n *\n * // 2. Using a HeadingPitchRange offset\n * var transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-72.0, 40.0));\n * var heading = Cesium.Math.toRadians(50.0);\n * var pitch = Cesium.Math.toRadians(-20.0);\n * var range = 5000.0;\n * viewer.camera.lookAtTransform(transform, new Cesium.HeadingPitchRange(heading, pitch, range));\n */\n\n\nCamera.prototype.lookAtTransform = function (transform, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(transform)) {\n    throw new DeveloperError(\"transform is required\");\n  }\n\n  if (this._mode === SceneMode.MORPHING) {\n    throw new DeveloperError(\"lookAtTransform is not supported while morphing.\");\n  } //>>includeEnd('debug');\n\n\n  this._setTransform(transform);\n\n  if (!defined(offset)) {\n    return;\n  }\n\n  var cartesianOffset;\n\n  if (defined(offset.heading)) {\n    cartesianOffset = offsetFromHeadingPitchRange(offset.heading, offset.pitch, offset.range);\n  } else {\n    cartesianOffset = offset;\n  }\n\n  if (this._mode === SceneMode.SCENE2D) {\n    Cartesian2.clone(Cartesian2.ZERO, this.position);\n    Cartesian3.negate(cartesianOffset, this.up);\n    this.up.z = 0.0;\n\n    if (Cartesian3.magnitudeSquared(this.up) < CesiumMath.EPSILON10) {\n      Cartesian3.clone(Cartesian3.UNIT_Y, this.up);\n    }\n\n    Cartesian3.normalize(this.up, this.up);\n\n    this._setTransform(Matrix4.IDENTITY);\n\n    Cartesian3.negate(Cartesian3.UNIT_Z, this.direction);\n    Cartesian3.cross(this.direction, this.up, this.right);\n    Cartesian3.normalize(this.right, this.right);\n    var frustum = this.frustum;\n    var ratio = frustum.top / frustum.right;\n    frustum.right = Cartesian3.magnitude(cartesianOffset) * 0.5;\n    frustum.left = -frustum.right;\n    frustum.top = ratio * frustum.right;\n    frustum.bottom = -frustum.top;\n\n    this._setTransform(transform);\n\n    return;\n  }\n\n  Cartesian3.clone(cartesianOffset, this.position);\n  Cartesian3.negate(this.position, this.direction);\n  Cartesian3.normalize(this.direction, this.direction);\n  Cartesian3.cross(this.direction, Cartesian3.UNIT_Z, this.right);\n\n  if (Cartesian3.magnitudeSquared(this.right) < CesiumMath.EPSILON10) {\n    Cartesian3.clone(Cartesian3.UNIT_X, this.right);\n  }\n\n  Cartesian3.normalize(this.right, this.right);\n  Cartesian3.cross(this.right, this.direction, this.up);\n  Cartesian3.normalize(this.up, this.up);\n\n  this._adjustOrthographicFrustum(true);\n};\n\nvar viewRectangle3DCartographic1 = new Cartographic();\nvar viewRectangle3DCartographic2 = new Cartographic();\nvar viewRectangle3DNorthEast = new Cartesian3();\nvar viewRectangle3DSouthWest = new Cartesian3();\nvar viewRectangle3DNorthWest = new Cartesian3();\nvar viewRectangle3DSouthEast = new Cartesian3();\nvar viewRectangle3DNorthCenter = new Cartesian3();\nvar viewRectangle3DSouthCenter = new Cartesian3();\nvar viewRectangle3DCenter = new Cartesian3();\nvar viewRectangle3DEquator = new Cartesian3();\nvar defaultRF = {\n  direction: new Cartesian3(),\n  right: new Cartesian3(),\n  up: new Cartesian3()\n};\nvar viewRectangle3DEllipsoidGeodesic;\n\nfunction computeD(direction, upOrRight, corner, tanThetaOrPhi) {\n  var opposite = Math.abs(Cartesian3.dot(upOrRight, corner));\n  return opposite / tanThetaOrPhi - Cartesian3.dot(direction, corner);\n}\n\nfunction rectangleCameraPosition3D(camera, rectangle, result, updateCamera) {\n  var ellipsoid = camera._projection.ellipsoid;\n  var cameraRF = updateCamera ? camera : defaultRF;\n  var north = rectangle.north;\n  var south = rectangle.south;\n  var east = rectangle.east;\n  var west = rectangle.west; // If we go across the International Date Line\n\n  if (west > east) {\n    east += CesiumMath.TWO_PI;\n  } // Find the midpoint latitude.\n  //\n  // EllipsoidGeodesic will fail if the north and south edges are very close to being on opposite sides of the ellipsoid.\n  // Ideally we'd just call EllipsoidGeodesic.setEndPoints and let it throw when it detects this case, but sadly it doesn't\n  // even look for this case in optimized builds, so we have to test for it here instead.\n  //\n  // Fortunately, this case can only happen (here) when north is very close to the north pole and south is very close to the south pole,\n  // so handle it just by using 0 latitude as the center.  It's certainliy possible to use a smaller tolerance\n  // than one degree here, but one degree is safe and putting the center at 0 latitude should be good enough for any\n  // rectangle that spans 178+ of the 180 degrees of latitude.\n\n\n  var longitude = (west + east) * 0.5;\n  var latitude;\n\n  if (south < -CesiumMath.PI_OVER_TWO + CesiumMath.RADIANS_PER_DEGREE && north > CesiumMath.PI_OVER_TWO - CesiumMath.RADIANS_PER_DEGREE) {\n    latitude = 0.0;\n  } else {\n    var northCartographic = viewRectangle3DCartographic1;\n    northCartographic.longitude = longitude;\n    northCartographic.latitude = north;\n    northCartographic.height = 0.0;\n    var southCartographic = viewRectangle3DCartographic2;\n    southCartographic.longitude = longitude;\n    southCartographic.latitude = south;\n    southCartographic.height = 0.0;\n    var ellipsoidGeodesic = viewRectangle3DEllipsoidGeodesic;\n\n    if (!defined(ellipsoidGeodesic) || ellipsoidGeodesic.ellipsoid !== ellipsoid) {\n      viewRectangle3DEllipsoidGeodesic = ellipsoidGeodesic = new EllipsoidGeodesic(undefined, undefined, ellipsoid);\n    }\n\n    ellipsoidGeodesic.setEndPoints(northCartographic, southCartographic);\n    latitude = ellipsoidGeodesic.interpolateUsingFraction(0.5, viewRectangle3DCartographic1).latitude;\n  }\n\n  var centerCartographic = viewRectangle3DCartographic1;\n  centerCartographic.longitude = longitude;\n  centerCartographic.latitude = latitude;\n  centerCartographic.height = 0.0;\n  var center = ellipsoid.cartographicToCartesian(centerCartographic, viewRectangle3DCenter);\n  var cart = viewRectangle3DCartographic1;\n  cart.longitude = east;\n  cart.latitude = north;\n  var northEast = ellipsoid.cartographicToCartesian(cart, viewRectangle3DNorthEast);\n  cart.longitude = west;\n  var northWest = ellipsoid.cartographicToCartesian(cart, viewRectangle3DNorthWest);\n  cart.longitude = longitude;\n  var northCenter = ellipsoid.cartographicToCartesian(cart, viewRectangle3DNorthCenter);\n  cart.latitude = south;\n  var southCenter = ellipsoid.cartographicToCartesian(cart, viewRectangle3DSouthCenter);\n  cart.longitude = east;\n  var southEast = ellipsoid.cartographicToCartesian(cart, viewRectangle3DSouthEast);\n  cart.longitude = west;\n  var southWest = ellipsoid.cartographicToCartesian(cart, viewRectangle3DSouthWest);\n  Cartesian3.subtract(northWest, center, northWest);\n  Cartesian3.subtract(southEast, center, southEast);\n  Cartesian3.subtract(northEast, center, northEast);\n  Cartesian3.subtract(southWest, center, southWest);\n  Cartesian3.subtract(northCenter, center, northCenter);\n  Cartesian3.subtract(southCenter, center, southCenter);\n  var direction = ellipsoid.geodeticSurfaceNormal(center, cameraRF.direction);\n  Cartesian3.negate(direction, direction);\n  var right = Cartesian3.cross(direction, Cartesian3.UNIT_Z, cameraRF.right);\n  Cartesian3.normalize(right, right);\n  var up = Cartesian3.cross(right, direction, cameraRF.up);\n  var d;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    var width = Math.max(Cartesian3.distance(northEast, northWest), Cartesian3.distance(southEast, southWest));\n    var height = Math.max(Cartesian3.distance(northEast, southEast), Cartesian3.distance(northWest, southWest));\n    var rightScalar;\n    var topScalar;\n    var ratio = camera.frustum._offCenterFrustum.right / camera.frustum._offCenterFrustum.top;\n    var heightRatio = height * ratio;\n\n    if (width > heightRatio) {\n      rightScalar = width;\n      topScalar = rightScalar / ratio;\n    } else {\n      topScalar = height;\n      rightScalar = heightRatio;\n    }\n\n    d = Math.max(rightScalar, topScalar);\n  } else {\n    var tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n    var tanTheta = camera.frustum.aspectRatio * tanPhi;\n    d = Math.max(computeD(direction, up, northWest, tanPhi), computeD(direction, up, southEast, tanPhi), computeD(direction, up, northEast, tanPhi), computeD(direction, up, southWest, tanPhi), computeD(direction, up, northCenter, tanPhi), computeD(direction, up, southCenter, tanPhi), computeD(direction, right, northWest, tanTheta), computeD(direction, right, southEast, tanTheta), computeD(direction, right, northEast, tanTheta), computeD(direction, right, southWest, tanTheta), computeD(direction, right, northCenter, tanTheta), computeD(direction, right, southCenter, tanTheta)); // If the rectangle crosses the equator, compute D at the equator, too, because that's the\n    // widest part of the rectangle when projected onto the globe.\n\n    if (south < 0 && north > 0) {\n      var equatorCartographic = viewRectangle3DCartographic1;\n      equatorCartographic.longitude = west;\n      equatorCartographic.latitude = 0.0;\n      equatorCartographic.height = 0.0;\n      var equatorPosition = ellipsoid.cartographicToCartesian(equatorCartographic, viewRectangle3DEquator);\n      Cartesian3.subtract(equatorPosition, center, equatorPosition);\n      d = Math.max(d, computeD(direction, up, equatorPosition, tanPhi), computeD(direction, right, equatorPosition, tanTheta));\n      equatorCartographic.longitude = east;\n      equatorPosition = ellipsoid.cartographicToCartesian(equatorCartographic, viewRectangle3DEquator);\n      Cartesian3.subtract(equatorPosition, center, equatorPosition);\n      d = Math.max(d, computeD(direction, up, equatorPosition, tanPhi), computeD(direction, right, equatorPosition, tanTheta));\n    }\n  }\n\n  return Cartesian3.add(center, Cartesian3.multiplyByScalar(direction, -d, viewRectangle3DEquator), result);\n}\n\nvar viewRectangleCVCartographic = new Cartographic();\nvar viewRectangleCVNorthEast = new Cartesian3();\nvar viewRectangleCVSouthWest = new Cartesian3();\n\nfunction rectangleCameraPositionColumbusView(camera, rectangle, result) {\n  var projection = camera._projection;\n\n  if (rectangle.west > rectangle.east) {\n    rectangle = Rectangle.MAX_VALUE;\n  }\n\n  var transform = camera._actualTransform;\n  var invTransform = camera._actualInvTransform;\n  var cart = viewRectangleCVCartographic;\n  cart.longitude = rectangle.east;\n  cart.latitude = rectangle.north;\n  var northEast = projection.project(cart, viewRectangleCVNorthEast);\n  Matrix4.multiplyByPoint(transform, northEast, northEast);\n  Matrix4.multiplyByPoint(invTransform, northEast, northEast);\n  cart.longitude = rectangle.west;\n  cart.latitude = rectangle.south;\n  var southWest = projection.project(cart, viewRectangleCVSouthWest);\n  Matrix4.multiplyByPoint(transform, southWest, southWest);\n  Matrix4.multiplyByPoint(invTransform, southWest, southWest);\n  result.x = (northEast.x - southWest.x) * 0.5 + southWest.x;\n  result.y = (northEast.y - southWest.y) * 0.5 + southWest.y;\n\n  if (defined(camera.frustum.fovy)) {\n    var tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n    var tanTheta = camera.frustum.aspectRatio * tanPhi;\n    result.z = Math.max((northEast.x - southWest.x) / tanTheta, (northEast.y - southWest.y) / tanPhi) * 0.5;\n  } else {\n    var width = northEast.x - southWest.x;\n    var height = northEast.y - southWest.y;\n    result.z = Math.max(width, height);\n  }\n\n  return result;\n}\n\nvar viewRectangle2DCartographic = new Cartographic();\nvar viewRectangle2DNorthEast = new Cartesian3();\nvar viewRectangle2DSouthWest = new Cartesian3();\n\nfunction rectangleCameraPosition2D(camera, rectangle, result) {\n  var projection = camera._projection; // Account for the rectangle crossing the International Date Line in 2D mode\n\n  var east = rectangle.east;\n\n  if (rectangle.west > rectangle.east) {\n    if (camera._scene.mapMode2D === MapMode2D.INFINITE_SCROLL) {\n      east += CesiumMath.TWO_PI;\n    } else {\n      rectangle = Rectangle.MAX_VALUE;\n      east = rectangle.east;\n    }\n  }\n\n  var cart = viewRectangle2DCartographic;\n  cart.longitude = east;\n  cart.latitude = rectangle.north;\n  var northEast = projection.project(cart, viewRectangle2DNorthEast);\n  cart.longitude = rectangle.west;\n  cart.latitude = rectangle.south;\n  var southWest = projection.project(cart, viewRectangle2DSouthWest);\n  var width = Math.abs(northEast.x - southWest.x) * 0.5;\n  var height = Math.abs(northEast.y - southWest.y) * 0.5;\n  var right, top;\n  var ratio = camera.frustum.right / camera.frustum.top;\n  var heightRatio = height * ratio;\n\n  if (width > heightRatio) {\n    right = width;\n    top = right / ratio;\n  } else {\n    top = height;\n    right = heightRatio;\n  }\n\n  height = Math.max(2.0 * right, 2.0 * top);\n  result.x = (northEast.x - southWest.x) * 0.5 + southWest.x;\n  result.y = (northEast.y - southWest.y) * 0.5 + southWest.y;\n  cart = projection.unproject(result, cart);\n  cart.height = height;\n  result = projection.project(cart, result);\n  return result;\n}\n/**\n * Get the camera position needed to view a rectangle on an ellipsoid or map\n *\n * @param {Rectangle} rectangle The rectangle to view.\n * @param {Cartesian3} [result] The camera position needed to view the rectangle\n * @returns {Cartesian3} The camera position needed to view the rectangle\n */\n\n\nCamera.prototype.getRectangleCameraCoordinates = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required\");\n  } //>>includeEnd('debug');\n\n\n  var mode = this._mode;\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  if (mode === SceneMode.SCENE3D) {\n    return rectangleCameraPosition3D(this, rectangle, result);\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    return rectangleCameraPositionColumbusView(this, rectangle, result);\n  } else if (mode === SceneMode.SCENE2D) {\n    return rectangleCameraPosition2D(this, rectangle, result);\n  }\n\n  return undefined;\n};\n\nvar pickEllipsoid3DRay = new Ray();\n\nfunction pickEllipsoid3D(camera, windowPosition, ellipsoid, result) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  var ray = camera.getPickRay(windowPosition, pickEllipsoid3DRay);\n  var intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n\n  if (!intersection) {\n    return undefined;\n  }\n\n  var t = intersection.start > 0.0 ? intersection.start : intersection.stop;\n  return Ray.getPoint(ray, t, result);\n}\n\nvar pickEllipsoid2DRay = new Ray();\n\nfunction pickMap2D(camera, windowPosition, projection, result) {\n  var ray = camera.getPickRay(windowPosition, pickEllipsoid2DRay);\n  var position = ray.origin;\n  position = Cartesian3.fromElements(position.y, position.z, 0.0, position);\n  var cart = projection.unproject(position);\n\n  if (cart.latitude < -CesiumMath.PI_OVER_TWO || cart.latitude > CesiumMath.PI_OVER_TWO) {\n    return undefined;\n  }\n\n  return projection.ellipsoid.cartographicToCartesian(cart, result);\n}\n\nvar pickEllipsoidCVRay = new Ray();\n\nfunction pickMapColumbusView(camera, windowPosition, projection, result) {\n  var ray = camera.getPickRay(windowPosition, pickEllipsoidCVRay);\n  var scalar = -ray.origin.x / ray.direction.x;\n  Ray.getPoint(ray, scalar, result);\n  var cart = projection.unproject(new Cartesian3(result.y, result.z, 0.0));\n\n  if (cart.latitude < -CesiumMath.PI_OVER_TWO || cart.latitude > CesiumMath.PI_OVER_TWO || cart.longitude < -Math.PI || cart.longitude > Math.PI) {\n    return undefined;\n  }\n\n  return projection.ellipsoid.cartographicToCartesian(cart, result);\n}\n/**\n * Pick an ellipsoid or map.\n *\n * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to pick.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} If the ellipsoid or map was picked, returns the point on the surface of the ellipsoid or map\n * in world coordinates. If the ellipsoid or map was not picked, returns undefined.\n *\n * @example\n * var canvas = viewer.scene.canvas;\n * var center = new Cesium.Cartesian2(canvas.clientWidth / 2.0, canvas.clientHeight / 2.0);\n * var ellipsoid = viewer.scene.globe.ellipsoid;\n * var result = viewer.camera.pickEllipsoid(center, ellipsoid);\n */\n\n\nCamera.prototype.pickEllipsoid = function (windowPosition, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(windowPosition)) {\n    throw new DeveloperError(\"windowPosition is required.\");\n  } //>>includeEnd('debug');\n\n\n  var canvas = this._scene.canvas;\n\n  if (canvas.clientWidth === 0 || canvas.clientHeight === 0) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  if (this._mode === SceneMode.SCENE3D) {\n    result = pickEllipsoid3D(this, windowPosition, ellipsoid, result);\n  } else if (this._mode === SceneMode.SCENE2D) {\n    result = pickMap2D(this, windowPosition, this._projection, result);\n  } else if (this._mode === SceneMode.COLUMBUS_VIEW) {\n    result = pickMapColumbusView(this, windowPosition, this._projection, result);\n  } else {\n    return undefined;\n  }\n\n  return result;\n};\n\nvar pickPerspCenter = new Cartesian3();\nvar pickPerspXDir = new Cartesian3();\nvar pickPerspYDir = new Cartesian3();\n\nfunction getPickRayPerspective(camera, windowPosition, result) {\n  var canvas = camera._scene.canvas;\n  var width = canvas.clientWidth;\n  var height = canvas.clientHeight;\n  var tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n  var tanTheta = camera.frustum.aspectRatio * tanPhi;\n  var near = camera.frustum.near;\n  var x = 2.0 / width * windowPosition.x - 1.0;\n  var y = 2.0 / height * (height - windowPosition.y) - 1.0;\n  var position = camera.positionWC;\n  Cartesian3.clone(position, result.origin);\n  var nearCenter = Cartesian3.multiplyByScalar(camera.directionWC, near, pickPerspCenter);\n  Cartesian3.add(position, nearCenter, nearCenter);\n  var xDir = Cartesian3.multiplyByScalar(camera.rightWC, x * near * tanTheta, pickPerspXDir);\n  var yDir = Cartesian3.multiplyByScalar(camera.upWC, y * near * tanPhi, pickPerspYDir);\n  var direction = Cartesian3.add(nearCenter, xDir, result.direction);\n  Cartesian3.add(direction, yDir, direction);\n  Cartesian3.subtract(direction, position, direction);\n  Cartesian3.normalize(direction, direction);\n  return result;\n}\n\nvar scratchDirection = new Cartesian3();\n\nfunction getPickRayOrthographic(camera, windowPosition, result) {\n  var canvas = camera._scene.canvas;\n  var width = canvas.clientWidth;\n  var height = canvas.clientHeight;\n  var frustum = camera.frustum;\n\n  if (defined(frustum._offCenterFrustum)) {\n    frustum = frustum._offCenterFrustum;\n  }\n\n  var x = 2.0 / width * windowPosition.x - 1.0;\n  x *= (frustum.right - frustum.left) * 0.5;\n  var y = 2.0 / height * (height - windowPosition.y) - 1.0;\n  y *= (frustum.top - frustum.bottom) * 0.5;\n  var origin = result.origin;\n  Cartesian3.clone(camera.position, origin);\n  Cartesian3.multiplyByScalar(camera.right, x, scratchDirection);\n  Cartesian3.add(scratchDirection, origin, origin);\n  Cartesian3.multiplyByScalar(camera.up, y, scratchDirection);\n  Cartesian3.add(scratchDirection, origin, origin);\n  Cartesian3.clone(camera.directionWC, result.direction);\n\n  if (camera._mode === SceneMode.COLUMBUS_VIEW || camera._mode === SceneMode.SCENE2D) {\n    Cartesian3.fromElements(result.origin.z, result.origin.x, result.origin.y, result.origin);\n  }\n\n  return result;\n}\n/**\n * Create a ray from the camera position through the pixel at <code>windowPosition</code>\n * in world coordinates.\n *\n * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.\n * @param {Ray} [result] The object onto which to store the result.\n * @returns {Ray} Returns the {@link Cartesian3} position and direction of the ray.\n */\n\n\nCamera.prototype.getPickRay = function (windowPosition, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(windowPosition)) {\n    throw new DeveloperError(\"windowPosition is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(result)) {\n    result = new Ray();\n  }\n\n  var frustum = this.frustum;\n\n  if (defined(frustum.aspectRatio) && defined(frustum.fov) && defined(frustum.near)) {\n    return getPickRayPerspective(this, windowPosition, result);\n  }\n\n  return getPickRayOrthographic(this, windowPosition, result);\n};\n\nvar scratchToCenter = new Cartesian3();\nvar scratchProj = new Cartesian3();\n/**\n * Return the distance from the camera to the front of the bounding sphere.\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere in world coordinates.\n * @returns {Number} The distance to the bounding sphere.\n */\n\nCamera.prototype.distanceToBoundingSphere = function (boundingSphere) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  } //>>includeEnd('debug');\n\n\n  var toCenter = Cartesian3.subtract(this.positionWC, boundingSphere.center, scratchToCenter);\n  var proj = Cartesian3.multiplyByScalar(this.directionWC, Cartesian3.dot(toCenter, this.directionWC), scratchProj);\n  return Math.max(0.0, Cartesian3.magnitude(proj) - boundingSphere.radius);\n};\n\nvar scratchPixelSize = new Cartesian2();\n/**\n * Return the pixel size in meters.\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere in world coordinates.\n * @param {Number} drawingBufferWidth The drawing buffer width.\n * @param {Number} drawingBufferHeight The drawing buffer height.\n * @returns {Number} The pixel size in meters.\n */\n\nCamera.prototype.getPixelSize = function (boundingSphere, drawingBufferWidth, drawingBufferHeight) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n\n  if (!defined(drawingBufferWidth)) {\n    throw new DeveloperError(\"drawingBufferWidth is required.\");\n  }\n\n  if (!defined(drawingBufferHeight)) {\n    throw new DeveloperError(\"drawingBufferHeight is required.\");\n  } //>>includeEnd('debug');\n\n\n  var distance = this.distanceToBoundingSphere(boundingSphere);\n  var pixelSize = this.frustum.getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, this._scene.pixelRatio, scratchPixelSize);\n  return Math.max(pixelSize.x, pixelSize.y);\n};\n\nfunction createAnimationTemplateCV(camera, position, center, maxX, maxY, duration) {\n  var newPosition = Cartesian3.clone(position);\n\n  if (center.y > maxX) {\n    newPosition.y -= center.y - maxX;\n  } else if (center.y < -maxX) {\n    newPosition.y += -maxX - center.y;\n  }\n\n  if (center.z > maxY) {\n    newPosition.z -= center.z - maxY;\n  } else if (center.z < -maxY) {\n    newPosition.z += -maxY - center.z;\n  }\n\n  function updateCV(value) {\n    var interp = Cartesian3.lerp(position, newPosition, value.time, new Cartesian3());\n    camera.worldToCameraCoordinatesPoint(interp, camera.position);\n  }\n\n  return {\n    easingFunction: EasingFunction.EXPONENTIAL_OUT,\n    startObject: {\n      time: 0.0\n    },\n    stopObject: {\n      time: 1.0\n    },\n    duration: duration,\n    update: updateCV\n  };\n}\n\nvar normalScratch = new Cartesian3();\nvar centerScratch = new Cartesian3();\nvar posScratch = new Cartesian3();\nvar scratchCartesian3Subtract = new Cartesian3();\n\nfunction createAnimationCV(camera, duration) {\n  var position = camera.position;\n  var direction = camera.direction;\n  var normal = camera.worldToCameraCoordinatesVector(Cartesian3.UNIT_X, normalScratch);\n  var scalar = -Cartesian3.dot(normal, position) / Cartesian3.dot(normal, direction);\n  var center = Cartesian3.add(position, Cartesian3.multiplyByScalar(direction, scalar, centerScratch), centerScratch);\n  camera.cameraToWorldCoordinatesPoint(center, center);\n  position = camera.cameraToWorldCoordinatesPoint(camera.position, posScratch);\n  var tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n  var tanTheta = camera.frustum.aspectRatio * tanPhi;\n  var distToC = Cartesian3.magnitude(Cartesian3.subtract(position, center, scratchCartesian3Subtract));\n  var dWidth = tanTheta * distToC;\n  var dHeight = tanPhi * distToC;\n  var mapWidth = camera._maxCoord.x;\n  var mapHeight = camera._maxCoord.y;\n  var maxX = Math.max(dWidth - mapWidth, mapWidth);\n  var maxY = Math.max(dHeight - mapHeight, mapHeight);\n\n  if (position.z < -maxX || position.z > maxX || position.y < -maxY || position.y > maxY) {\n    var translateX = center.y < -maxX || center.y > maxX;\n    var translateY = center.z < -maxY || center.z > maxY;\n\n    if (translateX || translateY) {\n      return createAnimationTemplateCV(camera, position, center, maxX, maxY, duration);\n    }\n  }\n\n  return undefined;\n}\n/**\n * Create an animation to move the map into view. This method is only valid for 2D and Columbus modes.\n *\n * @param {Number} duration The duration, in seconds, of the animation.\n * @returns {Object} The animation or undefined if the scene mode is 3D or the map is already ion view.\n *\n * @private\n */\n\n\nCamera.prototype.createCorrectPositionTween = function (duration) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(duration)) {\n    throw new DeveloperError(\"duration is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (this._mode === SceneMode.COLUMBUS_VIEW) {\n    return createAnimationCV(this, duration);\n  }\n\n  return undefined;\n};\n\nvar scratchFlyToDestination = new Cartesian3();\nvar newOptions = {\n  destination: undefined,\n  heading: undefined,\n  pitch: undefined,\n  roll: undefined,\n  duration: undefined,\n  complete: undefined,\n  cancel: undefined,\n  endTransform: undefined,\n  maximumHeight: undefined,\n  easingFunction: undefined\n};\n/**\n * Cancels the current camera flight if one is in progress.\n * The camera is left at it's current location.\n */\n\nCamera.prototype.cancelFlight = function () {\n  if (defined(this._currentFlight)) {\n    this._currentFlight.cancelTween();\n\n    this._currentFlight = undefined;\n  }\n};\n/**\n * Flies the camera from its current position to a new position.\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3|Rectangle} options.destination The final position of the camera in WGS84 (world) coordinates or a rectangle that would be visible from a top-down view.\n * @param {Object} [options.orientation] An object that contains either direction and up properties or heading, pitch and roll properties. By default, the direction will point\n * towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive\n * y direction in Columbus view.  Orientation is not used in 2D when in infinite scrolling mode.\n * @param {Number} [options.duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.\n * @param {Camera~FlightCompleteCallback} [options.complete] The function to execute when the flight is complete.\n * @param {Camera~FlightCancelledCallback} [options.cancel] The function to execute if the flight is cancelled.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame the camera will be in when the flight is completed.\n * @param {Number} [options.maximumHeight] The maximum height at the peak of the flight.\n * @param {Number} [options.pitchAdjustHeight] If camera flyes higher than that value, adjust pitch duiring the flight to look down, and keep Earth in viewport.\n * @param {Number} [options.flyOverLongitude] There are always two ways between 2 points on globe. This option force camera to choose fight direction to fly over that longitude.\n * @param {Number} [options.flyOverLongitudeWeight] Fly over the lon specifyed via flyOverLongitude only if that way is not longer than short way times flyOverLongitudeWeight.\n * @param {Boolean} [options.convert] Whether to convert the destination from world coordinates to scene coordinates (only relevant when not using 3D). Defaults to <code>true</code>.\n * @param {EasingFunction|EasingFunction~Callback} [options.easingFunction] Controls how the time is interpolated over the duration of the flight.\n *\n * @exception {DeveloperError} If either direction or up is given, then both are required.\n *\n * @example\n * // 1. Fly to a position with a top-down view\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)\n * });\n *\n * // 2. Fly to a Rectangle with a top-down view\n * viewer.camera.flyTo({\n *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)\n * });\n *\n * // 3. Fly to a position with an orientation using unit vectors.\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),\n *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)\n *     }\n * });\n *\n * // 4. Fly to a position with an orientation using heading, pitch and roll.\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         heading : Cesium.Math.toRadians(175.0),\n *         pitch : Cesium.Math.toRadians(-35.0),\n *         roll : 0.0\n *     }\n * });\n */\n\n\nCamera.prototype.flyTo = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var destination = options.destination; //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(destination)) {\n    throw new DeveloperError(\"destination is required.\");\n  } //>>includeEnd('debug');\n\n\n  var mode = this._mode;\n\n  if (mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  this.cancelFlight();\n  var orientation = defaultValue(options.orientation, defaultValue.EMPTY_OBJECT);\n\n  if (defined(orientation.direction)) {\n    orientation = directionUpToHeadingPitchRoll(this, destination, orientation, scratchSetViewOptions.orientation);\n  }\n\n  if (defined(options.duration) && options.duration <= 0.0) {\n    var setViewOptions = scratchSetViewOptions;\n    setViewOptions.destination = options.destination;\n    setViewOptions.orientation.heading = orientation.heading;\n    setViewOptions.orientation.pitch = orientation.pitch;\n    setViewOptions.orientation.roll = orientation.roll;\n    setViewOptions.convert = options.convert;\n    setViewOptions.endTransform = options.endTransform;\n    this.setView(setViewOptions);\n\n    if (typeof options.complete === \"function\") {\n      options.complete();\n    }\n\n    return;\n  }\n\n  var isRectangle = defined(destination.west);\n\n  if (isRectangle) {\n    destination = this.getRectangleCameraCoordinates(destination, scratchFlyToDestination);\n  }\n\n  var that = this;\n  var flightTween;\n  newOptions.destination = destination;\n  newOptions.heading = orientation.heading;\n  newOptions.pitch = orientation.pitch;\n  newOptions.roll = orientation.roll;\n  newOptions.duration = options.duration;\n\n  newOptions.complete = function () {\n    if (flightTween === that._currentFlight) {\n      that._currentFlight = undefined;\n    }\n\n    if (defined(options.complete)) {\n      options.complete();\n    }\n  };\n\n  newOptions.cancel = options.cancel;\n  newOptions.endTransform = options.endTransform;\n  newOptions.convert = isRectangle ? false : options.convert;\n  newOptions.maximumHeight = options.maximumHeight;\n  newOptions.pitchAdjustHeight = options.pitchAdjustHeight;\n  newOptions.flyOverLongitude = options.flyOverLongitude;\n  newOptions.flyOverLongitudeWeight = options.flyOverLongitudeWeight;\n  newOptions.easingFunction = options.easingFunction;\n  var scene = this._scene;\n  var tweenOptions = CameraFlightPath.createTween(scene, newOptions); // If the camera doesn't actually need to go anywhere, duration\n  // will be 0 and we can just complete the current flight.\n\n  if (tweenOptions.duration === 0) {\n    if (typeof tweenOptions.complete === \"function\") {\n      tweenOptions.complete();\n    }\n\n    return;\n  }\n\n  flightTween = scene.tweens.add(tweenOptions);\n  this._currentFlight = flightTween; // Save the final destination view information for the PRELOAD_FLIGHT pass.\n\n  var preloadFlightCamera = this._scene.preloadFlightCamera;\n\n  if (this._mode !== SceneMode.SCENE2D) {\n    if (!defined(preloadFlightCamera)) {\n      preloadFlightCamera = Camera.clone(this);\n    }\n\n    preloadFlightCamera.setView({\n      destination: destination,\n      orientation: orientation\n    });\n    this._scene.preloadFlightCullingVolume = preloadFlightCamera.frustum.computeCullingVolume(preloadFlightCamera.positionWC, preloadFlightCamera.directionWC, preloadFlightCamera.upWC);\n  }\n};\n\nfunction distanceToBoundingSphere3D(camera, radius) {\n  var frustum = camera.frustum;\n  var tanPhi = Math.tan(frustum.fovy * 0.5);\n  var tanTheta = frustum.aspectRatio * tanPhi;\n  return Math.max(radius / tanTheta, radius / tanPhi);\n}\n\nfunction distanceToBoundingSphere2D(camera, radius) {\n  var frustum = camera.frustum;\n\n  if (defined(frustum._offCenterFrustum)) {\n    frustum = frustum._offCenterFrustum;\n  }\n\n  var right, top;\n  var ratio = frustum.right / frustum.top;\n  var heightRatio = radius * ratio;\n\n  if (radius > heightRatio) {\n    right = radius;\n    top = right / ratio;\n  } else {\n    top = radius;\n    right = heightRatio;\n  }\n\n  return Math.max(right, top) * 1.5;\n}\n\nvar MINIMUM_ZOOM = 100.0;\n\nfunction adjustBoundingSphereOffset(camera, boundingSphere, offset) {\n  offset = HeadingPitchRange.clone(defined(offset) ? offset : Camera.DEFAULT_OFFSET);\n  var minimumZoom = camera._scene.screenSpaceCameraController.minimumZoomDistance;\n  var maximumZoom = camera._scene.screenSpaceCameraController.maximumZoomDistance;\n  var range = offset.range;\n\n  if (!defined(range) || range === 0.0) {\n    var radius = boundingSphere.radius;\n\n    if (radius === 0.0) {\n      offset.range = MINIMUM_ZOOM;\n    } else if (camera.frustum instanceof OrthographicFrustum || camera._mode === SceneMode.SCENE2D) {\n      offset.range = distanceToBoundingSphere2D(camera, radius);\n    } else {\n      offset.range = distanceToBoundingSphere3D(camera, radius);\n    }\n\n    offset.range = CesiumMath.clamp(offset.range, minimumZoom, maximumZoom);\n  }\n\n  return offset;\n}\n/**\n * Sets the camera so that the current view contains the provided bounding sphere.\n *\n * <p>The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.\n * The heading and the pitch angles are defined in the local east-north-up reference frame.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is\n * zero, a range will be computed such that the whole bounding sphere is visible.</p>\n *\n * <p>In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the range. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.</p>\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere to view, in world coordinates.\n * @param {HeadingPitchRange} [offset] The offset from the target in the local east-north-up reference frame centered at the target.\n *\n * @exception {DeveloperError} viewBoundingSphere is not supported while morphing.\n */\n\n\nCamera.prototype.viewBoundingSphere = function (boundingSphere, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n\n  if (this._mode === SceneMode.MORPHING) {\n    throw new DeveloperError(\"viewBoundingSphere is not supported while morphing.\");\n  } //>>includeEnd('debug');\n\n\n  offset = adjustBoundingSphereOffset(this, boundingSphere, offset);\n  this.lookAt(boundingSphere.center, offset);\n};\n\nvar scratchflyToBoundingSphereTransform = new Matrix4();\nvar scratchflyToBoundingSphereDestination = new Cartesian3();\nvar scratchflyToBoundingSphereDirection = new Cartesian3();\nvar scratchflyToBoundingSphereUp = new Cartesian3();\nvar scratchflyToBoundingSphereRight = new Cartesian3();\nvar scratchFlyToBoundingSphereCart4 = new Cartesian4();\nvar scratchFlyToBoundingSphereQuaternion = new Quaternion();\nvar scratchFlyToBoundingSphereMatrix3 = new Matrix3();\n/**\n * Flies the camera to a location where the current view contains the provided bounding sphere.\n *\n * <p> The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.\n * The heading and the pitch angles are defined in the local east-north-up reference frame.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is\n * zero, a range will be computed such that the whole bounding sphere is visible.</p>\n *\n * <p>In 2D and Columbus View, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the range. The heading will be aligned to local north.</p>\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere to view, in world coordinates.\n * @param {Object} [options] Object with the following properties:\n * @param {Number} [options.duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.\n * @param {HeadingPitchRange} [options.offset] The offset from the target in the local east-north-up reference frame centered at the target.\n * @param {Camera~FlightCompleteCallback} [options.complete] The function to execute when the flight is complete.\n * @param {Camera~FlightCancelledCallback} [options.cancel] The function to execute if the flight is cancelled.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame the camera will be in when the flight is completed.\n * @param {Number} [options.maximumHeight] The maximum height at the peak of the flight.\n * @param {Number} [options.pitchAdjustHeight] If camera flyes higher than that value, adjust pitch duiring the flight to look down, and keep Earth in viewport.\n * @param {Number} [options.flyOverLongitude] There are always two ways between 2 points on globe. This option force camera to choose fight direction to fly over that longitude.\n * @param {Number} [options.flyOverLongitudeWeight] Fly over the lon specifyed via flyOverLongitude only if that way is not longer than short way times flyOverLongitudeWeight.\n * @param {EasingFunction|EasingFunction~Callback} [options.easingFunction] Controls how the time is interpolated over the duration of the flight.\n */\n\nCamera.prototype.flyToBoundingSphere = function (boundingSphere, options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  } //>>includeEnd('debug');\n\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var scene2D = this._mode === SceneMode.SCENE2D || this._mode === SceneMode.COLUMBUS_VIEW;\n\n  this._setTransform(Matrix4.IDENTITY);\n\n  var offset = adjustBoundingSphereOffset(this, boundingSphere, options.offset);\n  var position;\n\n  if (scene2D) {\n    position = Cartesian3.multiplyByScalar(Cartesian3.UNIT_Z, offset.range, scratchflyToBoundingSphereDestination);\n  } else {\n    position = offsetFromHeadingPitchRange(offset.heading, offset.pitch, offset.range);\n  }\n\n  var transform = Transforms.eastNorthUpToFixedFrame(boundingSphere.center, Ellipsoid.WGS84, scratchflyToBoundingSphereTransform);\n  Matrix4.multiplyByPoint(transform, position, position);\n  var direction;\n  var up;\n\n  if (!scene2D) {\n    direction = Cartesian3.subtract(boundingSphere.center, position, scratchflyToBoundingSphereDirection);\n    Cartesian3.normalize(direction, direction);\n    up = Matrix4.multiplyByPointAsVector(transform, Cartesian3.UNIT_Z, scratchflyToBoundingSphereUp);\n\n    if (1.0 - Math.abs(Cartesian3.dot(direction, up)) < CesiumMath.EPSILON6) {\n      var rotateQuat = Quaternion.fromAxisAngle(direction, offset.heading, scratchFlyToBoundingSphereQuaternion);\n      var rotation = Matrix3.fromQuaternion(rotateQuat, scratchFlyToBoundingSphereMatrix3);\n      Cartesian3.fromCartesian4(Matrix4.getColumn(transform, 1, scratchFlyToBoundingSphereCart4), up);\n      Matrix3.multiplyByVector(rotation, up, up);\n    }\n\n    var right = Cartesian3.cross(direction, up, scratchflyToBoundingSphereRight);\n    Cartesian3.cross(right, direction, up);\n    Cartesian3.normalize(up, up);\n  }\n\n  this.flyTo({\n    destination: position,\n    orientation: {\n      direction: direction,\n      up: up\n    },\n    duration: options.duration,\n    complete: options.complete,\n    cancel: options.cancel,\n    endTransform: options.endTransform,\n    maximumHeight: options.maximumHeight,\n    easingFunction: options.easingFunction,\n    flyOverLongitude: options.flyOverLongitude,\n    flyOverLongitudeWeight: options.flyOverLongitudeWeight,\n    pitchAdjustHeight: options.pitchAdjustHeight\n  });\n};\n\nvar scratchCartesian3_1 = new Cartesian3();\nvar scratchCartesian3_2 = new Cartesian3();\nvar scratchCartesian3_3 = new Cartesian3();\nvar scratchCartesian3_4 = new Cartesian3();\nvar horizonPoints = [new Cartesian3(), new Cartesian3(), new Cartesian3(), new Cartesian3()];\n\nfunction computeHorizonQuad(camera, ellipsoid) {\n  var radii = ellipsoid.radii;\n  var p = camera.positionWC; // Find the corresponding position in the scaled space of the ellipsoid.\n\n  var q = Cartesian3.multiplyComponents(ellipsoid.oneOverRadii, p, scratchCartesian3_1);\n  var qMagnitude = Cartesian3.magnitude(q);\n  var qUnit = Cartesian3.normalize(q, scratchCartesian3_2); // Determine the east and north directions at q.\n\n  var eUnit;\n  var nUnit;\n\n  if (Cartesian3.equalsEpsilon(qUnit, Cartesian3.UNIT_Z, CesiumMath.EPSILON10)) {\n    eUnit = new Cartesian3(0, 1, 0);\n    nUnit = new Cartesian3(0, 0, 1);\n  } else {\n    eUnit = Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z, qUnit, scratchCartesian3_3), scratchCartesian3_3);\n    nUnit = Cartesian3.normalize(Cartesian3.cross(qUnit, eUnit, scratchCartesian3_4), scratchCartesian3_4);\n  } // Determine the radius of the 'limb' of the ellipsoid.\n\n\n  var wMagnitude = Math.sqrt(Cartesian3.magnitudeSquared(q) - 1.0); // Compute the center and offsets.\n\n  var center = Cartesian3.multiplyByScalar(qUnit, 1.0 / qMagnitude, scratchCartesian3_1);\n  var scalar = wMagnitude / qMagnitude;\n  var eastOffset = Cartesian3.multiplyByScalar(eUnit, scalar, scratchCartesian3_2);\n  var northOffset = Cartesian3.multiplyByScalar(nUnit, scalar, scratchCartesian3_3); // A conservative measure for the longitudes would be to use the min/max longitudes of the bounding frustum.\n\n  var upperLeft = Cartesian3.add(center, northOffset, horizonPoints[0]);\n  Cartesian3.subtract(upperLeft, eastOffset, upperLeft);\n  Cartesian3.multiplyComponents(radii, upperLeft, upperLeft);\n  var lowerLeft = Cartesian3.subtract(center, northOffset, horizonPoints[1]);\n  Cartesian3.subtract(lowerLeft, eastOffset, lowerLeft);\n  Cartesian3.multiplyComponents(radii, lowerLeft, lowerLeft);\n  var lowerRight = Cartesian3.subtract(center, northOffset, horizonPoints[2]);\n  Cartesian3.add(lowerRight, eastOffset, lowerRight);\n  Cartesian3.multiplyComponents(radii, lowerRight, lowerRight);\n  var upperRight = Cartesian3.add(center, northOffset, horizonPoints[3]);\n  Cartesian3.add(upperRight, eastOffset, upperRight);\n  Cartesian3.multiplyComponents(radii, upperRight, upperRight);\n  return horizonPoints;\n}\n\nvar scratchPickCartesian2 = new Cartesian2();\nvar scratchRectCartesian = new Cartesian3();\nvar cartoArray = [new Cartographic(), new Cartographic(), new Cartographic(), new Cartographic()];\n\nfunction addToResult(x, y, index, camera, ellipsoid, computedHorizonQuad) {\n  scratchPickCartesian2.x = x;\n  scratchPickCartesian2.y = y;\n  var r = camera.pickEllipsoid(scratchPickCartesian2, ellipsoid, scratchRectCartesian);\n\n  if (defined(r)) {\n    cartoArray[index] = ellipsoid.cartesianToCartographic(r, cartoArray[index]);\n    return 1;\n  }\n\n  cartoArray[index] = ellipsoid.cartesianToCartographic(computedHorizonQuad[index], cartoArray[index]);\n  return 0;\n}\n/**\n * Computes the approximate visible rectangle on the ellipsoid.\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid that you want to know the visible region.\n * @param {Rectangle} [result] The rectangle in which to store the result\n *\n * @returns {Rectangle|undefined} The visible rectangle or undefined if the ellipsoid isn't visible at all.\n */\n\n\nCamera.prototype.computeViewRectangle = function (ellipsoid, result) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  var cullingVolume = this.frustum.computeCullingVolume(this.positionWC, this.directionWC, this.upWC);\n  var boundingSphere = new BoundingSphere(Cartesian3.ZERO, ellipsoid.maximumRadius);\n  var visibility = cullingVolume.computeVisibility(boundingSphere);\n\n  if (visibility === Intersect.OUTSIDE) {\n    return undefined;\n  }\n\n  var canvas = this._scene.canvas;\n  var width = canvas.clientWidth;\n  var height = canvas.clientHeight;\n  var successfulPickCount = 0;\n  var computedHorizonQuad = computeHorizonQuad(this, ellipsoid);\n  successfulPickCount += addToResult(0, 0, 0, this, ellipsoid, computedHorizonQuad);\n  successfulPickCount += addToResult(0, height, 1, this, ellipsoid, computedHorizonQuad);\n  successfulPickCount += addToResult(width, height, 2, this, ellipsoid, computedHorizonQuad);\n  successfulPickCount += addToResult(width, 0, 3, this, ellipsoid, computedHorizonQuad);\n\n  if (successfulPickCount < 2) {\n    // If we have space non-globe in 3 or 4 corners then return the whole globe\n    return Rectangle.MAX_VALUE;\n  }\n\n  result = Rectangle.fromCartographicArray(cartoArray, result); // Detect if we go over the poles\n\n  var distance = 0;\n  var lastLon = cartoArray[3].longitude;\n\n  for (var i = 0; i < 4; ++i) {\n    var lon = cartoArray[i].longitude;\n    var diff = Math.abs(lon - lastLon);\n\n    if (diff > CesiumMath.PI) {\n      // Crossed the dateline\n      distance += CesiumMath.TWO_PI - diff;\n    } else {\n      distance += diff;\n    }\n\n    lastLon = lon;\n  } // We are over one of the poles so adjust the rectangle accordingly\n\n\n  if (CesiumMath.equalsEpsilon(Math.abs(distance), CesiumMath.TWO_PI, CesiumMath.EPSILON9)) {\n    result.west = -CesiumMath.PI;\n    result.east = CesiumMath.PI;\n\n    if (cartoArray[0].latitude >= 0.0) {\n      result.north = CesiumMath.PI_OVER_TWO;\n    } else {\n      result.south = -CesiumMath.PI_OVER_TWO;\n    }\n  }\n\n  return result;\n};\n/**\n * Switches the frustum/projection to perspective.\n *\n * This function is a no-op in 2D which must always be orthographic.\n */\n\n\nCamera.prototype.switchToPerspectiveFrustum = function () {\n  if (this._mode === SceneMode.SCENE2D || this.frustum instanceof PerspectiveFrustum) {\n    return;\n  }\n\n  var scene = this._scene;\n  this.frustum = new PerspectiveFrustum();\n  this.frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight;\n  this.frustum.fov = CesiumMath.toRadians(60.0);\n};\n/**\n * Switches the frustum/projection to orthographic.\n *\n * This function is a no-op in 2D which will always be orthographic.\n */\n\n\nCamera.prototype.switchToOrthographicFrustum = function () {\n  if (this._mode === SceneMode.SCENE2D || this.frustum instanceof OrthographicFrustum) {\n    return;\n  }\n\n  var scene = this._scene;\n  this.frustum = new OrthographicFrustum();\n  this.frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight; // It doesn't matter what we set this to. The adjust below will correct the width based on the camera position.\n\n  this.frustum.width = Cartesian3.magnitude(this.position); // Check the projection matrix. It will always be defined, but we need to force an off-center update.\n\n  var projectionMatrix = this.frustum.projectionMatrix;\n\n  if (defined(projectionMatrix)) {\n    this._adjustOrthographicFrustum(true);\n  }\n};\n/**\n * @private\n */\n\n\nCamera.clone = function (camera, result) {\n  if (!defined(result)) {\n    result = new Camera(camera._scene);\n  }\n\n  Cartesian3.clone(camera.position, result.position);\n  Cartesian3.clone(camera.direction, result.direction);\n  Cartesian3.clone(camera.up, result.up);\n  Cartesian3.clone(camera.right, result.right);\n  Matrix4.clone(camera._transform, result.transform);\n  result._transformChanged = true;\n  result.frustum = camera.frustum.clone();\n  return result;\n};\n/**\n * A function that will execute when a flight completes.\n * @callback Camera~FlightCompleteCallback\n */\n\n/**\n * A function that will execute when a flight is cancelled.\n * @callback Camera~FlightCancelledCallback\n */\n\n\nexport default Camera;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/Camera.js"],"names":["BoundingSphere","Cartesian2","Cartesian3","Cartesian4","Cartographic","defaultValue","defined","DeveloperError","EasingFunction","Ellipsoid","EllipsoidGeodesic","Event","getTimestamp","HeadingPitchRange","HeadingPitchRoll","Intersect","IntersectionTests","CesiumMath","Matrix3","Matrix4","OrthographicFrustum","OrthographicOffCenterFrustum","PerspectiveFrustum","Quaternion","Ray","Rectangle","Transforms","CameraFlightPath","MapMode2D","SceneMode","Camera","scene","_scene","_transform","clone","IDENTITY","_invTransform","_actualTransform","_actualInvTransform","_transformChanged","position","_position","_positionWC","_positionCartographic","_oldPositionWC","undefined","positionWCDeltaMagnitude","positionWCDeltaMagnitudeLastFrame","timeSinceMoved","_lastMovedTimestamp","direction","_direction","_directionWC","up","_up","_upWC","right","_right","_rightWC","frustum","aspectRatio","drawingBufferWidth","drawingBufferHeight","fov","toRadians","defaultMoveAmount","defaultLookAmount","Math","PI","defaultRotateAmount","defaultZoomAmount","constrainedAxis","maximumZoomFactor","_moveStart","_moveEnd","_changed","_changedPosition","_changedDirection","_changedFrustum","percentageChanged","_viewMatrix","_invViewMatrix","updateViewMatrix","_mode","SCENE3D","_modeChanged","projection","mapProjection","_projection","_maxCoord","project","PI_OVER_TWO","_max2Dfrustum","rectangleCameraPosition3D","DEFAULT_VIEW_RECTANGLE","mag","magnitude","DEFAULT_VIEW_FACTOR","normalize","multiplyByScalar","TRANSFORM_2D","TRANSFORM_2D_INVERSE","inverseTransformation","fromDegrees","DEFAULT_OFFSET","PI_OVER_FOUR","camera","computeView","multiply","updateCameraDeltas","positionWC","delta","subtract","max","prototype","canPreloadFlight","_currentFlight","SCENE2D","_updateCameraChanged","numberOfListeners","lastPosition","lastFrustum","x0","x","left","x1","x2","x3","y0","y","bottom","y1","top","y2","y3","leftX","rightX","min","bottomY","topY","areaPercentage","areaRef","raiseEvent","directionWC","dirAngle","acosClamped","dot","dirPercentage","fovy","distance","heightPercentage","positionCartographic","height","convertTransformForColumbusView","basisTo2D","scratchCartographic","scratchCartesian3Projection","scratchCartesian3","scratchCartesian4Origin","scratchCartesian4NewOrigin","scratchCartesian4NewXAxis","scratchCartesian4NewYAxis","scratchCartesian4NewZAxis","convertTransformFor2D","ellipsoid","origin","getColumn","cartographic","cartesianToCartographic","projectedPosition","newOrigin","z","w","newZAxis","UNIT_X","xAxis","add","newXAxis","newYAxis","magnitudeSquared","EPSILON10","cross","yAxis","UNIT_Y","UNIT_Z","setColumn","scratchCartesian","updateMembers","mode","heightChanged","positionChanged","equals","directionChanged","upChanged","rightChanged","transformChanged","COLUMBUS_VIEW","transform","multiplyByPoint","MORPHING","positionENU","unproject","det","abs","EPSILON2","invUpMag","scalar","w0","multiplyByPointAsVector","getHeading","heading","equalsEpsilon","EPSILON3","atan2","TWO_PI","zeroToTwoPi","getPitch","getRoll","roll","scratchHPRMatrix1","scratchHPRMatrix2","Object","defineProperties","get","inverseTransform","viewMatrix","inverseViewMatrix","upWC","rightWC","oldTransform","eastNorthUpToFixedFrame","_setTransform","pitch","moveStart","moveEnd","changed","update","updateFrustum","maxZoomOut","ratio","clampMove2D","setTransformPosition","setTransformUp","setTransformDirection","inverse","scratchAdjustOrtghographicFrustumMousePosition","pickGlobeScratchRay","scratchRayIntersection","scratchDepthIntersection","_adjustOrthographicFrustum","zooming","width","globe","rayIntersection","depthIntersection","mousePosition","ray","getPickRay","pickWorldCoordinates","pickPositionSupported","pickPositionWorldCoordinates","depthDistance","Number","POSITIVE_INFINITY","rayDistance","scratchSetViewCartesian","scratchSetViewTransform1","scratchSetViewTransform2","scratchSetViewQuaternion","scratchSetViewMatrix3","scratchSetViewCartographic","setView3D","hpr","currentTransform","localTransform","ZERO","rotQuat","fromHeadingPitchRoll","rotMat","fromQuaternion","setViewCV","convert","setView2D","newLeft","newRight","mapMode2D","ROTATE","scratchToHPRDirection","scratchToHPRUp","scratchToHPRRight","directionUpToHeadingPitchRoll","orientation","result","invTransform","scratchSetViewOptions","destination","endTransform","scratchHpr","setView","options","EMPTY_OBJECT","west","getRectangleCameraCoordinates","pitchScratch","flyHome","duration","completeMorph","flyTo","maxRadii","maximumRadius","acos","worldToCameraCoordinates","cartesian","multiplyByVector","worldToCameraCoordinatesPoint","worldToCameraCoordinatesVector","cameraToWorldCoordinates","cameraToWorldCoordinatesPoint","cameraToWorldCoordinatesVector","rotatable2D","maxProjectedX","maxProjectedY","minX","maxX","moveScratch","move","amount","cameraPosition","moveForward","zoom2D","moveBackward","moveUp","moveDown","moveRight","moveLeft","lookLeft","look","lookRight","lookUp","lookDown","lookScratchQuaternion","lookScratchMatrix","axis","angle","turnAngle","quaternion","fromAxisAngle","rotation","twistLeft","twistRight","rotateScratchQuaternion","rotateScratchMatrix","rotate","rotateDown","rotateVertical","rotateUp","rotateVertScratchP","rotateVertScratchA","rotateVertScratchTan","rotateVertScratchNegate","p","northParallel","southParallel","negate","angleToAxis","EPSILON4","tangent","rotateRight","rotateHorizontal","rotateLeft","newTop","newBottom","maxBottom","maxRight","zoom3D","zoomIn","zoomOut","getMagnitude","scratchLookAtMatrix4","lookAt","target","offset","WGS84","lookAtTransform","scratchLookAtHeadingPitchRangeOffset","scratchLookAtHeadingPitchRangeQuaternion1","scratchLookAtHeadingPitchRangeQuaternion2","scratchHeadingPitchRangeMatrix3","offsetFromHeadingPitchRange","range","clamp","pitchQuat","headingQuat","rotMatrix","cartesianOffset","viewRectangle3DCartographic1","viewRectangle3DCartographic2","viewRectangle3DNorthEast","viewRectangle3DSouthWest","viewRectangle3DNorthWest","viewRectangle3DSouthEast","viewRectangle3DNorthCenter","viewRectangle3DSouthCenter","viewRectangle3DCenter","viewRectangle3DEquator","defaultRF","viewRectangle3DEllipsoidGeodesic","computeD","upOrRight","corner","tanThetaOrPhi","opposite","rectangle","updateCamera","cameraRF","north","south","east","longitude","latitude","RADIANS_PER_DEGREE","northCartographic","southCartographic","ellipsoidGeodesic","setEndPoints","interpolateUsingFraction","centerCartographic","center","cartographicToCartesian","cart","northEast","northWest","northCenter","southCenter","southEast","southWest","geodeticSurfaceNormal","d","rightScalar","topScalar","_offCenterFrustum","heightRatio","tanPhi","tan","tanTheta","equatorCartographic","equatorPosition","viewRectangleCVCartographic","viewRectangleCVNorthEast","viewRectangleCVSouthWest","rectangleCameraPositionColumbusView","MAX_VALUE","viewRectangle2DCartographic","viewRectangle2DNorthEast","viewRectangle2DSouthWest","rectangleCameraPosition2D","INFINITE_SCROLL","pickEllipsoid3DRay","pickEllipsoid3D","windowPosition","intersection","rayEllipsoid","t","start","stop","getPoint","pickEllipsoid2DRay","pickMap2D","fromElements","pickEllipsoidCVRay","pickMapColumbusView","pickEllipsoid","canvas","clientWidth","clientHeight","pickPerspCenter","pickPerspXDir","pickPerspYDir","getPickRayPerspective","near","nearCenter","xDir","yDir","scratchDirection","getPickRayOrthographic","scratchToCenter","scratchProj","distanceToBoundingSphere","boundingSphere","toCenter","proj","radius","scratchPixelSize","getPixelSize","pixelSize","getPixelDimensions","pixelRatio","createAnimationTemplateCV","maxY","newPosition","updateCV","value","interp","lerp","time","easingFunction","EXPONENTIAL_OUT","startObject","stopObject","normalScratch","centerScratch","posScratch","scratchCartesian3Subtract","createAnimationCV","normal","distToC","dWidth","dHeight","mapWidth","mapHeight","translateX","translateY","createCorrectPositionTween","scratchFlyToDestination","newOptions","complete","cancel","maximumHeight","cancelFlight","cancelTween","setViewOptions","isRectangle","that","flightTween","pitchAdjustHeight","flyOverLongitude","flyOverLongitudeWeight","tweenOptions","createTween","tweens","preloadFlightCamera","preloadFlightCullingVolume","computeCullingVolume","distanceToBoundingSphere3D","distanceToBoundingSphere2D","MINIMUM_ZOOM","adjustBoundingSphereOffset","minimumZoom","screenSpaceCameraController","minimumZoomDistance","maximumZoom","maximumZoomDistance","viewBoundingSphere","scratchflyToBoundingSphereTransform","scratchflyToBoundingSphereDestination","scratchflyToBoundingSphereDirection","scratchflyToBoundingSphereUp","scratchflyToBoundingSphereRight","scratchFlyToBoundingSphereCart4","scratchFlyToBoundingSphereQuaternion","scratchFlyToBoundingSphereMatrix3","flyToBoundingSphere","scene2D","EPSILON6","rotateQuat","fromCartesian4","scratchCartesian3_1","scratchCartesian3_2","scratchCartesian3_3","scratchCartesian3_4","horizonPoints","computeHorizonQuad","radii","q","multiplyComponents","oneOverRadii","qMagnitude","qUnit","eUnit","nUnit","wMagnitude","sqrt","eastOffset","northOffset","upperLeft","lowerLeft","lowerRight","upperRight","scratchPickCartesian2","scratchRectCartesian","cartoArray","addToResult","index","computedHorizonQuad","r","computeViewRectangle","cullingVolume","visibility","computeVisibility","OUTSIDE","successfulPickCount","fromCartographicArray","lastLon","i","lon","diff","EPSILON9","switchToPerspectiveFrustum","switchToOrthographicFrustum","projectionMatrix"],"mappings":"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","sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EasingFunction from \"../Core/EasingFunction.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EllipsoidGeodesic from \"../Core/EllipsoidGeodesic.js\";\nimport Event from \"../Core/Event.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport HeadingPitchRange from \"../Core/HeadingPitchRange.js\";\nimport HeadingPitchRoll from \"../Core/HeadingPitchRoll.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport CameraFlightPath from \"./CameraFlightPath.js\";\nimport MapMode2D from \"./MapMode2D.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * The camera is defined by a position, orientation, and view frustum.\n * <br /><br />\n * The orientation forms an orthonormal basis with a view, up and right = view x up unit vectors.\n * <br /><br />\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias Camera\n *\n * @constructor\n *\n * @param {Scene} scene The scene.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Camera.html|Cesium Sandcastle Camera Demo}\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Camera%20Tutorial.html\">Sandcastle Example</a> from the <a href=\"https://cesium.com/docs/tutorials/camera/|Camera Tutorial}\n *\n * @example\n * // Create a camera looking down the negative z-axis, positioned at the origin,\n * // with a field of view of 60 degrees, and 1:1 aspect ratio.\n * var camera = new Cesium.Camera(scene);\n * camera.position = new Cesium.Cartesian3();\n * camera.direction = Cesium.Cartesian3.negate(Cesium.Cartesian3.UNIT_Z, new Cesium.Cartesian3());\n * camera.up = Cesium.Cartesian3.clone(Cesium.Cartesian3.UNIT_Y);\n * camera.frustum.fov = Cesium.Math.PI_OVER_THREE;\n * camera.frustum.near = 1.0;\n * camera.frustum.far = 2.0;\n */\nfunction Camera(scene) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  //>>includeEnd('debug');\n  this._scene = scene;\n\n  this._transform = Matrix4.clone(Matrix4.IDENTITY);\n  this._invTransform = Matrix4.clone(Matrix4.IDENTITY);\n  this._actualTransform = Matrix4.clone(Matrix4.IDENTITY);\n  this._actualInvTransform = Matrix4.clone(Matrix4.IDENTITY);\n  this._transformChanged = false;\n\n  /**\n   * The position of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.position = new Cartesian3();\n  this._position = new Cartesian3();\n  this._positionWC = new Cartesian3();\n  this._positionCartographic = new Cartographic();\n  this._oldPositionWC = undefined;\n\n  /**\n   * The position delta magnitude.\n   *\n   * @private\n   */\n  this.positionWCDeltaMagnitude = 0.0;\n\n  /**\n   * The position delta magnitude last frame.\n   *\n   * @private\n   */\n  this.positionWCDeltaMagnitudeLastFrame = 0.0;\n\n  /**\n   * How long in seconds since the camera has stopped moving\n   *\n   * @private\n   */\n  this.timeSinceMoved = 0.0;\n  this._lastMovedTimestamp = 0.0;\n\n  /**\n   * The view direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.direction = new Cartesian3();\n  this._direction = new Cartesian3();\n  this._directionWC = new Cartesian3();\n\n  /**\n   * The up direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.up = new Cartesian3();\n  this._up = new Cartesian3();\n  this._upWC = new Cartesian3();\n\n  /**\n   * The right direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.right = new Cartesian3();\n  this._right = new Cartesian3();\n  this._rightWC = new Cartesian3();\n\n  /**\n   * The region of space in view.\n   *\n   * @type {Frustum}\n   * @default PerspectiveFrustum()\n   *\n   * @see PerspectiveFrustum\n   * @see PerspectiveOffCenterFrustum\n   * @see OrthographicFrustum\n   */\n  this.frustum = new PerspectiveFrustum();\n  this.frustum.aspectRatio =\n    scene.drawingBufferWidth / scene.drawingBufferHeight;\n  this.frustum.fov = CesiumMath.toRadians(60.0);\n\n  /**\n   * The default amount to move the camera when an argument is not\n   * provided to the move methods.\n   * @type {Number}\n   * @default 100000.0;\n   */\n  this.defaultMoveAmount = 100000.0;\n  /**\n   * The default amount to rotate the camera when an argument is not\n   * provided to the look methods.\n   * @type {Number}\n   * @default Math.PI / 60.0\n   */\n  this.defaultLookAmount = Math.PI / 60.0;\n  /**\n   * The default amount to rotate the camera when an argument is not\n   * provided to the rotate methods.\n   * @type {Number}\n   * @default Math.PI / 3600.0\n   */\n  this.defaultRotateAmount = Math.PI / 3600.0;\n  /**\n   * The default amount to move the camera when an argument is not\n   * provided to the zoom methods.\n   * @type {Number}\n   * @default 100000.0;\n   */\n  this.defaultZoomAmount = 100000.0;\n  /**\n   * If set, the camera will not be able to rotate past this axis in either direction.\n   * @type {Cartesian3}\n   * @default undefined\n   */\n  this.constrainedAxis = undefined;\n  /**\n   * The factor multiplied by the the map size used to determine where to clamp the camera position\n   * when zooming out from the surface. The default is 1.5. Only valid for 2D and the map is rotatable.\n   * @type {Number}\n   * @default 1.5\n   */\n  this.maximumZoomFactor = 1.5;\n\n  this._moveStart = new Event();\n  this._moveEnd = new Event();\n\n  this._changed = new Event();\n  this._changedPosition = undefined;\n  this._changedDirection = undefined;\n  this._changedFrustum = undefined;\n\n  /**\n   * The amount the camera has to change before the <code>changed</code> event is raised. The value is a percentage in the [0, 1] range.\n   * @type {number}\n   * @default 0.5\n   */\n  this.percentageChanged = 0.5;\n\n  this._viewMatrix = new Matrix4();\n  this._invViewMatrix = new Matrix4();\n  updateViewMatrix(this);\n\n  this._mode = SceneMode.SCENE3D;\n  this._modeChanged = true;\n  var projection = scene.mapProjection;\n  this._projection = projection;\n  this._maxCoord = projection.project(\n    new Cartographic(Math.PI, CesiumMath.PI_OVER_TWO)\n  );\n  this._max2Dfrustum = undefined;\n\n  // set default view\n  rectangleCameraPosition3D(\n    this,\n    Camera.DEFAULT_VIEW_RECTANGLE,\n    this.position,\n    true\n  );\n\n  var mag = Cartesian3.magnitude(this.position);\n  mag += mag * Camera.DEFAULT_VIEW_FACTOR;\n  Cartesian3.normalize(this.position, this.position);\n  Cartesian3.multiplyByScalar(this.position, mag, this.position);\n}\n\n/**\n * @private\n */\nCamera.TRANSFORM_2D = new Matrix4(\n  0.0,\n  0.0,\n  1.0,\n  0.0,\n  1.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  1.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  1.0\n);\n\n/**\n * @private\n */\nCamera.TRANSFORM_2D_INVERSE = Matrix4.inverseTransformation(\n  Camera.TRANSFORM_2D,\n  new Matrix4()\n);\n\n/**\n * The default rectangle the camera will view on creation.\n * @type Rectangle\n */\nCamera.DEFAULT_VIEW_RECTANGLE = Rectangle.fromDegrees(\n  -95.0,\n  -20.0,\n  -70.0,\n  90.0\n);\n\n/**\n * A scalar to multiply to the camera position and add it back after setting the camera to view the rectangle.\n * A value of zero means the camera will view the entire {@link Camera#DEFAULT_VIEW_RECTANGLE}, a value greater than zero\n * will move it further away from the extent, and a value less than zero will move it close to the extent.\n * @type Number\n */\nCamera.DEFAULT_VIEW_FACTOR = 0.5;\n\n/**\n * The default heading/pitch/range that is used when the camera flies to a location that contains a bounding sphere.\n * @type HeadingPitchRange\n */\nCamera.DEFAULT_OFFSET = new HeadingPitchRange(\n  0.0,\n  -CesiumMath.PI_OVER_FOUR,\n  0.0\n);\n\nfunction updateViewMatrix(camera) {\n  Matrix4.computeView(\n    camera._position,\n    camera._direction,\n    camera._up,\n    camera._right,\n    camera._viewMatrix\n  );\n  Matrix4.multiply(\n    camera._viewMatrix,\n    camera._actualInvTransform,\n    camera._viewMatrix\n  );\n  Matrix4.inverseTransformation(camera._viewMatrix, camera._invViewMatrix);\n}\n\nfunction updateCameraDeltas(camera) {\n  if (!defined(camera._oldPositionWC)) {\n    camera._oldPositionWC = Cartesian3.clone(\n      camera.positionWC,\n      camera._oldPositionWC\n    );\n  } else {\n    camera.positionWCDeltaMagnitudeLastFrame = camera.positionWCDeltaMagnitude;\n    var delta = Cartesian3.subtract(\n      camera.positionWC,\n      camera._oldPositionWC,\n      camera._oldPositionWC\n    );\n    camera.positionWCDeltaMagnitude = Cartesian3.magnitude(delta);\n    camera._oldPositionWC = Cartesian3.clone(\n      camera.positionWC,\n      camera._oldPositionWC\n    );\n\n    // Update move timers\n    if (camera.positionWCDeltaMagnitude > 0.0) {\n      camera.timeSinceMoved = 0.0;\n      camera._lastMovedTimestamp = getTimestamp();\n    } else {\n      camera.timeSinceMoved =\n        Math.max(getTimestamp() - camera._lastMovedTimestamp, 0.0) / 1000.0;\n    }\n  }\n}\n\n/**\n * Checks if there's a camera flight with preload for this camera.\n *\n * @returns {Boolean} Whether or not this camera has a current flight with a valid preloadFlightCamera in scene.\n *\n * @private\n *\n */\nCamera.prototype.canPreloadFlight = function () {\n  return defined(this._currentFlight) && this._mode !== SceneMode.SCENE2D;\n};\n\nCamera.prototype._updateCameraChanged = function () {\n  var camera = this;\n\n  updateCameraDeltas(camera);\n\n  if (camera._changed.numberOfListeners === 0) {\n    return;\n  }\n\n  var percentageChanged = camera.percentageChanged;\n\n  if (camera._mode === SceneMode.SCENE2D) {\n    if (!defined(camera._changedFrustum)) {\n      camera._changedPosition = Cartesian3.clone(\n        camera.position,\n        camera._changedPosition\n      );\n      camera._changedFrustum = camera.frustum.clone();\n      return;\n    }\n\n    var position = camera.position;\n    var lastPosition = camera._changedPosition;\n\n    var frustum = camera.frustum;\n    var lastFrustum = camera._changedFrustum;\n\n    var x0 = position.x + frustum.left;\n    var x1 = position.x + frustum.right;\n    var x2 = lastPosition.x + lastFrustum.left;\n    var x3 = lastPosition.x + lastFrustum.right;\n\n    var y0 = position.y + frustum.bottom;\n    var y1 = position.y + frustum.top;\n    var y2 = lastPosition.y + lastFrustum.bottom;\n    var y3 = lastPosition.y + lastFrustum.top;\n\n    var leftX = Math.max(x0, x2);\n    var rightX = Math.min(x1, x3);\n    var bottomY = Math.max(y0, y2);\n    var topY = Math.min(y1, y3);\n\n    var areaPercentage;\n    if (leftX >= rightX || bottomY >= y1) {\n      areaPercentage = 1.0;\n    } else {\n      var areaRef = lastFrustum;\n      if (x0 < x2 && x1 > x3 && y0 < y2 && y1 > y3) {\n        areaRef = frustum;\n      }\n      areaPercentage =\n        1.0 -\n        ((rightX - leftX) * (topY - bottomY)) /\n          ((areaRef.right - areaRef.left) * (areaRef.top - areaRef.bottom));\n    }\n\n    if (areaPercentage > percentageChanged) {\n      camera._changed.raiseEvent(areaPercentage);\n      camera._changedPosition = Cartesian3.clone(\n        camera.position,\n        camera._changedPosition\n      );\n      camera._changedFrustum = camera.frustum.clone(camera._changedFrustum);\n    }\n    return;\n  }\n\n  if (!defined(camera._changedDirection)) {\n    camera._changedPosition = Cartesian3.clone(\n      camera.positionWC,\n      camera._changedPosition\n    );\n    camera._changedDirection = Cartesian3.clone(\n      camera.directionWC,\n      camera._changedDirection\n    );\n    return;\n  }\n\n  var dirAngle = CesiumMath.acosClamped(\n    Cartesian3.dot(camera.directionWC, camera._changedDirection)\n  );\n\n  var dirPercentage;\n  if (defined(camera.frustum.fovy)) {\n    dirPercentage = dirAngle / (camera.frustum.fovy * 0.5);\n  } else {\n    dirPercentage = dirAngle;\n  }\n\n  var distance = Cartesian3.distance(\n    camera.positionWC,\n    camera._changedPosition\n  );\n  var heightPercentage = distance / camera.positionCartographic.height;\n\n  if (\n    dirPercentage > percentageChanged ||\n    heightPercentage > percentageChanged\n  ) {\n    camera._changed.raiseEvent(Math.max(dirPercentage, heightPercentage));\n    camera._changedPosition = Cartesian3.clone(\n      camera.positionWC,\n      camera._changedPosition\n    );\n    camera._changedDirection = Cartesian3.clone(\n      camera.directionWC,\n      camera._changedDirection\n    );\n  }\n};\n\nfunction convertTransformForColumbusView(camera) {\n  Transforms.basisTo2D(\n    camera._projection,\n    camera._transform,\n    camera._actualTransform\n  );\n}\n\nvar scratchCartographic = new Cartographic();\nvar scratchCartesian3Projection = new Cartesian3();\nvar scratchCartesian3 = new Cartesian3();\nvar scratchCartesian4Origin = new Cartesian4();\nvar scratchCartesian4NewOrigin = new Cartesian4();\nvar scratchCartesian4NewXAxis = new Cartesian4();\nvar scratchCartesian4NewYAxis = new Cartesian4();\nvar scratchCartesian4NewZAxis = new Cartesian4();\n\nfunction convertTransformFor2D(camera) {\n  var projection = camera._projection;\n  var ellipsoid = projection.ellipsoid;\n\n  var origin = Matrix4.getColumn(camera._transform, 3, scratchCartesian4Origin);\n  var cartographic = ellipsoid.cartesianToCartographic(\n    origin,\n    scratchCartographic\n  );\n\n  var projectedPosition = projection.project(\n    cartographic,\n    scratchCartesian3Projection\n  );\n  var newOrigin = scratchCartesian4NewOrigin;\n  newOrigin.x = projectedPosition.z;\n  newOrigin.y = projectedPosition.x;\n  newOrigin.z = projectedPosition.y;\n  newOrigin.w = 1.0;\n\n  var newZAxis = Cartesian4.clone(Cartesian4.UNIT_X, scratchCartesian4NewZAxis);\n\n  var xAxis = Cartesian4.add(\n    Matrix4.getColumn(camera._transform, 0, scratchCartesian3),\n    origin,\n    scratchCartesian3\n  );\n  ellipsoid.cartesianToCartographic(xAxis, cartographic);\n\n  projection.project(cartographic, projectedPosition);\n  var newXAxis = scratchCartesian4NewXAxis;\n  newXAxis.x = projectedPosition.z;\n  newXAxis.y = projectedPosition.x;\n  newXAxis.z = projectedPosition.y;\n  newXAxis.w = 0.0;\n\n  Cartesian3.subtract(newXAxis, newOrigin, newXAxis);\n  newXAxis.x = 0.0;\n\n  var newYAxis = scratchCartesian4NewYAxis;\n  if (Cartesian3.magnitudeSquared(newXAxis) > CesiumMath.EPSILON10) {\n    Cartesian3.cross(newZAxis, newXAxis, newYAxis);\n  } else {\n    var yAxis = Cartesian4.add(\n      Matrix4.getColumn(camera._transform, 1, scratchCartesian3),\n      origin,\n      scratchCartesian3\n    );\n    ellipsoid.cartesianToCartographic(yAxis, cartographic);\n\n    projection.project(cartographic, projectedPosition);\n    newYAxis.x = projectedPosition.z;\n    newYAxis.y = projectedPosition.x;\n    newYAxis.z = projectedPosition.y;\n    newYAxis.w = 0.0;\n\n    Cartesian3.subtract(newYAxis, newOrigin, newYAxis);\n    newYAxis.x = 0.0;\n\n    if (Cartesian3.magnitudeSquared(newYAxis) < CesiumMath.EPSILON10) {\n      Cartesian4.clone(Cartesian4.UNIT_Y, newXAxis);\n      Cartesian4.clone(Cartesian4.UNIT_Z, newYAxis);\n    }\n  }\n\n  Cartesian3.cross(newYAxis, newZAxis, newXAxis);\n  Cartesian3.normalize(newXAxis, newXAxis);\n  Cartesian3.cross(newZAxis, newXAxis, newYAxis);\n  Cartesian3.normalize(newYAxis, newYAxis);\n\n  Matrix4.setColumn(\n    camera._actualTransform,\n    0,\n    newXAxis,\n    camera._actualTransform\n  );\n  Matrix4.setColumn(\n    camera._actualTransform,\n    1,\n    newYAxis,\n    camera._actualTransform\n  );\n  Matrix4.setColumn(\n    camera._actualTransform,\n    2,\n    newZAxis,\n    camera._actualTransform\n  );\n  Matrix4.setColumn(\n    camera._actualTransform,\n    3,\n    newOrigin,\n    camera._actualTransform\n  );\n}\n\nvar scratchCartesian = new Cartesian3();\n\nfunction updateMembers(camera) {\n  var mode = camera._mode;\n\n  var heightChanged = false;\n  var height = 0.0;\n  if (mode === SceneMode.SCENE2D) {\n    height = camera.frustum.right - camera.frustum.left;\n    heightChanged = height !== camera._positionCartographic.height;\n  }\n\n  var position = camera._position;\n  var positionChanged =\n    !Cartesian3.equals(position, camera.position) || heightChanged;\n  if (positionChanged) {\n    position = Cartesian3.clone(camera.position, camera._position);\n  }\n\n  var direction = camera._direction;\n  var directionChanged = !Cartesian3.equals(direction, camera.direction);\n  if (directionChanged) {\n    Cartesian3.normalize(camera.direction, camera.direction);\n    direction = Cartesian3.clone(camera.direction, camera._direction);\n  }\n\n  var up = camera._up;\n  var upChanged = !Cartesian3.equals(up, camera.up);\n  if (upChanged) {\n    Cartesian3.normalize(camera.up, camera.up);\n    up = Cartesian3.clone(camera.up, camera._up);\n  }\n\n  var right = camera._right;\n  var rightChanged = !Cartesian3.equals(right, camera.right);\n  if (rightChanged) {\n    Cartesian3.normalize(camera.right, camera.right);\n    right = Cartesian3.clone(camera.right, camera._right);\n  }\n\n  var transformChanged = camera._transformChanged || camera._modeChanged;\n  camera._transformChanged = false;\n\n  if (transformChanged) {\n    Matrix4.inverseTransformation(camera._transform, camera._invTransform);\n\n    if (\n      camera._mode === SceneMode.COLUMBUS_VIEW ||\n      camera._mode === SceneMode.SCENE2D\n    ) {\n      if (Matrix4.equals(Matrix4.IDENTITY, camera._transform)) {\n        Matrix4.clone(Camera.TRANSFORM_2D, camera._actualTransform);\n      } else if (camera._mode === SceneMode.COLUMBUS_VIEW) {\n        convertTransformForColumbusView(camera);\n      } else {\n        convertTransformFor2D(camera);\n      }\n    } else {\n      Matrix4.clone(camera._transform, camera._actualTransform);\n    }\n\n    Matrix4.inverseTransformation(\n      camera._actualTransform,\n      camera._actualInvTransform\n    );\n\n    camera._modeChanged = false;\n  }\n\n  var transform = camera._actualTransform;\n\n  if (positionChanged || transformChanged) {\n    camera._positionWC = Matrix4.multiplyByPoint(\n      transform,\n      position,\n      camera._positionWC\n    );\n\n    // Compute the Cartographic position of the camera.\n    if (mode === SceneMode.SCENE3D || mode === SceneMode.MORPHING) {\n      camera._positionCartographic = camera._projection.ellipsoid.cartesianToCartographic(\n        camera._positionWC,\n        camera._positionCartographic\n      );\n    } else {\n      // The camera position is expressed in the 2D coordinate system where the Y axis is to the East,\n      // the Z axis is to the North, and the X axis is out of the map.  Express them instead in the ENU axes where\n      // X is to the East, Y is to the North, and Z is out of the local horizontal plane.\n      var positionENU = scratchCartesian;\n      positionENU.x = camera._positionWC.y;\n      positionENU.y = camera._positionWC.z;\n      positionENU.z = camera._positionWC.x;\n\n      // In 2D, the camera height is always 12.7 million meters.\n      // The apparent height is equal to half the frustum width.\n      if (mode === SceneMode.SCENE2D) {\n        positionENU.z = height;\n      }\n\n      camera._projection.unproject(positionENU, camera._positionCartographic);\n    }\n  }\n\n  if (directionChanged || upChanged || rightChanged) {\n    var det = Cartesian3.dot(\n      direction,\n      Cartesian3.cross(up, right, scratchCartesian)\n    );\n    if (Math.abs(1.0 - det) > CesiumMath.EPSILON2) {\n      //orthonormalize axes\n      var invUpMag = 1.0 / Cartesian3.magnitudeSquared(up);\n      var scalar = Cartesian3.dot(up, direction) * invUpMag;\n      var w0 = Cartesian3.multiplyByScalar(direction, scalar, scratchCartesian);\n      up = Cartesian3.normalize(\n        Cartesian3.subtract(up, w0, camera._up),\n        camera._up\n      );\n      Cartesian3.clone(up, camera.up);\n\n      right = Cartesian3.cross(direction, up, camera._right);\n      Cartesian3.clone(right, camera.right);\n    }\n  }\n\n  if (directionChanged || transformChanged) {\n    camera._directionWC = Matrix4.multiplyByPointAsVector(\n      transform,\n      direction,\n      camera._directionWC\n    );\n    Cartesian3.normalize(camera._directionWC, camera._directionWC);\n  }\n\n  if (upChanged || transformChanged) {\n    camera._upWC = Matrix4.multiplyByPointAsVector(transform, up, camera._upWC);\n    Cartesian3.normalize(camera._upWC, camera._upWC);\n  }\n\n  if (rightChanged || transformChanged) {\n    camera._rightWC = Matrix4.multiplyByPointAsVector(\n      transform,\n      right,\n      camera._rightWC\n    );\n    Cartesian3.normalize(camera._rightWC, camera._rightWC);\n  }\n\n  if (\n    positionChanged ||\n    directionChanged ||\n    upChanged ||\n    rightChanged ||\n    transformChanged\n  ) {\n    updateViewMatrix(camera);\n  }\n}\n\nfunction getHeading(direction, up) {\n  var heading;\n  if (\n    !CesiumMath.equalsEpsilon(Math.abs(direction.z), 1.0, CesiumMath.EPSILON3)\n  ) {\n    heading = Math.atan2(direction.y, direction.x) - CesiumMath.PI_OVER_TWO;\n  } else {\n    heading = Math.atan2(up.y, up.x) - CesiumMath.PI_OVER_TWO;\n  }\n\n  return CesiumMath.TWO_PI - CesiumMath.zeroToTwoPi(heading);\n}\n\nfunction getPitch(direction) {\n  return CesiumMath.PI_OVER_TWO - CesiumMath.acosClamped(direction.z);\n}\n\nfunction getRoll(direction, up, right) {\n  var roll = 0.0;\n  if (\n    !CesiumMath.equalsEpsilon(Math.abs(direction.z), 1.0, CesiumMath.EPSILON3)\n  ) {\n    roll = Math.atan2(-right.z, up.z);\n    roll = CesiumMath.zeroToTwoPi(roll + CesiumMath.TWO_PI);\n  }\n\n  return roll;\n}\n\nvar scratchHPRMatrix1 = new Matrix4();\nvar scratchHPRMatrix2 = new Matrix4();\n\nObject.defineProperties(Camera.prototype, {\n  /**\n   * Gets the camera's reference frame. The inverse of this transformation is appended to the view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @default {@link Matrix4.IDENTITY}\n   */\n  transform: {\n    get: function () {\n      return this._transform;\n    },\n  },\n\n  /**\n   * Gets the inverse camera transform.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @default {@link Matrix4.IDENTITY}\n   */\n  inverseTransform: {\n    get: function () {\n      updateMembers(this);\n      return this._invTransform;\n    },\n  },\n\n  /**\n   * Gets the view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see Camera#inverseViewMatrix\n   */\n  viewMatrix: {\n    get: function () {\n      updateMembers(this);\n      return this._viewMatrix;\n    },\n  },\n\n  /**\n   * Gets the inverse view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see Camera#viewMatrix\n   */\n  inverseViewMatrix: {\n    get: function () {\n      updateMembers(this);\n      return this._invViewMatrix;\n    },\n  },\n\n  /**\n   * Gets the {@link Cartographic} position of the camera, with longitude and latitude\n   * expressed in radians and height in meters.  In 2D and Columbus View, it is possible\n   * for the returned longitude and latitude to be outside the range of valid longitudes\n   * and latitudes when the camera is outside the map.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartographic}\n   * @readonly\n   */\n  positionCartographic: {\n    get: function () {\n      updateMembers(this);\n      return this._positionCartographic;\n    },\n  },\n\n  /**\n   * Gets the position of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  positionWC: {\n    get: function () {\n      updateMembers(this);\n      return this._positionWC;\n    },\n  },\n\n  /**\n   * Gets the view direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  directionWC: {\n    get: function () {\n      updateMembers(this);\n      return this._directionWC;\n    },\n  },\n\n  /**\n   * Gets the up direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  upWC: {\n    get: function () {\n      updateMembers(this);\n      return this._upWC;\n    },\n  },\n\n  /**\n   * Gets the right direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  rightWC: {\n    get: function () {\n      updateMembers(this);\n      return this._rightWC;\n    },\n  },\n\n  /**\n   * Gets the camera heading in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  heading: {\n    get: function () {\n      if (this._mode !== SceneMode.MORPHING) {\n        var ellipsoid = this._projection.ellipsoid;\n\n        var oldTransform = Matrix4.clone(this._transform, scratchHPRMatrix1);\n        var transform = Transforms.eastNorthUpToFixedFrame(\n          this.positionWC,\n          ellipsoid,\n          scratchHPRMatrix2\n        );\n        this._setTransform(transform);\n\n        var heading = getHeading(this.direction, this.up);\n\n        this._setTransform(oldTransform);\n\n        return heading;\n      }\n\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the camera pitch in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  pitch: {\n    get: function () {\n      if (this._mode !== SceneMode.MORPHING) {\n        var ellipsoid = this._projection.ellipsoid;\n\n        var oldTransform = Matrix4.clone(this._transform, scratchHPRMatrix1);\n        var transform = Transforms.eastNorthUpToFixedFrame(\n          this.positionWC,\n          ellipsoid,\n          scratchHPRMatrix2\n        );\n        this._setTransform(transform);\n\n        var pitch = getPitch(this.direction);\n\n        this._setTransform(oldTransform);\n\n        return pitch;\n      }\n\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the camera roll in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  roll: {\n    get: function () {\n      if (this._mode !== SceneMode.MORPHING) {\n        var ellipsoid = this._projection.ellipsoid;\n\n        var oldTransform = Matrix4.clone(this._transform, scratchHPRMatrix1);\n        var transform = Transforms.eastNorthUpToFixedFrame(\n          this.positionWC,\n          ellipsoid,\n          scratchHPRMatrix2\n        );\n        this._setTransform(transform);\n\n        var roll = getRoll(this.direction, this.up, this.right);\n\n        this._setTransform(oldTransform);\n\n        return roll;\n      }\n\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised at when the camera starts to move.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  moveStart: {\n    get: function () {\n      return this._moveStart;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised when the camera has stopped moving.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  moveEnd: {\n    get: function () {\n      return this._moveEnd;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised when the camera has changed by <code>percentageChanged</code>.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  changed: {\n    get: function () {\n      return this._changed;\n    },\n  },\n});\n\n/**\n * @private\n */\nCamera.prototype.update = function (mode) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(mode)) {\n    throw new DeveloperError(\"mode is required.\");\n  }\n  if (\n    mode === SceneMode.SCENE2D &&\n    !(this.frustum instanceof OrthographicOffCenterFrustum)\n  ) {\n    throw new DeveloperError(\n      \"An OrthographicOffCenterFrustum is required in 2D.\"\n    );\n  }\n  if (\n    (mode === SceneMode.SCENE3D || mode === SceneMode.COLUMBUS_VIEW) &&\n    !(this.frustum instanceof PerspectiveFrustum) &&\n    !(this.frustum instanceof OrthographicFrustum)\n  ) {\n    throw new DeveloperError(\n      \"A PerspectiveFrustum or OrthographicFrustum is required in 3D and Columbus view\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var updateFrustum = false;\n  if (mode !== this._mode) {\n    this._mode = mode;\n    this._modeChanged = mode !== SceneMode.MORPHING;\n    updateFrustum = this._mode === SceneMode.SCENE2D;\n  }\n\n  if (updateFrustum) {\n    var frustum = (this._max2Dfrustum = this.frustum.clone());\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!(frustum instanceof OrthographicOffCenterFrustum)) {\n      throw new DeveloperError(\n        \"The camera frustum is expected to be orthographic for 2D camera control.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    var maxZoomOut = 2.0;\n    var ratio = frustum.top / frustum.right;\n    frustum.right = this._maxCoord.x * maxZoomOut;\n    frustum.left = -frustum.right;\n    frustum.top = ratio * frustum.right;\n    frustum.bottom = -frustum.top;\n  }\n\n  if (this._mode === SceneMode.SCENE2D) {\n    clampMove2D(this, this.position);\n  }\n};\n\nvar setTransformPosition = new Cartesian3();\nvar setTransformUp = new Cartesian3();\nvar setTransformDirection = new Cartesian3();\n\nCamera.prototype._setTransform = function (transform) {\n  var position = Cartesian3.clone(this.positionWC, setTransformPosition);\n  var up = Cartesian3.clone(this.upWC, setTransformUp);\n  var direction = Cartesian3.clone(this.directionWC, setTransformDirection);\n\n  Matrix4.clone(transform, this._transform);\n  this._transformChanged = true;\n  updateMembers(this);\n  var inverse = this._actualInvTransform;\n\n  Matrix4.multiplyByPoint(inverse, position, this.position);\n  Matrix4.multiplyByPointAsVector(inverse, direction, this.direction);\n  Matrix4.multiplyByPointAsVector(inverse, up, this.up);\n  Cartesian3.cross(this.direction, this.up, this.right);\n\n  updateMembers(this);\n};\n\nvar scratchAdjustOrtghographicFrustumMousePosition = new Cartesian2();\nvar pickGlobeScratchRay = new Ray();\nvar scratchRayIntersection = new Cartesian3();\nvar scratchDepthIntersection = new Cartesian3();\n\nCamera.prototype._adjustOrthographicFrustum = function (zooming) {\n  if (!(this.frustum instanceof OrthographicFrustum)) {\n    return;\n  }\n\n  if (!zooming && this._positionCartographic.height < 150000.0) {\n    return;\n  }\n\n  if (!Matrix4.equals(Matrix4.IDENTITY, this.transform)) {\n    this.frustum.width = Cartesian3.magnitude(this.position);\n    return;\n  }\n\n  var scene = this._scene;\n  var globe = scene.globe;\n  var rayIntersection;\n  var depthIntersection;\n\n  if (defined(globe)) {\n    var mousePosition = scratchAdjustOrtghographicFrustumMousePosition;\n    mousePosition.x = scene.drawingBufferWidth / 2.0;\n    mousePosition.y = scene.drawingBufferHeight / 2.0;\n\n    var ray = this.getPickRay(mousePosition, pickGlobeScratchRay);\n    rayIntersection = globe.pickWorldCoordinates(\n      ray,\n      scene,\n      scratchRayIntersection\n    );\n\n    if (scene.pickPositionSupported) {\n      depthIntersection = scene.pickPositionWorldCoordinates(\n        mousePosition,\n        scratchDepthIntersection\n      );\n    }\n\n    if (defined(rayIntersection) && defined(depthIntersection)) {\n      var depthDistance = defined(depthIntersection)\n        ? Cartesian3.distance(depthIntersection, this.positionWC)\n        : Number.POSITIVE_INFINITY;\n      var rayDistance = defined(rayIntersection)\n        ? Cartesian3.distance(rayIntersection, this.positionWC)\n        : Number.POSITIVE_INFINITY;\n      this.frustum.width = Math.min(depthDistance, rayDistance);\n    } else if (defined(depthIntersection)) {\n      this.frustum.width = Cartesian3.distance(\n        depthIntersection,\n        this.positionWC\n      );\n    } else if (defined(rayIntersection)) {\n      this.frustum.width = Cartesian3.distance(\n        rayIntersection,\n        this.positionWC\n      );\n    }\n  }\n\n  if (\n    !defined(globe) ||\n    (!defined(rayIntersection) && !defined(depthIntersection))\n  ) {\n    var distance = Math.max(this.positionCartographic.height, 0.0);\n    this.frustum.width = distance;\n  }\n};\n\nvar scratchSetViewCartesian = new Cartesian3();\nvar scratchSetViewTransform1 = new Matrix4();\nvar scratchSetViewTransform2 = new Matrix4();\nvar scratchSetViewQuaternion = new Quaternion();\nvar scratchSetViewMatrix3 = new Matrix3();\nvar scratchSetViewCartographic = new Cartographic();\n\nfunction setView3D(camera, position, hpr) {\n  var currentTransform = Matrix4.clone(\n    camera.transform,\n    scratchSetViewTransform1\n  );\n  var localTransform = Transforms.eastNorthUpToFixedFrame(\n    position,\n    camera._projection.ellipsoid,\n    scratchSetViewTransform2\n  );\n  camera._setTransform(localTransform);\n\n  Cartesian3.clone(Cartesian3.ZERO, camera.position);\n  hpr.heading = hpr.heading - CesiumMath.PI_OVER_TWO;\n\n  var rotQuat = Quaternion.fromHeadingPitchRoll(hpr, scratchSetViewQuaternion);\n  var rotMat = Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n\n  Matrix3.getColumn(rotMat, 0, camera.direction);\n  Matrix3.getColumn(rotMat, 2, camera.up);\n  Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n  camera._setTransform(currentTransform);\n\n  camera._adjustOrthographicFrustum(true);\n}\n\nfunction setViewCV(camera, position, hpr, convert) {\n  var currentTransform = Matrix4.clone(\n    camera.transform,\n    scratchSetViewTransform1\n  );\n  camera._setTransform(Matrix4.IDENTITY);\n\n  if (!Cartesian3.equals(position, camera.positionWC)) {\n    if (convert) {\n      var projection = camera._projection;\n      var cartographic = projection.ellipsoid.cartesianToCartographic(\n        position,\n        scratchSetViewCartographic\n      );\n      position = projection.project(cartographic, scratchSetViewCartesian);\n    }\n    Cartesian3.clone(position, camera.position);\n  }\n  hpr.heading = hpr.heading - CesiumMath.PI_OVER_TWO;\n\n  var rotQuat = Quaternion.fromHeadingPitchRoll(hpr, scratchSetViewQuaternion);\n  var rotMat = Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n\n  Matrix3.getColumn(rotMat, 0, camera.direction);\n  Matrix3.getColumn(rotMat, 2, camera.up);\n  Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n  camera._setTransform(currentTransform);\n\n  camera._adjustOrthographicFrustum(true);\n}\n\nfunction setView2D(camera, position, hpr, convert) {\n  var currentTransform = Matrix4.clone(\n    camera.transform,\n    scratchSetViewTransform1\n  );\n  camera._setTransform(Matrix4.IDENTITY);\n\n  if (!Cartesian3.equals(position, camera.positionWC)) {\n    if (convert) {\n      var projection = camera._projection;\n      var cartographic = projection.ellipsoid.cartesianToCartographic(\n        position,\n        scratchSetViewCartographic\n      );\n      position = projection.project(cartographic, scratchSetViewCartesian);\n    }\n\n    Cartesian2.clone(position, camera.position);\n\n    var newLeft = -position.z * 0.5;\n    var newRight = -newLeft;\n\n    var frustum = camera.frustum;\n    if (newRight > newLeft) {\n      var ratio = frustum.top / frustum.right;\n      frustum.right = newRight;\n      frustum.left = newLeft;\n      frustum.top = frustum.right * ratio;\n      frustum.bottom = -frustum.top;\n    }\n  }\n\n  if (camera._scene.mapMode2D === MapMode2D.ROTATE) {\n    hpr.heading = hpr.heading - CesiumMath.PI_OVER_TWO;\n    hpr.pitch = -CesiumMath.PI_OVER_TWO;\n    hpr.roll = 0.0;\n    var rotQuat = Quaternion.fromHeadingPitchRoll(\n      hpr,\n      scratchSetViewQuaternion\n    );\n    var rotMat = Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n\n    Matrix3.getColumn(rotMat, 2, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n  }\n\n  camera._setTransform(currentTransform);\n}\n\nvar scratchToHPRDirection = new Cartesian3();\nvar scratchToHPRUp = new Cartesian3();\nvar scratchToHPRRight = new Cartesian3();\n\nfunction directionUpToHeadingPitchRoll(camera, position, orientation, result) {\n  var direction = Cartesian3.clone(\n    orientation.direction,\n    scratchToHPRDirection\n  );\n  var up = Cartesian3.clone(orientation.up, scratchToHPRUp);\n\n  if (camera._scene.mode === SceneMode.SCENE3D) {\n    var ellipsoid = camera._projection.ellipsoid;\n    var transform = Transforms.eastNorthUpToFixedFrame(\n      position,\n      ellipsoid,\n      scratchHPRMatrix1\n    );\n    var invTransform = Matrix4.inverseTransformation(\n      transform,\n      scratchHPRMatrix2\n    );\n\n    Matrix4.multiplyByPointAsVector(invTransform, direction, direction);\n    Matrix4.multiplyByPointAsVector(invTransform, up, up);\n  }\n\n  var right = Cartesian3.cross(direction, up, scratchToHPRRight);\n\n  result.heading = getHeading(direction, up);\n  result.pitch = getPitch(direction);\n  result.roll = getRoll(direction, up, right);\n\n  return result;\n}\n\nvar scratchSetViewOptions = {\n  destination: undefined,\n  orientation: {\n    direction: undefined,\n    up: undefined,\n    heading: undefined,\n    pitch: undefined,\n    roll: undefined,\n  },\n  convert: undefined,\n  endTransform: undefined,\n};\n\nvar scratchHpr = new HeadingPitchRoll();\n/**\n * Sets the camera position, orientation and transform.\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3|Rectangle} [options.destination] The final position of the camera in WGS84 (world) coordinates or a rectangle that would be visible from a top-down view.\n * @param {Object} [options.orientation] An object that contains either direction and up properties or heading, pitch and roll properties. By default, the direction will point\n * towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive\n * y direction in Columbus view. Orientation is not used in 2D when in infinite scrolling mode.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame of the camera.\n * @param {Boolean} [options.convert] Whether to convert the destination from world coordinates to scene coordinates (only relevant when not using 3D). Defaults to <code>true</code>.\n *\n * @example\n * // 1. Set position with a top-down view\n * viewer.camera.setView({\n *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)\n * });\n *\n * // 2 Set view with heading, pitch and roll\n * viewer.camera.setView({\n *     destination : cartesianPosition,\n *     orientation: {\n *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)\n *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)\n *         roll : 0.0                             // default value\n *     }\n * });\n *\n * // 3. Change heading, pitch and roll with the camera position remaining the same.\n * viewer.camera.setView({\n *     orientation: {\n *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)\n *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)\n *         roll : 0.0                             // default value\n *     }\n * });\n *\n *\n * // 4. View rectangle with a top-down view\n * viewer.camera.setView({\n *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)\n * });\n *\n * // 5. Set position with an orientation using unit vectors.\n * viewer.camera.setView({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),\n *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)\n *     }\n * });\n */\nCamera.prototype.setView = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var orientation = defaultValue(\n    options.orientation,\n    defaultValue.EMPTY_OBJECT\n  );\n\n  var mode = this._mode;\n  if (mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  if (defined(options.endTransform)) {\n    this._setTransform(options.endTransform);\n  }\n\n  var convert = defaultValue(options.convert, true);\n  var destination = defaultValue(\n    options.destination,\n    Cartesian3.clone(this.positionWC, scratchSetViewCartesian)\n  );\n  if (defined(destination) && defined(destination.west)) {\n    destination = this.getRectangleCameraCoordinates(\n      destination,\n      scratchSetViewCartesian\n    );\n    convert = false;\n  }\n\n  if (defined(orientation.direction)) {\n    orientation = directionUpToHeadingPitchRoll(\n      this,\n      destination,\n      orientation,\n      scratchSetViewOptions.orientation\n    );\n  }\n\n  scratchHpr.heading = defaultValue(orientation.heading, 0.0);\n  scratchHpr.pitch = defaultValue(orientation.pitch, -CesiumMath.PI_OVER_TWO);\n  scratchHpr.roll = defaultValue(orientation.roll, 0.0);\n\n  if (mode === SceneMode.SCENE3D) {\n    setView3D(this, destination, scratchHpr);\n  } else if (mode === SceneMode.SCENE2D) {\n    setView2D(this, destination, scratchHpr, convert);\n  } else {\n    setViewCV(this, destination, scratchHpr, convert);\n  }\n};\n\nvar pitchScratch = new Cartesian3();\n/**\n * Fly the camera to the home view.  Use {@link Camera#.DEFAULT_VIEW_RECTANGLE} to set\n * the default view for the 3D scene.  The home view for 2D and columbus view shows the\n * entire map.\n *\n * @param {Number} [duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight. See {@link Camera#flyTo}\n */\nCamera.prototype.flyHome = function (duration) {\n  var mode = this._mode;\n\n  if (mode === SceneMode.MORPHING) {\n    this._scene.completeMorph();\n  }\n\n  if (mode === SceneMode.SCENE2D) {\n    this.flyTo({\n      destination: Camera.DEFAULT_VIEW_RECTANGLE,\n      duration: duration,\n      endTransform: Matrix4.IDENTITY,\n    });\n  } else if (mode === SceneMode.SCENE3D) {\n    var destination = this.getRectangleCameraCoordinates(\n      Camera.DEFAULT_VIEW_RECTANGLE\n    );\n\n    var mag = Cartesian3.magnitude(destination);\n    mag += mag * Camera.DEFAULT_VIEW_FACTOR;\n    Cartesian3.normalize(destination, destination);\n    Cartesian3.multiplyByScalar(destination, mag, destination);\n\n    this.flyTo({\n      destination: destination,\n      duration: duration,\n      endTransform: Matrix4.IDENTITY,\n    });\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    var maxRadii = this._projection.ellipsoid.maximumRadius;\n    var position = new Cartesian3(0.0, -1.0, 1.0);\n    position = Cartesian3.multiplyByScalar(\n      Cartesian3.normalize(position, position),\n      5.0 * maxRadii,\n      position\n    );\n    this.flyTo({\n      destination: position,\n      duration: duration,\n      orientation: {\n        heading: 0.0,\n        pitch: -Math.acos(Cartesian3.normalize(position, pitchScratch).z),\n        roll: 0.0,\n      },\n      endTransform: Matrix4.IDENTITY,\n      convert: false,\n    });\n  }\n};\n\n/**\n * Transform a vector or point from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian4} cartesian The vector or point to transform.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The transformed vector or point.\n */\nCamera.prototype.worldToCameraCoordinates = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByVector(this._actualInvTransform, cartesian, result);\n};\n\n/**\n * Transform a point from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian3} cartesian The point to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed point.\n */\nCamera.prototype.worldToCameraCoordinatesPoint = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByPoint(this._actualInvTransform, cartesian, result);\n};\n\n/**\n * Transform a vector from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian3} cartesian The vector to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed vector.\n */\nCamera.prototype.worldToCameraCoordinatesVector = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByPointAsVector(\n    this._actualInvTransform,\n    cartesian,\n    result\n  );\n};\n\n/**\n * Transform a vector or point from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian4} cartesian The vector or point to transform.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The transformed vector or point.\n */\nCamera.prototype.cameraToWorldCoordinates = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByVector(this._actualTransform, cartesian, result);\n};\n\n/**\n * Transform a point from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian3} cartesian The point to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed point.\n */\nCamera.prototype.cameraToWorldCoordinatesPoint = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByPoint(this._actualTransform, cartesian, result);\n};\n\n/**\n * Transform a vector from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian3} cartesian The vector to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed vector.\n */\nCamera.prototype.cameraToWorldCoordinatesVector = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByPointAsVector(\n    this._actualTransform,\n    cartesian,\n    result\n  );\n};\n\nfunction clampMove2D(camera, position) {\n  var rotatable2D = camera._scene.mapMode2D === MapMode2D.ROTATE;\n  var maxProjectedX = camera._maxCoord.x;\n  var maxProjectedY = camera._maxCoord.y;\n\n  var minX;\n  var maxX;\n  if (rotatable2D) {\n    maxX = maxProjectedX;\n    minX = -maxX;\n  } else {\n    maxX = position.x - maxProjectedX * 2.0;\n    minX = position.x + maxProjectedX * 2.0;\n  }\n\n  if (position.x > maxProjectedX) {\n    position.x = maxX;\n  }\n  if (position.x < -maxProjectedX) {\n    position.x = minX;\n  }\n\n  if (position.y > maxProjectedY) {\n    position.y = maxProjectedY;\n  }\n  if (position.y < -maxProjectedY) {\n    position.y = -maxProjectedY;\n  }\n}\n\nvar moveScratch = new Cartesian3();\n/**\n * Translates the camera's position by <code>amount</code> along <code>direction</code>.\n *\n * @param {Cartesian3} direction The direction to move.\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveBackward\n * @see Camera#moveForward\n * @see Camera#moveLeft\n * @see Camera#moveRight\n * @see Camera#moveUp\n * @see Camera#moveDown\n */\nCamera.prototype.move = function (direction, amount) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var cameraPosition = this.position;\n  Cartesian3.multiplyByScalar(direction, amount, moveScratch);\n  Cartesian3.add(cameraPosition, moveScratch, cameraPosition);\n\n  if (this._mode === SceneMode.SCENE2D) {\n    clampMove2D(this, cameraPosition);\n  }\n  this._adjustOrthographicFrustum(true);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the camera's view vector.\n * When in 2D mode, this will zoom in the camera instead of translating the camera's position.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveBackward\n */\nCamera.prototype.moveForward = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n\n  if (this._mode === SceneMode.SCENE2D) {\n    // 2D mode\n    zoom2D(this, amount);\n  } else {\n    // 3D or Columbus view mode\n    this.move(this.direction, amount);\n  }\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's view vector.\n * When in 2D mode, this will zoom out the camera instead of translating the camera's position.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveForward\n */\nCamera.prototype.moveBackward = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n\n  if (this._mode === SceneMode.SCENE2D) {\n    // 2D mode\n    zoom2D(this, -amount);\n  } else {\n    // 3D or Columbus view mode\n    this.move(this.direction, -amount);\n  }\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the camera's up vector.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveDown\n */\nCamera.prototype.moveUp = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.up, amount);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's up vector.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveUp\n */\nCamera.prototype.moveDown = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.up, -amount);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the camera's right vector.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveLeft\n */\nCamera.prototype.moveRight = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.right, amount);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's right vector.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveRight\n */\nCamera.prototype.moveLeft = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.right, -amount);\n};\n\n/**\n * Rotates the camera around its up vector by amount, in radians, in the opposite direction\n * of its right vector if not in 2D mode.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookRight\n */\nCamera.prototype.lookLeft = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.up, -amount);\n  }\n};\n\n/**\n * Rotates the camera around its up vector by amount, in radians, in the direction\n * of its right vector if not in 2D mode.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookLeft\n */\nCamera.prototype.lookRight = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.up, amount);\n  }\n};\n\n/**\n * Rotates the camera around its right vector by amount, in radians, in the direction\n * of its up vector if not in 2D mode.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookDown\n */\nCamera.prototype.lookUp = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.right, -amount);\n  }\n};\n\n/**\n * Rotates the camera around its right vector by amount, in radians, in the opposite direction\n * of its up vector if not in 2D mode.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookUp\n */\nCamera.prototype.lookDown = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.right, amount);\n  }\n};\n\nvar lookScratchQuaternion = new Quaternion();\nvar lookScratchMatrix = new Matrix3();\n/**\n * Rotate each of the camera's orientation vectors around <code>axis</code> by <code>angle</code>\n *\n * @param {Cartesian3} axis The axis to rotate around.\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookUp\n * @see Camera#lookDown\n * @see Camera#lookLeft\n * @see Camera#lookRight\n */\nCamera.prototype.look = function (axis, angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(axis)) {\n    throw new DeveloperError(\"axis is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var turnAngle = defaultValue(angle, this.defaultLookAmount);\n  var quaternion = Quaternion.fromAxisAngle(\n    axis,\n    -turnAngle,\n    lookScratchQuaternion\n  );\n  var rotation = Matrix3.fromQuaternion(quaternion, lookScratchMatrix);\n\n  var direction = this.direction;\n  var up = this.up;\n  var right = this.right;\n\n  Matrix3.multiplyByVector(rotation, direction, direction);\n  Matrix3.multiplyByVector(rotation, up, up);\n  Matrix3.multiplyByVector(rotation, right, right);\n};\n\n/**\n * Rotate the camera counter-clockwise around its direction vector by amount, in radians.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#twistRight\n */\nCamera.prototype.twistLeft = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n  this.look(this.direction, amount);\n};\n\n/**\n * Rotate the camera clockwise around its direction vector by amount, in radians.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#twistLeft\n */\nCamera.prototype.twistRight = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n  this.look(this.direction, -amount);\n};\n\nvar rotateScratchQuaternion = new Quaternion();\nvar rotateScratchMatrix = new Matrix3();\n/**\n * Rotates the camera around <code>axis</code> by <code>angle</code>. The distance\n * of the camera's position to the center of the camera's reference frame remains the same.\n *\n * @param {Cartesian3} axis The axis to rotate around given in world coordinates.\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateUp\n * @see Camera#rotateDown\n * @see Camera#rotateLeft\n * @see Camera#rotateRight\n */\nCamera.prototype.rotate = function (axis, angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(axis)) {\n    throw new DeveloperError(\"axis is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var turnAngle = defaultValue(angle, this.defaultRotateAmount);\n  var quaternion = Quaternion.fromAxisAngle(\n    axis,\n    -turnAngle,\n    rotateScratchQuaternion\n  );\n  var rotation = Matrix3.fromQuaternion(quaternion, rotateScratchMatrix);\n  Matrix3.multiplyByVector(rotation, this.position, this.position);\n  Matrix3.multiplyByVector(rotation, this.direction, this.direction);\n  Matrix3.multiplyByVector(rotation, this.up, this.up);\n  Cartesian3.cross(this.direction, this.up, this.right);\n  Cartesian3.cross(this.right, this.direction, this.up);\n\n  this._adjustOrthographicFrustum(false);\n};\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle downwards.\n *\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateUp\n * @see Camera#rotate\n */\nCamera.prototype.rotateDown = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateVertical(this, angle);\n};\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle upwards.\n *\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateDown\n * @see Camera#rotate\n */\nCamera.prototype.rotateUp = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateVertical(this, -angle);\n};\n\nvar rotateVertScratchP = new Cartesian3();\nvar rotateVertScratchA = new Cartesian3();\nvar rotateVertScratchTan = new Cartesian3();\nvar rotateVertScratchNegate = new Cartesian3();\nfunction rotateVertical(camera, angle) {\n  var position = camera.position;\n  if (\n    defined(camera.constrainedAxis) &&\n    !Cartesian3.equalsEpsilon(\n      camera.position,\n      Cartesian3.ZERO,\n      CesiumMath.EPSILON2\n    )\n  ) {\n    var p = Cartesian3.normalize(position, rotateVertScratchP);\n    var northParallel = Cartesian3.equalsEpsilon(\n      p,\n      camera.constrainedAxis,\n      CesiumMath.EPSILON2\n    );\n    var southParallel = Cartesian3.equalsEpsilon(\n      p,\n      Cartesian3.negate(camera.constrainedAxis, rotateVertScratchNegate),\n      CesiumMath.EPSILON2\n    );\n    if (!northParallel && !southParallel) {\n      var constrainedAxis = Cartesian3.normalize(\n        camera.constrainedAxis,\n        rotateVertScratchA\n      );\n\n      var dot = Cartesian3.dot(p, constrainedAxis);\n      var angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle > 0 && angle > angleToAxis) {\n        angle = angleToAxis - CesiumMath.EPSILON4;\n      }\n\n      dot = Cartesian3.dot(\n        p,\n        Cartesian3.negate(constrainedAxis, rotateVertScratchNegate)\n      );\n      angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle < 0 && -angle > angleToAxis) {\n        angle = -angleToAxis + CesiumMath.EPSILON4;\n      }\n\n      var tangent = Cartesian3.cross(constrainedAxis, p, rotateVertScratchTan);\n      camera.rotate(tangent, angle);\n    } else if ((northParallel && angle < 0) || (southParallel && angle > 0)) {\n      camera.rotate(camera.right, angle);\n    }\n  } else {\n    camera.rotate(camera.right, angle);\n  }\n}\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle to the right.\n *\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateLeft\n * @see Camera#rotate\n */\nCamera.prototype.rotateRight = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateHorizontal(this, -angle);\n};\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle to the left.\n *\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateRight\n * @see Camera#rotate\n */\nCamera.prototype.rotateLeft = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateHorizontal(this, angle);\n};\n\nfunction rotateHorizontal(camera, angle) {\n  if (defined(camera.constrainedAxis)) {\n    camera.rotate(camera.constrainedAxis, angle);\n  } else {\n    camera.rotate(camera.up, angle);\n  }\n}\n\nfunction zoom2D(camera, amount) {\n  var frustum = camera.frustum;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !(frustum instanceof OrthographicOffCenterFrustum) ||\n    !defined(frustum.left) ||\n    !defined(frustum.right) ||\n    !defined(frustum.bottom) ||\n    !defined(frustum.top)\n  ) {\n    throw new DeveloperError(\n      \"The camera frustum is expected to be orthographic for 2D camera control.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var ratio;\n  amount = amount * 0.5;\n\n  if (\n    Math.abs(frustum.top) + Math.abs(frustum.bottom) >\n    Math.abs(frustum.left) + Math.abs(frustum.right)\n  ) {\n    var newTop = frustum.top - amount;\n    var newBottom = frustum.bottom + amount;\n\n    var maxBottom = camera._maxCoord.y;\n    if (camera._scene.mapMode2D === MapMode2D.ROTATE) {\n      maxBottom *= camera.maximumZoomFactor;\n    }\n\n    if (newBottom > maxBottom) {\n      newBottom = maxBottom;\n      newTop = -maxBottom;\n    }\n\n    if (newTop <= newBottom) {\n      newTop = 1.0;\n      newBottom = -1.0;\n    }\n\n    ratio = frustum.right / frustum.top;\n    frustum.top = newTop;\n    frustum.bottom = newBottom;\n    frustum.right = frustum.top * ratio;\n    frustum.left = -frustum.right;\n  } else {\n    var newRight = frustum.right - amount;\n    var newLeft = frustum.left + amount;\n\n    var maxRight = camera._maxCoord.x;\n    if (camera._scene.mapMode2D === MapMode2D.ROTATE) {\n      maxRight *= camera.maximumZoomFactor;\n    }\n\n    if (newRight > maxRight) {\n      newRight = maxRight;\n      newLeft = -maxRight;\n    }\n\n    if (newRight <= newLeft) {\n      newRight = 1.0;\n      newLeft = -1.0;\n    }\n    ratio = frustum.top / frustum.right;\n    frustum.right = newRight;\n    frustum.left = newLeft;\n    frustum.top = frustum.right * ratio;\n    frustum.bottom = -frustum.top;\n  }\n}\n\nfunction zoom3D(camera, amount) {\n  camera.move(camera.direction, amount);\n}\n\n/**\n * Zooms <code>amount</code> along the camera's view vector.\n *\n * @param {Number} [amount] The amount to move. Defaults to <code>defaultZoomAmount</code>.\n *\n * @see Camera#zoomOut\n */\nCamera.prototype.zoomIn = function (amount) {\n  amount = defaultValue(amount, this.defaultZoomAmount);\n  if (this._mode === SceneMode.SCENE2D) {\n    zoom2D(this, amount);\n  } else {\n    zoom3D(this, amount);\n  }\n};\n\n/**\n * Zooms <code>amount</code> along the opposite direction of\n * the camera's view vector.\n *\n * @param {Number} [amount] The amount to move. Defaults to <code>defaultZoomAmount</code>.\n *\n * @see Camera#zoomIn\n */\nCamera.prototype.zoomOut = function (amount) {\n  amount = defaultValue(amount, this.defaultZoomAmount);\n  if (this._mode === SceneMode.SCENE2D) {\n    zoom2D(this, -amount);\n  } else {\n    zoom3D(this, -amount);\n  }\n};\n\n/**\n * Gets the magnitude of the camera position. In 3D, this is the vector magnitude. In 2D and\n * Columbus view, this is the distance to the map.\n *\n * @returns {Number} The magnitude of the position.\n */\nCamera.prototype.getMagnitude = function () {\n  if (this._mode === SceneMode.SCENE3D) {\n    return Cartesian3.magnitude(this.position);\n  } else if (this._mode === SceneMode.COLUMBUS_VIEW) {\n    return Math.abs(this.position.z);\n  } else if (this._mode === SceneMode.SCENE2D) {\n    return Math.max(\n      this.frustum.right - this.frustum.left,\n      this.frustum.top - this.frustum.bottom\n    );\n  }\n};\n\nvar scratchLookAtMatrix4 = new Matrix4();\n\n/**\n * Sets the camera position and orientation using a target and offset. The target must be given in\n * world coordinates. The offset can be either a cartesian or heading/pitch/range in the local east-north-up reference frame centered at the target.\n * If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset\n * is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.\n *\n * In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.\n *\n * @param {Cartesian3} target The target position in world coordinates.\n * @param {Cartesian3|HeadingPitchRange} offset The offset from the target in the local east-north-up reference frame centered at the target.\n *\n * @exception {DeveloperError} lookAt is not supported while morphing.\n *\n * @example\n * // 1. Using a cartesian offset\n * var center = Cesium.Cartesian3.fromDegrees(-98.0, 40.0);\n * viewer.camera.lookAt(center, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));\n *\n * // 2. Using a HeadingPitchRange offset\n * var center = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);\n * var heading = Cesium.Math.toRadians(50.0);\n * var pitch = Cesium.Math.toRadians(-20.0);\n * var range = 5000.0;\n * viewer.camera.lookAt(center, new Cesium.HeadingPitchRange(heading, pitch, range));\n */\nCamera.prototype.lookAt = function (target, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(target)) {\n    throw new DeveloperError(\"target is required\");\n  }\n  if (!defined(offset)) {\n    throw new DeveloperError(\"offset is required\");\n  }\n  if (this._mode === SceneMode.MORPHING) {\n    throw new DeveloperError(\"lookAt is not supported while morphing.\");\n  }\n  //>>includeEnd('debug');\n\n  var transform = Transforms.eastNorthUpToFixedFrame(\n    target,\n    Ellipsoid.WGS84,\n    scratchLookAtMatrix4\n  );\n  this.lookAtTransform(transform, offset);\n};\n\nvar scratchLookAtHeadingPitchRangeOffset = new Cartesian3();\nvar scratchLookAtHeadingPitchRangeQuaternion1 = new Quaternion();\nvar scratchLookAtHeadingPitchRangeQuaternion2 = new Quaternion();\nvar scratchHeadingPitchRangeMatrix3 = new Matrix3();\n\nfunction offsetFromHeadingPitchRange(heading, pitch, range) {\n  pitch = CesiumMath.clamp(\n    pitch,\n    -CesiumMath.PI_OVER_TWO,\n    CesiumMath.PI_OVER_TWO\n  );\n  heading = CesiumMath.zeroToTwoPi(heading) - CesiumMath.PI_OVER_TWO;\n\n  var pitchQuat = Quaternion.fromAxisAngle(\n    Cartesian3.UNIT_Y,\n    -pitch,\n    scratchLookAtHeadingPitchRangeQuaternion1\n  );\n  var headingQuat = Quaternion.fromAxisAngle(\n    Cartesian3.UNIT_Z,\n    -heading,\n    scratchLookAtHeadingPitchRangeQuaternion2\n  );\n  var rotQuat = Quaternion.multiply(headingQuat, pitchQuat, headingQuat);\n  var rotMatrix = Matrix3.fromQuaternion(\n    rotQuat,\n    scratchHeadingPitchRangeMatrix3\n  );\n\n  var offset = Cartesian3.clone(\n    Cartesian3.UNIT_X,\n    scratchLookAtHeadingPitchRangeOffset\n  );\n  Matrix3.multiplyByVector(rotMatrix, offset, offset);\n  Cartesian3.negate(offset, offset);\n  Cartesian3.multiplyByScalar(offset, range, offset);\n  return offset;\n}\n\n/**\n * Sets the camera position and orientation using a target and transformation matrix. The offset can be either a cartesian or heading/pitch/range.\n * If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset\n * is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.\n *\n * In 2D, there must be a top down view. The camera will be placed above the center of the reference frame. The height above the\n * target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.\n *\n * @param {Matrix4} transform The transformation matrix defining the reference frame.\n * @param {Cartesian3|HeadingPitchRange} [offset] The offset from the target in a reference frame centered at the target.\n *\n * @exception {DeveloperError} lookAtTransform is not supported while morphing.\n *\n * @example\n * // 1. Using a cartesian offset\n * var transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-98.0, 40.0));\n * viewer.camera.lookAtTransform(transform, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));\n *\n * // 2. Using a HeadingPitchRange offset\n * var transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-72.0, 40.0));\n * var heading = Cesium.Math.toRadians(50.0);\n * var pitch = Cesium.Math.toRadians(-20.0);\n * var range = 5000.0;\n * viewer.camera.lookAtTransform(transform, new Cesium.HeadingPitchRange(heading, pitch, range));\n */\nCamera.prototype.lookAtTransform = function (transform, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(transform)) {\n    throw new DeveloperError(\"transform is required\");\n  }\n  if (this._mode === SceneMode.MORPHING) {\n    throw new DeveloperError(\n      \"lookAtTransform is not supported while morphing.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._setTransform(transform);\n  if (!defined(offset)) {\n    return;\n  }\n\n  var cartesianOffset;\n  if (defined(offset.heading)) {\n    cartesianOffset = offsetFromHeadingPitchRange(\n      offset.heading,\n      offset.pitch,\n      offset.range\n    );\n  } else {\n    cartesianOffset = offset;\n  }\n\n  if (this._mode === SceneMode.SCENE2D) {\n    Cartesian2.clone(Cartesian2.ZERO, this.position);\n\n    Cartesian3.negate(cartesianOffset, this.up);\n    this.up.z = 0.0;\n\n    if (Cartesian3.magnitudeSquared(this.up) < CesiumMath.EPSILON10) {\n      Cartesian3.clone(Cartesian3.UNIT_Y, this.up);\n    }\n\n    Cartesian3.normalize(this.up, this.up);\n\n    this._setTransform(Matrix4.IDENTITY);\n\n    Cartesian3.negate(Cartesian3.UNIT_Z, this.direction);\n    Cartesian3.cross(this.direction, this.up, this.right);\n    Cartesian3.normalize(this.right, this.right);\n\n    var frustum = this.frustum;\n    var ratio = frustum.top / frustum.right;\n    frustum.right = Cartesian3.magnitude(cartesianOffset) * 0.5;\n    frustum.left = -frustum.right;\n    frustum.top = ratio * frustum.right;\n    frustum.bottom = -frustum.top;\n\n    this._setTransform(transform);\n\n    return;\n  }\n\n  Cartesian3.clone(cartesianOffset, this.position);\n  Cartesian3.negate(this.position, this.direction);\n  Cartesian3.normalize(this.direction, this.direction);\n  Cartesian3.cross(this.direction, Cartesian3.UNIT_Z, this.right);\n\n  if (Cartesian3.magnitudeSquared(this.right) < CesiumMath.EPSILON10) {\n    Cartesian3.clone(Cartesian3.UNIT_X, this.right);\n  }\n\n  Cartesian3.normalize(this.right, this.right);\n  Cartesian3.cross(this.right, this.direction, this.up);\n  Cartesian3.normalize(this.up, this.up);\n\n  this._adjustOrthographicFrustum(true);\n};\n\nvar viewRectangle3DCartographic1 = new Cartographic();\nvar viewRectangle3DCartographic2 = new Cartographic();\nvar viewRectangle3DNorthEast = new Cartesian3();\nvar viewRectangle3DSouthWest = new Cartesian3();\nvar viewRectangle3DNorthWest = new Cartesian3();\nvar viewRectangle3DSouthEast = new Cartesian3();\nvar viewRectangle3DNorthCenter = new Cartesian3();\nvar viewRectangle3DSouthCenter = new Cartesian3();\nvar viewRectangle3DCenter = new Cartesian3();\nvar viewRectangle3DEquator = new Cartesian3();\nvar defaultRF = {\n  direction: new Cartesian3(),\n  right: new Cartesian3(),\n  up: new Cartesian3(),\n};\nvar viewRectangle3DEllipsoidGeodesic;\n\nfunction computeD(direction, upOrRight, corner, tanThetaOrPhi) {\n  var opposite = Math.abs(Cartesian3.dot(upOrRight, corner));\n  return opposite / tanThetaOrPhi - Cartesian3.dot(direction, corner);\n}\n\nfunction rectangleCameraPosition3D(camera, rectangle, result, updateCamera) {\n  var ellipsoid = camera._projection.ellipsoid;\n  var cameraRF = updateCamera ? camera : defaultRF;\n\n  var north = rectangle.north;\n  var south = rectangle.south;\n  var east = rectangle.east;\n  var west = rectangle.west;\n\n  // If we go across the International Date Line\n  if (west > east) {\n    east += CesiumMath.TWO_PI;\n  }\n\n  // Find the midpoint latitude.\n  //\n  // EllipsoidGeodesic will fail if the north and south edges are very close to being on opposite sides of the ellipsoid.\n  // Ideally we'd just call EllipsoidGeodesic.setEndPoints and let it throw when it detects this case, but sadly it doesn't\n  // even look for this case in optimized builds, so we have to test for it here instead.\n  //\n  // Fortunately, this case can only happen (here) when north is very close to the north pole and south is very close to the south pole,\n  // so handle it just by using 0 latitude as the center.  It's certainliy possible to use a smaller tolerance\n  // than one degree here, but one degree is safe and putting the center at 0 latitude should be good enough for any\n  // rectangle that spans 178+ of the 180 degrees of latitude.\n  var longitude = (west + east) * 0.5;\n  var latitude;\n  if (\n    south < -CesiumMath.PI_OVER_TWO + CesiumMath.RADIANS_PER_DEGREE &&\n    north > CesiumMath.PI_OVER_TWO - CesiumMath.RADIANS_PER_DEGREE\n  ) {\n    latitude = 0.0;\n  } else {\n    var northCartographic = viewRectangle3DCartographic1;\n    northCartographic.longitude = longitude;\n    northCartographic.latitude = north;\n    northCartographic.height = 0.0;\n\n    var southCartographic = viewRectangle3DCartographic2;\n    southCartographic.longitude = longitude;\n    southCartographic.latitude = south;\n    southCartographic.height = 0.0;\n\n    var ellipsoidGeodesic = viewRectangle3DEllipsoidGeodesic;\n    if (\n      !defined(ellipsoidGeodesic) ||\n      ellipsoidGeodesic.ellipsoid !== ellipsoid\n    ) {\n      viewRectangle3DEllipsoidGeodesic = ellipsoidGeodesic = new EllipsoidGeodesic(\n        undefined,\n        undefined,\n        ellipsoid\n      );\n    }\n\n    ellipsoidGeodesic.setEndPoints(northCartographic, southCartographic);\n    latitude = ellipsoidGeodesic.interpolateUsingFraction(\n      0.5,\n      viewRectangle3DCartographic1\n    ).latitude;\n  }\n\n  var centerCartographic = viewRectangle3DCartographic1;\n  centerCartographic.longitude = longitude;\n  centerCartographic.latitude = latitude;\n  centerCartographic.height = 0.0;\n\n  var center = ellipsoid.cartographicToCartesian(\n    centerCartographic,\n    viewRectangle3DCenter\n  );\n\n  var cart = viewRectangle3DCartographic1;\n  cart.longitude = east;\n  cart.latitude = north;\n  var northEast = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DNorthEast\n  );\n  cart.longitude = west;\n  var northWest = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DNorthWest\n  );\n  cart.longitude = longitude;\n  var northCenter = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DNorthCenter\n  );\n  cart.latitude = south;\n  var southCenter = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DSouthCenter\n  );\n  cart.longitude = east;\n  var southEast = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DSouthEast\n  );\n  cart.longitude = west;\n  var southWest = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DSouthWest\n  );\n\n  Cartesian3.subtract(northWest, center, northWest);\n  Cartesian3.subtract(southEast, center, southEast);\n  Cartesian3.subtract(northEast, center, northEast);\n  Cartesian3.subtract(southWest, center, southWest);\n  Cartesian3.subtract(northCenter, center, northCenter);\n  Cartesian3.subtract(southCenter, center, southCenter);\n\n  var direction = ellipsoid.geodeticSurfaceNormal(center, cameraRF.direction);\n  Cartesian3.negate(direction, direction);\n  var right = Cartesian3.cross(direction, Cartesian3.UNIT_Z, cameraRF.right);\n  Cartesian3.normalize(right, right);\n  var up = Cartesian3.cross(right, direction, cameraRF.up);\n\n  var d;\n  if (camera.frustum instanceof OrthographicFrustum) {\n    var width = Math.max(\n      Cartesian3.distance(northEast, northWest),\n      Cartesian3.distance(southEast, southWest)\n    );\n    var height = Math.max(\n      Cartesian3.distance(northEast, southEast),\n      Cartesian3.distance(northWest, southWest)\n    );\n\n    var rightScalar;\n    var topScalar;\n    var ratio =\n      camera.frustum._offCenterFrustum.right /\n      camera.frustum._offCenterFrustum.top;\n    var heightRatio = height * ratio;\n    if (width > heightRatio) {\n      rightScalar = width;\n      topScalar = rightScalar / ratio;\n    } else {\n      topScalar = height;\n      rightScalar = heightRatio;\n    }\n\n    d = Math.max(rightScalar, topScalar);\n  } else {\n    var tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n    var tanTheta = camera.frustum.aspectRatio * tanPhi;\n\n    d = Math.max(\n      computeD(direction, up, northWest, tanPhi),\n      computeD(direction, up, southEast, tanPhi),\n      computeD(direction, up, northEast, tanPhi),\n      computeD(direction, up, southWest, tanPhi),\n      computeD(direction, up, northCenter, tanPhi),\n      computeD(direction, up, southCenter, tanPhi),\n      computeD(direction, right, northWest, tanTheta),\n      computeD(direction, right, southEast, tanTheta),\n      computeD(direction, right, northEast, tanTheta),\n      computeD(direction, right, southWest, tanTheta),\n      computeD(direction, right, northCenter, tanTheta),\n      computeD(direction, right, southCenter, tanTheta)\n    );\n\n    // If the rectangle crosses the equator, compute D at the equator, too, because that's the\n    // widest part of the rectangle when projected onto the globe.\n    if (south < 0 && north > 0) {\n      var equatorCartographic = viewRectangle3DCartographic1;\n      equatorCartographic.longitude = west;\n      equatorCartographic.latitude = 0.0;\n      equatorCartographic.height = 0.0;\n      var equatorPosition = ellipsoid.cartographicToCartesian(\n        equatorCartographic,\n        viewRectangle3DEquator\n      );\n      Cartesian3.subtract(equatorPosition, center, equatorPosition);\n      d = Math.max(\n        d,\n        computeD(direction, up, equatorPosition, tanPhi),\n        computeD(direction, right, equatorPosition, tanTheta)\n      );\n\n      equatorCartographic.longitude = east;\n      equatorPosition = ellipsoid.cartographicToCartesian(\n        equatorCartographic,\n        viewRectangle3DEquator\n      );\n      Cartesian3.subtract(equatorPosition, center, equatorPosition);\n      d = Math.max(\n        d,\n        computeD(direction, up, equatorPosition, tanPhi),\n        computeD(direction, right, equatorPosition, tanTheta)\n      );\n    }\n  }\n\n  return Cartesian3.add(\n    center,\n    Cartesian3.multiplyByScalar(direction, -d, viewRectangle3DEquator),\n    result\n  );\n}\n\nvar viewRectangleCVCartographic = new Cartographic();\nvar viewRectangleCVNorthEast = new Cartesian3();\nvar viewRectangleCVSouthWest = new Cartesian3();\nfunction rectangleCameraPositionColumbusView(camera, rectangle, result) {\n  var projection = camera._projection;\n  if (rectangle.west > rectangle.east) {\n    rectangle = Rectangle.MAX_VALUE;\n  }\n  var transform = camera._actualTransform;\n  var invTransform = camera._actualInvTransform;\n\n  var cart = viewRectangleCVCartographic;\n  cart.longitude = rectangle.east;\n  cart.latitude = rectangle.north;\n  var northEast = projection.project(cart, viewRectangleCVNorthEast);\n  Matrix4.multiplyByPoint(transform, northEast, northEast);\n  Matrix4.multiplyByPoint(invTransform, northEast, northEast);\n\n  cart.longitude = rectangle.west;\n  cart.latitude = rectangle.south;\n  var southWest = projection.project(cart, viewRectangleCVSouthWest);\n  Matrix4.multiplyByPoint(transform, southWest, southWest);\n  Matrix4.multiplyByPoint(invTransform, southWest, southWest);\n\n  result.x = (northEast.x - southWest.x) * 0.5 + southWest.x;\n  result.y = (northEast.y - southWest.y) * 0.5 + southWest.y;\n\n  if (defined(camera.frustum.fovy)) {\n    var tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n    var tanTheta = camera.frustum.aspectRatio * tanPhi;\n    result.z =\n      Math.max(\n        (northEast.x - southWest.x) / tanTheta,\n        (northEast.y - southWest.y) / tanPhi\n      ) * 0.5;\n  } else {\n    var width = northEast.x - southWest.x;\n    var height = northEast.y - southWest.y;\n    result.z = Math.max(width, height);\n  }\n\n  return result;\n}\n\nvar viewRectangle2DCartographic = new Cartographic();\nvar viewRectangle2DNorthEast = new Cartesian3();\nvar viewRectangle2DSouthWest = new Cartesian3();\nfunction rectangleCameraPosition2D(camera, rectangle, result) {\n  var projection = camera._projection;\n\n  // Account for the rectangle crossing the International Date Line in 2D mode\n  var east = rectangle.east;\n  if (rectangle.west > rectangle.east) {\n    if (camera._scene.mapMode2D === MapMode2D.INFINITE_SCROLL) {\n      east += CesiumMath.TWO_PI;\n    } else {\n      rectangle = Rectangle.MAX_VALUE;\n      east = rectangle.east;\n    }\n  }\n\n  var cart = viewRectangle2DCartographic;\n  cart.longitude = east;\n  cart.latitude = rectangle.north;\n  var northEast = projection.project(cart, viewRectangle2DNorthEast);\n  cart.longitude = rectangle.west;\n  cart.latitude = rectangle.south;\n  var southWest = projection.project(cart, viewRectangle2DSouthWest);\n\n  var width = Math.abs(northEast.x - southWest.x) * 0.5;\n  var height = Math.abs(northEast.y - southWest.y) * 0.5;\n\n  var right, top;\n  var ratio = camera.frustum.right / camera.frustum.top;\n  var heightRatio = height * ratio;\n  if (width > heightRatio) {\n    right = width;\n    top = right / ratio;\n  } else {\n    top = height;\n    right = heightRatio;\n  }\n\n  height = Math.max(2.0 * right, 2.0 * top);\n\n  result.x = (northEast.x - southWest.x) * 0.5 + southWest.x;\n  result.y = (northEast.y - southWest.y) * 0.5 + southWest.y;\n\n  cart = projection.unproject(result, cart);\n  cart.height = height;\n  result = projection.project(cart, result);\n\n  return result;\n}\n\n/**\n * Get the camera position needed to view a rectangle on an ellipsoid or map\n *\n * @param {Rectangle} rectangle The rectangle to view.\n * @param {Cartesian3} [result] The camera position needed to view the rectangle\n * @returns {Cartesian3} The camera position needed to view the rectangle\n */\nCamera.prototype.getRectangleCameraCoordinates = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required\");\n  }\n  //>>includeEnd('debug');\n  var mode = this._mode;\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  if (mode === SceneMode.SCENE3D) {\n    return rectangleCameraPosition3D(this, rectangle, result);\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    return rectangleCameraPositionColumbusView(this, rectangle, result);\n  } else if (mode === SceneMode.SCENE2D) {\n    return rectangleCameraPosition2D(this, rectangle, result);\n  }\n\n  return undefined;\n};\n\nvar pickEllipsoid3DRay = new Ray();\nfunction pickEllipsoid3D(camera, windowPosition, ellipsoid, result) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  var ray = camera.getPickRay(windowPosition, pickEllipsoid3DRay);\n  var intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n  if (!intersection) {\n    return undefined;\n  }\n\n  var t = intersection.start > 0.0 ? intersection.start : intersection.stop;\n  return Ray.getPoint(ray, t, result);\n}\n\nvar pickEllipsoid2DRay = new Ray();\nfunction pickMap2D(camera, windowPosition, projection, result) {\n  var ray = camera.getPickRay(windowPosition, pickEllipsoid2DRay);\n  var position = ray.origin;\n  position = Cartesian3.fromElements(position.y, position.z, 0.0, position);\n  var cart = projection.unproject(position);\n\n  if (\n    cart.latitude < -CesiumMath.PI_OVER_TWO ||\n    cart.latitude > CesiumMath.PI_OVER_TWO\n  ) {\n    return undefined;\n  }\n\n  return projection.ellipsoid.cartographicToCartesian(cart, result);\n}\n\nvar pickEllipsoidCVRay = new Ray();\nfunction pickMapColumbusView(camera, windowPosition, projection, result) {\n  var ray = camera.getPickRay(windowPosition, pickEllipsoidCVRay);\n  var scalar = -ray.origin.x / ray.direction.x;\n  Ray.getPoint(ray, scalar, result);\n\n  var cart = projection.unproject(new Cartesian3(result.y, result.z, 0.0));\n\n  if (\n    cart.latitude < -CesiumMath.PI_OVER_TWO ||\n    cart.latitude > CesiumMath.PI_OVER_TWO ||\n    cart.longitude < -Math.PI ||\n    cart.longitude > Math.PI\n  ) {\n    return undefined;\n  }\n\n  return projection.ellipsoid.cartographicToCartesian(cart, result);\n}\n\n/**\n * Pick an ellipsoid or map.\n *\n * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to pick.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} If the ellipsoid or map was picked, returns the point on the surface of the ellipsoid or map\n * in world coordinates. If the ellipsoid or map was not picked, returns undefined.\n *\n * @example\n * var canvas = viewer.scene.canvas;\n * var center = new Cesium.Cartesian2(canvas.clientWidth / 2.0, canvas.clientHeight / 2.0);\n * var ellipsoid = viewer.scene.globe.ellipsoid;\n * var result = viewer.camera.pickEllipsoid(center, ellipsoid);\n */\nCamera.prototype.pickEllipsoid = function (windowPosition, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(windowPosition)) {\n    throw new DeveloperError(\"windowPosition is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var canvas = this._scene.canvas;\n  if (canvas.clientWidth === 0 || canvas.clientHeight === 0) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  if (this._mode === SceneMode.SCENE3D) {\n    result = pickEllipsoid3D(this, windowPosition, ellipsoid, result);\n  } else if (this._mode === SceneMode.SCENE2D) {\n    result = pickMap2D(this, windowPosition, this._projection, result);\n  } else if (this._mode === SceneMode.COLUMBUS_VIEW) {\n    result = pickMapColumbusView(\n      this,\n      windowPosition,\n      this._projection,\n      result\n    );\n  } else {\n    return undefined;\n  }\n\n  return result;\n};\n\nvar pickPerspCenter = new Cartesian3();\nvar pickPerspXDir = new Cartesian3();\nvar pickPerspYDir = new Cartesian3();\nfunction getPickRayPerspective(camera, windowPosition, result) {\n  var canvas = camera._scene.canvas;\n  var width = canvas.clientWidth;\n  var height = canvas.clientHeight;\n\n  var tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n  var tanTheta = camera.frustum.aspectRatio * tanPhi;\n  var near = camera.frustum.near;\n\n  var x = (2.0 / width) * windowPosition.x - 1.0;\n  var y = (2.0 / height) * (height - windowPosition.y) - 1.0;\n\n  var position = camera.positionWC;\n  Cartesian3.clone(position, result.origin);\n\n  var nearCenter = Cartesian3.multiplyByScalar(\n    camera.directionWC,\n    near,\n    pickPerspCenter\n  );\n  Cartesian3.add(position, nearCenter, nearCenter);\n  var xDir = Cartesian3.multiplyByScalar(\n    camera.rightWC,\n    x * near * tanTheta,\n    pickPerspXDir\n  );\n  var yDir = Cartesian3.multiplyByScalar(\n    camera.upWC,\n    y * near * tanPhi,\n    pickPerspYDir\n  );\n  var direction = Cartesian3.add(nearCenter, xDir, result.direction);\n  Cartesian3.add(direction, yDir, direction);\n  Cartesian3.subtract(direction, position, direction);\n  Cartesian3.normalize(direction, direction);\n\n  return result;\n}\n\nvar scratchDirection = new Cartesian3();\n\nfunction getPickRayOrthographic(camera, windowPosition, result) {\n  var canvas = camera._scene.canvas;\n  var width = canvas.clientWidth;\n  var height = canvas.clientHeight;\n\n  var frustum = camera.frustum;\n  if (defined(frustum._offCenterFrustum)) {\n    frustum = frustum._offCenterFrustum;\n  }\n  var x = (2.0 / width) * windowPosition.x - 1.0;\n  x *= (frustum.right - frustum.left) * 0.5;\n  var y = (2.0 / height) * (height - windowPosition.y) - 1.0;\n  y *= (frustum.top - frustum.bottom) * 0.5;\n\n  var origin = result.origin;\n  Cartesian3.clone(camera.position, origin);\n\n  Cartesian3.multiplyByScalar(camera.right, x, scratchDirection);\n  Cartesian3.add(scratchDirection, origin, origin);\n  Cartesian3.multiplyByScalar(camera.up, y, scratchDirection);\n  Cartesian3.add(scratchDirection, origin, origin);\n\n  Cartesian3.clone(camera.directionWC, result.direction);\n\n  if (\n    camera._mode === SceneMode.COLUMBUS_VIEW ||\n    camera._mode === SceneMode.SCENE2D\n  ) {\n    Cartesian3.fromElements(\n      result.origin.z,\n      result.origin.x,\n      result.origin.y,\n      result.origin\n    );\n  }\n\n  return result;\n}\n\n/**\n * Create a ray from the camera position through the pixel at <code>windowPosition</code>\n * in world coordinates.\n *\n * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.\n * @param {Ray} [result] The object onto which to store the result.\n * @returns {Ray} Returns the {@link Cartesian3} position and direction of the ray.\n */\nCamera.prototype.getPickRay = function (windowPosition, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(windowPosition)) {\n    throw new DeveloperError(\"windowPosition is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Ray();\n  }\n\n  var frustum = this.frustum;\n  if (\n    defined(frustum.aspectRatio) &&\n    defined(frustum.fov) &&\n    defined(frustum.near)\n  ) {\n    return getPickRayPerspective(this, windowPosition, result);\n  }\n\n  return getPickRayOrthographic(this, windowPosition, result);\n};\n\nvar scratchToCenter = new Cartesian3();\nvar scratchProj = new Cartesian3();\n\n/**\n * Return the distance from the camera to the front of the bounding sphere.\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere in world coordinates.\n * @returns {Number} The distance to the bounding sphere.\n */\nCamera.prototype.distanceToBoundingSphere = function (boundingSphere) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var toCenter = Cartesian3.subtract(\n    this.positionWC,\n    boundingSphere.center,\n    scratchToCenter\n  );\n  var proj = Cartesian3.multiplyByScalar(\n    this.directionWC,\n    Cartesian3.dot(toCenter, this.directionWC),\n    scratchProj\n  );\n  return Math.max(0.0, Cartesian3.magnitude(proj) - boundingSphere.radius);\n};\n\nvar scratchPixelSize = new Cartesian2();\n\n/**\n * Return the pixel size in meters.\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere in world coordinates.\n * @param {Number} drawingBufferWidth The drawing buffer width.\n * @param {Number} drawingBufferHeight The drawing buffer height.\n * @returns {Number} The pixel size in meters.\n */\nCamera.prototype.getPixelSize = function (\n  boundingSphere,\n  drawingBufferWidth,\n  drawingBufferHeight\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n  if (!defined(drawingBufferWidth)) {\n    throw new DeveloperError(\"drawingBufferWidth is required.\");\n  }\n  if (!defined(drawingBufferHeight)) {\n    throw new DeveloperError(\"drawingBufferHeight is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var distance = this.distanceToBoundingSphere(boundingSphere);\n  var pixelSize = this.frustum.getPixelDimensions(\n    drawingBufferWidth,\n    drawingBufferHeight,\n    distance,\n    this._scene.pixelRatio,\n    scratchPixelSize\n  );\n  return Math.max(pixelSize.x, pixelSize.y);\n};\n\nfunction createAnimationTemplateCV(\n  camera,\n  position,\n  center,\n  maxX,\n  maxY,\n  duration\n) {\n  var newPosition = Cartesian3.clone(position);\n\n  if (center.y > maxX) {\n    newPosition.y -= center.y - maxX;\n  } else if (center.y < -maxX) {\n    newPosition.y += -maxX - center.y;\n  }\n\n  if (center.z > maxY) {\n    newPosition.z -= center.z - maxY;\n  } else if (center.z < -maxY) {\n    newPosition.z += -maxY - center.z;\n  }\n\n  function updateCV(value) {\n    var interp = Cartesian3.lerp(\n      position,\n      newPosition,\n      value.time,\n      new Cartesian3()\n    );\n    camera.worldToCameraCoordinatesPoint(interp, camera.position);\n  }\n  return {\n    easingFunction: EasingFunction.EXPONENTIAL_OUT,\n    startObject: {\n      time: 0.0,\n    },\n    stopObject: {\n      time: 1.0,\n    },\n    duration: duration,\n    update: updateCV,\n  };\n}\n\nvar normalScratch = new Cartesian3();\nvar centerScratch = new Cartesian3();\nvar posScratch = new Cartesian3();\nvar scratchCartesian3Subtract = new Cartesian3();\n\nfunction createAnimationCV(camera, duration) {\n  var position = camera.position;\n  var direction = camera.direction;\n\n  var normal = camera.worldToCameraCoordinatesVector(\n    Cartesian3.UNIT_X,\n    normalScratch\n  );\n  var scalar =\n    -Cartesian3.dot(normal, position) / Cartesian3.dot(normal, direction);\n  var center = Cartesian3.add(\n    position,\n    Cartesian3.multiplyByScalar(direction, scalar, centerScratch),\n    centerScratch\n  );\n  camera.cameraToWorldCoordinatesPoint(center, center);\n\n  position = camera.cameraToWorldCoordinatesPoint(camera.position, posScratch);\n\n  var tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n  var tanTheta = camera.frustum.aspectRatio * tanPhi;\n  var distToC = Cartesian3.magnitude(\n    Cartesian3.subtract(position, center, scratchCartesian3Subtract)\n  );\n  var dWidth = tanTheta * distToC;\n  var dHeight = tanPhi * distToC;\n\n  var mapWidth = camera._maxCoord.x;\n  var mapHeight = camera._maxCoord.y;\n\n  var maxX = Math.max(dWidth - mapWidth, mapWidth);\n  var maxY = Math.max(dHeight - mapHeight, mapHeight);\n\n  if (\n    position.z < -maxX ||\n    position.z > maxX ||\n    position.y < -maxY ||\n    position.y > maxY\n  ) {\n    var translateX = center.y < -maxX || center.y > maxX;\n    var translateY = center.z < -maxY || center.z > maxY;\n    if (translateX || translateY) {\n      return createAnimationTemplateCV(\n        camera,\n        position,\n        center,\n        maxX,\n        maxY,\n        duration\n      );\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Create an animation to move the map into view. This method is only valid for 2D and Columbus modes.\n *\n * @param {Number} duration The duration, in seconds, of the animation.\n * @returns {Object} The animation or undefined if the scene mode is 3D or the map is already ion view.\n *\n * @private\n */\nCamera.prototype.createCorrectPositionTween = function (duration) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(duration)) {\n    throw new DeveloperError(\"duration is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (this._mode === SceneMode.COLUMBUS_VIEW) {\n    return createAnimationCV(this, duration);\n  }\n\n  return undefined;\n};\n\nvar scratchFlyToDestination = new Cartesian3();\nvar newOptions = {\n  destination: undefined,\n  heading: undefined,\n  pitch: undefined,\n  roll: undefined,\n  duration: undefined,\n  complete: undefined,\n  cancel: undefined,\n  endTransform: undefined,\n  maximumHeight: undefined,\n  easingFunction: undefined,\n};\n\n/**\n * Cancels the current camera flight if one is in progress.\n * The camera is left at it's current location.\n */\nCamera.prototype.cancelFlight = function () {\n  if (defined(this._currentFlight)) {\n    this._currentFlight.cancelTween();\n    this._currentFlight = undefined;\n  }\n};\n\n/**\n * Flies the camera from its current position to a new position.\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3|Rectangle} options.destination The final position of the camera in WGS84 (world) coordinates or a rectangle that would be visible from a top-down view.\n * @param {Object} [options.orientation] An object that contains either direction and up properties or heading, pitch and roll properties. By default, the direction will point\n * towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive\n * y direction in Columbus view.  Orientation is not used in 2D when in infinite scrolling mode.\n * @param {Number} [options.duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.\n * @param {Camera~FlightCompleteCallback} [options.complete] The function to execute when the flight is complete.\n * @param {Camera~FlightCancelledCallback} [options.cancel] The function to execute if the flight is cancelled.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame the camera will be in when the flight is completed.\n * @param {Number} [options.maximumHeight] The maximum height at the peak of the flight.\n * @param {Number} [options.pitchAdjustHeight] If camera flyes higher than that value, adjust pitch duiring the flight to look down, and keep Earth in viewport.\n * @param {Number} [options.flyOverLongitude] There are always two ways between 2 points on globe. This option force camera to choose fight direction to fly over that longitude.\n * @param {Number} [options.flyOverLongitudeWeight] Fly over the lon specifyed via flyOverLongitude only if that way is not longer than short way times flyOverLongitudeWeight.\n * @param {Boolean} [options.convert] Whether to convert the destination from world coordinates to scene coordinates (only relevant when not using 3D). Defaults to <code>true</code>.\n * @param {EasingFunction|EasingFunction~Callback} [options.easingFunction] Controls how the time is interpolated over the duration of the flight.\n *\n * @exception {DeveloperError} If either direction or up is given, then both are required.\n *\n * @example\n * // 1. Fly to a position with a top-down view\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)\n * });\n *\n * // 2. Fly to a Rectangle with a top-down view\n * viewer.camera.flyTo({\n *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)\n * });\n *\n * // 3. Fly to a position with an orientation using unit vectors.\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),\n *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)\n *     }\n * });\n *\n * // 4. Fly to a position with an orientation using heading, pitch and roll.\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         heading : Cesium.Math.toRadians(175.0),\n *         pitch : Cesium.Math.toRadians(-35.0),\n *         roll : 0.0\n *     }\n * });\n */\nCamera.prototype.flyTo = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var destination = options.destination;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(destination)) {\n    throw new DeveloperError(\"destination is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var mode = this._mode;\n  if (mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  this.cancelFlight();\n\n  var orientation = defaultValue(\n    options.orientation,\n    defaultValue.EMPTY_OBJECT\n  );\n  if (defined(orientation.direction)) {\n    orientation = directionUpToHeadingPitchRoll(\n      this,\n      destination,\n      orientation,\n      scratchSetViewOptions.orientation\n    );\n  }\n\n  if (defined(options.duration) && options.duration <= 0.0) {\n    var setViewOptions = scratchSetViewOptions;\n    setViewOptions.destination = options.destination;\n    setViewOptions.orientation.heading = orientation.heading;\n    setViewOptions.orientation.pitch = orientation.pitch;\n    setViewOptions.orientation.roll = orientation.roll;\n    setViewOptions.convert = options.convert;\n    setViewOptions.endTransform = options.endTransform;\n    this.setView(setViewOptions);\n    if (typeof options.complete === \"function\") {\n      options.complete();\n    }\n    return;\n  }\n\n  var isRectangle = defined(destination.west);\n  if (isRectangle) {\n    destination = this.getRectangleCameraCoordinates(\n      destination,\n      scratchFlyToDestination\n    );\n  }\n\n  var that = this;\n  var flightTween;\n\n  newOptions.destination = destination;\n  newOptions.heading = orientation.heading;\n  newOptions.pitch = orientation.pitch;\n  newOptions.roll = orientation.roll;\n  newOptions.duration = options.duration;\n  newOptions.complete = function () {\n    if (flightTween === that._currentFlight) {\n      that._currentFlight = undefined;\n    }\n    if (defined(options.complete)) {\n      options.complete();\n    }\n  };\n  newOptions.cancel = options.cancel;\n  newOptions.endTransform = options.endTransform;\n  newOptions.convert = isRectangle ? false : options.convert;\n  newOptions.maximumHeight = options.maximumHeight;\n  newOptions.pitchAdjustHeight = options.pitchAdjustHeight;\n  newOptions.flyOverLongitude = options.flyOverLongitude;\n  newOptions.flyOverLongitudeWeight = options.flyOverLongitudeWeight;\n  newOptions.easingFunction = options.easingFunction;\n\n  var scene = this._scene;\n  var tweenOptions = CameraFlightPath.createTween(scene, newOptions);\n  // If the camera doesn't actually need to go anywhere, duration\n  // will be 0 and we can just complete the current flight.\n  if (tweenOptions.duration === 0) {\n    if (typeof tweenOptions.complete === \"function\") {\n      tweenOptions.complete();\n    }\n    return;\n  }\n  flightTween = scene.tweens.add(tweenOptions);\n  this._currentFlight = flightTween;\n\n  // Save the final destination view information for the PRELOAD_FLIGHT pass.\n  var preloadFlightCamera = this._scene.preloadFlightCamera;\n  if (this._mode !== SceneMode.SCENE2D) {\n    if (!defined(preloadFlightCamera)) {\n      preloadFlightCamera = Camera.clone(this);\n    }\n    preloadFlightCamera.setView({\n      destination: destination,\n      orientation: orientation,\n    });\n\n    this._scene.preloadFlightCullingVolume = preloadFlightCamera.frustum.computeCullingVolume(\n      preloadFlightCamera.positionWC,\n      preloadFlightCamera.directionWC,\n      preloadFlightCamera.upWC\n    );\n  }\n};\n\nfunction distanceToBoundingSphere3D(camera, radius) {\n  var frustum = camera.frustum;\n  var tanPhi = Math.tan(frustum.fovy * 0.5);\n  var tanTheta = frustum.aspectRatio * tanPhi;\n  return Math.max(radius / tanTheta, radius / tanPhi);\n}\n\nfunction distanceToBoundingSphere2D(camera, radius) {\n  var frustum = camera.frustum;\n  if (defined(frustum._offCenterFrustum)) {\n    frustum = frustum._offCenterFrustum;\n  }\n\n  var right, top;\n  var ratio = frustum.right / frustum.top;\n  var heightRatio = radius * ratio;\n  if (radius > heightRatio) {\n    right = radius;\n    top = right / ratio;\n  } else {\n    top = radius;\n    right = heightRatio;\n  }\n\n  return Math.max(right, top) * 1.5;\n}\n\nvar MINIMUM_ZOOM = 100.0;\n\nfunction adjustBoundingSphereOffset(camera, boundingSphere, offset) {\n  offset = HeadingPitchRange.clone(\n    defined(offset) ? offset : Camera.DEFAULT_OFFSET\n  );\n\n  var minimumZoom =\n    camera._scene.screenSpaceCameraController.minimumZoomDistance;\n  var maximumZoom =\n    camera._scene.screenSpaceCameraController.maximumZoomDistance;\n  var range = offset.range;\n  if (!defined(range) || range === 0.0) {\n    var radius = boundingSphere.radius;\n    if (radius === 0.0) {\n      offset.range = MINIMUM_ZOOM;\n    } else if (\n      camera.frustum instanceof OrthographicFrustum ||\n      camera._mode === SceneMode.SCENE2D\n    ) {\n      offset.range = distanceToBoundingSphere2D(camera, radius);\n    } else {\n      offset.range = distanceToBoundingSphere3D(camera, radius);\n    }\n    offset.range = CesiumMath.clamp(offset.range, minimumZoom, maximumZoom);\n  }\n\n  return offset;\n}\n\n/**\n * Sets the camera so that the current view contains the provided bounding sphere.\n *\n * <p>The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.\n * The heading and the pitch angles are defined in the local east-north-up reference frame.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is\n * zero, a range will be computed such that the whole bounding sphere is visible.</p>\n *\n * <p>In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the range. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.</p>\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere to view, in world coordinates.\n * @param {HeadingPitchRange} [offset] The offset from the target in the local east-north-up reference frame centered at the target.\n *\n * @exception {DeveloperError} viewBoundingSphere is not supported while morphing.\n */\nCamera.prototype.viewBoundingSphere = function (boundingSphere, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n\n  if (this._mode === SceneMode.MORPHING) {\n    throw new DeveloperError(\n      \"viewBoundingSphere is not supported while morphing.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  offset = adjustBoundingSphereOffset(this, boundingSphere, offset);\n  this.lookAt(boundingSphere.center, offset);\n};\n\nvar scratchflyToBoundingSphereTransform = new Matrix4();\nvar scratchflyToBoundingSphereDestination = new Cartesian3();\nvar scratchflyToBoundingSphereDirection = new Cartesian3();\nvar scratchflyToBoundingSphereUp = new Cartesian3();\nvar scratchflyToBoundingSphereRight = new Cartesian3();\nvar scratchFlyToBoundingSphereCart4 = new Cartesian4();\nvar scratchFlyToBoundingSphereQuaternion = new Quaternion();\nvar scratchFlyToBoundingSphereMatrix3 = new Matrix3();\n\n/**\n * Flies the camera to a location where the current view contains the provided bounding sphere.\n *\n * <p> The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.\n * The heading and the pitch angles are defined in the local east-north-up reference frame.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is\n * zero, a range will be computed such that the whole bounding sphere is visible.</p>\n *\n * <p>In 2D and Columbus View, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the range. The heading will be aligned to local north.</p>\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere to view, in world coordinates.\n * @param {Object} [options] Object with the following properties:\n * @param {Number} [options.duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.\n * @param {HeadingPitchRange} [options.offset] The offset from the target in the local east-north-up reference frame centered at the target.\n * @param {Camera~FlightCompleteCallback} [options.complete] The function to execute when the flight is complete.\n * @param {Camera~FlightCancelledCallback} [options.cancel] The function to execute if the flight is cancelled.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame the camera will be in when the flight is completed.\n * @param {Number} [options.maximumHeight] The maximum height at the peak of the flight.\n * @param {Number} [options.pitchAdjustHeight] If camera flyes higher than that value, adjust pitch duiring the flight to look down, and keep Earth in viewport.\n * @param {Number} [options.flyOverLongitude] There are always two ways between 2 points on globe. This option force camera to choose fight direction to fly over that longitude.\n * @param {Number} [options.flyOverLongitudeWeight] Fly over the lon specifyed via flyOverLongitude only if that way is not longer than short way times flyOverLongitudeWeight.\n * @param {EasingFunction|EasingFunction~Callback} [options.easingFunction] Controls how the time is interpolated over the duration of the flight.\n */\nCamera.prototype.flyToBoundingSphere = function (boundingSphere, options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var scene2D =\n    this._mode === SceneMode.SCENE2D || this._mode === SceneMode.COLUMBUS_VIEW;\n  this._setTransform(Matrix4.IDENTITY);\n  var offset = adjustBoundingSphereOffset(this, boundingSphere, options.offset);\n\n  var position;\n  if (scene2D) {\n    position = Cartesian3.multiplyByScalar(\n      Cartesian3.UNIT_Z,\n      offset.range,\n      scratchflyToBoundingSphereDestination\n    );\n  } else {\n    position = offsetFromHeadingPitchRange(\n      offset.heading,\n      offset.pitch,\n      offset.range\n    );\n  }\n\n  var transform = Transforms.eastNorthUpToFixedFrame(\n    boundingSphere.center,\n    Ellipsoid.WGS84,\n    scratchflyToBoundingSphereTransform\n  );\n  Matrix4.multiplyByPoint(transform, position, position);\n\n  var direction;\n  var up;\n\n  if (!scene2D) {\n    direction = Cartesian3.subtract(\n      boundingSphere.center,\n      position,\n      scratchflyToBoundingSphereDirection\n    );\n    Cartesian3.normalize(direction, direction);\n\n    up = Matrix4.multiplyByPointAsVector(\n      transform,\n      Cartesian3.UNIT_Z,\n      scratchflyToBoundingSphereUp\n    );\n    if (1.0 - Math.abs(Cartesian3.dot(direction, up)) < CesiumMath.EPSILON6) {\n      var rotateQuat = Quaternion.fromAxisAngle(\n        direction,\n        offset.heading,\n        scratchFlyToBoundingSphereQuaternion\n      );\n      var rotation = Matrix3.fromQuaternion(\n        rotateQuat,\n        scratchFlyToBoundingSphereMatrix3\n      );\n\n      Cartesian3.fromCartesian4(\n        Matrix4.getColumn(transform, 1, scratchFlyToBoundingSphereCart4),\n        up\n      );\n      Matrix3.multiplyByVector(rotation, up, up);\n    }\n\n    var right = Cartesian3.cross(\n      direction,\n      up,\n      scratchflyToBoundingSphereRight\n    );\n    Cartesian3.cross(right, direction, up);\n    Cartesian3.normalize(up, up);\n  }\n\n  this.flyTo({\n    destination: position,\n    orientation: {\n      direction: direction,\n      up: up,\n    },\n    duration: options.duration,\n    complete: options.complete,\n    cancel: options.cancel,\n    endTransform: options.endTransform,\n    maximumHeight: options.maximumHeight,\n    easingFunction: options.easingFunction,\n    flyOverLongitude: options.flyOverLongitude,\n    flyOverLongitudeWeight: options.flyOverLongitudeWeight,\n    pitchAdjustHeight: options.pitchAdjustHeight,\n  });\n};\n\nvar scratchCartesian3_1 = new Cartesian3();\nvar scratchCartesian3_2 = new Cartesian3();\nvar scratchCartesian3_3 = new Cartesian3();\nvar scratchCartesian3_4 = new Cartesian3();\nvar horizonPoints = [\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n];\n\nfunction computeHorizonQuad(camera, ellipsoid) {\n  var radii = ellipsoid.radii;\n  var p = camera.positionWC;\n\n  // Find the corresponding position in the scaled space of the ellipsoid.\n  var q = Cartesian3.multiplyComponents(\n    ellipsoid.oneOverRadii,\n    p,\n    scratchCartesian3_1\n  );\n\n  var qMagnitude = Cartesian3.magnitude(q);\n  var qUnit = Cartesian3.normalize(q, scratchCartesian3_2);\n\n  // Determine the east and north directions at q.\n  var eUnit;\n  var nUnit;\n  if (\n    Cartesian3.equalsEpsilon(qUnit, Cartesian3.UNIT_Z, CesiumMath.EPSILON10)\n  ) {\n    eUnit = new Cartesian3(0, 1, 0);\n    nUnit = new Cartesian3(0, 0, 1);\n  } else {\n    eUnit = Cartesian3.normalize(\n      Cartesian3.cross(Cartesian3.UNIT_Z, qUnit, scratchCartesian3_3),\n      scratchCartesian3_3\n    );\n    nUnit = Cartesian3.normalize(\n      Cartesian3.cross(qUnit, eUnit, scratchCartesian3_4),\n      scratchCartesian3_4\n    );\n  }\n\n  // Determine the radius of the 'limb' of the ellipsoid.\n  var wMagnitude = Math.sqrt(Cartesian3.magnitudeSquared(q) - 1.0);\n\n  // Compute the center and offsets.\n  var center = Cartesian3.multiplyByScalar(\n    qUnit,\n    1.0 / qMagnitude,\n    scratchCartesian3_1\n  );\n  var scalar = wMagnitude / qMagnitude;\n  var eastOffset = Cartesian3.multiplyByScalar(\n    eUnit,\n    scalar,\n    scratchCartesian3_2\n  );\n  var northOffset = Cartesian3.multiplyByScalar(\n    nUnit,\n    scalar,\n    scratchCartesian3_3\n  );\n\n  // A conservative measure for the longitudes would be to use the min/max longitudes of the bounding frustum.\n  var upperLeft = Cartesian3.add(center, northOffset, horizonPoints[0]);\n  Cartesian3.subtract(upperLeft, eastOffset, upperLeft);\n  Cartesian3.multiplyComponents(radii, upperLeft, upperLeft);\n\n  var lowerLeft = Cartesian3.subtract(center, northOffset, horizonPoints[1]);\n  Cartesian3.subtract(lowerLeft, eastOffset, lowerLeft);\n  Cartesian3.multiplyComponents(radii, lowerLeft, lowerLeft);\n\n  var lowerRight = Cartesian3.subtract(center, northOffset, horizonPoints[2]);\n  Cartesian3.add(lowerRight, eastOffset, lowerRight);\n  Cartesian3.multiplyComponents(radii, lowerRight, lowerRight);\n\n  var upperRight = Cartesian3.add(center, northOffset, horizonPoints[3]);\n  Cartesian3.add(upperRight, eastOffset, upperRight);\n  Cartesian3.multiplyComponents(radii, upperRight, upperRight);\n\n  return horizonPoints;\n}\n\nvar scratchPickCartesian2 = new Cartesian2();\nvar scratchRectCartesian = new Cartesian3();\nvar cartoArray = [\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n];\nfunction addToResult(x, y, index, camera, ellipsoid, computedHorizonQuad) {\n  scratchPickCartesian2.x = x;\n  scratchPickCartesian2.y = y;\n  var r = camera.pickEllipsoid(\n    scratchPickCartesian2,\n    ellipsoid,\n    scratchRectCartesian\n  );\n  if (defined(r)) {\n    cartoArray[index] = ellipsoid.cartesianToCartographic(r, cartoArray[index]);\n    return 1;\n  }\n  cartoArray[index] = ellipsoid.cartesianToCartographic(\n    computedHorizonQuad[index],\n    cartoArray[index]\n  );\n  return 0;\n}\n/**\n * Computes the approximate visible rectangle on the ellipsoid.\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid that you want to know the visible region.\n * @param {Rectangle} [result] The rectangle in which to store the result\n *\n * @returns {Rectangle|undefined} The visible rectangle or undefined if the ellipsoid isn't visible at all.\n */\nCamera.prototype.computeViewRectangle = function (ellipsoid, result) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  var cullingVolume = this.frustum.computeCullingVolume(\n    this.positionWC,\n    this.directionWC,\n    this.upWC\n  );\n  var boundingSphere = new BoundingSphere(\n    Cartesian3.ZERO,\n    ellipsoid.maximumRadius\n  );\n  var visibility = cullingVolume.computeVisibility(boundingSphere);\n  if (visibility === Intersect.OUTSIDE) {\n    return undefined;\n  }\n\n  var canvas = this._scene.canvas;\n  var width = canvas.clientWidth;\n  var height = canvas.clientHeight;\n\n  var successfulPickCount = 0;\n\n  var computedHorizonQuad = computeHorizonQuad(this, ellipsoid);\n\n  successfulPickCount += addToResult(\n    0,\n    0,\n    0,\n    this,\n    ellipsoid,\n    computedHorizonQuad\n  );\n  successfulPickCount += addToResult(\n    0,\n    height,\n    1,\n    this,\n    ellipsoid,\n    computedHorizonQuad\n  );\n  successfulPickCount += addToResult(\n    width,\n    height,\n    2,\n    this,\n    ellipsoid,\n    computedHorizonQuad\n  );\n  successfulPickCount += addToResult(\n    width,\n    0,\n    3,\n    this,\n    ellipsoid,\n    computedHorizonQuad\n  );\n\n  if (successfulPickCount < 2) {\n    // If we have space non-globe in 3 or 4 corners then return the whole globe\n    return Rectangle.MAX_VALUE;\n  }\n\n  result = Rectangle.fromCartographicArray(cartoArray, result);\n\n  // Detect if we go over the poles\n  var distance = 0;\n  var lastLon = cartoArray[3].longitude;\n  for (var i = 0; i < 4; ++i) {\n    var lon = cartoArray[i].longitude;\n    var diff = Math.abs(lon - lastLon);\n    if (diff > CesiumMath.PI) {\n      // Crossed the dateline\n      distance += CesiumMath.TWO_PI - diff;\n    } else {\n      distance += diff;\n    }\n\n    lastLon = lon;\n  }\n\n  // We are over one of the poles so adjust the rectangle accordingly\n  if (\n    CesiumMath.equalsEpsilon(\n      Math.abs(distance),\n      CesiumMath.TWO_PI,\n      CesiumMath.EPSILON9\n    )\n  ) {\n    result.west = -CesiumMath.PI;\n    result.east = CesiumMath.PI;\n    if (cartoArray[0].latitude >= 0.0) {\n      result.north = CesiumMath.PI_OVER_TWO;\n    } else {\n      result.south = -CesiumMath.PI_OVER_TWO;\n    }\n  }\n\n  return result;\n};\n\n/**\n * Switches the frustum/projection to perspective.\n *\n * This function is a no-op in 2D which must always be orthographic.\n */\nCamera.prototype.switchToPerspectiveFrustum = function () {\n  if (\n    this._mode === SceneMode.SCENE2D ||\n    this.frustum instanceof PerspectiveFrustum\n  ) {\n    return;\n  }\n\n  var scene = this._scene;\n  this.frustum = new PerspectiveFrustum();\n  this.frustum.aspectRatio =\n    scene.drawingBufferWidth / scene.drawingBufferHeight;\n  this.frustum.fov = CesiumMath.toRadians(60.0);\n};\n\n/**\n * Switches the frustum/projection to orthographic.\n *\n * This function is a no-op in 2D which will always be orthographic.\n */\nCamera.prototype.switchToOrthographicFrustum = function () {\n  if (\n    this._mode === SceneMode.SCENE2D ||\n    this.frustum instanceof OrthographicFrustum\n  ) {\n    return;\n  }\n\n  var scene = this._scene;\n  this.frustum = new OrthographicFrustum();\n  this.frustum.aspectRatio =\n    scene.drawingBufferWidth / scene.drawingBufferHeight;\n\n  // It doesn't matter what we set this to. The adjust below will correct the width based on the camera position.\n  this.frustum.width = Cartesian3.magnitude(this.position);\n\n  // Check the projection matrix. It will always be defined, but we need to force an off-center update.\n  var projectionMatrix = this.frustum.projectionMatrix;\n  if (defined(projectionMatrix)) {\n    this._adjustOrthographicFrustum(true);\n  }\n};\n\n/**\n * @private\n */\nCamera.clone = function (camera, result) {\n  if (!defined(result)) {\n    result = new Camera(camera._scene);\n  }\n\n  Cartesian3.clone(camera.position, result.position);\n  Cartesian3.clone(camera.direction, result.direction);\n  Cartesian3.clone(camera.up, result.up);\n  Cartesian3.clone(camera.right, result.right);\n  Matrix4.clone(camera._transform, result.transform);\n  result._transformChanged = true;\n  result.frustum = camera.frustum.clone();\n\n  return result;\n};\n\n/**\n * A function that will execute when a flight completes.\n * @callback Camera~FlightCompleteCallback\n */\n\n/**\n * A function that will execute when a flight is cancelled.\n * @callback Camera~FlightCancelledCallback\n */\nexport default Camera;\n"]},"metadata":{},"sourceType":"module"}