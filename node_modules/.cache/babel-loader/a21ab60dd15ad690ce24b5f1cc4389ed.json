{"ast":null,"code":"import when from \"../ThirdParty/when.js\";\nimport AttributeCompression from \"./AttributeCompression.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Credit from \"./Credit.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Event from \"./Event.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport WebMercatorTilingScheme from \"./WebMercatorTilingScheme.js\";\nimport getStringFromTypedArray from \"./getStringFromTypedArray.js\";\nimport HeightmapTerrainData from \"./HeightmapTerrainData.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport QuantizedMeshTerrainData from \"./QuantizedMeshTerrainData.js\";\nimport Request from \"./Request.js\";\nimport RequestType from \"./RequestType.js\";\nimport Resource from \"./Resource.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nimport TerrainProvider from \"./TerrainProvider.js\";\nimport TileAvailability from \"./TileAvailability.js\";\nimport TileProviderError from \"./TileProviderError.js\";\n\nfunction LayerInformation(layer) {\n  this.resource = layer.resource;\n  this.version = layer.version;\n  this.isHeightmap = layer.isHeightmap;\n  this.tileUrlTemplates = layer.tileUrlTemplates;\n  this.availability = layer.availability;\n  this.hasVertexNormals = layer.hasVertexNormals;\n  this.hasWaterMask = layer.hasWaterMask;\n  this.hasMetadata = layer.hasMetadata;\n  this.availabilityLevels = layer.availabilityLevels;\n  this.availabilityTilesLoaded = layer.availabilityTilesLoaded;\n  this.littleEndianExtensionSize = layer.littleEndianExtensionSize;\n  this.availabilityTilesLoaded = layer.availabilityTilesLoaded;\n  this.availabilityPromiseCache = {};\n}\n/**\n * A {@link TerrainProvider} that accesses terrain data in a Cesium terrain format.\n *\n * @alias CesiumTerrainProvider\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource|String|Promise<Resource>|Promise<String>} options.url The URL of the Cesium terrain server.\n * @param {Boolean} [options.requestVertexNormals=false] Flag that indicates if the client should request additional lighting information from the server, in the form of per vertex normals if available.\n * @param {Boolean} [options.requestWaterMask=false] Flag that indicates if the client should request per tile water masks from the server,  if available.\n * @param {Boolean} [options.requestMetadata=true] Flag that indicates if the client should request per tile metadata from the server, if available.\n * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If not specified, the WGS84 ellipsoid is used.\n * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.\n *\n *\n * @example\n * // Create Arctic DEM terrain with normals.\n * var viewer = new Cesium.Viewer('cesiumContainer', {\n *     terrainProvider : new Cesium.CesiumTerrainProvider({\n *         url : Cesium.IonResource.fromAssetId(3956),\n *         requestVertexNormals : true\n *     })\n * });\n *\n * @see createWorldTerrain\n * @see TerrainProvider\n */\n\n\nfunction CesiumTerrainProvider(options) {\n  //>>includeStart('debug', pragmas.debug)\n  if (!defined(options) || !defined(options.url)) {\n    throw new DeveloperError(\"options.url is required.\");\n  } //>>includeEnd('debug');\n\n\n  this._heightmapWidth = 65;\n  this._heightmapStructure = undefined;\n  this._hasWaterMask = false;\n  this._hasVertexNormals = false;\n  this._ellipsoid = options.ellipsoid;\n  /**\n   * Boolean flag that indicates if the client should request vertex normals from the server.\n   * @type {Boolean}\n   * @default false\n   * @private\n   */\n\n  this._requestVertexNormals = defaultValue(options.requestVertexNormals, false);\n  /**\n   * Boolean flag that indicates if the client should request tile watermasks from the server.\n   * @type {Boolean}\n   * @default false\n   * @private\n   */\n\n  this._requestWaterMask = defaultValue(options.requestWaterMask, false);\n  /**\n   * Boolean flag that indicates if the client should request tile metadata from the server.\n   * @type {Boolean}\n   * @default true\n   * @private\n   */\n\n  this._requestMetadata = defaultValue(options.requestMetadata, true);\n  this._errorEvent = new Event();\n  var credit = options.credit;\n\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n\n  this._credit = credit;\n  this._availability = undefined;\n  var deferred = when.defer();\n  this._ready = false;\n  this._readyPromise = deferred;\n  this._tileCredits = undefined;\n  var that = this;\n  var lastResource;\n  var layerJsonResource;\n  var metadataError;\n  var layers = this._layers = [];\n  var attribution = \"\";\n  var overallAvailability = [];\n  var overallMaxZoom = 0;\n  when(options.url).then(function (url) {\n    var resource = Resource.createIfNeeded(url);\n    resource.appendForwardSlash();\n    lastResource = resource;\n    layerJsonResource = lastResource.getDerivedResource({\n      url: \"layer.json\"\n    }); // ion resources have a credits property we can use for additional attribution.\n\n    that._tileCredits = resource.credits;\n    requestLayerJson();\n  }).otherwise(function (e) {\n    deferred.reject(e);\n  });\n\n  function parseMetadataSuccess(data) {\n    var message;\n\n    if (!data.format) {\n      message = \"The tile format is not specified in the layer.json file.\";\n      metadataError = TileProviderError.handleError(metadataError, that, that._errorEvent, message, undefined, undefined, undefined, requestLayerJson);\n      return;\n    }\n\n    if (!data.tiles || data.tiles.length === 0) {\n      message = \"The layer.json file does not specify any tile URL templates.\";\n      metadataError = TileProviderError.handleError(metadataError, that, that._errorEvent, message, undefined, undefined, undefined, requestLayerJson);\n      return;\n    }\n\n    var hasVertexNormals = false;\n    var hasWaterMask = false;\n    var hasMetadata = false;\n    var littleEndianExtensionSize = true;\n    var isHeightmap = false;\n\n    if (data.format === \"heightmap-1.0\") {\n      isHeightmap = true;\n\n      if (!defined(that._heightmapStructure)) {\n        that._heightmapStructure = {\n          heightScale: 1.0 / 5.0,\n          heightOffset: -1000.0,\n          elementsPerHeight: 1,\n          stride: 1,\n          elementMultiplier: 256.0,\n          isBigEndian: false,\n          lowestEncodedHeight: 0,\n          highestEncodedHeight: 256 * 256 - 1\n        };\n      }\n\n      hasWaterMask = true;\n      that._requestWaterMask = true;\n    } else if (data.format.indexOf(\"quantized-mesh-1.\") !== 0) {\n      message = 'The tile format \"' + data.format + '\" is invalid or not supported.';\n      metadataError = TileProviderError.handleError(metadataError, that, that._errorEvent, message, undefined, undefined, undefined, requestLayerJson);\n      return;\n    }\n\n    var tileUrlTemplates = data.tiles;\n    var maxZoom = data.maxzoom;\n    overallMaxZoom = Math.max(overallMaxZoom, maxZoom); // Keeps track of which of the availablity containing tiles have been loaded\n\n    if (!data.projection || data.projection === \"EPSG:4326\") {\n      that._tilingScheme = new GeographicTilingScheme({\n        numberOfLevelZeroTilesX: 2,\n        numberOfLevelZeroTilesY: 1,\n        ellipsoid: that._ellipsoid\n      });\n    } else if (data.projection === \"EPSG:3857\") {\n      that._tilingScheme = new WebMercatorTilingScheme({\n        numberOfLevelZeroTilesX: 1,\n        numberOfLevelZeroTilesY: 1,\n        ellipsoid: that._ellipsoid\n      });\n    } else {\n      message = 'The projection \"' + data.projection + '\" is invalid or not supported.';\n      metadataError = TileProviderError.handleError(metadataError, that, that._errorEvent, message, undefined, undefined, undefined, requestLayerJson);\n      return;\n    }\n\n    that._levelZeroMaximumGeometricError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(that._tilingScheme.ellipsoid, that._heightmapWidth, that._tilingScheme.getNumberOfXTilesAtLevel(0));\n\n    if (!data.scheme || data.scheme === \"tms\" || data.scheme === \"slippyMap\") {\n      that._scheme = data.scheme;\n    } else {\n      message = 'The scheme \"' + data.scheme + '\" is invalid or not supported.';\n      metadataError = TileProviderError.handleError(metadataError, that, that._errorEvent, message, undefined, undefined, undefined, requestLayerJson);\n      return;\n    }\n\n    var availabilityTilesLoaded; // The vertex normals defined in the 'octvertexnormals' extension is identical to the original\n    // contents of the original 'vertexnormals' extension.  'vertexnormals' extension is now\n    // deprecated, as the extensionLength for this extension was incorrectly using big endian.\n    // We maintain backwards compatibility with the legacy 'vertexnormal' implementation\n    // by setting the _littleEndianExtensionSize to false. Always prefer 'octvertexnormals'\n    // over 'vertexnormals' if both extensions are supported by the server.\n\n    if (defined(data.extensions) && data.extensions.indexOf(\"octvertexnormals\") !== -1) {\n      hasVertexNormals = true;\n    } else if (defined(data.extensions) && data.extensions.indexOf(\"vertexnormals\") !== -1) {\n      hasVertexNormals = true;\n      littleEndianExtensionSize = false;\n    }\n\n    if (defined(data.extensions) && data.extensions.indexOf(\"watermask\") !== -1) {\n      hasWaterMask = true;\n    }\n\n    if (defined(data.extensions) && data.extensions.indexOf(\"metadata\") !== -1) {\n      hasMetadata = true;\n    }\n\n    var availabilityLevels = data.metadataAvailability;\n    var availableTiles = data.available;\n    var availability;\n\n    if (defined(availableTiles) && !defined(availabilityLevels)) {\n      availability = new TileAvailability(that._tilingScheme, availableTiles.length);\n\n      for (var level = 0; level < availableTiles.length; ++level) {\n        var rangesAtLevel = availableTiles[level];\n\n        var yTiles = that._tilingScheme.getNumberOfYTilesAtLevel(level);\n\n        if (!defined(overallAvailability[level])) {\n          overallAvailability[level] = [];\n        }\n\n        for (var rangeIndex = 0; rangeIndex < rangesAtLevel.length; ++rangeIndex) {\n          var range = rangesAtLevel[rangeIndex];\n          var yStart = yTiles - range.endY - 1;\n          var yEnd = yTiles - range.startY - 1;\n          overallAvailability[level].push([range.startX, yStart, range.endX, yEnd]);\n          availability.addAvailableTileRange(level, range.startX, yStart, range.endX, yEnd);\n        }\n      }\n    } else if (defined(availabilityLevels)) {\n      availabilityTilesLoaded = new TileAvailability(that._tilingScheme, maxZoom);\n      availability = new TileAvailability(that._tilingScheme, maxZoom);\n      overallAvailability[0] = [[0, 0, 1, 0]];\n      availability.addAvailableTileRange(0, 0, 0, 1, 0);\n    }\n\n    that._hasWaterMask = that._hasWaterMask || hasWaterMask;\n    that._hasVertexNormals = that._hasVertexNormals || hasVertexNormals;\n    that._hasMetadata = that._hasMetadata || hasMetadata;\n\n    if (defined(data.attribution)) {\n      if (attribution.length > 0) {\n        attribution += \" \";\n      }\n\n      attribution += data.attribution;\n    }\n\n    layers.push(new LayerInformation({\n      resource: lastResource,\n      version: data.version,\n      isHeightmap: isHeightmap,\n      tileUrlTemplates: tileUrlTemplates,\n      availability: availability,\n      hasVertexNormals: hasVertexNormals,\n      hasWaterMask: hasWaterMask,\n      hasMetadata: hasMetadata,\n      availabilityLevels: availabilityLevels,\n      availabilityTilesLoaded: availabilityTilesLoaded,\n      littleEndianExtensionSize: littleEndianExtensionSize\n    }));\n    var parentUrl = data.parentUrl;\n\n    if (defined(parentUrl)) {\n      if (!defined(availability)) {\n        console.log(\"A layer.json can't have a parentUrl if it does't have an available array.\");\n        return when.resolve();\n      }\n\n      lastResource = lastResource.getDerivedResource({\n        url: parentUrl\n      });\n      lastResource.appendForwardSlash(); // Terrain always expects a directory\n\n      layerJsonResource = lastResource.getDerivedResource({\n        url: \"layer.json\"\n      });\n      var parentMetadata = layerJsonResource.fetchJson();\n      return when(parentMetadata, parseMetadataSuccess, parseMetadataFailure);\n    }\n\n    return when.resolve();\n  }\n\n  function parseMetadataFailure(data) {\n    var message = \"An error occurred while accessing \" + layerJsonResource.url + \".\";\n    metadataError = TileProviderError.handleError(metadataError, that, that._errorEvent, message, undefined, undefined, undefined, requestLayerJson);\n  }\n\n  function metadataSuccess(data) {\n    parseMetadataSuccess(data).then(function () {\n      if (defined(metadataError)) {\n        return;\n      }\n\n      var length = overallAvailability.length;\n\n      if (length > 0) {\n        var availability = that._availability = new TileAvailability(that._tilingScheme, overallMaxZoom);\n\n        for (var level = 0; level < length; ++level) {\n          var levelRanges = overallAvailability[level];\n\n          for (var i = 0; i < levelRanges.length; ++i) {\n            var range = levelRanges[i];\n            availability.addAvailableTileRange(level, range[0], range[1], range[2], range[3]);\n          }\n        }\n      }\n\n      if (attribution.length > 0) {\n        var layerJsonCredit = new Credit(attribution);\n\n        if (defined(that._tileCredits)) {\n          that._tileCredits.push(layerJsonCredit);\n        } else {\n          that._tileCredits = [layerJsonCredit];\n        }\n      }\n\n      that._ready = true;\n\n      that._readyPromise.resolve(true);\n    });\n  }\n\n  function metadataFailure(data) {\n    // If the metadata is not found, assume this is a pre-metadata heightmap tileset.\n    if (defined(data) && data.statusCode === 404) {\n      metadataSuccess({\n        tilejson: \"2.1.0\",\n        format: \"heightmap-1.0\",\n        version: \"1.0.0\",\n        scheme: \"tms\",\n        tiles: [\"{z}/{x}/{y}.terrain?v={version}\"]\n      });\n      return;\n    }\n\n    parseMetadataFailure(data);\n  }\n\n  function requestLayerJson() {\n    when(layerJsonResource.fetchJson()).then(metadataSuccess).otherwise(metadataFailure);\n  }\n}\n/**\n * When using the Quantized-Mesh format, a tile may be returned that includes additional extensions, such as PerVertexNormals, watermask, etc.\n * This enumeration defines the unique identifiers for each type of extension data that has been appended to the standard mesh data.\n *\n * @exports QuantizedMeshExtensionIds\n * @see CesiumTerrainProvider\n * @private\n */\n\n\nvar QuantizedMeshExtensionIds = {\n  /**\n   * Oct-Encoded Per-Vertex Normals are included as an extension to the tile mesh\n   *\n   * @type {Number}\n   * @constant\n   * @default 1\n   */\n  OCT_VERTEX_NORMALS: 1,\n\n  /**\n   * A watermask is included as an extension to the tile mesh\n   *\n   * @type {Number}\n   * @constant\n   * @default 2\n   */\n  WATER_MASK: 2,\n\n  /**\n   * A json object contain metadata about the tile\n   *\n   * @type {Number}\n   * @constant\n   * @default 4\n   */\n  METADATA: 4\n};\n\nfunction getRequestHeader(extensionsList) {\n  if (!defined(extensionsList) || extensionsList.length === 0) {\n    return {\n      Accept: \"application/vnd.quantized-mesh,application/octet-stream;q=0.9,*/*;q=0.01\"\n    };\n  }\n\n  var extensions = extensionsList.join(\"-\");\n  return {\n    Accept: \"application/vnd.quantized-mesh;extensions=\" + extensions + \",application/octet-stream;q=0.9,*/*;q=0.01\"\n  };\n}\n\nfunction createHeightmapTerrainData(provider, buffer, level, x, y) {\n  var heightBuffer = new Uint16Array(buffer, 0, provider._heightmapWidth * provider._heightmapWidth);\n  return new HeightmapTerrainData({\n    buffer: heightBuffer,\n    childTileMask: new Uint8Array(buffer, heightBuffer.byteLength, 1)[0],\n    waterMask: new Uint8Array(buffer, heightBuffer.byteLength + 1, buffer.byteLength - heightBuffer.byteLength - 1),\n    width: provider._heightmapWidth,\n    height: provider._heightmapWidth,\n    structure: provider._heightmapStructure,\n    credits: provider._tileCredits\n  });\n}\n\nfunction createQuantizedMeshTerrainData(provider, buffer, level, x, y, layer) {\n  var littleEndianExtensionSize = layer.littleEndianExtensionSize;\n  var pos = 0;\n  var cartesian3Elements = 3;\n  var boundingSphereElements = cartesian3Elements + 1;\n  var cartesian3Length = Float64Array.BYTES_PER_ELEMENT * cartesian3Elements;\n  var boundingSphereLength = Float64Array.BYTES_PER_ELEMENT * boundingSphereElements;\n  var encodedVertexElements = 3;\n  var encodedVertexLength = Uint16Array.BYTES_PER_ELEMENT * encodedVertexElements;\n  var triangleElements = 3;\n  var bytesPerIndex = Uint16Array.BYTES_PER_ELEMENT;\n  var triangleLength = bytesPerIndex * triangleElements;\n  var view = new DataView(buffer);\n  var center = new Cartesian3(view.getFloat64(pos, true), view.getFloat64(pos + 8, true), view.getFloat64(pos + 16, true));\n  pos += cartesian3Length;\n  var minimumHeight = view.getFloat32(pos, true);\n  pos += Float32Array.BYTES_PER_ELEMENT;\n  var maximumHeight = view.getFloat32(pos, true);\n  pos += Float32Array.BYTES_PER_ELEMENT;\n  var boundingSphere = new BoundingSphere(new Cartesian3(view.getFloat64(pos, true), view.getFloat64(pos + 8, true), view.getFloat64(pos + 16, true)), view.getFloat64(pos + cartesian3Length, true));\n  pos += boundingSphereLength;\n  var horizonOcclusionPoint = new Cartesian3(view.getFloat64(pos, true), view.getFloat64(pos + 8, true), view.getFloat64(pos + 16, true));\n  pos += cartesian3Length;\n  var vertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  var encodedVertexBuffer = new Uint16Array(buffer, pos, vertexCount * 3);\n  pos += vertexCount * encodedVertexLength;\n\n  if (vertexCount > 64 * 1024) {\n    // More than 64k vertices, so indices are 32-bit.\n    bytesPerIndex = Uint32Array.BYTES_PER_ELEMENT;\n    triangleLength = bytesPerIndex * triangleElements;\n  } // Decode the vertex buffer.\n\n\n  var uBuffer = encodedVertexBuffer.subarray(0, vertexCount);\n  var vBuffer = encodedVertexBuffer.subarray(vertexCount, 2 * vertexCount);\n  var heightBuffer = encodedVertexBuffer.subarray(vertexCount * 2, 3 * vertexCount);\n  AttributeCompression.zigZagDeltaDecode(uBuffer, vBuffer, heightBuffer); // skip over any additional padding that was added for 2/4 byte alignment\n\n  if (pos % bytesPerIndex !== 0) {\n    pos += bytesPerIndex - pos % bytesPerIndex;\n  }\n\n  var triangleCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  var indices = IndexDatatype.createTypedArrayFromArrayBuffer(vertexCount, buffer, pos, triangleCount * triangleElements);\n  pos += triangleCount * triangleLength; // High water mark decoding based on decompressIndices_ in webgl-loader's loader.js.\n  // https://code.google.com/p/webgl-loader/source/browse/trunk/samples/loader.js?r=99#55\n  // Copyright 2012 Google Inc., Apache 2.0 license.\n\n  var highest = 0;\n  var length = indices.length;\n\n  for (var i = 0; i < length; ++i) {\n    var code = indices[i];\n    indices[i] = highest - code;\n\n    if (code === 0) {\n      ++highest;\n    }\n  }\n\n  var westVertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  var westIndices = IndexDatatype.createTypedArrayFromArrayBuffer(vertexCount, buffer, pos, westVertexCount);\n  pos += westVertexCount * bytesPerIndex;\n  var southVertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  var southIndices = IndexDatatype.createTypedArrayFromArrayBuffer(vertexCount, buffer, pos, southVertexCount);\n  pos += southVertexCount * bytesPerIndex;\n  var eastVertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  var eastIndices = IndexDatatype.createTypedArrayFromArrayBuffer(vertexCount, buffer, pos, eastVertexCount);\n  pos += eastVertexCount * bytesPerIndex;\n  var northVertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  var northIndices = IndexDatatype.createTypedArrayFromArrayBuffer(vertexCount, buffer, pos, northVertexCount);\n  pos += northVertexCount * bytesPerIndex;\n  var encodedNormalBuffer;\n  var waterMaskBuffer;\n\n  while (pos < view.byteLength) {\n    var extensionId = view.getUint8(pos, true);\n    pos += Uint8Array.BYTES_PER_ELEMENT;\n    var extensionLength = view.getUint32(pos, littleEndianExtensionSize);\n    pos += Uint32Array.BYTES_PER_ELEMENT;\n\n    if (extensionId === QuantizedMeshExtensionIds.OCT_VERTEX_NORMALS && provider._requestVertexNormals) {\n      encodedNormalBuffer = new Uint8Array(buffer, pos, vertexCount * 2);\n    } else if (extensionId === QuantizedMeshExtensionIds.WATER_MASK && provider._requestWaterMask) {\n      waterMaskBuffer = new Uint8Array(buffer, pos, extensionLength);\n    } else if (extensionId === QuantizedMeshExtensionIds.METADATA && provider._requestMetadata) {\n      var stringLength = view.getUint32(pos, true);\n\n      if (stringLength > 0) {\n        var jsonString = getStringFromTypedArray(new Uint8Array(buffer), pos + Uint32Array.BYTES_PER_ELEMENT, stringLength);\n        var metadata = JSON.parse(jsonString);\n        var availableTiles = metadata.available;\n\n        if (defined(availableTiles)) {\n          for (var offset = 0; offset < availableTiles.length; ++offset) {\n            var availableLevel = level + offset + 1;\n            var rangesAtLevel = availableTiles[offset];\n\n            var yTiles = provider._tilingScheme.getNumberOfYTilesAtLevel(availableLevel);\n\n            for (var rangeIndex = 0; rangeIndex < rangesAtLevel.length; ++rangeIndex) {\n              var range = rangesAtLevel[rangeIndex];\n              var yStart = yTiles - range.endY - 1;\n              var yEnd = yTiles - range.startY - 1;\n              provider.availability.addAvailableTileRange(availableLevel, range.startX, yStart, range.endX, yEnd);\n              layer.availability.addAvailableTileRange(availableLevel, range.startX, yStart, range.endX, yEnd);\n            }\n          }\n        }\n      }\n\n      layer.availabilityTilesLoaded.addAvailableTileRange(level, x, y, x, y);\n    }\n\n    pos += extensionLength;\n  }\n\n  var skirtHeight = provider.getLevelMaximumGeometricError(level) * 5.0; // The skirt is not included in the OBB computation. If this ever\n  // causes any rendering artifacts (cracks), they are expected to be\n  // minor and in the corners of the screen. It's possible that this\n  // might need to be changed - just change to `minimumHeight - skirtHeight`\n  // A similar change might also be needed in `upsampleQuantizedTerrainMesh.js`.\n\n  var rectangle = provider._tilingScheme.tileXYToRectangle(x, y, level);\n\n  var orientedBoundingBox = OrientedBoundingBox.fromRectangle(rectangle, minimumHeight, maximumHeight, provider._tilingScheme.ellipsoid);\n  return new QuantizedMeshTerrainData({\n    center: center,\n    minimumHeight: minimumHeight,\n    maximumHeight: maximumHeight,\n    boundingSphere: boundingSphere,\n    orientedBoundingBox: orientedBoundingBox,\n    horizonOcclusionPoint: horizonOcclusionPoint,\n    quantizedVertices: encodedVertexBuffer,\n    encodedNormals: encodedNormalBuffer,\n    indices: indices,\n    westIndices: westIndices,\n    southIndices: southIndices,\n    eastIndices: eastIndices,\n    northIndices: northIndices,\n    westSkirtHeight: skirtHeight,\n    southSkirtHeight: skirtHeight,\n    eastSkirtHeight: skirtHeight,\n    northSkirtHeight: skirtHeight,\n    childTileMask: provider.availability.computeChildMaskForTile(level, x, y),\n    waterMask: waterMaskBuffer,\n    credits: provider._tileCredits\n  });\n}\n/**\n * Requests the geometry for a given tile.  This function should not be called before\n * {@link CesiumTerrainProvider#ready} returns true.  The result must include terrain data and\n * may optionally include a water mask and an indication of which child tiles are available.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n *\n * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n *\n * @exception {DeveloperError} This function must not be called before {@link CesiumTerrainProvider#ready}\n *            returns true.\n */\n\n\nCesiumTerrainProvider.prototype.requestTileGeometry = function (x, y, level, request) {\n  //>>includeStart('debug', pragmas.debug)\n  if (!this._ready) {\n    throw new DeveloperError(\"requestTileGeometry must not be called before the terrain provider is ready.\");\n  } //>>includeEnd('debug');\n\n\n  var layers = this._layers;\n  var layerToUse;\n  var layerCount = layers.length;\n\n  if (layerCount === 1) {\n    // Optimized path for single layers\n    layerToUse = layers[0];\n  } else {\n    for (var i = 0; i < layerCount; ++i) {\n      var layer = layers[i];\n\n      if (!defined(layer.availability) || layer.availability.isTileAvailable(level, x, y)) {\n        layerToUse = layer;\n        break;\n      }\n    }\n  }\n\n  return requestTileGeometry(this, x, y, level, layerToUse, request);\n};\n\nfunction requestTileGeometry(provider, x, y, level, layerToUse, request) {\n  if (!defined(layerToUse)) {\n    return when.reject(new RuntimeError(\"Terrain tile doesn't exist\"));\n  }\n\n  var urlTemplates = layerToUse.tileUrlTemplates;\n\n  if (urlTemplates.length === 0) {\n    return undefined;\n  } // The TileMapService scheme counts from the bottom left\n\n\n  var terrainY;\n\n  if (!provider._scheme || provider._scheme === \"tms\") {\n    var yTiles = provider._tilingScheme.getNumberOfYTilesAtLevel(level);\n\n    terrainY = yTiles - y - 1;\n  } else {\n    terrainY = y;\n  }\n\n  var extensionList = [];\n\n  if (provider._requestVertexNormals && layerToUse.hasVertexNormals) {\n    extensionList.push(layerToUse.littleEndianExtensionSize ? \"octvertexnormals\" : \"vertexnormals\");\n  }\n\n  if (provider._requestWaterMask && layerToUse.hasWaterMask) {\n    extensionList.push(\"watermask\");\n  }\n\n  if (provider._requestMetadata && layerToUse.hasMetadata) {\n    extensionList.push(\"metadata\");\n  }\n\n  var headers;\n  var query;\n  var url = urlTemplates[(x + terrainY + level) % urlTemplates.length];\n  var resource = layerToUse.resource;\n\n  if (defined(resource._ionEndpoint) && !defined(resource._ionEndpoint.externalType)) {\n    // ion uses query paremeters to request extensions\n    if (extensionList.length !== 0) {\n      query = {\n        extensions: extensionList.join(\"-\")\n      };\n    }\n\n    headers = getRequestHeader(undefined);\n  } else {\n    //All other terrain servers\n    headers = getRequestHeader(extensionList);\n  }\n\n  var promise = resource.getDerivedResource({\n    url: url,\n    templateValues: {\n      version: layerToUse.version,\n      z: level,\n      x: x,\n      y: terrainY\n    },\n    queryParameters: query,\n    headers: headers,\n    request: request\n  }).fetchArrayBuffer();\n\n  if (!defined(promise)) {\n    return undefined;\n  }\n\n  return promise.then(function (buffer) {\n    if (defined(provider._heightmapStructure)) {\n      return createHeightmapTerrainData(provider, buffer, level, x, y);\n    }\n\n    return createQuantizedMeshTerrainData(provider, buffer, level, x, y, layerToUse);\n  });\n}\n\nObject.defineProperties(CesiumTerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    }\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.  This function should not be called before {@link CesiumTerrainProvider#ready} returns true.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Credit}\n   */\n  credit: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug)\n      if (!this._ready) {\n        throw new DeveloperError(\"credit must not be called before the terrain provider is ready.\");\n      } //>>includeEnd('debug');\n\n\n      return this._credit;\n    }\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.  This function should\n   * not be called before {@link CesiumTerrainProvider#ready} returns true.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {GeographicTilingScheme}\n   */\n  tilingScheme: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug)\n      if (!this._ready) {\n        throw new DeveloperError(\"tilingScheme must not be called before the terrain provider is ready.\");\n      } //>>includeEnd('debug');\n\n\n      return this._tilingScheme;\n    }\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Boolean}\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    }\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.  This function should not be\n   * called before {@link CesiumTerrainProvider#ready} returns true.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Boolean}\n   * @exception {DeveloperError} This property must not be called before {@link CesiumTerrainProvider#ready}\n   */\n  hasWaterMask: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug)\n      if (!this._ready) {\n        throw new DeveloperError(\"hasWaterMask must not be called before the terrain provider is ready.\");\n      } //>>includeEnd('debug');\n\n\n      return this._hasWaterMask && this._requestWaterMask;\n    }\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * This function should not be called before {@link CesiumTerrainProvider#ready} returns true.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Boolean}\n   * @exception {DeveloperError} This property must not be called before {@link CesiumTerrainProvider#ready}\n   */\n  hasVertexNormals: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug)\n      if (!this._ready) {\n        throw new DeveloperError(\"hasVertexNormals must not be called before the terrain provider is ready.\");\n      } //>>includeEnd('debug');\n      // returns true if we can request vertex normals from the server\n\n\n      return this._hasVertexNormals && this._requestVertexNormals;\n    }\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include metadata.\n   * This function should not be called before {@link CesiumTerrainProvider#ready} returns true.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Boolean}\n   * @exception {DeveloperError} This property must not be called before {@link CesiumTerrainProvider#ready}\n   */\n  hasMetadata: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug)\n      if (!this._ready) {\n        throw new DeveloperError(\"hasMetadata must not be called before the terrain provider is ready.\");\n      } //>>includeEnd('debug');\n      // returns true if we can request metadata from the server\n\n\n      return this._hasMetadata && this._requestMetadata;\n    }\n  },\n\n  /**\n   * Boolean flag that indicates if the client should request vertex normals from the server.\n   * Vertex normals data is appended to the standard tile mesh data only if the client requests the vertex normals and\n   * if the server provides vertex normals.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Boolean}\n   */\n  requestVertexNormals: {\n    get: function () {\n      return this._requestVertexNormals;\n    }\n  },\n\n  /**\n   * Boolean flag that indicates if the client should request a watermask from the server.\n   * Watermask data is appended to the standard tile mesh data only if the client requests the watermask and\n   * if the server provides a watermask.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Boolean}\n   */\n  requestWaterMask: {\n    get: function () {\n      return this._requestWaterMask;\n    }\n  },\n\n  /**\n   * Boolean flag that indicates if the client should request metadata from the server.\n   * Metadata is appended to the standard tile mesh data only if the client requests the metadata and\n   * if the server provides a metadata.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Boolean}\n   */\n  requestMetadata: {\n    get: function () {\n      return this._requestMetadata;\n    }\n  },\n\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles.  This function should not be called before\n   * {@link CesiumTerrainProvider#ready} returns true.  This property may be undefined if availability\n   * information is not available. Note that this reflects tiles that are known to be available currently.\n   * Additional tiles may be discovered to be available in the future, e.g. if availability information\n   * exists deeper in the tree rather than it all being discoverable at the root. However, a tile that\n   * is available now will not become unavailable in the future.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {TileAvailability}\n   */\n  availability: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug)\n      if (!this._ready) {\n        throw new DeveloperError(\"availability must not be called before the terrain provider is ready.\");\n      } //>>includeEnd('debug');\n\n\n      return this._availability;\n    }\n  }\n});\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n *\n * @param {Number} level The tile level for which to get the maximum geometric error.\n * @returns {Number} The maximum geometric error.\n */\n\nCesiumTerrainProvider.prototype.getLevelMaximumGeometricError = function (level) {\n  return this._levelZeroMaximumGeometricError / (1 << level);\n};\n/**\n * Determines whether data for a tile is available to be loaded.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {Boolean} Undefined if not supported or availability is unknown, otherwise true or false.\n */\n\n\nCesiumTerrainProvider.prototype.getTileDataAvailable = function (x, y, level) {\n  if (!defined(this._availability)) {\n    return undefined;\n  }\n\n  if (level > this._availability._maximumLevel) {\n    return false;\n  }\n\n  if (this._availability.isTileAvailable(level, x, y)) {\n    // If the tile is listed as available, then we are done\n    return true;\n  }\n\n  if (!this._hasMetadata) {\n    // If we don't have any layers with the metadata extension then we don't have this tile\n    return false;\n  }\n\n  var layers = this._layers;\n  var count = layers.length;\n\n  for (var i = 0; i < count; ++i) {\n    var layerResult = checkLayer(this, x, y, level, layers[i], i === 0);\n\n    if (layerResult.result) {\n      // There is a layer that may or may not have the tile\n      return undefined;\n    }\n  }\n\n  return false;\n};\n/**\n * Makes sure we load availability data for a tile\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {undefined|Promise} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\n */\n\n\nCesiumTerrainProvider.prototype.loadTileDataAvailability = function (x, y, level) {\n  if (!defined(this._availability) || level > this._availability._maximumLevel || this._availability.isTileAvailable(level, x, y) || !this._hasMetadata) {\n    // We know the tile is either available or not available so nothing to wait on\n    return undefined;\n  }\n\n  var layers = this._layers;\n  var count = layers.length;\n\n  for (var i = 0; i < count; ++i) {\n    var layerResult = checkLayer(this, x, y, level, layers[i], i === 0);\n\n    if (defined(layerResult.promise)) {\n      return layerResult.promise;\n    }\n  }\n};\n\nfunction getAvailabilityTile(layer, x, y, level) {\n  if (level === 0) {\n    return;\n  }\n\n  var availabilityLevels = layer.availabilityLevels;\n  var parentLevel = level % availabilityLevels === 0 ? level - availabilityLevels : (level / availabilityLevels | 0) * availabilityLevels;\n  var divisor = 1 << level - parentLevel;\n  var parentX = x / divisor | 0;\n  var parentY = y / divisor | 0;\n  return {\n    level: parentLevel,\n    x: parentX,\n    y: parentY\n  };\n}\n\nfunction checkLayer(provider, x, y, level, layer, topLayer) {\n  if (!defined(layer.availabilityLevels)) {\n    // It's definitely not in this layer\n    return {\n      result: false\n    };\n  }\n\n  var cacheKey;\n\n  var deleteFromCache = function () {\n    delete layer.availabilityPromiseCache[cacheKey];\n  };\n\n  var availabilityTilesLoaded = layer.availabilityTilesLoaded;\n  var availability = layer.availability;\n  var tile = getAvailabilityTile(layer, x, y, level);\n\n  while (defined(tile)) {\n    if (availability.isTileAvailable(tile.level, tile.x, tile.y) && !availabilityTilesLoaded.isTileAvailable(tile.level, tile.x, tile.y)) {\n      var requestPromise;\n\n      if (!topLayer) {\n        cacheKey = tile.level + \"-\" + tile.x + \"-\" + tile.y;\n        requestPromise = layer.availabilityPromiseCache[cacheKey];\n\n        if (!defined(requestPromise)) {\n          // For cutout terrain, if this isn't the top layer the availability tiles\n          //  may never get loaded, so request it here.\n          var request = new Request({\n            throttle: true,\n            throttleByServer: true,\n            type: RequestType.TERRAIN\n          });\n          requestPromise = requestTileGeometry(provider, tile.x, tile.y, tile.level, layer, request);\n\n          if (defined(requestPromise)) {\n            layer.availabilityPromiseCache[cacheKey] = requestPromise;\n            requestPromise.then(deleteFromCache);\n          }\n        }\n      } // The availability tile is available, but not loaded, so there\n      //  is still a chance that it may become available at some point\n\n\n      return {\n        result: true,\n        promise: requestPromise\n      };\n    }\n\n    tile = getAvailabilityTile(layer, tile.x, tile.y, tile.level);\n  }\n\n  return {\n    result: false\n  };\n} // Used for testing\n\n\nCesiumTerrainProvider._getAvailabilityTile = getAvailabilityTile;\nexport default CesiumTerrainProvider;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/CesiumTerrainProvider.js"],"names":["when","AttributeCompression","BoundingSphere","Cartesian3","Credit","defaultValue","defined","DeveloperError","Event","GeographicTilingScheme","WebMercatorTilingScheme","getStringFromTypedArray","HeightmapTerrainData","IndexDatatype","OrientedBoundingBox","QuantizedMeshTerrainData","Request","RequestType","Resource","RuntimeError","TerrainProvider","TileAvailability","TileProviderError","LayerInformation","layer","resource","version","isHeightmap","tileUrlTemplates","availability","hasVertexNormals","hasWaterMask","hasMetadata","availabilityLevels","availabilityTilesLoaded","littleEndianExtensionSize","availabilityPromiseCache","CesiumTerrainProvider","options","url","_heightmapWidth","_heightmapStructure","undefined","_hasWaterMask","_hasVertexNormals","_ellipsoid","ellipsoid","_requestVertexNormals","requestVertexNormals","_requestWaterMask","requestWaterMask","_requestMetadata","requestMetadata","_errorEvent","credit","_credit","_availability","deferred","defer","_ready","_readyPromise","_tileCredits","that","lastResource","layerJsonResource","metadataError","layers","_layers","attribution","overallAvailability","overallMaxZoom","then","createIfNeeded","appendForwardSlash","getDerivedResource","credits","requestLayerJson","otherwise","e","reject","parseMetadataSuccess","data","message","format","handleError","tiles","length","heightScale","heightOffset","elementsPerHeight","stride","elementMultiplier","isBigEndian","lowestEncodedHeight","highestEncodedHeight","indexOf","maxZoom","maxzoom","Math","max","projection","_tilingScheme","numberOfLevelZeroTilesX","numberOfLevelZeroTilesY","_levelZeroMaximumGeometricError","getEstimatedLevelZeroGeometricErrorForAHeightmap","getNumberOfXTilesAtLevel","scheme","_scheme","extensions","metadataAvailability","availableTiles","available","level","rangesAtLevel","yTiles","getNumberOfYTilesAtLevel","rangeIndex","range","yStart","endY","yEnd","startY","push","startX","endX","addAvailableTileRange","_hasMetadata","parentUrl","console","log","resolve","parentMetadata","fetchJson","parseMetadataFailure","metadataSuccess","levelRanges","i","layerJsonCredit","metadataFailure","statusCode","tilejson","QuantizedMeshExtensionIds","OCT_VERTEX_NORMALS","WATER_MASK","METADATA","getRequestHeader","extensionsList","Accept","join","createHeightmapTerrainData","provider","buffer","x","y","heightBuffer","Uint16Array","childTileMask","Uint8Array","byteLength","waterMask","width","height","structure","createQuantizedMeshTerrainData","pos","cartesian3Elements","boundingSphereElements","cartesian3Length","Float64Array","BYTES_PER_ELEMENT","boundingSphereLength","encodedVertexElements","encodedVertexLength","triangleElements","bytesPerIndex","triangleLength","view","DataView","center","getFloat64","minimumHeight","getFloat32","Float32Array","maximumHeight","boundingSphere","horizonOcclusionPoint","vertexCount","getUint32","Uint32Array","encodedVertexBuffer","uBuffer","subarray","vBuffer","zigZagDeltaDecode","triangleCount","indices","createTypedArrayFromArrayBuffer","highest","code","westVertexCount","westIndices","southVertexCount","southIndices","eastVertexCount","eastIndices","northVertexCount","northIndices","encodedNormalBuffer","waterMaskBuffer","extensionId","getUint8","extensionLength","stringLength","jsonString","metadata","JSON","parse","offset","availableLevel","skirtHeight","getLevelMaximumGeometricError","rectangle","tileXYToRectangle","orientedBoundingBox","fromRectangle","quantizedVertices","encodedNormals","westSkirtHeight","southSkirtHeight","eastSkirtHeight","northSkirtHeight","computeChildMaskForTile","prototype","requestTileGeometry","request","layerToUse","layerCount","isTileAvailable","urlTemplates","terrainY","extensionList","headers","query","_ionEndpoint","externalType","promise","templateValues","z","queryParameters","fetchArrayBuffer","Object","defineProperties","errorEvent","get","tilingScheme","ready","readyPromise","getTileDataAvailable","_maximumLevel","count","layerResult","checkLayer","result","loadTileDataAvailability","getAvailabilityTile","parentLevel","divisor","parentX","parentY","topLayer","cacheKey","deleteFromCache","tile","requestPromise","throttle","throttleByServer","type","TERRAIN","_getAvailabilityTile"],"mappings":"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","sourcesContent":["import when from \"../ThirdParty/when.js\";\nimport AttributeCompression from \"./AttributeCompression.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Credit from \"./Credit.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Event from \"./Event.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport WebMercatorTilingScheme from \"./WebMercatorTilingScheme.js\";\nimport getStringFromTypedArray from \"./getStringFromTypedArray.js\";\nimport HeightmapTerrainData from \"./HeightmapTerrainData.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport QuantizedMeshTerrainData from \"./QuantizedMeshTerrainData.js\";\nimport Request from \"./Request.js\";\nimport RequestType from \"./RequestType.js\";\nimport Resource from \"./Resource.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nimport TerrainProvider from \"./TerrainProvider.js\";\nimport TileAvailability from \"./TileAvailability.js\";\nimport TileProviderError from \"./TileProviderError.js\";\n\nfunction LayerInformation(layer) {\n  this.resource = layer.resource;\n  this.version = layer.version;\n  this.isHeightmap = layer.isHeightmap;\n  this.tileUrlTemplates = layer.tileUrlTemplates;\n  this.availability = layer.availability;\n  this.hasVertexNormals = layer.hasVertexNormals;\n  this.hasWaterMask = layer.hasWaterMask;\n  this.hasMetadata = layer.hasMetadata;\n  this.availabilityLevels = layer.availabilityLevels;\n  this.availabilityTilesLoaded = layer.availabilityTilesLoaded;\n  this.littleEndianExtensionSize = layer.littleEndianExtensionSize;\n  this.availabilityTilesLoaded = layer.availabilityTilesLoaded;\n  this.availabilityPromiseCache = {};\n}\n\n/**\n * A {@link TerrainProvider} that accesses terrain data in a Cesium terrain format.\n *\n * @alias CesiumTerrainProvider\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource|String|Promise<Resource>|Promise<String>} options.url The URL of the Cesium terrain server.\n * @param {Boolean} [options.requestVertexNormals=false] Flag that indicates if the client should request additional lighting information from the server, in the form of per vertex normals if available.\n * @param {Boolean} [options.requestWaterMask=false] Flag that indicates if the client should request per tile water masks from the server,  if available.\n * @param {Boolean} [options.requestMetadata=true] Flag that indicates if the client should request per tile metadata from the server, if available.\n * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If not specified, the WGS84 ellipsoid is used.\n * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.\n *\n *\n * @example\n * // Create Arctic DEM terrain with normals.\n * var viewer = new Cesium.Viewer('cesiumContainer', {\n *     terrainProvider : new Cesium.CesiumTerrainProvider({\n *         url : Cesium.IonResource.fromAssetId(3956),\n *         requestVertexNormals : true\n *     })\n * });\n *\n * @see createWorldTerrain\n * @see TerrainProvider\n */\nfunction CesiumTerrainProvider(options) {\n  //>>includeStart('debug', pragmas.debug)\n  if (!defined(options) || !defined(options.url)) {\n    throw new DeveloperError(\"options.url is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._heightmapWidth = 65;\n  this._heightmapStructure = undefined;\n  this._hasWaterMask = false;\n  this._hasVertexNormals = false;\n  this._ellipsoid = options.ellipsoid;\n\n  /**\n   * Boolean flag that indicates if the client should request vertex normals from the server.\n   * @type {Boolean}\n   * @default false\n   * @private\n   */\n  this._requestVertexNormals = defaultValue(\n    options.requestVertexNormals,\n    false\n  );\n\n  /**\n   * Boolean flag that indicates if the client should request tile watermasks from the server.\n   * @type {Boolean}\n   * @default false\n   * @private\n   */\n  this._requestWaterMask = defaultValue(options.requestWaterMask, false);\n\n  /**\n   * Boolean flag that indicates if the client should request tile metadata from the server.\n   * @type {Boolean}\n   * @default true\n   * @private\n   */\n  this._requestMetadata = defaultValue(options.requestMetadata, true);\n\n  this._errorEvent = new Event();\n\n  var credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  this._credit = credit;\n\n  this._availability = undefined;\n\n  var deferred = when.defer();\n  this._ready = false;\n  this._readyPromise = deferred;\n  this._tileCredits = undefined;\n\n  var that = this;\n  var lastResource;\n  var layerJsonResource;\n  var metadataError;\n\n  var layers = (this._layers = []);\n  var attribution = \"\";\n  var overallAvailability = [];\n  var overallMaxZoom = 0;\n  when(options.url)\n    .then(function (url) {\n      var resource = Resource.createIfNeeded(url);\n      resource.appendForwardSlash();\n      lastResource = resource;\n      layerJsonResource = lastResource.getDerivedResource({\n        url: \"layer.json\",\n      });\n\n      // ion resources have a credits property we can use for additional attribution.\n      that._tileCredits = resource.credits;\n\n      requestLayerJson();\n    })\n    .otherwise(function (e) {\n      deferred.reject(e);\n    });\n\n  function parseMetadataSuccess(data) {\n    var message;\n\n    if (!data.format) {\n      message = \"The tile format is not specified in the layer.json file.\";\n      metadataError = TileProviderError.handleError(\n        metadataError,\n        that,\n        that._errorEvent,\n        message,\n        undefined,\n        undefined,\n        undefined,\n        requestLayerJson\n      );\n      return;\n    }\n\n    if (!data.tiles || data.tiles.length === 0) {\n      message = \"The layer.json file does not specify any tile URL templates.\";\n      metadataError = TileProviderError.handleError(\n        metadataError,\n        that,\n        that._errorEvent,\n        message,\n        undefined,\n        undefined,\n        undefined,\n        requestLayerJson\n      );\n      return;\n    }\n\n    var hasVertexNormals = false;\n    var hasWaterMask = false;\n    var hasMetadata = false;\n    var littleEndianExtensionSize = true;\n    var isHeightmap = false;\n    if (data.format === \"heightmap-1.0\") {\n      isHeightmap = true;\n      if (!defined(that._heightmapStructure)) {\n        that._heightmapStructure = {\n          heightScale: 1.0 / 5.0,\n          heightOffset: -1000.0,\n          elementsPerHeight: 1,\n          stride: 1,\n          elementMultiplier: 256.0,\n          isBigEndian: false,\n          lowestEncodedHeight: 0,\n          highestEncodedHeight: 256 * 256 - 1,\n        };\n      }\n      hasWaterMask = true;\n      that._requestWaterMask = true;\n    } else if (data.format.indexOf(\"quantized-mesh-1.\") !== 0) {\n      message =\n        'The tile format \"' + data.format + '\" is invalid or not supported.';\n      metadataError = TileProviderError.handleError(\n        metadataError,\n        that,\n        that._errorEvent,\n        message,\n        undefined,\n        undefined,\n        undefined,\n        requestLayerJson\n      );\n      return;\n    }\n\n    var tileUrlTemplates = data.tiles;\n\n    var maxZoom = data.maxzoom;\n    overallMaxZoom = Math.max(overallMaxZoom, maxZoom);\n    // Keeps track of which of the availablity containing tiles have been loaded\n\n    if (!data.projection || data.projection === \"EPSG:4326\") {\n      that._tilingScheme = new GeographicTilingScheme({\n        numberOfLevelZeroTilesX: 2,\n        numberOfLevelZeroTilesY: 1,\n        ellipsoid: that._ellipsoid,\n      });\n    } else if (data.projection === \"EPSG:3857\") {\n      that._tilingScheme = new WebMercatorTilingScheme({\n        numberOfLevelZeroTilesX: 1,\n        numberOfLevelZeroTilesY: 1,\n        ellipsoid: that._ellipsoid,\n      });\n    } else {\n      message =\n        'The projection \"' + data.projection + '\" is invalid or not supported.';\n      metadataError = TileProviderError.handleError(\n        metadataError,\n        that,\n        that._errorEvent,\n        message,\n        undefined,\n        undefined,\n        undefined,\n        requestLayerJson\n      );\n      return;\n    }\n\n    that._levelZeroMaximumGeometricError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n      that._tilingScheme.ellipsoid,\n      that._heightmapWidth,\n      that._tilingScheme.getNumberOfXTilesAtLevel(0)\n    );\n    if (!data.scheme || data.scheme === \"tms\" || data.scheme === \"slippyMap\") {\n      that._scheme = data.scheme;\n    } else {\n      message = 'The scheme \"' + data.scheme + '\" is invalid or not supported.';\n      metadataError = TileProviderError.handleError(\n        metadataError,\n        that,\n        that._errorEvent,\n        message,\n        undefined,\n        undefined,\n        undefined,\n        requestLayerJson\n      );\n      return;\n    }\n\n    var availabilityTilesLoaded;\n\n    // The vertex normals defined in the 'octvertexnormals' extension is identical to the original\n    // contents of the original 'vertexnormals' extension.  'vertexnormals' extension is now\n    // deprecated, as the extensionLength for this extension was incorrectly using big endian.\n    // We maintain backwards compatibility with the legacy 'vertexnormal' implementation\n    // by setting the _littleEndianExtensionSize to false. Always prefer 'octvertexnormals'\n    // over 'vertexnormals' if both extensions are supported by the server.\n    if (\n      defined(data.extensions) &&\n      data.extensions.indexOf(\"octvertexnormals\") !== -1\n    ) {\n      hasVertexNormals = true;\n    } else if (\n      defined(data.extensions) &&\n      data.extensions.indexOf(\"vertexnormals\") !== -1\n    ) {\n      hasVertexNormals = true;\n      littleEndianExtensionSize = false;\n    }\n    if (\n      defined(data.extensions) &&\n      data.extensions.indexOf(\"watermask\") !== -1\n    ) {\n      hasWaterMask = true;\n    }\n    if (\n      defined(data.extensions) &&\n      data.extensions.indexOf(\"metadata\") !== -1\n    ) {\n      hasMetadata = true;\n    }\n\n    var availabilityLevels = data.metadataAvailability;\n    var availableTiles = data.available;\n    var availability;\n    if (defined(availableTiles) && !defined(availabilityLevels)) {\n      availability = new TileAvailability(\n        that._tilingScheme,\n        availableTiles.length\n      );\n      for (var level = 0; level < availableTiles.length; ++level) {\n        var rangesAtLevel = availableTiles[level];\n        var yTiles = that._tilingScheme.getNumberOfYTilesAtLevel(level);\n        if (!defined(overallAvailability[level])) {\n          overallAvailability[level] = [];\n        }\n\n        for (\n          var rangeIndex = 0;\n          rangeIndex < rangesAtLevel.length;\n          ++rangeIndex\n        ) {\n          var range = rangesAtLevel[rangeIndex];\n          var yStart = yTiles - range.endY - 1;\n          var yEnd = yTiles - range.startY - 1;\n          overallAvailability[level].push([\n            range.startX,\n            yStart,\n            range.endX,\n            yEnd,\n          ]);\n          availability.addAvailableTileRange(\n            level,\n            range.startX,\n            yStart,\n            range.endX,\n            yEnd\n          );\n        }\n      }\n    } else if (defined(availabilityLevels)) {\n      availabilityTilesLoaded = new TileAvailability(\n        that._tilingScheme,\n        maxZoom\n      );\n      availability = new TileAvailability(that._tilingScheme, maxZoom);\n      overallAvailability[0] = [[0, 0, 1, 0]];\n      availability.addAvailableTileRange(0, 0, 0, 1, 0);\n    }\n\n    that._hasWaterMask = that._hasWaterMask || hasWaterMask;\n    that._hasVertexNormals = that._hasVertexNormals || hasVertexNormals;\n    that._hasMetadata = that._hasMetadata || hasMetadata;\n    if (defined(data.attribution)) {\n      if (attribution.length > 0) {\n        attribution += \" \";\n      }\n      attribution += data.attribution;\n    }\n\n    layers.push(\n      new LayerInformation({\n        resource: lastResource,\n        version: data.version,\n        isHeightmap: isHeightmap,\n        tileUrlTemplates: tileUrlTemplates,\n        availability: availability,\n        hasVertexNormals: hasVertexNormals,\n        hasWaterMask: hasWaterMask,\n        hasMetadata: hasMetadata,\n        availabilityLevels: availabilityLevels,\n        availabilityTilesLoaded: availabilityTilesLoaded,\n        littleEndianExtensionSize: littleEndianExtensionSize,\n      })\n    );\n\n    var parentUrl = data.parentUrl;\n    if (defined(parentUrl)) {\n      if (!defined(availability)) {\n        console.log(\n          \"A layer.json can't have a parentUrl if it does't have an available array.\"\n        );\n        return when.resolve();\n      }\n      lastResource = lastResource.getDerivedResource({\n        url: parentUrl,\n      });\n      lastResource.appendForwardSlash(); // Terrain always expects a directory\n      layerJsonResource = lastResource.getDerivedResource({\n        url: \"layer.json\",\n      });\n      var parentMetadata = layerJsonResource.fetchJson();\n      return when(parentMetadata, parseMetadataSuccess, parseMetadataFailure);\n    }\n\n    return when.resolve();\n  }\n\n  function parseMetadataFailure(data) {\n    var message =\n      \"An error occurred while accessing \" + layerJsonResource.url + \".\";\n    metadataError = TileProviderError.handleError(\n      metadataError,\n      that,\n      that._errorEvent,\n      message,\n      undefined,\n      undefined,\n      undefined,\n      requestLayerJson\n    );\n  }\n\n  function metadataSuccess(data) {\n    parseMetadataSuccess(data).then(function () {\n      if (defined(metadataError)) {\n        return;\n      }\n\n      var length = overallAvailability.length;\n      if (length > 0) {\n        var availability = (that._availability = new TileAvailability(\n          that._tilingScheme,\n          overallMaxZoom\n        ));\n        for (var level = 0; level < length; ++level) {\n          var levelRanges = overallAvailability[level];\n          for (var i = 0; i < levelRanges.length; ++i) {\n            var range = levelRanges[i];\n            availability.addAvailableTileRange(\n              level,\n              range[0],\n              range[1],\n              range[2],\n              range[3]\n            );\n          }\n        }\n      }\n\n      if (attribution.length > 0) {\n        var layerJsonCredit = new Credit(attribution);\n\n        if (defined(that._tileCredits)) {\n          that._tileCredits.push(layerJsonCredit);\n        } else {\n          that._tileCredits = [layerJsonCredit];\n        }\n      }\n\n      that._ready = true;\n      that._readyPromise.resolve(true);\n    });\n  }\n\n  function metadataFailure(data) {\n    // If the metadata is not found, assume this is a pre-metadata heightmap tileset.\n    if (defined(data) && data.statusCode === 404) {\n      metadataSuccess({\n        tilejson: \"2.1.0\",\n        format: \"heightmap-1.0\",\n        version: \"1.0.0\",\n        scheme: \"tms\",\n        tiles: [\"{z}/{x}/{y}.terrain?v={version}\"],\n      });\n      return;\n    }\n    parseMetadataFailure(data);\n  }\n\n  function requestLayerJson() {\n    when(layerJsonResource.fetchJson())\n      .then(metadataSuccess)\n      .otherwise(metadataFailure);\n  }\n}\n\n/**\n * When using the Quantized-Mesh format, a tile may be returned that includes additional extensions, such as PerVertexNormals, watermask, etc.\n * This enumeration defines the unique identifiers for each type of extension data that has been appended to the standard mesh data.\n *\n * @exports QuantizedMeshExtensionIds\n * @see CesiumTerrainProvider\n * @private\n */\nvar QuantizedMeshExtensionIds = {\n  /**\n   * Oct-Encoded Per-Vertex Normals are included as an extension to the tile mesh\n   *\n   * @type {Number}\n   * @constant\n   * @default 1\n   */\n  OCT_VERTEX_NORMALS: 1,\n  /**\n   * A watermask is included as an extension to the tile mesh\n   *\n   * @type {Number}\n   * @constant\n   * @default 2\n   */\n  WATER_MASK: 2,\n  /**\n   * A json object contain metadata about the tile\n   *\n   * @type {Number}\n   * @constant\n   * @default 4\n   */\n  METADATA: 4,\n};\n\nfunction getRequestHeader(extensionsList) {\n  if (!defined(extensionsList) || extensionsList.length === 0) {\n    return {\n      Accept:\n        \"application/vnd.quantized-mesh,application/octet-stream;q=0.9,*/*;q=0.01\",\n    };\n  }\n  var extensions = extensionsList.join(\"-\");\n  return {\n    Accept:\n      \"application/vnd.quantized-mesh;extensions=\" +\n      extensions +\n      \",application/octet-stream;q=0.9,*/*;q=0.01\",\n  };\n}\n\nfunction createHeightmapTerrainData(provider, buffer, level, x, y) {\n  var heightBuffer = new Uint16Array(\n    buffer,\n    0,\n    provider._heightmapWidth * provider._heightmapWidth\n  );\n  return new HeightmapTerrainData({\n    buffer: heightBuffer,\n    childTileMask: new Uint8Array(buffer, heightBuffer.byteLength, 1)[0],\n    waterMask: new Uint8Array(\n      buffer,\n      heightBuffer.byteLength + 1,\n      buffer.byteLength - heightBuffer.byteLength - 1\n    ),\n    width: provider._heightmapWidth,\n    height: provider._heightmapWidth,\n    structure: provider._heightmapStructure,\n    credits: provider._tileCredits,\n  });\n}\n\nfunction createQuantizedMeshTerrainData(provider, buffer, level, x, y, layer) {\n  var littleEndianExtensionSize = layer.littleEndianExtensionSize;\n  var pos = 0;\n  var cartesian3Elements = 3;\n  var boundingSphereElements = cartesian3Elements + 1;\n  var cartesian3Length = Float64Array.BYTES_PER_ELEMENT * cartesian3Elements;\n  var boundingSphereLength =\n    Float64Array.BYTES_PER_ELEMENT * boundingSphereElements;\n  var encodedVertexElements = 3;\n  var encodedVertexLength =\n    Uint16Array.BYTES_PER_ELEMENT * encodedVertexElements;\n  var triangleElements = 3;\n  var bytesPerIndex = Uint16Array.BYTES_PER_ELEMENT;\n  var triangleLength = bytesPerIndex * triangleElements;\n\n  var view = new DataView(buffer);\n  var center = new Cartesian3(\n    view.getFloat64(pos, true),\n    view.getFloat64(pos + 8, true),\n    view.getFloat64(pos + 16, true)\n  );\n  pos += cartesian3Length;\n\n  var minimumHeight = view.getFloat32(pos, true);\n  pos += Float32Array.BYTES_PER_ELEMENT;\n  var maximumHeight = view.getFloat32(pos, true);\n  pos += Float32Array.BYTES_PER_ELEMENT;\n\n  var boundingSphere = new BoundingSphere(\n    new Cartesian3(\n      view.getFloat64(pos, true),\n      view.getFloat64(pos + 8, true),\n      view.getFloat64(pos + 16, true)\n    ),\n    view.getFloat64(pos + cartesian3Length, true)\n  );\n  pos += boundingSphereLength;\n\n  var horizonOcclusionPoint = new Cartesian3(\n    view.getFloat64(pos, true),\n    view.getFloat64(pos + 8, true),\n    view.getFloat64(pos + 16, true)\n  );\n  pos += cartesian3Length;\n\n  var vertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  var encodedVertexBuffer = new Uint16Array(buffer, pos, vertexCount * 3);\n  pos += vertexCount * encodedVertexLength;\n\n  if (vertexCount > 64 * 1024) {\n    // More than 64k vertices, so indices are 32-bit.\n    bytesPerIndex = Uint32Array.BYTES_PER_ELEMENT;\n    triangleLength = bytesPerIndex * triangleElements;\n  }\n\n  // Decode the vertex buffer.\n  var uBuffer = encodedVertexBuffer.subarray(0, vertexCount);\n  var vBuffer = encodedVertexBuffer.subarray(vertexCount, 2 * vertexCount);\n  var heightBuffer = encodedVertexBuffer.subarray(\n    vertexCount * 2,\n    3 * vertexCount\n  );\n\n  AttributeCompression.zigZagDeltaDecode(uBuffer, vBuffer, heightBuffer);\n\n  // skip over any additional padding that was added for 2/4 byte alignment\n  if (pos % bytesPerIndex !== 0) {\n    pos += bytesPerIndex - (pos % bytesPerIndex);\n  }\n\n  var triangleCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  var indices = IndexDatatype.createTypedArrayFromArrayBuffer(\n    vertexCount,\n    buffer,\n    pos,\n    triangleCount * triangleElements\n  );\n  pos += triangleCount * triangleLength;\n\n  // High water mark decoding based on decompressIndices_ in webgl-loader's loader.js.\n  // https://code.google.com/p/webgl-loader/source/browse/trunk/samples/loader.js?r=99#55\n  // Copyright 2012 Google Inc., Apache 2.0 license.\n  var highest = 0;\n  var length = indices.length;\n  for (var i = 0; i < length; ++i) {\n    var code = indices[i];\n    indices[i] = highest - code;\n    if (code === 0) {\n      ++highest;\n    }\n  }\n\n  var westVertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  var westIndices = IndexDatatype.createTypedArrayFromArrayBuffer(\n    vertexCount,\n    buffer,\n    pos,\n    westVertexCount\n  );\n  pos += westVertexCount * bytesPerIndex;\n\n  var southVertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  var southIndices = IndexDatatype.createTypedArrayFromArrayBuffer(\n    vertexCount,\n    buffer,\n    pos,\n    southVertexCount\n  );\n  pos += southVertexCount * bytesPerIndex;\n\n  var eastVertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  var eastIndices = IndexDatatype.createTypedArrayFromArrayBuffer(\n    vertexCount,\n    buffer,\n    pos,\n    eastVertexCount\n  );\n  pos += eastVertexCount * bytesPerIndex;\n\n  var northVertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  var northIndices = IndexDatatype.createTypedArrayFromArrayBuffer(\n    vertexCount,\n    buffer,\n    pos,\n    northVertexCount\n  );\n  pos += northVertexCount * bytesPerIndex;\n\n  var encodedNormalBuffer;\n  var waterMaskBuffer;\n  while (pos < view.byteLength) {\n    var extensionId = view.getUint8(pos, true);\n    pos += Uint8Array.BYTES_PER_ELEMENT;\n    var extensionLength = view.getUint32(pos, littleEndianExtensionSize);\n    pos += Uint32Array.BYTES_PER_ELEMENT;\n\n    if (\n      extensionId === QuantizedMeshExtensionIds.OCT_VERTEX_NORMALS &&\n      provider._requestVertexNormals\n    ) {\n      encodedNormalBuffer = new Uint8Array(buffer, pos, vertexCount * 2);\n    } else if (\n      extensionId === QuantizedMeshExtensionIds.WATER_MASK &&\n      provider._requestWaterMask\n    ) {\n      waterMaskBuffer = new Uint8Array(buffer, pos, extensionLength);\n    } else if (\n      extensionId === QuantizedMeshExtensionIds.METADATA &&\n      provider._requestMetadata\n    ) {\n      var stringLength = view.getUint32(pos, true);\n      if (stringLength > 0) {\n        var jsonString = getStringFromTypedArray(\n          new Uint8Array(buffer),\n          pos + Uint32Array.BYTES_PER_ELEMENT,\n          stringLength\n        );\n        var metadata = JSON.parse(jsonString);\n        var availableTiles = metadata.available;\n        if (defined(availableTiles)) {\n          for (var offset = 0; offset < availableTiles.length; ++offset) {\n            var availableLevel = level + offset + 1;\n            var rangesAtLevel = availableTiles[offset];\n            var yTiles = provider._tilingScheme.getNumberOfYTilesAtLevel(\n              availableLevel\n            );\n\n            for (\n              var rangeIndex = 0;\n              rangeIndex < rangesAtLevel.length;\n              ++rangeIndex\n            ) {\n              var range = rangesAtLevel[rangeIndex];\n              var yStart = yTiles - range.endY - 1;\n              var yEnd = yTiles - range.startY - 1;\n              provider.availability.addAvailableTileRange(\n                availableLevel,\n                range.startX,\n                yStart,\n                range.endX,\n                yEnd\n              );\n              layer.availability.addAvailableTileRange(\n                availableLevel,\n                range.startX,\n                yStart,\n                range.endX,\n                yEnd\n              );\n            }\n          }\n        }\n      }\n      layer.availabilityTilesLoaded.addAvailableTileRange(level, x, y, x, y);\n    }\n    pos += extensionLength;\n  }\n\n  var skirtHeight = provider.getLevelMaximumGeometricError(level) * 5.0;\n\n  // The skirt is not included in the OBB computation. If this ever\n  // causes any rendering artifacts (cracks), they are expected to be\n  // minor and in the corners of the screen. It's possible that this\n  // might need to be changed - just change to `minimumHeight - skirtHeight`\n  // A similar change might also be needed in `upsampleQuantizedTerrainMesh.js`.\n  var rectangle = provider._tilingScheme.tileXYToRectangle(x, y, level);\n  var orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n    rectangle,\n    minimumHeight,\n    maximumHeight,\n    provider._tilingScheme.ellipsoid\n  );\n\n  return new QuantizedMeshTerrainData({\n    center: center,\n    minimumHeight: minimumHeight,\n    maximumHeight: maximumHeight,\n    boundingSphere: boundingSphere,\n    orientedBoundingBox: orientedBoundingBox,\n    horizonOcclusionPoint: horizonOcclusionPoint,\n    quantizedVertices: encodedVertexBuffer,\n    encodedNormals: encodedNormalBuffer,\n    indices: indices,\n    westIndices: westIndices,\n    southIndices: southIndices,\n    eastIndices: eastIndices,\n    northIndices: northIndices,\n    westSkirtHeight: skirtHeight,\n    southSkirtHeight: skirtHeight,\n    eastSkirtHeight: skirtHeight,\n    northSkirtHeight: skirtHeight,\n    childTileMask: provider.availability.computeChildMaskForTile(level, x, y),\n    waterMask: waterMaskBuffer,\n    credits: provider._tileCredits,\n  });\n}\n\n/**\n * Requests the geometry for a given tile.  This function should not be called before\n * {@link CesiumTerrainProvider#ready} returns true.  The result must include terrain data and\n * may optionally include a water mask and an indication of which child tiles are available.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n *\n * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n *\n * @exception {DeveloperError} This function must not be called before {@link CesiumTerrainProvider#ready}\n *            returns true.\n */\nCesiumTerrainProvider.prototype.requestTileGeometry = function (\n  x,\n  y,\n  level,\n  request\n) {\n  //>>includeStart('debug', pragmas.debug)\n  if (!this._ready) {\n    throw new DeveloperError(\n      \"requestTileGeometry must not be called before the terrain provider is ready.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var layers = this._layers;\n  var layerToUse;\n  var layerCount = layers.length;\n\n  if (layerCount === 1) {\n    // Optimized path for single layers\n    layerToUse = layers[0];\n  } else {\n    for (var i = 0; i < layerCount; ++i) {\n      var layer = layers[i];\n      if (\n        !defined(layer.availability) ||\n        layer.availability.isTileAvailable(level, x, y)\n      ) {\n        layerToUse = layer;\n        break;\n      }\n    }\n  }\n\n  return requestTileGeometry(this, x, y, level, layerToUse, request);\n};\n\nfunction requestTileGeometry(provider, x, y, level, layerToUse, request) {\n  if (!defined(layerToUse)) {\n    return when.reject(new RuntimeError(\"Terrain tile doesn't exist\"));\n  }\n\n  var urlTemplates = layerToUse.tileUrlTemplates;\n  if (urlTemplates.length === 0) {\n    return undefined;\n  }\n\n  // The TileMapService scheme counts from the bottom left\n  var terrainY;\n  if (!provider._scheme || provider._scheme === \"tms\") {\n    var yTiles = provider._tilingScheme.getNumberOfYTilesAtLevel(level);\n    terrainY = yTiles - y - 1;\n  } else {\n    terrainY = y;\n  }\n\n  var extensionList = [];\n  if (provider._requestVertexNormals && layerToUse.hasVertexNormals) {\n    extensionList.push(\n      layerToUse.littleEndianExtensionSize\n        ? \"octvertexnormals\"\n        : \"vertexnormals\"\n    );\n  }\n  if (provider._requestWaterMask && layerToUse.hasWaterMask) {\n    extensionList.push(\"watermask\");\n  }\n  if (provider._requestMetadata && layerToUse.hasMetadata) {\n    extensionList.push(\"metadata\");\n  }\n\n  var headers;\n  var query;\n  var url = urlTemplates[(x + terrainY + level) % urlTemplates.length];\n\n  var resource = layerToUse.resource;\n  if (\n    defined(resource._ionEndpoint) &&\n    !defined(resource._ionEndpoint.externalType)\n  ) {\n    // ion uses query paremeters to request extensions\n    if (extensionList.length !== 0) {\n      query = { extensions: extensionList.join(\"-\") };\n    }\n    headers = getRequestHeader(undefined);\n  } else {\n    //All other terrain servers\n    headers = getRequestHeader(extensionList);\n  }\n\n  var promise = resource\n    .getDerivedResource({\n      url: url,\n      templateValues: {\n        version: layerToUse.version,\n        z: level,\n        x: x,\n        y: terrainY,\n      },\n      queryParameters: query,\n      headers: headers,\n      request: request,\n    })\n    .fetchArrayBuffer();\n\n  if (!defined(promise)) {\n    return undefined;\n  }\n\n  return promise.then(function (buffer) {\n    if (defined(provider._heightmapStructure)) {\n      return createHeightmapTerrainData(provider, buffer, level, x, y);\n    }\n    return createQuantizedMeshTerrainData(\n      provider,\n      buffer,\n      level,\n      x,\n      y,\n      layerToUse\n    );\n  });\n}\n\nObject.defineProperties(CesiumTerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.  This function should not be called before {@link CesiumTerrainProvider#ready} returns true.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Credit}\n   */\n  credit: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug)\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"credit must not be called before the terrain provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._credit;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.  This function should\n   * not be called before {@link CesiumTerrainProvider#ready} returns true.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {GeographicTilingScheme}\n   */\n  tilingScheme: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug)\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tilingScheme must not be called before the terrain provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Boolean}\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.  This function should not be\n   * called before {@link CesiumTerrainProvider#ready} returns true.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Boolean}\n   * @exception {DeveloperError} This property must not be called before {@link CesiumTerrainProvider#ready}\n   */\n  hasWaterMask: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug)\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"hasWaterMask must not be called before the terrain provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._hasWaterMask && this._requestWaterMask;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * This function should not be called before {@link CesiumTerrainProvider#ready} returns true.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Boolean}\n   * @exception {DeveloperError} This property must not be called before {@link CesiumTerrainProvider#ready}\n   */\n  hasVertexNormals: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug)\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"hasVertexNormals must not be called before the terrain provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      // returns true if we can request vertex normals from the server\n      return this._hasVertexNormals && this._requestVertexNormals;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include metadata.\n   * This function should not be called before {@link CesiumTerrainProvider#ready} returns true.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Boolean}\n   * @exception {DeveloperError} This property must not be called before {@link CesiumTerrainProvider#ready}\n   */\n  hasMetadata: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug)\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"hasMetadata must not be called before the terrain provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      // returns true if we can request metadata from the server\n      return this._hasMetadata && this._requestMetadata;\n    },\n  },\n\n  /**\n   * Boolean flag that indicates if the client should request vertex normals from the server.\n   * Vertex normals data is appended to the standard tile mesh data only if the client requests the vertex normals and\n   * if the server provides vertex normals.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Boolean}\n   */\n  requestVertexNormals: {\n    get: function () {\n      return this._requestVertexNormals;\n    },\n  },\n\n  /**\n   * Boolean flag that indicates if the client should request a watermask from the server.\n   * Watermask data is appended to the standard tile mesh data only if the client requests the watermask and\n   * if the server provides a watermask.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Boolean}\n   */\n  requestWaterMask: {\n    get: function () {\n      return this._requestWaterMask;\n    },\n  },\n\n  /**\n   * Boolean flag that indicates if the client should request metadata from the server.\n   * Metadata is appended to the standard tile mesh data only if the client requests the metadata and\n   * if the server provides a metadata.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Boolean}\n   */\n  requestMetadata: {\n    get: function () {\n      return this._requestMetadata;\n    },\n  },\n\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles.  This function should not be called before\n   * {@link CesiumTerrainProvider#ready} returns true.  This property may be undefined if availability\n   * information is not available. Note that this reflects tiles that are known to be available currently.\n   * Additional tiles may be discovered to be available in the future, e.g. if availability information\n   * exists deeper in the tree rather than it all being discoverable at the root. However, a tile that\n   * is available now will not become unavailable in the future.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {TileAvailability}\n   */\n  availability: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug)\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"availability must not be called before the terrain provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._availability;\n    },\n  },\n});\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n *\n * @param {Number} level The tile level for which to get the maximum geometric error.\n * @returns {Number} The maximum geometric error.\n */\nCesiumTerrainProvider.prototype.getLevelMaximumGeometricError = function (\n  level\n) {\n  return this._levelZeroMaximumGeometricError / (1 << level);\n};\n\n/**\n * Determines whether data for a tile is available to be loaded.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {Boolean} Undefined if not supported or availability is unknown, otherwise true or false.\n */\nCesiumTerrainProvider.prototype.getTileDataAvailable = function (x, y, level) {\n  if (!defined(this._availability)) {\n    return undefined;\n  }\n  if (level > this._availability._maximumLevel) {\n    return false;\n  }\n\n  if (this._availability.isTileAvailable(level, x, y)) {\n    // If the tile is listed as available, then we are done\n    return true;\n  }\n  if (!this._hasMetadata) {\n    // If we don't have any layers with the metadata extension then we don't have this tile\n    return false;\n  }\n\n  var layers = this._layers;\n  var count = layers.length;\n  for (var i = 0; i < count; ++i) {\n    var layerResult = checkLayer(this, x, y, level, layers[i], i === 0);\n    if (layerResult.result) {\n      // There is a layer that may or may not have the tile\n      return undefined;\n    }\n  }\n\n  return false;\n};\n\n/**\n * Makes sure we load availability data for a tile\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {undefined|Promise} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\n */\nCesiumTerrainProvider.prototype.loadTileDataAvailability = function (\n  x,\n  y,\n  level\n) {\n  if (\n    !defined(this._availability) ||\n    level > this._availability._maximumLevel ||\n    this._availability.isTileAvailable(level, x, y) ||\n    !this._hasMetadata\n  ) {\n    // We know the tile is either available or not available so nothing to wait on\n    return undefined;\n  }\n\n  var layers = this._layers;\n  var count = layers.length;\n  for (var i = 0; i < count; ++i) {\n    var layerResult = checkLayer(this, x, y, level, layers[i], i === 0);\n    if (defined(layerResult.promise)) {\n      return layerResult.promise;\n    }\n  }\n};\n\nfunction getAvailabilityTile(layer, x, y, level) {\n  if (level === 0) {\n    return;\n  }\n\n  var availabilityLevels = layer.availabilityLevels;\n  var parentLevel =\n    level % availabilityLevels === 0\n      ? level - availabilityLevels\n      : ((level / availabilityLevels) | 0) * availabilityLevels;\n  var divisor = 1 << (level - parentLevel);\n  var parentX = (x / divisor) | 0;\n  var parentY = (y / divisor) | 0;\n\n  return {\n    level: parentLevel,\n    x: parentX,\n    y: parentY,\n  };\n}\n\nfunction checkLayer(provider, x, y, level, layer, topLayer) {\n  if (!defined(layer.availabilityLevels)) {\n    // It's definitely not in this layer\n    return {\n      result: false,\n    };\n  }\n\n  var cacheKey;\n  var deleteFromCache = function () {\n    delete layer.availabilityPromiseCache[cacheKey];\n  };\n  var availabilityTilesLoaded = layer.availabilityTilesLoaded;\n  var availability = layer.availability;\n\n  var tile = getAvailabilityTile(layer, x, y, level);\n  while (defined(tile)) {\n    if (\n      availability.isTileAvailable(tile.level, tile.x, tile.y) &&\n      !availabilityTilesLoaded.isTileAvailable(tile.level, tile.x, tile.y)\n    ) {\n      var requestPromise;\n      if (!topLayer) {\n        cacheKey = tile.level + \"-\" + tile.x + \"-\" + tile.y;\n        requestPromise = layer.availabilityPromiseCache[cacheKey];\n        if (!defined(requestPromise)) {\n          // For cutout terrain, if this isn't the top layer the availability tiles\n          //  may never get loaded, so request it here.\n          var request = new Request({\n            throttle: true,\n            throttleByServer: true,\n            type: RequestType.TERRAIN,\n          });\n          requestPromise = requestTileGeometry(\n            provider,\n            tile.x,\n            tile.y,\n            tile.level,\n            layer,\n            request\n          );\n          if (defined(requestPromise)) {\n            layer.availabilityPromiseCache[cacheKey] = requestPromise;\n            requestPromise.then(deleteFromCache);\n          }\n        }\n      }\n\n      // The availability tile is available, but not loaded, so there\n      //  is still a chance that it may become available at some point\n      return {\n        result: true,\n        promise: requestPromise,\n      };\n    }\n\n    tile = getAvailabilityTile(layer, tile.x, tile.y, tile.level);\n  }\n\n  return {\n    result: false,\n  };\n}\n\n// Used for testing\nCesiumTerrainProvider._getAvailabilityTile = getAvailabilityTile;\nexport default CesiumTerrainProvider;\n"]},"metadata":{},"sourceType":"module"}