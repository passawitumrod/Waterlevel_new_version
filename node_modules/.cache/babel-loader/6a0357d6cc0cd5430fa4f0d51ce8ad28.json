{"ast":null,"code":"import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix2 from \"./Matrix2.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport RectangleGeometryLibrary from \"./RectangleGeometryLibrary.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nvar positionScratch = new Cartesian3();\nvar normalScratch = new Cartesian3();\nvar tangentScratch = new Cartesian3();\nvar bitangentScratch = new Cartesian3();\nvar rectangleScratch = new Rectangle();\nvar stScratch = new Cartesian2();\nvar bottomBoundingSphere = new BoundingSphere();\nvar topBoundingSphere = new BoundingSphere();\n\nfunction createAttributes(vertexFormat, attributes) {\n  var geo = new Geometry({\n    attributes: new GeometryAttributes(),\n    primitiveType: PrimitiveType.TRIANGLES\n  });\n  geo.attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: attributes.positions\n  });\n\n  if (vertexFormat.normal) {\n    geo.attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attributes.normals\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    geo.attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attributes.tangents\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    geo.attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attributes.bitangents\n    });\n  }\n\n  return geo;\n}\n\nfunction calculateAttributes(positions, vertexFormat, ellipsoid, tangentRotationMatrix) {\n  var length = positions.length;\n  var normals = vertexFormat.normal ? new Float32Array(length) : undefined;\n  var tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;\n  var bitangents = vertexFormat.bitangent ? new Float32Array(length) : undefined;\n  var attrIndex = 0;\n  var bitangent = bitangentScratch;\n  var tangent = tangentScratch;\n  var normal = normalScratch;\n\n  if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n    for (var i = 0; i < length; i += 3) {\n      var p = Cartesian3.fromArray(positions, i, positionScratch);\n      var attrIndex1 = attrIndex + 1;\n      var attrIndex2 = attrIndex + 2;\n      normal = ellipsoid.geodeticSurfaceNormal(p, normal);\n\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\n        Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\n        Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent);\n        Cartesian3.normalize(tangent, tangent);\n\n        if (vertexFormat.bitangent) {\n          Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n        }\n      }\n\n      if (vertexFormat.normal) {\n        normals[attrIndex] = normal.x;\n        normals[attrIndex1] = normal.y;\n        normals[attrIndex2] = normal.z;\n      }\n\n      if (vertexFormat.tangent) {\n        tangents[attrIndex] = tangent.x;\n        tangents[attrIndex1] = tangent.y;\n        tangents[attrIndex2] = tangent.z;\n      }\n\n      if (vertexFormat.bitangent) {\n        bitangents[attrIndex] = bitangent.x;\n        bitangents[attrIndex1] = bitangent.y;\n        bitangents[attrIndex2] = bitangent.z;\n      }\n\n      attrIndex += 3;\n    }\n  }\n\n  return createAttributes(vertexFormat, {\n    positions: positions,\n    normals: normals,\n    tangents: tangents,\n    bitangents: bitangents\n  });\n}\n\nvar v1Scratch = new Cartesian3();\nvar v2Scratch = new Cartesian3();\n\nfunction calculateAttributesWall(positions, vertexFormat, ellipsoid) {\n  var length = positions.length;\n  var normals = vertexFormat.normal ? new Float32Array(length) : undefined;\n  var tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;\n  var bitangents = vertexFormat.bitangent ? new Float32Array(length) : undefined;\n  var normalIndex = 0;\n  var tangentIndex = 0;\n  var bitangentIndex = 0;\n  var recomputeNormal = true;\n  var bitangent = bitangentScratch;\n  var tangent = tangentScratch;\n  var normal = normalScratch;\n\n  if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n    for (var i = 0; i < length; i += 6) {\n      var p = Cartesian3.fromArray(positions, i, positionScratch);\n      var p1 = Cartesian3.fromArray(positions, (i + 6) % length, v1Scratch);\n\n      if (recomputeNormal) {\n        var p2 = Cartesian3.fromArray(positions, (i + 3) % length, v2Scratch);\n        Cartesian3.subtract(p1, p, p1);\n        Cartesian3.subtract(p2, p, p2);\n        normal = Cartesian3.normalize(Cartesian3.cross(p2, p1, normal), normal);\n        recomputeNormal = false;\n      }\n\n      if (Cartesian3.equalsEpsilon(p1, p, CesiumMath.EPSILON10)) {\n        // if we've reached a corner\n        recomputeNormal = true;\n      }\n\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\n        bitangent = ellipsoid.geodeticSurfaceNormal(p, bitangent);\n\n        if (vertexFormat.tangent) {\n          tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);\n        }\n      }\n\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = normal.x;\n        normals[normalIndex++] = normal.y;\n        normals[normalIndex++] = normal.z;\n        normals[normalIndex++] = normal.x;\n        normals[normalIndex++] = normal.y;\n        normals[normalIndex++] = normal.z;\n      }\n\n      if (vertexFormat.tangent) {\n        tangents[tangentIndex++] = tangent.x;\n        tangents[tangentIndex++] = tangent.y;\n        tangents[tangentIndex++] = tangent.z;\n        tangents[tangentIndex++] = tangent.x;\n        tangents[tangentIndex++] = tangent.y;\n        tangents[tangentIndex++] = tangent.z;\n      }\n\n      if (vertexFormat.bitangent) {\n        bitangents[bitangentIndex++] = bitangent.x;\n        bitangents[bitangentIndex++] = bitangent.y;\n        bitangents[bitangentIndex++] = bitangent.z;\n        bitangents[bitangentIndex++] = bitangent.x;\n        bitangents[bitangentIndex++] = bitangent.y;\n        bitangents[bitangentIndex++] = bitangent.z;\n      }\n    }\n  }\n\n  return createAttributes(vertexFormat, {\n    positions: positions,\n    normals: normals,\n    tangents: tangents,\n    bitangents: bitangents\n  });\n}\n\nfunction constructRectangle(rectangleGeometry, computedOptions) {\n  var vertexFormat = rectangleGeometry._vertexFormat;\n  var ellipsoid = rectangleGeometry._ellipsoid;\n  var height = computedOptions.height;\n  var width = computedOptions.width;\n  var northCap = computedOptions.northCap;\n  var southCap = computedOptions.southCap;\n  var rowStart = 0;\n  var rowEnd = height;\n  var rowHeight = height;\n  var size = 0;\n\n  if (northCap) {\n    rowStart = 1;\n    rowHeight -= 1;\n    size += 1;\n  }\n\n  if (southCap) {\n    rowEnd -= 1;\n    rowHeight -= 1;\n    size += 1;\n  }\n\n  size += width * rowHeight;\n  var positions = vertexFormat.position ? new Float64Array(size * 3) : undefined;\n  var textureCoordinates = vertexFormat.st ? new Float32Array(size * 2) : undefined;\n  var posIndex = 0;\n  var stIndex = 0;\n  var position = positionScratch;\n  var st = stScratch;\n  var minX = Number.MAX_VALUE;\n  var minY = Number.MAX_VALUE;\n  var maxX = -Number.MAX_VALUE;\n  var maxY = -Number.MAX_VALUE;\n\n  for (var row = rowStart; row < rowEnd; ++row) {\n    for (var col = 0; col < width; ++col) {\n      RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, vertexFormat.st, row, col, position, st);\n      positions[posIndex++] = position.x;\n      positions[posIndex++] = position.y;\n      positions[posIndex++] = position.z;\n\n      if (vertexFormat.st) {\n        textureCoordinates[stIndex++] = st.x;\n        textureCoordinates[stIndex++] = st.y;\n        minX = Math.min(minX, st.x);\n        minY = Math.min(minY, st.y);\n        maxX = Math.max(maxX, st.x);\n        maxY = Math.max(maxY, st.y);\n      }\n    }\n  }\n\n  if (northCap) {\n    RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, vertexFormat.st, 0, 0, position, st);\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n\n    if (vertexFormat.st) {\n      textureCoordinates[stIndex++] = st.x;\n      textureCoordinates[stIndex++] = st.y;\n      minX = st.x;\n      minY = st.y;\n      maxX = st.x;\n      maxY = st.y;\n    }\n  }\n\n  if (southCap) {\n    RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, vertexFormat.st, height - 1, 0, position, st);\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex] = position.z;\n\n    if (vertexFormat.st) {\n      textureCoordinates[stIndex++] = st.x;\n      textureCoordinates[stIndex] = st.y;\n      minX = Math.min(minX, st.x);\n      minY = Math.min(minY, st.y);\n      maxX = Math.max(maxX, st.x);\n      maxY = Math.max(maxY, st.y);\n    }\n  }\n\n  if (vertexFormat.st && (minX < 0.0 || minY < 0.0 || maxX > 1.0 || maxY > 1.0)) {\n    for (var k = 0; k < textureCoordinates.length; k += 2) {\n      textureCoordinates[k] = (textureCoordinates[k] - minX) / (maxX - minX);\n      textureCoordinates[k + 1] = (textureCoordinates[k + 1] - minY) / (maxY - minY);\n    }\n  }\n\n  var geo = calculateAttributes(positions, vertexFormat, ellipsoid, computedOptions.tangentRotationMatrix);\n  var indicesSize = 6 * (width - 1) * (rowHeight - 1);\n\n  if (northCap) {\n    indicesSize += 3 * (width - 1);\n  }\n\n  if (southCap) {\n    indicesSize += 3 * (width - 1);\n  }\n\n  var indices = IndexDatatype.createTypedArray(size, indicesSize);\n  var index = 0;\n  var indicesIndex = 0;\n  var i;\n\n  for (i = 0; i < rowHeight - 1; ++i) {\n    for (var j = 0; j < width - 1; ++j) {\n      var upperLeft = index;\n      var lowerLeft = upperLeft + width;\n      var lowerRight = lowerLeft + 1;\n      var upperRight = upperLeft + 1;\n      indices[indicesIndex++] = upperLeft;\n      indices[indicesIndex++] = lowerLeft;\n      indices[indicesIndex++] = upperRight;\n      indices[indicesIndex++] = upperRight;\n      indices[indicesIndex++] = lowerLeft;\n      indices[indicesIndex++] = lowerRight;\n      ++index;\n    }\n\n    ++index;\n  }\n\n  if (northCap || southCap) {\n    var northIndex = size - 1;\n    var southIndex = size - 1;\n\n    if (northCap && southCap) {\n      northIndex = size - 2;\n    }\n\n    var p1;\n    var p2;\n    index = 0;\n\n    if (northCap) {\n      for (i = 0; i < width - 1; i++) {\n        p1 = index;\n        p2 = p1 + 1;\n        indices[indicesIndex++] = northIndex;\n        indices[indicesIndex++] = p1;\n        indices[indicesIndex++] = p2;\n        ++index;\n      }\n    }\n\n    if (southCap) {\n      index = (rowHeight - 1) * width;\n\n      for (i = 0; i < width - 1; i++) {\n        p1 = index;\n        p2 = p1 + 1;\n        indices[indicesIndex++] = p1;\n        indices[indicesIndex++] = southIndex;\n        indices[indicesIndex++] = p2;\n        ++index;\n      }\n    }\n  }\n\n  geo.indices = indices;\n\n  if (vertexFormat.st) {\n    geo.attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: textureCoordinates\n    });\n  }\n\n  return geo;\n}\n\nfunction addWallPositions(wallPositions, posIndex, i, topPositions, bottomPositions) {\n  wallPositions[posIndex++] = topPositions[i];\n  wallPositions[posIndex++] = topPositions[i + 1];\n  wallPositions[posIndex++] = topPositions[i + 2];\n  wallPositions[posIndex++] = bottomPositions[i];\n  wallPositions[posIndex++] = bottomPositions[i + 1];\n  wallPositions[posIndex] = bottomPositions[i + 2];\n  return wallPositions;\n}\n\nfunction addWallTextureCoordinates(wallTextures, stIndex, i, st) {\n  wallTextures[stIndex++] = st[i];\n  wallTextures[stIndex++] = st[i + 1];\n  wallTextures[stIndex++] = st[i];\n  wallTextures[stIndex] = st[i + 1];\n  return wallTextures;\n}\n\nvar scratchVertexFormat = new VertexFormat();\n\nfunction constructExtrudedRectangle(rectangleGeometry, computedOptions) {\n  var shadowVolume = rectangleGeometry._shadowVolume;\n  var offsetAttributeValue = rectangleGeometry._offsetAttribute;\n  var vertexFormat = rectangleGeometry._vertexFormat;\n  var minHeight = rectangleGeometry._extrudedHeight;\n  var maxHeight = rectangleGeometry._surfaceHeight;\n  var ellipsoid = rectangleGeometry._ellipsoid;\n  var height = computedOptions.height;\n  var width = computedOptions.width;\n  var i;\n\n  if (shadowVolume) {\n    var newVertexFormat = VertexFormat.clone(vertexFormat, scratchVertexFormat);\n    newVertexFormat.normal = true;\n    rectangleGeometry._vertexFormat = newVertexFormat;\n  }\n\n  var topBottomGeo = constructRectangle(rectangleGeometry, computedOptions);\n\n  if (shadowVolume) {\n    rectangleGeometry._vertexFormat = vertexFormat;\n  }\n\n  var topPositions = PolygonPipeline.scaleToGeodeticHeight(topBottomGeo.attributes.position.values, maxHeight, ellipsoid, false);\n  topPositions = new Float64Array(topPositions);\n  var length = topPositions.length;\n  var newLength = length * 2;\n  var positions = new Float64Array(newLength);\n  positions.set(topPositions);\n  var bottomPositions = PolygonPipeline.scaleToGeodeticHeight(topBottomGeo.attributes.position.values, minHeight, ellipsoid);\n  positions.set(bottomPositions, length);\n  topBottomGeo.attributes.position.values = positions;\n  var normals = vertexFormat.normal ? new Float32Array(newLength) : undefined;\n  var tangents = vertexFormat.tangent ? new Float32Array(newLength) : undefined;\n  var bitangents = vertexFormat.bitangent ? new Float32Array(newLength) : undefined;\n  var textures = vertexFormat.st ? new Float32Array(newLength / 3 * 2) : undefined;\n  var topSt;\n  var topNormals;\n\n  if (vertexFormat.normal) {\n    topNormals = topBottomGeo.attributes.normal.values;\n    normals.set(topNormals);\n\n    for (i = 0; i < length; i++) {\n      topNormals[i] = -topNormals[i];\n    }\n\n    normals.set(topNormals, length);\n    topBottomGeo.attributes.normal.values = normals;\n  }\n\n  if (shadowVolume) {\n    topNormals = topBottomGeo.attributes.normal.values;\n\n    if (!vertexFormat.normal) {\n      topBottomGeo.attributes.normal = undefined;\n    }\n\n    var extrudeNormals = new Float32Array(newLength);\n\n    for (i = 0; i < length; i++) {\n      topNormals[i] = -topNormals[i];\n    }\n\n    extrudeNormals.set(topNormals, length); //only get normals for bottom layer that's going to be pushed down\n\n    topBottomGeo.attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals\n    });\n  }\n\n  var offsetValue;\n  var hasOffsets = defined(offsetAttributeValue);\n\n  if (hasOffsets) {\n    var size = length / 3 * 2;\n    var offsetAttribute = new Uint8Array(size);\n\n    if (offsetAttributeValue === GeometryOffsetAttribute.TOP) {\n      offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n    } else {\n      offsetValue = offsetAttributeValue === GeometryOffsetAttribute.NONE ? 0 : 1;\n      offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n    }\n\n    topBottomGeo.attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    var topTangents = topBottomGeo.attributes.tangent.values;\n    tangents.set(topTangents);\n\n    for (i = 0; i < length; i++) {\n      topTangents[i] = -topTangents[i];\n    }\n\n    tangents.set(topTangents, length);\n    topBottomGeo.attributes.tangent.values = tangents;\n  }\n\n  if (vertexFormat.bitangent) {\n    var topBitangents = topBottomGeo.attributes.bitangent.values;\n    bitangents.set(topBitangents);\n    bitangents.set(topBitangents, length);\n    topBottomGeo.attributes.bitangent.values = bitangents;\n  }\n\n  if (vertexFormat.st) {\n    topSt = topBottomGeo.attributes.st.values;\n    textures.set(topSt);\n    textures.set(topSt, length / 3 * 2);\n    topBottomGeo.attributes.st.values = textures;\n  }\n\n  var indices = topBottomGeo.indices;\n  var indicesLength = indices.length;\n  var posLength = length / 3;\n  var newIndices = IndexDatatype.createTypedArray(newLength / 3, indicesLength * 2);\n  newIndices.set(indices);\n\n  for (i = 0; i < indicesLength; i += 3) {\n    newIndices[i + indicesLength] = indices[i + 2] + posLength;\n    newIndices[i + 1 + indicesLength] = indices[i + 1] + posLength;\n    newIndices[i + 2 + indicesLength] = indices[i] + posLength;\n  }\n\n  topBottomGeo.indices = newIndices;\n  var northCap = computedOptions.northCap;\n  var southCap = computedOptions.southCap;\n  var rowHeight = height;\n  var widthMultiplier = 2;\n  var perimeterPositions = 0;\n  var corners = 4;\n  var dupliateCorners = 4;\n\n  if (northCap) {\n    widthMultiplier -= 1;\n    rowHeight -= 1;\n    perimeterPositions += 1;\n    corners -= 2;\n    dupliateCorners -= 1;\n  }\n\n  if (southCap) {\n    widthMultiplier -= 1;\n    rowHeight -= 1;\n    perimeterPositions += 1;\n    corners -= 2;\n    dupliateCorners -= 1;\n  }\n\n  perimeterPositions += widthMultiplier * width + 2 * rowHeight - corners;\n  var wallCount = (perimeterPositions + dupliateCorners) * 2;\n  var wallPositions = new Float64Array(wallCount * 3);\n  var wallExtrudeNormals = shadowVolume ? new Float32Array(wallCount * 3) : undefined;\n  var wallOffsetAttribute = hasOffsets ? new Uint8Array(wallCount) : undefined;\n  var wallTextures = vertexFormat.st ? new Float32Array(wallCount * 2) : undefined;\n  var computeTopOffsets = offsetAttributeValue === GeometryOffsetAttribute.TOP;\n\n  if (hasOffsets && !computeTopOffsets) {\n    offsetValue = offsetAttributeValue === GeometryOffsetAttribute.ALL ? 1 : 0;\n    wallOffsetAttribute = arrayFill(wallOffsetAttribute, offsetValue);\n  }\n\n  var posIndex = 0;\n  var stIndex = 0;\n  var extrudeNormalIndex = 0;\n  var wallOffsetIndex = 0;\n  var area = width * rowHeight;\n  var threeI;\n\n  for (i = 0; i < area; i += width) {\n    threeI = i * 3;\n    wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n    posIndex += 6;\n\n    if (vertexFormat.st) {\n      wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);\n      stIndex += 4;\n    }\n\n    if (shadowVolume) {\n      extrudeNormalIndex += 3;\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n    }\n\n    if (computeTopOffsets) {\n      wallOffsetAttribute[wallOffsetIndex++] = 1;\n      wallOffsetIndex += 1;\n    }\n  }\n\n  if (!southCap) {\n    for (i = area - width; i < area; i++) {\n      threeI = i * 3;\n      wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n      posIndex += 6;\n\n      if (vertexFormat.st) {\n        wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);\n        stIndex += 4;\n      }\n\n      if (shadowVolume) {\n        extrudeNormalIndex += 3;\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n      }\n\n      if (computeTopOffsets) {\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\n        wallOffsetIndex += 1;\n      }\n    }\n  } else {\n    var southIndex = northCap ? area + 1 : area;\n    threeI = southIndex * 3;\n\n    for (i = 0; i < 2; i++) {\n      // duplicate corner points\n      wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n      posIndex += 6;\n\n      if (vertexFormat.st) {\n        wallTextures = addWallTextureCoordinates(wallTextures, stIndex, southIndex * 2, topSt);\n        stIndex += 4;\n      }\n\n      if (shadowVolume) {\n        extrudeNormalIndex += 3;\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n      }\n\n      if (computeTopOffsets) {\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\n        wallOffsetIndex += 1;\n      }\n    }\n  }\n\n  for (i = area - 1; i > 0; i -= width) {\n    threeI = i * 3;\n    wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n    posIndex += 6;\n\n    if (vertexFormat.st) {\n      wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);\n      stIndex += 4;\n    }\n\n    if (shadowVolume) {\n      extrudeNormalIndex += 3;\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n    }\n\n    if (computeTopOffsets) {\n      wallOffsetAttribute[wallOffsetIndex++] = 1;\n      wallOffsetIndex += 1;\n    }\n  }\n\n  if (!northCap) {\n    for (i = width - 1; i >= 0; i--) {\n      threeI = i * 3;\n      wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n      posIndex += 6;\n\n      if (vertexFormat.st) {\n        wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);\n        stIndex += 4;\n      }\n\n      if (shadowVolume) {\n        extrudeNormalIndex += 3;\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n      }\n\n      if (computeTopOffsets) {\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\n        wallOffsetIndex += 1;\n      }\n    }\n  } else {\n    var northIndex = area;\n    threeI = northIndex * 3;\n\n    for (i = 0; i < 2; i++) {\n      // duplicate corner points\n      wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n      posIndex += 6;\n\n      if (vertexFormat.st) {\n        wallTextures = addWallTextureCoordinates(wallTextures, stIndex, northIndex * 2, topSt);\n        stIndex += 4;\n      }\n\n      if (shadowVolume) {\n        extrudeNormalIndex += 3;\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n      }\n\n      if (computeTopOffsets) {\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\n        wallOffsetIndex += 1;\n      }\n    }\n  }\n\n  var geo = calculateAttributesWall(wallPositions, vertexFormat, ellipsoid);\n\n  if (vertexFormat.st) {\n    geo.attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: wallTextures\n    });\n  }\n\n  if (shadowVolume) {\n    geo.attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: wallExtrudeNormals\n    });\n  }\n\n  if (hasOffsets) {\n    geo.attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: wallOffsetAttribute\n    });\n  }\n\n  var wallIndices = IndexDatatype.createTypedArray(wallCount, perimeterPositions * 6);\n  var upperLeft;\n  var lowerLeft;\n  var lowerRight;\n  var upperRight;\n  length = wallPositions.length / 3;\n  var index = 0;\n\n  for (i = 0; i < length - 1; i += 2) {\n    upperLeft = i;\n    upperRight = (upperLeft + 2) % length;\n    var p1 = Cartesian3.fromArray(wallPositions, upperLeft * 3, v1Scratch);\n    var p2 = Cartesian3.fromArray(wallPositions, upperRight * 3, v2Scratch);\n\n    if (Cartesian3.equalsEpsilon(p1, p2, CesiumMath.EPSILON10)) {\n      continue;\n    }\n\n    lowerLeft = (upperLeft + 1) % length;\n    lowerRight = (lowerLeft + 2) % length;\n    wallIndices[index++] = upperLeft;\n    wallIndices[index++] = lowerLeft;\n    wallIndices[index++] = upperRight;\n    wallIndices[index++] = upperRight;\n    wallIndices[index++] = lowerLeft;\n    wallIndices[index++] = lowerRight;\n  }\n\n  geo.indices = wallIndices;\n  geo = GeometryPipeline.combineInstances([new GeometryInstance({\n    geometry: topBottomGeo\n  }), new GeometryInstance({\n    geometry: geo\n  })]);\n  return geo[0];\n}\n\nvar scratchRectanglePoints = [new Cartesian3(), new Cartesian3(), new Cartesian3(), new Cartesian3()];\nvar nwScratch = new Cartographic();\nvar stNwScratch = new Cartographic();\n\nfunction computeRectangle(rectangle, granularity, rotation, ellipsoid, result) {\n  if (rotation === 0.0) {\n    return Rectangle.clone(rectangle, result);\n  }\n\n  var computedOptions = RectangleGeometryLibrary.computeOptions(rectangle, granularity, rotation, 0, rectangleScratch, nwScratch);\n  var height = computedOptions.height;\n  var width = computedOptions.width;\n  var positions = scratchRectanglePoints;\n  RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, 0, 0, positions[0]);\n  RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, 0, width - 1, positions[1]);\n  RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, height - 1, 0, positions[2]);\n  RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, height - 1, width - 1, positions[3]);\n  return Rectangle.fromCartesianArray(positions, ellipsoid, result);\n}\n/**\n * A description of a cartographic rectangle on an ellipsoid centered at the origin. Rectangle geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias RectangleGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Number} [options.height=0.0] The distance in meters between the rectangle and the ellipsoid surface.\n * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\n * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n * @param {Number} [options.extrudedHeight] The distance in meters between the rectangle's extruded face and the ellipsoid surface.\n *\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>options.rectangle.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>options.rectangle.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>options.rectangle.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be greater than <code>options.rectangle.south</code>.\n *\n * @see RectangleGeometry#createGeometry\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Rectangle.html|Cesium Sandcastle Rectangle Demo}\n *\n * @example\n * // 1. create a rectangle\n * var rectangle = new Cesium.RectangleGeometry({\n *   ellipsoid : Cesium.Ellipsoid.WGS84,\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n *   height : 10000.0\n * });\n * var geometry = Cesium.RectangleGeometry.createGeometry(rectangle);\n *\n * // 2. create an extruded rectangle without a top\n * var rectangle = new Cesium.RectangleGeometry({\n *   ellipsoid : Cesium.Ellipsoid.WGS84,\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n *   height : 10000.0,\n *   extrudedHeight: 300000\n * });\n * var geometry = Cesium.RectangleGeometry.createGeometry(rectangle);\n */\n\n\nfunction RectangleGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var rectangle = options.rectangle; //>>includeStart('debug', pragmas.debug);\n\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Rectangle.validate(rectangle);\n\n  if (rectangle.north < rectangle.south) {\n    throw new DeveloperError(\"options.rectangle.north must be greater than or equal to options.rectangle.south\");\n  } //>>includeEnd('debug');\n\n\n  var height = defaultValue(options.height, 0.0);\n  var extrudedHeight = defaultValue(options.extrudedHeight, height);\n  this._rectangle = Rectangle.clone(rectangle);\n  this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n  this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n  this._surfaceHeight = Math.max(height, extrudedHeight);\n  this._rotation = defaultValue(options.rotation, 0.0);\n  this._stRotation = defaultValue(options.stRotation, 0.0);\n  this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));\n  this._extrudedHeight = Math.min(height, extrudedHeight);\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\n  this._workerName = \"createRectangleGeometry\";\n  this._offsetAttribute = options.offsetAttribute;\n  this._rotatedRectangle = undefined;\n  this._textureCoordinateRotationPoints = undefined;\n}\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\n\n\nRectangleGeometry.packedLength = Rectangle.packedLength + Ellipsoid.packedLength + VertexFormat.packedLength + 7;\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {RectangleGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\nRectangleGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  Rectangle.pack(value._rectangle, array, startingIndex);\n  startingIndex += Rectangle.packedLength;\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._surfaceHeight;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._stRotation;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n  return array;\n};\n\nvar scratchRectangle = new Rectangle();\nvar scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nvar scratchOptions = {\n  rectangle: scratchRectangle,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  granularity: undefined,\n  height: undefined,\n  rotation: undefined,\n  stRotation: undefined,\n  extrudedHeight: undefined,\n  shadowVolume: undefined,\n  offsetAttribute: undefined\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {RectangleGeometry} [result] The object into which to store the result.\n * @returns {RectangleGeometry} The modified result parameter or a new RectangleGeometry instance if one was not provided.\n */\n\nRectangleGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var rectangle = Rectangle.unpack(array, startingIndex, scratchRectangle);\n  startingIndex += Rectangle.packedLength;\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n  var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n  startingIndex += VertexFormat.packedLength;\n  var granularity = array[startingIndex++];\n  var surfaceHeight = array[startingIndex++];\n  var rotation = array[startingIndex++];\n  var stRotation = array[startingIndex++];\n  var extrudedHeight = array[startingIndex++];\n  var shadowVolume = array[startingIndex++] === 1.0;\n  var offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.granularity = granularity;\n    scratchOptions.height = surfaceHeight;\n    scratchOptions.rotation = rotation;\n    scratchOptions.stRotation = stRotation;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.shadowVolume = shadowVolume;\n    scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new RectangleGeometry(scratchOptions);\n  }\n\n  result._rectangle = Rectangle.clone(rectangle, result._rectangle);\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._granularity = granularity;\n  result._surfaceHeight = surfaceHeight;\n  result._rotation = rotation;\n  result._stRotation = stRotation;\n  result._extrudedHeight = extrudedHeight;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n  return result;\n};\n/**\n * Computes the bounding rectangle based on the provided options\n *\n * @param {Object} options Object with the following properties:\n * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\n * @param {Rectangle} [result] An object in which to store the result.\n *\n * @returns {Rectangle} The result rectangle\n */\n\n\nRectangleGeometry.computeRectangle = function (options, result) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var rectangle = options.rectangle; //>>includeStart('debug', pragmas.debug);\n\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Rectangle.validate(rectangle);\n\n  if (rectangle.north < rectangle.south) {\n    throw new DeveloperError(\"options.rectangle.north must be greater than or equal to options.rectangle.south\");\n  } //>>includeEnd('debug');\n\n\n  var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var rotation = defaultValue(options.rotation, 0.0);\n  return computeRectangle(rectangle, granularity, rotation, ellipsoid, result);\n};\n\nvar tangentRotationMatrixScratch = new Matrix3();\nvar quaternionScratch = new Quaternion();\nvar centerScratch = new Cartographic();\n/**\n * Computes the geometric representation of a rectangle, including its vertices, indices, and a bounding sphere.\n *\n * @param {RectangleGeometry} rectangleGeometry A description of the rectangle.\n * @returns {Geometry|undefined} The computed vertices and indices.\n *\n * @exception {DeveloperError} Rotated rectangle is invalid.\n */\n\nRectangleGeometry.createGeometry = function (rectangleGeometry) {\n  if (CesiumMath.equalsEpsilon(rectangleGeometry._rectangle.north, rectangleGeometry._rectangle.south, CesiumMath.EPSILON10) || CesiumMath.equalsEpsilon(rectangleGeometry._rectangle.east, rectangleGeometry._rectangle.west, CesiumMath.EPSILON10)) {\n    return undefined;\n  }\n\n  var rectangle = rectangleGeometry._rectangle;\n  var ellipsoid = rectangleGeometry._ellipsoid;\n  var rotation = rectangleGeometry._rotation;\n  var stRotation = rectangleGeometry._stRotation;\n  var vertexFormat = rectangleGeometry._vertexFormat;\n  var computedOptions = RectangleGeometryLibrary.computeOptions(rectangle, rectangleGeometry._granularity, rotation, stRotation, rectangleScratch, nwScratch, stNwScratch);\n  var tangentRotationMatrix = tangentRotationMatrixScratch;\n\n  if (stRotation !== 0 || rotation !== 0) {\n    var center = Rectangle.center(rectangle, centerScratch);\n    var axis = ellipsoid.geodeticSurfaceNormalCartographic(center, v1Scratch);\n    Quaternion.fromAxisAngle(axis, -stRotation, quaternionScratch);\n    Matrix3.fromQuaternion(quaternionScratch, tangentRotationMatrix);\n  } else {\n    Matrix3.clone(Matrix3.IDENTITY, tangentRotationMatrix);\n  }\n\n  var surfaceHeight = rectangleGeometry._surfaceHeight;\n  var extrudedHeight = rectangleGeometry._extrudedHeight;\n  var extrude = !CesiumMath.equalsEpsilon(surfaceHeight, extrudedHeight, 0, CesiumMath.EPSILON2);\n  computedOptions.lonScalar = 1.0 / rectangleGeometry._rectangle.width;\n  computedOptions.latScalar = 1.0 / rectangleGeometry._rectangle.height;\n  computedOptions.tangentRotationMatrix = tangentRotationMatrix;\n  var geometry;\n  var boundingSphere;\n  rectangle = rectangleGeometry._rectangle;\n\n  if (extrude) {\n    geometry = constructExtrudedRectangle(rectangleGeometry, computedOptions);\n    var topBS = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, surfaceHeight, topBoundingSphere);\n    var bottomBS = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, extrudedHeight, bottomBoundingSphere);\n    boundingSphere = BoundingSphere.union(topBS, bottomBS);\n  } else {\n    geometry = constructRectangle(rectangleGeometry, computedOptions);\n    geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(geometry.attributes.position.values, surfaceHeight, ellipsoid, false);\n\n    if (defined(rectangleGeometry._offsetAttribute)) {\n      var length = geometry.attributes.position.values.length;\n      var applyOffset = new Uint8Array(length / 3);\n      var offsetValue = rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      arrayFill(applyOffset, offsetValue);\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset\n      });\n    }\n\n    boundingSphere = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, surfaceHeight);\n  }\n\n  if (!vertexFormat.position) {\n    delete geometry.attributes.position;\n  }\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: boundingSphere,\n    offsetAttribute: rectangleGeometry._offsetAttribute\n  });\n};\n/**\n * @private\n */\n\n\nRectangleGeometry.createShadowVolume = function (rectangleGeometry, minHeightFunc, maxHeightFunc) {\n  var granularity = rectangleGeometry._granularity;\n  var ellipsoid = rectangleGeometry._ellipsoid;\n  var minHeight = minHeightFunc(granularity, ellipsoid);\n  var maxHeight = maxHeightFunc(granularity, ellipsoid);\n  return new RectangleGeometry({\n    rectangle: rectangleGeometry._rectangle,\n    rotation: rectangleGeometry._rotation,\n    ellipsoid: ellipsoid,\n    stRotation: rectangleGeometry._stRotation,\n    granularity: granularity,\n    extrudedHeight: maxHeight,\n    height: minHeight,\n    vertexFormat: VertexFormat.POSITION_ONLY,\n    shadowVolume: true\n  });\n};\n\nvar unrotatedTextureRectangleScratch = new Rectangle();\nvar points2DScratch = [new Cartesian2(), new Cartesian2(), new Cartesian2()];\nvar rotation2DScratch = new Matrix2();\nvar rectangleCenterScratch = new Cartographic();\n\nfunction textureCoordinateRotationPoints(rectangleGeometry) {\n  if (rectangleGeometry._stRotation === 0.0) {\n    return [0, 0, 0, 1, 1, 0];\n  }\n\n  var rectangle = Rectangle.clone(rectangleGeometry._rectangle, unrotatedTextureRectangleScratch);\n  var granularity = rectangleGeometry._granularity;\n  var ellipsoid = rectangleGeometry._ellipsoid; // Rotate to align the texture coordinates with ENU\n\n  var rotation = rectangleGeometry._rotation - rectangleGeometry._stRotation;\n  var unrotatedTextureRectangle = computeRectangle(rectangle, granularity, rotation, ellipsoid, unrotatedTextureRectangleScratch); // Assume a computed \"east-north\" texture coordinate system based on spherical or planar tricks, bounded by `boundingRectangle`.\n  // The \"desired\" texture coordinate system forms an oriented rectangle (un-oriented computed) around the geometry that completely and tightly bounds it.\n  // We want to map from the \"east-north\" texture coordinate system into the \"desired\" system using a pair of lines (analagous planes in 2D)\n  // Compute 3 corners of the \"desired\" texture coordinate system in \"east-north\" texture space by the following in cartographic space:\n  // - rotate 3 of the corners in unrotatedTextureRectangle by stRotation around the center of the bounding rectangle\n  // - apply the \"east-north\" system's normalization formula to the rotated cartographics, even though this is likely to produce values outside [0-1].\n  // This gives us a set of points in the \"east-north\" texture coordinate system that can be used to map \"east-north\" texture coordinates to \"desired.\"\n\n  var points2D = points2DScratch;\n  points2D[0].x = unrotatedTextureRectangle.west;\n  points2D[0].y = unrotatedTextureRectangle.south;\n  points2D[1].x = unrotatedTextureRectangle.west;\n  points2D[1].y = unrotatedTextureRectangle.north;\n  points2D[2].x = unrotatedTextureRectangle.east;\n  points2D[2].y = unrotatedTextureRectangle.south;\n  var boundingRectangle = rectangleGeometry.rectangle;\n  var toDesiredInComputed = Matrix2.fromRotation(rectangleGeometry._stRotation, rotation2DScratch);\n  var boundingRectangleCenter = Rectangle.center(boundingRectangle, rectangleCenterScratch);\n\n  for (var i = 0; i < 3; ++i) {\n    var point2D = points2D[i];\n    point2D.x -= boundingRectangleCenter.longitude;\n    point2D.y -= boundingRectangleCenter.latitude;\n    Matrix2.multiplyByVector(toDesiredInComputed, point2D, point2D);\n    point2D.x += boundingRectangleCenter.longitude;\n    point2D.y += boundingRectangleCenter.latitude; // Convert point into east-north texture coordinate space\n\n    point2D.x = (point2D.x - boundingRectangle.west) / boundingRectangle.width;\n    point2D.y = (point2D.y - boundingRectangle.south) / boundingRectangle.height;\n  }\n\n  var minXYCorner = points2D[0];\n  var maxYCorner = points2D[1];\n  var maxXCorner = points2D[2];\n  var result = new Array(6);\n  Cartesian2.pack(minXYCorner, result);\n  Cartesian2.pack(maxYCorner, result, 2);\n  Cartesian2.pack(maxXCorner, result, 4);\n  return result;\n}\n\nObject.defineProperties(RectangleGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function () {\n      if (!defined(this._rotatedRectangle)) {\n        this._rotatedRectangle = computeRectangle(this._rectangle, this._granularity, this._rotation, this._ellipsoid);\n      }\n\n      return this._rotatedRectangle;\n    }\n  },\n\n  /**\n   * For remapping texture coordinates when rendering RectangleGeometries as GroundPrimitives.\n   * This version permits skew in textures by computing offsets directly in cartographic space and\n   * more accurately approximates rendering RectangleGeometries with height as standard Primitives.\n   * @see Geometry#_textureCoordinateRotationPoints\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function () {\n      if (!defined(this._textureCoordinateRotationPoints)) {\n        this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(this);\n      }\n\n      return this._textureCoordinateRotationPoints;\n    }\n  }\n});\nexport default RectangleGeometry;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/RectangleGeometry.js"],"names":["arrayFill","BoundingSphere","Cartesian2","Cartesian3","Cartographic","Check","ComponentDatatype","defaultValue","defined","DeveloperError","Ellipsoid","Geometry","GeometryAttribute","GeometryAttributes","GeometryInstance","GeometryOffsetAttribute","GeometryPipeline","IndexDatatype","CesiumMath","Matrix2","Matrix3","PolygonPipeline","PrimitiveType","Quaternion","Rectangle","RectangleGeometryLibrary","VertexFormat","positionScratch","normalScratch","tangentScratch","bitangentScratch","rectangleScratch","stScratch","bottomBoundingSphere","topBoundingSphere","createAttributes","vertexFormat","attributes","geo","primitiveType","TRIANGLES","position","componentDatatype","DOUBLE","componentsPerAttribute","values","positions","normal","FLOAT","normals","tangent","tangents","bitangent","bitangents","calculateAttributes","ellipsoid","tangentRotationMatrix","length","Float32Array","undefined","attrIndex","i","p","fromArray","attrIndex1","attrIndex2","geodeticSurfaceNormal","cross","UNIT_Z","multiplyByVector","normalize","x","y","z","v1Scratch","v2Scratch","calculateAttributesWall","normalIndex","tangentIndex","bitangentIndex","recomputeNormal","p1","p2","subtract","equalsEpsilon","EPSILON10","constructRectangle","rectangleGeometry","computedOptions","_vertexFormat","_ellipsoid","height","width","northCap","southCap","rowStart","rowEnd","rowHeight","size","Float64Array","textureCoordinates","st","posIndex","stIndex","minX","Number","MAX_VALUE","minY","maxX","maxY","row","col","computePosition","Math","min","max","k","indicesSize","indices","createTypedArray","index","indicesIndex","j","upperLeft","lowerLeft","lowerRight","upperRight","northIndex","southIndex","addWallPositions","wallPositions","topPositions","bottomPositions","addWallTextureCoordinates","wallTextures","scratchVertexFormat","constructExtrudedRectangle","shadowVolume","_shadowVolume","offsetAttributeValue","_offsetAttribute","minHeight","_extrudedHeight","maxHeight","_surfaceHeight","newVertexFormat","clone","topBottomGeo","scaleToGeodeticHeight","newLength","set","textures","topSt","topNormals","extrudeNormals","extrudeDirection","offsetValue","hasOffsets","offsetAttribute","Uint8Array","TOP","NONE","applyOffset","UNSIGNED_BYTE","topTangents","topBitangents","indicesLength","posLength","newIndices","widthMultiplier","perimeterPositions","corners","dupliateCorners","wallCount","wallExtrudeNormals","wallOffsetAttribute","computeTopOffsets","ALL","extrudeNormalIndex","wallOffsetIndex","area","threeI","wallIndices","combineInstances","geometry","scratchRectanglePoints","nwScratch","stNwScratch","computeRectangle","rectangle","granularity","rotation","result","computeOptions","fromCartesianArray","RectangleGeometry","options","EMPTY_OBJECT","typeOf","object","validate","north","south","extrudedHeight","_rectangle","_granularity","RADIANS_PER_DEGREE","WGS84","_rotation","_stRotation","stRotation","DEFAULT","_workerName","_rotatedRectangle","_textureCoordinateRotationPoints","packedLength","pack","value","array","startingIndex","scratchRectangle","scratchEllipsoid","UNIT_SPHERE","scratchOptions","unpack","surfaceHeight","tangentRotationMatrixScratch","quaternionScratch","centerScratch","createGeometry","east","west","center","axis","geodeticSurfaceNormalCartographic","fromAxisAngle","fromQuaternion","IDENTITY","extrude","EPSILON2","lonScalar","latScalar","boundingSphere","topBS","fromRectangle3D","bottomBS","union","createShadowVolume","minHeightFunc","maxHeightFunc","POSITION_ONLY","unrotatedTextureRectangleScratch","points2DScratch","rotation2DScratch","rectangleCenterScratch","textureCoordinateRotationPoints","unrotatedTextureRectangle","points2D","boundingRectangle","toDesiredInComputed","fromRotation","boundingRectangleCenter","point2D","longitude","latitude","minXYCorner","maxYCorner","maxXCorner","Array","Object","defineProperties","prototype","get"],"mappings":"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","sourcesContent":["import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix2 from \"./Matrix2.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport RectangleGeometryLibrary from \"./RectangleGeometryLibrary.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nvar positionScratch = new Cartesian3();\nvar normalScratch = new Cartesian3();\nvar tangentScratch = new Cartesian3();\nvar bitangentScratch = new Cartesian3();\nvar rectangleScratch = new Rectangle();\nvar stScratch = new Cartesian2();\nvar bottomBoundingSphere = new BoundingSphere();\nvar topBoundingSphere = new BoundingSphere();\n\nfunction createAttributes(vertexFormat, attributes) {\n  var geo = new Geometry({\n    attributes: new GeometryAttributes(),\n    primitiveType: PrimitiveType.TRIANGLES,\n  });\n\n  geo.attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: attributes.positions,\n  });\n  if (vertexFormat.normal) {\n    geo.attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attributes.normals,\n    });\n  }\n  if (vertexFormat.tangent) {\n    geo.attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attributes.tangents,\n    });\n  }\n  if (vertexFormat.bitangent) {\n    geo.attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attributes.bitangents,\n    });\n  }\n  return geo;\n}\n\nfunction calculateAttributes(\n  positions,\n  vertexFormat,\n  ellipsoid,\n  tangentRotationMatrix\n) {\n  var length = positions.length;\n\n  var normals = vertexFormat.normal ? new Float32Array(length) : undefined;\n  var tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;\n  var bitangents = vertexFormat.bitangent\n    ? new Float32Array(length)\n    : undefined;\n\n  var attrIndex = 0;\n  var bitangent = bitangentScratch;\n  var tangent = tangentScratch;\n  var normal = normalScratch;\n  if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n    for (var i = 0; i < length; i += 3) {\n      var p = Cartesian3.fromArray(positions, i, positionScratch);\n      var attrIndex1 = attrIndex + 1;\n      var attrIndex2 = attrIndex + 2;\n\n      normal = ellipsoid.geodeticSurfaceNormal(p, normal);\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\n        Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\n        Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent);\n        Cartesian3.normalize(tangent, tangent);\n\n        if (vertexFormat.bitangent) {\n          Cartesian3.normalize(\n            Cartesian3.cross(normal, tangent, bitangent),\n            bitangent\n          );\n        }\n      }\n\n      if (vertexFormat.normal) {\n        normals[attrIndex] = normal.x;\n        normals[attrIndex1] = normal.y;\n        normals[attrIndex2] = normal.z;\n      }\n      if (vertexFormat.tangent) {\n        tangents[attrIndex] = tangent.x;\n        tangents[attrIndex1] = tangent.y;\n        tangents[attrIndex2] = tangent.z;\n      }\n      if (vertexFormat.bitangent) {\n        bitangents[attrIndex] = bitangent.x;\n        bitangents[attrIndex1] = bitangent.y;\n        bitangents[attrIndex2] = bitangent.z;\n      }\n      attrIndex += 3;\n    }\n  }\n  return createAttributes(vertexFormat, {\n    positions: positions,\n    normals: normals,\n    tangents: tangents,\n    bitangents: bitangents,\n  });\n}\n\nvar v1Scratch = new Cartesian3();\nvar v2Scratch = new Cartesian3();\n\nfunction calculateAttributesWall(positions, vertexFormat, ellipsoid) {\n  var length = positions.length;\n\n  var normals = vertexFormat.normal ? new Float32Array(length) : undefined;\n  var tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;\n  var bitangents = vertexFormat.bitangent\n    ? new Float32Array(length)\n    : undefined;\n\n  var normalIndex = 0;\n  var tangentIndex = 0;\n  var bitangentIndex = 0;\n  var recomputeNormal = true;\n\n  var bitangent = bitangentScratch;\n  var tangent = tangentScratch;\n  var normal = normalScratch;\n  if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n    for (var i = 0; i < length; i += 6) {\n      var p = Cartesian3.fromArray(positions, i, positionScratch);\n      var p1 = Cartesian3.fromArray(positions, (i + 6) % length, v1Scratch);\n      if (recomputeNormal) {\n        var p2 = Cartesian3.fromArray(positions, (i + 3) % length, v2Scratch);\n        Cartesian3.subtract(p1, p, p1);\n        Cartesian3.subtract(p2, p, p2);\n        normal = Cartesian3.normalize(Cartesian3.cross(p2, p1, normal), normal);\n        recomputeNormal = false;\n      }\n\n      if (Cartesian3.equalsEpsilon(p1, p, CesiumMath.EPSILON10)) {\n        // if we've reached a corner\n        recomputeNormal = true;\n      }\n\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\n        bitangent = ellipsoid.geodeticSurfaceNormal(p, bitangent);\n        if (vertexFormat.tangent) {\n          tangent = Cartesian3.normalize(\n            Cartesian3.cross(bitangent, normal, tangent),\n            tangent\n          );\n        }\n      }\n\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = normal.x;\n        normals[normalIndex++] = normal.y;\n        normals[normalIndex++] = normal.z;\n        normals[normalIndex++] = normal.x;\n        normals[normalIndex++] = normal.y;\n        normals[normalIndex++] = normal.z;\n      }\n\n      if (vertexFormat.tangent) {\n        tangents[tangentIndex++] = tangent.x;\n        tangents[tangentIndex++] = tangent.y;\n        tangents[tangentIndex++] = tangent.z;\n        tangents[tangentIndex++] = tangent.x;\n        tangents[tangentIndex++] = tangent.y;\n        tangents[tangentIndex++] = tangent.z;\n      }\n\n      if (vertexFormat.bitangent) {\n        bitangents[bitangentIndex++] = bitangent.x;\n        bitangents[bitangentIndex++] = bitangent.y;\n        bitangents[bitangentIndex++] = bitangent.z;\n        bitangents[bitangentIndex++] = bitangent.x;\n        bitangents[bitangentIndex++] = bitangent.y;\n        bitangents[bitangentIndex++] = bitangent.z;\n      }\n    }\n  }\n\n  return createAttributes(vertexFormat, {\n    positions: positions,\n    normals: normals,\n    tangents: tangents,\n    bitangents: bitangents,\n  });\n}\n\nfunction constructRectangle(rectangleGeometry, computedOptions) {\n  var vertexFormat = rectangleGeometry._vertexFormat;\n  var ellipsoid = rectangleGeometry._ellipsoid;\n  var height = computedOptions.height;\n  var width = computedOptions.width;\n  var northCap = computedOptions.northCap;\n  var southCap = computedOptions.southCap;\n\n  var rowStart = 0;\n  var rowEnd = height;\n  var rowHeight = height;\n  var size = 0;\n  if (northCap) {\n    rowStart = 1;\n    rowHeight -= 1;\n    size += 1;\n  }\n  if (southCap) {\n    rowEnd -= 1;\n    rowHeight -= 1;\n    size += 1;\n  }\n  size += width * rowHeight;\n\n  var positions = vertexFormat.position\n    ? new Float64Array(size * 3)\n    : undefined;\n  var textureCoordinates = vertexFormat.st\n    ? new Float32Array(size * 2)\n    : undefined;\n\n  var posIndex = 0;\n  var stIndex = 0;\n\n  var position = positionScratch;\n  var st = stScratch;\n\n  var minX = Number.MAX_VALUE;\n  var minY = Number.MAX_VALUE;\n  var maxX = -Number.MAX_VALUE;\n  var maxY = -Number.MAX_VALUE;\n\n  for (var row = rowStart; row < rowEnd; ++row) {\n    for (var col = 0; col < width; ++col) {\n      RectangleGeometryLibrary.computePosition(\n        computedOptions,\n        ellipsoid,\n        vertexFormat.st,\n        row,\n        col,\n        position,\n        st\n      );\n\n      positions[posIndex++] = position.x;\n      positions[posIndex++] = position.y;\n      positions[posIndex++] = position.z;\n\n      if (vertexFormat.st) {\n        textureCoordinates[stIndex++] = st.x;\n        textureCoordinates[stIndex++] = st.y;\n\n        minX = Math.min(minX, st.x);\n        minY = Math.min(minY, st.y);\n        maxX = Math.max(maxX, st.x);\n        maxY = Math.max(maxY, st.y);\n      }\n    }\n  }\n  if (northCap) {\n    RectangleGeometryLibrary.computePosition(\n      computedOptions,\n      ellipsoid,\n      vertexFormat.st,\n      0,\n      0,\n      position,\n      st\n    );\n\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n\n    if (vertexFormat.st) {\n      textureCoordinates[stIndex++] = st.x;\n      textureCoordinates[stIndex++] = st.y;\n\n      minX = st.x;\n      minY = st.y;\n      maxX = st.x;\n      maxY = st.y;\n    }\n  }\n  if (southCap) {\n    RectangleGeometryLibrary.computePosition(\n      computedOptions,\n      ellipsoid,\n      vertexFormat.st,\n      height - 1,\n      0,\n      position,\n      st\n    );\n\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex] = position.z;\n\n    if (vertexFormat.st) {\n      textureCoordinates[stIndex++] = st.x;\n      textureCoordinates[stIndex] = st.y;\n\n      minX = Math.min(minX, st.x);\n      minY = Math.min(minY, st.y);\n      maxX = Math.max(maxX, st.x);\n      maxY = Math.max(maxY, st.y);\n    }\n  }\n\n  if (\n    vertexFormat.st &&\n    (minX < 0.0 || minY < 0.0 || maxX > 1.0 || maxY > 1.0)\n  ) {\n    for (var k = 0; k < textureCoordinates.length; k += 2) {\n      textureCoordinates[k] = (textureCoordinates[k] - minX) / (maxX - minX);\n      textureCoordinates[k + 1] =\n        (textureCoordinates[k + 1] - minY) / (maxY - minY);\n    }\n  }\n\n  var geo = calculateAttributes(\n    positions,\n    vertexFormat,\n    ellipsoid,\n    computedOptions.tangentRotationMatrix\n  );\n\n  var indicesSize = 6 * (width - 1) * (rowHeight - 1);\n  if (northCap) {\n    indicesSize += 3 * (width - 1);\n  }\n  if (southCap) {\n    indicesSize += 3 * (width - 1);\n  }\n  var indices = IndexDatatype.createTypedArray(size, indicesSize);\n  var index = 0;\n  var indicesIndex = 0;\n  var i;\n  for (i = 0; i < rowHeight - 1; ++i) {\n    for (var j = 0; j < width - 1; ++j) {\n      var upperLeft = index;\n      var lowerLeft = upperLeft + width;\n      var lowerRight = lowerLeft + 1;\n      var upperRight = upperLeft + 1;\n      indices[indicesIndex++] = upperLeft;\n      indices[indicesIndex++] = lowerLeft;\n      indices[indicesIndex++] = upperRight;\n      indices[indicesIndex++] = upperRight;\n      indices[indicesIndex++] = lowerLeft;\n      indices[indicesIndex++] = lowerRight;\n      ++index;\n    }\n    ++index;\n  }\n  if (northCap || southCap) {\n    var northIndex = size - 1;\n    var southIndex = size - 1;\n    if (northCap && southCap) {\n      northIndex = size - 2;\n    }\n\n    var p1;\n    var p2;\n    index = 0;\n\n    if (northCap) {\n      for (i = 0; i < width - 1; i++) {\n        p1 = index;\n        p2 = p1 + 1;\n        indices[indicesIndex++] = northIndex;\n        indices[indicesIndex++] = p1;\n        indices[indicesIndex++] = p2;\n        ++index;\n      }\n    }\n    if (southCap) {\n      index = (rowHeight - 1) * width;\n      for (i = 0; i < width - 1; i++) {\n        p1 = index;\n        p2 = p1 + 1;\n        indices[indicesIndex++] = p1;\n        indices[indicesIndex++] = southIndex;\n        indices[indicesIndex++] = p2;\n        ++index;\n      }\n    }\n  }\n\n  geo.indices = indices;\n  if (vertexFormat.st) {\n    geo.attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: textureCoordinates,\n    });\n  }\n\n  return geo;\n}\n\nfunction addWallPositions(\n  wallPositions,\n  posIndex,\n  i,\n  topPositions,\n  bottomPositions\n) {\n  wallPositions[posIndex++] = topPositions[i];\n  wallPositions[posIndex++] = topPositions[i + 1];\n  wallPositions[posIndex++] = topPositions[i + 2];\n  wallPositions[posIndex++] = bottomPositions[i];\n  wallPositions[posIndex++] = bottomPositions[i + 1];\n  wallPositions[posIndex] = bottomPositions[i + 2];\n  return wallPositions;\n}\n\nfunction addWallTextureCoordinates(wallTextures, stIndex, i, st) {\n  wallTextures[stIndex++] = st[i];\n  wallTextures[stIndex++] = st[i + 1];\n  wallTextures[stIndex++] = st[i];\n  wallTextures[stIndex] = st[i + 1];\n  return wallTextures;\n}\n\nvar scratchVertexFormat = new VertexFormat();\n\nfunction constructExtrudedRectangle(rectangleGeometry, computedOptions) {\n  var shadowVolume = rectangleGeometry._shadowVolume;\n  var offsetAttributeValue = rectangleGeometry._offsetAttribute;\n  var vertexFormat = rectangleGeometry._vertexFormat;\n  var minHeight = rectangleGeometry._extrudedHeight;\n  var maxHeight = rectangleGeometry._surfaceHeight;\n  var ellipsoid = rectangleGeometry._ellipsoid;\n\n  var height = computedOptions.height;\n  var width = computedOptions.width;\n\n  var i;\n\n  if (shadowVolume) {\n    var newVertexFormat = VertexFormat.clone(vertexFormat, scratchVertexFormat);\n    newVertexFormat.normal = true;\n    rectangleGeometry._vertexFormat = newVertexFormat;\n  }\n\n  var topBottomGeo = constructRectangle(rectangleGeometry, computedOptions);\n\n  if (shadowVolume) {\n    rectangleGeometry._vertexFormat = vertexFormat;\n  }\n\n  var topPositions = PolygonPipeline.scaleToGeodeticHeight(\n    topBottomGeo.attributes.position.values,\n    maxHeight,\n    ellipsoid,\n    false\n  );\n  topPositions = new Float64Array(topPositions);\n  var length = topPositions.length;\n  var newLength = length * 2;\n  var positions = new Float64Array(newLength);\n  positions.set(topPositions);\n  var bottomPositions = PolygonPipeline.scaleToGeodeticHeight(\n    topBottomGeo.attributes.position.values,\n    minHeight,\n    ellipsoid\n  );\n  positions.set(bottomPositions, length);\n  topBottomGeo.attributes.position.values = positions;\n\n  var normals = vertexFormat.normal ? new Float32Array(newLength) : undefined;\n  var tangents = vertexFormat.tangent ? new Float32Array(newLength) : undefined;\n  var bitangents = vertexFormat.bitangent\n    ? new Float32Array(newLength)\n    : undefined;\n  var textures = vertexFormat.st\n    ? new Float32Array((newLength / 3) * 2)\n    : undefined;\n  var topSt;\n  var topNormals;\n  if (vertexFormat.normal) {\n    topNormals = topBottomGeo.attributes.normal.values;\n    normals.set(topNormals);\n    for (i = 0; i < length; i++) {\n      topNormals[i] = -topNormals[i];\n    }\n    normals.set(topNormals, length);\n    topBottomGeo.attributes.normal.values = normals;\n  }\n  if (shadowVolume) {\n    topNormals = topBottomGeo.attributes.normal.values;\n    if (!vertexFormat.normal) {\n      topBottomGeo.attributes.normal = undefined;\n    }\n    var extrudeNormals = new Float32Array(newLength);\n    for (i = 0; i < length; i++) {\n      topNormals[i] = -topNormals[i];\n    }\n    extrudeNormals.set(topNormals, length); //only get normals for bottom layer that's going to be pushed down\n    topBottomGeo.attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals,\n    });\n  }\n\n  var offsetValue;\n  var hasOffsets = defined(offsetAttributeValue);\n  if (hasOffsets) {\n    var size = (length / 3) * 2;\n    var offsetAttribute = new Uint8Array(size);\n    if (offsetAttributeValue === GeometryOffsetAttribute.TOP) {\n      offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n    } else {\n      offsetValue =\n        offsetAttributeValue === GeometryOffsetAttribute.NONE ? 0 : 1;\n      offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n    }\n\n    topBottomGeo.attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    var topTangents = topBottomGeo.attributes.tangent.values;\n    tangents.set(topTangents);\n    for (i = 0; i < length; i++) {\n      topTangents[i] = -topTangents[i];\n    }\n    tangents.set(topTangents, length);\n    topBottomGeo.attributes.tangent.values = tangents;\n  }\n  if (vertexFormat.bitangent) {\n    var topBitangents = topBottomGeo.attributes.bitangent.values;\n    bitangents.set(topBitangents);\n    bitangents.set(topBitangents, length);\n    topBottomGeo.attributes.bitangent.values = bitangents;\n  }\n  if (vertexFormat.st) {\n    topSt = topBottomGeo.attributes.st.values;\n    textures.set(topSt);\n    textures.set(topSt, (length / 3) * 2);\n    topBottomGeo.attributes.st.values = textures;\n  }\n\n  var indices = topBottomGeo.indices;\n  var indicesLength = indices.length;\n  var posLength = length / 3;\n  var newIndices = IndexDatatype.createTypedArray(\n    newLength / 3,\n    indicesLength * 2\n  );\n  newIndices.set(indices);\n  for (i = 0; i < indicesLength; i += 3) {\n    newIndices[i + indicesLength] = indices[i + 2] + posLength;\n    newIndices[i + 1 + indicesLength] = indices[i + 1] + posLength;\n    newIndices[i + 2 + indicesLength] = indices[i] + posLength;\n  }\n  topBottomGeo.indices = newIndices;\n\n  var northCap = computedOptions.northCap;\n  var southCap = computedOptions.southCap;\n\n  var rowHeight = height;\n  var widthMultiplier = 2;\n  var perimeterPositions = 0;\n  var corners = 4;\n  var dupliateCorners = 4;\n  if (northCap) {\n    widthMultiplier -= 1;\n    rowHeight -= 1;\n    perimeterPositions += 1;\n    corners -= 2;\n    dupliateCorners -= 1;\n  }\n  if (southCap) {\n    widthMultiplier -= 1;\n    rowHeight -= 1;\n    perimeterPositions += 1;\n    corners -= 2;\n    dupliateCorners -= 1;\n  }\n  perimeterPositions += widthMultiplier * width + 2 * rowHeight - corners;\n\n  var wallCount = (perimeterPositions + dupliateCorners) * 2;\n\n  var wallPositions = new Float64Array(wallCount * 3);\n  var wallExtrudeNormals = shadowVolume\n    ? new Float32Array(wallCount * 3)\n    : undefined;\n  var wallOffsetAttribute = hasOffsets ? new Uint8Array(wallCount) : undefined;\n  var wallTextures = vertexFormat.st\n    ? new Float32Array(wallCount * 2)\n    : undefined;\n\n  var computeTopOffsets = offsetAttributeValue === GeometryOffsetAttribute.TOP;\n  if (hasOffsets && !computeTopOffsets) {\n    offsetValue = offsetAttributeValue === GeometryOffsetAttribute.ALL ? 1 : 0;\n    wallOffsetAttribute = arrayFill(wallOffsetAttribute, offsetValue);\n  }\n\n  var posIndex = 0;\n  var stIndex = 0;\n  var extrudeNormalIndex = 0;\n  var wallOffsetIndex = 0;\n  var area = width * rowHeight;\n  var threeI;\n  for (i = 0; i < area; i += width) {\n    threeI = i * 3;\n    wallPositions = addWallPositions(\n      wallPositions,\n      posIndex,\n      threeI,\n      topPositions,\n      bottomPositions\n    );\n    posIndex += 6;\n    if (vertexFormat.st) {\n      wallTextures = addWallTextureCoordinates(\n        wallTextures,\n        stIndex,\n        i * 2,\n        topSt\n      );\n      stIndex += 4;\n    }\n    if (shadowVolume) {\n      extrudeNormalIndex += 3;\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n    }\n    if (computeTopOffsets) {\n      wallOffsetAttribute[wallOffsetIndex++] = 1;\n      wallOffsetIndex += 1;\n    }\n  }\n\n  if (!southCap) {\n    for (i = area - width; i < area; i++) {\n      threeI = i * 3;\n      wallPositions = addWallPositions(\n        wallPositions,\n        posIndex,\n        threeI,\n        topPositions,\n        bottomPositions\n      );\n      posIndex += 6;\n      if (vertexFormat.st) {\n        wallTextures = addWallTextureCoordinates(\n          wallTextures,\n          stIndex,\n          i * 2,\n          topSt\n        );\n        stIndex += 4;\n      }\n      if (shadowVolume) {\n        extrudeNormalIndex += 3;\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n      }\n      if (computeTopOffsets) {\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\n        wallOffsetIndex += 1;\n      }\n    }\n  } else {\n    var southIndex = northCap ? area + 1 : area;\n    threeI = southIndex * 3;\n\n    for (i = 0; i < 2; i++) {\n      // duplicate corner points\n      wallPositions = addWallPositions(\n        wallPositions,\n        posIndex,\n        threeI,\n        topPositions,\n        bottomPositions\n      );\n      posIndex += 6;\n      if (vertexFormat.st) {\n        wallTextures = addWallTextureCoordinates(\n          wallTextures,\n          stIndex,\n          southIndex * 2,\n          topSt\n        );\n        stIndex += 4;\n      }\n      if (shadowVolume) {\n        extrudeNormalIndex += 3;\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n      }\n      if (computeTopOffsets) {\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\n        wallOffsetIndex += 1;\n      }\n    }\n  }\n\n  for (i = area - 1; i > 0; i -= width) {\n    threeI = i * 3;\n    wallPositions = addWallPositions(\n      wallPositions,\n      posIndex,\n      threeI,\n      topPositions,\n      bottomPositions\n    );\n    posIndex += 6;\n    if (vertexFormat.st) {\n      wallTextures = addWallTextureCoordinates(\n        wallTextures,\n        stIndex,\n        i * 2,\n        topSt\n      );\n      stIndex += 4;\n    }\n    if (shadowVolume) {\n      extrudeNormalIndex += 3;\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n    }\n    if (computeTopOffsets) {\n      wallOffsetAttribute[wallOffsetIndex++] = 1;\n      wallOffsetIndex += 1;\n    }\n  }\n\n  if (!northCap) {\n    for (i = width - 1; i >= 0; i--) {\n      threeI = i * 3;\n      wallPositions = addWallPositions(\n        wallPositions,\n        posIndex,\n        threeI,\n        topPositions,\n        bottomPositions\n      );\n      posIndex += 6;\n      if (vertexFormat.st) {\n        wallTextures = addWallTextureCoordinates(\n          wallTextures,\n          stIndex,\n          i * 2,\n          topSt\n        );\n        stIndex += 4;\n      }\n      if (shadowVolume) {\n        extrudeNormalIndex += 3;\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n      }\n      if (computeTopOffsets) {\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\n        wallOffsetIndex += 1;\n      }\n    }\n  } else {\n    var northIndex = area;\n    threeI = northIndex * 3;\n\n    for (i = 0; i < 2; i++) {\n      // duplicate corner points\n      wallPositions = addWallPositions(\n        wallPositions,\n        posIndex,\n        threeI,\n        topPositions,\n        bottomPositions\n      );\n      posIndex += 6;\n      if (vertexFormat.st) {\n        wallTextures = addWallTextureCoordinates(\n          wallTextures,\n          stIndex,\n          northIndex * 2,\n          topSt\n        );\n        stIndex += 4;\n      }\n      if (shadowVolume) {\n        extrudeNormalIndex += 3;\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n      }\n      if (computeTopOffsets) {\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\n        wallOffsetIndex += 1;\n      }\n    }\n  }\n\n  var geo = calculateAttributesWall(wallPositions, vertexFormat, ellipsoid);\n\n  if (vertexFormat.st) {\n    geo.attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: wallTextures,\n    });\n  }\n  if (shadowVolume) {\n    geo.attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: wallExtrudeNormals,\n    });\n  }\n  if (hasOffsets) {\n    geo.attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: wallOffsetAttribute,\n    });\n  }\n\n  var wallIndices = IndexDatatype.createTypedArray(\n    wallCount,\n    perimeterPositions * 6\n  );\n\n  var upperLeft;\n  var lowerLeft;\n  var lowerRight;\n  var upperRight;\n  length = wallPositions.length / 3;\n  var index = 0;\n  for (i = 0; i < length - 1; i += 2) {\n    upperLeft = i;\n    upperRight = (upperLeft + 2) % length;\n    var p1 = Cartesian3.fromArray(wallPositions, upperLeft * 3, v1Scratch);\n    var p2 = Cartesian3.fromArray(wallPositions, upperRight * 3, v2Scratch);\n    if (Cartesian3.equalsEpsilon(p1, p2, CesiumMath.EPSILON10)) {\n      continue;\n    }\n    lowerLeft = (upperLeft + 1) % length;\n    lowerRight = (lowerLeft + 2) % length;\n    wallIndices[index++] = upperLeft;\n    wallIndices[index++] = lowerLeft;\n    wallIndices[index++] = upperRight;\n    wallIndices[index++] = upperRight;\n    wallIndices[index++] = lowerLeft;\n    wallIndices[index++] = lowerRight;\n  }\n\n  geo.indices = wallIndices;\n\n  geo = GeometryPipeline.combineInstances([\n    new GeometryInstance({\n      geometry: topBottomGeo,\n    }),\n    new GeometryInstance({\n      geometry: geo,\n    }),\n  ]);\n\n  return geo[0];\n}\n\nvar scratchRectanglePoints = [\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n];\nvar nwScratch = new Cartographic();\nvar stNwScratch = new Cartographic();\nfunction computeRectangle(rectangle, granularity, rotation, ellipsoid, result) {\n  if (rotation === 0.0) {\n    return Rectangle.clone(rectangle, result);\n  }\n\n  var computedOptions = RectangleGeometryLibrary.computeOptions(\n    rectangle,\n    granularity,\n    rotation,\n    0,\n    rectangleScratch,\n    nwScratch\n  );\n\n  var height = computedOptions.height;\n  var width = computedOptions.width;\n\n  var positions = scratchRectanglePoints;\n  RectangleGeometryLibrary.computePosition(\n    computedOptions,\n    ellipsoid,\n    false,\n    0,\n    0,\n    positions[0]\n  );\n  RectangleGeometryLibrary.computePosition(\n    computedOptions,\n    ellipsoid,\n    false,\n    0,\n    width - 1,\n    positions[1]\n  );\n  RectangleGeometryLibrary.computePosition(\n    computedOptions,\n    ellipsoid,\n    false,\n    height - 1,\n    0,\n    positions[2]\n  );\n  RectangleGeometryLibrary.computePosition(\n    computedOptions,\n    ellipsoid,\n    false,\n    height - 1,\n    width - 1,\n    positions[3]\n  );\n\n  return Rectangle.fromCartesianArray(positions, ellipsoid, result);\n}\n\n/**\n * A description of a cartographic rectangle on an ellipsoid centered at the origin. Rectangle geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias RectangleGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Number} [options.height=0.0] The distance in meters between the rectangle and the ellipsoid surface.\n * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\n * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n * @param {Number} [options.extrudedHeight] The distance in meters between the rectangle's extruded face and the ellipsoid surface.\n *\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>options.rectangle.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>options.rectangle.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>options.rectangle.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be greater than <code>options.rectangle.south</code>.\n *\n * @see RectangleGeometry#createGeometry\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Rectangle.html|Cesium Sandcastle Rectangle Demo}\n *\n * @example\n * // 1. create a rectangle\n * var rectangle = new Cesium.RectangleGeometry({\n *   ellipsoid : Cesium.Ellipsoid.WGS84,\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n *   height : 10000.0\n * });\n * var geometry = Cesium.RectangleGeometry.createGeometry(rectangle);\n *\n * // 2. create an extruded rectangle without a top\n * var rectangle = new Cesium.RectangleGeometry({\n *   ellipsoid : Cesium.Ellipsoid.WGS84,\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n *   height : 10000.0,\n *   extrudedHeight: 300000\n * });\n * var geometry = Cesium.RectangleGeometry.createGeometry(rectangle);\n */\nfunction RectangleGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var rectangle = options.rectangle;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Rectangle.validate(rectangle);\n  if (rectangle.north < rectangle.south) {\n    throw new DeveloperError(\n      \"options.rectangle.north must be greater than or equal to options.rectangle.south\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var height = defaultValue(options.height, 0.0);\n  var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  this._rectangle = Rectangle.clone(rectangle);\n  this._granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  this._ellipsoid = Ellipsoid.clone(\n    defaultValue(options.ellipsoid, Ellipsoid.WGS84)\n  );\n  this._surfaceHeight = Math.max(height, extrudedHeight);\n  this._rotation = defaultValue(options.rotation, 0.0);\n  this._stRotation = defaultValue(options.stRotation, 0.0);\n  this._vertexFormat = VertexFormat.clone(\n    defaultValue(options.vertexFormat, VertexFormat.DEFAULT)\n  );\n  this._extrudedHeight = Math.min(height, extrudedHeight);\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\n  this._workerName = \"createRectangleGeometry\";\n  this._offsetAttribute = options.offsetAttribute;\n  this._rotatedRectangle = undefined;\n\n  this._textureCoordinateRotationPoints = undefined;\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nRectangleGeometry.packedLength =\n  Rectangle.packedLength +\n  Ellipsoid.packedLength +\n  VertexFormat.packedLength +\n  7;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {RectangleGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nRectangleGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Rectangle.pack(value._rectangle, array, startingIndex);\n  startingIndex += Rectangle.packedLength;\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._surfaceHeight;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._stRotation;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nvar scratchRectangle = new Rectangle();\nvar scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nvar scratchOptions = {\n  rectangle: scratchRectangle,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  granularity: undefined,\n  height: undefined,\n  rotation: undefined,\n  stRotation: undefined,\n  extrudedHeight: undefined,\n  shadowVolume: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {RectangleGeometry} [result] The object into which to store the result.\n * @returns {RectangleGeometry} The modified result parameter or a new RectangleGeometry instance if one was not provided.\n */\nRectangleGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var rectangle = Rectangle.unpack(array, startingIndex, scratchRectangle);\n  startingIndex += Rectangle.packedLength;\n\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  var vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  var granularity = array[startingIndex++];\n  var surfaceHeight = array[startingIndex++];\n  var rotation = array[startingIndex++];\n  var stRotation = array[startingIndex++];\n  var extrudedHeight = array[startingIndex++];\n  var shadowVolume = array[startingIndex++] === 1.0;\n  var offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.granularity = granularity;\n    scratchOptions.height = surfaceHeight;\n    scratchOptions.rotation = rotation;\n    scratchOptions.stRotation = stRotation;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.shadowVolume = shadowVolume;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n\n    return new RectangleGeometry(scratchOptions);\n  }\n\n  result._rectangle = Rectangle.clone(rectangle, result._rectangle);\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._granularity = granularity;\n  result._surfaceHeight = surfaceHeight;\n  result._rotation = rotation;\n  result._stRotation = stRotation;\n  result._extrudedHeight = extrudedHeight;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the bounding rectangle based on the provided options\n *\n * @param {Object} options Object with the following properties:\n * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\n * @param {Rectangle} [result] An object in which to store the result.\n *\n * @returns {Rectangle} The result rectangle\n */\nRectangleGeometry.computeRectangle = function (options, result) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var rectangle = options.rectangle;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Rectangle.validate(rectangle);\n  if (rectangle.north < rectangle.south) {\n    throw new DeveloperError(\n      \"options.rectangle.north must be greater than or equal to options.rectangle.south\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var rotation = defaultValue(options.rotation, 0.0);\n\n  return computeRectangle(rectangle, granularity, rotation, ellipsoid, result);\n};\n\nvar tangentRotationMatrixScratch = new Matrix3();\nvar quaternionScratch = new Quaternion();\nvar centerScratch = new Cartographic();\n/**\n * Computes the geometric representation of a rectangle, including its vertices, indices, and a bounding sphere.\n *\n * @param {RectangleGeometry} rectangleGeometry A description of the rectangle.\n * @returns {Geometry|undefined} The computed vertices and indices.\n *\n * @exception {DeveloperError} Rotated rectangle is invalid.\n */\nRectangleGeometry.createGeometry = function (rectangleGeometry) {\n  if (\n    CesiumMath.equalsEpsilon(\n      rectangleGeometry._rectangle.north,\n      rectangleGeometry._rectangle.south,\n      CesiumMath.EPSILON10\n    ) ||\n    CesiumMath.equalsEpsilon(\n      rectangleGeometry._rectangle.east,\n      rectangleGeometry._rectangle.west,\n      CesiumMath.EPSILON10\n    )\n  ) {\n    return undefined;\n  }\n\n  var rectangle = rectangleGeometry._rectangle;\n  var ellipsoid = rectangleGeometry._ellipsoid;\n  var rotation = rectangleGeometry._rotation;\n  var stRotation = rectangleGeometry._stRotation;\n  var vertexFormat = rectangleGeometry._vertexFormat;\n\n  var computedOptions = RectangleGeometryLibrary.computeOptions(\n    rectangle,\n    rectangleGeometry._granularity,\n    rotation,\n    stRotation,\n    rectangleScratch,\n    nwScratch,\n    stNwScratch\n  );\n\n  var tangentRotationMatrix = tangentRotationMatrixScratch;\n  if (stRotation !== 0 || rotation !== 0) {\n    var center = Rectangle.center(rectangle, centerScratch);\n    var axis = ellipsoid.geodeticSurfaceNormalCartographic(center, v1Scratch);\n    Quaternion.fromAxisAngle(axis, -stRotation, quaternionScratch);\n    Matrix3.fromQuaternion(quaternionScratch, tangentRotationMatrix);\n  } else {\n    Matrix3.clone(Matrix3.IDENTITY, tangentRotationMatrix);\n  }\n\n  var surfaceHeight = rectangleGeometry._surfaceHeight;\n  var extrudedHeight = rectangleGeometry._extrudedHeight;\n  var extrude = !CesiumMath.equalsEpsilon(\n    surfaceHeight,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2\n  );\n\n  computedOptions.lonScalar = 1.0 / rectangleGeometry._rectangle.width;\n  computedOptions.latScalar = 1.0 / rectangleGeometry._rectangle.height;\n  computedOptions.tangentRotationMatrix = tangentRotationMatrix;\n\n  var geometry;\n  var boundingSphere;\n  rectangle = rectangleGeometry._rectangle;\n  if (extrude) {\n    geometry = constructExtrudedRectangle(rectangleGeometry, computedOptions);\n    var topBS = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      surfaceHeight,\n      topBoundingSphere\n    );\n    var bottomBS = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      extrudedHeight,\n      bottomBoundingSphere\n    );\n    boundingSphere = BoundingSphere.union(topBS, bottomBS);\n  } else {\n    geometry = constructRectangle(rectangleGeometry, computedOptions);\n    geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n      geometry.attributes.position.values,\n      surfaceHeight,\n      ellipsoid,\n      false\n    );\n\n    if (defined(rectangleGeometry._offsetAttribute)) {\n      var length = geometry.attributes.position.values.length;\n      var applyOffset = new Uint8Array(length / 3);\n      var offsetValue =\n        rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      arrayFill(applyOffset, offsetValue);\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n\n    boundingSphere = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      surfaceHeight\n    );\n  }\n\n  if (!vertexFormat.position) {\n    delete geometry.attributes.position;\n  }\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: boundingSphere,\n    offsetAttribute: rectangleGeometry._offsetAttribute,\n  });\n};\n\n/**\n * @private\n */\nRectangleGeometry.createShadowVolume = function (\n  rectangleGeometry,\n  minHeightFunc,\n  maxHeightFunc\n) {\n  var granularity = rectangleGeometry._granularity;\n  var ellipsoid = rectangleGeometry._ellipsoid;\n\n  var minHeight = minHeightFunc(granularity, ellipsoid);\n  var maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n  return new RectangleGeometry({\n    rectangle: rectangleGeometry._rectangle,\n    rotation: rectangleGeometry._rotation,\n    ellipsoid: ellipsoid,\n    stRotation: rectangleGeometry._stRotation,\n    granularity: granularity,\n    extrudedHeight: maxHeight,\n    height: minHeight,\n    vertexFormat: VertexFormat.POSITION_ONLY,\n    shadowVolume: true,\n  });\n};\n\nvar unrotatedTextureRectangleScratch = new Rectangle();\nvar points2DScratch = [new Cartesian2(), new Cartesian2(), new Cartesian2()];\nvar rotation2DScratch = new Matrix2();\nvar rectangleCenterScratch = new Cartographic();\n\nfunction textureCoordinateRotationPoints(rectangleGeometry) {\n  if (rectangleGeometry._stRotation === 0.0) {\n    return [0, 0, 0, 1, 1, 0];\n  }\n\n  var rectangle = Rectangle.clone(\n    rectangleGeometry._rectangle,\n    unrotatedTextureRectangleScratch\n  );\n  var granularity = rectangleGeometry._granularity;\n  var ellipsoid = rectangleGeometry._ellipsoid;\n\n  // Rotate to align the texture coordinates with ENU\n  var rotation = rectangleGeometry._rotation - rectangleGeometry._stRotation;\n\n  var unrotatedTextureRectangle = computeRectangle(\n    rectangle,\n    granularity,\n    rotation,\n    ellipsoid,\n    unrotatedTextureRectangleScratch\n  );\n\n  // Assume a computed \"east-north\" texture coordinate system based on spherical or planar tricks, bounded by `boundingRectangle`.\n  // The \"desired\" texture coordinate system forms an oriented rectangle (un-oriented computed) around the geometry that completely and tightly bounds it.\n  // We want to map from the \"east-north\" texture coordinate system into the \"desired\" system using a pair of lines (analagous planes in 2D)\n  // Compute 3 corners of the \"desired\" texture coordinate system in \"east-north\" texture space by the following in cartographic space:\n  // - rotate 3 of the corners in unrotatedTextureRectangle by stRotation around the center of the bounding rectangle\n  // - apply the \"east-north\" system's normalization formula to the rotated cartographics, even though this is likely to produce values outside [0-1].\n  // This gives us a set of points in the \"east-north\" texture coordinate system that can be used to map \"east-north\" texture coordinates to \"desired.\"\n\n  var points2D = points2DScratch;\n  points2D[0].x = unrotatedTextureRectangle.west;\n  points2D[0].y = unrotatedTextureRectangle.south;\n\n  points2D[1].x = unrotatedTextureRectangle.west;\n  points2D[1].y = unrotatedTextureRectangle.north;\n\n  points2D[2].x = unrotatedTextureRectangle.east;\n  points2D[2].y = unrotatedTextureRectangle.south;\n\n  var boundingRectangle = rectangleGeometry.rectangle;\n  var toDesiredInComputed = Matrix2.fromRotation(\n    rectangleGeometry._stRotation,\n    rotation2DScratch\n  );\n  var boundingRectangleCenter = Rectangle.center(\n    boundingRectangle,\n    rectangleCenterScratch\n  );\n\n  for (var i = 0; i < 3; ++i) {\n    var point2D = points2D[i];\n    point2D.x -= boundingRectangleCenter.longitude;\n    point2D.y -= boundingRectangleCenter.latitude;\n    Matrix2.multiplyByVector(toDesiredInComputed, point2D, point2D);\n    point2D.x += boundingRectangleCenter.longitude;\n    point2D.y += boundingRectangleCenter.latitude;\n\n    // Convert point into east-north texture coordinate space\n    point2D.x = (point2D.x - boundingRectangle.west) / boundingRectangle.width;\n    point2D.y =\n      (point2D.y - boundingRectangle.south) / boundingRectangle.height;\n  }\n\n  var minXYCorner = points2D[0];\n  var maxYCorner = points2D[1];\n  var maxXCorner = points2D[2];\n  var result = new Array(6);\n  Cartesian2.pack(minXYCorner, result);\n  Cartesian2.pack(maxYCorner, result, 2);\n  Cartesian2.pack(maxXCorner, result, 4);\n  return result;\n}\n\nObject.defineProperties(RectangleGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function () {\n      if (!defined(this._rotatedRectangle)) {\n        this._rotatedRectangle = computeRectangle(\n          this._rectangle,\n          this._granularity,\n          this._rotation,\n          this._ellipsoid\n        );\n      }\n      return this._rotatedRectangle;\n    },\n  },\n  /**\n   * For remapping texture coordinates when rendering RectangleGeometries as GroundPrimitives.\n   * This version permits skew in textures by computing offsets directly in cartographic space and\n   * more accurately approximates rendering RectangleGeometries with height as standard Primitives.\n   * @see Geometry#_textureCoordinateRotationPoints\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function () {\n      if (!defined(this._textureCoordinateRotationPoints)) {\n        this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(\n          this\n        );\n      }\n      return this._textureCoordinateRotationPoints;\n    },\n  },\n});\nexport default RectangleGeometry;\n"]},"metadata":{},"sourceType":"module"}