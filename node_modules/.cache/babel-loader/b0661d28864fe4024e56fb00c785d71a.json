{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Color from \"../Core/Color.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport ReferenceFrame from \"../Core/ReferenceFrame.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TimeInterval from \"../Core/TimeInterval.js\";\nimport TimeIntervalCollection from \"../Core/TimeIntervalCollection.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport HorizontalOrigin from \"../Scene/HorizontalOrigin.js\";\nimport VerticalOrigin from \"../Scene/VerticalOrigin.js\";\nimport when from \"../ThirdParty/when.js\";\nimport zip from \"../ThirdParty/zip.js\";\nimport BillboardGraphics from \"./BillboardGraphics.js\";\nimport CompositePositionProperty from \"./CompositePositionProperty.js\";\nimport ModelGraphics from \"./ModelGraphics.js\";\nimport RectangleGraphics from \"./RectangleGraphics.js\";\nimport SampledPositionProperty from \"./SampledPositionProperty.js\";\nimport SampledProperty from \"./SampledProperty.js\";\nimport ScaledPositionProperty from \"./ScaledPositionProperty.js\";\nvar BILLBOARD_SIZE = 32;\nvar kmlNamespace = \"http://www.opengis.net/kml/2.2\";\nvar gxNamespace = \"http://www.google.com/kml/ext/2.2\";\nvar xmlnsNamespace = \"http://www.w3.org/2000/xmlns/\"; //\n// Handles files external to the KML (eg. textures and models)\n//\n\nfunction ExternalFileHandler(modelCallback) {\n  this._files = {};\n  this._promises = [];\n  this._count = 0;\n  this._modelCallback = modelCallback;\n}\n\nvar imageTypeRegex = /^data:image\\/([^,;]+)/;\n\nExternalFileHandler.prototype.texture = function (texture) {\n  var that = this;\n  var filename;\n\n  if (typeof texture === \"string\" || texture instanceof Resource) {\n    texture = Resource.createIfNeeded(texture);\n\n    if (!texture.isDataUri) {\n      return texture.url;\n    } // If its a data URI try and get the correct extension and then fetch the blob\n\n\n    var regexResult = texture.url.match(imageTypeRegex);\n    filename = \"texture_\" + ++this._count;\n\n    if (defined(regexResult)) {\n      filename += \".\" + regexResult[1];\n    }\n\n    var promise = texture.fetchBlob().then(function (blob) {\n      that._files[filename] = blob;\n    });\n\n    this._promises.push(promise);\n\n    return filename;\n  }\n\n  if (texture instanceof HTMLCanvasElement) {\n    var deferred = when.defer();\n\n    this._promises.push(deferred.promise);\n\n    filename = \"texture_\" + ++this._count + \".png\";\n    texture.toBlob(function (blob) {\n      that._files[filename] = blob;\n      deferred.resolve();\n    });\n    return filename;\n  }\n\n  return \"\";\n};\n\nfunction getModelBlobHander(that, filename) {\n  return function (blob) {\n    that._files[filename] = blob;\n  };\n}\n\nExternalFileHandler.prototype.model = function (model, time) {\n  var modelCallback = this._modelCallback;\n\n  if (!defined(modelCallback)) {\n    throw new RuntimeError(\"Encountered a model entity while exporting to KML, but no model callback was supplied.\");\n  }\n\n  var externalFiles = {};\n  var url = modelCallback(model, time, externalFiles); // Iterate through external files and add them to our list once the promise resolves\n\n  for (var filename in externalFiles) {\n    if (externalFiles.hasOwnProperty(filename)) {\n      var promise = when(externalFiles[filename]);\n\n      this._promises.push(promise);\n\n      promise.then(getModelBlobHander(this, filename));\n    }\n  }\n\n  return url;\n};\n\nObject.defineProperties(ExternalFileHandler.prototype, {\n  promise: {\n    get: function () {\n      return when.all(this._promises);\n    }\n  },\n  files: {\n    get: function () {\n      return this._files;\n    }\n  }\n}); //\n// Handles getting values from properties taking the desired time and default values into account\n//\n\nfunction ValueGetter(time) {\n  this._time = time;\n}\n\nValueGetter.prototype.get = function (property, defaultVal, result) {\n  var value;\n\n  if (defined(property)) {\n    value = defined(property.getValue) ? property.getValue(this._time, result) : property;\n  }\n\n  return defaultValue(value, defaultVal);\n};\n\nValueGetter.prototype.getColor = function (property, defaultVal) {\n  var result = this.get(property, defaultVal);\n\n  if (defined(result)) {\n    return colorToString(result);\n  }\n};\n\nValueGetter.prototype.getMaterialType = function (property) {\n  if (!defined(property)) {\n    return;\n  }\n\n  return property.getType(this._time);\n}; //\n// Caches styles so we don't generate a ton of duplicate styles\n//\n\n\nfunction StyleCache() {\n  this._ids = {};\n  this._styles = {};\n  this._count = 0;\n}\n\nStyleCache.prototype.get = function (element) {\n  var ids = this._ids;\n  var key = element.innerHTML;\n\n  if (defined(ids[key])) {\n    return ids[key];\n  }\n\n  var styleId = \"style-\" + ++this._count;\n  element.setAttribute(\"id\", styleId); // Store with #\n\n  styleId = \"#\" + styleId;\n  ids[key] = styleId;\n  this._styles[key] = element;\n  return styleId;\n};\n\nStyleCache.prototype.save = function (parentElement) {\n  var styles = this._styles;\n  var firstElement = parentElement.childNodes[0];\n\n  for (var key in styles) {\n    if (styles.hasOwnProperty(key)) {\n      parentElement.insertBefore(styles[key], firstElement);\n    }\n  }\n}; //\n// Manages the generation of IDs because an entity may have geometry and a Folder for children\n//\n\n\nfunction IdManager() {\n  this._ids = {};\n}\n\nIdManager.prototype.get = function (id) {\n  if (!defined(id)) {\n    return this.get(createGuid());\n  }\n\n  var ids = this._ids;\n\n  if (!defined(ids[id])) {\n    ids[id] = 0;\n    return id;\n  }\n\n  return id.toString() + \"-\" + ++ids[id];\n};\n/**\n * Exports an EntityCollection as a KML document. Only Point, Billboard, Model, Path, Polygon, Polyline geometries\n * will be exported. Note that there is not a 1 to 1 mapping of Entity properties to KML Feature properties. For\n * example, entity properties that are time dynamic but cannot be dynamic in KML are exported with their values at\n * options.time or the beginning of the EntityCollection's time interval if not specified. For time-dynamic properties\n * that are supported in KML, we use the samples if it is a {@link SampledProperty} otherwise we sample the value using\n * the options.sampleDuration. Point, Billboard, Model and Path geometries with time-dynamic positions will be exported\n * as gx:Track Features. Not all Materials are representable in KML, so for more advanced Materials just the primary\n * color is used. Canvas objects are exported as PNG images.\n *\n * @exports exportKml\n *\n * @param {Object} options An object with the following properties:\n * @param {EntityCollection} options.entities The EntityCollection to export as KML.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for the output file.\n * @param {exportKml~ModelCallback} [options.modelCallback] A callback that will be called with a {@link ModelGraphics} instance and should return the URI to use in the KML. Required if a model exists in the entity collection.\n * @param {JulianDate} [options.time=entities.computeAvailability().start] The time value to use to get properties that are not time varying in KML.\n * @param {TimeInterval} [options.defaultAvailability=entities.computeAvailability()] The interval that will be sampled if an entity doesn't have an availability.\n * @param {Number} [options.sampleDuration=60] The number of seconds to sample properties that are varying in KML.\n * @param {Boolean} [options.kmz=false] If true KML and external files will be compressed into a kmz file.\n *\n * @returns {Promise<Object>} A promise that resolved to an object containing the KML string and a dictionary of external file blobs, or a kmz file as a blob if options.kmz is true.\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Export%20KML.html|Cesium Sandcastle KML Export Demo}\n * @example\n * Cesium.exportKml({\n *      entities: entityCollection\n *  })\n *   .then(function(result) {\n *     // The XML string is in result.kml\n *\n *     var externalFiles = result.externalFiles\n *     for(var file in externalFiles) {\n *       // file is the name of the file used in the KML document as the href\n *       // externalFiles[file] is a blob with the contents of the file\n *     }\n *   });\n *\n */\n\n\nfunction exportKml(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var entities = options.entities;\n  var kmz = defaultValue(options.kmz, false); //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(entities)) {\n    throw new DeveloperError(\"entities is required.\");\n  } //>>includeEnd('debug');\n  // Get the state that is passed around during the recursion\n  // This is separated out for testing.\n\n\n  var state = exportKml._createState(options); // Filter EntityCollection so we only have top level entities\n\n\n  var rootEntities = entities.values.filter(function (entity) {\n    return !defined(entity.parent);\n  }); // Add the <Document>\n\n  var kmlDoc = state.kmlDoc;\n  var kmlElement = kmlDoc.documentElement;\n  kmlElement.setAttributeNS(xmlnsNamespace, \"xmlns:gx\", gxNamespace);\n  var kmlDocumentElement = kmlDoc.createElement(\"Document\");\n  kmlElement.appendChild(kmlDocumentElement); // Create the KML Hierarchy\n\n  recurseEntities(state, kmlDocumentElement, rootEntities); // Write out the <Style> elements\n\n  state.styleCache.save(kmlDocumentElement); // Once all the blobs have resolved return the KML string along with the blob collection\n\n  var externalFileHandler = state.externalFileHandler;\n  return externalFileHandler.promise.then(function () {\n    var serializer = new XMLSerializer();\n    var kmlString = serializer.serializeToString(state.kmlDoc);\n\n    if (kmz) {\n      return createKmz(kmlString, externalFileHandler.files);\n    }\n\n    return {\n      kml: kmlString,\n      externalFiles: externalFileHandler.files\n    };\n  });\n}\n\nfunction createKmz(kmlString, externalFiles) {\n  var deferred = when.defer();\n  zip.createWriter(new zip.BlobWriter(), function (writer) {\n    // We need to only write one file at a time so the zip doesn't get corrupted\n    addKmlToZip(writer, kmlString).then(function () {\n      var keys = Object.keys(externalFiles);\n      return addExternalFilesToZip(writer, keys, externalFiles, 0);\n    }).then(function () {\n      writer.close(function (blob) {\n        deferred.resolve({\n          kmz: blob\n        });\n      });\n    });\n  });\n  return deferred.promise;\n}\n\nfunction addKmlToZip(writer, kmlString) {\n  var deferred = when.defer();\n  writer.add(\"doc.kml\", new zip.TextReader(kmlString), function () {\n    deferred.resolve();\n  });\n  return deferred.promise;\n}\n\nfunction addExternalFilesToZip(writer, keys, externalFiles, index) {\n  if (keys.length === index) {\n    return;\n  }\n\n  var filename = keys[index];\n  var deferred = when.defer();\n  writer.add(filename, new zip.BlobReader(externalFiles[filename]), function () {\n    deferred.resolve();\n  });\n  return deferred.promise.then(function () {\n    return addExternalFilesToZip(writer, keys, externalFiles, index + 1);\n  });\n}\n\nexportKml._createState = function (options) {\n  var entities = options.entities;\n  var styleCache = new StyleCache(); // Use the start time as the default because just in case they define\n  //  properties with an interval even if they don't change.\n\n  var entityAvailability = entities.computeAvailability();\n  var time = defined(options.time) ? options.time : entityAvailability.start; // Figure out how we will sample dynamic position properties\n\n  var defaultAvailability = defaultValue(options.defaultAvailability, entityAvailability);\n  var sampleDuration = defaultValue(options.sampleDuration, 60); // Make sure we don't have infinite availability if we need to sample\n\n  if (defaultAvailability.start === Iso8601.MINIMUM_VALUE) {\n    if (defaultAvailability.stop === Iso8601.MAXIMUM_VALUE) {\n      // Infinite, so just use the default\n      defaultAvailability = new TimeInterval();\n    } else {\n      // No start time, so just sample 10 times before the stop\n      JulianDate.addSeconds(defaultAvailability.stop, -10 * sampleDuration, defaultAvailability.start);\n    }\n  } else if (defaultAvailability.stop === Iso8601.MAXIMUM_VALUE) {\n    // No stop time, so just sample 10 times after the start\n    JulianDate.addSeconds(defaultAvailability.start, 10 * sampleDuration, defaultAvailability.stop);\n  }\n\n  var externalFileHandler = new ExternalFileHandler(options.modelCallback);\n  var kmlDoc = document.implementation.createDocument(kmlNamespace, \"kml\");\n  return {\n    kmlDoc: kmlDoc,\n    ellipsoid: defaultValue(options.ellipsoid, Ellipsoid.WGS84),\n    idManager: new IdManager(),\n    styleCache: styleCache,\n    externalFileHandler: externalFileHandler,\n    time: time,\n    valueGetter: new ValueGetter(time),\n    sampleDuration: sampleDuration,\n    // Wrap it in a TimeIntervalCollection because that is what entity.availability is\n    defaultAvailability: new TimeIntervalCollection([defaultAvailability])\n  };\n};\n\nfunction recurseEntities(state, parentNode, entities) {\n  var kmlDoc = state.kmlDoc;\n  var styleCache = state.styleCache;\n  var valueGetter = state.valueGetter;\n  var idManager = state.idManager;\n  var count = entities.length;\n  var overlays;\n  var geometries;\n  var styles;\n\n  for (var i = 0; i < count; ++i) {\n    var entity = entities[i];\n    overlays = [];\n    geometries = [];\n    styles = [];\n    createPoint(state, entity, geometries, styles);\n    createLineString(state, entity.polyline, geometries, styles);\n    createPolygon(state, entity.rectangle, geometries, styles, overlays);\n    createPolygon(state, entity.polygon, geometries, styles, overlays);\n    createModel(state, entity, entity.model, geometries, styles);\n    var timeSpan;\n    var availability = entity.availability;\n\n    if (defined(availability)) {\n      timeSpan = kmlDoc.createElement(\"TimeSpan\");\n\n      if (!JulianDate.equals(availability.start, Iso8601.MINIMUM_VALUE)) {\n        timeSpan.appendChild(createBasicElementWithText(kmlDoc, \"begin\", JulianDate.toIso8601(availability.start)));\n      }\n\n      if (!JulianDate.equals(availability.stop, Iso8601.MAXIMUM_VALUE)) {\n        timeSpan.appendChild(createBasicElementWithText(kmlDoc, \"end\", JulianDate.toIso8601(availability.stop)));\n      }\n    }\n\n    for (var overlayIndex = 0; overlayIndex < overlays.length; ++overlayIndex) {\n      var overlay = overlays[overlayIndex];\n      overlay.setAttribute(\"id\", idManager.get(entity.id));\n      overlay.appendChild(createBasicElementWithText(kmlDoc, \"name\", entity.name));\n      overlay.appendChild(createBasicElementWithText(kmlDoc, \"visibility\", entity.show));\n      overlay.appendChild(createBasicElementWithText(kmlDoc, \"description\", entity.description));\n\n      if (defined(timeSpan)) {\n        overlay.appendChild(timeSpan);\n      }\n\n      parentNode.appendChild(overlay);\n    }\n\n    var geometryCount = geometries.length;\n\n    if (geometryCount > 0) {\n      var placemark = kmlDoc.createElement(\"Placemark\");\n      placemark.setAttribute(\"id\", idManager.get(entity.id));\n      var name = entity.name;\n      var labelGraphics = entity.label;\n\n      if (defined(labelGraphics)) {\n        var labelStyle = kmlDoc.createElement(\"LabelStyle\"); // KML only shows the name as a label, so just change the name if we need to show a label\n\n        var text = valueGetter.get(labelGraphics.text);\n        name = defined(text) && text.length > 0 ? text : name;\n        var color = valueGetter.getColor(labelGraphics.fillColor);\n\n        if (defined(color)) {\n          labelStyle.appendChild(createBasicElementWithText(kmlDoc, \"color\", color));\n          labelStyle.appendChild(createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\"));\n        }\n\n        var scale = valueGetter.get(labelGraphics.scale);\n\n        if (defined(scale)) {\n          labelStyle.appendChild(createBasicElementWithText(kmlDoc, \"scale\", scale));\n        }\n\n        styles.push(labelStyle);\n      }\n\n      placemark.appendChild(createBasicElementWithText(kmlDoc, \"name\", name));\n      placemark.appendChild(createBasicElementWithText(kmlDoc, \"visibility\", entity.show));\n      placemark.appendChild(createBasicElementWithText(kmlDoc, \"description\", entity.description));\n\n      if (defined(timeSpan)) {\n        placemark.appendChild(timeSpan);\n      }\n\n      parentNode.appendChild(placemark);\n      var styleCount = styles.length;\n\n      if (styleCount > 0) {\n        var style = kmlDoc.createElement(\"Style\");\n\n        for (var styleIndex = 0; styleIndex < styleCount; ++styleIndex) {\n          style.appendChild(styles[styleIndex]);\n        }\n\n        placemark.appendChild(createBasicElementWithText(kmlDoc, \"styleUrl\", styleCache.get(style)));\n      }\n\n      if (geometries.length === 1) {\n        placemark.appendChild(geometries[0]);\n      } else if (geometries.length > 1) {\n        var multigeometry = kmlDoc.createElement(\"MultiGeometry\");\n\n        for (var geometryIndex = 0; geometryIndex < geometryCount; ++geometryIndex) {\n          multigeometry.appendChild(geometries[geometryIndex]);\n        }\n\n        placemark.appendChild(multigeometry);\n      }\n    }\n\n    var children = entity._children;\n\n    if (children.length > 0) {\n      var folderNode = kmlDoc.createElement(\"Folder\");\n      folderNode.setAttribute(\"id\", idManager.get(entity.id));\n      folderNode.appendChild(createBasicElementWithText(kmlDoc, \"name\", entity.name));\n      folderNode.appendChild(createBasicElementWithText(kmlDoc, \"visibility\", entity.show));\n      folderNode.appendChild(createBasicElementWithText(kmlDoc, \"description\", entity.description));\n      parentNode.appendChild(folderNode);\n      recurseEntities(state, folderNode, children);\n    }\n  }\n}\n\nvar scratchCartesian3 = new Cartesian3();\nvar scratchCartographic = new Cartographic();\nvar scratchJulianDate = new JulianDate();\n\nfunction createPoint(state, entity, geometries, styles) {\n  var kmlDoc = state.kmlDoc;\n  var ellipsoid = state.ellipsoid;\n  var valueGetter = state.valueGetter;\n  var pointGraphics = defaultValue(entity.billboard, entity.point);\n\n  if (!defined(pointGraphics) && !defined(entity.path)) {\n    return;\n  } // If the point isn't constant then create gx:Track or gx:MultiTrack\n\n\n  var entityPositionProperty = entity.position;\n\n  if (!entityPositionProperty.isConstant) {\n    createTracks(state, entity, pointGraphics, geometries, styles);\n    return;\n  }\n\n  valueGetter.get(entityPositionProperty, undefined, scratchCartesian3);\n  var coordinates = createBasicElementWithText(kmlDoc, \"coordinates\", getCoordinates(scratchCartesian3, ellipsoid));\n  var pointGeometry = kmlDoc.createElement(\"Point\"); // Set altitude mode\n\n  var altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  altitudeMode.appendChild(getAltitudeMode(state, pointGraphics.heightReference));\n  pointGeometry.appendChild(altitudeMode);\n  pointGeometry.appendChild(coordinates);\n  geometries.push(pointGeometry); // Create style\n\n  var iconStyle = pointGraphics instanceof BillboardGraphics ? createIconStyleFromBillboard(state, pointGraphics) : createIconStyleFromPoint(state, pointGraphics);\n  styles.push(iconStyle);\n}\n\nfunction createTracks(state, entity, pointGraphics, geometries, styles) {\n  var kmlDoc = state.kmlDoc;\n  var ellipsoid = state.ellipsoid;\n  var valueGetter = state.valueGetter;\n  var intervals;\n  var entityPositionProperty = entity.position;\n  var useEntityPositionProperty = true;\n\n  if (entityPositionProperty instanceof CompositePositionProperty) {\n    intervals = entityPositionProperty.intervals;\n    useEntityPositionProperty = false;\n  } else {\n    intervals = defaultValue(entity.availability, state.defaultAvailability);\n  }\n\n  var isModel = pointGraphics instanceof ModelGraphics;\n  var i, j, times;\n  var tracks = [];\n\n  for (i = 0; i < intervals.length; ++i) {\n    var interval = intervals.get(i);\n    var positionProperty = useEntityPositionProperty ? entityPositionProperty : interval.data;\n    var trackAltitudeMode = kmlDoc.createElement(\"altitudeMode\"); // This is something that KML importing uses to handle clampToGround,\n    //  so just extract the internal property and set the altitudeMode.\n\n    if (positionProperty instanceof ScaledPositionProperty) {\n      positionProperty = positionProperty._value;\n      trackAltitudeMode.appendChild(getAltitudeMode(state, HeightReference.CLAMP_TO_GROUND));\n    } else if (defined(pointGraphics)) {\n      trackAltitudeMode.appendChild(getAltitudeMode(state, pointGraphics.heightReference));\n    } else {\n      // Path graphics only, which has no height reference\n      trackAltitudeMode.appendChild(getAltitudeMode(state, HeightReference.NONE));\n    }\n\n    var positionTimes = [];\n    var positionValues = [];\n\n    if (positionProperty.isConstant) {\n      valueGetter.get(positionProperty, undefined, scratchCartesian3);\n      var constCoordinates = createBasicElementWithText(kmlDoc, \"coordinates\", getCoordinates(scratchCartesian3, ellipsoid)); // This interval is constant so add a track with the same position\n\n      positionTimes.push(JulianDate.toIso8601(interval.start));\n      positionValues.push(constCoordinates);\n      positionTimes.push(JulianDate.toIso8601(interval.stop));\n      positionValues.push(constCoordinates);\n    } else if (positionProperty instanceof SampledPositionProperty) {\n      times = positionProperty._property._times;\n\n      for (j = 0; j < times.length; ++j) {\n        positionTimes.push(JulianDate.toIso8601(times[j]));\n        positionProperty.getValueInReferenceFrame(times[j], ReferenceFrame.FIXED, scratchCartesian3);\n        positionValues.push(getCoordinates(scratchCartesian3, ellipsoid));\n      }\n    } else if (positionProperty instanceof SampledProperty) {\n      times = positionProperty._times;\n      var values = positionProperty._values;\n\n      for (j = 0; j < times.length; ++j) {\n        positionTimes.push(JulianDate.toIso8601(times[j]));\n        Cartesian3.fromArray(values, j * 3, scratchCartesian3);\n        positionValues.push(getCoordinates(scratchCartesian3, ellipsoid));\n      }\n    } else {\n      var duration = state.sampleDuration;\n      interval.start.clone(scratchJulianDate);\n\n      if (!interval.isStartIncluded) {\n        JulianDate.addSeconds(scratchJulianDate, duration, scratchJulianDate);\n      }\n\n      var stopDate = interval.stop;\n\n      while (JulianDate.lessThan(scratchJulianDate, stopDate)) {\n        positionProperty.getValue(scratchJulianDate, scratchCartesian3);\n        positionTimes.push(JulianDate.toIso8601(scratchJulianDate));\n        positionValues.push(getCoordinates(scratchCartesian3, ellipsoid));\n        JulianDate.addSeconds(scratchJulianDate, duration, scratchJulianDate);\n      }\n\n      if (interval.isStopIncluded && JulianDate.equals(scratchJulianDate, stopDate)) {\n        positionProperty.getValue(scratchJulianDate, scratchCartesian3);\n        positionTimes.push(JulianDate.toIso8601(scratchJulianDate));\n        positionValues.push(getCoordinates(scratchCartesian3, ellipsoid));\n      }\n    }\n\n    var trackGeometry = kmlDoc.createElementNS(gxNamespace, \"Track\");\n    trackGeometry.appendChild(trackAltitudeMode);\n\n    for (var k = 0; k < positionTimes.length; ++k) {\n      var when = createBasicElementWithText(kmlDoc, \"when\", positionTimes[k]);\n      var coord = createBasicElementWithText(kmlDoc, \"coord\", positionValues[k], gxNamespace);\n      trackGeometry.appendChild(when);\n      trackGeometry.appendChild(coord);\n    }\n\n    if (isModel) {\n      trackGeometry.appendChild(createModelGeometry(state, pointGraphics));\n    }\n\n    tracks.push(trackGeometry);\n  } // If one track, then use it otherwise combine into a multitrack\n\n\n  if (tracks.length === 1) {\n    geometries.push(tracks[0]);\n  } else if (tracks.length > 1) {\n    var multiTrackGeometry = kmlDoc.createElementNS(gxNamespace, \"MultiTrack\");\n\n    for (i = 0; i < tracks.length; ++i) {\n      multiTrackGeometry.appendChild(tracks[i]);\n    }\n\n    geometries.push(multiTrackGeometry);\n  } // Create style\n\n\n  if (defined(pointGraphics) && !isModel) {\n    var iconStyle = pointGraphics instanceof BillboardGraphics ? createIconStyleFromBillboard(state, pointGraphics) : createIconStyleFromPoint(state, pointGraphics);\n    styles.push(iconStyle);\n  } // See if we have a line that needs to be drawn\n\n\n  var path = entity.path;\n\n  if (defined(path)) {\n    var width = valueGetter.get(path.width);\n    var material = path.material;\n\n    if (defined(material) || defined(width)) {\n      var lineStyle = kmlDoc.createElement(\"LineStyle\");\n\n      if (defined(width)) {\n        lineStyle.appendChild(createBasicElementWithText(kmlDoc, \"width\", width));\n      }\n\n      processMaterial(state, material, lineStyle);\n      styles.push(lineStyle);\n    }\n  }\n}\n\nfunction createIconStyleFromPoint(state, pointGraphics) {\n  var kmlDoc = state.kmlDoc;\n  var valueGetter = state.valueGetter;\n  var iconStyle = kmlDoc.createElement(\"IconStyle\");\n  var color = valueGetter.getColor(pointGraphics.color);\n\n  if (defined(color)) {\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"color\", color));\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\"));\n  }\n\n  var pixelSize = valueGetter.get(pointGraphics.pixelSize);\n\n  if (defined(pixelSize)) {\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"scale\", pixelSize / BILLBOARD_SIZE));\n  }\n\n  return iconStyle;\n}\n\nfunction createIconStyleFromBillboard(state, billboardGraphics) {\n  var kmlDoc = state.kmlDoc;\n  var valueGetter = state.valueGetter;\n  var externalFileHandler = state.externalFileHandler;\n  var iconStyle = kmlDoc.createElement(\"IconStyle\");\n  var image = valueGetter.get(billboardGraphics.image);\n\n  if (defined(image)) {\n    image = externalFileHandler.texture(image);\n    var icon = kmlDoc.createElement(\"Icon\");\n    icon.appendChild(createBasicElementWithText(kmlDoc, \"href\", image));\n    var imageSubRegion = valueGetter.get(billboardGraphics.imageSubRegion);\n\n    if (defined(imageSubRegion)) {\n      icon.appendChild(createBasicElementWithText(kmlDoc, \"x\", imageSubRegion.x, gxNamespace));\n      icon.appendChild(createBasicElementWithText(kmlDoc, \"y\", imageSubRegion.y, gxNamespace));\n      icon.appendChild(createBasicElementWithText(kmlDoc, \"w\", imageSubRegion.width, gxNamespace));\n      icon.appendChild(createBasicElementWithText(kmlDoc, \"h\", imageSubRegion.height, gxNamespace));\n    }\n\n    iconStyle.appendChild(icon);\n  }\n\n  var color = valueGetter.getColor(billboardGraphics.color);\n\n  if (defined(color)) {\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"color\", color));\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\"));\n  }\n\n  var scale = valueGetter.get(billboardGraphics.scale);\n\n  if (defined(scale)) {\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"scale\", scale));\n  }\n\n  var pixelOffset = valueGetter.get(billboardGraphics.pixelOffset);\n\n  if (defined(pixelOffset)) {\n    scale = defaultValue(scale, 1.0);\n    Cartesian2.divideByScalar(pixelOffset, scale, pixelOffset);\n    var width = valueGetter.get(billboardGraphics.width, BILLBOARD_SIZE);\n    var height = valueGetter.get(billboardGraphics.height, BILLBOARD_SIZE); // KML Hotspots are from the bottom left, but we work from the top left\n    // Move to left\n\n    var horizontalOrigin = valueGetter.get(billboardGraphics.horizontalOrigin, HorizontalOrigin.CENTER);\n\n    if (horizontalOrigin === HorizontalOrigin.CENTER) {\n      pixelOffset.x -= width * 0.5;\n    } else if (horizontalOrigin === HorizontalOrigin.RIGHT) {\n      pixelOffset.x -= width;\n    } // Move to bottom\n\n\n    var verticalOrigin = valueGetter.get(billboardGraphics.verticalOrigin, VerticalOrigin.CENTER);\n\n    if (verticalOrigin === VerticalOrigin.TOP) {\n      pixelOffset.y += height;\n    } else if (verticalOrigin === VerticalOrigin.CENTER) {\n      pixelOffset.y += height * 0.5;\n    }\n\n    var hotSpot = kmlDoc.createElement(\"hotSpot\");\n    hotSpot.setAttribute(\"x\", -pixelOffset.x);\n    hotSpot.setAttribute(\"y\", pixelOffset.y);\n    hotSpot.setAttribute(\"xunits\", \"pixels\");\n    hotSpot.setAttribute(\"yunits\", \"pixels\");\n    iconStyle.appendChild(hotSpot);\n  } // We can only specify heading so if axis isn't Z, then we skip the rotation\n  // GE treats a heading of zero as no heading but can still point north using a 360 degree angle\n\n\n  var rotation = valueGetter.get(billboardGraphics.rotation);\n  var alignedAxis = valueGetter.get(billboardGraphics.alignedAxis);\n\n  if (defined(rotation) && Cartesian3.equals(Cartesian3.UNIT_Z, alignedAxis)) {\n    rotation = CesiumMath.toDegrees(-rotation);\n\n    if (rotation === 0) {\n      rotation = 360;\n    }\n\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"heading\", rotation));\n  }\n\n  return iconStyle;\n}\n\nfunction createLineString(state, polylineGraphics, geometries, styles) {\n  var kmlDoc = state.kmlDoc;\n  var ellipsoid = state.ellipsoid;\n  var valueGetter = state.valueGetter;\n\n  if (!defined(polylineGraphics)) {\n    return;\n  }\n\n  var lineStringGeometry = kmlDoc.createElement(\"LineString\"); // Set altitude mode\n\n  var altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  var clampToGround = valueGetter.get(polylineGraphics.clampToGround, false);\n  var altitudeModeText;\n\n  if (clampToGround) {\n    lineStringGeometry.appendChild(createBasicElementWithText(kmlDoc, \"tessellate\", true));\n    altitudeModeText = kmlDoc.createTextNode(\"clampToGround\");\n  } else {\n    altitudeModeText = kmlDoc.createTextNode(\"absolute\");\n  }\n\n  altitudeMode.appendChild(altitudeModeText);\n  lineStringGeometry.appendChild(altitudeMode); // Set coordinates\n\n  var positionsProperty = polylineGraphics.positions;\n  var cartesians = valueGetter.get(positionsProperty);\n  var coordinates = createBasicElementWithText(kmlDoc, \"coordinates\", getCoordinates(cartesians, ellipsoid));\n  lineStringGeometry.appendChild(coordinates); // Set draw order\n\n  var zIndex = valueGetter.get(polylineGraphics.zIndex);\n\n  if (clampToGround && defined(zIndex)) {\n    lineStringGeometry.appendChild(createBasicElementWithText(kmlDoc, \"drawOrder\", zIndex, gxNamespace));\n  }\n\n  geometries.push(lineStringGeometry); // Create style\n\n  var lineStyle = kmlDoc.createElement(\"LineStyle\");\n  var width = valueGetter.get(polylineGraphics.width);\n\n  if (defined(width)) {\n    lineStyle.appendChild(createBasicElementWithText(kmlDoc, \"width\", width));\n  }\n\n  processMaterial(state, polylineGraphics.material, lineStyle);\n  styles.push(lineStyle);\n}\n\nfunction getRectangleBoundaries(state, rectangleGraphics, extrudedHeight) {\n  var kmlDoc = state.kmlDoc;\n  var valueGetter = state.valueGetter;\n  var coordinates;\n  var height = valueGetter.get(rectangleGraphics.height, 0.0);\n\n  if (extrudedHeight > 0) {\n    // We extrude up and KML extrudes down, so if we extrude, set the polygon height to\n    // the extruded height so KML will look similar to Cesium\n    height = extrudedHeight;\n  }\n\n  var coordinatesProperty = rectangleGraphics.coordinates;\n  var rectangle = valueGetter.get(coordinatesProperty);\n  var coordinateStrings = [];\n  var cornerFunction = [Rectangle.northeast, Rectangle.southeast, Rectangle.southwest, Rectangle.northwest];\n\n  for (var i = 0; i < 4; ++i) {\n    cornerFunction[i](rectangle, scratchCartographic);\n    coordinateStrings.push(CesiumMath.toDegrees(scratchCartographic.longitude) + \",\" + CesiumMath.toDegrees(scratchCartographic.latitude) + \",\" + height);\n  }\n\n  coordinates = createBasicElementWithText(kmlDoc, \"coordinates\", coordinateStrings.join(\" \"));\n  var outerBoundaryIs = kmlDoc.createElement(\"outerBoundaryIs\");\n  var linearRing = kmlDoc.createElement(\"LinearRing\");\n  linearRing.appendChild(coordinates);\n  outerBoundaryIs.appendChild(linearRing);\n  return [outerBoundaryIs];\n}\n\nfunction getLinearRing(state, positions, height, perPositionHeight) {\n  var kmlDoc = state.kmlDoc;\n  var ellipsoid = state.ellipsoid;\n  var coordinateStrings = [];\n  var positionCount = positions.length;\n\n  for (var i = 0; i < positionCount; ++i) {\n    Cartographic.fromCartesian(positions[i], ellipsoid, scratchCartographic);\n    coordinateStrings.push(CesiumMath.toDegrees(scratchCartographic.longitude) + \",\" + CesiumMath.toDegrees(scratchCartographic.latitude) + \",\" + (perPositionHeight ? scratchCartographic.height : height));\n  }\n\n  var coordinates = createBasicElementWithText(kmlDoc, \"coordinates\", coordinateStrings.join(\" \"));\n  var linearRing = kmlDoc.createElement(\"LinearRing\");\n  linearRing.appendChild(coordinates);\n  return linearRing;\n}\n\nfunction getPolygonBoundaries(state, polygonGraphics, extrudedHeight) {\n  var kmlDoc = state.kmlDoc;\n  var valueGetter = state.valueGetter;\n  var height = valueGetter.get(polygonGraphics.height, 0.0);\n  var perPositionHeight = valueGetter.get(polygonGraphics.perPositionHeight, false);\n\n  if (!perPositionHeight && extrudedHeight > 0) {\n    // We extrude up and KML extrudes down, so if we extrude, set the polygon height to\n    // the extruded height so KML will look similar to Cesium\n    height = extrudedHeight;\n  }\n\n  var boundaries = [];\n  var hierarchyProperty = polygonGraphics.hierarchy;\n  var hierarchy = valueGetter.get(hierarchyProperty); // Polygon hierarchy can sometimes just be an array of positions\n\n  var positions = Array.isArray(hierarchy) ? hierarchy : hierarchy.positions; // Polygon boundaries\n\n  var outerBoundaryIs = kmlDoc.createElement(\"outerBoundaryIs\");\n  outerBoundaryIs.appendChild(getLinearRing(state, positions, height, perPositionHeight));\n  boundaries.push(outerBoundaryIs); // Hole boundaries\n\n  var holes = hierarchy.holes;\n\n  if (defined(holes)) {\n    var holeCount = holes.length;\n\n    for (var i = 0; i < holeCount; ++i) {\n      var innerBoundaryIs = kmlDoc.createElement(\"innerBoundaryIs\");\n      innerBoundaryIs.appendChild(getLinearRing(state, holes[i].positions, height, perPositionHeight));\n      boundaries.push(innerBoundaryIs);\n    }\n  }\n\n  return boundaries;\n}\n\nfunction createPolygon(state, geometry, geometries, styles, overlays) {\n  var kmlDoc = state.kmlDoc;\n  var valueGetter = state.valueGetter;\n\n  if (!defined(geometry)) {\n    return;\n  } // Detect textured quads and use ground overlays instead\n\n\n  var isRectangle = geometry instanceof RectangleGraphics;\n\n  if (isRectangle && valueGetter.getMaterialType(geometry.material) === \"Image\") {\n    createGroundOverlay(state, geometry, overlays);\n    return;\n  }\n\n  var polygonGeometry = kmlDoc.createElement(\"Polygon\");\n  var extrudedHeight = valueGetter.get(geometry.extrudedHeight, 0.0);\n\n  if (extrudedHeight > 0) {\n    polygonGeometry.appendChild(createBasicElementWithText(kmlDoc, \"extrude\", true));\n  } // Set boundaries\n\n\n  var boundaries = isRectangle ? getRectangleBoundaries(state, geometry, extrudedHeight) : getPolygonBoundaries(state, geometry, extrudedHeight);\n  var boundaryCount = boundaries.length;\n\n  for (var i = 0; i < boundaryCount; ++i) {\n    polygonGeometry.appendChild(boundaries[i]);\n  } // Set altitude mode\n\n\n  var altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  altitudeMode.appendChild(getAltitudeMode(state, geometry.heightReference));\n  polygonGeometry.appendChild(altitudeMode);\n  geometries.push(polygonGeometry); // Create style\n\n  var polyStyle = kmlDoc.createElement(\"PolyStyle\");\n  var fill = valueGetter.get(geometry.fill, false);\n\n  if (fill) {\n    polyStyle.appendChild(createBasicElementWithText(kmlDoc, \"fill\", fill));\n  }\n\n  processMaterial(state, geometry.material, polyStyle);\n  var outline = valueGetter.get(geometry.outline, false);\n\n  if (outline) {\n    polyStyle.appendChild(createBasicElementWithText(kmlDoc, \"outline\", outline)); // Outline uses LineStyle\n\n    var lineStyle = kmlDoc.createElement(\"LineStyle\");\n    var outlineWidth = valueGetter.get(geometry.outlineWidth, 1.0);\n    lineStyle.appendChild(createBasicElementWithText(kmlDoc, \"width\", outlineWidth));\n    var outlineColor = valueGetter.getColor(geometry.outlineColor, Color.BLACK);\n    lineStyle.appendChild(createBasicElementWithText(kmlDoc, \"color\", outlineColor));\n    lineStyle.appendChild(createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\"));\n    styles.push(lineStyle);\n  }\n\n  styles.push(polyStyle);\n}\n\nfunction createGroundOverlay(state, rectangleGraphics, overlays) {\n  var kmlDoc = state.kmlDoc;\n  var valueGetter = state.valueGetter;\n  var externalFileHandler = state.externalFileHandler;\n  var groundOverlay = kmlDoc.createElement(\"GroundOverlay\"); // Set altitude mode\n\n  var altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  altitudeMode.appendChild(getAltitudeMode(state, rectangleGraphics.heightReference));\n  groundOverlay.appendChild(altitudeMode);\n  var height = valueGetter.get(rectangleGraphics.height);\n\n  if (defined(height)) {\n    groundOverlay.appendChild(createBasicElementWithText(kmlDoc, \"altitude\", height));\n  }\n\n  var rectangle = valueGetter.get(rectangleGraphics.coordinates);\n  var latLonBox = kmlDoc.createElement(\"LatLonBox\");\n  latLonBox.appendChild(createBasicElementWithText(kmlDoc, \"north\", CesiumMath.toDegrees(rectangle.north)));\n  latLonBox.appendChild(createBasicElementWithText(kmlDoc, \"south\", CesiumMath.toDegrees(rectangle.south)));\n  latLonBox.appendChild(createBasicElementWithText(kmlDoc, \"east\", CesiumMath.toDegrees(rectangle.east)));\n  latLonBox.appendChild(createBasicElementWithText(kmlDoc, \"west\", CesiumMath.toDegrees(rectangle.west)));\n  groundOverlay.appendChild(latLonBox); // We should only end up here if we have an ImageMaterialProperty\n\n  var material = valueGetter.get(rectangleGraphics.material);\n  var href = externalFileHandler.texture(material.image);\n  var icon = kmlDoc.createElement(\"Icon\");\n  icon.appendChild(createBasicElementWithText(kmlDoc, \"href\", href));\n  groundOverlay.appendChild(icon);\n  var color = material.color;\n\n  if (defined(color)) {\n    groundOverlay.appendChild(createBasicElementWithText(kmlDoc, \"color\", colorToString(material.color)));\n  }\n\n  overlays.push(groundOverlay);\n}\n\nfunction createModelGeometry(state, modelGraphics) {\n  var kmlDoc = state.kmlDoc;\n  var valueGetter = state.valueGetter;\n  var externalFileHandler = state.externalFileHandler;\n  var modelGeometry = kmlDoc.createElement(\"Model\");\n  var scale = valueGetter.get(modelGraphics.scale);\n\n  if (defined(scale)) {\n    var scaleElement = kmlDoc.createElement(\"scale\");\n    scaleElement.appendChild(createBasicElementWithText(kmlDoc, \"x\", scale));\n    scaleElement.appendChild(createBasicElementWithText(kmlDoc, \"y\", scale));\n    scaleElement.appendChild(createBasicElementWithText(kmlDoc, \"z\", scale));\n    modelGeometry.appendChild(scaleElement);\n  }\n\n  var link = kmlDoc.createElement(\"Link\");\n  var uri = externalFileHandler.model(modelGraphics, state.time);\n  link.appendChild(createBasicElementWithText(kmlDoc, \"href\", uri));\n  modelGeometry.appendChild(link);\n  return modelGeometry;\n}\n\nfunction createModel(state, entity, modelGraphics, geometries, styles) {\n  var kmlDoc = state.kmlDoc;\n  var ellipsoid = state.ellipsoid;\n  var valueGetter = state.valueGetter;\n\n  if (!defined(modelGraphics)) {\n    return;\n  } // If the point isn't constant then create gx:Track or gx:MultiTrack\n\n\n  var entityPositionProperty = entity.position;\n\n  if (!entityPositionProperty.isConstant) {\n    createTracks(state, entity, modelGraphics, geometries, styles);\n    return;\n  }\n\n  var modelGeometry = createModelGeometry(state, modelGraphics); // Set altitude mode\n\n  var altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  altitudeMode.appendChild(getAltitudeMode(state, modelGraphics.heightReference));\n  modelGeometry.appendChild(altitudeMode);\n  valueGetter.get(entityPositionProperty, undefined, scratchCartesian3);\n  Cartographic.fromCartesian(scratchCartesian3, ellipsoid, scratchCartographic);\n  var location = kmlDoc.createElement(\"Location\");\n  location.appendChild(createBasicElementWithText(kmlDoc, \"longitude\", CesiumMath.toDegrees(scratchCartographic.longitude)));\n  location.appendChild(createBasicElementWithText(kmlDoc, \"latitude\", CesiumMath.toDegrees(scratchCartographic.latitude)));\n  location.appendChild(createBasicElementWithText(kmlDoc, \"altitude\", scratchCartographic.height));\n  modelGeometry.appendChild(location);\n  geometries.push(modelGeometry);\n}\n\nfunction processMaterial(state, materialProperty, style) {\n  var kmlDoc = state.kmlDoc;\n  var valueGetter = state.valueGetter;\n\n  if (!defined(materialProperty)) {\n    return;\n  }\n\n  var material = valueGetter.get(materialProperty);\n\n  if (!defined(material)) {\n    return;\n  }\n\n  var color;\n  var type = valueGetter.getMaterialType(materialProperty);\n\n  switch (type) {\n    case \"Image\":\n      // Image materials are only able to be represented on rectangles, so if we make it\n      //  here we can't texture a generic polygon or polyline in KML, so just use white.\n      color = colorToString(Color.WHITE);\n      break;\n\n    case \"Color\":\n    case \"Grid\":\n    case \"PolylineGlow\":\n    case \"PolylineArrow\":\n    case \"PolylineDash\":\n      color = colorToString(material.color);\n      break;\n\n    case \"PolylineOutline\":\n      color = colorToString(material.color);\n      var outlineColor = colorToString(material.outlineColor);\n      var outlineWidth = material.outlineWidth;\n      style.appendChild(createBasicElementWithText(kmlDoc, \"outerColor\", outlineColor, gxNamespace));\n      style.appendChild(createBasicElementWithText(kmlDoc, \"outerWidth\", outlineWidth, gxNamespace));\n      break;\n\n    case \"Stripe\":\n      color = colorToString(material.oddColor);\n      break;\n  }\n\n  if (defined(color)) {\n    style.appendChild(createBasicElementWithText(kmlDoc, \"color\", color));\n    style.appendChild(createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\"));\n  }\n}\n\nfunction getAltitudeMode(state, heightReferenceProperty) {\n  var kmlDoc = state.kmlDoc;\n  var valueGetter = state.valueGetter;\n  var heightReference = valueGetter.get(heightReferenceProperty, HeightReference.NONE);\n  var altitudeModeText;\n\n  switch (heightReference) {\n    case HeightReference.NONE:\n      altitudeModeText = kmlDoc.createTextNode(\"absolute\");\n      break;\n\n    case HeightReference.CLAMP_TO_GROUND:\n      altitudeModeText = kmlDoc.createTextNode(\"clampToGround\");\n      break;\n\n    case HeightReference.RELATIVE_TO_GROUND:\n      altitudeModeText = kmlDoc.createTextNode(\"relativeToGround\");\n      break;\n  }\n\n  return altitudeModeText;\n}\n\nfunction getCoordinates(coordinates, ellipsoid) {\n  if (!Array.isArray(coordinates)) {\n    coordinates = [coordinates];\n  }\n\n  var count = coordinates.length;\n  var coordinateStrings = [];\n\n  for (var i = 0; i < count; ++i) {\n    Cartographic.fromCartesian(coordinates[i], ellipsoid, scratchCartographic);\n    coordinateStrings.push(CesiumMath.toDegrees(scratchCartographic.longitude) + \",\" + CesiumMath.toDegrees(scratchCartographic.latitude) + \",\" + scratchCartographic.height);\n  }\n\n  return coordinateStrings.join(\" \");\n}\n\nfunction createBasicElementWithText(kmlDoc, elementName, elementValue, namespace) {\n  elementValue = defaultValue(elementValue, \"\");\n\n  if (typeof elementValue === \"boolean\") {\n    elementValue = elementValue ? \"1\" : \"0\";\n  } // Create element with optional namespace\n\n\n  var element = defined(namespace) ? kmlDoc.createElementNS(namespace, elementName) : kmlDoc.createElement(elementName); // Wrap value in CDATA section if it contains HTML\n\n  var text = elementValue === \"string\" && elementValue.indexOf(\"<\") !== -1 ? kmlDoc.createCDATASection(elementValue) : kmlDoc.createTextNode(elementValue);\n  element.appendChild(text);\n  return element;\n}\n\nfunction colorToString(color) {\n  var result = \"\";\n  var bytes = color.toBytes();\n\n  for (var i = 3; i >= 0; --i) {\n    result += bytes[i] < 16 ? \"0\" + bytes[i].toString(16) : bytes[i].toString(16);\n  }\n\n  return result;\n}\n/**\n * Since KML does not support glTF models, this callback is required to specify what URL to use for the model in the KML document.\n * It can also be used to add additional files to the <code>externalFiles</code> object, which is the list of files embedded in the exported KMZ,\n * or otherwise returned with the KML string when exporting.\n *\n * @callback exportKml~ModelCallback\n *\n * @param {ModelGraphics} model The ModelGraphics instance for an Entity.\n * @param {JulianDate} time The time that any properties should use to get the value.\n * @param {Object} externalFiles An object that maps a filename to a Blob or a Promise that resolves to a Blob.\n * @returns {String} The URL to use for the href in the KML document.\n */\n\n\nexport default exportKml;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/DataSources/exportKml.js"],"names":["Cartesian2","Cartesian3","Cartographic","Color","createGuid","defaultValue","defined","DeveloperError","Ellipsoid","Iso8601","JulianDate","CesiumMath","Rectangle","ReferenceFrame","Resource","RuntimeError","TimeInterval","TimeIntervalCollection","HeightReference","HorizontalOrigin","VerticalOrigin","when","zip","BillboardGraphics","CompositePositionProperty","ModelGraphics","RectangleGraphics","SampledPositionProperty","SampledProperty","ScaledPositionProperty","BILLBOARD_SIZE","kmlNamespace","gxNamespace","xmlnsNamespace","ExternalFileHandler","modelCallback","_files","_promises","_count","_modelCallback","imageTypeRegex","prototype","texture","that","filename","createIfNeeded","isDataUri","url","regexResult","match","promise","fetchBlob","then","blob","push","HTMLCanvasElement","deferred","defer","toBlob","resolve","getModelBlobHander","model","time","externalFiles","hasOwnProperty","Object","defineProperties","get","all","files","ValueGetter","_time","property","defaultVal","result","value","getValue","getColor","colorToString","getMaterialType","getType","StyleCache","_ids","_styles","element","ids","key","innerHTML","styleId","setAttribute","save","parentElement","styles","firstElement","childNodes","insertBefore","IdManager","id","toString","exportKml","options","EMPTY_OBJECT","entities","kmz","state","_createState","rootEntities","values","filter","entity","parent","kmlDoc","kmlElement","documentElement","setAttributeNS","kmlDocumentElement","createElement","appendChild","recurseEntities","styleCache","externalFileHandler","serializer","XMLSerializer","kmlString","serializeToString","createKmz","kml","createWriter","BlobWriter","writer","addKmlToZip","keys","addExternalFilesToZip","close","add","TextReader","index","length","BlobReader","entityAvailability","computeAvailability","start","defaultAvailability","sampleDuration","MINIMUM_VALUE","stop","MAXIMUM_VALUE","addSeconds","document","implementation","createDocument","ellipsoid","WGS84","idManager","valueGetter","parentNode","count","overlays","geometries","i","createPoint","createLineString","polyline","createPolygon","rectangle","polygon","createModel","timeSpan","availability","equals","createBasicElementWithText","toIso8601","overlayIndex","overlay","name","show","description","geometryCount","placemark","labelGraphics","label","labelStyle","text","color","fillColor","scale","styleCount","style","styleIndex","multigeometry","geometryIndex","children","_children","folderNode","scratchCartesian3","scratchCartographic","scratchJulianDate","pointGraphics","billboard","point","path","entityPositionProperty","position","isConstant","createTracks","undefined","coordinates","getCoordinates","pointGeometry","altitudeMode","getAltitudeMode","heightReference","iconStyle","createIconStyleFromBillboard","createIconStyleFromPoint","intervals","useEntityPositionProperty","isModel","j","times","tracks","interval","positionProperty","data","trackAltitudeMode","_value","CLAMP_TO_GROUND","NONE","positionTimes","positionValues","constCoordinates","_property","_times","getValueInReferenceFrame","FIXED","_values","fromArray","duration","clone","isStartIncluded","stopDate","lessThan","isStopIncluded","trackGeometry","createElementNS","k","coord","createModelGeometry","multiTrackGeometry","width","material","lineStyle","processMaterial","pixelSize","billboardGraphics","image","icon","imageSubRegion","x","y","height","pixelOffset","divideByScalar","horizontalOrigin","CENTER","RIGHT","verticalOrigin","TOP","hotSpot","rotation","alignedAxis","UNIT_Z","toDegrees","polylineGraphics","lineStringGeometry","clampToGround","altitudeModeText","createTextNode","positionsProperty","positions","cartesians","zIndex","getRectangleBoundaries","rectangleGraphics","extrudedHeight","coordinatesProperty","coordinateStrings","cornerFunction","northeast","southeast","southwest","northwest","longitude","latitude","join","outerBoundaryIs","linearRing","getLinearRing","perPositionHeight","positionCount","fromCartesian","getPolygonBoundaries","polygonGraphics","boundaries","hierarchyProperty","hierarchy","Array","isArray","holes","holeCount","innerBoundaryIs","geometry","isRectangle","createGroundOverlay","polygonGeometry","boundaryCount","polyStyle","fill","outline","outlineWidth","outlineColor","BLACK","groundOverlay","latLonBox","north","south","east","west","href","modelGraphics","modelGeometry","scaleElement","link","uri","location","materialProperty","type","WHITE","oddColor","heightReferenceProperty","RELATIVE_TO_GROUND","elementName","elementValue","namespace","indexOf","createCDATASection","bytes","toBytes"],"mappings":"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","sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Color from \"../Core/Color.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport ReferenceFrame from \"../Core/ReferenceFrame.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TimeInterval from \"../Core/TimeInterval.js\";\nimport TimeIntervalCollection from \"../Core/TimeIntervalCollection.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport HorizontalOrigin from \"../Scene/HorizontalOrigin.js\";\nimport VerticalOrigin from \"../Scene/VerticalOrigin.js\";\nimport when from \"../ThirdParty/when.js\";\nimport zip from \"../ThirdParty/zip.js\";\nimport BillboardGraphics from \"./BillboardGraphics.js\";\nimport CompositePositionProperty from \"./CompositePositionProperty.js\";\nimport ModelGraphics from \"./ModelGraphics.js\";\nimport RectangleGraphics from \"./RectangleGraphics.js\";\nimport SampledPositionProperty from \"./SampledPositionProperty.js\";\nimport SampledProperty from \"./SampledProperty.js\";\nimport ScaledPositionProperty from \"./ScaledPositionProperty.js\";\n\nvar BILLBOARD_SIZE = 32;\nvar kmlNamespace = \"http://www.opengis.net/kml/2.2\";\nvar gxNamespace = \"http://www.google.com/kml/ext/2.2\";\nvar xmlnsNamespace = \"http://www.w3.org/2000/xmlns/\";\n\n//\n// Handles files external to the KML (eg. textures and models)\n//\nfunction ExternalFileHandler(modelCallback) {\n  this._files = {};\n  this._promises = [];\n  this._count = 0;\n  this._modelCallback = modelCallback;\n}\n\nvar imageTypeRegex = /^data:image\\/([^,;]+)/;\nExternalFileHandler.prototype.texture = function (texture) {\n  var that = this;\n  var filename;\n\n  if (typeof texture === \"string\" || texture instanceof Resource) {\n    texture = Resource.createIfNeeded(texture);\n    if (!texture.isDataUri) {\n      return texture.url;\n    }\n\n    // If its a data URI try and get the correct extension and then fetch the blob\n    var regexResult = texture.url.match(imageTypeRegex);\n    filename = \"texture_\" + ++this._count;\n    if (defined(regexResult)) {\n      filename += \".\" + regexResult[1];\n    }\n\n    var promise = texture.fetchBlob().then(function (blob) {\n      that._files[filename] = blob;\n    });\n\n    this._promises.push(promise);\n\n    return filename;\n  }\n\n  if (texture instanceof HTMLCanvasElement) {\n    var deferred = when.defer();\n    this._promises.push(deferred.promise);\n\n    filename = \"texture_\" + ++this._count + \".png\";\n    texture.toBlob(function (blob) {\n      that._files[filename] = blob;\n      deferred.resolve();\n    });\n\n    return filename;\n  }\n\n  return \"\";\n};\n\nfunction getModelBlobHander(that, filename) {\n  return function (blob) {\n    that._files[filename] = blob;\n  };\n}\n\nExternalFileHandler.prototype.model = function (model, time) {\n  var modelCallback = this._modelCallback;\n  if (!defined(modelCallback)) {\n    throw new RuntimeError(\n      \"Encountered a model entity while exporting to KML, but no model callback was supplied.\"\n    );\n  }\n\n  var externalFiles = {};\n  var url = modelCallback(model, time, externalFiles);\n\n  // Iterate through external files and add them to our list once the promise resolves\n  for (var filename in externalFiles) {\n    if (externalFiles.hasOwnProperty(filename)) {\n      var promise = when(externalFiles[filename]);\n      this._promises.push(promise);\n\n      promise.then(getModelBlobHander(this, filename));\n    }\n  }\n\n  return url;\n};\n\nObject.defineProperties(ExternalFileHandler.prototype, {\n  promise: {\n    get: function () {\n      return when.all(this._promises);\n    },\n  },\n  files: {\n    get: function () {\n      return this._files;\n    },\n  },\n});\n\n//\n// Handles getting values from properties taking the desired time and default values into account\n//\nfunction ValueGetter(time) {\n  this._time = time;\n}\n\nValueGetter.prototype.get = function (property, defaultVal, result) {\n  var value;\n  if (defined(property)) {\n    value = defined(property.getValue)\n      ? property.getValue(this._time, result)\n      : property;\n  }\n\n  return defaultValue(value, defaultVal);\n};\n\nValueGetter.prototype.getColor = function (property, defaultVal) {\n  var result = this.get(property, defaultVal);\n  if (defined(result)) {\n    return colorToString(result);\n  }\n};\n\nValueGetter.prototype.getMaterialType = function (property) {\n  if (!defined(property)) {\n    return;\n  }\n\n  return property.getType(this._time);\n};\n\n//\n// Caches styles so we don't generate a ton of duplicate styles\n//\nfunction StyleCache() {\n  this._ids = {};\n  this._styles = {};\n  this._count = 0;\n}\n\nStyleCache.prototype.get = function (element) {\n  var ids = this._ids;\n  var key = element.innerHTML;\n  if (defined(ids[key])) {\n    return ids[key];\n  }\n\n  var styleId = \"style-\" + ++this._count;\n  element.setAttribute(\"id\", styleId);\n\n  // Store with #\n  styleId = \"#\" + styleId;\n  ids[key] = styleId;\n  this._styles[key] = element;\n\n  return styleId;\n};\n\nStyleCache.prototype.save = function (parentElement) {\n  var styles = this._styles;\n\n  var firstElement = parentElement.childNodes[0];\n  for (var key in styles) {\n    if (styles.hasOwnProperty(key)) {\n      parentElement.insertBefore(styles[key], firstElement);\n    }\n  }\n};\n\n//\n// Manages the generation of IDs because an entity may have geometry and a Folder for children\n//\nfunction IdManager() {\n  this._ids = {};\n}\n\nIdManager.prototype.get = function (id) {\n  if (!defined(id)) {\n    return this.get(createGuid());\n  }\n\n  var ids = this._ids;\n  if (!defined(ids[id])) {\n    ids[id] = 0;\n    return id;\n  }\n\n  return id.toString() + \"-\" + ++ids[id];\n};\n\n/**\n * Exports an EntityCollection as a KML document. Only Point, Billboard, Model, Path, Polygon, Polyline geometries\n * will be exported. Note that there is not a 1 to 1 mapping of Entity properties to KML Feature properties. For\n * example, entity properties that are time dynamic but cannot be dynamic in KML are exported with their values at\n * options.time or the beginning of the EntityCollection's time interval if not specified. For time-dynamic properties\n * that are supported in KML, we use the samples if it is a {@link SampledProperty} otherwise we sample the value using\n * the options.sampleDuration. Point, Billboard, Model and Path geometries with time-dynamic positions will be exported\n * as gx:Track Features. Not all Materials are representable in KML, so for more advanced Materials just the primary\n * color is used. Canvas objects are exported as PNG images.\n *\n * @exports exportKml\n *\n * @param {Object} options An object with the following properties:\n * @param {EntityCollection} options.entities The EntityCollection to export as KML.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for the output file.\n * @param {exportKml~ModelCallback} [options.modelCallback] A callback that will be called with a {@link ModelGraphics} instance and should return the URI to use in the KML. Required if a model exists in the entity collection.\n * @param {JulianDate} [options.time=entities.computeAvailability().start] The time value to use to get properties that are not time varying in KML.\n * @param {TimeInterval} [options.defaultAvailability=entities.computeAvailability()] The interval that will be sampled if an entity doesn't have an availability.\n * @param {Number} [options.sampleDuration=60] The number of seconds to sample properties that are varying in KML.\n * @param {Boolean} [options.kmz=false] If true KML and external files will be compressed into a kmz file.\n *\n * @returns {Promise<Object>} A promise that resolved to an object containing the KML string and a dictionary of external file blobs, or a kmz file as a blob if options.kmz is true.\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Export%20KML.html|Cesium Sandcastle KML Export Demo}\n * @example\n * Cesium.exportKml({\n *      entities: entityCollection\n *  })\n *   .then(function(result) {\n *     // The XML string is in result.kml\n *\n *     var externalFiles = result.externalFiles\n *     for(var file in externalFiles) {\n *       // file is the name of the file used in the KML document as the href\n *       // externalFiles[file] is a blob with the contents of the file\n *     }\n *   });\n *\n */\nfunction exportKml(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var entities = options.entities;\n  var kmz = defaultValue(options.kmz, false);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entities)) {\n    throw new DeveloperError(\"entities is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // Get the state that is passed around during the recursion\n  // This is separated out for testing.\n  var state = exportKml._createState(options);\n\n  // Filter EntityCollection so we only have top level entities\n  var rootEntities = entities.values.filter(function (entity) {\n    return !defined(entity.parent);\n  });\n\n  // Add the <Document>\n  var kmlDoc = state.kmlDoc;\n  var kmlElement = kmlDoc.documentElement;\n  kmlElement.setAttributeNS(xmlnsNamespace, \"xmlns:gx\", gxNamespace);\n  var kmlDocumentElement = kmlDoc.createElement(\"Document\");\n  kmlElement.appendChild(kmlDocumentElement);\n\n  // Create the KML Hierarchy\n  recurseEntities(state, kmlDocumentElement, rootEntities);\n\n  // Write out the <Style> elements\n  state.styleCache.save(kmlDocumentElement);\n\n  // Once all the blobs have resolved return the KML string along with the blob collection\n  var externalFileHandler = state.externalFileHandler;\n  return externalFileHandler.promise.then(function () {\n    var serializer = new XMLSerializer();\n    var kmlString = serializer.serializeToString(state.kmlDoc);\n    if (kmz) {\n      return createKmz(kmlString, externalFileHandler.files);\n    }\n\n    return {\n      kml: kmlString,\n      externalFiles: externalFileHandler.files,\n    };\n  });\n}\n\nfunction createKmz(kmlString, externalFiles) {\n  var deferred = when.defer();\n  zip.createWriter(new zip.BlobWriter(), function (writer) {\n    // We need to only write one file at a time so the zip doesn't get corrupted\n    addKmlToZip(writer, kmlString)\n      .then(function () {\n        var keys = Object.keys(externalFiles);\n        return addExternalFilesToZip(writer, keys, externalFiles, 0);\n      })\n      .then(function () {\n        writer.close(function (blob) {\n          deferred.resolve({\n            kmz: blob,\n          });\n        });\n      });\n  });\n\n  return deferred.promise;\n}\n\nfunction addKmlToZip(writer, kmlString) {\n  var deferred = when.defer();\n  writer.add(\"doc.kml\", new zip.TextReader(kmlString), function () {\n    deferred.resolve();\n  });\n\n  return deferred.promise;\n}\n\nfunction addExternalFilesToZip(writer, keys, externalFiles, index) {\n  if (keys.length === index) {\n    return;\n  }\n\n  var filename = keys[index];\n\n  var deferred = when.defer();\n  writer.add(\n    filename,\n    new zip.BlobReader(externalFiles[filename]),\n    function () {\n      deferred.resolve();\n    }\n  );\n\n  return deferred.promise.then(function () {\n    return addExternalFilesToZip(writer, keys, externalFiles, index + 1);\n  });\n}\n\nexportKml._createState = function (options) {\n  var entities = options.entities;\n\n  var styleCache = new StyleCache();\n\n  // Use the start time as the default because just in case they define\n  //  properties with an interval even if they don't change.\n  var entityAvailability = entities.computeAvailability();\n  var time = defined(options.time) ? options.time : entityAvailability.start;\n\n  // Figure out how we will sample dynamic position properties\n  var defaultAvailability = defaultValue(\n    options.defaultAvailability,\n    entityAvailability\n  );\n  var sampleDuration = defaultValue(options.sampleDuration, 60);\n\n  // Make sure we don't have infinite availability if we need to sample\n  if (defaultAvailability.start === Iso8601.MINIMUM_VALUE) {\n    if (defaultAvailability.stop === Iso8601.MAXIMUM_VALUE) {\n      // Infinite, so just use the default\n      defaultAvailability = new TimeInterval();\n    } else {\n      // No start time, so just sample 10 times before the stop\n      JulianDate.addSeconds(\n        defaultAvailability.stop,\n        -10 * sampleDuration,\n        defaultAvailability.start\n      );\n    }\n  } else if (defaultAvailability.stop === Iso8601.MAXIMUM_VALUE) {\n    // No stop time, so just sample 10 times after the start\n    JulianDate.addSeconds(\n      defaultAvailability.start,\n      10 * sampleDuration,\n      defaultAvailability.stop\n    );\n  }\n\n  var externalFileHandler = new ExternalFileHandler(options.modelCallback);\n\n  var kmlDoc = document.implementation.createDocument(kmlNamespace, \"kml\");\n  return {\n    kmlDoc: kmlDoc,\n    ellipsoid: defaultValue(options.ellipsoid, Ellipsoid.WGS84),\n    idManager: new IdManager(),\n    styleCache: styleCache,\n    externalFileHandler: externalFileHandler,\n    time: time,\n    valueGetter: new ValueGetter(time),\n    sampleDuration: sampleDuration,\n    // Wrap it in a TimeIntervalCollection because that is what entity.availability is\n    defaultAvailability: new TimeIntervalCollection([defaultAvailability]),\n  };\n};\n\nfunction recurseEntities(state, parentNode, entities) {\n  var kmlDoc = state.kmlDoc;\n  var styleCache = state.styleCache;\n  var valueGetter = state.valueGetter;\n  var idManager = state.idManager;\n\n  var count = entities.length;\n  var overlays;\n  var geometries;\n  var styles;\n  for (var i = 0; i < count; ++i) {\n    var entity = entities[i];\n    overlays = [];\n    geometries = [];\n    styles = [];\n\n    createPoint(state, entity, geometries, styles);\n    createLineString(state, entity.polyline, geometries, styles);\n    createPolygon(state, entity.rectangle, geometries, styles, overlays);\n    createPolygon(state, entity.polygon, geometries, styles, overlays);\n    createModel(state, entity, entity.model, geometries, styles);\n\n    var timeSpan;\n    var availability = entity.availability;\n    if (defined(availability)) {\n      timeSpan = kmlDoc.createElement(\"TimeSpan\");\n\n      if (!JulianDate.equals(availability.start, Iso8601.MINIMUM_VALUE)) {\n        timeSpan.appendChild(\n          createBasicElementWithText(\n            kmlDoc,\n            \"begin\",\n            JulianDate.toIso8601(availability.start)\n          )\n        );\n      }\n\n      if (!JulianDate.equals(availability.stop, Iso8601.MAXIMUM_VALUE)) {\n        timeSpan.appendChild(\n          createBasicElementWithText(\n            kmlDoc,\n            \"end\",\n            JulianDate.toIso8601(availability.stop)\n          )\n        );\n      }\n    }\n\n    for (var overlayIndex = 0; overlayIndex < overlays.length; ++overlayIndex) {\n      var overlay = overlays[overlayIndex];\n\n      overlay.setAttribute(\"id\", idManager.get(entity.id));\n      overlay.appendChild(\n        createBasicElementWithText(kmlDoc, \"name\", entity.name)\n      );\n      overlay.appendChild(\n        createBasicElementWithText(kmlDoc, \"visibility\", entity.show)\n      );\n      overlay.appendChild(\n        createBasicElementWithText(kmlDoc, \"description\", entity.description)\n      );\n\n      if (defined(timeSpan)) {\n        overlay.appendChild(timeSpan);\n      }\n\n      parentNode.appendChild(overlay);\n    }\n\n    var geometryCount = geometries.length;\n    if (geometryCount > 0) {\n      var placemark = kmlDoc.createElement(\"Placemark\");\n      placemark.setAttribute(\"id\", idManager.get(entity.id));\n\n      var name = entity.name;\n      var labelGraphics = entity.label;\n      if (defined(labelGraphics)) {\n        var labelStyle = kmlDoc.createElement(\"LabelStyle\");\n\n        // KML only shows the name as a label, so just change the name if we need to show a label\n        var text = valueGetter.get(labelGraphics.text);\n        name = defined(text) && text.length > 0 ? text : name;\n\n        var color = valueGetter.getColor(labelGraphics.fillColor);\n        if (defined(color)) {\n          labelStyle.appendChild(\n            createBasicElementWithText(kmlDoc, \"color\", color)\n          );\n          labelStyle.appendChild(\n            createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\")\n          );\n        }\n\n        var scale = valueGetter.get(labelGraphics.scale);\n        if (defined(scale)) {\n          labelStyle.appendChild(\n            createBasicElementWithText(kmlDoc, \"scale\", scale)\n          );\n        }\n\n        styles.push(labelStyle);\n      }\n\n      placemark.appendChild(createBasicElementWithText(kmlDoc, \"name\", name));\n      placemark.appendChild(\n        createBasicElementWithText(kmlDoc, \"visibility\", entity.show)\n      );\n      placemark.appendChild(\n        createBasicElementWithText(kmlDoc, \"description\", entity.description)\n      );\n\n      if (defined(timeSpan)) {\n        placemark.appendChild(timeSpan);\n      }\n\n      parentNode.appendChild(placemark);\n\n      var styleCount = styles.length;\n      if (styleCount > 0) {\n        var style = kmlDoc.createElement(\"Style\");\n        for (var styleIndex = 0; styleIndex < styleCount; ++styleIndex) {\n          style.appendChild(styles[styleIndex]);\n        }\n\n        placemark.appendChild(\n          createBasicElementWithText(kmlDoc, \"styleUrl\", styleCache.get(style))\n        );\n      }\n\n      if (geometries.length === 1) {\n        placemark.appendChild(geometries[0]);\n      } else if (geometries.length > 1) {\n        var multigeometry = kmlDoc.createElement(\"MultiGeometry\");\n        for (\n          var geometryIndex = 0;\n          geometryIndex < geometryCount;\n          ++geometryIndex\n        ) {\n          multigeometry.appendChild(geometries[geometryIndex]);\n        }\n        placemark.appendChild(multigeometry);\n      }\n    }\n\n    var children = entity._children;\n    if (children.length > 0) {\n      var folderNode = kmlDoc.createElement(\"Folder\");\n      folderNode.setAttribute(\"id\", idManager.get(entity.id));\n      folderNode.appendChild(\n        createBasicElementWithText(kmlDoc, \"name\", entity.name)\n      );\n      folderNode.appendChild(\n        createBasicElementWithText(kmlDoc, \"visibility\", entity.show)\n      );\n      folderNode.appendChild(\n        createBasicElementWithText(kmlDoc, \"description\", entity.description)\n      );\n\n      parentNode.appendChild(folderNode);\n\n      recurseEntities(state, folderNode, children);\n    }\n  }\n}\n\nvar scratchCartesian3 = new Cartesian3();\nvar scratchCartographic = new Cartographic();\nvar scratchJulianDate = new JulianDate();\n\nfunction createPoint(state, entity, geometries, styles) {\n  var kmlDoc = state.kmlDoc;\n  var ellipsoid = state.ellipsoid;\n  var valueGetter = state.valueGetter;\n\n  var pointGraphics = defaultValue(entity.billboard, entity.point);\n  if (!defined(pointGraphics) && !defined(entity.path)) {\n    return;\n  }\n\n  // If the point isn't constant then create gx:Track or gx:MultiTrack\n  var entityPositionProperty = entity.position;\n  if (!entityPositionProperty.isConstant) {\n    createTracks(state, entity, pointGraphics, geometries, styles);\n    return;\n  }\n\n  valueGetter.get(entityPositionProperty, undefined, scratchCartesian3);\n  var coordinates = createBasicElementWithText(\n    kmlDoc,\n    \"coordinates\",\n    getCoordinates(scratchCartesian3, ellipsoid)\n  );\n\n  var pointGeometry = kmlDoc.createElement(\"Point\");\n\n  // Set altitude mode\n  var altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  altitudeMode.appendChild(\n    getAltitudeMode(state, pointGraphics.heightReference)\n  );\n  pointGeometry.appendChild(altitudeMode);\n\n  pointGeometry.appendChild(coordinates);\n  geometries.push(pointGeometry);\n\n  // Create style\n  var iconStyle =\n    pointGraphics instanceof BillboardGraphics\n      ? createIconStyleFromBillboard(state, pointGraphics)\n      : createIconStyleFromPoint(state, pointGraphics);\n  styles.push(iconStyle);\n}\n\nfunction createTracks(state, entity, pointGraphics, geometries, styles) {\n  var kmlDoc = state.kmlDoc;\n  var ellipsoid = state.ellipsoid;\n  var valueGetter = state.valueGetter;\n\n  var intervals;\n  var entityPositionProperty = entity.position;\n  var useEntityPositionProperty = true;\n  if (entityPositionProperty instanceof CompositePositionProperty) {\n    intervals = entityPositionProperty.intervals;\n    useEntityPositionProperty = false;\n  } else {\n    intervals = defaultValue(entity.availability, state.defaultAvailability);\n  }\n\n  var isModel = pointGraphics instanceof ModelGraphics;\n\n  var i, j, times;\n  var tracks = [];\n  for (i = 0; i < intervals.length; ++i) {\n    var interval = intervals.get(i);\n    var positionProperty = useEntityPositionProperty\n      ? entityPositionProperty\n      : interval.data;\n\n    var trackAltitudeMode = kmlDoc.createElement(\"altitudeMode\");\n    // This is something that KML importing uses to handle clampToGround,\n    //  so just extract the internal property and set the altitudeMode.\n    if (positionProperty instanceof ScaledPositionProperty) {\n      positionProperty = positionProperty._value;\n      trackAltitudeMode.appendChild(\n        getAltitudeMode(state, HeightReference.CLAMP_TO_GROUND)\n      );\n    } else if (defined(pointGraphics)) {\n      trackAltitudeMode.appendChild(\n        getAltitudeMode(state, pointGraphics.heightReference)\n      );\n    } else {\n      // Path graphics only, which has no height reference\n      trackAltitudeMode.appendChild(\n        getAltitudeMode(state, HeightReference.NONE)\n      );\n    }\n\n    var positionTimes = [];\n    var positionValues = [];\n\n    if (positionProperty.isConstant) {\n      valueGetter.get(positionProperty, undefined, scratchCartesian3);\n      var constCoordinates = createBasicElementWithText(\n        kmlDoc,\n        \"coordinates\",\n        getCoordinates(scratchCartesian3, ellipsoid)\n      );\n\n      // This interval is constant so add a track with the same position\n      positionTimes.push(JulianDate.toIso8601(interval.start));\n      positionValues.push(constCoordinates);\n      positionTimes.push(JulianDate.toIso8601(interval.stop));\n      positionValues.push(constCoordinates);\n    } else if (positionProperty instanceof SampledPositionProperty) {\n      times = positionProperty._property._times;\n\n      for (j = 0; j < times.length; ++j) {\n        positionTimes.push(JulianDate.toIso8601(times[j]));\n        positionProperty.getValueInReferenceFrame(\n          times[j],\n          ReferenceFrame.FIXED,\n          scratchCartesian3\n        );\n        positionValues.push(getCoordinates(scratchCartesian3, ellipsoid));\n      }\n    } else if (positionProperty instanceof SampledProperty) {\n      times = positionProperty._times;\n      var values = positionProperty._values;\n\n      for (j = 0; j < times.length; ++j) {\n        positionTimes.push(JulianDate.toIso8601(times[j]));\n        Cartesian3.fromArray(values, j * 3, scratchCartesian3);\n        positionValues.push(getCoordinates(scratchCartesian3, ellipsoid));\n      }\n    } else {\n      var duration = state.sampleDuration;\n      interval.start.clone(scratchJulianDate);\n      if (!interval.isStartIncluded) {\n        JulianDate.addSeconds(scratchJulianDate, duration, scratchJulianDate);\n      }\n\n      var stopDate = interval.stop;\n      while (JulianDate.lessThan(scratchJulianDate, stopDate)) {\n        positionProperty.getValue(scratchJulianDate, scratchCartesian3);\n\n        positionTimes.push(JulianDate.toIso8601(scratchJulianDate));\n        positionValues.push(getCoordinates(scratchCartesian3, ellipsoid));\n\n        JulianDate.addSeconds(scratchJulianDate, duration, scratchJulianDate);\n      }\n\n      if (\n        interval.isStopIncluded &&\n        JulianDate.equals(scratchJulianDate, stopDate)\n      ) {\n        positionProperty.getValue(scratchJulianDate, scratchCartesian3);\n\n        positionTimes.push(JulianDate.toIso8601(scratchJulianDate));\n        positionValues.push(getCoordinates(scratchCartesian3, ellipsoid));\n      }\n    }\n\n    var trackGeometry = kmlDoc.createElementNS(gxNamespace, \"Track\");\n    trackGeometry.appendChild(trackAltitudeMode);\n\n    for (var k = 0; k < positionTimes.length; ++k) {\n      var when = createBasicElementWithText(kmlDoc, \"when\", positionTimes[k]);\n      var coord = createBasicElementWithText(\n        kmlDoc,\n        \"coord\",\n        positionValues[k],\n        gxNamespace\n      );\n\n      trackGeometry.appendChild(when);\n      trackGeometry.appendChild(coord);\n    }\n\n    if (isModel) {\n      trackGeometry.appendChild(createModelGeometry(state, pointGraphics));\n    }\n\n    tracks.push(trackGeometry);\n  }\n\n  // If one track, then use it otherwise combine into a multitrack\n  if (tracks.length === 1) {\n    geometries.push(tracks[0]);\n  } else if (tracks.length > 1) {\n    var multiTrackGeometry = kmlDoc.createElementNS(gxNamespace, \"MultiTrack\");\n\n    for (i = 0; i < tracks.length; ++i) {\n      multiTrackGeometry.appendChild(tracks[i]);\n    }\n\n    geometries.push(multiTrackGeometry);\n  }\n\n  // Create style\n  if (defined(pointGraphics) && !isModel) {\n    var iconStyle =\n      pointGraphics instanceof BillboardGraphics\n        ? createIconStyleFromBillboard(state, pointGraphics)\n        : createIconStyleFromPoint(state, pointGraphics);\n    styles.push(iconStyle);\n  }\n\n  // See if we have a line that needs to be drawn\n  var path = entity.path;\n  if (defined(path)) {\n    var width = valueGetter.get(path.width);\n    var material = path.material;\n    if (defined(material) || defined(width)) {\n      var lineStyle = kmlDoc.createElement(\"LineStyle\");\n      if (defined(width)) {\n        lineStyle.appendChild(\n          createBasicElementWithText(kmlDoc, \"width\", width)\n        );\n      }\n\n      processMaterial(state, material, lineStyle);\n      styles.push(lineStyle);\n    }\n  }\n}\n\nfunction createIconStyleFromPoint(state, pointGraphics) {\n  var kmlDoc = state.kmlDoc;\n  var valueGetter = state.valueGetter;\n\n  var iconStyle = kmlDoc.createElement(\"IconStyle\");\n\n  var color = valueGetter.getColor(pointGraphics.color);\n  if (defined(color)) {\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"color\", color));\n    iconStyle.appendChild(\n      createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\")\n    );\n  }\n\n  var pixelSize = valueGetter.get(pointGraphics.pixelSize);\n  if (defined(pixelSize)) {\n    iconStyle.appendChild(\n      createBasicElementWithText(kmlDoc, \"scale\", pixelSize / BILLBOARD_SIZE)\n    );\n  }\n\n  return iconStyle;\n}\n\nfunction createIconStyleFromBillboard(state, billboardGraphics) {\n  var kmlDoc = state.kmlDoc;\n  var valueGetter = state.valueGetter;\n  var externalFileHandler = state.externalFileHandler;\n\n  var iconStyle = kmlDoc.createElement(\"IconStyle\");\n\n  var image = valueGetter.get(billboardGraphics.image);\n  if (defined(image)) {\n    image = externalFileHandler.texture(image);\n\n    var icon = kmlDoc.createElement(\"Icon\");\n    icon.appendChild(createBasicElementWithText(kmlDoc, \"href\", image));\n\n    var imageSubRegion = valueGetter.get(billboardGraphics.imageSubRegion);\n    if (defined(imageSubRegion)) {\n      icon.appendChild(\n        createBasicElementWithText(kmlDoc, \"x\", imageSubRegion.x, gxNamespace)\n      );\n      icon.appendChild(\n        createBasicElementWithText(kmlDoc, \"y\", imageSubRegion.y, gxNamespace)\n      );\n      icon.appendChild(\n        createBasicElementWithText(\n          kmlDoc,\n          \"w\",\n          imageSubRegion.width,\n          gxNamespace\n        )\n      );\n      icon.appendChild(\n        createBasicElementWithText(\n          kmlDoc,\n          \"h\",\n          imageSubRegion.height,\n          gxNamespace\n        )\n      );\n    }\n\n    iconStyle.appendChild(icon);\n  }\n\n  var color = valueGetter.getColor(billboardGraphics.color);\n  if (defined(color)) {\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"color\", color));\n    iconStyle.appendChild(\n      createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\")\n    );\n  }\n\n  var scale = valueGetter.get(billboardGraphics.scale);\n  if (defined(scale)) {\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"scale\", scale));\n  }\n\n  var pixelOffset = valueGetter.get(billboardGraphics.pixelOffset);\n  if (defined(pixelOffset)) {\n    scale = defaultValue(scale, 1.0);\n\n    Cartesian2.divideByScalar(pixelOffset, scale, pixelOffset);\n\n    var width = valueGetter.get(billboardGraphics.width, BILLBOARD_SIZE);\n    var height = valueGetter.get(billboardGraphics.height, BILLBOARD_SIZE);\n\n    // KML Hotspots are from the bottom left, but we work from the top left\n\n    // Move to left\n    var horizontalOrigin = valueGetter.get(\n      billboardGraphics.horizontalOrigin,\n      HorizontalOrigin.CENTER\n    );\n    if (horizontalOrigin === HorizontalOrigin.CENTER) {\n      pixelOffset.x -= width * 0.5;\n    } else if (horizontalOrigin === HorizontalOrigin.RIGHT) {\n      pixelOffset.x -= width;\n    }\n\n    // Move to bottom\n    var verticalOrigin = valueGetter.get(\n      billboardGraphics.verticalOrigin,\n      VerticalOrigin.CENTER\n    );\n    if (verticalOrigin === VerticalOrigin.TOP) {\n      pixelOffset.y += height;\n    } else if (verticalOrigin === VerticalOrigin.CENTER) {\n      pixelOffset.y += height * 0.5;\n    }\n\n    var hotSpot = kmlDoc.createElement(\"hotSpot\");\n    hotSpot.setAttribute(\"x\", -pixelOffset.x);\n    hotSpot.setAttribute(\"y\", pixelOffset.y);\n    hotSpot.setAttribute(\"xunits\", \"pixels\");\n    hotSpot.setAttribute(\"yunits\", \"pixels\");\n\n    iconStyle.appendChild(hotSpot);\n  }\n\n  // We can only specify heading so if axis isn't Z, then we skip the rotation\n  // GE treats a heading of zero as no heading but can still point north using a 360 degree angle\n  var rotation = valueGetter.get(billboardGraphics.rotation);\n  var alignedAxis = valueGetter.get(billboardGraphics.alignedAxis);\n  if (defined(rotation) && Cartesian3.equals(Cartesian3.UNIT_Z, alignedAxis)) {\n    rotation = CesiumMath.toDegrees(-rotation);\n    if (rotation === 0) {\n      rotation = 360;\n    }\n\n    iconStyle.appendChild(\n      createBasicElementWithText(kmlDoc, \"heading\", rotation)\n    );\n  }\n\n  return iconStyle;\n}\n\nfunction createLineString(state, polylineGraphics, geometries, styles) {\n  var kmlDoc = state.kmlDoc;\n  var ellipsoid = state.ellipsoid;\n  var valueGetter = state.valueGetter;\n\n  if (!defined(polylineGraphics)) {\n    return;\n  }\n\n  var lineStringGeometry = kmlDoc.createElement(\"LineString\");\n\n  // Set altitude mode\n  var altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  var clampToGround = valueGetter.get(polylineGraphics.clampToGround, false);\n  var altitudeModeText;\n  if (clampToGround) {\n    lineStringGeometry.appendChild(\n      createBasicElementWithText(kmlDoc, \"tessellate\", true)\n    );\n    altitudeModeText = kmlDoc.createTextNode(\"clampToGround\");\n  } else {\n    altitudeModeText = kmlDoc.createTextNode(\"absolute\");\n  }\n  altitudeMode.appendChild(altitudeModeText);\n  lineStringGeometry.appendChild(altitudeMode);\n\n  // Set coordinates\n  var positionsProperty = polylineGraphics.positions;\n  var cartesians = valueGetter.get(positionsProperty);\n  var coordinates = createBasicElementWithText(\n    kmlDoc,\n    \"coordinates\",\n    getCoordinates(cartesians, ellipsoid)\n  );\n  lineStringGeometry.appendChild(coordinates);\n\n  // Set draw order\n  var zIndex = valueGetter.get(polylineGraphics.zIndex);\n  if (clampToGround && defined(zIndex)) {\n    lineStringGeometry.appendChild(\n      createBasicElementWithText(kmlDoc, \"drawOrder\", zIndex, gxNamespace)\n    );\n  }\n\n  geometries.push(lineStringGeometry);\n\n  // Create style\n  var lineStyle = kmlDoc.createElement(\"LineStyle\");\n\n  var width = valueGetter.get(polylineGraphics.width);\n  if (defined(width)) {\n    lineStyle.appendChild(createBasicElementWithText(kmlDoc, \"width\", width));\n  }\n\n  processMaterial(state, polylineGraphics.material, lineStyle);\n\n  styles.push(lineStyle);\n}\n\nfunction getRectangleBoundaries(state, rectangleGraphics, extrudedHeight) {\n  var kmlDoc = state.kmlDoc;\n  var valueGetter = state.valueGetter;\n\n  var coordinates;\n  var height = valueGetter.get(rectangleGraphics.height, 0.0);\n\n  if (extrudedHeight > 0) {\n    // We extrude up and KML extrudes down, so if we extrude, set the polygon height to\n    // the extruded height so KML will look similar to Cesium\n    height = extrudedHeight;\n  }\n\n  var coordinatesProperty = rectangleGraphics.coordinates;\n  var rectangle = valueGetter.get(coordinatesProperty);\n\n  var coordinateStrings = [];\n  var cornerFunction = [\n    Rectangle.northeast,\n    Rectangle.southeast,\n    Rectangle.southwest,\n    Rectangle.northwest,\n  ];\n\n  for (var i = 0; i < 4; ++i) {\n    cornerFunction[i](rectangle, scratchCartographic);\n    coordinateStrings.push(\n      CesiumMath.toDegrees(scratchCartographic.longitude) +\n        \",\" +\n        CesiumMath.toDegrees(scratchCartographic.latitude) +\n        \",\" +\n        height\n    );\n  }\n\n  coordinates = createBasicElementWithText(\n    kmlDoc,\n    \"coordinates\",\n    coordinateStrings.join(\" \")\n  );\n\n  var outerBoundaryIs = kmlDoc.createElement(\"outerBoundaryIs\");\n  var linearRing = kmlDoc.createElement(\"LinearRing\");\n  linearRing.appendChild(coordinates);\n  outerBoundaryIs.appendChild(linearRing);\n\n  return [outerBoundaryIs];\n}\n\nfunction getLinearRing(state, positions, height, perPositionHeight) {\n  var kmlDoc = state.kmlDoc;\n  var ellipsoid = state.ellipsoid;\n\n  var coordinateStrings = [];\n  var positionCount = positions.length;\n  for (var i = 0; i < positionCount; ++i) {\n    Cartographic.fromCartesian(positions[i], ellipsoid, scratchCartographic);\n    coordinateStrings.push(\n      CesiumMath.toDegrees(scratchCartographic.longitude) +\n        \",\" +\n        CesiumMath.toDegrees(scratchCartographic.latitude) +\n        \",\" +\n        (perPositionHeight ? scratchCartographic.height : height)\n    );\n  }\n\n  var coordinates = createBasicElementWithText(\n    kmlDoc,\n    \"coordinates\",\n    coordinateStrings.join(\" \")\n  );\n  var linearRing = kmlDoc.createElement(\"LinearRing\");\n  linearRing.appendChild(coordinates);\n\n  return linearRing;\n}\n\nfunction getPolygonBoundaries(state, polygonGraphics, extrudedHeight) {\n  var kmlDoc = state.kmlDoc;\n  var valueGetter = state.valueGetter;\n\n  var height = valueGetter.get(polygonGraphics.height, 0.0);\n  var perPositionHeight = valueGetter.get(\n    polygonGraphics.perPositionHeight,\n    false\n  );\n\n  if (!perPositionHeight && extrudedHeight > 0) {\n    // We extrude up and KML extrudes down, so if we extrude, set the polygon height to\n    // the extruded height so KML will look similar to Cesium\n    height = extrudedHeight;\n  }\n\n  var boundaries = [];\n  var hierarchyProperty = polygonGraphics.hierarchy;\n  var hierarchy = valueGetter.get(hierarchyProperty);\n\n  // Polygon hierarchy can sometimes just be an array of positions\n  var positions = Array.isArray(hierarchy) ? hierarchy : hierarchy.positions;\n\n  // Polygon boundaries\n  var outerBoundaryIs = kmlDoc.createElement(\"outerBoundaryIs\");\n  outerBoundaryIs.appendChild(\n    getLinearRing(state, positions, height, perPositionHeight)\n  );\n  boundaries.push(outerBoundaryIs);\n\n  // Hole boundaries\n  var holes = hierarchy.holes;\n  if (defined(holes)) {\n    var holeCount = holes.length;\n    for (var i = 0; i < holeCount; ++i) {\n      var innerBoundaryIs = kmlDoc.createElement(\"innerBoundaryIs\");\n      innerBoundaryIs.appendChild(\n        getLinearRing(state, holes[i].positions, height, perPositionHeight)\n      );\n      boundaries.push(innerBoundaryIs);\n    }\n  }\n\n  return boundaries;\n}\n\nfunction createPolygon(state, geometry, geometries, styles, overlays) {\n  var kmlDoc = state.kmlDoc;\n  var valueGetter = state.valueGetter;\n\n  if (!defined(geometry)) {\n    return;\n  }\n\n  // Detect textured quads and use ground overlays instead\n  var isRectangle = geometry instanceof RectangleGraphics;\n  if (\n    isRectangle &&\n    valueGetter.getMaterialType(geometry.material) === \"Image\"\n  ) {\n    createGroundOverlay(state, geometry, overlays);\n    return;\n  }\n\n  var polygonGeometry = kmlDoc.createElement(\"Polygon\");\n\n  var extrudedHeight = valueGetter.get(geometry.extrudedHeight, 0.0);\n  if (extrudedHeight > 0) {\n    polygonGeometry.appendChild(\n      createBasicElementWithText(kmlDoc, \"extrude\", true)\n    );\n  }\n\n  // Set boundaries\n  var boundaries = isRectangle\n    ? getRectangleBoundaries(state, geometry, extrudedHeight)\n    : getPolygonBoundaries(state, geometry, extrudedHeight);\n\n  var boundaryCount = boundaries.length;\n  for (var i = 0; i < boundaryCount; ++i) {\n    polygonGeometry.appendChild(boundaries[i]);\n  }\n\n  // Set altitude mode\n  var altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  altitudeMode.appendChild(getAltitudeMode(state, geometry.heightReference));\n  polygonGeometry.appendChild(altitudeMode);\n\n  geometries.push(polygonGeometry);\n\n  // Create style\n  var polyStyle = kmlDoc.createElement(\"PolyStyle\");\n\n  var fill = valueGetter.get(geometry.fill, false);\n  if (fill) {\n    polyStyle.appendChild(createBasicElementWithText(kmlDoc, \"fill\", fill));\n  }\n\n  processMaterial(state, geometry.material, polyStyle);\n\n  var outline = valueGetter.get(geometry.outline, false);\n  if (outline) {\n    polyStyle.appendChild(\n      createBasicElementWithText(kmlDoc, \"outline\", outline)\n    );\n\n    // Outline uses LineStyle\n    var lineStyle = kmlDoc.createElement(\"LineStyle\");\n\n    var outlineWidth = valueGetter.get(geometry.outlineWidth, 1.0);\n    lineStyle.appendChild(\n      createBasicElementWithText(kmlDoc, \"width\", outlineWidth)\n    );\n\n    var outlineColor = valueGetter.getColor(geometry.outlineColor, Color.BLACK);\n    lineStyle.appendChild(\n      createBasicElementWithText(kmlDoc, \"color\", outlineColor)\n    );\n    lineStyle.appendChild(\n      createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\")\n    );\n\n    styles.push(lineStyle);\n  }\n\n  styles.push(polyStyle);\n}\n\nfunction createGroundOverlay(state, rectangleGraphics, overlays) {\n  var kmlDoc = state.kmlDoc;\n  var valueGetter = state.valueGetter;\n  var externalFileHandler = state.externalFileHandler;\n\n  var groundOverlay = kmlDoc.createElement(\"GroundOverlay\");\n\n  // Set altitude mode\n  var altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  altitudeMode.appendChild(\n    getAltitudeMode(state, rectangleGraphics.heightReference)\n  );\n  groundOverlay.appendChild(altitudeMode);\n\n  var height = valueGetter.get(rectangleGraphics.height);\n  if (defined(height)) {\n    groundOverlay.appendChild(\n      createBasicElementWithText(kmlDoc, \"altitude\", height)\n    );\n  }\n\n  var rectangle = valueGetter.get(rectangleGraphics.coordinates);\n  var latLonBox = kmlDoc.createElement(\"LatLonBox\");\n  latLonBox.appendChild(\n    createBasicElementWithText(\n      kmlDoc,\n      \"north\",\n      CesiumMath.toDegrees(rectangle.north)\n    )\n  );\n  latLonBox.appendChild(\n    createBasicElementWithText(\n      kmlDoc,\n      \"south\",\n      CesiumMath.toDegrees(rectangle.south)\n    )\n  );\n  latLonBox.appendChild(\n    createBasicElementWithText(\n      kmlDoc,\n      \"east\",\n      CesiumMath.toDegrees(rectangle.east)\n    )\n  );\n  latLonBox.appendChild(\n    createBasicElementWithText(\n      kmlDoc,\n      \"west\",\n      CesiumMath.toDegrees(rectangle.west)\n    )\n  );\n  groundOverlay.appendChild(latLonBox);\n\n  // We should only end up here if we have an ImageMaterialProperty\n  var material = valueGetter.get(rectangleGraphics.material);\n  var href = externalFileHandler.texture(material.image);\n  var icon = kmlDoc.createElement(\"Icon\");\n  icon.appendChild(createBasicElementWithText(kmlDoc, \"href\", href));\n  groundOverlay.appendChild(icon);\n\n  var color = material.color;\n  if (defined(color)) {\n    groundOverlay.appendChild(\n      createBasicElementWithText(kmlDoc, \"color\", colorToString(material.color))\n    );\n  }\n\n  overlays.push(groundOverlay);\n}\n\nfunction createModelGeometry(state, modelGraphics) {\n  var kmlDoc = state.kmlDoc;\n  var valueGetter = state.valueGetter;\n  var externalFileHandler = state.externalFileHandler;\n\n  var modelGeometry = kmlDoc.createElement(\"Model\");\n\n  var scale = valueGetter.get(modelGraphics.scale);\n  if (defined(scale)) {\n    var scaleElement = kmlDoc.createElement(\"scale\");\n    scaleElement.appendChild(createBasicElementWithText(kmlDoc, \"x\", scale));\n    scaleElement.appendChild(createBasicElementWithText(kmlDoc, \"y\", scale));\n    scaleElement.appendChild(createBasicElementWithText(kmlDoc, \"z\", scale));\n    modelGeometry.appendChild(scaleElement);\n  }\n\n  var link = kmlDoc.createElement(\"Link\");\n  var uri = externalFileHandler.model(modelGraphics, state.time);\n\n  link.appendChild(createBasicElementWithText(kmlDoc, \"href\", uri));\n  modelGeometry.appendChild(link);\n\n  return modelGeometry;\n}\n\nfunction createModel(state, entity, modelGraphics, geometries, styles) {\n  var kmlDoc = state.kmlDoc;\n  var ellipsoid = state.ellipsoid;\n  var valueGetter = state.valueGetter;\n\n  if (!defined(modelGraphics)) {\n    return;\n  }\n\n  // If the point isn't constant then create gx:Track or gx:MultiTrack\n  var entityPositionProperty = entity.position;\n  if (!entityPositionProperty.isConstant) {\n    createTracks(state, entity, modelGraphics, geometries, styles);\n    return;\n  }\n\n  var modelGeometry = createModelGeometry(state, modelGraphics);\n\n  // Set altitude mode\n  var altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  altitudeMode.appendChild(\n    getAltitudeMode(state, modelGraphics.heightReference)\n  );\n  modelGeometry.appendChild(altitudeMode);\n\n  valueGetter.get(entityPositionProperty, undefined, scratchCartesian3);\n  Cartographic.fromCartesian(scratchCartesian3, ellipsoid, scratchCartographic);\n  var location = kmlDoc.createElement(\"Location\");\n  location.appendChild(\n    createBasicElementWithText(\n      kmlDoc,\n      \"longitude\",\n      CesiumMath.toDegrees(scratchCartographic.longitude)\n    )\n  );\n  location.appendChild(\n    createBasicElementWithText(\n      kmlDoc,\n      \"latitude\",\n      CesiumMath.toDegrees(scratchCartographic.latitude)\n    )\n  );\n  location.appendChild(\n    createBasicElementWithText(kmlDoc, \"altitude\", scratchCartographic.height)\n  );\n  modelGeometry.appendChild(location);\n\n  geometries.push(modelGeometry);\n}\n\nfunction processMaterial(state, materialProperty, style) {\n  var kmlDoc = state.kmlDoc;\n  var valueGetter = state.valueGetter;\n\n  if (!defined(materialProperty)) {\n    return;\n  }\n\n  var material = valueGetter.get(materialProperty);\n  if (!defined(material)) {\n    return;\n  }\n\n  var color;\n  var type = valueGetter.getMaterialType(materialProperty);\n  switch (type) {\n    case \"Image\":\n      // Image materials are only able to be represented on rectangles, so if we make it\n      //  here we can't texture a generic polygon or polyline in KML, so just use white.\n      color = colorToString(Color.WHITE);\n      break;\n    case \"Color\":\n    case \"Grid\":\n    case \"PolylineGlow\":\n    case \"PolylineArrow\":\n    case \"PolylineDash\":\n      color = colorToString(material.color);\n      break;\n    case \"PolylineOutline\":\n      color = colorToString(material.color);\n\n      var outlineColor = colorToString(material.outlineColor);\n      var outlineWidth = material.outlineWidth;\n      style.appendChild(\n        createBasicElementWithText(\n          kmlDoc,\n          \"outerColor\",\n          outlineColor,\n          gxNamespace\n        )\n      );\n      style.appendChild(\n        createBasicElementWithText(\n          kmlDoc,\n          \"outerWidth\",\n          outlineWidth,\n          gxNamespace\n        )\n      );\n      break;\n    case \"Stripe\":\n      color = colorToString(material.oddColor);\n      break;\n  }\n\n  if (defined(color)) {\n    style.appendChild(createBasicElementWithText(kmlDoc, \"color\", color));\n    style.appendChild(\n      createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\")\n    );\n  }\n}\n\nfunction getAltitudeMode(state, heightReferenceProperty) {\n  var kmlDoc = state.kmlDoc;\n  var valueGetter = state.valueGetter;\n\n  var heightReference = valueGetter.get(\n    heightReferenceProperty,\n    HeightReference.NONE\n  );\n  var altitudeModeText;\n  switch (heightReference) {\n    case HeightReference.NONE:\n      altitudeModeText = kmlDoc.createTextNode(\"absolute\");\n      break;\n    case HeightReference.CLAMP_TO_GROUND:\n      altitudeModeText = kmlDoc.createTextNode(\"clampToGround\");\n      break;\n    case HeightReference.RELATIVE_TO_GROUND:\n      altitudeModeText = kmlDoc.createTextNode(\"relativeToGround\");\n      break;\n  }\n\n  return altitudeModeText;\n}\n\nfunction getCoordinates(coordinates, ellipsoid) {\n  if (!Array.isArray(coordinates)) {\n    coordinates = [coordinates];\n  }\n\n  var count = coordinates.length;\n  var coordinateStrings = [];\n  for (var i = 0; i < count; ++i) {\n    Cartographic.fromCartesian(coordinates[i], ellipsoid, scratchCartographic);\n    coordinateStrings.push(\n      CesiumMath.toDegrees(scratchCartographic.longitude) +\n        \",\" +\n        CesiumMath.toDegrees(scratchCartographic.latitude) +\n        \",\" +\n        scratchCartographic.height\n    );\n  }\n\n  return coordinateStrings.join(\" \");\n}\n\nfunction createBasicElementWithText(\n  kmlDoc,\n  elementName,\n  elementValue,\n  namespace\n) {\n  elementValue = defaultValue(elementValue, \"\");\n\n  if (typeof elementValue === \"boolean\") {\n    elementValue = elementValue ? \"1\" : \"0\";\n  }\n\n  // Create element with optional namespace\n  var element = defined(namespace)\n    ? kmlDoc.createElementNS(namespace, elementName)\n    : kmlDoc.createElement(elementName);\n\n  // Wrap value in CDATA section if it contains HTML\n  var text =\n    elementValue === \"string\" && elementValue.indexOf(\"<\") !== -1\n      ? kmlDoc.createCDATASection(elementValue)\n      : kmlDoc.createTextNode(elementValue);\n\n  element.appendChild(text);\n\n  return element;\n}\n\nfunction colorToString(color) {\n  var result = \"\";\n  var bytes = color.toBytes();\n  for (var i = 3; i >= 0; --i) {\n    result +=\n      bytes[i] < 16 ? \"0\" + bytes[i].toString(16) : bytes[i].toString(16);\n  }\n\n  return result;\n}\n\n/**\n * Since KML does not support glTF models, this callback is required to specify what URL to use for the model in the KML document.\n * It can also be used to add additional files to the <code>externalFiles</code> object, which is the list of files embedded in the exported KMZ,\n * or otherwise returned with the KML string when exporting.\n *\n * @callback exportKml~ModelCallback\n *\n * @param {ModelGraphics} model The ModelGraphics instance for an Entity.\n * @param {JulianDate} time The time that any properties should use to get the value.\n * @param {Object} externalFiles An object that maps a filename to a Blob or a Promise that resolves to a Blob.\n * @returns {String} The URL to use for the href in the KML document.\n */\nexport default exportKml;\n"]},"metadata":{},"sourceType":"module"}