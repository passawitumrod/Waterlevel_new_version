{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nvar viewerPositionWCScratch = new Cartesian3();\n\nfunction AutomaticUniform(options) {\n  this._size = options.size;\n  this._datatype = options.datatype;\n  this.getValue = options.getValue;\n}\n\nvar datatypeToGlsl = {};\ndatatypeToGlsl[WebGLConstants.FLOAT] = \"float\";\ndatatypeToGlsl[WebGLConstants.FLOAT_VEC2] = \"vec2\";\ndatatypeToGlsl[WebGLConstants.FLOAT_VEC3] = \"vec3\";\ndatatypeToGlsl[WebGLConstants.FLOAT_VEC4] = \"vec4\";\ndatatypeToGlsl[WebGLConstants.INT] = \"int\";\ndatatypeToGlsl[WebGLConstants.INT_VEC2] = \"ivec2\";\ndatatypeToGlsl[WebGLConstants.INT_VEC3] = \"ivec3\";\ndatatypeToGlsl[WebGLConstants.INT_VEC4] = \"ivec4\";\ndatatypeToGlsl[WebGLConstants.BOOL] = \"bool\";\ndatatypeToGlsl[WebGLConstants.BOOL_VEC2] = \"bvec2\";\ndatatypeToGlsl[WebGLConstants.BOOL_VEC3] = \"bvec3\";\ndatatypeToGlsl[WebGLConstants.BOOL_VEC4] = \"bvec4\";\ndatatypeToGlsl[WebGLConstants.FLOAT_MAT2] = \"mat2\";\ndatatypeToGlsl[WebGLConstants.FLOAT_MAT3] = \"mat3\";\ndatatypeToGlsl[WebGLConstants.FLOAT_MAT4] = \"mat4\";\ndatatypeToGlsl[WebGLConstants.SAMPLER_2D] = \"sampler2D\";\ndatatypeToGlsl[WebGLConstants.SAMPLER_CUBE] = \"samplerCube\";\n\nAutomaticUniform.prototype.getDeclaration = function (name) {\n  var declaration = \"uniform \" + datatypeToGlsl[this._datatype] + \" \" + name;\n  var size = this._size;\n\n  if (size === 1) {\n    declaration += \";\";\n  } else {\n    declaration += \"[\" + size.toString() + \"];\";\n  }\n\n  return declaration;\n};\n/**\n * @private\n */\n\n\nvar AutomaticUniforms = {\n  /**\n   * An automatic GLSL uniform containing the viewport's <code>x</code>, <code>y</code>, <code>width</code>,\n   * and <code>height</code> properties in an <code>vec4</code>'s <code>x</code>, <code>y</code>, <code>z</code>,\n   * and <code>w</code> components, respectively.\n   *\n   * @alias czm_viewport\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec4 czm_viewport;\n   *\n   * // Scale the window coordinate components to [0, 1] by dividing\n   * // by the viewport's width and height.\n   * vec2 v = gl_FragCoord.xy / czm_viewport.zw;\n   *\n   * @see Context#getViewport\n   */\n  czm_viewport: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC4,\n    getValue: function (uniformState) {\n      return uniformState.viewportCartesian4;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 orthographic projection matrix that\n   * transforms window coordinates to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   * <br /><br />\n   * This transform is useful when a vertex shader inputs or manipulates window coordinates\n   * as done by {@link BillboardCollection}.\n   * <br /><br />\n   * Do not confuse {@link czm_viewportTransformation} with <code>czm_viewportOrthographic</code>.\n   * The former transforms from normalized device coordinates to window coordinates; the later transforms\n   * from window coordinates to clip coordinates, and is often used to assign to <code>gl_Position</code>.\n   *\n   * @alias czm_viewportOrthographic\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_viewportOrthographic;\n   *\n   * // Example\n   * gl_Position = czm_viewportOrthographic * vec4(windowPosition, 0.0, 1.0);\n   *\n   * @see UniformState#viewportOrthographic\n   * @see czm_viewport\n   * @see czm_viewportTransformation\n   * @see BillboardCollection\n   */\n  czm_viewportOrthographic: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.viewportOrthographic;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 transformation matrix that\n   * transforms normalized device coordinates to window coordinates.  The context's\n   * full viewport is used, and the depth range is assumed to be <code>near = 0</code>\n   * and <code>far = 1</code>.\n   * <br /><br />\n   * This transform is useful when there is a need to manipulate window coordinates\n   * in a vertex shader as done by {@link BillboardCollection}.  In many cases,\n   * this matrix will not be used directly; instead, {@link czm_modelToWindowCoordinates}\n   * will be used to transform directly from model to window coordinates.\n   * <br /><br />\n   * Do not confuse <code>czm_viewportTransformation</code> with {@link czm_viewportOrthographic}.\n   * The former transforms from normalized device coordinates to window coordinates; the later transforms\n   * from window coordinates to clip coordinates, and is often used to assign to <code>gl_Position</code>.\n   *\n   * @alias czm_viewportTransformation\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_viewportTransformation;\n   *\n   * // Use czm_viewportTransformation as part of the\n   * // transform from model to window coordinates.\n   * vec4 q = czm_modelViewProjection * positionMC;               // model to clip coordinates\n   * q.xyz /= q.w;                                                // clip to normalized device coordinates (ndc)\n   * q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // ndc to window coordinates\n   *\n   * @see UniformState#viewportTransformation\n   * @see czm_viewport\n   * @see czm_viewportOrthographic\n   * @see czm_modelToWindowCoordinates\n   * @see BillboardCollection\n   */\n  czm_viewportTransformation: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.viewportTransformation;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the depth of the scene\n   * after the globe pass and then updated after the 3D Tiles pass.\n   * The depth is packed into an RGBA texture.\n   *\n   * @private\n   *\n   * @alias czm_globeDepthTexture\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform sampler2D czm_globeDepthTexture;\n   *\n   * // Get the depth at the current fragment\n   * vec2 coords = gl_FragCoord.xy / czm_viewport.zw;\n   * float depth = czm_unpackDepth(texture2D(czm_globeDepthTexture, coords));\n   */\n  czm_globeDepthTexture: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.SAMPLER_2D,\n    getValue: function (uniformState) {\n      return uniformState.globeDepthTexture;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 model transformation matrix that\n   * transforms model coordinates to world coordinates.\n   *\n   * @alias czm_model\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_model;\n   *\n   * // Example\n   * vec4 worldPosition = czm_model * modelPosition;\n   *\n   * @see UniformState#model\n   * @see czm_inverseModel\n   * @see czm_modelView\n   * @see czm_modelViewProjection\n   */\n  czm_model: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.model;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 model transformation matrix that\n   * transforms world coordinates to model coordinates.\n   *\n   * @alias czm_inverseModel\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseModel;\n   *\n   * // Example\n   * vec4 modelPosition = czm_inverseModel * worldPosition;\n   *\n   * @see UniformState#inverseModel\n   * @see czm_model\n   * @see czm_inverseModelView\n   */\n  czm_inverseModel: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseModel;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 view transformation matrix that\n   * transforms world coordinates to eye coordinates.\n   *\n   * @alias czm_view\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_view;\n   *\n   * // Example\n   * vec4 eyePosition = czm_view * worldPosition;\n   *\n   * @see UniformState#view\n   * @see czm_viewRotation\n   * @see czm_modelView\n   * @see czm_viewProjection\n   * @see czm_modelViewProjection\n   * @see czm_inverseView\n   */\n  czm_view: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.view;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 view transformation matrix that\n   * transforms 3D world coordinates to eye coordinates.  In 3D mode, this is identical to\n   * {@link czm_view}, but in 2D and Columbus View it represents the view matrix\n   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   *\n   * @alias czm_view3D\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_view3D;\n   *\n   * // Example\n   * vec4 eyePosition3D = czm_view3D * worldPosition3D;\n   *\n   * @see UniformState#view3D\n   * @see czm_view\n   */\n  czm_view3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.view3D;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 view rotation matrix that\n   * transforms vectors in world coordinates to eye coordinates.\n   *\n   * @alias czm_viewRotation\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_viewRotation;\n   *\n   * // Example\n   * vec3 eyeVector = czm_viewRotation * worldVector;\n   *\n   * @see UniformState#viewRotation\n   * @see czm_view\n   * @see czm_inverseView\n   * @see czm_inverseViewRotation\n   */\n  czm_viewRotation: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.viewRotation;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 view rotation matrix that\n   * transforms vectors in 3D world coordinates to eye coordinates.  In 3D mode, this is identical to\n   * {@link czm_viewRotation}, but in 2D and Columbus View it represents the view matrix\n   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   *\n   * @alias czm_viewRotation3D\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_viewRotation3D;\n   *\n   * // Example\n   * vec3 eyeVector = czm_viewRotation3D * worldVector;\n   *\n   * @see UniformState#viewRotation3D\n   * @see czm_viewRotation\n   */\n  czm_viewRotation3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.viewRotation3D;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 transformation matrix that\n   * transforms from eye coordinates to world coordinates.\n   *\n   * @alias czm_inverseView\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseView;\n   *\n   * // Example\n   * vec4 worldPosition = czm_inverseView * eyePosition;\n   *\n   * @see UniformState#inverseView\n   * @see czm_view\n   * @see czm_inverseNormal\n   */\n  czm_inverseView: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseView;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 transformation matrix that\n   * transforms from 3D eye coordinates to world coordinates.  In 3D mode, this is identical to\n   * {@link czm_inverseView}, but in 2D and Columbus View it represents the inverse view matrix\n   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   *\n   * @alias czm_inverseView3D\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseView3D;\n   *\n   * // Example\n   * vec4 worldPosition = czm_inverseView3D * eyePosition;\n   *\n   * @see UniformState#inverseView3D\n   * @see czm_inverseView\n   */\n  czm_inverseView3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseView3D;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 rotation matrix that\n   * transforms vectors from eye coordinates to world coordinates.\n   *\n   * @alias czm_inverseViewRotation\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_inverseViewRotation;\n   *\n   * // Example\n   * vec4 worldVector = czm_inverseViewRotation * eyeVector;\n   *\n   * @see UniformState#inverseView\n   * @see czm_view\n   * @see czm_viewRotation\n   * @see czm_inverseViewRotation\n   */\n  czm_inverseViewRotation: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.inverseViewRotation;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 rotation matrix that\n   * transforms vectors from 3D eye coordinates to world coordinates.  In 3D mode, this is identical to\n   * {@link czm_inverseViewRotation}, but in 2D and Columbus View it represents the inverse view matrix\n   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   *\n   * @alias czm_inverseViewRotation3D\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_inverseViewRotation3D;\n   *\n   * // Example\n   * vec4 worldVector = czm_inverseViewRotation3D * eyeVector;\n   *\n   * @see UniformState#inverseView3D\n   * @see czm_inverseViewRotation\n   */\n  czm_inverseViewRotation3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.inverseViewRotation3D;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 projection transformation matrix that\n   * transforms eye coordinates to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   *\n   * @alias czm_projection\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_projection;\n   *\n   * // Example\n   * gl_Position = czm_projection * eyePosition;\n   *\n   * @see UniformState#projection\n   * @see czm_viewProjection\n   * @see czm_modelViewProjection\n   * @see czm_infiniteProjection\n   */\n  czm_projection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.projection;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 inverse projection transformation matrix that\n   * transforms from clip coordinates to eye coordinates. Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   *\n   * @alias czm_inverseProjection\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseProjection;\n   *\n   * // Example\n   * vec4 eyePosition = czm_inverseProjection * clipPosition;\n   *\n   * @see UniformState#inverseProjection\n   * @see czm_projection\n   */\n  czm_inverseProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseProjection;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 projection transformation matrix with the far plane at infinity,\n   * that transforms eye coordinates to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.  An infinite far plane is used\n   * in algorithms like shadow volumes and GPU ray casting with proxy geometry to ensure that triangles\n   * are not clipped by the far plane.\n   *\n   * @alias czm_infiniteProjection\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_infiniteProjection;\n   *\n   * // Example\n   * gl_Position = czm_infiniteProjection * eyePosition;\n   *\n   * @see UniformState#infiniteProjection\n   * @see czm_projection\n   * @see czm_modelViewInfiniteProjection\n   */\n  czm_infiniteProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.infiniteProjection;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that\n   * transforms model coordinates to eye coordinates.\n   * <br /><br />\n   * Positions should be transformed to eye coordinates using <code>czm_modelView</code> and\n   * normals should be transformed using {@link czm_normal}.\n   *\n   * @alias czm_modelView\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_modelView;\n   *\n   * // Example\n   * vec4 eyePosition = czm_modelView * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * vec4 eyePosition = czm_view * czm_model * modelPosition;\n   *\n   * @see UniformState#modelView\n   * @see czm_model\n   * @see czm_view\n   * @see czm_modelViewProjection\n   * @see czm_normal\n   */\n  czm_modelView: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.modelView;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that\n   * transforms 3D model coordinates to eye coordinates.  In 3D mode, this is identical to\n   * {@link czm_modelView}, but in 2D and Columbus View it represents the model-view matrix\n   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   * <br /><br />\n   * Positions should be transformed to eye coordinates using <code>czm_modelView3D</code> and\n   * normals should be transformed using {@link czm_normal3D}.\n   *\n   * @alias czm_modelView3D\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_modelView3D;\n   *\n   * // Example\n   * vec4 eyePosition = czm_modelView3D * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * vec4 eyePosition = czm_view3D * czm_model * modelPosition;\n   *\n   * @see UniformState#modelView3D\n   * @see czm_modelView\n   */\n  czm_modelView3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.modelView3D;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that\n   * transforms model coordinates, relative to the eye, to eye coordinates.  This is used\n   * in conjunction with {@link czm_translateRelativeToEye}.\n   *\n   * @alias czm_modelViewRelativeToEye\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_modelViewRelativeToEye;\n   *\n   * // Example\n   * attribute vec3 positionHigh;\n   * attribute vec3 positionLow;\n   *\n   * void main()\n   * {\n   *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n   *   gl_Position = czm_projection * (czm_modelViewRelativeToEye * p);\n   * }\n   *\n   * @see czm_modelViewProjectionRelativeToEye\n   * @see czm_translateRelativeToEye\n   * @see EncodedCartesian3\n   */\n  czm_modelViewRelativeToEye: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.modelViewRelativeToEye;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 transformation matrix that\n   * transforms from eye coordinates to model coordinates.\n   *\n   * @alias czm_inverseModelView\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseModelView;\n   *\n   * // Example\n   * vec4 modelPosition = czm_inverseModelView * eyePosition;\n   *\n   * @see UniformState#inverseModelView\n   * @see czm_modelView\n   */\n  czm_inverseModelView: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseModelView;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 transformation matrix that\n   * transforms from eye coordinates to 3D model coordinates.  In 3D mode, this is identical to\n   * {@link czm_inverseModelView}, but in 2D and Columbus View it represents the inverse model-view matrix\n   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   *\n   * @alias czm_inverseModelView3D\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseModelView3D;\n   *\n   * // Example\n   * vec4 modelPosition = czm_inverseModelView3D * eyePosition;\n   *\n   * @see UniformState#inverseModelView\n   * @see czm_inverseModelView\n   * @see czm_modelView3D\n   */\n  czm_inverseModelView3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseModelView3D;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 view-projection transformation matrix that\n   * transforms world coordinates to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   *\n   * @alias czm_viewProjection\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_viewProjection;\n   *\n   * // Example\n   * vec4 gl_Position = czm_viewProjection * czm_model * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * gl_Position = czm_projection * czm_view * czm_model * modelPosition;\n   *\n   * @see UniformState#viewProjection\n   * @see czm_view\n   * @see czm_projection\n   * @see czm_modelViewProjection\n   * @see czm_inverseViewProjection\n   */\n  czm_viewProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.viewProjection;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 view-projection transformation matrix that\n   * transforms clip coordinates to world coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   *\n   * @alias czm_inverseViewProjection\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseViewProjection;\n   *\n   * // Example\n   * vec4 worldPosition = czm_inverseViewProjection * clipPosition;\n   *\n   * @see UniformState#inverseViewProjection\n   * @see czm_viewProjection\n   */\n  czm_inverseViewProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseViewProjection;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that\n   * transforms model coordinates to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   *\n   * @alias czm_modelViewProjection\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_modelViewProjection;\n   *\n   * // Example\n   * vec4 gl_Position = czm_modelViewProjection * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * gl_Position = czm_projection * czm_view * czm_model * modelPosition;\n   *\n   * @see UniformState#modelViewProjection\n   * @see czm_model\n   * @see czm_view\n   * @see czm_projection\n   * @see czm_modelView\n   * @see czm_viewProjection\n   * @see czm_modelViewInfiniteProjection\n   * @see czm_inverseModelViewProjection\n   */\n  czm_modelViewProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.modelViewProjection;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 inverse model-view-projection transformation matrix that\n   * transforms clip coordinates to model coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   *\n   * @alias czm_inverseModelViewProjection\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseModelViewProjection;\n   *\n   * // Example\n   * vec4 modelPosition = czm_inverseModelViewProjection * clipPosition;\n   *\n   * @see UniformState#modelViewProjection\n   * @see czm_modelViewProjection\n   */\n  czm_inverseModelViewProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseModelViewProjection;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that\n   * transforms model coordinates, relative to the eye, to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.  This is used in\n   * conjunction with {@link czm_translateRelativeToEye}.\n   *\n   * @alias czm_modelViewProjectionRelativeToEye\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_modelViewProjectionRelativeToEye;\n   *\n   * // Example\n   * attribute vec3 positionHigh;\n   * attribute vec3 positionLow;\n   *\n   * void main()\n   * {\n   *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n   *   gl_Position = czm_modelViewProjectionRelativeToEye * p;\n   * }\n   *\n   * @see czm_modelViewRelativeToEye\n   * @see czm_translateRelativeToEye\n   * @see EncodedCartesian3\n   */\n  czm_modelViewProjectionRelativeToEye: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.modelViewProjectionRelativeToEye;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that\n   * transforms model coordinates to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.  The projection matrix places\n   * the far plane at infinity.  This is useful in algorithms like shadow volumes and GPU ray casting with\n   * proxy geometry to ensure that triangles are not clipped by the far plane.\n   *\n   * @alias czm_modelViewInfiniteProjection\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_modelViewInfiniteProjection;\n   *\n   * // Example\n   * vec4 gl_Position = czm_modelViewInfiniteProjection * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * gl_Position = czm_infiniteProjection * czm_view * czm_model * modelPosition;\n   *\n   * @see UniformState#modelViewInfiniteProjection\n   * @see czm_model\n   * @see czm_view\n   * @see czm_infiniteProjection\n   * @see czm_modelViewProjection\n   */\n  czm_modelViewInfiniteProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.modelViewInfiniteProjection;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform that indicates if the current camera is orthographic in 3D.\n   *\n   * @alias czm_orthographicIn3D\n   * @namespace\n   * @glslUniform\n   * @see UniformState#orthographicIn3D\n   */\n  czm_orthographicIn3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.orthographicIn3D ? 1 : 0;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that\n   * transforms normal vectors in model coordinates to eye coordinates.\n   * <br /><br />\n   * Positions should be transformed to eye coordinates using {@link czm_modelView} and\n   * normals should be transformed using <code>czm_normal</code>.\n   *\n   * @alias czm_normal\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_normal;\n   *\n   * // Example\n   * vec3 eyeNormal = czm_normal * normal;\n   *\n   * @see UniformState#normal\n   * @see czm_inverseNormal\n   * @see czm_modelView\n   */\n  czm_normal: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.normal;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that\n   * transforms normal vectors in 3D model coordinates to eye coordinates.\n   * In 3D mode, this is identical to\n   * {@link czm_normal}, but in 2D and Columbus View it represents the normal transformation\n   * matrix as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   * <br /><br />\n   * Positions should be transformed to eye coordinates using {@link czm_modelView3D} and\n   * normals should be transformed using <code>czm_normal3D</code>.\n   *\n   * @alias czm_normal3D\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_normal3D;\n   *\n   * // Example\n   * vec3 eyeNormal = czm_normal3D * normal;\n   *\n   * @see UniformState#normal3D\n   * @see czm_normal\n   */\n  czm_normal3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.normal3D;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that\n   * transforms normal vectors in eye coordinates to model coordinates.  This is\n   * the opposite of the transform provided by {@link czm_normal}.\n   *\n   * @alias czm_inverseNormal\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_inverseNormal;\n   *\n   * // Example\n   * vec3 normalMC = czm_inverseNormal * normalEC;\n   *\n   * @see UniformState#inverseNormal\n   * @see czm_normal\n   * @see czm_modelView\n   * @see czm_inverseView\n   */\n  czm_inverseNormal: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.inverseNormal;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that\n   * transforms normal vectors in eye coordinates to 3D model coordinates.  This is\n   * the opposite of the transform provided by {@link czm_normal}.\n   * In 3D mode, this is identical to\n   * {@link czm_inverseNormal}, but in 2D and Columbus View it represents the inverse normal transformation\n   * matrix as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   *\n   * @alias czm_inverseNormal3D\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_inverseNormal3D;\n   *\n   * // Example\n   * vec3 normalMC = czm_inverseNormal3D * normalEC;\n   *\n   * @see UniformState#inverseNormal3D\n   * @see czm_inverseNormal\n   */\n  czm_inverseNormal3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.inverseNormal3D;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform containing height (<code>x</code>) and height squared (<code>y</code>)\n   *  of the eye (camera) in the 2D scene in meters.\n   *\n   * @alias czm_eyeHeight2D\n   * @namespace\n   * @glslUniform\n   *\n   * @see UniformState#eyeHeight2D\n   */\n  czm_eyeHeight2D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC2,\n    getValue: function (uniformState) {\n      return uniformState.eyeHeight2D;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the near distance (<code>x</code>) and the far distance (<code>y</code>)\n   * of the frustum defined by the camera.  This is the largest possible frustum, not an individual\n   * frustum used for multi-frustum rendering.\n   *\n   * @alias czm_entireFrustum\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec2 czm_entireFrustum;\n   *\n   * // Example\n   * float frustumLength = czm_entireFrustum.y - czm_entireFrustum.x;\n   *\n   * @see UniformState#entireFrustum\n   * @see czm_currentFrustum\n   */\n  czm_entireFrustum: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC2,\n    getValue: function (uniformState) {\n      return uniformState.entireFrustum;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the near distance (<code>x</code>) and the far distance (<code>y</code>)\n   * of the frustum defined by the camera.  This is the individual\n   * frustum used for multi-frustum rendering.\n   *\n   * @alias czm_currentFrustum\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec2 czm_currentFrustum;\n   *\n   * // Example\n   * float frustumLength = czm_currentFrustum.y - czm_currentFrustum.x;\n   *\n   * @see UniformState#currentFrustum\n   * @see czm_entireFrustum\n   */\n  czm_currentFrustum: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC2,\n    getValue: function (uniformState) {\n      return uniformState.currentFrustum;\n    }\n  }),\n\n  /**\n   * The distances to the frustum planes. The top, bottom, left and right distances are\n   * the x, y, z, and w components, respectively.\n   *\n   * @alias czm_frustumPlanes\n   * @namespace\n   * @glslUniform\n   */\n  czm_frustumPlanes: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC4,\n    getValue: function (uniformState) {\n      return uniformState.frustumPlanes;\n    }\n  }),\n\n  /**\n   * Gets the far plane's distance from the near plane, plus 1.0.\n   *\n   * @alias czm_farDepthFromNearPlusOne\n   * @namespace\n   * @glslUniform\n   */\n  czm_farDepthFromNearPlusOne: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.farDepthFromNearPlusOne;\n    }\n  }),\n\n  /**\n   * Gets the log2 of {@link AutomaticUniforms#czm_farDepthFromNearPlusOne}.\n   *\n   * @alias czm_oneOverLog2FarDepthFromNearPlusOne\n   * @namespace\n   * @glslUniform\n   */\n  czm_log2FarDepthFromNearPlusOne: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.log2FarDepthFromNearPlusOne;\n    }\n  }),\n\n  /**\n   * Gets 1.0 divided by {@link AutomaticUniforms#czm_log2FarDepthFromNearPlusOne}.\n   *\n   * @alias czm_oneOverLog2FarDepthFromNearPlusOne\n   * @namespace\n   * @glslUniform\n   */\n  czm_oneOverLog2FarDepthFromNearPlusOne: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.oneOverLog2FarDepthFromNearPlusOne;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the sun position in world coordinates.\n   *\n   * @alias czm_sunPositionWC\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_sunPositionWC;\n   *\n   * @see UniformState#sunPositionWC\n   * @see czm_sunPositionColumbusView\n   * @see czm_sunDirectionWC\n   */\n  czm_sunPositionWC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.sunPositionWC;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the sun position in Columbus view world coordinates.\n   *\n   * @alias czm_sunPositionColumbusView\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_sunPositionColumbusView;\n   *\n   * @see UniformState#sunPositionColumbusView\n   * @see czm_sunPositionWC\n   */\n  czm_sunPositionColumbusView: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.sunPositionColumbusView;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the normalized direction to the sun in eye coordinates.\n   *\n   * @alias czm_sunDirectionEC\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_sunDirectionEC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_sunDirectionEC, normalEC), 0.0);\n   *\n   * @see UniformState#sunDirectionEC\n   * @see czm_moonDirectionEC\n   * @see czm_sunDirectionWC\n   */\n  czm_sunDirectionEC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.sunDirectionEC;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the normalized direction to the sun in world coordinates.\n   *\n   * @alias czm_sunDirectionWC\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_sunDirectionWC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_sunDirectionWC, normalWC), 0.0);\n   *\n   * @see UniformState#sunDirectionWC\n   * @see czm_sunPositionWC\n   * @see czm_sunDirectionEC\n   */\n  czm_sunDirectionWC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.sunDirectionWC;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the normalized direction to the moon in eye coordinates.\n   *\n   * @alias czm_moonDirectionEC\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_moonDirectionEC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_moonDirectionEC, normalEC), 0.0);\n   *\n   * @see UniformState#moonDirectionEC\n   * @see czm_sunDirectionEC\n   */\n  czm_moonDirectionEC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.moonDirectionEC;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the normalized direction to the scene's light source in eye coordinates.\n   * This is commonly used for directional lighting computations.\n   *\n   * @alias czm_lightDirectionEC\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_lightDirectionEC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_lightDirectionEC, normalEC), 0.0);\n   *\n   * @see UniformState#lightDirectionEC\n   * @see czm_lightDirectionWC\n   */\n  czm_lightDirectionEC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.lightDirectionEC;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the normalized direction to the scene's light source in world coordinates.\n   * This is commonly used for directional lighting computations.\n   *\n   * @alias czm_lightDirectionWC\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_lightDirectionWC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_lightDirectionWC, normalWC), 0.0);\n   *\n   * @see UniformState#lightDirectionWC\n   * @see czm_lightDirectionEC\n   */\n  czm_lightDirectionWC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.lightDirectionWC;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform that represents the color of light emitted by the scene's light source. This\n   * is equivalent to the light color multiplied by the light intensity limited to a maximum luminance of 1.0\n   * suitable for non-HDR lighting.\n   *\n   * @alias czm_lightColor\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_lightColor;\n   *\n   * // Example\n   * vec3 diffuseColor = czm_lightColor * max(dot(czm_lightDirectionWC, normalWC), 0.0);\n   *\n   * @see UniformState#lightColor\n   * @see czm_lightColorHdr\n   */\n  czm_lightColor: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.lightColor;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform that represents the high dynamic range color of light emitted by the scene's light\n   * source. This is equivalent to the light color multiplied by the light intensity suitable for HDR lighting.\n   *\n   * @alias czm_lightColorHdr\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_lightColorHdr;\n   *\n   * // Example\n   * vec3 diffuseColor = czm_lightColorHdr * max(dot(czm_lightDirectionWC, normalWC), 0.0);\n   *\n   * @see UniformState#lightColorHdr\n   * @see czm_lightColor\n   */\n  czm_lightColorHdr: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.lightColorHdr;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the high bits of the camera position in model\n   * coordinates.  This is used for GPU RTE to eliminate jittering artifacts when rendering\n   * as described in {@link http://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.\n   *\n   * @alias czm_encodedCameraPositionMCHigh\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_encodedCameraPositionMCHigh;\n   *\n   * @see czm_encodedCameraPositionMCLow\n   * @see czm_modelViewRelativeToEye\n   * @see czm_modelViewProjectionRelativeToEye\n   */\n  czm_encodedCameraPositionMCHigh: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.encodedCameraPositionMCHigh;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the low bits of the camera position in model\n   * coordinates.  This is used for GPU RTE to eliminate jittering artifacts when rendering\n   * as described in {@linkhttp://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.\n   *\n   * @alias czm_encodedCameraPositionMCLow\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_encodedCameraPositionMCLow;\n   *\n   * @see czm_encodedCameraPositionMCHigh\n   * @see czm_modelViewRelativeToEye\n   * @see czm_modelViewProjectionRelativeToEye\n   */\n  czm_encodedCameraPositionMCLow: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.encodedCameraPositionMCLow;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the position of the viewer (camera) in world coordinates.\n   *\n   * @alias czm_viewerPositionWC\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_viewerPositionWC;\n   */\n  czm_viewerPositionWC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return Matrix4.getTranslation(uniformState.inverseView, viewerPositionWCScratch);\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the frame number. This uniform is automatically incremented\n   * every frame.\n   *\n   * @alias czm_frameNumber\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform float czm_frameNumber;\n   */\n  czm_frameNumber: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.frameState.frameNumber;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the current morph transition time between\n   * 2D/Columbus View and 3D, with 0.0 being 2D or Columbus View and 1.0 being 3D.\n   *\n   * @alias czm_morphTime\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform float czm_morphTime;\n   *\n   * // Example\n   * vec4 p = czm_columbusViewMorph(position2D, position3D, czm_morphTime);\n   */\n  czm_morphTime: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.frameState.morphTime;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the current {@link SceneMode}, expressed\n   * as a float.\n   *\n   * @alias czm_sceneMode\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform float czm_sceneMode;\n   *\n   * // Example\n   * if (czm_sceneMode == czm_sceneMode2D)\n   * {\n   *     eyeHeightSq = czm_eyeHeight2D.y;\n   * }\n   *\n   * @see czm_sceneMode2D\n   * @see czm_sceneModeColumbusView\n   * @see czm_sceneMode3D\n   * @see czm_sceneModeMorphing\n   */\n  czm_sceneMode: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.frameState.mode;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the current rendering pass.\n   *\n   * @alias czm_pass\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform float czm_pass;\n   *\n   * // Example\n   * if ((czm_pass == czm_passTranslucent) && isOpaque())\n   * {\n   *     gl_Position *= 0.0; // Cull opaque geometry in the translucent pass\n   * }\n   */\n  czm_pass: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.pass;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the current scene background color.\n   *\n   * @alias czm_backgroundColor\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec4 czm_backgroundColor;\n   *\n   * // Example: If the given color's RGB matches the background color, invert it.\n   * vec4 adjustColorForContrast(vec4 color)\n   * {\n   *     if (czm_backgroundColor.rgb == color.rgb)\n   *     {\n   *         color.rgb = vec3(1.0) - color.rgb;\n   *     }\n   *\n   *     return color;\n   * }\n   */\n  czm_backgroundColor: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC4,\n    getValue: function (uniformState) {\n      return uniformState.backgroundColor;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the BRDF look up texture used for image-based lighting computations.\n   *\n   * @alias czm_brdfLut\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform sampler2D czm_brdfLut;\n   *\n   * // Example: For a given roughness and NdotV value, find the material's BRDF information in the red and green channels\n   * float roughness = 0.5;\n   * float NdotV = dot(normal, view);\n   * vec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, 1.0 - roughness)).rg;\n   */\n  czm_brdfLut: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.SAMPLER_2D,\n    getValue: function (uniformState) {\n      return uniformState.brdfLut;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the environment map used within the scene.\n   *\n   * @alias czm_environmentMap\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform samplerCube czm_environmentMap;\n   *\n   * // Example: Create a perfect reflection of the environment map on a  model\n   * float reflected = reflect(view, normal);\n   * vec4 reflectedColor = textureCube(czm_environmentMap, reflected);\n   */\n  czm_environmentMap: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.SAMPLER_CUBE,\n    getValue: function (uniformState) {\n      return uniformState.environmentMap;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the specular environment map atlas used within the scene.\n   *\n   * @alias czm_specularEnvironmentMaps\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform sampler2D czm_specularEnvironmentMaps;\n   */\n  czm_specularEnvironmentMaps: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.SAMPLER_2D,\n    getValue: function (uniformState) {\n      return uniformState.specularEnvironmentMaps;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the size of the specular environment map atlas used within the scene.\n   *\n   * @alias czm_specularEnvironmentMapSize\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec2 czm_specularEnvironmentMapSize;\n   */\n  czm_specularEnvironmentMapSize: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC2,\n    getValue: function (uniformState) {\n      return uniformState.specularEnvironmentMapsDimensions;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the maximum level-of-detail of the specular environment map atlas used within the scene.\n   *\n   * @alias czm_specularEnvironmentMapsMaximumLOD\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform float czm_specularEnvironmentMapsMaximumLOD;\n   */\n  czm_specularEnvironmentMapsMaximumLOD: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.specularEnvironmentMapsMaximumLOD;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the spherical harmonic coefficients used within the scene.\n   *\n   * @alias czm_sphericalHarmonicCoefficients\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3[9] czm_sphericalHarmonicCoefficients;\n   */\n  czm_sphericalHarmonicCoefficients: new AutomaticUniform({\n    size: 9,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.sphericalHarmonicCoefficients;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 rotation matrix that transforms\n   * from True Equator Mean Equinox (TEME) axes to the pseudo-fixed axes at the current scene time.\n   *\n   * @alias czm_temeToPseudoFixed\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_temeToPseudoFixed;\n   *\n   * // Example\n   * vec3 pseudoFixed = czm_temeToPseudoFixed * teme;\n   *\n   * @see UniformState#temeToPseudoFixedMatrix\n   * @see Transforms.computeTemeToPseudoFixedMatrix\n   */\n  czm_temeToPseudoFixed: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.temeToPseudoFixedMatrix;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the ratio of canvas coordinate space to canvas pixel space.\n   *\n   * @alias czm_pixelRatio\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * uniform float czm_pixelRatio;\n   */\n  czm_pixelRatio: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.pixelRatio;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform scalar used to mix a color with the fog color based on the distance to the camera.\n   *\n   * @alias czm_fogDensity\n   * @namespace\n   * @glslUniform\n   *\n   * @see czm_fog\n   */\n  czm_fogDensity: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.fogDensity;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the splitter position to use when rendering imagery layers with a splitter.\n   * This will be in pixel coordinates relative to the canvas.\n   *\n   * @alias czm_imagerySplitPosition\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform float czm_imagerySplitPosition;\n   */\n  czm_imagerySplitPosition: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.imagerySplitPosition;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform scalar representing the geometric tolerance per meter\n   *\n   * @alias czm_geometricToleranceOverMeter\n   * @namespace\n   * @glslUniform\n   */\n  czm_geometricToleranceOverMeter: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.geometricToleranceOverMeter;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the distance from the camera at which to disable the depth test of billboards, labels and points\n   * to, for example, prevent clipping against terrain. When set to zero, the depth test should always be applied. When less than zero,\n   * the depth test should never be applied.\n   *\n   * @alias czm_minimumDisableDepthTestDistance\n   * @namespace\n   * @glslUniform\n   */\n  czm_minimumDisableDepthTestDistance: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.minimumDisableDepthTestDistance;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform that will be the highlight color of unclassified 3D Tiles.\n   *\n   * @alias czm_invertClassificationColor\n   * @namespace\n   * @glslUniform\n   */\n  czm_invertClassificationColor: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC4,\n    getValue: function (uniformState) {\n      return uniformState.invertClassificationColor;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform that is used for gamma correction.\n   *\n   * @alias czm_gamma\n   * @glslUniform\n   */\n  czm_gamma: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.gamma;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform that stores the ellipsoid radii.\n   *\n   * @alias czm_ellipsoidRadii\n   * @glslUniform\n   */\n  czm_ellipsoidRadii: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.ellipsoid.radii;\n    }\n  }),\n\n  /**\n   * An automatic GLSL uniform that stores the ellipsoid inverse radii.\n   *\n   * @alias czm_ellipsoidRadii\n   * @glslUniform\n   */\n  czm_ellipsoidInverseRadii: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.ellipsoid.oneOverRadii;\n    }\n  })\n};\nexport default AutomaticUniforms;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Renderer/AutomaticUniforms.js"],"names":["Cartesian3","Matrix4","WebGLConstants","viewerPositionWCScratch","AutomaticUniform","options","_size","size","_datatype","datatype","getValue","datatypeToGlsl","FLOAT","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","INT","INT_VEC2","INT_VEC3","INT_VEC4","BOOL","BOOL_VEC2","BOOL_VEC3","BOOL_VEC4","FLOAT_MAT2","FLOAT_MAT3","FLOAT_MAT4","SAMPLER_2D","SAMPLER_CUBE","prototype","getDeclaration","name","declaration","toString","AutomaticUniforms","czm_viewport","uniformState","viewportCartesian4","czm_viewportOrthographic","viewportOrthographic","czm_viewportTransformation","viewportTransformation","czm_globeDepthTexture","globeDepthTexture","czm_model","model","czm_inverseModel","inverseModel","czm_view","view","czm_view3D","view3D","czm_viewRotation","viewRotation","czm_viewRotation3D","viewRotation3D","czm_inverseView","inverseView","czm_inverseView3D","inverseView3D","czm_inverseViewRotation","inverseViewRotation","czm_inverseViewRotation3D","inverseViewRotation3D","czm_projection","projection","czm_inverseProjection","inverseProjection","czm_infiniteProjection","infiniteProjection","czm_modelView","modelView","czm_modelView3D","modelView3D","czm_modelViewRelativeToEye","modelViewRelativeToEye","czm_inverseModelView","inverseModelView","czm_inverseModelView3D","inverseModelView3D","czm_viewProjection","viewProjection","czm_inverseViewProjection","inverseViewProjection","czm_modelViewProjection","modelViewProjection","czm_inverseModelViewProjection","inverseModelViewProjection","czm_modelViewProjectionRelativeToEye","modelViewProjectionRelativeToEye","czm_modelViewInfiniteProjection","modelViewInfiniteProjection","czm_orthographicIn3D","orthographicIn3D","czm_normal","normal","czm_normal3D","normal3D","czm_inverseNormal","inverseNormal","czm_inverseNormal3D","inverseNormal3D","czm_eyeHeight2D","eyeHeight2D","czm_entireFrustum","entireFrustum","czm_currentFrustum","currentFrustum","czm_frustumPlanes","frustumPlanes","czm_farDepthFromNearPlusOne","farDepthFromNearPlusOne","czm_log2FarDepthFromNearPlusOne","log2FarDepthFromNearPlusOne","czm_oneOverLog2FarDepthFromNearPlusOne","oneOverLog2FarDepthFromNearPlusOne","czm_sunPositionWC","sunPositionWC","czm_sunPositionColumbusView","sunPositionColumbusView","czm_sunDirectionEC","sunDirectionEC","czm_sunDirectionWC","sunDirectionWC","czm_moonDirectionEC","moonDirectionEC","czm_lightDirectionEC","lightDirectionEC","czm_lightDirectionWC","lightDirectionWC","czm_lightColor","lightColor","czm_lightColorHdr","lightColorHdr","czm_encodedCameraPositionMCHigh","encodedCameraPositionMCHigh","czm_encodedCameraPositionMCLow","encodedCameraPositionMCLow","czm_viewerPositionWC","getTranslation","czm_frameNumber","frameState","frameNumber","czm_morphTime","morphTime","czm_sceneMode","mode","czm_pass","pass","czm_backgroundColor","backgroundColor","czm_brdfLut","brdfLut","czm_environmentMap","environmentMap","czm_specularEnvironmentMaps","specularEnvironmentMaps","czm_specularEnvironmentMapSize","specularEnvironmentMapsDimensions","czm_specularEnvironmentMapsMaximumLOD","specularEnvironmentMapsMaximumLOD","czm_sphericalHarmonicCoefficients","sphericalHarmonicCoefficients","czm_temeToPseudoFixed","temeToPseudoFixedMatrix","czm_pixelRatio","pixelRatio","czm_fogDensity","fogDensity","czm_imagerySplitPosition","imagerySplitPosition","czm_geometricToleranceOverMeter","geometricToleranceOverMeter","czm_minimumDisableDepthTestDistance","minimumDisableDepthTestDistance","czm_invertClassificationColor","invertClassificationColor","czm_gamma","gamma","czm_ellipsoidRadii","ellipsoid","radii","czm_ellipsoidInverseRadii","oneOverRadii"],"mappings":"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","sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\n\nvar viewerPositionWCScratch = new Cartesian3();\n\nfunction AutomaticUniform(options) {\n  this._size = options.size;\n  this._datatype = options.datatype;\n  this.getValue = options.getValue;\n}\n\nvar datatypeToGlsl = {};\ndatatypeToGlsl[WebGLConstants.FLOAT] = \"float\";\ndatatypeToGlsl[WebGLConstants.FLOAT_VEC2] = \"vec2\";\ndatatypeToGlsl[WebGLConstants.FLOAT_VEC3] = \"vec3\";\ndatatypeToGlsl[WebGLConstants.FLOAT_VEC4] = \"vec4\";\ndatatypeToGlsl[WebGLConstants.INT] = \"int\";\ndatatypeToGlsl[WebGLConstants.INT_VEC2] = \"ivec2\";\ndatatypeToGlsl[WebGLConstants.INT_VEC3] = \"ivec3\";\ndatatypeToGlsl[WebGLConstants.INT_VEC4] = \"ivec4\";\ndatatypeToGlsl[WebGLConstants.BOOL] = \"bool\";\ndatatypeToGlsl[WebGLConstants.BOOL_VEC2] = \"bvec2\";\ndatatypeToGlsl[WebGLConstants.BOOL_VEC3] = \"bvec3\";\ndatatypeToGlsl[WebGLConstants.BOOL_VEC4] = \"bvec4\";\ndatatypeToGlsl[WebGLConstants.FLOAT_MAT2] = \"mat2\";\ndatatypeToGlsl[WebGLConstants.FLOAT_MAT3] = \"mat3\";\ndatatypeToGlsl[WebGLConstants.FLOAT_MAT4] = \"mat4\";\ndatatypeToGlsl[WebGLConstants.SAMPLER_2D] = \"sampler2D\";\ndatatypeToGlsl[WebGLConstants.SAMPLER_CUBE] = \"samplerCube\";\n\nAutomaticUniform.prototype.getDeclaration = function (name) {\n  var declaration = \"uniform \" + datatypeToGlsl[this._datatype] + \" \" + name;\n\n  var size = this._size;\n  if (size === 1) {\n    declaration += \";\";\n  } else {\n    declaration += \"[\" + size.toString() + \"];\";\n  }\n\n  return declaration;\n};\n\n/**\n * @private\n */\nvar AutomaticUniforms = {\n  /**\n   * An automatic GLSL uniform containing the viewport's <code>x</code>, <code>y</code>, <code>width</code>,\n   * and <code>height</code> properties in an <code>vec4</code>'s <code>x</code>, <code>y</code>, <code>z</code>,\n   * and <code>w</code> components, respectively.\n   *\n   * @alias czm_viewport\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec4 czm_viewport;\n   *\n   * // Scale the window coordinate components to [0, 1] by dividing\n   * // by the viewport's width and height.\n   * vec2 v = gl_FragCoord.xy / czm_viewport.zw;\n   *\n   * @see Context#getViewport\n   */\n  czm_viewport: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC4,\n    getValue: function (uniformState) {\n      return uniformState.viewportCartesian4;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 orthographic projection matrix that\n   * transforms window coordinates to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   * <br /><br />\n   * This transform is useful when a vertex shader inputs or manipulates window coordinates\n   * as done by {@link BillboardCollection}.\n   * <br /><br />\n   * Do not confuse {@link czm_viewportTransformation} with <code>czm_viewportOrthographic</code>.\n   * The former transforms from normalized device coordinates to window coordinates; the later transforms\n   * from window coordinates to clip coordinates, and is often used to assign to <code>gl_Position</code>.\n   *\n   * @alias czm_viewportOrthographic\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_viewportOrthographic;\n   *\n   * // Example\n   * gl_Position = czm_viewportOrthographic * vec4(windowPosition, 0.0, 1.0);\n   *\n   * @see UniformState#viewportOrthographic\n   * @see czm_viewport\n   * @see czm_viewportTransformation\n   * @see BillboardCollection\n   */\n  czm_viewportOrthographic: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.viewportOrthographic;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 transformation matrix that\n   * transforms normalized device coordinates to window coordinates.  The context's\n   * full viewport is used, and the depth range is assumed to be <code>near = 0</code>\n   * and <code>far = 1</code>.\n   * <br /><br />\n   * This transform is useful when there is a need to manipulate window coordinates\n   * in a vertex shader as done by {@link BillboardCollection}.  In many cases,\n   * this matrix will not be used directly; instead, {@link czm_modelToWindowCoordinates}\n   * will be used to transform directly from model to window coordinates.\n   * <br /><br />\n   * Do not confuse <code>czm_viewportTransformation</code> with {@link czm_viewportOrthographic}.\n   * The former transforms from normalized device coordinates to window coordinates; the later transforms\n   * from window coordinates to clip coordinates, and is often used to assign to <code>gl_Position</code>.\n   *\n   * @alias czm_viewportTransformation\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_viewportTransformation;\n   *\n   * // Use czm_viewportTransformation as part of the\n   * // transform from model to window coordinates.\n   * vec4 q = czm_modelViewProjection * positionMC;               // model to clip coordinates\n   * q.xyz /= q.w;                                                // clip to normalized device coordinates (ndc)\n   * q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // ndc to window coordinates\n   *\n   * @see UniformState#viewportTransformation\n   * @see czm_viewport\n   * @see czm_viewportOrthographic\n   * @see czm_modelToWindowCoordinates\n   * @see BillboardCollection\n   */\n  czm_viewportTransformation: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.viewportTransformation;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the depth of the scene\n   * after the globe pass and then updated after the 3D Tiles pass.\n   * The depth is packed into an RGBA texture.\n   *\n   * @private\n   *\n   * @alias czm_globeDepthTexture\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform sampler2D czm_globeDepthTexture;\n   *\n   * // Get the depth at the current fragment\n   * vec2 coords = gl_FragCoord.xy / czm_viewport.zw;\n   * float depth = czm_unpackDepth(texture2D(czm_globeDepthTexture, coords));\n   */\n  czm_globeDepthTexture: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.SAMPLER_2D,\n    getValue: function (uniformState) {\n      return uniformState.globeDepthTexture;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 model transformation matrix that\n   * transforms model coordinates to world coordinates.\n   *\n   * @alias czm_model\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_model;\n   *\n   * // Example\n   * vec4 worldPosition = czm_model * modelPosition;\n   *\n   * @see UniformState#model\n   * @see czm_inverseModel\n   * @see czm_modelView\n   * @see czm_modelViewProjection\n   */\n  czm_model: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.model;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 model transformation matrix that\n   * transforms world coordinates to model coordinates.\n   *\n   * @alias czm_inverseModel\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseModel;\n   *\n   * // Example\n   * vec4 modelPosition = czm_inverseModel * worldPosition;\n   *\n   * @see UniformState#inverseModel\n   * @see czm_model\n   * @see czm_inverseModelView\n   */\n  czm_inverseModel: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseModel;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 view transformation matrix that\n   * transforms world coordinates to eye coordinates.\n   *\n   * @alias czm_view\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_view;\n   *\n   * // Example\n   * vec4 eyePosition = czm_view * worldPosition;\n   *\n   * @see UniformState#view\n   * @see czm_viewRotation\n   * @see czm_modelView\n   * @see czm_viewProjection\n   * @see czm_modelViewProjection\n   * @see czm_inverseView\n   */\n  czm_view: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.view;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 view transformation matrix that\n   * transforms 3D world coordinates to eye coordinates.  In 3D mode, this is identical to\n   * {@link czm_view}, but in 2D and Columbus View it represents the view matrix\n   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   *\n   * @alias czm_view3D\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_view3D;\n   *\n   * // Example\n   * vec4 eyePosition3D = czm_view3D * worldPosition3D;\n   *\n   * @see UniformState#view3D\n   * @see czm_view\n   */\n  czm_view3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.view3D;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 view rotation matrix that\n   * transforms vectors in world coordinates to eye coordinates.\n   *\n   * @alias czm_viewRotation\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_viewRotation;\n   *\n   * // Example\n   * vec3 eyeVector = czm_viewRotation * worldVector;\n   *\n   * @see UniformState#viewRotation\n   * @see czm_view\n   * @see czm_inverseView\n   * @see czm_inverseViewRotation\n   */\n  czm_viewRotation: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.viewRotation;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 view rotation matrix that\n   * transforms vectors in 3D world coordinates to eye coordinates.  In 3D mode, this is identical to\n   * {@link czm_viewRotation}, but in 2D and Columbus View it represents the view matrix\n   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   *\n   * @alias czm_viewRotation3D\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_viewRotation3D;\n   *\n   * // Example\n   * vec3 eyeVector = czm_viewRotation3D * worldVector;\n   *\n   * @see UniformState#viewRotation3D\n   * @see czm_viewRotation\n   */\n  czm_viewRotation3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.viewRotation3D;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 transformation matrix that\n   * transforms from eye coordinates to world coordinates.\n   *\n   * @alias czm_inverseView\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseView;\n   *\n   * // Example\n   * vec4 worldPosition = czm_inverseView * eyePosition;\n   *\n   * @see UniformState#inverseView\n   * @see czm_view\n   * @see czm_inverseNormal\n   */\n  czm_inverseView: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseView;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 transformation matrix that\n   * transforms from 3D eye coordinates to world coordinates.  In 3D mode, this is identical to\n   * {@link czm_inverseView}, but in 2D and Columbus View it represents the inverse view matrix\n   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   *\n   * @alias czm_inverseView3D\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseView3D;\n   *\n   * // Example\n   * vec4 worldPosition = czm_inverseView3D * eyePosition;\n   *\n   * @see UniformState#inverseView3D\n   * @see czm_inverseView\n   */\n  czm_inverseView3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseView3D;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 rotation matrix that\n   * transforms vectors from eye coordinates to world coordinates.\n   *\n   * @alias czm_inverseViewRotation\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_inverseViewRotation;\n   *\n   * // Example\n   * vec4 worldVector = czm_inverseViewRotation * eyeVector;\n   *\n   * @see UniformState#inverseView\n   * @see czm_view\n   * @see czm_viewRotation\n   * @see czm_inverseViewRotation\n   */\n  czm_inverseViewRotation: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.inverseViewRotation;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 rotation matrix that\n   * transforms vectors from 3D eye coordinates to world coordinates.  In 3D mode, this is identical to\n   * {@link czm_inverseViewRotation}, but in 2D and Columbus View it represents the inverse view matrix\n   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   *\n   * @alias czm_inverseViewRotation3D\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_inverseViewRotation3D;\n   *\n   * // Example\n   * vec4 worldVector = czm_inverseViewRotation3D * eyeVector;\n   *\n   * @see UniformState#inverseView3D\n   * @see czm_inverseViewRotation\n   */\n  czm_inverseViewRotation3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.inverseViewRotation3D;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 projection transformation matrix that\n   * transforms eye coordinates to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   *\n   * @alias czm_projection\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_projection;\n   *\n   * // Example\n   * gl_Position = czm_projection * eyePosition;\n   *\n   * @see UniformState#projection\n   * @see czm_viewProjection\n   * @see czm_modelViewProjection\n   * @see czm_infiniteProjection\n   */\n  czm_projection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.projection;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 inverse projection transformation matrix that\n   * transforms from clip coordinates to eye coordinates. Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   *\n   * @alias czm_inverseProjection\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseProjection;\n   *\n   * // Example\n   * vec4 eyePosition = czm_inverseProjection * clipPosition;\n   *\n   * @see UniformState#inverseProjection\n   * @see czm_projection\n   */\n  czm_inverseProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseProjection;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 projection transformation matrix with the far plane at infinity,\n   * that transforms eye coordinates to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.  An infinite far plane is used\n   * in algorithms like shadow volumes and GPU ray casting with proxy geometry to ensure that triangles\n   * are not clipped by the far plane.\n   *\n   * @alias czm_infiniteProjection\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_infiniteProjection;\n   *\n   * // Example\n   * gl_Position = czm_infiniteProjection * eyePosition;\n   *\n   * @see UniformState#infiniteProjection\n   * @see czm_projection\n   * @see czm_modelViewInfiniteProjection\n   */\n  czm_infiniteProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.infiniteProjection;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that\n   * transforms model coordinates to eye coordinates.\n   * <br /><br />\n   * Positions should be transformed to eye coordinates using <code>czm_modelView</code> and\n   * normals should be transformed using {@link czm_normal}.\n   *\n   * @alias czm_modelView\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_modelView;\n   *\n   * // Example\n   * vec4 eyePosition = czm_modelView * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * vec4 eyePosition = czm_view * czm_model * modelPosition;\n   *\n   * @see UniformState#modelView\n   * @see czm_model\n   * @see czm_view\n   * @see czm_modelViewProjection\n   * @see czm_normal\n   */\n  czm_modelView: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.modelView;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that\n   * transforms 3D model coordinates to eye coordinates.  In 3D mode, this is identical to\n   * {@link czm_modelView}, but in 2D and Columbus View it represents the model-view matrix\n   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   * <br /><br />\n   * Positions should be transformed to eye coordinates using <code>czm_modelView3D</code> and\n   * normals should be transformed using {@link czm_normal3D}.\n   *\n   * @alias czm_modelView3D\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_modelView3D;\n   *\n   * // Example\n   * vec4 eyePosition = czm_modelView3D * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * vec4 eyePosition = czm_view3D * czm_model * modelPosition;\n   *\n   * @see UniformState#modelView3D\n   * @see czm_modelView\n   */\n  czm_modelView3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.modelView3D;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that\n   * transforms model coordinates, relative to the eye, to eye coordinates.  This is used\n   * in conjunction with {@link czm_translateRelativeToEye}.\n   *\n   * @alias czm_modelViewRelativeToEye\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_modelViewRelativeToEye;\n   *\n   * // Example\n   * attribute vec3 positionHigh;\n   * attribute vec3 positionLow;\n   *\n   * void main()\n   * {\n   *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n   *   gl_Position = czm_projection * (czm_modelViewRelativeToEye * p);\n   * }\n   *\n   * @see czm_modelViewProjectionRelativeToEye\n   * @see czm_translateRelativeToEye\n   * @see EncodedCartesian3\n   */\n  czm_modelViewRelativeToEye: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.modelViewRelativeToEye;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 transformation matrix that\n   * transforms from eye coordinates to model coordinates.\n   *\n   * @alias czm_inverseModelView\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseModelView;\n   *\n   * // Example\n   * vec4 modelPosition = czm_inverseModelView * eyePosition;\n   *\n   * @see UniformState#inverseModelView\n   * @see czm_modelView\n   */\n  czm_inverseModelView: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseModelView;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 transformation matrix that\n   * transforms from eye coordinates to 3D model coordinates.  In 3D mode, this is identical to\n   * {@link czm_inverseModelView}, but in 2D and Columbus View it represents the inverse model-view matrix\n   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   *\n   * @alias czm_inverseModelView3D\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseModelView3D;\n   *\n   * // Example\n   * vec4 modelPosition = czm_inverseModelView3D * eyePosition;\n   *\n   * @see UniformState#inverseModelView\n   * @see czm_inverseModelView\n   * @see czm_modelView3D\n   */\n  czm_inverseModelView3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseModelView3D;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 view-projection transformation matrix that\n   * transforms world coordinates to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   *\n   * @alias czm_viewProjection\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_viewProjection;\n   *\n   * // Example\n   * vec4 gl_Position = czm_viewProjection * czm_model * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * gl_Position = czm_projection * czm_view * czm_model * modelPosition;\n   *\n   * @see UniformState#viewProjection\n   * @see czm_view\n   * @see czm_projection\n   * @see czm_modelViewProjection\n   * @see czm_inverseViewProjection\n   */\n  czm_viewProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.viewProjection;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 view-projection transformation matrix that\n   * transforms clip coordinates to world coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   *\n   * @alias czm_inverseViewProjection\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseViewProjection;\n   *\n   * // Example\n   * vec4 worldPosition = czm_inverseViewProjection * clipPosition;\n   *\n   * @see UniformState#inverseViewProjection\n   * @see czm_viewProjection\n   */\n  czm_inverseViewProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseViewProjection;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that\n   * transforms model coordinates to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   *\n   * @alias czm_modelViewProjection\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_modelViewProjection;\n   *\n   * // Example\n   * vec4 gl_Position = czm_modelViewProjection * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * gl_Position = czm_projection * czm_view * czm_model * modelPosition;\n   *\n   * @see UniformState#modelViewProjection\n   * @see czm_model\n   * @see czm_view\n   * @see czm_projection\n   * @see czm_modelView\n   * @see czm_viewProjection\n   * @see czm_modelViewInfiniteProjection\n   * @see czm_inverseModelViewProjection\n   */\n  czm_modelViewProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.modelViewProjection;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 inverse model-view-projection transformation matrix that\n   * transforms clip coordinates to model coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   *\n   * @alias czm_inverseModelViewProjection\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseModelViewProjection;\n   *\n   * // Example\n   * vec4 modelPosition = czm_inverseModelViewProjection * clipPosition;\n   *\n   * @see UniformState#modelViewProjection\n   * @see czm_modelViewProjection\n   */\n  czm_inverseModelViewProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseModelViewProjection;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that\n   * transforms model coordinates, relative to the eye, to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.  This is used in\n   * conjunction with {@link czm_translateRelativeToEye}.\n   *\n   * @alias czm_modelViewProjectionRelativeToEye\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_modelViewProjectionRelativeToEye;\n   *\n   * // Example\n   * attribute vec3 positionHigh;\n   * attribute vec3 positionLow;\n   *\n   * void main()\n   * {\n   *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n   *   gl_Position = czm_modelViewProjectionRelativeToEye * p;\n   * }\n   *\n   * @see czm_modelViewRelativeToEye\n   * @see czm_translateRelativeToEye\n   * @see EncodedCartesian3\n   */\n  czm_modelViewProjectionRelativeToEye: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.modelViewProjectionRelativeToEye;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that\n   * transforms model coordinates to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.  The projection matrix places\n   * the far plane at infinity.  This is useful in algorithms like shadow volumes and GPU ray casting with\n   * proxy geometry to ensure that triangles are not clipped by the far plane.\n   *\n   * @alias czm_modelViewInfiniteProjection\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_modelViewInfiniteProjection;\n   *\n   * // Example\n   * vec4 gl_Position = czm_modelViewInfiniteProjection * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * gl_Position = czm_infiniteProjection * czm_view * czm_model * modelPosition;\n   *\n   * @see UniformState#modelViewInfiniteProjection\n   * @see czm_model\n   * @see czm_view\n   * @see czm_infiniteProjection\n   * @see czm_modelViewProjection\n   */\n  czm_modelViewInfiniteProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.modelViewInfiniteProjection;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform that indicates if the current camera is orthographic in 3D.\n   *\n   * @alias czm_orthographicIn3D\n   * @namespace\n   * @glslUniform\n   * @see UniformState#orthographicIn3D\n   */\n  czm_orthographicIn3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.orthographicIn3D ? 1 : 0;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that\n   * transforms normal vectors in model coordinates to eye coordinates.\n   * <br /><br />\n   * Positions should be transformed to eye coordinates using {@link czm_modelView} and\n   * normals should be transformed using <code>czm_normal</code>.\n   *\n   * @alias czm_normal\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_normal;\n   *\n   * // Example\n   * vec3 eyeNormal = czm_normal * normal;\n   *\n   * @see UniformState#normal\n   * @see czm_inverseNormal\n   * @see czm_modelView\n   */\n  czm_normal: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.normal;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that\n   * transforms normal vectors in 3D model coordinates to eye coordinates.\n   * In 3D mode, this is identical to\n   * {@link czm_normal}, but in 2D and Columbus View it represents the normal transformation\n   * matrix as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   * <br /><br />\n   * Positions should be transformed to eye coordinates using {@link czm_modelView3D} and\n   * normals should be transformed using <code>czm_normal3D</code>.\n   *\n   * @alias czm_normal3D\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_normal3D;\n   *\n   * // Example\n   * vec3 eyeNormal = czm_normal3D * normal;\n   *\n   * @see UniformState#normal3D\n   * @see czm_normal\n   */\n  czm_normal3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.normal3D;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that\n   * transforms normal vectors in eye coordinates to model coordinates.  This is\n   * the opposite of the transform provided by {@link czm_normal}.\n   *\n   * @alias czm_inverseNormal\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_inverseNormal;\n   *\n   * // Example\n   * vec3 normalMC = czm_inverseNormal * normalEC;\n   *\n   * @see UniformState#inverseNormal\n   * @see czm_normal\n   * @see czm_modelView\n   * @see czm_inverseView\n   */\n  czm_inverseNormal: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.inverseNormal;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that\n   * transforms normal vectors in eye coordinates to 3D model coordinates.  This is\n   * the opposite of the transform provided by {@link czm_normal}.\n   * In 3D mode, this is identical to\n   * {@link czm_inverseNormal}, but in 2D and Columbus View it represents the inverse normal transformation\n   * matrix as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   *\n   * @alias czm_inverseNormal3D\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_inverseNormal3D;\n   *\n   * // Example\n   * vec3 normalMC = czm_inverseNormal3D * normalEC;\n   *\n   * @see UniformState#inverseNormal3D\n   * @see czm_inverseNormal\n   */\n  czm_inverseNormal3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.inverseNormal3D;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform containing height (<code>x</code>) and height squared (<code>y</code>)\n   *  of the eye (camera) in the 2D scene in meters.\n   *\n   * @alias czm_eyeHeight2D\n   * @namespace\n   * @glslUniform\n   *\n   * @see UniformState#eyeHeight2D\n   */\n  czm_eyeHeight2D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC2,\n    getValue: function (uniformState) {\n      return uniformState.eyeHeight2D;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the near distance (<code>x</code>) and the far distance (<code>y</code>)\n   * of the frustum defined by the camera.  This is the largest possible frustum, not an individual\n   * frustum used for multi-frustum rendering.\n   *\n   * @alias czm_entireFrustum\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec2 czm_entireFrustum;\n   *\n   * // Example\n   * float frustumLength = czm_entireFrustum.y - czm_entireFrustum.x;\n   *\n   * @see UniformState#entireFrustum\n   * @see czm_currentFrustum\n   */\n  czm_entireFrustum: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC2,\n    getValue: function (uniformState) {\n      return uniformState.entireFrustum;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the near distance (<code>x</code>) and the far distance (<code>y</code>)\n   * of the frustum defined by the camera.  This is the individual\n   * frustum used for multi-frustum rendering.\n   *\n   * @alias czm_currentFrustum\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec2 czm_currentFrustum;\n   *\n   * // Example\n   * float frustumLength = czm_currentFrustum.y - czm_currentFrustum.x;\n   *\n   * @see UniformState#currentFrustum\n   * @see czm_entireFrustum\n   */\n  czm_currentFrustum: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC2,\n    getValue: function (uniformState) {\n      return uniformState.currentFrustum;\n    },\n  }),\n\n  /**\n   * The distances to the frustum planes. The top, bottom, left and right distances are\n   * the x, y, z, and w components, respectively.\n   *\n   * @alias czm_frustumPlanes\n   * @namespace\n   * @glslUniform\n   */\n  czm_frustumPlanes: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC4,\n    getValue: function (uniformState) {\n      return uniformState.frustumPlanes;\n    },\n  }),\n\n  /**\n   * Gets the far plane's distance from the near plane, plus 1.0.\n   *\n   * @alias czm_farDepthFromNearPlusOne\n   * @namespace\n   * @glslUniform\n   */\n  czm_farDepthFromNearPlusOne: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.farDepthFromNearPlusOne;\n    },\n  }),\n\n  /**\n   * Gets the log2 of {@link AutomaticUniforms#czm_farDepthFromNearPlusOne}.\n   *\n   * @alias czm_oneOverLog2FarDepthFromNearPlusOne\n   * @namespace\n   * @glslUniform\n   */\n  czm_log2FarDepthFromNearPlusOne: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.log2FarDepthFromNearPlusOne;\n    },\n  }),\n\n  /**\n   * Gets 1.0 divided by {@link AutomaticUniforms#czm_log2FarDepthFromNearPlusOne}.\n   *\n   * @alias czm_oneOverLog2FarDepthFromNearPlusOne\n   * @namespace\n   * @glslUniform\n   */\n  czm_oneOverLog2FarDepthFromNearPlusOne: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.oneOverLog2FarDepthFromNearPlusOne;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the sun position in world coordinates.\n   *\n   * @alias czm_sunPositionWC\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_sunPositionWC;\n   *\n   * @see UniformState#sunPositionWC\n   * @see czm_sunPositionColumbusView\n   * @see czm_sunDirectionWC\n   */\n  czm_sunPositionWC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.sunPositionWC;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the sun position in Columbus view world coordinates.\n   *\n   * @alias czm_sunPositionColumbusView\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_sunPositionColumbusView;\n   *\n   * @see UniformState#sunPositionColumbusView\n   * @see czm_sunPositionWC\n   */\n  czm_sunPositionColumbusView: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.sunPositionColumbusView;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the normalized direction to the sun in eye coordinates.\n   *\n   * @alias czm_sunDirectionEC\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_sunDirectionEC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_sunDirectionEC, normalEC), 0.0);\n   *\n   * @see UniformState#sunDirectionEC\n   * @see czm_moonDirectionEC\n   * @see czm_sunDirectionWC\n   */\n  czm_sunDirectionEC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.sunDirectionEC;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the normalized direction to the sun in world coordinates.\n   *\n   * @alias czm_sunDirectionWC\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_sunDirectionWC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_sunDirectionWC, normalWC), 0.0);\n   *\n   * @see UniformState#sunDirectionWC\n   * @see czm_sunPositionWC\n   * @see czm_sunDirectionEC\n   */\n  czm_sunDirectionWC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.sunDirectionWC;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the normalized direction to the moon in eye coordinates.\n   *\n   * @alias czm_moonDirectionEC\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_moonDirectionEC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_moonDirectionEC, normalEC), 0.0);\n   *\n   * @see UniformState#moonDirectionEC\n   * @see czm_sunDirectionEC\n   */\n  czm_moonDirectionEC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.moonDirectionEC;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the normalized direction to the scene's light source in eye coordinates.\n   * This is commonly used for directional lighting computations.\n   *\n   * @alias czm_lightDirectionEC\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_lightDirectionEC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_lightDirectionEC, normalEC), 0.0);\n   *\n   * @see UniformState#lightDirectionEC\n   * @see czm_lightDirectionWC\n   */\n  czm_lightDirectionEC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.lightDirectionEC;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the normalized direction to the scene's light source in world coordinates.\n   * This is commonly used for directional lighting computations.\n   *\n   * @alias czm_lightDirectionWC\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_lightDirectionWC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_lightDirectionWC, normalWC), 0.0);\n   *\n   * @see UniformState#lightDirectionWC\n   * @see czm_lightDirectionEC\n   */\n  czm_lightDirectionWC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.lightDirectionWC;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform that represents the color of light emitted by the scene's light source. This\n   * is equivalent to the light color multiplied by the light intensity limited to a maximum luminance of 1.0\n   * suitable for non-HDR lighting.\n   *\n   * @alias czm_lightColor\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_lightColor;\n   *\n   * // Example\n   * vec3 diffuseColor = czm_lightColor * max(dot(czm_lightDirectionWC, normalWC), 0.0);\n   *\n   * @see UniformState#lightColor\n   * @see czm_lightColorHdr\n   */\n  czm_lightColor: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.lightColor;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform that represents the high dynamic range color of light emitted by the scene's light\n   * source. This is equivalent to the light color multiplied by the light intensity suitable for HDR lighting.\n   *\n   * @alias czm_lightColorHdr\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_lightColorHdr;\n   *\n   * // Example\n   * vec3 diffuseColor = czm_lightColorHdr * max(dot(czm_lightDirectionWC, normalWC), 0.0);\n   *\n   * @see UniformState#lightColorHdr\n   * @see czm_lightColor\n   */\n  czm_lightColorHdr: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.lightColorHdr;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the high bits of the camera position in model\n   * coordinates.  This is used for GPU RTE to eliminate jittering artifacts when rendering\n   * as described in {@link http://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.\n   *\n   * @alias czm_encodedCameraPositionMCHigh\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_encodedCameraPositionMCHigh;\n   *\n   * @see czm_encodedCameraPositionMCLow\n   * @see czm_modelViewRelativeToEye\n   * @see czm_modelViewProjectionRelativeToEye\n   */\n  czm_encodedCameraPositionMCHigh: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.encodedCameraPositionMCHigh;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the low bits of the camera position in model\n   * coordinates.  This is used for GPU RTE to eliminate jittering artifacts when rendering\n   * as described in {@linkhttp://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.\n   *\n   * @alias czm_encodedCameraPositionMCLow\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_encodedCameraPositionMCLow;\n   *\n   * @see czm_encodedCameraPositionMCHigh\n   * @see czm_modelViewRelativeToEye\n   * @see czm_modelViewProjectionRelativeToEye\n   */\n  czm_encodedCameraPositionMCLow: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.encodedCameraPositionMCLow;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the position of the viewer (camera) in world coordinates.\n   *\n   * @alias czm_viewerPositionWC\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_viewerPositionWC;\n   */\n  czm_viewerPositionWC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return Matrix4.getTranslation(\n        uniformState.inverseView,\n        viewerPositionWCScratch\n      );\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the frame number. This uniform is automatically incremented\n   * every frame.\n   *\n   * @alias czm_frameNumber\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform float czm_frameNumber;\n   */\n  czm_frameNumber: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.frameState.frameNumber;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the current morph transition time between\n   * 2D/Columbus View and 3D, with 0.0 being 2D or Columbus View and 1.0 being 3D.\n   *\n   * @alias czm_morphTime\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform float czm_morphTime;\n   *\n   * // Example\n   * vec4 p = czm_columbusViewMorph(position2D, position3D, czm_morphTime);\n   */\n  czm_morphTime: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.frameState.morphTime;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the current {@link SceneMode}, expressed\n   * as a float.\n   *\n   * @alias czm_sceneMode\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform float czm_sceneMode;\n   *\n   * // Example\n   * if (czm_sceneMode == czm_sceneMode2D)\n   * {\n   *     eyeHeightSq = czm_eyeHeight2D.y;\n   * }\n   *\n   * @see czm_sceneMode2D\n   * @see czm_sceneModeColumbusView\n   * @see czm_sceneMode3D\n   * @see czm_sceneModeMorphing\n   */\n  czm_sceneMode: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.frameState.mode;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the current rendering pass.\n   *\n   * @alias czm_pass\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform float czm_pass;\n   *\n   * // Example\n   * if ((czm_pass == czm_passTranslucent) && isOpaque())\n   * {\n   *     gl_Position *= 0.0; // Cull opaque geometry in the translucent pass\n   * }\n   */\n  czm_pass: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.pass;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the current scene background color.\n   *\n   * @alias czm_backgroundColor\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec4 czm_backgroundColor;\n   *\n   * // Example: If the given color's RGB matches the background color, invert it.\n   * vec4 adjustColorForContrast(vec4 color)\n   * {\n   *     if (czm_backgroundColor.rgb == color.rgb)\n   *     {\n   *         color.rgb = vec3(1.0) - color.rgb;\n   *     }\n   *\n   *     return color;\n   * }\n   */\n  czm_backgroundColor: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC4,\n    getValue: function (uniformState) {\n      return uniformState.backgroundColor;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the BRDF look up texture used for image-based lighting computations.\n   *\n   * @alias czm_brdfLut\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform sampler2D czm_brdfLut;\n   *\n   * // Example: For a given roughness and NdotV value, find the material's BRDF information in the red and green channels\n   * float roughness = 0.5;\n   * float NdotV = dot(normal, view);\n   * vec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, 1.0 - roughness)).rg;\n   */\n  czm_brdfLut: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.SAMPLER_2D,\n    getValue: function (uniformState) {\n      return uniformState.brdfLut;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the environment map used within the scene.\n   *\n   * @alias czm_environmentMap\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform samplerCube czm_environmentMap;\n   *\n   * // Example: Create a perfect reflection of the environment map on a  model\n   * float reflected = reflect(view, normal);\n   * vec4 reflectedColor = textureCube(czm_environmentMap, reflected);\n   */\n  czm_environmentMap: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.SAMPLER_CUBE,\n    getValue: function (uniformState) {\n      return uniformState.environmentMap;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the specular environment map atlas used within the scene.\n   *\n   * @alias czm_specularEnvironmentMaps\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform sampler2D czm_specularEnvironmentMaps;\n   */\n  czm_specularEnvironmentMaps: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.SAMPLER_2D,\n    getValue: function (uniformState) {\n      return uniformState.specularEnvironmentMaps;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the size of the specular environment map atlas used within the scene.\n   *\n   * @alias czm_specularEnvironmentMapSize\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec2 czm_specularEnvironmentMapSize;\n   */\n  czm_specularEnvironmentMapSize: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC2,\n    getValue: function (uniformState) {\n      return uniformState.specularEnvironmentMapsDimensions;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the maximum level-of-detail of the specular environment map atlas used within the scene.\n   *\n   * @alias czm_specularEnvironmentMapsMaximumLOD\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform float czm_specularEnvironmentMapsMaximumLOD;\n   */\n  czm_specularEnvironmentMapsMaximumLOD: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.specularEnvironmentMapsMaximumLOD;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the spherical harmonic coefficients used within the scene.\n   *\n   * @alias czm_sphericalHarmonicCoefficients\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3[9] czm_sphericalHarmonicCoefficients;\n   */\n  czm_sphericalHarmonicCoefficients: new AutomaticUniform({\n    size: 9,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.sphericalHarmonicCoefficients;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 rotation matrix that transforms\n   * from True Equator Mean Equinox (TEME) axes to the pseudo-fixed axes at the current scene time.\n   *\n   * @alias czm_temeToPseudoFixed\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_temeToPseudoFixed;\n   *\n   * // Example\n   * vec3 pseudoFixed = czm_temeToPseudoFixed * teme;\n   *\n   * @see UniformState#temeToPseudoFixedMatrix\n   * @see Transforms.computeTemeToPseudoFixedMatrix\n   */\n  czm_temeToPseudoFixed: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.temeToPseudoFixedMatrix;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the ratio of canvas coordinate space to canvas pixel space.\n   *\n   * @alias czm_pixelRatio\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * uniform float czm_pixelRatio;\n   */\n  czm_pixelRatio: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.pixelRatio;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform scalar used to mix a color with the fog color based on the distance to the camera.\n   *\n   * @alias czm_fogDensity\n   * @namespace\n   * @glslUniform\n   *\n   * @see czm_fog\n   */\n  czm_fogDensity: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.fogDensity;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the splitter position to use when rendering imagery layers with a splitter.\n   * This will be in pixel coordinates relative to the canvas.\n   *\n   * @alias czm_imagerySplitPosition\n   * @namespace\n   * @glslUniform\n   *\n   * @example\n   * // GLSL declaration\n   * uniform float czm_imagerySplitPosition;\n   */\n  czm_imagerySplitPosition: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.imagerySplitPosition;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform scalar representing the geometric tolerance per meter\n   *\n   * @alias czm_geometricToleranceOverMeter\n   * @namespace\n   * @glslUniform\n   */\n  czm_geometricToleranceOverMeter: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.geometricToleranceOverMeter;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the distance from the camera at which to disable the depth test of billboards, labels and points\n   * to, for example, prevent clipping against terrain. When set to zero, the depth test should always be applied. When less than zero,\n   * the depth test should never be applied.\n   *\n   * @alias czm_minimumDisableDepthTestDistance\n   * @namespace\n   * @glslUniform\n   */\n  czm_minimumDisableDepthTestDistance: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.minimumDisableDepthTestDistance;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform that will be the highlight color of unclassified 3D Tiles.\n   *\n   * @alias czm_invertClassificationColor\n   * @namespace\n   * @glslUniform\n   */\n  czm_invertClassificationColor: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC4,\n    getValue: function (uniformState) {\n      return uniformState.invertClassificationColor;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform that is used for gamma correction.\n   *\n   * @alias czm_gamma\n   * @glslUniform\n   */\n  czm_gamma: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.gamma;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform that stores the ellipsoid radii.\n   *\n   * @alias czm_ellipsoidRadii\n   * @glslUniform\n   */\n  czm_ellipsoidRadii: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.ellipsoid.radii;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform that stores the ellipsoid inverse radii.\n   *\n   * @alias czm_ellipsoidRadii\n   * @glslUniform\n   */\n  czm_ellipsoidInverseRadii: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.ellipsoid.oneOverRadii;\n    },\n  }),\n};\nexport default AutomaticUniforms;\n"]},"metadata":{},"sourceType":"module"}