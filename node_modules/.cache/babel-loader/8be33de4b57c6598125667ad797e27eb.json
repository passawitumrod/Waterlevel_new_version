{"ast":null,"code":"import arrayFill from \"./arrayFill.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CornerType from \"./CornerType.js\";\nimport CorridorGeometryLibrary from \"./CorridorGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nvar cartesian1 = new Cartesian3();\nvar cartesian2 = new Cartesian3();\nvar cartesian3 = new Cartesian3();\nvar cartesian4 = new Cartesian3();\nvar cartesian5 = new Cartesian3();\nvar cartesian6 = new Cartesian3();\nvar scratch1 = new Cartesian3();\nvar scratch2 = new Cartesian3();\n\nfunction scaleToSurface(positions, ellipsoid) {\n  for (var i = 0; i < positions.length; i++) {\n    positions[i] = ellipsoid.scaleToGeodeticSurface(positions[i], positions[i]);\n  }\n\n  return positions;\n}\n\nfunction addNormals(attr, normal, left, front, back, vertexFormat) {\n  var normals = attr.normals;\n  var tangents = attr.tangents;\n  var bitangents = attr.bitangents;\n  var forward = Cartesian3.normalize(Cartesian3.cross(left, normal, scratch1), scratch1);\n\n  if (vertexFormat.normal) {\n    CorridorGeometryLibrary.addAttribute(normals, normal, front, back);\n  }\n\n  if (vertexFormat.tangent) {\n    CorridorGeometryLibrary.addAttribute(tangents, forward, front, back);\n  }\n\n  if (vertexFormat.bitangent) {\n    CorridorGeometryLibrary.addAttribute(bitangents, left, front, back);\n  }\n}\n\nfunction combine(computedPositions, vertexFormat, ellipsoid) {\n  var positions = computedPositions.positions;\n  var corners = computedPositions.corners;\n  var endPositions = computedPositions.endPositions;\n  var computedLefts = computedPositions.lefts;\n  var computedNormals = computedPositions.normals;\n  var attributes = new GeometryAttributes();\n  var corner;\n  var leftCount = 0;\n  var rightCount = 0;\n  var i;\n  var indicesLength = 0;\n  var length;\n\n  for (i = 0; i < positions.length; i += 2) {\n    length = positions[i].length - 3;\n    leftCount += length; //subtracting 3 to account for duplicate points at corners\n\n    indicesLength += length * 2;\n    rightCount += positions[i + 1].length - 3;\n  }\n\n  leftCount += 3; //add back count for end positions\n\n  rightCount += 3;\n\n  for (i = 0; i < corners.length; i++) {\n    corner = corners[i];\n    var leftSide = corners[i].leftPositions;\n\n    if (defined(leftSide)) {\n      length = leftSide.length;\n      leftCount += length;\n      indicesLength += length;\n    } else {\n      length = corners[i].rightPositions.length;\n      rightCount += length;\n      indicesLength += length;\n    }\n  }\n\n  var addEndPositions = defined(endPositions);\n  var endPositionLength;\n\n  if (addEndPositions) {\n    endPositionLength = endPositions[0].length - 3;\n    leftCount += endPositionLength;\n    rightCount += endPositionLength;\n    endPositionLength /= 3;\n    indicesLength += endPositionLength * 6;\n  }\n\n  var size = leftCount + rightCount;\n  var finalPositions = new Float64Array(size);\n  var normals = vertexFormat.normal ? new Float32Array(size) : undefined;\n  var tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;\n  var bitangents = vertexFormat.bitangent ? new Float32Array(size) : undefined;\n  var attr = {\n    normals: normals,\n    tangents: tangents,\n    bitangents: bitangents\n  };\n  var front = 0;\n  var back = size - 1;\n  var UL, LL, UR, LR;\n  var normal = cartesian1;\n  var left = cartesian2;\n  var rightPos, leftPos;\n  var halfLength = endPositionLength / 2;\n  var indices = IndexDatatype.createTypedArray(size / 3, indicesLength);\n  var index = 0;\n\n  if (addEndPositions) {\n    // add rounded end\n    leftPos = cartesian3;\n    rightPos = cartesian4;\n    var firstEndPositions = endPositions[0];\n    normal = Cartesian3.fromArray(computedNormals, 0, normal);\n    left = Cartesian3.fromArray(computedLefts, 0, left);\n\n    for (i = 0; i < halfLength; i++) {\n      leftPos = Cartesian3.fromArray(firstEndPositions, (halfLength - 1 - i) * 3, leftPos);\n      rightPos = Cartesian3.fromArray(firstEndPositions, (halfLength + i) * 3, rightPos);\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n      CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);\n      addNormals(attr, normal, left, front, back, vertexFormat);\n      LL = front / 3;\n      LR = LL + 1;\n      UL = (back - 2) / 3;\n      UR = UL - 1;\n      indices[index++] = UL;\n      indices[index++] = LL;\n      indices[index++] = UR;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n      front += 3;\n      back -= 3;\n    }\n  }\n\n  var posIndex = 0;\n  var compIndex = 0;\n  var rightEdge = positions[posIndex++]; //add first two edges\n\n  var leftEdge = positions[posIndex++];\n  finalPositions.set(rightEdge, front);\n  finalPositions.set(leftEdge, back - leftEdge.length + 1);\n  left = Cartesian3.fromArray(computedLefts, compIndex, left);\n  var rightNormal;\n  var leftNormal;\n  length = leftEdge.length - 3;\n\n  for (i = 0; i < length; i += 3) {\n    rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, i, scratch1), scratch1);\n    leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length - i, scratch2), scratch2);\n    normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);\n    addNormals(attr, normal, left, front, back, vertexFormat);\n    LL = front / 3;\n    LR = LL + 1;\n    UL = (back - 2) / 3;\n    UR = UL - 1;\n    indices[index++] = UL;\n    indices[index++] = LL;\n    indices[index++] = UR;\n    indices[index++] = UR;\n    indices[index++] = LL;\n    indices[index++] = LR;\n    front += 3;\n    back -= 3;\n  }\n\n  rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, length, scratch1), scratch1);\n  leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length, scratch2), scratch2);\n  normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);\n  compIndex += 3;\n\n  for (i = 0; i < corners.length; i++) {\n    var j;\n    corner = corners[i];\n    var l = corner.leftPositions;\n    var r = corner.rightPositions;\n    var pivot;\n    var start;\n    var outsidePoint = cartesian6;\n    var previousPoint = cartesian3;\n    var nextPoint = cartesian4;\n    normal = Cartesian3.fromArray(computedNormals, compIndex, normal);\n\n    if (defined(l)) {\n      addNormals(attr, normal, left, undefined, back, vertexFormat);\n      back -= 3;\n      pivot = LR;\n      start = UR;\n\n      for (j = 0; j < l.length / 3; j++) {\n        outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);\n        indices[index++] = pivot;\n        indices[index++] = start - j - 1;\n        indices[index++] = start - j;\n        CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, undefined, back);\n        previousPoint = Cartesian3.fromArray(finalPositions, (start - j - 1) * 3, previousPoint);\n        nextPoint = Cartesian3.fromArray(finalPositions, pivot * 3, nextPoint);\n        left = Cartesian3.normalize(Cartesian3.subtract(previousPoint, nextPoint, left), left);\n        addNormals(attr, normal, left, undefined, back, vertexFormat);\n        back -= 3;\n      }\n\n      outsidePoint = Cartesian3.fromArray(finalPositions, pivot * 3, outsidePoint);\n      previousPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, start * 3, previousPoint), outsidePoint, previousPoint);\n      nextPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, (start - j) * 3, nextPoint), outsidePoint, nextPoint);\n      left = Cartesian3.normalize(Cartesian3.add(previousPoint, nextPoint, left), left);\n      addNormals(attr, normal, left, front, undefined, vertexFormat);\n      front += 3;\n    } else {\n      addNormals(attr, normal, left, front, undefined, vertexFormat);\n      front += 3;\n      pivot = UR;\n      start = LR;\n\n      for (j = 0; j < r.length / 3; j++) {\n        outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);\n        indices[index++] = pivot;\n        indices[index++] = start + j;\n        indices[index++] = start + j + 1;\n        CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, front);\n        previousPoint = Cartesian3.fromArray(finalPositions, pivot * 3, previousPoint);\n        nextPoint = Cartesian3.fromArray(finalPositions, (start + j) * 3, nextPoint);\n        left = Cartesian3.normalize(Cartesian3.subtract(previousPoint, nextPoint, left), left);\n        addNormals(attr, normal, left, front, undefined, vertexFormat);\n        front += 3;\n      }\n\n      outsidePoint = Cartesian3.fromArray(finalPositions, pivot * 3, outsidePoint);\n      previousPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, (start + j) * 3, previousPoint), outsidePoint, previousPoint);\n      nextPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, start * 3, nextPoint), outsidePoint, nextPoint);\n      left = Cartesian3.normalize(Cartesian3.negate(Cartesian3.add(nextPoint, previousPoint, left), left), left);\n      addNormals(attr, normal, left, undefined, back, vertexFormat);\n      back -= 3;\n    }\n\n    rightEdge = positions[posIndex++];\n    leftEdge = positions[posIndex++];\n    rightEdge.splice(0, 3); //remove duplicate points added by corner\n\n    leftEdge.splice(leftEdge.length - 3, 3);\n    finalPositions.set(rightEdge, front);\n    finalPositions.set(leftEdge, back - leftEdge.length + 1);\n    length = leftEdge.length - 3;\n    compIndex += 3;\n    left = Cartesian3.fromArray(computedLefts, compIndex, left);\n\n    for (j = 0; j < leftEdge.length; j += 3) {\n      rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, j, scratch1), scratch1);\n      leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length - j, scratch2), scratch2);\n      normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);\n      addNormals(attr, normal, left, front, back, vertexFormat);\n      LR = front / 3;\n      LL = LR - 1;\n      UR = (back - 2) / 3;\n      UL = UR + 1;\n      indices[index++] = UL;\n      indices[index++] = LL;\n      indices[index++] = UR;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n      front += 3;\n      back -= 3;\n    }\n\n    front -= 3;\n    back += 3;\n  }\n\n  normal = Cartesian3.fromArray(computedNormals, computedNormals.length - 3, normal);\n  addNormals(attr, normal, left, front, back, vertexFormat);\n\n  if (addEndPositions) {\n    // add rounded end\n    front += 3;\n    back -= 3;\n    leftPos = cartesian3;\n    rightPos = cartesian4;\n    var lastEndPositions = endPositions[1];\n\n    for (i = 0; i < halfLength; i++) {\n      leftPos = Cartesian3.fromArray(lastEndPositions, (endPositionLength - i - 1) * 3, leftPos);\n      rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);\n      CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n      addNormals(attr, normal, left, front, back, vertexFormat);\n      LR = front / 3;\n      LL = LR - 1;\n      UR = (back - 2) / 3;\n      UL = UR + 1;\n      indices[index++] = UL;\n      indices[index++] = LL;\n      indices[index++] = UR;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n      front += 3;\n      back -= 3;\n    }\n  }\n\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: finalPositions\n  });\n\n  if (vertexFormat.st) {\n    var st = new Float32Array(size / 3 * 2);\n    var rightSt;\n    var leftSt;\n    var stIndex = 0;\n\n    if (addEndPositions) {\n      leftCount /= 3;\n      rightCount /= 3;\n      var theta = Math.PI / (endPositionLength + 1);\n      leftSt = 1 / (leftCount - endPositionLength + 1);\n      rightSt = 1 / (rightCount - endPositionLength + 1);\n      var a;\n      var halfEndPos = endPositionLength / 2;\n\n      for (i = halfEndPos + 1; i < endPositionLength + 1; i++) {\n        // lower left rounded end\n        a = CesiumMath.PI_OVER_TWO + theta * i;\n        st[stIndex++] = rightSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n\n      for (i = 1; i < rightCount - endPositionLength + 1; i++) {\n        // bottom edge\n        st[stIndex++] = i * rightSt;\n        st[stIndex++] = 0;\n      }\n\n      for (i = endPositionLength; i > halfEndPos; i--) {\n        // lower right rounded end\n        a = CesiumMath.PI_OVER_TWO - i * theta;\n        st[stIndex++] = 1 - rightSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n\n      for (i = halfEndPos; i > 0; i--) {\n        // upper right rounded end\n        a = CesiumMath.PI_OVER_TWO - theta * i;\n        st[stIndex++] = 1 - leftSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n\n      for (i = leftCount - endPositionLength; i > 0; i--) {\n        // top edge\n        st[stIndex++] = i * leftSt;\n        st[stIndex++] = 1;\n      }\n\n      for (i = 1; i < halfEndPos + 1; i++) {\n        // upper left rounded end\n        a = CesiumMath.PI_OVER_TWO + theta * i;\n        st[stIndex++] = leftSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n    } else {\n      leftCount /= 3;\n      rightCount /= 3;\n      leftSt = 1 / (leftCount - 1);\n      rightSt = 1 / (rightCount - 1);\n\n      for (i = 0; i < rightCount; i++) {\n        // bottom edge\n        st[stIndex++] = i * rightSt;\n        st[stIndex++] = 0;\n      }\n\n      for (i = leftCount; i > 0; i--) {\n        // top edge\n        st[stIndex++] = (i - 1) * leftSt;\n        st[stIndex++] = 1;\n      }\n    }\n\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: st\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attr.normals\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attr.tangents\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attr.bitangents\n    });\n  }\n\n  return {\n    attributes: attributes,\n    indices: indices\n  };\n}\n\nfunction extrudedAttributes(attributes, vertexFormat) {\n  if (!vertexFormat.normal && !vertexFormat.tangent && !vertexFormat.bitangent && !vertexFormat.st) {\n    return attributes;\n  }\n\n  var positions = attributes.position.values;\n  var topNormals;\n  var topBitangents;\n\n  if (vertexFormat.normal || vertexFormat.bitangent) {\n    topNormals = attributes.normal.values;\n    topBitangents = attributes.bitangent.values;\n  }\n\n  var size = attributes.position.values.length / 18;\n  var threeSize = size * 3;\n  var twoSize = size * 2;\n  var sixSize = threeSize * 2;\n  var i;\n\n  if (vertexFormat.normal || vertexFormat.bitangent || vertexFormat.tangent) {\n    var normals = vertexFormat.normal ? new Float32Array(threeSize * 6) : undefined;\n    var tangents = vertexFormat.tangent ? new Float32Array(threeSize * 6) : undefined;\n    var bitangents = vertexFormat.bitangent ? new Float32Array(threeSize * 6) : undefined;\n    var topPosition = cartesian1;\n    var bottomPosition = cartesian2;\n    var previousPosition = cartesian3;\n    var normal = cartesian4;\n    var tangent = cartesian5;\n    var bitangent = cartesian6;\n    var attrIndex = sixSize;\n\n    for (i = 0; i < threeSize; i += 3) {\n      var attrIndexOffset = attrIndex + sixSize;\n      topPosition = Cartesian3.fromArray(positions, i, topPosition);\n      bottomPosition = Cartesian3.fromArray(positions, i + threeSize, bottomPosition);\n      previousPosition = Cartesian3.fromArray(positions, (i + 3) % threeSize, previousPosition);\n      bottomPosition = Cartesian3.subtract(bottomPosition, topPosition, bottomPosition);\n      previousPosition = Cartesian3.subtract(previousPosition, topPosition, previousPosition);\n      normal = Cartesian3.normalize(Cartesian3.cross(bottomPosition, previousPosition, normal), normal);\n\n      if (vertexFormat.normal) {\n        CorridorGeometryLibrary.addAttribute(normals, normal, attrIndexOffset);\n        CorridorGeometryLibrary.addAttribute(normals, normal, attrIndexOffset + 3);\n        CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex);\n        CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex + 3);\n      }\n\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\n        bitangent = Cartesian3.fromArray(topNormals, i, bitangent);\n\n        if (vertexFormat.bitangent) {\n          CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndexOffset);\n          CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndexOffset + 3);\n          CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndex);\n          CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndex + 3);\n        }\n\n        if (vertexFormat.tangent) {\n          tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);\n          CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndexOffset);\n          CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndexOffset + 3);\n          CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndex);\n          CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndex + 3);\n        }\n      }\n\n      attrIndex += 6;\n    }\n\n    if (vertexFormat.normal) {\n      normals.set(topNormals); //top\n\n      for (i = 0; i < threeSize; i += 3) {\n        //bottom normals\n        normals[i + threeSize] = -topNormals[i];\n        normals[i + threeSize + 1] = -topNormals[i + 1];\n        normals[i + threeSize + 2] = -topNormals[i + 2];\n      }\n\n      attributes.normal.values = normals;\n    } else {\n      attributes.normal = undefined;\n    }\n\n    if (vertexFormat.bitangent) {\n      bitangents.set(topBitangents); //top\n\n      bitangents.set(topBitangents, threeSize); //bottom\n\n      attributes.bitangent.values = bitangents;\n    } else {\n      attributes.bitangent = undefined;\n    }\n\n    if (vertexFormat.tangent) {\n      var topTangents = attributes.tangent.values;\n      tangents.set(topTangents); //top\n\n      tangents.set(topTangents, threeSize); //bottom\n\n      attributes.tangent.values = tangents;\n    }\n  }\n\n  if (vertexFormat.st) {\n    var topSt = attributes.st.values;\n    var st = new Float32Array(twoSize * 6);\n    st.set(topSt); //top\n\n    st.set(topSt, twoSize); //bottom\n\n    var index = twoSize * 2;\n\n    for (var j = 0; j < 2; j++) {\n      st[index++] = topSt[0];\n      st[index++] = topSt[1];\n\n      for (i = 2; i < twoSize; i += 2) {\n        var s = topSt[i];\n        var t = topSt[i + 1];\n        st[index++] = s;\n        st[index++] = t;\n        st[index++] = s;\n        st[index++] = t;\n      }\n\n      st[index++] = topSt[0];\n      st[index++] = topSt[1];\n    }\n\n    attributes.st.values = st;\n  }\n\n  return attributes;\n}\n\nfunction addWallPositions(positions, index, wallPositions) {\n  wallPositions[index++] = positions[0];\n  wallPositions[index++] = positions[1];\n  wallPositions[index++] = positions[2];\n\n  for (var i = 3; i < positions.length; i += 3) {\n    var x = positions[i];\n    var y = positions[i + 1];\n    var z = positions[i + 2];\n    wallPositions[index++] = x;\n    wallPositions[index++] = y;\n    wallPositions[index++] = z;\n    wallPositions[index++] = x;\n    wallPositions[index++] = y;\n    wallPositions[index++] = z;\n  }\n\n  wallPositions[index++] = positions[0];\n  wallPositions[index++] = positions[1];\n  wallPositions[index++] = positions[2];\n  return wallPositions;\n}\n\nfunction computePositionsExtruded(params, vertexFormat) {\n  var topVertexFormat = new VertexFormat({\n    position: vertexFormat.position,\n    normal: vertexFormat.normal || vertexFormat.bitangent || params.shadowVolume,\n    tangent: vertexFormat.tangent,\n    bitangent: vertexFormat.normal || vertexFormat.bitangent,\n    st: vertexFormat.st\n  });\n  var ellipsoid = params.ellipsoid;\n  var computedPositions = CorridorGeometryLibrary.computePositions(params);\n  var attr = combine(computedPositions, topVertexFormat, ellipsoid);\n  var height = params.height;\n  var extrudedHeight = params.extrudedHeight;\n  var attributes = attr.attributes;\n  var indices = attr.indices;\n  var positions = attributes.position.values;\n  var length = positions.length;\n  var newPositions = new Float64Array(length * 6);\n  var extrudedPositions = new Float64Array(length);\n  extrudedPositions.set(positions);\n  var wallPositions = new Float64Array(length * 4);\n  positions = PolygonPipeline.scaleToGeodeticHeight(positions, height, ellipsoid);\n  wallPositions = addWallPositions(positions, 0, wallPositions);\n  extrudedPositions = PolygonPipeline.scaleToGeodeticHeight(extrudedPositions, extrudedHeight, ellipsoid);\n  wallPositions = addWallPositions(extrudedPositions, length * 2, wallPositions);\n  newPositions.set(positions);\n  newPositions.set(extrudedPositions, length);\n  newPositions.set(wallPositions, length * 2);\n  attributes.position.values = newPositions;\n  attributes = extrudedAttributes(attributes, vertexFormat);\n  var i;\n  var size = length / 3;\n\n  if (params.shadowVolume) {\n    var topNormals = attributes.normal.values;\n    length = topNormals.length;\n    var extrudeNormals = new Float32Array(length * 6);\n\n    for (i = 0; i < length; i++) {\n      topNormals[i] = -topNormals[i];\n    } //only get normals for bottom layer that's going to be pushed down\n\n\n    extrudeNormals.set(topNormals, length); //bottom face\n\n    extrudeNormals = addWallPositions(topNormals, length * 4, extrudeNormals); //bottom wall\n\n    attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals\n    });\n\n    if (!vertexFormat.normal) {\n      attributes.normal = undefined;\n    }\n  }\n\n  if (defined(params.offsetAttribute)) {\n    var applyOffset = new Uint8Array(size * 6);\n\n    if (params.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      applyOffset = arrayFill(applyOffset, 1, 0, size); // top face\n\n      applyOffset = arrayFill(applyOffset, 1, size * 2, size * 4); // top wall\n    } else {\n      var applyOffsetValue = params.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      applyOffset = arrayFill(applyOffset, applyOffsetValue);\n    }\n\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset\n    });\n  }\n\n  var iLength = indices.length;\n  var twoSize = size + size;\n  var newIndices = IndexDatatype.createTypedArray(newPositions.length / 3, iLength * 2 + twoSize * 3);\n  newIndices.set(indices);\n  var index = iLength;\n\n  for (i = 0; i < iLength; i += 3) {\n    // bottom indices\n    var v0 = indices[i];\n    var v1 = indices[i + 1];\n    var v2 = indices[i + 2];\n    newIndices[index++] = v2 + size;\n    newIndices[index++] = v1 + size;\n    newIndices[index++] = v0 + size;\n  }\n\n  var UL, LL, UR, LR;\n\n  for (i = 0; i < twoSize; i += 2) {\n    //wall indices\n    UL = i + twoSize;\n    LL = UL + twoSize;\n    UR = UL + 1;\n    LR = LL + 1;\n    newIndices[index++] = UL;\n    newIndices[index++] = LL;\n    newIndices[index++] = UR;\n    newIndices[index++] = UR;\n    newIndices[index++] = LL;\n    newIndices[index++] = LR;\n  }\n\n  return {\n    attributes: attributes,\n    indices: newIndices\n  };\n}\n\nvar scratchCartesian1 = new Cartesian3();\nvar scratchCartesian2 = new Cartesian3();\nvar scratchCartographic = new Cartographic();\n\nfunction computeOffsetPoints(position1, position2, ellipsoid, halfWidth, min, max) {\n  // Compute direction of offset the point\n  var direction = Cartesian3.subtract(position2, position1, scratchCartesian1);\n  Cartesian3.normalize(direction, direction);\n  var normal = ellipsoid.geodeticSurfaceNormal(position1, scratchCartesian2);\n  var offsetDirection = Cartesian3.cross(direction, normal, scratchCartesian1);\n  Cartesian3.multiplyByScalar(offsetDirection, halfWidth, offsetDirection);\n  var minLat = min.latitude;\n  var minLon = min.longitude;\n  var maxLat = max.latitude;\n  var maxLon = max.longitude; // Compute 2 offset points\n\n  Cartesian3.add(position1, offsetDirection, scratchCartesian2);\n  ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);\n  var lat = scratchCartographic.latitude;\n  var lon = scratchCartographic.longitude;\n  minLat = Math.min(minLat, lat);\n  minLon = Math.min(minLon, lon);\n  maxLat = Math.max(maxLat, lat);\n  maxLon = Math.max(maxLon, lon);\n  Cartesian3.subtract(position1, offsetDirection, scratchCartesian2);\n  ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);\n  lat = scratchCartographic.latitude;\n  lon = scratchCartographic.longitude;\n  minLat = Math.min(minLat, lat);\n  minLon = Math.min(minLon, lon);\n  maxLat = Math.max(maxLat, lat);\n  maxLon = Math.max(maxLon, lon);\n  min.latitude = minLat;\n  min.longitude = minLon;\n  max.latitude = maxLat;\n  max.longitude = maxLon;\n}\n\nvar scratchCartesianOffset = new Cartesian3();\nvar scratchCartesianEnds = new Cartesian3();\nvar scratchCartographicMin = new Cartographic();\nvar scratchCartographicMax = new Cartographic();\n\nfunction computeRectangle(positions, ellipsoid, width, cornerType, result) {\n  positions = scaleToSurface(positions, ellipsoid);\n  var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n  var length = cleanPositions.length;\n\n  if (length < 2 || width <= 0) {\n    return new Rectangle();\n  }\n\n  var halfWidth = width * 0.5;\n  scratchCartographicMin.latitude = Number.POSITIVE_INFINITY;\n  scratchCartographicMin.longitude = Number.POSITIVE_INFINITY;\n  scratchCartographicMax.latitude = Number.NEGATIVE_INFINITY;\n  scratchCartographicMax.longitude = Number.NEGATIVE_INFINITY;\n  var lat, lon;\n\n  if (cornerType === CornerType.ROUNDED) {\n    // Compute start cap\n    var first = cleanPositions[0];\n    Cartesian3.subtract(first, cleanPositions[1], scratchCartesianOffset);\n    Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);\n    Cartesian3.multiplyByScalar(scratchCartesianOffset, halfWidth, scratchCartesianOffset);\n    Cartesian3.add(first, scratchCartesianOffset, scratchCartesianEnds);\n    ellipsoid.cartesianToCartographic(scratchCartesianEnds, scratchCartographic);\n    lat = scratchCartographic.latitude;\n    lon = scratchCartographic.longitude;\n    scratchCartographicMin.latitude = Math.min(scratchCartographicMin.latitude, lat);\n    scratchCartographicMin.longitude = Math.min(scratchCartographicMin.longitude, lon);\n    scratchCartographicMax.latitude = Math.max(scratchCartographicMax.latitude, lat);\n    scratchCartographicMax.longitude = Math.max(scratchCartographicMax.longitude, lon);\n  } // Compute the rest\n\n\n  for (var i = 0; i < length - 1; ++i) {\n    computeOffsetPoints(cleanPositions[i], cleanPositions[i + 1], ellipsoid, halfWidth, scratchCartographicMin, scratchCartographicMax);\n  } // Compute ending point\n\n\n  var last = cleanPositions[length - 1];\n  Cartesian3.subtract(last, cleanPositions[length - 2], scratchCartesianOffset);\n  Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);\n  Cartesian3.multiplyByScalar(scratchCartesianOffset, halfWidth, scratchCartesianOffset);\n  Cartesian3.add(last, scratchCartesianOffset, scratchCartesianEnds);\n  computeOffsetPoints(last, scratchCartesianEnds, ellipsoid, halfWidth, scratchCartographicMin, scratchCartographicMax);\n\n  if (cornerType === CornerType.ROUNDED) {\n    // Compute end cap\n    ellipsoid.cartesianToCartographic(scratchCartesianEnds, scratchCartographic);\n    lat = scratchCartographic.latitude;\n    lon = scratchCartographic.longitude;\n    scratchCartographicMin.latitude = Math.min(scratchCartographicMin.latitude, lat);\n    scratchCartographicMin.longitude = Math.min(scratchCartographicMin.longitude, lon);\n    scratchCartographicMax.latitude = Math.max(scratchCartographicMax.latitude, lat);\n    scratchCartographicMax.longitude = Math.max(scratchCartographicMax.longitude, lon);\n  }\n\n  var rectangle = defined(result) ? result : new Rectangle();\n  rectangle.north = scratchCartographicMax.latitude;\n  rectangle.south = scratchCartographicMin.latitude;\n  rectangle.east = scratchCartographicMax.longitude;\n  rectangle.west = scratchCartographicMin.longitude;\n  return rectangle;\n}\n/**\n * A description of a corridor. Corridor geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias CorridorGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.\n * @param {Number} options.width The distance between the edges of the corridor in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Number} [options.height=0] The distance in meters between the ellipsoid surface and the positions.\n * @param {Number} [options.extrudedHeight] The distance in meters between the ellipsoid surface and the extruded face.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n *\n * @see CorridorGeometry.createGeometry\n * @see Packable\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Corridor.html|Cesium Sandcastle Corridor Demo}\n *\n * @example\n * var corridor = new Cesium.CorridorGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\n *   width : 100000\n * });\n */\n\n\nfunction CorridorGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var positions = options.positions;\n  var width = options.width; //>>includeStart('debug', pragmas.debug);\n\n  Check.defined(\"options.positions\", positions);\n  Check.defined(\"options.width\", width); //>>includeEnd('debug');\n\n  var height = defaultValue(options.height, 0.0);\n  var extrudedHeight = defaultValue(options.extrudedHeight, height);\n  this._positions = positions;\n  this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n  this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));\n  this._width = width;\n  this._height = Math.max(height, extrudedHeight);\n  this._extrudedHeight = Math.min(height, extrudedHeight);\n  this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n  this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\n  this._workerName = \"createCorridorGeometry\";\n  this._offsetAttribute = options.offsetAttribute;\n  this._rectangle = undefined;\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n\n  this.packedLength = 1 + positions.length * Cartesian3.packedLength + Ellipsoid.packedLength + VertexFormat.packedLength + 7;\n}\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CorridorGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\n\nCorridorGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"value\", value);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var positions = value._positions;\n  var length = positions.length;\n  array[startingIndex++] = length;\n\n  for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n  array[startingIndex++] = value._width;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._cornerType;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n  return array;\n};\n\nvar scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nvar scratchVertexFormat = new VertexFormat();\nvar scratchOptions = {\n  positions: undefined,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  width: undefined,\n  height: undefined,\n  extrudedHeight: undefined,\n  cornerType: undefined,\n  granularity: undefined,\n  shadowVolume: undefined,\n  offsetAttribute: undefined\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CorridorGeometry} [result] The object into which to store the result.\n * @returns {CorridorGeometry} The modified result parameter or a new CorridorGeometry instance if one was not provided.\n */\n\nCorridorGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var length = array[startingIndex++];\n  var positions = new Array(length);\n\n  for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n  var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n  startingIndex += VertexFormat.packedLength;\n  var width = array[startingIndex++];\n  var height = array[startingIndex++];\n  var extrudedHeight = array[startingIndex++];\n  var cornerType = array[startingIndex++];\n  var granularity = array[startingIndex++];\n  var shadowVolume = array[startingIndex++] === 1.0;\n  var offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.positions = positions;\n    scratchOptions.width = width;\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.cornerType = cornerType;\n    scratchOptions.granularity = granularity;\n    scratchOptions.shadowVolume = shadowVolume;\n    scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new CorridorGeometry(scratchOptions);\n  }\n\n  result._positions = positions;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._width = width;\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._cornerType = cornerType;\n  result._granularity = granularity;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n  return result;\n};\n/**\n * Computes the bounding rectangle given the provided options\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.\n * @param {Number} options.width The distance between the edges of the corridor in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n * @param {Rectangle} [result] An object in which to store the result.\n *\n * @returns {Rectangle} The result rectangle.\n */\n\n\nCorridorGeometry.computeRectangle = function (options, result) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var positions = options.positions;\n  var width = options.width; //>>includeStart('debug', pragmas.debug);\n\n  Check.defined(\"options.positions\", positions);\n  Check.defined(\"options.width\", width); //>>includeEnd('debug');\n\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n  return computeRectangle(positions, ellipsoid, width, cornerType, result);\n};\n/**\n * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.\n *\n * @param {CorridorGeometry} corridorGeometry A description of the corridor.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\n\n\nCorridorGeometry.createGeometry = function (corridorGeometry) {\n  var positions = corridorGeometry._positions;\n  var width = corridorGeometry._width;\n  var ellipsoid = corridorGeometry._ellipsoid;\n  positions = scaleToSurface(positions, ellipsoid);\n  var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n\n  if (cleanPositions.length < 2 || width <= 0) {\n    return;\n  }\n\n  var height = corridorGeometry._height;\n  var extrudedHeight = corridorGeometry._extrudedHeight;\n  var extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n  var vertexFormat = corridorGeometry._vertexFormat;\n  var params = {\n    ellipsoid: ellipsoid,\n    positions: cleanPositions,\n    width: width,\n    cornerType: corridorGeometry._cornerType,\n    granularity: corridorGeometry._granularity,\n    saveAttributes: true\n  };\n  var attr;\n\n  if (extrude) {\n    params.height = height;\n    params.extrudedHeight = extrudedHeight;\n    params.shadowVolume = corridorGeometry._shadowVolume;\n    params.offsetAttribute = corridorGeometry._offsetAttribute;\n    attr = computePositionsExtruded(params, vertexFormat);\n  } else {\n    var computedPositions = CorridorGeometryLibrary.computePositions(params);\n    attr = combine(computedPositions, vertexFormat, ellipsoid);\n    attr.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(attr.attributes.position.values, height, ellipsoid);\n\n    if (defined(corridorGeometry._offsetAttribute)) {\n      var applyOffsetValue = corridorGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      var length = attr.attributes.position.values.length;\n      var applyOffset = new Uint8Array(length / 3);\n      arrayFill(applyOffset, applyOffsetValue);\n      attr.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset\n      });\n    }\n  }\n\n  var attributes = attr.attributes;\n  var boundingSphere = BoundingSphere.fromVertices(attributes.position.values, undefined, 3);\n\n  if (!vertexFormat.position) {\n    attr.attributes.position.values = undefined;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: attr.indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: corridorGeometry._offsetAttribute\n  });\n};\n/**\n * @private\n */\n\n\nCorridorGeometry.createShadowVolume = function (corridorGeometry, minHeightFunc, maxHeightFunc) {\n  var granularity = corridorGeometry._granularity;\n  var ellipsoid = corridorGeometry._ellipsoid;\n  var minHeight = minHeightFunc(granularity, ellipsoid);\n  var maxHeight = maxHeightFunc(granularity, ellipsoid);\n  return new CorridorGeometry({\n    positions: corridorGeometry._positions,\n    width: corridorGeometry._width,\n    cornerType: corridorGeometry._cornerType,\n    ellipsoid: ellipsoid,\n    granularity: granularity,\n    extrudedHeight: minHeight,\n    height: maxHeight,\n    vertexFormat: VertexFormat.POSITION_ONLY,\n    shadowVolume: true\n  });\n};\n\nObject.defineProperties(CorridorGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function () {\n      if (!defined(this._rectangle)) {\n        this._rectangle = computeRectangle(this._positions, this._ellipsoid, this._width, this._cornerType);\n      }\n\n      return this._rectangle;\n    }\n  },\n\n  /**\n   * For remapping texture coordinates when rendering CorridorGeometries as GroundPrimitives.\n   *\n   * Corridors don't support stRotation,\n   * so just return the corners of the original system.\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function () {\n      return [0, 0, 0, 1, 1, 0];\n    }\n  }\n});\nexport default CorridorGeometry;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/CorridorGeometry.js"],"names":["arrayFill","arrayRemoveDuplicates","BoundingSphere","Cartesian3","Cartographic","Check","ComponentDatatype","CornerType","CorridorGeometryLibrary","defaultValue","defined","Ellipsoid","Geometry","GeometryAttribute","GeometryAttributes","GeometryOffsetAttribute","IndexDatatype","CesiumMath","PolygonPipeline","PrimitiveType","Rectangle","VertexFormat","cartesian1","cartesian2","cartesian3","cartesian4","cartesian5","cartesian6","scratch1","scratch2","scaleToSurface","positions","ellipsoid","i","length","scaleToGeodeticSurface","addNormals","attr","normal","left","front","back","vertexFormat","normals","tangents","bitangents","forward","normalize","cross","addAttribute","tangent","bitangent","combine","computedPositions","corners","endPositions","computedLefts","lefts","computedNormals","attributes","corner","leftCount","rightCount","indicesLength","leftSide","leftPositions","rightPositions","addEndPositions","endPositionLength","size","finalPositions","Float64Array","Float32Array","undefined","UL","LL","UR","LR","rightPos","leftPos","halfLength","indices","createTypedArray","index","firstEndPositions","fromArray","posIndex","compIndex","rightEdge","leftEdge","set","rightNormal","leftNormal","geodeticSurfaceNormal","add","j","l","r","pivot","start","outsidePoint","previousPoint","nextPoint","subtract","negate","splice","lastEndPositions","position","componentDatatype","DOUBLE","componentsPerAttribute","values","st","rightSt","leftSt","stIndex","theta","Math","PI","a","halfEndPos","PI_OVER_TWO","cos","sin","FLOAT","extrudedAttributes","topNormals","topBitangents","threeSize","twoSize","sixSize","topPosition","bottomPosition","previousPosition","attrIndex","attrIndexOffset","topTangents","topSt","s","t","addWallPositions","wallPositions","x","y","z","computePositionsExtruded","params","topVertexFormat","shadowVolume","computePositions","height","extrudedHeight","newPositions","extrudedPositions","scaleToGeodeticHeight","extrudeNormals","extrudeDirection","offsetAttribute","applyOffset","Uint8Array","TOP","applyOffsetValue","NONE","UNSIGNED_BYTE","iLength","newIndices","v0","v1","v2","scratchCartesian1","scratchCartesian2","scratchCartographic","computeOffsetPoints","position1","position2","halfWidth","min","max","direction","offsetDirection","multiplyByScalar","minLat","latitude","minLon","longitude","maxLat","maxLon","cartesianToCartographic","lat","lon","scratchCartesianOffset","scratchCartesianEnds","scratchCartographicMin","scratchCartographicMax","computeRectangle","width","cornerType","result","cleanPositions","equalsEpsilon","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","ROUNDED","first","last","rectangle","north","south","east","west","CorridorGeometry","options","EMPTY_OBJECT","_positions","_ellipsoid","clone","WGS84","_vertexFormat","DEFAULT","_width","_height","_extrudedHeight","_cornerType","_granularity","granularity","RADIANS_PER_DEGREE","_shadowVolume","_workerName","_offsetAttribute","_rectangle","packedLength","pack","value","array","startingIndex","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","scratchOptions","unpack","Array","createGeometry","corridorGeometry","extrude","EPSILON2","saveAttributes","boundingSphere","fromVertices","primitiveType","TRIANGLES","createShadowVolume","minHeightFunc","maxHeightFunc","minHeight","maxHeight","POSITION_ONLY","Object","defineProperties","prototype","get","textureCoordinateRotationPoints"],"mappings":"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","sourcesContent":["import arrayFill from \"./arrayFill.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CornerType from \"./CornerType.js\";\nimport CorridorGeometryLibrary from \"./CorridorGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nvar cartesian1 = new Cartesian3();\nvar cartesian2 = new Cartesian3();\nvar cartesian3 = new Cartesian3();\nvar cartesian4 = new Cartesian3();\nvar cartesian5 = new Cartesian3();\nvar cartesian6 = new Cartesian3();\n\nvar scratch1 = new Cartesian3();\nvar scratch2 = new Cartesian3();\n\nfunction scaleToSurface(positions, ellipsoid) {\n  for (var i = 0; i < positions.length; i++) {\n    positions[i] = ellipsoid.scaleToGeodeticSurface(positions[i], positions[i]);\n  }\n  return positions;\n}\n\nfunction addNormals(attr, normal, left, front, back, vertexFormat) {\n  var normals = attr.normals;\n  var tangents = attr.tangents;\n  var bitangents = attr.bitangents;\n  var forward = Cartesian3.normalize(\n    Cartesian3.cross(left, normal, scratch1),\n    scratch1\n  );\n  if (vertexFormat.normal) {\n    CorridorGeometryLibrary.addAttribute(normals, normal, front, back);\n  }\n  if (vertexFormat.tangent) {\n    CorridorGeometryLibrary.addAttribute(tangents, forward, front, back);\n  }\n  if (vertexFormat.bitangent) {\n    CorridorGeometryLibrary.addAttribute(bitangents, left, front, back);\n  }\n}\n\nfunction combine(computedPositions, vertexFormat, ellipsoid) {\n  var positions = computedPositions.positions;\n  var corners = computedPositions.corners;\n  var endPositions = computedPositions.endPositions;\n  var computedLefts = computedPositions.lefts;\n  var computedNormals = computedPositions.normals;\n  var attributes = new GeometryAttributes();\n  var corner;\n  var leftCount = 0;\n  var rightCount = 0;\n  var i;\n  var indicesLength = 0;\n  var length;\n  for (i = 0; i < positions.length; i += 2) {\n    length = positions[i].length - 3;\n    leftCount += length; //subtracting 3 to account for duplicate points at corners\n    indicesLength += length * 2;\n    rightCount += positions[i + 1].length - 3;\n  }\n  leftCount += 3; //add back count for end positions\n  rightCount += 3;\n  for (i = 0; i < corners.length; i++) {\n    corner = corners[i];\n    var leftSide = corners[i].leftPositions;\n    if (defined(leftSide)) {\n      length = leftSide.length;\n      leftCount += length;\n      indicesLength += length;\n    } else {\n      length = corners[i].rightPositions.length;\n      rightCount += length;\n      indicesLength += length;\n    }\n  }\n\n  var addEndPositions = defined(endPositions);\n  var endPositionLength;\n  if (addEndPositions) {\n    endPositionLength = endPositions[0].length - 3;\n    leftCount += endPositionLength;\n    rightCount += endPositionLength;\n    endPositionLength /= 3;\n    indicesLength += endPositionLength * 6;\n  }\n  var size = leftCount + rightCount;\n  var finalPositions = new Float64Array(size);\n  var normals = vertexFormat.normal ? new Float32Array(size) : undefined;\n  var tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;\n  var bitangents = vertexFormat.bitangent ? new Float32Array(size) : undefined;\n  var attr = {\n    normals: normals,\n    tangents: tangents,\n    bitangents: bitangents,\n  };\n  var front = 0;\n  var back = size - 1;\n  var UL, LL, UR, LR;\n  var normal = cartesian1;\n  var left = cartesian2;\n  var rightPos, leftPos;\n  var halfLength = endPositionLength / 2;\n\n  var indices = IndexDatatype.createTypedArray(size / 3, indicesLength);\n  var index = 0;\n  if (addEndPositions) {\n    // add rounded end\n    leftPos = cartesian3;\n    rightPos = cartesian4;\n    var firstEndPositions = endPositions[0];\n    normal = Cartesian3.fromArray(computedNormals, 0, normal);\n    left = Cartesian3.fromArray(computedLefts, 0, left);\n    for (i = 0; i < halfLength; i++) {\n      leftPos = Cartesian3.fromArray(\n        firstEndPositions,\n        (halfLength - 1 - i) * 3,\n        leftPos\n      );\n      rightPos = Cartesian3.fromArray(\n        firstEndPositions,\n        (halfLength + i) * 3,\n        rightPos\n      );\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n      CorridorGeometryLibrary.addAttribute(\n        finalPositions,\n        leftPos,\n        undefined,\n        back\n      );\n      addNormals(attr, normal, left, front, back, vertexFormat);\n\n      LL = front / 3;\n      LR = LL + 1;\n      UL = (back - 2) / 3;\n      UR = UL - 1;\n      indices[index++] = UL;\n      indices[index++] = LL;\n      indices[index++] = UR;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n\n      front += 3;\n      back -= 3;\n    }\n  }\n\n  var posIndex = 0;\n  var compIndex = 0;\n  var rightEdge = positions[posIndex++]; //add first two edges\n  var leftEdge = positions[posIndex++];\n  finalPositions.set(rightEdge, front);\n  finalPositions.set(leftEdge, back - leftEdge.length + 1);\n\n  left = Cartesian3.fromArray(computedLefts, compIndex, left);\n  var rightNormal;\n  var leftNormal;\n  length = leftEdge.length - 3;\n  for (i = 0; i < length; i += 3) {\n    rightNormal = ellipsoid.geodeticSurfaceNormal(\n      Cartesian3.fromArray(rightEdge, i, scratch1),\n      scratch1\n    );\n    leftNormal = ellipsoid.geodeticSurfaceNormal(\n      Cartesian3.fromArray(leftEdge, length - i, scratch2),\n      scratch2\n    );\n    normal = Cartesian3.normalize(\n      Cartesian3.add(rightNormal, leftNormal, normal),\n      normal\n    );\n    addNormals(attr, normal, left, front, back, vertexFormat);\n\n    LL = front / 3;\n    LR = LL + 1;\n    UL = (back - 2) / 3;\n    UR = UL - 1;\n    indices[index++] = UL;\n    indices[index++] = LL;\n    indices[index++] = UR;\n    indices[index++] = UR;\n    indices[index++] = LL;\n    indices[index++] = LR;\n\n    front += 3;\n    back -= 3;\n  }\n\n  rightNormal = ellipsoid.geodeticSurfaceNormal(\n    Cartesian3.fromArray(rightEdge, length, scratch1),\n    scratch1\n  );\n  leftNormal = ellipsoid.geodeticSurfaceNormal(\n    Cartesian3.fromArray(leftEdge, length, scratch2),\n    scratch2\n  );\n  normal = Cartesian3.normalize(\n    Cartesian3.add(rightNormal, leftNormal, normal),\n    normal\n  );\n  compIndex += 3;\n  for (i = 0; i < corners.length; i++) {\n    var j;\n    corner = corners[i];\n    var l = corner.leftPositions;\n    var r = corner.rightPositions;\n    var pivot;\n    var start;\n    var outsidePoint = cartesian6;\n    var previousPoint = cartesian3;\n    var nextPoint = cartesian4;\n    normal = Cartesian3.fromArray(computedNormals, compIndex, normal);\n    if (defined(l)) {\n      addNormals(attr, normal, left, undefined, back, vertexFormat);\n      back -= 3;\n      pivot = LR;\n      start = UR;\n      for (j = 0; j < l.length / 3; j++) {\n        outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);\n        indices[index++] = pivot;\n        indices[index++] = start - j - 1;\n        indices[index++] = start - j;\n        CorridorGeometryLibrary.addAttribute(\n          finalPositions,\n          outsidePoint,\n          undefined,\n          back\n        );\n        previousPoint = Cartesian3.fromArray(\n          finalPositions,\n          (start - j - 1) * 3,\n          previousPoint\n        );\n        nextPoint = Cartesian3.fromArray(finalPositions, pivot * 3, nextPoint);\n        left = Cartesian3.normalize(\n          Cartesian3.subtract(previousPoint, nextPoint, left),\n          left\n        );\n        addNormals(attr, normal, left, undefined, back, vertexFormat);\n        back -= 3;\n      }\n      outsidePoint = Cartesian3.fromArray(\n        finalPositions,\n        pivot * 3,\n        outsidePoint\n      );\n      previousPoint = Cartesian3.subtract(\n        Cartesian3.fromArray(finalPositions, start * 3, previousPoint),\n        outsidePoint,\n        previousPoint\n      );\n      nextPoint = Cartesian3.subtract(\n        Cartesian3.fromArray(finalPositions, (start - j) * 3, nextPoint),\n        outsidePoint,\n        nextPoint\n      );\n      left = Cartesian3.normalize(\n        Cartesian3.add(previousPoint, nextPoint, left),\n        left\n      );\n      addNormals(attr, normal, left, front, undefined, vertexFormat);\n      front += 3;\n    } else {\n      addNormals(attr, normal, left, front, undefined, vertexFormat);\n      front += 3;\n      pivot = UR;\n      start = LR;\n      for (j = 0; j < r.length / 3; j++) {\n        outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);\n        indices[index++] = pivot;\n        indices[index++] = start + j;\n        indices[index++] = start + j + 1;\n        CorridorGeometryLibrary.addAttribute(\n          finalPositions,\n          outsidePoint,\n          front\n        );\n        previousPoint = Cartesian3.fromArray(\n          finalPositions,\n          pivot * 3,\n          previousPoint\n        );\n        nextPoint = Cartesian3.fromArray(\n          finalPositions,\n          (start + j) * 3,\n          nextPoint\n        );\n        left = Cartesian3.normalize(\n          Cartesian3.subtract(previousPoint, nextPoint, left),\n          left\n        );\n        addNormals(attr, normal, left, front, undefined, vertexFormat);\n        front += 3;\n      }\n      outsidePoint = Cartesian3.fromArray(\n        finalPositions,\n        pivot * 3,\n        outsidePoint\n      );\n      previousPoint = Cartesian3.subtract(\n        Cartesian3.fromArray(finalPositions, (start + j) * 3, previousPoint),\n        outsidePoint,\n        previousPoint\n      );\n      nextPoint = Cartesian3.subtract(\n        Cartesian3.fromArray(finalPositions, start * 3, nextPoint),\n        outsidePoint,\n        nextPoint\n      );\n      left = Cartesian3.normalize(\n        Cartesian3.negate(Cartesian3.add(nextPoint, previousPoint, left), left),\n        left\n      );\n      addNormals(attr, normal, left, undefined, back, vertexFormat);\n      back -= 3;\n    }\n    rightEdge = positions[posIndex++];\n    leftEdge = positions[posIndex++];\n    rightEdge.splice(0, 3); //remove duplicate points added by corner\n    leftEdge.splice(leftEdge.length - 3, 3);\n    finalPositions.set(rightEdge, front);\n    finalPositions.set(leftEdge, back - leftEdge.length + 1);\n    length = leftEdge.length - 3;\n\n    compIndex += 3;\n    left = Cartesian3.fromArray(computedLefts, compIndex, left);\n    for (j = 0; j < leftEdge.length; j += 3) {\n      rightNormal = ellipsoid.geodeticSurfaceNormal(\n        Cartesian3.fromArray(rightEdge, j, scratch1),\n        scratch1\n      );\n      leftNormal = ellipsoid.geodeticSurfaceNormal(\n        Cartesian3.fromArray(leftEdge, length - j, scratch2),\n        scratch2\n      );\n      normal = Cartesian3.normalize(\n        Cartesian3.add(rightNormal, leftNormal, normal),\n        normal\n      );\n      addNormals(attr, normal, left, front, back, vertexFormat);\n\n      LR = front / 3;\n      LL = LR - 1;\n      UR = (back - 2) / 3;\n      UL = UR + 1;\n      indices[index++] = UL;\n      indices[index++] = LL;\n      indices[index++] = UR;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n\n      front += 3;\n      back -= 3;\n    }\n    front -= 3;\n    back += 3;\n  }\n  normal = Cartesian3.fromArray(\n    computedNormals,\n    computedNormals.length - 3,\n    normal\n  );\n  addNormals(attr, normal, left, front, back, vertexFormat);\n\n  if (addEndPositions) {\n    // add rounded end\n    front += 3;\n    back -= 3;\n    leftPos = cartesian3;\n    rightPos = cartesian4;\n    var lastEndPositions = endPositions[1];\n    for (i = 0; i < halfLength; i++) {\n      leftPos = Cartesian3.fromArray(\n        lastEndPositions,\n        (endPositionLength - i - 1) * 3,\n        leftPos\n      );\n      rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);\n      CorridorGeometryLibrary.addAttribute(\n        finalPositions,\n        leftPos,\n        undefined,\n        back\n      );\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n      addNormals(attr, normal, left, front, back, vertexFormat);\n\n      LR = front / 3;\n      LL = LR - 1;\n      UR = (back - 2) / 3;\n      UL = UR + 1;\n      indices[index++] = UL;\n      indices[index++] = LL;\n      indices[index++] = UR;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n\n      front += 3;\n      back -= 3;\n    }\n  }\n\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: finalPositions,\n  });\n\n  if (vertexFormat.st) {\n    var st = new Float32Array((size / 3) * 2);\n    var rightSt;\n    var leftSt;\n    var stIndex = 0;\n    if (addEndPositions) {\n      leftCount /= 3;\n      rightCount /= 3;\n      var theta = Math.PI / (endPositionLength + 1);\n      leftSt = 1 / (leftCount - endPositionLength + 1);\n      rightSt = 1 / (rightCount - endPositionLength + 1);\n      var a;\n      var halfEndPos = endPositionLength / 2;\n      for (i = halfEndPos + 1; i < endPositionLength + 1; i++) {\n        // lower left rounded end\n        a = CesiumMath.PI_OVER_TWO + theta * i;\n        st[stIndex++] = rightSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n      for (i = 1; i < rightCount - endPositionLength + 1; i++) {\n        // bottom edge\n        st[stIndex++] = i * rightSt;\n        st[stIndex++] = 0;\n      }\n      for (i = endPositionLength; i > halfEndPos; i--) {\n        // lower right rounded end\n        a = CesiumMath.PI_OVER_TWO - i * theta;\n        st[stIndex++] = 1 - rightSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n      for (i = halfEndPos; i > 0; i--) {\n        // upper right rounded end\n        a = CesiumMath.PI_OVER_TWO - theta * i;\n        st[stIndex++] = 1 - leftSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n      for (i = leftCount - endPositionLength; i > 0; i--) {\n        // top edge\n        st[stIndex++] = i * leftSt;\n        st[stIndex++] = 1;\n      }\n      for (i = 1; i < halfEndPos + 1; i++) {\n        // upper left rounded end\n        a = CesiumMath.PI_OVER_TWO + theta * i;\n        st[stIndex++] = leftSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n    } else {\n      leftCount /= 3;\n      rightCount /= 3;\n      leftSt = 1 / (leftCount - 1);\n      rightSt = 1 / (rightCount - 1);\n      for (i = 0; i < rightCount; i++) {\n        // bottom edge\n        st[stIndex++] = i * rightSt;\n        st[stIndex++] = 0;\n      }\n      for (i = leftCount; i > 0; i--) {\n        // top edge\n        st[stIndex++] = (i - 1) * leftSt;\n        st[stIndex++] = 1;\n      }\n    }\n\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: st,\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attr.normals,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attr.tangents,\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attr.bitangents,\n    });\n  }\n\n  return {\n    attributes: attributes,\n    indices: indices,\n  };\n}\n\nfunction extrudedAttributes(attributes, vertexFormat) {\n  if (\n    !vertexFormat.normal &&\n    !vertexFormat.tangent &&\n    !vertexFormat.bitangent &&\n    !vertexFormat.st\n  ) {\n    return attributes;\n  }\n  var positions = attributes.position.values;\n  var topNormals;\n  var topBitangents;\n  if (vertexFormat.normal || vertexFormat.bitangent) {\n    topNormals = attributes.normal.values;\n    topBitangents = attributes.bitangent.values;\n  }\n  var size = attributes.position.values.length / 18;\n  var threeSize = size * 3;\n  var twoSize = size * 2;\n  var sixSize = threeSize * 2;\n  var i;\n  if (vertexFormat.normal || vertexFormat.bitangent || vertexFormat.tangent) {\n    var normals = vertexFormat.normal\n      ? new Float32Array(threeSize * 6)\n      : undefined;\n    var tangents = vertexFormat.tangent\n      ? new Float32Array(threeSize * 6)\n      : undefined;\n    var bitangents = vertexFormat.bitangent\n      ? new Float32Array(threeSize * 6)\n      : undefined;\n    var topPosition = cartesian1;\n    var bottomPosition = cartesian2;\n    var previousPosition = cartesian3;\n    var normal = cartesian4;\n    var tangent = cartesian5;\n    var bitangent = cartesian6;\n    var attrIndex = sixSize;\n    for (i = 0; i < threeSize; i += 3) {\n      var attrIndexOffset = attrIndex + sixSize;\n      topPosition = Cartesian3.fromArray(positions, i, topPosition);\n      bottomPosition = Cartesian3.fromArray(\n        positions,\n        i + threeSize,\n        bottomPosition\n      );\n      previousPosition = Cartesian3.fromArray(\n        positions,\n        (i + 3) % threeSize,\n        previousPosition\n      );\n      bottomPosition = Cartesian3.subtract(\n        bottomPosition,\n        topPosition,\n        bottomPosition\n      );\n      previousPosition = Cartesian3.subtract(\n        previousPosition,\n        topPosition,\n        previousPosition\n      );\n      normal = Cartesian3.normalize(\n        Cartesian3.cross(bottomPosition, previousPosition, normal),\n        normal\n      );\n      if (vertexFormat.normal) {\n        CorridorGeometryLibrary.addAttribute(normals, normal, attrIndexOffset);\n        CorridorGeometryLibrary.addAttribute(\n          normals,\n          normal,\n          attrIndexOffset + 3\n        );\n        CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex);\n        CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex + 3);\n      }\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\n        bitangent = Cartesian3.fromArray(topNormals, i, bitangent);\n        if (vertexFormat.bitangent) {\n          CorridorGeometryLibrary.addAttribute(\n            bitangents,\n            bitangent,\n            attrIndexOffset\n          );\n          CorridorGeometryLibrary.addAttribute(\n            bitangents,\n            bitangent,\n            attrIndexOffset + 3\n          );\n          CorridorGeometryLibrary.addAttribute(\n            bitangents,\n            bitangent,\n            attrIndex\n          );\n          CorridorGeometryLibrary.addAttribute(\n            bitangents,\n            bitangent,\n            attrIndex + 3\n          );\n        }\n\n        if (vertexFormat.tangent) {\n          tangent = Cartesian3.normalize(\n            Cartesian3.cross(bitangent, normal, tangent),\n            tangent\n          );\n          CorridorGeometryLibrary.addAttribute(\n            tangents,\n            tangent,\n            attrIndexOffset\n          );\n          CorridorGeometryLibrary.addAttribute(\n            tangents,\n            tangent,\n            attrIndexOffset + 3\n          );\n          CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndex);\n          CorridorGeometryLibrary.addAttribute(\n            tangents,\n            tangent,\n            attrIndex + 3\n          );\n        }\n      }\n      attrIndex += 6;\n    }\n\n    if (vertexFormat.normal) {\n      normals.set(topNormals); //top\n      for (i = 0; i < threeSize; i += 3) {\n        //bottom normals\n        normals[i + threeSize] = -topNormals[i];\n        normals[i + threeSize + 1] = -topNormals[i + 1];\n        normals[i + threeSize + 2] = -topNormals[i + 2];\n      }\n      attributes.normal.values = normals;\n    } else {\n      attributes.normal = undefined;\n    }\n\n    if (vertexFormat.bitangent) {\n      bitangents.set(topBitangents); //top\n      bitangents.set(topBitangents, threeSize); //bottom\n      attributes.bitangent.values = bitangents;\n    } else {\n      attributes.bitangent = undefined;\n    }\n\n    if (vertexFormat.tangent) {\n      var topTangents = attributes.tangent.values;\n      tangents.set(topTangents); //top\n      tangents.set(topTangents, threeSize); //bottom\n      attributes.tangent.values = tangents;\n    }\n  }\n  if (vertexFormat.st) {\n    var topSt = attributes.st.values;\n    var st = new Float32Array(twoSize * 6);\n    st.set(topSt); //top\n    st.set(topSt, twoSize); //bottom\n    var index = twoSize * 2;\n\n    for (var j = 0; j < 2; j++) {\n      st[index++] = topSt[0];\n      st[index++] = topSt[1];\n      for (i = 2; i < twoSize; i += 2) {\n        var s = topSt[i];\n        var t = topSt[i + 1];\n        st[index++] = s;\n        st[index++] = t;\n        st[index++] = s;\n        st[index++] = t;\n      }\n      st[index++] = topSt[0];\n      st[index++] = topSt[1];\n    }\n    attributes.st.values = st;\n  }\n\n  return attributes;\n}\n\nfunction addWallPositions(positions, index, wallPositions) {\n  wallPositions[index++] = positions[0];\n  wallPositions[index++] = positions[1];\n  wallPositions[index++] = positions[2];\n  for (var i = 3; i < positions.length; i += 3) {\n    var x = positions[i];\n    var y = positions[i + 1];\n    var z = positions[i + 2];\n    wallPositions[index++] = x;\n    wallPositions[index++] = y;\n    wallPositions[index++] = z;\n    wallPositions[index++] = x;\n    wallPositions[index++] = y;\n    wallPositions[index++] = z;\n  }\n  wallPositions[index++] = positions[0];\n  wallPositions[index++] = positions[1];\n  wallPositions[index++] = positions[2];\n\n  return wallPositions;\n}\n\nfunction computePositionsExtruded(params, vertexFormat) {\n  var topVertexFormat = new VertexFormat({\n    position: vertexFormat.position,\n    normal:\n      vertexFormat.normal || vertexFormat.bitangent || params.shadowVolume,\n    tangent: vertexFormat.tangent,\n    bitangent: vertexFormat.normal || vertexFormat.bitangent,\n    st: vertexFormat.st,\n  });\n  var ellipsoid = params.ellipsoid;\n  var computedPositions = CorridorGeometryLibrary.computePositions(params);\n  var attr = combine(computedPositions, topVertexFormat, ellipsoid);\n  var height = params.height;\n  var extrudedHeight = params.extrudedHeight;\n  var attributes = attr.attributes;\n  var indices = attr.indices;\n  var positions = attributes.position.values;\n  var length = positions.length;\n  var newPositions = new Float64Array(length * 6);\n  var extrudedPositions = new Float64Array(length);\n  extrudedPositions.set(positions);\n  var wallPositions = new Float64Array(length * 4);\n\n  positions = PolygonPipeline.scaleToGeodeticHeight(\n    positions,\n    height,\n    ellipsoid\n  );\n  wallPositions = addWallPositions(positions, 0, wallPositions);\n  extrudedPositions = PolygonPipeline.scaleToGeodeticHeight(\n    extrudedPositions,\n    extrudedHeight,\n    ellipsoid\n  );\n  wallPositions = addWallPositions(\n    extrudedPositions,\n    length * 2,\n    wallPositions\n  );\n  newPositions.set(positions);\n  newPositions.set(extrudedPositions, length);\n  newPositions.set(wallPositions, length * 2);\n  attributes.position.values = newPositions;\n\n  attributes = extrudedAttributes(attributes, vertexFormat);\n  var i;\n  var size = length / 3;\n  if (params.shadowVolume) {\n    var topNormals = attributes.normal.values;\n    length = topNormals.length;\n\n    var extrudeNormals = new Float32Array(length * 6);\n    for (i = 0; i < length; i++) {\n      topNormals[i] = -topNormals[i];\n    }\n    //only get normals for bottom layer that's going to be pushed down\n    extrudeNormals.set(topNormals, length); //bottom face\n    extrudeNormals = addWallPositions(topNormals, length * 4, extrudeNormals); //bottom wall\n    attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals,\n    });\n    if (!vertexFormat.normal) {\n      attributes.normal = undefined;\n    }\n  }\n  if (defined(params.offsetAttribute)) {\n    var applyOffset = new Uint8Array(size * 6);\n    if (params.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      applyOffset = arrayFill(applyOffset, 1, 0, size); // top face\n      applyOffset = arrayFill(applyOffset, 1, size * 2, size * 4); // top wall\n    } else {\n      var applyOffsetValue =\n        params.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      applyOffset = arrayFill(applyOffset, applyOffsetValue);\n    }\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  var iLength = indices.length;\n  var twoSize = size + size;\n  var newIndices = IndexDatatype.createTypedArray(\n    newPositions.length / 3,\n    iLength * 2 + twoSize * 3\n  );\n  newIndices.set(indices);\n  var index = iLength;\n  for (i = 0; i < iLength; i += 3) {\n    // bottom indices\n    var v0 = indices[i];\n    var v1 = indices[i + 1];\n    var v2 = indices[i + 2];\n    newIndices[index++] = v2 + size;\n    newIndices[index++] = v1 + size;\n    newIndices[index++] = v0 + size;\n  }\n\n  var UL, LL, UR, LR;\n\n  for (i = 0; i < twoSize; i += 2) {\n    //wall indices\n    UL = i + twoSize;\n    LL = UL + twoSize;\n    UR = UL + 1;\n    LR = LL + 1;\n    newIndices[index++] = UL;\n    newIndices[index++] = LL;\n    newIndices[index++] = UR;\n    newIndices[index++] = UR;\n    newIndices[index++] = LL;\n    newIndices[index++] = LR;\n  }\n\n  return {\n    attributes: attributes,\n    indices: newIndices,\n  };\n}\n\nvar scratchCartesian1 = new Cartesian3();\nvar scratchCartesian2 = new Cartesian3();\nvar scratchCartographic = new Cartographic();\n\nfunction computeOffsetPoints(\n  position1,\n  position2,\n  ellipsoid,\n  halfWidth,\n  min,\n  max\n) {\n  // Compute direction of offset the point\n  var direction = Cartesian3.subtract(position2, position1, scratchCartesian1);\n  Cartesian3.normalize(direction, direction);\n  var normal = ellipsoid.geodeticSurfaceNormal(position1, scratchCartesian2);\n  var offsetDirection = Cartesian3.cross(direction, normal, scratchCartesian1);\n  Cartesian3.multiplyByScalar(offsetDirection, halfWidth, offsetDirection);\n\n  var minLat = min.latitude;\n  var minLon = min.longitude;\n  var maxLat = max.latitude;\n  var maxLon = max.longitude;\n\n  // Compute 2 offset points\n  Cartesian3.add(position1, offsetDirection, scratchCartesian2);\n  ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);\n\n  var lat = scratchCartographic.latitude;\n  var lon = scratchCartographic.longitude;\n  minLat = Math.min(minLat, lat);\n  minLon = Math.min(minLon, lon);\n  maxLat = Math.max(maxLat, lat);\n  maxLon = Math.max(maxLon, lon);\n\n  Cartesian3.subtract(position1, offsetDirection, scratchCartesian2);\n  ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);\n\n  lat = scratchCartographic.latitude;\n  lon = scratchCartographic.longitude;\n  minLat = Math.min(minLat, lat);\n  minLon = Math.min(minLon, lon);\n  maxLat = Math.max(maxLat, lat);\n  maxLon = Math.max(maxLon, lon);\n\n  min.latitude = minLat;\n  min.longitude = minLon;\n  max.latitude = maxLat;\n  max.longitude = maxLon;\n}\n\nvar scratchCartesianOffset = new Cartesian3();\nvar scratchCartesianEnds = new Cartesian3();\nvar scratchCartographicMin = new Cartographic();\nvar scratchCartographicMax = new Cartographic();\n\nfunction computeRectangle(positions, ellipsoid, width, cornerType, result) {\n  positions = scaleToSurface(positions, ellipsoid);\n  var cleanPositions = arrayRemoveDuplicates(\n    positions,\n    Cartesian3.equalsEpsilon\n  );\n  var length = cleanPositions.length;\n  if (length < 2 || width <= 0) {\n    return new Rectangle();\n  }\n  var halfWidth = width * 0.5;\n\n  scratchCartographicMin.latitude = Number.POSITIVE_INFINITY;\n  scratchCartographicMin.longitude = Number.POSITIVE_INFINITY;\n  scratchCartographicMax.latitude = Number.NEGATIVE_INFINITY;\n  scratchCartographicMax.longitude = Number.NEGATIVE_INFINITY;\n\n  var lat, lon;\n  if (cornerType === CornerType.ROUNDED) {\n    // Compute start cap\n    var first = cleanPositions[0];\n    Cartesian3.subtract(first, cleanPositions[1], scratchCartesianOffset);\n    Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);\n    Cartesian3.multiplyByScalar(\n      scratchCartesianOffset,\n      halfWidth,\n      scratchCartesianOffset\n    );\n    Cartesian3.add(first, scratchCartesianOffset, scratchCartesianEnds);\n\n    ellipsoid.cartesianToCartographic(\n      scratchCartesianEnds,\n      scratchCartographic\n    );\n    lat = scratchCartographic.latitude;\n    lon = scratchCartographic.longitude;\n    scratchCartographicMin.latitude = Math.min(\n      scratchCartographicMin.latitude,\n      lat\n    );\n    scratchCartographicMin.longitude = Math.min(\n      scratchCartographicMin.longitude,\n      lon\n    );\n    scratchCartographicMax.latitude = Math.max(\n      scratchCartographicMax.latitude,\n      lat\n    );\n    scratchCartographicMax.longitude = Math.max(\n      scratchCartographicMax.longitude,\n      lon\n    );\n  }\n\n  // Compute the rest\n  for (var i = 0; i < length - 1; ++i) {\n    computeOffsetPoints(\n      cleanPositions[i],\n      cleanPositions[i + 1],\n      ellipsoid,\n      halfWidth,\n      scratchCartographicMin,\n      scratchCartographicMax\n    );\n  }\n\n  // Compute ending point\n  var last = cleanPositions[length - 1];\n  Cartesian3.subtract(last, cleanPositions[length - 2], scratchCartesianOffset);\n  Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);\n  Cartesian3.multiplyByScalar(\n    scratchCartesianOffset,\n    halfWidth,\n    scratchCartesianOffset\n  );\n  Cartesian3.add(last, scratchCartesianOffset, scratchCartesianEnds);\n  computeOffsetPoints(\n    last,\n    scratchCartesianEnds,\n    ellipsoid,\n    halfWidth,\n    scratchCartographicMin,\n    scratchCartographicMax\n  );\n\n  if (cornerType === CornerType.ROUNDED) {\n    // Compute end cap\n    ellipsoid.cartesianToCartographic(\n      scratchCartesianEnds,\n      scratchCartographic\n    );\n    lat = scratchCartographic.latitude;\n    lon = scratchCartographic.longitude;\n    scratchCartographicMin.latitude = Math.min(\n      scratchCartographicMin.latitude,\n      lat\n    );\n    scratchCartographicMin.longitude = Math.min(\n      scratchCartographicMin.longitude,\n      lon\n    );\n    scratchCartographicMax.latitude = Math.max(\n      scratchCartographicMax.latitude,\n      lat\n    );\n    scratchCartographicMax.longitude = Math.max(\n      scratchCartographicMax.longitude,\n      lon\n    );\n  }\n\n  var rectangle = defined(result) ? result : new Rectangle();\n  rectangle.north = scratchCartographicMax.latitude;\n  rectangle.south = scratchCartographicMin.latitude;\n  rectangle.east = scratchCartographicMax.longitude;\n  rectangle.west = scratchCartographicMin.longitude;\n\n  return rectangle;\n}\n\n/**\n * A description of a corridor. Corridor geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias CorridorGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.\n * @param {Number} options.width The distance between the edges of the corridor in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Number} [options.height=0] The distance in meters between the ellipsoid surface and the positions.\n * @param {Number} [options.extrudedHeight] The distance in meters between the ellipsoid surface and the extruded face.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n *\n * @see CorridorGeometry.createGeometry\n * @see Packable\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Corridor.html|Cesium Sandcastle Corridor Demo}\n *\n * @example\n * var corridor = new Cesium.CorridorGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\n *   width : 100000\n * });\n */\nfunction CorridorGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var positions = options.positions;\n  var width = options.width;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", positions);\n  Check.defined(\"options.width\", width);\n  //>>includeEnd('debug');\n\n  var height = defaultValue(options.height, 0.0);\n  var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  this._positions = positions;\n  this._ellipsoid = Ellipsoid.clone(\n    defaultValue(options.ellipsoid, Ellipsoid.WGS84)\n  );\n  this._vertexFormat = VertexFormat.clone(\n    defaultValue(options.vertexFormat, VertexFormat.DEFAULT)\n  );\n  this._width = width;\n  this._height = Math.max(height, extrudedHeight);\n  this._extrudedHeight = Math.min(height, extrudedHeight);\n  this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n  this._granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\n  this._workerName = \"createCorridorGeometry\";\n  this._offsetAttribute = options.offsetAttribute;\n  this._rectangle = undefined;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  this.packedLength =\n    1 +\n    positions.length * Cartesian3.packedLength +\n    Ellipsoid.packedLength +\n    VertexFormat.packedLength +\n    7;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CorridorGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCorridorGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var positions = value._positions;\n  var length = positions.length;\n  array[startingIndex++] = length;\n\n  for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._width;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._cornerType;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nvar scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nvar scratchVertexFormat = new VertexFormat();\nvar scratchOptions = {\n  positions: undefined,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  width: undefined,\n  height: undefined,\n  extrudedHeight: undefined,\n  cornerType: undefined,\n  granularity: undefined,\n  shadowVolume: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CorridorGeometry} [result] The object into which to store the result.\n * @returns {CorridorGeometry} The modified result parameter or a new CorridorGeometry instance if one was not provided.\n */\nCorridorGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var length = array[startingIndex++];\n  var positions = new Array(length);\n\n  for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  var vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  var width = array[startingIndex++];\n  var height = array[startingIndex++];\n  var extrudedHeight = array[startingIndex++];\n  var cornerType = array[startingIndex++];\n  var granularity = array[startingIndex++];\n  var shadowVolume = array[startingIndex++] === 1.0;\n  var offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.positions = positions;\n    scratchOptions.width = width;\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.cornerType = cornerType;\n    scratchOptions.granularity = granularity;\n    scratchOptions.shadowVolume = shadowVolume;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n\n    return new CorridorGeometry(scratchOptions);\n  }\n\n  result._positions = positions;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._width = width;\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._cornerType = cornerType;\n  result._granularity = granularity;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the bounding rectangle given the provided options\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.\n * @param {Number} options.width The distance between the edges of the corridor in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n * @param {Rectangle} [result] An object in which to store the result.\n *\n * @returns {Rectangle} The result rectangle.\n */\nCorridorGeometry.computeRectangle = function (options, result) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var positions = options.positions;\n  var width = options.width;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", positions);\n  Check.defined(\"options.width\", width);\n  //>>includeEnd('debug');\n\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n\n  return computeRectangle(positions, ellipsoid, width, cornerType, result);\n};\n\n/**\n * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.\n *\n * @param {CorridorGeometry} corridorGeometry A description of the corridor.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCorridorGeometry.createGeometry = function (corridorGeometry) {\n  var positions = corridorGeometry._positions;\n  var width = corridorGeometry._width;\n  var ellipsoid = corridorGeometry._ellipsoid;\n\n  positions = scaleToSurface(positions, ellipsoid);\n  var cleanPositions = arrayRemoveDuplicates(\n    positions,\n    Cartesian3.equalsEpsilon\n  );\n\n  if (cleanPositions.length < 2 || width <= 0) {\n    return;\n  }\n\n  var height = corridorGeometry._height;\n  var extrudedHeight = corridorGeometry._extrudedHeight;\n  var extrude = !CesiumMath.equalsEpsilon(\n    height,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2\n  );\n\n  var vertexFormat = corridorGeometry._vertexFormat;\n  var params = {\n    ellipsoid: ellipsoid,\n    positions: cleanPositions,\n    width: width,\n    cornerType: corridorGeometry._cornerType,\n    granularity: corridorGeometry._granularity,\n    saveAttributes: true,\n  };\n  var attr;\n  if (extrude) {\n    params.height = height;\n    params.extrudedHeight = extrudedHeight;\n    params.shadowVolume = corridorGeometry._shadowVolume;\n    params.offsetAttribute = corridorGeometry._offsetAttribute;\n    attr = computePositionsExtruded(params, vertexFormat);\n  } else {\n    var computedPositions = CorridorGeometryLibrary.computePositions(params);\n    attr = combine(computedPositions, vertexFormat, ellipsoid);\n    attr.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n      attr.attributes.position.values,\n      height,\n      ellipsoid\n    );\n\n    if (defined(corridorGeometry._offsetAttribute)) {\n      var applyOffsetValue =\n        corridorGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      var length = attr.attributes.position.values.length;\n      var applyOffset = new Uint8Array(length / 3);\n      arrayFill(applyOffset, applyOffsetValue);\n      attr.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n  }\n  var attributes = attr.attributes;\n  var boundingSphere = BoundingSphere.fromVertices(\n    attributes.position.values,\n    undefined,\n    3\n  );\n  if (!vertexFormat.position) {\n    attr.attributes.position.values = undefined;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: attr.indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: corridorGeometry._offsetAttribute,\n  });\n};\n\n/**\n * @private\n */\nCorridorGeometry.createShadowVolume = function (\n  corridorGeometry,\n  minHeightFunc,\n  maxHeightFunc\n) {\n  var granularity = corridorGeometry._granularity;\n  var ellipsoid = corridorGeometry._ellipsoid;\n\n  var minHeight = minHeightFunc(granularity, ellipsoid);\n  var maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n  return new CorridorGeometry({\n    positions: corridorGeometry._positions,\n    width: corridorGeometry._width,\n    cornerType: corridorGeometry._cornerType,\n    ellipsoid: ellipsoid,\n    granularity: granularity,\n    extrudedHeight: minHeight,\n    height: maxHeight,\n    vertexFormat: VertexFormat.POSITION_ONLY,\n    shadowVolume: true,\n  });\n};\n\nObject.defineProperties(CorridorGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function () {\n      if (!defined(this._rectangle)) {\n        this._rectangle = computeRectangle(\n          this._positions,\n          this._ellipsoid,\n          this._width,\n          this._cornerType\n        );\n      }\n      return this._rectangle;\n    },\n  },\n  /**\n   * For remapping texture coordinates when rendering CorridorGeometries as GroundPrimitives.\n   *\n   * Corridors don't support stRotation,\n   * so just return the corners of the original system.\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function () {\n      return [0, 0, 0, 1, 1, 0];\n    },\n  },\n});\nexport default CorridorGeometry;\n"]},"metadata":{},"sourceType":"module"}