{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport getStringFromTypedArray from \"../Core/getStringFromTypedArray.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport when from \"../ThirdParty/when.js\";\nimport Cesium3DTileBatchTable from \"./Cesium3DTileBatchTable.js\";\nimport Cesium3DTileFeatureTable from \"./Cesium3DTileFeatureTable.js\";\nimport Vector3DTilePoints from \"./Vector3DTilePoints.js\";\nimport Vector3DTilePolygons from \"./Vector3DTilePolygons.js\";\nimport Vector3DTilePolylines from \"./Vector3DTilePolylines.js\";\n/**\n * Represents the contents of a\n * {@link https://github.com/CesiumGS/3d-tiles/tree/3d-tiles-next/TileFormats/VectorData|Vector}\n * tile in a {@link https://github.com/CesiumGS/3d-tiles/tree/master/specification|3D Tiles} tileset.\n * <p>\n * Implements the {@link Cesium3DTileContent} interface.\n * </p>\n *\n * @alias Vector3DTileContent\n * @constructor\n *\n * @private\n */\n\nfunction Vector3DTileContent(tileset, tile, resource, arrayBuffer, byteOffset) {\n  this._tileset = tileset;\n  this._tile = tile;\n  this._resource = resource;\n  this._polygons = undefined;\n  this._polylines = undefined;\n  this._points = undefined;\n  this._contentReadyPromise = undefined;\n  this._readyPromise = when.defer();\n  this._batchTable = undefined;\n  this._features = undefined;\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.\n   */\n\n  this.featurePropertiesDirty = false;\n  initialize(this, arrayBuffer, byteOffset);\n}\n\nObject.defineProperties(Vector3DTileContent.prototype, {\n  featuresLength: {\n    get: function () {\n      return defined(this._batchTable) ? this._batchTable.featuresLength : 0;\n    }\n  },\n  pointsLength: {\n    get: function () {\n      if (defined(this._points)) {\n        return this._points.pointsLength;\n      }\n\n      return 0;\n    }\n  },\n  trianglesLength: {\n    get: function () {\n      var trianglesLength = 0;\n\n      if (defined(this._polygons)) {\n        trianglesLength += this._polygons.trianglesLength;\n      }\n\n      if (defined(this._polylines)) {\n        trianglesLength += this._polylines.trianglesLength;\n      }\n\n      return trianglesLength;\n    }\n  },\n  geometryByteLength: {\n    get: function () {\n      var geometryByteLength = 0;\n\n      if (defined(this._polygons)) {\n        geometryByteLength += this._polygons.geometryByteLength;\n      }\n\n      if (defined(this._polylines)) {\n        geometryByteLength += this._polylines.geometryByteLength;\n      }\n\n      return geometryByteLength;\n    }\n  },\n  texturesByteLength: {\n    get: function () {\n      if (defined(this._points)) {\n        return this._points.texturesByteLength;\n      }\n\n      return 0;\n    }\n  },\n  batchTableByteLength: {\n    get: function () {\n      return defined(this._batchTable) ? this._batchTable.memorySizeInBytes : 0;\n    }\n  },\n  innerContents: {\n    get: function () {\n      return undefined;\n    }\n  },\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    }\n  },\n  tileset: {\n    get: function () {\n      return this._tileset;\n    }\n  },\n  tile: {\n    get: function () {\n      return this._tile;\n    }\n  },\n  url: {\n    get: function () {\n      return this._resource.getUrlComponent(true);\n    }\n  },\n  batchTable: {\n    get: function () {\n      return this._batchTable;\n    }\n  }\n});\n\nfunction createColorChangedCallback(content) {\n  return function (batchId, color) {\n    if (defined(content._polygons)) {\n      content._polygons.updateCommands(batchId, color);\n    }\n  };\n}\n\nfunction getBatchIds(featureTableJson, featureTableBinary) {\n  var polygonBatchIds;\n  var polylineBatchIds;\n  var pointBatchIds;\n  var i;\n  var numberOfPolygons = defaultValue(featureTableJson.POLYGONS_LENGTH, 0);\n  var numberOfPolylines = defaultValue(featureTableJson.POLYLINES_LENGTH, 0);\n  var numberOfPoints = defaultValue(featureTableJson.POINTS_LENGTH, 0);\n\n  if (numberOfPolygons > 0 && defined(featureTableJson.POLYGON_BATCH_IDS)) {\n    var polygonBatchIdsByteOffset = featureTableBinary.byteOffset + featureTableJson.POLYGON_BATCH_IDS.byteOffset;\n    polygonBatchIds = new Uint16Array(featureTableBinary.buffer, polygonBatchIdsByteOffset, numberOfPolygons);\n  }\n\n  if (numberOfPolylines > 0 && defined(featureTableJson.POLYLINE_BATCH_IDS)) {\n    var polylineBatchIdsByteOffset = featureTableBinary.byteOffset + featureTableJson.POLYLINE_BATCH_IDS.byteOffset;\n    polylineBatchIds = new Uint16Array(featureTableBinary.buffer, polylineBatchIdsByteOffset, numberOfPolylines);\n  }\n\n  if (numberOfPoints > 0 && defined(featureTableJson.POINT_BATCH_IDS)) {\n    var pointBatchIdsByteOffset = featureTableBinary.byteOffset + featureTableJson.POINT_BATCH_IDS.byteOffset;\n    pointBatchIds = new Uint16Array(featureTableBinary.buffer, pointBatchIdsByteOffset, numberOfPoints);\n  }\n\n  var atLeastOneDefined = defined(polygonBatchIds) || defined(polylineBatchIds) || defined(pointBatchIds);\n  var atLeastOneUndefined = numberOfPolygons > 0 && !defined(polygonBatchIds) || numberOfPolylines > 0 && !defined(polylineBatchIds) || numberOfPoints > 0 && !defined(pointBatchIds);\n\n  if (atLeastOneDefined && atLeastOneUndefined) {\n    throw new RuntimeError(\"If one group of batch ids is defined, then all batch ids must be defined.\");\n  }\n\n  var allUndefinedBatchIds = !defined(polygonBatchIds) && !defined(polylineBatchIds) && !defined(pointBatchIds);\n\n  if (allUndefinedBatchIds) {\n    var id = 0;\n\n    if (!defined(polygonBatchIds) && numberOfPolygons > 0) {\n      polygonBatchIds = new Uint16Array(numberOfPolygons);\n\n      for (i = 0; i < numberOfPolygons; ++i) {\n        polygonBatchIds[i] = id++;\n      }\n    }\n\n    if (!defined(polylineBatchIds) && numberOfPolylines > 0) {\n      polylineBatchIds = new Uint16Array(numberOfPolylines);\n\n      for (i = 0; i < numberOfPolylines; ++i) {\n        polylineBatchIds[i] = id++;\n      }\n    }\n\n    if (!defined(pointBatchIds) && numberOfPoints > 0) {\n      pointBatchIds = new Uint16Array(numberOfPoints);\n\n      for (i = 0; i < numberOfPoints; ++i) {\n        pointBatchIds[i] = id++;\n      }\n    }\n  }\n\n  return {\n    polygons: polygonBatchIds,\n    polylines: polylineBatchIds,\n    points: pointBatchIds\n  };\n}\n\nvar sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\n\nfunction initialize(content, arrayBuffer, byteOffset) {\n  byteOffset = defaultValue(byteOffset, 0);\n  var uint8Array = new Uint8Array(arrayBuffer);\n  var view = new DataView(arrayBuffer);\n  byteOffset += sizeOfUint32; // Skip magic number\n\n  var version = view.getUint32(byteOffset, true);\n\n  if (version !== 1) {\n    throw new RuntimeError(\"Only Vector tile version 1 is supported.  Version \" + version + \" is not.\");\n  }\n\n  byteOffset += sizeOfUint32;\n  var byteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  if (byteLength === 0) {\n    content._readyPromise.resolve(content);\n\n    return;\n  }\n\n  var featureTableJSONByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  if (featureTableJSONByteLength === 0) {\n    throw new RuntimeError(\"Feature table must have a byte length greater than zero\");\n  }\n\n  var featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  var batchTableJSONByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  var batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  var indicesByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  var positionByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  var polylinePositionByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  var pointsPositionByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  var featureTableString = getStringFromTypedArray(uint8Array, byteOffset, featureTableJSONByteLength);\n  var featureTableJson = JSON.parse(featureTableString);\n  byteOffset += featureTableJSONByteLength;\n  var featureTableBinary = new Uint8Array(arrayBuffer, byteOffset, featureTableBinaryByteLength);\n  byteOffset += featureTableBinaryByteLength;\n  var batchTableJson;\n  var batchTableBinary;\n\n  if (batchTableJSONByteLength > 0) {\n    // PERFORMANCE_IDEA: is it possible to allocate this on-demand?  Perhaps keep the\n    // arraybuffer/string compressed in memory and then decompress it when it is first accessed.\n    //\n    // We could also make another request for it, but that would make the property set/get\n    // API async, and would double the number of numbers in some cases.\n    var batchTableString = getStringFromTypedArray(uint8Array, byteOffset, batchTableJSONByteLength);\n    batchTableJson = JSON.parse(batchTableString);\n    byteOffset += batchTableJSONByteLength;\n\n    if (batchTableBinaryByteLength > 0) {\n      // Has a batch table binary\n      batchTableBinary = new Uint8Array(arrayBuffer, byteOffset, batchTableBinaryByteLength); // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n\n      batchTableBinary = new Uint8Array(batchTableBinary);\n      byteOffset += batchTableBinaryByteLength;\n    }\n  }\n\n  var numberOfPolygons = defaultValue(featureTableJson.POLYGONS_LENGTH, 0);\n  var numberOfPolylines = defaultValue(featureTableJson.POLYLINES_LENGTH, 0);\n  var numberOfPoints = defaultValue(featureTableJson.POINTS_LENGTH, 0);\n  var totalPrimitives = numberOfPolygons + numberOfPolylines + numberOfPoints;\n  var batchTable = new Cesium3DTileBatchTable(content, totalPrimitives, batchTableJson, batchTableBinary, createColorChangedCallback(content));\n  content._batchTable = batchTable;\n\n  if (totalPrimitives === 0) {\n    return;\n  }\n\n  var featureTable = new Cesium3DTileFeatureTable(featureTableJson, featureTableBinary);\n  var region = featureTable.getGlobalProperty(\"REGION\");\n\n  if (!defined(region)) {\n    throw new RuntimeError(\"Feature table global property: REGION must be defined\");\n  }\n\n  var rectangle = Rectangle.unpack(region);\n  var minHeight = region[4];\n  var maxHeight = region[5];\n  var modelMatrix = content._tile.computedTransform;\n  var center = featureTable.getGlobalProperty(\"RTC_CENTER\", ComponentDatatype.FLOAT, 3);\n\n  if (defined(center)) {\n    center = Cartesian3.unpack(center);\n    Matrix4.multiplyByPoint(modelMatrix, center, center);\n  } else {\n    center = Rectangle.center(rectangle);\n    center.height = CesiumMath.lerp(minHeight, maxHeight, 0.5);\n    center = Ellipsoid.WGS84.cartographicToCartesian(center);\n  }\n\n  var batchIds = getBatchIds(featureTableJson, featureTableBinary);\n  byteOffset += byteOffset % 4;\n\n  if (numberOfPolygons > 0) {\n    featureTable.featuresLength = numberOfPolygons;\n    var polygonCounts = defaultValue(featureTable.getPropertyArray(\"POLYGON_COUNTS\", ComponentDatatype.UNSIGNED_INT, 1), featureTable.getPropertyArray(\"POLYGON_COUNT\", ComponentDatatype.UNSIGNED_INT, 1) // Workaround for old vector tilesets using the non-plural name\n    );\n\n    if (!defined(polygonCounts)) {\n      throw new RuntimeError(\"Feature table property: POLYGON_COUNTS must be defined when POLYGONS_LENGTH is greater than 0\");\n    }\n\n    var polygonIndexCounts = defaultValue(featureTable.getPropertyArray(\"POLYGON_INDEX_COUNTS\", ComponentDatatype.UNSIGNED_INT, 1), featureTable.getPropertyArray(\"POLYGON_INDEX_COUNT\", ComponentDatatype.UNSIGNED_INT, 1) // Workaround for old vector tilesets using the non-plural name\n    );\n\n    if (!defined(polygonIndexCounts)) {\n      throw new RuntimeError(\"Feature table property: POLYGON_INDEX_COUNTS must be defined when POLYGONS_LENGTH is greater than 0\");\n    } // Use the counts array to determine how many position values we want. If we used the byte length then\n    // zero padding values would be included and cause the delta zig-zag decoding to fail\n\n\n    var numPolygonPositions = polygonCounts.reduce(function (total, count) {\n      return total + count * 2;\n    }, 0);\n    var numPolygonIndices = polygonIndexCounts.reduce(function (total, count) {\n      return total + count;\n    }, 0);\n    var indices = new Uint32Array(arrayBuffer, byteOffset, numPolygonIndices);\n    byteOffset += indicesByteLength;\n    var polygonPositions = new Uint16Array(arrayBuffer, byteOffset, numPolygonPositions);\n    byteOffset += positionByteLength;\n    var polygonMinimumHeights;\n    var polygonMaximumHeights;\n\n    if (defined(featureTableJson.POLYGON_MINIMUM_HEIGHTS) && defined(featureTableJson.POLYGON_MAXIMUM_HEIGHTS)) {\n      polygonMinimumHeights = featureTable.getPropertyArray(\"POLYGON_MINIMUM_HEIGHTS\", ComponentDatatype.FLOAT, 1);\n      polygonMaximumHeights = featureTable.getPropertyArray(\"POLYGON_MAXIMUM_HEIGHTS\", ComponentDatatype.FLOAT, 1);\n    }\n\n    content._polygons = new Vector3DTilePolygons({\n      positions: polygonPositions,\n      counts: polygonCounts,\n      indexCounts: polygonIndexCounts,\n      indices: indices,\n      minimumHeight: minHeight,\n      maximumHeight: maxHeight,\n      polygonMinimumHeights: polygonMinimumHeights,\n      polygonMaximumHeights: polygonMaximumHeights,\n      center: center,\n      rectangle: rectangle,\n      boundingVolume: content.tile.boundingVolume.boundingVolume,\n      batchTable: batchTable,\n      batchIds: batchIds.polygons,\n      modelMatrix: modelMatrix\n    });\n  }\n\n  if (numberOfPolylines > 0) {\n    featureTable.featuresLength = numberOfPolylines;\n    var polylineCounts = defaultValue(featureTable.getPropertyArray(\"POLYLINE_COUNTS\", ComponentDatatype.UNSIGNED_INT, 1), featureTable.getPropertyArray(\"POLYLINE_COUNT\", ComponentDatatype.UNSIGNED_INT, 1) // Workaround for old vector tilesets using the non-plural name\n    );\n\n    if (!defined(polylineCounts)) {\n      throw new RuntimeError(\"Feature table property: POLYLINE_COUNTS must be defined when POLYLINES_LENGTH is greater than 0\");\n    }\n\n    var widths = featureTable.getPropertyArray(\"POLYLINE_WIDTHS\", ComponentDatatype.UNSIGNED_SHORT, 1);\n\n    if (!defined(widths)) {\n      widths = new Uint16Array(numberOfPolylines);\n\n      for (var i = 0; i < numberOfPolylines; ++i) {\n        widths[i] = 2.0;\n      }\n    } // Use the counts array to determine how many position values we want. If we used the byte length then\n    // zero padding values would be included and cause the delta zig-zag decoding to fail\n\n\n    var numPolylinePositions = polylineCounts.reduce(function (total, count) {\n      return total + count * 3;\n    }, 0);\n    var polylinePositions = new Uint16Array(arrayBuffer, byteOffset, numPolylinePositions);\n    byteOffset += polylinePositionByteLength;\n    content._polylines = new Vector3DTilePolylines({\n      positions: polylinePositions,\n      widths: widths,\n      counts: polylineCounts,\n      batchIds: batchIds.polylines,\n      minimumHeight: minHeight,\n      maximumHeight: maxHeight,\n      center: center,\n      rectangle: rectangle,\n      boundingVolume: content.tile.boundingVolume.boundingVolume,\n      batchTable: batchTable\n    });\n  }\n\n  if (numberOfPoints > 0) {\n    var pointPositions = new Uint16Array(arrayBuffer, byteOffset, numberOfPoints * 3);\n    byteOffset += pointsPositionByteLength;\n    content._points = new Vector3DTilePoints({\n      positions: pointPositions,\n      batchIds: batchIds.points,\n      minimumHeight: minHeight,\n      maximumHeight: maxHeight,\n      rectangle: rectangle,\n      batchTable: batchTable\n    });\n  }\n}\n\nfunction createFeatures(content) {\n  var featuresLength = content.featuresLength;\n\n  if (!defined(content._features) && featuresLength > 0) {\n    var features = new Array(featuresLength);\n\n    if (defined(content._polygons)) {\n      content._polygons.createFeatures(content, features);\n    }\n\n    if (defined(content._polylines)) {\n      content._polylines.createFeatures(content, features);\n    }\n\n    if (defined(content._points)) {\n      content._points.createFeatures(content, features);\n    }\n\n    content._features = features;\n  }\n}\n\nVector3DTileContent.prototype.hasProperty = function (batchId, name) {\n  return this._batchTable.hasProperty(batchId, name);\n};\n\nVector3DTileContent.prototype.getFeature = function (batchId) {\n  //>>includeStart('debug', pragmas.debug);\n  var featuresLength = this.featuresLength;\n\n  if (!defined(batchId) || batchId < 0 || batchId >= featuresLength) {\n    throw new DeveloperError(\"batchId is required and between zero and featuresLength - 1 (\" + (featuresLength - 1) + \").\");\n  } //>>includeEnd('debug');\n\n\n  createFeatures(this);\n  return this._features[batchId];\n};\n\nVector3DTileContent.prototype.applyDebugSettings = function (enabled, color) {\n  if (defined(this._polygons)) {\n    this._polygons.applyDebugSettings(enabled, color);\n  }\n\n  if (defined(this._polylines)) {\n    this._polylines.applyDebugSettings(enabled, color);\n  }\n\n  if (defined(this._points)) {\n    this._points.applyDebugSettings(enabled, color);\n  }\n};\n\nVector3DTileContent.prototype.applyStyle = function (style) {\n  createFeatures(this);\n\n  if (defined(this._polygons)) {\n    this._polygons.applyStyle(style, this._features);\n  }\n\n  if (defined(this._polylines)) {\n    this._polylines.applyStyle(style, this._features);\n  }\n\n  if (defined(this._points)) {\n    this._points.applyStyle(style, this._features);\n  }\n};\n\nVector3DTileContent.prototype.update = function (tileset, frameState) {\n  var ready = true;\n\n  if (defined(this._polygons)) {\n    this._polygons.classificationType = this._tileset.classificationType;\n    this._polygons.debugWireframe = this._tileset.debugWireframe;\n\n    this._polygons.update(frameState);\n\n    ready = ready && this._polygons._ready;\n  }\n\n  if (defined(this._polylines)) {\n    this._polylines.update(frameState);\n\n    ready = ready && this._polylines._ready;\n  }\n\n  if (defined(this._points)) {\n    this._points.update(frameState);\n\n    ready = ready && this._points._ready;\n  }\n\n  if (defined(this._batchTable) && ready) {\n    this._batchTable.update(tileset, frameState);\n  }\n\n  if (!defined(this._contentReadyPromise)) {\n    var pointsPromise = defined(this._points) ? this._points.readyPromise : undefined;\n    var polygonPromise = defined(this._polygons) ? this._polygons.readyPromise : undefined;\n    var polylinePromise = defined(this._polylines) ? this._polylines.readyPromise : undefined;\n    var that = this;\n    this._contentReadyPromise = when.all([pointsPromise, polygonPromise, polylinePromise]).then(function () {\n      that._readyPromise.resolve(that);\n    });\n  }\n};\n\nVector3DTileContent.prototype.isDestroyed = function () {\n  return false;\n};\n\nVector3DTileContent.prototype.destroy = function () {\n  this._polygons = this._polygons && this._polygons.destroy();\n  this._polylines = this._polylines && this._polylines.destroy();\n  this._points = this._points && this._points.destroy();\n  this._batchTable = this._batchTable && this._batchTable.destroy();\n  return destroyObject(this);\n};\n\nexport default Vector3DTileContent;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/Vector3DTileContent.js"],"names":["Cartesian3","defaultValue","defined","destroyObject","DeveloperError","Ellipsoid","getStringFromTypedArray","ComponentDatatype","CesiumMath","Matrix4","Rectangle","RuntimeError","when","Cesium3DTileBatchTable","Cesium3DTileFeatureTable","Vector3DTilePoints","Vector3DTilePolygons","Vector3DTilePolylines","Vector3DTileContent","tileset","tile","resource","arrayBuffer","byteOffset","_tileset","_tile","_resource","_polygons","undefined","_polylines","_points","_contentReadyPromise","_readyPromise","defer","_batchTable","_features","featurePropertiesDirty","initialize","Object","defineProperties","prototype","featuresLength","get","pointsLength","trianglesLength","geometryByteLength","texturesByteLength","batchTableByteLength","memorySizeInBytes","innerContents","readyPromise","promise","url","getUrlComponent","batchTable","createColorChangedCallback","content","batchId","color","updateCommands","getBatchIds","featureTableJson","featureTableBinary","polygonBatchIds","polylineBatchIds","pointBatchIds","i","numberOfPolygons","POLYGONS_LENGTH","numberOfPolylines","POLYLINES_LENGTH","numberOfPoints","POINTS_LENGTH","POLYGON_BATCH_IDS","polygonBatchIdsByteOffset","Uint16Array","buffer","POLYLINE_BATCH_IDS","polylineBatchIdsByteOffset","POINT_BATCH_IDS","pointBatchIdsByteOffset","atLeastOneDefined","atLeastOneUndefined","allUndefinedBatchIds","id","polygons","polylines","points","sizeOfUint32","Uint32Array","BYTES_PER_ELEMENT","uint8Array","Uint8Array","view","DataView","version","getUint32","byteLength","resolve","featureTableJSONByteLength","featureTableBinaryByteLength","batchTableJSONByteLength","batchTableBinaryByteLength","indicesByteLength","positionByteLength","polylinePositionByteLength","pointsPositionByteLength","featureTableString","JSON","parse","batchTableJson","batchTableBinary","batchTableString","totalPrimitives","featureTable","region","getGlobalProperty","rectangle","unpack","minHeight","maxHeight","modelMatrix","computedTransform","center","FLOAT","multiplyByPoint","height","lerp","WGS84","cartographicToCartesian","batchIds","polygonCounts","getPropertyArray","UNSIGNED_INT","polygonIndexCounts","numPolygonPositions","reduce","total","count","numPolygonIndices","indices","polygonPositions","polygonMinimumHeights","polygonMaximumHeights","POLYGON_MINIMUM_HEIGHTS","POLYGON_MAXIMUM_HEIGHTS","positions","counts","indexCounts","minimumHeight","maximumHeight","boundingVolume","polylineCounts","widths","UNSIGNED_SHORT","numPolylinePositions","polylinePositions","pointPositions","createFeatures","features","Array","hasProperty","name","getFeature","applyDebugSettings","enabled","applyStyle","style","update","frameState","ready","classificationType","debugWireframe","_ready","pointsPromise","polygonPromise","polylinePromise","that","all","then","isDestroyed","destroy"],"mappings":"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","sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport getStringFromTypedArray from \"../Core/getStringFromTypedArray.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport when from \"../ThirdParty/when.js\";\nimport Cesium3DTileBatchTable from \"./Cesium3DTileBatchTable.js\";\nimport Cesium3DTileFeatureTable from \"./Cesium3DTileFeatureTable.js\";\nimport Vector3DTilePoints from \"./Vector3DTilePoints.js\";\nimport Vector3DTilePolygons from \"./Vector3DTilePolygons.js\";\nimport Vector3DTilePolylines from \"./Vector3DTilePolylines.js\";\n\n/**\n * Represents the contents of a\n * {@link https://github.com/CesiumGS/3d-tiles/tree/3d-tiles-next/TileFormats/VectorData|Vector}\n * tile in a {@link https://github.com/CesiumGS/3d-tiles/tree/master/specification|3D Tiles} tileset.\n * <p>\n * Implements the {@link Cesium3DTileContent} interface.\n * </p>\n *\n * @alias Vector3DTileContent\n * @constructor\n *\n * @private\n */\nfunction Vector3DTileContent(tileset, tile, resource, arrayBuffer, byteOffset) {\n  this._tileset = tileset;\n  this._tile = tile;\n  this._resource = resource;\n\n  this._polygons = undefined;\n  this._polylines = undefined;\n  this._points = undefined;\n\n  this._contentReadyPromise = undefined;\n  this._readyPromise = when.defer();\n\n  this._batchTable = undefined;\n  this._features = undefined;\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.\n   */\n  this.featurePropertiesDirty = false;\n\n  initialize(this, arrayBuffer, byteOffset);\n}\n\nObject.defineProperties(Vector3DTileContent.prototype, {\n  featuresLength: {\n    get: function () {\n      return defined(this._batchTable) ? this._batchTable.featuresLength : 0;\n    },\n  },\n\n  pointsLength: {\n    get: function () {\n      if (defined(this._points)) {\n        return this._points.pointsLength;\n      }\n      return 0;\n    },\n  },\n\n  trianglesLength: {\n    get: function () {\n      var trianglesLength = 0;\n      if (defined(this._polygons)) {\n        trianglesLength += this._polygons.trianglesLength;\n      }\n      if (defined(this._polylines)) {\n        trianglesLength += this._polylines.trianglesLength;\n      }\n      return trianglesLength;\n    },\n  },\n\n  geometryByteLength: {\n    get: function () {\n      var geometryByteLength = 0;\n      if (defined(this._polygons)) {\n        geometryByteLength += this._polygons.geometryByteLength;\n      }\n      if (defined(this._polylines)) {\n        geometryByteLength += this._polylines.geometryByteLength;\n      }\n      return geometryByteLength;\n    },\n  },\n\n  texturesByteLength: {\n    get: function () {\n      if (defined(this._points)) {\n        return this._points.texturesByteLength;\n      }\n      return 0;\n    },\n  },\n\n  batchTableByteLength: {\n    get: function () {\n      return defined(this._batchTable) ? this._batchTable.memorySizeInBytes : 0;\n    },\n  },\n\n  innerContents: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n\n  tileset: {\n    get: function () {\n      return this._tileset;\n    },\n  },\n\n  tile: {\n    get: function () {\n      return this._tile;\n    },\n  },\n\n  url: {\n    get: function () {\n      return this._resource.getUrlComponent(true);\n    },\n  },\n\n  batchTable: {\n    get: function () {\n      return this._batchTable;\n    },\n  },\n});\n\nfunction createColorChangedCallback(content) {\n  return function (batchId, color) {\n    if (defined(content._polygons)) {\n      content._polygons.updateCommands(batchId, color);\n    }\n  };\n}\n\nfunction getBatchIds(featureTableJson, featureTableBinary) {\n  var polygonBatchIds;\n  var polylineBatchIds;\n  var pointBatchIds;\n  var i;\n\n  var numberOfPolygons = defaultValue(featureTableJson.POLYGONS_LENGTH, 0);\n  var numberOfPolylines = defaultValue(featureTableJson.POLYLINES_LENGTH, 0);\n  var numberOfPoints = defaultValue(featureTableJson.POINTS_LENGTH, 0);\n\n  if (numberOfPolygons > 0 && defined(featureTableJson.POLYGON_BATCH_IDS)) {\n    var polygonBatchIdsByteOffset =\n      featureTableBinary.byteOffset +\n      featureTableJson.POLYGON_BATCH_IDS.byteOffset;\n    polygonBatchIds = new Uint16Array(\n      featureTableBinary.buffer,\n      polygonBatchIdsByteOffset,\n      numberOfPolygons\n    );\n  }\n\n  if (numberOfPolylines > 0 && defined(featureTableJson.POLYLINE_BATCH_IDS)) {\n    var polylineBatchIdsByteOffset =\n      featureTableBinary.byteOffset +\n      featureTableJson.POLYLINE_BATCH_IDS.byteOffset;\n    polylineBatchIds = new Uint16Array(\n      featureTableBinary.buffer,\n      polylineBatchIdsByteOffset,\n      numberOfPolylines\n    );\n  }\n\n  if (numberOfPoints > 0 && defined(featureTableJson.POINT_BATCH_IDS)) {\n    var pointBatchIdsByteOffset =\n      featureTableBinary.byteOffset +\n      featureTableJson.POINT_BATCH_IDS.byteOffset;\n    pointBatchIds = new Uint16Array(\n      featureTableBinary.buffer,\n      pointBatchIdsByteOffset,\n      numberOfPoints\n    );\n  }\n\n  var atLeastOneDefined =\n    defined(polygonBatchIds) ||\n    defined(polylineBatchIds) ||\n    defined(pointBatchIds);\n  var atLeastOneUndefined =\n    (numberOfPolygons > 0 && !defined(polygonBatchIds)) ||\n    (numberOfPolylines > 0 && !defined(polylineBatchIds)) ||\n    (numberOfPoints > 0 && !defined(pointBatchIds));\n\n  if (atLeastOneDefined && atLeastOneUndefined) {\n    throw new RuntimeError(\n      \"If one group of batch ids is defined, then all batch ids must be defined.\"\n    );\n  }\n\n  var allUndefinedBatchIds =\n    !defined(polygonBatchIds) &&\n    !defined(polylineBatchIds) &&\n    !defined(pointBatchIds);\n  if (allUndefinedBatchIds) {\n    var id = 0;\n    if (!defined(polygonBatchIds) && numberOfPolygons > 0) {\n      polygonBatchIds = new Uint16Array(numberOfPolygons);\n      for (i = 0; i < numberOfPolygons; ++i) {\n        polygonBatchIds[i] = id++;\n      }\n    }\n    if (!defined(polylineBatchIds) && numberOfPolylines > 0) {\n      polylineBatchIds = new Uint16Array(numberOfPolylines);\n      for (i = 0; i < numberOfPolylines; ++i) {\n        polylineBatchIds[i] = id++;\n      }\n    }\n    if (!defined(pointBatchIds) && numberOfPoints > 0) {\n      pointBatchIds = new Uint16Array(numberOfPoints);\n      for (i = 0; i < numberOfPoints; ++i) {\n        pointBatchIds[i] = id++;\n      }\n    }\n  }\n\n  return {\n    polygons: polygonBatchIds,\n    polylines: polylineBatchIds,\n    points: pointBatchIds,\n  };\n}\n\nvar sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\n\nfunction initialize(content, arrayBuffer, byteOffset) {\n  byteOffset = defaultValue(byteOffset, 0);\n\n  var uint8Array = new Uint8Array(arrayBuffer);\n  var view = new DataView(arrayBuffer);\n  byteOffset += sizeOfUint32; // Skip magic number\n\n  var version = view.getUint32(byteOffset, true);\n  if (version !== 1) {\n    throw new RuntimeError(\n      \"Only Vector tile version 1 is supported.  Version \" +\n        version +\n        \" is not.\"\n    );\n  }\n  byteOffset += sizeOfUint32;\n\n  var byteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  if (byteLength === 0) {\n    content._readyPromise.resolve(content);\n    return;\n  }\n\n  var featureTableJSONByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  if (featureTableJSONByteLength === 0) {\n    throw new RuntimeError(\n      \"Feature table must have a byte length greater than zero\"\n    );\n  }\n\n  var featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  var batchTableJSONByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  var batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  var indicesByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  var positionByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  var polylinePositionByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  var pointsPositionByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  var featureTableString = getStringFromTypedArray(\n    uint8Array,\n    byteOffset,\n    featureTableJSONByteLength\n  );\n  var featureTableJson = JSON.parse(featureTableString);\n  byteOffset += featureTableJSONByteLength;\n\n  var featureTableBinary = new Uint8Array(\n    arrayBuffer,\n    byteOffset,\n    featureTableBinaryByteLength\n  );\n  byteOffset += featureTableBinaryByteLength;\n\n  var batchTableJson;\n  var batchTableBinary;\n  if (batchTableJSONByteLength > 0) {\n    // PERFORMANCE_IDEA: is it possible to allocate this on-demand?  Perhaps keep the\n    // arraybuffer/string compressed in memory and then decompress it when it is first accessed.\n    //\n    // We could also make another request for it, but that would make the property set/get\n    // API async, and would double the number of numbers in some cases.\n    var batchTableString = getStringFromTypedArray(\n      uint8Array,\n      byteOffset,\n      batchTableJSONByteLength\n    );\n    batchTableJson = JSON.parse(batchTableString);\n    byteOffset += batchTableJSONByteLength;\n\n    if (batchTableBinaryByteLength > 0) {\n      // Has a batch table binary\n      batchTableBinary = new Uint8Array(\n        arrayBuffer,\n        byteOffset,\n        batchTableBinaryByteLength\n      );\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n      byteOffset += batchTableBinaryByteLength;\n    }\n  }\n\n  var numberOfPolygons = defaultValue(featureTableJson.POLYGONS_LENGTH, 0);\n  var numberOfPolylines = defaultValue(featureTableJson.POLYLINES_LENGTH, 0);\n  var numberOfPoints = defaultValue(featureTableJson.POINTS_LENGTH, 0);\n  var totalPrimitives = numberOfPolygons + numberOfPolylines + numberOfPoints;\n\n  var batchTable = new Cesium3DTileBatchTable(\n    content,\n    totalPrimitives,\n    batchTableJson,\n    batchTableBinary,\n    createColorChangedCallback(content)\n  );\n  content._batchTable = batchTable;\n\n  if (totalPrimitives === 0) {\n    return;\n  }\n\n  var featureTable = new Cesium3DTileFeatureTable(\n    featureTableJson,\n    featureTableBinary\n  );\n  var region = featureTable.getGlobalProperty(\"REGION\");\n  if (!defined(region)) {\n    throw new RuntimeError(\n      \"Feature table global property: REGION must be defined\"\n    );\n  }\n  var rectangle = Rectangle.unpack(region);\n  var minHeight = region[4];\n  var maxHeight = region[5];\n\n  var modelMatrix = content._tile.computedTransform;\n\n  var center = featureTable.getGlobalProperty(\n    \"RTC_CENTER\",\n    ComponentDatatype.FLOAT,\n    3\n  );\n  if (defined(center)) {\n    center = Cartesian3.unpack(center);\n    Matrix4.multiplyByPoint(modelMatrix, center, center);\n  } else {\n    center = Rectangle.center(rectangle);\n    center.height = CesiumMath.lerp(minHeight, maxHeight, 0.5);\n    center = Ellipsoid.WGS84.cartographicToCartesian(center);\n  }\n\n  var batchIds = getBatchIds(featureTableJson, featureTableBinary);\n  byteOffset += byteOffset % 4;\n\n  if (numberOfPolygons > 0) {\n    featureTable.featuresLength = numberOfPolygons;\n\n    var polygonCounts = defaultValue(\n      featureTable.getPropertyArray(\n        \"POLYGON_COUNTS\",\n        ComponentDatatype.UNSIGNED_INT,\n        1\n      ),\n      featureTable.getPropertyArray(\n        \"POLYGON_COUNT\",\n        ComponentDatatype.UNSIGNED_INT,\n        1\n      ) // Workaround for old vector tilesets using the non-plural name\n    );\n\n    if (!defined(polygonCounts)) {\n      throw new RuntimeError(\n        \"Feature table property: POLYGON_COUNTS must be defined when POLYGONS_LENGTH is greater than 0\"\n      );\n    }\n\n    var polygonIndexCounts = defaultValue(\n      featureTable.getPropertyArray(\n        \"POLYGON_INDEX_COUNTS\",\n        ComponentDatatype.UNSIGNED_INT,\n        1\n      ),\n      featureTable.getPropertyArray(\n        \"POLYGON_INDEX_COUNT\",\n        ComponentDatatype.UNSIGNED_INT,\n        1\n      ) // Workaround for old vector tilesets using the non-plural name\n    );\n\n    if (!defined(polygonIndexCounts)) {\n      throw new RuntimeError(\n        \"Feature table property: POLYGON_INDEX_COUNTS must be defined when POLYGONS_LENGTH is greater than 0\"\n      );\n    }\n\n    // Use the counts array to determine how many position values we want. If we used the byte length then\n    // zero padding values would be included and cause the delta zig-zag decoding to fail\n    var numPolygonPositions = polygonCounts.reduce(function (total, count) {\n      return total + count * 2;\n    }, 0);\n\n    var numPolygonIndices = polygonIndexCounts.reduce(function (total, count) {\n      return total + count;\n    }, 0);\n\n    var indices = new Uint32Array(arrayBuffer, byteOffset, numPolygonIndices);\n    byteOffset += indicesByteLength;\n\n    var polygonPositions = new Uint16Array(\n      arrayBuffer,\n      byteOffset,\n      numPolygonPositions\n    );\n    byteOffset += positionByteLength;\n\n    var polygonMinimumHeights;\n    var polygonMaximumHeights;\n    if (\n      defined(featureTableJson.POLYGON_MINIMUM_HEIGHTS) &&\n      defined(featureTableJson.POLYGON_MAXIMUM_HEIGHTS)\n    ) {\n      polygonMinimumHeights = featureTable.getPropertyArray(\n        \"POLYGON_MINIMUM_HEIGHTS\",\n        ComponentDatatype.FLOAT,\n        1\n      );\n      polygonMaximumHeights = featureTable.getPropertyArray(\n        \"POLYGON_MAXIMUM_HEIGHTS\",\n        ComponentDatatype.FLOAT,\n        1\n      );\n    }\n\n    content._polygons = new Vector3DTilePolygons({\n      positions: polygonPositions,\n      counts: polygonCounts,\n      indexCounts: polygonIndexCounts,\n      indices: indices,\n      minimumHeight: minHeight,\n      maximumHeight: maxHeight,\n      polygonMinimumHeights: polygonMinimumHeights,\n      polygonMaximumHeights: polygonMaximumHeights,\n      center: center,\n      rectangle: rectangle,\n      boundingVolume: content.tile.boundingVolume.boundingVolume,\n      batchTable: batchTable,\n      batchIds: batchIds.polygons,\n      modelMatrix: modelMatrix,\n    });\n  }\n\n  if (numberOfPolylines > 0) {\n    featureTable.featuresLength = numberOfPolylines;\n\n    var polylineCounts = defaultValue(\n      featureTable.getPropertyArray(\n        \"POLYLINE_COUNTS\",\n        ComponentDatatype.UNSIGNED_INT,\n        1\n      ),\n      featureTable.getPropertyArray(\n        \"POLYLINE_COUNT\",\n        ComponentDatatype.UNSIGNED_INT,\n        1\n      ) // Workaround for old vector tilesets using the non-plural name\n    );\n\n    if (!defined(polylineCounts)) {\n      throw new RuntimeError(\n        \"Feature table property: POLYLINE_COUNTS must be defined when POLYLINES_LENGTH is greater than 0\"\n      );\n    }\n\n    var widths = featureTable.getPropertyArray(\n      \"POLYLINE_WIDTHS\",\n      ComponentDatatype.UNSIGNED_SHORT,\n      1\n    );\n    if (!defined(widths)) {\n      widths = new Uint16Array(numberOfPolylines);\n      for (var i = 0; i < numberOfPolylines; ++i) {\n        widths[i] = 2.0;\n      }\n    }\n\n    // Use the counts array to determine how many position values we want. If we used the byte length then\n    // zero padding values would be included and cause the delta zig-zag decoding to fail\n    var numPolylinePositions = polylineCounts.reduce(function (total, count) {\n      return total + count * 3;\n    }, 0);\n    var polylinePositions = new Uint16Array(\n      arrayBuffer,\n      byteOffset,\n      numPolylinePositions\n    );\n    byteOffset += polylinePositionByteLength;\n\n    content._polylines = new Vector3DTilePolylines({\n      positions: polylinePositions,\n      widths: widths,\n      counts: polylineCounts,\n      batchIds: batchIds.polylines,\n      minimumHeight: minHeight,\n      maximumHeight: maxHeight,\n      center: center,\n      rectangle: rectangle,\n      boundingVolume: content.tile.boundingVolume.boundingVolume,\n      batchTable: batchTable,\n    });\n  }\n\n  if (numberOfPoints > 0) {\n    var pointPositions = new Uint16Array(\n      arrayBuffer,\n      byteOffset,\n      numberOfPoints * 3\n    );\n    byteOffset += pointsPositionByteLength;\n    content._points = new Vector3DTilePoints({\n      positions: pointPositions,\n      batchIds: batchIds.points,\n      minimumHeight: minHeight,\n      maximumHeight: maxHeight,\n      rectangle: rectangle,\n      batchTable: batchTable,\n    });\n  }\n}\n\nfunction createFeatures(content) {\n  var featuresLength = content.featuresLength;\n  if (!defined(content._features) && featuresLength > 0) {\n    var features = new Array(featuresLength);\n\n    if (defined(content._polygons)) {\n      content._polygons.createFeatures(content, features);\n    }\n    if (defined(content._polylines)) {\n      content._polylines.createFeatures(content, features);\n    }\n    if (defined(content._points)) {\n      content._points.createFeatures(content, features);\n    }\n    content._features = features;\n  }\n}\n\nVector3DTileContent.prototype.hasProperty = function (batchId, name) {\n  return this._batchTable.hasProperty(batchId, name);\n};\n\nVector3DTileContent.prototype.getFeature = function (batchId) {\n  //>>includeStart('debug', pragmas.debug);\n  var featuresLength = this.featuresLength;\n  if (!defined(batchId) || batchId < 0 || batchId >= featuresLength) {\n    throw new DeveloperError(\n      \"batchId is required and between zero and featuresLength - 1 (\" +\n        (featuresLength - 1) +\n        \").\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  createFeatures(this);\n  return this._features[batchId];\n};\n\nVector3DTileContent.prototype.applyDebugSettings = function (enabled, color) {\n  if (defined(this._polygons)) {\n    this._polygons.applyDebugSettings(enabled, color);\n  }\n  if (defined(this._polylines)) {\n    this._polylines.applyDebugSettings(enabled, color);\n  }\n  if (defined(this._points)) {\n    this._points.applyDebugSettings(enabled, color);\n  }\n};\n\nVector3DTileContent.prototype.applyStyle = function (style) {\n  createFeatures(this);\n  if (defined(this._polygons)) {\n    this._polygons.applyStyle(style, this._features);\n  }\n  if (defined(this._polylines)) {\n    this._polylines.applyStyle(style, this._features);\n  }\n  if (defined(this._points)) {\n    this._points.applyStyle(style, this._features);\n  }\n};\n\nVector3DTileContent.prototype.update = function (tileset, frameState) {\n  var ready = true;\n  if (defined(this._polygons)) {\n    this._polygons.classificationType = this._tileset.classificationType;\n    this._polygons.debugWireframe = this._tileset.debugWireframe;\n    this._polygons.update(frameState);\n    ready = ready && this._polygons._ready;\n  }\n  if (defined(this._polylines)) {\n    this._polylines.update(frameState);\n    ready = ready && this._polylines._ready;\n  }\n  if (defined(this._points)) {\n    this._points.update(frameState);\n    ready = ready && this._points._ready;\n  }\n  if (defined(this._batchTable) && ready) {\n    this._batchTable.update(tileset, frameState);\n  }\n\n  if (!defined(this._contentReadyPromise)) {\n    var pointsPromise = defined(this._points)\n      ? this._points.readyPromise\n      : undefined;\n    var polygonPromise = defined(this._polygons)\n      ? this._polygons.readyPromise\n      : undefined;\n    var polylinePromise = defined(this._polylines)\n      ? this._polylines.readyPromise\n      : undefined;\n\n    var that = this;\n    this._contentReadyPromise = when\n      .all([pointsPromise, polygonPromise, polylinePromise])\n      .then(function () {\n        that._readyPromise.resolve(that);\n      });\n  }\n};\n\nVector3DTileContent.prototype.isDestroyed = function () {\n  return false;\n};\n\nVector3DTileContent.prototype.destroy = function () {\n  this._polygons = this._polygons && this._polygons.destroy();\n  this._polylines = this._polylines && this._polylines.destroy();\n  this._points = this._points && this._points.destroy();\n  this._batchTable = this._batchTable && this._batchTable.destroy();\n  return destroyObject(this);\n};\nexport default Vector3DTileContent;\n"]},"metadata":{},"sourceType":"module"}