{"ast":null,"code":"import when from \"../ThirdParty/when.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport EarthOrientationParameters from \"./EarthOrientationParameters.js\";\nimport EarthOrientationParametersSample from \"./EarthOrientationParametersSample.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport HeadingPitchRoll from \"./HeadingPitchRoll.js\";\nimport Iau2006XysData from \"./Iau2006XysData.js\";\nimport Iau2006XysSample from \"./Iau2006XysSample.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport TimeConstants from \"./TimeConstants.js\";\n/**\n * Contains functions for transforming positions to various reference frames.\n *\n * @exports Transforms\n * @namespace\n */\n\nvar Transforms = {};\nvar vectorProductLocalFrame = {\n  up: {\n    south: \"east\",\n    north: \"west\",\n    west: \"south\",\n    east: \"north\"\n  },\n  down: {\n    south: \"west\",\n    north: \"east\",\n    west: \"north\",\n    east: \"south\"\n  },\n  south: {\n    up: \"west\",\n    down: \"east\",\n    west: \"down\",\n    east: \"up\"\n  },\n  north: {\n    up: \"east\",\n    down: \"west\",\n    west: \"up\",\n    east: \"down\"\n  },\n  west: {\n    up: \"north\",\n    down: \"south\",\n    north: \"down\",\n    south: \"up\"\n  },\n  east: {\n    up: \"south\",\n    down: \"north\",\n    north: \"up\",\n    south: \"down\"\n  }\n};\nvar degeneratePositionLocalFrame = {\n  north: [-1, 0, 0],\n  east: [0, 1, 0],\n  up: [0, 0, 1],\n  south: [1, 0, 0],\n  west: [0, -1, 0],\n  down: [0, 0, -1]\n};\nvar localFrameToFixedFrameCache = {};\nvar scratchCalculateCartesian = {\n  east: new Cartesian3(),\n  north: new Cartesian3(),\n  up: new Cartesian3(),\n  west: new Cartesian3(),\n  south: new Cartesian3(),\n  down: new Cartesian3()\n};\nvar scratchFirstCartesian = new Cartesian3();\nvar scratchSecondCartesian = new Cartesian3();\nvar scratchThirdCartesian = new Cartesian3();\n/**\n * Generates a function that computes a 4x4 transformation matrix from a reference frame\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * @param  {String} firstAxis  name of the first axis of the local reference frame. Must be\n *  'east', 'north', 'up', 'west', 'south' or 'down'.\n * @param  {String} secondAxis  name of the second axis of the local reference frame. Must be\n *  'east', 'north', 'up', 'west', 'south' or 'down'.\n * @return {localFrameToFixedFrameGenerator~resultat} The function that will computes a\n * 4x4 transformation matrix from a reference frame, with first axis and second axis compliant with the parameters,\n */\n\nTransforms.localFrameToFixedFrameGenerator = function (firstAxis, secondAxis) {\n  if (!vectorProductLocalFrame.hasOwnProperty(firstAxis) || !vectorProductLocalFrame[firstAxis].hasOwnProperty(secondAxis)) {\n    throw new DeveloperError(\"firstAxis and secondAxis must be east, north, up, west, south or down.\");\n  }\n\n  var thirdAxis = vectorProductLocalFrame[firstAxis][secondAxis];\n  /**\n   * Computes a 4x4 transformation matrix from a reference frame\n   * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n   * @callback Transforms~LocalFrameToFixedFrame\n   * @param {Cartesian3} origin The center point of the local reference frame.\n   * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n   * @param {Matrix4} [result] The object onto which to store the result.\n   * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n   */\n\n  var resultat;\n  var hashAxis = firstAxis + secondAxis;\n\n  if (defined(localFrameToFixedFrameCache[hashAxis])) {\n    resultat = localFrameToFixedFrameCache[hashAxis];\n  } else {\n    resultat = function (origin, ellipsoid, result) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(origin)) {\n        throw new DeveloperError(\"origin is required.\");\n      } //>>includeEnd('debug');\n\n\n      if (!defined(result)) {\n        result = new Matrix4();\n      }\n\n      if (Cartesian3.equalsEpsilon(origin, Cartesian3.ZERO, CesiumMath.EPSILON14)) {\n        // If x, y, and z are zero, use the degenerate local frame, which is a special case\n        Cartesian3.unpack(degeneratePositionLocalFrame[firstAxis], 0, scratchFirstCartesian);\n        Cartesian3.unpack(degeneratePositionLocalFrame[secondAxis], 0, scratchSecondCartesian);\n        Cartesian3.unpack(degeneratePositionLocalFrame[thirdAxis], 0, scratchThirdCartesian);\n      } else if (CesiumMath.equalsEpsilon(origin.x, 0.0, CesiumMath.EPSILON14) && CesiumMath.equalsEpsilon(origin.y, 0.0, CesiumMath.EPSILON14)) {\n        // If x and y are zero, assume origin is at a pole, which is a special case.\n        var sign = CesiumMath.sign(origin.z);\n        Cartesian3.unpack(degeneratePositionLocalFrame[firstAxis], 0, scratchFirstCartesian);\n\n        if (firstAxis !== \"east\" && firstAxis !== \"west\") {\n          Cartesian3.multiplyByScalar(scratchFirstCartesian, sign, scratchFirstCartesian);\n        }\n\n        Cartesian3.unpack(degeneratePositionLocalFrame[secondAxis], 0, scratchSecondCartesian);\n\n        if (secondAxis !== \"east\" && secondAxis !== \"west\") {\n          Cartesian3.multiplyByScalar(scratchSecondCartesian, sign, scratchSecondCartesian);\n        }\n\n        Cartesian3.unpack(degeneratePositionLocalFrame[thirdAxis], 0, scratchThirdCartesian);\n\n        if (thirdAxis !== \"east\" && thirdAxis !== \"west\") {\n          Cartesian3.multiplyByScalar(scratchThirdCartesian, sign, scratchThirdCartesian);\n        }\n      } else {\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n        ellipsoid.geodeticSurfaceNormal(origin, scratchCalculateCartesian.up);\n        var up = scratchCalculateCartesian.up;\n        var east = scratchCalculateCartesian.east;\n        east.x = -origin.y;\n        east.y = origin.x;\n        east.z = 0.0;\n        Cartesian3.normalize(east, scratchCalculateCartesian.east);\n        Cartesian3.cross(up, east, scratchCalculateCartesian.north);\n        Cartesian3.multiplyByScalar(scratchCalculateCartesian.up, -1, scratchCalculateCartesian.down);\n        Cartesian3.multiplyByScalar(scratchCalculateCartesian.east, -1, scratchCalculateCartesian.west);\n        Cartesian3.multiplyByScalar(scratchCalculateCartesian.north, -1, scratchCalculateCartesian.south);\n        scratchFirstCartesian = scratchCalculateCartesian[firstAxis];\n        scratchSecondCartesian = scratchCalculateCartesian[secondAxis];\n        scratchThirdCartesian = scratchCalculateCartesian[thirdAxis];\n      }\n\n      result[0] = scratchFirstCartesian.x;\n      result[1] = scratchFirstCartesian.y;\n      result[2] = scratchFirstCartesian.z;\n      result[3] = 0.0;\n      result[4] = scratchSecondCartesian.x;\n      result[5] = scratchSecondCartesian.y;\n      result[6] = scratchSecondCartesian.z;\n      result[7] = 0.0;\n      result[8] = scratchThirdCartesian.x;\n      result[9] = scratchThirdCartesian.y;\n      result[10] = scratchThirdCartesian.z;\n      result[11] = 0.0;\n      result[12] = origin.x;\n      result[13] = origin.y;\n      result[14] = origin.z;\n      result[15] = 1.0;\n      return result;\n    };\n\n    localFrameToFixedFrameCache[hashAxis] = resultat;\n  }\n\n  return resultat;\n};\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local east direction.</li>\n * <li>The <code>y</code> axis points in the local north direction.</li>\n * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local east-north-up at cartographic (0.0, 0.0) to Earth's fixed frame.\n * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var transform = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n */\n\n\nTransforms.eastNorthUpToFixedFrame = Transforms.localFrameToFixedFrameGenerator(\"east\", \"north\");\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an north-east-down axes\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local north direction.</li>\n * <li>The <code>y</code> axis points in the local east direction.</li>\n * <li>The <code>z</code> axis points in the opposite direction of the ellipsoid surface normal which passes through the position.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local north-east-down at cartographic (0.0, 0.0) to Earth's fixed frame.\n * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var transform = Cesium.Transforms.northEastDownToFixedFrame(center);\n */\n\nTransforms.northEastDownToFixedFrame = Transforms.localFrameToFixedFrameGenerator(\"north\", \"east\");\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an north-up-east axes\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local north direction.</li>\n * <li>The <code>y</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>\n * <li>The <code>z</code> axis points in the local east direction.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local north-up-east at cartographic (0.0, 0.0) to Earth's fixed frame.\n * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var transform = Cesium.Transforms.northUpEastToFixedFrame(center);\n */\n\nTransforms.northUpEastToFixedFrame = Transforms.localFrameToFixedFrameGenerator(\"north\", \"up\");\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an north-west-up axes\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local north direction.</li>\n * <li>The <code>y</code> axis points in the local west direction.</li>\n * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local north-West-Up at cartographic (0.0, 0.0) to Earth's fixed frame.\n * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var transform = Cesium.Transforms.northWestUpToFixedFrame(center);\n */\n\nTransforms.northWestUpToFixedFrame = Transforms.localFrameToFixedFrameGenerator(\"north\", \"west\");\nvar scratchHPRQuaternion = new Quaternion();\nvar scratchScale = new Cartesian3(1.0, 1.0, 1.0);\nvar scratchHPRMatrix4 = new Matrix4();\n/**\n * Computes a 4x4 transformation matrix from a reference frame with axes computed from the heading-pitch-roll angles\n * centered at the provided origin to the provided ellipsoid's fixed reference frame. Heading is the rotation from the local north\n * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles\n * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.\n *\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {HeadingPitchRoll} headingPitchRoll The heading, pitch, and roll.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Transforms~LocalFrameToFixedFrame} [fixedFrameTransform=Transforms.eastNorthUpToFixedFrame] A 4x4 transformation\n *  matrix from a reference frame to the provided ellipsoid's fixed reference frame\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.\n * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var heading = -Cesium.Math.PI_OVER_TWO;\n * var pitch = Cesium.Math.PI_OVER_FOUR;\n * var roll = 0.0;\n * var hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);\n * var transform = Cesium.Transforms.headingPitchRollToFixedFrame(center, hpr);\n */\n\nTransforms.headingPitchRollToFixedFrame = function (origin, headingPitchRoll, ellipsoid, fixedFrameTransform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"HeadingPitchRoll\", headingPitchRoll); //>>includeEnd('debug');\n\n  fixedFrameTransform = defaultValue(fixedFrameTransform, Transforms.eastNorthUpToFixedFrame);\n  var hprQuaternion = Quaternion.fromHeadingPitchRoll(headingPitchRoll, scratchHPRQuaternion);\n  var hprMatrix = Matrix4.fromTranslationQuaternionRotationScale(Cartesian3.ZERO, hprQuaternion, scratchScale, scratchHPRMatrix4);\n  result = fixedFrameTransform(origin, ellipsoid, result);\n  return Matrix4.multiply(result, hprMatrix, result);\n};\n\nvar scratchENUMatrix4 = new Matrix4();\nvar scratchHPRMatrix3 = new Matrix3();\n/**\n * Computes a quaternion from a reference frame with axes computed from the heading-pitch-roll angles\n * centered at the provided origin. Heading is the rotation from the local north\n * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles\n * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.\n *\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {HeadingPitchRoll} headingPitchRoll The heading, pitch, and roll.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Transforms~LocalFrameToFixedFrame} [fixedFrameTransform=Transforms.eastNorthUpToFixedFrame] A 4x4 transformation\n *  matrix from a reference frame to the provided ellipsoid's fixed reference frame\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if none was provided.\n *\n * @example\n * // Get the quaternion from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.\n * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var heading = -Cesium.Math.PI_OVER_TWO;\n * var pitch = Cesium.Math.PI_OVER_FOUR;\n * var roll = 0.0;\n * var hpr = new HeadingPitchRoll(heading, pitch, roll);\n * var quaternion = Cesium.Transforms.headingPitchRollQuaternion(center, hpr);\n */\n\nTransforms.headingPitchRollQuaternion = function (origin, headingPitchRoll, ellipsoid, fixedFrameTransform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"HeadingPitchRoll\", headingPitchRoll); //>>includeEnd('debug');\n\n  var transform = Transforms.headingPitchRollToFixedFrame(origin, headingPitchRoll, ellipsoid, fixedFrameTransform, scratchENUMatrix4);\n  var rotation = Matrix4.getMatrix3(transform, scratchHPRMatrix3);\n  return Quaternion.fromRotationMatrix(rotation, result);\n};\n\nvar noScale = new Cartesian3(1.0, 1.0, 1.0);\nvar hprCenterScratch = new Cartesian3();\nvar ffScratch = new Matrix4();\nvar hprTransformScratch = new Matrix4();\nvar hprRotationScratch = new Matrix3();\nvar hprQuaternionScratch = new Quaternion();\n/**\n * Computes heading-pitch-roll angles from a transform in a particular reference frame. Heading is the rotation from the local north\n * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles\n * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.\n *\n * @param {Matrix4} transform The transform\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Transforms~LocalFrameToFixedFrame} [fixedFrameTransform=Transforms.eastNorthUpToFixedFrame] A 4x4 transformation\n *  matrix from a reference frame to the provided ellipsoid's fixed reference frame\n * @param {HeadingPitchRoll} [result] The object onto which to store the result.\n * @returns {HeadingPitchRoll} The modified result parameter or a new HeadingPitchRoll instance if none was provided.\n */\n\nTransforms.fixedFrameToHeadingPitchRoll = function (transform, ellipsoid, fixedFrameTransform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"transform\", transform); //>>includeEnd('debug');\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  fixedFrameTransform = defaultValue(fixedFrameTransform, Transforms.eastNorthUpToFixedFrame);\n\n  if (!defined(result)) {\n    result = new HeadingPitchRoll();\n  }\n\n  var center = Matrix4.getTranslation(transform, hprCenterScratch);\n\n  if (Cartesian3.equals(center, Cartesian3.ZERO)) {\n    result.heading = 0;\n    result.pitch = 0;\n    result.roll = 0;\n    return result;\n  }\n\n  var toFixedFrame = Matrix4.inverseTransformation(fixedFrameTransform(center, ellipsoid, ffScratch), ffScratch);\n  var transformCopy = Matrix4.setScale(transform, noScale, hprTransformScratch);\n  transformCopy = Matrix4.setTranslation(transformCopy, Cartesian3.ZERO, transformCopy);\n  toFixedFrame = Matrix4.multiply(toFixedFrame, transformCopy, toFixedFrame);\n  var quaternionRotation = Quaternion.fromRotationMatrix(Matrix4.getMatrix3(toFixedFrame, hprRotationScratch), hprQuaternionScratch);\n  quaternionRotation = Quaternion.normalize(quaternionRotation, quaternionRotation);\n  return HeadingPitchRoll.fromQuaternion(quaternionRotation, result);\n};\n\nvar gmstConstant0 = 6 * 3600 + 41 * 60 + 50.54841;\nvar gmstConstant1 = 8640184.812866;\nvar gmstConstant2 = 0.093104;\nvar gmstConstant3 = -6.2e-6;\nvar rateCoef = 1.1772758384668e-19;\nvar wgs84WRPrecessing = 7.2921158553e-5;\nvar twoPiOverSecondsInDay = CesiumMath.TWO_PI / 86400.0;\nvar dateInUtc = new JulianDate();\n/**\n * Computes a rotation matrix to transform a point or vector from True Equator Mean Equinox (TEME) axes to the\n * pseudo-fixed axes at a given time.  This method treats the UT1 time standard as equivalent to UTC.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.\n *\n * @example\n * //Set the view to the inertial frame.\n * scene.postUpdate.addEventListener(function(scene, time) {\n *    var now = Cesium.JulianDate.now();\n *    var offset = Cesium.Matrix4.multiplyByPoint(camera.transform, camera.position, new Cesium.Cartesian3());\n *    var transform = Cesium.Matrix4.fromRotationTranslation(Cesium.Transforms.computeTemeToPseudoFixedMatrix(now));\n *    var inverseTransform = Cesium.Matrix4.inverseTransformation(transform, new Cesium.Matrix4());\n *    Cesium.Matrix4.multiplyByPoint(inverseTransform, offset, offset);\n *    camera.lookAtTransform(transform, offset);\n * });\n */\n\nTransforms.computeTemeToPseudoFixedMatrix = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(\"date is required.\");\n  } //>>includeEnd('debug');\n  // GMST is actually computed using UT1.  We're using UTC as an approximation of UT1.\n  // We do not want to use the function like convertTaiToUtc in JulianDate because\n  // we explicitly do not want to fail when inside the leap second.\n\n\n  dateInUtc = JulianDate.addSeconds(date, -JulianDate.computeTaiMinusUtc(date), dateInUtc);\n  var utcDayNumber = dateInUtc.dayNumber;\n  var utcSecondsIntoDay = dateInUtc.secondsOfDay;\n  var t;\n  var diffDays = utcDayNumber - 2451545;\n\n  if (utcSecondsIntoDay >= 43200.0) {\n    t = (diffDays + 0.5) / TimeConstants.DAYS_PER_JULIAN_CENTURY;\n  } else {\n    t = (diffDays - 0.5) / TimeConstants.DAYS_PER_JULIAN_CENTURY;\n  }\n\n  var gmst0 = gmstConstant0 + t * (gmstConstant1 + t * (gmstConstant2 + t * gmstConstant3));\n  var angle = gmst0 * twoPiOverSecondsInDay % CesiumMath.TWO_PI;\n  var ratio = wgs84WRPrecessing + rateCoef * (utcDayNumber - 2451545.5);\n  var secondsSinceMidnight = (utcSecondsIntoDay + TimeConstants.SECONDS_PER_DAY * 0.5) % TimeConstants.SECONDS_PER_DAY;\n  var gha = angle + ratio * secondsSinceMidnight;\n  var cosGha = Math.cos(gha);\n  var sinGha = Math.sin(gha);\n\n  if (!defined(result)) {\n    return new Matrix3(cosGha, sinGha, 0.0, -sinGha, cosGha, 0.0, 0.0, 0.0, 1.0);\n  }\n\n  result[0] = cosGha;\n  result[1] = -sinGha;\n  result[2] = 0.0;\n  result[3] = sinGha;\n  result[4] = cosGha;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 1.0;\n  return result;\n};\n/**\n * The source of IAU 2006 XYS data, used for computing the transformation between the\n * Fixed and ICRF axes.\n * @type {Iau2006XysData}\n *\n * @see Transforms.computeIcrfToFixedMatrix\n * @see Transforms.computeFixedToIcrfMatrix\n *\n * @private\n */\n\n\nTransforms.iau2006XysData = new Iau2006XysData();\n/**\n * The source of Earth Orientation Parameters (EOP) data, used for computing the transformation\n * between the Fixed and ICRF axes.  By default, zero values are used for all EOP values,\n * yielding a reasonable but not completely accurate representation of the ICRF axes.\n * @type {EarthOrientationParameters}\n *\n * @see Transforms.computeIcrfToFixedMatrix\n * @see Transforms.computeFixedToIcrfMatrix\n *\n * @private\n */\n\nTransforms.earthOrientationParameters = EarthOrientationParameters.NONE;\nvar ttMinusTai = 32.184;\nvar j2000ttDays = 2451545.0;\n/**\n * Preloads the data necessary to transform between the ICRF and Fixed axes, in either\n * direction, over a given interval.  This function returns a promise that, when resolved,\n * indicates that the preload has completed.\n *\n * @param {TimeInterval} timeInterval The interval to preload.\n * @returns {Promise} A promise that, when resolved, indicates that the preload has completed\n *          and evaluation of the transformation between the fixed and ICRF axes will\n *          no longer return undefined for a time inside the interval.\n *\n *\n * @example\n * var interval = new Cesium.TimeInterval(...);\n * when(Cesium.Transforms.preloadIcrfFixed(interval), function() {\n *     // the data is now loaded\n * });\n *\n * @see Transforms.computeIcrfToFixedMatrix\n * @see Transforms.computeFixedToIcrfMatrix\n * @see when\n */\n\nTransforms.preloadIcrfFixed = function (timeInterval) {\n  var startDayTT = timeInterval.start.dayNumber;\n  var startSecondTT = timeInterval.start.secondsOfDay + ttMinusTai;\n  var stopDayTT = timeInterval.stop.dayNumber;\n  var stopSecondTT = timeInterval.stop.secondsOfDay + ttMinusTai;\n  var xysPromise = Transforms.iau2006XysData.preload(startDayTT, startSecondTT, stopDayTT, stopSecondTT);\n  var eopPromise = Transforms.earthOrientationParameters.getPromiseToLoad();\n  return when.all([xysPromise, eopPromise]);\n};\n/**\n * Computes a rotation matrix to transform a point or vector from the International Celestial\n * Reference Frame (GCRF/ICRF) inertial frame axes to the Earth-Fixed frame axes (ITRF)\n * at a given time.  This function may return undefined if the data necessary to\n * do the transformation is not yet loaded.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is\n *                  not specified, a new instance is created and returned.\n * @returns {Matrix3} The rotation matrix, or undefined if the data necessary to do the\n *                   transformation is not yet loaded.\n *\n *\n * @example\n * scene.postUpdate.addEventListener(function(scene, time) {\n *   // View in ICRF.\n *   var icrfToFixed = Cesium.Transforms.computeIcrfToFixedMatrix(time);\n *   if (Cesium.defined(icrfToFixed)) {\n *     var offset = Cesium.Cartesian3.clone(camera.position);\n *     var transform = Cesium.Matrix4.fromRotationTranslation(icrfToFixed);\n *     camera.lookAtTransform(transform, offset);\n *   }\n * });\n *\n * @see Transforms.preloadIcrfFixed\n */\n\n\nTransforms.computeIcrfToFixedMatrix = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(\"date is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  var fixedToIcrfMtx = Transforms.computeFixedToIcrfMatrix(date, result);\n\n  if (!defined(fixedToIcrfMtx)) {\n    return undefined;\n  }\n\n  return Matrix3.transpose(fixedToIcrfMtx, result);\n};\n\nvar xysScratch = new Iau2006XysSample(0.0, 0.0, 0.0);\nvar eopScratch = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\nvar rotation1Scratch = new Matrix3();\nvar rotation2Scratch = new Matrix3();\n/**\n * Computes a rotation matrix to transform a point or vector from the Earth-Fixed frame axes (ITRF)\n * to the International Celestial Reference Frame (GCRF/ICRF) inertial frame axes\n * at a given time.  This function may return undefined if the data necessary to\n * do the transformation is not yet loaded.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is\n *                  not specified, a new instance is created and returned.\n * @returns {Matrix3} The rotation matrix, or undefined if the data necessary to do the\n *                   transformation is not yet loaded.\n *\n *\n * @example\n * // Transform a point from the ICRF axes to the Fixed axes.\n * var now = Cesium.JulianDate.now();\n * var pointInFixed = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var fixedToIcrf = Cesium.Transforms.computeIcrfToFixedMatrix(now);\n * var pointInInertial = new Cesium.Cartesian3();\n * if (Cesium.defined(fixedToIcrf)) {\n *     pointInInertial = Cesium.Matrix3.multiplyByVector(fixedToIcrf, pointInFixed, pointInInertial);\n * }\n *\n * @see Transforms.preloadIcrfFixed\n */\n\nTransforms.computeFixedToIcrfMatrix = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(\"date is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(result)) {\n    result = new Matrix3();\n  } // Compute pole wander\n\n\n  var eop = Transforms.earthOrientationParameters.compute(date, eopScratch);\n\n  if (!defined(eop)) {\n    return undefined;\n  } // There is no external conversion to Terrestrial Time (TT).\n  // So use International Atomic Time (TAI) and convert using offsets.\n  // Here we are assuming that dayTT and secondTT are positive\n\n\n  var dayTT = date.dayNumber; // It's possible here that secondTT could roll over 86400\n  // This does not seem to affect the precision (unit tests check for this)\n\n  var secondTT = date.secondsOfDay + ttMinusTai;\n  var xys = Transforms.iau2006XysData.computeXysRadians(dayTT, secondTT, xysScratch);\n\n  if (!defined(xys)) {\n    return undefined;\n  }\n\n  var x = xys.x + eop.xPoleOffset;\n  var y = xys.y + eop.yPoleOffset; // Compute XYS rotation\n\n  var a = 1.0 / (1.0 + Math.sqrt(1.0 - x * x - y * y));\n  var rotation1 = rotation1Scratch;\n  rotation1[0] = 1.0 - a * x * x;\n  rotation1[3] = -a * x * y;\n  rotation1[6] = x;\n  rotation1[1] = -a * x * y;\n  rotation1[4] = 1 - a * y * y;\n  rotation1[7] = y;\n  rotation1[2] = -x;\n  rotation1[5] = -y;\n  rotation1[8] = 1 - a * (x * x + y * y);\n  var rotation2 = Matrix3.fromRotationZ(-xys.s, rotation2Scratch);\n  var matrixQ = Matrix3.multiply(rotation1, rotation2, rotation1Scratch); // Similar to TT conversions above\n  // It's possible here that secondTT could roll over 86400\n  // This does not seem to affect the precision (unit tests check for this)\n\n  var dateUt1day = date.dayNumber;\n  var dateUt1sec = date.secondsOfDay - JulianDate.computeTaiMinusUtc(date) + eop.ut1MinusUtc; // Compute Earth rotation angle\n  // The IERS standard for era is\n  //    era = 0.7790572732640 + 1.00273781191135448 * Tu\n  // where\n  //    Tu = JulianDateInUt1 - 2451545.0\n  // However, you get much more precision if you make the following simplification\n  //    era = a + (1 + b) * (JulianDayNumber + FractionOfDay - 2451545)\n  //    era = a + (JulianDayNumber - 2451545) + FractionOfDay + b (JulianDayNumber - 2451545 + FractionOfDay)\n  //    era = a + FractionOfDay + b (JulianDayNumber - 2451545 + FractionOfDay)\n  // since (JulianDayNumber - 2451545) represents an integer number of revolutions which will be discarded anyway.\n\n  var daysSinceJ2000 = dateUt1day - 2451545;\n  var fractionOfDay = dateUt1sec / TimeConstants.SECONDS_PER_DAY;\n  var era = 0.779057273264 + fractionOfDay + 0.00273781191135448 * (daysSinceJ2000 + fractionOfDay);\n  era = era % 1.0 * CesiumMath.TWO_PI;\n  var earthRotation = Matrix3.fromRotationZ(era, rotation2Scratch); // pseudoFixed to ICRF\n\n  var pfToIcrf = Matrix3.multiply(matrixQ, earthRotation, rotation1Scratch); // Compute pole wander matrix\n\n  var cosxp = Math.cos(eop.xPoleWander);\n  var cosyp = Math.cos(eop.yPoleWander);\n  var sinxp = Math.sin(eop.xPoleWander);\n  var sinyp = Math.sin(eop.yPoleWander);\n  var ttt = dayTT - j2000ttDays + secondTT / TimeConstants.SECONDS_PER_DAY;\n  ttt /= 36525.0; // approximate sp value in rad\n\n  var sp = -47.0e-6 * ttt * CesiumMath.RADIANS_PER_DEGREE / 3600.0;\n  var cossp = Math.cos(sp);\n  var sinsp = Math.sin(sp);\n  var fToPfMtx = rotation2Scratch;\n  fToPfMtx[0] = cosxp * cossp;\n  fToPfMtx[1] = cosxp * sinsp;\n  fToPfMtx[2] = sinxp;\n  fToPfMtx[3] = -cosyp * sinsp + sinyp * sinxp * cossp;\n  fToPfMtx[4] = cosyp * cossp + sinyp * sinxp * sinsp;\n  fToPfMtx[5] = -sinyp * cosxp;\n  fToPfMtx[6] = -sinyp * sinsp - cosyp * sinxp * cossp;\n  fToPfMtx[7] = sinyp * cossp - cosyp * sinxp * sinsp;\n  fToPfMtx[8] = cosyp * cosxp;\n  return Matrix3.multiply(pfToIcrf, fToPfMtx, result);\n};\n\nvar pointToWindowCoordinatesTemp = new Cartesian4();\n/**\n * Transform a point from model coordinates to window coordinates.\n *\n * @param {Matrix4} modelViewProjectionMatrix The 4x4 model-view-projection matrix.\n * @param {Matrix4} viewportTransformation The 4x4 viewport transformation.\n * @param {Cartesian3} point The point to transform.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.\n */\n\nTransforms.pointToWindowCoordinates = function (modelViewProjectionMatrix, viewportTransformation, point, result) {\n  result = Transforms.pointToGLWindowCoordinates(modelViewProjectionMatrix, viewportTransformation, point, result);\n  result.y = 2.0 * viewportTransformation[5] - result.y;\n  return result;\n};\n/**\n * @private\n */\n\n\nTransforms.pointToGLWindowCoordinates = function (modelViewProjectionMatrix, viewportTransformation, point, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(modelViewProjectionMatrix)) {\n    throw new DeveloperError(\"modelViewProjectionMatrix is required.\");\n  }\n\n  if (!defined(viewportTransformation)) {\n    throw new DeveloperError(\"viewportTransformation is required.\");\n  }\n\n  if (!defined(point)) {\n    throw new DeveloperError(\"point is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n\n  var tmp = pointToWindowCoordinatesTemp;\n  Matrix4.multiplyByVector(modelViewProjectionMatrix, Cartesian4.fromElements(point.x, point.y, point.z, 1, tmp), tmp);\n  Cartesian4.multiplyByScalar(tmp, 1.0 / tmp.w, tmp);\n  Matrix4.multiplyByVector(viewportTransformation, tmp, tmp);\n  return Cartesian2.fromCartesian4(tmp, result);\n};\n\nvar normalScratch = new Cartesian3();\nvar rightScratch = new Cartesian3();\nvar upScratch = new Cartesian3();\n/**\n * @private\n */\n\nTransforms.rotationMatrixFromPositionVelocity = function (position, velocity, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n\n  if (!defined(velocity)) {\n    throw new DeveloperError(\"velocity is required.\");\n  } //>>includeEnd('debug');\n\n\n  var normal = defaultValue(ellipsoid, Ellipsoid.WGS84).geodeticSurfaceNormal(position, normalScratch);\n  var right = Cartesian3.cross(velocity, normal, rightScratch);\n\n  if (Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)) {\n    right = Cartesian3.clone(Cartesian3.UNIT_X, right);\n  }\n\n  var up = Cartesian3.cross(right, velocity, upScratch);\n  Cartesian3.normalize(up, up);\n  Cartesian3.cross(velocity, up, right);\n  Cartesian3.negate(right, right);\n  Cartesian3.normalize(right, right);\n\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  result[0] = velocity.x;\n  result[1] = velocity.y;\n  result[2] = velocity.z;\n  result[3] = right.x;\n  result[4] = right.y;\n  result[5] = right.z;\n  result[6] = up.x;\n  result[7] = up.y;\n  result[8] = up.z;\n  return result;\n};\n\nvar swizzleMatrix = new Matrix4(0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0);\nvar scratchCartographic = new Cartographic();\nvar scratchCartesian3Projection = new Cartesian3();\nvar scratchCenter = new Cartesian3();\nvar scratchRotation = new Matrix3();\nvar scratchFromENU = new Matrix4();\nvar scratchToENU = new Matrix4();\n/**\n * @private\n */\n\nTransforms.basisTo2D = function (projection, matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(projection)) {\n    throw new DeveloperError(\"projection is required.\");\n  }\n\n  if (!defined(matrix)) {\n    throw new DeveloperError(\"matrix is required.\");\n  }\n\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  } //>>includeEnd('debug');\n\n\n  var rtcCenter = Matrix4.getTranslation(matrix, scratchCenter);\n  var ellipsoid = projection.ellipsoid; // Get the 2D Center\n\n  var cartographic = ellipsoid.cartesianToCartographic(rtcCenter, scratchCartographic);\n  var projectedPosition = projection.project(cartographic, scratchCartesian3Projection);\n  Cartesian3.fromElements(projectedPosition.z, projectedPosition.x, projectedPosition.y, projectedPosition); // Assuming the instance are positioned in WGS84, invert the WGS84 transform to get the local transform and then convert to 2D\n\n  var fromENU = Transforms.eastNorthUpToFixedFrame(rtcCenter, ellipsoid, scratchFromENU);\n  var toENU = Matrix4.inverseTransformation(fromENU, scratchToENU);\n  var rotation = Matrix4.getMatrix3(matrix, scratchRotation);\n  var local = Matrix4.multiplyByMatrix3(toENU, rotation, result);\n  Matrix4.multiply(swizzleMatrix, local, result); // Swap x, y, z for 2D\n\n  Matrix4.setTranslation(result, projectedPosition, result); // Use the projected center\n\n  return result;\n};\n/**\n * @private\n */\n\n\nTransforms.wgs84To2DModelMatrix = function (projection, center, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(projection)) {\n    throw new DeveloperError(\"projection is required.\");\n  }\n\n  if (!defined(center)) {\n    throw new DeveloperError(\"center is required.\");\n  }\n\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  } //>>includeEnd('debug');\n\n\n  var ellipsoid = projection.ellipsoid;\n  var fromENU = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, scratchFromENU);\n  var toENU = Matrix4.inverseTransformation(fromENU, scratchToENU);\n  var cartographic = ellipsoid.cartesianToCartographic(center, scratchCartographic);\n  var projectedPosition = projection.project(cartographic, scratchCartesian3Projection);\n  Cartesian3.fromElements(projectedPosition.z, projectedPosition.x, projectedPosition.y, projectedPosition);\n  var translation = Matrix4.fromTranslation(projectedPosition, scratchFromENU);\n  Matrix4.multiply(swizzleMatrix, toENU, result);\n  Matrix4.multiply(translation, result, result);\n  return result;\n};\n\nexport default Transforms;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/Transforms.js"],"names":["when","Cartesian2","Cartesian3","Cartesian4","Cartographic","Check","defaultValue","defined","DeveloperError","EarthOrientationParameters","EarthOrientationParametersSample","Ellipsoid","HeadingPitchRoll","Iau2006XysData","Iau2006XysSample","JulianDate","CesiumMath","Matrix3","Matrix4","Quaternion","TimeConstants","Transforms","vectorProductLocalFrame","up","south","north","west","east","down","degeneratePositionLocalFrame","localFrameToFixedFrameCache","scratchCalculateCartesian","scratchFirstCartesian","scratchSecondCartesian","scratchThirdCartesian","localFrameToFixedFrameGenerator","firstAxis","secondAxis","hasOwnProperty","thirdAxis","resultat","hashAxis","origin","ellipsoid","result","equalsEpsilon","ZERO","EPSILON14","unpack","x","y","sign","z","multiplyByScalar","WGS84","geodeticSurfaceNormal","normalize","cross","eastNorthUpToFixedFrame","northEastDownToFixedFrame","northUpEastToFixedFrame","northWestUpToFixedFrame","scratchHPRQuaternion","scratchScale","scratchHPRMatrix4","headingPitchRollToFixedFrame","headingPitchRoll","fixedFrameTransform","typeOf","object","hprQuaternion","fromHeadingPitchRoll","hprMatrix","fromTranslationQuaternionRotationScale","multiply","scratchENUMatrix4","scratchHPRMatrix3","headingPitchRollQuaternion","transform","rotation","getMatrix3","fromRotationMatrix","noScale","hprCenterScratch","ffScratch","hprTransformScratch","hprRotationScratch","hprQuaternionScratch","fixedFrameToHeadingPitchRoll","center","getTranslation","equals","heading","pitch","roll","toFixedFrame","inverseTransformation","transformCopy","setScale","setTranslation","quaternionRotation","fromQuaternion","gmstConstant0","gmstConstant1","gmstConstant2","gmstConstant3","rateCoef","wgs84WRPrecessing","twoPiOverSecondsInDay","TWO_PI","dateInUtc","computeTemeToPseudoFixedMatrix","date","addSeconds","computeTaiMinusUtc","utcDayNumber","dayNumber","utcSecondsIntoDay","secondsOfDay","t","diffDays","DAYS_PER_JULIAN_CENTURY","gmst0","angle","ratio","secondsSinceMidnight","SECONDS_PER_DAY","gha","cosGha","Math","cos","sinGha","sin","iau2006XysData","earthOrientationParameters","NONE","ttMinusTai","j2000ttDays","preloadIcrfFixed","timeInterval","startDayTT","start","startSecondTT","stopDayTT","stop","stopSecondTT","xysPromise","preload","eopPromise","getPromiseToLoad","all","computeIcrfToFixedMatrix","fixedToIcrfMtx","computeFixedToIcrfMatrix","undefined","transpose","xysScratch","eopScratch","rotation1Scratch","rotation2Scratch","eop","compute","dayTT","secondTT","xys","computeXysRadians","xPoleOffset","yPoleOffset","a","sqrt","rotation1","rotation2","fromRotationZ","s","matrixQ","dateUt1day","dateUt1sec","ut1MinusUtc","daysSinceJ2000","fractionOfDay","era","earthRotation","pfToIcrf","cosxp","xPoleWander","cosyp","yPoleWander","sinxp","sinyp","ttt","sp","RADIANS_PER_DEGREE","cossp","sinsp","fToPfMtx","pointToWindowCoordinatesTemp","pointToWindowCoordinates","modelViewProjectionMatrix","viewportTransformation","point","pointToGLWindowCoordinates","tmp","multiplyByVector","fromElements","w","fromCartesian4","normalScratch","rightScratch","upScratch","rotationMatrixFromPositionVelocity","position","velocity","normal","right","EPSILON6","clone","UNIT_X","negate","swizzleMatrix","scratchCartographic","scratchCartesian3Projection","scratchCenter","scratchRotation","scratchFromENU","scratchToENU","basisTo2D","projection","matrix","rtcCenter","cartographic","cartesianToCartographic","projectedPosition","project","fromENU","toENU","local","multiplyByMatrix3","wgs84To2DModelMatrix","translation","fromTranslation"],"mappings":"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","sourcesContent":["import when from \"../ThirdParty/when.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport EarthOrientationParameters from \"./EarthOrientationParameters.js\";\nimport EarthOrientationParametersSample from \"./EarthOrientationParametersSample.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport HeadingPitchRoll from \"./HeadingPitchRoll.js\";\nimport Iau2006XysData from \"./Iau2006XysData.js\";\nimport Iau2006XysSample from \"./Iau2006XysSample.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport TimeConstants from \"./TimeConstants.js\";\n\n/**\n * Contains functions for transforming positions to various reference frames.\n *\n * @exports Transforms\n * @namespace\n */\nvar Transforms = {};\n\nvar vectorProductLocalFrame = {\n  up: {\n    south: \"east\",\n    north: \"west\",\n    west: \"south\",\n    east: \"north\",\n  },\n  down: {\n    south: \"west\",\n    north: \"east\",\n    west: \"north\",\n    east: \"south\",\n  },\n  south: {\n    up: \"west\",\n    down: \"east\",\n    west: \"down\",\n    east: \"up\",\n  },\n  north: {\n    up: \"east\",\n    down: \"west\",\n    west: \"up\",\n    east: \"down\",\n  },\n  west: {\n    up: \"north\",\n    down: \"south\",\n    north: \"down\",\n    south: \"up\",\n  },\n  east: {\n    up: \"south\",\n    down: \"north\",\n    north: \"up\",\n    south: \"down\",\n  },\n};\n\nvar degeneratePositionLocalFrame = {\n  north: [-1, 0, 0],\n  east: [0, 1, 0],\n  up: [0, 0, 1],\n  south: [1, 0, 0],\n  west: [0, -1, 0],\n  down: [0, 0, -1],\n};\n\nvar localFrameToFixedFrameCache = {};\n\nvar scratchCalculateCartesian = {\n  east: new Cartesian3(),\n  north: new Cartesian3(),\n  up: new Cartesian3(),\n  west: new Cartesian3(),\n  south: new Cartesian3(),\n  down: new Cartesian3(),\n};\nvar scratchFirstCartesian = new Cartesian3();\nvar scratchSecondCartesian = new Cartesian3();\nvar scratchThirdCartesian = new Cartesian3();\n/**\n * Generates a function that computes a 4x4 transformation matrix from a reference frame\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * @param  {String} firstAxis  name of the first axis of the local reference frame. Must be\n *  'east', 'north', 'up', 'west', 'south' or 'down'.\n * @param  {String} secondAxis  name of the second axis of the local reference frame. Must be\n *  'east', 'north', 'up', 'west', 'south' or 'down'.\n * @return {localFrameToFixedFrameGenerator~resultat} The function that will computes a\n * 4x4 transformation matrix from a reference frame, with first axis and second axis compliant with the parameters,\n */\nTransforms.localFrameToFixedFrameGenerator = function (firstAxis, secondAxis) {\n  if (\n    !vectorProductLocalFrame.hasOwnProperty(firstAxis) ||\n    !vectorProductLocalFrame[firstAxis].hasOwnProperty(secondAxis)\n  ) {\n    throw new DeveloperError(\n      \"firstAxis and secondAxis must be east, north, up, west, south or down.\"\n    );\n  }\n  var thirdAxis = vectorProductLocalFrame[firstAxis][secondAxis];\n\n  /**\n   * Computes a 4x4 transformation matrix from a reference frame\n   * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n   * @callback Transforms~LocalFrameToFixedFrame\n   * @param {Cartesian3} origin The center point of the local reference frame.\n   * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n   * @param {Matrix4} [result] The object onto which to store the result.\n   * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n   */\n  var resultat;\n  var hashAxis = firstAxis + secondAxis;\n  if (defined(localFrameToFixedFrameCache[hashAxis])) {\n    resultat = localFrameToFixedFrameCache[hashAxis];\n  } else {\n    resultat = function (origin, ellipsoid, result) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(origin)) {\n        throw new DeveloperError(\"origin is required.\");\n      }\n      //>>includeEnd('debug');\n      if (!defined(result)) {\n        result = new Matrix4();\n      }\n      if (\n        Cartesian3.equalsEpsilon(origin, Cartesian3.ZERO, CesiumMath.EPSILON14)\n      ) {\n        // If x, y, and z are zero, use the degenerate local frame, which is a special case\n        Cartesian3.unpack(\n          degeneratePositionLocalFrame[firstAxis],\n          0,\n          scratchFirstCartesian\n        );\n        Cartesian3.unpack(\n          degeneratePositionLocalFrame[secondAxis],\n          0,\n          scratchSecondCartesian\n        );\n        Cartesian3.unpack(\n          degeneratePositionLocalFrame[thirdAxis],\n          0,\n          scratchThirdCartesian\n        );\n      } else if (\n        CesiumMath.equalsEpsilon(origin.x, 0.0, CesiumMath.EPSILON14) &&\n        CesiumMath.equalsEpsilon(origin.y, 0.0, CesiumMath.EPSILON14)\n      ) {\n        // If x and y are zero, assume origin is at a pole, which is a special case.\n        var sign = CesiumMath.sign(origin.z);\n\n        Cartesian3.unpack(\n          degeneratePositionLocalFrame[firstAxis],\n          0,\n          scratchFirstCartesian\n        );\n        if (firstAxis !== \"east\" && firstAxis !== \"west\") {\n          Cartesian3.multiplyByScalar(\n            scratchFirstCartesian,\n            sign,\n            scratchFirstCartesian\n          );\n        }\n\n        Cartesian3.unpack(\n          degeneratePositionLocalFrame[secondAxis],\n          0,\n          scratchSecondCartesian\n        );\n        if (secondAxis !== \"east\" && secondAxis !== \"west\") {\n          Cartesian3.multiplyByScalar(\n            scratchSecondCartesian,\n            sign,\n            scratchSecondCartesian\n          );\n        }\n\n        Cartesian3.unpack(\n          degeneratePositionLocalFrame[thirdAxis],\n          0,\n          scratchThirdCartesian\n        );\n        if (thirdAxis !== \"east\" && thirdAxis !== \"west\") {\n          Cartesian3.multiplyByScalar(\n            scratchThirdCartesian,\n            sign,\n            scratchThirdCartesian\n          );\n        }\n      } else {\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n        ellipsoid.geodeticSurfaceNormal(origin, scratchCalculateCartesian.up);\n\n        var up = scratchCalculateCartesian.up;\n        var east = scratchCalculateCartesian.east;\n        east.x = -origin.y;\n        east.y = origin.x;\n        east.z = 0.0;\n        Cartesian3.normalize(east, scratchCalculateCartesian.east);\n        Cartesian3.cross(up, east, scratchCalculateCartesian.north);\n\n        Cartesian3.multiplyByScalar(\n          scratchCalculateCartesian.up,\n          -1,\n          scratchCalculateCartesian.down\n        );\n        Cartesian3.multiplyByScalar(\n          scratchCalculateCartesian.east,\n          -1,\n          scratchCalculateCartesian.west\n        );\n        Cartesian3.multiplyByScalar(\n          scratchCalculateCartesian.north,\n          -1,\n          scratchCalculateCartesian.south\n        );\n\n        scratchFirstCartesian = scratchCalculateCartesian[firstAxis];\n        scratchSecondCartesian = scratchCalculateCartesian[secondAxis];\n        scratchThirdCartesian = scratchCalculateCartesian[thirdAxis];\n      }\n      result[0] = scratchFirstCartesian.x;\n      result[1] = scratchFirstCartesian.y;\n      result[2] = scratchFirstCartesian.z;\n      result[3] = 0.0;\n      result[4] = scratchSecondCartesian.x;\n      result[5] = scratchSecondCartesian.y;\n      result[6] = scratchSecondCartesian.z;\n      result[7] = 0.0;\n      result[8] = scratchThirdCartesian.x;\n      result[9] = scratchThirdCartesian.y;\n      result[10] = scratchThirdCartesian.z;\n      result[11] = 0.0;\n      result[12] = origin.x;\n      result[13] = origin.y;\n      result[14] = origin.z;\n      result[15] = 1.0;\n      return result;\n    };\n    localFrameToFixedFrameCache[hashAxis] = resultat;\n  }\n  return resultat;\n};\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local east direction.</li>\n * <li>The <code>y</code> axis points in the local north direction.</li>\n * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local east-north-up at cartographic (0.0, 0.0) to Earth's fixed frame.\n * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var transform = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n */\nTransforms.eastNorthUpToFixedFrame = Transforms.localFrameToFixedFrameGenerator(\n  \"east\",\n  \"north\"\n);\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an north-east-down axes\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local north direction.</li>\n * <li>The <code>y</code> axis points in the local east direction.</li>\n * <li>The <code>z</code> axis points in the opposite direction of the ellipsoid surface normal which passes through the position.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local north-east-down at cartographic (0.0, 0.0) to Earth's fixed frame.\n * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var transform = Cesium.Transforms.northEastDownToFixedFrame(center);\n */\nTransforms.northEastDownToFixedFrame = Transforms.localFrameToFixedFrameGenerator(\n  \"north\",\n  \"east\"\n);\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an north-up-east axes\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local north direction.</li>\n * <li>The <code>y</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>\n * <li>The <code>z</code> axis points in the local east direction.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local north-up-east at cartographic (0.0, 0.0) to Earth's fixed frame.\n * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var transform = Cesium.Transforms.northUpEastToFixedFrame(center);\n */\nTransforms.northUpEastToFixedFrame = Transforms.localFrameToFixedFrameGenerator(\n  \"north\",\n  \"up\"\n);\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an north-west-up axes\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local north direction.</li>\n * <li>The <code>y</code> axis points in the local west direction.</li>\n * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local north-West-Up at cartographic (0.0, 0.0) to Earth's fixed frame.\n * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var transform = Cesium.Transforms.northWestUpToFixedFrame(center);\n */\nTransforms.northWestUpToFixedFrame = Transforms.localFrameToFixedFrameGenerator(\n  \"north\",\n  \"west\"\n);\n\nvar scratchHPRQuaternion = new Quaternion();\nvar scratchScale = new Cartesian3(1.0, 1.0, 1.0);\nvar scratchHPRMatrix4 = new Matrix4();\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with axes computed from the heading-pitch-roll angles\n * centered at the provided origin to the provided ellipsoid's fixed reference frame. Heading is the rotation from the local north\n * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles\n * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.\n *\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {HeadingPitchRoll} headingPitchRoll The heading, pitch, and roll.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Transforms~LocalFrameToFixedFrame} [fixedFrameTransform=Transforms.eastNorthUpToFixedFrame] A 4x4 transformation\n *  matrix from a reference frame to the provided ellipsoid's fixed reference frame\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.\n * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var heading = -Cesium.Math.PI_OVER_TWO;\n * var pitch = Cesium.Math.PI_OVER_FOUR;\n * var roll = 0.0;\n * var hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);\n * var transform = Cesium.Transforms.headingPitchRollToFixedFrame(center, hpr);\n */\nTransforms.headingPitchRollToFixedFrame = function (\n  origin,\n  headingPitchRoll,\n  ellipsoid,\n  fixedFrameTransform,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"HeadingPitchRoll\", headingPitchRoll);\n  //>>includeEnd('debug');\n\n  fixedFrameTransform = defaultValue(\n    fixedFrameTransform,\n    Transforms.eastNorthUpToFixedFrame\n  );\n  var hprQuaternion = Quaternion.fromHeadingPitchRoll(\n    headingPitchRoll,\n    scratchHPRQuaternion\n  );\n  var hprMatrix = Matrix4.fromTranslationQuaternionRotationScale(\n    Cartesian3.ZERO,\n    hprQuaternion,\n    scratchScale,\n    scratchHPRMatrix4\n  );\n  result = fixedFrameTransform(origin, ellipsoid, result);\n  return Matrix4.multiply(result, hprMatrix, result);\n};\n\nvar scratchENUMatrix4 = new Matrix4();\nvar scratchHPRMatrix3 = new Matrix3();\n\n/**\n * Computes a quaternion from a reference frame with axes computed from the heading-pitch-roll angles\n * centered at the provided origin. Heading is the rotation from the local north\n * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles\n * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.\n *\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {HeadingPitchRoll} headingPitchRoll The heading, pitch, and roll.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Transforms~LocalFrameToFixedFrame} [fixedFrameTransform=Transforms.eastNorthUpToFixedFrame] A 4x4 transformation\n *  matrix from a reference frame to the provided ellipsoid's fixed reference frame\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if none was provided.\n *\n * @example\n * // Get the quaternion from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.\n * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var heading = -Cesium.Math.PI_OVER_TWO;\n * var pitch = Cesium.Math.PI_OVER_FOUR;\n * var roll = 0.0;\n * var hpr = new HeadingPitchRoll(heading, pitch, roll);\n * var quaternion = Cesium.Transforms.headingPitchRollQuaternion(center, hpr);\n */\nTransforms.headingPitchRollQuaternion = function (\n  origin,\n  headingPitchRoll,\n  ellipsoid,\n  fixedFrameTransform,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"HeadingPitchRoll\", headingPitchRoll);\n  //>>includeEnd('debug');\n\n  var transform = Transforms.headingPitchRollToFixedFrame(\n    origin,\n    headingPitchRoll,\n    ellipsoid,\n    fixedFrameTransform,\n    scratchENUMatrix4\n  );\n  var rotation = Matrix4.getMatrix3(transform, scratchHPRMatrix3);\n  return Quaternion.fromRotationMatrix(rotation, result);\n};\n\nvar noScale = new Cartesian3(1.0, 1.0, 1.0);\nvar hprCenterScratch = new Cartesian3();\nvar ffScratch = new Matrix4();\nvar hprTransformScratch = new Matrix4();\nvar hprRotationScratch = new Matrix3();\nvar hprQuaternionScratch = new Quaternion();\n/**\n * Computes heading-pitch-roll angles from a transform in a particular reference frame. Heading is the rotation from the local north\n * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles\n * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.\n *\n * @param {Matrix4} transform The transform\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Transforms~LocalFrameToFixedFrame} [fixedFrameTransform=Transforms.eastNorthUpToFixedFrame] A 4x4 transformation\n *  matrix from a reference frame to the provided ellipsoid's fixed reference frame\n * @param {HeadingPitchRoll} [result] The object onto which to store the result.\n * @returns {HeadingPitchRoll} The modified result parameter or a new HeadingPitchRoll instance if none was provided.\n */\nTransforms.fixedFrameToHeadingPitchRoll = function (\n  transform,\n  ellipsoid,\n  fixedFrameTransform,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"transform\", transform);\n  //>>includeEnd('debug');\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  fixedFrameTransform = defaultValue(\n    fixedFrameTransform,\n    Transforms.eastNorthUpToFixedFrame\n  );\n  if (!defined(result)) {\n    result = new HeadingPitchRoll();\n  }\n\n  var center = Matrix4.getTranslation(transform, hprCenterScratch);\n  if (Cartesian3.equals(center, Cartesian3.ZERO)) {\n    result.heading = 0;\n    result.pitch = 0;\n    result.roll = 0;\n    return result;\n  }\n  var toFixedFrame = Matrix4.inverseTransformation(\n    fixedFrameTransform(center, ellipsoid, ffScratch),\n    ffScratch\n  );\n  var transformCopy = Matrix4.setScale(transform, noScale, hprTransformScratch);\n  transformCopy = Matrix4.setTranslation(\n    transformCopy,\n    Cartesian3.ZERO,\n    transformCopy\n  );\n\n  toFixedFrame = Matrix4.multiply(toFixedFrame, transformCopy, toFixedFrame);\n  var quaternionRotation = Quaternion.fromRotationMatrix(\n    Matrix4.getMatrix3(toFixedFrame, hprRotationScratch),\n    hprQuaternionScratch\n  );\n  quaternionRotation = Quaternion.normalize(\n    quaternionRotation,\n    quaternionRotation\n  );\n\n  return HeadingPitchRoll.fromQuaternion(quaternionRotation, result);\n};\n\nvar gmstConstant0 = 6 * 3600 + 41 * 60 + 50.54841;\nvar gmstConstant1 = 8640184.812866;\nvar gmstConstant2 = 0.093104;\nvar gmstConstant3 = -6.2e-6;\nvar rateCoef = 1.1772758384668e-19;\nvar wgs84WRPrecessing = 7.2921158553e-5;\nvar twoPiOverSecondsInDay = CesiumMath.TWO_PI / 86400.0;\nvar dateInUtc = new JulianDate();\n\n/**\n * Computes a rotation matrix to transform a point or vector from True Equator Mean Equinox (TEME) axes to the\n * pseudo-fixed axes at a given time.  This method treats the UT1 time standard as equivalent to UTC.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.\n *\n * @example\n * //Set the view to the inertial frame.\n * scene.postUpdate.addEventListener(function(scene, time) {\n *    var now = Cesium.JulianDate.now();\n *    var offset = Cesium.Matrix4.multiplyByPoint(camera.transform, camera.position, new Cesium.Cartesian3());\n *    var transform = Cesium.Matrix4.fromRotationTranslation(Cesium.Transforms.computeTemeToPseudoFixedMatrix(now));\n *    var inverseTransform = Cesium.Matrix4.inverseTransformation(transform, new Cesium.Matrix4());\n *    Cesium.Matrix4.multiplyByPoint(inverseTransform, offset, offset);\n *    camera.lookAtTransform(transform, offset);\n * });\n */\nTransforms.computeTemeToPseudoFixedMatrix = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(\"date is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // GMST is actually computed using UT1.  We're using UTC as an approximation of UT1.\n  // We do not want to use the function like convertTaiToUtc in JulianDate because\n  // we explicitly do not want to fail when inside the leap second.\n\n  dateInUtc = JulianDate.addSeconds(\n    date,\n    -JulianDate.computeTaiMinusUtc(date),\n    dateInUtc\n  );\n  var utcDayNumber = dateInUtc.dayNumber;\n  var utcSecondsIntoDay = dateInUtc.secondsOfDay;\n\n  var t;\n  var diffDays = utcDayNumber - 2451545;\n  if (utcSecondsIntoDay >= 43200.0) {\n    t = (diffDays + 0.5) / TimeConstants.DAYS_PER_JULIAN_CENTURY;\n  } else {\n    t = (diffDays - 0.5) / TimeConstants.DAYS_PER_JULIAN_CENTURY;\n  }\n\n  var gmst0 =\n    gmstConstant0 +\n    t * (gmstConstant1 + t * (gmstConstant2 + t * gmstConstant3));\n  var angle = (gmst0 * twoPiOverSecondsInDay) % CesiumMath.TWO_PI;\n  var ratio = wgs84WRPrecessing + rateCoef * (utcDayNumber - 2451545.5);\n  var secondsSinceMidnight =\n    (utcSecondsIntoDay + TimeConstants.SECONDS_PER_DAY * 0.5) %\n    TimeConstants.SECONDS_PER_DAY;\n  var gha = angle + ratio * secondsSinceMidnight;\n  var cosGha = Math.cos(gha);\n  var sinGha = Math.sin(gha);\n\n  if (!defined(result)) {\n    return new Matrix3(\n      cosGha,\n      sinGha,\n      0.0,\n      -sinGha,\n      cosGha,\n      0.0,\n      0.0,\n      0.0,\n      1.0\n    );\n  }\n  result[0] = cosGha;\n  result[1] = -sinGha;\n  result[2] = 0.0;\n  result[3] = sinGha;\n  result[4] = cosGha;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 1.0;\n  return result;\n};\n\n/**\n * The source of IAU 2006 XYS data, used for computing the transformation between the\n * Fixed and ICRF axes.\n * @type {Iau2006XysData}\n *\n * @see Transforms.computeIcrfToFixedMatrix\n * @see Transforms.computeFixedToIcrfMatrix\n *\n * @private\n */\nTransforms.iau2006XysData = new Iau2006XysData();\n\n/**\n * The source of Earth Orientation Parameters (EOP) data, used for computing the transformation\n * between the Fixed and ICRF axes.  By default, zero values are used for all EOP values,\n * yielding a reasonable but not completely accurate representation of the ICRF axes.\n * @type {EarthOrientationParameters}\n *\n * @see Transforms.computeIcrfToFixedMatrix\n * @see Transforms.computeFixedToIcrfMatrix\n *\n * @private\n */\nTransforms.earthOrientationParameters = EarthOrientationParameters.NONE;\n\nvar ttMinusTai = 32.184;\nvar j2000ttDays = 2451545.0;\n\n/**\n * Preloads the data necessary to transform between the ICRF and Fixed axes, in either\n * direction, over a given interval.  This function returns a promise that, when resolved,\n * indicates that the preload has completed.\n *\n * @param {TimeInterval} timeInterval The interval to preload.\n * @returns {Promise} A promise that, when resolved, indicates that the preload has completed\n *          and evaluation of the transformation between the fixed and ICRF axes will\n *          no longer return undefined for a time inside the interval.\n *\n *\n * @example\n * var interval = new Cesium.TimeInterval(...);\n * when(Cesium.Transforms.preloadIcrfFixed(interval), function() {\n *     // the data is now loaded\n * });\n *\n * @see Transforms.computeIcrfToFixedMatrix\n * @see Transforms.computeFixedToIcrfMatrix\n * @see when\n */\nTransforms.preloadIcrfFixed = function (timeInterval) {\n  var startDayTT = timeInterval.start.dayNumber;\n  var startSecondTT = timeInterval.start.secondsOfDay + ttMinusTai;\n  var stopDayTT = timeInterval.stop.dayNumber;\n  var stopSecondTT = timeInterval.stop.secondsOfDay + ttMinusTai;\n\n  var xysPromise = Transforms.iau2006XysData.preload(\n    startDayTT,\n    startSecondTT,\n    stopDayTT,\n    stopSecondTT\n  );\n  var eopPromise = Transforms.earthOrientationParameters.getPromiseToLoad();\n\n  return when.all([xysPromise, eopPromise]);\n};\n\n/**\n * Computes a rotation matrix to transform a point or vector from the International Celestial\n * Reference Frame (GCRF/ICRF) inertial frame axes to the Earth-Fixed frame axes (ITRF)\n * at a given time.  This function may return undefined if the data necessary to\n * do the transformation is not yet loaded.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is\n *                  not specified, a new instance is created and returned.\n * @returns {Matrix3} The rotation matrix, or undefined if the data necessary to do the\n *                   transformation is not yet loaded.\n *\n *\n * @example\n * scene.postUpdate.addEventListener(function(scene, time) {\n *   // View in ICRF.\n *   var icrfToFixed = Cesium.Transforms.computeIcrfToFixedMatrix(time);\n *   if (Cesium.defined(icrfToFixed)) {\n *     var offset = Cesium.Cartesian3.clone(camera.position);\n *     var transform = Cesium.Matrix4.fromRotationTranslation(icrfToFixed);\n *     camera.lookAtTransform(transform, offset);\n *   }\n * });\n *\n * @see Transforms.preloadIcrfFixed\n */\nTransforms.computeIcrfToFixedMatrix = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(\"date is required.\");\n  }\n  //>>includeEnd('debug');\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  var fixedToIcrfMtx = Transforms.computeFixedToIcrfMatrix(date, result);\n  if (!defined(fixedToIcrfMtx)) {\n    return undefined;\n  }\n\n  return Matrix3.transpose(fixedToIcrfMtx, result);\n};\n\nvar xysScratch = new Iau2006XysSample(0.0, 0.0, 0.0);\nvar eopScratch = new EarthOrientationParametersSample(\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0\n);\nvar rotation1Scratch = new Matrix3();\nvar rotation2Scratch = new Matrix3();\n\n/**\n * Computes a rotation matrix to transform a point or vector from the Earth-Fixed frame axes (ITRF)\n * to the International Celestial Reference Frame (GCRF/ICRF) inertial frame axes\n * at a given time.  This function may return undefined if the data necessary to\n * do the transformation is not yet loaded.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is\n *                  not specified, a new instance is created and returned.\n * @returns {Matrix3} The rotation matrix, or undefined if the data necessary to do the\n *                   transformation is not yet loaded.\n *\n *\n * @example\n * // Transform a point from the ICRF axes to the Fixed axes.\n * var now = Cesium.JulianDate.now();\n * var pointInFixed = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var fixedToIcrf = Cesium.Transforms.computeIcrfToFixedMatrix(now);\n * var pointInInertial = new Cesium.Cartesian3();\n * if (Cesium.defined(fixedToIcrf)) {\n *     pointInInertial = Cesium.Matrix3.multiplyByVector(fixedToIcrf, pointInFixed, pointInInertial);\n * }\n *\n * @see Transforms.preloadIcrfFixed\n */\nTransforms.computeFixedToIcrfMatrix = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(\"date is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  // Compute pole wander\n  var eop = Transforms.earthOrientationParameters.compute(date, eopScratch);\n  if (!defined(eop)) {\n    return undefined;\n  }\n\n  // There is no external conversion to Terrestrial Time (TT).\n  // So use International Atomic Time (TAI) and convert using offsets.\n  // Here we are assuming that dayTT and secondTT are positive\n  var dayTT = date.dayNumber;\n  // It's possible here that secondTT could roll over 86400\n  // This does not seem to affect the precision (unit tests check for this)\n  var secondTT = date.secondsOfDay + ttMinusTai;\n\n  var xys = Transforms.iau2006XysData.computeXysRadians(\n    dayTT,\n    secondTT,\n    xysScratch\n  );\n  if (!defined(xys)) {\n    return undefined;\n  }\n\n  var x = xys.x + eop.xPoleOffset;\n  var y = xys.y + eop.yPoleOffset;\n\n  // Compute XYS rotation\n  var a = 1.0 / (1.0 + Math.sqrt(1.0 - x * x - y * y));\n\n  var rotation1 = rotation1Scratch;\n  rotation1[0] = 1.0 - a * x * x;\n  rotation1[3] = -a * x * y;\n  rotation1[6] = x;\n  rotation1[1] = -a * x * y;\n  rotation1[4] = 1 - a * y * y;\n  rotation1[7] = y;\n  rotation1[2] = -x;\n  rotation1[5] = -y;\n  rotation1[8] = 1 - a * (x * x + y * y);\n\n  var rotation2 = Matrix3.fromRotationZ(-xys.s, rotation2Scratch);\n  var matrixQ = Matrix3.multiply(rotation1, rotation2, rotation1Scratch);\n\n  // Similar to TT conversions above\n  // It's possible here that secondTT could roll over 86400\n  // This does not seem to affect the precision (unit tests check for this)\n  var dateUt1day = date.dayNumber;\n  var dateUt1sec =\n    date.secondsOfDay - JulianDate.computeTaiMinusUtc(date) + eop.ut1MinusUtc;\n\n  // Compute Earth rotation angle\n  // The IERS standard for era is\n  //    era = 0.7790572732640 + 1.00273781191135448 * Tu\n  // where\n  //    Tu = JulianDateInUt1 - 2451545.0\n  // However, you get much more precision if you make the following simplification\n  //    era = a + (1 + b) * (JulianDayNumber + FractionOfDay - 2451545)\n  //    era = a + (JulianDayNumber - 2451545) + FractionOfDay + b (JulianDayNumber - 2451545 + FractionOfDay)\n  //    era = a + FractionOfDay + b (JulianDayNumber - 2451545 + FractionOfDay)\n  // since (JulianDayNumber - 2451545) represents an integer number of revolutions which will be discarded anyway.\n  var daysSinceJ2000 = dateUt1day - 2451545;\n  var fractionOfDay = dateUt1sec / TimeConstants.SECONDS_PER_DAY;\n  var era =\n    0.779057273264 +\n    fractionOfDay +\n    0.00273781191135448 * (daysSinceJ2000 + fractionOfDay);\n  era = (era % 1.0) * CesiumMath.TWO_PI;\n\n  var earthRotation = Matrix3.fromRotationZ(era, rotation2Scratch);\n\n  // pseudoFixed to ICRF\n  var pfToIcrf = Matrix3.multiply(matrixQ, earthRotation, rotation1Scratch);\n\n  // Compute pole wander matrix\n  var cosxp = Math.cos(eop.xPoleWander);\n  var cosyp = Math.cos(eop.yPoleWander);\n  var sinxp = Math.sin(eop.xPoleWander);\n  var sinyp = Math.sin(eop.yPoleWander);\n\n  var ttt = dayTT - j2000ttDays + secondTT / TimeConstants.SECONDS_PER_DAY;\n  ttt /= 36525.0;\n\n  // approximate sp value in rad\n  var sp = (-47.0e-6 * ttt * CesiumMath.RADIANS_PER_DEGREE) / 3600.0;\n  var cossp = Math.cos(sp);\n  var sinsp = Math.sin(sp);\n\n  var fToPfMtx = rotation2Scratch;\n  fToPfMtx[0] = cosxp * cossp;\n  fToPfMtx[1] = cosxp * sinsp;\n  fToPfMtx[2] = sinxp;\n  fToPfMtx[3] = -cosyp * sinsp + sinyp * sinxp * cossp;\n  fToPfMtx[4] = cosyp * cossp + sinyp * sinxp * sinsp;\n  fToPfMtx[5] = -sinyp * cosxp;\n  fToPfMtx[6] = -sinyp * sinsp - cosyp * sinxp * cossp;\n  fToPfMtx[7] = sinyp * cossp - cosyp * sinxp * sinsp;\n  fToPfMtx[8] = cosyp * cosxp;\n\n  return Matrix3.multiply(pfToIcrf, fToPfMtx, result);\n};\n\nvar pointToWindowCoordinatesTemp = new Cartesian4();\n\n/**\n * Transform a point from model coordinates to window coordinates.\n *\n * @param {Matrix4} modelViewProjectionMatrix The 4x4 model-view-projection matrix.\n * @param {Matrix4} viewportTransformation The 4x4 viewport transformation.\n * @param {Cartesian3} point The point to transform.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.\n */\nTransforms.pointToWindowCoordinates = function (\n  modelViewProjectionMatrix,\n  viewportTransformation,\n  point,\n  result\n) {\n  result = Transforms.pointToGLWindowCoordinates(\n    modelViewProjectionMatrix,\n    viewportTransformation,\n    point,\n    result\n  );\n  result.y = 2.0 * viewportTransformation[5] - result.y;\n  return result;\n};\n\n/**\n * @private\n */\nTransforms.pointToGLWindowCoordinates = function (\n  modelViewProjectionMatrix,\n  viewportTransformation,\n  point,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(modelViewProjectionMatrix)) {\n    throw new DeveloperError(\"modelViewProjectionMatrix is required.\");\n  }\n\n  if (!defined(viewportTransformation)) {\n    throw new DeveloperError(\"viewportTransformation is required.\");\n  }\n\n  if (!defined(point)) {\n    throw new DeveloperError(\"point is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n\n  var tmp = pointToWindowCoordinatesTemp;\n\n  Matrix4.multiplyByVector(\n    modelViewProjectionMatrix,\n    Cartesian4.fromElements(point.x, point.y, point.z, 1, tmp),\n    tmp\n  );\n  Cartesian4.multiplyByScalar(tmp, 1.0 / tmp.w, tmp);\n  Matrix4.multiplyByVector(viewportTransformation, tmp, tmp);\n  return Cartesian2.fromCartesian4(tmp, result);\n};\n\nvar normalScratch = new Cartesian3();\nvar rightScratch = new Cartesian3();\nvar upScratch = new Cartesian3();\n\n/**\n * @private\n */\nTransforms.rotationMatrixFromPositionVelocity = function (\n  position,\n  velocity,\n  ellipsoid,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n\n  if (!defined(velocity)) {\n    throw new DeveloperError(\"velocity is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var normal = defaultValue(ellipsoid, Ellipsoid.WGS84).geodeticSurfaceNormal(\n    position,\n    normalScratch\n  );\n  var right = Cartesian3.cross(velocity, normal, rightScratch);\n\n  if (Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)) {\n    right = Cartesian3.clone(Cartesian3.UNIT_X, right);\n  }\n\n  var up = Cartesian3.cross(right, velocity, upScratch);\n  Cartesian3.normalize(up, up);\n  Cartesian3.cross(velocity, up, right);\n  Cartesian3.negate(right, right);\n  Cartesian3.normalize(right, right);\n\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  result[0] = velocity.x;\n  result[1] = velocity.y;\n  result[2] = velocity.z;\n  result[3] = right.x;\n  result[4] = right.y;\n  result[5] = right.z;\n  result[6] = up.x;\n  result[7] = up.y;\n  result[8] = up.z;\n\n  return result;\n};\n\nvar swizzleMatrix = new Matrix4(\n  0.0,\n  0.0,\n  1.0,\n  0.0,\n  1.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  1.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  1.0\n);\n\nvar scratchCartographic = new Cartographic();\nvar scratchCartesian3Projection = new Cartesian3();\nvar scratchCenter = new Cartesian3();\nvar scratchRotation = new Matrix3();\nvar scratchFromENU = new Matrix4();\nvar scratchToENU = new Matrix4();\n\n/**\n * @private\n */\nTransforms.basisTo2D = function (projection, matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(projection)) {\n    throw new DeveloperError(\"projection is required.\");\n  }\n  if (!defined(matrix)) {\n    throw new DeveloperError(\"matrix is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var rtcCenter = Matrix4.getTranslation(matrix, scratchCenter);\n  var ellipsoid = projection.ellipsoid;\n\n  // Get the 2D Center\n  var cartographic = ellipsoid.cartesianToCartographic(\n    rtcCenter,\n    scratchCartographic\n  );\n  var projectedPosition = projection.project(\n    cartographic,\n    scratchCartesian3Projection\n  );\n  Cartesian3.fromElements(\n    projectedPosition.z,\n    projectedPosition.x,\n    projectedPosition.y,\n    projectedPosition\n  );\n\n  // Assuming the instance are positioned in WGS84, invert the WGS84 transform to get the local transform and then convert to 2D\n  var fromENU = Transforms.eastNorthUpToFixedFrame(\n    rtcCenter,\n    ellipsoid,\n    scratchFromENU\n  );\n  var toENU = Matrix4.inverseTransformation(fromENU, scratchToENU);\n  var rotation = Matrix4.getMatrix3(matrix, scratchRotation);\n  var local = Matrix4.multiplyByMatrix3(toENU, rotation, result);\n  Matrix4.multiply(swizzleMatrix, local, result); // Swap x, y, z for 2D\n  Matrix4.setTranslation(result, projectedPosition, result); // Use the projected center\n\n  return result;\n};\n\n/**\n * @private\n */\nTransforms.wgs84To2DModelMatrix = function (projection, center, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(projection)) {\n    throw new DeveloperError(\"projection is required.\");\n  }\n  if (!defined(center)) {\n    throw new DeveloperError(\"center is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var ellipsoid = projection.ellipsoid;\n\n  var fromENU = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    scratchFromENU\n  );\n  var toENU = Matrix4.inverseTransformation(fromENU, scratchToENU);\n\n  var cartographic = ellipsoid.cartesianToCartographic(\n    center,\n    scratchCartographic\n  );\n  var projectedPosition = projection.project(\n    cartographic,\n    scratchCartesian3Projection\n  );\n  Cartesian3.fromElements(\n    projectedPosition.z,\n    projectedPosition.x,\n    projectedPosition.y,\n    projectedPosition\n  );\n\n  var translation = Matrix4.fromTranslation(projectedPosition, scratchFromENU);\n  Matrix4.multiply(swizzleMatrix, toENU, result);\n  Matrix4.multiply(translation, result, result);\n\n  return result;\n};\nexport default Transforms;\n"]},"metadata":{},"sourceType":"module"}