{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport CesiumMath from \"./Math.js\";\n\nfunction setConstants(ellipsoidGeodesic) {\n  var uSquared = ellipsoidGeodesic._uSquared;\n  var a = ellipsoidGeodesic._ellipsoid.maximumRadius;\n  var b = ellipsoidGeodesic._ellipsoid.minimumRadius;\n  var f = (a - b) / a;\n  var cosineHeading = Math.cos(ellipsoidGeodesic._startHeading);\n  var sineHeading = Math.sin(ellipsoidGeodesic._startHeading);\n  var tanU = (1 - f) * Math.tan(ellipsoidGeodesic._start.latitude);\n  var cosineU = 1.0 / Math.sqrt(1.0 + tanU * tanU);\n  var sineU = cosineU * tanU;\n  var sigma = Math.atan2(tanU, cosineHeading);\n  var sineAlpha = cosineU * sineHeading;\n  var sineSquaredAlpha = sineAlpha * sineAlpha;\n  var cosineSquaredAlpha = 1.0 - sineSquaredAlpha;\n  var cosineAlpha = Math.sqrt(cosineSquaredAlpha);\n  var u2Over4 = uSquared / 4.0;\n  var u4Over16 = u2Over4 * u2Over4;\n  var u6Over64 = u4Over16 * u2Over4;\n  var u8Over256 = u4Over16 * u4Over16;\n  var a0 = 1.0 + u2Over4 - 3.0 * u4Over16 / 4.0 + 5.0 * u6Over64 / 4.0 - 175.0 * u8Over256 / 64.0;\n  var a1 = 1.0 - u2Over4 + 15.0 * u4Over16 / 8.0 - 35.0 * u6Over64 / 8.0;\n  var a2 = 1.0 - 3.0 * u2Over4 + 35.0 * u4Over16 / 4.0;\n  var a3 = 1.0 - 5.0 * u2Over4;\n  var distanceRatio = a0 * sigma - a1 * Math.sin(2.0 * sigma) * u2Over4 / 2.0 - a2 * Math.sin(4.0 * sigma) * u4Over16 / 16.0 - a3 * Math.sin(6.0 * sigma) * u6Over64 / 48.0 - Math.sin(8.0 * sigma) * 5.0 * u8Over256 / 512;\n  var constants = ellipsoidGeodesic._constants;\n  constants.a = a;\n  constants.b = b;\n  constants.f = f;\n  constants.cosineHeading = cosineHeading;\n  constants.sineHeading = sineHeading;\n  constants.tanU = tanU;\n  constants.cosineU = cosineU;\n  constants.sineU = sineU;\n  constants.sigma = sigma;\n  constants.sineAlpha = sineAlpha;\n  constants.sineSquaredAlpha = sineSquaredAlpha;\n  constants.cosineSquaredAlpha = cosineSquaredAlpha;\n  constants.cosineAlpha = cosineAlpha;\n  constants.u2Over4 = u2Over4;\n  constants.u4Over16 = u4Over16;\n  constants.u6Over64 = u6Over64;\n  constants.u8Over256 = u8Over256;\n  constants.a0 = a0;\n  constants.a1 = a1;\n  constants.a2 = a2;\n  constants.a3 = a3;\n  constants.distanceRatio = distanceRatio;\n}\n\nfunction computeC(f, cosineSquaredAlpha) {\n  return f * cosineSquaredAlpha * (4.0 + f * (4.0 - 3.0 * cosineSquaredAlpha)) / 16.0;\n}\n\nfunction computeDeltaLambda(f, sineAlpha, cosineSquaredAlpha, sigma, sineSigma, cosineSigma, cosineTwiceSigmaMidpoint) {\n  var C = computeC(f, cosineSquaredAlpha);\n  return (1.0 - C) * f * sineAlpha * (sigma + C * sineSigma * (cosineTwiceSigmaMidpoint + C * cosineSigma * (2.0 * cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint - 1.0)));\n}\n\nfunction vincentyInverseFormula(ellipsoidGeodesic, major, minor, firstLongitude, firstLatitude, secondLongitude, secondLatitude) {\n  var eff = (major - minor) / major;\n  var l = secondLongitude - firstLongitude;\n  var u1 = Math.atan((1 - eff) * Math.tan(firstLatitude));\n  var u2 = Math.atan((1 - eff) * Math.tan(secondLatitude));\n  var cosineU1 = Math.cos(u1);\n  var sineU1 = Math.sin(u1);\n  var cosineU2 = Math.cos(u2);\n  var sineU2 = Math.sin(u2);\n  var cc = cosineU1 * cosineU2;\n  var cs = cosineU1 * sineU2;\n  var ss = sineU1 * sineU2;\n  var sc = sineU1 * cosineU2;\n  var lambda = l;\n  var lambdaDot = CesiumMath.TWO_PI;\n  var cosineLambda = Math.cos(lambda);\n  var sineLambda = Math.sin(lambda);\n  var sigma;\n  var cosineSigma;\n  var sineSigma;\n  var cosineSquaredAlpha;\n  var cosineTwiceSigmaMidpoint;\n\n  do {\n    cosineLambda = Math.cos(lambda);\n    sineLambda = Math.sin(lambda);\n    var temp = cs - sc * cosineLambda;\n    sineSigma = Math.sqrt(cosineU2 * cosineU2 * sineLambda * sineLambda + temp * temp);\n    cosineSigma = ss + cc * cosineLambda;\n    sigma = Math.atan2(sineSigma, cosineSigma);\n    var sineAlpha;\n\n    if (sineSigma === 0.0) {\n      sineAlpha = 0.0;\n      cosineSquaredAlpha = 1.0;\n    } else {\n      sineAlpha = cc * sineLambda / sineSigma;\n      cosineSquaredAlpha = 1.0 - sineAlpha * sineAlpha;\n    }\n\n    lambdaDot = lambda;\n    cosineTwiceSigmaMidpoint = cosineSigma - 2.0 * ss / cosineSquaredAlpha;\n\n    if (isNaN(cosineTwiceSigmaMidpoint)) {\n      cosineTwiceSigmaMidpoint = 0.0;\n    }\n\n    lambda = l + computeDeltaLambda(eff, sineAlpha, cosineSquaredAlpha, sigma, sineSigma, cosineSigma, cosineTwiceSigmaMidpoint);\n  } while (Math.abs(lambda - lambdaDot) > CesiumMath.EPSILON12);\n\n  var uSquared = cosineSquaredAlpha * (major * major - minor * minor) / (minor * minor);\n  var A = 1.0 + uSquared * (4096.0 + uSquared * (uSquared * (320.0 - 175.0 * uSquared) - 768.0)) / 16384.0;\n  var B = uSquared * (256.0 + uSquared * (uSquared * (74.0 - 47.0 * uSquared) - 128.0)) / 1024.0;\n  var cosineSquaredTwiceSigmaMidpoint = cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint;\n  var deltaSigma = B * sineSigma * (cosineTwiceSigmaMidpoint + B * (cosineSigma * (2.0 * cosineSquaredTwiceSigmaMidpoint - 1.0) - B * cosineTwiceSigmaMidpoint * (4.0 * sineSigma * sineSigma - 3.0) * (4.0 * cosineSquaredTwiceSigmaMidpoint - 3.0) / 6.0) / 4.0);\n  var distance = minor * A * (sigma - deltaSigma);\n  var startHeading = Math.atan2(cosineU2 * sineLambda, cs - sc * cosineLambda);\n  var endHeading = Math.atan2(cosineU1 * sineLambda, cs * cosineLambda - sc);\n  ellipsoidGeodesic._distance = distance;\n  ellipsoidGeodesic._startHeading = startHeading;\n  ellipsoidGeodesic._endHeading = endHeading;\n  ellipsoidGeodesic._uSquared = uSquared;\n}\n\nvar scratchCart1 = new Cartesian3();\nvar scratchCart2 = new Cartesian3();\n\nfunction computeProperties(ellipsoidGeodesic, start, end, ellipsoid) {\n  var firstCartesian = Cartesian3.normalize(ellipsoid.cartographicToCartesian(start, scratchCart2), scratchCart1);\n  var lastCartesian = Cartesian3.normalize(ellipsoid.cartographicToCartesian(end, scratchCart2), scratchCart2); //>>includeStart('debug', pragmas.debug);\n\n  Check.typeOf.number.greaterThanOrEquals(\"value\", Math.abs(Math.abs(Cartesian3.angleBetween(firstCartesian, lastCartesian)) - Math.PI), 0.0125); //>>includeEnd('debug');\n\n  vincentyInverseFormula(ellipsoidGeodesic, ellipsoid.maximumRadius, ellipsoid.minimumRadius, start.longitude, start.latitude, end.longitude, end.latitude);\n  ellipsoidGeodesic._start = Cartographic.clone(start, ellipsoidGeodesic._start);\n  ellipsoidGeodesic._end = Cartographic.clone(end, ellipsoidGeodesic._end);\n  ellipsoidGeodesic._start.height = 0;\n  ellipsoidGeodesic._end.height = 0;\n  setConstants(ellipsoidGeodesic);\n}\n/**\n * Initializes a geodesic on the ellipsoid connecting the two provided planetodetic points.\n *\n * @alias EllipsoidGeodesic\n * @constructor\n *\n * @param {Cartographic} [start] The initial planetodetic point on the path.\n * @param {Cartographic} [end] The final planetodetic point on the path.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the geodesic lies.\n */\n\n\nfunction EllipsoidGeodesic(start, end, ellipsoid) {\n  var e = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  this._ellipsoid = e;\n  this._start = new Cartographic();\n  this._end = new Cartographic();\n  this._constants = {};\n  this._startHeading = undefined;\n  this._endHeading = undefined;\n  this._distance = undefined;\n  this._uSquared = undefined;\n\n  if (defined(start) && defined(end)) {\n    computeProperties(this, start, end, e);\n  }\n}\n\nObject.defineProperties(EllipsoidGeodesic.prototype, {\n  /**\n   * Gets the ellipsoid.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function get() {\n      return this._ellipsoid;\n    }\n  },\n\n  /**\n   * Gets the surface distance between the start and end point\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Number}\n   * @readonly\n   */\n  surfaceDistance: {\n    get: function get() {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"distance\", this._distance); //>>includeEnd('debug');\n\n      return this._distance;\n    }\n  },\n\n  /**\n   * Gets the initial planetodetic point on the path.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Cartographic}\n   * @readonly\n   */\n  start: {\n    get: function get() {\n      return this._start;\n    }\n  },\n\n  /**\n   * Gets the final planetodetic point on the path.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Cartographic}\n   * @readonly\n   */\n  end: {\n    get: function get() {\n      return this._end;\n    }\n  },\n\n  /**\n   * Gets the heading at the initial point.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Number}\n   * @readonly\n   */\n  startHeading: {\n    get: function get() {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"distance\", this._distance); //>>includeEnd('debug');\n\n      return this._startHeading;\n    }\n  },\n\n  /**\n   * Gets the heading at the final point.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Number}\n   * @readonly\n   */\n  endHeading: {\n    get: function get() {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"distance\", this._distance); //>>includeEnd('debug');\n\n      return this._endHeading;\n    }\n  }\n});\n/**\n * Sets the start and end points of the geodesic\n *\n * @param {Cartographic} start The initial planetodetic point on the path.\n * @param {Cartographic} end The final planetodetic point on the path.\n */\n\nEllipsoidGeodesic.prototype.setEndPoints = function (start, end) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"start\", start);\n  Check.defined(\"end\", end); //>>includeEnd('debug');\n\n  computeProperties(this, start, end, this._ellipsoid);\n};\n/**\n * Provides the location of a point at the indicated portion along the geodesic.\n *\n * @param {Number} fraction The portion of the distance between the initial and final points.\n * @param {Cartographic} result The object in which to store the result.\n * @returns {Cartographic} The location of the point along the geodesic.\n */\n\n\nEllipsoidGeodesic.prototype.interpolateUsingFraction = function (fraction, result) {\n  return this.interpolateUsingSurfaceDistance(this._distance * fraction, result);\n};\n/**\n * Provides the location of a point at the indicated distance along the geodesic.\n *\n * @param {Number} distance The distance from the inital point to the point of interest along the geodesic\n * @param {Cartographic} result The object in which to store the result.\n * @returns {Cartographic} The location of the point along the geodesic.\n *\n * @exception {DeveloperError} start and end must be set before calling function interpolateUsingSurfaceDistance\n */\n\n\nEllipsoidGeodesic.prototype.interpolateUsingSurfaceDistance = function (distance, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"distance\", this._distance); //>>includeEnd('debug');\n\n  var constants = this._constants;\n  var s = constants.distanceRatio + distance / constants.b;\n  var cosine2S = Math.cos(2.0 * s);\n  var cosine4S = Math.cos(4.0 * s);\n  var cosine6S = Math.cos(6.0 * s);\n  var sine2S = Math.sin(2.0 * s);\n  var sine4S = Math.sin(4.0 * s);\n  var sine6S = Math.sin(6.0 * s);\n  var sine8S = Math.sin(8.0 * s);\n  var s2 = s * s;\n  var s3 = s * s2;\n  var u8Over256 = constants.u8Over256;\n  var u2Over4 = constants.u2Over4;\n  var u6Over64 = constants.u6Over64;\n  var u4Over16 = constants.u4Over16;\n  var sigma = 2.0 * s3 * u8Over256 * cosine2S / 3.0 + s * (1.0 - u2Over4 + 7.0 * u4Over16 / 4.0 - 15.0 * u6Over64 / 4.0 + 579.0 * u8Over256 / 64.0 - (u4Over16 - 15.0 * u6Over64 / 4.0 + 187.0 * u8Over256 / 16.0) * cosine2S - (5.0 * u6Over64 / 4.0 - 115.0 * u8Over256 / 16.0) * cosine4S - 29.0 * u8Over256 * cosine6S / 16.0) + (u2Over4 / 2.0 - u4Over16 + 71.0 * u6Over64 / 32.0 - 85.0 * u8Over256 / 16.0) * sine2S + (5.0 * u4Over16 / 16.0 - 5.0 * u6Over64 / 4.0 + 383.0 * u8Over256 / 96.0) * sine4S - s2 * ((u6Over64 - 11.0 * u8Over256 / 2.0) * sine2S + 5.0 * u8Over256 * sine4S / 2.0) + (29.0 * u6Over64 / 96.0 - 29.0 * u8Over256 / 16.0) * sine6S + 539.0 * u8Over256 * sine8S / 1536.0;\n  var theta = Math.asin(Math.sin(sigma) * constants.cosineAlpha);\n  var latitude = Math.atan(constants.a / constants.b * Math.tan(theta)); // Redefine in terms of relative argument of latitude.\n\n  sigma = sigma - constants.sigma;\n  var cosineTwiceSigmaMidpoint = Math.cos(2.0 * constants.sigma + sigma);\n  var sineSigma = Math.sin(sigma);\n  var cosineSigma = Math.cos(sigma);\n  var cc = constants.cosineU * cosineSigma;\n  var ss = constants.sineU * sineSigma;\n  var lambda = Math.atan2(sineSigma * constants.sineHeading, cc - ss * constants.cosineHeading);\n  var l = lambda - computeDeltaLambda(constants.f, constants.sineAlpha, constants.cosineSquaredAlpha, sigma, sineSigma, cosineSigma, cosineTwiceSigmaMidpoint);\n\n  if (defined(result)) {\n    result.longitude = this._start.longitude + l;\n    result.latitude = latitude;\n    result.height = 0.0;\n    return result;\n  }\n\n  return new Cartographic(this._start.longitude + l, latitude, 0.0);\n};\n\nexport default EllipsoidGeodesic;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/EllipsoidGeodesic.js"],"names":["Cartesian3","Cartographic","Check","defaultValue","defined","Ellipsoid","CesiumMath","setConstants","ellipsoidGeodesic","uSquared","_uSquared","a","_ellipsoid","maximumRadius","b","minimumRadius","f","cosineHeading","Math","cos","_startHeading","sineHeading","sin","tanU","tan","_start","latitude","cosineU","sqrt","sineU","sigma","atan2","sineAlpha","sineSquaredAlpha","cosineSquaredAlpha","cosineAlpha","u2Over4","u4Over16","u6Over64","u8Over256","a0","a1","a2","a3","distanceRatio","constants","_constants","computeC","computeDeltaLambda","sineSigma","cosineSigma","cosineTwiceSigmaMidpoint","C","vincentyInverseFormula","major","minor","firstLongitude","firstLatitude","secondLongitude","secondLatitude","eff","l","u1","atan","u2","cosineU1","sineU1","cosineU2","sineU2","cc","cs","ss","sc","lambda","lambdaDot","TWO_PI","cosineLambda","sineLambda","temp","isNaN","abs","EPSILON12","A","B","cosineSquaredTwiceSigmaMidpoint","deltaSigma","distance","startHeading","endHeading","_distance","_endHeading","scratchCart1","scratchCart2","computeProperties","start","end","ellipsoid","firstCartesian","normalize","cartographicToCartesian","lastCartesian","typeOf","number","greaterThanOrEquals","angleBetween","PI","longitude","clone","_end","height","EllipsoidGeodesic","e","WGS84","undefined","Object","defineProperties","prototype","get","surfaceDistance","setEndPoints","interpolateUsingFraction","fraction","result","interpolateUsingSurfaceDistance","s","cosine2S","cosine4S","cosine6S","sine2S","sine4S","sine6S","sine8S","s2","s3","theta","asin"],"mappings":"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","sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport CesiumMath from \"./Math.js\";\n\nfunction setConstants(ellipsoidGeodesic) {\n  var uSquared = ellipsoidGeodesic._uSquared;\n  var a = ellipsoidGeodesic._ellipsoid.maximumRadius;\n  var b = ellipsoidGeodesic._ellipsoid.minimumRadius;\n  var f = (a - b) / a;\n\n  var cosineHeading = Math.cos(ellipsoidGeodesic._startHeading);\n  var sineHeading = Math.sin(ellipsoidGeodesic._startHeading);\n\n  var tanU = (1 - f) * Math.tan(ellipsoidGeodesic._start.latitude);\n\n  var cosineU = 1.0 / Math.sqrt(1.0 + tanU * tanU);\n  var sineU = cosineU * tanU;\n\n  var sigma = Math.atan2(tanU, cosineHeading);\n\n  var sineAlpha = cosineU * sineHeading;\n  var sineSquaredAlpha = sineAlpha * sineAlpha;\n\n  var cosineSquaredAlpha = 1.0 - sineSquaredAlpha;\n  var cosineAlpha = Math.sqrt(cosineSquaredAlpha);\n\n  var u2Over4 = uSquared / 4.0;\n  var u4Over16 = u2Over4 * u2Over4;\n  var u6Over64 = u4Over16 * u2Over4;\n  var u8Over256 = u4Over16 * u4Over16;\n\n  var a0 =\n    1.0 +\n    u2Over4 -\n    (3.0 * u4Over16) / 4.0 +\n    (5.0 * u6Over64) / 4.0 -\n    (175.0 * u8Over256) / 64.0;\n  var a1 = 1.0 - u2Over4 + (15.0 * u4Over16) / 8.0 - (35.0 * u6Over64) / 8.0;\n  var a2 = 1.0 - 3.0 * u2Over4 + (35.0 * u4Over16) / 4.0;\n  var a3 = 1.0 - 5.0 * u2Over4;\n\n  var distanceRatio =\n    a0 * sigma -\n    (a1 * Math.sin(2.0 * sigma) * u2Over4) / 2.0 -\n    (a2 * Math.sin(4.0 * sigma) * u4Over16) / 16.0 -\n    (a3 * Math.sin(6.0 * sigma) * u6Over64) / 48.0 -\n    (Math.sin(8.0 * sigma) * 5.0 * u8Over256) / 512;\n\n  var constants = ellipsoidGeodesic._constants;\n\n  constants.a = a;\n  constants.b = b;\n  constants.f = f;\n  constants.cosineHeading = cosineHeading;\n  constants.sineHeading = sineHeading;\n  constants.tanU = tanU;\n  constants.cosineU = cosineU;\n  constants.sineU = sineU;\n  constants.sigma = sigma;\n  constants.sineAlpha = sineAlpha;\n  constants.sineSquaredAlpha = sineSquaredAlpha;\n  constants.cosineSquaredAlpha = cosineSquaredAlpha;\n  constants.cosineAlpha = cosineAlpha;\n  constants.u2Over4 = u2Over4;\n  constants.u4Over16 = u4Over16;\n  constants.u6Over64 = u6Over64;\n  constants.u8Over256 = u8Over256;\n  constants.a0 = a0;\n  constants.a1 = a1;\n  constants.a2 = a2;\n  constants.a3 = a3;\n  constants.distanceRatio = distanceRatio;\n}\n\nfunction computeC(f, cosineSquaredAlpha) {\n  return (\n    (f * cosineSquaredAlpha * (4.0 + f * (4.0 - 3.0 * cosineSquaredAlpha))) /\n    16.0\n  );\n}\n\nfunction computeDeltaLambda(\n  f,\n  sineAlpha,\n  cosineSquaredAlpha,\n  sigma,\n  sineSigma,\n  cosineSigma,\n  cosineTwiceSigmaMidpoint\n) {\n  var C = computeC(f, cosineSquaredAlpha);\n\n  return (\n    (1.0 - C) *\n    f *\n    sineAlpha *\n    (sigma +\n      C *\n        sineSigma *\n        (cosineTwiceSigmaMidpoint +\n          C *\n            cosineSigma *\n            (2.0 * cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint - 1.0)))\n  );\n}\n\nfunction vincentyInverseFormula(\n  ellipsoidGeodesic,\n  major,\n  minor,\n  firstLongitude,\n  firstLatitude,\n  secondLongitude,\n  secondLatitude\n) {\n  var eff = (major - minor) / major;\n  var l = secondLongitude - firstLongitude;\n\n  var u1 = Math.atan((1 - eff) * Math.tan(firstLatitude));\n  var u2 = Math.atan((1 - eff) * Math.tan(secondLatitude));\n\n  var cosineU1 = Math.cos(u1);\n  var sineU1 = Math.sin(u1);\n  var cosineU2 = Math.cos(u2);\n  var sineU2 = Math.sin(u2);\n\n  var cc = cosineU1 * cosineU2;\n  var cs = cosineU1 * sineU2;\n  var ss = sineU1 * sineU2;\n  var sc = sineU1 * cosineU2;\n\n  var lambda = l;\n  var lambdaDot = CesiumMath.TWO_PI;\n\n  var cosineLambda = Math.cos(lambda);\n  var sineLambda = Math.sin(lambda);\n\n  var sigma;\n  var cosineSigma;\n  var sineSigma;\n  var cosineSquaredAlpha;\n  var cosineTwiceSigmaMidpoint;\n\n  do {\n    cosineLambda = Math.cos(lambda);\n    sineLambda = Math.sin(lambda);\n\n    var temp = cs - sc * cosineLambda;\n    sineSigma = Math.sqrt(\n      cosineU2 * cosineU2 * sineLambda * sineLambda + temp * temp\n    );\n    cosineSigma = ss + cc * cosineLambda;\n\n    sigma = Math.atan2(sineSigma, cosineSigma);\n\n    var sineAlpha;\n\n    if (sineSigma === 0.0) {\n      sineAlpha = 0.0;\n      cosineSquaredAlpha = 1.0;\n    } else {\n      sineAlpha = (cc * sineLambda) / sineSigma;\n      cosineSquaredAlpha = 1.0 - sineAlpha * sineAlpha;\n    }\n\n    lambdaDot = lambda;\n\n    cosineTwiceSigmaMidpoint = cosineSigma - (2.0 * ss) / cosineSquaredAlpha;\n\n    if (isNaN(cosineTwiceSigmaMidpoint)) {\n      cosineTwiceSigmaMidpoint = 0.0;\n    }\n\n    lambda =\n      l +\n      computeDeltaLambda(\n        eff,\n        sineAlpha,\n        cosineSquaredAlpha,\n        sigma,\n        sineSigma,\n        cosineSigma,\n        cosineTwiceSigmaMidpoint\n      );\n  } while (Math.abs(lambda - lambdaDot) > CesiumMath.EPSILON12);\n\n  var uSquared =\n    (cosineSquaredAlpha * (major * major - minor * minor)) / (minor * minor);\n  var A =\n    1.0 +\n    (uSquared *\n      (4096.0 + uSquared * (uSquared * (320.0 - 175.0 * uSquared) - 768.0))) /\n      16384.0;\n  var B =\n    (uSquared *\n      (256.0 + uSquared * (uSquared * (74.0 - 47.0 * uSquared) - 128.0))) /\n    1024.0;\n\n  var cosineSquaredTwiceSigmaMidpoint =\n    cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint;\n  var deltaSigma =\n    B *\n    sineSigma *\n    (cosineTwiceSigmaMidpoint +\n      (B *\n        (cosineSigma * (2.0 * cosineSquaredTwiceSigmaMidpoint - 1.0) -\n          (B *\n            cosineTwiceSigmaMidpoint *\n            (4.0 * sineSigma * sineSigma - 3.0) *\n            (4.0 * cosineSquaredTwiceSigmaMidpoint - 3.0)) /\n            6.0)) /\n        4.0);\n\n  var distance = minor * A * (sigma - deltaSigma);\n\n  var startHeading = Math.atan2(cosineU2 * sineLambda, cs - sc * cosineLambda);\n  var endHeading = Math.atan2(cosineU1 * sineLambda, cs * cosineLambda - sc);\n\n  ellipsoidGeodesic._distance = distance;\n  ellipsoidGeodesic._startHeading = startHeading;\n  ellipsoidGeodesic._endHeading = endHeading;\n  ellipsoidGeodesic._uSquared = uSquared;\n}\n\nvar scratchCart1 = new Cartesian3();\nvar scratchCart2 = new Cartesian3();\nfunction computeProperties(ellipsoidGeodesic, start, end, ellipsoid) {\n  var firstCartesian = Cartesian3.normalize(\n    ellipsoid.cartographicToCartesian(start, scratchCart2),\n    scratchCart1\n  );\n  var lastCartesian = Cartesian3.normalize(\n    ellipsoid.cartographicToCartesian(end, scratchCart2),\n    scratchCart2\n  );\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\n    \"value\",\n    Math.abs(\n      Math.abs(Cartesian3.angleBetween(firstCartesian, lastCartesian)) - Math.PI\n    ),\n    0.0125\n  );\n  //>>includeEnd('debug');\n\n  vincentyInverseFormula(\n    ellipsoidGeodesic,\n    ellipsoid.maximumRadius,\n    ellipsoid.minimumRadius,\n    start.longitude,\n    start.latitude,\n    end.longitude,\n    end.latitude\n  );\n\n  ellipsoidGeodesic._start = Cartographic.clone(\n    start,\n    ellipsoidGeodesic._start\n  );\n  ellipsoidGeodesic._end = Cartographic.clone(end, ellipsoidGeodesic._end);\n  ellipsoidGeodesic._start.height = 0;\n  ellipsoidGeodesic._end.height = 0;\n\n  setConstants(ellipsoidGeodesic);\n}\n\n/**\n * Initializes a geodesic on the ellipsoid connecting the two provided planetodetic points.\n *\n * @alias EllipsoidGeodesic\n * @constructor\n *\n * @param {Cartographic} [start] The initial planetodetic point on the path.\n * @param {Cartographic} [end] The final planetodetic point on the path.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the geodesic lies.\n */\nfunction EllipsoidGeodesic(start, end, ellipsoid) {\n  var e = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  this._ellipsoid = e;\n  this._start = new Cartographic();\n  this._end = new Cartographic();\n\n  this._constants = {};\n  this._startHeading = undefined;\n  this._endHeading = undefined;\n  this._distance = undefined;\n  this._uSquared = undefined;\n\n  if (defined(start) && defined(end)) {\n    computeProperties(this, start, end, e);\n  }\n}\n\nObject.defineProperties(EllipsoidGeodesic.prototype, {\n  /**\n   * Gets the ellipsoid.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n\n  /**\n   * Gets the surface distance between the start and end point\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Number}\n   * @readonly\n   */\n  surfaceDistance: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"distance\", this._distance);\n      //>>includeEnd('debug');\n\n      return this._distance;\n    },\n  },\n\n  /**\n   * Gets the initial planetodetic point on the path.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Cartographic}\n   * @readonly\n   */\n  start: {\n    get: function () {\n      return this._start;\n    },\n  },\n\n  /**\n   * Gets the final planetodetic point on the path.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Cartographic}\n   * @readonly\n   */\n  end: {\n    get: function () {\n      return this._end;\n    },\n  },\n\n  /**\n   * Gets the heading at the initial point.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Number}\n   * @readonly\n   */\n  startHeading: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"distance\", this._distance);\n      //>>includeEnd('debug');\n\n      return this._startHeading;\n    },\n  },\n\n  /**\n   * Gets the heading at the final point.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Number}\n   * @readonly\n   */\n  endHeading: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"distance\", this._distance);\n      //>>includeEnd('debug');\n\n      return this._endHeading;\n    },\n  },\n});\n\n/**\n * Sets the start and end points of the geodesic\n *\n * @param {Cartographic} start The initial planetodetic point on the path.\n * @param {Cartographic} end The final planetodetic point on the path.\n */\nEllipsoidGeodesic.prototype.setEndPoints = function (start, end) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"start\", start);\n  Check.defined(\"end\", end);\n  //>>includeEnd('debug');\n\n  computeProperties(this, start, end, this._ellipsoid);\n};\n\n/**\n * Provides the location of a point at the indicated portion along the geodesic.\n *\n * @param {Number} fraction The portion of the distance between the initial and final points.\n * @param {Cartographic} result The object in which to store the result.\n * @returns {Cartographic} The location of the point along the geodesic.\n */\nEllipsoidGeodesic.prototype.interpolateUsingFraction = function (\n  fraction,\n  result\n) {\n  return this.interpolateUsingSurfaceDistance(\n    this._distance * fraction,\n    result\n  );\n};\n\n/**\n * Provides the location of a point at the indicated distance along the geodesic.\n *\n * @param {Number} distance The distance from the inital point to the point of interest along the geodesic\n * @param {Cartographic} result The object in which to store the result.\n * @returns {Cartographic} The location of the point along the geodesic.\n *\n * @exception {DeveloperError} start and end must be set before calling function interpolateUsingSurfaceDistance\n */\nEllipsoidGeodesic.prototype.interpolateUsingSurfaceDistance = function (\n  distance,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"distance\", this._distance);\n  //>>includeEnd('debug');\n\n  var constants = this._constants;\n\n  var s = constants.distanceRatio + distance / constants.b;\n\n  var cosine2S = Math.cos(2.0 * s);\n  var cosine4S = Math.cos(4.0 * s);\n  var cosine6S = Math.cos(6.0 * s);\n  var sine2S = Math.sin(2.0 * s);\n  var sine4S = Math.sin(4.0 * s);\n  var sine6S = Math.sin(6.0 * s);\n  var sine8S = Math.sin(8.0 * s);\n\n  var s2 = s * s;\n  var s3 = s * s2;\n\n  var u8Over256 = constants.u8Over256;\n  var u2Over4 = constants.u2Over4;\n  var u6Over64 = constants.u6Over64;\n  var u4Over16 = constants.u4Over16;\n  var sigma =\n    (2.0 * s3 * u8Over256 * cosine2S) / 3.0 +\n    s *\n      (1.0 -\n        u2Over4 +\n        (7.0 * u4Over16) / 4.0 -\n        (15.0 * u6Over64) / 4.0 +\n        (579.0 * u8Over256) / 64.0 -\n        (u4Over16 - (15.0 * u6Over64) / 4.0 + (187.0 * u8Over256) / 16.0) *\n          cosine2S -\n        ((5.0 * u6Over64) / 4.0 - (115.0 * u8Over256) / 16.0) * cosine4S -\n        (29.0 * u8Over256 * cosine6S) / 16.0) +\n    (u2Over4 / 2.0 -\n      u4Over16 +\n      (71.0 * u6Over64) / 32.0 -\n      (85.0 * u8Over256) / 16.0) *\n      sine2S +\n    ((5.0 * u4Over16) / 16.0 -\n      (5.0 * u6Over64) / 4.0 +\n      (383.0 * u8Over256) / 96.0) *\n      sine4S -\n    s2 *\n      ((u6Over64 - (11.0 * u8Over256) / 2.0) * sine2S +\n        (5.0 * u8Over256 * sine4S) / 2.0) +\n    ((29.0 * u6Over64) / 96.0 - (29.0 * u8Over256) / 16.0) * sine6S +\n    (539.0 * u8Over256 * sine8S) / 1536.0;\n\n  var theta = Math.asin(Math.sin(sigma) * constants.cosineAlpha);\n  var latitude = Math.atan((constants.a / constants.b) * Math.tan(theta));\n\n  // Redefine in terms of relative argument of latitude.\n  sigma = sigma - constants.sigma;\n\n  var cosineTwiceSigmaMidpoint = Math.cos(2.0 * constants.sigma + sigma);\n\n  var sineSigma = Math.sin(sigma);\n  var cosineSigma = Math.cos(sigma);\n\n  var cc = constants.cosineU * cosineSigma;\n  var ss = constants.sineU * sineSigma;\n\n  var lambda = Math.atan2(\n    sineSigma * constants.sineHeading,\n    cc - ss * constants.cosineHeading\n  );\n\n  var l =\n    lambda -\n    computeDeltaLambda(\n      constants.f,\n      constants.sineAlpha,\n      constants.cosineSquaredAlpha,\n      sigma,\n      sineSigma,\n      cosineSigma,\n      cosineTwiceSigmaMidpoint\n    );\n\n  if (defined(result)) {\n    result.longitude = this._start.longitude + l;\n    result.latitude = latitude;\n    result.height = 0.0;\n    return result;\n  }\n\n  return new Cartographic(this._start.longitude + l, latitude, 0.0);\n};\nexport default EllipsoidGeodesic;\n"]},"metadata":{},"sourceType":"module"}