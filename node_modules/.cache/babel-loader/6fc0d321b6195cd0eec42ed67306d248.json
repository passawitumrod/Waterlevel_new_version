{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Visibility from \"../Core/Visibility.js\";\nimport QuadtreeOccluders from \"./QuadtreeOccluders.js\";\nimport QuadtreeTile from \"./QuadtreeTile.js\";\nimport QuadtreeTileLoadState from \"./QuadtreeTileLoadState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport TileReplacementQueue from \"./TileReplacementQueue.js\";\nimport TileSelectionResult from \"./TileSelectionResult.js\";\n/**\n * Renders massive sets of data by utilizing level-of-detail and culling.  The globe surface is divided into\n * a quadtree of tiles with large, low-detail tiles at the root and small, high-detail tiles at the leaves.\n * The set of tiles to render is selected by projecting an estimate of the geometric error in a tile onto\n * the screen to estimate screen-space error, in pixels, which must be below a user-specified threshold.\n * The actual content of the tiles is arbitrary and is specified using a {@link QuadtreeTileProvider}.\n *\n * @alias QuadtreePrimitive\n * @constructor\n * @private\n *\n * @param {QuadtreeTileProvider} options.tileProvider The tile provider that loads, renders, and estimates\n *        the distance to individual tiles.\n * @param {Number} [options.maximumScreenSpaceError=2] The maximum screen-space error, in pixels, that is allowed.\n *        A higher maximum error will render fewer tiles and improve performance, while a lower\n *        value will improve visual quality.\n * @param {Number} [options.tileCacheSize=100] The maximum number of tiles that will be retained in the tile cache.\n *        Note that tiles will never be unloaded if they were used for rendering the last\n *        frame, so the actual number of resident tiles may be higher.  The value of\n *        this property will not affect visual quality.\n */\n\nfunction QuadtreePrimitive(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.tileProvider)) {\n    throw new DeveloperError(\"options.tileProvider is required.\");\n  }\n\n  if (defined(options.tileProvider.quadtree)) {\n    throw new DeveloperError(\"A QuadtreeTileProvider can only be used with a single QuadtreePrimitive\");\n  } //>>includeEnd('debug');\n\n\n  this._tileProvider = options.tileProvider;\n  this._tileProvider.quadtree = this;\n  this._debug = {\n    enableDebugOutput: false,\n    maxDepth: 0,\n    maxDepthVisited: 0,\n    tilesVisited: 0,\n    tilesCulled: 0,\n    tilesRendered: 0,\n    tilesWaitingForChildren: 0,\n    lastMaxDepth: -1,\n    lastMaxDepthVisited: -1,\n    lastTilesVisited: -1,\n    lastTilesCulled: -1,\n    lastTilesRendered: -1,\n    lastTilesWaitingForChildren: -1,\n    suspendLodUpdate: false\n  };\n  var tilingScheme = this._tileProvider.tilingScheme;\n  var ellipsoid = tilingScheme.ellipsoid;\n  this._tilesToRender = [];\n  this._tileLoadQueueHigh = []; // high priority tiles are preventing refinement\n\n  this._tileLoadQueueMedium = []; // medium priority tiles are being rendered\n\n  this._tileLoadQueueLow = []; // low priority tiles were refined past or are non-visible parts of quads.\n\n  this._tileReplacementQueue = new TileReplacementQueue();\n  this._levelZeroTiles = undefined;\n  this._loadQueueTimeSlice = 5.0;\n  this._tilesInvalidated = false;\n  this._addHeightCallbacks = [];\n  this._removeHeightCallbacks = [];\n  this._tileToUpdateHeights = [];\n  this._lastTileIndex = 0;\n  this._updateHeightsTimeSlice = 2.0; // If a culled tile contains _cameraPositionCartographic or _cameraReferenceFrameOriginCartographic, it will be marked\n  // TileSelectionResult.CULLED_BUT_NEEDED and added to the list of tiles to update heights,\n  // even though it is not rendered.\n  // These are updated each frame in `selectTilesForRendering`.\n\n  this._cameraPositionCartographic = undefined;\n  this._cameraReferenceFrameOriginCartographic = undefined;\n  /**\n   * Gets or sets the maximum screen-space error, in pixels, that is allowed.\n   * A higher maximum error will render fewer tiles and improve performance, while a lower\n   * value will improve visual quality.\n   * @type {Number}\n   * @default 2\n   */\n\n  this.maximumScreenSpaceError = defaultValue(options.maximumScreenSpaceError, 2);\n  /**\n   * Gets or sets the maximum number of tiles that will be retained in the tile cache.\n   * Note that tiles will never be unloaded if they were used for rendering the last\n   * frame, so the actual number of resident tiles may be higher.  The value of\n   * this property will not affect visual quality.\n   * @type {Number}\n   * @default 100\n   */\n\n  this.tileCacheSize = defaultValue(options.tileCacheSize, 100);\n  /**\n   * Gets or sets the number of loading descendant tiles that is considered \"too many\".\n   * If a tile has too many loading descendants, that tile will be loaded and rendered before any of\n   * its descendants are loaded and rendered. This means more feedback for the user that something\n   * is happening at the cost of a longer overall load time. Setting this to 0 will cause each\n   * tile level to be loaded successively, significantly increasing load time. Setting it to a large\n   * number (e.g. 1000) will minimize the number of tiles that are loaded but tend to make\n   * detail appear all at once after a long wait.\n   * @type {Number}\n   * @default 20\n   */\n\n  this.loadingDescendantLimit = 20;\n  /**\n   * Gets or sets a value indicating whether the ancestors of rendered tiles should be preloaded.\n   * Setting this to true optimizes the zoom-out experience and provides more detail in\n   * newly-exposed areas when panning. The down side is that it requires loading more tiles.\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.preloadAncestors = true;\n  /**\n   * Gets or sets a value indicating whether the siblings of rendered tiles should be preloaded.\n   * Setting this to true causes tiles with the same parent as a rendered tile to be loaded, even\n   * if they are culled. Setting this to true may provide a better panning experience at the\n   * cost of loading more tiles.\n   * @type {Boolean}\n   * @default false\n   */\n\n  this.preloadSiblings = false;\n  this._occluders = new QuadtreeOccluders({\n    ellipsoid: ellipsoid\n  });\n  this._tileLoadProgressEvent = new Event();\n  this._lastTileLoadQueueLength = 0;\n  this._lastSelectionFrameNumber = undefined;\n}\n\nObject.defineProperties(QuadtreePrimitive.prototype, {\n  /**\n   * Gets the provider of {@link QuadtreeTile} instances for this quadtree.\n   * @type {QuadtreeTile}\n   * @memberof QuadtreePrimitive.prototype\n   */\n  tileProvider: {\n    get: function () {\n      return this._tileProvider;\n    }\n  },\n\n  /**\n   * Gets an event that's raised when the length of the tile load queue has changed since the last render frame.  When the load queue is empty,\n   * all terrain and imagery for the current view have been loaded.  The event passes the new length of the tile load queue.\n   *\n   * @memberof QuadtreePrimitive.prototype\n   * @type {Event}\n   */\n  tileLoadProgressEvent: {\n    get: function () {\n      return this._tileLoadProgressEvent;\n    }\n  },\n  occluders: {\n    get: function () {\n      return this._occluders;\n    }\n  }\n});\n/**\n * Invalidates and frees all the tiles in the quadtree.  The tiles must be reloaded\n * before they can be displayed.\n *\n * @memberof QuadtreePrimitive\n */\n\nQuadtreePrimitive.prototype.invalidateAllTiles = function () {\n  this._tilesInvalidated = true;\n};\n\nfunction invalidateAllTiles(primitive) {\n  // Clear the replacement queue\n  var replacementQueue = primitive._tileReplacementQueue;\n  replacementQueue.head = undefined;\n  replacementQueue.tail = undefined;\n  replacementQueue.count = 0;\n  clearTileLoadQueue(primitive); // Free and recreate the level zero tiles.\n\n  var levelZeroTiles = primitive._levelZeroTiles;\n\n  if (defined(levelZeroTiles)) {\n    for (var i = 0; i < levelZeroTiles.length; ++i) {\n      var tile = levelZeroTiles[i];\n      var customData = tile.customData;\n      var customDataLength = customData.length;\n\n      for (var j = 0; j < customDataLength; ++j) {\n        var data = customData[j];\n        data.level = 0;\n\n        primitive._addHeightCallbacks.push(data);\n      }\n\n      levelZeroTiles[i].freeResources();\n    }\n  }\n\n  primitive._levelZeroTiles = undefined;\n\n  primitive._tileProvider.cancelReprojections();\n}\n/**\n * Invokes a specified function for each {@link QuadtreeTile} that is partially\n * or completely loaded.\n *\n * @param {Function} tileFunction The function to invoke for each loaded tile.  The\n *        function is passed a reference to the tile as its only parameter.\n */\n\n\nQuadtreePrimitive.prototype.forEachLoadedTile = function (tileFunction) {\n  var tile = this._tileReplacementQueue.head;\n\n  while (defined(tile)) {\n    if (tile.state !== QuadtreeTileLoadState.START) {\n      tileFunction(tile);\n    }\n\n    tile = tile.replacementNext;\n  }\n};\n/**\n * Invokes a specified function for each {@link QuadtreeTile} that was rendered\n * in the most recent frame.\n *\n * @param {Function} tileFunction The function to invoke for each rendered tile.  The\n *        function is passed a reference to the tile as its only parameter.\n */\n\n\nQuadtreePrimitive.prototype.forEachRenderedTile = function (tileFunction) {\n  var tilesRendered = this._tilesToRender;\n\n  for (var i = 0, len = tilesRendered.length; i < len; ++i) {\n    tileFunction(tilesRendered[i]);\n  }\n};\n/**\n * Calls the callback when a new tile is rendered that contains the given cartographic. The only parameter\n * is the cartesian position on the tile.\n *\n * @param {Cartographic} cartographic The cartographic position.\n * @param {Function} callback The function to be called when a new tile is loaded containing cartographic.\n * @returns {Function} The function to remove this callback from the quadtree.\n */\n\n\nQuadtreePrimitive.prototype.updateHeight = function (cartographic, callback) {\n  var primitive = this;\n  var object = {\n    positionOnEllipsoidSurface: undefined,\n    positionCartographic: cartographic,\n    level: -1,\n    callback: callback\n  };\n\n  object.removeFunc = function () {\n    var addedCallbacks = primitive._addHeightCallbacks;\n    var length = addedCallbacks.length;\n\n    for (var i = 0; i < length; ++i) {\n      if (addedCallbacks[i] === object) {\n        addedCallbacks.splice(i, 1);\n        break;\n      }\n    }\n\n    primitive._removeHeightCallbacks.push(object);\n  };\n\n  primitive._addHeightCallbacks.push(object);\n\n  return object.removeFunc;\n};\n/**\n * Updates the tile provider imagery and continues to process the tile load queue.\n * @private\n */\n\n\nQuadtreePrimitive.prototype.update = function (frameState) {\n  if (defined(this._tileProvider.update)) {\n    this._tileProvider.update(frameState);\n  }\n};\n\nfunction clearTileLoadQueue(primitive) {\n  var debug = primitive._debug;\n  debug.maxDepth = 0;\n  debug.maxDepthVisited = 0;\n  debug.tilesVisited = 0;\n  debug.tilesCulled = 0;\n  debug.tilesRendered = 0;\n  debug.tilesWaitingForChildren = 0;\n  primitive._tileLoadQueueHigh.length = 0;\n  primitive._tileLoadQueueMedium.length = 0;\n  primitive._tileLoadQueueLow.length = 0;\n}\n/**\n * Initializes values for a new render frame and prepare the tile load queue.\n * @private\n */\n\n\nQuadtreePrimitive.prototype.beginFrame = function (frameState) {\n  var passes = frameState.passes;\n\n  if (!passes.render) {\n    return;\n  }\n\n  if (this._tilesInvalidated) {\n    invalidateAllTiles(this);\n    this._tilesInvalidated = false;\n  } // Gets commands for any texture re-projections\n\n\n  this._tileProvider.initialize(frameState);\n\n  clearTileLoadQueue(this);\n\n  if (this._debug.suspendLodUpdate) {\n    return;\n  }\n\n  this._tileReplacementQueue.markStartOfRenderFrame();\n};\n/**\n * Selects new tiles to load based on the frame state and creates render commands.\n * @private\n */\n\n\nQuadtreePrimitive.prototype.render = function (frameState) {\n  var passes = frameState.passes;\n  var tileProvider = this._tileProvider;\n\n  if (passes.render) {\n    tileProvider.beginUpdate(frameState);\n    selectTilesForRendering(this, frameState);\n    createRenderCommandsForSelectedTiles(this, frameState);\n    tileProvider.endUpdate(frameState);\n  }\n\n  if (passes.pick && this._tilesToRender.length > 0) {\n    tileProvider.updateForPick(frameState);\n  }\n};\n/**\n * Checks if the load queue length has changed since the last time we raised a queue change event - if so, raises\n * a new change event at the end of the render cycle.\n * @private\n */\n\n\nfunction updateTileLoadProgress(primitive, frameState) {\n  var currentLoadQueueLength = primitive._tileLoadQueueHigh.length + primitive._tileLoadQueueMedium.length + primitive._tileLoadQueueLow.length;\n\n  if (currentLoadQueueLength !== primitive._lastTileLoadQueueLength || primitive._tilesInvalidated) {\n    frameState.afterRender.push(Event.prototype.raiseEvent.bind(primitive._tileLoadProgressEvent, currentLoadQueueLength));\n    primitive._lastTileLoadQueueLength = currentLoadQueueLength;\n  }\n\n  var debug = primitive._debug;\n\n  if (debug.enableDebugOutput && !debug.suspendLodUpdate) {\n    debug.maxDepth = primitive._tilesToRender.reduce(function (max, tile) {\n      return Math.max(max, tile.level);\n    }, -1);\n    debug.tilesRendered = primitive._tilesToRender.length;\n\n    if (debug.tilesVisited !== debug.lastTilesVisited || debug.tilesRendered !== debug.lastTilesRendered || debug.tilesCulled !== debug.lastTilesCulled || debug.maxDepth !== debug.lastMaxDepth || debug.tilesWaitingForChildren !== debug.lastTilesWaitingForChildren || debug.maxDepthVisited !== debug.lastMaxDepthVisited) {\n      console.log(\"Visited \" + debug.tilesVisited + \", Rendered: \" + debug.tilesRendered + \", Culled: \" + debug.tilesCulled + \", Max Depth Rendered: \" + debug.maxDepth + \", Max Depth Visited: \" + debug.maxDepthVisited + \", Waiting for children: \" + debug.tilesWaitingForChildren);\n      debug.lastTilesVisited = debug.tilesVisited;\n      debug.lastTilesRendered = debug.tilesRendered;\n      debug.lastTilesCulled = debug.tilesCulled;\n      debug.lastMaxDepth = debug.maxDepth;\n      debug.lastTilesWaitingForChildren = debug.tilesWaitingForChildren;\n      debug.lastMaxDepthVisited = debug.maxDepthVisited;\n    }\n  }\n}\n/**\n * Updates terrain heights.\n * @private\n */\n\n\nQuadtreePrimitive.prototype.endFrame = function (frameState) {\n  var passes = frameState.passes;\n\n  if (!passes.render || frameState.mode === SceneMode.MORPHING) {\n    // Only process the load queue for a single pass.\n    // Don't process the load queue or update heights during the morph flights.\n    return;\n  } // Load/create resources for terrain and imagery. Prepare texture re-projections for the next frame.\n\n\n  processTileLoadQueue(this, frameState);\n  updateHeights(this, frameState);\n  updateTileLoadProgress(this, frameState);\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @memberof QuadtreePrimitive\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see QuadtreePrimitive#destroy\n */\n\n\nQuadtreePrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @memberof QuadtreePrimitive\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * primitive = primitive && primitive.destroy();\n *\n * @see QuadtreePrimitive#isDestroyed\n */\n\n\nQuadtreePrimitive.prototype.destroy = function () {\n  this._tileProvider = this._tileProvider && this._tileProvider.destroy();\n};\n\nvar comparisonPoint;\nvar centerScratch = new Cartographic();\n\nfunction compareDistanceToPoint(a, b) {\n  var center = Rectangle.center(a.rectangle, centerScratch);\n  var alon = center.longitude - comparisonPoint.longitude;\n  var alat = center.latitude - comparisonPoint.latitude;\n  center = Rectangle.center(b.rectangle, centerScratch);\n  var blon = center.longitude - comparisonPoint.longitude;\n  var blat = center.latitude - comparisonPoint.latitude;\n  return alon * alon + alat * alat - (blon * blon + blat * blat);\n}\n\nvar cameraOriginScratch = new Cartesian3();\nvar rootTraversalDetails = [];\n\nfunction selectTilesForRendering(primitive, frameState) {\n  var debug = primitive._debug;\n\n  if (debug.suspendLodUpdate) {\n    return;\n  } // Clear the render list.\n\n\n  var tilesToRender = primitive._tilesToRender;\n  tilesToRender.length = 0; // We can't render anything before the level zero tiles exist.\n\n  var i;\n  var tileProvider = primitive._tileProvider;\n\n  if (!defined(primitive._levelZeroTiles)) {\n    if (tileProvider.ready) {\n      var tilingScheme = tileProvider.tilingScheme;\n      primitive._levelZeroTiles = QuadtreeTile.createLevelZeroTiles(tilingScheme);\n      var numberOfRootTiles = primitive._levelZeroTiles.length;\n\n      if (rootTraversalDetails.length < numberOfRootTiles) {\n        rootTraversalDetails = new Array(numberOfRootTiles);\n\n        for (i = 0; i < numberOfRootTiles; ++i) {\n          if (rootTraversalDetails[i] === undefined) {\n            rootTraversalDetails[i] = new TraversalDetails();\n          }\n        }\n      }\n    } else {\n      // Nothing to do until the provider is ready.\n      return;\n    }\n  }\n\n  primitive._occluders.ellipsoid.cameraPosition = frameState.camera.positionWC;\n  var tile;\n  var levelZeroTiles = primitive._levelZeroTiles;\n  var occluders = levelZeroTiles.length > 1 ? primitive._occluders : undefined; // Sort the level zero tiles by the distance from the center to the camera.\n  // The level zero tiles aren't necessarily a nice neat quad, so we can't use the\n  // quadtree ordering we use elsewhere in the tree\n\n  comparisonPoint = frameState.camera.positionCartographic;\n  levelZeroTiles.sort(compareDistanceToPoint);\n  var customDataAdded = primitive._addHeightCallbacks;\n  var customDataRemoved = primitive._removeHeightCallbacks;\n  var frameNumber = frameState.frameNumber;\n  var len;\n\n  if (customDataAdded.length > 0 || customDataRemoved.length > 0) {\n    for (i = 0, len = levelZeroTiles.length; i < len; ++i) {\n      tile = levelZeroTiles[i];\n\n      tile._updateCustomData(frameNumber, customDataAdded, customDataRemoved);\n    }\n\n    customDataAdded.length = 0;\n    customDataRemoved.length = 0;\n  }\n\n  var camera = frameState.camera;\n  primitive._cameraPositionCartographic = camera.positionCartographic;\n  var cameraFrameOrigin = Matrix4.getTranslation(camera.transform, cameraOriginScratch);\n  primitive._cameraReferenceFrameOriginCartographic = primitive.tileProvider.tilingScheme.ellipsoid.cartesianToCartographic(cameraFrameOrigin, primitive._cameraReferenceFrameOriginCartographic); // Traverse in depth-first, near-to-far order.\n\n  for (i = 0, len = levelZeroTiles.length; i < len; ++i) {\n    tile = levelZeroTiles[i];\n\n    primitive._tileReplacementQueue.markTileRendered(tile);\n\n    if (!tile.renderable) {\n      queueTileLoad(primitive, primitive._tileLoadQueueHigh, tile, frameState);\n      ++debug.tilesWaitingForChildren;\n    } else {\n      visitIfVisible(primitive, tile, tileProvider, frameState, occluders, false, rootTraversalDetails[i]);\n    }\n  }\n\n  primitive._lastSelectionFrameNumber = frameNumber;\n}\n\nfunction queueTileLoad(primitive, queue, tile, frameState) {\n  if (!tile.needsLoading) {\n    return;\n  }\n\n  if (primitive.tileProvider.computeTileLoadPriority !== undefined) {\n    tile._loadPriority = primitive.tileProvider.computeTileLoadPriority(tile, frameState);\n  }\n\n  queue.push(tile);\n}\n/**\n * Tracks details of traversing a tile while selecting tiles for rendering.\n * @alias TraversalDetails\n * @constructor\n * @private\n */\n\n\nfunction TraversalDetails() {\n  /**\n   * True if all selected (i.e. not culled or refined) tiles in this tile's subtree\n   * are renderable. If the subtree is renderable, we'll render it; no drama.\n   */\n  this.allAreRenderable = true;\n  /**\n   * True if any tiles in this tile's subtree were rendered last frame. If any\n   * were, we must render the subtree rather than this tile, because rendering\n   * this tile would cause detail to vanish that was visible last frame, and\n   * that's no good.\n   */\n\n  this.anyWereRenderedLastFrame = false;\n  /**\n   * Counts the number of selected tiles in this tile's subtree that are\n   * not yet ready to be rendered because they need more loading. Note that\n   * this value will _not_ necessarily be zero when\n   * {@link TraversalDetails#allAreRenderable} is true, for subtle reasons.\n   * When {@link TraversalDetails#allAreRenderable} and\n   * {@link TraversalDetails#anyWereRenderedLastFrame} are both false, we\n   * will render this tile instead of any tiles in its subtree and\n   * the `allAreRenderable` value for this tile will reflect only whether _this_\n   * tile is renderable. The `notYetRenderableCount` value, however, will still\n   * reflect the total number of tiles that we are waiting on, including the\n   * ones that we're not rendering. `notYetRenderableCount` is only reset\n   * when a subtree is removed from the render queue because the\n   * `notYetRenderableCount` exceeds the\n   * {@link QuadtreePrimitive#loadingDescendantLimit}.\n   */\n\n  this.notYetRenderableCount = 0;\n}\n\nfunction TraversalQuadDetails() {\n  this.southwest = new TraversalDetails();\n  this.southeast = new TraversalDetails();\n  this.northwest = new TraversalDetails();\n  this.northeast = new TraversalDetails();\n}\n\nTraversalQuadDetails.prototype.combine = function (result) {\n  var southwest = this.southwest;\n  var southeast = this.southeast;\n  var northwest = this.northwest;\n  var northeast = this.northeast;\n  result.allAreRenderable = southwest.allAreRenderable && southeast.allAreRenderable && northwest.allAreRenderable && northeast.allAreRenderable;\n  result.anyWereRenderedLastFrame = southwest.anyWereRenderedLastFrame || southeast.anyWereRenderedLastFrame || northwest.anyWereRenderedLastFrame || northeast.anyWereRenderedLastFrame;\n  result.notYetRenderableCount = southwest.notYetRenderableCount + southeast.notYetRenderableCount + northwest.notYetRenderableCount + northeast.notYetRenderableCount;\n};\n\nvar traversalQuadsByLevel = new Array(31); // level 30 tiles are ~2cm wide at the equator, should be good enough.\n\nfor (var i = 0; i < traversalQuadsByLevel.length; ++i) {\n  traversalQuadsByLevel[i] = new TraversalQuadDetails();\n}\n/**\n * Visits a tile for possible rendering. When we call this function with a tile:\n *\n *    * the tile has been determined to be visible (possibly based on a bounding volume that is not very tight-fitting)\n *    * its parent tile does _not_ meet the SSE (unless ancestorMeetsSse=true, see comments below)\n *    * the tile may or may not be renderable\n *\n * @private\n *\n * @param {Primitive} primitive The QuadtreePrimitive.\n * @param {FrameState} frameState The frame state.\n * @param {QuadtreeTile} tile The tile to visit\n * @param {Boolean} ancestorMeetsSse True if a tile higher in the tile tree already met the SSE and we're refining further only\n *                  to maintain detail while that higher tile loads.\n * @param {TraversalDetails} traveralDetails On return, populated with details of how the traversal of this tile went.\n */\n\n\nfunction visitTile(primitive, frameState, tile, ancestorMeetsSse, traversalDetails) {\n  var debug = primitive._debug;\n  ++debug.tilesVisited;\n\n  primitive._tileReplacementQueue.markTileRendered(tile);\n\n  tile._updateCustomData(frameState.frameNumber);\n\n  if (tile.level > debug.maxDepthVisited) {\n    debug.maxDepthVisited = tile.level;\n  }\n\n  var meetsSse = screenSpaceError(primitive, frameState, tile) < primitive.maximumScreenSpaceError;\n  var southwestChild = tile.southwestChild;\n  var southeastChild = tile.southeastChild;\n  var northwestChild = tile.northwestChild;\n  var northeastChild = tile.northeastChild;\n  var lastFrame = primitive._lastSelectionFrameNumber;\n  var lastFrameSelectionResult = tile._lastSelectionResultFrame === lastFrame ? tile._lastSelectionResult : TileSelectionResult.NONE;\n  var tileProvider = primitive.tileProvider;\n\n  if (meetsSse || ancestorMeetsSse) {\n    // This tile (or an ancestor) is the one we want to render this frame, but we'll do different things depending\n    // on the state of this tile and on what we did _last_ frame.\n    // We can render it if _any_ of the following are true:\n    // 1. We rendered it (or kicked it) last frame.\n    // 2. This tile was culled last frame, or it wasn't even visited because an ancestor was culled.\n    // 3. The tile is completely done loading.\n    // 4. a) Terrain is ready, and\n    //    b) All necessary imagery is ready. Necessary imagery is imagery that was rendered with this tile\n    //       or any descendants last frame. Such imagery is required because rendering this tile without\n    //       it would cause detail to disappear.\n    //\n    // Determining condition 4 is more expensive, so we check the others first.\n    //\n    // Note that even if we decide to render a tile here, it may later get \"kicked\" in favor of an ancestor.\n    var oneRenderedLastFrame = TileSelectionResult.originalResult(lastFrameSelectionResult) === TileSelectionResult.RENDERED;\n    var twoCulledOrNotVisited = TileSelectionResult.originalResult(lastFrameSelectionResult) === TileSelectionResult.CULLED || lastFrameSelectionResult === TileSelectionResult.NONE;\n    var threeCompletelyLoaded = tile.state === QuadtreeTileLoadState.DONE;\n    var renderable = oneRenderedLastFrame || twoCulledOrNotVisited || threeCompletelyLoaded;\n\n    if (!renderable) {\n      // Check the more expensive condition 4 above. This requires details of the thing\n      // we're rendering (e.g. the globe surface), so delegate it to the tile provider.\n      if (defined(tileProvider.canRenderWithoutLosingDetail)) {\n        renderable = tileProvider.canRenderWithoutLosingDetail(tile);\n      }\n    }\n\n    if (renderable) {\n      // Only load this tile if it (not just an ancestor) meets the SSE.\n      if (meetsSse) {\n        queueTileLoad(primitive, primitive._tileLoadQueueMedium, tile, frameState);\n      }\n\n      addTileToRenderList(primitive, tile);\n      traversalDetails.allAreRenderable = tile.renderable;\n      traversalDetails.anyWereRenderedLastFrame = lastFrameSelectionResult === TileSelectionResult.RENDERED;\n      traversalDetails.notYetRenderableCount = tile.renderable ? 0 : 1;\n      tile._lastSelectionResultFrame = frameState.frameNumber;\n      tile._lastSelectionResult = TileSelectionResult.RENDERED;\n\n      if (!traversalDetails.anyWereRenderedLastFrame) {\n        // Tile is newly-rendered this frame, so update its heights.\n        primitive._tileToUpdateHeights.push(tile);\n      }\n\n      return;\n    } // Otherwise, we can't render this tile (or its fill) because doing so would cause detail to disappear\n    // that was visible last frame. Instead, keep rendering any still-visible descendants that were rendered\n    // last frame and render fills for newly-visible descendants. E.g. if we were rendering level 15 last\n    // frame but this frame we want level 14 and the closest renderable level <= 14 is 0, rendering level\n    // zero would be pretty jarring so instead we keep rendering level 15 even though its SSE is better\n    // than required. So fall through to continue traversal...\n\n\n    ancestorMeetsSse = true; // Load this blocker tile with high priority, but only if this tile (not just an ancestor) meets the SSE.\n\n    if (meetsSse) {\n      queueTileLoad(primitive, primitive._tileLoadQueueHigh, tile, frameState);\n    }\n  }\n\n  if (tileProvider.canRefine(tile)) {\n    var allAreUpsampled = southwestChild.upsampledFromParent && southeastChild.upsampledFromParent && northwestChild.upsampledFromParent && northeastChild.upsampledFromParent;\n\n    if (allAreUpsampled) {\n      // No point in rendering the children because they're all upsampled.  Render this tile instead.\n      addTileToRenderList(primitive, tile); // Rendered tile that's not waiting on children loads with medium priority.\n\n      queueTileLoad(primitive, primitive._tileLoadQueueMedium, tile, frameState); // Make sure we don't unload the children and forget they're upsampled.\n\n      primitive._tileReplacementQueue.markTileRendered(southwestChild);\n\n      primitive._tileReplacementQueue.markTileRendered(southeastChild);\n\n      primitive._tileReplacementQueue.markTileRendered(northwestChild);\n\n      primitive._tileReplacementQueue.markTileRendered(northeastChild);\n\n      traversalDetails.allAreRenderable = tile.renderable;\n      traversalDetails.anyWereRenderedLastFrame = lastFrameSelectionResult === TileSelectionResult.RENDERED;\n      traversalDetails.notYetRenderableCount = tile.renderable ? 0 : 1;\n      tile._lastSelectionResultFrame = frameState.frameNumber;\n      tile._lastSelectionResult = TileSelectionResult.RENDERED;\n\n      if (!traversalDetails.anyWereRenderedLastFrame) {\n        // Tile is newly-rendered this frame, so update its heights.\n        primitive._tileToUpdateHeights.push(tile);\n      }\n\n      return;\n    } // SSE is not good enough, so refine.\n\n\n    tile._lastSelectionResultFrame = frameState.frameNumber;\n    tile._lastSelectionResult = TileSelectionResult.REFINED;\n    var firstRenderedDescendantIndex = primitive._tilesToRender.length;\n    var loadIndexLow = primitive._tileLoadQueueLow.length;\n    var loadIndexMedium = primitive._tileLoadQueueMedium.length;\n    var loadIndexHigh = primitive._tileLoadQueueHigh.length;\n    var tilesToUpdateHeightsIndex = primitive._tileToUpdateHeights.length; // No need to add the children to the load queue because they'll be added (if necessary) when they're visited.\n\n    visitVisibleChildrenNearToFar(primitive, southwestChild, southeastChild, northwestChild, northeastChild, frameState, ancestorMeetsSse, traversalDetails); // If no descendant tiles were added to the render list by the function above, it means they were all\n    // culled even though this tile was deemed visible. That's pretty common.\n\n    if (firstRenderedDescendantIndex !== primitive._tilesToRender.length) {\n      // At least one descendant tile was added to the render list.\n      // The traversalDetails tell us what happened while visiting the children.\n      var allAreRenderable = traversalDetails.allAreRenderable;\n      var anyWereRenderedLastFrame = traversalDetails.anyWereRenderedLastFrame;\n      var notYetRenderableCount = traversalDetails.notYetRenderableCount;\n      var queuedForLoad = false;\n\n      if (!allAreRenderable && !anyWereRenderedLastFrame) {\n        // Some of our descendants aren't ready to render yet, and none were rendered last frame,\n        // so kick them all out of the render list and render this tile instead. Continue to load them though!\n        // Mark the rendered descendants and their ancestors - up to this tile - as kicked.\n        var renderList = primitive._tilesToRender;\n\n        for (var i = firstRenderedDescendantIndex; i < renderList.length; ++i) {\n          var workTile = renderList[i];\n\n          while (workTile !== undefined && workTile._lastSelectionResult !== TileSelectionResult.KICKED && workTile !== tile) {\n            workTile._lastSelectionResult = TileSelectionResult.kick(workTile._lastSelectionResult);\n            workTile = workTile.parent;\n          }\n        } // Remove all descendants from the render list and add this tile.\n\n\n        primitive._tilesToRender.length = firstRenderedDescendantIndex;\n        primitive._tileToUpdateHeights.length = tilesToUpdateHeightsIndex;\n        addTileToRenderList(primitive, tile);\n        tile._lastSelectionResult = TileSelectionResult.RENDERED; // If we're waiting on heaps of descendants, the above will take too long. So in that case,\n        // load this tile INSTEAD of loading any of the descendants, and tell the up-level we're only waiting\n        // on this tile. Keep doing this until we actually manage to render this tile.\n\n        var wasRenderedLastFrame = lastFrameSelectionResult === TileSelectionResult.RENDERED;\n\n        if (!wasRenderedLastFrame && notYetRenderableCount > primitive.loadingDescendantLimit) {\n          // Remove all descendants from the load queues.\n          primitive._tileLoadQueueLow.length = loadIndexLow;\n          primitive._tileLoadQueueMedium.length = loadIndexMedium;\n          primitive._tileLoadQueueHigh.length = loadIndexHigh;\n          queueTileLoad(primitive, primitive._tileLoadQueueMedium, tile, frameState);\n          traversalDetails.notYetRenderableCount = tile.renderable ? 0 : 1;\n          queuedForLoad = true;\n        }\n\n        traversalDetails.allAreRenderable = tile.renderable;\n        traversalDetails.anyWereRenderedLastFrame = wasRenderedLastFrame;\n\n        if (!wasRenderedLastFrame) {\n          // Tile is newly-rendered this frame, so update its heights.\n          primitive._tileToUpdateHeights.push(tile);\n        }\n\n        ++debug.tilesWaitingForChildren;\n      }\n\n      if (primitive.preloadAncestors && !queuedForLoad) {\n        queueTileLoad(primitive, primitive._tileLoadQueueLow, tile, frameState);\n      }\n    }\n\n    return;\n  }\n\n  tile._lastSelectionResultFrame = frameState.frameNumber;\n  tile._lastSelectionResult = TileSelectionResult.RENDERED; // We'd like to refine but can't because we have no availability data for this tile's children,\n  // so we have no idea if refinining would involve a load or an upsample. We'll have to finish\n  // loading this tile first in order to find that out, so load this refinement blocker with\n  // high priority.\n\n  addTileToRenderList(primitive, tile);\n  queueTileLoad(primitive, primitive._tileLoadQueueHigh, tile, frameState);\n  traversalDetails.allAreRenderable = tile.renderable;\n  traversalDetails.anyWereRenderedLastFrame = lastFrameSelectionResult === TileSelectionResult.RENDERED;\n  traversalDetails.notYetRenderableCount = tile.renderable ? 0 : 1;\n}\n\nfunction visitVisibleChildrenNearToFar(primitive, southwest, southeast, northwest, northeast, frameState, ancestorMeetsSse, traversalDetails) {\n  var cameraPosition = frameState.camera.positionCartographic;\n  var tileProvider = primitive._tileProvider;\n  var occluders = primitive._occluders;\n  var quadDetails = traversalQuadsByLevel[southwest.level];\n  var southwestDetails = quadDetails.southwest;\n  var southeastDetails = quadDetails.southeast;\n  var northwestDetails = quadDetails.northwest;\n  var northeastDetails = quadDetails.northeast;\n\n  if (cameraPosition.longitude < southwest.rectangle.east) {\n    if (cameraPosition.latitude < southwest.rectangle.north) {\n      // Camera in southwest quadrant\n      visitIfVisible(primitive, southwest, tileProvider, frameState, occluders, ancestorMeetsSse, southwestDetails);\n      visitIfVisible(primitive, southeast, tileProvider, frameState, occluders, ancestorMeetsSse, southeastDetails);\n      visitIfVisible(primitive, northwest, tileProvider, frameState, occluders, ancestorMeetsSse, northwestDetails);\n      visitIfVisible(primitive, northeast, tileProvider, frameState, occluders, ancestorMeetsSse, northeastDetails);\n    } else {\n      // Camera in northwest quadrant\n      visitIfVisible(primitive, northwest, tileProvider, frameState, occluders, ancestorMeetsSse, northwestDetails);\n      visitIfVisible(primitive, southwest, tileProvider, frameState, occluders, ancestorMeetsSse, southwestDetails);\n      visitIfVisible(primitive, northeast, tileProvider, frameState, occluders, ancestorMeetsSse, northeastDetails);\n      visitIfVisible(primitive, southeast, tileProvider, frameState, occluders, ancestorMeetsSse, southeastDetails);\n    }\n  } else if (cameraPosition.latitude < southwest.rectangle.north) {\n    // Camera southeast quadrant\n    visitIfVisible(primitive, southeast, tileProvider, frameState, occluders, ancestorMeetsSse, southeastDetails);\n    visitIfVisible(primitive, southwest, tileProvider, frameState, occluders, ancestorMeetsSse, southwestDetails);\n    visitIfVisible(primitive, northeast, tileProvider, frameState, occluders, ancestorMeetsSse, northeastDetails);\n    visitIfVisible(primitive, northwest, tileProvider, frameState, occluders, ancestorMeetsSse, northwestDetails);\n  } else {\n    // Camera in northeast quadrant\n    visitIfVisible(primitive, northeast, tileProvider, frameState, occluders, ancestorMeetsSse, northeastDetails);\n    visitIfVisible(primitive, northwest, tileProvider, frameState, occluders, ancestorMeetsSse, northwestDetails);\n    visitIfVisible(primitive, southeast, tileProvider, frameState, occluders, ancestorMeetsSse, southeastDetails);\n    visitIfVisible(primitive, southwest, tileProvider, frameState, occluders, ancestorMeetsSse, southwestDetails);\n  }\n\n  quadDetails.combine(traversalDetails);\n}\n\nfunction containsNeededPosition(primitive, tile) {\n  var rectangle = tile.rectangle;\n  return defined(primitive._cameraPositionCartographic) && Rectangle.contains(rectangle, primitive._cameraPositionCartographic) || defined(primitive._cameraReferenceFrameOriginCartographic) && Rectangle.contains(rectangle, primitive._cameraReferenceFrameOriginCartographic);\n}\n\nfunction visitIfVisible(primitive, tile, tileProvider, frameState, occluders, ancestorMeetsSse, traversalDetails) {\n  if (tileProvider.computeTileVisibility(tile, frameState, occluders) !== Visibility.NONE) {\n    return visitTile(primitive, frameState, tile, ancestorMeetsSse, traversalDetails);\n  }\n\n  ++primitive._debug.tilesCulled;\n\n  primitive._tileReplacementQueue.markTileRendered(tile);\n\n  traversalDetails.allAreRenderable = true;\n  traversalDetails.anyWereRenderedLastFrame = false;\n  traversalDetails.notYetRenderableCount = 0;\n\n  if (containsNeededPosition(primitive, tile)) {\n    // Load the tile(s) that contains the camera's position and\n    // the origin of its reference frame with medium priority.\n    // But we only need to load until the terrain is available, no need to load imagery.\n    if (!defined(tile.data) || !defined(tile.data.vertexArray)) {\n      queueTileLoad(primitive, primitive._tileLoadQueueMedium, tile, frameState);\n    }\n\n    var lastFrame = primitive._lastSelectionFrameNumber;\n    var lastFrameSelectionResult = tile._lastSelectionResultFrame === lastFrame ? tile._lastSelectionResult : TileSelectionResult.NONE;\n\n    if (lastFrameSelectionResult !== TileSelectionResult.CULLED_BUT_NEEDED && lastFrameSelectionResult !== TileSelectionResult.RENDERED) {\n      primitive._tileToUpdateHeights.push(tile);\n    }\n\n    tile._lastSelectionResult = TileSelectionResult.CULLED_BUT_NEEDED;\n  } else if (primitive.preloadSiblings || tile.level === 0) {\n    // Load culled level zero tiles with low priority.\n    // For all other levels, only load culled tiles if preloadSiblings is enabled.\n    queueTileLoad(primitive, primitive._tileLoadQueueLow, tile, frameState);\n    tile._lastSelectionResult = TileSelectionResult.CULLED;\n  } else {\n    tile._lastSelectionResult = TileSelectionResult.CULLED;\n  }\n\n  tile._lastSelectionResultFrame = frameState.frameNumber;\n}\n\nfunction screenSpaceError(primitive, frameState, tile) {\n  if (frameState.mode === SceneMode.SCENE2D || frameState.camera.frustum instanceof OrthographicFrustum || frameState.camera.frustum instanceof OrthographicOffCenterFrustum) {\n    return screenSpaceError2D(primitive, frameState, tile);\n  }\n\n  var maxGeometricError = primitive._tileProvider.getLevelMaximumGeometricError(tile.level);\n\n  var distance = tile._distance;\n  var height = frameState.context.drawingBufferHeight;\n  var sseDenominator = frameState.camera.frustum.sseDenominator;\n  var error = maxGeometricError * height / (distance * sseDenominator);\n\n  if (frameState.fog.enabled) {\n    error -= CesiumMath.fog(distance, frameState.fog.density) * frameState.fog.sse;\n  }\n\n  error /= frameState.pixelRatio;\n  return error;\n}\n\nfunction screenSpaceError2D(primitive, frameState, tile) {\n  var camera = frameState.camera;\n  var frustum = camera.frustum;\n\n  if (defined(frustum._offCenterFrustum)) {\n    frustum = frustum._offCenterFrustum;\n  }\n\n  var context = frameState.context;\n  var width = context.drawingBufferWidth;\n  var height = context.drawingBufferHeight;\n\n  var maxGeometricError = primitive._tileProvider.getLevelMaximumGeometricError(tile.level);\n\n  var pixelSize = Math.max(frustum.top - frustum.bottom, frustum.right - frustum.left) / Math.max(width, height);\n  var error = maxGeometricError / pixelSize;\n\n  if (frameState.fog.enabled && frameState.mode !== SceneMode.SCENE2D) {\n    error -= CesiumMath.fog(tile._distance, frameState.fog.density) * frameState.fog.sse;\n  }\n\n  error /= frameState.pixelRatio;\n  return error;\n}\n\nfunction addTileToRenderList(primitive, tile) {\n  primitive._tilesToRender.push(tile);\n}\n\nfunction processTileLoadQueue(primitive, frameState) {\n  var tileLoadQueueHigh = primitive._tileLoadQueueHigh;\n  var tileLoadQueueMedium = primitive._tileLoadQueueMedium;\n  var tileLoadQueueLow = primitive._tileLoadQueueLow;\n\n  if (tileLoadQueueHigh.length === 0 && tileLoadQueueMedium.length === 0 && tileLoadQueueLow.length === 0) {\n    return;\n  } // Remove any tiles that were not used this frame beyond the number\n  // we're allowed to keep.\n\n\n  primitive._tileReplacementQueue.trimTiles(primitive.tileCacheSize);\n\n  var endTime = getTimestamp() + primitive._loadQueueTimeSlice;\n\n  var tileProvider = primitive._tileProvider;\n  var didSomeLoading = processSinglePriorityLoadQueue(primitive, frameState, tileProvider, endTime, tileLoadQueueHigh, false);\n  didSomeLoading = processSinglePriorityLoadQueue(primitive, frameState, tileProvider, endTime, tileLoadQueueMedium, didSomeLoading);\n  processSinglePriorityLoadQueue(primitive, frameState, tileProvider, endTime, tileLoadQueueLow, didSomeLoading);\n}\n\nfunction sortByLoadPriority(a, b) {\n  return a._loadPriority - b._loadPriority;\n}\n\nfunction processSinglePriorityLoadQueue(primitive, frameState, tileProvider, endTime, loadQueue, didSomeLoading) {\n  if (tileProvider.computeTileLoadPriority !== undefined) {\n    loadQueue.sort(sortByLoadPriority);\n  }\n\n  for (var i = 0, len = loadQueue.length; i < len && (getTimestamp() < endTime || !didSomeLoading); ++i) {\n    var tile = loadQueue[i];\n\n    primitive._tileReplacementQueue.markTileRendered(tile);\n\n    tileProvider.loadTile(frameState, tile);\n    didSomeLoading = true;\n  }\n\n  return didSomeLoading;\n}\n\nvar scratchRay = new Ray();\nvar scratchCartographic = new Cartographic();\nvar scratchPosition = new Cartesian3();\nvar scratchArray = [];\n\nfunction updateHeights(primitive, frameState) {\n  if (!primitive.tileProvider.ready) {\n    return;\n  }\n\n  var tryNextFrame = scratchArray;\n  tryNextFrame.length = 0;\n  var tilesToUpdateHeights = primitive._tileToUpdateHeights;\n  var terrainProvider = primitive._tileProvider.terrainProvider;\n  var startTime = getTimestamp();\n  var timeSlice = primitive._updateHeightsTimeSlice;\n  var endTime = startTime + timeSlice;\n  var mode = frameState.mode;\n  var projection = frameState.mapProjection;\n  var ellipsoid = primitive.tileProvider.tilingScheme.ellipsoid;\n  var i;\n\n  while (tilesToUpdateHeights.length > 0) {\n    var tile = tilesToUpdateHeights[0];\n\n    if (!defined(tile.data) || !defined(tile.data.mesh)) {\n      // Tile isn't loaded enough yet, so try again next frame if this tile is still\n      // being rendered.\n      var selectionResult = tile._lastSelectionResultFrame === primitive._lastSelectionFrameNumber ? tile._lastSelectionResult : TileSelectionResult.NONE;\n\n      if (selectionResult === TileSelectionResult.RENDERED || selectionResult === TileSelectionResult.CULLED_BUT_NEEDED) {\n        tryNextFrame.push(tile);\n      }\n\n      tilesToUpdateHeights.shift();\n      primitive._lastTileIndex = 0;\n      continue;\n    }\n\n    var customData = tile.customData;\n    var customDataLength = customData.length;\n    var timeSliceMax = false;\n\n    for (i = primitive._lastTileIndex; i < customDataLength; ++i) {\n      var data = customData[i];\n\n      if (tile.level > data.level) {\n        if (!defined(data.positionOnEllipsoidSurface)) {\n          // cartesian has to be on the ellipsoid surface for `ellipsoid.geodeticSurfaceNormal`\n          data.positionOnEllipsoidSurface = Cartesian3.fromRadians(data.positionCartographic.longitude, data.positionCartographic.latitude, 0.0, ellipsoid);\n        }\n\n        if (mode === SceneMode.SCENE3D) {\n          var surfaceNormal = ellipsoid.geodeticSurfaceNormal(data.positionOnEllipsoidSurface, scratchRay.direction); // compute origin point\n          // Try to find the intersection point between the surface normal and z-axis.\n          // minimum height (-11500.0) for the terrain set, need to get this information from the terrain provider\n\n          var rayOrigin = ellipsoid.getSurfaceNormalIntersectionWithZAxis(data.positionOnEllipsoidSurface, 11500.0, scratchRay.origin); // Theoretically, not with Earth datums, the intersection point can be outside the ellipsoid\n\n          if (!defined(rayOrigin)) {\n            // intersection point is outside the ellipsoid, try other value\n            // minimum height (-11500.0) for the terrain set, need to get this information from the terrain provider\n            var minimumHeight;\n\n            if (defined(tile.data.tileBoundingRegion)) {\n              minimumHeight = tile.data.tileBoundingRegion.minimumHeight;\n            }\n\n            var magnitude = Math.min(defaultValue(minimumHeight, 0.0), -11500.0); // multiply by the *positive* value of the magnitude\n\n            var vectorToMinimumPoint = Cartesian3.multiplyByScalar(surfaceNormal, Math.abs(magnitude) + 1, scratchPosition);\n            Cartesian3.subtract(data.positionOnEllipsoidSurface, vectorToMinimumPoint, scratchRay.origin);\n          }\n        } else {\n          Cartographic.clone(data.positionCartographic, scratchCartographic); // minimum height for the terrain set, need to get this information from the terrain provider\n\n          scratchCartographic.height = -11500.0;\n          projection.project(scratchCartographic, scratchPosition);\n          Cartesian3.fromElements(scratchPosition.z, scratchPosition.x, scratchPosition.y, scratchPosition);\n          Cartesian3.clone(scratchPosition, scratchRay.origin);\n          Cartesian3.clone(Cartesian3.UNIT_X, scratchRay.direction);\n        }\n\n        var position = tile.data.pick(scratchRay, mode, projection, false, scratchPosition);\n\n        if (defined(position)) {\n          data.callback(position);\n          data.level = tile.level;\n        }\n      } else if (tile.level === data.level) {\n        var children = tile.children;\n        var childrenLength = children.length;\n        var child;\n\n        for (var j = 0; j < childrenLength; ++j) {\n          child = children[j];\n\n          if (Rectangle.contains(child.rectangle, data.positionCartographic)) {\n            break;\n          }\n        }\n\n        var tileDataAvailable = terrainProvider.getTileDataAvailable(child.x, child.y, child.level);\n        var parentTile = tile.parent;\n\n        if (defined(tileDataAvailable) && !tileDataAvailable || defined(parentTile) && defined(parentTile.data) && defined(parentTile.data.terrainData) && !parentTile.data.terrainData.isChildAvailable(parentTile.x, parentTile.y, child.x, child.y)) {\n          data.removeFunc();\n        }\n      }\n\n      if (getTimestamp() >= endTime) {\n        timeSliceMax = true;\n        break;\n      }\n    }\n\n    if (timeSliceMax) {\n      primitive._lastTileIndex = i;\n      break;\n    } else {\n      primitive._lastTileIndex = 0;\n      tilesToUpdateHeights.shift();\n    }\n  }\n\n  for (i = 0; i < tryNextFrame.length; i++) {\n    tilesToUpdateHeights.push(tryNextFrame[i]);\n  }\n}\n\nfunction createRenderCommandsForSelectedTiles(primitive, frameState) {\n  var tileProvider = primitive._tileProvider;\n  var tilesToRender = primitive._tilesToRender;\n\n  for (var i = 0, len = tilesToRender.length; i < len; ++i) {\n    var tile = tilesToRender[i];\n    tileProvider.showTileThisFrame(tile, frameState);\n  }\n}\n\nexport default QuadtreePrimitive;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/QuadtreePrimitive.js"],"names":["Cartesian3","Cartographic","defaultValue","defined","DeveloperError","Event","getTimestamp","CesiumMath","Matrix4","OrthographicFrustum","OrthographicOffCenterFrustum","Ray","Rectangle","Visibility","QuadtreeOccluders","QuadtreeTile","QuadtreeTileLoadState","SceneMode","TileReplacementQueue","TileSelectionResult","QuadtreePrimitive","options","tileProvider","quadtree","_tileProvider","_debug","enableDebugOutput","maxDepth","maxDepthVisited","tilesVisited","tilesCulled","tilesRendered","tilesWaitingForChildren","lastMaxDepth","lastMaxDepthVisited","lastTilesVisited","lastTilesCulled","lastTilesRendered","lastTilesWaitingForChildren","suspendLodUpdate","tilingScheme","ellipsoid","_tilesToRender","_tileLoadQueueHigh","_tileLoadQueueMedium","_tileLoadQueueLow","_tileReplacementQueue","_levelZeroTiles","undefined","_loadQueueTimeSlice","_tilesInvalidated","_addHeightCallbacks","_removeHeightCallbacks","_tileToUpdateHeights","_lastTileIndex","_updateHeightsTimeSlice","_cameraPositionCartographic","_cameraReferenceFrameOriginCartographic","maximumScreenSpaceError","tileCacheSize","loadingDescendantLimit","preloadAncestors","preloadSiblings","_occluders","_tileLoadProgressEvent","_lastTileLoadQueueLength","_lastSelectionFrameNumber","Object","defineProperties","prototype","get","tileLoadProgressEvent","occluders","invalidateAllTiles","primitive","replacementQueue","head","tail","count","clearTileLoadQueue","levelZeroTiles","i","length","tile","customData","customDataLength","j","data","level","push","freeResources","cancelReprojections","forEachLoadedTile","tileFunction","state","START","replacementNext","forEachRenderedTile","len","updateHeight","cartographic","callback","object","positionOnEllipsoidSurface","positionCartographic","removeFunc","addedCallbacks","splice","update","frameState","debug","beginFrame","passes","render","initialize","markStartOfRenderFrame","beginUpdate","selectTilesForRendering","createRenderCommandsForSelectedTiles","endUpdate","pick","updateForPick","updateTileLoadProgress","currentLoadQueueLength","afterRender","raiseEvent","bind","reduce","max","Math","console","log","endFrame","mode","MORPHING","processTileLoadQueue","updateHeights","isDestroyed","destroy","comparisonPoint","centerScratch","compareDistanceToPoint","a","b","center","rectangle","alon","longitude","alat","latitude","blon","blat","cameraOriginScratch","rootTraversalDetails","tilesToRender","ready","createLevelZeroTiles","numberOfRootTiles","Array","TraversalDetails","cameraPosition","camera","positionWC","sort","customDataAdded","customDataRemoved","frameNumber","_updateCustomData","cameraFrameOrigin","getTranslation","transform","cartesianToCartographic","markTileRendered","renderable","queueTileLoad","visitIfVisible","queue","needsLoading","computeTileLoadPriority","_loadPriority","allAreRenderable","anyWereRenderedLastFrame","notYetRenderableCount","TraversalQuadDetails","southwest","southeast","northwest","northeast","combine","result","traversalQuadsByLevel","visitTile","ancestorMeetsSse","traversalDetails","meetsSse","screenSpaceError","southwestChild","southeastChild","northwestChild","northeastChild","lastFrame","lastFrameSelectionResult","_lastSelectionResultFrame","_lastSelectionResult","NONE","oneRenderedLastFrame","originalResult","RENDERED","twoCulledOrNotVisited","CULLED","threeCompletelyLoaded","DONE","canRenderWithoutLosingDetail","addTileToRenderList","canRefine","allAreUpsampled","upsampledFromParent","REFINED","firstRenderedDescendantIndex","loadIndexLow","loadIndexMedium","loadIndexHigh","tilesToUpdateHeightsIndex","visitVisibleChildrenNearToFar","queuedForLoad","renderList","workTile","KICKED","kick","parent","wasRenderedLastFrame","quadDetails","southwestDetails","southeastDetails","northwestDetails","northeastDetails","east","north","containsNeededPosition","contains","computeTileVisibility","vertexArray","CULLED_BUT_NEEDED","SCENE2D","frustum","screenSpaceError2D","maxGeometricError","getLevelMaximumGeometricError","distance","_distance","height","context","drawingBufferHeight","sseDenominator","error","fog","enabled","density","sse","pixelRatio","_offCenterFrustum","width","drawingBufferWidth","pixelSize","top","bottom","right","left","tileLoadQueueHigh","tileLoadQueueMedium","tileLoadQueueLow","trimTiles","endTime","didSomeLoading","processSinglePriorityLoadQueue","sortByLoadPriority","loadQueue","loadTile","scratchRay","scratchCartographic","scratchPosition","scratchArray","tryNextFrame","tilesToUpdateHeights","terrainProvider","startTime","timeSlice","projection","mapProjection","mesh","selectionResult","shift","timeSliceMax","fromRadians","SCENE3D","surfaceNormal","geodeticSurfaceNormal","direction","rayOrigin","getSurfaceNormalIntersectionWithZAxis","origin","minimumHeight","tileBoundingRegion","magnitude","min","vectorToMinimumPoint","multiplyByScalar","abs","subtract","clone","project","fromElements","z","x","y","UNIT_X","position","children","childrenLength","child","tileDataAvailable","getTileDataAvailable","parentTile","terrainData","isChildAvailable","showTileThisFrame"],"mappings":"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","sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Visibility from \"../Core/Visibility.js\";\nimport QuadtreeOccluders from \"./QuadtreeOccluders.js\";\nimport QuadtreeTile from \"./QuadtreeTile.js\";\nimport QuadtreeTileLoadState from \"./QuadtreeTileLoadState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport TileReplacementQueue from \"./TileReplacementQueue.js\";\nimport TileSelectionResult from \"./TileSelectionResult.js\";\n\n/**\n * Renders massive sets of data by utilizing level-of-detail and culling.  The globe surface is divided into\n * a quadtree of tiles with large, low-detail tiles at the root and small, high-detail tiles at the leaves.\n * The set of tiles to render is selected by projecting an estimate of the geometric error in a tile onto\n * the screen to estimate screen-space error, in pixels, which must be below a user-specified threshold.\n * The actual content of the tiles is arbitrary and is specified using a {@link QuadtreeTileProvider}.\n *\n * @alias QuadtreePrimitive\n * @constructor\n * @private\n *\n * @param {QuadtreeTileProvider} options.tileProvider The tile provider that loads, renders, and estimates\n *        the distance to individual tiles.\n * @param {Number} [options.maximumScreenSpaceError=2] The maximum screen-space error, in pixels, that is allowed.\n *        A higher maximum error will render fewer tiles and improve performance, while a lower\n *        value will improve visual quality.\n * @param {Number} [options.tileCacheSize=100] The maximum number of tiles that will be retained in the tile cache.\n *        Note that tiles will never be unloaded if they were used for rendering the last\n *        frame, so the actual number of resident tiles may be higher.  The value of\n *        this property will not affect visual quality.\n */\nfunction QuadtreePrimitive(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.tileProvider)) {\n    throw new DeveloperError(\"options.tileProvider is required.\");\n  }\n  if (defined(options.tileProvider.quadtree)) {\n    throw new DeveloperError(\n      \"A QuadtreeTileProvider can only be used with a single QuadtreePrimitive\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._tileProvider = options.tileProvider;\n  this._tileProvider.quadtree = this;\n\n  this._debug = {\n    enableDebugOutput: false,\n\n    maxDepth: 0,\n    maxDepthVisited: 0,\n    tilesVisited: 0,\n    tilesCulled: 0,\n    tilesRendered: 0,\n    tilesWaitingForChildren: 0,\n\n    lastMaxDepth: -1,\n    lastMaxDepthVisited: -1,\n    lastTilesVisited: -1,\n    lastTilesCulled: -1,\n    lastTilesRendered: -1,\n    lastTilesWaitingForChildren: -1,\n\n    suspendLodUpdate: false,\n  };\n\n  var tilingScheme = this._tileProvider.tilingScheme;\n  var ellipsoid = tilingScheme.ellipsoid;\n\n  this._tilesToRender = [];\n  this._tileLoadQueueHigh = []; // high priority tiles are preventing refinement\n  this._tileLoadQueueMedium = []; // medium priority tiles are being rendered\n  this._tileLoadQueueLow = []; // low priority tiles were refined past or are non-visible parts of quads.\n  this._tileReplacementQueue = new TileReplacementQueue();\n  this._levelZeroTiles = undefined;\n  this._loadQueueTimeSlice = 5.0;\n  this._tilesInvalidated = false;\n\n  this._addHeightCallbacks = [];\n  this._removeHeightCallbacks = [];\n\n  this._tileToUpdateHeights = [];\n  this._lastTileIndex = 0;\n  this._updateHeightsTimeSlice = 2.0;\n\n  // If a culled tile contains _cameraPositionCartographic or _cameraReferenceFrameOriginCartographic, it will be marked\n  // TileSelectionResult.CULLED_BUT_NEEDED and added to the list of tiles to update heights,\n  // even though it is not rendered.\n  // These are updated each frame in `selectTilesForRendering`.\n  this._cameraPositionCartographic = undefined;\n  this._cameraReferenceFrameOriginCartographic = undefined;\n\n  /**\n   * Gets or sets the maximum screen-space error, in pixels, that is allowed.\n   * A higher maximum error will render fewer tiles and improve performance, while a lower\n   * value will improve visual quality.\n   * @type {Number}\n   * @default 2\n   */\n  this.maximumScreenSpaceError = defaultValue(\n    options.maximumScreenSpaceError,\n    2\n  );\n\n  /**\n   * Gets or sets the maximum number of tiles that will be retained in the tile cache.\n   * Note that tiles will never be unloaded if they were used for rendering the last\n   * frame, so the actual number of resident tiles may be higher.  The value of\n   * this property will not affect visual quality.\n   * @type {Number}\n   * @default 100\n   */\n  this.tileCacheSize = defaultValue(options.tileCacheSize, 100);\n\n  /**\n   * Gets or sets the number of loading descendant tiles that is considered \"too many\".\n   * If a tile has too many loading descendants, that tile will be loaded and rendered before any of\n   * its descendants are loaded and rendered. This means more feedback for the user that something\n   * is happening at the cost of a longer overall load time. Setting this to 0 will cause each\n   * tile level to be loaded successively, significantly increasing load time. Setting it to a large\n   * number (e.g. 1000) will minimize the number of tiles that are loaded but tend to make\n   * detail appear all at once after a long wait.\n   * @type {Number}\n   * @default 20\n   */\n  this.loadingDescendantLimit = 20;\n\n  /**\n   * Gets or sets a value indicating whether the ancestors of rendered tiles should be preloaded.\n   * Setting this to true optimizes the zoom-out experience and provides more detail in\n   * newly-exposed areas when panning. The down side is that it requires loading more tiles.\n   * @type {Boolean}\n   * @default true\n   */\n  this.preloadAncestors = true;\n\n  /**\n   * Gets or sets a value indicating whether the siblings of rendered tiles should be preloaded.\n   * Setting this to true causes tiles with the same parent as a rendered tile to be loaded, even\n   * if they are culled. Setting this to true may provide a better panning experience at the\n   * cost of loading more tiles.\n   * @type {Boolean}\n   * @default false\n   */\n  this.preloadSiblings = false;\n\n  this._occluders = new QuadtreeOccluders({\n    ellipsoid: ellipsoid,\n  });\n\n  this._tileLoadProgressEvent = new Event();\n  this._lastTileLoadQueueLength = 0;\n\n  this._lastSelectionFrameNumber = undefined;\n}\n\nObject.defineProperties(QuadtreePrimitive.prototype, {\n  /**\n   * Gets the provider of {@link QuadtreeTile} instances for this quadtree.\n   * @type {QuadtreeTile}\n   * @memberof QuadtreePrimitive.prototype\n   */\n  tileProvider: {\n    get: function () {\n      return this._tileProvider;\n    },\n  },\n  /**\n   * Gets an event that's raised when the length of the tile load queue has changed since the last render frame.  When the load queue is empty,\n   * all terrain and imagery for the current view have been loaded.  The event passes the new length of the tile load queue.\n   *\n   * @memberof QuadtreePrimitive.prototype\n   * @type {Event}\n   */\n  tileLoadProgressEvent: {\n    get: function () {\n      return this._tileLoadProgressEvent;\n    },\n  },\n\n  occluders: {\n    get: function () {\n      return this._occluders;\n    },\n  },\n});\n\n/**\n * Invalidates and frees all the tiles in the quadtree.  The tiles must be reloaded\n * before they can be displayed.\n *\n * @memberof QuadtreePrimitive\n */\nQuadtreePrimitive.prototype.invalidateAllTiles = function () {\n  this._tilesInvalidated = true;\n};\n\nfunction invalidateAllTiles(primitive) {\n  // Clear the replacement queue\n  var replacementQueue = primitive._tileReplacementQueue;\n  replacementQueue.head = undefined;\n  replacementQueue.tail = undefined;\n  replacementQueue.count = 0;\n\n  clearTileLoadQueue(primitive);\n\n  // Free and recreate the level zero tiles.\n  var levelZeroTiles = primitive._levelZeroTiles;\n  if (defined(levelZeroTiles)) {\n    for (var i = 0; i < levelZeroTiles.length; ++i) {\n      var tile = levelZeroTiles[i];\n      var customData = tile.customData;\n      var customDataLength = customData.length;\n\n      for (var j = 0; j < customDataLength; ++j) {\n        var data = customData[j];\n        data.level = 0;\n        primitive._addHeightCallbacks.push(data);\n      }\n\n      levelZeroTiles[i].freeResources();\n    }\n  }\n\n  primitive._levelZeroTiles = undefined;\n\n  primitive._tileProvider.cancelReprojections();\n}\n\n/**\n * Invokes a specified function for each {@link QuadtreeTile} that is partially\n * or completely loaded.\n *\n * @param {Function} tileFunction The function to invoke for each loaded tile.  The\n *        function is passed a reference to the tile as its only parameter.\n */\nQuadtreePrimitive.prototype.forEachLoadedTile = function (tileFunction) {\n  var tile = this._tileReplacementQueue.head;\n  while (defined(tile)) {\n    if (tile.state !== QuadtreeTileLoadState.START) {\n      tileFunction(tile);\n    }\n    tile = tile.replacementNext;\n  }\n};\n\n/**\n * Invokes a specified function for each {@link QuadtreeTile} that was rendered\n * in the most recent frame.\n *\n * @param {Function} tileFunction The function to invoke for each rendered tile.  The\n *        function is passed a reference to the tile as its only parameter.\n */\nQuadtreePrimitive.prototype.forEachRenderedTile = function (tileFunction) {\n  var tilesRendered = this._tilesToRender;\n  for (var i = 0, len = tilesRendered.length; i < len; ++i) {\n    tileFunction(tilesRendered[i]);\n  }\n};\n\n/**\n * Calls the callback when a new tile is rendered that contains the given cartographic. The only parameter\n * is the cartesian position on the tile.\n *\n * @param {Cartographic} cartographic The cartographic position.\n * @param {Function} callback The function to be called when a new tile is loaded containing cartographic.\n * @returns {Function} The function to remove this callback from the quadtree.\n */\nQuadtreePrimitive.prototype.updateHeight = function (cartographic, callback) {\n  var primitive = this;\n  var object = {\n    positionOnEllipsoidSurface: undefined,\n    positionCartographic: cartographic,\n    level: -1,\n    callback: callback,\n  };\n\n  object.removeFunc = function () {\n    var addedCallbacks = primitive._addHeightCallbacks;\n    var length = addedCallbacks.length;\n    for (var i = 0; i < length; ++i) {\n      if (addedCallbacks[i] === object) {\n        addedCallbacks.splice(i, 1);\n        break;\n      }\n    }\n    primitive._removeHeightCallbacks.push(object);\n  };\n\n  primitive._addHeightCallbacks.push(object);\n  return object.removeFunc;\n};\n\n/**\n * Updates the tile provider imagery and continues to process the tile load queue.\n * @private\n */\nQuadtreePrimitive.prototype.update = function (frameState) {\n  if (defined(this._tileProvider.update)) {\n    this._tileProvider.update(frameState);\n  }\n};\n\nfunction clearTileLoadQueue(primitive) {\n  var debug = primitive._debug;\n  debug.maxDepth = 0;\n  debug.maxDepthVisited = 0;\n  debug.tilesVisited = 0;\n  debug.tilesCulled = 0;\n  debug.tilesRendered = 0;\n  debug.tilesWaitingForChildren = 0;\n\n  primitive._tileLoadQueueHigh.length = 0;\n  primitive._tileLoadQueueMedium.length = 0;\n  primitive._tileLoadQueueLow.length = 0;\n}\n\n/**\n * Initializes values for a new render frame and prepare the tile load queue.\n * @private\n */\nQuadtreePrimitive.prototype.beginFrame = function (frameState) {\n  var passes = frameState.passes;\n  if (!passes.render) {\n    return;\n  }\n\n  if (this._tilesInvalidated) {\n    invalidateAllTiles(this);\n    this._tilesInvalidated = false;\n  }\n\n  // Gets commands for any texture re-projections\n  this._tileProvider.initialize(frameState);\n\n  clearTileLoadQueue(this);\n\n  if (this._debug.suspendLodUpdate) {\n    return;\n  }\n\n  this._tileReplacementQueue.markStartOfRenderFrame();\n};\n\n/**\n * Selects new tiles to load based on the frame state and creates render commands.\n * @private\n */\nQuadtreePrimitive.prototype.render = function (frameState) {\n  var passes = frameState.passes;\n  var tileProvider = this._tileProvider;\n\n  if (passes.render) {\n    tileProvider.beginUpdate(frameState);\n\n    selectTilesForRendering(this, frameState);\n    createRenderCommandsForSelectedTiles(this, frameState);\n\n    tileProvider.endUpdate(frameState);\n  }\n\n  if (passes.pick && this._tilesToRender.length > 0) {\n    tileProvider.updateForPick(frameState);\n  }\n};\n\n/**\n * Checks if the load queue length has changed since the last time we raised a queue change event - if so, raises\n * a new change event at the end of the render cycle.\n * @private\n */\nfunction updateTileLoadProgress(primitive, frameState) {\n  var currentLoadQueueLength =\n    primitive._tileLoadQueueHigh.length +\n    primitive._tileLoadQueueMedium.length +\n    primitive._tileLoadQueueLow.length;\n\n  if (\n    currentLoadQueueLength !== primitive._lastTileLoadQueueLength ||\n    primitive._tilesInvalidated\n  ) {\n    frameState.afterRender.push(\n      Event.prototype.raiseEvent.bind(\n        primitive._tileLoadProgressEvent,\n        currentLoadQueueLength\n      )\n    );\n    primitive._lastTileLoadQueueLength = currentLoadQueueLength;\n  }\n\n  var debug = primitive._debug;\n  if (debug.enableDebugOutput && !debug.suspendLodUpdate) {\n    debug.maxDepth = primitive._tilesToRender.reduce(function (max, tile) {\n      return Math.max(max, tile.level);\n    }, -1);\n    debug.tilesRendered = primitive._tilesToRender.length;\n\n    if (\n      debug.tilesVisited !== debug.lastTilesVisited ||\n      debug.tilesRendered !== debug.lastTilesRendered ||\n      debug.tilesCulled !== debug.lastTilesCulled ||\n      debug.maxDepth !== debug.lastMaxDepth ||\n      debug.tilesWaitingForChildren !== debug.lastTilesWaitingForChildren ||\n      debug.maxDepthVisited !== debug.lastMaxDepthVisited\n    ) {\n      console.log(\n        \"Visited \" +\n          debug.tilesVisited +\n          \", Rendered: \" +\n          debug.tilesRendered +\n          \", Culled: \" +\n          debug.tilesCulled +\n          \", Max Depth Rendered: \" +\n          debug.maxDepth +\n          \", Max Depth Visited: \" +\n          debug.maxDepthVisited +\n          \", Waiting for children: \" +\n          debug.tilesWaitingForChildren\n      );\n\n      debug.lastTilesVisited = debug.tilesVisited;\n      debug.lastTilesRendered = debug.tilesRendered;\n      debug.lastTilesCulled = debug.tilesCulled;\n      debug.lastMaxDepth = debug.maxDepth;\n      debug.lastTilesWaitingForChildren = debug.tilesWaitingForChildren;\n      debug.lastMaxDepthVisited = debug.maxDepthVisited;\n    }\n  }\n}\n\n/**\n * Updates terrain heights.\n * @private\n */\nQuadtreePrimitive.prototype.endFrame = function (frameState) {\n  var passes = frameState.passes;\n  if (!passes.render || frameState.mode === SceneMode.MORPHING) {\n    // Only process the load queue for a single pass.\n    // Don't process the load queue or update heights during the morph flights.\n    return;\n  }\n\n  // Load/create resources for terrain and imagery. Prepare texture re-projections for the next frame.\n  processTileLoadQueue(this, frameState);\n  updateHeights(this, frameState);\n  updateTileLoadProgress(this, frameState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @memberof QuadtreePrimitive\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see QuadtreePrimitive#destroy\n */\nQuadtreePrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @memberof QuadtreePrimitive\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * primitive = primitive && primitive.destroy();\n *\n * @see QuadtreePrimitive#isDestroyed\n */\nQuadtreePrimitive.prototype.destroy = function () {\n  this._tileProvider = this._tileProvider && this._tileProvider.destroy();\n};\n\nvar comparisonPoint;\nvar centerScratch = new Cartographic();\nfunction compareDistanceToPoint(a, b) {\n  var center = Rectangle.center(a.rectangle, centerScratch);\n  var alon = center.longitude - comparisonPoint.longitude;\n  var alat = center.latitude - comparisonPoint.latitude;\n\n  center = Rectangle.center(b.rectangle, centerScratch);\n  var blon = center.longitude - comparisonPoint.longitude;\n  var blat = center.latitude - comparisonPoint.latitude;\n\n  return alon * alon + alat * alat - (blon * blon + blat * blat);\n}\n\nvar cameraOriginScratch = new Cartesian3();\nvar rootTraversalDetails = [];\n\nfunction selectTilesForRendering(primitive, frameState) {\n  var debug = primitive._debug;\n  if (debug.suspendLodUpdate) {\n    return;\n  }\n\n  // Clear the render list.\n  var tilesToRender = primitive._tilesToRender;\n  tilesToRender.length = 0;\n\n  // We can't render anything before the level zero tiles exist.\n  var i;\n  var tileProvider = primitive._tileProvider;\n  if (!defined(primitive._levelZeroTiles)) {\n    if (tileProvider.ready) {\n      var tilingScheme = tileProvider.tilingScheme;\n      primitive._levelZeroTiles = QuadtreeTile.createLevelZeroTiles(\n        tilingScheme\n      );\n      var numberOfRootTiles = primitive._levelZeroTiles.length;\n      if (rootTraversalDetails.length < numberOfRootTiles) {\n        rootTraversalDetails = new Array(numberOfRootTiles);\n        for (i = 0; i < numberOfRootTiles; ++i) {\n          if (rootTraversalDetails[i] === undefined) {\n            rootTraversalDetails[i] = new TraversalDetails();\n          }\n        }\n      }\n    } else {\n      // Nothing to do until the provider is ready.\n      return;\n    }\n  }\n\n  primitive._occluders.ellipsoid.cameraPosition = frameState.camera.positionWC;\n\n  var tile;\n  var levelZeroTiles = primitive._levelZeroTiles;\n  var occluders = levelZeroTiles.length > 1 ? primitive._occluders : undefined;\n\n  // Sort the level zero tiles by the distance from the center to the camera.\n  // The level zero tiles aren't necessarily a nice neat quad, so we can't use the\n  // quadtree ordering we use elsewhere in the tree\n  comparisonPoint = frameState.camera.positionCartographic;\n  levelZeroTiles.sort(compareDistanceToPoint);\n\n  var customDataAdded = primitive._addHeightCallbacks;\n  var customDataRemoved = primitive._removeHeightCallbacks;\n  var frameNumber = frameState.frameNumber;\n\n  var len;\n  if (customDataAdded.length > 0 || customDataRemoved.length > 0) {\n    for (i = 0, len = levelZeroTiles.length; i < len; ++i) {\n      tile = levelZeroTiles[i];\n      tile._updateCustomData(frameNumber, customDataAdded, customDataRemoved);\n    }\n\n    customDataAdded.length = 0;\n    customDataRemoved.length = 0;\n  }\n\n  var camera = frameState.camera;\n\n  primitive._cameraPositionCartographic = camera.positionCartographic;\n  var cameraFrameOrigin = Matrix4.getTranslation(\n    camera.transform,\n    cameraOriginScratch\n  );\n  primitive._cameraReferenceFrameOriginCartographic = primitive.tileProvider.tilingScheme.ellipsoid.cartesianToCartographic(\n    cameraFrameOrigin,\n    primitive._cameraReferenceFrameOriginCartographic\n  );\n\n  // Traverse in depth-first, near-to-far order.\n  for (i = 0, len = levelZeroTiles.length; i < len; ++i) {\n    tile = levelZeroTiles[i];\n    primitive._tileReplacementQueue.markTileRendered(tile);\n    if (!tile.renderable) {\n      queueTileLoad(primitive, primitive._tileLoadQueueHigh, tile, frameState);\n      ++debug.tilesWaitingForChildren;\n    } else {\n      visitIfVisible(\n        primitive,\n        tile,\n        tileProvider,\n        frameState,\n        occluders,\n        false,\n        rootTraversalDetails[i]\n      );\n    }\n  }\n\n  primitive._lastSelectionFrameNumber = frameNumber;\n}\n\nfunction queueTileLoad(primitive, queue, tile, frameState) {\n  if (!tile.needsLoading) {\n    return;\n  }\n\n  if (primitive.tileProvider.computeTileLoadPriority !== undefined) {\n    tile._loadPriority = primitive.tileProvider.computeTileLoadPriority(\n      tile,\n      frameState\n    );\n  }\n  queue.push(tile);\n}\n\n/**\n * Tracks details of traversing a tile while selecting tiles for rendering.\n * @alias TraversalDetails\n * @constructor\n * @private\n */\nfunction TraversalDetails() {\n  /**\n   * True if all selected (i.e. not culled or refined) tiles in this tile's subtree\n   * are renderable. If the subtree is renderable, we'll render it; no drama.\n   */\n  this.allAreRenderable = true;\n\n  /**\n   * True if any tiles in this tile's subtree were rendered last frame. If any\n   * were, we must render the subtree rather than this tile, because rendering\n   * this tile would cause detail to vanish that was visible last frame, and\n   * that's no good.\n   */\n  this.anyWereRenderedLastFrame = false;\n\n  /**\n   * Counts the number of selected tiles in this tile's subtree that are\n   * not yet ready to be rendered because they need more loading. Note that\n   * this value will _not_ necessarily be zero when\n   * {@link TraversalDetails#allAreRenderable} is true, for subtle reasons.\n   * When {@link TraversalDetails#allAreRenderable} and\n   * {@link TraversalDetails#anyWereRenderedLastFrame} are both false, we\n   * will render this tile instead of any tiles in its subtree and\n   * the `allAreRenderable` value for this tile will reflect only whether _this_\n   * tile is renderable. The `notYetRenderableCount` value, however, will still\n   * reflect the total number of tiles that we are waiting on, including the\n   * ones that we're not rendering. `notYetRenderableCount` is only reset\n   * when a subtree is removed from the render queue because the\n   * `notYetRenderableCount` exceeds the\n   * {@link QuadtreePrimitive#loadingDescendantLimit}.\n   */\n  this.notYetRenderableCount = 0;\n}\n\nfunction TraversalQuadDetails() {\n  this.southwest = new TraversalDetails();\n  this.southeast = new TraversalDetails();\n  this.northwest = new TraversalDetails();\n  this.northeast = new TraversalDetails();\n}\n\nTraversalQuadDetails.prototype.combine = function (result) {\n  var southwest = this.southwest;\n  var southeast = this.southeast;\n  var northwest = this.northwest;\n  var northeast = this.northeast;\n\n  result.allAreRenderable =\n    southwest.allAreRenderable &&\n    southeast.allAreRenderable &&\n    northwest.allAreRenderable &&\n    northeast.allAreRenderable;\n  result.anyWereRenderedLastFrame =\n    southwest.anyWereRenderedLastFrame ||\n    southeast.anyWereRenderedLastFrame ||\n    northwest.anyWereRenderedLastFrame ||\n    northeast.anyWereRenderedLastFrame;\n  result.notYetRenderableCount =\n    southwest.notYetRenderableCount +\n    southeast.notYetRenderableCount +\n    northwest.notYetRenderableCount +\n    northeast.notYetRenderableCount;\n};\n\nvar traversalQuadsByLevel = new Array(31); // level 30 tiles are ~2cm wide at the equator, should be good enough.\nfor (var i = 0; i < traversalQuadsByLevel.length; ++i) {\n  traversalQuadsByLevel[i] = new TraversalQuadDetails();\n}\n\n/**\n * Visits a tile for possible rendering. When we call this function with a tile:\n *\n *    * the tile has been determined to be visible (possibly based on a bounding volume that is not very tight-fitting)\n *    * its parent tile does _not_ meet the SSE (unless ancestorMeetsSse=true, see comments below)\n *    * the tile may or may not be renderable\n *\n * @private\n *\n * @param {Primitive} primitive The QuadtreePrimitive.\n * @param {FrameState} frameState The frame state.\n * @param {QuadtreeTile} tile The tile to visit\n * @param {Boolean} ancestorMeetsSse True if a tile higher in the tile tree already met the SSE and we're refining further only\n *                  to maintain detail while that higher tile loads.\n * @param {TraversalDetails} traveralDetails On return, populated with details of how the traversal of this tile went.\n */\nfunction visitTile(\n  primitive,\n  frameState,\n  tile,\n  ancestorMeetsSse,\n  traversalDetails\n) {\n  var debug = primitive._debug;\n\n  ++debug.tilesVisited;\n\n  primitive._tileReplacementQueue.markTileRendered(tile);\n  tile._updateCustomData(frameState.frameNumber);\n\n  if (tile.level > debug.maxDepthVisited) {\n    debug.maxDepthVisited = tile.level;\n  }\n\n  var meetsSse =\n    screenSpaceError(primitive, frameState, tile) <\n    primitive.maximumScreenSpaceError;\n\n  var southwestChild = tile.southwestChild;\n  var southeastChild = tile.southeastChild;\n  var northwestChild = tile.northwestChild;\n  var northeastChild = tile.northeastChild;\n\n  var lastFrame = primitive._lastSelectionFrameNumber;\n  var lastFrameSelectionResult =\n    tile._lastSelectionResultFrame === lastFrame\n      ? tile._lastSelectionResult\n      : TileSelectionResult.NONE;\n\n  var tileProvider = primitive.tileProvider;\n\n  if (meetsSse || ancestorMeetsSse) {\n    // This tile (or an ancestor) is the one we want to render this frame, but we'll do different things depending\n    // on the state of this tile and on what we did _last_ frame.\n\n    // We can render it if _any_ of the following are true:\n    // 1. We rendered it (or kicked it) last frame.\n    // 2. This tile was culled last frame, or it wasn't even visited because an ancestor was culled.\n    // 3. The tile is completely done loading.\n    // 4. a) Terrain is ready, and\n    //    b) All necessary imagery is ready. Necessary imagery is imagery that was rendered with this tile\n    //       or any descendants last frame. Such imagery is required because rendering this tile without\n    //       it would cause detail to disappear.\n    //\n    // Determining condition 4 is more expensive, so we check the others first.\n    //\n    // Note that even if we decide to render a tile here, it may later get \"kicked\" in favor of an ancestor.\n\n    var oneRenderedLastFrame =\n      TileSelectionResult.originalResult(lastFrameSelectionResult) ===\n      TileSelectionResult.RENDERED;\n    var twoCulledOrNotVisited =\n      TileSelectionResult.originalResult(lastFrameSelectionResult) ===\n        TileSelectionResult.CULLED ||\n      lastFrameSelectionResult === TileSelectionResult.NONE;\n    var threeCompletelyLoaded = tile.state === QuadtreeTileLoadState.DONE;\n\n    var renderable =\n      oneRenderedLastFrame || twoCulledOrNotVisited || threeCompletelyLoaded;\n\n    if (!renderable) {\n      // Check the more expensive condition 4 above. This requires details of the thing\n      // we're rendering (e.g. the globe surface), so delegate it to the tile provider.\n      if (defined(tileProvider.canRenderWithoutLosingDetail)) {\n        renderable = tileProvider.canRenderWithoutLosingDetail(tile);\n      }\n    }\n\n    if (renderable) {\n      // Only load this tile if it (not just an ancestor) meets the SSE.\n      if (meetsSse) {\n        queueTileLoad(\n          primitive,\n          primitive._tileLoadQueueMedium,\n          tile,\n          frameState\n        );\n      }\n      addTileToRenderList(primitive, tile);\n\n      traversalDetails.allAreRenderable = tile.renderable;\n      traversalDetails.anyWereRenderedLastFrame =\n        lastFrameSelectionResult === TileSelectionResult.RENDERED;\n      traversalDetails.notYetRenderableCount = tile.renderable ? 0 : 1;\n\n      tile._lastSelectionResultFrame = frameState.frameNumber;\n      tile._lastSelectionResult = TileSelectionResult.RENDERED;\n\n      if (!traversalDetails.anyWereRenderedLastFrame) {\n        // Tile is newly-rendered this frame, so update its heights.\n        primitive._tileToUpdateHeights.push(tile);\n      }\n\n      return;\n    }\n\n    // Otherwise, we can't render this tile (or its fill) because doing so would cause detail to disappear\n    // that was visible last frame. Instead, keep rendering any still-visible descendants that were rendered\n    // last frame and render fills for newly-visible descendants. E.g. if we were rendering level 15 last\n    // frame but this frame we want level 14 and the closest renderable level <= 14 is 0, rendering level\n    // zero would be pretty jarring so instead we keep rendering level 15 even though its SSE is better\n    // than required. So fall through to continue traversal...\n    ancestorMeetsSse = true;\n\n    // Load this blocker tile with high priority, but only if this tile (not just an ancestor) meets the SSE.\n    if (meetsSse) {\n      queueTileLoad(primitive, primitive._tileLoadQueueHigh, tile, frameState);\n    }\n  }\n\n  if (tileProvider.canRefine(tile)) {\n    var allAreUpsampled =\n      southwestChild.upsampledFromParent &&\n      southeastChild.upsampledFromParent &&\n      northwestChild.upsampledFromParent &&\n      northeastChild.upsampledFromParent;\n\n    if (allAreUpsampled) {\n      // No point in rendering the children because they're all upsampled.  Render this tile instead.\n      addTileToRenderList(primitive, tile);\n\n      // Rendered tile that's not waiting on children loads with medium priority.\n      queueTileLoad(\n        primitive,\n        primitive._tileLoadQueueMedium,\n        tile,\n        frameState\n      );\n\n      // Make sure we don't unload the children and forget they're upsampled.\n      primitive._tileReplacementQueue.markTileRendered(southwestChild);\n      primitive._tileReplacementQueue.markTileRendered(southeastChild);\n      primitive._tileReplacementQueue.markTileRendered(northwestChild);\n      primitive._tileReplacementQueue.markTileRendered(northeastChild);\n\n      traversalDetails.allAreRenderable = tile.renderable;\n      traversalDetails.anyWereRenderedLastFrame =\n        lastFrameSelectionResult === TileSelectionResult.RENDERED;\n      traversalDetails.notYetRenderableCount = tile.renderable ? 0 : 1;\n\n      tile._lastSelectionResultFrame = frameState.frameNumber;\n      tile._lastSelectionResult = TileSelectionResult.RENDERED;\n\n      if (!traversalDetails.anyWereRenderedLastFrame) {\n        // Tile is newly-rendered this frame, so update its heights.\n        primitive._tileToUpdateHeights.push(tile);\n      }\n\n      return;\n    }\n\n    // SSE is not good enough, so refine.\n    tile._lastSelectionResultFrame = frameState.frameNumber;\n    tile._lastSelectionResult = TileSelectionResult.REFINED;\n\n    var firstRenderedDescendantIndex = primitive._tilesToRender.length;\n    var loadIndexLow = primitive._tileLoadQueueLow.length;\n    var loadIndexMedium = primitive._tileLoadQueueMedium.length;\n    var loadIndexHigh = primitive._tileLoadQueueHigh.length;\n    var tilesToUpdateHeightsIndex = primitive._tileToUpdateHeights.length;\n\n    // No need to add the children to the load queue because they'll be added (if necessary) when they're visited.\n    visitVisibleChildrenNearToFar(\n      primitive,\n      southwestChild,\n      southeastChild,\n      northwestChild,\n      northeastChild,\n      frameState,\n      ancestorMeetsSse,\n      traversalDetails\n    );\n\n    // If no descendant tiles were added to the render list by the function above, it means they were all\n    // culled even though this tile was deemed visible. That's pretty common.\n\n    if (firstRenderedDescendantIndex !== primitive._tilesToRender.length) {\n      // At least one descendant tile was added to the render list.\n      // The traversalDetails tell us what happened while visiting the children.\n\n      var allAreRenderable = traversalDetails.allAreRenderable;\n      var anyWereRenderedLastFrame = traversalDetails.anyWereRenderedLastFrame;\n      var notYetRenderableCount = traversalDetails.notYetRenderableCount;\n      var queuedForLoad = false;\n\n      if (!allAreRenderable && !anyWereRenderedLastFrame) {\n        // Some of our descendants aren't ready to render yet, and none were rendered last frame,\n        // so kick them all out of the render list and render this tile instead. Continue to load them though!\n\n        // Mark the rendered descendants and their ancestors - up to this tile - as kicked.\n        var renderList = primitive._tilesToRender;\n        for (var i = firstRenderedDescendantIndex; i < renderList.length; ++i) {\n          var workTile = renderList[i];\n          while (\n            workTile !== undefined &&\n            workTile._lastSelectionResult !== TileSelectionResult.KICKED &&\n            workTile !== tile\n          ) {\n            workTile._lastSelectionResult = TileSelectionResult.kick(\n              workTile._lastSelectionResult\n            );\n            workTile = workTile.parent;\n          }\n        }\n\n        // Remove all descendants from the render list and add this tile.\n        primitive._tilesToRender.length = firstRenderedDescendantIndex;\n        primitive._tileToUpdateHeights.length = tilesToUpdateHeightsIndex;\n        addTileToRenderList(primitive, tile);\n\n        tile._lastSelectionResult = TileSelectionResult.RENDERED;\n\n        // If we're waiting on heaps of descendants, the above will take too long. So in that case,\n        // load this tile INSTEAD of loading any of the descendants, and tell the up-level we're only waiting\n        // on this tile. Keep doing this until we actually manage to render this tile.\n        var wasRenderedLastFrame =\n          lastFrameSelectionResult === TileSelectionResult.RENDERED;\n        if (\n          !wasRenderedLastFrame &&\n          notYetRenderableCount > primitive.loadingDescendantLimit\n        ) {\n          // Remove all descendants from the load queues.\n          primitive._tileLoadQueueLow.length = loadIndexLow;\n          primitive._tileLoadQueueMedium.length = loadIndexMedium;\n          primitive._tileLoadQueueHigh.length = loadIndexHigh;\n          queueTileLoad(\n            primitive,\n            primitive._tileLoadQueueMedium,\n            tile,\n            frameState\n          );\n          traversalDetails.notYetRenderableCount = tile.renderable ? 0 : 1;\n          queuedForLoad = true;\n        }\n\n        traversalDetails.allAreRenderable = tile.renderable;\n        traversalDetails.anyWereRenderedLastFrame = wasRenderedLastFrame;\n\n        if (!wasRenderedLastFrame) {\n          // Tile is newly-rendered this frame, so update its heights.\n          primitive._tileToUpdateHeights.push(tile);\n        }\n\n        ++debug.tilesWaitingForChildren;\n      }\n\n      if (primitive.preloadAncestors && !queuedForLoad) {\n        queueTileLoad(primitive, primitive._tileLoadQueueLow, tile, frameState);\n      }\n    }\n\n    return;\n  }\n\n  tile._lastSelectionResultFrame = frameState.frameNumber;\n  tile._lastSelectionResult = TileSelectionResult.RENDERED;\n\n  // We'd like to refine but can't because we have no availability data for this tile's children,\n  // so we have no idea if refinining would involve a load or an upsample. We'll have to finish\n  // loading this tile first in order to find that out, so load this refinement blocker with\n  // high priority.\n  addTileToRenderList(primitive, tile);\n  queueTileLoad(primitive, primitive._tileLoadQueueHigh, tile, frameState);\n\n  traversalDetails.allAreRenderable = tile.renderable;\n  traversalDetails.anyWereRenderedLastFrame =\n    lastFrameSelectionResult === TileSelectionResult.RENDERED;\n  traversalDetails.notYetRenderableCount = tile.renderable ? 0 : 1;\n}\n\nfunction visitVisibleChildrenNearToFar(\n  primitive,\n  southwest,\n  southeast,\n  northwest,\n  northeast,\n  frameState,\n  ancestorMeetsSse,\n  traversalDetails\n) {\n  var cameraPosition = frameState.camera.positionCartographic;\n  var tileProvider = primitive._tileProvider;\n  var occluders = primitive._occluders;\n\n  var quadDetails = traversalQuadsByLevel[southwest.level];\n  var southwestDetails = quadDetails.southwest;\n  var southeastDetails = quadDetails.southeast;\n  var northwestDetails = quadDetails.northwest;\n  var northeastDetails = quadDetails.northeast;\n\n  if (cameraPosition.longitude < southwest.rectangle.east) {\n    if (cameraPosition.latitude < southwest.rectangle.north) {\n      // Camera in southwest quadrant\n      visitIfVisible(\n        primitive,\n        southwest,\n        tileProvider,\n        frameState,\n        occluders,\n        ancestorMeetsSse,\n        southwestDetails\n      );\n      visitIfVisible(\n        primitive,\n        southeast,\n        tileProvider,\n        frameState,\n        occluders,\n        ancestorMeetsSse,\n        southeastDetails\n      );\n      visitIfVisible(\n        primitive,\n        northwest,\n        tileProvider,\n        frameState,\n        occluders,\n        ancestorMeetsSse,\n        northwestDetails\n      );\n      visitIfVisible(\n        primitive,\n        northeast,\n        tileProvider,\n        frameState,\n        occluders,\n        ancestorMeetsSse,\n        northeastDetails\n      );\n    } else {\n      // Camera in northwest quadrant\n      visitIfVisible(\n        primitive,\n        northwest,\n        tileProvider,\n        frameState,\n        occluders,\n        ancestorMeetsSse,\n        northwestDetails\n      );\n      visitIfVisible(\n        primitive,\n        southwest,\n        tileProvider,\n        frameState,\n        occluders,\n        ancestorMeetsSse,\n        southwestDetails\n      );\n      visitIfVisible(\n        primitive,\n        northeast,\n        tileProvider,\n        frameState,\n        occluders,\n        ancestorMeetsSse,\n        northeastDetails\n      );\n      visitIfVisible(\n        primitive,\n        southeast,\n        tileProvider,\n        frameState,\n        occluders,\n        ancestorMeetsSse,\n        southeastDetails\n      );\n    }\n  } else if (cameraPosition.latitude < southwest.rectangle.north) {\n    // Camera southeast quadrant\n    visitIfVisible(\n      primitive,\n      southeast,\n      tileProvider,\n      frameState,\n      occluders,\n      ancestorMeetsSse,\n      southeastDetails\n    );\n    visitIfVisible(\n      primitive,\n      southwest,\n      tileProvider,\n      frameState,\n      occluders,\n      ancestorMeetsSse,\n      southwestDetails\n    );\n    visitIfVisible(\n      primitive,\n      northeast,\n      tileProvider,\n      frameState,\n      occluders,\n      ancestorMeetsSse,\n      northeastDetails\n    );\n    visitIfVisible(\n      primitive,\n      northwest,\n      tileProvider,\n      frameState,\n      occluders,\n      ancestorMeetsSse,\n      northwestDetails\n    );\n  } else {\n    // Camera in northeast quadrant\n    visitIfVisible(\n      primitive,\n      northeast,\n      tileProvider,\n      frameState,\n      occluders,\n      ancestorMeetsSse,\n      northeastDetails\n    );\n    visitIfVisible(\n      primitive,\n      northwest,\n      tileProvider,\n      frameState,\n      occluders,\n      ancestorMeetsSse,\n      northwestDetails\n    );\n    visitIfVisible(\n      primitive,\n      southeast,\n      tileProvider,\n      frameState,\n      occluders,\n      ancestorMeetsSse,\n      southeastDetails\n    );\n    visitIfVisible(\n      primitive,\n      southwest,\n      tileProvider,\n      frameState,\n      occluders,\n      ancestorMeetsSse,\n      southwestDetails\n    );\n  }\n\n  quadDetails.combine(traversalDetails);\n}\n\nfunction containsNeededPosition(primitive, tile) {\n  var rectangle = tile.rectangle;\n  return (\n    (defined(primitive._cameraPositionCartographic) &&\n      Rectangle.contains(rectangle, primitive._cameraPositionCartographic)) ||\n    (defined(primitive._cameraReferenceFrameOriginCartographic) &&\n      Rectangle.contains(\n        rectangle,\n        primitive._cameraReferenceFrameOriginCartographic\n      ))\n  );\n}\n\nfunction visitIfVisible(\n  primitive,\n  tile,\n  tileProvider,\n  frameState,\n  occluders,\n  ancestorMeetsSse,\n  traversalDetails\n) {\n  if (\n    tileProvider.computeTileVisibility(tile, frameState, occluders) !==\n    Visibility.NONE\n  ) {\n    return visitTile(\n      primitive,\n      frameState,\n      tile,\n      ancestorMeetsSse,\n      traversalDetails\n    );\n  }\n\n  ++primitive._debug.tilesCulled;\n  primitive._tileReplacementQueue.markTileRendered(tile);\n\n  traversalDetails.allAreRenderable = true;\n  traversalDetails.anyWereRenderedLastFrame = false;\n  traversalDetails.notYetRenderableCount = 0;\n\n  if (containsNeededPosition(primitive, tile)) {\n    // Load the tile(s) that contains the camera's position and\n    // the origin of its reference frame with medium priority.\n    // But we only need to load until the terrain is available, no need to load imagery.\n    if (!defined(tile.data) || !defined(tile.data.vertexArray)) {\n      queueTileLoad(\n        primitive,\n        primitive._tileLoadQueueMedium,\n        tile,\n        frameState\n      );\n    }\n\n    var lastFrame = primitive._lastSelectionFrameNumber;\n    var lastFrameSelectionResult =\n      tile._lastSelectionResultFrame === lastFrame\n        ? tile._lastSelectionResult\n        : TileSelectionResult.NONE;\n    if (\n      lastFrameSelectionResult !== TileSelectionResult.CULLED_BUT_NEEDED &&\n      lastFrameSelectionResult !== TileSelectionResult.RENDERED\n    ) {\n      primitive._tileToUpdateHeights.push(tile);\n    }\n\n    tile._lastSelectionResult = TileSelectionResult.CULLED_BUT_NEEDED;\n  } else if (primitive.preloadSiblings || tile.level === 0) {\n    // Load culled level zero tiles with low priority.\n    // For all other levels, only load culled tiles if preloadSiblings is enabled.\n    queueTileLoad(primitive, primitive._tileLoadQueueLow, tile, frameState);\n    tile._lastSelectionResult = TileSelectionResult.CULLED;\n  } else {\n    tile._lastSelectionResult = TileSelectionResult.CULLED;\n  }\n\n  tile._lastSelectionResultFrame = frameState.frameNumber;\n}\n\nfunction screenSpaceError(primitive, frameState, tile) {\n  if (\n    frameState.mode === SceneMode.SCENE2D ||\n    frameState.camera.frustum instanceof OrthographicFrustum ||\n    frameState.camera.frustum instanceof OrthographicOffCenterFrustum\n  ) {\n    return screenSpaceError2D(primitive, frameState, tile);\n  }\n\n  var maxGeometricError = primitive._tileProvider.getLevelMaximumGeometricError(\n    tile.level\n  );\n\n  var distance = tile._distance;\n  var height = frameState.context.drawingBufferHeight;\n  var sseDenominator = frameState.camera.frustum.sseDenominator;\n\n  var error = (maxGeometricError * height) / (distance * sseDenominator);\n\n  if (frameState.fog.enabled) {\n    error -=\n      CesiumMath.fog(distance, frameState.fog.density) * frameState.fog.sse;\n  }\n\n  error /= frameState.pixelRatio;\n\n  return error;\n}\n\nfunction screenSpaceError2D(primitive, frameState, tile) {\n  var camera = frameState.camera;\n  var frustum = camera.frustum;\n  if (defined(frustum._offCenterFrustum)) {\n    frustum = frustum._offCenterFrustum;\n  }\n\n  var context = frameState.context;\n  var width = context.drawingBufferWidth;\n  var height = context.drawingBufferHeight;\n\n  var maxGeometricError = primitive._tileProvider.getLevelMaximumGeometricError(\n    tile.level\n  );\n  var pixelSize =\n    Math.max(frustum.top - frustum.bottom, frustum.right - frustum.left) /\n    Math.max(width, height);\n  var error = maxGeometricError / pixelSize;\n\n  if (frameState.fog.enabled && frameState.mode !== SceneMode.SCENE2D) {\n    error -=\n      CesiumMath.fog(tile._distance, frameState.fog.density) *\n      frameState.fog.sse;\n  }\n\n  error /= frameState.pixelRatio;\n\n  return error;\n}\n\nfunction addTileToRenderList(primitive, tile) {\n  primitive._tilesToRender.push(tile);\n}\n\nfunction processTileLoadQueue(primitive, frameState) {\n  var tileLoadQueueHigh = primitive._tileLoadQueueHigh;\n  var tileLoadQueueMedium = primitive._tileLoadQueueMedium;\n  var tileLoadQueueLow = primitive._tileLoadQueueLow;\n\n  if (\n    tileLoadQueueHigh.length === 0 &&\n    tileLoadQueueMedium.length === 0 &&\n    tileLoadQueueLow.length === 0\n  ) {\n    return;\n  }\n\n  // Remove any tiles that were not used this frame beyond the number\n  // we're allowed to keep.\n  primitive._tileReplacementQueue.trimTiles(primitive.tileCacheSize);\n\n  var endTime = getTimestamp() + primitive._loadQueueTimeSlice;\n  var tileProvider = primitive._tileProvider;\n\n  var didSomeLoading = processSinglePriorityLoadQueue(\n    primitive,\n    frameState,\n    tileProvider,\n    endTime,\n    tileLoadQueueHigh,\n    false\n  );\n  didSomeLoading = processSinglePriorityLoadQueue(\n    primitive,\n    frameState,\n    tileProvider,\n    endTime,\n    tileLoadQueueMedium,\n    didSomeLoading\n  );\n  processSinglePriorityLoadQueue(\n    primitive,\n    frameState,\n    tileProvider,\n    endTime,\n    tileLoadQueueLow,\n    didSomeLoading\n  );\n}\n\nfunction sortByLoadPriority(a, b) {\n  return a._loadPriority - b._loadPriority;\n}\n\nfunction processSinglePriorityLoadQueue(\n  primitive,\n  frameState,\n  tileProvider,\n  endTime,\n  loadQueue,\n  didSomeLoading\n) {\n  if (tileProvider.computeTileLoadPriority !== undefined) {\n    loadQueue.sort(sortByLoadPriority);\n  }\n\n  for (\n    var i = 0, len = loadQueue.length;\n    i < len && (getTimestamp() < endTime || !didSomeLoading);\n    ++i\n  ) {\n    var tile = loadQueue[i];\n    primitive._tileReplacementQueue.markTileRendered(tile);\n    tileProvider.loadTile(frameState, tile);\n    didSomeLoading = true;\n  }\n\n  return didSomeLoading;\n}\n\nvar scratchRay = new Ray();\nvar scratchCartographic = new Cartographic();\nvar scratchPosition = new Cartesian3();\nvar scratchArray = [];\n\nfunction updateHeights(primitive, frameState) {\n  if (!primitive.tileProvider.ready) {\n    return;\n  }\n\n  var tryNextFrame = scratchArray;\n  tryNextFrame.length = 0;\n  var tilesToUpdateHeights = primitive._tileToUpdateHeights;\n  var terrainProvider = primitive._tileProvider.terrainProvider;\n\n  var startTime = getTimestamp();\n  var timeSlice = primitive._updateHeightsTimeSlice;\n  var endTime = startTime + timeSlice;\n\n  var mode = frameState.mode;\n  var projection = frameState.mapProjection;\n  var ellipsoid = primitive.tileProvider.tilingScheme.ellipsoid;\n  var i;\n\n  while (tilesToUpdateHeights.length > 0) {\n    var tile = tilesToUpdateHeights[0];\n    if (!defined(tile.data) || !defined(tile.data.mesh)) {\n      // Tile isn't loaded enough yet, so try again next frame if this tile is still\n      // being rendered.\n      var selectionResult =\n        tile._lastSelectionResultFrame === primitive._lastSelectionFrameNumber\n          ? tile._lastSelectionResult\n          : TileSelectionResult.NONE;\n      if (\n        selectionResult === TileSelectionResult.RENDERED ||\n        selectionResult === TileSelectionResult.CULLED_BUT_NEEDED\n      ) {\n        tryNextFrame.push(tile);\n      }\n      tilesToUpdateHeights.shift();\n      primitive._lastTileIndex = 0;\n      continue;\n    }\n    var customData = tile.customData;\n    var customDataLength = customData.length;\n\n    var timeSliceMax = false;\n    for (i = primitive._lastTileIndex; i < customDataLength; ++i) {\n      var data = customData[i];\n\n      if (tile.level > data.level) {\n        if (!defined(data.positionOnEllipsoidSurface)) {\n          // cartesian has to be on the ellipsoid surface for `ellipsoid.geodeticSurfaceNormal`\n          data.positionOnEllipsoidSurface = Cartesian3.fromRadians(\n            data.positionCartographic.longitude,\n            data.positionCartographic.latitude,\n            0.0,\n            ellipsoid\n          );\n        }\n\n        if (mode === SceneMode.SCENE3D) {\n          var surfaceNormal = ellipsoid.geodeticSurfaceNormal(\n            data.positionOnEllipsoidSurface,\n            scratchRay.direction\n          );\n\n          // compute origin point\n\n          // Try to find the intersection point between the surface normal and z-axis.\n          // minimum height (-11500.0) for the terrain set, need to get this information from the terrain provider\n          var rayOrigin = ellipsoid.getSurfaceNormalIntersectionWithZAxis(\n            data.positionOnEllipsoidSurface,\n            11500.0,\n            scratchRay.origin\n          );\n\n          // Theoretically, not with Earth datums, the intersection point can be outside the ellipsoid\n          if (!defined(rayOrigin)) {\n            // intersection point is outside the ellipsoid, try other value\n            // minimum height (-11500.0) for the terrain set, need to get this information from the terrain provider\n            var minimumHeight;\n            if (defined(tile.data.tileBoundingRegion)) {\n              minimumHeight = tile.data.tileBoundingRegion.minimumHeight;\n            }\n            var magnitude = Math.min(\n              defaultValue(minimumHeight, 0.0),\n              -11500.0\n            );\n\n            // multiply by the *positive* value of the magnitude\n            var vectorToMinimumPoint = Cartesian3.multiplyByScalar(\n              surfaceNormal,\n              Math.abs(magnitude) + 1,\n              scratchPosition\n            );\n            Cartesian3.subtract(\n              data.positionOnEllipsoidSurface,\n              vectorToMinimumPoint,\n              scratchRay.origin\n            );\n          }\n        } else {\n          Cartographic.clone(data.positionCartographic, scratchCartographic);\n\n          // minimum height for the terrain set, need to get this information from the terrain provider\n          scratchCartographic.height = -11500.0;\n          projection.project(scratchCartographic, scratchPosition);\n          Cartesian3.fromElements(\n            scratchPosition.z,\n            scratchPosition.x,\n            scratchPosition.y,\n            scratchPosition\n          );\n          Cartesian3.clone(scratchPosition, scratchRay.origin);\n          Cartesian3.clone(Cartesian3.UNIT_X, scratchRay.direction);\n        }\n\n        var position = tile.data.pick(\n          scratchRay,\n          mode,\n          projection,\n          false,\n          scratchPosition\n        );\n        if (defined(position)) {\n          data.callback(position);\n          data.level = tile.level;\n        }\n      } else if (tile.level === data.level) {\n        var children = tile.children;\n        var childrenLength = children.length;\n\n        var child;\n        for (var j = 0; j < childrenLength; ++j) {\n          child = children[j];\n          if (Rectangle.contains(child.rectangle, data.positionCartographic)) {\n            break;\n          }\n        }\n\n        var tileDataAvailable = terrainProvider.getTileDataAvailable(\n          child.x,\n          child.y,\n          child.level\n        );\n        var parentTile = tile.parent;\n        if (\n          (defined(tileDataAvailable) && !tileDataAvailable) ||\n          (defined(parentTile) &&\n            defined(parentTile.data) &&\n            defined(parentTile.data.terrainData) &&\n            !parentTile.data.terrainData.isChildAvailable(\n              parentTile.x,\n              parentTile.y,\n              child.x,\n              child.y\n            ))\n        ) {\n          data.removeFunc();\n        }\n      }\n\n      if (getTimestamp() >= endTime) {\n        timeSliceMax = true;\n        break;\n      }\n    }\n\n    if (timeSliceMax) {\n      primitive._lastTileIndex = i;\n      break;\n    } else {\n      primitive._lastTileIndex = 0;\n      tilesToUpdateHeights.shift();\n    }\n  }\n  for (i = 0; i < tryNextFrame.length; i++) {\n    tilesToUpdateHeights.push(tryNextFrame[i]);\n  }\n}\n\nfunction createRenderCommandsForSelectedTiles(primitive, frameState) {\n  var tileProvider = primitive._tileProvider;\n  var tilesToRender = primitive._tilesToRender;\n\n  for (var i = 0, len = tilesToRender.length; i < len; ++i) {\n    var tile = tilesToRender[i];\n    tileProvider.showTileThisFrame(tile, frameState);\n  }\n}\nexport default QuadtreePrimitive;\n"]},"metadata":{},"sourceType":"module"}