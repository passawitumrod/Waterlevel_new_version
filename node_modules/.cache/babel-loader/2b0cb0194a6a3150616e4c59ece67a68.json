{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport AutomaticUniforms from \"./AutomaticUniforms.js\";\nimport ContextLimits from \"./ContextLimits.js\";\nimport createUniform from \"./createUniform.js\";\nimport createUniformArray from \"./createUniformArray.js\";\nvar nextShaderProgramId = 0;\n/**\n * @private\n */\n\nfunction ShaderProgram(options) {\n  var vertexShaderText = options.vertexShaderText;\n  var fragmentShaderText = options.fragmentShaderText;\n\n  if (typeof spector !== \"undefined\") {\n    // The #line statements common in Cesium shaders interfere with the ability of the\n    // SpectorJS to show errors on the correct line. So remove them when SpectorJS\n    // is active.\n    vertexShaderText = vertexShaderText.replace(/^#line/gm, \"//#line\");\n    fragmentShaderText = fragmentShaderText.replace(/^#line/gm, \"//#line\");\n  }\n\n  var modifiedFS = handleUniformPrecisionMismatches(vertexShaderText, fragmentShaderText);\n  this._gl = options.gl;\n  this._logShaderCompilation = options.logShaderCompilation;\n  this._debugShaders = options.debugShaders;\n  this._attributeLocations = options.attributeLocations;\n  this._program = undefined;\n  this._numberOfVertexAttributes = undefined;\n  this._vertexAttributes = undefined;\n  this._uniformsByName = undefined;\n  this._uniforms = undefined;\n  this._automaticUniforms = undefined;\n  this._manualUniforms = undefined;\n  this._duplicateUniformNames = modifiedFS.duplicateUniformNames;\n  this._cachedShader = undefined; // Used by ShaderCache\n\n  /**\n   * @private\n   */\n\n  this.maximumTextureUnitIndex = undefined;\n  this._vertexShaderSource = options.vertexShaderSource;\n  this._vertexShaderText = options.vertexShaderText;\n  this._fragmentShaderSource = options.fragmentShaderSource;\n  this._fragmentShaderText = modifiedFS.fragmentShaderText;\n  /**\n   * @private\n   */\n\n  this.id = nextShaderProgramId++;\n}\n\nShaderProgram.fromCache = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);\n\n  Check.defined(\"options.context\", options.context); //>>includeEnd('debug');\n\n  return options.context.shaderCache.getShaderProgram(options);\n};\n\nShaderProgram.replaceCache = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);\n\n  Check.defined(\"options.context\", options.context); //>>includeEnd('debug');\n\n  return options.context.shaderCache.replaceShaderProgram(options);\n};\n\nObject.defineProperties(ShaderProgram.prototype, {\n  /**\n   * GLSL source for the shader program's vertex shader.\n   * @memberof ShaderProgram.prototype\n   *\n   * @type {ShaderSource}\n   * @readonly\n   */\n  vertexShaderSource: {\n    get: function () {\n      return this._vertexShaderSource;\n    }\n  },\n\n  /**\n   * GLSL source for the shader program's fragment shader.\n   * @memberof ShaderProgram.prototype\n   *\n   * @type {ShaderSource}\n   * @readonly\n   */\n  fragmentShaderSource: {\n    get: function () {\n      return this._fragmentShaderSource;\n    }\n  },\n  vertexAttributes: {\n    get: function () {\n      initialize(this);\n      return this._vertexAttributes;\n    }\n  },\n  numberOfVertexAttributes: {\n    get: function () {\n      initialize(this);\n      return this._numberOfVertexAttributes;\n    }\n  },\n  allUniforms: {\n    get: function () {\n      initialize(this);\n      return this._uniformsByName;\n    }\n  }\n});\n\nfunction extractUniforms(shaderText) {\n  var uniformNames = [];\n  var uniformLines = shaderText.match(/uniform.*?(?![^{]*})(?=[=\\[;])/g);\n\n  if (defined(uniformLines)) {\n    var len = uniformLines.length;\n\n    for (var i = 0; i < len; i++) {\n      var line = uniformLines[i].trim();\n      var name = line.slice(line.lastIndexOf(\" \") + 1);\n      uniformNames.push(name);\n    }\n  }\n\n  return uniformNames;\n}\n\nfunction handleUniformPrecisionMismatches(vertexShaderText, fragmentShaderText) {\n  // If a uniform exists in both the vertex and fragment shader but with different precision qualifiers,\n  // give the fragment shader uniform a different name. This fixes shader compilation errors on devices\n  // that only support mediump in the fragment shader.\n  var duplicateUniformNames = {};\n\n  if (!ContextLimits.highpFloatSupported || !ContextLimits.highpIntSupported) {\n    var i, j;\n    var uniformName;\n    var duplicateName;\n    var vertexShaderUniforms = extractUniforms(vertexShaderText);\n    var fragmentShaderUniforms = extractUniforms(fragmentShaderText);\n    var vertexUniformsCount = vertexShaderUniforms.length;\n    var fragmentUniformsCount = fragmentShaderUniforms.length;\n\n    for (i = 0; i < vertexUniformsCount; i++) {\n      for (j = 0; j < fragmentUniformsCount; j++) {\n        if (vertexShaderUniforms[i] === fragmentShaderUniforms[j]) {\n          uniformName = vertexShaderUniforms[i];\n          duplicateName = \"czm_mediump_\" + uniformName; // Update fragmentShaderText with renamed uniforms\n\n          var re = new RegExp(uniformName + \"\\\\b\", \"g\");\n          fragmentShaderText = fragmentShaderText.replace(re, duplicateName);\n          duplicateUniformNames[duplicateName] = uniformName;\n        }\n      }\n    }\n  }\n\n  return {\n    fragmentShaderText: fragmentShaderText,\n    duplicateUniformNames: duplicateUniformNames\n  };\n}\n\nvar consolePrefix = \"[Cesium WebGL] \";\n\nfunction createAndLinkProgram(gl, shader) {\n  var vsSource = shader._vertexShaderText;\n  var fsSource = shader._fragmentShaderText;\n  var vertexShader = gl.createShader(gl.VERTEX_SHADER);\n  gl.shaderSource(vertexShader, vsSource);\n  gl.compileShader(vertexShader);\n  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n  gl.shaderSource(fragmentShader, fsSource);\n  gl.compileShader(fragmentShader);\n  var program = gl.createProgram();\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.deleteShader(vertexShader);\n  gl.deleteShader(fragmentShader);\n  var attributeLocations = shader._attributeLocations;\n\n  if (defined(attributeLocations)) {\n    for (var attribute in attributeLocations) {\n      if (attributeLocations.hasOwnProperty(attribute)) {\n        gl.bindAttribLocation(program, attributeLocations[attribute], attribute);\n      }\n    }\n  }\n\n  gl.linkProgram(program);\n  var log;\n\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    var debugShaders = shader._debugShaders; // For performance, only check compile errors if there is a linker error.\n\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n      log = gl.getShaderInfoLog(fragmentShader);\n      console.error(consolePrefix + \"Fragment shader compile log: \" + log);\n\n      if (defined(debugShaders)) {\n        var fragmentSourceTranslation = debugShaders.getTranslatedShaderSource(fragmentShader);\n\n        if (fragmentSourceTranslation !== \"\") {\n          console.error(consolePrefix + \"Translated fragment shader source:\\n\" + fragmentSourceTranslation);\n        } else {\n          console.error(consolePrefix + \"Fragment shader translation failed.\");\n        }\n      }\n\n      gl.deleteProgram(program);\n      throw new RuntimeError(\"Fragment shader failed to compile.  Compile log: \" + log);\n    }\n\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n      log = gl.getShaderInfoLog(vertexShader);\n      console.error(consolePrefix + \"Vertex shader compile log: \" + log);\n\n      if (defined(debugShaders)) {\n        var vertexSourceTranslation = debugShaders.getTranslatedShaderSource(vertexShader);\n\n        if (vertexSourceTranslation !== \"\") {\n          console.error(consolePrefix + \"Translated vertex shader source:\\n\" + vertexSourceTranslation);\n        } else {\n          console.error(consolePrefix + \"Vertex shader translation failed.\");\n        }\n      }\n\n      gl.deleteProgram(program);\n      throw new RuntimeError(\"Vertex shader failed to compile.  Compile log: \" + log);\n    }\n\n    log = gl.getProgramInfoLog(program);\n    console.error(consolePrefix + \"Shader program link log: \" + log);\n\n    if (defined(debugShaders)) {\n      console.error(consolePrefix + \"Translated vertex shader source:\\n\" + debugShaders.getTranslatedShaderSource(vertexShader));\n      console.error(consolePrefix + \"Translated fragment shader source:\\n\" + debugShaders.getTranslatedShaderSource(fragmentShader));\n    }\n\n    gl.deleteProgram(program);\n    throw new RuntimeError(\"Program failed to link.  Link log: \" + log);\n  }\n\n  var logShaderCompilation = shader._logShaderCompilation;\n\n  if (logShaderCompilation) {\n    log = gl.getShaderInfoLog(vertexShader);\n\n    if (defined(log) && log.length > 0) {\n      console.log(consolePrefix + \"Vertex shader compile log: \" + log);\n    }\n  }\n\n  if (logShaderCompilation) {\n    log = gl.getShaderInfoLog(fragmentShader);\n\n    if (defined(log) && log.length > 0) {\n      console.log(consolePrefix + \"Fragment shader compile log: \" + log);\n    }\n  }\n\n  if (logShaderCompilation) {\n    log = gl.getProgramInfoLog(program);\n\n    if (defined(log) && log.length > 0) {\n      console.log(consolePrefix + \"Shader program link log: \" + log);\n    }\n  }\n\n  return program;\n}\n\nfunction findVertexAttributes(gl, program, numberOfAttributes) {\n  var attributes = {};\n\n  for (var i = 0; i < numberOfAttributes; ++i) {\n    var attr = gl.getActiveAttrib(program, i);\n    var location = gl.getAttribLocation(program, attr.name);\n    attributes[attr.name] = {\n      name: attr.name,\n      type: attr.type,\n      index: location\n    };\n  }\n\n  return attributes;\n}\n\nfunction findUniforms(gl, program) {\n  var uniformsByName = {};\n  var uniforms = [];\n  var samplerUniforms = [];\n  var numberOfUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\n  for (var i = 0; i < numberOfUniforms; ++i) {\n    var activeUniform = gl.getActiveUniform(program, i);\n    var suffix = \"[0]\";\n    var uniformName = activeUniform.name.indexOf(suffix, activeUniform.name.length - suffix.length) !== -1 ? activeUniform.name.slice(0, activeUniform.name.length - 3) : activeUniform.name; // Ignore GLSL built-in uniforms returned in Firefox.\n\n    if (uniformName.indexOf(\"gl_\") !== 0) {\n      if (activeUniform.name.indexOf(\"[\") < 0) {\n        // Single uniform\n        var location = gl.getUniformLocation(program, uniformName); // IE 11.0.9 needs this check since getUniformLocation can return null\n        // if the uniform is not active (e.g., it is optimized out).  Looks like\n        // getActiveUniform() above returns uniforms that are not actually active.\n\n        if (location !== null) {\n          var uniform = createUniform(gl, activeUniform, uniformName, location);\n          uniformsByName[uniformName] = uniform;\n          uniforms.push(uniform);\n\n          if (uniform._setSampler) {\n            samplerUniforms.push(uniform);\n          }\n        }\n      } else {\n        // Uniform array\n        var uniformArray;\n        var locations;\n        var value;\n        var loc; // On some platforms - Nexus 4 in Firefox for one - an array of sampler2D ends up being represented\n        // as separate uniforms, one for each array element.  Check for and handle that case.\n\n        var indexOfBracket = uniformName.indexOf(\"[\");\n\n        if (indexOfBracket >= 0) {\n          // We're assuming the array elements show up in numerical order - it seems to be true.\n          uniformArray = uniformsByName[uniformName.slice(0, indexOfBracket)]; // Nexus 4 with Android 4.3 needs this check, because it reports a uniform\n          // with the strange name webgl_3467e0265d05c3c1[1] in our globe surface shader.\n\n          if (!defined(uniformArray)) {\n            continue;\n          }\n\n          locations = uniformArray._locations; // On the Nexus 4 in Chrome, we get one uniform per sampler, just like in Firefox,\n          // but the size is not 1 like it is in Firefox.  So if we push locations here,\n          // we'll end up adding too many locations.\n\n          if (locations.length <= 1) {\n            value = uniformArray.value;\n            loc = gl.getUniformLocation(program, uniformName); // Workaround for IE 11.0.9.  See above.\n\n            if (loc !== null) {\n              locations.push(loc);\n              value.push(gl.getUniform(program, loc));\n            }\n          }\n        } else {\n          locations = [];\n\n          for (var j = 0; j < activeUniform.size; ++j) {\n            loc = gl.getUniformLocation(program, uniformName + \"[\" + j + \"]\"); // Workaround for IE 11.0.9.  See above.\n\n            if (loc !== null) {\n              locations.push(loc);\n            }\n          }\n\n          uniformArray = createUniformArray(gl, activeUniform, uniformName, locations);\n          uniformsByName[uniformName] = uniformArray;\n          uniforms.push(uniformArray);\n\n          if (uniformArray._setSampler) {\n            samplerUniforms.push(uniformArray);\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    uniformsByName: uniformsByName,\n    uniforms: uniforms,\n    samplerUniforms: samplerUniforms\n  };\n}\n\nfunction partitionUniforms(shader, uniforms) {\n  var automaticUniforms = [];\n  var manualUniforms = [];\n\n  for (var uniform in uniforms) {\n    if (uniforms.hasOwnProperty(uniform)) {\n      var uniformObject = uniforms[uniform];\n      var uniformName = uniform; // if it's a duplicate uniform, use its original name so it is updated correctly\n\n      var duplicateUniform = shader._duplicateUniformNames[uniformName];\n\n      if (defined(duplicateUniform)) {\n        uniformObject.name = duplicateUniform;\n        uniformName = duplicateUniform;\n      }\n\n      var automaticUniform = AutomaticUniforms[uniformName];\n\n      if (defined(automaticUniform)) {\n        automaticUniforms.push({\n          uniform: uniformObject,\n          automaticUniform: automaticUniform\n        });\n      } else {\n        manualUniforms.push(uniformObject);\n      }\n    }\n  }\n\n  return {\n    automaticUniforms: automaticUniforms,\n    manualUniforms: manualUniforms\n  };\n}\n\nfunction setSamplerUniforms(gl, program, samplerUniforms) {\n  gl.useProgram(program);\n  var textureUnitIndex = 0;\n  var length = samplerUniforms.length;\n\n  for (var i = 0; i < length; ++i) {\n    textureUnitIndex = samplerUniforms[i]._setSampler(textureUnitIndex);\n  }\n\n  gl.useProgram(null);\n  return textureUnitIndex;\n}\n\nfunction initialize(shader) {\n  if (defined(shader._program)) {\n    return;\n  }\n\n  reinitialize(shader);\n}\n\nfunction reinitialize(shader) {\n  var oldProgram = shader._program;\n  var gl = shader._gl;\n  var program = createAndLinkProgram(gl, shader, shader._debugShaders);\n  var numberOfVertexAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n  var uniforms = findUniforms(gl, program);\n  var partitionedUniforms = partitionUniforms(shader, uniforms.uniformsByName);\n  shader._program = program;\n  shader._numberOfVertexAttributes = numberOfVertexAttributes;\n  shader._vertexAttributes = findVertexAttributes(gl, program, numberOfVertexAttributes);\n  shader._uniformsByName = uniforms.uniformsByName;\n  shader._uniforms = uniforms.uniforms;\n  shader._automaticUniforms = partitionedUniforms.automaticUniforms;\n  shader._manualUniforms = partitionedUniforms.manualUniforms;\n  shader.maximumTextureUnitIndex = setSamplerUniforms(gl, program, uniforms.samplerUniforms);\n\n  if (oldProgram) {\n    shader._gl.deleteProgram(oldProgram);\n  } // If SpectorJS is active, add the hook to make the shader editor work.\n  // https://github.com/BabylonJS/Spector.js/blob/master/documentation/extension.md#shader-editor\n\n\n  if (typeof spector !== \"undefined\") {\n    shader._program.__SPECTOR_rebuildProgram = function (vertexSourceCode, // The new vertex shader source\n    fragmentSourceCode, // The new fragment shader source\n    onCompiled, // Callback triggered by your engine when the compilation is successful. It needs to send back the new linked program.\n    onError // Callback triggered by your engine in case of error. It needs to send the WebGL error to allow the editor to display the error in the gutter.\n    ) {\n      var originalVS = shader._vertexShaderText;\n      var originalFS = shader._fragmentShaderText; // SpectorJS likes to replace `!=` with `! =` for unknown reasons,\n      // and that causes glsl compile failures. So fix that up.\n\n      var regex = / ! = /g;\n      shader._vertexShaderText = vertexSourceCode.replace(regex, \" != \");\n      shader._fragmentShaderText = fragmentSourceCode.replace(regex, \" != \");\n\n      try {\n        reinitialize(shader);\n        onCompiled(shader._program);\n      } catch (e) {\n        shader._vertexShaderText = originalVS;\n        shader._fragmentShaderText = originalFS; // Only pass on the WebGL error:\n\n        var errorMatcher = /(?:Compile|Link) error: ([^]*)/;\n        var match = errorMatcher.exec(e.message);\n\n        if (match) {\n          onError(match[1]);\n        } else {\n          onError(e.message);\n        }\n      }\n    };\n  }\n}\n\nShaderProgram.prototype._bind = function () {\n  initialize(this);\n\n  this._gl.useProgram(this._program);\n};\n\nShaderProgram.prototype._setUniforms = function (uniformMap, uniformState, validate) {\n  var len;\n  var i;\n\n  if (defined(uniformMap)) {\n    var manualUniforms = this._manualUniforms;\n    len = manualUniforms.length;\n\n    for (i = 0; i < len; ++i) {\n      var mu = manualUniforms[i];\n      mu.value = uniformMap[mu.name]();\n    }\n  }\n\n  var automaticUniforms = this._automaticUniforms;\n  len = automaticUniforms.length;\n\n  for (i = 0; i < len; ++i) {\n    var au = automaticUniforms[i];\n    au.uniform.value = au.automaticUniform.getValue(uniformState);\n  } ///////////////////////////////////////////////////////////////////\n  // It appears that assigning the uniform values above and then setting them here\n  // (which makes the GL calls) is faster than removing this loop and making\n  // the GL calls above.  I suspect this is because each GL call pollutes the\n  // L2 cache making our JavaScript and the browser/driver ping-pong cache lines.\n\n\n  var uniforms = this._uniforms;\n  len = uniforms.length;\n\n  for (i = 0; i < len; ++i) {\n    uniforms[i].set();\n  }\n\n  if (validate) {\n    var gl = this._gl;\n    var program = this._program;\n    gl.validateProgram(program); //>>includeStart('debug', pragmas.debug);\n\n    if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {\n      throw new DeveloperError(\"Program validation failed.  Program info log: \" + gl.getProgramInfoLog(program));\n    } //>>includeEnd('debug');\n\n  }\n};\n\nShaderProgram.prototype.isDestroyed = function () {\n  return false;\n};\n\nShaderProgram.prototype.destroy = function () {\n  this._cachedShader.cache.releaseShaderProgram(this);\n\n  return undefined;\n};\n\nShaderProgram.prototype.finalDestroy = function () {\n  this._gl.deleteProgram(this._program);\n\n  return destroyObject(this);\n};\n\nexport default ShaderProgram;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Renderer/ShaderProgram.js"],"names":["Check","defaultValue","defined","destroyObject","DeveloperError","RuntimeError","AutomaticUniforms","ContextLimits","createUniform","createUniformArray","nextShaderProgramId","ShaderProgram","options","vertexShaderText","fragmentShaderText","spector","replace","modifiedFS","handleUniformPrecisionMismatches","_gl","gl","_logShaderCompilation","logShaderCompilation","_debugShaders","debugShaders","_attributeLocations","attributeLocations","_program","undefined","_numberOfVertexAttributes","_vertexAttributes","_uniformsByName","_uniforms","_automaticUniforms","_manualUniforms","_duplicateUniformNames","duplicateUniformNames","_cachedShader","maximumTextureUnitIndex","_vertexShaderSource","vertexShaderSource","_vertexShaderText","_fragmentShaderSource","fragmentShaderSource","_fragmentShaderText","id","fromCache","EMPTY_OBJECT","context","shaderCache","getShaderProgram","replaceCache","replaceShaderProgram","Object","defineProperties","prototype","get","vertexAttributes","initialize","numberOfVertexAttributes","allUniforms","extractUniforms","shaderText","uniformNames","uniformLines","match","len","length","i","line","trim","name","slice","lastIndexOf","push","highpFloatSupported","highpIntSupported","j","uniformName","duplicateName","vertexShaderUniforms","fragmentShaderUniforms","vertexUniformsCount","fragmentUniformsCount","re","RegExp","consolePrefix","createAndLinkProgram","shader","vsSource","fsSource","vertexShader","createShader","VERTEX_SHADER","shaderSource","compileShader","fragmentShader","FRAGMENT_SHADER","program","createProgram","attachShader","deleteShader","attribute","hasOwnProperty","bindAttribLocation","linkProgram","log","getProgramParameter","LINK_STATUS","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","console","error","fragmentSourceTranslation","getTranslatedShaderSource","deleteProgram","vertexSourceTranslation","getProgramInfoLog","findVertexAttributes","numberOfAttributes","attributes","attr","getActiveAttrib","location","getAttribLocation","type","index","findUniforms","uniformsByName","uniforms","samplerUniforms","numberOfUniforms","ACTIVE_UNIFORMS","activeUniform","getActiveUniform","suffix","indexOf","getUniformLocation","uniform","_setSampler","uniformArray","locations","value","loc","indexOfBracket","_locations","getUniform","size","partitionUniforms","automaticUniforms","manualUniforms","uniformObject","duplicateUniform","automaticUniform","setSamplerUniforms","useProgram","textureUnitIndex","reinitialize","oldProgram","ACTIVE_ATTRIBUTES","partitionedUniforms","__SPECTOR_rebuildProgram","vertexSourceCode","fragmentSourceCode","onCompiled","onError","originalVS","originalFS","regex","e","errorMatcher","exec","message","_bind","_setUniforms","uniformMap","uniformState","validate","mu","au","getValue","set","validateProgram","VALIDATE_STATUS","isDestroyed","destroy","cache","releaseShaderProgram","finalDestroy"],"mappings":"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","sourcesContent":["import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport AutomaticUniforms from \"./AutomaticUniforms.js\";\nimport ContextLimits from \"./ContextLimits.js\";\nimport createUniform from \"./createUniform.js\";\nimport createUniformArray from \"./createUniformArray.js\";\n\nvar nextShaderProgramId = 0;\n\n/**\n * @private\n */\nfunction ShaderProgram(options) {\n  var vertexShaderText = options.vertexShaderText;\n  var fragmentShaderText = options.fragmentShaderText;\n\n  if (typeof spector !== \"undefined\") {\n    // The #line statements common in Cesium shaders interfere with the ability of the\n    // SpectorJS to show errors on the correct line. So remove them when SpectorJS\n    // is active.\n    vertexShaderText = vertexShaderText.replace(/^#line/gm, \"//#line\");\n    fragmentShaderText = fragmentShaderText.replace(/^#line/gm, \"//#line\");\n  }\n\n  var modifiedFS = handleUniformPrecisionMismatches(\n    vertexShaderText,\n    fragmentShaderText\n  );\n\n  this._gl = options.gl;\n  this._logShaderCompilation = options.logShaderCompilation;\n  this._debugShaders = options.debugShaders;\n  this._attributeLocations = options.attributeLocations;\n\n  this._program = undefined;\n  this._numberOfVertexAttributes = undefined;\n  this._vertexAttributes = undefined;\n  this._uniformsByName = undefined;\n  this._uniforms = undefined;\n  this._automaticUniforms = undefined;\n  this._manualUniforms = undefined;\n  this._duplicateUniformNames = modifiedFS.duplicateUniformNames;\n  this._cachedShader = undefined; // Used by ShaderCache\n\n  /**\n   * @private\n   */\n  this.maximumTextureUnitIndex = undefined;\n\n  this._vertexShaderSource = options.vertexShaderSource;\n  this._vertexShaderText = options.vertexShaderText;\n  this._fragmentShaderSource = options.fragmentShaderSource;\n  this._fragmentShaderText = modifiedFS.fragmentShaderText;\n\n  /**\n   * @private\n   */\n  this.id = nextShaderProgramId++;\n}\n\nShaderProgram.fromCache = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n  //>>includeEnd('debug');\n\n  return options.context.shaderCache.getShaderProgram(options);\n};\n\nShaderProgram.replaceCache = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n  //>>includeEnd('debug');\n\n  return options.context.shaderCache.replaceShaderProgram(options);\n};\n\nObject.defineProperties(ShaderProgram.prototype, {\n  /**\n   * GLSL source for the shader program's vertex shader.\n   * @memberof ShaderProgram.prototype\n   *\n   * @type {ShaderSource}\n   * @readonly\n   */\n  vertexShaderSource: {\n    get: function () {\n      return this._vertexShaderSource;\n    },\n  },\n  /**\n   * GLSL source for the shader program's fragment shader.\n   * @memberof ShaderProgram.prototype\n   *\n   * @type {ShaderSource}\n   * @readonly\n   */\n  fragmentShaderSource: {\n    get: function () {\n      return this._fragmentShaderSource;\n    },\n  },\n  vertexAttributes: {\n    get: function () {\n      initialize(this);\n      return this._vertexAttributes;\n    },\n  },\n  numberOfVertexAttributes: {\n    get: function () {\n      initialize(this);\n      return this._numberOfVertexAttributes;\n    },\n  },\n  allUniforms: {\n    get: function () {\n      initialize(this);\n      return this._uniformsByName;\n    },\n  },\n});\n\nfunction extractUniforms(shaderText) {\n  var uniformNames = [];\n  var uniformLines = shaderText.match(/uniform.*?(?![^{]*})(?=[=\\[;])/g);\n  if (defined(uniformLines)) {\n    var len = uniformLines.length;\n    for (var i = 0; i < len; i++) {\n      var line = uniformLines[i].trim();\n      var name = line.slice(line.lastIndexOf(\" \") + 1);\n      uniformNames.push(name);\n    }\n  }\n  return uniformNames;\n}\n\nfunction handleUniformPrecisionMismatches(\n  vertexShaderText,\n  fragmentShaderText\n) {\n  // If a uniform exists in both the vertex and fragment shader but with different precision qualifiers,\n  // give the fragment shader uniform a different name. This fixes shader compilation errors on devices\n  // that only support mediump in the fragment shader.\n  var duplicateUniformNames = {};\n\n  if (!ContextLimits.highpFloatSupported || !ContextLimits.highpIntSupported) {\n    var i, j;\n    var uniformName;\n    var duplicateName;\n    var vertexShaderUniforms = extractUniforms(vertexShaderText);\n    var fragmentShaderUniforms = extractUniforms(fragmentShaderText);\n    var vertexUniformsCount = vertexShaderUniforms.length;\n    var fragmentUniformsCount = fragmentShaderUniforms.length;\n\n    for (i = 0; i < vertexUniformsCount; i++) {\n      for (j = 0; j < fragmentUniformsCount; j++) {\n        if (vertexShaderUniforms[i] === fragmentShaderUniforms[j]) {\n          uniformName = vertexShaderUniforms[i];\n          duplicateName = \"czm_mediump_\" + uniformName;\n          // Update fragmentShaderText with renamed uniforms\n          var re = new RegExp(uniformName + \"\\\\b\", \"g\");\n          fragmentShaderText = fragmentShaderText.replace(re, duplicateName);\n          duplicateUniformNames[duplicateName] = uniformName;\n        }\n      }\n    }\n  }\n\n  return {\n    fragmentShaderText: fragmentShaderText,\n    duplicateUniformNames: duplicateUniformNames,\n  };\n}\n\nvar consolePrefix = \"[Cesium WebGL] \";\n\nfunction createAndLinkProgram(gl, shader) {\n  var vsSource = shader._vertexShaderText;\n  var fsSource = shader._fragmentShaderText;\n\n  var vertexShader = gl.createShader(gl.VERTEX_SHADER);\n  gl.shaderSource(vertexShader, vsSource);\n  gl.compileShader(vertexShader);\n\n  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n  gl.shaderSource(fragmentShader, fsSource);\n  gl.compileShader(fragmentShader);\n\n  var program = gl.createProgram();\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n\n  gl.deleteShader(vertexShader);\n  gl.deleteShader(fragmentShader);\n\n  var attributeLocations = shader._attributeLocations;\n  if (defined(attributeLocations)) {\n    for (var attribute in attributeLocations) {\n      if (attributeLocations.hasOwnProperty(attribute)) {\n        gl.bindAttribLocation(\n          program,\n          attributeLocations[attribute],\n          attribute\n        );\n      }\n    }\n  }\n\n  gl.linkProgram(program);\n\n  var log;\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    var debugShaders = shader._debugShaders;\n\n    // For performance, only check compile errors if there is a linker error.\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n      log = gl.getShaderInfoLog(fragmentShader);\n      console.error(consolePrefix + \"Fragment shader compile log: \" + log);\n      if (defined(debugShaders)) {\n        var fragmentSourceTranslation = debugShaders.getTranslatedShaderSource(\n          fragmentShader\n        );\n        if (fragmentSourceTranslation !== \"\") {\n          console.error(\n            consolePrefix +\n              \"Translated fragment shader source:\\n\" +\n              fragmentSourceTranslation\n          );\n        } else {\n          console.error(consolePrefix + \"Fragment shader translation failed.\");\n        }\n      }\n\n      gl.deleteProgram(program);\n      throw new RuntimeError(\n        \"Fragment shader failed to compile.  Compile log: \" + log\n      );\n    }\n\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n      log = gl.getShaderInfoLog(vertexShader);\n      console.error(consolePrefix + \"Vertex shader compile log: \" + log);\n      if (defined(debugShaders)) {\n        var vertexSourceTranslation = debugShaders.getTranslatedShaderSource(\n          vertexShader\n        );\n        if (vertexSourceTranslation !== \"\") {\n          console.error(\n            consolePrefix +\n              \"Translated vertex shader source:\\n\" +\n              vertexSourceTranslation\n          );\n        } else {\n          console.error(consolePrefix + \"Vertex shader translation failed.\");\n        }\n      }\n\n      gl.deleteProgram(program);\n      throw new RuntimeError(\n        \"Vertex shader failed to compile.  Compile log: \" + log\n      );\n    }\n\n    log = gl.getProgramInfoLog(program);\n    console.error(consolePrefix + \"Shader program link log: \" + log);\n    if (defined(debugShaders)) {\n      console.error(\n        consolePrefix +\n          \"Translated vertex shader source:\\n\" +\n          debugShaders.getTranslatedShaderSource(vertexShader)\n      );\n      console.error(\n        consolePrefix +\n          \"Translated fragment shader source:\\n\" +\n          debugShaders.getTranslatedShaderSource(fragmentShader)\n      );\n    }\n\n    gl.deleteProgram(program);\n    throw new RuntimeError(\"Program failed to link.  Link log: \" + log);\n  }\n\n  var logShaderCompilation = shader._logShaderCompilation;\n\n  if (logShaderCompilation) {\n    log = gl.getShaderInfoLog(vertexShader);\n    if (defined(log) && log.length > 0) {\n      console.log(consolePrefix + \"Vertex shader compile log: \" + log);\n    }\n  }\n\n  if (logShaderCompilation) {\n    log = gl.getShaderInfoLog(fragmentShader);\n    if (defined(log) && log.length > 0) {\n      console.log(consolePrefix + \"Fragment shader compile log: \" + log);\n    }\n  }\n\n  if (logShaderCompilation) {\n    log = gl.getProgramInfoLog(program);\n    if (defined(log) && log.length > 0) {\n      console.log(consolePrefix + \"Shader program link log: \" + log);\n    }\n  }\n\n  return program;\n}\n\nfunction findVertexAttributes(gl, program, numberOfAttributes) {\n  var attributes = {};\n  for (var i = 0; i < numberOfAttributes; ++i) {\n    var attr = gl.getActiveAttrib(program, i);\n    var location = gl.getAttribLocation(program, attr.name);\n\n    attributes[attr.name] = {\n      name: attr.name,\n      type: attr.type,\n      index: location,\n    };\n  }\n\n  return attributes;\n}\n\nfunction findUniforms(gl, program) {\n  var uniformsByName = {};\n  var uniforms = [];\n  var samplerUniforms = [];\n\n  var numberOfUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\n  for (var i = 0; i < numberOfUniforms; ++i) {\n    var activeUniform = gl.getActiveUniform(program, i);\n    var suffix = \"[0]\";\n    var uniformName =\n      activeUniform.name.indexOf(\n        suffix,\n        activeUniform.name.length - suffix.length\n      ) !== -1\n        ? activeUniform.name.slice(0, activeUniform.name.length - 3)\n        : activeUniform.name;\n\n    // Ignore GLSL built-in uniforms returned in Firefox.\n    if (uniformName.indexOf(\"gl_\") !== 0) {\n      if (activeUniform.name.indexOf(\"[\") < 0) {\n        // Single uniform\n        var location = gl.getUniformLocation(program, uniformName);\n\n        // IE 11.0.9 needs this check since getUniformLocation can return null\n        // if the uniform is not active (e.g., it is optimized out).  Looks like\n        // getActiveUniform() above returns uniforms that are not actually active.\n        if (location !== null) {\n          var uniform = createUniform(gl, activeUniform, uniformName, location);\n\n          uniformsByName[uniformName] = uniform;\n          uniforms.push(uniform);\n\n          if (uniform._setSampler) {\n            samplerUniforms.push(uniform);\n          }\n        }\n      } else {\n        // Uniform array\n\n        var uniformArray;\n        var locations;\n        var value;\n        var loc;\n\n        // On some platforms - Nexus 4 in Firefox for one - an array of sampler2D ends up being represented\n        // as separate uniforms, one for each array element.  Check for and handle that case.\n        var indexOfBracket = uniformName.indexOf(\"[\");\n        if (indexOfBracket >= 0) {\n          // We're assuming the array elements show up in numerical order - it seems to be true.\n          uniformArray = uniformsByName[uniformName.slice(0, indexOfBracket)];\n\n          // Nexus 4 with Android 4.3 needs this check, because it reports a uniform\n          // with the strange name webgl_3467e0265d05c3c1[1] in our globe surface shader.\n          if (!defined(uniformArray)) {\n            continue;\n          }\n\n          locations = uniformArray._locations;\n\n          // On the Nexus 4 in Chrome, we get one uniform per sampler, just like in Firefox,\n          // but the size is not 1 like it is in Firefox.  So if we push locations here,\n          // we'll end up adding too many locations.\n          if (locations.length <= 1) {\n            value = uniformArray.value;\n            loc = gl.getUniformLocation(program, uniformName);\n\n            // Workaround for IE 11.0.9.  See above.\n            if (loc !== null) {\n              locations.push(loc);\n              value.push(gl.getUniform(program, loc));\n            }\n          }\n        } else {\n          locations = [];\n          for (var j = 0; j < activeUniform.size; ++j) {\n            loc = gl.getUniformLocation(program, uniformName + \"[\" + j + \"]\");\n\n            // Workaround for IE 11.0.9.  See above.\n            if (loc !== null) {\n              locations.push(loc);\n            }\n          }\n          uniformArray = createUniformArray(\n            gl,\n            activeUniform,\n            uniformName,\n            locations\n          );\n\n          uniformsByName[uniformName] = uniformArray;\n          uniforms.push(uniformArray);\n\n          if (uniformArray._setSampler) {\n            samplerUniforms.push(uniformArray);\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    uniformsByName: uniformsByName,\n    uniforms: uniforms,\n    samplerUniforms: samplerUniforms,\n  };\n}\n\nfunction partitionUniforms(shader, uniforms) {\n  var automaticUniforms = [];\n  var manualUniforms = [];\n\n  for (var uniform in uniforms) {\n    if (uniforms.hasOwnProperty(uniform)) {\n      var uniformObject = uniforms[uniform];\n      var uniformName = uniform;\n      // if it's a duplicate uniform, use its original name so it is updated correctly\n      var duplicateUniform = shader._duplicateUniformNames[uniformName];\n      if (defined(duplicateUniform)) {\n        uniformObject.name = duplicateUniform;\n        uniformName = duplicateUniform;\n      }\n      var automaticUniform = AutomaticUniforms[uniformName];\n      if (defined(automaticUniform)) {\n        automaticUniforms.push({\n          uniform: uniformObject,\n          automaticUniform: automaticUniform,\n        });\n      } else {\n        manualUniforms.push(uniformObject);\n      }\n    }\n  }\n\n  return {\n    automaticUniforms: automaticUniforms,\n    manualUniforms: manualUniforms,\n  };\n}\n\nfunction setSamplerUniforms(gl, program, samplerUniforms) {\n  gl.useProgram(program);\n\n  var textureUnitIndex = 0;\n  var length = samplerUniforms.length;\n  for (var i = 0; i < length; ++i) {\n    textureUnitIndex = samplerUniforms[i]._setSampler(textureUnitIndex);\n  }\n\n  gl.useProgram(null);\n\n  return textureUnitIndex;\n}\n\nfunction initialize(shader) {\n  if (defined(shader._program)) {\n    return;\n  }\n\n  reinitialize(shader);\n}\n\nfunction reinitialize(shader) {\n  var oldProgram = shader._program;\n\n  var gl = shader._gl;\n  var program = createAndLinkProgram(gl, shader, shader._debugShaders);\n  var numberOfVertexAttributes = gl.getProgramParameter(\n    program,\n    gl.ACTIVE_ATTRIBUTES\n  );\n  var uniforms = findUniforms(gl, program);\n  var partitionedUniforms = partitionUniforms(shader, uniforms.uniformsByName);\n\n  shader._program = program;\n  shader._numberOfVertexAttributes = numberOfVertexAttributes;\n  shader._vertexAttributes = findVertexAttributes(\n    gl,\n    program,\n    numberOfVertexAttributes\n  );\n  shader._uniformsByName = uniforms.uniformsByName;\n  shader._uniforms = uniforms.uniforms;\n  shader._automaticUniforms = partitionedUniforms.automaticUniforms;\n  shader._manualUniforms = partitionedUniforms.manualUniforms;\n\n  shader.maximumTextureUnitIndex = setSamplerUniforms(\n    gl,\n    program,\n    uniforms.samplerUniforms\n  );\n\n  if (oldProgram) {\n    shader._gl.deleteProgram(oldProgram);\n  }\n\n  // If SpectorJS is active, add the hook to make the shader editor work.\n  // https://github.com/BabylonJS/Spector.js/blob/master/documentation/extension.md#shader-editor\n  if (typeof spector !== \"undefined\") {\n    shader._program.__SPECTOR_rebuildProgram = function (\n      vertexSourceCode, // The new vertex shader source\n      fragmentSourceCode, // The new fragment shader source\n      onCompiled, // Callback triggered by your engine when the compilation is successful. It needs to send back the new linked program.\n      onError // Callback triggered by your engine in case of error. It needs to send the WebGL error to allow the editor to display the error in the gutter.\n    ) {\n      var originalVS = shader._vertexShaderText;\n      var originalFS = shader._fragmentShaderText;\n\n      // SpectorJS likes to replace `!=` with `! =` for unknown reasons,\n      // and that causes glsl compile failures. So fix that up.\n      var regex = / ! = /g;\n      shader._vertexShaderText = vertexSourceCode.replace(regex, \" != \");\n      shader._fragmentShaderText = fragmentSourceCode.replace(regex, \" != \");\n\n      try {\n        reinitialize(shader);\n        onCompiled(shader._program);\n      } catch (e) {\n        shader._vertexShaderText = originalVS;\n        shader._fragmentShaderText = originalFS;\n\n        // Only pass on the WebGL error:\n        var errorMatcher = /(?:Compile|Link) error: ([^]*)/;\n        var match = errorMatcher.exec(e.message);\n        if (match) {\n          onError(match[1]);\n        } else {\n          onError(e.message);\n        }\n      }\n    };\n  }\n}\n\nShaderProgram.prototype._bind = function () {\n  initialize(this);\n  this._gl.useProgram(this._program);\n};\n\nShaderProgram.prototype._setUniforms = function (\n  uniformMap,\n  uniformState,\n  validate\n) {\n  var len;\n  var i;\n\n  if (defined(uniformMap)) {\n    var manualUniforms = this._manualUniforms;\n    len = manualUniforms.length;\n    for (i = 0; i < len; ++i) {\n      var mu = manualUniforms[i];\n      mu.value = uniformMap[mu.name]();\n    }\n  }\n\n  var automaticUniforms = this._automaticUniforms;\n  len = automaticUniforms.length;\n  for (i = 0; i < len; ++i) {\n    var au = automaticUniforms[i];\n    au.uniform.value = au.automaticUniform.getValue(uniformState);\n  }\n\n  ///////////////////////////////////////////////////////////////////\n\n  // It appears that assigning the uniform values above and then setting them here\n  // (which makes the GL calls) is faster than removing this loop and making\n  // the GL calls above.  I suspect this is because each GL call pollutes the\n  // L2 cache making our JavaScript and the browser/driver ping-pong cache lines.\n  var uniforms = this._uniforms;\n  len = uniforms.length;\n  for (i = 0; i < len; ++i) {\n    uniforms[i].set();\n  }\n\n  if (validate) {\n    var gl = this._gl;\n    var program = this._program;\n\n    gl.validateProgram(program);\n    //>>includeStart('debug', pragmas.debug);\n    if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {\n      throw new DeveloperError(\n        \"Program validation failed.  Program info log: \" +\n          gl.getProgramInfoLog(program)\n      );\n    }\n    //>>includeEnd('debug');\n  }\n};\n\nShaderProgram.prototype.isDestroyed = function () {\n  return false;\n};\n\nShaderProgram.prototype.destroy = function () {\n  this._cachedShader.cache.releaseShaderProgram(this);\n  return undefined;\n};\n\nShaderProgram.prototype.finalDestroy = function () {\n  this._gl.deleteProgram(this._program);\n  return destroyObject(this);\n};\nexport default ShaderProgram;\n"]},"metadata":{},"sourceType":"module"}