{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EllipsoidGeometry from \"../Core/EllipsoidGeometry.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport VertexFormat from \"../Core/VertexFormat.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport SkyAtmosphereFS from \"../Shaders/SkyAtmosphereFS.js\";\nimport SkyAtmosphereVS from \"../Shaders/SkyAtmosphereVS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport CullFace from \"./CullFace.js\";\nimport SceneMode from \"./SceneMode.js\";\n/**\n * An atmosphere drawn around the limb of the provided ellipsoid.  Based on\n * {@link https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter16.html|Accurate Atmospheric Scattering}\n * in GPU Gems 2.\n * <p>\n * This is only supported in 3D. Atmosphere is faded out when morphing to 2D or Columbus view.\n * </p>\n *\n * @alias SkyAtmosphere\n * @constructor\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid that the atmosphere is drawn around.\n *\n * @example\n * scene.skyAtmosphere = new Cesium.SkyAtmosphere();\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Sky%20Atmosphere.html|Sky atmosphere demo in Sandcastle}\n *\n * @see Scene.skyAtmosphere\n */\n\nfunction SkyAtmosphere(ellipsoid) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  /**\n   * Determines if the atmosphere is shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.show = true;\n  this._ellipsoid = ellipsoid;\n  this._command = new DrawCommand({\n    owner: this\n  });\n  this._spSkyFromSpace = undefined;\n  this._spSkyFromAtmosphere = undefined;\n  this._spSkyFromSpaceColorCorrect = undefined;\n  this._spSkyFromAtmosphereColorCorrect = undefined;\n  /**\n   * The hue shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A hue shift of 1.0 indicates a complete rotation of the hues available.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.hueShift = 0.0;\n  /**\n   * The saturation shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A saturation shift of -1.0 is monochrome.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.saturationShift = 0.0;\n  /**\n   * The brightness shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A brightness shift of -1.0 is complete darkness, which will let space show through.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.brightnessShift = 0.0;\n  this._hueSaturationBrightness = new Cartesian3(); // camera height, outer radius, inner radius, dynamic atmosphere color flag\n\n  var cameraAndRadiiAndDynamicAtmosphereColor = new Cartesian4(); // Toggles whether the sun position is used. 0 treats the sun as always directly overhead.\n\n  cameraAndRadiiAndDynamicAtmosphereColor.w = 0;\n  cameraAndRadiiAndDynamicAtmosphereColor.y = Cartesian3.maximumComponent(Cartesian3.multiplyByScalar(ellipsoid.radii, 1.025, new Cartesian3()));\n  cameraAndRadiiAndDynamicAtmosphereColor.z = ellipsoid.maximumRadius;\n  this._cameraAndRadiiAndDynamicAtmosphereColor = cameraAndRadiiAndDynamicAtmosphereColor;\n  var that = this;\n  this._command.uniformMap = {\n    u_cameraAndRadiiAndDynamicAtmosphereColor: function u_cameraAndRadiiAndDynamicAtmosphereColor() {\n      return that._cameraAndRadiiAndDynamicAtmosphereColor;\n    },\n    u_hsbShift: function u_hsbShift() {\n      that._hueSaturationBrightness.x = that.hueShift;\n      that._hueSaturationBrightness.y = that.saturationShift;\n      that._hueSaturationBrightness.z = that.brightnessShift;\n      return that._hueSaturationBrightness;\n    }\n  };\n}\n\nObject.defineProperties(SkyAtmosphere.prototype, {\n  /**\n   * Gets the ellipsoid the atmosphere is drawn around.\n   * @memberof SkyAtmosphere.prototype\n   *\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function get() {\n      return this._ellipsoid;\n    }\n  }\n});\n/**\n * @private\n */\n\nSkyAtmosphere.prototype.setDynamicAtmosphereColor = function (enableLighting, useSunDirection) {\n  this._cameraAndRadiiAndDynamicAtmosphereColor.w = enableLighting ? useSunDirection ? 2.0 : 1.0 : 0.0;\n};\n/**\n * @private\n */\n\n\nSkyAtmosphere.prototype.update = function (frameState) {\n  if (!this.show) {\n    return undefined;\n  }\n\n  var mode = frameState.mode;\n\n  if (mode !== SceneMode.SCENE3D && mode !== SceneMode.MORPHING) {\n    return undefined;\n  } // The atmosphere is only rendered during the render pass; it is not pickable, it doesn't cast shadows, etc.\n\n\n  if (!frameState.passes.render) {\n    return undefined;\n  }\n\n  var command = this._command;\n\n  if (!defined(command.vertexArray)) {\n    var context = frameState.context;\n    var geometry = EllipsoidGeometry.createGeometry(new EllipsoidGeometry({\n      radii: Cartesian3.multiplyByScalar(this._ellipsoid.radii, 1.025, new Cartesian3()),\n      slicePartitions: 256,\n      stackPartitions: 256,\n      vertexFormat: VertexFormat.POSITION_ONLY\n    }));\n    command.vertexArray = VertexArray.fromGeometry({\n      context: context,\n      geometry: geometry,\n      attributeLocations: GeometryPipeline.createAttributeLocations(geometry),\n      bufferUsage: BufferUsage.STATIC_DRAW\n    });\n    command.renderState = RenderState.fromCache({\n      cull: {\n        enabled: true,\n        face: CullFace.FRONT\n      },\n      blending: BlendingState.ALPHA_BLEND,\n      depthMask: false\n    });\n    var vs = new ShaderSource({\n      defines: [\"SKY_FROM_SPACE\"],\n      sources: [SkyAtmosphereVS]\n    });\n    this._spSkyFromSpace = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: SkyAtmosphereFS\n    });\n    vs = new ShaderSource({\n      defines: [\"SKY_FROM_ATMOSPHERE\"],\n      sources: [SkyAtmosphereVS]\n    });\n    this._spSkyFromAtmosphere = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: SkyAtmosphereFS\n    });\n  } // Compile the color correcting versions of the shader on demand\n\n\n  var useColorCorrect = colorCorrect(this);\n\n  if (useColorCorrect && (!defined(this._spSkyFromSpaceColorCorrect) || !defined(this._spSkyFromAtmosphereColorCorrect))) {\n    var contextColorCorrect = frameState.context;\n    var vsColorCorrect = new ShaderSource({\n      defines: [\"SKY_FROM_SPACE\"],\n      sources: [SkyAtmosphereVS]\n    });\n    var fsColorCorrect = new ShaderSource({\n      defines: [\"COLOR_CORRECT\"],\n      sources: [SkyAtmosphereFS]\n    });\n    this._spSkyFromSpaceColorCorrect = ShaderProgram.fromCache({\n      context: contextColorCorrect,\n      vertexShaderSource: vsColorCorrect,\n      fragmentShaderSource: fsColorCorrect\n    });\n    vsColorCorrect = new ShaderSource({\n      defines: [\"SKY_FROM_ATMOSPHERE\"],\n      sources: [SkyAtmosphereVS]\n    });\n    this._spSkyFromAtmosphereColorCorrect = ShaderProgram.fromCache({\n      context: contextColorCorrect,\n      vertexShaderSource: vsColorCorrect,\n      fragmentShaderSource: fsColorCorrect\n    });\n  }\n\n  var cameraPosition = frameState.camera.positionWC;\n  var cameraHeight = Cartesian3.magnitude(cameraPosition);\n  this._cameraAndRadiiAndDynamicAtmosphereColor.x = cameraHeight;\n\n  if (cameraHeight > this._cameraAndRadiiAndDynamicAtmosphereColor.y) {\n    // Camera in space\n    command.shaderProgram = useColorCorrect ? this._spSkyFromSpaceColorCorrect : this._spSkyFromSpace;\n  } else {\n    // Camera in atmosphere\n    command.shaderProgram = useColorCorrect ? this._spSkyFromAtmosphereColorCorrect : this._spSkyFromAtmosphere;\n  }\n\n  return command;\n};\n\nfunction colorCorrect(skyAtmosphere) {\n  return !(CesiumMath.equalsEpsilon(skyAtmosphere.hueShift, 0.0, CesiumMath.EPSILON7) && CesiumMath.equalsEpsilon(skyAtmosphere.saturationShift, 0.0, CesiumMath.EPSILON7) && CesiumMath.equalsEpsilon(skyAtmosphere.brightnessShift, 0.0, CesiumMath.EPSILON7));\n}\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see SkyAtmosphere#destroy\n */\n\n\nSkyAtmosphere.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * skyAtmosphere = skyAtmosphere && skyAtmosphere.destroy();\n *\n * @see SkyAtmosphere#isDestroyed\n */\n\n\nSkyAtmosphere.prototype.destroy = function () {\n  var command = this._command;\n  command.vertexArray = command.vertexArray && command.vertexArray.destroy();\n  this._spSkyFromSpace = this._spSkyFromSpace && this._spSkyFromSpace.destroy();\n  this._spSkyFromAtmosphere = this._spSkyFromAtmosphere && this._spSkyFromAtmosphere.destroy();\n  this._spSkyFromSpaceColorCorrect = this._spSkyFromSpaceColorCorrect && this._spSkyFromSpaceColorCorrect.destroy();\n  this._spSkyFromAtmosphereColorCorrect = this._spSkyFromAtmosphereColorCorrect && this._spSkyFromAtmosphereColorCorrect.destroy();\n  return destroyObject(this);\n};\n\nexport default SkyAtmosphere;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/SkyAtmosphere.js"],"names":["Cartesian3","Cartesian4","defaultValue","defined","destroyObject","Ellipsoid","EllipsoidGeometry","GeometryPipeline","CesiumMath","VertexFormat","BufferUsage","DrawCommand","RenderState","ShaderProgram","ShaderSource","VertexArray","SkyAtmosphereFS","SkyAtmosphereVS","BlendingState","CullFace","SceneMode","SkyAtmosphere","ellipsoid","WGS84","show","_ellipsoid","_command","owner","_spSkyFromSpace","undefined","_spSkyFromAtmosphere","_spSkyFromSpaceColorCorrect","_spSkyFromAtmosphereColorCorrect","hueShift","saturationShift","brightnessShift","_hueSaturationBrightness","cameraAndRadiiAndDynamicAtmosphereColor","w","y","maximumComponent","multiplyByScalar","radii","z","maximumRadius","_cameraAndRadiiAndDynamicAtmosphereColor","that","uniformMap","u_cameraAndRadiiAndDynamicAtmosphereColor","u_hsbShift","x","Object","defineProperties","prototype","get","setDynamicAtmosphereColor","enableLighting","useSunDirection","update","frameState","mode","SCENE3D","MORPHING","passes","render","command","vertexArray","context","geometry","createGeometry","slicePartitions","stackPartitions","vertexFormat","POSITION_ONLY","fromGeometry","attributeLocations","createAttributeLocations","bufferUsage","STATIC_DRAW","renderState","fromCache","cull","enabled","face","FRONT","blending","ALPHA_BLEND","depthMask","vs","defines","sources","vertexShaderSource","fragmentShaderSource","useColorCorrect","colorCorrect","contextColorCorrect","vsColorCorrect","fsColorCorrect","cameraPosition","camera","positionWC","cameraHeight","magnitude","shaderProgram","skyAtmosphere","equalsEpsilon","EPSILON7","isDestroyed","destroy"],"mappings":"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","sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EllipsoidGeometry from \"../Core/EllipsoidGeometry.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport VertexFormat from \"../Core/VertexFormat.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport SkyAtmosphereFS from \"../Shaders/SkyAtmosphereFS.js\";\nimport SkyAtmosphereVS from \"../Shaders/SkyAtmosphereVS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport CullFace from \"./CullFace.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * An atmosphere drawn around the limb of the provided ellipsoid.  Based on\n * {@link https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter16.html|Accurate Atmospheric Scattering}\n * in GPU Gems 2.\n * <p>\n * This is only supported in 3D. Atmosphere is faded out when morphing to 2D or Columbus view.\n * </p>\n *\n * @alias SkyAtmosphere\n * @constructor\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid that the atmosphere is drawn around.\n *\n * @example\n * scene.skyAtmosphere = new Cesium.SkyAtmosphere();\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Sky%20Atmosphere.html|Sky atmosphere demo in Sandcastle}\n *\n * @see Scene.skyAtmosphere\n */\nfunction SkyAtmosphere(ellipsoid) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  /**\n   * Determines if the atmosphere is shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.show = true;\n\n  this._ellipsoid = ellipsoid;\n  this._command = new DrawCommand({\n    owner: this,\n  });\n  this._spSkyFromSpace = undefined;\n  this._spSkyFromAtmosphere = undefined;\n\n  this._spSkyFromSpaceColorCorrect = undefined;\n  this._spSkyFromAtmosphereColorCorrect = undefined;\n\n  /**\n   * The hue shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A hue shift of 1.0 indicates a complete rotation of the hues available.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.hueShift = 0.0;\n\n  /**\n   * The saturation shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A saturation shift of -1.0 is monochrome.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.saturationShift = 0.0;\n\n  /**\n   * The brightness shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A brightness shift of -1.0 is complete darkness, which will let space show through.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.brightnessShift = 0.0;\n\n  this._hueSaturationBrightness = new Cartesian3();\n\n  // camera height, outer radius, inner radius, dynamic atmosphere color flag\n  var cameraAndRadiiAndDynamicAtmosphereColor = new Cartesian4();\n\n  // Toggles whether the sun position is used. 0 treats the sun as always directly overhead.\n  cameraAndRadiiAndDynamicAtmosphereColor.w = 0;\n  cameraAndRadiiAndDynamicAtmosphereColor.y = Cartesian3.maximumComponent(\n    Cartesian3.multiplyByScalar(ellipsoid.radii, 1.025, new Cartesian3())\n  );\n  cameraAndRadiiAndDynamicAtmosphereColor.z = ellipsoid.maximumRadius;\n\n  this._cameraAndRadiiAndDynamicAtmosphereColor = cameraAndRadiiAndDynamicAtmosphereColor;\n\n  var that = this;\n\n  this._command.uniformMap = {\n    u_cameraAndRadiiAndDynamicAtmosphereColor: function () {\n      return that._cameraAndRadiiAndDynamicAtmosphereColor;\n    },\n    u_hsbShift: function () {\n      that._hueSaturationBrightness.x = that.hueShift;\n      that._hueSaturationBrightness.y = that.saturationShift;\n      that._hueSaturationBrightness.z = that.brightnessShift;\n      return that._hueSaturationBrightness;\n    },\n  };\n}\n\nObject.defineProperties(SkyAtmosphere.prototype, {\n  /**\n   * Gets the ellipsoid the atmosphere is drawn around.\n   * @memberof SkyAtmosphere.prototype\n   *\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n});\n\n/**\n * @private\n */\nSkyAtmosphere.prototype.setDynamicAtmosphereColor = function (\n  enableLighting,\n  useSunDirection\n) {\n  this._cameraAndRadiiAndDynamicAtmosphereColor.w = enableLighting\n    ? useSunDirection\n      ? 2.0\n      : 1.0\n    : 0.0;\n};\n\n/**\n * @private\n */\nSkyAtmosphere.prototype.update = function (frameState) {\n  if (!this.show) {\n    return undefined;\n  }\n\n  var mode = frameState.mode;\n  if (mode !== SceneMode.SCENE3D && mode !== SceneMode.MORPHING) {\n    return undefined;\n  }\n\n  // The atmosphere is only rendered during the render pass; it is not pickable, it doesn't cast shadows, etc.\n  if (!frameState.passes.render) {\n    return undefined;\n  }\n\n  var command = this._command;\n\n  if (!defined(command.vertexArray)) {\n    var context = frameState.context;\n\n    var geometry = EllipsoidGeometry.createGeometry(\n      new EllipsoidGeometry({\n        radii: Cartesian3.multiplyByScalar(\n          this._ellipsoid.radii,\n          1.025,\n          new Cartesian3()\n        ),\n        slicePartitions: 256,\n        stackPartitions: 256,\n        vertexFormat: VertexFormat.POSITION_ONLY,\n      })\n    );\n    command.vertexArray = VertexArray.fromGeometry({\n      context: context,\n      geometry: geometry,\n      attributeLocations: GeometryPipeline.createAttributeLocations(geometry),\n      bufferUsage: BufferUsage.STATIC_DRAW,\n    });\n    command.renderState = RenderState.fromCache({\n      cull: {\n        enabled: true,\n        face: CullFace.FRONT,\n      },\n      blending: BlendingState.ALPHA_BLEND,\n      depthMask: false,\n    });\n\n    var vs = new ShaderSource({\n      defines: [\"SKY_FROM_SPACE\"],\n      sources: [SkyAtmosphereVS],\n    });\n\n    this._spSkyFromSpace = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: SkyAtmosphereFS,\n    });\n\n    vs = new ShaderSource({\n      defines: [\"SKY_FROM_ATMOSPHERE\"],\n      sources: [SkyAtmosphereVS],\n    });\n    this._spSkyFromAtmosphere = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: SkyAtmosphereFS,\n    });\n  }\n\n  // Compile the color correcting versions of the shader on demand\n  var useColorCorrect = colorCorrect(this);\n  if (\n    useColorCorrect &&\n    (!defined(this._spSkyFromSpaceColorCorrect) ||\n      !defined(this._spSkyFromAtmosphereColorCorrect))\n  ) {\n    var contextColorCorrect = frameState.context;\n\n    var vsColorCorrect = new ShaderSource({\n      defines: [\"SKY_FROM_SPACE\"],\n      sources: [SkyAtmosphereVS],\n    });\n    var fsColorCorrect = new ShaderSource({\n      defines: [\"COLOR_CORRECT\"],\n      sources: [SkyAtmosphereFS],\n    });\n\n    this._spSkyFromSpaceColorCorrect = ShaderProgram.fromCache({\n      context: contextColorCorrect,\n      vertexShaderSource: vsColorCorrect,\n      fragmentShaderSource: fsColorCorrect,\n    });\n    vsColorCorrect = new ShaderSource({\n      defines: [\"SKY_FROM_ATMOSPHERE\"],\n      sources: [SkyAtmosphereVS],\n    });\n    this._spSkyFromAtmosphereColorCorrect = ShaderProgram.fromCache({\n      context: contextColorCorrect,\n      vertexShaderSource: vsColorCorrect,\n      fragmentShaderSource: fsColorCorrect,\n    });\n  }\n\n  var cameraPosition = frameState.camera.positionWC;\n\n  var cameraHeight = Cartesian3.magnitude(cameraPosition);\n  this._cameraAndRadiiAndDynamicAtmosphereColor.x = cameraHeight;\n\n  if (cameraHeight > this._cameraAndRadiiAndDynamicAtmosphereColor.y) {\n    // Camera in space\n    command.shaderProgram = useColorCorrect\n      ? this._spSkyFromSpaceColorCorrect\n      : this._spSkyFromSpace;\n  } else {\n    // Camera in atmosphere\n    command.shaderProgram = useColorCorrect\n      ? this._spSkyFromAtmosphereColorCorrect\n      : this._spSkyFromAtmosphere;\n  }\n\n  return command;\n};\n\nfunction colorCorrect(skyAtmosphere) {\n  return !(\n    CesiumMath.equalsEpsilon(\n      skyAtmosphere.hueShift,\n      0.0,\n      CesiumMath.EPSILON7\n    ) &&\n    CesiumMath.equalsEpsilon(\n      skyAtmosphere.saturationShift,\n      0.0,\n      CesiumMath.EPSILON7\n    ) &&\n    CesiumMath.equalsEpsilon(\n      skyAtmosphere.brightnessShift,\n      0.0,\n      CesiumMath.EPSILON7\n    )\n  );\n}\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see SkyAtmosphere#destroy\n */\nSkyAtmosphere.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * skyAtmosphere = skyAtmosphere && skyAtmosphere.destroy();\n *\n * @see SkyAtmosphere#isDestroyed\n */\nSkyAtmosphere.prototype.destroy = function () {\n  var command = this._command;\n  command.vertexArray = command.vertexArray && command.vertexArray.destroy();\n  this._spSkyFromSpace = this._spSkyFromSpace && this._spSkyFromSpace.destroy();\n  this._spSkyFromAtmosphere =\n    this._spSkyFromAtmosphere && this._spSkyFromAtmosphere.destroy();\n  this._spSkyFromSpaceColorCorrect =\n    this._spSkyFromSpaceColorCorrect &&\n    this._spSkyFromSpaceColorCorrect.destroy();\n  this._spSkyFromAtmosphereColorCorrect =\n    this._spSkyFromAtmosphereColorCorrect &&\n    this._spSkyFromAtmosphereColorCorrect.destroy();\n  return destroyObject(this);\n};\nexport default SkyAtmosphere;\n"]},"metadata":{},"sourceType":"module"}