{"ast":null,"code":"import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n/**\n * Contains functions for operating on 2D triangles.\n *\n * @exports Intersections2D\n */\n\nvar Intersections2D = {};\n/**\n * Splits a 2D triangle at given axis-aligned threshold value and returns the resulting\n * polygon on a given side of the threshold.  The resulting polygon may have 0, 1, 2,\n * 3, or 4 vertices.\n *\n * @param {Number} threshold The threshold coordinate value at which to clip the triangle.\n * @param {Boolean} keepAbove true to keep the portion of the triangle above the threshold, or false\n *                            to keep the portion below.\n * @param {Number} u0 The coordinate of the first vertex in the triangle, in counter-clockwise order.\n * @param {Number} u1 The coordinate of the second vertex in the triangle, in counter-clockwise order.\n * @param {Number} u2 The coordinate of the third vertex in the triangle, in counter-clockwise order.\n * @param {Number[]} [result] The array into which to copy the result.  If this parameter is not supplied,\n *                            a new array is constructed and returned.\n * @returns {Number[]} The polygon that results after the clip, specified as a list of\n *                     vertices.  The vertices are specified in counter-clockwise order.\n *                     Each vertex is either an index from the existing list (identified as\n *                     a 0, 1, or 2) or -1 indicating a new vertex not in the original triangle.\n *                     For new vertices, the -1 is followed by three additional numbers: the\n *                     index of each of the two original vertices forming the line segment that\n *                     the new vertex lies on, and the fraction of the distance from the first\n *                     vertex to the second one.\n *\n * @example\n * var result = Cesium.Intersections2D.clipTriangleAtAxisAlignedThreshold(0.5, false, 0.2, 0.6, 0.4);\n * // result === [2, 0, -1, 1, 0, 0.25, -1, 1, 2, 0.5]\n */\n\nIntersections2D.clipTriangleAtAxisAlignedThreshold = function (threshold, keepAbove, u0, u1, u2, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(threshold)) {\n    throw new DeveloperError(\"threshold is required.\");\n  }\n\n  if (!defined(keepAbove)) {\n    throw new DeveloperError(\"keepAbove is required.\");\n  }\n\n  if (!defined(u0)) {\n    throw new DeveloperError(\"u0 is required.\");\n  }\n\n  if (!defined(u1)) {\n    throw new DeveloperError(\"u1 is required.\");\n  }\n\n  if (!defined(u2)) {\n    throw new DeveloperError(\"u2 is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(result)) {\n    result = [];\n  } else {\n    result.length = 0;\n  }\n\n  var u0Behind;\n  var u1Behind;\n  var u2Behind;\n\n  if (keepAbove) {\n    u0Behind = u0 < threshold;\n    u1Behind = u1 < threshold;\n    u2Behind = u2 < threshold;\n  } else {\n    u0Behind = u0 > threshold;\n    u1Behind = u1 > threshold;\n    u2Behind = u2 > threshold;\n  }\n\n  var numBehind = u0Behind + u1Behind + u2Behind;\n  var u01Ratio;\n  var u02Ratio;\n  var u12Ratio;\n  var u10Ratio;\n  var u20Ratio;\n  var u21Ratio;\n\n  if (numBehind === 1) {\n    if (u0Behind) {\n      u01Ratio = (threshold - u0) / (u1 - u0);\n      u02Ratio = (threshold - u0) / (u2 - u0);\n      result.push(1);\n      result.push(2);\n\n      if (u02Ratio !== 1.0) {\n        result.push(-1);\n        result.push(0);\n        result.push(2);\n        result.push(u02Ratio);\n      }\n\n      if (u01Ratio !== 1.0) {\n        result.push(-1);\n        result.push(0);\n        result.push(1);\n        result.push(u01Ratio);\n      }\n    } else if (u1Behind) {\n      u12Ratio = (threshold - u1) / (u2 - u1);\n      u10Ratio = (threshold - u1) / (u0 - u1);\n      result.push(2);\n      result.push(0);\n\n      if (u10Ratio !== 1.0) {\n        result.push(-1);\n        result.push(1);\n        result.push(0);\n        result.push(u10Ratio);\n      }\n\n      if (u12Ratio !== 1.0) {\n        result.push(-1);\n        result.push(1);\n        result.push(2);\n        result.push(u12Ratio);\n      }\n    } else if (u2Behind) {\n      u20Ratio = (threshold - u2) / (u0 - u2);\n      u21Ratio = (threshold - u2) / (u1 - u2);\n      result.push(0);\n      result.push(1);\n\n      if (u21Ratio !== 1.0) {\n        result.push(-1);\n        result.push(2);\n        result.push(1);\n        result.push(u21Ratio);\n      }\n\n      if (u20Ratio !== 1.0) {\n        result.push(-1);\n        result.push(2);\n        result.push(0);\n        result.push(u20Ratio);\n      }\n    }\n  } else if (numBehind === 2) {\n    if (!u0Behind && u0 !== threshold) {\n      u10Ratio = (threshold - u1) / (u0 - u1);\n      u20Ratio = (threshold - u2) / (u0 - u2);\n      result.push(0);\n      result.push(-1);\n      result.push(1);\n      result.push(0);\n      result.push(u10Ratio);\n      result.push(-1);\n      result.push(2);\n      result.push(0);\n      result.push(u20Ratio);\n    } else if (!u1Behind && u1 !== threshold) {\n      u21Ratio = (threshold - u2) / (u1 - u2);\n      u01Ratio = (threshold - u0) / (u1 - u0);\n      result.push(1);\n      result.push(-1);\n      result.push(2);\n      result.push(1);\n      result.push(u21Ratio);\n      result.push(-1);\n      result.push(0);\n      result.push(1);\n      result.push(u01Ratio);\n    } else if (!u2Behind && u2 !== threshold) {\n      u02Ratio = (threshold - u0) / (u2 - u0);\n      u12Ratio = (threshold - u1) / (u2 - u1);\n      result.push(2);\n      result.push(-1);\n      result.push(0);\n      result.push(2);\n      result.push(u02Ratio);\n      result.push(-1);\n      result.push(1);\n      result.push(2);\n      result.push(u12Ratio);\n    }\n  } else if (numBehind !== 3) {\n    // Completely in front of threshold\n    result.push(0);\n    result.push(1);\n    result.push(2);\n  } // else Completely behind threshold\n\n\n  return result;\n};\n/**\n * Compute the barycentric coordinates of a 2D position within a 2D triangle.\n *\n * @param {Number} x The x coordinate of the position for which to find the barycentric coordinates.\n * @param {Number} y The y coordinate of the position for which to find the barycentric coordinates.\n * @param {Number} x1 The x coordinate of the triangle's first vertex.\n * @param {Number} y1 The y coordinate of the triangle's first vertex.\n * @param {Number} x2 The x coordinate of the triangle's second vertex.\n * @param {Number} y2 The y coordinate of the triangle's second vertex.\n * @param {Number} x3 The x coordinate of the triangle's third vertex.\n * @param {Number} y3 The y coordinate of the triangle's third vertex.\n * @param {Cartesian3} [result] The instance into to which to copy the result.  If this parameter\n *                     is undefined, a new instance is created and returned.\n * @returns {Cartesian3} The barycentric coordinates of the position within the triangle.\n *\n * @example\n * var result = Cesium.Intersections2D.computeBarycentricCoordinates(0.0, 0.0, 0.0, 1.0, -1, -0.5, 1, -0.5);\n * // result === new Cesium.Cartesian3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0);\n */\n\n\nIntersections2D.computeBarycentricCoordinates = function (x, y, x1, y1, x2, y2, x3, y3, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(x)) {\n    throw new DeveloperError(\"x is required.\");\n  }\n\n  if (!defined(y)) {\n    throw new DeveloperError(\"y is required.\");\n  }\n\n  if (!defined(x1)) {\n    throw new DeveloperError(\"x1 is required.\");\n  }\n\n  if (!defined(y1)) {\n    throw new DeveloperError(\"y1 is required.\");\n  }\n\n  if (!defined(x2)) {\n    throw new DeveloperError(\"x2 is required.\");\n  }\n\n  if (!defined(y2)) {\n    throw new DeveloperError(\"y2 is required.\");\n  }\n\n  if (!defined(x3)) {\n    throw new DeveloperError(\"x3 is required.\");\n  }\n\n  if (!defined(y3)) {\n    throw new DeveloperError(\"y3 is required.\");\n  } //>>includeEnd('debug');\n\n\n  var x1mx3 = x1 - x3;\n  var x3mx2 = x3 - x2;\n  var y2my3 = y2 - y3;\n  var y1my3 = y1 - y3;\n  var inverseDeterminant = 1.0 / (y2my3 * x1mx3 + x3mx2 * y1my3);\n  var ymy3 = y - y3;\n  var xmx3 = x - x3;\n  var l1 = (y2my3 * xmx3 + x3mx2 * ymy3) * inverseDeterminant;\n  var l2 = (-y1my3 * xmx3 + x1mx3 * ymy3) * inverseDeterminant;\n  var l3 = 1.0 - l1 - l2;\n\n  if (defined(result)) {\n    result.x = l1;\n    result.y = l2;\n    result.z = l3;\n    return result;\n  }\n\n  return new Cartesian3(l1, l2, l3);\n};\n/**\n * Compute the intersection between 2 line segments\n *\n * @param {Number} x00 The x coordinate of the first line's first vertex.\n * @param {Number} y00 The y coordinate of the first line's first vertex.\n * @param {Number} x01 The x coordinate of the first line's second vertex.\n * @param {Number} y01 The y coordinate of the first line's second vertex.\n * @param {Number} x10 The x coordinate of the second line's first vertex.\n * @param {Number} y10 The y coordinate of the second line's first vertex.\n * @param {Number} x11 The x coordinate of the second line's second vertex.\n * @param {Number} y11 The y coordinate of the second line's second vertex.\n * @param {Cartesian2} [result] The instance into to which to copy the result. If this parameter\n *                     is undefined, a new instance is created and returned.\n * @returns {Cartesian2} The intersection point, undefined if there is no intersection point or lines are coincident.\n *\n * @example\n * var result = Cesium.Intersections2D.computeLineSegmentLineSegmentIntersection(0.0, 0.0, 0.0, 2.0, -1, 1, 1, 1);\n * // result === new Cesium.Cartesian2(0.0, 1.0);\n */\n\n\nIntersections2D.computeLineSegmentLineSegmentIntersection = function (x00, y00, x01, y01, x10, y10, x11, y11, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"x00\", x00);\n  Check.typeOf.number(\"y00\", y00);\n  Check.typeOf.number(\"x01\", x01);\n  Check.typeOf.number(\"y01\", y01);\n  Check.typeOf.number(\"x10\", x10);\n  Check.typeOf.number(\"y10\", y10);\n  Check.typeOf.number(\"x11\", x11);\n  Check.typeOf.number(\"y11\", y11); //>>includeEnd('debug');\n\n  var numerator1A = (x11 - x10) * (y00 - y10) - (y11 - y10) * (x00 - x10);\n  var numerator1B = (x01 - x00) * (y00 - y10) - (y01 - y00) * (x00 - x10);\n  var denominator1 = (y11 - y10) * (x01 - x00) - (x11 - x10) * (y01 - y00); // If denominator = 0, then lines are parallel. If denominator = 0 and both numerators are 0, then coincident\n\n  if (denominator1 === 0) {\n    return;\n  }\n\n  var ua1 = numerator1A / denominator1;\n  var ub1 = numerator1B / denominator1;\n\n  if (ua1 >= 0 && ua1 <= 1 && ub1 >= 0 && ub1 <= 1) {\n    if (!defined(result)) {\n      result = new Cartesian2();\n    }\n\n    result.x = x00 + ua1 * (x01 - x00);\n    result.y = y00 + ua1 * (y01 - y00);\n    return result;\n  }\n};\n\nexport default Intersections2D;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/Intersections2D.js"],"names":["Cartesian2","Cartesian3","Check","defined","DeveloperError","Intersections2D","clipTriangleAtAxisAlignedThreshold","threshold","keepAbove","u0","u1","u2","result","length","u0Behind","u1Behind","u2Behind","numBehind","u01Ratio","u02Ratio","u12Ratio","u10Ratio","u20Ratio","u21Ratio","push","computeBarycentricCoordinates","x","y","x1","y1","x2","y2","x3","y3","x1mx3","x3mx2","y2my3","y1my3","inverseDeterminant","ymy3","xmx3","l1","l2","l3","z","computeLineSegmentLineSegmentIntersection","x00","y00","x01","y01","x10","y10","x11","y11","typeOf","number","numerator1A","numerator1B","denominator1","ua1","ub1"],"mappings":"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","sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Contains functions for operating on 2D triangles.\n *\n * @exports Intersections2D\n */\nvar Intersections2D = {};\n\n/**\n * Splits a 2D triangle at given axis-aligned threshold value and returns the resulting\n * polygon on a given side of the threshold.  The resulting polygon may have 0, 1, 2,\n * 3, or 4 vertices.\n *\n * @param {Number} threshold The threshold coordinate value at which to clip the triangle.\n * @param {Boolean} keepAbove true to keep the portion of the triangle above the threshold, or false\n *                            to keep the portion below.\n * @param {Number} u0 The coordinate of the first vertex in the triangle, in counter-clockwise order.\n * @param {Number} u1 The coordinate of the second vertex in the triangle, in counter-clockwise order.\n * @param {Number} u2 The coordinate of the third vertex in the triangle, in counter-clockwise order.\n * @param {Number[]} [result] The array into which to copy the result.  If this parameter is not supplied,\n *                            a new array is constructed and returned.\n * @returns {Number[]} The polygon that results after the clip, specified as a list of\n *                     vertices.  The vertices are specified in counter-clockwise order.\n *                     Each vertex is either an index from the existing list (identified as\n *                     a 0, 1, or 2) or -1 indicating a new vertex not in the original triangle.\n *                     For new vertices, the -1 is followed by three additional numbers: the\n *                     index of each of the two original vertices forming the line segment that\n *                     the new vertex lies on, and the fraction of the distance from the first\n *                     vertex to the second one.\n *\n * @example\n * var result = Cesium.Intersections2D.clipTriangleAtAxisAlignedThreshold(0.5, false, 0.2, 0.6, 0.4);\n * // result === [2, 0, -1, 1, 0, 0.25, -1, 1, 2, 0.5]\n */\nIntersections2D.clipTriangleAtAxisAlignedThreshold = function (\n  threshold,\n  keepAbove,\n  u0,\n  u1,\n  u2,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(threshold)) {\n    throw new DeveloperError(\"threshold is required.\");\n  }\n  if (!defined(keepAbove)) {\n    throw new DeveloperError(\"keepAbove is required.\");\n  }\n  if (!defined(u0)) {\n    throw new DeveloperError(\"u0 is required.\");\n  }\n  if (!defined(u1)) {\n    throw new DeveloperError(\"u1 is required.\");\n  }\n  if (!defined(u2)) {\n    throw new DeveloperError(\"u2 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = [];\n  } else {\n    result.length = 0;\n  }\n\n  var u0Behind;\n  var u1Behind;\n  var u2Behind;\n  if (keepAbove) {\n    u0Behind = u0 < threshold;\n    u1Behind = u1 < threshold;\n    u2Behind = u2 < threshold;\n  } else {\n    u0Behind = u0 > threshold;\n    u1Behind = u1 > threshold;\n    u2Behind = u2 > threshold;\n  }\n\n  var numBehind = u0Behind + u1Behind + u2Behind;\n\n  var u01Ratio;\n  var u02Ratio;\n  var u12Ratio;\n  var u10Ratio;\n  var u20Ratio;\n  var u21Ratio;\n\n  if (numBehind === 1) {\n    if (u0Behind) {\n      u01Ratio = (threshold - u0) / (u1 - u0);\n      u02Ratio = (threshold - u0) / (u2 - u0);\n\n      result.push(1);\n\n      result.push(2);\n\n      if (u02Ratio !== 1.0) {\n        result.push(-1);\n        result.push(0);\n        result.push(2);\n        result.push(u02Ratio);\n      }\n\n      if (u01Ratio !== 1.0) {\n        result.push(-1);\n        result.push(0);\n        result.push(1);\n        result.push(u01Ratio);\n      }\n    } else if (u1Behind) {\n      u12Ratio = (threshold - u1) / (u2 - u1);\n      u10Ratio = (threshold - u1) / (u0 - u1);\n\n      result.push(2);\n\n      result.push(0);\n\n      if (u10Ratio !== 1.0) {\n        result.push(-1);\n        result.push(1);\n        result.push(0);\n        result.push(u10Ratio);\n      }\n\n      if (u12Ratio !== 1.0) {\n        result.push(-1);\n        result.push(1);\n        result.push(2);\n        result.push(u12Ratio);\n      }\n    } else if (u2Behind) {\n      u20Ratio = (threshold - u2) / (u0 - u2);\n      u21Ratio = (threshold - u2) / (u1 - u2);\n\n      result.push(0);\n\n      result.push(1);\n\n      if (u21Ratio !== 1.0) {\n        result.push(-1);\n        result.push(2);\n        result.push(1);\n        result.push(u21Ratio);\n      }\n\n      if (u20Ratio !== 1.0) {\n        result.push(-1);\n        result.push(2);\n        result.push(0);\n        result.push(u20Ratio);\n      }\n    }\n  } else if (numBehind === 2) {\n    if (!u0Behind && u0 !== threshold) {\n      u10Ratio = (threshold - u1) / (u0 - u1);\n      u20Ratio = (threshold - u2) / (u0 - u2);\n\n      result.push(0);\n\n      result.push(-1);\n      result.push(1);\n      result.push(0);\n      result.push(u10Ratio);\n\n      result.push(-1);\n      result.push(2);\n      result.push(0);\n      result.push(u20Ratio);\n    } else if (!u1Behind && u1 !== threshold) {\n      u21Ratio = (threshold - u2) / (u1 - u2);\n      u01Ratio = (threshold - u0) / (u1 - u0);\n\n      result.push(1);\n\n      result.push(-1);\n      result.push(2);\n      result.push(1);\n      result.push(u21Ratio);\n\n      result.push(-1);\n      result.push(0);\n      result.push(1);\n      result.push(u01Ratio);\n    } else if (!u2Behind && u2 !== threshold) {\n      u02Ratio = (threshold - u0) / (u2 - u0);\n      u12Ratio = (threshold - u1) / (u2 - u1);\n\n      result.push(2);\n\n      result.push(-1);\n      result.push(0);\n      result.push(2);\n      result.push(u02Ratio);\n\n      result.push(-1);\n      result.push(1);\n      result.push(2);\n      result.push(u12Ratio);\n    }\n  } else if (numBehind !== 3) {\n    // Completely in front of threshold\n    result.push(0);\n    result.push(1);\n    result.push(2);\n  }\n  // else Completely behind threshold\n\n  return result;\n};\n\n/**\n * Compute the barycentric coordinates of a 2D position within a 2D triangle.\n *\n * @param {Number} x The x coordinate of the position for which to find the barycentric coordinates.\n * @param {Number} y The y coordinate of the position for which to find the barycentric coordinates.\n * @param {Number} x1 The x coordinate of the triangle's first vertex.\n * @param {Number} y1 The y coordinate of the triangle's first vertex.\n * @param {Number} x2 The x coordinate of the triangle's second vertex.\n * @param {Number} y2 The y coordinate of the triangle's second vertex.\n * @param {Number} x3 The x coordinate of the triangle's third vertex.\n * @param {Number} y3 The y coordinate of the triangle's third vertex.\n * @param {Cartesian3} [result] The instance into to which to copy the result.  If this parameter\n *                     is undefined, a new instance is created and returned.\n * @returns {Cartesian3} The barycentric coordinates of the position within the triangle.\n *\n * @example\n * var result = Cesium.Intersections2D.computeBarycentricCoordinates(0.0, 0.0, 0.0, 1.0, -1, -0.5, 1, -0.5);\n * // result === new Cesium.Cartesian3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0);\n */\nIntersections2D.computeBarycentricCoordinates = function (\n  x,\n  y,\n  x1,\n  y1,\n  x2,\n  y2,\n  x3,\n  y3,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(x)) {\n    throw new DeveloperError(\"x is required.\");\n  }\n  if (!defined(y)) {\n    throw new DeveloperError(\"y is required.\");\n  }\n  if (!defined(x1)) {\n    throw new DeveloperError(\"x1 is required.\");\n  }\n  if (!defined(y1)) {\n    throw new DeveloperError(\"y1 is required.\");\n  }\n  if (!defined(x2)) {\n    throw new DeveloperError(\"x2 is required.\");\n  }\n  if (!defined(y2)) {\n    throw new DeveloperError(\"y2 is required.\");\n  }\n  if (!defined(x3)) {\n    throw new DeveloperError(\"x3 is required.\");\n  }\n  if (!defined(y3)) {\n    throw new DeveloperError(\"y3 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var x1mx3 = x1 - x3;\n  var x3mx2 = x3 - x2;\n  var y2my3 = y2 - y3;\n  var y1my3 = y1 - y3;\n  var inverseDeterminant = 1.0 / (y2my3 * x1mx3 + x3mx2 * y1my3);\n  var ymy3 = y - y3;\n  var xmx3 = x - x3;\n  var l1 = (y2my3 * xmx3 + x3mx2 * ymy3) * inverseDeterminant;\n  var l2 = (-y1my3 * xmx3 + x1mx3 * ymy3) * inverseDeterminant;\n  var l3 = 1.0 - l1 - l2;\n\n  if (defined(result)) {\n    result.x = l1;\n    result.y = l2;\n    result.z = l3;\n    return result;\n  }\n  return new Cartesian3(l1, l2, l3);\n};\n\n/**\n * Compute the intersection between 2 line segments\n *\n * @param {Number} x00 The x coordinate of the first line's first vertex.\n * @param {Number} y00 The y coordinate of the first line's first vertex.\n * @param {Number} x01 The x coordinate of the first line's second vertex.\n * @param {Number} y01 The y coordinate of the first line's second vertex.\n * @param {Number} x10 The x coordinate of the second line's first vertex.\n * @param {Number} y10 The y coordinate of the second line's first vertex.\n * @param {Number} x11 The x coordinate of the second line's second vertex.\n * @param {Number} y11 The y coordinate of the second line's second vertex.\n * @param {Cartesian2} [result] The instance into to which to copy the result. If this parameter\n *                     is undefined, a new instance is created and returned.\n * @returns {Cartesian2} The intersection point, undefined if there is no intersection point or lines are coincident.\n *\n * @example\n * var result = Cesium.Intersections2D.computeLineSegmentLineSegmentIntersection(0.0, 0.0, 0.0, 2.0, -1, 1, 1, 1);\n * // result === new Cesium.Cartesian2(0.0, 1.0);\n */\nIntersections2D.computeLineSegmentLineSegmentIntersection = function (\n  x00,\n  y00,\n  x01,\n  y01,\n  x10,\n  y10,\n  x11,\n  y11,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"x00\", x00);\n  Check.typeOf.number(\"y00\", y00);\n  Check.typeOf.number(\"x01\", x01);\n  Check.typeOf.number(\"y01\", y01);\n  Check.typeOf.number(\"x10\", x10);\n  Check.typeOf.number(\"y10\", y10);\n  Check.typeOf.number(\"x11\", x11);\n  Check.typeOf.number(\"y11\", y11);\n  //>>includeEnd('debug');\n\n  var numerator1A = (x11 - x10) * (y00 - y10) - (y11 - y10) * (x00 - x10);\n  var numerator1B = (x01 - x00) * (y00 - y10) - (y01 - y00) * (x00 - x10);\n  var denominator1 = (y11 - y10) * (x01 - x00) - (x11 - x10) * (y01 - y00);\n\n  // If denominator = 0, then lines are parallel. If denominator = 0 and both numerators are 0, then coincident\n  if (denominator1 === 0) {\n    return;\n  }\n\n  var ua1 = numerator1A / denominator1;\n  var ub1 = numerator1B / denominator1;\n\n  if (ua1 >= 0 && ua1 <= 1 && ub1 >= 0 && ub1 <= 1) {\n    if (!defined(result)) {\n      result = new Cartesian2();\n    }\n\n    result.x = x00 + ua1 * (x01 - x00);\n    result.y = y00 + ua1 * (y01 - y00);\n\n    return result;\n  }\n};\nexport default Intersections2D;\n"]},"metadata":{},"sourceType":"module"}