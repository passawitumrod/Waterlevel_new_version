{"ast":null,"code":"import addExtensionsUsed from './addExtensionsUsed.js';\nimport addExtensionsRequired from './addExtensionsRequired.js';\nimport addToArray from './addToArray.js';\nimport ForEach from './ForEach.js';\nimport defined from '../../Core/defined.js';\n/**\n * Move glTF 1.0 material techniques to glTF 2.0 KHR_techniques_webgl extension.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @returns {Object} The updated glTF asset.\n *\n * @private\n */\n\nfunction moveTechniquesToExtension(gltf) {\n  var techniquesLegacy = gltf.techniques;\n  var mappedUniforms = {};\n  var updatedTechniqueIndices = {};\n\n  if (defined(techniquesLegacy)) {\n    var extension = {\n      programs: [],\n      shaders: [],\n      techniques: []\n    }; // Some 1.1 models have a glExtensionsUsed property that can be transferred to program.glExtensions\n\n    var glExtensions = gltf.glExtensionsUsed;\n    delete gltf.glExtensionsUsed;\n    ForEach.technique(gltf, function (techniqueLegacy, techniqueIndex) {\n      var technique = {\n        name: techniqueLegacy.name,\n        program: undefined,\n        attributes: {},\n        uniforms: {}\n      };\n      var parameterLegacy;\n      ForEach.techniqueAttribute(techniqueLegacy, function (parameterName, attributeName) {\n        parameterLegacy = techniqueLegacy.parameters[parameterName];\n        technique.attributes[attributeName] = {\n          semantic: parameterLegacy.semantic\n        };\n      });\n      ForEach.techniqueUniform(techniqueLegacy, function (parameterName, uniformName) {\n        parameterLegacy = techniqueLegacy.parameters[parameterName];\n        technique.uniforms[uniformName] = {\n          count: parameterLegacy.count,\n          node: parameterLegacy.node,\n          type: parameterLegacy.type,\n          semantic: parameterLegacy.semantic,\n          value: parameterLegacy.value\n        }; // Store the name of the uniform to update material values.\n\n        mappedUniforms[parameterName] = uniformName;\n      });\n      var programLegacy = gltf.programs[techniqueLegacy.program];\n      var program = {\n        name: programLegacy.name,\n        fragmentShader: undefined,\n        vertexShader: undefined,\n        glExtensions: glExtensions\n      };\n      var fs = gltf.shaders[programLegacy.fragmentShader];\n      program.fragmentShader = addToArray(extension.shaders, fs, true);\n      var vs = gltf.shaders[programLegacy.vertexShader];\n      program.vertexShader = addToArray(extension.shaders, vs, true);\n      technique.program = addToArray(extension.programs, program); // Store the index of the new technique to reference instead.\n\n      updatedTechniqueIndices[techniqueIndex] = addToArray(extension.techniques, technique);\n    });\n\n    if (extension.techniques.length > 0) {\n      if (!defined(gltf.extensions)) {\n        gltf.extensions = {};\n      }\n\n      gltf.extensions.KHR_techniques_webgl = extension;\n      addExtensionsUsed(gltf, 'KHR_techniques_webgl');\n      addExtensionsRequired(gltf, 'KHR_techniques_webgl');\n    }\n  }\n\n  ForEach.material(gltf, function (material) {\n    if (defined(material.technique)) {\n      var materialExtension = {\n        technique: updatedTechniqueIndices[material.technique]\n      };\n      ForEach.objectLegacy(material.values, function (value, parameterName) {\n        if (!defined(materialExtension.values)) {\n          materialExtension.values = {};\n        }\n\n        var uniformName = mappedUniforms[parameterName];\n        materialExtension.values[uniformName] = value;\n      });\n\n      if (!defined(material.extensions)) {\n        material.extensions = {};\n      }\n\n      material.extensions.KHR_techniques_webgl = materialExtension;\n    }\n\n    delete material.technique;\n    delete material.values;\n  });\n  delete gltf.techniques;\n  delete gltf.programs;\n  delete gltf.shaders;\n  return gltf;\n}\n\nexport default moveTechniquesToExtension;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/ThirdParty/GltfPipeline/moveTechniquesToExtension.js"],"names":["addExtensionsUsed","addExtensionsRequired","addToArray","ForEach","defined","moveTechniquesToExtension","gltf","techniquesLegacy","techniques","mappedUniforms","updatedTechniqueIndices","extension","programs","shaders","glExtensions","glExtensionsUsed","technique","techniqueLegacy","techniqueIndex","name","program","undefined","attributes","uniforms","parameterLegacy","techniqueAttribute","parameterName","attributeName","parameters","semantic","techniqueUniform","uniformName","count","node","type","value","programLegacy","fragmentShader","vertexShader","fs","vs","length","extensions","KHR_techniques_webgl","material","materialExtension","objectLegacy","values"],"mappings":"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","sourcesContent":["import addExtensionsUsed from './addExtensionsUsed.js'\nimport addExtensionsRequired from './addExtensionsRequired.js'\nimport addToArray from './addToArray.js'\nimport ForEach from './ForEach.js'\nimport defined from '../../Core/defined.js'\n\n    /**\n     * Move glTF 1.0 material techniques to glTF 2.0 KHR_techniques_webgl extension.\n     *\n     * @param {Object} gltf A javascript object containing a glTF asset.\n     * @returns {Object} The updated glTF asset.\n     *\n     * @private\n     */\n    function moveTechniquesToExtension(gltf) {\n        var techniquesLegacy = gltf.techniques;\n        var mappedUniforms = {};\n        var updatedTechniqueIndices = {};\n        if (defined(techniquesLegacy)) {\n            var extension = {\n                programs: [],\n                shaders: [],\n                techniques: []\n            };\n\n            // Some 1.1 models have a glExtensionsUsed property that can be transferred to program.glExtensions\n            var glExtensions = gltf.glExtensionsUsed;\n            delete gltf.glExtensionsUsed;\n\n            ForEach.technique(gltf, function (techniqueLegacy, techniqueIndex) {\n                var technique = {\n                    name: techniqueLegacy.name,\n                    program: undefined,\n                    attributes: {},\n                    uniforms: {}\n                };\n\n                var parameterLegacy;\n                ForEach.techniqueAttribute(techniqueLegacy, function (parameterName, attributeName) {\n                    parameterLegacy = techniqueLegacy.parameters[parameterName];\n                    technique.attributes[attributeName] = {\n                        semantic: parameterLegacy.semantic\n                    };\n                });\n\n                ForEach.techniqueUniform(techniqueLegacy, function (parameterName, uniformName) {\n                    parameterLegacy = techniqueLegacy.parameters[parameterName];\n                    technique.uniforms[uniformName] = {\n                        count: parameterLegacy.count,\n                        node: parameterLegacy.node,\n                        type: parameterLegacy.type,\n                        semantic: parameterLegacy.semantic,\n                        value: parameterLegacy.value\n                    };\n\n                    // Store the name of the uniform to update material values.\n                    mappedUniforms[parameterName] = uniformName;\n                });\n\n                var programLegacy = gltf.programs[techniqueLegacy.program];\n                var program = {\n                    name: programLegacy.name,\n                    fragmentShader: undefined,\n                    vertexShader: undefined,\n                    glExtensions: glExtensions\n                };\n\n                var fs = gltf.shaders[programLegacy.fragmentShader];\n                program.fragmentShader = addToArray(extension.shaders, fs, true);\n\n                var vs = gltf.shaders[programLegacy.vertexShader];\n                program.vertexShader = addToArray(extension.shaders, vs, true);\n\n                technique.program = addToArray(extension.programs, program);\n\n                // Store the index of the new technique to reference instead.\n                updatedTechniqueIndices[techniqueIndex] = addToArray(extension.techniques, technique);\n            });\n\n            if (extension.techniques.length > 0) {\n                if (!defined(gltf.extensions)) {\n                    gltf.extensions = {};\n                }\n\n                gltf.extensions.KHR_techniques_webgl = extension;\n                addExtensionsUsed(gltf, 'KHR_techniques_webgl');\n                addExtensionsRequired(gltf, 'KHR_techniques_webgl');\n            }\n        }\n\n        ForEach.material(gltf, function (material) {\n            if (defined(material.technique)) {\n                var materialExtension = {\n                    technique: updatedTechniqueIndices[material.technique]\n                };\n\n                ForEach.objectLegacy(material.values, function (value, parameterName) {\n                    if (!defined(materialExtension.values)) {\n                        materialExtension.values = {};\n                    }\n\n                    var uniformName = mappedUniforms[parameterName];\n                    materialExtension.values[uniformName] = value;\n                });\n\n                if (!defined(material.extensions)) {\n                    material.extensions = {};\n                }\n\n                material.extensions.KHR_techniques_webgl = materialExtension;\n            }\n\n            delete material.technique;\n            delete material.values;\n        });\n\n        delete gltf.techniques;\n        delete gltf.programs;\n        delete gltf.shaders;\n\n        return gltf;\n    }\n\n    export default moveTechniquesToExtension;\n"]},"metadata":{},"sourceType":"module"}