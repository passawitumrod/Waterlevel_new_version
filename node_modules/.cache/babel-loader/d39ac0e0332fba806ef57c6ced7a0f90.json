{"ast":null,"code":"import BoundingSphere from \"./BoundingSphere.js\";\nimport buildModuleUrl from \"./buildModuleUrl.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Resource from \"./Resource.js\";\nvar scratchDiagonalCartesianNE = new Cartesian3();\nvar scratchDiagonalCartesianSW = new Cartesian3();\nvar scratchDiagonalCartographic = new Cartographic();\nvar scratchCenterCartesian = new Cartesian3();\nvar scratchSurfaceCartesian = new Cartesian3();\nvar scratchBoundingSphere = new BoundingSphere();\nvar tilingScheme = new GeographicTilingScheme();\nvar scratchCorners = [new Cartographic(), new Cartographic(), new Cartographic(), new Cartographic()];\nvar scratchTileXY = new Cartesian2();\n/**\n * A collection of functions for approximating terrain height\n * @private\n */\n\nvar ApproximateTerrainHeights = {};\n/**\n * Initializes the minimum and maximum terrain heights\n * @return {Promise}\n */\n\nApproximateTerrainHeights.initialize = function () {\n  var initPromise = ApproximateTerrainHeights._initPromise;\n\n  if (defined(initPromise)) {\n    return initPromise;\n  }\n\n  initPromise = Resource.fetchJson(buildModuleUrl(\"Assets/approximateTerrainHeights.json\")).then(function (json) {\n    ApproximateTerrainHeights._terrainHeights = json;\n  });\n  ApproximateTerrainHeights._initPromise = initPromise;\n  return initPromise;\n};\n/**\n * Computes the minimum and maximum terrain heights for a given rectangle\n * @param {Rectangle} rectangle The bounding rectangle\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid\n * @return {{minimumTerrainHeight: Number, maximumTerrainHeight: Number}}\n */\n\n\nApproximateTerrainHeights.getMinimumMaximumHeights = function (rectangle, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"rectangle\", rectangle);\n\n  if (!defined(ApproximateTerrainHeights._terrainHeights)) {\n    throw new DeveloperError(\"You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function\");\n  } //>>includeEnd('debug');\n\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  var xyLevel = getTileXYLevel(rectangle); // Get the terrain min/max for that tile\n\n  var minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\n  var maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n\n  if (defined(xyLevel)) {\n    var key = xyLevel.level + \"-\" + xyLevel.x + \"-\" + xyLevel.y;\n    var heights = ApproximateTerrainHeights._terrainHeights[key];\n\n    if (defined(heights)) {\n      minTerrainHeight = heights[0];\n      maxTerrainHeight = heights[1];\n    } // Compute min by taking the center of the NE->SW diagonal and finding distance to the surface\n\n\n    ellipsoid.cartographicToCartesian(Rectangle.northeast(rectangle, scratchDiagonalCartographic), scratchDiagonalCartesianNE);\n    ellipsoid.cartographicToCartesian(Rectangle.southwest(rectangle, scratchDiagonalCartographic), scratchDiagonalCartesianSW);\n    Cartesian3.midpoint(scratchDiagonalCartesianSW, scratchDiagonalCartesianNE, scratchCenterCartesian);\n    var surfacePosition = ellipsoid.scaleToGeodeticSurface(scratchCenterCartesian, scratchSurfaceCartesian);\n\n    if (defined(surfacePosition)) {\n      var distance = Cartesian3.distance(scratchCenterCartesian, surfacePosition);\n      minTerrainHeight = Math.min(minTerrainHeight, -distance);\n    } else {\n      minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\n    }\n  }\n\n  minTerrainHeight = Math.max(ApproximateTerrainHeights._defaultMinTerrainHeight, minTerrainHeight);\n  return {\n    minimumTerrainHeight: minTerrainHeight,\n    maximumTerrainHeight: maxTerrainHeight\n  };\n};\n/**\n * Computes the bounding sphere based on the tile heights in the rectangle\n * @param {Rectangle} rectangle The bounding rectangle\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid\n * @return {BoundingSphere} The result bounding sphere\n */\n\n\nApproximateTerrainHeights.getBoundingSphere = function (rectangle, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"rectangle\", rectangle);\n\n  if (!defined(ApproximateTerrainHeights._terrainHeights)) {\n    throw new DeveloperError(\"You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function\");\n  } //>>includeEnd('debug');\n\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  var xyLevel = getTileXYLevel(rectangle); // Get the terrain max for that tile\n\n  var maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n\n  if (defined(xyLevel)) {\n    var key = xyLevel.level + \"-\" + xyLevel.x + \"-\" + xyLevel.y;\n    var heights = ApproximateTerrainHeights._terrainHeights[key];\n\n    if (defined(heights)) {\n      maxTerrainHeight = heights[1];\n    }\n  }\n\n  var result = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, 0.0);\n  BoundingSphere.fromRectangle3D(rectangle, ellipsoid, maxTerrainHeight, scratchBoundingSphere);\n  return BoundingSphere.union(result, scratchBoundingSphere, result);\n};\n\nfunction getTileXYLevel(rectangle) {\n  Cartographic.fromRadians(rectangle.east, rectangle.north, 0.0, scratchCorners[0]);\n  Cartographic.fromRadians(rectangle.west, rectangle.north, 0.0, scratchCorners[1]);\n  Cartographic.fromRadians(rectangle.east, rectangle.south, 0.0, scratchCorners[2]);\n  Cartographic.fromRadians(rectangle.west, rectangle.south, 0.0, scratchCorners[3]); // Determine which tile the bounding rectangle is in\n\n  var lastLevelX = 0,\n      lastLevelY = 0;\n  var currentX = 0,\n      currentY = 0;\n  var maxLevel = ApproximateTerrainHeights._terrainHeightsMaxLevel;\n  var i;\n\n  for (i = 0; i <= maxLevel; ++i) {\n    var failed = false;\n\n    for (var j = 0; j < 4; ++j) {\n      var corner = scratchCorners[j];\n      tilingScheme.positionToTileXY(corner, i, scratchTileXY);\n\n      if (j === 0) {\n        currentX = scratchTileXY.x;\n        currentY = scratchTileXY.y;\n      } else if (currentX !== scratchTileXY.x || currentY !== scratchTileXY.y) {\n        failed = true;\n        break;\n      }\n    }\n\n    if (failed) {\n      break;\n    }\n\n    lastLevelX = currentX;\n    lastLevelY = currentY;\n  }\n\n  if (i === 0) {\n    return undefined;\n  }\n\n  return {\n    x: lastLevelX,\n    y: lastLevelY,\n    level: i > maxLevel ? maxLevel : i - 1\n  };\n}\n\nApproximateTerrainHeights._terrainHeightsMaxLevel = 6;\nApproximateTerrainHeights._defaultMaxTerrainHeight = 9000.0;\nApproximateTerrainHeights._defaultMinTerrainHeight = -100000.0;\nApproximateTerrainHeights._terrainHeights = undefined;\nApproximateTerrainHeights._initPromise = undefined;\nObject.defineProperties(ApproximateTerrainHeights, {\n  /**\n   * Determines if the terrain heights are initialized and ready to use. To initialize the terrain heights,\n   * call {@link ApproximateTerrainHeights#initialize} and wait for the returned promise to resolve.\n   * @type {Boolean}\n   * @readonly\n   * @memberof ApproximateTerrainHeights\n   */\n  initialized: {\n    get: function () {\n      return defined(ApproximateTerrainHeights._terrainHeights);\n    }\n  }\n});\nexport default ApproximateTerrainHeights;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/ApproximateTerrainHeights.js"],"names":["BoundingSphere","buildModuleUrl","Cartesian2","Cartesian3","Cartographic","Check","defaultValue","defined","DeveloperError","Ellipsoid","GeographicTilingScheme","Rectangle","Resource","scratchDiagonalCartesianNE","scratchDiagonalCartesianSW","scratchDiagonalCartographic","scratchCenterCartesian","scratchSurfaceCartesian","scratchBoundingSphere","tilingScheme","scratchCorners","scratchTileXY","ApproximateTerrainHeights","initialize","initPromise","_initPromise","fetchJson","then","json","_terrainHeights","getMinimumMaximumHeights","rectangle","ellipsoid","WGS84","xyLevel","getTileXYLevel","minTerrainHeight","_defaultMinTerrainHeight","maxTerrainHeight","_defaultMaxTerrainHeight","key","level","x","y","heights","cartographicToCartesian","northeast","southwest","midpoint","surfacePosition","scaleToGeodeticSurface","distance","Math","min","max","minimumTerrainHeight","maximumTerrainHeight","getBoundingSphere","result","fromRectangle3D","union","fromRadians","east","north","west","south","lastLevelX","lastLevelY","currentX","currentY","maxLevel","_terrainHeightsMaxLevel","i","failed","j","corner","positionToTileXY","undefined","Object","defineProperties","initialized","get"],"mappings":"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","sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport buildModuleUrl from \"./buildModuleUrl.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Resource from \"./Resource.js\";\n\nvar scratchDiagonalCartesianNE = new Cartesian3();\nvar scratchDiagonalCartesianSW = new Cartesian3();\nvar scratchDiagonalCartographic = new Cartographic();\nvar scratchCenterCartesian = new Cartesian3();\nvar scratchSurfaceCartesian = new Cartesian3();\n\nvar scratchBoundingSphere = new BoundingSphere();\nvar tilingScheme = new GeographicTilingScheme();\nvar scratchCorners = [\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n];\nvar scratchTileXY = new Cartesian2();\n\n/**\n * A collection of functions for approximating terrain height\n * @private\n */\nvar ApproximateTerrainHeights = {};\n\n/**\n * Initializes the minimum and maximum terrain heights\n * @return {Promise}\n */\nApproximateTerrainHeights.initialize = function () {\n  var initPromise = ApproximateTerrainHeights._initPromise;\n  if (defined(initPromise)) {\n    return initPromise;\n  }\n\n  initPromise = Resource.fetchJson(\n    buildModuleUrl(\"Assets/approximateTerrainHeights.json\")\n  ).then(function (json) {\n    ApproximateTerrainHeights._terrainHeights = json;\n  });\n  ApproximateTerrainHeights._initPromise = initPromise;\n\n  return initPromise;\n};\n\n/**\n * Computes the minimum and maximum terrain heights for a given rectangle\n * @param {Rectangle} rectangle The bounding rectangle\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid\n * @return {{minimumTerrainHeight: Number, maximumTerrainHeight: Number}}\n */\nApproximateTerrainHeights.getMinimumMaximumHeights = function (\n  rectangle,\n  ellipsoid\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"rectangle\", rectangle);\n  if (!defined(ApproximateTerrainHeights._terrainHeights)) {\n    throw new DeveloperError(\n      \"You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function\"\n    );\n  }\n  //>>includeEnd('debug');\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  var xyLevel = getTileXYLevel(rectangle);\n\n  // Get the terrain min/max for that tile\n  var minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\n  var maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n  if (defined(xyLevel)) {\n    var key = xyLevel.level + \"-\" + xyLevel.x + \"-\" + xyLevel.y;\n    var heights = ApproximateTerrainHeights._terrainHeights[key];\n    if (defined(heights)) {\n      minTerrainHeight = heights[0];\n      maxTerrainHeight = heights[1];\n    }\n\n    // Compute min by taking the center of the NE->SW diagonal and finding distance to the surface\n    ellipsoid.cartographicToCartesian(\n      Rectangle.northeast(rectangle, scratchDiagonalCartographic),\n      scratchDiagonalCartesianNE\n    );\n    ellipsoid.cartographicToCartesian(\n      Rectangle.southwest(rectangle, scratchDiagonalCartographic),\n      scratchDiagonalCartesianSW\n    );\n\n    Cartesian3.midpoint(\n      scratchDiagonalCartesianSW,\n      scratchDiagonalCartesianNE,\n      scratchCenterCartesian\n    );\n    var surfacePosition = ellipsoid.scaleToGeodeticSurface(\n      scratchCenterCartesian,\n      scratchSurfaceCartesian\n    );\n    if (defined(surfacePosition)) {\n      var distance = Cartesian3.distance(\n        scratchCenterCartesian,\n        surfacePosition\n      );\n      minTerrainHeight = Math.min(minTerrainHeight, -distance);\n    } else {\n      minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\n    }\n  }\n\n  minTerrainHeight = Math.max(\n    ApproximateTerrainHeights._defaultMinTerrainHeight,\n    minTerrainHeight\n  );\n\n  return {\n    minimumTerrainHeight: minTerrainHeight,\n    maximumTerrainHeight: maxTerrainHeight,\n  };\n};\n\n/**\n * Computes the bounding sphere based on the tile heights in the rectangle\n * @param {Rectangle} rectangle The bounding rectangle\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid\n * @return {BoundingSphere} The result bounding sphere\n */\nApproximateTerrainHeights.getBoundingSphere = function (rectangle, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"rectangle\", rectangle);\n  if (!defined(ApproximateTerrainHeights._terrainHeights)) {\n    throw new DeveloperError(\n      \"You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function\"\n    );\n  }\n  //>>includeEnd('debug');\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  var xyLevel = getTileXYLevel(rectangle);\n\n  // Get the terrain max for that tile\n  var maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n  if (defined(xyLevel)) {\n    var key = xyLevel.level + \"-\" + xyLevel.x + \"-\" + xyLevel.y;\n    var heights = ApproximateTerrainHeights._terrainHeights[key];\n    if (defined(heights)) {\n      maxTerrainHeight = heights[1];\n    }\n  }\n\n  var result = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, 0.0);\n  BoundingSphere.fromRectangle3D(\n    rectangle,\n    ellipsoid,\n    maxTerrainHeight,\n    scratchBoundingSphere\n  );\n\n  return BoundingSphere.union(result, scratchBoundingSphere, result);\n};\n\nfunction getTileXYLevel(rectangle) {\n  Cartographic.fromRadians(\n    rectangle.east,\n    rectangle.north,\n    0.0,\n    scratchCorners[0]\n  );\n  Cartographic.fromRadians(\n    rectangle.west,\n    rectangle.north,\n    0.0,\n    scratchCorners[1]\n  );\n  Cartographic.fromRadians(\n    rectangle.east,\n    rectangle.south,\n    0.0,\n    scratchCorners[2]\n  );\n  Cartographic.fromRadians(\n    rectangle.west,\n    rectangle.south,\n    0.0,\n    scratchCorners[3]\n  );\n\n  // Determine which tile the bounding rectangle is in\n  var lastLevelX = 0,\n    lastLevelY = 0;\n  var currentX = 0,\n    currentY = 0;\n  var maxLevel = ApproximateTerrainHeights._terrainHeightsMaxLevel;\n  var i;\n  for (i = 0; i <= maxLevel; ++i) {\n    var failed = false;\n    for (var j = 0; j < 4; ++j) {\n      var corner = scratchCorners[j];\n      tilingScheme.positionToTileXY(corner, i, scratchTileXY);\n      if (j === 0) {\n        currentX = scratchTileXY.x;\n        currentY = scratchTileXY.y;\n      } else if (currentX !== scratchTileXY.x || currentY !== scratchTileXY.y) {\n        failed = true;\n        break;\n      }\n    }\n\n    if (failed) {\n      break;\n    }\n\n    lastLevelX = currentX;\n    lastLevelY = currentY;\n  }\n\n  if (i === 0) {\n    return undefined;\n  }\n\n  return {\n    x: lastLevelX,\n    y: lastLevelY,\n    level: i > maxLevel ? maxLevel : i - 1,\n  };\n}\n\nApproximateTerrainHeights._terrainHeightsMaxLevel = 6;\nApproximateTerrainHeights._defaultMaxTerrainHeight = 9000.0;\nApproximateTerrainHeights._defaultMinTerrainHeight = -100000.0;\nApproximateTerrainHeights._terrainHeights = undefined;\nApproximateTerrainHeights._initPromise = undefined;\n\nObject.defineProperties(ApproximateTerrainHeights, {\n  /**\n   * Determines if the terrain heights are initialized and ready to use. To initialize the terrain heights,\n   * call {@link ApproximateTerrainHeights#initialize} and wait for the returned promise to resolve.\n   * @type {Boolean}\n   * @readonly\n   * @memberof ApproximateTerrainHeights\n   */\n  initialized: {\n    get: function () {\n      return defined(ApproximateTerrainHeights._terrainHeights);\n    },\n  },\n});\nexport default ApproximateTerrainHeights;\n"]},"metadata":{},"sourceType":"module"}