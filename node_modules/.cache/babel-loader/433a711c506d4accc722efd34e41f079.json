{"ast":null,"code":"import addExtensionsUsed from './addExtensionsUsed.js';\nimport addToArray from './addToArray.js';\nimport findAccessorMinMax from './findAccessorMinMax.js';\nimport ForEach from './ForEach.js';\nimport getAccessorByteStride from './getAccessorByteStride.js';\nimport numberOfComponentsForType from './numberOfComponentsForType.js';\nimport moveTechniqueRenderStates from './moveTechniqueRenderStates.js';\nimport moveTechniquesToExtension from './moveTechniquesToExtension.js';\nimport removeUnusedElements from './removeUnusedElements.js';\nimport updateAccessorComponentTypes from './updateAccessorComponentTypes.js';\nimport Cartesian3 from '../../Core/Cartesian3.js';\nimport Cartesian4 from '../../Core/Cartesian4.js';\nimport clone from '../../Core/clone.js';\nimport ComponentDatatype from '../../Core/ComponentDatatype.js';\nimport defaultValue from '../../Core/defaultValue.js';\nimport defined from '../../Core/defined.js';\nimport Matrix4 from '../../Core/Matrix4.js';\nimport Quaternion from '../../Core/Quaternion.js';\nimport WebGLConstants from '../../Core/WebGLConstants.js';\nvar updateFunctions = {\n  '0.8': glTF08to10,\n  '1.0': glTF10to20,\n  '2.0': undefined\n};\n/**\n * Update the glTF version to the latest version (2.0), or targetVersion if specified.\n * Applies changes made to the glTF spec between revisions so that the core library\n * only has to handle the latest version.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @param {Object} [options] Options for updating the glTF.\n * @param {String} [options.targetVersion] The glTF will be upgraded until it hits the specified version.\n * @returns {Object} The updated glTF asset.\n *\n * @private\n */\n\nfunction updateVersion(gltf, options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var targetVersion = options.targetVersion;\n  var version = gltf.version;\n  gltf.asset = defaultValue(gltf.asset, {\n    version: '1.0'\n  });\n  gltf.asset.version = defaultValue(gltf.asset.version, '1.0');\n  version = defaultValue(version, gltf.asset.version).toString(); // Invalid version\n\n  if (!Object.prototype.hasOwnProperty.call(updateFunctions, version)) {\n    // Try truncating trailing version numbers, could be a number as well if it is 0.8\n    if (defined(version)) {\n      version = version.substring(0, 3);\n    } // Default to 1.0 if it cannot be determined\n\n\n    if (!Object.prototype.hasOwnProperty.call(updateFunctions, version)) {\n      version = '1.0';\n    }\n  }\n\n  var updateFunction = updateFunctions[version];\n\n  while (defined(updateFunction)) {\n    if (version === targetVersion) {\n      break;\n    }\n\n    updateFunction(gltf, options);\n    version = gltf.asset.version;\n    updateFunction = updateFunctions[version];\n  }\n\n  return gltf;\n}\n\nfunction updateInstanceTechniques(gltf) {\n  var materials = gltf.materials;\n\n  for (var materialId in materials) {\n    if (Object.prototype.hasOwnProperty.call(materials, materialId)) {\n      var material = materials[materialId];\n      var instanceTechnique = material.instanceTechnique;\n\n      if (defined(instanceTechnique)) {\n        material.technique = instanceTechnique.technique;\n        material.values = instanceTechnique.values;\n        delete material.instanceTechnique;\n      }\n    }\n  }\n}\n\nfunction setPrimitiveModes(gltf) {\n  var meshes = gltf.meshes;\n\n  for (var meshId in meshes) {\n    if (Object.prototype.hasOwnProperty.call(meshes, meshId)) {\n      var mesh = meshes[meshId];\n      var primitives = mesh.primitives;\n\n      if (defined(primitives)) {\n        var primitivesLength = primitives.length;\n\n        for (var i = 0; i < primitivesLength; ++i) {\n          var primitive = primitives[i];\n          var defaultMode = defaultValue(primitive.primitive, WebGLConstants.TRIANGLES);\n          primitive.mode = defaultValue(primitive.mode, defaultMode);\n          delete primitive.primitive;\n        }\n      }\n    }\n  }\n}\n\nfunction updateNodes(gltf) {\n  var nodes = gltf.nodes;\n  var axis = new Cartesian3();\n  var quat = new Quaternion();\n\n  for (var nodeId in nodes) {\n    if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {\n      var node = nodes[nodeId];\n\n      if (defined(node.rotation)) {\n        var rotation = node.rotation;\n        Cartesian3.fromArray(rotation, 0, axis);\n        Quaternion.fromAxisAngle(axis, rotation[3], quat);\n        node.rotation = [quat.x, quat.y, quat.z, quat.w];\n      }\n\n      var instanceSkin = node.instanceSkin;\n\n      if (defined(instanceSkin)) {\n        node.skeletons = instanceSkin.skeletons;\n        node.skin = instanceSkin.skin;\n        node.meshes = instanceSkin.meshes;\n        delete node.instanceSkin;\n      }\n    }\n  }\n}\n\nfunction updateAnimations(gltf) {\n  var animations = gltf.animations;\n  var accessors = gltf.accessors;\n  var bufferViews = gltf.bufferViews;\n  var buffers = gltf.buffers;\n  var updatedAccessors = {};\n  var axis = new Cartesian3();\n  var quat = new Quaternion();\n\n  for (var animationId in animations) {\n    if (Object.prototype.hasOwnProperty.call(animations, animationId)) {\n      var animation = animations[animationId];\n      var channels = animation.channels;\n      var parameters = animation.parameters;\n      var samplers = animation.samplers;\n\n      if (defined(channels)) {\n        var channelsLength = channels.length;\n\n        for (var i = 0; i < channelsLength; ++i) {\n          var channel = channels[i];\n\n          if (channel.target.path === 'rotation') {\n            var accessorId = parameters[samplers[channel.sampler].output];\n\n            if (defined(updatedAccessors[accessorId])) {\n              continue;\n            }\n\n            updatedAccessors[accessorId] = true;\n            var accessor = accessors[accessorId];\n            var bufferView = bufferViews[accessor.bufferView];\n            var buffer = buffers[bufferView.buffer];\n            var source = buffer.extras._pipeline.source;\n            var byteOffset = source.byteOffset + bufferView.byteOffset + accessor.byteOffset;\n            var componentType = accessor.componentType;\n            var count = accessor.count;\n            var componentsLength = numberOfComponentsForType(accessor.type);\n            var length = accessor.count * componentsLength;\n            var typedArray = ComponentDatatype.createArrayBufferView(componentType, source.buffer, byteOffset, length);\n\n            for (var j = 0; j < count; j++) {\n              var offset = j * componentsLength;\n              Cartesian3.unpack(typedArray, offset, axis);\n              var angle = typedArray[offset + 3];\n              Quaternion.fromAxisAngle(axis, angle, quat);\n              Quaternion.pack(quat, typedArray, offset);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction removeTechniquePasses(gltf) {\n  var techniques = gltf.techniques;\n\n  for (var techniqueId in techniques) {\n    if (Object.prototype.hasOwnProperty.call(techniques, techniqueId)) {\n      var technique = techniques[techniqueId];\n      var passes = technique.passes;\n\n      if (defined(passes)) {\n        var passName = defaultValue(technique.pass, 'defaultPass');\n\n        if (Object.prototype.hasOwnProperty.call(passes, passName)) {\n          var pass = passes[passName];\n          var instanceProgram = pass.instanceProgram;\n          technique.attributes = defaultValue(technique.attributes, instanceProgram.attributes);\n          technique.program = defaultValue(technique.program, instanceProgram.program);\n          technique.uniforms = defaultValue(technique.uniforms, instanceProgram.uniforms);\n          technique.states = defaultValue(technique.states, pass.states);\n        }\n\n        delete technique.passes;\n        delete technique.pass;\n      }\n    }\n  }\n}\n\nfunction glTF08to10(gltf) {\n  if (!defined(gltf.asset)) {\n    gltf.asset = {};\n  }\n\n  var asset = gltf.asset;\n  asset.version = '1.0'; // Profile should be an object, not a string\n\n  if (typeof asset.profile === 'string') {\n    var split = asset.profile.split(' ');\n    asset.profile = {\n      api: split[0],\n      version: split[1]\n    };\n  } else {\n    asset.profile = {};\n  } // Version property should be in asset, not on the root element\n\n\n  if (defined(gltf.version)) {\n    delete gltf.version;\n  } // material.instanceTechnique properties should be directly on the material\n\n\n  updateInstanceTechniques(gltf); // primitive.primitive should be primitive.mode\n\n  setPrimitiveModes(gltf); // Node rotation should be quaternion, not axis-angle\n  // node.instanceSkin is deprecated\n\n  updateNodes(gltf); // Animations that target rotations should be quaternion, not axis-angle\n\n  updateAnimations(gltf); // technique.pass and techniques.passes are deprecated\n\n  removeTechniquePasses(gltf); // gltf.allExtensions -> extensionsUsed\n\n  if (defined(gltf.allExtensions)) {\n    gltf.extensionsUsed = gltf.allExtensions;\n    delete gltf.allExtensions;\n  } // gltf.lights -> khrMaterialsCommon.lights\n\n\n  if (defined(gltf.lights)) {\n    var extensions = defaultValue(gltf.extensions, {});\n    gltf.extensions = extensions;\n    var materialsCommon = defaultValue(extensions.KHR_materials_common, {});\n    extensions.KHR_materials_common = materialsCommon;\n    materialsCommon.lights = gltf.lights;\n    delete gltf.lights;\n    addExtensionsUsed(gltf, 'KHR_materials_common');\n  }\n}\n\nfunction removeAnimationSamplersIndirection(gltf) {\n  var animations = gltf.animations;\n\n  for (var animationId in animations) {\n    if (Object.prototype.hasOwnProperty.call(animations, animationId)) {\n      var animation = animations[animationId];\n      var parameters = animation.parameters;\n\n      if (defined(parameters)) {\n        var samplers = animation.samplers;\n\n        for (var samplerId in samplers) {\n          if (Object.prototype.hasOwnProperty.call(samplers, samplerId)) {\n            var sampler = samplers[samplerId];\n            sampler.input = parameters[sampler.input];\n            sampler.output = parameters[sampler.output];\n          }\n        }\n\n        delete animation.parameters;\n      }\n    }\n  }\n}\n\nfunction objectToArray(object, mapping) {\n  var array = [];\n\n  for (var id in object) {\n    if (Object.prototype.hasOwnProperty.call(object, id)) {\n      var value = object[id];\n      mapping[id] = array.length;\n      array.push(value);\n\n      if (!defined(value.name)) {\n        value.name = id;\n      }\n    }\n  }\n\n  return array;\n}\n\nfunction objectsToArrays(gltf) {\n  var i;\n  var globalMapping = {\n    accessors: {},\n    animations: {},\n    buffers: {},\n    bufferViews: {},\n    cameras: {},\n    images: {},\n    materials: {},\n    meshes: {},\n    nodes: {},\n    programs: {},\n    samplers: {},\n    scenes: {},\n    shaders: {},\n    skins: {},\n    textures: {},\n    techniques: {}\n  }; // Map joint names to id names\n\n  var jointName;\n  var jointNameToId = {};\n  var nodes = gltf.nodes;\n\n  for (var id in nodes) {\n    if (Object.prototype.hasOwnProperty.call(nodes, id)) {\n      jointName = nodes[id].jointName;\n\n      if (defined(jointName)) {\n        jointNameToId[jointName] = id;\n      }\n    }\n  } // Convert top level objects to arrays\n\n\n  for (var topLevelId in gltf) {\n    if (Object.prototype.hasOwnProperty.call(gltf, topLevelId) && defined(globalMapping[topLevelId])) {\n      var objectMapping = {};\n      var object = gltf[topLevelId];\n      gltf[topLevelId] = objectToArray(object, objectMapping);\n      globalMapping[topLevelId] = objectMapping;\n    }\n  } // Remap joint names to array indexes\n\n\n  for (jointName in jointNameToId) {\n    if (Object.prototype.hasOwnProperty.call(jointNameToId, jointName)) {\n      jointNameToId[jointName] = globalMapping.nodes[jointNameToId[jointName]];\n    }\n  } // Fix references\n\n\n  if (defined(gltf.scene)) {\n    gltf.scene = globalMapping.scenes[gltf.scene];\n  }\n\n  ForEach.bufferView(gltf, function (bufferView) {\n    if (defined(bufferView.buffer)) {\n      bufferView.buffer = globalMapping.buffers[bufferView.buffer];\n    }\n  });\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.bufferView)) {\n      accessor.bufferView = globalMapping.bufferViews[accessor.bufferView];\n    }\n  });\n  ForEach.shader(gltf, function (shader) {\n    var extensions = shader.extensions;\n\n    if (defined(extensions)) {\n      var binaryGltf = extensions.KHR_binary_glTF;\n\n      if (defined(binaryGltf)) {\n        shader.bufferView = globalMapping.bufferViews[binaryGltf.bufferView];\n        delete extensions.KHR_binary_glTF;\n      }\n\n      if (Object.keys(extensions).length === 0) {\n        delete shader.extensions;\n      }\n    }\n  });\n  ForEach.program(gltf, function (program) {\n    if (defined(program.vertexShader)) {\n      program.vertexShader = globalMapping.shaders[program.vertexShader];\n    }\n\n    if (defined(program.fragmentShader)) {\n      program.fragmentShader = globalMapping.shaders[program.fragmentShader];\n    }\n  });\n  ForEach.technique(gltf, function (technique) {\n    if (defined(technique.program)) {\n      technique.program = globalMapping.programs[technique.program];\n    }\n\n    ForEach.techniqueParameter(technique, function (parameter) {\n      if (defined(parameter.node)) {\n        parameter.node = globalMapping.nodes[parameter.node];\n      }\n\n      var value = parameter.value;\n\n      if (typeof value === 'string') {\n        parameter.value = {\n          index: globalMapping.textures[value]\n        };\n      }\n    });\n  });\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      if (defined(primitive.indices)) {\n        primitive.indices = globalMapping.accessors[primitive.indices];\n      }\n\n      ForEach.meshPrimitiveAttribute(primitive, function (accessorId, semantic) {\n        primitive.attributes[semantic] = globalMapping.accessors[accessorId];\n      });\n\n      if (defined(primitive.material)) {\n        primitive.material = globalMapping.materials[primitive.material];\n      }\n    });\n  });\n  ForEach.node(gltf, function (node) {\n    var children = node.children;\n\n    if (defined(children)) {\n      var childrenLength = children.length;\n\n      for (i = 0; i < childrenLength; ++i) {\n        children[i] = globalMapping.nodes[children[i]];\n      }\n    }\n\n    if (defined(node.meshes)) {\n      // Split out meshes on nodes\n      var meshes = node.meshes;\n      var meshesLength = meshes.length;\n\n      if (meshesLength > 0) {\n        node.mesh = globalMapping.meshes[meshes[0]];\n\n        for (i = 1; i < meshesLength; ++i) {\n          var meshNode = {\n            mesh: globalMapping.meshes[meshes[i]]\n          };\n          var meshNodeId = addToArray(gltf.nodes, meshNode);\n\n          if (!defined(children)) {\n            children = [];\n            node.children = children;\n          }\n\n          children.push(meshNodeId);\n        }\n      }\n\n      delete node.meshes;\n    }\n\n    if (defined(node.camera)) {\n      node.camera = globalMapping.cameras[node.camera];\n    }\n\n    if (defined(node.skin)) {\n      node.skin = globalMapping.skins[node.skin];\n    }\n\n    if (defined(node.skeletons)) {\n      // Assign skeletons to skins\n      var skeletons = node.skeletons;\n      var skeletonsLength = skeletons.length;\n\n      if (skeletonsLength > 0 && defined(node.skin)) {\n        var skin = gltf.skins[node.skin];\n        skin.skeleton = globalMapping.nodes[skeletons[0]];\n      }\n\n      delete node.skeletons;\n    }\n\n    if (defined(node.jointName)) {\n      delete node.jointName;\n    }\n  });\n  ForEach.skin(gltf, function (skin) {\n    if (defined(skin.inverseBindMatrices)) {\n      skin.inverseBindMatrices = globalMapping.accessors[skin.inverseBindMatrices];\n    }\n\n    var jointNames = skin.jointNames;\n\n    if (defined(jointNames)) {\n      var joints = [];\n      var jointNamesLength = jointNames.length;\n\n      for (i = 0; i < jointNamesLength; ++i) {\n        joints[i] = jointNameToId[jointNames[i]];\n      }\n\n      skin.joints = joints;\n      delete skin.jointNames;\n    }\n  });\n  ForEach.scene(gltf, function (scene) {\n    var sceneNodes = scene.nodes;\n\n    if (defined(sceneNodes)) {\n      var sceneNodesLength = sceneNodes.length;\n\n      for (i = 0; i < sceneNodesLength; ++i) {\n        sceneNodes[i] = globalMapping.nodes[sceneNodes[i]];\n      }\n    }\n  });\n  ForEach.animation(gltf, function (animation) {\n    var samplerMapping = {};\n    animation.samplers = objectToArray(animation.samplers, samplerMapping);\n    ForEach.animationSampler(animation, function (sampler) {\n      sampler.input = globalMapping.accessors[sampler.input];\n      sampler.output = globalMapping.accessors[sampler.output];\n    });\n    ForEach.animationChannel(animation, function (channel) {\n      channel.sampler = samplerMapping[channel.sampler];\n      var target = channel.target;\n\n      if (defined(target)) {\n        target.node = globalMapping.nodes[target.id];\n        delete target.id;\n      }\n    });\n  });\n  ForEach.material(gltf, function (material) {\n    if (defined(material.technique)) {\n      material.technique = globalMapping.techniques[material.technique];\n    }\n\n    ForEach.materialValue(material, function (value, name) {\n      if (typeof value === 'string') {\n        material.values[name] = {\n          index: globalMapping.textures[value]\n        };\n      }\n    });\n    var extensions = material.extensions;\n\n    if (defined(extensions)) {\n      var materialsCommon = extensions.KHR_materials_common;\n\n      if (defined(materialsCommon)) {\n        ForEach.materialValue(materialsCommon, function (value, name) {\n          if (typeof value === 'string') {\n            materialsCommon.values[name] = {\n              index: globalMapping.textures[value]\n            };\n          }\n        });\n      }\n    }\n  });\n  ForEach.image(gltf, function (image) {\n    var extensions = image.extensions;\n\n    if (defined(extensions)) {\n      var binaryGltf = extensions.KHR_binary_glTF;\n\n      if (defined(binaryGltf)) {\n        image.bufferView = globalMapping.bufferViews[binaryGltf.bufferView];\n        image.mimeType = binaryGltf.mimeType;\n        delete extensions.KHR_binary_glTF;\n      }\n\n      if (Object.keys(extensions).length === 0) {\n        delete image.extensions;\n      }\n    }\n\n    ForEach.compressedImage(image, function (compressedImage) {\n      var compressedExtensions = compressedImage.extensions;\n\n      if (defined(compressedExtensions)) {\n        var compressedBinaryGltf = compressedExtensions.KHR_binary_glTF;\n\n        if (defined(compressedBinaryGltf)) {\n          compressedImage.bufferView = globalMapping.bufferViews[compressedBinaryGltf.bufferView];\n          compressedImage.mimeType = compressedBinaryGltf.mimeType;\n          delete compressedExtensions.KHR_binary_glTF;\n        }\n\n        if (Object.keys(extensions).length === 0) {\n          delete compressedImage.extensions;\n        }\n      }\n    });\n  });\n  ForEach.texture(gltf, function (texture) {\n    if (defined(texture.sampler)) {\n      texture.sampler = globalMapping.samplers[texture.sampler];\n    }\n\n    if (defined(texture.source)) {\n      texture.source = globalMapping.images[texture.source];\n    }\n  });\n}\n\nfunction removeAnimationSamplerNames(gltf) {\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationSampler(animation, function (sampler) {\n      delete sampler.name;\n    });\n  });\n}\n\nfunction removeEmptyArrays(gltf) {\n  for (var topLevelId in gltf) {\n    if (Object.prototype.hasOwnProperty.call(gltf, topLevelId)) {\n      var array = gltf[topLevelId];\n\n      if (Array.isArray(array) && array.length === 0) {\n        delete gltf[topLevelId];\n      }\n    }\n  }\n\n  ForEach.node(gltf, function (node) {\n    if (defined(node.children) && node.children.length === 0) {\n      delete node.children;\n    }\n  });\n}\n\nfunction stripAsset(gltf) {\n  var asset = gltf.asset;\n  delete asset.profile;\n  delete asset.premultipliedAlpha;\n}\n\nvar knownExtensions = {\n  CESIUM_RTC: true,\n  KHR_materials_common: true,\n  WEB3D_quantized_attributes: true\n};\n\nfunction requireKnownExtensions(gltf) {\n  var extensionsUsed = gltf.extensionsUsed;\n  gltf.extensionsRequired = defaultValue(gltf.extensionsRequired, []);\n\n  if (defined(extensionsUsed)) {\n    var extensionsUsedLength = extensionsUsed.length;\n\n    for (var i = 0; i < extensionsUsedLength; ++i) {\n      var extension = extensionsUsed[i];\n\n      if (defined(knownExtensions[extension])) {\n        gltf.extensionsRequired.push(extension);\n      }\n    }\n  }\n}\n\nfunction removeBufferType(gltf) {\n  ForEach.buffer(gltf, function (buffer) {\n    delete buffer.type;\n  });\n}\n\nfunction removeTextureProperties(gltf) {\n  ForEach.texture(gltf, function (texture) {\n    delete texture.format;\n    delete texture.internalFormat;\n    delete texture.target;\n    delete texture.type;\n  });\n}\n\nfunction requireAttributeSetIndex(gltf) {\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      ForEach.meshPrimitiveAttribute(primitive, function (accessorId, semantic) {\n        if (semantic === 'TEXCOORD') {\n          primitive.attributes.TEXCOORD_0 = accessorId;\n        } else if (semantic === 'COLOR') {\n          primitive.attributes.COLOR_0 = accessorId;\n        }\n      });\n      delete primitive.attributes.TEXCOORD;\n      delete primitive.attributes.COLOR;\n    });\n  });\n  ForEach.technique(gltf, function (technique) {\n    ForEach.techniqueParameter(technique, function (parameter) {\n      var semantic = parameter.semantic;\n\n      if (defined(semantic)) {\n        if (semantic === 'TEXCOORD') {\n          parameter.semantic = 'TEXCOORD_0';\n        } else if (semantic === 'COLOR') {\n          parameter.semantic = 'COLOR_0';\n        }\n      }\n    });\n  });\n}\n\nvar knownSemantics = {\n  POSITION: true,\n  NORMAL: true,\n  TANGENT: true\n};\nvar indexedSemantics = {\n  COLOR: 'COLOR',\n  JOINT: 'JOINTS',\n  JOINTS: 'JOINTS',\n  TEXCOORD: 'TEXCOORD',\n  WEIGHT: 'WEIGHTS',\n  WEIGHTS: 'WEIGHTS'\n};\n\nfunction underscoreApplicationSpecificSemantics(gltf) {\n  var mappedSemantics = {};\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      /*eslint-disable no-unused-vars*/\n      ForEach.meshPrimitiveAttribute(primitive, function (accessorId, semantic) {\n        if (semantic.charAt(0) !== '_') {\n          var setIndex = semantic.search(/_[0-9]+/g);\n          var strippedSemantic = semantic;\n          var suffix = '_0';\n\n          if (setIndex >= 0) {\n            strippedSemantic = semantic.substring(0, setIndex);\n            suffix = semantic.substring(setIndex);\n          }\n\n          var newSemantic;\n          var indexedSemantic = indexedSemantics[strippedSemantic];\n\n          if (defined(indexedSemantic)) {\n            newSemantic = indexedSemantic + suffix;\n            mappedSemantics[semantic] = newSemantic;\n          } else if (!defined(knownSemantics[strippedSemantic])) {\n            newSemantic = '_' + semantic;\n            mappedSemantics[semantic] = newSemantic;\n          }\n        }\n      });\n\n      for (var semantic in mappedSemantics) {\n        if (Object.prototype.hasOwnProperty.call(mappedSemantics, semantic)) {\n          var mappedSemantic = mappedSemantics[semantic];\n          var accessorId = primitive.attributes[semantic];\n\n          if (defined(accessorId)) {\n            delete primitive.attributes[semantic];\n            primitive.attributes[mappedSemantic] = accessorId;\n          }\n        }\n      }\n    });\n  });\n  ForEach.technique(gltf, function (technique) {\n    ForEach.techniqueParameter(technique, function (parameter) {\n      var mappedSemantic = mappedSemantics[parameter.semantic];\n\n      if (defined(mappedSemantic)) {\n        parameter.semantic = mappedSemantic;\n      }\n    });\n  });\n}\n\nfunction clampCameraParameters(gltf) {\n  ForEach.camera(gltf, function (camera) {\n    var perspective = camera.perspective;\n\n    if (defined(perspective)) {\n      var aspectRatio = perspective.aspectRatio;\n\n      if (defined(aspectRatio) && aspectRatio === 0.0) {\n        delete perspective.aspectRatio;\n      }\n\n      var yfov = perspective.yfov;\n\n      if (defined(yfov) && yfov === 0.0) {\n        perspective.yfov = 1.0;\n      }\n    }\n  });\n}\n\nfunction computeAccessorByteStride(gltf, accessor) {\n  return defined(accessor.byteStride) && accessor.byteStride !== 0 ? accessor.byteStride : getAccessorByteStride(gltf, accessor);\n}\n\nfunction requireByteLength(gltf) {\n  ForEach.buffer(gltf, function (buffer) {\n    if (!defined(buffer.byteLength)) {\n      buffer.byteLength = buffer.extras._pipeline.source.length;\n    }\n  });\n  ForEach.accessor(gltf, function (accessor) {\n    var bufferViewId = accessor.bufferView;\n\n    if (defined(bufferViewId)) {\n      var bufferView = gltf.bufferViews[bufferViewId];\n      var accessorByteStride = computeAccessorByteStride(gltf, accessor);\n      var accessorByteEnd = accessor.byteOffset + accessor.count * accessorByteStride;\n      bufferView.byteLength = Math.max(defaultValue(bufferView.byteLength, 0), accessorByteEnd);\n    }\n  });\n}\n\nfunction moveByteStrideToBufferView(gltf) {\n  var i;\n  var j;\n  var bufferView;\n  var bufferViews = gltf.bufferViews;\n  var bufferViewHasVertexAttributes = {};\n  ForEach.accessorContainingVertexAttributeData(gltf, function (accessorId) {\n    var accessor = gltf.accessors[accessorId];\n\n    if (defined(accessor.bufferView)) {\n      bufferViewHasVertexAttributes[accessor.bufferView] = true;\n    }\n  }); // Map buffer views to a list of accessors\n\n  var bufferViewMap = {};\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.bufferView)) {\n      bufferViewMap[accessor.bufferView] = defaultValue(bufferViewMap[accessor.bufferView], []);\n      bufferViewMap[accessor.bufferView].push(accessor);\n    }\n  }); // Split accessors with different byte strides\n\n  for (var bufferViewId in bufferViewMap) {\n    if (Object.prototype.hasOwnProperty.call(bufferViewMap, bufferViewId)) {\n      bufferView = bufferViews[bufferViewId];\n      var accessors = bufferViewMap[bufferViewId];\n      accessors.sort(function (a, b) {\n        return a.byteOffset - b.byteOffset;\n      });\n      var currentByteOffset = 0;\n      var currentIndex = 0;\n      var accessorsLength = accessors.length;\n\n      for (i = 0; i < accessorsLength; ++i) {\n        var accessor = accessors[i];\n        var accessorByteStride = computeAccessorByteStride(gltf, accessor);\n        var accessorByteOffset = accessor.byteOffset;\n        var accessorByteLength = accessor.count * accessorByteStride;\n        delete accessor.byteStride;\n        var hasNextAccessor = i < accessorsLength - 1;\n        var nextAccessorByteStride = hasNextAccessor ? computeAccessorByteStride(gltf, accessors[i + 1]) : undefined;\n\n        if (accessorByteStride !== nextAccessorByteStride) {\n          var newBufferView = clone(bufferView, true);\n\n          if (bufferViewHasVertexAttributes[bufferViewId]) {\n            newBufferView.byteStride = accessorByteStride;\n          }\n\n          newBufferView.byteOffset += currentByteOffset;\n          newBufferView.byteLength = accessorByteOffset + accessorByteLength - currentByteOffset;\n          var newBufferViewId = addToArray(bufferViews, newBufferView);\n\n          for (j = currentIndex; j <= i; ++j) {\n            accessor = accessors[j];\n            accessor.bufferView = newBufferViewId;\n            accessor.byteOffset = accessor.byteOffset - currentByteOffset;\n          } // Set current byte offset to next accessor's byte offset\n\n\n          currentByteOffset = hasNextAccessor ? accessors[i + 1].byteOffset : undefined;\n          currentIndex = i + 1;\n        }\n      }\n    }\n  } // Remove unused buffer views\n\n\n  removeUnusedElements(gltf, ['accessor', 'bufferView', 'buffer']);\n}\n\nfunction requirePositionAccessorMinMax(gltf) {\n  ForEach.accessorWithSemantic(gltf, 'POSITION', function (accessorId) {\n    var accessor = gltf.accessors[accessorId];\n\n    if (!defined(accessor.min) || !defined(accessor.max)) {\n      var minMax = findAccessorMinMax(gltf, accessor);\n      accessor.min = minMax.min;\n      accessor.max = minMax.max;\n    }\n  });\n}\n\nfunction isNodeEmpty(node) {\n  return (!defined(node.children) || node.children.length === 0) && (!defined(node.meshes) || node.meshes.length === 0) && !defined(node.camera) && !defined(node.skin) && !defined(node.skeletons) && !defined(node.jointName) && (!defined(node.translation) || Cartesian3.fromArray(node.translation).equals(Cartesian3.ZERO)) && (!defined(node.scale) || Cartesian3.fromArray(node.scale).equals(new Cartesian3(1.0, 1.0, 1.0))) && (!defined(node.rotation) || Cartesian4.fromArray(node.rotation).equals(new Cartesian4(0.0, 0.0, 0.0, 1.0))) && (!defined(node.matrix) || Matrix4.fromColumnMajorArray(node.matrix).equals(Matrix4.IDENTITY)) && !defined(node.extensions) && !defined(node.extras);\n}\n\nfunction deleteNode(gltf, nodeId) {\n  // Remove from list of nodes in scene\n  ForEach.scene(gltf, function (scene) {\n    var sceneNodes = scene.nodes;\n\n    if (defined(sceneNodes)) {\n      var sceneNodesLength = sceneNodes.length;\n\n      for (var i = sceneNodesLength; i >= 0; --i) {\n        if (sceneNodes[i] === nodeId) {\n          sceneNodes.splice(i, 1);\n          return;\n        }\n      }\n    }\n  }); // Remove parent node's reference to this node, and delete the parent if also empty\n\n  ForEach.node(gltf, function (parentNode, parentNodeId) {\n    if (defined(parentNode.children)) {\n      var index = parentNode.children.indexOf(nodeId);\n\n      if (index > -1) {\n        parentNode.children.splice(index, 1);\n\n        if (isNodeEmpty(parentNode)) {\n          deleteNode(gltf, parentNodeId);\n        }\n      }\n    }\n  });\n  delete gltf.nodes[nodeId];\n}\n\nfunction removeEmptyNodes(gltf) {\n  ForEach.node(gltf, function (node, nodeId) {\n    if (isNodeEmpty(node)) {\n      deleteNode(gltf, nodeId);\n    }\n  });\n  return gltf;\n}\n\nfunction requireAnimationAccessorMinMax(gltf) {\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationSampler(animation, function (sampler) {\n      var accessor = gltf.accessors[sampler.input];\n\n      if (!defined(accessor.min) || !defined(accessor.max)) {\n        var minMax = findAccessorMinMax(gltf, accessor);\n        accessor.min = minMax.min;\n        accessor.max = minMax.max;\n      }\n    });\n  });\n}\n\nfunction glTF10to20(gltf) {\n  gltf.asset = defaultValue(gltf.asset, {});\n  gltf.asset.version = '2.0'; // material.instanceTechnique properties should be directly on the material. instanceTechnique is a gltf 0.8 property but is seen in some 1.0 models.\n\n  updateInstanceTechniques(gltf); // animation.samplers now refers directly to accessors and animation.parameters should be removed\n\n  removeAnimationSamplersIndirection(gltf); // Remove empty nodes and re-assign referencing indices\n\n  removeEmptyNodes(gltf); // Top-level objects are now arrays referenced by index instead of id\n\n  objectsToArrays(gltf); // Animation.sampler objects cannot have names\n\n  removeAnimationSamplerNames(gltf); // asset.profile no longer exists\n\n  stripAsset(gltf); // Move known extensions from extensionsUsed to extensionsRequired\n\n  requireKnownExtensions(gltf); // bufferView.byteLength and buffer.byteLength are required\n\n  requireByteLength(gltf); // byteStride moved from accessor to bufferView\n\n  moveByteStrideToBufferView(gltf); // accessor.min and accessor.max must be defined for accessors containing POSITION attributes\n\n  requirePositionAccessorMinMax(gltf); // An animation sampler's input accessor must have min and max properties defined\n\n  requireAnimationAccessorMinMax(gltf); // buffer.type is unnecessary and should be removed\n\n  removeBufferType(gltf); // Remove format, internalFormat, target, and type\n\n  removeTextureProperties(gltf); // TEXCOORD and COLOR attributes must be written with a set index (TEXCOORD_#)\n\n  requireAttributeSetIndex(gltf); // Add underscores to application-specific parameters\n\n  underscoreApplicationSpecificSemantics(gltf); // Accessors referenced by JOINTS_0 and WEIGHTS_0 attributes must have correct component types\n\n  updateAccessorComponentTypes(gltf); // Clamp camera parameters\n\n  clampCameraParameters(gltf); // Move legacy technique render states to material properties and add KHR_blend extension blending functions\n\n  moveTechniqueRenderStates(gltf); // Add material techniques to KHR_techniques_webgl extension, removing shaders, programs, and techniques\n\n  moveTechniquesToExtension(gltf); // Remove empty arrays\n\n  removeEmptyArrays(gltf);\n}\n\nexport default updateVersion;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/ThirdParty/GltfPipeline/updateVersion.js"],"names":["addExtensionsUsed","addToArray","findAccessorMinMax","ForEach","getAccessorByteStride","numberOfComponentsForType","moveTechniqueRenderStates","moveTechniquesToExtension","removeUnusedElements","updateAccessorComponentTypes","Cartesian3","Cartesian4","clone","ComponentDatatype","defaultValue","defined","Matrix4","Quaternion","WebGLConstants","updateFunctions","glTF08to10","glTF10to20","undefined","updateVersion","gltf","options","EMPTY_OBJECT","targetVersion","version","asset","toString","Object","prototype","hasOwnProperty","call","substring","updateFunction","updateInstanceTechniques","materials","materialId","material","instanceTechnique","technique","values","setPrimitiveModes","meshes","meshId","mesh","primitives","primitivesLength","length","i","primitive","defaultMode","TRIANGLES","mode","updateNodes","nodes","axis","quat","nodeId","node","rotation","fromArray","fromAxisAngle","x","y","z","w","instanceSkin","skeletons","skin","updateAnimations","animations","accessors","bufferViews","buffers","updatedAccessors","animationId","animation","channels","parameters","samplers","channelsLength","channel","target","path","accessorId","sampler","output","accessor","bufferView","buffer","source","extras","_pipeline","byteOffset","componentType","count","componentsLength","type","typedArray","createArrayBufferView","j","offset","unpack","angle","pack","removeTechniquePasses","techniques","techniqueId","passes","passName","pass","instanceProgram","attributes","program","uniforms","states","profile","split","api","allExtensions","extensionsUsed","lights","extensions","materialsCommon","KHR_materials_common","removeAnimationSamplersIndirection","samplerId","input","objectToArray","object","mapping","array","id","value","push","name","objectsToArrays","globalMapping","cameras","images","programs","scenes","shaders","skins","textures","jointName","jointNameToId","topLevelId","objectMapping","scene","shader","binaryGltf","KHR_binary_glTF","keys","vertexShader","fragmentShader","techniqueParameter","parameter","index","meshPrimitive","indices","meshPrimitiveAttribute","semantic","children","childrenLength","meshesLength","meshNode","meshNodeId","camera","skeletonsLength","skeleton","inverseBindMatrices","jointNames","joints","jointNamesLength","sceneNodes","sceneNodesLength","samplerMapping","animationSampler","animationChannel","materialValue","image","mimeType","compressedImage","compressedExtensions","compressedBinaryGltf","texture","removeAnimationSamplerNames","removeEmptyArrays","Array","isArray","stripAsset","premultipliedAlpha","knownExtensions","CESIUM_RTC","WEB3D_quantized_attributes","requireKnownExtensions","extensionsRequired","extensionsUsedLength","extension","removeBufferType","removeTextureProperties","format","internalFormat","requireAttributeSetIndex","TEXCOORD_0","COLOR_0","TEXCOORD","COLOR","knownSemantics","POSITION","NORMAL","TANGENT","indexedSemantics","JOINT","JOINTS","WEIGHT","WEIGHTS","underscoreApplicationSpecificSemantics","mappedSemantics","charAt","setIndex","search","strippedSemantic","suffix","newSemantic","indexedSemantic","mappedSemantic","clampCameraParameters","perspective","aspectRatio","yfov","computeAccessorByteStride","byteStride","requireByteLength","byteLength","bufferViewId","accessorByteStride","accessorByteEnd","Math","max","moveByteStrideToBufferView","bufferViewHasVertexAttributes","accessorContainingVertexAttributeData","bufferViewMap","sort","a","b","currentByteOffset","currentIndex","accessorsLength","accessorByteOffset","accessorByteLength","hasNextAccessor","nextAccessorByteStride","newBufferView","newBufferViewId","requirePositionAccessorMinMax","accessorWithSemantic","min","minMax","isNodeEmpty","translation","equals","ZERO","scale","matrix","fromColumnMajorArray","IDENTITY","deleteNode","splice","parentNode","parentNodeId","indexOf","removeEmptyNodes","requireAnimationAccessorMinMax"],"mappings":"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","sourcesContent":["import addExtensionsUsed from './addExtensionsUsed.js'\nimport addToArray from './addToArray.js'\nimport findAccessorMinMax from './findAccessorMinMax.js'\nimport ForEach from './ForEach.js'\nimport getAccessorByteStride from './getAccessorByteStride.js'\nimport numberOfComponentsForType from './numberOfComponentsForType.js'\nimport moveTechniqueRenderStates from './moveTechniqueRenderStates.js'\nimport moveTechniquesToExtension from './moveTechniquesToExtension.js'\nimport removeUnusedElements from './removeUnusedElements.js'\nimport updateAccessorComponentTypes from './updateAccessorComponentTypes.js'\nimport Cartesian3 from '../../Core/Cartesian3.js'\nimport Cartesian4 from '../../Core/Cartesian4.js'\nimport clone from '../../Core/clone.js'\nimport ComponentDatatype from '../../Core/ComponentDatatype.js'\nimport defaultValue from '../../Core/defaultValue.js'\nimport defined from '../../Core/defined.js'\nimport Matrix4 from '../../Core/Matrix4.js'\nimport Quaternion from '../../Core/Quaternion.js'\nimport WebGLConstants from '../../Core/WebGLConstants.js'\n\n    var updateFunctions = {\n        '0.8': glTF08to10,\n        '1.0': glTF10to20,\n        '2.0': undefined\n    };\n\n    /**\n     * Update the glTF version to the latest version (2.0), or targetVersion if specified.\n     * Applies changes made to the glTF spec between revisions so that the core library\n     * only has to handle the latest version.\n     *\n     * @param {Object} gltf A javascript object containing a glTF asset.\n     * @param {Object} [options] Options for updating the glTF.\n     * @param {String} [options.targetVersion] The glTF will be upgraded until it hits the specified version.\n     * @returns {Object} The updated glTF asset.\n     *\n     * @private\n     */\n    function updateVersion(gltf, options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var targetVersion = options.targetVersion;\n        var version = gltf.version;\n\n        gltf.asset = defaultValue(gltf.asset, {\n            version: '1.0'\n        });\n\n        gltf.asset.version = defaultValue(gltf.asset.version, '1.0');\n        version = defaultValue(version, gltf.asset.version).toString();\n\n        // Invalid version\n        if (!Object.prototype.hasOwnProperty.call(updateFunctions, version)) {\n            // Try truncating trailing version numbers, could be a number as well if it is 0.8\n            if (defined(version)) {\n                version = version.substring(0, 3);\n            }\n            // Default to 1.0 if it cannot be determined\n            if (!Object.prototype.hasOwnProperty.call(updateFunctions, version)) {\n                version = '1.0';\n            }\n        }\n\n        var updateFunction = updateFunctions[version];\n\n        while (defined(updateFunction)) {\n            if (version === targetVersion) {\n                break;\n            }\n            updateFunction(gltf, options);\n            version = gltf.asset.version;\n            updateFunction = updateFunctions[version];\n        }\n        return gltf;\n    }\n\n    function updateInstanceTechniques(gltf) {\n        var materials = gltf.materials;\n        for (var materialId in materials) {\n            if (Object.prototype.hasOwnProperty.call(materials, materialId)) {\n                var material = materials[materialId];\n                var instanceTechnique = material.instanceTechnique;\n                if (defined(instanceTechnique)) {\n                    material.technique = instanceTechnique.technique;\n                    material.values = instanceTechnique.values;\n                    delete material.instanceTechnique;\n                }\n            }\n        }\n    }\n\n    function setPrimitiveModes(gltf) {\n        var meshes = gltf.meshes;\n        for (var meshId in meshes) {\n            if (Object.prototype.hasOwnProperty.call(meshes, meshId)) {\n                var mesh = meshes[meshId];\n                var primitives = mesh.primitives;\n                if (defined(primitives)) {\n                    var primitivesLength = primitives.length;\n                    for (var i = 0; i < primitivesLength; ++i) {\n                        var primitive = primitives[i];\n                        var defaultMode = defaultValue(primitive.primitive, WebGLConstants.TRIANGLES);\n                        primitive.mode = defaultValue(primitive.mode, defaultMode);\n                        delete primitive.primitive;\n                    }\n                }\n            }\n        }\n    }\n\n    function updateNodes(gltf) {\n        var nodes = gltf.nodes;\n        var axis = new Cartesian3();\n        var quat = new Quaternion();\n        for (var nodeId in nodes) {\n            if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {\n                var node = nodes[nodeId];\n                if (defined(node.rotation)) {\n                    var rotation = node.rotation;\n                    Cartesian3.fromArray(rotation, 0, axis);\n                    Quaternion.fromAxisAngle(axis, rotation[3], quat);\n                    node.rotation = [quat.x, quat.y, quat.z, quat.w];\n                }\n                var instanceSkin = node.instanceSkin;\n                if (defined(instanceSkin)) {\n                    node.skeletons = instanceSkin.skeletons;\n                    node.skin = instanceSkin.skin;\n                    node.meshes = instanceSkin.meshes;\n                    delete node.instanceSkin;\n                }\n            }\n        }\n    }\n\n    function updateAnimations(gltf) {\n        var animations = gltf.animations;\n        var accessors = gltf.accessors;\n        var bufferViews = gltf.bufferViews;\n        var buffers = gltf.buffers;\n        var updatedAccessors = {};\n        var axis = new Cartesian3();\n        var quat = new Quaternion();\n        for (var animationId in animations) {\n            if (Object.prototype.hasOwnProperty.call(animations, animationId)) {\n                var animation = animations[animationId];\n                var channels = animation.channels;\n                var parameters = animation.parameters;\n                var samplers = animation.samplers;\n                if (defined(channels)) {\n                    var channelsLength = channels.length;\n                    for (var i = 0; i < channelsLength; ++i) {\n                        var channel = channels[i];\n                        if (channel.target.path === 'rotation') {\n                            var accessorId = parameters[samplers[channel.sampler].output];\n                            if (defined(updatedAccessors[accessorId])) {\n                                continue;\n                            }\n                            updatedAccessors[accessorId] = true;\n                            var accessor = accessors[accessorId];\n                            var bufferView = bufferViews[accessor.bufferView];\n                            var buffer = buffers[bufferView.buffer];\n                            var source = buffer.extras._pipeline.source;\n                            var byteOffset = source.byteOffset + bufferView.byteOffset + accessor.byteOffset;\n                            var componentType = accessor.componentType;\n                            var count = accessor.count;\n                            var componentsLength = numberOfComponentsForType(accessor.type);\n                            var length = accessor.count * componentsLength;\n                            var typedArray = ComponentDatatype.createArrayBufferView(componentType, source.buffer, byteOffset, length);\n\n                            for (var j = 0; j < count; j++) {\n                                var offset = j * componentsLength;\n                                Cartesian3.unpack(typedArray, offset, axis);\n                                var angle = typedArray[offset + 3];\n                                Quaternion.fromAxisAngle(axis, angle, quat);\n                                Quaternion.pack(quat, typedArray, offset);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    function removeTechniquePasses(gltf) {\n        var techniques = gltf.techniques;\n        for (var techniqueId in techniques) {\n            if (Object.prototype.hasOwnProperty.call(techniques, techniqueId)) {\n                var technique = techniques[techniqueId];\n                var passes = technique.passes;\n                if (defined(passes)) {\n                    var passName = defaultValue(technique.pass, 'defaultPass');\n                    if (Object.prototype.hasOwnProperty.call(passes, passName)) {\n                        var pass = passes[passName];\n                        var instanceProgram = pass.instanceProgram;\n                        technique.attributes = defaultValue(technique.attributes, instanceProgram.attributes);\n                        technique.program = defaultValue(technique.program, instanceProgram.program);\n                        technique.uniforms = defaultValue(technique.uniforms, instanceProgram.uniforms);\n                        technique.states = defaultValue(technique.states, pass.states);\n                    }\n                    delete technique.passes;\n                    delete technique.pass;\n                }\n            }\n        }\n    }\n\n    function glTF08to10(gltf) {\n        if (!defined(gltf.asset)) {\n            gltf.asset = {};\n        }\n        var asset = gltf.asset;\n        asset.version = '1.0';\n        // Profile should be an object, not a string\n        if (typeof asset.profile === 'string') {\n            var split = asset.profile.split(' ');\n            asset.profile = {\n                api: split[0],\n                version: split[1]\n            };\n        } else {\n            asset.profile = {};\n        }\n\n        // Version property should be in asset, not on the root element\n        if (defined(gltf.version)) {\n            delete gltf.version;\n        }\n        // material.instanceTechnique properties should be directly on the material\n        updateInstanceTechniques(gltf);\n        // primitive.primitive should be primitive.mode\n        setPrimitiveModes(gltf);\n        // Node rotation should be quaternion, not axis-angle\n        // node.instanceSkin is deprecated\n        updateNodes(gltf);\n        // Animations that target rotations should be quaternion, not axis-angle\n        updateAnimations(gltf);\n        // technique.pass and techniques.passes are deprecated\n        removeTechniquePasses(gltf);\n        // gltf.allExtensions -> extensionsUsed\n        if (defined(gltf.allExtensions)) {\n            gltf.extensionsUsed = gltf.allExtensions;\n            delete gltf.allExtensions;\n        }\n        // gltf.lights -> khrMaterialsCommon.lights\n        if (defined(gltf.lights)) {\n            var extensions = defaultValue(gltf.extensions, {});\n            gltf.extensions = extensions;\n            var materialsCommon = defaultValue(extensions.KHR_materials_common, {});\n            extensions.KHR_materials_common = materialsCommon;\n            materialsCommon.lights = gltf.lights;\n            delete gltf.lights;\n            addExtensionsUsed(gltf, 'KHR_materials_common');\n        }\n    }\n\n    function removeAnimationSamplersIndirection(gltf) {\n        var animations = gltf.animations;\n        for (var animationId in animations) {\n            if (Object.prototype.hasOwnProperty.call(animations, animationId)) {\n                var animation = animations[animationId];\n                var parameters = animation.parameters;\n                if (defined(parameters)) {\n                    var samplers = animation.samplers;\n                    for (var samplerId in samplers) {\n                        if (Object.prototype.hasOwnProperty.call(samplers, samplerId)) {\n                            var sampler = samplers[samplerId];\n                            sampler.input = parameters[sampler.input];\n                            sampler.output = parameters[sampler.output];\n                        }\n                    }\n                    delete animation.parameters;\n                }\n            }\n        }\n    }\n\n    function objectToArray(object, mapping) {\n        var array = [];\n        for (var id in object) {\n            if (Object.prototype.hasOwnProperty.call(object, id)) {\n                var value = object[id];\n                mapping[id] = array.length;\n                array.push(value);\n                if (!defined(value.name)) {\n                    value.name = id;\n                }\n            }\n        }\n        return array;\n    }\n\n    function objectsToArrays(gltf) {\n        var i;\n        var globalMapping = {\n            accessors: {},\n            animations: {},\n            buffers: {},\n            bufferViews: {},\n            cameras: {},\n            images: {},\n            materials: {},\n            meshes: {},\n            nodes: {},\n            programs: {},\n            samplers: {},\n            scenes: {},\n            shaders: {},\n            skins: {},\n            textures: {},\n            techniques: {}\n        };\n\n        // Map joint names to id names\n        var jointName;\n        var jointNameToId = {};\n        var nodes = gltf.nodes;\n        for (var id in nodes) {\n            if (Object.prototype.hasOwnProperty.call(nodes, id)) {\n                jointName = nodes[id].jointName;\n                if (defined(jointName)) {\n                    jointNameToId[jointName] = id;\n                }\n            }\n        }\n\n        // Convert top level objects to arrays\n        for (var topLevelId in gltf) {\n            if (Object.prototype.hasOwnProperty.call(gltf, topLevelId) && defined(globalMapping[topLevelId])) {\n                var objectMapping = {};\n                var object = gltf[topLevelId];\n                gltf[topLevelId] = objectToArray(object, objectMapping);\n                globalMapping[topLevelId] = objectMapping;\n            }\n        }\n\n        // Remap joint names to array indexes\n        for (jointName in jointNameToId) {\n            if (Object.prototype.hasOwnProperty.call(jointNameToId, jointName)) {\n                jointNameToId[jointName] = globalMapping.nodes[jointNameToId[jointName]];\n            }\n        }\n\n        // Fix references\n        if (defined(gltf.scene)) {\n            gltf.scene = globalMapping.scenes[gltf.scene];\n        }\n        ForEach.bufferView(gltf, function(bufferView) {\n            if (defined(bufferView.buffer)) {\n                bufferView.buffer = globalMapping.buffers[bufferView.buffer];\n            }\n        });\n        ForEach.accessor(gltf, function(accessor) {\n            if (defined(accessor.bufferView)) {\n                accessor.bufferView = globalMapping.bufferViews[accessor.bufferView];\n            }\n        });\n        ForEach.shader(gltf, function(shader) {\n            var extensions = shader.extensions;\n            if (defined(extensions)) {\n                var binaryGltf = extensions.KHR_binary_glTF;\n                if (defined(binaryGltf)) {\n                    shader.bufferView = globalMapping.bufferViews[binaryGltf.bufferView];\n                    delete extensions.KHR_binary_glTF;\n                }\n                if (Object.keys(extensions).length === 0) {\n                    delete shader.extensions;\n                }\n            }\n        });\n        ForEach.program(gltf, function(program) {\n            if (defined(program.vertexShader)) {\n                program.vertexShader = globalMapping.shaders[program.vertexShader];\n            }\n            if (defined(program.fragmentShader)) {\n                program.fragmentShader = globalMapping.shaders[program.fragmentShader];\n            }\n        });\n        ForEach.technique(gltf, function(technique) {\n            if (defined(technique.program)) {\n                technique.program = globalMapping.programs[technique.program];\n            }\n            ForEach.techniqueParameter(technique, function(parameter) {\n                if (defined(parameter.node)) {\n                    parameter.node = globalMapping.nodes[parameter.node];\n                }\n                var value = parameter.value;\n                if (typeof value === 'string') {\n                    parameter.value = {\n                        index: globalMapping.textures[value]\n                    };\n                }\n            });\n        });\n        ForEach.mesh(gltf, function(mesh) {\n            ForEach.meshPrimitive(mesh, function(primitive) {\n                if (defined(primitive.indices)) {\n                    primitive.indices = globalMapping.accessors[primitive.indices];\n                }\n                ForEach.meshPrimitiveAttribute(primitive, function(accessorId, semantic) {\n                    primitive.attributes[semantic] = globalMapping.accessors[accessorId];\n                });\n                if (defined(primitive.material)) {\n                    primitive.material = globalMapping.materials[primitive.material];\n                }\n            });\n        });\n        ForEach.node(gltf, function(node) {\n            var children = node.children;\n            if (defined(children)) {\n                var childrenLength = children.length;\n                for (i = 0; i < childrenLength; ++i) {\n                    children[i] = globalMapping.nodes[children[i]];\n                }\n            }\n            if (defined(node.meshes)) {\n                // Split out meshes on nodes\n                var meshes = node.meshes;\n                var meshesLength = meshes.length;\n                if (meshesLength > 0) {\n                    node.mesh = globalMapping.meshes[meshes[0]];\n                    for (i = 1; i < meshesLength; ++i) {\n                        var meshNode = {\n                            mesh: globalMapping.meshes[meshes[i]]\n                        };\n                        var meshNodeId = addToArray(gltf.nodes, meshNode);\n                        if (!defined(children)) {\n                            children = [];\n                            node.children = children;\n                        }\n                        children.push(meshNodeId);\n                    }\n                }\n                delete node.meshes;\n            }\n            if (defined(node.camera)) {\n                node.camera = globalMapping.cameras[node.camera];\n            }\n            if (defined(node.skin)) {\n                node.skin = globalMapping.skins[node.skin];\n            }\n            if (defined(node.skeletons)) {\n                // Assign skeletons to skins\n                var skeletons = node.skeletons;\n                var skeletonsLength = skeletons.length;\n                if ((skeletonsLength > 0) && defined(node.skin)) {\n                    var skin = gltf.skins[node.skin];\n                    skin.skeleton = globalMapping.nodes[skeletons[0]];\n                }\n                delete node.skeletons;\n            }\n            if (defined(node.jointName)) {\n                delete node.jointName;\n            }\n        });\n        ForEach.skin(gltf, function(skin) {\n            if (defined(skin.inverseBindMatrices)) {\n                skin.inverseBindMatrices = globalMapping.accessors[skin.inverseBindMatrices];\n            }\n            var jointNames = skin.jointNames;\n            if (defined(jointNames)) {\n                var joints = [];\n                var jointNamesLength = jointNames.length;\n                for (i = 0; i < jointNamesLength; ++i) {\n                    joints[i] = jointNameToId[jointNames[i]];\n                }\n                skin.joints = joints;\n                delete skin.jointNames;\n            }\n        });\n        ForEach.scene(gltf, function(scene) {\n            var sceneNodes = scene.nodes;\n            if (defined(sceneNodes)) {\n                var sceneNodesLength = sceneNodes.length;\n                for (i = 0; i < sceneNodesLength; ++i) {\n                    sceneNodes[i] = globalMapping.nodes[sceneNodes[i]];\n                }\n            }\n        });\n        ForEach.animation(gltf, function(animation) {\n            var samplerMapping = {};\n            animation.samplers = objectToArray(animation.samplers, samplerMapping);\n            ForEach.animationSampler(animation, function(sampler) {\n                sampler.input = globalMapping.accessors[sampler.input];\n                sampler.output = globalMapping.accessors[sampler.output];\n            });\n            ForEach.animationChannel(animation, function(channel) {\n                channel.sampler = samplerMapping[channel.sampler];\n                var target = channel.target;\n                if (defined(target)) {\n                    target.node = globalMapping.nodes[target.id];\n                    delete target.id;\n                }\n            });\n        });\n        ForEach.material(gltf, function(material) {\n            if (defined(material.technique)) {\n                material.technique = globalMapping.techniques[material.technique];\n            }\n            ForEach.materialValue(material, function(value, name) {\n                if (typeof value === 'string') {\n                    material.values[name] = {\n                        index: globalMapping.textures[value]\n                    };\n                }\n            });\n            var extensions = material.extensions;\n            if (defined(extensions)) {\n                var materialsCommon = extensions.KHR_materials_common;\n                if (defined(materialsCommon)) {\n                    ForEach.materialValue(materialsCommon, function(value, name) {\n                        if (typeof value === 'string') {\n                            materialsCommon.values[name] = {\n                                index: globalMapping.textures[value]\n                            };\n                        }\n                    });\n                }\n            }\n        });\n        ForEach.image(gltf, function(image) {\n            var extensions = image.extensions;\n            if (defined(extensions)) {\n                var binaryGltf = extensions.KHR_binary_glTF;\n                if (defined(binaryGltf)) {\n                    image.bufferView = globalMapping.bufferViews[binaryGltf.bufferView];\n                    image.mimeType = binaryGltf.mimeType;\n                    delete extensions.KHR_binary_glTF;\n                }\n                if (Object.keys(extensions).length === 0) {\n                    delete image.extensions;\n                }\n            }\n            ForEach.compressedImage(image, function(compressedImage) {\n                var compressedExtensions = compressedImage.extensions;\n                if (defined(compressedExtensions)) {\n                    var compressedBinaryGltf = compressedExtensions.KHR_binary_glTF;\n                    if (defined(compressedBinaryGltf)) {\n                        compressedImage.bufferView = globalMapping.bufferViews[compressedBinaryGltf.bufferView];\n                        compressedImage.mimeType = compressedBinaryGltf.mimeType;\n                        delete compressedExtensions.KHR_binary_glTF;\n                    }\n                    if (Object.keys(extensions).length === 0) {\n                        delete compressedImage.extensions;\n                    }\n                }\n            });\n        });\n        ForEach.texture(gltf, function(texture) {\n            if (defined(texture.sampler)) {\n                texture.sampler = globalMapping.samplers[texture.sampler];\n            }\n            if (defined(texture.source)) {\n                texture.source = globalMapping.images[texture.source];\n            }\n        });\n    }\n\n    function removeAnimationSamplerNames(gltf) {\n        ForEach.animation(gltf, function(animation) {\n            ForEach.animationSampler(animation, function(sampler) {\n                delete sampler.name;\n            });\n        });\n    }\n\n    function removeEmptyArrays(gltf) {\n        for (var topLevelId in gltf) {\n            if (Object.prototype.hasOwnProperty.call(gltf, topLevelId)) {\n                var array = gltf[topLevelId];\n                if (Array.isArray(array) && array.length === 0) {\n                    delete gltf[topLevelId];\n                }\n            }\n        }\n        ForEach.node(gltf, function(node) {\n            if (defined(node.children) && node.children.length === 0) {\n                delete node.children;\n            }\n        });\n    }\n\n    function stripAsset(gltf) {\n        var asset = gltf.asset;\n        delete asset.profile;\n        delete asset.premultipliedAlpha;\n    }\n\n    var knownExtensions = {\n        CESIUM_RTC: true,\n        KHR_materials_common: true,\n        WEB3D_quantized_attributes: true\n    };\n    function requireKnownExtensions(gltf) {\n        var extensionsUsed = gltf.extensionsUsed;\n        gltf.extensionsRequired = defaultValue(gltf.extensionsRequired, []);\n        if (defined(extensionsUsed)) {\n            var extensionsUsedLength = extensionsUsed.length;\n            for (var i = 0; i < extensionsUsedLength; ++i) {\n                var extension = extensionsUsed[i];\n                if (defined(knownExtensions[extension])) {\n                    gltf.extensionsRequired.push(extension);\n                }\n            }\n        }\n    }\n\n    function removeBufferType(gltf) {\n        ForEach.buffer(gltf, function(buffer) {\n            delete buffer.type;\n        });\n    }\n\n    function removeTextureProperties(gltf) {\n        ForEach.texture(gltf, function(texture) {\n            delete texture.format;\n            delete texture.internalFormat;\n            delete texture.target;\n            delete texture.type;\n        });\n    }\n\n    function requireAttributeSetIndex(gltf) {\n        ForEach.mesh(gltf, function(mesh) {\n            ForEach.meshPrimitive(mesh, function(primitive) {\n                ForEach.meshPrimitiveAttribute(primitive, function(accessorId, semantic) {\n                    if (semantic === 'TEXCOORD') {\n                        primitive.attributes.TEXCOORD_0 = accessorId;\n                    } else if (semantic === 'COLOR') {\n                        primitive.attributes.COLOR_0 = accessorId;\n                    }\n                });\n                delete primitive.attributes.TEXCOORD;\n                delete primitive.attributes.COLOR;\n            });\n        });\n        ForEach.technique(gltf, function(technique) {\n            ForEach.techniqueParameter(technique, function(parameter) {\n                var semantic = parameter.semantic;\n                if (defined(semantic)) {\n                    if (semantic === 'TEXCOORD') {\n                        parameter.semantic = 'TEXCOORD_0';\n                    } else if (semantic === 'COLOR') {\n                        parameter.semantic = 'COLOR_0';\n                    }\n                }\n            });\n        });\n    }\n\n    var knownSemantics = {\n        POSITION: true,\n        NORMAL: true,\n        TANGENT: true\n    };\n    var indexedSemantics = {\n        COLOR: 'COLOR',\n        JOINT : 'JOINTS',\n        JOINTS: 'JOINTS',\n        TEXCOORD: 'TEXCOORD',\n        WEIGHT: 'WEIGHTS',\n        WEIGHTS: 'WEIGHTS'\n    };\n    function underscoreApplicationSpecificSemantics(gltf) {\n        var mappedSemantics = {};\n        ForEach.mesh(gltf, function(mesh) {\n            ForEach.meshPrimitive(mesh, function(primitive) {\n                /*eslint-disable no-unused-vars*/\n                ForEach.meshPrimitiveAttribute(primitive, function(accessorId, semantic) {\n                    if (semantic.charAt(0) !== '_') {\n                        var setIndex = semantic.search(/_[0-9]+/g);\n                        var strippedSemantic = semantic;\n                        var suffix = '_0';\n                        if (setIndex >= 0) {\n                            strippedSemantic = semantic.substring(0, setIndex);\n                            suffix = semantic.substring(setIndex);\n                        }\n                        var newSemantic;\n                        var indexedSemantic = indexedSemantics[strippedSemantic];\n                        if (defined(indexedSemantic)) {\n                            newSemantic = indexedSemantic + suffix;\n                            mappedSemantics[semantic] = newSemantic;\n                        } else if (!defined(knownSemantics[strippedSemantic])) {\n                            newSemantic = '_' + semantic;\n                            mappedSemantics[semantic] = newSemantic;\n                        }\n                    }\n                });\n                for (var semantic in mappedSemantics) {\n                    if (Object.prototype.hasOwnProperty.call(mappedSemantics, semantic)) {\n                        var mappedSemantic = mappedSemantics[semantic];\n                        var accessorId = primitive.attributes[semantic];\n                        if (defined(accessorId)) {\n                            delete primitive.attributes[semantic];\n                            primitive.attributes[mappedSemantic] = accessorId;\n                        }\n                    }\n                }\n            });\n        });\n        ForEach.technique(gltf, function(technique) {\n            ForEach.techniqueParameter(technique, function(parameter) {\n                var mappedSemantic = mappedSemantics[parameter.semantic];\n                if (defined(mappedSemantic)) {\n                    parameter.semantic = mappedSemantic;\n                }\n            });\n        });\n    }\n\n    function clampCameraParameters(gltf) {\n        ForEach.camera(gltf, function(camera) {\n            var perspective = camera.perspective;\n            if (defined(perspective)) {\n                var aspectRatio = perspective.aspectRatio;\n                if (defined(aspectRatio) && aspectRatio === 0.0) {\n                    delete perspective.aspectRatio;\n                }\n                var yfov = perspective.yfov;\n                if (defined(yfov) && yfov === 0.0) {\n                    perspective.yfov = 1.0;\n                }\n            }\n        });\n    }\n\n    function computeAccessorByteStride(gltf, accessor) {\n        return (defined(accessor.byteStride) && accessor.byteStride !== 0) ? accessor.byteStride : getAccessorByteStride(gltf, accessor);\n    }\n\n    function requireByteLength(gltf) {\n        ForEach.buffer(gltf, function(buffer) {\n            if (!defined(buffer.byteLength)) {\n                buffer.byteLength = buffer.extras._pipeline.source.length;\n            }\n        });\n        ForEach.accessor(gltf, function(accessor) {\n            var bufferViewId = accessor.bufferView;\n            if (defined(bufferViewId)) {\n                var bufferView = gltf.bufferViews[bufferViewId];\n                var accessorByteStride = computeAccessorByteStride(gltf, accessor);\n                var accessorByteEnd = accessor.byteOffset + accessor.count * accessorByteStride;\n                bufferView.byteLength = Math.max(defaultValue(bufferView.byteLength, 0), accessorByteEnd);\n            }\n        });\n    }\n\n    function moveByteStrideToBufferView(gltf) {\n        var i;\n        var j;\n        var bufferView;\n        var bufferViews = gltf.bufferViews;\n\n        var bufferViewHasVertexAttributes = {};\n        ForEach.accessorContainingVertexAttributeData(gltf, function(accessorId) {\n            var accessor = gltf.accessors[accessorId];\n            if (defined(accessor.bufferView)) {\n                bufferViewHasVertexAttributes[accessor.bufferView] = true;\n            }\n        });\n\n        // Map buffer views to a list of accessors\n        var bufferViewMap = {};\n        ForEach.accessor(gltf, function(accessor) {\n            if (defined(accessor.bufferView)) {\n                bufferViewMap[accessor.bufferView] = defaultValue(bufferViewMap[accessor.bufferView], []);\n                bufferViewMap[accessor.bufferView].push(accessor);\n            }\n        });\n\n        // Split accessors with different byte strides\n        for (var bufferViewId in bufferViewMap) {\n            if (Object.prototype.hasOwnProperty.call(bufferViewMap, bufferViewId)) {\n                bufferView = bufferViews[bufferViewId];\n                var accessors = bufferViewMap[bufferViewId];\n                accessors.sort(function(a, b) {\n                    return a.byteOffset - b.byteOffset;\n                });\n                var currentByteOffset = 0;\n                var currentIndex = 0;\n                var accessorsLength = accessors.length;\n                for (i = 0; i < accessorsLength; ++i) {\n                    var accessor = accessors[i];\n                    var accessorByteStride = computeAccessorByteStride(gltf, accessor);\n                    var accessorByteOffset = accessor.byteOffset;\n                    var accessorByteLength = accessor.count * accessorByteStride;\n                    delete accessor.byteStride;\n\n                    var hasNextAccessor = (i < accessorsLength - 1);\n                    var nextAccessorByteStride = hasNextAccessor ? computeAccessorByteStride(gltf, accessors[i + 1]) : undefined;\n                    if (accessorByteStride !== nextAccessorByteStride) {\n                        var newBufferView = clone(bufferView, true);\n                        if (bufferViewHasVertexAttributes[bufferViewId]) {\n                            newBufferView.byteStride = accessorByteStride;\n                        }\n                        newBufferView.byteOffset += currentByteOffset;\n                        newBufferView.byteLength = accessorByteOffset + accessorByteLength - currentByteOffset;\n                        var newBufferViewId = addToArray(bufferViews, newBufferView);\n                        for (j = currentIndex; j <= i; ++j) {\n                            accessor = accessors[j];\n                            accessor.bufferView = newBufferViewId;\n                            accessor.byteOffset = accessor.byteOffset - currentByteOffset;\n                        }\n                        // Set current byte offset to next accessor's byte offset\n                        currentByteOffset = hasNextAccessor ? accessors[i + 1].byteOffset : undefined;\n                        currentIndex = i + 1;\n                    }\n                }\n            }\n        }\n\n        // Remove unused buffer views\n        removeUnusedElements(gltf, ['accessor', 'bufferView', 'buffer']);\n    }\n\n    function requirePositionAccessorMinMax(gltf) {\n        ForEach.accessorWithSemantic(gltf, 'POSITION', function(accessorId) {\n            var accessor = gltf.accessors[accessorId];\n            if (!defined(accessor.min) || !defined(accessor.max)) {\n                var minMax = findAccessorMinMax(gltf, accessor);\n                accessor.min = minMax.min;\n                accessor.max = minMax.max;\n            }\n        });\n    }\n\n    function isNodeEmpty(node) {\n        return (!defined(node.children) || node.children.length === 0) &&\n            (!defined(node.meshes) || node.meshes.length === 0) &&\n            !defined(node.camera) && !defined(node.skin) && !defined(node.skeletons) && !defined(node.jointName) &&\n            (!defined(node.translation) || Cartesian3.fromArray(node.translation).equals(Cartesian3.ZERO)) &&\n            (!defined(node.scale) || Cartesian3.fromArray(node.scale).equals(new Cartesian3(1.0, 1.0, 1.0))) &&\n            (!defined(node.rotation) || Cartesian4.fromArray(node.rotation).equals(new Cartesian4(0.0, 0.0, 0.0, 1.0))) &&\n            (!defined(node.matrix) || Matrix4.fromColumnMajorArray(node.matrix).equals(Matrix4.IDENTITY)) &&\n            !defined(node.extensions) && !defined(node.extras);\n    }\n\n    function deleteNode(gltf, nodeId) {\n        // Remove from list of nodes in scene\n        ForEach.scene(gltf, function(scene) {\n            var sceneNodes = scene.nodes;\n            if (defined(sceneNodes)) {\n                var sceneNodesLength = sceneNodes.length;\n                for (var i = sceneNodesLength; i >= 0; --i) {\n                    if (sceneNodes[i] === nodeId) {\n                        sceneNodes.splice(i, 1);\n                        return;\n                    }\n                }\n            }\n        });\n\n        // Remove parent node's reference to this node, and delete the parent if also empty\n        ForEach.node(gltf, function(parentNode, parentNodeId) {\n            if (defined(parentNode.children)) {\n                var index = parentNode.children.indexOf(nodeId);\n                if (index > -1) {\n                    parentNode.children.splice(index, 1);\n\n                    if (isNodeEmpty(parentNode)) {\n                        deleteNode(gltf, parentNodeId);\n                    }\n                }\n            }\n        });\n\n        delete gltf.nodes[nodeId];\n    }\n\n    function removeEmptyNodes(gltf) {\n        ForEach.node(gltf, function(node, nodeId) {\n            if (isNodeEmpty(node)) {\n                deleteNode(gltf, nodeId);\n            }\n        });\n\n        return gltf;\n    }\n\n    function requireAnimationAccessorMinMax(gltf) {\n        ForEach.animation(gltf, function(animation) {\n            ForEach.animationSampler(animation, function(sampler) {\n                var accessor = gltf.accessors[sampler.input];\n                if (!defined(accessor.min) || !defined(accessor.max)) {\n                    var minMax = findAccessorMinMax(gltf, accessor);\n                    accessor.min = minMax.min;\n                    accessor.max = minMax.max;\n                }\n            });\n        });\n    }\n\n    function glTF10to20(gltf) {\n        gltf.asset = defaultValue(gltf.asset, {});\n        gltf.asset.version = '2.0';\n        // material.instanceTechnique properties should be directly on the material. instanceTechnique is a gltf 0.8 property but is seen in some 1.0 models.\n        updateInstanceTechniques(gltf);\n        // animation.samplers now refers directly to accessors and animation.parameters should be removed\n        removeAnimationSamplersIndirection(gltf);\n        // Remove empty nodes and re-assign referencing indices\n        removeEmptyNodes(gltf);\n        // Top-level objects are now arrays referenced by index instead of id\n        objectsToArrays(gltf);\n        // Animation.sampler objects cannot have names\n        removeAnimationSamplerNames(gltf);\n        // asset.profile no longer exists\n        stripAsset(gltf);\n        // Move known extensions from extensionsUsed to extensionsRequired\n        requireKnownExtensions(gltf);\n        // bufferView.byteLength and buffer.byteLength are required\n        requireByteLength(gltf);\n        // byteStride moved from accessor to bufferView\n        moveByteStrideToBufferView(gltf);\n        // accessor.min and accessor.max must be defined for accessors containing POSITION attributes\n        requirePositionAccessorMinMax(gltf);\n        // An animation sampler's input accessor must have min and max properties defined\n        requireAnimationAccessorMinMax(gltf);\n        // buffer.type is unnecessary and should be removed\n        removeBufferType(gltf);\n        // Remove format, internalFormat, target, and type\n        removeTextureProperties(gltf);\n        // TEXCOORD and COLOR attributes must be written with a set index (TEXCOORD_#)\n        requireAttributeSetIndex(gltf);\n        // Add underscores to application-specific parameters\n        underscoreApplicationSpecificSemantics(gltf);\n        // Accessors referenced by JOINTS_0 and WEIGHTS_0 attributes must have correct component types\n        updateAccessorComponentTypes(gltf);\n        // Clamp camera parameters\n        clampCameraParameters(gltf);\n        // Move legacy technique render states to material properties and add KHR_blend extension blending functions\n        moveTechniqueRenderStates(gltf);\n        // Add material techniques to KHR_techniques_webgl extension, removing shaders, programs, and techniques\n        moveTechniquesToExtension(gltf);\n        // Remove empty arrays\n        removeEmptyArrays(gltf);\n    }\n\n    export default updateVersion;\n"]},"metadata":{},"sourceType":"module"}