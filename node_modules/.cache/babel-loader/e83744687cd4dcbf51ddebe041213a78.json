{"ast":null,"code":"import MersenneTwister from \"../ThirdParty/mersenne-twister.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n/**\n * Math functions.\n *\n * @exports CesiumMath\n * @alias Math\n */\n\nvar CesiumMath = {};\n/**\n * 0.1\n * @type {Number}\n * @constant\n */\n\nCesiumMath.EPSILON1 = 0.1;\n/**\n * 0.01\n * @type {Number}\n * @constant\n */\n\nCesiumMath.EPSILON2 = 0.01;\n/**\n * 0.001\n * @type {Number}\n * @constant\n */\n\nCesiumMath.EPSILON3 = 0.001;\n/**\n * 0.0001\n * @type {Number}\n * @constant\n */\n\nCesiumMath.EPSILON4 = 0.0001;\n/**\n * 0.00001\n * @type {Number}\n * @constant\n */\n\nCesiumMath.EPSILON5 = 0.00001;\n/**\n * 0.000001\n * @type {Number}\n * @constant\n */\n\nCesiumMath.EPSILON6 = 0.000001;\n/**\n * 0.0000001\n * @type {Number}\n * @constant\n */\n\nCesiumMath.EPSILON7 = 0.0000001;\n/**\n * 0.00000001\n * @type {Number}\n * @constant\n */\n\nCesiumMath.EPSILON8 = 0.00000001;\n/**\n * 0.000000001\n * @type {Number}\n * @constant\n */\n\nCesiumMath.EPSILON9 = 0.000000001;\n/**\n * 0.0000000001\n * @type {Number}\n * @constant\n */\n\nCesiumMath.EPSILON10 = 0.0000000001;\n/**\n * 0.00000000001\n * @type {Number}\n * @constant\n */\n\nCesiumMath.EPSILON11 = 0.00000000001;\n/**\n * 0.000000000001\n * @type {Number}\n * @constant\n */\n\nCesiumMath.EPSILON12 = 0.000000000001;\n/**\n * 0.0000000000001\n * @type {Number}\n * @constant\n */\n\nCesiumMath.EPSILON13 = 0.0000000000001;\n/**\n * 0.00000000000001\n * @type {Number}\n * @constant\n */\n\nCesiumMath.EPSILON14 = 0.00000000000001;\n/**\n * 0.000000000000001\n * @type {Number}\n * @constant\n */\n\nCesiumMath.EPSILON15 = 0.000000000000001;\n/**\n * 0.0000000000000001\n * @type {Number}\n * @constant\n */\n\nCesiumMath.EPSILON16 = 0.0000000000000001;\n/**\n * 0.00000000000000001\n * @type {Number}\n * @constant\n */\n\nCesiumMath.EPSILON17 = 0.00000000000000001;\n/**\n * 0.000000000000000001\n * @type {Number}\n * @constant\n */\n\nCesiumMath.EPSILON18 = 0.000000000000000001;\n/**\n * 0.0000000000000000001\n * @type {Number}\n * @constant\n */\n\nCesiumMath.EPSILON19 = 0.0000000000000000001;\n/**\n * 0.00000000000000000001\n * @type {Number}\n * @constant\n */\n\nCesiumMath.EPSILON20 = 0.00000000000000000001;\n/**\n * 0.000000000000000000001\n * @type {Number}\n * @constant\n */\n\nCesiumMath.EPSILON21 = 0.000000000000000000001;\n/**\n * The gravitational parameter of the Earth in meters cubed\n * per second squared as defined by the WGS84 model: 3.986004418e14\n * @type {Number}\n * @constant\n */\n\nCesiumMath.GRAVITATIONALPARAMETER = 3.986004418e14;\n/**\n * Radius of the sun in meters: 6.955e8\n * @type {Number}\n * @constant\n */\n\nCesiumMath.SOLAR_RADIUS = 6.955e8;\n/**\n * The mean radius of the moon, according to the \"Report of the IAU/IAG Working Group on\n * Cartographic Coordinates and Rotational Elements of the Planets and satellites: 2000\",\n * Celestial Mechanics 82: 83-110, 2002.\n * @type {Number}\n * @constant\n */\n\nCesiumMath.LUNAR_RADIUS = 1737400.0;\n/**\n * 64 * 1024\n * @type {Number}\n * @constant\n */\n\nCesiumMath.SIXTY_FOUR_KILOBYTES = 64 * 1024;\n/**\n * 4 * 1024 * 1024 * 1024\n * @type {Number}\n * @constant\n */\n\nCesiumMath.FOUR_GIGABYTES = 4 * 1024 * 1024 * 1024;\n/**\n * Returns the sign of the value; 1 if the value is positive, -1 if the value is\n * negative, or 0 if the value is 0.\n *\n * @function\n * @param {Number} value The value to return the sign of.\n * @returns {Number} The sign of value.\n */\n\nCesiumMath.sign = defaultValue(Math.sign, function sign(value) {\n  value = +value; // coerce to number\n\n  if (value === 0 || value !== value) {\n    // zero or NaN\n    return value;\n  }\n\n  return value > 0 ? 1 : -1;\n});\n/**\n * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.\n * This is similar to {@link CesiumMath#sign} except that returns 1.0 instead of\n * 0.0 when the input value is 0.0.\n * @param {Number} value The value to return the sign of.\n * @returns {Number} The sign of value.\n */\n\nCesiumMath.signNotZero = function (value) {\n  return value < 0.0 ? -1.0 : 1.0;\n};\n/**\n * Converts a scalar value in the range [-1.0, 1.0] to a SNORM in the range [0, rangeMaximum]\n * @param {Number} value The scalar value in the range [-1.0, 1.0]\n * @param {Number} [rangeMaximum=255] The maximum value in the mapped range, 255 by default.\n * @returns {Number} A SNORM value, where 0 maps to -1.0 and rangeMaximum maps to 1.0.\n *\n * @see CesiumMath.fromSNorm\n */\n\n\nCesiumMath.toSNorm = function (value, rangeMaximum) {\n  rangeMaximum = defaultValue(rangeMaximum, 255);\n  return Math.round((CesiumMath.clamp(value, -1.0, 1.0) * 0.5 + 0.5) * rangeMaximum);\n};\n/**\n * Converts a SNORM value in the range [0, rangeMaximum] to a scalar in the range [-1.0, 1.0].\n * @param {Number} value SNORM value in the range [0, rangeMaximum]\n * @param {Number} [rangeMaximum=255] The maximum value in the SNORM range, 255 by default.\n * @returns {Number} Scalar in the range [-1.0, 1.0].\n *\n * @see CesiumMath.toSNorm\n */\n\n\nCesiumMath.fromSNorm = function (value, rangeMaximum) {\n  rangeMaximum = defaultValue(rangeMaximum, 255);\n  return CesiumMath.clamp(value, 0.0, rangeMaximum) / rangeMaximum * 2.0 - 1.0;\n};\n/**\n * Converts a scalar value in the range [rangeMinimum, rangeMaximum] to a scalar in the range [0.0, 1.0]\n * @param {Number} value The scalar value in the range [rangeMinimum, rangeMaximum]\n * @param {Number} rangeMinimum The minimum value in the mapped range.\n * @param {Number} rangeMaximum The maximum value in the mapped range.\n * @returns {Number} A scalar value, where rangeMinimum maps to 0.0 and rangeMaximum maps to 1.0.\n */\n\n\nCesiumMath.normalize = function (value, rangeMinimum, rangeMaximum) {\n  rangeMaximum = Math.max(rangeMaximum - rangeMinimum, 0.0);\n  return rangeMaximum === 0.0 ? 0.0 : CesiumMath.clamp((value - rangeMinimum) / rangeMaximum, 0.0, 1.0);\n};\n/**\n * Returns the hyperbolic sine of a number.\n * The hyperbolic sine of <em>value</em> is defined to be\n * (<em>e<sup>x</sup>&nbsp;-&nbsp;e<sup>-x</sup></em>)/2.0\n * where <i>e</i> is Euler's number, approximately 2.71828183.\n *\n * <p>Special cases:\n *   <ul>\n *     <li>If the argument is NaN, then the result is NaN.</li>\n *\n *     <li>If the argument is infinite, then the result is an infinity\n *     with the same sign as the argument.</li>\n *\n *     <li>If the argument is zero, then the result is a zero with the\n *     same sign as the argument.</li>\n *   </ul>\n *</p>\n *\n * @function\n * @param {Number} value The number whose hyperbolic sine is to be returned.\n * @returns {Number} The hyperbolic sine of <code>value</code>.\n */\n\n\nCesiumMath.sinh = defaultValue(Math.sinh, function sinh(value) {\n  return (Math.exp(value) - Math.exp(-value)) / 2.0;\n});\n/**\n * Returns the hyperbolic cosine of a number.\n * The hyperbolic cosine of <strong>value</strong> is defined to be\n * (<em>e<sup>x</sup>&nbsp;+&nbsp;e<sup>-x</sup></em>)/2.0\n * where <i>e</i> is Euler's number, approximately 2.71828183.\n *\n * <p>Special cases:\n *   <ul>\n *     <li>If the argument is NaN, then the result is NaN.</li>\n *\n *     <li>If the argument is infinite, then the result is positive infinity.</li>\n *\n *     <li>If the argument is zero, then the result is 1.0.</li>\n *   </ul>\n *</p>\n *\n * @function\n * @param {Number} value The number whose hyperbolic cosine is to be returned.\n * @returns {Number} The hyperbolic cosine of <code>value</code>.\n */\n\nCesiumMath.cosh = defaultValue(Math.cosh, function cosh(value) {\n  return (Math.exp(value) + Math.exp(-value)) / 2.0;\n});\n/**\n * Computes the linear interpolation of two values.\n *\n * @param {Number} p The start value to interpolate.\n * @param {Number} q The end value to interpolate.\n * @param {Number} time The time of interpolation generally in the range <code>[0.0, 1.0]</code>.\n * @returns {Number} The linearly interpolated value.\n *\n * @example\n * var n = Cesium.Math.lerp(0.0, 2.0, 0.5); // returns 1.0\n */\n\nCesiumMath.lerp = function (p, q, time) {\n  return (1.0 - time) * p + time * q;\n};\n/**\n * pi\n *\n * @type {Number}\n * @constant\n */\n\n\nCesiumMath.PI = Math.PI;\n/**\n * 1/pi\n *\n * @type {Number}\n * @constant\n */\n\nCesiumMath.ONE_OVER_PI = 1.0 / Math.PI;\n/**\n * pi/2\n *\n * @type {Number}\n * @constant\n */\n\nCesiumMath.PI_OVER_TWO = Math.PI / 2.0;\n/**\n * pi/3\n *\n * @type {Number}\n * @constant\n */\n\nCesiumMath.PI_OVER_THREE = Math.PI / 3.0;\n/**\n * pi/4\n *\n * @type {Number}\n * @constant\n */\n\nCesiumMath.PI_OVER_FOUR = Math.PI / 4.0;\n/**\n * pi/6\n *\n * @type {Number}\n * @constant\n */\n\nCesiumMath.PI_OVER_SIX = Math.PI / 6.0;\n/**\n * 3pi/2\n *\n * @type {Number}\n * @constant\n */\n\nCesiumMath.THREE_PI_OVER_TWO = 3.0 * Math.PI / 2.0;\n/**\n * 2pi\n *\n * @type {Number}\n * @constant\n */\n\nCesiumMath.TWO_PI = 2.0 * Math.PI;\n/**\n * 1/2pi\n *\n * @type {Number}\n * @constant\n */\n\nCesiumMath.ONE_OVER_TWO_PI = 1.0 / (2.0 * Math.PI);\n/**\n * The number of radians in a degree.\n *\n * @type {Number}\n * @constant\n * @default Math.PI / 180.0\n */\n\nCesiumMath.RADIANS_PER_DEGREE = Math.PI / 180.0;\n/**\n * The number of degrees in a radian.\n *\n * @type {Number}\n * @constant\n * @default 180.0 / Math.PI\n */\n\nCesiumMath.DEGREES_PER_RADIAN = 180.0 / Math.PI;\n/**\n * The number of radians in an arc second.\n *\n * @type {Number}\n * @constant\n * @default {@link CesiumMath.RADIANS_PER_DEGREE} / 3600.0\n */\n\nCesiumMath.RADIANS_PER_ARCSECOND = CesiumMath.RADIANS_PER_DEGREE / 3600.0;\n/**\n * Converts degrees to radians.\n * @param {Number} degrees The angle to convert in degrees.\n * @returns {Number} The corresponding angle in radians.\n */\n\nCesiumMath.toRadians = function (degrees) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(degrees)) {\n    throw new DeveloperError(\"degrees is required.\");\n  } //>>includeEnd('debug');\n\n\n  return degrees * CesiumMath.RADIANS_PER_DEGREE;\n};\n/**\n * Converts radians to degrees.\n * @param {Number} radians The angle to convert in radians.\n * @returns {Number} The corresponding angle in degrees.\n */\n\n\nCesiumMath.toDegrees = function (radians) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(radians)) {\n    throw new DeveloperError(\"radians is required.\");\n  } //>>includeEnd('debug');\n\n\n  return radians * CesiumMath.DEGREES_PER_RADIAN;\n};\n/**\n * Converts a longitude value, in radians, to the range [<code>-Math.PI</code>, <code>Math.PI</code>).\n *\n * @param {Number} angle The longitude value, in radians, to convert to the range [<code>-Math.PI</code>, <code>Math.PI</code>).\n * @returns {Number} The equivalent longitude value in the range [<code>-Math.PI</code>, <code>Math.PI</code>).\n *\n * @example\n * // Convert 270 degrees to -90 degrees longitude\n * var longitude = Cesium.Math.convertLongitudeRange(Cesium.Math.toRadians(270.0));\n */\n\n\nCesiumMath.convertLongitudeRange = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  } //>>includeEnd('debug');\n\n\n  var twoPi = CesiumMath.TWO_PI;\n  var simplified = angle - Math.floor(angle / twoPi) * twoPi;\n\n  if (simplified < -Math.PI) {\n    return simplified + twoPi;\n  }\n\n  if (simplified >= Math.PI) {\n    return simplified - twoPi;\n  }\n\n  return simplified;\n};\n/**\n * Convenience function that clamps a latitude value, in radians, to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).\n * Useful for sanitizing data before use in objects requiring correct range.\n *\n * @param {Number} angle The latitude value, in radians, to clamp to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).\n * @returns {Number} The latitude value clamped to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).\n *\n * @example\n * // Clamp 108 degrees latitude to 90 degrees latitude\n * var latitude = Cesium.Math.clampToLatitudeRange(Cesium.Math.toRadians(108.0));\n */\n\n\nCesiumMath.clampToLatitudeRange = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  } //>>includeEnd('debug');\n\n\n  return CesiumMath.clamp(angle, -1 * CesiumMath.PI_OVER_TWO, CesiumMath.PI_OVER_TWO);\n};\n/**\n * Produces an angle in the range -Pi <= angle <= Pi which is equivalent to the provided angle.\n *\n * @param {Number} angle in radians\n * @returns {Number} The angle in the range [<code>-CesiumMath.PI</code>, <code>CesiumMath.PI</code>].\n */\n\n\nCesiumMath.negativePiToPi = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  } //>>includeEnd('debug');\n\n\n  return CesiumMath.zeroToTwoPi(angle + CesiumMath.PI) - CesiumMath.PI;\n};\n/**\n * Produces an angle in the range 0 <= angle <= 2Pi which is equivalent to the provided angle.\n *\n * @param {Number} angle in radians\n * @returns {Number} The angle in the range [0, <code>CesiumMath.TWO_PI</code>].\n */\n\n\nCesiumMath.zeroToTwoPi = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  } //>>includeEnd('debug');\n\n\n  var mod = CesiumMath.mod(angle, CesiumMath.TWO_PI);\n\n  if (Math.abs(mod) < CesiumMath.EPSILON14 && Math.abs(angle) > CesiumMath.EPSILON14) {\n    return CesiumMath.TWO_PI;\n  }\n\n  return mod;\n};\n/**\n * The modulo operation that also works for negative dividends.\n *\n * @param {Number} m The dividend.\n * @param {Number} n The divisor.\n * @returns {Number} The remainder.\n */\n\n\nCesiumMath.mod = function (m, n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(m)) {\n    throw new DeveloperError(\"m is required.\");\n  }\n\n  if (!defined(n)) {\n    throw new DeveloperError(\"n is required.\");\n  } //>>includeEnd('debug');\n\n\n  return (m % n + n) % n;\n};\n/**\n * Determines if two values are equal using an absolute or relative tolerance test. This is useful\n * to avoid problems due to roundoff error when comparing floating-point values directly. The values are\n * first compared using an absolute tolerance test. If that fails, a relative tolerance test is performed.\n * Use this test if you are unsure of the magnitudes of left and right.\n *\n * @param {Number} left The first value to compare.\n * @param {Number} right The other value to compare.\n * @param {Number} relativeEpsilon The maximum inclusive delta between <code>left</code> and <code>right</code> for the relative tolerance test.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The maximum inclusive delta between <code>left</code> and <code>right</code> for the absolute tolerance test.\n * @returns {Boolean} <code>true</code> if the values are equal within the epsilon; otherwise, <code>false</code>.\n *\n * @example\n * var a = Cesium.Math.equalsEpsilon(0.0, 0.01, Cesium.Math.EPSILON2); // true\n * var b = Cesium.Math.equalsEpsilon(0.0, 0.1, Cesium.Math.EPSILON2);  // false\n * var c = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON7); // true\n * var d = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON9); // false\n */\n\n\nCesiumMath.equalsEpsilon = function (left, right, relativeEpsilon, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"left is required.\");\n  }\n\n  if (!defined(right)) {\n    throw new DeveloperError(\"right is required.\");\n  }\n\n  if (!defined(relativeEpsilon)) {\n    throw new DeveloperError(\"relativeEpsilon is required.\");\n  } //>>includeEnd('debug');\n\n\n  absoluteEpsilon = defaultValue(absoluteEpsilon, relativeEpsilon);\n  var absDiff = Math.abs(left - right);\n  return absDiff <= absoluteEpsilon || absDiff <= relativeEpsilon * Math.max(Math.abs(left), Math.abs(right));\n};\n/**\n * Determines if the left value is less than the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns false.\n *\n * @param {Number} left The first number to compare.\n * @param {Number} right The second number to compare.\n * @param {Number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {Boolean} <code>true</code> if <code>left</code> is less than <code>right</code> by more than\n *          <code>absoluteEpsilon<code>. <code>false</code> if <code>left</code> is greater or if the two\n *          values are nearly equal.\n */\n\n\nCesiumMath.lessThan = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"first is required.\");\n  }\n\n  if (!defined(right)) {\n    throw new DeveloperError(\"second is required.\");\n  }\n\n  if (!defined(absoluteEpsilon)) {\n    throw new DeveloperError(\"relativeEpsilon is required.\");\n  } //>>includeEnd('debug');\n\n\n  return left - right < -absoluteEpsilon;\n};\n/**\n * Determines if the left value is less than or equal to the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns true.\n *\n * @param {Number} left The first number to compare.\n * @param {Number} right The second number to compare.\n * @param {Number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {Boolean} <code>true</code> if <code>left</code> is less than <code>right</code> or if the\n *          the values are nearly equal.\n */\n\n\nCesiumMath.lessThanOrEquals = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"first is required.\");\n  }\n\n  if (!defined(right)) {\n    throw new DeveloperError(\"second is required.\");\n  }\n\n  if (!defined(absoluteEpsilon)) {\n    throw new DeveloperError(\"relativeEpsilon is required.\");\n  } //>>includeEnd('debug');\n\n\n  return left - right < absoluteEpsilon;\n};\n/**\n * Determines if the left value is greater the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns false.\n *\n * @param {Number} left The first number to compare.\n * @param {Number} right The second number to compare.\n * @param {Number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {Boolean} <code>true</code> if <code>left</code> is greater than <code>right</code> by more than\n *          <code>absoluteEpsilon<code>. <code>false</code> if <code>left</code> is less or if the two\n *          values are nearly equal.\n */\n\n\nCesiumMath.greaterThan = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"first is required.\");\n  }\n\n  if (!defined(right)) {\n    throw new DeveloperError(\"second is required.\");\n  }\n\n  if (!defined(absoluteEpsilon)) {\n    throw new DeveloperError(\"relativeEpsilon is required.\");\n  } //>>includeEnd('debug');\n\n\n  return left - right > absoluteEpsilon;\n};\n/**\n * Determines if the left value is greater than or equal to the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns true.\n *\n * @param {Number} left The first number to compare.\n * @param {Number} right The second number to compare.\n * @param {Number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {Boolean} <code>true</code> if <code>left</code> is greater than <code>right</code> or if the\n *          the values are nearly equal.\n */\n\n\nCesiumMath.greaterThanOrEquals = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"first is required.\");\n  }\n\n  if (!defined(right)) {\n    throw new DeveloperError(\"second is required.\");\n  }\n\n  if (!defined(absoluteEpsilon)) {\n    throw new DeveloperError(\"relativeEpsilon is required.\");\n  } //>>includeEnd('debug');\n\n\n  return left - right > -absoluteEpsilon;\n};\n\nvar factorials = [1];\n/**\n * Computes the factorial of the provided number.\n *\n * @param {Number} n The number whose factorial is to be computed.\n * @returns {Number} The factorial of the provided number or undefined if the number is less than 0.\n *\n * @exception {DeveloperError} A number greater than or equal to 0 is required.\n *\n *\n * @example\n * //Compute 7!, which is equal to 5040\n * var computedFactorial = Cesium.Math.factorial(7);\n *\n * @see {@link http://en.wikipedia.org/wiki/Factorial|Factorial on Wikipedia}\n */\n\nCesiumMath.factorial = function (n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof n !== \"number\" || n < 0) {\n    throw new DeveloperError(\"A number greater than or equal to 0 is required.\");\n  } //>>includeEnd('debug');\n\n\n  var length = factorials.length;\n\n  if (n >= length) {\n    var sum = factorials[length - 1];\n\n    for (var i = length; i <= n; i++) {\n      var next = sum * i;\n      factorials.push(next);\n      sum = next;\n    }\n  }\n\n  return factorials[n];\n};\n/**\n * Increments a number with a wrapping to a minimum value if the number exceeds the maximum value.\n *\n * @param {Number} [n] The number to be incremented.\n * @param {Number} [maximumValue] The maximum incremented value before rolling over to the minimum value.\n * @param {Number} [minimumValue=0.0] The number reset to after the maximum value has been exceeded.\n * @returns {Number} The incremented number.\n *\n * @exception {DeveloperError} Maximum value must be greater than minimum value.\n *\n * @example\n * var n = Cesium.Math.incrementWrap(5, 10, 0); // returns 6\n * var n = Cesium.Math.incrementWrap(10, 10, 0); // returns 0\n */\n\n\nCesiumMath.incrementWrap = function (n, maximumValue, minimumValue) {\n  minimumValue = defaultValue(minimumValue, 0.0); //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(n)) {\n    throw new DeveloperError(\"n is required.\");\n  }\n\n  if (maximumValue <= minimumValue) {\n    throw new DeveloperError(\"maximumValue must be greater than minimumValue.\");\n  } //>>includeEnd('debug');\n\n\n  ++n;\n\n  if (n > maximumValue) {\n    n = minimumValue;\n  }\n\n  return n;\n};\n/**\n * Determines if a positive integer is a power of two.\n *\n * @param {Number} n The positive integer to test.\n * @returns {Boolean} <code>true</code> if the number if a power of two; otherwise, <code>false</code>.\n *\n * @exception {DeveloperError} A number greater than or equal to 0 is required.\n *\n * @example\n * var t = Cesium.Math.isPowerOfTwo(16); // true\n * var f = Cesium.Math.isPowerOfTwo(20); // false\n */\n\n\nCesiumMath.isPowerOfTwo = function (n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof n !== \"number\" || n < 0) {\n    throw new DeveloperError(\"A number greater than or equal to 0 is required.\");\n  } //>>includeEnd('debug');\n\n\n  return n !== 0 && (n & n - 1) === 0;\n};\n/**\n * Computes the next power-of-two integer greater than or equal to the provided positive integer.\n *\n * @param {Number} n The positive integer to test.\n * @returns {Number} The next power-of-two integer.\n *\n * @exception {DeveloperError} A number greater than or equal to 0 is required.\n *\n * @example\n * var n = Cesium.Math.nextPowerOfTwo(29); // 32\n * var m = Cesium.Math.nextPowerOfTwo(32); // 32\n */\n\n\nCesiumMath.nextPowerOfTwo = function (n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof n !== \"number\" || n < 0) {\n    throw new DeveloperError(\"A number greater than or equal to 0 is required.\");\n  } //>>includeEnd('debug');\n  // From http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2\n\n\n  --n;\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  ++n;\n  return n;\n};\n/**\n * Constraint a value to lie between two values.\n *\n * @param {Number} value The value to constrain.\n * @param {Number} min The minimum value.\n * @param {Number} max The maximum value.\n * @returns {Number} The value clamped so that min <= value <= max.\n */\n\n\nCesiumMath.clamp = function (value, min, max) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n\n  if (!defined(min)) {\n    throw new DeveloperError(\"min is required.\");\n  }\n\n  if (!defined(max)) {\n    throw new DeveloperError(\"max is required.\");\n  } //>>includeEnd('debug');\n\n\n  return value < min ? min : value > max ? max : value;\n};\n\nvar randomNumberGenerator = new MersenneTwister();\n/**\n * Sets the seed used by the random number generator\n * in {@link CesiumMath#nextRandomNumber}.\n *\n * @param {Number} seed An integer used as the seed.\n */\n\nCesiumMath.setRandomNumberSeed = function (seed) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(seed)) {\n    throw new DeveloperError(\"seed is required.\");\n  } //>>includeEnd('debug');\n\n\n  randomNumberGenerator = new MersenneTwister(seed);\n};\n/**\n * Generates a random floating point number in the range of [0.0, 1.0)\n * using a Mersenne twister.\n *\n * @returns {Number} A random number in the range of [0.0, 1.0).\n *\n * @see CesiumMath.setRandomNumberSeed\n * @see {@link http://en.wikipedia.org/wiki/Mersenne_twister|Mersenne twister on Wikipedia}\n */\n\n\nCesiumMath.nextRandomNumber = function () {\n  return randomNumberGenerator.random();\n};\n/**\n * Generates a random number between two numbers.\n *\n * @param {Number} min The minimum value.\n * @param {Number} max The maximum value.\n * @returns {Number} A random number between the min and max.\n */\n\n\nCesiumMath.randomBetween = function (min, max) {\n  return CesiumMath.nextRandomNumber() * (max - min) + min;\n};\n/**\n * Computes <code>Math.acos(value)</code>, but first clamps <code>value</code> to the range [-1.0, 1.0]\n * so that the function will never return NaN.\n *\n * @param {Number} value The value for which to compute acos.\n * @returns {Number} The acos of the value if the value is in the range [-1.0, 1.0], or the acos of -1.0 or 1.0,\n *          whichever is closer, if the value is outside the range.\n */\n\n\nCesiumMath.acosClamped = function (value) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required.\");\n  } //>>includeEnd('debug');\n\n\n  return Math.acos(CesiumMath.clamp(value, -1.0, 1.0));\n};\n/**\n * Computes <code>Math.asin(value)</code>, but first clamps <code>value</code> to the range [-1.0, 1.0]\n * so that the function will never return NaN.\n *\n * @param {Number} value The value for which to compute asin.\n * @returns {Number} The asin of the value if the value is in the range [-1.0, 1.0], or the asin of -1.0 or 1.0,\n *          whichever is closer, if the value is outside the range.\n */\n\n\nCesiumMath.asinClamped = function (value) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required.\");\n  } //>>includeEnd('debug');\n\n\n  return Math.asin(CesiumMath.clamp(value, -1.0, 1.0));\n};\n/**\n * Finds the chord length between two points given the circle's radius and the angle between the points.\n *\n * @param {Number} angle The angle between the two points.\n * @param {Number} radius The radius of the circle.\n * @returns {Number} The chord length.\n */\n\n\nCesiumMath.chordLength = function (angle, radius) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  }\n\n  if (!defined(radius)) {\n    throw new DeveloperError(\"radius is required.\");\n  } //>>includeEnd('debug');\n\n\n  return 2.0 * radius * Math.sin(angle * 0.5);\n};\n/**\n * Finds the logarithm of a number to a base.\n *\n * @param {Number} number The number.\n * @param {Number} base The base.\n * @returns {Number} The result.\n */\n\n\nCesiumMath.logBase = function (number, base) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(number)) {\n    throw new DeveloperError(\"number is required.\");\n  }\n\n  if (!defined(base)) {\n    throw new DeveloperError(\"base is required.\");\n  } //>>includeEnd('debug');\n\n\n  return Math.log(number) / Math.log(base);\n};\n/**\n * Finds the cube root of a number.\n * Returns NaN if <code>number</code> is not provided.\n *\n * @function\n * @param {Number} [number] The number.\n * @returns {Number} The result.\n */\n\n\nCesiumMath.cbrt = defaultValue(Math.cbrt, function cbrt(number) {\n  var result = Math.pow(Math.abs(number), 1.0 / 3.0);\n  return number < 0.0 ? -result : result;\n});\n/**\n * Finds the base 2 logarithm of a number.\n *\n * @function\n * @param {Number} number The number.\n * @returns {Number} The result.\n */\n\nCesiumMath.log2 = defaultValue(Math.log2, function log2(number) {\n  return Math.log(number) * Math.LOG2E;\n});\n/**\n * @private\n */\n\nCesiumMath.fog = function (distanceToCamera, density) {\n  var scalar = distanceToCamera * density;\n  return 1.0 - Math.exp(-(scalar * scalar));\n};\n/**\n * Computes a fast approximation of Atan for input in the range [-1, 1].\n *\n * Based on Michal Drobot's approximation from ShaderFastLibs,\n * which in turn is based on \"Efficient approximations for the arctangent function,\"\n * Rajan, S. Sichun Wang Inkol, R. Joyal, A., May 2006.\n * Adapted from ShaderFastLibs under MIT License.\n *\n * @param {Number} x An input number in the range [-1, 1]\n * @returns {Number} An approximation of atan(x)\n */\n\n\nCesiumMath.fastApproximateAtan = function (x) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"x\", x); //>>includeEnd('debug');\n\n  return x * (-0.1784 * Math.abs(x) - 0.0663 * x * x + 1.0301);\n};\n/**\n * Computes a fast approximation of Atan2(x, y) for arbitrary input scalars.\n *\n * Range reduction math based on nvidia's cg reference implementation: http://developer.download.nvidia.com/cg/atan2.html\n *\n * @param {Number} x An input number that isn't zero if y is zero.\n * @param {Number} y An input number that isn't zero if x is zero.\n * @returns {Number} An approximation of atan2(x, y)\n */\n\n\nCesiumMath.fastApproximateAtan2 = function (x, y) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"x\", x);\n  Check.typeOf.number(\"y\", y); //>>includeEnd('debug');\n  // atan approximations are usually only reliable over [-1, 1]\n  // So reduce the range by flipping whether x or y is on top based on which is bigger.\n\n  var opposite;\n  var adjacent;\n  var t = Math.abs(x); // t used as swap and atan result.\n\n  opposite = Math.abs(y);\n  adjacent = Math.max(t, opposite);\n  opposite = Math.min(t, opposite);\n  var oppositeOverAdjacent = opposite / adjacent; //>>includeStart('debug', pragmas.debug);\n\n  if (isNaN(oppositeOverAdjacent)) {\n    throw new DeveloperError(\"either x or y must be nonzero\");\n  } //>>includeEnd('debug');\n\n\n  t = CesiumMath.fastApproximateAtan(oppositeOverAdjacent); // Undo range reduction\n\n  t = Math.abs(y) > Math.abs(x) ? CesiumMath.PI_OVER_TWO - t : t;\n  t = x < 0.0 ? CesiumMath.PI - t : t;\n  t = y < 0.0 ? -t : t;\n  return t;\n};\n\nexport default CesiumMath;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/Math.js"],"names":["MersenneTwister","Check","defaultValue","defined","DeveloperError","CesiumMath","EPSILON1","EPSILON2","EPSILON3","EPSILON4","EPSILON5","EPSILON6","EPSILON7","EPSILON8","EPSILON9","EPSILON10","EPSILON11","EPSILON12","EPSILON13","EPSILON14","EPSILON15","EPSILON16","EPSILON17","EPSILON18","EPSILON19","EPSILON20","EPSILON21","GRAVITATIONALPARAMETER","SOLAR_RADIUS","LUNAR_RADIUS","SIXTY_FOUR_KILOBYTES","FOUR_GIGABYTES","sign","Math","value","signNotZero","toSNorm","rangeMaximum","round","clamp","fromSNorm","normalize","rangeMinimum","max","sinh","exp","cosh","lerp","p","q","time","PI","ONE_OVER_PI","PI_OVER_TWO","PI_OVER_THREE","PI_OVER_FOUR","PI_OVER_SIX","THREE_PI_OVER_TWO","TWO_PI","ONE_OVER_TWO_PI","RADIANS_PER_DEGREE","DEGREES_PER_RADIAN","RADIANS_PER_ARCSECOND","toRadians","degrees","toDegrees","radians","convertLongitudeRange","angle","twoPi","simplified","floor","clampToLatitudeRange","negativePiToPi","zeroToTwoPi","mod","abs","m","n","equalsEpsilon","left","right","relativeEpsilon","absoluteEpsilon","absDiff","lessThan","lessThanOrEquals","greaterThan","greaterThanOrEquals","factorials","factorial","length","sum","i","next","push","incrementWrap","maximumValue","minimumValue","isPowerOfTwo","nextPowerOfTwo","min","randomNumberGenerator","setRandomNumberSeed","seed","nextRandomNumber","random","randomBetween","acosClamped","acos","asinClamped","asin","chordLength","radius","sin","logBase","number","base","log","cbrt","result","pow","log2","LOG2E","fog","distanceToCamera","density","scalar","fastApproximateAtan","x","typeOf","fastApproximateAtan2","y","opposite","adjacent","t","oppositeOverAdjacent","isNaN"],"mappings":"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","sourcesContent":["import MersenneTwister from \"../ThirdParty/mersenne-twister.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Math functions.\n *\n * @exports CesiumMath\n * @alias Math\n */\nvar CesiumMath = {};\n\n/**\n * 0.1\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON1 = 0.1;\n\n/**\n * 0.01\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON2 = 0.01;\n\n/**\n * 0.001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON3 = 0.001;\n\n/**\n * 0.0001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON4 = 0.0001;\n\n/**\n * 0.00001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON5 = 0.00001;\n\n/**\n * 0.000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON6 = 0.000001;\n\n/**\n * 0.0000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON7 = 0.0000001;\n\n/**\n * 0.00000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON8 = 0.00000001;\n\n/**\n * 0.000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON9 = 0.000000001;\n\n/**\n * 0.0000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON10 = 0.0000000001;\n\n/**\n * 0.00000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON11 = 0.00000000001;\n\n/**\n * 0.000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON12 = 0.000000000001;\n\n/**\n * 0.0000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON13 = 0.0000000000001;\n\n/**\n * 0.00000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON14 = 0.00000000000001;\n\n/**\n * 0.000000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON15 = 0.000000000000001;\n\n/**\n * 0.0000000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON16 = 0.0000000000000001;\n\n/**\n * 0.00000000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON17 = 0.00000000000000001;\n\n/**\n * 0.000000000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON18 = 0.000000000000000001;\n\n/**\n * 0.0000000000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON19 = 0.0000000000000000001;\n\n/**\n * 0.00000000000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON20 = 0.00000000000000000001;\n\n/**\n * 0.000000000000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON21 = 0.000000000000000000001;\n\n/**\n * The gravitational parameter of the Earth in meters cubed\n * per second squared as defined by the WGS84 model: 3.986004418e14\n * @type {Number}\n * @constant\n */\nCesiumMath.GRAVITATIONALPARAMETER = 3.986004418e14;\n\n/**\n * Radius of the sun in meters: 6.955e8\n * @type {Number}\n * @constant\n */\nCesiumMath.SOLAR_RADIUS = 6.955e8;\n\n/**\n * The mean radius of the moon, according to the \"Report of the IAU/IAG Working Group on\n * Cartographic Coordinates and Rotational Elements of the Planets and satellites: 2000\",\n * Celestial Mechanics 82: 83-110, 2002.\n * @type {Number}\n * @constant\n */\nCesiumMath.LUNAR_RADIUS = 1737400.0;\n\n/**\n * 64 * 1024\n * @type {Number}\n * @constant\n */\nCesiumMath.SIXTY_FOUR_KILOBYTES = 64 * 1024;\n\n/**\n * 4 * 1024 * 1024 * 1024\n * @type {Number}\n * @constant\n */\nCesiumMath.FOUR_GIGABYTES = 4 * 1024 * 1024 * 1024;\n\n/**\n * Returns the sign of the value; 1 if the value is positive, -1 if the value is\n * negative, or 0 if the value is 0.\n *\n * @function\n * @param {Number} value The value to return the sign of.\n * @returns {Number} The sign of value.\n */\nCesiumMath.sign = defaultValue(Math.sign, function sign(value) {\n  value = +value; // coerce to number\n  if (value === 0 || value !== value) {\n    // zero or NaN\n    return value;\n  }\n  return value > 0 ? 1 : -1;\n});\n\n/**\n * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.\n * This is similar to {@link CesiumMath#sign} except that returns 1.0 instead of\n * 0.0 when the input value is 0.0.\n * @param {Number} value The value to return the sign of.\n * @returns {Number} The sign of value.\n */\nCesiumMath.signNotZero = function (value) {\n  return value < 0.0 ? -1.0 : 1.0;\n};\n\n/**\n * Converts a scalar value in the range [-1.0, 1.0] to a SNORM in the range [0, rangeMaximum]\n * @param {Number} value The scalar value in the range [-1.0, 1.0]\n * @param {Number} [rangeMaximum=255] The maximum value in the mapped range, 255 by default.\n * @returns {Number} A SNORM value, where 0 maps to -1.0 and rangeMaximum maps to 1.0.\n *\n * @see CesiumMath.fromSNorm\n */\nCesiumMath.toSNorm = function (value, rangeMaximum) {\n  rangeMaximum = defaultValue(rangeMaximum, 255);\n  return Math.round(\n    (CesiumMath.clamp(value, -1.0, 1.0) * 0.5 + 0.5) * rangeMaximum\n  );\n};\n\n/**\n * Converts a SNORM value in the range [0, rangeMaximum] to a scalar in the range [-1.0, 1.0].\n * @param {Number} value SNORM value in the range [0, rangeMaximum]\n * @param {Number} [rangeMaximum=255] The maximum value in the SNORM range, 255 by default.\n * @returns {Number} Scalar in the range [-1.0, 1.0].\n *\n * @see CesiumMath.toSNorm\n */\nCesiumMath.fromSNorm = function (value, rangeMaximum) {\n  rangeMaximum = defaultValue(rangeMaximum, 255);\n  return (\n    (CesiumMath.clamp(value, 0.0, rangeMaximum) / rangeMaximum) * 2.0 - 1.0\n  );\n};\n\n/**\n * Converts a scalar value in the range [rangeMinimum, rangeMaximum] to a scalar in the range [0.0, 1.0]\n * @param {Number} value The scalar value in the range [rangeMinimum, rangeMaximum]\n * @param {Number} rangeMinimum The minimum value in the mapped range.\n * @param {Number} rangeMaximum The maximum value in the mapped range.\n * @returns {Number} A scalar value, where rangeMinimum maps to 0.0 and rangeMaximum maps to 1.0.\n */\nCesiumMath.normalize = function (value, rangeMinimum, rangeMaximum) {\n  rangeMaximum = Math.max(rangeMaximum - rangeMinimum, 0.0);\n  return rangeMaximum === 0.0\n    ? 0.0\n    : CesiumMath.clamp((value - rangeMinimum) / rangeMaximum, 0.0, 1.0);\n};\n\n/**\n * Returns the hyperbolic sine of a number.\n * The hyperbolic sine of <em>value</em> is defined to be\n * (<em>e<sup>x</sup>&nbsp;-&nbsp;e<sup>-x</sup></em>)/2.0\n * where <i>e</i> is Euler's number, approximately 2.71828183.\n *\n * <p>Special cases:\n *   <ul>\n *     <li>If the argument is NaN, then the result is NaN.</li>\n *\n *     <li>If the argument is infinite, then the result is an infinity\n *     with the same sign as the argument.</li>\n *\n *     <li>If the argument is zero, then the result is a zero with the\n *     same sign as the argument.</li>\n *   </ul>\n *</p>\n *\n * @function\n * @param {Number} value The number whose hyperbolic sine is to be returned.\n * @returns {Number} The hyperbolic sine of <code>value</code>.\n */\nCesiumMath.sinh = defaultValue(Math.sinh, function sinh(value) {\n  return (Math.exp(value) - Math.exp(-value)) / 2.0;\n});\n\n/**\n * Returns the hyperbolic cosine of a number.\n * The hyperbolic cosine of <strong>value</strong> is defined to be\n * (<em>e<sup>x</sup>&nbsp;+&nbsp;e<sup>-x</sup></em>)/2.0\n * where <i>e</i> is Euler's number, approximately 2.71828183.\n *\n * <p>Special cases:\n *   <ul>\n *     <li>If the argument is NaN, then the result is NaN.</li>\n *\n *     <li>If the argument is infinite, then the result is positive infinity.</li>\n *\n *     <li>If the argument is zero, then the result is 1.0.</li>\n *   </ul>\n *</p>\n *\n * @function\n * @param {Number} value The number whose hyperbolic cosine is to be returned.\n * @returns {Number} The hyperbolic cosine of <code>value</code>.\n */\nCesiumMath.cosh = defaultValue(Math.cosh, function cosh(value) {\n  return (Math.exp(value) + Math.exp(-value)) / 2.0;\n});\n\n/**\n * Computes the linear interpolation of two values.\n *\n * @param {Number} p The start value to interpolate.\n * @param {Number} q The end value to interpolate.\n * @param {Number} time The time of interpolation generally in the range <code>[0.0, 1.0]</code>.\n * @returns {Number} The linearly interpolated value.\n *\n * @example\n * var n = Cesium.Math.lerp(0.0, 2.0, 0.5); // returns 1.0\n */\nCesiumMath.lerp = function (p, q, time) {\n  return (1.0 - time) * p + time * q;\n};\n\n/**\n * pi\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.PI = Math.PI;\n\n/**\n * 1/pi\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.ONE_OVER_PI = 1.0 / Math.PI;\n\n/**\n * pi/2\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.PI_OVER_TWO = Math.PI / 2.0;\n\n/**\n * pi/3\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.PI_OVER_THREE = Math.PI / 3.0;\n\n/**\n * pi/4\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.PI_OVER_FOUR = Math.PI / 4.0;\n\n/**\n * pi/6\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.PI_OVER_SIX = Math.PI / 6.0;\n\n/**\n * 3pi/2\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.THREE_PI_OVER_TWO = (3.0 * Math.PI) / 2.0;\n\n/**\n * 2pi\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.TWO_PI = 2.0 * Math.PI;\n\n/**\n * 1/2pi\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.ONE_OVER_TWO_PI = 1.0 / (2.0 * Math.PI);\n\n/**\n * The number of radians in a degree.\n *\n * @type {Number}\n * @constant\n * @default Math.PI / 180.0\n */\nCesiumMath.RADIANS_PER_DEGREE = Math.PI / 180.0;\n\n/**\n * The number of degrees in a radian.\n *\n * @type {Number}\n * @constant\n * @default 180.0 / Math.PI\n */\nCesiumMath.DEGREES_PER_RADIAN = 180.0 / Math.PI;\n\n/**\n * The number of radians in an arc second.\n *\n * @type {Number}\n * @constant\n * @default {@link CesiumMath.RADIANS_PER_DEGREE} / 3600.0\n */\nCesiumMath.RADIANS_PER_ARCSECOND = CesiumMath.RADIANS_PER_DEGREE / 3600.0;\n\n/**\n * Converts degrees to radians.\n * @param {Number} degrees The angle to convert in degrees.\n * @returns {Number} The corresponding angle in radians.\n */\nCesiumMath.toRadians = function (degrees) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(degrees)) {\n    throw new DeveloperError(\"degrees is required.\");\n  }\n  //>>includeEnd('debug');\n  return degrees * CesiumMath.RADIANS_PER_DEGREE;\n};\n\n/**\n * Converts radians to degrees.\n * @param {Number} radians The angle to convert in radians.\n * @returns {Number} The corresponding angle in degrees.\n */\nCesiumMath.toDegrees = function (radians) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(radians)) {\n    throw new DeveloperError(\"radians is required.\");\n  }\n  //>>includeEnd('debug');\n  return radians * CesiumMath.DEGREES_PER_RADIAN;\n};\n\n/**\n * Converts a longitude value, in radians, to the range [<code>-Math.PI</code>, <code>Math.PI</code>).\n *\n * @param {Number} angle The longitude value, in radians, to convert to the range [<code>-Math.PI</code>, <code>Math.PI</code>).\n * @returns {Number} The equivalent longitude value in the range [<code>-Math.PI</code>, <code>Math.PI</code>).\n *\n * @example\n * // Convert 270 degrees to -90 degrees longitude\n * var longitude = Cesium.Math.convertLongitudeRange(Cesium.Math.toRadians(270.0));\n */\nCesiumMath.convertLongitudeRange = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  }\n  //>>includeEnd('debug');\n  var twoPi = CesiumMath.TWO_PI;\n\n  var simplified = angle - Math.floor(angle / twoPi) * twoPi;\n\n  if (simplified < -Math.PI) {\n    return simplified + twoPi;\n  }\n  if (simplified >= Math.PI) {\n    return simplified - twoPi;\n  }\n\n  return simplified;\n};\n\n/**\n * Convenience function that clamps a latitude value, in radians, to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).\n * Useful for sanitizing data before use in objects requiring correct range.\n *\n * @param {Number} angle The latitude value, in radians, to clamp to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).\n * @returns {Number} The latitude value clamped to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).\n *\n * @example\n * // Clamp 108 degrees latitude to 90 degrees latitude\n * var latitude = Cesium.Math.clampToLatitudeRange(Cesium.Math.toRadians(108.0));\n */\nCesiumMath.clampToLatitudeRange = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return CesiumMath.clamp(\n    angle,\n    -1 * CesiumMath.PI_OVER_TWO,\n    CesiumMath.PI_OVER_TWO\n  );\n};\n\n/**\n * Produces an angle in the range -Pi <= angle <= Pi which is equivalent to the provided angle.\n *\n * @param {Number} angle in radians\n * @returns {Number} The angle in the range [<code>-CesiumMath.PI</code>, <code>CesiumMath.PI</code>].\n */\nCesiumMath.negativePiToPi = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  }\n  //>>includeEnd('debug');\n  return CesiumMath.zeroToTwoPi(angle + CesiumMath.PI) - CesiumMath.PI;\n};\n\n/**\n * Produces an angle in the range 0 <= angle <= 2Pi which is equivalent to the provided angle.\n *\n * @param {Number} angle in radians\n * @returns {Number} The angle in the range [0, <code>CesiumMath.TWO_PI</code>].\n */\nCesiumMath.zeroToTwoPi = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  }\n  //>>includeEnd('debug');\n  var mod = CesiumMath.mod(angle, CesiumMath.TWO_PI);\n  if (\n    Math.abs(mod) < CesiumMath.EPSILON14 &&\n    Math.abs(angle) > CesiumMath.EPSILON14\n  ) {\n    return CesiumMath.TWO_PI;\n  }\n  return mod;\n};\n\n/**\n * The modulo operation that also works for negative dividends.\n *\n * @param {Number} m The dividend.\n * @param {Number} n The divisor.\n * @returns {Number} The remainder.\n */\nCesiumMath.mod = function (m, n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(m)) {\n    throw new DeveloperError(\"m is required.\");\n  }\n  if (!defined(n)) {\n    throw new DeveloperError(\"n is required.\");\n  }\n  //>>includeEnd('debug');\n  return ((m % n) + n) % n;\n};\n\n/**\n * Determines if two values are equal using an absolute or relative tolerance test. This is useful\n * to avoid problems due to roundoff error when comparing floating-point values directly. The values are\n * first compared using an absolute tolerance test. If that fails, a relative tolerance test is performed.\n * Use this test if you are unsure of the magnitudes of left and right.\n *\n * @param {Number} left The first value to compare.\n * @param {Number} right The other value to compare.\n * @param {Number} relativeEpsilon The maximum inclusive delta between <code>left</code> and <code>right</code> for the relative tolerance test.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The maximum inclusive delta between <code>left</code> and <code>right</code> for the absolute tolerance test.\n * @returns {Boolean} <code>true</code> if the values are equal within the epsilon; otherwise, <code>false</code>.\n *\n * @example\n * var a = Cesium.Math.equalsEpsilon(0.0, 0.01, Cesium.Math.EPSILON2); // true\n * var b = Cesium.Math.equalsEpsilon(0.0, 0.1, Cesium.Math.EPSILON2);  // false\n * var c = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON7); // true\n * var d = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON9); // false\n */\nCesiumMath.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"left is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"right is required.\");\n  }\n  if (!defined(relativeEpsilon)) {\n    throw new DeveloperError(\"relativeEpsilon is required.\");\n  }\n  //>>includeEnd('debug');\n  absoluteEpsilon = defaultValue(absoluteEpsilon, relativeEpsilon);\n  var absDiff = Math.abs(left - right);\n  return (\n    absDiff <= absoluteEpsilon ||\n    absDiff <= relativeEpsilon * Math.max(Math.abs(left), Math.abs(right))\n  );\n};\n\n/**\n * Determines if the left value is less than the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns false.\n *\n * @param {Number} left The first number to compare.\n * @param {Number} right The second number to compare.\n * @param {Number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {Boolean} <code>true</code> if <code>left</code> is less than <code>right</code> by more than\n *          <code>absoluteEpsilon<code>. <code>false</code> if <code>left</code> is greater or if the two\n *          values are nearly equal.\n */\nCesiumMath.lessThan = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"first is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"second is required.\");\n  }\n  if (!defined(absoluteEpsilon)) {\n    throw new DeveloperError(\"relativeEpsilon is required.\");\n  }\n  //>>includeEnd('debug');\n  return left - right < -absoluteEpsilon;\n};\n\n/**\n * Determines if the left value is less than or equal to the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns true.\n *\n * @param {Number} left The first number to compare.\n * @param {Number} right The second number to compare.\n * @param {Number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {Boolean} <code>true</code> if <code>left</code> is less than <code>right</code> or if the\n *          the values are nearly equal.\n */\nCesiumMath.lessThanOrEquals = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"first is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"second is required.\");\n  }\n  if (!defined(absoluteEpsilon)) {\n    throw new DeveloperError(\"relativeEpsilon is required.\");\n  }\n  //>>includeEnd('debug');\n  return left - right < absoluteEpsilon;\n};\n\n/**\n * Determines if the left value is greater the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns false.\n *\n * @param {Number} left The first number to compare.\n * @param {Number} right The second number to compare.\n * @param {Number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {Boolean} <code>true</code> if <code>left</code> is greater than <code>right</code> by more than\n *          <code>absoluteEpsilon<code>. <code>false</code> if <code>left</code> is less or if the two\n *          values are nearly equal.\n */\nCesiumMath.greaterThan = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"first is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"second is required.\");\n  }\n  if (!defined(absoluteEpsilon)) {\n    throw new DeveloperError(\"relativeEpsilon is required.\");\n  }\n  //>>includeEnd('debug');\n  return left - right > absoluteEpsilon;\n};\n\n/**\n * Determines if the left value is greater than or equal to the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns true.\n *\n * @param {Number} left The first number to compare.\n * @param {Number} right The second number to compare.\n * @param {Number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {Boolean} <code>true</code> if <code>left</code> is greater than <code>right</code> or if the\n *          the values are nearly equal.\n */\nCesiumMath.greaterThanOrEquals = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"first is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"second is required.\");\n  }\n  if (!defined(absoluteEpsilon)) {\n    throw new DeveloperError(\"relativeEpsilon is required.\");\n  }\n  //>>includeEnd('debug');\n  return left - right > -absoluteEpsilon;\n};\n\nvar factorials = [1];\n\n/**\n * Computes the factorial of the provided number.\n *\n * @param {Number} n The number whose factorial is to be computed.\n * @returns {Number} The factorial of the provided number or undefined if the number is less than 0.\n *\n * @exception {DeveloperError} A number greater than or equal to 0 is required.\n *\n *\n * @example\n * //Compute 7!, which is equal to 5040\n * var computedFactorial = Cesium.Math.factorial(7);\n *\n * @see {@link http://en.wikipedia.org/wiki/Factorial|Factorial on Wikipedia}\n */\nCesiumMath.factorial = function (n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof n !== \"number\" || n < 0) {\n    throw new DeveloperError(\n      \"A number greater than or equal to 0 is required.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var length = factorials.length;\n  if (n >= length) {\n    var sum = factorials[length - 1];\n    for (var i = length; i <= n; i++) {\n      var next = sum * i;\n      factorials.push(next);\n      sum = next;\n    }\n  }\n  return factorials[n];\n};\n\n/**\n * Increments a number with a wrapping to a minimum value if the number exceeds the maximum value.\n *\n * @param {Number} [n] The number to be incremented.\n * @param {Number} [maximumValue] The maximum incremented value before rolling over to the minimum value.\n * @param {Number} [minimumValue=0.0] The number reset to after the maximum value has been exceeded.\n * @returns {Number} The incremented number.\n *\n * @exception {DeveloperError} Maximum value must be greater than minimum value.\n *\n * @example\n * var n = Cesium.Math.incrementWrap(5, 10, 0); // returns 6\n * var n = Cesium.Math.incrementWrap(10, 10, 0); // returns 0\n */\nCesiumMath.incrementWrap = function (n, maximumValue, minimumValue) {\n  minimumValue = defaultValue(minimumValue, 0.0);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(n)) {\n    throw new DeveloperError(\"n is required.\");\n  }\n  if (maximumValue <= minimumValue) {\n    throw new DeveloperError(\"maximumValue must be greater than minimumValue.\");\n  }\n  //>>includeEnd('debug');\n\n  ++n;\n  if (n > maximumValue) {\n    n = minimumValue;\n  }\n  return n;\n};\n\n/**\n * Determines if a positive integer is a power of two.\n *\n * @param {Number} n The positive integer to test.\n * @returns {Boolean} <code>true</code> if the number if a power of two; otherwise, <code>false</code>.\n *\n * @exception {DeveloperError} A number greater than or equal to 0 is required.\n *\n * @example\n * var t = Cesium.Math.isPowerOfTwo(16); // true\n * var f = Cesium.Math.isPowerOfTwo(20); // false\n */\nCesiumMath.isPowerOfTwo = function (n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof n !== \"number\" || n < 0) {\n    throw new DeveloperError(\n      \"A number greater than or equal to 0 is required.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  return n !== 0 && (n & (n - 1)) === 0;\n};\n\n/**\n * Computes the next power-of-two integer greater than or equal to the provided positive integer.\n *\n * @param {Number} n The positive integer to test.\n * @returns {Number} The next power-of-two integer.\n *\n * @exception {DeveloperError} A number greater than or equal to 0 is required.\n *\n * @example\n * var n = Cesium.Math.nextPowerOfTwo(29); // 32\n * var m = Cesium.Math.nextPowerOfTwo(32); // 32\n */\nCesiumMath.nextPowerOfTwo = function (n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof n !== \"number\" || n < 0) {\n    throw new DeveloperError(\n      \"A number greater than or equal to 0 is required.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  // From http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2\n  --n;\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  ++n;\n\n  return n;\n};\n\n/**\n * Constraint a value to lie between two values.\n *\n * @param {Number} value The value to constrain.\n * @param {Number} min The minimum value.\n * @param {Number} max The maximum value.\n * @returns {Number} The value clamped so that min <= value <= max.\n */\nCesiumMath.clamp = function (value, min, max) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(min)) {\n    throw new DeveloperError(\"min is required.\");\n  }\n  if (!defined(max)) {\n    throw new DeveloperError(\"max is required.\");\n  }\n  //>>includeEnd('debug');\n  return value < min ? min : value > max ? max : value;\n};\n\nvar randomNumberGenerator = new MersenneTwister();\n\n/**\n * Sets the seed used by the random number generator\n * in {@link CesiumMath#nextRandomNumber}.\n *\n * @param {Number} seed An integer used as the seed.\n */\nCesiumMath.setRandomNumberSeed = function (seed) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(seed)) {\n    throw new DeveloperError(\"seed is required.\");\n  }\n  //>>includeEnd('debug');\n\n  randomNumberGenerator = new MersenneTwister(seed);\n};\n\n/**\n * Generates a random floating point number in the range of [0.0, 1.0)\n * using a Mersenne twister.\n *\n * @returns {Number} A random number in the range of [0.0, 1.0).\n *\n * @see CesiumMath.setRandomNumberSeed\n * @see {@link http://en.wikipedia.org/wiki/Mersenne_twister|Mersenne twister on Wikipedia}\n */\nCesiumMath.nextRandomNumber = function () {\n  return randomNumberGenerator.random();\n};\n\n/**\n * Generates a random number between two numbers.\n *\n * @param {Number} min The minimum value.\n * @param {Number} max The maximum value.\n * @returns {Number} A random number between the min and max.\n */\nCesiumMath.randomBetween = function (min, max) {\n  return CesiumMath.nextRandomNumber() * (max - min) + min;\n};\n\n/**\n * Computes <code>Math.acos(value)</code>, but first clamps <code>value</code> to the range [-1.0, 1.0]\n * so that the function will never return NaN.\n *\n * @param {Number} value The value for which to compute acos.\n * @returns {Number} The acos of the value if the value is in the range [-1.0, 1.0], or the acos of -1.0 or 1.0,\n *          whichever is closer, if the value is outside the range.\n */\nCesiumMath.acosClamped = function (value) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required.\");\n  }\n  //>>includeEnd('debug');\n  return Math.acos(CesiumMath.clamp(value, -1.0, 1.0));\n};\n\n/**\n * Computes <code>Math.asin(value)</code>, but first clamps <code>value</code> to the range [-1.0, 1.0]\n * so that the function will never return NaN.\n *\n * @param {Number} value The value for which to compute asin.\n * @returns {Number} The asin of the value if the value is in the range [-1.0, 1.0], or the asin of -1.0 or 1.0,\n *          whichever is closer, if the value is outside the range.\n */\nCesiumMath.asinClamped = function (value) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required.\");\n  }\n  //>>includeEnd('debug');\n  return Math.asin(CesiumMath.clamp(value, -1.0, 1.0));\n};\n\n/**\n * Finds the chord length between two points given the circle's radius and the angle between the points.\n *\n * @param {Number} angle The angle between the two points.\n * @param {Number} radius The radius of the circle.\n * @returns {Number} The chord length.\n */\nCesiumMath.chordLength = function (angle, radius) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  }\n  if (!defined(radius)) {\n    throw new DeveloperError(\"radius is required.\");\n  }\n  //>>includeEnd('debug');\n  return 2.0 * radius * Math.sin(angle * 0.5);\n};\n\n/**\n * Finds the logarithm of a number to a base.\n *\n * @param {Number} number The number.\n * @param {Number} base The base.\n * @returns {Number} The result.\n */\nCesiumMath.logBase = function (number, base) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(number)) {\n    throw new DeveloperError(\"number is required.\");\n  }\n  if (!defined(base)) {\n    throw new DeveloperError(\"base is required.\");\n  }\n  //>>includeEnd('debug');\n  return Math.log(number) / Math.log(base);\n};\n\n/**\n * Finds the cube root of a number.\n * Returns NaN if <code>number</code> is not provided.\n *\n * @function\n * @param {Number} [number] The number.\n * @returns {Number} The result.\n */\nCesiumMath.cbrt = defaultValue(Math.cbrt, function cbrt(number) {\n  var result = Math.pow(Math.abs(number), 1.0 / 3.0);\n  return number < 0.0 ? -result : result;\n});\n\n/**\n * Finds the base 2 logarithm of a number.\n *\n * @function\n * @param {Number} number The number.\n * @returns {Number} The result.\n */\nCesiumMath.log2 = defaultValue(Math.log2, function log2(number) {\n  return Math.log(number) * Math.LOG2E;\n});\n\n/**\n * @private\n */\nCesiumMath.fog = function (distanceToCamera, density) {\n  var scalar = distanceToCamera * density;\n  return 1.0 - Math.exp(-(scalar * scalar));\n};\n\n/**\n * Computes a fast approximation of Atan for input in the range [-1, 1].\n *\n * Based on Michal Drobot's approximation from ShaderFastLibs,\n * which in turn is based on \"Efficient approximations for the arctangent function,\"\n * Rajan, S. Sichun Wang Inkol, R. Joyal, A., May 2006.\n * Adapted from ShaderFastLibs under MIT License.\n *\n * @param {Number} x An input number in the range [-1, 1]\n * @returns {Number} An approximation of atan(x)\n */\nCesiumMath.fastApproximateAtan = function (x) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"x\", x);\n  //>>includeEnd('debug');\n\n  return x * (-0.1784 * Math.abs(x) - 0.0663 * x * x + 1.0301);\n};\n\n/**\n * Computes a fast approximation of Atan2(x, y) for arbitrary input scalars.\n *\n * Range reduction math based on nvidia's cg reference implementation: http://developer.download.nvidia.com/cg/atan2.html\n *\n * @param {Number} x An input number that isn't zero if y is zero.\n * @param {Number} y An input number that isn't zero if x is zero.\n * @returns {Number} An approximation of atan2(x, y)\n */\nCesiumMath.fastApproximateAtan2 = function (x, y) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"x\", x);\n  Check.typeOf.number(\"y\", y);\n  //>>includeEnd('debug');\n\n  // atan approximations are usually only reliable over [-1, 1]\n  // So reduce the range by flipping whether x or y is on top based on which is bigger.\n  var opposite;\n  var adjacent;\n  var t = Math.abs(x); // t used as swap and atan result.\n  opposite = Math.abs(y);\n  adjacent = Math.max(t, opposite);\n  opposite = Math.min(t, opposite);\n\n  var oppositeOverAdjacent = opposite / adjacent;\n  //>>includeStart('debug', pragmas.debug);\n  if (isNaN(oppositeOverAdjacent)) {\n    throw new DeveloperError(\"either x or y must be nonzero\");\n  }\n  //>>includeEnd('debug');\n  t = CesiumMath.fastApproximateAtan(oppositeOverAdjacent);\n\n  // Undo range reduction\n  t = Math.abs(y) > Math.abs(x) ? CesiumMath.PI_OVER_TWO - t : t;\n  t = x < 0.0 ? CesiumMath.PI - t : t;\n  t = y < 0.0 ? -t : t;\n  return t;\n};\nexport default CesiumMath;\n"]},"metadata":{},"sourceType":"module"}