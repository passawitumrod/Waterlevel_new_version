{"ast":null,"code":"import combine from \"../Core/combine.js\";\nimport Credit from \"../Core/Credit.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Resource from \"../Core/Resource.js\";\nimport WebMercatorTilingScheme from \"../Core/WebMercatorTilingScheme.js\";\nimport when from \"../ThirdParty/when.js\";\nimport ImageryProvider from \"./ImageryProvider.js\";\nimport TimeDynamicImagery from \"./TimeDynamicImagery.js\";\nvar defaultParameters = Object.freeze({\n  service: \"WMTS\",\n  version: \"1.0.0\",\n  request: \"GetTile\"\n});\n/**\n * Provides tiled imagery served by {@link http://www.opengeospatial.org/standards/wmts|WMTS 1.0.0} compliant servers.\n * This provider supports HTTP KVP-encoded and RESTful GetTile requests, but does not yet support the SOAP encoding.\n *\n * @alias WebMapTileServiceImageryProvider\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource|String} options.url The base URL for the WMTS GetTile operation (for KVP-encoded requests) or the tile-URL template (for RESTful requests). The tile-URL template should contain the following variables: &#123;style&#125;, &#123;TileMatrixSet&#125;, &#123;TileMatrix&#125;, &#123;TileRow&#125;, &#123;TileCol&#125;. The first two are optional if actual values are hardcoded or not required by the server. The &#123;s&#125; keyword may be used to specify subdomains.\n * @param {String} [options.format='image/jpeg'] The MIME type for images to retrieve from the server.\n * @param {String} options.layer The layer name for WMTS requests.\n * @param {String} options.style The style name for WMTS requests.\n * @param {String} options.tileMatrixSetID The identifier of the TileMatrixSet to use for WMTS requests.\n * @param {Array} [options.tileMatrixLabels] A list of identifiers in the TileMatrix to use for WMTS requests, one per TileMatrix level.\n * @param {Clock} [options.clock] A Clock instance that is used when determining the value for the time dimension. Required when options.times is specified.\n * @param {TimeIntervalCollection} [options.times] TimeIntervalCollection with its <code>data</code> property being an object containing time dynamic dimension and their values.\n * @param {Object} [options.dimensions] A object containing static dimensions and their values.\n * @param {Number} [options.tileWidth=256] The tile width in pixels.\n * @param {Number} [options.tileHeight=256] The tile height in pixels.\n * @param {TilingScheme} [options.tilingScheme] The tiling scheme corresponding to the organization of the tiles in the TileMatrixSet.\n * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle covered by the layer.\n * @param {Number} [options.minimumLevel=0] The minimum level-of-detail supported by the imagery provider.\n * @param {Number} [options.maximumLevel] The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.\n * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If not specified, the WGS84 ellipsoid is used.\n * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.\n * @param {String|String[]} [options.subdomains='abc'] The subdomains to use for the <code>{s}</code> placeholder in the URL template.\n *                          If this parameter is a single string, each character in the string is a subdomain.  If it is\n *                          an array, each element in the array is a subdomain.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Web%20Map%20Tile%20Service%20with%20Time.html|Cesium Sandcastle Web Map Tile Service with Time Demo}\n *\n * @example\n * // Example 1. USGS shaded relief tiles (KVP)\n * var shadedRelief1 = new Cesium.WebMapTileServiceImageryProvider({\n *     url : 'http://basemap.nationalmap.gov/arcgis/rest/services/USGSShadedReliefOnly/MapServer/WMTS',\n *     layer : 'USGSShadedReliefOnly',\n *     style : 'default',\n *     format : 'image/jpeg',\n *     tileMatrixSetID : 'default028mm',\n *     // tileMatrixLabels : ['default028mm:0', 'default028mm:1', 'default028mm:2' ...],\n *     maximumLevel: 19,\n *     credit : new Cesium.Credit('U. S. Geological Survey')\n * });\n * viewer.imageryLayers.addImageryProvider(shadedRelief1);\n *\n * @example\n * // Example 2. USGS shaded relief tiles (RESTful)\n * var shadedRelief2 = new Cesium.WebMapTileServiceImageryProvider({\n *     url : 'http://basemap.nationalmap.gov/arcgis/rest/services/USGSShadedReliefOnly/MapServer/WMTS/tile/1.0.0/USGSShadedReliefOnly/{Style}/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.jpg',\n *     layer : 'USGSShadedReliefOnly',\n *     style : 'default',\n *     format : 'image/jpeg',\n *     tileMatrixSetID : 'default028mm',\n *     maximumLevel: 19,\n *     credit : new Cesium.Credit('U. S. Geological Survey')\n * });\n * viewer.imageryLayers.addImageryProvider(shadedRelief2);\n *\n * @example\n * // Example 3. NASA time dynamic weather data (RESTful)\n * var times = Cesium.TimeIntervalCollection.fromIso8601({\n *     iso8601: '2015-07-30/2017-06-16/P1D',\n *     dataCallback: function dataCallback(interval, index) {\n *         return {\n *             Time: Cesium.JulianDate.toIso8601(interval.start)\n *         };\n *     }\n * });\n * var weather = new Cesium.WebMapTileServiceImageryProvider({\n *     url : 'https://gibs.earthdata.nasa.gov/wmts/epsg4326/best/AMSR2_Snow_Water_Equivalent/default/{Time}/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.png',\n *     layer : 'AMSR2_Snow_Water_Equivalent',\n *     style : 'default',\n *     tileMatrixSetID : '2km',\n *     maximumLevel : 5,\n *     format : 'image/png',\n *     clock: clock,\n *     times: times,\n *     credit : new Cesium.Credit('NASA Global Imagery Browse Services for EOSDIS')\n * });\n * viewer.imageryLayers.addImageryProvider(weather);\n *\n * @see ArcGisMapServerImageryProvider\n * @see BingMapsImageryProvider\n * @see GoogleEarthEnterpriseMapsProvider\n * @see OpenStreetMapImageryProvider\n * @see SingleTileImageryProvider\n * @see TileMapServiceImageryProvider\n * @see WebMapServiceImageryProvider\n * @see UrlTemplateImageryProvider\n */\n\nfunction WebMapTileServiceImageryProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(options.url)) {\n    throw new DeveloperError(\"options.url is required.\");\n  }\n\n  if (!defined(options.layer)) {\n    throw new DeveloperError(\"options.layer is required.\");\n  }\n\n  if (!defined(options.style)) {\n    throw new DeveloperError(\"options.style is required.\");\n  }\n\n  if (!defined(options.tileMatrixSetID)) {\n    throw new DeveloperError(\"options.tileMatrixSetID is required.\");\n  }\n\n  if (defined(options.times) && !defined(options.clock)) {\n    throw new DeveloperError(\"options.times was specified, so options.clock is required.\");\n  } //>>includeEnd('debug');\n\n\n  var resource = Resource.createIfNeeded(options.url);\n  var style = options.style;\n  var tileMatrixSetID = options.tileMatrixSetID;\n  var url = resource.url;\n\n  if (url.indexOf(\"{\") >= 0) {\n    var templateValues = {\n      style: style,\n      Style: style,\n      TileMatrixSet: tileMatrixSetID\n    };\n    resource.setTemplateValues(templateValues);\n    this._useKvp = false;\n  } else {\n    resource.setQueryParameters(defaultParameters);\n    this._useKvp = true;\n  }\n\n  this._resource = resource;\n  this._layer = options.layer;\n  this._style = style;\n  this._tileMatrixSetID = tileMatrixSetID;\n  this._tileMatrixLabels = options.tileMatrixLabels;\n  this._format = defaultValue(options.format, \"image/jpeg\");\n  this._tileDiscardPolicy = options.tileDiscardPolicy;\n  this._tilingScheme = defined(options.tilingScheme) ? options.tilingScheme : new WebMercatorTilingScheme({\n    ellipsoid: options.ellipsoid\n  });\n  this._tileWidth = defaultValue(options.tileWidth, 256);\n  this._tileHeight = defaultValue(options.tileHeight, 256);\n  this._minimumLevel = defaultValue(options.minimumLevel, 0);\n  this._maximumLevel = options.maximumLevel;\n  this._rectangle = defaultValue(options.rectangle, this._tilingScheme.rectangle);\n  this._dimensions = options.dimensions;\n  var that = this;\n  this._reload = undefined;\n\n  if (defined(options.times)) {\n    this._timeDynamicImagery = new TimeDynamicImagery({\n      clock: options.clock,\n      times: options.times,\n      requestImageFunction: function requestImageFunction(x, y, level, request, interval) {\n        return requestImage(that, x, y, level, request, interval);\n      },\n      reloadFunction: function reloadFunction() {\n        if (defined(that._reload)) {\n          that._reload();\n        }\n      }\n    });\n  }\n\n  this._readyPromise = when.resolve(true); // Check the number of tiles at the minimum level.  If it's more than four,\n  // throw an exception, because starting at the higher minimum\n  // level will cause too many tiles to be downloaded and rendered.\n\n  var swTile = this._tilingScheme.positionToTileXY(Rectangle.southwest(this._rectangle), this._minimumLevel);\n\n  var neTile = this._tilingScheme.positionToTileXY(Rectangle.northeast(this._rectangle), this._minimumLevel);\n\n  var tileCount = (Math.abs(neTile.x - swTile.x) + 1) * (Math.abs(neTile.y - swTile.y) + 1); //>>includeStart('debug', pragmas.debug);\n\n  if (tileCount > 4) {\n    throw new DeveloperError(\"The imagery provider's rectangle and minimumLevel indicate that there are \" + tileCount + \" tiles at the minimum level. Imagery providers with more than four tiles at the minimum level are not supported.\");\n  } //>>includeEnd('debug');\n\n\n  this._errorEvent = new Event();\n  var credit = options.credit;\n  this._credit = typeof credit === \"string\" ? new Credit(credit) : credit;\n  this._subdomains = options.subdomains;\n\n  if (Array.isArray(this._subdomains)) {\n    this._subdomains = this._subdomains.slice();\n  } else if (defined(this._subdomains) && this._subdomains.length > 0) {\n    this._subdomains = this._subdomains.split(\"\");\n  } else {\n    this._subdomains = [\"a\", \"b\", \"c\"];\n  }\n}\n\nfunction requestImage(imageryProvider, col, row, level, request, interval) {\n  var labels = imageryProvider._tileMatrixLabels;\n  var tileMatrix = defined(labels) ? labels[level] : level.toString();\n  var subdomains = imageryProvider._subdomains;\n  var staticDimensions = imageryProvider._dimensions;\n  var dynamicIntervalData = defined(interval) ? interval.data : undefined;\n  var resource;\n\n  if (!imageryProvider._useKvp) {\n    var templateValues = {\n      TileMatrix: tileMatrix,\n      TileRow: row.toString(),\n      TileCol: col.toString(),\n      s: subdomains[(col + row + level) % subdomains.length]\n    };\n    resource = imageryProvider._resource.getDerivedResource({\n      request: request\n    });\n    resource.setTemplateValues(templateValues);\n\n    if (defined(staticDimensions)) {\n      resource.setTemplateValues(staticDimensions);\n    }\n\n    if (defined(dynamicIntervalData)) {\n      resource.setTemplateValues(dynamicIntervalData);\n    }\n  } else {\n    // build KVP request\n    var query = {};\n    query.tilematrix = tileMatrix;\n    query.layer = imageryProvider._layer;\n    query.style = imageryProvider._style;\n    query.tilerow = row;\n    query.tilecol = col;\n    query.tilematrixset = imageryProvider._tileMatrixSetID;\n    query.format = imageryProvider._format;\n\n    if (defined(staticDimensions)) {\n      query = combine(query, staticDimensions);\n    }\n\n    if (defined(dynamicIntervalData)) {\n      query = combine(query, dynamicIntervalData);\n    }\n\n    resource = imageryProvider._resource.getDerivedResource({\n      queryParameters: query,\n      request: request\n    });\n  }\n\n  return ImageryProvider.loadImage(imageryProvider, resource);\n}\n\nObject.defineProperties(WebMapTileServiceImageryProvider.prototype, {\n  /**\n   * Gets the URL of the service hosting the imagery.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {String}\n   * @readonly\n   */\n  url: {\n    get: function get() {\n      return this._resource.url;\n    }\n  },\n\n  /**\n   * Gets the proxy used by this provider.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {Proxy}\n   * @readonly\n   */\n  proxy: {\n    get: function get() {\n      return this._resource.proxy;\n    }\n  },\n\n  /**\n   * Gets the width of each tile, in pixels. This function should\n   * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileWidth: {\n    get: function get() {\n      return this._tileWidth;\n    }\n  },\n\n  /**\n   * Gets the height of each tile, in pixels.  This function should\n   * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileHeight: {\n    get: function get() {\n      return this._tileHeight;\n    }\n  },\n\n  /**\n   * Gets the maximum level-of-detail that can be requested.  This function should\n   * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  maximumLevel: {\n    get: function get() {\n      return this._maximumLevel;\n    }\n  },\n\n  /**\n   * Gets the minimum level-of-detail that can be requested.  This function should\n   * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  minimumLevel: {\n    get: function get() {\n      return this._minimumLevel;\n    }\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.  This function should\n   * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function get() {\n      return this._tilingScheme;\n    }\n  },\n\n  /**\n   * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should\n   * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  rectangle: {\n    get: function get() {\n      return this._rectangle;\n    }\n  },\n\n  /**\n   * Gets the tile discard policy.  If not undefined, the discard policy is responsible\n   * for filtering out \"missing\" tiles via its shouldDiscardImage function.  If this function\n   * returns undefined, no tiles are filtered.  This function should\n   * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {TileDiscardPolicy}\n   * @readonly\n   */\n  tileDiscardPolicy: {\n    get: function get() {\n      return this._tileDiscardPolicy;\n    }\n  },\n\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function get() {\n      return this._errorEvent;\n    }\n  },\n\n  /**\n   * Gets the mime type of images returned by this imagery provider.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {String}\n   * @readonly\n   */\n  format: {\n    get: function get() {\n      return this._format;\n    }\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    value: true\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function get() {\n      return this._readyPromise;\n    }\n  },\n\n  /**\n   * Gets the credit to display when this imagery provider is active.  Typically this is used to credit\n   * the source of the imagery.  This function should not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function get() {\n      return this._credit;\n    }\n  },\n\n  /**\n   * Gets a value indicating whether or not the images provided by this imagery provider\n   * include an alpha channel.  If this property is false, an alpha channel, if present, will\n   * be ignored.  If this property is true, any images without an alpha channel will be treated\n   * as if their alpha is 1.0 everywhere.  When this property is false, memory usage\n   * and texture upload time are reduced.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasAlphaChannel: {\n    get: function get() {\n      return true;\n    }\n  },\n\n  /**\n   * Gets or sets a clock that is used to get keep the time used for time dynamic parameters.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {Clock}\n   */\n  clock: {\n    get: function get() {\n      return this._timeDynamicImagery.clock;\n    },\n    set: function set(value) {\n      this._timeDynamicImagery.clock = value;\n    }\n  },\n\n  /**\n   * Gets or sets a time interval collection that is used to get time dynamic parameters. The data of each\n   * TimeInterval is an object containing the keys and values of the properties that are used during\n   * tile requests.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {TimeIntervalCollection}\n   */\n  times: {\n    get: function get() {\n      return this._timeDynamicImagery.times;\n    },\n    set: function set(value) {\n      this._timeDynamicImagery.times = value;\n    }\n  },\n\n  /**\n   * Gets or sets an object that contains static dimensions and their values.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {Object}\n   */\n  dimensions: {\n    get: function get() {\n      return this._dimensions;\n    },\n    set: function set(value) {\n      if (this._dimensions !== value) {\n        this._dimensions = value;\n\n        if (defined(this._reload)) {\n          this._reload();\n        }\n      }\n    }\n  }\n});\n/**\n * Gets the credits to be displayed when a given tile is displayed.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level;\n * @returns {Credit[]} The credits to be displayed when the tile is displayed.\n *\n * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.\n */\n\nWebMapTileServiceImageryProvider.prototype.getTileCredits = function (x, y, level) {\n  return undefined;\n};\n/**\n * Requests the image for a given tile.  This function should\n * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<Image|Canvas>|undefined} A promise for the image that will resolve when the image is available, or\n *          undefined if there are too many active requests to the server, and the request\n *          should be retried later.  The resolved image may be either an\n *          Image or a Canvas DOM object.\n *\n * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.\n */\n\n\nWebMapTileServiceImageryProvider.prototype.requestImage = function (x, y, level, request) {\n  var result;\n  var timeDynamicImagery = this._timeDynamicImagery;\n  var currentInterval; // Try and load from cache\n\n  if (defined(timeDynamicImagery)) {\n    currentInterval = timeDynamicImagery.currentInterval;\n    result = timeDynamicImagery.getFromCache(x, y, level, request);\n  } // Couldn't load from cache\n\n\n  if (!defined(result)) {\n    result = requestImage(this, x, y, level, request, currentInterval);\n  } // If we are approaching an interval, preload this tile in the next interval\n\n\n  if (defined(result) && defined(timeDynamicImagery)) {\n    timeDynamicImagery.checkApproachingInterval(x, y, level, request);\n  }\n\n  return result;\n};\n/**\n * Picking features is not currently supported by this imagery provider, so this function simply returns\n * undefined.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Number} longitude The longitude at which to pick features.\n * @param {Number} latitude  The latitude at which to pick features.\n * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve when the asynchronous\n *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}\n *                   instances.  The array may be empty if no features are found at the given location.\n *                   It may also be undefined if picking is not supported.\n */\n\n\nWebMapTileServiceImageryProvider.prototype.pickFeatures = function (x, y, level, longitude, latitude) {\n  return undefined;\n};\n\nexport default WebMapTileServiceImageryProvider;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/WebMapTileServiceImageryProvider.js"],"names":["combine","Credit","defaultValue","defined","DeveloperError","Event","Rectangle","Resource","WebMercatorTilingScheme","when","ImageryProvider","TimeDynamicImagery","defaultParameters","Object","freeze","service","version","request","WebMapTileServiceImageryProvider","options","EMPTY_OBJECT","url","layer","style","tileMatrixSetID","times","clock","resource","createIfNeeded","indexOf","templateValues","Style","TileMatrixSet","setTemplateValues","_useKvp","setQueryParameters","_resource","_layer","_style","_tileMatrixSetID","_tileMatrixLabels","tileMatrixLabels","_format","format","_tileDiscardPolicy","tileDiscardPolicy","_tilingScheme","tilingScheme","ellipsoid","_tileWidth","tileWidth","_tileHeight","tileHeight","_minimumLevel","minimumLevel","_maximumLevel","maximumLevel","_rectangle","rectangle","_dimensions","dimensions","that","_reload","undefined","_timeDynamicImagery","requestImageFunction","x","y","level","interval","requestImage","reloadFunction","_readyPromise","resolve","swTile","positionToTileXY","southwest","neTile","northeast","tileCount","Math","abs","_errorEvent","credit","_credit","_subdomains","subdomains","Array","isArray","slice","length","split","imageryProvider","col","row","labels","tileMatrix","toString","staticDimensions","dynamicIntervalData","data","TileMatrix","TileRow","TileCol","s","getDerivedResource","query","tilematrix","tilerow","tilecol","tilematrixset","queryParameters","loadImage","defineProperties","prototype","get","proxy","errorEvent","ready","value","readyPromise","hasAlphaChannel","set","getTileCredits","result","timeDynamicImagery","currentInterval","getFromCache","checkApproachingInterval","pickFeatures","longitude","latitude"],"mappings":"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","sourcesContent":["import combine from \"../Core/combine.js\";\nimport Credit from \"../Core/Credit.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Resource from \"../Core/Resource.js\";\nimport WebMercatorTilingScheme from \"../Core/WebMercatorTilingScheme.js\";\nimport when from \"../ThirdParty/when.js\";\nimport ImageryProvider from \"./ImageryProvider.js\";\nimport TimeDynamicImagery from \"./TimeDynamicImagery.js\";\n\nvar defaultParameters = Object.freeze({\n  service: \"WMTS\",\n  version: \"1.0.0\",\n  request: \"GetTile\",\n});\n\n/**\n * Provides tiled imagery served by {@link http://www.opengeospatial.org/standards/wmts|WMTS 1.0.0} compliant servers.\n * This provider supports HTTP KVP-encoded and RESTful GetTile requests, but does not yet support the SOAP encoding.\n *\n * @alias WebMapTileServiceImageryProvider\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource|String} options.url The base URL for the WMTS GetTile operation (for KVP-encoded requests) or the tile-URL template (for RESTful requests). The tile-URL template should contain the following variables: &#123;style&#125;, &#123;TileMatrixSet&#125;, &#123;TileMatrix&#125;, &#123;TileRow&#125;, &#123;TileCol&#125;. The first two are optional if actual values are hardcoded or not required by the server. The &#123;s&#125; keyword may be used to specify subdomains.\n * @param {String} [options.format='image/jpeg'] The MIME type for images to retrieve from the server.\n * @param {String} options.layer The layer name for WMTS requests.\n * @param {String} options.style The style name for WMTS requests.\n * @param {String} options.tileMatrixSetID The identifier of the TileMatrixSet to use for WMTS requests.\n * @param {Array} [options.tileMatrixLabels] A list of identifiers in the TileMatrix to use for WMTS requests, one per TileMatrix level.\n * @param {Clock} [options.clock] A Clock instance that is used when determining the value for the time dimension. Required when options.times is specified.\n * @param {TimeIntervalCollection} [options.times] TimeIntervalCollection with its <code>data</code> property being an object containing time dynamic dimension and their values.\n * @param {Object} [options.dimensions] A object containing static dimensions and their values.\n * @param {Number} [options.tileWidth=256] The tile width in pixels.\n * @param {Number} [options.tileHeight=256] The tile height in pixels.\n * @param {TilingScheme} [options.tilingScheme] The tiling scheme corresponding to the organization of the tiles in the TileMatrixSet.\n * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle covered by the layer.\n * @param {Number} [options.minimumLevel=0] The minimum level-of-detail supported by the imagery provider.\n * @param {Number} [options.maximumLevel] The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.\n * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If not specified, the WGS84 ellipsoid is used.\n * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.\n * @param {String|String[]} [options.subdomains='abc'] The subdomains to use for the <code>{s}</code> placeholder in the URL template.\n *                          If this parameter is a single string, each character in the string is a subdomain.  If it is\n *                          an array, each element in the array is a subdomain.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Web%20Map%20Tile%20Service%20with%20Time.html|Cesium Sandcastle Web Map Tile Service with Time Demo}\n *\n * @example\n * // Example 1. USGS shaded relief tiles (KVP)\n * var shadedRelief1 = new Cesium.WebMapTileServiceImageryProvider({\n *     url : 'http://basemap.nationalmap.gov/arcgis/rest/services/USGSShadedReliefOnly/MapServer/WMTS',\n *     layer : 'USGSShadedReliefOnly',\n *     style : 'default',\n *     format : 'image/jpeg',\n *     tileMatrixSetID : 'default028mm',\n *     // tileMatrixLabels : ['default028mm:0', 'default028mm:1', 'default028mm:2' ...],\n *     maximumLevel: 19,\n *     credit : new Cesium.Credit('U. S. Geological Survey')\n * });\n * viewer.imageryLayers.addImageryProvider(shadedRelief1);\n *\n * @example\n * // Example 2. USGS shaded relief tiles (RESTful)\n * var shadedRelief2 = new Cesium.WebMapTileServiceImageryProvider({\n *     url : 'http://basemap.nationalmap.gov/arcgis/rest/services/USGSShadedReliefOnly/MapServer/WMTS/tile/1.0.0/USGSShadedReliefOnly/{Style}/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.jpg',\n *     layer : 'USGSShadedReliefOnly',\n *     style : 'default',\n *     format : 'image/jpeg',\n *     tileMatrixSetID : 'default028mm',\n *     maximumLevel: 19,\n *     credit : new Cesium.Credit('U. S. Geological Survey')\n * });\n * viewer.imageryLayers.addImageryProvider(shadedRelief2);\n *\n * @example\n * // Example 3. NASA time dynamic weather data (RESTful)\n * var times = Cesium.TimeIntervalCollection.fromIso8601({\n *     iso8601: '2015-07-30/2017-06-16/P1D',\n *     dataCallback: function dataCallback(interval, index) {\n *         return {\n *             Time: Cesium.JulianDate.toIso8601(interval.start)\n *         };\n *     }\n * });\n * var weather = new Cesium.WebMapTileServiceImageryProvider({\n *     url : 'https://gibs.earthdata.nasa.gov/wmts/epsg4326/best/AMSR2_Snow_Water_Equivalent/default/{Time}/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.png',\n *     layer : 'AMSR2_Snow_Water_Equivalent',\n *     style : 'default',\n *     tileMatrixSetID : '2km',\n *     maximumLevel : 5,\n *     format : 'image/png',\n *     clock: clock,\n *     times: times,\n *     credit : new Cesium.Credit('NASA Global Imagery Browse Services for EOSDIS')\n * });\n * viewer.imageryLayers.addImageryProvider(weather);\n *\n * @see ArcGisMapServerImageryProvider\n * @see BingMapsImageryProvider\n * @see GoogleEarthEnterpriseMapsProvider\n * @see OpenStreetMapImageryProvider\n * @see SingleTileImageryProvider\n * @see TileMapServiceImageryProvider\n * @see WebMapServiceImageryProvider\n * @see UrlTemplateImageryProvider\n */\nfunction WebMapTileServiceImageryProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.url)) {\n    throw new DeveloperError(\"options.url is required.\");\n  }\n  if (!defined(options.layer)) {\n    throw new DeveloperError(\"options.layer is required.\");\n  }\n  if (!defined(options.style)) {\n    throw new DeveloperError(\"options.style is required.\");\n  }\n  if (!defined(options.tileMatrixSetID)) {\n    throw new DeveloperError(\"options.tileMatrixSetID is required.\");\n  }\n  if (defined(options.times) && !defined(options.clock)) {\n    throw new DeveloperError(\n      \"options.times was specified, so options.clock is required.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var resource = Resource.createIfNeeded(options.url);\n\n  var style = options.style;\n  var tileMatrixSetID = options.tileMatrixSetID;\n  var url = resource.url;\n  if (url.indexOf(\"{\") >= 0) {\n    var templateValues = {\n      style: style,\n      Style: style,\n      TileMatrixSet: tileMatrixSetID,\n    };\n\n    resource.setTemplateValues(templateValues);\n    this._useKvp = false;\n  } else {\n    resource.setQueryParameters(defaultParameters);\n    this._useKvp = true;\n  }\n\n  this._resource = resource;\n  this._layer = options.layer;\n  this._style = style;\n  this._tileMatrixSetID = tileMatrixSetID;\n  this._tileMatrixLabels = options.tileMatrixLabels;\n  this._format = defaultValue(options.format, \"image/jpeg\");\n  this._tileDiscardPolicy = options.tileDiscardPolicy;\n\n  this._tilingScheme = defined(options.tilingScheme)\n    ? options.tilingScheme\n    : new WebMercatorTilingScheme({ ellipsoid: options.ellipsoid });\n  this._tileWidth = defaultValue(options.tileWidth, 256);\n  this._tileHeight = defaultValue(options.tileHeight, 256);\n\n  this._minimumLevel = defaultValue(options.minimumLevel, 0);\n  this._maximumLevel = options.maximumLevel;\n\n  this._rectangle = defaultValue(\n    options.rectangle,\n    this._tilingScheme.rectangle\n  );\n  this._dimensions = options.dimensions;\n\n  var that = this;\n  this._reload = undefined;\n  if (defined(options.times)) {\n    this._timeDynamicImagery = new TimeDynamicImagery({\n      clock: options.clock,\n      times: options.times,\n      requestImageFunction: function (x, y, level, request, interval) {\n        return requestImage(that, x, y, level, request, interval);\n      },\n      reloadFunction: function () {\n        if (defined(that._reload)) {\n          that._reload();\n        }\n      },\n    });\n  }\n\n  this._readyPromise = when.resolve(true);\n\n  // Check the number of tiles at the minimum level.  If it's more than four,\n  // throw an exception, because starting at the higher minimum\n  // level will cause too many tiles to be downloaded and rendered.\n  var swTile = this._tilingScheme.positionToTileXY(\n    Rectangle.southwest(this._rectangle),\n    this._minimumLevel\n  );\n  var neTile = this._tilingScheme.positionToTileXY(\n    Rectangle.northeast(this._rectangle),\n    this._minimumLevel\n  );\n  var tileCount =\n    (Math.abs(neTile.x - swTile.x) + 1) * (Math.abs(neTile.y - swTile.y) + 1);\n  //>>includeStart('debug', pragmas.debug);\n  if (tileCount > 4) {\n    throw new DeveloperError(\n      \"The imagery provider's rectangle and minimumLevel indicate that there are \" +\n        tileCount +\n        \" tiles at the minimum level. Imagery providers with more than four tiles at the minimum level are not supported.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._errorEvent = new Event();\n\n  var credit = options.credit;\n  this._credit = typeof credit === \"string\" ? new Credit(credit) : credit;\n\n  this._subdomains = options.subdomains;\n  if (Array.isArray(this._subdomains)) {\n    this._subdomains = this._subdomains.slice();\n  } else if (defined(this._subdomains) && this._subdomains.length > 0) {\n    this._subdomains = this._subdomains.split(\"\");\n  } else {\n    this._subdomains = [\"a\", \"b\", \"c\"];\n  }\n}\n\nfunction requestImage(imageryProvider, col, row, level, request, interval) {\n  var labels = imageryProvider._tileMatrixLabels;\n  var tileMatrix = defined(labels) ? labels[level] : level.toString();\n  var subdomains = imageryProvider._subdomains;\n  var staticDimensions = imageryProvider._dimensions;\n  var dynamicIntervalData = defined(interval) ? interval.data : undefined;\n\n  var resource;\n  if (!imageryProvider._useKvp) {\n    var templateValues = {\n      TileMatrix: tileMatrix,\n      TileRow: row.toString(),\n      TileCol: col.toString(),\n      s: subdomains[(col + row + level) % subdomains.length],\n    };\n\n    resource = imageryProvider._resource.getDerivedResource({\n      request: request,\n    });\n    resource.setTemplateValues(templateValues);\n\n    if (defined(staticDimensions)) {\n      resource.setTemplateValues(staticDimensions);\n    }\n\n    if (defined(dynamicIntervalData)) {\n      resource.setTemplateValues(dynamicIntervalData);\n    }\n  } else {\n    // build KVP request\n    var query = {};\n    query.tilematrix = tileMatrix;\n    query.layer = imageryProvider._layer;\n    query.style = imageryProvider._style;\n    query.tilerow = row;\n    query.tilecol = col;\n    query.tilematrixset = imageryProvider._tileMatrixSetID;\n    query.format = imageryProvider._format;\n\n    if (defined(staticDimensions)) {\n      query = combine(query, staticDimensions);\n    }\n\n    if (defined(dynamicIntervalData)) {\n      query = combine(query, dynamicIntervalData);\n    }\n    resource = imageryProvider._resource.getDerivedResource({\n      queryParameters: query,\n      request: request,\n    });\n  }\n\n  return ImageryProvider.loadImage(imageryProvider, resource);\n}\n\nObject.defineProperties(WebMapTileServiceImageryProvider.prototype, {\n  /**\n   * Gets the URL of the service hosting the imagery.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {String}\n   * @readonly\n   */\n  url: {\n    get: function () {\n      return this._resource.url;\n    },\n  },\n\n  /**\n   * Gets the proxy used by this provider.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {Proxy}\n   * @readonly\n   */\n  proxy: {\n    get: function () {\n      return this._resource.proxy;\n    },\n  },\n\n  /**\n   * Gets the width of each tile, in pixels. This function should\n   * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileWidth: {\n    get: function () {\n      return this._tileWidth;\n    },\n  },\n\n  /**\n   * Gets the height of each tile, in pixels.  This function should\n   * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileHeight: {\n    get: function () {\n      return this._tileHeight;\n    },\n  },\n\n  /**\n   * Gets the maximum level-of-detail that can be requested.  This function should\n   * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  maximumLevel: {\n    get: function () {\n      return this._maximumLevel;\n    },\n  },\n\n  /**\n   * Gets the minimum level-of-detail that can be requested.  This function should\n   * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  minimumLevel: {\n    get: function () {\n      return this._minimumLevel;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.  This function should\n   * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should\n   * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  rectangle: {\n    get: function () {\n      return this._rectangle;\n    },\n  },\n\n  /**\n   * Gets the tile discard policy.  If not undefined, the discard policy is responsible\n   * for filtering out \"missing\" tiles via its shouldDiscardImage function.  If this function\n   * returns undefined, no tiles are filtered.  This function should\n   * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {TileDiscardPolicy}\n   * @readonly\n   */\n  tileDiscardPolicy: {\n    get: function () {\n      return this._tileDiscardPolicy;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets the mime type of images returned by this imagery provider.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {String}\n   * @readonly\n   */\n  format: {\n    get: function () {\n      return this._format;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    value: true,\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this imagery provider is active.  Typically this is used to credit\n   * the source of the imagery.  This function should not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the images provided by this imagery provider\n   * include an alpha channel.  If this property is false, an alpha channel, if present, will\n   * be ignored.  If this property is true, any images without an alpha channel will be treated\n   * as if their alpha is 1.0 everywhere.  When this property is false, memory usage\n   * and texture upload time are reduced.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasAlphaChannel: {\n    get: function () {\n      return true;\n    },\n  },\n  /**\n   * Gets or sets a clock that is used to get keep the time used for time dynamic parameters.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {Clock}\n   */\n  clock: {\n    get: function () {\n      return this._timeDynamicImagery.clock;\n    },\n    set: function (value) {\n      this._timeDynamicImagery.clock = value;\n    },\n  },\n  /**\n   * Gets or sets a time interval collection that is used to get time dynamic parameters. The data of each\n   * TimeInterval is an object containing the keys and values of the properties that are used during\n   * tile requests.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {TimeIntervalCollection}\n   */\n  times: {\n    get: function () {\n      return this._timeDynamicImagery.times;\n    },\n    set: function (value) {\n      this._timeDynamicImagery.times = value;\n    },\n  },\n  /**\n   * Gets or sets an object that contains static dimensions and their values.\n   * @memberof WebMapTileServiceImageryProvider.prototype\n   * @type {Object}\n   */\n  dimensions: {\n    get: function () {\n      return this._dimensions;\n    },\n    set: function (value) {\n      if (this._dimensions !== value) {\n        this._dimensions = value;\n        if (defined(this._reload)) {\n          this._reload();\n        }\n      }\n    },\n  },\n});\n\n/**\n * Gets the credits to be displayed when a given tile is displayed.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level;\n * @returns {Credit[]} The credits to be displayed when the tile is displayed.\n *\n * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.\n */\nWebMapTileServiceImageryProvider.prototype.getTileCredits = function (\n  x,\n  y,\n  level\n) {\n  return undefined;\n};\n\n/**\n * Requests the image for a given tile.  This function should\n * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<Image|Canvas>|undefined} A promise for the image that will resolve when the image is available, or\n *          undefined if there are too many active requests to the server, and the request\n *          should be retried later.  The resolved image may be either an\n *          Image or a Canvas DOM object.\n *\n * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.\n */\nWebMapTileServiceImageryProvider.prototype.requestImage = function (\n  x,\n  y,\n  level,\n  request\n) {\n  var result;\n  var timeDynamicImagery = this._timeDynamicImagery;\n  var currentInterval;\n\n  // Try and load from cache\n  if (defined(timeDynamicImagery)) {\n    currentInterval = timeDynamicImagery.currentInterval;\n    result = timeDynamicImagery.getFromCache(x, y, level, request);\n  }\n\n  // Couldn't load from cache\n  if (!defined(result)) {\n    result = requestImage(this, x, y, level, request, currentInterval);\n  }\n\n  // If we are approaching an interval, preload this tile in the next interval\n  if (defined(result) && defined(timeDynamicImagery)) {\n    timeDynamicImagery.checkApproachingInterval(x, y, level, request);\n  }\n\n  return result;\n};\n\n/**\n * Picking features is not currently supported by this imagery provider, so this function simply returns\n * undefined.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Number} longitude The longitude at which to pick features.\n * @param {Number} latitude  The latitude at which to pick features.\n * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve when the asynchronous\n *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}\n *                   instances.  The array may be empty if no features are found at the given location.\n *                   It may also be undefined if picking is not supported.\n */\nWebMapTileServiceImageryProvider.prototype.pickFeatures = function (\n  x,\n  y,\n  level,\n  longitude,\n  latitude\n) {\n  return undefined;\n};\nexport default WebMapTileServiceImageryProvider;\n"]},"metadata":{},"sourceType":"module"}