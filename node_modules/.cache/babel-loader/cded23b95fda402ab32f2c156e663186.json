{"ast":null,"code":"import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport EllipsoidalOccluder from \"../Core/EllipsoidalOccluder.js\";\nimport Event from \"../Core/Event.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Billboard from \"../Scene/Billboard.js\";\nimport BillboardCollection from \"../Scene/BillboardCollection.js\";\nimport Label from \"../Scene/Label.js\";\nimport LabelCollection from \"../Scene/LabelCollection.js\";\nimport PointPrimitive from \"../Scene/PointPrimitive.js\";\nimport PointPrimitiveCollection from \"../Scene/PointPrimitiveCollection.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport kdbush from \"../ThirdParty/kdbush.js\";\n/**\n * Defines how screen space objects (billboards, points, labels) are clustered.\n *\n * @param {Object} [options] An object with the following properties:\n * @param {Boolean} [options.enabled=false] Whether or not to enable clustering.\n * @param {Number} [options.pixelRange=80] The pixel range to extend the screen space bounding box.\n * @param {Number} [options.minimumClusterSize=2] The minimum number of screen space objects that can be clustered.\n * @param {Boolean} [options.clusterBillboards=true] Whether or not to cluster the billboards of an entity.\n * @param {Boolean} [options.clusterLabels=true] Whether or not to cluster the labels of an entity.\n * @param {Boolean} [options.clusterPoints=true] Whether or not to cluster the points of an entity.\n *\n * @alias EntityCluster\n * @constructor\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Clustering.html|Cesium Sandcastle Clustering Demo}\n */\n\nfunction EntityCluster(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  this._enabled = defaultValue(options.enabled, false);\n  this._pixelRange = defaultValue(options.pixelRange, 80);\n  this._minimumClusterSize = defaultValue(options.minimumClusterSize, 2);\n  this._clusterBillboards = defaultValue(options.clusterBillboards, true);\n  this._clusterLabels = defaultValue(options.clusterLabels, true);\n  this._clusterPoints = defaultValue(options.clusterPoints, true);\n  this._labelCollection = undefined;\n  this._billboardCollection = undefined;\n  this._pointCollection = undefined;\n  this._clusterBillboardCollection = undefined;\n  this._clusterLabelCollection = undefined;\n  this._clusterPointCollection = undefined;\n  this._collectionIndicesByEntity = {};\n  this._unusedLabelIndices = [];\n  this._unusedBillboardIndices = [];\n  this._unusedPointIndices = [];\n  this._previousClusters = [];\n  this._previousHeight = undefined;\n  this._enabledDirty = false;\n  this._clusterDirty = false;\n  this._cluster = undefined;\n  this._removeEventListener = undefined;\n  this._clusterEvent = new Event();\n}\n\nfunction getX(point) {\n  return point.coord.x;\n}\n\nfunction getY(point) {\n  return point.coord.y;\n}\n\nfunction expandBoundingBox(bbox, pixelRange) {\n  bbox.x -= pixelRange;\n  bbox.y -= pixelRange;\n  bbox.width += pixelRange * 2.0;\n  bbox.height += pixelRange * 2.0;\n}\n\nvar labelBoundingBoxScratch = new BoundingRectangle();\n\nfunction getBoundingBox(item, coord, pixelRange, entityCluster, result) {\n  if (defined(item._labelCollection) && entityCluster._clusterLabels) {\n    result = Label.getScreenSpaceBoundingBox(item, coord, result);\n  } else if (defined(item._billboardCollection) && entityCluster._clusterBillboards) {\n    result = Billboard.getScreenSpaceBoundingBox(item, coord, result);\n  } else if (defined(item._pointPrimitiveCollection) && entityCluster._clusterPoints) {\n    result = PointPrimitive.getScreenSpaceBoundingBox(item, coord, result);\n  }\n\n  expandBoundingBox(result, pixelRange);\n\n  if (entityCluster._clusterLabels && !defined(item._labelCollection) && defined(item.id) && hasLabelIndex(entityCluster, item.id.id) && defined(item.id._label)) {\n    var labelIndex = entityCluster._collectionIndicesByEntity[item.id.id].labelIndex;\n\n    var label = entityCluster._labelCollection.get(labelIndex);\n\n    var labelBBox = Label.getScreenSpaceBoundingBox(label, coord, labelBoundingBoxScratch);\n    expandBoundingBox(labelBBox, pixelRange);\n    result = BoundingRectangle.union(result, labelBBox, result);\n  }\n\n  return result;\n}\n\nfunction addNonClusteredItem(item, entityCluster) {\n  item.clusterShow = true;\n\n  if (!defined(item._labelCollection) && defined(item.id) && hasLabelIndex(entityCluster, item.id.id) && defined(item.id._label)) {\n    var labelIndex = entityCluster._collectionIndicesByEntity[item.id.id].labelIndex;\n\n    var label = entityCluster._labelCollection.get(labelIndex);\n\n    label.clusterShow = true;\n  }\n}\n\nfunction addCluster(position, numPoints, ids, entityCluster) {\n  var cluster = {\n    billboard: entityCluster._clusterBillboardCollection.add(),\n    label: entityCluster._clusterLabelCollection.add(),\n    point: entityCluster._clusterPointCollection.add()\n  };\n  cluster.billboard.show = false;\n  cluster.point.show = false;\n  cluster.label.show = true;\n  cluster.label.text = numPoints.toLocaleString();\n  cluster.label.id = ids;\n  cluster.billboard.position = cluster.label.position = cluster.point.position = position;\n\n  entityCluster._clusterEvent.raiseEvent(ids, cluster);\n}\n\nfunction hasLabelIndex(entityCluster, entityId) {\n  return defined(entityCluster) && defined(entityCluster._collectionIndicesByEntity[entityId]) && defined(entityCluster._collectionIndicesByEntity[entityId].labelIndex);\n}\n\nfunction getScreenSpacePositions(collection, points, scene, occluder, entityCluster) {\n  if (!defined(collection)) {\n    return;\n  }\n\n  var length = collection.length;\n\n  for (var i = 0; i < length; ++i) {\n    var item = collection.get(i);\n    item.clusterShow = false;\n\n    if (!item.show || entityCluster._scene.mode === SceneMode.SCENE3D && !occluder.isPointVisible(item.position)) {\n      continue;\n    }\n\n    var canClusterLabels = entityCluster._clusterLabels && defined(item._labelCollection);\n    var canClusterBillboards = entityCluster._clusterBillboards && defined(item.id._billboard);\n    var canClusterPoints = entityCluster._clusterPoints && defined(item.id._point);\n\n    if (canClusterLabels && (canClusterPoints || canClusterBillboards)) {\n      continue;\n    }\n\n    var coord = item.computeScreenSpacePosition(scene);\n\n    if (!defined(coord)) {\n      continue;\n    }\n\n    points.push({\n      index: i,\n      collection: collection,\n      clustered: false,\n      coord: coord\n    });\n  }\n}\n\nvar pointBoundinRectangleScratch = new BoundingRectangle();\nvar totalBoundingRectangleScratch = new BoundingRectangle();\nvar neighborBoundingRectangleScratch = new BoundingRectangle();\n\nfunction createDeclutterCallback(entityCluster) {\n  return function (amount) {\n    if (defined(amount) && amount < 0.05 || !entityCluster.enabled) {\n      return;\n    }\n\n    var scene = entityCluster._scene;\n    var labelCollection = entityCluster._labelCollection;\n    var billboardCollection = entityCluster._billboardCollection;\n    var pointCollection = entityCluster._pointCollection;\n\n    if (!defined(labelCollection) && !defined(billboardCollection) && !defined(pointCollection) || !entityCluster._clusterBillboards && !entityCluster._clusterLabels && !entityCluster._clusterPoints) {\n      return;\n    }\n\n    var clusteredLabelCollection = entityCluster._clusterLabelCollection;\n    var clusteredBillboardCollection = entityCluster._clusterBillboardCollection;\n    var clusteredPointCollection = entityCluster._clusterPointCollection;\n\n    if (defined(clusteredLabelCollection)) {\n      clusteredLabelCollection.removeAll();\n    } else {\n      clusteredLabelCollection = entityCluster._clusterLabelCollection = new LabelCollection({\n        scene: scene\n      });\n    }\n\n    if (defined(clusteredBillboardCollection)) {\n      clusteredBillboardCollection.removeAll();\n    } else {\n      clusteredBillboardCollection = entityCluster._clusterBillboardCollection = new BillboardCollection({\n        scene: scene\n      });\n    }\n\n    if (defined(clusteredPointCollection)) {\n      clusteredPointCollection.removeAll();\n    } else {\n      clusteredPointCollection = entityCluster._clusterPointCollection = new PointPrimitiveCollection();\n    }\n\n    var pixelRange = entityCluster._pixelRange;\n    var minimumClusterSize = entityCluster._minimumClusterSize;\n    var clusters = entityCluster._previousClusters;\n    var newClusters = [];\n    var previousHeight = entityCluster._previousHeight;\n    var currentHeight = scene.camera.positionCartographic.height;\n    var ellipsoid = scene.mapProjection.ellipsoid;\n    var cameraPosition = scene.camera.positionWC;\n    var occluder = new EllipsoidalOccluder(ellipsoid, cameraPosition);\n    var points = [];\n\n    if (entityCluster._clusterLabels) {\n      getScreenSpacePositions(labelCollection, points, scene, occluder, entityCluster);\n    }\n\n    if (entityCluster._clusterBillboards) {\n      getScreenSpacePositions(billboardCollection, points, scene, occluder, entityCluster);\n    }\n\n    if (entityCluster._clusterPoints) {\n      getScreenSpacePositions(pointCollection, points, scene, occluder, entityCluster);\n    }\n\n    var i;\n    var j;\n    var length;\n    var bbox;\n    var neighbors;\n    var neighborLength;\n    var neighborIndex;\n    var neighborPoint;\n    var ids;\n    var numPoints;\n    var collection;\n    var collectionIndex;\n    var index = kdbush(points, getX, getY, 64, Int32Array);\n\n    if (currentHeight < previousHeight) {\n      length = clusters.length;\n\n      for (i = 0; i < length; ++i) {\n        var cluster = clusters[i];\n\n        if (!occluder.isPointVisible(cluster.position)) {\n          continue;\n        }\n\n        var coord = Billboard._computeScreenSpacePosition(Matrix4.IDENTITY, cluster.position, Cartesian3.ZERO, Cartesian2.ZERO, scene);\n\n        if (!defined(coord)) {\n          continue;\n        }\n\n        var factor = 1.0 - currentHeight / previousHeight;\n        var width = cluster.width = cluster.width * factor;\n        var height = cluster.height = cluster.height * factor;\n        width = Math.max(width, cluster.minimumWidth);\n        height = Math.max(height, cluster.minimumHeight);\n        var minX = coord.x - width * 0.5;\n        var minY = coord.y - height * 0.5;\n        var maxX = coord.x + width;\n        var maxY = coord.y + height;\n        neighbors = index.range(minX, minY, maxX, maxY);\n        neighborLength = neighbors.length;\n        numPoints = 0;\n        ids = [];\n\n        for (j = 0; j < neighborLength; ++j) {\n          neighborIndex = neighbors[j];\n          neighborPoint = points[neighborIndex];\n\n          if (!neighborPoint.clustered) {\n            ++numPoints;\n            collection = neighborPoint.collection;\n            collectionIndex = neighborPoint.index;\n            ids.push(collection.get(collectionIndex).id);\n          }\n        }\n\n        if (numPoints >= minimumClusterSize) {\n          addCluster(cluster.position, numPoints, ids, entityCluster);\n          newClusters.push(cluster);\n\n          for (j = 0; j < neighborLength; ++j) {\n            points[neighbors[j]].clustered = true;\n          }\n        }\n      }\n    }\n\n    length = points.length;\n\n    for (i = 0; i < length; ++i) {\n      var point = points[i];\n\n      if (point.clustered) {\n        continue;\n      }\n\n      point.clustered = true;\n      collection = point.collection;\n      collectionIndex = point.index;\n      var item = collection.get(collectionIndex);\n      bbox = getBoundingBox(item, point.coord, pixelRange, entityCluster, pointBoundinRectangleScratch);\n      var totalBBox = BoundingRectangle.clone(bbox, totalBoundingRectangleScratch);\n      neighbors = index.range(bbox.x, bbox.y, bbox.x + bbox.width, bbox.y + bbox.height);\n      neighborLength = neighbors.length;\n      var clusterPosition = Cartesian3.clone(item.position);\n      numPoints = 1;\n      ids = [item.id];\n\n      for (j = 0; j < neighborLength; ++j) {\n        neighborIndex = neighbors[j];\n        neighborPoint = points[neighborIndex];\n\n        if (!neighborPoint.clustered) {\n          var neighborItem = neighborPoint.collection.get(neighborPoint.index);\n          var neighborBBox = getBoundingBox(neighborItem, neighborPoint.coord, pixelRange, entityCluster, neighborBoundingRectangleScratch);\n          Cartesian3.add(neighborItem.position, clusterPosition, clusterPosition);\n          BoundingRectangle.union(totalBBox, neighborBBox, totalBBox);\n          ++numPoints;\n          ids.push(neighborItem.id);\n        }\n      }\n\n      if (numPoints >= minimumClusterSize) {\n        var position = Cartesian3.multiplyByScalar(clusterPosition, 1.0 / numPoints, clusterPosition);\n        addCluster(position, numPoints, ids, entityCluster);\n        newClusters.push({\n          position: position,\n          width: totalBBox.width,\n          height: totalBBox.height,\n          minimumWidth: bbox.width,\n          minimumHeight: bbox.height\n        });\n\n        for (j = 0; j < neighborLength; ++j) {\n          points[neighbors[j]].clustered = true;\n        }\n      } else {\n        addNonClusteredItem(item, entityCluster);\n      }\n    }\n\n    if (clusteredLabelCollection.length === 0) {\n      clusteredLabelCollection.destroy();\n      entityCluster._clusterLabelCollection = undefined;\n    }\n\n    if (clusteredBillboardCollection.length === 0) {\n      clusteredBillboardCollection.destroy();\n      entityCluster._clusterBillboardCollection = undefined;\n    }\n\n    if (clusteredPointCollection.length === 0) {\n      clusteredPointCollection.destroy();\n      entityCluster._clusterPointCollection = undefined;\n    }\n\n    entityCluster._previousClusters = newClusters;\n    entityCluster._previousHeight = currentHeight;\n  };\n}\n\nEntityCluster.prototype._initialize = function (scene) {\n  this._scene = scene;\n  var cluster = createDeclutterCallback(this);\n  this._cluster = cluster;\n  this._removeEventListener = scene.camera.changed.addEventListener(cluster);\n};\n\nObject.defineProperties(EntityCluster.prototype, {\n  /**\n   * Gets or sets whether clustering is enabled.\n   * @memberof EntityCluster.prototype\n   * @type {Boolean}\n   */\n  enabled: {\n    get: function () {\n      return this._enabled;\n    },\n    set: function (value) {\n      this._enabledDirty = value !== this._enabled;\n      this._enabled = value;\n    }\n  },\n\n  /**\n   * Gets or sets the pixel range to extend the screen space bounding box.\n   * @memberof EntityCluster.prototype\n   * @type {Number}\n   */\n  pixelRange: {\n    get: function () {\n      return this._pixelRange;\n    },\n    set: function (value) {\n      this._clusterDirty = this._clusterDirty || value !== this._pixelRange;\n      this._pixelRange = value;\n    }\n  },\n\n  /**\n   * Gets or sets the minimum number of screen space objects that can be clustered.\n   * @memberof EntityCluster.prototype\n   * @type {Number}\n   */\n  minimumClusterSize: {\n    get: function () {\n      return this._minimumClusterSize;\n    },\n    set: function (value) {\n      this._clusterDirty = this._clusterDirty || value !== this._minimumClusterSize;\n      this._minimumClusterSize = value;\n    }\n  },\n\n  /**\n   * Gets the event that will be raised when a new cluster will be displayed. The signature of the event listener is {@link EntityCluster~newClusterCallback}.\n   * @memberof EntityCluster.prototype\n   * @type {Event}\n   */\n  clusterEvent: {\n    get: function () {\n      return this._clusterEvent;\n    }\n  },\n\n  /**\n   * Gets or sets whether clustering billboard entities is enabled.\n   * @memberof EntityCluster.prototype\n   * @type {Boolean}\n   */\n  clusterBillboards: {\n    get: function () {\n      return this._clusterBillboards;\n    },\n    set: function (value) {\n      this._clusterDirty = this._clusterDirty || value !== this._clusterBillboards;\n      this._clusterBillboards = value;\n    }\n  },\n\n  /**\n   * Gets or sets whether clustering labels entities is enabled.\n   * @memberof EntityCluster.prototype\n   * @type {Boolean}\n   */\n  clusterLabels: {\n    get: function () {\n      return this._clusterLabels;\n    },\n    set: function (value) {\n      this._clusterDirty = this._clusterDirty || value !== this._clusterLabels;\n      this._clusterLabels = value;\n    }\n  },\n\n  /**\n   * Gets or sets whether clustering point entities is enabled.\n   * @memberof EntityCluster.prototype\n   * @type {Boolean}\n   */\n  clusterPoints: {\n    get: function () {\n      return this._clusterPoints;\n    },\n    set: function (value) {\n      this._clusterDirty = this._clusterDirty || value !== this._clusterPoints;\n      this._clusterPoints = value;\n    }\n  }\n});\n\nfunction createGetEntity(collectionProperty, CollectionConstructor, unusedIndicesProperty, entityIndexProperty) {\n  return function (entity) {\n    var collection = this[collectionProperty];\n\n    if (!defined(this._collectionIndicesByEntity)) {\n      this._collectionIndicesByEntity = {};\n    }\n\n    var entityIndices = this._collectionIndicesByEntity[entity.id];\n\n    if (!defined(entityIndices)) {\n      entityIndices = this._collectionIndicesByEntity[entity.id] = {\n        billboardIndex: undefined,\n        labelIndex: undefined,\n        pointIndex: undefined\n      };\n    }\n\n    if (defined(collection) && defined(entityIndices[entityIndexProperty])) {\n      return collection.get(entityIndices[entityIndexProperty]);\n    }\n\n    if (!defined(collection)) {\n      collection = this[collectionProperty] = new CollectionConstructor({\n        scene: this._scene\n      });\n    }\n\n    var index;\n    var entityItem;\n    var unusedIndices = this[unusedIndicesProperty];\n\n    if (unusedIndices.length > 0) {\n      index = unusedIndices.pop();\n      entityItem = collection.get(index);\n    } else {\n      entityItem = collection.add();\n      index = collection.length - 1;\n    }\n\n    entityIndices[entityIndexProperty] = index;\n    this._clusterDirty = true;\n    return entityItem;\n  };\n}\n\nfunction removeEntityIndicesIfUnused(entityCluster, entityId) {\n  var indices = entityCluster._collectionIndicesByEntity[entityId];\n\n  if (!defined(indices.billboardIndex) && !defined(indices.labelIndex) && !defined(indices.pointIndex)) {\n    delete entityCluster._collectionIndicesByEntity[entityId];\n  }\n}\n/**\n * Returns a new {@link Label}.\n * @param {Entity} entity The entity that will use the returned {@link Label} for visualization.\n * @returns {Label} The label that will be used to visualize an entity.\n *\n * @private\n */\n\n\nEntityCluster.prototype.getLabel = createGetEntity(\"_labelCollection\", LabelCollection, \"_unusedLabelIndices\", \"labelIndex\");\n/**\n * Removes the {@link Label} associated with an entity so it can be reused by another entity.\n * @param {Entity} entity The entity that will uses the returned {@link Label} for visualization.\n *\n * @private\n */\n\nEntityCluster.prototype.removeLabel = function (entity) {\n  var entityIndices = this._collectionIndicesByEntity && this._collectionIndicesByEntity[entity.id];\n\n  if (!defined(this._labelCollection) || !defined(entityIndices) || !defined(entityIndices.labelIndex)) {\n    return;\n  }\n\n  var index = entityIndices.labelIndex;\n  entityIndices.labelIndex = undefined;\n  removeEntityIndicesIfUnused(this, entity.id);\n\n  var label = this._labelCollection.get(index);\n\n  label.show = false;\n  label.text = \"\";\n  label.id = undefined;\n\n  this._unusedLabelIndices.push(index);\n\n  this._clusterDirty = true;\n};\n/**\n * Returns a new {@link Billboard}.\n * @param {Entity} entity The entity that will use the returned {@link Billboard} for visualization.\n * @returns {Billboard} The label that will be used to visualize an entity.\n *\n * @private\n */\n\n\nEntityCluster.prototype.getBillboard = createGetEntity(\"_billboardCollection\", BillboardCollection, \"_unusedBillboardIndices\", \"billboardIndex\");\n/**\n * Removes the {@link Billboard} associated with an entity so it can be reused by another entity.\n * @param {Entity} entity The entity that will uses the returned {@link Billboard} for visualization.\n *\n * @private\n */\n\nEntityCluster.prototype.removeBillboard = function (entity) {\n  var entityIndices = this._collectionIndicesByEntity && this._collectionIndicesByEntity[entity.id];\n\n  if (!defined(this._billboardCollection) || !defined(entityIndices) || !defined(entityIndices.billboardIndex)) {\n    return;\n  }\n\n  var index = entityIndices.billboardIndex;\n  entityIndices.billboardIndex = undefined;\n  removeEntityIndicesIfUnused(this, entity.id);\n\n  var billboard = this._billboardCollection.get(index);\n\n  billboard.id = undefined;\n  billboard.show = false;\n  billboard.image = undefined;\n\n  this._unusedBillboardIndices.push(index);\n\n  this._clusterDirty = true;\n};\n/**\n * Returns a new {@link Point}.\n * @param {Entity} entity The entity that will use the returned {@link Point} for visualization.\n * @returns {Point} The label that will be used to visualize an entity.\n *\n * @private\n */\n\n\nEntityCluster.prototype.getPoint = createGetEntity(\"_pointCollection\", PointPrimitiveCollection, \"_unusedPointIndices\", \"pointIndex\");\n/**\n * Removes the {@link Point} associated with an entity so it can be reused by another entity.\n * @param {Entity} entity The entity that will uses the returned {@link Point} for visualization.\n *\n * @private\n */\n\nEntityCluster.prototype.removePoint = function (entity) {\n  var entityIndices = this._collectionIndicesByEntity && this._collectionIndicesByEntity[entity.id];\n\n  if (!defined(this._pointCollection) || !defined(entityIndices) || !defined(entityIndices.pointIndex)) {\n    return;\n  }\n\n  var index = entityIndices.pointIndex;\n  entityIndices.pointIndex = undefined;\n  removeEntityIndicesIfUnused(this, entity.id);\n\n  var point = this._pointCollection.get(index);\n\n  point.show = false;\n  point.id = undefined;\n\n  this._unusedPointIndices.push(index);\n\n  this._clusterDirty = true;\n};\n\nfunction disableCollectionClustering(collection) {\n  if (!defined(collection)) {\n    return;\n  }\n\n  var length = collection.length;\n\n  for (var i = 0; i < length; ++i) {\n    collection.get(i).clusterShow = true;\n  }\n}\n\nfunction updateEnable(entityCluster) {\n  if (entityCluster.enabled) {\n    return;\n  }\n\n  if (defined(entityCluster._clusterLabelCollection)) {\n    entityCluster._clusterLabelCollection.destroy();\n  }\n\n  if (defined(entityCluster._clusterBillboardCollection)) {\n    entityCluster._clusterBillboardCollection.destroy();\n  }\n\n  if (defined(entityCluster._clusterPointCollection)) {\n    entityCluster._clusterPointCollection.destroy();\n  }\n\n  entityCluster._clusterLabelCollection = undefined;\n  entityCluster._clusterBillboardCollection = undefined;\n  entityCluster._clusterPointCollection = undefined;\n  disableCollectionClustering(entityCluster._labelCollection);\n  disableCollectionClustering(entityCluster._billboardCollection);\n  disableCollectionClustering(entityCluster._pointCollection);\n}\n/**\n * Gets the draw commands for the clustered billboards/points/labels if enabled, otherwise,\n * queues the draw commands for billboards/points/labels created for entities.\n * @private\n */\n\n\nEntityCluster.prototype.update = function (frameState) {\n  // If clustering is enabled before the label collection is updated,\n  // the glyphs haven't been created so the screen space bounding boxes\n  // are incorrect.\n  var commandList;\n\n  if (defined(this._labelCollection) && this._labelCollection.length > 0 && this._labelCollection.get(0)._glyphs.length === 0) {\n    commandList = frameState.commandList;\n    frameState.commandList = [];\n\n    this._labelCollection.update(frameState);\n\n    frameState.commandList = commandList;\n  } // If clustering is enabled before the billboard collection is updated,\n  // the images haven't been added to the image atlas so the screen space bounding boxes\n  // are incorrect.\n\n\n  if (defined(this._billboardCollection) && this._billboardCollection.length > 0 && !defined(this._billboardCollection.get(0).width)) {\n    commandList = frameState.commandList;\n    frameState.commandList = [];\n\n    this._billboardCollection.update(frameState);\n\n    frameState.commandList = commandList;\n  }\n\n  if (this._enabledDirty) {\n    this._enabledDirty = false;\n    updateEnable(this);\n    this._clusterDirty = true;\n  }\n\n  if (this._clusterDirty) {\n    this._clusterDirty = false;\n\n    this._cluster();\n  }\n\n  if (defined(this._clusterLabelCollection)) {\n    this._clusterLabelCollection.update(frameState);\n  }\n\n  if (defined(this._clusterBillboardCollection)) {\n    this._clusterBillboardCollection.update(frameState);\n  }\n\n  if (defined(this._clusterPointCollection)) {\n    this._clusterPointCollection.update(frameState);\n  }\n\n  if (defined(this._labelCollection)) {\n    this._labelCollection.update(frameState);\n  }\n\n  if (defined(this._billboardCollection)) {\n    this._billboardCollection.update(frameState);\n  }\n\n  if (defined(this._pointCollection)) {\n    this._pointCollection.update(frameState);\n  }\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Unlike other objects that use WebGL resources, this object can be reused. For example, if a data source is removed\n * from a data source collection and added to another.\n * </p>\n */\n\n\nEntityCluster.prototype.destroy = function () {\n  this._labelCollection = this._labelCollection && this._labelCollection.destroy();\n  this._billboardCollection = this._billboardCollection && this._billboardCollection.destroy();\n  this._pointCollection = this._pointCollection && this._pointCollection.destroy();\n  this._clusterLabelCollection = this._clusterLabelCollection && this._clusterLabelCollection.destroy();\n  this._clusterBillboardCollection = this._clusterBillboardCollection && this._clusterBillboardCollection.destroy();\n  this._clusterPointCollection = this._clusterPointCollection && this._clusterPointCollection.destroy();\n\n  if (defined(this._removeEventListener)) {\n    this._removeEventListener();\n\n    this._removeEventListener = undefined;\n  }\n\n  this._labelCollection = undefined;\n  this._billboardCollection = undefined;\n  this._pointCollection = undefined;\n  this._clusterBillboardCollection = undefined;\n  this._clusterLabelCollection = undefined;\n  this._clusterPointCollection = undefined;\n  this._collectionIndicesByEntity = undefined;\n  this._unusedLabelIndices = [];\n  this._unusedBillboardIndices = [];\n  this._unusedPointIndices = [];\n  this._previousClusters = [];\n  this._previousHeight = undefined;\n  this._enabledDirty = false;\n  this._pixelRangeDirty = false;\n  this._minimumClusterSizeDirty = false;\n  return undefined;\n};\n/**\n * A event listener function used to style clusters.\n * @callback EntityCluster~newClusterCallback\n *\n * @param {Entity[]} clusteredEntities An array of the entities contained in the cluster.\n * @param {Object} cluster An object containing billboard, label, and point properties. The values are the same as\n * billboard, label and point entities, but must be the values of the ConstantProperty.\n *\n * @example\n * // The default cluster values.\n * dataSource.clustering.clusterEvent.addEventListener(function(entities, cluster) {\n *     cluster.label.show = true;\n *     cluster.label.text = entities.length.toLocaleString();\n * });\n */\n\n\nexport default EntityCluster;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/DataSources/EntityCluster.js"],"names":["BoundingRectangle","Cartesian2","Cartesian3","defaultValue","defined","EllipsoidalOccluder","Event","Matrix4","Billboard","BillboardCollection","Label","LabelCollection","PointPrimitive","PointPrimitiveCollection","SceneMode","kdbush","EntityCluster","options","EMPTY_OBJECT","_enabled","enabled","_pixelRange","pixelRange","_minimumClusterSize","minimumClusterSize","_clusterBillboards","clusterBillboards","_clusterLabels","clusterLabels","_clusterPoints","clusterPoints","_labelCollection","undefined","_billboardCollection","_pointCollection","_clusterBillboardCollection","_clusterLabelCollection","_clusterPointCollection","_collectionIndicesByEntity","_unusedLabelIndices","_unusedBillboardIndices","_unusedPointIndices","_previousClusters","_previousHeight","_enabledDirty","_clusterDirty","_cluster","_removeEventListener","_clusterEvent","getX","point","coord","x","getY","y","expandBoundingBox","bbox","width","height","labelBoundingBoxScratch","getBoundingBox","item","entityCluster","result","getScreenSpaceBoundingBox","_pointPrimitiveCollection","id","hasLabelIndex","_label","labelIndex","label","get","labelBBox","union","addNonClusteredItem","clusterShow","addCluster","position","numPoints","ids","cluster","billboard","add","show","text","toLocaleString","raiseEvent","entityId","getScreenSpacePositions","collection","points","scene","occluder","length","i","_scene","mode","SCENE3D","isPointVisible","canClusterLabels","canClusterBillboards","_billboard","canClusterPoints","_point","computeScreenSpacePosition","push","index","clustered","pointBoundinRectangleScratch","totalBoundingRectangleScratch","neighborBoundingRectangleScratch","createDeclutterCallback","amount","labelCollection","billboardCollection","pointCollection","clusteredLabelCollection","clusteredBillboardCollection","clusteredPointCollection","removeAll","clusters","newClusters","previousHeight","currentHeight","camera","positionCartographic","ellipsoid","mapProjection","cameraPosition","positionWC","j","neighbors","neighborLength","neighborIndex","neighborPoint","collectionIndex","Int32Array","_computeScreenSpacePosition","IDENTITY","ZERO","factor","Math","max","minimumWidth","minimumHeight","minX","minY","maxX","maxY","range","totalBBox","clone","clusterPosition","neighborItem","neighborBBox","multiplyByScalar","destroy","prototype","_initialize","changed","addEventListener","Object","defineProperties","set","value","clusterEvent","createGetEntity","collectionProperty","CollectionConstructor","unusedIndicesProperty","entityIndexProperty","entity","entityIndices","billboardIndex","pointIndex","entityItem","unusedIndices","pop","removeEntityIndicesIfUnused","indices","getLabel","removeLabel","getBillboard","removeBillboard","image","getPoint","removePoint","disableCollectionClustering","updateEnable","update","frameState","commandList","_glyphs","_pixelRangeDirty","_minimumClusterSizeDirty"],"mappings":"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","sourcesContent":["import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport EllipsoidalOccluder from \"../Core/EllipsoidalOccluder.js\";\nimport Event from \"../Core/Event.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Billboard from \"../Scene/Billboard.js\";\nimport BillboardCollection from \"../Scene/BillboardCollection.js\";\nimport Label from \"../Scene/Label.js\";\nimport LabelCollection from \"../Scene/LabelCollection.js\";\nimport PointPrimitive from \"../Scene/PointPrimitive.js\";\nimport PointPrimitiveCollection from \"../Scene/PointPrimitiveCollection.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport kdbush from \"../ThirdParty/kdbush.js\";\n\n/**\n * Defines how screen space objects (billboards, points, labels) are clustered.\n *\n * @param {Object} [options] An object with the following properties:\n * @param {Boolean} [options.enabled=false] Whether or not to enable clustering.\n * @param {Number} [options.pixelRange=80] The pixel range to extend the screen space bounding box.\n * @param {Number} [options.minimumClusterSize=2] The minimum number of screen space objects that can be clustered.\n * @param {Boolean} [options.clusterBillboards=true] Whether or not to cluster the billboards of an entity.\n * @param {Boolean} [options.clusterLabels=true] Whether or not to cluster the labels of an entity.\n * @param {Boolean} [options.clusterPoints=true] Whether or not to cluster the points of an entity.\n *\n * @alias EntityCluster\n * @constructor\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Clustering.html|Cesium Sandcastle Clustering Demo}\n */\nfunction EntityCluster(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._enabled = defaultValue(options.enabled, false);\n  this._pixelRange = defaultValue(options.pixelRange, 80);\n  this._minimumClusterSize = defaultValue(options.minimumClusterSize, 2);\n  this._clusterBillboards = defaultValue(options.clusterBillboards, true);\n  this._clusterLabels = defaultValue(options.clusterLabels, true);\n  this._clusterPoints = defaultValue(options.clusterPoints, true);\n\n  this._labelCollection = undefined;\n  this._billboardCollection = undefined;\n  this._pointCollection = undefined;\n\n  this._clusterBillboardCollection = undefined;\n  this._clusterLabelCollection = undefined;\n  this._clusterPointCollection = undefined;\n\n  this._collectionIndicesByEntity = {};\n\n  this._unusedLabelIndices = [];\n  this._unusedBillboardIndices = [];\n  this._unusedPointIndices = [];\n\n  this._previousClusters = [];\n  this._previousHeight = undefined;\n\n  this._enabledDirty = false;\n  this._clusterDirty = false;\n\n  this._cluster = undefined;\n  this._removeEventListener = undefined;\n\n  this._clusterEvent = new Event();\n}\n\nfunction getX(point) {\n  return point.coord.x;\n}\n\nfunction getY(point) {\n  return point.coord.y;\n}\n\nfunction expandBoundingBox(bbox, pixelRange) {\n  bbox.x -= pixelRange;\n  bbox.y -= pixelRange;\n  bbox.width += pixelRange * 2.0;\n  bbox.height += pixelRange * 2.0;\n}\n\nvar labelBoundingBoxScratch = new BoundingRectangle();\n\nfunction getBoundingBox(item, coord, pixelRange, entityCluster, result) {\n  if (defined(item._labelCollection) && entityCluster._clusterLabels) {\n    result = Label.getScreenSpaceBoundingBox(item, coord, result);\n  } else if (\n    defined(item._billboardCollection) &&\n    entityCluster._clusterBillboards\n  ) {\n    result = Billboard.getScreenSpaceBoundingBox(item, coord, result);\n  } else if (\n    defined(item._pointPrimitiveCollection) &&\n    entityCluster._clusterPoints\n  ) {\n    result = PointPrimitive.getScreenSpaceBoundingBox(item, coord, result);\n  }\n\n  expandBoundingBox(result, pixelRange);\n\n  if (\n    entityCluster._clusterLabels &&\n    !defined(item._labelCollection) &&\n    defined(item.id) &&\n    hasLabelIndex(entityCluster, item.id.id) &&\n    defined(item.id._label)\n  ) {\n    var labelIndex =\n      entityCluster._collectionIndicesByEntity[item.id.id].labelIndex;\n    var label = entityCluster._labelCollection.get(labelIndex);\n    var labelBBox = Label.getScreenSpaceBoundingBox(\n      label,\n      coord,\n      labelBoundingBoxScratch\n    );\n    expandBoundingBox(labelBBox, pixelRange);\n    result = BoundingRectangle.union(result, labelBBox, result);\n  }\n\n  return result;\n}\n\nfunction addNonClusteredItem(item, entityCluster) {\n  item.clusterShow = true;\n\n  if (\n    !defined(item._labelCollection) &&\n    defined(item.id) &&\n    hasLabelIndex(entityCluster, item.id.id) &&\n    defined(item.id._label)\n  ) {\n    var labelIndex =\n      entityCluster._collectionIndicesByEntity[item.id.id].labelIndex;\n    var label = entityCluster._labelCollection.get(labelIndex);\n    label.clusterShow = true;\n  }\n}\n\nfunction addCluster(position, numPoints, ids, entityCluster) {\n  var cluster = {\n    billboard: entityCluster._clusterBillboardCollection.add(),\n    label: entityCluster._clusterLabelCollection.add(),\n    point: entityCluster._clusterPointCollection.add(),\n  };\n\n  cluster.billboard.show = false;\n  cluster.point.show = false;\n  cluster.label.show = true;\n  cluster.label.text = numPoints.toLocaleString();\n  cluster.label.id = ids;\n  cluster.billboard.position = cluster.label.position = cluster.point.position = position;\n\n  entityCluster._clusterEvent.raiseEvent(ids, cluster);\n}\n\nfunction hasLabelIndex(entityCluster, entityId) {\n  return (\n    defined(entityCluster) &&\n    defined(entityCluster._collectionIndicesByEntity[entityId]) &&\n    defined(entityCluster._collectionIndicesByEntity[entityId].labelIndex)\n  );\n}\n\nfunction getScreenSpacePositions(\n  collection,\n  points,\n  scene,\n  occluder,\n  entityCluster\n) {\n  if (!defined(collection)) {\n    return;\n  }\n\n  var length = collection.length;\n  for (var i = 0; i < length; ++i) {\n    var item = collection.get(i);\n    item.clusterShow = false;\n\n    if (\n      !item.show ||\n      (entityCluster._scene.mode === SceneMode.SCENE3D &&\n        !occluder.isPointVisible(item.position))\n    ) {\n      continue;\n    }\n\n    var canClusterLabels =\n      entityCluster._clusterLabels && defined(item._labelCollection);\n    var canClusterBillboards =\n      entityCluster._clusterBillboards && defined(item.id._billboard);\n    var canClusterPoints =\n      entityCluster._clusterPoints && defined(item.id._point);\n    if (canClusterLabels && (canClusterPoints || canClusterBillboards)) {\n      continue;\n    }\n\n    var coord = item.computeScreenSpacePosition(scene);\n    if (!defined(coord)) {\n      continue;\n    }\n\n    points.push({\n      index: i,\n      collection: collection,\n      clustered: false,\n      coord: coord,\n    });\n  }\n}\n\nvar pointBoundinRectangleScratch = new BoundingRectangle();\nvar totalBoundingRectangleScratch = new BoundingRectangle();\nvar neighborBoundingRectangleScratch = new BoundingRectangle();\n\nfunction createDeclutterCallback(entityCluster) {\n  return function (amount) {\n    if ((defined(amount) && amount < 0.05) || !entityCluster.enabled) {\n      return;\n    }\n\n    var scene = entityCluster._scene;\n\n    var labelCollection = entityCluster._labelCollection;\n    var billboardCollection = entityCluster._billboardCollection;\n    var pointCollection = entityCluster._pointCollection;\n\n    if (\n      (!defined(labelCollection) &&\n        !defined(billboardCollection) &&\n        !defined(pointCollection)) ||\n      (!entityCluster._clusterBillboards &&\n        !entityCluster._clusterLabels &&\n        !entityCluster._clusterPoints)\n    ) {\n      return;\n    }\n\n    var clusteredLabelCollection = entityCluster._clusterLabelCollection;\n    var clusteredBillboardCollection =\n      entityCluster._clusterBillboardCollection;\n    var clusteredPointCollection = entityCluster._clusterPointCollection;\n\n    if (defined(clusteredLabelCollection)) {\n      clusteredLabelCollection.removeAll();\n    } else {\n      clusteredLabelCollection = entityCluster._clusterLabelCollection = new LabelCollection(\n        {\n          scene: scene,\n        }\n      );\n    }\n\n    if (defined(clusteredBillboardCollection)) {\n      clusteredBillboardCollection.removeAll();\n    } else {\n      clusteredBillboardCollection = entityCluster._clusterBillboardCollection = new BillboardCollection(\n        {\n          scene: scene,\n        }\n      );\n    }\n\n    if (defined(clusteredPointCollection)) {\n      clusteredPointCollection.removeAll();\n    } else {\n      clusteredPointCollection = entityCluster._clusterPointCollection = new PointPrimitiveCollection();\n    }\n\n    var pixelRange = entityCluster._pixelRange;\n    var minimumClusterSize = entityCluster._minimumClusterSize;\n\n    var clusters = entityCluster._previousClusters;\n    var newClusters = [];\n\n    var previousHeight = entityCluster._previousHeight;\n    var currentHeight = scene.camera.positionCartographic.height;\n\n    var ellipsoid = scene.mapProjection.ellipsoid;\n    var cameraPosition = scene.camera.positionWC;\n    var occluder = new EllipsoidalOccluder(ellipsoid, cameraPosition);\n\n    var points = [];\n    if (entityCluster._clusterLabels) {\n      getScreenSpacePositions(\n        labelCollection,\n        points,\n        scene,\n        occluder,\n        entityCluster\n      );\n    }\n    if (entityCluster._clusterBillboards) {\n      getScreenSpacePositions(\n        billboardCollection,\n        points,\n        scene,\n        occluder,\n        entityCluster\n      );\n    }\n    if (entityCluster._clusterPoints) {\n      getScreenSpacePositions(\n        pointCollection,\n        points,\n        scene,\n        occluder,\n        entityCluster\n      );\n    }\n\n    var i;\n    var j;\n    var length;\n    var bbox;\n    var neighbors;\n    var neighborLength;\n    var neighborIndex;\n    var neighborPoint;\n    var ids;\n    var numPoints;\n\n    var collection;\n    var collectionIndex;\n\n    var index = kdbush(points, getX, getY, 64, Int32Array);\n\n    if (currentHeight < previousHeight) {\n      length = clusters.length;\n      for (i = 0; i < length; ++i) {\n        var cluster = clusters[i];\n\n        if (!occluder.isPointVisible(cluster.position)) {\n          continue;\n        }\n\n        var coord = Billboard._computeScreenSpacePosition(\n          Matrix4.IDENTITY,\n          cluster.position,\n          Cartesian3.ZERO,\n          Cartesian2.ZERO,\n          scene\n        );\n        if (!defined(coord)) {\n          continue;\n        }\n\n        var factor = 1.0 - currentHeight / previousHeight;\n        var width = (cluster.width = cluster.width * factor);\n        var height = (cluster.height = cluster.height * factor);\n\n        width = Math.max(width, cluster.minimumWidth);\n        height = Math.max(height, cluster.minimumHeight);\n\n        var minX = coord.x - width * 0.5;\n        var minY = coord.y - height * 0.5;\n        var maxX = coord.x + width;\n        var maxY = coord.y + height;\n\n        neighbors = index.range(minX, minY, maxX, maxY);\n        neighborLength = neighbors.length;\n        numPoints = 0;\n        ids = [];\n\n        for (j = 0; j < neighborLength; ++j) {\n          neighborIndex = neighbors[j];\n          neighborPoint = points[neighborIndex];\n          if (!neighborPoint.clustered) {\n            ++numPoints;\n\n            collection = neighborPoint.collection;\n            collectionIndex = neighborPoint.index;\n            ids.push(collection.get(collectionIndex).id);\n          }\n        }\n\n        if (numPoints >= minimumClusterSize) {\n          addCluster(cluster.position, numPoints, ids, entityCluster);\n          newClusters.push(cluster);\n\n          for (j = 0; j < neighborLength; ++j) {\n            points[neighbors[j]].clustered = true;\n          }\n        }\n      }\n    }\n\n    length = points.length;\n    for (i = 0; i < length; ++i) {\n      var point = points[i];\n      if (point.clustered) {\n        continue;\n      }\n\n      point.clustered = true;\n\n      collection = point.collection;\n      collectionIndex = point.index;\n\n      var item = collection.get(collectionIndex);\n      bbox = getBoundingBox(\n        item,\n        point.coord,\n        pixelRange,\n        entityCluster,\n        pointBoundinRectangleScratch\n      );\n      var totalBBox = BoundingRectangle.clone(\n        bbox,\n        totalBoundingRectangleScratch\n      );\n\n      neighbors = index.range(\n        bbox.x,\n        bbox.y,\n        bbox.x + bbox.width,\n        bbox.y + bbox.height\n      );\n      neighborLength = neighbors.length;\n\n      var clusterPosition = Cartesian3.clone(item.position);\n      numPoints = 1;\n      ids = [item.id];\n\n      for (j = 0; j < neighborLength; ++j) {\n        neighborIndex = neighbors[j];\n        neighborPoint = points[neighborIndex];\n        if (!neighborPoint.clustered) {\n          var neighborItem = neighborPoint.collection.get(neighborPoint.index);\n          var neighborBBox = getBoundingBox(\n            neighborItem,\n            neighborPoint.coord,\n            pixelRange,\n            entityCluster,\n            neighborBoundingRectangleScratch\n          );\n\n          Cartesian3.add(\n            neighborItem.position,\n            clusterPosition,\n            clusterPosition\n          );\n\n          BoundingRectangle.union(totalBBox, neighborBBox, totalBBox);\n          ++numPoints;\n\n          ids.push(neighborItem.id);\n        }\n      }\n\n      if (numPoints >= minimumClusterSize) {\n        var position = Cartesian3.multiplyByScalar(\n          clusterPosition,\n          1.0 / numPoints,\n          clusterPosition\n        );\n        addCluster(position, numPoints, ids, entityCluster);\n        newClusters.push({\n          position: position,\n          width: totalBBox.width,\n          height: totalBBox.height,\n          minimumWidth: bbox.width,\n          minimumHeight: bbox.height,\n        });\n\n        for (j = 0; j < neighborLength; ++j) {\n          points[neighbors[j]].clustered = true;\n        }\n      } else {\n        addNonClusteredItem(item, entityCluster);\n      }\n    }\n\n    if (clusteredLabelCollection.length === 0) {\n      clusteredLabelCollection.destroy();\n      entityCluster._clusterLabelCollection = undefined;\n    }\n\n    if (clusteredBillboardCollection.length === 0) {\n      clusteredBillboardCollection.destroy();\n      entityCluster._clusterBillboardCollection = undefined;\n    }\n\n    if (clusteredPointCollection.length === 0) {\n      clusteredPointCollection.destroy();\n      entityCluster._clusterPointCollection = undefined;\n    }\n\n    entityCluster._previousClusters = newClusters;\n    entityCluster._previousHeight = currentHeight;\n  };\n}\n\nEntityCluster.prototype._initialize = function (scene) {\n  this._scene = scene;\n\n  var cluster = createDeclutterCallback(this);\n  this._cluster = cluster;\n  this._removeEventListener = scene.camera.changed.addEventListener(cluster);\n};\n\nObject.defineProperties(EntityCluster.prototype, {\n  /**\n   * Gets or sets whether clustering is enabled.\n   * @memberof EntityCluster.prototype\n   * @type {Boolean}\n   */\n  enabled: {\n    get: function () {\n      return this._enabled;\n    },\n    set: function (value) {\n      this._enabledDirty = value !== this._enabled;\n      this._enabled = value;\n    },\n  },\n  /**\n   * Gets or sets the pixel range to extend the screen space bounding box.\n   * @memberof EntityCluster.prototype\n   * @type {Number}\n   */\n  pixelRange: {\n    get: function () {\n      return this._pixelRange;\n    },\n    set: function (value) {\n      this._clusterDirty = this._clusterDirty || value !== this._pixelRange;\n      this._pixelRange = value;\n    },\n  },\n  /**\n   * Gets or sets the minimum number of screen space objects that can be clustered.\n   * @memberof EntityCluster.prototype\n   * @type {Number}\n   */\n  minimumClusterSize: {\n    get: function () {\n      return this._minimumClusterSize;\n    },\n    set: function (value) {\n      this._clusterDirty =\n        this._clusterDirty || value !== this._minimumClusterSize;\n      this._minimumClusterSize = value;\n    },\n  },\n  /**\n   * Gets the event that will be raised when a new cluster will be displayed. The signature of the event listener is {@link EntityCluster~newClusterCallback}.\n   * @memberof EntityCluster.prototype\n   * @type {Event}\n   */\n  clusterEvent: {\n    get: function () {\n      return this._clusterEvent;\n    },\n  },\n  /**\n   * Gets or sets whether clustering billboard entities is enabled.\n   * @memberof EntityCluster.prototype\n   * @type {Boolean}\n   */\n  clusterBillboards: {\n    get: function () {\n      return this._clusterBillboards;\n    },\n    set: function (value) {\n      this._clusterDirty =\n        this._clusterDirty || value !== this._clusterBillboards;\n      this._clusterBillboards = value;\n    },\n  },\n  /**\n   * Gets or sets whether clustering labels entities is enabled.\n   * @memberof EntityCluster.prototype\n   * @type {Boolean}\n   */\n  clusterLabels: {\n    get: function () {\n      return this._clusterLabels;\n    },\n    set: function (value) {\n      this._clusterDirty = this._clusterDirty || value !== this._clusterLabels;\n      this._clusterLabels = value;\n    },\n  },\n  /**\n   * Gets or sets whether clustering point entities is enabled.\n   * @memberof EntityCluster.prototype\n   * @type {Boolean}\n   */\n  clusterPoints: {\n    get: function () {\n      return this._clusterPoints;\n    },\n    set: function (value) {\n      this._clusterDirty = this._clusterDirty || value !== this._clusterPoints;\n      this._clusterPoints = value;\n    },\n  },\n});\n\nfunction createGetEntity(\n  collectionProperty,\n  CollectionConstructor,\n  unusedIndicesProperty,\n  entityIndexProperty\n) {\n  return function (entity) {\n    var collection = this[collectionProperty];\n\n    if (!defined(this._collectionIndicesByEntity)) {\n      this._collectionIndicesByEntity = {};\n    }\n\n    var entityIndices = this._collectionIndicesByEntity[entity.id];\n\n    if (!defined(entityIndices)) {\n      entityIndices = this._collectionIndicesByEntity[entity.id] = {\n        billboardIndex: undefined,\n        labelIndex: undefined,\n        pointIndex: undefined,\n      };\n    }\n\n    if (defined(collection) && defined(entityIndices[entityIndexProperty])) {\n      return collection.get(entityIndices[entityIndexProperty]);\n    }\n\n    if (!defined(collection)) {\n      collection = this[collectionProperty] = new CollectionConstructor({\n        scene: this._scene,\n      });\n    }\n\n    var index;\n    var entityItem;\n\n    var unusedIndices = this[unusedIndicesProperty];\n    if (unusedIndices.length > 0) {\n      index = unusedIndices.pop();\n      entityItem = collection.get(index);\n    } else {\n      entityItem = collection.add();\n      index = collection.length - 1;\n    }\n\n    entityIndices[entityIndexProperty] = index;\n\n    this._clusterDirty = true;\n\n    return entityItem;\n  };\n}\n\nfunction removeEntityIndicesIfUnused(entityCluster, entityId) {\n  var indices = entityCluster._collectionIndicesByEntity[entityId];\n\n  if (\n    !defined(indices.billboardIndex) &&\n    !defined(indices.labelIndex) &&\n    !defined(indices.pointIndex)\n  ) {\n    delete entityCluster._collectionIndicesByEntity[entityId];\n  }\n}\n\n/**\n * Returns a new {@link Label}.\n * @param {Entity} entity The entity that will use the returned {@link Label} for visualization.\n * @returns {Label} The label that will be used to visualize an entity.\n *\n * @private\n */\nEntityCluster.prototype.getLabel = createGetEntity(\n  \"_labelCollection\",\n  LabelCollection,\n  \"_unusedLabelIndices\",\n  \"labelIndex\"\n);\n\n/**\n * Removes the {@link Label} associated with an entity so it can be reused by another entity.\n * @param {Entity} entity The entity that will uses the returned {@link Label} for visualization.\n *\n * @private\n */\nEntityCluster.prototype.removeLabel = function (entity) {\n  var entityIndices =\n    this._collectionIndicesByEntity &&\n    this._collectionIndicesByEntity[entity.id];\n  if (\n    !defined(this._labelCollection) ||\n    !defined(entityIndices) ||\n    !defined(entityIndices.labelIndex)\n  ) {\n    return;\n  }\n\n  var index = entityIndices.labelIndex;\n  entityIndices.labelIndex = undefined;\n  removeEntityIndicesIfUnused(this, entity.id);\n\n  var label = this._labelCollection.get(index);\n  label.show = false;\n  label.text = \"\";\n  label.id = undefined;\n\n  this._unusedLabelIndices.push(index);\n\n  this._clusterDirty = true;\n};\n\n/**\n * Returns a new {@link Billboard}.\n * @param {Entity} entity The entity that will use the returned {@link Billboard} for visualization.\n * @returns {Billboard} The label that will be used to visualize an entity.\n *\n * @private\n */\nEntityCluster.prototype.getBillboard = createGetEntity(\n  \"_billboardCollection\",\n  BillboardCollection,\n  \"_unusedBillboardIndices\",\n  \"billboardIndex\"\n);\n\n/**\n * Removes the {@link Billboard} associated with an entity so it can be reused by another entity.\n * @param {Entity} entity The entity that will uses the returned {@link Billboard} for visualization.\n *\n * @private\n */\nEntityCluster.prototype.removeBillboard = function (entity) {\n  var entityIndices =\n    this._collectionIndicesByEntity &&\n    this._collectionIndicesByEntity[entity.id];\n  if (\n    !defined(this._billboardCollection) ||\n    !defined(entityIndices) ||\n    !defined(entityIndices.billboardIndex)\n  ) {\n    return;\n  }\n\n  var index = entityIndices.billboardIndex;\n  entityIndices.billboardIndex = undefined;\n  removeEntityIndicesIfUnused(this, entity.id);\n\n  var billboard = this._billboardCollection.get(index);\n  billboard.id = undefined;\n  billboard.show = false;\n  billboard.image = undefined;\n\n  this._unusedBillboardIndices.push(index);\n\n  this._clusterDirty = true;\n};\n\n/**\n * Returns a new {@link Point}.\n * @param {Entity} entity The entity that will use the returned {@link Point} for visualization.\n * @returns {Point} The label that will be used to visualize an entity.\n *\n * @private\n */\nEntityCluster.prototype.getPoint = createGetEntity(\n  \"_pointCollection\",\n  PointPrimitiveCollection,\n  \"_unusedPointIndices\",\n  \"pointIndex\"\n);\n\n/**\n * Removes the {@link Point} associated with an entity so it can be reused by another entity.\n * @param {Entity} entity The entity that will uses the returned {@link Point} for visualization.\n *\n * @private\n */\nEntityCluster.prototype.removePoint = function (entity) {\n  var entityIndices =\n    this._collectionIndicesByEntity &&\n    this._collectionIndicesByEntity[entity.id];\n  if (\n    !defined(this._pointCollection) ||\n    !defined(entityIndices) ||\n    !defined(entityIndices.pointIndex)\n  ) {\n    return;\n  }\n\n  var index = entityIndices.pointIndex;\n  entityIndices.pointIndex = undefined;\n  removeEntityIndicesIfUnused(this, entity.id);\n\n  var point = this._pointCollection.get(index);\n  point.show = false;\n  point.id = undefined;\n\n  this._unusedPointIndices.push(index);\n\n  this._clusterDirty = true;\n};\n\nfunction disableCollectionClustering(collection) {\n  if (!defined(collection)) {\n    return;\n  }\n\n  var length = collection.length;\n  for (var i = 0; i < length; ++i) {\n    collection.get(i).clusterShow = true;\n  }\n}\n\nfunction updateEnable(entityCluster) {\n  if (entityCluster.enabled) {\n    return;\n  }\n\n  if (defined(entityCluster._clusterLabelCollection)) {\n    entityCluster._clusterLabelCollection.destroy();\n  }\n  if (defined(entityCluster._clusterBillboardCollection)) {\n    entityCluster._clusterBillboardCollection.destroy();\n  }\n  if (defined(entityCluster._clusterPointCollection)) {\n    entityCluster._clusterPointCollection.destroy();\n  }\n\n  entityCluster._clusterLabelCollection = undefined;\n  entityCluster._clusterBillboardCollection = undefined;\n  entityCluster._clusterPointCollection = undefined;\n\n  disableCollectionClustering(entityCluster._labelCollection);\n  disableCollectionClustering(entityCluster._billboardCollection);\n  disableCollectionClustering(entityCluster._pointCollection);\n}\n\n/**\n * Gets the draw commands for the clustered billboards/points/labels if enabled, otherwise,\n * queues the draw commands for billboards/points/labels created for entities.\n * @private\n */\nEntityCluster.prototype.update = function (frameState) {\n  // If clustering is enabled before the label collection is updated,\n  // the glyphs haven't been created so the screen space bounding boxes\n  // are incorrect.\n  var commandList;\n  if (\n    defined(this._labelCollection) &&\n    this._labelCollection.length > 0 &&\n    this._labelCollection.get(0)._glyphs.length === 0\n  ) {\n    commandList = frameState.commandList;\n    frameState.commandList = [];\n    this._labelCollection.update(frameState);\n    frameState.commandList = commandList;\n  }\n\n  // If clustering is enabled before the billboard collection is updated,\n  // the images haven't been added to the image atlas so the screen space bounding boxes\n  // are incorrect.\n  if (\n    defined(this._billboardCollection) &&\n    this._billboardCollection.length > 0 &&\n    !defined(this._billboardCollection.get(0).width)\n  ) {\n    commandList = frameState.commandList;\n    frameState.commandList = [];\n    this._billboardCollection.update(frameState);\n    frameState.commandList = commandList;\n  }\n\n  if (this._enabledDirty) {\n    this._enabledDirty = false;\n    updateEnable(this);\n    this._clusterDirty = true;\n  }\n\n  if (this._clusterDirty) {\n    this._clusterDirty = false;\n    this._cluster();\n  }\n\n  if (defined(this._clusterLabelCollection)) {\n    this._clusterLabelCollection.update(frameState);\n  }\n  if (defined(this._clusterBillboardCollection)) {\n    this._clusterBillboardCollection.update(frameState);\n  }\n  if (defined(this._clusterPointCollection)) {\n    this._clusterPointCollection.update(frameState);\n  }\n\n  if (defined(this._labelCollection)) {\n    this._labelCollection.update(frameState);\n  }\n  if (defined(this._billboardCollection)) {\n    this._billboardCollection.update(frameState);\n  }\n  if (defined(this._pointCollection)) {\n    this._pointCollection.update(frameState);\n  }\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Unlike other objects that use WebGL resources, this object can be reused. For example, if a data source is removed\n * from a data source collection and added to another.\n * </p>\n */\nEntityCluster.prototype.destroy = function () {\n  this._labelCollection =\n    this._labelCollection && this._labelCollection.destroy();\n  this._billboardCollection =\n    this._billboardCollection && this._billboardCollection.destroy();\n  this._pointCollection =\n    this._pointCollection && this._pointCollection.destroy();\n\n  this._clusterLabelCollection =\n    this._clusterLabelCollection && this._clusterLabelCollection.destroy();\n  this._clusterBillboardCollection =\n    this._clusterBillboardCollection &&\n    this._clusterBillboardCollection.destroy();\n  this._clusterPointCollection =\n    this._clusterPointCollection && this._clusterPointCollection.destroy();\n\n  if (defined(this._removeEventListener)) {\n    this._removeEventListener();\n    this._removeEventListener = undefined;\n  }\n\n  this._labelCollection = undefined;\n  this._billboardCollection = undefined;\n  this._pointCollection = undefined;\n\n  this._clusterBillboardCollection = undefined;\n  this._clusterLabelCollection = undefined;\n  this._clusterPointCollection = undefined;\n\n  this._collectionIndicesByEntity = undefined;\n\n  this._unusedLabelIndices = [];\n  this._unusedBillboardIndices = [];\n  this._unusedPointIndices = [];\n\n  this._previousClusters = [];\n  this._previousHeight = undefined;\n\n  this._enabledDirty = false;\n  this._pixelRangeDirty = false;\n  this._minimumClusterSizeDirty = false;\n\n  return undefined;\n};\n\n/**\n * A event listener function used to style clusters.\n * @callback EntityCluster~newClusterCallback\n *\n * @param {Entity[]} clusteredEntities An array of the entities contained in the cluster.\n * @param {Object} cluster An object containing billboard, label, and point properties. The values are the same as\n * billboard, label and point entities, but must be the values of the ConstantProperty.\n *\n * @example\n * // The default cluster values.\n * dataSource.clustering.clusterEvent.addEventListener(function(entities, cluster) {\n *     cluster.label.show = true;\n *     cluster.label.text = entities.length.toLocaleString();\n * });\n */\nexport default EntityCluster;\n"]},"metadata":{},"sourceType":"module"}