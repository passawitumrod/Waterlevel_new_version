{"ast":null,"code":"import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GeometryInstanceAttribute from \"../Core/GeometryInstanceAttribute.js\";\nimport GroundPolylineGeometry from \"../Core/GroundPolylineGeometry.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport PolylineShadowVolumeFS from \"../Shaders/PolylineShadowVolumeFS.js\";\nimport PolylineShadowVolumeMorphFS from \"../Shaders/PolylineShadowVolumeMorphFS.js\";\nimport PolylineShadowVolumeMorphVS from \"../Shaders/PolylineShadowVolumeMorphVS.js\";\nimport PolylineShadowVolumeVS from \"../Shaders/PolylineShadowVolumeVS.js\";\nimport when from \"../ThirdParty/when.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport CullFace from \"./CullFace.js\";\nimport PolylineColorAppearance from \"./PolylineColorAppearance.js\";\nimport PolylineMaterialAppearance from \"./PolylineMaterialAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\n/**\n * A GroundPolylinePrimitive represents a polyline draped over the terrain or 3D Tiles in the {@link Scene}.\n * <p>\n * Only to be used with GeometryInstances containing {@link GroundPolylineGeometry}.\n * </p>\n *\n * @alias GroundPolylinePrimitive\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Array|GeometryInstance} [options.geometryInstances] GeometryInstances containing GroundPolylineGeometry\n * @param {Appearance} [options.appearance] The Appearance used to render the polyline. Defaults to a white color {@link Material} on a {@link PolylineMaterialAppearance}.\n * @param {Boolean} [options.show=true] Determines if this primitive will be shown.\n * @param {Boolean} [options.interleave=false] When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.\n * @param {Boolean} [options.releaseGeometryInstances=true] When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n * @param {Boolean} [options.asynchronous=true] Determines if the primitive will be created asynchronously or block until ready. If false initializeTerrainHeights() must be called first.\n * @param {ClassificationType} [options.classificationType=ClassificationType.BOTH] Determines whether terrain, 3D Tiles or both will be classified.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {Boolean} [options.debugShowShadowVolume=false] For debugging only. Determines if the shadow volume for each geometry in the primitive is drawn. Must be <code>true</code> on creation to have effect.\n *\n * @example\n * // 1. Draw a polyline on terrain with a basic color material\n *\n * var instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.GroundPolylineGeometry({\n *      positions : Cesium.Cartesian3.fromDegreesArray([\n *          -112.1340164450331, 36.05494287836128,\n *          -112.08821010582645, 36.097804071380715\n *      ]),\n *      width : 4.0\n *   }),\n *   id : 'object returned when this instance is picked and to get/set per-instance attributes'\n * });\n *\n * scene.groundPrimitives.add(new Cesium.GroundPolylinePrimitive({\n *   geometryInstances : instance,\n *   appearance : new Cesium.PolylineMaterialAppearance()\n * }));\n *\n * // 2. Draw a looped polyline on terrain with per-instance color and a distance display condition.\n * // Distance display conditions for polylines on terrain are based on an approximate terrain height\n * // instead of true terrain height.\n *\n * var instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.GroundPolylineGeometry({\n *      positions : Cesium.Cartesian3.fromDegreesArray([\n *          -112.1340164450331, 36.05494287836128,\n *          -112.08821010582645, 36.097804071380715,\n *          -112.13296079730024, 36.168769146801104\n *      ]),\n *      loop : true,\n *      width : 4.0\n *   }),\n *   attributes : {\n *      color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromCssColorString('green').withAlpha(0.7)),\n *      distanceDisplayCondition : new Cesium.DistanceDisplayConditionGeometryInstanceAttribute(1000, 30000)\n *   },\n *   id : 'object returned when this instance is picked and to get/set per-instance attributes'\n * });\n *\n * scene.groundPrimitives.add(new Cesium.GroundPolylinePrimitive({\n *   geometryInstances : instance,\n *   appearance : new Cesium.PolylineColorAppearance()\n * }));\n */\n\nfunction GroundPolylinePrimitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  /**\n   * The geometry instances rendered with this primitive. This may\n   * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>\n   * is <code>true</code> when the primitive is constructed.\n   * <p>\n   * Changing this property after the primitive is rendered has no effect.\n   * </p>\n   *\n   * @readonly\n   * @type {Array|GeometryInstance}\n   *\n   * @default undefined\n   */\n\n  this.geometryInstances = options.geometryInstances;\n  this._hasPerInstanceColors = true;\n  var appearance = options.appearance;\n\n  if (!defined(appearance)) {\n    appearance = new PolylineMaterialAppearance();\n  }\n  /**\n   * The {@link Appearance} used to shade this primitive. Each geometry\n   * instance is shaded with the same appearance.  Some appearances, like\n   * {@link PolylineColorAppearance} allow giving each instance unique\n   * properties.\n   *\n   * @type Appearance\n   *\n   * @default undefined\n   */\n\n\n  this.appearance = appearance;\n  /**\n   * Determines if the primitive will be shown.  This affects all geometry\n   * instances in the primitive.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n\n  this.show = defaultValue(options.show, true);\n  /**\n   * Determines whether terrain, 3D Tiles or both will be classified.\n   *\n   * @type {ClassificationType}\n   *\n   * @default ClassificationType.BOTH\n   */\n\n  this.classificationType = defaultValue(options.classificationType, ClassificationType.BOTH);\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n\n  this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false); // Shadow volume is shown by removing a discard in the shader, so this isn't toggleable.\n\n  this._debugShowShadowVolume = defaultValue(options.debugShowShadowVolume, false);\n  this._primitiveOptions = {\n    geometryInstances: undefined,\n    appearance: undefined,\n    vertexCacheOptimize: false,\n    interleave: defaultValue(options.interleave, false),\n    releaseGeometryInstances: defaultValue(options.releaseGeometryInstances, true),\n    allowPicking: defaultValue(options.allowPicking, true),\n    asynchronous: defaultValue(options.asynchronous, true),\n    compressVertices: false,\n    _createShaderProgramFunction: undefined,\n    _createCommandsFunction: undefined,\n    _updateAndQueueCommandsFunction: undefined\n  }; // Used when inserting in an OrderedPrimitiveCollection\n\n  this._zIndex = undefined;\n  this._ready = false;\n  this._readyPromise = when.defer();\n  this._primitive = undefined;\n  this._sp = undefined;\n  this._sp2D = undefined;\n  this._spMorph = undefined;\n  this._renderState = getRenderState(false);\n  this._renderState3DTiles = getRenderState(true);\n  this._renderStateMorph = RenderState.fromCache({\n    cull: {\n      enabled: true,\n      face: CullFace.FRONT // Geometry is \"inverted,\" so cull front when materials on volume instead of on terrain (morph)\n\n    },\n    depthTest: {\n      enabled: true\n    },\n    blending: BlendingState.ALPHA_BLEND,\n    depthMask: false\n  });\n}\n\nObject.defineProperties(GroundPolylinePrimitive.prototype, {\n  /**\n   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  interleave: {\n    get: function () {\n      return this._primitiveOptions.interleave;\n    }\n  },\n\n  /**\n   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  releaseGeometryInstances: {\n    get: function () {\n      return this._primitiveOptions.releaseGeometryInstances;\n    }\n  },\n\n  /**\n   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._primitiveOptions.allowPicking;\n    }\n  },\n\n  /**\n   * Determines if the geometry instances will be created and batched on a web worker.\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._primitiveOptions.asynchronous;\n    }\n  },\n\n  /**\n   * Determines if the primitive is complete and ready to render.  If this property is\n   * true, the primitive will be rendered the next time that {@link GroundPolylinePrimitive#update}\n   * is called.\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n\n  /**\n   * Gets a promise that resolves when the primitive is ready to render.\n   * @memberof GroundPolylinePrimitive.prototype\n   * @type {Promise.<GroundPolylinePrimitive>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    }\n  },\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * If true, draws the shadow volume for each geometry in the primitive.\n   * </p>\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  debugShowShadowVolume: {\n    get: function () {\n      return this._debugShowShadowVolume;\n    }\n  }\n});\n/**\n * Initializes the minimum and maximum terrain heights. This only needs to be called if you are creating the\n * GroundPolylinePrimitive synchronously.\n *\n * @returns {Promise} A promise that will resolve once the terrain heights have been loaded.\n */\n\nGroundPolylinePrimitive.initializeTerrainHeights = function () {\n  return ApproximateTerrainHeights.initialize();\n};\n\nfunction createShaderProgram(groundPolylinePrimitive, frameState, appearance) {\n  var context = frameState.context;\n  var primitive = groundPolylinePrimitive._primitive;\n  var attributeLocations = primitive._attributeLocations;\n\n  var vs = primitive._batchTable.getVertexShaderCallback()(PolylineShadowVolumeVS);\n\n  vs = Primitive._appendShowToShader(primitive, vs);\n  vs = Primitive._appendDistanceDisplayConditionToShader(primitive, vs);\n  vs = Primitive._modifyShaderPosition(groundPolylinePrimitive, vs, frameState.scene3DOnly);\n\n  var vsMorph = primitive._batchTable.getVertexShaderCallback()(PolylineShadowVolumeMorphVS);\n\n  vsMorph = Primitive._appendShowToShader(primitive, vsMorph);\n  vsMorph = Primitive._appendDistanceDisplayConditionToShader(primitive, vsMorph);\n  vsMorph = Primitive._modifyShaderPosition(groundPolylinePrimitive, vsMorph, frameState.scene3DOnly); // Access pick color from fragment shader.\n  // Helps with varying budget.\n\n  var fs = primitive._batchTable.getVertexShaderCallback()(PolylineShadowVolumeFS);\n\n  var vsDefines = [\"GLOBE_MINIMUM_ALTITUDE \" + frameState.mapProjection.ellipsoid.minimumRadius.toFixed(1)];\n  var colorDefine = \"\";\n  var materialShaderSource = \"\";\n\n  if (defined(appearance.material)) {\n    materialShaderSource = defined(appearance.material) ? appearance.material.shaderSource : \"\"; // Check for use of v_width and v_polylineAngle in material shader\n    // to determine whether these varyings should be active in the vertex shader.\n\n    if (materialShaderSource.search(/varying\\s+float\\s+v_polylineAngle;/g) !== -1) {\n      vsDefines.push(\"ANGLE_VARYING\");\n    }\n\n    if (materialShaderSource.search(/varying\\s+float\\s+v_width;/g) !== -1) {\n      vsDefines.push(\"WIDTH_VARYING\");\n    }\n  } else {\n    colorDefine = \"PER_INSTANCE_COLOR\";\n  }\n\n  vsDefines.push(colorDefine);\n  var fsDefines = groundPolylinePrimitive.debugShowShadowVolume ? [\"DEBUG_SHOW_VOLUME\", colorDefine] : [colorDefine];\n  var vsColor3D = new ShaderSource({\n    defines: vsDefines,\n    sources: [vs]\n  });\n  var fsColor3D = new ShaderSource({\n    defines: fsDefines,\n    sources: [materialShaderSource, fs]\n  });\n  groundPolylinePrimitive._sp = ShaderProgram.replaceCache({\n    context: context,\n    shaderProgram: primitive._sp,\n    vertexShaderSource: vsColor3D,\n    fragmentShaderSource: fsColor3D,\n    attributeLocations: attributeLocations\n  }); // Derive 2D/CV\n\n  var colorProgram2D = context.shaderCache.getDerivedShaderProgram(groundPolylinePrimitive._sp, \"2dColor\");\n\n  if (!defined(colorProgram2D)) {\n    var vsColor2D = new ShaderSource({\n      defines: vsDefines.concat([\"COLUMBUS_VIEW_2D\"]),\n      sources: [vs]\n    });\n    colorProgram2D = context.shaderCache.createDerivedShaderProgram(groundPolylinePrimitive._sp, \"2dColor\", {\n      context: context,\n      shaderProgram: groundPolylinePrimitive._sp2D,\n      vertexShaderSource: vsColor2D,\n      fragmentShaderSource: fsColor3D,\n      attributeLocations: attributeLocations\n    });\n  }\n\n  groundPolylinePrimitive._sp2D = colorProgram2D; // Derive Morph\n\n  var colorProgramMorph = context.shaderCache.getDerivedShaderProgram(groundPolylinePrimitive._sp, \"MorphColor\");\n\n  if (!defined(colorProgramMorph)) {\n    var vsColorMorph = new ShaderSource({\n      defines: vsDefines.concat([\"MAX_TERRAIN_HEIGHT \" + ApproximateTerrainHeights._defaultMaxTerrainHeight.toFixed(1)]),\n      sources: [vsMorph]\n    });\n    fs = primitive._batchTable.getVertexShaderCallback()(PolylineShadowVolumeMorphFS);\n    var fsColorMorph = new ShaderSource({\n      defines: fsDefines,\n      sources: [materialShaderSource, fs]\n    });\n    colorProgramMorph = context.shaderCache.createDerivedShaderProgram(groundPolylinePrimitive._sp, \"MorphColor\", {\n      context: context,\n      shaderProgram: groundPolylinePrimitive._spMorph,\n      vertexShaderSource: vsColorMorph,\n      fragmentShaderSource: fsColorMorph,\n      attributeLocations: attributeLocations\n    });\n  }\n\n  groundPolylinePrimitive._spMorph = colorProgramMorph;\n}\n\nfunction getRenderState(mask3DTiles) {\n  return RenderState.fromCache({\n    cull: {\n      enabled: true // prevent double-draw. Geometry is \"inverted\" (reversed winding order) so we're drawing backfaces.\n\n    },\n    blending: BlendingState.ALPHA_BLEND,\n    depthMask: false,\n    stencilTest: {\n      enabled: mask3DTiles,\n      frontFunction: StencilFunction.EQUAL,\n      frontOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.KEEP\n      },\n      backFunction: StencilFunction.EQUAL,\n      backOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.KEEP\n      },\n      reference: StencilConstants.CESIUM_3D_TILE_MASK,\n      mask: StencilConstants.CESIUM_3D_TILE_MASK\n    }\n  });\n}\n\nfunction createCommands(groundPolylinePrimitive, appearance, material, translucent, colorCommands, pickCommands) {\n  var primitive = groundPolylinePrimitive._primitive;\n  var length = primitive._va.length;\n  colorCommands.length = length;\n  pickCommands.length = length;\n  var isPolylineColorAppearance = appearance instanceof PolylineColorAppearance;\n  var materialUniforms = isPolylineColorAppearance ? {} : material._uniforms;\n\n  var uniformMap = primitive._batchTable.getUniformMapCallback()(materialUniforms);\n\n  for (var i = 0; i < length; i++) {\n    var vertexArray = primitive._va[i];\n    var command = colorCommands[i];\n\n    if (!defined(command)) {\n      command = colorCommands[i] = new DrawCommand({\n        owner: groundPolylinePrimitive,\n        primitiveType: primitive._primitiveType\n      });\n    }\n\n    command.vertexArray = vertexArray;\n    command.renderState = groundPolylinePrimitive._renderState;\n    command.shaderProgram = groundPolylinePrimitive._sp;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.TERRAIN_CLASSIFICATION;\n    command.pickId = \"czm_batchTable_pickColor(v_endPlaneNormalEcAndBatchId.w)\";\n    var derivedTilesetCommand = DrawCommand.shallowClone(command, command.derivedCommands.tileset);\n    derivedTilesetCommand.renderState = groundPolylinePrimitive._renderState3DTiles;\n    derivedTilesetCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedTilesetCommand; // derive for 2D\n\n    var derived2DCommand = DrawCommand.shallowClone(command, command.derivedCommands.color2D);\n    derived2DCommand.shaderProgram = groundPolylinePrimitive._sp2D;\n    command.derivedCommands.color2D = derived2DCommand;\n    var derived2DTilesetCommand = DrawCommand.shallowClone(derivedTilesetCommand, derivedTilesetCommand.derivedCommands.color2D);\n    derived2DTilesetCommand.shaderProgram = groundPolylinePrimitive._sp2D;\n    derivedTilesetCommand.derivedCommands.color2D = derived2DTilesetCommand; // derive for Morph\n\n    var derivedMorphCommand = DrawCommand.shallowClone(command, command.derivedCommands.colorMorph);\n    derivedMorphCommand.renderState = groundPolylinePrimitive._renderStateMorph;\n    derivedMorphCommand.shaderProgram = groundPolylinePrimitive._spMorph;\n    derivedMorphCommand.pickId = \"czm_batchTable_pickColor(v_batchId)\";\n    command.derivedCommands.colorMorph = derivedMorphCommand;\n  }\n}\n\nfunction updateAndQueueCommand(groundPolylinePrimitive, command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume) {\n  // Use derived appearance command for morph and 2D\n  if (frameState.mode === SceneMode.MORPHING) {\n    command = command.derivedCommands.colorMorph;\n  } else if (frameState.mode !== SceneMode.SCENE3D) {\n    command = command.derivedCommands.color2D;\n  }\n\n  command.modelMatrix = modelMatrix;\n  command.boundingVolume = boundingVolume;\n  command.cull = cull;\n  command.debugShowBoundingVolume = debugShowBoundingVolume;\n  frameState.commandList.push(command);\n}\n\nfunction updateAndQueueCommands(groundPolylinePrimitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume) {\n  var primitive = groundPolylinePrimitive._primitive;\n\n  Primitive._updateBoundingVolumes(primitive, frameState, modelMatrix); // Expected to be identity - GroundPrimitives don't support other model matrices\n\n\n  var boundingSpheres;\n\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingSpheres = primitive._boundingSphereWC;\n  } else if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n    boundingSpheres = primitive._boundingSphereCV;\n  } else if (frameState.mode === SceneMode.SCENE2D && defined(primitive._boundingSphere2D)) {\n    boundingSpheres = primitive._boundingSphere2D;\n  } else if (defined(primitive._boundingSphereMorph)) {\n    boundingSpheres = primitive._boundingSphereMorph;\n  }\n\n  var morphing = frameState.mode === SceneMode.MORPHING;\n  var classificationType = groundPolylinePrimitive.classificationType;\n  var queueTerrainCommands = classificationType !== ClassificationType.CESIUM_3D_TILE;\n  var queue3DTilesCommands = classificationType !== ClassificationType.TERRAIN && !morphing;\n  var command;\n  var passes = frameState.passes;\n\n  if (passes.render || passes.pick && primitive.allowPicking) {\n    var colorLength = colorCommands.length;\n\n    for (var j = 0; j < colorLength; ++j) {\n      var boundingVolume = boundingSpheres[j];\n\n      if (queueTerrainCommands) {\n        command = colorCommands[j];\n        updateAndQueueCommand(groundPolylinePrimitive, command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume);\n      }\n\n      if (queue3DTilesCommands) {\n        command = colorCommands[j].derivedCommands.tileset;\n        updateAndQueueCommand(groundPolylinePrimitive, command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume);\n      }\n    }\n  }\n}\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} For synchronous GroundPolylinePrimitives, you must call GroundPolylinePrimitives.initializeTerrainHeights() and wait for the returned promise to resolve.\n * @exception {DeveloperError} All GeometryInstances must have color attributes to use PolylineColorAppearance with GroundPolylinePrimitive.\n */\n\n\nGroundPolylinePrimitive.prototype.update = function (frameState) {\n  if (!defined(this._primitive) && !defined(this.geometryInstances)) {\n    return;\n  }\n\n  if (!ApproximateTerrainHeights.initialized) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!this.asynchronous) {\n      throw new DeveloperError(\"For synchronous GroundPolylinePrimitives, you must call GroundPolylinePrimitives.initializeTerrainHeights() and wait for the returned promise to resolve.\");\n    } //>>includeEnd('debug');\n\n\n    GroundPolylinePrimitive.initializeTerrainHeights();\n    return;\n  }\n\n  var i;\n  var that = this;\n  var primitiveOptions = this._primitiveOptions;\n\n  if (!defined(this._primitive)) {\n    var geometryInstances = Array.isArray(this.geometryInstances) ? this.geometryInstances : [this.geometryInstances];\n    var geometryInstancesLength = geometryInstances.length;\n    var groundInstances = new Array(geometryInstancesLength);\n    var attributes; // Check if each instance has a color attribute.\n\n    for (i = 0; i < geometryInstancesLength; ++i) {\n      attributes = geometryInstances[i].attributes;\n\n      if (!defined(attributes) || !defined(attributes.color)) {\n        this._hasPerInstanceColors = false;\n        break;\n      }\n    }\n\n    for (i = 0; i < geometryInstancesLength; ++i) {\n      var geometryInstance = geometryInstances[i];\n      attributes = {};\n      var instanceAttributes = geometryInstance.attributes;\n\n      for (var attributeKey in instanceAttributes) {\n        if (instanceAttributes.hasOwnProperty(attributeKey)) {\n          attributes[attributeKey] = instanceAttributes[attributeKey];\n        }\n      } // Automatically create line width attribute if not already given\n\n\n      if (!defined(attributes.width)) {\n        attributes.width = new GeometryInstanceAttribute({\n          componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n          componentsPerAttribute: 1.0,\n          value: [geometryInstance.geometry.width]\n        });\n      } // Update each geometry for framestate.scene3DOnly = true and projection\n\n\n      geometryInstance.geometry._scene3DOnly = frameState.scene3DOnly;\n      GroundPolylineGeometry.setProjectionAndEllipsoid(geometryInstance.geometry, frameState.mapProjection);\n      groundInstances[i] = new GeometryInstance({\n        geometry: geometryInstance.geometry,\n        attributes: attributes,\n        id: geometryInstance.id,\n        pickPrimitive: that\n      });\n    }\n\n    primitiveOptions.geometryInstances = groundInstances;\n    primitiveOptions.appearance = this.appearance;\n\n    primitiveOptions._createShaderProgramFunction = function (primitive, frameState, appearance) {\n      createShaderProgram(that, frameState, appearance);\n    };\n\n    primitiveOptions._createCommandsFunction = function (primitive, appearance, material, translucent, twoPasses, colorCommands, pickCommands) {\n      createCommands(that, appearance, material, translucent, colorCommands, pickCommands);\n    };\n\n    primitiveOptions._updateAndQueueCommandsFunction = function (primitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {\n      updateAndQueueCommands(that, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume);\n    };\n\n    this._primitive = new Primitive(primitiveOptions);\n\n    this._primitive.readyPromise.then(function (primitive) {\n      that._ready = true;\n\n      if (that.releaseGeometryInstances) {\n        that.geometryInstances = undefined;\n      }\n\n      var error = primitive._error;\n\n      if (!defined(error)) {\n        that._readyPromise.resolve(that);\n      } else {\n        that._readyPromise.reject(error);\n      }\n    });\n  }\n\n  if (this.appearance instanceof PolylineColorAppearance && !this._hasPerInstanceColors) {\n    throw new DeveloperError(\"All GeometryInstances must have color attributes to use PolylineColorAppearance with GroundPolylinePrimitive.\");\n  }\n\n  this._primitive.appearance = this.appearance;\n  this._primitive.show = this.show;\n  this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume;\n\n  this._primitive.update(frameState);\n};\n/**\n * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.\n *\n * @param {*} id The id of the {@link GeometryInstance}.\n * @returns {Object} The typed array in the attribute's format or undefined if the is no instance with id.\n *\n * @exception {DeveloperError} must call update before calling getGeometryInstanceAttributes.\n *\n * @example\n * var attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);\n */\n\n\nGroundPolylinePrimitive.prototype.getGeometryInstanceAttributes = function (id) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(this._primitive)) {\n    throw new DeveloperError(\"must call update before calling getGeometryInstanceAttributes\");\n  } //>>includeEnd('debug');\n\n\n  return this._primitive.getGeometryInstanceAttributes(id);\n};\n/**\n * Checks if the given Scene supports GroundPolylinePrimitives.\n * GroundPolylinePrimitives require support for the WEBGL_depth_texture extension.\n *\n * @param {Scene} scene The current scene.\n * @returns {Boolean} Whether or not the current scene supports GroundPolylinePrimitives.\n */\n\n\nGroundPolylinePrimitive.isSupported = function (scene) {\n  return scene.frameState.context.depthTexture;\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see GroundPolylinePrimitive#destroy\n */\n\n\nGroundPolylinePrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * e = e && e.destroy();\n *\n * @see GroundPolylinePrimitive#isDestroyed\n */\n\n\nGroundPolylinePrimitive.prototype.destroy = function () {\n  this._primitive = this._primitive && this._primitive.destroy();\n  this._sp = this._sp && this._sp.destroy(); // Derived programs, destroyed above if they existed.\n\n  this._sp2D = undefined;\n  this._spMorph = undefined;\n  return destroyObject(this);\n};\n\nexport default GroundPolylinePrimitive;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Scene/GroundPolylinePrimitive.js"],"names":["ApproximateTerrainHeights","ComponentDatatype","defaultValue","defined","destroyObject","DeveloperError","GeometryInstance","GeometryInstanceAttribute","GroundPolylineGeometry","DrawCommand","Pass","RenderState","ShaderProgram","ShaderSource","PolylineShadowVolumeFS","PolylineShadowVolumeMorphFS","PolylineShadowVolumeMorphVS","PolylineShadowVolumeVS","when","BlendingState","ClassificationType","CullFace","PolylineColorAppearance","PolylineMaterialAppearance","Primitive","SceneMode","StencilConstants","StencilFunction","StencilOperation","GroundPolylinePrimitive","options","EMPTY_OBJECT","geometryInstances","_hasPerInstanceColors","appearance","show","classificationType","BOTH","debugShowBoundingVolume","_debugShowShadowVolume","debugShowShadowVolume","_primitiveOptions","undefined","vertexCacheOptimize","interleave","releaseGeometryInstances","allowPicking","asynchronous","compressVertices","_createShaderProgramFunction","_createCommandsFunction","_updateAndQueueCommandsFunction","_zIndex","_ready","_readyPromise","defer","_primitive","_sp","_sp2D","_spMorph","_renderState","getRenderState","_renderState3DTiles","_renderStateMorph","fromCache","cull","enabled","face","FRONT","depthTest","blending","ALPHA_BLEND","depthMask","Object","defineProperties","prototype","get","ready","readyPromise","promise","initializeTerrainHeights","initialize","createShaderProgram","groundPolylinePrimitive","frameState","context","primitive","attributeLocations","_attributeLocations","vs","_batchTable","getVertexShaderCallback","_appendShowToShader","_appendDistanceDisplayConditionToShader","_modifyShaderPosition","scene3DOnly","vsMorph","fs","vsDefines","mapProjection","ellipsoid","minimumRadius","toFixed","colorDefine","materialShaderSource","material","shaderSource","search","push","fsDefines","vsColor3D","defines","sources","fsColor3D","replaceCache","shaderProgram","vertexShaderSource","fragmentShaderSource","colorProgram2D","shaderCache","getDerivedShaderProgram","vsColor2D","concat","createDerivedShaderProgram","colorProgramMorph","vsColorMorph","_defaultMaxTerrainHeight","fsColorMorph","mask3DTiles","stencilTest","frontFunction","EQUAL","frontOperation","fail","KEEP","zFail","zPass","backFunction","backOperation","reference","CESIUM_3D_TILE_MASK","mask","createCommands","translucent","colorCommands","pickCommands","length","_va","isPolylineColorAppearance","materialUniforms","_uniforms","uniformMap","getUniformMapCallback","i","vertexArray","command","owner","primitiveType","_primitiveType","renderState","pass","TERRAIN_CLASSIFICATION","pickId","derivedTilesetCommand","shallowClone","derivedCommands","tileset","CESIUM_3D_TILE_CLASSIFICATION","derived2DCommand","color2D","derived2DTilesetCommand","derivedMorphCommand","colorMorph","updateAndQueueCommand","modelMatrix","boundingVolume","mode","MORPHING","SCENE3D","commandList","updateAndQueueCommands","_updateBoundingVolumes","boundingSpheres","_boundingSphereWC","COLUMBUS_VIEW","_boundingSphereCV","SCENE2D","_boundingSphere2D","_boundingSphereMorph","morphing","queueTerrainCommands","CESIUM_3D_TILE","queue3DTilesCommands","TERRAIN","passes","render","pick","colorLength","j","update","initialized","that","primitiveOptions","Array","isArray","geometryInstancesLength","groundInstances","attributes","color","geometryInstance","instanceAttributes","attributeKey","hasOwnProperty","width","componentDatatype","UNSIGNED_BYTE","componentsPerAttribute","value","geometry","_scene3DOnly","setProjectionAndEllipsoid","id","pickPrimitive","twoPasses","then","error","_error","resolve","reject","getGeometryInstanceAttributes","isSupported","scene","depthTexture","isDestroyed","destroy"],"mappings":"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","sourcesContent":["import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GeometryInstanceAttribute from \"../Core/GeometryInstanceAttribute.js\";\nimport GroundPolylineGeometry from \"../Core/GroundPolylineGeometry.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport PolylineShadowVolumeFS from \"../Shaders/PolylineShadowVolumeFS.js\";\nimport PolylineShadowVolumeMorphFS from \"../Shaders/PolylineShadowVolumeMorphFS.js\";\nimport PolylineShadowVolumeMorphVS from \"../Shaders/PolylineShadowVolumeMorphVS.js\";\nimport PolylineShadowVolumeVS from \"../Shaders/PolylineShadowVolumeVS.js\";\nimport when from \"../ThirdParty/when.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport CullFace from \"./CullFace.js\";\nimport PolylineColorAppearance from \"./PolylineColorAppearance.js\";\nimport PolylineMaterialAppearance from \"./PolylineMaterialAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\n\n/**\n * A GroundPolylinePrimitive represents a polyline draped over the terrain or 3D Tiles in the {@link Scene}.\n * <p>\n * Only to be used with GeometryInstances containing {@link GroundPolylineGeometry}.\n * </p>\n *\n * @alias GroundPolylinePrimitive\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Array|GeometryInstance} [options.geometryInstances] GeometryInstances containing GroundPolylineGeometry\n * @param {Appearance} [options.appearance] The Appearance used to render the polyline. Defaults to a white color {@link Material} on a {@link PolylineMaterialAppearance}.\n * @param {Boolean} [options.show=true] Determines if this primitive will be shown.\n * @param {Boolean} [options.interleave=false] When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.\n * @param {Boolean} [options.releaseGeometryInstances=true] When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n * @param {Boolean} [options.asynchronous=true] Determines if the primitive will be created asynchronously or block until ready. If false initializeTerrainHeights() must be called first.\n * @param {ClassificationType} [options.classificationType=ClassificationType.BOTH] Determines whether terrain, 3D Tiles or both will be classified.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {Boolean} [options.debugShowShadowVolume=false] For debugging only. Determines if the shadow volume for each geometry in the primitive is drawn. Must be <code>true</code> on creation to have effect.\n *\n * @example\n * // 1. Draw a polyline on terrain with a basic color material\n *\n * var instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.GroundPolylineGeometry({\n *      positions : Cesium.Cartesian3.fromDegreesArray([\n *          -112.1340164450331, 36.05494287836128,\n *          -112.08821010582645, 36.097804071380715\n *      ]),\n *      width : 4.0\n *   }),\n *   id : 'object returned when this instance is picked and to get/set per-instance attributes'\n * });\n *\n * scene.groundPrimitives.add(new Cesium.GroundPolylinePrimitive({\n *   geometryInstances : instance,\n *   appearance : new Cesium.PolylineMaterialAppearance()\n * }));\n *\n * // 2. Draw a looped polyline on terrain with per-instance color and a distance display condition.\n * // Distance display conditions for polylines on terrain are based on an approximate terrain height\n * // instead of true terrain height.\n *\n * var instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.GroundPolylineGeometry({\n *      positions : Cesium.Cartesian3.fromDegreesArray([\n *          -112.1340164450331, 36.05494287836128,\n *          -112.08821010582645, 36.097804071380715,\n *          -112.13296079730024, 36.168769146801104\n *      ]),\n *      loop : true,\n *      width : 4.0\n *   }),\n *   attributes : {\n *      color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromCssColorString('green').withAlpha(0.7)),\n *      distanceDisplayCondition : new Cesium.DistanceDisplayConditionGeometryInstanceAttribute(1000, 30000)\n *   },\n *   id : 'object returned when this instance is picked and to get/set per-instance attributes'\n * });\n *\n * scene.groundPrimitives.add(new Cesium.GroundPolylinePrimitive({\n *   geometryInstances : instance,\n *   appearance : new Cesium.PolylineColorAppearance()\n * }));\n */\nfunction GroundPolylinePrimitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The geometry instances rendered with this primitive. This may\n   * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>\n   * is <code>true</code> when the primitive is constructed.\n   * <p>\n   * Changing this property after the primitive is rendered has no effect.\n   * </p>\n   *\n   * @readonly\n   * @type {Array|GeometryInstance}\n   *\n   * @default undefined\n   */\n  this.geometryInstances = options.geometryInstances;\n  this._hasPerInstanceColors = true;\n\n  var appearance = options.appearance;\n  if (!defined(appearance)) {\n    appearance = new PolylineMaterialAppearance();\n  }\n  /**\n   * The {@link Appearance} used to shade this primitive. Each geometry\n   * instance is shaded with the same appearance.  Some appearances, like\n   * {@link PolylineColorAppearance} allow giving each instance unique\n   * properties.\n   *\n   * @type Appearance\n   *\n   * @default undefined\n   */\n  this.appearance = appearance;\n\n  /**\n   * Determines if the primitive will be shown.  This affects all geometry\n   * instances in the primitive.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  /**\n   * Determines whether terrain, 3D Tiles or both will be classified.\n   *\n   * @type {ClassificationType}\n   *\n   * @default ClassificationType.BOTH\n   */\n  this.classificationType = defaultValue(\n    options.classificationType,\n    ClassificationType.BOTH\n  );\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false\n  );\n\n  // Shadow volume is shown by removing a discard in the shader, so this isn't toggleable.\n  this._debugShowShadowVolume = defaultValue(\n    options.debugShowShadowVolume,\n    false\n  );\n\n  this._primitiveOptions = {\n    geometryInstances: undefined,\n    appearance: undefined,\n    vertexCacheOptimize: false,\n    interleave: defaultValue(options.interleave, false),\n    releaseGeometryInstances: defaultValue(\n      options.releaseGeometryInstances,\n      true\n    ),\n    allowPicking: defaultValue(options.allowPicking, true),\n    asynchronous: defaultValue(options.asynchronous, true),\n    compressVertices: false,\n    _createShaderProgramFunction: undefined,\n    _createCommandsFunction: undefined,\n    _updateAndQueueCommandsFunction: undefined,\n  };\n\n  // Used when inserting in an OrderedPrimitiveCollection\n  this._zIndex = undefined;\n\n  this._ready = false;\n  this._readyPromise = when.defer();\n\n  this._primitive = undefined;\n\n  this._sp = undefined;\n  this._sp2D = undefined;\n  this._spMorph = undefined;\n\n  this._renderState = getRenderState(false);\n  this._renderState3DTiles = getRenderState(true);\n\n  this._renderStateMorph = RenderState.fromCache({\n    cull: {\n      enabled: true,\n      face: CullFace.FRONT, // Geometry is \"inverted,\" so cull front when materials on volume instead of on terrain (morph)\n    },\n    depthTest: {\n      enabled: true,\n    },\n    blending: BlendingState.ALPHA_BLEND,\n    depthMask: false,\n  });\n}\n\nObject.defineProperties(GroundPolylinePrimitive.prototype, {\n  /**\n   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  interleave: {\n    get: function () {\n      return this._primitiveOptions.interleave;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  releaseGeometryInstances: {\n    get: function () {\n      return this._primitiveOptions.releaseGeometryInstances;\n    },\n  },\n\n  /**\n   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._primitiveOptions.allowPicking;\n    },\n  },\n\n  /**\n   * Determines if the geometry instances will be created and batched on a web worker.\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._primitiveOptions.asynchronous;\n    },\n  },\n\n  /**\n   * Determines if the primitive is complete and ready to render.  If this property is\n   * true, the primitive will be rendered the next time that {@link GroundPolylinePrimitive#update}\n   * is called.\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves when the primitive is ready to render.\n   * @memberof GroundPolylinePrimitive.prototype\n   * @type {Promise.<GroundPolylinePrimitive>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * If true, draws the shadow volume for each geometry in the primitive.\n   * </p>\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  debugShowShadowVolume: {\n    get: function () {\n      return this._debugShowShadowVolume;\n    },\n  },\n});\n\n/**\n * Initializes the minimum and maximum terrain heights. This only needs to be called if you are creating the\n * GroundPolylinePrimitive synchronously.\n *\n * @returns {Promise} A promise that will resolve once the terrain heights have been loaded.\n */\nGroundPolylinePrimitive.initializeTerrainHeights = function () {\n  return ApproximateTerrainHeights.initialize();\n};\n\nfunction createShaderProgram(groundPolylinePrimitive, frameState, appearance) {\n  var context = frameState.context;\n  var primitive = groundPolylinePrimitive._primitive;\n  var attributeLocations = primitive._attributeLocations;\n\n  var vs = primitive._batchTable.getVertexShaderCallback()(\n    PolylineShadowVolumeVS\n  );\n  vs = Primitive._appendShowToShader(primitive, vs);\n  vs = Primitive._appendDistanceDisplayConditionToShader(primitive, vs);\n  vs = Primitive._modifyShaderPosition(\n    groundPolylinePrimitive,\n    vs,\n    frameState.scene3DOnly\n  );\n\n  var vsMorph = primitive._batchTable.getVertexShaderCallback()(\n    PolylineShadowVolumeMorphVS\n  );\n  vsMorph = Primitive._appendShowToShader(primitive, vsMorph);\n  vsMorph = Primitive._appendDistanceDisplayConditionToShader(\n    primitive,\n    vsMorph\n  );\n  vsMorph = Primitive._modifyShaderPosition(\n    groundPolylinePrimitive,\n    vsMorph,\n    frameState.scene3DOnly\n  );\n\n  // Access pick color from fragment shader.\n  // Helps with varying budget.\n  var fs = primitive._batchTable.getVertexShaderCallback()(\n    PolylineShadowVolumeFS\n  );\n\n  var vsDefines = [\n    \"GLOBE_MINIMUM_ALTITUDE \" +\n      frameState.mapProjection.ellipsoid.minimumRadius.toFixed(1),\n  ];\n  var colorDefine = \"\";\n  var materialShaderSource = \"\";\n  if (defined(appearance.material)) {\n    materialShaderSource = defined(appearance.material)\n      ? appearance.material.shaderSource\n      : \"\";\n\n    // Check for use of v_width and v_polylineAngle in material shader\n    // to determine whether these varyings should be active in the vertex shader.\n    if (\n      materialShaderSource.search(/varying\\s+float\\s+v_polylineAngle;/g) !== -1\n    ) {\n      vsDefines.push(\"ANGLE_VARYING\");\n    }\n    if (materialShaderSource.search(/varying\\s+float\\s+v_width;/g) !== -1) {\n      vsDefines.push(\"WIDTH_VARYING\");\n    }\n  } else {\n    colorDefine = \"PER_INSTANCE_COLOR\";\n  }\n\n  vsDefines.push(colorDefine);\n  var fsDefines = groundPolylinePrimitive.debugShowShadowVolume\n    ? [\"DEBUG_SHOW_VOLUME\", colorDefine]\n    : [colorDefine];\n\n  var vsColor3D = new ShaderSource({\n    defines: vsDefines,\n    sources: [vs],\n  });\n  var fsColor3D = new ShaderSource({\n    defines: fsDefines,\n    sources: [materialShaderSource, fs],\n  });\n  groundPolylinePrimitive._sp = ShaderProgram.replaceCache({\n    context: context,\n    shaderProgram: primitive._sp,\n    vertexShaderSource: vsColor3D,\n    fragmentShaderSource: fsColor3D,\n    attributeLocations: attributeLocations,\n  });\n\n  // Derive 2D/CV\n  var colorProgram2D = context.shaderCache.getDerivedShaderProgram(\n    groundPolylinePrimitive._sp,\n    \"2dColor\"\n  );\n  if (!defined(colorProgram2D)) {\n    var vsColor2D = new ShaderSource({\n      defines: vsDefines.concat([\"COLUMBUS_VIEW_2D\"]),\n      sources: [vs],\n    });\n    colorProgram2D = context.shaderCache.createDerivedShaderProgram(\n      groundPolylinePrimitive._sp,\n      \"2dColor\",\n      {\n        context: context,\n        shaderProgram: groundPolylinePrimitive._sp2D,\n        vertexShaderSource: vsColor2D,\n        fragmentShaderSource: fsColor3D,\n        attributeLocations: attributeLocations,\n      }\n    );\n  }\n  groundPolylinePrimitive._sp2D = colorProgram2D;\n\n  // Derive Morph\n  var colorProgramMorph = context.shaderCache.getDerivedShaderProgram(\n    groundPolylinePrimitive._sp,\n    \"MorphColor\"\n  );\n  if (!defined(colorProgramMorph)) {\n    var vsColorMorph = new ShaderSource({\n      defines: vsDefines.concat([\n        \"MAX_TERRAIN_HEIGHT \" +\n          ApproximateTerrainHeights._defaultMaxTerrainHeight.toFixed(1),\n      ]),\n      sources: [vsMorph],\n    });\n\n    fs = primitive._batchTable.getVertexShaderCallback()(\n      PolylineShadowVolumeMorphFS\n    );\n    var fsColorMorph = new ShaderSource({\n      defines: fsDefines,\n      sources: [materialShaderSource, fs],\n    });\n    colorProgramMorph = context.shaderCache.createDerivedShaderProgram(\n      groundPolylinePrimitive._sp,\n      \"MorphColor\",\n      {\n        context: context,\n        shaderProgram: groundPolylinePrimitive._spMorph,\n        vertexShaderSource: vsColorMorph,\n        fragmentShaderSource: fsColorMorph,\n        attributeLocations: attributeLocations,\n      }\n    );\n  }\n  groundPolylinePrimitive._spMorph = colorProgramMorph;\n}\n\nfunction getRenderState(mask3DTiles) {\n  return RenderState.fromCache({\n    cull: {\n      enabled: true, // prevent double-draw. Geometry is \"inverted\" (reversed winding order) so we're drawing backfaces.\n    },\n    blending: BlendingState.ALPHA_BLEND,\n    depthMask: false,\n    stencilTest: {\n      enabled: mask3DTiles,\n      frontFunction: StencilFunction.EQUAL,\n      frontOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.KEEP,\n      },\n      backFunction: StencilFunction.EQUAL,\n      backOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.KEEP,\n      },\n      reference: StencilConstants.CESIUM_3D_TILE_MASK,\n      mask: StencilConstants.CESIUM_3D_TILE_MASK,\n    },\n  });\n}\n\nfunction createCommands(\n  groundPolylinePrimitive,\n  appearance,\n  material,\n  translucent,\n  colorCommands,\n  pickCommands\n) {\n  var primitive = groundPolylinePrimitive._primitive;\n  var length = primitive._va.length;\n  colorCommands.length = length;\n  pickCommands.length = length;\n\n  var isPolylineColorAppearance = appearance instanceof PolylineColorAppearance;\n\n  var materialUniforms = isPolylineColorAppearance ? {} : material._uniforms;\n  var uniformMap = primitive._batchTable.getUniformMapCallback()(\n    materialUniforms\n  );\n\n  for (var i = 0; i < length; i++) {\n    var vertexArray = primitive._va[i];\n\n    var command = colorCommands[i];\n    if (!defined(command)) {\n      command = colorCommands[i] = new DrawCommand({\n        owner: groundPolylinePrimitive,\n        primitiveType: primitive._primitiveType,\n      });\n    }\n\n    command.vertexArray = vertexArray;\n    command.renderState = groundPolylinePrimitive._renderState;\n    command.shaderProgram = groundPolylinePrimitive._sp;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.TERRAIN_CLASSIFICATION;\n    command.pickId = \"czm_batchTable_pickColor(v_endPlaneNormalEcAndBatchId.w)\";\n\n    var derivedTilesetCommand = DrawCommand.shallowClone(\n      command,\n      command.derivedCommands.tileset\n    );\n    derivedTilesetCommand.renderState =\n      groundPolylinePrimitive._renderState3DTiles;\n    derivedTilesetCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedTilesetCommand;\n\n    // derive for 2D\n    var derived2DCommand = DrawCommand.shallowClone(\n      command,\n      command.derivedCommands.color2D\n    );\n    derived2DCommand.shaderProgram = groundPolylinePrimitive._sp2D;\n    command.derivedCommands.color2D = derived2DCommand;\n\n    var derived2DTilesetCommand = DrawCommand.shallowClone(\n      derivedTilesetCommand,\n      derivedTilesetCommand.derivedCommands.color2D\n    );\n    derived2DTilesetCommand.shaderProgram = groundPolylinePrimitive._sp2D;\n    derivedTilesetCommand.derivedCommands.color2D = derived2DTilesetCommand;\n\n    // derive for Morph\n    var derivedMorphCommand = DrawCommand.shallowClone(\n      command,\n      command.derivedCommands.colorMorph\n    );\n    derivedMorphCommand.renderState = groundPolylinePrimitive._renderStateMorph;\n    derivedMorphCommand.shaderProgram = groundPolylinePrimitive._spMorph;\n    derivedMorphCommand.pickId = \"czm_batchTable_pickColor(v_batchId)\";\n    command.derivedCommands.colorMorph = derivedMorphCommand;\n  }\n}\n\nfunction updateAndQueueCommand(\n  groundPolylinePrimitive,\n  command,\n  frameState,\n  modelMatrix,\n  cull,\n  boundingVolume,\n  debugShowBoundingVolume\n) {\n  // Use derived appearance command for morph and 2D\n  if (frameState.mode === SceneMode.MORPHING) {\n    command = command.derivedCommands.colorMorph;\n  } else if (frameState.mode !== SceneMode.SCENE3D) {\n    command = command.derivedCommands.color2D;\n  }\n  command.modelMatrix = modelMatrix;\n  command.boundingVolume = boundingVolume;\n  command.cull = cull;\n  command.debugShowBoundingVolume = debugShowBoundingVolume;\n\n  frameState.commandList.push(command);\n}\n\nfunction updateAndQueueCommands(\n  groundPolylinePrimitive,\n  frameState,\n  colorCommands,\n  pickCommands,\n  modelMatrix,\n  cull,\n  debugShowBoundingVolume\n) {\n  var primitive = groundPolylinePrimitive._primitive;\n\n  Primitive._updateBoundingVolumes(primitive, frameState, modelMatrix); // Expected to be identity - GroundPrimitives don't support other model matrices\n\n  var boundingSpheres;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingSpheres = primitive._boundingSphereWC;\n  } else if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n    boundingSpheres = primitive._boundingSphereCV;\n  } else if (\n    frameState.mode === SceneMode.SCENE2D &&\n    defined(primitive._boundingSphere2D)\n  ) {\n    boundingSpheres = primitive._boundingSphere2D;\n  } else if (defined(primitive._boundingSphereMorph)) {\n    boundingSpheres = primitive._boundingSphereMorph;\n  }\n\n  var morphing = frameState.mode === SceneMode.MORPHING;\n  var classificationType = groundPolylinePrimitive.classificationType;\n  var queueTerrainCommands =\n    classificationType !== ClassificationType.CESIUM_3D_TILE;\n  var queue3DTilesCommands =\n    classificationType !== ClassificationType.TERRAIN && !morphing;\n\n  var command;\n  var passes = frameState.passes;\n  if (passes.render || (passes.pick && primitive.allowPicking)) {\n    var colorLength = colorCommands.length;\n    for (var j = 0; j < colorLength; ++j) {\n      var boundingVolume = boundingSpheres[j];\n      if (queueTerrainCommands) {\n        command = colorCommands[j];\n        updateAndQueueCommand(\n          groundPolylinePrimitive,\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume,\n          debugShowBoundingVolume\n        );\n      }\n      if (queue3DTilesCommands) {\n        command = colorCommands[j].derivedCommands.tileset;\n        updateAndQueueCommand(\n          groundPolylinePrimitive,\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume,\n          debugShowBoundingVolume\n        );\n      }\n    }\n  }\n}\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} For synchronous GroundPolylinePrimitives, you must call GroundPolylinePrimitives.initializeTerrainHeights() and wait for the returned promise to resolve.\n * @exception {DeveloperError} All GeometryInstances must have color attributes to use PolylineColorAppearance with GroundPolylinePrimitive.\n */\nGroundPolylinePrimitive.prototype.update = function (frameState) {\n  if (!defined(this._primitive) && !defined(this.geometryInstances)) {\n    return;\n  }\n\n  if (!ApproximateTerrainHeights.initialized) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!this.asynchronous) {\n      throw new DeveloperError(\n        \"For synchronous GroundPolylinePrimitives, you must call GroundPolylinePrimitives.initializeTerrainHeights() and wait for the returned promise to resolve.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    GroundPolylinePrimitive.initializeTerrainHeights();\n    return;\n  }\n\n  var i;\n\n  var that = this;\n  var primitiveOptions = this._primitiveOptions;\n  if (!defined(this._primitive)) {\n    var geometryInstances = Array.isArray(this.geometryInstances)\n      ? this.geometryInstances\n      : [this.geometryInstances];\n    var geometryInstancesLength = geometryInstances.length;\n    var groundInstances = new Array(geometryInstancesLength);\n\n    var attributes;\n\n    // Check if each instance has a color attribute.\n    for (i = 0; i < geometryInstancesLength; ++i) {\n      attributes = geometryInstances[i].attributes;\n      if (!defined(attributes) || !defined(attributes.color)) {\n        this._hasPerInstanceColors = false;\n        break;\n      }\n    }\n\n    for (i = 0; i < geometryInstancesLength; ++i) {\n      var geometryInstance = geometryInstances[i];\n      attributes = {};\n      var instanceAttributes = geometryInstance.attributes;\n      for (var attributeKey in instanceAttributes) {\n        if (instanceAttributes.hasOwnProperty(attributeKey)) {\n          attributes[attributeKey] = instanceAttributes[attributeKey];\n        }\n      }\n\n      // Automatically create line width attribute if not already given\n      if (!defined(attributes.width)) {\n        attributes.width = new GeometryInstanceAttribute({\n          componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n          componentsPerAttribute: 1.0,\n          value: [geometryInstance.geometry.width],\n        });\n      }\n\n      // Update each geometry for framestate.scene3DOnly = true and projection\n      geometryInstance.geometry._scene3DOnly = frameState.scene3DOnly;\n      GroundPolylineGeometry.setProjectionAndEllipsoid(\n        geometryInstance.geometry,\n        frameState.mapProjection\n      );\n\n      groundInstances[i] = new GeometryInstance({\n        geometry: geometryInstance.geometry,\n        attributes: attributes,\n        id: geometryInstance.id,\n        pickPrimitive: that,\n      });\n    }\n\n    primitiveOptions.geometryInstances = groundInstances;\n    primitiveOptions.appearance = this.appearance;\n\n    primitiveOptions._createShaderProgramFunction = function (\n      primitive,\n      frameState,\n      appearance\n    ) {\n      createShaderProgram(that, frameState, appearance);\n    };\n    primitiveOptions._createCommandsFunction = function (\n      primitive,\n      appearance,\n      material,\n      translucent,\n      twoPasses,\n      colorCommands,\n      pickCommands\n    ) {\n      createCommands(\n        that,\n        appearance,\n        material,\n        translucent,\n        colorCommands,\n        pickCommands\n      );\n    };\n    primitiveOptions._updateAndQueueCommandsFunction = function (\n      primitive,\n      frameState,\n      colorCommands,\n      pickCommands,\n      modelMatrix,\n      cull,\n      debugShowBoundingVolume,\n      twoPasses\n    ) {\n      updateAndQueueCommands(\n        that,\n        frameState,\n        colorCommands,\n        pickCommands,\n        modelMatrix,\n        cull,\n        debugShowBoundingVolume\n      );\n    };\n\n    this._primitive = new Primitive(primitiveOptions);\n    this._primitive.readyPromise.then(function (primitive) {\n      that._ready = true;\n\n      if (that.releaseGeometryInstances) {\n        that.geometryInstances = undefined;\n      }\n\n      var error = primitive._error;\n      if (!defined(error)) {\n        that._readyPromise.resolve(that);\n      } else {\n        that._readyPromise.reject(error);\n      }\n    });\n  }\n\n  if (\n    this.appearance instanceof PolylineColorAppearance &&\n    !this._hasPerInstanceColors\n  ) {\n    throw new DeveloperError(\n      \"All GeometryInstances must have color attributes to use PolylineColorAppearance with GroundPolylinePrimitive.\"\n    );\n  }\n\n  this._primitive.appearance = this.appearance;\n  this._primitive.show = this.show;\n  this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume;\n  this._primitive.update(frameState);\n};\n\n/**\n * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.\n *\n * @param {*} id The id of the {@link GeometryInstance}.\n * @returns {Object} The typed array in the attribute's format or undefined if the is no instance with id.\n *\n * @exception {DeveloperError} must call update before calling getGeometryInstanceAttributes.\n *\n * @example\n * var attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);\n */\nGroundPolylinePrimitive.prototype.getGeometryInstanceAttributes = function (\n  id\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(this._primitive)) {\n    throw new DeveloperError(\n      \"must call update before calling getGeometryInstanceAttributes\"\n    );\n  }\n  //>>includeEnd('debug');\n  return this._primitive.getGeometryInstanceAttributes(id);\n};\n\n/**\n * Checks if the given Scene supports GroundPolylinePrimitives.\n * GroundPolylinePrimitives require support for the WEBGL_depth_texture extension.\n *\n * @param {Scene} scene The current scene.\n * @returns {Boolean} Whether or not the current scene supports GroundPolylinePrimitives.\n */\nGroundPolylinePrimitive.isSupported = function (scene) {\n  return scene.frameState.context.depthTexture;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see GroundPolylinePrimitive#destroy\n */\nGroundPolylinePrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * e = e && e.destroy();\n *\n * @see GroundPolylinePrimitive#isDestroyed\n */\nGroundPolylinePrimitive.prototype.destroy = function () {\n  this._primitive = this._primitive && this._primitive.destroy();\n  this._sp = this._sp && this._sp.destroy();\n\n  // Derived programs, destroyed above if they existed.\n  this._sp2D = undefined;\n  this._spMorph = undefined;\n\n  return destroyObject(this);\n};\nexport default GroundPolylinePrimitive;\n"]},"metadata":{},"sourceType":"module"}