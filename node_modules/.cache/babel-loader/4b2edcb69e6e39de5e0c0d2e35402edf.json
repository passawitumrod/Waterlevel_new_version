{"ast":null,"code":"import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Rectangle from \"./Rectangle.js\";\n/**\n * Determine whether or not other objects are visible or hidden behind the visible horizon defined by\n * an {@link Ellipsoid} and a camera position.  The ellipsoid is assumed to be located at the\n * origin of the coordinate system.  This class uses the algorithm described in the\n * {@link https://cesium.com/blog/2013/04/25/Horizon-culling/|Horizon Culling} blog post.\n *\n * @alias EllipsoidalOccluder\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to use as an occluder.\n * @param {Cartesian3} [cameraPosition] The coordinate of the viewer/camera.  If this parameter is not\n *        specified, {@link EllipsoidalOccluder#cameraPosition} must be called before\n *        testing visibility.\n *\n * @constructor\n *\n * @example\n * // Construct an ellipsoidal occluder with radii 1.0, 1.1, and 0.9.\n * var cameraPosition = new Cesium.Cartesian3(5.0, 6.0, 7.0);\n * var occluderEllipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * var occluder = new Cesium.EllipsoidalOccluder(occluderEllipsoid, cameraPosition);\n *\n * @private\n */\n\nfunction EllipsoidalOccluder(ellipsoid, cameraPosition) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid); //>>includeEnd('debug');\n\n  this._ellipsoid = ellipsoid;\n  this._cameraPosition = new Cartesian3();\n  this._cameraPositionInScaledSpace = new Cartesian3();\n  this._distanceToLimbInScaledSpaceSquared = 0.0; // cameraPosition fills in the above values\n\n  if (defined(cameraPosition)) {\n    this.cameraPosition = cameraPosition;\n  }\n}\n\nObject.defineProperties(EllipsoidalOccluder.prototype, {\n  /**\n   * Gets the occluding ellipsoid.\n   * @memberof EllipsoidalOccluder.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    }\n  },\n\n  /**\n   * Gets or sets the position of the camera.\n   * @memberof EllipsoidalOccluder.prototype\n   * @type {Cartesian3}\n   */\n  cameraPosition: {\n    get: function () {\n      return this._cameraPosition;\n    },\n    set: function (cameraPosition) {\n      // See https://cesium.com/blog/2013/04/25/Horizon-culling/\n      var ellipsoid = this._ellipsoid;\n      var cv = ellipsoid.transformPositionToScaledSpace(cameraPosition, this._cameraPositionInScaledSpace);\n      var vhMagnitudeSquared = Cartesian3.magnitudeSquared(cv) - 1.0;\n      Cartesian3.clone(cameraPosition, this._cameraPosition);\n      this._cameraPositionInScaledSpace = cv;\n      this._distanceToLimbInScaledSpaceSquared = vhMagnitudeSquared;\n    }\n  }\n});\nvar scratchCartesian = new Cartesian3();\n/**\n * Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.\n *\n * @param {Cartesian3} occludee The point to test for visibility.\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n * @example\n * var cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\n * var ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * var occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\n * var point = new Cesium.Cartesian3(0, -3, -3);\n * occluder.isPointVisible(point); //returns true\n */\n\nEllipsoidalOccluder.prototype.isPointVisible = function (occludee) {\n  var ellipsoid = this._ellipsoid;\n  var occludeeScaledSpacePosition = ellipsoid.transformPositionToScaledSpace(occludee, scratchCartesian);\n  return isScaledSpacePointVisible(occludeeScaledSpacePosition, this._cameraPositionInScaledSpace, this._distanceToLimbInScaledSpaceSquared);\n};\n/**\n * Determines whether or not a point expressed in the ellipsoid scaled space, is hidden from view by the\n * occluder.  To transform a Cartesian X, Y, Z position in the coordinate system aligned with the ellipsoid\n * into the scaled space, call {@link Ellipsoid#transformPositionToScaledSpace}.\n *\n * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space.\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n * @example\n * var cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\n * var ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * var occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\n * var point = new Cesium.Cartesian3(0, -3, -3);\n * var scaledSpacePoint = ellipsoid.transformPositionToScaledSpace(point);\n * occluder.isScaledSpacePointVisible(scaledSpacePoint); //returns true\n */\n\n\nEllipsoidalOccluder.prototype.isScaledSpacePointVisible = function (occludeeScaledSpacePosition) {\n  return isScaledSpacePointVisible(occludeeScaledSpacePosition, this._cameraPositionInScaledSpace, this._distanceToLimbInScaledSpaceSquared);\n};\n\nvar scratchCameraPositionInScaledSpaceShrunk = new Cartesian3();\n/**\n * Similar to {@link EllipsoidalOccluder#isScaledSpacePointVisible} except tests against an\n * ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. This is intended to be used with points generated by\n * {@link EllipsoidalOccluder#computeHorizonCullingPointPossiblyUnderEllipsoid} or\n * {@link EllipsoidalOccluder#computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space of the possibly-shrunk ellipsoid.\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n */\n\nEllipsoidalOccluder.prototype.isScaledSpacePointVisiblePossiblyUnderEllipsoid = function (occludeeScaledSpacePosition, minimumHeight) {\n  var ellipsoid = this._ellipsoid;\n  var vhMagnitudeSquared;\n  var cv;\n\n  if (defined(minimumHeight) && minimumHeight < 0.0 && ellipsoid.minimumRadius > -minimumHeight) {\n    // This code is similar to the cameraPosition setter, but unrolled for performance because it will be called a lot.\n    cv = scratchCameraPositionInScaledSpaceShrunk;\n    cv.x = this._cameraPosition.x / (ellipsoid.radii.x + minimumHeight);\n    cv.y = this._cameraPosition.y / (ellipsoid.radii.y + minimumHeight);\n    cv.z = this._cameraPosition.z / (ellipsoid.radii.z + minimumHeight);\n    vhMagnitudeSquared = cv.x * cv.x + cv.y * cv.y + cv.z * cv.z - 1.0;\n  } else {\n    cv = this._cameraPositionInScaledSpace;\n    vhMagnitudeSquared = this._distanceToLimbInScaledSpaceSquared;\n  }\n\n  return isScaledSpacePointVisible(occludeeScaledSpacePosition, cv, vhMagnitudeSquared);\n};\n/**\n * Computes a point that can be used for horizon culling from a list of positions.  If the point is below\n * the horizon, all of the positions are guaranteed to be below the horizon as well.  The returned point\n * is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Cartesian3[]} positions The positions from which to compute the horizon culling point.  The positions\n *                       must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                       ellipsoid's axes.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\n\n\nEllipsoidalOccluder.prototype.computeHorizonCullingPoint = function (directionToPoint, positions, result) {\n  return computeHorizonCullingPointFromPositions(this._ellipsoid, directionToPoint, positions, result);\n};\n\nvar scratchEllipsoidShrunk = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n/**\n * Similar to {@link EllipsoidalOccluder#computeHorizonCullingPoint} except computes the culling\n * point relative to an ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. The returned point is expressed in the possibly-shrunk ellipsoid-scaled space and is suitable\n * for use with {@link EllipsoidalOccluder#isScaledSpacePointVisiblePossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Cartesian3[]} positions The positions from which to compute the horizon culling point.  The positions\n *                       must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                       ellipsoid's axes.\n * @param {Number} [minimumHeight] The minimum height of all positions. If this value is undefined, all positions are assumed to be above the ellipsoid.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the possibly-shrunk ellipsoid-scaled space.\n */\n\nEllipsoidalOccluder.prototype.computeHorizonCullingPointPossiblyUnderEllipsoid = function (directionToPoint, positions, minimumHeight, result) {\n  var possiblyShrunkEllipsoid = getPossiblyShrunkEllipsoid(this._ellipsoid, minimumHeight, scratchEllipsoidShrunk);\n  return computeHorizonCullingPointFromPositions(possiblyShrunkEllipsoid, directionToPoint, positions, result);\n};\n/**\n * Computes a point that can be used for horizon culling from a list of positions.  If the point is below\n * the horizon, all of the positions are guaranteed to be below the horizon as well.  The returned point\n * is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Number[]} vertices  The vertices from which to compute the horizon culling point.  The positions\n *                   must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                   ellipsoid's axes.\n * @param {Number} [stride=3]\n * @param {Cartesian3} [center=Cartesian3.ZERO]\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\n\n\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromVertices = function (directionToPoint, vertices, stride, center, result) {\n  return computeHorizonCullingPointFromVertices(this._ellipsoid, directionToPoint, vertices, stride, center, result);\n};\n/**\n * Similar to {@link EllipsoidalOccluder#computeHorizonCullingPointFromVertices} except computes the culling\n * point relative to an ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. The returned point is expressed in the possibly-shrunk ellipsoid-scaled space and is suitable\n * for use with {@link EllipsoidalOccluder#isScaledSpacePointVisiblePossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Number[]} vertices  The vertices from which to compute the horizon culling point.  The positions\n *                   must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                   ellipsoid's axes.\n * @param {Number} [stride=3]\n * @param {Cartesian3} [center=Cartesian3.ZERO]\n * @param {Number} [minimumHeight] The minimum height of all vertices. If this value is undefined, all vertices are assumed to be above the ellipsoid.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the possibly-shrunk ellipsoid-scaled space.\n */\n\n\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid = function (directionToPoint, vertices, stride, center, minimumHeight, result) {\n  var possiblyShrunkEllipsoid = getPossiblyShrunkEllipsoid(this._ellipsoid, minimumHeight, scratchEllipsoidShrunk);\n  return computeHorizonCullingPointFromVertices(possiblyShrunkEllipsoid, directionToPoint, vertices, stride, center, result);\n};\n\nvar subsampleScratch = [];\n/**\n * Computes a point that can be used for horizon culling of a rectangle.  If the point is below\n * the horizon, the ellipsoid-conforming rectangle is guaranteed to be below the horizon as well.\n * The returned point is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Rectangle} rectangle The rectangle for which to compute the horizon culling point.\n * @param {Ellipsoid} ellipsoid The ellipsoid on which the rectangle is defined.  This may be different from\n *                    the ellipsoid used by this instance for occlusion testing.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\n\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromRectangle = function (rectangle, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle); //>>includeEnd('debug');\n\n  var positions = Rectangle.subsample(rectangle, ellipsoid, 0.0, subsampleScratch);\n  var bs = BoundingSphere.fromPoints(positions); // If the bounding sphere center is too close to the center of the occluder, it doesn't make\n  // sense to try to horizon cull it.\n\n  if (Cartesian3.magnitude(bs.center) < 0.1 * ellipsoid.minimumRadius) {\n    return undefined;\n  }\n\n  return this.computeHorizonCullingPoint(bs.center, positions, result);\n};\n\nvar scratchEllipsoidShrunkRadii = new Cartesian3();\n\nfunction getPossiblyShrunkEllipsoid(ellipsoid, minimumHeight, result) {\n  if (defined(minimumHeight) && minimumHeight < 0.0 && ellipsoid.minimumRadius > -minimumHeight) {\n    var ellipsoidShrunkRadii = Cartesian3.fromElements(ellipsoid.radii.x + minimumHeight, ellipsoid.radii.y + minimumHeight, ellipsoid.radii.z + minimumHeight, scratchEllipsoidShrunkRadii);\n    ellipsoid = Ellipsoid.fromCartesian3(ellipsoidShrunkRadii, result);\n  }\n\n  return ellipsoid;\n}\n\nfunction computeHorizonCullingPointFromPositions(ellipsoid, directionToPoint, positions, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"directionToPoint\", directionToPoint);\n  Check.defined(\"positions\", positions); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  var scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint);\n  var resultMagnitude = 0.0;\n\n  for (var i = 0, len = positions.length; i < len; ++i) {\n    var position = positions[i];\n    var candidateMagnitude = computeMagnitude(ellipsoid, position, scaledSpaceDirectionToPoint);\n\n    if (candidateMagnitude < 0.0) {\n      // all points should face the same direction, but this one doesn't, so return undefined\n      return undefined;\n    }\n\n    resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);\n  }\n\n  return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);\n}\n\nvar positionScratch = new Cartesian3();\n\nfunction computeHorizonCullingPointFromVertices(ellipsoid, directionToPoint, vertices, stride, center, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"directionToPoint\", directionToPoint);\n  Check.defined(\"vertices\", vertices);\n  Check.typeOf.number(\"stride\", stride); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  stride = defaultValue(stride, 3);\n  center = defaultValue(center, Cartesian3.ZERO);\n  var scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint);\n  var resultMagnitude = 0.0;\n\n  for (var i = 0, len = vertices.length; i < len; i += stride) {\n    positionScratch.x = vertices[i] + center.x;\n    positionScratch.y = vertices[i + 1] + center.y;\n    positionScratch.z = vertices[i + 2] + center.z;\n    var candidateMagnitude = computeMagnitude(ellipsoid, positionScratch, scaledSpaceDirectionToPoint);\n\n    if (candidateMagnitude < 0.0) {\n      // all points should face the same direction, but this one doesn't, so return undefined\n      return undefined;\n    }\n\n    resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);\n  }\n\n  return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);\n}\n\nfunction isScaledSpacePointVisible(occludeeScaledSpacePosition, cameraPositionInScaledSpace, distanceToLimbInScaledSpaceSquared) {\n  // See https://cesium.com/blog/2013/04/25/Horizon-culling/\n  var cv = cameraPositionInScaledSpace;\n  var vhMagnitudeSquared = distanceToLimbInScaledSpaceSquared;\n  var vt = Cartesian3.subtract(occludeeScaledSpacePosition, cv, scratchCartesian);\n  var vtDotVc = -Cartesian3.dot(vt, cv); // If vhMagnitudeSquared < 0 then we are below the surface of the ellipsoid and\n  // in this case, set the culling plane to be on V.\n\n  var isOccluded = vhMagnitudeSquared < 0 ? vtDotVc > 0 : vtDotVc > vhMagnitudeSquared && vtDotVc * vtDotVc / Cartesian3.magnitudeSquared(vt) > vhMagnitudeSquared;\n  return !isOccluded;\n}\n\nvar scaledSpaceScratch = new Cartesian3();\nvar directionScratch = new Cartesian3();\n\nfunction computeMagnitude(ellipsoid, position, scaledSpaceDirectionToPoint) {\n  var scaledSpacePosition = ellipsoid.transformPositionToScaledSpace(position, scaledSpaceScratch);\n  var magnitudeSquared = Cartesian3.magnitudeSquared(scaledSpacePosition);\n  var magnitude = Math.sqrt(magnitudeSquared);\n  var direction = Cartesian3.divideByScalar(scaledSpacePosition, magnitude, directionScratch); // For the purpose of this computation, points below the ellipsoid are consider to be on it instead.\n\n  magnitudeSquared = Math.max(1.0, magnitudeSquared);\n  magnitude = Math.max(1.0, magnitude);\n  var cosAlpha = Cartesian3.dot(direction, scaledSpaceDirectionToPoint);\n  var sinAlpha = Cartesian3.magnitude(Cartesian3.cross(direction, scaledSpaceDirectionToPoint, direction));\n  var cosBeta = 1.0 / magnitude;\n  var sinBeta = Math.sqrt(magnitudeSquared - 1.0) * cosBeta;\n  return 1.0 / (cosAlpha * cosBeta - sinAlpha * sinBeta);\n}\n\nfunction magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result) {\n  // The horizon culling point is undefined if there were no positions from which to compute it,\n  // the directionToPoint is pointing opposite all of the positions,  or if we computed NaN or infinity.\n  if (resultMagnitude <= 0.0 || resultMagnitude === 1.0 / 0.0 || resultMagnitude !== resultMagnitude) {\n    return undefined;\n  }\n\n  return Cartesian3.multiplyByScalar(scaledSpaceDirectionToPoint, resultMagnitude, result);\n}\n\nvar directionToPointScratch = new Cartesian3();\n\nfunction computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint) {\n  if (Cartesian3.equals(directionToPoint, Cartesian3.ZERO)) {\n    return directionToPoint;\n  }\n\n  ellipsoid.transformPositionToScaledSpace(directionToPoint, directionToPointScratch);\n  return Cartesian3.normalize(directionToPointScratch, directionToPointScratch);\n}\n\nexport default EllipsoidalOccluder;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/EllipsoidalOccluder.js"],"names":["BoundingSphere","Cartesian3","Check","defaultValue","defined","Ellipsoid","Rectangle","EllipsoidalOccluder","ellipsoid","cameraPosition","typeOf","object","_ellipsoid","_cameraPosition","_cameraPositionInScaledSpace","_distanceToLimbInScaledSpaceSquared","Object","defineProperties","prototype","get","set","cv","transformPositionToScaledSpace","vhMagnitudeSquared","magnitudeSquared","clone","scratchCartesian","isPointVisible","occludee","occludeeScaledSpacePosition","isScaledSpacePointVisible","scratchCameraPositionInScaledSpaceShrunk","isScaledSpacePointVisiblePossiblyUnderEllipsoid","minimumHeight","minimumRadius","x","radii","y","z","computeHorizonCullingPoint","directionToPoint","positions","result","computeHorizonCullingPointFromPositions","scratchEllipsoidShrunk","UNIT_SPHERE","computeHorizonCullingPointPossiblyUnderEllipsoid","possiblyShrunkEllipsoid","getPossiblyShrunkEllipsoid","computeHorizonCullingPointFromVertices","vertices","stride","center","computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid","subsampleScratch","computeHorizonCullingPointFromRectangle","rectangle","subsample","bs","fromPoints","magnitude","undefined","scratchEllipsoidShrunkRadii","ellipsoidShrunkRadii","fromElements","fromCartesian3","scaledSpaceDirectionToPoint","computeScaledSpaceDirectionToPoint","resultMagnitude","i","len","length","position","candidateMagnitude","computeMagnitude","Math","max","magnitudeToPoint","positionScratch","number","ZERO","cameraPositionInScaledSpace","distanceToLimbInScaledSpaceSquared","vt","subtract","vtDotVc","dot","isOccluded","scaledSpaceScratch","directionScratch","scaledSpacePosition","sqrt","direction","divideByScalar","cosAlpha","sinAlpha","cross","cosBeta","sinBeta","multiplyByScalar","directionToPointScratch","equals","normalize"],"mappings":"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","sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * Determine whether or not other objects are visible or hidden behind the visible horizon defined by\n * an {@link Ellipsoid} and a camera position.  The ellipsoid is assumed to be located at the\n * origin of the coordinate system.  This class uses the algorithm described in the\n * {@link https://cesium.com/blog/2013/04/25/Horizon-culling/|Horizon Culling} blog post.\n *\n * @alias EllipsoidalOccluder\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to use as an occluder.\n * @param {Cartesian3} [cameraPosition] The coordinate of the viewer/camera.  If this parameter is not\n *        specified, {@link EllipsoidalOccluder#cameraPosition} must be called before\n *        testing visibility.\n *\n * @constructor\n *\n * @example\n * // Construct an ellipsoidal occluder with radii 1.0, 1.1, and 0.9.\n * var cameraPosition = new Cesium.Cartesian3(5.0, 6.0, 7.0);\n * var occluderEllipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * var occluder = new Cesium.EllipsoidalOccluder(occluderEllipsoid, cameraPosition);\n *\n * @private\n */\nfunction EllipsoidalOccluder(ellipsoid, cameraPosition) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  //>>includeEnd('debug');\n\n  this._ellipsoid = ellipsoid;\n  this._cameraPosition = new Cartesian3();\n  this._cameraPositionInScaledSpace = new Cartesian3();\n  this._distanceToLimbInScaledSpaceSquared = 0.0;\n\n  // cameraPosition fills in the above values\n  if (defined(cameraPosition)) {\n    this.cameraPosition = cameraPosition;\n  }\n}\n\nObject.defineProperties(EllipsoidalOccluder.prototype, {\n  /**\n   * Gets the occluding ellipsoid.\n   * @memberof EllipsoidalOccluder.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n  /**\n   * Gets or sets the position of the camera.\n   * @memberof EllipsoidalOccluder.prototype\n   * @type {Cartesian3}\n   */\n  cameraPosition: {\n    get: function () {\n      return this._cameraPosition;\n    },\n    set: function (cameraPosition) {\n      // See https://cesium.com/blog/2013/04/25/Horizon-culling/\n      var ellipsoid = this._ellipsoid;\n      var cv = ellipsoid.transformPositionToScaledSpace(\n        cameraPosition,\n        this._cameraPositionInScaledSpace\n      );\n      var vhMagnitudeSquared = Cartesian3.magnitudeSquared(cv) - 1.0;\n\n      Cartesian3.clone(cameraPosition, this._cameraPosition);\n      this._cameraPositionInScaledSpace = cv;\n      this._distanceToLimbInScaledSpaceSquared = vhMagnitudeSquared;\n    },\n  },\n});\n\nvar scratchCartesian = new Cartesian3();\n\n/**\n * Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.\n *\n * @param {Cartesian3} occludee The point to test for visibility.\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n * @example\n * var cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\n * var ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * var occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\n * var point = new Cesium.Cartesian3(0, -3, -3);\n * occluder.isPointVisible(point); //returns true\n */\nEllipsoidalOccluder.prototype.isPointVisible = function (occludee) {\n  var ellipsoid = this._ellipsoid;\n  var occludeeScaledSpacePosition = ellipsoid.transformPositionToScaledSpace(\n    occludee,\n    scratchCartesian\n  );\n  return isScaledSpacePointVisible(\n    occludeeScaledSpacePosition,\n    this._cameraPositionInScaledSpace,\n    this._distanceToLimbInScaledSpaceSquared\n  );\n};\n\n/**\n * Determines whether or not a point expressed in the ellipsoid scaled space, is hidden from view by the\n * occluder.  To transform a Cartesian X, Y, Z position in the coordinate system aligned with the ellipsoid\n * into the scaled space, call {@link Ellipsoid#transformPositionToScaledSpace}.\n *\n * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space.\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n * @example\n * var cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\n * var ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * var occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\n * var point = new Cesium.Cartesian3(0, -3, -3);\n * var scaledSpacePoint = ellipsoid.transformPositionToScaledSpace(point);\n * occluder.isScaledSpacePointVisible(scaledSpacePoint); //returns true\n */\nEllipsoidalOccluder.prototype.isScaledSpacePointVisible = function (\n  occludeeScaledSpacePosition\n) {\n  return isScaledSpacePointVisible(\n    occludeeScaledSpacePosition,\n    this._cameraPositionInScaledSpace,\n    this._distanceToLimbInScaledSpaceSquared\n  );\n};\n\nvar scratchCameraPositionInScaledSpaceShrunk = new Cartesian3();\n\n/**\n * Similar to {@link EllipsoidalOccluder#isScaledSpacePointVisible} except tests against an\n * ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. This is intended to be used with points generated by\n * {@link EllipsoidalOccluder#computeHorizonCullingPointPossiblyUnderEllipsoid} or\n * {@link EllipsoidalOccluder#computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space of the possibly-shrunk ellipsoid.\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n */\nEllipsoidalOccluder.prototype.isScaledSpacePointVisiblePossiblyUnderEllipsoid = function (\n  occludeeScaledSpacePosition,\n  minimumHeight\n) {\n  var ellipsoid = this._ellipsoid;\n  var vhMagnitudeSquared;\n  var cv;\n\n  if (\n    defined(minimumHeight) &&\n    minimumHeight < 0.0 &&\n    ellipsoid.minimumRadius > -minimumHeight\n  ) {\n    // This code is similar to the cameraPosition setter, but unrolled for performance because it will be called a lot.\n    cv = scratchCameraPositionInScaledSpaceShrunk;\n    cv.x = this._cameraPosition.x / (ellipsoid.radii.x + minimumHeight);\n    cv.y = this._cameraPosition.y / (ellipsoid.radii.y + minimumHeight);\n    cv.z = this._cameraPosition.z / (ellipsoid.radii.z + minimumHeight);\n    vhMagnitudeSquared = cv.x * cv.x + cv.y * cv.y + cv.z * cv.z - 1.0;\n  } else {\n    cv = this._cameraPositionInScaledSpace;\n    vhMagnitudeSquared = this._distanceToLimbInScaledSpaceSquared;\n  }\n\n  return isScaledSpacePointVisible(\n    occludeeScaledSpacePosition,\n    cv,\n    vhMagnitudeSquared\n  );\n};\n\n/**\n * Computes a point that can be used for horizon culling from a list of positions.  If the point is below\n * the horizon, all of the positions are guaranteed to be below the horizon as well.  The returned point\n * is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Cartesian3[]} positions The positions from which to compute the horizon culling point.  The positions\n *                       must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                       ellipsoid's axes.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPoint = function (\n  directionToPoint,\n  positions,\n  result\n) {\n  return computeHorizonCullingPointFromPositions(\n    this._ellipsoid,\n    directionToPoint,\n    positions,\n    result\n  );\n};\n\nvar scratchEllipsoidShrunk = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n\n/**\n * Similar to {@link EllipsoidalOccluder#computeHorizonCullingPoint} except computes the culling\n * point relative to an ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. The returned point is expressed in the possibly-shrunk ellipsoid-scaled space and is suitable\n * for use with {@link EllipsoidalOccluder#isScaledSpacePointVisiblePossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Cartesian3[]} positions The positions from which to compute the horizon culling point.  The positions\n *                       must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                       ellipsoid's axes.\n * @param {Number} [minimumHeight] The minimum height of all positions. If this value is undefined, all positions are assumed to be above the ellipsoid.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the possibly-shrunk ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointPossiblyUnderEllipsoid = function (\n  directionToPoint,\n  positions,\n  minimumHeight,\n  result\n) {\n  var possiblyShrunkEllipsoid = getPossiblyShrunkEllipsoid(\n    this._ellipsoid,\n    minimumHeight,\n    scratchEllipsoidShrunk\n  );\n  return computeHorizonCullingPointFromPositions(\n    possiblyShrunkEllipsoid,\n    directionToPoint,\n    positions,\n    result\n  );\n};\n/**\n * Computes a point that can be used for horizon culling from a list of positions.  If the point is below\n * the horizon, all of the positions are guaranteed to be below the horizon as well.  The returned point\n * is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Number[]} vertices  The vertices from which to compute the horizon culling point.  The positions\n *                   must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                   ellipsoid's axes.\n * @param {Number} [stride=3]\n * @param {Cartesian3} [center=Cartesian3.ZERO]\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromVertices = function (\n  directionToPoint,\n  vertices,\n  stride,\n  center,\n  result\n) {\n  return computeHorizonCullingPointFromVertices(\n    this._ellipsoid,\n    directionToPoint,\n    vertices,\n    stride,\n    center,\n    result\n  );\n};\n\n/**\n * Similar to {@link EllipsoidalOccluder#computeHorizonCullingPointFromVertices} except computes the culling\n * point relative to an ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. The returned point is expressed in the possibly-shrunk ellipsoid-scaled space and is suitable\n * for use with {@link EllipsoidalOccluder#isScaledSpacePointVisiblePossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Number[]} vertices  The vertices from which to compute the horizon culling point.  The positions\n *                   must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                   ellipsoid's axes.\n * @param {Number} [stride=3]\n * @param {Cartesian3} [center=Cartesian3.ZERO]\n * @param {Number} [minimumHeight] The minimum height of all vertices. If this value is undefined, all vertices are assumed to be above the ellipsoid.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the possibly-shrunk ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid = function (\n  directionToPoint,\n  vertices,\n  stride,\n  center,\n  minimumHeight,\n  result\n) {\n  var possiblyShrunkEllipsoid = getPossiblyShrunkEllipsoid(\n    this._ellipsoid,\n    minimumHeight,\n    scratchEllipsoidShrunk\n  );\n  return computeHorizonCullingPointFromVertices(\n    possiblyShrunkEllipsoid,\n    directionToPoint,\n    vertices,\n    stride,\n    center,\n    result\n  );\n};\n\nvar subsampleScratch = [];\n\n/**\n * Computes a point that can be used for horizon culling of a rectangle.  If the point is below\n * the horizon, the ellipsoid-conforming rectangle is guaranteed to be below the horizon as well.\n * The returned point is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Rectangle} rectangle The rectangle for which to compute the horizon culling point.\n * @param {Ellipsoid} ellipsoid The ellipsoid on which the rectangle is defined.  This may be different from\n *                    the ellipsoid used by this instance for occlusion testing.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromRectangle = function (\n  rectangle,\n  ellipsoid,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  var positions = Rectangle.subsample(\n    rectangle,\n    ellipsoid,\n    0.0,\n    subsampleScratch\n  );\n  var bs = BoundingSphere.fromPoints(positions);\n\n  // If the bounding sphere center is too close to the center of the occluder, it doesn't make\n  // sense to try to horizon cull it.\n  if (Cartesian3.magnitude(bs.center) < 0.1 * ellipsoid.minimumRadius) {\n    return undefined;\n  }\n\n  return this.computeHorizonCullingPoint(bs.center, positions, result);\n};\n\nvar scratchEllipsoidShrunkRadii = new Cartesian3();\n\nfunction getPossiblyShrunkEllipsoid(ellipsoid, minimumHeight, result) {\n  if (\n    defined(minimumHeight) &&\n    minimumHeight < 0.0 &&\n    ellipsoid.minimumRadius > -minimumHeight\n  ) {\n    var ellipsoidShrunkRadii = Cartesian3.fromElements(\n      ellipsoid.radii.x + minimumHeight,\n      ellipsoid.radii.y + minimumHeight,\n      ellipsoid.radii.z + minimumHeight,\n      scratchEllipsoidShrunkRadii\n    );\n    ellipsoid = Ellipsoid.fromCartesian3(ellipsoidShrunkRadii, result);\n  }\n  return ellipsoid;\n}\n\nfunction computeHorizonCullingPointFromPositions(\n  ellipsoid,\n  directionToPoint,\n  positions,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"directionToPoint\", directionToPoint);\n  Check.defined(\"positions\", positions);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  var scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(\n    ellipsoid,\n    directionToPoint\n  );\n  var resultMagnitude = 0.0;\n\n  for (var i = 0, len = positions.length; i < len; ++i) {\n    var position = positions[i];\n    var candidateMagnitude = computeMagnitude(\n      ellipsoid,\n      position,\n      scaledSpaceDirectionToPoint\n    );\n    if (candidateMagnitude < 0.0) {\n      // all points should face the same direction, but this one doesn't, so return undefined\n      return undefined;\n    }\n    resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);\n  }\n\n  return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);\n}\n\nvar positionScratch = new Cartesian3();\n\nfunction computeHorizonCullingPointFromVertices(\n  ellipsoid,\n  directionToPoint,\n  vertices,\n  stride,\n  center,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"directionToPoint\", directionToPoint);\n  Check.defined(\"vertices\", vertices);\n  Check.typeOf.number(\"stride\", stride);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  stride = defaultValue(stride, 3);\n  center = defaultValue(center, Cartesian3.ZERO);\n  var scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(\n    ellipsoid,\n    directionToPoint\n  );\n  var resultMagnitude = 0.0;\n\n  for (var i = 0, len = vertices.length; i < len; i += stride) {\n    positionScratch.x = vertices[i] + center.x;\n    positionScratch.y = vertices[i + 1] + center.y;\n    positionScratch.z = vertices[i + 2] + center.z;\n\n    var candidateMagnitude = computeMagnitude(\n      ellipsoid,\n      positionScratch,\n      scaledSpaceDirectionToPoint\n    );\n    if (candidateMagnitude < 0.0) {\n      // all points should face the same direction, but this one doesn't, so return undefined\n      return undefined;\n    }\n    resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);\n  }\n\n  return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);\n}\n\nfunction isScaledSpacePointVisible(\n  occludeeScaledSpacePosition,\n  cameraPositionInScaledSpace,\n  distanceToLimbInScaledSpaceSquared\n) {\n  // See https://cesium.com/blog/2013/04/25/Horizon-culling/\n  var cv = cameraPositionInScaledSpace;\n  var vhMagnitudeSquared = distanceToLimbInScaledSpaceSquared;\n  var vt = Cartesian3.subtract(\n    occludeeScaledSpacePosition,\n    cv,\n    scratchCartesian\n  );\n  var vtDotVc = -Cartesian3.dot(vt, cv);\n  // If vhMagnitudeSquared < 0 then we are below the surface of the ellipsoid and\n  // in this case, set the culling plane to be on V.\n  var isOccluded =\n    vhMagnitudeSquared < 0\n      ? vtDotVc > 0\n      : vtDotVc > vhMagnitudeSquared &&\n        (vtDotVc * vtDotVc) / Cartesian3.magnitudeSquared(vt) >\n          vhMagnitudeSquared;\n  return !isOccluded;\n}\n\nvar scaledSpaceScratch = new Cartesian3();\nvar directionScratch = new Cartesian3();\n\nfunction computeMagnitude(ellipsoid, position, scaledSpaceDirectionToPoint) {\n  var scaledSpacePosition = ellipsoid.transformPositionToScaledSpace(\n    position,\n    scaledSpaceScratch\n  );\n  var magnitudeSquared = Cartesian3.magnitudeSquared(scaledSpacePosition);\n  var magnitude = Math.sqrt(magnitudeSquared);\n  var direction = Cartesian3.divideByScalar(\n    scaledSpacePosition,\n    magnitude,\n    directionScratch\n  );\n\n  // For the purpose of this computation, points below the ellipsoid are consider to be on it instead.\n  magnitudeSquared = Math.max(1.0, magnitudeSquared);\n  magnitude = Math.max(1.0, magnitude);\n\n  var cosAlpha = Cartesian3.dot(direction, scaledSpaceDirectionToPoint);\n  var sinAlpha = Cartesian3.magnitude(\n    Cartesian3.cross(direction, scaledSpaceDirectionToPoint, direction)\n  );\n  var cosBeta = 1.0 / magnitude;\n  var sinBeta = Math.sqrt(magnitudeSquared - 1.0) * cosBeta;\n\n  return 1.0 / (cosAlpha * cosBeta - sinAlpha * sinBeta);\n}\n\nfunction magnitudeToPoint(\n  scaledSpaceDirectionToPoint,\n  resultMagnitude,\n  result\n) {\n  // The horizon culling point is undefined if there were no positions from which to compute it,\n  // the directionToPoint is pointing opposite all of the positions,  or if we computed NaN or infinity.\n  if (\n    resultMagnitude <= 0.0 ||\n    resultMagnitude === 1.0 / 0.0 ||\n    resultMagnitude !== resultMagnitude\n  ) {\n    return undefined;\n  }\n\n  return Cartesian3.multiplyByScalar(\n    scaledSpaceDirectionToPoint,\n    resultMagnitude,\n    result\n  );\n}\n\nvar directionToPointScratch = new Cartesian3();\n\nfunction computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint) {\n  if (Cartesian3.equals(directionToPoint, Cartesian3.ZERO)) {\n    return directionToPoint;\n  }\n\n  ellipsoid.transformPositionToScaledSpace(\n    directionToPoint,\n    directionToPointScratch\n  );\n  return Cartesian3.normalize(directionToPointScratch, directionToPointScratch);\n}\nexport default EllipsoidalOccluder;\n"]},"metadata":{},"sourceType":"module"}