{"ast":null,"code":"import Cartesian2 from \"./Cartesian2.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\n/**\n * A 2x2 matrix, indexable as a column-major order array.\n * Constructor parameters are in row-major order for code readability.\n * @alias Matrix2\n * @constructor\n *\n * @param {Number} [column0Row0=0.0] The value for column 0, row 0.\n * @param {Number} [column1Row0=0.0] The value for column 1, row 0.\n * @param {Number} [column0Row1=0.0] The value for column 0, row 1.\n * @param {Number} [column1Row1=0.0] The value for column 1, row 1.\n *\n * @see Matrix2.fromColumnMajorArray\n * @see Matrix2.fromRowMajorArray\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix3\n * @see Matrix4\n */\n\nfunction Matrix2(column0Row0, column1Row0, column0Row1, column1Row1) {\n  this[0] = defaultValue(column0Row0, 0.0);\n  this[1] = defaultValue(column0Row1, 0.0);\n  this[2] = defaultValue(column1Row0, 0.0);\n  this[3] = defaultValue(column1Row1, 0.0);\n}\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\n\n\nMatrix2.packedLength = 4;\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Matrix2} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\nMatrix2.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  array[startingIndex++] = value[0];\n  array[startingIndex++] = value[1];\n  array[startingIndex++] = value[2];\n  array[startingIndex++] = value[3];\n  return array;\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Matrix2} [result] The object into which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n */\n\n\nMatrix2.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Matrix2();\n  }\n\n  result[0] = array[startingIndex++];\n  result[1] = array[startingIndex++];\n  result[2] = array[startingIndex++];\n  result[3] = array[startingIndex++];\n  return result;\n};\n/**\n * Duplicates a Matrix2 instance.\n *\n * @param {Matrix2} matrix The matrix to duplicate.\n * @param {Matrix2} [result] The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided. (Returns undefined if matrix is undefined)\n */\n\n\nMatrix2.clone = function (matrix, result) {\n  if (!defined(matrix)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Matrix2(matrix[0], matrix[2], matrix[1], matrix[3]);\n  }\n\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  return result;\n};\n/**\n * Creates a Matrix2 from 4 consecutive elements in an array.\n *\n * @param {Number[]} array The array whose 4 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.\n * @param {Matrix2} [result] The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Create the Matrix2:\n * // [1.0, 2.0]\n * // [1.0, 2.0]\n *\n * var v = [1.0, 1.0, 2.0, 2.0];\n * var m = Cesium.Matrix2.fromArray(v);\n *\n * // Create same Matrix2 with using an offset into an array\n * var v2 = [0.0, 0.0, 1.0, 1.0, 2.0, 2.0];\n * var m2 = Cesium.Matrix2.fromArray(v2, 2);\n */\n\n\nMatrix2.fromArray = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Matrix2();\n  }\n\n  result[0] = array[startingIndex];\n  result[1] = array[startingIndex + 1];\n  result[2] = array[startingIndex + 2];\n  result[3] = array[startingIndex + 3];\n  return result;\n};\n/**\n * Creates a Matrix2 instance from a column-major order array.\n *\n * @param {Number[]} values The column-major order array.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n */\n\n\nMatrix2.fromColumnMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values); //>>includeEnd('debug');\n\n  return Matrix2.clone(values, result);\n};\n/**\n * Creates a Matrix2 instance from a row-major order array.\n * The resulting matrix will be in column-major order.\n *\n * @param {Number[]} values The row-major order array.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n */\n\n\nMatrix2.fromRowMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix2(values[0], values[1], values[2], values[3]);\n  }\n\n  result[0] = values[0];\n  result[1] = values[2];\n  result[2] = values[1];\n  result[3] = values[3];\n  return result;\n};\n/**\n * Computes a Matrix2 instance representing a non-uniform scale.\n *\n * @param {Cartesian2} scale The x and y scale factors.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [7.0, 0.0]\n * //   [0.0, 8.0]\n * var m = Cesium.Matrix2.fromScale(new Cesium.Cartesian2(7.0, 8.0));\n */\n\n\nMatrix2.fromScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scale\", scale); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix2(scale.x, 0.0, 0.0, scale.y);\n  }\n\n  result[0] = scale.x;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = scale.y;\n  return result;\n};\n/**\n * Computes a Matrix2 instance representing a uniform scale.\n *\n * @param {Number} scale The uniform scale factor.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [2.0, 0.0]\n * //   [0.0, 2.0]\n * var m = Cesium.Matrix2.fromUniformScale(2.0);\n */\n\n\nMatrix2.fromUniformScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"scale\", scale); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix2(scale, 0.0, 0.0, scale);\n  }\n\n  result[0] = scale;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = scale;\n  return result;\n};\n/**\n * Creates a rotation matrix.\n *\n * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise.\n * var p = new Cesium.Cartesian2(5, 6);\n * var m = Cesium.Matrix2.fromRotation(Cesium.Math.toRadians(45.0));\n * var rotated = Cesium.Matrix2.multiplyByVector(m, p, new Cesium.Cartesian2());\n */\n\n\nMatrix2.fromRotation = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle); //>>includeEnd('debug');\n\n  var cosAngle = Math.cos(angle);\n  var sinAngle = Math.sin(angle);\n\n  if (!defined(result)) {\n    return new Matrix2(cosAngle, -sinAngle, sinAngle, cosAngle);\n  }\n\n  result[0] = cosAngle;\n  result[1] = sinAngle;\n  result[2] = -sinAngle;\n  result[3] = cosAngle;\n  return result;\n};\n/**\n * Creates an Array from the provided Matrix2 instance.\n * The array will be in column-major order.\n *\n * @param {Matrix2} matrix The matrix to use..\n * @param {Number[]} [result] The Array onto which to store the result.\n * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.\n */\n\n\nMatrix2.toArray = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return [matrix[0], matrix[1], matrix[2], matrix[3]];\n  }\n\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  return result;\n};\n/**\n * Computes the array index of the element at the provided row and column.\n *\n * @param {Number} row The zero-based index of the row.\n * @param {Number} column The zero-based index of the column.\n * @returns {Number} The index of the element at the provided row and column.\n *\n * @exception {DeveloperError} row must be 0 or 1.\n * @exception {DeveloperError} column must be 0 or 1.\n *\n * @example\n * var myMatrix = new Cesium.Matrix2();\n * var column1Row0Index = Cesium.Matrix2.getElementIndex(1, 0);\n * var column1Row0 = myMatrix[column1Row0Index]\n * myMatrix[column1Row0Index] = 10.0;\n */\n\n\nMatrix2.getElementIndex = function (column, row) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"row\", row, 0);\n  Check.typeOf.number.lessThanOrEquals(\"row\", row, 1);\n  Check.typeOf.number.greaterThanOrEquals(\"column\", column, 0);\n  Check.typeOf.number.lessThanOrEquals(\"column\", column, 1); //>>includeEnd('debug');\n\n  return column * 2 + row;\n};\n/**\n * Retrieves a copy of the matrix column at the provided index as a Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {Number} index The zero-based index of the column to retrieve.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\n\n\nMatrix2.getColumn = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var startIndex = index * 2;\n  var x = matrix[startIndex];\n  var y = matrix[startIndex + 1];\n  result.x = x;\n  result.y = y;\n  return result;\n};\n/**\n * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {Number} index The zero-based index of the column to set.\n * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified column.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\n\n\nMatrix2.setColumn = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result = Matrix2.clone(matrix, result);\n  var startIndex = index * 2;\n  result[startIndex] = cartesian.x;\n  result[startIndex + 1] = cartesian.y;\n  return result;\n};\n/**\n * Retrieves a copy of the matrix row at the provided index as a Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {Number} index The zero-based index of the row to retrieve.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\n\n\nMatrix2.getRow = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var x = matrix[index];\n  var y = matrix[index + 2];\n  result.x = x;\n  result.y = y;\n  return result;\n};\n/**\n * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {Number} index The zero-based index of the row to set.\n * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified row.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\n\n\nMatrix2.setRow = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result = Matrix2.clone(matrix, result);\n  result[index] = cartesian.x;\n  result[index + 2] = cartesian.y;\n  return result;\n};\n\nvar scratchColumn = new Cartesian2();\n/**\n * Extracts the non-uniform scale assuming the matrix is an affine transformation.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\n\nMatrix2.getScale = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = Cartesian2.magnitude(Cartesian2.fromElements(matrix[0], matrix[1], scratchColumn));\n  result.y = Cartesian2.magnitude(Cartesian2.fromElements(matrix[2], matrix[3], scratchColumn));\n  return result;\n};\n\nvar scratchScale = new Cartesian2();\n/**\n * Computes the maximum scale assuming the matrix is an affine transformation.\n * The maximum scale is the maximum length of the column vectors.\n *\n * @param {Matrix2} matrix The matrix.\n * @returns {Number} The maximum scale.\n */\n\nMatrix2.getMaximumScale = function (matrix) {\n  Matrix2.getScale(matrix, scratchScale);\n  return Cartesian2.maximumComponent(scratchScale);\n};\n/**\n * Computes the product of two matrices.\n *\n * @param {Matrix2} left The first matrix.\n * @param {Matrix2} right The second matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\n\n\nMatrix2.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var column0Row0 = left[0] * right[0] + left[2] * right[1];\n  var column1Row0 = left[0] * right[2] + left[2] * right[3];\n  var column0Row1 = left[1] * right[0] + left[3] * right[1];\n  var column1Row1 = left[1] * right[2] + left[3] * right[3];\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column1Row0;\n  result[3] = column1Row1;\n  return result;\n};\n/**\n * Computes the sum of two matrices.\n *\n * @param {Matrix2} left The first matrix.\n * @param {Matrix2} right The second matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\n\n\nMatrix2.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result[0] = left[0] + right[0];\n  result[1] = left[1] + right[1];\n  result[2] = left[2] + right[2];\n  result[3] = left[3] + right[3];\n  return result;\n};\n/**\n * Computes the difference of two matrices.\n *\n * @param {Matrix2} left The first matrix.\n * @param {Matrix2} right The second matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\n\n\nMatrix2.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result[0] = left[0] - right[0];\n  result[1] = left[1] - right[1];\n  result[2] = left[2] - right[2];\n  result[3] = left[3] - right[3];\n  return result;\n};\n/**\n * Computes the product of a matrix and a column vector.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Cartesian2} cartesian The column.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\n\n\nMatrix2.multiplyByVector = function (matrix, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var x = matrix[0] * cartesian.x + matrix[2] * cartesian.y;\n  var y = matrix[1] * cartesian.x + matrix[3] * cartesian.y;\n  result.x = x;\n  result.y = y;\n  return result;\n};\n/**\n * Computes the product of a matrix and a scalar.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Number} scalar The number to multiply by.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\n\n\nMatrix2.multiplyByScalar = function (matrix, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scalar;\n  result[1] = matrix[1] * scalar;\n  result[2] = matrix[2] * scalar;\n  result[3] = matrix[3] * scalar;\n  return result;\n};\n/**\n * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.\n *\n * @param {Matrix2} matrix The matrix on the left-hand side.\n * @param {Cartesian2} scale The non-uniform scale on the right-hand side.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n *\n * @example\n * // Instead of Cesium.Matrix2.multiply(m, Cesium.Matrix2.fromScale(scale), m);\n * Cesium.Matrix2.multiplyByScale(m, scale, m);\n *\n * @see Matrix2.fromScale\n * @see Matrix2.multiplyByUniformScale\n */\n\n\nMatrix2.multiplyByScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale.x;\n  result[1] = matrix[1] * scale.x;\n  result[2] = matrix[2] * scale.y;\n  result[3] = matrix[3] * scale.y;\n  return result;\n};\n/**\n * Creates a negated copy of the provided matrix.\n *\n * @param {Matrix2} matrix The matrix to negate.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\n\n\nMatrix2.negate = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result[0] = -matrix[0];\n  result[1] = -matrix[1];\n  result[2] = -matrix[2];\n  result[3] = -matrix[3];\n  return result;\n};\n/**\n * Computes the transpose of the provided matrix.\n *\n * @param {Matrix2} matrix The matrix to transpose.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\n\n\nMatrix2.transpose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var column0Row0 = matrix[0];\n  var column0Row1 = matrix[2];\n  var column1Row0 = matrix[1];\n  var column1Row1 = matrix[3];\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column1Row0;\n  result[3] = column1Row1;\n  return result;\n};\n/**\n * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.\n *\n * @param {Matrix2} matrix The matrix with signed elements.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\n\n\nMatrix2.abs = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result[0] = Math.abs(matrix[0]);\n  result[1] = Math.abs(matrix[1]);\n  result[2] = Math.abs(matrix[2]);\n  result[3] = Math.abs(matrix[3]);\n  return result;\n};\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix2} [left] The first matrix.\n * @param {Matrix2} [right] The second matrix.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\n\n\nMatrix2.equals = function (left, right) {\n  return left === right || defined(left) && defined(right) && left[0] === right[0] && left[1] === right[1] && left[2] === right[2] && left[3] === right[3];\n};\n/**\n * @private\n */\n\n\nMatrix2.equalsArray = function (matrix, array, offset) {\n  return matrix[0] === array[offset] && matrix[1] === array[offset + 1] && matrix[2] === array[offset + 2] && matrix[3] === array[offset + 3];\n};\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix2} [left] The first matrix.\n * @param {Matrix2} [right] The second matrix.\n * @param {Number} epsilon The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\n\n\nMatrix2.equalsEpsilon = function (left, right, epsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"epsilon\", epsilon); //>>includeEnd('debug');\n\n  return left === right || defined(left) && defined(right) && Math.abs(left[0] - right[0]) <= epsilon && Math.abs(left[1] - right[1]) <= epsilon && Math.abs(left[2] - right[2]) <= epsilon && Math.abs(left[3] - right[3]) <= epsilon;\n};\n/**\n * An immutable Matrix2 instance initialized to the identity matrix.\n *\n * @type {Matrix2}\n * @constant\n */\n\n\nMatrix2.IDENTITY = Object.freeze(new Matrix2(1.0, 0.0, 0.0, 1.0));\n/**\n * An immutable Matrix2 instance initialized to the zero matrix.\n *\n * @type {Matrix2}\n * @constant\n */\n\nMatrix2.ZERO = Object.freeze(new Matrix2(0.0, 0.0, 0.0, 0.0));\n/**\n * The index into Matrix2 for column 0, row 0.\n *\n * @type {Number}\n * @constant\n *\n * @example\n * var matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN0ROW0] = 5.0; // set column 0, row 0 to 5.0\n */\n\nMatrix2.COLUMN0ROW0 = 0;\n/**\n * The index into Matrix2 for column 0, row 1.\n *\n * @type {Number}\n * @constant\n *\n * @example\n * var matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN0ROW1] = 5.0; // set column 0, row 1 to 5.0\n */\n\nMatrix2.COLUMN0ROW1 = 1;\n/**\n * The index into Matrix2 for column 1, row 0.\n *\n * @type {Number}\n * @constant\n *\n * @example\n * var matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN1ROW0] = 5.0; // set column 1, row 0 to 5.0\n */\n\nMatrix2.COLUMN1ROW0 = 2;\n/**\n * The index into Matrix2 for column 1, row 1.\n *\n * @type {Number}\n * @constant\n *\n * @example\n * var matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN1ROW1] = 5.0; // set column 1, row 1 to 5.0\n */\n\nMatrix2.COLUMN1ROW1 = 3;\nObject.defineProperties(Matrix2.prototype, {\n  /**\n   * Gets the number of items in the collection.\n   * @memberof Matrix2.prototype\n   *\n   * @type {Number}\n   */\n  length: {\n    get: function () {\n      return Matrix2.packedLength;\n    }\n  }\n});\n/**\n * Duplicates the provided Matrix2 instance.\n *\n * @param {Matrix2} [result] The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n */\n\nMatrix2.prototype.clone = function (result) {\n  return Matrix2.clone(this, result);\n};\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix2} [right] The right hand side matrix.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\n\n\nMatrix2.prototype.equals = function (right) {\n  return Matrix2.equals(this, right);\n};\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix2} [right] The right hand side matrix.\n * @param {Number} epsilon The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\n\n\nMatrix2.prototype.equalsEpsilon = function (right, epsilon) {\n  return Matrix2.equalsEpsilon(this, right, epsilon);\n};\n/**\n * Creates a string representing this Matrix with each row being\n * on a separate line and in the format '(column0, column1)'.\n *\n * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1)'.\n */\n\n\nMatrix2.prototype.toString = function () {\n  return \"(\" + this[0] + \", \" + this[2] + \")\\n\" + \"(\" + this[1] + \", \" + this[3] + \")\";\n};\n\nexport default Matrix2;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/Matrix2.js"],"names":["Cartesian2","Check","defaultValue","defined","Matrix2","column0Row0","column1Row0","column0Row1","column1Row1","packedLength","pack","value","array","startingIndex","typeOf","object","unpack","result","clone","matrix","undefined","fromArray","fromColumnMajorArray","values","fromRowMajorArray","fromScale","scale","x","y","fromUniformScale","number","fromRotation","angle","cosAngle","Math","cos","sinAngle","sin","toArray","getElementIndex","column","row","greaterThanOrEquals","lessThanOrEquals","getColumn","index","startIndex","setColumn","cartesian","getRow","setRow","scratchColumn","getScale","magnitude","fromElements","scratchScale","getMaximumScale","maximumComponent","multiply","left","right","add","subtract","multiplyByVector","multiplyByScalar","scalar","multiplyByScale","negate","transpose","abs","equals","equalsArray","offset","equalsEpsilon","epsilon","IDENTITY","Object","freeze","ZERO","COLUMN0ROW0","COLUMN0ROW1","COLUMN1ROW0","COLUMN1ROW1","defineProperties","prototype","length","get","toString"],"mappings":"AAAA,OAAOA,UAAP,MAAuB,iBAAvB;AACA,OAAOC,KAAP,MAAkB,YAAlB;AACA,OAAOC,YAAP,MAAyB,mBAAzB;AACA,OAAOC,OAAP,MAAoB,cAApB;AAEA;;;;;;;;;;;;;;;;;;;AAkBA,SAASC,OAAT,CAAiBC,WAAjB,EAA8BC,WAA9B,EAA2CC,WAA3C,EAAwDC,WAAxD,EAAqE;AACnE,OAAK,CAAL,IAAUN,YAAY,CAACG,WAAD,EAAc,GAAd,CAAtB;AACA,OAAK,CAAL,IAAUH,YAAY,CAACK,WAAD,EAAc,GAAd,CAAtB;AACA,OAAK,CAAL,IAAUL,YAAY,CAACI,WAAD,EAAc,GAAd,CAAtB;AACA,OAAK,CAAL,IAAUJ,YAAY,CAACM,WAAD,EAAc,GAAd,CAAtB;AACD;AAED;;;;;;AAIAJ,OAAO,CAACK,YAAR,GAAuB,CAAvB;AAEA;;;;;;;;;;AASAL,OAAO,CAACM,IAAR,GAAe,UAAUC,KAAV,EAAiBC,KAAjB,EAAwBC,aAAxB,EAAuC;AACpD;AACAZ,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,OAApB,EAA6BJ,KAA7B;AACAV,EAAAA,KAAK,CAACE,OAAN,CAAc,OAAd,EAAuBS,KAAvB,EAHoD,CAIpD;;AAEAC,EAAAA,aAAa,GAAGX,YAAY,CAACW,aAAD,EAAgB,CAAhB,CAA5B;AAEAD,EAAAA,KAAK,CAACC,aAAa,EAAd,CAAL,GAAyBF,KAAK,CAAC,CAAD,CAA9B;AACAC,EAAAA,KAAK,CAACC,aAAa,EAAd,CAAL,GAAyBF,KAAK,CAAC,CAAD,CAA9B;AACAC,EAAAA,KAAK,CAACC,aAAa,EAAd,CAAL,GAAyBF,KAAK,CAAC,CAAD,CAA9B;AACAC,EAAAA,KAAK,CAACC,aAAa,EAAd,CAAL,GAAyBF,KAAK,CAAC,CAAD,CAA9B;AAEA,SAAOC,KAAP;AACD,CAdD;AAgBA;;;;;;;;;;AAQAR,OAAO,CAACY,MAAR,GAAiB,UAAUJ,KAAV,EAAiBC,aAAjB,EAAgCI,MAAhC,EAAwC;AACvD;AACAhB,EAAAA,KAAK,CAACE,OAAN,CAAc,OAAd,EAAuBS,KAAvB,EAFuD,CAGvD;;AAEAC,EAAAA,aAAa,GAAGX,YAAY,CAACW,aAAD,EAAgB,CAAhB,CAA5B;;AAEA,MAAI,CAACV,OAAO,CAACc,MAAD,CAAZ,EAAsB;AACpBA,IAAAA,MAAM,GAAG,IAAIb,OAAJ,EAAT;AACD;;AAEDa,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYL,KAAK,CAACC,aAAa,EAAd,CAAjB;AACAI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYL,KAAK,CAACC,aAAa,EAAd,CAAjB;AACAI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYL,KAAK,CAACC,aAAa,EAAd,CAAjB;AACAI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYL,KAAK,CAACC,aAAa,EAAd,CAAjB;AACA,SAAOI,MAAP;AACD,CAhBD;AAkBA;;;;;;;;;AAOAb,OAAO,CAACc,KAAR,GAAgB,UAAUC,MAAV,EAAkBF,MAAlB,EAA0B;AACxC,MAAI,CAACd,OAAO,CAACgB,MAAD,CAAZ,EAAsB;AACpB,WAAOC,SAAP;AACD;;AACD,MAAI,CAACjB,OAAO,CAACc,MAAD,CAAZ,EAAsB;AACpB,WAAO,IAAIb,OAAJ,CAAYe,MAAM,CAAC,CAAD,CAAlB,EAAuBA,MAAM,CAAC,CAAD,CAA7B,EAAkCA,MAAM,CAAC,CAAD,CAAxC,EAA6CA,MAAM,CAAC,CAAD,CAAnD,CAAP;AACD;;AACDF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAlB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAlB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAlB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAlB;AACA,SAAOF,MAAP;AACD,CAZD;AAcA;;;;;;;;;;;;;;;;;;;;;;AAoBAb,OAAO,CAACiB,SAAR,GAAoB,UAAUT,KAAV,EAAiBC,aAAjB,EAAgCI,MAAhC,EAAwC;AAC1D;AACAhB,EAAAA,KAAK,CAACE,OAAN,CAAc,OAAd,EAAuBS,KAAvB,EAF0D,CAG1D;;AAEAC,EAAAA,aAAa,GAAGX,YAAY,CAACW,aAAD,EAAgB,CAAhB,CAA5B;;AAEA,MAAI,CAACV,OAAO,CAACc,MAAD,CAAZ,EAAsB;AACpBA,IAAAA,MAAM,GAAG,IAAIb,OAAJ,EAAT;AACD;;AAEDa,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYL,KAAK,CAACC,aAAD,CAAjB;AACAI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYL,KAAK,CAACC,aAAa,GAAG,CAAjB,CAAjB;AACAI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYL,KAAK,CAACC,aAAa,GAAG,CAAjB,CAAjB;AACAI,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYL,KAAK,CAACC,aAAa,GAAG,CAAjB,CAAjB;AACA,SAAOI,MAAP;AACD,CAhBD;AAkBA;;;;;;;;;AAOAb,OAAO,CAACkB,oBAAR,GAA+B,UAAUC,MAAV,EAAkBN,MAAlB,EAA0B;AACvD;AACAhB,EAAAA,KAAK,CAACE,OAAN,CAAc,QAAd,EAAwBoB,MAAxB,EAFuD,CAGvD;;AAEA,SAAOnB,OAAO,CAACc,KAAR,CAAcK,MAAd,EAAsBN,MAAtB,CAAP;AACD,CAND;AAQA;;;;;;;;;;AAQAb,OAAO,CAACoB,iBAAR,GAA4B,UAAUD,MAAV,EAAkBN,MAAlB,EAA0B;AACpD;AACAhB,EAAAA,KAAK,CAACE,OAAN,CAAc,QAAd,EAAwBoB,MAAxB,EAFoD,CAGpD;;AAEA,MAAI,CAACpB,OAAO,CAACc,MAAD,CAAZ,EAAsB;AACpB,WAAO,IAAIb,OAAJ,CAAYmB,MAAM,CAAC,CAAD,CAAlB,EAAuBA,MAAM,CAAC,CAAD,CAA7B,EAAkCA,MAAM,CAAC,CAAD,CAAxC,EAA6CA,MAAM,CAAC,CAAD,CAAnD,CAAP;AACD;;AACDN,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYM,MAAM,CAAC,CAAD,CAAlB;AACAN,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYM,MAAM,CAAC,CAAD,CAAlB;AACAN,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYM,MAAM,CAAC,CAAD,CAAlB;AACAN,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYM,MAAM,CAAC,CAAD,CAAlB;AACA,SAAON,MAAP;AACD,CAbD;AAeA;;;;;;;;;;;;;;;AAaAb,OAAO,CAACqB,SAAR,GAAoB,UAAUC,KAAV,EAAiBT,MAAjB,EAAyB;AAC3C;AACAhB,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,OAApB,EAA6BW,KAA7B,EAF2C,CAG3C;;AAEA,MAAI,CAACvB,OAAO,CAACc,MAAD,CAAZ,EAAsB;AACpB,WAAO,IAAIb,OAAJ,CAAYsB,KAAK,CAACC,CAAlB,EAAqB,GAArB,EAA0B,GAA1B,EAA+BD,KAAK,CAACE,CAArC,CAAP;AACD;;AAEDX,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYS,KAAK,CAACC,CAAlB;AACAV,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYS,KAAK,CAACE,CAAlB;AACA,SAAOX,MAAP;AACD,CAdD;AAgBA;;;;;;;;;;;;;;;AAaAb,OAAO,CAACyB,gBAAR,GAA2B,UAAUH,KAAV,EAAiBT,MAAjB,EAAyB;AAClD;AACAhB,EAAAA,KAAK,CAACa,MAAN,CAAagB,MAAb,CAAoB,OAApB,EAA6BJ,KAA7B,EAFkD,CAGlD;;AAEA,MAAI,CAACvB,OAAO,CAACc,MAAD,CAAZ,EAAsB;AACpB,WAAO,IAAIb,OAAJ,CAAYsB,KAAZ,EAAmB,GAAnB,EAAwB,GAAxB,EAA6BA,KAA7B,CAAP;AACD;;AAEDT,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYS,KAAZ;AACAT,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,GAAZ;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYS,KAAZ;AACA,SAAOT,MAAP;AACD,CAdD;AAgBA;;;;;;;;;;;;;;;AAaAb,OAAO,CAAC2B,YAAR,GAAuB,UAAUC,KAAV,EAAiBf,MAAjB,EAAyB;AAC9C;AACAhB,EAAAA,KAAK,CAACa,MAAN,CAAagB,MAAb,CAAoB,OAApB,EAA6BE,KAA7B,EAF8C,CAG9C;;AAEA,MAAIC,QAAQ,GAAGC,IAAI,CAACC,GAAL,CAASH,KAAT,CAAf;AACA,MAAII,QAAQ,GAAGF,IAAI,CAACG,GAAL,CAASL,KAAT,CAAf;;AAEA,MAAI,CAAC7B,OAAO,CAACc,MAAD,CAAZ,EAAsB;AACpB,WAAO,IAAIb,OAAJ,CAAY6B,QAAZ,EAAsB,CAACG,QAAvB,EAAiCA,QAAjC,EAA2CH,QAA3C,CAAP;AACD;;AACDhB,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgB,QAAZ;AACAhB,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYmB,QAAZ;AACAnB,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAACmB,QAAb;AACAnB,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYgB,QAAZ;AACA,SAAOhB,MAAP;AACD,CAhBD;AAkBA;;;;;;;;;;AAQAb,OAAO,CAACkC,OAAR,GAAkB,UAAUnB,MAAV,EAAkBF,MAAlB,EAA0B;AAC1C;AACAhB,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B,EAF0C,CAG1C;;AAEA,MAAI,CAAChB,OAAO,CAACc,MAAD,CAAZ,EAAsB;AACpB,WAAO,CAACE,MAAM,CAAC,CAAD,CAAP,EAAYA,MAAM,CAAC,CAAD,CAAlB,EAAuBA,MAAM,CAAC,CAAD,CAA7B,EAAkCA,MAAM,CAAC,CAAD,CAAxC,CAAP;AACD;;AACDF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAlB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAlB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAlB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAlB;AACA,SAAOF,MAAP;AACD,CAbD;AAeA;;;;;;;;;;;;;;;;;;AAgBAb,OAAO,CAACmC,eAAR,GAA0B,UAAUC,MAAV,EAAkBC,GAAlB,EAAuB;AAC/C;AACAxC,EAAAA,KAAK,CAACa,MAAN,CAAagB,MAAb,CAAoBY,mBAApB,CAAwC,KAAxC,EAA+CD,GAA/C,EAAoD,CAApD;AACAxC,EAAAA,KAAK,CAACa,MAAN,CAAagB,MAAb,CAAoBa,gBAApB,CAAqC,KAArC,EAA4CF,GAA5C,EAAiD,CAAjD;AAEAxC,EAAAA,KAAK,CAACa,MAAN,CAAagB,MAAb,CAAoBY,mBAApB,CAAwC,QAAxC,EAAkDF,MAAlD,EAA0D,CAA1D;AACAvC,EAAAA,KAAK,CAACa,MAAN,CAAagB,MAAb,CAAoBa,gBAApB,CAAqC,QAArC,EAA+CH,MAA/C,EAAuD,CAAvD,EAN+C,CAO/C;;AAEA,SAAOA,MAAM,GAAG,CAAT,GAAaC,GAApB;AACD,CAVD;AAYA;;;;;;;;;;;;AAUArC,OAAO,CAACwC,SAAR,GAAoB,UAAUzB,MAAV,EAAkB0B,KAAlB,EAAyB5B,MAAzB,EAAiC;AACnD;AACAhB,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B;AAEAlB,EAAAA,KAAK,CAACa,MAAN,CAAagB,MAAb,CAAoBY,mBAApB,CAAwC,OAAxC,EAAiDG,KAAjD,EAAwD,CAAxD;AACA5C,EAAAA,KAAK,CAACa,MAAN,CAAagB,MAAb,CAAoBa,gBAApB,CAAqC,OAArC,EAA8CE,KAA9C,EAAqD,CAArD;AAEA5C,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAPmD,CAQnD;;AAEA,MAAI6B,UAAU,GAAGD,KAAK,GAAG,CAAzB;AACA,MAAIlB,CAAC,GAAGR,MAAM,CAAC2B,UAAD,CAAd;AACA,MAAIlB,CAAC,GAAGT,MAAM,CAAC2B,UAAU,GAAG,CAAd,CAAd;AAEA7B,EAAAA,MAAM,CAACU,CAAP,GAAWA,CAAX;AACAV,EAAAA,MAAM,CAACW,CAAP,GAAWA,CAAX;AACA,SAAOX,MAAP;AACD,CAjBD;AAmBA;;;;;;;;;;;;;AAWAb,OAAO,CAAC2C,SAAR,GAAoB,UAAU5B,MAAV,EAAkB0B,KAAlB,EAAyBG,SAAzB,EAAoC/B,MAApC,EAA4C;AAC9D;AACAhB,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B;AAEAlB,EAAAA,KAAK,CAACa,MAAN,CAAagB,MAAb,CAAoBY,mBAApB,CAAwC,OAAxC,EAAiDG,KAAjD,EAAwD,CAAxD;AACA5C,EAAAA,KAAK,CAACa,MAAN,CAAagB,MAAb,CAAoBa,gBAApB,CAAqC,OAArC,EAA8CE,KAA9C,EAAqD,CAArD;AAEA5C,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,WAApB,EAAiCiC,SAAjC;AACA/C,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAR8D,CAS9D;;AAEAA,EAAAA,MAAM,GAAGb,OAAO,CAACc,KAAR,CAAcC,MAAd,EAAsBF,MAAtB,CAAT;AACA,MAAI6B,UAAU,GAAGD,KAAK,GAAG,CAAzB;AACA5B,EAAAA,MAAM,CAAC6B,UAAD,CAAN,GAAqBE,SAAS,CAACrB,CAA/B;AACAV,EAAAA,MAAM,CAAC6B,UAAU,GAAG,CAAd,CAAN,GAAyBE,SAAS,CAACpB,CAAnC;AACA,SAAOX,MAAP;AACD,CAhBD;AAkBA;;;;;;;;;;;;AAUAb,OAAO,CAAC6C,MAAR,GAAiB,UAAU9B,MAAV,EAAkB0B,KAAlB,EAAyB5B,MAAzB,EAAiC;AAChD;AACAhB,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B;AAEAlB,EAAAA,KAAK,CAACa,MAAN,CAAagB,MAAb,CAAoBY,mBAApB,CAAwC,OAAxC,EAAiDG,KAAjD,EAAwD,CAAxD;AACA5C,EAAAA,KAAK,CAACa,MAAN,CAAagB,MAAb,CAAoBa,gBAApB,CAAqC,OAArC,EAA8CE,KAA9C,EAAqD,CAArD;AAEA5C,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAPgD,CAQhD;;AAEA,MAAIU,CAAC,GAAGR,MAAM,CAAC0B,KAAD,CAAd;AACA,MAAIjB,CAAC,GAAGT,MAAM,CAAC0B,KAAK,GAAG,CAAT,CAAd;AAEA5B,EAAAA,MAAM,CAACU,CAAP,GAAWA,CAAX;AACAV,EAAAA,MAAM,CAACW,CAAP,GAAWA,CAAX;AACA,SAAOX,MAAP;AACD,CAhBD;AAkBA;;;;;;;;;;;;;AAWAb,OAAO,CAAC8C,MAAR,GAAiB,UAAU/B,MAAV,EAAkB0B,KAAlB,EAAyBG,SAAzB,EAAoC/B,MAApC,EAA4C;AAC3D;AACAhB,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B;AAEAlB,EAAAA,KAAK,CAACa,MAAN,CAAagB,MAAb,CAAoBY,mBAApB,CAAwC,OAAxC,EAAiDG,KAAjD,EAAwD,CAAxD;AACA5C,EAAAA,KAAK,CAACa,MAAN,CAAagB,MAAb,CAAoBa,gBAApB,CAAqC,OAArC,EAA8CE,KAA9C,EAAqD,CAArD;AAEA5C,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,WAApB,EAAiCiC,SAAjC;AACA/C,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAR2D,CAS3D;;AAEAA,EAAAA,MAAM,GAAGb,OAAO,CAACc,KAAR,CAAcC,MAAd,EAAsBF,MAAtB,CAAT;AACAA,EAAAA,MAAM,CAAC4B,KAAD,CAAN,GAAgBG,SAAS,CAACrB,CAA1B;AACAV,EAAAA,MAAM,CAAC4B,KAAK,GAAG,CAAT,CAAN,GAAoBG,SAAS,CAACpB,CAA9B;AACA,SAAOX,MAAP;AACD,CAfD;;AAiBA,IAAIkC,aAAa,GAAG,IAAInD,UAAJ,EAApB;AAEA;;;;;;;;AAOAI,OAAO,CAACgD,QAAR,GAAmB,UAAUjC,MAAV,EAAkBF,MAAlB,EAA0B;AAC3C;AACAhB,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B;AACAlB,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAH2C,CAI3C;;AAEAA,EAAAA,MAAM,CAACU,CAAP,GAAW3B,UAAU,CAACqD,SAAX,CACTrD,UAAU,CAACsD,YAAX,CAAwBnC,MAAM,CAAC,CAAD,CAA9B,EAAmCA,MAAM,CAAC,CAAD,CAAzC,EAA8CgC,aAA9C,CADS,CAAX;AAGAlC,EAAAA,MAAM,CAACW,CAAP,GAAW5B,UAAU,CAACqD,SAAX,CACTrD,UAAU,CAACsD,YAAX,CAAwBnC,MAAM,CAAC,CAAD,CAA9B,EAAmCA,MAAM,CAAC,CAAD,CAAzC,EAA8CgC,aAA9C,CADS,CAAX;AAGA,SAAOlC,MAAP;AACD,CAbD;;AAeA,IAAIsC,YAAY,GAAG,IAAIvD,UAAJ,EAAnB;AAEA;;;;;;;;AAOAI,OAAO,CAACoD,eAAR,GAA0B,UAAUrC,MAAV,EAAkB;AAC1Cf,EAAAA,OAAO,CAACgD,QAAR,CAAiBjC,MAAjB,EAAyBoC,YAAzB;AACA,SAAOvD,UAAU,CAACyD,gBAAX,CAA4BF,YAA5B,CAAP;AACD,CAHD;AAKA;;;;;;;;;;AAQAnD,OAAO,CAACsD,QAAR,GAAmB,UAAUC,IAAV,EAAgBC,KAAhB,EAAuB3C,MAAvB,EAA+B;AAChD;AACAhB,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,MAApB,EAA4B4C,IAA5B;AACA1D,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,OAApB,EAA6B6C,KAA7B;AACA3D,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAJgD,CAKhD;;AAEA,MAAIZ,WAAW,GAAGsD,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAf,GAAqBD,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAtD;AACA,MAAItD,WAAW,GAAGqD,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAf,GAAqBD,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAtD;AACA,MAAIrD,WAAW,GAAGoD,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAf,GAAqBD,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAtD;AACA,MAAIpD,WAAW,GAAGmD,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAf,GAAqBD,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAtD;AAEA3C,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYZ,WAAZ;AACAY,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYV,WAAZ;AACAU,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYX,WAAZ;AACAW,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYT,WAAZ;AACA,SAAOS,MAAP;AACD,CAjBD;AAmBA;;;;;;;;;;AAQAb,OAAO,CAACyD,GAAR,GAAc,UAAUF,IAAV,EAAgBC,KAAhB,EAAuB3C,MAAvB,EAA+B;AAC3C;AACAhB,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,MAApB,EAA4B4C,IAA5B;AACA1D,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,OAApB,EAA6B6C,KAA7B;AACA3D,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAJ2C,CAK3C;;AAEAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY0C,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAA3B;AACA3C,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY0C,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAA3B;AACA3C,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY0C,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAA3B;AACA3C,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY0C,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAA3B;AACA,SAAO3C,MAAP;AACD,CAZD;AAcA;;;;;;;;;;AAQAb,OAAO,CAAC0D,QAAR,GAAmB,UAAUH,IAAV,EAAgBC,KAAhB,EAAuB3C,MAAvB,EAA+B;AAChD;AACAhB,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,MAApB,EAA4B4C,IAA5B;AACA1D,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,OAApB,EAA6B6C,KAA7B;AACA3D,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAJgD,CAKhD;;AAEAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY0C,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAA3B;AACA3C,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY0C,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAA3B;AACA3C,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY0C,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAA3B;AACA3C,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY0C,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAA3B;AACA,SAAO3C,MAAP;AACD,CAZD;AAcA;;;;;;;;;;AAQAb,OAAO,CAAC2D,gBAAR,GAA2B,UAAU5C,MAAV,EAAkB6B,SAAlB,EAA6B/B,MAA7B,EAAqC;AAC9D;AACAhB,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B;AACAlB,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,WAApB,EAAiCiC,SAAjC;AACA/C,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAJ8D,CAK9D;;AAEA,MAAIU,CAAC,GAAGR,MAAM,CAAC,CAAD,CAAN,GAAY6B,SAAS,CAACrB,CAAtB,GAA0BR,MAAM,CAAC,CAAD,CAAN,GAAY6B,SAAS,CAACpB,CAAxD;AACA,MAAIA,CAAC,GAAGT,MAAM,CAAC,CAAD,CAAN,GAAY6B,SAAS,CAACrB,CAAtB,GAA0BR,MAAM,CAAC,CAAD,CAAN,GAAY6B,SAAS,CAACpB,CAAxD;AAEAX,EAAAA,MAAM,CAACU,CAAP,GAAWA,CAAX;AACAV,EAAAA,MAAM,CAACW,CAAP,GAAWA,CAAX;AACA,SAAOX,MAAP;AACD,CAbD;AAeA;;;;;;;;;;AAQAb,OAAO,CAAC4D,gBAAR,GAA2B,UAAU7C,MAAV,EAAkB8C,MAAlB,EAA0BhD,MAA1B,EAAkC;AAC3D;AACAhB,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B;AACAlB,EAAAA,KAAK,CAACa,MAAN,CAAagB,MAAb,CAAoB,QAApB,EAA8BmC,MAA9B;AACAhE,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAJ2D,CAK3D;;AAEAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAN,GAAY8C,MAAxB;AACAhD,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAN,GAAY8C,MAAxB;AACAhD,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAN,GAAY8C,MAAxB;AACAhD,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAN,GAAY8C,MAAxB;AACA,SAAOhD,MAAP;AACD,CAZD;AAcA;;;;;;;;;;;;;;;;;;AAgBAb,OAAO,CAAC8D,eAAR,GAA0B,UAAU/C,MAAV,EAAkBO,KAAlB,EAAyBT,MAAzB,EAAiC;AACzD;AACAhB,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B;AACAlB,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,OAApB,EAA6BW,KAA7B;AACAzB,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAJyD,CAKzD;;AAEAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAN,GAAYO,KAAK,CAACC,CAA9B;AACAV,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAN,GAAYO,KAAK,CAACC,CAA9B;AACAV,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAN,GAAYO,KAAK,CAACE,CAA9B;AACAX,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYE,MAAM,CAAC,CAAD,CAAN,GAAYO,KAAK,CAACE,CAA9B;AACA,SAAOX,MAAP;AACD,CAZD;AAcA;;;;;;;;;AAOAb,OAAO,CAAC+D,MAAR,GAAiB,UAAUhD,MAAV,EAAkBF,MAAlB,EAA0B;AACzC;AACAhB,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B;AACAlB,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAHyC,CAIzC;;AAEAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAACE,MAAM,CAAC,CAAD,CAAnB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAACE,MAAM,CAAC,CAAD,CAAnB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAACE,MAAM,CAAC,CAAD,CAAnB;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAACE,MAAM,CAAC,CAAD,CAAnB;AACA,SAAOF,MAAP;AACD,CAXD;AAaA;;;;;;;;;AAOAb,OAAO,CAACgE,SAAR,GAAoB,UAAUjD,MAAV,EAAkBF,MAAlB,EAA0B;AAC5C;AACAhB,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B;AACAlB,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAH4C,CAI5C;;AAEA,MAAIZ,WAAW,GAAGc,MAAM,CAAC,CAAD,CAAxB;AACA,MAAIZ,WAAW,GAAGY,MAAM,CAAC,CAAD,CAAxB;AACA,MAAIb,WAAW,GAAGa,MAAM,CAAC,CAAD,CAAxB;AACA,MAAIX,WAAW,GAAGW,MAAM,CAAC,CAAD,CAAxB;AAEAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYZ,WAAZ;AACAY,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYV,WAAZ;AACAU,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYX,WAAZ;AACAW,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYT,WAAZ;AACA,SAAOS,MAAP;AACD,CAhBD;AAkBA;;;;;;;;;AAOAb,OAAO,CAACiE,GAAR,GAAc,UAAUlD,MAAV,EAAkBF,MAAlB,EAA0B;AACtC;AACAhB,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BI,MAA9B;AACAlB,EAAAA,KAAK,CAACa,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BE,MAA9B,EAHsC,CAItC;;AAEAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYiB,IAAI,CAACmC,GAAL,CAASlD,MAAM,CAAC,CAAD,CAAf,CAAZ;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYiB,IAAI,CAACmC,GAAL,CAASlD,MAAM,CAAC,CAAD,CAAf,CAAZ;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYiB,IAAI,CAACmC,GAAL,CAASlD,MAAM,CAAC,CAAD,CAAf,CAAZ;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYiB,IAAI,CAACmC,GAAL,CAASlD,MAAM,CAAC,CAAD,CAAf,CAAZ;AAEA,SAAOF,MAAP;AACD,CAZD;AAcA;;;;;;;;;;AAQAb,OAAO,CAACkE,MAAR,GAAiB,UAAUX,IAAV,EAAgBC,KAAhB,EAAuB;AACtC,SACED,IAAI,KAAKC,KAAT,IACCzD,OAAO,CAACwD,IAAD,CAAP,IACCxD,OAAO,CAACyD,KAAD,CADR,IAECD,IAAI,CAAC,CAAD,CAAJ,KAAYC,KAAK,CAAC,CAAD,CAFlB,IAGCD,IAAI,CAAC,CAAD,CAAJ,KAAYC,KAAK,CAAC,CAAD,CAHlB,IAICD,IAAI,CAAC,CAAD,CAAJ,KAAYC,KAAK,CAAC,CAAD,CAJlB,IAKCD,IAAI,CAAC,CAAD,CAAJ,KAAYC,KAAK,CAAC,CAAD,CAPrB;AASD,CAVD;AAYA;;;;;AAGAxD,OAAO,CAACmE,WAAR,GAAsB,UAAUpD,MAAV,EAAkBP,KAAlB,EAAyB4D,MAAzB,EAAiC;AACrD,SACErD,MAAM,CAAC,CAAD,CAAN,KAAcP,KAAK,CAAC4D,MAAD,CAAnB,IACArD,MAAM,CAAC,CAAD,CAAN,KAAcP,KAAK,CAAC4D,MAAM,GAAG,CAAV,CADnB,IAEArD,MAAM,CAAC,CAAD,CAAN,KAAcP,KAAK,CAAC4D,MAAM,GAAG,CAAV,CAFnB,IAGArD,MAAM,CAAC,CAAD,CAAN,KAAcP,KAAK,CAAC4D,MAAM,GAAG,CAAV,CAJrB;AAMD,CAPD;AASA;;;;;;;;;;;;AAUApE,OAAO,CAACqE,aAAR,GAAwB,UAAUd,IAAV,EAAgBC,KAAhB,EAAuBc,OAAvB,EAAgC;AACtD;AACAzE,EAAAA,KAAK,CAACa,MAAN,CAAagB,MAAb,CAAoB,SAApB,EAA+B4C,OAA/B,EAFsD,CAGtD;;AAEA,SACEf,IAAI,KAAKC,KAAT,IACCzD,OAAO,CAACwD,IAAD,CAAP,IACCxD,OAAO,CAACyD,KAAD,CADR,IAEC1B,IAAI,CAACmC,GAAL,CAASV,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAxB,KAAgCc,OAFjC,IAGCxC,IAAI,CAACmC,GAAL,CAASV,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAxB,KAAgCc,OAHjC,IAICxC,IAAI,CAACmC,GAAL,CAASV,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAxB,KAAgCc,OAJjC,IAKCxC,IAAI,CAACmC,GAAL,CAASV,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAxB,KAAgCc,OAPpC;AASD,CAdD;AAgBA;;;;;;;;AAMAtE,OAAO,CAACuE,QAAR,GAAmBC,MAAM,CAACC,MAAP,CAAc,IAAIzE,OAAJ,CAAY,GAAZ,EAAiB,GAAjB,EAAsB,GAAtB,EAA2B,GAA3B,CAAd,CAAnB;AAEA;;;;;;;AAMAA,OAAO,CAAC0E,IAAR,GAAeF,MAAM,CAACC,MAAP,CAAc,IAAIzE,OAAJ,CAAY,GAAZ,EAAiB,GAAjB,EAAsB,GAAtB,EAA2B,GAA3B,CAAd,CAAf;AAEA;;;;;;;;;;;AAUAA,OAAO,CAAC2E,WAAR,GAAsB,CAAtB;AAEA;;;;;;;;;;;AAUA3E,OAAO,CAAC4E,WAAR,GAAsB,CAAtB;AAEA;;;;;;;;;;;AAUA5E,OAAO,CAAC6E,WAAR,GAAsB,CAAtB;AAEA;;;;;;;;;;;AAUA7E,OAAO,CAAC8E,WAAR,GAAsB,CAAtB;AAEAN,MAAM,CAACO,gBAAP,CAAwB/E,OAAO,CAACgF,SAAhC,EAA2C;AACzC;;;;;;AAMAC,EAAAA,MAAM,EAAE;AACNC,IAAAA,GAAG,EAAE,YAAY;AACf,aAAOlF,OAAO,CAACK,YAAf;AACD;AAHK;AAPiC,CAA3C;AAcA;;;;;;;AAMAL,OAAO,CAACgF,SAAR,CAAkBlE,KAAlB,GAA0B,UAAUD,MAAV,EAAkB;AAC1C,SAAOb,OAAO,CAACc,KAAR,CAAc,IAAd,EAAoBD,MAApB,CAAP;AACD,CAFD;AAIA;;;;;;;;;AAOAb,OAAO,CAACgF,SAAR,CAAkBd,MAAlB,GAA2B,UAAUV,KAAV,EAAiB;AAC1C,SAAOxD,OAAO,CAACkE,MAAR,CAAe,IAAf,EAAqBV,KAArB,CAAP;AACD,CAFD;AAIA;;;;;;;;;;;AASAxD,OAAO,CAACgF,SAAR,CAAkBX,aAAlB,GAAkC,UAAUb,KAAV,EAAiBc,OAAjB,EAA0B;AAC1D,SAAOtE,OAAO,CAACqE,aAAR,CAAsB,IAAtB,EAA4Bb,KAA5B,EAAmCc,OAAnC,CAAP;AACD,CAFD;AAIA;;;;;;;;AAMAtE,OAAO,CAACgF,SAAR,CAAkBG,QAAlB,GAA6B,YAAY;AACvC,SACE,MACA,KAAK,CAAL,CADA,GAEA,IAFA,GAGA,KAAK,CAAL,CAHA,GAIA,KAJA,GAKA,GALA,GAMA,KAAK,CAAL,CANA,GAOA,IAPA,GAQA,KAAK,CAAL,CARA,GASA,GAVF;AAYD,CAbD;;AAcA,eAAenF,OAAf","sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\n\n/**\n * A 2x2 matrix, indexable as a column-major order array.\n * Constructor parameters are in row-major order for code readability.\n * @alias Matrix2\n * @constructor\n *\n * @param {Number} [column0Row0=0.0] The value for column 0, row 0.\n * @param {Number} [column1Row0=0.0] The value for column 1, row 0.\n * @param {Number} [column0Row1=0.0] The value for column 0, row 1.\n * @param {Number} [column1Row1=0.0] The value for column 1, row 1.\n *\n * @see Matrix2.fromColumnMajorArray\n * @see Matrix2.fromRowMajorArray\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix3\n * @see Matrix4\n */\nfunction Matrix2(column0Row0, column1Row0, column0Row1, column1Row1) {\n  this[0] = defaultValue(column0Row0, 0.0);\n  this[1] = defaultValue(column0Row1, 0.0);\n  this[2] = defaultValue(column1Row0, 0.0);\n  this[3] = defaultValue(column1Row1, 0.0);\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nMatrix2.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Matrix2} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nMatrix2.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value[0];\n  array[startingIndex++] = value[1];\n  array[startingIndex++] = value[2];\n  array[startingIndex++] = value[3];\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Matrix2} [result] The object into which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n */\nMatrix2.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Matrix2();\n  }\n\n  result[0] = array[startingIndex++];\n  result[1] = array[startingIndex++];\n  result[2] = array[startingIndex++];\n  result[3] = array[startingIndex++];\n  return result;\n};\n\n/**\n * Duplicates a Matrix2 instance.\n *\n * @param {Matrix2} matrix The matrix to duplicate.\n * @param {Matrix2} [result] The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided. (Returns undefined if matrix is undefined)\n */\nMatrix2.clone = function (matrix, result) {\n  if (!defined(matrix)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Matrix2(matrix[0], matrix[2], matrix[1], matrix[3]);\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  return result;\n};\n\n/**\n * Creates a Matrix2 from 4 consecutive elements in an array.\n *\n * @param {Number[]} array The array whose 4 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.\n * @param {Matrix2} [result] The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Create the Matrix2:\n * // [1.0, 2.0]\n * // [1.0, 2.0]\n *\n * var v = [1.0, 1.0, 2.0, 2.0];\n * var m = Cesium.Matrix2.fromArray(v);\n *\n * // Create same Matrix2 with using an offset into an array\n * var v2 = [0.0, 0.0, 1.0, 1.0, 2.0, 2.0];\n * var m2 = Cesium.Matrix2.fromArray(v2, 2);\n */\nMatrix2.fromArray = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Matrix2();\n  }\n\n  result[0] = array[startingIndex];\n  result[1] = array[startingIndex + 1];\n  result[2] = array[startingIndex + 2];\n  result[3] = array[startingIndex + 3];\n  return result;\n};\n\n/**\n * Creates a Matrix2 instance from a column-major order array.\n *\n * @param {Number[]} values The column-major order array.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n */\nMatrix2.fromColumnMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  return Matrix2.clone(values, result);\n};\n\n/**\n * Creates a Matrix2 instance from a row-major order array.\n * The resulting matrix will be in column-major order.\n *\n * @param {Number[]} values The row-major order array.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n */\nMatrix2.fromRowMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix2(values[0], values[1], values[2], values[3]);\n  }\n  result[0] = values[0];\n  result[1] = values[2];\n  result[2] = values[1];\n  result[3] = values[3];\n  return result;\n};\n\n/**\n * Computes a Matrix2 instance representing a non-uniform scale.\n *\n * @param {Cartesian2} scale The x and y scale factors.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [7.0, 0.0]\n * //   [0.0, 8.0]\n * var m = Cesium.Matrix2.fromScale(new Cesium.Cartesian2(7.0, 8.0));\n */\nMatrix2.fromScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix2(scale.x, 0.0, 0.0, scale.y);\n  }\n\n  result[0] = scale.x;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = scale.y;\n  return result;\n};\n\n/**\n * Computes a Matrix2 instance representing a uniform scale.\n *\n * @param {Number} scale The uniform scale factor.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [2.0, 0.0]\n * //   [0.0, 2.0]\n * var m = Cesium.Matrix2.fromUniformScale(2.0);\n */\nMatrix2.fromUniformScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix2(scale, 0.0, 0.0, scale);\n  }\n\n  result[0] = scale;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = scale;\n  return result;\n};\n\n/**\n * Creates a rotation matrix.\n *\n * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise.\n * var p = new Cesium.Cartesian2(5, 6);\n * var m = Cesium.Matrix2.fromRotation(Cesium.Math.toRadians(45.0));\n * var rotated = Cesium.Matrix2.multiplyByVector(m, p, new Cesium.Cartesian2());\n */\nMatrix2.fromRotation = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  var cosAngle = Math.cos(angle);\n  var sinAngle = Math.sin(angle);\n\n  if (!defined(result)) {\n    return new Matrix2(cosAngle, -sinAngle, sinAngle, cosAngle);\n  }\n  result[0] = cosAngle;\n  result[1] = sinAngle;\n  result[2] = -sinAngle;\n  result[3] = cosAngle;\n  return result;\n};\n\n/**\n * Creates an Array from the provided Matrix2 instance.\n * The array will be in column-major order.\n *\n * @param {Matrix2} matrix The matrix to use..\n * @param {Number[]} [result] The Array onto which to store the result.\n * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.\n */\nMatrix2.toArray = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return [matrix[0], matrix[1], matrix[2], matrix[3]];\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  return result;\n};\n\n/**\n * Computes the array index of the element at the provided row and column.\n *\n * @param {Number} row The zero-based index of the row.\n * @param {Number} column The zero-based index of the column.\n * @returns {Number} The index of the element at the provided row and column.\n *\n * @exception {DeveloperError} row must be 0 or 1.\n * @exception {DeveloperError} column must be 0 or 1.\n *\n * @example\n * var myMatrix = new Cesium.Matrix2();\n * var column1Row0Index = Cesium.Matrix2.getElementIndex(1, 0);\n * var column1Row0 = myMatrix[column1Row0Index]\n * myMatrix[column1Row0Index] = 10.0;\n */\nMatrix2.getElementIndex = function (column, row) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"row\", row, 0);\n  Check.typeOf.number.lessThanOrEquals(\"row\", row, 1);\n\n  Check.typeOf.number.greaterThanOrEquals(\"column\", column, 0);\n  Check.typeOf.number.lessThanOrEquals(\"column\", column, 1);\n  //>>includeEnd('debug');\n\n  return column * 2 + row;\n};\n\n/**\n * Retrieves a copy of the matrix column at the provided index as a Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {Number} index The zero-based index of the column to retrieve.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.getColumn = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var startIndex = index * 2;\n  var x = matrix[startIndex];\n  var y = matrix[startIndex + 1];\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {Number} index The zero-based index of the column to set.\n * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified column.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.setColumn = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix2.clone(matrix, result);\n  var startIndex = index * 2;\n  result[startIndex] = cartesian.x;\n  result[startIndex + 1] = cartesian.y;\n  return result;\n};\n\n/**\n * Retrieves a copy of the matrix row at the provided index as a Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {Number} index The zero-based index of the row to retrieve.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.getRow = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var x = matrix[index];\n  var y = matrix[index + 2];\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {Number} index The zero-based index of the row to set.\n * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified row.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.setRow = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix2.clone(matrix, result);\n  result[index] = cartesian.x;\n  result[index + 2] = cartesian.y;\n  return result;\n};\n\nvar scratchColumn = new Cartesian2();\n\n/**\n * Extracts the non-uniform scale assuming the matrix is an affine transformation.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nMatrix2.getScale = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Cartesian2.magnitude(\n    Cartesian2.fromElements(matrix[0], matrix[1], scratchColumn)\n  );\n  result.y = Cartesian2.magnitude(\n    Cartesian2.fromElements(matrix[2], matrix[3], scratchColumn)\n  );\n  return result;\n};\n\nvar scratchScale = new Cartesian2();\n\n/**\n * Computes the maximum scale assuming the matrix is an affine transformation.\n * The maximum scale is the maximum length of the column vectors.\n *\n * @param {Matrix2} matrix The matrix.\n * @returns {Number} The maximum scale.\n */\nMatrix2.getMaximumScale = function (matrix) {\n  Matrix2.getScale(matrix, scratchScale);\n  return Cartesian2.maximumComponent(scratchScale);\n};\n\n/**\n * Computes the product of two matrices.\n *\n * @param {Matrix2} left The first matrix.\n * @param {Matrix2} right The second matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var column0Row0 = left[0] * right[0] + left[2] * right[1];\n  var column1Row0 = left[0] * right[2] + left[2] * right[3];\n  var column0Row1 = left[1] * right[0] + left[3] * right[1];\n  var column1Row1 = left[1] * right[2] + left[3] * right[3];\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column1Row0;\n  result[3] = column1Row1;\n  return result;\n};\n\n/**\n * Computes the sum of two matrices.\n *\n * @param {Matrix2} left The first matrix.\n * @param {Matrix2} right The second matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] + right[0];\n  result[1] = left[1] + right[1];\n  result[2] = left[2] + right[2];\n  result[3] = left[3] + right[3];\n  return result;\n};\n\n/**\n * Computes the difference of two matrices.\n *\n * @param {Matrix2} left The first matrix.\n * @param {Matrix2} right The second matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] - right[0];\n  result[1] = left[1] - right[1];\n  result[2] = left[2] - right[2];\n  result[3] = left[3] - right[3];\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a column vector.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Cartesian2} cartesian The column.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nMatrix2.multiplyByVector = function (matrix, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var x = matrix[0] * cartesian.x + matrix[2] * cartesian.y;\n  var y = matrix[1] * cartesian.x + matrix[3] * cartesian.y;\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a scalar.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Number} scalar The number to multiply by.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.multiplyByScalar = function (matrix, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scalar;\n  result[1] = matrix[1] * scalar;\n  result[2] = matrix[2] * scalar;\n  result[3] = matrix[3] * scalar;\n  return result;\n};\n\n/**\n * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.\n *\n * @param {Matrix2} matrix The matrix on the left-hand side.\n * @param {Cartesian2} scale The non-uniform scale on the right-hand side.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n *\n * @example\n * // Instead of Cesium.Matrix2.multiply(m, Cesium.Matrix2.fromScale(scale), m);\n * Cesium.Matrix2.multiplyByScale(m, scale, m);\n *\n * @see Matrix2.fromScale\n * @see Matrix2.multiplyByUniformScale\n */\nMatrix2.multiplyByScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale.x;\n  result[1] = matrix[1] * scale.x;\n  result[2] = matrix[2] * scale.y;\n  result[3] = matrix[3] * scale.y;\n  return result;\n};\n\n/**\n * Creates a negated copy of the provided matrix.\n *\n * @param {Matrix2} matrix The matrix to negate.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.negate = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = -matrix[0];\n  result[1] = -matrix[1];\n  result[2] = -matrix[2];\n  result[3] = -matrix[3];\n  return result;\n};\n\n/**\n * Computes the transpose of the provided matrix.\n *\n * @param {Matrix2} matrix The matrix to transpose.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.transpose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var column0Row0 = matrix[0];\n  var column0Row1 = matrix[2];\n  var column1Row0 = matrix[1];\n  var column1Row1 = matrix[3];\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column1Row0;\n  result[3] = column1Row1;\n  return result;\n};\n\n/**\n * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.\n *\n * @param {Matrix2} matrix The matrix with signed elements.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.abs = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = Math.abs(matrix[0]);\n  result[1] = Math.abs(matrix[1]);\n  result[2] = Math.abs(matrix[2]);\n  result[3] = Math.abs(matrix[3]);\n\n  return result;\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix2} [left] The first matrix.\n * @param {Matrix2} [right] The second matrix.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nMatrix2.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left[0] === right[0] &&\n      left[1] === right[1] &&\n      left[2] === right[2] &&\n      left[3] === right[3])\n  );\n};\n\n/**\n * @private\n */\nMatrix2.equalsArray = function (matrix, array, offset) {\n  return (\n    matrix[0] === array[offset] &&\n    matrix[1] === array[offset + 1] &&\n    matrix[2] === array[offset + 2] &&\n    matrix[3] === array[offset + 3]\n  );\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix2} [left] The first matrix.\n * @param {Matrix2} [right] The second matrix.\n * @param {Number} epsilon The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix2.equalsEpsilon = function (left, right, epsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"epsilon\", epsilon);\n  //>>includeEnd('debug');\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(left[0] - right[0]) <= epsilon &&\n      Math.abs(left[1] - right[1]) <= epsilon &&\n      Math.abs(left[2] - right[2]) <= epsilon &&\n      Math.abs(left[3] - right[3]) <= epsilon)\n  );\n};\n\n/**\n * An immutable Matrix2 instance initialized to the identity matrix.\n *\n * @type {Matrix2}\n * @constant\n */\nMatrix2.IDENTITY = Object.freeze(new Matrix2(1.0, 0.0, 0.0, 1.0));\n\n/**\n * An immutable Matrix2 instance initialized to the zero matrix.\n *\n * @type {Matrix2}\n * @constant\n */\nMatrix2.ZERO = Object.freeze(new Matrix2(0.0, 0.0, 0.0, 0.0));\n\n/**\n * The index into Matrix2 for column 0, row 0.\n *\n * @type {Number}\n * @constant\n *\n * @example\n * var matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN0ROW0] = 5.0; // set column 0, row 0 to 5.0\n */\nMatrix2.COLUMN0ROW0 = 0;\n\n/**\n * The index into Matrix2 for column 0, row 1.\n *\n * @type {Number}\n * @constant\n *\n * @example\n * var matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN0ROW1] = 5.0; // set column 0, row 1 to 5.0\n */\nMatrix2.COLUMN0ROW1 = 1;\n\n/**\n * The index into Matrix2 for column 1, row 0.\n *\n * @type {Number}\n * @constant\n *\n * @example\n * var matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN1ROW0] = 5.0; // set column 1, row 0 to 5.0\n */\nMatrix2.COLUMN1ROW0 = 2;\n\n/**\n * The index into Matrix2 for column 1, row 1.\n *\n * @type {Number}\n * @constant\n *\n * @example\n * var matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN1ROW1] = 5.0; // set column 1, row 1 to 5.0\n */\nMatrix2.COLUMN1ROW1 = 3;\n\nObject.defineProperties(Matrix2.prototype, {\n  /**\n   * Gets the number of items in the collection.\n   * @memberof Matrix2.prototype\n   *\n   * @type {Number}\n   */\n  length: {\n    get: function () {\n      return Matrix2.packedLength;\n    },\n  },\n});\n\n/**\n * Duplicates the provided Matrix2 instance.\n *\n * @param {Matrix2} [result] The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n */\nMatrix2.prototype.clone = function (result) {\n  return Matrix2.clone(this, result);\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix2} [right] The right hand side matrix.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nMatrix2.prototype.equals = function (right) {\n  return Matrix2.equals(this, right);\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix2} [right] The right hand side matrix.\n * @param {Number} epsilon The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix2.prototype.equalsEpsilon = function (right, epsilon) {\n  return Matrix2.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this Matrix with each row being\n * on a separate line and in the format '(column0, column1)'.\n *\n * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1)'.\n */\nMatrix2.prototype.toString = function () {\n  return (\n    \"(\" +\n    this[0] +\n    \", \" +\n    this[2] +\n    \")\\n\" +\n    \"(\" +\n    this[1] +\n    \", \" +\n    this[3] +\n    \")\"\n  );\n};\nexport default Matrix2;\n"]},"metadata":{},"sourceType":"module"}