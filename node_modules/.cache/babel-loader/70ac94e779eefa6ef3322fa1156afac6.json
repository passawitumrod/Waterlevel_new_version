{"ast":null,"code":"import ArcType from \"./ArcType.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Color from \"./Color.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nfunction interpolateColors(p0, p1, color0, color1, minDistance, array, offset) {\n  var numPoints = PolylinePipeline.numberOfPoints(p0, p1, minDistance);\n  var i;\n  var r0 = color0.red;\n  var g0 = color0.green;\n  var b0 = color0.blue;\n  var a0 = color0.alpha;\n  var r1 = color1.red;\n  var g1 = color1.green;\n  var b1 = color1.blue;\n  var a1 = color1.alpha;\n\n  if (Color.equals(color0, color1)) {\n    for (i = 0; i < numPoints; i++) {\n      array[offset++] = Color.floatToByte(r0);\n      array[offset++] = Color.floatToByte(g0);\n      array[offset++] = Color.floatToByte(b0);\n      array[offset++] = Color.floatToByte(a0);\n    }\n\n    return offset;\n  }\n\n  var redPerVertex = (r1 - r0) / numPoints;\n  var greenPerVertex = (g1 - g0) / numPoints;\n  var bluePerVertex = (b1 - b0) / numPoints;\n  var alphaPerVertex = (a1 - a0) / numPoints;\n  var index = offset;\n\n  for (i = 0; i < numPoints; i++) {\n    array[index++] = Color.floatToByte(r0 + i * redPerVertex);\n    array[index++] = Color.floatToByte(g0 + i * greenPerVertex);\n    array[index++] = Color.floatToByte(b0 + i * bluePerVertex);\n    array[index++] = Color.floatToByte(a0 + i * alphaPerVertex);\n  }\n\n  return index;\n}\n/**\n * A description of a polyline modeled as a line strip; the first two positions define a line segment,\n * and each additional position defines a line segment from the previous position.\n *\n * @alias SimplePolylineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the positions in the polyline as a line strip.\n * @param {Color[]} [options.colors] An Array of {@link Color} defining the per vertex or per segment colors.\n * @param {Boolean} [options.colorsPerVertex=false] A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude if options.arcType is not ArcType.NONE. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n *\n * @exception {DeveloperError} At least two positions are required.\n * @exception {DeveloperError} colors has an invalid length.\n *\n * @see SimplePolylineGeometry#createGeometry\n *\n * @example\n * // A polyline with two connected line segments\n * var polyline = new Cesium.SimplePolylineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     0.0, 0.0,\n *     5.0, 0.0,\n *     5.0, 5.0\n *   ])\n * });\n * var geometry = Cesium.SimplePolylineGeometry.createGeometry(polyline);\n */\n\n\nfunction SimplePolylineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var positions = options.positions;\n  var colors = options.colors;\n  var colorsPerVertex = defaultValue(options.colorsPerVertex, false); //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(positions) || positions.length < 2) {\n    throw new DeveloperError(\"At least two positions are required.\");\n  }\n\n  if (defined(colors) && (colorsPerVertex && colors.length < positions.length || !colorsPerVertex && colors.length < positions.length - 1)) {\n    throw new DeveloperError(\"colors has an invalid length.\");\n  } //>>includeEnd('debug');\n\n\n  this._positions = positions;\n  this._colors = colors;\n  this._colorsPerVertex = colorsPerVertex;\n  this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n  this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  this._workerName = \"createSimplePolylineGeometry\";\n  var numComponents = 1 + positions.length * Cartesian3.packedLength;\n  numComponents += defined(colors) ? 1 + colors.length * Color.packedLength : 1;\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n\n  this.packedLength = numComponents + Ellipsoid.packedLength + 3;\n}\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {SimplePolylineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\n\nSimplePolylineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  } //>>includeEnd('debug');\n\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var i;\n  var positions = value._positions;\n  var length = positions.length;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  var colors = value._colors;\n  length = defined(colors) ? colors.length : 0.0;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n    Color.pack(colors[i], array, startingIndex);\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n  array[startingIndex++] = value._colorsPerVertex ? 1.0 : 0.0;\n  array[startingIndex++] = value._arcType;\n  array[startingIndex] = value._granularity;\n  return array;\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {SimplePolylineGeometry} [result] The object into which to store the result.\n * @returns {SimplePolylineGeometry} The modified result parameter or a new SimplePolylineGeometry instance if one was not provided.\n */\n\n\nSimplePolylineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  } //>>includeEnd('debug');\n\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var i;\n  var length = array[startingIndex++];\n  var positions = new Array(length);\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  length = array[startingIndex++];\n  var colors = length > 0 ? new Array(length) : undefined;\n\n  for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n    colors[i] = Color.unpack(array, startingIndex);\n  }\n\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n  var colorsPerVertex = array[startingIndex++] === 1.0;\n  var arcType = array[startingIndex++];\n  var granularity = array[startingIndex];\n\n  if (!defined(result)) {\n    return new SimplePolylineGeometry({\n      positions: positions,\n      colors: colors,\n      ellipsoid: ellipsoid,\n      colorsPerVertex: colorsPerVertex,\n      arcType: arcType,\n      granularity: granularity\n    });\n  }\n\n  result._positions = positions;\n  result._colors = colors;\n  result._ellipsoid = ellipsoid;\n  result._colorsPerVertex = colorsPerVertex;\n  result._arcType = arcType;\n  result._granularity = granularity;\n  return result;\n};\n\nvar scratchArray1 = new Array(2);\nvar scratchArray2 = new Array(2);\nvar generateArcOptionsScratch = {\n  positions: scratchArray1,\n  height: scratchArray2,\n  ellipsoid: undefined,\n  minDistance: undefined,\n  granularity: undefined\n};\n/**\n * Computes the geometric representation of a simple polyline, including its vertices, indices, and a bounding sphere.\n *\n * @param {SimplePolylineGeometry} simplePolylineGeometry A description of the polyline.\n * @returns {Geometry} The computed vertices and indices.\n */\n\nSimplePolylineGeometry.createGeometry = function (simplePolylineGeometry) {\n  var positions = simplePolylineGeometry._positions;\n  var colors = simplePolylineGeometry._colors;\n  var colorsPerVertex = simplePolylineGeometry._colorsPerVertex;\n  var arcType = simplePolylineGeometry._arcType;\n  var granularity = simplePolylineGeometry._granularity;\n  var ellipsoid = simplePolylineGeometry._ellipsoid;\n  var minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n  var perSegmentColors = defined(colors) && !colorsPerVertex;\n  var i;\n  var length = positions.length;\n  var positionValues;\n  var numberOfPositions;\n  var colorValues;\n  var color;\n  var offset = 0;\n\n  if (arcType === ArcType.GEODESIC || arcType === ArcType.RHUMB) {\n    var subdivisionSize;\n    var numberOfPointsFunction;\n    var generateArcFunction;\n\n    if (arcType === ArcType.GEODESIC) {\n      subdivisionSize = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n      numberOfPointsFunction = PolylinePipeline.numberOfPoints;\n      generateArcFunction = PolylinePipeline.generateArc;\n    } else {\n      subdivisionSize = granularity;\n      numberOfPointsFunction = PolylinePipeline.numberOfPointsRhumbLine;\n      generateArcFunction = PolylinePipeline.generateRhumbArc;\n    }\n\n    var heights = PolylinePipeline.extractHeights(positions, ellipsoid);\n    var generateArcOptions = generateArcOptionsScratch;\n\n    if (arcType === ArcType.GEODESIC) {\n      generateArcOptions.minDistance = minDistance;\n    } else {\n      generateArcOptions.granularity = granularity;\n    }\n\n    generateArcOptions.ellipsoid = ellipsoid;\n\n    if (perSegmentColors) {\n      var positionCount = 0;\n\n      for (i = 0; i < length - 1; i++) {\n        positionCount += numberOfPointsFunction(positions[i], positions[i + 1], subdivisionSize) + 1;\n      }\n\n      positionValues = new Float64Array(positionCount * 3);\n      colorValues = new Uint8Array(positionCount * 4);\n      generateArcOptions.positions = scratchArray1;\n      generateArcOptions.height = scratchArray2;\n      var ci = 0;\n\n      for (i = 0; i < length - 1; ++i) {\n        scratchArray1[0] = positions[i];\n        scratchArray1[1] = positions[i + 1];\n        scratchArray2[0] = heights[i];\n        scratchArray2[1] = heights[i + 1];\n        var pos = generateArcFunction(generateArcOptions);\n\n        if (defined(colors)) {\n          var segLen = pos.length / 3;\n          color = colors[i];\n\n          for (var k = 0; k < segLen; ++k) {\n            colorValues[ci++] = Color.floatToByte(color.red);\n            colorValues[ci++] = Color.floatToByte(color.green);\n            colorValues[ci++] = Color.floatToByte(color.blue);\n            colorValues[ci++] = Color.floatToByte(color.alpha);\n          }\n        }\n\n        positionValues.set(pos, offset);\n        offset += pos.length;\n      }\n    } else {\n      generateArcOptions.positions = positions;\n      generateArcOptions.height = heights;\n      positionValues = new Float64Array(generateArcFunction(generateArcOptions));\n\n      if (defined(colors)) {\n        colorValues = new Uint8Array(positionValues.length / 3 * 4);\n\n        for (i = 0; i < length - 1; ++i) {\n          var p0 = positions[i];\n          var p1 = positions[i + 1];\n          var c0 = colors[i];\n          var c1 = colors[i + 1];\n          offset = interpolateColors(p0, p1, c0, c1, minDistance, colorValues, offset);\n        }\n\n        var lastColor = colors[length - 1];\n        colorValues[offset++] = Color.floatToByte(lastColor.red);\n        colorValues[offset++] = Color.floatToByte(lastColor.green);\n        colorValues[offset++] = Color.floatToByte(lastColor.blue);\n        colorValues[offset++] = Color.floatToByte(lastColor.alpha);\n      }\n    }\n  } else {\n    numberOfPositions = perSegmentColors ? length * 2 - 2 : length;\n    positionValues = new Float64Array(numberOfPositions * 3);\n    colorValues = defined(colors) ? new Uint8Array(numberOfPositions * 4) : undefined;\n    var positionIndex = 0;\n    var colorIndex = 0;\n\n    for (i = 0; i < length; ++i) {\n      var p = positions[i];\n\n      if (perSegmentColors && i > 0) {\n        Cartesian3.pack(p, positionValues, positionIndex);\n        positionIndex += 3;\n        color = colors[i - 1];\n        colorValues[colorIndex++] = Color.floatToByte(color.red);\n        colorValues[colorIndex++] = Color.floatToByte(color.green);\n        colorValues[colorIndex++] = Color.floatToByte(color.blue);\n        colorValues[colorIndex++] = Color.floatToByte(color.alpha);\n      }\n\n      if (perSegmentColors && i === length - 1) {\n        break;\n      }\n\n      Cartesian3.pack(p, positionValues, positionIndex);\n      positionIndex += 3;\n\n      if (defined(colors)) {\n        color = colors[i];\n        colorValues[colorIndex++] = Color.floatToByte(color.red);\n        colorValues[colorIndex++] = Color.floatToByte(color.green);\n        colorValues[colorIndex++] = Color.floatToByte(color.blue);\n        colorValues[colorIndex++] = Color.floatToByte(color.alpha);\n      }\n    }\n  }\n\n  var attributes = new GeometryAttributes();\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positionValues\n  });\n\n  if (defined(colors)) {\n    attributes.color = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 4,\n      values: colorValues,\n      normalize: true\n    });\n  }\n\n  numberOfPositions = positionValues.length / 3;\n  var numberOfIndices = (numberOfPositions - 1) * 2;\n  var indices = IndexDatatype.createTypedArray(numberOfPositions, numberOfIndices);\n  var index = 0;\n\n  for (i = 0; i < numberOfPositions - 1; ++i) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: BoundingSphere.fromPoints(positions)\n  });\n};\n\nexport default SimplePolylineGeometry;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/SimplePolylineGeometry.js"],"names":["ArcType","BoundingSphere","Cartesian3","Color","ComponentDatatype","defaultValue","defined","DeveloperError","Ellipsoid","Geometry","GeometryAttribute","GeometryAttributes","IndexDatatype","CesiumMath","PolylinePipeline","PrimitiveType","interpolateColors","p0","p1","color0","color1","minDistance","array","offset","numPoints","numberOfPoints","i","r0","red","g0","green","b0","blue","a0","alpha","r1","g1","b1","a1","equals","floatToByte","redPerVertex","greenPerVertex","bluePerVertex","alphaPerVertex","index","SimplePolylineGeometry","options","EMPTY_OBJECT","positions","colors","colorsPerVertex","length","_positions","_colors","_colorsPerVertex","_arcType","arcType","GEODESIC","_granularity","granularity","RADIANS_PER_DEGREE","_ellipsoid","ellipsoid","WGS84","_workerName","numComponents","packedLength","pack","value","startingIndex","unpack","result","Array","undefined","scratchArray1","scratchArray2","generateArcOptionsScratch","height","createGeometry","simplePolylineGeometry","chordLength","maximumRadius","perSegmentColors","positionValues","numberOfPositions","colorValues","color","RHUMB","subdivisionSize","numberOfPointsFunction","generateArcFunction","generateArc","numberOfPointsRhumbLine","generateRhumbArc","heights","extractHeights","generateArcOptions","positionCount","Float64Array","Uint8Array","ci","pos","segLen","k","set","c0","c1","lastColor","positionIndex","colorIndex","p","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","UNSIGNED_BYTE","normalize","numberOfIndices","indices","createTypedArray","primitiveType","LINES","boundingSphere","fromPoints"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,cAApB;AACA,OAAOC,cAAP,MAA2B,qBAA3B;AACA,OAAOC,UAAP,MAAuB,iBAAvB;AACA,OAAOC,KAAP,MAAkB,YAAlB;AACA,OAAOC,iBAAP,MAA8B,wBAA9B;AACA,OAAOC,YAAP,MAAyB,mBAAzB;AACA,OAAOC,OAAP,MAAoB,cAApB;AACA,OAAOC,cAAP,MAA2B,qBAA3B;AACA,OAAOC,SAAP,MAAsB,gBAAtB;AACA,OAAOC,QAAP,MAAqB,eAArB;AACA,OAAOC,iBAAP,MAA8B,wBAA9B;AACA,OAAOC,kBAAP,MAA+B,yBAA/B;AACA,OAAOC,aAAP,MAA0B,oBAA1B;AACA,OAAOC,UAAP,MAAuB,WAAvB;AACA,OAAOC,gBAAP,MAA6B,uBAA7B;AACA,OAAOC,aAAP,MAA0B,oBAA1B;;AAEA,SAASC,iBAAT,CAA2BC,EAA3B,EAA+BC,EAA/B,EAAmCC,MAAnC,EAA2CC,MAA3C,EAAmDC,WAAnD,EAAgEC,KAAhE,EAAuEC,MAAvE,EAA+E;AAC7E,MAAIC,SAAS,GAAGV,gBAAgB,CAACW,cAAjB,CAAgCR,EAAhC,EAAoCC,EAApC,EAAwCG,WAAxC,CAAhB;AACA,MAAIK,CAAJ;AAEA,MAAIC,EAAE,GAAGR,MAAM,CAACS,GAAhB;AACA,MAAIC,EAAE,GAAGV,MAAM,CAACW,KAAhB;AACA,MAAIC,EAAE,GAAGZ,MAAM,CAACa,IAAhB;AACA,MAAIC,EAAE,GAAGd,MAAM,CAACe,KAAhB;AAEA,MAAIC,EAAE,GAAGf,MAAM,CAACQ,GAAhB;AACA,MAAIQ,EAAE,GAAGhB,MAAM,CAACU,KAAhB;AACA,MAAIO,EAAE,GAAGjB,MAAM,CAACY,IAAhB;AACA,MAAIM,EAAE,GAAGlB,MAAM,CAACc,KAAhB;;AAEA,MAAI/B,KAAK,CAACoC,MAAN,CAAapB,MAAb,EAAqBC,MAArB,CAAJ,EAAkC;AAChC,SAAKM,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGF,SAAhB,EAA2BE,CAAC,EAA5B,EAAgC;AAC9BJ,MAAAA,KAAK,CAACC,MAAM,EAAP,CAAL,GAAkBpB,KAAK,CAACqC,WAAN,CAAkBb,EAAlB,CAAlB;AACAL,MAAAA,KAAK,CAACC,MAAM,EAAP,CAAL,GAAkBpB,KAAK,CAACqC,WAAN,CAAkBX,EAAlB,CAAlB;AACAP,MAAAA,KAAK,CAACC,MAAM,EAAP,CAAL,GAAkBpB,KAAK,CAACqC,WAAN,CAAkBT,EAAlB,CAAlB;AACAT,MAAAA,KAAK,CAACC,MAAM,EAAP,CAAL,GAAkBpB,KAAK,CAACqC,WAAN,CAAkBP,EAAlB,CAAlB;AACD;;AACD,WAAOV,MAAP;AACD;;AAED,MAAIkB,YAAY,GAAG,CAACN,EAAE,GAAGR,EAAN,IAAYH,SAA/B;AACA,MAAIkB,cAAc,GAAG,CAACN,EAAE,GAAGP,EAAN,IAAYL,SAAjC;AACA,MAAImB,aAAa,GAAG,CAACN,EAAE,GAAGN,EAAN,IAAYP,SAAhC;AACA,MAAIoB,cAAc,GAAG,CAACN,EAAE,GAAGL,EAAN,IAAYT,SAAjC;AAEA,MAAIqB,KAAK,GAAGtB,MAAZ;;AACA,OAAKG,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGF,SAAhB,EAA2BE,CAAC,EAA5B,EAAgC;AAC9BJ,IAAAA,KAAK,CAACuB,KAAK,EAAN,CAAL,GAAiB1C,KAAK,CAACqC,WAAN,CAAkBb,EAAE,GAAGD,CAAC,GAAGe,YAA3B,CAAjB;AACAnB,IAAAA,KAAK,CAACuB,KAAK,EAAN,CAAL,GAAiB1C,KAAK,CAACqC,WAAN,CAAkBX,EAAE,GAAGH,CAAC,GAAGgB,cAA3B,CAAjB;AACApB,IAAAA,KAAK,CAACuB,KAAK,EAAN,CAAL,GAAiB1C,KAAK,CAACqC,WAAN,CAAkBT,EAAE,GAAGL,CAAC,GAAGiB,aAA3B,CAAjB;AACArB,IAAAA,KAAK,CAACuB,KAAK,EAAN,CAAL,GAAiB1C,KAAK,CAACqC,WAAN,CAAkBP,EAAE,GAAGP,CAAC,GAAGkB,cAA3B,CAAjB;AACD;;AAED,SAAOC,KAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA,SAASC,sBAAT,CAAgCC,OAAhC,EAAyC;AACvCA,EAAAA,OAAO,GAAG1C,YAAY,CAAC0C,OAAD,EAAU1C,YAAY,CAAC2C,YAAvB,CAAtB;AACA,MAAIC,SAAS,GAAGF,OAAO,CAACE,SAAxB;AACA,MAAIC,MAAM,GAAGH,OAAO,CAACG,MAArB;AACA,MAAIC,eAAe,GAAG9C,YAAY,CAAC0C,OAAO,CAACI,eAAT,EAA0B,KAA1B,CAAlC,CAJuC,CAMvC;;AACA,MAAI,CAAC7C,OAAO,CAAC2C,SAAD,CAAR,IAAuBA,SAAS,CAACG,MAAV,GAAmB,CAA9C,EAAiD;AAC/C,UAAM,IAAI7C,cAAJ,CAAmB,sCAAnB,CAAN;AACD;;AACD,MACED,OAAO,CAAC4C,MAAD,CAAP,KACEC,eAAe,IAAID,MAAM,CAACE,MAAP,GAAgBH,SAAS,CAACG,MAA9C,IACE,CAACD,eAAD,IAAoBD,MAAM,CAACE,MAAP,GAAgBH,SAAS,CAACG,MAAV,GAAmB,CAF1D,CADF,EAIE;AACA,UAAM,IAAI7C,cAAJ,CAAmB,+BAAnB,CAAN;AACD,GAhBsC,CAiBvC;;;AAEA,OAAK8C,UAAL,GAAkBJ,SAAlB;AACA,OAAKK,OAAL,GAAeJ,MAAf;AACA,OAAKK,gBAAL,GAAwBJ,eAAxB;AAEA,OAAKK,QAAL,GAAgBnD,YAAY,CAAC0C,OAAO,CAACU,OAAT,EAAkBzD,OAAO,CAAC0D,QAA1B,CAA5B;AACA,OAAKC,YAAL,GAAoBtD,YAAY,CAC9B0C,OAAO,CAACa,WADsB,EAE9B/C,UAAU,CAACgD,kBAFmB,CAAhC;AAIA,OAAKC,UAAL,GAAkBzD,YAAY,CAAC0C,OAAO,CAACgB,SAAT,EAAoBvD,SAAS,CAACwD,KAA9B,CAA9B;AACA,OAAKC,WAAL,GAAmB,8BAAnB;AAEA,MAAIC,aAAa,GAAG,IAAIjB,SAAS,CAACG,MAAV,GAAmBlD,UAAU,CAACiE,YAAtD;AACAD,EAAAA,aAAa,IAAI5D,OAAO,CAAC4C,MAAD,CAAP,GAAkB,IAAIA,MAAM,CAACE,MAAP,GAAgBjD,KAAK,CAACgE,YAA5C,GAA2D,CAA5E;AAEA;;;;;AAIA,OAAKA,YAAL,GAAoBD,aAAa,GAAG1D,SAAS,CAAC2D,YAA1B,GAAyC,CAA7D;AACD;AAED;;;;;;;;;;;AASArB,sBAAsB,CAACsB,IAAvB,GAA8B,UAAUC,KAAV,EAAiB/C,KAAjB,EAAwBgD,aAAxB,EAAuC;AACnE;AACA,MAAI,CAAChE,OAAO,CAAC+D,KAAD,CAAZ,EAAqB;AACnB,UAAM,IAAI9D,cAAJ,CAAmB,mBAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAACgB,KAAD,CAAZ,EAAqB;AACnB,UAAM,IAAIf,cAAJ,CAAmB,mBAAnB,CAAN;AACD,GAPkE,CAQnE;;;AAEA+D,EAAAA,aAAa,GAAGjE,YAAY,CAACiE,aAAD,EAAgB,CAAhB,CAA5B;AAEA,MAAI5C,CAAJ;AAEA,MAAIuB,SAAS,GAAGoB,KAAK,CAAChB,UAAtB;AACA,MAAID,MAAM,GAAGH,SAAS,CAACG,MAAvB;AACA9B,EAAAA,KAAK,CAACgD,aAAa,EAAd,CAAL,GAAyBlB,MAAzB;;AAEA,OAAK1B,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG0B,MAAhB,EAAwB,EAAE1B,CAAF,EAAK4C,aAAa,IAAIpE,UAAU,CAACiE,YAAzD,EAAuE;AACrEjE,IAAAA,UAAU,CAACkE,IAAX,CAAgBnB,SAAS,CAACvB,CAAD,CAAzB,EAA8BJ,KAA9B,EAAqCgD,aAArC;AACD;;AAED,MAAIpB,MAAM,GAAGmB,KAAK,CAACf,OAAnB;AACAF,EAAAA,MAAM,GAAG9C,OAAO,CAAC4C,MAAD,CAAP,GAAkBA,MAAM,CAACE,MAAzB,GAAkC,GAA3C;AACA9B,EAAAA,KAAK,CAACgD,aAAa,EAAd,CAAL,GAAyBlB,MAAzB;;AAEA,OAAK1B,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG0B,MAAhB,EAAwB,EAAE1B,CAAF,EAAK4C,aAAa,IAAInE,KAAK,CAACgE,YAApD,EAAkE;AAChEhE,IAAAA,KAAK,CAACiE,IAAN,CAAWlB,MAAM,CAACxB,CAAD,CAAjB,EAAsBJ,KAAtB,EAA6BgD,aAA7B;AACD;;AAED9D,EAAAA,SAAS,CAAC4D,IAAV,CAAeC,KAAK,CAACP,UAArB,EAAiCxC,KAAjC,EAAwCgD,aAAxC;AACAA,EAAAA,aAAa,IAAI9D,SAAS,CAAC2D,YAA3B;AAEA7C,EAAAA,KAAK,CAACgD,aAAa,EAAd,CAAL,GAAyBD,KAAK,CAACd,gBAAN,GAAyB,GAAzB,GAA+B,GAAxD;AACAjC,EAAAA,KAAK,CAACgD,aAAa,EAAd,CAAL,GAAyBD,KAAK,CAACb,QAA/B;AACAlC,EAAAA,KAAK,CAACgD,aAAD,CAAL,GAAuBD,KAAK,CAACV,YAA7B;AAEA,SAAOrC,KAAP;AACD,CAtCD;AAwCA;;;;;;;;;;AAQAwB,sBAAsB,CAACyB,MAAvB,GAAgC,UAAUjD,KAAV,EAAiBgD,aAAjB,EAAgCE,MAAhC,EAAwC;AACtE;AACA,MAAI,CAAClE,OAAO,CAACgB,KAAD,CAAZ,EAAqB;AACnB,UAAM,IAAIf,cAAJ,CAAmB,mBAAnB,CAAN;AACD,GAJqE,CAKtE;;;AAEA+D,EAAAA,aAAa,GAAGjE,YAAY,CAACiE,aAAD,EAAgB,CAAhB,CAA5B;AAEA,MAAI5C,CAAJ;AAEA,MAAI0B,MAAM,GAAG9B,KAAK,CAACgD,aAAa,EAAd,CAAlB;AACA,MAAIrB,SAAS,GAAG,IAAIwB,KAAJ,CAAUrB,MAAV,CAAhB;;AAEA,OAAK1B,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG0B,MAAhB,EAAwB,EAAE1B,CAAF,EAAK4C,aAAa,IAAIpE,UAAU,CAACiE,YAAzD,EAAuE;AACrElB,IAAAA,SAAS,CAACvB,CAAD,CAAT,GAAexB,UAAU,CAACqE,MAAX,CAAkBjD,KAAlB,EAAyBgD,aAAzB,CAAf;AACD;;AAEDlB,EAAAA,MAAM,GAAG9B,KAAK,CAACgD,aAAa,EAAd,CAAd;AACA,MAAIpB,MAAM,GAAGE,MAAM,GAAG,CAAT,GAAa,IAAIqB,KAAJ,CAAUrB,MAAV,CAAb,GAAiCsB,SAA9C;;AAEA,OAAKhD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG0B,MAAhB,EAAwB,EAAE1B,CAAF,EAAK4C,aAAa,IAAInE,KAAK,CAACgE,YAApD,EAAkE;AAChEjB,IAAAA,MAAM,CAACxB,CAAD,CAAN,GAAYvB,KAAK,CAACoE,MAAN,CAAajD,KAAb,EAAoBgD,aAApB,CAAZ;AACD;;AAED,MAAIP,SAAS,GAAGvD,SAAS,CAAC+D,MAAV,CAAiBjD,KAAjB,EAAwBgD,aAAxB,CAAhB;AACAA,EAAAA,aAAa,IAAI9D,SAAS,CAAC2D,YAA3B;AAEA,MAAIhB,eAAe,GAAG7B,KAAK,CAACgD,aAAa,EAAd,CAAL,KAA2B,GAAjD;AACA,MAAIb,OAAO,GAAGnC,KAAK,CAACgD,aAAa,EAAd,CAAnB;AACA,MAAIV,WAAW,GAAGtC,KAAK,CAACgD,aAAD,CAAvB;;AAEA,MAAI,CAAChE,OAAO,CAACkE,MAAD,CAAZ,EAAsB;AACpB,WAAO,IAAI1B,sBAAJ,CAA2B;AAChCG,MAAAA,SAAS,EAAEA,SADqB;AAEhCC,MAAAA,MAAM,EAAEA,MAFwB;AAGhCa,MAAAA,SAAS,EAAEA,SAHqB;AAIhCZ,MAAAA,eAAe,EAAEA,eAJe;AAKhCM,MAAAA,OAAO,EAAEA,OALuB;AAMhCG,MAAAA,WAAW,EAAEA;AANmB,KAA3B,CAAP;AAQD;;AAEDY,EAAAA,MAAM,CAACnB,UAAP,GAAoBJ,SAApB;AACAuB,EAAAA,MAAM,CAAClB,OAAP,GAAiBJ,MAAjB;AACAsB,EAAAA,MAAM,CAACV,UAAP,GAAoBC,SAApB;AACAS,EAAAA,MAAM,CAACjB,gBAAP,GAA0BJ,eAA1B;AACAqB,EAAAA,MAAM,CAAChB,QAAP,GAAkBC,OAAlB;AACAe,EAAAA,MAAM,CAACb,YAAP,GAAsBC,WAAtB;AAEA,SAAOY,MAAP;AACD,CAnDD;;AAqDA,IAAIG,aAAa,GAAG,IAAIF,KAAJ,CAAU,CAAV,CAApB;AACA,IAAIG,aAAa,GAAG,IAAIH,KAAJ,CAAU,CAAV,CAApB;AACA,IAAII,yBAAyB,GAAG;AAC9B5B,EAAAA,SAAS,EAAE0B,aADmB;AAE9BG,EAAAA,MAAM,EAAEF,aAFsB;AAG9Bb,EAAAA,SAAS,EAAEW,SAHmB;AAI9BrD,EAAAA,WAAW,EAAEqD,SAJiB;AAK9Bd,EAAAA,WAAW,EAAEc;AALiB,CAAhC;AAQA;;;;;;;AAMA5B,sBAAsB,CAACiC,cAAvB,GAAwC,UAAUC,sBAAV,EAAkC;AACxE,MAAI/B,SAAS,GAAG+B,sBAAsB,CAAC3B,UAAvC;AACA,MAAIH,MAAM,GAAG8B,sBAAsB,CAAC1B,OAApC;AACA,MAAIH,eAAe,GAAG6B,sBAAsB,CAACzB,gBAA7C;AACA,MAAIE,OAAO,GAAGuB,sBAAsB,CAACxB,QAArC;AACA,MAAII,WAAW,GAAGoB,sBAAsB,CAACrB,YAAzC;AACA,MAAII,SAAS,GAAGiB,sBAAsB,CAAClB,UAAvC;AAEA,MAAIzC,WAAW,GAAGR,UAAU,CAACoE,WAAX,CAChBrB,WADgB,EAEhBG,SAAS,CAACmB,aAFM,CAAlB;AAIA,MAAIC,gBAAgB,GAAG7E,OAAO,CAAC4C,MAAD,CAAP,IAAmB,CAACC,eAA3C;AAEA,MAAIzB,CAAJ;AACA,MAAI0B,MAAM,GAAGH,SAAS,CAACG,MAAvB;AAEA,MAAIgC,cAAJ;AACA,MAAIC,iBAAJ;AACA,MAAIC,WAAJ;AACA,MAAIC,KAAJ;AACA,MAAIhE,MAAM,GAAG,CAAb;;AAEA,MAAIkC,OAAO,KAAKzD,OAAO,CAAC0D,QAApB,IAAgCD,OAAO,KAAKzD,OAAO,CAACwF,KAAxD,EAA+D;AAC7D,QAAIC,eAAJ;AACA,QAAIC,sBAAJ;AACA,QAAIC,mBAAJ;;AACA,QAAIlC,OAAO,KAAKzD,OAAO,CAAC0D,QAAxB,EAAkC;AAChC+B,MAAAA,eAAe,GAAG5E,UAAU,CAACoE,WAAX,CAChBrB,WADgB,EAEhBG,SAAS,CAACmB,aAFM,CAAlB;AAIAQ,MAAAA,sBAAsB,GAAG5E,gBAAgB,CAACW,cAA1C;AACAkE,MAAAA,mBAAmB,GAAG7E,gBAAgB,CAAC8E,WAAvC;AACD,KAPD,MAOO;AACLH,MAAAA,eAAe,GAAG7B,WAAlB;AACA8B,MAAAA,sBAAsB,GAAG5E,gBAAgB,CAAC+E,uBAA1C;AACAF,MAAAA,mBAAmB,GAAG7E,gBAAgB,CAACgF,gBAAvC;AACD;;AAED,QAAIC,OAAO,GAAGjF,gBAAgB,CAACkF,cAAjB,CAAgC/C,SAAhC,EAA2Cc,SAA3C,CAAd;AAEA,QAAIkC,kBAAkB,GAAGpB,yBAAzB;;AACA,QAAIpB,OAAO,KAAKzD,OAAO,CAAC0D,QAAxB,EAAkC;AAChCuC,MAAAA,kBAAkB,CAAC5E,WAAnB,GAAiCA,WAAjC;AACD,KAFD,MAEO;AACL4E,MAAAA,kBAAkB,CAACrC,WAAnB,GAAiCA,WAAjC;AACD;;AACDqC,IAAAA,kBAAkB,CAAClC,SAAnB,GAA+BA,SAA/B;;AAEA,QAAIoB,gBAAJ,EAAsB;AACpB,UAAIe,aAAa,GAAG,CAApB;;AACA,WAAKxE,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG0B,MAAM,GAAG,CAAzB,EAA4B1B,CAAC,EAA7B,EAAiC;AAC/BwE,QAAAA,aAAa,IACXR,sBAAsB,CACpBzC,SAAS,CAACvB,CAAD,CADW,EAEpBuB,SAAS,CAACvB,CAAC,GAAG,CAAL,CAFW,EAGpB+D,eAHoB,CAAtB,GAII,CALN;AAMD;;AAEDL,MAAAA,cAAc,GAAG,IAAIe,YAAJ,CAAiBD,aAAa,GAAG,CAAjC,CAAjB;AACAZ,MAAAA,WAAW,GAAG,IAAIc,UAAJ,CAAeF,aAAa,GAAG,CAA/B,CAAd;AAEAD,MAAAA,kBAAkB,CAAChD,SAAnB,GAA+B0B,aAA/B;AACAsB,MAAAA,kBAAkB,CAACnB,MAAnB,GAA4BF,aAA5B;AAEA,UAAIyB,EAAE,GAAG,CAAT;;AACA,WAAK3E,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG0B,MAAM,GAAG,CAAzB,EAA4B,EAAE1B,CAA9B,EAAiC;AAC/BiD,QAAAA,aAAa,CAAC,CAAD,CAAb,GAAmB1B,SAAS,CAACvB,CAAD,CAA5B;AACAiD,QAAAA,aAAa,CAAC,CAAD,CAAb,GAAmB1B,SAAS,CAACvB,CAAC,GAAG,CAAL,CAA5B;AAEAkD,QAAAA,aAAa,CAAC,CAAD,CAAb,GAAmBmB,OAAO,CAACrE,CAAD,CAA1B;AACAkD,QAAAA,aAAa,CAAC,CAAD,CAAb,GAAmBmB,OAAO,CAACrE,CAAC,GAAG,CAAL,CAA1B;AAEA,YAAI4E,GAAG,GAAGX,mBAAmB,CAACM,kBAAD,CAA7B;;AAEA,YAAI3F,OAAO,CAAC4C,MAAD,CAAX,EAAqB;AACnB,cAAIqD,MAAM,GAAGD,GAAG,CAAClD,MAAJ,GAAa,CAA1B;AACAmC,UAAAA,KAAK,GAAGrC,MAAM,CAACxB,CAAD,CAAd;;AACA,eAAK,IAAI8E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4B,EAAEC,CAA9B,EAAiC;AAC/BlB,YAAAA,WAAW,CAACe,EAAE,EAAH,CAAX,GAAoBlG,KAAK,CAACqC,WAAN,CAAkB+C,KAAK,CAAC3D,GAAxB,CAApB;AACA0D,YAAAA,WAAW,CAACe,EAAE,EAAH,CAAX,GAAoBlG,KAAK,CAACqC,WAAN,CAAkB+C,KAAK,CAACzD,KAAxB,CAApB;AACAwD,YAAAA,WAAW,CAACe,EAAE,EAAH,CAAX,GAAoBlG,KAAK,CAACqC,WAAN,CAAkB+C,KAAK,CAACvD,IAAxB,CAApB;AACAsD,YAAAA,WAAW,CAACe,EAAE,EAAH,CAAX,GAAoBlG,KAAK,CAACqC,WAAN,CAAkB+C,KAAK,CAACrD,KAAxB,CAApB;AACD;AACF;;AAEDkD,QAAAA,cAAc,CAACqB,GAAf,CAAmBH,GAAnB,EAAwB/E,MAAxB;AACAA,QAAAA,MAAM,IAAI+E,GAAG,CAAClD,MAAd;AACD;AACF,KAzCD,MAyCO;AACL6C,MAAAA,kBAAkB,CAAChD,SAAnB,GAA+BA,SAA/B;AACAgD,MAAAA,kBAAkB,CAACnB,MAAnB,GAA4BiB,OAA5B;AACAX,MAAAA,cAAc,GAAG,IAAIe,YAAJ,CACfR,mBAAmB,CAACM,kBAAD,CADJ,CAAjB;;AAIA,UAAI3F,OAAO,CAAC4C,MAAD,CAAX,EAAqB;AACnBoC,QAAAA,WAAW,GAAG,IAAIc,UAAJ,CAAgBhB,cAAc,CAAChC,MAAf,GAAwB,CAAzB,GAA8B,CAA7C,CAAd;;AAEA,aAAK1B,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG0B,MAAM,GAAG,CAAzB,EAA4B,EAAE1B,CAA9B,EAAiC;AAC/B,cAAIT,EAAE,GAAGgC,SAAS,CAACvB,CAAD,CAAlB;AACA,cAAIR,EAAE,GAAG+B,SAAS,CAACvB,CAAC,GAAG,CAAL,CAAlB;AACA,cAAIgF,EAAE,GAAGxD,MAAM,CAACxB,CAAD,CAAf;AACA,cAAIiF,EAAE,GAAGzD,MAAM,CAACxB,CAAC,GAAG,CAAL,CAAf;AACAH,UAAAA,MAAM,GAAGP,iBAAiB,CACxBC,EADwB,EAExBC,EAFwB,EAGxBwF,EAHwB,EAIxBC,EAJwB,EAKxBtF,WALwB,EAMxBiE,WANwB,EAOxB/D,MAPwB,CAA1B;AASD;;AAED,YAAIqF,SAAS,GAAG1D,MAAM,CAACE,MAAM,GAAG,CAAV,CAAtB;AACAkC,QAAAA,WAAW,CAAC/D,MAAM,EAAP,CAAX,GAAwBpB,KAAK,CAACqC,WAAN,CAAkBoE,SAAS,CAAChF,GAA5B,CAAxB;AACA0D,QAAAA,WAAW,CAAC/D,MAAM,EAAP,CAAX,GAAwBpB,KAAK,CAACqC,WAAN,CAAkBoE,SAAS,CAAC9E,KAA5B,CAAxB;AACAwD,QAAAA,WAAW,CAAC/D,MAAM,EAAP,CAAX,GAAwBpB,KAAK,CAACqC,WAAN,CAAkBoE,SAAS,CAAC5E,IAA5B,CAAxB;AACAsD,QAAAA,WAAW,CAAC/D,MAAM,EAAP,CAAX,GAAwBpB,KAAK,CAACqC,WAAN,CAAkBoE,SAAS,CAAC1E,KAA5B,CAAxB;AACD;AACF;AACF,GArGD,MAqGO;AACLmD,IAAAA,iBAAiB,GAAGF,gBAAgB,GAAG/B,MAAM,GAAG,CAAT,GAAa,CAAhB,GAAoBA,MAAxD;AACAgC,IAAAA,cAAc,GAAG,IAAIe,YAAJ,CAAiBd,iBAAiB,GAAG,CAArC,CAAjB;AACAC,IAAAA,WAAW,GAAGhF,OAAO,CAAC4C,MAAD,CAAP,GACV,IAAIkD,UAAJ,CAAef,iBAAiB,GAAG,CAAnC,CADU,GAEVX,SAFJ;AAIA,QAAImC,aAAa,GAAG,CAApB;AACA,QAAIC,UAAU,GAAG,CAAjB;;AAEA,SAAKpF,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG0B,MAAhB,EAAwB,EAAE1B,CAA1B,EAA6B;AAC3B,UAAIqF,CAAC,GAAG9D,SAAS,CAACvB,CAAD,CAAjB;;AAEA,UAAIyD,gBAAgB,IAAIzD,CAAC,GAAG,CAA5B,EAA+B;AAC7BxB,QAAAA,UAAU,CAACkE,IAAX,CAAgB2C,CAAhB,EAAmB3B,cAAnB,EAAmCyB,aAAnC;AACAA,QAAAA,aAAa,IAAI,CAAjB;AAEAtB,QAAAA,KAAK,GAAGrC,MAAM,CAACxB,CAAC,GAAG,CAAL,CAAd;AACA4D,QAAAA,WAAW,CAACwB,UAAU,EAAX,CAAX,GAA4B3G,KAAK,CAACqC,WAAN,CAAkB+C,KAAK,CAAC3D,GAAxB,CAA5B;AACA0D,QAAAA,WAAW,CAACwB,UAAU,EAAX,CAAX,GAA4B3G,KAAK,CAACqC,WAAN,CAAkB+C,KAAK,CAACzD,KAAxB,CAA5B;AACAwD,QAAAA,WAAW,CAACwB,UAAU,EAAX,CAAX,GAA4B3G,KAAK,CAACqC,WAAN,CAAkB+C,KAAK,CAACvD,IAAxB,CAA5B;AACAsD,QAAAA,WAAW,CAACwB,UAAU,EAAX,CAAX,GAA4B3G,KAAK,CAACqC,WAAN,CAAkB+C,KAAK,CAACrD,KAAxB,CAA5B;AACD;;AAED,UAAIiD,gBAAgB,IAAIzD,CAAC,KAAK0B,MAAM,GAAG,CAAvC,EAA0C;AACxC;AACD;;AAEDlD,MAAAA,UAAU,CAACkE,IAAX,CAAgB2C,CAAhB,EAAmB3B,cAAnB,EAAmCyB,aAAnC;AACAA,MAAAA,aAAa,IAAI,CAAjB;;AAEA,UAAIvG,OAAO,CAAC4C,MAAD,CAAX,EAAqB;AACnBqC,QAAAA,KAAK,GAAGrC,MAAM,CAACxB,CAAD,CAAd;AACA4D,QAAAA,WAAW,CAACwB,UAAU,EAAX,CAAX,GAA4B3G,KAAK,CAACqC,WAAN,CAAkB+C,KAAK,CAAC3D,GAAxB,CAA5B;AACA0D,QAAAA,WAAW,CAACwB,UAAU,EAAX,CAAX,GAA4B3G,KAAK,CAACqC,WAAN,CAAkB+C,KAAK,CAACzD,KAAxB,CAA5B;AACAwD,QAAAA,WAAW,CAACwB,UAAU,EAAX,CAAX,GAA4B3G,KAAK,CAACqC,WAAN,CAAkB+C,KAAK,CAACvD,IAAxB,CAA5B;AACAsD,QAAAA,WAAW,CAACwB,UAAU,EAAX,CAAX,GAA4B3G,KAAK,CAACqC,WAAN,CAAkB+C,KAAK,CAACrD,KAAxB,CAA5B;AACD;AACF;AACF;;AAED,MAAI8E,UAAU,GAAG,IAAIrG,kBAAJ,EAAjB;AACAqG,EAAAA,UAAU,CAACC,QAAX,GAAsB,IAAIvG,iBAAJ,CAAsB;AAC1CwG,IAAAA,iBAAiB,EAAE9G,iBAAiB,CAAC+G,MADK;AAE1CC,IAAAA,sBAAsB,EAAE,CAFkB;AAG1CC,IAAAA,MAAM,EAAEjC;AAHkC,GAAtB,CAAtB;;AAMA,MAAI9E,OAAO,CAAC4C,MAAD,CAAX,EAAqB;AACnB8D,IAAAA,UAAU,CAACzB,KAAX,GAAmB,IAAI7E,iBAAJ,CAAsB;AACvCwG,MAAAA,iBAAiB,EAAE9G,iBAAiB,CAACkH,aADE;AAEvCF,MAAAA,sBAAsB,EAAE,CAFe;AAGvCC,MAAAA,MAAM,EAAE/B,WAH+B;AAIvCiC,MAAAA,SAAS,EAAE;AAJ4B,KAAtB,CAAnB;AAMD;;AAEDlC,EAAAA,iBAAiB,GAAGD,cAAc,CAAChC,MAAf,GAAwB,CAA5C;AACA,MAAIoE,eAAe,GAAG,CAACnC,iBAAiB,GAAG,CAArB,IAA0B,CAAhD;AACA,MAAIoC,OAAO,GAAG7G,aAAa,CAAC8G,gBAAd,CACZrC,iBADY,EAEZmC,eAFY,CAAd;AAKA,MAAI3E,KAAK,GAAG,CAAZ;;AACA,OAAKnB,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG2D,iBAAiB,GAAG,CAApC,EAAuC,EAAE3D,CAAzC,EAA4C;AAC1C+F,IAAAA,OAAO,CAAC5E,KAAK,EAAN,CAAP,GAAmBnB,CAAnB;AACA+F,IAAAA,OAAO,CAAC5E,KAAK,EAAN,CAAP,GAAmBnB,CAAC,GAAG,CAAvB;AACD;;AAED,SAAO,IAAIjB,QAAJ,CAAa;AAClBuG,IAAAA,UAAU,EAAEA,UADM;AAElBS,IAAAA,OAAO,EAAEA,OAFS;AAGlBE,IAAAA,aAAa,EAAE5G,aAAa,CAAC6G,KAHX;AAIlBC,IAAAA,cAAc,EAAE5H,cAAc,CAAC6H,UAAf,CAA0B7E,SAA1B;AAJE,GAAb,CAAP;AAMD,CAxMD;;AAyMA,eAAeH,sBAAf","sourcesContent":["import ArcType from \"./ArcType.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Color from \"./Color.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nfunction interpolateColors(p0, p1, color0, color1, minDistance, array, offset) {\n  var numPoints = PolylinePipeline.numberOfPoints(p0, p1, minDistance);\n  var i;\n\n  var r0 = color0.red;\n  var g0 = color0.green;\n  var b0 = color0.blue;\n  var a0 = color0.alpha;\n\n  var r1 = color1.red;\n  var g1 = color1.green;\n  var b1 = color1.blue;\n  var a1 = color1.alpha;\n\n  if (Color.equals(color0, color1)) {\n    for (i = 0; i < numPoints; i++) {\n      array[offset++] = Color.floatToByte(r0);\n      array[offset++] = Color.floatToByte(g0);\n      array[offset++] = Color.floatToByte(b0);\n      array[offset++] = Color.floatToByte(a0);\n    }\n    return offset;\n  }\n\n  var redPerVertex = (r1 - r0) / numPoints;\n  var greenPerVertex = (g1 - g0) / numPoints;\n  var bluePerVertex = (b1 - b0) / numPoints;\n  var alphaPerVertex = (a1 - a0) / numPoints;\n\n  var index = offset;\n  for (i = 0; i < numPoints; i++) {\n    array[index++] = Color.floatToByte(r0 + i * redPerVertex);\n    array[index++] = Color.floatToByte(g0 + i * greenPerVertex);\n    array[index++] = Color.floatToByte(b0 + i * bluePerVertex);\n    array[index++] = Color.floatToByte(a0 + i * alphaPerVertex);\n  }\n\n  return index;\n}\n\n/**\n * A description of a polyline modeled as a line strip; the first two positions define a line segment,\n * and each additional position defines a line segment from the previous position.\n *\n * @alias SimplePolylineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the positions in the polyline as a line strip.\n * @param {Color[]} [options.colors] An Array of {@link Color} defining the per vertex or per segment colors.\n * @param {Boolean} [options.colorsPerVertex=false] A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude if options.arcType is not ArcType.NONE. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n *\n * @exception {DeveloperError} At least two positions are required.\n * @exception {DeveloperError} colors has an invalid length.\n *\n * @see SimplePolylineGeometry#createGeometry\n *\n * @example\n * // A polyline with two connected line segments\n * var polyline = new Cesium.SimplePolylineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     0.0, 0.0,\n *     5.0, 0.0,\n *     5.0, 5.0\n *   ])\n * });\n * var geometry = Cesium.SimplePolylineGeometry.createGeometry(polyline);\n */\nfunction SimplePolylineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var positions = options.positions;\n  var colors = options.colors;\n  var colorsPerVertex = defaultValue(options.colorsPerVertex, false);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions) || positions.length < 2) {\n    throw new DeveloperError(\"At least two positions are required.\");\n  }\n  if (\n    defined(colors) &&\n    ((colorsPerVertex && colors.length < positions.length) ||\n      (!colorsPerVertex && colors.length < positions.length - 1))\n  ) {\n    throw new DeveloperError(\"colors has an invalid length.\");\n  }\n  //>>includeEnd('debug');\n\n  this._positions = positions;\n  this._colors = colors;\n  this._colorsPerVertex = colorsPerVertex;\n\n  this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n  this._granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  this._workerName = \"createSimplePolylineGeometry\";\n\n  var numComponents = 1 + positions.length * Cartesian3.packedLength;\n  numComponents += defined(colors) ? 1 + colors.length * Color.packedLength : 1;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  this.packedLength = numComponents + Ellipsoid.packedLength + 3;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {SimplePolylineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nSimplePolylineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var i;\n\n  var positions = value._positions;\n  var length = positions.length;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  var colors = value._colors;\n  length = defined(colors) ? colors.length : 0.0;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n    Color.pack(colors[i], array, startingIndex);\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  array[startingIndex++] = value._colorsPerVertex ? 1.0 : 0.0;\n  array[startingIndex++] = value._arcType;\n  array[startingIndex] = value._granularity;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {SimplePolylineGeometry} [result] The object into which to store the result.\n * @returns {SimplePolylineGeometry} The modified result parameter or a new SimplePolylineGeometry instance if one was not provided.\n */\nSimplePolylineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var i;\n\n  var length = array[startingIndex++];\n  var positions = new Array(length);\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  length = array[startingIndex++];\n  var colors = length > 0 ? new Array(length) : undefined;\n\n  for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n    colors[i] = Color.unpack(array, startingIndex);\n  }\n\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  var colorsPerVertex = array[startingIndex++] === 1.0;\n  var arcType = array[startingIndex++];\n  var granularity = array[startingIndex];\n\n  if (!defined(result)) {\n    return new SimplePolylineGeometry({\n      positions: positions,\n      colors: colors,\n      ellipsoid: ellipsoid,\n      colorsPerVertex: colorsPerVertex,\n      arcType: arcType,\n      granularity: granularity,\n    });\n  }\n\n  result._positions = positions;\n  result._colors = colors;\n  result._ellipsoid = ellipsoid;\n  result._colorsPerVertex = colorsPerVertex;\n  result._arcType = arcType;\n  result._granularity = granularity;\n\n  return result;\n};\n\nvar scratchArray1 = new Array(2);\nvar scratchArray2 = new Array(2);\nvar generateArcOptionsScratch = {\n  positions: scratchArray1,\n  height: scratchArray2,\n  ellipsoid: undefined,\n  minDistance: undefined,\n  granularity: undefined,\n};\n\n/**\n * Computes the geometric representation of a simple polyline, including its vertices, indices, and a bounding sphere.\n *\n * @param {SimplePolylineGeometry} simplePolylineGeometry A description of the polyline.\n * @returns {Geometry} The computed vertices and indices.\n */\nSimplePolylineGeometry.createGeometry = function (simplePolylineGeometry) {\n  var positions = simplePolylineGeometry._positions;\n  var colors = simplePolylineGeometry._colors;\n  var colorsPerVertex = simplePolylineGeometry._colorsPerVertex;\n  var arcType = simplePolylineGeometry._arcType;\n  var granularity = simplePolylineGeometry._granularity;\n  var ellipsoid = simplePolylineGeometry._ellipsoid;\n\n  var minDistance = CesiumMath.chordLength(\n    granularity,\n    ellipsoid.maximumRadius\n  );\n  var perSegmentColors = defined(colors) && !colorsPerVertex;\n\n  var i;\n  var length = positions.length;\n\n  var positionValues;\n  var numberOfPositions;\n  var colorValues;\n  var color;\n  var offset = 0;\n\n  if (arcType === ArcType.GEODESIC || arcType === ArcType.RHUMB) {\n    var subdivisionSize;\n    var numberOfPointsFunction;\n    var generateArcFunction;\n    if (arcType === ArcType.GEODESIC) {\n      subdivisionSize = CesiumMath.chordLength(\n        granularity,\n        ellipsoid.maximumRadius\n      );\n      numberOfPointsFunction = PolylinePipeline.numberOfPoints;\n      generateArcFunction = PolylinePipeline.generateArc;\n    } else {\n      subdivisionSize = granularity;\n      numberOfPointsFunction = PolylinePipeline.numberOfPointsRhumbLine;\n      generateArcFunction = PolylinePipeline.generateRhumbArc;\n    }\n\n    var heights = PolylinePipeline.extractHeights(positions, ellipsoid);\n\n    var generateArcOptions = generateArcOptionsScratch;\n    if (arcType === ArcType.GEODESIC) {\n      generateArcOptions.minDistance = minDistance;\n    } else {\n      generateArcOptions.granularity = granularity;\n    }\n    generateArcOptions.ellipsoid = ellipsoid;\n\n    if (perSegmentColors) {\n      var positionCount = 0;\n      for (i = 0; i < length - 1; i++) {\n        positionCount +=\n          numberOfPointsFunction(\n            positions[i],\n            positions[i + 1],\n            subdivisionSize\n          ) + 1;\n      }\n\n      positionValues = new Float64Array(positionCount * 3);\n      colorValues = new Uint8Array(positionCount * 4);\n\n      generateArcOptions.positions = scratchArray1;\n      generateArcOptions.height = scratchArray2;\n\n      var ci = 0;\n      for (i = 0; i < length - 1; ++i) {\n        scratchArray1[0] = positions[i];\n        scratchArray1[1] = positions[i + 1];\n\n        scratchArray2[0] = heights[i];\n        scratchArray2[1] = heights[i + 1];\n\n        var pos = generateArcFunction(generateArcOptions);\n\n        if (defined(colors)) {\n          var segLen = pos.length / 3;\n          color = colors[i];\n          for (var k = 0; k < segLen; ++k) {\n            colorValues[ci++] = Color.floatToByte(color.red);\n            colorValues[ci++] = Color.floatToByte(color.green);\n            colorValues[ci++] = Color.floatToByte(color.blue);\n            colorValues[ci++] = Color.floatToByte(color.alpha);\n          }\n        }\n\n        positionValues.set(pos, offset);\n        offset += pos.length;\n      }\n    } else {\n      generateArcOptions.positions = positions;\n      generateArcOptions.height = heights;\n      positionValues = new Float64Array(\n        generateArcFunction(generateArcOptions)\n      );\n\n      if (defined(colors)) {\n        colorValues = new Uint8Array((positionValues.length / 3) * 4);\n\n        for (i = 0; i < length - 1; ++i) {\n          var p0 = positions[i];\n          var p1 = positions[i + 1];\n          var c0 = colors[i];\n          var c1 = colors[i + 1];\n          offset = interpolateColors(\n            p0,\n            p1,\n            c0,\n            c1,\n            minDistance,\n            colorValues,\n            offset\n          );\n        }\n\n        var lastColor = colors[length - 1];\n        colorValues[offset++] = Color.floatToByte(lastColor.red);\n        colorValues[offset++] = Color.floatToByte(lastColor.green);\n        colorValues[offset++] = Color.floatToByte(lastColor.blue);\n        colorValues[offset++] = Color.floatToByte(lastColor.alpha);\n      }\n    }\n  } else {\n    numberOfPositions = perSegmentColors ? length * 2 - 2 : length;\n    positionValues = new Float64Array(numberOfPositions * 3);\n    colorValues = defined(colors)\n      ? new Uint8Array(numberOfPositions * 4)\n      : undefined;\n\n    var positionIndex = 0;\n    var colorIndex = 0;\n\n    for (i = 0; i < length; ++i) {\n      var p = positions[i];\n\n      if (perSegmentColors && i > 0) {\n        Cartesian3.pack(p, positionValues, positionIndex);\n        positionIndex += 3;\n\n        color = colors[i - 1];\n        colorValues[colorIndex++] = Color.floatToByte(color.red);\n        colorValues[colorIndex++] = Color.floatToByte(color.green);\n        colorValues[colorIndex++] = Color.floatToByte(color.blue);\n        colorValues[colorIndex++] = Color.floatToByte(color.alpha);\n      }\n\n      if (perSegmentColors && i === length - 1) {\n        break;\n      }\n\n      Cartesian3.pack(p, positionValues, positionIndex);\n      positionIndex += 3;\n\n      if (defined(colors)) {\n        color = colors[i];\n        colorValues[colorIndex++] = Color.floatToByte(color.red);\n        colorValues[colorIndex++] = Color.floatToByte(color.green);\n        colorValues[colorIndex++] = Color.floatToByte(color.blue);\n        colorValues[colorIndex++] = Color.floatToByte(color.alpha);\n      }\n    }\n  }\n\n  var attributes = new GeometryAttributes();\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positionValues,\n  });\n\n  if (defined(colors)) {\n    attributes.color = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 4,\n      values: colorValues,\n      normalize: true,\n    });\n  }\n\n  numberOfPositions = positionValues.length / 3;\n  var numberOfIndices = (numberOfPositions - 1) * 2;\n  var indices = IndexDatatype.createTypedArray(\n    numberOfPositions,\n    numberOfIndices\n  );\n\n  var index = 0;\n  for (i = 0; i < numberOfPositions - 1; ++i) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: BoundingSphere.fromPoints(positions),\n  });\n};\nexport default SimplePolylineGeometry;\n"]},"metadata":{},"sourceType":"module"}