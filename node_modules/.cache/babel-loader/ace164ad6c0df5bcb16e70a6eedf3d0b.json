{"ast":null,"code":"import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport EllipseGeometryLibrary from \"./EllipseGeometryLibrary.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nvar scratchCartesian1 = new Cartesian3();\nvar scratchCartesian2 = new Cartesian3();\nvar scratchCartesian3 = new Cartesian3();\nvar scratchCartesian4 = new Cartesian3();\nvar texCoordScratch = new Cartesian2();\nvar textureMatrixScratch = new Matrix3();\nvar tangentMatrixScratch = new Matrix3();\nvar quaternionScratch = new Quaternion();\nvar scratchNormal = new Cartesian3();\nvar scratchTangent = new Cartesian3();\nvar scratchBitangent = new Cartesian3();\nvar scratchCartographic = new Cartographic();\nvar projectedCenterScratch = new Cartesian3();\nvar scratchMinTexCoord = new Cartesian2();\nvar scratchMaxTexCoord = new Cartesian2();\n\nfunction computeTopBottomAttributes(positions, options, extrude) {\n  var vertexFormat = options.vertexFormat;\n  var center = options.center;\n  var semiMajorAxis = options.semiMajorAxis;\n  var semiMinorAxis = options.semiMinorAxis;\n  var ellipsoid = options.ellipsoid;\n  var stRotation = options.stRotation;\n  var size = extrude ? positions.length / 3 * 2 : positions.length / 3;\n  var shadowVolume = options.shadowVolume;\n  var textureCoordinates = vertexFormat.st ? new Float32Array(size * 2) : undefined;\n  var normals = vertexFormat.normal ? new Float32Array(size * 3) : undefined;\n  var tangents = vertexFormat.tangent ? new Float32Array(size * 3) : undefined;\n  var bitangents = vertexFormat.bitangent ? new Float32Array(size * 3) : undefined;\n  var extrudeNormals = shadowVolume ? new Float32Array(size * 3) : undefined;\n  var textureCoordIndex = 0; // Raise positions to a height above the ellipsoid and compute the\n  // texture coordinates, normals, tangents, and bitangents.\n\n  var normal = scratchNormal;\n  var tangent = scratchTangent;\n  var bitangent = scratchBitangent;\n  var projection = new GeographicProjection(ellipsoid);\n  var projectedCenter = projection.project(ellipsoid.cartesianToCartographic(center, scratchCartographic), projectedCenterScratch);\n  var geodeticNormal = ellipsoid.scaleToGeodeticSurface(center, scratchCartesian1);\n  ellipsoid.geodeticSurfaceNormal(geodeticNormal, geodeticNormal);\n  var textureMatrix = textureMatrixScratch;\n  var tangentMatrix = tangentMatrixScratch;\n\n  if (stRotation !== 0) {\n    var rotation = Quaternion.fromAxisAngle(geodeticNormal, stRotation, quaternionScratch);\n    textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n    rotation = Quaternion.fromAxisAngle(geodeticNormal, -stRotation, quaternionScratch);\n    tangentMatrix = Matrix3.fromQuaternion(rotation, tangentMatrix);\n  } else {\n    textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n    tangentMatrix = Matrix3.clone(Matrix3.IDENTITY, tangentMatrix);\n  }\n\n  var minTexCoord = Cartesian2.fromElements(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, scratchMinTexCoord);\n  var maxTexCoord = Cartesian2.fromElements(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, scratchMaxTexCoord);\n  var length = positions.length;\n  var bottomOffset = extrude ? length : 0;\n  var stOffset = bottomOffset / 3 * 2;\n\n  for (var i = 0; i < length; i += 3) {\n    var i1 = i + 1;\n    var i2 = i + 2;\n    var position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n\n    if (vertexFormat.st) {\n      var rotatedPoint = Matrix3.multiplyByVector(textureMatrix, position, scratchCartesian2);\n      var projectedPoint = projection.project(ellipsoid.cartesianToCartographic(rotatedPoint, scratchCartographic), scratchCartesian3);\n      Cartesian3.subtract(projectedPoint, projectedCenter, projectedPoint);\n      texCoordScratch.x = (projectedPoint.x + semiMajorAxis) / (2.0 * semiMajorAxis);\n      texCoordScratch.y = (projectedPoint.y + semiMinorAxis) / (2.0 * semiMinorAxis);\n      minTexCoord.x = Math.min(texCoordScratch.x, minTexCoord.x);\n      minTexCoord.y = Math.min(texCoordScratch.y, minTexCoord.y);\n      maxTexCoord.x = Math.max(texCoordScratch.x, maxTexCoord.x);\n      maxTexCoord.y = Math.max(texCoordScratch.y, maxTexCoord.y);\n\n      if (extrude) {\n        textureCoordinates[textureCoordIndex + stOffset] = texCoordScratch.x;\n        textureCoordinates[textureCoordIndex + 1 + stOffset] = texCoordScratch.y;\n      }\n\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.x;\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.y;\n    }\n\n    if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent || shadowVolume) {\n      normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n\n      if (shadowVolume) {\n        extrudeNormals[i + bottomOffset] = -normal.x;\n        extrudeNormals[i1 + bottomOffset] = -normal.y;\n        extrudeNormals[i2 + bottomOffset] = -normal.z;\n      }\n\n      if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n        if (vertexFormat.tangent || vertexFormat.bitangent) {\n          tangent = Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent), tangent);\n          Matrix3.multiplyByVector(tangentMatrix, tangent, tangent);\n        }\n\n        if (vertexFormat.normal) {\n          normals[i] = normal.x;\n          normals[i1] = normal.y;\n          normals[i2] = normal.z;\n\n          if (extrude) {\n            normals[i + bottomOffset] = -normal.x;\n            normals[i1 + bottomOffset] = -normal.y;\n            normals[i2 + bottomOffset] = -normal.z;\n          }\n        }\n\n        if (vertexFormat.tangent) {\n          tangents[i] = tangent.x;\n          tangents[i1] = tangent.y;\n          tangents[i2] = tangent.z;\n\n          if (extrude) {\n            tangents[i + bottomOffset] = -tangent.x;\n            tangents[i1 + bottomOffset] = -tangent.y;\n            tangents[i2 + bottomOffset] = -tangent.z;\n          }\n        }\n\n        if (vertexFormat.bitangent) {\n          bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n          bitangents[i] = bitangent.x;\n          bitangents[i1] = bitangent.y;\n          bitangents[i2] = bitangent.z;\n\n          if (extrude) {\n            bitangents[i + bottomOffset] = bitangent.x;\n            bitangents[i1 + bottomOffset] = bitangent.y;\n            bitangents[i2 + bottomOffset] = bitangent.z;\n          }\n        }\n      }\n    }\n  }\n\n  if (vertexFormat.st) {\n    length = textureCoordinates.length;\n\n    for (var k = 0; k < length; k += 2) {\n      textureCoordinates[k] = (textureCoordinates[k] - minTexCoord.x) / (maxTexCoord.x - minTexCoord.x);\n      textureCoordinates[k + 1] = (textureCoordinates[k + 1] - minTexCoord.y) / (maxTexCoord.y - minTexCoord.y);\n    }\n  }\n\n  var attributes = new GeometryAttributes();\n\n  if (vertexFormat.position) {\n    var finalPositions = EllipseGeometryLibrary.raisePositionsToHeight(positions, options, extrude);\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: finalPositions\n    });\n  }\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: textureCoordinates\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents\n    });\n  }\n\n  if (shadowVolume) {\n    attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals\n    });\n  }\n\n  if (extrude && defined(options.offsetAttribute)) {\n    var offsetAttribute = new Uint8Array(size);\n\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n    } else {\n      var offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n    }\n\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute\n    });\n  }\n\n  return attributes;\n}\n\nfunction topIndices(numPts) {\n  // numTriangles in half = 3 + 8 + 12 + ... = -1 + 4 + (4 + 4) + (4 + 4 + 4) + ... = -1 + 4 * (1 + 2 + 3 + ...)\n  //              = -1 + 4 * ((n * ( n + 1)) / 2)\n  // total triangles = 2 * numTrangles in half\n  // indices = total triangles * 3;\n  // Substitute numPts for n above\n  var indices = new Array(12 * (numPts * (numPts + 1)) - 6);\n  var indicesIndex = 0;\n  var prevIndex;\n  var numInterior;\n  var positionIndex;\n  var i;\n  var j; // Indices triangles to the 'right' of the north vector\n\n  prevIndex = 0;\n  positionIndex = 1;\n\n  for (i = 0; i < 3; i++) {\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n\n  for (i = 2; i < numPts + 1; ++i) {\n    positionIndex = i * (i + 1) - 1;\n    prevIndex = (i - 1) * i - 1;\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n    numInterior = 2 * i;\n\n    for (j = 0; j < numInterior - 1; ++j) {\n      indices[indicesIndex++] = positionIndex;\n      indices[indicesIndex++] = prevIndex++;\n      indices[indicesIndex++] = prevIndex;\n      indices[indicesIndex++] = positionIndex++;\n      indices[indicesIndex++] = prevIndex;\n      indices[indicesIndex++] = positionIndex;\n    }\n\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  } // Indices for center column of triangles\n\n\n  numInterior = numPts * 2;\n  ++positionIndex;\n  ++prevIndex;\n\n  for (i = 0; i < numInterior - 1; ++i) {\n    indices[indicesIndex++] = positionIndex;\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n\n  indices[indicesIndex++] = positionIndex;\n  indices[indicesIndex++] = prevIndex++;\n  indices[indicesIndex++] = prevIndex;\n  indices[indicesIndex++] = positionIndex++;\n  indices[indicesIndex++] = prevIndex++;\n  indices[indicesIndex++] = prevIndex; // Reverse the process creating indices to the 'left' of the north vector\n\n  ++prevIndex;\n\n  for (i = numPts - 1; i > 1; --i) {\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n    numInterior = 2 * i;\n\n    for (j = 0; j < numInterior - 1; ++j) {\n      indices[indicesIndex++] = positionIndex;\n      indices[indicesIndex++] = prevIndex++;\n      indices[indicesIndex++] = prevIndex;\n      indices[indicesIndex++] = positionIndex++;\n      indices[indicesIndex++] = prevIndex;\n      indices[indicesIndex++] = positionIndex;\n    }\n\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = positionIndex++;\n  }\n\n  for (i = 0; i < 3; i++) {\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n\n  return indices;\n}\n\nvar boundingSphereCenter = new Cartesian3();\n\nfunction computeEllipse(options) {\n  var center = options.center;\n  boundingSphereCenter = Cartesian3.multiplyByScalar(options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter), options.height, boundingSphereCenter);\n  boundingSphereCenter = Cartesian3.add(center, boundingSphereCenter, boundingSphereCenter);\n  var boundingSphere = new BoundingSphere(boundingSphereCenter, options.semiMajorAxis);\n  var cep = EllipseGeometryLibrary.computeEllipsePositions(options, true, false);\n  var positions = cep.positions;\n  var numPts = cep.numPts;\n  var attributes = computeTopBottomAttributes(positions, options, false);\n  var indices = topIndices(numPts);\n  indices = IndexDatatype.createTypedArray(positions.length / 3, indices);\n  return {\n    boundingSphere: boundingSphere,\n    attributes: attributes,\n    indices: indices\n  };\n}\n\nfunction computeWallAttributes(positions, options) {\n  var vertexFormat = options.vertexFormat;\n  var center = options.center;\n  var semiMajorAxis = options.semiMajorAxis;\n  var semiMinorAxis = options.semiMinorAxis;\n  var ellipsoid = options.ellipsoid;\n  var height = options.height;\n  var extrudedHeight = options.extrudedHeight;\n  var stRotation = options.stRotation;\n  var size = positions.length / 3 * 2;\n  var finalPositions = new Float64Array(size * 3);\n  var textureCoordinates = vertexFormat.st ? new Float32Array(size * 2) : undefined;\n  var normals = vertexFormat.normal ? new Float32Array(size * 3) : undefined;\n  var tangents = vertexFormat.tangent ? new Float32Array(size * 3) : undefined;\n  var bitangents = vertexFormat.bitangent ? new Float32Array(size * 3) : undefined;\n  var shadowVolume = options.shadowVolume;\n  var extrudeNormals = shadowVolume ? new Float32Array(size * 3) : undefined;\n  var textureCoordIndex = 0; // Raise positions to a height above the ellipsoid and compute the\n  // texture coordinates, normals, tangents, and bitangents.\n\n  var normal = scratchNormal;\n  var tangent = scratchTangent;\n  var bitangent = scratchBitangent;\n  var projection = new GeographicProjection(ellipsoid);\n  var projectedCenter = projection.project(ellipsoid.cartesianToCartographic(center, scratchCartographic), projectedCenterScratch);\n  var geodeticNormal = ellipsoid.scaleToGeodeticSurface(center, scratchCartesian1);\n  ellipsoid.geodeticSurfaceNormal(geodeticNormal, geodeticNormal);\n  var rotation = Quaternion.fromAxisAngle(geodeticNormal, stRotation, quaternionScratch);\n  var textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrixScratch);\n  var minTexCoord = Cartesian2.fromElements(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, scratchMinTexCoord);\n  var maxTexCoord = Cartesian2.fromElements(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, scratchMaxTexCoord);\n  var length = positions.length;\n  var stOffset = length / 3 * 2;\n\n  for (var i = 0; i < length; i += 3) {\n    var i1 = i + 1;\n    var i2 = i + 2;\n    var position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n    var extrudedPosition;\n\n    if (vertexFormat.st) {\n      var rotatedPoint = Matrix3.multiplyByVector(textureMatrix, position, scratchCartesian2);\n      var projectedPoint = projection.project(ellipsoid.cartesianToCartographic(rotatedPoint, scratchCartographic), scratchCartesian3);\n      Cartesian3.subtract(projectedPoint, projectedCenter, projectedPoint);\n      texCoordScratch.x = (projectedPoint.x + semiMajorAxis) / (2.0 * semiMajorAxis);\n      texCoordScratch.y = (projectedPoint.y + semiMinorAxis) / (2.0 * semiMinorAxis);\n      minTexCoord.x = Math.min(texCoordScratch.x, minTexCoord.x);\n      minTexCoord.y = Math.min(texCoordScratch.y, minTexCoord.y);\n      maxTexCoord.x = Math.max(texCoordScratch.x, maxTexCoord.x);\n      maxTexCoord.y = Math.max(texCoordScratch.y, maxTexCoord.y);\n      textureCoordinates[textureCoordIndex + stOffset] = texCoordScratch.x;\n      textureCoordinates[textureCoordIndex + 1 + stOffset] = texCoordScratch.y;\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.x;\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.y;\n    }\n\n    position = ellipsoid.scaleToGeodeticSurface(position, position);\n    extrudedPosition = Cartesian3.clone(position, scratchCartesian2);\n    normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n\n    if (shadowVolume) {\n      extrudeNormals[i + length] = -normal.x;\n      extrudeNormals[i1 + length] = -normal.y;\n      extrudeNormals[i2 + length] = -normal.z;\n    }\n\n    var scaledNormal = Cartesian3.multiplyByScalar(normal, height, scratchCartesian4);\n    position = Cartesian3.add(position, scaledNormal, position);\n    scaledNormal = Cartesian3.multiplyByScalar(normal, extrudedHeight, scaledNormal);\n    extrudedPosition = Cartesian3.add(extrudedPosition, scaledNormal, extrudedPosition);\n\n    if (vertexFormat.position) {\n      finalPositions[i + length] = extrudedPosition.x;\n      finalPositions[i1 + length] = extrudedPosition.y;\n      finalPositions[i2 + length] = extrudedPosition.z;\n      finalPositions[i] = position.x;\n      finalPositions[i1] = position.y;\n      finalPositions[i2] = position.z;\n    }\n\n    if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n      bitangent = Cartesian3.clone(normal, bitangent);\n      var next = Cartesian3.fromArray(positions, (i + 3) % length, scratchCartesian4);\n      Cartesian3.subtract(next, position, next);\n      var bottom = Cartesian3.subtract(extrudedPosition, position, scratchCartesian3);\n      normal = Cartesian3.normalize(Cartesian3.cross(bottom, next, normal), normal);\n\n      if (vertexFormat.normal) {\n        normals[i] = normal.x;\n        normals[i1] = normal.y;\n        normals[i2] = normal.z;\n        normals[i + length] = normal.x;\n        normals[i1 + length] = normal.y;\n        normals[i2 + length] = normal.z;\n      }\n\n      if (vertexFormat.tangent) {\n        tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);\n        tangents[i] = tangent.x;\n        tangents[i1] = tangent.y;\n        tangents[i2] = tangent.z;\n        tangents[i + length] = tangent.x;\n        tangents[i + 1 + length] = tangent.y;\n        tangents[i + 2 + length] = tangent.z;\n      }\n\n      if (vertexFormat.bitangent) {\n        bitangents[i] = bitangent.x;\n        bitangents[i1] = bitangent.y;\n        bitangents[i2] = bitangent.z;\n        bitangents[i + length] = bitangent.x;\n        bitangents[i1 + length] = bitangent.y;\n        bitangents[i2 + length] = bitangent.z;\n      }\n    }\n  }\n\n  if (vertexFormat.st) {\n    length = textureCoordinates.length;\n\n    for (var k = 0; k < length; k += 2) {\n      textureCoordinates[k] = (textureCoordinates[k] - minTexCoord.x) / (maxTexCoord.x - minTexCoord.x);\n      textureCoordinates[k + 1] = (textureCoordinates[k + 1] - minTexCoord.y) / (maxTexCoord.y - minTexCoord.y);\n    }\n  }\n\n  var attributes = new GeometryAttributes();\n\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: finalPositions\n    });\n  }\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: textureCoordinates\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents\n    });\n  }\n\n  if (shadowVolume) {\n    attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals\n    });\n  }\n\n  if (defined(options.offsetAttribute)) {\n    var offsetAttribute = new Uint8Array(size);\n\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n    } else {\n      var offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n    }\n\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute\n    });\n  }\n\n  return attributes;\n}\n\nfunction computeWallIndices(positions) {\n  var length = positions.length / 3;\n  var indices = IndexDatatype.createTypedArray(length, length * 6);\n  var index = 0;\n\n  for (var i = 0; i < length; i++) {\n    var UL = i;\n    var LL = i + length;\n    var UR = (UL + 1) % length;\n    var LR = UR + length;\n    indices[index++] = UL;\n    indices[index++] = LL;\n    indices[index++] = UR;\n    indices[index++] = UR;\n    indices[index++] = LL;\n    indices[index++] = LR;\n  }\n\n  return indices;\n}\n\nvar topBoundingSphere = new BoundingSphere();\nvar bottomBoundingSphere = new BoundingSphere();\n\nfunction computeExtrudedEllipse(options) {\n  var center = options.center;\n  var ellipsoid = options.ellipsoid;\n  var semiMajorAxis = options.semiMajorAxis;\n  var scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1), options.height, scratchCartesian1);\n  topBoundingSphere.center = Cartesian3.add(center, scaledNormal, topBoundingSphere.center);\n  topBoundingSphere.radius = semiMajorAxis;\n  scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scaledNormal), options.extrudedHeight, scaledNormal);\n  bottomBoundingSphere.center = Cartesian3.add(center, scaledNormal, bottomBoundingSphere.center);\n  bottomBoundingSphere.radius = semiMajorAxis;\n  var cep = EllipseGeometryLibrary.computeEllipsePositions(options, true, true);\n  var positions = cep.positions;\n  var numPts = cep.numPts;\n  var outerPositions = cep.outerPositions;\n  var boundingSphere = BoundingSphere.union(topBoundingSphere, bottomBoundingSphere);\n  var topBottomAttributes = computeTopBottomAttributes(positions, options, true);\n  var indices = topIndices(numPts);\n  var length = indices.length;\n  indices.length = length * 2;\n  var posLength = positions.length / 3;\n\n  for (var i = 0; i < length; i += 3) {\n    indices[i + length] = indices[i + 2] + posLength;\n    indices[i + 1 + length] = indices[i + 1] + posLength;\n    indices[i + 2 + length] = indices[i] + posLength;\n  }\n\n  var topBottomIndices = IndexDatatype.createTypedArray(posLength * 2 / 3, indices);\n  var topBottomGeo = new Geometry({\n    attributes: topBottomAttributes,\n    indices: topBottomIndices,\n    primitiveType: PrimitiveType.TRIANGLES\n  });\n  var wallAttributes = computeWallAttributes(outerPositions, options);\n  indices = computeWallIndices(outerPositions);\n  var wallIndices = IndexDatatype.createTypedArray(outerPositions.length * 2 / 3, indices);\n  var wallGeo = new Geometry({\n    attributes: wallAttributes,\n    indices: wallIndices,\n    primitiveType: PrimitiveType.TRIANGLES\n  });\n  var geo = GeometryPipeline.combineInstances([new GeometryInstance({\n    geometry: topBottomGeo\n  }), new GeometryInstance({\n    geometry: wallGeo\n  })]);\n  return {\n    boundingSphere: boundingSphere,\n    attributes: geo[0].attributes,\n    indices: geo[0].indices\n  };\n}\n\nfunction computeRectangle(center, semiMajorAxis, semiMinorAxis, rotation, granularity, ellipsoid, result) {\n  var cep = EllipseGeometryLibrary.computeEllipsePositions({\n    center: center,\n    semiMajorAxis: semiMajorAxis,\n    semiMinorAxis: semiMinorAxis,\n    rotation: rotation,\n    granularity: granularity\n  }, false, true);\n  var positionsFlat = cep.outerPositions;\n  var positionsCount = positionsFlat.length / 3;\n  var positions = new Array(positionsCount);\n\n  for (var i = 0; i < positionsCount; ++i) {\n    positions[i] = Cartesian3.fromArray(positionsFlat, i * 3);\n  }\n\n  var rectangle = Rectangle.fromCartesianArray(positions, ellipsoid, result); // Rectangle width goes beyond 180 degrees when the ellipse crosses a pole.\n  // When this happens, make the rectangle into a \"circle\" around the pole\n\n  if (rectangle.width > CesiumMath.PI) {\n    rectangle.north = rectangle.north > 0.0 ? CesiumMath.PI_OVER_TWO - CesiumMath.EPSILON7 : rectangle.north;\n    rectangle.south = rectangle.south < 0.0 ? CesiumMath.EPSILON7 - CesiumMath.PI_OVER_TWO : rectangle.south;\n    rectangle.east = CesiumMath.PI;\n    rectangle.west = -CesiumMath.PI;\n  }\n\n  return rectangle;\n}\n/**\n * A description of an ellipse on an ellipsoid. Ellipse geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias EllipseGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.\n * @param {Number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.\n * @param {Number} [options.extrudedHeight] The distance in meters between the ellipse's extruded face and the ellipsoid surface.\n * @param {Number} [options.rotation=0.0] The angle of rotation counter-clockwise from north.\n * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates counter-clockwise from north.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The angular distance between points on the ellipse in radians.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.\n * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.\n * @exception {DeveloperError} granularity must be greater than zero.\n *\n *\n * @example\n * // Create an ellipse.\n * var ellipse = new Cesium.EllipseGeometry({\n *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n *   semiMajorAxis : 500000.0,\n *   semiMinorAxis : 300000.0,\n *   rotation : Cesium.Math.toRadians(60.0)\n * });\n * var geometry = Cesium.EllipseGeometry.createGeometry(ellipse);\n *\n * @see EllipseGeometry.createGeometry\n */\n\n\nfunction EllipseGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var center = options.center;\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var semiMajorAxis = options.semiMajorAxis;\n  var semiMinorAxis = options.semiMinorAxis;\n  var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n  var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT); //>>includeStart('debug', pragmas.debug);\n\n  Check.defined(\"options.center\", center);\n  Check.typeOf.number(\"options.semiMajorAxis\", semiMajorAxis);\n  Check.typeOf.number(\"options.semiMinorAxis\", semiMinorAxis);\n\n  if (semiMajorAxis < semiMinorAxis) {\n    throw new DeveloperError(\"semiMajorAxis must be greater than or equal to the semiMinorAxis.\");\n  }\n\n  if (granularity <= 0.0) {\n    throw new DeveloperError(\"granularity must be greater than zero.\");\n  } //>>includeEnd('debug');\n\n\n  var height = defaultValue(options.height, 0.0);\n  var extrudedHeight = defaultValue(options.extrudedHeight, height);\n  this._center = Cartesian3.clone(center);\n  this._semiMajorAxis = semiMajorAxis;\n  this._semiMinorAxis = semiMinorAxis;\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._rotation = defaultValue(options.rotation, 0.0);\n  this._stRotation = defaultValue(options.stRotation, 0.0);\n  this._height = Math.max(extrudedHeight, height);\n  this._granularity = granularity;\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._extrudedHeight = Math.min(extrudedHeight, height);\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\n  this._workerName = \"createEllipseGeometry\";\n  this._offsetAttribute = options.offsetAttribute;\n  this._rectangle = undefined;\n  this._textureCoordinateRotationPoints = undefined;\n}\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\n\n\nEllipseGeometry.packedLength = Cartesian3.packedLength + Ellipsoid.packedLength + VertexFormat.packedLength + 9;\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipseGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\nEllipseGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"value\", value);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  Cartesian3.pack(value._center, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n  array[startingIndex++] = value._semiMajorAxis;\n  array[startingIndex++] = value._semiMinorAxis;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._stRotation;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n  return array;\n};\n\nvar scratchCenter = new Cartesian3();\nvar scratchEllipsoid = new Ellipsoid();\nvar scratchVertexFormat = new VertexFormat();\nvar scratchOptions = {\n  center: scratchCenter,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  semiMajorAxis: undefined,\n  semiMinorAxis: undefined,\n  rotation: undefined,\n  stRotation: undefined,\n  height: undefined,\n  granularity: undefined,\n  extrudedHeight: undefined,\n  shadowVolume: undefined,\n  offsetAttribute: undefined\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipseGeometry} [result] The object into which to store the result.\n * @returns {EllipseGeometry} The modified result parameter or a new EllipseGeometry instance if one was not provided.\n */\n\nEllipseGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var center = Cartesian3.unpack(array, startingIndex, scratchCenter);\n  startingIndex += Cartesian3.packedLength;\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n  var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n  startingIndex += VertexFormat.packedLength;\n  var semiMajorAxis = array[startingIndex++];\n  var semiMinorAxis = array[startingIndex++];\n  var rotation = array[startingIndex++];\n  var stRotation = array[startingIndex++];\n  var height = array[startingIndex++];\n  var granularity = array[startingIndex++];\n  var extrudedHeight = array[startingIndex++];\n  var shadowVolume = array[startingIndex++] === 1.0;\n  var offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.granularity = granularity;\n    scratchOptions.stRotation = stRotation;\n    scratchOptions.rotation = rotation;\n    scratchOptions.semiMajorAxis = semiMajorAxis;\n    scratchOptions.semiMinorAxis = semiMinorAxis;\n    scratchOptions.shadowVolume = shadowVolume;\n    scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new EllipseGeometry(scratchOptions);\n  }\n\n  result._center = Cartesian3.clone(center, result._center);\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._semiMajorAxis = semiMajorAxis;\n  result._semiMinorAxis = semiMinorAxis;\n  result._rotation = rotation;\n  result._stRotation = stRotation;\n  result._height = height;\n  result._granularity = granularity;\n  result._extrudedHeight = extrudedHeight;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n  return result;\n};\n/**\n * Computes the bounding rectangle based on the provided options\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.\n * @param {Number} [options.rotation=0.0] The angle of rotation counter-clockwise from north.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The angular distance between points on the ellipse in radians.\n * @param {Rectangle} [result] An object in which to store the result\n *\n * @returns {Rectangle} The result rectangle\n */\n\n\nEllipseGeometry.computeRectangle = function (options, result) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var center = options.center;\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var semiMajorAxis = options.semiMajorAxis;\n  var semiMinorAxis = options.semiMinorAxis;\n  var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n  var rotation = defaultValue(options.rotation, 0.0); //>>includeStart('debug', pragmas.debug);\n\n  Check.defined(\"options.center\", center);\n  Check.typeOf.number(\"options.semiMajorAxis\", semiMajorAxis);\n  Check.typeOf.number(\"options.semiMinorAxis\", semiMinorAxis);\n\n  if (semiMajorAxis < semiMinorAxis) {\n    throw new DeveloperError(\"semiMajorAxis must be greater than or equal to the semiMinorAxis.\");\n  }\n\n  if (granularity <= 0.0) {\n    throw new DeveloperError(\"granularity must be greater than zero.\");\n  } //>>includeEnd('debug');\n\n\n  return computeRectangle(center, semiMajorAxis, semiMinorAxis, rotation, granularity, ellipsoid, result);\n};\n/**\n * Computes the geometric representation of a ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipseGeometry} ellipseGeometry A description of the ellipse.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\n\n\nEllipseGeometry.createGeometry = function (ellipseGeometry) {\n  if (ellipseGeometry._semiMajorAxis <= 0.0 || ellipseGeometry._semiMinorAxis <= 0.0) {\n    return;\n  }\n\n  var height = ellipseGeometry._height;\n  var extrudedHeight = ellipseGeometry._extrudedHeight;\n  var extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n  ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(ellipseGeometry._center, ellipseGeometry._center);\n  var options = {\n    center: ellipseGeometry._center,\n    semiMajorAxis: ellipseGeometry._semiMajorAxis,\n    semiMinorAxis: ellipseGeometry._semiMinorAxis,\n    ellipsoid: ellipseGeometry._ellipsoid,\n    rotation: ellipseGeometry._rotation,\n    height: height,\n    granularity: ellipseGeometry._granularity,\n    vertexFormat: ellipseGeometry._vertexFormat,\n    stRotation: ellipseGeometry._stRotation\n  };\n  var geometry;\n\n  if (extrude) {\n    options.extrudedHeight = extrudedHeight;\n    options.shadowVolume = ellipseGeometry._shadowVolume;\n    options.offsetAttribute = ellipseGeometry._offsetAttribute;\n    geometry = computeExtrudedEllipse(options);\n  } else {\n    geometry = computeEllipse(options);\n\n    if (defined(ellipseGeometry._offsetAttribute)) {\n      var length = geometry.attributes.position.values.length;\n      var applyOffset = new Uint8Array(length / 3);\n      var offsetValue = ellipseGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      arrayFill(applyOffset, offsetValue);\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset\n      });\n    }\n  }\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: geometry.boundingSphere,\n    offsetAttribute: ellipseGeometry._offsetAttribute\n  });\n};\n/**\n * @private\n */\n\n\nEllipseGeometry.createShadowVolume = function (ellipseGeometry, minHeightFunc, maxHeightFunc) {\n  var granularity = ellipseGeometry._granularity;\n  var ellipsoid = ellipseGeometry._ellipsoid;\n  var minHeight = minHeightFunc(granularity, ellipsoid);\n  var maxHeight = maxHeightFunc(granularity, ellipsoid);\n  return new EllipseGeometry({\n    center: ellipseGeometry._center,\n    semiMajorAxis: ellipseGeometry._semiMajorAxis,\n    semiMinorAxis: ellipseGeometry._semiMinorAxis,\n    ellipsoid: ellipsoid,\n    rotation: ellipseGeometry._rotation,\n    stRotation: ellipseGeometry._stRotation,\n    granularity: granularity,\n    extrudedHeight: minHeight,\n    height: maxHeight,\n    vertexFormat: VertexFormat.POSITION_ONLY,\n    shadowVolume: true\n  });\n};\n\nfunction textureCoordinateRotationPoints(ellipseGeometry) {\n  var stRotation = -ellipseGeometry._stRotation;\n\n  if (stRotation === 0.0) {\n    return [0, 0, 0, 1, 1, 0];\n  }\n\n  var cep = EllipseGeometryLibrary.computeEllipsePositions({\n    center: ellipseGeometry._center,\n    semiMajorAxis: ellipseGeometry._semiMajorAxis,\n    semiMinorAxis: ellipseGeometry._semiMinorAxis,\n    rotation: ellipseGeometry._rotation,\n    granularity: ellipseGeometry._granularity\n  }, false, true);\n  var positionsFlat = cep.outerPositions;\n  var positionsCount = positionsFlat.length / 3;\n  var positions = new Array(positionsCount);\n\n  for (var i = 0; i < positionsCount; ++i) {\n    positions[i] = Cartesian3.fromArray(positionsFlat, i * 3);\n  }\n\n  var ellipsoid = ellipseGeometry._ellipsoid;\n  var boundingRectangle = ellipseGeometry.rectangle;\n  return Geometry._textureCoordinateRotationPoints(positions, stRotation, ellipsoid, boundingRectangle);\n}\n\nObject.defineProperties(EllipseGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function get() {\n      if (!defined(this._rectangle)) {\n        this._rectangle = computeRectangle(this._center, this._semiMajorAxis, this._semiMinorAxis, this._rotation, this._granularity, this._ellipsoid);\n      }\n\n      return this._rectangle;\n    }\n  },\n\n  /**\n   * For remapping texture coordinates when rendering EllipseGeometries as GroundPrimitives.\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function get() {\n      if (!defined(this._textureCoordinateRotationPoints)) {\n        this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(this);\n      }\n\n      return this._textureCoordinateRotationPoints;\n    }\n  }\n});\nexport default EllipseGeometry;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/EllipseGeometry.js"],"names":["arrayFill","BoundingSphere","Cartesian2","Cartesian3","Cartographic","Check","ComponentDatatype","defaultValue","defined","DeveloperError","EllipseGeometryLibrary","Ellipsoid","GeographicProjection","Geometry","GeometryAttribute","GeometryAttributes","GeometryInstance","GeometryOffsetAttribute","GeometryPipeline","IndexDatatype","CesiumMath","Matrix3","PrimitiveType","Quaternion","Rectangle","VertexFormat","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchCartesian4","texCoordScratch","textureMatrixScratch","tangentMatrixScratch","quaternionScratch","scratchNormal","scratchTangent","scratchBitangent","scratchCartographic","projectedCenterScratch","scratchMinTexCoord","scratchMaxTexCoord","computeTopBottomAttributes","positions","options","extrude","vertexFormat","center","semiMajorAxis","semiMinorAxis","ellipsoid","stRotation","size","length","shadowVolume","textureCoordinates","st","Float32Array","undefined","normals","normal","tangents","tangent","bitangents","bitangent","extrudeNormals","textureCoordIndex","projection","projectedCenter","project","cartesianToCartographic","geodeticNormal","scaleToGeodeticSurface","geodeticSurfaceNormal","textureMatrix","tangentMatrix","rotation","fromAxisAngle","fromQuaternion","clone","IDENTITY","minTexCoord","fromElements","Number","POSITIVE_INFINITY","maxTexCoord","NEGATIVE_INFINITY","bottomOffset","stOffset","i","i1","i2","position","fromArray","rotatedPoint","multiplyByVector","projectedPoint","subtract","x","y","Math","min","max","z","normalize","cross","UNIT_Z","k","attributes","finalPositions","raisePositionsToHeight","componentDatatype","DOUBLE","componentsPerAttribute","values","FLOAT","extrudeDirection","offsetAttribute","Uint8Array","TOP","offsetValue","NONE","applyOffset","UNSIGNED_BYTE","topIndices","numPts","indices","Array","indicesIndex","prevIndex","numInterior","positionIndex","j","boundingSphereCenter","computeEllipse","multiplyByScalar","height","add","boundingSphere","cep","computeEllipsePositions","createTypedArray","computeWallAttributes","extrudedHeight","Float64Array","extrudedPosition","scaledNormal","next","bottom","computeWallIndices","index","UL","LL","UR","LR","topBoundingSphere","bottomBoundingSphere","computeExtrudedEllipse","radius","outerPositions","union","topBottomAttributes","posLength","topBottomIndices","topBottomGeo","primitiveType","TRIANGLES","wallAttributes","wallIndices","wallGeo","geo","combineInstances","geometry","computeRectangle","granularity","result","positionsFlat","positionsCount","rectangle","fromCartesianArray","width","PI","north","PI_OVER_TWO","EPSILON7","south","east","west","EllipseGeometry","EMPTY_OBJECT","WGS84","RADIANS_PER_DEGREE","DEFAULT","typeOf","number","_center","_semiMajorAxis","_semiMinorAxis","_ellipsoid","_rotation","_stRotation","_height","_granularity","_vertexFormat","_extrudedHeight","_shadowVolume","_workerName","_offsetAttribute","_rectangle","_textureCoordinateRotationPoints","packedLength","pack","value","array","startingIndex","scratchCenter","scratchEllipsoid","scratchVertexFormat","scratchOptions","unpack","createGeometry","ellipseGeometry","equalsEpsilon","EPSILON2","createShadowVolume","minHeightFunc","maxHeightFunc","minHeight","maxHeight","POSITION_ONLY","textureCoordinateRotationPoints","boundingRectangle","Object","defineProperties","prototype","get"],"mappings":"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","sourcesContent":["import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport EllipseGeometryLibrary from \"./EllipseGeometryLibrary.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nvar scratchCartesian1 = new Cartesian3();\nvar scratchCartesian2 = new Cartesian3();\nvar scratchCartesian3 = new Cartesian3();\nvar scratchCartesian4 = new Cartesian3();\nvar texCoordScratch = new Cartesian2();\nvar textureMatrixScratch = new Matrix3();\nvar tangentMatrixScratch = new Matrix3();\nvar quaternionScratch = new Quaternion();\n\nvar scratchNormal = new Cartesian3();\nvar scratchTangent = new Cartesian3();\nvar scratchBitangent = new Cartesian3();\n\nvar scratchCartographic = new Cartographic();\nvar projectedCenterScratch = new Cartesian3();\n\nvar scratchMinTexCoord = new Cartesian2();\nvar scratchMaxTexCoord = new Cartesian2();\n\nfunction computeTopBottomAttributes(positions, options, extrude) {\n  var vertexFormat = options.vertexFormat;\n  var center = options.center;\n  var semiMajorAxis = options.semiMajorAxis;\n  var semiMinorAxis = options.semiMinorAxis;\n  var ellipsoid = options.ellipsoid;\n  var stRotation = options.stRotation;\n  var size = extrude ? (positions.length / 3) * 2 : positions.length / 3;\n  var shadowVolume = options.shadowVolume;\n\n  var textureCoordinates = vertexFormat.st\n    ? new Float32Array(size * 2)\n    : undefined;\n  var normals = vertexFormat.normal ? new Float32Array(size * 3) : undefined;\n  var tangents = vertexFormat.tangent ? new Float32Array(size * 3) : undefined;\n  var bitangents = vertexFormat.bitangent\n    ? new Float32Array(size * 3)\n    : undefined;\n\n  var extrudeNormals = shadowVolume ? new Float32Array(size * 3) : undefined;\n\n  var textureCoordIndex = 0;\n\n  // Raise positions to a height above the ellipsoid and compute the\n  // texture coordinates, normals, tangents, and bitangents.\n  var normal = scratchNormal;\n  var tangent = scratchTangent;\n  var bitangent = scratchBitangent;\n\n  var projection = new GeographicProjection(ellipsoid);\n  var projectedCenter = projection.project(\n    ellipsoid.cartesianToCartographic(center, scratchCartographic),\n    projectedCenterScratch\n  );\n\n  var geodeticNormal = ellipsoid.scaleToGeodeticSurface(\n    center,\n    scratchCartesian1\n  );\n  ellipsoid.geodeticSurfaceNormal(geodeticNormal, geodeticNormal);\n\n  var textureMatrix = textureMatrixScratch;\n  var tangentMatrix = tangentMatrixScratch;\n  if (stRotation !== 0) {\n    var rotation = Quaternion.fromAxisAngle(\n      geodeticNormal,\n      stRotation,\n      quaternionScratch\n    );\n    textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n\n    rotation = Quaternion.fromAxisAngle(\n      geodeticNormal,\n      -stRotation,\n      quaternionScratch\n    );\n    tangentMatrix = Matrix3.fromQuaternion(rotation, tangentMatrix);\n  } else {\n    textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n    tangentMatrix = Matrix3.clone(Matrix3.IDENTITY, tangentMatrix);\n  }\n\n  var minTexCoord = Cartesian2.fromElements(\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n    scratchMinTexCoord\n  );\n  var maxTexCoord = Cartesian2.fromElements(\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n    scratchMaxTexCoord\n  );\n\n  var length = positions.length;\n  var bottomOffset = extrude ? length : 0;\n  var stOffset = (bottomOffset / 3) * 2;\n  for (var i = 0; i < length; i += 3) {\n    var i1 = i + 1;\n    var i2 = i + 2;\n    var position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n\n    if (vertexFormat.st) {\n      var rotatedPoint = Matrix3.multiplyByVector(\n        textureMatrix,\n        position,\n        scratchCartesian2\n      );\n      var projectedPoint = projection.project(\n        ellipsoid.cartesianToCartographic(rotatedPoint, scratchCartographic),\n        scratchCartesian3\n      );\n      Cartesian3.subtract(projectedPoint, projectedCenter, projectedPoint);\n\n      texCoordScratch.x =\n        (projectedPoint.x + semiMajorAxis) / (2.0 * semiMajorAxis);\n      texCoordScratch.y =\n        (projectedPoint.y + semiMinorAxis) / (2.0 * semiMinorAxis);\n\n      minTexCoord.x = Math.min(texCoordScratch.x, minTexCoord.x);\n      minTexCoord.y = Math.min(texCoordScratch.y, minTexCoord.y);\n      maxTexCoord.x = Math.max(texCoordScratch.x, maxTexCoord.x);\n      maxTexCoord.y = Math.max(texCoordScratch.y, maxTexCoord.y);\n\n      if (extrude) {\n        textureCoordinates[textureCoordIndex + stOffset] = texCoordScratch.x;\n        textureCoordinates[textureCoordIndex + 1 + stOffset] =\n          texCoordScratch.y;\n      }\n\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.x;\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.y;\n    }\n\n    if (\n      vertexFormat.normal ||\n      vertexFormat.tangent ||\n      vertexFormat.bitangent ||\n      shadowVolume\n    ) {\n      normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n\n      if (shadowVolume) {\n        extrudeNormals[i + bottomOffset] = -normal.x;\n        extrudeNormals[i1 + bottomOffset] = -normal.y;\n        extrudeNormals[i2 + bottomOffset] = -normal.z;\n      }\n\n      if (\n        vertexFormat.normal ||\n        vertexFormat.tangent ||\n        vertexFormat.bitangent\n      ) {\n        if (vertexFormat.tangent || vertexFormat.bitangent) {\n          tangent = Cartesian3.normalize(\n            Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent),\n            tangent\n          );\n          Matrix3.multiplyByVector(tangentMatrix, tangent, tangent);\n        }\n        if (vertexFormat.normal) {\n          normals[i] = normal.x;\n          normals[i1] = normal.y;\n          normals[i2] = normal.z;\n          if (extrude) {\n            normals[i + bottomOffset] = -normal.x;\n            normals[i1 + bottomOffset] = -normal.y;\n            normals[i2 + bottomOffset] = -normal.z;\n          }\n        }\n\n        if (vertexFormat.tangent) {\n          tangents[i] = tangent.x;\n          tangents[i1] = tangent.y;\n          tangents[i2] = tangent.z;\n          if (extrude) {\n            tangents[i + bottomOffset] = -tangent.x;\n            tangents[i1 + bottomOffset] = -tangent.y;\n            tangents[i2 + bottomOffset] = -tangent.z;\n          }\n        }\n\n        if (vertexFormat.bitangent) {\n          bitangent = Cartesian3.normalize(\n            Cartesian3.cross(normal, tangent, bitangent),\n            bitangent\n          );\n          bitangents[i] = bitangent.x;\n          bitangents[i1] = bitangent.y;\n          bitangents[i2] = bitangent.z;\n          if (extrude) {\n            bitangents[i + bottomOffset] = bitangent.x;\n            bitangents[i1 + bottomOffset] = bitangent.y;\n            bitangents[i2 + bottomOffset] = bitangent.z;\n          }\n        }\n      }\n    }\n  }\n\n  if (vertexFormat.st) {\n    length = textureCoordinates.length;\n    for (var k = 0; k < length; k += 2) {\n      textureCoordinates[k] =\n        (textureCoordinates[k] - minTexCoord.x) /\n        (maxTexCoord.x - minTexCoord.x);\n      textureCoordinates[k + 1] =\n        (textureCoordinates[k + 1] - minTexCoord.y) /\n        (maxTexCoord.y - minTexCoord.y);\n    }\n  }\n\n  var attributes = new GeometryAttributes();\n\n  if (vertexFormat.position) {\n    var finalPositions = EllipseGeometryLibrary.raisePositionsToHeight(\n      positions,\n      options,\n      extrude\n    );\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: finalPositions,\n    });\n  }\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: textureCoordinates,\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents,\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents,\n    });\n  }\n\n  if (shadowVolume) {\n    attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals,\n    });\n  }\n\n  if (extrude && defined(options.offsetAttribute)) {\n    var offsetAttribute = new Uint8Array(size);\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n    } else {\n      var offsetValue =\n        options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n    }\n\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute,\n    });\n  }\n\n  return attributes;\n}\n\nfunction topIndices(numPts) {\n  // numTriangles in half = 3 + 8 + 12 + ... = -1 + 4 + (4 + 4) + (4 + 4 + 4) + ... = -1 + 4 * (1 + 2 + 3 + ...)\n  //              = -1 + 4 * ((n * ( n + 1)) / 2)\n  // total triangles = 2 * numTrangles in half\n  // indices = total triangles * 3;\n  // Substitute numPts for n above\n\n  var indices = new Array(12 * (numPts * (numPts + 1)) - 6);\n  var indicesIndex = 0;\n  var prevIndex;\n  var numInterior;\n  var positionIndex;\n  var i;\n  var j;\n  // Indices triangles to the 'right' of the north vector\n\n  prevIndex = 0;\n  positionIndex = 1;\n  for (i = 0; i < 3; i++) {\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n\n  for (i = 2; i < numPts + 1; ++i) {\n    positionIndex = i * (i + 1) - 1;\n    prevIndex = (i - 1) * i - 1;\n\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n\n    numInterior = 2 * i;\n    for (j = 0; j < numInterior - 1; ++j) {\n      indices[indicesIndex++] = positionIndex;\n      indices[indicesIndex++] = prevIndex++;\n      indices[indicesIndex++] = prevIndex;\n\n      indices[indicesIndex++] = positionIndex++;\n      indices[indicesIndex++] = prevIndex;\n      indices[indicesIndex++] = positionIndex;\n    }\n\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n\n  // Indices for center column of triangles\n  numInterior = numPts * 2;\n  ++positionIndex;\n  ++prevIndex;\n  for (i = 0; i < numInterior - 1; ++i) {\n    indices[indicesIndex++] = positionIndex;\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex;\n\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n\n  indices[indicesIndex++] = positionIndex;\n  indices[indicesIndex++] = prevIndex++;\n  indices[indicesIndex++] = prevIndex;\n\n  indices[indicesIndex++] = positionIndex++;\n  indices[indicesIndex++] = prevIndex++;\n  indices[indicesIndex++] = prevIndex;\n\n  // Reverse the process creating indices to the 'left' of the north vector\n  ++prevIndex;\n  for (i = numPts - 1; i > 1; --i) {\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n\n    numInterior = 2 * i;\n    for (j = 0; j < numInterior - 1; ++j) {\n      indices[indicesIndex++] = positionIndex;\n      indices[indicesIndex++] = prevIndex++;\n      indices[indicesIndex++] = prevIndex;\n\n      indices[indicesIndex++] = positionIndex++;\n      indices[indicesIndex++] = prevIndex;\n      indices[indicesIndex++] = positionIndex;\n    }\n\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = positionIndex++;\n  }\n\n  for (i = 0; i < 3; i++) {\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n  return indices;\n}\n\nvar boundingSphereCenter = new Cartesian3();\n\nfunction computeEllipse(options) {\n  var center = options.center;\n  boundingSphereCenter = Cartesian3.multiplyByScalar(\n    options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter),\n    options.height,\n    boundingSphereCenter\n  );\n  boundingSphereCenter = Cartesian3.add(\n    center,\n    boundingSphereCenter,\n    boundingSphereCenter\n  );\n  var boundingSphere = new BoundingSphere(\n    boundingSphereCenter,\n    options.semiMajorAxis\n  );\n  var cep = EllipseGeometryLibrary.computeEllipsePositions(\n    options,\n    true,\n    false\n  );\n  var positions = cep.positions;\n  var numPts = cep.numPts;\n  var attributes = computeTopBottomAttributes(positions, options, false);\n  var indices = topIndices(numPts);\n  indices = IndexDatatype.createTypedArray(positions.length / 3, indices);\n  return {\n    boundingSphere: boundingSphere,\n    attributes: attributes,\n    indices: indices,\n  };\n}\n\nfunction computeWallAttributes(positions, options) {\n  var vertexFormat = options.vertexFormat;\n  var center = options.center;\n  var semiMajorAxis = options.semiMajorAxis;\n  var semiMinorAxis = options.semiMinorAxis;\n  var ellipsoid = options.ellipsoid;\n  var height = options.height;\n  var extrudedHeight = options.extrudedHeight;\n  var stRotation = options.stRotation;\n  var size = (positions.length / 3) * 2;\n\n  var finalPositions = new Float64Array(size * 3);\n  var textureCoordinates = vertexFormat.st\n    ? new Float32Array(size * 2)\n    : undefined;\n  var normals = vertexFormat.normal ? new Float32Array(size * 3) : undefined;\n  var tangents = vertexFormat.tangent ? new Float32Array(size * 3) : undefined;\n  var bitangents = vertexFormat.bitangent\n    ? new Float32Array(size * 3)\n    : undefined;\n\n  var shadowVolume = options.shadowVolume;\n  var extrudeNormals = shadowVolume ? new Float32Array(size * 3) : undefined;\n\n  var textureCoordIndex = 0;\n\n  // Raise positions to a height above the ellipsoid and compute the\n  // texture coordinates, normals, tangents, and bitangents.\n  var normal = scratchNormal;\n  var tangent = scratchTangent;\n  var bitangent = scratchBitangent;\n\n  var projection = new GeographicProjection(ellipsoid);\n  var projectedCenter = projection.project(\n    ellipsoid.cartesianToCartographic(center, scratchCartographic),\n    projectedCenterScratch\n  );\n\n  var geodeticNormal = ellipsoid.scaleToGeodeticSurface(\n    center,\n    scratchCartesian1\n  );\n  ellipsoid.geodeticSurfaceNormal(geodeticNormal, geodeticNormal);\n  var rotation = Quaternion.fromAxisAngle(\n    geodeticNormal,\n    stRotation,\n    quaternionScratch\n  );\n  var textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrixScratch);\n\n  var minTexCoord = Cartesian2.fromElements(\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n    scratchMinTexCoord\n  );\n  var maxTexCoord = Cartesian2.fromElements(\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n    scratchMaxTexCoord\n  );\n\n  var length = positions.length;\n  var stOffset = (length / 3) * 2;\n  for (var i = 0; i < length; i += 3) {\n    var i1 = i + 1;\n    var i2 = i + 2;\n    var position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n    var extrudedPosition;\n\n    if (vertexFormat.st) {\n      var rotatedPoint = Matrix3.multiplyByVector(\n        textureMatrix,\n        position,\n        scratchCartesian2\n      );\n      var projectedPoint = projection.project(\n        ellipsoid.cartesianToCartographic(rotatedPoint, scratchCartographic),\n        scratchCartesian3\n      );\n      Cartesian3.subtract(projectedPoint, projectedCenter, projectedPoint);\n\n      texCoordScratch.x =\n        (projectedPoint.x + semiMajorAxis) / (2.0 * semiMajorAxis);\n      texCoordScratch.y =\n        (projectedPoint.y + semiMinorAxis) / (2.0 * semiMinorAxis);\n\n      minTexCoord.x = Math.min(texCoordScratch.x, minTexCoord.x);\n      minTexCoord.y = Math.min(texCoordScratch.y, minTexCoord.y);\n      maxTexCoord.x = Math.max(texCoordScratch.x, maxTexCoord.x);\n      maxTexCoord.y = Math.max(texCoordScratch.y, maxTexCoord.y);\n\n      textureCoordinates[textureCoordIndex + stOffset] = texCoordScratch.x;\n      textureCoordinates[textureCoordIndex + 1 + stOffset] = texCoordScratch.y;\n\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.x;\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.y;\n    }\n\n    position = ellipsoid.scaleToGeodeticSurface(position, position);\n    extrudedPosition = Cartesian3.clone(position, scratchCartesian2);\n    normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n\n    if (shadowVolume) {\n      extrudeNormals[i + length] = -normal.x;\n      extrudeNormals[i1 + length] = -normal.y;\n      extrudeNormals[i2 + length] = -normal.z;\n    }\n\n    var scaledNormal = Cartesian3.multiplyByScalar(\n      normal,\n      height,\n      scratchCartesian4\n    );\n    position = Cartesian3.add(position, scaledNormal, position);\n    scaledNormal = Cartesian3.multiplyByScalar(\n      normal,\n      extrudedHeight,\n      scaledNormal\n    );\n    extrudedPosition = Cartesian3.add(\n      extrudedPosition,\n      scaledNormal,\n      extrudedPosition\n    );\n\n    if (vertexFormat.position) {\n      finalPositions[i + length] = extrudedPosition.x;\n      finalPositions[i1 + length] = extrudedPosition.y;\n      finalPositions[i2 + length] = extrudedPosition.z;\n\n      finalPositions[i] = position.x;\n      finalPositions[i1] = position.y;\n      finalPositions[i2] = position.z;\n    }\n\n    if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n      bitangent = Cartesian3.clone(normal, bitangent);\n      var next = Cartesian3.fromArray(\n        positions,\n        (i + 3) % length,\n        scratchCartesian4\n      );\n      Cartesian3.subtract(next, position, next);\n      var bottom = Cartesian3.subtract(\n        extrudedPosition,\n        position,\n        scratchCartesian3\n      );\n\n      normal = Cartesian3.normalize(\n        Cartesian3.cross(bottom, next, normal),\n        normal\n      );\n\n      if (vertexFormat.normal) {\n        normals[i] = normal.x;\n        normals[i1] = normal.y;\n        normals[i2] = normal.z;\n\n        normals[i + length] = normal.x;\n        normals[i1 + length] = normal.y;\n        normals[i2 + length] = normal.z;\n      }\n\n      if (vertexFormat.tangent) {\n        tangent = Cartesian3.normalize(\n          Cartesian3.cross(bitangent, normal, tangent),\n          tangent\n        );\n        tangents[i] = tangent.x;\n        tangents[i1] = tangent.y;\n        tangents[i2] = tangent.z;\n\n        tangents[i + length] = tangent.x;\n        tangents[i + 1 + length] = tangent.y;\n        tangents[i + 2 + length] = tangent.z;\n      }\n\n      if (vertexFormat.bitangent) {\n        bitangents[i] = bitangent.x;\n        bitangents[i1] = bitangent.y;\n        bitangents[i2] = bitangent.z;\n\n        bitangents[i + length] = bitangent.x;\n        bitangents[i1 + length] = bitangent.y;\n        bitangents[i2 + length] = bitangent.z;\n      }\n    }\n  }\n\n  if (vertexFormat.st) {\n    length = textureCoordinates.length;\n    for (var k = 0; k < length; k += 2) {\n      textureCoordinates[k] =\n        (textureCoordinates[k] - minTexCoord.x) /\n        (maxTexCoord.x - minTexCoord.x);\n      textureCoordinates[k + 1] =\n        (textureCoordinates[k + 1] - minTexCoord.y) /\n        (maxTexCoord.y - minTexCoord.y);\n    }\n  }\n\n  var attributes = new GeometryAttributes();\n\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: finalPositions,\n    });\n  }\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: textureCoordinates,\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents,\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents,\n    });\n  }\n\n  if (shadowVolume) {\n    attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals,\n    });\n  }\n\n  if (defined(options.offsetAttribute)) {\n    var offsetAttribute = new Uint8Array(size);\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n    } else {\n      var offsetValue =\n        options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n    }\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute,\n    });\n  }\n\n  return attributes;\n}\n\nfunction computeWallIndices(positions) {\n  var length = positions.length / 3;\n  var indices = IndexDatatype.createTypedArray(length, length * 6);\n  var index = 0;\n  for (var i = 0; i < length; i++) {\n    var UL = i;\n    var LL = i + length;\n    var UR = (UL + 1) % length;\n    var LR = UR + length;\n    indices[index++] = UL;\n    indices[index++] = LL;\n    indices[index++] = UR;\n    indices[index++] = UR;\n    indices[index++] = LL;\n    indices[index++] = LR;\n  }\n\n  return indices;\n}\n\nvar topBoundingSphere = new BoundingSphere();\nvar bottomBoundingSphere = new BoundingSphere();\n\nfunction computeExtrudedEllipse(options) {\n  var center = options.center;\n  var ellipsoid = options.ellipsoid;\n  var semiMajorAxis = options.semiMajorAxis;\n  var scaledNormal = Cartesian3.multiplyByScalar(\n    ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1),\n    options.height,\n    scratchCartesian1\n  );\n  topBoundingSphere.center = Cartesian3.add(\n    center,\n    scaledNormal,\n    topBoundingSphere.center\n  );\n  topBoundingSphere.radius = semiMajorAxis;\n\n  scaledNormal = Cartesian3.multiplyByScalar(\n    ellipsoid.geodeticSurfaceNormal(center, scaledNormal),\n    options.extrudedHeight,\n    scaledNormal\n  );\n  bottomBoundingSphere.center = Cartesian3.add(\n    center,\n    scaledNormal,\n    bottomBoundingSphere.center\n  );\n  bottomBoundingSphere.radius = semiMajorAxis;\n\n  var cep = EllipseGeometryLibrary.computeEllipsePositions(options, true, true);\n  var positions = cep.positions;\n  var numPts = cep.numPts;\n  var outerPositions = cep.outerPositions;\n  var boundingSphere = BoundingSphere.union(\n    topBoundingSphere,\n    bottomBoundingSphere\n  );\n  var topBottomAttributes = computeTopBottomAttributes(\n    positions,\n    options,\n    true\n  );\n  var indices = topIndices(numPts);\n  var length = indices.length;\n  indices.length = length * 2;\n  var posLength = positions.length / 3;\n  for (var i = 0; i < length; i += 3) {\n    indices[i + length] = indices[i + 2] + posLength;\n    indices[i + 1 + length] = indices[i + 1] + posLength;\n    indices[i + 2 + length] = indices[i] + posLength;\n  }\n\n  var topBottomIndices = IndexDatatype.createTypedArray(\n    (posLength * 2) / 3,\n    indices\n  );\n\n  var topBottomGeo = new Geometry({\n    attributes: topBottomAttributes,\n    indices: topBottomIndices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  });\n\n  var wallAttributes = computeWallAttributes(outerPositions, options);\n  indices = computeWallIndices(outerPositions);\n  var wallIndices = IndexDatatype.createTypedArray(\n    (outerPositions.length * 2) / 3,\n    indices\n  );\n\n  var wallGeo = new Geometry({\n    attributes: wallAttributes,\n    indices: wallIndices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  });\n\n  var geo = GeometryPipeline.combineInstances([\n    new GeometryInstance({\n      geometry: topBottomGeo,\n    }),\n    new GeometryInstance({\n      geometry: wallGeo,\n    }),\n  ]);\n\n  return {\n    boundingSphere: boundingSphere,\n    attributes: geo[0].attributes,\n    indices: geo[0].indices,\n  };\n}\n\nfunction computeRectangle(\n  center,\n  semiMajorAxis,\n  semiMinorAxis,\n  rotation,\n  granularity,\n  ellipsoid,\n  result\n) {\n  var cep = EllipseGeometryLibrary.computeEllipsePositions(\n    {\n      center: center,\n      semiMajorAxis: semiMajorAxis,\n      semiMinorAxis: semiMinorAxis,\n      rotation: rotation,\n      granularity: granularity,\n    },\n    false,\n    true\n  );\n  var positionsFlat = cep.outerPositions;\n  var positionsCount = positionsFlat.length / 3;\n  var positions = new Array(positionsCount);\n  for (var i = 0; i < positionsCount; ++i) {\n    positions[i] = Cartesian3.fromArray(positionsFlat, i * 3);\n  }\n  var rectangle = Rectangle.fromCartesianArray(positions, ellipsoid, result);\n  // Rectangle width goes beyond 180 degrees when the ellipse crosses a pole.\n  // When this happens, make the rectangle into a \"circle\" around the pole\n  if (rectangle.width > CesiumMath.PI) {\n    rectangle.north =\n      rectangle.north > 0.0\n        ? CesiumMath.PI_OVER_TWO - CesiumMath.EPSILON7\n        : rectangle.north;\n    rectangle.south =\n      rectangle.south < 0.0\n        ? CesiumMath.EPSILON7 - CesiumMath.PI_OVER_TWO\n        : rectangle.south;\n    rectangle.east = CesiumMath.PI;\n    rectangle.west = -CesiumMath.PI;\n  }\n  return rectangle;\n}\n\n/**\n * A description of an ellipse on an ellipsoid. Ellipse geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias EllipseGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.\n * @param {Number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.\n * @param {Number} [options.extrudedHeight] The distance in meters between the ellipse's extruded face and the ellipsoid surface.\n * @param {Number} [options.rotation=0.0] The angle of rotation counter-clockwise from north.\n * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates counter-clockwise from north.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The angular distance between points on the ellipse in radians.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.\n * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.\n * @exception {DeveloperError} granularity must be greater than zero.\n *\n *\n * @example\n * // Create an ellipse.\n * var ellipse = new Cesium.EllipseGeometry({\n *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n *   semiMajorAxis : 500000.0,\n *   semiMinorAxis : 300000.0,\n *   rotation : Cesium.Math.toRadians(60.0)\n * });\n * var geometry = Cesium.EllipseGeometry.createGeometry(ellipse);\n *\n * @see EllipseGeometry.createGeometry\n */\nfunction EllipseGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var center = options.center;\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var semiMajorAxis = options.semiMajorAxis;\n  var semiMinorAxis = options.semiMinorAxis;\n  var granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.center\", center);\n  Check.typeOf.number(\"options.semiMajorAxis\", semiMajorAxis);\n  Check.typeOf.number(\"options.semiMinorAxis\", semiMinorAxis);\n  if (semiMajorAxis < semiMinorAxis) {\n    throw new DeveloperError(\n      \"semiMajorAxis must be greater than or equal to the semiMinorAxis.\"\n    );\n  }\n  if (granularity <= 0.0) {\n    throw new DeveloperError(\"granularity must be greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  var height = defaultValue(options.height, 0.0);\n  var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  this._center = Cartesian3.clone(center);\n  this._semiMajorAxis = semiMajorAxis;\n  this._semiMinorAxis = semiMinorAxis;\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._rotation = defaultValue(options.rotation, 0.0);\n  this._stRotation = defaultValue(options.stRotation, 0.0);\n  this._height = Math.max(extrudedHeight, height);\n  this._granularity = granularity;\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._extrudedHeight = Math.min(extrudedHeight, height);\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\n  this._workerName = \"createEllipseGeometry\";\n  this._offsetAttribute = options.offsetAttribute;\n\n  this._rectangle = undefined;\n  this._textureCoordinateRotationPoints = undefined;\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nEllipseGeometry.packedLength =\n  Cartesian3.packedLength +\n  Ellipsoid.packedLength +\n  VertexFormat.packedLength +\n  9;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipseGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nEllipseGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value._center, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._semiMajorAxis;\n  array[startingIndex++] = value._semiMinorAxis;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._stRotation;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nvar scratchCenter = new Cartesian3();\nvar scratchEllipsoid = new Ellipsoid();\nvar scratchVertexFormat = new VertexFormat();\nvar scratchOptions = {\n  center: scratchCenter,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  semiMajorAxis: undefined,\n  semiMinorAxis: undefined,\n  rotation: undefined,\n  stRotation: undefined,\n  height: undefined,\n  granularity: undefined,\n  extrudedHeight: undefined,\n  shadowVolume: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipseGeometry} [result] The object into which to store the result.\n * @returns {EllipseGeometry} The modified result parameter or a new EllipseGeometry instance if one was not provided.\n */\nEllipseGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var center = Cartesian3.unpack(array, startingIndex, scratchCenter);\n  startingIndex += Cartesian3.packedLength;\n\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  var vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  var semiMajorAxis = array[startingIndex++];\n  var semiMinorAxis = array[startingIndex++];\n  var rotation = array[startingIndex++];\n  var stRotation = array[startingIndex++];\n  var height = array[startingIndex++];\n  var granularity = array[startingIndex++];\n  var extrudedHeight = array[startingIndex++];\n  var shadowVolume = array[startingIndex++] === 1.0;\n  var offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.granularity = granularity;\n    scratchOptions.stRotation = stRotation;\n    scratchOptions.rotation = rotation;\n    scratchOptions.semiMajorAxis = semiMajorAxis;\n    scratchOptions.semiMinorAxis = semiMinorAxis;\n    scratchOptions.shadowVolume = shadowVolume;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n\n    return new EllipseGeometry(scratchOptions);\n  }\n\n  result._center = Cartesian3.clone(center, result._center);\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._semiMajorAxis = semiMajorAxis;\n  result._semiMinorAxis = semiMinorAxis;\n  result._rotation = rotation;\n  result._stRotation = stRotation;\n  result._height = height;\n  result._granularity = granularity;\n  result._extrudedHeight = extrudedHeight;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the bounding rectangle based on the provided options\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.\n * @param {Number} [options.rotation=0.0] The angle of rotation counter-clockwise from north.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The angular distance between points on the ellipse in radians.\n * @param {Rectangle} [result] An object in which to store the result\n *\n * @returns {Rectangle} The result rectangle\n */\nEllipseGeometry.computeRectangle = function (options, result) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var center = options.center;\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var semiMajorAxis = options.semiMajorAxis;\n  var semiMinorAxis = options.semiMinorAxis;\n  var granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  var rotation = defaultValue(options.rotation, 0.0);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.center\", center);\n  Check.typeOf.number(\"options.semiMajorAxis\", semiMajorAxis);\n  Check.typeOf.number(\"options.semiMinorAxis\", semiMinorAxis);\n  if (semiMajorAxis < semiMinorAxis) {\n    throw new DeveloperError(\n      \"semiMajorAxis must be greater than or equal to the semiMinorAxis.\"\n    );\n  }\n  if (granularity <= 0.0) {\n    throw new DeveloperError(\"granularity must be greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  return computeRectangle(\n    center,\n    semiMajorAxis,\n    semiMinorAxis,\n    rotation,\n    granularity,\n    ellipsoid,\n    result\n  );\n};\n\n/**\n * Computes the geometric representation of a ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipseGeometry} ellipseGeometry A description of the ellipse.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nEllipseGeometry.createGeometry = function (ellipseGeometry) {\n  if (\n    ellipseGeometry._semiMajorAxis <= 0.0 ||\n    ellipseGeometry._semiMinorAxis <= 0.0\n  ) {\n    return;\n  }\n\n  var height = ellipseGeometry._height;\n  var extrudedHeight = ellipseGeometry._extrudedHeight;\n  var extrude = !CesiumMath.equalsEpsilon(\n    height,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2\n  );\n\n  ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(\n    ellipseGeometry._center,\n    ellipseGeometry._center\n  );\n  var options = {\n    center: ellipseGeometry._center,\n    semiMajorAxis: ellipseGeometry._semiMajorAxis,\n    semiMinorAxis: ellipseGeometry._semiMinorAxis,\n    ellipsoid: ellipseGeometry._ellipsoid,\n    rotation: ellipseGeometry._rotation,\n    height: height,\n    granularity: ellipseGeometry._granularity,\n    vertexFormat: ellipseGeometry._vertexFormat,\n    stRotation: ellipseGeometry._stRotation,\n  };\n  var geometry;\n  if (extrude) {\n    options.extrudedHeight = extrudedHeight;\n    options.shadowVolume = ellipseGeometry._shadowVolume;\n    options.offsetAttribute = ellipseGeometry._offsetAttribute;\n    geometry = computeExtrudedEllipse(options);\n  } else {\n    geometry = computeEllipse(options);\n\n    if (defined(ellipseGeometry._offsetAttribute)) {\n      var length = geometry.attributes.position.values.length;\n      var applyOffset = new Uint8Array(length / 3);\n      var offsetValue =\n        ellipseGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      arrayFill(applyOffset, offsetValue);\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n  }\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: geometry.boundingSphere,\n    offsetAttribute: ellipseGeometry._offsetAttribute,\n  });\n};\n\n/**\n * @private\n */\nEllipseGeometry.createShadowVolume = function (\n  ellipseGeometry,\n  minHeightFunc,\n  maxHeightFunc\n) {\n  var granularity = ellipseGeometry._granularity;\n  var ellipsoid = ellipseGeometry._ellipsoid;\n\n  var minHeight = minHeightFunc(granularity, ellipsoid);\n  var maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n  return new EllipseGeometry({\n    center: ellipseGeometry._center,\n    semiMajorAxis: ellipseGeometry._semiMajorAxis,\n    semiMinorAxis: ellipseGeometry._semiMinorAxis,\n    ellipsoid: ellipsoid,\n    rotation: ellipseGeometry._rotation,\n    stRotation: ellipseGeometry._stRotation,\n    granularity: granularity,\n    extrudedHeight: minHeight,\n    height: maxHeight,\n    vertexFormat: VertexFormat.POSITION_ONLY,\n    shadowVolume: true,\n  });\n};\n\nfunction textureCoordinateRotationPoints(ellipseGeometry) {\n  var stRotation = -ellipseGeometry._stRotation;\n  if (stRotation === 0.0) {\n    return [0, 0, 0, 1, 1, 0];\n  }\n\n  var cep = EllipseGeometryLibrary.computeEllipsePositions(\n    {\n      center: ellipseGeometry._center,\n      semiMajorAxis: ellipseGeometry._semiMajorAxis,\n      semiMinorAxis: ellipseGeometry._semiMinorAxis,\n      rotation: ellipseGeometry._rotation,\n      granularity: ellipseGeometry._granularity,\n    },\n    false,\n    true\n  );\n  var positionsFlat = cep.outerPositions;\n  var positionsCount = positionsFlat.length / 3;\n  var positions = new Array(positionsCount);\n  for (var i = 0; i < positionsCount; ++i) {\n    positions[i] = Cartesian3.fromArray(positionsFlat, i * 3);\n  }\n\n  var ellipsoid = ellipseGeometry._ellipsoid;\n  var boundingRectangle = ellipseGeometry.rectangle;\n  return Geometry._textureCoordinateRotationPoints(\n    positions,\n    stRotation,\n    ellipsoid,\n    boundingRectangle\n  );\n}\n\nObject.defineProperties(EllipseGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function () {\n      if (!defined(this._rectangle)) {\n        this._rectangle = computeRectangle(\n          this._center,\n          this._semiMajorAxis,\n          this._semiMinorAxis,\n          this._rotation,\n          this._granularity,\n          this._ellipsoid\n        );\n      }\n      return this._rectangle;\n    },\n  },\n  /**\n   * For remapping texture coordinates when rendering EllipseGeometries as GroundPrimitives.\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function () {\n      if (!defined(this._textureCoordinateRotationPoints)) {\n        this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(\n          this\n        );\n      }\n      return this._textureCoordinateRotationPoints;\n    },\n  },\n});\nexport default EllipseGeometry;\n"]},"metadata":{},"sourceType":"module"}