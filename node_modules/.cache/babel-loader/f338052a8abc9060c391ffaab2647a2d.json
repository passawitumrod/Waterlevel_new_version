{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport Credit from \"../Core/Credit.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport getAbsoluteUri from \"../Core/getAbsoluteUri.js\";\nimport getMagic from \"../Core/getMagic.js\";\nimport getStringFromTypedArray from \"../Core/getStringFromTypedArray.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport loadCRN from \"../Core/loadCRN.js\";\nimport loadImageFromTypedArray from \"../Core/loadImageFromTypedArray.js\";\nimport loadKTX from \"../Core/loadKTX.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Resource from \"../Core/Resource.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport addDefaults from \"../ThirdParty/GltfPipeline/addDefaults.js\";\nimport addPipelineExtras from \"../ThirdParty/GltfPipeline/addPipelineExtras.js\";\nimport ForEach from \"../ThirdParty/GltfPipeline/ForEach.js\";\nimport getAccessorByteStride from \"../ThirdParty/GltfPipeline/getAccessorByteStride.js\";\nimport hasExtension from \"../ThirdParty/GltfPipeline/hasExtension.js\";\nimport numberOfComponentsForType from \"../ThirdParty/GltfPipeline/numberOfComponentsForType.js\";\nimport parseGlb from \"../ThirdParty/GltfPipeline/parseGlb.js\";\nimport updateVersion from \"../ThirdParty/GltfPipeline/updateVersion.js\";\nimport when from \"../ThirdParty/when.js\";\nimport Axis from \"./Axis.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nimport ColorBlendMode from \"./ColorBlendMode.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport DracoLoader from \"./DracoLoader.js\";\nimport getClipAndStyleCode from \"./getClipAndStyleCode.js\";\nimport getClippingFunction from \"./getClippingFunction.js\";\nimport HeightReference from \"./HeightReference.js\";\nimport JobType from \"./JobType.js\";\nimport ModelAnimationCache from \"./ModelAnimationCache.js\";\nimport ModelAnimationCollection from \"./ModelAnimationCollection.js\";\nimport ModelLoadResources from \"./ModelLoadResources.js\";\nimport ModelMaterial from \"./ModelMaterial.js\";\nimport ModelMesh from \"./ModelMesh.js\";\nimport ModelNode from \"./ModelNode.js\";\nimport ModelOutlineLoader from \"./ModelOutlineLoader.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport OctahedralProjectedCubeMap from \"./OctahedralProjectedCubeMap.js\";\nimport processModelMaterialsCommon from \"./processModelMaterialsCommon.js\";\nimport processPbrMaterials from \"./processPbrMaterials.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\nvar boundingSphereCartesian3Scratch = new Cartesian3();\nvar ModelState = ModelUtility.ModelState; // glTF MIME types discussed in https://github.com/KhronosGroup/glTF/issues/412 and https://github.com/KhronosGroup/glTF/issues/943\n\nvar defaultModelAccept = \"model/gltf-binary,model/gltf+json;q=0.8,application/json;q=0.2,*/*;q=0.01\";\nvar articulationEpsilon = CesiumMath.EPSILON16; ///////////////////////////////////////////////////////////////////////////\n\nfunction setCachedGltf(model, cachedGltf) {\n  model._cachedGltf = cachedGltf;\n} // glTF JSON can be big given embedded geometry, textures, and animations, so we\n// cache it across all models using the same url/cache-key.  This also reduces the\n// slight overhead in assigning defaults to missing values.\n//\n// Note that this is a global cache, compared to renderer resources, which\n// are cached per context.\n\n\nfunction CachedGltf(options) {\n  this._gltf = options.gltf;\n  this.ready = options.ready;\n  this.modelsToLoad = [];\n  this.count = 0;\n}\n\nObject.defineProperties(CachedGltf.prototype, {\n  gltf: {\n    set: function (value) {\n      this._gltf = value;\n    },\n    get: function () {\n      return this._gltf;\n    }\n  }\n});\n\nCachedGltf.prototype.makeReady = function (gltfJson) {\n  this.gltf = gltfJson;\n  var models = this.modelsToLoad;\n  var length = models.length;\n\n  for (var i = 0; i < length; ++i) {\n    var m = models[i];\n\n    if (!m.isDestroyed()) {\n      setCachedGltf(m, this);\n    }\n  }\n\n  this.modelsToLoad = undefined;\n  this.ready = true;\n};\n\nvar gltfCache = {};\nvar uriToGuid = {}; ///////////////////////////////////////////////////////////////////////////\n\n/**\n * A 3D model based on glTF, the runtime asset format for WebGL, OpenGL ES, and OpenGL.\n * <p>\n * Cesium includes support for geometry and materials, glTF animations, and glTF skinning.\n * In addition, individual glTF nodes are pickable with {@link Scene#pick} and animatable\n * with {@link Model#getNode}.  glTF cameras and lights are not currently supported.\n * </p>\n * <p>\n * An external glTF asset is created with {@link Model.fromGltf}.  glTF JSON can also be\n * created at runtime and passed to this constructor function.  In either case, the\n * {@link Model#readyPromise} is resolved when the model is ready to render, i.e.,\n * when the external binary, image, and shader files are downloaded and the WebGL\n * resources are created.\n * </p>\n * <p>\n * Cesium supports glTF assets with the following extensions:\n * <ul>\n * <li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/README.md|KHR_binary_glTF (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_materials_common/README.md|KHR_materials_common (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/WEB3D_quantized_attributes/README.md|WEB3D_quantized_attributes (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/AGI_articulations/README.md|AGI_articulations}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/pull/1302|KHR_blend (draft)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md|KHR_draco_mesh_compression}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/README.md|KHR_materials_pbrSpecularGlossiness}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit/README.md|KHR_materials_unlit}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_techniques_webgl/README.md|KHR_techniques_webgl}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_texture_transform/README.md|KHR_texture_transform}\n * </li>\n * </ul>\n * </p>\n * <p>\n * For high-precision rendering, Cesium supports the {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/CESIUM_RTC/README.md|CESIUM_RTC} extension, which introduces the\n * CESIUM_RTC_MODELVIEW parameter semantic that says the node is in WGS84 coordinates translated\n * relative to a local origin.\n * </p>\n *\n * @alias Model\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Object|ArrayBuffer|Uint8Array} [options.gltf] A glTF JSON object, or a binary glTF buffer.\n * @param {Resource|String} [options.basePath=''] The base path that paths in the glTF JSON are relative to.\n * @param {Boolean} [options.show=true] Determines if the model primitive will be shown.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the model from model to world coordinates.\n * @param {Number} [options.scale=1.0] A uniform scale applied to this model.\n * @param {Number} [options.minimumPixelSize=0.0] The approximate minimum pixel size of the model regardless of zoom.\n * @param {Number} [options.maximumScale] The maximum scale size of a model. An upper limit for minimumPixelSize.\n * @param {Object} [options.id] A user-defined object to return when the model is picked with {@link Scene#pick}.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each glTF mesh and primitive is pickable with {@link Scene#pick}.\n * @param {Boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the model is loaded.\n * @param {Boolean} [options.asynchronous=true] Determines if model WebGL resource creation will be spread out over several frames or block until completion once all glTF files are loaded.\n * @param {Boolean} [options.clampAnimations=true] Determines if the model's animations should hold a pose over frames where no keyframes are specified.\n * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the model casts or receives shadows from light sources.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Draws the bounding sphere for each draw command in the model.\n * @param {Boolean} [options.debugWireframe=false] For debugging only. Draws the model in wireframe.\n * @param {HeightReference} [options.heightReference=HeightReference.NONE] Determines how the model is drawn relative to terrain.\n * @param {Scene} [options.scene] Must be passed in for models that use the height reference property.\n * @param {DistanceDisplayCondition} [options.distanceDisplayCondition] The condition specifying at what distance from the camera that this model will be displayed.\n * @param {Color} [options.color=Color.WHITE] A color that blends with the model's rendered color.\n * @param {ColorBlendMode} [options.colorBlendMode=ColorBlendMode.HIGHLIGHT] Defines how the color blends with the model.\n * @param {Number} [options.colorBlendAmount=0.5] Value used to determine the color strength when the <code>colorBlendMode</code> is <code>MIX</code>. A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with any value in-between resulting in a mix of the two.\n * @param {Color} [options.silhouetteColor=Color.RED] The silhouette color. If more than 256 models have silhouettes enabled, there is a small chance that overlapping models will have minor artifacts.\n * @param {Number} [options.silhouetteSize=0.0] The size of the silhouette in pixels.\n * @param {ClippingPlaneCollection} [options.clippingPlanes] The {@link ClippingPlaneCollection} used to selectively disable rendering the model.\n * @param {Boolean} [options.dequantizeInShader=true] Determines if a {@link https://github.com/google/draco|Draco} encoded model is dequantized on the GPU. This decreases total memory usage for encoded models.\n * @param {Cartesian2} [options.imageBasedLightingFactor=Cartesian2(1.0, 1.0)] Scales diffuse and specular image-based lighting from the earth, sky, atmosphere and star skybox.\n * @param {Cartesian3} [options.lightColor] The light color when shading the model. When <code>undefined</code> the scene's light color is used instead.\n * @param {Number} [options.luminanceAtZenith=0.2] The sun's luminance at the zenith in kilo candela per meter squared to use for this model's procedural environment map.\n * @param {Cartesian3[]} [options.sphericalHarmonicCoefficients] The third order spherical harmonic coefficients used for the diffuse color of image-based lighting.\n * @param {String} [options.specularEnvironmentMaps] A URL to a KTX file that contains a cube map of the specular lighting and the convoluted specular mipmaps.\n * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.\n *\n * @see Model.fromGltf\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=3D%20Models.html|Cesium Sandcastle Models Demo}\n */\n\nfunction Model(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var cacheKey = options.cacheKey;\n  this._cacheKey = cacheKey;\n  this._cachedGltf = undefined;\n  this._releaseGltfJson = defaultValue(options.releaseGltfJson, false);\n  var cachedGltf;\n\n  if (defined(cacheKey) && defined(gltfCache[cacheKey]) && gltfCache[cacheKey].ready) {\n    // glTF JSON is in cache and ready\n    cachedGltf = gltfCache[cacheKey];\n    ++cachedGltf.count;\n  } else {\n    // glTF was explicitly provided, e.g., when a user uses the Model constructor directly\n    var gltf = options.gltf;\n\n    if (defined(gltf)) {\n      if (gltf instanceof ArrayBuffer) {\n        gltf = new Uint8Array(gltf);\n      }\n\n      if (gltf instanceof Uint8Array) {\n        // Binary glTF\n        var parsedGltf = parseGlb(gltf);\n        cachedGltf = new CachedGltf({\n          gltf: parsedGltf,\n          ready: true\n        });\n      } else {\n        // Normal glTF (JSON)\n        cachedGltf = new CachedGltf({\n          gltf: options.gltf,\n          ready: true\n        });\n      }\n\n      cachedGltf.count = 1;\n\n      if (defined(cacheKey)) {\n        gltfCache[cacheKey] = cachedGltf;\n      }\n    }\n  }\n\n  setCachedGltf(this, cachedGltf);\n  var basePath = defaultValue(options.basePath, \"\");\n  this._resource = Resource.createIfNeeded(basePath); // User specified credit\n\n  var credit = options.credit;\n\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n\n  this._credit = credit; // Create a list of Credit's so they can be added from the Resource later\n\n  this._resourceCredits = [];\n  /**\n   * Determines if the model primitive will be shown.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n\n  this.show = defaultValue(options.show, true);\n  /**\n   * The silhouette color.\n   *\n   * @type {Color}\n   *\n   * @default Color.RED\n   */\n\n  this.silhouetteColor = defaultValue(options.silhouetteColor, Color.RED);\n  this._silhouetteColor = new Color();\n  this._silhouetteColorPreviousAlpha = 1.0;\n  this._normalAttributeName = undefined;\n  /**\n   * The size of the silhouette in pixels.\n   *\n   * @type {Number}\n   *\n   * @default 0.0\n   */\n\n  this.silhouetteSize = defaultValue(options.silhouetteSize, 0.0);\n  /**\n   * The 4x4 transformation matrix that transforms the model from model to world coordinates.\n   * When this is the identity matrix, the model is drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type {Matrix4}\n   *\n   * @default {@link Matrix4.IDENTITY}\n   *\n   * @example\n   * var origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n   * m.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);\n   */\n\n  this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));\n  this._modelMatrix = Matrix4.clone(this.modelMatrix);\n  this._clampedModelMatrix = undefined;\n  /**\n   * A uniform scale applied to this model before the {@link Model#modelMatrix}.\n   * Values greater than <code>1.0</code> increase the size of the model; values\n   * less than <code>1.0</code> decrease.\n   *\n   * @type {Number}\n   *\n   * @default 1.0\n   */\n\n  this.scale = defaultValue(options.scale, 1.0);\n  this._scale = this.scale;\n  /**\n   * The approximate minimum pixel size of the model regardless of zoom.\n   * This can be used to ensure that a model is visible even when the viewer\n   * zooms out.  When <code>0.0</code>, no minimum size is enforced.\n   *\n   * @type {Number}\n   *\n   * @default 0.0\n   */\n\n  this.minimumPixelSize = defaultValue(options.minimumPixelSize, 0.0);\n  this._minimumPixelSize = this.minimumPixelSize;\n  /**\n   * The maximum scale size for a model. This can be used to give\n   * an upper limit to the {@link Model#minimumPixelSize}, ensuring that the model\n   * is never an unreasonable scale.\n   *\n   * @type {Number}\n   */\n\n  this.maximumScale = options.maximumScale;\n  this._maximumScale = this.maximumScale;\n  /**\n   * User-defined object returned when the model is picked.\n   *\n   * @type Object\n   *\n   * @default undefined\n   *\n   * @see Scene#pick\n   */\n\n  this.id = options.id;\n  this._id = options.id;\n  /**\n   * Returns the height reference of the model\n   *\n   * @type {HeightReference}\n   *\n   * @default HeightReference.NONE\n   */\n\n  this.heightReference = defaultValue(options.heightReference, HeightReference.NONE);\n  this._heightReference = this.heightReference;\n  this._heightChanged = false;\n  this._removeUpdateHeightCallback = undefined;\n  var scene = options.scene;\n  this._scene = scene;\n\n  if (defined(scene) && defined(scene.terrainProviderChanged)) {\n    this._terrainProviderChangedCallback = scene.terrainProviderChanged.addEventListener(function () {\n      this._heightChanged = true;\n    }, this);\n  }\n  /**\n   * Used for picking primitives that wrap a model.\n   *\n   * @private\n   */\n\n\n  this._pickObject = options.pickObject;\n  this._allowPicking = defaultValue(options.allowPicking, true);\n  this._ready = false;\n  this._readyPromise = when.defer();\n  /**\n   * The currently playing glTF animations.\n   *\n   * @type {ModelAnimationCollection}\n   */\n\n  this.activeAnimations = new ModelAnimationCollection(this);\n  /**\n   * Determines if the model's animations should hold a pose over frames where no keyframes are specified.\n   *\n   * @type {Boolean}\n   */\n\n  this.clampAnimations = defaultValue(options.clampAnimations, true);\n  this._defaultTexture = undefined;\n  this._incrementallyLoadTextures = defaultValue(options.incrementallyLoadTextures, true);\n  this._asynchronous = defaultValue(options.asynchronous, true);\n  /**\n   * Determines whether the model casts or receives shadows from light sources.\n   *\n   * @type {ShadowMode}\n   *\n   * @default ShadowMode.ENABLED\n   */\n\n  this.shadows = defaultValue(options.shadows, ShadowMode.ENABLED);\n  this._shadows = this.shadows;\n  /**\n   * A color that blends with the model's rendered color.\n   *\n   * @type {Color}\n   *\n   * @default Color.WHITE\n   */\n\n  this.color = Color.clone(defaultValue(options.color, Color.WHITE));\n  this._colorPreviousAlpha = 1.0;\n  /**\n   * Defines how the color blends with the model.\n   *\n   * @type {ColorBlendMode}\n   *\n   * @default ColorBlendMode.HIGHLIGHT\n   */\n\n  this.colorBlendMode = defaultValue(options.colorBlendMode, ColorBlendMode.HIGHLIGHT);\n  /**\n   * Value used to determine the color strength when the <code>colorBlendMode</code> is <code>MIX</code>.\n   * A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with\n   * any value in-between resulting in a mix of the two.\n   *\n   * @type {Number}\n   *\n   * @default 0.5\n   */\n\n  this.colorBlendAmount = defaultValue(options.colorBlendAmount, 0.5);\n  this._colorShadingEnabled = false;\n  this._clippingPlanes = undefined;\n  this.clippingPlanes = options.clippingPlanes; // Used for checking if shaders need to be regenerated due to clipping plane changes.\n\n  this._clippingPlanesState = 0; // If defined, use this matrix to position the clipping planes instead of the modelMatrix.\n  // This is so that when models are part of a tileset they all get clipped relative\n  // to the root tile.\n\n  this.clippingPlanesOriginMatrix = undefined;\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the model.  A glTF primitive corresponds\n   * to one draw command.  A glTF mesh has an array of primitives, often of length one.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n\n  this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);\n  this._debugShowBoundingVolume = false;\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the model in wireframe.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n\n  this.debugWireframe = defaultValue(options.debugWireframe, false);\n  this._debugWireframe = false;\n  this._distanceDisplayCondition = options.distanceDisplayCondition; // Undocumented options\n\n  this._addBatchIdToGeneratedShaders = options.addBatchIdToGeneratedShaders;\n  this._precreatedAttributes = options.precreatedAttributes;\n  this._vertexShaderLoaded = options.vertexShaderLoaded;\n  this._fragmentShaderLoaded = options.fragmentShaderLoaded;\n  this._uniformMapLoaded = options.uniformMapLoaded;\n  this._pickIdLoaded = options.pickIdLoaded;\n  this._ignoreCommands = defaultValue(options.ignoreCommands, false);\n  this._requestType = options.requestType;\n  this._upAxis = defaultValue(options.upAxis, Axis.Y);\n  this._gltfForwardAxis = Axis.Z;\n  this._forwardAxis = options.forwardAxis;\n  /**\n   * @private\n   * @readonly\n   */\n\n  this.cull = defaultValue(options.cull, true);\n  /**\n   * @private\n   * @readonly\n   */\n\n  this.opaquePass = defaultValue(options.opaquePass, Pass.OPAQUE);\n  this._computedModelMatrix = new Matrix4(); // Derived from modelMatrix and scale\n\n  this._clippingPlaneModelViewMatrix = Matrix4.clone(Matrix4.IDENTITY); // Derived from modelMatrix, scale, and the current view matrix\n\n  this._initialRadius = undefined; // Radius without model's scale property, model-matrix scale, animations, or skins\n\n  this._boundingSphere = undefined;\n  this._scaledBoundingSphere = new BoundingSphere();\n  this._state = ModelState.NEEDS_LOAD;\n  this._loadResources = undefined;\n  this._mode = undefined;\n  this._perNodeShowDirty = false; // true when the Cesium API was used to change a node's show property\n\n  this._cesiumAnimationsDirty = false; // true when the Cesium API, not a glTF animation, changed a node transform\n\n  this._dirty = false; // true when the model was transformed this frame\n\n  this._maxDirtyNumber = 0; // Used in place of a dirty boolean flag to avoid an extra graph traversal\n\n  this._runtime = {\n    animations: undefined,\n    articulationsByName: undefined,\n    articulationsByStageKey: undefined,\n    stagesByKey: undefined,\n    rootNodes: undefined,\n    nodes: undefined,\n    // Indexed with the node's index\n    nodesByName: undefined,\n    // Indexed with name property in the node\n    skinnedNodes: undefined,\n    meshesByName: undefined,\n    // Indexed with the name property in the mesh\n    materialsByName: undefined,\n    // Indexed with the name property in the material\n    materialsById: undefined // Indexed with the material's index\n\n  };\n  this._uniformMaps = {}; // Not cached since it can be targeted by glTF animation\n\n  this._extensionsUsed = undefined; // Cached used glTF extensions\n\n  this._extensionsRequired = undefined; // Cached required glTF extensions\n\n  this._quantizedUniforms = {}; // Quantized uniforms for each program for WEB3D_quantized_attributes\n\n  this._programPrimitives = {};\n  this._rendererResources = {\n    // Cached between models with the same url/cache-key\n    buffers: {},\n    vertexArrays: {},\n    programs: {},\n    sourceShaders: {},\n    silhouettePrograms: {},\n    textures: {},\n    samplers: {},\n    renderStates: {}\n  };\n  this._cachedRendererResources = undefined;\n  this._loadRendererResourcesFromCache = false;\n  this._dequantizeInShader = defaultValue(options.dequantizeInShader, true);\n  this._decodedData = {};\n  this._cachedGeometryByteLength = 0;\n  this._cachedTexturesByteLength = 0;\n  this._geometryByteLength = 0;\n  this._texturesByteLength = 0;\n  this._trianglesLength = 0; // Hold references for shader reconstruction.\n  // Hold these separately because _cachedGltf may get released (this.releaseGltfJson)\n\n  this._sourceTechniques = {};\n  this._sourcePrograms = {};\n  this._quantizedVertexShaders = {};\n  this._nodeCommands = [];\n  this._pickIds = []; // CESIUM_RTC extension\n\n  this._rtcCenter = undefined; // reference to either 3D or 2D\n\n  this._rtcCenterEye = undefined; // in eye coordinates\n\n  this._rtcCenter3D = undefined; // in world coordinates\n\n  this._rtcCenter2D = undefined; // in projected world coordinates\n\n  this._sourceVersion = undefined;\n  this._sourceKHRTechniquesWebGL = undefined;\n  this._imageBasedLightingFactor = new Cartesian2(1.0, 1.0);\n  Cartesian2.clone(options.imageBasedLightingFactor, this._imageBasedLightingFactor);\n  this._lightColor = Cartesian3.clone(options.lightColor);\n  this._luminanceAtZenith = undefined;\n  this.luminanceAtZenith = defaultValue(options.luminanceAtZenith, 0.2);\n  this._sphericalHarmonicCoefficients = options.sphericalHarmonicCoefficients;\n  this._specularEnvironmentMaps = options.specularEnvironmentMaps;\n  this._shouldUpdateSpecularMapAtlas = true;\n  this._specularEnvironmentMapAtlas = undefined;\n  this._useDefaultSphericalHarmonics = false;\n  this._useDefaultSpecularMaps = false;\n  this._shouldRegenerateShaders = false;\n}\n\nObject.defineProperties(Model.prototype, {\n  /**\n   * The object for the glTF JSON, including properties with default values omitted\n   * from the JSON provided to this model.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Object}\n   * @readonly\n   *\n   * @default undefined\n   */\n  gltf: {\n    get: function () {\n      return defined(this._cachedGltf) ? this._cachedGltf.gltf : undefined;\n    }\n  },\n\n  /**\n   * When <code>true</code>, the glTF JSON is not stored with the model once the model is\n   * loaded (when {@link Model#ready} is <code>true</code>).  This saves memory when\n   * geometry, textures, and animations are embedded in the .gltf file.\n   * This is especially useful for cases like 3D buildings, where each .gltf model is unique\n   * and caching the glTF JSON is not effective.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   *\n   * @private\n   */\n  releaseGltfJson: {\n    get: function () {\n      return this._releaseGltfJson;\n    }\n  },\n\n  /**\n   * The key identifying this model in the model cache for glTF JSON, renderer resources, and animations.\n   * Caching saves memory and improves loading speed when several models with the same url are created.\n   * <p>\n   * This key is automatically generated when the model is created with {@link Model.fromGltf}.  If the model\n   * is created directly from glTF JSON using the {@link Model} constructor, this key can be manually\n   * provided; otherwise, the model will not be changed.\n   * </p>\n   *\n   * @memberof Model.prototype\n   *\n   * @type {String}\n   * @readonly\n   *\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    }\n  },\n\n  /**\n   * The base path that paths in the glTF JSON are relative to.  The base\n   * path is the same path as the path containing the .gltf file\n   * minus the .gltf file, when binary, image, and shader files are\n   * in the same directory as the .gltf.  When this is <code>''</code>,\n   * the app's base path is used.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {String}\n   * @readonly\n   *\n   * @default ''\n   */\n  basePath: {\n    get: function () {\n      return this._resource.url;\n    }\n  },\n\n  /**\n   * The model's bounding sphere in its local coordinate system.  This does not take into\n   * account glTF animations and skins nor does it take into account {@link Model#minimumPixelSize}.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   *\n   * @default undefined\n   *\n   * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n   *\n   * @example\n   * // Center in WGS84 coordinates\n   * var center = Cesium.Matrix4.multiplyByPoint(model.modelMatrix, model.boundingSphere.center, new Cesium.Cartesian3());\n   */\n  boundingSphere: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (this._state !== ModelState.LOADED) {\n        throw new DeveloperError(\"The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\");\n      } //>>includeEnd('debug');\n\n\n      var modelMatrix = this.modelMatrix;\n\n      if (this.heightReference !== HeightReference.NONE && this._clampedModelMatrix) {\n        modelMatrix = this._clampedModelMatrix;\n      }\n\n      var nonUniformScale = Matrix4.getScale(modelMatrix, boundingSphereCartesian3Scratch);\n      var scale = defined(this.maximumScale) ? Math.min(this.maximumScale, this.scale) : this.scale;\n      Cartesian3.multiplyByScalar(nonUniformScale, scale, nonUniformScale);\n      var scaledBoundingSphere = this._scaledBoundingSphere;\n      scaledBoundingSphere.center = Cartesian3.multiplyComponents(this._boundingSphere.center, nonUniformScale, scaledBoundingSphere.center);\n      scaledBoundingSphere.radius = Cartesian3.maximumComponent(nonUniformScale) * this._initialRadius;\n\n      if (defined(this._rtcCenter)) {\n        Cartesian3.add(this._rtcCenter, scaledBoundingSphere.center, scaledBoundingSphere.center);\n      }\n\n      return scaledBoundingSphere;\n    }\n  },\n\n  /**\n   * When <code>true</code>, this model is ready to render, i.e., the external binary, image,\n   * and shader files were downloaded and the WebGL resources were created.  This is set to\n   * <code>true</code> right before {@link Model#readyPromise} is resolved.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n\n  /**\n   * Gets the promise that will be resolved when this model is ready to render, i.e., when the external binary, image,\n   * and shader files were downloaded and the WebGL resources were created.\n   * <p>\n   * This promise is resolved at the end of the frame before the first frame the model is rendered in.\n   * </p>\n   *\n   * @memberof Model.prototype\n   * @type {Promise.<Model>}\n   * @readonly\n   *\n   * @example\n   * // Play all animations at half-speed when the model is ready to render\n   * Cesium.when(model.readyPromise).then(function(model) {\n   *   model.activeAnimations.addAll({\n   *     multiplier : 0.5\n   *   });\n   * }).otherwise(function(error){\n   *   window.alert(error);\n   * });\n   *\n   * @see Model#ready\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    }\n  },\n\n  /**\n   * Determines if model WebGL resource creation will be spread out over several frames or\n   * block until completion once all glTF files are loaded.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._asynchronous;\n    }\n  },\n\n  /**\n   * When <code>true</code>, each glTF mesh and primitive is pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._allowPicking;\n    }\n  },\n\n  /**\n   * Determine if textures may continue to stream in after the model is loaded.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  incrementallyLoadTextures: {\n    get: function () {\n      return this._incrementallyLoadTextures;\n    }\n  },\n\n  /**\n   * Return the number of pending texture loads.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  pendingTextureLoads: {\n    get: function () {\n      return defined(this._loadResources) ? this._loadResources.pendingTextureLoads : 0;\n    }\n  },\n\n  /**\n   * Returns true if the model was transformed this frame\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @private\n   */\n  dirty: {\n    get: function () {\n      return this._dirty;\n    }\n  },\n\n  /**\n   * Gets or sets the condition specifying at what distance from the camera that this model will be displayed.\n   * @memberof Model.prototype\n   * @type {DistanceDisplayCondition}\n   * @default undefined\n   */\n  distanceDisplayCondition: {\n    get: function () {\n      return this._distanceDisplayCondition;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\"far must be greater than near\");\n      } //>>includeEnd('debug');\n\n\n      this._distanceDisplayCondition = DistanceDisplayCondition.clone(value, this._distanceDisplayCondition);\n    }\n  },\n  extensionsUsed: {\n    get: function () {\n      if (!defined(this._extensionsUsed)) {\n        this._extensionsUsed = ModelUtility.getUsedExtensions(this.gltf);\n      }\n\n      return this._extensionsUsed;\n    }\n  },\n  extensionsRequired: {\n    get: function () {\n      if (!defined(this._extensionsRequired)) {\n        this._extensionsRequired = ModelUtility.getRequiredExtensions(this.gltf);\n      }\n\n      return this._extensionsRequired;\n    }\n  },\n\n  /**\n   * Gets the model's up-axis.\n   * By default models are y-up according to the glTF spec, however geo-referenced models will typically be z-up.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Number}\n   * @default Axis.Y\n   * @readonly\n   *\n   * @private\n   */\n  upAxis: {\n    get: function () {\n      return this._upAxis;\n    }\n  },\n\n  /**\n   * Gets the model's forward axis.\n   * By default, glTF 2.0 models are z-forward according to the glTF spec, however older\n   * glTF (1.0, 0.8) models used x-forward.  Note that only Axis.X and Axis.Z are supported.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Number}\n   * @default Axis.Z\n   * @readonly\n   *\n   * @private\n   */\n  forwardAxis: {\n    get: function () {\n      if (defined(this._forwardAxis)) {\n        return this._forwardAxis;\n      }\n\n      return this._gltfForwardAxis;\n    }\n  },\n\n  /**\n   * Gets the model's triangle count.\n   *\n   * @private\n   */\n  trianglesLength: {\n    get: function () {\n      return this._trianglesLength;\n    }\n  },\n\n  /**\n   * Gets the model's geometry memory in bytes. This includes all vertex and index buffers.\n   *\n   * @private\n   */\n  geometryByteLength: {\n    get: function () {\n      return this._geometryByteLength;\n    }\n  },\n\n  /**\n   * Gets the model's texture memory in bytes.\n   *\n   * @private\n   */\n  texturesByteLength: {\n    get: function () {\n      return this._texturesByteLength;\n    }\n  },\n\n  /**\n   * Gets the model's cached geometry memory in bytes. This includes all vertex and index buffers.\n   *\n   * @private\n   */\n  cachedGeometryByteLength: {\n    get: function () {\n      return this._cachedGeometryByteLength;\n    }\n  },\n\n  /**\n   * Gets the model's cached texture memory in bytes.\n   *\n   * @private\n   */\n  cachedTexturesByteLength: {\n    get: function () {\n      return this._cachedTexturesByteLength;\n    }\n  },\n\n  /**\n   * The {@link ClippingPlaneCollection} used to selectively disable rendering the model.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {ClippingPlaneCollection}\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._clippingPlanes;\n    },\n    set: function (value) {\n      if (value === this._clippingPlanes) {\n        return;\n      } // Handle destroying, checking of unknown, checking for existing ownership\n\n\n      ClippingPlaneCollection.setOwner(value, this, \"_clippingPlanes\");\n    }\n  },\n\n  /**\n   * @private\n   */\n  pickIds: {\n    get: function () {\n      return this._pickIds;\n    }\n  },\n\n  /**\n   * Cesium adds lighting from the earth, sky, atmosphere, and star skybox. This cartesian is used to scale the final\n   * diffuse and specular lighting contribution from those sources to the final color. A value of 0.0 will disable those light sources.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Cartesian2}\n   * @default Cartesian2(1.0, 1.0)\n   */\n  imageBasedLightingFactor: {\n    get: function () {\n      return this._imageBasedLightingFactor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.object(\"imageBasedLightingFactor\", value);\n      Check.typeOf.number.greaterThanOrEquals(\"imageBasedLightingFactor.x\", value.x, 0.0);\n      Check.typeOf.number.lessThanOrEquals(\"imageBasedLightingFactor.x\", value.x, 1.0);\n      Check.typeOf.number.greaterThanOrEquals(\"imageBasedLightingFactor.y\", value.y, 0.0);\n      Check.typeOf.number.lessThanOrEquals(\"imageBasedLightingFactor.y\", value.y, 1.0); //>>includeEnd('debug');\n\n      var imageBasedLightingFactor = this._imageBasedLightingFactor;\n\n      if (value === imageBasedLightingFactor || Cartesian2.equals(value, imageBasedLightingFactor)) {\n        return;\n      }\n\n      this._shouldRegenerateShaders = this._shouldRegenerateShaders || this._imageBasedLightingFactor.x > 0.0 && value.x === 0.0 || this._imageBasedLightingFactor.x === 0.0 && value.x > 0.0;\n      this._shouldRegenerateShaders = this._shouldRegenerateShaders || this._imageBasedLightingFactor.y > 0.0 && value.y === 0.0 || this._imageBasedLightingFactor.y === 0.0 && value.y > 0.0;\n      Cartesian2.clone(value, this._imageBasedLightingFactor);\n    }\n  },\n\n  /**\n   * The light color when shading the model. When <code>undefined</code> the scene's light color is used instead.\n   * <p>\n   * For example, disabling additional light sources by setting <code>model.imageBasedLightingFactor = new Cesium.Cartesian2(0.0, 0.0)</code> will make the\n   * model much darker. Here, increasing the intensity of the light source will make the model brighter.\n   * </p>\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Cartesian3}\n   * @default undefined\n   */\n  lightColor: {\n    get: function () {\n      return this._lightColor;\n    },\n    set: function (value) {\n      var lightColor = this._lightColor;\n\n      if (value === lightColor || Cartesian3.equals(value, lightColor)) {\n        return;\n      }\n\n      this._shouldRegenerateShaders = this._shouldRegenerateShaders || defined(lightColor) && !defined(value) || defined(value) && !defined(lightColor);\n      this._lightColor = Cartesian3.clone(value, lightColor);\n    }\n  },\n\n  /**\n   * The sun's luminance at the zenith in kilo candela per meter squared to use for this model's procedural environment map.\n   * This is used when {@link Model#specularEnvironmentMaps} and {@link Model#sphericalHarmonicCoefficients} are not defined.\n   *\n   * @memberof Model.prototype\n   *\n   * @demo {@link https://sandcastle.cesium.com/index.html?src=Image-Based Lighting.html|Sandcastle Image Based Lighting Demo}\n   * @type {Number}\n   * @default 0.2\n   */\n  luminanceAtZenith: {\n    get: function () {\n      return this._luminanceAtZenith;\n    },\n    set: function (value) {\n      var lum = this._luminanceAtZenith;\n\n      if (value === lum) {\n        return;\n      }\n\n      this._shouldRegenerateShaders = this._shouldRegenerateShaders || defined(lum) && !defined(value) || defined(value) && !defined(lum);\n      this._luminanceAtZenith = value;\n    }\n  },\n\n  /**\n   * The third order spherical harmonic coefficients used for the diffuse color of image-based lighting. When <code>undefined</code>, a diffuse irradiance\n   * computed from the atmosphere color is used.\n   * <p>\n   * There are nine <code>Cartesian3</code> coefficients.\n   * The order of the coefficients is: L<sub>00</sub>, L<sub>1-1</sub>, L<sub>10</sub>, L<sub>11</sub>, L<sub>2-2</sub>, L<sub>2-1</sub>, L<sub>20</sub>, L<sub>21</sub>, L<sub>22</sub>\n   * </p>\n   *\n   * These values can be obtained by preprocessing the environment map using the <code>cmgen</code> tool of\n   * {@link https://github.com/google/filament/releases|Google's Filament project}. This will also generate a KTX file that can be\n   * supplied to {@link Model#specularEnvironmentMaps}.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Cartesian3[]}\n   * @demo {@link https://sandcastle.cesium.com/index.html?src=Image-Based Lighting.html|Sandcastle Image Based Lighting Demo}\n   * @see {@link https://graphics.stanford.edu/papers/envmap/envmap.pdf|An Efficient Representation for Irradiance Environment Maps}\n   */\n  sphericalHarmonicCoefficients: {\n    get: function () {\n      return this._sphericalHarmonicCoefficients;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && (!Array.isArray(value) || value.length !== 9)) {\n        throw new DeveloperError(\"sphericalHarmonicCoefficients must be an array of 9 Cartesian3 values.\");\n      } //>>includeEnd('debug');\n\n\n      if (value === this._sphericalHarmonicCoefficients) {\n        return;\n      }\n\n      this._sphericalHarmonicCoefficients = value;\n      this._shouldRegenerateShaders = true;\n    }\n  },\n\n  /**\n   * A URL to a KTX file that contains a cube map of the specular lighting and the convoluted specular mipmaps.\n   *\n   * @memberof Model.prototype\n   * @demo {@link https://sandcastle.cesium.com/index.html?src=Image-Based Lighting.html|Sandcastle Image Based Lighting Demo}\n   * @type {String}\n   * @see Model#sphericalHarmonicCoefficients\n   */\n  specularEnvironmentMaps: {\n    get: function () {\n      return this._specularEnvironmentMaps;\n    },\n    set: function (value) {\n      this._shouldUpdateSpecularMapAtlas = this._shouldUpdateSpecularMapAtlas || value !== this._specularEnvironmentMaps;\n      this._specularEnvironmentMaps = value;\n    }\n  },\n\n  /**\n   * Gets the credit that will be displayed for the model\n   * @memberof Model.prototype\n   * @type {Credit}\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    }\n  }\n});\n\nfunction silhouetteSupported(context) {\n  return context.stencilBuffer;\n}\n\nfunction isColorShadingEnabled(model) {\n  return !Color.equals(model.color, Color.WHITE) || model.colorBlendMode !== ColorBlendMode.HIGHLIGHT;\n}\n\nfunction isClippingEnabled(model) {\n  var clippingPlanes = model._clippingPlanes;\n  return defined(clippingPlanes) && clippingPlanes.enabled && clippingPlanes.length !== 0;\n}\n/**\n * Determines if silhouettes are supported.\n *\n * @param {Scene} scene The scene.\n * @returns {Boolean} <code>true</code> if silhouettes are supported; otherwise, returns <code>false</code>\n */\n\n\nModel.silhouetteSupported = function (scene) {\n  return silhouetteSupported(scene.context);\n};\n\nfunction containsGltfMagic(uint8Array) {\n  var magic = getMagic(uint8Array);\n  return magic === \"glTF\";\n}\n/**\n * <p>\n * Creates a model from a glTF asset.  When the model is ready to render, i.e., when the external binary, image,\n * and shader files are downloaded and the WebGL resources are created, the {@link Model#readyPromise} is resolved.\n * </p>\n * <p>\n * The model can be a traditional glTF asset with a .gltf extension or a Binary glTF using the .glb extension.\n * </p>\n * <p>\n * Cesium supports glTF assets with the following extensions:\n * <ul>\n * <li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/README.md|KHR_binary_glTF (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_materials_common/README.md|KHR_materials_common (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/WEB3D_quantized_attributes/README.md|WEB3D_quantized_attributes (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/AGI_articulations/README.md|AGI_articulations}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/pull/1302|KHR_blend (draft)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md|KHR_draco_mesh_compression}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/README.md|KHR_materials_pbrSpecularGlossiness}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit/README.md|KHR_materials_unlit}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_techniques_webgl/README.md|KHR_techniques_webgl}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_texture_transform/README.md|KHR_texture_transform}\n * </li>\n * </ul>\n * </p>\n * <p>\n * For high-precision rendering, Cesium supports the {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/CESIUM_RTC/README.md|CESIUM_RTC} extension, which introduces the\n * CESIUM_RTC_MODELVIEW parameter semantic that says the node is in WGS84 coordinates translated\n * relative to a local origin.\n * </p>\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource|String} options.url The url to the .gltf file.\n * @param {Resource|String} [options.basePath] The base path that paths in the glTF JSON are relative to.\n * @param {Boolean} [options.show=true] Determines if the model primitive will be shown.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the model from model to world coordinates.\n * @param {Number} [options.scale=1.0] A uniform scale applied to this model.\n * @param {Number} [options.minimumPixelSize=0.0] The approximate minimum pixel size of the model regardless of zoom.\n * @param {Number} [options.maximumScale] The maximum scale for the model.\n * @param {Object} [options.id] A user-defined object to return when the model is picked with {@link Scene#pick}.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each glTF mesh and primitive is pickable with {@link Scene#pick}.\n * @param {Boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the model is loaded.\n * @param {Boolean} [options.asynchronous=true] Determines if model WebGL resource creation will be spread out over several frames or block until completion once all glTF files are loaded.\n * @param {Boolean} [options.clampAnimations=true] Determines if the model's animations should hold a pose over frames where no keyframes are specified.\n * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the model casts or receives shadows from light sources.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Draws the bounding sphere for each draw command in the model.\n * @param {Boolean} [options.debugWireframe=false] For debugging only. Draws the model in wireframe.\n * @param {HeightReference} [options.heightReference=HeightReference.NONE] Determines how the model is drawn relative to terrain.\n * @param {Scene} [options.scene] Must be passed in for models that use the height reference property.\n * @param {DistanceDisplayCondition} [options.distanceDisplayCondition] The condition specifying at what distance from the camera that this model will be displayed.\n * @param {Color} [options.color=Color.WHITE] A color that blends with the model's rendered color.\n * @param {ColorBlendMode} [options.colorBlendMode=ColorBlendMode.HIGHLIGHT] Defines how the color blends with the model.\n * @param {Number} [options.colorBlendAmount=0.5] Value used to determine the color strength when the <code>colorBlendMode</code> is <code>MIX</code>. A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with any value in-between resulting in a mix of the two.\n * @param {Color} [options.silhouetteColor=Color.RED] The silhouette color. If more than 256 models have silhouettes enabled, there is a small chance that overlapping models will have minor artifacts.\n * @param {Number} [options.silhouetteSize=0.0] The size of the silhouette in pixels.\n * @param {ClippingPlaneCollection} [options.clippingPlanes] The {@link ClippingPlaneCollection} used to selectively disable rendering the model.\n * @param {Boolean} [options.dequantizeInShader=true] Determines if a {@link https://github.com/google/draco|Draco} encoded model is dequantized on the GPU. This decreases total memory usage for encoded models.\n * @param {Credit|String} [options.credit] A credit for the model, which is displayed on the canvas.\n *\n * @returns {Model} The newly created model.\n *\n * @example\n * // Example 1. Create a model from a glTF asset\n * var model = scene.primitives.add(Cesium.Model.fromGltf({\n *   url : './duck/duck.gltf'\n * }));\n *\n * @example\n * // Example 2. Create model and provide all properties and events\n * var origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n * var modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);\n *\n * var model = scene.primitives.add(Cesium.Model.fromGltf({\n *   url : './duck/duck.gltf',\n *   show : true,                     // default\n *   modelMatrix : modelMatrix,\n *   scale : 2.0,                     // double size\n *   minimumPixelSize : 128,          // never smaller than 128 pixels\n *   maximumScale: 20000,             // never larger than 20000 * model size (overrides minimumPixelSize)\n *   allowPicking : false,            // not pickable\n *   debugShowBoundingVolume : false, // default\n *   debugWireframe : false\n * }));\n *\n * model.readyPromise.then(function(model) {\n *   // Play all animations when the model is ready to render\n *   model.activeAnimations.addAll();\n * });\n */\n\n\nModel.fromGltf = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.url)) {\n    throw new DeveloperError(\"options.url is required\");\n  } //>>includeEnd('debug');\n\n\n  var url = options.url;\n  options = clone(options); // Create resource for the model file\n\n  var modelResource = Resource.createIfNeeded(url); // Setup basePath to get dependent files\n\n  var basePath = defaultValue(options.basePath, modelResource.clone());\n  var resource = Resource.createIfNeeded(basePath); // If no cache key is provided, use a GUID.\n  // Check using a URI to GUID dictionary that we have not already added this model.\n\n  var cacheKey = defaultValue(options.cacheKey, uriToGuid[getAbsoluteUri(modelResource.url)]);\n\n  if (!defined(cacheKey)) {\n    cacheKey = createGuid();\n    uriToGuid[getAbsoluteUri(modelResource.url)] = cacheKey;\n  }\n\n  if (defined(options.basePath) && !defined(options.cacheKey)) {\n    cacheKey += resource.url;\n  }\n\n  options.cacheKey = cacheKey;\n  options.basePath = resource;\n  var model = new Model(options);\n  var cachedGltf = gltfCache[cacheKey];\n\n  if (!defined(cachedGltf)) {\n    cachedGltf = new CachedGltf({\n      ready: false\n    });\n    cachedGltf.count = 1;\n    cachedGltf.modelsToLoad.push(model);\n    setCachedGltf(model, cachedGltf);\n    gltfCache[cacheKey] = cachedGltf; // Add Accept header if we need it\n\n    if (!defined(modelResource.headers.Accept)) {\n      modelResource.headers.Accept = defaultModelAccept;\n    }\n\n    modelResource.fetchArrayBuffer().then(function (arrayBuffer) {\n      var array = new Uint8Array(arrayBuffer);\n\n      if (containsGltfMagic(array)) {\n        // Load binary glTF\n        var parsedGltf = parseGlb(array);\n        cachedGltf.makeReady(parsedGltf);\n      } else {\n        // Load text (JSON) glTF\n        var json = getStringFromTypedArray(array);\n        cachedGltf.makeReady(JSON.parse(json));\n      }\n\n      var resourceCredits = model._resourceCredits;\n      var credits = modelResource.credits;\n\n      if (defined(credits)) {\n        var length = credits.length;\n\n        for (var i = 0; i < length; i++) {\n          resourceCredits.push(credits[i]);\n        }\n      }\n    }).otherwise(ModelUtility.getFailedLoadFunction(model, \"model\", modelResource.url));\n  } else if (!cachedGltf.ready) {\n    // Cache hit but the fetchArrayBuffer() or fetchText() request is still pending\n    ++cachedGltf.count;\n    cachedGltf.modelsToLoad.push(model);\n  } // else if the cached glTF is defined and ready, the\n  // model constructor will pick it up using the cache key.\n\n\n  return model;\n};\n/**\n * For the unit tests to verify model caching.\n *\n * @private\n */\n\n\nModel._gltfCache = gltfCache;\n\nfunction getRuntime(model, runtimeName, name) {\n  //>>includeStart('debug', pragmas.debug);\n  if (model._state !== ModelState.LOADED) {\n    throw new DeveloperError(\"The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\");\n  }\n\n  if (!defined(name)) {\n    throw new DeveloperError(\"name is required.\");\n  } //>>includeEnd('debug');\n\n\n  return model._runtime[runtimeName][name];\n}\n/**\n * Returns the glTF node with the given <code>name</code> property.  This is used to\n * modify a node's transform for animation outside of glTF animations.\n *\n * @param {String} name The glTF name of the node.\n * @returns {ModelNode} The node or <code>undefined</code> if no node with <code>name</code> exists.\n *\n * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n *\n * @example\n * // Apply non-uniform scale to node LOD3sp\n * var node = model.getNode('LOD3sp');\n * node.matrix = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(5.0, 1.0, 1.0), node.matrix);\n */\n\n\nModel.prototype.getNode = function (name) {\n  var node = getRuntime(this, \"nodesByName\", name);\n  return defined(node) ? node.publicNode : undefined;\n};\n/**\n * Returns the glTF mesh with the given <code>name</code> property.\n *\n * @param {String} name The glTF name of the mesh.\n *\n * @returns {ModelMesh} The mesh or <code>undefined</code> if no mesh with <code>name</code> exists.\n *\n * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n */\n\n\nModel.prototype.getMesh = function (name) {\n  return getRuntime(this, \"meshesByName\", name);\n};\n/**\n * Returns the glTF material with the given <code>name</code> property.\n *\n * @param {String} name The glTF name of the material.\n * @returns {ModelMaterial} The material or <code>undefined</code> if no material with <code>name</code> exists.\n *\n * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n */\n\n\nModel.prototype.getMaterial = function (name) {\n  return getRuntime(this, \"materialsByName\", name);\n};\n/**\n * Sets the current value of an articulation stage.  After setting one or multiple stage values, call\n * Model.applyArticulations() to cause the node matrices to be recalculated.\n *\n * @param {String} articulationStageKey The name of the articulation, a space, and the name of the stage.\n * @param {Number} value The numeric value of this stage of the articulation.\n *\n * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n *\n * @see Model#applyArticulations\n */\n\n\nModel.prototype.setArticulationStage = function (articulationStageKey, value) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"value\", value); //>>includeEnd('debug');\n\n  var stage = getRuntime(this, \"stagesByKey\", articulationStageKey);\n  var articulation = getRuntime(this, \"articulationsByStageKey\", articulationStageKey);\n\n  if (defined(stage) && defined(articulation)) {\n    value = CesiumMath.clamp(value, stage.minimumValue, stage.maximumValue);\n\n    if (!CesiumMath.equalsEpsilon(stage.currentValue, value, articulationEpsilon)) {\n      stage.currentValue = value;\n      articulation.isDirty = true;\n    }\n  }\n};\n\nvar scratchArticulationCartesian = new Cartesian3();\nvar scratchArticulationRotation = new Matrix3();\n/**\n * Modifies a Matrix4 by applying a transformation for a given value of a stage.  Note this is different usage\n * from the typical <code>result</code> parameter, in that the incoming value of <code>result</code> is\n * meaningful.  Various stages of an articulation can be multiplied together, so their\n * transformations are all merged into a composite Matrix4 representing them all.\n *\n * @param {object} stage The stage of an articulation that is being evaluated.\n * @param {Matrix4} result The matrix to be modified.\n * @returns {Matrix4} A matrix transformed as requested by the articulation stage.\n *\n * @private\n */\n\nfunction applyArticulationStageMatrix(stage, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"stage\", stage);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var value = stage.currentValue;\n  var cartesian = scratchArticulationCartesian;\n  var rotation;\n\n  switch (stage.type) {\n    case \"xRotate\":\n      rotation = Matrix3.fromRotationX(CesiumMath.toRadians(value), scratchArticulationRotation);\n      Matrix4.multiplyByMatrix3(result, rotation, result);\n      break;\n\n    case \"yRotate\":\n      rotation = Matrix3.fromRotationY(CesiumMath.toRadians(value), scratchArticulationRotation);\n      Matrix4.multiplyByMatrix3(result, rotation, result);\n      break;\n\n    case \"zRotate\":\n      rotation = Matrix3.fromRotationZ(CesiumMath.toRadians(value), scratchArticulationRotation);\n      Matrix4.multiplyByMatrix3(result, rotation, result);\n      break;\n\n    case \"xTranslate\":\n      cartesian.x = value;\n      cartesian.y = 0.0;\n      cartesian.z = 0.0;\n      Matrix4.multiplyByTranslation(result, cartesian, result);\n      break;\n\n    case \"yTranslate\":\n      cartesian.x = 0.0;\n      cartesian.y = value;\n      cartesian.z = 0.0;\n      Matrix4.multiplyByTranslation(result, cartesian, result);\n      break;\n\n    case \"zTranslate\":\n      cartesian.x = 0.0;\n      cartesian.y = 0.0;\n      cartesian.z = value;\n      Matrix4.multiplyByTranslation(result, cartesian, result);\n      break;\n\n    case \"xScale\":\n      cartesian.x = value;\n      cartesian.y = 1.0;\n      cartesian.z = 1.0;\n      Matrix4.multiplyByScale(result, cartesian, result);\n      break;\n\n    case \"yScale\":\n      cartesian.x = 1.0;\n      cartesian.y = value;\n      cartesian.z = 1.0;\n      Matrix4.multiplyByScale(result, cartesian, result);\n      break;\n\n    case \"zScale\":\n      cartesian.x = 1.0;\n      cartesian.y = 1.0;\n      cartesian.z = value;\n      Matrix4.multiplyByScale(result, cartesian, result);\n      break;\n\n    case \"uniformScale\":\n      Matrix4.multiplyByUniformScale(result, value, result);\n      break;\n\n    default:\n      break;\n  }\n\n  return result;\n}\n\nvar scratchApplyArticulationTransform = new Matrix4();\n/**\n * Applies any modified articulation stages to the matrix of each node that participates\n * in any articulation.  Note that this will overwrite any nodeTransformations on participating nodes.\n *\n * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n */\n\nModel.prototype.applyArticulations = function () {\n  var articulationsByName = this._runtime.articulationsByName;\n\n  for (var articulationName in articulationsByName) {\n    if (articulationsByName.hasOwnProperty(articulationName)) {\n      var articulation = articulationsByName[articulationName];\n\n      if (articulation.isDirty) {\n        articulation.isDirty = false;\n        var numNodes = articulation.nodes.length;\n\n        for (var n = 0; n < numNodes; ++n) {\n          var node = articulation.nodes[n];\n          var transform = Matrix4.clone(node.originalMatrix, scratchApplyArticulationTransform);\n          var numStages = articulation.stages.length;\n\n          for (var s = 0; s < numStages; ++s) {\n            var stage = articulation.stages[s];\n            transform = applyArticulationStageMatrix(stage, transform);\n          }\n\n          node.matrix = transform;\n        }\n      }\n    }\n  }\n}; ///////////////////////////////////////////////////////////////////////////\n\n\nfunction addBuffersToLoadResources(model) {\n  var gltf = model.gltf;\n  var loadResources = model._loadResources;\n  ForEach.buffer(gltf, function (buffer, id) {\n    loadResources.buffers[id] = buffer.extras._pipeline.source;\n  });\n}\n\nfunction bufferLoad(model, id) {\n  return function (arrayBuffer) {\n    var loadResources = model._loadResources;\n    var buffer = new Uint8Array(arrayBuffer);\n    --loadResources.pendingBufferLoads;\n    model.gltf.buffers[id].extras._pipeline.source = buffer;\n  };\n}\n\nfunction parseBufferViews(model) {\n  var bufferViews = model.gltf.bufferViews;\n  var vertexBuffersToCreate = model._loadResources.vertexBuffersToCreate; // Only ARRAY_BUFFER here.  ELEMENT_ARRAY_BUFFER created below.\n\n  ForEach.bufferView(model.gltf, function (bufferView, id) {\n    if (bufferView.target === WebGLConstants.ARRAY_BUFFER) {\n      vertexBuffersToCreate.enqueue(id);\n    }\n  });\n  var indexBuffersToCreate = model._loadResources.indexBuffersToCreate;\n  var indexBufferIds = {}; // The Cesium Renderer requires knowing the datatype for an index buffer\n  // at creation type, which is not part of the glTF bufferview so loop\n  // through glTF accessors to create the bufferview's index buffer.\n\n  ForEach.accessor(model.gltf, function (accessor) {\n    var bufferViewId = accessor.bufferView;\n\n    if (!defined(bufferViewId)) {\n      return;\n    }\n\n    var bufferView = bufferViews[bufferViewId];\n\n    if (bufferView.target === WebGLConstants.ELEMENT_ARRAY_BUFFER && !defined(indexBufferIds[bufferViewId])) {\n      indexBufferIds[bufferViewId] = true;\n      indexBuffersToCreate.enqueue({\n        id: bufferViewId,\n        componentType: accessor.componentType\n      });\n    }\n  });\n}\n\nfunction parseTechniques(model) {\n  // retain references to gltf techniques\n  var gltf = model.gltf;\n\n  if (!hasExtension(gltf, \"KHR_techniques_webgl\")) {\n    return;\n  }\n\n  var sourcePrograms = model._sourcePrograms;\n  var sourceTechniques = model._sourceTechniques;\n  var programs = gltf.extensions.KHR_techniques_webgl.programs;\n  ForEach.technique(gltf, function (technique, techniqueId) {\n    sourceTechniques[techniqueId] = clone(technique);\n    var programId = technique.program;\n\n    if (!defined(sourcePrograms[programId])) {\n      sourcePrograms[programId] = clone(programs[programId]);\n    }\n  });\n}\n\nfunction shaderLoad(model, type, id) {\n  return function (source) {\n    var loadResources = model._loadResources;\n    loadResources.shaders[id] = {\n      source: source,\n      type: type,\n      bufferView: undefined\n    };\n    --loadResources.pendingShaderLoads;\n    model._rendererResources.sourceShaders[id] = source;\n  };\n}\n\nfunction parseShaders(model) {\n  var gltf = model.gltf;\n  var buffers = gltf.buffers;\n  var bufferViews = gltf.bufferViews;\n  var sourceShaders = model._rendererResources.sourceShaders;\n  ForEach.shader(gltf, function (shader, id) {\n    // Shader references either uri (external or base64-encoded) or bufferView\n    if (defined(shader.bufferView)) {\n      var bufferViewId = shader.bufferView;\n      var bufferView = bufferViews[bufferViewId];\n      var bufferId = bufferView.buffer;\n      var buffer = buffers[bufferId];\n      var source = getStringFromTypedArray(buffer.extras._pipeline.source, bufferView.byteOffset, bufferView.byteLength);\n      sourceShaders[id] = source;\n    } else if (defined(shader.extras._pipeline.source)) {\n      sourceShaders[id] = shader.extras._pipeline.source;\n    } else {\n      ++model._loadResources.pendingShaderLoads;\n\n      var shaderResource = model._resource.getDerivedResource({\n        url: shader.uri\n      });\n\n      shaderResource.fetchText().then(shaderLoad(model, shader.type, id)).otherwise(ModelUtility.getFailedLoadFunction(model, \"shader\", shaderResource.url));\n    }\n  });\n}\n\nfunction parsePrograms(model) {\n  var sourceTechniques = model._sourceTechniques;\n\n  for (var techniqueId in sourceTechniques) {\n    if (sourceTechniques.hasOwnProperty(techniqueId)) {\n      var technique = sourceTechniques[techniqueId];\n\n      model._loadResources.programsToCreate.enqueue({\n        programId: technique.program,\n        techniqueId: techniqueId\n      });\n    }\n  }\n}\n\nfunction parseArticulations(model) {\n  var articulationsByName = {};\n  var articulationsByStageKey = {};\n  var runtimeStagesByKey = {};\n  model._runtime.articulationsByName = articulationsByName;\n  model._runtime.articulationsByStageKey = articulationsByStageKey;\n  model._runtime.stagesByKey = runtimeStagesByKey;\n  var gltf = model.gltf;\n\n  if (!hasExtension(gltf, \"AGI_articulations\") || !defined(gltf.extensions) || !defined(gltf.extensions.AGI_articulations)) {\n    return;\n  }\n\n  var gltfArticulations = gltf.extensions.AGI_articulations.articulations;\n\n  if (!defined(gltfArticulations)) {\n    return;\n  }\n\n  var numArticulations = gltfArticulations.length;\n\n  for (var i = 0; i < numArticulations; ++i) {\n    var articulation = clone(gltfArticulations[i]);\n    articulation.nodes = [];\n    articulation.isDirty = true;\n    articulationsByName[articulation.name] = articulation;\n    var numStages = articulation.stages.length;\n\n    for (var s = 0; s < numStages; ++s) {\n      var stage = articulation.stages[s];\n      stage.currentValue = stage.initialValue;\n      var stageKey = articulation.name + \" \" + stage.name;\n      articulationsByStageKey[stageKey] = articulation;\n      runtimeStagesByKey[stageKey] = stage;\n    }\n  }\n}\n\nfunction imageLoad(model, textureId) {\n  return function (image) {\n    var loadResources = model._loadResources;\n    --loadResources.pendingTextureLoads;\n    loadResources.texturesToCreate.enqueue({\n      id: textureId,\n      image: image,\n      bufferView: image.bufferView,\n      width: image.width,\n      height: image.height,\n      internalFormat: image.internalFormat\n    });\n  };\n}\n\nvar ktxRegex = /(^data:image\\/ktx)|(\\.ktx$)/i;\nvar crnRegex = /(^data:image\\/crn)|(\\.crn$)/i;\n\nfunction parseTextures(model, context, supportsWebP) {\n  var gltf = model.gltf;\n  var images = gltf.images;\n  var uri;\n  ForEach.texture(gltf, function (texture, id) {\n    var imageId = texture.source;\n\n    if (defined(texture.extensions) && defined(texture.extensions.EXT_texture_webp) && supportsWebP) {\n      imageId = texture.extensions.EXT_texture_webp.source;\n    }\n\n    var gltfImage = images[imageId];\n    var extras = gltfImage.extras;\n    var bufferViewId = gltfImage.bufferView;\n    var mimeType = gltfImage.mimeType;\n    uri = gltfImage.uri; // First check for a compressed texture\n\n    if (defined(extras) && defined(extras.compressedImage3DTiles)) {\n      var crunch = extras.compressedImage3DTiles.crunch;\n      var s3tc = extras.compressedImage3DTiles.s3tc;\n      var pvrtc = extras.compressedImage3DTiles.pvrtc1;\n      var etc1 = extras.compressedImage3DTiles.etc1;\n\n      if (context.s3tc && defined(crunch)) {\n        mimeType = crunch.mimeType;\n\n        if (defined(crunch.bufferView)) {\n          bufferViewId = crunch.bufferView;\n        } else {\n          uri = crunch.uri;\n        }\n      } else if (context.s3tc && defined(s3tc)) {\n        mimeType = s3tc.mimeType;\n\n        if (defined(s3tc.bufferView)) {\n          bufferViewId = s3tc.bufferView;\n        } else {\n          uri = s3tc.uri;\n        }\n      } else if (context.pvrtc && defined(pvrtc)) {\n        mimeType = pvrtc.mimeType;\n\n        if (defined(pvrtc.bufferView)) {\n          bufferViewId = pvrtc.bufferView;\n        } else {\n          uri = pvrtc.uri;\n        }\n      } else if (context.etc1 && defined(etc1)) {\n        mimeType = etc1.mimeType;\n\n        if (defined(etc1.bufferView)) {\n          bufferViewId = etc1.bufferView;\n        } else {\n          uri = etc1.uri;\n        }\n      }\n    } // Image references either uri (external or base64-encoded) or bufferView\n\n\n    if (defined(bufferViewId)) {\n      model._loadResources.texturesToCreateFromBufferView.enqueue({\n        id: id,\n        image: undefined,\n        bufferView: bufferViewId,\n        mimeType: mimeType\n      });\n    } else {\n      ++model._loadResources.pendingTextureLoads;\n\n      var imageResource = model._resource.getDerivedResource({\n        url: uri\n      });\n\n      var promise;\n\n      if (ktxRegex.test(uri)) {\n        promise = loadKTX(imageResource);\n      } else if (crnRegex.test(uri)) {\n        promise = loadCRN(imageResource);\n      } else {\n        promise = imageResource.fetchImage();\n      }\n\n      promise.then(imageLoad(model, id, imageId)).otherwise(ModelUtility.getFailedLoadFunction(model, \"image\", imageResource.url));\n    }\n  });\n}\n\nvar scratchArticulationStageInitialTransform = new Matrix4();\n\nfunction parseNodes(model) {\n  var runtimeNodes = {};\n  var runtimeNodesByName = {};\n  var skinnedNodes = [];\n  var skinnedNodesIds = model._loadResources.skinnedNodesIds;\n  var articulationsByName = model._runtime.articulationsByName;\n  ForEach.node(model.gltf, function (node, id) {\n    var runtimeNode = {\n      // Animation targets\n      matrix: undefined,\n      translation: undefined,\n      rotation: undefined,\n      scale: undefined,\n      // Per-node show inherited from parent\n      computedShow: true,\n      // Computed transforms\n      transformToRoot: new Matrix4(),\n      computedMatrix: new Matrix4(),\n      dirtyNumber: 0,\n      // The frame this node was made dirty by an animation; for graph traversal\n      // Rendering\n      commands: [],\n      // empty for transform, light, and camera nodes\n      // Skinned node\n      inverseBindMatrices: undefined,\n      // undefined when node is not skinned\n      bindShapeMatrix: undefined,\n      // undefined when node is not skinned or identity\n      joints: [],\n      // empty when node is not skinned\n      computedJointMatrices: [],\n      // empty when node is not skinned\n      // Joint node\n      jointName: node.jointName,\n      // undefined when node is not a joint\n      weights: [],\n      // Graph pointers\n      children: [],\n      // empty for leaf nodes\n      parents: [],\n      // empty for root nodes\n      // Publicly-accessible ModelNode instance to modify animation targets\n      publicNode: undefined\n    };\n    runtimeNode.publicNode = new ModelNode(model, node, runtimeNode, id, ModelUtility.getTransform(node));\n    runtimeNodes[id] = runtimeNode;\n    runtimeNodesByName[node.name] = runtimeNode;\n\n    if (defined(node.skin)) {\n      skinnedNodesIds.push(id);\n      skinnedNodes.push(runtimeNode);\n    }\n\n    if (defined(node.extensions) && defined(node.extensions.AGI_articulations)) {\n      var articulationName = node.extensions.AGI_articulations.articulationName;\n\n      if (defined(articulationName)) {\n        var transform = Matrix4.clone(runtimeNode.publicNode.originalMatrix, scratchArticulationStageInitialTransform);\n        var articulation = articulationsByName[articulationName];\n        articulation.nodes.push(runtimeNode.publicNode);\n        var numStages = articulation.stages.length;\n\n        for (var s = 0; s < numStages; ++s) {\n          var stage = articulation.stages[s];\n          transform = applyArticulationStageMatrix(stage, transform);\n        }\n\n        runtimeNode.publicNode.matrix = transform;\n      }\n    }\n  });\n  model._runtime.nodes = runtimeNodes;\n  model._runtime.nodesByName = runtimeNodesByName;\n  model._runtime.skinnedNodes = skinnedNodes;\n}\n\nfunction parseMaterials(model) {\n  var gltf = model.gltf;\n  var techniques = model._sourceTechniques;\n  var runtimeMaterialsByName = {};\n  var runtimeMaterialsById = {};\n  var uniformMaps = model._uniformMaps;\n  ForEach.material(gltf, function (material, materialId) {\n    // Allocated now so ModelMaterial can keep a reference to it.\n    uniformMaps[materialId] = {\n      uniformMap: undefined,\n      values: undefined,\n      jointMatrixUniformName: undefined,\n      morphWeightsUniformName: undefined\n    };\n    var modelMaterial = new ModelMaterial(model, material, materialId);\n\n    if (defined(material.extensions) && defined(material.extensions.KHR_techniques_webgl)) {\n      var techniqueId = material.extensions.KHR_techniques_webgl.technique;\n      modelMaterial._technique = techniqueId;\n      modelMaterial._program = techniques[techniqueId].program;\n      ForEach.materialValue(material, function (value, uniformName) {\n        if (!defined(modelMaterial._values)) {\n          modelMaterial._values = {};\n        }\n\n        modelMaterial._values[uniformName] = clone(value);\n      });\n    }\n\n    runtimeMaterialsByName[material.name] = modelMaterial;\n    runtimeMaterialsById[materialId] = modelMaterial;\n  });\n  model._runtime.materialsByName = runtimeMaterialsByName;\n  model._runtime.materialsById = runtimeMaterialsById;\n}\n\nfunction parseMeshes(model) {\n  var runtimeMeshesByName = {};\n  var runtimeMaterialsById = model._runtime.materialsById;\n  ForEach.mesh(model.gltf, function (mesh, meshId) {\n    runtimeMeshesByName[mesh.name] = new ModelMesh(mesh, runtimeMaterialsById, meshId);\n\n    if (defined(model.extensionsUsed.WEB3D_quantized_attributes) || model._dequantizeInShader) {\n      // Cache primitives according to their program\n      ForEach.meshPrimitive(mesh, function (primitive, primitiveId) {\n        var programId = getProgramForPrimitive(model, primitive);\n        var programPrimitives = model._programPrimitives[programId];\n\n        if (!defined(programPrimitives)) {\n          programPrimitives = {};\n          model._programPrimitives[programId] = programPrimitives;\n        }\n\n        programPrimitives[meshId + \".primitive.\" + primitiveId] = primitive;\n      });\n    }\n  });\n  model._runtime.meshesByName = runtimeMeshesByName;\n} ///////////////////////////////////////////////////////////////////////////\n\n\nvar CreateVertexBufferJob = function () {\n  this.id = undefined;\n  this.model = undefined;\n  this.context = undefined;\n};\n\nCreateVertexBufferJob.prototype.set = function (id, model, context) {\n  this.id = id;\n  this.model = model;\n  this.context = context;\n};\n\nCreateVertexBufferJob.prototype.execute = function () {\n  createVertexBuffer(this.id, this.model, this.context);\n}; ///////////////////////////////////////////////////////////////////////////\n\n\nfunction createVertexBuffer(bufferViewId, model, context) {\n  var loadResources = model._loadResources;\n  var bufferViews = model.gltf.bufferViews;\n  var bufferView = bufferViews[bufferViewId]; // Use bufferView created at runtime\n\n  if (!defined(bufferView)) {\n    bufferView = loadResources.createdBufferViews[bufferViewId];\n  }\n\n  var vertexBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: loadResources.getBuffer(bufferView),\n    usage: BufferUsage.STATIC_DRAW\n  });\n  vertexBuffer.vertexArrayDestroyable = false;\n  model._rendererResources.buffers[bufferViewId] = vertexBuffer;\n  model._geometryByteLength += vertexBuffer.sizeInBytes;\n} ///////////////////////////////////////////////////////////////////////////\n\n\nvar CreateIndexBufferJob = function () {\n  this.id = undefined;\n  this.componentType = undefined;\n  this.model = undefined;\n  this.context = undefined;\n};\n\nCreateIndexBufferJob.prototype.set = function (id, componentType, model, context) {\n  this.id = id;\n  this.componentType = componentType;\n  this.model = model;\n  this.context = context;\n};\n\nCreateIndexBufferJob.prototype.execute = function () {\n  createIndexBuffer(this.id, this.componentType, this.model, this.context);\n}; ///////////////////////////////////////////////////////////////////////////\n\n\nfunction createIndexBuffer(bufferViewId, componentType, model, context) {\n  var loadResources = model._loadResources;\n  var bufferViews = model.gltf.bufferViews;\n  var bufferView = bufferViews[bufferViewId]; // Use bufferView created at runtime\n\n  if (!defined(bufferView)) {\n    bufferView = loadResources.createdBufferViews[bufferViewId];\n  }\n\n  var indexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: loadResources.getBuffer(bufferView),\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: componentType\n  });\n  indexBuffer.vertexArrayDestroyable = false;\n  model._rendererResources.buffers[bufferViewId] = indexBuffer;\n  model._geometryByteLength += indexBuffer.sizeInBytes;\n}\n\nvar scratchVertexBufferJob = new CreateVertexBufferJob();\nvar scratchIndexBufferJob = new CreateIndexBufferJob();\n\nfunction createBuffers(model, frameState) {\n  var loadResources = model._loadResources;\n\n  if (loadResources.pendingBufferLoads !== 0) {\n    return;\n  }\n\n  var context = frameState.context;\n  var vertexBuffersToCreate = loadResources.vertexBuffersToCreate;\n  var indexBuffersToCreate = loadResources.indexBuffersToCreate;\n  var i;\n\n  if (model.asynchronous) {\n    while (vertexBuffersToCreate.length > 0) {\n      scratchVertexBufferJob.set(vertexBuffersToCreate.peek(), model, context);\n\n      if (!frameState.jobScheduler.execute(scratchVertexBufferJob, JobType.BUFFER)) {\n        break;\n      }\n\n      vertexBuffersToCreate.dequeue();\n    }\n\n    while (indexBuffersToCreate.length > 0) {\n      i = indexBuffersToCreate.peek();\n      scratchIndexBufferJob.set(i.id, i.componentType, model, context);\n\n      if (!frameState.jobScheduler.execute(scratchIndexBufferJob, JobType.BUFFER)) {\n        break;\n      }\n\n      indexBuffersToCreate.dequeue();\n    }\n  } else {\n    while (vertexBuffersToCreate.length > 0) {\n      createVertexBuffer(vertexBuffersToCreate.dequeue(), model, context);\n    }\n\n    while (indexBuffersToCreate.length > 0) {\n      i = indexBuffersToCreate.dequeue();\n      createIndexBuffer(i.id, i.componentType, model, context);\n    }\n  }\n}\n\nfunction getProgramForPrimitive(model, primitive) {\n  var material = model._runtime.materialsById[primitive.material];\n\n  if (!defined(material)) {\n    return;\n  }\n\n  return material._program;\n}\n\nfunction modifyShaderForQuantizedAttributes(shader, programName, model) {\n  var primitive;\n  var primitives = model._programPrimitives[programName]; // If no primitives were cached for this program, there's no need to modify the shader\n\n  if (!defined(primitives)) {\n    return shader;\n  }\n\n  var primitiveId;\n\n  for (primitiveId in primitives) {\n    if (primitives.hasOwnProperty(primitiveId)) {\n      primitive = primitives[primitiveId];\n\n      if (getProgramForPrimitive(model, primitive) === programName) {\n        break;\n      }\n    }\n  } // This is not needed after the program is processed, free the memory\n\n\n  model._programPrimitives[programName] = undefined;\n  var result;\n\n  if (model.extensionsUsed.WEB3D_quantized_attributes) {\n    result = ModelUtility.modifyShaderForQuantizedAttributes(model.gltf, primitive, shader);\n    model._quantizedUniforms[programName] = result.uniforms;\n  } else {\n    var decodedData = model._decodedData[primitiveId];\n\n    if (defined(decodedData)) {\n      result = ModelUtility.modifyShaderForDracoQuantizedAttributes(model.gltf, primitive, shader, decodedData.attributes);\n    } else {\n      return shader;\n    }\n  }\n\n  return result.shader;\n}\n\nfunction modifyShaderForColor(shader) {\n  shader = ShaderSource.replaceMain(shader, \"gltf_blend_main\");\n  shader += \"uniform vec4 gltf_color; \\n\" + \"uniform float gltf_colorBlend; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    gltf_blend_main(); \\n\" + \"    gl_FragColor.rgb = mix(gl_FragColor.rgb, gltf_color.rgb, gltf_colorBlend); \\n\" + \"    float highlight = ceil(gltf_colorBlend); \\n\" + \"    gl_FragColor.rgb *= mix(gltf_color.rgb, vec3(1.0), highlight); \\n\" + \"    gl_FragColor.a *= gltf_color.a; \\n\" + \"} \\n\";\n  return shader;\n}\n\nfunction modifyShader(shader, programName, callback) {\n  if (defined(callback)) {\n    shader = callback(shader, programName);\n  }\n\n  return shader;\n}\n\nvar CreateProgramJob = function () {\n  this.programToCreate = undefined;\n  this.model = undefined;\n  this.context = undefined;\n};\n\nCreateProgramJob.prototype.set = function (programToCreate, model, context) {\n  this.programToCreate = programToCreate;\n  this.model = model;\n  this.context = context;\n};\n\nCreateProgramJob.prototype.execute = function () {\n  createProgram(this.programToCreate, this.model, this.context);\n}; ///////////////////////////////////////////////////////////////////////////\n// When building programs for the first time, do not include modifiers for clipping planes and color\n// since this is the version of the program that will be cached for use with other Models.\n\n\nfunction createProgram(programToCreate, model, context) {\n  var programId = programToCreate.programId;\n  var techniqueId = programToCreate.techniqueId;\n  var program = model._sourcePrograms[programId];\n  var shaders = model._rendererResources.sourceShaders;\n  var vs = shaders[program.vertexShader];\n  var fs = shaders[program.fragmentShader];\n  var quantizedVertexShaders = model._quantizedVertexShaders;\n  var toClipCoordinatesGLSL = model._toClipCoordinatesGLSL[programId];\n\n  if (model.extensionsUsed.WEB3D_quantized_attributes || model._dequantizeInShader) {\n    var quantizedVS = quantizedVertexShaders[programId];\n\n    if (!defined(quantizedVS)) {\n      quantizedVS = modifyShaderForQuantizedAttributes(vs, programId, model);\n      quantizedVertexShaders[programId] = quantizedVS;\n    }\n\n    vs = quantizedVS;\n  }\n\n  var drawVS = modifyShader(vs, programId, model._vertexShaderLoaded);\n  var drawFS = modifyShader(fs, programId, model._fragmentShaderLoaded); // Internet Explorer seems to have problems with discard (for clipping planes) after too many levels of indirection:\n  // https://github.com/CesiumGS/cesium/issues/6575.\n  // For IE log depth code is defined out anyway due to unsupported WebGL extensions, so the wrappers can be omitted.\n\n  if (!FeatureDetection.isInternetExplorer()) {\n    drawVS = ModelUtility.modifyVertexShaderForLogDepth(drawVS, toClipCoordinatesGLSL);\n    drawFS = ModelUtility.modifyFragmentShaderForLogDepth(drawFS);\n  }\n\n  if (!defined(model._uniformMapLoaded)) {\n    drawFS = \"uniform vec4 czm_pickColor;\\n\" + drawFS;\n  }\n\n  var useIBL = model._imageBasedLightingFactor.x > 0.0 || model._imageBasedLightingFactor.y > 0.0;\n\n  if (useIBL) {\n    drawFS = \"#define USE_IBL_LIGHTING \\n\\n\" + drawFS;\n  }\n\n  if (defined(model._lightColor)) {\n    drawFS = \"#define USE_CUSTOM_LIGHT_COLOR \\n\\n\" + drawFS;\n  }\n\n  if (model._sourceVersion !== \"2.0\" || model._sourceKHRTechniquesWebGL) {\n    drawFS = ShaderSource.replaceMain(drawFS, \"non_gamma_corrected_main\");\n    drawFS = drawFS + \"\\n\" + \"void main() { \\n\" + \"    non_gamma_corrected_main(); \\n\" + \"    gl_FragColor = czm_gammaCorrect(gl_FragColor); \\n\" + \"} \\n\";\n  }\n\n  if (OctahedralProjectedCubeMap.isSupported(context)) {\n    var usesSH = defined(model._sphericalHarmonicCoefficients) || model._useDefaultSphericalHarmonics;\n\n    var usesSM = defined(model._specularEnvironmentMapAtlas) && model._specularEnvironmentMapAtlas.ready || model._useDefaultSpecularMaps;\n\n    var addMatrix = usesSH || usesSM || useIBL;\n\n    if (addMatrix) {\n      drawFS = \"uniform mat4 gltf_clippingPlanesMatrix; \\n\" + drawFS;\n    }\n\n    if (defined(model._sphericalHarmonicCoefficients)) {\n      drawFS = \"#define DIFFUSE_IBL \\n\" + \"#define CUSTOM_SPHERICAL_HARMONICS \\n\" + \"uniform vec3 gltf_sphericalHarmonicCoefficients[9]; \\n\" + drawFS;\n    } else if (model._useDefaultSphericalHarmonics) {\n      drawFS = \"#define DIFFUSE_IBL \\n\" + drawFS;\n    }\n\n    if (defined(model._specularEnvironmentMapAtlas) && model._specularEnvironmentMapAtlas.ready) {\n      drawFS = \"#define SPECULAR_IBL \\n\" + \"#define CUSTOM_SPECULAR_IBL \\n\" + \"uniform sampler2D gltf_specularMap; \\n\" + \"uniform vec2 gltf_specularMapSize; \\n\" + \"uniform float gltf_maxSpecularLOD; \\n\" + drawFS;\n    } else if (model._useDefaultSpecularMaps) {\n      drawFS = \"#define SPECULAR_IBL \\n\" + drawFS;\n    }\n  }\n\n  if (defined(model._luminanceAtZenith)) {\n    drawFS = \"#define USE_SUN_LUMINANCE \\n\" + \"uniform float gltf_luminanceAtZenith;\\n\" + drawFS;\n  }\n\n  createAttributesAndProgram(programId, techniqueId, drawFS, drawVS, model, context);\n}\n\nfunction recreateProgram(programToCreate, model, context) {\n  var programId = programToCreate.programId;\n  var techniqueId = programToCreate.techniqueId;\n  var program = model._sourcePrograms[programId];\n  var shaders = model._rendererResources.sourceShaders;\n  var quantizedVertexShaders = model._quantizedVertexShaders;\n  var toClipCoordinatesGLSL = model._toClipCoordinatesGLSL[programId];\n  var clippingPlaneCollection = model.clippingPlanes;\n  var addClippingPlaneCode = isClippingEnabled(model);\n  var vs = shaders[program.vertexShader];\n  var fs = shaders[program.fragmentShader];\n\n  if (model.extensionsUsed.WEB3D_quantized_attributes || model._dequantizeInShader) {\n    vs = quantizedVertexShaders[programId];\n  }\n\n  var finalFS = fs;\n\n  if (isColorShadingEnabled(model)) {\n    finalFS = Model._modifyShaderForColor(finalFS);\n  }\n\n  if (addClippingPlaneCode) {\n    finalFS = modifyShaderForClippingPlanes(finalFS, clippingPlaneCollection, context);\n  }\n\n  var drawVS = modifyShader(vs, programId, model._vertexShaderLoaded);\n  var drawFS = modifyShader(finalFS, programId, model._fragmentShaderLoaded);\n\n  if (!FeatureDetection.isInternetExplorer()) {\n    drawVS = ModelUtility.modifyVertexShaderForLogDepth(drawVS, toClipCoordinatesGLSL);\n    drawFS = ModelUtility.modifyFragmentShaderForLogDepth(drawFS);\n  }\n\n  if (!defined(model._uniformMapLoaded)) {\n    drawFS = \"uniform vec4 czm_pickColor;\\n\" + drawFS;\n  }\n\n  var useIBL = model._imageBasedLightingFactor.x > 0.0 || model._imageBasedLightingFactor.y > 0.0;\n\n  if (useIBL) {\n    drawFS = \"#define USE_IBL_LIGHTING \\n\\n\" + drawFS;\n  }\n\n  if (defined(model._lightColor)) {\n    drawFS = \"#define USE_CUSTOM_LIGHT_COLOR \\n\\n\" + drawFS;\n  }\n\n  if (model._sourceVersion !== \"2.0\" || model._sourceKHRTechniquesWebGL) {\n    drawFS = ShaderSource.replaceMain(drawFS, \"non_gamma_corrected_main\");\n    drawFS = drawFS + \"\\n\" + \"void main() { \\n\" + \"    non_gamma_corrected_main(); \\n\" + \"    gl_FragColor = czm_gammaCorrect(gl_FragColor); \\n\" + \"} \\n\";\n  }\n\n  if (OctahedralProjectedCubeMap.isSupported(context)) {\n    var usesSH = defined(model._sphericalHarmonicCoefficients) || model._useDefaultSphericalHarmonics;\n\n    var usesSM = defined(model._specularEnvironmentMapAtlas) && model._specularEnvironmentMapAtlas.ready || model._useDefaultSpecularMaps;\n\n    var addMatrix = !addClippingPlaneCode && (usesSH || usesSM || useIBL);\n\n    if (addMatrix) {\n      drawFS = \"uniform mat4 gltf_clippingPlanesMatrix; \\n\" + drawFS;\n    }\n\n    if (defined(model._sphericalHarmonicCoefficients)) {\n      drawFS = \"#define DIFFUSE_IBL \\n\" + \"#define CUSTOM_SPHERICAL_HARMONICS \\n\" + \"uniform vec3 gltf_sphericalHarmonicCoefficients[9]; \\n\" + drawFS;\n    } else if (model._useDefaultSphericalHarmonics) {\n      drawFS = \"#define DIFFUSE_IBL \\n\" + drawFS;\n    }\n\n    if (defined(model._specularEnvironmentMapAtlas) && model._specularEnvironmentMapAtlas.ready) {\n      drawFS = \"#define SPECULAR_IBL \\n\" + \"#define CUSTOM_SPECULAR_IBL \\n\" + \"uniform sampler2D gltf_specularMap; \\n\" + \"uniform vec2 gltf_specularMapSize; \\n\" + \"uniform float gltf_maxSpecularLOD; \\n\" + drawFS;\n    } else if (model._useDefaultSpecularMaps) {\n      drawFS = \"#define SPECULAR_IBL \\n\" + drawFS;\n    }\n  }\n\n  if (defined(model._luminanceAtZenith)) {\n    drawFS = \"#define USE_SUN_LUMINANCE \\n\" + \"uniform float gltf_luminanceAtZenith;\\n\" + drawFS;\n  }\n\n  createAttributesAndProgram(programId, techniqueId, drawFS, drawVS, model, context);\n}\n\nfunction createAttributesAndProgram(programId, techniqueId, drawFS, drawVS, model, context) {\n  var technique = model._sourceTechniques[techniqueId];\n  var attributeLocations = ModelUtility.createAttributeLocations(technique, model._precreatedAttributes);\n  model._rendererResources.programs[programId] = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: drawVS,\n    fragmentShaderSource: drawFS,\n    attributeLocations: attributeLocations\n  });\n}\n\nvar scratchCreateProgramJob = new CreateProgramJob();\n\nfunction createPrograms(model, frameState) {\n  var loadResources = model._loadResources;\n  var programsToCreate = loadResources.programsToCreate;\n\n  if (loadResources.pendingShaderLoads !== 0) {\n    return;\n  } // PERFORMANCE_IDEA: this could be more fine-grained by looking\n  // at the shader's bufferView's to determine the buffer dependencies.\n\n\n  if (loadResources.pendingBufferLoads !== 0) {\n    return;\n  }\n\n  var context = frameState.context;\n\n  if (model.asynchronous) {\n    while (programsToCreate.length > 0) {\n      scratchCreateProgramJob.set(programsToCreate.peek(), model, context);\n\n      if (!frameState.jobScheduler.execute(scratchCreateProgramJob, JobType.PROGRAM)) {\n        break;\n      }\n\n      programsToCreate.dequeue();\n    }\n  } else {\n    // Create all loaded programs this frame\n    while (programsToCreate.length > 0) {\n      createProgram(programsToCreate.dequeue(), model, context);\n    }\n  }\n}\n\nfunction getOnImageCreatedFromTypedArray(loadResources, gltfTexture) {\n  return function (image) {\n    loadResources.texturesToCreate.enqueue({\n      id: gltfTexture.id,\n      image: image,\n      bufferView: undefined\n    });\n    --loadResources.pendingBufferViewToImage;\n  };\n}\n\nfunction loadTexturesFromBufferViews(model) {\n  var loadResources = model._loadResources;\n\n  if (loadResources.pendingBufferLoads !== 0) {\n    return;\n  }\n\n  while (loadResources.texturesToCreateFromBufferView.length > 0) {\n    var gltfTexture = loadResources.texturesToCreateFromBufferView.dequeue();\n    var gltf = model.gltf;\n    var bufferView = gltf.bufferViews[gltfTexture.bufferView];\n    var imageId = gltf.textures[gltfTexture.id].source;\n    var onerror = ModelUtility.getFailedLoadFunction(model, \"image\", \"id: \" + gltfTexture.id + \", bufferView: \" + gltfTexture.bufferView);\n\n    if (gltfTexture.mimeType === \"image/ktx\") {\n      loadKTX(loadResources.getBuffer(bufferView)).then(imageLoad(model, gltfTexture.id, imageId)).otherwise(onerror);\n      ++model._loadResources.pendingTextureLoads;\n    } else if (gltfTexture.mimeType === \"image/crn\") {\n      loadCRN(loadResources.getBuffer(bufferView)).then(imageLoad(model, gltfTexture.id, imageId)).otherwise(onerror);\n      ++model._loadResources.pendingTextureLoads;\n    } else {\n      var onload = getOnImageCreatedFromTypedArray(loadResources, gltfTexture);\n      loadImageFromTypedArray({\n        uint8Array: loadResources.getBuffer(bufferView),\n        format: gltfTexture.mimeType,\n        flipY: false\n      }).then(onload).otherwise(onerror);\n      ++loadResources.pendingBufferViewToImage;\n    }\n  }\n}\n\nfunction createSamplers(model) {\n  var loadResources = model._loadResources;\n\n  if (loadResources.createSamplers) {\n    loadResources.createSamplers = false;\n    var rendererSamplers = model._rendererResources.samplers;\n    ForEach.sampler(model.gltf, function (sampler, samplerId) {\n      rendererSamplers[samplerId] = new Sampler({\n        wrapS: sampler.wrapS,\n        wrapT: sampler.wrapT,\n        minificationFilter: sampler.minFilter,\n        magnificationFilter: sampler.magFilter\n      });\n    });\n  }\n} ///////////////////////////////////////////////////////////////////////////\n\n\nvar CreateTextureJob = function () {\n  this.gltfTexture = undefined;\n  this.model = undefined;\n  this.context = undefined;\n};\n\nCreateTextureJob.prototype.set = function (gltfTexture, model, context) {\n  this.gltfTexture = gltfTexture;\n  this.model = model;\n  this.context = context;\n};\n\nCreateTextureJob.prototype.execute = function () {\n  createTexture(this.gltfTexture, this.model, this.context);\n}; ///////////////////////////////////////////////////////////////////////////\n\n\nfunction createTexture(gltfTexture, model, context) {\n  var textures = model.gltf.textures;\n  var texture = textures[gltfTexture.id];\n  var rendererSamplers = model._rendererResources.samplers;\n  var sampler = rendererSamplers[texture.sampler];\n\n  if (!defined(sampler)) {\n    sampler = new Sampler({\n      wrapS: TextureWrap.REPEAT,\n      wrapT: TextureWrap.REPEAT\n    });\n  }\n\n  var usesTextureTransform = false;\n  var materials = model.gltf.materials;\n  var materialsLength = materials.length;\n\n  for (var i = 0; i < materialsLength; ++i) {\n    var material = materials[i];\n\n    if (defined(material.extensions) && defined(material.extensions.KHR_techniques_webgl)) {\n      var values = material.extensions.KHR_techniques_webgl.values;\n\n      for (var valueName in values) {\n        if (values.hasOwnProperty(valueName) && valueName.indexOf(\"Texture\") !== -1) {\n          var value = values[valueName];\n\n          if (value.index === gltfTexture.id && defined(value.extensions) && defined(value.extensions.KHR_texture_transform)) {\n            usesTextureTransform = true;\n            break;\n          }\n        }\n      }\n    }\n\n    if (usesTextureTransform) {\n      break;\n    }\n  }\n\n  var wrapS = sampler.wrapS;\n  var wrapT = sampler.wrapT;\n  var minFilter = sampler.minificationFilter;\n\n  if (usesTextureTransform && minFilter !== TextureMinificationFilter.LINEAR && minFilter !== TextureMinificationFilter.NEAREST) {\n    if (minFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST || minFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR) {\n      minFilter = TextureMinificationFilter.NEAREST;\n    } else {\n      minFilter = TextureMinificationFilter.LINEAR;\n    }\n\n    sampler = new Sampler({\n      wrapS: sampler.wrapS,\n      wrapT: sampler.wrapT,\n      textureMinificationFilter: minFilter,\n      textureMagnificationFilter: sampler.magnificationFilter\n    });\n  }\n\n  var internalFormat = gltfTexture.internalFormat;\n  var mipmap = !(defined(internalFormat) && PixelFormat.isCompressedFormat(internalFormat)) && (minFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST || minFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR || minFilter === TextureMinificationFilter.LINEAR_MIPMAP_NEAREST || minFilter === TextureMinificationFilter.LINEAR_MIPMAP_LINEAR);\n  var requiresNpot = mipmap || wrapS === TextureWrap.REPEAT || wrapS === TextureWrap.MIRRORED_REPEAT || wrapT === TextureWrap.REPEAT || wrapT === TextureWrap.MIRRORED_REPEAT;\n  var tx;\n  var source = gltfTexture.image;\n\n  if (defined(internalFormat)) {\n    tx = new Texture({\n      context: context,\n      source: {\n        arrayBufferView: gltfTexture.bufferView\n      },\n      width: gltfTexture.width,\n      height: gltfTexture.height,\n      pixelFormat: internalFormat,\n      sampler: sampler\n    });\n  } else if (defined(source)) {\n    var npot = !CesiumMath.isPowerOfTwo(source.width) || !CesiumMath.isPowerOfTwo(source.height);\n\n    if (requiresNpot && npot) {\n      // WebGL requires power-of-two texture dimensions for mipmapping and REPEAT/MIRRORED_REPEAT wrap modes.\n      var canvas = document.createElement(\"canvas\");\n      canvas.width = CesiumMath.nextPowerOfTwo(source.width);\n      canvas.height = CesiumMath.nextPowerOfTwo(source.height);\n      var canvasContext = canvas.getContext(\"2d\");\n      canvasContext.drawImage(source, 0, 0, source.width, source.height, 0, 0, canvas.width, canvas.height);\n      source = canvas;\n    }\n\n    tx = new Texture({\n      context: context,\n      source: source,\n      pixelFormat: texture.internalFormat,\n      pixelDatatype: texture.type,\n      sampler: sampler,\n      flipY: false\n    }); // GLTF_SPEC: Support TEXTURE_CUBE_MAP.  https://github.com/KhronosGroup/glTF/issues/40\n\n    if (mipmap) {\n      tx.generateMipmap();\n    }\n  }\n\n  if (defined(tx)) {\n    model._rendererResources.textures[gltfTexture.id] = tx;\n    model._texturesByteLength += tx.sizeInBytes;\n  }\n}\n\nvar scratchCreateTextureJob = new CreateTextureJob();\n\nfunction createTextures(model, frameState) {\n  var context = frameState.context;\n  var texturesToCreate = model._loadResources.texturesToCreate;\n\n  if (model.asynchronous) {\n    while (texturesToCreate.length > 0) {\n      scratchCreateTextureJob.set(texturesToCreate.peek(), model, context);\n\n      if (!frameState.jobScheduler.execute(scratchCreateTextureJob, JobType.TEXTURE)) {\n        break;\n      }\n\n      texturesToCreate.dequeue();\n    }\n  } else {\n    // Create all loaded textures this frame\n    while (texturesToCreate.length > 0) {\n      createTexture(texturesToCreate.dequeue(), model, context);\n    }\n  }\n}\n\nfunction getAttributeLocations(model, primitive) {\n  var techniques = model._sourceTechniques; // Retrieve the compiled shader program to assign index values to attributes\n\n  var attributeLocations = {};\n  var location;\n  var index;\n  var material = model._runtime.materialsById[primitive.material];\n\n  if (!defined(material)) {\n    return attributeLocations;\n  }\n\n  var technique = techniques[material._technique];\n\n  if (!defined(technique)) {\n    return attributeLocations;\n  }\n\n  var attributes = technique.attributes;\n  var program = model._rendererResources.programs[technique.program];\n  var programVertexAttributes = program.vertexAttributes;\n  var programAttributeLocations = program._attributeLocations; // Note: WebGL shader compiler may have optimized and removed some attributes from programVertexAttributes\n\n  for (location in programVertexAttributes) {\n    if (programVertexAttributes.hasOwnProperty(location)) {\n      var attribute = attributes[location];\n\n      if (defined(attribute)) {\n        index = programAttributeLocations[location];\n        attributeLocations[attribute.semantic] = index;\n      }\n    }\n  } // Always add pre-created attributes.\n  // Some pre-created attributes, like per-instance pickIds, may be compiled out of the draw program\n  // but should be included in the list of attribute locations for the pick program.\n  // This is safe to do since programVertexAttributes and programAttributeLocations are equivalent except\n  // that programVertexAttributes optimizes out unused attributes.\n\n\n  var precreatedAttributes = model._precreatedAttributes;\n\n  if (defined(precreatedAttributes)) {\n    for (location in precreatedAttributes) {\n      if (precreatedAttributes.hasOwnProperty(location)) {\n        index = programAttributeLocations[location];\n        attributeLocations[location] = index;\n      }\n    }\n  }\n\n  return attributeLocations;\n}\n\nfunction createJoints(model, runtimeSkins) {\n  var gltf = model.gltf;\n  var skins = gltf.skins;\n  var nodes = gltf.nodes;\n  var runtimeNodes = model._runtime.nodes;\n  var skinnedNodesIds = model._loadResources.skinnedNodesIds;\n  var length = skinnedNodesIds.length;\n\n  for (var j = 0; j < length; ++j) {\n    var id = skinnedNodesIds[j];\n    var skinnedNode = runtimeNodes[id];\n    var node = nodes[id];\n    var runtimeSkin = runtimeSkins[node.skin];\n    skinnedNode.inverseBindMatrices = runtimeSkin.inverseBindMatrices;\n    skinnedNode.bindShapeMatrix = runtimeSkin.bindShapeMatrix;\n    var gltfJoints = skins[node.skin].joints;\n    var jointsLength = gltfJoints.length;\n\n    for (var i = 0; i < jointsLength; ++i) {\n      var nodeId = gltfJoints[i];\n      var jointNode = runtimeNodes[nodeId];\n      skinnedNode.joints.push(jointNode);\n    }\n  }\n}\n\nfunction createSkins(model) {\n  var loadResources = model._loadResources;\n\n  if (loadResources.pendingBufferLoads !== 0) {\n    return;\n  }\n\n  if (!loadResources.createSkins) {\n    return;\n  }\n\n  loadResources.createSkins = false;\n  var gltf = model.gltf;\n  var accessors = gltf.accessors;\n  var runtimeSkins = {};\n  ForEach.skin(gltf, function (skin, id) {\n    var accessor = accessors[skin.inverseBindMatrices];\n    var bindShapeMatrix;\n\n    if (!Matrix4.equals(skin.bindShapeMatrix, Matrix4.IDENTITY)) {\n      bindShapeMatrix = Matrix4.clone(skin.bindShapeMatrix);\n    }\n\n    runtimeSkins[id] = {\n      inverseBindMatrices: ModelAnimationCache.getSkinInverseBindMatrices(model, accessor),\n      bindShapeMatrix: bindShapeMatrix // not used when undefined\n\n    };\n  });\n  createJoints(model, runtimeSkins);\n}\n\nfunction getChannelEvaluator(model, runtimeNode, targetPath, spline) {\n  return function (localAnimationTime) {\n    if (defined(spline)) {\n      localAnimationTime = model.clampAnimations ? spline.clampTime(localAnimationTime) : spline.wrapTime(localAnimationTime);\n      runtimeNode[targetPath] = spline.evaluate(localAnimationTime, runtimeNode[targetPath]);\n      runtimeNode.dirtyNumber = model._maxDirtyNumber;\n    }\n  };\n}\n\nfunction createRuntimeAnimations(model) {\n  var loadResources = model._loadResources;\n\n  if (!loadResources.finishedPendingBufferLoads()) {\n    return;\n  }\n\n  if (!loadResources.createRuntimeAnimations) {\n    return;\n  }\n\n  loadResources.createRuntimeAnimations = false;\n  model._runtime.animations = [];\n  var runtimeNodes = model._runtime.nodes;\n  var accessors = model.gltf.accessors;\n  ForEach.animation(model.gltf, function (animation, i) {\n    var channels = animation.channels;\n    var samplers = animation.samplers; // Find start and stop time for the entire animation\n\n    var startTime = Number.MAX_VALUE;\n    var stopTime = -Number.MAX_VALUE;\n    var channelsLength = channels.length;\n    var channelEvaluators = new Array(channelsLength);\n\n    for (var j = 0; j < channelsLength; ++j) {\n      var channel = channels[j];\n      var target = channel.target;\n      var path = target.path;\n      var sampler = samplers[channel.sampler];\n      var input = ModelAnimationCache.getAnimationParameterValues(model, accessors[sampler.input]);\n      var output = ModelAnimationCache.getAnimationParameterValues(model, accessors[sampler.output]);\n      startTime = Math.min(startTime, input[0]);\n      stopTime = Math.max(stopTime, input[input.length - 1]);\n      var spline = ModelAnimationCache.getAnimationSpline(model, i, animation, channel.sampler, sampler, input, path, output);\n      channelEvaluators[j] = getChannelEvaluator(model, runtimeNodes[target.node], target.path, spline);\n    }\n\n    model._runtime.animations[i] = {\n      name: animation.name,\n      startTime: startTime,\n      stopTime: stopTime,\n      channelEvaluators: channelEvaluators\n    };\n  });\n}\n\nfunction createVertexArrays(model, context) {\n  var loadResources = model._loadResources;\n\n  if (!loadResources.finishedBuffersCreation() || !loadResources.finishedProgramCreation() || !loadResources.createVertexArrays) {\n    return;\n  }\n\n  loadResources.createVertexArrays = false;\n  var rendererBuffers = model._rendererResources.buffers;\n  var rendererVertexArrays = model._rendererResources.vertexArrays;\n  var gltf = model.gltf;\n  var accessors = gltf.accessors;\n  ForEach.mesh(gltf, function (mesh, meshId) {\n    ForEach.meshPrimitive(mesh, function (primitive, primitiveId) {\n      var attributes = [];\n      var attributeLocation;\n      var attributeLocations = getAttributeLocations(model, primitive);\n      var decodedData = model._decodedData[meshId + \".primitive.\" + primitiveId];\n      ForEach.meshPrimitiveAttribute(primitive, function (accessorId, attributeName) {\n        // Skip if the attribute is not used by the material, e.g., because the asset\n        // was exported with an attribute that wasn't used and the asset wasn't optimized.\n        attributeLocation = attributeLocations[attributeName];\n\n        if (defined(attributeLocation)) {\n          // Use attributes of previously decoded draco geometry\n          if (defined(decodedData)) {\n            var decodedAttributes = decodedData.attributes;\n\n            if (decodedAttributes.hasOwnProperty(attributeName)) {\n              var decodedAttribute = decodedAttributes[attributeName];\n              attributes.push({\n                index: attributeLocation,\n                vertexBuffer: rendererBuffers[decodedAttribute.bufferView],\n                componentsPerAttribute: decodedAttribute.componentsPerAttribute,\n                componentDatatype: decodedAttribute.componentDatatype,\n                normalize: decodedAttribute.normalized,\n                offsetInBytes: decodedAttribute.byteOffset,\n                strideInBytes: decodedAttribute.byteStride\n              });\n              return;\n            }\n          }\n\n          var a = accessors[accessorId];\n          var normalize = defined(a.normalized) && a.normalized;\n          attributes.push({\n            index: attributeLocation,\n            vertexBuffer: rendererBuffers[a.bufferView],\n            componentsPerAttribute: numberOfComponentsForType(a.type),\n            componentDatatype: a.componentType,\n            normalize: normalize,\n            offsetInBytes: a.byteOffset,\n            strideInBytes: getAccessorByteStride(gltf, a)\n          });\n        }\n      }); // Add pre-created attributes\n\n      var attribute;\n      var attributeName;\n      var precreatedAttributes = model._precreatedAttributes;\n\n      if (defined(precreatedAttributes)) {\n        for (attributeName in precreatedAttributes) {\n          if (precreatedAttributes.hasOwnProperty(attributeName)) {\n            attributeLocation = attributeLocations[attributeName];\n\n            if (defined(attributeLocation)) {\n              attribute = precreatedAttributes[attributeName];\n              attribute.index = attributeLocation;\n              attributes.push(attribute);\n            }\n          }\n        }\n      }\n\n      var indexBuffer;\n\n      if (defined(primitive.indices)) {\n        var accessor = accessors[primitive.indices];\n        var bufferView = accessor.bufferView; // Use buffer of previously decoded draco geometry\n\n        if (defined(decodedData)) {\n          bufferView = decodedData.bufferView;\n        }\n\n        indexBuffer = rendererBuffers[bufferView];\n      }\n\n      rendererVertexArrays[meshId + \".primitive.\" + primitiveId] = new VertexArray({\n        context: context,\n        attributes: attributes,\n        indexBuffer: indexBuffer\n      });\n    });\n  });\n}\n\nfunction createRenderStates(model) {\n  var loadResources = model._loadResources;\n\n  if (loadResources.createRenderStates) {\n    loadResources.createRenderStates = false;\n    ForEach.material(model.gltf, function (material, materialId) {\n      createRenderStateForMaterial(model, material, materialId);\n    });\n  }\n}\n\nfunction createRenderStateForMaterial(model, material, materialId) {\n  var rendererRenderStates = model._rendererResources.renderStates;\n  var blendEquationSeparate = [WebGLConstants.FUNC_ADD, WebGLConstants.FUNC_ADD];\n  var blendFuncSeparate = [WebGLConstants.ONE, WebGLConstants.ONE_MINUS_SRC_ALPHA, WebGLConstants.ONE, WebGLConstants.ONE_MINUS_SRC_ALPHA];\n\n  if (defined(material.extensions) && defined(material.extensions.KHR_blend)) {\n    blendEquationSeparate = material.extensions.KHR_blend.blendEquation;\n    blendFuncSeparate = material.extensions.KHR_blend.blendFactors;\n  }\n\n  var enableCulling = !material.doubleSided;\n  var blendingEnabled = material.alphaMode === \"BLEND\";\n  rendererRenderStates[materialId] = RenderState.fromCache({\n    cull: {\n      enabled: enableCulling\n    },\n    depthTest: {\n      enabled: true,\n      func: DepthFunction.LESS_OR_EQUAL\n    },\n    depthMask: !blendingEnabled,\n    blending: {\n      enabled: blendingEnabled,\n      equationRgb: blendEquationSeparate[0],\n      equationAlpha: blendEquationSeparate[1],\n      functionSourceRgb: blendFuncSeparate[0],\n      functionDestinationRgb: blendFuncSeparate[1],\n      functionSourceAlpha: blendFuncSeparate[2],\n      functionDestinationAlpha: blendFuncSeparate[3]\n    }\n  });\n} ///////////////////////////////////////////////////////////////////////////\n\n\nvar gltfUniformsFromNode = {\n  MODEL: function (uniformState, model, runtimeNode) {\n    return function () {\n      return runtimeNode.computedMatrix;\n    };\n  },\n  VIEW: function (uniformState, model, runtimeNode) {\n    return function () {\n      return uniformState.view;\n    };\n  },\n  PROJECTION: function (uniformState, model, runtimeNode) {\n    return function () {\n      return uniformState.projection;\n    };\n  },\n  MODELVIEW: function (uniformState, model, runtimeNode) {\n    var mv = new Matrix4();\n    return function () {\n      return Matrix4.multiplyTransformation(uniformState.view, runtimeNode.computedMatrix, mv);\n    };\n  },\n  CESIUM_RTC_MODELVIEW: function (uniformState, model, runtimeNode) {\n    // CESIUM_RTC extension\n    var mvRtc = new Matrix4();\n    return function () {\n      Matrix4.multiplyTransformation(uniformState.view, runtimeNode.computedMatrix, mvRtc);\n      return Matrix4.setTranslation(mvRtc, model._rtcCenterEye, mvRtc);\n    };\n  },\n  MODELVIEWPROJECTION: function (uniformState, model, runtimeNode) {\n    var mvp = new Matrix4();\n    return function () {\n      Matrix4.multiplyTransformation(uniformState.view, runtimeNode.computedMatrix, mvp);\n      return Matrix4.multiply(uniformState._projection, mvp, mvp);\n    };\n  },\n  MODELINVERSE: function (uniformState, model, runtimeNode) {\n    var mInverse = new Matrix4();\n    return function () {\n      return Matrix4.inverse(runtimeNode.computedMatrix, mInverse);\n    };\n  },\n  VIEWINVERSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseView;\n    };\n  },\n  PROJECTIONINVERSE: function (uniformState, model, runtimeNode) {\n    return function () {\n      return uniformState.inverseProjection;\n    };\n  },\n  MODELVIEWINVERSE: function (uniformState, model, runtimeNode) {\n    var mv = new Matrix4();\n    var mvInverse = new Matrix4();\n    return function () {\n      Matrix4.multiplyTransformation(uniformState.view, runtimeNode.computedMatrix, mv);\n      return Matrix4.inverse(mv, mvInverse);\n    };\n  },\n  MODELVIEWPROJECTIONINVERSE: function (uniformState, model, runtimeNode) {\n    var mvp = new Matrix4();\n    var mvpInverse = new Matrix4();\n    return function () {\n      Matrix4.multiplyTransformation(uniformState.view, runtimeNode.computedMatrix, mvp);\n      Matrix4.multiply(uniformState._projection, mvp, mvp);\n      return Matrix4.inverse(mvp, mvpInverse);\n    };\n  },\n  MODELINVERSETRANSPOSE: function (uniformState, model, runtimeNode) {\n    var mInverse = new Matrix4();\n    var mInverseTranspose = new Matrix3();\n    return function () {\n      Matrix4.inverse(runtimeNode.computedMatrix, mInverse);\n      Matrix4.getMatrix3(mInverse, mInverseTranspose);\n      return Matrix3.transpose(mInverseTranspose, mInverseTranspose);\n    };\n  },\n  MODELVIEWINVERSETRANSPOSE: function (uniformState, model, runtimeNode) {\n    var mv = new Matrix4();\n    var mvInverse = new Matrix4();\n    var mvInverseTranspose = new Matrix3();\n    return function () {\n      Matrix4.multiplyTransformation(uniformState.view, runtimeNode.computedMatrix, mv);\n      Matrix4.inverse(mv, mvInverse);\n      Matrix4.getMatrix3(mvInverse, mvInverseTranspose);\n      return Matrix3.transpose(mvInverseTranspose, mvInverseTranspose);\n    };\n  },\n  VIEWPORT: function (uniformState, model, runtimeNode) {\n    return function () {\n      return uniformState.viewportCartesian4;\n    };\n  }\n};\n\nfunction getUniformFunctionFromSource(source, model, semantic, uniformState) {\n  var runtimeNode = model._runtime.nodes[source];\n  return gltfUniformsFromNode[semantic](uniformState, model, runtimeNode);\n}\n\nfunction createUniformsForMaterial(model, material, technique, instanceValues, context, textures, defaultTexture) {\n  var uniformMap = {};\n  var uniformValues = {};\n  var jointMatrixUniformName;\n  var morphWeightsUniformName;\n  ForEach.techniqueUniform(technique, function (uniform, uniformName) {\n    // GLTF_SPEC: This does not take into account uniform arrays,\n    // indicated by uniforms with a count property.\n    //\n    // https://github.com/KhronosGroup/glTF/issues/258\n    // GLTF_SPEC: In this implementation, material parameters with a\n    // semantic or targeted via a source (for animation) are not\n    // targetable for material animations.  Is this too strict?\n    //\n    // https://github.com/KhronosGroup/glTF/issues/142\n    var uv;\n\n    if (defined(instanceValues) && defined(instanceValues[uniformName])) {\n      // Parameter overrides by the instance technique\n      uv = ModelUtility.createUniformFunction(uniform.type, instanceValues[uniformName], textures, defaultTexture);\n      uniformMap[uniformName] = uv.func;\n      uniformValues[uniformName] = uv;\n    } else if (defined(uniform.node)) {\n      uniformMap[uniformName] = getUniformFunctionFromSource(uniform.node, model, uniform.semantic, context.uniformState);\n    } else if (defined(uniform.semantic)) {\n      if (uniform.semantic === \"JOINTMATRIX\") {\n        jointMatrixUniformName = uniformName;\n      } else if (uniform.semantic === \"MORPHWEIGHTS\") {\n        morphWeightsUniformName = uniformName;\n      } else if (uniform.semantic === \"ALPHACUTOFF\") {\n        // The material's alphaCutoff value uses a uniform with semantic ALPHACUTOFF.\n        // A uniform with this semantic will ignore the instance or default values.\n        var alphaMode = material.alphaMode;\n\n        if (defined(alphaMode) && alphaMode === \"MASK\") {\n          var alphaCutoffValue = defaultValue(material.alphaCutoff, 0.5);\n          uv = ModelUtility.createUniformFunction(uniform.type, alphaCutoffValue, textures, defaultTexture);\n          uniformMap[uniformName] = uv.func;\n          uniformValues[uniformName] = uv;\n        }\n      } else {\n        // Map glTF semantic to Cesium automatic uniform\n        uniformMap[uniformName] = ModelUtility.getGltfSemanticUniforms()[uniform.semantic](context.uniformState, model);\n      }\n    } else if (defined(uniform.value)) {\n      // Technique value that isn't overridden by a material\n      var uv2 = ModelUtility.createUniformFunction(uniform.type, uniform.value, textures, defaultTexture);\n      uniformMap[uniformName] = uv2.func;\n      uniformValues[uniformName] = uv2;\n    }\n  });\n  return {\n    map: uniformMap,\n    values: uniformValues,\n    jointMatrixUniformName: jointMatrixUniformName,\n    morphWeightsUniformName: morphWeightsUniformName\n  };\n}\n\nfunction createUniformMaps(model, context) {\n  var loadResources = model._loadResources;\n\n  if (!loadResources.finishedProgramCreation()) {\n    return;\n  }\n\n  if (!loadResources.createUniformMaps) {\n    return;\n  }\n\n  loadResources.createUniformMaps = false;\n  var gltf = model.gltf;\n  var techniques = model._sourceTechniques;\n  var uniformMaps = model._uniformMaps;\n  var textures = model._rendererResources.textures;\n  var defaultTexture = model._defaultTexture;\n  ForEach.material(gltf, function (material, materialId) {\n    var modelMaterial = model._runtime.materialsById[materialId];\n    var technique = techniques[modelMaterial._technique];\n    var instanceValues = modelMaterial._values;\n    var uniforms = createUniformsForMaterial(model, material, technique, instanceValues, context, textures, defaultTexture);\n    var u = uniformMaps[materialId];\n    u.uniformMap = uniforms.map; // uniform name -> function for the renderer\n\n    u.values = uniforms.values; // material parameter name -> ModelMaterial for modifying the parameter at runtime\n\n    u.jointMatrixUniformName = uniforms.jointMatrixUniformName;\n    u.morphWeightsUniformName = uniforms.morphWeightsUniformName;\n\n    if (defined(technique.attributes.a_outlineCoordinates)) {\n      var outlineTexture = ModelOutlineLoader.createTexture(model, context);\n\n      u.uniformMap.u_outlineTexture = function () {\n        return outlineTexture;\n      };\n    }\n  });\n}\n\nfunction createUniformsForDracoQuantizedAttributes(decodedData) {\n  return ModelUtility.createUniformsForDracoQuantizedAttributes(decodedData.attributes);\n}\n\nfunction createUniformsForQuantizedAttributes(model, primitive) {\n  var programId = getProgramForPrimitive(model, primitive);\n  var quantizedUniforms = model._quantizedUniforms[programId];\n  return ModelUtility.createUniformsForQuantizedAttributes(model.gltf, primitive, quantizedUniforms);\n}\n\nfunction createPickColorFunction(color) {\n  return function () {\n    return color;\n  };\n}\n\nfunction createJointMatricesFunction(runtimeNode) {\n  return function () {\n    return runtimeNode.computedJointMatrices;\n  };\n}\n\nfunction createMorphWeightsFunction(runtimeNode) {\n  return function () {\n    return runtimeNode.weights;\n  };\n}\n\nfunction createSilhouetteColorFunction(model) {\n  return function () {\n    return model.silhouetteColor;\n  };\n}\n\nfunction createSilhouetteSizeFunction(model) {\n  return function () {\n    return model.silhouetteSize;\n  };\n}\n\nfunction createColorFunction(model) {\n  return function () {\n    return model.color;\n  };\n}\n\nvar scratchClippingPlaneMatrix = new Matrix4();\n\nfunction createClippingPlanesMatrixFunction(model) {\n  return function () {\n    var clippingPlanes = model.clippingPlanes;\n\n    if (!defined(clippingPlanes) && !defined(model._sphericalHarmonicCoefficients) && !defined(model._specularEnvironmentMaps)) {\n      return Matrix4.IDENTITY;\n    }\n\n    var modelMatrix = defined(clippingPlanes) ? clippingPlanes.modelMatrix : Matrix4.IDENTITY;\n    return Matrix4.multiply(model._clippingPlaneModelViewMatrix, modelMatrix, scratchClippingPlaneMatrix);\n  };\n}\n\nfunction createClippingPlanesFunction(model) {\n  return function () {\n    var clippingPlanes = model.clippingPlanes;\n    return !defined(clippingPlanes) || !clippingPlanes.enabled ? model._defaultTexture : clippingPlanes.texture;\n  };\n}\n\nfunction createClippingPlanesEdgeStyleFunction(model) {\n  return function () {\n    var clippingPlanes = model.clippingPlanes;\n\n    if (!defined(clippingPlanes)) {\n      return Color.WHITE.withAlpha(0.0);\n    }\n\n    var style = Color.clone(clippingPlanes.edgeColor);\n    style.alpha = clippingPlanes.edgeWidth;\n    return style;\n  };\n}\n\nfunction createColorBlendFunction(model) {\n  return function () {\n    return ColorBlendMode.getColorBlend(model.colorBlendMode, model.colorBlendAmount);\n  };\n}\n\nfunction createIBLFactorFunction(model) {\n  return function () {\n    return model._imageBasedLightingFactor;\n  };\n}\n\nfunction createLightColorFunction(model) {\n  return function () {\n    return model._lightColor;\n  };\n}\n\nfunction createLuminanceAtZenithFunction(model) {\n  return function () {\n    return model.luminanceAtZenith;\n  };\n}\n\nfunction createSphericalHarmonicCoefficientsFunction(model) {\n  return function () {\n    return model._sphericalHarmonicCoefficients;\n  };\n}\n\nfunction createSpecularEnvironmentMapFunction(model) {\n  return function () {\n    return model._specularEnvironmentMapAtlas.texture;\n  };\n}\n\nfunction createSpecularEnvironmentMapSizeFunction(model) {\n  return function () {\n    return model._specularEnvironmentMapAtlas.texture.dimensions;\n  };\n}\n\nfunction createSpecularEnvironmentMapLOD(model) {\n  return function () {\n    return model._specularEnvironmentMapAtlas.maximumMipmapLevel;\n  };\n}\n\nfunction triangleCountFromPrimitiveIndices(primitive, indicesCount) {\n  switch (primitive.mode) {\n    case PrimitiveType.TRIANGLES:\n      return indicesCount / 3;\n\n    case PrimitiveType.TRIANGLE_STRIP:\n    case PrimitiveType.TRIANGLE_FAN:\n      return Math.max(indicesCount - 2, 0);\n\n    default:\n      return 0;\n  }\n}\n\nfunction createCommand(model, gltfNode, runtimeNode, context, scene3DOnly) {\n  var nodeCommands = model._nodeCommands;\n  var pickIds = model._pickIds;\n  var allowPicking = model.allowPicking;\n  var runtimeMeshesByName = model._runtime.meshesByName;\n  var resources = model._rendererResources;\n  var rendererVertexArrays = resources.vertexArrays;\n  var rendererPrograms = resources.programs;\n  var rendererRenderStates = resources.renderStates;\n  var uniformMaps = model._uniformMaps;\n  var gltf = model.gltf;\n  var accessors = gltf.accessors;\n  var gltfMeshes = gltf.meshes;\n  var id = gltfNode.mesh;\n  var mesh = gltfMeshes[id];\n  var primitives = mesh.primitives;\n  var length = primitives.length; // The glTF node hierarchy is a DAG so a node can have more than one\n  // parent, so a node may already have commands.  If so, append more\n  // since they will have a different model matrix.\n\n  for (var i = 0; i < length; ++i) {\n    var primitive = primitives[i];\n    var ix = accessors[primitive.indices];\n    var material = model._runtime.materialsById[primitive.material];\n    var programId = material._program;\n    var decodedData = model._decodedData[id + \".primitive.\" + i];\n    var boundingSphere;\n    var positionAccessor = primitive.attributes.POSITION;\n\n    if (defined(positionAccessor)) {\n      var minMax = ModelUtility.getAccessorMinMax(gltf, positionAccessor);\n      boundingSphere = BoundingSphere.fromCornerPoints(Cartesian3.fromArray(minMax.min), Cartesian3.fromArray(minMax.max));\n    }\n\n    var vertexArray = rendererVertexArrays[id + \".primitive.\" + i];\n    var offset;\n    var count; // Use indices of the previously decoded Draco geometry.\n\n    if (defined(decodedData)) {\n      count = decodedData.numberOfIndices;\n      offset = 0;\n    } else if (defined(ix)) {\n      count = ix.count;\n      offset = ix.byteOffset / IndexDatatype.getSizeInBytes(ix.componentType); // glTF has offset in bytes.  Cesium has offsets in indices\n    } else {\n      var positions = accessors[primitive.attributes.POSITION];\n      count = positions.count;\n      offset = 0;\n    } // Update model triangle count using number of indices\n\n\n    model._trianglesLength += triangleCountFromPrimitiveIndices(primitive, count);\n    var um = uniformMaps[primitive.material];\n    var uniformMap = um.uniformMap;\n\n    if (defined(um.jointMatrixUniformName)) {\n      var jointUniformMap = {};\n      jointUniformMap[um.jointMatrixUniformName] = createJointMatricesFunction(runtimeNode);\n      uniformMap = combine(uniformMap, jointUniformMap);\n    }\n\n    if (defined(um.morphWeightsUniformName)) {\n      var morphWeightsUniformMap = {};\n      morphWeightsUniformMap[um.morphWeightsUniformName] = createMorphWeightsFunction(runtimeNode);\n      uniformMap = combine(uniformMap, morphWeightsUniformMap);\n    }\n\n    uniformMap = combine(uniformMap, {\n      gltf_color: createColorFunction(model),\n      gltf_colorBlend: createColorBlendFunction(model),\n      gltf_clippingPlanes: createClippingPlanesFunction(model),\n      gltf_clippingPlanesEdgeStyle: createClippingPlanesEdgeStyleFunction(model),\n      gltf_clippingPlanesMatrix: createClippingPlanesMatrixFunction(model),\n      gltf_iblFactor: createIBLFactorFunction(model),\n      gltf_lightColor: createLightColorFunction(model),\n      gltf_sphericalHarmonicCoefficients: createSphericalHarmonicCoefficientsFunction(model),\n      gltf_specularMap: createSpecularEnvironmentMapFunction(model),\n      gltf_specularMapSize: createSpecularEnvironmentMapSizeFunction(model),\n      gltf_maxSpecularLOD: createSpecularEnvironmentMapLOD(model),\n      gltf_luminanceAtZenith: createLuminanceAtZenithFunction(model)\n    }); // Allow callback to modify the uniformMap\n\n    if (defined(model._uniformMapLoaded)) {\n      uniformMap = model._uniformMapLoaded(uniformMap, programId, runtimeNode);\n    } // Add uniforms for decoding quantized attributes if used\n\n\n    var quantizedUniformMap = {};\n\n    if (model.extensionsUsed.WEB3D_quantized_attributes) {\n      quantizedUniformMap = createUniformsForQuantizedAttributes(model, primitive);\n    } else if (model._dequantizeInShader && defined(decodedData)) {\n      quantizedUniformMap = createUniformsForDracoQuantizedAttributes(decodedData);\n    }\n\n    uniformMap = combine(uniformMap, quantizedUniformMap);\n    var rs = rendererRenderStates[primitive.material];\n    var isTranslucent = rs.blending.enabled;\n    var owner = model._pickObject;\n\n    if (!defined(owner)) {\n      owner = {\n        primitive: model,\n        id: model.id,\n        node: runtimeNode.publicNode,\n        mesh: runtimeMeshesByName[mesh.name]\n      };\n    }\n\n    var castShadows = ShadowMode.castShadows(model._shadows);\n    var receiveShadows = ShadowMode.receiveShadows(model._shadows);\n    var pickId;\n\n    if (allowPicking && !defined(model._uniformMapLoaded)) {\n      pickId = context.createPickId(owner);\n      pickIds.push(pickId);\n      var pickUniforms = {\n        czm_pickColor: createPickColorFunction(pickId.color)\n      };\n      uniformMap = combine(uniformMap, pickUniforms);\n    }\n\n    if (allowPicking) {\n      if (defined(model._pickIdLoaded) && defined(model._uniformMapLoaded)) {\n        pickId = model._pickIdLoaded();\n      } else {\n        pickId = \"czm_pickColor\";\n      }\n    }\n\n    var command = new DrawCommand({\n      boundingVolume: new BoundingSphere(),\n      // updated in update()\n      cull: model.cull,\n      modelMatrix: new Matrix4(),\n      // computed in update()\n      primitiveType: primitive.mode,\n      vertexArray: vertexArray,\n      count: count,\n      offset: offset,\n      shaderProgram: rendererPrograms[programId],\n      castShadows: castShadows,\n      receiveShadows: receiveShadows,\n      uniformMap: uniformMap,\n      renderState: rs,\n      owner: owner,\n      pass: isTranslucent ? Pass.TRANSLUCENT : model.opaquePass,\n      pickId: pickId\n    });\n    var command2D;\n\n    if (!scene3DOnly) {\n      command2D = DrawCommand.shallowClone(command);\n      command2D.boundingVolume = new BoundingSphere(); // updated in update()\n\n      command2D.modelMatrix = new Matrix4(); // updated in update()\n    }\n\n    var nodeCommand = {\n      show: true,\n      boundingSphere: boundingSphere,\n      command: command,\n      command2D: command2D,\n      // Generated on demand when silhouette size is greater than 0.0 and silhouette alpha is greater than 0.0\n      silhouetteModelCommand: undefined,\n      silhouetteModelCommand2D: undefined,\n      silhouetteColorCommand: undefined,\n      silhouetteColorCommand2D: undefined,\n      // Generated on demand when color alpha is less than 1.0\n      translucentCommand: undefined,\n      translucentCommand2D: undefined,\n      // For updating node commands on shader reconstruction\n      programId: programId\n    };\n    runtimeNode.commands.push(nodeCommand);\n    nodeCommands.push(nodeCommand);\n  }\n}\n\nfunction createRuntimeNodes(model, context, scene3DOnly) {\n  var loadResources = model._loadResources;\n\n  if (!loadResources.finishedEverythingButTextureCreation()) {\n    return;\n  }\n\n  if (!loadResources.createRuntimeNodes) {\n    return;\n  }\n\n  loadResources.createRuntimeNodes = false;\n  var rootNodes = [];\n  var runtimeNodes = model._runtime.nodes;\n  var gltf = model.gltf;\n  var nodes = gltf.nodes;\n  var scene = gltf.scenes[gltf.scene];\n  var sceneNodes = scene.nodes;\n  var length = sceneNodes.length;\n  var stack = [];\n  var seen = {};\n\n  for (var i = 0; i < length; ++i) {\n    stack.push({\n      parentRuntimeNode: undefined,\n      gltfNode: nodes[sceneNodes[i]],\n      id: sceneNodes[i]\n    });\n\n    while (stack.length > 0) {\n      var n = stack.pop();\n      seen[n.id] = true;\n      var parentRuntimeNode = n.parentRuntimeNode;\n      var gltfNode = n.gltfNode; // Node hierarchy is a DAG so a node can have more than one parent so it may already exist\n\n      var runtimeNode = runtimeNodes[n.id];\n\n      if (runtimeNode.parents.length === 0) {\n        if (defined(gltfNode.matrix)) {\n          runtimeNode.matrix = Matrix4.fromColumnMajorArray(gltfNode.matrix);\n        } else {\n          // TRS converted to Cesium types\n          var rotation = gltfNode.rotation;\n          runtimeNode.translation = Cartesian3.fromArray(gltfNode.translation);\n          runtimeNode.rotation = Quaternion.unpack(rotation);\n          runtimeNode.scale = Cartesian3.fromArray(gltfNode.scale);\n        }\n      }\n\n      if (defined(parentRuntimeNode)) {\n        parentRuntimeNode.children.push(runtimeNode);\n        runtimeNode.parents.push(parentRuntimeNode);\n      } else {\n        rootNodes.push(runtimeNode);\n      }\n\n      if (defined(gltfNode.mesh)) {\n        createCommand(model, gltfNode, runtimeNode, context, scene3DOnly);\n      }\n\n      var children = gltfNode.children;\n\n      if (defined(children)) {\n        var childrenLength = children.length;\n\n        for (var j = 0; j < childrenLength; j++) {\n          var childId = children[j];\n\n          if (!seen[childId]) {\n            stack.push({\n              parentRuntimeNode: runtimeNode,\n              gltfNode: nodes[childId],\n              id: children[j]\n            });\n          }\n        }\n      }\n    }\n  }\n\n  model._runtime.rootNodes = rootNodes;\n  model._runtime.nodes = runtimeNodes;\n}\n\nfunction getGeometryByteLength(buffers) {\n  var memory = 0;\n\n  for (var id in buffers) {\n    if (buffers.hasOwnProperty(id)) {\n      memory += buffers[id].sizeInBytes;\n    }\n  }\n\n  return memory;\n}\n\nfunction getTexturesByteLength(textures) {\n  var memory = 0;\n\n  for (var id in textures) {\n    if (textures.hasOwnProperty(id)) {\n      memory += textures[id].sizeInBytes;\n    }\n  }\n\n  return memory;\n}\n\nfunction createResources(model, frameState) {\n  var context = frameState.context;\n  var scene3DOnly = frameState.scene3DOnly;\n  var quantizedVertexShaders = model._quantizedVertexShaders;\n  var toClipCoordinates = model._toClipCoordinatesGLSL = {};\n  var techniques = model._sourceTechniques;\n  var programs = model._sourcePrograms;\n  var resources = model._rendererResources;\n  var shaders = resources.sourceShaders;\n\n  if (model._loadRendererResourcesFromCache) {\n    shaders = resources.sourceShaders = model._cachedRendererResources.sourceShaders;\n  }\n\n  for (var techniqueId in techniques) {\n    if (techniques.hasOwnProperty(techniqueId)) {\n      var programId = techniques[techniqueId].program;\n      var program = programs[programId];\n      var shader = shaders[program.vertexShader];\n      ModelUtility.checkSupportedGlExtensions(program.glExtensions, context);\n\n      if (model.extensionsUsed.WEB3D_quantized_attributes || model._dequantizeInShader) {\n        var quantizedVS = quantizedVertexShaders[programId];\n\n        if (!defined(quantizedVS)) {\n          quantizedVS = modifyShaderForQuantizedAttributes(shader, programId, model);\n          quantizedVertexShaders[programId] = quantizedVS;\n        }\n\n        shader = quantizedVS;\n      }\n\n      shader = modifyShader(shader, programId, model._vertexShaderLoaded);\n      toClipCoordinates[programId] = ModelUtility.toClipCoordinatesGLSL(model.gltf, shader);\n    }\n  }\n\n  if (model._loadRendererResourcesFromCache) {\n    var cachedResources = model._cachedRendererResources;\n    resources.buffers = cachedResources.buffers;\n    resources.vertexArrays = cachedResources.vertexArrays;\n    resources.programs = cachedResources.programs;\n    resources.silhouettePrograms = cachedResources.silhouettePrograms;\n    resources.textures = cachedResources.textures;\n    resources.samplers = cachedResources.samplers;\n    resources.renderStates = cachedResources.renderStates; // Vertex arrays are unique to this model, create instead of using the cache.\n\n    if (defined(model._precreatedAttributes)) {\n      createVertexArrays(model, context);\n    }\n\n    model._cachedGeometryByteLength += getGeometryByteLength(cachedResources.buffers);\n    model._cachedTexturesByteLength += getTexturesByteLength(cachedResources.textures);\n  } else {\n    createBuffers(model, frameState); // using glTF bufferViews\n\n    createPrograms(model, frameState);\n    createSamplers(model, context);\n    loadTexturesFromBufferViews(model);\n    createTextures(model, frameState);\n  }\n\n  createSkins(model);\n  createRuntimeAnimations(model);\n\n  if (!model._loadRendererResourcesFromCache) {\n    createVertexArrays(model, context); // using glTF meshes\n\n    createRenderStates(model); // using glTF materials/techniques/states\n    // Long-term, we might not cache render states if they could change\n    // due to an animation, e.g., a uniform going from opaque to transparent.\n    // Could use copy-on-write if it is worth it.  Probably overkill.\n  }\n\n  createUniformMaps(model, context); // using glTF materials/techniques\n\n  createRuntimeNodes(model, context, scene3DOnly); // using glTF scene\n} ///////////////////////////////////////////////////////////////////////////\n\n\nfunction getNodeMatrix(node, result) {\n  var publicNode = node.publicNode;\n  var publicMatrix = publicNode.matrix;\n\n  if (publicNode.useMatrix && defined(publicMatrix)) {\n    // Public matrix overrides original glTF matrix and glTF animations\n    Matrix4.clone(publicMatrix, result);\n  } else if (defined(node.matrix)) {\n    Matrix4.clone(node.matrix, result);\n  } else {\n    Matrix4.fromTranslationQuaternionRotationScale(node.translation, node.rotation, node.scale, result); // Keep matrix returned by the node in-sync if the node is targeted by an animation.  Only TRS nodes can be targeted.\n\n    publicNode.setMatrix(result);\n  }\n}\n\nvar scratchNodeStack = [];\nvar scratchComputedTranslation = new Cartesian4();\nvar scratchComputedMatrixIn2D = new Matrix4();\n\nfunction updateNodeHierarchyModelMatrix(model, modelTransformChanged, justLoaded, projection) {\n  var maxDirtyNumber = model._maxDirtyNumber;\n  var rootNodes = model._runtime.rootNodes;\n  var length = rootNodes.length;\n  var nodeStack = scratchNodeStack;\n  var computedModelMatrix = model._computedModelMatrix;\n\n  if (model._mode !== SceneMode.SCENE3D && !model._ignoreCommands) {\n    var translation = Matrix4.getColumn(computedModelMatrix, 3, scratchComputedTranslation);\n\n    if (!Cartesian4.equals(translation, Cartesian4.UNIT_W)) {\n      computedModelMatrix = Transforms.basisTo2D(projection, computedModelMatrix, scratchComputedMatrixIn2D);\n      model._rtcCenter = model._rtcCenter3D;\n    } else {\n      var center = model.boundingSphere.center;\n      var to2D = Transforms.wgs84To2DModelMatrix(projection, center, scratchComputedMatrixIn2D);\n      computedModelMatrix = Matrix4.multiply(to2D, computedModelMatrix, scratchComputedMatrixIn2D);\n\n      if (defined(model._rtcCenter)) {\n        Matrix4.setTranslation(computedModelMatrix, Cartesian4.UNIT_W, computedModelMatrix);\n        model._rtcCenter = model._rtcCenter2D;\n      }\n    }\n  }\n\n  for (var i = 0; i < length; ++i) {\n    var n = rootNodes[i];\n    getNodeMatrix(n, n.transformToRoot);\n    nodeStack.push(n);\n\n    while (nodeStack.length > 0) {\n      n = nodeStack.pop();\n      var transformToRoot = n.transformToRoot;\n      var commands = n.commands;\n\n      if (n.dirtyNumber === maxDirtyNumber || modelTransformChanged || justLoaded) {\n        var nodeMatrix = Matrix4.multiplyTransformation(computedModelMatrix, transformToRoot, n.computedMatrix);\n        var commandsLength = commands.length;\n\n        if (commandsLength > 0) {\n          // Node has meshes, which has primitives.  Update their commands.\n          for (var j = 0; j < commandsLength; ++j) {\n            var primitiveCommand = commands[j];\n            var command = primitiveCommand.command;\n            Matrix4.clone(nodeMatrix, command.modelMatrix); // PERFORMANCE_IDEA: Can use transformWithoutScale if no node up to the root has scale (including animation)\n\n            BoundingSphere.transform(primitiveCommand.boundingSphere, command.modelMatrix, command.boundingVolume);\n\n            if (defined(model._rtcCenter)) {\n              Cartesian3.add(model._rtcCenter, command.boundingVolume.center, command.boundingVolume.center);\n            } // If the model crosses the IDL in 2D, it will be drawn in one viewport, but part of it\n            // will be clipped by the viewport. We create a second command that translates the model\n            // model matrix to the opposite side of the map so the part that was clipped in one viewport\n            // is drawn in the other.\n\n\n            command = primitiveCommand.command2D;\n\n            if (defined(command) && model._mode === SceneMode.SCENE2D) {\n              Matrix4.clone(nodeMatrix, command.modelMatrix);\n              command.modelMatrix[13] -= CesiumMath.sign(command.modelMatrix[13]) * 2.0 * CesiumMath.PI * projection.ellipsoid.maximumRadius;\n              BoundingSphere.transform(primitiveCommand.boundingSphere, command.modelMatrix, command.boundingVolume);\n            }\n          }\n        }\n      }\n\n      var children = n.children;\n\n      if (defined(children)) {\n        var childrenLength = children.length;\n\n        for (var k = 0; k < childrenLength; ++k) {\n          var child = children[k]; // A node's transform needs to be updated if\n          // - It was targeted for animation this frame, or\n          // - Any of its ancestors were targeted for animation this frame\n          // PERFORMANCE_IDEA: if a child has multiple parents and only one of the parents\n          // is dirty, all the subtrees for each child instance will be dirty; we probably\n          // won't see this in the wild often.\n\n          child.dirtyNumber = Math.max(child.dirtyNumber, n.dirtyNumber);\n\n          if (child.dirtyNumber === maxDirtyNumber || justLoaded) {\n            // Don't check for modelTransformChanged since if only the model's model matrix changed,\n            // we do not need to rebuild the local transform-to-root, only the final\n            // [model's-model-matrix][transform-to-root] above.\n            getNodeMatrix(child, child.transformToRoot);\n            Matrix4.multiplyTransformation(transformToRoot, child.transformToRoot, child.transformToRoot);\n          }\n\n          nodeStack.push(child);\n        }\n      }\n    }\n  }\n\n  ++model._maxDirtyNumber;\n}\n\nvar scratchObjectSpace = new Matrix4();\n\nfunction applySkins(model) {\n  var skinnedNodes = model._runtime.skinnedNodes;\n  var length = skinnedNodes.length;\n\n  for (var i = 0; i < length; ++i) {\n    var node = skinnedNodes[i];\n    scratchObjectSpace = Matrix4.inverseTransformation(node.transformToRoot, scratchObjectSpace);\n    var computedJointMatrices = node.computedJointMatrices;\n    var joints = node.joints;\n    var bindShapeMatrix = node.bindShapeMatrix;\n    var inverseBindMatrices = node.inverseBindMatrices;\n    var inverseBindMatricesLength = inverseBindMatrices.length;\n\n    for (var m = 0; m < inverseBindMatricesLength; ++m) {\n      // [joint-matrix] = [node-to-root^-1][joint-to-root][inverse-bind][bind-shape]\n      if (!defined(computedJointMatrices[m])) {\n        computedJointMatrices[m] = new Matrix4();\n      }\n\n      computedJointMatrices[m] = Matrix4.multiplyTransformation(scratchObjectSpace, joints[m].transformToRoot, computedJointMatrices[m]);\n      computedJointMatrices[m] = Matrix4.multiplyTransformation(computedJointMatrices[m], inverseBindMatrices[m], computedJointMatrices[m]);\n\n      if (defined(bindShapeMatrix)) {\n        // Optimization for when bind shape matrix is the identity.\n        computedJointMatrices[m] = Matrix4.multiplyTransformation(computedJointMatrices[m], bindShapeMatrix, computedJointMatrices[m]);\n      }\n    }\n  }\n}\n\nfunction updatePerNodeShow(model) {\n  // Totally not worth it, but we could optimize this:\n  // http://help.agi.com/AGIComponents/html/BlogDeletionInBoundingVolumeHierarchies.htm\n  var rootNodes = model._runtime.rootNodes;\n  var length = rootNodes.length;\n  var nodeStack = scratchNodeStack;\n\n  for (var i = 0; i < length; ++i) {\n    var n = rootNodes[i];\n    n.computedShow = n.publicNode.show;\n    nodeStack.push(n);\n\n    while (nodeStack.length > 0) {\n      n = nodeStack.pop();\n      var show = n.computedShow;\n      var nodeCommands = n.commands;\n      var nodeCommandsLength = nodeCommands.length;\n\n      for (var j = 0; j < nodeCommandsLength; ++j) {\n        nodeCommands[j].show = show;\n      } // if commandsLength is zero, the node has a light or camera\n\n\n      var children = n.children;\n\n      if (defined(children)) {\n        var childrenLength = children.length;\n\n        for (var k = 0; k < childrenLength; ++k) {\n          var child = children[k]; // Parent needs to be shown for child to be shown.\n\n          child.computedShow = show && child.publicNode.show;\n          nodeStack.push(child);\n        }\n      }\n    }\n  }\n}\n\nfunction updatePickIds(model, context) {\n  var id = model.id;\n\n  if (model._id !== id) {\n    model._id = id;\n    var pickIds = model._pickIds;\n    var length = pickIds.length;\n\n    for (var i = 0; i < length; ++i) {\n      pickIds[i].object.id = id;\n    }\n  }\n}\n\nfunction updateWireframe(model) {\n  if (model._debugWireframe !== model.debugWireframe) {\n    model._debugWireframe = model.debugWireframe; // This assumes the original primitive was TRIANGLES and that the triangles\n    // are connected for the wireframe to look perfect.\n\n    var primitiveType = model.debugWireframe ? PrimitiveType.LINES : PrimitiveType.TRIANGLES;\n    var nodeCommands = model._nodeCommands;\n    var length = nodeCommands.length;\n\n    for (var i = 0; i < length; ++i) {\n      nodeCommands[i].command.primitiveType = primitiveType;\n    }\n  }\n}\n\nfunction updateShowBoundingVolume(model) {\n  if (model.debugShowBoundingVolume !== model._debugShowBoundingVolume) {\n    model._debugShowBoundingVolume = model.debugShowBoundingVolume;\n    var debugShowBoundingVolume = model.debugShowBoundingVolume;\n    var nodeCommands = model._nodeCommands;\n    var length = nodeCommands.length;\n\n    for (var i = 0; i < length; ++i) {\n      nodeCommands[i].command.debugShowBoundingVolume = debugShowBoundingVolume;\n    }\n  }\n}\n\nfunction updateShadows(model) {\n  if (model.shadows !== model._shadows) {\n    model._shadows = model.shadows;\n    var castShadows = ShadowMode.castShadows(model.shadows);\n    var receiveShadows = ShadowMode.receiveShadows(model.shadows);\n    var nodeCommands = model._nodeCommands;\n    var length = nodeCommands.length;\n\n    for (var i = 0; i < length; i++) {\n      var nodeCommand = nodeCommands[i];\n      nodeCommand.command.castShadows = castShadows;\n      nodeCommand.command.receiveShadows = receiveShadows;\n    }\n  }\n}\n\nfunction getTranslucentRenderState(renderState) {\n  var rs = clone(renderState, true);\n  rs.cull.enabled = false;\n  rs.depthTest.enabled = true;\n  rs.depthMask = false;\n  rs.blending = BlendingState.ALPHA_BLEND;\n  return RenderState.fromCache(rs);\n}\n\nfunction deriveTranslucentCommand(command) {\n  var translucentCommand = DrawCommand.shallowClone(command);\n  translucentCommand.pass = Pass.TRANSLUCENT;\n  translucentCommand.renderState = getTranslucentRenderState(command.renderState);\n  return translucentCommand;\n}\n\nfunction updateColor(model, frameState, forceDerive) {\n  // Generate translucent commands when the blend color has an alpha in the range (0.0, 1.0) exclusive\n  var scene3DOnly = frameState.scene3DOnly;\n  var alpha = model.color.alpha;\n\n  if (alpha > 0.0 && alpha < 1.0) {\n    var nodeCommands = model._nodeCommands;\n    var length = nodeCommands.length;\n\n    if (!defined(nodeCommands[0].translucentCommand) || forceDerive) {\n      for (var i = 0; i < length; ++i) {\n        var nodeCommand = nodeCommands[i];\n        var command = nodeCommand.command;\n        nodeCommand.translucentCommand = deriveTranslucentCommand(command);\n\n        if (!scene3DOnly) {\n          var command2D = nodeCommand.command2D;\n          nodeCommand.translucentCommand2D = deriveTranslucentCommand(command2D);\n        }\n      }\n    }\n  }\n}\n\nfunction getProgramId(model, program) {\n  var programs = model._rendererResources.programs;\n\n  for (var id in programs) {\n    if (programs.hasOwnProperty(id)) {\n      if (programs[id] === program) {\n        return id;\n      }\n    }\n  }\n}\n\nfunction createSilhouetteProgram(model, program, frameState) {\n  var vs = program.vertexShaderSource.sources[0];\n  var attributeLocations = program._attributeLocations;\n  var normalAttributeName = model._normalAttributeName; // Modified from http://forum.unity3d.com/threads/toon-outline-but-with-diffuse-surface.24668/\n\n  vs = ShaderSource.replaceMain(vs, \"gltf_silhouette_main\");\n  vs += \"uniform float gltf_silhouetteSize; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    gltf_silhouette_main(); \\n\" + \"    vec3 n = normalize(czm_normal3D * \" + normalAttributeName + \"); \\n\" + \"    n.x *= czm_projection[0][0]; \\n\" + \"    n.y *= czm_projection[1][1]; \\n\" + \"    vec4 clip = gl_Position; \\n\" + \"    clip.xy += n.xy * clip.w * gltf_silhouetteSize * czm_pixelRatio / czm_viewport.z; \\n\" + \"    gl_Position = clip; \\n\" + \"}\";\n  var fs = \"uniform vec4 gltf_silhouetteColor; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    gl_FragColor = czm_gammaCorrect(gltf_silhouetteColor); \\n\" + \"}\";\n  return ShaderProgram.fromCache({\n    context: frameState.context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations\n  });\n}\n\nfunction hasSilhouette(model, frameState) {\n  return silhouetteSupported(frameState.context) && model.silhouetteSize > 0.0 && model.silhouetteColor.alpha > 0.0 && defined(model._normalAttributeName);\n}\n\nfunction hasTranslucentCommands(model) {\n  var nodeCommands = model._nodeCommands;\n  var length = nodeCommands.length;\n\n  for (var i = 0; i < length; ++i) {\n    var nodeCommand = nodeCommands[i];\n    var command = nodeCommand.command;\n\n    if (command.pass === Pass.TRANSLUCENT) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isTranslucent(model) {\n  return model.color.alpha > 0.0 && model.color.alpha < 1.0;\n}\n\nfunction isInvisible(model) {\n  return model.color.alpha === 0.0;\n}\n\nfunction alphaDirty(currAlpha, prevAlpha) {\n  // Returns whether the alpha state has changed between invisible, translucent, or opaque\n  return Math.floor(currAlpha) !== Math.floor(prevAlpha) || Math.ceil(currAlpha) !== Math.ceil(prevAlpha);\n}\n\nvar silhouettesLength = 0;\n\nfunction createSilhouetteCommands(model, frameState) {\n  // Wrap around after exceeding the 8-bit stencil limit.\n  // The reference is unique to each model until this point.\n  var stencilReference = ++silhouettesLength % 255; // If the model is translucent the silhouette needs to be in the translucent pass.\n  // Otherwise the silhouette would be rendered before the model.\n\n  var silhouetteTranslucent = hasTranslucentCommands(model) || isTranslucent(model) || model.silhouetteColor.alpha < 1.0;\n  var silhouettePrograms = model._rendererResources.silhouettePrograms;\n  var scene3DOnly = frameState.scene3DOnly;\n  var nodeCommands = model._nodeCommands;\n  var length = nodeCommands.length;\n\n  for (var i = 0; i < length; ++i) {\n    var nodeCommand = nodeCommands[i];\n    var command = nodeCommand.command; // Create model command\n\n    var modelCommand = isTranslucent(model) ? nodeCommand.translucentCommand : command;\n    var silhouetteModelCommand = DrawCommand.shallowClone(modelCommand);\n    var renderState = clone(modelCommand.renderState); // Write the reference value into the stencil buffer.\n\n    renderState.stencilTest = {\n      enabled: true,\n      frontFunction: WebGLConstants.ALWAYS,\n      backFunction: WebGLConstants.ALWAYS,\n      reference: stencilReference,\n      mask: ~0,\n      frontOperation: {\n        fail: WebGLConstants.KEEP,\n        zFail: WebGLConstants.KEEP,\n        zPass: WebGLConstants.REPLACE\n      },\n      backOperation: {\n        fail: WebGLConstants.KEEP,\n        zFail: WebGLConstants.KEEP,\n        zPass: WebGLConstants.REPLACE\n      }\n    };\n\n    if (isInvisible(model)) {\n      // When the model is invisible disable color and depth writes but still write into the stencil buffer\n      renderState.colorMask = {\n        red: false,\n        green: false,\n        blue: false,\n        alpha: false\n      };\n      renderState.depthMask = false;\n    }\n\n    renderState = RenderState.fromCache(renderState);\n    silhouetteModelCommand.renderState = renderState;\n    nodeCommand.silhouetteModelCommand = silhouetteModelCommand; // Create color command\n\n    var silhouetteColorCommand = DrawCommand.shallowClone(command);\n    renderState = clone(command.renderState, true);\n    renderState.depthTest.enabled = true;\n    renderState.cull.enabled = false;\n\n    if (silhouetteTranslucent) {\n      silhouetteColorCommand.pass = Pass.TRANSLUCENT;\n      renderState.depthMask = false;\n      renderState.blending = BlendingState.ALPHA_BLEND;\n    } // Only render silhouette if the value in the stencil buffer equals the reference\n\n\n    renderState.stencilTest = {\n      enabled: true,\n      frontFunction: WebGLConstants.NOTEQUAL,\n      backFunction: WebGLConstants.NOTEQUAL,\n      reference: stencilReference,\n      mask: ~0,\n      frontOperation: {\n        fail: WebGLConstants.KEEP,\n        zFail: WebGLConstants.KEEP,\n        zPass: WebGLConstants.KEEP\n      },\n      backOperation: {\n        fail: WebGLConstants.KEEP,\n        zFail: WebGLConstants.KEEP,\n        zPass: WebGLConstants.KEEP\n      }\n    };\n    renderState = RenderState.fromCache(renderState); // If the silhouette program has already been cached use it\n\n    var program = command.shaderProgram;\n    var id = getProgramId(model, program);\n    var silhouetteProgram = silhouettePrograms[id];\n\n    if (!defined(silhouetteProgram)) {\n      silhouetteProgram = createSilhouetteProgram(model, program, frameState);\n      silhouettePrograms[id] = silhouetteProgram;\n    }\n\n    var silhouetteUniformMap = combine(command.uniformMap, {\n      gltf_silhouetteColor: createSilhouetteColorFunction(model),\n      gltf_silhouetteSize: createSilhouetteSizeFunction(model)\n    });\n    silhouetteColorCommand.renderState = renderState;\n    silhouetteColorCommand.shaderProgram = silhouetteProgram;\n    silhouetteColorCommand.uniformMap = silhouetteUniformMap;\n    silhouetteColorCommand.castShadows = false;\n    silhouetteColorCommand.receiveShadows = false;\n    nodeCommand.silhouetteColorCommand = silhouetteColorCommand;\n\n    if (!scene3DOnly) {\n      var command2D = nodeCommand.command2D;\n      var silhouetteModelCommand2D = DrawCommand.shallowClone(silhouetteModelCommand);\n      silhouetteModelCommand2D.boundingVolume = command2D.boundingVolume;\n      silhouetteModelCommand2D.modelMatrix = command2D.modelMatrix;\n      nodeCommand.silhouetteModelCommand2D = silhouetteModelCommand2D;\n      var silhouetteColorCommand2D = DrawCommand.shallowClone(silhouetteColorCommand);\n      silhouetteModelCommand2D.boundingVolume = command2D.boundingVolume;\n      silhouetteModelCommand2D.modelMatrix = command2D.modelMatrix;\n      nodeCommand.silhouetteColorCommand2D = silhouetteColorCommand2D;\n    }\n  }\n}\n\nfunction modifyShaderForClippingPlanes(shader, clippingPlaneCollection, context) {\n  shader = ShaderSource.replaceMain(shader, \"gltf_clip_main\");\n  shader += Model._getClippingFunction(clippingPlaneCollection, context) + \"\\n\";\n  shader += \"uniform sampler2D gltf_clippingPlanes; \\n\" + \"uniform mat4 gltf_clippingPlanesMatrix; \\n\" + \"uniform vec4 gltf_clippingPlanesEdgeStyle; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    gltf_clip_main(); \\n\" + getClipAndStyleCode(\"gltf_clippingPlanes\", \"gltf_clippingPlanesMatrix\", \"gltf_clippingPlanesEdgeStyle\") + \"} \\n\";\n  return shader;\n}\n\nfunction updateSilhouette(model, frameState, force) {\n  // Generate silhouette commands when the silhouette size is greater than 0.0 and the alpha is greater than 0.0\n  // There are two silhouette commands:\n  //     1. silhouetteModelCommand : render model normally while enabling stencil mask\n  //     2. silhouetteColorCommand : render enlarged model with a solid color while enabling stencil tests\n  if (!hasSilhouette(model, frameState)) {\n    return;\n  }\n\n  var nodeCommands = model._nodeCommands;\n  var dirty = alphaDirty(model.color.alpha, model._colorPreviousAlpha) || alphaDirty(model.silhouetteColor.alpha, model._silhouetteColorPreviousAlpha) || !defined(nodeCommands[0].silhouetteModelCommand);\n  model._colorPreviousAlpha = model.color.alpha;\n  model._silhouetteColorPreviousAlpha = model.silhouetteColor.alpha;\n\n  if (dirty || force) {\n    createSilhouetteCommands(model, frameState);\n  }\n}\n\nfunction updateClippingPlanes(model, frameState) {\n  var clippingPlanes = model._clippingPlanes;\n\n  if (defined(clippingPlanes) && clippingPlanes.owner === model) {\n    if (clippingPlanes.enabled) {\n      clippingPlanes.update(frameState);\n    }\n  }\n}\n\nvar scratchBoundingSphere = new BoundingSphere();\n\nfunction scaleInPixels(positionWC, radius, frameState) {\n  scratchBoundingSphere.center = positionWC;\n  scratchBoundingSphere.radius = radius;\n  return frameState.camera.getPixelSize(scratchBoundingSphere, frameState.context.drawingBufferWidth, frameState.context.drawingBufferHeight);\n}\n\nvar scratchPosition = new Cartesian3();\nvar scratchCartographic = new Cartographic();\n\nfunction getScale(model, frameState) {\n  var scale = model.scale;\n\n  if (model.minimumPixelSize !== 0.0) {\n    // Compute size of bounding sphere in pixels\n    var context = frameState.context;\n    var maxPixelSize = Math.max(context.drawingBufferWidth, context.drawingBufferHeight);\n    var m = defined(model._clampedModelMatrix) ? model._clampedModelMatrix : model.modelMatrix;\n    scratchPosition.x = m[12];\n    scratchPosition.y = m[13];\n    scratchPosition.z = m[14];\n\n    if (defined(model._rtcCenter)) {\n      Cartesian3.add(model._rtcCenter, scratchPosition, scratchPosition);\n    }\n\n    if (model._mode !== SceneMode.SCENE3D) {\n      var projection = frameState.mapProjection;\n      var cartographic = projection.ellipsoid.cartesianToCartographic(scratchPosition, scratchCartographic);\n      projection.project(cartographic, scratchPosition);\n      Cartesian3.fromElements(scratchPosition.z, scratchPosition.x, scratchPosition.y, scratchPosition);\n    }\n\n    var radius = model.boundingSphere.radius;\n    var metersPerPixel = scaleInPixels(scratchPosition, radius, frameState); // metersPerPixel is always > 0.0\n\n    var pixelsPerMeter = 1.0 / metersPerPixel;\n    var diameterInPixels = Math.min(pixelsPerMeter * (2.0 * radius), maxPixelSize); // Maintain model's minimum pixel size\n\n    if (diameterInPixels < model.minimumPixelSize) {\n      scale = model.minimumPixelSize * metersPerPixel / (2.0 * model._initialRadius);\n    }\n  }\n\n  return defined(model.maximumScale) ? Math.min(model.maximumScale, scale) : scale;\n}\n\nfunction releaseCachedGltf(model) {\n  if (defined(model._cacheKey) && defined(model._cachedGltf) && --model._cachedGltf.count === 0) {\n    delete gltfCache[model._cacheKey];\n  }\n\n  model._cachedGltf = undefined;\n} ///////////////////////////////////////////////////////////////////////////\n\n\nfunction CachedRendererResources(context, cacheKey) {\n  this.buffers = undefined;\n  this.vertexArrays = undefined;\n  this.programs = undefined;\n  this.sourceShaders = undefined;\n  this.silhouettePrograms = undefined;\n  this.textures = undefined;\n  this.samplers = undefined;\n  this.renderStates = undefined;\n  this.ready = false;\n  this.context = context;\n  this.cacheKey = cacheKey;\n  this.count = 0;\n}\n\nfunction destroy(property) {\n  for (var name in property) {\n    if (property.hasOwnProperty(name)) {\n      property[name].destroy();\n    }\n  }\n}\n\nfunction destroyCachedRendererResources(resources) {\n  destroy(resources.buffers);\n  destroy(resources.vertexArrays);\n  destroy(resources.programs);\n  destroy(resources.silhouettePrograms);\n  destroy(resources.textures);\n}\n\nCachedRendererResources.prototype.release = function () {\n  if (--this.count === 0) {\n    if (defined(this.cacheKey)) {\n      // Remove if this was cached\n      delete this.context.cache.modelRendererResourceCache[this.cacheKey];\n    }\n\n    destroyCachedRendererResources(this);\n    return destroyObject(this);\n  }\n\n  return undefined;\n}; ///////////////////////////////////////////////////////////////////////////\n\n\nfunction getUpdateHeightCallback(model, ellipsoid, cartoPosition) {\n  return function (clampedPosition) {\n    if (model.heightReference === HeightReference.RELATIVE_TO_GROUND) {\n      var clampedCart = ellipsoid.cartesianToCartographic(clampedPosition, scratchCartographic);\n      clampedCart.height += cartoPosition.height;\n      ellipsoid.cartographicToCartesian(clampedCart, clampedPosition);\n    }\n\n    var clampedModelMatrix = model._clampedModelMatrix; // Modify clamped model matrix to use new height\n\n    Matrix4.clone(model.modelMatrix, clampedModelMatrix);\n    clampedModelMatrix[12] = clampedPosition.x;\n    clampedModelMatrix[13] = clampedPosition.y;\n    clampedModelMatrix[14] = clampedPosition.z;\n    model._heightChanged = true;\n  };\n}\n\nfunction updateClamping(model) {\n  if (defined(model._removeUpdateHeightCallback)) {\n    model._removeUpdateHeightCallback();\n\n    model._removeUpdateHeightCallback = undefined;\n  }\n\n  var scene = model._scene;\n\n  if (!defined(scene) || !defined(scene.globe) || model.heightReference === HeightReference.NONE) {\n    //>>includeStart('debug', pragmas.debug);\n    if (model.heightReference !== HeightReference.NONE) {\n      throw new DeveloperError(\"Height reference is not supported without a scene and globe.\");\n    } //>>includeEnd('debug');\n\n\n    model._clampedModelMatrix = undefined;\n    return;\n  }\n\n  var globe = scene.globe;\n  var ellipsoid = globe.ellipsoid; // Compute cartographic position so we don't recompute every update\n\n  var modelMatrix = model.modelMatrix;\n  scratchPosition.x = modelMatrix[12];\n  scratchPosition.y = modelMatrix[13];\n  scratchPosition.z = modelMatrix[14];\n  var cartoPosition = ellipsoid.cartesianToCartographic(scratchPosition);\n\n  if (!defined(model._clampedModelMatrix)) {\n    model._clampedModelMatrix = Matrix4.clone(modelMatrix, new Matrix4());\n  } // Install callback to handle updating of terrain tiles\n\n\n  var surface = globe._surface;\n  model._removeUpdateHeightCallback = surface.updateHeight(cartoPosition, getUpdateHeightCallback(model, ellipsoid, cartoPosition)); // Set the correct height now\n\n  var height = globe.getHeight(cartoPosition);\n\n  if (defined(height)) {\n    // Get callback with cartoPosition being the non-clamped position\n    var cb = getUpdateHeightCallback(model, ellipsoid, cartoPosition); // Compute the clamped cartesian and call updateHeight callback\n\n    Cartographic.clone(cartoPosition, scratchCartographic);\n    scratchCartographic.height = height;\n    ellipsoid.cartographicToCartesian(scratchCartographic, scratchPosition);\n    cb(scratchPosition);\n  }\n}\n\nvar scratchDisplayConditionCartesian = new Cartesian3();\nvar scratchDistanceDisplayConditionCartographic = new Cartographic();\n\nfunction distanceDisplayConditionVisible(model, frameState) {\n  var distance2;\n  var ddc = model.distanceDisplayCondition;\n  var nearSquared = ddc.near * ddc.near;\n  var farSquared = ddc.far * ddc.far;\n\n  if (frameState.mode === SceneMode.SCENE2D) {\n    var frustum2DWidth = frameState.camera.frustum.right - frameState.camera.frustum.left;\n    distance2 = frustum2DWidth * 0.5;\n    distance2 = distance2 * distance2;\n  } else {\n    // Distance to center of primitive's reference frame\n    var position = Matrix4.getTranslation(model.modelMatrix, scratchDisplayConditionCartesian);\n\n    if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n      var projection = frameState.mapProjection;\n      var ellipsoid = projection.ellipsoid;\n      var cartographic = ellipsoid.cartesianToCartographic(position, scratchDistanceDisplayConditionCartographic);\n      position = projection.project(cartographic, position);\n      Cartesian3.fromElements(position.z, position.x, position.y, position);\n    }\n\n    distance2 = Cartesian3.distanceSquared(position, frameState.camera.positionWC);\n  }\n\n  return distance2 >= nearSquared && distance2 <= farSquared;\n}\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {RuntimeError} Failed to load external reference.\n */\n\n\nModel.prototype.update = function (frameState) {\n  if (frameState.mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  if (!FeatureDetection.supportsWebP.initialized) {\n    FeatureDetection.supportsWebP.initialize();\n    return;\n  }\n\n  var supportsWebP = FeatureDetection.supportsWebP();\n  var context = frameState.context;\n  this._defaultTexture = context.defaultTexture;\n\n  if (this._state === ModelState.NEEDS_LOAD && defined(this.gltf)) {\n    // Use renderer resources from cache instead of loading/creating them?\n    var cachedRendererResources;\n    var cacheKey = this.cacheKey;\n\n    if (defined(cacheKey)) {\n      // cache key given? this model will pull from or contribute to context level cache\n      context.cache.modelRendererResourceCache = defaultValue(context.cache.modelRendererResourceCache, {});\n      var modelCaches = context.cache.modelRendererResourceCache;\n      cachedRendererResources = modelCaches[this.cacheKey];\n\n      if (defined(cachedRendererResources)) {\n        if (!cachedRendererResources.ready) {\n          // Cached resources for the model are not loaded yet.  We'll\n          // try again every frame until they are.\n          return;\n        }\n\n        ++cachedRendererResources.count;\n        this._loadRendererResourcesFromCache = true;\n      } else {\n        cachedRendererResources = new CachedRendererResources(context, cacheKey);\n        cachedRendererResources.count = 1;\n        modelCaches[this.cacheKey] = cachedRendererResources;\n      }\n\n      this._cachedRendererResources = cachedRendererResources;\n    } else {\n      // cache key not given? this model doesn't care about context level cache at all. Cache is here to simplify freeing on destroy.\n      cachedRendererResources = new CachedRendererResources(context);\n      cachedRendererResources.count = 1;\n      this._cachedRendererResources = cachedRendererResources;\n    }\n\n    this._state = ModelState.LOADING;\n\n    if (this._state !== ModelState.FAILED) {\n      var extensions = this.gltf.extensions;\n\n      if (defined(extensions) && defined(extensions.CESIUM_RTC)) {\n        var center = Cartesian3.fromArray(extensions.CESIUM_RTC.center);\n\n        if (!Cartesian3.equals(center, Cartesian3.ZERO)) {\n          this._rtcCenter3D = center;\n          var projection = frameState.mapProjection;\n          var ellipsoid = projection.ellipsoid;\n          var cartographic = ellipsoid.cartesianToCartographic(this._rtcCenter3D);\n          var projectedCart = projection.project(cartographic);\n          Cartesian3.fromElements(projectedCart.z, projectedCart.x, projectedCart.y, projectedCart);\n          this._rtcCenter2D = projectedCart;\n          this._rtcCenterEye = new Cartesian3();\n          this._rtcCenter = this._rtcCenter3D;\n        }\n      }\n\n      addPipelineExtras(this.gltf);\n      this._loadResources = new ModelLoadResources();\n\n      if (!this._loadRendererResourcesFromCache) {\n        // Buffers are required to updateVersion\n        ModelUtility.parseBuffers(this, bufferLoad);\n      }\n    }\n  }\n\n  var loadResources = this._loadResources;\n  var incrementallyLoadTextures = this._incrementallyLoadTextures;\n  var justLoaded = false;\n\n  if (this._state === ModelState.LOADING) {\n    // Transition from LOADING -> LOADED once resources are downloaded and created.\n    // Textures may continue to stream in while in the LOADED state.\n    if (loadResources.pendingBufferLoads === 0) {\n      if (!loadResources.initialized) {\n        frameState.brdfLutGenerator.update(frameState);\n        ModelUtility.checkSupportedExtensions(this.extensionsRequired, supportsWebP);\n        ModelUtility.updateForwardAxis(this); // glTF pipeline updates, not needed if loading from cache\n\n        if (!defined(this.gltf.extras.sourceVersion)) {\n          var gltf = this.gltf; // Add the original version so it remains cached\n\n          gltf.extras.sourceVersion = ModelUtility.getAssetVersion(gltf);\n          gltf.extras.sourceKHRTechniquesWebGL = defined(ModelUtility.getUsedExtensions(gltf).KHR_techniques_webgl);\n          this._sourceVersion = gltf.extras.sourceVersion;\n          this._sourceKHRTechniquesWebGL = gltf.extras.sourceKHRTechniquesWebGL;\n          updateVersion(gltf);\n          addDefaults(gltf);\n          var options = {\n            addBatchIdToGeneratedShaders: this._addBatchIdToGeneratedShaders\n          };\n          processModelMaterialsCommon(gltf, options);\n          processPbrMaterials(gltf, options);\n        }\n\n        this._sourceVersion = this.gltf.extras.sourceVersion;\n        this._sourceKHRTechniquesWebGL = this.gltf.extras.sourceKHRTechniquesWebGL; // Skip dequantizing in the shader if not encoded\n\n        this._dequantizeInShader = this._dequantizeInShader && DracoLoader.hasExtension(this); // We do this after to make sure that the ids don't change\n\n        addBuffersToLoadResources(this);\n        parseArticulations(this);\n        parseTechniques(this);\n\n        if (!this._loadRendererResourcesFromCache) {\n          parseBufferViews(this);\n          parseShaders(this);\n          parsePrograms(this);\n          parseTextures(this, context, supportsWebP);\n        }\n\n        parseMaterials(this);\n        parseMeshes(this);\n        parseNodes(this); // Start draco decoding\n\n        DracoLoader.parse(this, context);\n        loadResources.initialized = true;\n      }\n\n      if (!loadResources.finishedDecoding()) {\n        DracoLoader.decodeModel(this, context).otherwise(ModelUtility.getFailedLoadFunction(this, \"model\", this.basePath));\n      }\n\n      if (loadResources.finishedDecoding() && !loadResources.resourcesParsed) {\n        this._boundingSphere = ModelUtility.computeBoundingSphere(this);\n        this._initialRadius = this._boundingSphere.radius;\n        DracoLoader.cacheDataForModel(this);\n        loadResources.resourcesParsed = true;\n      }\n\n      if (loadResources.resourcesParsed && loadResources.pendingShaderLoads === 0) {\n        ModelOutlineLoader.outlinePrimitives(this);\n        createResources(this, frameState);\n      }\n    }\n\n    if (loadResources.finished() || incrementallyLoadTextures && loadResources.finishedEverythingButTextureCreation()) {\n      this._state = ModelState.LOADED;\n      justLoaded = true;\n    }\n  } // Incrementally stream textures.\n\n\n  if (defined(loadResources) && this._state === ModelState.LOADED) {\n    if (incrementallyLoadTextures && !justLoaded) {\n      createResources(this, frameState);\n    }\n\n    if (loadResources.finished()) {\n      this._loadResources = undefined; // Clear CPU memory since WebGL resources were created.\n\n      var resources = this._rendererResources;\n      var cachedResources = this._cachedRendererResources;\n      cachedResources.buffers = resources.buffers;\n      cachedResources.vertexArrays = resources.vertexArrays;\n      cachedResources.programs = resources.programs;\n      cachedResources.sourceShaders = resources.sourceShaders;\n      cachedResources.silhouettePrograms = resources.silhouettePrograms;\n      cachedResources.textures = resources.textures;\n      cachedResources.samplers = resources.samplers;\n      cachedResources.renderStates = resources.renderStates;\n      cachedResources.ready = true; // The normal attribute name is required for silhouettes, so get it before the gltf JSON is released\n\n      this._normalAttributeName = ModelUtility.getAttributeOrUniformBySemantic(this.gltf, \"NORMAL\"); // Vertex arrays are unique to this model, do not store in cache.\n\n      if (defined(this._precreatedAttributes)) {\n        cachedResources.vertexArrays = {};\n      }\n\n      if (this.releaseGltfJson) {\n        releaseCachedGltf(this);\n      }\n    }\n  }\n\n  var iblSupported = OctahedralProjectedCubeMap.isSupported(context);\n\n  if (this._shouldUpdateSpecularMapAtlas && iblSupported) {\n    this._shouldUpdateSpecularMapAtlas = false;\n    this._specularEnvironmentMapAtlas = this._specularEnvironmentMapAtlas && this._specularEnvironmentMapAtlas.destroy();\n    this._specularEnvironmentMapAtlas = undefined;\n\n    if (defined(this._specularEnvironmentMaps)) {\n      this._specularEnvironmentMapAtlas = new OctahedralProjectedCubeMap(this._specularEnvironmentMaps);\n      var that = this;\n\n      this._specularEnvironmentMapAtlas.readyPromise.then(function () {\n        that._shouldRegenerateShaders = true;\n      }).otherwise(function (error) {\n        console.error(\"Error loading specularEnvironmentMaps: \" + error);\n      });\n    } // Regenerate shaders to not use an environment map. Will be set to true again if there was a new environment map and it is ready.\n\n\n    this._shouldRegenerateShaders = true;\n  }\n\n  if (defined(this._specularEnvironmentMapAtlas)) {\n    this._specularEnvironmentMapAtlas.update(frameState);\n  }\n\n  var recompileWithDefaultAtlas = !defined(this._specularEnvironmentMapAtlas) && defined(frameState.specularEnvironmentMaps) && !this._useDefaultSpecularMaps;\n  var recompileWithoutDefaultAtlas = !defined(frameState.specularEnvironmentMaps) && this._useDefaultSpecularMaps;\n  var recompileWithDefaultSHCoeffs = !defined(this._sphericalHarmonicCoefficients) && defined(frameState.sphericalHarmonicCoefficients) && !this._useDefaultSphericalHarmonics;\n  var recompileWithoutDefaultSHCoeffs = !defined(frameState.sphericalHarmonicCoefficients) && this._useDefaultSphericalHarmonics;\n  this._shouldRegenerateShaders = this._shouldRegenerateShaders || recompileWithDefaultAtlas || recompileWithoutDefaultAtlas || recompileWithDefaultSHCoeffs || recompileWithoutDefaultSHCoeffs;\n  this._useDefaultSpecularMaps = !defined(this._specularEnvironmentMapAtlas) && defined(frameState.specularEnvironmentMaps);\n  this._useDefaultSphericalHarmonics = !defined(this._sphericalHarmonicCoefficients) && defined(frameState.sphericalHarmonicCoefficients);\n  var silhouette = hasSilhouette(this, frameState);\n  var translucent = isTranslucent(this);\n  var invisible = isInvisible(this);\n  var displayConditionPassed = defined(this.distanceDisplayCondition) ? distanceDisplayConditionVisible(this, frameState) : true;\n  var show = this.show && displayConditionPassed && this.scale !== 0.0 && (!invisible || silhouette);\n\n  if (show && this._state === ModelState.LOADED || justLoaded) {\n    var animated = this.activeAnimations.update(frameState) || this._cesiumAnimationsDirty;\n\n    this._cesiumAnimationsDirty = false;\n    this._dirty = false;\n    var modelMatrix = this.modelMatrix;\n    var modeChanged = frameState.mode !== this._mode;\n    this._mode = frameState.mode; // Model's model matrix needs to be updated\n\n    var modelTransformChanged = !Matrix4.equals(this._modelMatrix, modelMatrix) || this._scale !== this.scale || this._minimumPixelSize !== this.minimumPixelSize || this.minimumPixelSize !== 0.0 || // Minimum pixel size changed or is enabled\n    this._maximumScale !== this.maximumScale || this._heightReference !== this.heightReference || this._heightChanged || modeChanged;\n\n    if (modelTransformChanged || justLoaded) {\n      Matrix4.clone(modelMatrix, this._modelMatrix);\n      updateClamping(this);\n\n      if (defined(this._clampedModelMatrix)) {\n        modelMatrix = this._clampedModelMatrix;\n      }\n\n      this._scale = this.scale;\n      this._minimumPixelSize = this.minimumPixelSize;\n      this._maximumScale = this.maximumScale;\n      this._heightReference = this.heightReference;\n      this._heightChanged = false;\n      var scale = getScale(this, frameState);\n      var computedModelMatrix = this._computedModelMatrix;\n      Matrix4.multiplyByUniformScale(modelMatrix, scale, computedModelMatrix);\n\n      if (this._upAxis === Axis.Y) {\n        Matrix4.multiplyTransformation(computedModelMatrix, Axis.Y_UP_TO_Z_UP, computedModelMatrix);\n      } else if (this._upAxis === Axis.X) {\n        Matrix4.multiplyTransformation(computedModelMatrix, Axis.X_UP_TO_Z_UP, computedModelMatrix);\n      }\n\n      if (this.forwardAxis === Axis.Z) {\n        // glTF 2.0 has a Z-forward convention that must be adapted here to X-forward.\n        Matrix4.multiplyTransformation(computedModelMatrix, Axis.Z_UP_TO_X_UP, computedModelMatrix);\n      }\n    } // Update modelMatrix throughout the graph as needed\n\n\n    if (animated || modelTransformChanged || justLoaded) {\n      updateNodeHierarchyModelMatrix(this, modelTransformChanged, justLoaded, frameState.mapProjection);\n      this._dirty = true;\n\n      if (animated || justLoaded) {\n        // Apply skins if animation changed any node transforms\n        applySkins(this);\n      }\n    }\n\n    if (this._perNodeShowDirty) {\n      this._perNodeShowDirty = false;\n      updatePerNodeShow(this);\n    }\n\n    updatePickIds(this, context);\n    updateWireframe(this);\n    updateShowBoundingVolume(this);\n    updateShadows(this);\n    updateClippingPlanes(this, frameState); // Regenerate shaders if ClippingPlaneCollection state changed or it was removed\n\n    var clippingPlanes = this._clippingPlanes;\n    var currentClippingPlanesState = 0;\n    var useClippingPlanes = defined(clippingPlanes) && clippingPlanes.enabled && clippingPlanes.length > 0;\n\n    var usesSH = defined(this._sphericalHarmonicCoefficients) || this._useDefaultSphericalHarmonics;\n\n    var usesSM = defined(this._specularEnvironmentMapAtlas) && this._specularEnvironmentMapAtlas.ready || this._useDefaultSpecularMaps;\n\n    if (useClippingPlanes || usesSH || usesSM) {\n      var clippingPlanesOriginMatrix = defaultValue(this.clippingPlanesOriginMatrix, modelMatrix);\n      Matrix4.multiply(context.uniformState.view3D, clippingPlanesOriginMatrix, this._clippingPlaneModelViewMatrix);\n    }\n\n    if (useClippingPlanes) {\n      currentClippingPlanesState = clippingPlanes.clippingPlanesState;\n    }\n\n    var shouldRegenerateShaders = this._shouldRegenerateShaders;\n    shouldRegenerateShaders = shouldRegenerateShaders || this._clippingPlanesState !== currentClippingPlanesState;\n    this._clippingPlanesState = currentClippingPlanesState; // Regenerate shaders if color shading changed from last update\n\n    var currentlyColorShadingEnabled = isColorShadingEnabled(this);\n\n    if (currentlyColorShadingEnabled !== this._colorShadingEnabled) {\n      this._colorShadingEnabled = currentlyColorShadingEnabled;\n      shouldRegenerateShaders = true;\n    }\n\n    if (shouldRegenerateShaders) {\n      regenerateShaders(this, frameState);\n    } else {\n      updateColor(this, frameState, false);\n      updateSilhouette(this, frameState, false);\n    }\n  }\n\n  if (justLoaded) {\n    // Called after modelMatrix update.\n    var model = this;\n    frameState.afterRender.push(function () {\n      model._ready = true;\n\n      model._readyPromise.resolve(model);\n    });\n    return;\n  } // We don't check show at the top of the function since we\n  // want to be able to progressively load models when they are not shown,\n  // and then have them visible immediately when show is set to true.\n\n\n  if (show && !this._ignoreCommands) {\n    // PERFORMANCE_IDEA: This is terrible\n    var commandList = frameState.commandList;\n    var passes = frameState.passes;\n    var nodeCommands = this._nodeCommands;\n    var length = nodeCommands.length;\n    var i;\n    var nc;\n    var idl2D = frameState.mapProjection.ellipsoid.maximumRadius * CesiumMath.PI;\n    var boundingVolume;\n\n    if (passes.render || passes.pick && this.allowPicking) {\n      for (i = 0; i < length; ++i) {\n        nc = nodeCommands[i];\n\n        if (nc.show) {\n          var command = translucent ? nc.translucentCommand : nc.command;\n          command = silhouette ? nc.silhouetteModelCommand : command;\n          commandList.push(command);\n          boundingVolume = nc.command.boundingVolume;\n\n          if (frameState.mode === SceneMode.SCENE2D && (boundingVolume.center.y + boundingVolume.radius > idl2D || boundingVolume.center.y - boundingVolume.radius < idl2D)) {\n            var command2D = translucent ? nc.translucentCommand2D : nc.command2D;\n            command2D = silhouette ? nc.silhouetteModelCommand2D : command2D;\n            commandList.push(command2D);\n          }\n        }\n      }\n\n      if (silhouette && !passes.pick) {\n        // Render second silhouette pass\n        for (i = 0; i < length; ++i) {\n          nc = nodeCommands[i];\n\n          if (nc.show) {\n            commandList.push(nc.silhouetteColorCommand);\n            boundingVolume = nc.command.boundingVolume;\n\n            if (frameState.mode === SceneMode.SCENE2D && (boundingVolume.center.y + boundingVolume.radius > idl2D || boundingVolume.center.y - boundingVolume.radius < idl2D)) {\n              commandList.push(nc.silhouetteColorCommand2D);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  var credit = this._credit;\n\n  if (defined(credit)) {\n    frameState.creditDisplay.addCredit(credit);\n  }\n\n  var resourceCredits = this._resourceCredits;\n  var creditCount = resourceCredits.length;\n\n  for (var c = 0; c < creditCount; c++) {\n    frameState.creditDisplay.addCredit(resourceCredits[c]);\n  }\n};\n\nfunction destroyIfNotCached(rendererResources, cachedRendererResources) {\n  if (rendererResources.programs !== cachedRendererResources.programs) {\n    destroy(rendererResources.programs);\n  }\n\n  if (rendererResources.silhouettePrograms !== cachedRendererResources.silhouettePrograms) {\n    destroy(rendererResources.silhouettePrograms);\n  }\n} // Run from update iff:\n// - everything is loaded\n// - clipping planes state change OR color state set\n// Run this from destructor after removing color state and clipping plane state\n\n\nfunction regenerateShaders(model, frameState) {\n  // In regards to _cachedRendererResources:\n  // Fair to assume that this is data that should just never get modified due to clipping planes or model color.\n  // So if clipping planes or model color active:\n  // - delink _rendererResources.*programs and create new dictionaries.\n  // - do NOT destroy any programs - might be used by copies of the model or by might be needed in the future if clipping planes/model color is deactivated\n  // If clipping planes and model color inactive:\n  // - destroy _rendererResources.*programs\n  // - relink _rendererResources.*programs to _cachedRendererResources\n  // In both cases, need to mark commands as dirty, re-run derived commands (elsewhere)\n  var rendererResources = model._rendererResources;\n  var cachedRendererResources = model._cachedRendererResources;\n  destroyIfNotCached(rendererResources, cachedRendererResources);\n  var programId;\n\n  if (isClippingEnabled(model) || isColorShadingEnabled(model) || model._shouldRegenerateShaders) {\n    model._shouldRegenerateShaders = false;\n    rendererResources.programs = {};\n    rendererResources.silhouettePrograms = {};\n    var visitedPrograms = {};\n    var techniques = model._sourceTechniques;\n    var technique;\n\n    for (var techniqueId in techniques) {\n      if (techniques.hasOwnProperty(techniqueId)) {\n        technique = techniques[techniqueId];\n        programId = technique.program;\n\n        if (!visitedPrograms[programId]) {\n          visitedPrograms[programId] = true;\n          recreateProgram({\n            programId: programId,\n            techniqueId: techniqueId\n          }, model, frameState.context);\n        }\n      }\n    }\n  } else {\n    rendererResources.programs = cachedRendererResources.programs;\n    rendererResources.silhouettePrograms = cachedRendererResources.silhouettePrograms;\n  } // Fix all the commands, marking them as dirty so everything that derives will re-derive\n\n\n  var rendererPrograms = rendererResources.programs;\n  var nodeCommands = model._nodeCommands;\n  var commandCount = nodeCommands.length;\n\n  for (var i = 0; i < commandCount; ++i) {\n    var nodeCommand = nodeCommands[i];\n    programId = nodeCommand.programId;\n    var renderProgram = rendererPrograms[programId];\n    nodeCommand.command.shaderProgram = renderProgram;\n\n    if (defined(nodeCommand.command2D)) {\n      nodeCommand.command2D.shaderProgram = renderProgram;\n    }\n  } // Force update silhouette commands/shaders\n\n\n  updateColor(model, frameState, true);\n  updateSilhouette(model, frameState, true);\n}\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see Model#destroy\n */\n\n\nModel.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * model = model && model.destroy();\n *\n * @see Model#isDestroyed\n */\n\n\nModel.prototype.destroy = function () {\n  // Vertex arrays are unique to this model, destroy here.\n  if (defined(this._precreatedAttributes)) {\n    destroy(this._rendererResources.vertexArrays);\n  }\n\n  if (defined(this._removeUpdateHeightCallback)) {\n    this._removeUpdateHeightCallback();\n\n    this._removeUpdateHeightCallback = undefined;\n  }\n\n  if (defined(this._terrainProviderChangedCallback)) {\n    this._terrainProviderChangedCallback();\n\n    this._terrainProviderChangedCallback = undefined;\n  } // Shaders modified for clipping and for color don't get cached, so destroy these manually\n\n\n  if (defined(this._cachedRendererResources)) {\n    destroyIfNotCached(this._rendererResources, this._cachedRendererResources);\n  }\n\n  this._rendererResources = undefined;\n  this._cachedRendererResources = this._cachedRendererResources && this._cachedRendererResources.release();\n  DracoLoader.destroyCachedDataForModel(this);\n  var pickIds = this._pickIds;\n  var length = pickIds.length;\n\n  for (var i = 0; i < length; ++i) {\n    pickIds[i].destroy();\n  }\n\n  releaseCachedGltf(this);\n  this._quantizedVertexShaders = undefined; // Only destroy the ClippingPlaneCollection if this is the owner - if this model is part of a Cesium3DTileset,\n  // _clippingPlanes references a ClippingPlaneCollection that this model does not own.\n\n  var clippingPlaneCollection = this._clippingPlanes;\n\n  if (defined(clippingPlaneCollection) && !clippingPlaneCollection.isDestroyed() && clippingPlaneCollection.owner === this) {\n    clippingPlaneCollection.destroy();\n  }\n\n  this._clippingPlanes = undefined;\n  this._specularEnvironmentMapAtlas = this._specularEnvironmentMapAtlas && this._specularEnvironmentMapAtlas.destroy();\n  return destroyObject(this);\n}; // exposed for testing\n\n\nModel._getClippingFunction = getClippingFunction;\nModel._modifyShaderForColor = modifyShaderForColor;\nexport default Model;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/Model.js"],"names":["BoundingSphere","Cartesian2","Cartesian3","Cartesian4","Cartographic","Check","clone","Color","combine","createGuid","Credit","defaultValue","defined","destroyObject","DeveloperError","DistanceDisplayCondition","FeatureDetection","getAbsoluteUri","getMagic","getStringFromTypedArray","IndexDatatype","loadCRN","loadImageFromTypedArray","loadKTX","CesiumMath","Matrix3","Matrix4","PixelFormat","PrimitiveType","Quaternion","Resource","Transforms","WebGLConstants","Buffer","BufferUsage","DrawCommand","Pass","RenderState","Sampler","ShaderProgram","ShaderSource","Texture","TextureMinificationFilter","TextureWrap","VertexArray","addDefaults","addPipelineExtras","ForEach","getAccessorByteStride","hasExtension","numberOfComponentsForType","parseGlb","updateVersion","when","Axis","BlendingState","ClippingPlaneCollection","ColorBlendMode","DepthFunction","DracoLoader","getClipAndStyleCode","getClippingFunction","HeightReference","JobType","ModelAnimationCache","ModelAnimationCollection","ModelLoadResources","ModelMaterial","ModelMesh","ModelNode","ModelOutlineLoader","ModelUtility","OctahedralProjectedCubeMap","processModelMaterialsCommon","processPbrMaterials","SceneMode","ShadowMode","boundingSphereCartesian3Scratch","ModelState","defaultModelAccept","articulationEpsilon","EPSILON16","setCachedGltf","model","cachedGltf","_cachedGltf","CachedGltf","options","_gltf","gltf","ready","modelsToLoad","count","Object","defineProperties","prototype","set","value","get","makeReady","gltfJson","models","length","i","m","isDestroyed","undefined","gltfCache","uriToGuid","Model","EMPTY_OBJECT","cacheKey","_cacheKey","_releaseGltfJson","releaseGltfJson","ArrayBuffer","Uint8Array","parsedGltf","basePath","_resource","createIfNeeded","credit","_credit","_resourceCredits","show","silhouetteColor","RED","_silhouetteColor","_silhouetteColorPreviousAlpha","_normalAttributeName","silhouetteSize","modelMatrix","IDENTITY","_modelMatrix","_clampedModelMatrix","scale","_scale","minimumPixelSize","_minimumPixelSize","maximumScale","_maximumScale","id","_id","heightReference","NONE","_heightReference","_heightChanged","_removeUpdateHeightCallback","scene","_scene","terrainProviderChanged","_terrainProviderChangedCallback","addEventListener","_pickObject","pickObject","_allowPicking","allowPicking","_ready","_readyPromise","defer","activeAnimations","clampAnimations","_defaultTexture","_incrementallyLoadTextures","incrementallyLoadTextures","_asynchronous","asynchronous","shadows","ENABLED","_shadows","color","WHITE","_colorPreviousAlpha","colorBlendMode","HIGHLIGHT","colorBlendAmount","_colorShadingEnabled","_clippingPlanes","clippingPlanes","_clippingPlanesState","clippingPlanesOriginMatrix","debugShowBoundingVolume","_debugShowBoundingVolume","debugWireframe","_debugWireframe","_distanceDisplayCondition","distanceDisplayCondition","_addBatchIdToGeneratedShaders","addBatchIdToGeneratedShaders","_precreatedAttributes","precreatedAttributes","_vertexShaderLoaded","vertexShaderLoaded","_fragmentShaderLoaded","fragmentShaderLoaded","_uniformMapLoaded","uniformMapLoaded","_pickIdLoaded","pickIdLoaded","_ignoreCommands","ignoreCommands","_requestType","requestType","_upAxis","upAxis","Y","_gltfForwardAxis","Z","_forwardAxis","forwardAxis","cull","opaquePass","OPAQUE","_computedModelMatrix","_clippingPlaneModelViewMatrix","_initialRadius","_boundingSphere","_scaledBoundingSphere","_state","NEEDS_LOAD","_loadResources","_mode","_perNodeShowDirty","_cesiumAnimationsDirty","_dirty","_maxDirtyNumber","_runtime","animations","articulationsByName","articulationsByStageKey","stagesByKey","rootNodes","nodes","nodesByName","skinnedNodes","meshesByName","materialsByName","materialsById","_uniformMaps","_extensionsUsed","_extensionsRequired","_quantizedUniforms","_programPrimitives","_rendererResources","buffers","vertexArrays","programs","sourceShaders","silhouettePrograms","textures","samplers","renderStates","_cachedRendererResources","_loadRendererResourcesFromCache","_dequantizeInShader","dequantizeInShader","_decodedData","_cachedGeometryByteLength","_cachedTexturesByteLength","_geometryByteLength","_texturesByteLength","_trianglesLength","_sourceTechniques","_sourcePrograms","_quantizedVertexShaders","_nodeCommands","_pickIds","_rtcCenter","_rtcCenterEye","_rtcCenter3D","_rtcCenter2D","_sourceVersion","_sourceKHRTechniquesWebGL","_imageBasedLightingFactor","imageBasedLightingFactor","_lightColor","lightColor","_luminanceAtZenith","luminanceAtZenith","_sphericalHarmonicCoefficients","sphericalHarmonicCoefficients","_specularEnvironmentMaps","specularEnvironmentMaps","_shouldUpdateSpecularMapAtlas","_specularEnvironmentMapAtlas","_useDefaultSphericalHarmonics","_useDefaultSpecularMaps","_shouldRegenerateShaders","url","boundingSphere","LOADED","nonUniformScale","getScale","Math","min","multiplyByScalar","scaledBoundingSphere","center","multiplyComponents","radius","maximumComponent","add","readyPromise","promise","pendingTextureLoads","dirty","far","near","extensionsUsed","getUsedExtensions","extensionsRequired","getRequiredExtensions","trianglesLength","geometryByteLength","texturesByteLength","cachedGeometryByteLength","cachedTexturesByteLength","setOwner","pickIds","typeOf","object","number","greaterThanOrEquals","x","lessThanOrEquals","y","equals","lum","Array","isArray","silhouetteSupported","context","stencilBuffer","isColorShadingEnabled","isClippingEnabled","enabled","containsGltfMagic","uint8Array","magic","fromGltf","modelResource","resource","push","headers","Accept","fetchArrayBuffer","then","arrayBuffer","array","json","JSON","parse","resourceCredits","credits","otherwise","getFailedLoadFunction","_gltfCache","getRuntime","runtimeName","name","getNode","node","publicNode","getMesh","getMaterial","setArticulationStage","articulationStageKey","stage","articulation","clamp","minimumValue","maximumValue","equalsEpsilon","currentValue","isDirty","scratchArticulationCartesian","scratchArticulationRotation","applyArticulationStageMatrix","result","cartesian","rotation","type","fromRotationX","toRadians","multiplyByMatrix3","fromRotationY","fromRotationZ","z","multiplyByTranslation","multiplyByScale","multiplyByUniformScale","scratchApplyArticulationTransform","applyArticulations","articulationName","hasOwnProperty","numNodes","n","transform","originalMatrix","numStages","stages","s","matrix","addBuffersToLoadResources","loadResources","buffer","extras","_pipeline","source","bufferLoad","pendingBufferLoads","parseBufferViews","bufferViews","vertexBuffersToCreate","bufferView","target","ARRAY_BUFFER","enqueue","indexBuffersToCreate","indexBufferIds","accessor","bufferViewId","ELEMENT_ARRAY_BUFFER","componentType","parseTechniques","sourcePrograms","sourceTechniques","extensions","KHR_techniques_webgl","technique","techniqueId","programId","program","shaderLoad","shaders","pendingShaderLoads","parseShaders","shader","bufferId","byteOffset","byteLength","shaderResource","getDerivedResource","uri","fetchText","parsePrograms","programsToCreate","parseArticulations","runtimeStagesByKey","AGI_articulations","gltfArticulations","articulations","numArticulations","initialValue","stageKey","imageLoad","textureId","image","texturesToCreate","width","height","internalFormat","ktxRegex","crnRegex","parseTextures","supportsWebP","images","texture","imageId","EXT_texture_webp","gltfImage","mimeType","compressedImage3DTiles","crunch","s3tc","pvrtc","pvrtc1","etc1","texturesToCreateFromBufferView","imageResource","test","fetchImage","scratchArticulationStageInitialTransform","parseNodes","runtimeNodes","runtimeNodesByName","skinnedNodesIds","runtimeNode","translation","computedShow","transformToRoot","computedMatrix","dirtyNumber","commands","inverseBindMatrices","bindShapeMatrix","joints","computedJointMatrices","jointName","weights","children","parents","getTransform","skin","parseMaterials","techniques","runtimeMaterialsByName","runtimeMaterialsById","uniformMaps","material","materialId","uniformMap","values","jointMatrixUniformName","morphWeightsUniformName","modelMaterial","_technique","_program","materialValue","uniformName","_values","parseMeshes","runtimeMeshesByName","mesh","meshId","WEB3D_quantized_attributes","meshPrimitive","primitive","primitiveId","getProgramForPrimitive","programPrimitives","CreateVertexBufferJob","execute","createVertexBuffer","createdBufferViews","vertexBuffer","typedArray","getBuffer","usage","STATIC_DRAW","vertexArrayDestroyable","sizeInBytes","CreateIndexBufferJob","createIndexBuffer","indexBuffer","indexDatatype","scratchVertexBufferJob","scratchIndexBufferJob","createBuffers","frameState","peek","jobScheduler","BUFFER","dequeue","modifyShaderForQuantizedAttributes","programName","primitives","uniforms","decodedData","modifyShaderForDracoQuantizedAttributes","attributes","modifyShaderForColor","replaceMain","modifyShader","callback","CreateProgramJob","programToCreate","createProgram","vs","vertexShader","fs","fragmentShader","quantizedVertexShaders","toClipCoordinatesGLSL","_toClipCoordinatesGLSL","quantizedVS","drawVS","drawFS","isInternetExplorer","modifyVertexShaderForLogDepth","modifyFragmentShaderForLogDepth","useIBL","isSupported","usesSH","usesSM","addMatrix","createAttributesAndProgram","recreateProgram","clippingPlaneCollection","addClippingPlaneCode","finalFS","_modifyShaderForColor","modifyShaderForClippingPlanes","attributeLocations","createAttributeLocations","fromCache","vertexShaderSource","fragmentShaderSource","scratchCreateProgramJob","createPrograms","PROGRAM","getOnImageCreatedFromTypedArray","gltfTexture","pendingBufferViewToImage","loadTexturesFromBufferViews","onerror","onload","format","flipY","createSamplers","rendererSamplers","sampler","samplerId","wrapS","wrapT","minificationFilter","minFilter","magnificationFilter","magFilter","CreateTextureJob","createTexture","REPEAT","usesTextureTransform","materials","materialsLength","valueName","indexOf","index","KHR_texture_transform","LINEAR","NEAREST","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","textureMinificationFilter","textureMagnificationFilter","mipmap","isCompressedFormat","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","requiresNpot","MIRRORED_REPEAT","tx","arrayBufferView","pixelFormat","npot","isPowerOfTwo","canvas","document","createElement","nextPowerOfTwo","canvasContext","getContext","drawImage","pixelDatatype","generateMipmap","scratchCreateTextureJob","createTextures","TEXTURE","getAttributeLocations","location","programVertexAttributes","vertexAttributes","programAttributeLocations","_attributeLocations","attribute","semantic","createJoints","runtimeSkins","skins","j","skinnedNode","runtimeSkin","gltfJoints","jointsLength","nodeId","jointNode","createSkins","accessors","getSkinInverseBindMatrices","getChannelEvaluator","targetPath","spline","localAnimationTime","clampTime","wrapTime","evaluate","createRuntimeAnimations","finishedPendingBufferLoads","animation","channels","startTime","Number","MAX_VALUE","stopTime","channelsLength","channelEvaluators","channel","path","input","getAnimationParameterValues","output","max","getAnimationSpline","createVertexArrays","finishedBuffersCreation","finishedProgramCreation","rendererBuffers","rendererVertexArrays","attributeLocation","meshPrimitiveAttribute","accessorId","attributeName","decodedAttributes","decodedAttribute","componentsPerAttribute","componentDatatype","normalize","normalized","offsetInBytes","strideInBytes","byteStride","a","indices","createRenderStates","createRenderStateForMaterial","rendererRenderStates","blendEquationSeparate","FUNC_ADD","blendFuncSeparate","ONE","ONE_MINUS_SRC_ALPHA","KHR_blend","blendEquation","blendFactors","enableCulling","doubleSided","blendingEnabled","alphaMode","depthTest","func","LESS_OR_EQUAL","depthMask","blending","equationRgb","equationAlpha","functionSourceRgb","functionDestinationRgb","functionSourceAlpha","functionDestinationAlpha","gltfUniformsFromNode","MODEL","uniformState","VIEW","view","PROJECTION","projection","MODELVIEW","mv","multiplyTransformation","CESIUM_RTC_MODELVIEW","mvRtc","setTranslation","MODELVIEWPROJECTION","mvp","multiply","_projection","MODELINVERSE","mInverse","inverse","VIEWINVERSE","inverseView","PROJECTIONINVERSE","inverseProjection","MODELVIEWINVERSE","mvInverse","MODELVIEWPROJECTIONINVERSE","mvpInverse","MODELINVERSETRANSPOSE","mInverseTranspose","getMatrix3","transpose","MODELVIEWINVERSETRANSPOSE","mvInverseTranspose","VIEWPORT","viewportCartesian4","getUniformFunctionFromSource","createUniformsForMaterial","instanceValues","defaultTexture","uniformValues","techniqueUniform","uniform","uv","createUniformFunction","alphaCutoffValue","alphaCutoff","getGltfSemanticUniforms","uv2","map","createUniformMaps","u","a_outlineCoordinates","outlineTexture","u_outlineTexture","createUniformsForDracoQuantizedAttributes","createUniformsForQuantizedAttributes","quantizedUniforms","createPickColorFunction","createJointMatricesFunction","createMorphWeightsFunction","createSilhouetteColorFunction","createSilhouetteSizeFunction","createColorFunction","scratchClippingPlaneMatrix","createClippingPlanesMatrixFunction","createClippingPlanesFunction","createClippingPlanesEdgeStyleFunction","withAlpha","style","edgeColor","alpha","edgeWidth","createColorBlendFunction","getColorBlend","createIBLFactorFunction","createLightColorFunction","createLuminanceAtZenithFunction","createSphericalHarmonicCoefficientsFunction","createSpecularEnvironmentMapFunction","createSpecularEnvironmentMapSizeFunction","dimensions","createSpecularEnvironmentMapLOD","maximumMipmapLevel","triangleCountFromPrimitiveIndices","indicesCount","mode","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","createCommand","gltfNode","scene3DOnly","nodeCommands","resources","rendererPrograms","gltfMeshes","meshes","ix","positionAccessor","POSITION","minMax","getAccessorMinMax","fromCornerPoints","fromArray","vertexArray","offset","numberOfIndices","getSizeInBytes","positions","um","jointUniformMap","morphWeightsUniformMap","gltf_color","gltf_colorBlend","gltf_clippingPlanes","gltf_clippingPlanesEdgeStyle","gltf_clippingPlanesMatrix","gltf_iblFactor","gltf_lightColor","gltf_sphericalHarmonicCoefficients","gltf_specularMap","gltf_specularMapSize","gltf_maxSpecularLOD","gltf_luminanceAtZenith","quantizedUniformMap","rs","isTranslucent","owner","castShadows","receiveShadows","pickId","createPickId","pickUniforms","czm_pickColor","command","boundingVolume","primitiveType","shaderProgram","renderState","pass","TRANSLUCENT","command2D","shallowClone","nodeCommand","silhouetteModelCommand","silhouetteModelCommand2D","silhouetteColorCommand","silhouetteColorCommand2D","translucentCommand","translucentCommand2D","createRuntimeNodes","finishedEverythingButTextureCreation","scenes","sceneNodes","stack","seen","parentRuntimeNode","pop","fromColumnMajorArray","unpack","childrenLength","childId","getGeometryByteLength","memory","getTexturesByteLength","createResources","toClipCoordinates","checkSupportedGlExtensions","glExtensions","cachedResources","getNodeMatrix","publicMatrix","useMatrix","fromTranslationQuaternionRotationScale","setMatrix","scratchNodeStack","scratchComputedTranslation","scratchComputedMatrixIn2D","updateNodeHierarchyModelMatrix","modelTransformChanged","justLoaded","maxDirtyNumber","nodeStack","computedModelMatrix","SCENE3D","getColumn","UNIT_W","basisTo2D","to2D","wgs84To2DModelMatrix","nodeMatrix","commandsLength","primitiveCommand","SCENE2D","sign","PI","ellipsoid","maximumRadius","k","child","scratchObjectSpace","applySkins","inverseTransformation","inverseBindMatricesLength","updatePerNodeShow","nodeCommandsLength","updatePickIds","updateWireframe","LINES","updateShowBoundingVolume","updateShadows","getTranslucentRenderState","ALPHA_BLEND","deriveTranslucentCommand","updateColor","forceDerive","getProgramId","createSilhouetteProgram","sources","normalAttributeName","hasSilhouette","hasTranslucentCommands","isInvisible","alphaDirty","currAlpha","prevAlpha","floor","ceil","silhouettesLength","createSilhouetteCommands","stencilReference","silhouetteTranslucent","modelCommand","stencilTest","frontFunction","ALWAYS","backFunction","reference","mask","frontOperation","fail","KEEP","zFail","zPass","REPLACE","backOperation","colorMask","red","green","blue","NOTEQUAL","silhouetteProgram","silhouetteUniformMap","gltf_silhouetteColor","gltf_silhouetteSize","_getClippingFunction","updateSilhouette","force","updateClippingPlanes","update","scratchBoundingSphere","scaleInPixels","positionWC","camera","getPixelSize","drawingBufferWidth","drawingBufferHeight","scratchPosition","scratchCartographic","maxPixelSize","mapProjection","cartographic","cartesianToCartographic","project","fromElements","metersPerPixel","pixelsPerMeter","diameterInPixels","releaseCachedGltf","CachedRendererResources","destroy","property","destroyCachedRendererResources","release","cache","modelRendererResourceCache","getUpdateHeightCallback","cartoPosition","clampedPosition","RELATIVE_TO_GROUND","clampedCart","cartographicToCartesian","clampedModelMatrix","updateClamping","globe","surface","_surface","updateHeight","getHeight","cb","scratchDisplayConditionCartesian","scratchDistanceDisplayConditionCartographic","distanceDisplayConditionVisible","distance2","ddc","nearSquared","farSquared","frustum2DWidth","frustum","right","left","position","getTranslation","COLUMBUS_VIEW","distanceSquared","MORPHING","initialized","initialize","cachedRendererResources","modelCaches","LOADING","FAILED","CESIUM_RTC","ZERO","projectedCart","parseBuffers","brdfLutGenerator","checkSupportedExtensions","updateForwardAxis","sourceVersion","getAssetVersion","sourceKHRTechniquesWebGL","finishedDecoding","decodeModel","resourcesParsed","computeBoundingSphere","cacheDataForModel","outlinePrimitives","finished","getAttributeOrUniformBySemantic","iblSupported","that","error","console","recompileWithDefaultAtlas","recompileWithoutDefaultAtlas","recompileWithDefaultSHCoeffs","recompileWithoutDefaultSHCoeffs","silhouette","translucent","invisible","displayConditionPassed","animated","modeChanged","Y_UP_TO_Z_UP","X","X_UP_TO_Z_UP","Z_UP_TO_X_UP","currentClippingPlanesState","useClippingPlanes","view3D","clippingPlanesState","shouldRegenerateShaders","currentlyColorShadingEnabled","regenerateShaders","afterRender","resolve","commandList","passes","nc","idl2D","render","pick","creditDisplay","addCredit","creditCount","c","destroyIfNotCached","rendererResources","visitedPrograms","commandCount","renderProgram","destroyCachedDataForModel"],"mappings":"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","sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport Credit from \"../Core/Credit.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport getAbsoluteUri from \"../Core/getAbsoluteUri.js\";\nimport getMagic from \"../Core/getMagic.js\";\nimport getStringFromTypedArray from \"../Core/getStringFromTypedArray.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport loadCRN from \"../Core/loadCRN.js\";\nimport loadImageFromTypedArray from \"../Core/loadImageFromTypedArray.js\";\nimport loadKTX from \"../Core/loadKTX.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Resource from \"../Core/Resource.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport addDefaults from \"../ThirdParty/GltfPipeline/addDefaults.js\";\nimport addPipelineExtras from \"../ThirdParty/GltfPipeline/addPipelineExtras.js\";\nimport ForEach from \"../ThirdParty/GltfPipeline/ForEach.js\";\nimport getAccessorByteStride from \"../ThirdParty/GltfPipeline/getAccessorByteStride.js\";\nimport hasExtension from \"../ThirdParty/GltfPipeline/hasExtension.js\";\nimport numberOfComponentsForType from \"../ThirdParty/GltfPipeline/numberOfComponentsForType.js\";\nimport parseGlb from \"../ThirdParty/GltfPipeline/parseGlb.js\";\nimport updateVersion from \"../ThirdParty/GltfPipeline/updateVersion.js\";\nimport when from \"../ThirdParty/when.js\";\nimport Axis from \"./Axis.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nimport ColorBlendMode from \"./ColorBlendMode.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport DracoLoader from \"./DracoLoader.js\";\nimport getClipAndStyleCode from \"./getClipAndStyleCode.js\";\nimport getClippingFunction from \"./getClippingFunction.js\";\nimport HeightReference from \"./HeightReference.js\";\nimport JobType from \"./JobType.js\";\nimport ModelAnimationCache from \"./ModelAnimationCache.js\";\nimport ModelAnimationCollection from \"./ModelAnimationCollection.js\";\nimport ModelLoadResources from \"./ModelLoadResources.js\";\nimport ModelMaterial from \"./ModelMaterial.js\";\nimport ModelMesh from \"./ModelMesh.js\";\nimport ModelNode from \"./ModelNode.js\";\nimport ModelOutlineLoader from \"./ModelOutlineLoader.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport OctahedralProjectedCubeMap from \"./OctahedralProjectedCubeMap.js\";\nimport processModelMaterialsCommon from \"./processModelMaterialsCommon.js\";\nimport processPbrMaterials from \"./processPbrMaterials.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\n\nvar boundingSphereCartesian3Scratch = new Cartesian3();\n\nvar ModelState = ModelUtility.ModelState;\n\n// glTF MIME types discussed in https://github.com/KhronosGroup/glTF/issues/412 and https://github.com/KhronosGroup/glTF/issues/943\nvar defaultModelAccept =\n  \"model/gltf-binary,model/gltf+json;q=0.8,application/json;q=0.2,*/*;q=0.01\";\n\nvar articulationEpsilon = CesiumMath.EPSILON16;\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction setCachedGltf(model, cachedGltf) {\n  model._cachedGltf = cachedGltf;\n}\n\n// glTF JSON can be big given embedded geometry, textures, and animations, so we\n// cache it across all models using the same url/cache-key.  This also reduces the\n// slight overhead in assigning defaults to missing values.\n//\n// Note that this is a global cache, compared to renderer resources, which\n// are cached per context.\nfunction CachedGltf(options) {\n  this._gltf = options.gltf;\n  this.ready = options.ready;\n  this.modelsToLoad = [];\n  this.count = 0;\n}\n\nObject.defineProperties(CachedGltf.prototype, {\n  gltf: {\n    set: function (value) {\n      this._gltf = value;\n    },\n\n    get: function () {\n      return this._gltf;\n    },\n  },\n});\n\nCachedGltf.prototype.makeReady = function (gltfJson) {\n  this.gltf = gltfJson;\n\n  var models = this.modelsToLoad;\n  var length = models.length;\n  for (var i = 0; i < length; ++i) {\n    var m = models[i];\n    if (!m.isDestroyed()) {\n      setCachedGltf(m, this);\n    }\n  }\n  this.modelsToLoad = undefined;\n  this.ready = true;\n};\n\nvar gltfCache = {};\nvar uriToGuid = {};\n///////////////////////////////////////////////////////////////////////////\n\n/**\n * A 3D model based on glTF, the runtime asset format for WebGL, OpenGL ES, and OpenGL.\n * <p>\n * Cesium includes support for geometry and materials, glTF animations, and glTF skinning.\n * In addition, individual glTF nodes are pickable with {@link Scene#pick} and animatable\n * with {@link Model#getNode}.  glTF cameras and lights are not currently supported.\n * </p>\n * <p>\n * An external glTF asset is created with {@link Model.fromGltf}.  glTF JSON can also be\n * created at runtime and passed to this constructor function.  In either case, the\n * {@link Model#readyPromise} is resolved when the model is ready to render, i.e.,\n * when the external binary, image, and shader files are downloaded and the WebGL\n * resources are created.\n * </p>\n * <p>\n * Cesium supports glTF assets with the following extensions:\n * <ul>\n * <li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/README.md|KHR_binary_glTF (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_materials_common/README.md|KHR_materials_common (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/WEB3D_quantized_attributes/README.md|WEB3D_quantized_attributes (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/AGI_articulations/README.md|AGI_articulations}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/pull/1302|KHR_blend (draft)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md|KHR_draco_mesh_compression}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/README.md|KHR_materials_pbrSpecularGlossiness}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit/README.md|KHR_materials_unlit}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_techniques_webgl/README.md|KHR_techniques_webgl}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_texture_transform/README.md|KHR_texture_transform}\n * </li>\n * </ul>\n * </p>\n * <p>\n * For high-precision rendering, Cesium supports the {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/CESIUM_RTC/README.md|CESIUM_RTC} extension, which introduces the\n * CESIUM_RTC_MODELVIEW parameter semantic that says the node is in WGS84 coordinates translated\n * relative to a local origin.\n * </p>\n *\n * @alias Model\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Object|ArrayBuffer|Uint8Array} [options.gltf] A glTF JSON object, or a binary glTF buffer.\n * @param {Resource|String} [options.basePath=''] The base path that paths in the glTF JSON are relative to.\n * @param {Boolean} [options.show=true] Determines if the model primitive will be shown.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the model from model to world coordinates.\n * @param {Number} [options.scale=1.0] A uniform scale applied to this model.\n * @param {Number} [options.minimumPixelSize=0.0] The approximate minimum pixel size of the model regardless of zoom.\n * @param {Number} [options.maximumScale] The maximum scale size of a model. An upper limit for minimumPixelSize.\n * @param {Object} [options.id] A user-defined object to return when the model is picked with {@link Scene#pick}.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each glTF mesh and primitive is pickable with {@link Scene#pick}.\n * @param {Boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the model is loaded.\n * @param {Boolean} [options.asynchronous=true] Determines if model WebGL resource creation will be spread out over several frames or block until completion once all glTF files are loaded.\n * @param {Boolean} [options.clampAnimations=true] Determines if the model's animations should hold a pose over frames where no keyframes are specified.\n * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the model casts or receives shadows from light sources.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Draws the bounding sphere for each draw command in the model.\n * @param {Boolean} [options.debugWireframe=false] For debugging only. Draws the model in wireframe.\n * @param {HeightReference} [options.heightReference=HeightReference.NONE] Determines how the model is drawn relative to terrain.\n * @param {Scene} [options.scene] Must be passed in for models that use the height reference property.\n * @param {DistanceDisplayCondition} [options.distanceDisplayCondition] The condition specifying at what distance from the camera that this model will be displayed.\n * @param {Color} [options.color=Color.WHITE] A color that blends with the model's rendered color.\n * @param {ColorBlendMode} [options.colorBlendMode=ColorBlendMode.HIGHLIGHT] Defines how the color blends with the model.\n * @param {Number} [options.colorBlendAmount=0.5] Value used to determine the color strength when the <code>colorBlendMode</code> is <code>MIX</code>. A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with any value in-between resulting in a mix of the two.\n * @param {Color} [options.silhouetteColor=Color.RED] The silhouette color. If more than 256 models have silhouettes enabled, there is a small chance that overlapping models will have minor artifacts.\n * @param {Number} [options.silhouetteSize=0.0] The size of the silhouette in pixels.\n * @param {ClippingPlaneCollection} [options.clippingPlanes] The {@link ClippingPlaneCollection} used to selectively disable rendering the model.\n * @param {Boolean} [options.dequantizeInShader=true] Determines if a {@link https://github.com/google/draco|Draco} encoded model is dequantized on the GPU. This decreases total memory usage for encoded models.\n * @param {Cartesian2} [options.imageBasedLightingFactor=Cartesian2(1.0, 1.0)] Scales diffuse and specular image-based lighting from the earth, sky, atmosphere and star skybox.\n * @param {Cartesian3} [options.lightColor] The light color when shading the model. When <code>undefined</code> the scene's light color is used instead.\n * @param {Number} [options.luminanceAtZenith=0.2] The sun's luminance at the zenith in kilo candela per meter squared to use for this model's procedural environment map.\n * @param {Cartesian3[]} [options.sphericalHarmonicCoefficients] The third order spherical harmonic coefficients used for the diffuse color of image-based lighting.\n * @param {String} [options.specularEnvironmentMaps] A URL to a KTX file that contains a cube map of the specular lighting and the convoluted specular mipmaps.\n * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.\n *\n * @see Model.fromGltf\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=3D%20Models.html|Cesium Sandcastle Models Demo}\n */\nfunction Model(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var cacheKey = options.cacheKey;\n  this._cacheKey = cacheKey;\n  this._cachedGltf = undefined;\n  this._releaseGltfJson = defaultValue(options.releaseGltfJson, false);\n\n  var cachedGltf;\n  if (\n    defined(cacheKey) &&\n    defined(gltfCache[cacheKey]) &&\n    gltfCache[cacheKey].ready\n  ) {\n    // glTF JSON is in cache and ready\n    cachedGltf = gltfCache[cacheKey];\n    ++cachedGltf.count;\n  } else {\n    // glTF was explicitly provided, e.g., when a user uses the Model constructor directly\n    var gltf = options.gltf;\n\n    if (defined(gltf)) {\n      if (gltf instanceof ArrayBuffer) {\n        gltf = new Uint8Array(gltf);\n      }\n\n      if (gltf instanceof Uint8Array) {\n        // Binary glTF\n        var parsedGltf = parseGlb(gltf);\n\n        cachedGltf = new CachedGltf({\n          gltf: parsedGltf,\n          ready: true,\n        });\n      } else {\n        // Normal glTF (JSON)\n        cachedGltf = new CachedGltf({\n          gltf: options.gltf,\n          ready: true,\n        });\n      }\n\n      cachedGltf.count = 1;\n\n      if (defined(cacheKey)) {\n        gltfCache[cacheKey] = cachedGltf;\n      }\n    }\n  }\n  setCachedGltf(this, cachedGltf);\n\n  var basePath = defaultValue(options.basePath, \"\");\n  this._resource = Resource.createIfNeeded(basePath);\n\n  // User specified credit\n  var credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  this._credit = credit;\n\n  // Create a list of Credit's so they can be added from the Resource later\n  this._resourceCredits = [];\n\n  /**\n   * Determines if the model primitive will be shown.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  /**\n   * The silhouette color.\n   *\n   * @type {Color}\n   *\n   * @default Color.RED\n   */\n  this.silhouetteColor = defaultValue(options.silhouetteColor, Color.RED);\n  this._silhouetteColor = new Color();\n  this._silhouetteColorPreviousAlpha = 1.0;\n  this._normalAttributeName = undefined;\n\n  /**\n   * The size of the silhouette in pixels.\n   *\n   * @type {Number}\n   *\n   * @default 0.0\n   */\n  this.silhouetteSize = defaultValue(options.silhouetteSize, 0.0);\n\n  /**\n   * The 4x4 transformation matrix that transforms the model from model to world coordinates.\n   * When this is the identity matrix, the model is drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type {Matrix4}\n   *\n   * @default {@link Matrix4.IDENTITY}\n   *\n   * @example\n   * var origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n   * m.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);\n   */\n  this.modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY)\n  );\n  this._modelMatrix = Matrix4.clone(this.modelMatrix);\n  this._clampedModelMatrix = undefined;\n\n  /**\n   * A uniform scale applied to this model before the {@link Model#modelMatrix}.\n   * Values greater than <code>1.0</code> increase the size of the model; values\n   * less than <code>1.0</code> decrease.\n   *\n   * @type {Number}\n   *\n   * @default 1.0\n   */\n  this.scale = defaultValue(options.scale, 1.0);\n  this._scale = this.scale;\n\n  /**\n   * The approximate minimum pixel size of the model regardless of zoom.\n   * This can be used to ensure that a model is visible even when the viewer\n   * zooms out.  When <code>0.0</code>, no minimum size is enforced.\n   *\n   * @type {Number}\n   *\n   * @default 0.0\n   */\n  this.minimumPixelSize = defaultValue(options.minimumPixelSize, 0.0);\n  this._minimumPixelSize = this.minimumPixelSize;\n\n  /**\n   * The maximum scale size for a model. This can be used to give\n   * an upper limit to the {@link Model#minimumPixelSize}, ensuring that the model\n   * is never an unreasonable scale.\n   *\n   * @type {Number}\n   */\n  this.maximumScale = options.maximumScale;\n  this._maximumScale = this.maximumScale;\n\n  /**\n   * User-defined object returned when the model is picked.\n   *\n   * @type Object\n   *\n   * @default undefined\n   *\n   * @see Scene#pick\n   */\n  this.id = options.id;\n  this._id = options.id;\n\n  /**\n   * Returns the height reference of the model\n   *\n   * @type {HeightReference}\n   *\n   * @default HeightReference.NONE\n   */\n  this.heightReference = defaultValue(\n    options.heightReference,\n    HeightReference.NONE\n  );\n  this._heightReference = this.heightReference;\n  this._heightChanged = false;\n  this._removeUpdateHeightCallback = undefined;\n  var scene = options.scene;\n  this._scene = scene;\n  if (defined(scene) && defined(scene.terrainProviderChanged)) {\n    this._terrainProviderChangedCallback = scene.terrainProviderChanged.addEventListener(\n      function () {\n        this._heightChanged = true;\n      },\n      this\n    );\n  }\n\n  /**\n   * Used for picking primitives that wrap a model.\n   *\n   * @private\n   */\n  this._pickObject = options.pickObject;\n  this._allowPicking = defaultValue(options.allowPicking, true);\n\n  this._ready = false;\n  this._readyPromise = when.defer();\n\n  /**\n   * The currently playing glTF animations.\n   *\n   * @type {ModelAnimationCollection}\n   */\n  this.activeAnimations = new ModelAnimationCollection(this);\n\n  /**\n   * Determines if the model's animations should hold a pose over frames where no keyframes are specified.\n   *\n   * @type {Boolean}\n   */\n  this.clampAnimations = defaultValue(options.clampAnimations, true);\n\n  this._defaultTexture = undefined;\n  this._incrementallyLoadTextures = defaultValue(\n    options.incrementallyLoadTextures,\n    true\n  );\n  this._asynchronous = defaultValue(options.asynchronous, true);\n\n  /**\n   * Determines whether the model casts or receives shadows from light sources.\n   *\n   * @type {ShadowMode}\n   *\n   * @default ShadowMode.ENABLED\n   */\n  this.shadows = defaultValue(options.shadows, ShadowMode.ENABLED);\n  this._shadows = this.shadows;\n\n  /**\n   * A color that blends with the model's rendered color.\n   *\n   * @type {Color}\n   *\n   * @default Color.WHITE\n   */\n  this.color = Color.clone(defaultValue(options.color, Color.WHITE));\n  this._colorPreviousAlpha = 1.0;\n\n  /**\n   * Defines how the color blends with the model.\n   *\n   * @type {ColorBlendMode}\n   *\n   * @default ColorBlendMode.HIGHLIGHT\n   */\n  this.colorBlendMode = defaultValue(\n    options.colorBlendMode,\n    ColorBlendMode.HIGHLIGHT\n  );\n\n  /**\n   * Value used to determine the color strength when the <code>colorBlendMode</code> is <code>MIX</code>.\n   * A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with\n   * any value in-between resulting in a mix of the two.\n   *\n   * @type {Number}\n   *\n   * @default 0.5\n   */\n  this.colorBlendAmount = defaultValue(options.colorBlendAmount, 0.5);\n\n  this._colorShadingEnabled = false;\n\n  this._clippingPlanes = undefined;\n  this.clippingPlanes = options.clippingPlanes;\n  // Used for checking if shaders need to be regenerated due to clipping plane changes.\n  this._clippingPlanesState = 0;\n  // If defined, use this matrix to position the clipping planes instead of the modelMatrix.\n  // This is so that when models are part of a tileset they all get clipped relative\n  // to the root tile.\n  this.clippingPlanesOriginMatrix = undefined;\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the model.  A glTF primitive corresponds\n   * to one draw command.  A glTF mesh has an array of primitives, often of length one.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false\n  );\n  this._debugShowBoundingVolume = false;\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the model in wireframe.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugWireframe = defaultValue(options.debugWireframe, false);\n  this._debugWireframe = false;\n\n  this._distanceDisplayCondition = options.distanceDisplayCondition;\n\n  // Undocumented options\n  this._addBatchIdToGeneratedShaders = options.addBatchIdToGeneratedShaders;\n  this._precreatedAttributes = options.precreatedAttributes;\n  this._vertexShaderLoaded = options.vertexShaderLoaded;\n  this._fragmentShaderLoaded = options.fragmentShaderLoaded;\n  this._uniformMapLoaded = options.uniformMapLoaded;\n  this._pickIdLoaded = options.pickIdLoaded;\n  this._ignoreCommands = defaultValue(options.ignoreCommands, false);\n  this._requestType = options.requestType;\n  this._upAxis = defaultValue(options.upAxis, Axis.Y);\n  this._gltfForwardAxis = Axis.Z;\n  this._forwardAxis = options.forwardAxis;\n\n  /**\n   * @private\n   * @readonly\n   */\n  this.cull = defaultValue(options.cull, true);\n\n  /**\n   * @private\n   * @readonly\n   */\n  this.opaquePass = defaultValue(options.opaquePass, Pass.OPAQUE);\n\n  this._computedModelMatrix = new Matrix4(); // Derived from modelMatrix and scale\n  this._clippingPlaneModelViewMatrix = Matrix4.clone(Matrix4.IDENTITY); // Derived from modelMatrix, scale, and the current view matrix\n  this._initialRadius = undefined; // Radius without model's scale property, model-matrix scale, animations, or skins\n  this._boundingSphere = undefined;\n  this._scaledBoundingSphere = new BoundingSphere();\n  this._state = ModelState.NEEDS_LOAD;\n  this._loadResources = undefined;\n\n  this._mode = undefined;\n\n  this._perNodeShowDirty = false; // true when the Cesium API was used to change a node's show property\n  this._cesiumAnimationsDirty = false; // true when the Cesium API, not a glTF animation, changed a node transform\n  this._dirty = false; // true when the model was transformed this frame\n  this._maxDirtyNumber = 0; // Used in place of a dirty boolean flag to avoid an extra graph traversal\n\n  this._runtime = {\n    animations: undefined,\n    articulationsByName: undefined,\n    articulationsByStageKey: undefined,\n    stagesByKey: undefined,\n    rootNodes: undefined,\n    nodes: undefined, // Indexed with the node's index\n    nodesByName: undefined, // Indexed with name property in the node\n    skinnedNodes: undefined,\n    meshesByName: undefined, // Indexed with the name property in the mesh\n    materialsByName: undefined, // Indexed with the name property in the material\n    materialsById: undefined, // Indexed with the material's index\n  };\n\n  this._uniformMaps = {}; // Not cached since it can be targeted by glTF animation\n  this._extensionsUsed = undefined; // Cached used glTF extensions\n  this._extensionsRequired = undefined; // Cached required glTF extensions\n  this._quantizedUniforms = {}; // Quantized uniforms for each program for WEB3D_quantized_attributes\n  this._programPrimitives = {};\n  this._rendererResources = {\n    // Cached between models with the same url/cache-key\n    buffers: {},\n    vertexArrays: {},\n    programs: {},\n    sourceShaders: {},\n    silhouettePrograms: {},\n    textures: {},\n    samplers: {},\n    renderStates: {},\n  };\n  this._cachedRendererResources = undefined;\n  this._loadRendererResourcesFromCache = false;\n\n  this._dequantizeInShader = defaultValue(options.dequantizeInShader, true);\n  this._decodedData = {};\n\n  this._cachedGeometryByteLength = 0;\n  this._cachedTexturesByteLength = 0;\n  this._geometryByteLength = 0;\n  this._texturesByteLength = 0;\n  this._trianglesLength = 0;\n\n  // Hold references for shader reconstruction.\n  // Hold these separately because _cachedGltf may get released (this.releaseGltfJson)\n  this._sourceTechniques = {};\n  this._sourcePrograms = {};\n  this._quantizedVertexShaders = {};\n\n  this._nodeCommands = [];\n  this._pickIds = [];\n\n  // CESIUM_RTC extension\n  this._rtcCenter = undefined; // reference to either 3D or 2D\n  this._rtcCenterEye = undefined; // in eye coordinates\n  this._rtcCenter3D = undefined; // in world coordinates\n  this._rtcCenter2D = undefined; // in projected world coordinates\n\n  this._sourceVersion = undefined;\n  this._sourceKHRTechniquesWebGL = undefined;\n\n  this._imageBasedLightingFactor = new Cartesian2(1.0, 1.0);\n  Cartesian2.clone(\n    options.imageBasedLightingFactor,\n    this._imageBasedLightingFactor\n  );\n  this._lightColor = Cartesian3.clone(options.lightColor);\n\n  this._luminanceAtZenith = undefined;\n  this.luminanceAtZenith = defaultValue(options.luminanceAtZenith, 0.2);\n\n  this._sphericalHarmonicCoefficients = options.sphericalHarmonicCoefficients;\n  this._specularEnvironmentMaps = options.specularEnvironmentMaps;\n  this._shouldUpdateSpecularMapAtlas = true;\n  this._specularEnvironmentMapAtlas = undefined;\n\n  this._useDefaultSphericalHarmonics = false;\n  this._useDefaultSpecularMaps = false;\n\n  this._shouldRegenerateShaders = false;\n}\n\nObject.defineProperties(Model.prototype, {\n  /**\n   * The object for the glTF JSON, including properties with default values omitted\n   * from the JSON provided to this model.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Object}\n   * @readonly\n   *\n   * @default undefined\n   */\n  gltf: {\n    get: function () {\n      return defined(this._cachedGltf) ? this._cachedGltf.gltf : undefined;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the glTF JSON is not stored with the model once the model is\n   * loaded (when {@link Model#ready} is <code>true</code>).  This saves memory when\n   * geometry, textures, and animations are embedded in the .gltf file.\n   * This is especially useful for cases like 3D buildings, where each .gltf model is unique\n   * and caching the glTF JSON is not effective.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   *\n   * @private\n   */\n  releaseGltfJson: {\n    get: function () {\n      return this._releaseGltfJson;\n    },\n  },\n\n  /**\n   * The key identifying this model in the model cache for glTF JSON, renderer resources, and animations.\n   * Caching saves memory and improves loading speed when several models with the same url are created.\n   * <p>\n   * This key is automatically generated when the model is created with {@link Model.fromGltf}.  If the model\n   * is created directly from glTF JSON using the {@link Model} constructor, this key can be manually\n   * provided; otherwise, the model will not be changed.\n   * </p>\n   *\n   * @memberof Model.prototype\n   *\n   * @type {String}\n   * @readonly\n   *\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    },\n  },\n\n  /**\n   * The base path that paths in the glTF JSON are relative to.  The base\n   * path is the same path as the path containing the .gltf file\n   * minus the .gltf file, when binary, image, and shader files are\n   * in the same directory as the .gltf.  When this is <code>''</code>,\n   * the app's base path is used.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {String}\n   * @readonly\n   *\n   * @default ''\n   */\n  basePath: {\n    get: function () {\n      return this._resource.url;\n    },\n  },\n\n  /**\n   * The model's bounding sphere in its local coordinate system.  This does not take into\n   * account glTF animations and skins nor does it take into account {@link Model#minimumPixelSize}.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   *\n   * @default undefined\n   *\n   * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n   *\n   * @example\n   * // Center in WGS84 coordinates\n   * var center = Cesium.Matrix4.multiplyByPoint(model.modelMatrix, model.boundingSphere.center, new Cesium.Cartesian3());\n   */\n  boundingSphere: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (this._state !== ModelState.LOADED) {\n        throw new DeveloperError(\n          \"The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      var modelMatrix = this.modelMatrix;\n      if (\n        this.heightReference !== HeightReference.NONE &&\n        this._clampedModelMatrix\n      ) {\n        modelMatrix = this._clampedModelMatrix;\n      }\n\n      var nonUniformScale = Matrix4.getScale(\n        modelMatrix,\n        boundingSphereCartesian3Scratch\n      );\n      var scale = defined(this.maximumScale)\n        ? Math.min(this.maximumScale, this.scale)\n        : this.scale;\n      Cartesian3.multiplyByScalar(nonUniformScale, scale, nonUniformScale);\n\n      var scaledBoundingSphere = this._scaledBoundingSphere;\n      scaledBoundingSphere.center = Cartesian3.multiplyComponents(\n        this._boundingSphere.center,\n        nonUniformScale,\n        scaledBoundingSphere.center\n      );\n      scaledBoundingSphere.radius =\n        Cartesian3.maximumComponent(nonUniformScale) * this._initialRadius;\n\n      if (defined(this._rtcCenter)) {\n        Cartesian3.add(\n          this._rtcCenter,\n          scaledBoundingSphere.center,\n          scaledBoundingSphere.center\n        );\n      }\n\n      return scaledBoundingSphere;\n    },\n  },\n\n  /**\n   * When <code>true</code>, this model is ready to render, i.e., the external binary, image,\n   * and shader files were downloaded and the WebGL resources were created.  This is set to\n   * <code>true</code> right before {@link Model#readyPromise} is resolved.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets the promise that will be resolved when this model is ready to render, i.e., when the external binary, image,\n   * and shader files were downloaded and the WebGL resources were created.\n   * <p>\n   * This promise is resolved at the end of the frame before the first frame the model is rendered in.\n   * </p>\n   *\n   * @memberof Model.prototype\n   * @type {Promise.<Model>}\n   * @readonly\n   *\n   * @example\n   * // Play all animations at half-speed when the model is ready to render\n   * Cesium.when(model.readyPromise).then(function(model) {\n   *   model.activeAnimations.addAll({\n   *     multiplier : 0.5\n   *   });\n   * }).otherwise(function(error){\n   *   window.alert(error);\n   * });\n   *\n   * @see Model#ready\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n\n  /**\n   * Determines if model WebGL resource creation will be spread out over several frames or\n   * block until completion once all glTF files are loaded.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._asynchronous;\n    },\n  },\n\n  /**\n   * When <code>true</code>, each glTF mesh and primitive is pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._allowPicking;\n    },\n  },\n\n  /**\n   * Determine if textures may continue to stream in after the model is loaded.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  incrementallyLoadTextures: {\n    get: function () {\n      return this._incrementallyLoadTextures;\n    },\n  },\n\n  /**\n   * Return the number of pending texture loads.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  pendingTextureLoads: {\n    get: function () {\n      return defined(this._loadResources)\n        ? this._loadResources.pendingTextureLoads\n        : 0;\n    },\n  },\n\n  /**\n   * Returns true if the model was transformed this frame\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @private\n   */\n  dirty: {\n    get: function () {\n      return this._dirty;\n    },\n  },\n\n  /**\n   * Gets or sets the condition specifying at what distance from the camera that this model will be displayed.\n   * @memberof Model.prototype\n   * @type {DistanceDisplayCondition}\n   * @default undefined\n   */\n  distanceDisplayCondition: {\n    get: function () {\n      return this._distanceDisplayCondition;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\"far must be greater than near\");\n      }\n      //>>includeEnd('debug');\n      this._distanceDisplayCondition = DistanceDisplayCondition.clone(\n        value,\n        this._distanceDisplayCondition\n      );\n    },\n  },\n\n  extensionsUsed: {\n    get: function () {\n      if (!defined(this._extensionsUsed)) {\n        this._extensionsUsed = ModelUtility.getUsedExtensions(this.gltf);\n      }\n      return this._extensionsUsed;\n    },\n  },\n\n  extensionsRequired: {\n    get: function () {\n      if (!defined(this._extensionsRequired)) {\n        this._extensionsRequired = ModelUtility.getRequiredExtensions(\n          this.gltf\n        );\n      }\n      return this._extensionsRequired;\n    },\n  },\n\n  /**\n   * Gets the model's up-axis.\n   * By default models are y-up according to the glTF spec, however geo-referenced models will typically be z-up.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Number}\n   * @default Axis.Y\n   * @readonly\n   *\n   * @private\n   */\n  upAxis: {\n    get: function () {\n      return this._upAxis;\n    },\n  },\n\n  /**\n   * Gets the model's forward axis.\n   * By default, glTF 2.0 models are z-forward according to the glTF spec, however older\n   * glTF (1.0, 0.8) models used x-forward.  Note that only Axis.X and Axis.Z are supported.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Number}\n   * @default Axis.Z\n   * @readonly\n   *\n   * @private\n   */\n  forwardAxis: {\n    get: function () {\n      if (defined(this._forwardAxis)) {\n        return this._forwardAxis;\n      }\n      return this._gltfForwardAxis;\n    },\n  },\n\n  /**\n   * Gets the model's triangle count.\n   *\n   * @private\n   */\n  trianglesLength: {\n    get: function () {\n      return this._trianglesLength;\n    },\n  },\n\n  /**\n   * Gets the model's geometry memory in bytes. This includes all vertex and index buffers.\n   *\n   * @private\n   */\n  geometryByteLength: {\n    get: function () {\n      return this._geometryByteLength;\n    },\n  },\n\n  /**\n   * Gets the model's texture memory in bytes.\n   *\n   * @private\n   */\n  texturesByteLength: {\n    get: function () {\n      return this._texturesByteLength;\n    },\n  },\n\n  /**\n   * Gets the model's cached geometry memory in bytes. This includes all vertex and index buffers.\n   *\n   * @private\n   */\n  cachedGeometryByteLength: {\n    get: function () {\n      return this._cachedGeometryByteLength;\n    },\n  },\n\n  /**\n   * Gets the model's cached texture memory in bytes.\n   *\n   * @private\n   */\n  cachedTexturesByteLength: {\n    get: function () {\n      return this._cachedTexturesByteLength;\n    },\n  },\n\n  /**\n   * The {@link ClippingPlaneCollection} used to selectively disable rendering the model.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {ClippingPlaneCollection}\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._clippingPlanes;\n    },\n    set: function (value) {\n      if (value === this._clippingPlanes) {\n        return;\n      }\n      // Handle destroying, checking of unknown, checking for existing ownership\n      ClippingPlaneCollection.setOwner(value, this, \"_clippingPlanes\");\n    },\n  },\n\n  /**\n   * @private\n   */\n  pickIds: {\n    get: function () {\n      return this._pickIds;\n    },\n  },\n\n  /**\n   * Cesium adds lighting from the earth, sky, atmosphere, and star skybox. This cartesian is used to scale the final\n   * diffuse and specular lighting contribution from those sources to the final color. A value of 0.0 will disable those light sources.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Cartesian2}\n   * @default Cartesian2(1.0, 1.0)\n   */\n  imageBasedLightingFactor: {\n    get: function () {\n      return this._imageBasedLightingFactor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.object(\"imageBasedLightingFactor\", value);\n      Check.typeOf.number.greaterThanOrEquals(\n        \"imageBasedLightingFactor.x\",\n        value.x,\n        0.0\n      );\n      Check.typeOf.number.lessThanOrEquals(\n        \"imageBasedLightingFactor.x\",\n        value.x,\n        1.0\n      );\n      Check.typeOf.number.greaterThanOrEquals(\n        \"imageBasedLightingFactor.y\",\n        value.y,\n        0.0\n      );\n      Check.typeOf.number.lessThanOrEquals(\n        \"imageBasedLightingFactor.y\",\n        value.y,\n        1.0\n      );\n      //>>includeEnd('debug');\n      var imageBasedLightingFactor = this._imageBasedLightingFactor;\n      if (\n        value === imageBasedLightingFactor ||\n        Cartesian2.equals(value, imageBasedLightingFactor)\n      ) {\n        return;\n      }\n      this._shouldRegenerateShaders =\n        this._shouldRegenerateShaders ||\n        (this._imageBasedLightingFactor.x > 0.0 && value.x === 0.0) ||\n        (this._imageBasedLightingFactor.x === 0.0 && value.x > 0.0);\n      this._shouldRegenerateShaders =\n        this._shouldRegenerateShaders ||\n        (this._imageBasedLightingFactor.y > 0.0 && value.y === 0.0) ||\n        (this._imageBasedLightingFactor.y === 0.0 && value.y > 0.0);\n      Cartesian2.clone(value, this._imageBasedLightingFactor);\n    },\n  },\n\n  /**\n   * The light color when shading the model. When <code>undefined</code> the scene's light color is used instead.\n   * <p>\n   * For example, disabling additional light sources by setting <code>model.imageBasedLightingFactor = new Cesium.Cartesian2(0.0, 0.0)</code> will make the\n   * model much darker. Here, increasing the intensity of the light source will make the model brighter.\n   * </p>\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Cartesian3}\n   * @default undefined\n   */\n  lightColor: {\n    get: function () {\n      return this._lightColor;\n    },\n    set: function (value) {\n      var lightColor = this._lightColor;\n      if (value === lightColor || Cartesian3.equals(value, lightColor)) {\n        return;\n      }\n      this._shouldRegenerateShaders =\n        this._shouldRegenerateShaders ||\n        (defined(lightColor) && !defined(value)) ||\n        (defined(value) && !defined(lightColor));\n      this._lightColor = Cartesian3.clone(value, lightColor);\n    },\n  },\n\n  /**\n   * The sun's luminance at the zenith in kilo candela per meter squared to use for this model's procedural environment map.\n   * This is used when {@link Model#specularEnvironmentMaps} and {@link Model#sphericalHarmonicCoefficients} are not defined.\n   *\n   * @memberof Model.prototype\n   *\n   * @demo {@link https://sandcastle.cesium.com/index.html?src=Image-Based Lighting.html|Sandcastle Image Based Lighting Demo}\n   * @type {Number}\n   * @default 0.2\n   */\n  luminanceAtZenith: {\n    get: function () {\n      return this._luminanceAtZenith;\n    },\n    set: function (value) {\n      var lum = this._luminanceAtZenith;\n      if (value === lum) {\n        return;\n      }\n      this._shouldRegenerateShaders =\n        this._shouldRegenerateShaders ||\n        (defined(lum) && !defined(value)) ||\n        (defined(value) && !defined(lum));\n      this._luminanceAtZenith = value;\n    },\n  },\n\n  /**\n   * The third order spherical harmonic coefficients used for the diffuse color of image-based lighting. When <code>undefined</code>, a diffuse irradiance\n   * computed from the atmosphere color is used.\n   * <p>\n   * There are nine <code>Cartesian3</code> coefficients.\n   * The order of the coefficients is: L<sub>00</sub>, L<sub>1-1</sub>, L<sub>10</sub>, L<sub>11</sub>, L<sub>2-2</sub>, L<sub>2-1</sub>, L<sub>20</sub>, L<sub>21</sub>, L<sub>22</sub>\n   * </p>\n   *\n   * These values can be obtained by preprocessing the environment map using the <code>cmgen</code> tool of\n   * {@link https://github.com/google/filament/releases|Google's Filament project}. This will also generate a KTX file that can be\n   * supplied to {@link Model#specularEnvironmentMaps}.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Cartesian3[]}\n   * @demo {@link https://sandcastle.cesium.com/index.html?src=Image-Based Lighting.html|Sandcastle Image Based Lighting Demo}\n   * @see {@link https://graphics.stanford.edu/papers/envmap/envmap.pdf|An Efficient Representation for Irradiance Environment Maps}\n   */\n  sphericalHarmonicCoefficients: {\n    get: function () {\n      return this._sphericalHarmonicCoefficients;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && (!Array.isArray(value) || value.length !== 9)) {\n        throw new DeveloperError(\n          \"sphericalHarmonicCoefficients must be an array of 9 Cartesian3 values.\"\n        );\n      }\n      //>>includeEnd('debug');\n      if (value === this._sphericalHarmonicCoefficients) {\n        return;\n      }\n      this._sphericalHarmonicCoefficients = value;\n      this._shouldRegenerateShaders = true;\n    },\n  },\n\n  /**\n   * A URL to a KTX file that contains a cube map of the specular lighting and the convoluted specular mipmaps.\n   *\n   * @memberof Model.prototype\n   * @demo {@link https://sandcastle.cesium.com/index.html?src=Image-Based Lighting.html|Sandcastle Image Based Lighting Demo}\n   * @type {String}\n   * @see Model#sphericalHarmonicCoefficients\n   */\n  specularEnvironmentMaps: {\n    get: function () {\n      return this._specularEnvironmentMaps;\n    },\n    set: function (value) {\n      this._shouldUpdateSpecularMapAtlas =\n        this._shouldUpdateSpecularMapAtlas ||\n        value !== this._specularEnvironmentMaps;\n      this._specularEnvironmentMaps = value;\n    },\n  },\n  /**\n   * Gets the credit that will be displayed for the model\n   * @memberof Model.prototype\n   * @type {Credit}\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n});\n\nfunction silhouetteSupported(context) {\n  return context.stencilBuffer;\n}\n\nfunction isColorShadingEnabled(model) {\n  return (\n    !Color.equals(model.color, Color.WHITE) ||\n    model.colorBlendMode !== ColorBlendMode.HIGHLIGHT\n  );\n}\n\nfunction isClippingEnabled(model) {\n  var clippingPlanes = model._clippingPlanes;\n  return (\n    defined(clippingPlanes) &&\n    clippingPlanes.enabled &&\n    clippingPlanes.length !== 0\n  );\n}\n\n/**\n * Determines if silhouettes are supported.\n *\n * @param {Scene} scene The scene.\n * @returns {Boolean} <code>true</code> if silhouettes are supported; otherwise, returns <code>false</code>\n */\nModel.silhouetteSupported = function (scene) {\n  return silhouetteSupported(scene.context);\n};\n\nfunction containsGltfMagic(uint8Array) {\n  var magic = getMagic(uint8Array);\n  return magic === \"glTF\";\n}\n\n/**\n * <p>\n * Creates a model from a glTF asset.  When the model is ready to render, i.e., when the external binary, image,\n * and shader files are downloaded and the WebGL resources are created, the {@link Model#readyPromise} is resolved.\n * </p>\n * <p>\n * The model can be a traditional glTF asset with a .gltf extension or a Binary glTF using the .glb extension.\n * </p>\n * <p>\n * Cesium supports glTF assets with the following extensions:\n * <ul>\n * <li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/README.md|KHR_binary_glTF (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_materials_common/README.md|KHR_materials_common (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/WEB3D_quantized_attributes/README.md|WEB3D_quantized_attributes (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/AGI_articulations/README.md|AGI_articulations}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/pull/1302|KHR_blend (draft)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md|KHR_draco_mesh_compression}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/README.md|KHR_materials_pbrSpecularGlossiness}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit/README.md|KHR_materials_unlit}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_techniques_webgl/README.md|KHR_techniques_webgl}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_texture_transform/README.md|KHR_texture_transform}\n * </li>\n * </ul>\n * </p>\n * <p>\n * For high-precision rendering, Cesium supports the {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/CESIUM_RTC/README.md|CESIUM_RTC} extension, which introduces the\n * CESIUM_RTC_MODELVIEW parameter semantic that says the node is in WGS84 coordinates translated\n * relative to a local origin.\n * </p>\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource|String} options.url The url to the .gltf file.\n * @param {Resource|String} [options.basePath] The base path that paths in the glTF JSON are relative to.\n * @param {Boolean} [options.show=true] Determines if the model primitive will be shown.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the model from model to world coordinates.\n * @param {Number} [options.scale=1.0] A uniform scale applied to this model.\n * @param {Number} [options.minimumPixelSize=0.0] The approximate minimum pixel size of the model regardless of zoom.\n * @param {Number} [options.maximumScale] The maximum scale for the model.\n * @param {Object} [options.id] A user-defined object to return when the model is picked with {@link Scene#pick}.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each glTF mesh and primitive is pickable with {@link Scene#pick}.\n * @param {Boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the model is loaded.\n * @param {Boolean} [options.asynchronous=true] Determines if model WebGL resource creation will be spread out over several frames or block until completion once all glTF files are loaded.\n * @param {Boolean} [options.clampAnimations=true] Determines if the model's animations should hold a pose over frames where no keyframes are specified.\n * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the model casts or receives shadows from light sources.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Draws the bounding sphere for each draw command in the model.\n * @param {Boolean} [options.debugWireframe=false] For debugging only. Draws the model in wireframe.\n * @param {HeightReference} [options.heightReference=HeightReference.NONE] Determines how the model is drawn relative to terrain.\n * @param {Scene} [options.scene] Must be passed in for models that use the height reference property.\n * @param {DistanceDisplayCondition} [options.distanceDisplayCondition] The condition specifying at what distance from the camera that this model will be displayed.\n * @param {Color} [options.color=Color.WHITE] A color that blends with the model's rendered color.\n * @param {ColorBlendMode} [options.colorBlendMode=ColorBlendMode.HIGHLIGHT] Defines how the color blends with the model.\n * @param {Number} [options.colorBlendAmount=0.5] Value used to determine the color strength when the <code>colorBlendMode</code> is <code>MIX</code>. A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with any value in-between resulting in a mix of the two.\n * @param {Color} [options.silhouetteColor=Color.RED] The silhouette color. If more than 256 models have silhouettes enabled, there is a small chance that overlapping models will have minor artifacts.\n * @param {Number} [options.silhouetteSize=0.0] The size of the silhouette in pixels.\n * @param {ClippingPlaneCollection} [options.clippingPlanes] The {@link ClippingPlaneCollection} used to selectively disable rendering the model.\n * @param {Boolean} [options.dequantizeInShader=true] Determines if a {@link https://github.com/google/draco|Draco} encoded model is dequantized on the GPU. This decreases total memory usage for encoded models.\n * @param {Credit|String} [options.credit] A credit for the model, which is displayed on the canvas.\n *\n * @returns {Model} The newly created model.\n *\n * @example\n * // Example 1. Create a model from a glTF asset\n * var model = scene.primitives.add(Cesium.Model.fromGltf({\n *   url : './duck/duck.gltf'\n * }));\n *\n * @example\n * // Example 2. Create model and provide all properties and events\n * var origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n * var modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);\n *\n * var model = scene.primitives.add(Cesium.Model.fromGltf({\n *   url : './duck/duck.gltf',\n *   show : true,                     // default\n *   modelMatrix : modelMatrix,\n *   scale : 2.0,                     // double size\n *   minimumPixelSize : 128,          // never smaller than 128 pixels\n *   maximumScale: 20000,             // never larger than 20000 * model size (overrides minimumPixelSize)\n *   allowPicking : false,            // not pickable\n *   debugShowBoundingVolume : false, // default\n *   debugWireframe : false\n * }));\n *\n * model.readyPromise.then(function(model) {\n *   // Play all animations when the model is ready to render\n *   model.activeAnimations.addAll();\n * });\n */\nModel.fromGltf = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.url)) {\n    throw new DeveloperError(\"options.url is required\");\n  }\n  //>>includeEnd('debug');\n\n  var url = options.url;\n  options = clone(options);\n\n  // Create resource for the model file\n  var modelResource = Resource.createIfNeeded(url);\n\n  // Setup basePath to get dependent files\n  var basePath = defaultValue(options.basePath, modelResource.clone());\n  var resource = Resource.createIfNeeded(basePath);\n\n  // If no cache key is provided, use a GUID.\n  // Check using a URI to GUID dictionary that we have not already added this model.\n  var cacheKey = defaultValue(\n    options.cacheKey,\n    uriToGuid[getAbsoluteUri(modelResource.url)]\n  );\n  if (!defined(cacheKey)) {\n    cacheKey = createGuid();\n    uriToGuid[getAbsoluteUri(modelResource.url)] = cacheKey;\n  }\n\n  if (defined(options.basePath) && !defined(options.cacheKey)) {\n    cacheKey += resource.url;\n  }\n  options.cacheKey = cacheKey;\n  options.basePath = resource;\n\n  var model = new Model(options);\n\n  var cachedGltf = gltfCache[cacheKey];\n  if (!defined(cachedGltf)) {\n    cachedGltf = new CachedGltf({\n      ready: false,\n    });\n    cachedGltf.count = 1;\n    cachedGltf.modelsToLoad.push(model);\n    setCachedGltf(model, cachedGltf);\n    gltfCache[cacheKey] = cachedGltf;\n\n    // Add Accept header if we need it\n    if (!defined(modelResource.headers.Accept)) {\n      modelResource.headers.Accept = defaultModelAccept;\n    }\n\n    modelResource\n      .fetchArrayBuffer()\n      .then(function (arrayBuffer) {\n        var array = new Uint8Array(arrayBuffer);\n        if (containsGltfMagic(array)) {\n          // Load binary glTF\n          var parsedGltf = parseGlb(array);\n          cachedGltf.makeReady(parsedGltf);\n        } else {\n          // Load text (JSON) glTF\n          var json = getStringFromTypedArray(array);\n          cachedGltf.makeReady(JSON.parse(json));\n        }\n\n        var resourceCredits = model._resourceCredits;\n        var credits = modelResource.credits;\n        if (defined(credits)) {\n          var length = credits.length;\n          for (var i = 0; i < length; i++) {\n            resourceCredits.push(credits[i]);\n          }\n        }\n      })\n      .otherwise(\n        ModelUtility.getFailedLoadFunction(model, \"model\", modelResource.url)\n      );\n  } else if (!cachedGltf.ready) {\n    // Cache hit but the fetchArrayBuffer() or fetchText() request is still pending\n    ++cachedGltf.count;\n    cachedGltf.modelsToLoad.push(model);\n  }\n  // else if the cached glTF is defined and ready, the\n  // model constructor will pick it up using the cache key.\n\n  return model;\n};\n\n/**\n * For the unit tests to verify model caching.\n *\n * @private\n */\nModel._gltfCache = gltfCache;\n\nfunction getRuntime(model, runtimeName, name) {\n  //>>includeStart('debug', pragmas.debug);\n  if (model._state !== ModelState.LOADED) {\n    throw new DeveloperError(\n      \"The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\"\n    );\n  }\n\n  if (!defined(name)) {\n    throw new DeveloperError(\"name is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return model._runtime[runtimeName][name];\n}\n\n/**\n * Returns the glTF node with the given <code>name</code> property.  This is used to\n * modify a node's transform for animation outside of glTF animations.\n *\n * @param {String} name The glTF name of the node.\n * @returns {ModelNode} The node or <code>undefined</code> if no node with <code>name</code> exists.\n *\n * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n *\n * @example\n * // Apply non-uniform scale to node LOD3sp\n * var node = model.getNode('LOD3sp');\n * node.matrix = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(5.0, 1.0, 1.0), node.matrix);\n */\nModel.prototype.getNode = function (name) {\n  var node = getRuntime(this, \"nodesByName\", name);\n  return defined(node) ? node.publicNode : undefined;\n};\n\n/**\n * Returns the glTF mesh with the given <code>name</code> property.\n *\n * @param {String} name The glTF name of the mesh.\n *\n * @returns {ModelMesh} The mesh or <code>undefined</code> if no mesh with <code>name</code> exists.\n *\n * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n */\nModel.prototype.getMesh = function (name) {\n  return getRuntime(this, \"meshesByName\", name);\n};\n\n/**\n * Returns the glTF material with the given <code>name</code> property.\n *\n * @param {String} name The glTF name of the material.\n * @returns {ModelMaterial} The material or <code>undefined</code> if no material with <code>name</code> exists.\n *\n * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n */\nModel.prototype.getMaterial = function (name) {\n  return getRuntime(this, \"materialsByName\", name);\n};\n\n/**\n * Sets the current value of an articulation stage.  After setting one or multiple stage values, call\n * Model.applyArticulations() to cause the node matrices to be recalculated.\n *\n * @param {String} articulationStageKey The name of the articulation, a space, and the name of the stage.\n * @param {Number} value The numeric value of this stage of the articulation.\n *\n * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n *\n * @see Model#applyArticulations\n */\nModel.prototype.setArticulationStage = function (articulationStageKey, value) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"value\", value);\n  //>>includeEnd('debug');\n\n  var stage = getRuntime(this, \"stagesByKey\", articulationStageKey);\n  var articulation = getRuntime(\n    this,\n    \"articulationsByStageKey\",\n    articulationStageKey\n  );\n  if (defined(stage) && defined(articulation)) {\n    value = CesiumMath.clamp(value, stage.minimumValue, stage.maximumValue);\n    if (\n      !CesiumMath.equalsEpsilon(stage.currentValue, value, articulationEpsilon)\n    ) {\n      stage.currentValue = value;\n      articulation.isDirty = true;\n    }\n  }\n};\n\nvar scratchArticulationCartesian = new Cartesian3();\nvar scratchArticulationRotation = new Matrix3();\n\n/**\n * Modifies a Matrix4 by applying a transformation for a given value of a stage.  Note this is different usage\n * from the typical <code>result</code> parameter, in that the incoming value of <code>result</code> is\n * meaningful.  Various stages of an articulation can be multiplied together, so their\n * transformations are all merged into a composite Matrix4 representing them all.\n *\n * @param {object} stage The stage of an articulation that is being evaluated.\n * @param {Matrix4} result The matrix to be modified.\n * @returns {Matrix4} A matrix transformed as requested by the articulation stage.\n *\n * @private\n */\nfunction applyArticulationStageMatrix(stage, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"stage\", stage);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var value = stage.currentValue;\n  var cartesian = scratchArticulationCartesian;\n  var rotation;\n  switch (stage.type) {\n    case \"xRotate\":\n      rotation = Matrix3.fromRotationX(\n        CesiumMath.toRadians(value),\n        scratchArticulationRotation\n      );\n      Matrix4.multiplyByMatrix3(result, rotation, result);\n      break;\n    case \"yRotate\":\n      rotation = Matrix3.fromRotationY(\n        CesiumMath.toRadians(value),\n        scratchArticulationRotation\n      );\n      Matrix4.multiplyByMatrix3(result, rotation, result);\n      break;\n    case \"zRotate\":\n      rotation = Matrix3.fromRotationZ(\n        CesiumMath.toRadians(value),\n        scratchArticulationRotation\n      );\n      Matrix4.multiplyByMatrix3(result, rotation, result);\n      break;\n    case \"xTranslate\":\n      cartesian.x = value;\n      cartesian.y = 0.0;\n      cartesian.z = 0.0;\n      Matrix4.multiplyByTranslation(result, cartesian, result);\n      break;\n    case \"yTranslate\":\n      cartesian.x = 0.0;\n      cartesian.y = value;\n      cartesian.z = 0.0;\n      Matrix4.multiplyByTranslation(result, cartesian, result);\n      break;\n    case \"zTranslate\":\n      cartesian.x = 0.0;\n      cartesian.y = 0.0;\n      cartesian.z = value;\n      Matrix4.multiplyByTranslation(result, cartesian, result);\n      break;\n    case \"xScale\":\n      cartesian.x = value;\n      cartesian.y = 1.0;\n      cartesian.z = 1.0;\n      Matrix4.multiplyByScale(result, cartesian, result);\n      break;\n    case \"yScale\":\n      cartesian.x = 1.0;\n      cartesian.y = value;\n      cartesian.z = 1.0;\n      Matrix4.multiplyByScale(result, cartesian, result);\n      break;\n    case \"zScale\":\n      cartesian.x = 1.0;\n      cartesian.y = 1.0;\n      cartesian.z = value;\n      Matrix4.multiplyByScale(result, cartesian, result);\n      break;\n    case \"uniformScale\":\n      Matrix4.multiplyByUniformScale(result, value, result);\n      break;\n    default:\n      break;\n  }\n  return result;\n}\n\nvar scratchApplyArticulationTransform = new Matrix4();\n\n/**\n * Applies any modified articulation stages to the matrix of each node that participates\n * in any articulation.  Note that this will overwrite any nodeTransformations on participating nodes.\n *\n * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n */\nModel.prototype.applyArticulations = function () {\n  var articulationsByName = this._runtime.articulationsByName;\n  for (var articulationName in articulationsByName) {\n    if (articulationsByName.hasOwnProperty(articulationName)) {\n      var articulation = articulationsByName[articulationName];\n      if (articulation.isDirty) {\n        articulation.isDirty = false;\n        var numNodes = articulation.nodes.length;\n        for (var n = 0; n < numNodes; ++n) {\n          var node = articulation.nodes[n];\n          var transform = Matrix4.clone(\n            node.originalMatrix,\n            scratchApplyArticulationTransform\n          );\n\n          var numStages = articulation.stages.length;\n          for (var s = 0; s < numStages; ++s) {\n            var stage = articulation.stages[s];\n            transform = applyArticulationStageMatrix(stage, transform);\n          }\n          node.matrix = transform;\n        }\n      }\n    }\n  }\n};\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction addBuffersToLoadResources(model) {\n  var gltf = model.gltf;\n  var loadResources = model._loadResources;\n  ForEach.buffer(gltf, function (buffer, id) {\n    loadResources.buffers[id] = buffer.extras._pipeline.source;\n  });\n}\n\nfunction bufferLoad(model, id) {\n  return function (arrayBuffer) {\n    var loadResources = model._loadResources;\n    var buffer = new Uint8Array(arrayBuffer);\n    --loadResources.pendingBufferLoads;\n    model.gltf.buffers[id].extras._pipeline.source = buffer;\n  };\n}\n\nfunction parseBufferViews(model) {\n  var bufferViews = model.gltf.bufferViews;\n  var vertexBuffersToCreate = model._loadResources.vertexBuffersToCreate;\n\n  // Only ARRAY_BUFFER here.  ELEMENT_ARRAY_BUFFER created below.\n  ForEach.bufferView(model.gltf, function (bufferView, id) {\n    if (bufferView.target === WebGLConstants.ARRAY_BUFFER) {\n      vertexBuffersToCreate.enqueue(id);\n    }\n  });\n\n  var indexBuffersToCreate = model._loadResources.indexBuffersToCreate;\n  var indexBufferIds = {};\n\n  // The Cesium Renderer requires knowing the datatype for an index buffer\n  // at creation type, which is not part of the glTF bufferview so loop\n  // through glTF accessors to create the bufferview's index buffer.\n  ForEach.accessor(model.gltf, function (accessor) {\n    var bufferViewId = accessor.bufferView;\n    if (!defined(bufferViewId)) {\n      return;\n    }\n\n    var bufferView = bufferViews[bufferViewId];\n    if (\n      bufferView.target === WebGLConstants.ELEMENT_ARRAY_BUFFER &&\n      !defined(indexBufferIds[bufferViewId])\n    ) {\n      indexBufferIds[bufferViewId] = true;\n      indexBuffersToCreate.enqueue({\n        id: bufferViewId,\n        componentType: accessor.componentType,\n      });\n    }\n  });\n}\n\nfunction parseTechniques(model) {\n  // retain references to gltf techniques\n  var gltf = model.gltf;\n  if (!hasExtension(gltf, \"KHR_techniques_webgl\")) {\n    return;\n  }\n\n  var sourcePrograms = model._sourcePrograms;\n  var sourceTechniques = model._sourceTechniques;\n  var programs = gltf.extensions.KHR_techniques_webgl.programs;\n\n  ForEach.technique(gltf, function (technique, techniqueId) {\n    sourceTechniques[techniqueId] = clone(technique);\n\n    var programId = technique.program;\n    if (!defined(sourcePrograms[programId])) {\n      sourcePrograms[programId] = clone(programs[programId]);\n    }\n  });\n}\n\nfunction shaderLoad(model, type, id) {\n  return function (source) {\n    var loadResources = model._loadResources;\n    loadResources.shaders[id] = {\n      source: source,\n      type: type,\n      bufferView: undefined,\n    };\n    --loadResources.pendingShaderLoads;\n    model._rendererResources.sourceShaders[id] = source;\n  };\n}\n\nfunction parseShaders(model) {\n  var gltf = model.gltf;\n  var buffers = gltf.buffers;\n  var bufferViews = gltf.bufferViews;\n  var sourceShaders = model._rendererResources.sourceShaders;\n  ForEach.shader(gltf, function (shader, id) {\n    // Shader references either uri (external or base64-encoded) or bufferView\n    if (defined(shader.bufferView)) {\n      var bufferViewId = shader.bufferView;\n      var bufferView = bufferViews[bufferViewId];\n      var bufferId = bufferView.buffer;\n      var buffer = buffers[bufferId];\n      var source = getStringFromTypedArray(\n        buffer.extras._pipeline.source,\n        bufferView.byteOffset,\n        bufferView.byteLength\n      );\n      sourceShaders[id] = source;\n    } else if (defined(shader.extras._pipeline.source)) {\n      sourceShaders[id] = shader.extras._pipeline.source;\n    } else {\n      ++model._loadResources.pendingShaderLoads;\n\n      var shaderResource = model._resource.getDerivedResource({\n        url: shader.uri,\n      });\n\n      shaderResource\n        .fetchText()\n        .then(shaderLoad(model, shader.type, id))\n        .otherwise(\n          ModelUtility.getFailedLoadFunction(\n            model,\n            \"shader\",\n            shaderResource.url\n          )\n        );\n    }\n  });\n}\n\nfunction parsePrograms(model) {\n  var sourceTechniques = model._sourceTechniques;\n  for (var techniqueId in sourceTechniques) {\n    if (sourceTechniques.hasOwnProperty(techniqueId)) {\n      var technique = sourceTechniques[techniqueId];\n      model._loadResources.programsToCreate.enqueue({\n        programId: technique.program,\n        techniqueId: techniqueId,\n      });\n    }\n  }\n}\n\nfunction parseArticulations(model) {\n  var articulationsByName = {};\n  var articulationsByStageKey = {};\n  var runtimeStagesByKey = {};\n\n  model._runtime.articulationsByName = articulationsByName;\n  model._runtime.articulationsByStageKey = articulationsByStageKey;\n  model._runtime.stagesByKey = runtimeStagesByKey;\n\n  var gltf = model.gltf;\n  if (\n    !hasExtension(gltf, \"AGI_articulations\") ||\n    !defined(gltf.extensions) ||\n    !defined(gltf.extensions.AGI_articulations)\n  ) {\n    return;\n  }\n\n  var gltfArticulations = gltf.extensions.AGI_articulations.articulations;\n  if (!defined(gltfArticulations)) {\n    return;\n  }\n\n  var numArticulations = gltfArticulations.length;\n  for (var i = 0; i < numArticulations; ++i) {\n    var articulation = clone(gltfArticulations[i]);\n    articulation.nodes = [];\n    articulation.isDirty = true;\n    articulationsByName[articulation.name] = articulation;\n\n    var numStages = articulation.stages.length;\n    for (var s = 0; s < numStages; ++s) {\n      var stage = articulation.stages[s];\n      stage.currentValue = stage.initialValue;\n\n      var stageKey = articulation.name + \" \" + stage.name;\n      articulationsByStageKey[stageKey] = articulation;\n      runtimeStagesByKey[stageKey] = stage;\n    }\n  }\n}\n\nfunction imageLoad(model, textureId) {\n  return function (image) {\n    var loadResources = model._loadResources;\n    --loadResources.pendingTextureLoads;\n    loadResources.texturesToCreate.enqueue({\n      id: textureId,\n      image: image,\n      bufferView: image.bufferView,\n      width: image.width,\n      height: image.height,\n      internalFormat: image.internalFormat,\n    });\n  };\n}\n\nvar ktxRegex = /(^data:image\\/ktx)|(\\.ktx$)/i;\nvar crnRegex = /(^data:image\\/crn)|(\\.crn$)/i;\n\nfunction parseTextures(model, context, supportsWebP) {\n  var gltf = model.gltf;\n  var images = gltf.images;\n  var uri;\n  ForEach.texture(gltf, function (texture, id) {\n    var imageId = texture.source;\n\n    if (\n      defined(texture.extensions) &&\n      defined(texture.extensions.EXT_texture_webp) &&\n      supportsWebP\n    ) {\n      imageId = texture.extensions.EXT_texture_webp.source;\n    }\n\n    var gltfImage = images[imageId];\n    var extras = gltfImage.extras;\n\n    var bufferViewId = gltfImage.bufferView;\n    var mimeType = gltfImage.mimeType;\n    uri = gltfImage.uri;\n\n    // First check for a compressed texture\n    if (defined(extras) && defined(extras.compressedImage3DTiles)) {\n      var crunch = extras.compressedImage3DTiles.crunch;\n      var s3tc = extras.compressedImage3DTiles.s3tc;\n      var pvrtc = extras.compressedImage3DTiles.pvrtc1;\n      var etc1 = extras.compressedImage3DTiles.etc1;\n\n      if (context.s3tc && defined(crunch)) {\n        mimeType = crunch.mimeType;\n        if (defined(crunch.bufferView)) {\n          bufferViewId = crunch.bufferView;\n        } else {\n          uri = crunch.uri;\n        }\n      } else if (context.s3tc && defined(s3tc)) {\n        mimeType = s3tc.mimeType;\n        if (defined(s3tc.bufferView)) {\n          bufferViewId = s3tc.bufferView;\n        } else {\n          uri = s3tc.uri;\n        }\n      } else if (context.pvrtc && defined(pvrtc)) {\n        mimeType = pvrtc.mimeType;\n        if (defined(pvrtc.bufferView)) {\n          bufferViewId = pvrtc.bufferView;\n        } else {\n          uri = pvrtc.uri;\n        }\n      } else if (context.etc1 && defined(etc1)) {\n        mimeType = etc1.mimeType;\n        if (defined(etc1.bufferView)) {\n          bufferViewId = etc1.bufferView;\n        } else {\n          uri = etc1.uri;\n        }\n      }\n    }\n\n    // Image references either uri (external or base64-encoded) or bufferView\n    if (defined(bufferViewId)) {\n      model._loadResources.texturesToCreateFromBufferView.enqueue({\n        id: id,\n        image: undefined,\n        bufferView: bufferViewId,\n        mimeType: mimeType,\n      });\n    } else {\n      ++model._loadResources.pendingTextureLoads;\n\n      var imageResource = model._resource.getDerivedResource({\n        url: uri,\n      });\n\n      var promise;\n      if (ktxRegex.test(uri)) {\n        promise = loadKTX(imageResource);\n      } else if (crnRegex.test(uri)) {\n        promise = loadCRN(imageResource);\n      } else {\n        promise = imageResource.fetchImage();\n      }\n      promise\n        .then(imageLoad(model, id, imageId))\n        .otherwise(\n          ModelUtility.getFailedLoadFunction(model, \"image\", imageResource.url)\n        );\n    }\n  });\n}\n\nvar scratchArticulationStageInitialTransform = new Matrix4();\n\nfunction parseNodes(model) {\n  var runtimeNodes = {};\n  var runtimeNodesByName = {};\n  var skinnedNodes = [];\n\n  var skinnedNodesIds = model._loadResources.skinnedNodesIds;\n  var articulationsByName = model._runtime.articulationsByName;\n\n  ForEach.node(model.gltf, function (node, id) {\n    var runtimeNode = {\n      // Animation targets\n      matrix: undefined,\n      translation: undefined,\n      rotation: undefined,\n      scale: undefined,\n\n      // Per-node show inherited from parent\n      computedShow: true,\n\n      // Computed transforms\n      transformToRoot: new Matrix4(),\n      computedMatrix: new Matrix4(),\n      dirtyNumber: 0, // The frame this node was made dirty by an animation; for graph traversal\n\n      // Rendering\n      commands: [], // empty for transform, light, and camera nodes\n\n      // Skinned node\n      inverseBindMatrices: undefined, // undefined when node is not skinned\n      bindShapeMatrix: undefined, // undefined when node is not skinned or identity\n      joints: [], // empty when node is not skinned\n      computedJointMatrices: [], // empty when node is not skinned\n\n      // Joint node\n      jointName: node.jointName, // undefined when node is not a joint\n\n      weights: [],\n\n      // Graph pointers\n      children: [], // empty for leaf nodes\n      parents: [], // empty for root nodes\n\n      // Publicly-accessible ModelNode instance to modify animation targets\n      publicNode: undefined,\n    };\n    runtimeNode.publicNode = new ModelNode(\n      model,\n      node,\n      runtimeNode,\n      id,\n      ModelUtility.getTransform(node)\n    );\n\n    runtimeNodes[id] = runtimeNode;\n    runtimeNodesByName[node.name] = runtimeNode;\n\n    if (defined(node.skin)) {\n      skinnedNodesIds.push(id);\n      skinnedNodes.push(runtimeNode);\n    }\n\n    if (\n      defined(node.extensions) &&\n      defined(node.extensions.AGI_articulations)\n    ) {\n      var articulationName = node.extensions.AGI_articulations.articulationName;\n      if (defined(articulationName)) {\n        var transform = Matrix4.clone(\n          runtimeNode.publicNode.originalMatrix,\n          scratchArticulationStageInitialTransform\n        );\n        var articulation = articulationsByName[articulationName];\n        articulation.nodes.push(runtimeNode.publicNode);\n\n        var numStages = articulation.stages.length;\n        for (var s = 0; s < numStages; ++s) {\n          var stage = articulation.stages[s];\n          transform = applyArticulationStageMatrix(stage, transform);\n        }\n        runtimeNode.publicNode.matrix = transform;\n      }\n    }\n  });\n\n  model._runtime.nodes = runtimeNodes;\n  model._runtime.nodesByName = runtimeNodesByName;\n  model._runtime.skinnedNodes = skinnedNodes;\n}\n\nfunction parseMaterials(model) {\n  var gltf = model.gltf;\n  var techniques = model._sourceTechniques;\n\n  var runtimeMaterialsByName = {};\n  var runtimeMaterialsById = {};\n  var uniformMaps = model._uniformMaps;\n\n  ForEach.material(gltf, function (material, materialId) {\n    // Allocated now so ModelMaterial can keep a reference to it.\n    uniformMaps[materialId] = {\n      uniformMap: undefined,\n      values: undefined,\n      jointMatrixUniformName: undefined,\n      morphWeightsUniformName: undefined,\n    };\n\n    var modelMaterial = new ModelMaterial(model, material, materialId);\n\n    if (\n      defined(material.extensions) &&\n      defined(material.extensions.KHR_techniques_webgl)\n    ) {\n      var techniqueId = material.extensions.KHR_techniques_webgl.technique;\n      modelMaterial._technique = techniqueId;\n      modelMaterial._program = techniques[techniqueId].program;\n\n      ForEach.materialValue(material, function (value, uniformName) {\n        if (!defined(modelMaterial._values)) {\n          modelMaterial._values = {};\n        }\n\n        modelMaterial._values[uniformName] = clone(value);\n      });\n    }\n\n    runtimeMaterialsByName[material.name] = modelMaterial;\n    runtimeMaterialsById[materialId] = modelMaterial;\n  });\n\n  model._runtime.materialsByName = runtimeMaterialsByName;\n  model._runtime.materialsById = runtimeMaterialsById;\n}\n\nfunction parseMeshes(model) {\n  var runtimeMeshesByName = {};\n  var runtimeMaterialsById = model._runtime.materialsById;\n\n  ForEach.mesh(model.gltf, function (mesh, meshId) {\n    runtimeMeshesByName[mesh.name] = new ModelMesh(\n      mesh,\n      runtimeMaterialsById,\n      meshId\n    );\n    if (\n      defined(model.extensionsUsed.WEB3D_quantized_attributes) ||\n      model._dequantizeInShader\n    ) {\n      // Cache primitives according to their program\n      ForEach.meshPrimitive(mesh, function (primitive, primitiveId) {\n        var programId = getProgramForPrimitive(model, primitive);\n        var programPrimitives = model._programPrimitives[programId];\n        if (!defined(programPrimitives)) {\n          programPrimitives = {};\n          model._programPrimitives[programId] = programPrimitives;\n        }\n        programPrimitives[meshId + \".primitive.\" + primitiveId] = primitive;\n      });\n    }\n  });\n\n  model._runtime.meshesByName = runtimeMeshesByName;\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nvar CreateVertexBufferJob = function () {\n  this.id = undefined;\n  this.model = undefined;\n  this.context = undefined;\n};\n\nCreateVertexBufferJob.prototype.set = function (id, model, context) {\n  this.id = id;\n  this.model = model;\n  this.context = context;\n};\n\nCreateVertexBufferJob.prototype.execute = function () {\n  createVertexBuffer(this.id, this.model, this.context);\n};\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction createVertexBuffer(bufferViewId, model, context) {\n  var loadResources = model._loadResources;\n  var bufferViews = model.gltf.bufferViews;\n  var bufferView = bufferViews[bufferViewId];\n\n  // Use bufferView created at runtime\n  if (!defined(bufferView)) {\n    bufferView = loadResources.createdBufferViews[bufferViewId];\n  }\n\n  var vertexBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: loadResources.getBuffer(bufferView),\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  vertexBuffer.vertexArrayDestroyable = false;\n  model._rendererResources.buffers[bufferViewId] = vertexBuffer;\n  model._geometryByteLength += vertexBuffer.sizeInBytes;\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nvar CreateIndexBufferJob = function () {\n  this.id = undefined;\n  this.componentType = undefined;\n  this.model = undefined;\n  this.context = undefined;\n};\n\nCreateIndexBufferJob.prototype.set = function (\n  id,\n  componentType,\n  model,\n  context\n) {\n  this.id = id;\n  this.componentType = componentType;\n  this.model = model;\n  this.context = context;\n};\n\nCreateIndexBufferJob.prototype.execute = function () {\n  createIndexBuffer(this.id, this.componentType, this.model, this.context);\n};\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction createIndexBuffer(bufferViewId, componentType, model, context) {\n  var loadResources = model._loadResources;\n  var bufferViews = model.gltf.bufferViews;\n  var bufferView = bufferViews[bufferViewId];\n\n  // Use bufferView created at runtime\n  if (!defined(bufferView)) {\n    bufferView = loadResources.createdBufferViews[bufferViewId];\n  }\n\n  var indexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: loadResources.getBuffer(bufferView),\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: componentType,\n  });\n  indexBuffer.vertexArrayDestroyable = false;\n  model._rendererResources.buffers[bufferViewId] = indexBuffer;\n  model._geometryByteLength += indexBuffer.sizeInBytes;\n}\n\nvar scratchVertexBufferJob = new CreateVertexBufferJob();\nvar scratchIndexBufferJob = new CreateIndexBufferJob();\n\nfunction createBuffers(model, frameState) {\n  var loadResources = model._loadResources;\n\n  if (loadResources.pendingBufferLoads !== 0) {\n    return;\n  }\n\n  var context = frameState.context;\n  var vertexBuffersToCreate = loadResources.vertexBuffersToCreate;\n  var indexBuffersToCreate = loadResources.indexBuffersToCreate;\n  var i;\n\n  if (model.asynchronous) {\n    while (vertexBuffersToCreate.length > 0) {\n      scratchVertexBufferJob.set(vertexBuffersToCreate.peek(), model, context);\n      if (\n        !frameState.jobScheduler.execute(scratchVertexBufferJob, JobType.BUFFER)\n      ) {\n        break;\n      }\n      vertexBuffersToCreate.dequeue();\n    }\n\n    while (indexBuffersToCreate.length > 0) {\n      i = indexBuffersToCreate.peek();\n      scratchIndexBufferJob.set(i.id, i.componentType, model, context);\n      if (\n        !frameState.jobScheduler.execute(scratchIndexBufferJob, JobType.BUFFER)\n      ) {\n        break;\n      }\n      indexBuffersToCreate.dequeue();\n    }\n  } else {\n    while (vertexBuffersToCreate.length > 0) {\n      createVertexBuffer(vertexBuffersToCreate.dequeue(), model, context);\n    }\n\n    while (indexBuffersToCreate.length > 0) {\n      i = indexBuffersToCreate.dequeue();\n      createIndexBuffer(i.id, i.componentType, model, context);\n    }\n  }\n}\n\nfunction getProgramForPrimitive(model, primitive) {\n  var material = model._runtime.materialsById[primitive.material];\n  if (!defined(material)) {\n    return;\n  }\n\n  return material._program;\n}\n\nfunction modifyShaderForQuantizedAttributes(shader, programName, model) {\n  var primitive;\n  var primitives = model._programPrimitives[programName];\n\n  // If no primitives were cached for this program, there's no need to modify the shader\n  if (!defined(primitives)) {\n    return shader;\n  }\n\n  var primitiveId;\n  for (primitiveId in primitives) {\n    if (primitives.hasOwnProperty(primitiveId)) {\n      primitive = primitives[primitiveId];\n      if (getProgramForPrimitive(model, primitive) === programName) {\n        break;\n      }\n    }\n  }\n\n  // This is not needed after the program is processed, free the memory\n  model._programPrimitives[programName] = undefined;\n\n  var result;\n  if (model.extensionsUsed.WEB3D_quantized_attributes) {\n    result = ModelUtility.modifyShaderForQuantizedAttributes(\n      model.gltf,\n      primitive,\n      shader\n    );\n    model._quantizedUniforms[programName] = result.uniforms;\n  } else {\n    var decodedData = model._decodedData[primitiveId];\n    if (defined(decodedData)) {\n      result = ModelUtility.modifyShaderForDracoQuantizedAttributes(\n        model.gltf,\n        primitive,\n        shader,\n        decodedData.attributes\n      );\n    } else {\n      return shader;\n    }\n  }\n\n  return result.shader;\n}\n\nfunction modifyShaderForColor(shader) {\n  shader = ShaderSource.replaceMain(shader, \"gltf_blend_main\");\n  shader +=\n    \"uniform vec4 gltf_color; \\n\" +\n    \"uniform float gltf_colorBlend; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    gltf_blend_main(); \\n\" +\n    \"    gl_FragColor.rgb = mix(gl_FragColor.rgb, gltf_color.rgb, gltf_colorBlend); \\n\" +\n    \"    float highlight = ceil(gltf_colorBlend); \\n\" +\n    \"    gl_FragColor.rgb *= mix(gltf_color.rgb, vec3(1.0), highlight); \\n\" +\n    \"    gl_FragColor.a *= gltf_color.a; \\n\" +\n    \"} \\n\";\n\n  return shader;\n}\n\nfunction modifyShader(shader, programName, callback) {\n  if (defined(callback)) {\n    shader = callback(shader, programName);\n  }\n  return shader;\n}\n\nvar CreateProgramJob = function () {\n  this.programToCreate = undefined;\n  this.model = undefined;\n  this.context = undefined;\n};\n\nCreateProgramJob.prototype.set = function (programToCreate, model, context) {\n  this.programToCreate = programToCreate;\n  this.model = model;\n  this.context = context;\n};\n\nCreateProgramJob.prototype.execute = function () {\n  createProgram(this.programToCreate, this.model, this.context);\n};\n\n///////////////////////////////////////////////////////////////////////////\n\n// When building programs for the first time, do not include modifiers for clipping planes and color\n// since this is the version of the program that will be cached for use with other Models.\nfunction createProgram(programToCreate, model, context) {\n  var programId = programToCreate.programId;\n  var techniqueId = programToCreate.techniqueId;\n  var program = model._sourcePrograms[programId];\n  var shaders = model._rendererResources.sourceShaders;\n\n  var vs = shaders[program.vertexShader];\n  var fs = shaders[program.fragmentShader];\n\n  var quantizedVertexShaders = model._quantizedVertexShaders;\n  var toClipCoordinatesGLSL = model._toClipCoordinatesGLSL[programId];\n\n  if (\n    model.extensionsUsed.WEB3D_quantized_attributes ||\n    model._dequantizeInShader\n  ) {\n    var quantizedVS = quantizedVertexShaders[programId];\n    if (!defined(quantizedVS)) {\n      quantizedVS = modifyShaderForQuantizedAttributes(vs, programId, model);\n      quantizedVertexShaders[programId] = quantizedVS;\n    }\n    vs = quantizedVS;\n  }\n\n  var drawVS = modifyShader(vs, programId, model._vertexShaderLoaded);\n  var drawFS = modifyShader(fs, programId, model._fragmentShaderLoaded);\n\n  // Internet Explorer seems to have problems with discard (for clipping planes) after too many levels of indirection:\n  // https://github.com/CesiumGS/cesium/issues/6575.\n  // For IE log depth code is defined out anyway due to unsupported WebGL extensions, so the wrappers can be omitted.\n  if (!FeatureDetection.isInternetExplorer()) {\n    drawVS = ModelUtility.modifyVertexShaderForLogDepth(\n      drawVS,\n      toClipCoordinatesGLSL\n    );\n    drawFS = ModelUtility.modifyFragmentShaderForLogDepth(drawFS);\n  }\n\n  if (!defined(model._uniformMapLoaded)) {\n    drawFS = \"uniform vec4 czm_pickColor;\\n\" + drawFS;\n  }\n\n  var useIBL =\n    model._imageBasedLightingFactor.x > 0.0 ||\n    model._imageBasedLightingFactor.y > 0.0;\n  if (useIBL) {\n    drawFS = \"#define USE_IBL_LIGHTING \\n\\n\" + drawFS;\n  }\n\n  if (defined(model._lightColor)) {\n    drawFS = \"#define USE_CUSTOM_LIGHT_COLOR \\n\\n\" + drawFS;\n  }\n\n  if (model._sourceVersion !== \"2.0\" || model._sourceKHRTechniquesWebGL) {\n    drawFS = ShaderSource.replaceMain(drawFS, \"non_gamma_corrected_main\");\n    drawFS =\n      drawFS +\n      \"\\n\" +\n      \"void main() { \\n\" +\n      \"    non_gamma_corrected_main(); \\n\" +\n      \"    gl_FragColor = czm_gammaCorrect(gl_FragColor); \\n\" +\n      \"} \\n\";\n  }\n\n  if (OctahedralProjectedCubeMap.isSupported(context)) {\n    var usesSH =\n      defined(model._sphericalHarmonicCoefficients) ||\n      model._useDefaultSphericalHarmonics;\n    var usesSM =\n      (defined(model._specularEnvironmentMapAtlas) &&\n        model._specularEnvironmentMapAtlas.ready) ||\n      model._useDefaultSpecularMaps;\n    var addMatrix = usesSH || usesSM || useIBL;\n    if (addMatrix) {\n      drawFS = \"uniform mat4 gltf_clippingPlanesMatrix; \\n\" + drawFS;\n    }\n\n    if (defined(model._sphericalHarmonicCoefficients)) {\n      drawFS =\n        \"#define DIFFUSE_IBL \\n\" +\n        \"#define CUSTOM_SPHERICAL_HARMONICS \\n\" +\n        \"uniform vec3 gltf_sphericalHarmonicCoefficients[9]; \\n\" +\n        drawFS;\n    } else if (model._useDefaultSphericalHarmonics) {\n      drawFS = \"#define DIFFUSE_IBL \\n\" + drawFS;\n    }\n\n    if (\n      defined(model._specularEnvironmentMapAtlas) &&\n      model._specularEnvironmentMapAtlas.ready\n    ) {\n      drawFS =\n        \"#define SPECULAR_IBL \\n\" +\n        \"#define CUSTOM_SPECULAR_IBL \\n\" +\n        \"uniform sampler2D gltf_specularMap; \\n\" +\n        \"uniform vec2 gltf_specularMapSize; \\n\" +\n        \"uniform float gltf_maxSpecularLOD; \\n\" +\n        drawFS;\n    } else if (model._useDefaultSpecularMaps) {\n      drawFS = \"#define SPECULAR_IBL \\n\" + drawFS;\n    }\n  }\n\n  if (defined(model._luminanceAtZenith)) {\n    drawFS =\n      \"#define USE_SUN_LUMINANCE \\n\" +\n      \"uniform float gltf_luminanceAtZenith;\\n\" +\n      drawFS;\n  }\n\n  createAttributesAndProgram(\n    programId,\n    techniqueId,\n    drawFS,\n    drawVS,\n    model,\n    context\n  );\n}\n\nfunction recreateProgram(programToCreate, model, context) {\n  var programId = programToCreate.programId;\n  var techniqueId = programToCreate.techniqueId;\n  var program = model._sourcePrograms[programId];\n  var shaders = model._rendererResources.sourceShaders;\n\n  var quantizedVertexShaders = model._quantizedVertexShaders;\n  var toClipCoordinatesGLSL = model._toClipCoordinatesGLSL[programId];\n\n  var clippingPlaneCollection = model.clippingPlanes;\n  var addClippingPlaneCode = isClippingEnabled(model);\n\n  var vs = shaders[program.vertexShader];\n  var fs = shaders[program.fragmentShader];\n\n  if (\n    model.extensionsUsed.WEB3D_quantized_attributes ||\n    model._dequantizeInShader\n  ) {\n    vs = quantizedVertexShaders[programId];\n  }\n\n  var finalFS = fs;\n  if (isColorShadingEnabled(model)) {\n    finalFS = Model._modifyShaderForColor(finalFS);\n  }\n  if (addClippingPlaneCode) {\n    finalFS = modifyShaderForClippingPlanes(\n      finalFS,\n      clippingPlaneCollection,\n      context\n    );\n  }\n\n  var drawVS = modifyShader(vs, programId, model._vertexShaderLoaded);\n  var drawFS = modifyShader(finalFS, programId, model._fragmentShaderLoaded);\n\n  if (!FeatureDetection.isInternetExplorer()) {\n    drawVS = ModelUtility.modifyVertexShaderForLogDepth(\n      drawVS,\n      toClipCoordinatesGLSL\n    );\n    drawFS = ModelUtility.modifyFragmentShaderForLogDepth(drawFS);\n  }\n\n  if (!defined(model._uniformMapLoaded)) {\n    drawFS = \"uniform vec4 czm_pickColor;\\n\" + drawFS;\n  }\n\n  var useIBL =\n    model._imageBasedLightingFactor.x > 0.0 ||\n    model._imageBasedLightingFactor.y > 0.0;\n  if (useIBL) {\n    drawFS = \"#define USE_IBL_LIGHTING \\n\\n\" + drawFS;\n  }\n\n  if (defined(model._lightColor)) {\n    drawFS = \"#define USE_CUSTOM_LIGHT_COLOR \\n\\n\" + drawFS;\n  }\n\n  if (model._sourceVersion !== \"2.0\" || model._sourceKHRTechniquesWebGL) {\n    drawFS = ShaderSource.replaceMain(drawFS, \"non_gamma_corrected_main\");\n    drawFS =\n      drawFS +\n      \"\\n\" +\n      \"void main() { \\n\" +\n      \"    non_gamma_corrected_main(); \\n\" +\n      \"    gl_FragColor = czm_gammaCorrect(gl_FragColor); \\n\" +\n      \"} \\n\";\n  }\n\n  if (OctahedralProjectedCubeMap.isSupported(context)) {\n    var usesSH =\n      defined(model._sphericalHarmonicCoefficients) ||\n      model._useDefaultSphericalHarmonics;\n    var usesSM =\n      (defined(model._specularEnvironmentMapAtlas) &&\n        model._specularEnvironmentMapAtlas.ready) ||\n      model._useDefaultSpecularMaps;\n    var addMatrix = !addClippingPlaneCode && (usesSH || usesSM || useIBL);\n    if (addMatrix) {\n      drawFS = \"uniform mat4 gltf_clippingPlanesMatrix; \\n\" + drawFS;\n    }\n\n    if (defined(model._sphericalHarmonicCoefficients)) {\n      drawFS =\n        \"#define DIFFUSE_IBL \\n\" +\n        \"#define CUSTOM_SPHERICAL_HARMONICS \\n\" +\n        \"uniform vec3 gltf_sphericalHarmonicCoefficients[9]; \\n\" +\n        drawFS;\n    } else if (model._useDefaultSphericalHarmonics) {\n      drawFS = \"#define DIFFUSE_IBL \\n\" + drawFS;\n    }\n\n    if (\n      defined(model._specularEnvironmentMapAtlas) &&\n      model._specularEnvironmentMapAtlas.ready\n    ) {\n      drawFS =\n        \"#define SPECULAR_IBL \\n\" +\n        \"#define CUSTOM_SPECULAR_IBL \\n\" +\n        \"uniform sampler2D gltf_specularMap; \\n\" +\n        \"uniform vec2 gltf_specularMapSize; \\n\" +\n        \"uniform float gltf_maxSpecularLOD; \\n\" +\n        drawFS;\n    } else if (model._useDefaultSpecularMaps) {\n      drawFS = \"#define SPECULAR_IBL \\n\" + drawFS;\n    }\n  }\n\n  if (defined(model._luminanceAtZenith)) {\n    drawFS =\n      \"#define USE_SUN_LUMINANCE \\n\" +\n      \"uniform float gltf_luminanceAtZenith;\\n\" +\n      drawFS;\n  }\n\n  createAttributesAndProgram(\n    programId,\n    techniqueId,\n    drawFS,\n    drawVS,\n    model,\n    context\n  );\n}\n\nfunction createAttributesAndProgram(\n  programId,\n  techniqueId,\n  drawFS,\n  drawVS,\n  model,\n  context\n) {\n  var technique = model._sourceTechniques[techniqueId];\n  var attributeLocations = ModelUtility.createAttributeLocations(\n    technique,\n    model._precreatedAttributes\n  );\n\n  model._rendererResources.programs[programId] = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: drawVS,\n    fragmentShaderSource: drawFS,\n    attributeLocations: attributeLocations,\n  });\n}\n\nvar scratchCreateProgramJob = new CreateProgramJob();\n\nfunction createPrograms(model, frameState) {\n  var loadResources = model._loadResources;\n  var programsToCreate = loadResources.programsToCreate;\n\n  if (loadResources.pendingShaderLoads !== 0) {\n    return;\n  }\n\n  // PERFORMANCE_IDEA: this could be more fine-grained by looking\n  // at the shader's bufferView's to determine the buffer dependencies.\n  if (loadResources.pendingBufferLoads !== 0) {\n    return;\n  }\n\n  var context = frameState.context;\n\n  if (model.asynchronous) {\n    while (programsToCreate.length > 0) {\n      scratchCreateProgramJob.set(programsToCreate.peek(), model, context);\n      if (\n        !frameState.jobScheduler.execute(\n          scratchCreateProgramJob,\n          JobType.PROGRAM\n        )\n      ) {\n        break;\n      }\n      programsToCreate.dequeue();\n    }\n  } else {\n    // Create all loaded programs this frame\n    while (programsToCreate.length > 0) {\n      createProgram(programsToCreate.dequeue(), model, context);\n    }\n  }\n}\n\nfunction getOnImageCreatedFromTypedArray(loadResources, gltfTexture) {\n  return function (image) {\n    loadResources.texturesToCreate.enqueue({\n      id: gltfTexture.id,\n      image: image,\n      bufferView: undefined,\n    });\n\n    --loadResources.pendingBufferViewToImage;\n  };\n}\n\nfunction loadTexturesFromBufferViews(model) {\n  var loadResources = model._loadResources;\n\n  if (loadResources.pendingBufferLoads !== 0) {\n    return;\n  }\n\n  while (loadResources.texturesToCreateFromBufferView.length > 0) {\n    var gltfTexture = loadResources.texturesToCreateFromBufferView.dequeue();\n\n    var gltf = model.gltf;\n    var bufferView = gltf.bufferViews[gltfTexture.bufferView];\n    var imageId = gltf.textures[gltfTexture.id].source;\n\n    var onerror = ModelUtility.getFailedLoadFunction(\n      model,\n      \"image\",\n      \"id: \" + gltfTexture.id + \", bufferView: \" + gltfTexture.bufferView\n    );\n\n    if (gltfTexture.mimeType === \"image/ktx\") {\n      loadKTX(loadResources.getBuffer(bufferView))\n        .then(imageLoad(model, gltfTexture.id, imageId))\n        .otherwise(onerror);\n      ++model._loadResources.pendingTextureLoads;\n    } else if (gltfTexture.mimeType === \"image/crn\") {\n      loadCRN(loadResources.getBuffer(bufferView))\n        .then(imageLoad(model, gltfTexture.id, imageId))\n        .otherwise(onerror);\n      ++model._loadResources.pendingTextureLoads;\n    } else {\n      var onload = getOnImageCreatedFromTypedArray(loadResources, gltfTexture);\n      loadImageFromTypedArray({\n        uint8Array: loadResources.getBuffer(bufferView),\n        format: gltfTexture.mimeType,\n        flipY: false,\n      })\n        .then(onload)\n        .otherwise(onerror);\n      ++loadResources.pendingBufferViewToImage;\n    }\n  }\n}\n\nfunction createSamplers(model) {\n  var loadResources = model._loadResources;\n  if (loadResources.createSamplers) {\n    loadResources.createSamplers = false;\n\n    var rendererSamplers = model._rendererResources.samplers;\n    ForEach.sampler(model.gltf, function (sampler, samplerId) {\n      rendererSamplers[samplerId] = new Sampler({\n        wrapS: sampler.wrapS,\n        wrapT: sampler.wrapT,\n        minificationFilter: sampler.minFilter,\n        magnificationFilter: sampler.magFilter,\n      });\n    });\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nvar CreateTextureJob = function () {\n  this.gltfTexture = undefined;\n  this.model = undefined;\n  this.context = undefined;\n};\n\nCreateTextureJob.prototype.set = function (gltfTexture, model, context) {\n  this.gltfTexture = gltfTexture;\n  this.model = model;\n  this.context = context;\n};\n\nCreateTextureJob.prototype.execute = function () {\n  createTexture(this.gltfTexture, this.model, this.context);\n};\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction createTexture(gltfTexture, model, context) {\n  var textures = model.gltf.textures;\n  var texture = textures[gltfTexture.id];\n\n  var rendererSamplers = model._rendererResources.samplers;\n  var sampler = rendererSamplers[texture.sampler];\n  if (!defined(sampler)) {\n    sampler = new Sampler({\n      wrapS: TextureWrap.REPEAT,\n      wrapT: TextureWrap.REPEAT,\n    });\n  }\n\n  var usesTextureTransform = false;\n  var materials = model.gltf.materials;\n  var materialsLength = materials.length;\n  for (var i = 0; i < materialsLength; ++i) {\n    var material = materials[i];\n    if (\n      defined(material.extensions) &&\n      defined(material.extensions.KHR_techniques_webgl)\n    ) {\n      var values = material.extensions.KHR_techniques_webgl.values;\n      for (var valueName in values) {\n        if (\n          values.hasOwnProperty(valueName) &&\n          valueName.indexOf(\"Texture\") !== -1\n        ) {\n          var value = values[valueName];\n          if (\n            value.index === gltfTexture.id &&\n            defined(value.extensions) &&\n            defined(value.extensions.KHR_texture_transform)\n          ) {\n            usesTextureTransform = true;\n            break;\n          }\n        }\n      }\n    }\n    if (usesTextureTransform) {\n      break;\n    }\n  }\n\n  var wrapS = sampler.wrapS;\n  var wrapT = sampler.wrapT;\n  var minFilter = sampler.minificationFilter;\n\n  if (\n    usesTextureTransform &&\n    minFilter !== TextureMinificationFilter.LINEAR &&\n    minFilter !== TextureMinificationFilter.NEAREST\n  ) {\n    if (\n      minFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST ||\n      minFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR\n    ) {\n      minFilter = TextureMinificationFilter.NEAREST;\n    } else {\n      minFilter = TextureMinificationFilter.LINEAR;\n    }\n\n    sampler = new Sampler({\n      wrapS: sampler.wrapS,\n      wrapT: sampler.wrapT,\n      textureMinificationFilter: minFilter,\n      textureMagnificationFilter: sampler.magnificationFilter,\n    });\n  }\n\n  var internalFormat = gltfTexture.internalFormat;\n\n  var mipmap =\n    !(\n      defined(internalFormat) && PixelFormat.isCompressedFormat(internalFormat)\n    ) &&\n    (minFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST ||\n      minFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR ||\n      minFilter === TextureMinificationFilter.LINEAR_MIPMAP_NEAREST ||\n      minFilter === TextureMinificationFilter.LINEAR_MIPMAP_LINEAR);\n  var requiresNpot =\n    mipmap ||\n    wrapS === TextureWrap.REPEAT ||\n    wrapS === TextureWrap.MIRRORED_REPEAT ||\n    wrapT === TextureWrap.REPEAT ||\n    wrapT === TextureWrap.MIRRORED_REPEAT;\n\n  var tx;\n  var source = gltfTexture.image;\n\n  if (defined(internalFormat)) {\n    tx = new Texture({\n      context: context,\n      source: {\n        arrayBufferView: gltfTexture.bufferView,\n      },\n      width: gltfTexture.width,\n      height: gltfTexture.height,\n      pixelFormat: internalFormat,\n      sampler: sampler,\n    });\n  } else if (defined(source)) {\n    var npot =\n      !CesiumMath.isPowerOfTwo(source.width) ||\n      !CesiumMath.isPowerOfTwo(source.height);\n\n    if (requiresNpot && npot) {\n      // WebGL requires power-of-two texture dimensions for mipmapping and REPEAT/MIRRORED_REPEAT wrap modes.\n      var canvas = document.createElement(\"canvas\");\n      canvas.width = CesiumMath.nextPowerOfTwo(source.width);\n      canvas.height = CesiumMath.nextPowerOfTwo(source.height);\n      var canvasContext = canvas.getContext(\"2d\");\n      canvasContext.drawImage(\n        source,\n        0,\n        0,\n        source.width,\n        source.height,\n        0,\n        0,\n        canvas.width,\n        canvas.height\n      );\n      source = canvas;\n    }\n\n    tx = new Texture({\n      context: context,\n      source: source,\n      pixelFormat: texture.internalFormat,\n      pixelDatatype: texture.type,\n      sampler: sampler,\n      flipY: false,\n    });\n    // GLTF_SPEC: Support TEXTURE_CUBE_MAP.  https://github.com/KhronosGroup/glTF/issues/40\n    if (mipmap) {\n      tx.generateMipmap();\n    }\n  }\n  if (defined(tx)) {\n    model._rendererResources.textures[gltfTexture.id] = tx;\n    model._texturesByteLength += tx.sizeInBytes;\n  }\n}\n\nvar scratchCreateTextureJob = new CreateTextureJob();\n\nfunction createTextures(model, frameState) {\n  var context = frameState.context;\n  var texturesToCreate = model._loadResources.texturesToCreate;\n\n  if (model.asynchronous) {\n    while (texturesToCreate.length > 0) {\n      scratchCreateTextureJob.set(texturesToCreate.peek(), model, context);\n      if (\n        !frameState.jobScheduler.execute(\n          scratchCreateTextureJob,\n          JobType.TEXTURE\n        )\n      ) {\n        break;\n      }\n      texturesToCreate.dequeue();\n    }\n  } else {\n    // Create all loaded textures this frame\n    while (texturesToCreate.length > 0) {\n      createTexture(texturesToCreate.dequeue(), model, context);\n    }\n  }\n}\n\nfunction getAttributeLocations(model, primitive) {\n  var techniques = model._sourceTechniques;\n\n  // Retrieve the compiled shader program to assign index values to attributes\n  var attributeLocations = {};\n\n  var location;\n  var index;\n  var material = model._runtime.materialsById[primitive.material];\n  if (!defined(material)) {\n    return attributeLocations;\n  }\n\n  var technique = techniques[material._technique];\n  if (!defined(technique)) {\n    return attributeLocations;\n  }\n\n  var attributes = technique.attributes;\n  var program = model._rendererResources.programs[technique.program];\n  var programVertexAttributes = program.vertexAttributes;\n  var programAttributeLocations = program._attributeLocations;\n\n  // Note: WebGL shader compiler may have optimized and removed some attributes from programVertexAttributes\n  for (location in programVertexAttributes) {\n    if (programVertexAttributes.hasOwnProperty(location)) {\n      var attribute = attributes[location];\n      if (defined(attribute)) {\n        index = programAttributeLocations[location];\n        attributeLocations[attribute.semantic] = index;\n      }\n    }\n  }\n\n  // Always add pre-created attributes.\n  // Some pre-created attributes, like per-instance pickIds, may be compiled out of the draw program\n  // but should be included in the list of attribute locations for the pick program.\n  // This is safe to do since programVertexAttributes and programAttributeLocations are equivalent except\n  // that programVertexAttributes optimizes out unused attributes.\n  var precreatedAttributes = model._precreatedAttributes;\n  if (defined(precreatedAttributes)) {\n    for (location in precreatedAttributes) {\n      if (precreatedAttributes.hasOwnProperty(location)) {\n        index = programAttributeLocations[location];\n        attributeLocations[location] = index;\n      }\n    }\n  }\n\n  return attributeLocations;\n}\n\nfunction createJoints(model, runtimeSkins) {\n  var gltf = model.gltf;\n  var skins = gltf.skins;\n  var nodes = gltf.nodes;\n  var runtimeNodes = model._runtime.nodes;\n\n  var skinnedNodesIds = model._loadResources.skinnedNodesIds;\n  var length = skinnedNodesIds.length;\n  for (var j = 0; j < length; ++j) {\n    var id = skinnedNodesIds[j];\n    var skinnedNode = runtimeNodes[id];\n    var node = nodes[id];\n\n    var runtimeSkin = runtimeSkins[node.skin];\n    skinnedNode.inverseBindMatrices = runtimeSkin.inverseBindMatrices;\n    skinnedNode.bindShapeMatrix = runtimeSkin.bindShapeMatrix;\n\n    var gltfJoints = skins[node.skin].joints;\n    var jointsLength = gltfJoints.length;\n    for (var i = 0; i < jointsLength; ++i) {\n      var nodeId = gltfJoints[i];\n      var jointNode = runtimeNodes[nodeId];\n      skinnedNode.joints.push(jointNode);\n    }\n  }\n}\n\nfunction createSkins(model) {\n  var loadResources = model._loadResources;\n\n  if (loadResources.pendingBufferLoads !== 0) {\n    return;\n  }\n\n  if (!loadResources.createSkins) {\n    return;\n  }\n  loadResources.createSkins = false;\n\n  var gltf = model.gltf;\n  var accessors = gltf.accessors;\n  var runtimeSkins = {};\n\n  ForEach.skin(gltf, function (skin, id) {\n    var accessor = accessors[skin.inverseBindMatrices];\n\n    var bindShapeMatrix;\n    if (!Matrix4.equals(skin.bindShapeMatrix, Matrix4.IDENTITY)) {\n      bindShapeMatrix = Matrix4.clone(skin.bindShapeMatrix);\n    }\n\n    runtimeSkins[id] = {\n      inverseBindMatrices: ModelAnimationCache.getSkinInverseBindMatrices(\n        model,\n        accessor\n      ),\n      bindShapeMatrix: bindShapeMatrix, // not used when undefined\n    };\n  });\n\n  createJoints(model, runtimeSkins);\n}\n\nfunction getChannelEvaluator(model, runtimeNode, targetPath, spline) {\n  return function (localAnimationTime) {\n    if (defined(spline)) {\n      localAnimationTime = model.clampAnimations\n        ? spline.clampTime(localAnimationTime)\n        : spline.wrapTime(localAnimationTime);\n      runtimeNode[targetPath] = spline.evaluate(\n        localAnimationTime,\n        runtimeNode[targetPath]\n      );\n      runtimeNode.dirtyNumber = model._maxDirtyNumber;\n    }\n  };\n}\n\nfunction createRuntimeAnimations(model) {\n  var loadResources = model._loadResources;\n\n  if (!loadResources.finishedPendingBufferLoads()) {\n    return;\n  }\n\n  if (!loadResources.createRuntimeAnimations) {\n    return;\n  }\n  loadResources.createRuntimeAnimations = false;\n\n  model._runtime.animations = [];\n\n  var runtimeNodes = model._runtime.nodes;\n  var accessors = model.gltf.accessors;\n\n  ForEach.animation(model.gltf, function (animation, i) {\n    var channels = animation.channels;\n    var samplers = animation.samplers;\n\n    // Find start and stop time for the entire animation\n    var startTime = Number.MAX_VALUE;\n    var stopTime = -Number.MAX_VALUE;\n\n    var channelsLength = channels.length;\n    var channelEvaluators = new Array(channelsLength);\n\n    for (var j = 0; j < channelsLength; ++j) {\n      var channel = channels[j];\n      var target = channel.target;\n      var path = target.path;\n      var sampler = samplers[channel.sampler];\n      var input = ModelAnimationCache.getAnimationParameterValues(\n        model,\n        accessors[sampler.input]\n      );\n      var output = ModelAnimationCache.getAnimationParameterValues(\n        model,\n        accessors[sampler.output]\n      );\n\n      startTime = Math.min(startTime, input[0]);\n      stopTime = Math.max(stopTime, input[input.length - 1]);\n\n      var spline = ModelAnimationCache.getAnimationSpline(\n        model,\n        i,\n        animation,\n        channel.sampler,\n        sampler,\n        input,\n        path,\n        output\n      );\n\n      channelEvaluators[j] = getChannelEvaluator(\n        model,\n        runtimeNodes[target.node],\n        target.path,\n        spline\n      );\n    }\n\n    model._runtime.animations[i] = {\n      name: animation.name,\n      startTime: startTime,\n      stopTime: stopTime,\n      channelEvaluators: channelEvaluators,\n    };\n  });\n}\n\nfunction createVertexArrays(model, context) {\n  var loadResources = model._loadResources;\n  if (\n    !loadResources.finishedBuffersCreation() ||\n    !loadResources.finishedProgramCreation() ||\n    !loadResources.createVertexArrays\n  ) {\n    return;\n  }\n  loadResources.createVertexArrays = false;\n\n  var rendererBuffers = model._rendererResources.buffers;\n  var rendererVertexArrays = model._rendererResources.vertexArrays;\n  var gltf = model.gltf;\n  var accessors = gltf.accessors;\n  ForEach.mesh(gltf, function (mesh, meshId) {\n    ForEach.meshPrimitive(mesh, function (primitive, primitiveId) {\n      var attributes = [];\n      var attributeLocation;\n      var attributeLocations = getAttributeLocations(model, primitive);\n      var decodedData =\n        model._decodedData[meshId + \".primitive.\" + primitiveId];\n      ForEach.meshPrimitiveAttribute(primitive, function (\n        accessorId,\n        attributeName\n      ) {\n        // Skip if the attribute is not used by the material, e.g., because the asset\n        // was exported with an attribute that wasn't used and the asset wasn't optimized.\n        attributeLocation = attributeLocations[attributeName];\n        if (defined(attributeLocation)) {\n          // Use attributes of previously decoded draco geometry\n          if (defined(decodedData)) {\n            var decodedAttributes = decodedData.attributes;\n            if (decodedAttributes.hasOwnProperty(attributeName)) {\n              var decodedAttribute = decodedAttributes[attributeName];\n              attributes.push({\n                index: attributeLocation,\n                vertexBuffer: rendererBuffers[decodedAttribute.bufferView],\n                componentsPerAttribute: decodedAttribute.componentsPerAttribute,\n                componentDatatype: decodedAttribute.componentDatatype,\n                normalize: decodedAttribute.normalized,\n                offsetInBytes: decodedAttribute.byteOffset,\n                strideInBytes: decodedAttribute.byteStride,\n              });\n\n              return;\n            }\n          }\n\n          var a = accessors[accessorId];\n          var normalize = defined(a.normalized) && a.normalized;\n          attributes.push({\n            index: attributeLocation,\n            vertexBuffer: rendererBuffers[a.bufferView],\n            componentsPerAttribute: numberOfComponentsForType(a.type),\n            componentDatatype: a.componentType,\n            normalize: normalize,\n            offsetInBytes: a.byteOffset,\n            strideInBytes: getAccessorByteStride(gltf, a),\n          });\n        }\n      });\n\n      // Add pre-created attributes\n      var attribute;\n      var attributeName;\n      var precreatedAttributes = model._precreatedAttributes;\n      if (defined(precreatedAttributes)) {\n        for (attributeName in precreatedAttributes) {\n          if (precreatedAttributes.hasOwnProperty(attributeName)) {\n            attributeLocation = attributeLocations[attributeName];\n            if (defined(attributeLocation)) {\n              attribute = precreatedAttributes[attributeName];\n              attribute.index = attributeLocation;\n              attributes.push(attribute);\n            }\n          }\n        }\n      }\n\n      var indexBuffer;\n      if (defined(primitive.indices)) {\n        var accessor = accessors[primitive.indices];\n        var bufferView = accessor.bufferView;\n\n        // Use buffer of previously decoded draco geometry\n        if (defined(decodedData)) {\n          bufferView = decodedData.bufferView;\n        }\n\n        indexBuffer = rendererBuffers[bufferView];\n      }\n      rendererVertexArrays[\n        meshId + \".primitive.\" + primitiveId\n      ] = new VertexArray({\n        context: context,\n        attributes: attributes,\n        indexBuffer: indexBuffer,\n      });\n    });\n  });\n}\n\nfunction createRenderStates(model) {\n  var loadResources = model._loadResources;\n  if (loadResources.createRenderStates) {\n    loadResources.createRenderStates = false;\n\n    ForEach.material(model.gltf, function (material, materialId) {\n      createRenderStateForMaterial(model, material, materialId);\n    });\n  }\n}\n\nfunction createRenderStateForMaterial(model, material, materialId) {\n  var rendererRenderStates = model._rendererResources.renderStates;\n\n  var blendEquationSeparate = [\n    WebGLConstants.FUNC_ADD,\n    WebGLConstants.FUNC_ADD,\n  ];\n  var blendFuncSeparate = [\n    WebGLConstants.ONE,\n    WebGLConstants.ONE_MINUS_SRC_ALPHA,\n    WebGLConstants.ONE,\n    WebGLConstants.ONE_MINUS_SRC_ALPHA,\n  ];\n\n  if (defined(material.extensions) && defined(material.extensions.KHR_blend)) {\n    blendEquationSeparate = material.extensions.KHR_blend.blendEquation;\n    blendFuncSeparate = material.extensions.KHR_blend.blendFactors;\n  }\n\n  var enableCulling = !material.doubleSided;\n  var blendingEnabled = material.alphaMode === \"BLEND\";\n  rendererRenderStates[materialId] = RenderState.fromCache({\n    cull: {\n      enabled: enableCulling,\n    },\n    depthTest: {\n      enabled: true,\n      func: DepthFunction.LESS_OR_EQUAL,\n    },\n    depthMask: !blendingEnabled,\n    blending: {\n      enabled: blendingEnabled,\n      equationRgb: blendEquationSeparate[0],\n      equationAlpha: blendEquationSeparate[1],\n      functionSourceRgb: blendFuncSeparate[0],\n      functionDestinationRgb: blendFuncSeparate[1],\n      functionSourceAlpha: blendFuncSeparate[2],\n      functionDestinationAlpha: blendFuncSeparate[3],\n    },\n  });\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nvar gltfUniformsFromNode = {\n  MODEL: function (uniformState, model, runtimeNode) {\n    return function () {\n      return runtimeNode.computedMatrix;\n    };\n  },\n  VIEW: function (uniformState, model, runtimeNode) {\n    return function () {\n      return uniformState.view;\n    };\n  },\n  PROJECTION: function (uniformState, model, runtimeNode) {\n    return function () {\n      return uniformState.projection;\n    };\n  },\n  MODELVIEW: function (uniformState, model, runtimeNode) {\n    var mv = new Matrix4();\n    return function () {\n      return Matrix4.multiplyTransformation(\n        uniformState.view,\n        runtimeNode.computedMatrix,\n        mv\n      );\n    };\n  },\n  CESIUM_RTC_MODELVIEW: function (uniformState, model, runtimeNode) {\n    // CESIUM_RTC extension\n    var mvRtc = new Matrix4();\n    return function () {\n      Matrix4.multiplyTransformation(\n        uniformState.view,\n        runtimeNode.computedMatrix,\n        mvRtc\n      );\n      return Matrix4.setTranslation(mvRtc, model._rtcCenterEye, mvRtc);\n    };\n  },\n  MODELVIEWPROJECTION: function (uniformState, model, runtimeNode) {\n    var mvp = new Matrix4();\n    return function () {\n      Matrix4.multiplyTransformation(\n        uniformState.view,\n        runtimeNode.computedMatrix,\n        mvp\n      );\n      return Matrix4.multiply(uniformState._projection, mvp, mvp);\n    };\n  },\n  MODELINVERSE: function (uniformState, model, runtimeNode) {\n    var mInverse = new Matrix4();\n    return function () {\n      return Matrix4.inverse(runtimeNode.computedMatrix, mInverse);\n    };\n  },\n  VIEWINVERSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseView;\n    };\n  },\n  PROJECTIONINVERSE: function (uniformState, model, runtimeNode) {\n    return function () {\n      return uniformState.inverseProjection;\n    };\n  },\n  MODELVIEWINVERSE: function (uniformState, model, runtimeNode) {\n    var mv = new Matrix4();\n    var mvInverse = new Matrix4();\n    return function () {\n      Matrix4.multiplyTransformation(\n        uniformState.view,\n        runtimeNode.computedMatrix,\n        mv\n      );\n      return Matrix4.inverse(mv, mvInverse);\n    };\n  },\n  MODELVIEWPROJECTIONINVERSE: function (uniformState, model, runtimeNode) {\n    var mvp = new Matrix4();\n    var mvpInverse = new Matrix4();\n    return function () {\n      Matrix4.multiplyTransformation(\n        uniformState.view,\n        runtimeNode.computedMatrix,\n        mvp\n      );\n      Matrix4.multiply(uniformState._projection, mvp, mvp);\n      return Matrix4.inverse(mvp, mvpInverse);\n    };\n  },\n  MODELINVERSETRANSPOSE: function (uniformState, model, runtimeNode) {\n    var mInverse = new Matrix4();\n    var mInverseTranspose = new Matrix3();\n    return function () {\n      Matrix4.inverse(runtimeNode.computedMatrix, mInverse);\n      Matrix4.getMatrix3(mInverse, mInverseTranspose);\n      return Matrix3.transpose(mInverseTranspose, mInverseTranspose);\n    };\n  },\n  MODELVIEWINVERSETRANSPOSE: function (uniformState, model, runtimeNode) {\n    var mv = new Matrix4();\n    var mvInverse = new Matrix4();\n    var mvInverseTranspose = new Matrix3();\n    return function () {\n      Matrix4.multiplyTransformation(\n        uniformState.view,\n        runtimeNode.computedMatrix,\n        mv\n      );\n      Matrix4.inverse(mv, mvInverse);\n      Matrix4.getMatrix3(mvInverse, mvInverseTranspose);\n      return Matrix3.transpose(mvInverseTranspose, mvInverseTranspose);\n    };\n  },\n  VIEWPORT: function (uniformState, model, runtimeNode) {\n    return function () {\n      return uniformState.viewportCartesian4;\n    };\n  },\n};\n\nfunction getUniformFunctionFromSource(source, model, semantic, uniformState) {\n  var runtimeNode = model._runtime.nodes[source];\n  return gltfUniformsFromNode[semantic](uniformState, model, runtimeNode);\n}\n\nfunction createUniformsForMaterial(\n  model,\n  material,\n  technique,\n  instanceValues,\n  context,\n  textures,\n  defaultTexture\n) {\n  var uniformMap = {};\n  var uniformValues = {};\n  var jointMatrixUniformName;\n  var morphWeightsUniformName;\n\n  ForEach.techniqueUniform(technique, function (uniform, uniformName) {\n    // GLTF_SPEC: This does not take into account uniform arrays,\n    // indicated by uniforms with a count property.\n    //\n    // https://github.com/KhronosGroup/glTF/issues/258\n\n    // GLTF_SPEC: In this implementation, material parameters with a\n    // semantic or targeted via a source (for animation) are not\n    // targetable for material animations.  Is this too strict?\n    //\n    // https://github.com/KhronosGroup/glTF/issues/142\n\n    var uv;\n    if (defined(instanceValues) && defined(instanceValues[uniformName])) {\n      // Parameter overrides by the instance technique\n      uv = ModelUtility.createUniformFunction(\n        uniform.type,\n        instanceValues[uniformName],\n        textures,\n        defaultTexture\n      );\n      uniformMap[uniformName] = uv.func;\n      uniformValues[uniformName] = uv;\n    } else if (defined(uniform.node)) {\n      uniformMap[uniformName] = getUniformFunctionFromSource(\n        uniform.node,\n        model,\n        uniform.semantic,\n        context.uniformState\n      );\n    } else if (defined(uniform.semantic)) {\n      if (uniform.semantic === \"JOINTMATRIX\") {\n        jointMatrixUniformName = uniformName;\n      } else if (uniform.semantic === \"MORPHWEIGHTS\") {\n        morphWeightsUniformName = uniformName;\n      } else if (uniform.semantic === \"ALPHACUTOFF\") {\n        // The material's alphaCutoff value uses a uniform with semantic ALPHACUTOFF.\n        // A uniform with this semantic will ignore the instance or default values.\n        var alphaMode = material.alphaMode;\n        if (defined(alphaMode) && alphaMode === \"MASK\") {\n          var alphaCutoffValue = defaultValue(material.alphaCutoff, 0.5);\n          uv = ModelUtility.createUniformFunction(\n            uniform.type,\n            alphaCutoffValue,\n            textures,\n            defaultTexture\n          );\n          uniformMap[uniformName] = uv.func;\n          uniformValues[uniformName] = uv;\n        }\n      } else {\n        // Map glTF semantic to Cesium automatic uniform\n        uniformMap[uniformName] = ModelUtility.getGltfSemanticUniforms()[\n          uniform.semantic\n        ](context.uniformState, model);\n      }\n    } else if (defined(uniform.value)) {\n      // Technique value that isn't overridden by a material\n      var uv2 = ModelUtility.createUniformFunction(\n        uniform.type,\n        uniform.value,\n        textures,\n        defaultTexture\n      );\n      uniformMap[uniformName] = uv2.func;\n      uniformValues[uniformName] = uv2;\n    }\n  });\n\n  return {\n    map: uniformMap,\n    values: uniformValues,\n    jointMatrixUniformName: jointMatrixUniformName,\n    morphWeightsUniformName: morphWeightsUniformName,\n  };\n}\n\nfunction createUniformMaps(model, context) {\n  var loadResources = model._loadResources;\n\n  if (!loadResources.finishedProgramCreation()) {\n    return;\n  }\n\n  if (!loadResources.createUniformMaps) {\n    return;\n  }\n  loadResources.createUniformMaps = false;\n\n  var gltf = model.gltf;\n  var techniques = model._sourceTechniques;\n  var uniformMaps = model._uniformMaps;\n\n  var textures = model._rendererResources.textures;\n  var defaultTexture = model._defaultTexture;\n\n  ForEach.material(gltf, function (material, materialId) {\n    var modelMaterial = model._runtime.materialsById[materialId];\n    var technique = techniques[modelMaterial._technique];\n    var instanceValues = modelMaterial._values;\n\n    var uniforms = createUniformsForMaterial(\n      model,\n      material,\n      technique,\n      instanceValues,\n      context,\n      textures,\n      defaultTexture\n    );\n\n    var u = uniformMaps[materialId];\n    u.uniformMap = uniforms.map; // uniform name -> function for the renderer\n    u.values = uniforms.values; // material parameter name -> ModelMaterial for modifying the parameter at runtime\n    u.jointMatrixUniformName = uniforms.jointMatrixUniformName;\n    u.morphWeightsUniformName = uniforms.morphWeightsUniformName;\n\n    if (defined(technique.attributes.a_outlineCoordinates)) {\n      var outlineTexture = ModelOutlineLoader.createTexture(model, context);\n      u.uniformMap.u_outlineTexture = function () {\n        return outlineTexture;\n      };\n    }\n  });\n}\n\nfunction createUniformsForDracoQuantizedAttributes(decodedData) {\n  return ModelUtility.createUniformsForDracoQuantizedAttributes(\n    decodedData.attributes\n  );\n}\n\nfunction createUniformsForQuantizedAttributes(model, primitive) {\n  var programId = getProgramForPrimitive(model, primitive);\n  var quantizedUniforms = model._quantizedUniforms[programId];\n  return ModelUtility.createUniformsForQuantizedAttributes(\n    model.gltf,\n    primitive,\n    quantizedUniforms\n  );\n}\n\nfunction createPickColorFunction(color) {\n  return function () {\n    return color;\n  };\n}\n\nfunction createJointMatricesFunction(runtimeNode) {\n  return function () {\n    return runtimeNode.computedJointMatrices;\n  };\n}\n\nfunction createMorphWeightsFunction(runtimeNode) {\n  return function () {\n    return runtimeNode.weights;\n  };\n}\n\nfunction createSilhouetteColorFunction(model) {\n  return function () {\n    return model.silhouetteColor;\n  };\n}\n\nfunction createSilhouetteSizeFunction(model) {\n  return function () {\n    return model.silhouetteSize;\n  };\n}\n\nfunction createColorFunction(model) {\n  return function () {\n    return model.color;\n  };\n}\n\nvar scratchClippingPlaneMatrix = new Matrix4();\nfunction createClippingPlanesMatrixFunction(model) {\n  return function () {\n    var clippingPlanes = model.clippingPlanes;\n    if (\n      !defined(clippingPlanes) &&\n      !defined(model._sphericalHarmonicCoefficients) &&\n      !defined(model._specularEnvironmentMaps)\n    ) {\n      return Matrix4.IDENTITY;\n    }\n    var modelMatrix = defined(clippingPlanes)\n      ? clippingPlanes.modelMatrix\n      : Matrix4.IDENTITY;\n    return Matrix4.multiply(\n      model._clippingPlaneModelViewMatrix,\n      modelMatrix,\n      scratchClippingPlaneMatrix\n    );\n  };\n}\n\nfunction createClippingPlanesFunction(model) {\n  return function () {\n    var clippingPlanes = model.clippingPlanes;\n    return !defined(clippingPlanes) || !clippingPlanes.enabled\n      ? model._defaultTexture\n      : clippingPlanes.texture;\n  };\n}\n\nfunction createClippingPlanesEdgeStyleFunction(model) {\n  return function () {\n    var clippingPlanes = model.clippingPlanes;\n    if (!defined(clippingPlanes)) {\n      return Color.WHITE.withAlpha(0.0);\n    }\n\n    var style = Color.clone(clippingPlanes.edgeColor);\n    style.alpha = clippingPlanes.edgeWidth;\n    return style;\n  };\n}\n\nfunction createColorBlendFunction(model) {\n  return function () {\n    return ColorBlendMode.getColorBlend(\n      model.colorBlendMode,\n      model.colorBlendAmount\n    );\n  };\n}\n\nfunction createIBLFactorFunction(model) {\n  return function () {\n    return model._imageBasedLightingFactor;\n  };\n}\n\nfunction createLightColorFunction(model) {\n  return function () {\n    return model._lightColor;\n  };\n}\n\nfunction createLuminanceAtZenithFunction(model) {\n  return function () {\n    return model.luminanceAtZenith;\n  };\n}\n\nfunction createSphericalHarmonicCoefficientsFunction(model) {\n  return function () {\n    return model._sphericalHarmonicCoefficients;\n  };\n}\n\nfunction createSpecularEnvironmentMapFunction(model) {\n  return function () {\n    return model._specularEnvironmentMapAtlas.texture;\n  };\n}\n\nfunction createSpecularEnvironmentMapSizeFunction(model) {\n  return function () {\n    return model._specularEnvironmentMapAtlas.texture.dimensions;\n  };\n}\n\nfunction createSpecularEnvironmentMapLOD(model) {\n  return function () {\n    return model._specularEnvironmentMapAtlas.maximumMipmapLevel;\n  };\n}\n\nfunction triangleCountFromPrimitiveIndices(primitive, indicesCount) {\n  switch (primitive.mode) {\n    case PrimitiveType.TRIANGLES:\n      return indicesCount / 3;\n    case PrimitiveType.TRIANGLE_STRIP:\n    case PrimitiveType.TRIANGLE_FAN:\n      return Math.max(indicesCount - 2, 0);\n    default:\n      return 0;\n  }\n}\n\nfunction createCommand(model, gltfNode, runtimeNode, context, scene3DOnly) {\n  var nodeCommands = model._nodeCommands;\n  var pickIds = model._pickIds;\n  var allowPicking = model.allowPicking;\n  var runtimeMeshesByName = model._runtime.meshesByName;\n\n  var resources = model._rendererResources;\n  var rendererVertexArrays = resources.vertexArrays;\n  var rendererPrograms = resources.programs;\n  var rendererRenderStates = resources.renderStates;\n  var uniformMaps = model._uniformMaps;\n\n  var gltf = model.gltf;\n  var accessors = gltf.accessors;\n  var gltfMeshes = gltf.meshes;\n\n  var id = gltfNode.mesh;\n  var mesh = gltfMeshes[id];\n\n  var primitives = mesh.primitives;\n  var length = primitives.length;\n\n  // The glTF node hierarchy is a DAG so a node can have more than one\n  // parent, so a node may already have commands.  If so, append more\n  // since they will have a different model matrix.\n\n  for (var i = 0; i < length; ++i) {\n    var primitive = primitives[i];\n    var ix = accessors[primitive.indices];\n    var material = model._runtime.materialsById[primitive.material];\n    var programId = material._program;\n    var decodedData = model._decodedData[id + \".primitive.\" + i];\n\n    var boundingSphere;\n    var positionAccessor = primitive.attributes.POSITION;\n    if (defined(positionAccessor)) {\n      var minMax = ModelUtility.getAccessorMinMax(gltf, positionAccessor);\n      boundingSphere = BoundingSphere.fromCornerPoints(\n        Cartesian3.fromArray(minMax.min),\n        Cartesian3.fromArray(minMax.max)\n      );\n    }\n\n    var vertexArray = rendererVertexArrays[id + \".primitive.\" + i];\n    var offset;\n    var count;\n\n    // Use indices of the previously decoded Draco geometry.\n    if (defined(decodedData)) {\n      count = decodedData.numberOfIndices;\n      offset = 0;\n    } else if (defined(ix)) {\n      count = ix.count;\n      offset = ix.byteOffset / IndexDatatype.getSizeInBytes(ix.componentType); // glTF has offset in bytes.  Cesium has offsets in indices\n    } else {\n      var positions = accessors[primitive.attributes.POSITION];\n      count = positions.count;\n      offset = 0;\n    }\n\n    // Update model triangle count using number of indices\n    model._trianglesLength += triangleCountFromPrimitiveIndices(\n      primitive,\n      count\n    );\n\n    var um = uniformMaps[primitive.material];\n    var uniformMap = um.uniformMap;\n    if (defined(um.jointMatrixUniformName)) {\n      var jointUniformMap = {};\n      jointUniformMap[um.jointMatrixUniformName] = createJointMatricesFunction(\n        runtimeNode\n      );\n\n      uniformMap = combine(uniformMap, jointUniformMap);\n    }\n    if (defined(um.morphWeightsUniformName)) {\n      var morphWeightsUniformMap = {};\n      morphWeightsUniformMap[\n        um.morphWeightsUniformName\n      ] = createMorphWeightsFunction(runtimeNode);\n\n      uniformMap = combine(uniformMap, morphWeightsUniformMap);\n    }\n\n    uniformMap = combine(uniformMap, {\n      gltf_color: createColorFunction(model),\n      gltf_colorBlend: createColorBlendFunction(model),\n      gltf_clippingPlanes: createClippingPlanesFunction(model),\n      gltf_clippingPlanesEdgeStyle: createClippingPlanesEdgeStyleFunction(\n        model\n      ),\n      gltf_clippingPlanesMatrix: createClippingPlanesMatrixFunction(model),\n      gltf_iblFactor: createIBLFactorFunction(model),\n      gltf_lightColor: createLightColorFunction(model),\n      gltf_sphericalHarmonicCoefficients: createSphericalHarmonicCoefficientsFunction(\n        model\n      ),\n      gltf_specularMap: createSpecularEnvironmentMapFunction(model),\n      gltf_specularMapSize: createSpecularEnvironmentMapSizeFunction(model),\n      gltf_maxSpecularLOD: createSpecularEnvironmentMapLOD(model),\n      gltf_luminanceAtZenith: createLuminanceAtZenithFunction(model),\n    });\n\n    // Allow callback to modify the uniformMap\n    if (defined(model._uniformMapLoaded)) {\n      uniformMap = model._uniformMapLoaded(uniformMap, programId, runtimeNode);\n    }\n\n    // Add uniforms for decoding quantized attributes if used\n    var quantizedUniformMap = {};\n    if (model.extensionsUsed.WEB3D_quantized_attributes) {\n      quantizedUniformMap = createUniformsForQuantizedAttributes(\n        model,\n        primitive\n      );\n    } else if (model._dequantizeInShader && defined(decodedData)) {\n      quantizedUniformMap = createUniformsForDracoQuantizedAttributes(\n        decodedData\n      );\n    }\n    uniformMap = combine(uniformMap, quantizedUniformMap);\n\n    var rs = rendererRenderStates[primitive.material];\n    var isTranslucent = rs.blending.enabled;\n\n    var owner = model._pickObject;\n    if (!defined(owner)) {\n      owner = {\n        primitive: model,\n        id: model.id,\n        node: runtimeNode.publicNode,\n        mesh: runtimeMeshesByName[mesh.name],\n      };\n    }\n\n    var castShadows = ShadowMode.castShadows(model._shadows);\n    var receiveShadows = ShadowMode.receiveShadows(model._shadows);\n\n    var pickId;\n    if (allowPicking && !defined(model._uniformMapLoaded)) {\n      pickId = context.createPickId(owner);\n      pickIds.push(pickId);\n      var pickUniforms = {\n        czm_pickColor: createPickColorFunction(pickId.color),\n      };\n      uniformMap = combine(uniformMap, pickUniforms);\n    }\n\n    if (allowPicking) {\n      if (defined(model._pickIdLoaded) && defined(model._uniformMapLoaded)) {\n        pickId = model._pickIdLoaded();\n      } else {\n        pickId = \"czm_pickColor\";\n      }\n    }\n\n    var command = new DrawCommand({\n      boundingVolume: new BoundingSphere(), // updated in update()\n      cull: model.cull,\n      modelMatrix: new Matrix4(), // computed in update()\n      primitiveType: primitive.mode,\n      vertexArray: vertexArray,\n      count: count,\n      offset: offset,\n      shaderProgram: rendererPrograms[programId],\n      castShadows: castShadows,\n      receiveShadows: receiveShadows,\n      uniformMap: uniformMap,\n      renderState: rs,\n      owner: owner,\n      pass: isTranslucent ? Pass.TRANSLUCENT : model.opaquePass,\n      pickId: pickId,\n    });\n\n    var command2D;\n    if (!scene3DOnly) {\n      command2D = DrawCommand.shallowClone(command);\n      command2D.boundingVolume = new BoundingSphere(); // updated in update()\n      command2D.modelMatrix = new Matrix4(); // updated in update()\n    }\n\n    var nodeCommand = {\n      show: true,\n      boundingSphere: boundingSphere,\n      command: command,\n      command2D: command2D,\n      // Generated on demand when silhouette size is greater than 0.0 and silhouette alpha is greater than 0.0\n      silhouetteModelCommand: undefined,\n      silhouetteModelCommand2D: undefined,\n      silhouetteColorCommand: undefined,\n      silhouetteColorCommand2D: undefined,\n      // Generated on demand when color alpha is less than 1.0\n      translucentCommand: undefined,\n      translucentCommand2D: undefined,\n      // For updating node commands on shader reconstruction\n      programId: programId,\n    };\n    runtimeNode.commands.push(nodeCommand);\n    nodeCommands.push(nodeCommand);\n  }\n}\n\nfunction createRuntimeNodes(model, context, scene3DOnly) {\n  var loadResources = model._loadResources;\n\n  if (!loadResources.finishedEverythingButTextureCreation()) {\n    return;\n  }\n\n  if (!loadResources.createRuntimeNodes) {\n    return;\n  }\n  loadResources.createRuntimeNodes = false;\n\n  var rootNodes = [];\n  var runtimeNodes = model._runtime.nodes;\n\n  var gltf = model.gltf;\n  var nodes = gltf.nodes;\n\n  var scene = gltf.scenes[gltf.scene];\n  var sceneNodes = scene.nodes;\n  var length = sceneNodes.length;\n\n  var stack = [];\n  var seen = {};\n\n  for (var i = 0; i < length; ++i) {\n    stack.push({\n      parentRuntimeNode: undefined,\n      gltfNode: nodes[sceneNodes[i]],\n      id: sceneNodes[i],\n    });\n\n    while (stack.length > 0) {\n      var n = stack.pop();\n      seen[n.id] = true;\n      var parentRuntimeNode = n.parentRuntimeNode;\n      var gltfNode = n.gltfNode;\n\n      // Node hierarchy is a DAG so a node can have more than one parent so it may already exist\n      var runtimeNode = runtimeNodes[n.id];\n      if (runtimeNode.parents.length === 0) {\n        if (defined(gltfNode.matrix)) {\n          runtimeNode.matrix = Matrix4.fromColumnMajorArray(gltfNode.matrix);\n        } else {\n          // TRS converted to Cesium types\n          var rotation = gltfNode.rotation;\n          runtimeNode.translation = Cartesian3.fromArray(gltfNode.translation);\n          runtimeNode.rotation = Quaternion.unpack(rotation);\n          runtimeNode.scale = Cartesian3.fromArray(gltfNode.scale);\n        }\n      }\n\n      if (defined(parentRuntimeNode)) {\n        parentRuntimeNode.children.push(runtimeNode);\n        runtimeNode.parents.push(parentRuntimeNode);\n      } else {\n        rootNodes.push(runtimeNode);\n      }\n\n      if (defined(gltfNode.mesh)) {\n        createCommand(model, gltfNode, runtimeNode, context, scene3DOnly);\n      }\n\n      var children = gltfNode.children;\n      if (defined(children)) {\n        var childrenLength = children.length;\n        for (var j = 0; j < childrenLength; j++) {\n          var childId = children[j];\n          if (!seen[childId]) {\n            stack.push({\n              parentRuntimeNode: runtimeNode,\n              gltfNode: nodes[childId],\n              id: children[j],\n            });\n          }\n        }\n      }\n    }\n  }\n\n  model._runtime.rootNodes = rootNodes;\n  model._runtime.nodes = runtimeNodes;\n}\n\nfunction getGeometryByteLength(buffers) {\n  var memory = 0;\n  for (var id in buffers) {\n    if (buffers.hasOwnProperty(id)) {\n      memory += buffers[id].sizeInBytes;\n    }\n  }\n  return memory;\n}\n\nfunction getTexturesByteLength(textures) {\n  var memory = 0;\n  for (var id in textures) {\n    if (textures.hasOwnProperty(id)) {\n      memory += textures[id].sizeInBytes;\n    }\n  }\n  return memory;\n}\n\nfunction createResources(model, frameState) {\n  var context = frameState.context;\n  var scene3DOnly = frameState.scene3DOnly;\n  var quantizedVertexShaders = model._quantizedVertexShaders;\n  var toClipCoordinates = (model._toClipCoordinatesGLSL = {});\n  var techniques = model._sourceTechniques;\n  var programs = model._sourcePrograms;\n\n  var resources = model._rendererResources;\n  var shaders = resources.sourceShaders;\n  if (model._loadRendererResourcesFromCache) {\n    shaders = resources.sourceShaders =\n      model._cachedRendererResources.sourceShaders;\n  }\n\n  for (var techniqueId in techniques) {\n    if (techniques.hasOwnProperty(techniqueId)) {\n      var programId = techniques[techniqueId].program;\n      var program = programs[programId];\n      var shader = shaders[program.vertexShader];\n\n      ModelUtility.checkSupportedGlExtensions(program.glExtensions, context);\n\n      if (\n        model.extensionsUsed.WEB3D_quantized_attributes ||\n        model._dequantizeInShader\n      ) {\n        var quantizedVS = quantizedVertexShaders[programId];\n        if (!defined(quantizedVS)) {\n          quantizedVS = modifyShaderForQuantizedAttributes(\n            shader,\n            programId,\n            model\n          );\n          quantizedVertexShaders[programId] = quantizedVS;\n        }\n        shader = quantizedVS;\n      }\n\n      shader = modifyShader(shader, programId, model._vertexShaderLoaded);\n      toClipCoordinates[programId] = ModelUtility.toClipCoordinatesGLSL(\n        model.gltf,\n        shader\n      );\n    }\n  }\n\n  if (model._loadRendererResourcesFromCache) {\n    var cachedResources = model._cachedRendererResources;\n\n    resources.buffers = cachedResources.buffers;\n    resources.vertexArrays = cachedResources.vertexArrays;\n    resources.programs = cachedResources.programs;\n    resources.silhouettePrograms = cachedResources.silhouettePrograms;\n    resources.textures = cachedResources.textures;\n    resources.samplers = cachedResources.samplers;\n    resources.renderStates = cachedResources.renderStates;\n\n    // Vertex arrays are unique to this model, create instead of using the cache.\n    if (defined(model._precreatedAttributes)) {\n      createVertexArrays(model, context);\n    }\n\n    model._cachedGeometryByteLength += getGeometryByteLength(\n      cachedResources.buffers\n    );\n    model._cachedTexturesByteLength += getTexturesByteLength(\n      cachedResources.textures\n    );\n  } else {\n    createBuffers(model, frameState); // using glTF bufferViews\n    createPrograms(model, frameState);\n    createSamplers(model, context);\n    loadTexturesFromBufferViews(model);\n    createTextures(model, frameState);\n  }\n\n  createSkins(model);\n  createRuntimeAnimations(model);\n\n  if (!model._loadRendererResourcesFromCache) {\n    createVertexArrays(model, context); // using glTF meshes\n    createRenderStates(model); // using glTF materials/techniques/states\n    // Long-term, we might not cache render states if they could change\n    // due to an animation, e.g., a uniform going from opaque to transparent.\n    // Could use copy-on-write if it is worth it.  Probably overkill.\n  }\n\n  createUniformMaps(model, context); // using glTF materials/techniques\n  createRuntimeNodes(model, context, scene3DOnly); // using glTF scene\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction getNodeMatrix(node, result) {\n  var publicNode = node.publicNode;\n  var publicMatrix = publicNode.matrix;\n\n  if (publicNode.useMatrix && defined(publicMatrix)) {\n    // Public matrix overrides original glTF matrix and glTF animations\n    Matrix4.clone(publicMatrix, result);\n  } else if (defined(node.matrix)) {\n    Matrix4.clone(node.matrix, result);\n  } else {\n    Matrix4.fromTranslationQuaternionRotationScale(\n      node.translation,\n      node.rotation,\n      node.scale,\n      result\n    );\n    // Keep matrix returned by the node in-sync if the node is targeted by an animation.  Only TRS nodes can be targeted.\n    publicNode.setMatrix(result);\n  }\n}\n\nvar scratchNodeStack = [];\nvar scratchComputedTranslation = new Cartesian4();\nvar scratchComputedMatrixIn2D = new Matrix4();\n\nfunction updateNodeHierarchyModelMatrix(\n  model,\n  modelTransformChanged,\n  justLoaded,\n  projection\n) {\n  var maxDirtyNumber = model._maxDirtyNumber;\n\n  var rootNodes = model._runtime.rootNodes;\n  var length = rootNodes.length;\n\n  var nodeStack = scratchNodeStack;\n  var computedModelMatrix = model._computedModelMatrix;\n\n  if (model._mode !== SceneMode.SCENE3D && !model._ignoreCommands) {\n    var translation = Matrix4.getColumn(\n      computedModelMatrix,\n      3,\n      scratchComputedTranslation\n    );\n    if (!Cartesian4.equals(translation, Cartesian4.UNIT_W)) {\n      computedModelMatrix = Transforms.basisTo2D(\n        projection,\n        computedModelMatrix,\n        scratchComputedMatrixIn2D\n      );\n      model._rtcCenter = model._rtcCenter3D;\n    } else {\n      var center = model.boundingSphere.center;\n      var to2D = Transforms.wgs84To2DModelMatrix(\n        projection,\n        center,\n        scratchComputedMatrixIn2D\n      );\n      computedModelMatrix = Matrix4.multiply(\n        to2D,\n        computedModelMatrix,\n        scratchComputedMatrixIn2D\n      );\n\n      if (defined(model._rtcCenter)) {\n        Matrix4.setTranslation(\n          computedModelMatrix,\n          Cartesian4.UNIT_W,\n          computedModelMatrix\n        );\n        model._rtcCenter = model._rtcCenter2D;\n      }\n    }\n  }\n\n  for (var i = 0; i < length; ++i) {\n    var n = rootNodes[i];\n\n    getNodeMatrix(n, n.transformToRoot);\n    nodeStack.push(n);\n\n    while (nodeStack.length > 0) {\n      n = nodeStack.pop();\n      var transformToRoot = n.transformToRoot;\n      var commands = n.commands;\n\n      if (\n        n.dirtyNumber === maxDirtyNumber ||\n        modelTransformChanged ||\n        justLoaded\n      ) {\n        var nodeMatrix = Matrix4.multiplyTransformation(\n          computedModelMatrix,\n          transformToRoot,\n          n.computedMatrix\n        );\n        var commandsLength = commands.length;\n        if (commandsLength > 0) {\n          // Node has meshes, which has primitives.  Update their commands.\n          for (var j = 0; j < commandsLength; ++j) {\n            var primitiveCommand = commands[j];\n            var command = primitiveCommand.command;\n            Matrix4.clone(nodeMatrix, command.modelMatrix);\n\n            // PERFORMANCE_IDEA: Can use transformWithoutScale if no node up to the root has scale (including animation)\n            BoundingSphere.transform(\n              primitiveCommand.boundingSphere,\n              command.modelMatrix,\n              command.boundingVolume\n            );\n\n            if (defined(model._rtcCenter)) {\n              Cartesian3.add(\n                model._rtcCenter,\n                command.boundingVolume.center,\n                command.boundingVolume.center\n              );\n            }\n\n            // If the model crosses the IDL in 2D, it will be drawn in one viewport, but part of it\n            // will be clipped by the viewport. We create a second command that translates the model\n            // model matrix to the opposite side of the map so the part that was clipped in one viewport\n            // is drawn in the other.\n            command = primitiveCommand.command2D;\n            if (defined(command) && model._mode === SceneMode.SCENE2D) {\n              Matrix4.clone(nodeMatrix, command.modelMatrix);\n              command.modelMatrix[13] -=\n                CesiumMath.sign(command.modelMatrix[13]) *\n                2.0 *\n                CesiumMath.PI *\n                projection.ellipsoid.maximumRadius;\n              BoundingSphere.transform(\n                primitiveCommand.boundingSphere,\n                command.modelMatrix,\n                command.boundingVolume\n              );\n            }\n          }\n        }\n      }\n\n      var children = n.children;\n      if (defined(children)) {\n        var childrenLength = children.length;\n        for (var k = 0; k < childrenLength; ++k) {\n          var child = children[k];\n\n          // A node's transform needs to be updated if\n          // - It was targeted for animation this frame, or\n          // - Any of its ancestors were targeted for animation this frame\n\n          // PERFORMANCE_IDEA: if a child has multiple parents and only one of the parents\n          // is dirty, all the subtrees for each child instance will be dirty; we probably\n          // won't see this in the wild often.\n          child.dirtyNumber = Math.max(child.dirtyNumber, n.dirtyNumber);\n\n          if (child.dirtyNumber === maxDirtyNumber || justLoaded) {\n            // Don't check for modelTransformChanged since if only the model's model matrix changed,\n            // we do not need to rebuild the local transform-to-root, only the final\n            // [model's-model-matrix][transform-to-root] above.\n            getNodeMatrix(child, child.transformToRoot);\n            Matrix4.multiplyTransformation(\n              transformToRoot,\n              child.transformToRoot,\n              child.transformToRoot\n            );\n          }\n\n          nodeStack.push(child);\n        }\n      }\n    }\n  }\n\n  ++model._maxDirtyNumber;\n}\n\nvar scratchObjectSpace = new Matrix4();\n\nfunction applySkins(model) {\n  var skinnedNodes = model._runtime.skinnedNodes;\n  var length = skinnedNodes.length;\n\n  for (var i = 0; i < length; ++i) {\n    var node = skinnedNodes[i];\n\n    scratchObjectSpace = Matrix4.inverseTransformation(\n      node.transformToRoot,\n      scratchObjectSpace\n    );\n\n    var computedJointMatrices = node.computedJointMatrices;\n    var joints = node.joints;\n    var bindShapeMatrix = node.bindShapeMatrix;\n    var inverseBindMatrices = node.inverseBindMatrices;\n    var inverseBindMatricesLength = inverseBindMatrices.length;\n\n    for (var m = 0; m < inverseBindMatricesLength; ++m) {\n      // [joint-matrix] = [node-to-root^-1][joint-to-root][inverse-bind][bind-shape]\n      if (!defined(computedJointMatrices[m])) {\n        computedJointMatrices[m] = new Matrix4();\n      }\n      computedJointMatrices[m] = Matrix4.multiplyTransformation(\n        scratchObjectSpace,\n        joints[m].transformToRoot,\n        computedJointMatrices[m]\n      );\n      computedJointMatrices[m] = Matrix4.multiplyTransformation(\n        computedJointMatrices[m],\n        inverseBindMatrices[m],\n        computedJointMatrices[m]\n      );\n      if (defined(bindShapeMatrix)) {\n        // Optimization for when bind shape matrix is the identity.\n        computedJointMatrices[m] = Matrix4.multiplyTransformation(\n          computedJointMatrices[m],\n          bindShapeMatrix,\n          computedJointMatrices[m]\n        );\n      }\n    }\n  }\n}\n\nfunction updatePerNodeShow(model) {\n  // Totally not worth it, but we could optimize this:\n  // http://help.agi.com/AGIComponents/html/BlogDeletionInBoundingVolumeHierarchies.htm\n\n  var rootNodes = model._runtime.rootNodes;\n  var length = rootNodes.length;\n\n  var nodeStack = scratchNodeStack;\n\n  for (var i = 0; i < length; ++i) {\n    var n = rootNodes[i];\n    n.computedShow = n.publicNode.show;\n    nodeStack.push(n);\n\n    while (nodeStack.length > 0) {\n      n = nodeStack.pop();\n      var show = n.computedShow;\n\n      var nodeCommands = n.commands;\n      var nodeCommandsLength = nodeCommands.length;\n      for (var j = 0; j < nodeCommandsLength; ++j) {\n        nodeCommands[j].show = show;\n      }\n      // if commandsLength is zero, the node has a light or camera\n\n      var children = n.children;\n      if (defined(children)) {\n        var childrenLength = children.length;\n        for (var k = 0; k < childrenLength; ++k) {\n          var child = children[k];\n          // Parent needs to be shown for child to be shown.\n          child.computedShow = show && child.publicNode.show;\n          nodeStack.push(child);\n        }\n      }\n    }\n  }\n}\n\nfunction updatePickIds(model, context) {\n  var id = model.id;\n  if (model._id !== id) {\n    model._id = id;\n\n    var pickIds = model._pickIds;\n    var length = pickIds.length;\n    for (var i = 0; i < length; ++i) {\n      pickIds[i].object.id = id;\n    }\n  }\n}\n\nfunction updateWireframe(model) {\n  if (model._debugWireframe !== model.debugWireframe) {\n    model._debugWireframe = model.debugWireframe;\n\n    // This assumes the original primitive was TRIANGLES and that the triangles\n    // are connected for the wireframe to look perfect.\n    var primitiveType = model.debugWireframe\n      ? PrimitiveType.LINES\n      : PrimitiveType.TRIANGLES;\n    var nodeCommands = model._nodeCommands;\n    var length = nodeCommands.length;\n\n    for (var i = 0; i < length; ++i) {\n      nodeCommands[i].command.primitiveType = primitiveType;\n    }\n  }\n}\n\nfunction updateShowBoundingVolume(model) {\n  if (model.debugShowBoundingVolume !== model._debugShowBoundingVolume) {\n    model._debugShowBoundingVolume = model.debugShowBoundingVolume;\n\n    var debugShowBoundingVolume = model.debugShowBoundingVolume;\n    var nodeCommands = model._nodeCommands;\n    var length = nodeCommands.length;\n\n    for (var i = 0; i < length; ++i) {\n      nodeCommands[i].command.debugShowBoundingVolume = debugShowBoundingVolume;\n    }\n  }\n}\n\nfunction updateShadows(model) {\n  if (model.shadows !== model._shadows) {\n    model._shadows = model.shadows;\n\n    var castShadows = ShadowMode.castShadows(model.shadows);\n    var receiveShadows = ShadowMode.receiveShadows(model.shadows);\n    var nodeCommands = model._nodeCommands;\n    var length = nodeCommands.length;\n\n    for (var i = 0; i < length; i++) {\n      var nodeCommand = nodeCommands[i];\n      nodeCommand.command.castShadows = castShadows;\n      nodeCommand.command.receiveShadows = receiveShadows;\n    }\n  }\n}\n\nfunction getTranslucentRenderState(renderState) {\n  var rs = clone(renderState, true);\n  rs.cull.enabled = false;\n  rs.depthTest.enabled = true;\n  rs.depthMask = false;\n  rs.blending = BlendingState.ALPHA_BLEND;\n\n  return RenderState.fromCache(rs);\n}\n\nfunction deriveTranslucentCommand(command) {\n  var translucentCommand = DrawCommand.shallowClone(command);\n  translucentCommand.pass = Pass.TRANSLUCENT;\n  translucentCommand.renderState = getTranslucentRenderState(\n    command.renderState\n  );\n  return translucentCommand;\n}\n\nfunction updateColor(model, frameState, forceDerive) {\n  // Generate translucent commands when the blend color has an alpha in the range (0.0, 1.0) exclusive\n  var scene3DOnly = frameState.scene3DOnly;\n  var alpha = model.color.alpha;\n  if (alpha > 0.0 && alpha < 1.0) {\n    var nodeCommands = model._nodeCommands;\n    var length = nodeCommands.length;\n    if (!defined(nodeCommands[0].translucentCommand) || forceDerive) {\n      for (var i = 0; i < length; ++i) {\n        var nodeCommand = nodeCommands[i];\n        var command = nodeCommand.command;\n        nodeCommand.translucentCommand = deriveTranslucentCommand(command);\n        if (!scene3DOnly) {\n          var command2D = nodeCommand.command2D;\n          nodeCommand.translucentCommand2D = deriveTranslucentCommand(\n            command2D\n          );\n        }\n      }\n    }\n  }\n}\n\nfunction getProgramId(model, program) {\n  var programs = model._rendererResources.programs;\n  for (var id in programs) {\n    if (programs.hasOwnProperty(id)) {\n      if (programs[id] === program) {\n        return id;\n      }\n    }\n  }\n}\n\nfunction createSilhouetteProgram(model, program, frameState) {\n  var vs = program.vertexShaderSource.sources[0];\n  var attributeLocations = program._attributeLocations;\n  var normalAttributeName = model._normalAttributeName;\n\n  // Modified from http://forum.unity3d.com/threads/toon-outline-but-with-diffuse-surface.24668/\n  vs = ShaderSource.replaceMain(vs, \"gltf_silhouette_main\");\n  vs +=\n    \"uniform float gltf_silhouetteSize; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    gltf_silhouette_main(); \\n\" +\n    \"    vec3 n = normalize(czm_normal3D * \" +\n    normalAttributeName +\n    \"); \\n\" +\n    \"    n.x *= czm_projection[0][0]; \\n\" +\n    \"    n.y *= czm_projection[1][1]; \\n\" +\n    \"    vec4 clip = gl_Position; \\n\" +\n    \"    clip.xy += n.xy * clip.w * gltf_silhouetteSize * czm_pixelRatio / czm_viewport.z; \\n\" +\n    \"    gl_Position = clip; \\n\" +\n    \"}\";\n\n  var fs =\n    \"uniform vec4 gltf_silhouetteColor; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    gl_FragColor = czm_gammaCorrect(gltf_silhouetteColor); \\n\" +\n    \"}\";\n\n  return ShaderProgram.fromCache({\n    context: frameState.context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n}\n\nfunction hasSilhouette(model, frameState) {\n  return (\n    silhouetteSupported(frameState.context) &&\n    model.silhouetteSize > 0.0 &&\n    model.silhouetteColor.alpha > 0.0 &&\n    defined(model._normalAttributeName)\n  );\n}\n\nfunction hasTranslucentCommands(model) {\n  var nodeCommands = model._nodeCommands;\n  var length = nodeCommands.length;\n  for (var i = 0; i < length; ++i) {\n    var nodeCommand = nodeCommands[i];\n    var command = nodeCommand.command;\n    if (command.pass === Pass.TRANSLUCENT) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction isTranslucent(model) {\n  return model.color.alpha > 0.0 && model.color.alpha < 1.0;\n}\n\nfunction isInvisible(model) {\n  return model.color.alpha === 0.0;\n}\n\nfunction alphaDirty(currAlpha, prevAlpha) {\n  // Returns whether the alpha state has changed between invisible, translucent, or opaque\n  return (\n    Math.floor(currAlpha) !== Math.floor(prevAlpha) ||\n    Math.ceil(currAlpha) !== Math.ceil(prevAlpha)\n  );\n}\n\nvar silhouettesLength = 0;\n\nfunction createSilhouetteCommands(model, frameState) {\n  // Wrap around after exceeding the 8-bit stencil limit.\n  // The reference is unique to each model until this point.\n  var stencilReference = ++silhouettesLength % 255;\n\n  // If the model is translucent the silhouette needs to be in the translucent pass.\n  // Otherwise the silhouette would be rendered before the model.\n  var silhouetteTranslucent =\n    hasTranslucentCommands(model) ||\n    isTranslucent(model) ||\n    model.silhouetteColor.alpha < 1.0;\n  var silhouettePrograms = model._rendererResources.silhouettePrograms;\n  var scene3DOnly = frameState.scene3DOnly;\n  var nodeCommands = model._nodeCommands;\n  var length = nodeCommands.length;\n  for (var i = 0; i < length; ++i) {\n    var nodeCommand = nodeCommands[i];\n    var command = nodeCommand.command;\n\n    // Create model command\n    var modelCommand = isTranslucent(model)\n      ? nodeCommand.translucentCommand\n      : command;\n    var silhouetteModelCommand = DrawCommand.shallowClone(modelCommand);\n    var renderState = clone(modelCommand.renderState);\n\n    // Write the reference value into the stencil buffer.\n    renderState.stencilTest = {\n      enabled: true,\n      frontFunction: WebGLConstants.ALWAYS,\n      backFunction: WebGLConstants.ALWAYS,\n      reference: stencilReference,\n      mask: ~0,\n      frontOperation: {\n        fail: WebGLConstants.KEEP,\n        zFail: WebGLConstants.KEEP,\n        zPass: WebGLConstants.REPLACE,\n      },\n      backOperation: {\n        fail: WebGLConstants.KEEP,\n        zFail: WebGLConstants.KEEP,\n        zPass: WebGLConstants.REPLACE,\n      },\n    };\n\n    if (isInvisible(model)) {\n      // When the model is invisible disable color and depth writes but still write into the stencil buffer\n      renderState.colorMask = {\n        red: false,\n        green: false,\n        blue: false,\n        alpha: false,\n      };\n      renderState.depthMask = false;\n    }\n    renderState = RenderState.fromCache(renderState);\n    silhouetteModelCommand.renderState = renderState;\n    nodeCommand.silhouetteModelCommand = silhouetteModelCommand;\n\n    // Create color command\n    var silhouetteColorCommand = DrawCommand.shallowClone(command);\n    renderState = clone(command.renderState, true);\n    renderState.depthTest.enabled = true;\n    renderState.cull.enabled = false;\n    if (silhouetteTranslucent) {\n      silhouetteColorCommand.pass = Pass.TRANSLUCENT;\n      renderState.depthMask = false;\n      renderState.blending = BlendingState.ALPHA_BLEND;\n    }\n\n    // Only render silhouette if the value in the stencil buffer equals the reference\n    renderState.stencilTest = {\n      enabled: true,\n      frontFunction: WebGLConstants.NOTEQUAL,\n      backFunction: WebGLConstants.NOTEQUAL,\n      reference: stencilReference,\n      mask: ~0,\n      frontOperation: {\n        fail: WebGLConstants.KEEP,\n        zFail: WebGLConstants.KEEP,\n        zPass: WebGLConstants.KEEP,\n      },\n      backOperation: {\n        fail: WebGLConstants.KEEP,\n        zFail: WebGLConstants.KEEP,\n        zPass: WebGLConstants.KEEP,\n      },\n    };\n    renderState = RenderState.fromCache(renderState);\n\n    // If the silhouette program has already been cached use it\n    var program = command.shaderProgram;\n    var id = getProgramId(model, program);\n    var silhouetteProgram = silhouettePrograms[id];\n    if (!defined(silhouetteProgram)) {\n      silhouetteProgram = createSilhouetteProgram(model, program, frameState);\n      silhouettePrograms[id] = silhouetteProgram;\n    }\n\n    var silhouetteUniformMap = combine(command.uniformMap, {\n      gltf_silhouetteColor: createSilhouetteColorFunction(model),\n      gltf_silhouetteSize: createSilhouetteSizeFunction(model),\n    });\n\n    silhouetteColorCommand.renderState = renderState;\n    silhouetteColorCommand.shaderProgram = silhouetteProgram;\n    silhouetteColorCommand.uniformMap = silhouetteUniformMap;\n    silhouetteColorCommand.castShadows = false;\n    silhouetteColorCommand.receiveShadows = false;\n    nodeCommand.silhouetteColorCommand = silhouetteColorCommand;\n\n    if (!scene3DOnly) {\n      var command2D = nodeCommand.command2D;\n      var silhouetteModelCommand2D = DrawCommand.shallowClone(\n        silhouetteModelCommand\n      );\n      silhouetteModelCommand2D.boundingVolume = command2D.boundingVolume;\n      silhouetteModelCommand2D.modelMatrix = command2D.modelMatrix;\n      nodeCommand.silhouetteModelCommand2D = silhouetteModelCommand2D;\n\n      var silhouetteColorCommand2D = DrawCommand.shallowClone(\n        silhouetteColorCommand\n      );\n      silhouetteModelCommand2D.boundingVolume = command2D.boundingVolume;\n      silhouetteModelCommand2D.modelMatrix = command2D.modelMatrix;\n      nodeCommand.silhouetteColorCommand2D = silhouetteColorCommand2D;\n    }\n  }\n}\n\nfunction modifyShaderForClippingPlanes(\n  shader,\n  clippingPlaneCollection,\n  context\n) {\n  shader = ShaderSource.replaceMain(shader, \"gltf_clip_main\");\n  shader += Model._getClippingFunction(clippingPlaneCollection, context) + \"\\n\";\n  shader +=\n    \"uniform sampler2D gltf_clippingPlanes; \\n\" +\n    \"uniform mat4 gltf_clippingPlanesMatrix; \\n\" +\n    \"uniform vec4 gltf_clippingPlanesEdgeStyle; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    gltf_clip_main(); \\n\" +\n    getClipAndStyleCode(\n      \"gltf_clippingPlanes\",\n      \"gltf_clippingPlanesMatrix\",\n      \"gltf_clippingPlanesEdgeStyle\"\n    ) +\n    \"} \\n\";\n  return shader;\n}\n\nfunction updateSilhouette(model, frameState, force) {\n  // Generate silhouette commands when the silhouette size is greater than 0.0 and the alpha is greater than 0.0\n  // There are two silhouette commands:\n  //     1. silhouetteModelCommand : render model normally while enabling stencil mask\n  //     2. silhouetteColorCommand : render enlarged model with a solid color while enabling stencil tests\n  if (!hasSilhouette(model, frameState)) {\n    return;\n  }\n\n  var nodeCommands = model._nodeCommands;\n  var dirty =\n    alphaDirty(model.color.alpha, model._colorPreviousAlpha) ||\n    alphaDirty(\n      model.silhouetteColor.alpha,\n      model._silhouetteColorPreviousAlpha\n    ) ||\n    !defined(nodeCommands[0].silhouetteModelCommand);\n\n  model._colorPreviousAlpha = model.color.alpha;\n  model._silhouetteColorPreviousAlpha = model.silhouetteColor.alpha;\n\n  if (dirty || force) {\n    createSilhouetteCommands(model, frameState);\n  }\n}\n\nfunction updateClippingPlanes(model, frameState) {\n  var clippingPlanes = model._clippingPlanes;\n  if (defined(clippingPlanes) && clippingPlanes.owner === model) {\n    if (clippingPlanes.enabled) {\n      clippingPlanes.update(frameState);\n    }\n  }\n}\n\nvar scratchBoundingSphere = new BoundingSphere();\n\nfunction scaleInPixels(positionWC, radius, frameState) {\n  scratchBoundingSphere.center = positionWC;\n  scratchBoundingSphere.radius = radius;\n  return frameState.camera.getPixelSize(\n    scratchBoundingSphere,\n    frameState.context.drawingBufferWidth,\n    frameState.context.drawingBufferHeight\n  );\n}\n\nvar scratchPosition = new Cartesian3();\nvar scratchCartographic = new Cartographic();\n\nfunction getScale(model, frameState) {\n  var scale = model.scale;\n\n  if (model.minimumPixelSize !== 0.0) {\n    // Compute size of bounding sphere in pixels\n    var context = frameState.context;\n    var maxPixelSize = Math.max(\n      context.drawingBufferWidth,\n      context.drawingBufferHeight\n    );\n    var m = defined(model._clampedModelMatrix)\n      ? model._clampedModelMatrix\n      : model.modelMatrix;\n    scratchPosition.x = m[12];\n    scratchPosition.y = m[13];\n    scratchPosition.z = m[14];\n\n    if (defined(model._rtcCenter)) {\n      Cartesian3.add(model._rtcCenter, scratchPosition, scratchPosition);\n    }\n\n    if (model._mode !== SceneMode.SCENE3D) {\n      var projection = frameState.mapProjection;\n      var cartographic = projection.ellipsoid.cartesianToCartographic(\n        scratchPosition,\n        scratchCartographic\n      );\n      projection.project(cartographic, scratchPosition);\n      Cartesian3.fromElements(\n        scratchPosition.z,\n        scratchPosition.x,\n        scratchPosition.y,\n        scratchPosition\n      );\n    }\n\n    var radius = model.boundingSphere.radius;\n    var metersPerPixel = scaleInPixels(scratchPosition, radius, frameState);\n\n    // metersPerPixel is always > 0.0\n    var pixelsPerMeter = 1.0 / metersPerPixel;\n    var diameterInPixels = Math.min(\n      pixelsPerMeter * (2.0 * radius),\n      maxPixelSize\n    );\n\n    // Maintain model's minimum pixel size\n    if (diameterInPixels < model.minimumPixelSize) {\n      scale =\n        (model.minimumPixelSize * metersPerPixel) /\n        (2.0 * model._initialRadius);\n    }\n  }\n\n  return defined(model.maximumScale)\n    ? Math.min(model.maximumScale, scale)\n    : scale;\n}\n\nfunction releaseCachedGltf(model) {\n  if (\n    defined(model._cacheKey) &&\n    defined(model._cachedGltf) &&\n    --model._cachedGltf.count === 0\n  ) {\n    delete gltfCache[model._cacheKey];\n  }\n  model._cachedGltf = undefined;\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction CachedRendererResources(context, cacheKey) {\n  this.buffers = undefined;\n  this.vertexArrays = undefined;\n  this.programs = undefined;\n  this.sourceShaders = undefined;\n  this.silhouettePrograms = undefined;\n  this.textures = undefined;\n  this.samplers = undefined;\n  this.renderStates = undefined;\n  this.ready = false;\n\n  this.context = context;\n  this.cacheKey = cacheKey;\n  this.count = 0;\n}\n\nfunction destroy(property) {\n  for (var name in property) {\n    if (property.hasOwnProperty(name)) {\n      property[name].destroy();\n    }\n  }\n}\n\nfunction destroyCachedRendererResources(resources) {\n  destroy(resources.buffers);\n  destroy(resources.vertexArrays);\n  destroy(resources.programs);\n  destroy(resources.silhouettePrograms);\n  destroy(resources.textures);\n}\n\nCachedRendererResources.prototype.release = function () {\n  if (--this.count === 0) {\n    if (defined(this.cacheKey)) {\n      // Remove if this was cached\n      delete this.context.cache.modelRendererResourceCache[this.cacheKey];\n    }\n    destroyCachedRendererResources(this);\n    return destroyObject(this);\n  }\n\n  return undefined;\n};\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction getUpdateHeightCallback(model, ellipsoid, cartoPosition) {\n  return function (clampedPosition) {\n    if (model.heightReference === HeightReference.RELATIVE_TO_GROUND) {\n      var clampedCart = ellipsoid.cartesianToCartographic(\n        clampedPosition,\n        scratchCartographic\n      );\n      clampedCart.height += cartoPosition.height;\n      ellipsoid.cartographicToCartesian(clampedCart, clampedPosition);\n    }\n\n    var clampedModelMatrix = model._clampedModelMatrix;\n\n    // Modify clamped model matrix to use new height\n    Matrix4.clone(model.modelMatrix, clampedModelMatrix);\n    clampedModelMatrix[12] = clampedPosition.x;\n    clampedModelMatrix[13] = clampedPosition.y;\n    clampedModelMatrix[14] = clampedPosition.z;\n\n    model._heightChanged = true;\n  };\n}\n\nfunction updateClamping(model) {\n  if (defined(model._removeUpdateHeightCallback)) {\n    model._removeUpdateHeightCallback();\n    model._removeUpdateHeightCallback = undefined;\n  }\n\n  var scene = model._scene;\n  if (\n    !defined(scene) ||\n    !defined(scene.globe) ||\n    model.heightReference === HeightReference.NONE\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    if (model.heightReference !== HeightReference.NONE) {\n      throw new DeveloperError(\n        \"Height reference is not supported without a scene and globe.\"\n      );\n    }\n    //>>includeEnd('debug');\n    model._clampedModelMatrix = undefined;\n    return;\n  }\n\n  var globe = scene.globe;\n  var ellipsoid = globe.ellipsoid;\n\n  // Compute cartographic position so we don't recompute every update\n  var modelMatrix = model.modelMatrix;\n  scratchPosition.x = modelMatrix[12];\n  scratchPosition.y = modelMatrix[13];\n  scratchPosition.z = modelMatrix[14];\n  var cartoPosition = ellipsoid.cartesianToCartographic(scratchPosition);\n\n  if (!defined(model._clampedModelMatrix)) {\n    model._clampedModelMatrix = Matrix4.clone(modelMatrix, new Matrix4());\n  }\n\n  // Install callback to handle updating of terrain tiles\n  var surface = globe._surface;\n  model._removeUpdateHeightCallback = surface.updateHeight(\n    cartoPosition,\n    getUpdateHeightCallback(model, ellipsoid, cartoPosition)\n  );\n\n  // Set the correct height now\n  var height = globe.getHeight(cartoPosition);\n  if (defined(height)) {\n    // Get callback with cartoPosition being the non-clamped position\n    var cb = getUpdateHeightCallback(model, ellipsoid, cartoPosition);\n\n    // Compute the clamped cartesian and call updateHeight callback\n    Cartographic.clone(cartoPosition, scratchCartographic);\n    scratchCartographic.height = height;\n    ellipsoid.cartographicToCartesian(scratchCartographic, scratchPosition);\n    cb(scratchPosition);\n  }\n}\n\nvar scratchDisplayConditionCartesian = new Cartesian3();\nvar scratchDistanceDisplayConditionCartographic = new Cartographic();\n\nfunction distanceDisplayConditionVisible(model, frameState) {\n  var distance2;\n  var ddc = model.distanceDisplayCondition;\n  var nearSquared = ddc.near * ddc.near;\n  var farSquared = ddc.far * ddc.far;\n\n  if (frameState.mode === SceneMode.SCENE2D) {\n    var frustum2DWidth =\n      frameState.camera.frustum.right - frameState.camera.frustum.left;\n    distance2 = frustum2DWidth * 0.5;\n    distance2 = distance2 * distance2;\n  } else {\n    // Distance to center of primitive's reference frame\n    var position = Matrix4.getTranslation(\n      model.modelMatrix,\n      scratchDisplayConditionCartesian\n    );\n    if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n      var projection = frameState.mapProjection;\n      var ellipsoid = projection.ellipsoid;\n      var cartographic = ellipsoid.cartesianToCartographic(\n        position,\n        scratchDistanceDisplayConditionCartographic\n      );\n      position = projection.project(cartographic, position);\n      Cartesian3.fromElements(position.z, position.x, position.y, position);\n    }\n    distance2 = Cartesian3.distanceSquared(\n      position,\n      frameState.camera.positionWC\n    );\n  }\n\n  return distance2 >= nearSquared && distance2 <= farSquared;\n}\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {RuntimeError} Failed to load external reference.\n */\nModel.prototype.update = function (frameState) {\n  if (frameState.mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  if (!FeatureDetection.supportsWebP.initialized) {\n    FeatureDetection.supportsWebP.initialize();\n    return;\n  }\n  var supportsWebP = FeatureDetection.supportsWebP();\n\n  var context = frameState.context;\n  this._defaultTexture = context.defaultTexture;\n\n  if (this._state === ModelState.NEEDS_LOAD && defined(this.gltf)) {\n    // Use renderer resources from cache instead of loading/creating them?\n    var cachedRendererResources;\n    var cacheKey = this.cacheKey;\n    if (defined(cacheKey)) {\n      // cache key given? this model will pull from or contribute to context level cache\n      context.cache.modelRendererResourceCache = defaultValue(\n        context.cache.modelRendererResourceCache,\n        {}\n      );\n      var modelCaches = context.cache.modelRendererResourceCache;\n\n      cachedRendererResources = modelCaches[this.cacheKey];\n      if (defined(cachedRendererResources)) {\n        if (!cachedRendererResources.ready) {\n          // Cached resources for the model are not loaded yet.  We'll\n          // try again every frame until they are.\n          return;\n        }\n\n        ++cachedRendererResources.count;\n        this._loadRendererResourcesFromCache = true;\n      } else {\n        cachedRendererResources = new CachedRendererResources(\n          context,\n          cacheKey\n        );\n        cachedRendererResources.count = 1;\n        modelCaches[this.cacheKey] = cachedRendererResources;\n      }\n      this._cachedRendererResources = cachedRendererResources;\n    } else {\n      // cache key not given? this model doesn't care about context level cache at all. Cache is here to simplify freeing on destroy.\n      cachedRendererResources = new CachedRendererResources(context);\n      cachedRendererResources.count = 1;\n      this._cachedRendererResources = cachedRendererResources;\n    }\n\n    this._state = ModelState.LOADING;\n    if (this._state !== ModelState.FAILED) {\n      var extensions = this.gltf.extensions;\n      if (defined(extensions) && defined(extensions.CESIUM_RTC)) {\n        var center = Cartesian3.fromArray(extensions.CESIUM_RTC.center);\n        if (!Cartesian3.equals(center, Cartesian3.ZERO)) {\n          this._rtcCenter3D = center;\n\n          var projection = frameState.mapProjection;\n          var ellipsoid = projection.ellipsoid;\n          var cartographic = ellipsoid.cartesianToCartographic(\n            this._rtcCenter3D\n          );\n          var projectedCart = projection.project(cartographic);\n          Cartesian3.fromElements(\n            projectedCart.z,\n            projectedCart.x,\n            projectedCart.y,\n            projectedCart\n          );\n          this._rtcCenter2D = projectedCart;\n\n          this._rtcCenterEye = new Cartesian3();\n          this._rtcCenter = this._rtcCenter3D;\n        }\n      }\n\n      addPipelineExtras(this.gltf);\n\n      this._loadResources = new ModelLoadResources();\n      if (!this._loadRendererResourcesFromCache) {\n        // Buffers are required to updateVersion\n        ModelUtility.parseBuffers(this, bufferLoad);\n      }\n    }\n  }\n\n  var loadResources = this._loadResources;\n  var incrementallyLoadTextures = this._incrementallyLoadTextures;\n  var justLoaded = false;\n\n  if (this._state === ModelState.LOADING) {\n    // Transition from LOADING -> LOADED once resources are downloaded and created.\n    // Textures may continue to stream in while in the LOADED state.\n    if (loadResources.pendingBufferLoads === 0) {\n      if (!loadResources.initialized) {\n        frameState.brdfLutGenerator.update(frameState);\n\n        ModelUtility.checkSupportedExtensions(\n          this.extensionsRequired,\n          supportsWebP\n        );\n        ModelUtility.updateForwardAxis(this);\n\n        // glTF pipeline updates, not needed if loading from cache\n        if (!defined(this.gltf.extras.sourceVersion)) {\n          var gltf = this.gltf;\n          // Add the original version so it remains cached\n          gltf.extras.sourceVersion = ModelUtility.getAssetVersion(gltf);\n          gltf.extras.sourceKHRTechniquesWebGL = defined(\n            ModelUtility.getUsedExtensions(gltf).KHR_techniques_webgl\n          );\n\n          this._sourceVersion = gltf.extras.sourceVersion;\n          this._sourceKHRTechniquesWebGL = gltf.extras.sourceKHRTechniquesWebGL;\n\n          updateVersion(gltf);\n          addDefaults(gltf);\n\n          var options = {\n            addBatchIdToGeneratedShaders: this._addBatchIdToGeneratedShaders,\n          };\n\n          processModelMaterialsCommon(gltf, options);\n          processPbrMaterials(gltf, options);\n        }\n\n        this._sourceVersion = this.gltf.extras.sourceVersion;\n        this._sourceKHRTechniquesWebGL = this.gltf.extras.sourceKHRTechniquesWebGL;\n\n        // Skip dequantizing in the shader if not encoded\n        this._dequantizeInShader =\n          this._dequantizeInShader && DracoLoader.hasExtension(this);\n\n        // We do this after to make sure that the ids don't change\n        addBuffersToLoadResources(this);\n        parseArticulations(this);\n        parseTechniques(this);\n        if (!this._loadRendererResourcesFromCache) {\n          parseBufferViews(this);\n          parseShaders(this);\n          parsePrograms(this);\n          parseTextures(this, context, supportsWebP);\n        }\n        parseMaterials(this);\n        parseMeshes(this);\n        parseNodes(this);\n\n        // Start draco decoding\n        DracoLoader.parse(this, context);\n\n        loadResources.initialized = true;\n      }\n\n      if (!loadResources.finishedDecoding()) {\n        DracoLoader.decodeModel(this, context).otherwise(\n          ModelUtility.getFailedLoadFunction(this, \"model\", this.basePath)\n        );\n      }\n\n      if (loadResources.finishedDecoding() && !loadResources.resourcesParsed) {\n        this._boundingSphere = ModelUtility.computeBoundingSphere(this);\n        this._initialRadius = this._boundingSphere.radius;\n\n        DracoLoader.cacheDataForModel(this);\n\n        loadResources.resourcesParsed = true;\n      }\n\n      if (\n        loadResources.resourcesParsed &&\n        loadResources.pendingShaderLoads === 0\n      ) {\n        ModelOutlineLoader.outlinePrimitives(this);\n        createResources(this, frameState);\n      }\n    }\n\n    if (\n      loadResources.finished() ||\n      (incrementallyLoadTextures &&\n        loadResources.finishedEverythingButTextureCreation())\n    ) {\n      this._state = ModelState.LOADED;\n      justLoaded = true;\n    }\n  }\n\n  // Incrementally stream textures.\n  if (defined(loadResources) && this._state === ModelState.LOADED) {\n    if (incrementallyLoadTextures && !justLoaded) {\n      createResources(this, frameState);\n    }\n\n    if (loadResources.finished()) {\n      this._loadResources = undefined; // Clear CPU memory since WebGL resources were created.\n\n      var resources = this._rendererResources;\n      var cachedResources = this._cachedRendererResources;\n\n      cachedResources.buffers = resources.buffers;\n      cachedResources.vertexArrays = resources.vertexArrays;\n      cachedResources.programs = resources.programs;\n      cachedResources.sourceShaders = resources.sourceShaders;\n      cachedResources.silhouettePrograms = resources.silhouettePrograms;\n      cachedResources.textures = resources.textures;\n      cachedResources.samplers = resources.samplers;\n      cachedResources.renderStates = resources.renderStates;\n      cachedResources.ready = true;\n\n      // The normal attribute name is required for silhouettes, so get it before the gltf JSON is released\n      this._normalAttributeName = ModelUtility.getAttributeOrUniformBySemantic(\n        this.gltf,\n        \"NORMAL\"\n      );\n\n      // Vertex arrays are unique to this model, do not store in cache.\n      if (defined(this._precreatedAttributes)) {\n        cachedResources.vertexArrays = {};\n      }\n\n      if (this.releaseGltfJson) {\n        releaseCachedGltf(this);\n      }\n    }\n  }\n\n  var iblSupported = OctahedralProjectedCubeMap.isSupported(context);\n  if (this._shouldUpdateSpecularMapAtlas && iblSupported) {\n    this._shouldUpdateSpecularMapAtlas = false;\n    this._specularEnvironmentMapAtlas =\n      this._specularEnvironmentMapAtlas &&\n      this._specularEnvironmentMapAtlas.destroy();\n    this._specularEnvironmentMapAtlas = undefined;\n    if (defined(this._specularEnvironmentMaps)) {\n      this._specularEnvironmentMapAtlas = new OctahedralProjectedCubeMap(\n        this._specularEnvironmentMaps\n      );\n      var that = this;\n      this._specularEnvironmentMapAtlas.readyPromise\n        .then(function () {\n          that._shouldRegenerateShaders = true;\n        })\n        .otherwise(function (error) {\n          console.error(\"Error loading specularEnvironmentMaps: \" + error);\n        });\n    }\n\n    // Regenerate shaders to not use an environment map. Will be set to true again if there was a new environment map and it is ready.\n    this._shouldRegenerateShaders = true;\n  }\n\n  if (defined(this._specularEnvironmentMapAtlas)) {\n    this._specularEnvironmentMapAtlas.update(frameState);\n  }\n\n  var recompileWithDefaultAtlas =\n    !defined(this._specularEnvironmentMapAtlas) &&\n    defined(frameState.specularEnvironmentMaps) &&\n    !this._useDefaultSpecularMaps;\n  var recompileWithoutDefaultAtlas =\n    !defined(frameState.specularEnvironmentMaps) &&\n    this._useDefaultSpecularMaps;\n\n  var recompileWithDefaultSHCoeffs =\n    !defined(this._sphericalHarmonicCoefficients) &&\n    defined(frameState.sphericalHarmonicCoefficients) &&\n    !this._useDefaultSphericalHarmonics;\n  var recompileWithoutDefaultSHCoeffs =\n    !defined(frameState.sphericalHarmonicCoefficients) &&\n    this._useDefaultSphericalHarmonics;\n\n  this._shouldRegenerateShaders =\n    this._shouldRegenerateShaders ||\n    recompileWithDefaultAtlas ||\n    recompileWithoutDefaultAtlas ||\n    recompileWithDefaultSHCoeffs ||\n    recompileWithoutDefaultSHCoeffs;\n\n  this._useDefaultSpecularMaps =\n    !defined(this._specularEnvironmentMapAtlas) &&\n    defined(frameState.specularEnvironmentMaps);\n  this._useDefaultSphericalHarmonics =\n    !defined(this._sphericalHarmonicCoefficients) &&\n    defined(frameState.sphericalHarmonicCoefficients);\n\n  var silhouette = hasSilhouette(this, frameState);\n  var translucent = isTranslucent(this);\n  var invisible = isInvisible(this);\n  var displayConditionPassed = defined(this.distanceDisplayCondition)\n    ? distanceDisplayConditionVisible(this, frameState)\n    : true;\n  var show =\n    this.show &&\n    displayConditionPassed &&\n    this.scale !== 0.0 &&\n    (!invisible || silhouette);\n\n  if ((show && this._state === ModelState.LOADED) || justLoaded) {\n    var animated =\n      this.activeAnimations.update(frameState) || this._cesiumAnimationsDirty;\n    this._cesiumAnimationsDirty = false;\n    this._dirty = false;\n    var modelMatrix = this.modelMatrix;\n\n    var modeChanged = frameState.mode !== this._mode;\n    this._mode = frameState.mode;\n\n    // Model's model matrix needs to be updated\n    var modelTransformChanged =\n      !Matrix4.equals(this._modelMatrix, modelMatrix) ||\n      this._scale !== this.scale ||\n      this._minimumPixelSize !== this.minimumPixelSize ||\n      this.minimumPixelSize !== 0.0 || // Minimum pixel size changed or is enabled\n      this._maximumScale !== this.maximumScale ||\n      this._heightReference !== this.heightReference ||\n      this._heightChanged ||\n      modeChanged;\n\n    if (modelTransformChanged || justLoaded) {\n      Matrix4.clone(modelMatrix, this._modelMatrix);\n\n      updateClamping(this);\n\n      if (defined(this._clampedModelMatrix)) {\n        modelMatrix = this._clampedModelMatrix;\n      }\n\n      this._scale = this.scale;\n      this._minimumPixelSize = this.minimumPixelSize;\n      this._maximumScale = this.maximumScale;\n      this._heightReference = this.heightReference;\n      this._heightChanged = false;\n\n      var scale = getScale(this, frameState);\n      var computedModelMatrix = this._computedModelMatrix;\n      Matrix4.multiplyByUniformScale(modelMatrix, scale, computedModelMatrix);\n      if (this._upAxis === Axis.Y) {\n        Matrix4.multiplyTransformation(\n          computedModelMatrix,\n          Axis.Y_UP_TO_Z_UP,\n          computedModelMatrix\n        );\n      } else if (this._upAxis === Axis.X) {\n        Matrix4.multiplyTransformation(\n          computedModelMatrix,\n          Axis.X_UP_TO_Z_UP,\n          computedModelMatrix\n        );\n      }\n      if (this.forwardAxis === Axis.Z) {\n        // glTF 2.0 has a Z-forward convention that must be adapted here to X-forward.\n        Matrix4.multiplyTransformation(\n          computedModelMatrix,\n          Axis.Z_UP_TO_X_UP,\n          computedModelMatrix\n        );\n      }\n    }\n\n    // Update modelMatrix throughout the graph as needed\n    if (animated || modelTransformChanged || justLoaded) {\n      updateNodeHierarchyModelMatrix(\n        this,\n        modelTransformChanged,\n        justLoaded,\n        frameState.mapProjection\n      );\n      this._dirty = true;\n\n      if (animated || justLoaded) {\n        // Apply skins if animation changed any node transforms\n        applySkins(this);\n      }\n    }\n\n    if (this._perNodeShowDirty) {\n      this._perNodeShowDirty = false;\n      updatePerNodeShow(this);\n    }\n    updatePickIds(this, context);\n    updateWireframe(this);\n    updateShowBoundingVolume(this);\n    updateShadows(this);\n    updateClippingPlanes(this, frameState);\n\n    // Regenerate shaders if ClippingPlaneCollection state changed or it was removed\n    var clippingPlanes = this._clippingPlanes;\n    var currentClippingPlanesState = 0;\n    var useClippingPlanes =\n      defined(clippingPlanes) &&\n      clippingPlanes.enabled &&\n      clippingPlanes.length > 0;\n    var usesSH =\n      defined(this._sphericalHarmonicCoefficients) ||\n      this._useDefaultSphericalHarmonics;\n    var usesSM =\n      (defined(this._specularEnvironmentMapAtlas) &&\n        this._specularEnvironmentMapAtlas.ready) ||\n      this._useDefaultSpecularMaps;\n    if (useClippingPlanes || usesSH || usesSM) {\n      var clippingPlanesOriginMatrix = defaultValue(\n        this.clippingPlanesOriginMatrix,\n        modelMatrix\n      );\n      Matrix4.multiply(\n        context.uniformState.view3D,\n        clippingPlanesOriginMatrix,\n        this._clippingPlaneModelViewMatrix\n      );\n    }\n\n    if (useClippingPlanes) {\n      currentClippingPlanesState = clippingPlanes.clippingPlanesState;\n    }\n\n    var shouldRegenerateShaders = this._shouldRegenerateShaders;\n    shouldRegenerateShaders =\n      shouldRegenerateShaders ||\n      this._clippingPlanesState !== currentClippingPlanesState;\n    this._clippingPlanesState = currentClippingPlanesState;\n\n    // Regenerate shaders if color shading changed from last update\n    var currentlyColorShadingEnabled = isColorShadingEnabled(this);\n    if (currentlyColorShadingEnabled !== this._colorShadingEnabled) {\n      this._colorShadingEnabled = currentlyColorShadingEnabled;\n      shouldRegenerateShaders = true;\n    }\n\n    if (shouldRegenerateShaders) {\n      regenerateShaders(this, frameState);\n    } else {\n      updateColor(this, frameState, false);\n      updateSilhouette(this, frameState, false);\n    }\n  }\n\n  if (justLoaded) {\n    // Called after modelMatrix update.\n    var model = this;\n    frameState.afterRender.push(function () {\n      model._ready = true;\n      model._readyPromise.resolve(model);\n    });\n    return;\n  }\n\n  // We don't check show at the top of the function since we\n  // want to be able to progressively load models when they are not shown,\n  // and then have them visible immediately when show is set to true.\n  if (show && !this._ignoreCommands) {\n    // PERFORMANCE_IDEA: This is terrible\n    var commandList = frameState.commandList;\n    var passes = frameState.passes;\n    var nodeCommands = this._nodeCommands;\n    var length = nodeCommands.length;\n    var i;\n    var nc;\n\n    var idl2D =\n      frameState.mapProjection.ellipsoid.maximumRadius * CesiumMath.PI;\n    var boundingVolume;\n\n    if (passes.render || (passes.pick && this.allowPicking)) {\n      for (i = 0; i < length; ++i) {\n        nc = nodeCommands[i];\n        if (nc.show) {\n          var command = translucent ? nc.translucentCommand : nc.command;\n          command = silhouette ? nc.silhouetteModelCommand : command;\n          commandList.push(command);\n          boundingVolume = nc.command.boundingVolume;\n          if (\n            frameState.mode === SceneMode.SCENE2D &&\n            (boundingVolume.center.y + boundingVolume.radius > idl2D ||\n              boundingVolume.center.y - boundingVolume.radius < idl2D)\n          ) {\n            var command2D = translucent\n              ? nc.translucentCommand2D\n              : nc.command2D;\n            command2D = silhouette ? nc.silhouetteModelCommand2D : command2D;\n            commandList.push(command2D);\n          }\n        }\n      }\n\n      if (silhouette && !passes.pick) {\n        // Render second silhouette pass\n        for (i = 0; i < length; ++i) {\n          nc = nodeCommands[i];\n          if (nc.show) {\n            commandList.push(nc.silhouetteColorCommand);\n            boundingVolume = nc.command.boundingVolume;\n            if (\n              frameState.mode === SceneMode.SCENE2D &&\n              (boundingVolume.center.y + boundingVolume.radius > idl2D ||\n                boundingVolume.center.y - boundingVolume.radius < idl2D)\n            ) {\n              commandList.push(nc.silhouetteColorCommand2D);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  var credit = this._credit;\n  if (defined(credit)) {\n    frameState.creditDisplay.addCredit(credit);\n  }\n\n  var resourceCredits = this._resourceCredits;\n  var creditCount = resourceCredits.length;\n  for (var c = 0; c < creditCount; c++) {\n    frameState.creditDisplay.addCredit(resourceCredits[c]);\n  }\n};\n\nfunction destroyIfNotCached(rendererResources, cachedRendererResources) {\n  if (rendererResources.programs !== cachedRendererResources.programs) {\n    destroy(rendererResources.programs);\n  }\n  if (\n    rendererResources.silhouettePrograms !==\n    cachedRendererResources.silhouettePrograms\n  ) {\n    destroy(rendererResources.silhouettePrograms);\n  }\n}\n\n// Run from update iff:\n// - everything is loaded\n// - clipping planes state change OR color state set\n// Run this from destructor after removing color state and clipping plane state\nfunction regenerateShaders(model, frameState) {\n  // In regards to _cachedRendererResources:\n  // Fair to assume that this is data that should just never get modified due to clipping planes or model color.\n  // So if clipping planes or model color active:\n  // - delink _rendererResources.*programs and create new dictionaries.\n  // - do NOT destroy any programs - might be used by copies of the model or by might be needed in the future if clipping planes/model color is deactivated\n\n  // If clipping planes and model color inactive:\n  // - destroy _rendererResources.*programs\n  // - relink _rendererResources.*programs to _cachedRendererResources\n\n  // In both cases, need to mark commands as dirty, re-run derived commands (elsewhere)\n\n  var rendererResources = model._rendererResources;\n  var cachedRendererResources = model._cachedRendererResources;\n  destroyIfNotCached(rendererResources, cachedRendererResources);\n\n  var programId;\n  if (\n    isClippingEnabled(model) ||\n    isColorShadingEnabled(model) ||\n    model._shouldRegenerateShaders\n  ) {\n    model._shouldRegenerateShaders = false;\n\n    rendererResources.programs = {};\n    rendererResources.silhouettePrograms = {};\n\n    var visitedPrograms = {};\n    var techniques = model._sourceTechniques;\n    var technique;\n\n    for (var techniqueId in techniques) {\n      if (techniques.hasOwnProperty(techniqueId)) {\n        technique = techniques[techniqueId];\n        programId = technique.program;\n        if (!visitedPrograms[programId]) {\n          visitedPrograms[programId] = true;\n          recreateProgram(\n            {\n              programId: programId,\n              techniqueId: techniqueId,\n            },\n            model,\n            frameState.context\n          );\n        }\n      }\n    }\n  } else {\n    rendererResources.programs = cachedRendererResources.programs;\n    rendererResources.silhouettePrograms =\n      cachedRendererResources.silhouettePrograms;\n  }\n\n  // Fix all the commands, marking them as dirty so everything that derives will re-derive\n  var rendererPrograms = rendererResources.programs;\n\n  var nodeCommands = model._nodeCommands;\n  var commandCount = nodeCommands.length;\n  for (var i = 0; i < commandCount; ++i) {\n    var nodeCommand = nodeCommands[i];\n    programId = nodeCommand.programId;\n\n    var renderProgram = rendererPrograms[programId];\n    nodeCommand.command.shaderProgram = renderProgram;\n    if (defined(nodeCommand.command2D)) {\n      nodeCommand.command2D.shaderProgram = renderProgram;\n    }\n  }\n\n  // Force update silhouette commands/shaders\n  updateColor(model, frameState, true);\n  updateSilhouette(model, frameState, true);\n}\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see Model#destroy\n */\nModel.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * model = model && model.destroy();\n *\n * @see Model#isDestroyed\n */\nModel.prototype.destroy = function () {\n  // Vertex arrays are unique to this model, destroy here.\n  if (defined(this._precreatedAttributes)) {\n    destroy(this._rendererResources.vertexArrays);\n  }\n\n  if (defined(this._removeUpdateHeightCallback)) {\n    this._removeUpdateHeightCallback();\n    this._removeUpdateHeightCallback = undefined;\n  }\n\n  if (defined(this._terrainProviderChangedCallback)) {\n    this._terrainProviderChangedCallback();\n    this._terrainProviderChangedCallback = undefined;\n  }\n\n  // Shaders modified for clipping and for color don't get cached, so destroy these manually\n  if (defined(this._cachedRendererResources)) {\n    destroyIfNotCached(this._rendererResources, this._cachedRendererResources);\n  }\n\n  this._rendererResources = undefined;\n  this._cachedRendererResources =\n    this._cachedRendererResources && this._cachedRendererResources.release();\n  DracoLoader.destroyCachedDataForModel(this);\n\n  var pickIds = this._pickIds;\n  var length = pickIds.length;\n  for (var i = 0; i < length; ++i) {\n    pickIds[i].destroy();\n  }\n\n  releaseCachedGltf(this);\n  this._quantizedVertexShaders = undefined;\n\n  // Only destroy the ClippingPlaneCollection if this is the owner - if this model is part of a Cesium3DTileset,\n  // _clippingPlanes references a ClippingPlaneCollection that this model does not own.\n  var clippingPlaneCollection = this._clippingPlanes;\n  if (\n    defined(clippingPlaneCollection) &&\n    !clippingPlaneCollection.isDestroyed() &&\n    clippingPlaneCollection.owner === this\n  ) {\n    clippingPlaneCollection.destroy();\n  }\n  this._clippingPlanes = undefined;\n\n  this._specularEnvironmentMapAtlas =\n    this._specularEnvironmentMapAtlas &&\n    this._specularEnvironmentMapAtlas.destroy();\n\n  return destroyObject(this);\n};\n\n// exposed for testing\nModel._getClippingFunction = getClippingFunction;\nModel._modifyShaderForColor = modifyShaderForColor;\nexport default Model;\n"]},"metadata":{},"sourceType":"module"}