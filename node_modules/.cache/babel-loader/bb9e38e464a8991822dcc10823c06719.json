{"ast":null,"code":"import defined from \"../Core/defined.js\";\n/**\n * A priority queue of tiles to be replaced, if necessary, to make room for new tiles.  The queue\n * is implemented as a linked list.\n *\n * @alias TileReplacementQueue\n * @private\n */\n\nfunction TileReplacementQueue() {\n  this.head = undefined;\n  this.tail = undefined;\n  this.count = 0;\n  this._lastBeforeStartOfFrame = undefined;\n}\n/**\n * Marks the start of the render frame.  Tiles before (closer to the head) this tile in the\n * list were used last frame and must not be unloaded.\n */\n\n\nTileReplacementQueue.prototype.markStartOfRenderFrame = function () {\n  this._lastBeforeStartOfFrame = this.head;\n};\n/**\n * Reduces the size of the queue to a specified size by unloading the least-recently used\n * tiles.  Tiles that were used last frame will not be unloaded, even if that puts the number\n * of tiles above the specified maximum.\n *\n * @param {Number} maximumTiles The maximum number of tiles in the queue.\n */\n\n\nTileReplacementQueue.prototype.trimTiles = function (maximumTiles) {\n  var tileToTrim = this.tail;\n  var keepTrimming = true;\n\n  while (keepTrimming && defined(this._lastBeforeStartOfFrame) && this.count > maximumTiles && defined(tileToTrim)) {\n    // Stop trimming after we process the last tile not used in the\n    // current frame.\n    keepTrimming = tileToTrim !== this._lastBeforeStartOfFrame;\n    var previous = tileToTrim.replacementPrevious;\n\n    if (tileToTrim.eligibleForUnloading) {\n      tileToTrim.freeResources();\n      remove(this, tileToTrim);\n    }\n\n    tileToTrim = previous;\n  }\n};\n\nfunction remove(tileReplacementQueue, item) {\n  var previous = item.replacementPrevious;\n  var next = item.replacementNext;\n\n  if (item === tileReplacementQueue._lastBeforeStartOfFrame) {\n    tileReplacementQueue._lastBeforeStartOfFrame = next;\n  }\n\n  if (item === tileReplacementQueue.head) {\n    tileReplacementQueue.head = next;\n  } else {\n    previous.replacementNext = next;\n  }\n\n  if (item === tileReplacementQueue.tail) {\n    tileReplacementQueue.tail = previous;\n  } else {\n    next.replacementPrevious = previous;\n  }\n\n  item.replacementPrevious = undefined;\n  item.replacementNext = undefined;\n  --tileReplacementQueue.count;\n}\n/**\n * Marks a tile as rendered this frame and moves it before the first tile that was not rendered\n * this frame.\n *\n * @param {TileReplacementQueue} item The tile that was rendered.\n */\n\n\nTileReplacementQueue.prototype.markTileRendered = function (item) {\n  var head = this.head;\n\n  if (head === item) {\n    if (item === this._lastBeforeStartOfFrame) {\n      this._lastBeforeStartOfFrame = item.replacementNext;\n    }\n\n    return;\n  }\n\n  ++this.count;\n\n  if (!defined(head)) {\n    // no other tiles in the list\n    item.replacementPrevious = undefined;\n    item.replacementNext = undefined;\n    this.head = item;\n    this.tail = item;\n    return;\n  }\n\n  if (defined(item.replacementPrevious) || defined(item.replacementNext)) {\n    // tile already in the list, remove from its current location\n    remove(this, item);\n  }\n\n  item.replacementPrevious = undefined;\n  item.replacementNext = head;\n  head.replacementPrevious = item;\n  this.head = item;\n};\n\nexport default TileReplacementQueue;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/TileReplacementQueue.js"],"names":["defined","TileReplacementQueue","head","undefined","tail","count","_lastBeforeStartOfFrame","prototype","markStartOfRenderFrame","trimTiles","maximumTiles","tileToTrim","keepTrimming","previous","replacementPrevious","eligibleForUnloading","freeResources","remove","tileReplacementQueue","item","next","replacementNext","markTileRendered"],"mappings":"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","sourcesContent":["import defined from \"../Core/defined.js\";\n\n/**\n * A priority queue of tiles to be replaced, if necessary, to make room for new tiles.  The queue\n * is implemented as a linked list.\n *\n * @alias TileReplacementQueue\n * @private\n */\nfunction TileReplacementQueue() {\n  this.head = undefined;\n  this.tail = undefined;\n  this.count = 0;\n  this._lastBeforeStartOfFrame = undefined;\n}\n\n/**\n * Marks the start of the render frame.  Tiles before (closer to the head) this tile in the\n * list were used last frame and must not be unloaded.\n */\nTileReplacementQueue.prototype.markStartOfRenderFrame = function () {\n  this._lastBeforeStartOfFrame = this.head;\n};\n\n/**\n * Reduces the size of the queue to a specified size by unloading the least-recently used\n * tiles.  Tiles that were used last frame will not be unloaded, even if that puts the number\n * of tiles above the specified maximum.\n *\n * @param {Number} maximumTiles The maximum number of tiles in the queue.\n */\nTileReplacementQueue.prototype.trimTiles = function (maximumTiles) {\n  var tileToTrim = this.tail;\n  var keepTrimming = true;\n  while (\n    keepTrimming &&\n    defined(this._lastBeforeStartOfFrame) &&\n    this.count > maximumTiles &&\n    defined(tileToTrim)\n  ) {\n    // Stop trimming after we process the last tile not used in the\n    // current frame.\n    keepTrimming = tileToTrim !== this._lastBeforeStartOfFrame;\n\n    var previous = tileToTrim.replacementPrevious;\n\n    if (tileToTrim.eligibleForUnloading) {\n      tileToTrim.freeResources();\n      remove(this, tileToTrim);\n    }\n\n    tileToTrim = previous;\n  }\n};\n\nfunction remove(tileReplacementQueue, item) {\n  var previous = item.replacementPrevious;\n  var next = item.replacementNext;\n\n  if (item === tileReplacementQueue._lastBeforeStartOfFrame) {\n    tileReplacementQueue._lastBeforeStartOfFrame = next;\n  }\n\n  if (item === tileReplacementQueue.head) {\n    tileReplacementQueue.head = next;\n  } else {\n    previous.replacementNext = next;\n  }\n\n  if (item === tileReplacementQueue.tail) {\n    tileReplacementQueue.tail = previous;\n  } else {\n    next.replacementPrevious = previous;\n  }\n\n  item.replacementPrevious = undefined;\n  item.replacementNext = undefined;\n\n  --tileReplacementQueue.count;\n}\n\n/**\n * Marks a tile as rendered this frame and moves it before the first tile that was not rendered\n * this frame.\n *\n * @param {TileReplacementQueue} item The tile that was rendered.\n */\nTileReplacementQueue.prototype.markTileRendered = function (item) {\n  var head = this.head;\n  if (head === item) {\n    if (item === this._lastBeforeStartOfFrame) {\n      this._lastBeforeStartOfFrame = item.replacementNext;\n    }\n    return;\n  }\n\n  ++this.count;\n\n  if (!defined(head)) {\n    // no other tiles in the list\n    item.replacementPrevious = undefined;\n    item.replacementNext = undefined;\n    this.head = item;\n    this.tail = item;\n    return;\n  }\n\n  if (defined(item.replacementPrevious) || defined(item.replacementNext)) {\n    // tile already in the list, remove from its current location\n    remove(this, item);\n  }\n\n  item.replacementPrevious = undefined;\n  item.replacementNext = head;\n  head.replacementPrevious = item;\n\n  this.head = item;\n};\nexport default TileReplacementQueue;\n"]},"metadata":{},"sourceType":"module"}