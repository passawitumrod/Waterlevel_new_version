{"ast":null,"code":"import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n/**\n * Creates a curve parameterized and evaluated by time. This type describes an interface\n * and is not intended to be instantiated directly.\n *\n * @alias Spline\n * @constructor\n *\n * @see CatmullRomSpline\n * @see HermiteSpline\n * @see LinearSpline\n * @see QuaternionSpline\n */\n\nfunction Spline() {\n  /**\n   * An array of times for the control points.\n   * @type {Number[]}\n   * @default undefined\n   */\n  this.times = undefined;\n  /**\n   * An array of control points.\n   * @type {Cartesian3[]|Quaternion[]}\n   * @default undefined\n   */\n\n  this.points = undefined;\n  DeveloperError.throwInstantiationError();\n}\n/**\n * Evaluates the curve at a given time.\n * @function\n *\n * @param {Number} time The time at which to evaluate the curve.\n * @param {Cartesian3|Quaternion|Number[]} [result] The object onto which to store the result.\n * @returns {Cartesian3|Quaternion|Number[]} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\n\n\nSpline.prototype.evaluate = DeveloperError.throwInstantiationError;\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n *\n * @param {Number} time The time.\n * @param {Number} startIndex The index from which to start the search.\n * @returns {Number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\n\nSpline.prototype.findTimeInterval = function (time, startIndex) {\n  var times = this.times;\n  var length = times.length; //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(time)) {\n    throw new DeveloperError(\"time is required.\");\n  }\n\n  if (time < times[0] || time > times[length - 1]) {\n    throw new DeveloperError(\"time is out of range.\");\n  } //>>includeEnd('debug');\n  // Take advantage of temporal coherence by checking current, next and previous intervals\n  // for containment of time.\n\n\n  startIndex = defaultValue(startIndex, 0);\n\n  if (time >= times[startIndex]) {\n    if (startIndex + 1 < length && time < times[startIndex + 1]) {\n      return startIndex;\n    } else if (startIndex + 2 < length && time < times[startIndex + 2]) {\n      return startIndex + 1;\n    }\n  } else if (startIndex - 1 >= 0 && time >= times[startIndex - 1]) {\n    return startIndex - 1;\n  } // The above failed so do a linear search. For the use cases so far, the\n  // length of the list is less than 10. In the future, if there is a bottle neck,\n  // it might be here.\n\n\n  var i;\n\n  if (time > times[startIndex]) {\n    for (i = startIndex; i < length - 1; ++i) {\n      if (time >= times[i] && time < times[i + 1]) {\n        break;\n      }\n    }\n  } else {\n    for (i = startIndex - 1; i >= 0; --i) {\n      if (time >= times[i] && time < times[i + 1]) {\n        break;\n      }\n    }\n  }\n\n  if (i === length - 1) {\n    i = length - 2;\n  }\n\n  return i;\n};\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, wrapped around the animation period.\n */\n\n\nSpline.prototype.wrapTime = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"time\", time); //>>includeEnd('debug');\n\n  var times = this.times;\n  var timeEnd = times[times.length - 1];\n  var timeStart = times[0];\n  var timeStretch = timeEnd - timeStart;\n  var divs;\n\n  if (time < timeStart) {\n    divs = Math.floor((timeStart - time) / timeStretch) + 1;\n    time += divs * timeStretch;\n  }\n\n  if (time > timeEnd) {\n    divs = Math.floor((time - timeEnd) / timeStretch) + 1;\n    time -= divs * timeStretch;\n  }\n\n  return time;\n};\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, clamped to the animation period.\n */\n\n\nSpline.prototype.clampTime = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"time\", time); //>>includeEnd('debug');\n\n  var times = this.times;\n  return CesiumMath.clamp(time, times[0], times[times.length - 1]);\n};\n\nexport default Spline;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/Spline.js"],"names":["Check","defaultValue","defined","DeveloperError","CesiumMath","Spline","times","undefined","points","throwInstantiationError","prototype","evaluate","findTimeInterval","time","startIndex","length","i","wrapTime","typeOf","number","timeEnd","timeStart","timeStretch","divs","Math","floor","clampTime","clamp"],"mappings":"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","sourcesContent":["import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * Creates a curve parameterized and evaluated by time. This type describes an interface\n * and is not intended to be instantiated directly.\n *\n * @alias Spline\n * @constructor\n *\n * @see CatmullRomSpline\n * @see HermiteSpline\n * @see LinearSpline\n * @see QuaternionSpline\n */\nfunction Spline() {\n  /**\n   * An array of times for the control points.\n   * @type {Number[]}\n   * @default undefined\n   */\n  this.times = undefined;\n\n  /**\n   * An array of control points.\n   * @type {Cartesian3[]|Quaternion[]}\n   * @default undefined\n   */\n  this.points = undefined;\n\n  DeveloperError.throwInstantiationError();\n}\n\n/**\n * Evaluates the curve at a given time.\n * @function\n *\n * @param {Number} time The time at which to evaluate the curve.\n * @param {Cartesian3|Quaternion|Number[]} [result] The object onto which to store the result.\n * @returns {Cartesian3|Quaternion|Number[]} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nSpline.prototype.evaluate = DeveloperError.throwInstantiationError;\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n *\n * @param {Number} time The time.\n * @param {Number} startIndex The index from which to start the search.\n * @returns {Number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nSpline.prototype.findTimeInterval = function (time, startIndex) {\n  var times = this.times;\n  var length = times.length;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(time)) {\n    throw new DeveloperError(\"time is required.\");\n  }\n  if (time < times[0] || time > times[length - 1]) {\n    throw new DeveloperError(\"time is out of range.\");\n  }\n  //>>includeEnd('debug');\n\n  // Take advantage of temporal coherence by checking current, next and previous intervals\n  // for containment of time.\n  startIndex = defaultValue(startIndex, 0);\n\n  if (time >= times[startIndex]) {\n    if (startIndex + 1 < length && time < times[startIndex + 1]) {\n      return startIndex;\n    } else if (startIndex + 2 < length && time < times[startIndex + 2]) {\n      return startIndex + 1;\n    }\n  } else if (startIndex - 1 >= 0 && time >= times[startIndex - 1]) {\n    return startIndex - 1;\n  }\n\n  // The above failed so do a linear search. For the use cases so far, the\n  // length of the list is less than 10. In the future, if there is a bottle neck,\n  // it might be here.\n\n  var i;\n  if (time > times[startIndex]) {\n    for (i = startIndex; i < length - 1; ++i) {\n      if (time >= times[i] && time < times[i + 1]) {\n        break;\n      }\n    }\n  } else {\n    for (i = startIndex - 1; i >= 0; --i) {\n      if (time >= times[i] && time < times[i + 1]) {\n        break;\n      }\n    }\n  }\n\n  if (i === length - 1) {\n    i = length - 2;\n  }\n\n  return i;\n};\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, wrapped around the animation period.\n */\nSpline.prototype.wrapTime = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"time\", time);\n  //>>includeEnd('debug');\n\n  var times = this.times;\n  var timeEnd = times[times.length - 1];\n  var timeStart = times[0];\n  var timeStretch = timeEnd - timeStart;\n  var divs;\n  if (time < timeStart) {\n    divs = Math.floor((timeStart - time) / timeStretch) + 1;\n    time += divs * timeStretch;\n  }\n  if (time > timeEnd) {\n    divs = Math.floor((time - timeEnd) / timeStretch) + 1;\n    time -= divs * timeStretch;\n  }\n  return time;\n};\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, clamped to the animation period.\n */\nSpline.prototype.clampTime = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"time\", time);\n  //>>includeEnd('debug');\n\n  var times = this.times;\n  return CesiumMath.clamp(time, times[0], times[times.length - 1]);\n};\nexport default Spline;\n"]},"metadata":{},"sourceType":"module"}