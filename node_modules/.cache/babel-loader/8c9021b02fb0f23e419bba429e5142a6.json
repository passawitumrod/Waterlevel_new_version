{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport BoxOutlineGeometry from \"../Core/BoxOutlineGeometry.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport SphereOutlineGeometry from \"../Core/SphereOutlineGeometry.js\";\nimport TerrainQuantization from \"../Core/TerrainQuantization.js\";\nimport Visibility from \"../Core/Visibility.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport GlobeSurfaceTile from \"./GlobeSurfaceTile.js\";\nimport ImageryLayer from \"./ImageryLayer.js\";\nimport ImageryState from \"./ImageryState.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport QuadtreeTileLoadState from \"./QuadtreeTileLoadState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\nimport TerrainFillMesh from \"./TerrainFillMesh.js\";\nimport TerrainState from \"./TerrainState.js\";\nimport TileBoundingRegion from \"./TileBoundingRegion.js\";\nimport TileSelectionResult from \"./TileSelectionResult.js\";\n/**\n * Provides quadtree tiles representing the surface of the globe.  This type is intended to be used\n * with {@link QuadtreePrimitive}.\n *\n * @alias GlobeSurfaceTileProvider\n * @constructor\n *\n * @param {TerrainProvider} options.terrainProvider The terrain provider that describes the surface geometry.\n * @param {ImageryLayerCollection} option.imageryLayers The collection of imagery layers describing the shading of the surface.\n * @param {GlobeSurfaceShaderSet} options.surfaceShaderSet The set of shaders used to render the surface.\n *\n * @private\n */\n\nfunction GlobeSurfaceTileProvider(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options)) {\n    throw new DeveloperError(\"options is required.\");\n  }\n\n  if (!defined(options.terrainProvider)) {\n    throw new DeveloperError(\"options.terrainProvider is required.\");\n  } else if (!defined(options.imageryLayers)) {\n    throw new DeveloperError(\"options.imageryLayers is required.\");\n  } else if (!defined(options.surfaceShaderSet)) {\n    throw new DeveloperError(\"options.surfaceShaderSet is required.\");\n  } //>>includeEnd('debug');\n\n\n  this.lightingFadeOutDistance = 6500000.0;\n  this.lightingFadeInDistance = 9000000.0;\n  this.hasWaterMask = false;\n  this.oceanNormalMap = undefined;\n  this.zoomedOutOceanSpecularIntensity = 0.5;\n  this.enableLighting = false;\n  this.dynamicAtmosphereLighting = false;\n  this.dynamicAtmosphereLightingFromSun = false;\n  this.showGroundAtmosphere = false;\n  this.shadows = ShadowMode.RECEIVE_ONLY;\n  /**\n   * The color to use to highlight terrain fill tiles. If undefined, fill tiles are not\n   * highlighted at all. The alpha value is used to alpha blend with the tile's\n   * actual color. Because terrain fill tiles do not represent the actual terrain surface,\n   * it may be useful in some applications to indicate visually that they are not to be trusted.\n   * @type {Color}\n   * @default undefined\n   */\n\n  this.fillHighlightColor = undefined;\n  this.hueShift = 0.0;\n  this.saturationShift = 0.0;\n  this.brightnessShift = 0.0;\n  this.showSkirts = true;\n  this.backFaceCulling = true;\n  this._quadtree = undefined;\n  this._terrainProvider = options.terrainProvider;\n  this._imageryLayers = options.imageryLayers;\n  this._surfaceShaderSet = options.surfaceShaderSet;\n  this._renderState = undefined;\n  this._blendRenderState = undefined;\n  this._disableCullingRenderState = undefined;\n  this._disableCullingBlendRenderState = undefined;\n  this._errorEvent = new Event();\n\n  this._imageryLayers.layerAdded.addEventListener(GlobeSurfaceTileProvider.prototype._onLayerAdded, this);\n\n  this._imageryLayers.layerRemoved.addEventListener(GlobeSurfaceTileProvider.prototype._onLayerRemoved, this);\n\n  this._imageryLayers.layerMoved.addEventListener(GlobeSurfaceTileProvider.prototype._onLayerMoved, this);\n\n  this._imageryLayers.layerShownOrHidden.addEventListener(GlobeSurfaceTileProvider.prototype._onLayerShownOrHidden, this);\n\n  this._imageryLayersUpdatedEvent = new Event();\n  this._layerOrderChanged = false;\n  this._tilesToRenderByTextureCount = [];\n  this._drawCommands = [];\n  this._uniformMaps = [];\n  this._usedDrawCommands = 0;\n  this._vertexArraysToDestroy = [];\n  this._debug = {\n    wireframe: false,\n    boundingSphereTile: undefined\n  };\n  this._baseColor = undefined;\n  this._firstPassInitialColor = undefined;\n  this.baseColor = new Color(0.0, 0.0, 0.5, 1.0);\n  /**\n   * A property specifying a {@link ClippingPlaneCollection} used to selectively disable rendering on the outside of each plane.\n   * @type {ClippingPlaneCollection}\n   * @private\n   */\n\n  this._clippingPlanes = undefined;\n  /**\n   * A property specifying a {@link Rectangle} used to selectively limit terrain and imagery rendering.\n   * @type {Rectangle}\n   */\n\n  this.cartographicLimitRectangle = Rectangle.clone(Rectangle.MAX_VALUE);\n  this._hasLoadedTilesThisFrame = false;\n  this._hasFillTilesThisFrame = false;\n}\n\nObject.defineProperties(GlobeSurfaceTileProvider.prototype, {\n  /**\n   * Gets or sets the color of the globe when no imagery is available.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Color}\n   */\n  baseColor: {\n    get: function get() {\n      return this._baseColor;\n    },\n    set: function set(value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      } //>>includeEnd('debug');\n\n\n      this._baseColor = value;\n      this._firstPassInitialColor = Cartesian4.fromColor(value, this._firstPassInitialColor);\n    }\n  },\n\n  /**\n   * Gets or sets the {@link QuadtreePrimitive} for which this provider is\n   * providing tiles.  This property may be undefined if the provider is not yet associated\n   * with a {@link QuadtreePrimitive}.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {QuadtreePrimitive}\n   */\n  quadtree: {\n    get: function get() {\n      return this._quadtree;\n    },\n    set: function set(value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      } //>>includeEnd('debug');\n\n\n      this._quadtree = value;\n    }\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Boolean}\n   */\n  ready: {\n    get: function get() {\n      return this._terrainProvider.ready && (this._imageryLayers.length === 0 || this._imageryLayers.get(0).imageryProvider.ready);\n    }\n  },\n\n  /**\n   * Gets the tiling scheme used by the provider.  This property should\n   * not be accessed before {@link GlobeSurfaceTileProvider#ready} returns true.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {TilingScheme}\n   */\n  tilingScheme: {\n    get: function get() {\n      return this._terrainProvider.tilingScheme;\n    }\n  },\n\n  /**\n   * Gets an event that is raised when the geometry provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function get() {\n      return this._errorEvent;\n    }\n  },\n\n  /**\n   * Gets an event that is raised when an imagery layer is added, shown, hidden, moved, or removed.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Event}\n   */\n  imageryLayersUpdatedEvent: {\n    get: function get() {\n      return this._imageryLayersUpdatedEvent;\n    }\n  },\n\n  /**\n   * Gets or sets the terrain provider that describes the surface geometry.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {TerrainProvider}\n   */\n  terrainProvider: {\n    get: function get() {\n      return this._terrainProvider;\n    },\n    set: function set(terrainProvider) {\n      if (this._terrainProvider === terrainProvider) {\n        return;\n      } //>>includeStart('debug', pragmas.debug);\n\n\n      if (!defined(terrainProvider)) {\n        throw new DeveloperError(\"terrainProvider is required.\");\n      } //>>includeEnd('debug');\n\n\n      this._terrainProvider = terrainProvider;\n\n      if (defined(this._quadtree)) {\n        this._quadtree.invalidateAllTiles();\n      }\n    }\n  },\n\n  /**\n   * The {@link ClippingPlaneCollection} used to selectively disable rendering the tileset.\n   *\n   * @type {ClippingPlaneCollection}\n   *\n   * @private\n   */\n  clippingPlanes: {\n    get: function get() {\n      return this._clippingPlanes;\n    },\n    set: function set(value) {\n      ClippingPlaneCollection.setOwner(value, this, \"_clippingPlanes\");\n    }\n  }\n});\n\nfunction sortTileImageryByLayerIndex(a, b) {\n  var aImagery = a.loadingImagery;\n\n  if (!defined(aImagery)) {\n    aImagery = a.readyImagery;\n  }\n\n  var bImagery = b.loadingImagery;\n\n  if (!defined(bImagery)) {\n    bImagery = b.readyImagery;\n  }\n\n  return aImagery.imageryLayer._layerIndex - bImagery.imageryLayer._layerIndex;\n}\n/**\n * Make updates to the tile provider that are not involved in rendering. Called before the render update cycle.\n */\n\n\nGlobeSurfaceTileProvider.prototype.update = function (frameState) {\n  // update collection: imagery indices, base layers, raise layer show/hide event\n  this._imageryLayers._update();\n};\n\nfunction updateCredits(surface, frameState) {\n  var creditDisplay = frameState.creditDisplay;\n\n  if (surface._terrainProvider.ready && defined(surface._terrainProvider.credit)) {\n    creditDisplay.addCredit(surface._terrainProvider.credit);\n  }\n\n  var imageryLayers = surface._imageryLayers;\n\n  for (var i = 0, len = imageryLayers.length; i < len; ++i) {\n    var imageryProvider = imageryLayers.get(i).imageryProvider;\n\n    if (imageryProvider.ready && defined(imageryProvider.credit)) {\n      creditDisplay.addCredit(imageryProvider.credit);\n    }\n  }\n}\n/**\n * Called at the beginning of each render frame, before {@link QuadtreeTileProvider#showTileThisFrame}\n * @param {FrameState} frameState The frame state.\n */\n\n\nGlobeSurfaceTileProvider.prototype.initialize = function (frameState) {\n  // update each layer for texture reprojection.\n  this._imageryLayers.queueReprojectionCommands(frameState);\n\n  if (this._layerOrderChanged) {\n    this._layerOrderChanged = false; // Sort the TileImagery instances in each tile by the layer index.\n\n    this._quadtree.forEachLoadedTile(function (tile) {\n      tile.data.imagery.sort(sortTileImageryByLayerIndex);\n    });\n  } // Add credits for terrain and imagery providers.\n\n\n  updateCredits(this, frameState);\n  var vertexArraysToDestroy = this._vertexArraysToDestroy;\n  var length = vertexArraysToDestroy.length;\n\n  for (var j = 0; j < length; ++j) {\n    GlobeSurfaceTile._freeVertexArray(vertexArraysToDestroy[j]);\n  }\n\n  vertexArraysToDestroy.length = 0;\n};\n/**\n * Called at the beginning of the update cycle for each render frame, before {@link QuadtreeTileProvider#showTileThisFrame}\n * or any other functions.\n *\n * @param {FrameState} frameState The frame state.\n */\n\n\nGlobeSurfaceTileProvider.prototype.beginUpdate = function (frameState) {\n  var tilesToRenderByTextureCount = this._tilesToRenderByTextureCount;\n\n  for (var i = 0, len = tilesToRenderByTextureCount.length; i < len; ++i) {\n    var tiles = tilesToRenderByTextureCount[i];\n\n    if (defined(tiles)) {\n      tiles.length = 0;\n    }\n  } // update clipping planes\n\n\n  var clippingPlanes = this._clippingPlanes;\n\n  if (defined(clippingPlanes) && clippingPlanes.enabled) {\n    clippingPlanes.update(frameState);\n  }\n\n  this._usedDrawCommands = 0;\n  this._hasLoadedTilesThisFrame = false;\n  this._hasFillTilesThisFrame = false;\n};\n/**\n * Called at the end of the update cycle for each render frame, after {@link QuadtreeTileProvider#showTileThisFrame}\n * and any other functions.\n *\n * @param {FrameState} frameState The frame state.\n */\n\n\nGlobeSurfaceTileProvider.prototype.endUpdate = function (frameState) {\n  if (!defined(this._renderState)) {\n    this._renderState = RenderState.fromCache({\n      // Write color and depth\n      cull: {\n        enabled: true\n      },\n      depthTest: {\n        enabled: true,\n        func: DepthFunction.LESS\n      }\n    });\n    this._blendRenderState = RenderState.fromCache({\n      // Write color and depth\n      cull: {\n        enabled: true\n      },\n      depthTest: {\n        enabled: true,\n        func: DepthFunction.LESS_OR_EQUAL\n      },\n      blending: BlendingState.ALPHA_BLEND\n    });\n    var rs = clone(this._renderState, true);\n    rs.cull.enabled = false;\n    this._disableCullingRenderState = RenderState.fromCache(rs);\n    rs = clone(this._blendRenderState, true);\n    rs.cull.enabled = false;\n    this._disableCullingBlendRenderState = RenderState.fromCache(rs);\n  } // If this frame has a mix of loaded and fill tiles, we need to propagate\n  // loaded heights to the fill tiles.\n\n\n  if (this._hasFillTilesThisFrame && this._hasLoadedTilesThisFrame) {\n    TerrainFillMesh.updateFillTiles(this, this._quadtree._tilesToRender, frameState, this._vertexArraysToDestroy);\n  } // Add the tile render commands to the command list, sorted by texture count.\n\n\n  var tilesToRenderByTextureCount = this._tilesToRenderByTextureCount;\n\n  for (var textureCountIndex = 0, textureCountLength = tilesToRenderByTextureCount.length; textureCountIndex < textureCountLength; ++textureCountIndex) {\n    var tilesToRender = tilesToRenderByTextureCount[textureCountIndex];\n\n    if (!defined(tilesToRender)) {\n      continue;\n    }\n\n    for (var tileIndex = 0, tileLength = tilesToRender.length; tileIndex < tileLength; ++tileIndex) {\n      var tile = tilesToRender[tileIndex];\n      var tileBoundingRegion = tile.data.tileBoundingRegion;\n      addDrawCommandsForTile(this, tile, frameState);\n      frameState.minimumTerrainHeight = Math.min(frameState.minimumTerrainHeight, tileBoundingRegion.minimumHeight);\n    }\n  }\n};\n/**\n * Adds draw commands for tiles rendered in the previous frame for a pick pass.\n *\n * @param {FrameState} frameState The frame state.\n */\n\n\nGlobeSurfaceTileProvider.prototype.updateForPick = function (frameState) {\n  // Add the tile pick commands from the tiles drawn last frame.\n  var drawCommands = this._drawCommands;\n\n  for (var i = 0, length = this._usedDrawCommands; i < length; ++i) {\n    frameState.commandList.push(drawCommands[i]);\n  }\n};\n/**\n * Cancels any imagery re-projections in the queue.\n */\n\n\nGlobeSurfaceTileProvider.prototype.cancelReprojections = function () {\n  this._imageryLayers.cancelReprojections();\n};\n/**\n * Gets the maximum geometric error allowed in a tile at a given level, in meters.  This function should not be\n * called before {@link GlobeSurfaceTileProvider#ready} returns true.\n *\n * @param {Number} level The tile level for which to get the maximum geometric error.\n * @returns {Number} The maximum geometric error in meters.\n */\n\n\nGlobeSurfaceTileProvider.prototype.getLevelMaximumGeometricError = function (level) {\n  return this._terrainProvider.getLevelMaximumGeometricError(level);\n};\n/**\n * Loads, or continues loading, a given tile.  This function will continue to be called\n * until {@link QuadtreeTile#state} is no longer {@link QuadtreeTileLoadState#LOADING}.  This function should\n * not be called before {@link GlobeSurfaceTileProvider#ready} returns true.\n *\n * @param {FrameState} frameState The frame state.\n * @param {QuadtreeTile} tile The tile to load.\n *\n * @exception {DeveloperError} <code>loadTile</code> must not be called before the tile provider is ready.\n */\n\n\nGlobeSurfaceTileProvider.prototype.loadTile = function (frameState, tile) {\n  // We don't want to load imagery until we're certain that the terrain tiles are actually visible.\n  // So if our bounding volume isn't accurate because it came from another tile, load terrain only\n  // initially. If we load some terrain and suddenly have a more accurate bounding volume and the\n  // tile is _still_ visible, give the tile a chance to load imagery immediately rather than\n  // waiting for next frame.\n  var surfaceTile = tile.data;\n  var terrainOnly = true;\n  var terrainStateBefore;\n\n  if (defined(surfaceTile)) {\n    terrainOnly = surfaceTile.boundingVolumeSourceTile !== tile || tile._lastSelectionResult === TileSelectionResult.CULLED_BUT_NEEDED;\n    terrainStateBefore = surfaceTile.terrainState;\n  }\n\n  GlobeSurfaceTile.processStateMachine(tile, frameState, this.terrainProvider, this._imageryLayers, this._vertexArraysToDestroy, terrainOnly);\n  surfaceTile = tile.data;\n\n  if (terrainOnly && terrainStateBefore !== tile.data.terrainState) {\n    // Terrain state changed. If:\n    // a) The tile is visible, and\n    // b) The bounding volume is accurate (updated as a side effect of computing visibility)\n    // Then we'll load imagery, too.\n    if (this.computeTileVisibility(tile, frameState, this.quadtree.occluders) && surfaceTile.boundingVolumeSourceTile === tile) {\n      terrainOnly = false;\n      GlobeSurfaceTile.processStateMachine(tile, frameState, this.terrainProvider, this._imageryLayers, this._vertexArraysToDestroy, terrainOnly);\n    }\n  }\n};\n\nvar boundingSphereScratch = new BoundingSphere();\nvar rectangleIntersectionScratch = new Rectangle();\nvar splitCartographicLimitRectangleScratch = new Rectangle();\nvar rectangleCenterScratch = new Cartographic(); // cartographicLimitRectangle may span the IDL, but tiles never will.\n\nfunction clipRectangleAntimeridian(tileRectangle, cartographicLimitRectangle) {\n  if (cartographicLimitRectangle.west < cartographicLimitRectangle.east) {\n    return cartographicLimitRectangle;\n  }\n\n  var splitRectangle = Rectangle.clone(cartographicLimitRectangle, splitCartographicLimitRectangleScratch);\n  var tileCenter = Rectangle.center(tileRectangle, rectangleCenterScratch);\n\n  if (tileCenter.longitude > 0.0) {\n    splitRectangle.east = CesiumMath.PI;\n  } else {\n    splitRectangle.west = -CesiumMath.PI;\n  }\n\n  return splitRectangle;\n}\n/**\n * Determines the visibility of a given tile.  The tile may be fully visible, partially visible, or not\n * visible at all.  Tiles that are renderable and are at least partially visible will be shown by a call\n * to {@link GlobeSurfaceTileProvider#showTileThisFrame}.\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {FrameState} frameState The state information about the current frame.\n * @param {QuadtreeOccluders} occluders The objects that may occlude this tile.\n *\n * @returns {Visibility} The visibility of the tile.\n */\n\n\nGlobeSurfaceTileProvider.prototype.computeTileVisibility = function (tile, frameState, occluders) {\n  var distance = this.computeDistanceToTile(tile, frameState);\n  tile._distance = distance;\n\n  if (frameState.fog.enabled && !frameState.cameraUnderground) {\n    if (CesiumMath.fog(distance, frameState.fog.density) >= 1.0) {\n      // Tile is completely in fog so return that it is not visible.\n      return Visibility.NONE;\n    }\n  }\n\n  var surfaceTile = tile.data;\n  var tileBoundingRegion = surfaceTile.tileBoundingRegion;\n\n  if (surfaceTile.boundingVolumeSourceTile === undefined) {\n    // We have no idea where this tile is, so let's just call it partially visible.\n    return Visibility.PARTIAL;\n  }\n\n  var cullingVolume = frameState.cullingVolume;\n  var boundingVolume = surfaceTile.orientedBoundingBox;\n\n  if (!defined(boundingVolume) && defined(surfaceTile.renderedMesh)) {\n    boundingVolume = surfaceTile.renderedMesh.boundingSphere3D;\n  } // Check if the tile is outside the limit area in cartographic space\n\n\n  surfaceTile.clippedByBoundaries = false;\n  var clippedCartographicLimitRectangle = clipRectangleAntimeridian(tile.rectangle, this.cartographicLimitRectangle);\n  var areaLimitIntersection = Rectangle.simpleIntersection(clippedCartographicLimitRectangle, tile.rectangle, rectangleIntersectionScratch);\n\n  if (!defined(areaLimitIntersection)) {\n    return Visibility.NONE;\n  }\n\n  if (!Rectangle.equals(areaLimitIntersection, tile.rectangle)) {\n    surfaceTile.clippedByBoundaries = true;\n  }\n\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    boundingVolume = boundingSphereScratch;\n    BoundingSphere.fromRectangleWithHeights2D(tile.rectangle, frameState.mapProjection, tileBoundingRegion.minimumHeight, tileBoundingRegion.maximumHeight, boundingVolume);\n    Cartesian3.fromElements(boundingVolume.center.z, boundingVolume.center.x, boundingVolume.center.y, boundingVolume.center);\n\n    if (frameState.mode === SceneMode.MORPHING && defined(surfaceTile.renderedMesh)) {\n      boundingVolume = BoundingSphere.union(surfaceTile.renderedMesh.boundingSphere3D, boundingVolume, boundingVolume);\n    }\n  }\n\n  if (!defined(boundingVolume)) {\n    return Intersect.INTERSECTING;\n  }\n\n  var clippingPlanes = this._clippingPlanes;\n\n  if (defined(clippingPlanes) && clippingPlanes.enabled) {\n    var planeIntersection = clippingPlanes.computeIntersectionWithBoundingVolume(boundingVolume);\n    tile.isClipped = planeIntersection !== Intersect.INSIDE;\n\n    if (planeIntersection === Intersect.OUTSIDE) {\n      return Visibility.NONE;\n    }\n  }\n\n  var intersection = cullingVolume.computeVisibility(boundingVolume);\n\n  if (intersection === Intersect.OUTSIDE) {\n    return Visibility.NONE;\n  }\n\n  var ortho3D = frameState.mode === SceneMode.SCENE3D && frameState.camera.frustum instanceof OrthographicFrustum;\n\n  if (frameState.mode === SceneMode.SCENE3D && !ortho3D && defined(occluders) && !frameState.cameraUnderground) {\n    var occludeePointInScaledSpace = surfaceTile.occludeePointInScaledSpace;\n\n    if (!defined(occludeePointInScaledSpace)) {\n      return intersection;\n    }\n\n    if (occluders.ellipsoid.isScaledSpacePointVisiblePossiblyUnderEllipsoid(occludeePointInScaledSpace, tileBoundingRegion.minimumHeight)) {\n      return intersection;\n    }\n\n    return Visibility.NONE;\n  }\n\n  return intersection;\n};\n/**\n * Determines if the given tile can be refined\n * @param {QuadtreeTile} tile The tile to check.\n * @returns {boolean} True if the tile can be refined, false if it cannot.\n */\n\n\nGlobeSurfaceTileProvider.prototype.canRefine = function (tile) {\n  // Only allow refinement it we know whether or not the children of this tile exist.\n  // For a tileset with `availability`, we'll always be able to refine.\n  // We can ask for availability of _any_ child tile because we only need to confirm\n  // that we get a yes or no answer, it doesn't matter what the answer is.\n  if (defined(tile.data.terrainData)) {\n    return true;\n  }\n\n  var childAvailable = this.terrainProvider.getTileDataAvailable(tile.x * 2, tile.y * 2, tile.level + 1);\n  return childAvailable !== undefined;\n};\n\nvar readyImageryScratch = [];\nvar canRenderTraversalStack = [];\n/**\n * Determines if the given not-fully-loaded tile can be rendered without losing detail that\n * was present last frame as a result of rendering descendant tiles. This method will only be\n * called if this tile's descendants were rendered last frame. If the tile is fully loaded,\n * it is assumed that this method will return true and it will not be called.\n * @param {QuadtreeTile} tile The tile to check.\n * @returns {boolean} True if the tile can be rendered without losing detail.\n */\n\nGlobeSurfaceTileProvider.prototype.canRenderWithoutLosingDetail = function (tile, frameState) {\n  var surfaceTile = tile.data;\n  var readyImagery = readyImageryScratch;\n  readyImagery.length = this._imageryLayers.length;\n  var terrainReady = false;\n  var initialImageryState = false;\n  var imagery;\n\n  if (defined(surfaceTile)) {\n    // We can render even with non-ready terrain as long as all our rendered descendants\n    // are missing terrain geometry too. i.e. if we rendered fills for more detailed tiles\n    // last frame, it's ok to render a fill for this tile this frame.\n    terrainReady = surfaceTile.terrainState === TerrainState.READY; // Initially assume all imagery layers are ready, unless imagery hasn't been initialized at all.\n\n    initialImageryState = true;\n    imagery = surfaceTile.imagery;\n  }\n\n  var i;\n  var len;\n\n  for (i = 0, len = readyImagery.length; i < len; ++i) {\n    readyImagery[i] = initialImageryState;\n  }\n\n  if (defined(imagery)) {\n    for (i = 0, len = imagery.length; i < len; ++i) {\n      var tileImagery = imagery[i];\n      var loadingImagery = tileImagery.loadingImagery;\n      var isReady = !defined(loadingImagery) || loadingImagery.state === ImageryState.FAILED || loadingImagery.state === ImageryState.INVALID;\n      var layerIndex = (tileImagery.loadingImagery || tileImagery.readyImagery).imageryLayer._layerIndex; // For a layer to be ready, all tiles belonging to that layer must be ready.\n\n      readyImagery[layerIndex] = isReady && readyImagery[layerIndex];\n    }\n  }\n\n  var lastFrame = this.quadtree._lastSelectionFrameNumber; // Traverse the descendants looking for one with terrain or imagery that is not loaded on this tile.\n\n  var stack = canRenderTraversalStack;\n  stack.length = 0;\n  stack.push(tile.southwestChild, tile.southeastChild, tile.northwestChild, tile.northeastChild);\n\n  while (stack.length > 0) {\n    var descendant = stack.pop();\n    var lastFrameSelectionResult = descendant._lastSelectionResultFrame === lastFrame ? descendant._lastSelectionResult : TileSelectionResult.NONE;\n\n    if (lastFrameSelectionResult === TileSelectionResult.RENDERED) {\n      var descendantSurface = descendant.data;\n\n      if (!defined(descendantSurface)) {\n        // Descendant has no data, so it can't block rendering.\n        continue;\n      }\n\n      if (!terrainReady && descendant.data.terrainState === TerrainState.READY) {\n        // Rendered descendant has real terrain, but we don't. Rendering is blocked.\n        return false;\n      }\n\n      var descendantImagery = descendant.data.imagery;\n\n      for (i = 0, len = descendantImagery.length; i < len; ++i) {\n        var descendantTileImagery = descendantImagery[i];\n        var descendantLoadingImagery = descendantTileImagery.loadingImagery;\n        var descendantIsReady = !defined(descendantLoadingImagery) || descendantLoadingImagery.state === ImageryState.FAILED || descendantLoadingImagery.state === ImageryState.INVALID;\n        var descendantLayerIndex = (descendantTileImagery.loadingImagery || descendantTileImagery.readyImagery).imageryLayer._layerIndex; // If this imagery tile of a descendant is ready but the layer isn't ready in this tile,\n        // then rendering is blocked.\n\n        if (descendantIsReady && !readyImagery[descendantLayerIndex]) {\n          return false;\n        }\n      }\n    } else if (lastFrameSelectionResult === TileSelectionResult.REFINED) {\n      stack.push(descendant.southwestChild, descendant.southeastChild, descendant.northwestChild, descendant.northeastChild);\n    }\n  }\n\n  return true;\n};\n\nvar tileDirectionScratch = new Cartesian3();\n/**\n * Determines the priority for loading this tile. Lower priority values load sooner.\n * @param {QuadtreeTile} tile The tile.\n * @param {FrameState} frameState The frame state.\n * @returns {Number} The load priority value.\n */\n\nGlobeSurfaceTileProvider.prototype.computeTileLoadPriority = function (tile, frameState) {\n  var surfaceTile = tile.data;\n\n  if (surfaceTile === undefined) {\n    return 0.0;\n  }\n\n  var obb = surfaceTile.orientedBoundingBox;\n\n  if (obb === undefined) {\n    return 0.0;\n  }\n\n  var cameraPosition = frameState.camera.positionWC;\n  var cameraDirection = frameState.camera.directionWC;\n  var tileDirection = Cartesian3.subtract(obb.center, cameraPosition, tileDirectionScratch);\n  var magnitude = Cartesian3.magnitude(tileDirection);\n\n  if (magnitude < CesiumMath.EPSILON5) {\n    return 0.0;\n  }\n\n  Cartesian3.divideByScalar(tileDirection, magnitude, tileDirection);\n  return (1.0 - Cartesian3.dot(tileDirection, cameraDirection)) * tile._distance;\n};\n\nvar modifiedModelViewScratch = new Matrix4();\nvar modifiedModelViewProjectionScratch = new Matrix4();\nvar tileRectangleScratch = new Cartesian4();\nvar localizedCartographicLimitRectangleScratch = new Cartesian4();\nvar rtcScratch = new Cartesian3();\nvar centerEyeScratch = new Cartesian3();\nvar southwestScratch = new Cartesian3();\nvar northeastScratch = new Cartesian3();\n/**\n * Shows a specified tile in this frame.  The provider can cause the tile to be shown by adding\n * render commands to the commandList, or use any other method as appropriate.  The tile is not\n * expected to be visible next frame as well, unless this method is called next frame, too.\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {FrameState} frameState The state information of the current rendering frame.\n */\n\nGlobeSurfaceTileProvider.prototype.showTileThisFrame = function (tile, frameState) {\n  var readyTextureCount = 0;\n  var tileImageryCollection = tile.data.imagery;\n\n  for (var i = 0, len = tileImageryCollection.length; i < len; ++i) {\n    var tileImagery = tileImageryCollection[i];\n\n    if (defined(tileImagery.readyImagery) && tileImagery.readyImagery.imageryLayer.alpha !== 0.0) {\n      ++readyTextureCount;\n    }\n  }\n\n  var tileSet = this._tilesToRenderByTextureCount[readyTextureCount];\n\n  if (!defined(tileSet)) {\n    tileSet = [];\n    this._tilesToRenderByTextureCount[readyTextureCount] = tileSet;\n  }\n\n  tileSet.push(tile);\n  var surfaceTile = tile.data;\n\n  if (!defined(surfaceTile.vertexArray)) {\n    this._hasFillTilesThisFrame = true;\n  } else {\n    this._hasLoadedTilesThisFrame = true;\n  }\n\n  var debug = this._debug;\n  ++debug.tilesRendered;\n  debug.texturesRendered += readyTextureCount;\n};\n\nvar cornerPositionsScratch = [new Cartesian3(), new Cartesian3(), new Cartesian3(), new Cartesian3()];\n\nfunction computeOccludeePoint(tileProvider, center, rectangle, minimumHeight, maximumHeight, result) {\n  var ellipsoidalOccluder = tileProvider.quadtree._occluders.ellipsoid;\n  var ellipsoid = ellipsoidalOccluder.ellipsoid;\n  var cornerPositions = cornerPositionsScratch;\n  Cartesian3.fromRadians(rectangle.west, rectangle.south, maximumHeight, ellipsoid, cornerPositions[0]);\n  Cartesian3.fromRadians(rectangle.east, rectangle.south, maximumHeight, ellipsoid, cornerPositions[1]);\n  Cartesian3.fromRadians(rectangle.west, rectangle.north, maximumHeight, ellipsoid, cornerPositions[2]);\n  Cartesian3.fromRadians(rectangle.east, rectangle.north, maximumHeight, ellipsoid, cornerPositions[3]);\n  return ellipsoidalOccluder.computeHorizonCullingPointPossiblyUnderEllipsoid(center, cornerPositions, minimumHeight, result);\n}\n/**\n * Gets the distance from the camera to the closest point on the tile.  This is used for level-of-detail selection.\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {FrameState} frameState The state information of the current rendering frame.\n *\n * @returns {Number} The distance from the camera to the closest point on the tile, in meters.\n */\n\n\nGlobeSurfaceTileProvider.prototype.computeDistanceToTile = function (tile, frameState) {\n  // The distance should be:\n  // 1. the actual distance to the tight-fitting bounding volume, or\n  // 2. a distance that is equal to or greater than the actual distance to the tight-fitting bounding volume.\n  //\n  // When we don't know the min/max heights for a tile, but we do know the min/max of an ancestor tile, we can\n  // build a tight-fitting bounding volume horizontally, but not vertically. The min/max heights from the\n  // ancestor will likely form a volume that is much bigger than it needs to be. This means that the volume may\n  // be deemed to be much closer to the camera than it really is, causing us to select tiles that are too detailed.\n  // Loading too-detailed tiles is super expensive, so we don't want to do that. We don't know where the child\n  // tile really lies within the parent range of heights, but we _do_ know the child tile can't be any closer than\n  // the ancestor height surface (min or max) that is _farthest away_ from the camera. So if we compute distance\n  // based that conservative metric, we may end up loading tiles that are not detailed enough, but that's much\n  // better (faster) than loading tiles that are too detailed.\n  var heightSource = updateTileBoundingRegion(tile, this.terrainProvider, frameState);\n  var surfaceTile = tile.data;\n  var tileBoundingRegion = surfaceTile.tileBoundingRegion;\n\n  if (heightSource === undefined) {\n    // Can't find any min/max heights anywhere? Ok, let's just say the\n    // tile is really far away so we'll load and render it rather than\n    // refining.\n    return 9999999999.0;\n  } else if (surfaceTile.boundingVolumeSourceTile !== heightSource) {\n    // Heights are from a new source tile, so update the bounding volume.\n    surfaceTile.boundingVolumeSourceTile = heightSource;\n    var rectangle = tile.rectangle;\n\n    if (defined(rectangle)) {\n      surfaceTile.orientedBoundingBox = OrientedBoundingBox.fromRectangle(tile.rectangle, tileBoundingRegion.minimumHeight, tileBoundingRegion.maximumHeight, tile.tilingScheme.ellipsoid, surfaceTile.orientedBoundingBox);\n      surfaceTile.occludeePointInScaledSpace = computeOccludeePoint(this, surfaceTile.orientedBoundingBox.center, tile.rectangle, tileBoundingRegion.minimumHeight, tileBoundingRegion.maximumHeight, surfaceTile.occludeePointInScaledSpace);\n    }\n  }\n\n  var min = tileBoundingRegion.minimumHeight;\n  var max = tileBoundingRegion.maximumHeight;\n\n  if (surfaceTile.boundingVolumeSourceTile !== tile) {\n    var cameraHeight = frameState.camera.positionCartographic.height;\n    var distanceToMin = Math.abs(cameraHeight - min);\n    var distanceToMax = Math.abs(cameraHeight - max);\n\n    if (distanceToMin > distanceToMax) {\n      tileBoundingRegion.minimumHeight = min;\n      tileBoundingRegion.maximumHeight = min;\n    } else {\n      tileBoundingRegion.minimumHeight = max;\n      tileBoundingRegion.maximumHeight = max;\n    }\n  }\n\n  var result = tileBoundingRegion.distanceToCamera(frameState);\n  tileBoundingRegion.minimumHeight = min;\n  tileBoundingRegion.maximumHeight = max;\n  return result;\n};\n\nfunction updateTileBoundingRegion(tile, terrainProvider, frameState) {\n  var surfaceTile = tile.data;\n\n  if (surfaceTile === undefined) {\n    surfaceTile = tile.data = new GlobeSurfaceTile();\n  }\n\n  if (surfaceTile.tileBoundingRegion === undefined) {\n    surfaceTile.tileBoundingRegion = new TileBoundingRegion({\n      computeBoundingVolumes: false,\n      rectangle: tile.rectangle,\n      ellipsoid: tile.tilingScheme.ellipsoid,\n      minimumHeight: 0.0,\n      maximumHeight: 0.0\n    });\n  }\n\n  var terrainData = surfaceTile.terrainData;\n  var mesh = surfaceTile.mesh;\n  var tileBoundingRegion = surfaceTile.tileBoundingRegion;\n\n  if (mesh !== undefined && mesh.minimumHeight !== undefined && mesh.maximumHeight !== undefined) {\n    // We have tight-fitting min/max heights from the mesh.\n    tileBoundingRegion.minimumHeight = mesh.minimumHeight;\n    tileBoundingRegion.maximumHeight = mesh.maximumHeight;\n    return tile;\n  }\n\n  if (terrainData !== undefined && terrainData._minimumHeight !== undefined && terrainData._maximumHeight !== undefined) {\n    // We have tight-fitting min/max heights from the terrain data.\n    tileBoundingRegion.minimumHeight = terrainData._minimumHeight * frameState.terrainExaggeration;\n    tileBoundingRegion.maximumHeight = terrainData._maximumHeight * frameState.terrainExaggeration;\n    return tile;\n  } // No accurate min/max heights available, so we're stuck with min/max heights from an ancestor tile.\n\n\n  tileBoundingRegion.minimumHeight = Number.NaN;\n  tileBoundingRegion.maximumHeight = Number.NaN;\n  var ancestor = tile.parent;\n\n  while (ancestor !== undefined) {\n    var ancestorSurfaceTile = ancestor.data;\n\n    if (ancestorSurfaceTile !== undefined) {\n      var ancestorMesh = ancestorSurfaceTile.mesh;\n\n      if (ancestorMesh !== undefined && ancestorMesh.minimumHeight !== undefined && ancestorMesh.maximumHeight !== undefined) {\n        tileBoundingRegion.minimumHeight = ancestorMesh.minimumHeight;\n        tileBoundingRegion.maximumHeight = ancestorMesh.maximumHeight;\n        return ancestor;\n      }\n\n      var ancestorTerrainData = ancestorSurfaceTile.terrainData;\n\n      if (ancestorTerrainData !== undefined && ancestorTerrainData._minimumHeight !== undefined && ancestorTerrainData._maximumHeight !== undefined) {\n        tileBoundingRegion.minimumHeight = ancestorTerrainData._minimumHeight * frameState.terrainExaggeration;\n        tileBoundingRegion.maximumHeight = ancestorTerrainData._maximumHeight * frameState.terrainExaggeration;\n        return ancestor;\n      }\n    }\n\n    ancestor = ancestor.parent;\n  }\n\n  return undefined;\n}\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see GlobeSurfaceTileProvider#destroy\n */\n\n\nGlobeSurfaceTileProvider.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * provider = provider && provider();\n *\n * @see GlobeSurfaceTileProvider#isDestroyed\n */\n\n\nGlobeSurfaceTileProvider.prototype.destroy = function () {\n  this._tileProvider = this._tileProvider && this._tileProvider.destroy();\n  this._clippingPlanes = this._clippingPlanes && this._clippingPlanes.destroy();\n  return destroyObject(this);\n};\n\nfunction getTileReadyCallback(tileImageriesToFree, layer, terrainProvider) {\n  return function (tile) {\n    var tileImagery;\n    var imagery;\n    var startIndex = -1;\n    var tileImageryCollection = tile.data.imagery;\n    var length = tileImageryCollection.length;\n    var i;\n\n    for (i = 0; i < length; ++i) {\n      tileImagery = tileImageryCollection[i];\n      imagery = defaultValue(tileImagery.readyImagery, tileImagery.loadingImagery);\n\n      if (imagery.imageryLayer === layer) {\n        startIndex = i;\n        break;\n      }\n    }\n\n    if (startIndex !== -1) {\n      var endIndex = startIndex + tileImageriesToFree;\n      tileImagery = tileImageryCollection[endIndex];\n      imagery = defined(tileImagery) ? defaultValue(tileImagery.readyImagery, tileImagery.loadingImagery) : undefined;\n\n      if (!defined(imagery) || imagery.imageryLayer !== layer) {\n        // Return false to keep the callback if we have to wait on the skeletons\n        // Return true to remove the callback if something went wrong\n        return !layer._createTileImagerySkeletons(tile, terrainProvider, endIndex);\n      }\n\n      for (i = startIndex; i < endIndex; ++i) {\n        tileImageryCollection[i].freeResources();\n      }\n\n      tileImageryCollection.splice(startIndex, tileImageriesToFree);\n    }\n\n    return true; // Everything is done, so remove the callback\n  };\n}\n\nGlobeSurfaceTileProvider.prototype._onLayerAdded = function (layer, index) {\n  if (layer.show) {\n    var terrainProvider = this._terrainProvider;\n    var that = this;\n    var imageryProvider = layer.imageryProvider;\n    var tileImageryUpdatedEvent = this._imageryLayersUpdatedEvent;\n\n    imageryProvider._reload = function () {\n      // Clear the layer's cache\n      layer._imageryCache = {};\n\n      that._quadtree.forEachLoadedTile(function (tile) {\n        // If this layer is still waiting to for the loaded callback, just return\n        if (defined(tile._loadedCallbacks[layer._layerIndex])) {\n          return;\n        }\n\n        var i; // Figure out how many TileImageries we will need to remove and where to insert new ones\n\n        var tileImageryCollection = tile.data.imagery;\n        var length = tileImageryCollection.length;\n        var startIndex = -1;\n        var tileImageriesToFree = 0;\n\n        for (i = 0; i < length; ++i) {\n          var tileImagery = tileImageryCollection[i];\n          var imagery = defaultValue(tileImagery.readyImagery, tileImagery.loadingImagery);\n\n          if (imagery.imageryLayer === layer) {\n            if (startIndex === -1) {\n              startIndex = i;\n            }\n\n            ++tileImageriesToFree;\n          } else if (startIndex !== -1) {\n            // iterated past the section of TileImageries belonging to this layer, no need to continue.\n            break;\n          }\n        }\n\n        if (startIndex === -1) {\n          return;\n        } // Insert immediately after existing TileImageries\n\n\n        var insertionPoint = startIndex + tileImageriesToFree; // Create new TileImageries for all loaded tiles\n\n        if (layer._createTileImagerySkeletons(tile, terrainProvider, insertionPoint)) {\n          // Add callback to remove old TileImageries when the new TileImageries are ready\n          tile._loadedCallbacks[layer._layerIndex] = getTileReadyCallback(tileImageriesToFree, layer, terrainProvider);\n          tile.state = QuadtreeTileLoadState.LOADING;\n        }\n      });\n    }; // create TileImageries for this layer for all previously loaded tiles\n\n\n    this._quadtree.forEachLoadedTile(function (tile) {\n      if (layer._createTileImagerySkeletons(tile, terrainProvider)) {\n        tile.state = QuadtreeTileLoadState.LOADING; // Tiles that are not currently being rendered need to load the new layer before they're renderable.\n        // We don't mark the rendered tiles non-renderable, though, because that would make the globe disappear.\n\n        if (tile.level !== 0 && (tile._lastSelectionResultFrame !== that.quadtree._lastSelectionFrameNumber || tile._lastSelectionResult !== TileSelectionResult.RENDERED)) {\n          tile.renderable = false;\n        }\n      }\n    });\n\n    this._layerOrderChanged = true;\n    tileImageryUpdatedEvent.raiseEvent();\n  }\n};\n\nGlobeSurfaceTileProvider.prototype._onLayerRemoved = function (layer, index) {\n  // destroy TileImagerys for this layer for all previously loaded tiles\n  this._quadtree.forEachLoadedTile(function (tile) {\n    var tileImageryCollection = tile.data.imagery;\n    var startIndex = -1;\n    var numDestroyed = 0;\n\n    for (var i = 0, len = tileImageryCollection.length; i < len; ++i) {\n      var tileImagery = tileImageryCollection[i];\n      var imagery = tileImagery.loadingImagery;\n\n      if (!defined(imagery)) {\n        imagery = tileImagery.readyImagery;\n      }\n\n      if (imagery.imageryLayer === layer) {\n        if (startIndex === -1) {\n          startIndex = i;\n        }\n\n        tileImagery.freeResources();\n        ++numDestroyed;\n      } else if (startIndex !== -1) {\n        // iterated past the section of TileImagerys belonging to this layer, no need to continue.\n        break;\n      }\n    }\n\n    if (startIndex !== -1) {\n      tileImageryCollection.splice(startIndex, numDestroyed);\n    }\n  });\n\n  if (defined(layer.imageryProvider)) {\n    layer.imageryProvider._reload = undefined;\n  }\n\n  this._imageryLayersUpdatedEvent.raiseEvent();\n};\n\nGlobeSurfaceTileProvider.prototype._onLayerMoved = function (layer, newIndex, oldIndex) {\n  this._layerOrderChanged = true;\n\n  this._imageryLayersUpdatedEvent.raiseEvent();\n};\n\nGlobeSurfaceTileProvider.prototype._onLayerShownOrHidden = function (layer, index, show) {\n  if (show) {\n    this._onLayerAdded(layer, index);\n  } else {\n    this._onLayerRemoved(layer, index);\n  }\n};\n\nvar scratchClippingPlaneMatrix = new Matrix4();\n\nfunction createTileUniformMap(frameState, globeSurfaceTileProvider) {\n  var uniformMap = {\n    u_initialColor: function u_initialColor() {\n      return this.properties.initialColor;\n    },\n    u_fillHighlightColor: function u_fillHighlightColor() {\n      return this.properties.fillHighlightColor;\n    },\n    u_zoomedOutOceanSpecularIntensity: function u_zoomedOutOceanSpecularIntensity() {\n      return this.properties.zoomedOutOceanSpecularIntensity;\n    },\n    u_oceanNormalMap: function u_oceanNormalMap() {\n      return this.properties.oceanNormalMap;\n    },\n    u_lightingFadeDistance: function u_lightingFadeDistance() {\n      return this.properties.lightingFadeDistance;\n    },\n    u_nightFadeDistance: function u_nightFadeDistance() {\n      return this.properties.nightFadeDistance;\n    },\n    u_center3D: function u_center3D() {\n      return this.properties.center3D;\n    },\n    u_tileRectangle: function u_tileRectangle() {\n      return this.properties.tileRectangle;\n    },\n    u_modifiedModelView: function u_modifiedModelView() {\n      var viewMatrix = frameState.context.uniformState.view;\n      var centerEye = Matrix4.multiplyByPoint(viewMatrix, this.properties.rtc, centerEyeScratch);\n      Matrix4.setTranslation(viewMatrix, centerEye, modifiedModelViewScratch);\n      return modifiedModelViewScratch;\n    },\n    u_modifiedModelViewProjection: function u_modifiedModelViewProjection() {\n      var viewMatrix = frameState.context.uniformState.view;\n      var projectionMatrix = frameState.context.uniformState.projection;\n      var centerEye = Matrix4.multiplyByPoint(viewMatrix, this.properties.rtc, centerEyeScratch);\n      Matrix4.setTranslation(viewMatrix, centerEye, modifiedModelViewProjectionScratch);\n      Matrix4.multiply(projectionMatrix, modifiedModelViewProjectionScratch, modifiedModelViewProjectionScratch);\n      return modifiedModelViewProjectionScratch;\n    },\n    u_dayTextures: function u_dayTextures() {\n      return this.properties.dayTextures;\n    },\n    u_dayTextureTranslationAndScale: function u_dayTextureTranslationAndScale() {\n      return this.properties.dayTextureTranslationAndScale;\n    },\n    u_dayTextureTexCoordsRectangle: function u_dayTextureTexCoordsRectangle() {\n      return this.properties.dayTextureTexCoordsRectangle;\n    },\n    u_dayTextureUseWebMercatorT: function u_dayTextureUseWebMercatorT() {\n      return this.properties.dayTextureUseWebMercatorT;\n    },\n    u_dayTextureAlpha: function u_dayTextureAlpha() {\n      return this.properties.dayTextureAlpha;\n    },\n    u_dayTextureBrightness: function u_dayTextureBrightness() {\n      return this.properties.dayTextureBrightness;\n    },\n    u_dayTextureContrast: function u_dayTextureContrast() {\n      return this.properties.dayTextureContrast;\n    },\n    u_dayTextureHue: function u_dayTextureHue() {\n      return this.properties.dayTextureHue;\n    },\n    u_dayTextureSaturation: function u_dayTextureSaturation() {\n      return this.properties.dayTextureSaturation;\n    },\n    u_dayTextureOneOverGamma: function u_dayTextureOneOverGamma() {\n      return this.properties.dayTextureOneOverGamma;\n    },\n    u_dayIntensity: function u_dayIntensity() {\n      return this.properties.dayIntensity;\n    },\n    u_southAndNorthLatitude: function u_southAndNorthLatitude() {\n      return this.properties.southAndNorthLatitude;\n    },\n    u_southMercatorYAndOneOverHeight: function u_southMercatorYAndOneOverHeight() {\n      return this.properties.southMercatorYAndOneOverHeight;\n    },\n    u_waterMask: function u_waterMask() {\n      return this.properties.waterMask;\n    },\n    u_waterMaskTranslationAndScale: function u_waterMaskTranslationAndScale() {\n      return this.properties.waterMaskTranslationAndScale;\n    },\n    u_minMaxHeight: function u_minMaxHeight() {\n      return this.properties.minMaxHeight;\n    },\n    u_scaleAndBias: function u_scaleAndBias() {\n      return this.properties.scaleAndBias;\n    },\n    u_dayTextureSplit: function u_dayTextureSplit() {\n      return this.properties.dayTextureSplit;\n    },\n    u_dayTextureCutoutRectangles: function u_dayTextureCutoutRectangles() {\n      return this.properties.dayTextureCutoutRectangles;\n    },\n    u_clippingPlanes: function u_clippingPlanes() {\n      var clippingPlanes = globeSurfaceTileProvider._clippingPlanes;\n\n      if (defined(clippingPlanes) && defined(clippingPlanes.texture)) {\n        // Check in case clippingPlanes hasn't been updated yet.\n        return clippingPlanes.texture;\n      }\n\n      return frameState.context.defaultTexture;\n    },\n    u_cartographicLimitRectangle: function u_cartographicLimitRectangle() {\n      return this.properties.localizedCartographicLimitRectangle;\n    },\n    u_clippingPlanesMatrix: function u_clippingPlanesMatrix() {\n      var clippingPlanes = globeSurfaceTileProvider._clippingPlanes;\n      return defined(clippingPlanes) ? Matrix4.multiply(frameState.context.uniformState.view, clippingPlanes.modelMatrix, scratchClippingPlaneMatrix) : Matrix4.IDENTITY;\n    },\n    u_clippingPlanesEdgeStyle: function u_clippingPlanesEdgeStyle() {\n      var style = this.properties.clippingPlanesEdgeColor;\n      style.alpha = this.properties.clippingPlanesEdgeWidth;\n      return style;\n    },\n    u_minimumBrightness: function u_minimumBrightness() {\n      return frameState.fog.minimumBrightness;\n    },\n    u_hsbShift: function u_hsbShift() {\n      return this.properties.hsbShift;\n    },\n    u_colorsToAlpha: function u_colorsToAlpha() {\n      return this.properties.colorsToAlpha;\n    },\n    // make a separate object so that changes to the properties are seen on\n    // derived commands that combine another uniform map with this one.\n    properties: {\n      initialColor: new Cartesian4(0.0, 0.0, 0.5, 1.0),\n      fillHighlightColor: new Color(0.0, 0.0, 0.0, 0.0),\n      zoomedOutOceanSpecularIntensity: 0.5,\n      oceanNormalMap: undefined,\n      lightingFadeDistance: new Cartesian2(6500000.0, 9000000.0),\n      nightFadeDistance: new Cartesian2(10000000.0, 40000000.0),\n      hsbShift: new Cartesian3(),\n      center3D: undefined,\n      rtc: new Cartesian3(),\n      modifiedModelView: new Matrix4(),\n      tileRectangle: new Cartesian4(),\n      dayTextures: [],\n      dayTextureTranslationAndScale: [],\n      dayTextureTexCoordsRectangle: [],\n      dayTextureUseWebMercatorT: [],\n      dayTextureAlpha: [],\n      dayTextureBrightness: [],\n      dayTextureContrast: [],\n      dayTextureHue: [],\n      dayTextureSaturation: [],\n      dayTextureOneOverGamma: [],\n      dayTextureSplit: [],\n      dayTextureCutoutRectangles: [],\n      dayIntensity: 0.0,\n      colorsToAlpha: [],\n      southAndNorthLatitude: new Cartesian2(),\n      southMercatorYAndOneOverHeight: new Cartesian2(),\n      waterMask: undefined,\n      waterMaskTranslationAndScale: new Cartesian4(),\n      minMaxHeight: new Cartesian2(),\n      scaleAndBias: new Matrix4(),\n      clippingPlanesEdgeColor: Color.clone(Color.WHITE),\n      clippingPlanesEdgeWidth: 0.0,\n      localizedCartographicLimitRectangle: new Cartesian4()\n    }\n  };\n  return uniformMap;\n}\n\nfunction createWireframeVertexArrayIfNecessary(context, provider, tile) {\n  var surfaceTile = tile.data;\n  var mesh;\n  var vertexArray;\n\n  if (defined(surfaceTile.vertexArray)) {\n    mesh = surfaceTile.mesh;\n    vertexArray = surfaceTile.vertexArray;\n  } else if (defined(surfaceTile.fill) && defined(surfaceTile.fill.vertexArray)) {\n    mesh = surfaceTile.fill.mesh;\n    vertexArray = surfaceTile.fill.vertexArray;\n  }\n\n  if (!defined(mesh) || !defined(vertexArray)) {\n    return;\n  }\n\n  if (defined(surfaceTile.wireframeVertexArray)) {\n    if (surfaceTile.wireframeVertexArray.mesh === mesh) {\n      return;\n    }\n\n    surfaceTile.wireframeVertexArray.destroy();\n    surfaceTile.wireframeVertexArray = undefined;\n  }\n\n  surfaceTile.wireframeVertexArray = createWireframeVertexArray(context, vertexArray, mesh);\n  surfaceTile.wireframeVertexArray.mesh = mesh;\n}\n/**\n * Creates a vertex array for wireframe rendering of a terrain tile.\n *\n * @private\n *\n * @param {Context} context The context in which to create the vertex array.\n * @param {VertexArray} vertexArray The existing, non-wireframe vertex array.  The new vertex array\n *                      will share vertex buffers with this existing one.\n * @param {TerrainMesh} terrainMesh The terrain mesh containing non-wireframe indices.\n * @returns {VertexArray} The vertex array for wireframe rendering.\n */\n\n\nfunction createWireframeVertexArray(context, vertexArray, terrainMesh) {\n  var indices = terrainMesh.indices;\n  var geometry = {\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES\n  };\n  GeometryPipeline.toWireframe(geometry);\n  var wireframeIndices = geometry.indices;\n  var wireframeIndexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: wireframeIndices,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: IndexDatatype.fromSizeInBytes(wireframeIndices.BYTES_PER_ELEMENT)\n  });\n  return new VertexArray({\n    context: context,\n    attributes: vertexArray._attributes,\n    indexBuffer: wireframeIndexBuffer\n  });\n}\n\nvar getDebugOrientedBoundingBox;\nvar getDebugBoundingSphere;\nvar debugDestroyPrimitive;\n\n(function () {\n  var instanceOBB = new GeometryInstance({\n    geometry: BoxOutlineGeometry.fromDimensions({\n      dimensions: new Cartesian3(2.0, 2.0, 2.0)\n    })\n  });\n  var instanceSphere = new GeometryInstance({\n    geometry: new SphereOutlineGeometry({\n      radius: 1.0\n    })\n  });\n  var modelMatrix = new Matrix4();\n  var previousVolume;\n  var primitive;\n\n  function createDebugPrimitive(instance) {\n    return new Primitive({\n      geometryInstances: instance,\n      appearance: new PerInstanceColorAppearance({\n        translucent: false,\n        flat: true\n      }),\n      asynchronous: false\n    });\n  }\n\n  getDebugOrientedBoundingBox = function getDebugOrientedBoundingBox(obb, color) {\n    if (obb === previousVolume) {\n      return primitive;\n    }\n\n    debugDestroyPrimitive();\n    previousVolume = obb;\n    modelMatrix = Matrix4.fromRotationTranslation(obb.halfAxes, obb.center, modelMatrix);\n    instanceOBB.modelMatrix = modelMatrix;\n    instanceOBB.attributes.color = ColorGeometryInstanceAttribute.fromColor(color);\n    primitive = createDebugPrimitive(instanceOBB);\n    return primitive;\n  };\n\n  getDebugBoundingSphere = function getDebugBoundingSphere(sphere, color) {\n    if (sphere === previousVolume) {\n      return primitive;\n    }\n\n    debugDestroyPrimitive();\n    previousVolume = sphere;\n    modelMatrix = Matrix4.fromTranslation(sphere.center, modelMatrix);\n    modelMatrix = Matrix4.multiplyByUniformScale(modelMatrix, sphere.radius, modelMatrix);\n    instanceSphere.modelMatrix = modelMatrix;\n    instanceSphere.attributes.color = ColorGeometryInstanceAttribute.fromColor(color);\n    primitive = createDebugPrimitive(instanceSphere);\n    return primitive;\n  };\n\n  debugDestroyPrimitive = function debugDestroyPrimitive() {\n    if (defined(primitive)) {\n      primitive.destroy();\n      primitive = undefined;\n      previousVolume = undefined;\n    }\n  };\n})();\n\nvar otherPassesInitialColor = new Cartesian4(0.0, 0.0, 0.0, 0.0);\nvar surfaceShaderSetOptionsScratch = {\n  frameState: undefined,\n  surfaceTile: undefined,\n  numberOfDayTextures: undefined,\n  applyBrightness: undefined,\n  applyContrast: undefined,\n  applyHue: undefined,\n  applySaturation: undefined,\n  applyGamma: undefined,\n  applyAlpha: undefined,\n  applySplit: undefined,\n  showReflectiveOcean: undefined,\n  showOceanWaves: undefined,\n  enableLighting: undefined,\n  dynamicAtmosphereLighting: undefined,\n  dynamicAtmosphereLightingFromSun: undefined,\n  showGroundAtmosphere: undefined,\n  perFragmentGroundAtmosphere: undefined,\n  hasVertexNormals: undefined,\n  useWebMercatorProjection: undefined,\n  enableFog: undefined,\n  enableClippingPlanes: undefined,\n  clippingPlanes: undefined,\n  clippedByBoundaries: undefined,\n  hasImageryLayerCutout: undefined,\n  colorCorrect: undefined,\n  colorToAlpha: undefined\n};\n\nfunction addDrawCommandsForTile(tileProvider, tile, frameState) {\n  var surfaceTile = tile.data;\n\n  if (!defined(surfaceTile.vertexArray)) {\n    if (surfaceTile.fill === undefined) {\n      // No fill was created for this tile, probably because this tile is not connected to\n      // any renderable tiles. So create a simple tile in the middle of the tile's possible\n      // height range.\n      surfaceTile.fill = new TerrainFillMesh(tile);\n    }\n\n    surfaceTile.fill.update(tileProvider, frameState);\n  }\n\n  var creditDisplay = frameState.creditDisplay;\n  var terrainData = surfaceTile.terrainData;\n\n  if (defined(terrainData) && defined(terrainData.credits)) {\n    var tileCredits = terrainData.credits;\n\n    for (var tileCreditIndex = 0, tileCreditLength = tileCredits.length; tileCreditIndex < tileCreditLength; ++tileCreditIndex) {\n      creditDisplay.addCredit(tileCredits[tileCreditIndex]);\n    }\n  }\n\n  var maxTextures = ContextLimits.maximumTextureImageUnits;\n  var waterMaskTexture = surfaceTile.waterMaskTexture;\n  var waterMaskTranslationAndScale = surfaceTile.waterMaskTranslationAndScale;\n\n  if (!defined(waterMaskTexture) && defined(surfaceTile.fill)) {\n    waterMaskTexture = surfaceTile.fill.waterMaskTexture;\n    waterMaskTranslationAndScale = surfaceTile.fill.waterMaskTranslationAndScale;\n  }\n\n  var cameraUnderground = frameState.cameraUnderground;\n  var showReflectiveOcean = tileProvider.hasWaterMask && defined(waterMaskTexture);\n  var oceanNormalMap = tileProvider.oceanNormalMap;\n  var showOceanWaves = showReflectiveOcean && defined(oceanNormalMap);\n  var hasVertexNormals = tileProvider.terrainProvider.ready && tileProvider.terrainProvider.hasVertexNormals;\n  var enableFog = frameState.fog.enabled && !cameraUnderground;\n  var showGroundAtmosphere = tileProvider.showGroundAtmosphere;\n  var castShadows = ShadowMode.castShadows(tileProvider.shadows);\n  var receiveShadows = ShadowMode.receiveShadows(tileProvider.shadows);\n  var hueShift = tileProvider.hueShift;\n  var saturationShift = tileProvider.saturationShift;\n  var brightnessShift = tileProvider.brightnessShift;\n  var colorCorrect = !(CesiumMath.equalsEpsilon(hueShift, 0.0, CesiumMath.EPSILON7) && CesiumMath.equalsEpsilon(saturationShift, 0.0, CesiumMath.EPSILON7) && CesiumMath.equalsEpsilon(brightnessShift, 0.0, CesiumMath.EPSILON7));\n  var perFragmentGroundAtmosphere = false;\n\n  if (showGroundAtmosphere) {\n    var mode = frameState.mode;\n    var camera = frameState.camera;\n    var cameraDistance;\n\n    if (mode === SceneMode.SCENE2D || mode === SceneMode.COLUMBUS_VIEW) {\n      cameraDistance = camera.positionCartographic.height;\n    } else {\n      cameraDistance = Cartesian3.magnitude(camera.positionWC);\n    }\n\n    var fadeOutDistance = tileProvider.nightFadeOutDistance;\n\n    if (mode !== SceneMode.SCENE3D) {\n      fadeOutDistance -= frameState.mapProjection.ellipsoid.maximumRadius;\n    }\n\n    perFragmentGroundAtmosphere = cameraDistance > fadeOutDistance;\n  }\n\n  if (showReflectiveOcean) {\n    --maxTextures;\n  }\n\n  if (showOceanWaves) {\n    --maxTextures;\n  }\n\n  if (defined(frameState.shadowState) && frameState.shadowState.shadowsEnabled) {\n    --maxTextures;\n  }\n\n  if (defined(tileProvider.clippingPlanes) && tileProvider.clippingPlanes.enabled) {\n    --maxTextures;\n  }\n\n  var mesh = surfaceTile.renderedMesh;\n  var rtc = mesh.center;\n  var encoding = mesh.encoding; // Not used in 3D.\n\n  var tileRectangle = tileRectangleScratch; // Only used for Mercator projections.\n\n  var southLatitude = 0.0;\n  var northLatitude = 0.0;\n  var southMercatorY = 0.0;\n  var oneOverMercatorHeight = 0.0;\n  var useWebMercatorProjection = false;\n\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    var projection = frameState.mapProjection;\n    var southwest = projection.project(Rectangle.southwest(tile.rectangle), southwestScratch);\n    var northeast = projection.project(Rectangle.northeast(tile.rectangle), northeastScratch);\n    tileRectangle.x = southwest.x;\n    tileRectangle.y = southwest.y;\n    tileRectangle.z = northeast.x;\n    tileRectangle.w = northeast.y; // In 2D and Columbus View, use the center of the tile for RTC rendering.\n\n    if (frameState.mode !== SceneMode.MORPHING) {\n      rtc = rtcScratch;\n      rtc.x = 0.0;\n      rtc.y = (tileRectangle.z + tileRectangle.x) * 0.5;\n      rtc.z = (tileRectangle.w + tileRectangle.y) * 0.5;\n      tileRectangle.x -= rtc.y;\n      tileRectangle.y -= rtc.z;\n      tileRectangle.z -= rtc.y;\n      tileRectangle.w -= rtc.z;\n    }\n\n    if (frameState.mode === SceneMode.SCENE2D && encoding.quantization === TerrainQuantization.BITS12) {\n      // In 2D, the texture coordinates of the tile are interpolated over the rectangle to get the position in the vertex shader.\n      // When the texture coordinates are quantized, error is introduced. This can be seen through the 1px wide cracking\n      // between the quantized tiles in 2D. To compensate for the error, move the expand the rectangle in each direction by\n      // half the error amount.\n      var epsilon = 1.0 / (Math.pow(2.0, 12.0) - 1.0) * 0.5;\n      var widthEpsilon = (tileRectangle.z - tileRectangle.x) * epsilon;\n      var heightEpsilon = (tileRectangle.w - tileRectangle.y) * epsilon;\n      tileRectangle.x -= widthEpsilon;\n      tileRectangle.y -= heightEpsilon;\n      tileRectangle.z += widthEpsilon;\n      tileRectangle.w += heightEpsilon;\n    }\n\n    if (projection instanceof WebMercatorProjection) {\n      southLatitude = tile.rectangle.south;\n      northLatitude = tile.rectangle.north;\n      southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(southLatitude);\n      oneOverMercatorHeight = 1.0 / (WebMercatorProjection.geodeticLatitudeToMercatorAngle(northLatitude) - southMercatorY);\n      useWebMercatorProjection = true;\n    }\n  }\n\n  var surfaceShaderSetOptions = surfaceShaderSetOptionsScratch;\n  surfaceShaderSetOptions.frameState = frameState;\n  surfaceShaderSetOptions.surfaceTile = surfaceTile;\n  surfaceShaderSetOptions.showReflectiveOcean = showReflectiveOcean;\n  surfaceShaderSetOptions.showOceanWaves = showOceanWaves;\n  surfaceShaderSetOptions.enableLighting = tileProvider.enableLighting;\n  surfaceShaderSetOptions.dynamicAtmosphereLighting = tileProvider.dynamicAtmosphereLighting;\n  surfaceShaderSetOptions.dynamicAtmosphereLightingFromSun = tileProvider.dynamicAtmosphereLightingFromSun;\n  surfaceShaderSetOptions.showGroundAtmosphere = showGroundAtmosphere;\n  surfaceShaderSetOptions.perFragmentGroundAtmosphere = perFragmentGroundAtmosphere;\n  surfaceShaderSetOptions.hasVertexNormals = hasVertexNormals;\n  surfaceShaderSetOptions.useWebMercatorProjection = useWebMercatorProjection;\n  surfaceShaderSetOptions.clippedByBoundaries = surfaceTile.clippedByBoundaries;\n  var tileImageryCollection = surfaceTile.imagery;\n  var imageryIndex = 0;\n  var imageryLen = tileImageryCollection.length;\n  var showSkirts = tileProvider.showSkirts && !cameraUnderground;\n  var backFaceCulling = tileProvider.backFaceCulling && !cameraUnderground;\n  var firstPassRenderState = backFaceCulling ? tileProvider._renderState : tileProvider._disableCullingRenderState;\n  var otherPassesRenderState = backFaceCulling ? tileProvider._blendRenderState : tileProvider._disableCullingBlendRenderState;\n  var renderState = firstPassRenderState;\n  var initialColor = tileProvider._firstPassInitialColor;\n  var context = frameState.context;\n\n  if (!defined(tileProvider._debug.boundingSphereTile)) {\n    debugDestroyPrimitive();\n  }\n\n  do {\n    var numberOfDayTextures = 0;\n    var command;\n    var uniformMap;\n\n    if (tileProvider._drawCommands.length <= tileProvider._usedDrawCommands) {\n      command = new DrawCommand();\n      command.owner = tile;\n      command.cull = false;\n      command.boundingVolume = new BoundingSphere();\n      command.orientedBoundingBox = undefined;\n      uniformMap = createTileUniformMap(frameState, tileProvider);\n\n      tileProvider._drawCommands.push(command);\n\n      tileProvider._uniformMaps.push(uniformMap);\n    } else {\n      command = tileProvider._drawCommands[tileProvider._usedDrawCommands];\n      uniformMap = tileProvider._uniformMaps[tileProvider._usedDrawCommands];\n    }\n\n    command.owner = tile;\n    ++tileProvider._usedDrawCommands;\n\n    if (tile === tileProvider._debug.boundingSphereTile) {\n      var obb = surfaceTile.orientedBoundingBox; // If a debug primitive already exists for this tile, it will not be\n      // re-created, to avoid allocation every frame. If it were possible\n      // to have more than one selected tile, this would have to change.\n\n      if (defined(obb)) {\n        getDebugOrientedBoundingBox(obb, Color.RED).update(frameState);\n      } else if (defined(mesh) && defined(mesh.boundingSphere3D)) {\n        getDebugBoundingSphere(mesh.boundingSphere3D, Color.RED).update(frameState);\n      }\n    }\n\n    var uniformMapProperties = uniformMap.properties;\n    Cartesian4.clone(initialColor, uniformMapProperties.initialColor);\n    uniformMapProperties.oceanNormalMap = oceanNormalMap;\n    uniformMapProperties.lightingFadeDistance.x = tileProvider.lightingFadeOutDistance;\n    uniformMapProperties.lightingFadeDistance.y = tileProvider.lightingFadeInDistance;\n    uniformMapProperties.nightFadeDistance.x = tileProvider.nightFadeOutDistance;\n    uniformMapProperties.nightFadeDistance.y = tileProvider.nightFadeInDistance;\n    uniformMapProperties.zoomedOutOceanSpecularIntensity = tileProvider.zoomedOutOceanSpecularIntensity;\n    var highlightFillTile = !defined(surfaceTile.vertexArray) && defined(tileProvider.fillHighlightColor) && tileProvider.fillHighlightColor.alpha > 0.0;\n\n    if (highlightFillTile) {\n      Color.clone(tileProvider.fillHighlightColor, uniformMapProperties.fillHighlightColor);\n    }\n\n    uniformMapProperties.center3D = mesh.center;\n    Cartesian3.clone(rtc, uniformMapProperties.rtc);\n    Cartesian4.clone(tileRectangle, uniformMapProperties.tileRectangle);\n    uniformMapProperties.southAndNorthLatitude.x = southLatitude;\n    uniformMapProperties.southAndNorthLatitude.y = northLatitude;\n    uniformMapProperties.southMercatorYAndOneOverHeight.x = southMercatorY;\n    uniformMapProperties.southMercatorYAndOneOverHeight.y = oneOverMercatorHeight; // Convert tile limiter rectangle from cartographic to texture space using the tileRectangle.\n\n    var localizedCartographicLimitRectangle = localizedCartographicLimitRectangleScratch;\n    var cartographicLimitRectangle = clipRectangleAntimeridian(tile.rectangle, tileProvider.cartographicLimitRectangle);\n    Cartesian3.fromElements(hueShift, saturationShift, brightnessShift, uniformMapProperties.hsbShift);\n    var cartographicTileRectangle = tile.rectangle;\n    var inverseTileWidth = 1.0 / cartographicTileRectangle.width;\n    var inverseTileHeight = 1.0 / cartographicTileRectangle.height;\n    localizedCartographicLimitRectangle.x = (cartographicLimitRectangle.west - cartographicTileRectangle.west) * inverseTileWidth;\n    localizedCartographicLimitRectangle.y = (cartographicLimitRectangle.south - cartographicTileRectangle.south) * inverseTileHeight;\n    localizedCartographicLimitRectangle.z = (cartographicLimitRectangle.east - cartographicTileRectangle.west) * inverseTileWidth;\n    localizedCartographicLimitRectangle.w = (cartographicLimitRectangle.north - cartographicTileRectangle.south) * inverseTileHeight;\n    Cartesian4.clone(localizedCartographicLimitRectangle, uniformMapProperties.localizedCartographicLimitRectangle); // For performance, use fog in the shader only when the tile is in fog.\n\n    var applyFog = enableFog && CesiumMath.fog(tile._distance, frameState.fog.density) > CesiumMath.EPSILON3;\n    colorCorrect = colorCorrect && (applyFog || showGroundAtmosphere);\n    var applyBrightness = false;\n    var applyContrast = false;\n    var applyHue = false;\n    var applySaturation = false;\n    var applyGamma = false;\n    var applyAlpha = false;\n    var applySplit = false;\n    var applyCutout = false;\n    var applyColorToAlpha = false;\n\n    while (numberOfDayTextures < maxTextures && imageryIndex < imageryLen) {\n      var tileImagery = tileImageryCollection[imageryIndex];\n      var imagery = tileImagery.readyImagery;\n      ++imageryIndex;\n\n      if (!defined(imagery) || imagery.imageryLayer.alpha === 0.0) {\n        continue;\n      }\n\n      var texture = tileImagery.useWebMercatorT ? imagery.textureWebMercator : imagery.texture; //>>includeStart('debug', pragmas.debug);\n\n      if (!defined(texture)) {\n        // Our \"ready\" texture isn't actually ready.  This should never happen.\n        //\n        // Side note: It IS possible for it to not be in the READY ImageryState, though.\n        // This can happen when a single imagery tile is shared by two terrain tiles (common)\n        // and one of them (A) needs a geographic version of the tile because it is near the poles,\n        // and the other (B) does not.  B can and will transition the imagery tile to the READY state\n        // without reprojecting to geographic.  Then, later, A will deem that same tile not-ready-yet\n        // because it only has the Web Mercator texture, and flip it back to the TRANSITIONING state.\n        // The imagery tile won't be in the READY state anymore, but it's still READY enough for B's\n        // purposes.\n        throw new DeveloperError(\"readyImagery is not actually ready!\");\n      } //>>includeEnd('debug');\n\n\n      var imageryLayer = imagery.imageryLayer;\n\n      if (!defined(tileImagery.textureTranslationAndScale)) {\n        tileImagery.textureTranslationAndScale = imageryLayer._calculateTextureTranslationAndScale(tile, tileImagery);\n      }\n\n      uniformMapProperties.dayTextures[numberOfDayTextures] = texture;\n      uniformMapProperties.dayTextureTranslationAndScale[numberOfDayTextures] = tileImagery.textureTranslationAndScale;\n      uniformMapProperties.dayTextureTexCoordsRectangle[numberOfDayTextures] = tileImagery.textureCoordinateRectangle;\n      uniformMapProperties.dayTextureUseWebMercatorT[numberOfDayTextures] = tileImagery.useWebMercatorT;\n      uniformMapProperties.dayTextureAlpha[numberOfDayTextures] = imageryLayer.alpha;\n      applyAlpha = applyAlpha || uniformMapProperties.dayTextureAlpha[numberOfDayTextures] !== 1.0;\n      uniformMapProperties.dayTextureBrightness[numberOfDayTextures] = imageryLayer.brightness;\n      applyBrightness = applyBrightness || uniformMapProperties.dayTextureBrightness[numberOfDayTextures] !== ImageryLayer.DEFAULT_BRIGHTNESS;\n      uniformMapProperties.dayTextureContrast[numberOfDayTextures] = imageryLayer.contrast;\n      applyContrast = applyContrast || uniformMapProperties.dayTextureContrast[numberOfDayTextures] !== ImageryLayer.DEFAULT_CONTRAST;\n      uniformMapProperties.dayTextureHue[numberOfDayTextures] = imageryLayer.hue;\n      applyHue = applyHue || uniformMapProperties.dayTextureHue[numberOfDayTextures] !== ImageryLayer.DEFAULT_HUE;\n      uniformMapProperties.dayTextureSaturation[numberOfDayTextures] = imageryLayer.saturation;\n      applySaturation = applySaturation || uniformMapProperties.dayTextureSaturation[numberOfDayTextures] !== ImageryLayer.DEFAULT_SATURATION;\n      uniformMapProperties.dayTextureOneOverGamma[numberOfDayTextures] = 1.0 / imageryLayer.gamma;\n      applyGamma = applyGamma || uniformMapProperties.dayTextureOneOverGamma[numberOfDayTextures] !== 1.0 / ImageryLayer.DEFAULT_GAMMA;\n      uniformMapProperties.dayTextureSplit[numberOfDayTextures] = imageryLayer.splitDirection;\n      applySplit = applySplit || uniformMapProperties.dayTextureSplit[numberOfDayTextures] !== 0.0; // Update cutout rectangle\n\n      var dayTextureCutoutRectangle = uniformMapProperties.dayTextureCutoutRectangles[numberOfDayTextures];\n\n      if (!defined(dayTextureCutoutRectangle)) {\n        dayTextureCutoutRectangle = uniformMapProperties.dayTextureCutoutRectangles[numberOfDayTextures] = new Cartesian4();\n      }\n\n      Cartesian4.clone(Cartesian4.ZERO, dayTextureCutoutRectangle);\n\n      if (defined(imageryLayer.cutoutRectangle)) {\n        var cutoutRectangle = clipRectangleAntimeridian(cartographicTileRectangle, imageryLayer.cutoutRectangle);\n        var intersection = Rectangle.simpleIntersection(cutoutRectangle, cartographicTileRectangle, rectangleIntersectionScratch);\n        applyCutout = defined(intersection) || applyCutout;\n        dayTextureCutoutRectangle.x = (cutoutRectangle.west - cartographicTileRectangle.west) * inverseTileWidth;\n        dayTextureCutoutRectangle.y = (cutoutRectangle.south - cartographicTileRectangle.south) * inverseTileHeight;\n        dayTextureCutoutRectangle.z = (cutoutRectangle.east - cartographicTileRectangle.west) * inverseTileWidth;\n        dayTextureCutoutRectangle.w = (cutoutRectangle.north - cartographicTileRectangle.south) * inverseTileHeight;\n      } // Update color to alpha\n\n\n      var colorToAlpha = uniformMapProperties.colorsToAlpha[numberOfDayTextures];\n\n      if (!defined(colorToAlpha)) {\n        colorToAlpha = uniformMapProperties.colorsToAlpha[numberOfDayTextures] = new Cartesian4();\n      }\n\n      var hasColorToAlpha = defined(imageryLayer.colorToAlpha) && imageryLayer.colorToAlphaThreshold > 0.0;\n      applyColorToAlpha = applyColorToAlpha || hasColorToAlpha;\n\n      if (hasColorToAlpha) {\n        var color = imageryLayer.colorToAlpha;\n        colorToAlpha.x = color.red;\n        colorToAlpha.y = color.green;\n        colorToAlpha.z = color.blue;\n        colorToAlpha.w = imageryLayer.colorToAlphaThreshold;\n      } else {\n        colorToAlpha.w = -1.0;\n      }\n\n      if (defined(imagery.credits)) {\n        var credits = imagery.credits;\n\n        for (var creditIndex = 0, creditLength = credits.length; creditIndex < creditLength; ++creditIndex) {\n          creditDisplay.addCredit(credits[creditIndex]);\n        }\n      }\n\n      ++numberOfDayTextures;\n    } // trim texture array to the used length so we don't end up using old textures\n    // which might get destroyed eventually\n\n\n    uniformMapProperties.dayTextures.length = numberOfDayTextures;\n    uniformMapProperties.waterMask = waterMaskTexture;\n    Cartesian4.clone(waterMaskTranslationAndScale, uniformMapProperties.waterMaskTranslationAndScale);\n    uniformMapProperties.minMaxHeight.x = encoding.minimumHeight;\n    uniformMapProperties.minMaxHeight.y = encoding.maximumHeight;\n    Matrix4.clone(encoding.matrix, uniformMapProperties.scaleAndBias); // update clipping planes\n\n    var clippingPlanes = tileProvider._clippingPlanes;\n    var clippingPlanesEnabled = defined(clippingPlanes) && clippingPlanes.enabled && tile.isClipped;\n\n    if (clippingPlanesEnabled) {\n      uniformMapProperties.clippingPlanesEdgeColor = Color.clone(clippingPlanes.edgeColor, uniformMapProperties.clippingPlanesEdgeColor);\n      uniformMapProperties.clippingPlanesEdgeWidth = clippingPlanes.edgeWidth;\n    }\n\n    if (defined(tileProvider.uniformMap)) {\n      uniformMap = combine(uniformMap, tileProvider.uniformMap);\n    }\n\n    surfaceShaderSetOptions.numberOfDayTextures = numberOfDayTextures;\n    surfaceShaderSetOptions.applyBrightness = applyBrightness;\n    surfaceShaderSetOptions.applyContrast = applyContrast;\n    surfaceShaderSetOptions.applyHue = applyHue;\n    surfaceShaderSetOptions.applySaturation = applySaturation;\n    surfaceShaderSetOptions.applyGamma = applyGamma;\n    surfaceShaderSetOptions.applyAlpha = applyAlpha;\n    surfaceShaderSetOptions.applySplit = applySplit;\n    surfaceShaderSetOptions.enableFog = applyFog;\n    surfaceShaderSetOptions.enableClippingPlanes = clippingPlanesEnabled;\n    surfaceShaderSetOptions.clippingPlanes = clippingPlanes;\n    surfaceShaderSetOptions.hasImageryLayerCutout = applyCutout;\n    surfaceShaderSetOptions.colorCorrect = colorCorrect;\n    surfaceShaderSetOptions.highlightFillTile = highlightFillTile;\n    surfaceShaderSetOptions.colorToAlpha = applyColorToAlpha;\n    var count = surfaceTile.renderedMesh.indices.length;\n\n    if (!showSkirts) {\n      count = surfaceTile.renderedMesh.indexCountWithoutSkirts;\n    }\n\n    command.shaderProgram = tileProvider._surfaceShaderSet.getShaderProgram(surfaceShaderSetOptions);\n    command.castShadows = castShadows;\n    command.receiveShadows = receiveShadows;\n    command.renderState = renderState;\n    command.primitiveType = PrimitiveType.TRIANGLES;\n    command.vertexArray = surfaceTile.vertexArray || surfaceTile.fill.vertexArray;\n    command.count = count;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.GLOBE;\n\n    if (tileProvider._debug.wireframe) {\n      createWireframeVertexArrayIfNecessary(context, tileProvider, tile);\n\n      if (defined(surfaceTile.wireframeVertexArray)) {\n        command.vertexArray = surfaceTile.wireframeVertexArray;\n        command.primitiveType = PrimitiveType.LINES;\n        command.count = count * 2;\n      }\n    }\n\n    var boundingVolume = command.boundingVolume;\n    var orientedBoundingBox = command.orientedBoundingBox;\n\n    if (frameState.mode !== SceneMode.SCENE3D) {\n      var tileBoundingRegion = surfaceTile.tileBoundingRegion;\n      BoundingSphere.fromRectangleWithHeights2D(tile.rectangle, frameState.mapProjection, tileBoundingRegion.minimumHeight, tileBoundingRegion.maximumHeight, boundingVolume);\n      Cartesian3.fromElements(boundingVolume.center.z, boundingVolume.center.x, boundingVolume.center.y, boundingVolume.center);\n\n      if (frameState.mode === SceneMode.MORPHING) {\n        boundingVolume = BoundingSphere.union(mesh.boundingSphere3D, boundingVolume, boundingVolume);\n      }\n    } else {\n      command.boundingVolume = BoundingSphere.clone(mesh.boundingSphere3D, boundingVolume);\n      command.orientedBoundingBox = OrientedBoundingBox.clone(surfaceTile.orientedBoundingBox, orientedBoundingBox);\n    }\n\n    command.dirty = true;\n    frameState.commandList.push(command);\n    renderState = otherPassesRenderState;\n    initialColor = otherPassesInitialColor;\n  } while (imageryIndex < imageryLen);\n}\n\nexport default GlobeSurfaceTileProvider;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/GlobeSurfaceTileProvider.js"],"names":["BoundingSphere","BoxOutlineGeometry","Cartesian2","Cartesian3","Cartesian4","Cartographic","clone","Color","ColorGeometryInstanceAttribute","combine","defaultValue","defined","destroyObject","DeveloperError","Event","GeometryInstance","GeometryPipeline","IndexDatatype","Intersect","CesiumMath","Matrix4","OrientedBoundingBox","OrthographicFrustum","PrimitiveType","Rectangle","SphereOutlineGeometry","TerrainQuantization","Visibility","WebMercatorProjection","Buffer","BufferUsage","ContextLimits","DrawCommand","Pass","RenderState","VertexArray","BlendingState","ClippingPlaneCollection","DepthFunction","GlobeSurfaceTile","ImageryLayer","ImageryState","PerInstanceColorAppearance","Primitive","QuadtreeTileLoadState","SceneMode","ShadowMode","TerrainFillMesh","TerrainState","TileBoundingRegion","TileSelectionResult","GlobeSurfaceTileProvider","options","terrainProvider","imageryLayers","surfaceShaderSet","lightingFadeOutDistance","lightingFadeInDistance","hasWaterMask","oceanNormalMap","undefined","zoomedOutOceanSpecularIntensity","enableLighting","dynamicAtmosphereLighting","dynamicAtmosphereLightingFromSun","showGroundAtmosphere","shadows","RECEIVE_ONLY","fillHighlightColor","hueShift","saturationShift","brightnessShift","showSkirts","backFaceCulling","_quadtree","_terrainProvider","_imageryLayers","_surfaceShaderSet","_renderState","_blendRenderState","_disableCullingRenderState","_disableCullingBlendRenderState","_errorEvent","layerAdded","addEventListener","prototype","_onLayerAdded","layerRemoved","_onLayerRemoved","layerMoved","_onLayerMoved","layerShownOrHidden","_onLayerShownOrHidden","_imageryLayersUpdatedEvent","_layerOrderChanged","_tilesToRenderByTextureCount","_drawCommands","_uniformMaps","_usedDrawCommands","_vertexArraysToDestroy","_debug","wireframe","boundingSphereTile","_baseColor","_firstPassInitialColor","baseColor","_clippingPlanes","cartographicLimitRectangle","MAX_VALUE","_hasLoadedTilesThisFrame","_hasFillTilesThisFrame","Object","defineProperties","get","set","value","fromColor","quadtree","ready","length","imageryProvider","tilingScheme","errorEvent","imageryLayersUpdatedEvent","invalidateAllTiles","clippingPlanes","setOwner","sortTileImageryByLayerIndex","a","b","aImagery","loadingImagery","readyImagery","bImagery","imageryLayer","_layerIndex","update","frameState","_update","updateCredits","surface","creditDisplay","credit","addCredit","i","len","initialize","queueReprojectionCommands","forEachLoadedTile","tile","data","imagery","sort","vertexArraysToDestroy","j","_freeVertexArray","beginUpdate","tilesToRenderByTextureCount","tiles","enabled","endUpdate","fromCache","cull","depthTest","func","LESS","LESS_OR_EQUAL","blending","ALPHA_BLEND","rs","updateFillTiles","_tilesToRender","textureCountIndex","textureCountLength","tilesToRender","tileIndex","tileLength","tileBoundingRegion","addDrawCommandsForTile","minimumTerrainHeight","Math","min","minimumHeight","updateForPick","drawCommands","commandList","push","cancelReprojections","getLevelMaximumGeometricError","level","loadTile","surfaceTile","terrainOnly","terrainStateBefore","boundingVolumeSourceTile","_lastSelectionResult","CULLED_BUT_NEEDED","terrainState","processStateMachine","computeTileVisibility","occluders","boundingSphereScratch","rectangleIntersectionScratch","splitCartographicLimitRectangleScratch","rectangleCenterScratch","clipRectangleAntimeridian","tileRectangle","west","east","splitRectangle","tileCenter","center","longitude","PI","distance","computeDistanceToTile","_distance","fog","cameraUnderground","density","NONE","PARTIAL","cullingVolume","boundingVolume","orientedBoundingBox","renderedMesh","boundingSphere3D","clippedByBoundaries","clippedCartographicLimitRectangle","rectangle","areaLimitIntersection","simpleIntersection","equals","mode","SCENE3D","fromRectangleWithHeights2D","mapProjection","maximumHeight","fromElements","z","x","y","MORPHING","union","INTERSECTING","planeIntersection","computeIntersectionWithBoundingVolume","isClipped","INSIDE","OUTSIDE","intersection","computeVisibility","ortho3D","camera","frustum","occludeePointInScaledSpace","ellipsoid","isScaledSpacePointVisiblePossiblyUnderEllipsoid","canRefine","terrainData","childAvailable","getTileDataAvailable","readyImageryScratch","canRenderTraversalStack","canRenderWithoutLosingDetail","terrainReady","initialImageryState","READY","tileImagery","isReady","state","FAILED","INVALID","layerIndex","lastFrame","_lastSelectionFrameNumber","stack","southwestChild","southeastChild","northwestChild","northeastChild","descendant","pop","lastFrameSelectionResult","_lastSelectionResultFrame","RENDERED","descendantSurface","descendantImagery","descendantTileImagery","descendantLoadingImagery","descendantIsReady","descendantLayerIndex","REFINED","tileDirectionScratch","computeTileLoadPriority","obb","cameraPosition","positionWC","cameraDirection","directionWC","tileDirection","subtract","magnitude","EPSILON5","divideByScalar","dot","modifiedModelViewScratch","modifiedModelViewProjectionScratch","tileRectangleScratch","localizedCartographicLimitRectangleScratch","rtcScratch","centerEyeScratch","southwestScratch","northeastScratch","showTileThisFrame","readyTextureCount","tileImageryCollection","alpha","tileSet","vertexArray","debug","tilesRendered","texturesRendered","cornerPositionsScratch","computeOccludeePoint","tileProvider","result","ellipsoidalOccluder","_occluders","cornerPositions","fromRadians","south","north","computeHorizonCullingPointPossiblyUnderEllipsoid","heightSource","updateTileBoundingRegion","fromRectangle","max","cameraHeight","positionCartographic","height","distanceToMin","abs","distanceToMax","distanceToCamera","computeBoundingVolumes","mesh","_minimumHeight","_maximumHeight","terrainExaggeration","Number","NaN","ancestor","parent","ancestorSurfaceTile","ancestorMesh","ancestorTerrainData","isDestroyed","destroy","_tileProvider","getTileReadyCallback","tileImageriesToFree","layer","startIndex","endIndex","_createTileImagerySkeletons","freeResources","splice","index","show","that","tileImageryUpdatedEvent","_reload","_imageryCache","_loadedCallbacks","insertionPoint","LOADING","renderable","raiseEvent","numDestroyed","newIndex","oldIndex","scratchClippingPlaneMatrix","createTileUniformMap","globeSurfaceTileProvider","uniformMap","u_initialColor","properties","initialColor","u_fillHighlightColor","u_zoomedOutOceanSpecularIntensity","u_oceanNormalMap","u_lightingFadeDistance","lightingFadeDistance","u_nightFadeDistance","nightFadeDistance","u_center3D","center3D","u_tileRectangle","u_modifiedModelView","viewMatrix","context","uniformState","view","centerEye","multiplyByPoint","rtc","setTranslation","u_modifiedModelViewProjection","projectionMatrix","projection","multiply","u_dayTextures","dayTextures","u_dayTextureTranslationAndScale","dayTextureTranslationAndScale","u_dayTextureTexCoordsRectangle","dayTextureTexCoordsRectangle","u_dayTextureUseWebMercatorT","dayTextureUseWebMercatorT","u_dayTextureAlpha","dayTextureAlpha","u_dayTextureBrightness","dayTextureBrightness","u_dayTextureContrast","dayTextureContrast","u_dayTextureHue","dayTextureHue","u_dayTextureSaturation","dayTextureSaturation","u_dayTextureOneOverGamma","dayTextureOneOverGamma","u_dayIntensity","dayIntensity","u_southAndNorthLatitude","southAndNorthLatitude","u_southMercatorYAndOneOverHeight","southMercatorYAndOneOverHeight","u_waterMask","waterMask","u_waterMaskTranslationAndScale","waterMaskTranslationAndScale","u_minMaxHeight","minMaxHeight","u_scaleAndBias","scaleAndBias","u_dayTextureSplit","dayTextureSplit","u_dayTextureCutoutRectangles","dayTextureCutoutRectangles","u_clippingPlanes","texture","defaultTexture","u_cartographicLimitRectangle","localizedCartographicLimitRectangle","u_clippingPlanesMatrix","modelMatrix","IDENTITY","u_clippingPlanesEdgeStyle","style","clippingPlanesEdgeColor","clippingPlanesEdgeWidth","u_minimumBrightness","minimumBrightness","u_hsbShift","hsbShift","u_colorsToAlpha","colorsToAlpha","modifiedModelView","WHITE","createWireframeVertexArrayIfNecessary","provider","fill","wireframeVertexArray","createWireframeVertexArray","terrainMesh","indices","geometry","primitiveType","TRIANGLES","toWireframe","wireframeIndices","wireframeIndexBuffer","createIndexBuffer","typedArray","usage","STATIC_DRAW","indexDatatype","fromSizeInBytes","BYTES_PER_ELEMENT","attributes","_attributes","indexBuffer","getDebugOrientedBoundingBox","getDebugBoundingSphere","debugDestroyPrimitive","instanceOBB","fromDimensions","dimensions","instanceSphere","radius","previousVolume","primitive","createDebugPrimitive","instance","geometryInstances","appearance","translucent","flat","asynchronous","color","fromRotationTranslation","halfAxes","sphere","fromTranslation","multiplyByUniformScale","otherPassesInitialColor","surfaceShaderSetOptionsScratch","numberOfDayTextures","applyBrightness","applyContrast","applyHue","applySaturation","applyGamma","applyAlpha","applySplit","showReflectiveOcean","showOceanWaves","perFragmentGroundAtmosphere","hasVertexNormals","useWebMercatorProjection","enableFog","enableClippingPlanes","hasImageryLayerCutout","colorCorrect","colorToAlpha","credits","tileCredits","tileCreditIndex","tileCreditLength","maxTextures","maximumTextureImageUnits","waterMaskTexture","castShadows","receiveShadows","equalsEpsilon","EPSILON7","cameraDistance","SCENE2D","COLUMBUS_VIEW","fadeOutDistance","nightFadeOutDistance","maximumRadius","shadowState","shadowsEnabled","encoding","southLatitude","northLatitude","southMercatorY","oneOverMercatorHeight","southwest","project","northeast","w","quantization","BITS12","epsilon","pow","widthEpsilon","heightEpsilon","geodeticLatitudeToMercatorAngle","surfaceShaderSetOptions","imageryIndex","imageryLen","firstPassRenderState","otherPassesRenderState","renderState","command","owner","RED","uniformMapProperties","nightFadeInDistance","highlightFillTile","cartographicTileRectangle","inverseTileWidth","width","inverseTileHeight","applyFog","EPSILON3","applyCutout","applyColorToAlpha","useWebMercatorT","textureWebMercator","textureTranslationAndScale","_calculateTextureTranslationAndScale","textureCoordinateRectangle","brightness","DEFAULT_BRIGHTNESS","contrast","DEFAULT_CONTRAST","hue","DEFAULT_HUE","saturation","DEFAULT_SATURATION","gamma","DEFAULT_GAMMA","splitDirection","dayTextureCutoutRectangle","ZERO","cutoutRectangle","hasColorToAlpha","colorToAlphaThreshold","red","green","blue","creditIndex","creditLength","matrix","clippingPlanesEnabled","edgeColor","edgeWidth","count","indexCountWithoutSkirts","shaderProgram","getShaderProgram","pass","GLOBE","LINES","dirty"],"mappings":"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","sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport BoxOutlineGeometry from \"../Core/BoxOutlineGeometry.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport SphereOutlineGeometry from \"../Core/SphereOutlineGeometry.js\";\nimport TerrainQuantization from \"../Core/TerrainQuantization.js\";\nimport Visibility from \"../Core/Visibility.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport GlobeSurfaceTile from \"./GlobeSurfaceTile.js\";\nimport ImageryLayer from \"./ImageryLayer.js\";\nimport ImageryState from \"./ImageryState.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport QuadtreeTileLoadState from \"./QuadtreeTileLoadState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\nimport TerrainFillMesh from \"./TerrainFillMesh.js\";\nimport TerrainState from \"./TerrainState.js\";\nimport TileBoundingRegion from \"./TileBoundingRegion.js\";\nimport TileSelectionResult from \"./TileSelectionResult.js\";\n\n/**\n * Provides quadtree tiles representing the surface of the globe.  This type is intended to be used\n * with {@link QuadtreePrimitive}.\n *\n * @alias GlobeSurfaceTileProvider\n * @constructor\n *\n * @param {TerrainProvider} options.terrainProvider The terrain provider that describes the surface geometry.\n * @param {ImageryLayerCollection} option.imageryLayers The collection of imagery layers describing the shading of the surface.\n * @param {GlobeSurfaceShaderSet} options.surfaceShaderSet The set of shaders used to render the surface.\n *\n * @private\n */\nfunction GlobeSurfaceTileProvider(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options)) {\n    throw new DeveloperError(\"options is required.\");\n  }\n  if (!defined(options.terrainProvider)) {\n    throw new DeveloperError(\"options.terrainProvider is required.\");\n  } else if (!defined(options.imageryLayers)) {\n    throw new DeveloperError(\"options.imageryLayers is required.\");\n  } else if (!defined(options.surfaceShaderSet)) {\n    throw new DeveloperError(\"options.surfaceShaderSet is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this.lightingFadeOutDistance = 6500000.0;\n  this.lightingFadeInDistance = 9000000.0;\n  this.hasWaterMask = false;\n  this.oceanNormalMap = undefined;\n  this.zoomedOutOceanSpecularIntensity = 0.5;\n  this.enableLighting = false;\n  this.dynamicAtmosphereLighting = false;\n  this.dynamicAtmosphereLightingFromSun = false;\n  this.showGroundAtmosphere = false;\n  this.shadows = ShadowMode.RECEIVE_ONLY;\n\n  /**\n   * The color to use to highlight terrain fill tiles. If undefined, fill tiles are not\n   * highlighted at all. The alpha value is used to alpha blend with the tile's\n   * actual color. Because terrain fill tiles do not represent the actual terrain surface,\n   * it may be useful in some applications to indicate visually that they are not to be trusted.\n   * @type {Color}\n   * @default undefined\n   */\n  this.fillHighlightColor = undefined;\n\n  this.hueShift = 0.0;\n  this.saturationShift = 0.0;\n  this.brightnessShift = 0.0;\n\n  this.showSkirts = true;\n  this.backFaceCulling = true;\n\n  this._quadtree = undefined;\n  this._terrainProvider = options.terrainProvider;\n  this._imageryLayers = options.imageryLayers;\n  this._surfaceShaderSet = options.surfaceShaderSet;\n\n  this._renderState = undefined;\n  this._blendRenderState = undefined;\n  this._disableCullingRenderState = undefined;\n  this._disableCullingBlendRenderState = undefined;\n\n  this._errorEvent = new Event();\n\n  this._imageryLayers.layerAdded.addEventListener(\n    GlobeSurfaceTileProvider.prototype._onLayerAdded,\n    this\n  );\n  this._imageryLayers.layerRemoved.addEventListener(\n    GlobeSurfaceTileProvider.prototype._onLayerRemoved,\n    this\n  );\n  this._imageryLayers.layerMoved.addEventListener(\n    GlobeSurfaceTileProvider.prototype._onLayerMoved,\n    this\n  );\n  this._imageryLayers.layerShownOrHidden.addEventListener(\n    GlobeSurfaceTileProvider.prototype._onLayerShownOrHidden,\n    this\n  );\n  this._imageryLayersUpdatedEvent = new Event();\n\n  this._layerOrderChanged = false;\n\n  this._tilesToRenderByTextureCount = [];\n  this._drawCommands = [];\n  this._uniformMaps = [];\n  this._usedDrawCommands = 0;\n\n  this._vertexArraysToDestroy = [];\n\n  this._debug = {\n    wireframe: false,\n    boundingSphereTile: undefined,\n  };\n\n  this._baseColor = undefined;\n  this._firstPassInitialColor = undefined;\n  this.baseColor = new Color(0.0, 0.0, 0.5, 1.0);\n\n  /**\n   * A property specifying a {@link ClippingPlaneCollection} used to selectively disable rendering on the outside of each plane.\n   * @type {ClippingPlaneCollection}\n   * @private\n   */\n  this._clippingPlanes = undefined;\n\n  /**\n   * A property specifying a {@link Rectangle} used to selectively limit terrain and imagery rendering.\n   * @type {Rectangle}\n   */\n  this.cartographicLimitRectangle = Rectangle.clone(Rectangle.MAX_VALUE);\n\n  this._hasLoadedTilesThisFrame = false;\n  this._hasFillTilesThisFrame = false;\n}\n\nObject.defineProperties(GlobeSurfaceTileProvider.prototype, {\n  /**\n   * Gets or sets the color of the globe when no imagery is available.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Color}\n   */\n  baseColor: {\n    get: function () {\n      return this._baseColor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      this._baseColor = value;\n      this._firstPassInitialColor = Cartesian4.fromColor(\n        value,\n        this._firstPassInitialColor\n      );\n    },\n  },\n  /**\n   * Gets or sets the {@link QuadtreePrimitive} for which this provider is\n   * providing tiles.  This property may be undefined if the provider is not yet associated\n   * with a {@link QuadtreePrimitive}.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {QuadtreePrimitive}\n   */\n  quadtree: {\n    get: function () {\n      return this._quadtree;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      this._quadtree = value;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Boolean}\n   */\n  ready: {\n    get: function () {\n      return (\n        this._terrainProvider.ready &&\n        (this._imageryLayers.length === 0 ||\n          this._imageryLayers.get(0).imageryProvider.ready)\n      );\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by the provider.  This property should\n   * not be accessed before {@link GlobeSurfaceTileProvider#ready} returns true.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {TilingScheme}\n   */\n  tilingScheme: {\n    get: function () {\n      return this._terrainProvider.tilingScheme;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when the geometry provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when an imagery layer is added, shown, hidden, moved, or removed.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Event}\n   */\n  imageryLayersUpdatedEvent: {\n    get: function () {\n      return this._imageryLayersUpdatedEvent;\n    },\n  },\n\n  /**\n   * Gets or sets the terrain provider that describes the surface geometry.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {TerrainProvider}\n   */\n  terrainProvider: {\n    get: function () {\n      return this._terrainProvider;\n    },\n    set: function (terrainProvider) {\n      if (this._terrainProvider === terrainProvider) {\n        return;\n      }\n\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(terrainProvider)) {\n        throw new DeveloperError(\"terrainProvider is required.\");\n      }\n      //>>includeEnd('debug');\n\n      this._terrainProvider = terrainProvider;\n\n      if (defined(this._quadtree)) {\n        this._quadtree.invalidateAllTiles();\n      }\n    },\n  },\n  /**\n   * The {@link ClippingPlaneCollection} used to selectively disable rendering the tileset.\n   *\n   * @type {ClippingPlaneCollection}\n   *\n   * @private\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._clippingPlanes;\n    },\n    set: function (value) {\n      ClippingPlaneCollection.setOwner(value, this, \"_clippingPlanes\");\n    },\n  },\n});\n\nfunction sortTileImageryByLayerIndex(a, b) {\n  var aImagery = a.loadingImagery;\n  if (!defined(aImagery)) {\n    aImagery = a.readyImagery;\n  }\n\n  var bImagery = b.loadingImagery;\n  if (!defined(bImagery)) {\n    bImagery = b.readyImagery;\n  }\n\n  return aImagery.imageryLayer._layerIndex - bImagery.imageryLayer._layerIndex;\n}\n\n/**\n * Make updates to the tile provider that are not involved in rendering. Called before the render update cycle.\n */\nGlobeSurfaceTileProvider.prototype.update = function (frameState) {\n  // update collection: imagery indices, base layers, raise layer show/hide event\n  this._imageryLayers._update();\n};\n\nfunction updateCredits(surface, frameState) {\n  var creditDisplay = frameState.creditDisplay;\n  if (\n    surface._terrainProvider.ready &&\n    defined(surface._terrainProvider.credit)\n  ) {\n    creditDisplay.addCredit(surface._terrainProvider.credit);\n  }\n\n  var imageryLayers = surface._imageryLayers;\n  for (var i = 0, len = imageryLayers.length; i < len; ++i) {\n    var imageryProvider = imageryLayers.get(i).imageryProvider;\n    if (imageryProvider.ready && defined(imageryProvider.credit)) {\n      creditDisplay.addCredit(imageryProvider.credit);\n    }\n  }\n}\n\n/**\n * Called at the beginning of each render frame, before {@link QuadtreeTileProvider#showTileThisFrame}\n * @param {FrameState} frameState The frame state.\n */\nGlobeSurfaceTileProvider.prototype.initialize = function (frameState) {\n  // update each layer for texture reprojection.\n  this._imageryLayers.queueReprojectionCommands(frameState);\n\n  if (this._layerOrderChanged) {\n    this._layerOrderChanged = false;\n\n    // Sort the TileImagery instances in each tile by the layer index.\n    this._quadtree.forEachLoadedTile(function (tile) {\n      tile.data.imagery.sort(sortTileImageryByLayerIndex);\n    });\n  }\n\n  // Add credits for terrain and imagery providers.\n  updateCredits(this, frameState);\n\n  var vertexArraysToDestroy = this._vertexArraysToDestroy;\n  var length = vertexArraysToDestroy.length;\n  for (var j = 0; j < length; ++j) {\n    GlobeSurfaceTile._freeVertexArray(vertexArraysToDestroy[j]);\n  }\n  vertexArraysToDestroy.length = 0;\n};\n\n/**\n * Called at the beginning of the update cycle for each render frame, before {@link QuadtreeTileProvider#showTileThisFrame}\n * or any other functions.\n *\n * @param {FrameState} frameState The frame state.\n */\nGlobeSurfaceTileProvider.prototype.beginUpdate = function (frameState) {\n  var tilesToRenderByTextureCount = this._tilesToRenderByTextureCount;\n  for (var i = 0, len = tilesToRenderByTextureCount.length; i < len; ++i) {\n    var tiles = tilesToRenderByTextureCount[i];\n    if (defined(tiles)) {\n      tiles.length = 0;\n    }\n  }\n  // update clipping planes\n  var clippingPlanes = this._clippingPlanes;\n  if (defined(clippingPlanes) && clippingPlanes.enabled) {\n    clippingPlanes.update(frameState);\n  }\n  this._usedDrawCommands = 0;\n\n  this._hasLoadedTilesThisFrame = false;\n  this._hasFillTilesThisFrame = false;\n};\n\n/**\n * Called at the end of the update cycle for each render frame, after {@link QuadtreeTileProvider#showTileThisFrame}\n * and any other functions.\n *\n * @param {FrameState} frameState The frame state.\n */\nGlobeSurfaceTileProvider.prototype.endUpdate = function (frameState) {\n  if (!defined(this._renderState)) {\n    this._renderState = RenderState.fromCache({\n      // Write color and depth\n      cull: {\n        enabled: true,\n      },\n      depthTest: {\n        enabled: true,\n        func: DepthFunction.LESS,\n      },\n    });\n\n    this._blendRenderState = RenderState.fromCache({\n      // Write color and depth\n      cull: {\n        enabled: true,\n      },\n      depthTest: {\n        enabled: true,\n        func: DepthFunction.LESS_OR_EQUAL,\n      },\n      blending: BlendingState.ALPHA_BLEND,\n    });\n\n    var rs = clone(this._renderState, true);\n    rs.cull.enabled = false;\n    this._disableCullingRenderState = RenderState.fromCache(rs);\n\n    rs = clone(this._blendRenderState, true);\n    rs.cull.enabled = false;\n    this._disableCullingBlendRenderState = RenderState.fromCache(rs);\n  }\n\n  // If this frame has a mix of loaded and fill tiles, we need to propagate\n  // loaded heights to the fill tiles.\n  if (this._hasFillTilesThisFrame && this._hasLoadedTilesThisFrame) {\n    TerrainFillMesh.updateFillTiles(\n      this,\n      this._quadtree._tilesToRender,\n      frameState,\n      this._vertexArraysToDestroy\n    );\n  }\n\n  // Add the tile render commands to the command list, sorted by texture count.\n  var tilesToRenderByTextureCount = this._tilesToRenderByTextureCount;\n  for (\n    var textureCountIndex = 0,\n      textureCountLength = tilesToRenderByTextureCount.length;\n    textureCountIndex < textureCountLength;\n    ++textureCountIndex\n  ) {\n    var tilesToRender = tilesToRenderByTextureCount[textureCountIndex];\n    if (!defined(tilesToRender)) {\n      continue;\n    }\n\n    for (\n      var tileIndex = 0, tileLength = tilesToRender.length;\n      tileIndex < tileLength;\n      ++tileIndex\n    ) {\n      var tile = tilesToRender[tileIndex];\n      var tileBoundingRegion = tile.data.tileBoundingRegion;\n      addDrawCommandsForTile(this, tile, frameState);\n      frameState.minimumTerrainHeight = Math.min(\n        frameState.minimumTerrainHeight,\n        tileBoundingRegion.minimumHeight\n      );\n    }\n  }\n};\n\n/**\n * Adds draw commands for tiles rendered in the previous frame for a pick pass.\n *\n * @param {FrameState} frameState The frame state.\n */\nGlobeSurfaceTileProvider.prototype.updateForPick = function (frameState) {\n  // Add the tile pick commands from the tiles drawn last frame.\n  var drawCommands = this._drawCommands;\n  for (var i = 0, length = this._usedDrawCommands; i < length; ++i) {\n    frameState.commandList.push(drawCommands[i]);\n  }\n};\n\n/**\n * Cancels any imagery re-projections in the queue.\n */\nGlobeSurfaceTileProvider.prototype.cancelReprojections = function () {\n  this._imageryLayers.cancelReprojections();\n};\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level, in meters.  This function should not be\n * called before {@link GlobeSurfaceTileProvider#ready} returns true.\n *\n * @param {Number} level The tile level for which to get the maximum geometric error.\n * @returns {Number} The maximum geometric error in meters.\n */\nGlobeSurfaceTileProvider.prototype.getLevelMaximumGeometricError = function (\n  level\n) {\n  return this._terrainProvider.getLevelMaximumGeometricError(level);\n};\n\n/**\n * Loads, or continues loading, a given tile.  This function will continue to be called\n * until {@link QuadtreeTile#state} is no longer {@link QuadtreeTileLoadState#LOADING}.  This function should\n * not be called before {@link GlobeSurfaceTileProvider#ready} returns true.\n *\n * @param {FrameState} frameState The frame state.\n * @param {QuadtreeTile} tile The tile to load.\n *\n * @exception {DeveloperError} <code>loadTile</code> must not be called before the tile provider is ready.\n */\nGlobeSurfaceTileProvider.prototype.loadTile = function (frameState, tile) {\n  // We don't want to load imagery until we're certain that the terrain tiles are actually visible.\n  // So if our bounding volume isn't accurate because it came from another tile, load terrain only\n  // initially. If we load some terrain and suddenly have a more accurate bounding volume and the\n  // tile is _still_ visible, give the tile a chance to load imagery immediately rather than\n  // waiting for next frame.\n\n  var surfaceTile = tile.data;\n  var terrainOnly = true;\n  var terrainStateBefore;\n  if (defined(surfaceTile)) {\n    terrainOnly =\n      surfaceTile.boundingVolumeSourceTile !== tile ||\n      tile._lastSelectionResult === TileSelectionResult.CULLED_BUT_NEEDED;\n    terrainStateBefore = surfaceTile.terrainState;\n  }\n\n  GlobeSurfaceTile.processStateMachine(\n    tile,\n    frameState,\n    this.terrainProvider,\n    this._imageryLayers,\n    this._vertexArraysToDestroy,\n    terrainOnly\n  );\n\n  surfaceTile = tile.data;\n  if (terrainOnly && terrainStateBefore !== tile.data.terrainState) {\n    // Terrain state changed. If:\n    // a) The tile is visible, and\n    // b) The bounding volume is accurate (updated as a side effect of computing visibility)\n    // Then we'll load imagery, too.\n    if (\n      this.computeTileVisibility(tile, frameState, this.quadtree.occluders) &&\n      surfaceTile.boundingVolumeSourceTile === tile\n    ) {\n      terrainOnly = false;\n      GlobeSurfaceTile.processStateMachine(\n        tile,\n        frameState,\n        this.terrainProvider,\n        this._imageryLayers,\n        this._vertexArraysToDestroy,\n        terrainOnly\n      );\n    }\n  }\n};\n\nvar boundingSphereScratch = new BoundingSphere();\nvar rectangleIntersectionScratch = new Rectangle();\nvar splitCartographicLimitRectangleScratch = new Rectangle();\nvar rectangleCenterScratch = new Cartographic();\n\n// cartographicLimitRectangle may span the IDL, but tiles never will.\nfunction clipRectangleAntimeridian(tileRectangle, cartographicLimitRectangle) {\n  if (cartographicLimitRectangle.west < cartographicLimitRectangle.east) {\n    return cartographicLimitRectangle;\n  }\n  var splitRectangle = Rectangle.clone(\n    cartographicLimitRectangle,\n    splitCartographicLimitRectangleScratch\n  );\n  var tileCenter = Rectangle.center(tileRectangle, rectangleCenterScratch);\n  if (tileCenter.longitude > 0.0) {\n    splitRectangle.east = CesiumMath.PI;\n  } else {\n    splitRectangle.west = -CesiumMath.PI;\n  }\n  return splitRectangle;\n}\n\n/**\n * Determines the visibility of a given tile.  The tile may be fully visible, partially visible, or not\n * visible at all.  Tiles that are renderable and are at least partially visible will be shown by a call\n * to {@link GlobeSurfaceTileProvider#showTileThisFrame}.\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {FrameState} frameState The state information about the current frame.\n * @param {QuadtreeOccluders} occluders The objects that may occlude this tile.\n *\n * @returns {Visibility} The visibility of the tile.\n */\nGlobeSurfaceTileProvider.prototype.computeTileVisibility = function (\n  tile,\n  frameState,\n  occluders\n) {\n  var distance = this.computeDistanceToTile(tile, frameState);\n  tile._distance = distance;\n\n  if (frameState.fog.enabled && !frameState.cameraUnderground) {\n    if (CesiumMath.fog(distance, frameState.fog.density) >= 1.0) {\n      // Tile is completely in fog so return that it is not visible.\n      return Visibility.NONE;\n    }\n  }\n\n  var surfaceTile = tile.data;\n  var tileBoundingRegion = surfaceTile.tileBoundingRegion;\n\n  if (surfaceTile.boundingVolumeSourceTile === undefined) {\n    // We have no idea where this tile is, so let's just call it partially visible.\n    return Visibility.PARTIAL;\n  }\n\n  var cullingVolume = frameState.cullingVolume;\n  var boundingVolume = surfaceTile.orientedBoundingBox;\n\n  if (!defined(boundingVolume) && defined(surfaceTile.renderedMesh)) {\n    boundingVolume = surfaceTile.renderedMesh.boundingSphere3D;\n  }\n\n  // Check if the tile is outside the limit area in cartographic space\n  surfaceTile.clippedByBoundaries = false;\n  var clippedCartographicLimitRectangle = clipRectangleAntimeridian(\n    tile.rectangle,\n    this.cartographicLimitRectangle\n  );\n  var areaLimitIntersection = Rectangle.simpleIntersection(\n    clippedCartographicLimitRectangle,\n    tile.rectangle,\n    rectangleIntersectionScratch\n  );\n  if (!defined(areaLimitIntersection)) {\n    return Visibility.NONE;\n  }\n  if (!Rectangle.equals(areaLimitIntersection, tile.rectangle)) {\n    surfaceTile.clippedByBoundaries = true;\n  }\n\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    boundingVolume = boundingSphereScratch;\n    BoundingSphere.fromRectangleWithHeights2D(\n      tile.rectangle,\n      frameState.mapProjection,\n      tileBoundingRegion.minimumHeight,\n      tileBoundingRegion.maximumHeight,\n      boundingVolume\n    );\n    Cartesian3.fromElements(\n      boundingVolume.center.z,\n      boundingVolume.center.x,\n      boundingVolume.center.y,\n      boundingVolume.center\n    );\n\n    if (\n      frameState.mode === SceneMode.MORPHING &&\n      defined(surfaceTile.renderedMesh)\n    ) {\n      boundingVolume = BoundingSphere.union(\n        surfaceTile.renderedMesh.boundingSphere3D,\n        boundingVolume,\n        boundingVolume\n      );\n    }\n  }\n\n  if (!defined(boundingVolume)) {\n    return Intersect.INTERSECTING;\n  }\n\n  var clippingPlanes = this._clippingPlanes;\n  if (defined(clippingPlanes) && clippingPlanes.enabled) {\n    var planeIntersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n      boundingVolume\n    );\n    tile.isClipped = planeIntersection !== Intersect.INSIDE;\n    if (planeIntersection === Intersect.OUTSIDE) {\n      return Visibility.NONE;\n    }\n  }\n\n  var intersection = cullingVolume.computeVisibility(boundingVolume);\n  if (intersection === Intersect.OUTSIDE) {\n    return Visibility.NONE;\n  }\n\n  var ortho3D =\n    frameState.mode === SceneMode.SCENE3D &&\n    frameState.camera.frustum instanceof OrthographicFrustum;\n  if (\n    frameState.mode === SceneMode.SCENE3D &&\n    !ortho3D &&\n    defined(occluders) &&\n    !frameState.cameraUnderground\n  ) {\n    var occludeePointInScaledSpace = surfaceTile.occludeePointInScaledSpace;\n    if (!defined(occludeePointInScaledSpace)) {\n      return intersection;\n    }\n\n    if (\n      occluders.ellipsoid.isScaledSpacePointVisiblePossiblyUnderEllipsoid(\n        occludeePointInScaledSpace,\n        tileBoundingRegion.minimumHeight\n      )\n    ) {\n      return intersection;\n    }\n\n    return Visibility.NONE;\n  }\n\n  return intersection;\n};\n\n/**\n * Determines if the given tile can be refined\n * @param {QuadtreeTile} tile The tile to check.\n * @returns {boolean} True if the tile can be refined, false if it cannot.\n */\nGlobeSurfaceTileProvider.prototype.canRefine = function (tile) {\n  // Only allow refinement it we know whether or not the children of this tile exist.\n  // For a tileset with `availability`, we'll always be able to refine.\n  // We can ask for availability of _any_ child tile because we only need to confirm\n  // that we get a yes or no answer, it doesn't matter what the answer is.\n  if (defined(tile.data.terrainData)) {\n    return true;\n  }\n  var childAvailable = this.terrainProvider.getTileDataAvailable(\n    tile.x * 2,\n    tile.y * 2,\n    tile.level + 1\n  );\n  return childAvailable !== undefined;\n};\n\nvar readyImageryScratch = [];\nvar canRenderTraversalStack = [];\n\n/**\n * Determines if the given not-fully-loaded tile can be rendered without losing detail that\n * was present last frame as a result of rendering descendant tiles. This method will only be\n * called if this tile's descendants were rendered last frame. If the tile is fully loaded,\n * it is assumed that this method will return true and it will not be called.\n * @param {QuadtreeTile} tile The tile to check.\n * @returns {boolean} True if the tile can be rendered without losing detail.\n */\nGlobeSurfaceTileProvider.prototype.canRenderWithoutLosingDetail = function (\n  tile,\n  frameState\n) {\n  var surfaceTile = tile.data;\n\n  var readyImagery = readyImageryScratch;\n  readyImagery.length = this._imageryLayers.length;\n\n  var terrainReady = false;\n  var initialImageryState = false;\n  var imagery;\n\n  if (defined(surfaceTile)) {\n    // We can render even with non-ready terrain as long as all our rendered descendants\n    // are missing terrain geometry too. i.e. if we rendered fills for more detailed tiles\n    // last frame, it's ok to render a fill for this tile this frame.\n    terrainReady = surfaceTile.terrainState === TerrainState.READY;\n\n    // Initially assume all imagery layers are ready, unless imagery hasn't been initialized at all.\n    initialImageryState = true;\n\n    imagery = surfaceTile.imagery;\n  }\n\n  var i;\n  var len;\n\n  for (i = 0, len = readyImagery.length; i < len; ++i) {\n    readyImagery[i] = initialImageryState;\n  }\n\n  if (defined(imagery)) {\n    for (i = 0, len = imagery.length; i < len; ++i) {\n      var tileImagery = imagery[i];\n      var loadingImagery = tileImagery.loadingImagery;\n      var isReady =\n        !defined(loadingImagery) ||\n        loadingImagery.state === ImageryState.FAILED ||\n        loadingImagery.state === ImageryState.INVALID;\n      var layerIndex = (tileImagery.loadingImagery || tileImagery.readyImagery)\n        .imageryLayer._layerIndex;\n\n      // For a layer to be ready, all tiles belonging to that layer must be ready.\n      readyImagery[layerIndex] = isReady && readyImagery[layerIndex];\n    }\n  }\n\n  var lastFrame = this.quadtree._lastSelectionFrameNumber;\n\n  // Traverse the descendants looking for one with terrain or imagery that is not loaded on this tile.\n  var stack = canRenderTraversalStack;\n  stack.length = 0;\n  stack.push(\n    tile.southwestChild,\n    tile.southeastChild,\n    tile.northwestChild,\n    tile.northeastChild\n  );\n\n  while (stack.length > 0) {\n    var descendant = stack.pop();\n    var lastFrameSelectionResult =\n      descendant._lastSelectionResultFrame === lastFrame\n        ? descendant._lastSelectionResult\n        : TileSelectionResult.NONE;\n\n    if (lastFrameSelectionResult === TileSelectionResult.RENDERED) {\n      var descendantSurface = descendant.data;\n\n      if (!defined(descendantSurface)) {\n        // Descendant has no data, so it can't block rendering.\n        continue;\n      }\n\n      if (\n        !terrainReady &&\n        descendant.data.terrainState === TerrainState.READY\n      ) {\n        // Rendered descendant has real terrain, but we don't. Rendering is blocked.\n        return false;\n      }\n\n      var descendantImagery = descendant.data.imagery;\n      for (i = 0, len = descendantImagery.length; i < len; ++i) {\n        var descendantTileImagery = descendantImagery[i];\n        var descendantLoadingImagery = descendantTileImagery.loadingImagery;\n        var descendantIsReady =\n          !defined(descendantLoadingImagery) ||\n          descendantLoadingImagery.state === ImageryState.FAILED ||\n          descendantLoadingImagery.state === ImageryState.INVALID;\n        var descendantLayerIndex = (\n          descendantTileImagery.loadingImagery ||\n          descendantTileImagery.readyImagery\n        ).imageryLayer._layerIndex;\n\n        // If this imagery tile of a descendant is ready but the layer isn't ready in this tile,\n        // then rendering is blocked.\n        if (descendantIsReady && !readyImagery[descendantLayerIndex]) {\n          return false;\n        }\n      }\n    } else if (lastFrameSelectionResult === TileSelectionResult.REFINED) {\n      stack.push(\n        descendant.southwestChild,\n        descendant.southeastChild,\n        descendant.northwestChild,\n        descendant.northeastChild\n      );\n    }\n  }\n\n  return true;\n};\n\nvar tileDirectionScratch = new Cartesian3();\n\n/**\n * Determines the priority for loading this tile. Lower priority values load sooner.\n * @param {QuadtreeTile} tile The tile.\n * @param {FrameState} frameState The frame state.\n * @returns {Number} The load priority value.\n */\nGlobeSurfaceTileProvider.prototype.computeTileLoadPriority = function (\n  tile,\n  frameState\n) {\n  var surfaceTile = tile.data;\n  if (surfaceTile === undefined) {\n    return 0.0;\n  }\n\n  var obb = surfaceTile.orientedBoundingBox;\n  if (obb === undefined) {\n    return 0.0;\n  }\n\n  var cameraPosition = frameState.camera.positionWC;\n  var cameraDirection = frameState.camera.directionWC;\n  var tileDirection = Cartesian3.subtract(\n    obb.center,\n    cameraPosition,\n    tileDirectionScratch\n  );\n  var magnitude = Cartesian3.magnitude(tileDirection);\n  if (magnitude < CesiumMath.EPSILON5) {\n    return 0.0;\n  }\n  Cartesian3.divideByScalar(tileDirection, magnitude, tileDirection);\n  return (\n    (1.0 - Cartesian3.dot(tileDirection, cameraDirection)) * tile._distance\n  );\n};\n\nvar modifiedModelViewScratch = new Matrix4();\nvar modifiedModelViewProjectionScratch = new Matrix4();\nvar tileRectangleScratch = new Cartesian4();\nvar localizedCartographicLimitRectangleScratch = new Cartesian4();\nvar rtcScratch = new Cartesian3();\nvar centerEyeScratch = new Cartesian3();\nvar southwestScratch = new Cartesian3();\nvar northeastScratch = new Cartesian3();\n\n/**\n * Shows a specified tile in this frame.  The provider can cause the tile to be shown by adding\n * render commands to the commandList, or use any other method as appropriate.  The tile is not\n * expected to be visible next frame as well, unless this method is called next frame, too.\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {FrameState} frameState The state information of the current rendering frame.\n */\nGlobeSurfaceTileProvider.prototype.showTileThisFrame = function (\n  tile,\n  frameState\n) {\n  var readyTextureCount = 0;\n  var tileImageryCollection = tile.data.imagery;\n  for (var i = 0, len = tileImageryCollection.length; i < len; ++i) {\n    var tileImagery = tileImageryCollection[i];\n    if (\n      defined(tileImagery.readyImagery) &&\n      tileImagery.readyImagery.imageryLayer.alpha !== 0.0\n    ) {\n      ++readyTextureCount;\n    }\n  }\n\n  var tileSet = this._tilesToRenderByTextureCount[readyTextureCount];\n  if (!defined(tileSet)) {\n    tileSet = [];\n    this._tilesToRenderByTextureCount[readyTextureCount] = tileSet;\n  }\n\n  tileSet.push(tile);\n\n  var surfaceTile = tile.data;\n  if (!defined(surfaceTile.vertexArray)) {\n    this._hasFillTilesThisFrame = true;\n  } else {\n    this._hasLoadedTilesThisFrame = true;\n  }\n\n  var debug = this._debug;\n  ++debug.tilesRendered;\n  debug.texturesRendered += readyTextureCount;\n};\n\nvar cornerPositionsScratch = [\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n];\n\nfunction computeOccludeePoint(\n  tileProvider,\n  center,\n  rectangle,\n  minimumHeight,\n  maximumHeight,\n  result\n) {\n  var ellipsoidalOccluder = tileProvider.quadtree._occluders.ellipsoid;\n  var ellipsoid = ellipsoidalOccluder.ellipsoid;\n\n  var cornerPositions = cornerPositionsScratch;\n  Cartesian3.fromRadians(\n    rectangle.west,\n    rectangle.south,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[0]\n  );\n  Cartesian3.fromRadians(\n    rectangle.east,\n    rectangle.south,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[1]\n  );\n  Cartesian3.fromRadians(\n    rectangle.west,\n    rectangle.north,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[2]\n  );\n  Cartesian3.fromRadians(\n    rectangle.east,\n    rectangle.north,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[3]\n  );\n\n  return ellipsoidalOccluder.computeHorizonCullingPointPossiblyUnderEllipsoid(\n    center,\n    cornerPositions,\n    minimumHeight,\n    result\n  );\n}\n\n/**\n * Gets the distance from the camera to the closest point on the tile.  This is used for level-of-detail selection.\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {FrameState} frameState The state information of the current rendering frame.\n *\n * @returns {Number} The distance from the camera to the closest point on the tile, in meters.\n */\nGlobeSurfaceTileProvider.prototype.computeDistanceToTile = function (\n  tile,\n  frameState\n) {\n  // The distance should be:\n  // 1. the actual distance to the tight-fitting bounding volume, or\n  // 2. a distance that is equal to or greater than the actual distance to the tight-fitting bounding volume.\n  //\n  // When we don't know the min/max heights for a tile, but we do know the min/max of an ancestor tile, we can\n  // build a tight-fitting bounding volume horizontally, but not vertically. The min/max heights from the\n  // ancestor will likely form a volume that is much bigger than it needs to be. This means that the volume may\n  // be deemed to be much closer to the camera than it really is, causing us to select tiles that are too detailed.\n  // Loading too-detailed tiles is super expensive, so we don't want to do that. We don't know where the child\n  // tile really lies within the parent range of heights, but we _do_ know the child tile can't be any closer than\n  // the ancestor height surface (min or max) that is _farthest away_ from the camera. So if we compute distance\n  // based that conservative metric, we may end up loading tiles that are not detailed enough, but that's much\n  // better (faster) than loading tiles that are too detailed.\n\n  var heightSource = updateTileBoundingRegion(\n    tile,\n    this.terrainProvider,\n    frameState\n  );\n  var surfaceTile = tile.data;\n  var tileBoundingRegion = surfaceTile.tileBoundingRegion;\n\n  if (heightSource === undefined) {\n    // Can't find any min/max heights anywhere? Ok, let's just say the\n    // tile is really far away so we'll load and render it rather than\n    // refining.\n    return 9999999999.0;\n  } else if (surfaceTile.boundingVolumeSourceTile !== heightSource) {\n    // Heights are from a new source tile, so update the bounding volume.\n    surfaceTile.boundingVolumeSourceTile = heightSource;\n\n    var rectangle = tile.rectangle;\n    if (defined(rectangle)) {\n      surfaceTile.orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n        tile.rectangle,\n        tileBoundingRegion.minimumHeight,\n        tileBoundingRegion.maximumHeight,\n        tile.tilingScheme.ellipsoid,\n        surfaceTile.orientedBoundingBox\n      );\n\n      surfaceTile.occludeePointInScaledSpace = computeOccludeePoint(\n        this,\n        surfaceTile.orientedBoundingBox.center,\n        tile.rectangle,\n        tileBoundingRegion.minimumHeight,\n        tileBoundingRegion.maximumHeight,\n        surfaceTile.occludeePointInScaledSpace\n      );\n    }\n  }\n\n  var min = tileBoundingRegion.minimumHeight;\n  var max = tileBoundingRegion.maximumHeight;\n\n  if (surfaceTile.boundingVolumeSourceTile !== tile) {\n    var cameraHeight = frameState.camera.positionCartographic.height;\n    var distanceToMin = Math.abs(cameraHeight - min);\n    var distanceToMax = Math.abs(cameraHeight - max);\n    if (distanceToMin > distanceToMax) {\n      tileBoundingRegion.minimumHeight = min;\n      tileBoundingRegion.maximumHeight = min;\n    } else {\n      tileBoundingRegion.minimumHeight = max;\n      tileBoundingRegion.maximumHeight = max;\n    }\n  }\n\n  var result = tileBoundingRegion.distanceToCamera(frameState);\n\n  tileBoundingRegion.minimumHeight = min;\n  tileBoundingRegion.maximumHeight = max;\n\n  return result;\n};\n\nfunction updateTileBoundingRegion(tile, terrainProvider, frameState) {\n  var surfaceTile = tile.data;\n  if (surfaceTile === undefined) {\n    surfaceTile = tile.data = new GlobeSurfaceTile();\n  }\n\n  if (surfaceTile.tileBoundingRegion === undefined) {\n    surfaceTile.tileBoundingRegion = new TileBoundingRegion({\n      computeBoundingVolumes: false,\n      rectangle: tile.rectangle,\n      ellipsoid: tile.tilingScheme.ellipsoid,\n      minimumHeight: 0.0,\n      maximumHeight: 0.0,\n    });\n  }\n\n  var terrainData = surfaceTile.terrainData;\n  var mesh = surfaceTile.mesh;\n  var tileBoundingRegion = surfaceTile.tileBoundingRegion;\n\n  if (\n    mesh !== undefined &&\n    mesh.minimumHeight !== undefined &&\n    mesh.maximumHeight !== undefined\n  ) {\n    // We have tight-fitting min/max heights from the mesh.\n    tileBoundingRegion.minimumHeight = mesh.minimumHeight;\n    tileBoundingRegion.maximumHeight = mesh.maximumHeight;\n    return tile;\n  }\n\n  if (\n    terrainData !== undefined &&\n    terrainData._minimumHeight !== undefined &&\n    terrainData._maximumHeight !== undefined\n  ) {\n    // We have tight-fitting min/max heights from the terrain data.\n    tileBoundingRegion.minimumHeight =\n      terrainData._minimumHeight * frameState.terrainExaggeration;\n    tileBoundingRegion.maximumHeight =\n      terrainData._maximumHeight * frameState.terrainExaggeration;\n    return tile;\n  }\n\n  // No accurate min/max heights available, so we're stuck with min/max heights from an ancestor tile.\n  tileBoundingRegion.minimumHeight = Number.NaN;\n  tileBoundingRegion.maximumHeight = Number.NaN;\n\n  var ancestor = tile.parent;\n  while (ancestor !== undefined) {\n    var ancestorSurfaceTile = ancestor.data;\n    if (ancestorSurfaceTile !== undefined) {\n      var ancestorMesh = ancestorSurfaceTile.mesh;\n      if (\n        ancestorMesh !== undefined &&\n        ancestorMesh.minimumHeight !== undefined &&\n        ancestorMesh.maximumHeight !== undefined\n      ) {\n        tileBoundingRegion.minimumHeight = ancestorMesh.minimumHeight;\n        tileBoundingRegion.maximumHeight = ancestorMesh.maximumHeight;\n        return ancestor;\n      }\n\n      var ancestorTerrainData = ancestorSurfaceTile.terrainData;\n      if (\n        ancestorTerrainData !== undefined &&\n        ancestorTerrainData._minimumHeight !== undefined &&\n        ancestorTerrainData._maximumHeight !== undefined\n      ) {\n        tileBoundingRegion.minimumHeight =\n          ancestorTerrainData._minimumHeight * frameState.terrainExaggeration;\n        tileBoundingRegion.maximumHeight =\n          ancestorTerrainData._maximumHeight * frameState.terrainExaggeration;\n        return ancestor;\n      }\n    }\n    ancestor = ancestor.parent;\n  }\n\n  return undefined;\n}\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see GlobeSurfaceTileProvider#destroy\n */\nGlobeSurfaceTileProvider.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * provider = provider && provider();\n *\n * @see GlobeSurfaceTileProvider#isDestroyed\n */\nGlobeSurfaceTileProvider.prototype.destroy = function () {\n  this._tileProvider = this._tileProvider && this._tileProvider.destroy();\n  this._clippingPlanes = this._clippingPlanes && this._clippingPlanes.destroy();\n\n  return destroyObject(this);\n};\n\nfunction getTileReadyCallback(tileImageriesToFree, layer, terrainProvider) {\n  return function (tile) {\n    var tileImagery;\n    var imagery;\n    var startIndex = -1;\n    var tileImageryCollection = tile.data.imagery;\n    var length = tileImageryCollection.length;\n    var i;\n    for (i = 0; i < length; ++i) {\n      tileImagery = tileImageryCollection[i];\n      imagery = defaultValue(\n        tileImagery.readyImagery,\n        tileImagery.loadingImagery\n      );\n      if (imagery.imageryLayer === layer) {\n        startIndex = i;\n        break;\n      }\n    }\n\n    if (startIndex !== -1) {\n      var endIndex = startIndex + tileImageriesToFree;\n      tileImagery = tileImageryCollection[endIndex];\n      imagery = defined(tileImagery)\n        ? defaultValue(tileImagery.readyImagery, tileImagery.loadingImagery)\n        : undefined;\n      if (!defined(imagery) || imagery.imageryLayer !== layer) {\n        // Return false to keep the callback if we have to wait on the skeletons\n        // Return true to remove the callback if something went wrong\n        return !layer._createTileImagerySkeletons(\n          tile,\n          terrainProvider,\n          endIndex\n        );\n      }\n\n      for (i = startIndex; i < endIndex; ++i) {\n        tileImageryCollection[i].freeResources();\n      }\n\n      tileImageryCollection.splice(startIndex, tileImageriesToFree);\n    }\n\n    return true; // Everything is done, so remove the callback\n  };\n}\n\nGlobeSurfaceTileProvider.prototype._onLayerAdded = function (layer, index) {\n  if (layer.show) {\n    var terrainProvider = this._terrainProvider;\n\n    var that = this;\n    var imageryProvider = layer.imageryProvider;\n    var tileImageryUpdatedEvent = this._imageryLayersUpdatedEvent;\n    imageryProvider._reload = function () {\n      // Clear the layer's cache\n      layer._imageryCache = {};\n\n      that._quadtree.forEachLoadedTile(function (tile) {\n        // If this layer is still waiting to for the loaded callback, just return\n        if (defined(tile._loadedCallbacks[layer._layerIndex])) {\n          return;\n        }\n\n        var i;\n\n        // Figure out how many TileImageries we will need to remove and where to insert new ones\n        var tileImageryCollection = tile.data.imagery;\n        var length = tileImageryCollection.length;\n        var startIndex = -1;\n        var tileImageriesToFree = 0;\n        for (i = 0; i < length; ++i) {\n          var tileImagery = tileImageryCollection[i];\n          var imagery = defaultValue(\n            tileImagery.readyImagery,\n            tileImagery.loadingImagery\n          );\n          if (imagery.imageryLayer === layer) {\n            if (startIndex === -1) {\n              startIndex = i;\n            }\n\n            ++tileImageriesToFree;\n          } else if (startIndex !== -1) {\n            // iterated past the section of TileImageries belonging to this layer, no need to continue.\n            break;\n          }\n        }\n\n        if (startIndex === -1) {\n          return;\n        }\n\n        // Insert immediately after existing TileImageries\n        var insertionPoint = startIndex + tileImageriesToFree;\n\n        // Create new TileImageries for all loaded tiles\n        if (\n          layer._createTileImagerySkeletons(\n            tile,\n            terrainProvider,\n            insertionPoint\n          )\n        ) {\n          // Add callback to remove old TileImageries when the new TileImageries are ready\n          tile._loadedCallbacks[layer._layerIndex] = getTileReadyCallback(\n            tileImageriesToFree,\n            layer,\n            terrainProvider\n          );\n\n          tile.state = QuadtreeTileLoadState.LOADING;\n        }\n      });\n    };\n\n    // create TileImageries for this layer for all previously loaded tiles\n    this._quadtree.forEachLoadedTile(function (tile) {\n      if (layer._createTileImagerySkeletons(tile, terrainProvider)) {\n        tile.state = QuadtreeTileLoadState.LOADING;\n\n        // Tiles that are not currently being rendered need to load the new layer before they're renderable.\n        // We don't mark the rendered tiles non-renderable, though, because that would make the globe disappear.\n        if (\n          tile.level !== 0 &&\n          (tile._lastSelectionResultFrame !==\n            that.quadtree._lastSelectionFrameNumber ||\n            tile._lastSelectionResult !== TileSelectionResult.RENDERED)\n        ) {\n          tile.renderable = false;\n        }\n      }\n    });\n\n    this._layerOrderChanged = true;\n    tileImageryUpdatedEvent.raiseEvent();\n  }\n};\n\nGlobeSurfaceTileProvider.prototype._onLayerRemoved = function (layer, index) {\n  // destroy TileImagerys for this layer for all previously loaded tiles\n  this._quadtree.forEachLoadedTile(function (tile) {\n    var tileImageryCollection = tile.data.imagery;\n\n    var startIndex = -1;\n    var numDestroyed = 0;\n    for (var i = 0, len = tileImageryCollection.length; i < len; ++i) {\n      var tileImagery = tileImageryCollection[i];\n      var imagery = tileImagery.loadingImagery;\n      if (!defined(imagery)) {\n        imagery = tileImagery.readyImagery;\n      }\n      if (imagery.imageryLayer === layer) {\n        if (startIndex === -1) {\n          startIndex = i;\n        }\n\n        tileImagery.freeResources();\n        ++numDestroyed;\n      } else if (startIndex !== -1) {\n        // iterated past the section of TileImagerys belonging to this layer, no need to continue.\n        break;\n      }\n    }\n\n    if (startIndex !== -1) {\n      tileImageryCollection.splice(startIndex, numDestroyed);\n    }\n  });\n\n  if (defined(layer.imageryProvider)) {\n    layer.imageryProvider._reload = undefined;\n  }\n\n  this._imageryLayersUpdatedEvent.raiseEvent();\n};\n\nGlobeSurfaceTileProvider.prototype._onLayerMoved = function (\n  layer,\n  newIndex,\n  oldIndex\n) {\n  this._layerOrderChanged = true;\n  this._imageryLayersUpdatedEvent.raiseEvent();\n};\n\nGlobeSurfaceTileProvider.prototype._onLayerShownOrHidden = function (\n  layer,\n  index,\n  show\n) {\n  if (show) {\n    this._onLayerAdded(layer, index);\n  } else {\n    this._onLayerRemoved(layer, index);\n  }\n};\n\nvar scratchClippingPlaneMatrix = new Matrix4();\nfunction createTileUniformMap(frameState, globeSurfaceTileProvider) {\n  var uniformMap = {\n    u_initialColor: function () {\n      return this.properties.initialColor;\n    },\n    u_fillHighlightColor: function () {\n      return this.properties.fillHighlightColor;\n    },\n    u_zoomedOutOceanSpecularIntensity: function () {\n      return this.properties.zoomedOutOceanSpecularIntensity;\n    },\n    u_oceanNormalMap: function () {\n      return this.properties.oceanNormalMap;\n    },\n    u_lightingFadeDistance: function () {\n      return this.properties.lightingFadeDistance;\n    },\n    u_nightFadeDistance: function () {\n      return this.properties.nightFadeDistance;\n    },\n    u_center3D: function () {\n      return this.properties.center3D;\n    },\n    u_tileRectangle: function () {\n      return this.properties.tileRectangle;\n    },\n    u_modifiedModelView: function () {\n      var viewMatrix = frameState.context.uniformState.view;\n      var centerEye = Matrix4.multiplyByPoint(\n        viewMatrix,\n        this.properties.rtc,\n        centerEyeScratch\n      );\n      Matrix4.setTranslation(viewMatrix, centerEye, modifiedModelViewScratch);\n      return modifiedModelViewScratch;\n    },\n    u_modifiedModelViewProjection: function () {\n      var viewMatrix = frameState.context.uniformState.view;\n      var projectionMatrix = frameState.context.uniformState.projection;\n      var centerEye = Matrix4.multiplyByPoint(\n        viewMatrix,\n        this.properties.rtc,\n        centerEyeScratch\n      );\n      Matrix4.setTranslation(\n        viewMatrix,\n        centerEye,\n        modifiedModelViewProjectionScratch\n      );\n      Matrix4.multiply(\n        projectionMatrix,\n        modifiedModelViewProjectionScratch,\n        modifiedModelViewProjectionScratch\n      );\n      return modifiedModelViewProjectionScratch;\n    },\n    u_dayTextures: function () {\n      return this.properties.dayTextures;\n    },\n    u_dayTextureTranslationAndScale: function () {\n      return this.properties.dayTextureTranslationAndScale;\n    },\n    u_dayTextureTexCoordsRectangle: function () {\n      return this.properties.dayTextureTexCoordsRectangle;\n    },\n    u_dayTextureUseWebMercatorT: function () {\n      return this.properties.dayTextureUseWebMercatorT;\n    },\n    u_dayTextureAlpha: function () {\n      return this.properties.dayTextureAlpha;\n    },\n    u_dayTextureBrightness: function () {\n      return this.properties.dayTextureBrightness;\n    },\n    u_dayTextureContrast: function () {\n      return this.properties.dayTextureContrast;\n    },\n    u_dayTextureHue: function () {\n      return this.properties.dayTextureHue;\n    },\n    u_dayTextureSaturation: function () {\n      return this.properties.dayTextureSaturation;\n    },\n    u_dayTextureOneOverGamma: function () {\n      return this.properties.dayTextureOneOverGamma;\n    },\n    u_dayIntensity: function () {\n      return this.properties.dayIntensity;\n    },\n    u_southAndNorthLatitude: function () {\n      return this.properties.southAndNorthLatitude;\n    },\n    u_southMercatorYAndOneOverHeight: function () {\n      return this.properties.southMercatorYAndOneOverHeight;\n    },\n    u_waterMask: function () {\n      return this.properties.waterMask;\n    },\n    u_waterMaskTranslationAndScale: function () {\n      return this.properties.waterMaskTranslationAndScale;\n    },\n    u_minMaxHeight: function () {\n      return this.properties.minMaxHeight;\n    },\n    u_scaleAndBias: function () {\n      return this.properties.scaleAndBias;\n    },\n    u_dayTextureSplit: function () {\n      return this.properties.dayTextureSplit;\n    },\n    u_dayTextureCutoutRectangles: function () {\n      return this.properties.dayTextureCutoutRectangles;\n    },\n    u_clippingPlanes: function () {\n      var clippingPlanes = globeSurfaceTileProvider._clippingPlanes;\n      if (defined(clippingPlanes) && defined(clippingPlanes.texture)) {\n        // Check in case clippingPlanes hasn't been updated yet.\n        return clippingPlanes.texture;\n      }\n      return frameState.context.defaultTexture;\n    },\n    u_cartographicLimitRectangle: function () {\n      return this.properties.localizedCartographicLimitRectangle;\n    },\n    u_clippingPlanesMatrix: function () {\n      var clippingPlanes = globeSurfaceTileProvider._clippingPlanes;\n      return defined(clippingPlanes)\n        ? Matrix4.multiply(\n            frameState.context.uniformState.view,\n            clippingPlanes.modelMatrix,\n            scratchClippingPlaneMatrix\n          )\n        : Matrix4.IDENTITY;\n    },\n    u_clippingPlanesEdgeStyle: function () {\n      var style = this.properties.clippingPlanesEdgeColor;\n      style.alpha = this.properties.clippingPlanesEdgeWidth;\n      return style;\n    },\n    u_minimumBrightness: function () {\n      return frameState.fog.minimumBrightness;\n    },\n    u_hsbShift: function () {\n      return this.properties.hsbShift;\n    },\n    u_colorsToAlpha: function () {\n      return this.properties.colorsToAlpha;\n    },\n\n    // make a separate object so that changes to the properties are seen on\n    // derived commands that combine another uniform map with this one.\n    properties: {\n      initialColor: new Cartesian4(0.0, 0.0, 0.5, 1.0),\n      fillHighlightColor: new Color(0.0, 0.0, 0.0, 0.0),\n      zoomedOutOceanSpecularIntensity: 0.5,\n      oceanNormalMap: undefined,\n      lightingFadeDistance: new Cartesian2(6500000.0, 9000000.0),\n      nightFadeDistance: new Cartesian2(10000000.0, 40000000.0),\n      hsbShift: new Cartesian3(),\n\n      center3D: undefined,\n      rtc: new Cartesian3(),\n      modifiedModelView: new Matrix4(),\n      tileRectangle: new Cartesian4(),\n\n      dayTextures: [],\n      dayTextureTranslationAndScale: [],\n      dayTextureTexCoordsRectangle: [],\n      dayTextureUseWebMercatorT: [],\n      dayTextureAlpha: [],\n      dayTextureBrightness: [],\n      dayTextureContrast: [],\n      dayTextureHue: [],\n      dayTextureSaturation: [],\n      dayTextureOneOverGamma: [],\n      dayTextureSplit: [],\n      dayTextureCutoutRectangles: [],\n      dayIntensity: 0.0,\n      colorsToAlpha: [],\n\n      southAndNorthLatitude: new Cartesian2(),\n      southMercatorYAndOneOverHeight: new Cartesian2(),\n\n      waterMask: undefined,\n      waterMaskTranslationAndScale: new Cartesian4(),\n\n      minMaxHeight: new Cartesian2(),\n      scaleAndBias: new Matrix4(),\n      clippingPlanesEdgeColor: Color.clone(Color.WHITE),\n      clippingPlanesEdgeWidth: 0.0,\n\n      localizedCartographicLimitRectangle: new Cartesian4(),\n    },\n  };\n\n  return uniformMap;\n}\n\nfunction createWireframeVertexArrayIfNecessary(context, provider, tile) {\n  var surfaceTile = tile.data;\n\n  var mesh;\n  var vertexArray;\n\n  if (defined(surfaceTile.vertexArray)) {\n    mesh = surfaceTile.mesh;\n    vertexArray = surfaceTile.vertexArray;\n  } else if (\n    defined(surfaceTile.fill) &&\n    defined(surfaceTile.fill.vertexArray)\n  ) {\n    mesh = surfaceTile.fill.mesh;\n    vertexArray = surfaceTile.fill.vertexArray;\n  }\n\n  if (!defined(mesh) || !defined(vertexArray)) {\n    return;\n  }\n\n  if (defined(surfaceTile.wireframeVertexArray)) {\n    if (surfaceTile.wireframeVertexArray.mesh === mesh) {\n      return;\n    }\n\n    surfaceTile.wireframeVertexArray.destroy();\n    surfaceTile.wireframeVertexArray = undefined;\n  }\n\n  surfaceTile.wireframeVertexArray = createWireframeVertexArray(\n    context,\n    vertexArray,\n    mesh\n  );\n  surfaceTile.wireframeVertexArray.mesh = mesh;\n}\n\n/**\n * Creates a vertex array for wireframe rendering of a terrain tile.\n *\n * @private\n *\n * @param {Context} context The context in which to create the vertex array.\n * @param {VertexArray} vertexArray The existing, non-wireframe vertex array.  The new vertex array\n *                      will share vertex buffers with this existing one.\n * @param {TerrainMesh} terrainMesh The terrain mesh containing non-wireframe indices.\n * @returns {VertexArray} The vertex array for wireframe rendering.\n */\nfunction createWireframeVertexArray(context, vertexArray, terrainMesh) {\n  var indices = terrainMesh.indices;\n\n  var geometry = {\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  };\n\n  GeometryPipeline.toWireframe(geometry);\n\n  var wireframeIndices = geometry.indices;\n  var wireframeIndexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: wireframeIndices,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: IndexDatatype.fromSizeInBytes(\n      wireframeIndices.BYTES_PER_ELEMENT\n    ),\n  });\n  return new VertexArray({\n    context: context,\n    attributes: vertexArray._attributes,\n    indexBuffer: wireframeIndexBuffer,\n  });\n}\n\nvar getDebugOrientedBoundingBox;\nvar getDebugBoundingSphere;\nvar debugDestroyPrimitive;\n\n(function () {\n  var instanceOBB = new GeometryInstance({\n    geometry: BoxOutlineGeometry.fromDimensions({\n      dimensions: new Cartesian3(2.0, 2.0, 2.0),\n    }),\n  });\n  var instanceSphere = new GeometryInstance({\n    geometry: new SphereOutlineGeometry({ radius: 1.0 }),\n  });\n  var modelMatrix = new Matrix4();\n  var previousVolume;\n  var primitive;\n\n  function createDebugPrimitive(instance) {\n    return new Primitive({\n      geometryInstances: instance,\n      appearance: new PerInstanceColorAppearance({\n        translucent: false,\n        flat: true,\n      }),\n      asynchronous: false,\n    });\n  }\n\n  getDebugOrientedBoundingBox = function (obb, color) {\n    if (obb === previousVolume) {\n      return primitive;\n    }\n    debugDestroyPrimitive();\n\n    previousVolume = obb;\n    modelMatrix = Matrix4.fromRotationTranslation(\n      obb.halfAxes,\n      obb.center,\n      modelMatrix\n    );\n\n    instanceOBB.modelMatrix = modelMatrix;\n    instanceOBB.attributes.color = ColorGeometryInstanceAttribute.fromColor(\n      color\n    );\n\n    primitive = createDebugPrimitive(instanceOBB);\n    return primitive;\n  };\n\n  getDebugBoundingSphere = function (sphere, color) {\n    if (sphere === previousVolume) {\n      return primitive;\n    }\n    debugDestroyPrimitive();\n\n    previousVolume = sphere;\n    modelMatrix = Matrix4.fromTranslation(sphere.center, modelMatrix);\n    modelMatrix = Matrix4.multiplyByUniformScale(\n      modelMatrix,\n      sphere.radius,\n      modelMatrix\n    );\n\n    instanceSphere.modelMatrix = modelMatrix;\n    instanceSphere.attributes.color = ColorGeometryInstanceAttribute.fromColor(\n      color\n    );\n\n    primitive = createDebugPrimitive(instanceSphere);\n    return primitive;\n  };\n\n  debugDestroyPrimitive = function () {\n    if (defined(primitive)) {\n      primitive.destroy();\n      primitive = undefined;\n      previousVolume = undefined;\n    }\n  };\n})();\n\nvar otherPassesInitialColor = new Cartesian4(0.0, 0.0, 0.0, 0.0);\nvar surfaceShaderSetOptionsScratch = {\n  frameState: undefined,\n  surfaceTile: undefined,\n  numberOfDayTextures: undefined,\n  applyBrightness: undefined,\n  applyContrast: undefined,\n  applyHue: undefined,\n  applySaturation: undefined,\n  applyGamma: undefined,\n  applyAlpha: undefined,\n  applySplit: undefined,\n  showReflectiveOcean: undefined,\n  showOceanWaves: undefined,\n  enableLighting: undefined,\n  dynamicAtmosphereLighting: undefined,\n  dynamicAtmosphereLightingFromSun: undefined,\n  showGroundAtmosphere: undefined,\n  perFragmentGroundAtmosphere: undefined,\n  hasVertexNormals: undefined,\n  useWebMercatorProjection: undefined,\n  enableFog: undefined,\n  enableClippingPlanes: undefined,\n  clippingPlanes: undefined,\n  clippedByBoundaries: undefined,\n  hasImageryLayerCutout: undefined,\n  colorCorrect: undefined,\n  colorToAlpha: undefined,\n};\n\nfunction addDrawCommandsForTile(tileProvider, tile, frameState) {\n  var surfaceTile = tile.data;\n\n  if (!defined(surfaceTile.vertexArray)) {\n    if (surfaceTile.fill === undefined) {\n      // No fill was created for this tile, probably because this tile is not connected to\n      // any renderable tiles. So create a simple tile in the middle of the tile's possible\n      // height range.\n      surfaceTile.fill = new TerrainFillMesh(tile);\n    }\n    surfaceTile.fill.update(tileProvider, frameState);\n  }\n\n  var creditDisplay = frameState.creditDisplay;\n\n  var terrainData = surfaceTile.terrainData;\n  if (defined(terrainData) && defined(terrainData.credits)) {\n    var tileCredits = terrainData.credits;\n    for (\n      var tileCreditIndex = 0, tileCreditLength = tileCredits.length;\n      tileCreditIndex < tileCreditLength;\n      ++tileCreditIndex\n    ) {\n      creditDisplay.addCredit(tileCredits[tileCreditIndex]);\n    }\n  }\n\n  var maxTextures = ContextLimits.maximumTextureImageUnits;\n\n  var waterMaskTexture = surfaceTile.waterMaskTexture;\n  var waterMaskTranslationAndScale = surfaceTile.waterMaskTranslationAndScale;\n  if (!defined(waterMaskTexture) && defined(surfaceTile.fill)) {\n    waterMaskTexture = surfaceTile.fill.waterMaskTexture;\n    waterMaskTranslationAndScale =\n      surfaceTile.fill.waterMaskTranslationAndScale;\n  }\n\n  var cameraUnderground = frameState.cameraUnderground;\n\n  var showReflectiveOcean =\n    tileProvider.hasWaterMask && defined(waterMaskTexture);\n  var oceanNormalMap = tileProvider.oceanNormalMap;\n  var showOceanWaves = showReflectiveOcean && defined(oceanNormalMap);\n  var hasVertexNormals =\n    tileProvider.terrainProvider.ready &&\n    tileProvider.terrainProvider.hasVertexNormals;\n  var enableFog = frameState.fog.enabled && !cameraUnderground;\n  var showGroundAtmosphere = tileProvider.showGroundAtmosphere;\n  var castShadows = ShadowMode.castShadows(tileProvider.shadows);\n  var receiveShadows = ShadowMode.receiveShadows(tileProvider.shadows);\n\n  var hueShift = tileProvider.hueShift;\n  var saturationShift = tileProvider.saturationShift;\n  var brightnessShift = tileProvider.brightnessShift;\n\n  var colorCorrect = !(\n    CesiumMath.equalsEpsilon(hueShift, 0.0, CesiumMath.EPSILON7) &&\n    CesiumMath.equalsEpsilon(saturationShift, 0.0, CesiumMath.EPSILON7) &&\n    CesiumMath.equalsEpsilon(brightnessShift, 0.0, CesiumMath.EPSILON7)\n  );\n\n  var perFragmentGroundAtmosphere = false;\n  if (showGroundAtmosphere) {\n    var mode = frameState.mode;\n    var camera = frameState.camera;\n    var cameraDistance;\n    if (mode === SceneMode.SCENE2D || mode === SceneMode.COLUMBUS_VIEW) {\n      cameraDistance = camera.positionCartographic.height;\n    } else {\n      cameraDistance = Cartesian3.magnitude(camera.positionWC);\n    }\n    var fadeOutDistance = tileProvider.nightFadeOutDistance;\n    if (mode !== SceneMode.SCENE3D) {\n      fadeOutDistance -= frameState.mapProjection.ellipsoid.maximumRadius;\n    }\n    perFragmentGroundAtmosphere = cameraDistance > fadeOutDistance;\n  }\n\n  if (showReflectiveOcean) {\n    --maxTextures;\n  }\n  if (showOceanWaves) {\n    --maxTextures;\n  }\n\n  if (\n    defined(frameState.shadowState) &&\n    frameState.shadowState.shadowsEnabled\n  ) {\n    --maxTextures;\n  }\n  if (\n    defined(tileProvider.clippingPlanes) &&\n    tileProvider.clippingPlanes.enabled\n  ) {\n    --maxTextures;\n  }\n\n  var mesh = surfaceTile.renderedMesh;\n  var rtc = mesh.center;\n  var encoding = mesh.encoding;\n\n  // Not used in 3D.\n  var tileRectangle = tileRectangleScratch;\n\n  // Only used for Mercator projections.\n  var southLatitude = 0.0;\n  var northLatitude = 0.0;\n  var southMercatorY = 0.0;\n  var oneOverMercatorHeight = 0.0;\n\n  var useWebMercatorProjection = false;\n\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    var projection = frameState.mapProjection;\n    var southwest = projection.project(\n      Rectangle.southwest(tile.rectangle),\n      southwestScratch\n    );\n    var northeast = projection.project(\n      Rectangle.northeast(tile.rectangle),\n      northeastScratch\n    );\n\n    tileRectangle.x = southwest.x;\n    tileRectangle.y = southwest.y;\n    tileRectangle.z = northeast.x;\n    tileRectangle.w = northeast.y;\n\n    // In 2D and Columbus View, use the center of the tile for RTC rendering.\n    if (frameState.mode !== SceneMode.MORPHING) {\n      rtc = rtcScratch;\n      rtc.x = 0.0;\n      rtc.y = (tileRectangle.z + tileRectangle.x) * 0.5;\n      rtc.z = (tileRectangle.w + tileRectangle.y) * 0.5;\n      tileRectangle.x -= rtc.y;\n      tileRectangle.y -= rtc.z;\n      tileRectangle.z -= rtc.y;\n      tileRectangle.w -= rtc.z;\n    }\n\n    if (\n      frameState.mode === SceneMode.SCENE2D &&\n      encoding.quantization === TerrainQuantization.BITS12\n    ) {\n      // In 2D, the texture coordinates of the tile are interpolated over the rectangle to get the position in the vertex shader.\n      // When the texture coordinates are quantized, error is introduced. This can be seen through the 1px wide cracking\n      // between the quantized tiles in 2D. To compensate for the error, move the expand the rectangle in each direction by\n      // half the error amount.\n      var epsilon = (1.0 / (Math.pow(2.0, 12.0) - 1.0)) * 0.5;\n      var widthEpsilon = (tileRectangle.z - tileRectangle.x) * epsilon;\n      var heightEpsilon = (tileRectangle.w - tileRectangle.y) * epsilon;\n      tileRectangle.x -= widthEpsilon;\n      tileRectangle.y -= heightEpsilon;\n      tileRectangle.z += widthEpsilon;\n      tileRectangle.w += heightEpsilon;\n    }\n\n    if (projection instanceof WebMercatorProjection) {\n      southLatitude = tile.rectangle.south;\n      northLatitude = tile.rectangle.north;\n\n      southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(\n        southLatitude\n      );\n\n      oneOverMercatorHeight =\n        1.0 /\n        (WebMercatorProjection.geodeticLatitudeToMercatorAngle(northLatitude) -\n          southMercatorY);\n\n      useWebMercatorProjection = true;\n    }\n  }\n\n  var surfaceShaderSetOptions = surfaceShaderSetOptionsScratch;\n  surfaceShaderSetOptions.frameState = frameState;\n  surfaceShaderSetOptions.surfaceTile = surfaceTile;\n  surfaceShaderSetOptions.showReflectiveOcean = showReflectiveOcean;\n  surfaceShaderSetOptions.showOceanWaves = showOceanWaves;\n  surfaceShaderSetOptions.enableLighting = tileProvider.enableLighting;\n  surfaceShaderSetOptions.dynamicAtmosphereLighting =\n    tileProvider.dynamicAtmosphereLighting;\n  surfaceShaderSetOptions.dynamicAtmosphereLightingFromSun =\n    tileProvider.dynamicAtmosphereLightingFromSun;\n  surfaceShaderSetOptions.showGroundAtmosphere = showGroundAtmosphere;\n  surfaceShaderSetOptions.perFragmentGroundAtmosphere = perFragmentGroundAtmosphere;\n  surfaceShaderSetOptions.hasVertexNormals = hasVertexNormals;\n  surfaceShaderSetOptions.useWebMercatorProjection = useWebMercatorProjection;\n  surfaceShaderSetOptions.clippedByBoundaries = surfaceTile.clippedByBoundaries;\n\n  var tileImageryCollection = surfaceTile.imagery;\n  var imageryIndex = 0;\n  var imageryLen = tileImageryCollection.length;\n\n  var showSkirts = tileProvider.showSkirts && !cameraUnderground;\n  var backFaceCulling = tileProvider.backFaceCulling && !cameraUnderground;\n  var firstPassRenderState = backFaceCulling\n    ? tileProvider._renderState\n    : tileProvider._disableCullingRenderState;\n  var otherPassesRenderState = backFaceCulling\n    ? tileProvider._blendRenderState\n    : tileProvider._disableCullingBlendRenderState;\n  var renderState = firstPassRenderState;\n\n  var initialColor = tileProvider._firstPassInitialColor;\n\n  var context = frameState.context;\n\n  if (!defined(tileProvider._debug.boundingSphereTile)) {\n    debugDestroyPrimitive();\n  }\n\n  do {\n    var numberOfDayTextures = 0;\n\n    var command;\n    var uniformMap;\n\n    if (tileProvider._drawCommands.length <= tileProvider._usedDrawCommands) {\n      command = new DrawCommand();\n      command.owner = tile;\n      command.cull = false;\n      command.boundingVolume = new BoundingSphere();\n      command.orientedBoundingBox = undefined;\n\n      uniformMap = createTileUniformMap(frameState, tileProvider);\n\n      tileProvider._drawCommands.push(command);\n      tileProvider._uniformMaps.push(uniformMap);\n    } else {\n      command = tileProvider._drawCommands[tileProvider._usedDrawCommands];\n      uniformMap = tileProvider._uniformMaps[tileProvider._usedDrawCommands];\n    }\n\n    command.owner = tile;\n\n    ++tileProvider._usedDrawCommands;\n\n    if (tile === tileProvider._debug.boundingSphereTile) {\n      var obb = surfaceTile.orientedBoundingBox;\n      // If a debug primitive already exists for this tile, it will not be\n      // re-created, to avoid allocation every frame. If it were possible\n      // to have more than one selected tile, this would have to change.\n      if (defined(obb)) {\n        getDebugOrientedBoundingBox(obb, Color.RED).update(frameState);\n      } else if (defined(mesh) && defined(mesh.boundingSphere3D)) {\n        getDebugBoundingSphere(mesh.boundingSphere3D, Color.RED).update(\n          frameState\n        );\n      }\n    }\n\n    var uniformMapProperties = uniformMap.properties;\n    Cartesian4.clone(initialColor, uniformMapProperties.initialColor);\n    uniformMapProperties.oceanNormalMap = oceanNormalMap;\n    uniformMapProperties.lightingFadeDistance.x =\n      tileProvider.lightingFadeOutDistance;\n    uniformMapProperties.lightingFadeDistance.y =\n      tileProvider.lightingFadeInDistance;\n    uniformMapProperties.nightFadeDistance.x =\n      tileProvider.nightFadeOutDistance;\n    uniformMapProperties.nightFadeDistance.y = tileProvider.nightFadeInDistance;\n    uniformMapProperties.zoomedOutOceanSpecularIntensity =\n      tileProvider.zoomedOutOceanSpecularIntensity;\n\n    var highlightFillTile =\n      !defined(surfaceTile.vertexArray) &&\n      defined(tileProvider.fillHighlightColor) &&\n      tileProvider.fillHighlightColor.alpha > 0.0;\n    if (highlightFillTile) {\n      Color.clone(\n        tileProvider.fillHighlightColor,\n        uniformMapProperties.fillHighlightColor\n      );\n    }\n\n    uniformMapProperties.center3D = mesh.center;\n    Cartesian3.clone(rtc, uniformMapProperties.rtc);\n\n    Cartesian4.clone(tileRectangle, uniformMapProperties.tileRectangle);\n    uniformMapProperties.southAndNorthLatitude.x = southLatitude;\n    uniformMapProperties.southAndNorthLatitude.y = northLatitude;\n    uniformMapProperties.southMercatorYAndOneOverHeight.x = southMercatorY;\n    uniformMapProperties.southMercatorYAndOneOverHeight.y = oneOverMercatorHeight;\n\n    // Convert tile limiter rectangle from cartographic to texture space using the tileRectangle.\n    var localizedCartographicLimitRectangle = localizedCartographicLimitRectangleScratch;\n    var cartographicLimitRectangle = clipRectangleAntimeridian(\n      tile.rectangle,\n      tileProvider.cartographicLimitRectangle\n    );\n\n    Cartesian3.fromElements(\n      hueShift,\n      saturationShift,\n      brightnessShift,\n      uniformMapProperties.hsbShift\n    );\n\n    var cartographicTileRectangle = tile.rectangle;\n    var inverseTileWidth = 1.0 / cartographicTileRectangle.width;\n    var inverseTileHeight = 1.0 / cartographicTileRectangle.height;\n    localizedCartographicLimitRectangle.x =\n      (cartographicLimitRectangle.west - cartographicTileRectangle.west) *\n      inverseTileWidth;\n    localizedCartographicLimitRectangle.y =\n      (cartographicLimitRectangle.south - cartographicTileRectangle.south) *\n      inverseTileHeight;\n    localizedCartographicLimitRectangle.z =\n      (cartographicLimitRectangle.east - cartographicTileRectangle.west) *\n      inverseTileWidth;\n    localizedCartographicLimitRectangle.w =\n      (cartographicLimitRectangle.north - cartographicTileRectangle.south) *\n      inverseTileHeight;\n\n    Cartesian4.clone(\n      localizedCartographicLimitRectangle,\n      uniformMapProperties.localizedCartographicLimitRectangle\n    );\n\n    // For performance, use fog in the shader only when the tile is in fog.\n    var applyFog =\n      enableFog &&\n      CesiumMath.fog(tile._distance, frameState.fog.density) >\n        CesiumMath.EPSILON3;\n    colorCorrect = colorCorrect && (applyFog || showGroundAtmosphere);\n\n    var applyBrightness = false;\n    var applyContrast = false;\n    var applyHue = false;\n    var applySaturation = false;\n    var applyGamma = false;\n    var applyAlpha = false;\n    var applySplit = false;\n    var applyCutout = false;\n    var applyColorToAlpha = false;\n\n    while (numberOfDayTextures < maxTextures && imageryIndex < imageryLen) {\n      var tileImagery = tileImageryCollection[imageryIndex];\n      var imagery = tileImagery.readyImagery;\n      ++imageryIndex;\n\n      if (!defined(imagery) || imagery.imageryLayer.alpha === 0.0) {\n        continue;\n      }\n\n      var texture = tileImagery.useWebMercatorT\n        ? imagery.textureWebMercator\n        : imagery.texture;\n\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(texture)) {\n        // Our \"ready\" texture isn't actually ready.  This should never happen.\n        //\n        // Side note: It IS possible for it to not be in the READY ImageryState, though.\n        // This can happen when a single imagery tile is shared by two terrain tiles (common)\n        // and one of them (A) needs a geographic version of the tile because it is near the poles,\n        // and the other (B) does not.  B can and will transition the imagery tile to the READY state\n        // without reprojecting to geographic.  Then, later, A will deem that same tile not-ready-yet\n        // because it only has the Web Mercator texture, and flip it back to the TRANSITIONING state.\n        // The imagery tile won't be in the READY state anymore, but it's still READY enough for B's\n        // purposes.\n        throw new DeveloperError(\"readyImagery is not actually ready!\");\n      }\n      //>>includeEnd('debug');\n\n      var imageryLayer = imagery.imageryLayer;\n\n      if (!defined(tileImagery.textureTranslationAndScale)) {\n        tileImagery.textureTranslationAndScale = imageryLayer._calculateTextureTranslationAndScale(\n          tile,\n          tileImagery\n        );\n      }\n\n      uniformMapProperties.dayTextures[numberOfDayTextures] = texture;\n      uniformMapProperties.dayTextureTranslationAndScale[numberOfDayTextures] =\n        tileImagery.textureTranslationAndScale;\n      uniformMapProperties.dayTextureTexCoordsRectangle[numberOfDayTextures] =\n        tileImagery.textureCoordinateRectangle;\n      uniformMapProperties.dayTextureUseWebMercatorT[numberOfDayTextures] =\n        tileImagery.useWebMercatorT;\n\n      uniformMapProperties.dayTextureAlpha[numberOfDayTextures] =\n        imageryLayer.alpha;\n      applyAlpha =\n        applyAlpha ||\n        uniformMapProperties.dayTextureAlpha[numberOfDayTextures] !== 1.0;\n\n      uniformMapProperties.dayTextureBrightness[numberOfDayTextures] =\n        imageryLayer.brightness;\n      applyBrightness =\n        applyBrightness ||\n        uniformMapProperties.dayTextureBrightness[numberOfDayTextures] !==\n          ImageryLayer.DEFAULT_BRIGHTNESS;\n\n      uniformMapProperties.dayTextureContrast[numberOfDayTextures] =\n        imageryLayer.contrast;\n      applyContrast =\n        applyContrast ||\n        uniformMapProperties.dayTextureContrast[numberOfDayTextures] !==\n          ImageryLayer.DEFAULT_CONTRAST;\n\n      uniformMapProperties.dayTextureHue[numberOfDayTextures] =\n        imageryLayer.hue;\n      applyHue =\n        applyHue ||\n        uniformMapProperties.dayTextureHue[numberOfDayTextures] !==\n          ImageryLayer.DEFAULT_HUE;\n\n      uniformMapProperties.dayTextureSaturation[numberOfDayTextures] =\n        imageryLayer.saturation;\n      applySaturation =\n        applySaturation ||\n        uniformMapProperties.dayTextureSaturation[numberOfDayTextures] !==\n          ImageryLayer.DEFAULT_SATURATION;\n\n      uniformMapProperties.dayTextureOneOverGamma[numberOfDayTextures] =\n        1.0 / imageryLayer.gamma;\n      applyGamma =\n        applyGamma ||\n        uniformMapProperties.dayTextureOneOverGamma[numberOfDayTextures] !==\n          1.0 / ImageryLayer.DEFAULT_GAMMA;\n\n      uniformMapProperties.dayTextureSplit[numberOfDayTextures] =\n        imageryLayer.splitDirection;\n      applySplit =\n        applySplit ||\n        uniformMapProperties.dayTextureSplit[numberOfDayTextures] !== 0.0;\n\n      // Update cutout rectangle\n      var dayTextureCutoutRectangle =\n        uniformMapProperties.dayTextureCutoutRectangles[numberOfDayTextures];\n      if (!defined(dayTextureCutoutRectangle)) {\n        dayTextureCutoutRectangle = uniformMapProperties.dayTextureCutoutRectangles[\n          numberOfDayTextures\n        ] = new Cartesian4();\n      }\n\n      Cartesian4.clone(Cartesian4.ZERO, dayTextureCutoutRectangle);\n      if (defined(imageryLayer.cutoutRectangle)) {\n        var cutoutRectangle = clipRectangleAntimeridian(\n          cartographicTileRectangle,\n          imageryLayer.cutoutRectangle\n        );\n        var intersection = Rectangle.simpleIntersection(\n          cutoutRectangle,\n          cartographicTileRectangle,\n          rectangleIntersectionScratch\n        );\n        applyCutout = defined(intersection) || applyCutout;\n\n        dayTextureCutoutRectangle.x =\n          (cutoutRectangle.west - cartographicTileRectangle.west) *\n          inverseTileWidth;\n        dayTextureCutoutRectangle.y =\n          (cutoutRectangle.south - cartographicTileRectangle.south) *\n          inverseTileHeight;\n        dayTextureCutoutRectangle.z =\n          (cutoutRectangle.east - cartographicTileRectangle.west) *\n          inverseTileWidth;\n        dayTextureCutoutRectangle.w =\n          (cutoutRectangle.north - cartographicTileRectangle.south) *\n          inverseTileHeight;\n      }\n\n      // Update color to alpha\n      var colorToAlpha =\n        uniformMapProperties.colorsToAlpha[numberOfDayTextures];\n      if (!defined(colorToAlpha)) {\n        colorToAlpha = uniformMapProperties.colorsToAlpha[\n          numberOfDayTextures\n        ] = new Cartesian4();\n      }\n\n      var hasColorToAlpha =\n        defined(imageryLayer.colorToAlpha) &&\n        imageryLayer.colorToAlphaThreshold > 0.0;\n      applyColorToAlpha = applyColorToAlpha || hasColorToAlpha;\n\n      if (hasColorToAlpha) {\n        var color = imageryLayer.colorToAlpha;\n        colorToAlpha.x = color.red;\n        colorToAlpha.y = color.green;\n        colorToAlpha.z = color.blue;\n        colorToAlpha.w = imageryLayer.colorToAlphaThreshold;\n      } else {\n        colorToAlpha.w = -1.0;\n      }\n\n      if (defined(imagery.credits)) {\n        var credits = imagery.credits;\n        for (\n          var creditIndex = 0, creditLength = credits.length;\n          creditIndex < creditLength;\n          ++creditIndex\n        ) {\n          creditDisplay.addCredit(credits[creditIndex]);\n        }\n      }\n\n      ++numberOfDayTextures;\n    }\n\n    // trim texture array to the used length so we don't end up using old textures\n    // which might get destroyed eventually\n    uniformMapProperties.dayTextures.length = numberOfDayTextures;\n    uniformMapProperties.waterMask = waterMaskTexture;\n    Cartesian4.clone(\n      waterMaskTranslationAndScale,\n      uniformMapProperties.waterMaskTranslationAndScale\n    );\n\n    uniformMapProperties.minMaxHeight.x = encoding.minimumHeight;\n    uniformMapProperties.minMaxHeight.y = encoding.maximumHeight;\n    Matrix4.clone(encoding.matrix, uniformMapProperties.scaleAndBias);\n\n    // update clipping planes\n    var clippingPlanes = tileProvider._clippingPlanes;\n    var clippingPlanesEnabled =\n      defined(clippingPlanes) && clippingPlanes.enabled && tile.isClipped;\n    if (clippingPlanesEnabled) {\n      uniformMapProperties.clippingPlanesEdgeColor = Color.clone(\n        clippingPlanes.edgeColor,\n        uniformMapProperties.clippingPlanesEdgeColor\n      );\n      uniformMapProperties.clippingPlanesEdgeWidth = clippingPlanes.edgeWidth;\n    }\n\n    if (defined(tileProvider.uniformMap)) {\n      uniformMap = combine(uniformMap, tileProvider.uniformMap);\n    }\n\n    surfaceShaderSetOptions.numberOfDayTextures = numberOfDayTextures;\n    surfaceShaderSetOptions.applyBrightness = applyBrightness;\n    surfaceShaderSetOptions.applyContrast = applyContrast;\n    surfaceShaderSetOptions.applyHue = applyHue;\n    surfaceShaderSetOptions.applySaturation = applySaturation;\n    surfaceShaderSetOptions.applyGamma = applyGamma;\n    surfaceShaderSetOptions.applyAlpha = applyAlpha;\n    surfaceShaderSetOptions.applySplit = applySplit;\n    surfaceShaderSetOptions.enableFog = applyFog;\n    surfaceShaderSetOptions.enableClippingPlanes = clippingPlanesEnabled;\n    surfaceShaderSetOptions.clippingPlanes = clippingPlanes;\n    surfaceShaderSetOptions.hasImageryLayerCutout = applyCutout;\n    surfaceShaderSetOptions.colorCorrect = colorCorrect;\n    surfaceShaderSetOptions.highlightFillTile = highlightFillTile;\n    surfaceShaderSetOptions.colorToAlpha = applyColorToAlpha;\n\n    var count = surfaceTile.renderedMesh.indices.length;\n    if (!showSkirts) {\n      count = surfaceTile.renderedMesh.indexCountWithoutSkirts;\n    }\n\n    command.shaderProgram = tileProvider._surfaceShaderSet.getShaderProgram(\n      surfaceShaderSetOptions\n    );\n    command.castShadows = castShadows;\n    command.receiveShadows = receiveShadows;\n    command.renderState = renderState;\n    command.primitiveType = PrimitiveType.TRIANGLES;\n    command.vertexArray =\n      surfaceTile.vertexArray || surfaceTile.fill.vertexArray;\n    command.count = count;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.GLOBE;\n\n    if (tileProvider._debug.wireframe) {\n      createWireframeVertexArrayIfNecessary(context, tileProvider, tile);\n      if (defined(surfaceTile.wireframeVertexArray)) {\n        command.vertexArray = surfaceTile.wireframeVertexArray;\n        command.primitiveType = PrimitiveType.LINES;\n        command.count = count * 2;\n      }\n    }\n\n    var boundingVolume = command.boundingVolume;\n    var orientedBoundingBox = command.orientedBoundingBox;\n\n    if (frameState.mode !== SceneMode.SCENE3D) {\n      var tileBoundingRegion = surfaceTile.tileBoundingRegion;\n      BoundingSphere.fromRectangleWithHeights2D(\n        tile.rectangle,\n        frameState.mapProjection,\n        tileBoundingRegion.minimumHeight,\n        tileBoundingRegion.maximumHeight,\n        boundingVolume\n      );\n      Cartesian3.fromElements(\n        boundingVolume.center.z,\n        boundingVolume.center.x,\n        boundingVolume.center.y,\n        boundingVolume.center\n      );\n\n      if (frameState.mode === SceneMode.MORPHING) {\n        boundingVolume = BoundingSphere.union(\n          mesh.boundingSphere3D,\n          boundingVolume,\n          boundingVolume\n        );\n      }\n    } else {\n      command.boundingVolume = BoundingSphere.clone(\n        mesh.boundingSphere3D,\n        boundingVolume\n      );\n      command.orientedBoundingBox = OrientedBoundingBox.clone(\n        surfaceTile.orientedBoundingBox,\n        orientedBoundingBox\n      );\n    }\n\n    command.dirty = true;\n    frameState.commandList.push(command);\n\n    renderState = otherPassesRenderState;\n    initialColor = otherPassesInitialColor;\n  } while (imageryIndex < imageryLen);\n}\nexport default GlobeSurfaceTileProvider;\n"]},"metadata":{},"sourceType":"module"}