{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport GroundPrimitive from \"../Scene/GroundPrimitive.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport Primitive from \"../Scene/Primitive.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport MaterialProperty from \"./MaterialProperty.js\";\nimport Property from \"./Property.js\";\n/**\n * Defines the interface for a dynamic geometry updater.  A DynamicGeometryUpdater\n * is responsible for handling visualization of a specific type of geometry\n * that needs to be recomputed based on simulation time.\n * This object is never used directly by client code, but is instead created by\n * {@link GeometryUpdater} implementations which contain dynamic geometry.\n *\n * This type defines an interface and cannot be instantiated directly.\n *\n * @alias DynamicGeometryUpdater\n * @constructor\n * @private\n * @abstract\n */\n\nfunction DynamicGeometryUpdater(geometryUpdater, primitives, orderedGroundPrimitives) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"geometryUpdater\", geometryUpdater);\n  Check.defined(\"primitives\", primitives);\n  Check.defined(\"orderedGroundPrimitives\", orderedGroundPrimitives); //>>includeEnd('debug');\n\n  this._primitives = primitives;\n  this._orderedGroundPrimitives = orderedGroundPrimitives;\n  this._primitive = undefined;\n  this._outlinePrimitive = undefined;\n  this._geometryUpdater = geometryUpdater;\n  this._options = geometryUpdater._options;\n  this._entity = geometryUpdater._entity;\n  this._material = undefined;\n}\n\nDynamicGeometryUpdater.prototype._isHidden = function (entity, geometry, time) {\n  return !entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(geometry.show, time, true);\n};\n\nDynamicGeometryUpdater.prototype._setOptions = DeveloperError.throwInstantiationError;\n/**\n * Updates the geometry to the specified time.\n * @memberof DynamicGeometryUpdater\n * @function\n *\n * @param {JulianDate} time The current time.\n */\n\nDynamicGeometryUpdater.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time); //>>includeEnd('debug');\n\n  var geometryUpdater = this._geometryUpdater;\n  var onTerrain = geometryUpdater._onTerrain;\n  var primitives = this._primitives;\n  var orderedGroundPrimitives = this._orderedGroundPrimitives;\n\n  if (onTerrain) {\n    orderedGroundPrimitives.remove(this._primitive);\n  } else {\n    primitives.removeAndDestroy(this._primitive);\n    primitives.removeAndDestroy(this._outlinePrimitive);\n    this._outlinePrimitive = undefined;\n  }\n\n  this._primitive = undefined;\n  var entity = this._entity;\n  var geometry = entity[this._geometryUpdater._geometryPropertyName];\n\n  this._setOptions(entity, geometry, time);\n\n  if (this._isHidden(entity, geometry, time)) {\n    return;\n  }\n\n  var shadows = this._geometryUpdater.shadowsProperty.getValue(time);\n\n  var options = this._options;\n\n  if (!defined(geometry.fill) || geometry.fill.getValue(time)) {\n    var fillMaterialProperty = geometryUpdater.fillMaterialProperty;\n    var isColorAppearance = fillMaterialProperty instanceof ColorMaterialProperty;\n    var appearance;\n\n    var closed = geometryUpdater._getIsClosed(options);\n\n    if (isColorAppearance) {\n      appearance = new PerInstanceColorAppearance({\n        closed: closed,\n        flat: onTerrain && !geometryUpdater._supportsMaterialsforEntitiesOnTerrain\n      });\n    } else {\n      var material = MaterialProperty.getValue(time, fillMaterialProperty, this._material);\n      this._material = material;\n      appearance = new MaterialAppearance({\n        material: material,\n        translucent: material.isTranslucent(),\n        closed: closed\n      });\n    }\n\n    if (onTerrain) {\n      options.vertexFormat = PerInstanceColorAppearance.VERTEX_FORMAT;\n      this._primitive = orderedGroundPrimitives.add(new GroundPrimitive({\n        geometryInstances: this._geometryUpdater.createFillGeometryInstance(time),\n        appearance: appearance,\n        asynchronous: false,\n        shadows: shadows,\n        classificationType: this._geometryUpdater.classificationTypeProperty.getValue(time)\n      }), Property.getValueOrUndefined(this._geometryUpdater.zIndex, time));\n    } else {\n      options.vertexFormat = appearance.vertexFormat;\n\n      var fillInstance = this._geometryUpdater.createFillGeometryInstance(time);\n\n      if (isColorAppearance) {\n        appearance.translucent = fillInstance.attributes.color.value[3] !== 255;\n      }\n\n      this._primitive = primitives.add(new Primitive({\n        geometryInstances: fillInstance,\n        appearance: appearance,\n        asynchronous: false,\n        shadows: shadows\n      }));\n    }\n  }\n\n  if (!onTerrain && defined(geometry.outline) && geometry.outline.getValue(time)) {\n    var outlineInstance = this._geometryUpdater.createOutlineGeometryInstance(time);\n\n    var outlineWidth = Property.getValueOrDefault(geometry.outlineWidth, time, 1.0);\n    this._outlinePrimitive = primitives.add(new Primitive({\n      geometryInstances: outlineInstance,\n      appearance: new PerInstanceColorAppearance({\n        flat: true,\n        translucent: outlineInstance.attributes.color.value[3] !== 255,\n        renderState: {\n          lineWidth: geometryUpdater._scene.clampLineWidth(outlineWidth)\n        }\n      }),\n      asynchronous: false,\n      shadows: shadows\n    }));\n  }\n};\n/**\n * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n * The bounding sphere is in the fixed frame of the scene's globe.\n * @function\n *\n * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n *                       BoundingSphereState.PENDING if the result is still being computed, or\n *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n * @private\n */\n\n\nDynamicGeometryUpdater.prototype.getBoundingSphere = function (result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  } //>>includeEnd('debug');\n\n\n  var entity = this._entity;\n  var primitive = this._primitive;\n  var outlinePrimitive = this._outlinePrimitive;\n  var attributes; //Outline and Fill geometries have the same bounding sphere, so just use whichever one is defined and ready\n\n  if (defined(primitive) && primitive.show && primitive.ready) {\n    attributes = primitive.getGeometryInstanceAttributes(entity);\n\n    if (defined(attributes) && defined(attributes.boundingSphere)) {\n      BoundingSphere.clone(attributes.boundingSphere, result);\n      return BoundingSphereState.DONE;\n    }\n  }\n\n  if (defined(outlinePrimitive) && outlinePrimitive.show && outlinePrimitive.ready) {\n    attributes = outlinePrimitive.getGeometryInstanceAttributes(entity);\n\n    if (defined(attributes) && defined(attributes.boundingSphere)) {\n      BoundingSphere.clone(attributes.boundingSphere, result);\n      return BoundingSphereState.DONE;\n    }\n  }\n\n  if (defined(primitive) && !primitive.ready || defined(outlinePrimitive) && !outlinePrimitive.ready) {\n    return BoundingSphereState.PENDING;\n  }\n\n  return BoundingSphereState.FAILED;\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * @memberof DynamicGeometryUpdater\n * @function\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n */\n\n\nDynamicGeometryUpdater.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n * @memberof DynamicGeometryUpdater\n * @function\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\n\n\nDynamicGeometryUpdater.prototype.destroy = function () {\n  var primitives = this._primitives;\n  var orderedGroundPrimitives = this._orderedGroundPrimitives;\n\n  if (this._geometryUpdater._onTerrain) {\n    orderedGroundPrimitives.remove(this._primitive);\n  } else {\n    primitives.removeAndDestroy(this._primitive);\n  }\n\n  primitives.removeAndDestroy(this._outlinePrimitive);\n  destroyObject(this);\n};\n\nexport default DynamicGeometryUpdater;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/DataSources/DynamicGeometryUpdater.js"],"names":["BoundingSphere","Check","defined","destroyObject","DeveloperError","GroundPrimitive","MaterialAppearance","PerInstanceColorAppearance","Primitive","BoundingSphereState","ColorMaterialProperty","MaterialProperty","Property","DynamicGeometryUpdater","geometryUpdater","primitives","orderedGroundPrimitives","_primitives","_orderedGroundPrimitives","_primitive","undefined","_outlinePrimitive","_geometryUpdater","_options","_entity","_material","prototype","_isHidden","entity","geometry","time","isShowing","isAvailable","getValueOrDefault","show","_setOptions","throwInstantiationError","update","onTerrain","_onTerrain","remove","removeAndDestroy","_geometryPropertyName","shadows","shadowsProperty","getValue","options","fill","fillMaterialProperty","isColorAppearance","appearance","closed","_getIsClosed","flat","_supportsMaterialsforEntitiesOnTerrain","material","translucent","isTranslucent","vertexFormat","VERTEX_FORMAT","add","geometryInstances","createFillGeometryInstance","asynchronous","classificationType","classificationTypeProperty","getValueOrUndefined","zIndex","fillInstance","attributes","color","value","outline","outlineInstance","createOutlineGeometryInstance","outlineWidth","renderState","lineWidth","_scene","clampLineWidth","getBoundingSphere","result","primitive","outlinePrimitive","ready","getGeometryInstanceAttributes","boundingSphere","clone","DONE","PENDING","FAILED","isDestroyed","destroy"],"mappings":"AAAA,OAAOA,cAAP,MAA2B,2BAA3B;AACA,OAAOC,KAAP,MAAkB,kBAAlB;AACA,OAAOC,OAAP,MAAoB,oBAApB;AACA,OAAOC,aAAP,MAA0B,0BAA1B;AACA,OAAOC,cAAP,MAA2B,2BAA3B;AACA,OAAOC,eAAP,MAA4B,6BAA5B;AACA,OAAOC,kBAAP,MAA+B,gCAA/B;AACA,OAAOC,0BAAP,MAAuC,wCAAvC;AACA,OAAOC,SAAP,MAAsB,uBAAtB;AACA,OAAOC,mBAAP,MAAgC,0BAAhC;AACA,OAAOC,qBAAP,MAAkC,4BAAlC;AACA,OAAOC,gBAAP,MAA6B,uBAA7B;AACA,OAAOC,QAAP,MAAqB,eAArB;AAEA;;;;;;;;;;;;;;;AAcA,SAASC,sBAAT,CACEC,eADF,EAEEC,UAFF,EAGEC,uBAHF,EAIE;AACA;AACAf,EAAAA,KAAK,CAACC,OAAN,CAAc,iBAAd,EAAiCY,eAAjC;AACAb,EAAAA,KAAK,CAACC,OAAN,CAAc,YAAd,EAA4Ba,UAA5B;AACAd,EAAAA,KAAK,CAACC,OAAN,CAAc,yBAAd,EAAyCc,uBAAzC,EAJA,CAKA;;AAEA,OAAKC,WAAL,GAAmBF,UAAnB;AACA,OAAKG,wBAAL,GAAgCF,uBAAhC;AACA,OAAKG,UAAL,GAAkBC,SAAlB;AACA,OAAKC,iBAAL,GAAyBD,SAAzB;AACA,OAAKE,gBAAL,GAAwBR,eAAxB;AACA,OAAKS,QAAL,GAAgBT,eAAe,CAACS,QAAhC;AACA,OAAKC,OAAL,GAAeV,eAAe,CAACU,OAA/B;AACA,OAAKC,SAAL,GAAiBL,SAAjB;AACD;;AAEDP,sBAAsB,CAACa,SAAvB,CAAiCC,SAAjC,GAA6C,UAAUC,MAAV,EAAkBC,QAAlB,EAA4BC,IAA5B,EAAkC;AAC7E,SACE,CAACF,MAAM,CAACG,SAAR,IACA,CAACH,MAAM,CAACI,WAAP,CAAmBF,IAAnB,CADD,IAEA,CAAClB,QAAQ,CAACqB,iBAAT,CAA2BJ,QAAQ,CAACK,IAApC,EAA0CJ,IAA1C,EAAgD,IAAhD,CAHH;AAKD,CAND;;AAQAjB,sBAAsB,CAACa,SAAvB,CAAiCS,WAAjC,GACE/B,cAAc,CAACgC,uBADjB;AAGA;;;;;;;;AAOAvB,sBAAsB,CAACa,SAAvB,CAAiCW,MAAjC,GAA0C,UAAUP,IAAV,EAAgB;AACxD;AACA7B,EAAAA,KAAK,CAACC,OAAN,CAAc,MAAd,EAAsB4B,IAAtB,EAFwD,CAGxD;;AAEA,MAAIhB,eAAe,GAAG,KAAKQ,gBAA3B;AACA,MAAIgB,SAAS,GAAGxB,eAAe,CAACyB,UAAhC;AAEA,MAAIxB,UAAU,GAAG,KAAKE,WAAtB;AACA,MAAID,uBAAuB,GAAG,KAAKE,wBAAnC;;AACA,MAAIoB,SAAJ,EAAe;AACbtB,IAAAA,uBAAuB,CAACwB,MAAxB,CAA+B,KAAKrB,UAApC;AACD,GAFD,MAEO;AACLJ,IAAAA,UAAU,CAAC0B,gBAAX,CAA4B,KAAKtB,UAAjC;AACAJ,IAAAA,UAAU,CAAC0B,gBAAX,CAA4B,KAAKpB,iBAAjC;AACA,SAAKA,iBAAL,GAAyBD,SAAzB;AACD;;AACD,OAAKD,UAAL,GAAkBC,SAAlB;AAEA,MAAIQ,MAAM,GAAG,KAAKJ,OAAlB;AACA,MAAIK,QAAQ,GAAGD,MAAM,CAAC,KAAKN,gBAAL,CAAsBoB,qBAAvB,CAArB;;AACA,OAAKP,WAAL,CAAiBP,MAAjB,EAAyBC,QAAzB,EAAmCC,IAAnC;;AACA,MAAI,KAAKH,SAAL,CAAeC,MAAf,EAAuBC,QAAvB,EAAiCC,IAAjC,CAAJ,EAA4C;AAC1C;AACD;;AAED,MAAIa,OAAO,GAAG,KAAKrB,gBAAL,CAAsBsB,eAAtB,CAAsCC,QAAtC,CAA+Cf,IAA/C,CAAd;;AACA,MAAIgB,OAAO,GAAG,KAAKvB,QAAnB;;AACA,MAAI,CAACrB,OAAO,CAAC2B,QAAQ,CAACkB,IAAV,CAAR,IAA2BlB,QAAQ,CAACkB,IAAT,CAAcF,QAAd,CAAuBf,IAAvB,CAA/B,EAA6D;AAC3D,QAAIkB,oBAAoB,GAAGlC,eAAe,CAACkC,oBAA3C;AACA,QAAIC,iBAAiB,GACnBD,oBAAoB,YAAYtC,qBADlC;AAEA,QAAIwC,UAAJ;;AACA,QAAIC,MAAM,GAAGrC,eAAe,CAACsC,YAAhB,CAA6BN,OAA7B,CAAb;;AACA,QAAIG,iBAAJ,EAAuB;AACrBC,MAAAA,UAAU,GAAG,IAAI3C,0BAAJ,CAA+B;AAC1C4C,QAAAA,MAAM,EAAEA,MADkC;AAE1CE,QAAAA,IAAI,EACFf,SAAS,IAAI,CAACxB,eAAe,CAACwC;AAHU,OAA/B,CAAb;AAKD,KAND,MAMO;AACL,UAAIC,QAAQ,GAAG5C,gBAAgB,CAACkC,QAAjB,CACbf,IADa,EAEbkB,oBAFa,EAGb,KAAKvB,SAHQ,CAAf;AAKA,WAAKA,SAAL,GAAiB8B,QAAjB;AACAL,MAAAA,UAAU,GAAG,IAAI5C,kBAAJ,CAAuB;AAClCiD,QAAAA,QAAQ,EAAEA,QADwB;AAElCC,QAAAA,WAAW,EAAED,QAAQ,CAACE,aAAT,EAFqB;AAGlCN,QAAAA,MAAM,EAAEA;AAH0B,OAAvB,CAAb;AAKD;;AAED,QAAIb,SAAJ,EAAe;AACbQ,MAAAA,OAAO,CAACY,YAAR,GAAuBnD,0BAA0B,CAACoD,aAAlD;AACA,WAAKxC,UAAL,GAAkBH,uBAAuB,CAAC4C,GAAxB,CAChB,IAAIvD,eAAJ,CAAoB;AAClBwD,QAAAA,iBAAiB,EAAE,KAAKvC,gBAAL,CAAsBwC,0BAAtB,CACjBhC,IADiB,CADD;AAIlBoB,QAAAA,UAAU,EAAEA,UAJM;AAKlBa,QAAAA,YAAY,EAAE,KALI;AAMlBpB,QAAAA,OAAO,EAAEA,OANS;AAOlBqB,QAAAA,kBAAkB,EAAE,KAAK1C,gBAAL,CAAsB2C,0BAAtB,CAAiDpB,QAAjD,CAClBf,IADkB;AAPF,OAApB,CADgB,EAYhBlB,QAAQ,CAACsD,mBAAT,CAA6B,KAAK5C,gBAAL,CAAsB6C,MAAnD,EAA2DrC,IAA3D,CAZgB,CAAlB;AAcD,KAhBD,MAgBO;AACLgB,MAAAA,OAAO,CAACY,YAAR,GAAuBR,UAAU,CAACQ,YAAlC;;AAEA,UAAIU,YAAY,GAAG,KAAK9C,gBAAL,CAAsBwC,0BAAtB,CAAiDhC,IAAjD,CAAnB;;AAEA,UAAImB,iBAAJ,EAAuB;AACrBC,QAAAA,UAAU,CAACM,WAAX,GAAyBY,YAAY,CAACC,UAAb,CAAwBC,KAAxB,CAA8BC,KAA9B,CAAoC,CAApC,MAA2C,GAApE;AACD;;AAED,WAAKpD,UAAL,GAAkBJ,UAAU,CAAC6C,GAAX,CAChB,IAAIpD,SAAJ,CAAc;AACZqD,QAAAA,iBAAiB,EAAEO,YADP;AAEZlB,QAAAA,UAAU,EAAEA,UAFA;AAGZa,QAAAA,YAAY,EAAE,KAHF;AAIZpB,QAAAA,OAAO,EAAEA;AAJG,OAAd,CADgB,CAAlB;AAQD;AACF;;AAED,MACE,CAACL,SAAD,IACApC,OAAO,CAAC2B,QAAQ,CAAC2C,OAAV,CADP,IAEA3C,QAAQ,CAAC2C,OAAT,CAAiB3B,QAAjB,CAA0Bf,IAA1B,CAHF,EAIE;AACA,QAAI2C,eAAe,GAAG,KAAKnD,gBAAL,CAAsBoD,6BAAtB,CACpB5C,IADoB,CAAtB;;AAGA,QAAI6C,YAAY,GAAG/D,QAAQ,CAACqB,iBAAT,CACjBJ,QAAQ,CAAC8C,YADQ,EAEjB7C,IAFiB,EAGjB,GAHiB,CAAnB;AAMA,SAAKT,iBAAL,GAAyBN,UAAU,CAAC6C,GAAX,CACvB,IAAIpD,SAAJ,CAAc;AACZqD,MAAAA,iBAAiB,EAAEY,eADP;AAEZvB,MAAAA,UAAU,EAAE,IAAI3C,0BAAJ,CAA+B;AACzC8C,QAAAA,IAAI,EAAE,IADmC;AAEzCG,QAAAA,WAAW,EAAEiB,eAAe,CAACJ,UAAhB,CAA2BC,KAA3B,CAAiCC,KAAjC,CAAuC,CAAvC,MAA8C,GAFlB;AAGzCK,QAAAA,WAAW,EAAE;AACXC,UAAAA,SAAS,EAAE/D,eAAe,CAACgE,MAAhB,CAAuBC,cAAvB,CAAsCJ,YAAtC;AADA;AAH4B,OAA/B,CAFA;AASZZ,MAAAA,YAAY,EAAE,KATF;AAUZpB,MAAAA,OAAO,EAAEA;AAVG,KAAd,CADuB,CAAzB;AAcD;AACF,CAvHD;AAyHA;;;;;;;;;;;;;AAWA9B,sBAAsB,CAACa,SAAvB,CAAiCsD,iBAAjC,GAAqD,UAAUC,MAAV,EAAkB;AACrE;AACA,MAAI,CAAC/E,OAAO,CAAC+E,MAAD,CAAZ,EAAsB;AACpB,UAAM,IAAI7E,cAAJ,CAAmB,qBAAnB,CAAN;AACD,GAJoE,CAKrE;;;AACA,MAAIwB,MAAM,GAAG,KAAKJ,OAAlB;AACA,MAAI0D,SAAS,GAAG,KAAK/D,UAArB;AACA,MAAIgE,gBAAgB,GAAG,KAAK9D,iBAA5B;AAEA,MAAIgD,UAAJ,CAVqE,CAYrE;;AACA,MAAInE,OAAO,CAACgF,SAAD,CAAP,IAAsBA,SAAS,CAAChD,IAAhC,IAAwCgD,SAAS,CAACE,KAAtD,EAA6D;AAC3Df,IAAAA,UAAU,GAAGa,SAAS,CAACG,6BAAV,CAAwCzD,MAAxC,CAAb;;AACA,QAAI1B,OAAO,CAACmE,UAAD,CAAP,IAAuBnE,OAAO,CAACmE,UAAU,CAACiB,cAAZ,CAAlC,EAA+D;AAC7DtF,MAAAA,cAAc,CAACuF,KAAf,CAAqBlB,UAAU,CAACiB,cAAhC,EAAgDL,MAAhD;AACA,aAAOxE,mBAAmB,CAAC+E,IAA3B;AACD;AACF;;AAED,MACEtF,OAAO,CAACiF,gBAAD,CAAP,IACAA,gBAAgB,CAACjD,IADjB,IAEAiD,gBAAgB,CAACC,KAHnB,EAIE;AACAf,IAAAA,UAAU,GAAGc,gBAAgB,CAACE,6BAAjB,CAA+CzD,MAA/C,CAAb;;AACA,QAAI1B,OAAO,CAACmE,UAAD,CAAP,IAAuBnE,OAAO,CAACmE,UAAU,CAACiB,cAAZ,CAAlC,EAA+D;AAC7DtF,MAAAA,cAAc,CAACuF,KAAf,CAAqBlB,UAAU,CAACiB,cAAhC,EAAgDL,MAAhD;AACA,aAAOxE,mBAAmB,CAAC+E,IAA3B;AACD;AACF;;AAED,MACGtF,OAAO,CAACgF,SAAD,CAAP,IAAsB,CAACA,SAAS,CAACE,KAAlC,IACClF,OAAO,CAACiF,gBAAD,CAAP,IAA6B,CAACA,gBAAgB,CAACC,KAFlD,EAGE;AACA,WAAO3E,mBAAmB,CAACgF,OAA3B;AACD;;AAED,SAAOhF,mBAAmB,CAACiF,MAA3B;AACD,CAzCD;AA2CA;;;;;;;;;AAOA7E,sBAAsB,CAACa,SAAvB,CAAiCiE,WAAjC,GAA+C,YAAY;AACzD,SAAO,KAAP;AACD,CAFD;AAIA;;;;;;;;;AAOA9E,sBAAsB,CAACa,SAAvB,CAAiCkE,OAAjC,GAA2C,YAAY;AACrD,MAAI7E,UAAU,GAAG,KAAKE,WAAtB;AACA,MAAID,uBAAuB,GAAG,KAAKE,wBAAnC;;AACA,MAAI,KAAKI,gBAAL,CAAsBiB,UAA1B,EAAsC;AACpCvB,IAAAA,uBAAuB,CAACwB,MAAxB,CAA+B,KAAKrB,UAApC;AACD,GAFD,MAEO;AACLJ,IAAAA,UAAU,CAAC0B,gBAAX,CAA4B,KAAKtB,UAAjC;AACD;;AACDJ,EAAAA,UAAU,CAAC0B,gBAAX,CAA4B,KAAKpB,iBAAjC;AACAlB,EAAAA,aAAa,CAAC,IAAD,CAAb;AACD,CAVD;;AAWA,eAAeU,sBAAf","sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport GroundPrimitive from \"../Scene/GroundPrimitive.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport Primitive from \"../Scene/Primitive.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport MaterialProperty from \"./MaterialProperty.js\";\nimport Property from \"./Property.js\";\n\n/**\n * Defines the interface for a dynamic geometry updater.  A DynamicGeometryUpdater\n * is responsible for handling visualization of a specific type of geometry\n * that needs to be recomputed based on simulation time.\n * This object is never used directly by client code, but is instead created by\n * {@link GeometryUpdater} implementations which contain dynamic geometry.\n *\n * This type defines an interface and cannot be instantiated directly.\n *\n * @alias DynamicGeometryUpdater\n * @constructor\n * @private\n * @abstract\n */\nfunction DynamicGeometryUpdater(\n  geometryUpdater,\n  primitives,\n  orderedGroundPrimitives\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"geometryUpdater\", geometryUpdater);\n  Check.defined(\"primitives\", primitives);\n  Check.defined(\"orderedGroundPrimitives\", orderedGroundPrimitives);\n  //>>includeEnd('debug');\n\n  this._primitives = primitives;\n  this._orderedGroundPrimitives = orderedGroundPrimitives;\n  this._primitive = undefined;\n  this._outlinePrimitive = undefined;\n  this._geometryUpdater = geometryUpdater;\n  this._options = geometryUpdater._options;\n  this._entity = geometryUpdater._entity;\n  this._material = undefined;\n}\n\nDynamicGeometryUpdater.prototype._isHidden = function (entity, geometry, time) {\n  return (\n    !entity.isShowing ||\n    !entity.isAvailable(time) ||\n    !Property.getValueOrDefault(geometry.show, time, true)\n  );\n};\n\nDynamicGeometryUpdater.prototype._setOptions =\n  DeveloperError.throwInstantiationError;\n\n/**\n * Updates the geometry to the specified time.\n * @memberof DynamicGeometryUpdater\n * @function\n *\n * @param {JulianDate} time The current time.\n */\nDynamicGeometryUpdater.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  //>>includeEnd('debug');\n\n  var geometryUpdater = this._geometryUpdater;\n  var onTerrain = geometryUpdater._onTerrain;\n\n  var primitives = this._primitives;\n  var orderedGroundPrimitives = this._orderedGroundPrimitives;\n  if (onTerrain) {\n    orderedGroundPrimitives.remove(this._primitive);\n  } else {\n    primitives.removeAndDestroy(this._primitive);\n    primitives.removeAndDestroy(this._outlinePrimitive);\n    this._outlinePrimitive = undefined;\n  }\n  this._primitive = undefined;\n\n  var entity = this._entity;\n  var geometry = entity[this._geometryUpdater._geometryPropertyName];\n  this._setOptions(entity, geometry, time);\n  if (this._isHidden(entity, geometry, time)) {\n    return;\n  }\n\n  var shadows = this._geometryUpdater.shadowsProperty.getValue(time);\n  var options = this._options;\n  if (!defined(geometry.fill) || geometry.fill.getValue(time)) {\n    var fillMaterialProperty = geometryUpdater.fillMaterialProperty;\n    var isColorAppearance =\n      fillMaterialProperty instanceof ColorMaterialProperty;\n    var appearance;\n    var closed = geometryUpdater._getIsClosed(options);\n    if (isColorAppearance) {\n      appearance = new PerInstanceColorAppearance({\n        closed: closed,\n        flat:\n          onTerrain && !geometryUpdater._supportsMaterialsforEntitiesOnTerrain,\n      });\n    } else {\n      var material = MaterialProperty.getValue(\n        time,\n        fillMaterialProperty,\n        this._material\n      );\n      this._material = material;\n      appearance = new MaterialAppearance({\n        material: material,\n        translucent: material.isTranslucent(),\n        closed: closed,\n      });\n    }\n\n    if (onTerrain) {\n      options.vertexFormat = PerInstanceColorAppearance.VERTEX_FORMAT;\n      this._primitive = orderedGroundPrimitives.add(\n        new GroundPrimitive({\n          geometryInstances: this._geometryUpdater.createFillGeometryInstance(\n            time\n          ),\n          appearance: appearance,\n          asynchronous: false,\n          shadows: shadows,\n          classificationType: this._geometryUpdater.classificationTypeProperty.getValue(\n            time\n          ),\n        }),\n        Property.getValueOrUndefined(this._geometryUpdater.zIndex, time)\n      );\n    } else {\n      options.vertexFormat = appearance.vertexFormat;\n\n      var fillInstance = this._geometryUpdater.createFillGeometryInstance(time);\n\n      if (isColorAppearance) {\n        appearance.translucent = fillInstance.attributes.color.value[3] !== 255;\n      }\n\n      this._primitive = primitives.add(\n        new Primitive({\n          geometryInstances: fillInstance,\n          appearance: appearance,\n          asynchronous: false,\n          shadows: shadows,\n        })\n      );\n    }\n  }\n\n  if (\n    !onTerrain &&\n    defined(geometry.outline) &&\n    geometry.outline.getValue(time)\n  ) {\n    var outlineInstance = this._geometryUpdater.createOutlineGeometryInstance(\n      time\n    );\n    var outlineWidth = Property.getValueOrDefault(\n      geometry.outlineWidth,\n      time,\n      1.0\n    );\n\n    this._outlinePrimitive = primitives.add(\n      new Primitive({\n        geometryInstances: outlineInstance,\n        appearance: new PerInstanceColorAppearance({\n          flat: true,\n          translucent: outlineInstance.attributes.color.value[3] !== 255,\n          renderState: {\n            lineWidth: geometryUpdater._scene.clampLineWidth(outlineWidth),\n          },\n        }),\n        asynchronous: false,\n        shadows: shadows,\n      })\n    );\n  }\n};\n\n/**\n * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n * The bounding sphere is in the fixed frame of the scene's globe.\n * @function\n *\n * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n *                       BoundingSphereState.PENDING if the result is still being computed, or\n *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n * @private\n */\nDynamicGeometryUpdater.prototype.getBoundingSphere = function (result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n  var entity = this._entity;\n  var primitive = this._primitive;\n  var outlinePrimitive = this._outlinePrimitive;\n\n  var attributes;\n\n  //Outline and Fill geometries have the same bounding sphere, so just use whichever one is defined and ready\n  if (defined(primitive) && primitive.show && primitive.ready) {\n    attributes = primitive.getGeometryInstanceAttributes(entity);\n    if (defined(attributes) && defined(attributes.boundingSphere)) {\n      BoundingSphere.clone(attributes.boundingSphere, result);\n      return BoundingSphereState.DONE;\n    }\n  }\n\n  if (\n    defined(outlinePrimitive) &&\n    outlinePrimitive.show &&\n    outlinePrimitive.ready\n  ) {\n    attributes = outlinePrimitive.getGeometryInstanceAttributes(entity);\n    if (defined(attributes) && defined(attributes.boundingSphere)) {\n      BoundingSphere.clone(attributes.boundingSphere, result);\n      return BoundingSphereState.DONE;\n    }\n  }\n\n  if (\n    (defined(primitive) && !primitive.ready) ||\n    (defined(outlinePrimitive) && !outlinePrimitive.ready)\n  ) {\n    return BoundingSphereState.PENDING;\n  }\n\n  return BoundingSphereState.FAILED;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * @memberof DynamicGeometryUpdater\n * @function\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n */\nDynamicGeometryUpdater.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n * @memberof DynamicGeometryUpdater\n * @function\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nDynamicGeometryUpdater.prototype.destroy = function () {\n  var primitives = this._primitives;\n  var orderedGroundPrimitives = this._orderedGroundPrimitives;\n  if (this._geometryUpdater._onTerrain) {\n    orderedGroundPrimitives.remove(this._primitive);\n  } else {\n    primitives.removeAndDestroy(this._primitive);\n  }\n  primitives.removeAndDestroy(this._outlinePrimitive);\n  destroyObject(this);\n};\nexport default DynamicGeometryUpdater;\n"]},"metadata":{},"sourceType":"module"}