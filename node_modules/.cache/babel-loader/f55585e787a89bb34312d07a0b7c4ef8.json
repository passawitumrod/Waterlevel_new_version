{"ast":null,"code":"import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport Billboard from \"./Billboard.js\";\nimport HeightReference from \"./HeightReference.js\";\nimport HorizontalOrigin from \"./HorizontalOrigin.js\";\nimport LabelStyle from \"./LabelStyle.js\";\nimport SDFSettings from \"./SDFSettings.js\";\nimport VerticalOrigin from \"./VerticalOrigin.js\";\nvar fontInfoCache = {};\nvar fontInfoCacheLength = 0;\nvar fontInfoCacheMaxSize = 256;\nvar textTypes = Object.freeze({\n  LTR: 0,\n  RTL: 1,\n  WEAK: 2,\n  BRACKETS: 3\n});\n\nfunction rebindAllGlyphs(label) {\n  if (!label._rebindAllGlyphs && !label._repositionAllGlyphs) {\n    // only push label if it's not already been marked dirty\n    label._labelCollection._labelsToUpdate.push(label);\n  }\n\n  label._rebindAllGlyphs = true;\n}\n\nfunction repositionAllGlyphs(label) {\n  if (!label._rebindAllGlyphs && !label._repositionAllGlyphs) {\n    // only push label if it's not already been marked dirty\n    label._labelCollection._labelsToUpdate.push(label);\n  }\n\n  label._repositionAllGlyphs = true;\n}\n\nfunction getCSSValue(element, property) {\n  return document.defaultView.getComputedStyle(element, null).getPropertyValue(property);\n}\n\nfunction parseFont(label) {\n  var fontInfo = fontInfoCache[label._font];\n\n  if (!defined(fontInfo)) {\n    var div = document.createElement(\"div\");\n    div.style.position = \"absolute\";\n    div.style.opacity = 0;\n    div.style.font = label._font;\n    document.body.appendChild(div);\n    fontInfo = {\n      family: getCSSValue(div, \"font-family\"),\n      size: getCSSValue(div, \"font-size\").replace(\"px\", \"\"),\n      style: getCSSValue(div, \"font-style\"),\n      weight: getCSSValue(div, \"font-weight\")\n    };\n    document.body.removeChild(div);\n\n    if (fontInfoCacheLength < fontInfoCacheMaxSize) {\n      fontInfoCache[label._font] = fontInfo;\n      fontInfoCacheLength++;\n    }\n  }\n\n  label._fontFamily = fontInfo.family;\n  label._fontSize = fontInfo.size;\n  label._fontStyle = fontInfo.style;\n  label._fontWeight = fontInfo.weight;\n}\n/**\n * A Label draws viewport-aligned text positioned in the 3D scene.  This constructor\n * should not be used directly, instead create labels by calling {@link LabelCollection#add}.\n *\n * @alias Label\n * @internalConstructor\n * @class\n *\n * @exception {DeveloperError} translucencyByDistance.far must be greater than translucencyByDistance.near\n * @exception {DeveloperError} pixelOffsetScaleByDistance.far must be greater than pixelOffsetScaleByDistance.near\n * @exception {DeveloperError} distanceDisplayCondition.far must be greater than distanceDisplayCondition.near\n *\n * @see LabelCollection\n * @see LabelCollection#add\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Labels.html|Cesium Sandcastle Labels Demo}\n */\n\n\nfunction Label(options, labelCollection) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);\n\n  if (defined(options.disableDepthTestDistance) && options.disableDepthTestDistance < 0.0) {\n    throw new DeveloperError(\"disableDepthTestDistance must be greater than 0.0.\");\n  } //>>includeEnd('debug');\n\n\n  var translucencyByDistance = options.translucencyByDistance;\n  var pixelOffsetScaleByDistance = options.pixelOffsetScaleByDistance;\n  var scaleByDistance = options.scaleByDistance;\n  var distanceDisplayCondition = options.distanceDisplayCondition;\n\n  if (defined(translucencyByDistance)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (translucencyByDistance.far <= translucencyByDistance.near) {\n      throw new DeveloperError(\"translucencyByDistance.far must be greater than translucencyByDistance.near.\");\n    } //>>includeEnd('debug');\n\n\n    translucencyByDistance = NearFarScalar.clone(translucencyByDistance);\n  }\n\n  if (defined(pixelOffsetScaleByDistance)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (pixelOffsetScaleByDistance.far <= pixelOffsetScaleByDistance.near) {\n      throw new DeveloperError(\"pixelOffsetScaleByDistance.far must be greater than pixelOffsetScaleByDistance.near.\");\n    } //>>includeEnd('debug');\n\n\n    pixelOffsetScaleByDistance = NearFarScalar.clone(pixelOffsetScaleByDistance);\n  }\n\n  if (defined(scaleByDistance)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (scaleByDistance.far <= scaleByDistance.near) {\n      throw new DeveloperError(\"scaleByDistance.far must be greater than scaleByDistance.near.\");\n    } //>>includeEnd('debug');\n\n\n    scaleByDistance = NearFarScalar.clone(scaleByDistance);\n  }\n\n  if (defined(distanceDisplayCondition)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (distanceDisplayCondition.far <= distanceDisplayCondition.near) {\n      throw new DeveloperError(\"distanceDisplayCondition.far must be greater than distanceDisplayCondition.near.\");\n    } //>>includeEnd('debug');\n\n\n    distanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition);\n  }\n\n  this._renderedText = undefined;\n  this._text = undefined;\n  this._show = defaultValue(options.show, true);\n  this._font = defaultValue(options.font, \"30px sans-serif\");\n  this._fillColor = Color.clone(defaultValue(options.fillColor, Color.WHITE));\n  this._outlineColor = Color.clone(defaultValue(options.outlineColor, Color.BLACK));\n  this._outlineWidth = defaultValue(options.outlineWidth, 1.0);\n  this._showBackground = defaultValue(options.showBackground, false);\n  this._backgroundColor = defaultValue(options.backgroundColor, new Color(0.165, 0.165, 0.165, 0.8));\n  this._backgroundPadding = defaultValue(options.backgroundPadding, new Cartesian2(7, 5));\n  this._style = defaultValue(options.style, LabelStyle.FILL);\n  this._verticalOrigin = defaultValue(options.verticalOrigin, VerticalOrigin.BASELINE);\n  this._horizontalOrigin = defaultValue(options.horizontalOrigin, HorizontalOrigin.LEFT);\n  this._pixelOffset = Cartesian2.clone(defaultValue(options.pixelOffset, Cartesian2.ZERO));\n  this._eyeOffset = Cartesian3.clone(defaultValue(options.eyeOffset, Cartesian3.ZERO));\n  this._position = Cartesian3.clone(defaultValue(options.position, Cartesian3.ZERO));\n  this._scale = defaultValue(options.scale, 1.0);\n  this._id = options.id;\n  this._translucencyByDistance = translucencyByDistance;\n  this._pixelOffsetScaleByDistance = pixelOffsetScaleByDistance;\n  this._scaleByDistance = scaleByDistance;\n  this._heightReference = defaultValue(options.heightReference, HeightReference.NONE);\n  this._distanceDisplayCondition = distanceDisplayCondition;\n  this._disableDepthTestDistance = options.disableDepthTestDistance;\n  this._labelCollection = labelCollection;\n  this._glyphs = [];\n  this._backgroundBillboard = undefined;\n  this._batchIndex = undefined; // Used only by Vector3DTilePoints and BillboardCollection\n\n  this._rebindAllGlyphs = true;\n  this._repositionAllGlyphs = true;\n  this._actualClampedPosition = undefined;\n  this._removeCallbackFunc = undefined;\n  this._mode = undefined;\n  this._clusterShow = true;\n  this.text = defaultValue(options.text, \"\");\n  this._relativeSize = 1.0;\n  parseFont(this);\n\n  this._updateClamping();\n}\n\nObject.defineProperties(Label.prototype, {\n  /**\n   * Determines if this label will be shown.  Use this to hide or show a label, instead\n   * of removing it and re-adding it to the collection.\n   * @memberof Label.prototype\n   * @type {Boolean}\n   * @default true\n   */\n  show: {\n    get: function () {\n      return this._show;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      } //>>includeEnd('debug');\n\n\n      if (this._show !== value) {\n        this._show = value;\n        var glyphs = this._glyphs;\n\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var billboard = glyphs[i].billboard;\n\n          if (defined(billboard)) {\n            billboard.show = value;\n          }\n        }\n\n        var backgroundBillboard = this._backgroundBillboard;\n\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.show = value;\n        }\n      }\n    }\n  },\n\n  /**\n   * Gets or sets the Cartesian position of this label.\n   * @memberof Label.prototype\n   * @type {Cartesian3}\n   */\n  position: {\n    get: function () {\n      return this._position;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      } //>>includeEnd('debug');\n\n\n      var position = this._position;\n\n      if (!Cartesian3.equals(position, value)) {\n        Cartesian3.clone(value, position);\n        var glyphs = this._glyphs;\n\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var billboard = glyphs[i].billboard;\n\n          if (defined(billboard)) {\n            billboard.position = value;\n          }\n        }\n\n        var backgroundBillboard = this._backgroundBillboard;\n\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.position = value;\n        }\n\n        this._updateClamping();\n      }\n    }\n  },\n\n  /**\n   * Gets or sets the height reference of this billboard.\n   * @memberof Label.prototype\n   * @type {HeightReference}\n   * @default HeightReference.NONE\n   */\n  heightReference: {\n    get: function () {\n      return this._heightReference;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      } //>>includeEnd('debug');\n\n\n      if (value !== this._heightReference) {\n        this._heightReference = value;\n        var glyphs = this._glyphs;\n\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var billboard = glyphs[i].billboard;\n\n          if (defined(billboard)) {\n            billboard.heightReference = value;\n          }\n        }\n\n        var backgroundBillboard = this._backgroundBillboard;\n\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.heightReference = value;\n        }\n\n        repositionAllGlyphs(this);\n\n        this._updateClamping();\n      }\n    }\n  },\n\n  /**\n   * Gets or sets the text of this label.\n   * @memberof Label.prototype\n   * @type {String}\n   */\n  text: {\n    get: function () {\n      return this._text;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      } //>>includeEnd('debug');\n\n\n      if (this._text !== value) {\n        this._text = value;\n        this._renderedText = Label.enableRightToLeftDetection ? reverseRtl(value) : value;\n        rebindAllGlyphs(this);\n      }\n    }\n  },\n\n  /**\n   * Gets or sets the font used to draw this label. Fonts are specified using the same syntax as the CSS 'font' property.\n   * @memberof Label.prototype\n   * @type {String}\n   * @default '30px sans-serif'\n   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles|HTML canvas 2D context text styles}\n   */\n  font: {\n    get: function () {\n      return this._font;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      } //>>includeEnd('debug');\n\n\n      if (this._font !== value) {\n        this._font = value;\n        rebindAllGlyphs(this);\n        parseFont(this);\n      }\n    }\n  },\n\n  /**\n   * Gets or sets the fill color of this label.\n   * @memberof Label.prototype\n   * @type {Color}\n   * @default Color.WHITE\n   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles|HTML canvas 2D context fill and stroke styles}\n   */\n  fillColor: {\n    get: function () {\n      return this._fillColor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      } //>>includeEnd('debug');\n\n\n      var fillColor = this._fillColor;\n\n      if (!Color.equals(fillColor, value)) {\n        Color.clone(value, fillColor);\n        rebindAllGlyphs(this);\n      }\n    }\n  },\n\n  /**\n   * Gets or sets the outline color of this label.\n   * @memberof Label.prototype\n   * @type {Color}\n   * @default Color.BLACK\n   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles|HTML canvas 2D context fill and stroke styles}\n   */\n  outlineColor: {\n    get: function () {\n      return this._outlineColor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      } //>>includeEnd('debug');\n\n\n      var outlineColor = this._outlineColor;\n\n      if (!Color.equals(outlineColor, value)) {\n        Color.clone(value, outlineColor);\n        rebindAllGlyphs(this);\n      }\n    }\n  },\n\n  /**\n   * Gets or sets the outline width of this label.\n   * @memberof Label.prototype\n   * @type {Number}\n   * @default 1.0\n   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles|HTML canvas 2D context fill and stroke styles}\n   */\n  outlineWidth: {\n    get: function () {\n      return this._outlineWidth;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      } //>>includeEnd('debug');\n\n\n      if (this._outlineWidth !== value) {\n        this._outlineWidth = value;\n        rebindAllGlyphs(this);\n      }\n    }\n  },\n\n  /**\n   * Determines if a background behind this label will be shown.\n   * @memberof Label.prototype\n   * @default false\n   * @type {Boolean}\n   */\n  showBackground: {\n    get: function () {\n      return this._showBackground;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      } //>>includeEnd('debug');\n\n\n      if (this._showBackground !== value) {\n        this._showBackground = value;\n        rebindAllGlyphs(this);\n      }\n    }\n  },\n\n  /**\n   * Gets or sets the background color of this label.\n   * @memberof Label.prototype\n   * @type {Color}\n   * @default new Color(0.165, 0.165, 0.165, 0.8)\n   */\n  backgroundColor: {\n    get: function () {\n      return this._backgroundColor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      } //>>includeEnd('debug');\n\n\n      var backgroundColor = this._backgroundColor;\n\n      if (!Color.equals(backgroundColor, value)) {\n        Color.clone(value, backgroundColor);\n        var backgroundBillboard = this._backgroundBillboard;\n\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.color = backgroundColor;\n        }\n      }\n    }\n  },\n\n  /**\n   * Gets or sets the background padding, in pixels, of this label.  The <code>x</code> value\n   * controls horizontal padding, and the <code>y</code> value controls vertical padding.\n   * @memberof Label.prototype\n   * @type {Cartesian2}\n   * @default new Cartesian2(7, 5)\n   */\n  backgroundPadding: {\n    get: function () {\n      return this._backgroundPadding;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      } //>>includeEnd('debug');\n\n\n      var backgroundPadding = this._backgroundPadding;\n\n      if (!Cartesian2.equals(backgroundPadding, value)) {\n        Cartesian2.clone(value, backgroundPadding);\n        repositionAllGlyphs(this);\n      }\n    }\n  },\n\n  /**\n   * Gets or sets the style of this label.\n   * @memberof Label.prototype\n   * @type {LabelStyle}\n   * @default LabelStyle.FILL\n   */\n  style: {\n    get: function () {\n      return this._style;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      } //>>includeEnd('debug');\n\n\n      if (this._style !== value) {\n        this._style = value;\n        rebindAllGlyphs(this);\n      }\n    }\n  },\n\n  /**\n   * Gets or sets the pixel offset in screen space from the origin of this label.  This is commonly used\n   * to align multiple labels and billboards at the same position, e.g., an image and text.  The\n   * screen space origin is the top, left corner of the canvas; <code>x</code> increases from\n   * left to right, and <code>y</code> increases from top to bottom.\n   * <br /><br />\n   * <div align='center'>\n   * <table border='0' cellpadding='5'><tr>\n   * <td align='center'><code>default</code><br/><img src='Images/Label.setPixelOffset.default.png' width='250' height='188' /></td>\n   * <td align='center'><code>l.pixeloffset = new Cartesian2(25, 75);</code><br/><img src='Images/Label.setPixelOffset.x50y-25.png' width='250' height='188' /></td>\n   * </tr></table>\n   * The label's origin is indicated by the yellow point.\n   * </div>\n   * @memberof Label.prototype\n   * @type {Cartesian2}\n   * @default Cartesian2.ZERO\n   */\n  pixelOffset: {\n    get: function () {\n      return this._pixelOffset;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      } //>>includeEnd('debug');\n\n\n      var pixelOffset = this._pixelOffset;\n\n      if (!Cartesian2.equals(pixelOffset, value)) {\n        Cartesian2.clone(value, pixelOffset);\n        var glyphs = this._glyphs;\n\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var glyph = glyphs[i];\n\n          if (defined(glyph.billboard)) {\n            glyph.billboard.pixelOffset = value;\n          }\n        }\n\n        var backgroundBillboard = this._backgroundBillboard;\n\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.pixelOffset = value;\n        }\n      }\n    }\n  },\n\n  /**\n   * Gets or sets near and far translucency properties of a Label based on the Label's distance from the camera.\n   * A label's translucency will interpolate between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the label's translucency remains clamped to the nearest bound.  If undefined,\n   * translucencyByDistance will be disabled.\n   * @memberof Label.prototype\n   * @type {NearFarScalar}\n   *\n   * @example\n   * // Example 1.\n   * // Set a label's translucencyByDistance to 1.0 when the\n   * // camera is 1500 meters from the label and disappear as\n   * // the camera distance approaches 8.0e6 meters.\n   * text.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);\n   *\n   * @example\n   * // Example 2.\n   * // disable translucency by distance\n   * text.translucencyByDistance = undefined;\n   */\n  translucencyByDistance: {\n    get: function () {\n      return this._translucencyByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\"far distance must be greater than near distance.\");\n      } //>>includeEnd('debug');\n\n\n      var translucencyByDistance = this._translucencyByDistance;\n\n      if (!NearFarScalar.equals(translucencyByDistance, value)) {\n        this._translucencyByDistance = NearFarScalar.clone(value, translucencyByDistance);\n        var glyphs = this._glyphs;\n\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var glyph = glyphs[i];\n\n          if (defined(glyph.billboard)) {\n            glyph.billboard.translucencyByDistance = value;\n          }\n        }\n\n        var backgroundBillboard = this._backgroundBillboard;\n\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.translucencyByDistance = value;\n        }\n      }\n    }\n  },\n\n  /**\n   * Gets or sets near and far pixel offset scaling properties of a Label based on the Label's distance from the camera.\n   * A label's pixel offset will be scaled between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the label's pixel offset scaling remains clamped to the nearest bound.  If undefined,\n   * pixelOffsetScaleByDistance will be disabled.\n   * @memberof Label.prototype\n   * @type {NearFarScalar}\n   *\n   * @example\n   * // Example 1.\n   * // Set a label's pixel offset scale to 0.0 when the\n   * // camera is 1500 meters from the label and scale pixel offset to 10.0 pixels\n   * // in the y direction the camera distance approaches 8.0e6 meters.\n   * text.pixelOffset = new Cesium.Cartesian2(0.0, 1.0);\n   * text.pixelOffsetScaleByDistance = new Cesium.NearFarScalar(1.5e2, 0.0, 8.0e6, 10.0);\n   *\n   * @example\n   * // Example 2.\n   * // disable pixel offset by distance\n   * text.pixelOffsetScaleByDistance = undefined;\n   */\n  pixelOffsetScaleByDistance: {\n    get: function () {\n      return this._pixelOffsetScaleByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\"far distance must be greater than near distance.\");\n      } //>>includeEnd('debug');\n\n\n      var pixelOffsetScaleByDistance = this._pixelOffsetScaleByDistance;\n\n      if (!NearFarScalar.equals(pixelOffsetScaleByDistance, value)) {\n        this._pixelOffsetScaleByDistance = NearFarScalar.clone(value, pixelOffsetScaleByDistance);\n        var glyphs = this._glyphs;\n\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var glyph = glyphs[i];\n\n          if (defined(glyph.billboard)) {\n            glyph.billboard.pixelOffsetScaleByDistance = value;\n          }\n        }\n\n        var backgroundBillboard = this._backgroundBillboard;\n\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.pixelOffsetScaleByDistance = value;\n        }\n      }\n    }\n  },\n\n  /**\n   * Gets or sets near and far scaling properties of a Label based on the label's distance from the camera.\n   * A label's scale will interpolate between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the label's scale remains clamped to the nearest bound.  If undefined,\n   * scaleByDistance will be disabled.\n   * @memberof Label.prototype\n   * @type {NearFarScalar}\n   *\n   * @example\n   * // Example 1.\n   * // Set a label's scaleByDistance to scale by 1.5 when the\n   * // camera is 1500 meters from the label and disappear as\n   * // the camera distance approaches 8.0e6 meters.\n   * label.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 1.5, 8.0e6, 0.0);\n   *\n   * @example\n   * // Example 2.\n   * // disable scaling by distance\n   * label.scaleByDistance = undefined;\n   */\n  scaleByDistance: {\n    get: function () {\n      return this._scaleByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\"far distance must be greater than near distance.\");\n      } //>>includeEnd('debug');\n\n\n      var scaleByDistance = this._scaleByDistance;\n\n      if (!NearFarScalar.equals(scaleByDistance, value)) {\n        this._scaleByDistance = NearFarScalar.clone(value, scaleByDistance);\n        var glyphs = this._glyphs;\n\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var glyph = glyphs[i];\n\n          if (defined(glyph.billboard)) {\n            glyph.billboard.scaleByDistance = value;\n          }\n        }\n\n        var backgroundBillboard = this._backgroundBillboard;\n\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.scaleByDistance = value;\n        }\n      }\n    }\n  },\n\n  /**\n   * Gets and sets the 3D Cartesian offset applied to this label in eye coordinates.  Eye coordinates is a left-handed\n   * coordinate system, where <code>x</code> points towards the viewer's right, <code>y</code> points up, and\n   * <code>z</code> points into the screen.  Eye coordinates use the same scale as world and model coordinates,\n   * which is typically meters.\n   * <br /><br />\n   * An eye offset is commonly used to arrange multiple label or objects at the same position, e.g., to\n   * arrange a label above its corresponding 3D model.\n   * <br /><br />\n   * Below, the label is positioned at the center of the Earth but an eye offset makes it always\n   * appear on top of the Earth regardless of the viewer's or Earth's orientation.\n   * <br /><br />\n   * <div align='center'>\n   * <table border='0' cellpadding='5'><tr>\n   * <td align='center'><img src='Images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>\n   * <td align='center'><img src='Images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>\n   * </tr></table>\n   * <code>l.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code><br /><br />\n   * </div>\n   * @memberof Label.prototype\n   * @type {Cartesian3}\n   * @default Cartesian3.ZERO\n   */\n  eyeOffset: {\n    get: function () {\n      return this._eyeOffset;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      } //>>includeEnd('debug');\n\n\n      var eyeOffset = this._eyeOffset;\n\n      if (!Cartesian3.equals(eyeOffset, value)) {\n        Cartesian3.clone(value, eyeOffset);\n        var glyphs = this._glyphs;\n\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var glyph = glyphs[i];\n\n          if (defined(glyph.billboard)) {\n            glyph.billboard.eyeOffset = value;\n          }\n        }\n\n        var backgroundBillboard = this._backgroundBillboard;\n\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.eyeOffset = value;\n        }\n      }\n    }\n  },\n\n  /**\n   * Gets or sets the horizontal origin of this label, which determines if the label is drawn\n   * to the left, center, or right of its anchor position.\n   * <br /><br />\n   * <div align='center'>\n   * <img src='Images/Billboard.setHorizontalOrigin.png' width='648' height='196' /><br />\n   * </div>\n   * @memberof Label.prototype\n   * @type {HorizontalOrigin}\n   * @default HorizontalOrigin.LEFT\n   * @example\n   * // Use a top, right origin\n   * l.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;\n   * l.verticalOrigin = Cesium.VerticalOrigin.TOP;\n   */\n  horizontalOrigin: {\n    get: function () {\n      return this._horizontalOrigin;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      } //>>includeEnd('debug');\n\n\n      if (this._horizontalOrigin !== value) {\n        this._horizontalOrigin = value;\n        repositionAllGlyphs(this);\n      }\n    }\n  },\n\n  /**\n   * Gets or sets the vertical origin of this label, which determines if the label is\n   * to the above, below, or at the center of its anchor position.\n   * <br /><br />\n   * <div align='center'>\n   * <img src='Images/Billboard.setVerticalOrigin.png' width='695' height='175' /><br />\n   * </div>\n   * @memberof Label.prototype\n   * @type {VerticalOrigin}\n   * @default VerticalOrigin.BASELINE\n   * @example\n   * // Use a top, right origin\n   * l.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;\n   * l.verticalOrigin = Cesium.VerticalOrigin.TOP;\n   */\n  verticalOrigin: {\n    get: function () {\n      return this._verticalOrigin;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      } //>>includeEnd('debug');\n\n\n      if (this._verticalOrigin !== value) {\n        this._verticalOrigin = value;\n        var glyphs = this._glyphs;\n\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var glyph = glyphs[i];\n\n          if (defined(glyph.billboard)) {\n            glyph.billboard.verticalOrigin = value;\n          }\n        }\n\n        var backgroundBillboard = this._backgroundBillboard;\n\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.verticalOrigin = value;\n        }\n\n        repositionAllGlyphs(this);\n      }\n    }\n  },\n\n  /**\n   * Gets or sets the uniform scale that is multiplied with the label's size in pixels.\n   * A scale of <code>1.0</code> does not change the size of the label; a scale greater than\n   * <code>1.0</code> enlarges the label; a positive scale less than <code>1.0</code> shrinks\n   * the label.\n   * <br /><br />\n   * Applying a large scale value may pixelate the label.  To make text larger without pixelation,\n   * use a larger font size when calling {@link Label#font} instead.\n   * <br /><br />\n   * <div align='center'>\n   * <img src='Images/Label.setScale.png' width='400' height='300' /><br/>\n   * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,\n   * and <code>2.0</code>.\n   * </div>\n   * @memberof Label.prototype\n   * @type {Number}\n   * @default 1.0\n   */\n  scale: {\n    get: function () {\n      return this._scale;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      } //>>includeEnd('debug');\n\n\n      if (this._scale !== value) {\n        this._scale = value;\n        var glyphs = this._glyphs;\n\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var glyph = glyphs[i];\n\n          if (defined(glyph.billboard)) {\n            glyph.billboard.scale = value * this._relativeSize;\n          }\n        }\n\n        var backgroundBillboard = this._backgroundBillboard;\n\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.scale = value * this._relativeSize;\n        }\n\n        repositionAllGlyphs(this);\n      }\n    }\n  },\n\n  /**\n   * Gets the total scale of the label, which is the label's scale multiplied by the computed relative size\n   * of the desired font compared to the generated glyph size.\n   * @memberof Label.prototype\n   * @type {Number}\n   * @default 1.0\n   */\n  totalScale: {\n    get: function () {\n      return this._scale * this._relativeSize;\n    }\n  },\n\n  /**\n   * Gets or sets the condition specifying at what distance from the camera that this label will be displayed.\n   * @memberof Label.prototype\n   * @type {DistanceDisplayCondition}\n   * @default undefined\n   */\n  distanceDisplayCondition: {\n    get: function () {\n      return this._distanceDisplayCondition;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\"far must be greater than near\");\n      } //>>includeEnd('debug');\n\n\n      if (!DistanceDisplayCondition.equals(value, this._distanceDisplayCondition)) {\n        this._distanceDisplayCondition = DistanceDisplayCondition.clone(value, this._distanceDisplayCondition);\n        var glyphs = this._glyphs;\n\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var glyph = glyphs[i];\n\n          if (defined(glyph.billboard)) {\n            glyph.billboard.distanceDisplayCondition = value;\n          }\n        }\n\n        var backgroundBillboard = this._backgroundBillboard;\n\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.distanceDisplayCondition = value;\n        }\n      }\n    }\n  },\n\n  /**\n   * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.\n   * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.\n   * @memberof Label.prototype\n   * @type {Number}\n   */\n  disableDepthTestDistance: {\n    get: function () {\n      return this._disableDepthTestDistance;\n    },\n    set: function (value) {\n      if (this._disableDepthTestDistance !== value) {\n        //>>includeStart('debug', pragmas.debug);\n        if (defined(value) && value < 0.0) {\n          throw new DeveloperError(\"disableDepthTestDistance must be greater than 0.0.\");\n        } //>>includeEnd('debug');\n\n\n        this._disableDepthTestDistance = value;\n        var glyphs = this._glyphs;\n\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var glyph = glyphs[i];\n\n          if (defined(glyph.billboard)) {\n            glyph.billboard.disableDepthTestDistance = value;\n          }\n        }\n\n        var backgroundBillboard = this._backgroundBillboard;\n\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.disableDepthTestDistance = value;\n        }\n      }\n    }\n  },\n\n  /**\n   * Gets or sets the user-defined value returned when the label is picked.\n   * @memberof Label.prototype\n   * @type {*}\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n    set: function (value) {\n      if (this._id !== value) {\n        this._id = value;\n        var glyphs = this._glyphs;\n\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var glyph = glyphs[i];\n\n          if (defined(glyph.billboard)) {\n            glyph.billboard.id = value;\n          }\n        }\n\n        var backgroundBillboard = this._backgroundBillboard;\n\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.id = value;\n        }\n      }\n    }\n  },\n\n  /**\n   * @private\n   */\n  pickId: {\n    get: function () {\n      if (this._glyphs.length === 0 || !defined(this._glyphs[0].billboard)) {\n        return undefined;\n      }\n\n      return this._glyphs[0].billboard.pickId;\n    }\n  },\n\n  /**\n   * Keeps track of the position of the label based on the height reference.\n   * @memberof Label.prototype\n   * @type {Cartesian3}\n   * @private\n   */\n  _clampedPosition: {\n    get: function () {\n      return this._actualClampedPosition;\n    },\n    set: function (value) {\n      this._actualClampedPosition = Cartesian3.clone(value, this._actualClampedPosition);\n      var glyphs = this._glyphs;\n\n      for (var i = 0, len = glyphs.length; i < len; i++) {\n        var glyph = glyphs[i];\n\n        if (defined(glyph.billboard)) {\n          // Set all the private values here, because we already clamped to ground\n          //  so we don't want to do it again for every glyph\n          glyph.billboard._clampedPosition = value;\n        }\n      }\n\n      var backgroundBillboard = this._backgroundBillboard;\n\n      if (defined(backgroundBillboard)) {\n        backgroundBillboard._clampedPosition = value;\n      }\n    }\n  },\n\n  /**\n   * Determines whether or not this label will be shown or hidden because it was clustered.\n   * @memberof Label.prototype\n   * @type {Boolean}\n   * @default true\n   * @private\n   */\n  clusterShow: {\n    get: function () {\n      return this._clusterShow;\n    },\n    set: function (value) {\n      if (this._clusterShow !== value) {\n        this._clusterShow = value;\n        var glyphs = this._glyphs;\n\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var glyph = glyphs[i];\n\n          if (defined(glyph.billboard)) {\n            glyph.billboard.clusterShow = value;\n          }\n        }\n\n        var backgroundBillboard = this._backgroundBillboard;\n\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.clusterShow = value;\n        }\n      }\n    }\n  }\n});\n\nLabel.prototype._updateClamping = function () {\n  Billboard._updateClamping(this._labelCollection, this);\n};\n/**\n * Computes the screen-space position of the label's origin, taking into account eye and pixel offsets.\n * The screen space origin is the top, left corner of the canvas; <code>x</code> increases from\n * left to right, and <code>y</code> increases from top to bottom.\n *\n * @param {Scene} scene The scene the label is in.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The screen-space position of the label.\n *\n *\n * @example\n * console.log(l.computeScreenSpacePosition(scene).toString());\n *\n * @see Label#eyeOffset\n * @see Label#pixelOffset\n */\n\n\nLabel.prototype.computeScreenSpacePosition = function (scene, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n\n  var labelCollection = this._labelCollection;\n  var modelMatrix = labelCollection.modelMatrix;\n  var actualPosition = defined(this._actualClampedPosition) ? this._actualClampedPosition : this._position;\n\n  var windowCoordinates = Billboard._computeScreenSpacePosition(modelMatrix, actualPosition, this._eyeOffset, this._pixelOffset, scene, result);\n\n  return windowCoordinates;\n};\n/**\n * Gets a label's screen space bounding box centered around screenSpacePosition.\n * @param {Label} label The label to get the screen space bounding box for.\n * @param {Cartesian2} screenSpacePosition The screen space center of the label.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The screen space bounding box.\n *\n * @private\n */\n\n\nLabel.getScreenSpaceBoundingBox = function (label, screenSpacePosition, result) {\n  var x = 0;\n  var y = 0;\n  var width = 0;\n  var height = 0;\n  var scale = label.totalScale;\n  var backgroundBillboard = label._backgroundBillboard;\n\n  if (defined(backgroundBillboard)) {\n    x = screenSpacePosition.x + backgroundBillboard._translate.x;\n    y = screenSpacePosition.y - backgroundBillboard._translate.y;\n    width = backgroundBillboard.width * scale;\n    height = backgroundBillboard.height * scale;\n\n    if (label.verticalOrigin === VerticalOrigin.BOTTOM || label.verticalOrigin === VerticalOrigin.BASELINE) {\n      y -= height;\n    } else if (label.verticalOrigin === VerticalOrigin.CENTER) {\n      y -= height * 0.5;\n    }\n  } else {\n    x = Number.POSITIVE_INFINITY;\n    y = Number.POSITIVE_INFINITY;\n    var maxX = 0;\n    var maxY = 0;\n    var glyphs = label._glyphs;\n    var length = glyphs.length;\n\n    for (var i = 0; i < length; ++i) {\n      var glyph = glyphs[i];\n      var billboard = glyph.billboard;\n\n      if (!defined(billboard)) {\n        continue;\n      }\n\n      var glyphX = screenSpacePosition.x + billboard._translate.x;\n      var glyphY = screenSpacePosition.y - billboard._translate.y;\n      var glyphWidth = glyph.dimensions.width * scale;\n      var glyphHeight = glyph.dimensions.height * scale;\n\n      if (label.verticalOrigin === VerticalOrigin.BOTTOM || label.verticalOrigin === VerticalOrigin.BASELINE) {\n        glyphY -= glyphHeight;\n      } else if (label.verticalOrigin === VerticalOrigin.CENTER) {\n        glyphY -= glyphHeight * 0.5;\n      }\n\n      if (label._verticalOrigin === VerticalOrigin.TOP) {\n        glyphY += SDFSettings.PADDING * scale;\n      } else if (label._verticalOrigin === VerticalOrigin.BOTTOM || label._verticalOrigin === VerticalOrigin.BASELINE) {\n        glyphY -= SDFSettings.PADDING * scale;\n      }\n\n      x = Math.min(x, glyphX);\n      y = Math.min(y, glyphY);\n      maxX = Math.max(maxX, glyphX + glyphWidth);\n      maxY = Math.max(maxY, glyphY + glyphHeight);\n    }\n\n    width = maxX - x;\n    height = maxY - y;\n  }\n\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n\n  result.x = x;\n  result.y = y;\n  result.width = width;\n  result.height = height;\n  return result;\n};\n/**\n * Determines if this label equals another label.  Labels are equal if all their properties\n * are equal.  Labels in different collections can be equal.\n *\n * @param {Label} other The label to compare for equality.\n * @returns {Boolean} <code>true</code> if the labels are equal; otherwise, <code>false</code>.\n */\n\n\nLabel.prototype.equals = function (other) {\n  return this === other || defined(other) && this._show === other._show && this._scale === other._scale && this._outlineWidth === other._outlineWidth && this._showBackground === other._showBackground && this._style === other._style && this._verticalOrigin === other._verticalOrigin && this._horizontalOrigin === other._horizontalOrigin && this._heightReference === other._heightReference && this._renderedText === other._renderedText && this._font === other._font && Cartesian3.equals(this._position, other._position) && Color.equals(this._fillColor, other._fillColor) && Color.equals(this._outlineColor, other._outlineColor) && Color.equals(this._backgroundColor, other._backgroundColor) && Cartesian2.equals(this._backgroundPadding, other._backgroundPadding) && Cartesian2.equals(this._pixelOffset, other._pixelOffset) && Cartesian3.equals(this._eyeOffset, other._eyeOffset) && NearFarScalar.equals(this._translucencyByDistance, other._translucencyByDistance) && NearFarScalar.equals(this._pixelOffsetScaleByDistance, other._pixelOffsetScaleByDistance) && NearFarScalar.equals(this._scaleByDistance, other._scaleByDistance) && DistanceDisplayCondition.equals(this._distanceDisplayCondition, other._distanceDisplayCondition) && this._disableDepthTestDistance === other._disableDepthTestDistance && this._id === other._id;\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n */\n\n\nLabel.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Determines whether or not run the algorithm, that match the text of the label to right-to-left languages\n * @memberof Label\n * @type {Boolean}\n * @default false\n *\n * @example\n * // Example 1.\n * // Set a label's rightToLeft before init\n * Cesium.Label.enableRightToLeftDetection = true;\n * var myLabelEntity = viewer.entities.add({\n *   label: {\n *     id: 'my label',\n *     text: 'זה טקסט בעברית \\n ועכשיו יורדים שורה',\n *   }\n * });\n *\n * @example\n * // Example 2.\n * var myLabelEntity = viewer.entities.add({\n *   label: {\n *     id: 'my label',\n *     text: 'English text'\n *   }\n * });\n * // Set a label's rightToLeft after init\n * Cesium.Label.enableRightToLeftDetection = true;\n * myLabelEntity.text = 'טקסט חדש';\n */\n\n\nLabel.enableRightToLeftDetection = false;\n\nfunction convertTextToTypes(text, rtlChars) {\n  var ltrChars = /[a-zA-Z0-9]/;\n  var bracketsChars = /[()[\\]{}<>]/;\n  var parsedText = [];\n  var word = \"\";\n  var lastType = textTypes.LTR;\n  var currentType = \"\";\n  var textLength = text.length;\n\n  for (var textIndex = 0; textIndex < textLength; ++textIndex) {\n    var character = text.charAt(textIndex);\n\n    if (rtlChars.test(character)) {\n      currentType = textTypes.RTL;\n    } else if (ltrChars.test(character)) {\n      currentType = textTypes.LTR;\n    } else if (bracketsChars.test(character)) {\n      currentType = textTypes.BRACKETS;\n    } else {\n      currentType = textTypes.WEAK;\n    }\n\n    if (textIndex === 0) {\n      lastType = currentType;\n    }\n\n    if (lastType === currentType && currentType !== textTypes.BRACKETS) {\n      word += character;\n    } else {\n      if (word !== \"\") {\n        parsedText.push({\n          Type: lastType,\n          Word: word\n        });\n      }\n\n      lastType = currentType;\n      word = character;\n    }\n  }\n\n  parsedText.push({\n    Type: currentType,\n    Word: word\n  });\n  return parsedText;\n}\n\nfunction reverseWord(word) {\n  return word.split(\"\").reverse().join(\"\");\n}\n\nfunction spliceWord(result, pointer, word) {\n  return result.slice(0, pointer) + word + result.slice(pointer);\n}\n\nfunction reverseBrackets(bracket) {\n  switch (bracket) {\n    case \"(\":\n      return \")\";\n\n    case \")\":\n      return \"(\";\n\n    case \"[\":\n      return \"]\";\n\n    case \"]\":\n      return \"[\";\n\n    case \"{\":\n      return \"}\";\n\n    case \"}\":\n      return \"{\";\n\n    case \"<\":\n      return \">\";\n\n    case \">\":\n      return \"<\";\n  }\n} //To add another language, simply add its Unicode block range(s) to the below regex.\n\n\nvar hebrew = \"\\u05D0-\\u05EA\";\nvar arabic = \"\\u0600-\\u06FF\\u0750-\\u077F\\u08A0-\\u08FF\";\nvar rtlChars = new RegExp(\"[\" + hebrew + arabic + \"]\");\n/**\n *\n * @param {String} value the text to parse and reorder\n * @returns {String} the text as rightToLeft direction\n * @private\n */\n\nfunction reverseRtl(value) {\n  var texts = value.split(\"\\n\");\n  var result = \"\";\n\n  for (var i = 0; i < texts.length; i++) {\n    var text = texts[i]; // first character of the line is a RTL character, so need to manage different cases\n\n    var rtlDir = rtlChars.test(text.charAt(0));\n    var parsedText = convertTextToTypes(text, rtlChars);\n    var splicePointer = 0;\n    var line = \"\";\n\n    for (var wordIndex = 0; wordIndex < parsedText.length; ++wordIndex) {\n      var subText = parsedText[wordIndex];\n      var reverse = subText.Type === textTypes.BRACKETS ? reverseBrackets(subText.Word) : reverseWord(subText.Word);\n\n      if (rtlDir) {\n        if (subText.Type === textTypes.RTL) {\n          line = reverse + line;\n          splicePointer = 0;\n        } else if (subText.Type === textTypes.LTR) {\n          line = spliceWord(line, splicePointer, subText.Word);\n          splicePointer += subText.Word.length;\n        } else if (subText.Type === textTypes.WEAK || subText.Type === textTypes.BRACKETS) {\n          // current word is weak, last one was bracket\n          if (subText.Type === textTypes.WEAK && parsedText[wordIndex - 1].Type === textTypes.BRACKETS) {\n            line = reverse + line;\n          } // current word is weak or bracket, last one was rtl\n          else if (parsedText[wordIndex - 1].Type === textTypes.RTL) {\n              line = reverse + line;\n              splicePointer = 0;\n            } // current word is weak or bracket, there is at least one more word\n            else if (parsedText.length > wordIndex + 1) {\n                // next word is rtl\n                if (parsedText[wordIndex + 1].Type === textTypes.RTL) {\n                  line = reverse + line;\n                  splicePointer = 0;\n                } else {\n                  line = spliceWord(line, splicePointer, subText.Word);\n                  splicePointer += subText.Word.length;\n                }\n              } // current word is weak or bracket, and it the last in this line\n              else {\n                  line = spliceWord(line, 0, reverse);\n                }\n        }\n      } // ltr line, rtl word\n      else if (subText.Type === textTypes.RTL) {\n          line = spliceWord(line, splicePointer, reverse);\n        } // ltr line, ltr word\n        else if (subText.Type === textTypes.LTR) {\n            line += subText.Word;\n            splicePointer = line.length;\n          } // ltr line, weak or bracket word\n          else if (subText.Type === textTypes.WEAK || subText.Type === textTypes.BRACKETS) {\n              // not first word in line\n              if (wordIndex > 0) {\n                // last word was rtl\n                if (parsedText[wordIndex - 1].Type === textTypes.RTL) {\n                  // there is at least one more word\n                  if (parsedText.length > wordIndex + 1) {\n                    // next word is rtl\n                    if (parsedText[wordIndex + 1].Type === textTypes.RTL) {\n                      line = spliceWord(line, splicePointer, reverse);\n                    } else {\n                      line += subText.Word;\n                      splicePointer = line.length;\n                    }\n                  } else {\n                    line += subText.Word;\n                  }\n                } else {\n                  line += subText.Word;\n                  splicePointer = line.length;\n                }\n              } else {\n                line += subText.Word;\n                splicePointer = line.length;\n              }\n            }\n    }\n\n    result += line;\n\n    if (i < texts.length - 1) {\n      result += \"\\n\";\n    }\n  }\n\n  return result;\n}\n\nexport default Label;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Scene/Label.js"],"names":["BoundingRectangle","Cartesian2","Cartesian3","Color","defaultValue","defined","DeveloperError","DistanceDisplayCondition","NearFarScalar","Billboard","HeightReference","HorizontalOrigin","LabelStyle","SDFSettings","VerticalOrigin","fontInfoCache","fontInfoCacheLength","fontInfoCacheMaxSize","textTypes","Object","freeze","LTR","RTL","WEAK","BRACKETS","rebindAllGlyphs","label","_rebindAllGlyphs","_repositionAllGlyphs","_labelCollection","_labelsToUpdate","push","repositionAllGlyphs","getCSSValue","element","property","document","defaultView","getComputedStyle","getPropertyValue","parseFont","fontInfo","_font","div","createElement","style","position","opacity","font","body","appendChild","family","size","replace","weight","removeChild","_fontFamily","_fontSize","_fontStyle","_fontWeight","Label","options","labelCollection","EMPTY_OBJECT","disableDepthTestDistance","translucencyByDistance","pixelOffsetScaleByDistance","scaleByDistance","distanceDisplayCondition","far","near","clone","_renderedText","undefined","_text","_show","show","_fillColor","fillColor","WHITE","_outlineColor","outlineColor","BLACK","_outlineWidth","outlineWidth","_showBackground","showBackground","_backgroundColor","backgroundColor","_backgroundPadding","backgroundPadding","_style","FILL","_verticalOrigin","verticalOrigin","BASELINE","_horizontalOrigin","horizontalOrigin","LEFT","_pixelOffset","pixelOffset","ZERO","_eyeOffset","eyeOffset","_position","_scale","scale","_id","id","_translucencyByDistance","_pixelOffsetScaleByDistance","_scaleByDistance","_heightReference","heightReference","NONE","_distanceDisplayCondition","_disableDepthTestDistance","_glyphs","_backgroundBillboard","_batchIndex","_actualClampedPosition","_removeCallbackFunc","_mode","_clusterShow","text","_relativeSize","_updateClamping","defineProperties","prototype","get","set","value","glyphs","i","len","length","billboard","backgroundBillboard","equals","enableRightToLeftDetection","reverseRtl","color","glyph","totalScale","pickId","_clampedPosition","clusterShow","computeScreenSpacePosition","scene","result","modelMatrix","actualPosition","windowCoordinates","_computeScreenSpacePosition","getScreenSpaceBoundingBox","screenSpacePosition","x","y","width","height","_translate","BOTTOM","CENTER","Number","POSITIVE_INFINITY","maxX","maxY","glyphX","glyphY","glyphWidth","dimensions","glyphHeight","TOP","PADDING","Math","min","max","other","isDestroyed","convertTextToTypes","rtlChars","ltrChars","bracketsChars","parsedText","word","lastType","currentType","textLength","textIndex","character","charAt","test","Type","Word","reverseWord","split","reverse","join","spliceWord","pointer","slice","reverseBrackets","bracket","hebrew","arabic","RegExp","texts","rtlDir","splicePointer","line","wordIndex","subText"],"mappings":"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","sourcesContent":["import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport Billboard from \"./Billboard.js\";\nimport HeightReference from \"./HeightReference.js\";\nimport HorizontalOrigin from \"./HorizontalOrigin.js\";\nimport LabelStyle from \"./LabelStyle.js\";\nimport SDFSettings from \"./SDFSettings.js\";\nimport VerticalOrigin from \"./VerticalOrigin.js\";\n\nvar fontInfoCache = {};\nvar fontInfoCacheLength = 0;\nvar fontInfoCacheMaxSize = 256;\n\nvar textTypes = Object.freeze({\n  LTR: 0,\n  RTL: 1,\n  WEAK: 2,\n  BRACKETS: 3,\n});\n\nfunction rebindAllGlyphs(label) {\n  if (!label._rebindAllGlyphs && !label._repositionAllGlyphs) {\n    // only push label if it's not already been marked dirty\n    label._labelCollection._labelsToUpdate.push(label);\n  }\n  label._rebindAllGlyphs = true;\n}\n\nfunction repositionAllGlyphs(label) {\n  if (!label._rebindAllGlyphs && !label._repositionAllGlyphs) {\n    // only push label if it's not already been marked dirty\n    label._labelCollection._labelsToUpdate.push(label);\n  }\n  label._repositionAllGlyphs = true;\n}\n\nfunction getCSSValue(element, property) {\n  return document.defaultView\n    .getComputedStyle(element, null)\n    .getPropertyValue(property);\n}\n\nfunction parseFont(label) {\n  var fontInfo = fontInfoCache[label._font];\n  if (!defined(fontInfo)) {\n    var div = document.createElement(\"div\");\n    div.style.position = \"absolute\";\n    div.style.opacity = 0;\n    div.style.font = label._font;\n    document.body.appendChild(div);\n\n    fontInfo = {\n      family: getCSSValue(div, \"font-family\"),\n      size: getCSSValue(div, \"font-size\").replace(\"px\", \"\"),\n      style: getCSSValue(div, \"font-style\"),\n      weight: getCSSValue(div, \"font-weight\"),\n    };\n\n    document.body.removeChild(div);\n    if (fontInfoCacheLength < fontInfoCacheMaxSize) {\n      fontInfoCache[label._font] = fontInfo;\n      fontInfoCacheLength++;\n    }\n  }\n  label._fontFamily = fontInfo.family;\n  label._fontSize = fontInfo.size;\n  label._fontStyle = fontInfo.style;\n  label._fontWeight = fontInfo.weight;\n}\n\n/**\n * A Label draws viewport-aligned text positioned in the 3D scene.  This constructor\n * should not be used directly, instead create labels by calling {@link LabelCollection#add}.\n *\n * @alias Label\n * @internalConstructor\n * @class\n *\n * @exception {DeveloperError} translucencyByDistance.far must be greater than translucencyByDistance.near\n * @exception {DeveloperError} pixelOffsetScaleByDistance.far must be greater than pixelOffsetScaleByDistance.near\n * @exception {DeveloperError} distanceDisplayCondition.far must be greater than distanceDisplayCondition.near\n *\n * @see LabelCollection\n * @see LabelCollection#add\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Labels.html|Cesium Sandcastle Labels Demo}\n */\nfunction Label(options, labelCollection) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    defined(options.disableDepthTestDistance) &&\n    options.disableDepthTestDistance < 0.0\n  ) {\n    throw new DeveloperError(\n      \"disableDepthTestDistance must be greater than 0.0.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var translucencyByDistance = options.translucencyByDistance;\n  var pixelOffsetScaleByDistance = options.pixelOffsetScaleByDistance;\n  var scaleByDistance = options.scaleByDistance;\n  var distanceDisplayCondition = options.distanceDisplayCondition;\n  if (defined(translucencyByDistance)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (translucencyByDistance.far <= translucencyByDistance.near) {\n      throw new DeveloperError(\n        \"translucencyByDistance.far must be greater than translucencyByDistance.near.\"\n      );\n    }\n    //>>includeEnd('debug');\n    translucencyByDistance = NearFarScalar.clone(translucencyByDistance);\n  }\n  if (defined(pixelOffsetScaleByDistance)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (pixelOffsetScaleByDistance.far <= pixelOffsetScaleByDistance.near) {\n      throw new DeveloperError(\n        \"pixelOffsetScaleByDistance.far must be greater than pixelOffsetScaleByDistance.near.\"\n      );\n    }\n    //>>includeEnd('debug');\n    pixelOffsetScaleByDistance = NearFarScalar.clone(\n      pixelOffsetScaleByDistance\n    );\n  }\n  if (defined(scaleByDistance)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (scaleByDistance.far <= scaleByDistance.near) {\n      throw new DeveloperError(\n        \"scaleByDistance.far must be greater than scaleByDistance.near.\"\n      );\n    }\n    //>>includeEnd('debug');\n    scaleByDistance = NearFarScalar.clone(scaleByDistance);\n  }\n  if (defined(distanceDisplayCondition)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (distanceDisplayCondition.far <= distanceDisplayCondition.near) {\n      throw new DeveloperError(\n        \"distanceDisplayCondition.far must be greater than distanceDisplayCondition.near.\"\n      );\n    }\n    //>>includeEnd('debug');\n    distanceDisplayCondition = DistanceDisplayCondition.clone(\n      distanceDisplayCondition\n    );\n  }\n\n  this._renderedText = undefined;\n  this._text = undefined;\n  this._show = defaultValue(options.show, true);\n  this._font = defaultValue(options.font, \"30px sans-serif\");\n  this._fillColor = Color.clone(defaultValue(options.fillColor, Color.WHITE));\n  this._outlineColor = Color.clone(\n    defaultValue(options.outlineColor, Color.BLACK)\n  );\n  this._outlineWidth = defaultValue(options.outlineWidth, 1.0);\n  this._showBackground = defaultValue(options.showBackground, false);\n  this._backgroundColor = defaultValue(\n    options.backgroundColor,\n    new Color(0.165, 0.165, 0.165, 0.8)\n  );\n  this._backgroundPadding = defaultValue(\n    options.backgroundPadding,\n    new Cartesian2(7, 5)\n  );\n  this._style = defaultValue(options.style, LabelStyle.FILL);\n  this._verticalOrigin = defaultValue(\n    options.verticalOrigin,\n    VerticalOrigin.BASELINE\n  );\n  this._horizontalOrigin = defaultValue(\n    options.horizontalOrigin,\n    HorizontalOrigin.LEFT\n  );\n  this._pixelOffset = Cartesian2.clone(\n    defaultValue(options.pixelOffset, Cartesian2.ZERO)\n  );\n  this._eyeOffset = Cartesian3.clone(\n    defaultValue(options.eyeOffset, Cartesian3.ZERO)\n  );\n  this._position = Cartesian3.clone(\n    defaultValue(options.position, Cartesian3.ZERO)\n  );\n  this._scale = defaultValue(options.scale, 1.0);\n  this._id = options.id;\n  this._translucencyByDistance = translucencyByDistance;\n  this._pixelOffsetScaleByDistance = pixelOffsetScaleByDistance;\n  this._scaleByDistance = scaleByDistance;\n  this._heightReference = defaultValue(\n    options.heightReference,\n    HeightReference.NONE\n  );\n  this._distanceDisplayCondition = distanceDisplayCondition;\n  this._disableDepthTestDistance = options.disableDepthTestDistance;\n\n  this._labelCollection = labelCollection;\n  this._glyphs = [];\n  this._backgroundBillboard = undefined;\n  this._batchIndex = undefined; // Used only by Vector3DTilePoints and BillboardCollection\n\n  this._rebindAllGlyphs = true;\n  this._repositionAllGlyphs = true;\n\n  this._actualClampedPosition = undefined;\n  this._removeCallbackFunc = undefined;\n  this._mode = undefined;\n\n  this._clusterShow = true;\n\n  this.text = defaultValue(options.text, \"\");\n\n  this._relativeSize = 1.0;\n\n  parseFont(this);\n\n  this._updateClamping();\n}\n\nObject.defineProperties(Label.prototype, {\n  /**\n   * Determines if this label will be shown.  Use this to hide or show a label, instead\n   * of removing it and re-adding it to the collection.\n   * @memberof Label.prototype\n   * @type {Boolean}\n   * @default true\n   */\n  show: {\n    get: function () {\n      return this._show;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._show !== value) {\n        this._show = value;\n\n        var glyphs = this._glyphs;\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var billboard = glyphs[i].billboard;\n          if (defined(billboard)) {\n            billboard.show = value;\n          }\n        }\n        var backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.show = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the Cartesian position of this label.\n   * @memberof Label.prototype\n   * @type {Cartesian3}\n   */\n  position: {\n    get: function () {\n      return this._position;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      var position = this._position;\n      if (!Cartesian3.equals(position, value)) {\n        Cartesian3.clone(value, position);\n\n        var glyphs = this._glyphs;\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var billboard = glyphs[i].billboard;\n          if (defined(billboard)) {\n            billboard.position = value;\n          }\n        }\n        var backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.position = value;\n        }\n\n        this._updateClamping();\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the height reference of this billboard.\n   * @memberof Label.prototype\n   * @type {HeightReference}\n   * @default HeightReference.NONE\n   */\n  heightReference: {\n    get: function () {\n      return this._heightReference;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (value !== this._heightReference) {\n        this._heightReference = value;\n\n        var glyphs = this._glyphs;\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var billboard = glyphs[i].billboard;\n          if (defined(billboard)) {\n            billboard.heightReference = value;\n          }\n        }\n        var backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.heightReference = value;\n        }\n\n        repositionAllGlyphs(this);\n\n        this._updateClamping();\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the text of this label.\n   * @memberof Label.prototype\n   * @type {String}\n   */\n  text: {\n    get: function () {\n      return this._text;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._text !== value) {\n        this._text = value;\n        this._renderedText = Label.enableRightToLeftDetection\n          ? reverseRtl(value)\n          : value;\n        rebindAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the font used to draw this label. Fonts are specified using the same syntax as the CSS 'font' property.\n   * @memberof Label.prototype\n   * @type {String}\n   * @default '30px sans-serif'\n   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles|HTML canvas 2D context text styles}\n   */\n  font: {\n    get: function () {\n      return this._font;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._font !== value) {\n        this._font = value;\n        rebindAllGlyphs(this);\n        parseFont(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the fill color of this label.\n   * @memberof Label.prototype\n   * @type {Color}\n   * @default Color.WHITE\n   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles|HTML canvas 2D context fill and stroke styles}\n   */\n  fillColor: {\n    get: function () {\n      return this._fillColor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      var fillColor = this._fillColor;\n      if (!Color.equals(fillColor, value)) {\n        Color.clone(value, fillColor);\n        rebindAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the outline color of this label.\n   * @memberof Label.prototype\n   * @type {Color}\n   * @default Color.BLACK\n   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles|HTML canvas 2D context fill and stroke styles}\n   */\n  outlineColor: {\n    get: function () {\n      return this._outlineColor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      var outlineColor = this._outlineColor;\n      if (!Color.equals(outlineColor, value)) {\n        Color.clone(value, outlineColor);\n        rebindAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the outline width of this label.\n   * @memberof Label.prototype\n   * @type {Number}\n   * @default 1.0\n   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles|HTML canvas 2D context fill and stroke styles}\n   */\n  outlineWidth: {\n    get: function () {\n      return this._outlineWidth;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._outlineWidth !== value) {\n        this._outlineWidth = value;\n        rebindAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Determines if a background behind this label will be shown.\n   * @memberof Label.prototype\n   * @default false\n   * @type {Boolean}\n   */\n  showBackground: {\n    get: function () {\n      return this._showBackground;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._showBackground !== value) {\n        this._showBackground = value;\n        rebindAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the background color of this label.\n   * @memberof Label.prototype\n   * @type {Color}\n   * @default new Color(0.165, 0.165, 0.165, 0.8)\n   */\n  backgroundColor: {\n    get: function () {\n      return this._backgroundColor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      var backgroundColor = this._backgroundColor;\n      if (!Color.equals(backgroundColor, value)) {\n        Color.clone(value, backgroundColor);\n\n        var backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.color = backgroundColor;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the background padding, in pixels, of this label.  The <code>x</code> value\n   * controls horizontal padding, and the <code>y</code> value controls vertical padding.\n   * @memberof Label.prototype\n   * @type {Cartesian2}\n   * @default new Cartesian2(7, 5)\n   */\n  backgroundPadding: {\n    get: function () {\n      return this._backgroundPadding;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      var backgroundPadding = this._backgroundPadding;\n      if (!Cartesian2.equals(backgroundPadding, value)) {\n        Cartesian2.clone(value, backgroundPadding);\n        repositionAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the style of this label.\n   * @memberof Label.prototype\n   * @type {LabelStyle}\n   * @default LabelStyle.FILL\n   */\n  style: {\n    get: function () {\n      return this._style;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._style !== value) {\n        this._style = value;\n        rebindAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the pixel offset in screen space from the origin of this label.  This is commonly used\n   * to align multiple labels and billboards at the same position, e.g., an image and text.  The\n   * screen space origin is the top, left corner of the canvas; <code>x</code> increases from\n   * left to right, and <code>y</code> increases from top to bottom.\n   * <br /><br />\n   * <div align='center'>\n   * <table border='0' cellpadding='5'><tr>\n   * <td align='center'><code>default</code><br/><img src='Images/Label.setPixelOffset.default.png' width='250' height='188' /></td>\n   * <td align='center'><code>l.pixeloffset = new Cartesian2(25, 75);</code><br/><img src='Images/Label.setPixelOffset.x50y-25.png' width='250' height='188' /></td>\n   * </tr></table>\n   * The label's origin is indicated by the yellow point.\n   * </div>\n   * @memberof Label.prototype\n   * @type {Cartesian2}\n   * @default Cartesian2.ZERO\n   */\n  pixelOffset: {\n    get: function () {\n      return this._pixelOffset;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      var pixelOffset = this._pixelOffset;\n      if (!Cartesian2.equals(pixelOffset, value)) {\n        Cartesian2.clone(value, pixelOffset);\n\n        var glyphs = this._glyphs;\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.pixelOffset = value;\n          }\n        }\n        var backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.pixelOffset = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets or sets near and far translucency properties of a Label based on the Label's distance from the camera.\n   * A label's translucency will interpolate between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the label's translucency remains clamped to the nearest bound.  If undefined,\n   * translucencyByDistance will be disabled.\n   * @memberof Label.prototype\n   * @type {NearFarScalar}\n   *\n   * @example\n   * // Example 1.\n   * // Set a label's translucencyByDistance to 1.0 when the\n   * // camera is 1500 meters from the label and disappear as\n   * // the camera distance approaches 8.0e6 meters.\n   * text.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);\n   *\n   * @example\n   * // Example 2.\n   * // disable translucency by distance\n   * text.translucencyByDistance = undefined;\n   */\n  translucencyByDistance: {\n    get: function () {\n      return this._translucencyByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\n          \"far distance must be greater than near distance.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      var translucencyByDistance = this._translucencyByDistance;\n      if (!NearFarScalar.equals(translucencyByDistance, value)) {\n        this._translucencyByDistance = NearFarScalar.clone(\n          value,\n          translucencyByDistance\n        );\n\n        var glyphs = this._glyphs;\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.translucencyByDistance = value;\n          }\n        }\n        var backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.translucencyByDistance = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets or sets near and far pixel offset scaling properties of a Label based on the Label's distance from the camera.\n   * A label's pixel offset will be scaled between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the label's pixel offset scaling remains clamped to the nearest bound.  If undefined,\n   * pixelOffsetScaleByDistance will be disabled.\n   * @memberof Label.prototype\n   * @type {NearFarScalar}\n   *\n   * @example\n   * // Example 1.\n   * // Set a label's pixel offset scale to 0.0 when the\n   * // camera is 1500 meters from the label and scale pixel offset to 10.0 pixels\n   * // in the y direction the camera distance approaches 8.0e6 meters.\n   * text.pixelOffset = new Cesium.Cartesian2(0.0, 1.0);\n   * text.pixelOffsetScaleByDistance = new Cesium.NearFarScalar(1.5e2, 0.0, 8.0e6, 10.0);\n   *\n   * @example\n   * // Example 2.\n   * // disable pixel offset by distance\n   * text.pixelOffsetScaleByDistance = undefined;\n   */\n  pixelOffsetScaleByDistance: {\n    get: function () {\n      return this._pixelOffsetScaleByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\n          \"far distance must be greater than near distance.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      var pixelOffsetScaleByDistance = this._pixelOffsetScaleByDistance;\n      if (!NearFarScalar.equals(pixelOffsetScaleByDistance, value)) {\n        this._pixelOffsetScaleByDistance = NearFarScalar.clone(\n          value,\n          pixelOffsetScaleByDistance\n        );\n\n        var glyphs = this._glyphs;\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.pixelOffsetScaleByDistance = value;\n          }\n        }\n        var backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.pixelOffsetScaleByDistance = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets or sets near and far scaling properties of a Label based on the label's distance from the camera.\n   * A label's scale will interpolate between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the label's scale remains clamped to the nearest bound.  If undefined,\n   * scaleByDistance will be disabled.\n   * @memberof Label.prototype\n   * @type {NearFarScalar}\n   *\n   * @example\n   * // Example 1.\n   * // Set a label's scaleByDistance to scale by 1.5 when the\n   * // camera is 1500 meters from the label and disappear as\n   * // the camera distance approaches 8.0e6 meters.\n   * label.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 1.5, 8.0e6, 0.0);\n   *\n   * @example\n   * // Example 2.\n   * // disable scaling by distance\n   * label.scaleByDistance = undefined;\n   */\n  scaleByDistance: {\n    get: function () {\n      return this._scaleByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\n          \"far distance must be greater than near distance.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      var scaleByDistance = this._scaleByDistance;\n      if (!NearFarScalar.equals(scaleByDistance, value)) {\n        this._scaleByDistance = NearFarScalar.clone(value, scaleByDistance);\n\n        var glyphs = this._glyphs;\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.scaleByDistance = value;\n          }\n        }\n        var backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.scaleByDistance = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets and sets the 3D Cartesian offset applied to this label in eye coordinates.  Eye coordinates is a left-handed\n   * coordinate system, where <code>x</code> points towards the viewer's right, <code>y</code> points up, and\n   * <code>z</code> points into the screen.  Eye coordinates use the same scale as world and model coordinates,\n   * which is typically meters.\n   * <br /><br />\n   * An eye offset is commonly used to arrange multiple label or objects at the same position, e.g., to\n   * arrange a label above its corresponding 3D model.\n   * <br /><br />\n   * Below, the label is positioned at the center of the Earth but an eye offset makes it always\n   * appear on top of the Earth regardless of the viewer's or Earth's orientation.\n   * <br /><br />\n   * <div align='center'>\n   * <table border='0' cellpadding='5'><tr>\n   * <td align='center'><img src='Images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>\n   * <td align='center'><img src='Images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>\n   * </tr></table>\n   * <code>l.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code><br /><br />\n   * </div>\n   * @memberof Label.prototype\n   * @type {Cartesian3}\n   * @default Cartesian3.ZERO\n   */\n  eyeOffset: {\n    get: function () {\n      return this._eyeOffset;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      var eyeOffset = this._eyeOffset;\n      if (!Cartesian3.equals(eyeOffset, value)) {\n        Cartesian3.clone(value, eyeOffset);\n\n        var glyphs = this._glyphs;\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.eyeOffset = value;\n          }\n        }\n        var backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.eyeOffset = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the horizontal origin of this label, which determines if the label is drawn\n   * to the left, center, or right of its anchor position.\n   * <br /><br />\n   * <div align='center'>\n   * <img src='Images/Billboard.setHorizontalOrigin.png' width='648' height='196' /><br />\n   * </div>\n   * @memberof Label.prototype\n   * @type {HorizontalOrigin}\n   * @default HorizontalOrigin.LEFT\n   * @example\n   * // Use a top, right origin\n   * l.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;\n   * l.verticalOrigin = Cesium.VerticalOrigin.TOP;\n   */\n  horizontalOrigin: {\n    get: function () {\n      return this._horizontalOrigin;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._horizontalOrigin !== value) {\n        this._horizontalOrigin = value;\n        repositionAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the vertical origin of this label, which determines if the label is\n   * to the above, below, or at the center of its anchor position.\n   * <br /><br />\n   * <div align='center'>\n   * <img src='Images/Billboard.setVerticalOrigin.png' width='695' height='175' /><br />\n   * </div>\n   * @memberof Label.prototype\n   * @type {VerticalOrigin}\n   * @default VerticalOrigin.BASELINE\n   * @example\n   * // Use a top, right origin\n   * l.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;\n   * l.verticalOrigin = Cesium.VerticalOrigin.TOP;\n   */\n  verticalOrigin: {\n    get: function () {\n      return this._verticalOrigin;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._verticalOrigin !== value) {\n        this._verticalOrigin = value;\n\n        var glyphs = this._glyphs;\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.verticalOrigin = value;\n          }\n        }\n        var backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.verticalOrigin = value;\n        }\n\n        repositionAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the uniform scale that is multiplied with the label's size in pixels.\n   * A scale of <code>1.0</code> does not change the size of the label; a scale greater than\n   * <code>1.0</code> enlarges the label; a positive scale less than <code>1.0</code> shrinks\n   * the label.\n   * <br /><br />\n   * Applying a large scale value may pixelate the label.  To make text larger without pixelation,\n   * use a larger font size when calling {@link Label#font} instead.\n   * <br /><br />\n   * <div align='center'>\n   * <img src='Images/Label.setScale.png' width='400' height='300' /><br/>\n   * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,\n   * and <code>2.0</code>.\n   * </div>\n   * @memberof Label.prototype\n   * @type {Number}\n   * @default 1.0\n   */\n  scale: {\n    get: function () {\n      return this._scale;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._scale !== value) {\n        this._scale = value;\n\n        var glyphs = this._glyphs;\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.scale = value * this._relativeSize;\n          }\n        }\n        var backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.scale = value * this._relativeSize;\n        }\n\n        repositionAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets the total scale of the label, which is the label's scale multiplied by the computed relative size\n   * of the desired font compared to the generated glyph size.\n   * @memberof Label.prototype\n   * @type {Number}\n   * @default 1.0\n   */\n  totalScale: {\n    get: function () {\n      return this._scale * this._relativeSize;\n    },\n  },\n\n  /**\n   * Gets or sets the condition specifying at what distance from the camera that this label will be displayed.\n   * @memberof Label.prototype\n   * @type {DistanceDisplayCondition}\n   * @default undefined\n   */\n  distanceDisplayCondition: {\n    get: function () {\n      return this._distanceDisplayCondition;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\"far must be greater than near\");\n      }\n      //>>includeEnd('debug');\n      if (\n        !DistanceDisplayCondition.equals(value, this._distanceDisplayCondition)\n      ) {\n        this._distanceDisplayCondition = DistanceDisplayCondition.clone(\n          value,\n          this._distanceDisplayCondition\n        );\n\n        var glyphs = this._glyphs;\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.distanceDisplayCondition = value;\n          }\n        }\n        var backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.distanceDisplayCondition = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.\n   * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.\n   * @memberof Label.prototype\n   * @type {Number}\n   */\n  disableDepthTestDistance: {\n    get: function () {\n      return this._disableDepthTestDistance;\n    },\n    set: function (value) {\n      if (this._disableDepthTestDistance !== value) {\n        //>>includeStart('debug', pragmas.debug);\n        if (defined(value) && value < 0.0) {\n          throw new DeveloperError(\n            \"disableDepthTestDistance must be greater than 0.0.\"\n          );\n        }\n        //>>includeEnd('debug');\n        this._disableDepthTestDistance = value;\n\n        var glyphs = this._glyphs;\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.disableDepthTestDistance = value;\n          }\n        }\n        var backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.disableDepthTestDistance = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the user-defined value returned when the label is picked.\n   * @memberof Label.prototype\n   * @type {*}\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n    set: function (value) {\n      if (this._id !== value) {\n        this._id = value;\n\n        var glyphs = this._glyphs;\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.id = value;\n          }\n        }\n        var backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.id = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * @private\n   */\n  pickId: {\n    get: function () {\n      if (this._glyphs.length === 0 || !defined(this._glyphs[0].billboard)) {\n        return undefined;\n      }\n      return this._glyphs[0].billboard.pickId;\n    },\n  },\n\n  /**\n   * Keeps track of the position of the label based on the height reference.\n   * @memberof Label.prototype\n   * @type {Cartesian3}\n   * @private\n   */\n  _clampedPosition: {\n    get: function () {\n      return this._actualClampedPosition;\n    },\n    set: function (value) {\n      this._actualClampedPosition = Cartesian3.clone(\n        value,\n        this._actualClampedPosition\n      );\n\n      var glyphs = this._glyphs;\n      for (var i = 0, len = glyphs.length; i < len; i++) {\n        var glyph = glyphs[i];\n        if (defined(glyph.billboard)) {\n          // Set all the private values here, because we already clamped to ground\n          //  so we don't want to do it again for every glyph\n          glyph.billboard._clampedPosition = value;\n        }\n      }\n      var backgroundBillboard = this._backgroundBillboard;\n      if (defined(backgroundBillboard)) {\n        backgroundBillboard._clampedPosition = value;\n      }\n    },\n  },\n\n  /**\n   * Determines whether or not this label will be shown or hidden because it was clustered.\n   * @memberof Label.prototype\n   * @type {Boolean}\n   * @default true\n   * @private\n   */\n  clusterShow: {\n    get: function () {\n      return this._clusterShow;\n    },\n    set: function (value) {\n      if (this._clusterShow !== value) {\n        this._clusterShow = value;\n\n        var glyphs = this._glyphs;\n        for (var i = 0, len = glyphs.length; i < len; i++) {\n          var glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.clusterShow = value;\n          }\n        }\n        var backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.clusterShow = value;\n        }\n      }\n    },\n  },\n});\n\nLabel.prototype._updateClamping = function () {\n  Billboard._updateClamping(this._labelCollection, this);\n};\n\n/**\n * Computes the screen-space position of the label's origin, taking into account eye and pixel offsets.\n * The screen space origin is the top, left corner of the canvas; <code>x</code> increases from\n * left to right, and <code>y</code> increases from top to bottom.\n *\n * @param {Scene} scene The scene the label is in.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The screen-space position of the label.\n *\n *\n * @example\n * console.log(l.computeScreenSpacePosition(scene).toString());\n *\n * @see Label#eyeOffset\n * @see Label#pixelOffset\n */\nLabel.prototype.computeScreenSpacePosition = function (scene, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n\n  var labelCollection = this._labelCollection;\n  var modelMatrix = labelCollection.modelMatrix;\n  var actualPosition = defined(this._actualClampedPosition)\n    ? this._actualClampedPosition\n    : this._position;\n\n  var windowCoordinates = Billboard._computeScreenSpacePosition(\n    modelMatrix,\n    actualPosition,\n    this._eyeOffset,\n    this._pixelOffset,\n    scene,\n    result\n  );\n  return windowCoordinates;\n};\n\n/**\n * Gets a label's screen space bounding box centered around screenSpacePosition.\n * @param {Label} label The label to get the screen space bounding box for.\n * @param {Cartesian2} screenSpacePosition The screen space center of the label.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The screen space bounding box.\n *\n * @private\n */\nLabel.getScreenSpaceBoundingBox = function (\n  label,\n  screenSpacePosition,\n  result\n) {\n  var x = 0;\n  var y = 0;\n  var width = 0;\n  var height = 0;\n  var scale = label.totalScale;\n\n  var backgroundBillboard = label._backgroundBillboard;\n  if (defined(backgroundBillboard)) {\n    x = screenSpacePosition.x + backgroundBillboard._translate.x;\n    y = screenSpacePosition.y - backgroundBillboard._translate.y;\n    width = backgroundBillboard.width * scale;\n    height = backgroundBillboard.height * scale;\n\n    if (\n      label.verticalOrigin === VerticalOrigin.BOTTOM ||\n      label.verticalOrigin === VerticalOrigin.BASELINE\n    ) {\n      y -= height;\n    } else if (label.verticalOrigin === VerticalOrigin.CENTER) {\n      y -= height * 0.5;\n    }\n  } else {\n    x = Number.POSITIVE_INFINITY;\n    y = Number.POSITIVE_INFINITY;\n    var maxX = 0;\n    var maxY = 0;\n    var glyphs = label._glyphs;\n    var length = glyphs.length;\n    for (var i = 0; i < length; ++i) {\n      var glyph = glyphs[i];\n      var billboard = glyph.billboard;\n      if (!defined(billboard)) {\n        continue;\n      }\n\n      var glyphX = screenSpacePosition.x + billboard._translate.x;\n      var glyphY = screenSpacePosition.y - billboard._translate.y;\n      var glyphWidth = glyph.dimensions.width * scale;\n      var glyphHeight = glyph.dimensions.height * scale;\n\n      if (\n        label.verticalOrigin === VerticalOrigin.BOTTOM ||\n        label.verticalOrigin === VerticalOrigin.BASELINE\n      ) {\n        glyphY -= glyphHeight;\n      } else if (label.verticalOrigin === VerticalOrigin.CENTER) {\n        glyphY -= glyphHeight * 0.5;\n      }\n\n      if (label._verticalOrigin === VerticalOrigin.TOP) {\n        glyphY += SDFSettings.PADDING * scale;\n      } else if (\n        label._verticalOrigin === VerticalOrigin.BOTTOM ||\n        label._verticalOrigin === VerticalOrigin.BASELINE\n      ) {\n        glyphY -= SDFSettings.PADDING * scale;\n      }\n\n      x = Math.min(x, glyphX);\n      y = Math.min(y, glyphY);\n      maxX = Math.max(maxX, glyphX + glyphWidth);\n      maxY = Math.max(maxY, glyphY + glyphHeight);\n    }\n\n    width = maxX - x;\n    height = maxY - y;\n  }\n\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n\n  result.x = x;\n  result.y = y;\n  result.width = width;\n  result.height = height;\n\n  return result;\n};\n\n/**\n * Determines if this label equals another label.  Labels are equal if all their properties\n * are equal.  Labels in different collections can be equal.\n *\n * @param {Label} other The label to compare for equality.\n * @returns {Boolean} <code>true</code> if the labels are equal; otherwise, <code>false</code>.\n */\nLabel.prototype.equals = function (other) {\n  return (\n    this === other ||\n    (defined(other) &&\n      this._show === other._show &&\n      this._scale === other._scale &&\n      this._outlineWidth === other._outlineWidth &&\n      this._showBackground === other._showBackground &&\n      this._style === other._style &&\n      this._verticalOrigin === other._verticalOrigin &&\n      this._horizontalOrigin === other._horizontalOrigin &&\n      this._heightReference === other._heightReference &&\n      this._renderedText === other._renderedText &&\n      this._font === other._font &&\n      Cartesian3.equals(this._position, other._position) &&\n      Color.equals(this._fillColor, other._fillColor) &&\n      Color.equals(this._outlineColor, other._outlineColor) &&\n      Color.equals(this._backgroundColor, other._backgroundColor) &&\n      Cartesian2.equals(this._backgroundPadding, other._backgroundPadding) &&\n      Cartesian2.equals(this._pixelOffset, other._pixelOffset) &&\n      Cartesian3.equals(this._eyeOffset, other._eyeOffset) &&\n      NearFarScalar.equals(\n        this._translucencyByDistance,\n        other._translucencyByDistance\n      ) &&\n      NearFarScalar.equals(\n        this._pixelOffsetScaleByDistance,\n        other._pixelOffsetScaleByDistance\n      ) &&\n      NearFarScalar.equals(this._scaleByDistance, other._scaleByDistance) &&\n      DistanceDisplayCondition.equals(\n        this._distanceDisplayCondition,\n        other._distanceDisplayCondition\n      ) &&\n      this._disableDepthTestDistance === other._disableDepthTestDistance &&\n      this._id === other._id)\n  );\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n */\nLabel.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Determines whether or not run the algorithm, that match the text of the label to right-to-left languages\n * @memberof Label\n * @type {Boolean}\n * @default false\n *\n * @example\n * // Example 1.\n * // Set a label's rightToLeft before init\n * Cesium.Label.enableRightToLeftDetection = true;\n * var myLabelEntity = viewer.entities.add({\n *   label: {\n *     id: 'my label',\n *     text: 'זה טקסט בעברית \\n ועכשיו יורדים שורה',\n *   }\n * });\n *\n * @example\n * // Example 2.\n * var myLabelEntity = viewer.entities.add({\n *   label: {\n *     id: 'my label',\n *     text: 'English text'\n *   }\n * });\n * // Set a label's rightToLeft after init\n * Cesium.Label.enableRightToLeftDetection = true;\n * myLabelEntity.text = 'טקסט חדש';\n */\nLabel.enableRightToLeftDetection = false;\n\nfunction convertTextToTypes(text, rtlChars) {\n  var ltrChars = /[a-zA-Z0-9]/;\n  var bracketsChars = /[()[\\]{}<>]/;\n  var parsedText = [];\n  var word = \"\";\n  var lastType = textTypes.LTR;\n  var currentType = \"\";\n  var textLength = text.length;\n  for (var textIndex = 0; textIndex < textLength; ++textIndex) {\n    var character = text.charAt(textIndex);\n    if (rtlChars.test(character)) {\n      currentType = textTypes.RTL;\n    } else if (ltrChars.test(character)) {\n      currentType = textTypes.LTR;\n    } else if (bracketsChars.test(character)) {\n      currentType = textTypes.BRACKETS;\n    } else {\n      currentType = textTypes.WEAK;\n    }\n\n    if (textIndex === 0) {\n      lastType = currentType;\n    }\n\n    if (lastType === currentType && currentType !== textTypes.BRACKETS) {\n      word += character;\n    } else {\n      if (word !== \"\") {\n        parsedText.push({ Type: lastType, Word: word });\n      }\n      lastType = currentType;\n      word = character;\n    }\n  }\n  parsedText.push({ Type: currentType, Word: word });\n  return parsedText;\n}\n\nfunction reverseWord(word) {\n  return word.split(\"\").reverse().join(\"\");\n}\n\nfunction spliceWord(result, pointer, word) {\n  return result.slice(0, pointer) + word + result.slice(pointer);\n}\n\nfunction reverseBrackets(bracket) {\n  switch (bracket) {\n    case \"(\":\n      return \")\";\n    case \")\":\n      return \"(\";\n    case \"[\":\n      return \"]\";\n    case \"]\":\n      return \"[\";\n    case \"{\":\n      return \"}\";\n    case \"}\":\n      return \"{\";\n    case \"<\":\n      return \">\";\n    case \">\":\n      return \"<\";\n  }\n}\n\n//To add another language, simply add its Unicode block range(s) to the below regex.\nvar hebrew = \"\\u05D0-\\u05EA\";\nvar arabic = \"\\u0600-\\u06FF\\u0750-\\u077F\\u08A0-\\u08FF\";\nvar rtlChars = new RegExp(\"[\" + hebrew + arabic + \"]\");\n\n/**\n *\n * @param {String} value the text to parse and reorder\n * @returns {String} the text as rightToLeft direction\n * @private\n */\nfunction reverseRtl(value) {\n  var texts = value.split(\"\\n\");\n  var result = \"\";\n  for (var i = 0; i < texts.length; i++) {\n    var text = texts[i];\n    // first character of the line is a RTL character, so need to manage different cases\n    var rtlDir = rtlChars.test(text.charAt(0));\n    var parsedText = convertTextToTypes(text, rtlChars);\n\n    var splicePointer = 0;\n    var line = \"\";\n    for (var wordIndex = 0; wordIndex < parsedText.length; ++wordIndex) {\n      var subText = parsedText[wordIndex];\n      var reverse =\n        subText.Type === textTypes.BRACKETS\n          ? reverseBrackets(subText.Word)\n          : reverseWord(subText.Word);\n      if (rtlDir) {\n        if (subText.Type === textTypes.RTL) {\n          line = reverse + line;\n          splicePointer = 0;\n        } else if (subText.Type === textTypes.LTR) {\n          line = spliceWord(line, splicePointer, subText.Word);\n          splicePointer += subText.Word.length;\n        } else if (\n          subText.Type === textTypes.WEAK ||\n          subText.Type === textTypes.BRACKETS\n        ) {\n          // current word is weak, last one was bracket\n          if (\n            subText.Type === textTypes.WEAK &&\n            parsedText[wordIndex - 1].Type === textTypes.BRACKETS\n          ) {\n            line = reverse + line;\n          }\n          // current word is weak or bracket, last one was rtl\n          else if (parsedText[wordIndex - 1].Type === textTypes.RTL) {\n            line = reverse + line;\n            splicePointer = 0;\n          }\n          // current word is weak or bracket, there is at least one more word\n          else if (parsedText.length > wordIndex + 1) {\n            // next word is rtl\n            if (parsedText[wordIndex + 1].Type === textTypes.RTL) {\n              line = reverse + line;\n              splicePointer = 0;\n            } else {\n              line = spliceWord(line, splicePointer, subText.Word);\n              splicePointer += subText.Word.length;\n            }\n          }\n          // current word is weak or bracket, and it the last in this line\n          else {\n            line = spliceWord(line, 0, reverse);\n          }\n        }\n      }\n      // ltr line, rtl word\n      else if (subText.Type === textTypes.RTL) {\n        line = spliceWord(line, splicePointer, reverse);\n      }\n      // ltr line, ltr word\n      else if (subText.Type === textTypes.LTR) {\n        line += subText.Word;\n        splicePointer = line.length;\n      }\n      // ltr line, weak or bracket word\n      else if (\n        subText.Type === textTypes.WEAK ||\n        subText.Type === textTypes.BRACKETS\n      ) {\n        // not first word in line\n        if (wordIndex > 0) {\n          // last word was rtl\n          if (parsedText[wordIndex - 1].Type === textTypes.RTL) {\n            // there is at least one more word\n            if (parsedText.length > wordIndex + 1) {\n              // next word is rtl\n              if (parsedText[wordIndex + 1].Type === textTypes.RTL) {\n                line = spliceWord(line, splicePointer, reverse);\n              } else {\n                line += subText.Word;\n                splicePointer = line.length;\n              }\n            } else {\n              line += subText.Word;\n            }\n          } else {\n            line += subText.Word;\n            splicePointer = line.length;\n          }\n        } else {\n          line += subText.Word;\n          splicePointer = line.length;\n        }\n      }\n    }\n\n    result += line;\n    if (i < texts.length - 1) {\n      result += \"\\n\";\n    }\n  }\n  return result;\n}\nexport default Label;\n"]},"metadata":{},"sourceType":"module"}