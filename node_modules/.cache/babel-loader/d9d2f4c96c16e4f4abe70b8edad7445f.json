{"ast":null,"code":"//     JavaScript Expression Parser (JSEP) 0.3.1\n//     JSEP may be freely distributed under the MIT License\n//     http://jsep.from.so/\nvar tmp = {};\n/*global module: true, exports: true, console: true */\n\n(function (root) {\n  'use strict'; // Node Types\n  // ----------\n  // This is the full set of types that any JSEP node can be.\n  // Store them here to save space when minified\n\n  var COMPOUND = 'Compound',\n      IDENTIFIER = 'Identifier',\n      MEMBER_EXP = 'MemberExpression',\n      LITERAL = 'Literal',\n      THIS_EXP = 'ThisExpression',\n      CALL_EXP = 'CallExpression',\n      UNARY_EXP = 'UnaryExpression',\n      BINARY_EXP = 'BinaryExpression',\n      LOGICAL_EXP = 'LogicalExpression',\n      CONDITIONAL_EXP = 'ConditionalExpression',\n      ARRAY_EXP = 'ArrayExpression',\n      PERIOD_CODE = 46,\n      // '.'\n  COMMA_CODE = 44,\n      // ','\n  SQUOTE_CODE = 39,\n      // single quote\n  DQUOTE_CODE = 34,\n      // double quotes\n  OPAREN_CODE = 40,\n      // (\n  CPAREN_CODE = 41,\n      // )\n  OBRACK_CODE = 91,\n      // [\n  CBRACK_CODE = 93,\n      // ]\n  QUMARK_CODE = 63,\n      // ?\n  SEMCOL_CODE = 59,\n      // ;\n  COLON_CODE = 58,\n      // :\n  throwError = function (message, index) {\n    var error = new Error(message + ' at character ' + index);\n    error.index = index;\n    error.description = message;\n    throw error;\n  },\n      // Operations\n  // ----------\n  // Set `t` to `true` to save space (when minified, not gzipped)\n  t = true,\n      // Use a quickly-accessible map to store all of the unary operators\n  // Values are set to `true` (it really doesn't matter)\n  unary_ops = {\n    '-': t,\n    '!': t,\n    '~': t,\n    '+': t\n  },\n      // Also use a map for the binary operations but set their values to their\n  // binary precedence for quick reference:\n  // see [Order of operations](http://en.wikipedia.org/wiki/Order_of_operations#Programming_language)\n  binary_ops = {\n    '||': 1,\n    '&&': 2,\n    '|': 3,\n    '^': 4,\n    '&': 5,\n    '==': 6,\n    '!=': 6,\n    '===': 6,\n    '!==': 6,\n    '<': 7,\n    '>': 7,\n    '<=': 7,\n    '>=': 7,\n    '<<': 8,\n    '>>': 8,\n    '>>>': 8,\n    '+': 9,\n    '-': 9,\n    '*': 10,\n    '/': 10,\n    '%': 10\n  },\n      // Get return the longest key length of any object\n  getMaxKeyLen = function (obj) {\n    var max_len = 0,\n        len;\n\n    for (var key in obj) {\n      if ((len = key.length) > max_len && obj.hasOwnProperty(key)) {\n        max_len = len;\n      }\n    }\n\n    return max_len;\n  },\n      max_unop_len = getMaxKeyLen(unary_ops),\n      max_binop_len = getMaxKeyLen(binary_ops),\n      // Literals\n  // ----------\n  // Store the values to return for the various literals we may encounter\n  literals = {\n    'true': true,\n    'false': false,\n    'null': null\n  },\n      // Except for `this`, which is special. This could be changed to something like `'self'` as well\n  this_str = 'this',\n      // Returns the precedence of a binary operator or `0` if it isn't a binary operator\n  binaryPrecedence = function (op_val) {\n    return binary_ops[op_val] || 0;\n  },\n      // Utility function (gets called from multiple places)\n  // Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions\n  createBinaryExpression = function (operator, left, right) {\n    var type = operator === '||' || operator === '&&' ? LOGICAL_EXP : BINARY_EXP;\n    return {\n      type: type,\n      operator: operator,\n      left: left,\n      right: right\n    };\n  },\n      // `ch` is a character code in the next three functions\n  isDecimalDigit = function (ch) {\n    return ch >= 48 && ch <= 57; // 0...9\n  },\n      isIdentifierStart = function (ch) {\n    return ch === 36 || ch === 95 || // `$` and `_`\n    ch >= 65 && ch <= 90 || // A...Z\n    ch >= 97 && ch <= 122 || // a...z\n    ch >= 128 && !binary_ops[String.fromCharCode(ch)]; // any non-ASCII that is not an operator\n  },\n      isIdentifierPart = function (ch) {\n    return ch === 36 || ch === 95 || // `$` and `_`\n    ch >= 65 && ch <= 90 || // A...Z\n    ch >= 97 && ch <= 122 || // a...z\n    ch >= 48 && ch <= 57 || // 0...9\n    ch >= 128 && !binary_ops[String.fromCharCode(ch)]; // any non-ASCII that is not an operator\n  },\n      // Parsing\n  // -------\n  // `expr` is a string with the passed in expression\n  jsep = function (expr) {\n    // `index` stores the character number we are currently at while `length` is a constant\n    // All of the gobbles below will modify `index` as we move along\n    var index = 0,\n        charAtFunc = expr.charAt,\n        charCodeAtFunc = expr.charCodeAt,\n        exprI = function (i) {\n      return charAtFunc.call(expr, i);\n    },\n        exprICode = function (i) {\n      return charCodeAtFunc.call(expr, i);\n    },\n        length = expr.length,\n        // Push `index` up to the next non-space character\n    gobbleSpaces = function () {\n      var ch = exprICode(index); // space or tab\n\n      while (ch === 32 || ch === 9) {\n        ch = exprICode(++index);\n      }\n    },\n        // The main parsing function. Much of this code is dedicated to ternary expressions\n    gobbleExpression = function () {\n      var test = gobbleBinaryExpression(),\n          consequent,\n          alternate;\n      gobbleSpaces();\n\n      if (exprICode(index) === QUMARK_CODE) {\n        // Ternary expression: test ? consequent : alternate\n        index++;\n        consequent = gobbleExpression();\n\n        if (!consequent) {\n          throwError('Expected expression', index);\n        }\n\n        gobbleSpaces();\n\n        if (exprICode(index) === COLON_CODE) {\n          index++;\n          alternate = gobbleExpression();\n\n          if (!alternate) {\n            throwError('Expected expression', index);\n          }\n\n          return {\n            type: CONDITIONAL_EXP,\n            test: test,\n            consequent: consequent,\n            alternate: alternate\n          };\n        } else {\n          throwError('Expected :', index);\n        }\n      } else {\n        return test;\n      }\n    },\n        // Search for the operation portion of the string (e.g. `+`, `===`)\n    // Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\n    // and move down from 3 to 2 to 1 character until a matching binary operation is found\n    // then, return that binary operation\n    gobbleBinaryOp = function () {\n      gobbleSpaces();\n      var biop,\n          to_check = expr.substr(index, max_binop_len),\n          tc_len = to_check.length;\n\n      while (tc_len > 0) {\n        if (binary_ops.hasOwnProperty(to_check)) {\n          index += tc_len;\n          return to_check;\n        }\n\n        to_check = to_check.substr(0, --tc_len);\n      }\n\n      return false;\n    },\n        // This function is responsible for gobbling an individual expression,\n    // e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\n    gobbleBinaryExpression = function () {\n      var ch_i, node, biop, prec, stack, biop_info, left, right, i; // First, try to get the leftmost thing\n      // Then, check to see if there's a binary operator operating on that leftmost thing\n\n      left = gobbleToken();\n      biop = gobbleBinaryOp(); // If there wasn't a binary operator, just return the leftmost node\n\n      if (!biop) {\n        return left;\n      } // Otherwise, we need to start a stack to properly place the binary operations in their\n      // precedence structure\n\n\n      biop_info = {\n        value: biop,\n        prec: binaryPrecedence(biop)\n      };\n      right = gobbleToken();\n\n      if (!right) {\n        throwError(\"Expected expression after \" + biop, index);\n      }\n\n      stack = [left, biop_info, right]; // Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\n\n      while (biop = gobbleBinaryOp()) {\n        prec = binaryPrecedence(biop);\n\n        if (prec === 0) {\n          break;\n        }\n\n        biop_info = {\n          value: biop,\n          prec: prec\n        }; // Reduce: make a binary expression from the three topmost entries.\n\n        while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {\n          right = stack.pop();\n          biop = stack.pop().value;\n          left = stack.pop();\n          node = createBinaryExpression(biop, left, right);\n          stack.push(node);\n        }\n\n        node = gobbleToken();\n\n        if (!node) {\n          throwError(\"Expected expression after \" + biop, index);\n        }\n\n        stack.push(biop_info, node);\n      }\n\n      i = stack.length - 1;\n      node = stack[i];\n\n      while (i > 1) {\n        node = createBinaryExpression(stack[i - 1].value, stack[i - 2], node);\n        i -= 2;\n      }\n\n      return node;\n    },\n        // An individual part of a binary expression:\n    // e.g. `foo.bar(baz)`, `1`, `\"abc\"`, `(a % 2)` (because it's in parenthesis)\n    gobbleToken = function () {\n      var ch, to_check, tc_len;\n      gobbleSpaces();\n      ch = exprICode(index);\n\n      if (isDecimalDigit(ch) || ch === PERIOD_CODE) {\n        // Char code 46 is a dot `.` which can start off a numeric literal\n        return gobbleNumericLiteral();\n      } else if (ch === SQUOTE_CODE || ch === DQUOTE_CODE) {\n        // Single or double quotes\n        return gobbleStringLiteral();\n      } else if (isIdentifierStart(ch) || ch === OPAREN_CODE) {\n        // open parenthesis\n        // `foo`, `bar.baz`\n        return gobbleVariable();\n      } else if (ch === OBRACK_CODE) {\n        return gobbleArray();\n      } else {\n        to_check = expr.substr(index, max_unop_len);\n        tc_len = to_check.length;\n\n        while (tc_len > 0) {\n          if (unary_ops.hasOwnProperty(to_check)) {\n            index += tc_len;\n            return {\n              type: UNARY_EXP,\n              operator: to_check,\n              argument: gobbleToken(),\n              prefix: true\n            };\n          }\n\n          to_check = to_check.substr(0, --tc_len);\n        }\n\n        return false;\n      }\n    },\n        // Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\n    // keep track of everything in the numeric literal and then calling `parseFloat` on that string\n    gobbleNumericLiteral = function () {\n      var number = '',\n          ch,\n          chCode;\n\n      while (isDecimalDigit(exprICode(index))) {\n        number += exprI(index++);\n      }\n\n      if (exprICode(index) === PERIOD_CODE) {\n        // can start with a decimal marker\n        number += exprI(index++);\n\n        while (isDecimalDigit(exprICode(index))) {\n          number += exprI(index++);\n        }\n      }\n\n      ch = exprI(index);\n\n      if (ch === 'e' || ch === 'E') {\n        // exponent marker\n        number += exprI(index++);\n        ch = exprI(index);\n\n        if (ch === '+' || ch === '-') {\n          // exponent sign\n          number += exprI(index++);\n        }\n\n        while (isDecimalDigit(exprICode(index))) {\n          //exponent itself\n          number += exprI(index++);\n        }\n\n        if (!isDecimalDigit(exprICode(index - 1))) {\n          throwError('Expected exponent (' + number + exprI(index) + ')', index);\n        }\n      }\n\n      chCode = exprICode(index); // Check to make sure this isn't a variable name that start with a number (123abc)\n\n      if (isIdentifierStart(chCode)) {\n        throwError('Variable names cannot start with a number (' + number + exprI(index) + ')', index);\n      } else if (chCode === PERIOD_CODE) {\n        throwError('Unexpected period', index);\n      }\n\n      return {\n        type: LITERAL,\n        value: parseFloat(number),\n        raw: number\n      };\n    },\n        // Parses a string literal, staring with single or double quotes with basic support for escape codes\n    // e.g. `\"hello world\"`, `'this is\\nJSEP'`\n    gobbleStringLiteral = function () {\n      var str = '',\n          quote = exprI(index++),\n          closed = false,\n          ch;\n\n      while (index < length) {\n        ch = exprI(index++);\n\n        if (ch === quote) {\n          closed = true;\n          break;\n        } else if (ch === '\\\\') {\n          // Check for all of the common escape codes\n          ch = exprI(index++);\n\n          switch (ch) {\n            case 'n':\n              str += '\\n';\n              break;\n\n            case 'r':\n              str += '\\r';\n              break;\n\n            case 't':\n              str += '\\t';\n              break;\n\n            case 'b':\n              str += '\\b';\n              break;\n\n            case 'f':\n              str += '\\f';\n              break;\n\n            case 'v':\n              str += '\\x0B';\n              break;\n\n            default:\n              str += '\\\\' + ch;\n          }\n        } else {\n          str += ch;\n        }\n      }\n\n      if (!closed) {\n        throwError('Unclosed quote after \"' + str + '\"', index);\n      }\n\n      return {\n        type: LITERAL,\n        value: str,\n        raw: quote + str + quote\n      };\n    },\n        // Gobbles only identifiers\n    // e.g.: `foo`, `_value`, `$x1`\n    // Also, this function checks if that identifier is a literal:\n    // (e.g. `true`, `false`, `null`) or `this`\n    gobbleIdentifier = function () {\n      var ch = exprICode(index),\n          start = index,\n          identifier;\n\n      if (isIdentifierStart(ch)) {\n        index++;\n      } else {\n        throwError('Unexpected ' + exprI(index), index);\n      }\n\n      while (index < length) {\n        ch = exprICode(index);\n\n        if (isIdentifierPart(ch)) {\n          index++;\n        } else {\n          break;\n        }\n      }\n\n      identifier = expr.slice(start, index);\n\n      if (literals.hasOwnProperty(identifier)) {\n        return {\n          type: LITERAL,\n          value: literals[identifier],\n          raw: identifier\n        };\n      } else if (identifier === this_str) {\n        return {\n          type: THIS_EXP\n        };\n      } else {\n        return {\n          type: IDENTIFIER,\n          name: identifier\n        };\n      }\n    },\n        // Gobbles a list of arguments within the context of a function call\n    // or array literal. This function also assumes that the opening character\n    // `(` or `[` has already been gobbled, and gobbles expressions and commas\n    // until the terminator character `)` or `]` is encountered.\n    // e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\n    gobbleArguments = function (termination) {\n      var ch_i,\n          args = [],\n          node,\n          closed = false;\n\n      while (index < length) {\n        gobbleSpaces();\n        ch_i = exprICode(index);\n\n        if (ch_i === termination) {\n          // done parsing\n          closed = true;\n          index++;\n          break;\n        } else if (ch_i === COMMA_CODE) {\n          // between expressions\n          index++;\n        } else {\n          node = gobbleExpression();\n\n          if (!node || node.type === COMPOUND) {\n            throwError('Expected comma', index);\n          }\n\n          args.push(node);\n        }\n      }\n\n      if (!closed) {\n        throwError('Expected ' + String.fromCharCode(termination), index);\n      }\n\n      return args;\n    },\n        // Gobble a non-literal variable name. This variable name may include properties\n    // e.g. `foo`, `bar.baz`, `foo['bar'].baz`\n    // It also gobbles function calls:\n    // e.g. `Math.acos(obj.angle)`\n    gobbleVariable = function () {\n      var ch_i, node;\n      ch_i = exprICode(index);\n\n      if (ch_i === OPAREN_CODE) {\n        node = gobbleGroup();\n      } else {\n        node = gobbleIdentifier();\n      }\n\n      gobbleSpaces();\n      ch_i = exprICode(index);\n\n      while (ch_i === PERIOD_CODE || ch_i === OBRACK_CODE || ch_i === OPAREN_CODE) {\n        index++;\n\n        if (ch_i === PERIOD_CODE) {\n          gobbleSpaces();\n          node = {\n            type: MEMBER_EXP,\n            computed: false,\n            object: node,\n            property: gobbleIdentifier()\n          };\n        } else if (ch_i === OBRACK_CODE) {\n          node = {\n            type: MEMBER_EXP,\n            computed: true,\n            object: node,\n            property: gobbleExpression()\n          };\n          gobbleSpaces();\n          ch_i = exprICode(index);\n\n          if (ch_i !== CBRACK_CODE) {\n            throwError('Unclosed [', index);\n          }\n\n          index++;\n        } else if (ch_i === OPAREN_CODE) {\n          // A function call is being made; gobble all the arguments\n          node = {\n            type: CALL_EXP,\n            'arguments': gobbleArguments(CPAREN_CODE),\n            callee: node\n          };\n        }\n\n        gobbleSpaces();\n        ch_i = exprICode(index);\n      }\n\n      return node;\n    },\n        // Responsible for parsing a group of things within parentheses `()`\n    // This function assumes that it needs to gobble the opening parenthesis\n    // and then tries to gobble everything within that parenthesis, assuming\n    // that the next thing it should see is the close parenthesis. If not,\n    // then the expression probably doesn't have a `)`\n    gobbleGroup = function () {\n      index++;\n      var node = gobbleExpression();\n      gobbleSpaces();\n\n      if (exprICode(index) === CPAREN_CODE) {\n        index++;\n        return node;\n      } else {\n        throwError('Unclosed (', index);\n      }\n    },\n        // Responsible for parsing Array literals `[1, 2, 3]`\n    // This function assumes that it needs to gobble the opening bracket\n    // and then tries to gobble the expressions as arguments.\n    gobbleArray = function () {\n      index++;\n      return {\n        type: ARRAY_EXP,\n        elements: gobbleArguments(CBRACK_CODE)\n      };\n    },\n        nodes = [],\n        ch_i,\n        node;\n\n    while (index < length) {\n      ch_i = exprICode(index); // Expressions can be separated by semicolons, commas, or just inferred without any\n      // separators\n\n      if (ch_i === SEMCOL_CODE || ch_i === COMMA_CODE) {\n        index++; // ignore separators\n      } else {\n        // Try to gobble each expression individually\n        if (node = gobbleExpression()) {\n          nodes.push(node); // If we weren't able to find a binary expression and are out of room, then\n          // the expression passed in probably has too much\n        } else if (index < length) {\n          throwError('Unexpected \"' + exprI(index) + '\"', index);\n        }\n      }\n    } // If there's only one expression just try returning the expression\n\n\n    if (nodes.length === 1) {\n      return nodes[0];\n    } else {\n      return {\n        type: COMPOUND,\n        body: nodes\n      };\n    }\n  }; // To be filled in by the template\n\n\n  jsep.version = '0.3.1';\n\n  jsep.toString = function () {\n    return 'JavaScript Expression Parser (JSEP) v' + jsep.version;\n  };\n  /**\n   * @method jsep.addUnaryOp\n   * @param {string} op_name The name of the unary op to add\n   * @return jsep\n   */\n\n\n  jsep.addUnaryOp = function (op_name) {\n    max_unop_len = Math.max(op_name.length, max_unop_len);\n    unary_ops[op_name] = t;\n    return this;\n  };\n  /**\n   * @method jsep.addBinaryOp\n   * @param {string} op_name The name of the binary op to add\n   * @param {number} precedence The precedence of the binary op (can be a float)\n   * @return jsep\n   */\n\n\n  jsep.addBinaryOp = function (op_name, precedence) {\n    max_binop_len = Math.max(op_name.length, max_binop_len);\n    binary_ops[op_name] = precedence;\n    return this;\n  };\n  /**\n   * @method jsep.addLiteral\n   * @param {string} literal_name The name of the literal to add\n   * @param {*} literal_value The value of the literal\n   * @return jsep\n   */\n\n\n  jsep.addLiteral = function (literal_name, literal_value) {\n    literals[literal_name] = literal_value;\n    return this;\n  };\n  /**\n   * @method jsep.removeUnaryOp\n   * @param {string} op_name The name of the unary op to remove\n   * @return jsep\n   */\n\n\n  jsep.removeUnaryOp = function (op_name) {\n    delete unary_ops[op_name];\n\n    if (op_name.length === max_unop_len) {\n      max_unop_len = getMaxKeyLen(unary_ops);\n    }\n\n    return this;\n  };\n  /**\n   * @method jsep.removeAllUnaryOps\n   * @return jsep\n   */\n\n\n  jsep.removeAllUnaryOps = function () {\n    unary_ops = {};\n    max_unop_len = 0;\n    return this;\n  };\n  /**\n   * @method jsep.removeBinaryOp\n   * @param {string} op_name The name of the binary op to remove\n   * @return jsep\n   */\n\n\n  jsep.removeBinaryOp = function (op_name) {\n    delete binary_ops[op_name];\n\n    if (op_name.length === max_binop_len) {\n      max_binop_len = getMaxKeyLen(binary_ops);\n    }\n\n    return this;\n  };\n  /**\n   * @method jsep.removeAllBinaryOps\n   * @return jsep\n   */\n\n\n  jsep.removeAllBinaryOps = function () {\n    binary_ops = {};\n    max_binop_len = 0;\n    return this;\n  };\n  /**\n   * @method jsep.removeLiteral\n   * @param {string} literal_name The name of the literal to remove\n   * @return jsep\n   */\n\n\n  jsep.removeLiteral = function (literal_name) {\n    delete literals[literal_name];\n    return this;\n  };\n  /**\n   * @method jsep.removeAllLiterals\n   * @return jsep\n   */\n\n\n  jsep.removeAllLiterals = function () {\n    literals = {};\n    return this;\n  };\n\n  root.jsep = jsep;\n})(tmp);\n\nexport default tmp.jsep;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/ThirdParty/jsep.js"],"names":["tmp","root","COMPOUND","IDENTIFIER","MEMBER_EXP","LITERAL","THIS_EXP","CALL_EXP","UNARY_EXP","BINARY_EXP","LOGICAL_EXP","CONDITIONAL_EXP","ARRAY_EXP","PERIOD_CODE","COMMA_CODE","SQUOTE_CODE","DQUOTE_CODE","OPAREN_CODE","CPAREN_CODE","OBRACK_CODE","CBRACK_CODE","QUMARK_CODE","SEMCOL_CODE","COLON_CODE","throwError","message","index","error","Error","description","t","unary_ops","binary_ops","getMaxKeyLen","obj","max_len","len","key","length","hasOwnProperty","max_unop_len","max_binop_len","literals","this_str","binaryPrecedence","op_val","createBinaryExpression","operator","left","right","type","isDecimalDigit","ch","isIdentifierStart","String","fromCharCode","isIdentifierPart","jsep","expr","charAtFunc","charAt","charCodeAtFunc","charCodeAt","exprI","i","call","exprICode","gobbleSpaces","gobbleExpression","test","gobbleBinaryExpression","consequent","alternate","gobbleBinaryOp","biop","to_check","substr","tc_len","ch_i","node","prec","stack","biop_info","gobbleToken","value","pop","push","gobbleNumericLiteral","gobbleStringLiteral","gobbleVariable","gobbleArray","argument","prefix","number","chCode","parseFloat","raw","str","quote","closed","gobbleIdentifier","start","identifier","slice","name","gobbleArguments","termination","args","gobbleGroup","computed","object","property","callee","elements","nodes","body","version","toString","addUnaryOp","op_name","Math","max","addBinaryOp","precedence","addLiteral","literal_name","literal_value","removeUnaryOp","removeAllUnaryOps","removeBinaryOp","removeAllBinaryOps","removeLiteral","removeAllLiterals"],"mappings":"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","sourcesContent":["//     JavaScript Expression Parser (JSEP) 0.3.1\n//     JSEP may be freely distributed under the MIT License\n//     http://jsep.from.so/\n\nvar tmp = {};\n\n/*global module: true, exports: true, console: true */\n(function (root) {\n\t'use strict';\n\t// Node Types\n\t// ----------\n\n\t// This is the full set of types that any JSEP node can be.\n\t// Store them here to save space when minified\n\tvar COMPOUND = 'Compound',\n\t\tIDENTIFIER = 'Identifier',\n\t\tMEMBER_EXP = 'MemberExpression',\n\t\tLITERAL = 'Literal',\n\t\tTHIS_EXP = 'ThisExpression',\n\t\tCALL_EXP = 'CallExpression',\n\t\tUNARY_EXP = 'UnaryExpression',\n\t\tBINARY_EXP = 'BinaryExpression',\n\t\tLOGICAL_EXP = 'LogicalExpression',\n\t\tCONDITIONAL_EXP = 'ConditionalExpression',\n\t\tARRAY_EXP = 'ArrayExpression',\n\n\t\tPERIOD_CODE = 46, // '.'\n\t\tCOMMA_CODE  = 44, // ','\n\t\tSQUOTE_CODE = 39, // single quote\n\t\tDQUOTE_CODE = 34, // double quotes\n\t\tOPAREN_CODE = 40, // (\n\t\tCPAREN_CODE = 41, // )\n\t\tOBRACK_CODE = 91, // [\n\t\tCBRACK_CODE = 93, // ]\n\t\tQUMARK_CODE = 63, // ?\n\t\tSEMCOL_CODE = 59, // ;\n\t\tCOLON_CODE  = 58, // :\n\n\t\tthrowError = function(message, index) {\n\t\t\tvar error = new Error(message + ' at character ' + index);\n\t\t\terror.index = index;\n\t\t\terror.description = message;\n\t\t\tthrow error;\n\t\t},\n\n\t// Operations\n\t// ----------\n\n\t// Set `t` to `true` to save space (when minified, not gzipped)\n\t\tt = true,\n\t// Use a quickly-accessible map to store all of the unary operators\n\t// Values are set to `true` (it really doesn't matter)\n\t\tunary_ops = {'-': t, '!': t, '~': t, '+': t},\n\t// Also use a map for the binary operations but set their values to their\n\t// binary precedence for quick reference:\n\t// see [Order of operations](http://en.wikipedia.org/wiki/Order_of_operations#Programming_language)\n\t\tbinary_ops = {\n\t\t\t'||': 1, '&&': 2, '|': 3,  '^': 4,  '&': 5,\n\t\t\t'==': 6, '!=': 6, '===': 6, '!==': 6,\n\t\t\t'<': 7,  '>': 7,  '<=': 7,  '>=': 7,\n\t\t\t'<<':8,  '>>': 8, '>>>': 8,\n\t\t\t'+': 9, '-': 9,\n\t\t\t'*': 10, '/': 10, '%': 10\n\t\t},\n\t// Get return the longest key length of any object\n\t\tgetMaxKeyLen = function(obj) {\n\t\t\tvar max_len = 0, len;\n\t\t\tfor(var key in obj) {\n\t\t\t\tif((len = key.length) > max_len && obj.hasOwnProperty(key)) {\n\t\t\t\t\tmax_len = len;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn max_len;\n\t\t},\n\t\tmax_unop_len = getMaxKeyLen(unary_ops),\n\t\tmax_binop_len = getMaxKeyLen(binary_ops),\n\t// Literals\n\t// ----------\n\t// Store the values to return for the various literals we may encounter\n\t\tliterals = {\n\t\t\t'true': true,\n\t\t\t'false': false,\n\t\t\t'null': null\n\t\t},\n\t// Except for `this`, which is special. This could be changed to something like `'self'` as well\n\t\tthis_str = 'this',\n\t// Returns the precedence of a binary operator or `0` if it isn't a binary operator\n\t\tbinaryPrecedence = function(op_val) {\n\t\t\treturn binary_ops[op_val] || 0;\n\t\t},\n\t// Utility function (gets called from multiple places)\n\t// Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions\n\t\tcreateBinaryExpression = function (operator, left, right) {\n\t\t\tvar type = (operator === '||' || operator === '&&') ? LOGICAL_EXP : BINARY_EXP;\n\t\t\treturn {\n\t\t\t\ttype: type,\n\t\t\t\toperator: operator,\n\t\t\t\tleft: left,\n\t\t\t\tright: right\n\t\t\t};\n\t\t},\n\t\t// `ch` is a character code in the next three functions\n\t\tisDecimalDigit = function(ch) {\n\t\t\treturn (ch >= 48 && ch <= 57); // 0...9\n\t\t},\n\t\tisIdentifierStart = function(ch) {\n\t\t\treturn (ch === 36) || (ch === 95) || // `$` and `_`\n\t\t\t\t\t(ch >= 65 && ch <= 90) || // A...Z\n\t\t\t\t\t(ch >= 97 && ch <= 122) || // a...z\n                    (ch >= 128 && !binary_ops[String.fromCharCode(ch)]); // any non-ASCII that is not an operator\n\t\t},\n\t\tisIdentifierPart = function(ch) {\n\t\t\treturn (ch === 36) || (ch === 95) || // `$` and `_`\n\t\t\t\t\t(ch >= 65 && ch <= 90) || // A...Z\n\t\t\t\t\t(ch >= 97 && ch <= 122) || // a...z\n\t\t\t\t\t(ch >= 48 && ch <= 57) || // 0...9\n                    (ch >= 128 && !binary_ops[String.fromCharCode(ch)]); // any non-ASCII that is not an operator\n\t\t},\n\n\t\t// Parsing\n\t\t// -------\n\t\t// `expr` is a string with the passed in expression\n\t\tjsep = function(expr) {\n\t\t\t// `index` stores the character number we are currently at while `length` is a constant\n\t\t\t// All of the gobbles below will modify `index` as we move along\n\t\t\tvar index = 0,\n\t\t\t\tcharAtFunc = expr.charAt,\n\t\t\t\tcharCodeAtFunc = expr.charCodeAt,\n\t\t\t\texprI = function(i) { return charAtFunc.call(expr, i); },\n\t\t\t\texprICode = function(i) { return charCodeAtFunc.call(expr, i); },\n\t\t\t\tlength = expr.length,\n\n\t\t\t\t// Push `index` up to the next non-space character\n\t\t\t\tgobbleSpaces = function() {\n\t\t\t\t\tvar ch = exprICode(index);\n\t\t\t\t\t// space or tab\n\t\t\t\t\twhile(ch === 32 || ch === 9) {\n\t\t\t\t\t\tch = exprICode(++index);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// The main parsing function. Much of this code is dedicated to ternary expressions\n\t\t\t\tgobbleExpression = function() {\n\t\t\t\t\tvar test = gobbleBinaryExpression(),\n\t\t\t\t\t\tconsequent, alternate;\n\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\tif(exprICode(index) === QUMARK_CODE) {\n\t\t\t\t\t\t// Ternary expression: test ? consequent : alternate\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tconsequent = gobbleExpression();\n\t\t\t\t\t\tif(!consequent) {\n\t\t\t\t\t\t\tthrowError('Expected expression', index);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\t\tif(exprICode(index) === COLON_CODE) {\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t\talternate = gobbleExpression();\n\t\t\t\t\t\t\tif(!alternate) {\n\t\t\t\t\t\t\t\tthrowError('Expected expression', index);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\ttype: CONDITIONAL_EXP,\n\t\t\t\t\t\t\t\ttest: test,\n\t\t\t\t\t\t\t\tconsequent: consequent,\n\t\t\t\t\t\t\t\talternate: alternate\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrowError('Expected :', index);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn test;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Search for the operation portion of the string (e.g. `+`, `===`)\n\t\t\t\t// Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\n\t\t\t\t// and move down from 3 to 2 to 1 character until a matching binary operation is found\n\t\t\t\t// then, return that binary operation\n\t\t\t\tgobbleBinaryOp = function() {\n\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\tvar biop, to_check = expr.substr(index, max_binop_len), tc_len = to_check.length;\n\t\t\t\t\twhile(tc_len > 0) {\n\t\t\t\t\t\tif(binary_ops.hasOwnProperty(to_check)) {\n\t\t\t\t\t\t\tindex += tc_len;\n\t\t\t\t\t\t\treturn to_check;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tto_check = to_check.substr(0, --tc_len);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t},\n\n\t\t\t\t// This function is responsible for gobbling an individual expression,\n\t\t\t\t// e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\n\t\t\t\tgobbleBinaryExpression = function() {\n\t\t\t\t\tvar ch_i, node, biop, prec, stack, biop_info, left, right, i;\n\n\t\t\t\t\t// First, try to get the leftmost thing\n\t\t\t\t\t// Then, check to see if there's a binary operator operating on that leftmost thing\n\t\t\t\t\tleft = gobbleToken();\n\t\t\t\t\tbiop = gobbleBinaryOp();\n\n\t\t\t\t\t// If there wasn't a binary operator, just return the leftmost node\n\t\t\t\t\tif(!biop) {\n\t\t\t\t\t\treturn left;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Otherwise, we need to start a stack to properly place the binary operations in their\n\t\t\t\t\t// precedence structure\n\t\t\t\t\tbiop_info = { value: biop, prec: binaryPrecedence(biop)};\n\n\t\t\t\t\tright = gobbleToken();\n\t\t\t\t\tif(!right) {\n\t\t\t\t\t\tthrowError(\"Expected expression after \" + biop, index);\n\t\t\t\t\t}\n\t\t\t\t\tstack = [left, biop_info, right];\n\n\t\t\t\t\t// Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\n\t\t\t\t\twhile((biop = gobbleBinaryOp())) {\n\t\t\t\t\t\tprec = binaryPrecedence(biop);\n\n\t\t\t\t\t\tif(prec === 0) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbiop_info = { value: biop, prec: prec };\n\n\t\t\t\t\t\t// Reduce: make a binary expression from the three topmost entries.\n\t\t\t\t\t\twhile ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n\t\t\t\t\t\t\tright = stack.pop();\n\t\t\t\t\t\t\tbiop = stack.pop().value;\n\t\t\t\t\t\t\tleft = stack.pop();\n\t\t\t\t\t\t\tnode = createBinaryExpression(biop, left, right);\n\t\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnode = gobbleToken();\n\t\t\t\t\t\tif(!node) {\n\t\t\t\t\t\t\tthrowError(\"Expected expression after \" + biop, index);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstack.push(biop_info, node);\n\t\t\t\t\t}\n\n\t\t\t\t\ti = stack.length - 1;\n\t\t\t\t\tnode = stack[i];\n\t\t\t\t\twhile(i > 1) {\n\t\t\t\t\t\tnode = createBinaryExpression(stack[i - 1].value, stack[i - 2], node);\n\t\t\t\t\t\ti -= 2;\n\t\t\t\t\t}\n\t\t\t\t\treturn node;\n\t\t\t\t},\n\n\t\t\t\t// An individual part of a binary expression:\n\t\t\t\t// e.g. `foo.bar(baz)`, `1`, `\"abc\"`, `(a % 2)` (because it's in parenthesis)\n\t\t\t\tgobbleToken = function() {\n\t\t\t\t\tvar ch, to_check, tc_len;\n\n\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\tch = exprICode(index);\n\n\t\t\t\t\tif(isDecimalDigit(ch) || ch === PERIOD_CODE) {\n\t\t\t\t\t\t// Char code 46 is a dot `.` which can start off a numeric literal\n\t\t\t\t\t\treturn gobbleNumericLiteral();\n\t\t\t\t\t} else if(ch === SQUOTE_CODE || ch === DQUOTE_CODE) {\n\t\t\t\t\t\t// Single or double quotes\n\t\t\t\t\t\treturn gobbleStringLiteral();\n\t\t\t\t\t} else if(isIdentifierStart(ch) || ch === OPAREN_CODE) { // open parenthesis\n\t\t\t\t\t\t// `foo`, `bar.baz`\n\t\t\t\t\t\treturn gobbleVariable();\n\t\t\t\t\t} else if (ch === OBRACK_CODE) {\n\t\t\t\t\t\treturn gobbleArray();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tto_check = expr.substr(index, max_unop_len);\n\t\t\t\t\t\ttc_len = to_check.length;\n\t\t\t\t\t\twhile(tc_len > 0) {\n\t\t\t\t\t\t\tif(unary_ops.hasOwnProperty(to_check)) {\n\t\t\t\t\t\t\t\tindex += tc_len;\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\ttype: UNARY_EXP,\n\t\t\t\t\t\t\t\t\toperator: to_check,\n\t\t\t\t\t\t\t\t\targument: gobbleToken(),\n\t\t\t\t\t\t\t\t\tprefix: true\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tto_check = to_check.substr(0, --tc_len);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t// Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\n\t\t\t\t// keep track of everything in the numeric literal and then calling `parseFloat` on that string\n\t\t\t\tgobbleNumericLiteral = function() {\n\t\t\t\t\tvar number = '', ch, chCode;\n\t\t\t\t\twhile(isDecimalDigit(exprICode(index))) {\n\t\t\t\t\t\tnumber += exprI(index++);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(exprICode(index) === PERIOD_CODE) { // can start with a decimal marker\n\t\t\t\t\t\tnumber += exprI(index++);\n\n\t\t\t\t\t\twhile(isDecimalDigit(exprICode(index))) {\n\t\t\t\t\t\t\tnumber += exprI(index++);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tch = exprI(index);\n\t\t\t\t\tif(ch === 'e' || ch === 'E') { // exponent marker\n\t\t\t\t\t\tnumber += exprI(index++);\n\t\t\t\t\t\tch = exprI(index);\n\t\t\t\t\t\tif(ch === '+' || ch === '-') { // exponent sign\n\t\t\t\t\t\t\tnumber += exprI(index++);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile(isDecimalDigit(exprICode(index))) { //exponent itself\n\t\t\t\t\t\t\tnumber += exprI(index++);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!isDecimalDigit(exprICode(index-1)) ) {\n\t\t\t\t\t\t\tthrowError('Expected exponent (' + number + exprI(index) + ')', index);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t\tchCode = exprICode(index);\n\t\t\t\t\t// Check to make sure this isn't a variable name that start with a number (123abc)\n\t\t\t\t\tif(isIdentifierStart(chCode)) {\n\t\t\t\t\t\tthrowError('Variable names cannot start with a number (' +\n\t\t\t\t\t\t\t\t\tnumber + exprI(index) + ')', index);\n\t\t\t\t\t} else if(chCode === PERIOD_CODE) {\n\t\t\t\t\t\tthrowError('Unexpected period', index);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: LITERAL,\n\t\t\t\t\t\tvalue: parseFloat(number),\n\t\t\t\t\t\traw: number\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\t// Parses a string literal, staring with single or double quotes with basic support for escape codes\n\t\t\t\t// e.g. `\"hello world\"`, `'this is\\nJSEP'`\n\t\t\t\tgobbleStringLiteral = function() {\n\t\t\t\t\tvar str = '', quote = exprI(index++), closed = false, ch;\n\n\t\t\t\t\twhile(index < length) {\n\t\t\t\t\t\tch = exprI(index++);\n\t\t\t\t\t\tif(ch === quote) {\n\t\t\t\t\t\t\tclosed = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if(ch === '\\\\') {\n\t\t\t\t\t\t\t// Check for all of the common escape codes\n\t\t\t\t\t\t\tch = exprI(index++);\n\t\t\t\t\t\t\tswitch(ch) {\n\t\t\t\t\t\t\t\tcase 'n': str += '\\n'; break;\n\t\t\t\t\t\t\t\tcase 'r': str += '\\r'; break;\n\t\t\t\t\t\t\t\tcase 't': str += '\\t'; break;\n\t\t\t\t\t\t\t\tcase 'b': str += '\\b'; break;\n\t\t\t\t\t\t\t\tcase 'f': str += '\\f'; break;\n\t\t\t\t\t\t\t\tcase 'v': str += '\\x0B'; break;\n\t\t\t\t\t\t\t\tdefault : str += '\\\\' + ch;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstr += ch;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!closed) {\n\t\t\t\t\t\tthrowError('Unclosed quote after \"'+str+'\"', index);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: LITERAL,\n\t\t\t\t\t\tvalue: str,\n\t\t\t\t\t\traw: quote + str + quote\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\t// Gobbles only identifiers\n\t\t\t\t// e.g.: `foo`, `_value`, `$x1`\n\t\t\t\t// Also, this function checks if that identifier is a literal:\n\t\t\t\t// (e.g. `true`, `false`, `null`) or `this`\n\t\t\t\tgobbleIdentifier = function() {\n\t\t\t\t\tvar ch = exprICode(index), start = index, identifier;\n\n\t\t\t\t\tif(isIdentifierStart(ch)) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrowError('Unexpected ' + exprI(index), index);\n\t\t\t\t\t}\n\n\t\t\t\t\twhile(index < length) {\n\t\t\t\t\t\tch = exprICode(index);\n\t\t\t\t\t\tif(isIdentifierPart(ch)) {\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tidentifier = expr.slice(start, index);\n\n\t\t\t\t\tif(literals.hasOwnProperty(identifier)) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttype: LITERAL,\n\t\t\t\t\t\t\tvalue: literals[identifier],\n\t\t\t\t\t\t\traw: identifier\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if(identifier === this_str) {\n\t\t\t\t\t\treturn { type: THIS_EXP };\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttype: IDENTIFIER,\n\t\t\t\t\t\t\tname: identifier\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Gobbles a list of arguments within the context of a function call\n\t\t\t\t// or array literal. This function also assumes that the opening character\n\t\t\t\t// `(` or `[` has already been gobbled, and gobbles expressions and commas\n\t\t\t\t// until the terminator character `)` or `]` is encountered.\n\t\t\t\t// e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\n\t\t\t\tgobbleArguments = function(termination) {\n\t\t\t\t\tvar ch_i, args = [], node, closed = false;\n\t\t\t\t\twhile(index < length) {\n\t\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\t\tch_i = exprICode(index);\n\t\t\t\t\t\tif(ch_i === termination) { // done parsing\n\t\t\t\t\t\t\tclosed = true;\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (ch_i === COMMA_CODE) { // between expressions\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnode = gobbleExpression();\n\t\t\t\t\t\t\tif(!node || node.type === COMPOUND) {\n\t\t\t\t\t\t\t\tthrowError('Expected comma', index);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targs.push(node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!closed) {\n\t\t\t\t\t\tthrowError('Expected ' + String.fromCharCode(termination), index);\n\t\t\t\t\t}\n\t\t\t\t\treturn args;\n\t\t\t\t},\n\n\t\t\t\t// Gobble a non-literal variable name. This variable name may include properties\n\t\t\t\t// e.g. `foo`, `bar.baz`, `foo['bar'].baz`\n\t\t\t\t// It also gobbles function calls:\n\t\t\t\t// e.g. `Math.acos(obj.angle)`\n\t\t\t\tgobbleVariable = function() {\n\t\t\t\t\tvar ch_i, node;\n\t\t\t\t\tch_i = exprICode(index);\n\n\t\t\t\t\tif(ch_i === OPAREN_CODE) {\n\t\t\t\t\t\tnode = gobbleGroup();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode = gobbleIdentifier();\n\t\t\t\t\t}\n\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\tch_i = exprICode(index);\n\t\t\t\t\twhile(ch_i === PERIOD_CODE || ch_i === OBRACK_CODE || ch_i === OPAREN_CODE) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tif(ch_i === PERIOD_CODE) {\n\t\t\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\t\t\tnode = {\n\t\t\t\t\t\t\t\ttype: MEMBER_EXP,\n\t\t\t\t\t\t\t\tcomputed: false,\n\t\t\t\t\t\t\t\tobject: node,\n\t\t\t\t\t\t\t\tproperty: gobbleIdentifier()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else if(ch_i === OBRACK_CODE) {\n\t\t\t\t\t\t\tnode = {\n\t\t\t\t\t\t\t\ttype: MEMBER_EXP,\n\t\t\t\t\t\t\t\tcomputed: true,\n\t\t\t\t\t\t\t\tobject: node,\n\t\t\t\t\t\t\t\tproperty: gobbleExpression()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\t\t\tch_i = exprICode(index);\n\t\t\t\t\t\t\tif(ch_i !== CBRACK_CODE) {\n\t\t\t\t\t\t\t\tthrowError('Unclosed [', index);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t} else if(ch_i === OPAREN_CODE) {\n\t\t\t\t\t\t\t// A function call is being made; gobble all the arguments\n\t\t\t\t\t\t\tnode = {\n\t\t\t\t\t\t\t\ttype: CALL_EXP,\n\t\t\t\t\t\t\t\t'arguments': gobbleArguments(CPAREN_CODE),\n\t\t\t\t\t\t\t\tcallee: node\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\t\tch_i = exprICode(index);\n\t\t\t\t\t}\n\t\t\t\t\treturn node;\n\t\t\t\t},\n\n\t\t\t\t// Responsible for parsing a group of things within parentheses `()`\n\t\t\t\t// This function assumes that it needs to gobble the opening parenthesis\n\t\t\t\t// and then tries to gobble everything within that parenthesis, assuming\n\t\t\t\t// that the next thing it should see is the close parenthesis. If not,\n\t\t\t\t// then the expression probably doesn't have a `)`\n\t\t\t\tgobbleGroup = function() {\n\t\t\t\t\tindex++;\n\t\t\t\t\tvar node = gobbleExpression();\n\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\tif(exprICode(index) === CPAREN_CODE) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrowError('Unclosed (', index);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Responsible for parsing Array literals `[1, 2, 3]`\n\t\t\t\t// This function assumes that it needs to gobble the opening bracket\n\t\t\t\t// and then tries to gobble the expressions as arguments.\n\t\t\t\tgobbleArray = function() {\n\t\t\t\t\tindex++;\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: ARRAY_EXP,\n\t\t\t\t\t\telements: gobbleArguments(CBRACK_CODE)\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\tnodes = [], ch_i, node;\n\n\t\t\twhile(index < length) {\n\t\t\t\tch_i = exprICode(index);\n\n\t\t\t\t// Expressions can be separated by semicolons, commas, or just inferred without any\n\t\t\t\t// separators\n\t\t\t\tif(ch_i === SEMCOL_CODE || ch_i === COMMA_CODE) {\n\t\t\t\t\tindex++; // ignore separators\n\t\t\t\t} else {\n\t\t\t\t\t// Try to gobble each expression individually\n\t\t\t\t\tif((node = gobbleExpression())) {\n\t\t\t\t\t\tnodes.push(node);\n\t\t\t\t\t// If we weren't able to find a binary expression and are out of room, then\n\t\t\t\t\t// the expression passed in probably has too much\n\t\t\t\t\t} else if(index < length) {\n\t\t\t\t\t\tthrowError('Unexpected \"' + exprI(index) + '\"', index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there's only one expression just try returning the expression\n\t\t\tif(nodes.length === 1) {\n\t\t\t\treturn nodes[0];\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\ttype: COMPOUND,\n\t\t\t\t\tbody: nodes\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\n\t// To be filled in by the template\n\tjsep.version = '0.3.1';\n\tjsep.toString = function() { return 'JavaScript Expression Parser (JSEP) v' + jsep.version; };\n\n\t/**\n\t * @method jsep.addUnaryOp\n\t * @param {string} op_name The name of the unary op to add\n\t * @return jsep\n\t */\n\tjsep.addUnaryOp = function(op_name) {\n\t\tmax_unop_len = Math.max(op_name.length, max_unop_len);\n\t\tunary_ops[op_name] = t; return this;\n\t};\n\n\t/**\n\t * @method jsep.addBinaryOp\n\t * @param {string} op_name The name of the binary op to add\n\t * @param {number} precedence The precedence of the binary op (can be a float)\n\t * @return jsep\n\t */\n\tjsep.addBinaryOp = function(op_name, precedence) {\n\t\tmax_binop_len = Math.max(op_name.length, max_binop_len);\n\t\tbinary_ops[op_name] = precedence;\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method jsep.addLiteral\n\t * @param {string} literal_name The name of the literal to add\n\t * @param {*} literal_value The value of the literal\n\t * @return jsep\n\t */\n\tjsep.addLiteral = function(literal_name, literal_value) {\n\t\tliterals[literal_name] = literal_value;\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method jsep.removeUnaryOp\n\t * @param {string} op_name The name of the unary op to remove\n\t * @return jsep\n\t */\n\tjsep.removeUnaryOp = function(op_name) {\n\t\tdelete unary_ops[op_name];\n\t\tif(op_name.length === max_unop_len) {\n\t\t\tmax_unop_len = getMaxKeyLen(unary_ops);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method jsep.removeAllUnaryOps\n\t * @return jsep\n\t */\n\tjsep.removeAllUnaryOps = function() {\n\t\tunary_ops = {};\n\t\tmax_unop_len = 0;\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method jsep.removeBinaryOp\n\t * @param {string} op_name The name of the binary op to remove\n\t * @return jsep\n\t */\n\tjsep.removeBinaryOp = function(op_name) {\n\t\tdelete binary_ops[op_name];\n\t\tif(op_name.length === max_binop_len) {\n\t\t\tmax_binop_len = getMaxKeyLen(binary_ops);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method jsep.removeAllBinaryOps\n\t * @return jsep\n\t */\n\tjsep.removeAllBinaryOps = function() {\n\t\tbinary_ops = {};\n\t\tmax_binop_len = 0;\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method jsep.removeLiteral\n\t * @param {string} literal_name The name of the literal to remove\n\t * @return jsep\n\t */\n\tjsep.removeLiteral = function(literal_name) {\n\t\tdelete literals[literal_name];\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method jsep.removeAllLiterals\n\t * @return jsep\n\t */\n\tjsep.removeAllLiterals = function() {\n\t\tliterals = {};\n\n\t\treturn this;\n\t};\n\n    root.jsep = jsep;\n}(tmp));\n\nexport default tmp.jsep;\n"]},"metadata":{},"sourceType":"module"}