{"ast":null,"code":"import AxisAlignedBoundingBox from \"./AxisAlignedBoundingBox.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\nimport Ray from \"./Ray.js\";\nimport Transforms from \"./Transforms.js\";\nvar scratchCart4 = new Cartesian4();\n/**\n * A plane tangent to the provided ellipsoid at the provided origin.\n * If origin is not on the surface of the ellipsoid, it's surface projection will be used.\n * If origin is at the center of the ellipsoid, an exception will be thrown.\n * @alias EllipsoidTangentPlane\n * @constructor\n *\n * @param {Cartesian3} origin The point on the surface of the ellipsoid where the tangent plane touches.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.\n *\n * @exception {DeveloperError} origin must not be at the center of the ellipsoid.\n */\n\nfunction EllipsoidTangentPlane(origin, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"origin\", origin); //>>includeEnd('debug');\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  origin = ellipsoid.scaleToGeodeticSurface(origin); //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(origin)) {\n    throw new DeveloperError(\"origin must not be at the center of the ellipsoid.\");\n  } //>>includeEnd('debug');\n\n\n  var eastNorthUp = Transforms.eastNorthUpToFixedFrame(origin, ellipsoid);\n  this._ellipsoid = ellipsoid;\n  this._origin = origin;\n  this._xAxis = Cartesian3.fromCartesian4(Matrix4.getColumn(eastNorthUp, 0, scratchCart4));\n  this._yAxis = Cartesian3.fromCartesian4(Matrix4.getColumn(eastNorthUp, 1, scratchCart4));\n  var normal = Cartesian3.fromCartesian4(Matrix4.getColumn(eastNorthUp, 2, scratchCart4));\n  this._plane = Plane.fromPointNormal(origin, normal);\n}\n\nObject.defineProperties(EllipsoidTangentPlane.prototype, {\n  /**\n   * Gets the ellipsoid.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function get() {\n      return this._ellipsoid;\n    }\n  },\n\n  /**\n   * Gets the origin.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @type {Cartesian3}\n   */\n  origin: {\n    get: function get() {\n      return this._origin;\n    }\n  },\n\n  /**\n   * Gets the plane which is tangent to the ellipsoid.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Plane}\n   */\n  plane: {\n    get: function get() {\n      return this._plane;\n    }\n  },\n\n  /**\n   * Gets the local X-axis (east) of the tangent plane.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Cartesian3}\n   */\n  xAxis: {\n    get: function get() {\n      return this._xAxis;\n    }\n  },\n\n  /**\n   * Gets the local Y-axis (north) of the tangent plane.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Cartesian3}\n   */\n  yAxis: {\n    get: function get() {\n      return this._yAxis;\n    }\n  },\n\n  /**\n   * Gets the local Z-axis (up) of the tangent plane.\n   * @member EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Cartesian3}\n   */\n  zAxis: {\n    get: function get() {\n      return this._plane.normal;\n    }\n  }\n});\nvar tmp = new AxisAlignedBoundingBox();\n/**\n * Creates a new instance from the provided ellipsoid and the center\n * point of the provided Cartesians.\n *\n * @param {Cartesian3} cartesians The list of positions surrounding the center point.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.\n */\n\nEllipsoidTangentPlane.fromPoints = function (cartesians, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians); //>>includeEnd('debug');\n\n  var box = AxisAlignedBoundingBox.fromPoints(cartesians, tmp);\n  return new EllipsoidTangentPlane(box.center, ellipsoid);\n};\n\nvar scratchProjectPointOntoPlaneRay = new Ray();\nvar scratchProjectPointOntoPlaneCartesian3 = new Cartesian3();\n/**\n * Computes the projection of the provided 3D position onto the 2D plane, radially outward from the {@link EllipsoidTangentPlane.ellipsoid} coordinate system origin.\n *\n * @param {Cartesian3} cartesian The point to project.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided. Undefined if there is no intersection point\n */\n\nEllipsoidTangentPlane.prototype.projectPointOntoPlane = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian); //>>includeEnd('debug');\n\n  var ray = scratchProjectPointOntoPlaneRay;\n  ray.origin = cartesian;\n  Cartesian3.normalize(cartesian, ray.direction);\n  var intersectionPoint = IntersectionTests.rayPlane(ray, this._plane, scratchProjectPointOntoPlaneCartesian3);\n\n  if (!defined(intersectionPoint)) {\n    Cartesian3.negate(ray.direction, ray.direction);\n    intersectionPoint = IntersectionTests.rayPlane(ray, this._plane, scratchProjectPointOntoPlaneCartesian3);\n  }\n\n  if (defined(intersectionPoint)) {\n    var v = Cartesian3.subtract(intersectionPoint, this._origin, intersectionPoint);\n    var x = Cartesian3.dot(this._xAxis, v);\n    var y = Cartesian3.dot(this._yAxis, v);\n\n    if (!defined(result)) {\n      return new Cartesian2(x, y);\n    }\n\n    result.x = x;\n    result.y = y;\n    return result;\n  }\n\n  return undefined;\n};\n/**\n * Computes the projection of the provided 3D positions onto the 2D plane (where possible), radially outward from the global origin.\n * The resulting array may be shorter than the input array - if a single projection is impossible it will not be included.\n *\n * @see EllipsoidTangentPlane.projectPointOntoPlane\n *\n * @param {Cartesian3[]} cartesians The array of points to project.\n * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.\n * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided.\n */\n\n\nEllipsoidTangentPlane.prototype.projectPointsOntoPlane = function (cartesians, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = [];\n  }\n\n  var count = 0;\n  var length = cartesians.length;\n\n  for (var i = 0; i < length; i++) {\n    var p = this.projectPointOntoPlane(cartesians[i], result[count]);\n\n    if (defined(p)) {\n      result[count] = p;\n      count++;\n    }\n  }\n\n  result.length = count;\n  return result;\n};\n/**\n * Computes the projection of the provided 3D position onto the 2D plane, along the plane normal.\n *\n * @param {Cartesian3} cartesian The point to project.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.\n */\n\n\nEllipsoidTangentPlane.prototype.projectPointToNearestOnPlane = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n\n  var ray = scratchProjectPointOntoPlaneRay;\n  ray.origin = cartesian;\n  Cartesian3.clone(this._plane.normal, ray.direction);\n  var intersectionPoint = IntersectionTests.rayPlane(ray, this._plane, scratchProjectPointOntoPlaneCartesian3);\n\n  if (!defined(intersectionPoint)) {\n    Cartesian3.negate(ray.direction, ray.direction);\n    intersectionPoint = IntersectionTests.rayPlane(ray, this._plane, scratchProjectPointOntoPlaneCartesian3);\n  }\n\n  var v = Cartesian3.subtract(intersectionPoint, this._origin, intersectionPoint);\n  var x = Cartesian3.dot(this._xAxis, v);\n  var y = Cartesian3.dot(this._yAxis, v);\n  result.x = x;\n  result.y = y;\n  return result;\n};\n/**\n * Computes the projection of the provided 3D positions onto the 2D plane, along the plane normal.\n *\n * @see EllipsoidTangentPlane.projectPointToNearestOnPlane\n *\n * @param {Cartesian3[]} cartesians The array of points to project.\n * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.\n * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided. This will have the same length as <code>cartesians</code>.\n */\n\n\nEllipsoidTangentPlane.prototype.projectPointsToNearestOnPlane = function (cartesians, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = [];\n  }\n\n  var length = cartesians.length;\n  result.length = length;\n\n  for (var i = 0; i < length; i++) {\n    result[i] = this.projectPointToNearestOnPlane(cartesians[i], result[i]);\n  }\n\n  return result;\n};\n\nvar projectPointsOntoEllipsoidScratch = new Cartesian3();\n/**\n * Computes the projection of the provided 2D position onto the 3D ellipsoid.\n *\n * @param {Cartesian2} cartesian The points to project.\n * @param {Cartesian3} [result] The Cartesian3 instance to store result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\n\nEllipsoidTangentPlane.prototype.projectPointOntoEllipsoid = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  var ellipsoid = this._ellipsoid;\n  var origin = this._origin;\n  var xAxis = this._xAxis;\n  var yAxis = this._yAxis;\n  var tmp = projectPointsOntoEllipsoidScratch;\n  Cartesian3.multiplyByScalar(xAxis, cartesian.x, tmp);\n  result = Cartesian3.add(origin, tmp, result);\n  Cartesian3.multiplyByScalar(yAxis, cartesian.y, tmp);\n  Cartesian3.add(result, tmp, result);\n  ellipsoid.scaleToGeocentricSurface(result, result);\n  return result;\n};\n/**\n * Computes the projection of the provided 2D positions onto the 3D ellipsoid.\n *\n * @param {Cartesian2[]} cartesians The array of points to project.\n * @param {Cartesian3[]} [result] The array of Cartesian3 instances onto which to store results.\n * @returns {Cartesian3[]} The modified result parameter or a new array of Cartesian3 instances if none was provided.\n */\n\n\nEllipsoidTangentPlane.prototype.projectPointsOntoEllipsoid = function (cartesians, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians); //>>includeEnd('debug');\n\n  var length = cartesians.length;\n\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    result[i] = this.projectPointOntoEllipsoid(cartesians[i], result[i]);\n  }\n\n  return result;\n};\n\nexport default EllipsoidTangentPlane;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/EllipsoidTangentPlane.js"],"names":["AxisAlignedBoundingBox","Cartesian2","Cartesian3","Cartesian4","Check","defaultValue","defined","DeveloperError","Ellipsoid","IntersectionTests","Matrix4","Plane","Ray","Transforms","scratchCart4","EllipsoidTangentPlane","origin","ellipsoid","WGS84","scaleToGeodeticSurface","eastNorthUp","eastNorthUpToFixedFrame","_ellipsoid","_origin","_xAxis","fromCartesian4","getColumn","_yAxis","normal","_plane","fromPointNormal","Object","defineProperties","prototype","get","plane","xAxis","yAxis","zAxis","tmp","fromPoints","cartesians","box","center","scratchProjectPointOntoPlaneRay","scratchProjectPointOntoPlaneCartesian3","projectPointOntoPlane","cartesian","result","ray","normalize","direction","intersectionPoint","rayPlane","negate","v","subtract","x","dot","y","undefined","projectPointsOntoPlane","count","length","i","p","projectPointToNearestOnPlane","clone","projectPointsToNearestOnPlane","projectPointsOntoEllipsoidScratch","projectPointOntoEllipsoid","multiplyByScalar","add","scaleToGeocentricSurface","projectPointsOntoEllipsoid","Array"],"mappings":"AAAA,OAAOA,sBAAP,MAAmC,6BAAnC;AACA,OAAOC,UAAP,MAAuB,iBAAvB;AACA,OAAOC,UAAP,MAAuB,iBAAvB;AACA,OAAOC,UAAP,MAAuB,iBAAvB;AACA,OAAOC,KAAP,MAAkB,YAAlB;AACA,OAAOC,YAAP,MAAyB,mBAAzB;AACA,OAAOC,OAAP,MAAoB,cAApB;AACA,OAAOC,cAAP,MAA2B,qBAA3B;AACA,OAAOC,SAAP,MAAsB,gBAAtB;AACA,OAAOC,iBAAP,MAA8B,wBAA9B;AACA,OAAOC,OAAP,MAAoB,cAApB;AACA,OAAOC,KAAP,MAAkB,YAAlB;AACA,OAAOC,GAAP,MAAgB,UAAhB;AACA,OAAOC,UAAP,MAAuB,iBAAvB;AAEA,IAAIC,YAAY,GAAG,IAAIX,UAAJ,EAAnB;AACA;;;;;;;;;;;;;AAYA,SAASY,qBAAT,CAA+BC,MAA/B,EAAuCC,SAAvC,EAAkD;AAChD;AACAb,EAAAA,KAAK,CAACE,OAAN,CAAc,QAAd,EAAwBU,MAAxB,EAFgD,CAGhD;;AAEAC,EAAAA,SAAS,GAAGZ,YAAY,CAACY,SAAD,EAAYT,SAAS,CAACU,KAAtB,CAAxB;AACAF,EAAAA,MAAM,GAAGC,SAAS,CAACE,sBAAV,CAAiCH,MAAjC,CAAT,CANgD,CAQhD;;AACA,MAAI,CAACV,OAAO,CAACU,MAAD,CAAZ,EAAsB;AACpB,UAAM,IAAIT,cAAJ,CACJ,oDADI,CAAN;AAGD,GAb+C,CAchD;;;AAEA,MAAIa,WAAW,GAAGP,UAAU,CAACQ,uBAAX,CAAmCL,MAAnC,EAA2CC,SAA3C,CAAlB;AACA,OAAKK,UAAL,GAAkBL,SAAlB;AACA,OAAKM,OAAL,GAAeP,MAAf;AACA,OAAKQ,MAAL,GAActB,UAAU,CAACuB,cAAX,CACZf,OAAO,CAACgB,SAAR,CAAkBN,WAAlB,EAA+B,CAA/B,EAAkCN,YAAlC,CADY,CAAd;AAGA,OAAKa,MAAL,GAAczB,UAAU,CAACuB,cAAX,CACZf,OAAO,CAACgB,SAAR,CAAkBN,WAAlB,EAA+B,CAA/B,EAAkCN,YAAlC,CADY,CAAd;AAIA,MAAIc,MAAM,GAAG1B,UAAU,CAACuB,cAAX,CACXf,OAAO,CAACgB,SAAR,CAAkBN,WAAlB,EAA+B,CAA/B,EAAkCN,YAAlC,CADW,CAAb;AAGA,OAAKe,MAAL,GAAclB,KAAK,CAACmB,eAAN,CAAsBd,MAAtB,EAA8BY,MAA9B,CAAd;AACD;;AAEDG,MAAM,CAACC,gBAAP,CAAwBjB,qBAAqB,CAACkB,SAA9C,EAAyD;AACvD;;;;;AAKAhB,EAAAA,SAAS,EAAE;AACTiB,IAAAA,GAAG,EAAE,eAAY;AACf,aAAO,KAAKZ,UAAZ;AACD;AAHQ,GAN4C;;AAYvD;;;;;AAKAN,EAAAA,MAAM,EAAE;AACNkB,IAAAA,GAAG,EAAE,eAAY;AACf,aAAO,KAAKX,OAAZ;AACD;AAHK,GAjB+C;;AAuBvD;;;;;;AAMAY,EAAAA,KAAK,EAAE;AACLD,IAAAA,GAAG,EAAE,eAAY;AACf,aAAO,KAAKL,MAAZ;AACD;AAHI,GA7BgD;;AAmCvD;;;;;;AAMAO,EAAAA,KAAK,EAAE;AACLF,IAAAA,GAAG,EAAE,eAAY;AACf,aAAO,KAAKV,MAAZ;AACD;AAHI,GAzCgD;;AA+CvD;;;;;;AAMAa,EAAAA,KAAK,EAAE;AACLH,IAAAA,GAAG,EAAE,eAAY;AACf,aAAO,KAAKP,MAAZ;AACD;AAHI,GArDgD;;AA2DvD;;;;;;AAMAW,EAAAA,KAAK,EAAE;AACLJ,IAAAA,GAAG,EAAE,eAAY;AACf,aAAO,KAAKL,MAAL,CAAYD,MAAnB;AACD;AAHI;AAjEgD,CAAzD;AAwEA,IAAIW,GAAG,GAAG,IAAIvC,sBAAJ,EAAV;AACA;;;;;;;;AAOAe,qBAAqB,CAACyB,UAAtB,GAAmC,UAAUC,UAAV,EAAsBxB,SAAtB,EAAiC;AAClE;AACAb,EAAAA,KAAK,CAACE,OAAN,CAAc,YAAd,EAA4BmC,UAA5B,EAFkE,CAGlE;;AAEA,MAAIC,GAAG,GAAG1C,sBAAsB,CAACwC,UAAvB,CAAkCC,UAAlC,EAA8CF,GAA9C,CAAV;AACA,SAAO,IAAIxB,qBAAJ,CAA0B2B,GAAG,CAACC,MAA9B,EAAsC1B,SAAtC,CAAP;AACD,CAPD;;AASA,IAAI2B,+BAA+B,GAAG,IAAIhC,GAAJ,EAAtC;AACA,IAAIiC,sCAAsC,GAAG,IAAI3C,UAAJ,EAA7C;AAEA;;;;;;;;AAOAa,qBAAqB,CAACkB,SAAtB,CAAgCa,qBAAhC,GAAwD,UACtDC,SADsD,EAEtDC,MAFsD,EAGtD;AACA;AACA5C,EAAAA,KAAK,CAACE,OAAN,CAAc,WAAd,EAA2ByC,SAA3B,EAFA,CAGA;;AAEA,MAAIE,GAAG,GAAGL,+BAAV;AACAK,EAAAA,GAAG,CAACjC,MAAJ,GAAa+B,SAAb;AACA7C,EAAAA,UAAU,CAACgD,SAAX,CAAqBH,SAArB,EAAgCE,GAAG,CAACE,SAApC;AAEA,MAAIC,iBAAiB,GAAG3C,iBAAiB,CAAC4C,QAAlB,CACtBJ,GADsB,EAEtB,KAAKpB,MAFiB,EAGtBgB,sCAHsB,CAAxB;;AAKA,MAAI,CAACvC,OAAO,CAAC8C,iBAAD,CAAZ,EAAiC;AAC/BlD,IAAAA,UAAU,CAACoD,MAAX,CAAkBL,GAAG,CAACE,SAAtB,EAAiCF,GAAG,CAACE,SAArC;AACAC,IAAAA,iBAAiB,GAAG3C,iBAAiB,CAAC4C,QAAlB,CAClBJ,GADkB,EAElB,KAAKpB,MAFa,EAGlBgB,sCAHkB,CAApB;AAKD;;AAED,MAAIvC,OAAO,CAAC8C,iBAAD,CAAX,EAAgC;AAC9B,QAAIG,CAAC,GAAGrD,UAAU,CAACsD,QAAX,CACNJ,iBADM,EAEN,KAAK7B,OAFC,EAGN6B,iBAHM,CAAR;AAKA,QAAIK,CAAC,GAAGvD,UAAU,CAACwD,GAAX,CAAe,KAAKlC,MAApB,EAA4B+B,CAA5B,CAAR;AACA,QAAII,CAAC,GAAGzD,UAAU,CAACwD,GAAX,CAAe,KAAK/B,MAApB,EAA4B4B,CAA5B,CAAR;;AAEA,QAAI,CAACjD,OAAO,CAAC0C,MAAD,CAAZ,EAAsB;AACpB,aAAO,IAAI/C,UAAJ,CAAewD,CAAf,EAAkBE,CAAlB,CAAP;AACD;;AACDX,IAAAA,MAAM,CAACS,CAAP,GAAWA,CAAX;AACAT,IAAAA,MAAM,CAACW,CAAP,GAAWA,CAAX;AACA,WAAOX,MAAP;AACD;;AACD,SAAOY,SAAP;AACD,CA3CD;AA6CA;;;;;;;;;;;;AAUA7C,qBAAqB,CAACkB,SAAtB,CAAgC4B,sBAAhC,GAAyD,UACvDpB,UADuD,EAEvDO,MAFuD,EAGvD;AACA;AACA5C,EAAAA,KAAK,CAACE,OAAN,CAAc,YAAd,EAA4BmC,UAA5B,EAFA,CAGA;;AAEA,MAAI,CAACnC,OAAO,CAAC0C,MAAD,CAAZ,EAAsB;AACpBA,IAAAA,MAAM,GAAG,EAAT;AACD;;AAED,MAAIc,KAAK,GAAG,CAAZ;AACA,MAAIC,MAAM,GAAGtB,UAAU,CAACsB,MAAxB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4BC,CAAC,EAA7B,EAAiC;AAC/B,QAAIC,CAAC,GAAG,KAAKnB,qBAAL,CAA2BL,UAAU,CAACuB,CAAD,CAArC,EAA0ChB,MAAM,CAACc,KAAD,CAAhD,CAAR;;AACA,QAAIxD,OAAO,CAAC2D,CAAD,CAAX,EAAgB;AACdjB,MAAAA,MAAM,CAACc,KAAD,CAAN,GAAgBG,CAAhB;AACAH,MAAAA,KAAK;AACN;AACF;;AACDd,EAAAA,MAAM,CAACe,MAAP,GAAgBD,KAAhB;AACA,SAAOd,MAAP;AACD,CAvBD;AAyBA;;;;;;;;;AAOAjC,qBAAqB,CAACkB,SAAtB,CAAgCiC,4BAAhC,GAA+D,UAC7DnB,SAD6D,EAE7DC,MAF6D,EAG7D;AACA;AACA5C,EAAAA,KAAK,CAACE,OAAN,CAAc,WAAd,EAA2ByC,SAA3B,EAFA,CAGA;;AAEA,MAAI,CAACzC,OAAO,CAAC0C,MAAD,CAAZ,EAAsB;AACpBA,IAAAA,MAAM,GAAG,IAAI/C,UAAJ,EAAT;AACD;;AAED,MAAIgD,GAAG,GAAGL,+BAAV;AACAK,EAAAA,GAAG,CAACjC,MAAJ,GAAa+B,SAAb;AACA7C,EAAAA,UAAU,CAACiE,KAAX,CAAiB,KAAKtC,MAAL,CAAYD,MAA7B,EAAqCqB,GAAG,CAACE,SAAzC;AAEA,MAAIC,iBAAiB,GAAG3C,iBAAiB,CAAC4C,QAAlB,CACtBJ,GADsB,EAEtB,KAAKpB,MAFiB,EAGtBgB,sCAHsB,CAAxB;;AAKA,MAAI,CAACvC,OAAO,CAAC8C,iBAAD,CAAZ,EAAiC;AAC/BlD,IAAAA,UAAU,CAACoD,MAAX,CAAkBL,GAAG,CAACE,SAAtB,EAAiCF,GAAG,CAACE,SAArC;AACAC,IAAAA,iBAAiB,GAAG3C,iBAAiB,CAAC4C,QAAlB,CAClBJ,GADkB,EAElB,KAAKpB,MAFa,EAGlBgB,sCAHkB,CAApB;AAKD;;AAED,MAAIU,CAAC,GAAGrD,UAAU,CAACsD,QAAX,CACNJ,iBADM,EAEN,KAAK7B,OAFC,EAGN6B,iBAHM,CAAR;AAKA,MAAIK,CAAC,GAAGvD,UAAU,CAACwD,GAAX,CAAe,KAAKlC,MAApB,EAA4B+B,CAA5B,CAAR;AACA,MAAII,CAAC,GAAGzD,UAAU,CAACwD,GAAX,CAAe,KAAK/B,MAApB,EAA4B4B,CAA5B,CAAR;AAEAP,EAAAA,MAAM,CAACS,CAAP,GAAWA,CAAX;AACAT,EAAAA,MAAM,CAACW,CAAP,GAAWA,CAAX;AACA,SAAOX,MAAP;AACD,CAzCD;AA2CA;;;;;;;;;;;AASAjC,qBAAqB,CAACkB,SAAtB,CAAgCmC,6BAAhC,GAAgE,UAC9D3B,UAD8D,EAE9DO,MAF8D,EAG9D;AACA;AACA5C,EAAAA,KAAK,CAACE,OAAN,CAAc,YAAd,EAA4BmC,UAA5B,EAFA,CAGA;;AAEA,MAAI,CAACnC,OAAO,CAAC0C,MAAD,CAAZ,EAAsB;AACpBA,IAAAA,MAAM,GAAG,EAAT;AACD;;AAED,MAAIe,MAAM,GAAGtB,UAAU,CAACsB,MAAxB;AACAf,EAAAA,MAAM,CAACe,MAAP,GAAgBA,MAAhB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4BC,CAAC,EAA7B,EAAiC;AAC/BhB,IAAAA,MAAM,CAACgB,CAAD,CAAN,GAAY,KAAKE,4BAAL,CAAkCzB,UAAU,CAACuB,CAAD,CAA5C,EAAiDhB,MAAM,CAACgB,CAAD,CAAvD,CAAZ;AACD;;AACD,SAAOhB,MAAP;AACD,CAlBD;;AAoBA,IAAIqB,iCAAiC,GAAG,IAAInE,UAAJ,EAAxC;AACA;;;;;;;;AAOAa,qBAAqB,CAACkB,SAAtB,CAAgCqC,yBAAhC,GAA4D,UAC1DvB,SAD0D,EAE1DC,MAF0D,EAG1D;AACA;AACA5C,EAAAA,KAAK,CAACE,OAAN,CAAc,WAAd,EAA2ByC,SAA3B,EAFA,CAGA;;AAEA,MAAI,CAACzC,OAAO,CAAC0C,MAAD,CAAZ,EAAsB;AACpBA,IAAAA,MAAM,GAAG,IAAI9C,UAAJ,EAAT;AACD;;AAED,MAAIe,SAAS,GAAG,KAAKK,UAArB;AACA,MAAIN,MAAM,GAAG,KAAKO,OAAlB;AACA,MAAIa,KAAK,GAAG,KAAKZ,MAAjB;AACA,MAAIa,KAAK,GAAG,KAAKV,MAAjB;AACA,MAAIY,GAAG,GAAG8B,iCAAV;AAEAnE,EAAAA,UAAU,CAACqE,gBAAX,CAA4BnC,KAA5B,EAAmCW,SAAS,CAACU,CAA7C,EAAgDlB,GAAhD;AACAS,EAAAA,MAAM,GAAG9C,UAAU,CAACsE,GAAX,CAAexD,MAAf,EAAuBuB,GAAvB,EAA4BS,MAA5B,CAAT;AACA9C,EAAAA,UAAU,CAACqE,gBAAX,CAA4BlC,KAA5B,EAAmCU,SAAS,CAACY,CAA7C,EAAgDpB,GAAhD;AACArC,EAAAA,UAAU,CAACsE,GAAX,CAAexB,MAAf,EAAuBT,GAAvB,EAA4BS,MAA5B;AACA/B,EAAAA,SAAS,CAACwD,wBAAV,CAAmCzB,MAAnC,EAA2CA,MAA3C;AAEA,SAAOA,MAAP;AACD,CAzBD;AA2BA;;;;;;;;;AAOAjC,qBAAqB,CAACkB,SAAtB,CAAgCyC,0BAAhC,GAA6D,UAC3DjC,UAD2D,EAE3DO,MAF2D,EAG3D;AACA;AACA5C,EAAAA,KAAK,CAACE,OAAN,CAAc,YAAd,EAA4BmC,UAA5B,EAFA,CAGA;;AAEA,MAAIsB,MAAM,GAAGtB,UAAU,CAACsB,MAAxB;;AACA,MAAI,CAACzD,OAAO,CAAC0C,MAAD,CAAZ,EAAsB;AACpBA,IAAAA,MAAM,GAAG,IAAI2B,KAAJ,CAAUZ,MAAV,CAAT;AACD,GAFD,MAEO;AACLf,IAAAA,MAAM,CAACe,MAAP,GAAgBA,MAAhB;AACD;;AAED,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4B,EAAEC,CAA9B,EAAiC;AAC/BhB,IAAAA,MAAM,CAACgB,CAAD,CAAN,GAAY,KAAKM,yBAAL,CAA+B7B,UAAU,CAACuB,CAAD,CAAzC,EAA8ChB,MAAM,CAACgB,CAAD,CAApD,CAAZ;AACD;;AAED,SAAOhB,MAAP;AACD,CApBD;;AAqBA,eAAejC,qBAAf","sourcesContent":["import AxisAlignedBoundingBox from \"./AxisAlignedBoundingBox.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\nimport Ray from \"./Ray.js\";\nimport Transforms from \"./Transforms.js\";\n\nvar scratchCart4 = new Cartesian4();\n/**\n * A plane tangent to the provided ellipsoid at the provided origin.\n * If origin is not on the surface of the ellipsoid, it's surface projection will be used.\n * If origin is at the center of the ellipsoid, an exception will be thrown.\n * @alias EllipsoidTangentPlane\n * @constructor\n *\n * @param {Cartesian3} origin The point on the surface of the ellipsoid where the tangent plane touches.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.\n *\n * @exception {DeveloperError} origin must not be at the center of the ellipsoid.\n */\nfunction EllipsoidTangentPlane(origin, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"origin\", origin);\n  //>>includeEnd('debug');\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  origin = ellipsoid.scaleToGeodeticSurface(origin);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(origin)) {\n    throw new DeveloperError(\n      \"origin must not be at the center of the ellipsoid.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var eastNorthUp = Transforms.eastNorthUpToFixedFrame(origin, ellipsoid);\n  this._ellipsoid = ellipsoid;\n  this._origin = origin;\n  this._xAxis = Cartesian3.fromCartesian4(\n    Matrix4.getColumn(eastNorthUp, 0, scratchCart4)\n  );\n  this._yAxis = Cartesian3.fromCartesian4(\n    Matrix4.getColumn(eastNorthUp, 1, scratchCart4)\n  );\n\n  var normal = Cartesian3.fromCartesian4(\n    Matrix4.getColumn(eastNorthUp, 2, scratchCart4)\n  );\n  this._plane = Plane.fromPointNormal(origin, normal);\n}\n\nObject.defineProperties(EllipsoidTangentPlane.prototype, {\n  /**\n   * Gets the ellipsoid.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n\n  /**\n   * Gets the origin.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @type {Cartesian3}\n   */\n  origin: {\n    get: function () {\n      return this._origin;\n    },\n  },\n\n  /**\n   * Gets the plane which is tangent to the ellipsoid.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Plane}\n   */\n  plane: {\n    get: function () {\n      return this._plane;\n    },\n  },\n\n  /**\n   * Gets the local X-axis (east) of the tangent plane.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Cartesian3}\n   */\n  xAxis: {\n    get: function () {\n      return this._xAxis;\n    },\n  },\n\n  /**\n   * Gets the local Y-axis (north) of the tangent plane.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Cartesian3}\n   */\n  yAxis: {\n    get: function () {\n      return this._yAxis;\n    },\n  },\n\n  /**\n   * Gets the local Z-axis (up) of the tangent plane.\n   * @member EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Cartesian3}\n   */\n  zAxis: {\n    get: function () {\n      return this._plane.normal;\n    },\n  },\n});\n\nvar tmp = new AxisAlignedBoundingBox();\n/**\n * Creates a new instance from the provided ellipsoid and the center\n * point of the provided Cartesians.\n *\n * @param {Cartesian3} cartesians The list of positions surrounding the center point.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.\n */\nEllipsoidTangentPlane.fromPoints = function (cartesians, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  var box = AxisAlignedBoundingBox.fromPoints(cartesians, tmp);\n  return new EllipsoidTangentPlane(box.center, ellipsoid);\n};\n\nvar scratchProjectPointOntoPlaneRay = new Ray();\nvar scratchProjectPointOntoPlaneCartesian3 = new Cartesian3();\n\n/**\n * Computes the projection of the provided 3D position onto the 2D plane, radially outward from the {@link EllipsoidTangentPlane.ellipsoid} coordinate system origin.\n *\n * @param {Cartesian3} cartesian The point to project.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided. Undefined if there is no intersection point\n */\nEllipsoidTangentPlane.prototype.projectPointOntoPlane = function (\n  cartesian,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  var ray = scratchProjectPointOntoPlaneRay;\n  ray.origin = cartesian;\n  Cartesian3.normalize(cartesian, ray.direction);\n\n  var intersectionPoint = IntersectionTests.rayPlane(\n    ray,\n    this._plane,\n    scratchProjectPointOntoPlaneCartesian3\n  );\n  if (!defined(intersectionPoint)) {\n    Cartesian3.negate(ray.direction, ray.direction);\n    intersectionPoint = IntersectionTests.rayPlane(\n      ray,\n      this._plane,\n      scratchProjectPointOntoPlaneCartesian3\n    );\n  }\n\n  if (defined(intersectionPoint)) {\n    var v = Cartesian3.subtract(\n      intersectionPoint,\n      this._origin,\n      intersectionPoint\n    );\n    var x = Cartesian3.dot(this._xAxis, v);\n    var y = Cartesian3.dot(this._yAxis, v);\n\n    if (!defined(result)) {\n      return new Cartesian2(x, y);\n    }\n    result.x = x;\n    result.y = y;\n    return result;\n  }\n  return undefined;\n};\n\n/**\n * Computes the projection of the provided 3D positions onto the 2D plane (where possible), radially outward from the global origin.\n * The resulting array may be shorter than the input array - if a single projection is impossible it will not be included.\n *\n * @see EllipsoidTangentPlane.projectPointOntoPlane\n *\n * @param {Cartesian3[]} cartesians The array of points to project.\n * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.\n * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointsOntoPlane = function (\n  cartesians,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = [];\n  }\n\n  var count = 0;\n  var length = cartesians.length;\n  for (var i = 0; i < length; i++) {\n    var p = this.projectPointOntoPlane(cartesians[i], result[count]);\n    if (defined(p)) {\n      result[count] = p;\n      count++;\n    }\n  }\n  result.length = count;\n  return result;\n};\n\n/**\n * Computes the projection of the provided 3D position onto the 2D plane, along the plane normal.\n *\n * @param {Cartesian3} cartesian The point to project.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointToNearestOnPlane = function (\n  cartesian,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n\n  var ray = scratchProjectPointOntoPlaneRay;\n  ray.origin = cartesian;\n  Cartesian3.clone(this._plane.normal, ray.direction);\n\n  var intersectionPoint = IntersectionTests.rayPlane(\n    ray,\n    this._plane,\n    scratchProjectPointOntoPlaneCartesian3\n  );\n  if (!defined(intersectionPoint)) {\n    Cartesian3.negate(ray.direction, ray.direction);\n    intersectionPoint = IntersectionTests.rayPlane(\n      ray,\n      this._plane,\n      scratchProjectPointOntoPlaneCartesian3\n    );\n  }\n\n  var v = Cartesian3.subtract(\n    intersectionPoint,\n    this._origin,\n    intersectionPoint\n  );\n  var x = Cartesian3.dot(this._xAxis, v);\n  var y = Cartesian3.dot(this._yAxis, v);\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes the projection of the provided 3D positions onto the 2D plane, along the plane normal.\n *\n * @see EllipsoidTangentPlane.projectPointToNearestOnPlane\n *\n * @param {Cartesian3[]} cartesians The array of points to project.\n * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.\n * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided. This will have the same length as <code>cartesians</code>.\n */\nEllipsoidTangentPlane.prototype.projectPointsToNearestOnPlane = function (\n  cartesians,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = [];\n  }\n\n  var length = cartesians.length;\n  result.length = length;\n  for (var i = 0; i < length; i++) {\n    result[i] = this.projectPointToNearestOnPlane(cartesians[i], result[i]);\n  }\n  return result;\n};\n\nvar projectPointsOntoEllipsoidScratch = new Cartesian3();\n/**\n * Computes the projection of the provided 2D position onto the 3D ellipsoid.\n *\n * @param {Cartesian2} cartesian The points to project.\n * @param {Cartesian3} [result] The Cartesian3 instance to store result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointOntoEllipsoid = function (\n  cartesian,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  var ellipsoid = this._ellipsoid;\n  var origin = this._origin;\n  var xAxis = this._xAxis;\n  var yAxis = this._yAxis;\n  var tmp = projectPointsOntoEllipsoidScratch;\n\n  Cartesian3.multiplyByScalar(xAxis, cartesian.x, tmp);\n  result = Cartesian3.add(origin, tmp, result);\n  Cartesian3.multiplyByScalar(yAxis, cartesian.y, tmp);\n  Cartesian3.add(result, tmp, result);\n  ellipsoid.scaleToGeocentricSurface(result, result);\n\n  return result;\n};\n\n/**\n * Computes the projection of the provided 2D positions onto the 3D ellipsoid.\n *\n * @param {Cartesian2[]} cartesians The array of points to project.\n * @param {Cartesian3[]} [result] The array of Cartesian3 instances onto which to store results.\n * @returns {Cartesian3[]} The modified result parameter or a new array of Cartesian3 instances if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointsOntoEllipsoid = function (\n  cartesians,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  var length = cartesians.length;\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    result[i] = this.projectPointOntoEllipsoid(cartesians[i], result[i]);\n  }\n\n  return result;\n};\nexport default EllipsoidTangentPlane;\n"]},"metadata":{},"sourceType":"module"}