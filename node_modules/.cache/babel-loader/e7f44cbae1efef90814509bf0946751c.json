{"ast":null,"code":"import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport getImagePixels from \"../Core/getImagePixels.js\";\nimport Resource from \"../Core/Resource.js\";\n/**\n * A policy for discarding tile images that match a known image containing a\n * \"missing\" image.\n *\n * @alias DiscardMissingTileImagePolicy\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource|String} options.missingImageUrl The URL of the known missing image.\n * @param {Cartesian2[]} options.pixelsToCheck An array of {@link Cartesian2} pixel positions to\n *        compare against the missing image.\n * @param {Boolean} [options.disableCheckIfAllPixelsAreTransparent=false] If true, the discard check will be disabled\n *                  if all of the pixelsToCheck in the missingImageUrl have an alpha value of 0.  If false, the\n *                  discard check will proceed no matter the values of the pixelsToCheck.\n */\n\nfunction DiscardMissingTileImagePolicy(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(options.missingImageUrl)) {\n    throw new DeveloperError(\"options.missingImageUrl is required.\");\n  }\n\n  if (!defined(options.pixelsToCheck)) {\n    throw new DeveloperError(\"options.pixelsToCheck is required.\");\n  } //>>includeEnd('debug');\n\n\n  this._pixelsToCheck = options.pixelsToCheck;\n  this._missingImagePixels = undefined;\n  this._missingImageByteLength = undefined;\n  this._isReady = false;\n  var resource = Resource.createIfNeeded(options.missingImageUrl);\n  var that = this;\n\n  function success(image) {\n    if (defined(image.blob)) {\n      that._missingImageByteLength = image.blob.size;\n    }\n\n    var pixels = getImagePixels(image);\n\n    if (options.disableCheckIfAllPixelsAreTransparent) {\n      var allAreTransparent = true;\n      var width = image.width;\n      var pixelsToCheck = options.pixelsToCheck;\n\n      for (var i = 0, len = pixelsToCheck.length; allAreTransparent && i < len; ++i) {\n        var pos = pixelsToCheck[i];\n        var index = pos.x * 4 + pos.y * width;\n        var alpha = pixels[index + 3];\n\n        if (alpha > 0) {\n          allAreTransparent = false;\n        }\n      }\n\n      if (allAreTransparent) {\n        pixels = undefined;\n      }\n    }\n\n    that._missingImagePixels = pixels;\n    that._isReady = true;\n  }\n\n  function failure() {\n    // Failed to download \"missing\" image, so assume that any truly missing tiles\n    // will also fail to download and disable the discard check.\n    that._missingImagePixels = undefined;\n    that._isReady = true;\n  }\n\n  resource.fetchImage({\n    preferBlob: true,\n    preferImageBitmap: true,\n    flipY: true\n  }).then(success).otherwise(failure);\n}\n/**\n * Determines if the discard policy is ready to process images.\n * @returns {Boolean} True if the discard policy is ready to process images; otherwise, false.\n */\n\n\nDiscardMissingTileImagePolicy.prototype.isReady = function () {\n  return this._isReady;\n};\n/**\n * Given a tile image, decide whether to discard that image.\n *\n * @param {Image} image An image to test.\n * @returns {Boolean} True if the image should be discarded; otherwise, false.\n *\n * @exception {DeveloperError} <code>shouldDiscardImage</code> must not be called before the discard policy is ready.\n */\n\n\nDiscardMissingTileImagePolicy.prototype.shouldDiscardImage = function (image) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._isReady) {\n    throw new DeveloperError(\"shouldDiscardImage must not be called before the discard policy is ready.\");\n  } //>>includeEnd('debug');\n\n\n  var pixelsToCheck = this._pixelsToCheck;\n  var missingImagePixels = this._missingImagePixels; // If missingImagePixels is undefined, it indicates that the discard check has been disabled.\n\n  if (!defined(missingImagePixels)) {\n    return false;\n  }\n\n  if (defined(image.blob) && image.blob.size !== this._missingImageByteLength) {\n    return false;\n  }\n\n  var pixels = getImagePixels(image);\n  var width = image.width;\n\n  for (var i = 0, len = pixelsToCheck.length; i < len; ++i) {\n    var pos = pixelsToCheck[i];\n    var index = pos.x * 4 + pos.y * width;\n\n    for (var offset = 0; offset < 4; ++offset) {\n      var pixel = index + offset;\n\n      if (pixels[pixel] !== missingImagePixels[pixel]) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n};\n\nexport default DiscardMissingTileImagePolicy;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Scene/DiscardMissingTileImagePolicy.js"],"names":["defaultValue","defined","DeveloperError","getImagePixels","Resource","DiscardMissingTileImagePolicy","options","EMPTY_OBJECT","missingImageUrl","pixelsToCheck","_pixelsToCheck","_missingImagePixels","undefined","_missingImageByteLength","_isReady","resource","createIfNeeded","that","success","image","blob","size","pixels","disableCheckIfAllPixelsAreTransparent","allAreTransparent","width","i","len","length","pos","index","x","y","alpha","failure","fetchImage","preferBlob","preferImageBitmap","flipY","then","otherwise","prototype","isReady","shouldDiscardImage","missingImagePixels","offset","pixel"],"mappings":"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","sourcesContent":["import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport getImagePixels from \"../Core/getImagePixels.js\";\nimport Resource from \"../Core/Resource.js\";\n\n/**\n * A policy for discarding tile images that match a known image containing a\n * \"missing\" image.\n *\n * @alias DiscardMissingTileImagePolicy\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource|String} options.missingImageUrl The URL of the known missing image.\n * @param {Cartesian2[]} options.pixelsToCheck An array of {@link Cartesian2} pixel positions to\n *        compare against the missing image.\n * @param {Boolean} [options.disableCheckIfAllPixelsAreTransparent=false] If true, the discard check will be disabled\n *                  if all of the pixelsToCheck in the missingImageUrl have an alpha value of 0.  If false, the\n *                  discard check will proceed no matter the values of the pixelsToCheck.\n */\nfunction DiscardMissingTileImagePolicy(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.missingImageUrl)) {\n    throw new DeveloperError(\"options.missingImageUrl is required.\");\n  }\n\n  if (!defined(options.pixelsToCheck)) {\n    throw new DeveloperError(\"options.pixelsToCheck is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._pixelsToCheck = options.pixelsToCheck;\n  this._missingImagePixels = undefined;\n  this._missingImageByteLength = undefined;\n  this._isReady = false;\n\n  var resource = Resource.createIfNeeded(options.missingImageUrl);\n\n  var that = this;\n\n  function success(image) {\n    if (defined(image.blob)) {\n      that._missingImageByteLength = image.blob.size;\n    }\n\n    var pixels = getImagePixels(image);\n\n    if (options.disableCheckIfAllPixelsAreTransparent) {\n      var allAreTransparent = true;\n      var width = image.width;\n\n      var pixelsToCheck = options.pixelsToCheck;\n      for (\n        var i = 0, len = pixelsToCheck.length;\n        allAreTransparent && i < len;\n        ++i\n      ) {\n        var pos = pixelsToCheck[i];\n        var index = pos.x * 4 + pos.y * width;\n        var alpha = pixels[index + 3];\n\n        if (alpha > 0) {\n          allAreTransparent = false;\n        }\n      }\n\n      if (allAreTransparent) {\n        pixels = undefined;\n      }\n    }\n\n    that._missingImagePixels = pixels;\n    that._isReady = true;\n  }\n\n  function failure() {\n    // Failed to download \"missing\" image, so assume that any truly missing tiles\n    // will also fail to download and disable the discard check.\n    that._missingImagePixels = undefined;\n    that._isReady = true;\n  }\n\n  resource\n    .fetchImage({\n      preferBlob: true,\n      preferImageBitmap: true,\n      flipY: true,\n    })\n    .then(success)\n    .otherwise(failure);\n}\n\n/**\n * Determines if the discard policy is ready to process images.\n * @returns {Boolean} True if the discard policy is ready to process images; otherwise, false.\n */\nDiscardMissingTileImagePolicy.prototype.isReady = function () {\n  return this._isReady;\n};\n\n/**\n * Given a tile image, decide whether to discard that image.\n *\n * @param {Image} image An image to test.\n * @returns {Boolean} True if the image should be discarded; otherwise, false.\n *\n * @exception {DeveloperError} <code>shouldDiscardImage</code> must not be called before the discard policy is ready.\n */\nDiscardMissingTileImagePolicy.prototype.shouldDiscardImage = function (image) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._isReady) {\n    throw new DeveloperError(\n      \"shouldDiscardImage must not be called before the discard policy is ready.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var pixelsToCheck = this._pixelsToCheck;\n  var missingImagePixels = this._missingImagePixels;\n\n  // If missingImagePixels is undefined, it indicates that the discard check has been disabled.\n  if (!defined(missingImagePixels)) {\n    return false;\n  }\n\n  if (defined(image.blob) && image.blob.size !== this._missingImageByteLength) {\n    return false;\n  }\n\n  var pixels = getImagePixels(image);\n  var width = image.width;\n\n  for (var i = 0, len = pixelsToCheck.length; i < len; ++i) {\n    var pos = pixelsToCheck[i];\n    var index = pos.x * 4 + pos.y * width;\n    for (var offset = 0; offset < 4; ++offset) {\n      var pixel = index + offset;\n      if (pixels[pixel] !== missingImagePixels[pixel]) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\nexport default DiscardMissingTileImagePolicy;\n"]},"metadata":{},"sourceType":"module"}