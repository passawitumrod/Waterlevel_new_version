{"ast":null,"code":"import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport PerspectiveOffCenterFrustum from \"./PerspectiveOffCenterFrustum.js\";\n/**\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias PerspectiveFrustum\n * @constructor\n *\n * @param {Object} [options] An object with the following properties:\n * @param {Number} [options.fov] The angle of the field of view (FOV), in radians.\n * @param {Number} [options.aspectRatio] The aspect ratio of the frustum's width to it's height.\n * @param {Number} [options.near=1.0] The distance of the near plane.\n * @param {Number} [options.far=500000000.0] The distance of the far plane.\n * @param {Number} [options.xOffset=0.0] The offset in the x direction.\n * @param {Number} [options.yOffset=0.0] The offset in the y direction.\n *\n * @example\n * var frustum = new Cesium.PerspectiveFrustum({\n *     fov : Cesium.Math.PI_OVER_THREE,\n *     aspectRatio : canvas.clientWidth / canvas.clientHeight\n *     near : 1.0,\n *     far : 1000.0\n * });\n *\n * @see PerspectiveOffCenterFrustum\n */\n\nfunction PerspectiveFrustum(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  this._offCenterFrustum = new PerspectiveOffCenterFrustum();\n  /**\n   * The angle of the field of view (FOV), in radians.  This angle will be used\n   * as the horizontal FOV if the width is greater than the height, otherwise\n   * it will be the vertical FOV.\n   * @type {Number}\n   * @default undefined\n   */\n\n  this.fov = options.fov;\n  this._fov = undefined;\n  this._fovy = undefined;\n  this._sseDenominator = undefined;\n  /**\n   * The aspect ratio of the frustum's width to it's height.\n   * @type {Number}\n   * @default undefined\n   */\n\n  this.aspectRatio = options.aspectRatio;\n  this._aspectRatio = undefined;\n  /**\n   * The distance of the near plane.\n   * @type {Number}\n   * @default 1.0\n   */\n\n  this.near = defaultValue(options.near, 1.0);\n  this._near = this.near;\n  /**\n   * The distance of the far plane.\n   * @type {Number}\n   * @default 500000000.0\n   */\n\n  this.far = defaultValue(options.far, 500000000.0);\n  this._far = this.far;\n  /**\n   * Offsets the frustum in the x direction.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.xOffset = defaultValue(options.xOffset, 0.0);\n  this._xOffset = this.xOffset;\n  /**\n   * Offsets the frustum in the y direction.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.yOffset = defaultValue(options.yOffset, 0.0);\n  this._yOffset = this.yOffset;\n}\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\n\n\nPerspectiveFrustum.packedLength = 6;\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PerspectiveFrustum} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\nPerspectiveFrustum.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  array[startingIndex++] = value.fov;\n  array[startingIndex++] = value.aspectRatio;\n  array[startingIndex++] = value.near;\n  array[startingIndex++] = value.far;\n  array[startingIndex++] = value.xOffset;\n  array[startingIndex] = value.yOffset;\n  return array;\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PerspectiveFrustum} [result] The object into which to store the result.\n * @returns {PerspectiveFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\n */\n\n\nPerspectiveFrustum.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new PerspectiveFrustum();\n  }\n\n  result.fov = array[startingIndex++];\n  result.aspectRatio = array[startingIndex++];\n  result.near = array[startingIndex++];\n  result.far = array[startingIndex++];\n  result.xOffset = array[startingIndex++];\n  result.yOffset = array[startingIndex];\n  return result;\n};\n\nfunction update(frustum) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(frustum.fov) || !defined(frustum.aspectRatio) || !defined(frustum.near) || !defined(frustum.far)) {\n    throw new DeveloperError(\"fov, aspectRatio, near, or far parameters are not set.\");\n  } //>>includeEnd('debug');\n\n\n  var f = frustum._offCenterFrustum;\n\n  if (frustum.fov !== frustum._fov || frustum.aspectRatio !== frustum._aspectRatio || frustum.near !== frustum._near || frustum.far !== frustum._far || frustum.xOffset !== frustum._xOffset || frustum.yOffset !== frustum._yOffset) {\n    //>>includeStart('debug', pragmas.debug);\n    if (frustum.fov < 0 || frustum.fov >= Math.PI) {\n      throw new DeveloperError(\"fov must be in the range [0, PI).\");\n    }\n\n    if (frustum.aspectRatio < 0) {\n      throw new DeveloperError(\"aspectRatio must be positive.\");\n    }\n\n    if (frustum.near < 0 || frustum.near > frustum.far) {\n      throw new DeveloperError(\"near must be greater than zero and less than far.\");\n    } //>>includeEnd('debug');\n\n\n    frustum._aspectRatio = frustum.aspectRatio;\n    frustum._fov = frustum.fov;\n    frustum._fovy = frustum.aspectRatio <= 1 ? frustum.fov : Math.atan(Math.tan(frustum.fov * 0.5) / frustum.aspectRatio) * 2.0;\n    frustum._near = frustum.near;\n    frustum._far = frustum.far;\n    frustum._sseDenominator = 2.0 * Math.tan(0.5 * frustum._fovy);\n    frustum._xOffset = frustum.xOffset;\n    frustum._yOffset = frustum.yOffset;\n    f.top = frustum.near * Math.tan(0.5 * frustum._fovy);\n    f.bottom = -f.top;\n    f.right = frustum.aspectRatio * f.top;\n    f.left = -f.right;\n    f.near = frustum.near;\n    f.far = frustum.far;\n    f.right += frustum.xOffset;\n    f.left += frustum.xOffset;\n    f.top += frustum.yOffset;\n    f.bottom += frustum.yOffset;\n  }\n}\n\nObject.defineProperties(PerspectiveFrustum.prototype, {\n  /**\n   * Gets the perspective projection matrix computed from the view frustum.\n   * @memberof PerspectiveFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveFrustum#infiniteProjectionMatrix\n   */\n  projectionMatrix: {\n    get: function get() {\n      update(this);\n      return this._offCenterFrustum.projectionMatrix;\n    }\n  },\n\n  /**\n   * The perspective projection matrix computed from the view frustum with an infinite far plane.\n   * @memberof PerspectiveFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveFrustum#projectionMatrix\n   */\n  infiniteProjectionMatrix: {\n    get: function get() {\n      update(this);\n      return this._offCenterFrustum.infiniteProjectionMatrix;\n    }\n  },\n\n  /**\n   * Gets the angle of the vertical field of view, in radians.\n   * @memberof PerspectiveFrustum.prototype\n   * @type {Number}\n   * @readonly\n   * @default undefined\n   */\n  fovy: {\n    get: function get() {\n      update(this);\n      return this._fovy;\n    }\n  },\n\n  /**\n   * @readonly\n   * @private\n   */\n  sseDenominator: {\n    get: function get() {\n      update(this);\n      return this._sseDenominator;\n    }\n  }\n});\n/**\n * Creates a culling volume for this frustum.\n *\n * @param {Cartesian3} position The eye position.\n * @param {Cartesian3} direction The view direction.\n * @param {Cartesian3} up The up direction.\n * @returns {CullingVolume} A culling volume at the given position and orientation.\n *\n * @example\n * // Check if a bounding volume intersects the frustum.\n * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * var intersect = cullingVolume.computeVisibility(boundingVolume);\n */\n\nPerspectiveFrustum.prototype.computeCullingVolume = function (position, direction, up) {\n  update(this);\n  return this._offCenterFrustum.computeCullingVolume(position, direction, up);\n};\n/**\n * Returns the pixel's width and height in meters.\n *\n * @param {Number} drawingBufferWidth The width of the drawing buffer.\n * @param {Number} drawingBufferHeight The height of the drawing buffer.\n * @param {Number} distance The distance to the near plane in meters.\n * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\n *\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n * @exception {DeveloperError} pixelRatio must be greater than zero.\n *\n * @example\n * // Example 1\n * // Get the width and height of a pixel.\n * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new Cesium.Cartesian2());\n *\n * @example\n * // Example 2\n * // Get the width and height of a pixel if the near plane was set to 'distance'.\n * // For example, get the size of a pixel of an image on a billboard.\n * var position = camera.position;\n * var direction = camera.direction;\n * var toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive\n * var toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector\n * var distance = Cesium.Cartesian3.magnitude(toCenterProj);\n * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, scene.pixelRatio, new Cesium.Cartesian2());\n */\n\n\nPerspectiveFrustum.prototype.getPixelDimensions = function (drawingBufferWidth, drawingBufferHeight, distance, pixelRatio, result) {\n  update(this);\n  return this._offCenterFrustum.getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, pixelRatio, result);\n};\n/**\n * Returns a duplicate of a PerspectiveFrustum instance.\n *\n * @param {PerspectiveFrustum} [result] The object onto which to store the result.\n * @returns {PerspectiveFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\n */\n\n\nPerspectiveFrustum.prototype.clone = function (result) {\n  if (!defined(result)) {\n    result = new PerspectiveFrustum();\n  }\n\n  result.aspectRatio = this.aspectRatio;\n  result.fov = this.fov;\n  result.near = this.near;\n  result.far = this.far; // force update of clone to compute matrices\n\n  result._aspectRatio = undefined;\n  result._fov = undefined;\n  result._near = undefined;\n  result._far = undefined;\n\n  this._offCenterFrustum.clone(result._offCenterFrustum);\n\n  return result;\n};\n/**\n * Compares the provided PerspectiveFrustum componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {PerspectiveFrustum} [other] The right hand side PerspectiveFrustum.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\n\n\nPerspectiveFrustum.prototype.equals = function (other) {\n  if (!defined(other) || !(other instanceof PerspectiveFrustum)) {\n    return false;\n  }\n\n  update(this);\n  update(other);\n  return this.fov === other.fov && this.aspectRatio === other.aspectRatio && this._offCenterFrustum.equals(other._offCenterFrustum);\n};\n/**\n * Compares the provided PerspectiveFrustum componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {PerspectiveFrustum} other The right hand side PerspectiveFrustum.\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\n */\n\n\nPerspectiveFrustum.prototype.equalsEpsilon = function (other, relativeEpsilon, absoluteEpsilon) {\n  if (!defined(other) || !(other instanceof PerspectiveFrustum)) {\n    return false;\n  }\n\n  update(this);\n  update(other);\n  return CesiumMath.equalsEpsilon(this.fov, other.fov, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(this.aspectRatio, other.aspectRatio, relativeEpsilon, absoluteEpsilon) && this._offCenterFrustum.equalsEpsilon(other._offCenterFrustum, relativeEpsilon, absoluteEpsilon);\n};\n\nexport default PerspectiveFrustum;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/PerspectiveFrustum.js"],"names":["Check","defaultValue","defined","DeveloperError","CesiumMath","PerspectiveOffCenterFrustum","PerspectiveFrustum","options","EMPTY_OBJECT","_offCenterFrustum","fov","_fov","undefined","_fovy","_sseDenominator","aspectRatio","_aspectRatio","near","_near","far","_far","xOffset","_xOffset","yOffset","_yOffset","packedLength","pack","value","array","startingIndex","typeOf","object","unpack","result","update","frustum","f","Math","PI","atan","tan","top","bottom","right","left","Object","defineProperties","prototype","projectionMatrix","get","infiniteProjectionMatrix","fovy","sseDenominator","computeCullingVolume","position","direction","up","getPixelDimensions","drawingBufferWidth","drawingBufferHeight","distance","pixelRatio","clone","equals","other","equalsEpsilon","relativeEpsilon","absoluteEpsilon"],"mappings":"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","sourcesContent":["import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport PerspectiveOffCenterFrustum from \"./PerspectiveOffCenterFrustum.js\";\n\n/**\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias PerspectiveFrustum\n * @constructor\n *\n * @param {Object} [options] An object with the following properties:\n * @param {Number} [options.fov] The angle of the field of view (FOV), in radians.\n * @param {Number} [options.aspectRatio] The aspect ratio of the frustum's width to it's height.\n * @param {Number} [options.near=1.0] The distance of the near plane.\n * @param {Number} [options.far=500000000.0] The distance of the far plane.\n * @param {Number} [options.xOffset=0.0] The offset in the x direction.\n * @param {Number} [options.yOffset=0.0] The offset in the y direction.\n *\n * @example\n * var frustum = new Cesium.PerspectiveFrustum({\n *     fov : Cesium.Math.PI_OVER_THREE,\n *     aspectRatio : canvas.clientWidth / canvas.clientHeight\n *     near : 1.0,\n *     far : 1000.0\n * });\n *\n * @see PerspectiveOffCenterFrustum\n */\nfunction PerspectiveFrustum(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._offCenterFrustum = new PerspectiveOffCenterFrustum();\n\n  /**\n   * The angle of the field of view (FOV), in radians.  This angle will be used\n   * as the horizontal FOV if the width is greater than the height, otherwise\n   * it will be the vertical FOV.\n   * @type {Number}\n   * @default undefined\n   */\n  this.fov = options.fov;\n  this._fov = undefined;\n  this._fovy = undefined;\n\n  this._sseDenominator = undefined;\n\n  /**\n   * The aspect ratio of the frustum's width to it's height.\n   * @type {Number}\n   * @default undefined\n   */\n  this.aspectRatio = options.aspectRatio;\n  this._aspectRatio = undefined;\n\n  /**\n   * The distance of the near plane.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.near = defaultValue(options.near, 1.0);\n  this._near = this.near;\n\n  /**\n   * The distance of the far plane.\n   * @type {Number}\n   * @default 500000000.0\n   */\n  this.far = defaultValue(options.far, 500000000.0);\n  this._far = this.far;\n\n  /**\n   * Offsets the frustum in the x direction.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.xOffset = defaultValue(options.xOffset, 0.0);\n  this._xOffset = this.xOffset;\n\n  /**\n   * Offsets the frustum in the y direction.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.yOffset = defaultValue(options.yOffset, 0.0);\n  this._yOffset = this.yOffset;\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nPerspectiveFrustum.packedLength = 6;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PerspectiveFrustum} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nPerspectiveFrustum.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.fov;\n  array[startingIndex++] = value.aspectRatio;\n  array[startingIndex++] = value.near;\n  array[startingIndex++] = value.far;\n  array[startingIndex++] = value.xOffset;\n  array[startingIndex] = value.yOffset;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PerspectiveFrustum} [result] The object into which to store the result.\n * @returns {PerspectiveFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\n */\nPerspectiveFrustum.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new PerspectiveFrustum();\n  }\n\n  result.fov = array[startingIndex++];\n  result.aspectRatio = array[startingIndex++];\n  result.near = array[startingIndex++];\n  result.far = array[startingIndex++];\n  result.xOffset = array[startingIndex++];\n  result.yOffset = array[startingIndex];\n\n  return result;\n};\n\nfunction update(frustum) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(frustum.fov) ||\n    !defined(frustum.aspectRatio) ||\n    !defined(frustum.near) ||\n    !defined(frustum.far)\n  ) {\n    throw new DeveloperError(\n      \"fov, aspectRatio, near, or far parameters are not set.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var f = frustum._offCenterFrustum;\n\n  if (\n    frustum.fov !== frustum._fov ||\n    frustum.aspectRatio !== frustum._aspectRatio ||\n    frustum.near !== frustum._near ||\n    frustum.far !== frustum._far ||\n    frustum.xOffset !== frustum._xOffset ||\n    frustum.yOffset !== frustum._yOffset\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    if (frustum.fov < 0 || frustum.fov >= Math.PI) {\n      throw new DeveloperError(\"fov must be in the range [0, PI).\");\n    }\n\n    if (frustum.aspectRatio < 0) {\n      throw new DeveloperError(\"aspectRatio must be positive.\");\n    }\n\n    if (frustum.near < 0 || frustum.near > frustum.far) {\n      throw new DeveloperError(\n        \"near must be greater than zero and less than far.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    frustum._aspectRatio = frustum.aspectRatio;\n    frustum._fov = frustum.fov;\n    frustum._fovy =\n      frustum.aspectRatio <= 1\n        ? frustum.fov\n        : Math.atan(Math.tan(frustum.fov * 0.5) / frustum.aspectRatio) * 2.0;\n    frustum._near = frustum.near;\n    frustum._far = frustum.far;\n    frustum._sseDenominator = 2.0 * Math.tan(0.5 * frustum._fovy);\n    frustum._xOffset = frustum.xOffset;\n    frustum._yOffset = frustum.yOffset;\n\n    f.top = frustum.near * Math.tan(0.5 * frustum._fovy);\n    f.bottom = -f.top;\n    f.right = frustum.aspectRatio * f.top;\n    f.left = -f.right;\n    f.near = frustum.near;\n    f.far = frustum.far;\n\n    f.right += frustum.xOffset;\n    f.left += frustum.xOffset;\n    f.top += frustum.yOffset;\n    f.bottom += frustum.yOffset;\n  }\n}\n\nObject.defineProperties(PerspectiveFrustum.prototype, {\n  /**\n   * Gets the perspective projection matrix computed from the view frustum.\n   * @memberof PerspectiveFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveFrustum#infiniteProjectionMatrix\n   */\n  projectionMatrix: {\n    get: function () {\n      update(this);\n      return this._offCenterFrustum.projectionMatrix;\n    },\n  },\n\n  /**\n   * The perspective projection matrix computed from the view frustum with an infinite far plane.\n   * @memberof PerspectiveFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveFrustum#projectionMatrix\n   */\n  infiniteProjectionMatrix: {\n    get: function () {\n      update(this);\n      return this._offCenterFrustum.infiniteProjectionMatrix;\n    },\n  },\n\n  /**\n   * Gets the angle of the vertical field of view, in radians.\n   * @memberof PerspectiveFrustum.prototype\n   * @type {Number}\n   * @readonly\n   * @default undefined\n   */\n  fovy: {\n    get: function () {\n      update(this);\n      return this._fovy;\n    },\n  },\n\n  /**\n   * @readonly\n   * @private\n   */\n  sseDenominator: {\n    get: function () {\n      update(this);\n      return this._sseDenominator;\n    },\n  },\n});\n\n/**\n * Creates a culling volume for this frustum.\n *\n * @param {Cartesian3} position The eye position.\n * @param {Cartesian3} direction The view direction.\n * @param {Cartesian3} up The up direction.\n * @returns {CullingVolume} A culling volume at the given position and orientation.\n *\n * @example\n * // Check if a bounding volume intersects the frustum.\n * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * var intersect = cullingVolume.computeVisibility(boundingVolume);\n */\nPerspectiveFrustum.prototype.computeCullingVolume = function (\n  position,\n  direction,\n  up\n) {\n  update(this);\n  return this._offCenterFrustum.computeCullingVolume(position, direction, up);\n};\n\n/**\n * Returns the pixel's width and height in meters.\n *\n * @param {Number} drawingBufferWidth The width of the drawing buffer.\n * @param {Number} drawingBufferHeight The height of the drawing buffer.\n * @param {Number} distance The distance to the near plane in meters.\n * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\n *\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n * @exception {DeveloperError} pixelRatio must be greater than zero.\n *\n * @example\n * // Example 1\n * // Get the width and height of a pixel.\n * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new Cesium.Cartesian2());\n *\n * @example\n * // Example 2\n * // Get the width and height of a pixel if the near plane was set to 'distance'.\n * // For example, get the size of a pixel of an image on a billboard.\n * var position = camera.position;\n * var direction = camera.direction;\n * var toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive\n * var toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector\n * var distance = Cesium.Cartesian3.magnitude(toCenterProj);\n * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, scene.pixelRatio, new Cesium.Cartesian2());\n */\nPerspectiveFrustum.prototype.getPixelDimensions = function (\n  drawingBufferWidth,\n  drawingBufferHeight,\n  distance,\n  pixelRatio,\n  result\n) {\n  update(this);\n  return this._offCenterFrustum.getPixelDimensions(\n    drawingBufferWidth,\n    drawingBufferHeight,\n    distance,\n    pixelRatio,\n    result\n  );\n};\n\n/**\n * Returns a duplicate of a PerspectiveFrustum instance.\n *\n * @param {PerspectiveFrustum} [result] The object onto which to store the result.\n * @returns {PerspectiveFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\n */\nPerspectiveFrustum.prototype.clone = function (result) {\n  if (!defined(result)) {\n    result = new PerspectiveFrustum();\n  }\n\n  result.aspectRatio = this.aspectRatio;\n  result.fov = this.fov;\n  result.near = this.near;\n  result.far = this.far;\n\n  // force update of clone to compute matrices\n  result._aspectRatio = undefined;\n  result._fov = undefined;\n  result._near = undefined;\n  result._far = undefined;\n\n  this._offCenterFrustum.clone(result._offCenterFrustum);\n\n  return result;\n};\n\n/**\n * Compares the provided PerspectiveFrustum componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {PerspectiveFrustum} [other] The right hand side PerspectiveFrustum.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nPerspectiveFrustum.prototype.equals = function (other) {\n  if (!defined(other) || !(other instanceof PerspectiveFrustum)) {\n    return false;\n  }\n\n  update(this);\n  update(other);\n\n  return (\n    this.fov === other.fov &&\n    this.aspectRatio === other.aspectRatio &&\n    this._offCenterFrustum.equals(other._offCenterFrustum)\n  );\n};\n\n/**\n * Compares the provided PerspectiveFrustum componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {PerspectiveFrustum} other The right hand side PerspectiveFrustum.\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\n */\nPerspectiveFrustum.prototype.equalsEpsilon = function (\n  other,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  if (!defined(other) || !(other instanceof PerspectiveFrustum)) {\n    return false;\n  }\n\n  update(this);\n  update(other);\n\n  return (\n    CesiumMath.equalsEpsilon(\n      this.fov,\n      other.fov,\n      relativeEpsilon,\n      absoluteEpsilon\n    ) &&\n    CesiumMath.equalsEpsilon(\n      this.aspectRatio,\n      other.aspectRatio,\n      relativeEpsilon,\n      absoluteEpsilon\n    ) &&\n    this._offCenterFrustum.equalsEpsilon(\n      other._offCenterFrustum,\n      relativeEpsilon,\n      absoluteEpsilon\n    )\n  );\n};\nexport default PerspectiveFrustum;\n"]},"metadata":{},"sourceType":"module"}