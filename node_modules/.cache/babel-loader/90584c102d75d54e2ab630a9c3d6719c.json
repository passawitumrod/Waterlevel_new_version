{"ast":null,"code":"import AttributeCompression from \"./AttributeCompression.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport TerrainQuantization from \"./TerrainQuantization.js\";\nvar cartesian3Scratch = new Cartesian3();\nvar cartesian3DimScratch = new Cartesian3();\nvar cartesian2Scratch = new Cartesian2();\nvar matrix4Scratch = new Matrix4();\nvar matrix4Scratch2 = new Matrix4();\nvar SHIFT_LEFT_12 = Math.pow(2.0, 12.0);\n/**\n * Data used to quantize and pack the terrain mesh. The position can be unpacked for picking and all attributes\n * are unpacked in the vertex shader.\n *\n * @alias TerrainEncoding\n * @constructor\n *\n * @param {AxisAlignedBoundingBox} axisAlignedBoundingBox The bounds of the tile in the east-north-up coordinates at the tiles center.\n * @param {Number} minimumHeight The minimum height.\n * @param {Number} maximumHeight The maximum height.\n * @param {Matrix4} fromENU The east-north-up to fixed frame matrix at the center of the terrain mesh.\n * @param {Boolean} hasVertexNormals If the mesh has vertex normals.\n * @param {Boolean} [hasWebMercatorT=false] true if the terrain data includes a Web Mercator texture coordinate; otherwise, false.\n *\n * @private\n */\n\nfunction TerrainEncoding(axisAlignedBoundingBox, minimumHeight, maximumHeight, fromENU, hasVertexNormals, hasWebMercatorT) {\n  var quantization = TerrainQuantization.NONE;\n  var center;\n  var toENU;\n  var matrix;\n\n  if (defined(axisAlignedBoundingBox) && defined(minimumHeight) && defined(maximumHeight) && defined(fromENU)) {\n    var minimum = axisAlignedBoundingBox.minimum;\n    var maximum = axisAlignedBoundingBox.maximum;\n    var dimensions = Cartesian3.subtract(maximum, minimum, cartesian3DimScratch);\n    var hDim = maximumHeight - minimumHeight;\n    var maxDim = Math.max(Cartesian3.maximumComponent(dimensions), hDim);\n\n    if (maxDim < SHIFT_LEFT_12 - 1.0) {\n      quantization = TerrainQuantization.BITS12;\n    } else {\n      quantization = TerrainQuantization.NONE;\n    }\n\n    center = axisAlignedBoundingBox.center;\n    toENU = Matrix4.inverseTransformation(fromENU, new Matrix4());\n    var translation = Cartesian3.negate(minimum, cartesian3Scratch);\n    Matrix4.multiply(Matrix4.fromTranslation(translation, matrix4Scratch), toENU, toENU);\n    var scale = cartesian3Scratch;\n    scale.x = 1.0 / dimensions.x;\n    scale.y = 1.0 / dimensions.y;\n    scale.z = 1.0 / dimensions.z;\n    Matrix4.multiply(Matrix4.fromScale(scale, matrix4Scratch), toENU, toENU);\n    matrix = Matrix4.clone(fromENU);\n    Matrix4.setTranslation(matrix, Cartesian3.ZERO, matrix);\n    fromENU = Matrix4.clone(fromENU, new Matrix4());\n    var translationMatrix = Matrix4.fromTranslation(minimum, matrix4Scratch);\n    var scaleMatrix = Matrix4.fromScale(dimensions, matrix4Scratch2);\n    var st = Matrix4.multiply(translationMatrix, scaleMatrix, matrix4Scratch);\n    Matrix4.multiply(fromENU, st, fromENU);\n    Matrix4.multiply(matrix, st, matrix);\n  }\n  /**\n   * How the vertices of the mesh were compressed.\n   * @type {TerrainQuantization}\n   */\n\n\n  this.quantization = quantization;\n  /**\n   * The minimum height of the tile including the skirts.\n   * @type {Number}\n   */\n\n  this.minimumHeight = minimumHeight;\n  /**\n   * The maximum height of the tile.\n   * @type {Number}\n   */\n\n  this.maximumHeight = maximumHeight;\n  /**\n   * The center of the tile.\n   * @type {Cartesian3}\n   */\n\n  this.center = center;\n  /**\n   * A matrix that takes a vertex from the tile, transforms it to east-north-up at the center and scales\n   * it so each component is in the [0, 1] range.\n   * @type {Matrix4}\n   */\n\n  this.toScaledENU = toENU;\n  /**\n   * A matrix that restores a vertex transformed with toScaledENU back to the earth fixed reference frame\n   * @type {Matrix4}\n   */\n\n  this.fromScaledENU = fromENU;\n  /**\n   * The matrix used to decompress the terrain vertices in the shader for RTE rendering.\n   * @type {Matrix4}\n   */\n\n  this.matrix = matrix;\n  /**\n   * The terrain mesh contains normals.\n   * @type {Boolean}\n   */\n\n  this.hasVertexNormals = hasVertexNormals;\n  /**\n   * The terrain mesh contains a vertical texture coordinate following the Web Mercator projection.\n   * @type {Boolean}\n   */\n\n  this.hasWebMercatorT = defaultValue(hasWebMercatorT, false);\n}\n\nTerrainEncoding.prototype.encode = function (vertexBuffer, bufferIndex, position, uv, height, normalToPack, webMercatorT) {\n  var u = uv.x;\n  var v = uv.y;\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    position = Matrix4.multiplyByPoint(this.toScaledENU, position, cartesian3Scratch);\n    position.x = CesiumMath.clamp(position.x, 0.0, 1.0);\n    position.y = CesiumMath.clamp(position.y, 0.0, 1.0);\n    position.z = CesiumMath.clamp(position.z, 0.0, 1.0);\n    var hDim = this.maximumHeight - this.minimumHeight;\n    var h = CesiumMath.clamp((height - this.minimumHeight) / hDim, 0.0, 1.0);\n    Cartesian2.fromElements(position.x, position.y, cartesian2Scratch);\n    var compressed0 = AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\n    Cartesian2.fromElements(position.z, h, cartesian2Scratch);\n    var compressed1 = AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\n    Cartesian2.fromElements(u, v, cartesian2Scratch);\n    var compressed2 = AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\n    vertexBuffer[bufferIndex++] = compressed0;\n    vertexBuffer[bufferIndex++] = compressed1;\n    vertexBuffer[bufferIndex++] = compressed2;\n\n    if (this.hasWebMercatorT) {\n      Cartesian2.fromElements(webMercatorT, 0.0, cartesian2Scratch);\n      var compressed3 = AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\n      vertexBuffer[bufferIndex++] = compressed3;\n    }\n  } else {\n    Cartesian3.subtract(position, this.center, cartesian3Scratch);\n    vertexBuffer[bufferIndex++] = cartesian3Scratch.x;\n    vertexBuffer[bufferIndex++] = cartesian3Scratch.y;\n    vertexBuffer[bufferIndex++] = cartesian3Scratch.z;\n    vertexBuffer[bufferIndex++] = height;\n    vertexBuffer[bufferIndex++] = u;\n    vertexBuffer[bufferIndex++] = v;\n\n    if (this.hasWebMercatorT) {\n      vertexBuffer[bufferIndex++] = webMercatorT;\n    }\n  }\n\n  if (this.hasVertexNormals) {\n    vertexBuffer[bufferIndex++] = AttributeCompression.octPackFloat(normalToPack);\n  }\n\n  return bufferIndex;\n};\n\nTerrainEncoding.prototype.decodePosition = function (buffer, index, result) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  index *= this.getStride();\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    var xy = AttributeCompression.decompressTextureCoordinates(buffer[index], cartesian2Scratch);\n    result.x = xy.x;\n    result.y = xy.y;\n    var zh = AttributeCompression.decompressTextureCoordinates(buffer[index + 1], cartesian2Scratch);\n    result.z = zh.x;\n    return Matrix4.multiplyByPoint(this.fromScaledENU, result, result);\n  }\n\n  result.x = buffer[index];\n  result.y = buffer[index + 1];\n  result.z = buffer[index + 2];\n  return Cartesian3.add(result, this.center, result);\n};\n\nTerrainEncoding.prototype.decodeTextureCoordinates = function (buffer, index, result) {\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n\n  index *= this.getStride();\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    return AttributeCompression.decompressTextureCoordinates(buffer[index + 2], result);\n  }\n\n  return Cartesian2.fromElements(buffer[index + 4], buffer[index + 5], result);\n};\n\nTerrainEncoding.prototype.decodeHeight = function (buffer, index) {\n  index *= this.getStride();\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    var zh = AttributeCompression.decompressTextureCoordinates(buffer[index + 1], cartesian2Scratch);\n    return zh.y * (this.maximumHeight - this.minimumHeight) + this.minimumHeight;\n  }\n\n  return buffer[index + 3];\n};\n\nTerrainEncoding.prototype.decodeWebMercatorT = function (buffer, index) {\n  index *= this.getStride();\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    return AttributeCompression.decompressTextureCoordinates(buffer[index + 3], cartesian2Scratch).x;\n  }\n\n  return buffer[index + 6];\n};\n\nTerrainEncoding.prototype.getOctEncodedNormal = function (buffer, index, result) {\n  var stride = this.getStride();\n  index = (index + 1) * stride - 1;\n  var temp = buffer[index] / 256.0;\n  var x = Math.floor(temp);\n  var y = (temp - x) * 256.0;\n  return Cartesian2.fromElements(x, y, result);\n};\n\nTerrainEncoding.prototype.getStride = function () {\n  var vertexStride;\n\n  switch (this.quantization) {\n    case TerrainQuantization.BITS12:\n      vertexStride = 3;\n      break;\n\n    default:\n      vertexStride = 6;\n  }\n\n  if (this.hasWebMercatorT) {\n    ++vertexStride;\n  }\n\n  if (this.hasVertexNormals) {\n    ++vertexStride;\n  }\n\n  return vertexStride;\n};\n\nvar attributesNone = {\n  position3DAndHeight: 0,\n  textureCoordAndEncodedNormals: 1\n};\nvar attributes = {\n  compressed0: 0,\n  compressed1: 1\n};\n\nTerrainEncoding.prototype.getAttributes = function (buffer) {\n  var datatype = ComponentDatatype.FLOAT;\n  var sizeInBytes = ComponentDatatype.getSizeInBytes(datatype);\n  var stride;\n\n  if (this.quantization === TerrainQuantization.NONE) {\n    var position3DAndHeightLength = 4;\n    var numTexCoordComponents = 2;\n\n    if (this.hasWebMercatorT) {\n      ++numTexCoordComponents;\n    }\n\n    if (this.hasVertexNormals) {\n      ++numTexCoordComponents;\n    }\n\n    stride = (position3DAndHeightLength + numTexCoordComponents) * sizeInBytes;\n    return [{\n      index: attributesNone.position3DAndHeight,\n      vertexBuffer: buffer,\n      componentDatatype: datatype,\n      componentsPerAttribute: position3DAndHeightLength,\n      offsetInBytes: 0,\n      strideInBytes: stride\n    }, {\n      index: attributesNone.textureCoordAndEncodedNormals,\n      vertexBuffer: buffer,\n      componentDatatype: datatype,\n      componentsPerAttribute: numTexCoordComponents,\n      offsetInBytes: position3DAndHeightLength * sizeInBytes,\n      strideInBytes: stride\n    }];\n  }\n\n  var numCompressed0 = 3;\n  var numCompressed1 = 0;\n\n  if (this.hasWebMercatorT || this.hasVertexNormals) {\n    ++numCompressed0;\n  }\n\n  if (this.hasWebMercatorT && this.hasVertexNormals) {\n    ++numCompressed1;\n    stride = (numCompressed0 + numCompressed1) * sizeInBytes;\n    return [{\n      index: attributes.compressed0,\n      vertexBuffer: buffer,\n      componentDatatype: datatype,\n      componentsPerAttribute: numCompressed0,\n      offsetInBytes: 0,\n      strideInBytes: stride\n    }, {\n      index: attributes.compressed1,\n      vertexBuffer: buffer,\n      componentDatatype: datatype,\n      componentsPerAttribute: numCompressed1,\n      offsetInBytes: numCompressed0 * sizeInBytes,\n      strideInBytes: stride\n    }];\n  }\n\n  return [{\n    index: attributes.compressed0,\n    vertexBuffer: buffer,\n    componentDatatype: datatype,\n    componentsPerAttribute: numCompressed0\n  }];\n};\n\nTerrainEncoding.prototype.getAttributeLocations = function () {\n  if (this.quantization === TerrainQuantization.NONE) {\n    return attributesNone;\n  }\n\n  return attributes;\n};\n\nTerrainEncoding.clone = function (encoding, result) {\n  if (!defined(result)) {\n    result = new TerrainEncoding();\n  }\n\n  result.quantization = encoding.quantization;\n  result.minimumHeight = encoding.minimumHeight;\n  result.maximumHeight = encoding.maximumHeight;\n  result.center = Cartesian3.clone(encoding.center);\n  result.toScaledENU = Matrix4.clone(encoding.toScaledENU);\n  result.fromScaledENU = Matrix4.clone(encoding.fromScaledENU);\n  result.matrix = Matrix4.clone(encoding.matrix);\n  result.hasVertexNormals = encoding.hasVertexNormals;\n  result.hasWebMercatorT = encoding.hasWebMercatorT;\n  return result;\n};\n\nexport default TerrainEncoding;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/TerrainEncoding.js"],"names":["AttributeCompression","Cartesian2","Cartesian3","ComponentDatatype","defaultValue","defined","CesiumMath","Matrix4","TerrainQuantization","cartesian3Scratch","cartesian3DimScratch","cartesian2Scratch","matrix4Scratch","matrix4Scratch2","SHIFT_LEFT_12","Math","pow","TerrainEncoding","axisAlignedBoundingBox","minimumHeight","maximumHeight","fromENU","hasVertexNormals","hasWebMercatorT","quantization","NONE","center","toENU","matrix","minimum","maximum","dimensions","subtract","hDim","maxDim","max","maximumComponent","BITS12","inverseTransformation","translation","negate","multiply","fromTranslation","scale","x","y","z","fromScale","clone","setTranslation","ZERO","translationMatrix","scaleMatrix","st","toScaledENU","fromScaledENU","prototype","encode","vertexBuffer","bufferIndex","position","uv","height","normalToPack","webMercatorT","u","v","multiplyByPoint","clamp","h","fromElements","compressed0","compressTextureCoordinates","compressed1","compressed2","compressed3","octPackFloat","decodePosition","buffer","index","result","getStride","xy","decompressTextureCoordinates","zh","add","decodeTextureCoordinates","decodeHeight","decodeWebMercatorT","getOctEncodedNormal","stride","temp","floor","vertexStride","attributesNone","position3DAndHeight","textureCoordAndEncodedNormals","attributes","getAttributes","datatype","FLOAT","sizeInBytes","getSizeInBytes","position3DAndHeightLength","numTexCoordComponents","componentDatatype","componentsPerAttribute","offsetInBytes","strideInBytes","numCompressed0","numCompressed1","getAttributeLocations","encoding"],"mappings":"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","sourcesContent":["import AttributeCompression from \"./AttributeCompression.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport TerrainQuantization from \"./TerrainQuantization.js\";\n\nvar cartesian3Scratch = new Cartesian3();\nvar cartesian3DimScratch = new Cartesian3();\nvar cartesian2Scratch = new Cartesian2();\nvar matrix4Scratch = new Matrix4();\nvar matrix4Scratch2 = new Matrix4();\n\nvar SHIFT_LEFT_12 = Math.pow(2.0, 12.0);\n\n/**\n * Data used to quantize and pack the terrain mesh. The position can be unpacked for picking and all attributes\n * are unpacked in the vertex shader.\n *\n * @alias TerrainEncoding\n * @constructor\n *\n * @param {AxisAlignedBoundingBox} axisAlignedBoundingBox The bounds of the tile in the east-north-up coordinates at the tiles center.\n * @param {Number} minimumHeight The minimum height.\n * @param {Number} maximumHeight The maximum height.\n * @param {Matrix4} fromENU The east-north-up to fixed frame matrix at the center of the terrain mesh.\n * @param {Boolean} hasVertexNormals If the mesh has vertex normals.\n * @param {Boolean} [hasWebMercatorT=false] true if the terrain data includes a Web Mercator texture coordinate; otherwise, false.\n *\n * @private\n */\nfunction TerrainEncoding(\n  axisAlignedBoundingBox,\n  minimumHeight,\n  maximumHeight,\n  fromENU,\n  hasVertexNormals,\n  hasWebMercatorT\n) {\n  var quantization = TerrainQuantization.NONE;\n  var center;\n  var toENU;\n  var matrix;\n\n  if (\n    defined(axisAlignedBoundingBox) &&\n    defined(minimumHeight) &&\n    defined(maximumHeight) &&\n    defined(fromENU)\n  ) {\n    var minimum = axisAlignedBoundingBox.minimum;\n    var maximum = axisAlignedBoundingBox.maximum;\n\n    var dimensions = Cartesian3.subtract(\n      maximum,\n      minimum,\n      cartesian3DimScratch\n    );\n    var hDim = maximumHeight - minimumHeight;\n    var maxDim = Math.max(Cartesian3.maximumComponent(dimensions), hDim);\n\n    if (maxDim < SHIFT_LEFT_12 - 1.0) {\n      quantization = TerrainQuantization.BITS12;\n    } else {\n      quantization = TerrainQuantization.NONE;\n    }\n\n    center = axisAlignedBoundingBox.center;\n    toENU = Matrix4.inverseTransformation(fromENU, new Matrix4());\n\n    var translation = Cartesian3.negate(minimum, cartesian3Scratch);\n    Matrix4.multiply(\n      Matrix4.fromTranslation(translation, matrix4Scratch),\n      toENU,\n      toENU\n    );\n\n    var scale = cartesian3Scratch;\n    scale.x = 1.0 / dimensions.x;\n    scale.y = 1.0 / dimensions.y;\n    scale.z = 1.0 / dimensions.z;\n    Matrix4.multiply(Matrix4.fromScale(scale, matrix4Scratch), toENU, toENU);\n\n    matrix = Matrix4.clone(fromENU);\n    Matrix4.setTranslation(matrix, Cartesian3.ZERO, matrix);\n\n    fromENU = Matrix4.clone(fromENU, new Matrix4());\n\n    var translationMatrix = Matrix4.fromTranslation(minimum, matrix4Scratch);\n    var scaleMatrix = Matrix4.fromScale(dimensions, matrix4Scratch2);\n    var st = Matrix4.multiply(translationMatrix, scaleMatrix, matrix4Scratch);\n\n    Matrix4.multiply(fromENU, st, fromENU);\n    Matrix4.multiply(matrix, st, matrix);\n  }\n\n  /**\n   * How the vertices of the mesh were compressed.\n   * @type {TerrainQuantization}\n   */\n  this.quantization = quantization;\n\n  /**\n   * The minimum height of the tile including the skirts.\n   * @type {Number}\n   */\n  this.minimumHeight = minimumHeight;\n\n  /**\n   * The maximum height of the tile.\n   * @type {Number}\n   */\n  this.maximumHeight = maximumHeight;\n\n  /**\n   * The center of the tile.\n   * @type {Cartesian3}\n   */\n  this.center = center;\n\n  /**\n   * A matrix that takes a vertex from the tile, transforms it to east-north-up at the center and scales\n   * it so each component is in the [0, 1] range.\n   * @type {Matrix4}\n   */\n  this.toScaledENU = toENU;\n\n  /**\n   * A matrix that restores a vertex transformed with toScaledENU back to the earth fixed reference frame\n   * @type {Matrix4}\n   */\n  this.fromScaledENU = fromENU;\n\n  /**\n   * The matrix used to decompress the terrain vertices in the shader for RTE rendering.\n   * @type {Matrix4}\n   */\n  this.matrix = matrix;\n\n  /**\n   * The terrain mesh contains normals.\n   * @type {Boolean}\n   */\n  this.hasVertexNormals = hasVertexNormals;\n\n  /**\n   * The terrain mesh contains a vertical texture coordinate following the Web Mercator projection.\n   * @type {Boolean}\n   */\n  this.hasWebMercatorT = defaultValue(hasWebMercatorT, false);\n}\n\nTerrainEncoding.prototype.encode = function (\n  vertexBuffer,\n  bufferIndex,\n  position,\n  uv,\n  height,\n  normalToPack,\n  webMercatorT\n) {\n  var u = uv.x;\n  var v = uv.y;\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    position = Matrix4.multiplyByPoint(\n      this.toScaledENU,\n      position,\n      cartesian3Scratch\n    );\n\n    position.x = CesiumMath.clamp(position.x, 0.0, 1.0);\n    position.y = CesiumMath.clamp(position.y, 0.0, 1.0);\n    position.z = CesiumMath.clamp(position.z, 0.0, 1.0);\n\n    var hDim = this.maximumHeight - this.minimumHeight;\n    var h = CesiumMath.clamp((height - this.minimumHeight) / hDim, 0.0, 1.0);\n\n    Cartesian2.fromElements(position.x, position.y, cartesian2Scratch);\n    var compressed0 = AttributeCompression.compressTextureCoordinates(\n      cartesian2Scratch\n    );\n\n    Cartesian2.fromElements(position.z, h, cartesian2Scratch);\n    var compressed1 = AttributeCompression.compressTextureCoordinates(\n      cartesian2Scratch\n    );\n\n    Cartesian2.fromElements(u, v, cartesian2Scratch);\n    var compressed2 = AttributeCompression.compressTextureCoordinates(\n      cartesian2Scratch\n    );\n\n    vertexBuffer[bufferIndex++] = compressed0;\n    vertexBuffer[bufferIndex++] = compressed1;\n    vertexBuffer[bufferIndex++] = compressed2;\n\n    if (this.hasWebMercatorT) {\n      Cartesian2.fromElements(webMercatorT, 0.0, cartesian2Scratch);\n      var compressed3 = AttributeCompression.compressTextureCoordinates(\n        cartesian2Scratch\n      );\n      vertexBuffer[bufferIndex++] = compressed3;\n    }\n  } else {\n    Cartesian3.subtract(position, this.center, cartesian3Scratch);\n\n    vertexBuffer[bufferIndex++] = cartesian3Scratch.x;\n    vertexBuffer[bufferIndex++] = cartesian3Scratch.y;\n    vertexBuffer[bufferIndex++] = cartesian3Scratch.z;\n    vertexBuffer[bufferIndex++] = height;\n    vertexBuffer[bufferIndex++] = u;\n    vertexBuffer[bufferIndex++] = v;\n\n    if (this.hasWebMercatorT) {\n      vertexBuffer[bufferIndex++] = webMercatorT;\n    }\n  }\n\n  if (this.hasVertexNormals) {\n    vertexBuffer[bufferIndex++] = AttributeCompression.octPackFloat(\n      normalToPack\n    );\n  }\n\n  return bufferIndex;\n};\n\nTerrainEncoding.prototype.decodePosition = function (buffer, index, result) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  index *= this.getStride();\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    var xy = AttributeCompression.decompressTextureCoordinates(\n      buffer[index],\n      cartesian2Scratch\n    );\n    result.x = xy.x;\n    result.y = xy.y;\n\n    var zh = AttributeCompression.decompressTextureCoordinates(\n      buffer[index + 1],\n      cartesian2Scratch\n    );\n    result.z = zh.x;\n\n    return Matrix4.multiplyByPoint(this.fromScaledENU, result, result);\n  }\n\n  result.x = buffer[index];\n  result.y = buffer[index + 1];\n  result.z = buffer[index + 2];\n  return Cartesian3.add(result, this.center, result);\n};\n\nTerrainEncoding.prototype.decodeTextureCoordinates = function (\n  buffer,\n  index,\n  result\n) {\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n\n  index *= this.getStride();\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    return AttributeCompression.decompressTextureCoordinates(\n      buffer[index + 2],\n      result\n    );\n  }\n\n  return Cartesian2.fromElements(buffer[index + 4], buffer[index + 5], result);\n};\n\nTerrainEncoding.prototype.decodeHeight = function (buffer, index) {\n  index *= this.getStride();\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    var zh = AttributeCompression.decompressTextureCoordinates(\n      buffer[index + 1],\n      cartesian2Scratch\n    );\n    return (\n      zh.y * (this.maximumHeight - this.minimumHeight) + this.minimumHeight\n    );\n  }\n\n  return buffer[index + 3];\n};\n\nTerrainEncoding.prototype.decodeWebMercatorT = function (buffer, index) {\n  index *= this.getStride();\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    return AttributeCompression.decompressTextureCoordinates(\n      buffer[index + 3],\n      cartesian2Scratch\n    ).x;\n  }\n\n  return buffer[index + 6];\n};\n\nTerrainEncoding.prototype.getOctEncodedNormal = function (\n  buffer,\n  index,\n  result\n) {\n  var stride = this.getStride();\n  index = (index + 1) * stride - 1;\n\n  var temp = buffer[index] / 256.0;\n  var x = Math.floor(temp);\n  var y = (temp - x) * 256.0;\n\n  return Cartesian2.fromElements(x, y, result);\n};\n\nTerrainEncoding.prototype.getStride = function () {\n  var vertexStride;\n\n  switch (this.quantization) {\n    case TerrainQuantization.BITS12:\n      vertexStride = 3;\n      break;\n    default:\n      vertexStride = 6;\n  }\n\n  if (this.hasWebMercatorT) {\n    ++vertexStride;\n  }\n\n  if (this.hasVertexNormals) {\n    ++vertexStride;\n  }\n\n  return vertexStride;\n};\n\nvar attributesNone = {\n  position3DAndHeight: 0,\n  textureCoordAndEncodedNormals: 1,\n};\nvar attributes = {\n  compressed0: 0,\n  compressed1: 1,\n};\n\nTerrainEncoding.prototype.getAttributes = function (buffer) {\n  var datatype = ComponentDatatype.FLOAT;\n  var sizeInBytes = ComponentDatatype.getSizeInBytes(datatype);\n  var stride;\n\n  if (this.quantization === TerrainQuantization.NONE) {\n    var position3DAndHeightLength = 4;\n    var numTexCoordComponents = 2;\n\n    if (this.hasWebMercatorT) {\n      ++numTexCoordComponents;\n    }\n\n    if (this.hasVertexNormals) {\n      ++numTexCoordComponents;\n    }\n\n    stride = (position3DAndHeightLength + numTexCoordComponents) * sizeInBytes;\n\n    return [\n      {\n        index: attributesNone.position3DAndHeight,\n        vertexBuffer: buffer,\n        componentDatatype: datatype,\n        componentsPerAttribute: position3DAndHeightLength,\n        offsetInBytes: 0,\n        strideInBytes: stride,\n      },\n      {\n        index: attributesNone.textureCoordAndEncodedNormals,\n        vertexBuffer: buffer,\n        componentDatatype: datatype,\n        componentsPerAttribute: numTexCoordComponents,\n        offsetInBytes: position3DAndHeightLength * sizeInBytes,\n        strideInBytes: stride,\n      },\n    ];\n  }\n\n  var numCompressed0 = 3;\n  var numCompressed1 = 0;\n\n  if (this.hasWebMercatorT || this.hasVertexNormals) {\n    ++numCompressed0;\n  }\n\n  if (this.hasWebMercatorT && this.hasVertexNormals) {\n    ++numCompressed1;\n\n    stride = (numCompressed0 + numCompressed1) * sizeInBytes;\n\n    return [\n      {\n        index: attributes.compressed0,\n        vertexBuffer: buffer,\n        componentDatatype: datatype,\n        componentsPerAttribute: numCompressed0,\n        offsetInBytes: 0,\n        strideInBytes: stride,\n      },\n      {\n        index: attributes.compressed1,\n        vertexBuffer: buffer,\n        componentDatatype: datatype,\n        componentsPerAttribute: numCompressed1,\n        offsetInBytes: numCompressed0 * sizeInBytes,\n        strideInBytes: stride,\n      },\n    ];\n  }\n  return [\n    {\n      index: attributes.compressed0,\n      vertexBuffer: buffer,\n      componentDatatype: datatype,\n      componentsPerAttribute: numCompressed0,\n    },\n  ];\n};\n\nTerrainEncoding.prototype.getAttributeLocations = function () {\n  if (this.quantization === TerrainQuantization.NONE) {\n    return attributesNone;\n  }\n  return attributes;\n};\n\nTerrainEncoding.clone = function (encoding, result) {\n  if (!defined(result)) {\n    result = new TerrainEncoding();\n  }\n\n  result.quantization = encoding.quantization;\n  result.minimumHeight = encoding.minimumHeight;\n  result.maximumHeight = encoding.maximumHeight;\n  result.center = Cartesian3.clone(encoding.center);\n  result.toScaledENU = Matrix4.clone(encoding.toScaledENU);\n  result.fromScaledENU = Matrix4.clone(encoding.fromScaledENU);\n  result.matrix = Matrix4.clone(encoding.matrix);\n  result.hasVertexNormals = encoding.hasVertexNormals;\n  result.hasWebMercatorT = encoding.hasWebMercatorT;\n  return result;\n};\nexport default TerrainEncoding;\n"]},"metadata":{},"sourceType":"module"}