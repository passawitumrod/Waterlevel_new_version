{"ast":null,"code":"import Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport CesiumMath from \"./Math.js\";\n/**\n * A two dimensional region specified as longitude and latitude coordinates.\n *\n * @alias Rectangle\n * @constructor\n *\n * @param {Number} [west=0.0] The westernmost longitude, in radians, in the range [-Pi, Pi].\n * @param {Number} [south=0.0] The southernmost latitude, in radians, in the range [-Pi/2, Pi/2].\n * @param {Number} [east=0.0] The easternmost longitude, in radians, in the range [-Pi, Pi].\n * @param {Number} [north=0.0] The northernmost latitude, in radians, in the range [-Pi/2, Pi/2].\n *\n * @see Packable\n */\n\nfunction Rectangle(west, south, east, north) {\n  /**\n   * The westernmost longitude in radians in the range [-Pi, Pi].\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n  this.west = defaultValue(west, 0.0);\n  /**\n   * The southernmost latitude in radians in the range [-Pi/2, Pi/2].\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.south = defaultValue(south, 0.0);\n  /**\n   * The easternmost longitude in radians in the range [-Pi, Pi].\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.east = defaultValue(east, 0.0);\n  /**\n   * The northernmost latitude in radians in the range [-Pi/2, Pi/2].\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.north = defaultValue(north, 0.0);\n}\n\nObject.defineProperties(Rectangle.prototype, {\n  /**\n   * Gets the width of the rectangle in radians.\n   * @memberof Rectangle.prototype\n   * @type {Number}\n   */\n  width: {\n    get: function () {\n      return Rectangle.computeWidth(this);\n    }\n  },\n\n  /**\n   * Gets the height of the rectangle in radians.\n   * @memberof Rectangle.prototype\n   * @type {Number}\n   */\n  height: {\n    get: function () {\n      return Rectangle.computeHeight(this);\n    }\n  }\n});\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\n\nRectangle.packedLength = 4;\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Rectangle} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\nRectangle.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  array[startingIndex++] = value.west;\n  array[startingIndex++] = value.south;\n  array[startingIndex++] = value.east;\n  array[startingIndex] = value.north;\n  return array;\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Rectangle} [result] The object into which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.\n */\n\n\nRectangle.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  result.west = array[startingIndex++];\n  result.south = array[startingIndex++];\n  result.east = array[startingIndex++];\n  result.north = array[startingIndex];\n  return result;\n};\n/**\n * Computes the width of a rectangle in radians.\n * @param {Rectangle} rectangle The rectangle to compute the width of.\n * @returns {Number} The width.\n */\n\n\nRectangle.computeWidth = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle); //>>includeEnd('debug');\n\n  var east = rectangle.east;\n  var west = rectangle.west;\n\n  if (east < west) {\n    east += CesiumMath.TWO_PI;\n  }\n\n  return east - west;\n};\n/**\n * Computes the height of a rectangle in radians.\n * @param {Rectangle} rectangle The rectangle to compute the height of.\n * @returns {Number} The height.\n */\n\n\nRectangle.computeHeight = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle); //>>includeEnd('debug');\n\n  return rectangle.north - rectangle.south;\n};\n/**\n * Creates a rectangle given the boundary longitude and latitude in degrees.\n *\n * @param {Number} [west=0.0] The westernmost longitude in degrees in the range [-180.0, 180.0].\n * @param {Number} [south=0.0] The southernmost latitude in degrees in the range [-90.0, 90.0].\n * @param {Number} [east=0.0] The easternmost longitude in degrees in the range [-180.0, 180.0].\n * @param {Number} [north=0.0] The northernmost latitude in degrees in the range [-90.0, 90.0].\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n *\n * @example\n * var rectangle = Cesium.Rectangle.fromDegrees(0.0, 20.0, 10.0, 30.0);\n */\n\n\nRectangle.fromDegrees = function (west, south, east, north, result) {\n  west = CesiumMath.toRadians(defaultValue(west, 0.0));\n  south = CesiumMath.toRadians(defaultValue(south, 0.0));\n  east = CesiumMath.toRadians(defaultValue(east, 0.0));\n  north = CesiumMath.toRadians(defaultValue(north, 0.0));\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n/**\n * Creates a rectangle given the boundary longitude and latitude in radians.\n *\n * @param {Number} [west=0.0] The westernmost longitude in radians in the range [-Math.PI, Math.PI].\n * @param {Number} [south=0.0] The southernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].\n * @param {Number} [east=0.0] The easternmost longitude in radians in the range [-Math.PI, Math.PI].\n * @param {Number} [north=0.0] The northernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n *\n * @example\n * var rectangle = Cesium.Rectangle.fromRadians(0.0, Math.PI/4, Math.PI/8, 3*Math.PI/4);\n */\n\n\nRectangle.fromRadians = function (west, south, east, north, result) {\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = defaultValue(west, 0.0);\n  result.south = defaultValue(south, 0.0);\n  result.east = defaultValue(east, 0.0);\n  result.north = defaultValue(north, 0.0);\n  return result;\n};\n/**\n * Creates the smallest possible Rectangle that encloses all positions in the provided array.\n *\n * @param {Cartographic[]} cartographics The list of Cartographic instances.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\n\n\nRectangle.fromCartographicArray = function (cartographics, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartographics\", cartographics); //>>includeEnd('debug');\n\n  var west = Number.MAX_VALUE;\n  var east = -Number.MAX_VALUE;\n  var westOverIDL = Number.MAX_VALUE;\n  var eastOverIDL = -Number.MAX_VALUE;\n  var south = Number.MAX_VALUE;\n  var north = -Number.MAX_VALUE;\n\n  for (var i = 0, len = cartographics.length; i < len; i++) {\n    var position = cartographics[i];\n    west = Math.min(west, position.longitude);\n    east = Math.max(east, position.longitude);\n    south = Math.min(south, position.latitude);\n    north = Math.max(north, position.latitude);\n    var lonAdjusted = position.longitude >= 0 ? position.longitude : position.longitude + CesiumMath.TWO_PI;\n    westOverIDL = Math.min(westOverIDL, lonAdjusted);\n    eastOverIDL = Math.max(eastOverIDL, lonAdjusted);\n  }\n\n  if (east - west > eastOverIDL - westOverIDL) {\n    west = westOverIDL;\n    east = eastOverIDL;\n\n    if (east > CesiumMath.PI) {\n      east = east - CesiumMath.TWO_PI;\n    }\n\n    if (west > CesiumMath.PI) {\n      west = west - CesiumMath.TWO_PI;\n    }\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n/**\n * Creates the smallest possible Rectangle that encloses all positions in the provided array.\n *\n * @param {Cartesian3[]} cartesians The list of Cartesian instances.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid the cartesians are on.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\n\n\nRectangle.fromCartesianArray = function (cartesians, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians); //>>includeEnd('debug');\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  var west = Number.MAX_VALUE;\n  var east = -Number.MAX_VALUE;\n  var westOverIDL = Number.MAX_VALUE;\n  var eastOverIDL = -Number.MAX_VALUE;\n  var south = Number.MAX_VALUE;\n  var north = -Number.MAX_VALUE;\n\n  for (var i = 0, len = cartesians.length; i < len; i++) {\n    var position = ellipsoid.cartesianToCartographic(cartesians[i]);\n    west = Math.min(west, position.longitude);\n    east = Math.max(east, position.longitude);\n    south = Math.min(south, position.latitude);\n    north = Math.max(north, position.latitude);\n    var lonAdjusted = position.longitude >= 0 ? position.longitude : position.longitude + CesiumMath.TWO_PI;\n    westOverIDL = Math.min(westOverIDL, lonAdjusted);\n    eastOverIDL = Math.max(eastOverIDL, lonAdjusted);\n  }\n\n  if (east - west > eastOverIDL - westOverIDL) {\n    west = westOverIDL;\n    east = eastOverIDL;\n\n    if (east > CesiumMath.PI) {\n      east = east - CesiumMath.TWO_PI;\n    }\n\n    if (west > CesiumMath.PI) {\n      west = west - CesiumMath.TWO_PI;\n    }\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n/**\n * Duplicates a Rectangle.\n *\n * @param {Rectangle} rectangle The rectangle to clone.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided. (Returns undefined if rectangle is undefined)\n */\n\n\nRectangle.clone = function (rectangle, result) {\n  if (!defined(rectangle)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(rectangle.west, rectangle.south, rectangle.east, rectangle.north);\n  }\n\n  result.west = rectangle.west;\n  result.south = rectangle.south;\n  result.east = rectangle.east;\n  result.north = rectangle.north;\n  return result;\n};\n/**\n * Compares the provided Rectangles componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Rectangle} [left] The first Rectangle.\n * @param {Rectangle} [right] The second Rectangle.\n * @param {Number} absoluteEpsilon The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\n\n\nRectangle.equalsEpsilon = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"absoluteEpsilon\", absoluteEpsilon); //>>includeEnd('debug');\n\n  return left === right || defined(left) && defined(right) && Math.abs(left.west - right.west) <= absoluteEpsilon && Math.abs(left.south - right.south) <= absoluteEpsilon && Math.abs(left.east - right.east) <= absoluteEpsilon && Math.abs(left.north - right.north) <= absoluteEpsilon;\n};\n/**\n * Duplicates this Rectangle.\n *\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\n\n\nRectangle.prototype.clone = function (result) {\n  return Rectangle.clone(this, result);\n};\n/**\n * Compares the provided Rectangle with this Rectangle componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Rectangle} [other] The Rectangle to compare.\n * @returns {Boolean} <code>true</code> if the Rectangles are equal, <code>false</code> otherwise.\n */\n\n\nRectangle.prototype.equals = function (other) {\n  return Rectangle.equals(this, other);\n};\n/**\n * Compares the provided rectangles and returns <code>true</code> if they are equal,\n * <code>false</code> otherwise.\n *\n * @param {Rectangle} [left] The first Rectangle.\n * @param {Rectangle} [right] The second Rectangle.\n * @returns {Boolean} <code>true</code> if left and right are equal; otherwise <code>false</code>.\n */\n\n\nRectangle.equals = function (left, right) {\n  return left === right || defined(left) && defined(right) && left.west === right.west && left.south === right.south && left.east === right.east && left.north === right.north;\n};\n/**\n * Compares the provided Rectangle with this Rectangle componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Rectangle} [other] The Rectangle to compare.\n * @param {Number} epsilon The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if the Rectangles are within the provided epsilon, <code>false</code> otherwise.\n */\n\n\nRectangle.prototype.equalsEpsilon = function (other, epsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"epsilon\", epsilon); //>>includeEnd('debug');\n\n  return Rectangle.equalsEpsilon(this, other, epsilon);\n};\n/**\n * Checks a Rectangle's properties and throws if they are not in valid ranges.\n *\n * @param {Rectangle} rectangle The rectangle to validate\n *\n * @exception {DeveloperError} <code>north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n */\n\n\nRectangle.validate = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  var north = rectangle.north;\n  Check.typeOf.number.greaterThanOrEquals(\"north\", north, -CesiumMath.PI_OVER_TWO);\n  Check.typeOf.number.lessThanOrEquals(\"north\", north, CesiumMath.PI_OVER_TWO);\n  var south = rectangle.south;\n  Check.typeOf.number.greaterThanOrEquals(\"south\", south, -CesiumMath.PI_OVER_TWO);\n  Check.typeOf.number.lessThanOrEquals(\"south\", south, CesiumMath.PI_OVER_TWO);\n  var west = rectangle.west;\n  Check.typeOf.number.greaterThanOrEquals(\"west\", west, -Math.PI);\n  Check.typeOf.number.lessThanOrEquals(\"west\", west, Math.PI);\n  var east = rectangle.east;\n  Check.typeOf.number.greaterThanOrEquals(\"east\", east, -Math.PI);\n  Check.typeOf.number.lessThanOrEquals(\"east\", east, Math.PI); //>>includeEnd('debug');\n};\n/**\n * Computes the southwest corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\n\n\nRectangle.southwest = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.west, rectangle.south);\n  }\n\n  result.longitude = rectangle.west;\n  result.latitude = rectangle.south;\n  result.height = 0.0;\n  return result;\n};\n/**\n * Computes the northwest corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\n\n\nRectangle.northwest = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.west, rectangle.north);\n  }\n\n  result.longitude = rectangle.west;\n  result.latitude = rectangle.north;\n  result.height = 0.0;\n  return result;\n};\n/**\n * Computes the northeast corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\n\n\nRectangle.northeast = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.east, rectangle.north);\n  }\n\n  result.longitude = rectangle.east;\n  result.latitude = rectangle.north;\n  result.height = 0.0;\n  return result;\n};\n/**\n * Computes the southeast corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\n\n\nRectangle.southeast = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.east, rectangle.south);\n  }\n\n  result.longitude = rectangle.east;\n  result.latitude = rectangle.south;\n  result.height = 0.0;\n  return result;\n};\n/**\n * Computes the center of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the center\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\n\n\nRectangle.center = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle); //>>includeEnd('debug');\n\n  var east = rectangle.east;\n  var west = rectangle.west;\n\n  if (east < west) {\n    east += CesiumMath.TWO_PI;\n  }\n\n  var longitude = CesiumMath.negativePiToPi((west + east) * 0.5);\n  var latitude = (rectangle.south + rectangle.north) * 0.5;\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude);\n  }\n\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = 0.0;\n  return result;\n};\n/**\n * Computes the intersection of two rectangles.  This function assumes that the rectangle's coordinates are\n * latitude and longitude in radians and produces a correct intersection, taking into account the fact that\n * the same angle can be represented with multiple values as well as the wrapping of longitude at the\n * anti-meridian.  For a simple intersection that ignores these factors and can be used with projected\n * coordinates, see {@link Rectangle.simpleIntersection}.\n *\n * @param {Rectangle} rectangle On rectangle to find an intersection\n * @param {Rectangle} otherRectangle Another rectangle to find an intersection\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.\n */\n\n\nRectangle.intersection = function (rectangle, otherRectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"otherRectangle\", otherRectangle); //>>includeEnd('debug');\n\n  var rectangleEast = rectangle.east;\n  var rectangleWest = rectangle.west;\n  var otherRectangleEast = otherRectangle.east;\n  var otherRectangleWest = otherRectangle.west;\n\n  if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {\n    rectangleEast += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {\n    otherRectangleEast += CesiumMath.TWO_PI;\n  }\n\n  if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {\n    otherRectangleWest += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {\n    rectangleWest += CesiumMath.TWO_PI;\n  }\n\n  var west = CesiumMath.negativePiToPi(Math.max(rectangleWest, otherRectangleWest));\n  var east = CesiumMath.negativePiToPi(Math.min(rectangleEast, otherRectangleEast));\n\n  if ((rectangle.west < rectangle.east || otherRectangle.west < otherRectangle.east) && east <= west) {\n    return undefined;\n  }\n\n  var south = Math.max(rectangle.south, otherRectangle.south);\n  var north = Math.min(rectangle.north, otherRectangle.north);\n\n  if (south >= north) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n/**\n * Computes a simple intersection of two rectangles.  Unlike {@link Rectangle.intersection}, this function\n * does not attempt to put the angular coordinates into a consistent range or to account for crossing the\n * anti-meridian.  As such, it can be used for rectangles where the coordinates are not simply latitude\n * and longitude (i.e. projected coordinates).\n *\n * @param {Rectangle} rectangle On rectangle to find an intersection\n * @param {Rectangle} otherRectangle Another rectangle to find an intersection\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.\n */\n\n\nRectangle.simpleIntersection = function (rectangle, otherRectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"otherRectangle\", otherRectangle); //>>includeEnd('debug');\n\n  var west = Math.max(rectangle.west, otherRectangle.west);\n  var south = Math.max(rectangle.south, otherRectangle.south);\n  var east = Math.min(rectangle.east, otherRectangle.east);\n  var north = Math.min(rectangle.north, otherRectangle.north);\n\n  if (south >= north || west >= east) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n/**\n * Computes a rectangle that is the union of two rectangles.\n *\n * @param {Rectangle} rectangle A rectangle to enclose in rectangle.\n * @param {Rectangle} otherRectangle A rectangle to enclose in a rectangle.\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\n\n\nRectangle.union = function (rectangle, otherRectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"otherRectangle\", otherRectangle); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  var rectangleEast = rectangle.east;\n  var rectangleWest = rectangle.west;\n  var otherRectangleEast = otherRectangle.east;\n  var otherRectangleWest = otherRectangle.west;\n\n  if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {\n    rectangleEast += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {\n    otherRectangleEast += CesiumMath.TWO_PI;\n  }\n\n  if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {\n    otherRectangleWest += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {\n    rectangleWest += CesiumMath.TWO_PI;\n  }\n\n  var west = CesiumMath.convertLongitudeRange(Math.min(rectangleWest, otherRectangleWest));\n  var east = CesiumMath.convertLongitudeRange(Math.max(rectangleEast, otherRectangleEast));\n  result.west = west;\n  result.south = Math.min(rectangle.south, otherRectangle.south);\n  result.east = east;\n  result.north = Math.max(rectangle.north, otherRectangle.north);\n  return result;\n};\n/**\n * Computes a rectangle by enlarging the provided rectangle until it contains the provided cartographic.\n *\n * @param {Rectangle} rectangle A rectangle to expand.\n * @param {Cartographic} cartographic A cartographic to enclose in a rectangle.\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.\n */\n\n\nRectangle.expand = function (rectangle, cartographic, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"cartographic\", cartographic); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  result.west = Math.min(rectangle.west, cartographic.longitude);\n  result.south = Math.min(rectangle.south, cartographic.latitude);\n  result.east = Math.max(rectangle.east, cartographic.longitude);\n  result.north = Math.max(rectangle.north, cartographic.latitude);\n  return result;\n};\n/**\n * Returns true if the cartographic is on or inside the rectangle, false otherwise.\n *\n * @param {Rectangle} rectangle The rectangle\n * @param {Cartographic} cartographic The cartographic to test.\n * @returns {Boolean} true if the provided cartographic is inside the rectangle, false otherwise.\n */\n\n\nRectangle.contains = function (rectangle, cartographic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"cartographic\", cartographic); //>>includeEnd('debug');\n\n  var longitude = cartographic.longitude;\n  var latitude = cartographic.latitude;\n  var west = rectangle.west;\n  var east = rectangle.east;\n\n  if (east < west) {\n    east += CesiumMath.TWO_PI;\n\n    if (longitude < 0.0) {\n      longitude += CesiumMath.TWO_PI;\n    }\n  }\n\n  return (longitude > west || CesiumMath.equalsEpsilon(longitude, west, CesiumMath.EPSILON14)) && (longitude < east || CesiumMath.equalsEpsilon(longitude, east, CesiumMath.EPSILON14)) && latitude >= rectangle.south && latitude <= rectangle.north;\n};\n\nvar subsampleLlaScratch = new Cartographic();\n/**\n * Samples a rectangle so that it includes a list of Cartesian points suitable for passing to\n * {@link BoundingSphere#fromPoints}.  Sampling is necessary to account\n * for rectangles that cover the poles or cross the equator.\n *\n * @param {Rectangle} rectangle The rectangle to subsample.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.\n * @param {Number} [surfaceHeight=0.0] The height of the rectangle above the ellipsoid.\n * @param {Cartesian3[]} [result] The array of Cartesians onto which to store the result.\n * @returns {Cartesian3[]} The modified result parameter or a new Array of Cartesians instances if none was provided.\n */\n\nRectangle.subsample = function (rectangle, ellipsoid, surfaceHeight, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle); //>>includeEnd('debug');\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  surfaceHeight = defaultValue(surfaceHeight, 0.0);\n\n  if (!defined(result)) {\n    result = [];\n  }\n\n  var length = 0;\n  var north = rectangle.north;\n  var south = rectangle.south;\n  var east = rectangle.east;\n  var west = rectangle.west;\n  var lla = subsampleLlaScratch;\n  lla.height = surfaceHeight;\n  lla.longitude = west;\n  lla.latitude = north;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n  lla.longitude = east;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n  lla.latitude = south;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n  lla.longitude = west;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n\n  if (north < 0.0) {\n    lla.latitude = north;\n  } else if (south > 0.0) {\n    lla.latitude = south;\n  } else {\n    lla.latitude = 0.0;\n  }\n\n  for (var i = 1; i < 8; ++i) {\n    lla.longitude = -Math.PI + i * CesiumMath.PI_OVER_TWO;\n\n    if (Rectangle.contains(rectangle, lla)) {\n      result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n      length++;\n    }\n  }\n\n  if (lla.latitude === 0.0) {\n    lla.longitude = west;\n    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n    length++;\n    lla.longitude = east;\n    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n    length++;\n  }\n\n  result.length = length;\n  return result;\n};\n/**\n * The largest possible rectangle.\n *\n * @type {Rectangle}\n * @constant\n */\n\n\nRectangle.MAX_VALUE = Object.freeze(new Rectangle(-Math.PI, -CesiumMath.PI_OVER_TWO, Math.PI, CesiumMath.PI_OVER_TWO));\nexport default Rectangle;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/Rectangle.js"],"names":["Cartographic","Check","defaultValue","defined","Ellipsoid","CesiumMath","Rectangle","west","south","east","north","Object","defineProperties","prototype","width","get","computeWidth","height","computeHeight","packedLength","pack","value","array","startingIndex","typeOf","object","unpack","result","rectangle","TWO_PI","fromDegrees","toRadians","fromRadians","fromCartographicArray","cartographics","Number","MAX_VALUE","westOverIDL","eastOverIDL","i","len","length","position","Math","min","longitude","max","latitude","lonAdjusted","PI","fromCartesianArray","cartesians","ellipsoid","WGS84","cartesianToCartographic","clone","undefined","equalsEpsilon","left","right","absoluteEpsilon","number","abs","equals","other","epsilon","validate","greaterThanOrEquals","PI_OVER_TWO","lessThanOrEquals","southwest","northwest","northeast","southeast","center","negativePiToPi","intersection","otherRectangle","rectangleEast","rectangleWest","otherRectangleEast","otherRectangleWest","simpleIntersection","union","convertLongitudeRange","expand","cartographic","contains","EPSILON14","subsampleLlaScratch","subsample","surfaceHeight","lla","cartographicToCartesian","freeze"],"mappings":"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","sourcesContent":["import Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A two dimensional region specified as longitude and latitude coordinates.\n *\n * @alias Rectangle\n * @constructor\n *\n * @param {Number} [west=0.0] The westernmost longitude, in radians, in the range [-Pi, Pi].\n * @param {Number} [south=0.0] The southernmost latitude, in radians, in the range [-Pi/2, Pi/2].\n * @param {Number} [east=0.0] The easternmost longitude, in radians, in the range [-Pi, Pi].\n * @param {Number} [north=0.0] The northernmost latitude, in radians, in the range [-Pi/2, Pi/2].\n *\n * @see Packable\n */\nfunction Rectangle(west, south, east, north) {\n  /**\n   * The westernmost longitude in radians in the range [-Pi, Pi].\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n  this.west = defaultValue(west, 0.0);\n\n  /**\n   * The southernmost latitude in radians in the range [-Pi/2, Pi/2].\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n  this.south = defaultValue(south, 0.0);\n\n  /**\n   * The easternmost longitude in radians in the range [-Pi, Pi].\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n  this.east = defaultValue(east, 0.0);\n\n  /**\n   * The northernmost latitude in radians in the range [-Pi/2, Pi/2].\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n  this.north = defaultValue(north, 0.0);\n}\n\nObject.defineProperties(Rectangle.prototype, {\n  /**\n   * Gets the width of the rectangle in radians.\n   * @memberof Rectangle.prototype\n   * @type {Number}\n   */\n  width: {\n    get: function () {\n      return Rectangle.computeWidth(this);\n    },\n  },\n\n  /**\n   * Gets the height of the rectangle in radians.\n   * @memberof Rectangle.prototype\n   * @type {Number}\n   */\n  height: {\n    get: function () {\n      return Rectangle.computeHeight(this);\n    },\n  },\n});\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nRectangle.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Rectangle} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nRectangle.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.west;\n  array[startingIndex++] = value.south;\n  array[startingIndex++] = value.east;\n  array[startingIndex] = value.north;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Rectangle} [result] The object into which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.\n */\nRectangle.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  result.west = array[startingIndex++];\n  result.south = array[startingIndex++];\n  result.east = array[startingIndex++];\n  result.north = array[startingIndex];\n  return result;\n};\n\n/**\n * Computes the width of a rectangle in radians.\n * @param {Rectangle} rectangle The rectangle to compute the width of.\n * @returns {Number} The width.\n */\nRectangle.computeWidth = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n  var east = rectangle.east;\n  var west = rectangle.west;\n  if (east < west) {\n    east += CesiumMath.TWO_PI;\n  }\n  return east - west;\n};\n\n/**\n * Computes the height of a rectangle in radians.\n * @param {Rectangle} rectangle The rectangle to compute the height of.\n * @returns {Number} The height.\n */\nRectangle.computeHeight = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n  return rectangle.north - rectangle.south;\n};\n\n/**\n * Creates a rectangle given the boundary longitude and latitude in degrees.\n *\n * @param {Number} [west=0.0] The westernmost longitude in degrees in the range [-180.0, 180.0].\n * @param {Number} [south=0.0] The southernmost latitude in degrees in the range [-90.0, 90.0].\n * @param {Number} [east=0.0] The easternmost longitude in degrees in the range [-180.0, 180.0].\n * @param {Number} [north=0.0] The northernmost latitude in degrees in the range [-90.0, 90.0].\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n *\n * @example\n * var rectangle = Cesium.Rectangle.fromDegrees(0.0, 20.0, 10.0, 30.0);\n */\nRectangle.fromDegrees = function (west, south, east, north, result) {\n  west = CesiumMath.toRadians(defaultValue(west, 0.0));\n  south = CesiumMath.toRadians(defaultValue(south, 0.0));\n  east = CesiumMath.toRadians(defaultValue(east, 0.0));\n  north = CesiumMath.toRadians(defaultValue(north, 0.0));\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n\n  return result;\n};\n\n/**\n * Creates a rectangle given the boundary longitude and latitude in radians.\n *\n * @param {Number} [west=0.0] The westernmost longitude in radians in the range [-Math.PI, Math.PI].\n * @param {Number} [south=0.0] The southernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].\n * @param {Number} [east=0.0] The easternmost longitude in radians in the range [-Math.PI, Math.PI].\n * @param {Number} [north=0.0] The northernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n *\n * @example\n * var rectangle = Cesium.Rectangle.fromRadians(0.0, Math.PI/4, Math.PI/8, 3*Math.PI/4);\n */\nRectangle.fromRadians = function (west, south, east, north, result) {\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = defaultValue(west, 0.0);\n  result.south = defaultValue(south, 0.0);\n  result.east = defaultValue(east, 0.0);\n  result.north = defaultValue(north, 0.0);\n\n  return result;\n};\n\n/**\n * Creates the smallest possible Rectangle that encloses all positions in the provided array.\n *\n * @param {Cartographic[]} cartographics The list of Cartographic instances.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.fromCartographicArray = function (cartographics, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartographics\", cartographics);\n  //>>includeEnd('debug');\n\n  var west = Number.MAX_VALUE;\n  var east = -Number.MAX_VALUE;\n  var westOverIDL = Number.MAX_VALUE;\n  var eastOverIDL = -Number.MAX_VALUE;\n  var south = Number.MAX_VALUE;\n  var north = -Number.MAX_VALUE;\n\n  for (var i = 0, len = cartographics.length; i < len; i++) {\n    var position = cartographics[i];\n    west = Math.min(west, position.longitude);\n    east = Math.max(east, position.longitude);\n    south = Math.min(south, position.latitude);\n    north = Math.max(north, position.latitude);\n\n    var lonAdjusted =\n      position.longitude >= 0\n        ? position.longitude\n        : position.longitude + CesiumMath.TWO_PI;\n    westOverIDL = Math.min(westOverIDL, lonAdjusted);\n    eastOverIDL = Math.max(eastOverIDL, lonAdjusted);\n  }\n\n  if (east - west > eastOverIDL - westOverIDL) {\n    west = westOverIDL;\n    east = eastOverIDL;\n\n    if (east > CesiumMath.PI) {\n      east = east - CesiumMath.TWO_PI;\n    }\n    if (west > CesiumMath.PI) {\n      west = west - CesiumMath.TWO_PI;\n    }\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Creates the smallest possible Rectangle that encloses all positions in the provided array.\n *\n * @param {Cartesian3[]} cartesians The list of Cartesian instances.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid the cartesians are on.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.fromCartesianArray = function (cartesians, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  var west = Number.MAX_VALUE;\n  var east = -Number.MAX_VALUE;\n  var westOverIDL = Number.MAX_VALUE;\n  var eastOverIDL = -Number.MAX_VALUE;\n  var south = Number.MAX_VALUE;\n  var north = -Number.MAX_VALUE;\n\n  for (var i = 0, len = cartesians.length; i < len; i++) {\n    var position = ellipsoid.cartesianToCartographic(cartesians[i]);\n    west = Math.min(west, position.longitude);\n    east = Math.max(east, position.longitude);\n    south = Math.min(south, position.latitude);\n    north = Math.max(north, position.latitude);\n\n    var lonAdjusted =\n      position.longitude >= 0\n        ? position.longitude\n        : position.longitude + CesiumMath.TWO_PI;\n    westOverIDL = Math.min(westOverIDL, lonAdjusted);\n    eastOverIDL = Math.max(eastOverIDL, lonAdjusted);\n  }\n\n  if (east - west > eastOverIDL - westOverIDL) {\n    west = westOverIDL;\n    east = eastOverIDL;\n\n    if (east > CesiumMath.PI) {\n      east = east - CesiumMath.TWO_PI;\n    }\n    if (west > CesiumMath.PI) {\n      west = west - CesiumMath.TWO_PI;\n    }\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Duplicates a Rectangle.\n *\n * @param {Rectangle} rectangle The rectangle to clone.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided. (Returns undefined if rectangle is undefined)\n */\nRectangle.clone = function (rectangle, result) {\n  if (!defined(rectangle)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(\n      rectangle.west,\n      rectangle.south,\n      rectangle.east,\n      rectangle.north\n    );\n  }\n\n  result.west = rectangle.west;\n  result.south = rectangle.south;\n  result.east = rectangle.east;\n  result.north = rectangle.north;\n  return result;\n};\n\n/**\n * Compares the provided Rectangles componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Rectangle} [left] The first Rectangle.\n * @param {Rectangle} [right] The second Rectangle.\n * @param {Number} absoluteEpsilon The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nRectangle.equalsEpsilon = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"absoluteEpsilon\", absoluteEpsilon);\n  //>>includeEnd('debug');\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(left.west - right.west) <= absoluteEpsilon &&\n      Math.abs(left.south - right.south) <= absoluteEpsilon &&\n      Math.abs(left.east - right.east) <= absoluteEpsilon &&\n      Math.abs(left.north - right.north) <= absoluteEpsilon)\n  );\n};\n\n/**\n * Duplicates this Rectangle.\n *\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.prototype.clone = function (result) {\n  return Rectangle.clone(this, result);\n};\n\n/**\n * Compares the provided Rectangle with this Rectangle componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Rectangle} [other] The Rectangle to compare.\n * @returns {Boolean} <code>true</code> if the Rectangles are equal, <code>false</code> otherwise.\n */\nRectangle.prototype.equals = function (other) {\n  return Rectangle.equals(this, other);\n};\n\n/**\n * Compares the provided rectangles and returns <code>true</code> if they are equal,\n * <code>false</code> otherwise.\n *\n * @param {Rectangle} [left] The first Rectangle.\n * @param {Rectangle} [right] The second Rectangle.\n * @returns {Boolean} <code>true</code> if left and right are equal; otherwise <code>false</code>.\n */\nRectangle.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.west === right.west &&\n      left.south === right.south &&\n      left.east === right.east &&\n      left.north === right.north)\n  );\n};\n\n/**\n * Compares the provided Rectangle with this Rectangle componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Rectangle} [other] The Rectangle to compare.\n * @param {Number} epsilon The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if the Rectangles are within the provided epsilon, <code>false</code> otherwise.\n */\nRectangle.prototype.equalsEpsilon = function (other, epsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"epsilon\", epsilon);\n  //>>includeEnd('debug');\n\n  return Rectangle.equalsEpsilon(this, other, epsilon);\n};\n\n/**\n * Checks a Rectangle's properties and throws if they are not in valid ranges.\n *\n * @param {Rectangle} rectangle The rectangle to validate\n *\n * @exception {DeveloperError} <code>north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n */\nRectangle.validate = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n\n  var north = rectangle.north;\n  Check.typeOf.number.greaterThanOrEquals(\n    \"north\",\n    north,\n    -CesiumMath.PI_OVER_TWO\n  );\n  Check.typeOf.number.lessThanOrEquals(\"north\", north, CesiumMath.PI_OVER_TWO);\n\n  var south = rectangle.south;\n  Check.typeOf.number.greaterThanOrEquals(\n    \"south\",\n    south,\n    -CesiumMath.PI_OVER_TWO\n  );\n  Check.typeOf.number.lessThanOrEquals(\"south\", south, CesiumMath.PI_OVER_TWO);\n\n  var west = rectangle.west;\n  Check.typeOf.number.greaterThanOrEquals(\"west\", west, -Math.PI);\n  Check.typeOf.number.lessThanOrEquals(\"west\", west, Math.PI);\n\n  var east = rectangle.east;\n  Check.typeOf.number.greaterThanOrEquals(\"east\", east, -Math.PI);\n  Check.typeOf.number.lessThanOrEquals(\"east\", east, Math.PI);\n  //>>includeEnd('debug');\n};\n\n/**\n * Computes the southwest corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.southwest = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.west, rectangle.south);\n  }\n  result.longitude = rectangle.west;\n  result.latitude = rectangle.south;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the northwest corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.northwest = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.west, rectangle.north);\n  }\n  result.longitude = rectangle.west;\n  result.latitude = rectangle.north;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the northeast corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.northeast = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.east, rectangle.north);\n  }\n  result.longitude = rectangle.east;\n  result.latitude = rectangle.north;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the southeast corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.southeast = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.east, rectangle.south);\n  }\n  result.longitude = rectangle.east;\n  result.latitude = rectangle.south;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the center of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the center\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.center = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  var east = rectangle.east;\n  var west = rectangle.west;\n\n  if (east < west) {\n    east += CesiumMath.TWO_PI;\n  }\n\n  var longitude = CesiumMath.negativePiToPi((west + east) * 0.5);\n  var latitude = (rectangle.south + rectangle.north) * 0.5;\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude);\n  }\n\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the intersection of two rectangles.  This function assumes that the rectangle's coordinates are\n * latitude and longitude in radians and produces a correct intersection, taking into account the fact that\n * the same angle can be represented with multiple values as well as the wrapping of longitude at the\n * anti-meridian.  For a simple intersection that ignores these factors and can be used with projected\n * coordinates, see {@link Rectangle.simpleIntersection}.\n *\n * @param {Rectangle} rectangle On rectangle to find an intersection\n * @param {Rectangle} otherRectangle Another rectangle to find an intersection\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.\n */\nRectangle.intersection = function (rectangle, otherRectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"otherRectangle\", otherRectangle);\n  //>>includeEnd('debug');\n\n  var rectangleEast = rectangle.east;\n  var rectangleWest = rectangle.west;\n\n  var otherRectangleEast = otherRectangle.east;\n  var otherRectangleWest = otherRectangle.west;\n\n  if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {\n    rectangleEast += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {\n    otherRectangleEast += CesiumMath.TWO_PI;\n  }\n\n  if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {\n    otherRectangleWest += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {\n    rectangleWest += CesiumMath.TWO_PI;\n  }\n\n  var west = CesiumMath.negativePiToPi(\n    Math.max(rectangleWest, otherRectangleWest)\n  );\n  var east = CesiumMath.negativePiToPi(\n    Math.min(rectangleEast, otherRectangleEast)\n  );\n\n  if (\n    (rectangle.west < rectangle.east ||\n      otherRectangle.west < otherRectangle.east) &&\n    east <= west\n  ) {\n    return undefined;\n  }\n\n  var south = Math.max(rectangle.south, otherRectangle.south);\n  var north = Math.min(rectangle.north, otherRectangle.north);\n\n  if (south >= north) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Computes a simple intersection of two rectangles.  Unlike {@link Rectangle.intersection}, this function\n * does not attempt to put the angular coordinates into a consistent range or to account for crossing the\n * anti-meridian.  As such, it can be used for rectangles where the coordinates are not simply latitude\n * and longitude (i.e. projected coordinates).\n *\n * @param {Rectangle} rectangle On rectangle to find an intersection\n * @param {Rectangle} otherRectangle Another rectangle to find an intersection\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.\n */\nRectangle.simpleIntersection = function (rectangle, otherRectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"otherRectangle\", otherRectangle);\n  //>>includeEnd('debug');\n\n  var west = Math.max(rectangle.west, otherRectangle.west);\n  var south = Math.max(rectangle.south, otherRectangle.south);\n  var east = Math.min(rectangle.east, otherRectangle.east);\n  var north = Math.min(rectangle.north, otherRectangle.north);\n\n  if (south >= north || west >= east) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Computes a rectangle that is the union of two rectangles.\n *\n * @param {Rectangle} rectangle A rectangle to enclose in rectangle.\n * @param {Rectangle} otherRectangle A rectangle to enclose in a rectangle.\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.union = function (rectangle, otherRectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"otherRectangle\", otherRectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  var rectangleEast = rectangle.east;\n  var rectangleWest = rectangle.west;\n\n  var otherRectangleEast = otherRectangle.east;\n  var otherRectangleWest = otherRectangle.west;\n\n  if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {\n    rectangleEast += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {\n    otherRectangleEast += CesiumMath.TWO_PI;\n  }\n\n  if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {\n    otherRectangleWest += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {\n    rectangleWest += CesiumMath.TWO_PI;\n  }\n\n  var west = CesiumMath.convertLongitudeRange(\n    Math.min(rectangleWest, otherRectangleWest)\n  );\n  var east = CesiumMath.convertLongitudeRange(\n    Math.max(rectangleEast, otherRectangleEast)\n  );\n\n  result.west = west;\n  result.south = Math.min(rectangle.south, otherRectangle.south);\n  result.east = east;\n  result.north = Math.max(rectangle.north, otherRectangle.north);\n\n  return result;\n};\n\n/**\n * Computes a rectangle by enlarging the provided rectangle until it contains the provided cartographic.\n *\n * @param {Rectangle} rectangle A rectangle to expand.\n * @param {Cartographic} cartographic A cartographic to enclose in a rectangle.\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.\n */\nRectangle.expand = function (rectangle, cartographic, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  result.west = Math.min(rectangle.west, cartographic.longitude);\n  result.south = Math.min(rectangle.south, cartographic.latitude);\n  result.east = Math.max(rectangle.east, cartographic.longitude);\n  result.north = Math.max(rectangle.north, cartographic.latitude);\n\n  return result;\n};\n\n/**\n * Returns true if the cartographic is on or inside the rectangle, false otherwise.\n *\n * @param {Rectangle} rectangle The rectangle\n * @param {Cartographic} cartographic The cartographic to test.\n * @returns {Boolean} true if the provided cartographic is inside the rectangle, false otherwise.\n */\nRectangle.contains = function (rectangle, cartographic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  var longitude = cartographic.longitude;\n  var latitude = cartographic.latitude;\n\n  var west = rectangle.west;\n  var east = rectangle.east;\n\n  if (east < west) {\n    east += CesiumMath.TWO_PI;\n    if (longitude < 0.0) {\n      longitude += CesiumMath.TWO_PI;\n    }\n  }\n  return (\n    (longitude > west ||\n      CesiumMath.equalsEpsilon(longitude, west, CesiumMath.EPSILON14)) &&\n    (longitude < east ||\n      CesiumMath.equalsEpsilon(longitude, east, CesiumMath.EPSILON14)) &&\n    latitude >= rectangle.south &&\n    latitude <= rectangle.north\n  );\n};\n\nvar subsampleLlaScratch = new Cartographic();\n/**\n * Samples a rectangle so that it includes a list of Cartesian points suitable for passing to\n * {@link BoundingSphere#fromPoints}.  Sampling is necessary to account\n * for rectangles that cover the poles or cross the equator.\n *\n * @param {Rectangle} rectangle The rectangle to subsample.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.\n * @param {Number} [surfaceHeight=0.0] The height of the rectangle above the ellipsoid.\n * @param {Cartesian3[]} [result] The array of Cartesians onto which to store the result.\n * @returns {Cartesian3[]} The modified result parameter or a new Array of Cartesians instances if none was provided.\n */\nRectangle.subsample = function (rectangle, ellipsoid, surfaceHeight, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  surfaceHeight = defaultValue(surfaceHeight, 0.0);\n\n  if (!defined(result)) {\n    result = [];\n  }\n  var length = 0;\n\n  var north = rectangle.north;\n  var south = rectangle.south;\n  var east = rectangle.east;\n  var west = rectangle.west;\n\n  var lla = subsampleLlaScratch;\n  lla.height = surfaceHeight;\n\n  lla.longitude = west;\n  lla.latitude = north;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n\n  lla.longitude = east;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n\n  lla.latitude = south;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n\n  lla.longitude = west;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n\n  if (north < 0.0) {\n    lla.latitude = north;\n  } else if (south > 0.0) {\n    lla.latitude = south;\n  } else {\n    lla.latitude = 0.0;\n  }\n\n  for (var i = 1; i < 8; ++i) {\n    lla.longitude = -Math.PI + i * CesiumMath.PI_OVER_TWO;\n    if (Rectangle.contains(rectangle, lla)) {\n      result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n      length++;\n    }\n  }\n\n  if (lla.latitude === 0.0) {\n    lla.longitude = west;\n    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n    length++;\n    lla.longitude = east;\n    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n    length++;\n  }\n  result.length = length;\n  return result;\n};\n\n/**\n * The largest possible rectangle.\n *\n * @type {Rectangle}\n * @constant\n */\nRectangle.MAX_VALUE = Object.freeze(\n  new Rectangle(\n    -Math.PI,\n    -CesiumMath.PI_OVER_TWO,\n    Math.PI,\n    CesiumMath.PI_OVER_TWO\n  )\n);\nexport default Rectangle;\n"]},"metadata":{},"sourceType":"module"}