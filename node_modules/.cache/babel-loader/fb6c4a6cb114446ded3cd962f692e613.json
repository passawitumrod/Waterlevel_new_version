{"ast":null,"code":"import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport Intersections2D from \"./Intersections2D.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport QuantizedMeshTerrainData from \"./QuantizedMeshTerrainData.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport TerrainMesh from \"./TerrainMesh.js\";\n/**\n * Terrain data for a single tile from a Google Earth Enterprise server.\n *\n * @alias GoogleEarthEnterpriseTerrainData\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {ArrayBuffer} options.buffer The buffer containing terrain data.\n * @param {Number} options.negativeAltitudeExponentBias Multiplier for negative terrain heights that are encoded as very small positive values.\n * @param {Number} options.negativeElevationThreshold Threshold for negative values\n * @param {Number} [options.childTileMask=15] A bit mask indicating which of this tile's four children exist.\n *                 If a child's bit is set, geometry will be requested for that tile as well when it\n *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is\n *                 instead upsampled from the parent.  The bit values are as follows:\n *                 <table>\n *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *                  <tr><td>2</td><td>4</td><td>Northeast</td></tr>\n *                  <tr><td>3</td><td>8</td><td>Northwest</td></tr>\n *                 </table>\n * @param {Boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;\n *                  otherwise, false.\n * @param {Credit[]} [options.credits] Array of credits for this tile.\n *\n *\n * @example\n * var buffer = ...\n * var childTileMask = ...\n * var terrainData = new Cesium.GoogleEarthEnterpriseTerrainData({\n *   buffer : heightBuffer,\n *   childTileMask : childTileMask\n * });\n *\n * @see TerrainData\n * @see HeightmapTerrainData\n * @see QuantizedMeshTerrainData\n */\n\nfunction GoogleEarthEnterpriseTerrainData(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);\n\n  Check.typeOf.object(\"options.buffer\", options.buffer);\n  Check.typeOf.number(\"options.negativeAltitudeExponentBias\", options.negativeAltitudeExponentBias);\n  Check.typeOf.number(\"options.negativeElevationThreshold\", options.negativeElevationThreshold); //>>includeEnd('debug');\n\n  this._buffer = options.buffer;\n  this._credits = options.credits;\n  this._negativeAltitudeExponentBias = options.negativeAltitudeExponentBias;\n  this._negativeElevationThreshold = options.negativeElevationThreshold; // Convert from google layout to layout of other providers\n  // 3 2 -> 2 3\n  // 0 1 -> 0 1\n\n  var googleChildTileMask = defaultValue(options.childTileMask, 15);\n  var childTileMask = googleChildTileMask & 3; // Bottom row is identical\n\n  childTileMask |= googleChildTileMask & 4 ? 8 : 0; // NE\n\n  childTileMask |= googleChildTileMask & 8 ? 4 : 0; // NW\n\n  this._childTileMask = childTileMask;\n  this._createdByUpsampling = defaultValue(options.createdByUpsampling, false);\n  this._skirtHeight = undefined;\n  this._bufferType = this._buffer.constructor;\n  this._mesh = undefined;\n  this._minimumHeight = undefined;\n  this._maximumHeight = undefined;\n}\n\nObject.defineProperties(GoogleEarthEnterpriseTerrainData.prototype, {\n  /**\n   * An array of credits for this tile\n   * @memberof GoogleEarthEnterpriseTerrainData.prototype\n   * @type {Credit[]}\n   */\n  credits: {\n    get: function () {\n      return this._credits;\n    }\n  },\n\n  /**\n   * The water mask included in this terrain data, if any.  A water mask is a rectangular\n   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n   * @memberof GoogleEarthEnterpriseTerrainData.prototype\n   * @type {Uint8Array|Image|Canvas}\n   */\n  waterMask: {\n    get: function () {\n      return undefined;\n    }\n  }\n});\nvar taskProcessor = new TaskProcessor(\"createVerticesFromGoogleEarthEnterpriseBuffer\");\nvar nativeRectangleScratch = new Rectangle();\nvar rectangleScratch = new Rectangle();\n/**\n * Creates a {@link TerrainMesh} from this terrain data.\n *\n * @private\n *\n * @param {TilingScheme} tilingScheme The tiling scheme to which this tile belongs.\n * @param {Number} x The X coordinate of the tile for which to create the terrain data.\n * @param {Number} y The Y coordinate of the tile for which to create the terrain data.\n * @param {Number} level The level of the tile for which to create the terrain data.\n * @param {Number} [exaggeration=1.0] The scale used to exaggerate the terrain.\n * @returns {Promise.<TerrainMesh>|undefined} A promise for the terrain mesh, or undefined if too many\n *          asynchronous mesh creations are already in progress and the operation should\n *          be retried later.\n */\n\nGoogleEarthEnterpriseTerrainData.prototype.createMesh = function (tilingScheme, x, y, level, exaggeration) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"tilingScheme\", tilingScheme);\n  Check.typeOf.number(\"x\", x);\n  Check.typeOf.number(\"y\", y);\n  Check.typeOf.number(\"level\", level); //>>includeEnd('debug');\n\n  var ellipsoid = tilingScheme.ellipsoid;\n  tilingScheme.tileXYToNativeRectangle(x, y, level, nativeRectangleScratch);\n  tilingScheme.tileXYToRectangle(x, y, level, rectangleScratch);\n  exaggeration = defaultValue(exaggeration, 1.0); // Compute the center of the tile for RTC rendering.\n\n  var center = ellipsoid.cartographicToCartesian(Rectangle.center(rectangleScratch));\n  var levelZeroMaxError = 40075.16; // From Google's Doc\n\n  var thisLevelMaxError = levelZeroMaxError / (1 << level);\n  this._skirtHeight = Math.min(thisLevelMaxError * 8.0, 1000.0);\n  var verticesPromise = taskProcessor.scheduleTask({\n    buffer: this._buffer,\n    nativeRectangle: nativeRectangleScratch,\n    rectangle: rectangleScratch,\n    relativeToCenter: center,\n    ellipsoid: ellipsoid,\n    skirtHeight: this._skirtHeight,\n    exaggeration: exaggeration,\n    includeWebMercatorT: true,\n    negativeAltitudeExponentBias: this._negativeAltitudeExponentBias,\n    negativeElevationThreshold: this._negativeElevationThreshold\n  });\n\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  var that = this;\n  return verticesPromise.then(function (result) {\n    // Clone complex result objects because the transfer from the web worker\n    // has stripped them down to JSON-style objects.\n    that._mesh = new TerrainMesh(center, new Float32Array(result.vertices), new Uint16Array(result.indices), result.indexCountWithoutSkirts, result.vertexCountWithoutSkirts, result.minimumHeight, result.maximumHeight, BoundingSphere.clone(result.boundingSphere3D), Cartesian3.clone(result.occludeePointInScaledSpace), result.numberOfAttributes, OrientedBoundingBox.clone(result.orientedBoundingBox), TerrainEncoding.clone(result.encoding), exaggeration, result.westIndicesSouthToNorth, result.southIndicesEastToWest, result.eastIndicesNorthToSouth, result.northIndicesWestToEast);\n    that._minimumHeight = result.minimumHeight;\n    that._maximumHeight = result.maximumHeight; // Free memory received from server after mesh is created.\n\n    that._buffer = undefined;\n    return that._mesh;\n  });\n};\n/**\n * Computes the terrain height at a specified longitude and latitude.\n *\n * @param {Rectangle} rectangle The rectangle covered by this terrain data.\n * @param {Number} longitude The longitude in radians.\n * @param {Number} latitude The latitude in radians.\n * @returns {Number} The terrain height at the specified position.  If the position\n *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly\n *          incorrect for positions far outside the rectangle.\n */\n\n\nGoogleEarthEnterpriseTerrainData.prototype.interpolateHeight = function (rectangle, longitude, latitude) {\n  var u = CesiumMath.clamp((longitude - rectangle.west) / rectangle.width, 0.0, 1.0);\n  var v = CesiumMath.clamp((latitude - rectangle.south) / rectangle.height, 0.0, 1.0);\n\n  if (!defined(this._mesh)) {\n    return interpolateHeight(this, u, v, rectangle);\n  }\n\n  return interpolateMeshHeight(this, u, v);\n};\n\nvar upsampleTaskProcessor = new TaskProcessor(\"upsampleQuantizedTerrainMesh\");\n/**\n * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the\n * height samples in this instance, interpolated if necessary.\n *\n * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.\n * @param {Number} thisX The X coordinate of this tile in the tiling scheme.\n * @param {Number} thisY The Y coordinate of this tile in the tiling scheme.\n * @param {Number} thisLevel The level of this tile in the tiling scheme.\n * @param {Number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.\n * @returns {Promise.<HeightmapTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,\n *          or undefined if too many asynchronous upsample operations are in progress and the request has been\n *          deferred.\n */\n\nGoogleEarthEnterpriseTerrainData.prototype.upsample = function (tilingScheme, thisX, thisY, thisLevel, descendantX, descendantY, descendantLevel) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"tilingScheme\", tilingScheme);\n  Check.typeOf.number(\"thisX\", thisX);\n  Check.typeOf.number(\"thisY\", thisY);\n  Check.typeOf.number(\"thisLevel\", thisLevel);\n  Check.typeOf.number(\"descendantX\", descendantX);\n  Check.typeOf.number(\"descendantY\", descendantY);\n  Check.typeOf.number(\"descendantLevel\", descendantLevel);\n  var levelDifference = descendantLevel - thisLevel;\n\n  if (levelDifference > 1) {\n    throw new DeveloperError(\"Upsampling through more than one level at a time is not currently supported.\");\n  } //>>includeEnd('debug');\n\n\n  var mesh = this._mesh;\n\n  if (!defined(this._mesh)) {\n    return undefined;\n  }\n\n  var isEastChild = thisX * 2 !== descendantX;\n  var isNorthChild = thisY * 2 === descendantY;\n  var ellipsoid = tilingScheme.ellipsoid;\n  var childRectangle = tilingScheme.tileXYToRectangle(descendantX, descendantY, descendantLevel);\n  var upsamplePromise = upsampleTaskProcessor.scheduleTask({\n    vertices: mesh.vertices,\n    indices: mesh.indices,\n    indexCountWithoutSkirts: mesh.indexCountWithoutSkirts,\n    vertexCountWithoutSkirts: mesh.vertexCountWithoutSkirts,\n    encoding: mesh.encoding,\n    minimumHeight: this._minimumHeight,\n    maximumHeight: this._maximumHeight,\n    isEastChild: isEastChild,\n    isNorthChild: isNorthChild,\n    childRectangle: childRectangle,\n    ellipsoid: ellipsoid,\n    exaggeration: mesh.exaggeration\n  });\n\n  if (!defined(upsamplePromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  var that = this;\n  return upsamplePromise.then(function (result) {\n    var quantizedVertices = new Uint16Array(result.vertices);\n    var indicesTypedArray = IndexDatatype.createTypedArray(quantizedVertices.length / 3, result.indices);\n    var skirtHeight = that._skirtHeight; // Use QuantizedMeshTerrainData since we have what we need already parsed\n\n    return new QuantizedMeshTerrainData({\n      quantizedVertices: quantizedVertices,\n      indices: indicesTypedArray,\n      minimumHeight: result.minimumHeight,\n      maximumHeight: result.maximumHeight,\n      boundingSphere: BoundingSphere.clone(result.boundingSphere),\n      orientedBoundingBox: OrientedBoundingBox.clone(result.orientedBoundingBox),\n      horizonOcclusionPoint: Cartesian3.clone(result.horizonOcclusionPoint),\n      westIndices: result.westIndices,\n      southIndices: result.southIndices,\n      eastIndices: result.eastIndices,\n      northIndices: result.northIndices,\n      westSkirtHeight: skirtHeight,\n      southSkirtHeight: skirtHeight,\n      eastSkirtHeight: skirtHeight,\n      northSkirtHeight: skirtHeight,\n      childTileMask: 0,\n      createdByUpsampling: true,\n      credits: that._credits\n    });\n  });\n};\n/**\n * Determines if a given child tile is available, based on the\n * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed\n * to be one of the four children of this tile.  If non-child tile coordinates are\n * given, the availability of the southeast child tile is returned.\n *\n * @param {Number} thisX The tile X coordinate of this (the parent) tile.\n * @param {Number} thisY The tile Y coordinate of this (the parent) tile.\n * @param {Number} childX The tile X coordinate of the child tile to check for availability.\n * @param {Number} childY The tile Y coordinate of the child tile to check for availability.\n * @returns {Boolean} True if the child tile is available; otherwise, false.\n */\n\n\nGoogleEarthEnterpriseTerrainData.prototype.isChildAvailable = function (thisX, thisY, childX, childY) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"thisX\", thisX);\n  Check.typeOf.number(\"thisY\", thisY);\n  Check.typeOf.number(\"childX\", childX);\n  Check.typeOf.number(\"childY\", childY); //>>includeEnd('debug');\n\n  var bitNumber = 2; // northwest child\n\n  if (childX !== thisX * 2) {\n    ++bitNumber; // east child\n  }\n\n  if (childY !== thisY * 2) {\n    bitNumber -= 2; // south child\n  }\n\n  return (this._childTileMask & 1 << bitNumber) !== 0;\n};\n/**\n * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution\n * terrain data.  If this value is false, the data was obtained from some other source, such\n * as by downloading it from a remote server.  This method should return true for instances\n * returned from a call to {@link HeightmapTerrainData#upsample}.\n *\n * @returns {Boolean} True if this instance was created by upsampling; otherwise, false.\n */\n\n\nGoogleEarthEnterpriseTerrainData.prototype.wasCreatedByUpsampling = function () {\n  return this._createdByUpsampling;\n};\n\nvar texCoordScratch0 = new Cartesian2();\nvar texCoordScratch1 = new Cartesian2();\nvar texCoordScratch2 = new Cartesian2();\nvar barycentricCoordinateScratch = new Cartesian3();\n\nfunction interpolateMeshHeight(terrainData, u, v) {\n  var mesh = terrainData._mesh;\n  var vertices = mesh.vertices;\n  var encoding = mesh.encoding;\n  var indices = mesh.indices;\n\n  for (var i = 0, len = indices.length; i < len; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n    var uv0 = encoding.decodeTextureCoordinates(vertices, i0, texCoordScratch0);\n    var uv1 = encoding.decodeTextureCoordinates(vertices, i1, texCoordScratch1);\n    var uv2 = encoding.decodeTextureCoordinates(vertices, i2, texCoordScratch2);\n    var barycentric = Intersections2D.computeBarycentricCoordinates(u, v, uv0.x, uv0.y, uv1.x, uv1.y, uv2.x, uv2.y, barycentricCoordinateScratch);\n\n    if (barycentric.x >= -1e-15 && barycentric.y >= -1e-15 && barycentric.z >= -1e-15) {\n      var h0 = encoding.decodeHeight(vertices, i0);\n      var h1 = encoding.decodeHeight(vertices, i1);\n      var h2 = encoding.decodeHeight(vertices, i2);\n      return barycentric.x * h0 + barycentric.y * h1 + barycentric.z * h2;\n    }\n  } // Position does not lie in any triangle in this mesh.\n\n\n  return undefined;\n}\n\nvar sizeOfUint16 = Uint16Array.BYTES_PER_ELEMENT;\nvar sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\nvar sizeOfInt32 = Int32Array.BYTES_PER_ELEMENT;\nvar sizeOfFloat = Float32Array.BYTES_PER_ELEMENT;\nvar sizeOfDouble = Float64Array.BYTES_PER_ELEMENT;\n\nfunction interpolateHeight(terrainData, u, v, rectangle) {\n  var buffer = terrainData._buffer;\n  var quad = 0; // SW\n\n  var uStart = 0.0;\n  var vStart = 0.0;\n\n  if (v > 0.5) {\n    // Upper row\n    if (u > 0.5) {\n      // NE\n      quad = 2;\n      uStart = 0.5;\n    } else {\n      // NW\n      quad = 3;\n    }\n\n    vStart = 0.5;\n  } else if (u > 0.5) {\n    // SE\n    quad = 1;\n    uStart = 0.5;\n  }\n\n  var dv = new DataView(buffer);\n  var offset = 0;\n\n  for (var q = 0; q < quad; ++q) {\n    offset += dv.getUint32(offset, true);\n    offset += sizeOfUint32;\n  }\n\n  offset += sizeOfUint32; // Skip length of quad\n\n  offset += 2 * sizeOfDouble; // Skip origin\n  // Read sizes\n\n  var xSize = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\n  offset += sizeOfDouble;\n  var ySize = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\n  offset += sizeOfDouble; // Samples per quad\n\n  var xScale = rectangle.width / xSize / 2;\n  var yScale = rectangle.height / ySize / 2; // Number of points\n\n  var numPoints = dv.getInt32(offset, true);\n  offset += sizeOfInt32; // Number of faces\n\n  var numIndices = dv.getInt32(offset, true) * 3;\n  offset += sizeOfInt32;\n  offset += sizeOfInt32; // Skip Level\n\n  var uBuffer = new Array(numPoints);\n  var vBuffer = new Array(numPoints);\n  var heights = new Array(numPoints);\n  var i;\n\n  for (i = 0; i < numPoints; ++i) {\n    uBuffer[i] = uStart + dv.getUint8(offset++) * xScale;\n    vBuffer[i] = vStart + dv.getUint8(offset++) * yScale; // Height is stored in units of (1/EarthRadius) or (1/6371010.0)\n\n    heights[i] = dv.getFloat32(offset, true) * 6371010.0;\n    offset += sizeOfFloat;\n  }\n\n  var indices = new Array(numIndices);\n\n  for (i = 0; i < numIndices; ++i) {\n    indices[i] = dv.getUint16(offset, true);\n    offset += sizeOfUint16;\n  }\n\n  for (i = 0; i < numIndices; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n    var u0 = uBuffer[i0];\n    var u1 = uBuffer[i1];\n    var u2 = uBuffer[i2];\n    var v0 = vBuffer[i0];\n    var v1 = vBuffer[i1];\n    var v2 = vBuffer[i2];\n    var barycentric = Intersections2D.computeBarycentricCoordinates(u, v, u0, v0, u1, v1, u2, v2, barycentricCoordinateScratch);\n\n    if (barycentric.x >= -1e-15 && barycentric.y >= -1e-15 && barycentric.z >= -1e-15) {\n      return barycentric.x * heights[i0] + barycentric.y * heights[i1] + barycentric.z * heights[i2];\n    }\n  } // Position does not lie in any triangle in this mesh.\n\n\n  return undefined;\n}\n\nexport default GoogleEarthEnterpriseTerrainData;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/GoogleEarthEnterpriseTerrainData.js"],"names":["BoundingSphere","Cartesian2","Cartesian3","Check","defaultValue","defined","DeveloperError","IndexDatatype","Intersections2D","CesiumMath","OrientedBoundingBox","QuantizedMeshTerrainData","Rectangle","TaskProcessor","TerrainEncoding","TerrainMesh","GoogleEarthEnterpriseTerrainData","options","EMPTY_OBJECT","typeOf","object","buffer","number","negativeAltitudeExponentBias","negativeElevationThreshold","_buffer","_credits","credits","_negativeAltitudeExponentBias","_negativeElevationThreshold","googleChildTileMask","childTileMask","_childTileMask","_createdByUpsampling","createdByUpsampling","_skirtHeight","undefined","_bufferType","constructor","_mesh","_minimumHeight","_maximumHeight","Object","defineProperties","prototype","get","waterMask","taskProcessor","nativeRectangleScratch","rectangleScratch","createMesh","tilingScheme","x","y","level","exaggeration","ellipsoid","tileXYToNativeRectangle","tileXYToRectangle","center","cartographicToCartesian","levelZeroMaxError","thisLevelMaxError","Math","min","verticesPromise","scheduleTask","nativeRectangle","rectangle","relativeToCenter","skirtHeight","includeWebMercatorT","that","then","result","Float32Array","vertices","Uint16Array","indices","indexCountWithoutSkirts","vertexCountWithoutSkirts","minimumHeight","maximumHeight","clone","boundingSphere3D","occludeePointInScaledSpace","numberOfAttributes","orientedBoundingBox","encoding","westIndicesSouthToNorth","southIndicesEastToWest","eastIndicesNorthToSouth","northIndicesWestToEast","interpolateHeight","longitude","latitude","u","clamp","west","width","v","south","height","interpolateMeshHeight","upsampleTaskProcessor","upsample","thisX","thisY","thisLevel","descendantX","descendantY","descendantLevel","levelDifference","mesh","isEastChild","isNorthChild","childRectangle","upsamplePromise","quantizedVertices","indicesTypedArray","createTypedArray","length","boundingSphere","horizonOcclusionPoint","westIndices","southIndices","eastIndices","northIndices","westSkirtHeight","southSkirtHeight","eastSkirtHeight","northSkirtHeight","isChildAvailable","childX","childY","bitNumber","wasCreatedByUpsampling","texCoordScratch0","texCoordScratch1","texCoordScratch2","barycentricCoordinateScratch","terrainData","i","len","i0","i1","i2","uv0","decodeTextureCoordinates","uv1","uv2","barycentric","computeBarycentricCoordinates","z","h0","decodeHeight","h1","h2","sizeOfUint16","BYTES_PER_ELEMENT","sizeOfUint32","Uint32Array","sizeOfInt32","Int32Array","sizeOfFloat","sizeOfDouble","Float64Array","quad","uStart","vStart","dv","DataView","offset","q","getUint32","xSize","toRadians","getFloat64","ySize","xScale","yScale","numPoints","getInt32","numIndices","uBuffer","Array","vBuffer","heights","getUint8","getFloat32","getUint16","u0","u1","u2","v0","v1","v2"],"mappings":"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","sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport Intersections2D from \"./Intersections2D.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport QuantizedMeshTerrainData from \"./QuantizedMeshTerrainData.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport TerrainMesh from \"./TerrainMesh.js\";\n\n/**\n * Terrain data for a single tile from a Google Earth Enterprise server.\n *\n * @alias GoogleEarthEnterpriseTerrainData\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {ArrayBuffer} options.buffer The buffer containing terrain data.\n * @param {Number} options.negativeAltitudeExponentBias Multiplier for negative terrain heights that are encoded as very small positive values.\n * @param {Number} options.negativeElevationThreshold Threshold for negative values\n * @param {Number} [options.childTileMask=15] A bit mask indicating which of this tile's four children exist.\n *                 If a child's bit is set, geometry will be requested for that tile as well when it\n *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is\n *                 instead upsampled from the parent.  The bit values are as follows:\n *                 <table>\n *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *                  <tr><td>2</td><td>4</td><td>Northeast</td></tr>\n *                  <tr><td>3</td><td>8</td><td>Northwest</td></tr>\n *                 </table>\n * @param {Boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;\n *                  otherwise, false.\n * @param {Credit[]} [options.credits] Array of credits for this tile.\n *\n *\n * @example\n * var buffer = ...\n * var childTileMask = ...\n * var terrainData = new Cesium.GoogleEarthEnterpriseTerrainData({\n *   buffer : heightBuffer,\n *   childTileMask : childTileMask\n * });\n *\n * @see TerrainData\n * @see HeightmapTerrainData\n * @see QuantizedMeshTerrainData\n */\nfunction GoogleEarthEnterpriseTerrainData(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.buffer\", options.buffer);\n  Check.typeOf.number(\n    \"options.negativeAltitudeExponentBias\",\n    options.negativeAltitudeExponentBias\n  );\n  Check.typeOf.number(\n    \"options.negativeElevationThreshold\",\n    options.negativeElevationThreshold\n  );\n  //>>includeEnd('debug');\n\n  this._buffer = options.buffer;\n  this._credits = options.credits;\n  this._negativeAltitudeExponentBias = options.negativeAltitudeExponentBias;\n  this._negativeElevationThreshold = options.negativeElevationThreshold;\n\n  // Convert from google layout to layout of other providers\n  // 3 2 -> 2 3\n  // 0 1 -> 0 1\n  var googleChildTileMask = defaultValue(options.childTileMask, 15);\n  var childTileMask = googleChildTileMask & 3; // Bottom row is identical\n  childTileMask |= googleChildTileMask & 4 ? 8 : 0; // NE\n  childTileMask |= googleChildTileMask & 8 ? 4 : 0; // NW\n\n  this._childTileMask = childTileMask;\n\n  this._createdByUpsampling = defaultValue(options.createdByUpsampling, false);\n\n  this._skirtHeight = undefined;\n  this._bufferType = this._buffer.constructor;\n  this._mesh = undefined;\n  this._minimumHeight = undefined;\n  this._maximumHeight = undefined;\n}\n\nObject.defineProperties(GoogleEarthEnterpriseTerrainData.prototype, {\n  /**\n   * An array of credits for this tile\n   * @memberof GoogleEarthEnterpriseTerrainData.prototype\n   * @type {Credit[]}\n   */\n  credits: {\n    get: function () {\n      return this._credits;\n    },\n  },\n  /**\n   * The water mask included in this terrain data, if any.  A water mask is a rectangular\n   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n   * @memberof GoogleEarthEnterpriseTerrainData.prototype\n   * @type {Uint8Array|Image|Canvas}\n   */\n  waterMask: {\n    get: function () {\n      return undefined;\n    },\n  },\n});\n\nvar taskProcessor = new TaskProcessor(\n  \"createVerticesFromGoogleEarthEnterpriseBuffer\"\n);\n\nvar nativeRectangleScratch = new Rectangle();\nvar rectangleScratch = new Rectangle();\n\n/**\n * Creates a {@link TerrainMesh} from this terrain data.\n *\n * @private\n *\n * @param {TilingScheme} tilingScheme The tiling scheme to which this tile belongs.\n * @param {Number} x The X coordinate of the tile for which to create the terrain data.\n * @param {Number} y The Y coordinate of the tile for which to create the terrain data.\n * @param {Number} level The level of the tile for which to create the terrain data.\n * @param {Number} [exaggeration=1.0] The scale used to exaggerate the terrain.\n * @returns {Promise.<TerrainMesh>|undefined} A promise for the terrain mesh, or undefined if too many\n *          asynchronous mesh creations are already in progress and the operation should\n *          be retried later.\n */\nGoogleEarthEnterpriseTerrainData.prototype.createMesh = function (\n  tilingScheme,\n  x,\n  y,\n  level,\n  exaggeration\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"tilingScheme\", tilingScheme);\n  Check.typeOf.number(\"x\", x);\n  Check.typeOf.number(\"y\", y);\n  Check.typeOf.number(\"level\", level);\n  //>>includeEnd('debug');\n\n  var ellipsoid = tilingScheme.ellipsoid;\n  tilingScheme.tileXYToNativeRectangle(x, y, level, nativeRectangleScratch);\n  tilingScheme.tileXYToRectangle(x, y, level, rectangleScratch);\n  exaggeration = defaultValue(exaggeration, 1.0);\n\n  // Compute the center of the tile for RTC rendering.\n  var center = ellipsoid.cartographicToCartesian(\n    Rectangle.center(rectangleScratch)\n  );\n\n  var levelZeroMaxError = 40075.16; // From Google's Doc\n  var thisLevelMaxError = levelZeroMaxError / (1 << level);\n  this._skirtHeight = Math.min(thisLevelMaxError * 8.0, 1000.0);\n\n  var verticesPromise = taskProcessor.scheduleTask({\n    buffer: this._buffer,\n    nativeRectangle: nativeRectangleScratch,\n    rectangle: rectangleScratch,\n    relativeToCenter: center,\n    ellipsoid: ellipsoid,\n    skirtHeight: this._skirtHeight,\n    exaggeration: exaggeration,\n    includeWebMercatorT: true,\n    negativeAltitudeExponentBias: this._negativeAltitudeExponentBias,\n    negativeElevationThreshold: this._negativeElevationThreshold,\n  });\n\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  var that = this;\n  return verticesPromise.then(function (result) {\n    // Clone complex result objects because the transfer from the web worker\n    // has stripped them down to JSON-style objects.\n    that._mesh = new TerrainMesh(\n      center,\n      new Float32Array(result.vertices),\n      new Uint16Array(result.indices),\n      result.indexCountWithoutSkirts,\n      result.vertexCountWithoutSkirts,\n      result.minimumHeight,\n      result.maximumHeight,\n      BoundingSphere.clone(result.boundingSphere3D),\n      Cartesian3.clone(result.occludeePointInScaledSpace),\n      result.numberOfAttributes,\n      OrientedBoundingBox.clone(result.orientedBoundingBox),\n      TerrainEncoding.clone(result.encoding),\n      exaggeration,\n      result.westIndicesSouthToNorth,\n      result.southIndicesEastToWest,\n      result.eastIndicesNorthToSouth,\n      result.northIndicesWestToEast\n    );\n\n    that._minimumHeight = result.minimumHeight;\n    that._maximumHeight = result.maximumHeight;\n\n    // Free memory received from server after mesh is created.\n    that._buffer = undefined;\n    return that._mesh;\n  });\n};\n\n/**\n * Computes the terrain height at a specified longitude and latitude.\n *\n * @param {Rectangle} rectangle The rectangle covered by this terrain data.\n * @param {Number} longitude The longitude in radians.\n * @param {Number} latitude The latitude in radians.\n * @returns {Number} The terrain height at the specified position.  If the position\n *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly\n *          incorrect for positions far outside the rectangle.\n */\nGoogleEarthEnterpriseTerrainData.prototype.interpolateHeight = function (\n  rectangle,\n  longitude,\n  latitude\n) {\n  var u = CesiumMath.clamp(\n    (longitude - rectangle.west) / rectangle.width,\n    0.0,\n    1.0\n  );\n  var v = CesiumMath.clamp(\n    (latitude - rectangle.south) / rectangle.height,\n    0.0,\n    1.0\n  );\n\n  if (!defined(this._mesh)) {\n    return interpolateHeight(this, u, v, rectangle);\n  }\n\n  return interpolateMeshHeight(this, u, v);\n};\n\nvar upsampleTaskProcessor = new TaskProcessor(\"upsampleQuantizedTerrainMesh\");\n\n/**\n * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the\n * height samples in this instance, interpolated if necessary.\n *\n * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.\n * @param {Number} thisX The X coordinate of this tile in the tiling scheme.\n * @param {Number} thisY The Y coordinate of this tile in the tiling scheme.\n * @param {Number} thisLevel The level of this tile in the tiling scheme.\n * @param {Number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.\n * @returns {Promise.<HeightmapTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,\n *          or undefined if too many asynchronous upsample operations are in progress and the request has been\n *          deferred.\n */\nGoogleEarthEnterpriseTerrainData.prototype.upsample = function (\n  tilingScheme,\n  thisX,\n  thisY,\n  thisLevel,\n  descendantX,\n  descendantY,\n  descendantLevel\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"tilingScheme\", tilingScheme);\n  Check.typeOf.number(\"thisX\", thisX);\n  Check.typeOf.number(\"thisY\", thisY);\n  Check.typeOf.number(\"thisLevel\", thisLevel);\n  Check.typeOf.number(\"descendantX\", descendantX);\n  Check.typeOf.number(\"descendantY\", descendantY);\n  Check.typeOf.number(\"descendantLevel\", descendantLevel);\n  var levelDifference = descendantLevel - thisLevel;\n  if (levelDifference > 1) {\n    throw new DeveloperError(\n      \"Upsampling through more than one level at a time is not currently supported.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var mesh = this._mesh;\n  if (!defined(this._mesh)) {\n    return undefined;\n  }\n\n  var isEastChild = thisX * 2 !== descendantX;\n  var isNorthChild = thisY * 2 === descendantY;\n\n  var ellipsoid = tilingScheme.ellipsoid;\n  var childRectangle = tilingScheme.tileXYToRectangle(\n    descendantX,\n    descendantY,\n    descendantLevel\n  );\n\n  var upsamplePromise = upsampleTaskProcessor.scheduleTask({\n    vertices: mesh.vertices,\n    indices: mesh.indices,\n    indexCountWithoutSkirts: mesh.indexCountWithoutSkirts,\n    vertexCountWithoutSkirts: mesh.vertexCountWithoutSkirts,\n    encoding: mesh.encoding,\n    minimumHeight: this._minimumHeight,\n    maximumHeight: this._maximumHeight,\n    isEastChild: isEastChild,\n    isNorthChild: isNorthChild,\n    childRectangle: childRectangle,\n    ellipsoid: ellipsoid,\n    exaggeration: mesh.exaggeration,\n  });\n\n  if (!defined(upsamplePromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  var that = this;\n  return upsamplePromise.then(function (result) {\n    var quantizedVertices = new Uint16Array(result.vertices);\n    var indicesTypedArray = IndexDatatype.createTypedArray(\n      quantizedVertices.length / 3,\n      result.indices\n    );\n\n    var skirtHeight = that._skirtHeight;\n\n    // Use QuantizedMeshTerrainData since we have what we need already parsed\n    return new QuantizedMeshTerrainData({\n      quantizedVertices: quantizedVertices,\n      indices: indicesTypedArray,\n      minimumHeight: result.minimumHeight,\n      maximumHeight: result.maximumHeight,\n      boundingSphere: BoundingSphere.clone(result.boundingSphere),\n      orientedBoundingBox: OrientedBoundingBox.clone(\n        result.orientedBoundingBox\n      ),\n      horizonOcclusionPoint: Cartesian3.clone(result.horizonOcclusionPoint),\n      westIndices: result.westIndices,\n      southIndices: result.southIndices,\n      eastIndices: result.eastIndices,\n      northIndices: result.northIndices,\n      westSkirtHeight: skirtHeight,\n      southSkirtHeight: skirtHeight,\n      eastSkirtHeight: skirtHeight,\n      northSkirtHeight: skirtHeight,\n      childTileMask: 0,\n      createdByUpsampling: true,\n      credits: that._credits,\n    });\n  });\n};\n\n/**\n * Determines if a given child tile is available, based on the\n * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed\n * to be one of the four children of this tile.  If non-child tile coordinates are\n * given, the availability of the southeast child tile is returned.\n *\n * @param {Number} thisX The tile X coordinate of this (the parent) tile.\n * @param {Number} thisY The tile Y coordinate of this (the parent) tile.\n * @param {Number} childX The tile X coordinate of the child tile to check for availability.\n * @param {Number} childY The tile Y coordinate of the child tile to check for availability.\n * @returns {Boolean} True if the child tile is available; otherwise, false.\n */\nGoogleEarthEnterpriseTerrainData.prototype.isChildAvailable = function (\n  thisX,\n  thisY,\n  childX,\n  childY\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"thisX\", thisX);\n  Check.typeOf.number(\"thisY\", thisY);\n  Check.typeOf.number(\"childX\", childX);\n  Check.typeOf.number(\"childY\", childY);\n  //>>includeEnd('debug');\n\n  var bitNumber = 2; // northwest child\n  if (childX !== thisX * 2) {\n    ++bitNumber; // east child\n  }\n  if (childY !== thisY * 2) {\n    bitNumber -= 2; // south child\n  }\n\n  return (this._childTileMask & (1 << bitNumber)) !== 0;\n};\n\n/**\n * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution\n * terrain data.  If this value is false, the data was obtained from some other source, such\n * as by downloading it from a remote server.  This method should return true for instances\n * returned from a call to {@link HeightmapTerrainData#upsample}.\n *\n * @returns {Boolean} True if this instance was created by upsampling; otherwise, false.\n */\nGoogleEarthEnterpriseTerrainData.prototype.wasCreatedByUpsampling = function () {\n  return this._createdByUpsampling;\n};\n\nvar texCoordScratch0 = new Cartesian2();\nvar texCoordScratch1 = new Cartesian2();\nvar texCoordScratch2 = new Cartesian2();\nvar barycentricCoordinateScratch = new Cartesian3();\n\nfunction interpolateMeshHeight(terrainData, u, v) {\n  var mesh = terrainData._mesh;\n  var vertices = mesh.vertices;\n  var encoding = mesh.encoding;\n  var indices = mesh.indices;\n\n  for (var i = 0, len = indices.length; i < len; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n\n    var uv0 = encoding.decodeTextureCoordinates(vertices, i0, texCoordScratch0);\n    var uv1 = encoding.decodeTextureCoordinates(vertices, i1, texCoordScratch1);\n    var uv2 = encoding.decodeTextureCoordinates(vertices, i2, texCoordScratch2);\n\n    var barycentric = Intersections2D.computeBarycentricCoordinates(\n      u,\n      v,\n      uv0.x,\n      uv0.y,\n      uv1.x,\n      uv1.y,\n      uv2.x,\n      uv2.y,\n      barycentricCoordinateScratch\n    );\n    if (\n      barycentric.x >= -1e-15 &&\n      barycentric.y >= -1e-15 &&\n      barycentric.z >= -1e-15\n    ) {\n      var h0 = encoding.decodeHeight(vertices, i0);\n      var h1 = encoding.decodeHeight(vertices, i1);\n      var h2 = encoding.decodeHeight(vertices, i2);\n      return barycentric.x * h0 + barycentric.y * h1 + barycentric.z * h2;\n    }\n  }\n\n  // Position does not lie in any triangle in this mesh.\n  return undefined;\n}\n\nvar sizeOfUint16 = Uint16Array.BYTES_PER_ELEMENT;\nvar sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\nvar sizeOfInt32 = Int32Array.BYTES_PER_ELEMENT;\nvar sizeOfFloat = Float32Array.BYTES_PER_ELEMENT;\nvar sizeOfDouble = Float64Array.BYTES_PER_ELEMENT;\n\nfunction interpolateHeight(terrainData, u, v, rectangle) {\n  var buffer = terrainData._buffer;\n  var quad = 0; // SW\n  var uStart = 0.0;\n  var vStart = 0.0;\n  if (v > 0.5) {\n    // Upper row\n    if (u > 0.5) {\n      // NE\n      quad = 2;\n      uStart = 0.5;\n    } else {\n      // NW\n      quad = 3;\n    }\n    vStart = 0.5;\n  } else if (u > 0.5) {\n    // SE\n    quad = 1;\n    uStart = 0.5;\n  }\n\n  var dv = new DataView(buffer);\n  var offset = 0;\n  for (var q = 0; q < quad; ++q) {\n    offset += dv.getUint32(offset, true);\n    offset += sizeOfUint32;\n  }\n  offset += sizeOfUint32; // Skip length of quad\n  offset += 2 * sizeOfDouble; // Skip origin\n\n  // Read sizes\n  var xSize = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\n  offset += sizeOfDouble;\n  var ySize = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\n  offset += sizeOfDouble;\n\n  // Samples per quad\n  var xScale = rectangle.width / xSize / 2;\n  var yScale = rectangle.height / ySize / 2;\n\n  // Number of points\n  var numPoints = dv.getInt32(offset, true);\n  offset += sizeOfInt32;\n\n  // Number of faces\n  var numIndices = dv.getInt32(offset, true) * 3;\n  offset += sizeOfInt32;\n\n  offset += sizeOfInt32; // Skip Level\n\n  var uBuffer = new Array(numPoints);\n  var vBuffer = new Array(numPoints);\n  var heights = new Array(numPoints);\n  var i;\n  for (i = 0; i < numPoints; ++i) {\n    uBuffer[i] = uStart + dv.getUint8(offset++) * xScale;\n    vBuffer[i] = vStart + dv.getUint8(offset++) * yScale;\n\n    // Height is stored in units of (1/EarthRadius) or (1/6371010.0)\n    heights[i] = dv.getFloat32(offset, true) * 6371010.0;\n    offset += sizeOfFloat;\n  }\n\n  var indices = new Array(numIndices);\n  for (i = 0; i < numIndices; ++i) {\n    indices[i] = dv.getUint16(offset, true);\n    offset += sizeOfUint16;\n  }\n\n  for (i = 0; i < numIndices; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n\n    var u0 = uBuffer[i0];\n    var u1 = uBuffer[i1];\n    var u2 = uBuffer[i2];\n\n    var v0 = vBuffer[i0];\n    var v1 = vBuffer[i1];\n    var v2 = vBuffer[i2];\n\n    var barycentric = Intersections2D.computeBarycentricCoordinates(\n      u,\n      v,\n      u0,\n      v0,\n      u1,\n      v1,\n      u2,\n      v2,\n      barycentricCoordinateScratch\n    );\n    if (\n      barycentric.x >= -1e-15 &&\n      barycentric.y >= -1e-15 &&\n      barycentric.z >= -1e-15\n    ) {\n      return (\n        barycentric.x * heights[i0] +\n        barycentric.y * heights[i1] +\n        barycentric.z * heights[i2]\n      );\n    }\n  }\n\n  // Position does not lie in any triangle in this mesh.\n  return undefined;\n}\nexport default GoogleEarthEnterpriseTerrainData;\n"]},"metadata":{},"sourceType":"module"}